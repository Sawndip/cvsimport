head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.47;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.15;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.28;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.53;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.35;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.37;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/*
 * tkMacDialog.c --
 *
 *	Contains the Mac implementation of the common dialog boxes.
 *
 * Copyright (c) 1996-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkMacDialog.c,v 1.9 2002/04/08 09:04:38 das Exp $
 */

#include <Gestalt.h>
#include <Aliases.h>
#include <Errors.h>
#include <Strings.h>
#include <MoreFiles.h>
#include <MoreFilesExtras.h>
#include <StandardFile.h>
#include <ColorPicker.h>
#include <Lowmem.h>
#include <Navigation.h>
#include "tkPort.h"
#include "tkInt.h"
#include "tclMacInt.h"
#include "tkMacInt.h"
#include "tkFileFilter.h"

#ifndef StrLength
#define StrLength(s) 		(*((unsigned char *) (s)))
#endif
#ifndef StrBody
#define StrBody(s)		((char *) (s) + 1)
#endif

/*
 * The following are ID's for resources that are defined in tkMacResource.r
 */
#define OPEN_BOX        130
#define OPEN_POPUP      131
#define OPEN_MENU       132
#define OPEN_POPUP_ITEM 10

#define SAVE_FILE	0
#define OPEN_FILE	1
#define CHOOSE_FOLDER   2

#define MATCHED		0
#define UNMATCHED	1

/*
 * The following structure is used in the GetFileName() function. It stored
 * information about the file dialog and the file filters.
 */
typedef struct _OpenFileData {
    FileFilterList fl;			/* List of file filters. */
    SInt16 curType;			/* The filetype currently being
					 * listed. */
    short popupItem;			/* Item number of the popup in the
					 * dialog. */
    int usePopup;			/* True if we show the popup menu (this
    					 * is an open operation and the
					 * -filetypes option is set). */
} OpenFileData;


static pascal Boolean	FileFilterProc _ANSI_ARGS_((CInfoPBPtr pb,
			    void *myData));
static int 		GetFileName _ANSI_ARGS_ ((ClientData clientData, 
			    Tcl_Interp *interp, int objc, 
			    Tcl_Obj *CONST objv[], int isOpen));
static int 		NavGetFileName _ANSI_ARGS_ ((ClientData clientData, 
			    Tcl_Interp *interp, int objc, 
			    Tcl_Obj *CONST objv[], int isOpen));
static Boolean		MatchOneType _ANSI_ARGS_((StringPtr fileNamePtr, OSType fileType,
			    OpenFileData *myofdPtr, FileFilter *filterPtr));
static pascal short 	OpenHookProc _ANSI_ARGS_((short item,
			    DialogPtr theDialog, OpenFileData * myofdPtr));
static int 		ParseFileDlgArgs _ANSI_ARGS_ ((Tcl_Interp * interp,
			    OpenFileData * myofdPtr, int argc, char ** argv,
			    int isOpen));
static pascal Boolean   OpenFileFilterProc(AEDesc* theItem, void* info, 
                            NavCallBackUserData callBackUD,
                            NavFilterModes filterMode );
pascal void             OpenEventProc(NavEventCallbackMessage callBackSelector,
                            NavCBRecPtr callBackParms,
                            NavCallBackUserData callBackUD );
static void             InitFileDialogs();
static int              StdGetFile(Tcl_Interp *interp, OpenFileData *ofd,
                            unsigned char *initialFile, int isOpen);
static int              NavServicesGetFile(Tcl_Interp *interp, OpenFileData *ofd,
                            AEDesc *initialDesc, unsigned char *initialFile,
                            StringPtr title, StringPtr message, int multiple, int isOpen);
static int              HandleInitialDirectory (Tcl_Interp *interp, char *initialDir, FSSpec *dirSpec, 
                            AEDesc *dirDescPtr);                            
/*
 * Filter and hook functions used by the tk_getOpenFile and tk_getSaveFile
 * commands.
 */

int fileDlgInited = 0;
int useNavServices = 0;
NavObjectFilterUPP openFileFilterUPP;
NavEventUPP openFileEventUPP;

static FileFilterYDUPP openFilter = NULL;
static DlgHookYDUPP openHook = NULL;
static DlgHookYDUPP saveHook = NULL;
  

/*
 *----------------------------------------------------------------------
 *
 * Tk_ChooseColorObjCmd --
 *
 *	This procedure implements the color dialog box for the Mac
 *	platform. See the user documentation for details on what it
 *	does.
 *
 * Results:
 *      A standard Tcl result.
 *
 * Side effects:
 *      See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tk_ChooseColorObjCmd(
    ClientData clientData,	/* Main window associated with interpreter. */
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST objv[])	/* Argument objects. */
{
    Tk_Window parent;
    char *title;
    int i, picked, srcRead, dstWrote;
    long response;
    OSErr err;
    static inited = 0;
    static RGBColor in;
    static CONST char *optionStrings[] = {
	"-initialcolor",    "-parent",	    "-title",	    NULL
    };
    enum options {
	COLOR_INITIAL,	    COLOR_PARENT,   COLOR_TITLE
    };

    if (inited == 0) {
    	/*
    	 * 'in' stores the last color picked.  The next time the color dialog
    	 * pops up, the last color will remain in the dialog.
    	 */
    	 
        in.red = 0xffff;
        in.green = 0xffff;
        in.blue = 0xffff;
        inited = 1;
    }
    
    parent = (Tk_Window) clientData;
    title = "Choose a color:";
    picked = 0;
        
    for (i = 1; i < objc; i += 2) {
    	int index;
    	char *option, *value;
    	
        if (Tcl_GetIndexFromObj(interp, objv[i], optionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (i + 1 == objc) {
	    option = Tcl_GetStringFromObj(objv[i], NULL);
	    Tcl_AppendResult(interp, "value for \"", option, "\" missing", 
		    (char *) NULL);
	    return TCL_ERROR;
	}
	value = Tcl_GetStringFromObj(objv[i + 1], NULL);
	
	switch ((enum options) index) {
	    case COLOR_INITIAL: {
		XColor *colorPtr;

		colorPtr = Tk_GetColor(interp, parent, value);
		if (colorPtr == NULL) {
		    return TCL_ERROR;
		}
		in.red   = colorPtr->red;
		in.green = colorPtr->green;
                in.blue  = colorPtr->blue;
                Tk_FreeColor(colorPtr);
		break;
	    }
	    case COLOR_PARENT: {
		parent = Tk_NameToWindow(interp, value, parent);
		if (parent == NULL) {
		    return TCL_ERROR;
		}
		break;
	    }
	    case COLOR_TITLE: {
	        title = value;
		break;
	    }
	}
    }
        
    /*
     * Use the gestalt manager to determine how to bring
     * up the color picker.  If versin 2.0 isn't available
     * we can assume version 1.0 is available as it comes with
     * Color Quickdraw which Tk requires to run at all.
     */
     
    err = Gestalt(gestaltColorPicker, &response); 
    if ((err == noErr) && (response == 0x0200L)) {
	ColorPickerInfo cpinfo;

        /*
         * Version 2.0 of the color picker is available. Let's use it
         */

    	cpinfo.theColor.profile = 0L;
    	cpinfo.theColor.color.rgb.red   = in.red;
    	cpinfo.theColor.color.rgb.green = in.green;
    	cpinfo.theColor.color.rgb.blue  = in.blue;
    	cpinfo.dstProfile = 0L;
    	cpinfo.flags = kColorPickerCanModifyPalette | kColorPickerCanAnimatePalette;
    	cpinfo.placeWhere = kDeepestColorScreen;
    	cpinfo.pickerType = 0L;
    	cpinfo.eventProc = NULL;
    	cpinfo.colorProc = NULL;
    	cpinfo.colorProcData = NULL;
    	
    	Tcl_UtfToExternal(NULL, NULL, title, -1, 0, NULL, 
		StrBody(cpinfo.prompt), 255, &srcRead, &dstWrote, NULL);
    	StrLength(cpinfo.prompt) = (unsigned char) dstWrote;

        if ((PickColor(&cpinfo) == noErr) && (cpinfo.newColorChosen != 0)) {
            in.red 	= cpinfo.theColor.color.rgb.red;
            in.green 	= cpinfo.theColor.color.rgb.green;
            in.blue 	= cpinfo.theColor.color.rgb.blue;
            picked = 1;
        }
    } else {
    	RGBColor out;
    	Str255 prompt;
    	Point point = {-1, -1};
    	
        /*
         * Use version 1.0 of the color picker
         */
    	
    	Tcl_UtfToExternal(NULL, NULL, title, -1, 0, NULL, StrBody(prompt), 
		255, &srcRead, &dstWrote, NULL);
    	StrLength(prompt) = (unsigned char) dstWrote;

        if (GetColor(point, prompt, &in, &out)) {
            in = out;
            picked = 1;
        }
    } 
    
    if (picked != 0) {
        char result[32];

        sprintf(result, "#%02x%02x%02x", in.red >> 8, in.green >> 8, 
        	in.blue >> 8);
	Tcl_AppendResult(interp, result, NULL);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_GetOpenFileObjCmd --
 *
 *	This procedure implements the "open file" dialog box for the
 *	Mac platform. See the user documentation for details on what
 *	it does.
 *
 * Results:
 *      A standard Tcl result.
 *
 * Side effects:
 *	See user documentation.
 *----------------------------------------------------------------------
 */

int
Tk_GetOpenFileObjCmd(
    ClientData clientData,	/* Main window associated with interpreter. */
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST objv[])	/* Argument objects. */
{
    int i, result, multiple;
    OpenFileData ofd;
    Tk_Window parent;
    Str255 message, title;
    AEDesc initialDesc = {typeNull, NULL};
    FSSpec dirSpec;
    static CONST char *openOptionStrings[] = {
	    "-defaultextension", "-filetypes", 
	    "-initialdir", "-initialfile", 
	    "-message", "-multiple",
	    "-parent",	"-title", 	NULL
    };
    enum openOptions {
	    OPEN_DEFAULT, OPEN_TYPES,	
	    OPEN_INITDIR, OPEN_INITFILE,
	    OPEN_MESSAGE, OPEN_MULTIPLE, 
	    OPEN_PARENT, OPEN_TITLE
    };
    
    if (!fileDlgInited) {
	InitFileDialogs();
    }
    
    result = TCL_ERROR;    
    parent = (Tk_Window) clientData; 
    multiple = false;
    title[0] = 0;
    message[0] = 0;   

    TkInitFileFilters(&ofd.fl);
    
    ofd.curType		= 0;
    ofd.popupItem	= OPEN_POPUP_ITEM;
    ofd.usePopup 	= 1;

    for (i = 1; i < objc; i += 2) {
        char *choice;
	int index, choiceLen;
	char *string;
	int srcRead, dstWrote;

	if (Tcl_GetIndexFromObj(interp, objv[i], openOptionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    result = TCL_ERROR;
	    goto end;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(objv[i], NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    result = TCL_ERROR;
	    goto end;
	}
	
	switch (index) {
	    case OPEN_DEFAULT:
	        break;
	    case OPEN_TYPES:
	        choice = Tcl_GetStringFromObj(objv[i + 1], NULL);
                if (TkGetFileFilters(interp, &ofd.fl, choice, 0) 
                        != TCL_OK) {
                    result = TCL_ERROR;
                    goto end;
                }
	        break;
	    case OPEN_INITDIR:
	        choice = Tcl_GetStringFromObj(objv[i + 1], NULL);
                if (HandleInitialDirectory(interp, choice, &dirSpec, 
                        &initialDesc) != TCL_OK) {
                    result = TCL_ERROR;
                    goto end;
                }
	        break;
	    case OPEN_INITFILE:
	        break;
	    case OPEN_MESSAGE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
	        Tcl_UtfToExternal(NULL, NULL, choice, choiceLen, 
		        0, NULL, StrBody(message), 255, 
		        &srcRead, &dstWrote, NULL);
                message[0] = dstWrote;
	        break;
	    case OPEN_MULTIPLE:
	        if (Tcl_GetBooleanFromObj(interp, objv[i + 1], &multiple) != TCL_OK) {
	            result = TCL_ERROR;
	            goto end;
	        }
	        break;
	    case OPEN_PARENT:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
                parent = Tk_NameToWindow(interp, choice, parent);
	        if (parent == NULL) {
	            result = TCL_ERROR;
	            goto end;
	        }
	        break;
	    case OPEN_TITLE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
	        Tcl_UtfToExternal(NULL, NULL, choice, choiceLen, 
		        0, NULL, StrBody(title), 255, 
		        &srcRead, &dstWrote, NULL);
                title[0] = dstWrote;
	        break;
	}
    }
             
    if (useNavServices) {
        AEDesc *initialPtr = NULL;
        
        if (initialDesc.descriptorType == typeFSS) {
            initialPtr = &initialDesc;
        }
        result = NavServicesGetFile(interp, &ofd, initialPtr, NULL, 
                title, message, multiple, OPEN_FILE);
    } else {
        result = StdGetFile(interp, &ofd, NULL, OPEN_FILE);
    }

    end:
    TkFreeFileFilters(&ofd.fl);
    AEDisposeDesc(&initialDesc);
    
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_GetSaveFileObjCmd --
 *
 *	Same as Tk_GetOpenFileCmd but opens a "save file" dialog box
 *	instead
 *
 * Results:
 *      A standard Tcl result.
 *
 * Side effects:
 *	See user documentation.
 *----------------------------------------------------------------------
 */

int
Tk_GetSaveFileObjCmd(
    ClientData clientData,	/* Main window associated with interpreter. */
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST objv[])	/* Argument objects. */
{
    int i, result;
    Str255 initialFile;
    Tk_Window parent;
    AEDesc initialDesc = {typeNull, NULL};
    FSSpec dirSpec;
    Str255 title, message;
    OpenFileData ofd;
    static CONST char *saveOptionStrings[] = {
	    "-defaultextension", "-filetypes", "-initialdir", "-initialfile", 
	    "-message", "-parent",	"-title", 	NULL
    };
    enum saveOptions {
	    SAVE_DEFAULT,	SAVE_TYPES,	SAVE_INITDIR,	SAVE_INITFILE,
	    SAVE_MESSAGE,	SAVE_PARENT,	SAVE_TITLE
    };

    if (!fileDlgInited) {
	InitFileDialogs();
    }
    
    result = TCL_ERROR;    
    parent = (Tk_Window) clientData;    
    StrLength(initialFile) = 0;
    title[0] = 0;
    message[0] = 0;   
    

    for (i = 1; i < objc; i += 2) {
        char *choice;
	int index, choiceLen;
	char *string;
        Tcl_DString ds;
        int srcRead, dstWrote;

	if (Tcl_GetIndexFromObj(interp, objv[i], saveOptionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(objv[i], NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    return TCL_ERROR;
	}
	switch (index) {
	    case SAVE_DEFAULT:
	        break;
	    case SAVE_TYPES:
	        break;
	    case SAVE_INITDIR:
	        choice = Tcl_GetStringFromObj(objv[i + 1], NULL);
                if (HandleInitialDirectory(interp, choice, &dirSpec, 
                        &initialDesc) != TCL_OK) {
                    result = TCL_ERROR;
                    goto end;
                }
	        break;
	    case SAVE_INITFILE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
                if (Tcl_TranslateFileName(interp, choice, &ds) == NULL) {
                    result = TCL_ERROR;
                    goto end;
                }
                Tcl_UtfToExternal(NULL, NULL, Tcl_DStringValue(&ds), 
        	        Tcl_DStringLength(&ds), 0, NULL, 
		        StrBody(initialFile), 255, &srcRead, &dstWrote, NULL);
                StrLength(initialFile) = (unsigned char) dstWrote;
                Tcl_DStringFree(&ds);            
	        break;
	    case SAVE_MESSAGE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
	        Tcl_UtfToExternal(NULL, NULL, choice, choiceLen, 
		        0, NULL, StrBody(message), 255, 
		        &srcRead, &dstWrote, NULL);
                StrLength(message) = (unsigned char) dstWrote;
	        break;
	    case SAVE_PARENT:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
                parent = Tk_NameToWindow(interp, choice, parent);
	        if (parent == NULL) {
	            result = TCL_ERROR;
	            goto end;
	        }
	        break;
	    case SAVE_TITLE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
	        Tcl_UtfToExternal(NULL, NULL, choice, choiceLen, 
		        0, NULL, StrBody(title), 255, 
		        &srcRead, &dstWrote, NULL);
                StrLength(title) = (unsigned char) dstWrote;
	        break;
	}
    }
         
    TkInitFileFilters(&ofd.fl);
    ofd.usePopup = 0;

    if (useNavServices) {
        AEDesc *initialPtr = NULL;
        
        if (initialDesc.descriptorType == typeFSS) {
            initialPtr = &initialDesc;
        }
        result = NavServicesGetFile(interp, &ofd, initialPtr, initialFile, 
                title, message, false, SAVE_FILE);
    } else {
        result = StdGetFile(interp, NULL, initialFile, SAVE_FILE);
    }

    end:
    
    AEDisposeDesc(&initialDesc);
    
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_ChooseDirectoryObjCmd --
 *
 *	This procedure implements the "tk_chooseDirectory" dialog box 
 *	for the Windows platform. See the user documentation for details 
 *	on what it does.
 *
 * Results:
 *	See user documentation.
 *
 * Side effects:
 *	A modal dialog window is created.  Tcl_SetServiceMode() is
 *	called to allow background events to be processed
 *
 *----------------------------------------------------------------------
 */

int
Tk_ChooseDirectoryObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int i, result;
    Tk_Window parent;
    AEDesc initialDesc = {typeNull, NULL};
    FSSpec dirSpec;
    Str255 message, title;
    int srcRead, dstWrote;
    OpenFileData ofd;
    static CONST char *chooseOptionStrings[] = {
	    "-initialdir", "-message", "-mustexist", "-parent", "-title", NULL
    };
    enum chooseOptions {
	    CHOOSE_INITDIR,	CHOOSE_MESSAGE, CHOOSE_MUSTEXIST, 
	    CHOOSE_PARENT, CHOOSE_TITLE
    };
  
    
    if (!NavServicesAvailable()) {
        return TCL_ERROR;
    }

    if (!fileDlgInited) {
	InitFileDialogs();
    }
    result = TCL_ERROR;    
    parent = (Tk_Window) clientData;    
    title[0] = 0;
    message[0] = 0;   

    for (i = 1; i < objc; i += 2) {
        char *choice;
	int index, choiceLen;
	char *string;

	if (Tcl_GetIndexFromObj(interp, objv[i], chooseOptionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(objv[i], NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    return TCL_ERROR;
	}
	switch (index) {
	    case CHOOSE_INITDIR:
	        choice = Tcl_GetStringFromObj(objv[i + 1], NULL);
                if (HandleInitialDirectory(interp, choice, &dirSpec, 
                        &initialDesc) != TCL_OK) {
                    result = TCL_ERROR;
                    goto end;
                }
	        break;
	    case CHOOSE_MESSAGE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
	        Tcl_UtfToExternal(NULL, NULL, choice, choiceLen, 
		        0, NULL, StrBody(message), 255, 
		        &srcRead, &dstWrote, NULL);
                StrLength(message) = (unsigned char) dstWrote;
	        break;
	    case CHOOSE_PARENT:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
                parent = Tk_NameToWindow(interp, choice, parent);
	        if (parent == NULL) {
	            result = TCL_ERROR;
	            goto end;
	        }
	        break;
	    case CHOOSE_TITLE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
	        Tcl_UtfToExternal(NULL, NULL, choice, choiceLen, 
		        0, NULL, StrBody(title), 255, 
		        &srcRead, &dstWrote, NULL);
                StrLength(title) = (unsigned char) dstWrote;
	        break;
	}
    }
             
    TkInitFileFilters(&ofd.fl);
    ofd.usePopup = 0;

    if (useNavServices) {
        AEDesc *initialPtr = NULL;
        
        if (initialDesc.descriptorType == typeFSS) {
            initialPtr = &initialDesc;
        }
        result = NavServicesGetFile(interp, &ofd, initialPtr, NULL, 
                title, message, false, CHOOSE_FOLDER);
    } else {
        result = TCL_ERROR;
    }

    end:
    AEDisposeDesc(&initialDesc);
    
    return result;
}

int
HandleInitialDirectory (
    Tcl_Interp *interp,
    char *initialDir, 
    FSSpec *dirSpec, 
    AEDesc *dirDescPtr)
{
	Tcl_DString ds;
	long dirID;
	OSErr err;
	Boolean isDirectory;
	Str255 dir;
	int srcRead, dstWrote;
	
	if (Tcl_TranslateFileName(interp, initialDir, &ds) == NULL) {
	    return TCL_ERROR;
	}
	Tcl_UtfToExternal(NULL, NULL, Tcl_DStringValue(&ds), 
		Tcl_DStringLength(&ds), 0, NULL, StrBody(dir), 255, 
		&srcRead, &dstWrote, NULL);
        StrLength(dir) = (unsigned char) dstWrote;
	Tcl_DStringFree(&ds);
          
	err = FSpLocationFromPath(StrLength(dir), StrBody(dir), dirSpec);
	if (err != noErr) {
	    Tcl_AppendResult(interp, "bad directory \"", initialDir, "\"", NULL);
	    return TCL_ERROR;
	}
	err = FSpGetDirectoryIDTcl(dirSpec, &dirID, &isDirectory);
	if ((err != noErr) || !isDirectory) {
	    Tcl_AppendResult(interp, "bad directory \"", initialDir, "\"", NULL);
	    return TCL_ERROR;
	}

        if (useNavServices) {
            AECreateDesc( typeFSS, dirSpec, sizeof(*dirSpec), dirDescPtr);        
        } else {
	    /*
	     * Make sure you negate -dirSpec.vRefNum because the 
	     * standard file package wants it that way !
	     */
	
	    LMSetSFSaveDisk(-dirSpec->vRefNum);
	    LMSetCurDirStore(dirID);
	}
        return TCL_OK;
}

static void
InitFileDialogs()
{
    fileDlgInited = 1;
    
    if (NavServicesAvailable()) {
        openFileFilterUPP = NewNavObjectFilterProc(OpenFileFilterProc);
        openFileEventUPP = NewNavEventProc(OpenEventProc);
        useNavServices = 1;
    } else {
	openFilter = NewFileFilterYDProc(FileFilterProc);
	openHook = NewDlgHookYDProc(OpenHookProc);
	saveHook = NewDlgHookYDProc(OpenHookProc);
	useNavServices = 0;
    }
    
        
}


/*
 *----------------------------------------------------------------------
 *
 * GetFileName --
 *
 *	Calls the Mac file dialog functions for the user to choose a
 *	file to or save.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	If the user selects a file, the native pathname of the file
 *	is returned in the interp's result. Otherwise an empty string
 *	is returned in the interp's result.
 *
 *----------------------------------------------------------------------
 */

static int
GetFileName(
    ClientData clientData,	/* Main window associated with interpreter. */
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST objv[],	/* Argument objects. */
    int isOpen)			/* true if we should call GetOpenFileName(),
				 * false if we should call GetSaveFileName() */
{
    return TCL_OK;
}

static int
NavServicesGetFile(
    Tcl_Interp *interp,
    OpenFileData *ofdPtr,
    AEDesc *initialDesc,
    unsigned char *initialFile,
    StringPtr title,
    StringPtr message,
    int multiple,
    int isOpen)
{
    NavReplyRecord theReply;
    NavDialogOptions diagOptions;
    OSErr err;
    Tcl_Obj *theResult;
    int result;

    
    diagOptions.location.h = -1;
    diagOptions.location.v = -1;
    diagOptions.dialogOptionFlags = kNavDontAutoTranslate 
            + kNavDontAddTranslateItems;
            
    if (multiple) {
        diagOptions.dialogOptionFlags += kNavAllowMultipleFiles;
    }
    
    if (ofdPtr != NULL && ofdPtr->usePopup) {
        FileFilter *filterPtr;
        
	filterPtr = ofdPtr->fl.filters;
	if (filterPtr == NULL) {
	    ofdPtr->usePopup = 0;
	}
    }
    
    if (ofdPtr != NULL && ofdPtr->usePopup) {    
        NavMenuItemSpecHandle popupExtensionHandle = NULL;
        NavMenuItemSpec *popupItems;
        FileFilter *filterPtr;
        short index = 0;
	
	ofdPtr->curType = 0;
	
        popupExtensionHandle = (NavMenuItemSpecHandle) NewHandle(ofdPtr->fl.numFilters 
                * sizeof(NavMenuItemSpec));
        HLock((Handle) popupExtensionHandle);
        popupItems = *popupExtensionHandle;
        
        for (filterPtr = ofdPtr->fl.filters; filterPtr != NULL; 
                filterPtr = filterPtr->next, popupItems++, index++) {
            int len;
            
            len = strlen(filterPtr->name);
            BlockMove(filterPtr->name, popupItems->menuItemName + 1, len);
            popupItems->menuItemName[0] = len;
            popupItems->menuCreator = 'WIsH';
            popupItems->menuType = index;
        }
        HUnlock((Handle) popupExtensionHandle);
        diagOptions.popupExtension = popupExtensionHandle;
    } else {        
        diagOptions.dialogOptionFlags += kNavNoTypePopup; 
        diagOptions.popupExtension = NULL;
    }
        
    if ((initialFile != NULL) && (initialFile[0] != 0)) {
        char *lastColon;
        int len;
        
        len = initialFile[0];
        
        p2cstr(initialFile);        
        lastColon = strrchr((char *)initialFile, ':');
        if (lastColon != NULL) {
            len -= lastColon - ((char *) (initialFile + 1));
            BlockMove(lastColon + 1, diagOptions.savedFileName + 1, len);
            diagOptions.savedFileName[0] = len;
        } else {  
            BlockMove(initialFile, diagOptions.savedFileName + 1, len);
            diagOptions.savedFileName[0] = len;
        }
    } else {
        diagOptions.savedFileName[0] = 0;
    }
    
    strcpy((char *) (diagOptions.clientName + 1),"Wish");
    diagOptions.clientName[0] = strlen("Wish");
    
    if (title == NULL) {
        diagOptions.windowTitle[0] = 0;
    } else {
        BlockMove(title, diagOptions.windowTitle, title[0] + 1);
        diagOptions.windowTitle[0] = title[0];
    }
    
    if (message == NULL) {
        diagOptions.message[0] = 0;
    } else {
        BlockMove(message, diagOptions.message, message[0] + 1);
        diagOptions.message[0] = message[0];
    }
    
    diagOptions.actionButtonLabel[0] = 0;
    diagOptions.cancelButtonLabel[0] = 0;
    diagOptions.preferenceKey = 0;
    
    /* Now process the selection list.  We have to use the popupExtension
     * to fill the menu.
     */
    
    
    if (isOpen == OPEN_FILE) {
        err = NavGetFile(initialDesc, &theReply, &diagOptions, openFileEventUPP,  
                NULL, openFileFilterUPP, NULL, ofdPtr);    
    } else if (isOpen == SAVE_FILE) {
        err = NavPutFile (initialDesc, &theReply, &diagOptions, openFileEventUPP, 
                'TEXT', 'WIsH', NULL);
    } else if (isOpen == CHOOSE_FOLDER) {
        err = NavChooseFolder (initialDesc, &theReply, &diagOptions,
                openFileEventUPP, NULL, NULL);
    }
    
                        
    /*
     * Most commands assume that the file dialogs return a single
     * item, not a list.  So only build a list if multiple is true...
     */
                         
    if (multiple) {
        theResult = Tcl_NewListObj(0, NULL);
    } else {
        theResult = Tcl_NewObj();
    }
           
    if ( theReply.validRecord && err == noErr ) {
        AEDesc resultDesc;
        long count;
        Tcl_DString fileName;
        Handle pathHandle;
        int length;
        
        if ( err == noErr ) {
            err = AECountItems(&(theReply.selection), &count);
            if (err == noErr) {
                long i;
                for (i = 1; i <= count; i++ ) {
                    err = AEGetNthDesc(&(theReply.selection),
                            i, typeFSS, NULL, &resultDesc);
                    if (err == noErr) {
                        HLock(resultDesc.dataHandle);
                        pathHandle = NULL;
                        FSpPathFromLocation((FSSpec *) *resultDesc.dataHandle, 
                                &length, &pathHandle);
                        HLock(pathHandle);
                        Tcl_ExternalToUtfDString(NULL, (char *) *pathHandle, -1, &fileName);
                        if (multiple) {
                            Tcl_ListObjAppendElement(interp, theResult, 
                                    Tcl_NewStringObj(Tcl_DStringValue(&fileName), 
                                    Tcl_DStringLength(&fileName)));
                        } else {
                            Tcl_SetStringObj(theResult, Tcl_DStringValue(&fileName), 
                                    Tcl_DStringLength(&fileName));
                        }
                        
                        Tcl_DStringFree(&fileName);
                        HUnlock(pathHandle);
                        DisposeHandle(pathHandle);
                        HUnlock(resultDesc.dataHandle);
                        AEDisposeDesc( &resultDesc );
                    }
                }
            }
         }
         err = NavDisposeReply( &theReply );
         Tcl_SetObjResult(interp, theResult);
         result = TCL_OK;
    } else if (err == userCanceledErr) {
        result = TCL_OK;
    } else {
        result = TCL_ERROR;
    }
    
    if (diagOptions.popupExtension != NULL) {
        DisposeHandle((Handle) diagOptions.popupExtension);
    }
    
    return result;
}

static pascal Boolean 
OpenFileFilterProc( 
    AEDesc* theItem, void* info,
    NavCallBackUserData callBackUD,
    NavFilterModes filterMode )
{
    OpenFileData *ofdPtr = (OpenFileData *) callBackUD;
    if (!ofdPtr->usePopup) {
        return true;
    } else {
        if (ofdPtr->fl.numFilters == 0) {
            return true;
        } else {
            
            if ( theItem->descriptorType == typeFSS ) {
                NavFileOrFolderInfo* theInfo = (NavFileOrFolderInfo*)info;
                int result;
                
                if ( !theInfo->isFolder ) {
                    OSType fileType;
                    StringPtr fileNamePtr;
                    int i;
                    FileFilter *filterPtr;
               
                    fileType = theInfo->fileAndFolder.fileInfo.finderInfo.fdType;
                    HLock(theItem->dataHandle);
                    fileNamePtr = (((FSSpec *) *theItem->dataHandle)->name);
                    
                    if (ofdPtr->usePopup) {
                        i = ofdPtr->curType;
	                for (filterPtr=ofdPtr->fl.filters; filterPtr && i>0; i--) {
	                    filterPtr = filterPtr->next;
	                }
	                if (filterPtr) {
	                    result = MatchOneType(fileNamePtr, fileType,
	                            ofdPtr, filterPtr);
	                } else {
	                    result = false;
                        }
                    } else {
	                /*
	                 * We are not using the popup menu. In this case, the file is
	                 * considered matched if it matches any of the file filters.
	                 */
			result = UNMATCHED;
	                for (filterPtr=ofdPtr->fl.filters; filterPtr;
		                filterPtr=filterPtr->next) {
	                    if (MatchOneType(fileNamePtr, fileType,
	                            ofdPtr, filterPtr) == MATCHED) {
	                        result = MATCHED;
	                        break;
	                    }
	                }
                    }
                    
                    HUnlock(theItem->dataHandle);
                    return (result == MATCHED);
                } else {
                    return true;
                }
            }
        }
        
        return true;
    }
}

pascal void 
OpenEventProc(
    NavEventCallbackMessage callBackSelector,
    NavCBRecPtr callBackParams,
    NavCallBackUserData callBackUD )
{
    NavMenuItemSpec *chosenItem;
    OpenFileData *ofd = (OpenFileData *) callBackUD;
        
    if (callBackSelector ==  kNavCBPopupMenuSelect) {
        chosenItem = (NavMenuItemSpec *) callBackParams->eventData.eventDataParms.param;
        ofd->curType = chosenItem->menuType;
    } else if (callBackSelector == kNavCBEvent) {
    	if (callBackParams->eventData.eventDataParms.event->what == updateEvt) {
    		if (TkMacConvertEvent( callBackParams->eventData.eventDataParms.event)) {
        		while (Tcl_DoOneEvent(TCL_IDLE_EVENTS|TCL_DONT_WAIT|TCL_WINDOW_EVENTS)) {
           			/* Empty Body */
        		}
        	}
        }
    }
}

static int
StdGetFile(
    Tcl_Interp *interp,
    OpenFileData *ofd,
    unsigned char *initialFile,
    int isOpen)
{
    int i;
    StandardFileReply reply;
    Point mypoint;
    MenuHandle menu = NULL;


    /*
     * Set the items in the file types popup.
     */

    /*
     * Delete all the entries inside the popup menu, in case there's any
     * left overs from previous invocation of this command
     */

    if (ofd != NULL && ofd->usePopup) {
	FileFilter *filterPtr;
	
	menu = GetMenu(OPEN_MENU);
        for (i = CountMItems(menu); i > 0; i--) {
            /*
             * The item indices are one based. Also, if we delete from
             * the beginning, the items may be re-numbered. So we
             * delete from the end
    	     */
    	     
    	     DeleteMenuItem(menu, i);
        }

	filterPtr = ofd->fl.filters;
	if (filterPtr == NULL) {
	    ofd->usePopup = 0;
	} else {
	    for ( ; filterPtr != NULL; filterPtr = filterPtr->next) {
	        Str255 str;
	        
	    	StrLength(str) = (unsigned char) strlen(filterPtr->name);
	    	strcpy(StrBody(str), filterPtr->name);
		AppendMenu(menu, str);
	    }
	}
    }

    /*
     * Call the toolbox file dialog function.
     */
     
    SetPt(&mypoint, -1, -1);
    TkpSetCursor(NULL);
    if (isOpen == OPEN_FILE) {
        if (ofd != NULL && ofd->usePopup) {
	    CustomGetFile(openFilter, (short) -1, NULL, &reply, OPEN_BOX,
	    	    mypoint, openHook, NULL, NULL, NULL, (void*) ofd);
	} else {
	    StandardGetFile(NULL, -1, NULL, &reply);
	}
    } else if (isOpen == SAVE_FILE) {
	static Str255 prompt = "\pSave as";
	
   	if (ofd != NULL && ofd->usePopup) {
   	    /*
   	     * Currently this never gets called because we don't use
   	     * popup for the save dialog.
   	     */
	    CustomPutFile(prompt, initialFile, &reply, OPEN_BOX, 
		    mypoint, saveHook, NULL, NULL, NULL, (void *) ofd);
	} else {
	    StandardPutFile(prompt, initialFile, &reply);
	}
    }

    /*
     * Now parse the reply, and populate the Tcl result.
     */
     
    if (reply.sfGood) {
        int length;
    	Handle pathHandle;
    	
    	pathHandle = NULL;
    	FSpPathFromLocation(&reply.sfFile, &length, &pathHandle);
	if (pathHandle != NULL) {
	    Tcl_DString ds;
	    
	    HLock(pathHandle);
	    Tcl_ExternalToUtfDString(NULL, (char *) *pathHandle, -1, &ds);
	    Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
	    Tcl_DStringFree(&ds);
	    HUnlock(pathHandle);
	    DisposeHandle(pathHandle);
	}
    }
    
    if (menu != NULL) {
    	DisposeMenu(menu);
    }

    return TCL_OK;
}
/*
 *----------------------------------------------------------------------
 *
 * OpenHookProc --
 *
 *	Gets called for various events that occur in the file dialog box.
 *	Initializes the popup menu or rebuild the file list depending on
 *	the type of the event.
 *
 * Results:
 *	A standard result understood by the Mac file dialog event dispatcher.
 *
 * Side effects:
 *	The contents in the file dialog may be changed depending on
 *	the type of the event.
 *----------------------------------------------------------------------
 */

static pascal short
OpenHookProc(
    short item,			/* Event description. */
    DialogPtr theDialog,	/* The dialog where the event occurs. */
    OpenFileData *ofdPtr)	/* Information about the file dialog. */
{
    short ignore;
    Rect rect;
    Handle handle;
    int newType;

    switch (item) {
	case sfHookFirstCall:
	    if (ofdPtr->usePopup) {
		/*
		 * Set the popup list to display the selected type.
		 */
		GetDialogItem(theDialog, ofdPtr->popupItem, &ignore, &handle, 
			&rect);
		SetControlValue((ControlRef) handle, ofdPtr->curType + 1);
	    }
	    return sfHookNullEvent;
      
	case OPEN_POPUP_ITEM:
	    if (ofdPtr->usePopup) {
		GetDialogItem(theDialog, ofdPtr->popupItem,
			&ignore, &handle, &rect);
		newType = GetControlValue((ControlRef) handle) - 1;
		if (ofdPtr->curType != newType) {
		    if (newType<0 || newType>ofdPtr->fl.numFilters) {
			/*
			 * Sanity check. Looks like the user selected an
			 * non-existent menu item?? Don't do anything.
			 */
		    } else {
			ofdPtr->curType = newType;
		    }
		    return sfHookRebuildList;
		}
	    }  
	    break;
    }

    return item;
}

/*
 *----------------------------------------------------------------------
 *
 * FileFilterProc --
 *
 *	Filters files according to file types. Get called whenever the
 *	file list needs to be updated inside the dialog box.
 *
 * Results:
 *	Returns MATCHED if the file should be shown in the listbox, returns
 *	UNMATCHED otherwise.
 *
 * Side effects:
 *	If MATCHED is returned, the file is shown in the listbox.
 *
 *----------------------------------------------------------------------
 */

static pascal Boolean
FileFilterProc(
    CInfoPBPtr pb,		/* Information about the file */
    void *myData)		/* Client data for this file dialog */
{
    int i;
    OpenFileData * ofdPtr = (OpenFileData*)myData;
    FileFilter * filterPtr;

    if (ofdPtr->fl.numFilters == 0) {
	/*
	 * No types have been specified. List all files by default
	 */
	return MATCHED;
    }

    if (pb->dirInfo.ioFlAttrib & 0x10) {
    	/*
    	 * This is a directory: always show it
    	 */
    	return MATCHED;
    }

    if (ofdPtr->usePopup) {
        i = ofdPtr->curType;
	for (filterPtr=ofdPtr->fl.filters; filterPtr && i>0; i--) {
	    filterPtr = filterPtr->next;
	}
	if (filterPtr) {
	    return MatchOneType(pb->hFileInfo.ioNamePtr, pb->hFileInfo.ioFlFndrInfo.fdType,
	            ofdPtr, filterPtr);
	} else {
	    return UNMATCHED;
        }
    } else {
	/*
	 * We are not using the popup menu. In this case, the file is
	 * considered matched if it matches any of the file filters.
	 */

	for (filterPtr=ofdPtr->fl.filters; filterPtr;
		filterPtr=filterPtr->next) {
	    if (MatchOneType(pb->hFileInfo.ioNamePtr, pb->hFileInfo.ioFlFndrInfo.fdType,
	            ofdPtr, filterPtr) == MATCHED) {
	        return MATCHED;
	    }
	}
	return UNMATCHED;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * MatchOneType --
 *
 *	Match a file with one file type in the list of file types.
 *
 * Results:
 *	Returns MATCHED if the file matches with the file type; returns
 *	UNMATCHED otherwise.
 *
 * Side effects:
 *	None
 *
 *----------------------------------------------------------------------
 */

static Boolean
MatchOneType(
    StringPtr fileNamePtr,	/* Name of the file */
    OSType    fileType,         /* Type of the file */ 
    OpenFileData * ofdPtr,	/* Information about this file dialog */
    FileFilter * filterPtr)	/* Match the file described by pb against
				 * this filter */
{
    FileFilterClause * clausePtr;

    /*
     * A file matches with a file type if it matches with at least one
     * clause of the type.
     *
     * If the clause has both glob patterns and ostypes, the file must
     * match with at least one pattern AND at least one ostype.
     *
     * If the clause has glob patterns only, the file must match with at least
     * one pattern.
     *
     * If the clause has mac types only, the file must match with at least
     * one mac type.
     *
     * If the clause has neither glob patterns nor mac types, it's
     * considered an error.
     */

    for (clausePtr=filterPtr->clauses; clausePtr; clausePtr=clausePtr->next) {
	int macMatched  = 0;
	int globMatched = 0;
	GlobPattern * globPtr;
	MacFileType * mfPtr;

	if (clausePtr->patterns == NULL) {
	    globMatched = 1;
	}
	if (clausePtr->macTypes == NULL) {
	    macMatched = 1;
	}

	for (globPtr=clausePtr->patterns; globPtr; globPtr=globPtr->next) {
	    char filename[256];
	    int len;
	    char * p, *q, *ext;
        
	    if (fileNamePtr == NULL) {
		continue;
	    }
	    p = (char*)(fileNamePtr);
	    len = p[0];
	    strncpy(filename, p+1, len);
	    filename[len] = '\0';
	    ext = globPtr->pattern;

	    if (ext[0] == '\0') {
		/*
		 * We don't want any extensions: OK if the filename doesn't
		 * have "." in it
		 */
		for (q=filename; *q; q++) {
		    if (*q == '.') {
			goto glob_unmatched;
		    }
		}
		goto glob_matched;
	    }
        
	    if (Tcl_StringMatch(filename, ext)) {
		goto glob_matched;
	    } else {
		goto glob_unmatched;
	    }

	  glob_unmatched:
	    continue;

	  glob_matched:
	    globMatched = 1;
	    break;
	}

	for (mfPtr=clausePtr->macTypes; mfPtr; mfPtr=mfPtr->next) {
	    if (fileType == mfPtr->type) {
		macMatched = 1;
		break;
	    }
        }

	if (globMatched && macMatched) {
	    return MATCHED;
	}
    }

    return UNMATCHED;
}


@


1.4
log
@touched all sources to ease next import
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tkMacDialog.c,v 1.7.6.2 2000/09/26 16:08:56 spolk Exp $
d144 1
a144 1
    static char *optionStrings[] = {
d231 1
a231 1
    	cpinfo.flags = CanModifyPalette | CanAnimatePalette;
d307 1
a307 1
    static char *openOptionStrings[] = {
d456 2
a457 2
    static char *saveOptionStrings[] = {
	    "-defaultextension", "-initialdir", "-initialfile", 
d461 1
a461 1
	    SAVE_DEFAULT,	SAVE_INITDIR,	SAVE_INITFILE,
d496 2
d598 1
a598 1
    static char *chooseOptionStrings[] = {
d717 1
a717 1
	err = FSpGetDirectoryID(dirSpec, &dirID, &isDirectory);
a1052 3
    static SInt32 otherEvent = ~(kNavCBCustomize|kNavCBStart|kNavCBTerminate
	    |kNavCBNewLocation|kNavCBShowDesktop|kNavCBSelectEntry|kNavCBAccept
	    |kNavCBCancel|kNavCBAdjustPreview);
d1057 7
a1063 3
    } else if (callBackSelector == kNavCBAdjustRect || callBackSelector & otherEvent != 0) { 
        while (Tcl_DoOneEvent(TCL_IDLE_EVENTS|TCL_DONT_WAIT|TCL_WINDOW_EVENTS)) {
            /* Empty Body */
d1127 1
a1127 1
	    	    mypoint, openHook, NULL, NULL, NULL, (void*) &ofd);
d1219 1
a1219 1
		newType = GetCtlValue((ControlRef) handle) - 1;
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 * Copyright (c) 1996 Sun Microsystems, Inc.
d11 1
a11 2
 * RCS: @@(#) $Id: tkMacDialog.c,v 1.7 1999/01/26 04:11:31 jingham Exp $
 *
d23 1
d27 1
d30 7
d47 1
a56 5
    Tcl_Interp * interp;
    char * initialFile;			/* default file to appear in the
					 * save dialog */
    char * defExt;			/* default extension (not used on the
					 * Mac) */
d59 3
a61 8
					 * listed */
    int isOpen;				/* True if this is an Open dialog,
					 * false if it is a Save dialog. */
    MenuHandle menu;			/* Handle of the menu in the popup*/
    short dialogId;			/* resource ID of the dialog */
    int popupId;			/* resource ID of the popup */
    short popupItem;			/* item number of the popup in the
					 * dialog */
d64 1
a64 2
					 * -filetypes option is set)
    					 */
d67 1
d70 8
a77 5
static int 		GetFileName _ANSI_ARGS_ ((
			    ClientData clientData, Tcl_Interp *interp,
    			    int argc, char **argv, int isOpen ));
static Boolean		MatchOneType _ANSI_ARGS_((CInfoPBPtr pb,
			    OpenFileData * myDataPtr, FileFilter * filterPtr));
d79 1
a79 1
			    DialogPtr theDialog, OpenFileData * myDataPtr));
d81 1
a81 1
			    OpenFileData * myDataPtr, int argc, char ** argv,
d83 14
a96 1

d102 5
d115 1
a115 62
 * EvalArgv --
 *
 *	Invokes the Tcl procedure with the arguments. argv[0] is set by
 *	the caller of this function. It may be different than cmdName.
 *	The TCL command will see argv[0], not cmdName, as its name if it
 *	invokes [lindex [info level 0] 0]
 *
 * Results:
 *	TCL_ERROR if the command does not exist and cannot be autoloaded.
 *	Otherwise, return the result of the evaluation of the command.
 *
 * Side effects:
 *	The command may be autoloaded.
 *
 *----------------------------------------------------------------------
 */

static int
EvalArgv(
    Tcl_Interp *interp,		/* Current interpreter. */
    char * cmdName,		/* Name of the TCL command to call */
    int argc,			/* Number of arguments. */
    char **argv)		/* Argument strings. */
{
    Tcl_CmdInfo cmdInfo;

    if (!Tcl_GetCommandInfo(interp, cmdName, &cmdInfo)) {
	char * cmdArgv[2];

	/*
	 * This comand is not in the interpreter yet -- looks like we
	 * have to auto-load it
	 */
	if (!Tcl_GetCommandInfo(interp, "auto_load", &cmdInfo)) {
	    Tcl_ResetResult(interp);
	    Tcl_AppendResult(interp, "cannot execute command \"auto_load\"",
		NULL);
	    return TCL_ERROR;
	}

	cmdArgv[0] = "auto_load";
	cmdArgv[1] = cmdName;

	if ((*cmdInfo.proc)(cmdInfo.clientData, interp, 2, cmdArgv)!= TCL_OK){ 
	    return TCL_ERROR;
	}

	if (!Tcl_GetCommandInfo(interp, cmdName, &cmdInfo)) {
	    Tcl_ResetResult(interp);
	    Tcl_AppendResult(interp, "cannot auto-load command \"",
		cmdName, "\"",NULL);
	    return TCL_ERROR;
	}
    }

    return (*cmdInfo.proc)(cmdInfo.clientData, interp, argc, argv);
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_ChooseColorCmd --
d131 1
a131 1
Tk_ChooseColorCmd(
d134 2
a135 2
    int argc,			/* Number of arguments. */
    char **argv)		/* Argument strings. */
d137 6
a142 8
    Tk_Window parent = Tk_MainWindow(interp);
    char * colorStr = NULL;
    XColor * colorPtr = NULL;
    char * title = "Choose a color:";
    int i, version;
    long response = 0;
    OSErr err = noErr;
    char buff[40];
d144 6
a149 1
    static inited = 0;
d151 60
d219 2
a220 39
    if ((err == noErr) || (response == 0x0200L)) {
    	version = 2;
    } else {
    	version = 1;
    }
 
    for (i=1; i<argc; i+=2) {
        int v = i+1;
	int len = strlen(argv[i]);

        if (strncmp(argv[i], "-initialcolor", len)==0) {
	    if (v==argc) {goto arg_missing;}

	    colorStr = argv[v];
	} else if (strncmp(argv[i], "-parent", len)==0) {
	    if (v==argc) {goto arg_missing;}

	    parent=Tk_NameToWindow(interp, argv[v], Tk_MainWindow(interp));
	    if (parent == NULL) {
		return TCL_ERROR;
	    }
	} else if (strncmp(argv[i], "-title", len)==0) {
	    if (v==argc) {goto arg_missing;}

	    title = argv[v];
	} else {
    	    Tcl_AppendResult(interp, "unknown option \"", 
		    argv[i], "\", must be -initialcolor, -parent or -title",
		    NULL);
	    return TCL_ERROR;
	}
    }

    if (colorStr) {
        colorPtr = Tk_GetColor(interp, parent, colorStr);
        if (colorPtr == NULL) {
            return TCL_ERROR;
        }
    }
a221 42
    if (!inited) {
        inited = 1;
        in.red = 0xffff;
        in.green = 0xffff;
        in.blue = 0xffff;
    }
    if (colorPtr) {
        in.red   = colorPtr->red;
        in.green = colorPtr->green;
        in.blue  = colorPtr->blue;
    }
        
    if (version == 1) {
        /*
         * Use version 1.0 of the color picker
         */
    	
    	RGBColor out;
    	Str255 prompt;
    	Point point = {-1, -1};
    	
        prompt[0] = strlen(title);
        strncpy((char*) prompt+1, title, 255);
        
        if (GetColor(point, prompt, &in, &out)) {
            /*
             * user selected a color
             */
            sprintf(buff, "#%02x%02x%02x", out.red >> 8, out.green >> 8,
                out.blue >> 8);
            Tcl_SetResult(interp, buff, TCL_VOLATILE);

            /*
             * Save it for the next time
             */
            in.red   = out.red;
            in.green = out.green;
            in.blue  = out.blue;
        } else {
            Tcl_ResetResult(interp);
    	}
    } else {
a224 1
	ColorPickerInfo cpinfo;
d237 23
d261 3
a263 15
        cpinfo.prompt[0] = strlen(title);
        strncpy((char*)cpinfo.prompt+1, title, 255);
        
        if ((PickColor(&cpinfo) == noErr) && cpinfo.newColorChosen) {
            sprintf(buff, "#%02x%02x%02x",
		cpinfo.theColor.color.rgb.red   >> 8, 
                cpinfo.theColor.color.rgb.green >> 8,
		cpinfo.theColor.color.rgb.blue  >> 8);
            Tcl_SetResult(interp, buff, TCL_VOLATILE);
            
            in.blue  = cpinfo.theColor.color.rgb.red;
    	    in.green = cpinfo.theColor.color.rgb.green;
    	    in.blue  = cpinfo.theColor.color.rgb.blue;
          } else {
            Tcl_ResetResult(interp);
d265 4
a268 1
    }
d270 3
a272 2
    if (colorPtr) {
	Tk_FreeColor(colorPtr);
a273 1

a274 5

  arg_missing:
    Tcl_AppendResult(interp, "value for \"", argv[argc-1], "\" missing",
	NULL);
    return TCL_ERROR;
d280 1
a280 1
 * Tk_GetOpenFileCmd --
d295 1
a295 1
Tk_GetOpenFileCmd(
d298 2
a299 2
    int argc,			/* Number of arguments. */
    char **argv)		/* Argument strings. */
d301 123
a423 1
    return GetFileName(clientData, interp, argc, argv, OPEN_FILE);
d429 1
a429 1
 * Tk_GetSaveFileCmd --
d443 1
a443 1
Tk_GetSaveFileCmd(
d446 2
a447 2
    int argc,			/* Number of arguments. */
    char **argv)		/* Argument strings. */
d449 112
a560 1
    return GetFileName(clientData, interp, argc, argv, SAVE_FILE);
d566 192
d768 2
a769 2
 *	is returned in interp->result. Otherwise an empty string
 *	is returned in interp->result.
d778 2
a779 2
    int argc,			/* Number of arguments. */
    char **argv,		/* Argument strings. */
d783 2
a784 6
    int code = TCL_OK;
    int i;
    OpenFileData myData, *myDataPtr;
    StandardFileReply reply;
    Point mypoint;
    Str255 str;
d786 16
a801 1
    myDataPtr = &myData;
d803 104
a906 4
    if (openFilter == NULL) {
	openFilter = NewFileFilterYDProc(FileFilterProc);
	openHook = NewDlgHookYDProc(OpenHookProc);
	saveHook = NewDlgHookYDProc(OpenHookProc);
d908 2
a909 1

d911 2
a912 1
     * 1. Parse the arguments.
d914 57
a970 3
    if (ParseFileDlgArgs(interp, myDataPtr, argc, argv, isOpen) 
	!= TCL_OK) {
	return TCL_ERROR;
d972 105
d1079 1
a1079 1
     * 2. Set the items in the file types popup.
d1087 5
a1091 4
    if (myDataPtr->usePopup) {
	FileFilter * filterPtr;

        for (i=CountMItems(myDataPtr->menu); i>0; i--) {
d1097 2
a1098 1
    	     DeleteMenuItem(myDataPtr->menu, i);
d1101 10
a1110 6
	if (myDataPtr->fl.filters) {
	    for (filterPtr=myDataPtr->fl.filters; filterPtr;
		    filterPtr=filterPtr->next) {
		strncpy((char*)str+1, filterPtr->name, 254);
		str[0] = strlen(filterPtr->name);
		AppendMenu(myDataPtr->menu, (ConstStr255Param) str);
a1111 2
	} else {
	    myDataPtr->usePopup = 0;
d1116 1
a1116 1
     * 3. Call the toolbox file dialog function.
d1118 1
d1121 4
a1124 6
    
    if (myDataPtr->isOpen) {
        if (myDataPtr->usePopup) {
	    CustomGetFile(openFilter, (short) -1, NULL, &reply, 
	        myDataPtr->dialogId, 
	        mypoint, openHook, NULL, NULL, NULL, (void*)myDataPtr);
d1128 4
a1131 12
    } else {
	Str255 prompt, def;

	strcpy((char*)prompt+1, "Save as");
	prompt[0] = strlen("Save as");
   	if (myDataPtr->initialFile) {
   	    strncpy((char*)def+1, myDataPtr->initialFile, 254);
	    def[0] = strlen(myDataPtr->initialFile);
        } else {
            def[0] = 0;
        }
   	if (myDataPtr->usePopup) {
d1136 2
a1137 2
	    CustomPutFile(prompt, def, &reply, myDataPtr->dialogId, mypoint, 
	        saveHook, NULL, NULL, NULL, myDataPtr);
d1139 1
a1139 1
	    StandardPutFile(prompt, def, &reply);
d1143 4
a1146 1
    Tcl_ResetResult(interp);    
d1149 1
a1149 2
    	Handle pathHandle = NULL;
    	char * pathName = NULL;
d1151 1
a1152 1

d1154 2
d1157 3
a1159 2
	    pathName = (char *) ckalloc((unsigned) (length + 1));
	    strcpy(pathName, *pathHandle);
a1161 6

	    /*
	     * Return the full pathname of the selected file
	     */

	    Tcl_SetResult(interp, pathName, TCL_DYNAMIC);
a1163 38

  done:
    TkFreeFileFilters(&myDataPtr->fl);
    return code;
}

/*
 *----------------------------------------------------------------------
 *
 * ParseFileDlgArgs --
 *
 *	Parses the arguments passed to tk_getOpenFile and tk_getSaveFile.
 *
 * Results:
 *	A standard TCL return value.
 *
 * Side effects:
 *	The OpenFileData structure is initialized and modified according
 *	to the arguments.
 *
 *----------------------------------------------------------------------
 */

static int
ParseFileDlgArgs(
    Tcl_Interp * interp,		/* Current interpreter. */
    OpenFileData * myDataPtr,		/* Information about the file dialog */
    int argc,				/* Number of arguments */
    char ** argv,			/* Argument strings */
    int isOpen)				/* TRUE if this is an "open" dialog */
{
    int i;

    myDataPtr->interp      	= interp;
    myDataPtr->initialFile 	= NULL;
    myDataPtr->curType		= 0;

    TkInitFileFilters(&myDataPtr->fl);
d1165 2
a1166 99
    if (isOpen) {
	myDataPtr->isOpen    = 1;
        myDataPtr->usePopup  = 1;
	myDataPtr->menu      = GetMenu(OPEN_MENU);
	myDataPtr->dialogId  = OPEN_BOX;
	myDataPtr->popupId   = OPEN_POPUP;
	myDataPtr->popupItem = OPEN_POPUP_ITEM;
	if (myDataPtr->menu == NULL) {
	    Debugger();
	}
    } else {
        myDataPtr->isOpen    = 0;
	myDataPtr->usePopup  = 0;
    }

    for (i=1; i<argc; i+=2) {
        int v = i+1;
	int len = strlen(argv[i]);

	if (strncmp(argv[i], "-defaultextension", len)==0) {
	    if (v==argc) {goto arg_missing;}

	    myDataPtr->defExt = argv[v];
	}
	else if (strncmp(argv[i], "-filetypes", len)==0) {
	    if (v==argc) {goto arg_missing;}

	    if (TkGetFileFilters(interp, &myDataPtr->fl,argv[v],0) != TCL_OK) {
		return TCL_ERROR;
	    }
	}
	else if (strncmp(argv[i], "-initialdir", len)==0) {
	    FSSpec dirSpec;
	    char * dirName;
	    Tcl_DString dstring;
	    long dirID;
	    OSErr err;
	    Boolean isDirectory;

	    if (v==argc) {goto arg_missing;}
	    
	    if (Tcl_TranslateFileName(interp, argv[v], &dstring) == NULL) {
	        return TCL_ERROR;
	    }
	    dirName = dstring.string;
	    if (FSpLocationFromPath(strlen(dirName), dirName, &dirSpec) != 
		    noErr) {
		Tcl_AppendResult(interp, "bad directory \"", argv[v],
	            "\"", NULL);
	        return TCL_ERROR;
	    }
	    err = FSpGetDirectoryID(&dirSpec, &dirID, &isDirectory);
	    if ((err != noErr) || !isDirectory) {
		Tcl_AppendResult(interp, "bad directory \"", argv[v],
	            "\"", NULL);
	        return TCL_ERROR;
	    }
	    /*
	     * Make sure you negate -dirSpec.vRefNum because the standard file
	     * package wants it that way !
	     */
	    LMSetSFSaveDisk(-dirSpec.vRefNum);
	    LMSetCurDirStore(dirID);
	    Tcl_DStringFree(&dstring);
    	}
	else if (strncmp(argv[i], "-initialfile", len)==0) {
	    if (v==argc) {goto arg_missing;}
	    
	    myDataPtr->initialFile = argv[v];
	}
	else if (strncmp(argv[i], "-parent", len)==0) {
	    /*
	     * Ignored on the Mac, but make sure that it's a valid window
	     * pathname
	     */
	    Tk_Window parent;

	    if (v==argc) {goto arg_missing;}
	    	    
	    parent=Tk_NameToWindow(interp, argv[v], Tk_MainWindow(interp));
	    if (parent == NULL) {
		return TCL_ERROR;
	    }	    
	}
	else if (strncmp(argv[i], "-title", len)==0) {
	    if (v==argc) {goto arg_missing;}
	    
	    /*
	     * This option is ignored on the Mac because the Mac file
	     * dialog do not support titles.
	     */
	}
	else {
    	    Tcl_AppendResult(interp, "unknown option \"", 
		argv[i], "\", must be -defaultextension, ",
		"-filetypes, -initialdir, -initialfile, -parent or -title",
		NULL);
	    return TCL_ERROR;
	}
a1169 5

  arg_missing:
    Tcl_AppendResult(interp, "value for \"", argv[argc-1], "\" missing",
	NULL);
    return TCL_ERROR;
a1170 1

d1193 1
a1193 1
    OpenFileData * myDataPtr)	/* Information about the file dialog. */
d1202 1
a1202 1
	    if (myDataPtr->usePopup) {
d1206 3
a1208 3
		GetDialogItem(theDialog, myDataPtr->popupItem,
			&ignore, &handle, &rect);
		SetControlValue((ControlRef) handle, myDataPtr->curType + 1);
d1213 2
a1214 2
	    if (myDataPtr->usePopup) {
		GetDialogItem(theDialog, myDataPtr->popupItem,
d1217 2
a1218 2
		if (myDataPtr->curType != newType) {
		    if (newType<0 || newType>myDataPtr->fl.numFilters) {
d1224 1
a1224 1
			myDataPtr->curType = newType;
d1259 1
a1259 1
    OpenFileData * myDataPtr = (OpenFileData*)myData;
d1262 1
a1262 1
    if (myDataPtr->fl.numFilters == 0) {
d1276 3
a1278 3
    if (myDataPtr->usePopup) {
        i = myDataPtr->curType;
	for (filterPtr=myDataPtr->fl.filters; filterPtr && i>0; i--) {
d1282 2
a1283 1
	    return MatchOneType(pb, myDataPtr, filterPtr);
d1293 1
a1293 1
	for (filterPtr=myDataPtr->fl.filters; filterPtr;
d1295 2
a1296 1
	    if (MatchOneType(pb, myDataPtr, filterPtr) == MATCHED) {
d1323 3
a1325 2
    CInfoPBPtr pb,		/* Information about the file */
    OpenFileData * myDataPtr,	/* Information about this file dialog */
d1366 1
a1366 1
	    if (pb->hFileInfo.ioNamePtr == NULL) {
d1369 1
a1369 1
	    p = (char*)(pb->hFileInfo.ioNamePtr);
d1403 1
a1403 1
	    if (pb->hFileInfo.ioFlFndrInfo.fdType == mfPtr->type) {
a1415 18

/*
 *----------------------------------------------------------------------
 *
 * Tk_MessageBoxCmd --
 *
 *	This procedure implements the MessageBox window for the
 *	Mac platform. See the user documentation for details on what
 *	it does.
 *
 * Results:
 *      A standard Tcl result.
 *
 * Side effects:
 *	See user documentation.
 *
 *----------------------------------------------------------------------
 */
d1417 1
a1417 9
int
Tk_MessageBoxCmd(
    ClientData clientData,	/* Main window associated with interpreter. */
    Tcl_Interp *interp,		/* Current interpreter. */
    int argc,			/* Number of arguments. */
    char **argv)		/* Argument strings. */
{
    return EvalArgv(interp, "tkMessageBox", argc, argv);
}
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d6 1
a6 1
 * Copyright (c) 1996-1997 Sun Microsystems, Inc.
d11 2
a12 1
 * RCS: @@(#) $Id: tkMacDialog.c,v 1.7.6.2 2000/09/26 16:08:56 spolk Exp $
a23 1
#include <Navigation.h>
a26 1
#include "tkMacInt.h"
a28 7
#ifndef StrLength
#define StrLength(s) 		(*((unsigned char *) (s)))
#endif
#ifndef StrBody
#define StrBody(s)		((char *) (s) + 1)
#endif

a38 1
#define CHOOSE_FOLDER   2
d48 5
d55 8
a62 3
					 * listed. */
    short popupItem;			/* Item number of the popup in the
					 * dialog. */
d65 2
a66 1
					 * -filetypes option is set). */
a68 1

d71 5
a75 8
static int 		GetFileName _ANSI_ARGS_ ((ClientData clientData, 
			    Tcl_Interp *interp, int objc, 
			    Tcl_Obj *CONST objv[], int isOpen));
static int 		NavGetFileName _ANSI_ARGS_ ((ClientData clientData, 
			    Tcl_Interp *interp, int objc, 
			    Tcl_Obj *CONST objv[], int isOpen));
static Boolean		MatchOneType _ANSI_ARGS_((StringPtr fileNamePtr, OSType fileType,
			    OpenFileData *myofdPtr, FileFilter *filterPtr));
d77 1
a77 1
			    DialogPtr theDialog, OpenFileData * myofdPtr));
d79 1
a79 1
			    OpenFileData * myofdPtr, int argc, char ** argv,
d81 1
a81 14
static pascal Boolean   OpenFileFilterProc(AEDesc* theItem, void* info, 
                            NavCallBackUserData callBackUD,
                            NavFilterModes filterMode );
pascal void             OpenEventProc(NavEventCallbackMessage callBackSelector,
                            NavCBRecPtr callBackParms,
                            NavCallBackUserData callBackUD );
static void             InitFileDialogs();
static int              StdGetFile(Tcl_Interp *interp, OpenFileData *ofd,
                            unsigned char *initialFile, int isOpen);
static int              NavServicesGetFile(Tcl_Interp *interp, OpenFileData *ofd,
                            AEDesc *initialDesc, unsigned char *initialFile,
                            StringPtr title, StringPtr message, int multiple, int isOpen);
static int              HandleInitialDirectory (Tcl_Interp *interp, char *initialDir, FSSpec *dirSpec, 
                            AEDesc *dirDescPtr);                            
a86 5
int fileDlgInited = 0;
int useNavServices = 0;
NavObjectFilterUPP openFileFilterUPP;
NavEventUPP openFileEventUPP;

d95 62
a156 1
 * Tk_ChooseColorObjCmd --
d172 1
a172 1
Tk_ChooseColorObjCmd(
d175 2
a176 2
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST objv[])	/* Argument objects. */
d178 9
a186 5
    Tk_Window parent;
    char *title;
    int i, picked, srcRead, dstWrote;
    long response;
    OSErr err;
a187 7
    static RGBColor in;
    static char *optionStrings[] = {
	"-initialcolor",    "-parent",	    "-title",	    NULL
    };
    enum options {
	COLOR_INITIAL,	    COLOR_PARENT,   COLOR_TITLE
    };
a188 60
    if (inited == 0) {
    	/*
    	 * 'in' stores the last color picked.  The next time the color dialog
    	 * pops up, the last color will remain in the dialog.
    	 */
    	 
        in.red = 0xffff;
        in.green = 0xffff;
        in.blue = 0xffff;
        inited = 1;
    }
    
    parent = (Tk_Window) clientData;
    title = "Choose a color:";
    picked = 0;
        
    for (i = 1; i < objc; i += 2) {
    	int index;
    	char *option, *value;
    	
        if (Tcl_GetIndexFromObj(interp, objv[i], optionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (i + 1 == objc) {
	    option = Tcl_GetStringFromObj(objv[i], NULL);
	    Tcl_AppendResult(interp, "value for \"", option, "\" missing", 
		    (char *) NULL);
	    return TCL_ERROR;
	}
	value = Tcl_GetStringFromObj(objv[i + 1], NULL);
	
	switch ((enum options) index) {
	    case COLOR_INITIAL: {
		XColor *colorPtr;

		colorPtr = Tk_GetColor(interp, parent, value);
		if (colorPtr == NULL) {
		    return TCL_ERROR;
		}
		in.red   = colorPtr->red;
		in.green = colorPtr->green;
                in.blue  = colorPtr->blue;
                Tk_FreeColor(colorPtr);
		break;
	    }
	    case COLOR_PARENT: {
		parent = Tk_NameToWindow(interp, value, parent);
		if (parent == NULL) {
		    return TCL_ERROR;
		}
		break;
	    }
	    case COLOR_TITLE: {
	        title = value;
		break;
	    }
	}
    }
        
d197 39
a235 2
    if ((err == noErr) && (response == 0x0200L)) {
	ColorPickerInfo cpinfo;
d237 42
d282 1
a294 23
    	
    	Tcl_UtfToExternal(NULL, NULL, title, -1, 0, NULL, 
		StrBody(cpinfo.prompt), 255, &srcRead, &dstWrote, NULL);
    	StrLength(cpinfo.prompt) = (unsigned char) dstWrote;

        if ((PickColor(&cpinfo) == noErr) && (cpinfo.newColorChosen != 0)) {
            in.red 	= cpinfo.theColor.color.rgb.red;
            in.green 	= cpinfo.theColor.color.rgb.green;
            in.blue 	= cpinfo.theColor.color.rgb.blue;
            picked = 1;
        }
    } else {
    	RGBColor out;
    	Str255 prompt;
    	Point point = {-1, -1};
    	
        /*
         * Use version 1.0 of the color picker
         */
    	
    	Tcl_UtfToExternal(NULL, NULL, title, -1, 0, NULL, StrBody(prompt), 
		255, &srcRead, &dstWrote, NULL);
    	StrLength(prompt) = (unsigned char) dstWrote;
d296 15
a310 3
        if (GetColor(point, prompt, &in, &out)) {
            in = out;
            picked = 1;
d312 1
a312 4
    } 
    
    if (picked != 0) {
        char result[32];
d314 2
a315 3
        sprintf(result, "#%02x%02x%02x", in.red >> 8, in.green >> 8, 
        	in.blue >> 8);
	Tcl_AppendResult(interp, result, NULL);
d317 1
d319 5
d329 1
a329 1
 * Tk_GetOpenFileObjCmd --
d344 1
a344 1
Tk_GetOpenFileObjCmd(
d347 2
a348 2
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST objv[])	/* Argument objects. */
d350 1
a350 123
    int i, result, multiple;
    OpenFileData ofd;
    Tk_Window parent;
    Str255 message, title;
    AEDesc initialDesc = {typeNull, NULL};
    FSSpec dirSpec;
    static char *openOptionStrings[] = {
	    "-defaultextension", "-filetypes", 
	    "-initialdir", "-initialfile", 
	    "-message", "-multiple",
	    "-parent",	"-title", 	NULL
    };
    enum openOptions {
	    OPEN_DEFAULT, OPEN_TYPES,	
	    OPEN_INITDIR, OPEN_INITFILE,
	    OPEN_MESSAGE, OPEN_MULTIPLE, 
	    OPEN_PARENT, OPEN_TITLE
    };
    
    if (!fileDlgInited) {
	InitFileDialogs();
    }
    
    result = TCL_ERROR;    
    parent = (Tk_Window) clientData; 
    multiple = false;
    title[0] = 0;
    message[0] = 0;   

    TkInitFileFilters(&ofd.fl);
    
    ofd.curType		= 0;
    ofd.popupItem	= OPEN_POPUP_ITEM;
    ofd.usePopup 	= 1;

    for (i = 1; i < objc; i += 2) {
        char *choice;
	int index, choiceLen;
	char *string;
	int srcRead, dstWrote;

	if (Tcl_GetIndexFromObj(interp, objv[i], openOptionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    result = TCL_ERROR;
	    goto end;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(objv[i], NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    result = TCL_ERROR;
	    goto end;
	}
	
	switch (index) {
	    case OPEN_DEFAULT:
	        break;
	    case OPEN_TYPES:
	        choice = Tcl_GetStringFromObj(objv[i + 1], NULL);
                if (TkGetFileFilters(interp, &ofd.fl, choice, 0) 
                        != TCL_OK) {
                    result = TCL_ERROR;
                    goto end;
                }
	        break;
	    case OPEN_INITDIR:
	        choice = Tcl_GetStringFromObj(objv[i + 1], NULL);
                if (HandleInitialDirectory(interp, choice, &dirSpec, 
                        &initialDesc) != TCL_OK) {
                    result = TCL_ERROR;
                    goto end;
                }
	        break;
	    case OPEN_INITFILE:
	        break;
	    case OPEN_MESSAGE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
	        Tcl_UtfToExternal(NULL, NULL, choice, choiceLen, 
		        0, NULL, StrBody(message), 255, 
		        &srcRead, &dstWrote, NULL);
                message[0] = dstWrote;
	        break;
	    case OPEN_MULTIPLE:
	        if (Tcl_GetBooleanFromObj(interp, objv[i + 1], &multiple) != TCL_OK) {
	            result = TCL_ERROR;
	            goto end;
	        }
	        break;
	    case OPEN_PARENT:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
                parent = Tk_NameToWindow(interp, choice, parent);
	        if (parent == NULL) {
	            result = TCL_ERROR;
	            goto end;
	        }
	        break;
	    case OPEN_TITLE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
	        Tcl_UtfToExternal(NULL, NULL, choice, choiceLen, 
		        0, NULL, StrBody(title), 255, 
		        &srcRead, &dstWrote, NULL);
                title[0] = dstWrote;
	        break;
	}
    }
             
    if (useNavServices) {
        AEDesc *initialPtr = NULL;
        
        if (initialDesc.descriptorType == typeFSS) {
            initialPtr = &initialDesc;
        }
        result = NavServicesGetFile(interp, &ofd, initialPtr, NULL, 
                title, message, multiple, OPEN_FILE);
    } else {
        result = StdGetFile(interp, &ofd, NULL, OPEN_FILE);
    }

    end:
    TkFreeFileFilters(&ofd.fl);
    AEDisposeDesc(&initialDesc);
    
    return result;
d356 1
a356 1
 * Tk_GetSaveFileObjCmd --
d370 1
a370 1
Tk_GetSaveFileObjCmd(
d373 2
a374 2
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST objv[])	/* Argument objects. */
d376 1
a376 112
    int i, result;
    Str255 initialFile;
    Tk_Window parent;
    AEDesc initialDesc = {typeNull, NULL};
    FSSpec dirSpec;
    Str255 title, message;
    OpenFileData ofd;
    static char *saveOptionStrings[] = {
	    "-defaultextension", "-initialdir", "-initialfile", 
	    "-message", "-parent",	"-title", 	NULL
    };
    enum saveOptions {
	    SAVE_DEFAULT,	SAVE_INITDIR,	SAVE_INITFILE,
	    SAVE_MESSAGE,	SAVE_PARENT,	SAVE_TITLE
    };

    if (!fileDlgInited) {
	InitFileDialogs();
    }
    
    result = TCL_ERROR;    
    parent = (Tk_Window) clientData;    
    StrLength(initialFile) = 0;
    title[0] = 0;
    message[0] = 0;   
    

    for (i = 1; i < objc; i += 2) {
        char *choice;
	int index, choiceLen;
	char *string;
        Tcl_DString ds;
        int srcRead, dstWrote;

	if (Tcl_GetIndexFromObj(interp, objv[i], saveOptionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(objv[i], NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    return TCL_ERROR;
	}
	switch (index) {
	    case SAVE_DEFAULT:
	        break;
	    case SAVE_INITDIR:
	        choice = Tcl_GetStringFromObj(objv[i + 1], NULL);
                if (HandleInitialDirectory(interp, choice, &dirSpec, 
                        &initialDesc) != TCL_OK) {
                    result = TCL_ERROR;
                    goto end;
                }
	        break;
	    case SAVE_INITFILE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
                if (Tcl_TranslateFileName(interp, choice, &ds) == NULL) {
                    result = TCL_ERROR;
                    goto end;
                }
                Tcl_UtfToExternal(NULL, NULL, Tcl_DStringValue(&ds), 
        	        Tcl_DStringLength(&ds), 0, NULL, 
		        StrBody(initialFile), 255, &srcRead, &dstWrote, NULL);
                StrLength(initialFile) = (unsigned char) dstWrote;
                Tcl_DStringFree(&ds);            
	        break;
	    case SAVE_MESSAGE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
	        Tcl_UtfToExternal(NULL, NULL, choice, choiceLen, 
		        0, NULL, StrBody(message), 255, 
		        &srcRead, &dstWrote, NULL);
                StrLength(message) = (unsigned char) dstWrote;
	        break;
	    case SAVE_PARENT:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
                parent = Tk_NameToWindow(interp, choice, parent);
	        if (parent == NULL) {
	            result = TCL_ERROR;
	            goto end;
	        }
	        break;
	    case SAVE_TITLE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
	        Tcl_UtfToExternal(NULL, NULL, choice, choiceLen, 
		        0, NULL, StrBody(title), 255, 
		        &srcRead, &dstWrote, NULL);
                StrLength(title) = (unsigned char) dstWrote;
	        break;
	}
    }
         
    TkInitFileFilters(&ofd.fl);
    ofd.usePopup = 0;

    if (useNavServices) {
        AEDesc *initialPtr = NULL;
        
        if (initialDesc.descriptorType == typeFSS) {
            initialPtr = &initialDesc;
        }
        result = NavServicesGetFile(interp, &ofd, initialPtr, initialFile, 
                title, message, false, SAVE_FILE);
    } else {
        result = StdGetFile(interp, NULL, initialFile, SAVE_FILE);
    }

    end:
    
    AEDisposeDesc(&initialDesc);
    
    return result;
a381 192
 * Tk_ChooseDirectoryObjCmd --
 *
 *	This procedure implements the "tk_chooseDirectory" dialog box 
 *	for the Windows platform. See the user documentation for details 
 *	on what it does.
 *
 * Results:
 *	See user documentation.
 *
 * Side effects:
 *	A modal dialog window is created.  Tcl_SetServiceMode() is
 *	called to allow background events to be processed
 *
 *----------------------------------------------------------------------
 */

int
Tk_ChooseDirectoryObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int i, result;
    Tk_Window parent;
    AEDesc initialDesc = {typeNull, NULL};
    FSSpec dirSpec;
    Str255 message, title;
    int srcRead, dstWrote;
    OpenFileData ofd;
    static char *chooseOptionStrings[] = {
	    "-initialdir", "-message", "-mustexist", "-parent", "-title", NULL
    };
    enum chooseOptions {
	    CHOOSE_INITDIR,	CHOOSE_MESSAGE, CHOOSE_MUSTEXIST, 
	    CHOOSE_PARENT, CHOOSE_TITLE
    };
  
    
    if (!NavServicesAvailable()) {
        return TCL_ERROR;
    }

    if (!fileDlgInited) {
	InitFileDialogs();
    }
    result = TCL_ERROR;    
    parent = (Tk_Window) clientData;    
    title[0] = 0;
    message[0] = 0;   

    for (i = 1; i < objc; i += 2) {
        char *choice;
	int index, choiceLen;
	char *string;

	if (Tcl_GetIndexFromObj(interp, objv[i], chooseOptionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(objv[i], NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    return TCL_ERROR;
	}
	switch (index) {
	    case CHOOSE_INITDIR:
	        choice = Tcl_GetStringFromObj(objv[i + 1], NULL);
                if (HandleInitialDirectory(interp, choice, &dirSpec, 
                        &initialDesc) != TCL_OK) {
                    result = TCL_ERROR;
                    goto end;
                }
	        break;
	    case CHOOSE_MESSAGE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
	        Tcl_UtfToExternal(NULL, NULL, choice, choiceLen, 
		        0, NULL, StrBody(message), 255, 
		        &srcRead, &dstWrote, NULL);
                StrLength(message) = (unsigned char) dstWrote;
	        break;
	    case CHOOSE_PARENT:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
                parent = Tk_NameToWindow(interp, choice, parent);
	        if (parent == NULL) {
	            result = TCL_ERROR;
	            goto end;
	        }
	        break;
	    case CHOOSE_TITLE:
	        choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
	        Tcl_UtfToExternal(NULL, NULL, choice, choiceLen, 
		        0, NULL, StrBody(title), 255, 
		        &srcRead, &dstWrote, NULL);
                StrLength(title) = (unsigned char) dstWrote;
	        break;
	}
    }
             
    TkInitFileFilters(&ofd.fl);
    ofd.usePopup = 0;

    if (useNavServices) {
        AEDesc *initialPtr = NULL;
        
        if (initialDesc.descriptorType == typeFSS) {
            initialPtr = &initialDesc;
        }
        result = NavServicesGetFile(interp, &ofd, initialPtr, NULL, 
                title, message, false, CHOOSE_FOLDER);
    } else {
        result = TCL_ERROR;
    }

    end:
    AEDisposeDesc(&initialDesc);
    
    return result;
}

int
HandleInitialDirectory (
    Tcl_Interp *interp,
    char *initialDir, 
    FSSpec *dirSpec, 
    AEDesc *dirDescPtr)
{
	Tcl_DString ds;
	long dirID;
	OSErr err;
	Boolean isDirectory;
	Str255 dir;
	int srcRead, dstWrote;
	
	if (Tcl_TranslateFileName(interp, initialDir, &ds) == NULL) {
	    return TCL_ERROR;
	}
	Tcl_UtfToExternal(NULL, NULL, Tcl_DStringValue(&ds), 
		Tcl_DStringLength(&ds), 0, NULL, StrBody(dir), 255, 
		&srcRead, &dstWrote, NULL);
        StrLength(dir) = (unsigned char) dstWrote;
	Tcl_DStringFree(&ds);
          
	err = FSpLocationFromPath(StrLength(dir), StrBody(dir), dirSpec);
	if (err != noErr) {
	    Tcl_AppendResult(interp, "bad directory \"", initialDir, "\"", NULL);
	    return TCL_ERROR;
	}
	err = FSpGetDirectoryID(dirSpec, &dirID, &isDirectory);
	if ((err != noErr) || !isDirectory) {
	    Tcl_AppendResult(interp, "bad directory \"", initialDir, "\"", NULL);
	    return TCL_ERROR;
	}

        if (useNavServices) {
            AECreateDesc( typeFSS, dirSpec, sizeof(*dirSpec), dirDescPtr);        
        } else {
	    /*
	     * Make sure you negate -dirSpec.vRefNum because the 
	     * standard file package wants it that way !
	     */
	
	    LMSetSFSaveDisk(-dirSpec->vRefNum);
	    LMSetCurDirStore(dirID);
	}
        return TCL_OK;
}

static void
InitFileDialogs()
{
    fileDlgInited = 1;
    
    if (NavServicesAvailable()) {
        openFileFilterUPP = NewNavObjectFilterProc(OpenFileFilterProc);
        openFileEventUPP = NewNavEventProc(OpenEventProc);
        useNavServices = 1;
    } else {
	openFilter = NewFileFilterYDProc(FileFilterProc);
	openHook = NewDlgHookYDProc(OpenHookProc);
	saveHook = NewDlgHookYDProc(OpenHookProc);
	useNavServices = 0;
    }
    
        
}


/*
 *----------------------------------------------------------------------
 *
d392 2
a393 2
 *	is returned in the interp's result. Otherwise an empty string
 *	is returned in the interp's result.
d402 2
a403 2
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST objv[],	/* Argument objects. */
d407 6
a412 2
    return TCL_OK;
}
d414 1
a414 16
static int
NavServicesGetFile(
    Tcl_Interp *interp,
    OpenFileData *ofdPtr,
    AEDesc *initialDesc,
    unsigned char *initialFile,
    StringPtr title,
    StringPtr message,
    int multiple,
    int isOpen)
{
    NavReplyRecord theReply;
    NavDialogOptions diagOptions;
    OSErr err;
    Tcl_Obj *theResult;
    int result;
d416 4
a419 8
    
    diagOptions.location.h = -1;
    diagOptions.location.v = -1;
    diagOptions.dialogOptionFlags = kNavDontAutoTranslate 
            + kNavDontAddTranslateItems;
            
    if (multiple) {
        diagOptions.dialogOptionFlags += kNavAllowMultipleFiles;
d421 1
a421 98
    
    if (ofdPtr != NULL && ofdPtr->usePopup) {
        FileFilter *filterPtr;
        
	filterPtr = ofdPtr->fl.filters;
	if (filterPtr == NULL) {
	    ofdPtr->usePopup = 0;
	}
    }
    
    if (ofdPtr != NULL && ofdPtr->usePopup) {    
        NavMenuItemSpecHandle popupExtensionHandle = NULL;
        NavMenuItemSpec *popupItems;
        FileFilter *filterPtr;
        short index = 0;
	
	ofdPtr->curType = 0;
	
        popupExtensionHandle = (NavMenuItemSpecHandle) NewHandle(ofdPtr->fl.numFilters 
                * sizeof(NavMenuItemSpec));
        HLock((Handle) popupExtensionHandle);
        popupItems = *popupExtensionHandle;
        
        for (filterPtr = ofdPtr->fl.filters; filterPtr != NULL; 
                filterPtr = filterPtr->next, popupItems++, index++) {
            int len;
            
            len = strlen(filterPtr->name);
            BlockMove(filterPtr->name, popupItems->menuItemName + 1, len);
            popupItems->menuItemName[0] = len;
            popupItems->menuCreator = 'WIsH';
            popupItems->menuType = index;
        }
        HUnlock((Handle) popupExtensionHandle);
        diagOptions.popupExtension = popupExtensionHandle;
    } else {        
        diagOptions.dialogOptionFlags += kNavNoTypePopup; 
        diagOptions.popupExtension = NULL;
    }
        
    if ((initialFile != NULL) && (initialFile[0] != 0)) {
        char *lastColon;
        int len;
        
        len = initialFile[0];
        
        p2cstr(initialFile);        
        lastColon = strrchr((char *)initialFile, ':');
        if (lastColon != NULL) {
            len -= lastColon - ((char *) (initialFile + 1));
            BlockMove(lastColon + 1, diagOptions.savedFileName + 1, len);
            diagOptions.savedFileName[0] = len;
        } else {  
            BlockMove(initialFile, diagOptions.savedFileName + 1, len);
            diagOptions.savedFileName[0] = len;
        }
    } else {
        diagOptions.savedFileName[0] = 0;
    }
    
    strcpy((char *) (diagOptions.clientName + 1),"Wish");
    diagOptions.clientName[0] = strlen("Wish");
    
    if (title == NULL) {
        diagOptions.windowTitle[0] = 0;
    } else {
        BlockMove(title, diagOptions.windowTitle, title[0] + 1);
        diagOptions.windowTitle[0] = title[0];
    }
    
    if (message == NULL) {
        diagOptions.message[0] = 0;
    } else {
        BlockMove(message, diagOptions.message, message[0] + 1);
        diagOptions.message[0] = message[0];
    }
    
    diagOptions.actionButtonLabel[0] = 0;
    diagOptions.cancelButtonLabel[0] = 0;
    diagOptions.preferenceKey = 0;
    
    /* Now process the selection list.  We have to use the popupExtension
     * to fill the menu.
     */
    
    
    if (isOpen == OPEN_FILE) {
        err = NavGetFile(initialDesc, &theReply, &diagOptions, openFileEventUPP,  
                NULL, openFileFilterUPP, NULL, ofdPtr);    
    } else if (isOpen == SAVE_FILE) {
        err = NavPutFile (initialDesc, &theReply, &diagOptions, openFileEventUPP, 
                'TEXT', 'WIsH', NULL);
    } else if (isOpen == CHOOSE_FOLDER) {
        err = NavChooseFolder (initialDesc, &theReply, &diagOptions,
                openFileEventUPP, NULL, NULL);
    }
    
                        
d423 1
a423 2
     * Most commands assume that the file dialogs return a single
     * item, not a list.  So only build a list if multiple is true...
d425 3
a427 57
                         
    if (multiple) {
        theResult = Tcl_NewListObj(0, NULL);
    } else {
        theResult = Tcl_NewObj();
    }
           
    if ( theReply.validRecord && err == noErr ) {
        AEDesc resultDesc;
        long count;
        Tcl_DString fileName;
        Handle pathHandle;
        int length;
        
        if ( err == noErr ) {
            err = AECountItems(&(theReply.selection), &count);
            if (err == noErr) {
                long i;
                for (i = 1; i <= count; i++ ) {
                    err = AEGetNthDesc(&(theReply.selection),
                            i, typeFSS, NULL, &resultDesc);
                    if (err == noErr) {
                        HLock(resultDesc.dataHandle);
                        pathHandle = NULL;
                        FSpPathFromLocation((FSSpec *) *resultDesc.dataHandle, 
                                &length, &pathHandle);
                        HLock(pathHandle);
                        Tcl_ExternalToUtfDString(NULL, (char *) *pathHandle, -1, &fileName);
                        if (multiple) {
                            Tcl_ListObjAppendElement(interp, theResult, 
                                    Tcl_NewStringObj(Tcl_DStringValue(&fileName), 
                                    Tcl_DStringLength(&fileName)));
                        } else {
                            Tcl_SetStringObj(theResult, Tcl_DStringValue(&fileName), 
                                    Tcl_DStringLength(&fileName));
                        }
                        
                        Tcl_DStringFree(&fileName);
                        HUnlock(pathHandle);
                        DisposeHandle(pathHandle);
                        HUnlock(resultDesc.dataHandle);
                        AEDisposeDesc( &resultDesc );
                    }
                }
            }
         }
         err = NavDisposeReply( &theReply );
         Tcl_SetObjResult(interp, theResult);
         result = TCL_OK;
    } else if (err == userCanceledErr) {
        result = TCL_OK;
    } else {
        result = TCL_ERROR;
    }
    
    if (diagOptions.popupExtension != NULL) {
        DisposeHandle((Handle) diagOptions.popupExtension);
a428 105
    
    return result;
}

static pascal Boolean 
OpenFileFilterProc( 
    AEDesc* theItem, void* info,
    NavCallBackUserData callBackUD,
    NavFilterModes filterMode )
{
    OpenFileData *ofdPtr = (OpenFileData *) callBackUD;
    if (!ofdPtr->usePopup) {
        return true;
    } else {
        if (ofdPtr->fl.numFilters == 0) {
            return true;
        } else {
            
            if ( theItem->descriptorType == typeFSS ) {
                NavFileOrFolderInfo* theInfo = (NavFileOrFolderInfo*)info;
                int result;
                
                if ( !theInfo->isFolder ) {
                    OSType fileType;
                    StringPtr fileNamePtr;
                    int i;
                    FileFilter *filterPtr;
               
                    fileType = theInfo->fileAndFolder.fileInfo.finderInfo.fdType;
                    HLock(theItem->dataHandle);
                    fileNamePtr = (((FSSpec *) *theItem->dataHandle)->name);
                    
                    if (ofdPtr->usePopup) {
                        i = ofdPtr->curType;
	                for (filterPtr=ofdPtr->fl.filters; filterPtr && i>0; i--) {
	                    filterPtr = filterPtr->next;
	                }
	                if (filterPtr) {
	                    result = MatchOneType(fileNamePtr, fileType,
	                            ofdPtr, filterPtr);
	                } else {
	                    result = false;
                        }
                    } else {
	                /*
	                 * We are not using the popup menu. In this case, the file is
	                 * considered matched if it matches any of the file filters.
	                 */
			result = UNMATCHED;
	                for (filterPtr=ofdPtr->fl.filters; filterPtr;
		                filterPtr=filterPtr->next) {
	                    if (MatchOneType(fileNamePtr, fileType,
	                            ofdPtr, filterPtr) == MATCHED) {
	                        result = MATCHED;
	                        break;
	                    }
	                }
                    }
                    
                    HUnlock(theItem->dataHandle);
                    return (result == MATCHED);
                } else {
                    return true;
                }
            }
        }
        
        return true;
    }
}

pascal void 
OpenEventProc(
    NavEventCallbackMessage callBackSelector,
    NavCBRecPtr callBackParams,
    NavCallBackUserData callBackUD )
{
    NavMenuItemSpec *chosenItem;
    OpenFileData *ofd = (OpenFileData *) callBackUD;
    static SInt32 otherEvent = ~(kNavCBCustomize|kNavCBStart|kNavCBTerminate
	    |kNavCBNewLocation|kNavCBShowDesktop|kNavCBSelectEntry|kNavCBAccept
	    |kNavCBCancel|kNavCBAdjustPreview);
        
    if (callBackSelector ==  kNavCBPopupMenuSelect) {
        chosenItem = (NavMenuItemSpec *) callBackParams->eventData.eventDataParms.param;
        ofd->curType = chosenItem->menuType;
    } else if (callBackSelector == kNavCBAdjustRect || callBackSelector & otherEvent != 0) { 
        while (Tcl_DoOneEvent(TCL_IDLE_EVENTS|TCL_DONT_WAIT|TCL_WINDOW_EVENTS)) {
            /* Empty Body */
        }
    }
}

static int
StdGetFile(
    Tcl_Interp *interp,
    OpenFileData *ofd,
    unsigned char *initialFile,
    int isOpen)
{
    int i;
    StandardFileReply reply;
    Point mypoint;
    MenuHandle menu = NULL;

d431 1
a431 1
     * Set the items in the file types popup.
d439 4
a442 5
    if (ofd != NULL && ofd->usePopup) {
	FileFilter *filterPtr;
	
	menu = GetMenu(OPEN_MENU);
        for (i = CountMItems(menu); i > 0; i--) {
d448 1
a448 2
    	     
    	     DeleteMenuItem(menu, i);
d451 7
a457 3
	filterPtr = ofd->fl.filters;
	if (filterPtr == NULL) {
	    ofd->usePopup = 0;
d459 1
a459 7
	    for ( ; filterPtr != NULL; filterPtr = filterPtr->next) {
	        Str255 str;
	        
	    	StrLength(str) = (unsigned char) strlen(filterPtr->name);
	    	strcpy(StrBody(str), filterPtr->name);
		AppendMenu(menu, str);
	    }
d464 1
a464 1
     * Call the toolbox file dialog function.
a465 1
     
d468 6
a473 4
    if (isOpen == OPEN_FILE) {
        if (ofd != NULL && ofd->usePopup) {
	    CustomGetFile(openFilter, (short) -1, NULL, &reply, OPEN_BOX,
	    	    mypoint, openHook, NULL, NULL, NULL, (void*) &ofd);
d477 12
a488 4
    } else if (isOpen == SAVE_FILE) {
	static Str255 prompt = "\pSave as";
	
   	if (ofd != NULL && ofd->usePopup) {
d493 2
a494 2
	    CustomPutFile(prompt, initialFile, &reply, OPEN_BOX, 
		    mypoint, saveHook, NULL, NULL, NULL, (void *) ofd);
d496 1
a496 1
	    StandardPutFile(prompt, initialFile, &reply);
d500 1
a500 4
    /*
     * Now parse the reply, and populate the Tcl result.
     */
     
d503 2
a504 1
    	Handle pathHandle;
a505 1
    	pathHandle = NULL;
d507 1
a508 2
	    Tcl_DString ds;
	    
d510 2
a511 3
	    Tcl_ExternalToUtfDString(NULL, (char *) *pathHandle, -1, &ds);
	    Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
	    Tcl_DStringFree(&ds);
d514 6
d522 38
d561 99
a659 2
    if (menu != NULL) {
    	DisposeMenu(menu);
d663 5
d669 1
d692 1
a692 1
    OpenFileData *ofdPtr)	/* Information about the file dialog. */
d701 1
a701 1
	    if (ofdPtr->usePopup) {
d705 3
a707 3
		GetDialogItem(theDialog, ofdPtr->popupItem, &ignore, &handle, 
			&rect);
		SetControlValue((ControlRef) handle, ofdPtr->curType + 1);
d712 2
a713 2
	    if (ofdPtr->usePopup) {
		GetDialogItem(theDialog, ofdPtr->popupItem,
d716 2
a717 2
		if (ofdPtr->curType != newType) {
		    if (newType<0 || newType>ofdPtr->fl.numFilters) {
d723 1
a723 1
			ofdPtr->curType = newType;
d758 1
a758 1
    OpenFileData * ofdPtr = (OpenFileData*)myData;
d761 1
a761 1
    if (ofdPtr->fl.numFilters == 0) {
d775 3
a777 3
    if (ofdPtr->usePopup) {
        i = ofdPtr->curType;
	for (filterPtr=ofdPtr->fl.filters; filterPtr && i>0; i--) {
d781 1
a781 2
	    return MatchOneType(pb->hFileInfo.ioNamePtr, pb->hFileInfo.ioFlFndrInfo.fdType,
	            ofdPtr, filterPtr);
d791 1
a791 1
	for (filterPtr=ofdPtr->fl.filters; filterPtr;
d793 1
a793 2
	    if (MatchOneType(pb->hFileInfo.ioNamePtr, pb->hFileInfo.ioFlFndrInfo.fdType,
	            ofdPtr, filterPtr) == MATCHED) {
d820 2
a821 3
    StringPtr fileNamePtr,	/* Name of the file */
    OSType    fileType,         /* Type of the file */ 
    OpenFileData * ofdPtr,	/* Information about this file dialog */
d862 1
a862 1
	    if (fileNamePtr == NULL) {
d865 1
a865 1
	    p = (char*)(fileNamePtr);
d899 1
a899 1
	    if (fileType == mfPtr->type) {
d912 18
d931 9
a939 1

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tkMacDialog.c,v 1.9 2002/04/08 09:04:38 das Exp $
d144 1
a144 1
    static CONST char *optionStrings[] = {
d231 1
a231 1
    	cpinfo.flags = kColorPickerCanModifyPalette | kColorPickerCanAnimatePalette;
d307 1
a307 1
    static CONST char *openOptionStrings[] = {
d456 2
a457 2
    static CONST char *saveOptionStrings[] = {
	    "-defaultextension", "-filetypes", "-initialdir", "-initialfile", 
d461 1
a461 1
	    SAVE_DEFAULT,	SAVE_TYPES,	SAVE_INITDIR,	SAVE_INITFILE,
a495 2
	    case SAVE_TYPES:
	        break;
d596 1
a596 1
    static CONST char *chooseOptionStrings[] = {
d715 1
a715 1
	err = FSpGetDirectoryIDTcl(dirSpec, &dirID, &isDirectory);
d1051 3
d1058 3
a1060 7
    } else if (callBackSelector == kNavCBEvent) {
    	if (callBackParams->eventData.eventDataParms.event->what == updateEvt) {
    		if (TkMacConvertEvent( callBackParams->eventData.eventDataParms.event)) {
        		while (Tcl_DoOneEvent(TCL_IDLE_EVENTS|TCL_DONT_WAIT|TCL_WINDOW_EVENTS)) {
           			/* Empty Body */
        		}
        	}
d1124 1
a1124 1
	    	    mypoint, openHook, NULL, NULL, NULL, (void*) ofd);
d1216 1
a1216 1
		newType = GetControlValue((ControlRef) handle) - 1;
@


