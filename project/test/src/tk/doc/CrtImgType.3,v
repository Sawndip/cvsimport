head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@.\" @;
expand	@o@;


1.5
date	2003.01.21.20.24.40;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.12;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.23;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.49;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.29;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.58;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@'\"
'\" Copyright (c) 1994 The Regents of the University of California.
'\" Copyright (c) 1994-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @@(#) $Id: CrtImgType.3,v 1.6 2002/08/05 04:30:38 dgp Exp $
'\" 
.so man.macros
.TH Tk_CreateImageType 3 8.3 Tk "Tk Library Procedures"
.BS
.SH NAME
Tk_CreateImageType, Tk_GetImageMasterData, Tk_InitImageArgs \- define new kind of image
.SH SYNOPSIS
.nf
\fB#include <tk.h>\fR
.sp
\fBTk_CreateImageType\fR(\fItypePtr\fR)
ClientData
.sp
.VS
\fBTk_GetImageMasterData\fR(\fIinterp, name, typePtrPtr\fR)
.sp
\fBTk_InitImageArgs\fR(\fIinterp, argc, argvPtr\fR)
.SH ARGUMENTS
.AS Tk_ImageType *typePtrPtr
.AP Tk_ImageType *typePtr in
Structure that defines the new type of image.
Must be static: a
pointer to this structure is retained by the image code.
.AP Tcl_Interp *interp in
Interpreter in which image was created.
.AP "CONST char" *name in
Name of existing image.
.AP Tk_ImageType **typePtrPtr out
Points to word in which to store a pointer to type information for
the given image, if it exists.
.AP int argc in
Number of arguments
.AP char ***argvPtr in/out
Pointer to argument list
.VE
.BE

.SH DESCRIPTION
.PP
\fBTk_CreateImageType\fR is invoked to define a new kind of image.
An image type corresponds to a particular value of the \fItype\fR
argument for the \fBimage create\fR command.  There may exist
any number of different image types, and new types may be defined
dynamically by calling \fBTk_CreateImageType\fR.
For example, there might be one type for 2-color bitmaps,
another for multi-color images, another for dithered images,
another for video, and so on.
.PP
The code that implements a new image type is called an
\fIimage manager\fR.
It consists of a collection of procedures plus three different
kinds of data structures.
The first data structure is a Tk_ImageType structure, which contains
the name of the image type and pointers to five procedures provided
by the image manager to deal with images of this type:
.CS
typedef struct Tk_ImageType {
	char *\fIname\fR;
	Tk_ImageCreateProc *\fIcreateProc\fR;
	Tk_ImageGetProc *\fIgetProc\fR;
	Tk_ImageDisplayProc *\fIdisplayProc\fR;
	Tk_ImageFreeProc *\fIfreeProc\fR;
	Tk_ImageDeleteProc *\fIdeleteProc\fR;
} Tk_ImageType;
.CE
The fields of this structure will be described in later subsections
of this entry.
.PP
The second major data structure manipulated by an image manager
is called an \fIimage master\fR;  it contains overall information
about a particular image, such as the values of the configuration
options specified in an \fBimage create\fR command.
There will usually be one of these structures for each
invocation of the \fBimage create\fR command.
.PP
The third data structure related to images is an \fIimage instance\fR.
There will usually be one of these structures for each usage of an
image in a particular widget.
It is possible for a single image to appear simultaneously
in multiple widgets, or even multiple times in the same widget.
Furthermore, different instances may be on different screens
or displays.
The image instance data structure describes things that may
vary from instance to instance, such as colors and graphics
contexts for redisplay.
There is usually one instance structure for each \fB\-image\fR
option specified for a widget or canvas item.
.PP
The following subsections describe the fields of a Tk_ImageType
in more detail.

.SH NAME
.PP
\fItypePtr->name\fR provides a name for the image type.
Once \fBTk_CreateImageType\fR returns, this name may be used
in \fBimage create\fR commands to create images of the new
type.
If there already existed an image type by this name then
the new image type replaces the old one.

.SH PORTABILITY
.PP
In Tk 8.2 and earlier, the createProc below had a different
signature. If you want to compile an image type using the
old interface which should still run on all Tcl/Tk versions,
compile it with the flag -DUSE_OLD_IMAGE. Further on, if
you are using Stubs, you need to call the function
Tk_InitImageArgs(interp, argc, &argv) first in your
createProc. See below for a description of this function.

.SH CREATEPROC
\fItypePtr->createProc\fR provides the address of a procedure for
Tk to call whenever \fBimage create\fR is invoked to create
an image of the new type.
\fItypePtr->createProc\fR must match the following prototype:
.CS
typedef int Tk_ImageCreateProc(
	Tcl_Interp *\fIinterp\fR,
	char *\fIname\fR,
	int \fIobjc\fR,
	Tcl_Obj *CONST \fIobjv\fR[],
	Tk_ImageType *\fItypePtr\fR,
	Tk_ImageMaster \fImaster\fR,
	ClientData *\fImasterDataPtr\fR);
.CE
The \fIinterp\fR argument is the interpreter in which the \fBimage\fR
command was invoked, and \fIname\fR is the name for the new image,
which was either specified explicitly in the \fBimage\fR command
or generated automatically by the \fBimage\fR command.
The \fIobjc\fR and \fIobjv\fR arguments describe all the configuration
options for the new image (everything after the name argument to
\fBimage\fR).
The \fImaster\fR argument is a token that refers to Tk's information
about this image;  the image manager must return this token to
Tk when invoking the \fBTk_ImageChanged\fR procedure.
Typically \fIcreateProc\fR will parse \fIobjc\fR and \fIobjv\fR
and create an image master data structure for the new image.
\fIcreateProc\fR may store an arbitrary one-word value at
*\fImasterDataPtr\fR, which will be passed back to the
image manager when other callbacks are invoked.
Typically the value is a pointer to the master data
structure for the image.
.PP
If \fIcreateProc\fR encounters an error, it should leave an error
message in \fIinterp->result\fR and return \fBTCL_ERROR\fR;  otherwise
it should return \fBTCL_OK\fR.
.PP
\fIcreateProc\fR should call \fBTk_ImageChanged\fR in order to set the
size of the image and request an initial redisplay.

.SH GETPROC
.PP
\fItypePtr->getProc\fR is invoked by Tk whenever a widget
calls \fBTk_GetImage\fR to use a particular image.
This procedure must match the following prototype:
.CS
typedef ClientData Tk_ImageGetProc(
	Tk_Window \fItkwin\fR,
	ClientData \fImasterData\fR);
.CE
The \fItkwin\fR argument identifies the window in which the
image will be used and \fImasterData\fR is the value
returned by \fIcreateProc\fR when the image master was created.
\fIgetProc\fR will usually create a data structure for the new
instance, including such things as the resources needed to
display the image in the given window.
\fIgetProc\fR returns a one-word token for the instance, which
is typically the address of the instance data structure.
Tk will pass this value back to the image manager when invoking
its \fIdisplayProc\fR and \fIfreeProc\fR procedures.

.SH DISPLAYPROC
.PP
\fItypePtr->displayProc\fR is invoked by Tk whenever an image needs
to be displayed (i.e., whenever a widget calls \fBTk_RedrawImage\fR).
\fIdisplayProc\fR must match the following prototype:
.CS
typedef void Tk_ImageDisplayProc(
	ClientData \fIinstanceData\fR,
	Display *\fIdisplay\fR,
	Drawable \fIdrawable\fR,
	int \fIimageX\fR,
	int \fIimageY\fR,
	int \fIwidth\fR,
	int \fIheight\fR,
	int \fIdrawableX\fR,
	int \fIdrawableY\fR);
.CE
The \fIinstanceData\fR will be the same as the value returned by
\fIgetProc\fR when the instance was created.
\fIdisplay\fR and \fIdrawable\fR indicate where to display the
image;  \fIdrawable\fR may be a pixmap rather than
the window specified to \fIgetProc\fR (this is usually the case,
since most widgets double-buffer their redisplay to get smoother
visual effects).
\fIimageX\fR, \fIimageY\fR, \fIwidth\fR, and \fIheight\fR
identify the region of the image that must be redisplayed.
This region will always be within the size of the image
as specified in the most recent call to \fBTk_ImageChanged\fR.
\fIdrawableX\fR and \fIdrawableY\fR indicate where in \fIdrawable\fR
the image should be displayed;  \fIdisplayProc\fR should display
the given region of the image so that point (\fIimageX\fR, \fIimageY\fR)
in the image appears at (\fIdrawableX\fR, \fIdrawableY\fR) in \fIdrawable\fR.

.SH FREEPROC
.PP
\fItypePtr->freeProc\fR contains the address of a procedure that
Tk will invoke when an image instance is released (i.e., when
\fBTk_FreeImage\fR is invoked).
This can happen, for example, when a widget is deleted or a image item
in a canvas is deleted, or when the image displayed in a widget or
canvas item is changed.
\fIfreeProc\fR must match the following prototype:
.CS
typedef void Tk_ImageFreeProc(
	ClientData \fIinstanceData\fR,
	Display *\fIdisplay\fR);
.CE
The \fIinstanceData\fR will be the same as the value returned by
\fIgetProc\fR when the instance was created, and \fIdisplay\fR
is the display containing the window for the instance.
\fIfreeProc\fR should release any resources associated with the
image instance, since the instance will never be used again.

.SH DELETEPROC
.PP
\fItypePtr->deleteProc\fR is a procedure that Tk invokes when an
image is being deleted (i.e. when the \fBimage delete\fR command
is invoked).
Before invoking \fIdeleteProc\fR Tk will invoke \fIfreeProc\fR for
each of the image's instances.
\fIdeleteProc\fR must match the following prototype:
.CS
typedef void Tk_ImageDeleteProc(
	ClientData \fImasterData\fR);
.CE
The \fImasterData\fR argument will be the same as the value
stored in \fI*masterDataPtr\fR by \fIcreateProc\fR when the
image was created.
\fIdeleteProc\fR should release any resources associated with
the image.

.SH TK_GETIMAGEMASTERDATA
.VS
.PP
The procedure \fBTk_GetImageMasterData\fR may be invoked to retrieve
information about an image.  For example, an image manager can use this
procedure to locate its image master data for an image.
If there exists an image named \fIname\fR
in the interpreter given by \fIinterp\fR, then \fI*typePtrPtr\fR is
filled in with type information for the image (the \fItypePtr\fR value
passed to \fBTk_CreateImageType\fR when the image type was registered)
and the return value is the ClientData value returned by the
\fIcreateProc\fR when the image was created (this is typically a
pointer to the image master data structure).  If no such image exists
then NULL is returned and NULL is stored at \fI*typePtrPtr\fR.
.VE

.SH TK_INITIMAGEARGS
.VS
.PP
The function \fBTk_InitImageArgs\fR converts the arguments of the
\fBcreateProc\fR from objects to strings when necessary. When
not using stubs, not using the old interface, or running
under an older (pre-8.3) Tk version, this function has no
effect. This function makes porting older image handlers to
the new interface a lot easier: After running this function,
the arguments are guaranteed to be in string format, no
matter how Tk deliverd them.

.SH "SEE ALSO"
Tk_ImageChanged, Tk_GetImage, Tk_FreeImage, Tk_RedrawImage, Tk_SizeOfImage

.SH KEYWORDS
image manager, image type, instance, master
@


1.4
log
@touched all sources to ease next import
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: CrtImgType.3,v 1.7.6.1 2000/05/04 21:26:21 spolk Exp $
d34 1
a34 1
.AP char *name in
d39 1
a39 1
.AP int argc
d41 1
a41 1
.AP char ***argvPtr
a283 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: CrtImgType.3,v 1.8 1999/01/26 04:11:13 jingham Exp $
d11 1
a11 1
.TH Tk_CreateImageType 3 8.0 Tk "Tk Library Procedures"
d14 1
a14 1
Tk_CreateImageType, Tk_GetImageMasterData \- define new kind of image
d24 2
d39 4
d109 10
d128 2
a129 2
	int \fIargc\fR,
	char **\fIargv\fR,
d138 1
a138 1
The \fIargc\fR and \fIargv\fR arguments describe all the configuration
d144 1
a144 1
Typically \fIcreateProc\fR will parse \fIargc\fR and \fIargv\fR
d267 12
d284 1
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: CrtImgType.3,v 1.7.6.1 2000/05/04 21:26:21 spolk Exp $
d11 1
a11 1
.TH Tk_CreateImageType 3 8.3 Tk "Tk Library Procedures"
d14 1
a14 1
Tk_CreateImageType, Tk_GetImageMasterData, Tk_InitImageArgs \- define new kind of image
a23 2
.sp
\fBTk_InitImageArgs\fR(\fIinterp, argc, argvPtr\fR)
a36 4
.AP int argc
Number of arguments
.AP char ***argvPtr
Pointer to argument list
a102 10
.SH PORTABILITY
.PP
In Tk 8.2 and earlier, the createProc below had a different
signature. If you want to compile an image type using the
old interface which should still run on all Tcl/Tk versions,
compile it with the flag -DUSE_OLD_IMAGE. Further on, if
you are using Stubs, you need to call the function
Tk_InitImageArgs(interp, argc, &argv) first in your
createProc. See below for a description of this function.

d112 2
a113 2
	int \fIobjc\fR,
	Tcl_Obj *CONST \fIobjv\fR[],
d122 1
a122 1
The \fIobjc\fR and \fIobjv\fR arguments describe all the configuration
d128 1
a128 1
Typically \fIcreateProc\fR will parse \fIobjc\fR and \fIobjv\fR
a250 12
.SH TK_INITIMAGEARGS
.VS
.PP
The function \fBTk_InitImageArgs\fR converts the arguments of the
\fBcreateProc\fR from objects to strings when necessary. When
not using stubs, not using the old interface, or running
under an older (pre-8.3) Tk version, this function has no
effect. This function makes porting older image handlers to
the new interface a lot easier: After running this function,
the arguments are guaranteed to be in string format, no
matter how Tk deliverd them.

a255 1

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: CrtImgType.3,v 1.6 2002/08/05 04:30:38 dgp Exp $
d34 1
a34 1
.AP "CONST char" *name in
d39 1
a39 1
.AP int argc in
d41 1
a41 1
.AP char ***argvPtr in/out
d284 1
@


