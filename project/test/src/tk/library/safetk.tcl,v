head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.46;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.14;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.26;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.52;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.33;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.50;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# safetk.tcl --
#
# Support procs to use Tk in safe interpreters.
#
# RCS: @@(#) $Id: safetk.tcl,v 1.8 2000/10/31 01:11:51 hobbs Exp $
#
# Copyright (c) 1997 Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

# see safetk.n for documentation

#
#
# Note: It is now ok to let untrusted code being executed
#       between the creation of the interp and the actual loading
#       of Tk in that interp because the C side Tk_Init will
#       now look up the master interp and ask its safe::TkInit
#       for the actual parameters to use for it's initialization (if allowed),
#       not relying on the slave state.
#

# We use opt (optional arguments parsing)
package require opt 0.4.1;

namespace eval ::safe {

    # counter for safe toplevels
    variable tkSafeId 0;

    #
    # tkInterpInit : prepare the slave interpreter for tk loading
    #                most of the real job is done by loadTk
    # returns the slave name (tkInterpInit does)
    #
    proc ::safe::tkInterpInit {slave argv} {
	global env tk_library

	# We have to make sure that the tk_library variable uses a file
	# pathname that works better in Tk (of the style returned by
	# [file join], ie C:/path/to/tk/lib, not C:\path\to\tk\lib
	set tk_library [file join $tk_library]

	# Clear Tk's access for that interp (path).
	allowTk $slave $argv

	# there seems to be an obscure case where the tk_library
	# variable value is changed to point to a sym link destination
	# dir instead of the sym link itself, and thus where the $tk_library
	# would then not be anymore one of the auto_path dir, so we use
	# the addToAccessPath which adds if it's not already in instead
	# of the more conventional findInAccessPath.
	# Might be usefull for masters without Tk really loaded too.
	::interp eval $slave [list set tk_library [::safe::interpAddToAccessPath $slave $tk_library]]
	return $slave
    }


# tkInterpLoadTk : 
# Do additional configuration as needed (calling tkInterpInit) 
# and actually load Tk into the slave.
# 
# Either contained in the specified windowId (-use) or
# creating a decorated toplevel for it.

# empty definition for auto_mkIndex
proc ::safe::loadTk {} {}
   
::tcl::OptProc loadTk {
    {slave -interp "name of the slave interpreter"}
    {-use  -windowId {} "window Id to use (new toplevel otherwise)"}
    {-display -displayName {} "display name to use (current one otherwise)"}
} {
    set displayGiven [::tcl::OptProcArgGiven "-display"]
    if {!$displayGiven} {
	
	# Try to get the current display from "."
	# (which might not exist if the master is tk-less)
	
	if {[catch {set display [winfo screen .]}]} {
	    if {[info exists ::env(DISPLAY)]} {
		set display $::env(DISPLAY)
	    } else {
		Log $slave "no winfo screen . nor env(DISPLAY)" WARNING
		set display ":0.0"
	    }
	}
    }
    if {![::tcl::OptProcArgGiven "-use"]} {
	
	# create a decorated toplevel
	
	::tcl::Lassign [tkTopLevel $slave $display] w use

	# set our delete hook (slave arg is added by interpDelete)
	# to clean up both window related code and tkInit(slave)
	Set [DeleteHookName $slave] [list tkDelete {} $w]

    } else {

	# set our delete hook (slave arg is added by interpDelete)
	# to clean up tkInit(slave)
	    
	Set [DeleteHookName $slave] [list disallowTk]

	# Let's be nice and also accept tk window names instead of ids
	
	if {[string match ".*" $use]} {
	    set windowName $use
	    set use [winfo id $windowName]
	    set nDisplay [winfo screen $windowName]
	} else {

	    # Check for a better -display value
	    # (works only for multi screens on single host, but not
	    #  cross hosts, for that a tk window name would be better
	    #  but embeding is also usefull for non tk names)
	    
	    if {![catch {winfo pathname $use} name]} {
		set nDisplay [winfo screen $name]
	    } else {

		# Can't have a better one
		
		set nDisplay $display
	    }
	}
	if {[string compare $nDisplay $display]} {
	    if {$displayGiven} {
		error "conflicting -display $display and -use\
			$use -> $nDisplay"
	    } else {
		set display $nDisplay
	    }
	}
    }

    # Prepares the slave for tk with those parameters
    
    tkInterpInit $slave [list "-use" $use "-display" $display]
    
    load {} Tk $slave

    return $slave
}

proc ::safe::TkInit {interpPath} {
    variable tkInit
    if {[info exists tkInit($interpPath)]} {
	set value $tkInit($interpPath)
	Log $interpPath "TkInit called, returning \"$value\"" NOTICE
	return $value
    } else {
	Log $interpPath "TkInit called for interp with clearance:\
		preventing Tk init" ERROR
	error "not allowed"
    }
}

# safe::allowTk --
#
#	Set tkInit(interpPath) to allow Tk to be initialized in
#	safe::TkInit.
#
# Arguments:
#	interpPath	slave interpreter handle
#	argv		arguments passed to safe::TkInterpInit
#
# Results:
#	none.

proc ::safe::allowTk {interpPath argv} {
    variable tkInit
    set tkInit($interpPath) $argv
    return
}


# safe::disallowTk --
#
#	Unset tkInit(interpPath) to disallow Tk from getting initialized
#	in safe::TkInit.
#
# Arguments:
#	interpPath	slave interpreter handle
#
# Results:
#	none.

proc ::safe::disallowTk {interpPath} {
    variable tkInit
    # This can already be deleted by the DeleteHook of the interp
    if {[info exists tkInit($interpPath)]} {
	unset tkInit($interpPath)
    }
    return
}


# safe::tkDelete --
#
#	Clean up the window associated with the interp being deleted.
#
# Arguments:
#	interpPath	slave interpreter handle
#
# Results:
#	none.

proc ::safe::tkDelete {W window slave} {

    # we are going to be called for each widget... skip untill it's
    # top level

    Log $slave "Called tkDelete $W $window" NOTICE
    if {[::interp exists $slave]} {
	if {[catch {::safe::interpDelete $slave} msg]} {
	    Log $slave "Deletion error : $msg"
	}
    }
    if {[winfo exists $window]} {
	Log $slave "Destroy toplevel $window" NOTICE
	destroy $window
    }
    
    # clean up tkInit(slave)
    disallowTk $slave
    return
}

proc ::safe::tkTopLevel {slave display} {
    variable tkSafeId
    incr tkSafeId
    set w ".safe$tkSafeId"
    if {[catch {toplevel $w -screen $display -class SafeTk} msg]} {
	return -code error "Unable to create toplevel for\
		safe slave \"$slave\" ($msg)"
    }
    Log $slave "New toplevel $w" NOTICE

    set msg "Untrusted Tcl applet ($slave)"
    wm title $w $msg

    # Control frame
    set wc $w.fc
    frame $wc -bg red -borderwidth 3 -relief ridge

    # We will destroy the interp when the window is destroyed
    bindtags $wc [concat Safe$wc [bindtags $wc]]
    bind Safe$wc <Destroy> [list ::safe::tkDelete %W $w $slave]

    label $wc.l -text $msg -padx 2 -pady 0 -anchor w

    # We want the button to be the last visible item
    # (so be packed first) and at the right and not resizing horizontally

    # frame the button so it does not expand horizontally
    # but still have the default background instead of red one from the parent
    frame  $wc.fb -bd 0
    button $wc.fb.b -text "Delete" \
	    -bd 1  -padx 2 -pady 0 -highlightthickness 0 \
	    -command [list ::safe::tkDelete $w $w $slave]
    pack $wc.fb.b -side right -fill both
    pack $wc.fb -side right -fill both -expand 1
    pack $wc.l -side left  -fill both -expand 1
    pack $wc -side bottom -fill x

    # Container frame
    frame $w.c -container 1
    pack $w.c -fill both -expand 1
    
    # return both the toplevel window name and the id to use for embedding
    list $w [winfo id $w.c]
}

}
@


1.4
log
@touched all sources to ease next import
@
text
@d5 1
a5 1
# RCS: @@(#) $Id: safetk.tcl,v 1.7.6.2 2000/09/26 16:08:45 spolk Exp $
d43 1
a43 1
	set tk_library [eval [list file join] [file split $tk_library]]
a277 2


@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
# SCCS: @@(#) safetk.tcl 1.8 97/10/29 14:59:16
d25 1
a25 1
package require opt 0.1;
d40 5
d56 1
a56 1
	return $slave;
d70 17
a86 16
    ::tcl::OptProc loadTk {
	{slave -interp "name of the slave interpreter"}
	{-use  -windowId {} "window Id to use (new toplevel otherwise)"}
	{-display -displayName {} "display name to use (current one otherwise)"}
    } {
	set displayGiven [::tcl::OptProcArgGiven "-display"]
	if {!$displayGiven} {
	    # Try to get the current display from "."
	    # (which might not exist if the master is tk-less)
	    if {[catch {set display [winfo screen .]}]} {
		if {[info exists ::env(DISPLAY)]} {
		    set display $::env(DISPLAY)
		} else {
		    Log $slave "no winfo screen . nor env(DISPLAY)" WARNING
		    set display ":0.0"
		}
d89 24
a112 5
	if {![::tcl::OptProcArgGiven "-use"]} {
	    # create a decorated toplevel
	    ::tcl::Lassign [tkTopLevel $slave $display] w use;
	    # set our delete hook (slave arg is added by interpDelete)
	    Set [DeleteHookName $slave] [list tkDelete {} $w];
d114 8
a121 5
	    # Let's be nice and also accept tk window names instead of ids
	    if {[string match ".*" $use]} {
		set windowName $use
		set use [winfo id $windowName]
		set nDisplay [winfo screen $windowName]
d123 4
a126 10
		# Check for a better -display value
		# (works only for multi screens on single host, but not
		#  cross hosts, for that a tk window name would be better
		#  but embeding is also usefull for non tk names)
		if {![catch {winfo pathname $use} name]} {
		    set nDisplay [winfo screen $name]
		} else {
		    # Can't have a better one
		    set nDisplay $display
		}
d128 7
a134 7
	    if {[string compare $nDisplay $display]} {
		if {$displayGiven} {
		    error "conflicting -display $display and -use\
			    $use -> $nDisplay"
		} else {
		    set display $nDisplay
		}
d137 1
d139 5
a143 1
	# Prepares the slave for tk with those parameters
d145 2
a146 6
	tkInterpInit $slave [list "-use" $use "-display" $display]

	load {} Tk $slave

	return $slave
    }
d161 12
d176 1
d179 41
a219 12
    proc ::safe::tkDelete {W window slave} {
	# we are going to be called for each widget... skip untill it's
	# top level
	Log $slave "Called tkDelete $W $window" NOTICE;
	if {[::interp exists $slave]} {
	    if {[catch {::safe::interpDelete $slave} msg]} {
		Log $slave "Deletion error : $msg";
	    }
	}
	if {[winfo exists $window]} {
	    Log $slave "Destroy toplevel $window" NOTICE;
	    destroy $window;
d222 9
d233 3
a235 3
    variable tkSafeId;
    incr tkSafeId;
    set w ".safe$tkSafeId";
d238 1
a238 1
		safe slave \"$slave\" ($msg)";
d243 1
a243 1
    wm title $w $msg;
d247 1
a247 1
    frame $wc -bg red -borderwidth 3 -relief ridge ;
d251 1
a251 1
    bind Safe$wc <Destroy> [list ::safe::tkDelete %W $w $slave];
d253 1
a253 2
    label $wc.l -text $msg \
	    -padx 2 -pady 0 -anchor w;
d260 1
a260 1
    frame  $wc.fb -bd 0 ;
d264 4
a267 4
    pack $wc.fb.b -side right -fill both ;
    pack $wc.fb -side right -fill both -expand 1;
    pack $wc.l -side left  -fill both -expand 1;
    pack $wc -side bottom -fill x ;
d270 2
a271 2
    frame $w.c -container 1;
    pack $w.c -fill both -expand 1;
d274 1
a274 1
    list $w [winfo id $w.c] ;
d278 2
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d5 1
a5 1
# RCS: @@(#) $Id: safetk.tcl,v 1.7.6.2 2000/09/26 16:08:45 spolk Exp $
d25 1
a25 1
package require opt 0.4.1;
a39 5
	# We have to make sure that the tk_library variable uses a file
	# pathname that works better in Tk (of the style returned by
	# [file join], ie C:/path/to/tk/lib, not C:\path\to\tk\lib
	set tk_library [eval [list file join] [file split $tk_library]]

d51 1
a51 1
	return $slave
d65 16
a80 17
::tcl::OptProc loadTk {
    {slave -interp "name of the slave interpreter"}
    {-use  -windowId {} "window Id to use (new toplevel otherwise)"}
    {-display -displayName {} "display name to use (current one otherwise)"}
} {
    set displayGiven [::tcl::OptProcArgGiven "-display"]
    if {!$displayGiven} {
	
	# Try to get the current display from "."
	# (which might not exist if the master is tk-less)
	
	if {[catch {set display [winfo screen .]}]} {
	    if {[info exists ::env(DISPLAY)]} {
		set display $::env(DISPLAY)
	    } else {
		Log $slave "no winfo screen . nor env(DISPLAY)" WARNING
		set display ":0.0"
d83 5
a87 24
    }
    if {![::tcl::OptProcArgGiven "-use"]} {
	
	# create a decorated toplevel
	
	::tcl::Lassign [tkTopLevel $slave $display] w use

	# set our delete hook (slave arg is added by interpDelete)
	# to clean up both window related code and tkInit(slave)
	Set [DeleteHookName $slave] [list tkDelete {} $w]

    } else {

	# set our delete hook (slave arg is added by interpDelete)
	# to clean up tkInit(slave)
	    
	Set [DeleteHookName $slave] [list disallowTk]

	# Let's be nice and also accept tk window names instead of ids
	
	if {[string match ".*" $use]} {
	    set windowName $use
	    set use [winfo id $windowName]
	    set nDisplay [winfo screen $windowName]
d89 5
a93 8

	    # Check for a better -display value
	    # (works only for multi screens on single host, but not
	    #  cross hosts, for that a tk window name would be better
	    #  but embeding is also usefull for non tk names)
	    
	    if {![catch {winfo pathname $use} name]} {
		set nDisplay [winfo screen $name]
d95 10
a104 4

		# Can't have a better one
		
		set nDisplay $display
d106 7
a112 7
	}
	if {[string compare $nDisplay $display]} {
	    if {$displayGiven} {
		error "conflicting -display $display and -use\
			$use -> $nDisplay"
	    } else {
		set display $nDisplay
a114 1
    }
d116 5
a120 5
    # Prepares the slave for tk with those parameters
    
    tkInterpInit $slave [list "-use" $use "-display" $display]
    
    load {} Tk $slave
d122 2
a123 2
    return $slave
}
a137 12
# safe::allowTk --
#
#	Set tkInit(interpPath) to allow Tk to be initialized in
#	safe::TkInit.
#
# Arguments:
#	interpPath	slave interpreter handle
#	argv		arguments passed to safe::TkInterpInit
#
# Results:
#	none.

a140 1
    return
d143 12
a154 41

# safe::disallowTk --
#
#	Unset tkInit(interpPath) to disallow Tk from getting initialized
#	in safe::TkInit.
#
# Arguments:
#	interpPath	slave interpreter handle
#
# Results:
#	none.

proc ::safe::disallowTk {interpPath} {
    variable tkInit
    # This can already be deleted by the DeleteHook of the interp
    if {[info exists tkInit($interpPath)]} {
	unset tkInit($interpPath)
    }
    return
}


# safe::tkDelete --
#
#	Clean up the window associated with the interp being deleted.
#
# Arguments:
#	interpPath	slave interpreter handle
#
# Results:
#	none.

proc ::safe::tkDelete {W window slave} {

    # we are going to be called for each widget... skip untill it's
    # top level

    Log $slave "Called tkDelete $W $window" NOTICE
    if {[::interp exists $slave]} {
	if {[catch {::safe::interpDelete $slave} msg]} {
	    Log $slave "Deletion error : $msg"
a156 9
    if {[winfo exists $window]} {
	Log $slave "Destroy toplevel $window" NOTICE
	destroy $window
    }
    
    # clean up tkInit(slave)
    disallowTk $slave
    return
}
d159 3
a161 3
    variable tkSafeId
    incr tkSafeId
    set w ".safe$tkSafeId"
d164 1
a164 1
		safe slave \"$slave\" ($msg)"
d169 1
a169 1
    wm title $w $msg
d173 1
a173 1
    frame $wc -bg red -borderwidth 3 -relief ridge
d177 1
a177 1
    bind Safe$wc <Destroy> [list ::safe::tkDelete %W $w $slave]
d179 2
a180 1
    label $wc.l -text $msg -padx 2 -pady 0 -anchor w
d187 1
a187 1
    frame  $wc.fb -bd 0
d191 4
a194 4
    pack $wc.fb.b -side right -fill both
    pack $wc.fb -side right -fill both -expand 1
    pack $wc.l -side left  -fill both -expand 1
    pack $wc -side bottom -fill x
d197 2
a198 2
    frame $w.c -container 1
    pack $w.c -fill both -expand 1
d201 1
a201 1
    list $w [winfo id $w.c]
a204 2


@


1.1.1.3
log
@import tk 8.4.0
@
text
@d5 1
a5 1
# RCS: @@(#) $Id: safetk.tcl,v 1.8 2000/10/31 01:11:51 hobbs Exp $
d43 1
a43 1
	set tk_library [file join $tk_library]
d278 2
@


