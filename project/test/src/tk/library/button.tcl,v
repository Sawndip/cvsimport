head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.46;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.14;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.26;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.51;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.33;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.49;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# button.tcl --
#
# This file defines the default bindings for Tk label, button,
# checkbutton, and radiobutton widgets and provides procedures
# that help in implementing those bindings.
#
# RCS: @@(#) $Id: button.tcl,v 1.17 2002/09/04 02:05:52 hobbs Exp $
#
# Copyright (c) 1992-1994 The Regents of the University of California.
# Copyright (c) 1994-1996 Sun Microsystems, Inc.
# Copyright (c) 2002 ActiveState Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

#-------------------------------------------------------------------------
# The code below creates the default class bindings for buttons.
#-------------------------------------------------------------------------

if {[string equal [tk windowingsystem] "classic"]
	|| [string equal [tk windowingsystem] "aqua"]} {
    bind Radiobutton <Enter> {
	tk::ButtonEnter %W
    }
    bind Radiobutton <1> {
	tk::ButtonDown %W
    }
    bind Radiobutton <ButtonRelease-1> {
	tk::ButtonUp %W
    }
    bind Checkbutton <Enter> {
	tk::ButtonEnter %W
    }
    bind Checkbutton <1> {
	tk::ButtonDown %W
    }
    bind Checkbutton <ButtonRelease-1> {
	tk::ButtonUp %W
    }
}
if {[string equal "windows" $tcl_platform(platform)]} {
    bind Checkbutton <equal> {
	tk::CheckRadioInvoke %W select
    }
    bind Checkbutton <plus> {
	tk::CheckRadioInvoke %W select
    }
    bind Checkbutton <minus> {
	tk::CheckRadioInvoke %W deselect
    }
    bind Checkbutton <1> {
	tk::CheckRadioDown %W
    }
    bind Checkbutton <ButtonRelease-1> {
	tk::ButtonUp %W
    }
    bind Checkbutton <Enter> {
	tk::CheckRadioEnter %W
    }

    bind Radiobutton <1> {
	tk::CheckRadioDown %W
    }
    bind Radiobutton <ButtonRelease-1> {
	tk::ButtonUp %W
    }
    bind Radiobutton <Enter> {
	tk::CheckRadioEnter %W
    }
}
if {[string equal "x11" [tk windowingsystem]]} {
    bind Checkbutton <Return> {
	if {!$tk_strictMotif} {
	    tk::CheckRadioInvoke %W
	}
    }
    bind Radiobutton <Return> {
	if {!$tk_strictMotif} {
	    tk::CheckRadioInvoke %W
	}
    }
    bind Checkbutton <1> {
	tk::CheckRadioInvoke %W
    }
    bind Radiobutton <1> {
	tk::CheckRadioInvoke %W
    }
    bind Checkbutton <Enter> {
	tk::ButtonEnter %W
    }
    bind Radiobutton <Enter> {
	tk::ButtonEnter %W
    }
}

bind Button <space> {
    tk::ButtonInvoke %W
}
bind Checkbutton <space> {
    tk::CheckRadioInvoke %W
}
bind Radiobutton <space> {
    tk::CheckRadioInvoke %W
}

bind Button <FocusIn> {}
bind Button <Enter> {
    tk::ButtonEnter %W
}
bind Button <Leave> {
    tk::ButtonLeave %W
}
bind Button <1> {
    tk::ButtonDown %W
}
bind Button <ButtonRelease-1> {
    tk::ButtonUp %W
}

bind Checkbutton <FocusIn> {}
bind Checkbutton <Leave> {
    tk::ButtonLeave %W
}

bind Radiobutton <FocusIn> {}
bind Radiobutton <Leave> {
    tk::ButtonLeave %W
}

if {[string equal "windows" $tcl_platform(platform)]} {

#########################
# Windows implementation 
#########################

# ::tk::ButtonEnter --
# The procedure below is invoked when the mouse pointer enters a
# button widget.  It records the button we're in and changes the
# state of the button to active unless the button is disabled.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonEnter w {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {

	# If the mouse button is down, set the relief to sunken on entry.
	# Overwise, if there's an -overrelief value, set the relief to that.

	set Priv($w,relief) [$w cget -relief]
	if {$Priv(buttonWindow) eq $w} {
	    $w configure -relief sunken -state active
	    set Priv($w,prelief) sunken
	} elseif {[set over [$w cget -overrelief]] ne ""} {
	    $w configure -relief $over
	    set Priv($w,prelief) $over
	}
    }
    set Priv(window) $w
}

# ::tk::ButtonLeave --
# The procedure below is invoked when the mouse pointer leaves a
# button widget.  It changes the state of the button back to inactive.
# Restore any modified relief too.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonLeave w {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {
	$w configure -state normal
    }

    # Restore the original button relief if it was changed by Tk.
    # That is signaled by the existence of Priv($w,prelief).

    if {[info exists Priv($w,relief)]} {
	if {[info exists Priv($w,prelief)] && \
		$Priv($w,prelief) eq [$w cget -relief]} {
	    $w configure -relief $Priv($w,relief)
	}
	unset -nocomplain Priv($w,relief) Priv($w,prelief)
    }

    set Priv(window) ""
}

# ::tk::ButtonDown --
# The procedure below is invoked when the mouse button is pressed in
# a button widget.  It records the fact that the mouse is in the button,
# saves the button's relief so it can be restored later, and changes
# the relief to sunken.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonDown w {
    variable ::tk::Priv

    # Only save the button's relief if it does not yet exist.  If there
    # is an overrelief setting, Priv($w,relief) will already have been set,
    # and the current value of the -relief option will be incorrect.

    if {![info exists Priv($w,relief)]} {
	set Priv($w,relief) [$w cget -relief]
    }

    if {[$w cget -state] ne "disabled"} {
	set Priv(buttonWindow) $w
	$w configure -relief sunken -state active
	set Priv($w,prelief) sunken

	# If this button has a repeatdelay set up, get it going with an after
	after cancel $Priv(afterId)
	set delay [$w cget -repeatdelay]
	set Priv(repeated) 0
	if {$delay > 0} {
	    set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
	}
    }
}

# ::tk::ButtonUp --
# The procedure below is invoked when the mouse button is released
# in a button widget.  It restores the button's relief and invokes
# the command as long as the mouse hasn't left the button.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonUp w {
    variable ::tk::Priv
    if {$Priv(buttonWindow) eq $w} {
	set Priv(buttonWindow) ""

	# Restore the button's relief if it was cached.

	if {[info exists Priv($w,relief)]} {
	    if {[info exists Priv($w,prelief)] && \
		    $Priv($w,prelief) eq [$w cget -relief]} {
		$w configure -relief $Priv($w,relief)
	    }
	    unset -nocomplain Priv($w,relief) Priv($w,prelief)
	}

	# Clean up the after event from the auto-repeater
	after cancel $Priv(afterId)

	if {$Priv(window) eq $w && [$w cget -state] ne "disabled"} {
	    $w configure -state normal

	    # Only invoke the command if it wasn't already invoked by the
	    # auto-repeater functionality
	    if { $Priv(repeated) == 0 } {
		uplevel #0 [list $w invoke]
	    }
	}
    }
}

# ::tk::CheckRadioEnter --
# The procedure below is invoked when the mouse pointer enters a
# checkbutton or radiobutton widget.  It records the button we're in
# and changes the state of the button to active unless the button is
# disabled.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::CheckRadioEnter w {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {
	if {$Priv(buttonWindow) eq $w} {
	    $w configure -state active
	}
	if {[set over [$w cget -overrelief]] ne ""} {
	    set Priv($w,relief)  [$w cget -relief]
	    set Priv($w,prelief) $over
	    $w configure -relief $over
	}
    }
    set Priv(window) $w
}

# ::tk::CheckRadioDown --
# The procedure below is invoked when the mouse button is pressed in
# a button widget.  It records the fact that the mouse is in the button,
# saves the button's relief so it can be restored later, and changes
# the relief to sunken.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::CheckRadioDown w {
    variable ::tk::Priv
    if {![info exists Priv($w,relief)]} {
	set Priv($w,relief) [$w cget -relief]
    }
    if {[$w cget -state] ne "disabled"} {
	set Priv(buttonWindow) $w
	set Priv(repeated) 0
	$w configure -state active
    }
}

}

if {[string equal "x11" [tk windowingsystem]]} {

#####################
# Unix implementation
#####################

# ::tk::ButtonEnter --
# The procedure below is invoked when the mouse pointer enters a
# button widget.  It records the button we're in and changes the
# state of the button to active unless the button is disabled.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonEnter {w} {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {
	# On unix the state is active just with mouse-over
	$w configure -state active

	# If the mouse button is down, set the relief to sunken on entry.
	# Overwise, if there's an -overrelief value, set the relief to that.

	set Priv($w,relief) [$w cget -relief]
	if {$Priv(buttonWindow) eq $w} {
	    $w configure -relief sunken
	    set Priv($w,prelief) sunken
	} elseif {[set over [$w cget -overrelief]] ne ""} {
	    $w configure -relief $over
	    set Priv($w,prelief) $over
	}
    }
    set Priv(window) $w
}

# ::tk::ButtonLeave --
# The procedure below is invoked when the mouse pointer leaves a
# button widget.  It changes the state of the button back to inactive.
# Restore any modified relief too.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonLeave w {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {
	$w configure -state normal
    }

    # Restore the original button relief if it was changed by Tk.
    # That is signaled by the existence of Priv($w,prelief).

    if {[info exists Priv($w,relief)]} {
	if {[info exists Priv($w,prelief)] && \
		$Priv($w,prelief) eq [$w cget -relief]} {
	    $w configure -relief $Priv($w,relief)
	}
	unset -nocomplain Priv($w,relief) Priv($w,prelief)
    }

    set Priv(window) ""
}

# ::tk::ButtonDown --
# The procedure below is invoked when the mouse button is pressed in
# a button widget.  It records the fact that the mouse is in the button,
# saves the button's relief so it can be restored later, and changes
# the relief to sunken.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonDown w {
    variable ::tk::Priv

    # Only save the button's relief if it does not yet exist.  If there
    # is an overrelief setting, Priv($w,relief) will already have been set,
    # and the current value of the -relief option will be incorrect.

    if {![info exists Priv($w,relief)]} {
	set Priv($w,relief) [$w cget -relief]
    }

    if {[$w cget -state] ne "disabled"} {
	set Priv(buttonWindow) $w
	$w configure -relief sunken
	set Priv($w,prelief) sunken

	# If this button has a repeatdelay set up, get it going with an after
	after cancel $Priv(afterId)
	set delay [$w cget -repeatdelay]
	set Priv(repeated) 0
	if {$delay > 0} {
	    set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
	}
    }
}

# ::tk::ButtonUp --
# The procedure below is invoked when the mouse button is released
# in a button widget.  It restores the button's relief and invokes
# the command as long as the mouse hasn't left the button.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonUp w {
    variable ::tk::Priv
    if {[string equal $w $Priv(buttonWindow)]} {
	set Priv(buttonWindow) ""

	# Restore the button's relief if it was cached.

	if {[info exists Priv($w,relief)]} {
	    if {[info exists Priv($w,prelief)] && \
		    $Priv($w,prelief) eq [$w cget -relief]} {
		$w configure -relief $Priv($w,relief)
	    }
	    unset -nocomplain Priv($w,relief) Priv($w,prelief)
	}

	# Clean up the after event from the auto-repeater
	after cancel $Priv(afterId)

	if {$Priv(window) eq $w && [$w cget -state] ne "disabled"} {
	    # Only invoke the command if it wasn't already invoked by the
	    # auto-repeater functionality
	    if { $Priv(repeated) == 0 } {
		uplevel #0 [list $w invoke]
	    }
	}
    }
}

}

if {[string equal [tk windowingsystem] "classic"]
	|| [string equal [tk windowingsystem] "aqua"]} {

####################
# Mac implementation
####################

# ::tk::ButtonEnter --
# The procedure below is invoked when the mouse pointer enters a
# button widget.  It records the button we're in and changes the
# state of the button to active unless the button is disabled.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonEnter {w} {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {

	# If there's an -overrelief value, set the relief to that.

	if {$Priv(buttonWindow) eq $w} {
	    $w configure -state active
	} elseif {[set over [$w cget -overrelief]] ne ""} {
	    set Priv($w,relief)  [$w cget -relief]
	    set Priv($w,prelief) $over
	    $w configure -relief $over
	}
    }
    set Priv(window) $w
}

# ::tk::ButtonLeave --
# The procedure below is invoked when the mouse pointer leaves a
# button widget.  It changes the state of the button back to
# inactive.  If we're leaving the button window with a mouse button
# pressed (Priv(buttonWindow) == $w), restore the relief of the
# button too.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonLeave w {
    variable ::tk::Priv
    if {$w eq $Priv(buttonWindow)} {
	$w configure -state normal
    }

    # Restore the original button relief if it was changed by Tk.
    # That is signaled by the existence of Priv($w,prelief).

    if {[info exists Priv($w,relief)]} {
	if {[info exists Priv($w,prelief)] && \
		$Priv($w,prelief) eq [$w cget -relief]} {
	    $w configure -relief $Priv($w,relief)
	}
	unset -nocomplain Priv($w,relief) Priv($w,prelief)
    }

    set Priv(window) ""
}

# ::tk::ButtonDown --
# The procedure below is invoked when the mouse button is pressed in
# a button widget.  It records the fact that the mouse is in the button,
# saves the button's relief so it can be restored later, and changes
# the relief to sunken.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonDown w {
    variable ::tk::Priv

    if {[$w cget -state] ne "disabled"} {
	set Priv(buttonWindow) $w
	$w configure -state active

	# If this button has a repeatdelay set up, get it going with an after
	after cancel $Priv(afterId)
	set Priv(repeated) 0
	if { ![catch {$w cget -repeatdelay} delay] } {
	    if {$delay > 0} {
		set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
	    }
	}
    }
}

# ::tk::ButtonUp --
# The procedure below is invoked when the mouse button is released
# in a button widget.  It restores the button's relief and invokes
# the command as long as the mouse hasn't left the button.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonUp w {
    variable ::tk::Priv
    if {$Priv(buttonWindow) eq $w} {
	set Priv(buttonWindow) ""
	$w configure -state normal

	# Restore the button's relief if it was cached.

	if {[info exists Priv($w,relief)]} {
	    if {[info exists Priv($w,prelief)] && \
		    $Priv($w,prelief) eq [$w cget -relief]} {
		$w configure -relief $Priv($w,relief)
	    }
	    unset -nocomplain Priv($w,relief) Priv($w,prelief)
	}

	# Clean up the after event from the auto-repeater
	after cancel $Priv(afterId)

	if {$Priv(window) eq $w && [$w cget -state] ne "disabled"} {
	    # Only invoke the command if it wasn't already invoked by the
	    # auto-repeater functionality
	    if { $Priv(repeated) == 0 } {
		uplevel #0 [list $w invoke]
	    }
	}
    }
}

}

##################
# Shared routines
##################

# ::tk::ButtonInvoke --
# The procedure below is called when a button is invoked through
# the keyboard.  It simulate a press of the button via the mouse.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonInvoke w {
    if {[$w cget -state] ne "disabled"} {
	set oldRelief [$w cget -relief]
	set oldState [$w cget -state]
	$w configure -state active -relief sunken
	update idletasks
	after 100
	$w configure -state $oldState -relief $oldRelief
	uplevel #0 [list $w invoke]
    }
}

# ::tk::ButtonAutoInvoke --
#
#	Invoke an auto-repeating button, and set it up to continue to repeat.
#
# Arguments:
#	w	button to invoke.
#
# Results:
#	None.
#
# Side effects:
#	May create an after event to call ::tk::ButtonAutoInvoke.

proc ::tk::ButtonAutoInvoke {w} {
    variable ::tk::Priv
    after cancel $Priv(afterId)
    set delay [$w cget -repeatinterval]
    if {$Priv(window) eq $w} {
	incr Priv(repeated)
	uplevel #0 [list $w invoke]
    }
    if {$delay > 0} {
	set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
    }
}

# ::tk::CheckRadioInvoke --
# The procedure below is invoked when the mouse button is pressed in
# a checkbutton or radiobutton widget, or when the widget is invoked
# through the keyboard.  It invokes the widget if it
# isn't disabled.
#
# Arguments:
# w -		The name of the widget.
# cmd -		The subcommand to invoke (one of invoke, select, or deselect).

proc ::tk::CheckRadioInvoke {w {cmd invoke}} {
    if {[$w cget -state] ne "disabled"} {
	uplevel #0 [list $w $cmd]
    }
}
@


1.4
log
@touched all sources to ease next import
@
text
@d7 1
a7 1
# RCS: @@(#) $Id: button.tcl,v 1.7.6.1 2000/05/04 21:26:25 spolk Exp $
d11 1
d21 2
a22 1
if {[string match "macintosh" $tcl_platform(platform)]} {
d24 1
a24 1
	tkButtonEnter %W
d27 1
a27 1
	tkButtonDown %W
d30 1
a30 1
	tkButtonUp %W
d33 1
a33 1
	tkButtonEnter %W
d36 1
a36 1
	tkButtonDown %W
d39 1
a39 1
	tkButtonUp %W
d42 1
a42 1
if {[string match "windows" $tcl_platform(platform)]} {
d44 1
a44 1
	tkCheckRadioInvoke %W select
d47 1
a47 1
	tkCheckRadioInvoke %W select
d50 1
a50 1
	tkCheckRadioInvoke %W deselect
d53 1
a53 1
	tkCheckRadioDown %W
d56 1
a56 1
	tkButtonUp %W
d59 1
a59 1
	tkCheckRadioEnter %W
d63 1
a63 1
	tkCheckRadioDown %W
d66 1
a66 1
	tkButtonUp %W
d69 1
a69 1
	tkCheckRadioEnter %W
d72 1
a72 1
if {[string match "unix" $tcl_platform(platform)]} {
d75 1
a75 1
	    tkCheckRadioInvoke %W
d80 1
a80 1
	    tkCheckRadioInvoke %W
d84 1
a84 1
	tkCheckRadioInvoke %W
d87 1
a87 1
	tkCheckRadioInvoke %W
d90 1
a90 1
	tkButtonEnter %W
d93 1
a93 1
	tkButtonEnter %W
d98 1
a98 1
    tkButtonInvoke %W
d101 1
a101 1
    tkCheckRadioInvoke %W
d104 1
a104 1
    tkCheckRadioInvoke %W
d109 1
a109 1
    tkButtonEnter %W
d112 1
a112 1
    tkButtonLeave %W
d115 1
a115 1
    tkButtonDown %W
d118 1
a118 1
    tkButtonUp %W
d123 1
a123 1
    tkButtonLeave %W
d128 1
a128 1
    tkButtonLeave %W
d131 1
a131 1
if {[string match "windows" $tcl_platform(platform)]} {
d137 1
a137 1
# tkButtonEnter --
d145 15
a159 5
proc tkButtonEnter w {
    global tkPriv
    if {[string compare [$w cget -state] "disabled"] \
	    && [string equal $tkPriv(buttonWindow) $w]} {
	$w configure -state active -relief sunken
d161 1
a161 1
    set tkPriv(window) $w
d164 1
a164 1
# tkButtonLeave --
d166 2
a167 4
# button widget.  It changes the state of the button back to
# inactive.  If we're leaving the button window with a mouse button
# pressed (tkPriv(buttonWindow) == $w), restore the relief of the
# button too.
d172 3
a174 3
proc tkButtonLeave w {
    global tkPriv
    if {[string compare [$w cget -state] "disabled"]} {
a176 5
    if {[string equal $tkPriv(buttonWindow) $w]} {
	$w configure -relief $tkPriv(relief)
    }
    set tkPriv(window) ""
}
d178 2
a179 8
# tkCheckRadioEnter --
# The procedure below is invoked when the mouse pointer enters a
# checkbutton or radiobutton widget.  It records the button we're in
# and changes the state of the button to active unless the button is
# disabled.
#
# Arguments:
# w -		The name of the widget.
d181 6
a186 5
proc tkCheckRadioEnter w {
    global tkPriv
    if {[string compare [$w cget -state] "disabled"] \
	    && [string equal $tkPriv(buttonWindow) $w]} {
	$w configure -state active
d188 2
a189 1
    set tkPriv(window) $w
d192 1
a192 1
# tkButtonDown --
d201 13
a213 5
proc tkButtonDown w {
    global tkPriv
    set tkPriv(relief) [$w cget -relief]
    if {[string compare [$w cget -state] "disabled"]} {
	set tkPriv(buttonWindow) $w
d215 9
d227 4
a230 5
# tkCheckRadioDown --
# The procedure below is invoked when the mouse button is pressed in
# a button widget.  It records the fact that the mouse is in the button,
# saves the button's relief so it can be restored later, and changes
# the relief to sunken.
d235 27
a261 6
proc tkCheckRadioDown w {
    global tkPriv
    set tkPriv(relief) [$w cget -relief]
    if {[string compare [$w cget -state] "disabled"]} {
	set tkPriv(buttonWindow) $w
	$w configure -state active
d265 5
a269 4
# tkButtonUp --
# The procedure below is invoked when the mouse button is released
# in a button widget.  It restores the button's relief and invokes
# the command as long as the mouse hasn't left the button.
d274 10
a283 9
proc tkButtonUp w {
    global tkPriv
    if {[string equal $tkPriv(buttonWindow) $w]} {
	set tkPriv(buttonWindow) ""
	$w configure -relief $tkPriv(relief)
	if {[string equal $tkPriv(window) $w]
              && [string compare [$w cget -state] "disabled"]} {
	    $w configure -state normal
	    uplevel #0 [list $w invoke]
d286 1
d289 19
d310 3
a312 1
if {[string match "unix" $tcl_platform(platform)]} {
d318 1
a318 1
# tkButtonEnter --
d326 4
a329 3
proc tkButtonEnter {w} {
    global tkPriv
    if {[string compare [$w cget -state] "disabled"]} {
d331 11
a341 2
	if {[string equal $tkPriv(buttonWindow) $w]} {
	    $w configure -state active -relief sunken
d344 1
a344 1
    set tkPriv(window) $w
d347 1
a347 1
# tkButtonLeave --
d349 2
a350 4
# button widget.  It changes the state of the button back to
# inactive.  If we're leaving the button window with a mouse button
# pressed (tkPriv(buttonWindow) == $w), restore the relief of the
# button too.
d355 3
a357 3
proc tkButtonLeave w {
    global tkPriv
    if {[string compare [$w cget -state] "disabled"]} {
d360 10
a369 2
    if {[string equal $tkPriv(buttonWindow) $w]} {
	$w configure -relief $tkPriv(relief)
d371 2
a372 1
    set tkPriv(window) ""
d375 1
a375 1
# tkButtonDown --
d384 13
a396 5
proc tkButtonDown w {
    global tkPriv
    set tkPriv(relief) [$w cget -relief]
    if {[string compare [$w cget -state] "disabled"]} {
	set tkPriv(buttonWindow) $w
d398 9
d410 1
a410 1
# tkButtonUp --
d418 24
a441 8
proc tkButtonUp w {
    global tkPriv
    if {[string equal $w $tkPriv(buttonWindow)]} {
	set tkPriv(buttonWindow) ""
	$w configure -relief $tkPriv(relief)
	if {[string equal $w $tkPriv(window)] \
		&& [string compare [$w cget -state] "disabled"]} {
	    uplevel #0 [list $w invoke]
d448 2
a449 1
if {[string match "macintosh" $tcl_platform(platform)]} {
d455 1
a455 1
# tkButtonEnter --
d463 7
a469 4
proc tkButtonEnter {w} {
    global tkPriv
    if {[string compare [$w cget -state] "disabled"]} {
      if {[string equal $w $tkPriv(buttonWindow)]} {
d471 4
d477 1
a477 1
    set tkPriv(window) $w
d480 1
a480 1
# tkButtonLeave --
d484 1
a484 1
# pressed (tkPriv(buttonWindow) == $w), restore the relief of the
d490 3
a492 3
proc tkButtonLeave w {
    global tkPriv
    if {[string equal $w $tkPriv(buttonWindow)]} {
d495 13
a507 1
    set tkPriv(window) ""
d510 1
a510 1
# tkButtonDown --
d519 5
a523 4
proc tkButtonDown w {
    global tkPriv
    if {[string compare [$w cget -state] "disabled"]} {
	set tkPriv(buttonWindow) $w
d525 9
d537 1
a537 1
# tkButtonUp --
d545 4
a548 3
proc tkButtonUp w {
    global tkPriv
    if {[string equal $w $tkPriv(buttonWindow)]} {
d550 20
a569 4
	set tkPriv(buttonWindow) ""
	if {[string equal $w $tkPriv(window)]
              && [string compare [$w cget -state] "disabled"]} {
	    uplevel #0 [list $w invoke]
d580 1
a580 1
# tkButtonInvoke --
d587 2
a588 2
proc tkButtonInvoke w {
    if {[string compare [$w cget -state] "disabled"]} {
d599 27
a625 1
# tkCheckRadioInvoke --
d635 2
a636 2
proc tkCheckRadioInvoke {w {cmd invoke}} {
    if {[string compare [$w cget -state] "disabled"]} {
a639 2


@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
# SCCS: @@(#) button.tcl 1.22 96/11/14 14:49:11
d20 1
a20 1
if {$tcl_platform(platform) == "macintosh"} {
d40 1
a40 10
if {$tcl_platform(platform) == "windows"} {
    bind Button <Return> {
	tkButtonInvoke %W
    }
    bind Checkbutton <Return> {
	tkCheckRadioInvoke %W
    }
    bind Radiobutton <Return> {
	tkCheckRadioInvoke %W
    }
d70 1
a70 1
if {$tcl_platform(platform) == "unix"} {
d129 1
a129 1
if {$tcl_platform(platform) == "windows"} {
d145 3
a147 4
    if {[$w cget -state] != "disabled"} {
	if {$tkPriv(buttonWindow) == $w} {
	    $w configure -state active -relief sunken
	}
d164 2
a165 2
    if {[$w cget -state] != "disabled"} {
	$w config -state normal
d167 1
a167 1
    if {$w == $tkPriv(buttonWindow)} {
d184 3
a186 4
    if {[$w cget -state] != "disabled"} {
	if {$tkPriv(buttonWindow) == $w} {
	    $w configure -state active
	}
d202 2
a203 2
    set tkPriv(relief) [lindex [$w conf -relief] 4]
    if {[$w cget -state] != "disabled"} {
d205 1
a205 1
	$w config -relief sunken -state active
d220 2
a221 2
    set tkPriv(relief) [lindex [$w conf -relief] 4]
    if {[$w cget -state] != "disabled"} {
d223 1
a223 1
	$w config -state active
d237 1
a237 1
    if {$w == $tkPriv(buttonWindow)} {
d239 4
a242 3
	if {($w == $tkPriv(window))
		&& ([$w cget -state] != "disabled")} {
	    $w config -relief $tkPriv(relief) -state normal
d250 1
a250 1
if {$tcl_platform(platform) == "unix"} {
d266 3
a268 3
    if {[$w cget -state] != "disabled"} {
	$w config -state active
	if {$tkPriv(buttonWindow) == $w} {
d287 2
a288 2
    if {[$w cget -state] != "disabled"} {
	$w config -state normal
d290 1
a290 1
    if {$w == $tkPriv(buttonWindow)} {
d307 2
a308 2
    set tkPriv(relief) [lindex [$w config -relief] 4]
    if {[$w cget -state] != "disabled"} {
d310 1
a310 1
	$w config -relief sunken
d324 1
a324 1
    if {$w == $tkPriv(buttonWindow)} {
d326 3
a328 3
	$w config -relief $tkPriv(relief)
	if {($w == $tkPriv(window))
		&& ([$w cget -state] != "disabled")} {
d336 1
a336 1
if {$tcl_platform(platform) == "macintosh"} {
d352 2
a353 2
    if {[$w cget -state] != "disabled"} {
	if {$tkPriv(buttonWindow) == $w} {
d372 1
a372 1
    if {$w == $tkPriv(buttonWindow)} {
d389 1
a389 1
    if {[$w cget -state] != "disabled"} {
d391 1
a391 1
	$w config -state active
d405 2
a406 2
    if {$w == $tkPriv(buttonWindow)} {
	$w config -state normal
d408 2
a409 2
	if {($w == $tkPriv(window))
		&& ([$w cget -state] != "disabled")} {
d429 1
a429 1
    if {[$w cget -state] != "disabled"} {
d451 1
a451 1
    if {[$w cget -state] != "disabled"} {
d455 1
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d7 1
a7 1
# RCS: @@(#) $Id: button.tcl,v 1.7.6.1 2000/05/04 21:26:25 spolk Exp $
d20 1
a20 1
if {[string match "macintosh" $tcl_platform(platform)]} {
d40 10
a49 1
if {[string match "windows" $tcl_platform(platform)]} {
d79 1
a79 1
if {[string match "unix" $tcl_platform(platform)]} {
d138 1
a138 1
if {[string match "windows" $tcl_platform(platform)]} {
d154 4
a157 3
    if {[string compare [$w cget -state] "disabled"] \
	    && [string equal $tkPriv(buttonWindow) $w]} {
	$w configure -state active -relief sunken
d174 2
a175 2
    if {[string compare [$w cget -state] "disabled"]} {
	$w configure -state normal
d177 1
a177 1
    if {[string equal $tkPriv(buttonWindow) $w]} {
d194 4
a197 3
    if {[string compare [$w cget -state] "disabled"] \
	    && [string equal $tkPriv(buttonWindow) $w]} {
	$w configure -state active
d213 2
a214 2
    set tkPriv(relief) [$w cget -relief]
    if {[string compare [$w cget -state] "disabled"]} {
d216 1
a216 1
	$w configure -relief sunken -state active
d231 2
a232 2
    set tkPriv(relief) [$w cget -relief]
    if {[string compare [$w cget -state] "disabled"]} {
d234 1
a234 1
	$w configure -state active
d248 1
a248 1
    if {[string equal $tkPriv(buttonWindow) $w]} {
d250 3
a252 4
	$w configure -relief $tkPriv(relief)
	if {[string equal $tkPriv(window) $w]
              && [string compare [$w cget -state] "disabled"]} {
	    $w configure -state normal
d260 1
a260 1
if {[string match "unix" $tcl_platform(platform)]} {
d276 3
a278 3
    if {[string compare [$w cget -state] "disabled"]} {
	$w configure -state active
	if {[string equal $tkPriv(buttonWindow) $w]} {
d297 2
a298 2
    if {[string compare [$w cget -state] "disabled"]} {
	$w configure -state normal
d300 1
a300 1
    if {[string equal $tkPriv(buttonWindow) $w]} {
d317 2
a318 2
    set tkPriv(relief) [$w cget -relief]
    if {[string compare [$w cget -state] "disabled"]} {
d320 1
a320 1
	$w configure -relief sunken
d334 1
a334 1
    if {[string equal $w $tkPriv(buttonWindow)]} {
d336 3
a338 3
	$w configure -relief $tkPriv(relief)
	if {[string equal $w $tkPriv(window)] \
		&& [string compare [$w cget -state] "disabled"]} {
d346 1
a346 1
if {[string match "macintosh" $tcl_platform(platform)]} {
d362 2
a363 2
    if {[string compare [$w cget -state] "disabled"]} {
      if {[string equal $w $tkPriv(buttonWindow)]} {
d382 1
a382 1
    if {[string equal $w $tkPriv(buttonWindow)]} {
d399 1
a399 1
    if {[string compare [$w cget -state] "disabled"]} {
d401 1
a401 1
	$w configure -state active
d415 2
a416 2
    if {[string equal $w $tkPriv(buttonWindow)]} {
	$w configure -state normal
d418 2
a419 2
	if {[string equal $w $tkPriv(window)]
              && [string compare [$w cget -state] "disabled"]} {
d439 1
a439 1
    if {[string compare [$w cget -state] "disabled"]} {
d461 1
a461 1
    if {[string compare [$w cget -state] "disabled"]} {
a464 1

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d7 1
a7 1
# RCS: @@(#) $Id: button.tcl,v 1.17 2002/09/04 02:05:52 hobbs Exp $
a10 1
# Copyright (c) 2002 ActiveState Corporation.
d20 1
a20 2
if {[string equal [tk windowingsystem] "classic"]
	|| [string equal [tk windowingsystem] "aqua"]} {
d22 1
a22 1
	tk::ButtonEnter %W
d25 1
a25 1
	tk::ButtonDown %W
d28 1
a28 1
	tk::ButtonUp %W
d31 1
a31 1
	tk::ButtonEnter %W
d34 1
a34 1
	tk::ButtonDown %W
d37 1
a37 1
	tk::ButtonUp %W
d40 1
a40 1
if {[string equal "windows" $tcl_platform(platform)]} {
d42 1
a42 1
	tk::CheckRadioInvoke %W select
d45 1
a45 1
	tk::CheckRadioInvoke %W select
d48 1
a48 1
	tk::CheckRadioInvoke %W deselect
d51 1
a51 1
	tk::CheckRadioDown %W
d54 1
a54 1
	tk::ButtonUp %W
d57 1
a57 1
	tk::CheckRadioEnter %W
d61 1
a61 1
	tk::CheckRadioDown %W
d64 1
a64 1
	tk::ButtonUp %W
d67 1
a67 1
	tk::CheckRadioEnter %W
d70 1
a70 1
if {[string equal "x11" [tk windowingsystem]]} {
d73 1
a73 1
	    tk::CheckRadioInvoke %W
d78 1
a78 1
	    tk::CheckRadioInvoke %W
d82 1
a82 1
	tk::CheckRadioInvoke %W
d85 1
a85 1
	tk::CheckRadioInvoke %W
d88 1
a88 1
	tk::ButtonEnter %W
d91 1
a91 1
	tk::ButtonEnter %W
d96 1
a96 1
    tk::ButtonInvoke %W
d99 1
a99 1
    tk::CheckRadioInvoke %W
d102 1
a102 1
    tk::CheckRadioInvoke %W
d107 1
a107 1
    tk::ButtonEnter %W
d110 1
a110 1
    tk::ButtonLeave %W
d113 1
a113 1
    tk::ButtonDown %W
d116 1
a116 1
    tk::ButtonUp %W
d121 1
a121 1
    tk::ButtonLeave %W
d126 1
a126 1
    tk::ButtonLeave %W
d129 1
a129 1
if {[string equal "windows" $tcl_platform(platform)]} {
d135 1
a135 1
# ::tk::ButtonEnter --
d143 5
a147 15
proc ::tk::ButtonEnter w {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {

	# If the mouse button is down, set the relief to sunken on entry.
	# Overwise, if there's an -overrelief value, set the relief to that.

	set Priv($w,relief) [$w cget -relief]
	if {$Priv(buttonWindow) eq $w} {
	    $w configure -relief sunken -state active
	    set Priv($w,prelief) sunken
	} elseif {[set over [$w cget -overrelief]] ne ""} {
	    $w configure -relief $over
	    set Priv($w,prelief) $over
	}
d149 1
a149 1
    set Priv(window) $w
d152 1
a152 1
# ::tk::ButtonLeave --
d154 4
a157 2
# button widget.  It changes the state of the button back to inactive.
# Restore any modified relief too.
d162 3
a164 3
proc ::tk::ButtonLeave w {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {
d167 5
d173 8
a180 2
    # Restore the original button relief if it was changed by Tk.
    # That is signaled by the existence of Priv($w,prelief).
d182 5
a186 6
    if {[info exists Priv($w,relief)]} {
	if {[info exists Priv($w,prelief)] && \
		$Priv($w,prelief) eq [$w cget -relief]} {
	    $w configure -relief $Priv($w,relief)
	}
	unset -nocomplain Priv($w,relief) Priv($w,prelief)
d188 1
a188 2

    set Priv(window) ""
d191 1
a191 1
# ::tk::ButtonDown --
d200 5
a204 13
proc ::tk::ButtonDown w {
    variable ::tk::Priv

    # Only save the button's relief if it does not yet exist.  If there
    # is an overrelief setting, Priv($w,relief) will already have been set,
    # and the current value of the -relief option will be incorrect.

    if {![info exists Priv($w,relief)]} {
	set Priv($w,relief) [$w cget -relief]
    }

    if {[$w cget -state] ne "disabled"} {
	set Priv(buttonWindow) $w
a205 9
	set Priv($w,prelief) sunken

	# If this button has a repeatdelay set up, get it going with an after
	after cancel $Priv(afterId)
	set delay [$w cget -repeatdelay]
	set Priv(repeated) 0
	if {$delay > 0} {
	    set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
	}
d209 5
a213 4
# ::tk::ButtonUp --
# The procedure below is invoked when the mouse button is released
# in a button widget.  It restores the button's relief and invokes
# the command as long as the mouse hasn't left the button.
d218 6
a223 27
proc ::tk::ButtonUp w {
    variable ::tk::Priv
    if {$Priv(buttonWindow) eq $w} {
	set Priv(buttonWindow) ""

	# Restore the button's relief if it was cached.

	if {[info exists Priv($w,relief)]} {
	    if {[info exists Priv($w,prelief)] && \
		    $Priv($w,prelief) eq [$w cget -relief]} {
		$w configure -relief $Priv($w,relief)
	    }
	    unset -nocomplain Priv($w,relief) Priv($w,prelief)
	}

	# Clean up the after event from the auto-repeater
	after cancel $Priv(afterId)

	if {$Priv(window) eq $w && [$w cget -state] ne "disabled"} {
	    $w configure -state normal

	    # Only invoke the command if it wasn't already invoked by the
	    # auto-repeater functionality
	    if { $Priv(repeated) == 0 } {
		uplevel #0 [list $w invoke]
	    }
	}
d227 4
a230 5
# ::tk::CheckRadioEnter --
# The procedure below is invoked when the mouse pointer enters a
# checkbutton or radiobutton widget.  It records the button we're in
# and changes the state of the button to active unless the button is
# disabled.
d235 9
a243 10
proc ::tk::CheckRadioEnter w {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {
	if {$Priv(buttonWindow) eq $w} {
	    $w configure -state active
	}
	if {[set over [$w cget -overrelief]] ne ""} {
	    set Priv($w,relief)  [$w cget -relief]
	    set Priv($w,prelief) $over
	    $w configure -relief $over
a245 1
    set Priv(window) $w
a247 19
# ::tk::CheckRadioDown --
# The procedure below is invoked when the mouse button is pressed in
# a button widget.  It records the fact that the mouse is in the button,
# saves the button's relief so it can be restored later, and changes
# the relief to sunken.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::CheckRadioDown w {
    variable ::tk::Priv
    if {![info exists Priv($w,relief)]} {
	set Priv($w,relief) [$w cget -relief]
    }
    if {[$w cget -state] ne "disabled"} {
	set Priv(buttonWindow) $w
	set Priv(repeated) 0
	$w configure -state active
    }
d250 1
a250 3
}

if {[string equal "x11" [tk windowingsystem]]} {
d256 1
a256 1
# ::tk::ButtonEnter --
d264 3
a266 4
proc ::tk::ButtonEnter {w} {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {
	# On unix the state is active just with mouse-over
d268 2
a269 11

	# If the mouse button is down, set the relief to sunken on entry.
	# Overwise, if there's an -overrelief value, set the relief to that.

	set Priv($w,relief) [$w cget -relief]
	if {$Priv(buttonWindow) eq $w} {
	    $w configure -relief sunken
	    set Priv($w,prelief) sunken
	} elseif {[set over [$w cget -overrelief]] ne ""} {
	    $w configure -relief $over
	    set Priv($w,prelief) $over
d272 1
a272 1
    set Priv(window) $w
d275 1
a275 1
# ::tk::ButtonLeave --
d277 4
a280 2
# button widget.  It changes the state of the button back to inactive.
# Restore any modified relief too.
d285 3
a287 3
proc ::tk::ButtonLeave w {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {
d290 2
a291 10

    # Restore the original button relief if it was changed by Tk.
    # That is signaled by the existence of Priv($w,prelief).

    if {[info exists Priv($w,relief)]} {
	if {[info exists Priv($w,prelief)] && \
		$Priv($w,prelief) eq [$w cget -relief]} {
	    $w configure -relief $Priv($w,relief)
	}
	unset -nocomplain Priv($w,relief) Priv($w,prelief)
d293 1
a293 2

    set Priv(window) ""
d296 1
a296 1
# ::tk::ButtonDown --
d305 5
a309 13
proc ::tk::ButtonDown w {
    variable ::tk::Priv

    # Only save the button's relief if it does not yet exist.  If there
    # is an overrelief setting, Priv($w,relief) will already have been set,
    # and the current value of the -relief option will be incorrect.

    if {![info exists Priv($w,relief)]} {
	set Priv($w,relief) [$w cget -relief]
    }

    if {[$w cget -state] ne "disabled"} {
	set Priv(buttonWindow) $w
a310 9
	set Priv($w,prelief) sunken

	# If this button has a repeatdelay set up, get it going with an after
	after cancel $Priv(afterId)
	set delay [$w cget -repeatdelay]
	set Priv(repeated) 0
	if {$delay > 0} {
	    set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
	}
d314 1
a314 1
# ::tk::ButtonUp --
d322 8
a329 24
proc ::tk::ButtonUp w {
    variable ::tk::Priv
    if {[string equal $w $Priv(buttonWindow)]} {
	set Priv(buttonWindow) ""

	# Restore the button's relief if it was cached.

	if {[info exists Priv($w,relief)]} {
	    if {[info exists Priv($w,prelief)] && \
		    $Priv($w,prelief) eq [$w cget -relief]} {
		$w configure -relief $Priv($w,relief)
	    }
	    unset -nocomplain Priv($w,relief) Priv($w,prelief)
	}

	# Clean up the after event from the auto-repeater
	after cancel $Priv(afterId)

	if {$Priv(window) eq $w && [$w cget -state] ne "disabled"} {
	    # Only invoke the command if it wasn't already invoked by the
	    # auto-repeater functionality
	    if { $Priv(repeated) == 0 } {
		uplevel #0 [list $w invoke]
	    }
d336 1
a336 2
if {[string equal [tk windowingsystem] "classic"]
	|| [string equal [tk windowingsystem] "aqua"]} {
d342 1
a342 1
# ::tk::ButtonEnter --
d350 4
a353 7
proc ::tk::ButtonEnter {w} {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {

	# If there's an -overrelief value, set the relief to that.

	if {$Priv(buttonWindow) eq $w} {
a354 4
	} elseif {[set over [$w cget -overrelief]] ne ""} {
	    set Priv($w,relief)  [$w cget -relief]
	    set Priv($w,prelief) $over
	    $w configure -relief $over
d357 1
a357 1
    set Priv(window) $w
d360 1
a360 1
# ::tk::ButtonLeave --
d364 1
a364 1
# pressed (Priv(buttonWindow) == $w), restore the relief of the
d370 3
a372 3
proc ::tk::ButtonLeave w {
    variable ::tk::Priv
    if {$w eq $Priv(buttonWindow)} {
d375 1
a375 13

    # Restore the original button relief if it was changed by Tk.
    # That is signaled by the existence of Priv($w,prelief).

    if {[info exists Priv($w,relief)]} {
	if {[info exists Priv($w,prelief)] && \
		$Priv($w,prelief) eq [$w cget -relief]} {
	    $w configure -relief $Priv($w,relief)
	}
	unset -nocomplain Priv($w,relief) Priv($w,prelief)
    }

    set Priv(window) ""
d378 1
a378 1
# ::tk::ButtonDown --
d387 4
a390 5
proc ::tk::ButtonDown w {
    variable ::tk::Priv

    if {[$w cget -state] ne "disabled"} {
	set Priv(buttonWindow) $w
a391 9

	# If this button has a repeatdelay set up, get it going with an after
	after cancel $Priv(afterId)
	set Priv(repeated) 0
	if { ![catch {$w cget -repeatdelay} delay] } {
	    if {$delay > 0} {
		set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
	    }
	}
d395 1
a395 1
# ::tk::ButtonUp --
d403 3
a405 4
proc ::tk::ButtonUp w {
    variable ::tk::Priv
    if {$Priv(buttonWindow) eq $w} {
	set Priv(buttonWindow) ""
d407 4
a410 20

	# Restore the button's relief if it was cached.

	if {[info exists Priv($w,relief)]} {
	    if {[info exists Priv($w,prelief)] && \
		    $Priv($w,prelief) eq [$w cget -relief]} {
		$w configure -relief $Priv($w,relief)
	    }
	    unset -nocomplain Priv($w,relief) Priv($w,prelief)
	}

	# Clean up the after event from the auto-repeater
	after cancel $Priv(afterId)

	if {$Priv(window) eq $w && [$w cget -state] ne "disabled"} {
	    # Only invoke the command if it wasn't already invoked by the
	    # auto-repeater functionality
	    if { $Priv(repeated) == 0 } {
		uplevel #0 [list $w invoke]
	    }
d421 1
a421 1
# ::tk::ButtonInvoke --
d428 2
a429 2
proc ::tk::ButtonInvoke w {
    if {[$w cget -state] ne "disabled"} {
d440 1
a440 27
# ::tk::ButtonAutoInvoke --
#
#	Invoke an auto-repeating button, and set it up to continue to repeat.
#
# Arguments:
#	w	button to invoke.
#
# Results:
#	None.
#
# Side effects:
#	May create an after event to call ::tk::ButtonAutoInvoke.

proc ::tk::ButtonAutoInvoke {w} {
    variable ::tk::Priv
    after cancel $Priv(afterId)
    set delay [$w cget -repeatinterval]
    if {$Priv(window) eq $w} {
	incr Priv(repeated)
	uplevel #0 [list $w invoke]
    }
    if {$delay > 0} {
	set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
    }
}

# ::tk::CheckRadioInvoke --
d450 2
a451 2
proc ::tk::CheckRadioInvoke {w {cmd invoke}} {
    if {[$w cget -state] ne "disabled"} {
d455 2
@


