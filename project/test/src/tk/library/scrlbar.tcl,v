head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.46;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.14;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.26;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.52;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.33;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.50;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# scrlbar.tcl --
#
# This file defines the default bindings for Tk scrollbar widgets.
# It also provides procedures that help in implementing the bindings.
#
# RCS: @@(#) $Id: scrlbar.tcl,v 1.10 2002/08/31 06:12:28 das Exp $
#
# Copyright (c) 1994 The Regents of the University of California.
# Copyright (c) 1994-1996 Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

#-------------------------------------------------------------------------
# The code below creates the default class bindings for scrollbars.
#-------------------------------------------------------------------------

# Standard Motif bindings:
if {[string equal [tk windowingsystem] "x11"]} {

bind Scrollbar <Enter> {
    if {$tk_strictMotif} {
	set tk::Priv(activeBg) [%W cget -activebackground]
	%W config -activebackground [%W cget -background]
    }
    %W activate [%W identify %x %y]
}
bind Scrollbar <Motion> {
    %W activate [%W identify %x %y]
}

# The "info exists" command in the following binding handles the
# situation where a Leave event occurs for a scrollbar without the Enter
# event.  This seems to happen on some systems (such as Solaris 2.4) for
# unknown reasons.

bind Scrollbar <Leave> {
    if {$tk_strictMotif && [info exists tk::Priv(activeBg)]} {
	%W config -activebackground $tk::Priv(activeBg)
    }
    %W activate {}
}
bind Scrollbar <1> {
    tk::ScrollButtonDown %W %x %y
}
bind Scrollbar <B1-Motion> {
    tk::ScrollDrag %W %x %y
}
bind Scrollbar <B1-B2-Motion> {
    tk::ScrollDrag %W %x %y
}
bind Scrollbar <ButtonRelease-1> {
    tk::ScrollButtonUp %W %x %y
}
bind Scrollbar <B1-Leave> {
    # Prevents <Leave> binding from being invoked.
}
bind Scrollbar <B1-Enter> {
    # Prevents <Enter> binding from being invoked.
}
bind Scrollbar <2> {
    tk::ScrollButton2Down %W %x %y
}
bind Scrollbar <B1-2> {
    # Do nothing, since button 1 is already down.
}
bind Scrollbar <B2-1> {
    # Do nothing, since button 2 is already down.
}
bind Scrollbar <B2-Motion> {
    tk::ScrollDrag %W %x %y
}
bind Scrollbar <ButtonRelease-2> {
    tk::ScrollButtonUp %W %x %y
}
bind Scrollbar <B1-ButtonRelease-2> {
    # Do nothing:  B1 release will handle it.
}
bind Scrollbar <B2-ButtonRelease-1> {
    # Do nothing:  B2 release will handle it.
}
bind Scrollbar <B2-Leave> {
    # Prevents <Leave> binding from being invoked.
}
bind Scrollbar <B2-Enter> {
    # Prevents <Enter> binding from being invoked.
}
bind Scrollbar <Control-1> {
    tk::ScrollTopBottom %W %x %y
}
bind Scrollbar <Control-2> {
    tk::ScrollTopBottom %W %x %y
}

bind Scrollbar <Up> {
    tk::ScrollByUnits %W v -1
}
bind Scrollbar <Down> {
    tk::ScrollByUnits %W v 1
}
bind Scrollbar <Control-Up> {
    tk::ScrollByPages %W v -1
}
bind Scrollbar <Control-Down> {
    tk::ScrollByPages %W v 1
}
bind Scrollbar <Left> {
    tk::ScrollByUnits %W h -1
}
bind Scrollbar <Right> {
    tk::ScrollByUnits %W h 1
}
bind Scrollbar <Control-Left> {
    tk::ScrollByPages %W h -1
}
bind Scrollbar <Control-Right> {
    tk::ScrollByPages %W h 1
}
bind Scrollbar <Prior> {
    tk::ScrollByPages %W hv -1
}
bind Scrollbar <Next> {
    tk::ScrollByPages %W hv 1
}
bind Scrollbar <Home> {
    tk::ScrollToPos %W 0
}
bind Scrollbar <End> {
    tk::ScrollToPos %W 1
}
}
# tk::ScrollButtonDown --
# This procedure is invoked when a button is pressed in a scrollbar.
# It changes the way the scrollbar is displayed and takes actions
# depending on where the mouse is.
#
# Arguments:
# w -		The scrollbar widget.
# x, y -	Mouse coordinates.

proc tk::ScrollButtonDown {w x y} {
    variable ::tk::Priv
    set Priv(relief) [$w cget -activerelief]
    $w configure -activerelief sunken
    set element [$w identify $x $y]
    if {[string equal $element "slider"]} {
	ScrollStartDrag $w $x $y
    } else {
	ScrollSelect $w $element initial
    }
}

# ::tk::ScrollButtonUp --
# This procedure is invoked when a button is released in a scrollbar.
# It cancels scans and auto-repeats that were in progress, and restores
# the way the active element is displayed.
#
# Arguments:
# w -		The scrollbar widget.
# x, y -	Mouse coordinates.

proc ::tk::ScrollButtonUp {w x y} {
    variable ::tk::Priv
    tk::CancelRepeat
    if {[info exists Priv(relief)]} {
	# Avoid error due to spurious release events
	$w configure -activerelief $Priv(relief)
	ScrollEndDrag $w $x $y
	$w activate [$w identify $x $y]
    }
}

# ::tk::ScrollSelect --
# This procedure is invoked when a button is pressed over the scrollbar.
# It invokes one of several scrolling actions depending on where in
# the scrollbar the button was pressed.
#
# Arguments:
# w -		The scrollbar widget.
# element -	The element of the scrollbar that was selected, such
#		as "arrow1" or "trough2".  Shouldn't be "slider".
# repeat -	Whether and how to auto-repeat the action:  "noRepeat"
#		means don't auto-repeat, "initial" means this is the
#		first action in an auto-repeat sequence, and "again"
#		means this is the second repetition or later.

proc ::tk::ScrollSelect {w element repeat} {
    variable ::tk::Priv
    if {![winfo exists $w]} return
    switch -- $element {
	"arrow1"	{ScrollByUnits $w hv -1}
	"trough1"	{ScrollByPages $w hv -1}
	"trough2"	{ScrollByPages $w hv 1}
	"arrow2"	{ScrollByUnits $w hv 1}
	default		{return}
    }
    if {[string equal $repeat "again"]} {
	set Priv(afterId) [after [$w cget -repeatinterval] \
		[list tk::ScrollSelect $w $element again]]
    } elseif {[string equal $repeat "initial"]} {
	set delay [$w cget -repeatdelay]
	if {$delay > 0} {
	    set Priv(afterId) [after $delay \
		    [list tk::ScrollSelect $w $element again]]
	}
    }
}

# ::tk::ScrollStartDrag --
# This procedure is called to initiate a drag of the slider.  It just
# remembers the starting position of the mouse and slider.
#
# Arguments:
# w -		The scrollbar widget.
# x, y -	The mouse position at the start of the drag operation.

proc ::tk::ScrollStartDrag {w x y} {
    variable ::tk::Priv

    if {[string equal [$w cget -command] ""]} {
	return
    }
    set Priv(pressX) $x
    set Priv(pressY) $y
    set Priv(initValues) [$w get]
    set iv0 [lindex $Priv(initValues) 0]
    if {[llength $Priv(initValues)] == 2} {
	set Priv(initPos) $iv0
    } elseif {$iv0 == 0} {
	set Priv(initPos) 0.0
    } else {
	set Priv(initPos) [expr {(double([lindex $Priv(initValues) 2])) \
		/ [lindex $Priv(initValues) 0]}]
    }
}

# ::tk::ScrollDrag --
# This procedure is called for each mouse motion even when the slider
# is being dragged.  It notifies the associated widget if we're not
# jump scrolling, and it just updates the scrollbar if we are jump
# scrolling.
#
# Arguments:
# w -		The scrollbar widget.
# x, y -	The current mouse position.

proc ::tk::ScrollDrag {w x y} {
    variable ::tk::Priv

    if {[string equal $Priv(initPos) ""]} {
	return
    }
    set delta [$w delta [expr {$x - $Priv(pressX)}] [expr {$y - $Priv(pressY)}]]
    if {[$w cget -jump]} {
	if {[llength $Priv(initValues)] == 2} {
	    $w set [expr {[lindex $Priv(initValues) 0] + $delta}] \
		    [expr {[lindex $Priv(initValues) 1] + $delta}]
	} else {
	    set delta [expr {round($delta * [lindex $Priv(initValues) 0])}]
	    eval [list $w] set [lreplace $Priv(initValues) 2 3 \
		    [expr {[lindex $Priv(initValues) 2] + $delta}] \
		    [expr {[lindex $Priv(initValues) 3] + $delta}]]
	}
    } else {
	ScrollToPos $w [expr {$Priv(initPos) + $delta}]
    }
}

# ::tk::ScrollEndDrag --
# This procedure is called to end an interactive drag of the slider.
# It scrolls the window if we're in jump mode, otherwise it does nothing.
#
# Arguments:
# w -		The scrollbar widget.
# x, y -	The mouse position at the end of the drag operation.

proc ::tk::ScrollEndDrag {w x y} {
    variable ::tk::Priv

    if {[string equal $Priv(initPos) ""]} {
	return
    }
    if {[$w cget -jump]} {
	set delta [$w delta [expr {$x - $Priv(pressX)}] \
		[expr {$y - $Priv(pressY)}]]
	ScrollToPos $w [expr {$Priv(initPos) + $delta}]
    }
    set Priv(initPos) ""
}

# ::tk::ScrollByUnits --
# This procedure tells the scrollbar's associated widget to scroll up
# or down by a given number of units.  It notifies the associated widget
# in different ways for old and new command syntaxes.
#
# Arguments:
# w -		The scrollbar widget.
# orient -	Which kinds of scrollbars this applies to:  "h" for
#		horizontal, "v" for vertical, "hv" for both.
# amount -	How many units to scroll:  typically 1 or -1.

proc ::tk::ScrollByUnits {w orient amount} {
    set cmd [$w cget -command]
    if {[string equal $cmd ""] || ([string first \
	    [string index [$w cget -orient] 0] $orient] < 0)} {
	return
    }
    set info [$w get]
    if {[llength $info] == 2} {
	uplevel #0 $cmd scroll $amount units
    } else {
	uplevel #0 $cmd [expr {[lindex $info 2] + $amount}]
    }
}

# ::tk::ScrollByPages --
# This procedure tells the scrollbar's associated widget to scroll up
# or down by a given number of screenfuls.  It notifies the associated
# widget in different ways for old and new command syntaxes.
#
# Arguments:
# w -		The scrollbar widget.
# orient -	Which kinds of scrollbars this applies to:  "h" for
#		horizontal, "v" for vertical, "hv" for both.
# amount -	How many screens to scroll:  typically 1 or -1.

proc ::tk::ScrollByPages {w orient amount} {
    set cmd [$w cget -command]
    if {[string equal $cmd ""] || ([string first \
	    [string index [$w cget -orient] 0] $orient] < 0)} {
	return
    }
    set info [$w get]
    if {[llength $info] == 2} {
	uplevel #0 $cmd scroll $amount pages
    } else {
	uplevel #0 $cmd [expr {[lindex $info 2] + $amount*([lindex $info 1] - 1)}]
    }
}

# ::tk::ScrollToPos --
# This procedure tells the scrollbar's associated widget to scroll to
# a particular location, given by a fraction between 0 and 1.  It notifies
# the associated widget in different ways for old and new command syntaxes.
#
# Arguments:
# w -		The scrollbar widget.
# pos -		A fraction between 0 and 1 indicating a desired position
#		in the document.

proc ::tk::ScrollToPos {w pos} {
    set cmd [$w cget -command]
    if {[string equal $cmd ""]} {
	return
    }
    set info [$w get]
    if {[llength $info] == 2} {
	uplevel #0 $cmd moveto $pos
    } else {
	uplevel #0 $cmd [expr {round([lindex $info 0]*$pos)}]
    }
}

# ::tk::ScrollTopBottom
# Scroll to the top or bottom of the document, depending on the mouse
# position.
#
# Arguments:
# w -		The scrollbar widget.
# x, y -	Mouse coordinates within the widget.

proc ::tk::ScrollTopBottom {w x y} {
    variable ::tk::Priv
    set element [$w identify $x $y]
    if {[string match *1 $element]} {
	ScrollToPos $w 0
    } elseif {[string match *2 $element]} {
	ScrollToPos $w 1
    }

    # Set Priv(relief), since it's needed by tk::ScrollButtonUp.

    set Priv(relief) [$w cget -activerelief]
}

# ::tk::ScrollButton2Down
# This procedure is invoked when button 2 is pressed over a scrollbar.
# If the button is over the trough or slider, it sets the scrollbar to
# the mouse position and starts a slider drag.  Otherwise it just
# behaves the same as button 1.
#
# Arguments:
# w -		The scrollbar widget.
# x, y -	Mouse coordinates within the widget.

proc ::tk::ScrollButton2Down {w x y} {
    variable ::tk::Priv
    set element [$w identify $x $y]
    if {[string match {arrow[12]} $element]} {
	ScrollButtonDown $w $x $y
	return
    }
    ScrollToPos $w [$w fraction $x $y]
    set Priv(relief) [$w cget -activerelief]

    # Need the "update idletasks" below so that the widget calls us
    # back to reset the actual scrollbar position before we start the
    # slider drag.

    update idletasks
    $w configure -activerelief sunken
    $w activate slider
    ScrollStartDrag $w $x $y
}
@


1.4
log
@touched all sources to ease next import
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: scrlbar.tcl,v 1.7.6.1 2000/05/04 21:26:25 spolk Exp $
d20 1
a20 2
if {[string compare $tcl_platform(platform) "windows"] && \
	[string compare $tcl_platform(platform) "macintosh"]} {
d24 1
a24 1
	set tkPriv(activeBg) [%W cget -activebackground]
d39 2
a40 2
    if {$tk_strictMotif && [info exists tkPriv(activeBg)]} {
	%W config -activebackground $tkPriv(activeBg)
d45 1
a45 1
    tkScrollButtonDown %W %x %y
d48 1
a48 1
    tkScrollDrag %W %x %y
d51 1
a51 1
    tkScrollDrag %W %x %y
d54 1
a54 1
    tkScrollButtonUp %W %x %y
d63 1
a63 1
    tkScrollButton2Down %W %x %y
d72 1
a72 1
    tkScrollDrag %W %x %y
d75 1
a75 1
    tkScrollButtonUp %W %x %y
d90 1
a90 1
    tkScrollTopBottom %W %x %y
d93 1
a93 1
    tkScrollTopBottom %W %x %y
d97 1
a97 1
    tkScrollByUnits %W v -1
d100 1
a100 1
    tkScrollByUnits %W v 1
d103 1
a103 1
    tkScrollByPages %W v -1
d106 1
a106 1
    tkScrollByPages %W v 1
d109 1
a109 1
    tkScrollByUnits %W h -1
d112 1
a112 1
    tkScrollByUnits %W h 1
d115 1
a115 1
    tkScrollByPages %W h -1
d118 1
a118 1
    tkScrollByPages %W h 1
d121 1
a121 1
    tkScrollByPages %W hv -1
d124 1
a124 1
    tkScrollByPages %W hv 1
d127 1
a127 1
    tkScrollToPos %W 0
d130 1
a130 1
    tkScrollToPos %W 1
d133 1
a133 1
# tkScrollButtonDown --
d142 3
a144 3
proc tkScrollButtonDown {w x y} {
    global tkPriv
    set tkPriv(relief) [$w cget -activerelief]
d148 1
a148 1
	tkScrollStartDrag $w $x $y
d150 1
a150 1
	tkScrollSelect $w $element initial
d154 1
a154 1
# tkScrollButtonUp --
d163 4
a166 4
proc tkScrollButtonUp {w x y} {
    global tkPriv
    tkCancelRepeat
    if {[info exists tkPriv(relief)]} {
d168 2
a169 2
	$w configure -activerelief $tkPriv(relief)
	tkScrollEndDrag $w $x $y
d174 1
a174 1
# tkScrollSelect --
d188 2
a189 2
proc tkScrollSelect {w element repeat} {
    global tkPriv
d192 4
a195 4
	"arrow1"	{tkScrollByUnits $w hv -1}
	"trough1"	{tkScrollByPages $w hv -1}
	"trough2"	{tkScrollByPages $w hv 1}
	"arrow2"	{tkScrollByUnits $w hv 1}
d199 2
a200 2
	set tkPriv(afterId) [after [$w cget -repeatinterval] \
		[list tkScrollSelect $w $element again]]
d204 2
a205 2
	    set tkPriv(afterId) [after $delay \
		    [list tkScrollSelect $w $element again]]
d210 1
a210 1
# tkScrollStartDrag --
d218 2
a219 2
proc tkScrollStartDrag {w x y} {
    global tkPriv
d224 6
a229 6
    set tkPriv(pressX) $x
    set tkPriv(pressY) $y
    set tkPriv(initValues) [$w get]
    set iv0 [lindex $tkPriv(initValues) 0]
    if {[llength $tkPriv(initValues)] == 2} {
	set tkPriv(initPos) $iv0
d231 1
a231 1
	set tkPriv(initPos) 0.0
d233 2
a234 2
	set tkPriv(initPos) [expr {(double([lindex $tkPriv(initValues) 2])) \
		/ [lindex $tkPriv(initValues) 0]}]
d238 1
a238 1
# tkScrollDrag --
d248 2
a249 2
proc tkScrollDrag {w x y} {
    global tkPriv
d251 1
a251 1
    if {[string equal $tkPriv(initPos) ""]} {
d254 1
a254 1
    set delta [$w delta [expr {$x - $tkPriv(pressX)}] [expr {$y - $tkPriv(pressY)}]]
d256 3
a258 3
	if {[llength $tkPriv(initValues)] == 2} {
	    $w set [expr {[lindex $tkPriv(initValues) 0] + $delta}] \
		    [expr {[lindex $tkPriv(initValues) 1] + $delta}]
d260 4
a263 4
	    set delta [expr {round($delta * [lindex $tkPriv(initValues) 0])}]
	    eval [list $w] set [lreplace $tkPriv(initValues) 2 3 \
		    [expr {[lindex $tkPriv(initValues) 2] + $delta}] \
		    [expr {[lindex $tkPriv(initValues) 3] + $delta}]]
d266 1
a266 1
	tkScrollToPos $w [expr {$tkPriv(initPos) + $delta}]
d270 1
a270 1
# tkScrollEndDrag --
d278 2
a279 2
proc tkScrollEndDrag {w x y} {
    global tkPriv
d281 1
a281 1
    if {[string equal $tkPriv(initPos) ""]} {
d285 3
a287 3
	set delta [$w delta [expr {$x - $tkPriv(pressX)}] \
		[expr {$y - $tkPriv(pressY)}]]
	tkScrollToPos $w [expr {$tkPriv(initPos) + $delta}]
d289 1
a289 1
    set tkPriv(initPos) ""
d292 1
a292 1
# tkScrollByUnits --
d303 1
a303 1
proc tkScrollByUnits {w orient amount} {
d317 1
a317 1
# tkScrollByPages --
d328 1
a328 1
proc tkScrollByPages {w orient amount} {
d342 1
a342 1
# tkScrollToPos --
d352 1
a352 1
proc tkScrollToPos {w pos} {
d365 1
a365 1
# tkScrollTopBottom
d373 2
a374 2
proc tkScrollTopBottom {w x y} {
    global tkPriv
d377 1
a377 1
	tkScrollToPos $w 0
d379 1
a379 1
	tkScrollToPos $w 1
d382 1
a382 1
    # Set tkPriv(relief), since it's needed by tkScrollButtonUp.
d384 1
a384 1
    set tkPriv(relief) [$w cget -activerelief]
d387 1
a387 1
# tkScrollButton2Down
d397 2
a398 2
proc tkScrollButton2Down {w x y} {
    global tkPriv
d401 1
a401 1
	tkScrollButtonDown $w $x $y
d404 2
a405 2
    tkScrollToPos $w [$w fraction $x $y]
    set tkPriv(relief) [$w cget -activerelief]
d414 1
a414 1
    tkScrollStartDrag $w $x $y
a415 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
# SCCS: @@(#) scrlbar.tcl 1.26 96/11/30 17:19:16
d20 3
a22 2
if {($tcl_platform(platform) != "windows") &&
    ($tcl_platform(platform) != "macintosh")} {
d148 1
a148 1
    if {$element == "slider"} {
d167 6
a172 3
    $w configure -activerelief $tkPriv(relief)
    tkScrollEndDrag $w $x $y
    $w activate [$w identify $x $y]
d192 6
a197 10
    if {$element == "arrow1"} {
	tkScrollByUnits $w hv -1
    } elseif {$element == "trough1"} {
	tkScrollByPages $w hv -1
    } elseif {$element == "trough2"} {
	tkScrollByPages $w hv 1
    } elseif {$element == "arrow2"} {
	tkScrollByUnits $w hv 1
    } else {
	return
d199 1
a199 1
    if {$repeat == "again"} {
d201 2
a202 2
		tkScrollSelect $w $element again]
    } elseif {$repeat == "initial"} {
d205 2
a206 1
	    set tkPriv(afterId) [after $delay tkScrollSelect $w $element again]
d222 1
a222 1
    if {[$w cget -command] == ""} {
d231 2
d234 2
a235 6
	if {$iv0 == 0} {
	    set tkPriv(initPos) 0.0
	} else {
	    set tkPriv(initPos) [expr {(double([lindex $tkPriv(initValues) 2])) \
		    / [lindex $tkPriv(initValues) 0]}]
	}
d252 1
a252 1
    if {$tkPriv(initPos) == ""} {
d262 1
a262 1
	    eval $w set [lreplace $tkPriv(initValues) 2 3 \
d282 1
a282 1
    if {$tkPriv(initPos) == ""} {
d306 1
a306 1
    if {($cmd == "") || ([string first \
d314 1
a314 1
	uplevel #0 $cmd [expr [lindex $info 2] + $amount]
d331 1
a331 1
    if {($cmd == "") || ([string first \
d339 1
a339 1
	uplevel #0 $cmd [expr [lindex $info 2] + $amount*([lindex $info 1] - 1)]
d355 1
a355 1
    if {($cmd == "")} {
d362 1
a362 1
	uplevel #0 $cmd [expr round([lindex $info 0]*$pos)]
d401 1
a401 1
    if {($element == "arrow1") || ($element == "arrow2")} {
d417 1
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: scrlbar.tcl,v 1.7.6.1 2000/05/04 21:26:25 spolk Exp $
d20 2
a21 3
if {[string compare $tcl_platform(platform) "windows"] && \
	[string compare $tcl_platform(platform) "macintosh"]} {

d147 1
a147 1
    if {[string equal $element "slider"]} {
d166 3
a168 6
    if {[info exists tkPriv(relief)]} {
	# Avoid error due to spurious release events
	$w configure -activerelief $tkPriv(relief)
	tkScrollEndDrag $w $x $y
	$w activate [$w identify $x $y]
    }
d188 10
a197 6
    switch -- $element {
	"arrow1"	{tkScrollByUnits $w hv -1}
	"trough1"	{tkScrollByPages $w hv -1}
	"trough2"	{tkScrollByPages $w hv 1}
	"arrow2"	{tkScrollByUnits $w hv 1}
	default		{return}
d199 1
a199 1
    if {[string equal $repeat "again"]} {
d201 2
a202 2
		[list tkScrollSelect $w $element again]]
    } elseif {[string equal $repeat "initial"]} {
d205 1
a205 2
	    set tkPriv(afterId) [after $delay \
		    [list tkScrollSelect $w $element again]]
d221 1
a221 1
    if {[string equal [$w cget -command] ""]} {
a229 2
    } elseif {$iv0 == 0} {
	set tkPriv(initPos) 0.0
d231 6
a236 2
	set tkPriv(initPos) [expr {(double([lindex $tkPriv(initValues) 2])) \
		/ [lindex $tkPriv(initValues) 0]}]
d253 1
a253 1
    if {[string equal $tkPriv(initPos) ""]} {
d263 1
a263 1
	    eval [list $w] set [lreplace $tkPriv(initValues) 2 3 \
d283 1
a283 1
    if {[string equal $tkPriv(initPos) ""]} {
d307 1
a307 1
    if {[string equal $cmd ""] || ([string first \
d315 1
a315 1
	uplevel #0 $cmd [expr {[lindex $info 2] + $amount}]
d332 1
a332 1
    if {[string equal $cmd ""] || ([string first \
d340 1
a340 1
	uplevel #0 $cmd [expr {[lindex $info 2] + $amount*([lindex $info 1] - 1)}]
d356 1
a356 1
    if {[string equal $cmd ""]} {
d363 1
a363 1
	uplevel #0 $cmd [expr {round([lindex $info 0]*$pos)}]
d402 1
a402 1
    if {[string match {arrow[12]} $element]} {
a417 1

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: scrlbar.tcl,v 1.10 2002/08/31 06:12:28 das Exp $
d20 2
a21 1
if {[string equal [tk windowingsystem] "x11"]} {
d25 1
a25 1
	set tk::Priv(activeBg) [%W cget -activebackground]
d40 2
a41 2
    if {$tk_strictMotif && [info exists tk::Priv(activeBg)]} {
	%W config -activebackground $tk::Priv(activeBg)
d46 1
a46 1
    tk::ScrollButtonDown %W %x %y
d49 1
a49 1
    tk::ScrollDrag %W %x %y
d52 1
a52 1
    tk::ScrollDrag %W %x %y
d55 1
a55 1
    tk::ScrollButtonUp %W %x %y
d64 1
a64 1
    tk::ScrollButton2Down %W %x %y
d73 1
a73 1
    tk::ScrollDrag %W %x %y
d76 1
a76 1
    tk::ScrollButtonUp %W %x %y
d91 1
a91 1
    tk::ScrollTopBottom %W %x %y
d94 1
a94 1
    tk::ScrollTopBottom %W %x %y
d98 1
a98 1
    tk::ScrollByUnits %W v -1
d101 1
a101 1
    tk::ScrollByUnits %W v 1
d104 1
a104 1
    tk::ScrollByPages %W v -1
d107 1
a107 1
    tk::ScrollByPages %W v 1
d110 1
a110 1
    tk::ScrollByUnits %W h -1
d113 1
a113 1
    tk::ScrollByUnits %W h 1
d116 1
a116 1
    tk::ScrollByPages %W h -1
d119 1
a119 1
    tk::ScrollByPages %W h 1
d122 1
a122 1
    tk::ScrollByPages %W hv -1
d125 1
a125 1
    tk::ScrollByPages %W hv 1
d128 1
a128 1
    tk::ScrollToPos %W 0
d131 1
a131 1
    tk::ScrollToPos %W 1
d134 1
a134 1
# tk::ScrollButtonDown --
d143 3
a145 3
proc tk::ScrollButtonDown {w x y} {
    variable ::tk::Priv
    set Priv(relief) [$w cget -activerelief]
d149 1
a149 1
	ScrollStartDrag $w $x $y
d151 1
a151 1
	ScrollSelect $w $element initial
d155 1
a155 1
# ::tk::ScrollButtonUp --
d164 4
a167 4
proc ::tk::ScrollButtonUp {w x y} {
    variable ::tk::Priv
    tk::CancelRepeat
    if {[info exists Priv(relief)]} {
d169 2
a170 2
	$w configure -activerelief $Priv(relief)
	ScrollEndDrag $w $x $y
d175 1
a175 1
# ::tk::ScrollSelect --
d189 2
a190 2
proc ::tk::ScrollSelect {w element repeat} {
    variable ::tk::Priv
d193 4
a196 4
	"arrow1"	{ScrollByUnits $w hv -1}
	"trough1"	{ScrollByPages $w hv -1}
	"trough2"	{ScrollByPages $w hv 1}
	"arrow2"	{ScrollByUnits $w hv 1}
d200 2
a201 2
	set Priv(afterId) [after [$w cget -repeatinterval] \
		[list tk::ScrollSelect $w $element again]]
d205 2
a206 2
	    set Priv(afterId) [after $delay \
		    [list tk::ScrollSelect $w $element again]]
d211 1
a211 1
# ::tk::ScrollStartDrag --
d219 2
a220 2
proc ::tk::ScrollStartDrag {w x y} {
    variable ::tk::Priv
d225 6
a230 6
    set Priv(pressX) $x
    set Priv(pressY) $y
    set Priv(initValues) [$w get]
    set iv0 [lindex $Priv(initValues) 0]
    if {[llength $Priv(initValues)] == 2} {
	set Priv(initPos) $iv0
d232 1
a232 1
	set Priv(initPos) 0.0
d234 2
a235 2
	set Priv(initPos) [expr {(double([lindex $Priv(initValues) 2])) \
		/ [lindex $Priv(initValues) 0]}]
d239 1
a239 1
# ::tk::ScrollDrag --
d249 2
a250 2
proc ::tk::ScrollDrag {w x y} {
    variable ::tk::Priv
d252 1
a252 1
    if {[string equal $Priv(initPos) ""]} {
d255 1
a255 1
    set delta [$w delta [expr {$x - $Priv(pressX)}] [expr {$y - $Priv(pressY)}]]
d257 3
a259 3
	if {[llength $Priv(initValues)] == 2} {
	    $w set [expr {[lindex $Priv(initValues) 0] + $delta}] \
		    [expr {[lindex $Priv(initValues) 1] + $delta}]
d261 4
a264 4
	    set delta [expr {round($delta * [lindex $Priv(initValues) 0])}]
	    eval [list $w] set [lreplace $Priv(initValues) 2 3 \
		    [expr {[lindex $Priv(initValues) 2] + $delta}] \
		    [expr {[lindex $Priv(initValues) 3] + $delta}]]
d267 1
a267 1
	ScrollToPos $w [expr {$Priv(initPos) + $delta}]
d271 1
a271 1
# ::tk::ScrollEndDrag --
d279 2
a280 2
proc ::tk::ScrollEndDrag {w x y} {
    variable ::tk::Priv
d282 1
a282 1
    if {[string equal $Priv(initPos) ""]} {
d286 3
a288 3
	set delta [$w delta [expr {$x - $Priv(pressX)}] \
		[expr {$y - $Priv(pressY)}]]
	ScrollToPos $w [expr {$Priv(initPos) + $delta}]
d290 1
a290 1
    set Priv(initPos) ""
d293 1
a293 1
# ::tk::ScrollByUnits --
d304 1
a304 1
proc ::tk::ScrollByUnits {w orient amount} {
d318 1
a318 1
# ::tk::ScrollByPages --
d329 1
a329 1
proc ::tk::ScrollByPages {w orient amount} {
d343 1
a343 1
# ::tk::ScrollToPos --
d353 1
a353 1
proc ::tk::ScrollToPos {w pos} {
d366 1
a366 1
# ::tk::ScrollTopBottom
d374 2
a375 2
proc ::tk::ScrollTopBottom {w x y} {
    variable ::tk::Priv
d378 1
a378 1
	ScrollToPos $w 0
d380 1
a380 1
	ScrollToPos $w 1
d383 1
a383 1
    # Set Priv(relief), since it's needed by tk::ScrollButtonUp.
d385 1
a385 1
    set Priv(relief) [$w cget -activerelief]
d388 1
a388 1
# ::tk::ScrollButton2Down
d398 2
a399 2
proc ::tk::ScrollButton2Down {w x y} {
    variable ::tk::Priv
d402 1
a402 1
	ScrollButtonDown $w $x $y
d405 2
a406 2
    ScrollToPos $w [$w fraction $x $y]
    set Priv(relief) [$w cget -activerelief]
d415 1
a415 1
    ScrollStartDrag $w $x $y
d417 1
@


