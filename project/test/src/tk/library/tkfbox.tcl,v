head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.46;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.14;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.26;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.52;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.34;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.51;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# tkfbox.tcl --
#
#	Implements the "TK" standard file selection dialog box. This
#	dialog box is used on the Unix platforms whenever the tk_strictMotif
#	flag is not set.
#
#	The "TK" standard file selection dialog box is similar to the
#	file selection dialog box on Win95(TM). The user can navigate
#	the directories by clicking on the folder icons or by
#	selecting the "Directory" option menu. The user can select
#	files by clicking on the file icons or by entering a filename
#	in the "Filename:" entry.
#
# RCS: @@(#) $Id: tkfbox.tcl,v 1.37 2002/07/22 21:25:39 mdejong Exp $
#
# Copyright (c) 1994-1998 Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

#----------------------------------------------------------------------
#
#		      I C O N   L I S T
#
# This is a pseudo-widget that implements the icon list inside the 
# ::tk::dialog::file:: dialog box.
#
#----------------------------------------------------------------------

# ::tk::IconList --
#
#	Creates an IconList widget.
#
proc ::tk::IconList {w args} {
    IconList_Config $w $args
    IconList_Create $w
}

proc ::tk::IconList_Index {w i} {
    upvar #0 ::tk::$w data
    upvar #0 ::tk::$w:itemList itemList
    if {![info exists data(list)]} {set data(list) {}}
    switch -regexp -- $i {
	"^-?[0-9]+$" {
	    if { $i < 0 } {
		set i 0
	    }
	    if { $i >= [llength $data(list)] } {
		set i [expr {[llength $data(list)] - 1}]
	    }
	    return $i
	}
	"^active$" {
	    return $data(index,active)
	}
	"^anchor$" {
	    return $data(index,anchor)
	}
	"^end$" {
	    return [llength $data(list)]
	}
	"@@-?[0-9]+,-?[0-9]+" {
	    foreach {x y} [scan $i "@@%d,%d"] {
		break
	    }
	    set item [$data(canvas) find closest $x $y]
	    return [lindex [$data(canvas) itemcget $item -tags] 1]
	}
    }
}

proc ::tk::IconList_Selection {w op args} {
    upvar ::tk::$w data
    switch -exact -- $op {
	"anchor" {
	    if { [llength $args] == 1 } {
		set data(index,anchor) [tk::IconList_Index $w [lindex $args 0]]
	    } else {
		return $data(index,anchor)
	    }
	}
	"clear" {
	    if { [llength $args] == 2 } {
		foreach {first last} $args {
		    break
		}
	    } elseif { [llength $args] == 1 } {
		set first [set last [lindex $args 0]]
	    } else {
		error "wrong # args: should be [lindex [info level 0] 0] path\
			clear first ?last?"
	    }
	    set first [IconList_Index $w $first]
	    set last [IconList_Index $w $last]
	    if { $first > $last } {
		set tmp $first
		set first $last
		set last $tmp
	    }
	    set ind 0
	    foreach item $data(selection) {
		if { $item >= $first } {
		    set first $ind
		    break
		}
	    }
	    set ind [expr {[llength $data(selection)] - 1}]
	    for {} {$ind >= 0} {incr ind -1} {
		set item [lindex $data(selection) $ind]
		if { $item <= $last } {
		    set last $ind
		    break
		}
	    }

	    if { $first > $last } {
		return
	    }
	    set data(selection) [lreplace $data(selection) $first $last]
	    event generate $w <<ListboxSelect>>
	    IconList_DrawSelection $w
	}
	"includes" {
	    set index [lsearch -exact $data(selection) [lindex $args 0]]
	    return [expr {$index != -1}]
	}
	"set" {
	    if { [llength $args] == 2 } {
		foreach {first last} $args {
		    break
		}
	    } elseif { [llength $args] == 1 } {
		set last [set first [lindex $args 0]]
	    } else {
		error "wrong # args: should be [lindex [info level 0] 0] path\
			set first ?last?"
	    }

	    set first [IconList_Index $w $first]
	    set last [IconList_Index $w $last]
	    if { $first > $last } {
		set tmp $first
		set first $last
		set last $tmp
	    }
	    for {set i $first} {$i <= $last} {incr i} {
		lappend data(selection) $i
	    }
	    set data(selection) [lsort -integer -unique $data(selection)]
	    event generate $w <<ListboxSelect>>
	    IconList_DrawSelection $w
	}
    }
}

proc ::tk::IconList_Curselection {w} {
    upvar ::tk::$w data
    return $data(selection)
}

proc ::tk::IconList_DrawSelection {w} {
    upvar ::tk::$w data
    upvar ::tk::$w:itemList itemList

    $data(canvas) delete selection
    foreach item $data(selection) {
	set rTag [lindex [lindex $data(list) $item] 2]
	foreach {iTag tTag text serial} $itemList($rTag) {
	    break
	}

	set bbox [$data(canvas) bbox $tTag]
        $data(canvas) create rect $bbox -fill \#a0a0ff -outline \#a0a0ff \
		-tags selection
    }
    $data(canvas) lower selection
    return
}

proc ::tk::IconList_Get {w item} {
    upvar ::tk::$w data
    upvar ::tk::$w:itemList itemList
    set rTag [lindex [lindex $data(list) $item] 2]
    foreach {iTag tTag text serial} $itemList($rTag) {
	break
    }
    return $text
}

# ::tk::IconList_Config --
#
#	Configure the widget variables of IconList, according to the command
#	line arguments.
#
proc ::tk::IconList_Config {w argList} {

    # 1: the configuration specs
    #
    set specs {
	{-command "" "" ""}
	{-multiple "" "" "0"}
    }

    # 2: parse the arguments
    #
    tclParseConfigSpec ::tk::$w $specs "" $argList
}

# ::tk::IconList_Create --
#
#	Creates an IconList widget by assembling a canvas widget and a
#	scrollbar widget. Sets all the bindings necessary for the IconList's
#	operations.
#
proc ::tk::IconList_Create {w} {
    upvar ::tk::$w data

    frame $w
    set data(sbar)   [scrollbar $w.sbar -orient horizontal \
	-highlightthickness 0 -takefocus 0]
    set data(canvas) [canvas $w.canvas -bd 2 -relief sunken \
	-width 400 -height 120 -takefocus 1]
    pack $data(sbar) -side bottom -fill x -padx 2
    pack $data(canvas) -expand yes -fill both

    $data(sbar) config -command [list $data(canvas) xview]
    $data(canvas) config -xscrollcommand [list $data(sbar) set]

    # Initializes the max icon/text width and height and other variables
    #
    set data(maxIW) 1
    set data(maxIH) 1
    set data(maxTW) 1
    set data(maxTH) 1
    set data(numItems) 0
    set data(curItem)  {}
    set data(noScroll) 1
    set data(selection) {}
    set data(index,anchor) ""

    # Creates the event bindings.
    #
    bind $data(canvas) <Configure>	[list tk::IconList_Arrange $w]

    bind $data(canvas) <1>		[list tk::IconList_Btn1 $w %x %y]
    bind $data(canvas) <B1-Motion>	[list tk::IconList_Motion1 $w %x %y]
    bind $data(canvas) <B1-Leave>	[list tk::IconList_Leave1 $w %x %y]
    bind $data(canvas) <Control-1>	[list tk::IconList_CtrlBtn1 $w %x %y]
    bind $data(canvas) <Shift-1>	[list tk::IconList_ShiftBtn1 $w %x %y]
    bind $data(canvas) <B1-Enter>	[list tk::CancelRepeat]
    bind $data(canvas) <ButtonRelease-1> [list tk::CancelRepeat]
    bind $data(canvas) <Double-ButtonRelease-1> \
	    [list tk::IconList_Double1 $w %x %y]

    bind $data(canvas) <Up>		[list tk::IconList_UpDown $w -1]
    bind $data(canvas) <Down>		[list tk::IconList_UpDown $w  1]
    bind $data(canvas) <Left>		[list tk::IconList_LeftRight $w -1]
    bind $data(canvas) <Right>		[list tk::IconList_LeftRight $w  1]
    bind $data(canvas) <Return>		[list tk::IconList_ReturnKey $w]
    bind $data(canvas) <KeyPress>	[list tk::IconList_KeyPress $w %A]
    bind $data(canvas) <Control-KeyPress> ";"
    bind $data(canvas) <Alt-KeyPress>	";"

    bind $data(canvas) <FocusIn>	[list tk::IconList_FocusIn $w]
    bind $data(canvas) <FocusOut>	[list tk::IconList_FocusOut $w]

    return $w
}

# ::tk::IconList_AutoScan --
#
# This procedure is invoked when the mouse leaves an entry window
# with button 1 down.  It scrolls the window up, down, left, or
# right, depending on where the mouse left the window, and reschedules
# itself as an "after" command so that the window continues to scroll until
# the mouse moves back into the window or the mouse button is released.
#
# Arguments:
# w -		The IconList window.
#
proc ::tk::IconList_AutoScan {w} {
    upvar ::tk::$w data
    variable ::tk::Priv

    if {![winfo exists $w]} return
    set x $Priv(x)
    set y $Priv(y)

    if {$data(noScroll)} {
	return
    }
    if {$x >= [winfo width $data(canvas)]} {
	$data(canvas) xview scroll 1 units
    } elseif {$x < 0} {
	$data(canvas) xview scroll -1 units
    } elseif {$y >= [winfo height $data(canvas)]} {
	# do nothing
    } elseif {$y < 0} {
	# do nothing
    } else {
	return
    }

    IconList_Motion1 $w $x $y
    set Priv(afterId) [after 50 [list tk::IconList_AutoScan $w]]
}

# Deletes all the items inside the canvas subwidget and reset the IconList's
# state.
#
proc ::tk::IconList_DeleteAll {w} {
    upvar ::tk::$w data
    upvar ::tk::$w:itemList itemList

    $data(canvas) delete all
    catch {unset data(selected)}
    catch {unset data(rect)}
    catch {unset data(list)}
    catch {unset itemList}
    set data(maxIW) 1
    set data(maxIH) 1
    set data(maxTW) 1
    set data(maxTH) 1
    set data(numItems) 0
    set data(curItem)  {}
    set data(noScroll) 1
    set data(selection) {}
    set data(index,anchor) ""
    $data(sbar) set 0.0 1.0
    $data(canvas) xview moveto 0
}

# Adds an icon into the IconList with the designated image and text
#
proc ::tk::IconList_Add {w image items} {
    upvar ::tk::$w data
    upvar ::tk::$w:itemList itemList
    upvar ::tk::$w:textList textList

    foreach text $items {
	set iTag [$data(canvas) create image 0 0 -image $image -anchor nw \
		-tags [list icon $data(numItems) item$data(numItems)]]
	set tTag [$data(canvas) create text  0 0 -text  $text  -anchor nw \
		-font $data(font) \
		-tags [list text $data(numItems) item$data(numItems)]]
	set rTag [$data(canvas) create rect  0 0 0 0 -fill "" -outline "" \
		-tags [list rect $data(numItems) item$data(numItems)]]
	
	foreach {x1 y1 x2 y2} [$data(canvas) bbox $iTag] {
	    break
	}
	set iW [expr {$x2 - $x1}]
	set iH [expr {$y2 - $y1}]
	if {$data(maxIW) < $iW} {
	    set data(maxIW) $iW
	}
	if {$data(maxIH) < $iH} {
	    set data(maxIH) $iH
	}
    
	foreach {x1 y1 x2 y2} [$data(canvas) bbox $tTag] {
	    break
	}
	set tW [expr {$x2 - $x1}]
	set tH [expr {$y2 - $y1}]
	if {$data(maxTW) < $tW} {
	    set data(maxTW) $tW
	}
	if {$data(maxTH) < $tH} {
	    set data(maxTH) $tH
	}
    
	lappend data(list) [list $iTag $tTag $rTag $iW $iH $tW \
		$tH $data(numItems)]
	set itemList($rTag) [list $iTag $tTag $text $data(numItems)]
	set textList($data(numItems)) [string tolower $text]
	incr data(numItems)
    }
}

# Places the icons in a column-major arrangement.
#
proc ::tk::IconList_Arrange {w} {
    upvar ::tk::$w data

    if {![info exists data(list)]} {
	if {[info exists data(canvas)] && [winfo exists $data(canvas)]} {
	    set data(noScroll) 1
	    $data(sbar) config -command ""
	}
	return
    }

    set W [winfo width  $data(canvas)]
    set H [winfo height $data(canvas)]
    set pad [expr {[$data(canvas) cget -highlightthickness] + \
	    [$data(canvas) cget -bd]}]
    if {$pad < 2} {
	set pad 2
    }

    incr W -[expr {$pad*2}]
    incr H -[expr {$pad*2}]

    set dx [expr {$data(maxIW) + $data(maxTW) + 8}]
    if {$data(maxTH) > $data(maxIH)} {
	set dy $data(maxTH)
    } else {
	set dy $data(maxIH)
    }
    incr dy 2
    set shift [expr {$data(maxIW) + 4}]

    set x [expr {$pad * 2}]
    set y [expr {$pad * 1}] ; # Why * 1 ?
    set usedColumn 0
    foreach sublist $data(list) {
	set usedColumn 1
	foreach {iTag tTag rTag iW iH tW tH} $sublist {
	    break
	}

	set i_dy [expr {($dy - $iH)/2}]
	set t_dy [expr {($dy - $tH)/2}]

	$data(canvas) coords $iTag $x                    [expr {$y + $i_dy}]
	$data(canvas) coords $tTag [expr {$x + $shift}]  [expr {$y + $t_dy}]
	$data(canvas) coords $rTag $x $y [expr {$x+$dx}] [expr {$y+$dy}]

	incr y $dy
	if {($y + $dy) > $H} {
	    set y [expr {$pad * 1}] ; # *1 ?
	    incr x $dx
	    set usedColumn 0
	}
    }

    if {$usedColumn} {
	set sW [expr {$x + $dx}]
    } else {
	set sW $x
    }

    if {$sW < $W} {
	$data(canvas) config -scrollregion [list $pad $pad $sW $H]
	$data(sbar) config -command ""
	$data(canvas) xview moveto 0
	set data(noScroll) 1
    } else {
	$data(canvas) config -scrollregion [list $pad $pad $sW $H]
	$data(sbar) config -command [list $data(canvas) xview]
	set data(noScroll) 0
    }

    set data(itemsPerColumn) [expr {($H-$pad)/$dy}]
    if {$data(itemsPerColumn) < 1} {
	set data(itemsPerColumn) 1
    }

    if {$data(curItem) != ""} {
	IconList_Select $w [lindex [lindex $data(list) $data(curItem)] 2] 0
    }
}

# Gets called when the user invokes the IconList (usually by double-clicking
# or pressing the Return key).
#
proc ::tk::IconList_Invoke {w} {
    upvar ::tk::$w data

    if {$data(-command) != "" && [llength $data(selection)]} {
	uplevel #0 $data(-command)
    }
}

# ::tk::IconList_See --
#
#	If the item is not (completely) visible, scroll the canvas so that
#	it becomes visible.
proc ::tk::IconList_See {w rTag} {
    upvar ::tk::$w data
    upvar ::tk::$w:itemList itemList

    if {$data(noScroll)} {
	return
    }
    set sRegion [$data(canvas) cget -scrollregion]
    if {[string equal $sRegion {}]} {
	return
    }

    if { $rTag < 0 || $rTag >= [llength $data(list)] } {
	return
    }

    set bbox [$data(canvas) bbox item$rTag]
    set pad [expr {[$data(canvas) cget -highlightthickness] + \
	    [$data(canvas) cget -bd]}]

    set x1 [lindex $bbox 0]
    set x2 [lindex $bbox 2]
    incr x1 -[expr {$pad * 2}]
    incr x2 -[expr {$pad * 1}] ; # *1 ?

    set cW [expr {[winfo width $data(canvas)] - $pad*2}]

    set scrollW [expr {[lindex $sRegion 2]-[lindex $sRegion 0]+1}]
    set dispX [expr {int([lindex [$data(canvas) xview] 0]*$scrollW)}]
    set oldDispX $dispX

    # check if out of the right edge
    #
    if {($x2 - $dispX) >= $cW} {
	set dispX [expr {$x2 - $cW}]
    }
    # check if out of the left edge
    #
    if {($x1 - $dispX) < 0} {
	set dispX $x1
    }

    if {$oldDispX != $dispX} {
	set fraction [expr {double($dispX)/double($scrollW)}]
	$data(canvas) xview moveto $fraction
    }
}

proc ::tk::IconList_Btn1 {w x y} {
    upvar ::tk::$w data

    focus $data(canvas)
    set x [expr {int([$data(canvas) canvasx $x])}]
    set y [expr {int([$data(canvas) canvasy $y])}]
    set i [IconList_Index $w @@${x},${y}]
    if {$i==""} return
    IconList_Selection $w clear 0 end
    IconList_Selection $w set $i
    IconList_Selection $w anchor $i
}

proc ::tk::IconList_CtrlBtn1 {w x y} {
    upvar ::tk::$w data
    
    if { $data(-multiple) } {
	focus $data(canvas)
	set x [expr {int([$data(canvas) canvasx $x])}]
	set y [expr {int([$data(canvas) canvasy $y])}]
	set i [IconList_Index $w @@${x},${y}]
	if {$i==""} return
	if { [IconList_Selection $w includes $i] } {
	    IconList_Selection $w clear $i
	} else {
	    IconList_Selection $w set $i
	    IconList_Selection $w anchor $i
	}
    }
}

proc ::tk::IconList_ShiftBtn1 {w x y} {
    upvar ::tk::$w data
    
    if { $data(-multiple) } {
	focus $data(canvas)
	set x [expr {int([$data(canvas) canvasx $x])}]
	set y [expr {int([$data(canvas) canvasy $y])}]
	set i [IconList_Index $w @@${x},${y}]
	if {$i==""} return
	set a [IconList_Index $w anchor]
	if { [string equal $a ""] } {
	    set a $i
	}
	IconList_Selection $w clear 0 end
	IconList_Selection $w set $a $i
    }
}

# Gets called on button-1 motions
#
proc ::tk::IconList_Motion1 {w x y} {
    upvar ::tk::$w data
    variable ::tk::Priv
    set Priv(x) $x
    set Priv(y) $y
    set x [expr {int([$data(canvas) canvasx $x])}]
    set y [expr {int([$data(canvas) canvasy $y])}]
    set i [IconList_Index $w @@${x},${y}]
    if {$i==""} return
    IconList_Selection $w clear 0 end
    IconList_Selection $w set $i
}

proc ::tk::IconList_Double1 {w x y} {
    upvar ::tk::$w data

    if {[llength $data(selection)]} {
	IconList_Invoke $w
    }
}

proc ::tk::IconList_ReturnKey {w} {
    IconList_Invoke $w
}

proc ::tk::IconList_Leave1 {w x y} {
    variable ::tk::Priv

    set Priv(x) $x
    set Priv(y) $y
    IconList_AutoScan $w
}

proc ::tk::IconList_FocusIn {w} {
    upvar ::tk::$w data

    if {![info exists data(list)]} {
	return
    }

    if {[llength $data(selection)]} {
	IconList_DrawSelection $w
    }
}

proc ::tk::IconList_FocusOut {w} {
    IconList_Selection $w clear 0 end
}

# ::tk::IconList_UpDown --
#
# Moves the active element up or down by one element
#
# Arguments:
# w -		The IconList widget.
# amount -	+1 to move down one item, -1 to move back one item.
#
proc ::tk::IconList_UpDown {w amount} {
    upvar ::tk::$w data

    if {![info exists data(list)]} {
	return
    }

    set curr [tk::IconList_Curselection $w]
    if { [llength $curr] == 0 } {
	set i 0
    } else {
	set i [tk::IconList_Index $w anchor]
	if {$i==""} return
	incr i $amount
    }
    IconList_Selection $w clear 0 end
    IconList_Selection $w set $i
    IconList_Selection $w anchor $i
    IconList_See $w $i
}

# ::tk::IconList_LeftRight --
#
# Moves the active element left or right by one column
#
# Arguments:
# w -		The IconList widget.
# amount -	+1 to move right one column, -1 to move left one column.
#
proc ::tk::IconList_LeftRight {w amount} {
    upvar ::tk::$w data

    if {![info exists data(list)]} {
	return
    }

    set curr [IconList_Curselection $w]
    if { [llength $curr] == 0 } {
	set i 0
    } else {
	set i [IconList_Index $w anchor]
	if {$i==""} return
	incr i [expr {$amount*$data(itemsPerColumn)}]
    }
    IconList_Selection $w clear 0 end
    IconList_Selection $w set $i
    IconList_Selection $w anchor $i
    IconList_See $w $i
}

#----------------------------------------------------------------------
#		Accelerator key bindings
#----------------------------------------------------------------------

# ::tk::IconList_KeyPress --
#
#	Gets called when user enters an arbitrary key in the listbox.
#
proc ::tk::IconList_KeyPress {w key} {
    variable ::tk::Priv

    append Priv(ILAccel,$w) $key
    IconList_Goto $w $Priv(ILAccel,$w)
    catch {
	after cancel $Priv(ILAccel,$w,afterId)
    }
    set Priv(ILAccel,$w,afterId) [after 500 [list tk::IconList_Reset $w]]
}

proc ::tk::IconList_Goto {w text} {
    upvar ::tk::$w data
    upvar ::tk::$w:textList textList
    
    if {![info exists data(list)]} {
	return
    }

    if {[string equal {} $text]} {
	return
    }

    if {$data(curItem) == "" || $data(curItem) == 0} {
	set start  0
    } else {
	set start  $data(curItem)
    }

    set text [string tolower $text]
    set theIndex -1
    set less 0
    set len [string length $text]
    set len0 [expr {$len-1}]
    set i $start

    # Search forward until we find a filename whose prefix is an exact match
    # with $text
    while {1} {
	set sub [string range $textList($i) 0 $len0]
	if {[string equal $text $sub]} {
	    set theIndex $i
	    break
	}
	incr i
	if {$i == $data(numItems)} {
	    set i 0
	}
	if {$i == $start} {
	    break
	}
    }

    if {$theIndex > -1} {
	IconList_Selection $w clear 0 end
	IconList_Selection $w set $theIndex
	IconList_Selection $w anchor $theIndex
	IconList_See $w $theIndex
    }
}

proc ::tk::IconList_Reset {w} {
    variable ::tk::Priv

    catch {unset Priv(ILAccel,$w)}
}

#----------------------------------------------------------------------
#
#		      F I L E   D I A L O G
#
#----------------------------------------------------------------------

namespace eval ::tk::dialog {}
namespace eval ::tk::dialog::file {
    namespace import ::tk::msgcat::*
}

# ::tk::dialog::file:: --
#
#	Implements the TK file selection dialog. This dialog is used when
#	the tk_strictMotif flag is set to false. This procedure shouldn't
#	be called directly. Call tk_getOpenFile or tk_getSaveFile instead.
#
# Arguments:
#	type		"open" or "save"
#	args		Options parsed by the procedure.
#

proc ::tk::dialog::file:: {type args} {
    variable ::tk::Priv
    set dataName __tk_filedialog
    upvar ::tk::dialog::file::$dataName data

    ::tk::dialog::file::Config $dataName $type $args

    if {[string equal $data(-parent) .]} {
        set w .$dataName
    } else {
        set w $data(-parent).$dataName
    }

    # (re)create the dialog box if necessary
    #
    if {![winfo exists $w]} {
	::tk::dialog::file::Create $w TkFDialog
    } elseif {[string compare [winfo class $w] TkFDialog]} {
	destroy $w
	::tk::dialog::file::Create $w TkFDialog
    } else {
	set data(dirMenuBtn) $w.f1.menu
	set data(dirMenu) $w.f1.menu.menu
	set data(upBtn) $w.f1.up
	set data(icons) $w.icons
	set data(ent) $w.f2.ent
	set data(typeMenuLab) $w.f3.lab
	set data(typeMenuBtn) $w.f3.menu
	set data(typeMenu) $data(typeMenuBtn).m
	set data(okBtn) $w.f2.ok
	set data(cancelBtn) $w.f3.cancel
	::tk::dialog::file::SetSelectMode $w $data(-multiple)
    }

    # Dialog boxes should be transient with respect to their parent,
    # so that they will always stay on top of their parent window.  However,
    # some window managers will create the window as withdrawn if the parent
    # window is withdrawn or iconified.  Combined with the grab we put on the
    # window, this can hang the entire application.  Therefore we only make
    # the dialog transient if the parent is viewable.

    if {[winfo viewable [winfo toplevel $data(-parent)]] } {
	wm transient $w $data(-parent)
    }

    # Add traces on the selectPath variable
    #

    trace variable data(selectPath) w "::tk::dialog::file::SetPath $w"
    $data(dirMenuBtn) configure \
	    -textvariable ::tk::dialog::file::${dataName}(selectPath)

    # Initialize the file types menu
    #
    if {[llength $data(-filetypes)]} {
	$data(typeMenu) delete 0 end
	foreach type $data(-filetypes) {
	    set title  [lindex $type 0]
	    set filter [lindex $type 1]
	    $data(typeMenu) add command -label $title \
		-command [list ::tk::dialog::file::SetFilter $w $type]
	}
	::tk::dialog::file::SetFilter $w [lindex $data(-filetypes) 0]
	$data(typeMenuBtn) config -state normal
	$data(typeMenuLab) config -state normal
    } else {
	set data(filter) "*"
	$data(typeMenuBtn) config -state disabled -takefocus 0
	$data(typeMenuLab) config -state disabled
    }
    ::tk::dialog::file::UpdateWhenIdle $w

    # Withdraw the window, then update all the geometry information
    # so we know how big it wants to be, then center the window in the
    # display and de-iconify it.

    ::tk::PlaceWindow $w widget $data(-parent)
    wm title $w $data(-title)

    # Set a grab and claim the focus too.

    ::tk::SetFocusGrab $w $data(ent)
    $data(ent) delete 0 end
    $data(ent) insert 0 $data(selectFile)
    $data(ent) selection range 0 end
    $data(ent) icursor end

    # Wait for the user to respond, then restore the focus and
    # return the index of the selected button.  Restore the focus
    # before deleting the window, since otherwise the window manager
    # may take the focus away so we can't redirect it.  Finally,
    # restore any grab that was in effect.

    vwait ::tk::Priv(selectFilePath)

    ::tk::RestoreFocusGrab $w $data(ent) withdraw

    # Cleanup traces on selectPath variable
    #

    foreach trace [trace vinfo data(selectPath)] {
	trace vdelete data(selectPath) [lindex $trace 0] [lindex $trace 1]
    }
    $data(dirMenuBtn) configure -textvariable {}

    return $Priv(selectFilePath)
}

# ::tk::dialog::file::Config --
#
#	Configures the TK filedialog according to the argument list
#
proc ::tk::dialog::file::Config {dataName type argList} {
    upvar ::tk::dialog::file::$dataName data

    set data(type) $type

    # 0: Delete all variable that were set on data(selectPath) the
    # last time the file dialog is used. The traces may cause troubles
    # if the dialog is now used with a different -parent option.

    foreach trace [trace vinfo data(selectPath)] {
	trace vdelete data(selectPath) [lindex $trace 0] [lindex $trace 1]
    }

    # 1: the configuration specs
    #
    set specs {
	{-defaultextension "" "" ""}
	{-filetypes "" "" ""}
	{-initialdir "" "" ""}
	{-initialfile "" "" ""}
	{-parent "" "" "."}
	{-title "" "" ""}
    }

    # The "-multiple" option is only available for the "open" file dialog.
    #
    if { [string equal $type "open"] } {
	lappend specs {-multiple "" "" "0"}
    }

    # 2: default values depending on the type of the dialog
    #
    if {![info exists data(selectPath)]} {
	# first time the dialog has been popped up
	set data(selectPath) [pwd]
	set data(selectFile) ""
    }

    # 3: parse the arguments
    #
    tclParseConfigSpec ::tk::dialog::file::$dataName $specs "" $argList

    if {$data(-title) == ""} {
	if {[string equal $type "open"]} {
	    set data(-title) "[mc "Open"]"
	} else {
	    set data(-title) "[mc "Save As"]"
	}
    }

    # 4: set the default directory and selection according to the -initial
    #    settings
    #
    if {$data(-initialdir) != ""} {
	# Ensure that initialdir is an absolute path name.
	if {[file isdirectory $data(-initialdir)]} {
	    set old [pwd]
	    cd $data(-initialdir)
	    set data(selectPath) [pwd]
	    cd $old
	} else {
	    set data(selectPath) [pwd]
	}
    }
    set data(selectFile) $data(-initialfile)

    # 5. Parse the -filetypes option
    #
    set data(-filetypes) [::tk::FDGetFileTypes $data(-filetypes)]

    if {![winfo exists $data(-parent)]} {
	error "bad window path name \"$data(-parent)\""
    }

    # Set -multiple to a one or zero value (not other boolean types
    # like "yes") so we can use it in tests more easily.
    if {![string compare $type save]} {
	set data(-multiple) 0
    } elseif {$data(-multiple)} { 
	set data(-multiple) 1 
    } else {
	set data(-multiple) 0
    }
}

proc ::tk::dialog::file::Create {w class} {
    set dataName [lindex [split $w .] end]
    upvar ::tk::dialog::file::$dataName data
    variable ::tk::Priv
    global tk_library

    toplevel $w -class $class

    # f1: the frame with the directory option menu
    #
    set f1 [frame $w.f1]
    bind [::tk::AmpWidget label $f1.lab -text "[mc "&Directory:"]" ] \
	<<AltUnderlined>> [list focus $f1.menu]
    
    set data(dirMenuBtn) $f1.menu
    set data(dirMenu) [tk_optionMenu $f1.menu [format %s(selectPath) ::tk::dialog::file::$dataName] ""]
    set data(upBtn) [button $f1.up]
    if {![info exists Priv(updirImage)]} {
	set Priv(updirImage) [image create bitmap -data {
#define updir_width 28
#define updir_height 16
static char updir_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x80, 0x1f, 0x00, 0x00, 0x40, 0x20, 0x00, 0x00,
   0x20, 0x40, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x01, 0x10, 0x00, 0x00, 0x01,
   0x10, 0x02, 0x00, 0x01, 0x10, 0x07, 0x00, 0x01, 0x90, 0x0f, 0x00, 0x01,
   0x10, 0x02, 0x00, 0x01, 0x10, 0x02, 0x00, 0x01, 0x10, 0x02, 0x00, 0x01,
   0x10, 0xfe, 0x07, 0x01, 0x10, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x01,
   0xf0, 0xff, 0xff, 0x01};}]
    }
    $data(upBtn) config -image $Priv(updirImage)

    $f1.menu config -takefocus 1 -highlightthickness 2
 
    pack $data(upBtn) -side right -padx 4 -fill both
    pack $f1.lab -side left -padx 4 -fill both
    pack $f1.menu -expand yes -fill both -padx 4

    # data(icons): the IconList that list the files and directories.
    #
    if { [string equal $class TkFDialog] } {
	if { $data(-multiple) } {
	    set fNameCaption "[mc {File &names:}]"
	} else {
	    set fNameCaption "[mc {File &name:}]"
	}
	set fTypeCaption [mc "Files of &type:"]
	set fCaptionWidth [::tk::mcmaxamp $fNameCaption $fTypeCaption]
	set fCaptionWidth [expr {$fCaptionWidth<14?14:$fCaptionWidth}]
	set iconListCommand [list ::tk::dialog::file::OkCmd $w]
    } else {
	set fNameCaption [mc "&Selection:"]
	set fCaptionWidth [string length $fNameCaption]
	set iconListCommand [list ::tk::dialog::file::chooseDir::DblClick $w]
    }
    set data(icons) [::tk::IconList $w.icons \
	    -command	$iconListCommand \
	    -multiple	$data(-multiple)]
    bind $data(icons) <<ListboxSelect>> \
	    [list ::tk::dialog::file::ListBrowse $w]

    # f2: the frame with the OK button and the "file name" field
    #
    set f2 [frame $w.f2 -bd 0]
    bind [::tk::AmpWidget label $f2.lab -text $fNameCaption -anchor e -width $fCaptionWidth \
	    -pady 0] <<AltUnderlined>> [list focus $f2.ent]
    set data(ent) [entry $f2.ent]

    # The font to use for the icons. The default Canvas font on Unix
    # is just deviant.
    set ::tk::$w.icons(font) [$data(ent) cget -font]

    # f3: the frame with the cancel button and the file types field
    #
    set f3 [frame $w.f3 -bd 0]

    # Make the file types bits only if this is a File Dialog
    if { [string equal $class TkFDialog] } {
	# The "File of types:" label needs to be grayed-out when
	# -filetypes are not specified. The label widget does not support
	# grayed-out text on monochrome displays. Therefore, we have to
	# use a button widget to emulate a label widget (by setting its
	# bindtags)
	
	set data(typeMenuLab) [::tk::AmpWidget button $f3.lab -text $fTypeCaption \
		-anchor e -width $fCaptionWidth \
		-bd [$f2.lab cget -bd] \
		-highlightthickness [$f2.lab cget -highlightthickness] \
		-relief [$f2.lab cget -relief] \
		-padx [$f2.lab cget -padx] \
		-pady [$f2.lab cget -pady]]
	bindtags $data(typeMenuLab) [list $data(typeMenuLab) Label \
		[winfo toplevel $data(typeMenuLab)] all]
	set data(typeMenuBtn) [menubutton $f3.menu -indicatoron 1 \
		-menu $f3.menu.m]
	set data(typeMenu) [menu $data(typeMenuBtn).m -tearoff 0]
	$data(typeMenuBtn) config -takefocus 1 -highlightthickness 2 \
		-relief raised -bd 2 -anchor w
        bind $data(typeMenuLab) <<AltUnderlined>> [list focus \
	    $data(typeMenuBtn)]
    }

    # the okBtn is created after the typeMenu so that the keyboard traversal
    # is in the right order
	set maxWidth [::tk::mcmaxamp &OK &Cancel]
	set maxWidth [expr {$maxWidth<6?6:$maxWidth}]
    set data(okBtn)     [::tk::AmpWidget button $f2.ok     -text "[mc "&OK"]" \
	-width $maxWidth -default active -pady 3]
    set data(cancelBtn) [::tk::AmpWidget button $f3.cancel -text "[mc "&Cancel"]" \
	-width $maxWidth -default normal -pady 3]

    # pack the widgets in f2 and f3
    #
    pack $data(okBtn) -side right -padx 4 -anchor e
    pack $f2.lab -side left -padx 4
    pack $f2.ent -expand yes -fill x -padx 2 -pady 0
    
    pack $data(cancelBtn) -side right -padx 4 -anchor w
    if { [string equal $class TkFDialog] } {
	pack $data(typeMenuLab) -side left -padx 4
	pack $data(typeMenuBtn) -expand yes -fill x -side right
    }

    # Pack all the frames together. We are done with widget construction.
    #
    pack $f1 -side top -fill x -pady 4
    pack $f3 -side bottom -fill x
    pack $f2 -side bottom -fill x
    pack $data(icons) -expand yes -fill both -padx 4 -pady 1

    # Set up the event handlers that are common to Directory and File Dialogs
    #

    wm protocol $w WM_DELETE_WINDOW [list ::tk::dialog::file::CancelCmd $w]
    $data(upBtn)     config -command [list ::tk::dialog::file::UpDirCmd $w]
    $data(cancelBtn) config -command [list ::tk::dialog::file::CancelCmd $w]
    bind $w <KeyPress-Escape> [list tk::ButtonInvoke $data(cancelBtn)]
    bind $w <Alt-Key> [list tk::AltKeyInDialog $w %A]
    # Set up event handlers specific to File or Directory Dialogs
    #

    if { [string equal $class TkFDialog] } {
	bind $data(ent) <Return> [list ::tk::dialog::file::ActivateEnt $w]
	$data(okBtn)     config -command [list ::tk::dialog::file::OkCmd $w]
	bind $w <Alt-t> [format {
	    if {[string equal [%s cget -state] "normal"]} {
		focus %s
	    }
	} $data(typeMenuBtn) $data(typeMenuBtn)]
    } else {
	set okCmd [list ::tk::dialog::file::chooseDir::OkCmd $w]
	bind $data(ent) <Return> $okCmd
	$data(okBtn) config -command $okCmd
	bind $w <Alt-s> [list focus $data(ent)]
	bind $w <Alt-o> [list tk::ButtonInvoke $data(okBtn)]
    }

    # Build the focus group for all the entries
    #
    ::tk::FocusGroup_Create $w
    ::tk::FocusGroup_BindIn $w  $data(ent) [list ::tk::dialog::file::EntFocusIn $w]
    ::tk::FocusGroup_BindOut $w $data(ent) [list ::tk::dialog::file::EntFocusOut $w]
}

# ::tk::dialog::file::SetSelectMode --
#
#	Set the select mode of the dialog to single select or multi-select.
#
# Arguments:
#	w		The dialog path.
#	multi		1 if the dialog is multi-select; 0 otherwise.
#
# Results:
#	None.

proc ::tk::dialog::file::SetSelectMode {w multi} {
    set dataName __tk_filedialog
    upvar ::tk::dialog::file::$dataName data
    if { $multi } {
	set fNameCaption "[mc {File &names:}]"
    } else {
	set fNameCaption "[mc {File &name:}]"
    }
    set iconListCommand [list ::tk::dialog::file::OkCmd $w]
    ::tk::SetAmpText $w.f2.lab $fNameCaption 
    ::tk::IconList_Config $data(icons) \
	    [list -multiple $multi -command $iconListCommand]
    return
}

# ::tk::dialog::file::UpdateWhenIdle --
#
#	Creates an idle event handler which updates the dialog in idle
#	time. This is important because loading the directory may take a long
#	time and we don't want to load the same directory for multiple times
#	due to multiple concurrent events.
#
proc ::tk::dialog::file::UpdateWhenIdle {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    if {[info exists data(updateId)]} {
	return
    } else {
	set data(updateId) [after idle [list ::tk::dialog::file::Update $w]]
    }
}

# ::tk::dialog::file::Update --
#
#	Loads the files and directories into the IconList widget. Also
#	sets up the directory option menu for quick access to parent
#	directories.
#
proc ::tk::dialog::file::Update {w} {

    # This proc may be called within an idle handler. Make sure that the
    # window has not been destroyed before this proc is called
    if {![winfo exists $w]} {
	return
    }
    set class [winfo class $w]
    if { [string compare $class TkFDialog] && \
	    [string compare $class TkChooseDir] } {
	return
    }

    set dataName [winfo name $w]
    upvar ::tk::dialog::file::$dataName data
    variable ::tk::Priv
    global tk_library
    catch {unset data(updateId)}

    if {![info exists Priv(folderImage)]} {
	set Priv(folderImage) [image create photo -data {
R0lGODlhEAAMAKEAAAD//wAAAPD/gAAAACH5BAEAAAAALAAAAAAQAAwAAAIghINhyycvVFsB
QtmS3rjaH1Hg141WaT5ouprt2HHcUgAAOw==}]
	set Priv(fileImage)   [image create photo -data {
R0lGODlhDAAMAKEAALLA3AAAAP//8wAAACH5BAEAAAAALAAAAAAMAAwAAAIgRI4Ha+IfWHsO
rSASvJTGhnhcV3EJlo3kh53ltF5nAhQAOw==}]
    }
    set folder $Priv(folderImage)
    set file   $Priv(fileImage)

    set appPWD [pwd]
    if {[catch {
	cd $data(selectPath)
    }]} {
	# We cannot change directory to $data(selectPath). $data(selectPath)
	# should have been checked before ::tk::dialog::file::Update is called, so
	# we normally won't come to here. Anyways, give an error and abort
	# action.
	tk_messageBox -type ok -parent $w -message \
	    "[mc "Cannot change to the directory \"%1\$s\".\nPermission denied." $data(selectPath)]"\
	    -icon warning
	cd $appPWD
	return
    }

    # Turn on the busy cursor. BUG?? We haven't disabled X events, though,
    # so the user may still click and cause havoc ...
    #
    set entCursor [$data(ent) cget -cursor]
    set dlgCursor [$w         cget -cursor]
    $data(ent) config -cursor watch
    $w         config -cursor watch
    update idletasks
    
    ::tk::IconList_DeleteAll $data(icons)

    # Make the dir list
    #
    set completeFileList [lsort -dictionary -unique [glob -nocomplain .* *]]
    set dirList {}
    foreach f $completeFileList {
	if {[string equal $f .]} {
	    continue
	}
	if {[string equal $f ..]} {
	    continue
	}
	if {[file isdir ./$f]} {
	    lappend dirList $f
	}
    }
    ::tk::IconList_Add $data(icons) $folder $dirList
    if { [string equal $class TkFDialog] } {
	# Make the file list if this is a File Dialog
	#
	if {[string equal $data(filter) *]} {
	    set files $completeFileList
	} else {
	    set files {}
	    foreach f $completeFileList {
		foreach pat $data(filter) {
		    if { [string match $pat $f] } {
			lappend files $f
			break
		    }
		}
	    }
	}
	set fileList {}
	foreach f $files {
	    if {![file isdir ./$f]} {
		lappend fileList $f
	    }
	}
	::tk::IconList_Add $data(icons) $file $fileList
    }

    ::tk::IconList_Arrange $data(icons)

    # Update the Directory: option menu
    #
    set list ""
    set dir ""
    foreach subdir [file split $data(selectPath)] {
	set dir [file join $dir $subdir]
	lappend list $dir
    }

    $data(dirMenu) delete 0 end
    set var [format %s(selectPath) ::tk::dialog::file::$dataName]
    foreach path $list {
	$data(dirMenu) add command -label $path -command [list set $var $path]
    }

    # Restore the PWD to the application's PWD
    #
    cd $appPWD

    if { [string equal $class TkFDialog] } {
	# Restore the Open/Save Button if this is a File Dialog
	#
	if {[string equal $data(type) open]} {
	    ::tk::SetAmpText $data(okBtn) [mc "&Open"]
	    set maxWidth [::tk::mcmaxamp [mc "&Open"]]
	    if {$maxWidth>[$data(okBtn) cget -width]} {
		    $data(okBtn) config -width $maxWidth
		    $data(cancelBtn) config -width $maxWidth
	    }
	} else {
	    ::tk::SetAmpText $data(okBtn) [mc "&Save"]
	    set maxWidth [::tk::mcmaxamp [mc "&Save"]]
	    if {$maxWidth>[$data(okBtn) cget -width]} {
		    $data(okBtn) config -width $maxWidth
		    $data(cancelBtn) config -width $maxWidth
	    }
	}
    }

    # turn off the busy cursor.
    #
    $data(ent) config -cursor $entCursor
    $w         config -cursor $dlgCursor
}

# ::tk::dialog::file::SetPathSilently --
#
# 	Sets data(selectPath) without invoking the trace procedure
#
proc ::tk::dialog::file::SetPathSilently {w path} {
    upvar ::tk::dialog::file::[winfo name $w] data
    
    trace vdelete  data(selectPath) w [list ::tk::dialog::file::SetPath $w]
    set data(selectPath) $path
    trace variable data(selectPath) w [list ::tk::dialog::file::SetPath $w]
}


# This proc gets called whenever data(selectPath) is set
#
proc ::tk::dialog::file::SetPath {w name1 name2 op} {
    if {[winfo exists $w]} {
	upvar ::tk::dialog::file::[winfo name $w] data
	::tk::dialog::file::UpdateWhenIdle $w
	# On directory dialogs, we keep the entry in sync with the currentdir.
	if { [string equal [winfo class $w] TkChooseDir] } {
	    $data(ent) delete 0 end
	    $data(ent) insert end $data(selectPath)
	}
    }
}

# This proc gets called whenever data(filter) is set
#
proc ::tk::dialog::file::SetFilter {w type} {
    upvar ::tk::dialog::file::[winfo name $w] data
    upvar ::tk::$data(icons) icons

    set data(filter) [lindex $type 1]
    $data(typeMenuBtn) config -text [lindex $type 0] -indicatoron 1

    # If we aren't using a default extension, use the one suppled
    # by the filter.
    if {![info exists data(extUsed)]} {
	if {[string length $data(-defaultextension)]} {
	    set data(extUsed) 1
	} else {
	    set data(extUsed) 0
	}
    }

    if {!$data(extUsed)} {
	# Get the first extension in the list that matches {^\*\.\w+$}
	# and remove all * from the filter.
	set index [lsearch -regexp $data(filter) {^\*\.\w+$}]
	if {$index >= 0} {
	    set data(-defaultextension) \
		    [string trimleft [lindex $data(filter) $index] "*"]
	} else {
	    # Couldn't find anything!  Reset to a safe default...
	    set data(-defaultextension) ""
	}
    }

    $icons(sbar) set 0.0 0.0
    
    ::tk::dialog::file::UpdateWhenIdle $w
}

# tk::dialog::file::ResolveFile --
#
#	Interpret the user's text input in a file selection dialog.
#	Performs:
#
#	(1) ~ substitution
#	(2) resolve all instances of . and ..
#	(3) check for non-existent files/directories
#	(4) check for chdir permissions
#
# Arguments:
#	context:  the current directory you are in
#	text:	  the text entered by the user
#	defaultext: the default extension to add to files with no extension
#
# Return vaue:
#	[list $flag $directory $file]
#
#	 flag = OK	: valid input
#	      = PATTERN	: valid directory/pattern
#	      = PATH	: the directory does not exist
#	      = FILE	: the directory exists by the file doesn't
#			  exist
#	      = CHDIR	: Cannot change to the directory
#	      = ERROR	: Invalid entry
#
#	 directory      : valid only if flag = OK or PATTERN or FILE
#	 file           : valid only if flag = OK or PATTERN
#
#	directory may not be the same as context, because text may contain
#	a subdirectory name
#
proc ::tk::dialog::file::ResolveFile {context text defaultext} {

    set appPWD [pwd]

    set path [::tk::dialog::file::JoinFile $context $text]

    # If the file has no extension, append the default.  Be careful not
    # to do this for directories, otherwise typing a dirname in the box
    # will give back "dirname.extension" instead of trying to change dir.
    if {![file isdirectory $path] && [string equal [file ext $path] ""]} {
	set path "$path$defaultext"
    }


    if {[catch {file exists $path}]} {
	# This "if" block can be safely removed if the following code
	# stop generating errors.
	#
	#	file exists ~nonsuchuser
	#
	return [list ERROR $path ""]
    }

    if {[file exists $path]} {
	if {[file isdirectory $path]} {
	    if {[catch {cd $path}]} {
		return [list CHDIR $path ""]
	    }
	    set directory [pwd]
	    set file ""
	    set flag OK
	    cd $appPWD
	} else {
	    if {[catch {cd [file dirname $path]}]} {
		return [list CHDIR [file dirname $path] ""]
	    }
	    set directory [pwd]
	    set file [file tail $path]
	    set flag OK
	    cd $appPWD
	}
    } else {
	set dirname [file dirname $path]
	if {[file exists $dirname]} {
	    if {[catch {cd $dirname}]} {
		return [list CHDIR $dirname ""]
	    }
	    set directory [pwd]
	    set file [file tail $path]
	    if {[regexp {[*]|[?]} $file]} {
		set flag PATTERN
	    } else {
		set flag FILE
	    }
	    cd $appPWD
	} else {
	    set directory $dirname
	    set file [file tail $path]
	    set flag PATH
	}
    }

    return [list $flag $directory $file]
}


# Gets called when the entry box gets keyboard focus. We clear the selection
# from the icon list . This way the user can be certain that the input in the 
# entry box is the selection.
#
proc ::tk::dialog::file::EntFocusIn {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    if {[string compare [$data(ent) get] ""]} {
	$data(ent) selection range 0 end
	$data(ent) icursor end
    } else {
	$data(ent) selection clear
    }

    if { [string equal [winfo class $w] TkFDialog] } {
	# If this is a File Dialog, make sure the buttons are labeled right.
	if {[string equal $data(type) open]} {
	    ::tk::SetAmpText $data(okBtn) [mc "&Open"]
	} else {
	    ::tk::SetAmpText $data(okBtn) [mc "&Save"]
	}
    }
}

proc ::tk::dialog::file::EntFocusOut {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    $data(ent) selection clear
}


# Gets called when user presses Return in the "File name" entry.
#
proc ::tk::dialog::file::ActivateEnt {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    set text [$data(ent) get]
    if {$data(-multiple)} {
	# For the multiple case we have to be careful to get the file
	# names as a true list, watching out for a single file with a
	# space in the name.  Thus we query the IconList directly.

	set data(selectFile) ""
	foreach item [::tk::IconList_Curselection $data(icons)] {
	    ::tk::dialog::file::VerifyFileName $w \
		    [::tk::IconList_Get $data(icons) $item]
	}
    } else {
	::tk::dialog::file::VerifyFileName $w $text
    }
}

# Verification procedure
#
proc ::tk::dialog::file::VerifyFileName {w filename} {
    upvar ::tk::dialog::file::[winfo name $w] data

    set list [::tk::dialog::file::ResolveFile $data(selectPath) $filename \
	    $data(-defaultextension)]
    foreach {flag path file} $list {
	break
    }

    switch -- $flag {
	OK {
	    if {[string equal $file ""]} {
		# user has entered an existing (sub)directory
		set data(selectPath) $path
		$data(ent) delete 0 end
	    } else {
		::tk::dialog::file::SetPathSilently $w $path
		if {$data(-multiple)} {
		    lappend data(selectFile) $file
		} else {
		    set data(selectFile) $file
		}
		::tk::dialog::file::Done $w
	    }
	}
	PATTERN {
	    set data(selectPath) $path
	    set data(filter) $file
	}
	FILE {
	    if {[string equal $data(type) open]} {
		tk_messageBox -icon warning -type ok -parent $w \
		    -message "[mc "File \"%1\$s\"  does not exist." [file join $path $file]]"
		$data(ent) selection range 0 end
		$data(ent) icursor end
	    } else {
		::tk::dialog::file::SetPathSilently $w $path
		if {$data(-multiple)} {
		    lappend data(selectFile) $file
		} else {
		    set data(selectFile) $file
		}
		::tk::dialog::file::Done $w
	    }
	}
	PATH {
	    tk_messageBox -icon warning -type ok -parent $w \
		-message "[mc "Directory \"%1\$s\" does not exist." $path]"
	    $data(ent) selection range 0 end
	    $data(ent) icursor end
	}
	CHDIR {
	    tk_messageBox -type ok -parent $w -message \
	       "[mc "Cannot change to the directory \"%1\$s\".\nPermission denied." $path]"\
		-icon warning
	    $data(ent) selection range 0 end
	    $data(ent) icursor end
	}
	ERROR {
	    tk_messageBox -type ok -parent $w -message \
	       "[mc "Invalid file name \"%1\$s\"." $path]"\
		-icon warning
	    $data(ent) selection range 0 end
	    $data(ent) icursor end
	}
    }
}

# Gets called when user presses the Alt-s or Alt-o keys.
#
proc ::tk::dialog::file::InvokeBtn {w key} {
    upvar ::tk::dialog::file::[winfo name $w] data

    if {[string equal [$data(okBtn) cget -text] $key]} {
	::tk::ButtonInvoke $data(okBtn)
    }
}

# Gets called when user presses the "parent directory" button
#
proc ::tk::dialog::file::UpDirCmd {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    if {[string compare $data(selectPath) "/"]} {
	set data(selectPath) [file dirname $data(selectPath)]
    }
}

# Join a file name to a path name. The "file join" command will break
# if the filename begins with ~
#
proc ::tk::dialog::file::JoinFile {path file} {
    if {[string match {~*} $file] && [file exists $path/$file]} {
	return [file join $path ./$file]
    } else {
	return [file join $path $file]
    }
}

# Gets called when user presses the "OK" button
#
proc ::tk::dialog::file::OkCmd {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    set filenames {}
    foreach item [::tk::IconList_Curselection $data(icons)] {
	lappend filenames [::tk::IconList_Get $data(icons) $item]
    }

    if {([llength $filenames] && !$data(-multiple)) || \
	    ($data(-multiple) && ([llength $filenames] == 1))} {
	set filename [lindex $filenames 0]
	set file [::tk::dialog::file::JoinFile $data(selectPath) $filename]
	if {[file isdirectory $file]} {
	    ::tk::dialog::file::ListInvoke $w [list $filename]
	    return
	}
    }

    ::tk::dialog::file::ActivateEnt $w
}

# Gets called when user presses the "Cancel" button
#
proc ::tk::dialog::file::CancelCmd {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    variable ::tk::Priv

    set Priv(selectFilePath) ""
}

# Gets called when user browses the IconList widget (dragging mouse, arrow
# keys, etc)
#
proc ::tk::dialog::file::ListBrowse {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    set text {}
    foreach item [::tk::IconList_Curselection $data(icons)] {
	lappend text [::tk::IconList_Get $data(icons) $item]
    }
    if {[llength $text] == 0} {
	return
    }
    if { [llength $text] > 1 } {
	set newtext {}
	foreach file $text {
	    set fullfile [::tk::dialog::file::JoinFile $data(selectPath) $file]
	    if { ![file isdirectory $fullfile] } {
		lappend newtext $file
	    }
	}
	set text $newtext
	set isDir 0
    } else {
	set text [lindex $text 0]
	set file [::tk::dialog::file::JoinFile $data(selectPath) $text]
	set isDir [file isdirectory $file]
    }
    if {!$isDir} {
	$data(ent) delete 0 end
	$data(ent) insert 0 $text

	if { [string equal [winfo class $w] TkFDialog] } {
	    if {[string equal $data(type) open]} {
		::tk::SetAmpText $data(okBtn) [mc "&Open"]
	    } else {
		::tk::SetAmpText $data(okBtn) [mc "&Save"]
	    }
	}
    } else {
	if { [string equal [winfo class $w] TkFDialog] } {
	    ::tk::SetAmpText $data(okBtn) [mc "&Open"]
	}
    }
}

# Gets called when user invokes the IconList widget (double-click, 
# Return key, etc)
#
proc ::tk::dialog::file::ListInvoke {w filenames} {
    upvar ::tk::dialog::file::[winfo name $w] data

    if {[llength $filenames] == 0} {
	return
    }

    set file [::tk::dialog::file::JoinFile $data(selectPath) \
	    [lindex $filenames 0]]
    
    set class [winfo class $w]
    if {[string equal $class TkChooseDir] || [file isdirectory $file]} {
	set appPWD [pwd]
	if {[catch {cd $file}]} {
	    tk_messageBox -type ok -parent $w -message \
	       "[mc "Cannot change to the directory \"%1\$s\".\nPermission denied." $file]"\
		-icon warning
	} else {
	    cd $appPWD
	    set data(selectPath) $file
	}
    } else {
	if {$data(-multiple)} {
	    set data(selectFile) $filenames
	} else {
	    set data(selectFile) $file
	}
	::tk::dialog::file::Done $w
    }
}

# ::tk::dialog::file::Done --
#
#	Gets called when user has input a valid filename.  Pops up a
#	dialog box to confirm selection when necessary. Sets the
#	tk::Priv(selectFilePath) variable, which will break the "vwait"
#	loop in ::tk::dialog::file:: and return the selected filename to the
#	script that calls tk_getOpenFile or tk_getSaveFile
#
proc ::tk::dialog::file::Done {w {selectFilePath ""}} {
    upvar ::tk::dialog::file::[winfo name $w] data
    variable ::tk::Priv

    if {[string equal $selectFilePath ""]} {
	if {$data(-multiple)} {
	    set selectFilePath {}
	    foreach f $data(selectFile) {
		lappend selectFilePath [::tk::dialog::file::JoinFile \
		    $data(selectPath) $f]
	    }
	} else {
	    set selectFilePath [::tk::dialog::file::JoinFile \
		    $data(selectPath) $data(selectFile)]
	}
	
	set Priv(selectFile)     $data(selectFile)
	set Priv(selectPath)     $data(selectPath)

	if {[string equal $data(type) save]} {
	    if {[file exists $selectFilePath]} {
	    set reply [tk_messageBox -icon warning -type yesno\
		    -parent $w -message \
			"[mc "File \"%1\$s\" already exists.\nDo you want to overwrite it?" $selectFilePath]"]
	    if {[string equal $reply "no"]} {
		return
		}
	    }
	}
    }
    set Priv(selectFilePath) $selectFilePath
}
@


1.4
log
@touched all sources to ease next import
@
text
@d10 1
a10 1
#	selectinf the "Directory" option menu. The user can select
d14 1
a14 1
# RCS: @@(#) $Id: tkfbox.tcl,v 1.11.6.2 2000/09/26 16:08:50 spolk Exp $
d27 1
a27 1
# tkFDialog dialog box.
d31 1
a31 1
# tkIconList --
d35 145
a179 2
proc tkIconList {w args} {
    upvar #0 $w data
d181 8
a188 2
    tkIconList_Config $w $args
    tkIconList_Create $w
d191 1
a191 1
# tkIconList_Config --
d196 1
a196 2
proc tkIconList_Config {w argList} {
    upvar #0 $w data
a200 1
	{-browsecmd "" "" ""}
d202 1
d207 1
a207 1
    tclParseConfigSpec $w $specs "" $argList
d210 1
a210 1
# tkIconList_Create --
d216 2
a217 2
proc tkIconList_Create {w} {
    upvar #0 $w data
d239 2
d244 1
a244 1
    bind $data(canvas) <Configure>	[list tkIconList_Arrange $w]
d246 7
a252 5
    bind $data(canvas) <1>		[list tkIconList_Btn1 $w %x %y]
    bind $data(canvas) <B1-Motion>	[list tkIconList_Motion1 $w %x %y]
    bind $data(canvas) <B1-Leave>	[list tkIconList_Leave1 $w %x %y]
    bind $data(canvas) <B1-Enter>	[list tkCancelRepeat]
    bind $data(canvas) <ButtonRelease-1> [list tkCancelRepeat]
d254 1
a254 1
	    [list tkIconList_Double1 $w %x %y]
d256 6
a261 6
    bind $data(canvas) <Up>		[list tkIconList_UpDown $w -1]
    bind $data(canvas) <Down>		[list tkIconList_UpDown $w  1]
    bind $data(canvas) <Left>		[list tkIconList_LeftRight $w -1]
    bind $data(canvas) <Right>		[list tkIconList_LeftRight $w  1]
    bind $data(canvas) <Return>		[list tkIconList_ReturnKey $w]
    bind $data(canvas) <KeyPress>	[list tkIconList_KeyPress $w %A]
d265 2
a266 1
    bind $data(canvas) <FocusIn>	[list tkIconList_FocusIn $w]
d271 1
a271 1
# tkIconList_AutoScan --
d282 3
a284 3
proc tkIconList_AutoScan {w} {
    upvar #0 $w data
    global tkPriv
d287 2
a288 2
    set x $tkPriv(x)
    set y $tkPriv(y)
d305 2
a306 2
    tkIconList_Motion1 $w $x $y
    set tkPriv(afterId) [after 50 [list tkIconList_AutoScan $w]]
d312 3
a314 3
proc tkIconList_DeleteAll {w} {
    upvar #0 $w data
    upvar #0 $w:itemList itemList
d328 2
d336 25
a360 9
proc tkIconList_Add {w image text} {
    upvar #0 $w data
    upvar #0 $w:itemList itemList
    upvar #0 $w:textList textList

    set iTag [$data(canvas) create image 0 0 -image $image -anchor nw]
    set tTag [$data(canvas) create text  0 0 -text  $text  -anchor nw \
	-font $data(font)]
    set rTag [$data(canvas) create rect  0 0 0 0 -fill "" -outline ""]
d362 11
a372 9
    set b [$data(canvas) bbox $iTag]
    set iW [expr {[lindex $b 2]-[lindex $b 0]}]
    set iH [expr {[lindex $b 3]-[lindex $b 1]}]
    if {$data(maxIW) < $iW} {
	set data(maxIW) $iW
    }
    if {$data(maxIH) < $iH} {
	set data(maxIH) $iH
    }
d374 5
a378 8
    set b [$data(canvas) bbox $tTag]
    set tW [expr {[lindex $b 2]-[lindex $b 0]}]
    set tH [expr {[lindex $b 3]-[lindex $b 1]}]
    if {$data(maxTW) < $tW} {
	set data(maxTW) $tW
    }
    if {$data(maxTH) < $tH} {
	set data(maxTH) $tH
a379 5
    
    lappend data(list) [list $iTag $tTag $rTag $iW $iH $tW $tH $data(numItems)]
    set itemList($rTag) [list $iTag $tTag $text $data(numItems)]
    set textList($data(numItems)) [string tolower $text]
    incr data(numItems)
d384 2
a385 2
proc tkIconList_Arrange {w} {
    upvar #0 $w data
d420 3
a422 7
	set iTag [lindex $sublist 0]
	set tTag [lindex $sublist 1]
	set rTag [lindex $sublist 2]
	set iW   [lindex $sublist 3]
	set iH   [lindex $sublist 4]
	set tW   [lindex $sublist 5]
	set tH   [lindex $sublist 6]
a428 1
	$data(canvas) coords $tTag [expr {$x + $shift}]  [expr {$y + $t_dy}]
d462 1
a462 1
	tkIconList_Select $w [lindex [lindex $data(list) $data(curItem)] 2] 0
d469 2
a470 2
proc tkIconList_Invoke {w} {
    upvar #0 $w data
d472 1
a472 1
    if {$data(-command) != "" && [info exists data(selected)]} {
d477 1
a477 1
# tkIconList_See --
d481 3
a483 3
proc tkIconList_See {w rTag} {
    upvar #0 $w data
    upvar #0 $w:itemList itemList
d493 1
a493 1
    if {![info exists itemList($rTag)]} {
d497 1
a497 2

    set bbox [$data(canvas) bbox $rTag]
d529 2
a530 2
proc tkIconList_SelectAtXY {w x y} {
    upvar #0 $w data
d532 8
a539 2
    tkIconList_Select $w [$data(canvas) find closest \
	    [$data(canvas) canvasx $x] [$data(canvas) canvasy $y]]
d542 15
a556 25
proc tkIconList_Select {w rTag {callBrowse 1}} {
    upvar #0 $w data
    upvar #0 $w:itemList itemList

    if {![info exists itemList($rTag)]} {
	return
    }
    set iTag   [lindex $itemList($rTag) 0]
    set tTag   [lindex $itemList($rTag) 1]
    set text   [lindex $itemList($rTag) 2]
    set serial [lindex $itemList($rTag) 3]

    if {![info exists data(rect)]} {
        set data(rect) [$data(canvas) create rect 0 0 0 0 \
		-fill #a0a0ff -outline #a0a0ff]
    }
    $data(canvas) lower $data(rect)
    set bbox [$data(canvas) bbox $tTag]
    eval [list $data(canvas) coords $data(rect)] $bbox

    set data(curItem) $serial
    set data(selected) $text

    if {$callBrowse && $data(-browsecmd) != ""} {
	eval $data(-browsecmd) [list $text]
d560 15
a574 6
proc tkIconList_Unselect {w} {
    upvar #0 $w data

    if {[info exists data(rect)]} {
	$data(canvas) delete $data(rect)
	unset data(rect)
a575 24
    if {[info exists data(selected)]} {
	unset data(selected)
    }
    #set data(curItem)  {}
}

# Returns the selected item
#
proc tkIconList_Get {w} {
    upvar #0 $w data

    if {[info exists data(selected)]} {
	return $data(selected)
    } else {
	return ""
    }
}


proc tkIconList_Btn1 {w x y} {
    upvar #0 $w data

    focus $data(canvas)
    tkIconList_SelectAtXY $w $x $y
d580 11
a590 6
proc tkIconList_Motion1 {w x y} {
    global tkPriv
    set tkPriv(x) $x
    set tkPriv(y) $y

    tkIconList_SelectAtXY $w $x $y
d593 2
a594 2
proc tkIconList_Double1 {w x y} {
    upvar #0 $w data
d596 2
a597 2
    if {[string compare $data(curItem) {}]} {
	tkIconList_Invoke $w
d601 2
a602 2
proc tkIconList_ReturnKey {w} {
    tkIconList_Invoke $w
d605 2
a606 2
proc tkIconList_Leave1 {w x y} {
    global tkPriv
d608 3
a610 3
    set tkPriv(x) $x
    set tkPriv(y) $y
    tkIconList_AutoScan $w
d613 2
a614 2
proc tkIconList_FocusIn {w} {
    upvar #0 $w data
d620 2
a621 2
    if {[string compare $data(curItem) {}]} {
	tkIconList_Select $w [lindex [lindex $data(list) $data(curItem)] 2] 1
d625 5
a629 1
# tkIconList_UpDown --
d637 2
a638 2
proc tkIconList_UpDown {w amount} {
    upvar #0 $w data
d644 3
a646 2
    if {[string equal $data(curItem) {}]} {
	set rTag [lindex [lindex $data(list) 0] 2]
d648 3
a650 10
	set oldRTag [lindex [lindex $data(list) $data(curItem)] 2]
	set rTag [lindex [lindex $data(list) [expr {$data(curItem)+$amount}]] 2]
	if {[string equal $rTag ""]} {
	    set rTag $oldRTag
	}
    }

    if {[string compare $rTag ""]} {
	tkIconList_Select $w $rTag
	tkIconList_See $w $rTag
d652 4
d658 1
a658 1
# tkIconList_LeftRight --
d666 2
a667 2
proc tkIconList_LeftRight {w amount} {
    upvar #0 $w data
d672 4
a675 2
    if {[string equal $data(curItem) {}]} {
	set rTag [lindex [lindex $data(list) 0] 2]
d677 8
a684 12
	set oldRTag [lindex [lindex $data(list) $data(curItem)] 2]
	set newItem [expr {$data(curItem)+($amount*$data(itemsPerColumn))}]
	set rTag [lindex [lindex $data(list) $newItem] 2]
	if {[string equal $rTag ""]} {
	    set rTag $oldRTag
	}
    }

    if {[string compare $rTag ""]} {
	tkIconList_Select $w $rTag
	tkIconList_See $w $rTag
    }
d691 1
a691 1
# tkIconList_KeyPress --
d695 2
a696 2
proc tkIconList_KeyPress {w key} {
    global tkPriv
d698 2
a699 2
    append tkPriv(ILAccel,$w) $key
    tkIconList_Goto $w $tkPriv(ILAccel,$w)
d701 1
a701 1
	after cancel $tkPriv(ILAccel,$w,afterId)
d703 1
a703 1
    set tkPriv(ILAccel,$w,afterId) [after 500 [list tkIconList_Reset $w]]
d706 3
a708 4
proc tkIconList_Goto {w text} {
    upvar #0 $w data
    upvar #0 $w:textList textList
    global tkPriv
d749 4
a752 3
	set rTag [lindex [lindex $data(list) $theIndex] 2]
	tkIconList_Select $w $rTag
	tkIconList_See $w $rTag
d756 2
a757 2
proc tkIconList_Reset {w} {
    global tkPriv
d759 1
a759 1
    catch {unset tkPriv(ILAccel,$w)}
d769 3
a771 1
namespace eval ::tk::dialog::file {}
d773 1
a773 1
# ::tk::dialog::file::tkFDialog --
d784 2
a785 2
proc ::tk::dialog::file::tkFDialog {type args} {
    global tkPriv
d815 12
a827 1
    wm transient $w $data(-parent)
d877 1
a877 1
    tkwait variable tkPriv(selectFilePath)
d889 1
a889 1
    return $tkPriv(selectFilePath)
d920 6
d940 1
a940 1
	    set data(-title) "Open"
d942 1
a942 1
	    set data(-title) "Save As"
d964 1
a964 1
    set data(-filetypes) [tkFDGetFileTypes $data(-filetypes)]
d969 10
d984 2
a985 1
    global tk_library tkPriv
d992 3
a994 1
    label $f1.lab -text "Directory:" -under 0
d998 2
a999 2
    if {![info exists tkPriv(updirImage)]} {
	set tkPriv(updirImage) [image create bitmap -data {
d1010 1
a1010 1
    $data(upBtn) config -image $tkPriv(updirImage)
d1021 8
a1028 2
	set fNameCaption "File name:"
	set fNameUnder 5
d1031 2
a1032 2
	set fNameCaption "Selection:"
	set fNameUnder 0
d1035 5
a1039 3
    set data(icons) [tkIconList $w.icons \
	-browsecmd [list ::tk::dialog::file::ListBrowse $w] \
	-command   $iconListCommand]
d1044 2
a1045 2
    label $f2.lab -text $fNameCaption -anchor e -width 14 \
	    -under $fNameUnder -pady 0
d1050 1
a1050 2
    global $w.icons
    set $w.icons(font) [$data(ent) cget -font]
d1064 2
a1065 2
	set data(typeMenuLab) [button $f3.lab -text "Files of type:" \
		-anchor e -width 14 -under 9 \
a1072 1
	
d1078 2
d1084 6
a1089 4
    set data(okBtn)     [button $f2.ok     -text OK     -under 0 -width 6 \
	-default active -pady 3]
    set data(cancelBtn) [button $f3.cancel -text Cancel -under 0 -width 6\
	-default normal -pady 3]
d1116 2
a1117 4
    bind $w <KeyPress-Escape> [list tkButtonInvoke $data(cancelBtn)]
    bind $w <Alt-c> [list tkButtonInvoke $data(cancelBtn)]
    bind $w <Alt-d> [list focus $data(dirMenuBtn)]

a1128 3
	bind $w <Alt-n> [list focus $data(ent)]
	bind $w <Alt-o> [list ::tk::dialog::file::InvokeBtn $w Open]
	bind $w <Alt-s> [list ::tk::dialog::file::InvokeBtn $w Save]
d1134 1
a1134 1
	bind $w <Alt-o> [list tkButtonInvoke $data(okBtn)]
d1139 29
a1167 3
    tkFocusGroup_Create $w
    tkFocusGroup_BindIn $w  $data(ent) [list ::tk::dialog::file::EntFocusIn $w]
    tkFocusGroup_BindOut $w $data(ent) [list ::tk::dialog::file::EntFocusOut $w]
d1208 2
a1209 1
    global tk_library tkPriv
d1212 2
a1213 2
    if {![info exists tkPriv(folderImage)]} {
	set tkPriv(folderImage) [image create photo -data {
d1216 1
a1216 1
	set tkPriv(fileImage)   [image create photo -data {
d1220 2
a1221 2
    set folder $tkPriv(folderImage)
    set file   $tkPriv(fileImage)
d1232 1
a1232 1
	    "Cannot change to the directory \"$data(selectPath)\".\nPermission denied."\
d1247 1
a1247 1
    tkIconList_DeleteAll $data(icons)
d1251 3
a1253 1
    foreach f [lsort -dictionary [glob -nocomplain .* *]] {
d1261 1
a1261 4
	    if {![info exists hasDoneDir($f)]} {
		tkIconList_Add $data(icons) $folder $f
		set hasDoneDir($f) 1
	    }
d1264 1
d1269 1
a1269 2
	    set files [lsort -dictionary \
		    [glob -nocomplain .* *]]
d1271 9
a1279 2
	    set files [lsort -dictionary \
		    [eval glob -nocomplain $data(filter)]]
d1281 1
a1281 1
	
d1284 1
a1284 4
		if {![info exists hasDoneFile($f)]} {
		    tkIconList_Add $data(icons) $file $f
		    set hasDoneFile($f) 1
		}
d1287 1
d1290 1
a1290 1
    tkIconList_Arrange $data(icons)
d1315 6
a1320 1
	    $data(okBtn) config -text "Open"
d1322 6
a1327 1
	    $data(okBtn) config -text "Save"
d1368 1
a1368 1
    upvar \#0 $data(icons) icons
d1373 23
a1512 2
    tkIconList_Unselect $data(icons)

d1516 1
a1516 1
	    $data(okBtn) config -text "Open"
d1518 1
a1518 1
	    $data(okBtn) config -text "Save"
d1535 26
a1560 6
    set text [string trim [$data(ent) get]]
    set list [::tk::dialog::file::ResolveFile $data(selectPath) $text \
		  $data(-defaultextension)]
    set flag [lindex $list 0]
    set path [lindex $list 1]
    set file [lindex $list 2]
d1570 5
a1574 1
		set data(selectFile) $file
d1585 1
a1585 1
		    -message "File \"[file join $path $file]\" does not exist."
d1590 5
a1594 1
		set data(selectFile) $file
d1600 1
a1600 1
		-message "Directory \"$path\" does not exist."
d1606 1
a1606 1
	       "Cannot change to the directory \"$path\".\nPermission denied."\
d1613 1
a1613 1
	       "Invalid file name \"$path\"."\
d1627 1
a1627 1
	tkButtonInvoke $data(okBtn)
a1651 2


d1657 9
a1665 3
    set text [tkIconList_Get $data(icons)]
    if {[string compare $text ""]} {
	set file [::tk::dialog::file::JoinFile $data(selectPath) $text]
d1667 1
a1667 1
	    ::tk::dialog::file::ListInvoke $w $text
d1679 1
a1679 1
    global tkPriv
d1681 1
a1681 1
    set tkPriv(selectFilePath) ""
d1687 1
a1687 1
proc ::tk::dialog::file::ListBrowse {w text} {
d1690 5
a1694 1
    if {[string equal $text ""]} {
d1697 16
a1712 3

    set file [::tk::dialog::file::JoinFile $data(selectPath) $text]
    if {![file isdirectory $file]} {
d1718 1
a1718 1
		$data(okBtn) config -text "Open"
d1720 1
a1720 1
		$data(okBtn) config -text "Save"
d1725 1
a1725 1
	    $data(okBtn) config -text "Open"
d1733 1
a1733 1
proc ::tk::dialog::file::ListInvoke {w text} {
d1736 1
a1736 1
    if {[string equal $text ""]} {
d1740 3
a1742 1
    set file [::tk::dialog::file::JoinFile $data(selectPath) $text]
d1748 1
a1748 1
	       "Cannot change to the directory \"$file\".\nPermission denied."\
d1755 5
a1759 1
	set data(selectFile) $file
d1768 2
a1769 2
#	tkPriv(selectFilePath) variable, which will break the "tkwait"
#	loop in tkFDialog and return the selected filename to the
d1774 1
a1774 1
    global tkPriv
d1777 13
a1789 4
	set selectFilePath [::tk::dialog::file::JoinFile $data(selectPath) \
		$data(selectFile)]
	set tkPriv(selectFile)     $data(selectFile)
	set tkPriv(selectPath)     $data(selectPath)
d1791 2
a1792 1
	if {[file exists $selectFilePath] && [string equal $data(type) save]} {
d1794 2
a1795 3
		    -parent $w -message "File\
		    \"$selectFilePath\" already exists.\nDo\
		    you want to overwrite it?"]
d1798 1
d1802 1
a1802 1
    set tkPriv(selectFilePath) $selectFilePath
a1803 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d14 1
a14 1
# SCCS: @@(#) tkfbox.tcl 1.13 97/10/01 14:51:01
d16 1
a16 1
# Copyright (c) 1994-1996 Sun Microsystems, Inc.
a54 1
	{-multiple "" "" "0"}
d79 2
a80 2
    $data(sbar) config -command "$data(canvas) xview"
    $data(canvas) config -xscrollcommand "$data(sbar) set"
d94 1
a94 1
    bind $data(canvas) <Configure> "tkIconList_Arrange $w"
d96 14
a109 14
    bind $data(canvas) <1>         "tkIconList_Btn1 $w %x %y"
    bind $data(canvas) <B1-Motion> "tkIconList_Motion1 $w %x %y"
    bind $data(canvas) <Shift-1>   "tkIconList_ShiftBtn1 $w %x %y"
    bind $data(canvas) <Double-1>  "tkIconList_Double1 $w %x %y"
    bind $data(canvas) <ButtonRelease-1> "tkCancelRepeat"
    bind $data(canvas) <B1-Leave>  "tkIconList_Leave1 $w %x %y"
    bind $data(canvas) <B1-Enter>  "tkCancelRepeat"

    bind $data(canvas) <Up>        "tkIconList_UpDown $w -1"
    bind $data(canvas) <Down>      "tkIconList_UpDown $w  1"
    bind $data(canvas) <Left>      "tkIconList_LeftRight $w -1"
    bind $data(canvas) <Right>     "tkIconList_LeftRight $w  1"
    bind $data(canvas) <Return>    "tkIconList_ReturnKey $w"
    bind $data(canvas) <KeyPress>  "tkIconList_KeyPress $w %A"
d111 1
a111 1
    bind $data(canvas) <Alt-KeyPress>  ";"
d113 1
a113 1
    bind $data(canvas) <FocusIn>   "tkIconList_FocusIn $w"
d153 1
a153 1
    set tkPriv(afterId) [after 50 tkIconList_AutoScan $w]
d286 1
a286 1
	$data(canvas) config -scrollregion "$pad $pad $sW $H"
d291 2
a292 2
	$data(canvas) config -scrollregion "$pad $pad $sW $H"
	$data(sbar) config -command "$data(canvas) xview"
d301 1
a301 1
    if {$data(curItem) != {}} {
d312 2
a313 2
    if {[string compare $data(-command) ""] && [info exists data(selected)]} {
	eval $data(-command) [list $data(selected)]
d329 1
a329 1
    if {![string compare $sRegion {}]} {
d374 1
a374 13
	[$data(canvas) canvasx $x] [$data(canvas) canvasy $y]]
}

proc tkIconList_AddSelectAtXY {w x y {no_delete 0}} {
    upvar #0 $w data

    if {$data(-multiple) && [info exists data(selected)]} {
	tkIconList_AddSelect $w [$data(canvas) find closest \
		[$data(canvas) canvasx $x] [$data(canvas) canvasy $y]] \
		1 $no_delete
	return
    }
    tkIconList_SelectAtXY $w $x $y
d389 1
a389 8
    if {$data(-multiple) && [info exists data(rect)]} {
	foreach r $data(rect) {
	    $data(canvas) delete $r
	}
	unset data(rect)
    }
    if ![info exists data(rect)] {

d391 1
a391 1
	    -fill #a0a0ff -outline #a0a0ff]
d395 1
a395 1
    eval $data(canvas) coords $data(rect) $bbox
d398 1
a398 69
    
    #we can't set the text to data(selected) as text, this is bugy,
    #when the path contains blanks
    if {$data(-multiple)} {
	catch {unset data(selected)}
	lappend data(selected) $text
    } else {
    	set data(selected) $text
    }
    
    if {$callBrowse} {
	if [string compare $data(-browsecmd) ""] {
	    eval $data(-browsecmd) [list $data(selected)]
	}
    }
}

proc tkIconList_AddSelect {w rTag {callBrowse 1} {no_delete 0}} {
    upvar #0 $w data
    upvar #0 $w:itemList itemList

    if ![info exists itemList($rTag)] {
	return
    }
    set iTag   [lindex $itemList($rTag) 0]
    set tTag   [lindex $itemList($rTag) 1]
    set text   [lindex $itemList($rTag) 2]
    set serial [lindex $itemList($rTag) 3]

    if {[lsearch -exact $data(selected) $text] != -1} {
	if {$no_delete} {
	    return
	}
	 
	# we've clicked on an existing item, so we need to remove it
	set i [lsearch -exact $data(selected) $text]
	set data(selected) [lreplace $data(selected) $i $i]
	
	# find the appropriate coordinates and remove the
	# corresponding rectangle.
	set tmpbbox [$data(canvas) bbox $tTag]
	for {set i 0} {$i<[llength $data(rect)]} {incr i} {
	    set rectTag [lindex $data(rect) $i]
	    set testbbox [$data(canvas) coords $rectTag]
	    # test first two coordinates; if they're the same the
	    # entire box should match
	    if {[lindex $testbbox 0]==[lindex $tmpbbox 0] && \
		    [lindex $testbbox 1]==[lindex $tmpbbox 1]} {
		$data(canvas) delete $rectTag
		set data(rect) [lreplace $data(rect) $i $i]
		break
	    }
	}

	if {$callBrowse} {
	    if [string compare $data(-browsecmd) ""] {
		eval $data(-browsecmd) [list $data(selected)]
	    }
	}
	return
    }

    set tmprect [$data(canvas) create rect 0 0 0 0 \
	    -fill #a0a0ff -outline #a0a0ff]
    lappend data(rect) $tmprect

    $data(canvas) lower $tmprect
    set bbox [$data(canvas) bbox $tTag]
    eval $data(canvas) coords $tmprect $bbox
d400 2
a401 7
    set data(curItem) $serial
    lappend data(selected) $text
    
    if {$callBrowse} {
	if [string compare $data(-browsecmd) ""] {
	    eval $data(-browsecmd) [list $data(selected)]
	}
d408 2
a409 4
    if [info exists data(rect)] {
	foreach r $data(rect) {
	    $data(canvas) delete $r
	}
d415 1
a415 1
    set data(curItem)  {}
a437 7
proc tkIconList_ShiftBtn1 {w x y} {
    upvar #0 $w data

    focus $data(canvas)
    tkIconList_AddSelectAtXY $w $x $y
}

d445 1
a445 1
    tkIconList_AddSelectAtXY $w $x $y 1
d451 1
a451 1
    if {$data(curItem) != {}} {
d475 2
a476 3
    if {$data(curItem) == {}} {
	set rTag [lindex [lindex $data(list) 0] 2]
	tkIconList_Select $w $rTag
d495 1
a495 1
    if {$data(curItem) == {}} {
d500 1
a500 1
	if {![string compare $rTag ""]} {
d525 1
a525 1
    if {$data(curItem) == {}} {
d531 1
a531 1
	if {![string compare $rTag ""]} {
d558 1
a558 1
    set tkPriv(ILAccel,$w,afterId) [after 500 tkIconList_Reset $w]
d570 1
a570 1
    if {[string length $text] == 0} {
d574 1
a574 1
    if {$data(curItem) == {} || $data(curItem) == 0} {
d589 1
a589 1
    while 1 {
d591 1
a591 1
	if {[string compare $text $sub] == 0} {
d606 1
a606 1
	tkIconList_Select $w $rTag 0
d623 4
a626 1
# tkFDialog --
d632 6
a637 1
proc tkFDialog {args} {
d639 2
a640 10
    global __old_dialog
    global __old_multiple
    set w __tk_filedialog
    upvar #0 $w data

    if {![string compare [lindex [info level 0] 0] tk_getOpenFile]} {
	set type open
    } else {
	set type save
    }
d642 1
a642 1
    tkFDialog_Config $w $type $args
d644 2
a645 2
    if {![string compare $data(-parent) .]} {
        set w .$w
d647 1
a647 10
        set w $data(-parent).$w
    }

    #because tk doesn't use window-path dependent array, it is
    #impossible to use more than one dialog box at the same time,
    #so we have to recreate the dialog!
    if {[info exists __old_dialog] \
	&& ($__old_dialog != $w || $__old_multiple != $data(-multiple))} {
    	catch {destroy $w}
	catch {destroy $__old_dialog}
a648 2
    set __old_dialog $w
    set __old_multiple $data(-multiple)
a651 1
    set new_dialog 0
d653 1
a653 2
	tkFDialog_Create $w
	set new_dialog 1
d656 1
a656 2
	tkFDialog_Create $w
	set new_dialog 1
a669 2
    #trace variable
    trace variable data(selectPath) w "tkFDialog_SetPath $w"
d671 8
a678 1
    # 5. Initialize the file types menu
d680 1
a680 1
    if {$data(-filetypes) != {}} {
d686 1
a686 1
		-command [list tkFDialog_SetFilter $w $type]
d688 1
a688 1
	tkFDialog_SetFilter $w [lindex $data(-filetypes) 0]
d696 1
d698 1
a698 3
    tkFDialog_UpdateWhenIdle $w

    # 6. Withdraw the window, then update all the geometry information
d702 1
a702 10
    if {$new_dialog} {
    	#center dialog, when it has been new created
	wm withdraw $w
	update idletasks
	set x [expr {[winfo screenwidth $w]/2 - [winfo reqwidth $w]/2 \
		       - [winfo vrootx [winfo parent $w]]}]
	set y [expr {[winfo screenheight $w]/2 - [winfo reqheight $w]/2 \
	    - [winfo vrooty [winfo parent $w]]}]
	wm geom $w [winfo reqwidth $w]x[winfo reqheight $w]+$x+$y
    }
a703 1
    wm deiconify $w
d705 1
a705 1
    # 7. Set a grab and claim the focus too.
d707 1
a707 7
    set oldFocus [focus]
    set oldGrab [grab current $w]
    if {$oldGrab != ""} {
	set grabStatus [grab status $oldGrab]
    }
    grab $w
    focus $data(ent)
d710 1
a710 2
    $data(ent) select from 0
    $data(ent) select to   end
d713 1
a713 1
    # 8. Wait for the user to respond, then restore the focus and
d720 8
a727 9
    catch {focus $oldFocus}
    grab release $w
    wm withdraw $w
    if {$oldGrab != ""} {
	if {$grabStatus == "global"} {
	    grab -global $oldGrab
	} else {
	    grab $oldGrab
	}
d729 2
a730 3
    #delete the tracer, because this conflicts with multiple
    #used dialogs
    trace vdelete data(selectPath) w "tkFDialog_SetPath $w"
d734 1
a734 1
# tkFDialog_Config --
d738 2
a739 2
proc tkFDialog_Config {w type argList} {
    upvar #0 $w data
d743 8
a760 9
    if ![string compare $type open] {
        # CYGNUS LOCAL: Handle -choosedir.
        # Note: the -choosedir option is a Cygnus extension.  It is not
        # documented since it only works on Unix -- it is an
        # implementation detail of the directory-choosing code in
        # in libgui.
	lappend specs {-multiple "" "" "0"} {-choosedir "" "" "0"}
	# END CYGNUS LOCAL
    }
d772 1
a772 1
    tclParseConfigSpec $w $specs "" $argList
d774 2
a775 2
    if {![string compare $data(-title) ""]} {
	if {![string compare $type "open"]} {
d785 7
a791 8
    # Khamis 16-04-98
    # When the path contains blanks, glob returns an item in a list, but
    # data(selectPath) must be an item and not a list of items, so we
    # must extract the item from the returned list.
    if {[string compare $data(-initialdir) ""]} {
        if {[file isdirectory $data(-initialdir)]} {
	    #khamis: Join result of glob to an item
	    set data(selectPath) [lindex [glob $data(-initialdir)] 0]
a794 7

	# Convert the initialdir to an absolute path name.

	set old [pwd]
	cd $data(selectPath)
	set data(selectPath) [pwd]
	cd $old
a804 14

    # Set -multiple to a one or zero value (not other boolean types
    # like "yes") so we can use it in tests easier.
    if {![string compare $type save]} {
	set data(-multiple) 0
        # CYGNUS LOCAL: choosedir
        # Handle -choosedir here as well.
        set data(-choosedir) 0
        # END CYGNUS LOCAL
    } else {
	if {$data(-multiple)} { 
	    set data(-multiple) 1 
	}
    }
d807 1
a807 1
proc tkFDialog_Create {w} {
d809 2
a810 2
    upvar #0 $dataName data
    global tk_library
d812 1
a812 1
    toplevel $w -class TkFDialog
d819 1
a819 1
    set data(dirMenu) [tk_optionMenu $f1.menu [format %s(selectPath) $dataName] ""]
d843 9
d853 2
a854 3
	-browsecmd "tkFDialog_ListBrowse $w" \
	-command   "tkFDialog_ListInvoke $w" \
	-multiple  "$data(-multiple)"]
d859 2
a860 4
    label $f2.lab -text "File name:" -anchor e -width 14 -under 5 -pady 0
    if {$data(-multiple)} {
	$f2.lab config -text "File names:"
    }
d872 24
a895 20
    # The "File of types:" label needs to be grayed-out when
    # -filetypes are not specified. The label widget does not support
    # grayed-out text on monochrome displays. Therefore, we have to
    # use a button widget to emulate a label widget (by setting its
    # bindtags)

    set data(typeMenuLab) [button $f3.lab -text "Files of type:" \
	-anchor e -width 14 -under 9 \
	-bd [$f2.lab cget -bd] \
	-highlightthickness [$f2.lab cget -highlightthickness] \
	-relief [$f2.lab cget -relief] \
	-padx [$f2.lab cget -padx] \
	-pady [$f2.lab cget -pady]]
    bindtags $data(typeMenuLab) [list $data(typeMenuLab) Label \
	    [winfo toplevel $data(typeMenuLab)] all]

    set data(typeMenuBtn) [menubutton $f3.menu -indicatoron 1 -menu $f3.menu.m]
    set data(typeMenu) [menu $data(typeMenuBtn).m -tearoff 0]
    $data(typeMenuBtn) config -takefocus 1 -highlightthickness 2 \
	-relief raised -bd 2 -anchor w
d911 4
a914 2
    pack $data(typeMenuLab) -side left -padx 4
    pack $data(typeMenuBtn) -expand yes -fill x -side right
d923 11
a933 1
    # Set up the event handlers
a934 19
    bind $data(ent) <Return>  "tkFDialog_ActivateEnt $w"
    
    $data(upBtn)     config -command "tkFDialog_UpDirCmd $w"
    $data(okBtn)     config -command "tkFDialog_OkCmd $w"
    $data(cancelBtn) config -command "tkFDialog_CancelCmd $w"

    #trace variable data(selectPath) w "tkFDialog_SetPath $w"

    bind $w <Alt-d> "focus $data(dirMenuBtn)"
    bind $w <Alt-t> [format {
	if {"[%s cget -state]" == "normal"} {
	    focus %s
	}
    } $data(typeMenuBtn) $data(typeMenuBtn)]
    bind $w <Alt-n> "focus $data(ent)"
    bind $w <KeyPress-Escape> "tkButtonInvoke $data(cancelBtn)"
    bind $w <Alt-c> "tkButtonInvoke $data(cancelBtn)"
    bind $w <Alt-o> "tkFDialog_InvokeBtn $w Open"
    bind $w <Alt-s> "tkFDialog_InvokeBtn $w Save"
d936 18
a953 1
    wm protocol $w WM_DELETE_WINDOW "tkFDialog_CancelCmd $w"
d958 2
a959 2
    tkFocusGroup_BindIn $w  $data(ent) "tkFDialog_EntFocusIn $w"
    tkFocusGroup_BindOut $w $data(ent) "tkFDialog_EntFocusOut $w"
d962 1
a962 1
# tkFDialog_UpdateWhenIdle --
d969 2
a970 2
proc tkFDialog_UpdateWhenIdle {w} {
    upvar #0 [winfo name $w] data
d975 1
a975 1
	set data(updateId) [after idle tkFDialog_Update $w]
d979 1
a979 1
# tkFDialog_Update --
d985 1
a985 1
proc tkFDialog_Update {w} {
d989 6
a994 1
    if {![winfo exists $w] || [string compare [winfo class $w] TkFDialog]} {
d999 1
a999 1
    upvar #0 $dataName data
d1019 1
a1019 1
	# should have been checked before tkFDialog_Update is called, so
d1022 1
a1022 1
	tk_messageBox -type ok -parent $data(-parent) -message \
d1043 1
a1043 1
	if {![string compare $f .]} {
d1046 1
a1046 1
	if {![string compare $f ..]} {
d1056 17
a1072 16
    # Make the file list
    #
    if {![string compare $data(filter) *]} {
	set files [lsort -dictionary \
	    [glob -nocomplain .* *]]
    } else {
	set files [lsort -dictionary \
	    [eval glob -nocomplain $data(filter)]]
    }

    set top 0
    foreach f $files {
	if {![file isdir ./$f]} {
	    if {![info exists hasDoneFile($f)]} {
		tkIconList_Add $data(icons) $file $f
		set hasDoneFile($f) 1
d1089 1
a1089 1
    set var [format %s(selectPath) $dataName]
d1098 10
d1114 1
a1114 1
# tkFDialog_SetPathSilently --
d1118 2
a1119 2
proc tkFDialog_SetPathSilently {w path} {
    upvar #0 [winfo name $w] data
d1121 1
a1121 1
    trace vdelete  data(selectPath) w "tkFDialog_SetPath $w"
d1123 1
a1123 1
    trace variable data(selectPath) w "tkFDialog_SetPath $w"
d1129 1
a1129 1
proc tkFDialog_SetPath {w name1 name2 op} {
d1131 7
a1137 2
	upvar #0 [winfo name $w] data
	tkFDialog_UpdateWhenIdle $w
d1143 2
a1144 2
proc tkFDialog_SetFilter {w type} {
    upvar #0 [winfo name $w] data
d1152 1
a1152 1
    tkFDialog_UpdateWhenIdle $w
d1155 1
a1155 1
# tkFDialogResolveFile --
d1187 1
a1187 1
proc tkFDialogResolveFile {context text defaultext} {
d1191 1
a1191 1
    set path [tkFDialog_JoinFile $context $text]
d1193 4
a1196 1
    if {[file ext $path] == ""} {
d1212 1
a1212 3
	    if {[catch {
		cd $path
	    }]} {
d1220 1
a1220 3
	    if {[catch {
		cd [file dirname $path]
	    }]} {
d1231 1
a1231 3
	    if {[catch {
		cd $dirname
	    }]} {
d1257 2
a1258 2
proc tkFDialog_EntFocusIn {w} {
    upvar #0 [winfo name $w] data
d1261 1
a1261 2
	$data(ent) selection from 0
	$data(ent) selection to   end
d1269 7
a1275 4
    if {![string compare $data(type) open]} {
	$data(okBtn) config -text "Open"
    } else {
	$data(okBtn) config -text "Save"
d1279 2
a1280 2
proc tkFDialog_EntFocusOut {w} {
    upvar #0 [winfo name $w] data
d1286 4
a1289 3
# Verification procedure
proc tkFDialog_VerifyFileName { w fname } {
    upvar #0 [winfo name $w] data
d1291 2
a1292 1
    set list [tkFDialogResolveFile $data(selectPath) $fname \
d1298 1
a1298 1
    case $flag {
d1300 4
a1303 15
	    if {![string compare $file ""]} {
	        tkFDialog_SetPathSilently $w [file dirname $path]
	        # CYGNUS LOCAL: handle choosedir
	        if {$data(-choosedir)} {
		    if {$data(-multiple)} {
		        lappend data(selectFile) [file tail $path]
		    } else {
		        set data(selectFile) [file tail $path]
		    }
		  tkFDialog_Done $w
		} else {
		    # user has entered an existing (sub)directory
		    set data(selectPath) $path
		    $data(ent) delete 0 end
		}
d1305 3
a1307 7
		tkFDialog_SetPathSilently $w $path
		if {$data(-multiple)} {
		    lappend data(selectFile) $file
		} else {
		    set data(selectFile) $file
		}
		tkFDialog_Done $w
d1315 2
a1316 2
	    if {![string compare $data(type) open]} {
		tk_messageBox -icon warning -type ok -parent $data(-parent) \
d1318 1
a1318 2
		$data(ent) select from 0
		$data(ent) select to   end
d1321 3
a1323 7
		tkFDialog_SetPathSilently $w $path
		if {$data(-multiple)} {
		    lappend data(selectFile) $file
		} else {
		    set data(selectFile) $file
		}
		tkFDialog_Done $w
d1327 1
a1327 1
	    tk_messageBox -icon warning -type ok -parent $data(-parent) \
d1329 1
a1329 2
	    $data(ent) select from 0
	    $data(ent) select to   end
d1333 1
a1333 1
	    tk_messageBox -type ok -parent $data(-parent) -message \
d1336 1
a1336 2
	    $data(ent) select from 0
	    $data(ent) select to   end
d1340 1
a1340 1
	    tk_messageBox -type ok -parent $data(-parent) -message \
d1343 1
a1343 2
	    $data(ent) select from 0
	    $data(ent) select to   end
a1348 17
# Gets called when user presses Return in the "File name" entry.
#
proc tkFDialog_ActivateEnt {w} {
    upvar #0 [winfo name $w] data

    #set text [string trim [$data(ent) get]]
    set text [$data(ent) get]
    if {$data(-multiple)} {
	set data(selectFile) ""
	foreach fname $text {
	    tkFDialog_VerifyFileName $w $fname
	}
    } else {
	tkFDialog_VerifyFileName $w $text
    }
}

d1351 2
a1352 2
proc tkFDialog_InvokeBtn {w key} {
    upvar #0 [winfo name $w] data
d1354 1
a1354 1
    if {![string compare [$data(okBtn) cget -text] $key]} {
d1361 2
a1362 2
proc tkFDialog_UpDirCmd {w} {
    upvar #0 [winfo name $w] data
d1372 1
a1372 1
proc tkFDialog_JoinFile {path file} {
d1384 2
a1385 2
proc tkFDialog_OkCmd {w} {
    upvar #0 [winfo name $w] data
d1389 4
a1392 7
	if {!$data(-multiple)} {
	    set file [tkFDialog_JoinFile $data(selectPath) $text]
	    # CYGNUS LOCAL: handle choosedir
	    if {!$data(-choosedir) && [file isdirectory $file]} {
		tkFDialog_ListInvoke $w $text
		return
	    }
d1396 1
a1396 1
    tkFDialog_ActivateEnt $w
d1401 2
a1402 2
proc tkFDialog_CancelCmd {w} {
    upvar #0 [winfo name $w] data
d1411 2
a1412 2
proc tkFDialog_ListBrowse {w text} {
    upvar #0 [winfo name $w] data
d1414 1
a1414 1
    if {$text == ""} {
d1418 2
a1419 3
    set file [tkFDialog_JoinFile $data(selectPath) $text]
    # CYGNUS LOCAL: handle choosedir
    if {$data(-choosedir) || ![file isdirectory $file]} {
d1423 9
a1431 1
	if {![string compare $data(type) open]} {
a1432 2
	} else {
	    $data(okBtn) config -text "Save"
a1433 2
    } else {
	$data(okBtn) config -text "Open"
d1440 2
a1441 2
proc tkFDialog_ListInvoke {w text} {
    upvar #0 [winfo name $w] data
d1443 1
a1443 1
    if {$text == ""} {
d1447 3
a1449 7
    if {$data(-multiple)} {
	set file [tkFDialog_JoinFile $data(selectPath) [lindex $text 0]]
    } else {
	set file [tkFDialog_JoinFile $data(selectPath) $text]
    }

    if {[file isdirectory $file]} {
d1452 1
a1452 1
	    tk_messageBox -type ok -parent $data(-parent) -message \
d1460 2
a1461 6
    	if {$data(-multiple)} {
	    set data(selectFile) [list $file]
	} else {
	    set data(selectFile) $file
	}
	tkFDialog_Done $w
d1465 1
a1465 1
# tkFDialog_Done --
d1473 2
a1474 2
proc tkFDialog_Done {w {selectFilePath ""}} {
    upvar #0 [winfo name $w] data
d1477 3
a1479 10
    if {![string compare $selectFilePath ""]} {
	if {$data(-multiple)} {
	    set selectFilePath {}
	    foreach f $data(selectFile) {
		lappend selectFilePath [file join $data(selectPath) $f]
	    }
	} else {
	    set selectFilePath [tkFDialog_JoinFile $data(selectPath) \
		    $data(selectFile)]
	}
d1483 8
a1490 10
	if {[file exists $selectFilePath] && 
	    ![string compare $data(type) save]} {

		set reply [tk_messageBox -icon warning -type yesno\
			-parent $data(-parent) -message "File\
			\"$selectFilePath\" already exists.\nDo\
			you want to overwrite it?"]
		if {![string compare $reply "no"]} {
		    return
		}
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: tkfbox.tcl,v 1.11.6.2 2000/09/26 16:08:50 spolk Exp $
d16 1
a16 1
# Copyright (c) 1994-1998 Sun Microsystems, Inc.
d55 1
d80 2
a81 2
    $data(sbar) config -command [list $data(canvas) xview]
    $data(canvas) config -xscrollcommand [list $data(sbar) set]
d95 1
a95 1
    bind $data(canvas) <Configure>	[list tkIconList_Arrange $w]
d97 14
a110 14
    bind $data(canvas) <1>		[list tkIconList_Btn1 $w %x %y]
    bind $data(canvas) <B1-Motion>	[list tkIconList_Motion1 $w %x %y]
    bind $data(canvas) <B1-Leave>	[list tkIconList_Leave1 $w %x %y]
    bind $data(canvas) <B1-Enter>	[list tkCancelRepeat]
    bind $data(canvas) <ButtonRelease-1> [list tkCancelRepeat]
    bind $data(canvas) <Double-ButtonRelease-1> \
	    [list tkIconList_Double1 $w %x %y]

    bind $data(canvas) <Up>		[list tkIconList_UpDown $w -1]
    bind $data(canvas) <Down>		[list tkIconList_UpDown $w  1]
    bind $data(canvas) <Left>		[list tkIconList_LeftRight $w -1]
    bind $data(canvas) <Right>		[list tkIconList_LeftRight $w  1]
    bind $data(canvas) <Return>		[list tkIconList_ReturnKey $w]
    bind $data(canvas) <KeyPress>	[list tkIconList_KeyPress $w %A]
d112 1
a112 1
    bind $data(canvas) <Alt-KeyPress>	";"
d114 1
a114 1
    bind $data(canvas) <FocusIn>	[list tkIconList_FocusIn $w]
d154 1
a154 1
    set tkPriv(afterId) [after 50 [list tkIconList_AutoScan $w]]
d287 1
a287 1
	$data(canvas) config -scrollregion [list $pad $pad $sW $H]
d292 2
a293 2
	$data(canvas) config -scrollregion [list $pad $pad $sW $H]
	$data(sbar) config -command [list $data(canvas) xview]
d302 1
a302 1
    if {$data(curItem) != ""} {
d313 2
a314 2
    if {$data(-command) != "" && [info exists data(selected)]} {
	uplevel #0 $data(-command)
d330 1
a330 1
    if {[string equal $sRegion {}]} {
d375 13
a387 1
	    [$data(canvas) canvasx $x] [$data(canvas) canvasy $y]]
d402 8
a409 1
    if {![info exists data(rect)]} {
d411 1
a411 1
		-fill #a0a0ff -outline #a0a0ff]
d415 1
a415 1
    eval [list $data(canvas) coords $data(rect)] $bbox
d418 69
a486 1
    set data(selected) $text
d488 7
a494 2
    if {$callBrowse && $data(-browsecmd) != ""} {
	eval $data(-browsecmd) [list $text]
d501 4
a504 2
    if {[info exists data(rect)]} {
	$data(canvas) delete $data(rect)
d510 1
a510 1
    #set data(curItem)  {}
d533 7
d547 1
a547 1
    tkIconList_SelectAtXY $w $x $y
d553 1
a553 1
    if {[string compare $data(curItem) {}]} {
d577 3
a579 2
    if {[string compare $data(curItem) {}]} {
	tkIconList_Select $w [lindex [lindex $data(list) $data(curItem)] 2] 1
d598 1
a598 1
    if {[string equal $data(curItem) {}]} {
d603 1
a603 1
	if {[string equal $rTag ""]} {
d628 1
a628 1
    if {[string equal $data(curItem) {}]} {
d634 1
a634 1
	if {[string equal $rTag ""]} {
d661 1
a661 1
    set tkPriv(ILAccel,$w,afterId) [after 500 [list tkIconList_Reset $w]]
d673 1
a673 1
    if {[string equal {} $text]} {
d677 1
a677 1
    if {$data(curItem) == "" || $data(curItem) == 0} {
d692 1
a692 1
    while {1} {
d694 1
a694 1
	if {[string equal $text $sub]} {
d709 1
a709 1
	tkIconList_Select $w $rTag
d726 1
a726 4
namespace eval ::tk::dialog {}
namespace eval ::tk::dialog::file {}

# ::tk::dialog::file::tkFDialog --
d732 6
a737 4
# Arguments:
#	type		"open" or "save"
#	args		Options parsed by the procedure.
#
d739 5
a743 4
proc ::tk::dialog::file::tkFDialog {type args} {
    global tkPriv
    set dataName __tk_filedialog
    upvar ::tk::dialog::file::$dataName data
d745 1
a745 1
    ::tk::dialog::file::Config $dataName $type $args
d747 2
a748 2
    if {[string equal $data(-parent) .]} {
        set w .$dataName
d750 10
a759 1
        set w $data(-parent).$dataName
d761 2
d766 1
d768 2
a769 1
	::tk::dialog::file::Create $w TkFDialog
d772 2
a773 1
	::tk::dialog::file::Create $w TkFDialog
d787 2
d790 1
a790 8
    # Add traces on the selectPath variable
    #

    trace variable data(selectPath) w "::tk::dialog::file::SetPath $w"
    $data(dirMenuBtn) configure \
	    -textvariable ::tk::dialog::file::${dataName}(selectPath)

    # Initialize the file types menu
d792 1
a792 1
    if {[llength $data(-filetypes)]} {
d798 1
a798 1
		-command [list ::tk::dialog::file::SetFilter $w $type]
d800 1
a800 1
	::tk::dialog::file::SetFilter $w [lindex $data(-filetypes) 0]
a807 1
    ::tk::dialog::file::UpdateWhenIdle $w
d809 3
a811 1
    # Withdraw the window, then update all the geometry information
d815 10
a824 1
    ::tk::PlaceWindow $w widget $data(-parent)
d826 1
d828 1
a828 1
    # Set a grab and claim the focus too.
d830 7
a836 1
    ::tk::SetFocusGrab $w $data(ent)
d839 2
a840 1
    $data(ent) selection range 0 end
d843 1
a843 1
    # Wait for the user to respond, then restore the focus and
d850 9
a858 8

    ::tk::RestoreFocusGrab $w $data(ent) withdraw

    # Cleanup traces on selectPath variable
    #

    foreach trace [trace vinfo data(selectPath)] {
	trace vdelete data(selectPath) [lindex $trace 0] [lindex $trace 1]
d860 3
a862 2
    $data(dirMenuBtn) configure -textvariable {}

d866 1
a866 1
# ::tk::dialog::file::Config --
d870 2
a871 2
proc ::tk::dialog::file::Config {dataName type argList} {
    upvar ::tk::dialog::file::$dataName data
a874 8
    # 0: Delete all variable that were set on data(selectPath) the
    # last time the file dialog is used. The traces may cause troubles
    # if the dialog is now used with a different -parent option.

    foreach trace [trace vinfo data(selectPath)] {
	trace vdelete data(selectPath) [lindex $trace 0] [lindex $trace 1]
    }

d885 9
d905 1
a905 1
    tclParseConfigSpec ::tk::dialog::file::$dataName $specs "" $argList
d907 2
a908 2
    if {$data(-title) == ""} {
	if {[string equal $type "open"]} {
d918 8
a925 7
    if {$data(-initialdir) != ""} {
	# Ensure that initialdir is an absolute path name.
	if {[file isdirectory $data(-initialdir)]} {
	    set old [pwd]
	    cd $data(-initialdir)
	    set data(selectPath) [pwd]
	    cd $old
d929 7
d946 14
d962 1
a962 1
proc ::tk::dialog::file::Create {w class} {
d964 2
a965 2
    upvar ::tk::dialog::file::$dataName data
    global tk_library tkPriv
d967 1
a967 1
    toplevel $w -class $class
d974 1
a974 1
    set data(dirMenu) [tk_optionMenu $f1.menu [format %s(selectPath) ::tk::dialog::file::$dataName] ""]
a997 9
    if { [string equal $class TkFDialog] } {
	set fNameCaption "File name:"
	set fNameUnder 5
	set iconListCommand [list ::tk::dialog::file::OkCmd $w]
    } else {
	set fNameCaption "Selection:"
	set fNameUnder 0
	set iconListCommand [list ::tk::dialog::file::chooseDir::DblClick $w]
    }
d999 3
a1001 2
	-browsecmd [list ::tk::dialog::file::ListBrowse $w] \
	-command   $iconListCommand]
d1006 4
a1009 2
    label $f2.lab -text $fNameCaption -anchor e -width 14 \
	    -under $fNameUnder -pady 0
d1021 20
a1040 24
    # Make the file types bits only if this is a File Dialog
    if { [string equal $class TkFDialog] } {
	# The "File of types:" label needs to be grayed-out when
	# -filetypes are not specified. The label widget does not support
	# grayed-out text on monochrome displays. Therefore, we have to
	# use a button widget to emulate a label widget (by setting its
	# bindtags)
	
	set data(typeMenuLab) [button $f3.lab -text "Files of type:" \
		-anchor e -width 14 -under 9 \
		-bd [$f2.lab cget -bd] \
		-highlightthickness [$f2.lab cget -highlightthickness] \
		-relief [$f2.lab cget -relief] \
		-padx [$f2.lab cget -padx] \
		-pady [$f2.lab cget -pady]]
	bindtags $data(typeMenuLab) [list $data(typeMenuLab) Label \
		[winfo toplevel $data(typeMenuLab)] all]
	
	set data(typeMenuBtn) [menubutton $f3.menu -indicatoron 1 \
		-menu $f3.menu.m]
	set data(typeMenu) [menu $data(typeMenuBtn).m -tearoff 0]
	$data(typeMenuBtn) config -takefocus 1 -highlightthickness 2 \
		-relief raised -bd 2 -anchor w
    }
d1056 2
a1057 4
    if { [string equal $class TkFDialog] } {
	pack $data(typeMenuLab) -side left -padx 4
	pack $data(typeMenuBtn) -expand yes -fill x -side right
    }
d1066 1
a1066 11
    # Set up the event handlers that are common to Directory and File Dialogs
    #

    wm protocol $w WM_DELETE_WINDOW [list ::tk::dialog::file::CancelCmd $w]
    $data(upBtn)     config -command [list ::tk::dialog::file::UpDirCmd $w]
    $data(cancelBtn) config -command [list ::tk::dialog::file::CancelCmd $w]
    bind $w <KeyPress-Escape> [list tkButtonInvoke $data(cancelBtn)]
    bind $w <Alt-c> [list tkButtonInvoke $data(cancelBtn)]
    bind $w <Alt-d> [list focus $data(dirMenuBtn)]

    # Set up event handlers specific to File or Directory Dialogs
d1068 19
d1088 1
a1088 18
    if { [string equal $class TkFDialog] } {
	bind $data(ent) <Return> [list ::tk::dialog::file::ActivateEnt $w]
	$data(okBtn)     config -command [list ::tk::dialog::file::OkCmd $w]
	bind $w <Alt-t> [format {
	    if {[string equal [%s cget -state] "normal"]} {
		focus %s
	    }
	} $data(typeMenuBtn) $data(typeMenuBtn)]
	bind $w <Alt-n> [list focus $data(ent)]
	bind $w <Alt-o> [list ::tk::dialog::file::InvokeBtn $w Open]
	bind $w <Alt-s> [list ::tk::dialog::file::InvokeBtn $w Save]
    } else {
	set okCmd [list ::tk::dialog::file::chooseDir::OkCmd $w]
	bind $data(ent) <Return> $okCmd
	$data(okBtn) config -command $okCmd
	bind $w <Alt-s> [list focus $data(ent)]
	bind $w <Alt-o> [list tkButtonInvoke $data(okBtn)]
    }
d1093 2
a1094 2
    tkFocusGroup_BindIn $w  $data(ent) [list ::tk::dialog::file::EntFocusIn $w]
    tkFocusGroup_BindOut $w $data(ent) [list ::tk::dialog::file::EntFocusOut $w]
d1097 1
a1097 1
# ::tk::dialog::file::UpdateWhenIdle --
d1104 2
a1105 2
proc ::tk::dialog::file::UpdateWhenIdle {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
d1110 1
a1110 1
	set data(updateId) [after idle [list ::tk::dialog::file::Update $w]]
d1114 1
a1114 1
# ::tk::dialog::file::Update --
d1120 1
a1120 1
proc ::tk::dialog::file::Update {w} {
d1124 1
a1124 6
    if {![winfo exists $w]} {
	return
    }
    set class [winfo class $w]
    if { [string compare $class TkFDialog] && \
	    [string compare $class TkChooseDir] } {
d1129 1
a1129 1
    upvar ::tk::dialog::file::$dataName data
d1149 1
a1149 1
	# should have been checked before ::tk::dialog::file::Update is called, so
d1152 1
a1152 1
	tk_messageBox -type ok -parent $w -message \
d1173 1
a1173 1
	if {[string equal $f .]} {
d1176 1
a1176 1
	if {[string equal $f ..]} {
d1186 16
a1201 17
    if { [string equal $class TkFDialog] } {
	# Make the file list if this is a File Dialog
	#
	if {[string equal $data(filter) *]} {
	    set files [lsort -dictionary \
		    [glob -nocomplain .* *]]
	} else {
	    set files [lsort -dictionary \
		    [eval glob -nocomplain $data(filter)]]
	}
	
	foreach f $files {
	    if {![file isdir ./$f]} {
		if {![info exists hasDoneFile($f)]} {
		    tkIconList_Add $data(icons) $file $f
		    set hasDoneFile($f) 1
		}
d1218 1
a1218 1
    set var [format %s(selectPath) ::tk::dialog::file::$dataName]
a1226 10
    if { [string equal $class TkFDialog] } {
	# Restore the Open/Save Button if this is a File Dialog
	#
	if {[string equal $data(type) open]} {
	    $data(okBtn) config -text "Open"
	} else {
	    $data(okBtn) config -text "Save"
	}
    }

d1233 1
a1233 1
# ::tk::dialog::file::SetPathSilently --
d1237 2
a1238 2
proc ::tk::dialog::file::SetPathSilently {w path} {
    upvar ::tk::dialog::file::[winfo name $w] data
d1240 1
a1240 1
    trace vdelete  data(selectPath) w [list ::tk::dialog::file::SetPath $w]
d1242 1
a1242 1
    trace variable data(selectPath) w [list ::tk::dialog::file::SetPath $w]
d1248 1
a1248 1
proc ::tk::dialog::file::SetPath {w name1 name2 op} {
d1250 2
a1251 7
	upvar ::tk::dialog::file::[winfo name $w] data
	::tk::dialog::file::UpdateWhenIdle $w
	# On directory dialogs, we keep the entry in sync with the currentdir.
	if { [string equal [winfo class $w] TkChooseDir] } {
	    $data(ent) delete 0 end
	    $data(ent) insert end $data(selectPath)
	}
d1257 2
a1258 2
proc ::tk::dialog::file::SetFilter {w type} {
    upvar ::tk::dialog::file::[winfo name $w] data
d1266 1
a1266 1
    ::tk::dialog::file::UpdateWhenIdle $w
d1269 1
a1269 1
# tk::dialog::file::ResolveFile --
d1301 1
a1301 1
proc ::tk::dialog::file::ResolveFile {context text defaultext} {
d1305 1
a1305 1
    set path [::tk::dialog::file::JoinFile $context $text]
d1307 1
a1307 4
    # If the file has no extension, append the default.  Be careful not
    # to do this for directories, otherwise typing a dirname in the box
    # will give back "dirname.extension" instead of trying to change dir.
    if {![file isdirectory $path] && [string equal [file ext $path] ""]} {
d1323 3
a1325 1
	    if {[catch {cd $path}]} {
d1333 3
a1335 1
	    if {[catch {cd [file dirname $path]}]} {
d1346 3
a1348 1
	    if {[catch {cd $dirname}]} {
d1374 2
a1375 2
proc ::tk::dialog::file::EntFocusIn {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
d1378 2
a1379 1
	$data(ent) selection range 0 end
d1387 4
a1390 7
    if { [string equal [winfo class $w] TkFDialog] } {
	# If this is a File Dialog, make sure the buttons are labeled right.
	if {[string equal $data(type) open]} {
	    $data(okBtn) config -text "Open"
	} else {
	    $data(okBtn) config -text "Save"
	}
d1394 2
a1395 2
proc ::tk::dialog::file::EntFocusOut {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
d1401 3
a1403 4
# Gets called when user presses Return in the "File name" entry.
#
proc ::tk::dialog::file::ActivateEnt {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
d1405 1
a1405 2
    set text [string trim [$data(ent) get]]
    set list [::tk::dialog::file::ResolveFile $data(selectPath) $text \
d1411 1
a1411 1
    switch -- $flag {
d1413 15
a1427 4
	    if {[string equal $file ""]} {
		# user has entered an existing (sub)directory
		set data(selectPath) $path
		$data(ent) delete 0 end
d1429 7
a1435 3
		::tk::dialog::file::SetPathSilently $w $path
		set data(selectFile) $file
		::tk::dialog::file::Done $w
d1443 2
a1444 2
	    if {[string equal $data(type) open]} {
		tk_messageBox -icon warning -type ok -parent $w \
d1446 2
a1447 1
		$data(ent) selection range 0 end
d1450 7
a1456 3
		::tk::dialog::file::SetPathSilently $w $path
		set data(selectFile) $file
		::tk::dialog::file::Done $w
d1460 1
a1460 1
	    tk_messageBox -icon warning -type ok -parent $w \
d1462 2
a1463 1
	    $data(ent) selection range 0 end
d1467 1
a1467 1
	    tk_messageBox -type ok -parent $w -message \
d1470 2
a1471 1
	    $data(ent) selection range 0 end
d1475 1
a1475 1
	    tk_messageBox -type ok -parent $w -message \
d1478 2
a1479 1
	    $data(ent) selection range 0 end
d1485 17
d1504 2
a1505 2
proc ::tk::dialog::file::InvokeBtn {w key} {
    upvar ::tk::dialog::file::[winfo name $w] data
d1507 1
a1507 1
    if {[string equal [$data(okBtn) cget -text] $key]} {
d1514 2
a1515 2
proc ::tk::dialog::file::UpDirCmd {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
d1525 1
a1525 1
proc ::tk::dialog::file::JoinFile {path file} {
d1537 2
a1538 2
proc ::tk::dialog::file::OkCmd {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
d1542 7
a1548 4
	set file [::tk::dialog::file::JoinFile $data(selectPath) $text]
	if {[file isdirectory $file]} {
	    ::tk::dialog::file::ListInvoke $w $text
	    return
d1552 1
a1552 1
    ::tk::dialog::file::ActivateEnt $w
d1557 2
a1558 2
proc ::tk::dialog::file::CancelCmd {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
d1567 2
a1568 2
proc ::tk::dialog::file::ListBrowse {w text} {
    upvar ::tk::dialog::file::[winfo name $w] data
d1570 1
a1570 1
    if {[string equal $text ""]} {
d1574 3
a1576 2
    set file [::tk::dialog::file::JoinFile $data(selectPath) $text]
    if {![file isdirectory $file]} {
d1580 4
a1583 6
	if { [string equal [winfo class $w] TkFDialog] } {
	    if {[string equal $data(type) open]} {
		$data(okBtn) config -text "Open"
	    } else {
		$data(okBtn) config -text "Save"
	    }
d1586 1
a1586 3
	if { [string equal [winfo class $w] TkFDialog] } {
	    $data(okBtn) config -text "Open"
	}
d1593 2
a1594 2
proc ::tk::dialog::file::ListInvoke {w text} {
    upvar ::tk::dialog::file::[winfo name $w] data
d1596 1
a1596 1
    if {[string equal $text ""]} {
d1600 7
a1606 3
    set file [::tk::dialog::file::JoinFile $data(selectPath) $text]
    set class [winfo class $w]
    if {[string equal $class TkChooseDir] || [file isdirectory $file]} {
d1609 1
a1609 1
	    tk_messageBox -type ok -parent $w -message \
d1617 6
a1622 2
	set data(selectFile) $file
	::tk::dialog::file::Done $w
d1626 1
a1626 1
# ::tk::dialog::file::Done --
d1634 2
a1635 2
proc ::tk::dialog::file::Done {w {selectFilePath ""}} {
    upvar ::tk::dialog::file::[winfo name $w] data
d1638 10
a1647 3
    if {[string equal $selectFilePath ""]} {
	set selectFilePath [::tk::dialog::file::JoinFile $data(selectPath) \
		$data(selectFile)]
d1651 10
a1660 8
	if {[file exists $selectFilePath] && [string equal $data(type) save]} {
	    set reply [tk_messageBox -icon warning -type yesno\
		    -parent $w -message "File\
		    \"$selectFilePath\" already exists.\nDo\
		    you want to overwrite it?"]
	    if {[string equal $reply "no"]} {
		return
	    }
@


1.1.1.3
log
@import tk 8.4.0
@
text
@d10 1
a10 1
#	selecting the "Directory" option menu. The user can select
d14 1
a14 1
# RCS: @@(#) $Id: tkfbox.tcl,v 1.37 2002/07/22 21:25:39 mdejong Exp $
d27 1
a27 1
# ::tk::dialog::file:: dialog box.
d31 1
a31 1
# ::tk::IconList --
d35 2
a36 145
proc ::tk::IconList {w args} {
    IconList_Config $w $args
    IconList_Create $w
}

proc ::tk::IconList_Index {w i} {
    upvar #0 ::tk::$w data
    upvar #0 ::tk::$w:itemList itemList
    if {![info exists data(list)]} {set data(list) {}}
    switch -regexp -- $i {
	"^-?[0-9]+$" {
	    if { $i < 0 } {
		set i 0
	    }
	    if { $i >= [llength $data(list)] } {
		set i [expr {[llength $data(list)] - 1}]
	    }
	    return $i
	}
	"^active$" {
	    return $data(index,active)
	}
	"^anchor$" {
	    return $data(index,anchor)
	}
	"^end$" {
	    return [llength $data(list)]
	}
	"@@-?[0-9]+,-?[0-9]+" {
	    foreach {x y} [scan $i "@@%d,%d"] {
		break
	    }
	    set item [$data(canvas) find closest $x $y]
	    return [lindex [$data(canvas) itemcget $item -tags] 1]
	}
    }
}

proc ::tk::IconList_Selection {w op args} {
    upvar ::tk::$w data
    switch -exact -- $op {
	"anchor" {
	    if { [llength $args] == 1 } {
		set data(index,anchor) [tk::IconList_Index $w [lindex $args 0]]
	    } else {
		return $data(index,anchor)
	    }
	}
	"clear" {
	    if { [llength $args] == 2 } {
		foreach {first last} $args {
		    break
		}
	    } elseif { [llength $args] == 1 } {
		set first [set last [lindex $args 0]]
	    } else {
		error "wrong # args: should be [lindex [info level 0] 0] path\
			clear first ?last?"
	    }
	    set first [IconList_Index $w $first]
	    set last [IconList_Index $w $last]
	    if { $first > $last } {
		set tmp $first
		set first $last
		set last $tmp
	    }
	    set ind 0
	    foreach item $data(selection) {
		if { $item >= $first } {
		    set first $ind
		    break
		}
	    }
	    set ind [expr {[llength $data(selection)] - 1}]
	    for {} {$ind >= 0} {incr ind -1} {
		set item [lindex $data(selection) $ind]
		if { $item <= $last } {
		    set last $ind
		    break
		}
	    }

	    if { $first > $last } {
		return
	    }
	    set data(selection) [lreplace $data(selection) $first $last]
	    event generate $w <<ListboxSelect>>
	    IconList_DrawSelection $w
	}
	"includes" {
	    set index [lsearch -exact $data(selection) [lindex $args 0]]
	    return [expr {$index != -1}]
	}
	"set" {
	    if { [llength $args] == 2 } {
		foreach {first last} $args {
		    break
		}
	    } elseif { [llength $args] == 1 } {
		set last [set first [lindex $args 0]]
	    } else {
		error "wrong # args: should be [lindex [info level 0] 0] path\
			set first ?last?"
	    }

	    set first [IconList_Index $w $first]
	    set last [IconList_Index $w $last]
	    if { $first > $last } {
		set tmp $first
		set first $last
		set last $tmp
	    }
	    for {set i $first} {$i <= $last} {incr i} {
		lappend data(selection) $i
	    }
	    set data(selection) [lsort -integer -unique $data(selection)]
	    event generate $w <<ListboxSelect>>
	    IconList_DrawSelection $w
	}
    }
}

proc ::tk::IconList_Curselection {w} {
    upvar ::tk::$w data
    return $data(selection)
}

proc ::tk::IconList_DrawSelection {w} {
    upvar ::tk::$w data
    upvar ::tk::$w:itemList itemList

    $data(canvas) delete selection
    foreach item $data(selection) {
	set rTag [lindex [lindex $data(list) $item] 2]
	foreach {iTag tTag text serial} $itemList($rTag) {
	    break
	}

	set bbox [$data(canvas) bbox $tTag]
        $data(canvas) create rect $bbox -fill \#a0a0ff -outline \#a0a0ff \
		-tags selection
    }
    $data(canvas) lower selection
    return
}
d38 2
a39 8
proc ::tk::IconList_Get {w item} {
    upvar ::tk::$w data
    upvar ::tk::$w:itemList itemList
    set rTag [lindex [lindex $data(list) $item] 2]
    foreach {iTag tTag text serial} $itemList($rTag) {
	break
    }
    return $text
d42 1
a42 1
# ::tk::IconList_Config --
d47 2
a48 1
proc ::tk::IconList_Config {w argList} {
d53 1
a54 1
	{-multiple "" "" "0"}
d59 1
a59 1
    tclParseConfigSpec ::tk::$w $specs "" $argList
d62 1
a62 1
# ::tk::IconList_Create --
d68 2
a69 2
proc ::tk::IconList_Create {w} {
    upvar ::tk::$w data
a90 2
    set data(selection) {}
    set data(index,anchor) ""
d94 1
a94 1
    bind $data(canvas) <Configure>	[list tk::IconList_Arrange $w]
d96 5
a100 7
    bind $data(canvas) <1>		[list tk::IconList_Btn1 $w %x %y]
    bind $data(canvas) <B1-Motion>	[list tk::IconList_Motion1 $w %x %y]
    bind $data(canvas) <B1-Leave>	[list tk::IconList_Leave1 $w %x %y]
    bind $data(canvas) <Control-1>	[list tk::IconList_CtrlBtn1 $w %x %y]
    bind $data(canvas) <Shift-1>	[list tk::IconList_ShiftBtn1 $w %x %y]
    bind $data(canvas) <B1-Enter>	[list tk::CancelRepeat]
    bind $data(canvas) <ButtonRelease-1> [list tk::CancelRepeat]
d102 1
a102 1
	    [list tk::IconList_Double1 $w %x %y]
d104 6
a109 6
    bind $data(canvas) <Up>		[list tk::IconList_UpDown $w -1]
    bind $data(canvas) <Down>		[list tk::IconList_UpDown $w  1]
    bind $data(canvas) <Left>		[list tk::IconList_LeftRight $w -1]
    bind $data(canvas) <Right>		[list tk::IconList_LeftRight $w  1]
    bind $data(canvas) <Return>		[list tk::IconList_ReturnKey $w]
    bind $data(canvas) <KeyPress>	[list tk::IconList_KeyPress $w %A]
d113 1
a113 2
    bind $data(canvas) <FocusIn>	[list tk::IconList_FocusIn $w]
    bind $data(canvas) <FocusOut>	[list tk::IconList_FocusOut $w]
d118 1
a118 1
# ::tk::IconList_AutoScan --
d129 3
a131 3
proc ::tk::IconList_AutoScan {w} {
    upvar ::tk::$w data
    variable ::tk::Priv
d134 2
a135 2
    set x $Priv(x)
    set y $Priv(y)
d152 2
a153 2
    IconList_Motion1 $w $x $y
    set Priv(afterId) [after 50 [list tk::IconList_AutoScan $w]]
d159 3
a161 3
proc ::tk::IconList_DeleteAll {w} {
    upvar ::tk::$w data
    upvar ::tk::$w:itemList itemList
a174 2
    set data(selection) {}
    set data(index,anchor) ""
d181 9
a189 25
proc ::tk::IconList_Add {w image items} {
    upvar ::tk::$w data
    upvar ::tk::$w:itemList itemList
    upvar ::tk::$w:textList textList

    foreach text $items {
	set iTag [$data(canvas) create image 0 0 -image $image -anchor nw \
		-tags [list icon $data(numItems) item$data(numItems)]]
	set tTag [$data(canvas) create text  0 0 -text  $text  -anchor nw \
		-font $data(font) \
		-tags [list text $data(numItems) item$data(numItems)]]
	set rTag [$data(canvas) create rect  0 0 0 0 -fill "" -outline "" \
		-tags [list rect $data(numItems) item$data(numItems)]]
	
	foreach {x1 y1 x2 y2} [$data(canvas) bbox $iTag] {
	    break
	}
	set iW [expr {$x2 - $x1}]
	set iH [expr {$y2 - $y1}]
	if {$data(maxIW) < $iW} {
	    set data(maxIW) $iW
	}
	if {$data(maxIH) < $iH} {
	    set data(maxIH) $iH
	}
d191 9
a199 11
	foreach {x1 y1 x2 y2} [$data(canvas) bbox $tTag] {
	    break
	}
	set tW [expr {$x2 - $x1}]
	set tH [expr {$y2 - $y1}]
	if {$data(maxTW) < $tW} {
	    set data(maxTW) $tW
	}
	if {$data(maxTH) < $tH} {
	    set data(maxTH) $tH
	}
d201 8
a208 5
	lappend data(list) [list $iTag $tTag $rTag $iW $iH $tW \
		$tH $data(numItems)]
	set itemList($rTag) [list $iTag $tTag $text $data(numItems)]
	set textList($data(numItems)) [string tolower $text]
	incr data(numItems)
d210 5
d219 2
a220 2
proc ::tk::IconList_Arrange {w} {
    upvar ::tk::$w data
d255 7
a261 3
	foreach {iTag tTag rTag iW iH tW tH} $sublist {
	    break
	}
d268 1
d302 1
a302 1
	IconList_Select $w [lindex [lindex $data(list) $data(curItem)] 2] 0
d309 2
a310 2
proc ::tk::IconList_Invoke {w} {
    upvar ::tk::$w data
d312 1
a312 1
    if {$data(-command) != "" && [llength $data(selection)]} {
d317 1
a317 1
# ::tk::IconList_See --
d321 3
a323 3
proc ::tk::IconList_See {w rTag} {
    upvar ::tk::$w data
    upvar ::tk::$w:itemList itemList
d333 1
a333 1
    if { $rTag < 0 || $rTag >= [llength $data(list)] } {
d337 2
a338 1
    set bbox [$data(canvas) bbox item$rTag]
d370 10
a379 2
proc ::tk::IconList_Btn1 {w x y} {
    upvar ::tk::$w data
d381 22
a402 8
    focus $data(canvas)
    set x [expr {int([$data(canvas) canvasx $x])}]
    set y [expr {int([$data(canvas) canvasy $y])}]
    set i [IconList_Index $w @@${x},${y}]
    if {$i==""} return
    IconList_Selection $w clear 0 end
    IconList_Selection $w set $i
    IconList_Selection $w anchor $i
d405 9
a413 15
proc ::tk::IconList_CtrlBtn1 {w x y} {
    upvar ::tk::$w data
    
    if { $data(-multiple) } {
	focus $data(canvas)
	set x [expr {int([$data(canvas) canvasx $x])}]
	set y [expr {int([$data(canvas) canvasy $y])}]
	set i [IconList_Index $w @@${x},${y}]
	if {$i==""} return
	if { [IconList_Selection $w includes $i] } {
	    IconList_Selection $w clear $i
	} else {
	    IconList_Selection $w set $i
	    IconList_Selection $w anchor $i
	}
d415 1
d418 9
a426 15
proc ::tk::IconList_ShiftBtn1 {w x y} {
    upvar ::tk::$w data
    
    if { $data(-multiple) } {
	focus $data(canvas)
	set x [expr {int([$data(canvas) canvasx $x])}]
	set y [expr {int([$data(canvas) canvasy $y])}]
	set i [IconList_Index $w @@${x},${y}]
	if {$i==""} return
	set a [IconList_Index $w anchor]
	if { [string equal $a ""] } {
	    set a $i
	}
	IconList_Selection $w clear 0 end
	IconList_Selection $w set $a $i
d430 8
d440 6
a445 11
proc ::tk::IconList_Motion1 {w x y} {
    upvar ::tk::$w data
    variable ::tk::Priv
    set Priv(x) $x
    set Priv(y) $y
    set x [expr {int([$data(canvas) canvasx $x])}]
    set y [expr {int([$data(canvas) canvasy $y])}]
    set i [IconList_Index $w @@${x},${y}]
    if {$i==""} return
    IconList_Selection $w clear 0 end
    IconList_Selection $w set $i
d448 2
a449 2
proc ::tk::IconList_Double1 {w x y} {
    upvar ::tk::$w data
d451 2
a452 2
    if {[llength $data(selection)]} {
	IconList_Invoke $w
d456 2
a457 2
proc ::tk::IconList_ReturnKey {w} {
    IconList_Invoke $w
d460 2
a461 2
proc ::tk::IconList_Leave1 {w x y} {
    variable ::tk::Priv
d463 3
a465 3
    set Priv(x) $x
    set Priv(y) $y
    IconList_AutoScan $w
d468 2
a469 2
proc ::tk::IconList_FocusIn {w} {
    upvar ::tk::$w data
d475 2
a476 2
    if {[llength $data(selection)]} {
	IconList_DrawSelection $w
d480 1
a480 5
proc ::tk::IconList_FocusOut {w} {
    IconList_Selection $w clear 0 end
}

# ::tk::IconList_UpDown --
d488 2
a489 2
proc ::tk::IconList_UpDown {w amount} {
    upvar ::tk::$w data
d495 2
a496 3
    set curr [tk::IconList_Curselection $w]
    if { [llength $curr] == 0 } {
	set i 0
d498 10
a507 3
	set i [tk::IconList_Index $w anchor]
	if {$i==""} return
	incr i $amount
a508 4
    IconList_Selection $w clear 0 end
    IconList_Selection $w set $i
    IconList_Selection $w anchor $i
    IconList_See $w $i
d511 1
a511 1
# ::tk::IconList_LeftRight --
d519 2
a520 2
proc ::tk::IconList_LeftRight {w amount} {
    upvar ::tk::$w data
d525 10
d536 4
a539 12
    set curr [IconList_Curselection $w]
    if { [llength $curr] == 0 } {
	set i 0
    } else {
	set i [IconList_Index $w anchor]
	if {$i==""} return
	incr i [expr {$amount*$data(itemsPerColumn)}]
    }
    IconList_Selection $w clear 0 end
    IconList_Selection $w set $i
    IconList_Selection $w anchor $i
    IconList_See $w $i
d546 1
a546 1
# ::tk::IconList_KeyPress --
d550 2
a551 2
proc ::tk::IconList_KeyPress {w key} {
    variable ::tk::Priv
d553 2
a554 2
    append Priv(ILAccel,$w) $key
    IconList_Goto $w $Priv(ILAccel,$w)
d556 1
a556 1
	after cancel $Priv(ILAccel,$w,afterId)
d558 1
a558 1
    set Priv(ILAccel,$w,afterId) [after 500 [list tk::IconList_Reset $w]]
d561 4
a564 3
proc ::tk::IconList_Goto {w text} {
    upvar ::tk::$w data
    upvar ::tk::$w:textList textList
d605 3
a607 4
	IconList_Selection $w clear 0 end
	IconList_Selection $w set $theIndex
	IconList_Selection $w anchor $theIndex
	IconList_See $w $theIndex
d611 2
a612 2
proc ::tk::IconList_Reset {w} {
    variable ::tk::Priv
d614 1
a614 1
    catch {unset Priv(ILAccel,$w)}
d624 1
a624 3
namespace eval ::tk::dialog::file {
    namespace import ::tk::msgcat::*
}
d626 1
a626 1
# ::tk::dialog::file:: --
d637 2
a638 2
proc ::tk::dialog::file:: {type args} {
    variable ::tk::Priv
a667 12
	::tk::dialog::file::SetSelectMode $w $data(-multiple)
    }

    # Dialog boxes should be transient with respect to their parent,
    # so that they will always stay on top of their parent window.  However,
    # some window managers will create the window as withdrawn if the parent
    # window is withdrawn or iconified.  Combined with the grab we put on the
    # window, this can hang the entire application.  Therefore we only make
    # the dialog transient if the parent is viewable.

    if {[winfo viewable [winfo toplevel $data(-parent)]] } {
	wm transient $w $data(-parent)
d669 1
d719 1
a719 1
    vwait ::tk::Priv(selectFilePath)
d731 1
a731 1
    return $Priv(selectFilePath)
a761 6
    # The "-multiple" option is only available for the "open" file dialog.
    #
    if { [string equal $type "open"] } {
	lappend specs {-multiple "" "" "0"}
    }

d776 1
a776 1
	    set data(-title) "[mc "Open"]"
d778 1
a778 1
	    set data(-title) "[mc "Save As"]"
d800 1
a800 1
    set data(-filetypes) [::tk::FDGetFileTypes $data(-filetypes)]
a804 10

    # Set -multiple to a one or zero value (not other boolean types
    # like "yes") so we can use it in tests more easily.
    if {![string compare $type save]} {
	set data(-multiple) 0
    } elseif {$data(-multiple)} { 
	set data(-multiple) 1 
    } else {
	set data(-multiple) 0
    }
d810 1
a810 2
    variable ::tk::Priv
    global tk_library
d817 1
a817 3
    bind [::tk::AmpWidget label $f1.lab -text "[mc "&Directory:"]" ] \
	<<AltUnderlined>> [list focus $f1.menu]
    
d821 2
a822 2
    if {![info exists Priv(updirImage)]} {
	set Priv(updirImage) [image create bitmap -data {
d833 1
a833 1
    $data(upBtn) config -image $Priv(updirImage)
d844 2
a845 8
	if { $data(-multiple) } {
	    set fNameCaption "[mc {File &names:}]"
	} else {
	    set fNameCaption "[mc {File &name:}]"
	}
	set fTypeCaption [mc "Files of &type:"]
	set fCaptionWidth [::tk::mcmaxamp $fNameCaption $fTypeCaption]
	set fCaptionWidth [expr {$fCaptionWidth<14?14:$fCaptionWidth}]
d848 2
a849 2
	set fNameCaption [mc "&Selection:"]
	set fCaptionWidth [string length $fNameCaption]
d852 3
a854 5
    set data(icons) [::tk::IconList $w.icons \
	    -command	$iconListCommand \
	    -multiple	$data(-multiple)]
    bind $data(icons) <<ListboxSelect>> \
	    [list ::tk::dialog::file::ListBrowse $w]
d859 2
a860 2
    bind [::tk::AmpWidget label $f2.lab -text $fNameCaption -anchor e -width $fCaptionWidth \
	    -pady 0] <<AltUnderlined>> [list focus $f2.ent]
d865 2
a866 1
    set ::tk::$w.icons(font) [$data(ent) cget -font]
d880 2
a881 2
	set data(typeMenuLab) [::tk::AmpWidget button $f3.lab -text $fTypeCaption \
		-anchor e -width $fCaptionWidth \
d889 1
a894 2
        bind $data(typeMenuLab) <<AltUnderlined>> [list focus \
	    $data(typeMenuBtn)]
d899 4
a902 6
	set maxWidth [::tk::mcmaxamp &OK &Cancel]
	set maxWidth [expr {$maxWidth<6?6:$maxWidth}]
    set data(okBtn)     [::tk::AmpWidget button $f2.ok     -text "[mc "&OK"]" \
	-width $maxWidth -default active -pady 3]
    set data(cancelBtn) [::tk::AmpWidget button $f3.cancel -text "[mc "&Cancel"]" \
	-width $maxWidth -default normal -pady 3]
d929 4
a932 2
    bind $w <KeyPress-Escape> [list tk::ButtonInvoke $data(cancelBtn)]
    bind $w <Alt-Key> [list tk::AltKeyInDialog $w %A]
d944 3
d952 1
a952 1
	bind $w <Alt-o> [list tk::ButtonInvoke $data(okBtn)]
d957 3
a959 29
    ::tk::FocusGroup_Create $w
    ::tk::FocusGroup_BindIn $w  $data(ent) [list ::tk::dialog::file::EntFocusIn $w]
    ::tk::FocusGroup_BindOut $w $data(ent) [list ::tk::dialog::file::EntFocusOut $w]
}

# ::tk::dialog::file::SetSelectMode --
#
#	Set the select mode of the dialog to single select or multi-select.
#
# Arguments:
#	w		The dialog path.
#	multi		1 if the dialog is multi-select; 0 otherwise.
#
# Results:
#	None.

proc ::tk::dialog::file::SetSelectMode {w multi} {
    set dataName __tk_filedialog
    upvar ::tk::dialog::file::$dataName data
    if { $multi } {
	set fNameCaption "[mc {File &names:}]"
    } else {
	set fNameCaption "[mc {File &name:}]"
    }
    set iconListCommand [list ::tk::dialog::file::OkCmd $w]
    ::tk::SetAmpText $w.f2.lab $fNameCaption 
    ::tk::IconList_Config $data(icons) \
	    [list -multiple $multi -command $iconListCommand]
    return
d1000 1
a1000 2
    variable ::tk::Priv
    global tk_library
d1003 2
a1004 2
    if {![info exists Priv(folderImage)]} {
	set Priv(folderImage) [image create photo -data {
d1007 1
a1007 1
	set Priv(fileImage)   [image create photo -data {
d1011 2
a1012 2
    set folder $Priv(folderImage)
    set file   $Priv(fileImage)
d1023 1
a1023 1
	    "[mc "Cannot change to the directory \"%1\$s\".\nPermission denied." $data(selectPath)]"\
d1038 1
a1038 1
    ::tk::IconList_DeleteAll $data(icons)
d1042 1
a1042 3
    set completeFileList [lsort -dictionary -unique [glob -nocomplain .* *]]
    set dirList {}
    foreach f $completeFileList {
d1050 4
a1053 1
	    lappend dirList $f
a1055 1
    ::tk::IconList_Add $data(icons) $folder $dirList
d1060 2
a1061 1
	    set files $completeFileList
d1063 2
a1064 9
	    set files {}
	    foreach f $completeFileList {
		foreach pat $data(filter) {
		    if { [string match $pat $f] } {
			lappend files $f
			break
		    }
		}
	    }
d1066 1
a1066 1
	set fileList {}
d1069 4
a1072 1
		lappend fileList $f
a1074 1
	::tk::IconList_Add $data(icons) $file $fileList
d1077 1
a1077 1
    ::tk::IconList_Arrange $data(icons)
d1102 1
a1102 6
	    ::tk::SetAmpText $data(okBtn) [mc "&Open"]
	    set maxWidth [::tk::mcmaxamp [mc "&Open"]]
	    if {$maxWidth>[$data(okBtn) cget -width]} {
		    $data(okBtn) config -width $maxWidth
		    $data(cancelBtn) config -width $maxWidth
	    }
d1104 1
a1104 6
	    ::tk::SetAmpText $data(okBtn) [mc "&Save"]
	    set maxWidth [::tk::mcmaxamp [mc "&Save"]]
	    if {$maxWidth>[$data(okBtn) cget -width]} {
		    $data(okBtn) config -width $maxWidth
		    $data(cancelBtn) config -width $maxWidth
	    }
d1145 1
a1145 1
    upvar ::tk::$data(icons) icons
a1149 23
    # If we aren't using a default extension, use the one suppled
    # by the filter.
    if {![info exists data(extUsed)]} {
	if {[string length $data(-defaultextension)]} {
	    set data(extUsed) 1
	} else {
	    set data(extUsed) 0
	}
    }

    if {!$data(extUsed)} {
	# Get the first extension in the list that matches {^\*\.\w+$}
	# and remove all * from the filter.
	set index [lsearch -regexp $data(filter) {^\*\.\w+$}]
	if {$index >= 0} {
	    set data(-defaultextension) \
		    [string trimleft [lindex $data(filter) $index] "*"]
	} else {
	    # Couldn't find anything!  Reset to a safe default...
	    set data(-defaultextension) ""
	}
    }

d1267 2
d1272 1
a1272 1
	    ::tk::SetAmpText $data(okBtn) [mc "&Open"]
d1274 1
a1274 1
	    ::tk::SetAmpText $data(okBtn) [mc "&Save"]
d1291 6
a1296 26
    set text [$data(ent) get]
    if {$data(-multiple)} {
	# For the multiple case we have to be careful to get the file
	# names as a true list, watching out for a single file with a
	# space in the name.  Thus we query the IconList directly.

	set data(selectFile) ""
	foreach item [::tk::IconList_Curselection $data(icons)] {
	    ::tk::dialog::file::VerifyFileName $w \
		    [::tk::IconList_Get $data(icons) $item]
	}
    } else {
	::tk::dialog::file::VerifyFileName $w $text
    }
}

# Verification procedure
#
proc ::tk::dialog::file::VerifyFileName {w filename} {
    upvar ::tk::dialog::file::[winfo name $w] data

    set list [::tk::dialog::file::ResolveFile $data(selectPath) $filename \
	    $data(-defaultextension)]
    foreach {flag path file} $list {
	break
    }
d1306 1
a1306 5
		if {$data(-multiple)} {
		    lappend data(selectFile) $file
		} else {
		    set data(selectFile) $file
		}
d1317 1
a1317 1
		    -message "[mc "File \"%1\$s\"  does not exist." [file join $path $file]]"
d1322 1
a1322 5
		if {$data(-multiple)} {
		    lappend data(selectFile) $file
		} else {
		    set data(selectFile) $file
		}
d1328 1
a1328 1
		-message "[mc "Directory \"%1\$s\" does not exist." $path]"
d1334 1
a1334 1
	       "[mc "Cannot change to the directory \"%1\$s\".\nPermission denied." $path]"\
d1341 1
a1341 1
	       "[mc "Invalid file name \"%1\$s\"." $path]"\
d1355 1
a1355 1
	::tk::ButtonInvoke $data(okBtn)
d1380 2
d1387 3
a1389 9
    set filenames {}
    foreach item [::tk::IconList_Curselection $data(icons)] {
	lappend filenames [::tk::IconList_Get $data(icons) $item]
    }

    if {([llength $filenames] && !$data(-multiple)) || \
	    ($data(-multiple) && ([llength $filenames] == 1))} {
	set filename [lindex $filenames 0]
	set file [::tk::dialog::file::JoinFile $data(selectPath) $filename]
d1391 1
a1391 1
	    ::tk::dialog::file::ListInvoke $w [list $filename]
d1403 1
a1403 1
    variable ::tk::Priv
d1405 1
a1405 1
    set Priv(selectFilePath) ""
d1411 1
a1411 1
proc ::tk::dialog::file::ListBrowse {w} {
d1414 1
a1414 5
    set text {}
    foreach item [::tk::IconList_Curselection $data(icons)] {
	lappend text [::tk::IconList_Get $data(icons) $item]
    }
    if {[llength $text] == 0} {
d1417 3
a1419 16
    if { [llength $text] > 1 } {
	set newtext {}
	foreach file $text {
	    set fullfile [::tk::dialog::file::JoinFile $data(selectPath) $file]
	    if { ![file isdirectory $fullfile] } {
		lappend newtext $file
	    }
	}
	set text $newtext
	set isDir 0
    } else {
	set text [lindex $text 0]
	set file [::tk::dialog::file::JoinFile $data(selectPath) $text]
	set isDir [file isdirectory $file]
    }
    if {!$isDir} {
d1425 1
a1425 1
		::tk::SetAmpText $data(okBtn) [mc "&Open"]
d1427 1
a1427 1
		::tk::SetAmpText $data(okBtn) [mc "&Save"]
d1432 1
a1432 1
	    ::tk::SetAmpText $data(okBtn) [mc "&Open"]
d1440 1
a1440 1
proc ::tk::dialog::file::ListInvoke {w filenames} {
d1443 1
a1443 1
    if {[llength $filenames] == 0} {
d1447 1
a1447 3
    set file [::tk::dialog::file::JoinFile $data(selectPath) \
	    [lindex $filenames 0]]
    
d1453 1
a1453 1
	       "[mc "Cannot change to the directory \"%1\$s\".\nPermission denied." $file]"\
d1460 1
a1460 5
	if {$data(-multiple)} {
	    set data(selectFile) $filenames
	} else {
	    set data(selectFile) $file
	}
d1469 2
a1470 2
#	tk::Priv(selectFilePath) variable, which will break the "vwait"
#	loop in ::tk::dialog::file:: and return the selected filename to the
d1475 1
a1475 1
    variable ::tk::Priv
d1478 4
a1481 13
	if {$data(-multiple)} {
	    set selectFilePath {}
	    foreach f $data(selectFile) {
		lappend selectFilePath [::tk::dialog::file::JoinFile \
		    $data(selectPath) $f]
	    }
	} else {
	    set selectFilePath [::tk::dialog::file::JoinFile \
		    $data(selectPath) $data(selectFile)]
	}
	
	set Priv(selectFile)     $data(selectFile)
	set Priv(selectPath)     $data(selectPath)
d1483 1
a1483 2
	if {[string equal $data(type) save]} {
	    if {[file exists $selectFilePath]} {
d1485 3
a1487 2
		    -parent $w -message \
			"[mc "File \"%1\$s\" already exists.\nDo you want to overwrite it?" $selectFilePath]"]
a1489 1
		}
d1493 1
a1493 1
    set Priv(selectFilePath) $selectFilePath
d1495 1
@


