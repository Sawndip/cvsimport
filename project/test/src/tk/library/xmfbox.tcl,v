head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.46;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.14;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.26;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.52;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.34;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.51;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# xmfbox.tcl --
#
#	Implements the "Motif" style file selection dialog for the
#	Unix platform. This implementation is used only if the
#	"::tk_strictMotif" flag is set.
#
# RCS: @@(#) $Id: xmfbox.tcl,v 1.24 2002/09/09 20:05:27 uid38172 Exp $
#
# Copyright (c) 1996 Sun Microsystems, Inc.
# Copyright (c) 1998-2000 Scriptics Corporation
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

namespace eval ::tk::dialog {}
namespace eval ::tk::dialog::file {}


# ::tk::MotifFDialog --
#
#	Implements a file dialog similar to the standard Motif file
#	selection box.
#
# Arguments:
#	type		"open" or "save"
#	args		Options parsed by the procedure.
#
# Results:
#	When -multiple is set to 0, this returns the absolute pathname
#	of the selected file. (NOTE: This is not the same as a single
#	element list.)
# 
#	When -multiple is set to > 0, this returns a Tcl list of absolute
#       pathnames. The argument for -multiple is ignored, but for consistency
#       with Windows it defines the maximum amount of memory to allocate for
#       the returned filenames.

proc ::tk::MotifFDialog {type args} {
    variable ::tk::Priv
    set dataName __tk_filedialog
    upvar ::tk::dialog::file::$dataName data

    set w [MotifFDialog_Create $dataName $type $args]

    # Set a grab and claim the focus too.

    ::tk::SetFocusGrab $w $data(sEnt)
    $data(sEnt) selection range 0 end

    # Wait for the user to respond, then restore the focus and
    # return the index of the selected button.  Restore the focus
    # before deleting the window, since otherwise the window manager
    # may take the focus away so we can't redirect it.  Finally,
    # restore any grab that was in effect.

    vwait ::tk::Priv(selectFilePath)
    ::tk::RestoreFocusGrab $w $data(sEnt) withdraw

    return $Priv(selectFilePath)
}

# ::tk::MotifFDialog_Create --
#
#	Creates the Motif file dialog (if it doesn't exist yet) and
#	initialize the internal data structure associated with the
#	dialog.
#
#	This procedure is used by ::tk::MotifFDialog to create the
#	dialog. It's also used by the test suite to test the Motif
#	file dialog implementation. User code shouldn't call this
#	procedure directly.
#
# Arguments:
#	dataName	Name of the global "data" array for the file dialog.
#	type		"Save" or "Open"
#	argList		Options parsed by the procedure.
#
# Results:
#	Pathname of the file dialog.

proc ::tk::MotifFDialog_Create {dataName type argList} {
    upvar ::tk::dialog::file::$dataName data

    MotifFDialog_Config $dataName $type $argList

    if {[string equal $data(-parent) .]} {
        set w .$dataName
    } else {
        set w $data(-parent).$dataName
    }

    # (re)create the dialog box if necessary
    #
    if {![winfo exists $w]} {
	MotifFDialog_BuildUI $w
    } elseif {[string compare [winfo class $w] TkMotifFDialog]} {
	destroy $w
	MotifFDialog_BuildUI $w
    } else {
	set data(fEnt) $w.top.f1.ent
	set data(dList) $w.top.f2.a.l
	set data(fList) $w.top.f2.b.l
	set data(sEnt) $w.top.f3.ent
	set data(okBtn) $w.bot.ok
	set data(filterBtn) $w.bot.filter
	set data(cancelBtn) $w.bot.cancel
    }
    MotifFDialog_SetListMode $w

    # Dialog boxes should be transient with respect to their parent,
    # so that they will always stay on top of their parent window.  However,
    # some window managers will create the window as withdrawn if the parent
    # window is withdrawn or iconified.  Combined with the grab we put on the
    # window, this can hang the entire application.  Therefore we only make
    # the dialog transient if the parent is viewable.

    if {[winfo viewable [winfo toplevel $data(-parent)]] } {
	wm transient $w $data(-parent)
    }

    MotifFDialog_FileTypes $w
    MotifFDialog_Update $w

    # Withdraw the window, then update all the geometry information
    # so we know how big it wants to be, then center the window in the
    # display (Motif style) and de-iconify it.

    ::tk::PlaceWindow $w
    wm title $w $data(-title)

    return $w
}

# ::tk::MotifFDialog_FileTypes --
#
#	Checks the -filetypes option. If present this adds a list of radio-
#	buttons to pick the file types from.
#
# Arguments:
#	w		Pathname of the tk_get*File dialogue.
#
# Results:
#	none

proc ::tk::MotifFDialog_FileTypes {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    set f $w.top.f3.types
    catch {destroy $f}

    # No file types: use "*" as the filter and display no radio-buttons
    if {$data(-filetypes) == ""} {
	set data(filter) *
	return
    }

    # The filetypes radiobuttons
    # set data(fileType) $data(-defaulttype)
    set data(fileType) 0

    MotifFDialog_SetFilter $w [lindex $data(-filetypes) $data(fileType)]

    #don't produce radiobuttons for only one filetype
    if {[llength $data(-filetypes)] == 1} {
	return
    }

    frame $f
    set cnt 0
    if {$data(-filetypes) != {}} {
	foreach type $data(-filetypes) {
	    set title  [lindex [lindex $type 0] 0]
	    set filter [lindex $type 1]
	    radiobutton $f.b$cnt \
		-text $title \
		-variable ::tk::dialog::file::[winfo name $w](fileType) \
		-value $cnt \
		-command "[list tk::MotifFDialog_SetFilter $w $type]"
	    pack $f.b$cnt -side left
	    incr cnt
	}
    }
    $f.b$data(fileType) invoke

    pack $f -side bottom -fill both

    return
}

# This proc gets called whenever data(filter) is set
#
proc ::tk::MotifFDialog_SetFilter {w type} {
    upvar ::tk::dialog::file::[winfo name $w] data
    variable ::tk::Priv

    set data(filter) [lindex $type 1]
    set Priv(selectFileType) [lindex [lindex $type 0] 0]

    MotifFDialog_Update $w
}

# ::tk::MotifFDialog_Config --
#
#	Iterates over the optional arguments to determine the option
#	values for the Motif file dialog; gives default values to
#	unspecified options.
#
# Arguments:
#	dataName	The name of the global variable in which
#			data for the file dialog is stored.
#	type		"Save" or "Open"
#	argList		Options parsed by the procedure.

proc ::tk::MotifFDialog_Config {dataName type argList} {
    upvar ::tk::dialog::file::$dataName data

    set data(type) $type

    # 1: the configuration specs
    #
    set specs {
	{-defaultextension "" "" ""}
	{-filetypes "" "" ""}
	{-initialdir "" "" ""}
	{-initialfile "" "" ""}
	{-parent "" "" "."}
	{-title "" "" ""}
    }
    if { [string equal $type "open"] } {
	lappend specs {-multiple "" "" "0"}
    }

    set data(-multiple) 0
    # 2: default values depending on the type of the dialog
    #
    if {![info exists data(selectPath)]} {
	# first time the dialog has been popped up
	set data(selectPath) [pwd]
	set data(selectFile) ""
    }

    # 3: parse the arguments
    #
    tclParseConfigSpec ::tk::dialog::file::$dataName $specs "" $argList

    if {[string equal $data(-title) ""]} {
	if {[string equal $type "open"]} {
	    if {$data(-multiple) != 0} {
		set data(-title) "[mc {Open Multiple Files}]"
	    } else {
	    set data(-title) [mc "Open"]
	    }
	} else {
	    set data(-title) [mc "Save As"]
	}
    }

    # 4: set the default directory and selection according to the -initial
    #    settings
    #
    if {[string compare $data(-initialdir) ""]} {
	if {[file isdirectory $data(-initialdir)]} {
	    set data(selectPath) [lindex [glob $data(-initialdir)] 0]
	} else {
	    set data(selectPath) [pwd]
	}

	# Convert the initialdir to an absolute path name.

	set old [pwd]
	cd $data(selectPath)
	set data(selectPath) [pwd]
	cd $old
    }
    set data(selectFile) $data(-initialfile)

    # 5. Parse the -filetypes option. It is not used by the motif
    #    file dialog, but we check for validity of the value to make sure
    #    the application code also runs fine with the TK file dialog.
    #
    set data(-filetypes) [::tk::FDGetFileTypes $data(-filetypes)]

    if {![info exists data(filter)]} {
	set data(filter) *
    }
    if {![winfo exists $data(-parent)]} {
	error "bad window path name \"$data(-parent)\""
    }
}

# ::tk::MotifFDialog_BuildUI --
#
#	Builds the UI components of the Motif file dialog.
#
# Arguments:
# 	w		Pathname of the dialog to build.
#
# Results:
# 	None.

proc ::tk::MotifFDialog_BuildUI {w} {
    set dataName [lindex [split $w .] end]
    upvar ::tk::dialog::file::$dataName data

    # Create the dialog toplevel and internal frames.
    #
    toplevel $w -class TkMotifFDialog
    set top [frame $w.top -relief raised -bd 1]
    set bot [frame $w.bot -relief raised -bd 1]

    pack $w.bot -side bottom -fill x
    pack $w.top -side top -expand yes -fill both

    set f1 [frame $top.f1]
    set f2 [frame $top.f2]
    set f3 [frame $top.f3]

    pack $f1 -side top    -fill x
    pack $f3 -side bottom -fill x
    pack $f2 -expand yes -fill both

    set f2a [frame $f2.a]
    set f2b [frame $f2.b]

    grid $f2a -row 0 -column 0 -rowspan 1 -columnspan 1 -padx 4 -pady 4 \
	-sticky news
    grid $f2b -row 0 -column 1 -rowspan 1 -columnspan 1 -padx 4 -pady 4 \
	-sticky news
    grid rowconfig $f2 0    -minsize 0   -weight 1
    grid columnconfig $f2 0 -minsize 0   -weight 1
    grid columnconfig $f2 1 -minsize 150 -weight 2

    # The Filter box
    #
    bind [::tk::AmpWidget label $f1.lab -text [mc "Fil&ter:"] -anchor w] \
	<<AltUnderlined>> [list focus $f1.ent]
    entry $f1.ent
    pack $f1.lab -side top -fill x -padx 6 -pady 4
    pack $f1.ent -side top -fill x -padx 4 -pady 0
    set data(fEnt) $f1.ent

    # The file and directory lists
    #
    set data(dList) [MotifFDialog_MakeSList $w $f2a \
	    [mc "&Directory:"] DList]
    set data(fList) [MotifFDialog_MakeSList $w $f2b \
	    [mc "Fi&les:"]     FList]

    # The Selection box
    #
    bind [::tk::AmpWidget label $f3.lab -text [mc "&Selection:"] -anchor w] \
	<<AltUnderlined>> [list focus $f3.ent]
    entry $f3.ent
    pack $f3.lab -side top -fill x -padx 6 -pady 0
    pack $f3.ent -side top -fill x -padx 4 -pady 4
    set data(sEnt) $f3.ent

    # The buttons
    #
    set maxWidth [::tk::mcmaxamp &OK &Filter &Cancel]
    set maxWidth [expr {$maxWidth<6?6:$maxWidth}]
    set data(okBtn) [::tk::AmpWidget button $bot.ok -text [mc "&OK"] \
	    -width $maxWidth \
	    -command [list tk::MotifFDialog_OkCmd $w]]
    set data(filterBtn) [::tk::AmpWidget button $bot.filter -text [mc "&Filter"] \
	    -width $maxWidth \
	    -command [list tk::MotifFDialog_FilterCmd $w]]
    set data(cancelBtn) [::tk::AmpWidget button $bot.cancel -text [mc "&Cancel"] \
	    -width $maxWidth \
	    -command [list tk::MotifFDialog_CancelCmd $w]]

    pack $bot.ok $bot.filter $bot.cancel -padx 10 -pady 10 -expand yes \
	-side left

    # Create the bindings:
    #
    bind $w <Alt-Key> [list ::tk::AltKeyInDialog $w %A]

    bind $data(fEnt) <Return> [list tk::MotifFDialog_ActivateFEnt $w]
    bind $data(sEnt) <Return> [list tk::MotifFDialog_ActivateSEnt $w]

    wm protocol $w WM_DELETE_WINDOW [list tk::MotifFDialog_CancelCmd $w]
}

proc ::tk::MotifFDialog_SetListMode {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    if {$data(-multiple) != 0} {
	set selectmode extended
    } else {
	set selectmode browse
    }
    set f $w.top.f2.b
    $f.l configure -selectmode $selectmode
}

# ::tk::MotifFDialog_MakeSList --
#
#	Create a scrolled-listbox and set the keyboard accelerator
#	bindings so that the list selection follows what the user
#	types.
#
# Arguments:
#	w		Pathname of the dialog box.
#	f		Frame widget inside which to create the scrolled
#			listbox. This frame widget already exists.
#	label		The string to display on top of the listbox.
#	under		Sets the -under option of the label.
#	cmdPrefix	Specifies procedures to call when the listbox is
#			browsed or activated.

proc ::tk::MotifFDialog_MakeSList {w f label cmdPrefix} {
    bind [::tk::AmpWidget label $f.lab -text $label -anchor w] \
	<<AltUnderlined>> [list focus $f.l]
    listbox $f.l -width 12 -height 5 -exportselection 0\
	-xscrollcommand [list $f.h set]	-yscrollcommand [list $f.v set]
    scrollbar $f.v -orient vertical   -takefocus 0 -command [list $f.l yview]
    scrollbar $f.h -orient horizontal -takefocus 0 -command [list $f.l xview]
    grid $f.lab -row 0 -column 0 -sticky news -rowspan 1 -columnspan 2 \
	-padx 2 -pady 2
    grid $f.l -row 1 -column 0 -rowspan 1 -columnspan 1 -sticky news
    grid $f.v -row 1 -column 1 -rowspan 1 -columnspan 1 -sticky news
    grid $f.h -row 2 -column 0 -rowspan 1 -columnspan 1 -sticky news

    grid rowconfig    $f 0 -weight 0 -minsize 0
    grid rowconfig    $f 1 -weight 1 -minsize 0
    grid columnconfig $f 0 -weight 1 -minsize 0

    # bindings for the listboxes
    #
    set list $f.l
    bind $list <<ListboxSelect>> [list tk::MotifFDialog_Browse$cmdPrefix $w]
    bind $list <Double-ButtonRelease-1> \
	    [list tk::MotifFDialog_Activate$cmdPrefix $w]
    bind $list <Return>	"tk::MotifFDialog_Browse$cmdPrefix [list $w]; \
	    tk::MotifFDialog_Activate$cmdPrefix [list $w]"

    bindtags $list [list Listbox $list [winfo toplevel $list] all]
    ListBoxKeyAccel_Set $list

    return $f.l
}

# ::tk::MotifFDialog_InterpFilter --
#
#	Interpret the string in the filter entry into two components:
#	the directory and the pattern. If the string is a relative
#	pathname, give a warning to the user and restore the pattern
#	to original.
#
# Arguments:
#	w		pathname of the dialog box.
#
# Results:
# 	A list of two elements. The first element is the directory
# 	specified # by the filter. The second element is the filter
# 	pattern itself.

proc ::tk::MotifFDialog_InterpFilter {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    set text [string trim [$data(fEnt) get]]

    # Perform tilde substitution
    #
    set badTilde 0
    if {[string equal [string index $text 0] ~]} {
	set list [file split $text]
	set tilde [lindex $list 0]
	if {[catch {set tilde [glob $tilde]}]} {
	    set badTilde 1
	} else {
	    set text [eval file join [concat $tilde [lrange $list 1 end]]]
	}
    }

    # If the string is a relative pathname, combine it
    # with the current selectPath.

    set relative 0
    if {[string equal [file pathtype $text] "relative"]} {
	set relative 1
    } elseif {$badTilde} {
	set relative 1	
    }

    if {$relative} {
	tk_messageBox -icon warning -type ok \
	    -message "\"$text\" must be an absolute pathname"

	$data(fEnt) delete 0 end
	$data(fEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) \
		$data(filter)]

	return [list $data(selectPath) $data(filter)]
    }

    set resolved [::tk::dialog::file::JoinFile [file dirname $text] [file tail $text]]

    if {[file isdirectory $resolved]} {
	set dir $resolved
	set fil $data(filter)
    } else {
	set dir [file dirname $resolved]
	set fil [file tail    $resolved]
    }

    return [list $dir $fil]
}

# ::tk::MotifFDialog_Update
#
#	Load the files and synchronize the "filter" and "selection" fields
#	boxes.
#
# Arguments:
# 	w 		pathname of the dialog box.
#
# Results:
#	None.

proc ::tk::MotifFDialog_Update {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    $data(fEnt) delete 0 end
    $data(fEnt) insert 0 \
            [::tk::dialog::file::JoinFile $data(selectPath) $data(filter)]
    $data(sEnt) delete 0 end
    $data(sEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) \
	    $data(selectFile)]
 
    MotifFDialog_LoadFiles $w
}

# ::tk::MotifFDialog_LoadFiles --
#
#	Loads the files and directories into the two listboxes according
#	to the filter setting.
#
# Arguments:
# 	w 		pathname of the dialog box.
#
# Results:
#	None.

proc ::tk::MotifFDialog_LoadFiles {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    $data(dList) delete 0 end
    $data(fList) delete 0 end

    set appPWD [pwd]
    if {[catch {cd $data(selectPath)}]} {
	cd $appPWD

	$data(dList) insert end ".."
	return
    }

    # Make the dir and file lists
    #
    # For speed we only have one glob, which reduces the file system
    # calls (good for slow NFS networks).
    #
    # We also do two smaller sorts (files + dirs) instead of one large sort,
    # which gives a small speed increase.
    #
    set top 0
    set dlist ""
    set flist ""
    foreach f [glob -nocomplain .* *] {
	if {[file isdir ./$f]} {
	    lappend dlist $f
	} else {
            foreach pat $data(filter) {
                if {[string match $pat $f]} {
		if {[string match .* $f]} {
		    incr top
		}
		lappend flist $f
                    break
	    }
            }
	}
    }
    eval [list $data(dList) insert end] [lsort -dictionary $dlist]
    eval [list $data(fList) insert end] [lsort -dictionary $flist]

    # The user probably doesn't want to see the . files. We adjust the view
    # so that the listbox displays all the non-dot files
    $data(fList) yview $top

    cd $appPWD
}

# ::tk::MotifFDialog_BrowseDList --
#
#	This procedure is called when the directory list is browsed
#	(clicked-over) by the user.
#
# Arguments:
# 	w		The pathname of the dialog box.
#
# Results:
#	None.	

proc ::tk::MotifFDialog_BrowseDList {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    focus $data(dList)
    if {[string equal [$data(dList) curselection] ""]} {
	return
    }
    set subdir [$data(dList) get [$data(dList) curselection]]
    if {[string equal $subdir ""]} {
	return
    }

    $data(fList) selection clear 0 end

    set list [MotifFDialog_InterpFilter $w]
    set data(filter) [lindex $list 1]

    switch -- $subdir {
	. {
	    set newSpec [::tk::dialog::file::JoinFile $data(selectPath) $data(filter)]
	}
	.. {
	    set newSpec [::tk::dialog::file::JoinFile [file dirname $data(selectPath)] \
		$data(filter)]
	}
	default {
	    set newSpec [::tk::dialog::file::JoinFile [::tk::dialog::file::JoinFile \
		    $data(selectPath) $subdir] $data(filter)]
	}
    }

    $data(fEnt) delete 0 end
    $data(fEnt) insert 0 $newSpec
}

# ::tk::MotifFDialog_ActivateDList --
#
#	This procedure is called when the directory list is activated
#	(double-clicked) by the user.
#
# Arguments:
# 	w		The pathname of the dialog box.
#
# Results:
#	None.	

proc ::tk::MotifFDialog_ActivateDList {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    if {[string equal [$data(dList) curselection] ""]} {
	return
    }
    set subdir [$data(dList) get [$data(dList) curselection]]
    if {[string equal $subdir ""]} {
	return
    }

    $data(fList) selection clear 0 end

    switch -- $subdir {
	. {
	    set newDir $data(selectPath)
	}
	.. {
	    set newDir [file dirname $data(selectPath)]
	}
	default {
	    set newDir [::tk::dialog::file::JoinFile $data(selectPath) $subdir]
	}
    }

    set data(selectPath) $newDir
    MotifFDialog_Update $w

    if {[string compare $subdir ..]} {
	$data(dList) selection set 0
	$data(dList) activate 0
    } else {
	$data(dList) selection set 1
	$data(dList) activate 1
    }
}

# ::tk::MotifFDialog_BrowseFList --
#
#	This procedure is called when the file list is browsed
#	(clicked-over) by the user.
#
# Arguments:
# 	w		The pathname of the dialog box.
#
# Results:
#	None.	

proc ::tk::MotifFDialog_BrowseFList {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    focus $data(fList)
    set data(selectFile) ""
    foreach item [$data(fList) curselection] {
	lappend data(selectFile) [$data(fList) get $item]
    }
    if {[llength $data(selectFile)] == 0} {
	return
    }

    $data(dList) selection clear 0 end

    $data(fEnt) delete 0 end
    $data(fEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) \
	    $data(filter)]
    $data(fEnt) xview end
 
    # if it's a multiple selection box, just put in the filenames 
    # otherwise put in the full path as usual 
    $data(sEnt) delete 0 end
    if {$data(-multiple) != 0} {
	$data(sEnt) insert 0 $data(selectFile)
    } else {
	$data(sEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) \
				  [lindex $data(selectFile) 0]]
    }
    $data(sEnt) xview end
}

# ::tk::MotifFDialog_ActivateFList --
#
#	This procedure is called when the file list is activated
#	(double-clicked) by the user.
#
# Arguments:
# 	w		The pathname of the dialog box.
#
# Results:
#	None.	

proc ::tk::MotifFDialog_ActivateFList {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    if {[string equal [$data(fList) curselection] ""]} {
	return
    }
    set data(selectFile) [$data(fList) get [$data(fList) curselection]]
    if {[string equal $data(selectFile) ""]} {
	return
    } else {
	MotifFDialog_ActivateSEnt $w
    }
}

# ::tk::MotifFDialog_ActivateFEnt --
#
#	This procedure is called when the user presses Return inside
#	the "filter" entry. It updates the dialog according to the
#	text inside the filter entry.
#
# Arguments:
# 	w		The pathname of the dialog box.
#
# Results:
#	None.	

proc ::tk::MotifFDialog_ActivateFEnt {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    set list [MotifFDialog_InterpFilter $w]
    set data(selectPath) [lindex $list 0]
    set data(filter)    [lindex $list 1]

    MotifFDialog_Update $w
}

# ::tk::MotifFDialog_ActivateSEnt --
#
#	This procedure is called when the user presses Return inside
#	the "selection" entry. It sets the ::tk::Priv(selectFilePath) 
#	variable so that the vwait loop in tk::MotifFDialog will be
#	terminated.
#
# Arguments:
# 	w		The pathname of the dialog box.
#
# Results:
#	None.	

proc ::tk::MotifFDialog_ActivateSEnt {w} {
    variable ::tk::Priv
    upvar ::tk::dialog::file::[winfo name $w] data

    set selectFilePath [string trim [$data(sEnt) get]]

    if {[string equal $selectFilePath ""]} {
	MotifFDialog_FilterCmd $w
	return
    }

    if {$data(-multiple) == 0} {
	set selectFilePath [list $selectFilePath]
    }

    if {[file isdirectory [lindex $selectFilePath 0]]} {
	set data(selectPath) [lindex [glob $selectFilePath] 0]
	set data(selectFile) ""
	MotifFDialog_Update $w
	return
    }

    set newFileList ""
    foreach item $selectFilePath {
	if {[string compare [file pathtype $item] "absolute"]} {
	    set item [file join $data(selectPath) $item]
	} elseif {![file exists [file dirname $item]]} {
	    tk_messageBox -icon warning -type ok \
		    -message [mc {Directory "%1$s" does not exist.} \
		    [file dirname $item]]
	    return
	}

	if {![file exists $item]} {
	    if {[string equal $data(type) open]} {
		tk_messageBox -icon warning -type ok \
			-message [mc {File "%1$s" does not exist.} $item]
		return
	    }
	} else {
	    if {[string equal $data(type) save]} {
		set message [format %s%s \
			[mc {File "%1$s" already exists.\n\n} \
			$selectFilePath] \
			[mc {Replace existing file?}]]
		set answer [tk_messageBox -icon warning -type yesno \
			-message $message]
		if {[string equal $answer "no"]} {
		    return
		}
	    }
	}
	
	lappend newFileList $item
    }

    if {$data(-multiple) != 0} {
	set Priv(selectFilePath) $newFileList
    } else {
	set Priv(selectFilePath) [lindex $newFileList 0]
    }

    # Set selectFile and selectPath to first item in list
    set Priv(selectFile)     [file tail    [lindex $newFileList 0]]
    set Priv(selectPath)     [file dirname [lindex $newFileList 0]]
}


proc ::tk::MotifFDialog_OkCmd {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    MotifFDialog_ActivateSEnt $w
}

proc ::tk::MotifFDialog_FilterCmd {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    MotifFDialog_ActivateFEnt $w
}

proc ::tk::MotifFDialog_CancelCmd {w} {
    variable ::tk::Priv

    set Priv(selectFilePath) ""
    set Priv(selectFile)     ""
    set Priv(selectPath)     ""
}

proc ::tk::ListBoxKeyAccel_Set {w} {
    bind Listbox <Any-KeyPress> ""
    bind $w <Destroy> [list tk::ListBoxKeyAccel_Unset $w]
    bind $w <Any-KeyPress> [list tk::ListBoxKeyAccel_Key $w %A]
}

proc ::tk::ListBoxKeyAccel_Unset {w} {
    variable ::tk::Priv

    catch {after cancel $Priv(lbAccel,$w,afterId)}
    catch {unset Priv(lbAccel,$w)}
    catch {unset Priv(lbAccel,$w,afterId)}
}

# ::tk::ListBoxKeyAccel_Key--
#
#	This procedure maintains a list of recently entered keystrokes
#	over a listbox widget. It arranges an idle event to move the
#	selection of the listbox to the entry that begins with the
#	keystrokes.
#
# Arguments:
# 	w		The pathname of the listbox.
#	key		The key which the user just pressed.
#
# Results:
#	None.	

proc ::tk::ListBoxKeyAccel_Key {w key} {
    variable ::tk::Priv

    if { $key == "" } {
	return
    }
    append Priv(lbAccel,$w) $key
    ListBoxKeyAccel_Goto $w $Priv(lbAccel,$w)
    catch {
	after cancel $Priv(lbAccel,$w,afterId)
    }
    set Priv(lbAccel,$w,afterId) [after 500 \
	    [list tk::ListBoxKeyAccel_Reset $w]]
}

proc ::tk::ListBoxKeyAccel_Goto {w string} {
    variable ::tk::Priv

    set string [string tolower $string]
    set end [$w index end]
    set theIndex -1

    for {set i 0} {$i < $end} {incr i} {
	set item [string tolower [$w get $i]]
	if {[string compare $string $item] >= 0} {
	    set theIndex $i
	}
	if {[string compare $string $item] <= 0} {
	    set theIndex $i
	    break
	}
    }

    if {$theIndex >= 0} {
	$w selection clear 0 end
	$w selection set $theIndex $theIndex
	$w activate $theIndex
	$w see $theIndex
	event generate $w <<ListboxSelect>>
    }
}

proc ::tk::ListBoxKeyAccel_Reset {w} {
    variable ::tk::Priv

    catch {unset Priv(lbAccel,$w)}
}

proc ::tk_getFileType {} {
    variable ::tk::Priv

    return $Priv(selectFileType)
}

@


1.4
log
@touched all sources to ease next import
@
text
@d5 1
a5 1
#	"tk_strictMotif" flag is set.
d7 1
a7 1
# RCS: @@(#) $Id: xmfbox.tcl,v 1.7.6.2 2000/09/26 16:08:52 spolk Exp $
d19 1
a19 1
# tkMotifFDialog --
d29 8
a36 4
#	A list of two members. The first member is the absolute
#	pathname of the selected file or "" if user hits cancel. The
#	second member is the name of the selected file type, or ""
#	which stands for "default file type"
d38 2
a39 2
proc tkMotifFDialog {type args} {
    global tkPriv
d43 1
a43 1
    set w [tkMotifFDialog_Create $dataName $type $args]
d56 1
a56 1
    tkwait variable tkPriv(selectFilePath)
d59 1
a59 1
    return $tkPriv(selectFilePath)
d62 1
a62 1
# tkMotifFDialog_Create --
d68 1
a68 1
#	This procedure is used by tkMotifFDialog to create the
d81 1
a81 2
proc tkMotifFDialog_Create {dataName type argList} {
    global tkPriv
d84 1
a84 1
    tkMotifFDialog_Config $dataName $type $argList
d95 1
a95 1
	tkMotifFDialog_BuildUI $w
d98 1
a98 1
	tkMotifFDialog_BuildUI $w
d108 1
d110 6
a115 1
    wm transient $w $data(-parent)
d117 6
a122 1
    tkMotifFDialog_Update $w
d134 69
a202 1
# tkMotifFDialog_Config --
d214 1
a214 1
proc tkMotifFDialog_Config {dataName type argList} {
d229 3
d233 1
d248 5
a252 1
	    set data(-title) "Open"
d254 1
a254 1
	    set data(-title) "Save As"
d263 1
a263 1
	    set data(selectPath) [glob $data(-initialdir)]
d281 1
a281 1
    set data(-filetypes) [tkFDGetFileTypes $data(-filetypes)]
d291 1
a291 1
# tkMotifFDialog_BuildUI --
d301 1
a301 1
proc tkMotifFDialog_BuildUI {w} {
d335 2
a336 1
    label $f1.lab -text "Filter:" -under 3 -anchor w
d344 4
a347 2
    set data(dList) [tkMotifFDialog_MakeSList $w $f2a Directory: 0 DList]
    set data(fList) [tkMotifFDialog_MakeSList $w $f2b Files:     2 FList]
d351 2
a352 1
    label $f3.lab -text "Selection:" -under 0 -anchor w
d360 11
a370 6
    set data(okBtn) [button $bot.ok     -text OK     -width 6 -under 0 \
	-command [list tkMotifFDialog_OkCmd $w]]
    set data(filterBtn) [button $bot.filter -text Filter -width 6 -under 0 \
	-command [list tkMotifFDialog_FilterCmd $w]]
    set data(cancelBtn) [button $bot.cancel -text Cancel -width 6 -under 0 \
	-command [list tkMotifFDialog_CancelCmd $w]]
d377 4
a380 4
    bind $w <Alt-t> [list focus $data(fEnt)]
    bind $w <Alt-d> [list focus $data(dList)]
    bind $w <Alt-l> [list focus $data(fList)]
    bind $w <Alt-s> [list focus $data(sEnt)]
d382 2
a383 3
    bind $w <Alt-o> [list tkButtonInvoke $bot.ok]
    bind $w <Alt-f> [list tkButtonInvoke $bot.filter]
    bind $w <Alt-c> [list tkButtonInvoke $bot.cancel]
d385 2
a386 2
    bind $data(fEnt) <Return> [list tkMotifFDialog_ActivateFEnt $w]
    bind $data(sEnt) <Return> [list tkMotifFDialog_ActivateSEnt $w]
d388 7
a394 1
    wm protocol $w WM_DELETE_WINDOW [list tkMotifFDialog_CancelCmd $w]
d397 1
a397 1
# tkMotifFDialog_MakeSList --
d412 4
a415 3
proc tkMotifFDialog_MakeSList {w f label under cmdPrefix} {
    label $f.lab -text $label -under $under -anchor w
    listbox $f.l -width 12 -height 5 -selectmode browse -exportselection 0\
d432 1
a432 5
    bind $list <Up>		[list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <Down>		[list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <space>		[list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <1>		[list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <B1-Motion>	[list tkMotifFDialog_Browse$cmdPrefix $w]
d434 3
a436 3
	    [list tkMotifFDialog_Activate$cmdPrefix $w]
    bind $list <Return>    "tkMotifFDialog_Browse$cmdPrefix [list $w]; \
	    tkMotifFDialog_Activate$cmdPrefix [list $w]"
d439 1
a439 1
    tkListBoxKeyAccel_Set $list
d444 1
a444 1
# tkMotifFDialog_InterpFilter --
d459 1
a459 1
proc tkMotifFDialog_InterpFilter {w} {
d511 1
a511 1
# tkMotifFDialog_Update
d522 1
a522 1
proc tkMotifFDialog_Update {w} {
d526 2
a527 1
    $data(fEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) $data(filter)]
d532 1
a532 1
    tkMotifFDialog_LoadFiles $w
d535 1
a535 1
# tkMotifFDialog_LoadFiles --
d546 1
a546 1
proc tkMotifFDialog_LoadFiles {w} {
d560 4
a563 1
    # Make the dir list
d565 2
a566 6
    foreach f [lsort -dictionary [glob -nocomplain .* *]] {
	if {[file isdir ./$f]} {
	    $data(dList) insert end $f
	}
    }
    # Make the file list
a567 7
    if {[string equal $data(filter) *]} {
	set files [lsort -dictionary [glob -nocomplain .* *]]
    } else {
	set files [lsort -dictionary \
	    [glob -nocomplain $data(filter)]]
    }

d569 13
a581 6
    foreach f $files {
	if {![file isdir ./$f]} {
	    regsub {^[.]/} $f "" f
	    $data(fList) insert end $f
	    if {[string match .* $f]} {
		incr top
d583 1
d586 2
d596 1
a596 1
# tkMotifFDialog_BrowseFList --
d607 1
a607 1
proc tkMotifFDialog_BrowseDList {w} {
d621 1
a621 1
    set list [tkMotifFDialog_InterpFilter $w]
d642 1
a642 1
# tkMotifFDialog_ActivateDList --
d653 1
a653 1
proc tkMotifFDialog_ActivateDList {w} {
d679 1
a679 1
    tkMotifFDialog_Update $w
d690 1
a690 1
# tkMotifFDialog_BrowseFList --
d701 1
a701 1
proc tkMotifFDialog_BrowseFList {w} {
d705 3
a707 2
    if {[string equal [$data(fList) curselection] ""]} {
	return
d709 1
a709 2
    set data(selectFile) [$data(fList) get [$data(fList) curselection]]
    if {[string equal $data(selectFile) ""]} {
d716 2
a717 1
    $data(fEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) $data(filter)]
d720 2
d723 6
a728 2
    $data(sEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) \
	    $data(selectFile)]
d732 1
a732 1
# tkMotifFDialog_ActivateFList --
d743 1
a743 1
proc tkMotifFDialog_ActivateFList {w} {
d753 1
a753 1
	tkMotifFDialog_ActivateSEnt $w
d757 1
a757 1
# tkMotifFDialog_ActivateFEnt --
d769 1
a769 1
proc tkMotifFDialog_ActivateFEnt {w} {
d772 1
a772 1
    set list [tkMotifFDialog_InterpFilter $w]
d776 1
a776 1
    tkMotifFDialog_Update $w
d779 1
a779 1
# tkMotifFDialog_ActivateSEnt --
d782 2
a783 2
#	the "selection" entry. It sets the tkPriv(selectFilePath) global
#	variable so that the vwait loop in tkMotifFDialog will be
d792 2
a793 2
proc tkMotifFDialog_ActivateSEnt {w} {
    global tkPriv
a796 2
    set selectFile     [file tail    $selectFilePath]
    set selectPath     [file dirname $selectFilePath]
d799 1
a799 1
	tkMotifFDialog_FilterCmd $w
d803 2
a804 5
    if {[file isdirectory $selectFilePath]} {
	set data(selectPath) [glob $selectFilePath]
	set data(selectFile) ""
	tkMotifFDialog_Update $w
	return
d807 4
a810 3
    if {[string compare [file pathtype $selectFilePath] "absolute"]} {
	tk_messageBox -icon warning -type ok \
	    -message "\"$selectFilePath\" must be an absolute pathname"
d814 5
a818 8
    if {![file exists $selectPath]} {
	tk_messageBox -icon warning -type ok \
	    -message "Directory \"$selectPath\" does not exist."
	return
    }

    if {![file exists $selectFilePath]} {
	if {[string equal $data(type) open]} {
d820 2
a821 1
		-message "File \"$selectFilePath\" does not exist."
d824 5
a828 8
    } else {
	if {[string equal $data(type) save]} {
	    set message [format %s%s \
		"File \"$selectFilePath\" already exists.\n\n" \
		"Replace existing file?"]
	    set answer [tk_messageBox -icon warning -type yesno \
		-message $message]
	    if {[string equal $answer "no"]} {
d831 12
d844 2
d848 9
a856 3
    set tkPriv(selectFilePath) $selectFilePath
    set tkPriv(selectFile)     $selectFile
    set tkPriv(selectPath)     $selectPath
d860 1
a860 1
proc tkMotifFDialog_OkCmd {w} {
d863 1
a863 1
    tkMotifFDialog_ActivateSEnt $w
d866 1
a866 1
proc tkMotifFDialog_FilterCmd {w} {
d869 1
a869 1
    tkMotifFDialog_ActivateFEnt $w
d872 2
a873 2
proc tkMotifFDialog_CancelCmd {w} {
    global tkPriv
d875 3
a877 3
    set tkPriv(selectFilePath) ""
    set tkPriv(selectFile)     ""
    set tkPriv(selectPath)     ""
d880 1
a880 1
proc tkListBoxKeyAccel_Set {w} {
d882 2
a883 2
    bind $w <Destroy> [list tkListBoxKeyAccel_Unset $w]
    bind $w <Any-KeyPress> [list tkListBoxKeyAccel_Key $w %A]
d886 2
a887 2
proc tkListBoxKeyAccel_Unset {w} {
    global tkPriv
d889 3
a891 3
    catch {after cancel $tkPriv(lbAccel,$w,afterId)}
    catch {unset tkPriv(lbAccel,$w)}
    catch {unset tkPriv(lbAccel,$w,afterId)}
d894 1
a894 1
# tkListBoxKeyAccel_Key--
d908 2
a909 2
proc tkListBoxKeyAccel_Key {w key} {
    global tkPriv
d911 5
a915 2
    append tkPriv(lbAccel,$w) $key
    tkListBoxKeyAccel_Goto $w $tkPriv(lbAccel,$w)
d917 1
a917 1
	after cancel $tkPriv(lbAccel,$w,afterId)
d919 2
a920 2
    set tkPriv(lbAccel,$w,afterId) [after 500 \
	    [list tkListBoxKeyAccel_Reset $w]]
d923 2
a924 2
proc tkListBoxKeyAccel_Goto {w string} {
    global tkPriv
d946 1
d950 2
a951 2
proc tkListBoxKeyAccel_Reset {w} {
    global tkPriv
d953 1
a953 1
    catch {unset tkPriv(lbAccel,$w)}
d956 2
d959 2
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
# SCCS: @@(#) xmfbox.tcl 1.6 97/10/01 15:06:07
d10 1
d14 3
a16 1
#
d24 3
a26 1
# Return value:
d28 1
d33 35
d69 9
a77 1
proc tkMotifFDialog {args} {
d79 1
a79 8
    set w __tk_filedialog
    upvar #0 $w data

    if {![string compare [lindex [info level 0] 0] tk_getOpenFile]} {
	set type open
    } else {
	set type save
    }
d81 1
a81 1
    tkMotifFDialog_Config $w $type $args
d83 2
a84 2
    if {![string compare $data(-parent) .]} {
        set w .$w
d86 1
a86 1
        set w $data(-parent).$w
d92 1
a92 1
	tkMotifFDialog_Create $w
d95 1
a95 1
	tkMotifFDialog_Create $w
d105 1
d110 1
a110 1
    # 5. Withdraw the window, then update all the geometry information
d112 1
a112 1
    # display and de-iconify it.
d114 1
a114 8
    wm withdraw $w
    update idletasks
    set x [expr {[winfo screenwidth $w]/2 - [winfo reqwidth $w]/2 \
	    - [winfo vrootx [winfo parent $w]]}]
    set y [expr {[winfo screenheight $w]/2 - [winfo reqheight $w]/2 \
	    - [winfo vrooty [winfo parent $w]]}]
    wm geom $w +$x+$y
    wm deiconify $w
d117 2
a118 1
    # 6. Set a grab and claim the focus too.
d120 11
a130 9
    set oldFocus [focus]
    set oldGrab [grab current $w]
    if {$oldGrab != ""} {
	set grabStatus [grab status $oldGrab]
    }
    grab $w
    focus $data(sEnt)
    $data(sEnt) select from 0
    $data(sEnt) select to   end
d132 2
a133 22
    # 7. Wait for the user to respond, then restore the focus and
    # return the index of the selected button.  Restore the focus
    # before deleting the window, since otherwise the window manager
    # may take the focus away so we can't redirect it.  Finally,
    # restore any grab that was in effect.

    tkwait variable tkPriv(selectFilePath)
    catch {focus $oldFocus}
    grab release $w
    wm withdraw $w
    if {$oldGrab != ""} {
	if {$grabStatus == "global"} {
	    grab -global $oldGrab
	} else {
	    grab $oldGrab
	}
    }
    return $tkPriv(selectFilePath)
}

proc tkMotifFDialog_Config {w type argList} {
    upvar #0 $w data
d158 1
a158 1
    tclParseConfigSpec $w $specs "" $argList
d160 2
a161 2
    if {![string compare $data(-title) ""]} {
	if {![string compare $type "open"]} {
d201 11
a211 1
proc tkMotifFDialog_Create {w} {
d213 1
a213 1
    upvar #0 $dataName data
d215 1
a215 1
    # 1: Create the dialog ...
d267 1
a267 1
	-command "tkMotifFDialog_OkCmd $w"]
d269 1
a269 1
	-command "tkMotifFDialog_FilterCmd $w"]
d271 1
a271 1
	-command "tkMotifFDialog_CancelCmd $w"]
d278 4
a281 4
    bind $w <Alt-t> "focus $data(fEnt)"
    bind $w <Alt-d> "focus $data(dList)"
    bind $w <Alt-l> "focus $data(fList)"
    bind $w <Alt-s> "focus $data(sEnt)"
d283 3
a285 3
    bind $w <Alt-o> "tkButtonInvoke $bot.ok    "
    bind $w <Alt-f> "tkButtonInvoke $bot.filter"
    bind $w <Alt-c> "tkButtonInvoke $bot.cancel"
d287 2
a288 2
    bind $data(fEnt) <Return> "tkMotifFDialog_ActivateFEnt $w"
    bind $data(sEnt) <Return> "tkMotifFDialog_ActivateSEnt $w"
d290 1
a290 1
    wm protocol $w WM_DELETE_WINDOW "tkMotifFDialog_CancelCmd $w"
d293 16
a308 1
proc tkMotifFDialog_MakeSList {w f label under cmd} {
d311 3
a313 6
	-xscrollcommand "$f.h set" \
	-yscrollcommand "$f.v set" 
    scrollbar $f.v -orient vertical   -takefocus 0 \
	-command "$f.l yview"
    scrollbar $f.h -orient horizontal -takefocus 0 \
	-command "$f.l xview"
d327 9
a335 7
    bind $list <Up>        "tkMotifFDialog_Browse$cmd $w"
    bind $list <Down>      "tkMotifFDialog_Browse$cmd $w"
    bind $list <space>     "tkMotifFDialog_Browse$cmd $w"
    bind $list <1>         "tkMotifFDialog_Browse$cmd $w"
    bind $list <B1-Motion> "tkMotifFDialog_Browse$cmd $w"
    bind $list <Double-1>  "tkMotifFDialog_Activate$cmd $w"
    bind $list <Return>    "tkMotifFDialog_Browse$cmd $w; tkMotifFDialog_Activate$cmd $w"
d337 1
a337 1
    bindtags $list "Listbox $list [winfo toplevel $list] all"
d343 160
d504 1
a504 1
    upvar #0 [winfo name $w] data
d507 1
a507 1
    if {![string compare [$data(dList) curselection] ""]} {
d511 1
a511 1
    if {![string compare $subdir ""]} {
d520 1
a520 1
    case $subdir {
d522 1
a522 1
	    set newSpec [file join $data(selectPath) $data(filter)]
d525 1
a525 1
	    set newSpec [file join [file dirname $data(selectPath)] \
d529 2
a530 1
	    set newSpec [file join $data(selectPath) $subdir $data(filter)]
d538 11
d550 1
a550 1
    upvar #0 [winfo name $w] data
d552 1
a552 1
    if {![string compare [$data(dList) curselection] ""]} {
d556 1
a556 1
    if {![string compare $subdir ""]} {
d562 1
a562 1
    case $subdir {
d570 1
a570 1
	    set newDir [file join $data(selectPath) $subdir]
d586 11
d598 1
a598 1
    upvar #0 [winfo name $w] data
d601 1
a601 1
    if {![string compare [$data(fList) curselection] ""]} {
d605 1
a605 1
    if {![string compare $data(selectFile) ""]} {
d612 1
a612 1
    $data(fEnt) insert 0 [file join $data(selectPath) $data(filter)]
d616 2
a617 1
    $data(sEnt) insert 0 [file join $data(selectPath) $data(selectFile)]
d621 11
d633 1
a633 1
    upvar #0 [winfo name $w] data
d635 1
a635 1
    if {![string compare [$data(fList) curselection] ""]} {
d639 1
a639 1
    if {![string compare $data(selectFile) ""]} {
d646 12
d659 1
a659 1
    upvar #0 [winfo name $w] data
d668 12
a679 28
proc tkMotifFDialog_InterpFilter {w} {
    upvar #0 [winfo name $w] data

    set text [string trim [$data(fEnt) get]]
    # Perform tilde substitution
    #
    if {![string compare [string index $text 0] ~]} {
	set list [file split $text]
	set tilde [lindex $list 0]
	catch {
	    set tilde [glob $tilde]
	}
	set text [eval file join [concat $tilde [lrange $list 1 end]]]
    }

    set resolved [file join [file dirname $text] [file tail $text]]

    if {[file isdirectory $resolved]} {
	set dir $resolved
	set fil $data(filter)
    } else {
	set dir [file dirname $resolved]
	set fil [file tail    $resolved]
    }

    return [list $dir $fil]
}

d683 1
a683 1
    upvar #0 [winfo name $w] data
d689 1
a689 2

    if {![string compare $selectFilePath ""]} {
d714 1
a714 1
	if {![string compare $data(type) open]} {
d720 1
a720 1
	if {![string compare $data(type) save]} {
d726 1
a726 1
	    if {![string compare $answer "no"]} {
d739 1
a739 1
    upvar #0 [winfo name $w] data
d745 1
a745 1
    upvar #0 [winfo name $w] data
a757 69
# tkMotifFDialog_Update
#
#	Load the files and synchronize the "filter" and "selection" fields
#	boxes.
#
# popup:
#	If this is true, then update the selection field according to the
#	"-selection" flag
#
proc tkMotifFDialog_Update {w} {
    upvar #0 [winfo name $w] data

    $data(fEnt) delete 0 end
    $data(fEnt) insert 0 [file join $data(selectPath) $data(filter)]
    $data(sEnt) delete 0 end
    $data(sEnt) insert 0 [file join $data(selectPath) $data(selectFile)]
 
    tkMotifFDialog_LoadFiles $w
}

proc tkMotifFDialog_LoadFiles {w} {
    upvar #0 [winfo name $w] data

    $data(dList) delete 0 end
    $data(fList) delete 0 end

    set appPWD [pwd]
    if {[catch {
	cd $data(selectPath)
    }]} {
	cd $appPWD

	$data(dList) insert end ".."
	return
    }

    # Make the dir list
    #
    foreach f [lsort -command tclSortNoCase [glob -nocomplain .* *]] {
	if {[file isdirectory $f]} {
	    $data(dList) insert end $f
	}
    }
    # Make the file list
    #
    if {![string compare $data(filter) *]} {
	set files [lsort -command tclSortNoCase [glob -nocomplain .* *]]
    } else {
	set files [lsort -command tclSortNoCase \
	    [glob -nocomplain $data(filter)]]
    }

    set top 0
    foreach f $files {
	if {![file isdir $f]} {
	    $data(fList) insert end $f
	    if {[string match .* $f]} {
		incr top
	    }
	}
    }

    # The user probably doesn't want to see the . files. We adjust the view
    # so that the listbox displays all the non-dot files
    $data(fList) yview $top

    cd $appPWD
}

d760 2
a761 2
    bind $w <Destroy> "tkListBoxKeyAccel_Unset $w"
    bind $w <Any-KeyPress> "tkListBoxKeyAccel_Key $w %A"
d772 14
d794 2
a795 1
    set tkPriv(lbAccel,$w,afterId) [after 500 tkListBoxKeyAccel_Reset $w]
d829 2
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d7 1
a7 1
# RCS: @@(#) $Id: xmfbox.tcl,v 1.7.6.2 2000/09/26 16:08:52 spolk Exp $
a9 1
# Copyright (c) 1998-2000 Scriptics Corporation
d13 1
a13 3

namespace eval ::tk::dialog {}
namespace eval ::tk::dialog::file {}
d21 1
a21 3
# Arguments:
#	type		"open" or "save"
#	args		Options parsed by the procedure.
a22 1
# Results:
d27 2
a28 2

proc tkMotifFDialog {type args} {
d30 2
a31 2
    set dataName __tk_filedialog
    upvar ::tk::dialog::file::$dataName data
d33 5
a37 41
    set w [tkMotifFDialog_Create $dataName $type $args]

    # Set a grab and claim the focus too.

    ::tk::SetFocusGrab $w $data(sEnt)
    $data(sEnt) selection range 0 end

    # Wait for the user to respond, then restore the focus and
    # return the index of the selected button.  Restore the focus
    # before deleting the window, since otherwise the window manager
    # may take the focus away so we can't redirect it.  Finally,
    # restore any grab that was in effect.

    tkwait variable tkPriv(selectFilePath)
    ::tk::RestoreFocusGrab $w $data(sEnt) withdraw

    return $tkPriv(selectFilePath)
}

# tkMotifFDialog_Create --
#
#	Creates the Motif file dialog (if it doesn't exist yet) and
#	initialize the internal data structure associated with the
#	dialog.
#
#	This procedure is used by tkMotifFDialog to create the
#	dialog. It's also used by the test suite to test the Motif
#	file dialog implementation. User code shouldn't call this
#	procedure directly.
#
# Arguments:
#	dataName	Name of the global "data" array for the file dialog.
#	type		"Save" or "Open"
#	argList		Options parsed by the procedure.
#
# Results:
#	Pathname of the file dialog.

proc tkMotifFDialog_Create {dataName type argList} {
    global tkPriv
    upvar ::tk::dialog::file::$dataName data
d39 1
a39 1
    tkMotifFDialog_Config $dataName $type $argList
d41 2
a42 2
    if {[string equal $data(-parent) .]} {
        set w .$dataName
d44 1
a44 1
        set w $data(-parent).$dataName
d50 1
a50 1
	tkMotifFDialog_BuildUI $w
d53 1
a53 1
	tkMotifFDialog_BuildUI $w
a62 1

d67 1
a67 1
    # Withdraw the window, then update all the geometry information
d69 1
a69 1
    # display (Motif style) and de-iconify it.
d71 8
a78 1
    ::tk::PlaceWindow $w
d81 30
a110 1
    return $w
d113 2
a114 14
# tkMotifFDialog_Config --
#
#	Iterates over the optional arguments to determine the option
#	values for the Motif file dialog; gives default values to
#	unspecified options.
#
# Arguments:
#	dataName	The name of the global variable in which
#			data for the file dialog is stored.
#	type		"Save" or "Open"
#	argList		Options parsed by the procedure.

proc tkMotifFDialog_Config {dataName type argList} {
    upvar ::tk::dialog::file::$dataName data
d139 1
a139 1
    tclParseConfigSpec ::tk::dialog::file::$dataName $specs "" $argList
d141 2
a142 2
    if {[string equal $data(-title) ""]} {
	if {[string equal $type "open"]} {
d182 1
a182 11
# tkMotifFDialog_BuildUI --
#
#	Builds the UI components of the Motif file dialog.
#
# Arguments:
# 	w		Pathname of the dialog to build.
#
# Results:
# 	None.

proc tkMotifFDialog_BuildUI {w} {
d184 1
a184 1
    upvar ::tk::dialog::file::$dataName data
d186 1
a186 1
    # Create the dialog toplevel and internal frames.
d238 1
a238 1
	-command [list tkMotifFDialog_OkCmd $w]]
d240 1
a240 1
	-command [list tkMotifFDialog_FilterCmd $w]]
d242 1
a242 1
	-command [list tkMotifFDialog_CancelCmd $w]]
d249 4
a252 4
    bind $w <Alt-t> [list focus $data(fEnt)]
    bind $w <Alt-d> [list focus $data(dList)]
    bind $w <Alt-l> [list focus $data(fList)]
    bind $w <Alt-s> [list focus $data(sEnt)]
d254 3
a256 3
    bind $w <Alt-o> [list tkButtonInvoke $bot.ok]
    bind $w <Alt-f> [list tkButtonInvoke $bot.filter]
    bind $w <Alt-c> [list tkButtonInvoke $bot.cancel]
d258 2
a259 2
    bind $data(fEnt) <Return> [list tkMotifFDialog_ActivateFEnt $w]
    bind $data(sEnt) <Return> [list tkMotifFDialog_ActivateSEnt $w]
d261 1
a261 1
    wm protocol $w WM_DELETE_WINDOW [list tkMotifFDialog_CancelCmd $w]
d264 1
a264 16
# tkMotifFDialog_MakeSList --
#
#	Create a scrolled-listbox and set the keyboard accelerator
#	bindings so that the list selection follows what the user
#	types.
#
# Arguments:
#	w		Pathname of the dialog box.
#	f		Frame widget inside which to create the scrolled
#			listbox. This frame widget already exists.
#	label		The string to display on top of the listbox.
#	under		Sets the -under option of the label.
#	cmdPrefix	Specifies procedures to call when the listbox is
#			browsed or activated.

proc tkMotifFDialog_MakeSList {w f label under cmdPrefix} {
d267 6
a272 3
	-xscrollcommand [list $f.h set]	-yscrollcommand [list $f.v set]
    scrollbar $f.v -orient vertical   -takefocus 0 -command [list $f.l yview]
    scrollbar $f.h -orient horizontal -takefocus 0 -command [list $f.l xview]
d286 7
a292 9
    bind $list <Up>		[list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <Down>		[list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <space>		[list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <1>		[list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <B1-Motion>	[list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <Double-ButtonRelease-1> \
	    [list tkMotifFDialog_Activate$cmdPrefix $w]
    bind $list <Return>    "tkMotifFDialog_Browse$cmdPrefix [list $w]; \
	    tkMotifFDialog_Activate$cmdPrefix [list $w]"
d294 1
a294 1
    bindtags $list [list Listbox $list [winfo toplevel $list] all]
a299 160
# tkMotifFDialog_InterpFilter --
#
#	Interpret the string in the filter entry into two components:
#	the directory and the pattern. If the string is a relative
#	pathname, give a warning to the user and restore the pattern
#	to original.
#
# Arguments:
#	w		pathname of the dialog box.
#
# Results:
# 	A list of two elements. The first element is the directory
# 	specified # by the filter. The second element is the filter
# 	pattern itself.

proc tkMotifFDialog_InterpFilter {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    set text [string trim [$data(fEnt) get]]

    # Perform tilde substitution
    #
    set badTilde 0
    if {[string equal [string index $text 0] ~]} {
	set list [file split $text]
	set tilde [lindex $list 0]
	if {[catch {set tilde [glob $tilde]}]} {
	    set badTilde 1
	} else {
	    set text [eval file join [concat $tilde [lrange $list 1 end]]]
	}
    }

    # If the string is a relative pathname, combine it
    # with the current selectPath.

    set relative 0
    if {[string equal [file pathtype $text] "relative"]} {
	set relative 1
    } elseif {$badTilde} {
	set relative 1	
    }

    if {$relative} {
	tk_messageBox -icon warning -type ok \
	    -message "\"$text\" must be an absolute pathname"

	$data(fEnt) delete 0 end
	$data(fEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) \
		$data(filter)]

	return [list $data(selectPath) $data(filter)]
    }

    set resolved [::tk::dialog::file::JoinFile [file dirname $text] [file tail $text]]

    if {[file isdirectory $resolved]} {
	set dir $resolved
	set fil $data(filter)
    } else {
	set dir [file dirname $resolved]
	set fil [file tail    $resolved]
    }

    return [list $dir $fil]
}

# tkMotifFDialog_Update
#
#	Load the files and synchronize the "filter" and "selection" fields
#	boxes.
#
# Arguments:
# 	w 		pathname of the dialog box.
#
# Results:
#	None.

proc tkMotifFDialog_Update {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    $data(fEnt) delete 0 end
    $data(fEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) $data(filter)]
    $data(sEnt) delete 0 end
    $data(sEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) \
	    $data(selectFile)]
 
    tkMotifFDialog_LoadFiles $w
}

# tkMotifFDialog_LoadFiles --
#
#	Loads the files and directories into the two listboxes according
#	to the filter setting.
#
# Arguments:
# 	w 		pathname of the dialog box.
#
# Results:
#	None.

proc tkMotifFDialog_LoadFiles {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    $data(dList) delete 0 end
    $data(fList) delete 0 end

    set appPWD [pwd]
    if {[catch {cd $data(selectPath)}]} {
	cd $appPWD

	$data(dList) insert end ".."
	return
    }

    # Make the dir list
    #
    foreach f [lsort -dictionary [glob -nocomplain .* *]] {
	if {[file isdir ./$f]} {
	    $data(dList) insert end $f
	}
    }
    # Make the file list
    #
    if {[string equal $data(filter) *]} {
	set files [lsort -dictionary [glob -nocomplain .* *]]
    } else {
	set files [lsort -dictionary \
	    [glob -nocomplain $data(filter)]]
    }

    set top 0
    foreach f $files {
	if {![file isdir ./$f]} {
	    regsub {^[.]/} $f "" f
	    $data(fList) insert end $f
	    if {[string match .* $f]} {
		incr top
	    }
	}
    }

    # The user probably doesn't want to see the . files. We adjust the view
    # so that the listbox displays all the non-dot files
    $data(fList) yview $top

    cd $appPWD
}

# tkMotifFDialog_BrowseFList --
#
#	This procedure is called when the directory list is browsed
#	(clicked-over) by the user.
#
# Arguments:
# 	w		The pathname of the dialog box.
#
# Results:
#	None.	

d301 1
a301 1
    upvar ::tk::dialog::file::[winfo name $w] data
d304 1
a304 1
    if {[string equal [$data(dList) curselection] ""]} {
d308 1
a308 1
    if {[string equal $subdir ""]} {
d317 1
a317 1
    switch -- $subdir {
d319 1
a319 1
	    set newSpec [::tk::dialog::file::JoinFile $data(selectPath) $data(filter)]
d322 1
a322 1
	    set newSpec [::tk::dialog::file::JoinFile [file dirname $data(selectPath)] \
d326 1
a326 2
	    set newSpec [::tk::dialog::file::JoinFile [::tk::dialog::file::JoinFile \
		    $data(selectPath) $subdir] $data(filter)]
a333 11
# tkMotifFDialog_ActivateDList --
#
#	This procedure is called when the directory list is activated
#	(double-clicked) by the user.
#
# Arguments:
# 	w		The pathname of the dialog box.
#
# Results:
#	None.	

d335 1
a335 1
    upvar ::tk::dialog::file::[winfo name $w] data
d337 1
a337 1
    if {[string equal [$data(dList) curselection] ""]} {
d341 1
a341 1
    if {[string equal $subdir ""]} {
d347 1
a347 1
    switch -- $subdir {
d355 1
a355 1
	    set newDir [::tk::dialog::file::JoinFile $data(selectPath) $subdir]
a370 11
# tkMotifFDialog_BrowseFList --
#
#	This procedure is called when the file list is browsed
#	(clicked-over) by the user.
#
# Arguments:
# 	w		The pathname of the dialog box.
#
# Results:
#	None.	

d372 1
a372 1
    upvar ::tk::dialog::file::[winfo name $w] data
d375 1
a375 1
    if {[string equal [$data(fList) curselection] ""]} {
d379 1
a379 1
    if {[string equal $data(selectFile) ""]} {
d386 1
a386 1
    $data(fEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) $data(filter)]
d390 1
a390 2
    $data(sEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) \
	    $data(selectFile)]
a393 11
# tkMotifFDialog_ActivateFList --
#
#	This procedure is called when the file list is activated
#	(double-clicked) by the user.
#
# Arguments:
# 	w		The pathname of the dialog box.
#
# Results:
#	None.	

d395 1
a395 1
    upvar ::tk::dialog::file::[winfo name $w] data
d397 1
a397 1
    if {[string equal [$data(fList) curselection] ""]} {
d401 1
a401 1
    if {[string equal $data(selectFile) ""]} {
a407 12
# tkMotifFDialog_ActivateFEnt --
#
#	This procedure is called when the user presses Return inside
#	the "filter" entry. It updates the dialog according to the
#	text inside the filter entry.
#
# Arguments:
# 	w		The pathname of the dialog box.
#
# Results:
#	None.	

d409 1
a409 1
    upvar ::tk::dialog::file::[winfo name $w] data
d418 28
a445 12
# tkMotifFDialog_ActivateSEnt --
#
#	This procedure is called when the user presses Return inside
#	the "selection" entry. It sets the tkPriv(selectFilePath) global
#	variable so that the vwait loop in tkMotifFDialog will be
#	terminated.
#
# Arguments:
# 	w		The pathname of the dialog box.
#
# Results:
#	None.	
d449 1
a449 1
    upvar ::tk::dialog::file::[winfo name $w] data
d455 2
a456 1
    if {[string equal $selectFilePath ""]} {
d481 1
a481 1
	if {[string equal $data(type) open]} {
d487 1
a487 1
	if {[string equal $data(type) save]} {
d493 1
a493 1
	    if {[string equal $answer "no"]} {
d506 1
a506 1
    upvar ::tk::dialog::file::[winfo name $w] data
d512 1
a512 1
    upvar ::tk::dialog::file::[winfo name $w] data
d525 69
d596 2
a597 2
    bind $w <Destroy> [list tkListBoxKeyAccel_Unset $w]
    bind $w <Any-KeyPress> [list tkListBoxKeyAccel_Key $w %A]
a607 14
# tkListBoxKeyAccel_Key--
#
#	This procedure maintains a list of recently entered keystrokes
#	over a listbox widget. It arranges an idle event to move the
#	selection of the listbox to the entry that begins with the
#	keystrokes.
#
# Arguments:
# 	w		The pathname of the listbox.
#	key		The key which the user just pressed.
#
# Results:
#	None.	

d616 1
a616 2
    set tkPriv(lbAccel,$w,afterId) [after 500 \
	    [list tkListBoxKeyAccel_Reset $w]]
a649 2


@


1.1.1.3
log
@import tk 8.4.0
@
text
@d5 1
a5 1
#	"::tk_strictMotif" flag is set.
d7 1
a7 1
# RCS: @@(#) $Id: xmfbox.tcl,v 1.24 2002/09/09 20:05:27 uid38172 Exp $
d19 1
a19 1
# ::tk::MotifFDialog --
d29 4
a32 8
#	When -multiple is set to 0, this returns the absolute pathname
#	of the selected file. (NOTE: This is not the same as a single
#	element list.)
# 
#	When -multiple is set to > 0, this returns a Tcl list of absolute
#       pathnames. The argument for -multiple is ignored, but for consistency
#       with Windows it defines the maximum amount of memory to allocate for
#       the returned filenames.
d34 2
a35 2
proc ::tk::MotifFDialog {type args} {
    variable ::tk::Priv
d39 1
a39 1
    set w [MotifFDialog_Create $dataName $type $args]
d52 1
a52 1
    vwait ::tk::Priv(selectFilePath)
d55 1
a55 1
    return $Priv(selectFilePath)
d58 1
a58 1
# ::tk::MotifFDialog_Create --
d64 1
a64 1
#	This procedure is used by ::tk::MotifFDialog to create the
d77 2
a78 1
proc ::tk::MotifFDialog_Create {dataName type argList} {
d81 1
a81 1
    MotifFDialog_Config $dataName $type $argList
d92 1
a92 1
	MotifFDialog_BuildUI $w
d95 1
a95 1
	MotifFDialog_BuildUI $w
a104 1
    MotifFDialog_SetListMode $w
d106 1
a106 6
    # Dialog boxes should be transient with respect to their parent,
    # so that they will always stay on top of their parent window.  However,
    # some window managers will create the window as withdrawn if the parent
    # window is withdrawn or iconified.  Combined with the grab we put on the
    # window, this can hang the entire application.  Therefore we only make
    # the dialog transient if the parent is viewable.
d108 1
a108 6
    if {[winfo viewable [winfo toplevel $data(-parent)]] } {
	wm transient $w $data(-parent)
    }

    MotifFDialog_FileTypes $w
    MotifFDialog_Update $w
d120 1
a120 69
# ::tk::MotifFDialog_FileTypes --
#
#	Checks the -filetypes option. If present this adds a list of radio-
#	buttons to pick the file types from.
#
# Arguments:
#	w		Pathname of the tk_get*File dialogue.
#
# Results:
#	none

proc ::tk::MotifFDialog_FileTypes {w} {
    upvar ::tk::dialog::file::[winfo name $w] data

    set f $w.top.f3.types
    catch {destroy $f}

    # No file types: use "*" as the filter and display no radio-buttons
    if {$data(-filetypes) == ""} {
	set data(filter) *
	return
    }

    # The filetypes radiobuttons
    # set data(fileType) $data(-defaulttype)
    set data(fileType) 0

    MotifFDialog_SetFilter $w [lindex $data(-filetypes) $data(fileType)]

    #don't produce radiobuttons for only one filetype
    if {[llength $data(-filetypes)] == 1} {
	return
    }

    frame $f
    set cnt 0
    if {$data(-filetypes) != {}} {
	foreach type $data(-filetypes) {
	    set title  [lindex [lindex $type 0] 0]
	    set filter [lindex $type 1]
	    radiobutton $f.b$cnt \
		-text $title \
		-variable ::tk::dialog::file::[winfo name $w](fileType) \
		-value $cnt \
		-command "[list tk::MotifFDialog_SetFilter $w $type]"
	    pack $f.b$cnt -side left
	    incr cnt
	}
    }
    $f.b$data(fileType) invoke

    pack $f -side bottom -fill both

    return
}

# This proc gets called whenever data(filter) is set
#
proc ::tk::MotifFDialog_SetFilter {w type} {
    upvar ::tk::dialog::file::[winfo name $w] data
    variable ::tk::Priv

    set data(filter) [lindex $type 1]
    set Priv(selectFileType) [lindex [lindex $type 0] 0]

    MotifFDialog_Update $w
}

# ::tk::MotifFDialog_Config --
d132 1
a132 1
proc ::tk::MotifFDialog_Config {dataName type argList} {
a146 3
    if { [string equal $type "open"] } {
	lappend specs {-multiple "" "" "0"}
    }
a147 1
    set data(-multiple) 0
d162 1
a162 5
	    if {$data(-multiple) != 0} {
		set data(-title) "[mc {Open Multiple Files}]"
	    } else {
	    set data(-title) [mc "Open"]
	    }
d164 1
a164 1
	    set data(-title) [mc "Save As"]
d173 1
a173 1
	    set data(selectPath) [lindex [glob $data(-initialdir)] 0]
d191 1
a191 1
    set data(-filetypes) [::tk::FDGetFileTypes $data(-filetypes)]
d201 1
a201 1
# ::tk::MotifFDialog_BuildUI --
d211 1
a211 1
proc ::tk::MotifFDialog_BuildUI {w} {
d245 1
a245 2
    bind [::tk::AmpWidget label $f1.lab -text [mc "Fil&ter:"] -anchor w] \
	<<AltUnderlined>> [list focus $f1.ent]
d253 2
a254 4
    set data(dList) [MotifFDialog_MakeSList $w $f2a \
	    [mc "&Directory:"] DList]
    set data(fList) [MotifFDialog_MakeSList $w $f2b \
	    [mc "Fi&les:"]     FList]
d258 1
a258 2
    bind [::tk::AmpWidget label $f3.lab -text [mc "&Selection:"] -anchor w] \
	<<AltUnderlined>> [list focus $f3.ent]
d266 6
a271 11
    set maxWidth [::tk::mcmaxamp &OK &Filter &Cancel]
    set maxWidth [expr {$maxWidth<6?6:$maxWidth}]
    set data(okBtn) [::tk::AmpWidget button $bot.ok -text [mc "&OK"] \
	    -width $maxWidth \
	    -command [list tk::MotifFDialog_OkCmd $w]]
    set data(filterBtn) [::tk::AmpWidget button $bot.filter -text [mc "&Filter"] \
	    -width $maxWidth \
	    -command [list tk::MotifFDialog_FilterCmd $w]]
    set data(cancelBtn) [::tk::AmpWidget button $bot.cancel -text [mc "&Cancel"] \
	    -width $maxWidth \
	    -command [list tk::MotifFDialog_CancelCmd $w]]
d278 4
a281 4
    bind $w <Alt-Key> [list ::tk::AltKeyInDialog $w %A]

    bind $data(fEnt) <Return> [list tk::MotifFDialog_ActivateFEnt $w]
    bind $data(sEnt) <Return> [list tk::MotifFDialog_ActivateSEnt $w]
d283 3
a285 2
    wm protocol $w WM_DELETE_WINDOW [list tk::MotifFDialog_CancelCmd $w]
}
d287 2
a288 2
proc ::tk::MotifFDialog_SetListMode {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
d290 1
a290 7
    if {$data(-multiple) != 0} {
	set selectmode extended
    } else {
	set selectmode browse
    }
    set f $w.top.f2.b
    $f.l configure -selectmode $selectmode
d293 1
a293 1
# ::tk::MotifFDialog_MakeSList --
d308 3
a310 4
proc ::tk::MotifFDialog_MakeSList {w f label cmdPrefix} {
    bind [::tk::AmpWidget label $f.lab -text $label -anchor w] \
	<<AltUnderlined>> [list focus $f.l]
    listbox $f.l -width 12 -height 5 -exportselection 0\
d327 5
a331 1
    bind $list <<ListboxSelect>> [list tk::MotifFDialog_Browse$cmdPrefix $w]
d333 3
a335 3
	    [list tk::MotifFDialog_Activate$cmdPrefix $w]
    bind $list <Return>	"tk::MotifFDialog_Browse$cmdPrefix [list $w]; \
	    tk::MotifFDialog_Activate$cmdPrefix [list $w]"
d338 1
a338 1
    ListBoxKeyAccel_Set $list
d343 1
a343 1
# ::tk::MotifFDialog_InterpFilter --
d358 1
a358 1
proc ::tk::MotifFDialog_InterpFilter {w} {
d410 1
a410 1
# ::tk::MotifFDialog_Update
d421 1
a421 1
proc ::tk::MotifFDialog_Update {w} {
d425 1
a425 2
    $data(fEnt) insert 0 \
            [::tk::dialog::file::JoinFile $data(selectPath) $data(filter)]
d430 1
a430 1
    MotifFDialog_LoadFiles $w
d433 1
a433 1
# ::tk::MotifFDialog_LoadFiles --
d444 1
a444 1
proc ::tk::MotifFDialog_LoadFiles {w} {
d458 1
a458 1
    # Make the dir and file lists
d460 6
a465 5
    # For speed we only have one glob, which reduces the file system
    # calls (good for slow NFS networks).
    #
    # We also do two smaller sorts (files + dirs) instead of one large sort,
    # which gives a small speed increase.
d467 7
d475 6
a480 13
    set dlist ""
    set flist ""
    foreach f [glob -nocomplain .* *] {
	if {[file isdir ./$f]} {
	    lappend dlist $f
	} else {
            foreach pat $data(filter) {
                if {[string match $pat $f]} {
		if {[string match .* $f]} {
		    incr top
		}
		lappend flist $f
                    break
a481 1
            }
a483 2
    eval [list $data(dList) insert end] [lsort -dictionary $dlist]
    eval [list $data(fList) insert end] [lsort -dictionary $flist]
d492 1
a492 1
# ::tk::MotifFDialog_BrowseDList --
d503 1
a503 1
proc ::tk::MotifFDialog_BrowseDList {w} {
d517 1
a517 1
    set list [MotifFDialog_InterpFilter $w]
d538 1
a538 1
# ::tk::MotifFDialog_ActivateDList --
d549 1
a549 1
proc ::tk::MotifFDialog_ActivateDList {w} {
d575 1
a575 1
    MotifFDialog_Update $w
d586 1
a586 1
# ::tk::MotifFDialog_BrowseFList --
d597 1
a597 1
proc ::tk::MotifFDialog_BrowseFList {w} {
d601 2
a602 3
    set data(selectFile) ""
    foreach item [$data(fList) curselection] {
	lappend data(selectFile) [$data(fList) get $item]
d604 2
a605 1
    if {[llength $data(selectFile)] == 0} {
d612 1
a612 2
    $data(fEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) \
	    $data(filter)]
a614 2
    # if it's a multiple selection box, just put in the filenames 
    # otherwise put in the full path as usual 
d616 2
a617 6
    if {$data(-multiple) != 0} {
	$data(sEnt) insert 0 $data(selectFile)
    } else {
	$data(sEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) \
				  [lindex $data(selectFile) 0]]
    }
d621 1
a621 1
# ::tk::MotifFDialog_ActivateFList --
d632 1
a632 1
proc ::tk::MotifFDialog_ActivateFList {w} {
d642 1
a642 1
	MotifFDialog_ActivateSEnt $w
d646 1
a646 1
# ::tk::MotifFDialog_ActivateFEnt --
d658 1
a658 1
proc ::tk::MotifFDialog_ActivateFEnt {w} {
d661 1
a661 1
    set list [MotifFDialog_InterpFilter $w]
d665 1
a665 1
    MotifFDialog_Update $w
d668 1
a668 1
# ::tk::MotifFDialog_ActivateSEnt --
d671 2
a672 2
#	the "selection" entry. It sets the ::tk::Priv(selectFilePath) 
#	variable so that the vwait loop in tk::MotifFDialog will be
d681 2
a682 2
proc ::tk::MotifFDialog_ActivateSEnt {w} {
    variable ::tk::Priv
d686 2
d690 1
a690 1
	MotifFDialog_FilterCmd $w
d694 5
a698 2
    if {$data(-multiple) == 0} {
	set selectFilePath [list $selectFilePath]
d701 9
a709 4
    if {[file isdirectory [lindex $selectFilePath 0]]} {
	set data(selectPath) [lindex [glob $selectFilePath] 0]
	set data(selectFile) ""
	MotifFDialog_Update $w
d713 2
a714 5
    set newFileList ""
    foreach item $selectFilePath {
	if {[string compare [file pathtype $item] "absolute"]} {
	    set item [file join $data(selectPath) $item]
	} elseif {![file exists [file dirname $item]]} {
d716 1
a716 2
		    -message [mc {Directory "%1$s" does not exist.} \
		    [file dirname $item]]
d719 8
a726 5

	if {![file exists $item]} {
	    if {[string equal $data(type) open]} {
		tk_messageBox -icon warning -type ok \
			-message [mc {File "%1$s" does not exist.} $item]
a728 12
	} else {
	    if {[string equal $data(type) save]} {
		set message [format %s%s \
			[mc {File "%1$s" already exists.\n\n} \
			$selectFilePath] \
			[mc {Replace existing file?}]]
		set answer [tk_messageBox -icon warning -type yesno \
			-message $message]
		if {[string equal $answer "no"]} {
		    return
		}
	    }
a729 2
	
	lappend newFileList $item
d732 3
a734 9
    if {$data(-multiple) != 0} {
	set Priv(selectFilePath) $newFileList
    } else {
	set Priv(selectFilePath) [lindex $newFileList 0]
    }

    # Set selectFile and selectPath to first item in list
    set Priv(selectFile)     [file tail    [lindex $newFileList 0]]
    set Priv(selectPath)     [file dirname [lindex $newFileList 0]]
d738 1
a738 1
proc ::tk::MotifFDialog_OkCmd {w} {
d741 1
a741 1
    MotifFDialog_ActivateSEnt $w
d744 1
a744 1
proc ::tk::MotifFDialog_FilterCmd {w} {
d747 1
a747 1
    MotifFDialog_ActivateFEnt $w
d750 2
a751 2
proc ::tk::MotifFDialog_CancelCmd {w} {
    variable ::tk::Priv
d753 3
a755 3
    set Priv(selectFilePath) ""
    set Priv(selectFile)     ""
    set Priv(selectPath)     ""
d758 1
a758 1
proc ::tk::ListBoxKeyAccel_Set {w} {
d760 2
a761 2
    bind $w <Destroy> [list tk::ListBoxKeyAccel_Unset $w]
    bind $w <Any-KeyPress> [list tk::ListBoxKeyAccel_Key $w %A]
d764 2
a765 2
proc ::tk::ListBoxKeyAccel_Unset {w} {
    variable ::tk::Priv
d767 3
a769 3
    catch {after cancel $Priv(lbAccel,$w,afterId)}
    catch {unset Priv(lbAccel,$w)}
    catch {unset Priv(lbAccel,$w,afterId)}
d772 1
a772 1
# ::tk::ListBoxKeyAccel_Key--
d786 2
a787 2
proc ::tk::ListBoxKeyAccel_Key {w key} {
    variable ::tk::Priv
d789 2
a790 5
    if { $key == "" } {
	return
    }
    append Priv(lbAccel,$w) $key
    ListBoxKeyAccel_Goto $w $Priv(lbAccel,$w)
d792 1
a792 1
	after cancel $Priv(lbAccel,$w,afterId)
d794 2
a795 2
    set Priv(lbAccel,$w,afterId) [after 500 \
	    [list tk::ListBoxKeyAccel_Reset $w]]
d798 2
a799 2
proc ::tk::ListBoxKeyAccel_Goto {w string} {
    variable ::tk::Priv
a820 1
	event generate $w <<ListboxSelect>>
d824 2
a825 2
proc ::tk::ListBoxKeyAccel_Reset {w} {
    variable ::tk::Priv
d827 1
a827 1
    catch {unset Priv(lbAccel,$w)}
a829 2
proc ::tk_getFileType {} {
    variable ::tk::Priv
a830 2
    return $Priv(selectFileType)
}
@


