head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.46;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.14;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.26;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.52;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.33;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.50;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# listbox.tcl --
#
# This file defines the default bindings for Tk listbox widgets
# and provides procedures that help in implementing those bindings.
#
# RCS: @@(#) $Id: listbox.tcl,v 1.13 2002/08/31 06:12:28 das Exp $
#
# Copyright (c) 1994 The Regents of the University of California.
# Copyright (c) 1994-1995 Sun Microsystems, Inc.
# Copyright (c) 1998 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

#--------------------------------------------------------------------------
# tk::Priv elements used in this file:
#
# afterId -		Token returned by "after" for autoscanning.
# listboxPrev -		The last element to be selected or deselected
#			during a selection operation.
# listboxSelection -	All of the items that were selected before the
#			current selection operation (such as a mouse
#			drag) started;  used to cancel an operation.
#--------------------------------------------------------------------------

#-------------------------------------------------------------------------
# The code below creates the default class bindings for listboxes.
#-------------------------------------------------------------------------

# Note: the check for existence of %W below is because this binding
# is sometimes invoked after a window has been deleted (e.g. because
# there is a double-click binding on the widget that deletes it).  Users
# can put "break"s in their bindings to avoid the error, but this check
# makes that unnecessary.

bind Listbox <1> {
    if {[winfo exists %W]} {
	tk::ListboxBeginSelect %W [%W index @@%x,%y]
    }
}

# Ignore double clicks so that users can define their own behaviors.
# Among other things, this prevents errors if the user deletes the
# listbox on a double click.

bind Listbox <Double-1> {
    # Empty script
}

bind Listbox <B1-Motion> {
    set tk::Priv(x) %x
    set tk::Priv(y) %y
    tk::ListboxMotion %W [%W index @@%x,%y]
}
bind Listbox <ButtonRelease-1> {
    tk::CancelRepeat
    %W activate @@%x,%y
}
bind Listbox <Shift-1> {
    tk::ListboxBeginExtend %W [%W index @@%x,%y]
}
bind Listbox <Control-1> {
    tk::ListboxBeginToggle %W [%W index @@%x,%y]
}
bind Listbox <B1-Leave> {
    set tk::Priv(x) %x
    set tk::Priv(y) %y
    tk::ListboxAutoScan %W
}
bind Listbox <B1-Enter> {
    tk::CancelRepeat
}

bind Listbox <Up> {
    tk::ListboxUpDown %W -1
}
bind Listbox <Shift-Up> {
    tk::ListboxExtendUpDown %W -1
}
bind Listbox <Down> {
    tk::ListboxUpDown %W 1
}
bind Listbox <Shift-Down> {
    tk::ListboxExtendUpDown %W 1
}
bind Listbox <Left> {
    %W xview scroll -1 units
}
bind Listbox <Control-Left> {
    %W xview scroll -1 pages
}
bind Listbox <Right> {
    %W xview scroll 1 units
}
bind Listbox <Control-Right> {
    %W xview scroll 1 pages
}
bind Listbox <Prior> {
    %W yview scroll -1 pages
    %W activate @@0,0
}
bind Listbox <Next> {
    %W yview scroll 1 pages
    %W activate @@0,0
}
bind Listbox <Control-Prior> {
    %W xview scroll -1 pages
}
bind Listbox <Control-Next> {
    %W xview scroll 1 pages
}
bind Listbox <Home> {
    %W xview moveto 0
}
bind Listbox <End> {
    %W xview moveto 1
}
bind Listbox <Control-Home> {
    %W activate 0
    %W see 0
    %W selection clear 0 end
    %W selection set 0
    event generate %W <<ListboxSelect>>
}
bind Listbox <Shift-Control-Home> {
    tk::ListboxDataExtend %W 0
}
bind Listbox <Control-End> {
    %W activate end
    %W see end
    %W selection clear 0 end
    %W selection set end
    event generate %W <<ListboxSelect>>
}
bind Listbox <Shift-Control-End> {
    tk::ListboxDataExtend %W [%W index end]
}
bind Listbox <<Copy>> {
    if {[string equal [selection own -displayof %W] "%W"]} {
	clipboard clear -displayof %W
	clipboard append -displayof %W [selection get -displayof %W]
    }
}
bind Listbox <space> {
    tk::ListboxBeginSelect %W [%W index active]
}
bind Listbox <Select> {
    tk::ListboxBeginSelect %W [%W index active]
}
bind Listbox <Control-Shift-space> {
    tk::ListboxBeginExtend %W [%W index active]
}
bind Listbox <Shift-Select> {
    tk::ListboxBeginExtend %W [%W index active]
}
bind Listbox <Escape> {
    tk::ListboxCancel %W
}
bind Listbox <Control-slash> {
    tk::ListboxSelectAll %W
}
bind Listbox <Control-backslash> {
    if {[string compare [%W cget -selectmode] "browse"]} {
	%W selection clear 0 end
	event generate %W <<ListboxSelect>>
    }
}

# Additional Tk bindings that aren't part of the Motif look and feel:

bind Listbox <2> {
    %W scan mark %x %y
}
bind Listbox <B2-Motion> {
    %W scan dragto %x %y
}

# The MouseWheel will typically only fire on Windows.  However,
# someone could use the "event generate" command to produce one
# on other platforms.

bind Listbox <MouseWheel> {
    %W yview scroll [expr {- (%D / 120) * 4}] units
}

if {[string equal "x11" [tk windowingsystem]]} {
    # Support for mousewheels on Linux/Unix commonly comes through mapping
    # the wheel to the extended buttons.  If you have a mousewheel, find
    # Linux configuration info at:
    #	http://www.inria.fr/koala/colas/mouse-wheel-scroll/
    bind Listbox <4> {
	if {!$tk_strictMotif} {
	    %W yview scroll -5 units
	}
    }
    bind Listbox <5> {
	if {!$tk_strictMotif} {
	    %W yview scroll 5 units
	}
    }
}

# ::tk::ListboxBeginSelect --
#
# This procedure is typically invoked on button-1 presses.  It begins
# the process of making a selection in the listbox.  Its exact behavior
# depends on the selection mode currently in effect for the listbox;
# see the Motif documentation for details.
#
# Arguments:
# w -		The listbox widget.
# el -		The element for the selection operation (typically the
#		one under the pointer).  Must be in numerical form.

proc ::tk::ListboxBeginSelect {w el} {
    variable ::tk::Priv
    if {[string equal [$w cget -selectmode] "multiple"]} {
	if {[$w selection includes $el]} {
	    $w selection clear $el
	} else {
	    $w selection set $el
	}
    } else {
	$w selection clear 0 end
	$w selection set $el
	$w selection anchor $el
	set Priv(listboxSelection) {}
	set Priv(listboxPrev) $el
    }
    event generate $w <<ListboxSelect>>
}

# ::tk::ListboxMotion --
#
# This procedure is called to process mouse motion events while
# button 1 is down.  It may move or extend the selection, depending
# on the listbox's selection mode.
#
# Arguments:
# w -		The listbox widget.
# el -		The element under the pointer (must be a number).

proc ::tk::ListboxMotion {w el} {
    variable ::tk::Priv
    if {$el == $Priv(listboxPrev)} {
	return
    }
    set anchor [$w index anchor]
    switch [$w cget -selectmode] {
	browse {
	    $w selection clear 0 end
	    $w selection set $el
	    set Priv(listboxPrev) $el
	    event generate $w <<ListboxSelect>>
	}
	extended {
	    set i $Priv(listboxPrev)
	    if {[string equal {} $i]} {
		set i $el
		$w selection set $el
	    }
	    if {[$w selection includes anchor]} {
		$w selection clear $i $el
		$w selection set anchor $el
	    } else {
		$w selection clear $i $el
		$w selection clear anchor $el
	    }
	    if {![info exists Priv(listboxSelection)]} {
		set Priv(listboxSelection) [$w curselection]
	    }
	    while {($i < $el) && ($i < $anchor)} {
		if {[lsearch $Priv(listboxSelection) $i] >= 0} {
		    $w selection set $i
		}
		incr i
	    }
	    while {($i > $el) && ($i > $anchor)} {
		if {[lsearch $Priv(listboxSelection) $i] >= 0} {
		    $w selection set $i
		}
		incr i -1
	    }
	    set Priv(listboxPrev) $el
	    event generate $w <<ListboxSelect>>
	}
    }
}

# ::tk::ListboxBeginExtend --
#
# This procedure is typically invoked on shift-button-1 presses.  It
# begins the process of extending a selection in the listbox.  Its
# exact behavior depends on the selection mode currently in effect
# for the listbox;  see the Motif documentation for details.
#
# Arguments:
# w -		The listbox widget.
# el -		The element for the selection operation (typically the
#		one under the pointer).  Must be in numerical form.

proc ::tk::ListboxBeginExtend {w el} {
    if {[string equal [$w cget -selectmode] "extended"]} {
	if {[$w selection includes anchor]} {
	    ListboxMotion $w $el
	} else {
	    # No selection yet; simulate the begin-select operation.
	    ListboxBeginSelect $w $el
	}
    }
}

# ::tk::ListboxBeginToggle --
#
# This procedure is typically invoked on control-button-1 presses.  It
# begins the process of toggling a selection in the listbox.  Its
# exact behavior depends on the selection mode currently in effect
# for the listbox;  see the Motif documentation for details.
#
# Arguments:
# w -		The listbox widget.
# el -		The element for the selection operation (typically the
#		one under the pointer).  Must be in numerical form.

proc ::tk::ListboxBeginToggle {w el} {
    variable ::tk::Priv
    if {[string equal [$w cget -selectmode] "extended"]} {
	set Priv(listboxSelection) [$w curselection]
	set Priv(listboxPrev) $el
	$w selection anchor $el
	if {[$w selection includes $el]} {
	    $w selection clear $el
	} else {
	    $w selection set $el
	}
	event generate $w <<ListboxSelect>>
    }
}

# ::tk::ListboxAutoScan --
# This procedure is invoked when the mouse leaves an entry window
# with button 1 down.  It scrolls the window up, down, left, or
# right, depending on where the mouse left the window, and reschedules
# itself as an "after" command so that the window continues to scroll until
# the mouse moves back into the window or the mouse button is released.
#
# Arguments:
# w -		The entry window.

proc ::tk::ListboxAutoScan {w} {
    variable ::tk::Priv
    if {![winfo exists $w]} return
    set x $Priv(x)
    set y $Priv(y)
    if {$y >= [winfo height $w]} {
	$w yview scroll 1 units
    } elseif {$y < 0} {
	$w yview scroll -1 units
    } elseif {$x >= [winfo width $w]} {
	$w xview scroll 2 units
    } elseif {$x < 0} {
	$w xview scroll -2 units
    } else {
	return
    }
    ListboxMotion $w [$w index @@$x,$y]
    set Priv(afterId) [after 50 [list tk::ListboxAutoScan $w]]
}

# ::tk::ListboxUpDown --
#
# Moves the location cursor (active element) up or down by one element,
# and changes the selection if we're in browse or extended selection
# mode.
#
# Arguments:
# w -		The listbox widget.
# amount -	+1 to move down one item, -1 to move back one item.

proc ::tk::ListboxUpDown {w amount} {
    variable ::tk::Priv
    $w activate [expr {[$w index active] + $amount}]
    $w see active
    switch [$w cget -selectmode] {
	browse {
	    $w selection clear 0 end
	    $w selection set active
	    event generate $w <<ListboxSelect>>
	}
	extended {
	    $w selection clear 0 end
	    $w selection set active
	    $w selection anchor active
	    set Priv(listboxPrev) [$w index active]
	    set Priv(listboxSelection) {}
	    event generate $w <<ListboxSelect>>
	}
    }
}

# ::tk::ListboxExtendUpDown --
#
# Does nothing unless we're in extended selection mode;  in this
# case it moves the location cursor (active element) up or down by
# one element, and extends the selection to that point.
#
# Arguments:
# w -		The listbox widget.
# amount -	+1 to move down one item, -1 to move back one item.

proc ::tk::ListboxExtendUpDown {w amount} {
    variable ::tk::Priv
    if {[string compare [$w cget -selectmode] "extended"]} {
	return
    }
    set active [$w index active]
    if {![info exists Priv(listboxSelection)]} {
	$w selection set $active
	set Priv(listboxSelection) [$w curselection]
    }
    $w activate [expr {$active + $amount}]
    $w see active
    ListboxMotion $w [$w index active]
}

# ::tk::ListboxDataExtend
#
# This procedure is called for key-presses such as Shift-KEndData.
# If the selection mode isn't multiple or extend then it does nothing.
# Otherwise it moves the active element to el and, if we're in
# extended mode, extends the selection to that point.
#
# Arguments:
# w -		The listbox widget.
# el -		An integer element number.

proc ::tk::ListboxDataExtend {w el} {
    set mode [$w cget -selectmode]
    if {[string equal $mode "extended"]} {
	$w activate $el
	$w see $el
        if {[$w selection includes anchor]} {
	    ListboxMotion $w $el
	}
    } elseif {[string equal $mode "multiple"]} {
	$w activate $el
	$w see $el
    }
}

# ::tk::ListboxCancel
#
# This procedure is invoked to cancel an extended selection in
# progress.  If there is an extended selection in progress, it
# restores all of the items between the active one and the anchor
# to their previous selection state.
#
# Arguments:
# w -		The listbox widget.

proc ::tk::ListboxCancel w {
    variable ::tk::Priv
    if {[string compare [$w cget -selectmode] "extended"]} {
	return
    }
    set first [$w index anchor]
    set last $Priv(listboxPrev)
    if { [string equal $last ""] } {
	# Not actually doing any selection right now
	return
    }
    if {$first > $last} {
	set tmp $first
	set first $last
	set last $tmp
    }
    $w selection clear $first $last
    while {$first <= $last} {
	if {[lsearch $Priv(listboxSelection) $first] >= 0} {
	    $w selection set $first
	}
	incr first
    }
    event generate $w <<ListboxSelect>>
}

# ::tk::ListboxSelectAll
#
# This procedure is invoked to handle the "select all" operation.
# For single and browse mode, it just selects the active element.
# Otherwise it selects everything in the widget.
#
# Arguments:
# w -		The listbox widget.

proc ::tk::ListboxSelectAll w {
    set mode [$w cget -selectmode]
    if {[string equal $mode "single"] || [string equal $mode "browse"]} {
	$w selection clear 0 end
	$w selection set active
    } else {
	$w selection set 0 end
    }
    event generate $w <<ListboxSelect>>
}
@


1.4
log
@touched all sources to ease next import
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: listbox.tcl,v 1.7.6.2 2000/09/26 16:08:41 spolk Exp $
d16 1
a16 1
# tkPriv elements used in this file:
d38 1
a38 1
	tkListboxBeginSelect %W [%W index @@%x,%y]
d51 3
a53 3
    set tkPriv(x) %x
    set tkPriv(y) %y
    tkListboxMotion %W [%W index @@%x,%y]
d56 1
a56 1
    tkCancelRepeat
d60 1
a60 1
    tkListboxBeginExtend %W [%W index @@%x,%y]
d63 1
a63 1
    tkListboxBeginToggle %W [%W index @@%x,%y]
d66 3
a68 3
    set tkPriv(x) %x
    set tkPriv(y) %y
    tkListboxAutoScan %W
d71 1
a71 1
    tkCancelRepeat
d75 1
a75 1
    tkListboxUpDown %W -1
d78 1
a78 1
    tkListboxExtendUpDown %W -1
d81 1
a81 1
    tkListboxUpDown %W 1
d84 1
a84 1
    tkListboxExtendUpDown %W 1
d126 1
a126 1
    tkListboxDataExtend %W 0
d136 1
a136 1
    tkListboxDataExtend %W [%W index end]
d145 1
a145 1
    tkListboxBeginSelect %W [%W index active]
d148 1
a148 1
    tkListboxBeginSelect %W [%W index active]
d151 1
a151 1
    tkListboxBeginExtend %W [%W index active]
d154 1
a154 1
    tkListboxBeginExtend %W [%W index active]
d157 1
a157 1
    tkListboxCancel %W
d160 1
a160 1
    tkListboxSelectAll %W
d186 1
a186 1
if {[string equal "unix" $tcl_platform(platform)]} {
d203 1
a203 1
# tkListboxBeginSelect --
d215 2
a216 2
proc tkListboxBeginSelect {w el} {
    global tkPriv
d227 2
a228 2
	set tkPriv(listboxSelection) {}
	set tkPriv(listboxPrev) $el
d233 1
a233 1
# tkListboxMotion --
d243 3
a245 3
proc tkListboxMotion {w el} {
    global tkPriv
    if {$el == $tkPriv(listboxPrev)} {
d253 1
a253 1
	    set tkPriv(listboxPrev) $el
d257 1
a257 1
	    set i $tkPriv(listboxPrev)
d269 2
a270 2
	    if {![info exists tkPriv(listboxSelection)]} {
		set tkPriv(listboxSelection) [$w curselection]
d273 1
a273 1
		if {[lsearch $tkPriv(listboxSelection) $i] >= 0} {
d279 1
a279 1
		if {[lsearch $tkPriv(listboxSelection) $i] >= 0} {
d284 1
a284 1
	    set tkPriv(listboxPrev) $el
d290 1
a290 1
# tkListboxBeginExtend --
d302 1
a302 1
proc tkListboxBeginExtend {w el} {
d305 1
a305 1
	    tkListboxMotion $w $el
d308 1
a308 1
	    tkListboxBeginSelect $w $el
d313 1
a313 1
# tkListboxBeginToggle --
d325 2
a326 2
proc tkListboxBeginToggle {w el} {
    global tkPriv
d328 2
a329 2
	set tkPriv(listboxSelection) [$w curselection]
	set tkPriv(listboxPrev) $el
d340 1
a340 1
# tkListboxAutoScan --
d350 2
a351 2
proc tkListboxAutoScan {w} {
    global tkPriv
d353 2
a354 2
    set x $tkPriv(x)
    set y $tkPriv(y)
d366 2
a367 2
    tkListboxMotion $w [$w index @@$x,$y]
    set tkPriv(afterId) [after 50 [list tkListboxAutoScan $w]]
d370 1
a370 1
# tkListboxUpDown --
d380 2
a381 2
proc tkListboxUpDown {w amount} {
    global tkPriv
d394 2
a395 2
	    set tkPriv(listboxPrev) [$w index active]
	    set tkPriv(listboxSelection) {}
d401 1
a401 1
# tkListboxExtendUpDown --
d411 2
a412 1
proc tkListboxExtendUpDown {w amount} {
d417 1
a417 2
    if {![info exists tkPriv(listboxSelection)]} {
	global tkPriv
d419 1
a419 1
	set tkPriv(listboxSelection) [$w curselection]
d423 1
a423 1
    tkListboxMotion $w [$w index active]
d426 1
a426 1
# tkListboxDataExtend
d437 1
a437 1
proc tkListboxDataExtend {w el} {
d443 1
a443 1
	    tkListboxMotion $w $el
d451 1
a451 1
# tkListboxCancel
d461 2
a462 2
proc tkListboxCancel w {
    global tkPriv
d467 1
a467 1
    set last $tkPriv(listboxPrev)
d479 1
a479 1
	if {[lsearch $tkPriv(listboxSelection) $first] >= 0} {
d487 1
a487 1
# tkListboxSelectAll
d496 1
a496 1
proc tkListboxSelectAll w {
a505 2


@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
# SCCS: @@(#) listbox.tcl 1.21 97/06/10 17:13:55
d10 1
d123 1
d133 1
d139 1
a139 1
    if {[selection own -displayof %W] == "%W"} {
d163 1
a163 1
    if {[%W cget -selectmode] != "browse"} {
d165 1
d178 25
d217 1
a217 1
    if {[$w cget -selectmode]  == "multiple"} {
d230 1
d254 1
d258 4
d269 3
d285 1
d303 1
a303 1
    if {[$w cget -selectmode] == "extended"} {
a307 1

d327 1
a327 1
    if {[$w cget -selectmode] == "extended"} {
d336 1
d367 1
a367 1
    set tkPriv(afterId) [after 50 tkListboxAutoScan $w]
d388 1
d396 1
d412 1
a412 1
    if {[$w cget -selectmode] != "extended"} {
d415 7
a421 1
    $w activate [expr {[$w index active] + $amount}]
d439 1
a439 1
    if {$mode == "extended"} {
d445 1
a445 1
    } elseif {$mode == "multiple"} {
d463 1
a463 1
    if {[$w cget -selectmode] != "extended"} {
d468 4
d484 1
d498 1
a498 1
    if {($mode == "single") || ($mode == "browse")} {
d504 1
d506 2
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: listbox.tcl,v 1.7.6.2 2000/09/26 16:08:41 spolk Exp $
a9 1
# Copyright (c) 1998 by Scriptics Corporation.
a121 1
    event generate %W <<ListboxSelect>>
a130 1
    event generate %W <<ListboxSelect>>
d136 1
a136 1
    if {[string equal [selection own -displayof %W] "%W"]} {
d160 1
a160 1
    if {[string compare [%W cget -selectmode] "browse"]} {
a161 1
	event generate %W <<ListboxSelect>>
a173 25
# The MouseWheel will typically only fire on Windows.  However,
# someone could use the "event generate" command to produce one
# on other platforms.

bind Listbox <MouseWheel> {
    %W yview scroll [expr {- (%D / 120) * 4}] units
}

if {[string equal "unix" $tcl_platform(platform)]} {
    # Support for mousewheels on Linux/Unix commonly comes through mapping
    # the wheel to the extended buttons.  If you have a mousewheel, find
    # Linux configuration info at:
    #	http://www.inria.fr/koala/colas/mouse-wheel-scroll/
    bind Listbox <4> {
	if {!$tk_strictMotif} {
	    %W yview scroll -5 units
	}
    }
    bind Listbox <5> {
	if {!$tk_strictMotif} {
	    %W yview scroll 5 units
	}
    }
}

d188 1
a188 1
    if {[string equal [$w cget -selectmode] "multiple"]} {
a200 1
    event generate $w <<ListboxSelect>>
a223 1
	    event generate $w <<ListboxSelect>>
a226 4
	    if {[string equal {} $i]} {
		set i $el
		$w selection set $el
	    }
a233 3
	    if {![info exists tkPriv(listboxSelection)]} {
		set tkPriv(listboxSelection) [$w curselection]
	    }
a246 1
	    event generate $w <<ListboxSelect>>
d264 1
a264 1
    if {[string equal [$w cget -selectmode] "extended"]} {
d269 1
d289 1
a289 1
    if {[string equal [$w cget -selectmode] "extended"]} {
a297 1
	event generate $w <<ListboxSelect>>
d328 1
a328 1
    set tkPriv(afterId) [after 50 [list tkListboxAutoScan $w]]
a348 1
	    event generate $w <<ListboxSelect>>
a355 1
	    event generate $w <<ListboxSelect>>
d371 1
a371 1
    if {[string compare [$w cget -selectmode] "extended"]} {
d374 1
a374 7
    set active [$w index active]
    if {![info exists tkPriv(listboxSelection)]} {
	global tkPriv
	$w selection set $active
	set tkPriv(listboxSelection) [$w curselection]
    }
    $w activate [expr {$active + $amount}]
d392 1
a392 1
    if {[string equal $mode "extended"]} {
d398 1
a398 1
    } elseif {[string equal $mode "multiple"]} {
d416 1
a416 1
    if {[string compare [$w cget -selectmode] "extended"]} {
a420 4
    if { [string equal $last ""] } {
	# Not actually doing any selection right now
	return
    }
a432 1
    event generate $w <<ListboxSelect>>
d446 1
a446 1
    if {[string equal $mode "single"] || [string equal $mode "browse"]} {
a451 1
    event generate $w <<ListboxSelect>>
a452 2


@


1.1.1.3
log
@import tk 8.4.0
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: listbox.tcl,v 1.13 2002/08/31 06:12:28 das Exp $
d16 1
a16 1
# tk::Priv elements used in this file:
d38 1
a38 1
	tk::ListboxBeginSelect %W [%W index @@%x,%y]
d51 3
a53 3
    set tk::Priv(x) %x
    set tk::Priv(y) %y
    tk::ListboxMotion %W [%W index @@%x,%y]
d56 1
a56 1
    tk::CancelRepeat
d60 1
a60 1
    tk::ListboxBeginExtend %W [%W index @@%x,%y]
d63 1
a63 1
    tk::ListboxBeginToggle %W [%W index @@%x,%y]
d66 3
a68 3
    set tk::Priv(x) %x
    set tk::Priv(y) %y
    tk::ListboxAutoScan %W
d71 1
a71 1
    tk::CancelRepeat
d75 1
a75 1
    tk::ListboxUpDown %W -1
d78 1
a78 1
    tk::ListboxExtendUpDown %W -1
d81 1
a81 1
    tk::ListboxUpDown %W 1
d84 1
a84 1
    tk::ListboxExtendUpDown %W 1
d126 1
a126 1
    tk::ListboxDataExtend %W 0
d136 1
a136 1
    tk::ListboxDataExtend %W [%W index end]
d145 1
a145 1
    tk::ListboxBeginSelect %W [%W index active]
d148 1
a148 1
    tk::ListboxBeginSelect %W [%W index active]
d151 1
a151 1
    tk::ListboxBeginExtend %W [%W index active]
d154 1
a154 1
    tk::ListboxBeginExtend %W [%W index active]
d157 1
a157 1
    tk::ListboxCancel %W
d160 1
a160 1
    tk::ListboxSelectAll %W
d186 1
a186 1
if {[string equal "x11" [tk windowingsystem]]} {
d203 1
a203 1
# ::tk::ListboxBeginSelect --
d215 2
a216 2
proc ::tk::ListboxBeginSelect {w el} {
    variable ::tk::Priv
d227 2
a228 2
	set Priv(listboxSelection) {}
	set Priv(listboxPrev) $el
d233 1
a233 1
# ::tk::ListboxMotion --
d243 3
a245 3
proc ::tk::ListboxMotion {w el} {
    variable ::tk::Priv
    if {$el == $Priv(listboxPrev)} {
d253 1
a253 1
	    set Priv(listboxPrev) $el
d257 1
a257 1
	    set i $Priv(listboxPrev)
d269 2
a270 2
	    if {![info exists Priv(listboxSelection)]} {
		set Priv(listboxSelection) [$w curselection]
d273 1
a273 1
		if {[lsearch $Priv(listboxSelection) $i] >= 0} {
d279 1
a279 1
		if {[lsearch $Priv(listboxSelection) $i] >= 0} {
d284 1
a284 1
	    set Priv(listboxPrev) $el
d290 1
a290 1
# ::tk::ListboxBeginExtend --
d302 1
a302 1
proc ::tk::ListboxBeginExtend {w el} {
d305 1
a305 1
	    ListboxMotion $w $el
d308 1
a308 1
	    ListboxBeginSelect $w $el
d313 1
a313 1
# ::tk::ListboxBeginToggle --
d325 2
a326 2
proc ::tk::ListboxBeginToggle {w el} {
    variable ::tk::Priv
d328 2
a329 2
	set Priv(listboxSelection) [$w curselection]
	set Priv(listboxPrev) $el
d340 1
a340 1
# ::tk::ListboxAutoScan --
d350 2
a351 2
proc ::tk::ListboxAutoScan {w} {
    variable ::tk::Priv
d353 2
a354 2
    set x $Priv(x)
    set y $Priv(y)
d366 2
a367 2
    ListboxMotion $w [$w index @@$x,$y]
    set Priv(afterId) [after 50 [list tk::ListboxAutoScan $w]]
d370 1
a370 1
# ::tk::ListboxUpDown --
d380 2
a381 2
proc ::tk::ListboxUpDown {w amount} {
    variable ::tk::Priv
d394 2
a395 2
	    set Priv(listboxPrev) [$w index active]
	    set Priv(listboxSelection) {}
d401 1
a401 1
# ::tk::ListboxExtendUpDown --
d411 1
a411 2
proc ::tk::ListboxExtendUpDown {w amount} {
    variable ::tk::Priv
d416 2
a417 1
    if {![info exists Priv(listboxSelection)]} {
d419 1
a419 1
	set Priv(listboxSelection) [$w curselection]
d423 1
a423 1
    ListboxMotion $w [$w index active]
d426 1
a426 1
# ::tk::ListboxDataExtend
d437 1
a437 1
proc ::tk::ListboxDataExtend {w el} {
d443 1
a443 1
	    ListboxMotion $w $el
d451 1
a451 1
# ::tk::ListboxCancel
d461 2
a462 2
proc ::tk::ListboxCancel w {
    variable ::tk::Priv
d467 1
a467 1
    set last $Priv(listboxPrev)
d479 1
a479 1
	if {[lsearch $Priv(listboxSelection) $first] >= 0} {
d487 1
a487 1
# ::tk::ListboxSelectAll
d496 1
a496 1
proc ::tk::ListboxSelectAll w {
d506 2
@


