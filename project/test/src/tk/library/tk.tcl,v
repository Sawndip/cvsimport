head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.4
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.46;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.14;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.26;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.52;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.33;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.51;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.01.21.19.54.48;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# tk.tcl --
#
# Initialization script normally executed in the interpreter for each
# Tk-based application.  Arranges class bindings for widgets.
#
# RCS: @@(#) $Id: tk.tcl,v 1.45 2002/10/10 16:34:51 hobbs Exp $
#
# Copyright (c) 1992-1994 The Regents of the University of California.
# Copyright (c) 1994-1996 Sun Microsystems, Inc.
# Copyright (c) 1998-2000 Ajuba Solutions.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

# Insist on running with compatible versions of Tcl and Tk.
package require -exact Tk 8.4
package require -exact Tcl 8.4

# Create a ::tk namespace
namespace eval ::tk {
    # Set up the msgcat commands
    namespace eval msgcat {
	namespace export mc mcmax        
        if {[interp issafe] || [catch {package require msgcat}]} {
            # The msgcat package is not available.  Supply our own
            # minimal replacement.
            proc mc {src args} {
                return [eval [list format $src] $args]
            }
            proc mcmax {args} {
                set max 0
                foreach string $args {
                    set len [string length $string]
                    if {$len>$max} {
                        set max $len
                    }
                }
                return $max
            }
        } else {
            # Get the commands from the msgcat package that Tk uses.
            namespace import ::msgcat::mc
            namespace import ::msgcat::mcmax
            ::msgcat::mcload [file join $::tk_library msgs]
        }
    }
    namespace import ::tk::msgcat::*
}

# Add Tk's directory to the end of the auto-load search path, if it
# isn't already on the path:

if {[info exists ::auto_path] && [string compare {} $::tk_library] && \
	[lsearch -exact $::auto_path $::tk_library] < 0} {
    lappend ::auto_path $::tk_library
}

# Turn off strict Motif look and feel as a default.

set ::tk_strictMotif 0

# Turn on useinputmethods (X Input Methods) by default.
# We catch this because safe interpreters may not allow the call.

catch {tk useinputmethods 1}

# ::tk::PlaceWindow --
#   place a toplevel at a particular position
# Arguments:
#   toplevel	name of toplevel window
#   ?placement?	pointer ?center? ; places $w centered on the pointer
#		widget widgetPath ; centers $w over widget_name
#		defaults to placing toplevel in the middle of the screen
#   ?anchor?	center or widgetPath
# Results:
#   Returns nothing
#
proc ::tk::PlaceWindow {w {place ""} {anchor ""}} {
    wm withdraw $w
    update idletasks
    set checkBounds 1
    if {[string equal -len [string length $place] $place "pointer"]} {
	## place at POINTER (centered if $anchor == center)
	if {[string equal -len [string length $anchor] $anchor "center"]} {
	    set x [expr {[winfo pointerx $w]-[winfo reqwidth $w]/2}]
	    set y [expr {[winfo pointery $w]-[winfo reqheight $w]/2}]
	} else {
	    set x [winfo pointerx $w]
	    set y [winfo pointery $w]
	}
    } elseif {[string equal -len [string length $place] $place "widget"] && \
	    [winfo exists $anchor] && [winfo ismapped $anchor]} {
	## center about WIDGET $anchor, widget must be mapped
	set x [expr {[winfo rootx $anchor] + \
		([winfo width $anchor]-[winfo reqwidth $w])/2}]
	set y [expr {[winfo rooty $anchor] + \
		([winfo height $anchor]-[winfo reqheight $w])/2}]
    } else {
	set x [expr {([winfo screenwidth $w]-[winfo reqwidth $w])/2}]
	set y [expr {([winfo screenheight $w]-[winfo reqheight $w])/2}]
	set checkBounds 0
    }
    if {$checkBounds} {
	if {$x < 0} {
	    set x 0
	} elseif {$x > ([winfo screenwidth $w]-[winfo reqwidth $w])} {
	    set x [expr {[winfo screenwidth $w]-[winfo reqwidth $w]}]
	}
	if {$y < 0} {
	    set y 0
	} elseif {$y > ([winfo screenheight $w]-[winfo reqheight $w])} {
	    set y [expr {[winfo screenheight $w]-[winfo reqheight $w]}]
	}
	if {[tk windowingsystem] eq "macintosh" \
		|| [tk windowingsystem] eq "aqua"} {
	    # Avoid the native menu bar which sits on top of everything.
	    if {$y < 20} { set y 20 }
	}
    }
    wm geometry $w +$x+$y
    wm deiconify $w
}

# ::tk::SetFocusGrab --
#   swap out current focus and grab temporarily (for dialogs)
# Arguments:
#   grab	new window to grab
#   focus	window to give focus to
# Results:
#   Returns nothing
#
proc ::tk::SetFocusGrab {grab {focus {}}} {
    set index "$grab,$focus"
    upvar ::tk::FocusGrab($index) data

    lappend data [focus]
    set oldGrab [grab current $grab]
    lappend data $oldGrab
    if {[winfo exists $oldGrab]} {
	lappend data [grab status $oldGrab]
    }
    # The "grab" command will fail if another application
    # already holds the grab.  So catch it.
    catch {grab $grab}
    if {[winfo exists $focus]} {
	focus $focus
    }
}

# ::tk::RestoreFocusGrab --
#   restore old focus and grab (for dialogs)
# Arguments:
#   grab	window that had taken grab
#   focus	window that had taken focus
#   destroy	destroy|withdraw - how to handle the old grabbed window
# Results:
#   Returns nothing
#
proc ::tk::RestoreFocusGrab {grab focus {destroy destroy}} {
    set index "$grab,$focus"
    if {[info exists ::tk::FocusGrab($index)]} {
	foreach {oldFocus oldGrab oldStatus} $::tk::FocusGrab($index) { break }
	unset ::tk::FocusGrab($index)
    } else {
	set oldGrab ""
    }

    catch {focus $oldFocus}
    grab release $grab
    if {[string equal $destroy "withdraw"]} {
	wm withdraw $grab
    } else {
	destroy $grab
    }
    if {[winfo exists $oldGrab] && [winfo ismapped $oldGrab]} {
	if {[string equal $oldStatus "global"]} {
	    grab -global $oldGrab
	} else {
	    grab $oldGrab
	}
    }
}

# ::tk::GetSelection --
#   This tries to obtain the default selection.  On Unix, we first try
#   and get a UTF8_STRING, a type supported by modern Unix apps for
#   passing Unicode data safely.  We fall back on the default STRING
#   type otherwise.  On Windows, only the STRING type is necessary.
# Arguments:
#   w	The widget for which the selection will be retrieved.
#	Important for the -displayof property.
#   sel	The source of the selection (PRIMARY or CLIPBOARD)
# Results:
#   Returns the selection, or an error if none could be found
#
if {[string equal $tcl_platform(platform) "unix"]} {
    proc ::tk::GetSelection {w {sel PRIMARY}} {
	if {[catch {selection get -displayof $w -selection $sel \
		-type UTF8_STRING} txt] \
		&& [catch {selection get -displayof $w -selection $sel} txt]} {
	    return -code error "could not find default selection"
	} else {
	    return $txt
	}
    }
} else {
    proc ::tk::GetSelection {w {sel PRIMARY}} {
	if {[catch {selection get -displayof $w -selection $sel} txt]} {
	    return -code error "could not find default selection"
	} else {
	    return $txt
	}
    }
}

# ::tk::ScreenChanged --
# This procedure is invoked by the binding mechanism whenever the
# "current" screen is changing.  The procedure does two things.
# First, it uses "upvar" to make variable "::tk::Priv" point at an
# array variable that holds state for the current display.  Second,
# it initializes the array if it didn't already exist.
#
# Arguments:
# screen -		The name of the new screen.

proc ::tk::ScreenChanged screen {
    set x [string last . $screen]
    if {$x > 0} {
	set disp [string range $screen 0 [expr {$x - 1}]]
    } else {
	set disp $screen
    }

    uplevel #0 upvar #0 ::tk::Priv.$disp ::tk::Priv
    variable ::tk::Priv
    global tcl_platform

    if {[info exists Priv]} {
	set Priv(screen) $screen
	return
    }
    array set Priv {
	activeMenu	{}
	activeItem	{}
	afterId		{}
	buttons		0
	buttonWindow	{}
	dragging	0
	focus		{}
	grab		{}
	initPos		{}
	inMenubutton	{}
	listboxPrev	{}
	menuBar		{}
	mouseMoved	0
	oldGrab		{}
	popup		{}
	postedMb	{}
	pressX		0
	pressY		0
	prevPos		0
	selectMode	char
    }
    set Priv(screen) $screen
    set Priv(tearoff) [string equal [tk windowingsystem] "x11"]
    set Priv(window) {}
}

# Do initial setup for Priv, so that it is always bound to something
# (otherwise, if someone references it, it may get set to a non-upvar-ed
# value, which will cause trouble later).

tk::ScreenChanged [winfo screen .]

# ::tk::EventMotifBindings --
# This procedure is invoked as a trace whenever ::tk_strictMotif is
# changed.  It is used to turn on or turn off the motif virtual
# bindings.
#
# Arguments:
# n1 - the name of the variable being changed ("::tk_strictMotif").

proc ::tk::EventMotifBindings {n1 dummy dummy} {
    upvar $n1 name
    
    if {$name} {
	set op delete
    } else {
	set op add
    }

    event $op <<Cut>> <Control-Key-w>
    event $op <<Copy>> <Meta-Key-w> 
    event $op <<Paste>> <Control-Key-y>
    event $op <<Undo>> <Control-underscore>
}

#----------------------------------------------------------------------
# Define common dialogs on platforms where they are not implemented 
# using compiled code.
#----------------------------------------------------------------------

if {[string equal [info commands tk_chooseColor] ""]} {
    proc ::tk_chooseColor {args} {
	return [eval tk::dialog::color:: $args]
    }
}
if {[string equal [info commands tk_getOpenFile] ""]} {
    proc ::tk_getOpenFile {args} {
	if {$::tk_strictMotif} {
	    return [eval tk::MotifFDialog open $args]
	} else {
	    return [eval ::tk::dialog::file:: open $args]
	}
    }
}
if {[string equal [info commands tk_getSaveFile] ""]} {
    proc ::tk_getSaveFile {args} {
	if {$::tk_strictMotif} {
	    return [eval tk::MotifFDialog save $args]
	} else {
	    return [eval ::tk::dialog::file:: save $args]
	}
    }
}
if {[string equal [info commands tk_messageBox] ""]} {
    proc ::tk_messageBox {args} {
	return [eval tk::MessageBox $args]
    }
}
if {[string equal [info command tk_chooseDirectory] ""]} {
    proc ::tk_chooseDirectory {args} {
	return [eval ::tk::dialog::file::chooseDir:: $args]
    }
}
	
#----------------------------------------------------------------------
# Define the set of common virtual events.
#----------------------------------------------------------------------

switch [tk windowingsystem] {
    "x11" {
	event add <<Cut>> <Control-Key-x> <Key-F20> 
	event add <<Copy>> <Control-Key-c> <Key-F16>
	event add <<Paste>> <Control-Key-v> <Key-F18>
	event add <<PasteSelection>> <ButtonRelease-2>
	event add <<Undo>> <Control-Key-z>
	event add <<Redo>> <Control-Key-Z>
	# Some OS's define a goofy (as in, not <Shift-Tab>) keysym
	# that is returned when the user presses <Shift-Tab>.  In order for
	# tab traversal to work, we have to add these keysyms to the 
	# PrevWindow event.
	# We use catch just in case the keysym isn't recognized.
	# This is needed for XFree86 systems
	catch { event add <<PrevWindow>> <ISO_Left_Tab> }
	# This seems to be correct on *some* HP systems.
	catch { event add <<PrevWindow>> <hpBackTab> }

	trace variable ::tk_strictMotif w ::tk::EventMotifBindings
	set ::tk_strictMotif $::tk_strictMotif
    }
    "win32" {
	event add <<Cut>> <Control-Key-x> <Shift-Key-Delete>
	event add <<Copy>> <Control-Key-c> <Control-Key-Insert>
	event add <<Paste>> <Control-Key-v> <Shift-Key-Insert>
	event add <<PasteSelection>> <ButtonRelease-2>
  	event add <<Undo>> <Control-Key-z>
	event add <<Redo>> <Control-Key-y>
    }
    "aqua" {
	event add <<Cut>> <Command-Key-x> <Key-F2> 
	event add <<Copy>> <Command-Key-c> <Key-F3>
	event add <<Paste>> <Command-Key-v> <Key-F4>
	event add <<PasteSelection>> <ButtonRelease-2>
	event add <<Clear>> <Clear>
  	event add <<Undo>> <Command-Key-z>
	event add <<Redo>> <Command-Key-y>
    }
    "classic" {
	event add <<Cut>> <Control-Key-x> <Key-F2> 
	event add <<Copy>> <Control-Key-c> <Key-F3>
	event add <<Paste>> <Control-Key-v> <Key-F4>
	event add <<PasteSelection>> <ButtonRelease-2>
	event add <<Clear>> <Clear>
	event add <<Undo>> <Control-Key-z> <Key-F1>
	event add <<Redo>> <Control-Key-Z>
    }
}
# ----------------------------------------------------------------------
# Read in files that define all of the class bindings.
# ----------------------------------------------------------------------

if {$::tk_library ne ""} {
    if {[string equal $tcl_platform(platform) "macintosh"]} {
	proc ::tk::SourceLibFile {file} {
	    if {[catch {
		namespace eval :: \
			[list source [file join $::tk_library $file.tcl]]
	    }]} {
		namespace eval :: [list source -rsrc $file]
	    }
	}
    } else {
	proc ::tk::SourceLibFile {file} {
	    namespace eval :: [list source [file join $::tk_library $file.tcl]]
	}	
    }
    namespace eval ::tk {
	SourceLibFile button
	SourceLibFile entry
	SourceLibFile listbox
	SourceLibFile menu
	SourceLibFile panedwindow
	SourceLibFile scale
	SourceLibFile scrlbar
	SourceLibFile spinbox
	SourceLibFile text
    }
}
# ----------------------------------------------------------------------
# Default bindings for keyboard traversal.
# ----------------------------------------------------------------------

event add <<PrevWindow>> <Shift-Tab>
bind all <Tab> {tk::TabToWindow [tk_focusNext %W]}
bind all <<PrevWindow>> {tk::TabToWindow [tk_focusPrev %W]}

# ::tk::CancelRepeat --
# This procedure is invoked to cancel an auto-repeat action described
# by ::tk::Priv(afterId).  It's used by several widgets to auto-scroll
# the widget when the mouse is dragged out of the widget with a
# button pressed.
#
# Arguments:
# None.

proc ::tk::CancelRepeat {} {
    variable ::tk::Priv
    after cancel $Priv(afterId)
    set Priv(afterId) {}
}

# ::tk::TabToWindow --
# This procedure moves the focus to the given widget.  If the widget
# is an entry, it selects the entire contents of the widget.
#
# Arguments:
# w - Window to which focus should be set.

proc ::tk::TabToWindow {w} {
    if {[string equal [winfo class $w] Entry]} {
	$w selection range 0 end
	$w icursor end
    }
    focus $w
}

# ::tk::UnderlineAmpersand --
# This procedure takes some text with ampersand and returns
# text w/o ampersand and position of the ampersand.
# Double ampersands are converted to single ones.
# Position returned is -1 when there is no ampersand.
#
proc ::tk::UnderlineAmpersand {text} {
    set idx [string first "&" $text]
    if {$idx >= 0} {
	set underline $idx
	# ignore "&&"
	while {[string match "&" [string index $text [expr {$idx + 1}]]]} {
	    set base [expr {$idx + 2}]
	    set idx  [string first "&" [string range $text $base end]]
	    if {$idx < 0} {
		break
	    } else {
		set underline [expr {$underline + $idx + 1}]
		incr idx $base
	    }
	}
    }
    if {$idx >= 0} {
	regsub -all -- {&([^&])} $text {\1} text
    } 
    return [list $text $idx]
}

# ::tk::SetAmpText -- 
# Given widget path and text with "magic ampersands",
# sets -text and -underline options for the widget
#
proc ::tk::SetAmpText {widget text} {
    foreach {newtext under} [::tk::UnderlineAmpersand $text] {
	$widget configure -text $newtext -underline $under
    }
}

# ::tk::AmpWidget --
# Creates new widget, turning -text option into -text and
# -underline options, returned by ::tk::UnderlineAmpersand.
#
proc ::tk::AmpWidget {class path args} {
    set wcmd [list $class $path]
    foreach {opt val} $args {
	if {[string equal $opt {-text}]} {
	    foreach {newtext under} [::tk::UnderlineAmpersand $val] {
		lappend wcmd -text $newtext -underline $under
	    }
	} else {
	    lappend wcmd $opt $val
	}
    }
    eval $wcmd
    if {$class=="button"} {
	bind $path <<AltUnderlined>> [list $path invoke]
    }
    return $path
}

# ::tk::FindAltKeyTarget --
# search recursively through the hierarchy of visible widgets
# to find button or label which has $char as underlined character
#
proc ::tk::FindAltKeyTarget {path char} {
    switch [winfo class $path] {
	Button -
	Label {
	    if {[string equal -nocase $char \
		[string index [$path cget -text] \
		[$path cget -underline]]]} {return $path} else {return {}}
	}
	default {
	    foreach child \
		[concat [grid slaves $path] \
		[pack slaves $path] \
		[place slaves $path] ] {
		if {""!=[set target [::tk::FindAltKeyTarget $child $char]]} {
		    return $target
		}
	    }
	}
    }
    return {}
}

# ::tk::AltKeyInDialog --
# <Alt-Key> event handler for standard dialogs. Sends <<AltUnderlined>>
# to button or label which has appropriate underlined character
#
proc ::tk::AltKeyInDialog {path key} {
    set target [::tk::FindAltKeyTarget $path $key]
    if { $target == ""} return
    event generate $target <<AltUnderlined>>
}

# ::tk::mcmaxamp --
# Replacement for mcmax, used for texts with "magic ampersand" in it.
#

proc ::tk::mcmaxamp {args} {
    set maxlen 0
    foreach arg $args {
	set length [string length [lindex [::tk::UnderlineAmpersand [mc $arg]] 0]]
	if {$length>$maxlen} {
	    set maxlen $length
	}
    }
    return $maxlen
}
# For now, turn off the custom mdef proc for the mac:

if {[string equal [tk windowingsystem] "aqua"]} {
    namespace eval ::tk::mac {
	set useCustomMDEF 0
    }
}
@


1.4
log
@touched all sources to ease next import
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: tk.tcl,v 1.7.6.2 2000/09/26 16:08:49 spolk Exp $
d10 1
a10 1
# Copyright (c) 1998-2000 Scriptics Corporation.
d16 2
d19 30
a48 2
package require -exact Tk 8.3
package require -exact Tcl 8.3
d53 3
a55 3
if {[info exists auto_path] && [string compare {} $tk_library] && \
	[lsearch -exact $auto_path $tk_library] < 0} {
    lappend auto_path $tk_library
d60 1
a60 1
set tk_strictMotif 0
d62 2
a63 1
# Create a ::tk namespace
d65 1
a65 2
namespace eval ::tk {
}
d114 5
d142 3
a144 1
    grab $grab
d161 6
a166 2
    foreach {oldFocus oldGrab oldStatus} $::tk::FocusGrab($index) { break }
    unset ::tk::FocusGrab($index)
d184 33
a216 1
# tkScreenChanged --
d219 1
a219 1
# First, it uses "upvar" to make global variable "tkPriv" point at an
d226 1
a226 1
proc tkScreenChanged screen {
d234 2
a235 2
    uplevel #0 upvar #0 tkPriv.$disp tkPriv
    global tkPriv
d238 2
a239 2
    if {[info exists tkPriv]} {
	set tkPriv(screen) $screen
d242 1
a242 1
    array set tkPriv {
d264 3
a266 3
    set tkPriv(screen) $screen
    set tkPriv(tearoff) [string equal $tcl_platform(platform) "unix"]
    set tkPriv(window) {}
d269 1
a269 1
# Do initial setup for tkPriv, so that it is always bound to something
d273 1
a273 1
tkScreenChanged [winfo screen .]
d275 2
a276 2
# tkEventMotifBindings --
# This procedure is invoked as a trace whenever tk_strictMotif is
d281 1
a281 1
# n1 - the name of the variable being changed ("tk_strictMotif").
d283 1
a283 1
proc tkEventMotifBindings {n1 dummy dummy} {
d295 1
d304 2
a305 2
    proc tk_chooseColor {args} {
	return [eval tkColorDialog $args]
d309 1
a309 1
    proc tk_getOpenFile {args} {
d311 1
a311 1
	    return [eval tkMotifFDialog open $args]
d313 1
a313 1
	    return [eval ::tk::dialog::file::tkFDialog open $args]
d318 1
a318 1
    proc tk_getSaveFile {args} {
d320 1
a320 1
	    return [eval tkMotifFDialog save $args]
d322 1
a322 1
	    return [eval ::tk::dialog::file::tkFDialog save $args]
d327 2
a328 2
    proc tk_messageBox {args} {
	return [eval tkMessageBox $args]
d332 2
a333 2
    proc tk_chooseDirectory {args} {
	return [eval ::tk::dialog::file::chooseDir::tkChooseDirectory $args]
d341 2
a342 2
switch $tcl_platform(platform) {
    "unix" {
d347 2
d353 8
a360 11
	# The info exists is necessary, because tcl_platform(os) doesn't
	# exist in safe interpreters.
	if {[info exists tcl_platform(os)]} {
	    switch $tcl_platform(os) {
		"IRIX"  -
		"Linux" { event add <<PrevWindow>> <ISO_Left_Tab> }
		"HP-UX" { event add <<PrevWindow>> <hpBackTab> }
	    }
	}
	trace variable tk_strictMotif w tkEventMotifBindings
	set tk_strictMotif $tk_strictMotif
d362 1
a362 1
    "windows" {
d367 2
d370 10
a379 1
    "macintosh" {
d385 2
a388 1

d393 26
a418 9
if {[string compare $tcl_platform(platform) "macintosh"] && \
	[string compare {} $tk_library]} {
    source [file join $tk_library button.tcl]
    source [file join $tk_library entry.tcl]
    source [file join $tk_library listbox.tcl]
    source [file join $tk_library menu.tcl]
    source [file join $tk_library scale.tcl]
    source [file join $tk_library scrlbar.tcl]
    source [file join $tk_library text.tcl]
a419 1

d425 2
a426 2
bind all <Tab> {tkTabToWindow [tk_focusNext %W]}
bind all <<PrevWindow>> {tkTabToWindow [tk_focusPrev %W]}
d428 1
a428 1
# tkCancelRepeat --
d430 1
a430 1
# by tkPriv(afterId).  It's used by several widgets to auto-scroll
d437 4
a440 4
proc tkCancelRepeat {} {
    global tkPriv
    after cancel $tkPriv(afterId)
    set tkPriv(afterId) {}
d443 1
a443 1
# tkTabToWindow --
d450 1
a450 1
proc tkTabToWindow {w} {
d458 95
d554 21
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
# SCCS: @@(#) tk.tcl 1.98 97/10/28 15:21:04
d10 1
d17 2
a18 2
package require -exact Tk 8.0
package require -exact Tcl 8.0
d23 3
a25 4
if {[info exists auto_path]} {
    if {[lsearch -exact $auto_path $tk_library] < 0} {
	lappend auto_path $tk_library
    }
d32 111
d169 22
a190 19
    set tkPriv(activeMenu) {}
    set tkPriv(activeItem) {}
    set tkPriv(afterId) {}
    set tkPriv(buttons) 0
    set tkPriv(buttonWindow) {}
    set tkPriv(dragging) 0
    set tkPriv(focus) {}
    set tkPriv(grab) {}
    set tkPriv(initPos) {}
    set tkPriv(inMenubutton) {}
    set tkPriv(listboxPrev) {}
    set tkPriv(menuBar) {}
    set tkPriv(mouseMoved) 0
    set tkPriv(oldGrab) {}
    set tkPriv(popup) {}
    set tkPriv(postedMb) {}
    set tkPriv(pressX) 0
    set tkPriv(pressY) 0
    set tkPriv(prevPos) 0
d192 1
a192 6
    set tkPriv(selectMode) char
    if {[string compare $tcl_platform(platform) "unix"] == 0} {
	set tkPriv(tearoff) 1
    } else {
	set tkPriv(tearoff) 0
    }
d225 39
d273 13
d308 9
a316 8
if {$tcl_platform(platform) != "macintosh"} {
    source $tk_library/button.tcl
    source $tk_library/entry.tcl
    source $tk_library/listbox.tcl
    source $tk_library/menu.tcl
    source $tk_library/scale.tcl
    source $tk_library/scrlbar.tcl
    source $tk_library/text.tcl
d323 1
d325 1
a325 1
bind all <Shift-Tab> {tkTabToWindow [tk_focusPrev %W]}
d350 3
a352 3
    if {"[winfo class $w]" == "Entry"} {
	$w select range 0 end
	$w icur end
d356 2
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: tk.tcl,v 1.7.6.2 2000/09/26 16:08:49 spolk Exp $
a9 1
# Copyright (c) 1998-2000 Scriptics Corporation.
d16 2
a17 2
package require -exact Tk 8.3
package require -exact Tcl 8.3
d22 4
a25 3
if {[info exists auto_path] && [string compare {} $tk_library] && \
	[lsearch -exact $auto_path $tk_library] < 0} {
    lappend auto_path $tk_library
a31 111
# Create a ::tk namespace

namespace eval ::tk {
}

# ::tk::PlaceWindow --
#   place a toplevel at a particular position
# Arguments:
#   toplevel	name of toplevel window
#   ?placement?	pointer ?center? ; places $w centered on the pointer
#		widget widgetPath ; centers $w over widget_name
#		defaults to placing toplevel in the middle of the screen
#   ?anchor?	center or widgetPath
# Results:
#   Returns nothing
#
proc ::tk::PlaceWindow {w {place ""} {anchor ""}} {
    wm withdraw $w
    update idletasks
    set checkBounds 1
    if {[string equal -len [string length $place] $place "pointer"]} {
	## place at POINTER (centered if $anchor == center)
	if {[string equal -len [string length $anchor] $anchor "center"]} {
	    set x [expr {[winfo pointerx $w]-[winfo reqwidth $w]/2}]
	    set y [expr {[winfo pointery $w]-[winfo reqheight $w]/2}]
	} else {
	    set x [winfo pointerx $w]
	    set y [winfo pointery $w]
	}
    } elseif {[string equal -len [string length $place] $place "widget"] && \
	    [winfo exists $anchor] && [winfo ismapped $anchor]} {
	## center about WIDGET $anchor, widget must be mapped
	set x [expr {[winfo rootx $anchor] + \
		([winfo width $anchor]-[winfo reqwidth $w])/2}]
	set y [expr {[winfo rooty $anchor] + \
		([winfo height $anchor]-[winfo reqheight $w])/2}]
    } else {
	set x [expr {([winfo screenwidth $w]-[winfo reqwidth $w])/2}]
	set y [expr {([winfo screenheight $w]-[winfo reqheight $w])/2}]
	set checkBounds 0
    }
    if {$checkBounds} {
	if {$x < 0} {
	    set x 0
	} elseif {$x > ([winfo screenwidth $w]-[winfo reqwidth $w])} {
	    set x [expr {[winfo screenwidth $w]-[winfo reqwidth $w]}]
	}
	if {$y < 0} {
	    set y 0
	} elseif {$y > ([winfo screenheight $w]-[winfo reqheight $w])} {
	    set y [expr {[winfo screenheight $w]-[winfo reqheight $w]}]
	}
    }
    wm geometry $w +$x+$y
    wm deiconify $w
}

# ::tk::SetFocusGrab --
#   swap out current focus and grab temporarily (for dialogs)
# Arguments:
#   grab	new window to grab
#   focus	window to give focus to
# Results:
#   Returns nothing
#
proc ::tk::SetFocusGrab {grab {focus {}}} {
    set index "$grab,$focus"
    upvar ::tk::FocusGrab($index) data

    lappend data [focus]
    set oldGrab [grab current $grab]
    lappend data $oldGrab
    if {[winfo exists $oldGrab]} {
	lappend data [grab status $oldGrab]
    }
    grab $grab
    if {[winfo exists $focus]} {
	focus $focus
    }
}

# ::tk::RestoreFocusGrab --
#   restore old focus and grab (for dialogs)
# Arguments:
#   grab	window that had taken grab
#   focus	window that had taken focus
#   destroy	destroy|withdraw - how to handle the old grabbed window
# Results:
#   Returns nothing
#
proc ::tk::RestoreFocusGrab {grab focus {destroy destroy}} {
    set index "$grab,$focus"
    foreach {oldFocus oldGrab oldStatus} $::tk::FocusGrab($index) { break }
    unset ::tk::FocusGrab($index)

    catch {focus $oldFocus}
    grab release $grab
    if {[string equal $destroy "withdraw"]} {
	wm withdraw $grab
    } else {
	destroy $grab
    }
    if {[winfo exists $oldGrab] && [winfo ismapped $oldGrab]} {
	if {[string equal $oldStatus "global"]} {
	    grab -global $oldGrab
	} else {
	    grab $oldGrab
	}
    }
}

d58 25
a82 21
    array set tkPriv {
	activeMenu	{}
	activeItem	{}
	afterId		{}
	buttons		0
	buttonWindow	{}
	dragging	0
	focus		{}
	grab		{}
	initPos		{}
	inMenubutton	{}
	listboxPrev	{}
	menuBar		{}
	mouseMoved	0
	oldGrab		{}
	popup		{}
	postedMb	{}
	pressX		0
	pressY		0
	prevPos		0
	selectMode	char
a83 2
    set tkPriv(screen) $screen
    set tkPriv(tearoff) [string equal $tcl_platform(platform) "unix"]
a115 39
# Define common dialogs on platforms where they are not implemented 
# using compiled code.
#----------------------------------------------------------------------

if {[string equal [info commands tk_chooseColor] ""]} {
    proc tk_chooseColor {args} {
	return [eval tkColorDialog $args]
    }
}
if {[string equal [info commands tk_getOpenFile] ""]} {
    proc tk_getOpenFile {args} {
	if {$::tk_strictMotif} {
	    return [eval tkMotifFDialog open $args]
	} else {
	    return [eval ::tk::dialog::file::tkFDialog open $args]
	}
    }
}
if {[string equal [info commands tk_getSaveFile] ""]} {
    proc tk_getSaveFile {args} {
	if {$::tk_strictMotif} {
	    return [eval tkMotifFDialog save $args]
	} else {
	    return [eval ::tk::dialog::file::tkFDialog save $args]
	}
    }
}
if {[string equal [info commands tk_messageBox] ""]} {
    proc tk_messageBox {args} {
	return [eval tkMessageBox $args]
    }
}
if {[string equal [info command tk_chooseDirectory] ""]} {
    proc tk_chooseDirectory {args} {
	return [eval ::tk::dialog::file::chooseDir::tkChooseDirectory $args]
    }
}
	
#----------------------------------------------------------------------
a124 13
	# Some OS's define a goofy (as in, not <Shift-Tab>) keysym
	# that is returned when the user presses <Shift-Tab>.  In order for
	# tab traversal to work, we have to add these keysyms to the 
	# PrevWindow event.
	# The info exists is necessary, because tcl_platform(os) doesn't
	# exist in safe interpreters.
	if {[info exists tcl_platform(os)]} {
	    switch $tcl_platform(os) {
		"IRIX"  -
		"Linux" { event add <<PrevWindow>> <ISO_Left_Tab> }
		"HP-UX" { event add <<PrevWindow>> <hpBackTab> }
	    }
	}
d147 8
a154 9
if {[string compare $tcl_platform(platform) "macintosh"] && \
	[string compare {} $tk_library]} {
    source [file join $tk_library button.tcl]
    source [file join $tk_library entry.tcl]
    source [file join $tk_library listbox.tcl]
    source [file join $tk_library menu.tcl]
    source [file join $tk_library scale.tcl]
    source [file join $tk_library scrlbar.tcl]
    source [file join $tk_library text.tcl]
a160 1
event add <<PrevWindow>> <Shift-Tab>
d162 1
a162 1
bind all <<PrevWindow>> {tkTabToWindow [tk_focusPrev %W]}
d187 3
a189 3
    if {[string equal [winfo class $w] Entry]} {
	$w selection range 0 end
	$w icursor end
a192 2


@


1.1.1.3
log
@import tk 8.4.0
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: tk.tcl,v 1.44 2002/09/09 23:52:02 hobbs Exp $
d10 1
a10 1
# Copyright (c) 1998-2000 Ajuba Solutions.
a15 2
package require -exact Tk 8.4
package require -exact Tcl 8.4
d17 2
a18 30
# Create a ::tk namespace
namespace eval ::tk {
    # Set up the msgcat commands
    namespace eval msgcat {
	namespace export mc mcmax        
        if {[interp issafe] || [catch {package require msgcat}]} {
            # The msgcat package is not available.  Supply our own
            # minimal replacement.
            proc mc {src args} {
                return [eval [list format $src] $args]
            }
            proc mcmax {args} {
                set max 0
                foreach string $args {
                    set len [string length $string]
                    if {$len>$max} {
                        set max $len
                    }
                }
                return $max
            }
        } else {
            # Get the commands from the msgcat package that Tk uses.
            namespace import ::msgcat::mc
            namespace import ::msgcat::mcmax
            ::msgcat::mcload [file join $::tk_library msgs]
        }
    }
    namespace import ::tk::msgcat::*
}
d23 3
a25 3
if {[info exists ::auto_path] && [string compare {} $::tk_library] && \
	[lsearch -exact $::auto_path $::tk_library] < 0} {
    lappend ::auto_path $::tk_library
d30 1
a30 1
set ::tk_strictMotif 0
d32 1
a32 2
# Turn on useinputmethods (X Input Methods) by default.
# We catch this because safe interpreters may not allow the call.
d34 2
a35 1
catch {tk useinputmethods 1}
a83 5
	if {[tk windowingsystem] eq "macintosh" \
		|| [tk windowingsystem] eq "aqua"} {
	    # Avoid the native menu bar which sits on top of everything.
	    if {$y < 20} { set y 20 }
	}
d107 1
a107 3
    # The "grab" command will fail if another application
    # already holds the grab.  So catch it.
    catch {grab $grab}
d124 2
a125 6
    if {[info exists ::tk::FocusGrab($index)]} {
	foreach {oldFocus oldGrab oldStatus} $::tk::FocusGrab($index) { break }
	unset ::tk::FocusGrab($index)
    } else {
	set oldGrab ""
    }
d143 1
a143 33
# ::tk::GetSelection --
#   This tries to obtain the default selection.  On Unix, we first try
#   and get a UTF8_STRING, a type supported by modern Unix apps for
#   passing Unicode data safely.  We fall back on the default STRING
#   type otherwise.  On Windows, only the STRING type is necessary.
# Arguments:
#   w	The widget for which the selection will be retrieved.
#	Important for the -displayof property.
#   sel	The source of the selection (PRIMARY or CLIPBOARD)
# Results:
#   Returns the selection, or an error if none could be found
#
if {[string equal $tcl_platform(platform) "unix"]} {
    proc ::tk::GetSelection {w {sel PRIMARY}} {
	if {[catch {selection get -displayof $w -selection $sel \
		-type UTF8_STRING} txt] \
		&& [catch {selection get -displayof $w -selection $sel} txt]} {
	    return -code error "could not find default selection"
	} else {
	    return $txt
	}
    }
} else {
    proc ::tk::GetSelection {w {sel PRIMARY}} {
	if {[catch {selection get -displayof $w -selection $sel} txt]} {
	    return -code error "could not find default selection"
	} else {
	    return $txt
	}
    }
}

# ::tk::ScreenChanged --
d146 1
a146 1
# First, it uses "upvar" to make variable "::tk::Priv" point at an
d153 1
a153 1
proc ::tk::ScreenChanged screen {
d161 2
a162 2
    uplevel #0 upvar #0 ::tk::Priv.$disp ::tk::Priv
    variable ::tk::Priv
d165 2
a166 2
    if {[info exists Priv]} {
	set Priv(screen) $screen
d169 1
a169 1
    array set Priv {
d191 3
a193 3
    set Priv(screen) $screen
    set Priv(tearoff) [string equal [tk windowingsystem] "x11"]
    set Priv(window) {}
d196 1
a196 1
# Do initial setup for Priv, so that it is always bound to something
d200 1
a200 1
tk::ScreenChanged [winfo screen .]
d202 2
a203 2
# ::tk::EventMotifBindings --
# This procedure is invoked as a trace whenever ::tk_strictMotif is
d208 1
a208 1
# n1 - the name of the variable being changed ("::tk_strictMotif").
d210 1
a210 1
proc ::tk::EventMotifBindings {n1 dummy dummy} {
a221 1
    event $op <<Undo>> <Control-underscore>
d230 2
a231 2
    proc ::tk_chooseColor {args} {
	return [eval tk::dialog::color:: $args]
d235 1
a235 1
    proc ::tk_getOpenFile {args} {
d237 1
a237 1
	    return [eval tk::MotifFDialog open $args]
d239 1
a239 1
	    return [eval ::tk::dialog::file:: open $args]
d244 1
a244 1
    proc ::tk_getSaveFile {args} {
d246 1
a246 1
	    return [eval tk::MotifFDialog save $args]
d248 1
a248 1
	    return [eval ::tk::dialog::file:: save $args]
d253 2
a254 2
    proc ::tk_messageBox {args} {
	return [eval tk::MessageBox $args]
d258 2
a259 2
    proc ::tk_chooseDirectory {args} {
	return [eval ::tk::dialog::file::chooseDir:: $args]
d267 2
a268 2
switch [tk windowingsystem] {
    "x11" {
a272 2
	event add <<Undo>> <Control-Key-z>
	event add <<Redo>> <Control-Key-Z>
d283 1
a283 4
		"HP-UX" {
		    # This seems to be correct on *some* HP systems.
		    catch { event add <<PrevWindow>> <hpBackTab> }
		}
d286 2
a287 2
	trace variable ::tk_strictMotif w ::tk::EventMotifBindings
	set ::tk_strictMotif $::tk_strictMotif
d289 1
a289 1
    "win32" {
a293 2
  	event add <<Undo>> <Control-Key-z>
	event add <<Redo>> <Control-Key-y>
d295 1
a295 10
    "aqua" {
	event add <<Cut>> <Command-Key-x> <Key-F2> 
	event add <<Copy>> <Command-Key-c> <Key-F3>
	event add <<Paste>> <Command-Key-v> <Key-F4>
	event add <<PasteSelection>> <ButtonRelease-2>
	event add <<Clear>> <Clear>
  	event add <<Undo>> <Command-Key-z>
	event add <<Redo>> <Command-Key-y>
    }
    "classic" {
a300 2
	event add <<Undo>> <Control-Key-z> <Key-F1>
	event add <<Redo>> <Control-Key-Z>
d303 1
d308 9
a316 26
if {$::tk_library ne ""} {
    if {[string equal $tcl_platform(platform) "macintosh"]} {
	proc ::tk::SourceLibFile {file} {
	    if {[catch {
		namespace eval :: \
			[list source [file join $::tk_library $file.tcl]]
	    }]} {
		namespace eval :: [list source -rsrc $file]
	    }
	}
    } else {
	proc ::tk::SourceLibFile {file} {
	    namespace eval :: [list source [file join $::tk_library $file.tcl]]
	}	
    }
    namespace eval ::tk {
	SourceLibFile button
	SourceLibFile entry
	SourceLibFile listbox
	SourceLibFile menu
	SourceLibFile panedwindow
	SourceLibFile scale
	SourceLibFile scrlbar
	SourceLibFile spinbox
	SourceLibFile text
    }
d318 1
d324 2
a325 2
bind all <Tab> {tk::TabToWindow [tk_focusNext %W]}
bind all <<PrevWindow>> {tk::TabToWindow [tk_focusPrev %W]}
d327 1
a327 1
# ::tk::CancelRepeat --
d329 1
a329 1
# by ::tk::Priv(afterId).  It's used by several widgets to auto-scroll
d336 4
a339 4
proc ::tk::CancelRepeat {} {
    variable ::tk::Priv
    after cancel $Priv(afterId)
    set Priv(afterId) {}
d342 1
a342 1
# ::tk::TabToWindow --
d349 1
a349 1
proc ::tk::TabToWindow {w} {
a356 95
# ::tk::UnderlineAmpersand --
# This procedure takes some text with ampersand and returns
# text w/o ampersand and position of the ampersand.
# Double ampersands are converted to single ones.
# Position returned is -1 when there is no ampersand.
#
proc ::tk::UnderlineAmpersand {text} {
    set idx [string first "&" $text]
    if {$idx >= 0} {
	set underline $idx
	# ignore "&&"
	while {[string match "&" [string index $text [expr {$idx + 1}]]]} {
	    set base [expr {$idx + 2}]
	    set idx  [string first "&" [string range $text $base end]]
	    if {$idx < 0} {
		break
	    } else {
		set underline [expr {$underline + $idx + 1}]
		incr idx $base
	    }
	}
    }
    if {$idx >= 0} {
	regsub -all -- {&([^&])} $text {\1} text
    } 
    return [list $text $idx]
}

# ::tk::SetAmpText -- 
# Given widget path and text with "magic ampersands",
# sets -text and -underline options for the widget
#
proc ::tk::SetAmpText {widget text} {
    foreach {newtext under} [::tk::UnderlineAmpersand $text] {
	$widget configure -text $newtext -underline $under
    }
}

# ::tk::AmpWidget --
# Creates new widget, turning -text option into -text and
# -underline options, returned by ::tk::UnderlineAmpersand.
#
proc ::tk::AmpWidget {class path args} {
    set wcmd [list $class $path]
    foreach {opt val} $args {
	if {[string equal $opt {-text}]} {
	    foreach {newtext under} [::tk::UnderlineAmpersand $val] {
		lappend wcmd -text $newtext -underline $under
	    }
	} else {
	    lappend wcmd $opt $val
	}
    }
    eval $wcmd
    if {$class=="button"} {
	bind $path <<AltUnderlined>> [list $path invoke]
    }
    return $path
}

# ::tk::FindAltKeyTarget --
# search recursively through the hierarchy of visible widgets
# to find button or label which has $char as underlined character
#
proc ::tk::FindAltKeyTarget {path char} {
    switch [winfo class $path] {
	Button -
	Label {
	    if {[string equal -nocase $char \
		[string index [$path cget -text] \
		[$path cget -underline]]]} {return $path} else {return {}}
	}
	default {
	    foreach child \
		[concat [grid slaves $path] \
		[pack slaves $path] \
		[place slaves $path] ] {
		if {""!=[set target [::tk::FindAltKeyTarget $child $char]]} {
		    return $target
		}
	    }
	}
    }
    return {}
}

# ::tk::AltKeyInDialog --
# <Alt-Key> event handler for standard dialogs. Sends <<AltUnderlined>>
# to button or label which has appropriate underlined character
#
proc ::tk::AltKeyInDialog {path key} {
    set target [::tk::FindAltKeyTarget $path $key]
    if { $target == ""} return
    event generate $target <<AltUnderlined>>
}
a357 21
# ::tk::mcmaxamp --
# Replacement for mcmax, used for texts with "magic ampersand" in it.
#

proc ::tk::mcmaxamp {args} {
    set maxlen 0
    foreach arg $args {
	set length [string length [lindex [::tk::UnderlineAmpersand [mc $arg]] 0]]
	if {$length>$maxlen} {
	    set maxlen $length
	}
    }
    return $maxlen
}
# For now, turn off the custom mdef proc for the mac:

if {[string equal [tk windowingsystem] "aqua"]} {
    namespace eval ::tk::mac {
	set useCustomMDEF 0
    }
}
@


1.1.1.4
log
@imported tk 8.4.1
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: tk.tcl,v 1.45 2002/10/10 16:34:51 hobbs Exp $
d353 12
a364 6
	# We use catch just in case the keysym isn't recognized.
	# This is needed for XFree86 systems
	catch { event add <<PrevWindow>> <ISO_Left_Tab> }
	# This seems to be correct on *some* HP systems.
	catch { event add <<PrevWindow>> <hpBackTab> }

@


