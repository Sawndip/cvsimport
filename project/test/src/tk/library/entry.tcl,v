head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.46;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.14;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.26;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.52;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.33;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.50;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# entry.tcl --
#
# This file defines the default bindings for Tk entry widgets and provides
# procedures that help in implementing those bindings.
#
# RCS: @@(#) $Id: entry.tcl,v 1.20 2002/08/31 06:12:28 das Exp $
#
# Copyright (c) 1992-1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

#-------------------------------------------------------------------------
# Elements of tk::Priv that are used in this file:
#
# afterId -		If non-null, it means that auto-scanning is underway
#			and it gives the "after" id for the next auto-scan
#			command to be executed.
# mouseMoved -		Non-zero means the mouse has moved a significant
#			amount since the button went down (so, for example,
#			start dragging out a selection).
# pressX -		X-coordinate at which the mouse button was pressed.
# selectMode -		The style of selection currently underway:
#			char, word, or line.
# x, y -		Last known mouse coordinates for scanning
#			and auto-scanning.
# data -		Used for Cut and Copy
#-------------------------------------------------------------------------

#-------------------------------------------------------------------------
# The code below creates the default class bindings for entries.
#-------------------------------------------------------------------------
bind Entry <<Cut>> {
    if {![catch {tk::EntryGetSelection %W} tk::Priv(data)]} {
	clipboard clear -displayof %W
	clipboard append -displayof %W $tk::Priv(data)
	%W delete sel.first sel.last
	unset tk::Priv(data)
    }
}
bind Entry <<Copy>> {
    if {![catch {tk::EntryGetSelection %W} tk::Priv(data)]} {
	clipboard clear -displayof %W
	clipboard append -displayof %W $tk::Priv(data)
	unset tk::Priv(data)
    }
}
bind Entry <<Paste>> {
    global tcl_platform
    catch {
	if {[string compare [tk windowingsystem] "x11"]} {
	    catch {
		%W delete sel.first sel.last
	    }
	}
	%W insert insert [::tk::GetSelection %W CLIPBOARD]
	tk::EntrySeeInsert %W
    }
}
bind Entry <<Clear>> {
    %W delete sel.first sel.last
}
bind Entry <<PasteSelection>> {
    if {$tk_strictMotif || ![info exists tk::Priv(mouseMoved)]
	|| !$tk::Priv(mouseMoved)} {
	tk::EntryPaste %W %x
    }
}

# Standard Motif bindings:

bind Entry <1> {
    tk::EntryButton1 %W %x
    %W selection clear
}
bind Entry <B1-Motion> {
    set tk::Priv(x) %x
    tk::EntryMouseSelect %W %x
}
bind Entry <Double-1> {
    set tk::Priv(selectMode) word
    tk::EntryMouseSelect %W %x
    catch {%W icursor sel.last}
}
bind Entry <Triple-1> {
    set tk::Priv(selectMode) line
    tk::EntryMouseSelect %W %x
    catch {%W icursor sel.last}
}
bind Entry <Shift-1> {
    set tk::Priv(selectMode) char
    %W selection adjust @@%x
}
bind Entry <Double-Shift-1>	{
    set tk::Priv(selectMode) word
    tk::EntryMouseSelect %W %x
}
bind Entry <Triple-Shift-1>	{
    set tk::Priv(selectMode) line
    tk::EntryMouseSelect %W %x
}
bind Entry <B1-Leave> {
    set tk::Priv(x) %x
    tk::EntryAutoScan %W
}
bind Entry <B1-Enter> {
    tk::CancelRepeat
}
bind Entry <ButtonRelease-1> {
    tk::CancelRepeat
}
bind Entry <Control-1> {
    %W icursor @@%x
}

bind Entry <Left> {
    tk::EntrySetCursor %W [expr {[%W index insert] - 1}]
}
bind Entry <Right> {
    tk::EntrySetCursor %W [expr {[%W index insert] + 1}]
}
bind Entry <Shift-Left> {
    tk::EntryKeySelect %W [expr {[%W index insert] - 1}]
    tk::EntrySeeInsert %W
}
bind Entry <Shift-Right> {
    tk::EntryKeySelect %W [expr {[%W index insert] + 1}]
    tk::EntrySeeInsert %W
}
bind Entry <Control-Left> {
    tk::EntrySetCursor %W [tk::EntryPreviousWord %W insert]
}
bind Entry <Control-Right> {
    tk::EntrySetCursor %W [tk::EntryNextWord %W insert]
}
bind Entry <Shift-Control-Left> {
    tk::EntryKeySelect %W [tk::EntryPreviousWord %W insert]
    tk::EntrySeeInsert %W
}
bind Entry <Shift-Control-Right> {
    tk::EntryKeySelect %W [tk::EntryNextWord %W insert]
    tk::EntrySeeInsert %W
}
bind Entry <Home> {
    tk::EntrySetCursor %W 0
}
bind Entry <Shift-Home> {
    tk::EntryKeySelect %W 0
    tk::EntrySeeInsert %W
}
bind Entry <End> {
    tk::EntrySetCursor %W end
}
bind Entry <Shift-End> {
    tk::EntryKeySelect %W end
    tk::EntrySeeInsert %W
}

bind Entry <Delete> {
    if {[%W selection present]} {
	%W delete sel.first sel.last
    } else {
	%W delete insert
    }
}
bind Entry <BackSpace> {
    tk::EntryBackspace %W
}

bind Entry <Control-space> {
    %W selection from insert
}
bind Entry <Select> {
    %W selection from insert
}
bind Entry <Control-Shift-space> {
    %W selection adjust insert
}
bind Entry <Shift-Select> {
    %W selection adjust insert
}
bind Entry <Control-slash> {
    %W selection range 0 end
}
bind Entry <Control-backslash> {
    %W selection clear
}
bind Entry <KeyPress> {
    tk::EntryInsert %W %A
}

# Ignore all Alt, Meta, and Control keypresses unless explicitly bound.
# Otherwise, if a widget binding for one of these is defined, the
# <KeyPress> class binding will also fire and insert the character,
# which is wrong.  Ditto for Escape, Return, and Tab.

bind Entry <Alt-KeyPress> {# nothing}
bind Entry <Meta-KeyPress> {# nothing}
bind Entry <Control-KeyPress> {# nothing}
bind Entry <Escape> {# nothing}
bind Entry <Return> {# nothing}
bind Entry <KP_Enter> {# nothing}
bind Entry <Tab> {# nothing}
if {[string equal [tk windowingsystem] "classic"]
	|| [string equal [tk windowingsystem] "aqua"]} {
	bind Entry <Command-KeyPress> {# nothing}
}

# On Windows, paste is done using Shift-Insert.  Shift-Insert already
# generates the <<Paste>> event, so we don't need to do anything here.
if {[string compare $tcl_platform(platform) "windows"]} {
    bind Entry <Insert> {
	catch {tk::EntryInsert %W [::tk::GetSelection %W PRIMARY]}
    }
}

# Additional emacs-like bindings:

bind Entry <Control-a> {
    if {!$tk_strictMotif} {
	tk::EntrySetCursor %W 0
    }
}
bind Entry <Control-b> {
    if {!$tk_strictMotif} {
	tk::EntrySetCursor %W [expr {[%W index insert] - 1}]
    }
}
bind Entry <Control-d> {
    if {!$tk_strictMotif} {
	%W delete insert
    }
}
bind Entry <Control-e> {
    if {!$tk_strictMotif} {
	tk::EntrySetCursor %W end
    }
}
bind Entry <Control-f> {
    if {!$tk_strictMotif} {
	tk::EntrySetCursor %W [expr {[%W index insert] + 1}]
    }
}
bind Entry <Control-h> {
    if {!$tk_strictMotif} {
	tk::EntryBackspace %W
    }
}
bind Entry <Control-k> {
    if {!$tk_strictMotif} {
	%W delete insert end
    }
}
bind Entry <Control-t> {
    if {!$tk_strictMotif} {
	tk::EntryTranspose %W
    }
}
bind Entry <Meta-b> {
    if {!$tk_strictMotif} {
	tk::EntrySetCursor %W [tk::EntryPreviousWord %W insert]
    }
}
bind Entry <Meta-d> {
    if {!$tk_strictMotif} {
	%W delete insert [tk::EntryNextWord %W insert]
    }
}
bind Entry <Meta-f> {
    if {!$tk_strictMotif} {
	tk::EntrySetCursor %W [tk::EntryNextWord %W insert]
    }
}
bind Entry <Meta-BackSpace> {
    if {!$tk_strictMotif} {
	%W delete [tk::EntryPreviousWord %W insert] insert
    }
}
bind Entry <Meta-Delete> {
    if {!$tk_strictMotif} {
	%W delete [tk::EntryPreviousWord %W insert] insert
    }
}

# A few additional bindings of my own.

bind Entry <2> {
    if {!$tk_strictMotif} {
	::tk::EntryScanMark %W %x
    }
}
bind Entry <B2-Motion> {
    if {!$tk_strictMotif} {
	::tk::EntryScanDrag %W %x
    }
}

# ::tk::EntryClosestGap --
# Given x and y coordinates, this procedure finds the closest boundary
# between characters to the given coordinates and returns the index
# of the character just after the boundary.
#
# Arguments:
# w -		The entry window.
# x -		X-coordinate within the window.

proc ::tk::EntryClosestGap {w x} {
    set pos [$w index @@$x]
    set bbox [$w bbox $pos]
    if {($x - [lindex $bbox 0]) < ([lindex $bbox 2]/2)} {
	return $pos
    }
    incr pos
}

# ::tk::EntryButton1 --
# This procedure is invoked to handle button-1 presses in entry
# widgets.  It moves the insertion cursor, sets the selection anchor,
# and claims the input focus.
#
# Arguments:
# w -		The entry window in which the button was pressed.
# x -		The x-coordinate of the button press.

proc ::tk::EntryButton1 {w x} {
    variable ::tk::Priv

    set Priv(selectMode) char
    set Priv(mouseMoved) 0
    set Priv(pressX) $x
    $w icursor [EntryClosestGap $w $x]
    $w selection from insert
    if {[string compare "disabled" [$w cget -state]]} {focus $w}
}

# ::tk::EntryMouseSelect --
# This procedure is invoked when dragging out a selection with
# the mouse.  Depending on the selection mode (character, word,
# line) it selects in different-sized units.  This procedure
# ignores mouse motions initially until the mouse has moved from
# one character to another or until there have been multiple clicks.
#
# Arguments:
# w -		The entry window in which the button was pressed.
# x -		The x-coordinate of the mouse.

proc ::tk::EntryMouseSelect {w x} {
    variable ::tk::Priv

    set cur [EntryClosestGap $w $x]
    set anchor [$w index anchor]
    if {($cur != $anchor) || (abs($Priv(pressX) - $x) >= 3)} {
	set Priv(mouseMoved) 1
    }
    switch $Priv(selectMode) {
	char {
	    if {$Priv(mouseMoved)} {
		if {$cur < $anchor} {
		    $w selection range $cur $anchor
		} elseif {$cur > $anchor} {
		    $w selection range $anchor $cur
		} else {
		    $w selection clear
		}
	    }
	}
	word {
	    if {$cur < [$w index anchor]} {
		set before [tcl_wordBreakBefore [$w get] $cur]
		set after [tcl_wordBreakAfter [$w get] [expr {$anchor-1}]]
	    } else {
		set before [tcl_wordBreakBefore [$w get] $anchor]
		set after [tcl_wordBreakAfter [$w get] [expr {$cur - 1}]]
	    }
	    if {$before < 0} {
		set before 0
	    }
	    if {$after < 0} {
		set after end
	    }
	    $w selection range $before $after
	}
	line {
	    $w selection range 0 end
	}
    }
    if {$Priv(mouseMoved)} {
        $w icursor $cur
    }
    update idletasks
}

# ::tk::EntryPaste --
# This procedure sets the insertion cursor to the current mouse position,
# pastes the selection there, and sets the focus to the window.
#
# Arguments:
# w -		The entry window.
# x -		X position of the mouse.

proc ::tk::EntryPaste {w x} {
    $w icursor [EntryClosestGap $w $x]
    catch {$w insert insert [::tk::GetSelection $w PRIMARY]}
    if {[string compare "disabled" [$w cget -state]]} {focus $w}
}

# ::tk::EntryAutoScan --
# This procedure is invoked when the mouse leaves an entry window
# with button 1 down.  It scrolls the window left or right,
# depending on where the mouse is, and reschedules itself as an
# "after" command so that the window continues to scroll until the
# mouse moves back into the window or the mouse button is released.
#
# Arguments:
# w -		The entry window.

proc ::tk::EntryAutoScan {w} {
    variable ::tk::Priv
    set x $Priv(x)
    if {![winfo exists $w]} return
    if {$x >= [winfo width $w]} {
	$w xview scroll 2 units
	EntryMouseSelect $w $x
    } elseif {$x < 0} {
	$w xview scroll -2 units
	EntryMouseSelect $w $x
    }
    set Priv(afterId) [after 50 [list tk::EntryAutoScan $w]]
}

# ::tk::EntryKeySelect --
# This procedure is invoked when stroking out selections using the
# keyboard.  It moves the cursor to a new position, then extends
# the selection to that position.
#
# Arguments:
# w -		The entry window.
# new -		A new position for the insertion cursor (the cursor hasn't
#		actually been moved to this position yet).

proc ::tk::EntryKeySelect {w new} {
    if {![$w selection present]} {
	$w selection from insert
	$w selection to $new
    } else {
	$w selection adjust $new
    }
    $w icursor $new
}

# ::tk::EntryInsert --
# Insert a string into an entry at the point of the insertion cursor.
# If there is a selection in the entry, and it covers the point of the
# insertion cursor, then delete the selection before inserting.
#
# Arguments:
# w -		The entry window in which to insert the string
# s -		The string to insert (usually just a single character)

proc ::tk::EntryInsert {w s} {
    if {[string equal $s ""]} {
	return
    }
    catch {
	set insert [$w index insert]
	if {([$w index sel.first] <= $insert)
		&& ([$w index sel.last] >= $insert)} {
	    $w delete sel.first sel.last
	}
    }
    $w insert insert $s
    EntrySeeInsert $w
}

# ::tk::EntryBackspace --
# Backspace over the character just before the insertion cursor.
# If backspacing would move the cursor off the left edge of the
# window, reposition the cursor at about the middle of the window.
#
# Arguments:
# w -		The entry window in which to backspace.

proc ::tk::EntryBackspace w {
    if {[$w selection present]} {
	$w delete sel.first sel.last
    } else {
	set x [expr {[$w index insert] - 1}]
	if {$x >= 0} {$w delete $x}
	if {[$w index @@0] >= [$w index insert]} {
	    set range [$w xview]
	    set left [lindex $range 0]
	    set right [lindex $range 1]
	    $w xview moveto [expr {$left - ($right - $left)/2.0}]
	}
    }
}

# ::tk::EntrySeeInsert --
# Make sure that the insertion cursor is visible in the entry window.
# If not, adjust the view so that it is.
#
# Arguments:
# w -		The entry window.

proc ::tk::EntrySeeInsert w {
    set c [$w index insert]
    if {($c < [$w index @@0]) || ($c > [$w index @@[winfo width $w]])} {
	$w xview $c
    }
}

# ::tk::EntrySetCursor -
# Move the insertion cursor to a given position in an entry.  Also
# clears the selection, if there is one in the entry, and makes sure
# that the insertion cursor is visible.
#
# Arguments:
# w -		The entry window.
# pos -		The desired new position for the cursor in the window.

proc ::tk::EntrySetCursor {w pos} {
    $w icursor $pos
    $w selection clear
    EntrySeeInsert $w
}

# ::tk::EntryTranspose -
# This procedure implements the "transpose" function for entry widgets.
# It tranposes the characters on either side of the insertion cursor,
# unless the cursor is at the end of the line.  In this case it
# transposes the two characters to the left of the cursor.  In either
# case, the cursor ends up to the right of the transposed characters.
#
# Arguments:
# w -		The entry window.

proc ::tk::EntryTranspose w {
    set i [$w index insert]
    if {$i < [$w index end]} {
	incr i
    }
    set first [expr {$i-2}]
    if {$first < 0} {
	return
    }
    set data [$w get]
    set new [string index $data [expr {$i-1}]][string index $data $first]
    $w delete $first $i
    $w insert insert $new
    EntrySeeInsert $w
}

# ::tk::EntryNextWord --
# Returns the index of the next word position after a given position in the
# entry.  The next word is platform dependent and may be either the next
# end-of-word position or the next start-of-word position after the next
# end-of-word position.
#
# Arguments:
# w -		The entry window in which the cursor is to move.
# start -	Position at which to start search.

if {[string equal $tcl_platform(platform) "windows"]}  {
    proc ::tk::EntryNextWord {w start} {
	set pos [tcl_endOfWord [$w get] [$w index $start]]
	if {$pos >= 0} {
	    set pos [tcl_startOfNextWord [$w get] $pos]
	}
	if {$pos < 0} {
	    return end
	}
	return $pos
    }
} else {
    proc ::tk::EntryNextWord {w start} {
	set pos [tcl_endOfWord [$w get] [$w index $start]]
	if {$pos < 0} {
	    return end
	}
	return $pos
    }
}

# ::tk::EntryPreviousWord --
#
# Returns the index of the previous word position before a given
# position in the entry.
#
# Arguments:
# w -		The entry window in which the cursor is to move.
# start -	Position at which to start search.

proc ::tk::EntryPreviousWord {w start} {
    set pos [tcl_startOfPreviousWord [$w get] [$w index $start]]
    if {$pos < 0} {
	return 0
    }
    return $pos
}

# ::tk::EntryScanMark --
#
# Marks the start of a possible scan drag operation
#
# Arguments:
# w -	The entry window from which the text to get
# x -	x location on screen

proc ::tk::EntryScanMark {w x} {
    $w scan mark $x
    set ::tk::Priv(x) $x
    set ::tk::Priv(y) 0 ; # not used
    set ::tk::Priv(mouseMoved) 0
}

# ::tk::EntryScanDrag --
#
# Marks the start of a possible scan drag operation
#
# Arguments:
# w -	The entry window from which the text to get
# x -	x location on screen

proc ::tk::EntryScanDrag {w x} {
    # Make sure these exist, as some weird situations can trigger the
    # motion binding without the initial press.  [Bug #220269]
    if {![info exists ::tk::Priv(x)]} { set ::tk::Priv(x) $x }
    # allow for a delta
    if {abs($x-$::tk::Priv(x)) > 2} {
	set ::tk::Priv(mouseMoved) 1
    }
    $w scan dragto $x
}

# ::tk::EntryGetSelection --
#
# Returns the selected text of the entry with respect to the -show option.
#
# Arguments:
# w -         The entry window from which the text to get

proc ::tk::EntryGetSelection {w} {
    set entryString [string range [$w get] [$w index sel.first] \
	    [expr {[$w index sel.last] - 1}]]
    if {[string compare [$w cget -show] ""]} {
	return [string repeat [string index [$w cget -show] 0] \
		[string length $entryString]]
    }
    return $entryString
}
@


1.4
log
@touched all sources to ease next import
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: entry.tcl,v 1.7.6.1 2000/05/04 21:26:25 spolk Exp $
d16 1
a16 1
# Elements of tkPriv that are used in this file:
d36 1
a36 1
    if {![catch {tkEntryGetSelection %W} tkPriv(data)]} {
d38 1
a38 1
	clipboard append -displayof %W $tkPriv(data)
d40 1
a40 1
	unset tkPriv(data)
d44 1
a44 1
    if {![catch {tkEntryGetSelection %W} tkPriv(data)]} {
d46 2
a47 2
	clipboard append -displayof %W $tkPriv(data)
	unset tkPriv(data)
d53 1
a53 1
	if {[string compare $tcl_platform(platform) "unix"]} {
d58 2
a59 2
	%W insert insert [selection get -displayof %W -selection CLIPBOARD]
	tkEntrySeeInsert %W
d66 3
a68 2
    if {!$tkPriv(mouseMoved) || $tk_strictMotif} {
	tkEntryPaste %W %x
d75 1
a75 1
    tkEntryButton1 %W %x
d79 2
a80 2
    set tkPriv(x) %x
    tkEntryMouseSelect %W %x
d83 3
a85 3
    set tkPriv(selectMode) word
    tkEntryMouseSelect %W %x
    catch {%W icursor sel.first}
d88 3
a90 3
    set tkPriv(selectMode) line
    tkEntryMouseSelect %W %x
    %W icursor 0
d93 1
a93 1
    set tkPriv(selectMode) char
d97 2
a98 2
    set tkPriv(selectMode) word
    tkEntryMouseSelect %W %x
d101 2
a102 2
    set tkPriv(selectMode) line
    tkEntryMouseSelect %W %x
d105 2
a106 2
    set tkPriv(x) %x
    tkEntryAutoScan %W
d109 1
a109 1
    tkCancelRepeat
d112 1
a112 1
    tkCancelRepeat
d119 1
a119 1
    tkEntrySetCursor %W [expr {[%W index insert] - 1}]
d122 1
a122 1
    tkEntrySetCursor %W [expr {[%W index insert] + 1}]
d125 2
a126 2
    tkEntryKeySelect %W [expr {[%W index insert] - 1}]
    tkEntrySeeInsert %W
d129 2
a130 2
    tkEntryKeySelect %W [expr {[%W index insert] + 1}]
    tkEntrySeeInsert %W
d133 1
a133 1
    tkEntrySetCursor %W [tkEntryPreviousWord %W insert]
d136 1
a136 1
    tkEntrySetCursor %W [tkEntryNextWord %W insert]
d139 2
a140 2
    tkEntryKeySelect %W [tkEntryPreviousWord %W insert]
    tkEntrySeeInsert %W
d143 2
a144 2
    tkEntryKeySelect %W [tkEntryNextWord %W insert]
    tkEntrySeeInsert %W
d147 1
a147 1
    tkEntrySetCursor %W 0
d150 2
a151 2
    tkEntryKeySelect %W 0
    tkEntrySeeInsert %W
d154 1
a154 1
    tkEntrySetCursor %W end
d157 2
a158 2
    tkEntryKeySelect %W end
    tkEntrySeeInsert %W
d169 1
a169 1
    tkEntryBackspace %W
d191 1
a191 1
    tkEntryInsert %W %A
d206 2
a207 1
if {[string equal $tcl_platform(platform) "macintosh"]} {
d215 1
a215 1
	catch {tkEntryInsert %W [selection get -displayof %W]}
d223 1
a223 1
	tkEntrySetCursor %W 0
d228 1
a228 1
	tkEntrySetCursor %W [expr {[%W index insert] - 1}]
d238 1
a238 1
	tkEntrySetCursor %W end
d243 1
a243 1
	tkEntrySetCursor %W [expr {[%W index insert] + 1}]
d248 1
a248 1
	tkEntryBackspace %W
d258 1
a258 1
	tkEntryTranspose %W
d263 1
a263 1
	tkEntrySetCursor %W [tkEntryPreviousWord %W insert]
d268 1
a268 1
	%W delete insert [tkEntryNextWord %W insert]
d273 1
a273 1
	tkEntrySetCursor %W [tkEntryNextWord %W insert]
d278 1
a278 1
	%W delete [tkEntryPreviousWord %W insert] insert
d283 1
a283 1
	%W delete [tkEntryPreviousWord %W insert] insert
d291 1
a291 4
	%W scan mark %x
	set tkPriv(x) %x
	set tkPriv(y) %y
	set tkPriv(mouseMoved) 0
d296 1
a296 4
	if {abs(%x-$tkPriv(x)) > 2} {
	    set tkPriv(mouseMoved) 1
	}
	%W scan dragto %x
d300 1
a300 1
# tkEntryClosestGap --
d309 1
a309 1
proc tkEntryClosestGap {w x} {
d318 1
a318 1
# tkEntryButton1 --
d327 2
a328 2
proc tkEntryButton1 {w x} {
    global tkPriv
d330 4
a333 4
    set tkPriv(selectMode) char
    set tkPriv(mouseMoved) 0
    set tkPriv(pressX) $x
    $w icursor [tkEntryClosestGap $w $x]
d335 1
a335 1
    if {[string equal [$w cget -state] "normal"]} {focus $w}
d338 1
a338 1
# tkEntryMouseSelect --
d349 2
a350 2
proc tkEntryMouseSelect {w x} {
    global tkPriv
d352 1
a352 1
    set cur [tkEntryClosestGap $w $x]
d354 2
a355 2
    if {($cur != $anchor) || (abs($tkPriv(pressX) - $x) >= 3)} {
	set tkPriv(mouseMoved) 1
d357 1
a357 1
    switch $tkPriv(selectMode) {
d359 1
a359 1
	    if {$tkPriv(mouseMoved)} {
d389 3
d395 1
a395 1
# tkEntryPaste --
d403 4
a406 6
proc tkEntryPaste {w x} {
    global tkPriv

    $w icursor [tkEntryClosestGap $w $x]
    catch {$w insert insert [selection get -displayof $w]}
    if {[string equal [$w cget -state] "normal"]} {focus $w}
d409 1
a409 1
# tkEntryAutoScan --
d419 3
a421 3
proc tkEntryAutoScan {w} {
    global tkPriv
    set x $tkPriv(x)
d425 1
a425 1
	tkEntryMouseSelect $w $x
d428 1
a428 1
	tkEntryMouseSelect $w $x
d430 1
a430 1
    set tkPriv(afterId) [after 50 [list tkEntryAutoScan $w]]
d433 1
a433 1
# tkEntryKeySelect --
d443 1
a443 1
proc tkEntryKeySelect {w new} {
d453 1
a453 1
# tkEntryInsert --
d462 1
a462 1
proc tkEntryInsert {w s} {
d474 1
a474 1
    tkEntrySeeInsert $w
d477 1
a477 1
# tkEntryBackspace --
d485 1
a485 1
proc tkEntryBackspace w {
d500 1
a500 1
# tkEntrySeeInsert --
d507 1
a507 1
proc tkEntrySeeInsert w {
d514 1
a514 1
# tkEntrySetCursor -
d523 1
a523 1
proc tkEntrySetCursor {w pos} {
d526 1
a526 1
    tkEntrySeeInsert $w
d529 1
a529 1
# tkEntryTranspose -
d539 1
a539 1
proc tkEntryTranspose w {
d548 2
a549 1
    set new [string index [$w get] [expr {$i-1}]][string index [$w get] $first]
d552 1
a552 1
    tkEntrySeeInsert $w
d555 1
a555 1
# tkEntryNextWord --
d566 1
a566 1
    proc tkEntryNextWord {w start} {
d577 1
a577 1
    proc tkEntryNextWord {w start} {
d586 1
a586 1
# tkEntryPreviousWord --
d595 1
a595 1
proc tkEntryPreviousWord {w start} {
d602 36
a637 1
# tkEntryGetSelection --
d644 1
a644 1
proc tkEntryGetSelection {w} {
d648 2
a649 1
	regsub -all . $entryString [string index [$w cget -show] 0] entryString
a652 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
# SCCS: @@(#) entry.tcl 1.49 97/09/17 19:08:48
d29 1
d36 1
a36 2
    if {![catch {set data [string range [%W get] [%W index sel.first]\
	    [expr {[%W index sel.last] - 1}]]}]} {
d38 1
a38 1
	clipboard append -displayof %W $data
d40 1
d44 1
a44 2
    if {![catch {set data [string range [%W get] [%W index sel.first]\
	    [expr {[%W index sel.last] - 1}]]}]} {
d46 2
a47 1
	clipboard append -displayof %W $data
d53 1
a53 1
	if {"$tcl_platform(platform)" != "unix"} {
d205 1
a205 1
if {$tcl_platform(platform) == "macintosh"} {
d211 1
a211 1
if {$tcl_platform(platform) != "windows"} {
d339 1
a339 1
    if {[lindex [$w configure -state] 4] == "normal"} {focus $w}
d409 1
a409 1
    if {[lindex [$w configure -state] 4] == "normal"} {focus $w}
d433 1
a433 1
    set tkPriv(afterId) [after 50 tkEntryAutoScan $w]
d466 1
a466 1
    if {$s == ""} {
d512 1
a512 2
    set left [$w index @@0]
    if {$left > $c} {
a513 6
	return
    }
    set x [winfo width $w]
    while {([$w index @@$x] <= $c) && ($left < $c)} {
	incr left
	$w xview $left
d567 1
a567 1
if {$tcl_platform(platform) == "windows"}  {
d603 15
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: entry.tcl,v 1.7.6.1 2000/05/04 21:26:25 spolk Exp $
a28 1
# data -		Used for Cut and Copy
d35 2
a36 1
    if {![catch {tkEntryGetSelection %W} tkPriv(data)]} {
d38 1
a38 1
	clipboard append -displayof %W $tkPriv(data)
a39 1
	unset tkPriv(data)
d43 2
a44 1
    if {![catch {tkEntryGetSelection %W} tkPriv(data)]} {
d46 1
a46 2
	clipboard append -displayof %W $tkPriv(data)
	unset tkPriv(data)
d52 1
a52 1
	if {[string compare $tcl_platform(platform) "unix"]} {
d204 1
a204 1
if {[string equal $tcl_platform(platform) "macintosh"]} {
d210 1
a210 1
if {[string compare $tcl_platform(platform) "windows"]} {
d338 1
a338 1
    if {[string equal [$w cget -state] "normal"]} {focus $w}
d408 1
a408 1
    if {[string equal [$w cget -state] "normal"]} {focus $w}
d432 1
a432 1
    set tkPriv(afterId) [after 50 [list tkEntryAutoScan $w]]
d465 1
a465 1
    if {[string equal $s ""]} {
d511 2
a512 1
    if {($c < [$w index @@0]) || ($c > [$w index @@[winfo width $w]])} {
d514 6
d573 1
a573 1
if {[string equal $tcl_platform(platform) "windows"]}  {
a608 15
}
# tkEntryGetSelection --
#
# Returns the selected text of the entry with respect to the -show option.
#
# Arguments:
# w -         The entry window from which the text to get

proc tkEntryGetSelection {w} {
    set entryString [string range [$w get] [$w index sel.first] \
	    [expr {[$w index sel.last] - 1}]]
    if {[string compare [$w cget -show] ""]} {
	regsub -all . $entryString [string index [$w cget -show] 0] entryString
    }
    return $entryString
@


1.1.1.3
log
@import tk 8.4.0
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: entry.tcl,v 1.20 2002/08/31 06:12:28 das Exp $
d16 1
a16 1
# Elements of tk::Priv that are used in this file:
d36 1
a36 1
    if {![catch {tk::EntryGetSelection %W} tk::Priv(data)]} {
d38 1
a38 1
	clipboard append -displayof %W $tk::Priv(data)
d40 1
a40 1
	unset tk::Priv(data)
d44 1
a44 1
    if {![catch {tk::EntryGetSelection %W} tk::Priv(data)]} {
d46 2
a47 2
	clipboard append -displayof %W $tk::Priv(data)
	unset tk::Priv(data)
d53 1
a53 1
	if {[string compare [tk windowingsystem] "x11"]} {
d58 2
a59 2
	%W insert insert [::tk::GetSelection %W CLIPBOARD]
	tk::EntrySeeInsert %W
d66 2
a67 3
    if {$tk_strictMotif || ![info exists tk::Priv(mouseMoved)]
	|| !$tk::Priv(mouseMoved)} {
	tk::EntryPaste %W %x
d74 1
a74 1
    tk::EntryButton1 %W %x
d78 2
a79 2
    set tk::Priv(x) %x
    tk::EntryMouseSelect %W %x
d82 3
a84 3
    set tk::Priv(selectMode) word
    tk::EntryMouseSelect %W %x
    catch {%W icursor sel.last}
d87 3
a89 3
    set tk::Priv(selectMode) line
    tk::EntryMouseSelect %W %x
    catch {%W icursor sel.last}
d92 1
a92 1
    set tk::Priv(selectMode) char
d96 2
a97 2
    set tk::Priv(selectMode) word
    tk::EntryMouseSelect %W %x
d100 2
a101 2
    set tk::Priv(selectMode) line
    tk::EntryMouseSelect %W %x
d104 2
a105 2
    set tk::Priv(x) %x
    tk::EntryAutoScan %W
d108 1
a108 1
    tk::CancelRepeat
d111 1
a111 1
    tk::CancelRepeat
d118 1
a118 1
    tk::EntrySetCursor %W [expr {[%W index insert] - 1}]
d121 1
a121 1
    tk::EntrySetCursor %W [expr {[%W index insert] + 1}]
d124 2
a125 2
    tk::EntryKeySelect %W [expr {[%W index insert] - 1}]
    tk::EntrySeeInsert %W
d128 2
a129 2
    tk::EntryKeySelect %W [expr {[%W index insert] + 1}]
    tk::EntrySeeInsert %W
d132 1
a132 1
    tk::EntrySetCursor %W [tk::EntryPreviousWord %W insert]
d135 1
a135 1
    tk::EntrySetCursor %W [tk::EntryNextWord %W insert]
d138 2
a139 2
    tk::EntryKeySelect %W [tk::EntryPreviousWord %W insert]
    tk::EntrySeeInsert %W
d142 2
a143 2
    tk::EntryKeySelect %W [tk::EntryNextWord %W insert]
    tk::EntrySeeInsert %W
d146 1
a146 1
    tk::EntrySetCursor %W 0
d149 2
a150 2
    tk::EntryKeySelect %W 0
    tk::EntrySeeInsert %W
d153 1
a153 1
    tk::EntrySetCursor %W end
d156 2
a157 2
    tk::EntryKeySelect %W end
    tk::EntrySeeInsert %W
d168 1
a168 1
    tk::EntryBackspace %W
d190 1
a190 1
    tk::EntryInsert %W %A
d205 1
a205 2
if {[string equal [tk windowingsystem] "classic"]
	|| [string equal [tk windowingsystem] "aqua"]} {
d213 1
a213 1
	catch {tk::EntryInsert %W [::tk::GetSelection %W PRIMARY]}
d221 1
a221 1
	tk::EntrySetCursor %W 0
d226 1
a226 1
	tk::EntrySetCursor %W [expr {[%W index insert] - 1}]
d236 1
a236 1
	tk::EntrySetCursor %W end
d241 1
a241 1
	tk::EntrySetCursor %W [expr {[%W index insert] + 1}]
d246 1
a246 1
	tk::EntryBackspace %W
d256 1
a256 1
	tk::EntryTranspose %W
d261 1
a261 1
	tk::EntrySetCursor %W [tk::EntryPreviousWord %W insert]
d266 1
a266 1
	%W delete insert [tk::EntryNextWord %W insert]
d271 1
a271 1
	tk::EntrySetCursor %W [tk::EntryNextWord %W insert]
d276 1
a276 1
	%W delete [tk::EntryPreviousWord %W insert] insert
d281 1
a281 1
	%W delete [tk::EntryPreviousWord %W insert] insert
d289 4
a292 1
	::tk::EntryScanMark %W %x
d297 4
a300 1
	::tk::EntryScanDrag %W %x
d304 1
a304 1
# ::tk::EntryClosestGap --
d313 1
a313 1
proc ::tk::EntryClosestGap {w x} {
d322 1
a322 1
# ::tk::EntryButton1 --
d331 2
a332 2
proc ::tk::EntryButton1 {w x} {
    variable ::tk::Priv
d334 4
a337 4
    set Priv(selectMode) char
    set Priv(mouseMoved) 0
    set Priv(pressX) $x
    $w icursor [EntryClosestGap $w $x]
d339 1
a339 1
    if {[string compare "disabled" [$w cget -state]]} {focus $w}
d342 1
a342 1
# ::tk::EntryMouseSelect --
d353 2
a354 2
proc ::tk::EntryMouseSelect {w x} {
    variable ::tk::Priv
d356 1
a356 1
    set cur [EntryClosestGap $w $x]
d358 2
a359 2
    if {($cur != $anchor) || (abs($Priv(pressX) - $x) >= 3)} {
	set Priv(mouseMoved) 1
d361 1
a361 1
    switch $Priv(selectMode) {
d363 1
a363 1
	    if {$Priv(mouseMoved)} {
a392 3
    if {$Priv(mouseMoved)} {
        $w icursor $cur
    }
d396 1
a396 1
# ::tk::EntryPaste --
d404 6
a409 4
proc ::tk::EntryPaste {w x} {
    $w icursor [EntryClosestGap $w $x]
    catch {$w insert insert [::tk::GetSelection $w PRIMARY]}
    if {[string compare "disabled" [$w cget -state]]} {focus $w}
d412 1
a412 1
# ::tk::EntryAutoScan --
d422 3
a424 3
proc ::tk::EntryAutoScan {w} {
    variable ::tk::Priv
    set x $Priv(x)
d428 1
a428 1
	EntryMouseSelect $w $x
d431 1
a431 1
	EntryMouseSelect $w $x
d433 1
a433 1
    set Priv(afterId) [after 50 [list tk::EntryAutoScan $w]]
d436 1
a436 1
# ::tk::EntryKeySelect --
d446 1
a446 1
proc ::tk::EntryKeySelect {w new} {
d456 1
a456 1
# ::tk::EntryInsert --
d465 1
a465 1
proc ::tk::EntryInsert {w s} {
d477 1
a477 1
    EntrySeeInsert $w
d480 1
a480 1
# ::tk::EntryBackspace --
d488 1
a488 1
proc ::tk::EntryBackspace w {
d503 1
a503 1
# ::tk::EntrySeeInsert --
d510 1
a510 1
proc ::tk::EntrySeeInsert w {
d517 1
a517 1
# ::tk::EntrySetCursor -
d526 1
a526 1
proc ::tk::EntrySetCursor {w pos} {
d529 1
a529 1
    EntrySeeInsert $w
d532 1
a532 1
# ::tk::EntryTranspose -
d542 1
a542 1
proc ::tk::EntryTranspose w {
d551 1
a551 2
    set data [$w get]
    set new [string index $data [expr {$i-1}]][string index $data $first]
d554 1
a554 1
    EntrySeeInsert $w
d557 1
a557 1
# ::tk::EntryNextWord --
d568 1
a568 1
    proc ::tk::EntryNextWord {w start} {
d579 1
a579 1
    proc ::tk::EntryNextWord {w start} {
d588 1
a588 1
# ::tk::EntryPreviousWord --
d597 1
a597 1
proc ::tk::EntryPreviousWord {w start} {
d604 1
a604 36

# ::tk::EntryScanMark --
#
# Marks the start of a possible scan drag operation
#
# Arguments:
# w -	The entry window from which the text to get
# x -	x location on screen

proc ::tk::EntryScanMark {w x} {
    $w scan mark $x
    set ::tk::Priv(x) $x
    set ::tk::Priv(y) 0 ; # not used
    set ::tk::Priv(mouseMoved) 0
}

# ::tk::EntryScanDrag --
#
# Marks the start of a possible scan drag operation
#
# Arguments:
# w -	The entry window from which the text to get
# x -	x location on screen

proc ::tk::EntryScanDrag {w x} {
    # Make sure these exist, as some weird situations can trigger the
    # motion binding without the initial press.  [Bug #220269]
    if {![info exists ::tk::Priv(x)]} { set ::tk::Priv(x) $x }
    # allow for a delta
    if {abs($x-$::tk::Priv(x)) > 2} {
	set ::tk::Priv(mouseMoved) 1
    }
    $w scan dragto $x
}

# ::tk::EntryGetSelection --
d611 1
a611 1
proc ::tk::EntryGetSelection {w} {
d615 1
a615 2
	return [string repeat [string index [$w cget -show] 0] \
		[string length $entryString]]
d619 1
@


