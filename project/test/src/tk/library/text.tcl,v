head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.46;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.14;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.26;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.52;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.33;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.51;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# text.tcl --
#
# This file defines the default bindings for Tk text widgets and provides
# procedures that help in implementing the bindings.
#
# RCS: @@(#) $Id: text.tcl,v 1.24 2002/08/31 06:12:28 das Exp $
#
# Copyright (c) 1992-1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

#-------------------------------------------------------------------------
# Elements of ::tk::Priv that are used in this file:
#
# afterId -		If non-null, it means that auto-scanning is underway
#			and it gives the "after" id for the next auto-scan
#			command to be executed.
# char -		Character position on the line;  kept in order
#			to allow moving up or down past short lines while
#			still remembering the desired position.
# mouseMoved -		Non-zero means the mouse has moved a significant
#			amount since the button went down (so, for example,
#			start dragging out a selection).
# prevPos -		Used when moving up or down lines via the keyboard.
#			Keeps track of the previous insert position, so
#			we can distinguish a series of ups and downs, all
#			in a row, from a new up or down.
# selectMode -		The style of selection currently underway:
#			char, word, or line.
# x, y -		Last known mouse coordinates for scanning
#			and auto-scanning.
#-------------------------------------------------------------------------

#-------------------------------------------------------------------------
# The code below creates the default class bindings for text widgets.
#-------------------------------------------------------------------------

# Standard Motif bindings:

bind Text <1> {
    tk::TextButton1 %W %x %y
    %W tag remove sel 0.0 end
}
bind Text <B1-Motion> {
    set tk::Priv(x) %x
    set tk::Priv(y) %y
    tk::TextSelectTo %W %x %y
}
bind Text <Double-1> {
    set tk::Priv(selectMode) word
    tk::TextSelectTo %W %x %y
    catch {%W mark set insert sel.last}
}
bind Text <Triple-1> {
    set tk::Priv(selectMode) line
    tk::TextSelectTo %W %x %y
    catch {%W mark set insert sel.last}
}
bind Text <Shift-1> {
    tk::TextResetAnchor %W @@%x,%y
    set tk::Priv(selectMode) char
    tk::TextSelectTo %W %x %y
}
bind Text <Double-Shift-1>	{
    set tk::Priv(selectMode) word
    tk::TextSelectTo %W %x %y 1
}
bind Text <Triple-Shift-1>	{
    set tk::Priv(selectMode) line
    tk::TextSelectTo %W %x %y
}
bind Text <B1-Leave> {
    set tk::Priv(x) %x
    set tk::Priv(y) %y
    tk::TextAutoScan %W
}
bind Text <B1-Enter> {
    tk::CancelRepeat
}
bind Text <ButtonRelease-1> {
    tk::CancelRepeat
}
bind Text <Control-1> {
    %W mark set insert @@%x,%y
}
bind Text <Left> {
    tk::TextSetCursor %W insert-1c
}
bind Text <Right> {
    tk::TextSetCursor %W insert+1c
}
bind Text <Up> {
    tk::TextSetCursor %W [tk::TextUpDownLine %W -1]
}
bind Text <Down> {
    tk::TextSetCursor %W [tk::TextUpDownLine %W 1]
}
bind Text <Shift-Left> {
    tk::TextKeySelect %W [%W index {insert - 1c}]
}
bind Text <Shift-Right> {
    tk::TextKeySelect %W [%W index {insert + 1c}]
}
bind Text <Shift-Up> {
    tk::TextKeySelect %W [tk::TextUpDownLine %W -1]
}
bind Text <Shift-Down> {
    tk::TextKeySelect %W [tk::TextUpDownLine %W 1]
}
bind Text <Control-Left> {
    tk::TextSetCursor %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
}
bind Text <Control-Right> {
    tk::TextSetCursor %W [tk::TextNextWord %W insert]
}
bind Text <Control-Up> {
    tk::TextSetCursor %W [tk::TextPrevPara %W insert]
}
bind Text <Control-Down> {
    tk::TextSetCursor %W [tk::TextNextPara %W insert]
}
bind Text <Shift-Control-Left> {
    tk::TextKeySelect %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
}
bind Text <Shift-Control-Right> {
    tk::TextKeySelect %W [tk::TextNextWord %W insert]
}
bind Text <Shift-Control-Up> {
    tk::TextKeySelect %W [tk::TextPrevPara %W insert]
}
bind Text <Shift-Control-Down> {
    tk::TextKeySelect %W [tk::TextNextPara %W insert]
}
bind Text <Prior> {
    tk::TextSetCursor %W [tk::TextScrollPages %W -1]
}
bind Text <Shift-Prior> {
    tk::TextKeySelect %W [tk::TextScrollPages %W -1]
}
bind Text <Next> {
    tk::TextSetCursor %W [tk::TextScrollPages %W 1]
}
bind Text <Shift-Next> {
    tk::TextKeySelect %W [tk::TextScrollPages %W 1]
}
bind Text <Control-Prior> {
    %W xview scroll -1 page
}
bind Text <Control-Next> {
    %W xview scroll 1 page
}

bind Text <Home> {
    tk::TextSetCursor %W {insert linestart}
}
bind Text <Shift-Home> {
    tk::TextKeySelect %W {insert linestart}
}
bind Text <End> {
    tk::TextSetCursor %W {insert lineend}
}
bind Text <Shift-End> {
    tk::TextKeySelect %W {insert lineend}
}
bind Text <Control-Home> {
    tk::TextSetCursor %W 1.0
}
bind Text <Control-Shift-Home> {
    tk::TextKeySelect %W 1.0
}
bind Text <Control-End> {
    tk::TextSetCursor %W {end - 1 char}
}
bind Text <Control-Shift-End> {
    tk::TextKeySelect %W {end - 1 char}
}

bind Text <Tab> {
    if { [string equal [%W cget -state] "normal"] } {
	tk::TextInsert %W \t
	focus %W
	break
    }
}
bind Text <Shift-Tab> {
    # Needed only to keep <Tab> binding from triggering;  doesn't
    # have to actually do anything.
    break
}
bind Text <Control-Tab> {
    focus [tk_focusNext %W]
}
bind Text <Control-Shift-Tab> {
    focus [tk_focusPrev %W]
}
bind Text <Control-i> {
    tk::TextInsert %W \t
}
bind Text <Return> {
    tk::TextInsert %W \n
    if {[%W cget -autoseparators]} {%W edit separator}
}
bind Text <Delete> {
    if {[string compare [%W tag nextrange sel 1.0 end] ""]} {
	%W delete sel.first sel.last
    } else {
	%W delete insert
	%W see insert
    }
}
bind Text <BackSpace> {
    if {[string compare [%W tag nextrange sel 1.0 end] ""]} {
	%W delete sel.first sel.last
    } elseif {[%W compare insert != 1.0]} {
	%W delete insert-1c
	%W see insert
    }
}

bind Text <Control-space> {
    %W mark set anchor insert
}
bind Text <Select> {
    %W mark set anchor insert
}
bind Text <Control-Shift-space> {
    set tk::Priv(selectMode) char
    tk::TextKeyExtend %W insert
}
bind Text <Shift-Select> {
    set tk::Priv(selectMode) char
    tk::TextKeyExtend %W insert
}
bind Text <Control-slash> {
    %W tag add sel 1.0 end
}
bind Text <Control-backslash> {
    %W tag remove sel 1.0 end
}
bind Text <<Cut>> {
    tk_textCut %W
}
bind Text <<Copy>> {
    tk_textCopy %W
}
bind Text <<Paste>> {
    tk_textPaste %W
}
bind Text <<Clear>> {
    catch {%W delete sel.first sel.last}
}
bind Text <<PasteSelection>> {
    if {$tk_strictMotif || ![info exists tk::Priv(mouseMoved)]
	|| !$tk::Priv(mouseMoved)} {
	tk::TextPasteSelection %W %x %y
    }
}
bind Text <Insert> {
    catch {tk::TextInsert %W [::tk::GetSelection %W PRIMARY]}
}
bind Text <KeyPress> {
    tk::TextInsert %W %A
}

# Ignore all Alt, Meta, and Control keypresses unless explicitly bound.
# Otherwise, if a widget binding for one of these is defined, the
# <KeyPress> class binding will also fire and insert the character,
# which is wrong.  Ditto for <Escape>.

bind Text <Alt-KeyPress> {# nothing }
bind Text <Meta-KeyPress> {# nothing}
bind Text <Control-KeyPress> {# nothing}
bind Text <Escape> {# nothing}
bind Text <KP_Enter> {# nothing}
if {[string equal [tk windowingsystem] "classic"]
	|| [string equal [tk windowingsystem] "aqua"]} {
    bind Text <Command-KeyPress> {# nothing}
}

# Additional emacs-like bindings:

bind Text <Control-a> {
    if {!$tk_strictMotif} {
	tk::TextSetCursor %W {insert linestart}
    }
}
bind Text <Control-b> {
    if {!$tk_strictMotif} {
	tk::TextSetCursor %W insert-1c
    }
}
bind Text <Control-d> {
    if {!$tk_strictMotif} {
	%W delete insert
    }
}
bind Text <Control-e> {
    if {!$tk_strictMotif} {
	tk::TextSetCursor %W {insert lineend}
    }
}
bind Text <Control-f> {
    if {!$tk_strictMotif} {
	tk::TextSetCursor %W insert+1c
    }
}
bind Text <Control-k> {
    if {!$tk_strictMotif} {
	if {[%W compare insert == {insert lineend}]} {
	    %W delete insert
	} else {
	    %W delete insert {insert lineend}
	}
    }
}
bind Text <Control-n> {
    if {!$tk_strictMotif} {
	tk::TextSetCursor %W [tk::TextUpDownLine %W 1]
    }
}
bind Text <Control-o> {
    if {!$tk_strictMotif} {
	%W insert insert \n
	%W mark set insert insert-1c
    }
}
bind Text <Control-p> {
    if {!$tk_strictMotif} {
	tk::TextSetCursor %W [tk::TextUpDownLine %W -1]
    }
}
bind Text <Control-t> {
    if {!$tk_strictMotif} {
	tk::TextTranspose %W
    }
}

bind Text <<Undo>> {
    catch { %W edit undo }
}

bind Text <<Redo>> {
    catch { %W edit redo }
}

if {[string compare $tcl_platform(platform) "windows"]} {
bind Text <Control-v> {
    if {!$tk_strictMotif} {
	tk::TextScrollPages %W 1
    }
}
}

bind Text <Meta-b> {
    if {!$tk_strictMotif} {
	tk::TextSetCursor %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
    }
}
bind Text <Meta-d> {
    if {!$tk_strictMotif} {
	%W delete insert [tk::TextNextWord %W insert]
    }
}
bind Text <Meta-f> {
    if {!$tk_strictMotif} {
	tk::TextSetCursor %W [tk::TextNextWord %W insert]
    }
}
bind Text <Meta-less> {
    if {!$tk_strictMotif} {
	tk::TextSetCursor %W 1.0
    }
}
bind Text <Meta-greater> {
    if {!$tk_strictMotif} {
	tk::TextSetCursor %W end-1c
    }
}
bind Text <Meta-BackSpace> {
    if {!$tk_strictMotif} {
	%W delete [tk::TextPrevPos %W insert tcl_startOfPreviousWord] insert
    }
}
bind Text <Meta-Delete> {
    if {!$tk_strictMotif} {
	%W delete [tk::TextPrevPos %W insert tcl_startOfPreviousWord] insert
    }
}

# Macintosh only bindings:

# if text black & highlight black -> text white, other text the same
if {[string equal [tk windowingsystem] "classic"]
	|| [string equal [tk windowingsystem] "aqua"]} {
bind Text <FocusIn> {
    %W tag configure sel -borderwidth 0
    %W configure -selectbackground systemHighlight -selectforeground systemHighlightText
}
bind Text <FocusOut> {
    %W tag configure sel -borderwidth 1
    %W configure -selectbackground white -selectforeground black
}
bind Text <Option-Left> {
    tk::TextSetCursor %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
}
bind Text <Option-Right> {
    tk::TextSetCursor %W [tk::TextNextWord %W insert]
}
bind Text <Option-Up> {
    tk::TextSetCursor %W [tk::TextPrevPara %W insert]
}
bind Text <Option-Down> {
    tk::TextSetCursor %W [tk::TextNextPara %W insert]
}
bind Text <Shift-Option-Left> {
    tk::TextKeySelect %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
}
bind Text <Shift-Option-Right> {
    tk::TextKeySelect %W [tk::TextNextWord %W insert]
}
bind Text <Shift-Option-Up> {
    tk::TextKeySelect %W [tk::TextPrevPara %W insert]
}
bind Text <Shift-Option-Down> {
    tk::TextKeySelect %W [tk::TextNextPara %W insert]
}

# End of Mac only bindings
}

# A few additional bindings of my own.

bind Text <Control-h> {
    if {!$tk_strictMotif} {
	if {[%W compare insert != 1.0]} {
	    %W delete insert-1c
	    %W see insert
	}
    }
}
bind Text <2> {
    if {!$tk_strictMotif} {
	tk::TextScanMark %W %x %y
    }
}
bind Text <B2-Motion> {
    if {!$tk_strictMotif} {
	tk::TextScanDrag %W %x %y
    }
}
set ::tk::Priv(prevPos) {}

# The MouseWheel will typically only fire on Windows.  However,
# someone could use the "event generate" command to produce one
# on other platforms.

bind Text <MouseWheel> {
    %W yview scroll [expr {- (%D / 120) * 4}] units
}

if {[string equal "x11" [tk windowingsystem]]} {
    # Support for mousewheels on Linux/Unix commonly comes through mapping
    # the wheel to the extended buttons.  If you have a mousewheel, find
    # Linux configuration info at:
    #	http://www.inria.fr/koala/colas/mouse-wheel-scroll/
    bind Text <4> {
	if {!$tk_strictMotif} {
	    %W yview scroll -5 units
	}
    }
    bind Text <5> {
	if {!$tk_strictMotif} {
	    %W yview scroll 5 units
	}
    }
}

# ::tk::TextClosestGap --
# Given x and y coordinates, this procedure finds the closest boundary
# between characters to the given coordinates and returns the index
# of the character just after the boundary.
#
# Arguments:
# w -		The text window.
# x -		X-coordinate within the window.
# y -		Y-coordinate within the window.

proc ::tk::TextClosestGap {w x y} {
    set pos [$w index @@$x,$y]
    set bbox [$w bbox $pos]
    if {[string equal $bbox ""]} {
	return $pos
    }
    if {($x - [lindex $bbox 0]) < ([lindex $bbox 2]/2)} {
	return $pos
    }
    $w index "$pos + 1 char"
}

# ::tk::TextButton1 --
# This procedure is invoked to handle button-1 presses in text
# widgets.  It moves the insertion cursor, sets the selection anchor,
# and claims the input focus.
#
# Arguments:
# w -		The text window in which the button was pressed.
# x -		The x-coordinate of the button press.
# y -		The x-coordinate of the button press.

proc ::tk::TextButton1 {w x y} {
    variable ::tk::Priv

    set Priv(selectMode) char
    set Priv(mouseMoved) 0
    set Priv(pressX) $x
    $w mark set insert [TextClosestGap $w $x $y]
    $w mark set anchor insert
    # Allow focus in any case on Windows, because that will let the
    # selection be displayed even for state disabled text widgets.
    if {[string equal $::tcl_platform(platform) "windows"] \
	    || [string equal [$w cget -state] "normal"]} {focus $w}
    if {[$w cget -autoseparators]} {$w edit separator}
}

# ::tk::TextSelectTo --
# This procedure is invoked to extend the selection, typically when
# dragging it with the mouse.  Depending on the selection mode (character,
# word, line) it selects in different-sized units.  This procedure
# ignores mouse motions initially until the mouse has moved from
# one character to another or until there have been multiple clicks.
#
# Arguments:
# w -		The text window in which the button was pressed.
# x -		Mouse x position.
# y - 		Mouse y position.

proc ::tk::TextSelectTo {w x y {extend 0}} {
    global tcl_platform
    variable ::tk::Priv

    set cur [TextClosestGap $w $x $y]
    if {[catch {$w index anchor}]} {
	$w mark set anchor $cur
    }
    set anchor [$w index anchor]
    if {[$w compare $cur != $anchor] || (abs($Priv(pressX) - $x) >= 3)} {
	set Priv(mouseMoved) 1
    }
    switch $Priv(selectMode) {
	char {
	    if {[$w compare $cur < anchor]} {
		set first $cur
		set last anchor
	    } else {
		set first anchor
		set last $cur
	    }
	}
	word {
	    if {[$w compare $cur < anchor]} {
		set first [TextPrevPos $w "$cur + 1c" tcl_wordBreakBefore]
		if { !$extend } {
		    set last [TextNextPos $w "anchor" tcl_wordBreakAfter]
		} else {
		    set last anchor
		}
	    } else {
		set last [TextNextPos $w "$cur - 1c" tcl_wordBreakAfter]
		if { !$extend } {
		    set first [TextPrevPos $w anchor tcl_wordBreakBefore]
		} else {
		    set first anchor
		}
	    }
	}
	line {
	    if {[$w compare $cur < anchor]} {
		set first [$w index "$cur linestart"]
		set last [$w index "anchor - 1c lineend + 1c"]
	    } else {
		set first [$w index "anchor linestart"]
		set last [$w index "$cur lineend + 1c"]
	    }
	}
    }
    if {$Priv(mouseMoved) || [string compare $Priv(selectMode) "char"]} {
	$w tag remove sel 0.0 end
	$w mark set insert $cur
	$w tag add sel $first $last
	$w tag remove sel $last end
	update idletasks
    }
}

# ::tk::TextKeyExtend --
# This procedure handles extending the selection from the keyboard,
# where the point to extend to is really the boundary between two
# characters rather than a particular character.
#
# Arguments:
# w -		The text window.
# index -	The point to which the selection is to be extended.

proc ::tk::TextKeyExtend {w index} {

    set cur [$w index $index]
    if {[catch {$w index anchor}]} {
	$w mark set anchor $cur
    }
    set anchor [$w index anchor]
    if {[$w compare $cur < anchor]} {
	set first $cur
	set last anchor
    } else {
	set first anchor
	set last $cur
    }
    $w tag remove sel 0.0 $first
    $w tag add sel $first $last
    $w tag remove sel $last end
}

# ::tk::TextPasteSelection --
# This procedure sets the insertion cursor to the mouse position,
# inserts the selection, and sets the focus to the window.
#
# Arguments:
# w -		The text window.
# x, y - 	Position of the mouse.

proc ::tk::TextPasteSelection {w x y} {
    $w mark set insert [TextClosestGap $w $x $y]
    if {![catch {::tk::GetSelection $w PRIMARY} sel]} {
	set oldSeparator [$w cget -autoseparators]
	if {$oldSeparator} {
	    $w configure -autoseparators 0
	    $w edit separator
	}
	$w insert insert $sel
	if {$oldSeparator} {
	    $w edit separator
	    $w configure -autoseparators 1
	}
    }
    if {[string equal [$w cget -state] "normal"]} {focus $w}
}

# ::tk::TextAutoScan --
# This procedure is invoked when the mouse leaves a text window
# with button 1 down.  It scrolls the window up, down, left, or right,
# depending on where the mouse is (this information was saved in
# ::tk::Priv(x) and ::tk::Priv(y)), and reschedules itself as an "after"
# command so that the window continues to scroll until the mouse
# moves back into the window or the mouse button is released.
#
# Arguments:
# w -		The text window.

proc ::tk::TextAutoScan {w} {
    variable ::tk::Priv
    if {![winfo exists $w]} return
    if {$Priv(y) >= [winfo height $w]} {
	$w yview scroll 2 units
    } elseif {$Priv(y) < 0} {
	$w yview scroll -2 units
    } elseif {$Priv(x) >= [winfo width $w]} {
	$w xview scroll 2 units
    } elseif {$Priv(x) < 0} {
	$w xview scroll -2 units
    } else {
	return
    }
    TextSelectTo $w $Priv(x) $Priv(y)
    set Priv(afterId) [after 50 [list tk::TextAutoScan $w]]
}

# ::tk::TextSetCursor
# Move the insertion cursor to a given position in a text.  Also
# clears the selection, if there is one in the text, and makes sure
# that the insertion cursor is visible.  Also, don't let the insertion
# cursor appear on the dummy last line of the text.
#
# Arguments:
# w -		The text window.
# pos -		The desired new position for the cursor in the window.

proc ::tk::TextSetCursor {w pos} {

    if {[$w compare $pos == end]} {
	set pos {end - 1 chars}
    }
    $w mark set insert $pos
    $w tag remove sel 1.0 end
    $w see insert
    if {[$w cget -autoseparators]} {$w edit separator}
}

# ::tk::TextKeySelect
# This procedure is invoked when stroking out selections using the
# keyboard.  It moves the cursor to a new position, then extends
# the selection to that position.
#
# Arguments:
# w -		The text window.
# new -		A new position for the insertion cursor (the cursor hasn't
#		actually been moved to this position yet).

proc ::tk::TextKeySelect {w new} {

    if {[string equal [$w tag nextrange sel 1.0 end] ""]} {
	if {[$w compare $new < insert]} {
	    $w tag add sel $new insert
	} else {
	    $w tag add sel insert $new
	}
	$w mark set anchor insert
    } else {
	if {[$w compare $new < anchor]} {
	    set first $new
	    set last anchor
	} else {
	    set first anchor
	    set last $new
	}
	$w tag remove sel 1.0 $first
	$w tag add sel $first $last
	$w tag remove sel $last end
    }
    $w mark set insert $new
    $w see insert
    update idletasks
}

# ::tk::TextResetAnchor --
# Set the selection anchor to whichever end is farthest from the
# index argument.  One special trick: if the selection has two or
# fewer characters, just leave the anchor where it is.  In this
# case it doesn't matter which point gets chosen for the anchor,
# and for the things like Shift-Left and Shift-Right this produces
# better behavior when the cursor moves back and forth across the
# anchor.
#
# Arguments:
# w -		The text widget.
# index -	Position at which mouse button was pressed, which determines
#		which end of selection should be used as anchor point.

proc ::tk::TextResetAnchor {w index} {

    if {[string equal [$w tag ranges sel] ""]} {
	# Don't move the anchor if there is no selection now; this makes
	# the widget behave "correctly" when the user clicks once, then
	# shift-clicks somewhere -- ie, the area between the two clicks will be
	# selected. [Bug: 5929].
	return
    }
    set a [$w index $index]
    set b [$w index sel.first]
    set c [$w index sel.last]
    if {[$w compare $a < $b]} {
	$w mark set anchor sel.last
	return
    }
    if {[$w compare $a > $c]} {
	$w mark set anchor sel.first
	return
    }
    scan $a "%d.%d" lineA chA
    scan $b "%d.%d" lineB chB
    scan $c "%d.%d" lineC chC
    if {$lineB < $lineC+2} {
	set total [string length [$w get $b $c]]
	if {$total <= 2} {
	    return
	}
	if {[string length [$w get $b $a]] < ($total/2)} {
	    $w mark set anchor sel.last
	} else {
	    $w mark set anchor sel.first
	}
	return
    }
    if {($lineA-$lineB) < ($lineC-$lineA)} {
	$w mark set anchor sel.last
    } else {
	$w mark set anchor sel.first
    }
}

# ::tk::TextInsert --
# Insert a string into a text at the point of the insertion cursor.
# If there is a selection in the text, and it covers the point of the
# insertion cursor, then delete the selection before inserting.
#
# Arguments:
# w -		The text window in which to insert the string
# s -		The string to insert (usually just a single character)

proc ::tk::TextInsert {w s} {
    if {[string equal $s ""] || [string equal [$w cget -state] "disabled"]} {
	return
    }
    set compound 0
    catch {
	if {[$w compare sel.first <= insert] \
		&& [$w compare sel.last >= insert]} {
            set oldSeparator [$w cget -autoseparators]
            if { $oldSeparator } {
                $w configure -autoseparators 0
                $w edit separator
                set compound 1
            }
	    $w delete sel.first sel.last
	}
    }
    $w insert insert $s
    $w see insert
    if { $compound && $oldSeparator } {
        $w edit separator
        $w configure -autoseparators 1
    }
}

# ::tk::TextUpDownLine --
# Returns the index of the character one line above or below the
# insertion cursor.  There are two tricky things here.  First,
# we want to maintain the original column across repeated operations,
# even though some lines that will get passed through don't have
# enough characters to cover the original column.  Second, don't
# try to scroll past the beginning or end of the text.
#
# Arguments:
# w -		The text window in which the cursor is to move.
# n -		The number of lines to move: -1 for up one line,
#		+1 for down one line.

proc ::tk::TextUpDownLine {w n} {
    variable ::tk::Priv

    set i [$w index insert]
    scan $i "%d.%d" line char
    if {[string compare $Priv(prevPos) $i]} {
	set Priv(char) $char
    }
    set new [$w index [expr {$line + $n}].$Priv(char)]
    if {[$w compare $new == end] || [$w compare $new == "insert linestart"]} {
	set new $i
    }
    set Priv(prevPos) $new
    return $new
}

# ::tk::TextPrevPara --
# Returns the index of the beginning of the paragraph just before a given
# position in the text (the beginning of a paragraph is the first non-blank
# character after a blank line).
#
# Arguments:
# w -		The text window in which the cursor is to move.
# pos -		Position at which to start search.

proc ::tk::TextPrevPara {w pos} {
    set pos [$w index "$pos linestart"]
    while {1} {
	if {([string equal [$w get "$pos - 1 line"] "\n"] \
		&& [string compare [$w get $pos] "\n"]) \
		|| [string equal $pos "1.0"]} {
	    if {[regexp -indices {^[ 	]+(.)} [$w get $pos "$pos lineend"] \
		    dummy index]} {
		set pos [$w index "$pos + [lindex $index 0] chars"]
	    }
	    if {[$w compare $pos != insert] || [string equal $pos 1.0]} {
		return $pos
	    }
	}
	set pos [$w index "$pos - 1 line"]
    }
}

# ::tk::TextNextPara --
# Returns the index of the beginning of the paragraph just after a given
# position in the text (the beginning of a paragraph is the first non-blank
# character after a blank line).
#
# Arguments:
# w -		The text window in which the cursor is to move.
# start -	Position at which to start search.

proc ::tk::TextNextPara {w start} {
    set pos [$w index "$start linestart + 1 line"]
    while {[string compare [$w get $pos] "\n"]} {
	if {[$w compare $pos == end]} {
	    return [$w index "end - 1c"]
	}
	set pos [$w index "$pos + 1 line"]
    }
    while {[string equal [$w get $pos] "\n"]} {
	set pos [$w index "$pos + 1 line"]
	if {[$w compare $pos == end]} {
	    return [$w index "end - 1c"]
	}
    }
    if {[regexp -indices {^[ 	]+(.)} [$w get $pos "$pos lineend"] \
	    dummy index]} {
	return [$w index "$pos + [lindex $index 0] chars"]
    }
    return $pos
}

# ::tk::TextScrollPages --
# This is a utility procedure used in bindings for moving up and down
# pages and possibly extending the selection along the way.  It scrolls
# the view in the widget by the number of pages, and it returns the
# index of the character that is at the same position in the new view
# as the insertion cursor used to be in the old view.
#
# Arguments:
# w -		The text window in which the cursor is to move.
# count -	Number of pages forward to scroll;  may be negative
#		to scroll backwards.

proc ::tk::TextScrollPages {w count} {
    set bbox [$w bbox insert]
    $w yview scroll $count pages
    if {[string equal $bbox ""]} {
	return [$w index @@[expr {[winfo height $w]/2}],0]
    }
    return [$w index @@[lindex $bbox 0],[lindex $bbox 1]]
}

# ::tk::TextTranspose --
# This procedure implements the "transpose" function for text widgets.
# It tranposes the characters on either side of the insertion cursor,
# unless the cursor is at the end of the line.  In this case it
# transposes the two characters to the left of the cursor.  In either
# case, the cursor ends up to the right of the transposed characters.
#
# Arguments:
# w -		Text window in which to transpose.

proc ::tk::TextTranspose w {
    set pos insert
    if {[$w compare $pos != "$pos lineend"]} {
	set pos [$w index "$pos + 1 char"]
    }
    set new [$w get "$pos - 1 char"][$w get  "$pos - 2 char"]
    if {[$w compare "$pos - 1 char" == 1.0]} {
	return
    }
    $w delete "$pos - 2 char" $pos
    $w insert insert $new
    $w see insert
}

# ::tk_textCopy --
# This procedure copies the selection from a text widget into the
# clipboard.
#
# Arguments:
# w -		Name of a text widget.

proc ::tk_textCopy w {
    if {![catch {set data [$w get sel.first sel.last]}]} {
	clipboard clear -displayof $w
	clipboard append -displayof $w $data
    }
}

# ::tk_textCut --
# This procedure copies the selection from a text widget into the
# clipboard, then deletes the selection (if it exists in the given
# widget).
#
# Arguments:
# w -		Name of a text widget.

proc ::tk_textCut w {
    if {![catch {set data [$w get sel.first sel.last]}]} {
	clipboard clear -displayof $w
	clipboard append -displayof $w $data
	$w delete sel.first sel.last
    }
}

# ::tk_textPaste --
# This procedure pastes the contents of the clipboard to the insertion
# point in a text widget.
#
# Arguments:
# w -		Name of a text widget.

proc ::tk_textPaste w {
    global tcl_platform
    if {![catch {::tk::GetSelection $w CLIPBOARD} sel]} {
	set oldSeparator [$w cget -autoseparators]
	if { $oldSeparator } {
	    $w configure -autoseparators 0
	    $w edit separator
	}
	if {[string compare [tk windowingsystem] "x11"]} {
	    catch { $w delete sel.first sel.last }
	}
	$w insert insert $sel
	if { $oldSeparator } {
	    $w edit separator
	    $w configure -autoseparators 1
	}
    }
}

# ::tk::TextNextWord --
# Returns the index of the next word position after a given position in the
# text.  The next word is platform dependent and may be either the next
# end-of-word position or the next start-of-word position after the next
# end-of-word position.
#
# Arguments:
# w -		The text window in which the cursor is to move.
# start -	Position at which to start search.

if {[string equal $tcl_platform(platform) "windows"]}  {
    proc ::tk::TextNextWord {w start} {
	TextNextPos $w [TextNextPos $w $start tcl_endOfWord] \
	    tcl_startOfNextWord
    }
} else {
    proc ::tk::TextNextWord {w start} {
	TextNextPos $w $start tcl_endOfWord
    }
}

# ::tk::TextNextPos --
# Returns the index of the next position after the given starting
# position in the text as computed by a specified function.
#
# Arguments:
# w -		The text window in which the cursor is to move.
# start -	Position at which to start search.
# op -		Function to use to find next position.

proc ::tk::TextNextPos {w start op} {
    set text ""
    set cur $start
    while {[$w compare $cur < end]} {
	set text $text[$w get $cur "$cur lineend + 1c"]
	set pos [$op $text 0]
	if {$pos >= 0} {
	    ## Adjust for embedded windows and images
	    ## dump gives us 3 items per window/image
	    set dump [$w dump -image -window $start "$start + $pos c"]
	    if {[llength $dump]} {
		set pos [expr {$pos + ([llength $dump]/3)}]
	    }
	    return [$w index "$start + $pos c"]
	}
	set cur [$w index "$cur lineend +1c"]
    }
    return end
}

# ::tk::TextPrevPos --
# Returns the index of the previous position before the given starting
# position in the text as computed by a specified function.
#
# Arguments:
# w -		The text window in which the cursor is to move.
# start -	Position at which to start search.
# op -		Function to use to find next position.

proc ::tk::TextPrevPos {w start op} {
    set text ""
    set cur $start
    while {[$w compare $cur > 0.0]} {
	set text [$w get "$cur linestart - 1c" $cur]$text
	set pos [$op $text end]
	if {$pos >= 0} {
	    ## Adjust for embedded windows and images
	    ## dump gives us 3 items per window/image
	    set dump [$w dump -image -window "$cur linestart" "$start - 1c"]
	    if {[llength $dump]} {
		## This is a hokey extra hack for control-arrow movement
		## that should be in a while loop to be correct (hobbs)
		if {[$w compare [lindex $dump 2] > \
			"$cur linestart - 1c + $pos c"]} {
		    incr pos -1
		}
		set pos [expr {$pos + ([llength $dump]/3)}]
	    }
	    return [$w index "$cur linestart - 1c + $pos c"]
	}
	set cur [$w index "$cur linestart - 1c"]
    }
    return 0.0
}

# ::tk::TextScanMark --
#
# Marks the start of a possible scan drag operation
#
# Arguments:
# w -	The text window from which the text to get
# x -	x location on screen
# y -	y location on screen

proc ::tk::TextScanMark {w x y} {
    $w scan mark $x $y
    set ::tk::Priv(x) $x
    set ::tk::Priv(y) $y
    set ::tk::Priv(mouseMoved) 0
}

# ::tk::TextScanDrag --
#
# Marks the start of a possible scan drag operation
#
# Arguments:
# w -	The text window from which the text to get
# x -	x location on screen
# y -	y location on screen

proc ::tk::TextScanDrag {w x y} {
    # Make sure these exist, as some weird situations can trigger the
    # motion binding without the initial press.  [Bug #220269]
    if {![info exists ::tk::Priv(x)]} { set ::tk::Priv(x) $x }
    if {![info exists ::tk::Priv(y)]} { set ::tk::Priv(y) $y }
    if {($x != $::tk::Priv(x)) || ($y != $::tk::Priv(y))} {
	set ::tk::Priv(mouseMoved) 1
    }
    if {[info exists ::tk::Priv(mouseMoved)] && $::tk::Priv(mouseMoved)} {
	$w scan dragto $x $y
    }
}
@


1.4
log
@touched all sources to ease next import
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: text.tcl,v 1.7.6.2 2000/09/26 16:08:48 spolk Exp $
d17 1
a17 1
# Elements of tkPriv that are used in this file:
d39 1
a39 1
# The code below creates the default class bindings for entries.
d45 1
a45 1
    tkTextButton1 %W %x %y
d49 3
a51 3
    set tkPriv(x) %x
    set tkPriv(y) %y
    tkTextSelectTo %W %x %y
d54 2
a55 2
    set tkPriv(selectMode) word
    tkTextSelectTo %W %x %y
a56 1
    catch {%W mark set anchor sel.first}
d59 2
a60 2
    set tkPriv(selectMode) line
    tkTextSelectTo %W %x %y
a61 1
    catch {%W mark set anchor sel.first}
d64 3
a66 3
    tkTextResetAnchor %W @@%x,%y
    set tkPriv(selectMode) char
    tkTextSelectTo %W %x %y
d69 2
a70 2
    set tkPriv(selectMode) word
    tkTextSelectTo %W %x %y 1
d73 2
a74 2
    set tkPriv(selectMode) line
    tkTextSelectTo %W %x %y
d77 3
a79 3
    set tkPriv(x) %x
    set tkPriv(y) %y
    tkTextAutoScan %W
d82 1
a82 1
    tkCancelRepeat
d85 1
a85 1
    tkCancelRepeat
d91 1
a91 1
    tkTextSetCursor %W insert-1c
d94 1
a94 1
    tkTextSetCursor %W insert+1c
d97 1
a97 1
    tkTextSetCursor %W [tkTextUpDownLine %W -1]
d100 1
a100 1
    tkTextSetCursor %W [tkTextUpDownLine %W 1]
d103 1
a103 1
    tkTextKeySelect %W [%W index {insert - 1c}]
d106 1
a106 1
    tkTextKeySelect %W [%W index {insert + 1c}]
d109 1
a109 1
    tkTextKeySelect %W [tkTextUpDownLine %W -1]
d112 1
a112 1
    tkTextKeySelect %W [tkTextUpDownLine %W 1]
d115 1
a115 1
    tkTextSetCursor %W [tkTextPrevPos %W insert tcl_startOfPreviousWord]
d118 1
a118 1
    tkTextSetCursor %W [tkTextNextWord %W insert]
d121 1
a121 1
    tkTextSetCursor %W [tkTextPrevPara %W insert]
d124 1
a124 1
    tkTextSetCursor %W [tkTextNextPara %W insert]
d127 1
a127 1
    tkTextKeySelect %W [tkTextPrevPos %W insert tcl_startOfPreviousWord]
d130 1
a130 1
    tkTextKeySelect %W [tkTextNextWord %W insert]
d133 1
a133 1
    tkTextKeySelect %W [tkTextPrevPara %W insert]
d136 1
a136 1
    tkTextKeySelect %W [tkTextNextPara %W insert]
d139 1
a139 1
    tkTextSetCursor %W [tkTextScrollPages %W -1]
d142 1
a142 1
    tkTextKeySelect %W [tkTextScrollPages %W -1]
d145 1
a145 1
    tkTextSetCursor %W [tkTextScrollPages %W 1]
d148 1
a148 1
    tkTextKeySelect %W [tkTextScrollPages %W 1]
d158 1
a158 1
    tkTextSetCursor %W {insert linestart}
d161 1
a161 1
    tkTextKeySelect %W {insert linestart}
d164 1
a164 1
    tkTextSetCursor %W {insert lineend}
d167 1
a167 1
    tkTextKeySelect %W {insert lineend}
d170 1
a170 1
    tkTextSetCursor %W 1.0
d173 1
a173 1
    tkTextKeySelect %W 1.0
d176 1
a176 1
    tkTextSetCursor %W {end - 1 char}
d179 1
a179 1
    tkTextKeySelect %W {end - 1 char}
d183 5
a187 3
    tkTextInsert %W \t
    focus %W
    break
d201 1
a201 1
    tkTextInsert %W \t
d204 2
a205 1
    tkTextInsert %W \n
d231 2
a232 2
    set tkPriv(selectMode) char
    tkTextKeyExtend %W insert
d235 2
a236 2
    set tkPriv(selectMode) char
    tkTextKeyExtend %W insert
d257 3
a259 2
    if {!$tkPriv(mouseMoved) || $tk_strictMotif} {
	tkTextPaste %W %x %y
d263 1
a263 1
    catch {tkTextInsert %W [selection get -displayof %W]}
d266 1
a266 1
    tkTextInsert %W %A
d279 2
a280 1
if {[string equal $tcl_platform(platform) "macintosh"]} {
d288 1
a288 1
	tkTextSetCursor %W {insert linestart}
d293 1
a293 1
	tkTextSetCursor %W insert-1c
d303 1
a303 1
	tkTextSetCursor %W {insert lineend}
d308 1
a308 1
	tkTextSetCursor %W insert+1c
d322 1
a322 1
	tkTextSetCursor %W [tkTextUpDownLine %W 1]
d333 1
a333 1
	tkTextSetCursor %W [tkTextUpDownLine %W -1]
d338 1
a338 1
	tkTextTranspose %W
d342 8
d353 1
a353 1
	tkTextScrollPages %W 1
d360 1
a360 1
	tkTextSetCursor %W [tkTextPrevPos %W insert tcl_startOfPreviousWord]
d365 1
a365 1
	%W delete insert [tkTextNextWord %W insert]
d370 1
a370 1
	tkTextSetCursor %W [tkTextNextWord %W insert]
d375 1
a375 1
	tkTextSetCursor %W 1.0
d380 1
a380 1
	tkTextSetCursor %W end-1c
d385 1
a385 1
	%W delete [tkTextPrevPos %W insert tcl_startOfPreviousWord] insert
d390 1
a390 1
	%W delete [tkTextPrevPos %W insert tcl_startOfPreviousWord] insert
d397 2
a398 1
if {[string equal $tcl_platform(platform) "macintosh"]} {
d408 1
a408 1
    tkTextSetCursor %W [tkTextPrevPos %W insert tcl_startOfPreviousWord]
d411 1
a411 1
    tkTextSetCursor %W [tkTextNextWord %W insert]
d414 1
a414 1
    tkTextSetCursor %W [tkTextPrevPara %W insert]
d417 1
a417 1
    tkTextSetCursor %W [tkTextNextPara %W insert]
d420 1
a420 1
    tkTextKeySelect %W [tkTextPrevPos %W insert tcl_startOfPreviousWord]
d423 1
a423 1
    tkTextKeySelect %W [tkTextNextWord %W insert]
d426 1
a426 1
    tkTextKeySelect %W [tkTextPrevPara %W insert]
d429 1
a429 1
    tkTextKeySelect %W [tkTextNextPara %W insert]
d447 1
a447 4
	%W scan mark %x %y
	set tkPriv(x) %x
	set tkPriv(y) %y
	set tkPriv(mouseMoved) 0
d452 1
a452 6
	if {(%x != $tkPriv(x)) || (%y != $tkPriv(y))} {
	    set tkPriv(mouseMoved) 1
	}
	if {$tkPriv(mouseMoved)} {
	    %W scan dragto %x %y
	}
d455 1
a455 1
set tkPriv(prevPos) {}
d465 1
a465 1
if {[string equal "unix" $tcl_platform(platform)]} {
d482 1
a482 1
# tkTextClosestGap --
d492 1
a492 1
proc tkTextClosestGap {w x y} {
d504 1
a504 1
# tkTextButton1 --
d514 2
a515 2
proc tkTextButton1 {w x y} {
    global tkPriv
d517 4
a520 4
    set tkPriv(selectMode) char
    set tkPriv(mouseMoved) 0
    set tkPriv(pressX) $x
    $w mark set insert [tkTextClosestGap $w $x $y]
d522 5
a526 1
    if {[string equal [$w cget -state] "normal"]} {focus $w}
d529 1
a529 1
# tkTextSelectTo --
d541 3
a543 2
proc tkTextSelectTo {w x y {extend 0}} {
    global tkPriv tcl_platform
d545 1
a545 1
    set cur [tkTextClosestGap $w $x $y]
d550 2
a551 2
    if {[$w compare $cur != $anchor] || (abs($tkPriv(pressX) - $x) >= 3)} {
	set tkPriv(mouseMoved) 1
d553 1
a553 1
    switch $tkPriv(selectMode) {
d565 1
a565 1
		set first [tkTextPrevPos $w "$cur + 1c" tcl_wordBreakBefore]
d567 1
a567 1
		    set last [tkTextNextPos $w "anchor" tcl_wordBreakAfter]
d572 1
a572 1
		set last [tkTextNextPos $w "$cur - 1c" tcl_wordBreakAfter]
d574 1
a574 1
		    set first [tkTextPrevPos $w anchor tcl_wordBreakBefore]
d590 3
a592 8
    if {$tkPriv(mouseMoved) || [string compare $tkPriv(selectMode) "char"]} {
	if {[string compare $tcl_platform(platform) "unix"] \
		&& [$w compare $cur < anchor]} {
	    $w mark set insert $first
	} else {
	    $w mark set insert $last
	}
	$w tag remove sel 0.0 $first
d599 1
a599 1
# tkTextKeyExtend --
d608 1
a608 2
proc tkTextKeyExtend {w index} {
    global tkPriv
d627 1
a627 1
# tkTextPaste --
d635 14
a648 3
proc tkTextPaste {w x y} {
    $w mark set insert [tkTextClosestGap $w $x $y]
    catch {$w insert insert [selection get -displayof $w]}
d652 1
a652 1
# tkTextAutoScan --
d656 1
a656 1
# tkPriv(x) and tkPriv(y)), and reschedules itself as an "after"
d663 2
a664 2
proc tkTextAutoScan {w} {
    global tkPriv
d666 1
a666 1
    if {$tkPriv(y) >= [winfo height $w]} {
d668 1
a668 1
    } elseif {$tkPriv(y) < 0} {
d670 1
a670 1
    } elseif {$tkPriv(x) >= [winfo width $w]} {
d672 1
a672 1
    } elseif {$tkPriv(x) < 0} {
d677 2
a678 2
    tkTextSelectTo $w $tkPriv(x) $tkPriv(y)
    set tkPriv(afterId) [after 50 [list tkTextAutoScan $w]]
d681 1
a681 1
# tkTextSetCursor
d691 1
a691 2
proc tkTextSetCursor {w pos} {
    global tkPriv
d699 1
d702 1
a702 1
# tkTextKeySelect
d712 1
a712 2
proc tkTextKeySelect {w new} {
    global tkPriv
d738 1
a738 1
# tkTextResetAnchor --
d752 1
a752 2
proc tkTextResetAnchor {w index} {
    global tkPriv
d755 4
a758 1
	$w mark set anchor $index
d794 1
a794 1
# tkTextInsert --
d803 1
a803 1
proc tkTextInsert {w s} {
d807 1
d811 6
d822 4
d828 1
a828 1
# tkTextUpDownLine --
d841 2
a842 2
proc tkTextUpDownLine {w n} {
    global tkPriv
d846 2
a847 2
    if {[string compare $tkPriv(prevPos) $i]} {
	set tkPriv(char) $char
d849 1
a849 1
    set new [$w index [expr {$line + $n}].$tkPriv(char)]
d853 1
a853 1
    set tkPriv(prevPos) $new
d857 1
a857 1
# tkTextPrevPara --
d866 1
a866 1
proc tkTextPrevPara {w pos} {
d884 1
a884 1
# tkTextNextPara --
d893 1
a893 1
proc tkTextNextPara {w start} {
d914 1
a914 1
# tkTextScrollPages --
d926 1
a926 1
proc tkTextScrollPages {w count} {
d935 1
a935 1
# tkTextTranspose --
d945 1
a945 1
proc tkTextTranspose w {
d959 1
a959 1
# tk_textCopy --
d966 1
a966 1
proc tk_textCopy w {
d973 1
a973 1
# tk_textCut --
d981 1
a981 1
proc tk_textCut w {
d989 1
a989 1
# tk_textPaste --
d996 1
a996 1
proc tk_textPaste w {
d998 13
a1010 5
    catch {
	if {[string compare $tcl_platform(platform) "unix"]} {
	    catch {
		$w delete sel.first sel.last
	    }
a1011 1
	$w insert insert [selection get -displayof $w -selection CLIPBOARD]
d1015 1
a1015 1
# tkTextNextWord --
d1026 2
a1027 2
    proc tkTextNextWord {w start} {
	tkTextNextPos $w [tkTextNextPos $w $start tcl_endOfWord] \
d1031 2
a1032 2
    proc tkTextNextWord {w start} {
	tkTextNextPos $w $start tcl_endOfWord
d1036 1
a1036 1
# tkTextNextPos --
d1045 1
a1045 1
proc tkTextNextPos {w start op} {
d1065 1
a1065 1
# tkTextPrevPos --
d1074 1
a1074 1
proc tkTextPrevPos {w start op} {
d1100 15
d1116 21
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
# SCCS: @@(#) text.tcl 1.58 97/09/17 18:54:56
d10 1
d56 2
a57 1
    catch {%W mark set insert sel.first}
d62 2
a63 1
    catch {%W mark set insert sel.first}
d72 1
a72 1
    tkTextSelectTo %W %x %y
d207 1
a207 1
    if {[%W tag nextrange sel 1.0 end] != ""} {
d215 1
a215 1
    if {[%W tag nextrange sel 1.0 end] != ""} {
d277 2
a278 2
if {$tcl_platform(platform) == "macintosh"} {
	bind Text <Command-KeyPress> {# nothing}
d339 1
a339 1
if {$tcl_platform(platform) != "windows"} {
d386 1
a386 1
if {$tcl_platform(platform) == "macintosh"} {
d453 25
d491 1
a491 1
    if {![string compare $bbox ""]} {
d518 1
a518 1
    focus $w
d533 1
a533 1
proc tkTextSelectTo {w x y} {
d557 5
a561 1
		set last [tkTextNextPos $w "anchor" tcl_wordBreakAfter]
a562 1
		set first [tkTextPrevPos $w anchor tcl_wordBreakBefore]
d564 5
d581 3
a583 2
    if {$tkPriv(mouseMoved) || ($tkPriv(selectMode) != "char")} {
	if {$tcl_platform(platform) != "unix" && [$w compare $cur < anchor]} {
d635 1
a635 1
    if {[$w cget -state] == "normal"} {focus $w}
d664 1
a664 1
    set tkPriv(afterId) [after 50 tkTextAutoScan $w]
d701 1
a701 1
    if {[$w tag nextrange sel 1.0 end] == ""} {
d742 1
a742 1
    if {[$w tag ranges sel] == ""} {
d789 1
a789 1
    if {($s == "") || ([$w cget -state] == "disabled")} {
d793 1
a793 1
	if {[$w compare sel.first <= insert]
d820 1
a820 1
    if {[string compare $tkPriv(prevPos) $i] != 0} {
d842 4
a845 3
    while 1 {
	if {(([$w get "$pos - 1 line"] == "\n") && ([$w get $pos] != "\n"))
		|| ($pos == "1.0")} {
d850 1
a850 1
	    if {[$w compare $pos != insert] || ($pos == "1.0")} {
d869 1
a869 1
    while {[$w get $pos] != "\n"} {
d875 1
a875 1
    while {[$w get $pos] == "\n"} {
d903 1
a903 1
    if {$bbox == ""} {
d973 1
a973 1
	if {"$tcl_platform(platform)" != "unix"} {
d992 1
a992 1
if {$tcl_platform(platform) == "windows"}  {
d1016 1
a1016 1
	set text "$text[$w get $cur "$cur lineend + 1c"]"
d1019 6
d1045 1
a1045 1
	set text "[$w get "$cur linestart - 1c" $cur]$text"
d1048 12
d1066 1
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: text.tcl,v 1.7.6.2 2000/09/26 16:08:48 spolk Exp $
a9 1
# Copyright (c) 1998 by Scriptics Corporation.
d55 1
a55 2
    catch {%W mark set insert sel.last}
    catch {%W mark set anchor sel.first}
d60 1
a60 2
    catch {%W mark set insert sel.last}
    catch {%W mark set anchor sel.first}
d69 1
a69 1
    tkTextSelectTo %W %x %y 1
d204 1
a204 1
    if {[string compare [%W tag nextrange sel 1.0 end] ""]} {
d212 1
a212 1
    if {[string compare [%W tag nextrange sel 1.0 end] ""]} {
d274 2
a275 2
if {[string equal $tcl_platform(platform) "macintosh"]} {
    bind Text <Command-KeyPress> {# nothing}
d336 1
a336 1
if {[string compare $tcl_platform(platform) "windows"]} {
d383 1
a383 1
if {[string equal $tcl_platform(platform) "macintosh"]} {
a449 25
# The MouseWheel will typically only fire on Windows.  However,
# someone could use the "event generate" command to produce one
# on other platforms.

bind Text <MouseWheel> {
    %W yview scroll [expr {- (%D / 120) * 4}] units
}

if {[string equal "unix" $tcl_platform(platform)]} {
    # Support for mousewheels on Linux/Unix commonly comes through mapping
    # the wheel to the extended buttons.  If you have a mousewheel, find
    # Linux configuration info at:
    #	http://www.inria.fr/koala/colas/mouse-wheel-scroll/
    bind Text <4> {
	if {!$tk_strictMotif} {
	    %W yview scroll -5 units
	}
    }
    bind Text <5> {
	if {!$tk_strictMotif} {
	    %W yview scroll 5 units
	}
    }
}

d463 1
a463 1
    if {[string equal $bbox ""]} {
d490 1
a490 1
    if {[string equal [$w cget -state] "normal"]} {focus $w}
d505 1
a505 1
proc tkTextSelectTo {w x y {extend 0}} {
d529 1
a529 5
		if { !$extend } {
		    set last [tkTextNextPos $w "anchor" tcl_wordBreakAfter]
		} else {
		    set last anchor
		}
d531 1
a532 5
		if { !$extend } {
		    set first [tkTextPrevPos $w anchor tcl_wordBreakBefore]
		} else {
		    set first anchor
		}
d545 2
a546 3
    if {$tkPriv(mouseMoved) || [string compare $tkPriv(selectMode) "char"]} {
	if {[string compare $tcl_platform(platform) "unix"] \
		&& [$w compare $cur < anchor]} {
d598 1
a598 1
    if {[string equal [$w cget -state] "normal"]} {focus $w}
d627 1
a627 1
    set tkPriv(afterId) [after 50 [list tkTextAutoScan $w]]
d664 1
a664 1
    if {[string equal [$w tag nextrange sel 1.0 end] ""]} {
d705 1
a705 1
    if {[string equal [$w tag ranges sel] ""]} {
d752 1
a752 1
    if {[string equal $s ""] || [string equal [$w cget -state] "disabled"]} {
d756 1
a756 1
	if {[$w compare sel.first <= insert] \
d783 1
a783 1
    if {[string compare $tkPriv(prevPos) $i]} {
d805 3
a807 4
    while {1} {
	if {([string equal [$w get "$pos - 1 line"] "\n"] \
		&& [string compare [$w get $pos] "\n"]) \
		|| [string equal $pos "1.0"]} {
d812 1
a812 1
	    if {[$w compare $pos != insert] || [string equal $pos 1.0]} {
d831 1
a831 1
    while {[string compare [$w get $pos] "\n"]} {
d837 1
a837 1
    while {[string equal [$w get $pos] "\n"]} {
d865 1
a865 1
    if {[string equal $bbox ""]} {
d935 1
a935 1
	if {[string compare $tcl_platform(platform) "unix"]} {
d954 1
a954 1
if {[string equal $tcl_platform(platform) "windows"]}  {
d978 1
a978 1
	set text $text[$w get $cur "$cur lineend + 1c"]
a980 6
	    ## Adjust for embedded windows and images
	    ## dump gives us 3 items per window/image
	    set dump [$w dump -image -window $start "$start + $pos c"]
	    if {[llength $dump]} {
		set pos [expr {$pos + ([llength $dump]/3)}]
	    }
d1001 1
a1001 1
	set text [$w get "$cur linestart - 1c" $cur]$text
a1003 12
	    ## Adjust for embedded windows and images
	    ## dump gives us 3 items per window/image
	    set dump [$w dump -image -window "$cur linestart" "$start - 1c"]
	    if {[llength $dump]} {
		## This is a hokey extra hack for control-arrow movement
		## that should be in a while loop to be correct (hobbs)
		if {[$w compare [lindex $dump 2] > \
			"$cur linestart - 1c + $pos c"]} {
		    incr pos -1
		}
		set pos [expr {$pos + ([llength $dump]/3)}]
	    }
a1009 1

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: text.tcl,v 1.24 2002/08/31 06:12:28 das Exp $
d17 1
a17 1
# Elements of ::tk::Priv that are used in this file:
d39 1
a39 1
# The code below creates the default class bindings for text widgets.
d45 1
a45 1
    tk::TextButton1 %W %x %y
d49 3
a51 3
    set tk::Priv(x) %x
    set tk::Priv(y) %y
    tk::TextSelectTo %W %x %y
d54 2
a55 2
    set tk::Priv(selectMode) word
    tk::TextSelectTo %W %x %y
d57 1
d60 2
a61 2
    set tk::Priv(selectMode) line
    tk::TextSelectTo %W %x %y
d63 1
d66 3
a68 3
    tk::TextResetAnchor %W @@%x,%y
    set tk::Priv(selectMode) char
    tk::TextSelectTo %W %x %y
d71 2
a72 2
    set tk::Priv(selectMode) word
    tk::TextSelectTo %W %x %y 1
d75 2
a76 2
    set tk::Priv(selectMode) line
    tk::TextSelectTo %W %x %y
d79 3
a81 3
    set tk::Priv(x) %x
    set tk::Priv(y) %y
    tk::TextAutoScan %W
d84 1
a84 1
    tk::CancelRepeat
d87 1
a87 1
    tk::CancelRepeat
d93 1
a93 1
    tk::TextSetCursor %W insert-1c
d96 1
a96 1
    tk::TextSetCursor %W insert+1c
d99 1
a99 1
    tk::TextSetCursor %W [tk::TextUpDownLine %W -1]
d102 1
a102 1
    tk::TextSetCursor %W [tk::TextUpDownLine %W 1]
d105 1
a105 1
    tk::TextKeySelect %W [%W index {insert - 1c}]
d108 1
a108 1
    tk::TextKeySelect %W [%W index {insert + 1c}]
d111 1
a111 1
    tk::TextKeySelect %W [tk::TextUpDownLine %W -1]
d114 1
a114 1
    tk::TextKeySelect %W [tk::TextUpDownLine %W 1]
d117 1
a117 1
    tk::TextSetCursor %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
d120 1
a120 1
    tk::TextSetCursor %W [tk::TextNextWord %W insert]
d123 1
a123 1
    tk::TextSetCursor %W [tk::TextPrevPara %W insert]
d126 1
a126 1
    tk::TextSetCursor %W [tk::TextNextPara %W insert]
d129 1
a129 1
    tk::TextKeySelect %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
d132 1
a132 1
    tk::TextKeySelect %W [tk::TextNextWord %W insert]
d135 1
a135 1
    tk::TextKeySelect %W [tk::TextPrevPara %W insert]
d138 1
a138 1
    tk::TextKeySelect %W [tk::TextNextPara %W insert]
d141 1
a141 1
    tk::TextSetCursor %W [tk::TextScrollPages %W -1]
d144 1
a144 1
    tk::TextKeySelect %W [tk::TextScrollPages %W -1]
d147 1
a147 1
    tk::TextSetCursor %W [tk::TextScrollPages %W 1]
d150 1
a150 1
    tk::TextKeySelect %W [tk::TextScrollPages %W 1]
d160 1
a160 1
    tk::TextSetCursor %W {insert linestart}
d163 1
a163 1
    tk::TextKeySelect %W {insert linestart}
d166 1
a166 1
    tk::TextSetCursor %W {insert lineend}
d169 1
a169 1
    tk::TextKeySelect %W {insert lineend}
d172 1
a172 1
    tk::TextSetCursor %W 1.0
d175 1
a175 1
    tk::TextKeySelect %W 1.0
d178 1
a178 1
    tk::TextSetCursor %W {end - 1 char}
d181 1
a181 1
    tk::TextKeySelect %W {end - 1 char}
d185 3
a187 5
    if { [string equal [%W cget -state] "normal"] } {
	tk::TextInsert %W \t
	focus %W
	break
    }
d201 1
a201 1
    tk::TextInsert %W \t
d204 1
a204 2
    tk::TextInsert %W \n
    if {[%W cget -autoseparators]} {%W edit separator}
d230 2
a231 2
    set tk::Priv(selectMode) char
    tk::TextKeyExtend %W insert
d234 2
a235 2
    set tk::Priv(selectMode) char
    tk::TextKeyExtend %W insert
d256 2
a257 3
    if {$tk_strictMotif || ![info exists tk::Priv(mouseMoved)]
	|| !$tk::Priv(mouseMoved)} {
	tk::TextPasteSelection %W %x %y
d261 1
a261 1
    catch {tk::TextInsert %W [::tk::GetSelection %W PRIMARY]}
d264 1
a264 1
    tk::TextInsert %W %A
d277 1
a277 2
if {[string equal [tk windowingsystem] "classic"]
	|| [string equal [tk windowingsystem] "aqua"]} {
d285 1
a285 1
	tk::TextSetCursor %W {insert linestart}
d290 1
a290 1
	tk::TextSetCursor %W insert-1c
d300 1
a300 1
	tk::TextSetCursor %W {insert lineend}
d305 1
a305 1
	tk::TextSetCursor %W insert+1c
d319 1
a319 1
	tk::TextSetCursor %W [tk::TextUpDownLine %W 1]
d330 1
a330 1
	tk::TextSetCursor %W [tk::TextUpDownLine %W -1]
d335 1
a335 1
	tk::TextTranspose %W
a338 8
bind Text <<Undo>> {
    catch { %W edit undo }
}

bind Text <<Redo>> {
    catch { %W edit redo }
}

d342 1
a342 1
	tk::TextScrollPages %W 1
d349 1
a349 1
	tk::TextSetCursor %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
d354 1
a354 1
	%W delete insert [tk::TextNextWord %W insert]
d359 1
a359 1
	tk::TextSetCursor %W [tk::TextNextWord %W insert]
d364 1
a364 1
	tk::TextSetCursor %W 1.0
d369 1
a369 1
	tk::TextSetCursor %W end-1c
d374 1
a374 1
	%W delete [tk::TextPrevPos %W insert tcl_startOfPreviousWord] insert
d379 1
a379 1
	%W delete [tk::TextPrevPos %W insert tcl_startOfPreviousWord] insert
d386 1
a386 2
if {[string equal [tk windowingsystem] "classic"]
	|| [string equal [tk windowingsystem] "aqua"]} {
d396 1
a396 1
    tk::TextSetCursor %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
d399 1
a399 1
    tk::TextSetCursor %W [tk::TextNextWord %W insert]
d402 1
a402 1
    tk::TextSetCursor %W [tk::TextPrevPara %W insert]
d405 1
a405 1
    tk::TextSetCursor %W [tk::TextNextPara %W insert]
d408 1
a408 1
    tk::TextKeySelect %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
d411 1
a411 1
    tk::TextKeySelect %W [tk::TextNextWord %W insert]
d414 1
a414 1
    tk::TextKeySelect %W [tk::TextPrevPara %W insert]
d417 1
a417 1
    tk::TextKeySelect %W [tk::TextNextPara %W insert]
d435 4
a438 1
	tk::TextScanMark %W %x %y
d443 6
a448 1
	tk::TextScanDrag %W %x %y
d451 1
a451 1
set ::tk::Priv(prevPos) {}
d461 1
a461 1
if {[string equal "x11" [tk windowingsystem]]} {
d478 1
a478 1
# ::tk::TextClosestGap --
d488 1
a488 1
proc ::tk::TextClosestGap {w x y} {
d500 1
a500 1
# ::tk::TextButton1 --
d510 2
a511 2
proc ::tk::TextButton1 {w x y} {
    variable ::tk::Priv
d513 4
a516 4
    set Priv(selectMode) char
    set Priv(mouseMoved) 0
    set Priv(pressX) $x
    $w mark set insert [TextClosestGap $w $x $y]
d518 1
a518 5
    # Allow focus in any case on Windows, because that will let the
    # selection be displayed even for state disabled text widgets.
    if {[string equal $::tcl_platform(platform) "windows"] \
	    || [string equal [$w cget -state] "normal"]} {focus $w}
    if {[$w cget -autoseparators]} {$w edit separator}
d521 1
a521 1
# ::tk::TextSelectTo --
d533 2
a534 3
proc ::tk::TextSelectTo {w x y {extend 0}} {
    global tcl_platform
    variable ::tk::Priv
d536 1
a536 1
    set cur [TextClosestGap $w $x $y]
d541 2
a542 2
    if {[$w compare $cur != $anchor] || (abs($Priv(pressX) - $x) >= 3)} {
	set Priv(mouseMoved) 1
d544 1
a544 1
    switch $Priv(selectMode) {
d556 1
a556 1
		set first [TextPrevPos $w "$cur + 1c" tcl_wordBreakBefore]
d558 1
a558 1
		    set last [TextNextPos $w "anchor" tcl_wordBreakAfter]
d563 1
a563 1
		set last [TextNextPos $w "$cur - 1c" tcl_wordBreakAfter]
d565 1
a565 1
		    set first [TextPrevPos $w anchor tcl_wordBreakBefore]
d581 8
a588 3
    if {$Priv(mouseMoved) || [string compare $Priv(selectMode) "char"]} {
	$w tag remove sel 0.0 end
	$w mark set insert $cur
d595 1
a595 1
# ::tk::TextKeyExtend --
d604 2
a605 1
proc ::tk::TextKeyExtend {w index} {
d624 1
a624 1
# ::tk::TextPasteSelection --
d632 3
a634 14
proc ::tk::TextPasteSelection {w x y} {
    $w mark set insert [TextClosestGap $w $x $y]
    if {![catch {::tk::GetSelection $w PRIMARY} sel]} {
	set oldSeparator [$w cget -autoseparators]
	if {$oldSeparator} {
	    $w configure -autoseparators 0
	    $w edit separator
	}
	$w insert insert $sel
	if {$oldSeparator} {
	    $w edit separator
	    $w configure -autoseparators 1
	}
    }
d638 1
a638 1
# ::tk::TextAutoScan --
d642 1
a642 1
# ::tk::Priv(x) and ::tk::Priv(y)), and reschedules itself as an "after"
d649 2
a650 2
proc ::tk::TextAutoScan {w} {
    variable ::tk::Priv
d652 1
a652 1
    if {$Priv(y) >= [winfo height $w]} {
d654 1
a654 1
    } elseif {$Priv(y) < 0} {
d656 1
a656 1
    } elseif {$Priv(x) >= [winfo width $w]} {
d658 1
a658 1
    } elseif {$Priv(x) < 0} {
d663 2
a664 2
    TextSelectTo $w $Priv(x) $Priv(y)
    set Priv(afterId) [after 50 [list tk::TextAutoScan $w]]
d667 1
a667 1
# ::tk::TextSetCursor
d677 2
a678 1
proc ::tk::TextSetCursor {w pos} {
a685 1
    if {[$w cget -autoseparators]} {$w edit separator}
d688 1
a688 1
# ::tk::TextKeySelect
d698 2
a699 1
proc ::tk::TextKeySelect {w new} {
d725 1
a725 1
# ::tk::TextResetAnchor --
d739 2
a740 1
proc ::tk::TextResetAnchor {w index} {
d743 1
a743 4
	# Don't move the anchor if there is no selection now; this makes
	# the widget behave "correctly" when the user clicks once, then
	# shift-clicks somewhere -- ie, the area between the two clicks will be
	# selected. [Bug: 5929].
d779 1
a779 1
# ::tk::TextInsert --
d788 1
a788 1
proc ::tk::TextInsert {w s} {
a791 1
    set compound 0
a794 6
            set oldSeparator [$w cget -autoseparators]
            if { $oldSeparator } {
                $w configure -autoseparators 0
                $w edit separator
                set compound 1
            }
a799 4
    if { $compound && $oldSeparator } {
        $w edit separator
        $w configure -autoseparators 1
    }
d802 1
a802 1
# ::tk::TextUpDownLine --
d815 2
a816 2
proc ::tk::TextUpDownLine {w n} {
    variable ::tk::Priv
d820 2
a821 2
    if {[string compare $Priv(prevPos) $i]} {
	set Priv(char) $char
d823 1
a823 1
    set new [$w index [expr {$line + $n}].$Priv(char)]
d827 1
a827 1
    set Priv(prevPos) $new
d831 1
a831 1
# ::tk::TextPrevPara --
d840 1
a840 1
proc ::tk::TextPrevPara {w pos} {
d858 1
a858 1
# ::tk::TextNextPara --
d867 1
a867 1
proc ::tk::TextNextPara {w start} {
d888 1
a888 1
# ::tk::TextScrollPages --
d900 1
a900 1
proc ::tk::TextScrollPages {w count} {
d909 1
a909 1
# ::tk::TextTranspose --
d919 1
a919 1
proc ::tk::TextTranspose w {
d933 1
a933 1
# ::tk_textCopy --
d940 1
a940 1
proc ::tk_textCopy w {
d947 1
a947 1
# ::tk_textCut --
d955 1
a955 1
proc ::tk_textCut w {
d963 1
a963 1
# ::tk_textPaste --
d970 1
a970 1
proc ::tk_textPaste w {
d972 5
a976 13
    if {![catch {::tk::GetSelection $w CLIPBOARD} sel]} {
	set oldSeparator [$w cget -autoseparators]
	if { $oldSeparator } {
	    $w configure -autoseparators 0
	    $w edit separator
	}
	if {[string compare [tk windowingsystem] "x11"]} {
	    catch { $w delete sel.first sel.last }
	}
	$w insert insert $sel
	if { $oldSeparator } {
	    $w edit separator
	    $w configure -autoseparators 1
d978 1
d982 1
a982 1
# ::tk::TextNextWord --
d993 2
a994 2
    proc ::tk::TextNextWord {w start} {
	TextNextPos $w [TextNextPos $w $start tcl_endOfWord] \
d998 2
a999 2
    proc ::tk::TextNextWord {w start} {
	TextNextPos $w $start tcl_endOfWord
d1003 1
a1003 1
# ::tk::TextNextPos --
d1012 1
a1012 1
proc ::tk::TextNextPos {w start op} {
d1032 1
a1032 1
# ::tk::TextPrevPos --
d1041 1
a1041 1
proc ::tk::TextPrevPos {w start op} {
a1066 15
# ::tk::TextScanMark --
#
# Marks the start of a possible scan drag operation
#
# Arguments:
# w -	The text window from which the text to get
# x -	x location on screen
# y -	y location on screen

proc ::tk::TextScanMark {w x y} {
    $w scan mark $x $y
    set ::tk::Priv(x) $x
    set ::tk::Priv(y) $y
    set ::tk::Priv(mouseMoved) 0
}
a1067 21
# ::tk::TextScanDrag --
#
# Marks the start of a possible scan drag operation
#
# Arguments:
# w -	The text window from which the text to get
# x -	x location on screen
# y -	y location on screen

proc ::tk::TextScanDrag {w x y} {
    # Make sure these exist, as some weird situations can trigger the
    # motion binding without the initial press.  [Bug #220269]
    if {![info exists ::tk::Priv(x)]} { set ::tk::Priv(x) $x }
    if {![info exists ::tk::Priv(y)]} { set ::tk::Priv(y) $y }
    if {($x != $::tk::Priv(x)) || ($y != $::tk::Priv(y))} {
	set ::tk::Priv(mouseMoved) 1
    }
    if {[info exists ::tk::Priv(mouseMoved)] && $::tk::Priv(mouseMoved)} {
	$w scan dragto $x $y
    }
}
@


