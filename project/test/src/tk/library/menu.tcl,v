head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.46;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.14;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.26;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.52;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.33;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.50;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# menu.tcl --
#
# This file defines the default bindings for Tk menus and menubuttons.
# It also implements keyboard traversal of menus and implements a few
# other utility procedures related to menus.
#
# RCS: @@(#) $Id: menu.tcl,v 1.18 2002/08/31 06:12:28 das Exp $
#
# Copyright (c) 1992-1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

#-------------------------------------------------------------------------
# Elements of tk::Priv that are used in this file:
#
# cursor -		Saves the -cursor option for the posted menubutton.
# focus -		Saves the focus during a menu selection operation.
#			Focus gets restored here when the menu is unposted.
# grabGlobal -		Used in conjunction with tk::Priv(oldGrab):  if
#			tk::Priv(oldGrab) is non-empty, then tk::Priv(grabGlobal)
#			contains either an empty string or "-global" to
#			indicate whether the old grab was a local one or
#			a global one.
# inMenubutton -	The name of the menubutton widget containing
#			the mouse, or an empty string if the mouse is
#			not over any menubutton.
# menuBar -		The name of the menubar that is the root
#			of the cascade hierarchy which is currently
#			posted. This is null when there is no menu currently
#			being pulled down from a menu bar.
# oldGrab -		Window that had the grab before a menu was posted.
#			Used to restore the grab state after the menu
#			is unposted.  Empty string means there was no
#			grab previously set.
# popup -		If a menu has been popped up via tk_popup, this
#			gives the name of the menu.  Otherwise this
#			value is empty.
# postedMb -		Name of the menubutton whose menu is currently
#			posted, or an empty string if nothing is posted
#			A grab is set on this widget.
# relief -		Used to save the original relief of the current
#			menubutton.
# window -		When the mouse is over a menu, this holds the
#			name of the menu;  it's cleared when the mouse
#			leaves the menu.
# tearoff -		Whether the last menu posted was a tearoff or not.
#			This is true always for unix, for tearoffs for Mac
#			and Windows.
# activeMenu -		This is the last active menu for use
#			with the <<MenuSelect>> virtual event.
# activeItem -		This is the last active menu item for
#			use with the <<MenuSelect>> virtual event.
#-------------------------------------------------------------------------

#-------------------------------------------------------------------------
# Overall note:
# This file is tricky because there are five different ways that menus
# can be used:
#
# 1. As a pulldown from a menubutton. In this style, the variable 
#    tk::Priv(postedMb) identifies the posted menubutton.
# 2. As a torn-off menu copied from some other menu.  In this style
#    tk::Priv(postedMb) is empty, and menu's type is "tearoff".
# 3. As an option menu, triggered from an option menubutton.  In this
#    style tk::Priv(postedMb) identifies the posted menubutton.
# 4. As a popup menu.  In this style tk::Priv(postedMb) is empty and
#    the top-level menu's type is "normal".
# 5. As a pulldown from a menubar. The variable tk::Priv(menubar) has
#    the owning menubar, and the menu itself is of type "normal".
#
# The various binding procedures use the  state described above to
# distinguish the various cases and take different actions in each
# case.
#-------------------------------------------------------------------------

#-------------------------------------------------------------------------
# The code below creates the default class bindings for menus
# and menubuttons.
#-------------------------------------------------------------------------

bind Menubutton <FocusIn> {}
bind Menubutton <Enter> {
    tk::MbEnter %W
}
bind Menubutton <Leave> {
    tk::MbLeave %W
}
bind Menubutton <1> {
    if {$tk::Priv(inMenubutton) ne ""} {
	tk::MbPost $tk::Priv(inMenubutton) %X %Y
    }
}
bind Menubutton <Motion> {
    tk::MbMotion %W up %X %Y
}
bind Menubutton <B1-Motion> {
    tk::MbMotion %W down %X %Y
}
bind Menubutton <ButtonRelease-1> {
    tk::MbButtonUp %W
}
bind Menubutton <space> {
    tk::MbPost %W
    tk::MenuFirstEntry [%W cget -menu]
}

# Must set focus when mouse enters a menu, in order to allow
# mixed-mode processing using both the mouse and the keyboard.
# Don't set the focus if the event comes from a grab release,
# though:  such an event can happen after as part of unposting
# a cascaded chain of menus, after the focus has already been
# restored to wherever it was before menu selection started.

bind Menu <FocusIn> {}

bind Menu <Enter> {
    set tk::Priv(window) %W
    if {[%W cget -type] eq "tearoff"} {
	if {"%m" ne "NotifyUngrab"} {
	    if {[tk windowingsystem] eq "x11"} {
		tk_menuSetFocus %W
	    }
	}
    }
    tk::MenuMotion %W %x %y %s
}

bind Menu <Leave> {
    tk::MenuLeave %W %X %Y %s
}
bind Menu <Motion> {
    tk::MenuMotion %W %x %y %s
}
bind Menu <ButtonPress> {
    tk::MenuButtonDown %W
}
bind Menu <ButtonRelease> {
   tk::MenuInvoke %W 1
}
bind Menu <space> {
    tk::MenuInvoke %W 0
}
bind Menu <Return> {
    tk::MenuInvoke %W 0
}
bind Menu <Escape> {
    tk::MenuEscape %W
}
bind Menu <Left> {
    tk::MenuLeftArrow %W
}
bind Menu <Right> {
    tk::MenuRightArrow %W
}
bind Menu <Up> {
    tk::MenuUpArrow %W
}
bind Menu <Down> {
    tk::MenuDownArrow %W
}
bind Menu <KeyPress> {
    tk::TraverseWithinMenu %W %A
}

# The following bindings apply to all windows, and are used to
# implement keyboard menu traversal.

if {[string equal [tk windowingsystem] "x11"]} {
    bind all <Alt-KeyPress> {
	tk::TraverseToMenu %W %A
    }

    bind all <F10> {
	tk::FirstMenu %W
    }
} else {
    bind Menubutton <Alt-KeyPress> {
	tk::TraverseToMenu %W %A
    }

    bind Menubutton <F10> {
	tk::FirstMenu %W
    }
}

# ::tk::MbEnter --
# This procedure is invoked when the mouse enters a menubutton
# widget.  It activates the widget unless it is disabled.  Note:
# this procedure is only invoked when mouse button 1 is *not* down.
# The procedure ::tk::MbB1Enter is invoked if the button is down.
#
# Arguments:
# w -			The  name of the widget.

proc ::tk::MbEnter w {
    variable ::tk::Priv

    if {[string compare $Priv(inMenubutton) ""]} {
	MbLeave $Priv(inMenubutton)
    }
    set Priv(inMenubutton) $w
    if {[string compare [$w cget -state] "disabled"]} {
	$w configure -state active
    }
}

# ::tk::MbLeave --
# This procedure is invoked when the mouse leaves a menubutton widget.
# It de-activates the widget, if the widget still exists.
#
# Arguments:
# w -			The  name of the widget.

proc ::tk::MbLeave w {
    variable ::tk::Priv

    set Priv(inMenubutton) {}
    if {![winfo exists $w]} {
	return
    }
    if {[string equal [$w cget -state] "active"]} {
	$w configure -state normal
    }
}

# ::tk::MbPost --
# Given a menubutton, this procedure does all the work of posting
# its associated menu and unposting any other menu that is currently
# posted.
#
# Arguments:
# w -			The name of the menubutton widget whose menu
#			is to be posted.
# x, y -		Root coordinates of cursor, used for positioning
#			option menus.  If not specified, then the center
#			of the menubutton is used for an option menu.

proc ::tk::MbPost {w {x {}} {y {}}} {
    global errorInfo
    variable ::tk::Priv
    global tcl_platform

    if {[$w cget -state] eq "disabled" || $w eq $Priv(postedMb)} {
	return
    }
    set menu [$w cget -menu]
    if {[string equal $menu ""]} {
	return
    }
    set tearoff [expr {[tk windowingsystem] eq "x11" \
	    || [$menu cget -type] eq "tearoff"}]
    if {[string first $w $menu] != 0} {
	error "can't post $menu:  it isn't a descendant of $w (this is a new requirement in Tk versions 3.0 and later)"
    }
    set cur $Priv(postedMb)
    if {[string compare $cur ""]} {
	MenuUnpost {}
    }
    set Priv(cursor) [$w cget -cursor]
    set Priv(relief) [$w cget -relief]
    $w configure -cursor arrow
    $w configure -relief raised

    set Priv(postedMb) $w
    set Priv(focus) [focus]
    $menu activate none
    GenerateMenuSelect $menu

    # If this looks like an option menubutton then post the menu so
    # that the current entry is on top of the mouse.  Otherwise post
    # the menu just below the menubutton, as for a pull-down.

    update idletasks
    if {[catch {
	switch [$w cget -direction] {
    	    above {
    	    	set x [winfo rootx $w]
    	    	set y [expr {[winfo rooty $w] - [winfo reqheight $menu]}]
		PostOverPoint $menu $x $y
    	    }
    	    below {
    	    	set x [winfo rootx $w]
    	    	set y [expr {[winfo rooty $w] + [winfo height $w]}]
		PostOverPoint $menu $x $y
    	    }
    	    left {
    	    	set x [expr {[winfo rootx $w] - [winfo reqwidth $menu]}]
    	    	set y [expr {(2 * [winfo rooty $w] + [winfo height $w]) / 2}]
    	    	set entry [MenuFindName $menu [$w cget -text]]
    	    	if {[$w cget -indicatoron]} {
		    if {$entry == [$menu index last]} {
		    	incr y [expr {-([$menu yposition $entry] \
			    	+ [winfo reqheight $menu])/2}]
		    } else {
		    	incr y [expr {-([$menu yposition $entry] \
			        + [$menu yposition [expr {$entry+1}]])/2}]
		    }
    	    	}
		PostOverPoint $menu $x $y
		if {$entry ne "" \
			&& [$menu entrycget $entry -state] ne "disabled"} {
    	    	    $menu activate $entry
		    GenerateMenuSelect $menu
    	    	}
    	    }
    	    right {
    	    	set x [expr {[winfo rootx $w] + [winfo width $w]}]
    	    	set y [expr {(2 * [winfo rooty $w] + [winfo height $w]) / 2}]
    	    	set entry [MenuFindName $menu [$w cget -text]]
    	    	if {[$w cget -indicatoron]} {
		    if {$entry == [$menu index last]} {
		    	incr y [expr {-([$menu yposition $entry] \
			    	+ [winfo reqheight $menu])/2}]
		    } else {
		    	incr y [expr {-([$menu yposition $entry] \
			        + [$menu yposition [expr {$entry+1}]])/2}]
		    }
    	    	}
		PostOverPoint $menu $x $y
		if {$entry ne "" \
			&& [$menu entrycget $entry -state] ne "disabled"} {
    	    	    $menu activate $entry
		    GenerateMenuSelect $menu
    	    	}
    	    }
    	    default {
    	    	if {[$w cget -indicatoron]} {
		    if {[string equal $y {}]} {
			set x [expr {[winfo rootx $w] + [winfo width $w]/2}]
			set y [expr {[winfo rooty $w] + [winfo height $w]/2}]
	    	    }
	            PostOverPoint $menu $x $y [MenuFindName $menu [$w cget -text]]
		} else {
		    PostOverPoint $menu [winfo rootx $w] [expr {[winfo rooty $w]+[winfo height $w]}]
    	    	}  
    	    }
	}
    } msg]} {
	# Error posting menu (e.g. bogus -postcommand). Unpost it and
	# reflect the error.
	
	set savedInfo $errorInfo
	MenuUnpost {}
	error $msg $savedInfo

    }

    set Priv(tearoff) $tearoff
    if {$tearoff != 0} {
    	focus $menu
	if {[winfo viewable $w]} {
	    SaveGrabInfo $w
	    grab -global $w
	}
    }
}

# ::tk::MenuUnpost --
# This procedure unposts a given menu, plus all of its ancestors up
# to (and including) a menubutton, if any.  It also restores various
# values to what they were before the menu was posted, and releases
# a grab if there's a menubutton involved.  Special notes:
# 1. It's important to unpost all menus before releasing the grab, so
#    that any Enter-Leave events (e.g. from menu back to main
#    application) have mode NotifyGrab.
# 2. Be sure to enclose various groups of commands in "catch" so that
#    the procedure will complete even if the menubutton or the menu
#    or the grab window has been deleted.
#
# Arguments:
# menu -		Name of a menu to unpost.  Ignored if there
#			is a posted menubutton.

proc ::tk::MenuUnpost menu {
    global tcl_platform
    variable ::tk::Priv
    set mb $Priv(postedMb)

    # Restore focus right away (otherwise X will take focus away when
    # the menu is unmapped and under some window managers (e.g. olvwm)
    # we'll lose the focus completely).

    catch {focus $Priv(focus)}
    set Priv(focus) ""

    # Unpost menu(s) and restore some stuff that's dependent on
    # what was posted.

    catch {
	if {[string compare $mb ""]} {
	    set menu [$mb cget -menu]
	    $menu unpost
	    set Priv(postedMb) {}
	    $mb configure -cursor $Priv(cursor)
	    $mb configure -relief $Priv(relief)
	} elseif {[string compare $Priv(popup) ""]} {
	    $Priv(popup) unpost
	    set Priv(popup) {}
	} elseif {[string compare [$menu cget -type] "menubar"] \
		&& [string compare [$menu cget -type] "tearoff"]} {
	    # We're in a cascaded sub-menu from a torn-off menu or popup.
	    # Unpost all the menus up to the toplevel one (but not
	    # including the top-level torn-off one) and deactivate the
	    # top-level torn off menu if there is one.

	    while {1} {
		set parent [winfo parent $menu]
		if {[string compare [winfo class $parent] "Menu"] \
			|| ![winfo ismapped $parent]} {
		    break
		}
		$parent activate none
		$parent postcascade none
		GenerateMenuSelect $parent
		set type [$parent cget -type]
		if {[string equal $type "menubar"] || \
			[string equal $type "tearoff"]} {
		    break
		}
		set menu $parent
	    }
	    if {[string compare [$menu cget -type] "menubar"]} {
		$menu unpost
	    }
	}
    }

    if {($Priv(tearoff) != 0) || $Priv(menuBar) ne ""} {
    	# Release grab, if any, and restore the previous grab, if there
    	# was one.
	if {[string compare $menu ""]} {
	    set grab [grab current $menu]
	    if {[string compare $grab ""]} {
		grab release $grab
	    }
	}
	RestoreOldGrab
	if {$Priv(menuBar) ne ""} {
	    $Priv(menuBar) configure -cursor $Priv(cursor)
	    set Priv(menuBar) {}
	}
	if {[tk windowingsystem] ne "x11"} {
	    set Priv(tearoff) 0
	}
    }
}

# ::tk::MbMotion --
# This procedure handles mouse motion events inside menubuttons, and
# also outside menubuttons when a menubutton has a grab (e.g. when a
# menu selection operation is in progress).
#
# Arguments:
# w -			The name of the menubutton widget.
# upDown - 		"down" means button 1 is pressed, "up" means
#			it isn't.
# rootx, rooty -	Coordinates of mouse, in (virtual?) root window.

proc ::tk::MbMotion {w upDown rootx rooty} {
    variable ::tk::Priv

    if {[string equal $Priv(inMenubutton) $w]} {
	return
    }
    set new [winfo containing $rootx $rooty]
    if {[string compare $new $Priv(inMenubutton)] \
	    && ([string equal $new ""] \
	    || [string equal [winfo toplevel $new] [winfo toplevel $w]])} {
	if {[string compare $Priv(inMenubutton) ""]} {
	    MbLeave $Priv(inMenubutton)
	}
	if {[string compare $new ""] \
		&& [string equal [winfo class $new] "Menubutton"] \
		&& ([$new cget -indicatoron] == 0) \
		&& ([$w cget -indicatoron] == 0)} {
	    if {[string equal $upDown "down"]} {
		MbPost $new $rootx $rooty
	    } else {
		MbEnter $new
	    }
	}
    }
}

# ::tk::MbButtonUp --
# This procedure is invoked to handle button 1 releases for menubuttons.
# If the release happens inside the menubutton then leave its menu
# posted with element 0 activated.  Otherwise, unpost the menu.
#
# Arguments:
# w -			The name of the menubutton widget.

proc ::tk::MbButtonUp w {
    variable ::tk::Priv
    global tcl_platform

    set menu [$w cget -menu]
    set tearoff [expr {[tk windowingsystem] eq "x11" || \
	    ($menu ne "" && [$menu cget -type] eq "tearoff")}]
    if {($tearoff != 0) && $Priv(postedMb) eq $w \
	    && $Priv(inMenubutton) eq $w} {
	MenuFirstEntry [$Priv(postedMb) cget -menu]
    } else {
	MenuUnpost {}
    }
}

# ::tk::MenuMotion --
# This procedure is called to handle mouse motion events for menus.
# It does two things.  First, it resets the active element in the
# menu, if the mouse is over the menu.  Second, if a mouse button
# is down, it posts and unposts cascade entries to match the mouse
# position.
#
# Arguments:
# menu -		The menu window.
# x -			The x position of the mouse.
# y -			The y position of the mouse.
# state -		Modifier state (tells whether buttons are down).

proc ::tk::MenuMotion {menu x y state} {
    variable ::tk::Priv
    if {[string equal $menu $Priv(window)]} {
	if {[string equal [$menu cget -type] "menubar"]} {
	    if {[info exists Priv(focus)] && \
		    [string compare $menu $Priv(focus)]} {
		$menu activate @@$x,$y
		GenerateMenuSelect $menu
	    }
	} else {
	    $menu activate @@$x,$y
	    GenerateMenuSelect $menu
	}
    }
    if {($state & 0x1f00) != 0} {
	$menu postcascade active
    }
}

# ::tk::MenuButtonDown --
# Handles button presses in menus.  There are a couple of tricky things
# here:
# 1. Change the posted cascade entry (if any) to match the mouse position.
# 2. If there is a posted menubutton, must grab to the menubutton;  this
#    overrrides the implicit grab on button press, so that the menu
#    button can track mouse motions over other menubuttons and change
#    the posted menu.
# 3. If there's no posted menubutton (e.g. because we're a torn-off menu
#    or one of its descendants) must grab to the top-level menu so that
#    we can track mouse motions across the entire menu hierarchy.
#
# Arguments:
# menu -		The menu window.

proc ::tk::MenuButtonDown menu {
    variable ::tk::Priv
    global tcl_platform

    if {![winfo viewable $menu]} {
        return
    }
    $menu postcascade active
    if {[string compare $Priv(postedMb) ""] && \
	    [winfo viewable $Priv(postedMb)]} {
	grab -global $Priv(postedMb)
    } else {
	while {[string equal [$menu cget -type] "normal"] \
		&& [string equal [winfo class [winfo parent $menu]] "Menu"] \
		&& [winfo ismapped [winfo parent $menu]]} {
	    set menu [winfo parent $menu]
	}

	if {[string equal $Priv(menuBar) {}]} {
	    set Priv(menuBar) $menu
	    set Priv(cursor) [$menu cget -cursor]
	    $menu configure -cursor arrow
        }

	# Don't update grab information if the grab window isn't changing.
	# Otherwise, we'll get an error when we unpost the menus and
	# restore the grab, since the old grab window will not be viewable
	# anymore.

	if {[string compare $menu [grab current $menu]]} {
	    SaveGrabInfo $menu
	}

	# Must re-grab even if the grab window hasn't changed, in order
	# to release the implicit grab from the button press.

	if {[string equal [tk windowingsystem] "x11"]} {
	    grab -global $menu
	}
    }
}

# ::tk::MenuLeave --
# This procedure is invoked to handle Leave events for a menu.  It
# deactivates everything unless the active element is a cascade element
# and the mouse is now over the submenu.
#
# Arguments:
# menu -		The menu window.
# rootx, rooty -	Root coordinates of mouse.
# state -		Modifier state.

proc ::tk::MenuLeave {menu rootx rooty state} {
    variable ::tk::Priv
    set Priv(window) {}
    if {[string equal [$menu index active] "none"]} {
	return
    }
    if {[string equal [$menu type active] "cascade"]
          && [string equal [winfo containing $rootx $rooty] \
                  [$menu entrycget active -menu]]} {
	return
    }
    $menu activate none
    GenerateMenuSelect $menu
}

# ::tk::MenuInvoke --
# This procedure is invoked when button 1 is released over a menu.
# It invokes the appropriate menu action and unposts the menu if
# it came from a menubutton.
#
# Arguments:
# w -			Name of the menu widget.
# buttonRelease -	1 means this procedure is called because of
#			a button release;  0 means because of keystroke.

proc ::tk::MenuInvoke {w buttonRelease} {
    variable ::tk::Priv

    if {$buttonRelease && [string equal $Priv(window) {}]} {
	# Mouse was pressed over a menu without a menu button, then
	# dragged off the menu (possibly with a cascade posted) and
	# released.  Unpost everything and quit.

	$w postcascade none
	$w activate none
	event generate $w <<MenuSelect>>
	MenuUnpost $w
	return
    }
    if {[string equal [$w type active] "cascade"]} {
	$w postcascade active
	set menu [$w entrycget active -menu]
	MenuFirstEntry $menu
    } elseif {[string equal [$w type active] "tearoff"]} {
	::tk::TearOffMenu $w
	MenuUnpost $w
    } elseif {[string equal [$w cget -type] "menubar"]} {
	$w postcascade none
	set active [$w index active]
	set isCascade [string equal [$w type $active] "cascade"]

	# Only de-activate the active item if it's a cascade; this prevents
	# the annoying "activation flicker" you otherwise get with 
	# checkbuttons/commands/etc. on menubars

	if { $isCascade } {
	    $w activate none
	    event generate $w <<MenuSelect>>
	}

	MenuUnpost $w

	# If the active item is not a cascade, invoke it.  This enables
	# the use of checkbuttons/commands/etc. on menubars (which is legal,
	# but not recommended)

	if { !$isCascade } {
	    uplevel #0 [list $w invoke $active]
	}
    } else {
	MenuUnpost $w
	uplevel #0 [list $w invoke active]
    }
}

# ::tk::MenuEscape --
# This procedure is invoked for the Cancel (or Escape) key.  It unposts
# the given menu and, if it is the top-level menu for a menu button,
# unposts the menu button as well.
#
# Arguments:
# menu -		Name of the menu window.

proc ::tk::MenuEscape menu {
    set parent [winfo parent $menu]
    if {[string compare [winfo class $parent] "Menu"]} {
	MenuUnpost $menu
    } elseif {[string equal [$parent cget -type] "menubar"]} {
	MenuUnpost $menu
	RestoreOldGrab
    } else {
	MenuNextMenu $menu left
    }
}

# The following routines handle arrow keys. Arrow keys behave
# differently depending on whether the menu is a menu bar or not.

proc ::tk::MenuUpArrow {menu} {
    if {[string equal [$menu cget -type] "menubar"]} {
	MenuNextMenu $menu left
    } else {
	MenuNextEntry $menu -1
    }
}

proc ::tk::MenuDownArrow {menu} {
    if {[string equal [$menu cget -type] "menubar"]} {
	MenuNextMenu $menu right
    } else {
	MenuNextEntry $menu 1
    }
}

proc ::tk::MenuLeftArrow {menu} {
    if {[string equal [$menu cget -type] "menubar"]} {
	MenuNextEntry $menu -1
    } else {
	MenuNextMenu $menu left
    }
}

proc ::tk::MenuRightArrow {menu} {
    if {[string equal [$menu cget -type] "menubar"]} {
	MenuNextEntry $menu 1
    } else {
	MenuNextMenu $menu right
    }
}

# ::tk::MenuNextMenu --
# This procedure is invoked to handle "left" and "right" traversal
# motions in menus.  It traverses to the next menu in a menu bar,
# or into or out of a cascaded menu.
#
# Arguments:
# menu -		The menu that received the keyboard
#			event.
# direction -		Direction in which to move: "left" or "right"

proc ::tk::MenuNextMenu {menu direction} {
    variable ::tk::Priv

    # First handle traversals into and out of cascaded menus.

    if {[string equal $direction "right"]} {
	set count 1
	set parent [winfo parent $menu]
	set class [winfo class $parent]
	if {[string equal [$menu type active] "cascade"]} {
	    $menu postcascade active
	    set m2 [$menu entrycget active -menu]
	    if {[string compare $m2 ""]} {
		MenuFirstEntry $m2
	    }
	    return
	} else {
	    set parent [winfo parent $menu]
	    while {[string compare $parent "."]} {
		if {[string equal [winfo class $parent] "Menu"] \
			&& [string equal [$parent cget -type] "menubar"]} {
		    tk_menuSetFocus $parent
		    MenuNextEntry $parent 1
		    return
		}
		set parent [winfo parent $parent]
	    }
	}
    } else {
	set count -1
	set m2 [winfo parent $menu]
	if {[string equal [winfo class $m2] "Menu"]} {
	    $menu activate none
	    GenerateMenuSelect $menu
	    tk_menuSetFocus $m2

	    $m2 postcascade none

	    if {[string compare [$m2 cget -type] "menubar"]} {
		return
	    }
	}
    }

    # Can't traverse into or out of a cascaded menu.  Go to the next
    # or previous menubutton, if that makes sense.

    set m2 [winfo parent $menu]
    if {[string equal [winfo class $m2] "Menu"]} {
	if {[string equal [$m2 cget -type] "menubar"]} {
	    tk_menuSetFocus $m2
	    MenuNextEntry $m2 -1
	    return
	}
    }

    set w $Priv(postedMb)
    if {[string equal $w ""]} {
	return
    }
    set buttons [winfo children [winfo parent $w]]
    set length [llength $buttons]
    set i [expr {[lsearch -exact $buttons $w] + $count}]
    while {1} {
	while {$i < 0} {
	    incr i $length
	}
	while {$i >= $length} {
	    incr i -$length
	}
	set mb [lindex $buttons $i]
	if {[string equal [winfo class $mb] "Menubutton"] \
		&& [string compare [$mb cget -state] "disabled"] \
		&& [string compare [$mb cget -menu] ""] \
		&& [string compare [[$mb cget -menu] index last] "none"]} {
	    break
	}
	if {[string equal $mb $w]} {
	    return
	}
	incr i $count
    }
    MbPost $mb
    MenuFirstEntry [$mb cget -menu]
}

# ::tk::MenuNextEntry --
# Activate the next higher or lower entry in the posted menu,
# wrapping around at the ends.  Disabled entries are skipped.
#
# Arguments:
# menu -			Menu window that received the keystroke.
# count -			1 means go to the next lower entry,
#				-1 means go to the next higher entry.

proc ::tk::MenuNextEntry {menu count} {

    if {[string equal [$menu index last] "none"]} {
	return
    }
    set length [expr {[$menu index last]+1}]
    set quitAfter $length
    set active [$menu index active]
    if {[string equal $active "none"]} {
	set i 0
    } else {
	set i [expr {$active + $count}]
    }
    while {1} {
	if {$quitAfter <= 0} {
	    # We've tried every entry in the menu.  Either there are
	    # none, or they're all disabled.  Just give up.

	    return
	}
	while {$i < 0} {
	    incr i $length
	}
	while {$i >= $length} {
	    incr i -$length
	}
	if {[catch {$menu entrycget $i -state} state] == 0} {
	    if {$state ne "disabled" && \
		    ($i!=0 || [$menu cget -type] ne "tearoff" \
		    || [$menu type 0] ne "tearoff")} {
		break
	    }
	}
	if {$i == $active} {
	    return
	}
	incr i $count
	incr quitAfter -1
    }
    $menu activate $i
    GenerateMenuSelect $menu

    if {[string equal [$menu type $i] "cascade"] \
	    && [string equal [$menu cget -type] "menubar"]} {
	set cascade [$menu entrycget $i -menu]
	if {[string compare $cascade ""]} {
	    # Here we auto-post a cascade.  This is necessary when
	    # we traverse left/right in the menubar, but undesirable when
	    # we traverse up/down in a menu.
	    $menu postcascade $i
	    MenuFirstEntry $cascade
	}
    }
}

# ::tk::MenuFind --
# This procedure searches the entire window hierarchy under w for
# a menubutton that isn't disabled and whose underlined character
# is "char" or an entry in a menubar that isn't disabled and whose
# underlined character is "char".
# It returns the name of that window, if found, or an
# empty string if no matching window was found.  If "char" is an
# empty string then the procedure returns the name of the first
# menubutton found that isn't disabled.
#
# Arguments:
# w -				Name of window where key was typed.
# char -			Underlined character to search for;
#				may be either upper or lower case, and
#				will match either upper or lower case.

proc ::tk::MenuFind {w char} {
    set char [string tolower $char]
    set windowlist [winfo child $w]

    foreach child $windowlist {
	# Don't descend into other toplevels.
        if {[string compare [winfo toplevel $w] [winfo toplevel $child]]} {
	    continue
	}
	if {[string equal [winfo class $child] "Menu"] && \
		[string equal [$child cget -type] "menubar"]} {
	    if {[string equal $char ""]} {
		return $child
	    }
	    set last [$child index last]
	    for {set i [$child cget -tearoff]} {$i <= $last} {incr i} {
		if {[string equal [$child type $i] "separator"]} {
		    continue
		}
		set char2 [string index [$child entrycget $i -label] \
			[$child entrycget $i -underline]]
		if {[string equal $char [string tolower $char2]] \
			|| [string equal $char ""]} {
		    if {[string compare [$child entrycget $i -state] "disabled"]} {
			return $child
		    }
		}
	    }
	}
    }

    foreach child $windowlist {
	# Don't descend into other toplevels.
        if {[string compare [winfo toplevel $w] [winfo toplevel $child]]} {
	    continue
	}
	switch [winfo class $child] {
	    Menubutton {
		set char2 [string index [$child cget -text] \
			[$child cget -underline]]
		if {[string equal $char [string tolower $char2]] \
			|| [string equal $char ""]} {
		    if {[string compare [$child cget -state] "disabled"]} {
			return $child
		    }
		}
	    }

	    default {
		set match [MenuFind $child $char]
		if {[string compare $match ""]} {
		    return $match
		}
	    }
	}
    }
    return {}
}

# ::tk::TraverseToMenu --
# This procedure implements keyboard traversal of menus.  Given an
# ASCII character "char", it looks for a menubutton with that character
# underlined.  If one is found, it posts the menubutton's menu
#
# Arguments:
# w -				Window in which the key was typed (selects
#				a toplevel window).
# char -			Character that selects a menu.  The case
#				is ignored.  If an empty string, nothing
#				happens.

proc ::tk::TraverseToMenu {w char} {
    variable ::tk::Priv
    if {[string equal $char ""]} {
	return
    }
    while {[string equal [winfo class $w] "Menu"]} {
	if {[string compare [$w cget -type] "menubar"] \
		&& [string equal $Priv(postedMb) ""]} {
	    return
	}
	if {[string equal [$w cget -type] "menubar"]} {
	    break
	}
	set w [winfo parent $w]
    }
    set w [MenuFind [winfo toplevel $w] $char]
    if {[string compare $w ""]} {
	if {[string equal [winfo class $w] "Menu"]} {
	    tk_menuSetFocus $w
	    set Priv(window) $w
	    SaveGrabInfo $w
	    grab -global $w
	    TraverseWithinMenu $w $char
	} else {
	    MbPost $w
	    MenuFirstEntry [$w cget -menu]
	}
    }
}

# ::tk::FirstMenu --
# This procedure traverses to the first menubutton in the toplevel
# for a given window, and posts that menubutton's menu.
#
# Arguments:
# w -				Name of a window.  Selects which toplevel
#				to search for menubuttons.

proc ::tk::FirstMenu w {
    variable ::tk::Priv
    set w [MenuFind [winfo toplevel $w] ""]
    if {[string compare $w ""]} {
	if {[string equal [winfo class $w] "Menu"]} {
	    tk_menuSetFocus $w
	    set Priv(window) $w
	    SaveGrabInfo $w
	    grab -global $w
	    MenuFirstEntry $w
	} else {
	    MbPost $w
	    MenuFirstEntry [$w cget -menu]
	}
    }
}

# ::tk::TraverseWithinMenu
# This procedure implements keyboard traversal within a menu.  It
# searches for an entry in the menu that has "char" underlined.  If
# such an entry is found, it is invoked and the menu is unposted.
#
# Arguments:
# w -				The name of the menu widget.
# char -			The character to look for;  case is
#				ignored.  If the string is empty then
#				nothing happens.

proc ::tk::TraverseWithinMenu {w char} {
    if {[string equal $char ""]} {
	return
    }
    set char [string tolower $char]
    set last [$w index last]
    if {[string equal $last "none"]} {
	return
    }
    for {set i 0} {$i <= $last} {incr i} {
	if {[catch {set char2 [string index \
		[$w entrycget $i -label] [$w entrycget $i -underline]]}]} {
	    continue
	}
	if {[string equal $char [string tolower $char2]]} {
	    if {[string equal [$w type $i] "cascade"]} {
		$w activate $i
		$w postcascade active
		event generate $w <<MenuSelect>>
		set m2 [$w entrycget $i -menu]
		if {[string compare $m2 ""]} {
		    MenuFirstEntry $m2
		}
	    } else {
		MenuUnpost $w
		uplevel #0 [list $w invoke $i]
	    }
	    return
	}
    }
}

# ::tk::MenuFirstEntry --
# Given a menu, this procedure finds the first entry that isn't
# disabled or a tear-off or separator, and activates that entry.
# However, if there is already an active entry in the menu (e.g.,
# because of a previous call to tk::PostOverPoint) then the active
# entry isn't changed.  This procedure also sets the input focus
# to the menu.
#
# Arguments:
# menu -		Name of the menu window (possibly empty).

proc ::tk::MenuFirstEntry menu {
    if {[string equal $menu ""]} {
	return
    }
    tk_menuSetFocus $menu
    if {[string compare [$menu index active] "none"]} {
	return
    }
    set last [$menu index last]
    if {[string equal $last "none"]} {
	return
    }
    for {set i 0} {$i <= $last} {incr i} {
	if {([catch {set state [$menu entrycget $i -state]}] == 0) \
		&& [string compare $state "disabled"] \
		&& [string compare [$menu type $i] "tearoff"]} {
	    $menu activate $i
	    GenerateMenuSelect $menu
	    # Only post the cascade if the current menu is a menubar;
	    # otherwise, if the first entry of the cascade is a cascade,
	    # we can get an annoying cascading effect resulting in a bunch of
	    # menus getting posted (bug 676)
	    if {[string equal [$menu type $i] "cascade"] && \
		[string equal [$menu cget -type] "menubar"]} {
		set cascade [$menu entrycget $i -menu]
		if {[string compare $cascade ""]} {
		    $menu postcascade $i
		    MenuFirstEntry $cascade
		}
	    }
	    return
	}
    }
}

# ::tk::MenuFindName --
# Given a menu and a text string, return the index of the menu entry
# that displays the string as its label.  If there is no such entry,
# return an empty string.  This procedure is tricky because some names
# like "active" have a special meaning in menu commands, so we can't
# always use the "index" widget command.
#
# Arguments:
# menu -		Name of the menu widget.
# s -			String to look for.

proc ::tk::MenuFindName {menu s} {
    set i ""
    if {![regexp {^active$|^last$|^none$|^[0-9]|^@@} $s]} {
	catch {set i [$menu index $s]}
	return $i
    }
    set last [$menu index last]
    if {[string equal $last "none"]} {
	return
    }
    for {set i 0} {$i <= $last} {incr i} {
	if {![catch {$menu entrycget $i -label} label]} {
	    if {[string equal $label $s]} {
		return $i
	    }
	}
    }
    return ""
}

# ::tk::PostOverPoint --
# This procedure posts a given menu such that a given entry in the
# menu is centered over a given point in the root window.  It also
# activates the given entry.
#
# Arguments:
# menu -		Menu to post.
# x, y -		Root coordinates of point.
# entry -		Index of entry within menu to center over (x,y).
#			If omitted or specified as {}, then the menu's
#			upper-left corner goes at (x,y).

proc ::tk::PostOverPoint {menu x y {entry {}}}  {
    global tcl_platform
    
    if {[string compare $entry {}]} {
	if {$entry == [$menu index last]} {
	    incr y [expr {-([$menu yposition $entry] \
		    + [winfo reqheight $menu])/2}]
	} else {
	    incr y [expr {-([$menu yposition $entry] \
		    + [$menu yposition [expr {$entry+1}]])/2}]
	}
	incr x [expr {-[winfo reqwidth $menu]/2}]
    }
    if {$tcl_platform(platform) == "windows"} {
	# We need to fix some problems with menu posting on Windows.
	set yoffset [expr {[winfo screenheight $menu] \
		- $y - [winfo reqheight $menu]}]
	if {$yoffset < 0} {
	    # The bottom of the menu is offscreen, so adjust upwards
	    incr y $yoffset
	    if {$y < 0} { set y 0 }
	}
	# If we're off the top of the screen (either because we were
	# originally or because we just adjusted too far upwards),
	# then make the menu popup on the top edge.
	if {$y < 0} {
	    set y 0
	}
    }
    $menu post $x $y
    if {$entry ne "" && [$menu entrycget $entry -state] ne "disabled"} {
	$menu activate $entry
	GenerateMenuSelect $menu
    }
}

# ::tk::SaveGrabInfo --
# Sets the variables tk::Priv(oldGrab) and tk::Priv(grabStatus) to record
# the state of any existing grab on the w's display.
#
# Arguments:
# w -			Name of a window;  used to select the display
#			whose grab information is to be recorded.

proc tk::SaveGrabInfo w {
    variable ::tk::Priv
    set Priv(oldGrab) [grab current $w]
    if {$Priv(oldGrab) ne ""} {
	set Priv(grabStatus) [grab status $Priv(oldGrab)]
    }
}

# ::tk::RestoreOldGrab --
# Restores the grab to what it was before TkSaveGrabInfo was called.
#

proc ::tk::RestoreOldGrab {} {
    variable ::tk::Priv

    if {$Priv(oldGrab) ne ""} {
    	# Be careful restoring the old grab, since it's window may not
	# be visible anymore.

	catch {
          if {[string equal $Priv(grabStatus) "global"]} {
		grab set -global $Priv(oldGrab)
	    } else {
		grab set $Priv(oldGrab)
	    }
	}
	set Priv(oldGrab) ""
    }
}

proc ::tk_menuSetFocus {menu} {
    variable ::tk::Priv
    if {![info exists Priv(focus)] || [string equal $Priv(focus) {}]} {
	set Priv(focus) [focus]
    }
    focus $menu
}
    
proc ::tk::GenerateMenuSelect {menu} {
    variable ::tk::Priv

    if {[string equal $Priv(activeMenu) $menu] \
          && [string equal $Priv(activeItem) [$menu index active]]} {
	return
    }

    set Priv(activeMenu) $menu
    set Priv(activeItem) [$menu index active]
    event generate $menu <<MenuSelect>>
}

# ::tk_popup --
# This procedure pops up a menu and sets things up for traversing
# the menu and its submenus.
#
# Arguments:
# menu -		Name of the menu to be popped up.
# x, y -		Root coordinates at which to pop up the
#			menu.
# entry -		Index of a menu entry to center over (x,y).
#			If omitted or specified as {}, then menu's
#			upper-left corner goes at (x,y).

proc ::tk_popup {menu x y {entry {}}} {
    variable ::tk::Priv
    global tcl_platform
    if {$Priv(popup) ne "" || $Priv(postedMb) ne ""} {
	tk::MenuUnpost {}
    }
    tk::PostOverPoint $menu $x $y $entry
    if {[tk windowingsystem] eq "x11" && [winfo viewable $menu]} {
        tk::SaveGrabInfo $menu
	grab -global $menu
	set Priv(popup) $menu
	tk_menuSetFocus $menu
    }
}
@


1.4
log
@touched all sources to ease next import
@
text
@d7 1
a7 1
# RCS: @@(#) $Id: menu.tcl,v 1.7.6.2 2000/09/26 16:08:43 spolk Exp $
d18 1
a18 1
# Elements of tkPriv that are used in this file:
d23 2
a24 2
# grabGlobal -		Used in conjunction with tkPriv(oldGrab):  if
#			tkPriv(oldGrab) is non-empty, then tkPriv(grabGlobal)
d65 1
a65 1
#    tkPriv(postedMb) identifies the posted menubutton.
d67 1
a67 1
#    tkPriv(postedMb) is empty, and menu's type is "tearoff".
d69 2
a70 2
#    style tkPriv(postedMb) identifies the posted menubutton.
# 4. As a popup menu.  In this style tkPriv(postedMb) is empty and
d72 1
a72 1
# 5. As a pulldown from a menubar. The variable tkPriv(menubar) has
d87 1
a87 1
    tkMbEnter %W
d90 1
a90 1
    tkMbLeave %W
d93 2
a94 2
    if {[string compare $tkPriv(inMenubutton) ""]} {
	tkMbPost $tkPriv(inMenubutton) %X %Y
d98 1
a98 1
    tkMbMotion %W up %X %Y
d101 1
a101 1
    tkMbMotion %W down %X %Y
d104 1
a104 1
    tkMbButtonUp %W
d107 2
a108 2
    tkMbPost %W
    tkMenuFirstEntry [%W cget -menu]
d121 4
a124 4
    set tkPriv(window) %W
    if {[string equal [%W cget -type] "tearoff"]} {
	if {[string compare "%m" "NotifyUngrab"]} {
	    if {[string equal $tcl_platform(platform) "unix"]} {
d129 1
a129 1
    tkMenuMotion %W %x %y %s
d133 1
a133 1
    tkMenuLeave %W %X %Y %s
d136 1
a136 1
    tkMenuMotion %W %x %y %s
d139 1
a139 1
    tkMenuButtonDown %W
d142 1
a142 1
   tkMenuInvoke %W 1
d145 1
a145 1
    tkMenuInvoke %W 0
d148 1
a148 1
    tkMenuInvoke %W 0
d151 1
a151 1
    tkMenuEscape %W
d154 1
a154 1
    tkMenuLeftArrow %W
d157 1
a157 1
    tkMenuRightArrow %W
d160 1
a160 1
    tkMenuUpArrow %W
d163 1
a163 1
    tkMenuDownArrow %W
d166 1
a166 1
    tkTraverseWithinMenu %W %A
d172 1
a172 1
if {[string equal $tcl_platform(platform) "unix"]} {
d174 1
a174 1
	tkTraverseToMenu %W %A
d178 1
a178 1
	tkFirstMenu %W
d182 1
a182 1
	tkTraverseToMenu %W %A
d186 1
a186 1
	tkFirstMenu %W
d190 1
a190 1
# tkMbEnter --
d194 1
a194 1
# The procedure tkMbB1Enter is invoked if the button is down.
d199 2
a200 2
proc tkMbEnter w {
    global tkPriv
d202 2
a203 2
    if {[string compare $tkPriv(inMenubutton) ""]} {
	tkMbLeave $tkPriv(inMenubutton)
d205 1
a205 1
    set tkPriv(inMenubutton) $w
d211 1
a211 1
# tkMbLeave --
d218 2
a219 2
proc tkMbLeave w {
    global tkPriv
d221 1
a221 1
    set tkPriv(inMenubutton) {}
d230 1
a230 1
# tkMbPost --
d242 3
a244 2
proc tkMbPost {w {x {}} {y {}}} {
    global tkPriv errorInfo
d247 1
a247 2
    if {[string equal [$w cget -state] "disabled"] || \
	    [string equal $w $tkPriv(postedMb)]} {
d254 2
a255 2
    set tearoff [expr {[string equal $tcl_platform(platform) "unix"] \
	    || [string equal [$menu cget -type] "tearoff"]}]
d259 1
a259 1
    set cur $tkPriv(postedMb)
d261 1
a261 1
	tkMenuUnpost {}
d263 2
a264 2
    set tkPriv(cursor) [$w cget -cursor]
    set tkPriv(relief) [$w cget -relief]
d268 2
a269 2
    set tkPriv(postedMb) $w
    set tkPriv(focus) [focus]
d271 1
a271 1
    tkGenerateMenuSelect $menu
d283 1
a283 1
    	    	$menu post $x $y
d288 1
a288 1
    	    	$menu post $x $y
d293 1
a293 1
    	    	set entry [tkMenuFindName $menu [$w cget -text]]
d303 3
a305 2
    	    	$menu post $x $y
		if {[string compare $entry {}] && [string compare [$menu entrycget $entry -state] "disabled"]} {
d307 1
a307 1
		    tkGenerateMenuSelect $menu
d313 1
a313 1
    	    	set entry [tkMenuFindName $menu [$w cget -text]]
d323 3
a325 2
    	    	$menu post $x $y
		if {[string compare $entry {}] && [string compare [$menu entrycget $entry -state] "disabled"]} {
d327 1
a327 1
		    tkGenerateMenuSelect $menu
d336 1
a336 1
	            tkPostOverPoint $menu $x $y [tkMenuFindName $menu [$w cget -text]]
d338 1
a338 1
	    	    $menu post [winfo rootx $w] [expr {[winfo rooty $w]+[winfo height $w]}]
d347 1
a347 1
	tkMenuUnpost {}
d352 1
a352 1
    set tkPriv(tearoff) $tearoff
d356 1
a356 1
	    tkSaveGrabInfo $w
d362 1
a362 1
# tkMenuUnpost --
d378 1
a378 1
proc tkMenuUnpost menu {
d380 2
a381 2
    global tkPriv
    set mb $tkPriv(postedMb)
d387 2
a388 2
    catch {focus $tkPriv(focus)}
    set tkPriv(focus) ""
d397 6
a402 6
	    set tkPriv(postedMb) {}
	    $mb configure -cursor $tkPriv(cursor)
	    $mb configure -relief $tkPriv(relief)
	} elseif {[string compare $tkPriv(popup) ""]} {
	    $tkPriv(popup) unpost
	    set tkPriv(popup) {}
d418 1
a418 1
		tkGenerateMenuSelect $parent
d432 1
a432 1
    if {($tkPriv(tearoff) != 0) || [string compare $tkPriv(menuBar) ""]} {
d441 4
a444 4
	tkRestoreOldGrab
	if {[string compare $tkPriv(menuBar) ""]} {
	    $tkPriv(menuBar) configure -cursor $tkPriv(cursor)
	    set tkPriv(menuBar) {}
d446 2
a447 2
	if {[string compare $tcl_platform(platform) "unix"]} {
	    set tkPriv(tearoff) 0
d452 1
a452 1
# tkMbMotion --
d463 2
a464 2
proc tkMbMotion {w upDown rootx rooty} {
    global tkPriv
d466 1
a466 1
    if {[string equal $tkPriv(inMenubutton) $w]} {
d470 1
a470 1
    if {[string compare $new $tkPriv(inMenubutton)] \
d473 2
a474 2
	if {[string compare $tkPriv(inMenubutton) ""]} {
	    tkMbLeave $tkPriv(inMenubutton)
d481 1
a481 1
		tkMbPost $new $rootx $rooty
d483 1
a483 1
		tkMbEnter $new
d489 1
a489 1
# tkMbButtonUp --
d497 2
a498 2
proc tkMbButtonUp w {
    global tkPriv
d502 5
a506 6
    set tearoff [expr {[string equal $tcl_platform(platform) "unix"] || \
	    ([string compare $menu {}] && \
	    [string equal [$menu cget -type] "tearoff"])}]
    if {($tearoff != 0) && [string equal $tkPriv(postedMb) $w] \
	    && [string equal $tkPriv(inMenubutton) $w]} {
	tkMenuFirstEntry [$tkPriv(postedMb) cget -menu]
d508 1
a508 1
	tkMenuUnpost {}
d512 1
a512 1
# tkMenuMotion --
d525 3
a527 3
proc tkMenuMotion {menu x y state} {
    global tkPriv
    if {[string equal $menu $tkPriv(window)]} {
d529 2
a530 2
	    if {[info exists tkPriv(focus)] && \
		    [string compare $menu $tkPriv(focus)]} {
d532 1
a532 1
		tkGenerateMenuSelect $menu
d536 1
a536 1
	    tkGenerateMenuSelect $menu
d544 1
a544 1
# tkMenuButtonDown --
d559 2
a560 2
proc tkMenuButtonDown menu {
    global tkPriv
d567 3
a569 3
    if {[string compare $tkPriv(postedMb) ""] && \
	    [winfo viewable $tkPriv(postedMb)]} {
	grab -global $tkPriv(postedMb)
d577 3
a579 3
	if {[string equal $tkPriv(menuBar) {}]} {
	    set tkPriv(menuBar) $menu
	    set tkPriv(cursor) [$menu cget -cursor]
d589 1
a589 1
	    tkSaveGrabInfo $menu
d595 1
a595 1
	if {[string equal $tcl_platform(platform) "unix"]} {
d601 1
a601 1
# tkMenuLeave --
d611 3
a613 3
proc tkMenuLeave {menu rootx rooty state} {
    global tkPriv
    set tkPriv(window) {}
d623 1
a623 1
    tkGenerateMenuSelect $menu
d626 1
a626 1
# tkMenuInvoke --
d636 2
a637 2
proc tkMenuInvoke {w buttonRelease} {
    global tkPriv
d639 1
a639 1
    if {$buttonRelease && [string equal $tkPriv(window) {}]} {
d647 1
a647 1
	tkMenuUnpost $w
d653 1
a653 1
	tkMenuFirstEntry $menu
d655 2
a656 2
	tkTearOffMenu $w
	tkMenuUnpost $w
d671 1
a671 1
	tkMenuUnpost $w
d681 1
a681 1
	tkMenuUnpost $w
d686 1
a686 1
# tkMenuEscape --
d694 1
a694 1
proc tkMenuEscape menu {
d697 1
a697 1
	tkMenuUnpost $menu
d699 2
a700 2
	tkMenuUnpost $menu
	tkRestoreOldGrab
d702 1
a702 1
	tkMenuNextMenu $menu left
d709 1
a709 1
proc tkMenuUpArrow {menu} {
d711 1
a711 1
	tkMenuNextMenu $menu left
d713 1
a713 1
	tkMenuNextEntry $menu -1
d717 1
a717 1
proc tkMenuDownArrow {menu} {
d719 1
a719 1
	tkMenuNextMenu $menu right
d721 1
a721 1
	tkMenuNextEntry $menu 1
d725 1
a725 1
proc tkMenuLeftArrow {menu} {
d727 1
a727 1
	tkMenuNextEntry $menu -1
d729 1
a729 1
	tkMenuNextMenu $menu left
d733 1
a733 1
proc tkMenuRightArrow {menu} {
d735 1
a735 1
	tkMenuNextEntry $menu 1
d737 1
a737 1
	tkMenuNextMenu $menu right
d741 1
a741 1
# tkMenuNextMenu --
d751 2
a752 2
proc tkMenuNextMenu {menu direction} {
    global tkPriv
d764 1
a764 1
		tkMenuFirstEntry $m2
d773 1
a773 1
		    tkMenuNextEntry $parent 1
d783 6
a789 9
		$menu activate none
		tkGenerateMenuSelect $menu
		tk_menuSetFocus $m2
		
		# This code unposts any posted submenu in the parent.
		
		set tmp [$m2 index active]
		$m2 activate none
		$m2 activate $tmp
d802 1
a802 1
	    tkMenuNextEntry $m2 -1
d807 1
a807 1
    set w $tkPriv(postedMb)
d833 2
a834 2
    tkMbPost $mb
    tkMenuFirstEntry [$mb cget -menu]
d837 1
a837 1
# tkMenuNextEntry --
d846 1
a846 2
proc tkMenuNextEntry {menu count} {
    global tkPriv
d873 3
a875 1
	    if {[string compare $state "disabled"]} {
d886 4
a889 2
    tkGenerateMenuSelect $menu
    if {[string equal [$menu type $i] "cascade"]} {
d896 1
a896 1
	    tkMenuFirstEntry $cascade
d901 1
a901 1
# tkMenuFind --
d917 1
a917 2
proc tkMenuFind {w char} {
    global tkPriv
d923 1
a923 2
        if {[string compare [winfo toplevel [focus]] \
		[winfo toplevel $child]]} {
d950 1
a950 2
        if {[string compare [winfo toplevel [focus]] \
		[winfo toplevel $child]]} {
d966 1
a966 1
		set match [tkMenuFind $child $char]
d976 1
a976 1
# tkTraverseToMenu --
d988 2
a989 2
proc tkTraverseToMenu {w char} {
    global tkPriv
d995 1
a995 1
		&& [string equal $tkPriv(postedMb) ""]} {
d1003 1
a1003 1
    set w [tkMenuFind [winfo toplevel $w] $char]
d1007 2
a1008 2
	    set tkPriv(window) $w
	    tkSaveGrabInfo $w
d1010 1
a1010 1
	    tkTraverseWithinMenu $w $char
d1012 2
a1013 2
	    tkMbPost $w
	    tkMenuFirstEntry [$w cget -menu]
d1018 1
a1018 1
# tkFirstMenu --
d1026 3
a1028 2
proc tkFirstMenu w {
    set w [tkMenuFind [winfo toplevel $w] ""]
d1032 2
a1033 2
	    set tkPriv(window) $w
	    tkSaveGrabInfo $w
d1035 1
a1035 1
	    tkMenuFirstEntry $w
d1037 2
a1038 2
	    tkMbPost $w
	    tkMenuFirstEntry [$w cget -menu]
d1043 1
a1043 1
# tkTraverseWithinMenu
d1054 1
a1054 1
proc tkTraverseWithinMenu {w char} {
d1075 1
a1075 1
		    tkMenuFirstEntry $m2
d1078 1
a1078 1
		tkMenuUnpost $w
d1086 1
a1086 1
# tkMenuFirstEntry --
d1090 1
a1090 1
# because of a previous call to tkPostOverPoint) then the active
d1097 1
a1097 1
proc tkMenuFirstEntry menu {
d1114 1
a1114 1
	    tkGenerateMenuSelect $menu
d1124 1
a1124 1
		    tkMenuFirstEntry $cascade
d1132 1
a1132 1
# tkMenuFindName --
d1143 1
a1143 1
proc tkMenuFindName {menu s} {
d1163 1
a1163 1
# tkPostOverPoint --
d1175 1
a1175 1
proc tkPostOverPoint {menu x y {entry {}}}  {
d1188 16
d1205 1
a1205 2
    if {[string compare $entry {}] \
	    && [string compare [$menu entrycget $entry -state] "disabled"]} {
d1207 1
a1207 1
	tkGenerateMenuSelect $menu
d1211 2
a1212 2
# tkSaveGrabInfo --
# Sets the variables tkPriv(oldGrab) and tkPriv(grabStatus) to record
d1219 5
a1223 5
proc tkSaveGrabInfo w {
    global tkPriv
    set tkPriv(oldGrab) [grab current $w]
    if {[string compare $tkPriv(oldGrab) ""]} {
	set tkPriv(grabStatus) [grab status $tkPriv(oldGrab)]
d1227 1
a1227 1
# tkRestoreOldGrab --
d1231 2
a1232 4
proc tkRestoreOldGrab {} {
    global tkPriv

    if {[string compare $tkPriv(oldGrab) ""]} {
d1234 1
d1239 2
a1240 2
          if {[string equal $tkPriv(grabStatus) "global"]} {
		grab set -global $tkPriv(oldGrab)
d1242 1
a1242 1
		grab set $tkPriv(oldGrab)
d1245 1
a1245 1
	set tkPriv(oldGrab) ""
d1249 4
a1252 4
proc tk_menuSetFocus {menu} {
    global tkPriv
    if {![info exists tkPriv(focus)] || [string equal $tkPriv(focus) {}]} {
	set tkPriv(focus) [focus]
d1257 2
a1258 2
proc tkGenerateMenuSelect {menu} {
    global tkPriv
d1260 2
a1261 2
    if {[string equal $tkPriv(activeMenu) $menu] \
          && [string equal $tkPriv(activeItem) [$menu index active]]} {
d1265 2
a1266 2
    set tkPriv(activeMenu) $menu
    set tkPriv(activeItem) [$menu index active]
d1270 1
a1270 1
# tk_popup --
d1282 2
a1283 2
proc tk_popup {menu x y {entry {}}} {
    global tkPriv
d1285 6
a1290 8
    if {[string compare $tkPriv(popup) ""] \
	    || [string compare $tkPriv(postedMb) ""]} {
	tkMenuUnpost {}
    }
    tkPostOverPoint $menu $x $y $entry
    if {[string equal $tcl_platform(platform) "unix"] \
	    && [winfo viewable $menu]} {
        tkSaveGrabInfo $menu
d1292 1
a1292 1
	set tkPriv(popup) $menu
a1295 2


@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
# SCCS: @@(#) menu.tcl 1.103 97/10/31 15:26:08
d11 1
d93 1
a93 1
    if {$tkPriv(inMenubutton) != ""} {
d122 3
a124 3
    if {[%W cget -type] == "tearoff"} {
	if {"%m" != "NotifyUngrab"} {
	    if {$tcl_platform(platform) == "unix"} {
d172 1
a172 1
if {$tcl_platform(platform) == "unix"} {
d202 1
a202 1
    if {$tkPriv(inMenubutton) != ""} {
d206 1
a206 1
    if {[$w cget -state] != "disabled"} {
d225 1
a225 1
    if {[$w cget -state] == "active"} {
d246 2
a247 1
    if {([$w cget -state] == "disabled") || ($w == $tkPriv(postedMb))} {
d251 1
a251 1
    if {$menu == ""} {
d254 2
a255 2
    set tearoff [expr {($tcl_platform(platform) == "unix") \
		     || ([$menu cget -type] == "tearoff")}]
d260 1
a260 1
    if {$cur != ""} {
d279 1
a279 1
    	 switch [$w cget -direction] {
d304 1
a304 1
    	    	if {($entry != {}) && ([$menu entrycget $entry -state] != "disabled")} {
d323 1
a323 1
    	    	if {($entry != {}) && ([$menu entrycget $entry -state] != "disabled")} {
d330 1
a330 1
	    	    if {$y == ""} {
d339 2
a340 2
    	 }
     } msg]} {
d353 4
a356 2
    	tkSaveGrabInfo $w
    	grab -global $w
d392 1
a392 1
	if {$mb != ""} {
d398 1
a398 1
	} elseif {$tkPriv(popup) != ""} {
d401 2
a402 2
	} elseif {(!([$menu cget -type] == "menubar")
		&& !([$menu cget -type] == "tearoff"))} {
d408 1
a408 1
	    while 1 {
d410 1
a410 1
		if {([winfo class $parent] != "Menu")
d418 2
a419 1
		if {($type == "menubar")|| ($type == "tearoff")} {
d424 1
a424 1
	    if {[$menu cget -type] != "menubar"} {
d430 1
a430 1
    if {($tkPriv(tearoff) != 0) || ($tkPriv(menuBar) != "")} {
d433 1
a433 2

	if {$menu != ""} {
d435 1
a435 1
	    if {$grab != ""} {
d440 1
a440 1
	if {$tkPriv(menuBar) != ""} {
d444 1
a444 1
	if {$tcl_platform(platform) != "unix"} {
d464 1
a464 1
    if {$tkPriv(inMenubutton) == $w} {
d468 4
a471 3
    if {($new != $tkPriv(inMenubutton)) && (($new == "")
	    || ([winfo toplevel $new] == [winfo toplevel $w]))} {
	if {$tkPriv(inMenubutton) != ""} {
d474 3
a476 2
	if {($new != "") && ([winfo class $new] == "Menubutton")
		&& ([$new cget -indicatoron] == 0)
d478 1
a478 1
	    if {$upDown == "down"} {
d499 6
a504 4
    set tearoff [expr {($tcl_platform(platform) == "unix") \
		     || ([[$w cget -menu] cget -type] == "tearoff")}]
    if {($tearoff != 0) && ($tkPriv(postedMb) == $w) 
	    && ($tkPriv(inMenubutton) == $w)} {
d526 2
a527 2
    if {$menu == $tkPriv(window)} {
	if {[$menu cget -type] == "menubar"} {
d529 1
a529 1
		    ([string compare $menu $tkPriv(focus)] != 0)} {
d561 4
d566 2
a567 1
    if {$tkPriv(postedMb) != ""} {
d570 2
a571 2
	while {([$menu cget -type] == "normal") 
		&& ([winfo class [winfo parent $menu]] == "Menu")
d576 1
a576 1
	if {$tkPriv(menuBar) == {}} {
d587 1
a587 1
	if {$menu != [grab current $menu]} {
d594 1
a594 1
	if {$tcl_platform(platform) == "unix"} {
d613 1
a613 1
    if {[$menu index active] == "none"} {
d616 3
a618 3
    if {([$menu type active] == "cascade")
	    && ([winfo containing $rootx $rooty]
	    == [$menu entrycget active -menu])} {
d638 1
a638 1
    if {$buttonRelease && ($tkPriv(window) == "")} {
d649 1
a649 1
    if {[$w type active] == "cascade"} {
d653 2
a654 1
    } elseif {[$w type active] == "tearoff"} {
d656 1
a656 2
	tkTearOffMenu $w
    } elseif {[$w cget -type] == "menubar"} {
d658 12
a669 2
	$w activate none
	event generate $w <<MenuSelect>>
d671 8
d695 1
a695 1
    if {([winfo class $parent] != "Menu")} {
d697 1
a697 1
    } elseif {([$parent cget -type] == "menubar")} {
d709 1
a709 1
    if {[$menu cget -type] == "menubar"} {
d717 1
a717 1
    if {[$menu cget -type] == "menubar"} {
d725 1
a725 1
    if {[$menu cget -type] == "menubar"} {
d733 1
a733 1
    if {[$menu cget -type] == "menubar"} {
d755 1
a755 1
    if {$direction == "right"} {
d759 1
a759 1
	if {[$menu type active] == "cascade"} {
d762 1
a762 1
	    if {$m2 != ""} {
d768 3
a770 3
	    while {($parent != ".")} {
		if {([winfo class $parent] == "Menu")
			&& ([$parent cget -type] == "menubar")} {
d781 2
a782 2
	if {[winfo class $m2] == "Menu"} {
	    if {[$m2 cget -type] != "menubar"} {
d801 2
a802 2
    if {[winfo class $m2] == "Menu"} {
	if {[$m2 cget -type] == "menubar"} {
d810 1
a810 1
    if {$w == ""} {
d816 1
a816 1
    while 1 {
d824 4
a827 4
	if {([winfo class $mb] == "Menubutton")
		&& ([$mb cget -state] != "disabled")
		&& ([$mb cget -menu] != "")
		&& ([[$mb cget -menu] index last] != "none")} {
d830 1
a830 1
	if {$mb == $w} {
d851 1
a851 1
    if {[$menu index last] == "none"} {
d857 1
a857 1
    if {$active == "none"} {
d862 1
a862 1
    while 1 {
d876 1
a876 1
	    if {$state != "disabled"} {
d888 1
a888 1
    if {[$menu type $i] == "cascade"} {
d890 4
a893 1
	if {[string compare $cascade ""] != 0} {
d922 20
a941 4
	switch [winfo class $child] {
	    Menu {
		if {[$child cget -type] == "menubar"} {
		    if {$char == ""} {
a943 14
		    set last [$child index last]
		    for {set i [$child cget -tearoff]} {$i <= $last} {incr i} {
			if {[$child type $i] == "separator"} {
			    continue
			}
			set char2 [string index [$child entrycget $i -label] \
				[$child entrycget $i -underline]]
			if {([string compare $char [string tolower $char2]] \
				== 0) || ($char == "")} {
			    if {[$child entrycget $i -state] != "disabled"} {
				return $child
			    }
			}
		    }
d950 5
d959 3
a961 3
		if {([string compare $char [string tolower $char2]] == 0)
			|| ($char == "")} {
		    if {[$child cget -state] != "disabled"} {
d969 1
a969 1
		if {$match != ""} {
d992 1
a992 1
    if {$char == ""} {
d995 3
a997 2
    while {[winfo class $w] == "Menu"} {
	if {([$w cget -type] != "menubar") && ($tkPriv(postedMb) == "")} {
d1000 1
a1000 1
	if {[$w cget -type] == "menubar"} {
d1006 2
a1007 2
    if {$w != ""} {
	if {[winfo class $w] == "Menu"} {
d1030 2
a1031 2
    if {$w != ""} {
	if {[winfo class $w] == "Menu"} {
d1056 1
a1056 1
    if {$char == ""} {
d1061 1
a1061 1
    if {$last == "none"} {
d1066 1
a1066 2
		[$w entrycget $i -label] \
		[$w entrycget $i -underline]]}]} {
d1069 2
a1070 2
	if {[string compare $char [string tolower $char2]] == 0} {
	    if {[$w type $i] == "cascade"} {
d1075 1
a1075 1
		if {$m2 != ""} {
d1099 1
a1099 1
    if {$menu == ""} {
d1103 1
a1103 1
    if {[$menu index active] != "none"} {
d1107 1
a1107 1
    if {$last == "none"} {
d1111 3
a1113 2
	if {([catch {set state [$menu entrycget $i -state]}] == 0)
		&& ($state != "disabled") && ([$menu type $i] != "tearoff")} {
d1116 6
a1121 1
	    if {[$menu type $i] == "cascade"} {
d1123 1
a1123 1
		if {[string compare $cascade ""] != 0} {
d1151 1
a1151 1
    if {$last == "none"} {
d1156 1
a1156 1
	    if {$label == $s} {
d1179 1
a1179 1
    if {$entry != {}} {
d1190 2
a1191 1
    if {($entry != {}) && ([$menu entrycget $entry -state] != "disabled")} {
d1208 1
a1208 1
    if {$tkPriv(oldGrab) != ""} {
d1220 1
a1220 1
    if {$tkPriv(oldGrab) != ""} {
d1226 1
a1226 1
	    if {$tkPriv(grabStatus) == "global"} {
d1238 1
a1238 1
    if {![info exists tkPriv(focus)] || [string length $tkPriv(focus)] == 0} {
d1247 2
a1248 3
    if {([string compare $tkPriv(activeMenu) $menu] == 0) \
	    && ([string compare $tkPriv(activeItem) [$menu index active]] \
	    == 0)} {
d1272 2
a1273 1
    if {($tkPriv(popup) != "") || ($tkPriv(postedMb) != "")} {
d1277 3
a1279 2
    if {$tcl_platform(platform) == "unix"} {
	tkSaveGrabInfo $menu
d1285 2
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d7 1
a7 1
# RCS: @@(#) $Id: menu.tcl,v 1.7.6.2 2000/09/26 16:08:43 spolk Exp $
a10 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d92 1
a92 1
    if {[string compare $tkPriv(inMenubutton) ""]} {
d121 3
a123 3
    if {[string equal [%W cget -type] "tearoff"]} {
	if {[string compare "%m" "NotifyUngrab"]} {
	    if {[string equal $tcl_platform(platform) "unix"]} {
d171 1
a171 1
if {[string equal $tcl_platform(platform) "unix"]} {
d201 1
a201 1
    if {[string compare $tkPriv(inMenubutton) ""]} {
d205 1
a205 1
    if {[string compare [$w cget -state] "disabled"]} {
d224 1
a224 1
    if {[string equal [$w cget -state] "active"]} {
d245 1
a245 2
    if {[string equal [$w cget -state] "disabled"] || \
	    [string equal $w $tkPriv(postedMb)]} {
d249 1
a249 1
    if {[string equal $menu ""]} {
d252 2
a253 2
    set tearoff [expr {[string equal $tcl_platform(platform) "unix"] \
	    || [string equal [$menu cget -type] "tearoff"]}]
d258 1
a258 1
    if {[string compare $cur ""]} {
d277 1
a277 1
	switch [$w cget -direction] {
d302 1
a302 1
		if {[string compare $entry {}] && [string compare [$menu entrycget $entry -state] "disabled"]} {
d321 1
a321 1
		if {[string compare $entry {}] && [string compare [$menu entrycget $entry -state] "disabled"]} {
d328 1
a328 1
		    if {[string equal $y {}]} {
d337 2
a338 2
	}
    } msg]} {
d351 2
a352 4
	if {[winfo viewable $w]} {
	    tkSaveGrabInfo $w
	    grab -global $w
	}
d388 1
a388 1
	if {[string compare $mb ""]} {
d394 1
a394 1
	} elseif {[string compare $tkPriv(popup) ""]} {
d397 2
a398 2
	} elseif {[string compare [$menu cget -type] "menubar"] \
		&& [string compare [$menu cget -type] "tearoff"]} {
d404 1
a404 1
	    while {1} {
d406 1
a406 1
		if {[string compare [winfo class $parent] "Menu"] \
d414 1
a414 2
		if {[string equal $type "menubar"] || \
			[string equal $type "tearoff"]} {
d419 1
a419 1
	    if {[string compare [$menu cget -type] "menubar"]} {
d425 1
a425 1
    if {($tkPriv(tearoff) != 0) || [string compare $tkPriv(menuBar) ""]} {
d428 2
a429 1
	if {[string compare $menu ""]} {
d431 1
a431 1
	    if {[string compare $grab ""]} {
d436 1
a436 1
	if {[string compare $tkPriv(menuBar) ""]} {
d440 1
a440 1
	if {[string compare $tcl_platform(platform) "unix"]} {
d460 1
a460 1
    if {[string equal $tkPriv(inMenubutton) $w]} {
d464 3
a466 4
    if {[string compare $new $tkPriv(inMenubutton)] \
	    && ([string equal $new ""] \
	    || [string equal [winfo toplevel $new] [winfo toplevel $w]])} {
	if {[string compare $tkPriv(inMenubutton) ""]} {
d469 2
a470 3
	if {[string compare $new ""] \
		&& [string equal [winfo class $new] "Menubutton"] \
		&& ([$new cget -indicatoron] == 0) \
d472 1
a472 1
	    if {[string equal $upDown "down"]} {
d493 4
a496 6
    set menu [$w cget -menu]
    set tearoff [expr {[string equal $tcl_platform(platform) "unix"] || \
	    ([string compare $menu {}] && \
	    [string equal [$menu cget -type] "tearoff"])}]
    if {($tearoff != 0) && [string equal $tkPriv(postedMb) $w] \
	    && [string equal $tkPriv(inMenubutton) $w]} {
d518 2
a519 2
    if {[string equal $menu $tkPriv(window)]} {
	if {[string equal [$menu cget -type] "menubar"]} {
d521 1
a521 1
		    [string compare $menu $tkPriv(focus)]} {
a552 4

    if {![winfo viewable $menu]} {
        return
    }
d554 1
a554 2
    if {[string compare $tkPriv(postedMb) ""] && \
	    [winfo viewable $tkPriv(postedMb)]} {
d557 2
a558 2
	while {[string equal [$menu cget -type] "normal"] \
		&& [string equal [winfo class [winfo parent $menu]] "Menu"] \
d563 1
a563 1
	if {[string equal $tkPriv(menuBar) {}]} {
d574 1
a574 1
	if {[string compare $menu [grab current $menu]]} {
d581 1
a581 1
	if {[string equal $tcl_platform(platform) "unix"]} {
d600 1
a600 1
    if {[string equal [$menu index active] "none"]} {
d603 3
a605 3
    if {[string equal [$menu type active] "cascade"]
          && [string equal [winfo containing $rootx $rooty] \
                  [$menu entrycget active -menu]]} {
d625 1
a625 1
    if {$buttonRelease && [string equal $tkPriv(window) {}]} {
d636 1
a636 1
    if {[string equal [$w type active] "cascade"]} {
d640 2
a641 1
    } elseif {[string equal [$w type active] "tearoff"]} {
d643 1
a643 2
	tkMenuUnpost $w
    } elseif {[string equal [$w cget -type] "menubar"]} {
d645 2
a646 12
	set active [$w index active]
	set isCascade [string equal [$w type $active] "cascade"]

	# Only de-activate the active item if it's a cascade; this prevents
	# the annoying "activation flicker" you otherwise get with 
	# checkbuttons/commands/etc. on menubars

	if { $isCascade } {
	    $w activate none
	    event generate $w <<MenuSelect>>
	}

a647 8

	# If the active item is not a cascade, invoke it.  This enables
	# the use of checkbuttons/commands/etc. on menubars (which is legal,
	# but not recommended)

	if { !$isCascade } {
	    uplevel #0 [list $w invoke $active]
	}
d664 1
a664 1
    if {[string compare [winfo class $parent] "Menu"]} {
d666 1
a666 1
    } elseif {[string equal [$parent cget -type] "menubar"]} {
d678 1
a678 1
    if {[string equal [$menu cget -type] "menubar"]} {
d686 1
a686 1
    if {[string equal [$menu cget -type] "menubar"]} {
d694 1
a694 1
    if {[string equal [$menu cget -type] "menubar"]} {
d702 1
a702 1
    if {[string equal [$menu cget -type] "menubar"]} {
d724 1
a724 1
    if {[string equal $direction "right"]} {
d728 1
a728 1
	if {[string equal [$menu type active] "cascade"]} {
d731 1
a731 1
	    if {[string compare $m2 ""]} {
d737 3
a739 3
	    while {[string compare $parent "."]} {
		if {[string equal [winfo class $parent] "Menu"] \
			&& [string equal [$parent cget -type] "menubar"]} {
d750 2
a751 2
	if {[string equal [winfo class $m2] "Menu"]} {
	    if {[string compare [$m2 cget -type] "menubar"]} {
d770 2
a771 2
    if {[string equal [winfo class $m2] "Menu"]} {
	if {[string equal [$m2 cget -type] "menubar"]} {
d779 1
a779 1
    if {[string equal $w ""]} {
d785 1
a785 1
    while {1} {
d793 4
a796 4
	if {[string equal [winfo class $mb] "Menubutton"] \
		&& [string compare [$mb cget -state] "disabled"] \
		&& [string compare [$mb cget -menu] ""] \
		&& [string compare [[$mb cget -menu] index last] "none"]} {
d799 1
a799 1
	if {[string equal $mb $w]} {
d820 1
a820 1
    if {[string equal [$menu index last] "none"]} {
d826 1
a826 1
    if {[string equal $active "none"]} {
d831 1
a831 1
    while {1} {
d845 1
a845 1
	    if {[string compare $state "disabled"]} {
d857 1
a857 1
    if {[string equal [$menu type $i] "cascade"]} {
d859 1
a859 4
	if {[string compare $cascade ""]} {
	    # Here we auto-post a cascade.  This is necessary when
	    # we traverse left/right in the menubar, but undesirable when
	    # we traverse up/down in a menu.
d888 4
a891 20
	# Don't descend into other toplevels.
        if {[string compare [winfo toplevel [focus]] \
		[winfo toplevel $child]]} {
	    continue
	}
	if {[string equal [winfo class $child] "Menu"] && \
		[string equal [$child cget -type] "menubar"]} {
	    if {[string equal $char ""]} {
		return $child
	    }
	    set last [$child index last]
	    for {set i [$child cget -tearoff]} {$i <= $last} {incr i} {
		if {[string equal [$child type $i] "separator"]} {
		    continue
		}
		set char2 [string index [$child entrycget $i -label] \
			[$child entrycget $i -underline]]
		if {[string equal $char [string tolower $char2]] \
			|| [string equal $char ""]} {
		    if {[string compare [$child entrycget $i -state] "disabled"]} {
d894 14
a913 5
	# Don't descend into other toplevels.
        if {[string compare [winfo toplevel [focus]] \
		[winfo toplevel $child]]} {
	    continue
	}
d918 3
a920 3
		if {[string equal $char [string tolower $char2]] \
			|| [string equal $char ""]} {
		    if {[string compare [$child cget -state] "disabled"]} {
d928 1
a928 1
		if {[string compare $match ""]} {
d951 1
a951 1
    if {[string equal $char ""]} {
d954 2
a955 3
    while {[string equal [winfo class $w] "Menu"]} {
	if {[string compare [$w cget -type] "menubar"] \
		&& [string equal $tkPriv(postedMb) ""]} {
d958 1
a958 1
	if {[string equal [$w cget -type] "menubar"]} {
d964 2
a965 2
    if {[string compare $w ""]} {
	if {[string equal [winfo class $w] "Menu"]} {
d988 2
a989 2
    if {[string compare $w ""]} {
	if {[string equal [winfo class $w] "Menu"]} {
d1014 1
a1014 1
    if {[string equal $char ""]} {
d1019 1
a1019 1
    if {[string equal $last "none"]} {
d1024 2
a1025 1
		[$w entrycget $i -label] [$w entrycget $i -underline]]}]} {
d1028 2
a1029 2
	if {[string equal $char [string tolower $char2]]} {
	    if {[string equal [$w type $i] "cascade"]} {
d1034 1
a1034 1
		if {[string compare $m2 ""]} {
d1058 1
a1058 1
    if {[string equal $menu ""]} {
d1062 1
a1062 1
    if {[string compare [$menu index active] "none"]} {
d1066 1
a1066 1
    if {[string equal $last "none"]} {
d1070 2
a1071 3
	if {([catch {set state [$menu entrycget $i -state]}] == 0) \
		&& [string compare $state "disabled"] \
		&& [string compare [$menu type $i] "tearoff"]} {
d1074 1
a1074 6
	    # Only post the cascade if the current menu is a menubar;
	    # otherwise, if the first entry of the cascade is a cascade,
	    # we can get an annoying cascading effect resulting in a bunch of
	    # menus getting posted (bug 676)
	    if {[string equal [$menu type $i] "cascade"] && \
		[string equal [$menu cget -type] "menubar"]} {
d1076 1
a1076 1
		if {[string compare $cascade ""]} {
d1104 1
a1104 1
    if {[string equal $last "none"]} {
d1109 1
a1109 1
	    if {[string equal $label $s]} {
d1132 1
a1132 1
    if {[string compare $entry {}]} {
d1143 1
a1143 2
    if {[string compare $entry {}] \
	    && [string compare [$menu entrycget $entry -state] "disabled"]} {
d1160 1
a1160 1
    if {[string compare $tkPriv(oldGrab) ""]} {
d1172 1
a1172 1
    if {[string compare $tkPriv(oldGrab) ""]} {
d1178 1
a1178 1
          if {[string equal $tkPriv(grabStatus) "global"]} {
d1190 1
a1190 1
    if {![info exists tkPriv(focus)] || [string equal $tkPriv(focus) {}]} {
d1199 3
a1201 2
    if {[string equal $tkPriv(activeMenu) $menu] \
          && [string equal $tkPriv(activeItem) [$menu index active]]} {
d1225 1
a1225 2
    if {[string compare $tkPriv(popup) ""] \
	    || [string compare $tkPriv(postedMb) ""]} {
d1229 2
a1230 3
    if {[string equal $tcl_platform(platform) "unix"] \
	    && [winfo viewable $menu]} {
        tkSaveGrabInfo $menu
a1235 2


@


1.1.1.3
log
@import tk 8.4.0
@
text
@d7 1
a7 1
# RCS: @@(#) $Id: menu.tcl,v 1.18 2002/08/31 06:12:28 das Exp $
d18 1
a18 1
# Elements of tk::Priv that are used in this file:
d23 2
a24 2
# grabGlobal -		Used in conjunction with tk::Priv(oldGrab):  if
#			tk::Priv(oldGrab) is non-empty, then tk::Priv(grabGlobal)
d65 1
a65 1
#    tk::Priv(postedMb) identifies the posted menubutton.
d67 1
a67 1
#    tk::Priv(postedMb) is empty, and menu's type is "tearoff".
d69 2
a70 2
#    style tk::Priv(postedMb) identifies the posted menubutton.
# 4. As a popup menu.  In this style tk::Priv(postedMb) is empty and
d72 1
a72 1
# 5. As a pulldown from a menubar. The variable tk::Priv(menubar) has
d87 1
a87 1
    tk::MbEnter %W
d90 1
a90 1
    tk::MbLeave %W
d93 2
a94 2
    if {$tk::Priv(inMenubutton) ne ""} {
	tk::MbPost $tk::Priv(inMenubutton) %X %Y
d98 1
a98 1
    tk::MbMotion %W up %X %Y
d101 1
a101 1
    tk::MbMotion %W down %X %Y
d104 1
a104 1
    tk::MbButtonUp %W
d107 2
a108 2
    tk::MbPost %W
    tk::MenuFirstEntry [%W cget -menu]
d121 4
a124 4
    set tk::Priv(window) %W
    if {[%W cget -type] eq "tearoff"} {
	if {"%m" ne "NotifyUngrab"} {
	    if {[tk windowingsystem] eq "x11"} {
d129 1
a129 1
    tk::MenuMotion %W %x %y %s
d133 1
a133 1
    tk::MenuLeave %W %X %Y %s
d136 1
a136 1
    tk::MenuMotion %W %x %y %s
d139 1
a139 1
    tk::MenuButtonDown %W
d142 1
a142 1
   tk::MenuInvoke %W 1
d145 1
a145 1
    tk::MenuInvoke %W 0
d148 1
a148 1
    tk::MenuInvoke %W 0
d151 1
a151 1
    tk::MenuEscape %W
d154 1
a154 1
    tk::MenuLeftArrow %W
d157 1
a157 1
    tk::MenuRightArrow %W
d160 1
a160 1
    tk::MenuUpArrow %W
d163 1
a163 1
    tk::MenuDownArrow %W
d166 1
a166 1
    tk::TraverseWithinMenu %W %A
d172 1
a172 1
if {[string equal [tk windowingsystem] "x11"]} {
d174 1
a174 1
	tk::TraverseToMenu %W %A
d178 1
a178 1
	tk::FirstMenu %W
d182 1
a182 1
	tk::TraverseToMenu %W %A
d186 1
a186 1
	tk::FirstMenu %W
d190 1
a190 1
# ::tk::MbEnter --
d194 1
a194 1
# The procedure ::tk::MbB1Enter is invoked if the button is down.
d199 2
a200 2
proc ::tk::MbEnter w {
    variable ::tk::Priv
d202 2
a203 2
    if {[string compare $Priv(inMenubutton) ""]} {
	MbLeave $Priv(inMenubutton)
d205 1
a205 1
    set Priv(inMenubutton) $w
d211 1
a211 1
# ::tk::MbLeave --
d218 2
a219 2
proc ::tk::MbLeave w {
    variable ::tk::Priv
d221 1
a221 1
    set Priv(inMenubutton) {}
d230 1
a230 1
# ::tk::MbPost --
d242 2
a243 3
proc ::tk::MbPost {w {x {}} {y {}}} {
    global errorInfo
    variable ::tk::Priv
d246 2
a247 1
    if {[$w cget -state] eq "disabled" || $w eq $Priv(postedMb)} {
d254 2
a255 2
    set tearoff [expr {[tk windowingsystem] eq "x11" \
	    || [$menu cget -type] eq "tearoff"}]
d259 1
a259 1
    set cur $Priv(postedMb)
d261 1
a261 1
	MenuUnpost {}
d263 2
a264 2
    set Priv(cursor) [$w cget -cursor]
    set Priv(relief) [$w cget -relief]
d268 2
a269 2
    set Priv(postedMb) $w
    set Priv(focus) [focus]
d271 1
a271 1
    GenerateMenuSelect $menu
d283 1
a283 1
		PostOverPoint $menu $x $y
d288 1
a288 1
		PostOverPoint $menu $x $y
d293 1
a293 1
    	    	set entry [MenuFindName $menu [$w cget -text]]
d303 2
a304 3
		PostOverPoint $menu $x $y
		if {$entry ne "" \
			&& [$menu entrycget $entry -state] ne "disabled"} {
d306 1
a306 1
		    GenerateMenuSelect $menu
d312 1
a312 1
    	    	set entry [MenuFindName $menu [$w cget -text]]
d322 2
a323 3
		PostOverPoint $menu $x $y
		if {$entry ne "" \
			&& [$menu entrycget $entry -state] ne "disabled"} {
d325 1
a325 1
		    GenerateMenuSelect $menu
d334 1
a334 1
	            PostOverPoint $menu $x $y [MenuFindName $menu [$w cget -text]]
d336 1
a336 1
		    PostOverPoint $menu [winfo rootx $w] [expr {[winfo rooty $w]+[winfo height $w]}]
d345 1
a345 1
	MenuUnpost {}
d350 1
a350 1
    set Priv(tearoff) $tearoff
d354 1
a354 1
	    SaveGrabInfo $w
d360 1
a360 1
# ::tk::MenuUnpost --
d376 1
a376 1
proc ::tk::MenuUnpost menu {
d378 2
a379 2
    variable ::tk::Priv
    set mb $Priv(postedMb)
d385 2
a386 2
    catch {focus $Priv(focus)}
    set Priv(focus) ""
d395 6
a400 6
	    set Priv(postedMb) {}
	    $mb configure -cursor $Priv(cursor)
	    $mb configure -relief $Priv(relief)
	} elseif {[string compare $Priv(popup) ""]} {
	    $Priv(popup) unpost
	    set Priv(popup) {}
d416 1
a416 1
		GenerateMenuSelect $parent
d430 1
a430 1
    if {($Priv(tearoff) != 0) || $Priv(menuBar) ne ""} {
d439 4
a442 4
	RestoreOldGrab
	if {$Priv(menuBar) ne ""} {
	    $Priv(menuBar) configure -cursor $Priv(cursor)
	    set Priv(menuBar) {}
d444 2
a445 2
	if {[tk windowingsystem] ne "x11"} {
	    set Priv(tearoff) 0
d450 1
a450 1
# ::tk::MbMotion --
d461 2
a462 2
proc ::tk::MbMotion {w upDown rootx rooty} {
    variable ::tk::Priv
d464 1
a464 1
    if {[string equal $Priv(inMenubutton) $w]} {
d468 1
a468 1
    if {[string compare $new $Priv(inMenubutton)] \
d471 2
a472 2
	if {[string compare $Priv(inMenubutton) ""]} {
	    MbLeave $Priv(inMenubutton)
d479 1
a479 1
		MbPost $new $rootx $rooty
d481 1
a481 1
		MbEnter $new
d487 1
a487 1
# ::tk::MbButtonUp --
d495 2
a496 2
proc ::tk::MbButtonUp w {
    variable ::tk::Priv
d500 6
a505 5
    set tearoff [expr {[tk windowingsystem] eq "x11" || \
	    ($menu ne "" && [$menu cget -type] eq "tearoff")}]
    if {($tearoff != 0) && $Priv(postedMb) eq $w \
	    && $Priv(inMenubutton) eq $w} {
	MenuFirstEntry [$Priv(postedMb) cget -menu]
d507 1
a507 1
	MenuUnpost {}
d511 1
a511 1
# ::tk::MenuMotion --
d524 3
a526 3
proc ::tk::MenuMotion {menu x y state} {
    variable ::tk::Priv
    if {[string equal $menu $Priv(window)]} {
d528 2
a529 2
	    if {[info exists Priv(focus)] && \
		    [string compare $menu $Priv(focus)]} {
d531 1
a531 1
		GenerateMenuSelect $menu
d535 1
a535 1
	    GenerateMenuSelect $menu
d543 1
a543 1
# ::tk::MenuButtonDown --
d558 2
a559 2
proc ::tk::MenuButtonDown menu {
    variable ::tk::Priv
d566 3
a568 3
    if {[string compare $Priv(postedMb) ""] && \
	    [winfo viewable $Priv(postedMb)]} {
	grab -global $Priv(postedMb)
d576 3
a578 3
	if {[string equal $Priv(menuBar) {}]} {
	    set Priv(menuBar) $menu
	    set Priv(cursor) [$menu cget -cursor]
d588 1
a588 1
	    SaveGrabInfo $menu
d594 1
a594 1
	if {[string equal [tk windowingsystem] "x11"]} {
d600 1
a600 1
# ::tk::MenuLeave --
d610 3
a612 3
proc ::tk::MenuLeave {menu rootx rooty state} {
    variable ::tk::Priv
    set Priv(window) {}
d622 1
a622 1
    GenerateMenuSelect $menu
d625 1
a625 1
# ::tk::MenuInvoke --
d635 2
a636 2
proc ::tk::MenuInvoke {w buttonRelease} {
    variable ::tk::Priv
d638 1
a638 1
    if {$buttonRelease && [string equal $Priv(window) {}]} {
d646 1
a646 1
	MenuUnpost $w
d652 1
a652 1
	MenuFirstEntry $menu
d654 2
a655 2
	::tk::TearOffMenu $w
	MenuUnpost $w
d670 1
a670 1
	MenuUnpost $w
d680 1
a680 1
	MenuUnpost $w
d685 1
a685 1
# ::tk::MenuEscape --
d693 1
a693 1
proc ::tk::MenuEscape menu {
d696 1
a696 1
	MenuUnpost $menu
d698 2
a699 2
	MenuUnpost $menu
	RestoreOldGrab
d701 1
a701 1
	MenuNextMenu $menu left
d708 1
a708 1
proc ::tk::MenuUpArrow {menu} {
d710 1
a710 1
	MenuNextMenu $menu left
d712 1
a712 1
	MenuNextEntry $menu -1
d716 1
a716 1
proc ::tk::MenuDownArrow {menu} {
d718 1
a718 1
	MenuNextMenu $menu right
d720 1
a720 1
	MenuNextEntry $menu 1
d724 1
a724 1
proc ::tk::MenuLeftArrow {menu} {
d726 1
a726 1
	MenuNextEntry $menu -1
d728 1
a728 1
	MenuNextMenu $menu left
d732 1
a732 1
proc ::tk::MenuRightArrow {menu} {
d734 1
a734 1
	MenuNextEntry $menu 1
d736 1
a736 1
	MenuNextMenu $menu right
d740 1
a740 1
# ::tk::MenuNextMenu --
d750 2
a751 2
proc ::tk::MenuNextMenu {menu direction} {
    variable ::tk::Priv
d763 1
a763 1
		MenuFirstEntry $m2
d772 1
a772 1
		    MenuNextEntry $parent 1
a781 6
	    $menu activate none
	    GenerateMenuSelect $menu
	    tk_menuSetFocus $m2

	    $m2 postcascade none

d783 9
d804 1
a804 1
	    MenuNextEntry $m2 -1
d809 1
a809 1
    set w $Priv(postedMb)
d835 2
a836 2
    MbPost $mb
    MenuFirstEntry [$mb cget -menu]
d839 1
a839 1
# ::tk::MenuNextEntry --
d848 2
a849 1
proc ::tk::MenuNextEntry {menu count} {
d876 1
a876 3
	    if {$state ne "disabled" && \
		    ($i!=0 || [$menu cget -type] ne "tearoff" \
		    || [$menu type 0] ne "tearoff")} {
d887 2
a888 4
    GenerateMenuSelect $menu

    if {[string equal [$menu type $i] "cascade"] \
	    && [string equal [$menu cget -type] "menubar"]} {
d895 1
a895 1
	    MenuFirstEntry $cascade
d900 1
a900 1
# ::tk::MenuFind --
d916 2
a917 1
proc ::tk::MenuFind {w char} {
d923 2
a924 1
        if {[string compare [winfo toplevel $w] [winfo toplevel $child]]} {
d951 2
a952 1
        if {[string compare [winfo toplevel $w] [winfo toplevel $child]]} {
d968 1
a968 1
		set match [MenuFind $child $char]
d978 1
a978 1
# ::tk::TraverseToMenu --
d990 2
a991 2
proc ::tk::TraverseToMenu {w char} {
    variable ::tk::Priv
d997 1
a997 1
		&& [string equal $Priv(postedMb) ""]} {
d1005 1
a1005 1
    set w [MenuFind [winfo toplevel $w] $char]
d1009 2
a1010 2
	    set Priv(window) $w
	    SaveGrabInfo $w
d1012 1
a1012 1
	    TraverseWithinMenu $w $char
d1014 2
a1015 2
	    MbPost $w
	    MenuFirstEntry [$w cget -menu]
d1020 1
a1020 1
# ::tk::FirstMenu --
d1028 2
a1029 3
proc ::tk::FirstMenu w {
    variable ::tk::Priv
    set w [MenuFind [winfo toplevel $w] ""]
d1033 2
a1034 2
	    set Priv(window) $w
	    SaveGrabInfo $w
d1036 1
a1036 1
	    MenuFirstEntry $w
d1038 2
a1039 2
	    MbPost $w
	    MenuFirstEntry [$w cget -menu]
d1044 1
a1044 1
# ::tk::TraverseWithinMenu
d1055 1
a1055 1
proc ::tk::TraverseWithinMenu {w char} {
d1076 1
a1076 1
		    MenuFirstEntry $m2
d1079 1
a1079 1
		MenuUnpost $w
d1087 1
a1087 1
# ::tk::MenuFirstEntry --
d1091 1
a1091 1
# because of a previous call to tk::PostOverPoint) then the active
d1098 1
a1098 1
proc ::tk::MenuFirstEntry menu {
d1115 1
a1115 1
	    GenerateMenuSelect $menu
d1125 1
a1125 1
		    MenuFirstEntry $cascade
d1133 1
a1133 1
# ::tk::MenuFindName --
d1144 1
a1144 1
proc ::tk::MenuFindName {menu s} {
d1164 1
a1164 1
# ::tk::PostOverPoint --
d1176 1
a1176 1
proc ::tk::PostOverPoint {menu x y {entry {}}}  {
a1188 16
    if {$tcl_platform(platform) == "windows"} {
	# We need to fix some problems with menu posting on Windows.
	set yoffset [expr {[winfo screenheight $menu] \
		- $y - [winfo reqheight $menu]}]
	if {$yoffset < 0} {
	    # The bottom of the menu is offscreen, so adjust upwards
	    incr y $yoffset
	    if {$y < 0} { set y 0 }
	}
	# If we're off the top of the screen (either because we were
	# originally or because we just adjusted too far upwards),
	# then make the menu popup on the top edge.
	if {$y < 0} {
	    set y 0
	}
    }
d1190 2
a1191 1
    if {$entry ne "" && [$menu entrycget $entry -state] ne "disabled"} {
d1193 1
a1193 1
	GenerateMenuSelect $menu
d1197 2
a1198 2
# ::tk::SaveGrabInfo --
# Sets the variables tk::Priv(oldGrab) and tk::Priv(grabStatus) to record
d1205 5
a1209 5
proc tk::SaveGrabInfo w {
    variable ::tk::Priv
    set Priv(oldGrab) [grab current $w]
    if {$Priv(oldGrab) ne ""} {
	set Priv(grabStatus) [grab status $Priv(oldGrab)]
d1213 1
a1213 1
# ::tk::RestoreOldGrab --
d1217 4
a1220 2
proc ::tk::RestoreOldGrab {} {
    variable ::tk::Priv
a1221 1
    if {$Priv(oldGrab) ne ""} {
d1226 2
a1227 2
          if {[string equal $Priv(grabStatus) "global"]} {
		grab set -global $Priv(oldGrab)
d1229 1
a1229 1
		grab set $Priv(oldGrab)
d1232 1
a1232 1
	set Priv(oldGrab) ""
d1236 4
a1239 4
proc ::tk_menuSetFocus {menu} {
    variable ::tk::Priv
    if {![info exists Priv(focus)] || [string equal $Priv(focus) {}]} {
	set Priv(focus) [focus]
d1244 2
a1245 2
proc ::tk::GenerateMenuSelect {menu} {
    variable ::tk::Priv
d1247 2
a1248 2
    if {[string equal $Priv(activeMenu) $menu] \
          && [string equal $Priv(activeItem) [$menu index active]]} {
d1252 2
a1253 2
    set Priv(activeMenu) $menu
    set Priv(activeItem) [$menu index active]
d1257 1
a1257 1
# ::tk_popup --
d1269 2
a1270 2
proc ::tk_popup {menu x y {entry {}}} {
    variable ::tk::Priv
d1272 8
a1279 6
    if {$Priv(popup) ne "" || $Priv(postedMb) ne ""} {
	tk::MenuUnpost {}
    }
    tk::PostOverPoint $menu $x $y $entry
    if {[tk windowingsystem] eq "x11" && [winfo viewable $menu]} {
        tk::SaveGrabInfo $menu
d1281 1
a1281 1
	set Priv(popup) $menu
d1285 2
@


