head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.51;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.16;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.29;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.54;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.36;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.39.09;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# This file is a Tcl script to test the code in the file tkTextIndex.c.
# This file is organized in the standard fashion for Tcl tests.
#
# Copyright (c) 1994 The Regents of the University of California.
# Copyright (c) 1994 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
#
# RCS: @@(#) $Id: textIndex.test,v 1.7 2002/07/13 20:28:35 dgp Exp $

package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands

# Some tests require the testtext command
testConstraint testtext [llength [info commands testtext]]

catch {destroy .t}
text .t -font {Courier -12} -width 20 -height 10
pack append . .t {top expand fill}
update
.t debug on
wm geometry . {}
  
# The statements below reset the main window;  it's needed if the window
# manager is mwm to make mwm forget about a previous minimum size setting.

wm withdraw .
wm minsize . 1 1
wm positionfrom . user
wm deiconify .

.t insert 1.0 "Line 1
abcdefghijklm
12345
Line 4
b\u4e4fy GIrl .#@@? x_yz
!@@#$%
Line 7"

image create photo textimage -width 10 -height 10
textimage put red -to 0 0 9 9

test textIndex-1.1 {TkTextMakeByteIndex} {testtext} {
    # (lineIndex < 0)
    testtext .t byteindex -1 3
} {1.0 0}
test textIndex-1.2 {TkTextMakeByteIndex} {testtext} {
    # (lineIndex < 0), because lineIndex == strtol(argv[2]) - 1
    testtext .t byteindex 0 3
} {1.0 0}
test textIndex-1.3 {TkTextMakeByteIndex} {testtext} {
    # not (lineIndex < 0)
    testtext .t byteindex 1 3
} {1.3 3}
test textIndex-1.4 {TkTextMakeByteIndex} {testtext} {
    # (byteIndex < 0)
    testtext .t byteindex 3 -1
} {3.0 0}
test textIndex-1.5 {TkTextMakeByteIndex} {testtext} {
    # not (byteIndex < 0)
    testtext .t byteindex 3 3
} {3.3 3}
test textIndex-1.6 {TkTextMakeByteIndex} {testtext} {
    # (indexPtr->linePtr == NULL)
    testtext .t byteindex 9 2
} {8.0 0}
test textIndex-1.7 {TkTextMakeByteIndex} {testtext} {
    # not (indexPtr->linePtr == NULL)
    testtext .t byteindex 7 2
} {7.2 2}
test textIndex-1.8 {TkTextMakeByteIndex: shortcut for 0} {testtext} {
    # (byteIndex == 0)
    testtext .t byteindex 1 0
} {1.0 0}
test textIndex-1.9 {TkTextMakeByteIndex: shortcut for 0} {testtext} {
    # not (byteIndex == 0)
    testtext .t byteindex 3 80
} {3.5 5}
test textIndex-1.10 {TkTextMakeByteIndex: verify index is in range} {testtext} {
    # for (segPtr = indexPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr) 
    # one segment

    testtext .t byteindex 3 5
} {3.5 5}
test textIndex-1.11 {TkTextMakeByteIndex: verify index is in range} {testtext} {
    # for (segPtr = indexPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr)
    #     index += segPtr->size
    # Multiple segments, make sure add segment size to index.

    .t mark set foo 3.2 
    set x [testtext .t byteindex 3 7]
    .t mark unset foo
    set x
} {3.5 5}
test textIndex-1.12 {TkTextMakeByteIndex: verify index is in range} {testtext} {
    # (segPtr == NULL)
    testtext .t byteindex 3 7
} {3.5 5}
test textIndex-1.13 {TkTextMakeByteIndex: verify index is in range} {testtext} {
    # not (segPtr == NULL)
    testtext .t byteindex 3 4
} {3.4 4}
test textIndex-1.14 {TkTextMakeByteIndex: verify index is in range} {testtext} {
    # (index + segPtr->size > byteIndex)
    # in this segment.

    testtext .t byteindex 3 4
} {3.4 4}
test textIndex-1.15 {TkTextMakeByteIndex: verify index is in range} {testtext} {
    # (index + segPtr->size > byteIndex), index != 0
    # in this segment.

    .t mark set foo 3.2
    set x [testtext .t byteindex 3 4]
    .t mark unset foo
    set x
} {3.4 4}
test textIndex-1.16 {TkTextMakeByteIndex: UTF-8 characters} {testtext} {
    testtext .t byteindex 5 100
} {5.18 20}
test textIndex-1.17 {TkTextMakeByteIndex: prevent splitting UTF-8 character} \
	{testtext} {
    # ((byteIndex > index) && (segPtr->typePtr == &tkTextCharType)) 
    # Wrong answer would be \xb9 (the 2nd byte of UTF rep of 0x4e4f).

    set x [testtext .t byteindex 5 2]
    list $x [.t get insert]
} {{5.2 4} y}
test textIndex-1.18 {TkTextMakeByteIndex: prevent splitting UTF-8 character} \
	{testtext} {
    # ((byteIndex > index) && (segPtr->typePtr == &tkTextCharType)) 
    testtext .t byteindex 5 1
    .t get insert
} "\u4e4f"

test textIndex-2.1 {TkTextMakeCharIndex} {
    # (lineIndex < 0)
    .t index -1.3
} 1.0
test textIndex-2.2 {TkTextMakeCharIndex} {
    # (lineIndex < 0), because lineIndex == strtol(argv[2]) - 1
    .t index 0.3
} 1.0
test textIndex-2.3 {TkTextMakeCharIndex} {
    # not (lineIndex < 0)
    .t index 1.3
} 1.3
test textIndex-2.4 {TkTextMakeCharIndex} {
    # (charIndex < 0)
    .t index 3.-1
} 3.0
test textIndex-2.5 {TkTextMakeCharIndex} {
    # (charIndex < 0)
    .t index 3.3
} 3.3
test textIndex-2.6 {TkTextMakeCharIndex} {
    # (indexPtr->linePtr == NULL)
    .t index 9.2
} 8.0
test textIndex-2.7 {TkTextMakeCharIndex} {
    # not (indexPtr->linePtr == NULL)
    .t index 7.2
} 7.2
test textIndex-2.8 {TkTextMakeCharIndex: verify index is in range} {
    # for (segPtr = indexPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr)
    # one segment

    .t index 3.5
} 3.5
test textIndex-2.9 {TkTextMakeCharIndex: verify index is in range} {
    # for (segPtr = indexPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr)
    # Multiple segments, make sure add segment size to index.

    .t mark set foo 3.2 
    set x [.t index 3.7]
    .t mark unset foo
    set x
} 3.5
test textIndex-2.10 {TkTextMakeCharIndex: verify index is in range} {
    # (segPtr == NULL)
    .t index 3.7
} 3.5
test textIndex-2.11 {TkTextMakeCharIndex: verify index is in range} {
    # not (segPtr == NULL)
    .t index 3.4
} 3.4
test textIndex-2.12 {TkTextMakeCharIndex: verify index is in range} {
    # (segPtr->typePtr == &tkTextCharType)
    # Wrong answer would be \xb9 (the 2nd byte of UTF rep of 0x4e4f).

    .t mark set insert 5.2
    .t get insert
} y
test textIndex-2.13 {TkTextMakeCharIndex: verify index is in range} {
    # not (segPtr->typePtr == &tkTextCharType)

    .t image create 5.2 -image textimage
    .t mark set insert 5.5
    set x [.t get insert]
    .t delete 5.2
    set x
} "G"
test textIndex-2.14 {TkTextMakeCharIndex: verify index is in range} {
    # (charIndex < segPtr->size)

    .t image create 5.0 -image textimage
    set x [.t index 5.0]
    .t delete 5.0
    set x
} 5.0

.t mark set foo 3.2
.t tag add x 2.8 2.11
.t tag add x 6.0 6.2
set weirdTag "funny . +- 22.1\n\t{"
.t tag add $weirdTag 2.1  2.6
set weirdMark "asdf \n{-+ 66.2\t"
.t mark set $weirdMark 4.0
.t tag config y -relief raised
test textIndex-3.1 {TkTextGetIndex, weird mark names} {
    list [catch {.t index $weirdMark} msg] $msg
} {0 4.0}

test textIndex-4.1 {TkTextGetIndex, tags} {
    list [catch {.t index x.first} msg] $msg
} {0 2.8}
test textIndex-4.2 {TkTextGetIndex, tags} {
    list [catch {.t index x.last} msg] $msg
} {0 6.2}
test textIndex-4.3 {TkTextGetIndex, weird tags} {
    list [.t index $weirdTag.first+1c] [.t index $weirdTag.last+2c]
} {2.2 2.8}
test textIndex-4.4 {TkTextGetIndex, tags} {
    list [catch {.t index x.gorp} msg] $msg
} {1 {bad text index "x.gorp"}}
test textIndex-4.5 {TkTextGetIndex, tags} {
    list [catch {.t index foo.last} msg] $msg
} {1 {bad text index "foo.last"}}
test textIndex-4.6 {TkTextGetIndex, tags} {
    list [catch {.t index y.first} msg] $msg
} {1 {text doesn't contain any characters tagged with "y"}}
test textIndex-4.7 {TkTextGetIndex, tags} {
    list [catch {.t index x.last,} msg] $msg
} {1 {bad text index "x.last,"}}
test textIndex-4.8 {TkTextGetIndex, tags} {
    .t tag add z 1.0
    set result [list [.t index z.first] [.t index z.last]]
    .t tag delete z
    set result
} {1.0 1.1}

test textIndex-5.1 {TkTextGetIndex, "@@"} {nonPortable fonts} {
    .t index @@12,9
} 1.1
test textIndex-5.2 {TkTextGetIndex, "@@"} {fonts} {
    .t index @@-2,7
} 1.0
test textIndex-5.3 {TkTextGetIndex, "@@"} {fonts} {
    .t index @@10,-7
} 1.0
test textIndex-5.4 {TkTextGetIndex, "@@"} {fonts} {
    list [catch {.t index @@x} msg] $msg
} {1 {bad text index "@@x"}}
test textIndex-5.5 {TkTextGetIndex, "@@"} {fonts} {
    list [catch {.t index @@10q} msg] $msg
} {1 {bad text index "@@10q"}}
test textIndex-5.6 {TkTextGetIndex, "@@"} {fonts} {
    list [catch {.t index @@10,} msg] $msg
} {1 {bad text index "@@10,"}}
test textIndex-5.7 {TkTextGetIndex, "@@"} {fonts} {
    list [catch {.t index @@10,a} msg] $msg
} {1 {bad text index "@@10,a"}}
test textIndex-5.8 {TkTextGetIndex, "@@"} {fonts} {
    list [catch {.t index @@10,9,} msg] $msg
} {1 {bad text index "@@10,9,"}}

test textIndex-6.1 {TkTextGetIndex, numeric} {
    list [catch {.t index 2.3} msg] $msg
} {0 2.3}
test textIndex-6.2 {TkTextGetIndex, numeric} {
    list [catch {.t index -} msg] $msg
} {1 {bad text index "-"}}
test textIndex-6.3 {TkTextGetIndex, numeric} {
    list [catch {.t index 2.end} msg] $msg
} {0 2.13}
test textIndex-6.4 {TkTextGetIndex, numeric} {
    list [catch {.t index 2.x} msg] $msg
} {1 {bad text index "2.x"}}
test textIndex-6.5 {TkTextGetIndex, numeric} {
    list [catch {.t index 2.3x} msg] $msg
} {1 {bad text index "2.3x"}}

test textIndex-7.1 {TkTextGetIndex, miscellaneous other bases} {
    list [catch {.t index end} msg] $msg
} {0 8.0}
test textIndex-7.2 {TkTextGetIndex, miscellaneous other bases} {
    list [catch {.t index foo} msg] $msg
} {0 3.2}
test textIndex-7.3 {TkTextGetIndex, miscellaneous other bases} {
    list [catch {.t index foo+1c} msg] $msg
} {0 3.3}

test textIndex-8.1 {TkTextGetIndex, modifiers} {
    list [catch {.t index 2.1+1char} msg] $msg
} {0 2.2}
test textIndex-8.2 {TkTextGetIndex, modifiers} {
    list [catch {.t index "2.1  	+1char"} msg] $msg
} {0 2.2}
test textIndex-8.3 {TkTextGetIndex, modifiers} {
    list [catch {.t index 2.1-1char} msg] $msg
} {0 2.0}
test textIndex-8.4 {TkTextGetIndex, modifiers} {
    list [catch {.t index {2.1  }} msg] $msg
} {0 2.1}
test textIndex-8.5 {TkTextGetIndex, modifiers} {
    list [catch {.t index {2.1+foo bar}} msg] $msg
} {1 {bad text index "2.1+foo bar"}}
test textIndex-8.6 {TkTextGetIndex, modifiers} {
    list [catch {.t index {2.1 foo bar}} msg] $msg
} {1 {bad text index "2.1 foo bar"}}

test textIndex-9.1 {TkTextIndexCmp} {
    list [.t compare 3.1 < 3.2] [.t compare 3.1 == 3.2]
} {1 0}
test textIndex-9.2 {TkTextIndexCmp} {
    list [.t compare 3.2 < 3.2] [.t compare 3.2 == 3.2]
} {0 1}
test textIndex-9.3 {TkTextIndexCmp} {
    list [.t compare 3.3 < 3.2] [.t compare 3.3 == 3.2]
} {0 0}
test textIndex-9.4 {TkTextIndexCmp} {
    list [.t compare 2.1 < 3.2] [.t compare 2.1 == 3.2]
} {1 0}
test textIndex-9.5 {TkTextIndexCmp} {
    list [.t compare 4.1 < 3.2] [.t compare 4.1 == 3.2]
} {0 0}

test textIndex-10.1 {ForwBack} {
    list [catch {.t index {2.3 + x}} msg] $msg
} {1 {bad text index "2.3 + x"}}
test textIndex-10.2 {ForwBack} {
    list [catch {.t index {2.3 + 2 chars}} msg] $msg
} {0 2.5}
test textIndex-10.3 {ForwBack} {
    list [catch {.t index {2.3 + 2c}} msg] $msg
} {0 2.5}
test textIndex-10.4 {ForwBack} {
    list [catch {.t index {2.3 - 3ch}} msg] $msg
} {0 2.0}
test textIndex-10.5 {ForwBack} {
    list [catch {.t index {1.3 + 3 lines}} msg] $msg
} {0 4.3}
test textIndex-10.6 {ForwBack} {
    list [catch {.t index {2.3 -1l}} msg] $msg
} {0 1.3}
test textIndex-10.7 {ForwBack} {
    list [catch {.t index {2.3 -1 gorp}} msg] $msg
} {1 {bad text index "2.3 -1 gorp"}}
test textIndex-10.8 {ForwBack} {
    list [catch {.t index {2.3 - 4 lines}} msg] $msg
} {0 1.3}
test textIndex-10.9 {ForwBack} {
    .t mark set insert 2.0
    list [catch {.t index {insert -0 chars}} msg] $msg
} {0 2.0}
test textIndex-10.10 {ForwBack} {
    .t mark set insert 2.end
    list [catch {.t index {insert +0 chars}} msg] $msg
} {0 2.13}

test textIndex-11.1 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 -7
} {1.3 3}
test textIndex-11.2 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 5
} {2.8 8}
test textIndex-11.3 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 10
} {2.13 13}
test textIndex-11.4 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 11
} {3.0 0}
test textIndex-11.5 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 57
} {7.6 6}
test textIndex-11.6 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 58
} {8.0 0}
test textIndex-11.7 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 59
} {8.0 0}

test textIndex-12.1 {TkTextIndexForwChars} {
    # (charCount < 0)
    .t index {2.3 + -7 chars}
} 1.3
test textIndex-12.2 {TkTextIndexForwChars} {
    # not (charCount < 0)
    .t index {2.3 + 5 chars}
} 2.8
test textIndex-12.3 {TkTextIndexForwChars: find index} {
    # for ( ; segPtr != NULL; segPtr = segPtr->nextPtr)
    # one loop
    .t index {2.3 + 9 chars}
} 2.12
test textIndex-12.4 {TkTextIndexForwChars: find index} {
    # for ( ; segPtr != NULL; segPtr = segPtr->nextPtr)
    # multiple loops
    .t mark set foo 2.5
    set x [.t index {2.3 + 9 chars}]
    .t mark unset foo
    set x
} 2.12
test textIndex-12.5 {TkTextIndexForwChars: find index} {
    # for ( ; segPtr != NULL; segPtr = segPtr->nextPtr)
    # border condition: last char

    .t index {2.3 + 10 chars}
} 2.13
test textIndex-12.6 {TkTextIndexForwChars: find index} {
    # for ( ; segPtr != NULL; segPtr = segPtr->nextPtr)
    # border condition: segPtr == NULL -> beginning of next line
    
    .t index {2.3 + 11 chars}
} 3.0
test textIndex-12.7 {TkTextIndexForwChars: find index} {
    # (segPtr->typePtr == &tkTextCharType)
    .t index {2.3 + 2 chars}
} 2.5
test textIndex-12.8 {TkTextIndexForwChars: find index} {
    # (charCount == 0)
    # No more chars, so we found byte offset.

    .t index {2.3 + 2 chars}
} 2.5
test textIndex-12.9 {TkTextIndexForwChars: find index} {
    # not (segPtr->typePtr == &tkTextCharType)

    .t image create 2.4 -image textimage
    set x [.t get {2.3 + 3 chars}]
    .t delete 2.4
    set x    
} "f"
test textIndex-12.10 {TkTextIndexForwChars: find index} {
    # dstPtr->byteIndex += segPtr->size - byteOffset
    # When moving to next segment, account for bytes in last segment.
    # Wrong answer would be 2.4

    .t mark set foo 2.4
    set x [.t index {2.3 + 5 chars}]
    .t mark unset foo
    set x
} 2.8
test textIndex-12.11 {TkTextIndexForwChars: go to next line} {
    # (linePtr == NULL)
    .t index {7.6 + 3 chars}
} 8.0
test textIndex-12.12 {TkTextIndexForwChars: go to next line} {
    # Reset byteIndex to 0 now that we are on a new line.
    # Wrong answer would be 2.9
    .t index {1.3 + 6 chars}
} 2.2
test textIndex-12.13 {TkTextIndexForwChars} {
    # right to end
    .t index {2.3 + 56 chars}
} 8.0
test textIndex-12.14 {TkTextIndexForwChars} {
    # try to go past end
    .t index {2.3 + 57 chars}
} 8.0

test textIndex-13.1 {TkTextIndexBackBytes} {testtext} {
    testtext .t backbytes 3.2 -10
} {4.6 6}
test textIndex-13.2 {TkTextIndexBackBytes} {testtext} {
    testtext .t backbytes 3.2 2
} {3.0 0}
test textIndex-13.3 {TkTextIndexBackBytes} {testtext} {
    testtext .t backbytes 3.2 3
} {2.13 13}
test textIndex-13.4 {TkTextIndexBackBytes} {testtext} {
    testtext .t backbytes 3.2 22
} {1.1 1}
test textIndex-13.5 {TkTextIndexBackBytes} {testtext} {
    testtext .t backbytes 3.2 23
} {1.0 0}
test textIndex-13.6 {TkTextIndexBackBytes} {testtext} {
    testtext .t backbytes 3.2 24
} {1.0 0}

test textIndex-14.1 {TkTextIndexBackChars} {
    # (charCount < 0)
    .t index {3.2 - -10 chars}
} 4.6
test textIndex-14.2 {TkTextIndexBackChars} {
    # not (charCount < 0)
    .t index {3.2 - 2 chars}
} 3.0
test textIndex-14.3 {TkTextIndexBackChars: find starting segment} {
    # for (segPtr = dstPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr)
    # single loop

    .t index {3.2 - 3 chars}
} 2.13
test textIndex-14.4 {TkTextIndexBackChars: find starting segment} {
    # for (segPtr = dstPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr)
    # multiple loop

    .t mark set foo1 2.5
    .t mark set foo2 2.7
    .t mark set foo3 2.10
    set x [.t index {2.9 - 1 chars}]
    .t mark unset foo1 foo2 foo3
    set x
} 2.8
test textIndex-14.5 {TkTextIndexBackChars: find starting seg and offset} {
    # for (segPtr = dstPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr)
    # Make sure segSize was decremented.  Wrong answer would be 2.10

    .t mark set foo 2.2
    set x [.t index {2.9 - 1 char}]
    .t mark unset foo
    set x
} 2.8
test textIndex-14.6 {TkTextIndexBackChars: back over characters} {
    # (segPtr->typePtr == &tkTextCharType)

    .t index {3.2 - 22 chars}
} 1.1
test textIndex-14.7 {TkTextIndexBackChars: loop backwards over chars} {
    # (charCount == 0)
    # No more chars, so we found byte offset.

    .t index {3.4 - 2 chars}
} 3.2
test textIndex-14.8 {TkTextIndexBackChars: loop backwards over chars} {
    # (p == start)
    # Still more chars, but we reached beginning of segment

    .t image create 5.6 -image textimage
    set x [.t index {5.8 - 3 chars}]
    .t delete 5.6
    set x
} 5.5
test textIndex-14.9 {TkTextIndexBackChars: back over image} {
    # not (segPtr->typePtr == &tkTextCharType)

    .t image create 5.6 -image textimage
    set x [.t get {5.8 - 4 chars}]
    .t delete 5.6
    set x
} "G"
test textIndex-14.10 {TkTextIndexBackChars: move to previous segment} {
    # (segPtr != oldPtr)
    # More segments to go

    .t mark set foo 3.4
    set x [.t index {3.5 - 2 chars}]
    .t mark unset foo
    set x
} 3.3
test textIndex-14.11 {TkTextIndexBackChars: move to previous segment} {
    # not (segPtr != oldPtr)
    # At beginning of line.

    .t mark set foo 3.4
    set x [.t index {3.5 - 10 chars}]
    .t mark unset foo
    set x
} 2.9
test textIndex-14.12 {TkTextIndexBackChars: move to previous line} {
    # (lineIndex == 0) 
    .t index {1.5 - 10 chars}
} 1.0
test textIndex-14.13 {TkTextIndexBackChars: move to previous line} {
    # not (lineIndex == 0) 
    .t index {2.5 - 10 chars}
} 1.2
test textIndex-14.14 {TkTextIndexBackChars: move to previous line} {
    # for (segPtr = oldPtr; segPtr != NULL; segPtr = segPtr->nextPtr)
    # Set byteIndex to end of previous line so we can subtract more
    # bytes from it.  Otherwise we get an TkTextIndex with a negative
    # byteIndex.

    .t index {2.5 - 6 chars}
} 1.6
test textIndex-14.15 {TkTextIndexBackChars: UTF} {
    .t get {5.3 - 1 chars}
} y
test textIndex-14.16 {TkTextIndexBackChars: UTF} {
    .t get {5.3 - 2 chars}
} \u4e4f
test textIndex-14.17 {TkTextIndexBackChars: UTF} {
    .t get {5.3 - 3 chars}
} b

proc getword index {
    .t get [.t index "$index wordstart"] [.t index "$index wordend"]
}
test textIndex-15.1 {StartEnd} {
    list [catch {.t index {2.3 lineend}} msg] $msg
} {0 2.13}
test textIndex-15.2 {StartEnd} {
    list [catch {.t index {2.3 linee}} msg] $msg
} {0 2.13}
test textIndex-15.3 {StartEnd} {
    list [catch {.t index {2.3 line}} msg] $msg
} {1 {bad text index "2.3 line"}}
test textIndex-15.4 {StartEnd} {
    list [catch {.t index {2.3 linestart}} msg] $msg
} {0 2.0}
test textIndex-15.5 {StartEnd} {
    list [catch {.t index {2.3 lines}} msg] $msg
} {0 2.0}
test textIndex-15.6 {StartEnd} {
    getword 5.3
} { }
test textIndex-15.7 {StartEnd} {
    getword 5.4
} GIrl
test textIndex-15.8 {StartEnd} {
    getword 5.7
} GIrl
test textIndex-15.9 {StartEnd} {
    getword 5.8
} { }
test textIndex-15.10 {StartEnd} {
    getword 5.14
} x_yz
test textIndex-15.11 {StartEnd} {
    getword 6.2
} #
test textIndex-15.12 {StartEnd} {
    getword 3.4
} 12345
.t tag add x 2.8 2.11
test textIndex-15.13 {StartEnd} {
    list [catch {.t index {2.2 worde}} msg] $msg
} {0 2.13}
test textIndex-15.14 {StartEnd} {
    list [catch {.t index {2.12 words}} msg] $msg
} {0 2.0}
test textIndex-15.15 {StartEnd} {
    list [catch {.t index {2.12 word}} msg] $msg
} {1 {bad text index "2.12 word"}}

test testIndex-16.1 {TkTextPrintIndex} {
    set t [text .t2]
    $t insert end \n
    $t window create end -window [button $t.b]
    set result [$t index end-2c]
    pack $t
    catch {destroy $t}
} 0


test testIndex-16.2 {TkTextPrintIndex} {
    set t [text .t2]
    $t insert end \n
    $t window create end -window [button $t.b]
    set result [$t tag add {} end-2c]
    pack $t
    catch {destroy $t}
} 0

# cleanup
rename textimage {}
catch {destroy .t}
::tcltest::cleanupTests
return













@


1.4
log
@touched all sources to ease next import
@
text
@d9 1
a9 1
# RCS: @@(#) $Id: textIndex.test,v 1.7.6.1 2000/05/04 21:26:29 spolk Exp $
d11 6
a16 3
if {[lsearch [namespace children] ::tcltest] == -1} {
    source [file join [pwd] [file dirname [info script]] defs.tcl]
}
d19 1
a19 3

set ::tcltest::testConfig(testtext) \
	[expr {[info commands testtext] != {}}]
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d6 2
d9 7
a15 4
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: textIndex.test,v 1.8 1999/01/26 04:11:40 jingham Exp $
d17 2
a18 2
if {[string compare test [info procs test]] == 1} then \
  {source defs}
d21 1
a21 5
if [catch {text .t -font {Courier 12} -width 20 -height 10}] {
    puts "The font needed by these tests isn't available, so I'm"
    puts "going to skip the tests."
    return
}
d39 1
a39 1
bOy GIrl .#@@? x_yz
d43 98
a140 1
test textIndex-1.1 {TkTextMakeIndex} {
d143 2
a144 1
test textIndex-1.2 {TkTextMakeIndex} {
d147 2
a148 1
test textIndex-1.3 {TkTextMakeIndex} {
d151 2
a152 1
test textIndex-1.4 {TkTextMakeIndex} {
d155 2
a156 1
test textIndex-1.5 {TkTextMakeIndex} {
d159 12
a170 1
test textIndex-1.6 {TkTextMakeIndex} {
d173 8
a180 2
test textIndex-1.7 {TkTextMakeIndex} {
    .t index 3.6
d182 2
a183 1
test textIndex-1.8 {TkTextMakeIndex} {
d186 28
a213 39
test textIndex-1.9 {TkTextMakeIndex} {
    .t index 7.2
} 7.2
test textIndex-1.10 {TkTextMakeIndex} {
    .t index 8.0
} 8.0
test textIndex-1.11 {TkTextMakeIndex} {
    .t index 8.1
} 8.0
test textIndex-1.12 {TkTextMakeIndex} {
    .t index 9.0
} 8.0

.t tag add x 2.3 2.6
test textIndex-2.1 {TkTextIndexToSeg} {
    .t get 2.0
} a
test textIndex-2.2 {TkTextIndexToSeg} {
    .t get 2.2
} c
test textIndex-2.3 {TkTextIndexToSeg} {
    .t get 2.3
} d
test textIndex-2.4 {TkTextIndexToSeg} {
    .t get 2.6
} g
test textIndex-2.5 {TkTextIndexToSeg} {
    .t get 2.7
} h
test textIndex-2.6 {TkTextIndexToSeg} {
    .t get 2.12
} m
test textIndex-2.7 {TkTextIndexToSeg} {
    .t get 2.13
} \n
test textIndex-2.8 {TkTextIndexToSeg} {
    .t get 2.14
} \n
.t tag delete x
d255 1
a255 1
test textIndex-5.1 {TkTextGetIndex, "@@"} {fonts} {
d354 2
a355 2
    list [catch {.t index {2.3 + 3 lines}} msg] $msg
} {0 5.3}
d365 30
d396 2
a397 1
test textIndex-11.1 {TkTextIndexForwChars} {
d400 2
a401 1
test textIndex-11.2 {TkTextIndexForwChars} {
d404 17
a420 1
test textIndex-11.3 {TkTextIndexForwChars} {
d423 4
a426 1
test textIndex-11.4 {TkTextIndexForwChars} {
d429 39
a467 4
test textIndex-11.5 {TkTextIndexForwChars} {
    .t index {2.3 + 55 chars}
} 7.6
test textIndex-11.6 {TkTextIndexForwChars} {
d470 2
a471 1
test textIndex-11.7 {TkTextIndexForwChars} {
d475 21
a495 1
test textIndex-12.1 {TkTextIndexBackChars} {
d498 2
a499 1
test textIndex-12.2 {TkTextIndexBackChars} {
d502 4
a505 1
test textIndex-12.3 {TkTextIndexBackChars} {
d508 23
a530 1
test textIndex-12.4 {TkTextIndexBackChars} {
d533 44
a576 5
test textIndex-12.5 {TkTextIndexBackChars} {
    .t index {3.2 - 23 chars}
} 1.0
test textIndex-12.6 {TkTextIndexBackChars} {
    .t index {3.2 - 24 chars}
d578 21
d603 1
a603 1
test textIndex-13.1 {StartEnd} {
d606 1
a606 1
test textIndex-13.2 {StartEnd} {
d609 1
a609 1
test textIndex-13.3 {StartEnd} {
d612 1
a612 1
test textIndex-13.4 {StartEnd} {
d615 1
a615 1
test textIndex-13.5 {StartEnd} {
d618 1
a618 1
test textIndex-13.6 {StartEnd} {
d621 1
a621 1
test textIndex-13.7 {StartEnd} {
d624 1
a624 1
test textIndex-13.8 {StartEnd} {
d627 1
a627 1
test textIndex-13.9 {StartEnd} {
d630 1
a630 1
test textIndex-13.10 {StartEnd} {
d633 1
a633 1
test textIndex-13.11 {StartEnd} {
d636 1
a636 1
test textIndex-13.12 {StartEnd} {
d640 1
a640 1
test textIndex-13.13 {StartEnd} {
d643 1
a643 1
test textIndex-13.14 {StartEnd} {
d646 1
a646 1
test textIndex-13.15 {StartEnd} {
d650 21
d672 15
a686 1
concat
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@a5 2
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
d7 4
a10 5
# RCS: @@(#) $Id: textIndex.test,v 1.7.6.1 2000/05/04 21:26:29 spolk Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    source [file join [pwd] [file dirname [info script]] defs.tcl]
}
d12 2
a13 4
# Some tests require the testtext command

set ::tcltest::testConfig(testtext) \
	[expr {[info commands testtext] != {}}]
d16 5
a20 1
text .t -font {Courier -12} -width 20 -height 10
d38 1
a38 1
b\u4e4fy GIrl .#@@? x_yz
d42 1
a42 98
image create photo textimage -width 10 -height 10
textimage put red -to 0 0 9 9

test textIndex-1.1 {TkTextMakeByteIndex} {testtext} {
    # (lineIndex < 0)
    testtext .t byteindex -1 3
} {1.0 0}
test textIndex-1.2 {TkTextMakeByteIndex} {testtext} {
    # (lineIndex < 0), because lineIndex == strtol(argv[2]) - 1
    testtext .t byteindex 0 3
} {1.0 0}
test textIndex-1.3 {TkTextMakeByteIndex} {testtext} {
    # not (lineIndex < 0)
    testtext .t byteindex 1 3
} {1.3 3}
test textIndex-1.4 {TkTextMakeByteIndex} {testtext} {
    # (byteIndex < 0)
    testtext .t byteindex 3 -1
} {3.0 0}
test textIndex-1.5 {TkTextMakeByteIndex} {testtext} {
    # not (byteIndex < 0)
    testtext .t byteindex 3 3
} {3.3 3}
test textIndex-1.6 {TkTextMakeByteIndex} {testtext} {
    # (indexPtr->linePtr == NULL)
    testtext .t byteindex 9 2
} {8.0 0}
test textIndex-1.7 {TkTextMakeByteIndex} {testtext} {
    # not (indexPtr->linePtr == NULL)
    testtext .t byteindex 7 2
} {7.2 2}
test textIndex-1.8 {TkTextMakeByteIndex: shortcut for 0} {testtext} {
    # (byteIndex == 0)
    testtext .t byteindex 1 0
} {1.0 0}
test textIndex-1.9 {TkTextMakeByteIndex: shortcut for 0} {testtext} {
    # not (byteIndex == 0)
    testtext .t byteindex 3 80
} {3.5 5}
test textIndex-1.10 {TkTextMakeByteIndex: verify index is in range} {testtext} {
    # for (segPtr = indexPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr) 
    # one segment

    testtext .t byteindex 3 5
} {3.5 5}
test textIndex-1.11 {TkTextMakeByteIndex: verify index is in range} {testtext} {
    # for (segPtr = indexPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr)
    #     index += segPtr->size
    # Multiple segments, make sure add segment size to index.

    .t mark set foo 3.2 
    set x [testtext .t byteindex 3 7]
    .t mark unset foo
    set x
} {3.5 5}
test textIndex-1.12 {TkTextMakeByteIndex: verify index is in range} {testtext} {
    # (segPtr == NULL)
    testtext .t byteindex 3 7
} {3.5 5}
test textIndex-1.13 {TkTextMakeByteIndex: verify index is in range} {testtext} {
    # not (segPtr == NULL)
    testtext .t byteindex 3 4
} {3.4 4}
test textIndex-1.14 {TkTextMakeByteIndex: verify index is in range} {testtext} {
    # (index + segPtr->size > byteIndex)
    # in this segment.

    testtext .t byteindex 3 4
} {3.4 4}
test textIndex-1.15 {TkTextMakeByteIndex: verify index is in range} {testtext} {
    # (index + segPtr->size > byteIndex), index != 0
    # in this segment.

    .t mark set foo 3.2
    set x [testtext .t byteindex 3 4]
    .t mark unset foo
    set x
} {3.4 4}
test textIndex-1.16 {TkTextMakeByteIndex: UTF-8 characters} {testtext} {
    testtext .t byteindex 5 100
} {5.18 20}
test textIndex-1.17 {TkTextMakeByteIndex: prevent splitting UTF-8 character} \
	{testtext} {
    # ((byteIndex > index) && (segPtr->typePtr == &tkTextCharType)) 
    # Wrong answer would be \xb9 (the 2nd byte of UTF rep of 0x4e4f).

    set x [testtext .t byteindex 5 2]
    list $x [.t get insert]
} {{5.2 4} y}
test textIndex-1.18 {TkTextMakeByteIndex: prevent splitting UTF-8 character} \
	{testtext} {
    # ((byteIndex > index) && (segPtr->typePtr == &tkTextCharType)) 
    testtext .t byteindex 5 1
    .t get insert
} "\u4e4f"

test textIndex-2.1 {TkTextMakeCharIndex} {
    # (lineIndex < 0)
d45 1
a45 2
test textIndex-2.2 {TkTextMakeCharIndex} {
    # (lineIndex < 0), because lineIndex == strtol(argv[2]) - 1
d48 1
a48 2
test textIndex-2.3 {TkTextMakeCharIndex} {
    # not (lineIndex < 0)
d51 1
a51 2
test textIndex-2.4 {TkTextMakeCharIndex} {
    # (charIndex < 0)
d54 1
a54 2
test textIndex-2.5 {TkTextMakeCharIndex} {
    # (charIndex < 0)
d57 1
a57 12
test textIndex-2.6 {TkTextMakeCharIndex} {
    # (indexPtr->linePtr == NULL)
    .t index 9.2
} 8.0
test textIndex-2.7 {TkTextMakeCharIndex} {
    # not (indexPtr->linePtr == NULL)
    .t index 7.2
} 7.2
test textIndex-2.8 {TkTextMakeCharIndex: verify index is in range} {
    # for (segPtr = indexPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr)
    # one segment

d60 2
a61 8
test textIndex-2.9 {TkTextMakeCharIndex: verify index is in range} {
    # for (segPtr = indexPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr)
    # Multiple segments, make sure add segment size to index.

    .t mark set foo 3.2 
    set x [.t index 3.7]
    .t mark unset foo
    set x
d63 1
a63 2
test textIndex-2.10 {TkTextMakeCharIndex: verify index is in range} {
    # (segPtr == NULL)
d66 39
a104 28
test textIndex-2.11 {TkTextMakeCharIndex: verify index is in range} {
    # not (segPtr == NULL)
    .t index 3.4
} 3.4
test textIndex-2.12 {TkTextMakeCharIndex: verify index is in range} {
    # (segPtr->typePtr == &tkTextCharType)
    # Wrong answer would be \xb9 (the 2nd byte of UTF rep of 0x4e4f).

    .t mark set insert 5.2
    .t get insert
} y
test textIndex-2.13 {TkTextMakeCharIndex: verify index is in range} {
    # not (segPtr->typePtr == &tkTextCharType)

    .t image create 5.2 -image textimage
    .t mark set insert 5.5
    set x [.t get insert]
    .t delete 5.2
    set x
} "G"
test textIndex-2.14 {TkTextMakeCharIndex: verify index is in range} {
    # (charIndex < segPtr->size)

    .t image create 5.0 -image textimage
    set x [.t index 5.0]
    .t delete 5.0
    set x
} 5.0
d146 1
a146 1
test textIndex-5.1 {TkTextGetIndex, "@@"} {nonPortable fonts} {
d245 2
a246 2
    list [catch {.t index {1.3 + 3 lines}} msg] $msg
} {0 4.3}
a255 30
test textIndex-10.9 {ForwBack} {
    .t mark set insert 2.0
    list [catch {.t index {insert -0 chars}} msg] $msg
} {0 2.0}
test textIndex-10.10 {ForwBack} {
    .t mark set insert 2.end
    list [catch {.t index {insert +0 chars}} msg] $msg
} {0 2.13}

test textIndex-11.1 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 -7
} {1.3 3}
test textIndex-11.2 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 5
} {2.8 8}
test textIndex-11.3 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 10
} {2.13 13}
test textIndex-11.4 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 11
} {3.0 0}
test textIndex-11.5 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 57
} {7.6 6}
test textIndex-11.6 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 58
} {8.0 0}
test textIndex-11.7 {TkTextIndexForwBytes} {testtext} {
    testtext .t forwbytes 2.3 59
} {8.0 0}
d257 1
a257 2
test textIndex-12.1 {TkTextIndexForwChars} {
    # (charCount < 0)
d260 1
a260 2
test textIndex-12.2 {TkTextIndexForwChars} {
    # not (charCount < 0)
d263 1
a263 17
test textIndex-12.3 {TkTextIndexForwChars: find index} {
    # for ( ; segPtr != NULL; segPtr = segPtr->nextPtr)
    # one loop
    .t index {2.3 + 9 chars}
} 2.12
test textIndex-12.4 {TkTextIndexForwChars: find index} {
    # for ( ; segPtr != NULL; segPtr = segPtr->nextPtr)
    # multiple loops
    .t mark set foo 2.5
    set x [.t index {2.3 + 9 chars}]
    .t mark unset foo
    set x
} 2.12
test textIndex-12.5 {TkTextIndexForwChars: find index} {
    # for ( ; segPtr != NULL; segPtr = segPtr->nextPtr)
    # border condition: last char

d266 1
a266 4
test textIndex-12.6 {TkTextIndexForwChars: find index} {
    # for ( ; segPtr != NULL; segPtr = segPtr->nextPtr)
    # border condition: segPtr == NULL -> beginning of next line
    
d269 4
a272 39
test textIndex-12.7 {TkTextIndexForwChars: find index} {
    # (segPtr->typePtr == &tkTextCharType)
    .t index {2.3 + 2 chars}
} 2.5
test textIndex-12.8 {TkTextIndexForwChars: find index} {
    # (charCount == 0)
    # No more chars, so we found byte offset.

    .t index {2.3 + 2 chars}
} 2.5
test textIndex-12.9 {TkTextIndexForwChars: find index} {
    # not (segPtr->typePtr == &tkTextCharType)

    .t image create 2.4 -image textimage
    set x [.t get {2.3 + 3 chars}]
    .t delete 2.4
    set x    
} "f"
test textIndex-12.10 {TkTextIndexForwChars: find index} {
    # dstPtr->byteIndex += segPtr->size - byteOffset
    # When moving to next segment, account for bytes in last segment.
    # Wrong answer would be 2.4

    .t mark set foo 2.4
    set x [.t index {2.3 + 5 chars}]
    .t mark unset foo
    set x
} 2.8
test textIndex-12.11 {TkTextIndexForwChars: go to next line} {
    # (linePtr == NULL)
    .t index {7.6 + 3 chars}
} 8.0
test textIndex-12.12 {TkTextIndexForwChars: go to next line} {
    # Reset byteIndex to 0 now that we are on a new line.
    # Wrong answer would be 2.9
    .t index {1.3 + 6 chars}
} 2.2
test textIndex-12.13 {TkTextIndexForwChars} {
    # right to end
d275 1
a275 2
test textIndex-12.14 {TkTextIndexForwChars} {
    # try to go past end
d279 1
a279 21
test textIndex-13.1 {TkTextIndexBackBytes} {testtext} {
    testtext .t backbytes 3.2 -10
} {4.6 6}
test textIndex-13.2 {TkTextIndexBackBytes} {testtext} {
    testtext .t backbytes 3.2 2
} {3.0 0}
test textIndex-13.3 {TkTextIndexBackBytes} {testtext} {
    testtext .t backbytes 3.2 3
} {2.13 13}
test textIndex-13.4 {TkTextIndexBackBytes} {testtext} {
    testtext .t backbytes 3.2 22
} {1.1 1}
test textIndex-13.5 {TkTextIndexBackBytes} {testtext} {
    testtext .t backbytes 3.2 23
} {1.0 0}
test textIndex-13.6 {TkTextIndexBackBytes} {testtext} {
    testtext .t backbytes 3.2 24
} {1.0 0}

test textIndex-14.1 {TkTextIndexBackChars} {
    # (charCount < 0)
d282 1
a282 2
test textIndex-14.2 {TkTextIndexBackChars} {
    # not (charCount < 0)
d285 1
a285 4
test textIndex-14.3 {TkTextIndexBackChars: find starting segment} {
    # for (segPtr = dstPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr)
    # single loop

d288 1
a288 23
test textIndex-14.4 {TkTextIndexBackChars: find starting segment} {
    # for (segPtr = dstPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr)
    # multiple loop

    .t mark set foo1 2.5
    .t mark set foo2 2.7
    .t mark set foo3 2.10
    set x [.t index {2.9 - 1 chars}]
    .t mark unset foo1 foo2 foo3
    set x
} 2.8
test textIndex-14.5 {TkTextIndexBackChars: find starting seg and offset} {
    # for (segPtr = dstPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr)
    # Make sure segSize was decremented.  Wrong answer would be 2.10

    .t mark set foo 2.2
    set x [.t index {2.9 - 1 char}]
    .t mark unset foo
    set x
} 2.8
test textIndex-14.6 {TkTextIndexBackChars: back over characters} {
    # (segPtr->typePtr == &tkTextCharType)

d291 5
a295 44
test textIndex-14.7 {TkTextIndexBackChars: loop backwards over chars} {
    # (charCount == 0)
    # No more chars, so we found byte offset.

    .t index {3.4 - 2 chars}
} 3.2
test textIndex-14.8 {TkTextIndexBackChars: loop backwards over chars} {
    # (p == start)
    # Still more chars, but we reached beginning of segment

    .t image create 5.6 -image textimage
    set x [.t index {5.8 - 3 chars}]
    .t delete 5.6
    set x
} 5.5
test textIndex-14.9 {TkTextIndexBackChars: back over image} {
    # not (segPtr->typePtr == &tkTextCharType)

    .t image create 5.6 -image textimage
    set x [.t get {5.8 - 4 chars}]
    .t delete 5.6
    set x
} "G"
test textIndex-14.10 {TkTextIndexBackChars: move to previous segment} {
    # (segPtr != oldPtr)
    # More segments to go

    .t mark set foo 3.4
    set x [.t index {3.5 - 2 chars}]
    .t mark unset foo
    set x
} 3.3
test textIndex-14.11 {TkTextIndexBackChars: move to previous segment} {
    # not (segPtr != oldPtr)
    # At beginning of line.

    .t mark set foo 3.4
    set x [.t index {3.5 - 10 chars}]
    .t mark unset foo
    set x
} 2.9
test textIndex-14.12 {TkTextIndexBackChars: move to previous line} {
    # (lineIndex == 0) 
    .t index {1.5 - 10 chars}
a296 21
test textIndex-14.13 {TkTextIndexBackChars: move to previous line} {
    # not (lineIndex == 0) 
    .t index {2.5 - 10 chars}
} 1.2
test textIndex-14.14 {TkTextIndexBackChars: move to previous line} {
    # for (segPtr = oldPtr; segPtr != NULL; segPtr = segPtr->nextPtr)
    # Set byteIndex to end of previous line so we can subtract more
    # bytes from it.  Otherwise we get an TkTextIndex with a negative
    # byteIndex.

    .t index {2.5 - 6 chars}
} 1.6
test textIndex-14.15 {TkTextIndexBackChars: UTF} {
    .t get {5.3 - 1 chars}
} y
test textIndex-14.16 {TkTextIndexBackChars: UTF} {
    .t get {5.3 - 2 chars}
} \u4e4f
test textIndex-14.17 {TkTextIndexBackChars: UTF} {
    .t get {5.3 - 3 chars}
} b
d301 1
a301 1
test textIndex-15.1 {StartEnd} {
d304 1
a304 1
test textIndex-15.2 {StartEnd} {
d307 1
a307 1
test textIndex-15.3 {StartEnd} {
d310 1
a310 1
test textIndex-15.4 {StartEnd} {
d313 1
a313 1
test textIndex-15.5 {StartEnd} {
d316 1
a316 1
test textIndex-15.6 {StartEnd} {
d319 1
a319 1
test textIndex-15.7 {StartEnd} {
d322 1
a322 1
test textIndex-15.8 {StartEnd} {
d325 1
a325 1
test textIndex-15.9 {StartEnd} {
d328 1
a328 1
test textIndex-15.10 {StartEnd} {
d331 1
a331 1
test textIndex-15.11 {StartEnd} {
d334 1
a334 1
test textIndex-15.12 {StartEnd} {
d338 1
a338 1
test textIndex-15.13 {StartEnd} {
d341 1
a341 1
test textIndex-15.14 {StartEnd} {
d344 1
a344 1
test textIndex-15.15 {StartEnd} {
a347 21
test testIndex-16.1 {TkTextPrintIndex} {
    set t [text .t2]
    $t insert end \n
    $t window create end -window [button $t.b]
    set result [$t index end-2c]
    pack $t
    catch {destroy $t}
} 0


test testIndex-16.2 {TkTextPrintIndex} {
    set t [text .t2]
    $t insert end \n
    $t window create end -window [button $t.b]
    set result [$t tag add {} end-2c]
    pack $t
    catch {destroy $t}
} 0

# cleanup
rename textimage {}
d349 1
a349 15
::tcltest::cleanupTests
return













@


1.1.1.3
log
@import tk 8.4.0
@
text
@d9 1
a9 1
# RCS: @@(#) $Id: textIndex.test,v 1.7 2002/07/13 20:28:35 dgp Exp $
d11 3
a13 6
package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands
d16 3
a18 1
testConstraint testtext [llength [info commands testtext]]
@


