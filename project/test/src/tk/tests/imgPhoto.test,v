head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.4
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.50;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.16;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.29;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.53;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.36;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.39.06;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.01.21.19.55.14;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# This file is a Tcl script to test out the "photo" image type and the
# other procedures in the file tkImgPhoto.c.  It is organized in the
# standard fashion for Tcl tests.
#
# Copyright (c) 1994 The Australian National University
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
#
# Author: Paul Mackerras (paulus@@cs.anu.edu.au)
#
# RCS: @@(#) $Id: imgPhoto.test,v 1.15 2002/10/18 00:48:22 hobbs Exp $

package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands

namespace import -force tcltest::makeFile
namespace import -force tcltest::removeFile

eval image delete [image names]

canvas .c
pack .c
update

set README [makeFile {
README -- Tk test suite design document.
} README-imgPhotot]

# find the teapot.ppm file for use in these tests
# first look in $tk_library/demos/images/teapot.ppm
# then look in <this file>/../../library/demos/images/teapot.ppm
testConstraint hasTeapotPhoto 1
set teapotPhotoFile [file join $tk_library demos images teapot.ppm]
if {![file exists $teapotPhotoFile]} {
    set newLib [file dirname [testsDirectory]]
    set teapotPhotoFile [file join $newLib library demos images teapot.ppm]
    if {![file exists $teapotPhotoFile]} {
	testConstraint hasTeapotPhoto
    }
}

test imgPhoto-1.1 {options for photo images} {
    image create photo p1 -width 79 -height 83
    list [lindex [p1 configure -width] 4] [lindex [p1 configure -height] 4] \
	[image width p1] [image height p1]
} {79 83 79 83}
test imgPhoto-1.2 {options for photo images} {
    list [catch {image create photo p1 -file no.such.file} err] \
	[string tolower $err]
} {1 {couldn't open "no.such.file": no such file or directory}}
test imgPhoto-1.3 {options for photo images} hasTeapotPhoto {
    list [catch {image create photo p1 -file $teapotPhotoFile \
	    -format no.such.format} err] $err
} {1 {image file format "no.such.format" is not supported}}
test imgPhoto-1.4 {options for photo images} hasTeapotPhoto {
    image create photo p1 -file $teapotPhotoFile
    list [image width p1] [image height p1]
} {256 256}
test imgPhoto-1.5 {options for photo images} hasTeapotPhoto {
    image create photo p1 -file $teapotPhotoFile \
	    -format ppm -width 79 -height 83
    list [image width p1] [image height p1] \
	[lindex [p1 configure -file] 4] [lindex [p1 configure -format] 4]
} [list 79 83 $teapotPhotoFile ppm]
test imgPhoto-1.6 {options for photo images} {
    image create photo p1 -palette 2/2/2 -gamma 2.2
    list [format %.1f [lindex [p1 configure -gamma] 4]] \
	    [lindex [p1 configure -palette] 4]
} {2.2 2/2/2}
test imgPhoto-1.7 {options for photo images} {
    list [catch {image create photo p1 -file $README} err] $err
} [subst {1 {couldn't recognize data in image file "$README"}}]
test imgPhoto-1.8 {options for photo images} {
    list [catch {image create photo -blah blah} err] $err
} {1 {unknown option "-blah"}}
test imgPhoto-1.9 {options for photo images - error case} {
    list [catch {image create photo -format} err] $err
} {1 {value for "-format" missing}}
test imgPhoto-1.10 {options for photo images - error case} {
    list [catch {image create photo -data} err] $err
} {1 {value for "-data" missing}}
test imgPhoto-1.11 {options for photo images - error case} {
    list [catch {image create photo p1 -format} err] $err
} {1 {value for "-format" missing}}

test imgPhoto-2.1 {ImgPhotoCreate procedure} {
    eval image delete [image names]
    catch {image create photo -blah blah}
    image names
} {}
test imgPhoto-2.2 {ImgPhotoCreate procedure} {
    eval image delete [image names]
    image create photo image1
    list [info commands image1] [image names] \
	    [image width image1] [image height image1]
} {image1 image1 0 0}
# test imgPhoto-2.3 {ImgPhotoCreate procedure: creation failure} {
#     image create photo p1
#     image create photo p2 -width 10 -height 10
#     catch {image create photo p2 -file bogus.img} msg
#     p1 copy p2
#     set msg
# } {couldn't open "bogus.img": no such file or directory}

test imgPhoto-3.1 {ImgPhotoConfigureMaster procedure} hasTeapotPhoto {
    image create photo p1 -file $teapotPhotoFile
    p1 configure -file $teapotPhotoFile
} {}
test imgPhoto-3.2 {ImgPhotoConfigureMaster procedure} hasTeapotPhoto {
    image create photo p1 -file $teapotPhotoFile
    list [catch {p1 configure -file bogus} err] [string tolower $err] \
	[image width p1] [image height p1]
} {1 {couldn't open "bogus": no such file or directory} 256 256}
test imgPhoto-3.3 {ImgPhotoConfigureMaster procedure} hasTeapotPhoto {
    image create photo p1
    .c create image 10 10 -image p1 -tags p1.1 -anchor nw
    .c create image 300 10 -image p1 -tags p1.2 -anchor nw
    update
    p1 configure -file $teapotPhotoFile
    update
    list [image width p1] [image height p1] [.c bbox p1.1] [.c bbox p1.2]
} {256 256 {10 10 266 266} {300 10 556 266}}

eval image delete [image names]
image create photo p1
.c create image 10 10 -image p1
update

test imgPhoto-4.1 {ImgPhotoCmd procedure} {
    list [catch {p1} err] $err
} {1 {wrong # args: should be "p1 option ?arg arg ...?"}}
test imgPhoto-4.2 {ImgPhotoCmd procedure} {
    list [catch {p1 blah} err] $err
} {1 {bad option "blah": must be blank, cget, configure, copy, data, get, put, read, redither, transparency, or write}}
test imgPhoto-4.3 {ImgPhotoCmd procedure: blank option} {
    p1 blank
    list [catch {p1 blank x} err] $err
} {1 {wrong # args: should be "p1 blank"}}
test imgPhoto-4.4 {ImgPhotoCmd procedure: cget option} {
    list [catch {p1 cget} msg] $msg
} {1 {wrong # args: should be "p1 cget option"}}
test imgPhoto-4.5 {ImgPhotoCmd procedure: cget option} {
    image create photo p2 -width 25 -height 30
    list [p2 cget -width] [p2 cget -height]
} {25 30}
test imgPhoto-4.6 {ImgPhotoCmd procedure: configure option} {
    llength [p1 configure]
} {7}
test imgPhoto-4.7 {ImgPhotoCmd procedure: configure option} {
    p1 conf -palette 3/4/2
    p1 configure -palette
} {-palette {} {} {} 3/4/2}
test imgPhoto-4.8 {ImgPhotoCmd procedure: configure option} {
    list [catch {p1 configure -blah} msg] $msg
} {1 {unknown option "-blah"}}
test imgPhoto-4.9 {ImgPhotoCmd procedure: configure option} {
    list [catch {p1 configure -palette {} -gamma} msg] $msg
} {1 {value for "-gamma" missing}}
test imgPhoto-4.10 {ImgPhotoCmd procedure: copy option} hasTeapotPhoto {
    image create photo p2 -file $teapotPhotoFile
    p1 configure -width 0 -height 0 -palette {} -gamma 1
    p1 copy p2
    list [image width p1] [image height p1] [p1 get 100 100]
} {256 256 {169 117 90}}
test imgPhoto-4.11 {ImgPhotoCmd procedure: copy option} {
    list [catch {p1 copy} msg] $msg
} {1 {wrong # args: should be "p1 copy source-image ?-compositingrule rule? ?-from x1 y1 x2 y2? ?-to x1 y1 x2 y2? ?-zoom x y? ?-subsample x y?"}}
test imgPhoto-4.12 {ImgPhotoCmd procedure: copy option} {
    list [catch {p1 copy blah} msg] $msg
} {1 {image "blah" doesn't exist or is not a photo image}}
test imgPhoto-4.13 {ImgPhotoCmd procedure: copy option} {
    list [catch {p1 copy p2 -blah} msg] $msg
} {1 {unrecognized option "-blah": must be -compositingrule, -from, -shrink, -subsample, -to, or -zoom}}
test imgPhoto-4.14 {ImgPhotoCmd procedure: copy option} {
    list [catch {p1 copy p2 -from -to} msg] $msg
} {1 {the "-from" option requires one to four integer values}}
test imgPhoto-4.15 {ImgPhotoCmd procedure: copy option} {
    p1 copy p2
    p1 copy p2 -from 0 70 60 120 -shrink
    list [image width p1] [image height p1] [p1 get 20 10]
} {60 50 {215 154 120}}
test imgPhoto-4.16 {ImgPhotoCmd procedure: copy option} {
    p1 copy p2 -from 60 120 0 70 -to 20 50
    list [image width p1] [image height p1] [p1 get 40 80]
} {80 100 {19 92 192}}
test imgPhoto-4.17 {ImgPhotoCmd procedure: copy option} {
    p1 copy p2 -from 0 120 60 70 -to 0 0 100 100
    list [image width p1] [image height p1] [p1 get 80 60]
} {100 100 {215 154 120}}
test imgPhoto-4.18 {ImgPhotoCmd procedure: copy option} {
    p1 copy p2 -from 60 70 0 120 -zoom 2
    list [image width p1] [image height p1] [p1 get 100 50]
} {120 100 {169 99 47}}
test imgPhoto-4.19 {ImgPhotoCmd procedure: copy option} {
    p1 copy p2 -from 0 70 60 120
    list [image width p1] [image height p1] [p1 get 100 50]
} {120 100 {169 99 47}}
test imgPhoto-4.20 {ImgPhotoCmd procedure: copy option} {
    p1 copy p2 -from 20 20 200 180 -subsample 2 -shrink
    list [image width p1] [image height p1] [p1 get 50 30]
} {90 80 {207 146 112}}
test imgPhoto-4.21 {ImgPhotoCmd procedure: copy option} {
    p1 copy p2
    set result [list [image width p1] [image height p1]]
    p1 conf -width 49 -height 51
    lappend result [image width p1] [image height p1]
    p1 copy p2
    lappend result [image width p1] [image height p1]
    p1 copy p2 -from 0 0 10 10 -shrink
    lappend result [image width p1] [image height p1]
    p1 conf -width 0
    p1 copy p2 -from 0 0 10 10 -shrink
    lappend result [image width p1] [image height p1]
    p1 conf -height 0
    p1 copy p2 -from 0 0 10 10 -shrink
    lappend result [image width p1] [image height p1]
} {256 256 49 51 49 51 49 51 10 51 10 10}
test imgPhoto-4.22 {ImgPhotoCmd procedure: get option} hasTeapotPhoto {
    p1 read $teapotPhotoFile
    list [p1 get 100 100] [p1 get 150 100] [p1 get 100 150]
} {{169 117 90} {172 115 84} {35 35 35}}
test imgPhoto-4.23 {ImgPhotoCmd procedure: get option} {
    list [catch {p1 get 256 0} err] $err
} {1 {p1 get: coordinates out of range}}
test imgPhoto-4.24 {ImgPhotoCmd procedure: get option} {
    list [catch {p1 get 0 -1} err] $err
} {1 {p1 get: coordinates out of range}}
test imgPhoto-4.25 {ImgPhotoCmd procedure: get option} {
    list [catch {p1 get} err] $err
} {1 {wrong # args: should be "p1 get x y"}}
test imgPhoto-4.26 {ImgPhotoCmd procedure: put option} {
    list [catch {p1 put} err] $err
} {1 {wrong # args: should be "p1 put data ?options?"}}
test imgPhoto-4.27 {ImgPhotoCmd procedure: put option} {
    list [catch {p1 put {{white} {white white}}} err] $err
} {1 {all elements of color list must have the same number of elements}}
test imgPhoto-4.28 {ImgPhotoCmd procedure: put option} {
    list [catch {p1 put {{blahgle}}} err] $err
} {1 {can't parse color "blahgle"}}
test imgPhoto-4.29 {ImgPhotoCmd procedure: put option} {
    p1 put -to 10 10 20 20 {{white}}
    p1 get 19 19
} {255 255 255}
test imgPhoto-4.30 {ImgPhotoCmd procedure: read option} {
    list [catch {p1 read} err] $err
} {1 {wrong # args: should be "p1 read fileName ?options?"}}
test imgPhoto-4.31 {ImgPhotoCmd procedure: read option} hasTeapotPhoto {
    list [catch {p1 read $teapotPhotoFile -zoom 2} err] $err
} {1 {unrecognized option "-zoom": must be -format, -from, -shrink, or -to}}
test imgPhoto-4.32 {ImgPhotoCmd procedure: read option} {
    list [catch {p1 read bogus} err] [string tolower $err]
} {1 {couldn't open "bogus": no such file or directory}}
test imgPhoto-4.33 {ImgPhotoCmd procedure: read option} hasTeapotPhoto {
    list [catch {p1 read $teapotPhotoFile -format bogus} err] $err
} {1 {image file format "bogus" is not supported}}
test imgPhoto-4.34 {ImgPhotoCmd procedure: read option} {
    list [catch {p1 read $README} err] $err
} [subst {1 {couldn't recognize data in image file "$README"}}]
test imgPhoto-4.35 {ImgPhotoCmd procedure: read option} hasTeapotPhoto {
    p1 read $teapotPhotoFile
    list [image width p1] [image height p1] [p1 get 120 120]
} {256 256 {161 109 82}}
test imgPhoto-4.36 {ImgPhotoCmd procedure: read option} hasTeapotPhoto {
    p1 read $teapotPhotoFile -from 0 70 60 120 -to 10 10 -shrink
    list [image width p1] [image height p1] [p1 get 29 19]
} {70 60 {244 180 144}}
test imgPhoto-4.37 {ImgPhotoCmd procedure: redither option} {
    p1 redither
    list [catch {p1 redither x} err] $err
} {1 {wrong # args: should be "p1 redither"}}
test imgPhoto-4.38 {ImgPhotoCmd procedure: write option} {
    list [catch {p1 write} err] $err
} {1 {wrong # args: should be "p1 write fileName ?options?"}}
test imgPhoto-4.39 {ImgPhotoCmd procedure: write option} {
    list [catch {p1 write teapot.tmp -format bogus} err] $err
} {1 {image file format "bogus" is unknown}}
eval image delete [image names]
image create photo p1
test imgPhoto-4.40 {ImgPhotoCmd procedure: transparency option} {
    list [catch {p1 transparency} err] $err
} {1 {wrong # args: should be "p1 transparency option ?arg arg ...?"}}
test imgPhoto-4.41 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get} err] $err
} {1 {wrong # args: should be "p1 transparency get x y"}}
test imgPhoto-4.42 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get 0} err] $err
} {1 {wrong # args: should be "p1 transparency get x y"}}
test imgPhoto-4.43 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get 0 0 0} err] $err
} {1 {wrong # args: should be "p1 transparency get x y"}}
test imgPhoto-4.44 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get bogus 0} err] $err
} {1 {expected integer but got "bogus"}}
test imgPhoto-4.45 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get 0 bogus} err] $err
} {1 {expected integer but got "bogus"}}
test imgPhoto-4.46 {ImgPhotoCmd procedure: transparency get option} {
    p1 put white
    p1 transparency get 0 0
} 0
test imgPhoto-4.47 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get 1 0} err] $err
} {1 {p1 transparency get: coordinates out of range}}
test imgPhoto-4.48 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get -1 0} err] $err
} {1 {p1 transparency get: coordinates out of range}}
test imgPhoto-4.49 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get 0 1} err] $err
} {1 {p1 transparency get: coordinates out of range}}
test imgPhoto-4.50 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get 0 -1} err] $err
} {1 {p1 transparency get: coordinates out of range}}
test imgPhoto-4.51 {ImgPhotoCmd procedure: transparency get option} {
    p1 blank
    p1 transparency get 0 0
} 1
test imgPhoto-4.52 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set} err] $err
} {1 {wrong # args: should be "p1 transparency set x y boolean"}}
test imgPhoto-4.53 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0} err] $err
} {1 {wrong # args: should be "p1 transparency set x y boolean"}}
test imgPhoto-4.54 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0 0} err] $err
} {1 {wrong # args: should be "p1 transparency set x y boolean"}}
test imgPhoto-4.55 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0 0 0 0} err] $err
} {1 {wrong # args: should be "p1 transparency set x y boolean"}}
test imgPhoto-4.56 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set bogus 0 0} err] $err
} {1 {expected integer but got "bogus"}}
test imgPhoto-4.57 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0 bogus 0} err] $err
} {1 {expected integer but got "bogus"}}
test imgPhoto-4.58 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0 0 bogus} err] $err
} {1 {expected boolean value but got "bogus"}}
test imgPhoto-4.59 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 1 0 0} err] $err
} {1 {p1 transparency set: coordinates out of range}}
test imgPhoto-4.60 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set -1 0 0} err] $err
} {1 {p1 transparency set: coordinates out of range}}
test imgPhoto-4.61 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0 1 0} err] $err
} {1 {p1 transparency set: coordinates out of range}}
test imgPhoto-4.62 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0 -1 0} err] $err
} {1 {p1 transparency set: coordinates out of range}}
test imgPhoto-4.63 {ImgPhotoCmd procedure: transparency set option} {
    p1 transparency set 0 0 false
    p1 transparency get 0 0
} 0
test imgPhoto-4.64 {ImgPhotoCmd procedure: transparency set option} {
    p1 transparency set 0 0 true
    p1 transparency get 0 0
} 1
# Now for some heftier testing, checking that setting and resetting of
# pixels' transparency status doesn't "leak" with any one-off errors.
proc checkImgTrans {img width height} {
    set result {}
    for {set x 0} {$x<$width} {incr x} {
	for {set y 0} {$y<$height} {incr y} {
	    if {[$img transparency get $x $y]} {
		lappend result $x $y
	    }
	}
    }
    return $result
}
test imgPhoto-4.65 {ImgPhotoCmd procedure: transparency get option} {
    p1 put white -to 0 0 3 3
    checkImgTrans p1 3 3
} {}
test imgPhoto-4.66 {ImgPhotoCmd procedure: transparency get option} {
    p1 blank
    checkImgTrans p1 3 3
} {0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2}
proc checkImgTransLoopSetReset {img width height} {
    set result {}
    for {set x 0} {$x<$width} {incr x} {
	for {set y 0} {$y<$height} {incr y} {
	    $img put white -to 0 0 3 3
	    $img transparency set $x $y 1
	    set result [concat $result [checkImgTrans $img $width $height]]
	    lappend result ,
	    $img transparency set $x $y 0
	    set result [concat $result [checkImgTrans $img $width $height]]
	    lappend result .
	}
    }
    return $result
}
test imgPhoto-4.67 {ImgPhotoCmd procedure: transparency set option} {
    checkImgTransLoopSetReset p1 3 3
} {0 0 , . 0 1 , . 0 2 , . 1 0 , . 1 1 , . 1 2 , . 2 0 , . 2 1 , . 2 2 , .}
proc checkImgTransLoopResetSet {img width height} {
    set result {}
    for {set x 0} {$x<$width} {incr x} {
	for {set y 0} {$y<$height} {incr y} {
	    $img blank
	    $img transparency set $x $y 0
	    set result [concat $result [checkImgTrans $img $width $height]]
	    lappend result ,
	    $img transparency set $x $y 1
	    set result [concat $result [checkImgTrans $img $width $height]]
	    lappend result .
	}
    }
    return $result
}
test imgPhoto-4.68 {ImgPhotoCmd procedure: transparency set option} {
    checkImgTransLoopResetSet p1 3 3
} {0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 2 1 0 1 1 1 2 2 0 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 1 0 1 1 1 2 2 0 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 0 2 1 1 1 2 2 0 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 0 2 1 0 1 2 2 0 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 0 2 1 0 1 1 2 0 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 0 2 1 0 1 1 1 2 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 .}
catch {rename checkImgTransLoopSetReset {}}
catch {rename checkImgTransLoopResetSet {}}
# Test the compositing rules for copying images
image create photo p1 -width 3 -height 3
image create photo p2 -width 2 -height 2
test imgPhoto-4.68 {ImgPhotoCmd procedure: copy with -compositingrule} {
    list [catch {p1 copy p2 -to 1 1 -compositingrule} msg] $msg
} {1 {the "-compositingrule" option requires a value}}
test imgPhoto-4.69 {ImgPhotoCmd procedure: copy with -compositingrule} {
    list [catch {p1 copy p2 -to 1 1 -compositingrule BAD} msg] $msg
} {1 {bad compositing rule "BAD": must be overlay or set}}
test imgPhoto-4.70 {ImgPhotoCmd procedure: copy with -compositingrule} {
    # Tests default compositing rule
    p1 blank
    p2 blank
    p1 put white -to 0 0 2 2
    p2 put white -to 0 0 2 2
    p2 transparency set 0 0 true
    p1 copy p2 -to 1 1
    checkImgTrans p1 3 3
} {0 2 2 0}
test imgPhoto-4.71 {ImgPhotoCmd procedure: copy with -compositingrule} {
    p1 blank
    p2 blank
    p1 put white -to 0 0 2 2
    p2 put white -to 0 0 2 2
    p2 transparency set 0 0 true
    p1 copy p2 -to 1 1 -compositingrule overlay
    checkImgTrans p1 3 3
} {0 2 2 0}
test imgPhoto-4.72 {ImgPhotoCmd procedure: copy with -compositingrule} {
    p1 blank
    p2 blank
    p1 put white -to 0 0 2 2
    p2 put white -to 0 0 2 2
    p2 transparency set 0 0 true
    p1 copy p2 -to 1 1 -compositingrule set
    checkImgTrans p1 3 3
} {0 2 1 1 2 0}
catch {rename checkImgTrans {}}

test imgPhoto-5.1 {ImgPhotoGet/Free procedures, shared instances} hasTeapotPhoto {
    eval image delete [image names]
    .c delete all
    image create photo p1 -file $teapotPhotoFile
    .c create image 0 0 -image p1 -tags p1.1
    .c create image 256 0 -image p1 -tags p1.2
    .c create image 0 256 -image p1 -tags p1.3
    update
    .c delete i1.1
    p1 configure -width 1
    update
    .c delete i1.2
    p1 configure -height 1
    update
    image delete p1
} {}

test imgPhoto-6.1 {ImgPhotoDisplay procedure, blank display} {
    .c delete all
    image create photo p1 -width 10 -height 10
    p1 blank
    .c create image 10 10 -image p1
    update
} {}

test imgPhoto-7.1 {ImgPhotoFree procedure, resource freeing} hasTeapotPhoto {
    eval image delete [image names]
    .c delete all
    image create photo p1 -file $teapotPhotoFile
    .c create image 0 0 -image p1 -anchor nw
    update
    .c delete all
    image delete p1
} {}
test imgPhoto-7.2 {ImgPhotoFree procedures, unlinking} hasTeapotPhoto {
    image create photo p1 -file $teapotPhotoFile
    .c create image 10 10 -image p1 -anchor nw
    button .b1 -image p1
    button .b2 -image p1
    button .b3 -image p1
    pack .b1 .b2 .b3
    update
    destroy .b2
    update
    destroy .b3
    update
    destroy .b1
    update
    .c delete all
} {}
test imgPhoto-7.3 {ImgPhotoFree procedures, multiple visuals} hasTeapotPhoto {
    image create photo p1 -file $teapotPhotoFile
    button .b1 -image p1
    frame .f -visual best
    button .f.b2 -image p1
    pack .f.b2
    pack .b1 .f
    update
    destroy .b1
    update
    .f.b2 configure -image {}
    update
    destroy .f
    image delete p1
} {}

test imgPhoto-8.1 {ImgPhotoDelete procedure} hasTeapotPhoto {
    image create photo p2 -file $teapotPhotoFile
    image delete p2
} {}
test imagePhoto-8.2 {ImgPhotoDelete procedure} hasTeapotPhoto {
    image create photo p2 -file $teapotPhotoFile
    rename p2 newp2
    set x [list [info command p2] [info command new*] [newp2 cget -file]]
    image delete p2
    append x [info command new*]
} [list {} newp2 $teapotPhotoFile]
test imagePhoto-8.3 {ImgPhotoDelete procedure, name cleanup} {
    image create photo p1
    image create photo p2 -width 10 -height 10
    image delete p2
    list [catch {p1 copy p2} msg] $msg
} {1 {image "p2" doesn't exist or is not a photo image}}

test imagePhoto-9.1 {ImgPhotoCmdDeletedProc procedure} hasTeapotPhoto {
    image create photo p2 -file $teapotPhotoFile
    rename p2 {}
    list [lsearch -exact [image names] p2] [catch {p2 foo} msg] $msg
} {-1 1 {invalid command name "p2"}}

test imgPhoto-10.1 {Tk_ImgPhotoPutBlock procedure} {
    eval image delete [image names]
    image create photo p1
    p1 put {{#ff0000 #ff0000 #ff0000 #ff0000 #ff0000 #ff0000 #ff0000 #ff0000}} -to 0 0
    p1 put {{#00ff00 #00ff00}} -to 2 0
    list [p1 get 2 0] [p1 get 3 0] [p1 get 4 0]
} {{0 255 0} {0 255 0} {255 0 0}}

test imgPhoto-11.1 {Tk_FindPhoto} {
    eval image delete [image names]
    image create bitmap i1
    image create photo p1
    list [catch {p1 copy i1} msg] $msg
} {1 {image "i1" doesn't exist or is not a photo image}}

test imgPhoto-12.1 {Tk_PhotoPutZoomedBlock} hasTeapotPhoto {
    image create photo p3 -file $teapotPhotoFile
    set result [list [p3 get 50 50] [p3 get 100 100]]
    p3 copy p3 -zoom 2
    lappend result [image width p3] [image height p3] [p3 get 100 100]
    image delete p3
    set result
} {{19 92 192} {169 117 90} 512 512 {19 92 192}}

test imgPhoto-13.1 {check separation of images in different interpreters} {
    eval image delete [image names]
    set data {
	R0lGODlhQgBkAPUAANbWxs7Wxs7OxsbOxsbGxsbGvb3Gvca9vcDAwL21vbW1vbW1tbWtta2t
	ta2ltaWltaWlraWctaWcrZycrZyUrZSUrZSMrZSMpYyMrYyMpYyEpYSEpYR7pYR7nHp7pYRz
	pYRynHtzpXtznHtrnHNrnHNjnGtjnGtjlGtalGNalGNSlGNSjFpSlFpKlFpKjFJKjFJCjFI5
	jEo5jEo5hEoxhEIxhDkphDkhhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAQgBkAAAG
	/kCEcEgsGo/IpHLJbDqf0Kh0Sq1ar9isdsvter/gsHhMLpvP6LR6zW673/C4fE6v2+/4vH7P
	7/v/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmOBZxXnAQEnKIIBUQJCguoDKkIBgWhpUev
	CA4TDwgEUpwKERUaHCIiJCQjIiEUQhwqKiwqLjDQMCwoIha3oUO5ESMuLSwtLSIMsU4Tzi4o
	JBwWFA8ODQoMCkIMq6sNDQ4UFhwlzC4qSGhgkMvCsAoM6E0oAWMCOSUFGrgQcauAgAACSqGa
	l6SAK1EaJXBA0SIDBw0KBiCg8EtEBgEWYCxoooAigFwIJGgQYQIF/goTAjk6sXhxAwwFnHRO
	mEmAwoQAIUo8lCWhRgoOElJVkJBQFCwhCRqkYlUE1QMKHEywoBCrQaeIMCgQeOCi3AkYMmRI
	S5EuxEkN7OApkGDhF4fDxoSVMAFUBAWkRxI0a+XghVAkBSqMsFCBwj4OI0igSKGCdLN0wYKd
	zGDBwUYhn6YOKUCioQECGk7INpIArQgUKkr87TyhAYIDQxQgLkYsRIcQIDjcgi2Lw8RYKaAz
	MXCgAs8UJrZGmOA5AkeQBlqRKsIpvYMQDx4S4NCCxIJSKJpFYMIgnPlSF2ygAQWuCUHAAp6x
	E4EEE5BXQQUWYLABBySoAIMLHBSBWwso/jxwIAoyzMAWEw3AEEJCt6nUwAQagCDCYcCQwJcK
	6QD3DDQxwNDCCSg9NIAGKpwwgQAOtDADDBbsdkQDIPhkwosDPgDPAg1EAME++1jTnhAKdAnb
	VAR04EIJFAhwwQs0sBDfE7cZwEAE++yU2joOtDcKE7GUcoIKH6RSmwwnQCZFKAo8cE2es7my
	HnuxKTDgAA6owEEBjoL3wqRUNDBCCnyRYMFMRSDoWYPvyBPPA738lt1KKTxgpjolrDDiFAWU
	cAMKE+CipAMRZMDTCSSUQMIJPQHLwWOcrDKBCBpokAIJgmYqQgosxIAOCS8iJEQD7HR2QbMh
	WCCEK7Ck90Cz/oAFu+YVigpTwTsLyJOcBJ6N6plxRihA3E4cOKTkFCU6FMoAA7wiygAZgURA
	ekYsEJYFGTSATRccQEMjti8eZsEFFuA7z2WkEJAAl7iEQekEhQHGzgQR4INUKLB8pYAFJaQA
	KhleKdwAByEkFswHIoxQQn4AcYBvGRosisDICCjQAIMJGnZYBsUd4JEZBIhQwgPzKFwAwggL
	IHbOQzCtxZ1NL0BlKmmhIOwwHGTg2YMUEBdtKzBfbQWlhMHoHIXBnvABBGE9UMKNMKhgQgnG
	nNQO0wVQoI4FEohFyr9GzDIYaaPxxWy0rCjKQJUMQvxBaMOgNMQChcU4DAkZ6PoV/hIUoP4i
	Z7g/YHZHIPXeyWyONgsaCi4AOoLjXP8uhAAvPpCQ2Akr38UpXW60Ij8yPkMmwwj8KAI8QWtQ
	+eXSixEb37WhcHQBERz2rdZ8leCBBcXNY3XevQ8VG/6+F5CACDYgATlmYYD27aRmLngBNADC
	GGxxQEAWUJDzqpcctc2DARN4kNRgtJxhnKAFV0kIEhYAJ34IQwUhqkENYFCCE5BmGf9wwWmA
	5UGgXAAVtfCFMIgRLMbFLQIPYFACcMI7TjQoH2eJQIs2poEMYMAp5XGAvFrBCYS9ImzQG1vT
	arGTEQhIhE7QjLA+MKDOxClGwuoJtWi0uBIUIxjDSE2wQ4iHl7ywQDjGwZws/NcAlgBjaKQJ
	JDVuoQBeUeACoFkMcFqgQL1IgxpRSsjsqHA/gy0tHvmAx2z2BxIupaJrnVxCEAAAOw==
    }
    interp create x1
    interp create x2
    x1 eval {load {} Tk}
    x2 eval {load {} Tk}
    x1 eval [list image create photo T1_data -data $data]
    x2 eval [list image create photo T1_data -data $data]
    unset data
    interp delete x1
    interp delete x2
} {}


test imgPhoto-14.1 {GIF writes work correctly} {
    set data "R0lGODlhYwA5APcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgAysnGy8hKzM
hASs3MTcjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAwP8AAAD/
AP//AAAA//8A/wD//////ywAAAAAYwA5AAAI/wAZCBxIsKDBgwgTKlzIsKHD
hxAjSpxIsaLFixgzatzIsaPHjyBDihxJsqTJkyhTqlzJsqXLlzBjypxJs6bN
mzhz6tzJs6fPn0CDCh1KtKhRiwoSKEXAtGlTpUqPGkyagOmCq1edNsWalWkC
BUSXIuDqFepBqFWtZv3KU+zYrkrBSqT6dgECtjOTbu16NwFHvV3lshRLti/J
qlgRCE6ZuO9ik4Dt+k0ZVyZiyVIvXr77ODPEy5g9T4zMWfTEzXdNz1VbWvXn
uqldP1TAOrbshqBb314Y2W7n3Qdpv7UNPCHpycUVbv6dnODy5sqzQldIe8H0
hciva9/Ovbv37+BzBgEEADs=
"
    set photo [image create photo -data $data]
    set filename [makeFile {} imgPhoto-14.1.gif]
    removeFile imgPhoto-14.1.gif
    $photo write $filename -format gif
    set photo2 [image create photo -file $filename]
    set result [string equal [$photo data] [$photo2 data]]
    image delete $photo $photo2
    catch {file delete -force $filename}
    set result
} 1

test imgPhoto-15.1 {photo images can fail to allocate memory gracefully} \
	{nonPortable} {
    # This is not portable to very large machines with more around
    # 3GB of free memory available...
    list [catch {image create photo -width 32000 -height 32000} msg] $msg
} {1 {not enough free memory for image buffer}}

destroy .c
eval image delete [image names]

# cleanup
removeFile README-imgPhoto
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
# RCS: @@(#) $Id: imgPhoto.test,v 1.7.6.1 2000/05/04 21:26:29 spolk Exp $
d14 6
a19 3
if {[lsearch [namespace children] ::tcltest] == -1} {
    source [file join [pwd] [file dirname [info script]] defs.tcl]
}
d21 2
a22 5
foreach i [winfo children .] {
    destroy $i
}
wm geometry . {}
raise .
d30 3
a32 6
# temporarily copy the README fiel from testsDir to tmpDir
if {![file exists README]} {
    set newREADME [file join $::tcltest::workingDir README]
    file copy [file join $::tcltest::testsDir README] $newREADME
    set removeREADME 1
}
d37 1
a37 1
# skip this file if you can't find the teapot.ppm file.
d40 2
a41 3
    set newLib [file dirname $::tcltest::testsDir]
    set teapotPhotoFile \
	[file join $newLib library demos images teapot.ppm]
d43 1
a43 4
	puts "Can't find [file join demos images teapot.ppm] in $tk_library"
	puts "your Tk library is incomplete, so I am skipping imgPhoto tests."    
	::tcltest::cleanupTests
	return 0
d56 1
a56 1
test imgPhoto-1.3 {options for photo images} {
d60 1
a60 1
test imgPhoto-1.4 {options for photo images} {
d64 1
a64 1
test imgPhoto-1.5 {options for photo images} {
d76 2
a77 2
    list [catch {image create photo p1 -file README} err] $err
} {1 {couldn't recognize data in image file "README"}}
d81 9
d100 1
a100 1
	[image width image1] [image height image1]
d110 1
a110 1
test imgPhoto-3.1 {ImgPhotoConfigureMaster procedure} {
d114 1
a114 1
test imgPhoto-3.2 {ImgPhotoConfigureMaster procedure} {
d119 1
a119 1
test imgPhoto-3.3 {ImgPhotoConfigureMaster procedure} {
d139 1
a139 1
} {1 {bad option "blah": must be blank, cget, configure, copy, data, get, put, read, redither, or write}}
d164 1
a164 1
test imgPhoto-4.10 {ImgPhotoCmd procedure: copy option} {
d172 1
a172 1
} {1 {wrong # args: should be "p1 copy source-image ?-from x1 y1 x2 y2? ?-to x1 y1 x2 y2? ?-zoom x y? ?-subsample x y?"}}
d178 1
a178 1
} {1 {unrecognized option "-blah": must be -from, -shrink, -subsample, -to, or -zoom}}
d223 1
a223 1
test imgPhoto-4.22 {ImgPhotoCmd procedure: get option} {
d252 1
a252 1
test imgPhoto-4.31 {ImgPhotoCmd procedure: read option} {
d258 1
a258 1
test imgPhoto-4.33 {ImgPhotoCmd procedure: read option} {
d262 3
a264 3
    list [catch {p1 read README} err] $err
} {1 {couldn't recognize data in image file "README"}}
test imgPhoto-4.35 {ImgPhotoCmd procedure: read option} {
d268 1
a268 1
test imgPhoto-4.36 {ImgPhotoCmd procedure: read option} {
d282 178
d461 1
a461 1
test imgPhoto-5.1 {ImgPhotoGet/Free procedures, shared instances} {
d486 1
a486 1
test imgPhoto-7.1 {ImgPhotoFree procedure, resource freeing} {
d495 1
a495 1
test imgPhoto-7.2 {ImgPhotoFree procedures, unlinking} {
d511 1
a511 1
test imgPhoto-7.3 {ImgPhotoFree procedures, multiple visuals} {
d527 1
a527 1
test imgPhoto-8.1 {ImgPhotoDelete procedure} {
d531 1
a531 1
test imagePhoto-8.2 {ImgPhotoDelete procedure} {
d545 1
a545 1
test imagePhoto-9.1 {ImgPhotoCmdDeletedProc procedure} {
d566 1
a566 1
test imgPhoto-12.1 {Tk_PhotoPutZoomedBlock} {
d619 45
d668 1
a668 3
if {[info exists removeREADME]} {
    catch {file delete -force $newREADME}
}
a670 13













@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d7 2
a8 3
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
d12 1
a12 1
# RCS: @@(#) $Id: imgPhoto.test,v 1.11 1999/01/26 04:11:35 jingham Exp $
d14 2
a15 2
if {[info procs test] != "test"} {
    source defs
d30 24
d64 1
a64 2
    list [catch {image create photo p1 -file \
	    [file join $tk_library demos/images/teapot.ppm] \
d68 1
a68 1
    image create photo p1 -file [file join $tk_library demos/images/teapot.ppm]
d72 1
a72 2
    image create photo p1 \
	    -file [file join $tk_library demos/images/teapot.ppm] \
d76 1
a76 1
} [list 79 83 [file join $tk_library demos/images/teapot.ppm] ppm]
d109 2
a110 2
    image create photo p1 -file [file join $tk_library demos/images/teapot.ppm]
    p1 configure -file [file join $tk_library demos/images/teapot.ppm]
d113 1
a113 1
    image create photo p1 -file [file join $tk_library demos/images/teapot.ppm]
d122 1
a122 1
    p1 configure -file [file join $tk_library demos/images/teapot.ppm]
d137 1
a137 1
} {1 {bad option "blah": must be blank, cget, configure, copy, get, put, read, redither, or write}}
d163 1
a163 1
    image create photo p2 -file [file join $tk_library demos/images/teapot.ppm]
d222 1
a222 1
    p1 read [file join $tk_library demos/images/teapot.ppm]
d236 1
a236 1
} {1 {wrong # args: should be "p1 put data ?-format format? ?-to x1 y1 x2 y2?"}}
d249 1
a249 1
} {1 {wrong # args: should be "p1 read fileName ?-format format-name? ?-from x1 y1 x2 y2? ?-to x y? ?-shrink?"}}
d251 1
a251 2
    list [catch {p1 read [file join $tk_library demos/images/teapot.ppm] \
	 -zoom 2} err] $err
d257 1
a257 2
    list [catch {p1 read [file join $tk_library demos/images/teapot.ppm] \
	    -format bogus} err] $err
d263 1
a263 1
    p1 read [file join $tk_library demos/images/teapot.ppm] -shrink
d267 1
a267 2
    p1 read [file join $tk_library demos/images/teapot.ppm] \
	     -from 0 70 60 120 -to 10 10 -shrink
d276 1
a276 1
} {1 {wrong # args: should be "p1 write fileName ?-format format-name??-from x1 y1 x2 y2?"}}
d284 1
a284 1
    image create photo p1 -file [file join $tk_library demos/images/teapot.ppm]
d309 1
a309 1
    image create photo p1 -file [file join $tk_library demos/images/teapot.ppm]
d316 1
a316 1
    image create photo p1 -file [file join $tk_library demos/images/teapot.ppm]
d332 1
a332 1
    image create photo p1 -file [file join $tk_library demos/images/teapot.ppm]
d348 1
a348 1
    image create photo p2 -file [file join $tk_library demos/images/teapot.ppm]
d352 1
a352 1
    image create photo p2 -file [file join $tk_library demos/images/teapot.ppm]
d356 2
a357 2
    lappend x [info command new*]
} [list {} newp2 [file join $tk_library demos/images/teapot.ppm] {}]
d366 1
a366 1
    image create photo p2 -file [file join $tk_library demos/images/teapot.ppm]
d374 1
a374 2
    p1 put {{#ff0000 #ff0000 #ff0000 #ff0000 #ff0000 #ff0000 #ff0000 #ff0000}} \
	    -to 0 0
d387 1
a387 1
    image create photo p3 -file [file join $tk_library demos/images/teapot.ppm]
d441 20
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d7 3
a9 2
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
d13 1
a13 1
# RCS: @@(#) $Id: imgPhoto.test,v 1.7.6.1 2000/05/04 21:26:29 spolk Exp $
d15 2
a16 2
if {[lsearch [namespace children] ::tcltest] == -1} {
    source [file join [pwd] [file dirname [info script]] defs.tcl]
a30 24
# temporarily copy the README fiel from testsDir to tmpDir
if {![file exists README]} {
    set newREADME [file join $::tcltest::workingDir README]
    file copy [file join $::tcltest::testsDir README] $newREADME
    set removeREADME 1
}

# find the teapot.ppm file for use in these tests
# first look in $tk_library/demos/images/teapot.ppm
# then look in <this file>/../../library/demos/images/teapot.ppm
# skip this file if you can't find the teapot.ppm file.
set teapotPhotoFile [file join $tk_library demos images teapot.ppm]
if {![file exists $teapotPhotoFile]} {
    set newLib [file dirname $::tcltest::testsDir]
    set teapotPhotoFile \
	[file join $newLib library demos images teapot.ppm]
    if {![file exists $teapotPhotoFile]} {
	puts "Can't find [file join demos images teapot.ppm] in $tk_library"
	puts "your Tk library is incomplete, so I am skipping imgPhoto tests."    
	::tcltest::cleanupTests
	return 0
    }
}

d41 2
a42 1
    list [catch {image create photo p1 -file $teapotPhotoFile \
d46 1
a46 1
    image create photo p1 -file $teapotPhotoFile
d50 2
a51 1
    image create photo p1 -file $teapotPhotoFile \
d55 1
a55 1
} [list 79 83 $teapotPhotoFile ppm]
d88 2
a89 2
    image create photo p1 -file $teapotPhotoFile
    p1 configure -file $teapotPhotoFile
d92 1
a92 1
    image create photo p1 -file $teapotPhotoFile
d101 1
a101 1
    p1 configure -file $teapotPhotoFile
d116 1
a116 1
} {1 {bad option "blah": must be blank, cget, configure, copy, data, get, put, read, redither, or write}}
d142 1
a142 1
    image create photo p2 -file $teapotPhotoFile
d201 1
a201 1
    p1 read $teapotPhotoFile
d215 1
a215 1
} {1 {wrong # args: should be "p1 put data ?options?"}}
d228 1
a228 1
} {1 {wrong # args: should be "p1 read fileName ?options?"}}
d230 2
a231 1
    list [catch {p1 read $teapotPhotoFile -zoom 2} err] $err
d237 2
a238 1
    list [catch {p1 read $teapotPhotoFile -format bogus} err] $err
d244 1
a244 1
    p1 read $teapotPhotoFile
d248 2
a249 1
    p1 read $teapotPhotoFile -from 0 70 60 120 -to 10 10 -shrink
d258 1
a258 1
} {1 {wrong # args: should be "p1 write fileName ?options?"}}
d266 1
a266 1
    image create photo p1 -file $teapotPhotoFile
d291 1
a291 1
    image create photo p1 -file $teapotPhotoFile
d298 1
a298 1
    image create photo p1 -file $teapotPhotoFile
d314 1
a314 1
    image create photo p1 -file $teapotPhotoFile
d330 1
a330 1
    image create photo p2 -file $teapotPhotoFile
d334 1
a334 1
    image create photo p2 -file $teapotPhotoFile
d338 2
a339 2
    append x [info command new*]
} [list {} newp2 $teapotPhotoFile]
d348 1
a348 1
    image create photo p2 -file $teapotPhotoFile
d356 2
a357 1
    p1 put {{#ff0000 #ff0000 #ff0000 #ff0000 #ff0000 #ff0000 #ff0000 #ff0000}} -to 0 0
d370 1
a370 1
    image create photo p3 -file $teapotPhotoFile
a423 20

# cleanup
if {[info exists removeREADME]} {
    catch {file delete -force $newREADME}
}
::tcltest::cleanupTests
return













@


1.1.1.3
log
@import tk 8.4.0
@
text
@d12 1
a12 1
# RCS: @@(#) $Id: imgPhoto.test,v 1.14 2002/07/14 15:45:23 dgp Exp $
d14 3
a16 6
package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands
d18 5
a22 2
namespace import -force tcltest::makeFile
namespace import -force tcltest::removeFile
d30 6
a35 3
set README [makeFile {
README -- Tk test suite design document.
} README-imgPhotot]
d40 1
a40 1
testConstraint hasTeapotPhoto 1
d43 3
a45 2
    set newLib [file dirname [testsDirectory]]
    set teapotPhotoFile [file join $newLib library demos images teapot.ppm]
d47 4
a50 1
	testConstraint hasTeapotPhoto
d63 1
a63 1
test imgPhoto-1.3 {options for photo images} hasTeapotPhoto {
d67 1
a67 1
test imgPhoto-1.4 {options for photo images} hasTeapotPhoto {
d71 1
a71 1
test imgPhoto-1.5 {options for photo images} hasTeapotPhoto {
d83 2
a84 2
    list [catch {image create photo p1 -file $README} err] $err
} [subst {1 {couldn't recognize data in image file "$README"}}]
d98 1
a98 1
	    [image width image1] [image height image1]
d108 1
a108 1
test imgPhoto-3.1 {ImgPhotoConfigureMaster procedure} hasTeapotPhoto {
d112 1
a112 1
test imgPhoto-3.2 {ImgPhotoConfigureMaster procedure} hasTeapotPhoto {
d117 1
a117 1
test imgPhoto-3.3 {ImgPhotoConfigureMaster procedure} hasTeapotPhoto {
d137 1
a137 1
} {1 {bad option "blah": must be blank, cget, configure, copy, data, get, put, read, redither, transparency, or write}}
d162 1
a162 1
test imgPhoto-4.10 {ImgPhotoCmd procedure: copy option} hasTeapotPhoto {
d170 1
a170 1
} {1 {wrong # args: should be "p1 copy source-image ?-compositingrule rule? ?-from x1 y1 x2 y2? ?-to x1 y1 x2 y2? ?-zoom x y? ?-subsample x y?"}}
d176 1
a176 1
} {1 {unrecognized option "-blah": must be -compositingrule, -from, -shrink, -subsample, -to, or -zoom}}
d221 1
a221 1
test imgPhoto-4.22 {ImgPhotoCmd procedure: get option} hasTeapotPhoto {
d250 1
a250 1
test imgPhoto-4.31 {ImgPhotoCmd procedure: read option} hasTeapotPhoto {
d256 1
a256 1
test imgPhoto-4.33 {ImgPhotoCmd procedure: read option} hasTeapotPhoto {
d260 3
a262 3
    list [catch {p1 read $README} err] $err
} [subst {1 {couldn't recognize data in image file "$README"}}]
test imgPhoto-4.35 {ImgPhotoCmd procedure: read option} hasTeapotPhoto {
d266 1
a266 1
test imgPhoto-4.36 {ImgPhotoCmd procedure: read option} hasTeapotPhoto {
a279 178
eval image delete [image names]
image create photo p1
test imgPhoto-4.40 {ImgPhotoCmd procedure: transparency option} {
    list [catch {p1 transparency} err] $err
} {1 {wrong # args: should be "p1 transparency option ?arg arg ...?"}}
test imgPhoto-4.41 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get} err] $err
} {1 {wrong # args: should be "p1 transparency get x y"}}
test imgPhoto-4.42 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get 0} err] $err
} {1 {wrong # args: should be "p1 transparency get x y"}}
test imgPhoto-4.43 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get 0 0 0} err] $err
} {1 {wrong # args: should be "p1 transparency get x y"}}
test imgPhoto-4.44 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get bogus 0} err] $err
} {1 {expected integer but got "bogus"}}
test imgPhoto-4.45 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get 0 bogus} err] $err
} {1 {expected integer but got "bogus"}}
test imgPhoto-4.46 {ImgPhotoCmd procedure: transparency get option} {
    p1 put white
    p1 transparency get 0 0
} 0
test imgPhoto-4.47 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get 1 0} err] $err
} {1 {p1 transparency get: coordinates out of range}}
test imgPhoto-4.48 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get -1 0} err] $err
} {1 {p1 transparency get: coordinates out of range}}
test imgPhoto-4.49 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get 0 1} err] $err
} {1 {p1 transparency get: coordinates out of range}}
test imgPhoto-4.50 {ImgPhotoCmd procedure: transparency get option} {
    list [catch {p1 transparency get 0 -1} err] $err
} {1 {p1 transparency get: coordinates out of range}}
test imgPhoto-4.51 {ImgPhotoCmd procedure: transparency get option} {
    p1 blank
    p1 transparency get 0 0
} 1
test imgPhoto-4.52 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set} err] $err
} {1 {wrong # args: should be "p1 transparency set x y boolean"}}
test imgPhoto-4.53 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0} err] $err
} {1 {wrong # args: should be "p1 transparency set x y boolean"}}
test imgPhoto-4.54 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0 0} err] $err
} {1 {wrong # args: should be "p1 transparency set x y boolean"}}
test imgPhoto-4.55 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0 0 0 0} err] $err
} {1 {wrong # args: should be "p1 transparency set x y boolean"}}
test imgPhoto-4.56 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set bogus 0 0} err] $err
} {1 {expected integer but got "bogus"}}
test imgPhoto-4.57 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0 bogus 0} err] $err
} {1 {expected integer but got "bogus"}}
test imgPhoto-4.58 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0 0 bogus} err] $err
} {1 {expected boolean value but got "bogus"}}
test imgPhoto-4.59 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 1 0 0} err] $err
} {1 {p1 transparency set: coordinates out of range}}
test imgPhoto-4.60 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set -1 0 0} err] $err
} {1 {p1 transparency set: coordinates out of range}}
test imgPhoto-4.61 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0 1 0} err] $err
} {1 {p1 transparency set: coordinates out of range}}
test imgPhoto-4.62 {ImgPhotoCmd procedure: transparency set option} {
    list [catch {p1 transparency set 0 -1 0} err] $err
} {1 {p1 transparency set: coordinates out of range}}
test imgPhoto-4.63 {ImgPhotoCmd procedure: transparency set option} {
    p1 transparency set 0 0 false
    p1 transparency get 0 0
} 0
test imgPhoto-4.64 {ImgPhotoCmd procedure: transparency set option} {
    p1 transparency set 0 0 true
    p1 transparency get 0 0
} 1
# Now for some heftier testing, checking that setting and resetting of
# pixels' transparency status doesn't "leak" with any one-off errors.
proc checkImgTrans {img width height} {
    set result {}
    for {set x 0} {$x<$width} {incr x} {
	for {set y 0} {$y<$height} {incr y} {
	    if {[$img transparency get $x $y]} {
		lappend result $x $y
	    }
	}
    }
    return $result
}
test imgPhoto-4.65 {ImgPhotoCmd procedure: transparency get option} {
    p1 put white -to 0 0 3 3
    checkImgTrans p1 3 3
} {}
test imgPhoto-4.66 {ImgPhotoCmd procedure: transparency get option} {
    p1 blank
    checkImgTrans p1 3 3
} {0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2}
proc checkImgTransLoopSetReset {img width height} {
    set result {}
    for {set x 0} {$x<$width} {incr x} {
	for {set y 0} {$y<$height} {incr y} {
	    $img put white -to 0 0 3 3
	    $img transparency set $x $y 1
	    set result [concat $result [checkImgTrans $img $width $height]]
	    lappend result ,
	    $img transparency set $x $y 0
	    set result [concat $result [checkImgTrans $img $width $height]]
	    lappend result .
	}
    }
    return $result
}
test imgPhoto-4.67 {ImgPhotoCmd procedure: transparency set option} {
    checkImgTransLoopSetReset p1 3 3
} {0 0 , . 0 1 , . 0 2 , . 1 0 , . 1 1 , . 1 2 , . 2 0 , . 2 1 , . 2 2 , .}
proc checkImgTransLoopResetSet {img width height} {
    set result {}
    for {set x 0} {$x<$width} {incr x} {
	for {set y 0} {$y<$height} {incr y} {
	    $img blank
	    $img transparency set $x $y 0
	    set result [concat $result [checkImgTrans $img $width $height]]
	    lappend result ,
	    $img transparency set $x $y 1
	    set result [concat $result [checkImgTrans $img $width $height]]
	    lappend result .
	}
    }
    return $result
}
test imgPhoto-4.68 {ImgPhotoCmd procedure: transparency set option} {
    checkImgTransLoopResetSet p1 3 3
} {0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 2 1 0 1 1 1 2 2 0 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 1 0 1 1 1 2 2 0 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 0 2 1 1 1 2 2 0 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 0 2 1 0 1 2 2 0 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 0 2 1 0 1 1 2 0 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 0 2 1 0 1 1 1 2 2 1 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 2 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 . 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 , 0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 .}
catch {rename checkImgTransLoopSetReset {}}
catch {rename checkImgTransLoopResetSet {}}
# Test the compositing rules for copying images
image create photo p1 -width 3 -height 3
image create photo p2 -width 2 -height 2
test imgPhoto-4.68 {ImgPhotoCmd procedure: copy with -compositingrule} {
    list [catch {p1 copy p2 -to 1 1 -compositingrule} msg] $msg
} {1 {the "-compositingrule" option requires a value}}
test imgPhoto-4.69 {ImgPhotoCmd procedure: copy with -compositingrule} {
    list [catch {p1 copy p2 -to 1 1 -compositingrule BAD} msg] $msg
} {1 {bad compositing rule "BAD": must be overlay or set}}
test imgPhoto-4.70 {ImgPhotoCmd procedure: copy with -compositingrule} {
    # Tests default compositing rule
    p1 blank
    p2 blank
    p1 put white -to 0 0 2 2
    p2 put white -to 0 0 2 2
    p2 transparency set 0 0 true
    p1 copy p2 -to 1 1
    checkImgTrans p1 3 3
} {0 2 2 0}
test imgPhoto-4.71 {ImgPhotoCmd procedure: copy with -compositingrule} {
    p1 blank
    p2 blank
    p1 put white -to 0 0 2 2
    p2 put white -to 0 0 2 2
    p2 transparency set 0 0 true
    p1 copy p2 -to 1 1 -compositingrule overlay
    checkImgTrans p1 3 3
} {0 2 2 0}
test imgPhoto-4.72 {ImgPhotoCmd procedure: copy with -compositingrule} {
    p1 blank
    p2 blank
    p1 put white -to 0 0 2 2
    p2 put white -to 0 0 2 2
    p2 transparency set 0 0 true
    p1 copy p2 -to 1 1 -compositingrule set
    checkImgTrans p1 3 3
} {0 2 1 1 2 0}
catch {rename checkImgTrans {}}
d281 1
a281 1
test imgPhoto-5.1 {ImgPhotoGet/Free procedures, shared instances} hasTeapotPhoto {
d306 1
a306 1
test imgPhoto-7.1 {ImgPhotoFree procedure, resource freeing} hasTeapotPhoto {
d315 1
a315 1
test imgPhoto-7.2 {ImgPhotoFree procedures, unlinking} hasTeapotPhoto {
d331 1
a331 1
test imgPhoto-7.3 {ImgPhotoFree procedures, multiple visuals} hasTeapotPhoto {
d347 1
a347 1
test imgPhoto-8.1 {ImgPhotoDelete procedure} hasTeapotPhoto {
d351 1
a351 1
test imagePhoto-8.2 {ImgPhotoDelete procedure} hasTeapotPhoto {
d365 1
a365 1
test imagePhoto-9.1 {ImgPhotoCmdDeletedProc procedure} hasTeapotPhoto {
d386 1
a386 1
test imgPhoto-12.1 {Tk_PhotoPutZoomedBlock} hasTeapotPhoto {
a438 45

test imgPhoto-14.1 {GIF writes work correctly} {
    set data "R0lGODlhYwA5APcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgAysnGy8hKzM
hASs3MTcjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAwP8AAAD/
AP//AAAA//8A/wD//////ywAAAAAYwA5AAAI/wAZCBxIsKDBgwgTKlzIsKHD
hxAjSpxIsaLFixgzatzIsaPHjyBDihxJsqTJkyhTqlzJsqXLlzBjypxJs6bN
mzhz6tzJs6fPn0CDCh1KtKhRiwoSKEXAtGlTpUqPGkyagOmCq1edNsWalWkC
BUSXIuDqFepBqFWtZv3KU+zYrkrBSqT6dgECtjOTbu16NwFHvV3lshRLti/J
qlgRCE6ZuO9ik4Dt+k0ZVyZiyVIvXr77ODPEy5g9T4zMWfTEzXdNz1VbWvXn
uqldP1TAOrbshqBb314Y2W7n3Qdpv7UNPCHpycUVbv6dnODy5sqzQldIe8H0
hciva9/Ovbv37+BzBgEEADs=
"
    set photo [image create photo -data $data]
    set filename [makeFile {} imgPhoto-14.1.gif]
    removeFile imgPhoto-14.1.gif
    $photo write $filename -format gif
    set photo2 [image create photo -file $filename]
    set result [string equal [$photo data] [$photo2 data]]
    image delete $photo $photo2
    catch {file delete -force $filename}
    set result
} 1

test imgPhoto-15.1 {photo images can fail to allocate memory gracefully} \
	{nonPortable} {
    # This is not portable to very large machines with more around
    # 3GB of free memory available...
    list [catch {image create photo -width 32000 -height 32000} msg] $msg
} {1 {not enough free memory for image buffer}}

d443 3
a445 1
removeFile README-imgPhoto
d448 13
@


1.1.1.4
log
@imported tk 8.4.1
@
text
@d12 1
a12 1
# RCS: @@(#) $Id: imgPhoto.test,v 1.15 2002/10/18 00:48:22 hobbs Exp $
a80 9
test imgPhoto-1.9 {options for photo images - error case} {
    list [catch {image create photo -format} err] $err
} {1 {value for "-format" missing}}
test imgPhoto-1.10 {options for photo images - error case} {
    list [catch {image create photo -data} err] $err
} {1 {value for "-data" missing}}
test imgPhoto-1.11 {options for photo images - error case} {
    list [catch {image create photo p1 -format} err] $err
} {1 {value for "-format" missing}}
@


