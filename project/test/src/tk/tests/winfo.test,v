head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.51;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.16;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.29;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.54;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.37;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.39.11;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# This file is a Tcl script to test out the "winfo" command.  It is
# organized in the standard fashion for Tcl tests.
#
# Copyright (c) 1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
#
# RCS: @@(#) $Id: winfo.test,v 1.9 2002/07/13 21:52:34 dgp Exp $

package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands

# eatColors --
# Creates a toplevel window and allocates enough colors in it to
# use up all the slots in the colormap.
#
# Arguments:
# w -		Name of toplevel window to create.
# options -	Options for w, such as "-colormap new".

proc eatColors {w {options ""}} {
    catch {destroy $w}
    eval toplevel $w $options
    wm geom $w +0+0
    canvas $w.c -width 400 -height 200 -bd 0
    pack $w.c
    for {set y 0} {$y < 8} {incr y} {
	for {set x 0} {$x < 40} {incr x} {
	    set color [format #%02x%02x%02x [expr $x*6] [expr $y*30] 0]
	    $w.c create rectangle [expr 10*$x] [expr 20*$y] \
		    [expr 10*$x + 10] [expr 20*$y + 20] -outline {} \
		    -fill $color
	}
    }
    update
}

# XXX - This test file is woefully incomplete.  At present, only a
# few of the winfo options are tested.

test winfo-1.1 {"winfo atom" command} {
    list [catch {winfo atom} msg] $msg
} {1 {wrong # args: should be "winfo atom ?-displayof window? name"}}
test winfo-1.2 {"winfo atom" command} {
    list [catch {winfo atom a b} msg] $msg
} {1 {wrong # args: should be "winfo atom ?-displayof window? name"}}
test winfo-1.3 {"winfo atom" command} {
    list [catch {winfo atom a b c d} msg] $msg
} {1 {wrong # args: should be "winfo atom ?-displayof window? name"}}
test winfo-1.4 {"winfo atom" command} {
    list [catch {winfo atom -displayof geek foo} msg] $msg
} {1 {bad window path name "geek"}}
test winfo-1.5 {"winfo atom" command} {
    winfo atom PRIMARY
} 1
test winfo-1.6 {"winfo atom" command} {
    winfo atom -displayof . PRIMARY
} 1

test winfo-2.1 {"winfo atomname" command} {
    list [catch {winfo atomname} msg] $msg
} {1 {wrong # args: should be "winfo atomname ?-displayof window? id"}}
test winfo-2.2 {"winfo atomname" command} {
    list [catch {winfo atomname a b} msg] $msg
} {1 {wrong # args: should be "winfo atomname ?-displayof window? id"}}
test winfo-2.3 {"winfo atomname" command} {
    list [catch {winfo atomname a b c d} msg] $msg
} {1 {wrong # args: should be "winfo atomname ?-displayof window? id"}}
test winfo-2.4 {"winfo atomname" command} {
    list [catch {winfo atomname -displayof geek foo} msg] $msg
} {1 {bad window path name "geek"}}
test winfo-2.5 {"winfo atomname" command} {
    list [catch {winfo atomname 44215} msg] $msg
} {1 {no atom exists with id "44215"}}
test winfo-2.6 {"winfo atomname" command} {
    winfo atomname 2
} SECONDARY
test winfo-2.7 {"winfo atom" command} {
    winfo atomname -displayof . 2
} SECONDARY

# Some tests require the "pseudocolor" visual class.
testConstraint pseudocolor [expr { ([winfo depth .] == 8) 
				&& ([winfo visual .] == "pseudocolor")}]

test winfo-3.1 {"winfo colormapfull" command} {pseudocolor} {
    list [catch {winfo colormapfull} msg] $msg
} {1 {wrong # args: should be "winfo colormapfull window"}}
test winfo-3.2 {"winfo colormapfull" command} {pseudocolor} {
    list [catch {winfo colormapfull a b} msg] $msg
} {1 {wrong # args: should be "winfo colormapfull window"}}
test winfo-3.3 {"winfo colormapfull" command} {pseudocolor} {
    list [catch {winfo colormapfull foo} msg] $msg
} {1 {bad window path name "foo"}}
test winfo-3.4 {"winfo colormapfull" command} {macOrUnix pseudocolor} {
    eatColors .t {-colormap new}
    set result [list [winfo colormapfull .] [winfo colormapfull .t]]
    .t.c delete 34
    lappend result [winfo colormapfull .t]
    .t.c create rectangle 30 30 80 80 -fill #441739
    lappend result [winfo colormapfull .t]
    .t.c create rectangle 40 40 90 90 -fill #ffeedd
    lappend result [winfo colormapfull .t]
    destroy .t.c
    lappend result [winfo colormapfull .t]
} {0 1 0 0 1 0}
catch {destroy .t}

toplevel .t -width 550 -height 400
frame .t.f -width 80 -height 60 -bd 2 -relief raised
place .t.f -x 50 -y 50
wm geom .t +0+0
update
test winfo-4.1 {"winfo containing" command} {
    list [catch {winfo containing 22} msg] $msg
} {1 {wrong # args: should be "winfo containing ?-displayof window? rootX rootY"}}
test winfo-4.2 {"winfo containing" command} {
    list [catch {winfo containing a b c} msg] $msg
} {1 {wrong # args: should be "winfo containing ?-displayof window? rootX rootY"}}
test winfo-4.3 {"winfo containing" command} {
    list [catch {winfo containing a b c d e} msg] $msg
} {1 {wrong # args: should be "winfo containing ?-displayof window? rootX rootY"}}
test winfo-4.4 {"winfo containing" command} {
    list [catch {winfo containing -displayof geek 25 30} msg] $msg
} {1 {bad window path name "geek"}}
test winfo-4.5 {"winfo containing" command} {
    winfo containing [winfo rootx .t.f] [winfo rooty .t.f]
} .t.f
test winfo-4.6 {"winfo containing" command} {nonPortable} {
    winfo containing [expr [winfo rootx .t.f]-1] [expr [winfo rooty .t.f]-1]
} .t
test winfo-4.7 {"winfo containing" command} {
    set x [winfo containing -display .t.f [expr [winfo rootx .t]+600] \
	    [expr [winfo rooty .t.f]+450]]
    expr {($x == ".") || ($x == "")}
} {1}
destroy .t

test winfo-5.1 {"winfo interps" command} {
    list [catch {winfo interps a} msg] $msg
} {1 {wrong # args: should be "winfo interps ?-displayof window?"}}
test winfo-5.2 {"winfo interps" command} {
    list [catch {winfo interps a b c} msg] $msg
} {1 {wrong # args: should be "winfo interps ?-displayof window?"}}
test winfo-5.3 {"winfo interps" command} {
    list [catch {winfo interps -displayof geek} msg] $msg
} {1 {bad window path name "geek"}}
test winfo-5.4 {"winfo interps" command} {unixOnly} {
    expr [lsearch -exact [winfo interps] [tk appname]] >= 0
} {1}
test winfo-5.5 {"winfo interps" command} {unixOnly} {
    expr [lsearch -exact [winfo interps -displayof .] [tk appname]] >= 0
} {1}

test winfo-6.1 {"winfo exists" command} {
    list [catch {winfo exists} msg] $msg
} {1 {wrong # args: should be "winfo exists window"}}
test winfo-6.2 {"winfo exists" command} {
    list [catch {winfo exists a b} msg] $msg
} {1 {wrong # args: should be "winfo exists window"}}
test winfo-6.3 {"winfo exists" command} {
    winfo exists gorp
} {0}
test winfo-6.4 {"winfo exists" command} {
    winfo exists .
} {1}
test winfo-6.5 {"winfo exists" command} {
    button .b -text "Test button"
    set x [winfo exists .b]
    pack .b
    update
    bind .b <Destroy> {lappend x [winfo exists .x]}
    destroy .b
    lappend x [winfo exists .x]
} {1 0 0}

catch {destroy .b}
button .b -text "Help"
update
test winfo-7.1 {"winfo pathname" command} {
    list [catch {winfo pathname} msg] $msg
} {1 {wrong # args: should be "winfo pathname ?-displayof window? id"}}
test winfo-7.2 {"winfo pathname" command} {
    list [catch {winfo pathname a b} msg] $msg
} {1 {wrong # args: should be "winfo pathname ?-displayof window? id"}}
test winfo-7.3 {"winfo pathname" command} {
    list [catch {winfo pathname a b c d} msg] $msg
} {1 {wrong # args: should be "winfo pathname ?-displayof window? id"}}
test winfo-7.4 {"winfo pathname" command} {
    list [catch {winfo pathname -displayof geek 25} msg] $msg
} {1 {bad window path name "geek"}}
test winfo-7.5 {"winfo pathname" command} {
    list [catch {winfo pathname xyz} msg] $msg
} {1 {expected integer but got "xyz"}}
test winfo-7.6 {"winfo pathname" command} {
    list [catch {winfo pathname 224} msg] $msg
} {1 {window id "224" doesn't exist in this application}}
test winfo-7.7 {"winfo pathname" command} {
    winfo pathname -displayof .b [winfo id .]
} {.}
test winfo-7.8 {"winfo pathname" command} {unixOnly testwrapper} {
    winfo pathname [testwrapper .]
} {}

test winfo-8.1 {"winfo pointerx" command} {
    catch [winfo pointerx .b]
} 1
test winfo-8.2 {"winfo pointery" command} {
    catch [winfo pointery .b]
} 1
test winfo-8.3 {"winfo pointerxy" command} {
    catch [winfo pointerxy .b]
} 1

test winfo-9.1 {"winfo viewable" command} {
    list [catch {winfo viewable} msg] $msg
} {1 {wrong # args: should be "winfo viewable window"}}
test winfo-9.2 {"winfo viewable" command} {
    list [catch {winfo viewable foo} msg] $msg
} {1 {bad window path name "foo"}}
test winfo-9.3 {"winfo viewable" command} {
    winfo viewable .
} {1}
test winfo-9.4 {"winfo viewable" command} {
    wm iconify .
    winfo viewable .
} {0}
wm deiconify .
test winfo-9.5 {"winfo viewable" command} {
    frame .f1 -width 100 -height 100 -relief raised -bd 2
    place .f1 -x 0 -y 0
    frame .f1.f2 -width 50 -height 50 -relief raised -bd 2
    place .f1.f2 -x 0 -y 0
    update
    list [winfo viewable .f1] [winfo viewable .f1.f2]
} {1 1}
test winfo-9.6 {"winfo viewable" command} {
    deleteWindows
    frame .f1 -width 100 -height 100 -relief raised -bd 2
    frame .f1.f2 -width 50 -height 50 -relief raised -bd 2
    place .f1.f2 -x 0 -y 0
    update
    list [winfo viewable .f1] [winfo viewable .f1.f2]
} {0 0}
test winfo-9.7 {"winfo viewable" command} {
    deleteWindows
    frame .f1 -width 100 -height 100 -relief raised -bd 2
    place .f1 -x 0 -y 0
    frame .f1.f2 -width 50 -height 50 -relief raised -bd 2
    place .f1.f2 -x 0 -y 0
    update
    wm iconify .
    list [winfo viewable .f1] [winfo viewable .f1.f2]
} {0 0}
wm deiconify .
deleteWindows

test winfo-10.1 {"winfo visualid" command} {
    list [catch {winfo visualid} msg] $msg
} {1 {wrong # args: should be "winfo visualid window"}}
test winfo-10.2 {"winfo visualid" command} {
    list [catch {winfo visualid gorp} msg] $msg
} {1 {bad window path name "gorp"}}
test winfo-10.3 {"winfo visualid" command} {
    expr 2+[winfo visualid .]-[winfo visualid .]
} {2}

test winfo-11.1 {"winfo visualid" command} {
    list [catch {winfo visualsavailable} msg] $msg
} {1 {wrong # args: should be "winfo visualsavailable window ?includeids?"}}
test winfo-11.2 {"winfo visualid" command} {
    list [catch {winfo visualsavailable gorp} msg] $msg
} {1 {bad window path name "gorp"}}
test winfo-11.3 {"winfo visualid" command} {
    list [catch {winfo visualsavailable . includeids foo} msg] $msg
} {1 {wrong # args: should be "winfo visualsavailable window ?includeids?"}}
test winfo-11.4 {"winfo visualid" command} {
    llength [lindex [winfo visualsa .] 0]
} {2}
test winfo-11.5 {"winfo visualid" command} {
    llength [lindex [winfo visualsa . includeids] 0]
} {3}
test winfo-11.6 {"winfo visualid" command} {
    set x [lindex [lindex [winfo visualsa . includeids] 0] 2]
    expr $x + 2 - $x
} {2}

test winfo-12.1 {GetDisplayOf procedure} {
    list [catch {winfo atom - foo x} msg] $msg
} {1 {wrong # args: should be "winfo atom ?-displayof window? name"}}
test winfo-12.2 {GetDisplayOf procedure} {
    list [catch {winfo atom -d bad_window x} msg] $msg
} {1 {bad window path name "bad_window"}}

# Some embedding tests
# 

proc MakeEmbed {} {
    frame .con -container 1
    pack .con -expand yes -fill both
    toplevel .emb -use [winfo id .con] -bd 0 -highlightthickness 0
    button .emb.b
    pack .emb.b -expand yes -fill both
    update
}
test winfo-13.1 {root coordinates of embedded toplevel} {
    MakeEmbed
    set z [expr [winfo rootx .emb] == [winfo rootx .con] && \
		[winfo rooty .emb] == [winfo rooty .con]]
    destroy .emb
    destroy .con
    set z
} {1}
test winfo-13.2 {destroying embedded toplevel} {
    destroy .emb
    update
    expr [winfo exists .emb.b] || [winfo exists .con]
} 0

deleteWindows

test winfo-13.3 {destroying container window} {
    MakeEmbed
    destroy .con
    update
    set z [expr [winfo exists .emb.b] || [winfo exists .emb]]
    catch {destroy .emb}
    catch {destroy .con}
    set z
} 0

deleteWindows

test winfo-13.4 {[winfo containing] with embedded windows} {
    MakeEmbed
    button .b
    pack .b -expand yes -fill both
    update

    set z [string compare \
	[winfo containing [winfo rootx .emb.b] [winfo rooty .emb.b]] .emb.b]
    catch {destroy .con}
    catch {destroy .emb}
    set z
} 0

test winfo-14.1 {usage} {
    list [catch {winfo ismapped} msg] $msg
} {1 {wrong # args: should be "winfo ismapped window"}}

test winfo-14.2 {usage} {
    list [catch {winfo ismapped . .} msg] $msg
} {1 {wrong # args: should be "winfo ismapped window"}}

test winfo-14.3 {initially unmapped} {
    catch {destroy .t}
    toplevel .t
    winfo ismapped .t
} 0

test winfo-14.4 {mapped at idle time} {
    catch {destroy .t}
    toplevel .t
    update idletasks
    winfo ismapped .t
} 1

deleteWindows
# cleanup
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d9 1
a9 1
# RCS: @@(#) $Id: winfo.test,v 1.7.6.2 2000/09/26 16:09:30 spolk Exp $
d11 6
a16 13
if {[lsearch [namespace children] ::tcltest] == -1} {
    source [file join [pwd] [file dirname [info script]] defs.tcl]
}

foreach i [winfo children .] {
    catch {destroy $i}
}
wm geometry . {}
raise .

# Some tests require the testwrapper command
set ::tcltest::testConfig(testwrapper) \
	[expr {[info commands testwrapper] != {}}]
d88 2
a89 2
set ::tcltest::testConfig(pseudocolor) \
	[expr {([winfo depth .] == 8) && ([winfo visual .] == "pseudocolor")}]
d243 1
a243 1
    eval destroy [winfo child .]
d251 1
a251 1
    eval destroy [winfo child .]
d261 1
a261 1
eval destroy [winfo child .]
d325 1
a325 3
foreach i [winfo children .] {
    destroy $i
}
d337 1
a337 3
foreach i [winfo children .] {
    destroy $i
}
d352 20
a371 3
foreach i [winfo children .] {
    catch {destroy $i}
}
d373 1
a376 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d6 2
d9 1
a9 4
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: winfo.test,v 1.8 1999/01/26 04:11:42 jingham Exp $
d11 2
a12 2
if {[info procs test] != "test"} {
    source defs
d21 4
d94 26
a119 24
if {([winfo depth .] == 8) && ([winfo visual .] == "pseudocolor")} {
    test winfo-3.1 {"winfo colormapfull" command} {
	list [catch {winfo colormapfull} msg] $msg
    } {1 {wrong # args: should be "winfo colormapfull window"}}
    test winfo-3.2 {"winfo colormapfull" command} {
	list [catch {winfo colormapfull a b} msg] $msg
    } {1 {wrong # args: should be "winfo colormapfull window"}}
    test winfo-3.3 {"winfo colormapfull" command} {
	list [catch {winfo colormapfull foo} msg] $msg
    } {1 {bad window path name "foo"}}
    test winfo-3.4 {"winfo colormapfull" command} {macOrUnix} {
	eatColors .t {-colormap new}
	set result [list [winfo colormapfull .] [winfo colormapfull .t]]
	.t.c delete 34
	lappend result [winfo colormapfull .t]
	.t.c create rectangle 30 30 80 80 -fill #441739
	lappend result [winfo colormapfull .t]
	.t.c create rectangle 40 40 90 90 -fill #ffeedd
	lappend result [winfo colormapfull .t]
	destroy .t.c
	lappend result [winfo colormapfull .t]
    } {0 1 0 0 1 0}
    catch {destroy .t}
}
a120 1
catch {destroy .t}
d213 3
a215 9

if {[string compare testwrapper [info commands testwrapper]] == 0} {
    puts "This application hasn't been compiled with the testwrapper command,"
    puts "therefore I am skipping all of these tests."

    test winfo-7.8 {"winfo pathname" command} {unixOnly} {
        winfo pathname [testwrapper .]
    } {}
}
d318 1
a318 1
test winfo-13.1 {root coordinates of embedded toplevel} {macOrUnix} {
d326 2
a327 2
test winfo-13.2 {destroying embedded toplevel} {macOrUnix} {
    catch {destroy .emb}
d336 1
a336 1
test winfo-13.3 {destroying container window} {macOrUnix} {
d350 1
a350 1
test winfo-13.4 {[winfo containing] with embedded windows} {macOrUnix} {
d366 5
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@a5 2
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
d7 4
a10 1
# RCS: @@(#) $Id: winfo.test,v 1.7.6.2 2000/09/26 16:09:30 spolk Exp $
d12 2
a13 2
if {[lsearch [namespace children] ::tcltest] == -1} {
    source [file join [pwd] [file dirname [info script]] defs.tcl]
a21 4
# Some tests require the testwrapper command
set ::tcltest::testConfig(testwrapper) \
	[expr {[info commands testwrapper] != {}}]

d91 25
a115 25
# Some tests require the "pseudocolor" visual class.
set ::tcltest::testConfig(pseudocolor) \
	[expr {([winfo depth .] == 8) && ([winfo visual .] == "pseudocolor")}]

test winfo-3.1 {"winfo colormapfull" command} {pseudocolor} {
    list [catch {winfo colormapfull} msg] $msg
} {1 {wrong # args: should be "winfo colormapfull window"}}
test winfo-3.2 {"winfo colormapfull" command} {pseudocolor} {
    list [catch {winfo colormapfull a b} msg] $msg
} {1 {wrong # args: should be "winfo colormapfull window"}}
test winfo-3.3 {"winfo colormapfull" command} {pseudocolor} {
    list [catch {winfo colormapfull foo} msg] $msg
} {1 {bad window path name "foo"}}
test winfo-3.4 {"winfo colormapfull" command} {macOrUnix pseudocolor} {
    eatColors .t {-colormap new}
    set result [list [winfo colormapfull .] [winfo colormapfull .t]]
    .t.c delete 34
    lappend result [winfo colormapfull .t]
    .t.c create rectangle 30 30 80 80 -fill #441739
    lappend result [winfo colormapfull .t]
    .t.c create rectangle 40 40 90 90 -fill #ffeedd
    lappend result [winfo colormapfull .t]
    destroy .t.c
    lappend result [winfo colormapfull .t]
} {0 1 0 0 1 0}
a116 1

d209 9
a217 3
test winfo-7.8 {"winfo pathname" command} {unixOnly testwrapper} {
    winfo pathname [testwrapper .]
} {}
d320 1
a320 1
test winfo-13.1 {root coordinates of embedded toplevel} {
d328 2
a329 2
test winfo-13.2 {destroying embedded toplevel} {
    destroy .emb
d338 1
a338 1
test winfo-13.3 {destroying container window} {
d352 1
a352 1
test winfo-13.4 {[winfo containing] with embedded windows} {
a367 5

# cleanup
::tcltest::cleanupTests
return

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d9 1
a9 1
# RCS: @@(#) $Id: winfo.test,v 1.9 2002/07/13 21:52:34 dgp Exp $
d11 13
a23 6
package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands
d95 2
a96 2
testConstraint pseudocolor [expr { ([winfo depth .] == 8) 
				&& ([winfo visual .] == "pseudocolor")}]
d250 1
a250 1
    deleteWindows
d258 1
a258 1
    deleteWindows
d268 1
a268 1
deleteWindows
d332 3
a334 1
deleteWindows
d346 3
a348 1
deleteWindows
d363 3
a365 13
test winfo-14.1 {usage} {
    list [catch {winfo ismapped} msg] $msg
} {1 {wrong # args: should be "winfo ismapped window"}}

test winfo-14.2 {usage} {
    list [catch {winfo ismapped . .} msg] $msg
} {1 {wrong # args: should be "winfo ismapped window"}}

test winfo-14.3 {initially unmapped} {
    catch {destroy .t}
    toplevel .t
    winfo ismapped .t
} 0
a366 8
test winfo-14.4 {mapped at idle time} {
    catch {destroy .t}
    toplevel .t
    update idletasks
    winfo ismapped .t
} 1

deleteWindows
d370 1
@


