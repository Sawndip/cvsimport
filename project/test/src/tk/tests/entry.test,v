head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.4
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.50;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.16;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.29;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.53;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.36;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.39.05;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.01.21.19.55.10;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# This file is a Tcl script to test entry widgets in Tk.  It is
# organized in the standard fashion for Tcl tests.
#
# Copyright (c) 1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
#
# RCS: @@(#) $Id: entry.test,v 1.13 2002/10/02 20:59:28 hobbs Exp $

package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands

proc scroll args {
    global scrollInfo
    set scrollInfo $args
}

# Create additional widget that's used to hold the selection at times.

entry .sel
.sel insert end "This is some sample text"

# Font names

set big -adobe-helvetica-medium-r-normal--24-240-75-75-p-*-iso8859-1
set fixed -adobe-courier-medium-r-normal--12-120-75-75-m-*-iso8859-1

# Create entries in the option database to be sure that geometry options
# like border width have predictable values.

option add *Entry.borderWidth 2
option add *Entry.highlightThickness 2
option add *Entry.font {Helvetica -12}

entry .e -bd 2 -relief sunken
pack .e
update

set i 1
foreach test {
    {-background #ff0000 #ff0000 non-existent
	{unknown color name "non-existent"}}
    {-bd 4 4 badValue {bad screen distance "badValue"}}
    {-bg #ff0000 #ff0000 non-existent {unknown color name "non-existent"}}
    {-borderwidth 1.3 1 badValue {bad screen distance "badValue"}}
    {-cursor arrow arrow badValue {bad cursor spec "badValue"}}
    {-disabledbackground green green non-existent 
	{unknown color name "non-existent"}}
    {-disabledforeground blue blue non-existent 
	{unknown color name "non-existent"}}
    {-exportselection yes 1 xyzzy {expected boolean value but got "xyzzy"}}
    {-fg #110022 #110022 bogus {unknown color name "bogus"}}
    {-font -Adobe-Helvetica-Medium-R-Normal--*-120-*-*-*-*-*-*
	-Adobe-Helvetica-Medium-R-Normal--*-120-*-*-*-*-*-* {}
	{font "" doesn't exist}}
    {-foreground #110022 #110022 bogus {unknown color name "bogus"}}
    {-highlightbackground #123456 #123456 ugly {unknown color name "ugly"}}
    {-highlightcolor #123456 #123456 bogus {unknown color name "bogus"}}
    {-highlightthickness 6 6 bogus {bad screen distance "bogus"}}
    {-highlightthickness -2 0 {} {}}
    {-insertbackground #110022 #110022 bogus {unknown color name "bogus"}}
    {-insertborderwidth 1.3 1 2.6x {bad screen distance "2.6x"}}
    {-insertofftime 100 100 3.2 {expected integer but got "3.2"}}
    {-insertontime 100 100 3.2 {expected integer but got "3.2"}}
    {-invalidcommand "any string" "any string" {} {}}
    {-invcmd "any string" "any string" {} {}}
    {-justify right right bogus {bad justification "bogus": must be left, right, or center}}
    {-readonlybackground green green non-existent 
	{unknown color name "non-existent"}}
    {-relief groove groove 1.5 {bad relief "1.5": must be flat, groove, raised, ridge, solid, or sunken}}
    {-selectbackground #110022 #110022 bogus {unknown color name "bogus"}}
    {-selectborderwidth 1.3 1 badValue {bad screen distance "badValue"}}
    {-selectforeground #654321 #654321 bogus {unknown color name "bogus"}}
    {-show * * {} {}}
    {-state n normal bogus 
	{bad state "bogus": must be disabled, normal, or readonly}}
    {-takefocus "any string" "any string" {} {}}
    {-textvariable i i {} {}}
    {-width 402 402 3p {expected integer but got "3p"}}
    {-xscrollcommand {Some command} {Some command} {} {}}
} {
    set name [lindex $test 0]
    test entry-1.$i {configuration options} {
	.e configure $name [lindex $test 1]
	list [lindex [.e configure $name] 4] [.e cget $name]
    } [list [lindex $test 2] [lindex $test 2]]
    incr i
    if {[lindex $test 3] != ""} {
	test entry-1.$i {configuration options} {
	    list [catch {.e configure $name [lindex $test 3]} msg] $msg
	} [list 1 [lindex $test 4]]
    }
    .e configure $name [lindex [.e configure $name] 3]
    incr i
}

test entry-2.1 {Tk_EntryCmd procedure} {
    list [catch {entry} msg] $msg
} {1 {wrong # args: should be "entry pathName ?options?"}}
test entry-2.2 {Tk_EntryCmd procedure} {
    list [catch {entry gorp} msg] $msg
} {1 {bad window path name "gorp"}}
test entry-2.3 {Tk_EntryCmd procedure} {
    catch {destroy .e}
    entry .e
    list [winfo exists .e] [winfo class .e] [info commands .e]
} {1 Entry .e}
test entry-2.4 {Tk_EntryCmd procedure} {
    catch {destroy .e}
    list [catch {entry .e -gorp foo} msg] $msg [winfo exists .e] \
	    [info commands .e]
} {1 {unknown option "-gorp"} 0 {}}
test entry-2.5 {Tk_EntryCmd procedure} {
    catch {destroy .e}
    entry .e
} {.e}

catch {destroy .e}
entry .e -font $fixed
pack .e
update

set cx [font measure $fixed a]
set cy [font metrics $fixed -linespace]
set ux [font measure $fixed \u4e4e]

test entry-3.1 {EntryWidgetCmd procedure} {
    list [catch {.e} msg] $msg
} {1 {wrong # args: should be ".e option ?arg arg ...?"}}
test entry-3.2 {EntryWidgetCmd procedure, "bbox" widget command} {
    list [catch {.e bbox} msg] $msg
} {1 {wrong # args: should be ".e bbox index"}}
test entry-3.3 {EntryWidgetCmd procedure, "bbox" widget command} {
    list [catch {.e bbox a b} msg] $msg
} {1 {wrong # args: should be ".e bbox index"}}
test entry-3.4 {EntryWidgetCmd procedure, "bbox" widget command} {
    list [catch {.e bbox bogus} msg] $msg
} {1 {bad entry index "bogus"}}
test entry-3.5 {EntryWidgetCmd procedure, "bbox" widget command} {
    .e delete 0 end
    .e bbox 0
} [list 5 5 0 $cy]
test entry-3.6 {EntryWidgetCmd procedure, "bbox" widget command} {
    # Tcl_UtfAtIndex(): no utf chars

    .e delete 0 end
    .e insert 0 "abc"
    list [.e bbox 3] [.e bbox end]
} [list "[expr 5+2*$cx] 5 $cx $cy" "[expr 5+2*$cx] 5 $cx $cy"]
test entry-3.7 {EntryWidgetCmd procedure, "bbox" widget command} {
    # Tcl_UtfAtIndex(): utf at end
    .e delete 0 end
    .e insert 0 "ab\u4e4e"
    .e bbox end
} "[expr 5+2*$cx] 5 $ux $cy"
test entry-3.8 {EntryWidgetCmd procedure, "bbox" widget command} {
    # Tcl_UtfAtIndex(): utf before index
    .e delete 0 end
    .e insert 0 "ab\u4e4ec"
    .e bbox 3
} "[expr 5+2*$cx+$ux] 5 $cx $cy"
test entry-3.9 {EntryWidgetCmd procedure, "bbox" widget command} {
    # Tcl_UtfAtIndex(): no chars
    .e delete 0 end
    .e bbox end
} "5 5 0 $cy"
test entry-3.10 {EntryWidgetCmd procedure, "bbox" widget command} {
    .e delete 0 end
    .e insert 0 "abcdefghij\u4e4eklmnop"
    list [.e bbox 0] [.e bbox 1] [.e bbox 10] [.e bbox end]
} [list "5 5 $cx $cy" "[expr 5+$cx] 5 $cx $cy" "[expr 5+10*$cx] 5 $ux $cy" "[expr 5+$ux+15*$cx] 5 $cx $cy"]
test entry-3.11 {EntryWidgetCmd procedure, "cget" widget command} {
    list [catch {.e cget} msg] $msg
} {1 {wrong # args: should be ".e cget option"}}
test entry-3.12 {EntryWidgetCmd procedure, "cget" widget command} {
    list [catch {.e cget a b} msg] $msg
} {1 {wrong # args: should be ".e cget option"}}
test entry-3.13 {EntryWidgetCmd procedure, "cget" widget command} {
    list [catch {.e cget -gorp} msg] $msg
} {1 {unknown option "-gorp"}}
test entry-3.14 {EntryWidgetCmd procedure, "cget" widget command} {
    .e configure -bd 4
    .e cget -bd
} {4}
test entry-3.15 {EntryWidgetCmd procedure, "configure" widget command} {
    llength [.e configure]
} {36}
test entry-3.16 {EntryWidgetCmd procedure, "configure" widget command} {
    list [catch {.e configure -foo} msg] $msg
} {1 {unknown option "-foo"}}
test entry-3.17 {EntryWidgetCmd procedure, "configure" widget command} {
    .e configure -bd 4
    .e configure -bg #ffffff
    lindex [.e configure -bd] 4
} {4}
test entry-3.18 {EntryWidgetCmd procedure, "delete" widget command} {
    list [catch {.e delete} msg] $msg
} {1 {wrong # args: should be ".e delete firstIndex ?lastIndex?"}}
test entry-3.19 {EntryWidgetCmd procedure, "delete" widget command} {
    list [catch {.e delete a b c} msg] $msg
} {1 {wrong # args: should be ".e delete firstIndex ?lastIndex?"}}
test entry-3.20 {EntryWidgetCmd procedure, "delete" widget command} {
    list [catch {.e delete foo} msg] $msg
} {1 {bad entry index "foo"}}
test entry-3.21 {EntryWidgetCmd procedure, "delete" widget command} {
    list [catch {.e delete 0 bar} msg] $msg
} {1 {bad entry index "bar"}}
test entry-3.22 {EntryWidgetCmd procedure, "delete" widget command} {
    .e delete 0 end
    .e insert end "01234567890"
    .e delete 2 4
    .e get
} {014567890}
test entry-3.23 {EntryWidgetCmd procedure, "delete" widget command} {
    .e delete 0 end
    .e insert end "01234567890"
    .e delete 6
    .e get
} {0123457890}
test entry-3.24 {EntryWidgetCmd procedure, "delete" widget command} {
    # UTF
    set x {}
    .e delete 0 end
    .e insert end "01234\u4e4e67890"
    .e delete 6
    lappend x [.e get]
    .e delete 0 end
    .e insert end "012345\u4e4e7890"
    .e delete 6
    lappend x [.e get]
    .e delete 0 end
    .e insert end "0123456\u4e4e890"
    .e delete 6
    lappend x [.e get]
} [list "01234\u4e4e7890" "0123457890" "012345\u4e4e890"]
test entry-3.25 {EntryWidgetCmd procedure, "delete" widget command} {
    .e delete 0 end
    .e insert end "01234567890"
    .e delete 6 5
    .e get
} {01234567890}
test entry-3.26 {EntryWidgetCmd procedure, "delete" widget command} {
    .e delete 0 end
    .e insert end "01234567890"
    .e configure -state disabled
    .e delete 2 8
    .e configure -state normal
    .e get
} {01234567890}
test entry-3.27 {EntryWidgetCmd procedure, "delete" widget command} {
    .e delete 0 end
    .e insert end "01234567890"
    .e configure -state readonly
    .e delete 2 8
    .e configure -state normal
    .e get
} {01234567890}
test entry-3.27 {EntryWidgetCmd procedure, "get" widget command} {
    list [catch {.e get foo} msg] $msg
} {1 {wrong # args: should be ".e get"}}
test entry-3.28 {EntryWidgetCmd procedure, "icursor" widget command} {
    list [catch {.e icursor} msg] $msg
} {1 {wrong # args: should be ".e icursor pos"}}
test entry-3.29 {EntryWidgetCmd procedure, "icursor" widget command} {
    list [catch {.e icursor foo} msg] $msg
} {1 {bad entry index "foo"}}
test entry-3.30 {EntryWidgetCmd procedure, "icursor" widget command} {
    .e delete 0 end
    .e insert end "01234567890"
    .e icursor 4
    .e index insert
} {4}
test entry-3.31 {EntryWidgetCmd procedure, "index" widget command} {
    list [catch {.e in} msg] $msg
} {1 {ambiguous option "in": must be bbox, cget, configure, delete, get, icursor, index, insert, scan, selection, validate, or xview}}
test entry-3.32 {EntryWidgetCmd procedure, "index" widget command} {
    list [catch {.e index} msg] $msg
} {1 {wrong # args: should be ".e index string"}}
test entry-3.33 {EntryWidgetCmd procedure, "index" widget command} {
    list [catch {.e index foo} msg] $msg
} {1 {bad entry index "foo"}}
test entry-3.34 {EntryWidgetCmd procedure, "index" widget command} {
    list [catch {.e index 0} msg] $msg
} {0 0}
test entry-3.35 {EntryWidgetCmd procedure, "index" widget command} {
    # UTF
    .e delete 0 end
    .e insert 0 abc\u4e4e\u0153def
    list [.e index 3] [.e index 4] [.e index end]
} {3 4 8}
test entry-3.36 {EntryWidgetCmd procedure, "insert" widget command} {
    list [catch {.e insert a} msg] $msg
} {1 {wrong # args: should be ".e insert index text"}}
test entry-3.37 {EntryWidgetCmd procedure, "insert" widget command} {
    list [catch {.e insert a b c} msg] $msg
} {1 {wrong # args: should be ".e insert index text"}}
test entry-3.38 {EntryWidgetCmd procedure, "insert" widget command} {
    list [catch {.e insert foo Text} msg] $msg
} {1 {bad entry index "foo"}}
test entry-3.39 {EntryWidgetCmd procedure, "insert" widget command} {
    .e delete 0 end
    .e insert end "01234567890"
    .e insert 3 xxx
    .e get
} {012xxx34567890}
test entry-3.40 {EntryWidgetCmd procedure, "insert" widget command} {
    .e delete 0 end
    .e insert end "01234567890"
    .e configure -state disabled
    .e insert 3 xxx
    .e configure -state normal
    .e get
} {01234567890}
test entry-3.40 {EntryWidgetCmd procedure, "insert" widget command} {
    .e delete 0 end
    .e insert end "01234567890"
    .e configure -state readonly
    .e insert 3 xxx
    .e configure -state normal
    .e get
} {01234567890}
test entry-3.41 {EntryWidgetCmd procedure, "insert" widget command} {
    list [catch {.e insert a b c} msg] $msg
} {1 {wrong # args: should be ".e insert index text"}}
test entry-3.42 {EntryWidgetCmd procedure, "scan" widget command} {
    list [catch {.e scan a} msg] $msg
} {1 {wrong # args: should be ".e scan mark|dragto x"}}
test entry-3.43 {EntryWidgetCmd procedure, "scan" widget command} {
    list [catch {.e scan a b c} msg] $msg
} {1 {wrong # args: should be ".e scan mark|dragto x"}}
test entry-3.44 {EntryWidgetCmd procedure, "scan" widget command} {
    list [catch {.e scan foobar 20} msg] $msg
} {1 {bad scan option "foobar": must be mark or dragto}}
test entry-3.45 {EntryWidgetCmd procedure, "scan" widget command} {
    list [catch {.e scan mark 20.1} msg] $msg
} {1 {expected integer but got "20.1"}}
# This test is non-portable because character sizes vary.

test entry-3.46 {EntryWidgetCmd procedure, "scan" widget command} {fonts} {
    .e delete 0 end
    update
    .e insert end "This is quite a long string, in fact a "
    .e insert end "very very long string"
    .e scan mark 30
    .e scan dragto 28
    .e index @@0
} {2}
test entry-3.47 {EntryWidgetCmd procedure, "select" widget command} {
    list [catch {.e select} msg] $msg
} {1 {wrong # args: should be ".e selection option ?index?"}}
test entry-3.48 {EntryWidgetCmd procedure, "select" widget command} {
    list [catch {.e select foo} msg] $msg
} {1 {bad selection option "foo": must be adjust, clear, from, present, range, or to}}
test entry-3.49 {EntryWidgetCmd procedure, "select clear" widget command} {
    list [catch {.e select clear gorp} msg] $msg
} {1 {wrong # args: should be ".e selection clear"}}
test entry-3.50 {EntryWidgetCmd procedure, "select clear" widget command} {
    .e delete 0 end
    .e insert end "0123456789"
    .e select from 1
    .e select to 4
    update
    .e select clear
    list [catch {selection get} msg] $msg [selection own]
} {1 {PRIMARY selection doesn't exist or form "STRING" not defined} .e}
test entry-3.51 {EntryWidgetCmd procedure, "selection present" widget command} {
    list [catch {.e selection present foo} msg] $msg
} {1 {wrong # args: should be ".e selection present"}}
test entry-3.52 {EntryWidgetCmd procedure, "selection present" widget command} {
    .e delete 0 end
    .e insert end 0123456789
    .e select from 3
    .e select to 6
    .e selection present
} {1}
test entry-3.53 {EntryWidgetCmd procedure, "selection present" widget command} {
    .e delete 0 end
    .e insert end 0123456789
    .e select from 3
    .e select to 6
    .e configure -exportselection false
    .e selection present
} {1}
.e configure -exportselection true
test entry-3.54 {EntryWidgetCmd procedure, "selection present" widget command} {
    .e delete 0 end
    .e insert end 0123456789
    .e select from 3
    .e select to 6
    .e delete 0 end
    .e selection present
} {0}
test entry-3.55 {EntryWidgetCmd procedure, "selection adjust" widget command} {
    list [catch {.e select adjust x} msg] $msg
} {1 {bad entry index "x"}}
test entry-3.56 {EntryWidgetCmd procedure, "selection adjust" widget command} {
    list [catch {.e select adjust 2 3} msg] $msg
} {1 {wrong # args: should be ".e selection adjust index"}}
test entry-3.57 {EntryWidgetCmd procedure, "selection adjust" widget command} {
    .e delete 0 end
    .e insert end "0123456789"
    .e select from 1
    .e select to 5
    update
    .e select adjust 4
    selection get
} {123}
test entry-3.58 {EntryWidgetCmd procedure, "selection adjust" widget command} {
    .e delete 0 end
    .e insert end "0123456789"
    .e select from 1
    .e select to 5
    update
    .e select adjust 2
    selection get
} {234}
test entry-3.59 {EntryWidgetCmd procedure, "selection from" widget command} {
    list [catch {.e select from 2 3} msg] $msg
} {1 {wrong # args: should be ".e selection from index"}}
test entry-3.60 {EntryWidgetCmd procedure, "selection range" widget command} {
    list [catch {.e select range 2} msg] $msg
} {1 {wrong # args: should be ".e selection range start end"}}
test entry-3.61 {EntryWidgetCmd procedure, "selection range" widget command} {
    list [catch {.e selection range 2 3 4} msg] $msg
} {1 {wrong # args: should be ".e selection range start end"}}
test entry-3.62 {EntryWidgetCmd procedure, "selection range" widget command} {
    .e delete 0 end
    .e insert end 0123456789
    .e select from 1
    .e select to 5
    .e select range 4 4
    list [catch {.e index sel.first} msg] $msg
} {1 {selection isn't in widget .e}}
test entry-3.63 {EntryWidgetCmd procedure, "selection range" widget command} {
    .e delete 0 end
    .e insert end 0123456789
    .e select from 3
    .e select to 7
    .e select range 2 9
    list [.e index sel.first] [.e index sel.last] [.e index anchor]
} {2 9 3}
test entry-3.64 {EntryWidgetCmd procedure, "selection" widget command} {
    .e delete 0 end
    .e insert end 0123456789
    .e selection range 0 end
    .e configure -state disabled
    .e selection range 2 4
    .e configure -state normal
    list [.e index sel.first] [.e index sel.last]
} {0 10}
test entry-3.64 {EntryWidgetCmd procedure, "selection" widget command} {
    .e delete 0 end
    .e insert end 0123456789
    .e selection range 0 end
    .e configure -state readonly
    .e selection range 2 4
    .e configure -state normal
    list [.e index sel.first] [.e index sel.last]
} {2 4}
.e delete 0 end
.e insert end "This is quite a long text string, so long that it "
.e insert end "runs off the end of the window quite a bit."
test entry-3.64 {EntryWidgetCmd procedure, "selection to" widget command} {
    list [catch {.e select to 2 3} msg] $msg
} {1 {wrong # args: should be ".e selection to index"}}
test entry-3.65 {EntryWidgetCmd procedure, "xview" widget command} {
    .e xview 5
    .e xview
} {0.0537634 0.268817}
test entry-3.66 {EntryWidgetCmd procedure, "xview" widget command} {
    list [catch {.e xview gorp} msg] $msg
} {1 {bad entry index "gorp"}}
test entry-3.67 {EntryWidgetCmd procedure, "xview" widget command} {
    .e xview 0
    .e icursor 10
    .e xview insert
    .e xview
} {0.107527 0.322581}
test entry-3.68 {EntryWidgetCmd procedure, "xview" widget command} {
    list [catch {.e xview moveto foo bar} msg] $msg
} {1 {wrong # args: should be ".e xview moveto fraction"}}
test entry-3.69 {EntryWidgetCmd procedure, "xview" widget command} {
    list [catch {.e xview moveto foo} msg] $msg
} {1 {expected floating-point number but got "foo"}}
test entry-3.70 {EntryWidgetCmd procedure, "xview" widget command} {
    .e xview moveto 0.5
    .e xview
} {0.505376 0.72043}
test entry-3.71 {EntryWidgetCmd procedure, "xview" widget command} {
    list [catch {.e xview scroll 24} msg] $msg
} {1 {wrong # args: should be ".e xview scroll number units|pages"}}
test entry-3.72 {EntryWidgetCmd procedure, "xview" widget command} {
    list [catch {.e xview scroll gorp units} msg] $msg
} {1 {expected integer but got "gorp"}}
test entry-3.73 {EntryWidgetCmd procedure, "xview" widget command} {
    .e xview moveto 0
    .e xview scroll 1 pages
    .e xview
} {0.193548 0.408602}
test entry-3.74 {EntryWidgetCmd procedure, "xview" widget command} {
    .e xview moveto .9
    update
    .e xview scroll -2 p
    .e xview
} {0.397849 0.612903}
test entry-3.75 {EntryWidgetCmd procedure, "xview" widget command} {
    .e xview 30
    update
    .e xview scroll 2 units 
    .e index @@0
} {32}
test entry-3.76 {EntryWidgetCmd procedure, "xview" widget command} {
    .e xview 30
    update
    .e xview scroll -1 units 
    .e index @@0
} {29}
test entry-3.77 {EntryWidgetCmd procedure, "xview" widget command} {
    list [catch {.e xview scroll 23 foobars} msg] $msg
} {1 {bad argument "foobars": must be units or pages}}
test entry-3.78 {EntryWidgetCmd procedure, "xview" widget command} {
    list [catch {.e xview eat 23 hamburgers} msg] $msg
} {1 {unknown option "eat": must be moveto or scroll}}
test entry-3.79 {EntryWidgetCmd procedure, "xview" widget command} {
    .e xview 0
    update
    .e xview -4
    .e index @@0
} {0}
test entry-3.80 {EntryWidgetCmd procedure, "xview" widget command} {
    .e xview 300
    .e index @@0
} {73}
.e insert 10 \u4e4e
test entry-3.81 {EntryWidgetCmd procedure, "xview" widget command} {
    # UTF
    # If Tcl_NumUtfChars wasn't used, wrong answer would be:
    # 0.106383 0.117021 0.117021

    set x {}
    .e xview moveto .1
    lappend x [lindex [.e xview] 0]
    .e xview moveto .11
    lappend x [lindex [.e xview] 0]
    .e xview moveto .12
    lappend x [lindex [.e xview] 0]
} {0.0957447 0.106383 0.117021}
test entry-3.82 {EntryWidgetCmd procedure} {
    list [catch {.e gorp} msg] $msg
} {1 {bad option "gorp": must be bbox, cget, configure, delete, get, icursor, index, insert, scan, selection, validate, or xview}}

# The test below doesn't actually check anything directly, but if run
# with Purify or some other memory-allocation-checking program it will
# ensure that resources get properly freed.

test entry-4.1 {DestroyEntry procedure} {
    catch {destroy .e}
    entry .e -textvariable x -show *
    pack .e
    .e insert end "Sample text"
    update
    destroy .e
} {}

frame .f -width 200 -height 50 -relief raised -bd 2
pack .f -side right
test entry-5.1 {ConfigureEntry procedure, -textvariable} {
    catch {destroy .e}
    set x 12345
    entry .e -textvariable x
    .e get
} {12345}
test entry-5.2 {ConfigureEntry procedure, -textvariable} {
    catch {destroy .e}
    set x 12345
    entry .e -textvariable x
    set y abcde
    .e configure -textvariable y
    set x 54321
    .e get
} {abcde}
test entry-5.3 {ConfigureEntry procedure, -textvariable} {
    catch {destroy .e}
    catch {unset x}
    entry .e
    .e insert 0 "Some text"
    .e configure -textvariable x
    set x
} {Some text}
test entry-5.4 {ConfigureEntry procedure, -textvariable} {
    proc override args {
	global x
	set x 12345
    }
    catch {destroy .e}
    catch {unset x}
    trace variable x w override
    entry .e
    .e insert 0 "Some text"
    .e configure -textvariable x
    set result [list $x [.e get]]
    unset x;  rename override {}
    set result
} {12345 12345}
test entry-5.5 {ConfigureEntry procedure} {
    catch {destroy .e}
    entry .e -exportselection false
    pack .e
    .e insert end "0123456789"
    .sel select from 0
    .sel select to 10
    set x {}
    lappend x [selection get]
    .e select from 1
    .e select to 5
    lappend x [selection get]
    .e configure -exportselection 1
    lappend x [selection get]
    set x
} {{This is so} {This is so} 1234}
test entry-5.6 {ConfigureEntry procedure} {
    catch {destroy .e}
    entry .e
    pack .e
    .e insert end "0123456789"
    .e select from 1
    .e select to 5
    .e configure -exportselection 0
    list [catch {selection get} msg] $msg [.e index sel.first] \
	    [.e index sel.last]
} {1 {PRIMARY selection doesn't exist or form "STRING" not defined} 1 5}
test entry-5.7 {ConfigureEntry procedure} {
    catch {destroy .e}
    entry .e -font $fixed -width 4 -xscrollcommand scroll
    pack .e
    .e insert end "01234567890"
    update
    .e configure -width 5
    set scrollInfo
} {0 0.363636}
test entry-5.8 {ConfigureEntry procedure} {fonts} {
    catch {destroy .e}
    entry .e -width 0
    pack .e
    .e insert end "0123"
    update
    .e configure -font $big
    update
    winfo geom .e
} {62x37+0+0}
test entry-5.9 {ConfigureEntry procedure} {fonts} {
    catch {destroy .e}
    entry .e -font $fixed -bd 2 -relief raised
    pack .e
    .e insert end "0123"
    update
    list [.e index @@10] [.e index @@11] [.e index @@12] [.e index @@13]
} {0 0 1 1}
test entry-5.10 {ConfigureEntry procedure} {fonts} {
    catch {destroy .e}
    entry .e -font $fixed -bd 2 -relief flat
    pack .e
    .e insert end "0123"
    update
    list [.e index @@10] [.e index @@11] [.e index @@12] [.e index @@13]
} {0 0 1 1}
test entry-5.11 {ConfigureEntry procedure} {
    # If "0" in selected font had 0 width, caused divide-by-zero error.

    catch {destroy .e}
    pack [entry .e -font {{open look glyph}}]
    .e scan dragto 30
    update
} {}    

# No tests for DisplayEntry.

test entry-6.1 {EntryComputeGeometry procedure} {fonts} {
    catch {destroy .e}
    entry .e -font $fixed -bd 2 -relief raised -width 20 -highlightthickness 3
    pack .e
    .e insert end 012\t45
    update
    list [.e index @@61] [.e index @@62]
} {3 4}
test entry-6.2 {EntryComputeGeometry procedure} {fonts} {
    catch {destroy .e}
    entry .e -font $fixed -bd 2 -relief raised -width 20 -justify center \
	    -highlightthickness 3
    pack .e
    .e insert end 012\t45
    update
    list [.e index @@96] [.e index @@97]
} {3 4}
test entry-6.3 {EntryComputeGeometry procedure} {fonts} {
    catch {destroy .e}
    entry .e -font $fixed -bd 2 -relief raised -width 20 -justify right \
	    -highlightthickness 3
    pack .e
    .e insert end 012\t45
    update
    list [.e index @@131] [.e index @@132]
} {3 4}
test entry-6.4 {EntryComputeGeometry procedure} {
    catch {destroy .e}
    entry .e -font $fixed -bd 2 -relief raised -width 5
    pack .e
    .e insert end "01234567890"
    update
    .e xview 6
    .e index @@0
} {6}
test entry-6.5 {EntryComputeGeometry procedure} {
    catch {destroy .e}
    entry .e -font $fixed -bd 2 -relief raised -width 5
    pack .e
    .e insert end "01234567890"
    update
    .e xview 7
    .e index @@0
} {6}
test entry-6.6 {EntryComputeGeometry procedure} {fonts} {
    catch {destroy .e}
    entry .e -font $fixed -bd 2 -relief raised -width 10
    pack .e
    .e insert end "01234\t67890"
    update
    .e xview 3
    list [.e index @@39] [.e index @@40]
} {5 6}
test entry-6.7 {EntryComputeGeometry procedure} {fonts} {
    catch {destroy .e}
    entry .e -font $big -bd 3 -relief raised -width 5
    pack .e
    .e insert end "01234567"
    update
    list [winfo reqwidth .e] [winfo reqheight .e]
} {77 39}
test entry-6.8 {EntryComputeGeometry procedure} {fonts} {
    catch {destroy .e}
    entry .e -font $big -bd 3 -relief raised -width 0
    pack .e
    .e insert end "01234567"
    update
    list [winfo reqwidth .e] [winfo reqheight .e]
} {116 39}
test entry-6.9 {EntryComputeGeometry procedure} {fonts} {
    catch {destroy .e}
    entry .e -font $big -bd 3 -relief raised -width 0 -highlightthickness 2
    pack .e
    update
    list [winfo reqwidth .e] [winfo reqheight .e]
} {25 39}
test entry-6.10 {EntryComputeGeometry procedure} {unixOnly fonts} {
    catch {destroy .e}
    entry .e -bd 1 -relief raised -width 0 -show .
    .e insert 0 12345
    pack .e
    update
    set x [winfo reqwidth .e]
    .e configure -show X
    lappend x [winfo reqwidth .e]
    .e configure -show ""
    lappend x [winfo reqwidth .e]
} {23 53 43}
test entry-6.11 {EntryComputeGeometry procedure} {pcOnly} {
    catch {destroy .e}
    entry .e -bd 1 -relief raised -width 0 -show . -font {helvetica 12}
    .e insert 0 12345
    pack .e
    update
    set x [winfo reqwidth .e]
    .e configure -show X
    lappend x [winfo reqwidth .e]
    .e configure -show ""
    lappend x [winfo reqwidth .e]
} [list \
    [expr 8+5*[font measure {helvetica 12} .]] \
    [expr 8+5*[font measure {helvetica 12} X]] \
    [expr 8+[font measure {helvetica 12} 12345]]]

catch {destroy .e}
entry .e -width 10 -font $fixed -textvariable contents -xscrollcommand scroll
pack .e
focus .e
test entry-7.1 {InsertChars procedure} {
    .e delete 0 end
    .e insert 0 abcde
    .e insert 2 XXX
    update
    list [.e get] $contents $scrollInfo
} {abXXXcde abXXXcde {0 1}}
test entry-7.2 {InsertChars procedure} {
    .e delete 0 end
    .e insert 0 abcde
    .e insert 500 XXX
    update
    list [.e get] $contents $scrollInfo
} {abcdeXXX abcdeXXX {0 1}}
test entry-7.3 {InsertChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789
    .e select from 2
    .e select to 6
    .e insert 2 XXX
    set x "[.e index sel.first] [.e index sel.last]"
    .e select to 8
    lappend x [.e index sel.first] [.e index sel.last]
} {5 9 5 8}
test entry-7.4 {InsertChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789
    .e select from 2
    .e select to 6
    .e insert 3 XXX
    set x "[.e index sel.first] [.e index sel.last]"
    .e select to 8
    lappend x [.e index sel.first] [.e index sel.last]
} {2 9 2 8}
test entry-7.5 {InsertChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789
    .e select from 2
    .e select to 6
    .e insert 5 XXX
    set x "[.e index sel.first] [.e index sel.last]"
    .e select to 8
    lappend x [.e index sel.first] [.e index sel.last]
} {2 9 2 8}
test entry-7.6 {InsertChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789
    .e select from 2
    .e select to 6
    .e insert 6 XXX
    set x "[.e index sel.first] [.e index sel.last]"
    .e select to 5
    lappend x [.e index sel.first] [.e index sel.last]
} {2 6 2 5}
test entry-7.7 {InsertChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789
    .e icursor 4
    .e insert 4 XXX
    .e index insert
} {7}
test entry-7.8 {InsertChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789
    .e icursor 4
    .e insert 5 XXX
    .e index insert
} {4}
test entry-7.9 {InsertChars procedure} {
    .e delete 0 end
    .e insert 0 "This is a very long string"
    update
    .e xview 4
    .e insert 3 XXX
    .e index @@0
} {7}
test entry-7.10 {InsertChars procedure} {
    .e delete 0 end
    .e insert 0 "This is a very long string"
    update
    .e xview 4
    .e insert 4 XXX
    .e index @@0
} {4}
.e configure -width 0
test entry-7.11 {InsertChars procedure} {fonts} {
    .e delete 0 end
    .e insert 0 "xyzzy"
    update
    .e insert 2 00
    winfo reqwidth .e
} {59}

.e configure -width 10
test entry-8.1 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 abcde
    .e delete 2 4
    update
    list [.e get] $contents $scrollInfo
} {abe abe {0 1}}
test entry-8.2 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 abcde
    .e delete -2 2
    update
    list [.e get] $contents $scrollInfo
} {cde cde {0 1}}
test entry-8.3 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 abcde
    .e delete 3 1000
    update
    list [.e get] $contents $scrollInfo
} {abc abc {0 1}}
test entry-8.4 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789abcde
    .e select from 3
    .e select to 8
    .e delete 1 3
    update
    set x "[.e index sel.first] [.e index sel.last]"
    .e select to 5
    lappend x [.e index sel.first] [.e index sel.last]
} {1 6 1 5}
test entry-8.5 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789abcde
    .e select from 3
    .e select to 8
    .e delete 1 4
    update
    set x "[.e index sel.first] [.e index sel.last]"
    .e select to 4
    lappend x [.e index sel.first] [.e index sel.last]
} {1 5 1 4}
test entry-8.6 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789abcde
    .e select from 3
    .e select to 8
    .e delete 1 7
    update
    set x "[.e index sel.first] [.e index sel.last]"
    .e select to 5
    lappend x [.e index sel.first] [.e index sel.last]
} {1 2 1 5}
test entry-8.7 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789abcde
    .e select from 3
    .e select to 8
    .e delete 1 8
    list [catch {.e index sel.first} msg] $msg
} {1 {selection isn't in widget .e}}
test entry-8.8 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789abcde
    .e select from 3
    .e select to 8
    .e delete 3 7
    update
    set x "[.e index sel.first] [.e index sel.last]"
    .e select to 8
    lappend x [.e index sel.first] [.e index sel.last]
} {3 4 3 8}
test entry-8.9 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789abcde
    .e select from 3
    .e select to 8
    .e delete 3 8
    list [catch {.e index sel.first} msg] $msg
} {1 {selection isn't in widget .e}}
test entry-8.10 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789abcde
    .e select from 8
    .e select to 3
    .e delete 5 8
    update
    set x "[.e index sel.first] [.e index sel.last]"
    .e select to 8
    lappend x [.e index sel.first] [.e index sel.last]
} {3 5 5 8}
test entry-8.11 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789abcde
    .e select from 8
    .e select to 3
    .e delete 8 10
    update
    set x "[.e index sel.first] [.e index sel.last]"
    .e select to 4
    lappend x [.e index sel.first] [.e index sel.last]
} {3 8 4 8}
test entry-8.12 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789abcde
    .e icursor 4
    .e delete 1 4
    .e index insert
} {1}
test entry-8.13 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789abcde
    .e icursor 4
    .e delete 1 5
    .e index insert
} {1}
test entry-8.14 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 0123456789abcde
    .e icursor 4
    .e delete 4 6
    .e index insert
} {4}
test entry-8.15 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 "This is a very long string"
    .e xview 4
    .e delete 1 4
    .e index @@0
} {1}
test entry-8.16 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 "This is a very long string"
    .e xview 4
    .e delete 1 5
    .e index @@0
} {1}
test entry-8.17 {DeleteChars procedure} {
    .e delete 0 end
    .e insert 0 "This is a very long string"
    .e xview 4
    .e delete 4 6
    .e index @@0
} {4}
.e configure -width 0
test entry-8.18 {DeleteChars procedure} {fonts} {
    .e delete 0 end
    .e insert 0 "xyzzy"
    update
    .e delete 2 4
    winfo reqwidth .e
} {31}

test entry-9.1 {EntryValueChanged procedure} {
    catch {destroy .e}
    proc override args {
	global x
	set x 12345
    }
    catch {unset x}
    trace variable x w override
    entry .e -textvariable x
    .e insert 0 foo
    set result [list $x [.e get]]
    unset x; rename override {}
    set result
} {12345 12345}

catch {destroy .e}
entry .e
pack .e
.e configure -width 0
test entry-10.1 {EntrySetValue procedure} {fonts} {
    set x abcde
    set y ab
    .e configure -textvariable x
    update
    .e configure -textvariable y
    update
    list [.e get] [winfo reqwidth .e]
} {ab 24}
test entry-10.2 {EntrySetValue procedure, updating selection} {
    catch {destroy .e}
    entry .e -textvariable x
    .e insert 0 "abcdefghjklmnopqrstu"
    .e selection range 4 10
    set x "a"
    list [catch {.e index sel.first} msg] $msg
} {1 {selection isn't in widget .e}}
test entry-10.3 {EntrySetValue procedure, updating selection} {
    catch {destroy .e}
    entry .e -textvariable x
    .e insert 0 "abcdefghjklmnopqrstu"
    .e selection range 4 10
    set x "abcdefg"
    list [.e index sel.first] [.e index sel.last]
} {4 7}
test entry-10.4 {EntrySetValue procedure, updating selection} {
    catch {destroy .e}
    entry .e -textvariable x
    .e insert 0 "abcdefghjklmnopqrstu"
    .e selection range 4 10
    set x "abcdefghijklmn"
    list [.e index sel.first] [.e index sel.last]
} {4 10}
test entry-10.5 {EntrySetValue procedure, updating display position} {
    catch {destroy .e}
    entry .e -width 10 -font $fixed -textvariable x
    pack .e
    .e insert 0 "abcdefghjklmnopqrstuvwxyz"
    .e xview 10
    update
    set x "abcdefg"
    update
    .e index @@0
} {0}
test entry-10.6 {EntrySetValue procedure, updating display position} {
    catch {destroy .e}
    entry .e -width 10 -font $fixed -textvariable x
    pack .e
    .e insert 0 "abcdefghjklmnopqrstuvwxyz"
    .e xview 10
    update
    set x "1234567890123456789012"
    update
    .e index @@0
} {10}
test entry-10.7 {EntrySetValue procedure, updating insertion cursor} {
    catch {destroy .e}
    entry .e -width 10 -font $fixed -textvariable x
    pack .e
    .e insert 0 "abcdefghjklmnopqrstuvwxyz"
    .e icursor 5
    set x "123"
    .e index insert
} {3}
test entry-10.8 {EntrySetValue procedure, updating insertion cursor} {
    catch {destroy .e}
    entry .e -width 10 -font $fixed -textvariable x
    pack .e
    .e insert 0 "abcdefghjklmnopqrstuvwxyz"
    .e icursor 5
    set x "123456"
    .e index insert
} {5}

test entry-11.1 {EntryEventProc procedure} {
    catch {destroy .e}
    entry .e
    .e insert 0 abcdefg
    destroy .e
    update
} {}
test entry-11.2 {EntryEventProc procedure} {
    deleteWindows
    entry .e1 -fg #112233
    rename .e1 .e2
    set x {}
    lappend x [winfo children .]
    lappend x [.e2 cget -fg]
    destroy .e1
    lappend x [info command .e*] [winfo children .]
} {.e1 #112233 {} {}}

test entry-12.1 {EntryCmdDeletedProc procedure} {
    deleteWindows
    button .e1 -text "xyz_123"
    rename .e1 {}
    list [info command .e*] [winfo children .]
} {{} {}}

catch {destroy .e}
entry .e -font $fixed -width 5 -bd 2 -relief sunken
pack .e
.e insert 0 012345678901234567890
.e xview 4
update
test entry-13.1 {GetEntryIndex procedure} {
    .e index end
} {21}
test entry-13.2 {GetEntryIndex procedure} {
    list [catch {.e index abogus} msg] $msg
} {1 {bad entry index "abogus"}}
test entry-13.3 {GetEntryIndex procedure} {
    .e select from 1
    .e select to 6
    .e index anchor
} {1}
test entry-13.4 {GetEntryIndex procedure} {
    .e select from 4
    .e select to 1
    .e index anchor
} {4}
test entry-13.5 {GetEntryIndex procedure} {
    .e select from 3
    .e select to 15
    .e select adjust 4
    .e index anchor
} {15}
test entry-13.6 {GetEntryIndex procedure} {
    list [catch {.e index ebogus} msg] $msg
} {1 {bad entry index "ebogus"}}
test entry-13.7 {GetEntryIndex procedure} {
    .e icursor 2
    .e index insert
} {2}
test entry-13.8 {GetEntryIndex procedure} {
    list [catch {.e index ibogus} msg] $msg
} {1 {bad entry index "ibogus"}}
test entry-13.9 {GetEntryIndex procedure} {
    .e select from 1
    .e select to 6
    list [.e index sel.first] [.e index sel.last]
} {1 6}
selection clear .e
test entry-13.10 {GetEntryIndex procedure} {unixOnly} {
    # On unix, when selection is cleared, entry widget's internal 
    # selection range is reset.

    list [catch {.e index sel.first} msg] $msg
} {1 {selection isn't in widget .e}}
test entry-13.11 {GetEntryIndex procedure} {macOrPc} {
    # On mac and pc, when selection is cleared, entry widget remembers
    # last selected range.  When selection ownership is restored to 
    # entry, the old range will be rehighlighted.

    list [catch {selection get}] [.e index sel.first]
} {1 1}
test entry-13.12 {GetEntryIndex procedure} {unixOnly} {
    list [catch {.e index sbogus} msg] $msg
} {1 {selection isn't in widget .e}}
test entry-13.13 {GetEntryIndex procedure} {macOrPc} {
    list [catch {.e index sbogus} msg] $msg
} {1 {bad entry index "sbogus"}}
test entry-13.14 {GetEntryIndex procedure} {macOrPc} {
    list [catch {selection get}] [catch {.e index sbogus}]
} {1 1}
test entry-13.15 {GetEntryIndex procedure} {
    list [catch {.e index @@xyz} msg] $msg
} {1 {bad entry index "@@xyz"}}
test entry-13.16 {GetEntryIndex procedure} {fonts} {
    .e index @@4
} {4}
test entry-13.17 {GetEntryIndex procedure} {fonts} {
    .e index @@11
} {4}
test entry-13.18 {GetEntryIndex procedure} {fonts} {
    .e index @@12
} {5}
test entry-13.19 {GetEntryIndex procedure} {fonts} {
    .e index @@[expr [winfo width .e] - 6]
} {8}
test entry-13.20 {GetEntryIndex procedure} {fonts} {
    .e index @@[expr [winfo width .e] - 5]
} {9}
test entry-13.21 {GetEntryIndex procedure} {
    .e index @@1000
} {9}
test entry-13.22 {GetEntryIndex procedure} {
    list [catch {.e index 1xyz} msg] $msg
} {1 {bad entry index "1xyz"}}
test entry-13.23 {GetEntryIndex procedure} {
    .e index -10
} {0}
test entry-13.24 {GetEntryIndex procedure} {
    .e index 12
} {12}
test entry-13.25 {GetEntryIndex procedure} {
    .e index 49
} {21}
test entry-13.26 {GetEntryIndex procedure} {fonts} {
    catch {destroy .e}
    entry .e -show .
    .e insert 0 XXXYZZY
    pack .e
    update
    list [.e index @@7] [.e index @@8]
} {0 1}

# XXX Still need to write tests for EntryScanTo and EntrySelectTo.

set x {}
for {set i 1} {$i <= 500} {incr i} {
    append x "This is line $i, out of 500\n"
}
test entry-14.1 {EntryFetchSelection procedure} {
    catch {destroy .e}
    entry .e
    .e insert end "This is a test string"
    .e select from 1
    .e select to 18
    selection get
} {his is a test str}
test entry-14.2 {EntryFetchSelection procedure} {
    catch {destroy .e}
    entry .e -show *
    .e insert end "This is a test string"
    .e select from 1
    .e select to 18
    selection get
} {*****************}
test entry-14.3 {EntryFetchSelection procedure} {
    catch {destroy .e}
    entry .e
    .e insert end $x
    .e select from 0
    .e select to end
    string compare [selection get] $x
} 0

test entry-15.1 {EntryLostSelection} {
    catch {destroy .e}
    entry .e
    .e insert 0 "Text"
    .e select from 0
    .e select to 4
    set result [selection get]
    selection clear
    .e select from 0
    .e select to 4
    lappend result [selection get]
} {Text Text}

# No tests for EventuallyRedraw.

catch {destroy .e}
entry .e -width 10 -xscrollcommand scroll
pack .e
update

test entry-16.1 {EntryVisibleRange procedure} {fonts} {
    .e delete 0 end
    .e insert 0 .............................
    .e xview
} {0 0.827586}
test entry-15.2 {EntryVisibleRange procedure} {unixOnly fonts} {
    .e configure -show X
    .e delete 0 end
    .e insert 0 .............................
    .e xview
} {0 0.275862}
test entry-15.3 {EntryVisibleRange procedure} {pcOnly} {
    .e configure -show .
    .e delete 0 end
    .e insert 0 XXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    .e xview
} {0 0.827586}
.e configure -show ""
test entry-15.4 {EntryVisibleRange procedure} {
    .e delete 0 end
    .e xview
} {0 1}

catch {destroy .e}
entry .e -width 10 -xscrollcommand scroll -font $fixed
pack .e
update
test entry-17.1 {EntryUpdateScrollbar procedure} {
    .e delete 0 end
    .e insert 0 123
    update
    set scrollInfo
} {0 1}
test entry-17.2 {EntryUpdateScrollbar procedure} {
    .e delete 0 end
    .e insert 0 0123456789abcdef
    .e xview 3
    update
    set scrollInfo
} {0.1875 0.8125}
test entry-17.3 {EntryUpdateScrollbar procedure} {
    .e delete 0 end
    .e insert 0 abcdefghijklmnopqrs
    .e xview 6
    update
    set scrollInfo
} {0.315789 0.842105}
test entry-17.4 {EntryUpdateScrollbar procedure} {
    destroy .e
    proc bgerror msg {
	global x
	set x $msg
    }
    entry .e -width 5 -xscrollcommand thisisnotacommand
    pack .e
    update
    rename bgerror {}
    list $x $errorInfo
} {{invalid command name "thisisnotacommand"} {invalid command name "thisisnotacommand"
    while executing
"thisisnotacommand 0 1"
    (horizontal scrolling command executed by .e)}}

set l [interp hidden]
deleteWindows

test entry-18.1 {Entry widget vs hiding} {
    destroy .e
    entry .e
    interp hide {} .e
    destroy .e
    list [winfo children .] [interp hidden]
} [list {} $l]    

##
## Entry widget VALIDATION tests
##

destroy .e
catch {unset ::e}
catch {unset ::vVals}
entry .e -validate all \
	-validatecommand [list doval %W %d %i %P %s %S %v %V] \
	-invalidcommand bell \
	-textvariable ::e \
	-background red -foreground white
pack .e
proc doval {W d i P s S v V} {
    set ::vVals [list $W $d $i $P $s $S $v $V]
    return 1
}

# The validation tests build each one upon the previous, so cascading
# failures aren't good
#
test entry-19.1 {entry widget validation} {
    .e insert 0 a
    set ::vVals
} {.e 1 0 a {} a all key}
test entry-19.2 {entry widget validation} {
    .e insert 1 b
    set ::vVals
} {.e 1 1 ab a b all key}
test entry-19.3 {entry widget validation} {
    .e insert end c
    set ::vVals
} {.e 1 2 abc ab c all key}
test entry-19.4 {entry widget validation} {
    .e insert 1 123
    list $::vVals $::e
} {{.e 1 1 a123bc abc 123 all key} a123bc}
test entry-19.5 {entry widget validation} {
    .e delete 2
    set ::vVals
} {.e 0 2 a13bc a123bc 2 all key}
test entry-19.6 {entry widget validation} {
    .e configure -validate key
    .e delete 1 3
    set ::vVals
} {.e 0 1 abc a13bc 13 key key}
test entry-19.7 {entry widget validation} {
    set ::vVals {}
    .e configure -validate focus
    .e insert end d
    set ::vVals
} {}
test entry-19.8 {entry widget validation} {
    focus -force .e
    # update necessary to process FocusIn event
    update
    set ::vVals
} {.e -1 -1 abcd abcd {} focus focusin}
test entry-19.9 {entry widget validation} {
    focus -force .
    # update necessary to process FocusOut event
    update
    set ::vVals
} {.e -1 -1 abcd abcd {} focus focusout}
.e configure -validate all
test entry-19.10 {entry widget validation} {
    focus -force .e
    # update necessary to process FocusIn event
    update
    set ::vVals
} {.e -1 -1 abcd abcd {} all focusin}
test entry-19.11 {entry widget validation} {
    focus -force .
    # update necessary to process FocusOut event
    update
    set ::vVals
} {.e -1 -1 abcd abcd {} all focusout}
.e configure -validate focusin
test entry-19.12 {entry widget validation} {
    focus -force .e
    # update necessary to process FocusIn event
    update
    set ::vVals
} {.e -1 -1 abcd abcd {} focusin focusin}
test entry-19.13 {entry widget validation} {
    set ::vVals {}
    focus -force .
    # update necessary to process FocusOut event
    update
    set ::vVals
} {}
.e configure -validate focuso
test entry-19.14 {entry widget validation} {
    focus -force .e
    # update necessary to process FocusIn event
    update
    set ::vVals
} {}
test entry-19.15 {entry widget validation} {
    focus -force .
    # update necessary to process FocusOut event
    update
    set ::vVals
} {.e -1 -1 abcd abcd {} focusout focusout}
test entry-19.16 {entry widget validation} {
    list [.e validate] $::vVals
} {1 {.e -1 -1 abcd abcd {} all forced}}
test entry-19.17 {entry widget validation} {
    set ::e newdata
    list [.e cget -validate] $::vVals
} {focusout {.e -1 -1 newdata abcd {} focusout forced}}

proc doval {W d i P s S v V} {
    set ::vVals [list $W $d $i $P $s $S $v $V]
    return 0
}

test entry-19.18 {entry widget validation} {
    .e configure -validate all
    set ::e nextdata
    list [.e cget -validate] $::vVals
} {none {.e -1 -1 nextdata newdata {} all forced}}

proc doval {W d i P s S v V} {
    set ::vVals [list $W $d $i $P $s $S $v $V]
    set ::e mydata
    return 1
}

## This sets validate to none because it shows that we prevent a possible
## loop condition in the validation, when the entry textvar is also set
test entry-19.19 {entry widget validation} {
    .e configure -validate all
    .e validate
    list [.e cget -validate] [.e get] $::vVals
} {none mydata {.e -1 -1 nextdata nextdata {} all forced}}

## This leaves validate alone because we trigger validation through the
## textvar (a write trace), and the write during validation triggers
## nothing (by definition of avoiding loops on var traces).  This is
## one of those "dangerous" conditions where the user will have a
## different value in the entry widget shown as is in the textvar.
test entry-19.20 {entry widget validation} {
    .e configure -validate all
    set ::e testdata
    list [.e cget -validate] [.e get] $::e $::vVals
} {all testdata mydata {.e -1 -1 testdata mydata {} all forced}}

destroy .e
catch {unset ::e ::vVals}

##
## End validation tests
##

test entry-20.1 {widget deletion while active} {
    destroy .e
    entry .e -validate all \
	    -validatecommand { destroy %W ; return 1 } \
	    -invalidcommand bell
    update
    .e insert 0 abc
    winfo exists .e
} 0
test entry-20.2 {widget deletion while active} {
    destroy .e
    entry .e -validate all \
	    -validatecommand { return 0 } \
	    -invalidcommand { destroy %W }
    .e insert 0 abc
    winfo exists .e
} 0
test entry-20.3 {widget deletion while active} {
    destroy .e
    entry .e -validate all \
	    -validatecommand { rename .e {} ; return 1 }
    .e insert 0 abc
    winfo exists .e
} 0
test entry-20.4 {widget deletion while active} {
    destroy .e
    entry .e -validate all \
	    -validatecommand { return 0 } \
	    -invalidcommand { rename .e {} }
    .e insert 0 abc
    winfo exists .e
} 0
test entry-20.5 {widget deletion while active} {
    destroy .e
    entry .e -validatecommand { destroy .e ; return 0 }
    .e validate
    winfo exists .e
} 0
test entry-20.6 {widget deletion while active} {
    destroy .e
    pack [entry .e]
    update
    .e config -xscrollcommand { destroy .e }
    update idle
    winfo exists .e
} 0
test entry-20.7 {widget deletion with textvariable active} {
    # SF bugs 607390 and 617446
    destroy .e
    set FOO init
    entry .e -textvariable FOO -validate all \
	    -vcmd {%W configure -bg white; format 1}
    bind .e <Destroy> { set FOO hello }
    destroy .e
    winfo exists .e
} 0

# XXX Still need to write tests for EntryBlinkProc, EntryFocusProc,
# and EntryTextVarProc.

option clear

# cleanup
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d9 1
a9 1
# RCS: @@(#) $Id: entry.test,v 1.7.6.2 2000/09/26 16:09:15 spolk Exp $
d11 6
a16 17
if {[lsearch [namespace children] ::tcltest] == -1} {
    source [file join [pwd] [file dirname [info script]] defs.tcl]
}

if {[lsearch [image types] test] < 0} {
    puts "This application hasn't been compiled with the \"test\""
    puts "image, so I can't run this test.  Are you sure you're using"
    puts "tktest instead of wish?"
    ::tcltest::cleanupTests
    return
}

foreach i [winfo children .] {
    destroy $i
}
wm geometry . {}
raise .
d47 1
a47 1
	    {unknown color name "non-existent"}}
d52 4
d70 2
d73 2
d80 2
a81 1
    {-state n normal bogus {bad state "bogus": must be disabled or normal}}
d192 1
a192 1
} {33}
d255 8
d319 8
d438 1
a438 1
} {1 {selection isn't in entry}}
d447 18
d946 1
a946 1
} {1 {selection isn't in entry}}
d965 1
a965 1
} {1 {selection isn't in entry}}
d1074 1
a1074 1
} {1 {selection isn't in entry}}
d1140 1
a1140 1
    eval destroy [winfo children .]
d1151 1
a1151 1
    eval destroy [winfo children .]
d1206 1
a1206 1
} {1 {selection isn't in entry}}
d1216 1
a1216 1
} {1 {selection isn't in entry}}
d1377 1
a1377 1
    (horizontal scrolling command executed by entry)}}
d1380 1
a1380 1
eval destroy [winfo children .]
a1505 1
.e configure -validate all
d1508 1
a1517 1
.e configure -validate all
d1522 1
a1526 2
.e configure -validate all

d1533 1
d1545 57
a1609 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d6 2
d9 5
a13 4
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: entry.test,v 1.11 1999/01/26 04:11:34 jingham Exp $
d19 1
a22 4
if {[info procs test] != "test"} {
    source defs
}

d54 1
d78 1
a78 1
    {-relief groove groove 1.5 {bad relief type "1.5": must be flat, groove, raised, ridge, solid, or sunken}}
d83 1
a83 1
    {-state normal normal bogus {bad state value "bogus": must be normal or disabled}}
d90 1
a90 1
    test entry-1.1 {configuration options} {
d96 1
a96 1
	test entry-1.2 {configuration options} {
d132 1
d150 3
a152 1
test entry-3.6 {EntryWidgetCmd procedure, "bbox" widget command} {fonts} {
d154 26
a179 4
    .e insert 0 "abcdefghijklmnop"
    list [.e bbox 0] [.e bbox 1] [.e bbox end]
} [list "5 5 $cx $cy" "[expr 5+$cx] 5 $cx $cy" "[expr 5+15*$cx] 5 $cx $cy"]
test entry-3.7 {EntryWidgetCmd procedure, "cget" widget command} {
d182 1
a182 1
test entry-3.8 {EntryWidgetCmd procedure, "cget" widget command} {
d185 1
a185 1
test entry-3.9 {EntryWidgetCmd procedure, "cget" widget command} {
d188 1
a188 1
test entry-3.10 {EntryWidgetCmd procedure, "cget" widget command} {
d192 1
a192 1
test entry-3.11 {EntryWidgetCmd procedure, "configure" widget command} {
d194 2
a195 2
} {28}
test entry-3.12 {EntryWidgetCmd procedure, "configure" widget command} {
d198 1
a198 1
test entry-3.13 {EntryWidgetCmd procedure, "configure" widget command} {
d203 1
a203 1
test entry-3.14 {EntryWidgetCmd procedure, "delete" widget command} {
d206 1
a206 1
test entry-3.15 {EntryWidgetCmd procedure, "delete" widget command} {
d209 1
a209 1
test entry-3.16 {EntryWidgetCmd procedure, "delete" widget command} {
d212 1
a212 1
test entry-3.17 {EntryWidgetCmd procedure, "delete" widget command} {
d215 1
a215 1
test entry-3.18 {EntryWidgetCmd procedure, "delete" widget command} {
d221 1
a221 1
test entry-3.19 {EntryWidgetCmd procedure, "delete" widget command} {
d227 17
a243 1
test entry-3.20 {EntryWidgetCmd procedure, "delete" widget command} {
d249 1
a249 1
test entry-3.21 {EntryWidgetCmd procedure, "delete" widget command} {
d257 1
a257 1
test entry-3.22 {EntryWidgetCmd procedure, "get" widget command} {
d260 1
a260 1
test entry-3.23 {EntryWidgetCmd procedure, "icursor" widget command} {
d263 1
a263 1
test entry-3.24 {EntryWidgetCmd procedure, "icursor" widget command} {
d266 1
a266 1
test entry-3.25 {EntryWidgetCmd procedure, "icursor" widget command} {
d272 1
a272 1
test entry-3.26 {EntryWidgetCmd procedure, "index" widget command} {
d274 2
a275 2
} {1 {bad option "in": must be bbox, cget, configure, delete, get, icursor, index, insert, scan, selection, or xview}}
test entry-3.27 {EntryWidgetCmd procedure, "index" widget command} {
d278 1
a278 1
test entry-3.28 {EntryWidgetCmd procedure, "index" widget command} {
d281 1
a281 1
test entry-3.29 {EntryWidgetCmd procedure, "index" widget command} {
d284 7
a290 1
test entry-3.30 {EntryWidgetCmd procedure, "insert" widget command} {
d293 1
a293 1
test entry-3.31 {EntryWidgetCmd procedure, "insert" widget command} {
d296 1
a296 1
test entry-3.32 {EntryWidgetCmd procedure, "insert" widget command} {
d299 1
a299 1
test entry-3.33 {EntryWidgetCmd procedure, "insert" widget command} {
d305 1
a305 1
test entry-3.34 {EntryWidgetCmd procedure, "insert" widget command} {
d313 1
a313 1
test entry-3.35 {EntryWidgetCmd procedure, "insert" widget command} {
d316 1
a316 1
test entry-3.36 {EntryWidgetCmd procedure, "scan" widget command} {
d319 1
a319 1
test entry-3.37 {EntryWidgetCmd procedure, "scan" widget command} {
d322 1
a322 1
test entry-3.38 {EntryWidgetCmd procedure, "scan" widget command} {
d325 1
a325 1
test entry-3.39 {EntryWidgetCmd procedure, "scan" widget command} {
d330 1
a330 1
test entry-3.40 {EntryWidgetCmd procedure, "scan" widget command} {fonts} {
d339 1
a339 1
test entry-3.41 {EntryWidgetCmd procedure, "select" widget command} {
d341 2
a342 2
} {1 {wrong # args: should be ".e select option ?index?"}}
test entry-3.42 {EntryWidgetCmd procedure, "select" widget command} {
d345 1
a345 1
test entry-3.43 {EntryWidgetCmd procedure, "select clear" widget command} {
d348 1
a348 1
test entry-3.44 {EntryWidgetCmd procedure, "select clear" widget command} {
d357 1
a357 1
test entry-3.45 {EntryWidgetCmd procedure, "selection present" widget command} {
d360 1
a360 1
test entry-3.46 {EntryWidgetCmd procedure, "selection present" widget command} {
d367 1
a367 1
test entry-3.47 {EntryWidgetCmd procedure, "selection present" widget command} {
d376 1
a376 1
test entry-3.48 {EntryWidgetCmd procedure, "selection present" widget command} {
d384 1
a384 1
test entry-3.49 {EntryWidgetCmd procedure, "selection adjust" widget command} {
d387 1
a387 1
test entry-3.50 {EntryWidgetCmd procedure, "selection adjust" widget command} {
d390 1
a390 1
test entry-3.51 {EntryWidgetCmd procedure, "selection adjust" widget command} {
d399 1
a399 1
test entry-3.52 {EntryWidgetCmd procedure, "selection adjust" widget command} {
d408 1
a408 1
test entry-3.53 {EntryWidgetCmd procedure, "selection from" widget command} {
d411 1
a411 1
test entry-3.54 {EntryWidgetCmd procedure, "selection range" widget command} {
d414 1
a414 1
test entry-3.55 {EntryWidgetCmd procedure, "selection range" widget command} {
d417 1
a417 1
test entry-3.56 {EntryWidgetCmd procedure, "selection range" widget command} {
d425 1
a425 1
test entry-3.57 {EntryWidgetCmd procedure, "selection range" widget command} {
d436 1
a436 1
test entry-3.58 {EntryWidgetCmd procedure, "selection to" widget command} {
d439 1
a439 1
test entry-3.59 {EntryWidgetCmd procedure, "xview" widget command} {
d443 1
a443 1
test entry-3.60 {EntryWidgetCmd procedure, "xview" widget command} {
d446 1
a446 1
test entry-3.61 {EntryWidgetCmd procedure, "xview" widget command} {
d452 1
a452 1
test entry-3.62 {EntryWidgetCmd procedure, "xview" widget command} {
d455 1
a455 1
test entry-3.63 {EntryWidgetCmd procedure, "xview" widget command} {
d458 1
a458 1
test entry-3.64 {EntryWidgetCmd procedure, "xview" widget command} {
d462 1
a462 1
test entry-3.65 {EntryWidgetCmd procedure, "xview" widget command} {
d465 1
a465 1
test entry-3.66 {EntryWidgetCmd procedure, "xview" widget command} {
d468 1
a468 1
test entry-3.67 {EntryWidgetCmd procedure, "xview" widget command} {
d473 1
a473 1
test entry-3.68 {EntryWidgetCmd procedure, "xview" widget command} {
d479 1
a479 1
test entry-3.69 {EntryWidgetCmd procedure, "xview" widget command} {
d485 1
a485 1
test entry-3.70 {EntryWidgetCmd procedure, "xview" widget command} {
d491 1
a491 1
test entry-3.71 {EntryWidgetCmd procedure, "xview" widget command} {
d494 1
a494 1
test entry-3.72 {EntryWidgetCmd procedure, "xview" widget command} {
d497 1
a497 1
test entry-3.73 {EntryWidgetCmd procedure, "xview" widget command} {
d503 1
a503 1
test entry-3.74 {EntryWidgetCmd procedure, "xview" widget command} {
d507 15
a521 1
test entry-3.75 {EntryWidgetCmd procedure} {
d523 1
a523 1
} {1 {bad option "gorp": must be bbox, cget, configure, delete, get, icursor, index, insert, scan, selection, or xview}}
d727 1
a727 1
test entry-6.10 {EntryComputeGeometry procedure} {fonts} {
d739 15
d1169 4
a1172 4
test entry-13.10 {GetEntryIndex procedure} {pc} {
    .e index sel.first
} {1}
test entry-13.11 {GetEntryIndex procedure} {!pc} {
d1175 11
a1185 1
test entry-13.12 {GetEntryIndex procedure} {pc} {
d1188 4
a1191 4
test entry-13.13 {GetEntryIndex procedure} {!pc} {
    list [catch {.e index sbogus} msg] $msg
} {1 {selection isn't in entry}}
test entry-13.14 {GetEntryIndex procedure} {
d1194 1
a1194 1
test entry-13.15 {GetEntryIndex procedure} {fonts} {
d1197 1
a1197 1
test entry-13.16 {GetEntryIndex procedure} {fonts} {
d1200 1
a1200 1
test entry-13.17 {GetEntryIndex procedure} {fonts} {
d1203 1
a1203 1
test entry-13.18 {GetEntryIndex procedure} {fonts} {
d1206 1
a1206 1
test entry-13.19 {GetEntryIndex procedure} {fonts} {
d1209 1
a1209 1
test entry-13.20 {GetEntryIndex procedure} {
d1212 1
a1212 1
test entry-13.21 {GetEntryIndex procedure} {
d1215 1
a1215 1
test entry-13.22 {GetEntryIndex procedure} {
d1218 1
a1218 1
test entry-13.23 {GetEntryIndex procedure} {
d1221 1
a1221 1
test entry-13.24 {GetEntryIndex procedure} {
d1224 1
a1224 1
test entry-13.25 {GetEntryIndex procedure} {fonts} {
d1289 1
a1289 1
test entry-16.2 {EntryVisibleRange procedure} {fonts} {
d1295 6
d1302 1
a1302 1
test entry-16.3 {EntryVisibleRange procedure} {
d1332 1
a1332 1
    catch {destroy .e}
d1337 1
a1337 1
    entry .e -width 5 -xscrollcommand bogus
d1342 1
a1342 1
} {{invalid command name "bogus"} {invalid command name "bogus"
d1344 1
a1344 1
"bogus 0 1"
d1351 1
a1351 1
    catch {destroy .e}
d1357 157
a1513 1
    
d1517 5
a1522 1
option clear
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@a5 2
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
d7 4
a10 5
# RCS: @@(#) $Id: entry.test,v 1.7.6.2 2000/09/26 16:09:15 spolk Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    source [file join [pwd] [file dirname [info script]] defs.tcl]
}
a15 1
    ::tcltest::cleanupTests
d19 4
a53 1

d77 1
a77 1
    {-relief groove groove 1.5 {bad relief "1.5": must be flat, groove, raised, ridge, solid, or sunken}}
d82 1
a82 1
    {-state n normal bogus {bad state "bogus": must be disabled or normal}}
d89 1
a89 1
    test entry-1.$i {configuration options} {
d95 1
a95 1
	test entry-1.$i {configuration options} {
a130 1
set ux [font measure $fixed \u4e4e]
d148 1
a148 3
test entry-3.6 {EntryWidgetCmd procedure, "bbox" widget command} {
    # Tcl_UtfAtIndex(): no utf chars

d150 4
a153 26
    .e insert 0 "abc"
    list [.e bbox 3] [.e bbox end]
} [list "[expr 5+2*$cx] 5 $cx $cy" "[expr 5+2*$cx] 5 $cx $cy"]
test entry-3.7 {EntryWidgetCmd procedure, "bbox" widget command} {
    # Tcl_UtfAtIndex(): utf at end
    .e delete 0 end
    .e insert 0 "ab\u4e4e"
    .e bbox end
} "[expr 5+2*$cx] 5 $ux $cy"
test entry-3.8 {EntryWidgetCmd procedure, "bbox" widget command} {
    # Tcl_UtfAtIndex(): utf before index
    .e delete 0 end
    .e insert 0 "ab\u4e4ec"
    .e bbox 3
} "[expr 5+2*$cx+$ux] 5 $cx $cy"
test entry-3.9 {EntryWidgetCmd procedure, "bbox" widget command} {
    # Tcl_UtfAtIndex(): no chars
    .e delete 0 end
    .e bbox end
} "5 5 0 $cy"
test entry-3.10 {EntryWidgetCmd procedure, "bbox" widget command} {
    .e delete 0 end
    .e insert 0 "abcdefghij\u4e4eklmnop"
    list [.e bbox 0] [.e bbox 1] [.e bbox 10] [.e bbox end]
} [list "5 5 $cx $cy" "[expr 5+$cx] 5 $cx $cy" "[expr 5+10*$cx] 5 $ux $cy" "[expr 5+$ux+15*$cx] 5 $cx $cy"]
test entry-3.11 {EntryWidgetCmd procedure, "cget" widget command} {
d156 1
a156 1
test entry-3.12 {EntryWidgetCmd procedure, "cget" widget command} {
d159 1
a159 1
test entry-3.13 {EntryWidgetCmd procedure, "cget" widget command} {
d162 1
a162 1
test entry-3.14 {EntryWidgetCmd procedure, "cget" widget command} {
d166 1
a166 1
test entry-3.15 {EntryWidgetCmd procedure, "configure" widget command} {
d168 2
a169 2
} {33}
test entry-3.16 {EntryWidgetCmd procedure, "configure" widget command} {
d172 1
a172 1
test entry-3.17 {EntryWidgetCmd procedure, "configure" widget command} {
d177 1
a177 1
test entry-3.18 {EntryWidgetCmd procedure, "delete" widget command} {
d180 1
a180 1
test entry-3.19 {EntryWidgetCmd procedure, "delete" widget command} {
d183 1
a183 1
test entry-3.20 {EntryWidgetCmd procedure, "delete" widget command} {
d186 1
a186 1
test entry-3.21 {EntryWidgetCmd procedure, "delete" widget command} {
d189 1
a189 1
test entry-3.22 {EntryWidgetCmd procedure, "delete" widget command} {
d195 1
a195 1
test entry-3.23 {EntryWidgetCmd procedure, "delete" widget command} {
d201 1
a201 17
test entry-3.24 {EntryWidgetCmd procedure, "delete" widget command} {
    # UTF
    set x {}
    .e delete 0 end
    .e insert end "01234\u4e4e67890"
    .e delete 6
    lappend x [.e get]
    .e delete 0 end
    .e insert end "012345\u4e4e7890"
    .e delete 6
    lappend x [.e get]
    .e delete 0 end
    .e insert end "0123456\u4e4e890"
    .e delete 6
    lappend x [.e get]
} [list "01234\u4e4e7890" "0123457890" "012345\u4e4e890"]
test entry-3.25 {EntryWidgetCmd procedure, "delete" widget command} {
d207 1
a207 1
test entry-3.26 {EntryWidgetCmd procedure, "delete" widget command} {
d215 1
a215 1
test entry-3.27 {EntryWidgetCmd procedure, "get" widget command} {
d218 1
a218 1
test entry-3.28 {EntryWidgetCmd procedure, "icursor" widget command} {
d221 1
a221 1
test entry-3.29 {EntryWidgetCmd procedure, "icursor" widget command} {
d224 1
a224 1
test entry-3.30 {EntryWidgetCmd procedure, "icursor" widget command} {
d230 1
a230 1
test entry-3.31 {EntryWidgetCmd procedure, "index" widget command} {
d232 2
a233 2
} {1 {ambiguous option "in": must be bbox, cget, configure, delete, get, icursor, index, insert, scan, selection, validate, or xview}}
test entry-3.32 {EntryWidgetCmd procedure, "index" widget command} {
d236 1
a236 1
test entry-3.33 {EntryWidgetCmd procedure, "index" widget command} {
d239 1
a239 1
test entry-3.34 {EntryWidgetCmd procedure, "index" widget command} {
d242 1
a242 7
test entry-3.35 {EntryWidgetCmd procedure, "index" widget command} {
    # UTF
    .e delete 0 end
    .e insert 0 abc\u4e4e\u0153def
    list [.e index 3] [.e index 4] [.e index end]
} {3 4 8}
test entry-3.36 {EntryWidgetCmd procedure, "insert" widget command} {
d245 1
a245 1
test entry-3.37 {EntryWidgetCmd procedure, "insert" widget command} {
d248 1
a248 1
test entry-3.38 {EntryWidgetCmd procedure, "insert" widget command} {
d251 1
a251 1
test entry-3.39 {EntryWidgetCmd procedure, "insert" widget command} {
d257 1
a257 1
test entry-3.40 {EntryWidgetCmd procedure, "insert" widget command} {
d265 1
a265 1
test entry-3.41 {EntryWidgetCmd procedure, "insert" widget command} {
d268 1
a268 1
test entry-3.42 {EntryWidgetCmd procedure, "scan" widget command} {
d271 1
a271 1
test entry-3.43 {EntryWidgetCmd procedure, "scan" widget command} {
d274 1
a274 1
test entry-3.44 {EntryWidgetCmd procedure, "scan" widget command} {
d277 1
a277 1
test entry-3.45 {EntryWidgetCmd procedure, "scan" widget command} {
d282 1
a282 1
test entry-3.46 {EntryWidgetCmd procedure, "scan" widget command} {fonts} {
d291 1
a291 1
test entry-3.47 {EntryWidgetCmd procedure, "select" widget command} {
d293 2
a294 2
} {1 {wrong # args: should be ".e selection option ?index?"}}
test entry-3.48 {EntryWidgetCmd procedure, "select" widget command} {
d297 1
a297 1
test entry-3.49 {EntryWidgetCmd procedure, "select clear" widget command} {
d300 1
a300 1
test entry-3.50 {EntryWidgetCmd procedure, "select clear" widget command} {
d309 1
a309 1
test entry-3.51 {EntryWidgetCmd procedure, "selection present" widget command} {
d312 1
a312 1
test entry-3.52 {EntryWidgetCmd procedure, "selection present" widget command} {
d319 1
a319 1
test entry-3.53 {EntryWidgetCmd procedure, "selection present" widget command} {
d328 1
a328 1
test entry-3.54 {EntryWidgetCmd procedure, "selection present" widget command} {
d336 1
a336 1
test entry-3.55 {EntryWidgetCmd procedure, "selection adjust" widget command} {
d339 1
a339 1
test entry-3.56 {EntryWidgetCmd procedure, "selection adjust" widget command} {
d342 1
a342 1
test entry-3.57 {EntryWidgetCmd procedure, "selection adjust" widget command} {
d351 1
a351 1
test entry-3.58 {EntryWidgetCmd procedure, "selection adjust" widget command} {
d360 1
a360 1
test entry-3.59 {EntryWidgetCmd procedure, "selection from" widget command} {
d363 1
a363 1
test entry-3.60 {EntryWidgetCmd procedure, "selection range" widget command} {
d366 1
a366 1
test entry-3.61 {EntryWidgetCmd procedure, "selection range" widget command} {
d369 1
a369 1
test entry-3.62 {EntryWidgetCmd procedure, "selection range" widget command} {
d377 1
a377 1
test entry-3.63 {EntryWidgetCmd procedure, "selection range" widget command} {
d388 1
a388 1
test entry-3.64 {EntryWidgetCmd procedure, "selection to" widget command} {
d391 1
a391 1
test entry-3.65 {EntryWidgetCmd procedure, "xview" widget command} {
d395 1
a395 1
test entry-3.66 {EntryWidgetCmd procedure, "xview" widget command} {
d398 1
a398 1
test entry-3.67 {EntryWidgetCmd procedure, "xview" widget command} {
d404 1
a404 1
test entry-3.68 {EntryWidgetCmd procedure, "xview" widget command} {
d407 1
a407 1
test entry-3.69 {EntryWidgetCmd procedure, "xview" widget command} {
d410 1
a410 1
test entry-3.70 {EntryWidgetCmd procedure, "xview" widget command} {
d414 1
a414 1
test entry-3.71 {EntryWidgetCmd procedure, "xview" widget command} {
d417 1
a417 1
test entry-3.72 {EntryWidgetCmd procedure, "xview" widget command} {
d420 1
a420 1
test entry-3.73 {EntryWidgetCmd procedure, "xview" widget command} {
d425 1
a425 1
test entry-3.74 {EntryWidgetCmd procedure, "xview" widget command} {
d431 1
a431 1
test entry-3.75 {EntryWidgetCmd procedure, "xview" widget command} {
d437 1
a437 1
test entry-3.76 {EntryWidgetCmd procedure, "xview" widget command} {
d443 1
a443 1
test entry-3.77 {EntryWidgetCmd procedure, "xview" widget command} {
d446 1
a446 1
test entry-3.78 {EntryWidgetCmd procedure, "xview" widget command} {
d449 1
a449 1
test entry-3.79 {EntryWidgetCmd procedure, "xview" widget command} {
d455 1
a455 1
test entry-3.80 {EntryWidgetCmd procedure, "xview" widget command} {
d459 1
a459 15
.e insert 10 \u4e4e
test entry-3.81 {EntryWidgetCmd procedure, "xview" widget command} {
    # UTF
    # If Tcl_NumUtfChars wasn't used, wrong answer would be:
    # 0.106383 0.117021 0.117021

    set x {}
    .e xview moveto .1
    lappend x [lindex [.e xview] 0]
    .e xview moveto .11
    lappend x [lindex [.e xview] 0]
    .e xview moveto .12
    lappend x [lindex [.e xview] 0]
} {0.0957447 0.106383 0.117021}
test entry-3.82 {EntryWidgetCmd procedure} {
d461 1
a461 1
} {1 {bad option "gorp": must be bbox, cget, configure, delete, get, icursor, index, insert, scan, selection, validate, or xview}}
d665 1
a665 1
test entry-6.10 {EntryComputeGeometry procedure} {unixOnly fonts} {
a676 15
test entry-6.11 {EntryComputeGeometry procedure} {pcOnly} {
    catch {destroy .e}
    entry .e -bd 1 -relief raised -width 0 -show . -font {helvetica 12}
    .e insert 0 12345
    pack .e
    update
    set x [winfo reqwidth .e]
    .e configure -show X
    lappend x [winfo reqwidth .e]
    .e configure -show ""
    lappend x [winfo reqwidth .e]
} [list \
    [expr 8+5*[font measure {helvetica 12} .]] \
    [expr 8+5*[font measure {helvetica 12} X]] \
    [expr 8+[font measure {helvetica 12} 12345]]]
d1092 4
a1095 4
test entry-13.10 {GetEntryIndex procedure} {unixOnly} {
    # On unix, when selection is cleared, entry widget's internal 
    # selection range is reset.

d1098 4
a1101 8
test entry-13.11 {GetEntryIndex procedure} {macOrPc} {
    # On mac and pc, when selection is cleared, entry widget remembers
    # last selected range.  When selection ownership is restored to 
    # entry, the old range will be rehighlighted.

    list [catch {selection get}] [.e index sel.first]
} {1 1}
test entry-13.12 {GetEntryIndex procedure} {unixOnly} {
d1104 1
a1104 7
test entry-13.13 {GetEntryIndex procedure} {macOrPc} {
    list [catch {.e index sbogus} msg] $msg
} {1 {bad entry index "sbogus"}}
test entry-13.14 {GetEntryIndex procedure} {macOrPc} {
    list [catch {selection get}] [catch {.e index sbogus}]
} {1 1}
test entry-13.15 {GetEntryIndex procedure} {
d1107 1
a1107 1
test entry-13.16 {GetEntryIndex procedure} {fonts} {
d1110 1
a1110 1
test entry-13.17 {GetEntryIndex procedure} {fonts} {
d1113 1
a1113 1
test entry-13.18 {GetEntryIndex procedure} {fonts} {
d1116 1
a1116 1
test entry-13.19 {GetEntryIndex procedure} {fonts} {
d1119 1
a1119 1
test entry-13.20 {GetEntryIndex procedure} {fonts} {
d1122 1
a1122 1
test entry-13.21 {GetEntryIndex procedure} {
d1125 1
a1125 1
test entry-13.22 {GetEntryIndex procedure} {
d1128 1
a1128 1
test entry-13.23 {GetEntryIndex procedure} {
d1131 1
a1131 1
test entry-13.24 {GetEntryIndex procedure} {
d1134 1
a1134 1
test entry-13.25 {GetEntryIndex procedure} {
d1137 1
a1137 1
test entry-13.26 {GetEntryIndex procedure} {fonts} {
d1202 1
a1202 1
test entry-15.2 {EntryVisibleRange procedure} {unixOnly fonts} {
a1207 6
test entry-15.3 {EntryVisibleRange procedure} {pcOnly} {
    .e configure -show .
    .e delete 0 end
    .e insert 0 XXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    .e xview
} {0 0.827586}
d1209 1
a1209 1
test entry-15.4 {EntryVisibleRange procedure} {
d1239 1
a1239 1
    destroy .e
d1244 1
a1244 1
    entry .e -width 5 -xscrollcommand thisisnotacommand
d1249 1
a1249 1
} {{invalid command name "thisisnotacommand"} {invalid command name "thisisnotacommand"
d1251 1
a1251 1
"thisisnotacommand 0 1"
d1258 1
a1258 1
    destroy .e
d1264 1
a1264 157

##
## Entry widget VALIDATION tests
##

destroy .e
catch {unset ::e}
catch {unset ::vVals}
entry .e -validate all \
	-validatecommand [list doval %W %d %i %P %s %S %v %V] \
	-invalidcommand bell \
	-textvariable ::e \
	-background red -foreground white
pack .e
proc doval {W d i P s S v V} {
    set ::vVals [list $W $d $i $P $s $S $v $V]
    return 1
}

# The validation tests build each one upon the previous, so cascading
# failures aren't good
#
test entry-19.1 {entry widget validation} {
    .e insert 0 a
    set ::vVals
} {.e 1 0 a {} a all key}
test entry-19.2 {entry widget validation} {
    .e insert 1 b
    set ::vVals
} {.e 1 1 ab a b all key}
test entry-19.3 {entry widget validation} {
    .e insert end c
    set ::vVals
} {.e 1 2 abc ab c all key}
test entry-19.4 {entry widget validation} {
    .e insert 1 123
    list $::vVals $::e
} {{.e 1 1 a123bc abc 123 all key} a123bc}
test entry-19.5 {entry widget validation} {
    .e delete 2
    set ::vVals
} {.e 0 2 a13bc a123bc 2 all key}
test entry-19.6 {entry widget validation} {
    .e configure -validate key
    .e delete 1 3
    set ::vVals
} {.e 0 1 abc a13bc 13 key key}
test entry-19.7 {entry widget validation} {
    set ::vVals {}
    .e configure -validate focus
    .e insert end d
    set ::vVals
} {}
test entry-19.8 {entry widget validation} {
    focus -force .e
    # update necessary to process FocusIn event
    update
    set ::vVals
} {.e -1 -1 abcd abcd {} focus focusin}
test entry-19.9 {entry widget validation} {
    focus -force .
    # update necessary to process FocusOut event
    update
    set ::vVals
} {.e -1 -1 abcd abcd {} focus focusout}
.e configure -validate all
test entry-19.10 {entry widget validation} {
    focus -force .e
    # update necessary to process FocusIn event
    update
    set ::vVals
} {.e -1 -1 abcd abcd {} all focusin}
test entry-19.11 {entry widget validation} {
    focus -force .
    # update necessary to process FocusOut event
    update
    set ::vVals
} {.e -1 -1 abcd abcd {} all focusout}
.e configure -validate focusin
test entry-19.12 {entry widget validation} {
    focus -force .e
    # update necessary to process FocusIn event
    update
    set ::vVals
} {.e -1 -1 abcd abcd {} focusin focusin}
test entry-19.13 {entry widget validation} {
    set ::vVals {}
    focus -force .
    # update necessary to process FocusOut event
    update
    set ::vVals
} {}
.e configure -validate focuso
test entry-19.14 {entry widget validation} {
    focus -force .e
    # update necessary to process FocusIn event
    update
    set ::vVals
} {}
test entry-19.15 {entry widget validation} {
    focus -force .
    # update necessary to process FocusOut event
    update
    set ::vVals
} {.e -1 -1 abcd abcd {} focusout focusout}
test entry-19.16 {entry widget validation} {
    list [.e validate] $::vVals
} {1 {.e -1 -1 abcd abcd {} all forced}}
test entry-19.17 {entry widget validation} {
    set ::e newdata
    list [.e cget -validate] $::vVals
} {focusout {.e -1 -1 newdata abcd {} focusout forced}}

proc doval {W d i P s S v V} {
    set ::vVals [list $W $d $i $P $s $S $v $V]
    return 0
}
.e configure -validate all

test entry-19.18 {entry widget validation} {
    set ::e nextdata
    list [.e cget -validate] $::vVals
} {none {.e -1 -1 nextdata newdata {} all forced}}

proc doval {W d i P s S v V} {
    set ::vVals [list $W $d $i $P $s $S $v $V]
    set ::e mydata
    return 1
}
.e configure -validate all

## This sets validate to none because it shows that we prevent a possible
## loop condition in the validation, when the entry textvar is also set
test entry-19.19 {entry widget validation} {
    .e validate
    list [.e cget -validate] [.e get] $::vVals
} {none mydata {.e -1 -1 nextdata nextdata {} all forced}}

.e configure -validate all

## This leaves validate alone because we trigger validation through the
## textvar (a write trace), and the write during validation triggers
## nothing (by definition of avoiding loops on var traces).  This is
## one of those "dangerous" conditions where the user will have a
## different value in the entry widget shown as is in the textvar.
test entry-19.20 {entry widget validation} {
    set ::e testdata
    list [.e cget -validate] [.e get] $::e $::vVals
} {all testdata mydata {.e -1 -1 testdata mydata {} all forced}}

destroy .e
catch {unset ::e ::vVals}

##
## End validation tests
##

d1268 1
a1269 5

# cleanup
::tcltest::cleanupTests
return

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d9 1
a9 1
# RCS: @@(#) $Id: entry.test,v 1.12 2002/07/14 05:48:46 dgp Exp $
d11 17
a27 6
package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands
d58 1
a58 1
	{unknown color name "non-existent"}}
a62 4
    {-disabledbackground green green non-existent 
	{unknown color name "non-existent"}}
    {-disabledforeground blue blue non-existent 
	{unknown color name "non-existent"}}
a76 2
    {-invalidcommand "any string" "any string" {} {}}
    {-invcmd "any string" "any string" {} {}}
a77 2
    {-readonlybackground green green non-existent 
	{unknown color name "non-existent"}}
d83 1
a83 2
    {-state n normal bogus 
	{bad state "bogus": must be disabled, normal, or readonly}}
d194 1
a194 1
} {36}
a256 8
test entry-3.27 {EntryWidgetCmd procedure, "delete" widget command} {
    .e delete 0 end
    .e insert end "01234567890"
    .e configure -state readonly
    .e delete 2 8
    .e configure -state normal
    .e get
} {01234567890}
a312 8
test entry-3.40 {EntryWidgetCmd procedure, "insert" widget command} {
    .e delete 0 end
    .e insert end "01234567890"
    .e configure -state readonly
    .e insert 3 xxx
    .e configure -state normal
    .e get
} {01234567890}
d424 1
a424 1
} {1 {selection isn't in widget .e}}
a432 18
test entry-3.64 {EntryWidgetCmd procedure, "selection" widget command} {
    .e delete 0 end
    .e insert end 0123456789
    .e selection range 0 end
    .e configure -state disabled
    .e selection range 2 4
    .e configure -state normal
    list [.e index sel.first] [.e index sel.last]
} {0 10}
test entry-3.64 {EntryWidgetCmd procedure, "selection" widget command} {
    .e delete 0 end
    .e insert end 0123456789
    .e selection range 0 end
    .e configure -state readonly
    .e selection range 2 4
    .e configure -state normal
    list [.e index sel.first] [.e index sel.last]
} {2 4}
d914 1
a914 1
} {1 {selection isn't in widget .e}}
d933 1
a933 1
} {1 {selection isn't in widget .e}}
d1042 1
a1042 1
} {1 {selection isn't in widget .e}}
d1108 1
a1108 1
    deleteWindows
d1119 1
a1119 1
    deleteWindows
d1174 1
a1174 1
} {1 {selection isn't in widget .e}}
d1184 1
a1184 1
} {1 {selection isn't in widget .e}}
d1345 1
a1345 1
    (horizontal scrolling command executed by .e)}}
d1348 1
a1348 1
deleteWindows
d1474 1
a1476 1
    .e configure -validate all
d1486 1
a1490 1
    .e configure -validate all
d1495 2
a1502 1
    .e configure -validate all
a1513 47
test entry-20.1 {widget deletion while active} {
    destroy .e
    entry .e -validate all \
	    -validatecommand { destroy %W ; return 1 } \
	    -invalidcommand bell
    update
    .e insert 0 abc
    winfo exists .e
} 0
test entry-20.2 {widget deletion while active} {
    destroy .e
    entry .e -validate all \
	    -validatecommand { return 0 } \
	    -invalidcommand { destroy %W }
    .e insert 0 abc
    winfo exists .e
} 0
test entry-20.3 {widget deletion while active} {
    destroy .e
    entry .e -validate all \
	    -validatecommand { rename .e {} ; return 1 }
    .e insert 0 abc
    winfo exists .e
} 0
test entry-20.4 {widget deletion while active} {
    destroy .e
    entry .e -validate all \
	    -validatecommand { return 0 } \
	    -invalidcommand { rename .e {} }
    .e insert 0 abc
    winfo exists .e
} 0
test entry-20.5 {widget deletion while active} {
    destroy .e
    entry .e -validatecommand { destroy .e ; return 0 }
    .e validate
    winfo exists .e
} 0
test entry-20.6 {widget deletion while active} {
    destroy .e
    pack [entry .e]
    update
    .e config -xscrollcommand { destroy .e }
    update idle
    winfo exists .e
} 0

d1522 1
@


1.1.1.4
log
@imported tk 8.4.1
@
text
@d9 1
a9 1
# RCS: @@(#) $Id: entry.test,v 1.13 2002/10/02 20:59:28 hobbs Exp $
a1588 10
    winfo exists .e
} 0
test entry-20.7 {widget deletion with textvariable active} {
    # SF bugs 607390 and 617446
    destroy .e
    set FOO init
    entry .e -textvariable FOO -validate all \
	    -vcmd {%W configure -bg white; format 1}
    bind .e <Destroy> { set FOO hello }
    destroy .e
@


