head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.51;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.16;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.29;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.54;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.36;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.39.08;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# This file is a Tcl script to test out Tk's selection management code,
# especially the "selection" command.  It is organized in the standard
# fashion for Tcl tests.
#
# Copyright (c) 1994 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
#
# RCS: @@(#) $Id: select.test,v 1.9 2002/07/13 20:28:35 dgp Exp $

#
# Note: Multiple display selection handling will only be tested if the
# environment variable TK_ALT_DISPLAY is set to an alternate display.
#

package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands

namespace import -force tcltest::interpreter

global longValue selValue selInfo

set selValue {}
set selInfo {}

proc handler {type offset count} {
    global selValue selInfo
    lappend selInfo $type $offset $count
    set numBytes [expr {[string length $selValue] - $offset}]
    if {$numBytes <= 0} {
	return ""
    }
    string range $selValue $offset [expr $numBytes+$offset]
}

proc errIncrHandler {type offset count} {
    global selValue selInfo pass
    if {$offset == 4000} {
	if {$pass == 0} {
	    # Just sizing the selection;  don't do anything here.
	    set pass 1
	} else {
	    # Fetching the selection;  wait long enough to cause a timeout.
	    after 6000
	}
    }
    lappend selInfo $type $offset $count
    set numBytes [expr {[string length $selValue] - $offset}]
    if {$numBytes <= 0} {
	return ""
    }
    string range $selValue $offset [expr $numBytes+$offset]
}

proc errHandler args {
    error "selection handler aborted"
}

proc badHandler {path type offset count} {
    global selValue selInfo
    selection handle -type $type $path {}
    lappend selInfo $path $type $offset $count
    set numBytes [expr {[string length $selValue] - $offset}]
    if {$numBytes <= 0} {
	return ""
    }
    string range $selValue $offset [expr $numBytes+$offset]
}
proc reallyBadHandler {path type offset count} {
    global selValue selInfo pass
    if {$offset == 4000} {
	if {$pass == 0} {
	    set pass 1
	} else {
	    selection handle -type $type $path {}
	}
    }
    lappend selInfo $path $type $offset $count
    set numBytes [expr {[string length $selValue] - $offset}]
    if {$numBytes <= 0} {
	return ""
    }
    string range $selValue $offset [expr $numBytes+$offset]
}

# Eliminate any existing selection on the screen.  This is needed in case
# there is a selection in some other application, in order to prevent races
# from causing false errors in the tests below.

selection clear .
after 1500

# common setup code
proc setup {{path .f1} {display {}}} {
    catch {destroy $path}
    if {$display == {}} {
	frame $path
    } else {
	toplevel $path -screen $display
	wm geom $path +0+0
    }
    selection own $path
}

# set up a very large buffer to test INCR retrievals
set longValue ""
foreach i {a b c d e f g j h i j k l m o p q r s t u v w x y z} {
    set j $i.1$i.2$i.3$i.4$i.5$i.6$i.7$i.8$i.9$i.10$i.11$i.12$i.13$i.14
    append longValue A$j B$j C$j D$j E$j F$j G$j H$j I$j K$j L$j M$j N$j
}

# Now we start the main body of the test code

test select-1.1 {Tk_CreateSelHandler procedure} {
    setup
    lsort [selection get TARGETS]
} {MULTIPLE TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW}
test select-1.2 {Tk_CreateSelHandler procedure} {
    setup
    selection handle .f1 {handler TEST} TEST
    lsort [selection get TARGETS]
} {MULTIPLE TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW}
test select-1.3 {Tk_CreateSelHandler procedure} {
    global selValue selInfo
    setup
    selection handle .f1 {handler TEST} TEST
    set selValue "Test value"
    set selInfo ""
    list [selection get TEST] $selInfo
} {{Test value} {TEST 0 4000}}
test select-1.4.1 {Tk_CreateSelHandler procedure} {unixOnly} {
    setup
    selection handle .f1 {handler TEST} TEST
    selection handle .f1 {handler STRING}
    lsort [selection get TARGETS]
} {MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW UTF8_STRING}
test select-1.4.2 {Tk_CreateSelHandler procedure} {macOrPc} {
    setup
    selection handle .f1 {handler TEST} TEST
    selection handle .f1 {handler STRING}
    lsort [selection get TARGETS]
} {MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW}
test select-1.5 {Tk_CreateSelHandler procedure} {
    global selValue selInfo
    setup
    selection handle .f1 {handler TEST} TEST
    selection handle .f1 {handler STRING}
    set selValue ""
    set selInfo ""
    list [selection get] $selInfo
} {{} {STRING 0 4000}}
test select-1.6.1 {Tk_CreateSelHandler procedure} {unixOnly} {
    global selValue selInfo
    setup
    selection handle .f1 {handler TEST} TEST
    selection handle .f1 {handler STRING}
    set selValue ""
    set selInfo ""
    selection get
    selection get -type TEST
    selection handle .f1 {handler TEST2} TEST
    selection get -type TEST
    list [set selInfo] [lsort [selection get TARGETS]]
} {{STRING 0 4000 TEST 0 4000 TEST2 0 4000} {MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW UTF8_STRING}}
test select-1.6.2 {Tk_CreateSelHandler procedure} {macOrPc} {
    global selValue selInfo
    setup
    selection handle .f1 {handler TEST} TEST
    selection handle .f1 {handler STRING}
    set selValue ""
    set selInfo ""
    selection get
    selection get -type TEST
    selection handle .f1 {handler TEST2} TEST
    selection get -type TEST
    list [set selInfo] [lsort [selection get TARGETS]]
} {{STRING 0 4000 TEST 0 4000 TEST2 0 4000} {MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW}}
test select-1.7.1 {Tk_CreateSelHandler procedure} {unixOnly} {
    setup
    selection own -selection CLIPBOARD .f1
    selection handle -selection CLIPBOARD .f1 {handler TEST} TEST
    selection handle -selection PRIMARY .f1 {handler TEST2} STRING
    list [lsort [selection get -selection PRIMARY TARGETS]] \
	[lsort [selection get -selection CLIPBOARD TARGETS]] 
} {{MULTIPLE STRING TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW UTF8_STRING} {MULTIPLE TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW}}
test select-1.7.2 {Tk_CreateSelHandler procedure} {macOrPc} {
    setup
    selection own -selection CLIPBOARD .f1
    selection handle -selection CLIPBOARD .f1 {handler TEST} TEST
    selection handle -selection PRIMARY .f1 {handler TEST2} STRING
    list [lsort [selection get -selection PRIMARY TARGETS]] \
	[lsort [selection get -selection CLIPBOARD TARGETS]] 
} {{MULTIPLE STRING TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW} {MULTIPLE TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW}}
test select-1.8 {Tk_CreateSelHandler procedure} {
    setup
    selection handle -format INTEGER -type TEST .f1 {handler TEST}
    lsort [selection get TARGETS]
} {MULTIPLE TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW}

##############################################################################

test select-2.1 {Tk_DeleteSelHandler procedure} {unixOnly} {
    setup
    selection handle .f1 {handler STRING} 
    selection handle -type TEST .f1 {handler TEST} 
    selection handle -type USER .f1 {handler USER} 
    set result [list [lsort [selection get TARGETS]]]
    selection handle -type TEST .f1 {}
    lappend result [lsort [selection get TARGETS]]
} {{MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW USER UTF8_STRING} {MULTIPLE STRING TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW USER UTF8_STRING}}
test select-2.2 {Tk_DeleteSelHandler procedure} {unixOnly} {
    setup
    selection handle .f1 {handler STRING} 
    selection handle -type TEST .f1 {handler TEST} 
    selection handle -type USER .f1 {handler USER} 
    set result [list [lsort [selection get TARGETS]]]
    selection handle -type USER .f1 {}
    lappend result [lsort [selection get TARGETS]]
} {{MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW USER UTF8_STRING} {MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW UTF8_STRING}}
test select-2.3 {Tk_DeleteSelHandler procedure} {unixOnly} {
    setup
    selection own -selection CLIPBOARD .f1
    selection handle -selection PRIMARY .f1 {handler STRING} 
    selection handle -selection CLIPBOARD .f1 {handler STRING} 
    selection handle -selection CLIPBOARD .f1 {}
    list [lsort [selection get TARGETS]] \
	[lsort [selection get -selection CLIPBOARD TARGETS]]
} {{MULTIPLE STRING TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW UTF8_STRING} {MULTIPLE TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW}}
test select-2.4 {Tk_DeleteSelHandler procedure} {macOrPc} {
    setup
    selection handle .f1 {handler STRING} 
    selection handle -type TEST .f1 {handler TEST} 
    selection handle -type USER .f1 {handler USER} 
    set result [list [lsort [selection get TARGETS]]]
    selection handle -type TEST .f1 {}
    lappend result [lsort [selection get TARGETS]]
} {{MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW USER} {MULTIPLE STRING TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW USER}}
test select-2.5 {Tk_DeleteSelHandler procedure} {macOrPc} {
    setup
    selection handle .f1 {handler STRING} 
    selection handle -type TEST .f1 {handler TEST} 
    selection handle -type USER .f1 {handler USER} 
    set result [list [lsort [selection get TARGETS]]]
    selection handle -type USER .f1 {}
    lappend result [lsort [selection get TARGETS]]
} {{MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW USER} {MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW}}
test select-2.6 {Tk_DeleteSelHandler procedure} {macOrPc} {
    setup
    selection own -selection CLIPBOARD .f1
    selection handle -selection PRIMARY .f1 {handler STRING} 
    selection handle -selection CLIPBOARD .f1 {handler STRING} 
    selection handle -selection CLIPBOARD .f1 {}
    list [lsort [selection get TARGETS]] \
	[lsort [selection get -selection CLIPBOARD TARGETS]]
} {{MULTIPLE STRING TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW} {MULTIPLE TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW}}
test select-2.7 {Tk_DeleteSelHandler procedure} {
    setup
    selection handle .f1 {handler STRING}
    list [selection handle .f1 {}] [selection handle .f1 {}]
} {{} {}}   

##############################################################################

test select-3.1 {Tk_OwnSelection procedure} {
    setup
    selection own
} {.f1}
test select-3.2 {Tk_OwnSelection procedure} {
    setup .f1
    set result [selection own]
    setup .f2
    lappend result [selection own]
} {.f1 .f2}
test select-3.3 {Tk_OwnSelection procedure} {
    setup .f1
    setup .f2
    selection own -selection CLIPBOARD .f1
    list [selection own] [selection own -selection CLIPBOARD]
} {.f2 .f1}
test select-3.4 {Tk_OwnSelection procedure} {
    global lostSel
    setup
    set lostSel {owned}
    selection own -command { set lostSel {lost} } .f1
    selection clear .f1
    set lostSel
} {lost}
test select-3.5 {Tk_OwnSelection procedure} {
    global lostSel
    setup .f1
    setup .f2
    set lostSel {owned}
    selection own -command { set lostSel {lost1} } .f1
    selection own -command { set lostSel {lost2} } .f2
    list $lostSel [selection own]
} {lost1 .f2}
test select-3.6 {Tk_OwnSelection procedure} {
    global lostSel
    setup
    set lostSel {owned}
    selection own -command { set lostSel {lost1} } .f1
    selection own -command { set lostSel {lost2} } .f1
    set result $lostSel
    selection clear .f1
    lappend result $lostSel
} {owned lost2}
test select-3.7 {Tk_OwnSelection procedure} {unixOnly} {
    global lostSel
    setup
    setupbg
    set lostSel {owned}
    selection own -command { set lostSel {lost1} } .f1
    update
    set result {}
    lappend result [dobg { selection own . }]
    lappend result [dobg {selection own}]
    update
    cleanupbg
    lappend result $lostSel
} {{} . lost1}
# check reentrancy on selection replacement
test select-3.8 {Tk_OwnSelection procedure} {
    setup
    selection own -selection CLIPBOARD -command { destroy .f1 } .f1
    selection own -selection CLIPBOARD .
} {}
test select-3.9 {Tk_OwnSelection procedure} {
    setup .f2
    setup .f1
    selection own -selection CLIPBOARD -command { destroy .f2 } .f1
    selection own -selection CLIPBOARD .f2
} {}

# multiple display tests
test select-3.10 {Tk_OwnSelection procedure} {altDisplay} {
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    list [selection own -displayof .f1] [selection own -displayof .f2]
} {.f1 .f2}
test select-3.11 {Tk_OwnSelection procedure} {altDisplay} {
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    setupbg
    update
    set result ""
    lappend result [dobg "toplevel .t -screen $env(TK_ALT_DISPLAY); wm geom .t +0+0; selection own .t; update"]
    lappend result [selection own -displayof .f1] \
	    [selection own -displayof .f2]
    cleanupbg
    set result
} {{} .f1 {}}

##############################################################################

test select-4.1 {Tk_ClearSelection procedure} {
    setup
    set result [selection own]
    selection clear .f1
    lappend result [selection own]
} {.f1 {}}
test select-4.2 {Tk_ClearSelection procedure} {
    setup
    selection own -selection CLIPBOARD .f1
    selection clear .f1
    selection own -selection CLIPBOARD
} {.f1}
test select-4.3 {Tk_ClearSelection procedure} {
    setup
    list [selection clear .f1] [selection clear .f1]
} {{} {}}
test select-4.4 {Tk_ClearSelection procedure} {unixOnly} {
    global lostSel
    setup
    setupbg
    set lostSel {owned}
    selection own -command { set lostSel {lost1} } .f1
    update
    set result {}
    lappend result [dobg {selection clear; update}]
    update
    cleanupbg
    lappend result [selection own]
} {{} {}}

# multiple display tests
test select-4.5 {Tk_ClearSelection procedure} {altDisplay} {
    global lostSel lostSel2
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    set lostSel {owned}
    set lostSel2 {owned2}
    selection own -command { set lostSel {lost1} } .f1
    selection own -command { set lostSel2 {lost2} } .f2
    update
    selection clear -displayof .f2
    update
    list $lostSel $lostSel2
} {owned lost2}
test select-4.6 {Tk_ClearSelection procedure} {unixOnly altDisplay} {
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    setupbg
    set lostSel {owned}
    set lostSel2 {owned2}
    selection own -command { set lostSel {lost1} } .f1
    selection own -command { set lostSel2 {lost2} } .f2
    update
    set result ""
    lappend result [dobg "toplevel .t -screen $env(TK_ALT_DISPLAY); wm geom .t +0+0; selection own .t; update"]
    lappend result [selection own -displayof .f1] \
	    [selection own -displayof .f2] $lostSel $lostSel2
    cleanupbg
    set result
} {{} .f1 {} owned lost2}

##############################################################################

test select-5.1 {Tk_GetSelection procedure} {
    setup
    list [catch {selection get TEST} msg] $msg
} {1 {PRIMARY selection doesn't exist or form "TEST" not defined}}
test select-5.2 {Tk_GetSelection procedure} {
    setup
    selection get TK_WINDOW
} {.f1}
test select-5.3 {Tk_GetSelection procedure} {
    setup
    selection handle -selection PRIMARY .f1 {handler TEST} TEST
    set selValue "Test value"
    set selInfo ""
    list [selection get TEST] $selInfo
} {{Test value} {TEST 0 4000}}
test select-5.4 {Tk_GetSelection procedure} {
    setup
    selection handle .f1 ERROR errHandler
    list [catch {selection get ERROR} msg] $msg
} {1 {PRIMARY selection doesn't exist or form "ERROR" not defined}}
test select-5.5 {Tk_GetSelection procedure} {
    setup
    set selValue $longValue
    set selInfo ""
    selection handle .f1 {handler STRING}
    list [selection get] $selInfo
} "$longValue {STRING 0 4000 STRING 4000 4000 STRING 8000 4000 STRING 12000 4000 STRING 16000 4000}"
test select-5.6 {Tk_GetSelection procedure} {
    proc weirdHandler {type offset count} {
	selection handle .f1 {}
	handler $type $offset $count
    }
    setup
    set selValue $longValue
    set selInfo ""
    selection handle .f1 {weirdHandler STRING}
    list [catch {selection get} msg] $msg
} {1 {PRIMARY selection doesn't exist or form "STRING" not defined}}
test select-5.7 {Tk_GetSelection procedure} {
    proc weirdHandler {type offset count} {
	destroy .f1
	handler $type $offset $count
    }
    setup
    set selValue "Test Value"
    set selInfo ""
    selection handle .f1 {weirdHandler STRING}
    list [catch {selection get} msg] $msg
} {1 {PRIMARY selection doesn't exist or form "STRING" not defined}}
test select-5.8 {Tk_GetSelection procedure} {
    proc weirdHandler {type offset count} {
	selection clear
	handler $type $offset $count
    }
    setup
    set selValue $longValue
    set selInfo ""
    selection handle .f1 {weirdHandler STRING}
    list [selection get] $selInfo [catch {selection get} msg] $msg
} "$longValue {STRING 0 4000 STRING 4000 4000 STRING 8000 4000 STRING 12000 4000 STRING 16000 4000} 1 {PRIMARY selection doesn't exist or form \"STRING\" not defined}"
test select-5.9 {Tk_GetSelection procedure} {unixOnly} {
    setup
    setupbg
    selection handle -selection PRIMARY .f1 {handler TEST} TEST
    update
    set selValue "Test value"
    set selInfo ""
    set result ""
    lappend result [dobg {selection get TEST}]
    cleanupbg
    lappend result $selInfo
} {{Test value} {TEST 0 4000}}
test select-5.10 {Tk_GetSelection procedure} {unixOnly} {
    setup
    setupbg
    selection handle -selection PRIMARY .f1 {handler TEST} TEST
    update
    set selValue "Test value"
    set selInfo ""
    selection own .f1
    set result ""
    lappend result [dobg {selection get TEST} 1]
    cleanupbg
    lappend result $selInfo
} {{selection owner didn't respond} {}}

# multiple display tests

test select-5.11 {Tk_GetSelection procedure} {altDisplay} {
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    selection handle -selection PRIMARY .f1 {handler TEST} TEST
    selection handle -selection PRIMARY .f2 {handler TEST2} TEST
    set selValue "Test value"
    set selInfo ""
    set result [list [selection get TEST] $selInfo]
    set selValue "Test value2"
    set selInfo ""
    lappend result [selection get -displayof .f2 TEST] $selInfo
} {{Test value} {TEST 0 4000} {Test value2} {TEST2 0 4000}}
test select-5.12 {Tk_GetSelection procedure} {altDisplay} {
    global lostSel lostSel2
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    selection handle -selection PRIMARY .f1 {handler TEST} TEST
    selection handle -selection PRIMARY .f2 {} TEST
    set selValue "Test value"
    set selInfo ""
    set result [list [catch {selection get TEST} msg] $msg $selInfo]
    set selValue "Test value2"
    set selInfo ""
    lappend result [catch {selection get -displayof .f2 TEST} msg] $msg \
	    $selInfo
} {0 {Test value} {TEST 0 4000} 1 {PRIMARY selection doesn't exist or form "TEST" not defined} {}}
test select-5.13 {Tk_GetSelection procedure} {unixOnly altDisplay} {
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    setupbg
    selection handle -selection PRIMARY .f1 {handler TEST} TEST
    selection own .f1
    selection handle -selection PRIMARY .f2 {handler TEST2} TEST
    selection own .f2
    set selValue "Test value"
    set selInfo ""
    update
    set result ""
    lappend result [dobg "toplevel .t -screen $env(TK_ALT_DISPLAY); wm geom .t +0+0; selection get -displayof .t TEST"]
    set selValue "Test value2"
    lappend result [dobg "selection get TEST"]
    cleanupbg
    lappend result $selInfo
} {{Test value} {Test value2} {TEST2 0 4000 TEST 0 4000}}
test select-5.14 {Tk_GetSelection procedure} {unixOnly altDisplay} {
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    setupbg
    selection handle -selection PRIMARY .f1 {handler TEST} TEST
    selection own .f1
    selection handle -selection PRIMARY .f2 {} TEST
    selection own .f2
    set selValue "Test value"
    set selInfo ""
    update
    set result ""
    lappend result [dobg "toplevel .t -screen $env(TK_ALT_DISPLAY); wm geom .t +0+0; selection get -displayof .t TEST"]
    set selValue "Test value2"
    lappend result [dobg "selection get TEST"]
    cleanupbg
    lappend result $selInfo
} {{PRIMARY selection doesn't exist or form "TEST" not defined} {Test value2} {TEST 0 4000}}

##############################################################################

test select-6.1 {Tk_SelectionCmd procedure} {
    list [catch {selection} cmd] $cmd
} {1 {wrong # args: should be "selection option ?arg arg ...?"}}

# selection clear
test select-6.2 {Tk_SelectionCmd procedure} {
    list [catch {selection clear -selection} cmd] $cmd
} {1 {value for "-selection" missing}}
test select-6.3 {Tk_SelectionCmd procedure} {
    setup
    selection own .
    set result [selection own]
    selection clear -displayof .f1
    lappend result [selection own]
} {. {}}
test select-6.4 {Tk_SelectionCmd procedure} {
    setup
    selection own -selection CLIPBOARD .f1
    set result [list [selection own] [selection own -selection CLIPBOARD]]
    selection clear -selection CLIPBOARD .f1
    lappend result [selection own] [selection own -selection CLIPBOARD]
} {.f1 .f1 .f1 {}}
test select-6.5 {Tk_SelectionCmd procedure} {
    setup
    selection own -selection CLIPBOARD .
    set result [list [selection own] [selection own -selection CLIPBOARD]]
    selection clear -selection CLIPBOARD -displayof .f1
    lappend result [selection own] [selection own -selection CLIPBOARD]
} {.f1 . .f1 {}}
test select-6.6 {Tk_SelectionCmd procedure} {
    list [catch {selection clear -badopt foo} cmd] $cmd
} {1 {bad option "-badopt": must be -displayof or -selection}}
test select-6.7 {Tk_SelectionCmd procedure} {
    list [catch {selection clear -selectionfoo foo} cmd] $cmd
} {1 {bad option "-selectionfoo": must be -displayof or -selection}}
test select-6.8 {Tk_SelectionCmd procedure} {
    catch {destroy .f2}
    list [catch {selection clear -displayof .f2} cmd] $cmd
} {1 {bad window path name ".f2"}}
test select-6.9 {Tk_SelectionCmd procedure} {
    catch {destroy .f2}
    list [catch {selection clear .f2} cmd] $cmd
} {1 {bad window path name ".f2"}}
test select-6.10 {Tk_SelectionCmd procedure} {
    setup
    set result [selection own -selection PRIMARY]
    selection clear
    lappend result [selection own -selection PRIMARY]
} {.f1 {}}
test select-6.11 {Tk_SelectionCmd procedure} {
    setup
    selection own -selection CLIPBOARD .f1
    set result [selection own -selection CLIPBOARD]
    selection clear -selection CLIPBOARD
    lappend result [selection own -selection CLIPBOARD]
} {.f1 {}}
test select-6.12 {Tk_SelectionCmd procedure} {
    list [catch {selection clear foo bar} cmd] $cmd
} {1 {wrong # args: should be "selection clear ?options?"}}

# selection get
test select-6.13 {Tk_SelectionCmd procedure} {
    list [catch {selection get -selection} cmd] $cmd
} {1 {value for "-selection" missing}}
test select-6.14 {Tk_SelectionCmd procedure} {
    global selValue selInfo
    setup
    selection handle .f1 {handler TEST}
    set selValue "Test value"
    set selInfo ""
    list [selection get -displayof .f1] $selInfo
} {{Test value} {TEST 0 4000}}
test select-6.15 {Tk_SelectionCmd procedure} {
    global selValue selInfo
    setup
    selection handle .f1 {handler STRING}
    selection handle -selection CLIPBOARD .f1 {handler TEST}
    selection own -selection CLIPBOARD .f1
    set selValue "Test value"
    set selInfo ""
    list [selection get -selection CLIPBOARD] $selInfo
} {{Test value} {TEST 0 4000}}
test select-6.16 {Tk_SelectionCmd procedure} {
    global selValue selInfo
    setup
    selection handle -type TEST .f1 {handler TEST}
    selection handle -type STRING .f1 {handler STRING}
    set selValue "Test value"
    set selInfo ""
    list [selection get -type TEST] $selInfo
} {{Test value} {TEST 0 4000}}
test select-6.17 {Tk_SelectionCmd procedure} {
    list [catch {selection get -badopt foo} cmd] $cmd
} {1 {bad option "-badopt": must be -displayof, -selection, or -type}}
test select-6.18 {Tk_SelectionCmd procedure} {
    list [catch {selection get -selectionfoo foo} cmd] $cmd
} {1 {bad option "-selectionfoo": must be -displayof, -selection, or -type}}
test select-6.19 {Tk_SelectionCmd procedure} {
    catch { destroy .f2 }
    list [catch {selection get -displayof .f2} cmd] $cmd
} {1 {bad window path name ".f2"}}
test select-6.20 {Tk_SelectionCmd procedure} {
    list [catch {selection get foo bar} cmd] $cmd
} {1 {wrong # args: should be "selection get ?options?"}}
test select-6.21 {Tk_SelectionCmd procedure} {
    global selValue selInfo
    setup
    selection handle -type TEST .f1 {handler TEST}
    selection handle -type STRING .f1 {handler STRING}
    set selValue "Test value"
    set selInfo ""
    list [selection get TEST] $selInfo
} {{Test value} {TEST 0 4000}}

# selection handle
# most of the handle section has been covered earlier
test select-6.22 {Tk_SelectionCmd procedure} {
    list [catch {selection handle -selection} cmd] $cmd
} {1 {value for "-selection" missing}}
test select-6.23 {Tk_SelectionCmd procedure} {
    global selValue selInfo
    setup
    set selValue "Test value"
    set selInfo ""
    list [selection handle -format INTEGER .f1 {handler TEST}] [selection get -displayof .f1] $selInfo
} {{} {Test value} {TEST 0 4000}}
test select-6.24 {Tk_SelectionCmd procedure} {
    list [catch {selection handle -badopt foo} cmd] $cmd
} {1 {bad option "-badopt": must be -format, -selection, or -type}}
test select-6.25 {Tk_SelectionCmd procedure} {
    list [catch {selection handle -selectionfoo foo} cmd] $cmd
} {1 {bad option "-selectionfoo": must be -format, -selection, or -type}}
test select-6.26 {Tk_SelectionCmd procedure} {
    list [catch {selection handle} cmd] $cmd
} {1 {wrong # args: should be "selection handle ?options? window command"}}
test select-6.27 {Tk_SelectionCmd procedure} {
    list [catch {selection handle .} cmd] $cmd
} {1 {wrong # args: should be "selection handle ?options? window command"}}
test select-6.28 {Tk_SelectionCmd procedure} {
    list [catch {selection handle . foo bar baz blat} cmd] $cmd
} {1 {wrong # args: should be "selection handle ?options? window command"}}
test select-6.29 {Tk_SelectionCmd procedure} {
    catch { destroy .f2 }
    list [catch {selection handle .f2 dummy} cmd] $cmd
} {1 {bad window path name ".f2"}}

# selection own
test select-6.30 {Tk_SelectionCmd procedure} {
    list [catch {selection own -selection} cmd] $cmd
} {1 {value for "-selection" missing}}
test select-6.31 {Tk_SelectionCmd procedure} {
    setup
    selection own .
    selection own -displayof .f1
} {.}
test select-6.32 {Tk_SelectionCmd procedure} {
    setup
    selection own .
    selection own -selection CLIPBOARD .f1
    list [selection own] [selection own -selection CLIPBOARD]
} {. .f1}
test select-6.33 {Tk_SelectionCmd procedure} {
    global lostSel
    setup
    set lostSel owned
    selection own -command { set lostSel lost } .
    selection own -selection CLIPBOARD .f1
    set result $lostSel
    selection own .f1
    lappend result $lostSel
} {owned lost}
test select-6.34 {Tk_SelectionCmd procedure} {
    list [catch {selection own -badopt foo} cmd] $cmd
} {1 {bad option "-badopt": must be -command, -displayof, or -selection}}
test select-6.35 {Tk_SelectionCmd procedure} {
    list [catch {selection own -selectionfoo foo} cmd] $cmd
} {1 {bad option "-selectionfoo": must be -command, -displayof, or -selection}}
test select-6.36 {Tk_SelectionCmd procedure} {
    catch {destroy .f2}
    list [catch {selection own -displayof .f2} cmd] $cmd
} {1 {bad window path name ".f2"}}
test select-6.37 {Tk_SelectionCmd procedure} {
    catch {destroy .f2}
    list [catch {selection own .f2} cmd] $cmd
} {1 {bad window path name ".f2"}}
test select-6.38 {Tk_SelectionCmd procedure} {
    list [catch {selection own foo bar baz} cmd] $cmd
} {1 {wrong # args: should be "selection own ?options? ?window?"}}

test select-6.39 {Tk_SelectionCmd procedure} {
    list [catch {selection foo} cmd] $cmd
} {1 {bad option "foo": must be clear, get, handle, or own}}

##############################################################################

    # This test is non-portable because some old X11/News servers ignore
    # a selection request when the window doesn't exist, which causes a
    # different error message.

    test select-7.1 {TkSelDeadWindow procedure} {nonPortable} {
	setup
	selection handle .f1 { handler TEST }
	set result [selection own]
	destroy .f1
	lappend result [selection own] [catch { selection get } msg] $msg
    } {.f1 {} 1 {PRIMARY selection doesn't exist or form "STRING" not defined}}

##############################################################################

# Check reentrancy on losing selection

test select-8.1 {TkSelEventProc procedure} {unixOnly} {
    setup
    setupbg
    selection own -selection CLIPBOARD -command { destroy .f1 } .f1
    update
    set result [dobg {selection own -selection CLIPBOARD .}]
    cleanupbg
    set result
} {}

##############################################################################

test select-9.1 {SelCvtToX and SelCvtFromX procedures} {unixOnly} {
    global selValue selInfo
    setup
    setupbg
    set selValue "1024"
    set selInfo ""
    selection handle -selection PRIMARY -format INTEGER -type TEST \
	.f1 {handler TEST}
    update
    set result ""
    lappend result [dobg {selection get TEST}]
    cleanupbg
    lappend result $selInfo
} {0x400 {TEST 0 4000}}
test select-9.2 {SelCvtToX and SelCvtFromX procedures} {unixOnly} {
    global selValue selInfo
    setup
    setupbg
    set selValue "1024 0xffff  2048 -2  "
    set selInfo ""
    selection handle -selection PRIMARY -format INTEGER -type TEST \
	.f1 {handler TEST}
    set result ""
    lappend result [dobg {selection get TEST}]
    cleanupbg
    lappend result $selInfo
} {{0x400 0xffff 0x800 0xfffffffe} {TEST 0 4000}}
test select-9.3 {SelCvtToX and SelCvtFromX procedures} {unixOnly} {
    global selValue selInfo
    setup
    setupbg
    set selValue "   "
    set selInfo ""
    selection handle -selection PRIMARY -format INTEGER -type TEST \
	.f1 {handler TEST}
    set result ""
    lappend result [dobg {selection get TEST}]
    cleanupbg
    lappend result $selInfo
} {{} {TEST 0 4000}}
test select-9.4 {SelCvtToX and SelCvtFromX procedures} {unixOnly} {
    global selValue selInfo
    setup
    setupbg
    set selValue "16 foobar 32"
    set selInfo ""
    selection handle -selection PRIMARY -format INTEGER -type TEST \
	.f1 {handler TEST}
    set result ""
    lappend result [dobg {selection get TEST}]
    cleanupbg
    lappend result $selInfo
} {{0x10 0x0 0x20} {TEST 0 4000}}

##############################################################################

# note, we are not testing MULTIPLE style selections

# most control paths have been exercised above
test select-10.1 {ConvertSelection procedure, race with selection clear} {unixOnly} {
    setup
    proc Ready {fd} {
	variable x
	lappend x [gets $fd]
    }
    set fd [open "|[list [interpreter] -geometry +0+0 -name tktest]" r+]
    puts $fd "puts foo; flush stdout"
    flush $fd
    gets $fd
    fileevent $fd readable [list Ready $fd]
    set selValue "Just a simple test"
    set selInfo ""
    selection handle .f1 {handler STRING}
    update
    puts $fd {puts "[catch {selection get} msg] $msg"; puts **DONE**; flush stdout}
    flush $fd
    after 200
    selection own .
    set x {}
    vwait [namespace which -variable x]
    puts $fd {exit}
    flush $fd
    close $fd
    lappend x $selInfo
} {{1 PRIMARY selection doesn't exist or form "STRING" not defined} {}}
test select-10.2 {ConvertSelection procedure} {unixOnly} {
    setup
    setupbg
    set selValue [string range $longValue 0 3999]
    set selInfo ""
    selection handle .f1 {handler STRING}
    set result ""
    lappend result [dobg {selection get}]
    cleanupbg
    lappend result $selInfo
} [list [string range $longValue 0 3999] {STRING 0 4000 STRING 4000 4000 STRING 0 4000 STRING 4000 4000}]
test select-10.3 {ConvertSelection procedure} {unixOnly} {
    setup
    setupbg
    selection handle .f1 ERROR errHandler
    set result ""
    lappend result [dobg {selection get ERROR}]
    cleanupbg
    set result
} {{PRIMARY selection doesn't exist or form "ERROR" not defined}}
# testing timers
# This one hangs in Exceed
test select-10.4 {ConvertSelection procedure} {unixOnly noExceed} {
    setup
    setupbg
    set selValue $longValue
    set selInfo ""
    selection handle .f1 {errIncrHandler STRING}
    set result ""
    set pass 0
    lappend result [dobg {selection get}]
    cleanupbg
    lappend result $selInfo
} {{selection owner didn't respond} {STRING 0 4000 STRING 4000 4000 STRING 8000 4000 STRING 12000 4000 STRING 16000 4000 STRING 0 4000 STRING 4000 4000}}
test select-10.5 {ConvertSelection procedure, reentrancy issues} {unixOnly} {
    setup
    setupbg
    set selValue "Test value"
    set selInfo ""
    selection handle -type TEST .f1 { handler TEST }
    selection handle -type STRING .f1 { badHandler .f1 STRING }
    set result ""
    lappend result [dobg {selection get}]
    cleanupbg
    lappend result $selInfo
} {{PRIMARY selection doesn't exist or form "STRING" not defined} {.f1 STRING 0 4000}}
test select-10.6 {ConvertSelection procedure, reentrancy issues} {unixOnly} {
    proc weirdHandler {type offset count} {
	destroy .f1
	handler $type $offset $count
    }
    setup
    setupbg
    set selValue $longValue
    set selInfo ""
    selection handle .f1 {weirdHandler STRING}
    set result ""
    lappend result [dobg {selection get}]
    cleanupbg
    lappend result $selInfo
} {{PRIMARY selection doesn't exist or form "STRING" not defined} {STRING 0 4000}}

##############################################################################

# testing reentrancy
test select-11.1 {TkSelPropProc procedure} {unixOnly} {
    setup
    setupbg
    set selValue $longValue
    set selInfo ""
    selection handle -type TEST .f1 { handler TEST }
    selection handle -type STRING .f1 { reallyBadHandler .f1 STRING }
    set result ""
    set pass 0
    lappend result [dobg {selection get}]
    cleanupbg
    lappend result $selInfo
} {{selection owner didn't respond} {.f1 STRING 0 4000 .f1 STRING 4000 4000 .f1 STRING 8000 4000 .f1 STRING 12000 4000 .f1 STRING 16000 4000 .f1 STRING 0 4000 .f1 STRING 4000 4000}}

##############################################################################

# Note, this assumes we are using CurrentTtime
test select-12.1 {DefaultSelection procedure} {unixOnly} {
    setup
    set result [selection get -type TIMESTAMP]
    setupbg
    lappend result [dobg {selection get -type TIMESTAMP}]
    cleanupbg
    set result
} {0x0 0x0}
test select-12.2 {DefaultSelection procedure} {unixOnly} {
    setup
    set result [lsort [list [selection get -type TARGETS]]]
    setupbg
    lappend result [dobg {lsort [selection get -type TARGETS]}]
    cleanupbg
    set result
} {{MULTIPLE TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW} {MULTIPLE TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW}}
test select-12.3 {DefaultSelection procedure} {unixOnly} {
    setup
    selection handle .f1 {handler TEST} TEST
    set result [list [lsort [selection get -type TARGETS]]]
    setupbg
    lappend result [dobg {lsort [selection get -type TARGETS]}]
    cleanupbg
    set result
} {{MULTIPLE TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW} {MULTIPLE TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW}}
test select-12.4 {DefaultSelection procedure} {unixOnly} {
    setup
    set result ""
    lappend result [selection get -type TK_APPLICATION]
    setupbg
    lappend result [dobg {selection get -type TK_APPLICATION}]
    cleanupbg
    set result
} [list [winfo name .] [winfo name .]]
test select-12.5 {DefaultSelection procedure} {unixOnly} {
    setup
    set result [selection get -type TK_WINDOW]
    setupbg
    lappend result [dobg {selection get -type TK_WINDOW}]
    cleanupbg
    set result
} {.f1 .f1}
test select-12.6 {DefaultSelection procedure} {
    global selValue selInfo
    setup
    selection handle .f1 {handler TARGETS.f1} TARGETS
    set selValue "Targets value"
    set selInfo ""
    set result [list [selection get TARGETS] $selInfo]
    selection handle .f1 {} TARGETS
    lappend result [selection get TARGETS]
} {{Targets value} {TARGETS.f1 0 4000} {MULTIPLE TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW}}

test select-13.1 {SelectionSize procedure, handler deleted} {unixOnly} {
    proc badHandler {path type offset count} {
	global selValue selInfo abortCount
	incr abortCount -1
	if {$abortCount == 0} {
	    selection handle -type $type $path {}
	}
	lappend selInfo $path $type $offset $count
	set numBytes [expr {[string length $selValue] - $offset}]
	if {$numBytes <= 0} {
	    return ""
	}
	string range $selValue $offset [expr $numBytes+$offset]
    }
    setup
    setupbg
    set selValue $longValue
    set selInfo ""
    selection handle .f1 {badHandler .f1 STRING}
    set result ""
    set abortCount 2
    lappend result [dobg {selection get}]
    cleanupbg
    lappend result $selInfo
} {{PRIMARY selection doesn't exist or form "STRING" not defined} {.f1 STRING 0 4000 .f1 STRING 4000 4000}}

catch {rename weirdHandler {}}

# cleanup
::tcltest::cleanupTests
return













@


1.4
log
@touched all sources to ease next import
@
text
@d9 1
a9 1
# RCS: @@(#) $Id: select.test,v 1.7.6.1 2000/05/04 21:26:29 spolk Exp $
d16 6
a21 3
if {[lsearch [namespace children] ::tcltest] == -1} {
    source [file join [pwd] [file dirname [info script]] defs.tcl]
}
d23 1
a23 1
eval destroy [winfo child .]
d135 7
a141 1
test select-1.4 {Tk_CreateSelHandler procedure} {
d156 14
a169 1
test select-1.6 {Tk_CreateSelHandler procedure} {
d182 9
a190 1
test select-1.7 {Tk_CreateSelHandler procedure} {
d206 28
a233 1
test select-2.1 {Tk_DeleteSelHandler procedure} {
d242 1
a242 1
test select-2.2 {Tk_DeleteSelHandler procedure} {
d251 1
a251 1
test select-2.3 {Tk_DeleteSelHandler procedure} {
d260 1
a260 1
test select-2.4 {Tk_DeleteSelHandler procedure} {
d339 13
a351 15
if {[info exists env(TK_ALT_DISPLAY)]} {

    test select-3.10 {Tk_OwnSelection procedure} {
	setup .f1
	setup .f2 $env(TK_ALT_DISPLAY)
	list [selection own -displayof .f1] [selection own -displayof .f2]
    } {.f1 .f2}
    test select-3.11 {Tk_OwnSelection procedure} {
	setup .f1
	setup .f2 $env(TK_ALT_DISPLAY)
	setupbg
	update
	set result ""
	lappend result [dobg "toplevel .t -screen $env(TK_ALT_DISPLAY); wm geom .t +0+0; selection own .t; update"]
	lappend result [selection own -displayof .f1] \
d353 3
a355 3
	cleanupbg
	set result
    } {{} .f1 {}}
a356 1
}
d390 25
a414 26
if {[info exists env(TK_ALT_DISPLAY)]} {
    test select-4.5 {Tk_ClearSelection procedure} {
	global lostSel lostSel2
	setup .f1
	setup .f2 $env(TK_ALT_DISPLAY)
	set lostSel {owned}
	set lostSel2 {owned2}
	selection own -command { set lostSel {lost1} } .f1
	selection own -command { set lostSel2 {lost2} } .f2
	update
	selection clear -displayof .f2
	update
	list $lostSel $lostSel2
    } {owned lost2}
    test select-4.6 {Tk_ClearSelection procedure} {unixOnly} {
	setup .f1
	setup .f2 $env(TK_ALT_DISPLAY)
	setupbg
	set lostSel {owned}
	set lostSel2 {owned2}
	selection own -command { set lostSel {lost1} } .f1
	selection own -command { set lostSel2 {lost2} } .f2
	update
	set result ""
	lappend result [dobg "toplevel .t -screen $env(TK_ALT_DISPLAY); wm geom .t +0+0; selection own .t; update"]
	lappend result [selection own -displayof .f1] \
d416 3
a418 3
	cleanupbg
	set result
    } {{} .f1 {} owned lost2}
a419 1
}
d503 1
a503 4
    fileevent $::tcltest::fd readable {}
    puts $::tcltest::fd {catch {selection get TEST} msg; update; puts $msg; flush stdout}
    flush $::tcltest::fd
    lappend result [gets $::tcltest::fd]
d509 25
a533 25
if {[info exists env(TK_ALT_DISPLAY)]} {
    test select-5.11 {Tk_GetSelection procedure} {
	setup .f1
	setup .f2 $env(TK_ALT_DISPLAY)
	selection handle -selection PRIMARY .f1 {handler TEST} TEST
	selection handle -selection PRIMARY .f2 {handler TEST2} TEST
	set selValue "Test value"
	set selInfo ""
	set result [list [selection get TEST] $selInfo]
	set selValue "Test value2"
	set selInfo ""
	lappend result [selection get -displayof .f2 TEST] $selInfo
    } {{Test value} {TEST 0 4000} {Test value2} {TEST2 0 4000}}
    test select-5.12 {Tk_GetSelection procedure} {
	global lostSel lostSel2
	setup .f1
	setup .f2 $env(TK_ALT_DISPLAY)
	selection handle -selection PRIMARY .f1 {handler TEST} TEST
	selection handle -selection PRIMARY .f2 {} TEST
	set selValue "Test value"
	set selInfo ""
	set result [list [catch {selection get TEST} msg] $msg $selInfo]
	set selValue "Test value2"
	set selInfo ""
	lappend result [catch {selection get -displayof .f2 TEST} msg] $msg \
d535 37
a571 37
    } {0 {Test value} {TEST 0 4000} 1 {PRIMARY selection doesn't exist or form "TEST" not defined} {}}
    test select-5.13 {Tk_GetSelection procedure} {unixOnly} {
	setup .f1
	setup .f2 $env(TK_ALT_DISPLAY)
	setupbg
	selection handle -selection PRIMARY .f1 {handler TEST} TEST
	selection own .f1
	selection handle -selection PRIMARY .f2 {handler TEST2} TEST
	selection own .f2
	set selValue "Test value"
	set selInfo ""
	update
	set result ""
	lappend result [dobg "toplevel .t -screen $env(TK_ALT_DISPLAY); wm geom .t +0+0; selection get -displayof .t TEST"]
	set selValue "Test value2"
	lappend result [dobg "selection get TEST"]
	cleanupbg
	lappend result $selInfo
    } {{Test value} {Test value2} {TEST2 0 4000 TEST 0 4000}}
    test select-5.14 {Tk_GetSelection procedure} {unixOnly} {
	setup .f1
	setup .f2 $env(TK_ALT_DISPLAY)
	setupbg
	selection handle -selection PRIMARY .f1 {handler TEST} TEST
	selection own .f1
	selection handle -selection PRIMARY .f2 {} TEST
	selection own .f2
	set selValue "Test value"
	set selInfo ""
	update
	set result ""
	lappend result [dobg "toplevel .t -screen $env(TK_ALT_DISPLAY); wm geom .t +0+0; selection get -displayof .t TEST"]
	set selValue "Test value2"
	lappend result [dobg "selection get TEST"]
	cleanupbg
	lappend result $selInfo
    } {{PRIMARY selection doesn't exist or form "TEST" not defined} {Test value2} {TEST 0 4000}}
a572 1
}
d606 1
a606 1
} {1 {unknown option "-badopt"}}
d609 1
a609 1
} {1 {unknown option "-selectionfoo"}}
d668 1
a668 1
} {1 {unknown option "-badopt"}}
d671 1
a671 1
} {1 {unknown option "-selectionfoo"}}
d703 1
a703 1
} {1 {unknown option "-badopt"}}
d706 1
a706 1
} {1 {unknown option "-selectionfoo"}}
d748 1
a748 1
} {1 {unknown option "-badopt"}}
d751 1
a751 1
} {1 {unknown option "-selectionfoo"}}
d859 9
a867 1
    setupbg
d872 2
a873 2
    puts $::tcltest::fd {puts "[catch {selection get} msg] $msg"; puts **DONE**; flush stdout}
    flush $::tcltest::fd
d876 6
a881 4
    set ::tcltest::bgData {}
    tkwait variable ::tcltest::bgDone
    cleanupbg
    list $::tcltest::bgData $selInfo
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d6 2
d9 1
a9 4
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: select.test,v 1.9 1999/01/26 04:11:37 jingham Exp $
d16 2
a17 2
if {[string compare test [info procs test]] == 1} {
    source defs
d451 4
a454 4
    fileevent $fd readable {}
    puts $fd {catch {selection get TEST} msg; update; puts $msg; flush stdout}
    flush $fd
    lappend result [gets $fd]
d816 2
a817 2
    puts $fd {puts "[catch {selection get} msg] $msg"; puts **DONE**; flush stdout}
    flush $fd
d820 2
a821 2
    set bgData {}
    tkwait variable bgDone
d823 1
a823 1
    list $bgData $selInfo
d846 2
a847 1
test select-10.4 {ConvertSelection procedure} {unixOnly} {
d987 17
a1003 1
concat
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@a5 2
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
d7 4
a10 1
# RCS: @@(#) $Id: select.test,v 1.7.6.1 2000/05/04 21:26:29 spolk Exp $
d17 2
a18 2
if {[lsearch [namespace children] ::tcltest] == -1} {
    source [file join [pwd] [file dirname [info script]] defs.tcl]
d452 4
a455 4
    fileevent $::tcltest::fd readable {}
    puts $::tcltest::fd {catch {selection get TEST} msg; update; puts $msg; flush stdout}
    flush $::tcltest::fd
    lappend result [gets $::tcltest::fd]
d817 2
a818 2
    puts $::tcltest::fd {puts "[catch {selection get} msg] $msg"; puts **DONE**; flush stdout}
    flush $::tcltest::fd
d821 2
a822 2
    set ::tcltest::bgData {}
    tkwait variable ::tcltest::bgDone
d824 1
a824 1
    list $::tcltest::bgData $selInfo
d847 1
a847 2
# This one hangs in Exceed
test select-10.4 {ConvertSelection procedure} {unixOnly noExceed} {
d987 1
a987 17

# cleanup
::tcltest::cleanupTests
return













@


1.1.1.3
log
@import tk 8.4.0
@
text
@d9 1
a9 1
# RCS: @@(#) $Id: select.test,v 1.9 2002/07/13 20:28:35 dgp Exp $
d16 3
a18 6
package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands
d20 1
a20 1
namespace import -force tcltest::interpreter
d132 1
a132 7
test select-1.4.1 {Tk_CreateSelHandler procedure} {unixOnly} {
    setup
    selection handle .f1 {handler TEST} TEST
    selection handle .f1 {handler STRING}
    lsort [selection get TARGETS]
} {MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW UTF8_STRING}
test select-1.4.2 {Tk_CreateSelHandler procedure} {macOrPc} {
d147 1
a147 14
test select-1.6.1 {Tk_CreateSelHandler procedure} {unixOnly} {
    global selValue selInfo
    setup
    selection handle .f1 {handler TEST} TEST
    selection handle .f1 {handler STRING}
    set selValue ""
    set selInfo ""
    selection get
    selection get -type TEST
    selection handle .f1 {handler TEST2} TEST
    selection get -type TEST
    list [set selInfo] [lsort [selection get TARGETS]]
} {{STRING 0 4000 TEST 0 4000 TEST2 0 4000} {MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW UTF8_STRING}}
test select-1.6.2 {Tk_CreateSelHandler procedure} {macOrPc} {
d160 1
a160 9
test select-1.7.1 {Tk_CreateSelHandler procedure} {unixOnly} {
    setup
    selection own -selection CLIPBOARD .f1
    selection handle -selection CLIPBOARD .f1 {handler TEST} TEST
    selection handle -selection PRIMARY .f1 {handler TEST2} STRING
    list [lsort [selection get -selection PRIMARY TARGETS]] \
	[lsort [selection get -selection CLIPBOARD TARGETS]] 
} {{MULTIPLE STRING TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW UTF8_STRING} {MULTIPLE TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW}}
test select-1.7.2 {Tk_CreateSelHandler procedure} {macOrPc} {
d176 1
a176 28
test select-2.1 {Tk_DeleteSelHandler procedure} {unixOnly} {
    setup
    selection handle .f1 {handler STRING} 
    selection handle -type TEST .f1 {handler TEST} 
    selection handle -type USER .f1 {handler USER} 
    set result [list [lsort [selection get TARGETS]]]
    selection handle -type TEST .f1 {}
    lappend result [lsort [selection get TARGETS]]
} {{MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW USER UTF8_STRING} {MULTIPLE STRING TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW USER UTF8_STRING}}
test select-2.2 {Tk_DeleteSelHandler procedure} {unixOnly} {
    setup
    selection handle .f1 {handler STRING} 
    selection handle -type TEST .f1 {handler TEST} 
    selection handle -type USER .f1 {handler USER} 
    set result [list [lsort [selection get TARGETS]]]
    selection handle -type USER .f1 {}
    lappend result [lsort [selection get TARGETS]]
} {{MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW USER UTF8_STRING} {MULTIPLE STRING TARGETS TEST TIMESTAMP TK_APPLICATION TK_WINDOW UTF8_STRING}}
test select-2.3 {Tk_DeleteSelHandler procedure} {unixOnly} {
    setup
    selection own -selection CLIPBOARD .f1
    selection handle -selection PRIMARY .f1 {handler STRING} 
    selection handle -selection CLIPBOARD .f1 {handler STRING} 
    selection handle -selection CLIPBOARD .f1 {}
    list [lsort [selection get TARGETS]] \
	[lsort [selection get -selection CLIPBOARD TARGETS]]
} {{MULTIPLE STRING TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW UTF8_STRING} {MULTIPLE TARGETS TIMESTAMP TK_APPLICATION TK_WINDOW}}
test select-2.4 {Tk_DeleteSelHandler procedure} {macOrPc} {
d185 1
a185 1
test select-2.5 {Tk_DeleteSelHandler procedure} {macOrPc} {
d194 1
a194 1
test select-2.6 {Tk_DeleteSelHandler procedure} {macOrPc} {
d203 1
a203 1
test select-2.7 {Tk_DeleteSelHandler procedure} {
d282 15
a296 13
test select-3.10 {Tk_OwnSelection procedure} {altDisplay} {
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    list [selection own -displayof .f1] [selection own -displayof .f2]
} {.f1 .f2}
test select-3.11 {Tk_OwnSelection procedure} {altDisplay} {
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    setupbg
    update
    set result ""
    lappend result [dobg "toplevel .t -screen $env(TK_ALT_DISPLAY); wm geom .t +0+0; selection own .t; update"]
    lappend result [selection own -displayof .f1] \
d298 3
a300 3
    cleanupbg
    set result
} {{} .f1 {}}
d302 1
d336 26
a361 25
test select-4.5 {Tk_ClearSelection procedure} {altDisplay} {
    global lostSel lostSel2
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    set lostSel {owned}
    set lostSel2 {owned2}
    selection own -command { set lostSel {lost1} } .f1
    selection own -command { set lostSel2 {lost2} } .f2
    update
    selection clear -displayof .f2
    update
    list $lostSel $lostSel2
} {owned lost2}
test select-4.6 {Tk_ClearSelection procedure} {unixOnly altDisplay} {
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    setupbg
    set lostSel {owned}
    set lostSel2 {owned2}
    selection own -command { set lostSel {lost1} } .f1
    selection own -command { set lostSel2 {lost2} } .f2
    update
    set result ""
    lappend result [dobg "toplevel .t -screen $env(TK_ALT_DISPLAY); wm geom .t +0+0; selection own .t; update"]
    lappend result [selection own -displayof .f1] \
d363 3
a365 3
    cleanupbg
    set result
} {{} .f1 {} owned lost2}
d367 1
d451 4
a454 1
    lappend result [dobg {selection get TEST} 1]
d460 25
a484 25

test select-5.11 {Tk_GetSelection procedure} {altDisplay} {
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    selection handle -selection PRIMARY .f1 {handler TEST} TEST
    selection handle -selection PRIMARY .f2 {handler TEST2} TEST
    set selValue "Test value"
    set selInfo ""
    set result [list [selection get TEST] $selInfo]
    set selValue "Test value2"
    set selInfo ""
    lappend result [selection get -displayof .f2 TEST] $selInfo
} {{Test value} {TEST 0 4000} {Test value2} {TEST2 0 4000}}
test select-5.12 {Tk_GetSelection procedure} {altDisplay} {
    global lostSel lostSel2
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    selection handle -selection PRIMARY .f1 {handler TEST} TEST
    selection handle -selection PRIMARY .f2 {} TEST
    set selValue "Test value"
    set selInfo ""
    set result [list [catch {selection get TEST} msg] $msg $selInfo]
    set selValue "Test value2"
    set selInfo ""
    lappend result [catch {selection get -displayof .f2 TEST} msg] $msg \
d486 37
a522 37
} {0 {Test value} {TEST 0 4000} 1 {PRIMARY selection doesn't exist or form "TEST" not defined} {}}
test select-5.13 {Tk_GetSelection procedure} {unixOnly altDisplay} {
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    setupbg
    selection handle -selection PRIMARY .f1 {handler TEST} TEST
    selection own .f1
    selection handle -selection PRIMARY .f2 {handler TEST2} TEST
    selection own .f2
    set selValue "Test value"
    set selInfo ""
    update
    set result ""
    lappend result [dobg "toplevel .t -screen $env(TK_ALT_DISPLAY); wm geom .t +0+0; selection get -displayof .t TEST"]
    set selValue "Test value2"
    lappend result [dobg "selection get TEST"]
    cleanupbg
    lappend result $selInfo
} {{Test value} {Test value2} {TEST2 0 4000 TEST 0 4000}}
test select-5.14 {Tk_GetSelection procedure} {unixOnly altDisplay} {
    setup .f1
    setup .f2 $env(TK_ALT_DISPLAY)
    setupbg
    selection handle -selection PRIMARY .f1 {handler TEST} TEST
    selection own .f1
    selection handle -selection PRIMARY .f2 {} TEST
    selection own .f2
    set selValue "Test value"
    set selInfo ""
    update
    set result ""
    lappend result [dobg "toplevel .t -screen $env(TK_ALT_DISPLAY); wm geom .t +0+0; selection get -displayof .t TEST"]
    set selValue "Test value2"
    lappend result [dobg "selection get TEST"]
    cleanupbg
    lappend result $selInfo
} {{PRIMARY selection doesn't exist or form "TEST" not defined} {Test value2} {TEST 0 4000}}
d524 1
d558 1
a558 1
} {1 {bad option "-badopt": must be -displayof or -selection}}
d561 1
a561 1
} {1 {bad option "-selectionfoo": must be -displayof or -selection}}
d620 1
a620 1
} {1 {bad option "-badopt": must be -displayof, -selection, or -type}}
d623 1
a623 1
} {1 {bad option "-selectionfoo": must be -displayof, -selection, or -type}}
d655 1
a655 1
} {1 {bad option "-badopt": must be -format, -selection, or -type}}
d658 1
a658 1
} {1 {bad option "-selectionfoo": must be -format, -selection, or -type}}
d700 1
a700 1
} {1 {bad option "-badopt": must be -command, -displayof, or -selection}}
d703 1
a703 1
} {1 {bad option "-selectionfoo": must be -command, -displayof, or -selection}}
d811 1
a811 9
    proc Ready {fd} {
	variable x
	lappend x [gets $fd]
    }
    set fd [open "|[list [interpreter] -geometry +0+0 -name tktest]" r+]
    puts $fd "puts foo; flush stdout"
    flush $fd
    gets $fd
    fileevent $fd readable [list Ready $fd]
d816 2
a817 2
    puts $fd {puts "[catch {selection get} msg] $msg"; puts **DONE**; flush stdout}
    flush $fd
d820 4
a823 6
    set x {}
    vwait [namespace which -variable x]
    puts $fd {exit}
    flush $fd
    close $fd
    lappend x $selInfo
@


