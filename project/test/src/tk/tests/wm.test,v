head	1.6;
access;
symbols
	sid-snapshot-20180601:1.6
	sid-snapshot-20180501:1.6
	sid-snapshot-20180401:1.6
	sid-snapshot-20180301:1.6
	sid-snapshot-20180201:1.6
	sid-snapshot-20180101:1.6
	sid-snapshot-20171201:1.6
	sid-snapshot-20171101:1.6
	sid-snapshot-20171001:1.6
	sid-snapshot-20170901:1.6
	sid-snapshot-20170801:1.6
	sid-snapshot-20170701:1.6
	sid-snapshot-20170601:1.6
	sid-snapshot-20170501:1.6
	sid-snapshot-20170401:1.6
	sid-snapshot-20170301:1.6
	sid-snapshot-20170201:1.6
	sid-snapshot-20170101:1.6
	sid-snapshot-20161201:1.6
	sid-snapshot-20161101:1.6
	sid-snapshot-20160901:1.6
	sid-snapshot-20160801:1.6
	sid-snapshot-20160701:1.6
	sid-snapshot-20160601:1.6
	sid-snapshot-20160501:1.6
	sid-snapshot-20160401:1.6
	sid-snapshot-20160301:1.6
	sid-snapshot-20160201:1.6
	sid-snapshot-20160101:1.6
	sid-snapshot-20151201:1.6
	sid-snapshot-20151101:1.6
	sid-snapshot-20151001:1.6
	sid-snapshot-20150901:1.6
	sid-snapshot-20150801:1.6
	sid-snapshot-20150701:1.6
	sid-snapshot-20150601:1.6
	sid-snapshot-20150501:1.6
	sid-snapshot-20150401:1.6
	sid-snapshot-20150301:1.6
	sid-snapshot-20150201:1.6
	sid-snapshot-20150101:1.6
	sid-snapshot-20141201:1.6
	sid-snapshot-20141101:1.6
	sid-snapshot-20141001:1.6
	sid-snapshot-20140901:1.6
	sid-snapshot-20140801:1.6
	sid-snapshot-20140701:1.6
	sid-snapshot-20140601:1.6
	sid-snapshot-20140501:1.6
	sid-snapshot-20140401:1.6
	sid-snapshot-20140301:1.6
	sid-snapshot-20140201:1.6
	sid-snapshot-20140101:1.6
	sid-snapshot-20131201:1.6
	sid-snapshot-20131101:1.6
	sid-snapshot-20131001:1.6
	sid-snapshot-20130901:1.6
	sid-snapshot-20130801:1.6
	sid-snapshot-20130701:1.6
	sid-snapshot-20130601:1.6
	insight_7_6-2013-04-10-branchpoint:1.6
	gdb_7_6-branch:1.6.0.28
	sid-snapshot-20130501:1.6
	sid-snapshot-20130401:1.6
	sid-snapshot-20130301:1.6
	sid-snapshot-20130201:1.6
	sid-snapshot-20130101:1.6
	sid-snapshot-20121201:1.6
	sid-snapshot-20121101:1.6
	sid-snapshot-20121001:1.6
	sid-snapshot-20120901:1.6
	gdb_7_5-branch:1.6.0.26
	sid-snapshot-20120801:1.6
	sid-snapshot-20120701:1.6
	sid-snapshot-20120601:1.6
	sid-snapshot-20120501:1.6
	sid-snapshot-20120401:1.6
	gdb_7_4-branch:1.6.0.24
	sid-snapshot-20120301:1.6
	sid-snapshot-20120201:1.6
	sid-snapshot-20120101:1.6
	sid-snapshot-20111201:1.6
	sid-snapshot-20111101:1.6
	sid-snapshot-20111001:1.6
	sid-snapshot-20110901:1.6
	gdb_7_3-branch:1.6.0.22
	sid-snapshot-20110801:1.6
	sid-snapshot-20110701:1.6
	sid-snapshot-20110601:1.6
	sid-snapshot-20110501:1.6
	sid-snapshot-20110401:1.6
	sid-snapshot-20110301:1.6
	sid-snapshot-20110201:1.6
	sid-snapshot-20110101:1.6
	sid-snapshot-20101201:1.6
	sid-snapshot-20101101:1.6
	sid-snapshot-20101001:1.6
	sid-snapshot-20100901:1.6
	sid-snapshot-20100801:1.6
	sid-snapshot-20100701:1.6
	sid-snapshot-20100601:1.6
	sid-snapshot-20100501:1.6
	sid-snapshot-20100401:1.6
	sid-snapshot-20100301:1.6
	gdb_7_1-branch:1.6.0.20
	gdb_7_0-branch:1.6.0.18
	sid-snapshot-20100201:1.6
	sid-snapshot-20100101:1.6
	sid-snapshot-20091201:1.6
	sid-snapshot-20091101:1.6
	sid-snapshot-20091001:1.6
	arc-sim-20090309:1.6
	sid-snapshot-20090901:1.6
	sid-snapshot-20090801:1.6
	sid-snapshot-20090701:1.6
	sid-snapshot-20090601:1.6
	sid-snapshot-20090501:1.6
	kevinb-pre-tk8_5_7_merge:1.6
	sid-snapshot-20090401:1.6
	arc-insight_6_8-branch:1.6.0.16
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.14
	insight_6_8-branchpoint:1.6
	sid-snapshot-20090301:1.6
	sid-snapshot-20090201:1.6
	sid-snapshot-20090101:1.6
	sid-snapshot-20081201:1.6
	sid-snapshot-20081101:1.6
	sid-snapshot-20081001:1.6
	sid-snapshot-20080901:1.6
	sid-snapshot-20080801:1.6
	sid-snapshot-20080701:1.6
	sid-snapshot-20080601:1.6
	sid-snapshot-20080501:1.6
	sid-snapshot-20080403:1.6
	sid-snapshot-20080401:1.6
	gdb_6_8-branch:1.6.0.12
	sid-snapshot-20080301:1.6
	sid-snapshot-20080201:1.6
	sid-snapshot-20080101:1.6
	sid-snapshot-20071201:1.6
	sid-snapshot-20071101:1.6
	sid-snapshot-20071001:1.6
	insight_6_6-20070208-release:1.6
	gdb_6_6-branch:1.6.0.10
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb_6_5-branch:1.6.0.8
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb_6_4-branch:1.6.0.6
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb_6_1-2004-04-05-release:1.6
	gdb_6_1-branch:1.6.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	gdb_6_0-2003-10-04-release:1.6
	gdb_6_0-branch:1.6.0.2
	gdb_6_0-2003-06-23-branchpoint:1.6
	TK8_4_1:1.1.1.2
	gdb_5_3-2002-12-12-release:1.3
	tcltk840-20020924-branch:1.4.0.2
	tcltk840-20020924-branchpoint:1.4
	TK_8_4_0:1.1.1.2
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.4
	gdb_5_3-branch:1.3.0.2
	gdb_5_3-2002-09-04-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	TK_8_3:1.1.1.1
	NET:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.6
date	2003.01.21.20.24.51;	author hunt;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.21.19.53.16;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.24.18.39.29;	author kseitz;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.01.01.33.48;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.54;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.10.00.22.37;	author irox;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.09.10.00.22.37;	author irox;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.24.20.39.11;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Updated to tk 8.4.1
@
text
@# This file is a Tcl script to test out Tk's interactions with
# the window manager, including the "wm" command.  It is organized
# in the standard fashion for Tcl tests.
#
# Copyright (c) 1992-1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
#
# RCS: @@(#) $Id$

# This file tests window manager interactions that work across
# platforms. Window manager tests that only work on a specific
# platform should be placed in unixWm.test or winWm.test.

package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands

wm deiconify .
if {![winfo ismapped .]} {
    tkwait visibility .
}

proc stdWindow {} {
    destroy .t
    toplevel .t -width 100 -height 50
    wm geom .t +0+0
    update
}

# [raise] and [lower] may return before the window manager
# has completed the operation.  The raiseDelay procedure
# idles for a while to give the operation a chance to complete.
#

proc raiseDelay {} {
    after 100; update
}


deleteWindows
stdWindow

test wm-1.1 {Tk_WmObjCmd procedure, miscellaneous errors} {
    list [catch {wm} msg] $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-1.2 {Tk_WmObjCmd procedure, miscellaneous errors} {
    list [catch {wm foo} msg] $msg
} {1 {bad option "foo": must be aspect, attributes, client, colormapwindows, command, deiconify, focusmodel, frame, geometry, grid, group, iconbitmap, iconify, iconmask, iconname, iconposition, iconwindow, maxsize, minsize, overrideredirect, positionfrom, protocol, resizable, sizefrom, stackorder, state, title, transient, or withdraw}}

test wm-1.3 {Tk_WmObjCmd procedure, miscellaneous errors} {
    list [catch {wm command} msg] $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-1.4 {Tk_WmObjCmd procedure, miscellaneous errors} {
    list [catch {wm aspect bogus} msg] $msg
} {1 {bad window path name "bogus"}}

test wm-1.5 {Tk_WmObjCmd procedure, miscellaneous errors} {
    catch {destroy .b}
    button .b -text hello
    list [catch {wm geometry .b} msg] $msg
} {1 {window ".b" isn't a top-level window}}


test wm-aspect-1.1 {usage} {
    list [catch {wm aspect} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-aspect-1.2 {usage} {
    list [catch {wm aspect . _} err] $err
} {1 {wrong # args: should be "wm aspect window ?minNumer minDenom maxNumer maxDenom?"}}

test wm-aspect-1.3 {usage} {
    list [catch {wm aspect . _ _ _} err] $err
} {1 {wrong # args: should be "wm aspect window ?minNumer minDenom maxNumer maxDenom?"}}

test wm-aspect-1.4 {usage} {
    list [catch {wm aspect . _ _ _ _ _} err] $err
} {1 {wrong # args: should be "wm aspect window ?minNumer minDenom maxNumer maxDenom?"}}

test wm-aspect-1.5 {usage} {
    list [catch {wm aspect . bad 14 15 16} msg] $msg
} {1 {expected integer but got "bad"}}

test wm-aspect-1.6 {usage} {
    list [catch {wm aspect . 13 foo 15 16} msg] $msg
} {1 {expected integer but got "foo"}}

test wm-aspect-1.7 {usage} {
    list [catch {wm aspect . 13 14 bar 16} msg] $msg
} {1 {expected integer but got "bar"}}

test wm-aspect-1.8 {usage} {
    list [catch {wm aspect . 13 14 15 baz} msg] $msg
} {1 {expected integer but got "baz"}}

test wm-aspect-1.9 {usage} {
    list [catch {wm aspect . 0 14 15 16} msg] $msg
} {1 {aspect number can't be <= 0}}

test wm-aspect-1.10 {usage} {
    list [catch {wm aspect . 13 0 15 16} msg] $msg
} {1 {aspect number can't be <= 0}}

test wm-aspect-1.11 {usage} {
    list [catch {wm aspect . 13 14 0 16} msg] $msg
} {1 {aspect number can't be <= 0}}

test wm-aspect-1.12 {usage} {
    list [catch {wm aspect . 13 14 15 0} msg] $msg
} {1 {aspect number can't be <= 0}}

test wm-aspect-2.1 {setting and reading values} {
    set result {}
    lappend result [wm aspect .t]
    wm aspect .t 3 4 10 2
    lappend result [wm aspect .t]
    wm aspect .t {} {} {} {}
    lappend result [wm aspect .t]
} [list {} {3 4 10 2} {}]


test wm-attributes-1.1 {usage} {
    list [catch {wm attributes} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-attributes-1.2.1 {usage} {pcOnly} {
    list [catch {wm attributes . _} err] $err
} {1 {wrong # args: should be "wm attributes window ?-disabled ?bool?? ?-toolwindow ?bool?? ?-topmost ?bool??"}}

test wm-attributes-1.2.2 {usage} {macOrUnix} {
    list [catch {wm attributes . _} err] $err
} {1 {wrong # args: should be "wm attributes window"}}


test wm-client-1.1 {usage} {
    list [catch {wm client} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-client-1.2 {usage} {
    list [catch {wm client . _ _} err] $err
} {1 {wrong # args: should be "wm client window ?name?"}}

test wm-client-2.1 {setting and reading values} {
    set result {}
    lappend result [wm client .t]
    wm client .t Miffo
    lappend result [wm client .t]
    wm client .t {}
    lappend result [wm client .t]
} [list {} Miffo {}]


test wm-colormapwindows-1.1 {usage} {
    list [catch {wm colormapwindows} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-colormapwindows-1.2 {usage} {
    list [catch {wm colormapwindows . _ _} err] $err
} {1 {wrong # args: should be "wm colormapwindows window ?windowList?"}}

test wm-colormapwindows-1.3 {usage} {
    list [catch {wm colormapwindows . "a \{"} msg] $msg
} {1 {unmatched open brace in list}}

test wm-colormapwindows-1.4 {usage} {
    list [catch {wm colormapwindows . foo} msg] $msg
} {1 {bad window path name "foo"}}

test wm-colormapwindows-2.1 {reading values} {
    catch {destroy .t2}
    toplevel .t2 -width 200 -height 200 -colormap new
    wm geom .t2 +0+0
    frame .t2.a -width 100 -height 30
    frame .t2.b -width 100 -height 30 -colormap new
    pack .t2.a .t2.b -side top
    update
    set x [wm colormapwindows .t2]
    frame .t2.c -width 100 -height 30 -colormap new
    pack .t2.c -side top
    update
    list $x [wm colormapwindows .t2]
} {{.t2.b .t2} {.t2.b .t2.c .t2}}

test wm-colormapwindows-2.2 {setting and reading values} {
    catch {destroy .t2}
    toplevel .t2 -width 200 -height 200
    wm geom .t2 +0+0
    frame .t2.a -width 100 -height 30
    frame .t2.b -width 100 -height 30
    frame .t2.c -width 100 -height 30
    pack .t2.a .t2.b .t2.c -side top
    wm colormapwindows .t2 {.t2.b .t2.a}
    wm colormapwindows .t2
} {.t2.b .t2.a}


test wm-command-1.1 {usage} {
    list [catch {wm command} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-command-1.2 {usage} {
    list [catch {wm command . _ _} err] $err
} {1 {wrong # args: should be "wm command window ?value?"}}

test wm-command-1.3 {usage} {
    list [catch {wm command . "a \{"} msg] $msg
} {1 {unmatched open brace in list}}

test wm-command-2.1 {setting and reading values} {
    set result {}
    lappend result [wm command .t]
    wm command .t [list Miffo Foo]
    lappend result [wm command .t]
    wm command .t {}
    lappend result [wm command .t]
} [list {} [list Miffo Foo] {}]


test wm-deiconify-1.1 {usage} {
    list [catch {wm deiconify} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-deiconify-1.2 {usage} {
    list [catch {wm deiconify . _} err] $err
} {1 {wrong # args: should be "wm deiconify window"}}

test wm-deiconify-1.3 {usage} {
    list [catch {wm deiconify _} err] $err
} {1 {bad window path name "_"}}

test wm-deiconify-1.4 {usage} {
    catch {destroy .icon}
    toplevel .icon -width 50 -height 50 -bg red
    wm iconwindow .t .icon
    set result [list [catch {wm deiconify .icon} msg] $msg]
    destroy .icon
    set result
} {1 {can't deiconify .icon: it is an icon for .t}}

test wm-deiconify-1.5 {usage} {
    catch {destroy .embed}
    frame .t.f -container 1
    toplevel .embed -use [winfo id .t.f]
    set result [list [catch {wm deiconify .embed} msg] $msg]
    destroy .t.f .embed
    set result
} {1 {can't deiconify .embed: it is an embedded window}}

test wm-deiconify-2.1 {a window that has never been mapped
        should not be mapped by a call to deiconify} {
    deleteWindows
    toplevel .t
    wm deiconify .t
    winfo ismapped .t
} 0

test wm-deiconify-2.2 {a window that has already been
        mapped should be mapped by deiconify} {
    deleteWindows
    toplevel .t
    update idletasks
    wm withdraw .t
    wm deiconify .t
    winfo ismapped .t
} 1

test wm-deiconify-2.3 {geometry for an unmapped window
        should not be calculated by a call to deiconify,
        it should be done at idle time} {
    deleteWindows
    set results {}
    toplevel .t -width 200 -height 200
    lappend results [wm geometry .t]
    wm deiconify .t
    lappend results [wm geometry .t]
    update idletasks
    lappend results [lindex [split \
        [wm geometry .t] +] 0]
} {1x1+0+0 1x1+0+0 200x200}

test wm-deiconify-2.4 {invoking destroy after a deiconify
        should not result in a crash because of a callback
        set on the toplevel} {
    deleteWindows
    toplevel .t
    wm withdraw .t
    wm deiconify .t
    destroy .t
    update
} {}


test wm-focusmodel-1.1 {usage} {
    list [catch {wm focusmodel} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-focusmodel-1.2 {usage} {
    list [catch {wm focusmodel . _ _} err] $err
} {1 {wrong # args: should be "wm focusmodel window ?active|passive?"}}

test wm-focusmodel-1.3 {usage} {
    list [catch {wm focusmodel . bogus} msg] $msg
} {1 {bad argument "bogus": must be active or passive}}

stdWindow

test wm-focusmodel-2.1 {setting and reading values} {
    set result {} 
    lappend result [wm focusmodel .t]
    wm focusmodel .t active
    lappend result [wm focusmodel .t]
    wm focusmodel .t passive
    lappend result [wm focusmodel .t]
    set result
} {passive active passive}


test wm-frame-1.1 {usage} {
    list [catch {wm frame} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-frame-1.2 {usage} {
    list [catch {wm frame . _} err] $err
} {1 {wrong # args: should be "wm frame window"}}


test wm-geometry-1.1 {usage} {
    list [catch {wm geometry} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-geometry-1.2 {usage} {
    list [catch {wm geometry . _ _} err] $err
} {1 {wrong # args: should be "wm geometry window ?newGeometry?"}}

test wm-geometry-1.3 {usage} {
    list [catch {wm geometry . bogus} msg] $msg
} {1 {bad geometry specifier "bogus"}}

test wm-geometry-2.1 {setting values} {
    set result {}
    wm geometry .t 150x150+50+50
    update
    lappend result [wm geometry .t]
    wm geometry .t {}
    update
    lappend result [string equal [wm geometry .t] "150x150+50+50"]
} [list 150x150+50+50 0]


test wm-grid-1.1 {usage} {
    list [catch {wm grid} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-grid-1.2 {usage} {
    list [catch {wm grid . _} err] $err
} {1 {wrong # args: should be "wm grid window ?baseWidth baseHeight widthInc heightInc?"}}

test wm-grid-1.3 {usage} {
    list [catch {wm grid . _ _ _} err] $err
} {1 {wrong # args: should be "wm grid window ?baseWidth baseHeight widthInc heightInc?"}}

test wm-grid-1.4 {usage} {
    list [catch {wm grid . _ _ _ _ _} err] $err
} {1 {wrong # args: should be "wm grid window ?baseWidth baseHeight widthInc heightInc?"}}

test wm-grid-1.5 {usage} {
    list [catch {wm grid . bad 14 15 16} msg] $msg
} {1 {expected integer but got "bad"}}

test wm-grid-1.6 {usage} {
    list [catch {wm grid . 13 foo 15 16} msg] $msg
} {1 {expected integer but got "foo"}}

test wm-grid-1.7 {usage} {
    list [catch {wm grid . 13 14 bar 16} msg] $msg
} {1 {expected integer but got "bar"}}

test wm-grid-1.8 {usage} {
    list [catch {wm grid . 13 14 15 baz} msg] $msg
} {1 {expected integer but got "baz"}}

test wm-grid-1.9 {usage} {
    list [catch {wm grid . -1 14 15 16} msg] $msg
} {1 {baseWidth can't be < 0}}

test wm-grid-1.10 {usage} {
    list [catch {wm grid . 13 -1 15 16} msg] $msg
} {1 {baseHeight can't be < 0}}

test wm-grid-1.11 {usage} {
    list [catch {wm grid . 13 14 -1 16} msg] $msg
} {1 {widthInc can't be < 0}}

test wm-grid-1.12 {usage} {
    list [catch {wm grid . 13 14 15 -1} msg] $msg
} {1 {heightInc can't be < 0}}

test wm-grid-2.1 {setting and reading values} {
    set result {}
    lappend result [wm grid .t]
    wm grid .t 3 4 10 2
    lappend result [wm grid .t]
    wm grid .t {} {} {} {}
    lappend result [wm grid .t]
} [list {} {3 4 10 2} {}]


test wm-group-1.1 {usage} {
    list [catch {wm group} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-group-1.2 {usage} {
    list [catch {wm group .t 12 13} msg] $msg
} {1 {wrong # args: should be "wm group window ?pathName?"}}

test wm-group-1.3 {usage} {
    list [catch {wm group .t bogus} msg] $msg
} {1 {bad window path name "bogus"}}

test wm-group-2.1 {setting and reading values} {
    set result {}
    lappend result [wm group .t]
    wm group .t .
    lappend result [wm group .t]
    wm group .t {}
    lappend result [wm group .t]
} [list {} . {}]


test wm-iconbitmap-1.1 {usage} {
    list [catch {wm iconbitmap} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-iconbitmap-1.2.1 {usage} {macOrUnix} {
    list [catch {wm iconbitmap .t 12 13} msg] $msg
} {1 {wrong # args: should be "wm iconbitmap window ?bitmap?"}}

test wm-iconbitmap-1.2.2 {usage} {pcOnly} {
    list [catch {wm iconbitmap .t 12 13 14} msg] $msg
} {1 {wrong # args: should be "wm iconbitmap window ?-default? ?image?"}}

test wm-iconbitmap-1.3 {usage} {pcOnly} {
    list [catch {wm iconbitmap .t 12 13} msg] $msg
} {1 {illegal option "12" must be "-default"}}

test wm-iconbitmap-1.4 {usage} {
    list [catch {wm iconbitmap .t bad-bitmap} msg] $msg
} {1 {bitmap "bad-bitmap" not defined}}

test wm-iconbitmap-2.1 {setting and reading values} {
    set result {}
    lappend result [wm iconbitmap .t]
    wm iconbitmap .t hourglass
    lappend result [wm iconbitmap .t]
    wm iconbitmap .t {}
    lappend result [wm iconbitmap .t]
} [list {} hourglass {}]


test wm-iconify-1.1 {usage} {
    list [catch {wm iconify} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-iconify-1.2 {usage} {
    list [catch {wm iconify .t _} msg] $msg
} {1 {wrong # args: should be "wm iconify window"}}

test wm-iconify-2.1 {Misc errors} {
    catch {destroy .t2}
    toplevel .t2
    wm overrideredirect .t2 1
    set result [list [catch {wm iconify .t2} msg] $msg]
    destroy .t2
    set result
} {1 {can't iconify ".t2": override-redirect flag is set}}

test wm-iconify-2.2 {Misc errors} {
    catch {destroy .t2}
    toplevel .t2
    wm geom .t2 +0+0
    wm transient .t2 .t
    set result [list [catch {wm iconify .t2} msg] $msg]
    destroy .t2
    set result
} {1 {can't iconify ".t2": it is a transient}}

test wm-iconify-2.3 {Misc errors} {
    catch {destroy .t2}
    toplevel .t2
    wm geom .t2 +0+0
    wm iconwindow .t .t2
    set result [list [catch {wm iconify .t2} msg] $msg]
    destroy .t2
    set result
} {1 {can't iconify .t2: it is an icon for .t}}

test wm-iconify-2.4 {Misc errors} {
    catch {destroy .t2}
    frame .t.f -container 1
    toplevel .t2 -use [winfo id .t.f]
    set result [list [catch {wm iconify .t2} msg] $msg]
    destroy .t2 .r.f
    set result
} {1 {can't iconify .t2: it is an embedded window}}

test wm-iconify-3.1 {} {
    catch {destroy .t2}
    toplevel .t2
    wm geom .t2 -0+0
    update
    set result [winfo ismapped .t2]
    wm iconify .t2
    update
    lappend result [winfo ismapped .t2]
    destroy .t2
    set result
} {1 0}


test wm-iconmask-1.1 {usage} {
    list [catch {wm iconmask} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-iconmask-1.2 {usage} {
    list [catch {wm iconmask .t 12 13} msg] $msg
} {1 {wrong # args: should be "wm iconmask window ?bitmap?"}}

test wm-iconmask-1.3 {usage} {
    list [catch {wm iconmask .t bad-bitmap} msg] $msg
} {1 {bitmap "bad-bitmap" not defined}}

test wm-iconmask-2.1 {setting and reading values} {
    set result {}
    lappend result [wm iconmask .t]
    wm iconmask .t hourglass
    lappend result [wm iconmask .t]
    wm iconmask .t {}
    lappend result [wm iconmask .t]
} [list {} hourglass {}]


test wm-iconname-1.1 {usage} {
    list [catch {wm iconname} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-iconname-1.2 {usage} {
    list [catch {wm iconname .t 12 13} msg] $msg
} {1 {wrong # args: should be "wm iconname window ?newName?"}}

test wm-iconname-2.1 {setting and reading values} {
    set result {}
    lappend result [wm iconname .t]
    wm iconname .t ThisIconHasAName
    lappend result [wm iconname .t]
    wm iconname .t {}
    lappend result [wm iconname .t]
} [list {} ThisIconHasAName {}]


test wm-iconposition-1.1 {usage} {
    list [catch {wm iconposition} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-iconposition-1.2 {usage} {
    list [catch {wm iconposition .t 12} msg] $msg
} {1 {wrong # args: should be "wm iconposition window ?x y?"}}

test wm-iconposition-1.3 {usage} {
    list [catch {wm iconposition .t 12 13 14} msg] $msg
} {1 {wrong # args: should be "wm iconposition window ?x y?"}}

test wm-iconposition-1.4 {usage} {
    list [catch {wm iconposition .t bad 13} msg] $msg
} {1 {expected integer but got "bad"}}

test wm-iconposition-1.5 {usage} {
    list [catch {wm iconposition .t 13 lousy} msg] $msg
} {1 {expected integer but got "lousy"}}

test wm-iconposition-2.1 {setting and reading values} {
    set result {}
    lappend result [wm iconposition .t]
    wm iconposition .t 10 20
    lappend result [wm iconposition .t]
    wm iconposition .t {} {}
    lappend result [wm iconposition .t]
} [list {} {10 20} {}]


test wm-iconwindow-1.1 {usage} {
    list [catch {wm iconwindow} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-iconwindow-1.2 {usage} {
    list [catch {wm iconwindow .t 12 13} msg] $msg
} {1 {wrong # args: should be "wm iconwindow window ?pathName?"}}

test wm-iconwindow-1.3 {usage} {
    list [catch {wm iconwindow .t bogus} msg] $msg
} {1 {bad window path name "bogus"}}

test wm-iconwindow-1.4 {usage} {
    catch {destroy .b}
    button .b -text Help
    set result [list [catch {wm iconwindow .t .b} msg] $msg]
    destroy .b
    set result
} {1 {can't use .b as icon window: not at top level}}

test wm-iconwindow-1.5 {usage} {
    catch {destroy .icon}
    toplevel .icon -width 50 -height 50 -bg green
    catch {destroy .t2}
    toplevel .t2
    wm geom .t2 -0+0
    wm iconwindow .t2 .icon
    set result [list [catch {wm iconwindow .t .icon} msg] $msg]
    destroy .t2
    destroy .icon
    set result
} {1 {.icon is already an icon for .t2}}

test wm-iconwindow-2.1 {setting and reading values} {
    set result {}
    lappend result [wm iconwindow .t]
    catch {destroy .icon}
    toplevel .icon -width 50 -height 50 -bg green
    wm iconwindow .t .icon
    lappend result [wm iconwindow .t]
    wm iconwindow .t {}
    destroy .icon
    lappend result [wm iconwindow .t]
} [list {} .icon {}]


test wm-maxsize-1.1 {usage} {
    list [catch {wm maxsize} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-maxsize-1.2 {usage} {
    list [catch {wm maxsize . a} msg]  $msg
} {1 {wrong # args: should be "wm maxsize window ?width height?"}}

test wm-maxsize-1.3 {usage} {
    list [catch {wm maxsize . a b c} msg]  $msg
} {1 {wrong # args: should be "wm maxsize window ?width height?"}}

test wm-maxsize-1.4 {usage} {
    list [catch {wm maxsize . x 100} msg]  $msg
} {1 {expected integer but got "x"}}

test wm-maxsize-1.5 {usage} {
    list [catch {wm maxsize . 100 bogus} msg]  $msg
} {1 {expected integer but got "bogus"}}

test wm-maxsize-1.6 {usage} {
    catch {destroy .t2}
    toplevel .t2
    wm maxsize .t2 200 150
    set result [wm maxsize .t2]
    destroy .t2
    set result
} {200 150}


test wm-minsize-1.1 {usage} {
    list [catch {wm minsize} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-minsize-1.2 {usage} {
    list [catch {wm minsize . a} msg]  $msg
} {1 {wrong # args: should be "wm minsize window ?width height?"}}

test wm-minsize-1.3 {usage} {
    list [catch {wm minsize . a b c} msg]  $msg
} {1 {wrong # args: should be "wm minsize window ?width height?"}}

test wm-minsize-1.4 {usage} {
    list [catch {wm minsize . x 100} msg]  $msg
} {1 {expected integer but got "x"}}

test wm-minsize-1.5 {usage} {
    list [catch {wm minsize . 100 bogus} msg]  $msg
} {1 {expected integer but got "bogus"}}

test wm-minsize-1.6 {usage} {
    catch {destroy .t2}
    toplevel .t2
    wm minsize .t2 200 150
    set result [wm minsize .t2]
    destroy .t2
    set result
} {200 150}


test wm-overrideredirect-1.1 {usage} {
    list [catch {wm overrideredirect} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-overrideredirect-1.2 {usage} {
    list [catch {wm overrideredirect .t 1 2} msg]  $msg
} {1 {wrong # args: should be "wm overrideredirect window ?boolean?"}}

test wm-overrideredirect-1.3 {usage} {
    list [catch {wm overrideredirect .t boo} msg]  $msg
} {1 {expected boolean value but got "boo"}}

test wm-overrideredirect-2.1 {setting and reading values} {
    set result {}
    lappend result [wm overrideredirect .t]
    wm overrideredirect .t true
    lappend result [wm overrideredirect .t]
    wm overrideredirect .t off
    lappend result [wm overrideredirect .t]
} {0 1 0}


test wm-positionfrom-1.1 {usage} {
    list [catch {wm positionfrom} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-positionfrom-1.2 {usage} {
    list [catch {wm positionfrom .t 1 2} msg]  $msg
} {1 {wrong # args: should be "wm positionfrom window ?user/program?"}}

test wm-positionfrom-1.3 {usage} {
    list [catch {wm positionfrom .t none} msg]  $msg
} {1 {bad argument "none": must be program or user}}

test wm-positionfrom-2.1 {setting and reading values} {
    catch {destroy .t2}
    toplevel .t2
    set result {}
    wm positionfrom .t user
    lappend result [wm positionfrom .t]
    wm positionfrom .t program
    lappend result [wm positionfrom .t]
    wm positionfrom .t {}
    lappend result [wm positionfrom .t]
    destroy .t2
    set result
} {user program {}}


test wm-protocol-1.1 {usage} {
    list [catch {wm protocol} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-protocol-1.2 {usage} {
    list [catch {wm protocol .t 1 2 3} msg]  $msg
} {1 {wrong # args: should be "wm protocol window ?name? ?command?"}}

test wm-protocol-2.1 {setting and reading values} {
    wm protocol .t {foo a} {a b c}
    wm protocol .t bar {test script for bar}
    set result [wm protocol .t]
    wm protocol .t {foo a} {}
    wm protocol .t bar {}
    set result
} {bar {foo a}}

test wm-protocol-2.2 {setting and reading values} {
    set result {}
    wm protocol .t foo {a b c}
    wm protocol .t bar {test script for bar}
    lappend result [wm protocol .t foo] [wm protocol .t bar]
    wm protocol .t foo {}
    wm protocol .t bar {}
    lappend result [wm protocol .t foo] [wm protocol .t bar]
} {{a b c} {test script for bar} {} {}}

test wm-protocol-2.3 {setting and reading values} {
    wm protocol .t foo {a b c}
    wm protocol .t foo {test script}
    set result [wm protocol .t foo]
    wm protocol .t foo {}
    set result
} {test script}


test wm-resizable-1.1 {usage} {
    list [catch {wm resizable} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-resizable-1.2 {usage} {
    list [catch {wm resizable .t 1} msg]  $msg
} {1 {wrong # args: should be "wm resizable window ?width height?"}}

test wm-resizable-1.3 {usage} {
    list [catch {wm resizable .t 1 2 3} msg]  $msg
} {1 {wrong # args: should be "wm resizable window ?width height?"}}

test wm-resizable-1.4 {usage} {
    list [catch {wm resizable .t bad 0} msg]  $msg
} {1 {expected boolean value but got "bad"}}

test wm-resizable-1.5 {usage} {
    list [catch {wm resizable .t 1 bad} msg]  $msg
} {1 {expected boolean value but got "bad"}}

test wm-resizable-2.1 {setting and reading values} {
    wm resizable .t 0 1
    set result [wm resizable .t]
    wm resizable .t 1 0
    lappend result [wm resizable .t]
    wm resizable .t 1 1
    lappend result [wm resizable .t]
} {0 1 {1 0} {1 1}}


test wm-sizefrom-1.1 {usage} {
    list [catch {wm sizefrom} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-sizefrom-1.2 {usage} {
    list [catch {wm sizefrom .t 1 2} msg]  $msg
} {1 {wrong # args: should be "wm sizefrom window ?user|program?"}}

test wm-sizefrom-1.4 {usage} {
    list [catch {wm sizefrom .t bad} msg]  $msg
} {1 {bad argument "bad": must be program or user}}

test wm-sizefrom-2.1 {setting and reading values} {
    set result [list [wm sizefrom .t]]
    wm sizefrom .t user
    lappend result [wm sizefrom .t]
    wm sizefrom .t program
    lappend result [wm sizefrom .t]
    wm sizefrom .t {}
    lappend result [wm sizefrom .t]
} {{} user program {}}



test wm-stackorder-1.1 {usage} {
    list [catch {wm stackorder} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-stackorder-1.2 {usage} {
    list [catch {wm stackorder . _} err] $err
} {1 {wrong # args: should be "wm stackorder window ?isabove|isbelow window?"}}

test wm-stackorder-1.3 {usage} {
    list [catch {wm stackorder . _ _ _} err] $err
} {1 {wrong # args: should be "wm stackorder window ?isabove|isbelow window?"}}

test wm-stackorder-1.4 {usage} {
    list [catch {wm stackorder . is .} err] $err
} {1 {ambiguous argument "is": must be isabove or isbelow}}

test wm-stackorder-1.5 {usage} {
    list [catch {wm stackorder _} err] $err
} {1 {bad window path name "_"}}

test wm-stackorder-1.6 {usage} {
    list [catch {wm stackorder . isabove _} err] $err
} {1 {bad window path name "_"}}

test wm-stackorder-1.7 {usage} {
    catch {destroy .t}
    toplevel .t
    button .t.b
    list [catch {wm stackorder .t.b} err] $err
} {1 {window ".t.b" isn't a top-level window}}

test wm-stackorder-1.8 {usage} {
    catch {destroy .t}
    toplevel .t
    button .t.b
    pack .t.b
    update
    list [catch {wm stackorder . isabove .t.b} err] $err
} {1 {window ".t.b" isn't a top-level window}}

test wm-stackorder-1.9 {usage} {
    catch {destroy .t}
    toplevel .t
    button .t.b
    pack .t.b
    update
    list [catch {wm stackorder . isbelow .t.b} err] $err
} {1 {window ".t.b" isn't a top-level window}}

test wm-stackorder-1.10 {usage, isabove|isbelow toplevels must be mapped} {
    catch {destroy .t}
    toplevel .t ; update
    wm withdraw .t
    list [catch {wm stackorder .t isabove .} err] $err
} {1 {window ".t" isn't mapped}}

test wm-stackorder-1.11 {usage, isabove|isbelow toplevels must be mapped} {
    catch {destroy .t}
    toplevel .t ; update
    wm withdraw .t
    list [catch {wm stackorder . isbelow .t} err] $err
} {1 {window ".t" isn't mapped}}


deleteWindows


test wm-stackorder-2.1 {} {
    catch {destroy .t}
    toplevel .t ; update
    wm stackorder .
} {. .t}

test wm-stackorder-2.2 {} {
    catch {destroy .t}
    toplevel .t ; update
    raise .
    raiseDelay
    wm stackorder .
} {.t .}

test wm-stackorder-2.3 {} {
    catch {destroy .t}
    toplevel .t ; update
    catch {destroy .t2}
    toplevel .t2 ; update
    raise .
    raise .t2
    raiseDelay
    wm stackorder .
} {.t . .t2}

test wm-stackorder-2.4 {} {
    catch {destroy .t}
    toplevel .t ; update
    catch {destroy .t2}
    toplevel .t2 ; update
    raise .
    lower .t2
    raiseDelay
    wm stackorder .
} {.t2 .t .}

test wm-stackorder-2.5 {} {
    catch {destroy .parent}
    toplevel .parent ; update
    catch {destroy .parent.child1}
    toplevel .parent.child1 ; update
    catch {destroy .parent.child2}
    toplevel .parent.child2 ; update
    catch {destroy .extra}
    toplevel .extra ; update
    raise .parent
    lower .parent.child2
    raiseDelay
    wm stackorder .parent
} {.parent.child2 .parent.child1 .parent}

deleteWindows

test wm-stackorder-2.6 {non-toplevel widgets ignored} {
    catch {destroy .t1}
    toplevel .t1
    button .t1.b
    pack .t1.b
    update
    wm stackorder .
} {. .t1}

deleteWindows

test wm-stackorder-2.7 {no children returns self} {
    wm stackorder .
} {.}

deleteWindows


test wm-stackorder-3.1 {unmapped toplevel} {
    catch {destroy .t1}
    toplevel .t1 ; update
    catch {destroy .t2}
    toplevel .t2 ; update
    wm iconify .t1
    wm stackorder .
} {. .t2}

test wm-stackorder-3.2 {unmapped toplevel} {
    catch {destroy .t1}
    toplevel .t1 ; update
    catch {destroy .t2}
    toplevel .t2 ; update
    wm withdraw .t2
    wm stackorder .
} {. .t1}

test wm-stackorder-3.3 {unmapped toplevel} {
    catch {destroy .t1}
    toplevel .t1 ; update
    catch {destroy .t2}
    toplevel .t2 ; update
    wm withdraw .t2
    wm stackorder .t2
} {}

test wm-stackorder-3.4 {unmapped toplevel} {
    catch {destroy .t1}
    toplevel .t1 ; update
    toplevel .t1.t2 ; update
    wm withdraw .t1.t2
    wm stackorder .t1
} {.t1}

test wm-stackorder-3.5 {unmapped toplevel} {
    catch {destroy .t1}
    toplevel .t1 ; update
    toplevel .t1.t2 ; update
    wm withdraw .t1
    wm stackorder .t1
} {.t1.t2}

test wm-stackorder-3.6 {unmapped toplevel} {
    catch {destroy .t1}
    toplevel .t1 ; update
    toplevel .t1.t2 ; update
    toplevel .t1.t2.t3 ; update
    wm withdraw .t1.t2
    wm stackorder .t1
} {.t1 .t1.t2.t3}

test wm-stackorder-3.7 {unmapped toplevel, mapped children returned} {
    catch {destroy .t1}
    toplevel .t1 ; update
    toplevel .t1.t2 ; update
    wm withdraw .t1
    wm stackorder .t1
} {.t1.t2}

test wm-stackorder-3.8 {toplevel mapped in idle callback } {
    catch {destroy .t1}
    toplevel .t1
    wm stackorder .
} {.}


deleteWindows


test wm-stackorder-4.1 {wm stackorder isabove|isbelow} {
    catch {destroy .t}
    toplevel .t ; update
    raise .t
    wm stackorder . isabove .t
} {0}

test wm-stackorder-4.2 {wm stackorder isabove|isbelow} {
    catch {destroy .t}
    toplevel .t ; update
    raise .t
    wm stackorder . isbelow .t
} {1}

test wm-stackorder-4.3 {wm stackorder isabove|isbelow} {
    catch {destroy .t}
    toplevel .t ; update
    raise .
    raiseDelay
    wm stackorder .t isa .
} {0}

test wm-stackorder-4.4 {wm stackorder isabove|isbelow} {
    catch {destroy .t}
    toplevel .t ; update
    raise .
    raiseDelay
    wm stackorder .t isb .
} {1}

deleteWindows

test wm-stackorder-5.1 {a menu is not a toplevel} {
    catch {destroy .t}
    toplevel .t
    menu .t.m -type menubar
    .t.m add cascade -label "File"
    .t configure -menu .t.m
    update
    raise .
    raiseDelay
    wm stackorder .
} {.t .}

test wm-stackorder-5.2 {A normal toplevel can't be
        raised above an overrideredirect toplevel } {
    catch {destroy .t}
    toplevel .t
    wm overrideredirect .t 1
    raise .
    update
    raiseDelay
    wm stackorder . isabove .t
} 0

test wm-stackorder-5.3 {An overrideredirect window
        can be explicitly lowered } {
    catch {destroy .t}
    toplevel .t
    wm overrideredirect .t 1
    lower .t
    update
    raiseDelay
    wm stackorder .t isbelow .
} 1

test wm-stackorder-6.1 {An embedded toplevel does not
        appear in the stacking order} {
    deleteWindows
    toplevel .real -container 1
    toplevel .embd -bg blue -use [winfo id .real]
    update
    wm stackorder .
} {. .real}

stdWindow

test wm-title-1.1 {usage} {
    list [catch {wm title} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-title-1.2 {usage} {
    list [catch {wm title . 1 2} msg]  $msg
} {1 {wrong # args: should be "wm title window ?newTitle?"}}

test wm-title-2.1 {setting and reading values} {
    destroy .t
    toplevel .t
    set result [wm title .t]
    wm title .t Apa
    lappend result [wm title .t]
    wm title .t {}
    lappend result [wm title .t]
} {t Apa {}}


test wm-transient-1.1 {usage} {
    catch {destroy .t} ; toplevel .t
    list [catch {wm transient .t 1 2} msg]  $msg
} {1 {wrong # args: should be "wm transient window ?master?"}}

test wm-transient-1.2 {usage} {
    catch {destroy .t} ; toplevel .t
    list [catch {wm transient .t foo} msg]  $msg
} {1 {bad window path name "foo"}}

test wm-transient-1.3 {usage} {
    catch {destroy .t} ; toplevel .t
    list [catch {wm transient foo .t} msg]  $msg
} {1 {bad window path name "foo"}}

test wm-transient-1.4 {usage} {
    deleteWindows
    toplevel .master
    toplevel .subject
    wm transient .subject .master
    list [catch {wm iconify .subject} msg] $msg
} {1 {can't iconify ".subject": it is a transient}}

test wm-transient-1.5 {usage} {
    deleteWindows
    toplevel .icon -bg blue
    toplevel .top
    wm iconwindow .top .icon
    toplevel .dummy
    list [catch {wm transient .icon .dummy} msg] $msg
} {1 {can't make ".icon" a transient: it is an icon for .top}}

test wm-transient-1.6 {usage} {
    deleteWindows
    toplevel .icon -bg blue
    toplevel .top
    wm iconwindow .top .icon
    toplevel .dummy
    list [catch {wm transient .dummy .icon} msg] $msg
} {1 {can't make ".icon" a master: it is an icon for .top}}

test wm-transient-1.7 {usage} {
    deleteWindows
    toplevel .master
    list [catch {wm transient .master .master} err] $err
} {1 {can't make ".master" its own master}}

test wm-transient-1.8 {usage} {
    deleteWindows
    toplevel .master
    frame .master.f
    list [catch {wm transient .master .master.f} err] $err
} {1 {can't make ".master" its own master}}

test wm-transient-2.1 { basic get/set of master } {
    deleteWindows
    set results [list]    
    toplevel .master
    toplevel .subject
    lappend results [wm transient .subject]
    wm transient .subject .master
    lappend results [wm transient .subject]
    wm transient .subject {}
    lappend results [wm transient .subject]
    set results
} {{} .master {}}

test wm-transient-2.2 { first toplevel parent of
        non-toplevel master is used } {
    deleteWindows
    toplevel .master
    frame .master.f
    toplevel .subject
    wm transient .subject .master.f
    wm transient .subject
} {.master}

test wm-transient-3.1 { transient toplevel is withdrawn
        when mapped if master is withdrawn } {
    deleteWindows
    toplevel .master
    wm withdraw .master
    update
    toplevel .subject
    wm transient .subject .master
    update
    list [wm state .subject] [winfo ismapped .subject]
} {withdrawn 0}

test wm-transient-3.2 { already mapped transient toplevel
        takes on withdrawn state of master } {
    deleteWindows
    toplevel .master
    wm withdraw .master
    update
    toplevel .subject
    update
    wm transient .subject .master
    update
    list [wm state .subject] [winfo ismapped .subject]
} {withdrawn 0}

test wm-transient-3.3 { withdraw/deiconify on the master
        also does a withdraw/deiconify on the transient } {
    deleteWindows
    set results [list]
    toplevel .master
    toplevel .subject
    update
    wm transient .subject .master
    wm withdraw .master
    update
    lappend results [wm state .subject] \
        [winfo ismapped .subject]
    wm deiconify .master
    update
    lappend results [wm state .subject] \
        [winfo ismapped .subject]
    set results
} {withdrawn 0 normal 1}

test wm-transient-4.1 { transient toplevel is withdrawn
        when mapped if master is iconic } {
    deleteWindows
    toplevel .master
    wm iconify .master
    update
    toplevel .subject
    wm transient .subject .master
    update
    list [wm state .subject] [winfo ismapped .subject]
} {withdrawn 0}

test wm-transient-4.2 { already mapped transient toplevel
        is withdrawn if master is iconic } {
    deleteWindows
    toplevel .master
    wm iconify .master
    update
    toplevel .subject
    update
    wm transient .subject .master
    update
    list [wm state .subject] [winfo ismapped .subject]
} {withdrawn 0}

test wm-transient-4.3 { iconify/deiconify on the master
        does a withdraw/deiconify on the transient } {
    deleteWindows
    set results [list]
    toplevel .master
    toplevel .subject
    update
    wm transient .subject .master
    wm iconify .master
    update
    lappend results [wm state .subject] \
        [winfo ismapped .subject]
    wm deiconify .master
    update
    lappend results [wm state .subject] \
        [winfo ismapped .subject]
    set results
} {withdrawn 0 normal 1}

test wm-transient-5.1 { an error during transient command should not
        cause the map/unmap binding to be deleted } {
    deleteWindows
    set results [list]
    toplevel .master
    toplevel .subject
    update
    wm transient .subject .master
    # Expect a bad window path error here
    lappend results [catch {wm transient .subject .bad}]
    wm withdraw .master
    update
    lappend results [wm state .subject]
    wm deiconify .master
    update
    lappend results [wm state .subject]
    set results
} {1 withdrawn normal}

test wm-transient-5.2 { remove transient property when master
        is destroyed } {
    deleteWindows
    toplevel .master
    toplevel .subject
    wm transient .subject .master
    update
    destroy .master
    update
    wm transient .subject
} {}

test wm-transient-5.3 { remove transient property from window
        that had never been mapped when master is destroyed } {
    deleteWindows
    toplevel .master
    toplevel .subject
    wm transient .subject .master
    destroy .master
    wm transient .subject
} {}

test wm-transient-6.1 { a withdrawn transient does not track
        state changes in the master } {
    deleteWindows
    toplevel .master
    toplevel .subject
    update
    wm transient .subject .master
    wm withdraw .subject
    wm withdraw .master
    wm deiconify .master
    # idle handler should not map the transient
    update
    wm state .subject
} {withdrawn}

test wm-transient-6.2 { a withdrawn transient does not track
        state changes in the master } {
    set results [list]
    deleteWindows
    toplevel .master
    toplevel .subject
    update
    wm transient .subject .master
    wm withdraw .subject
    wm withdraw .master
    wm deiconify .master
    # idle handler should not map the transient
    update
    lappend results [wm state .subject]
    wm deiconify .subject
    lappend results [wm state .subject]
    wm withdraw .master
    lappend results [wm state .subject]
    wm deiconify .master
    # idle handler should map transient
    update
    lappend results [wm state .subject]
} {withdrawn normal withdrawn normal}


# wm-transient-7.*: See SF Tk Bug #592201 "wm transient fails with two masters"
# wm-transient-7.3 through 7.5 all caused panics on Unix in Tk 8.4b1.
# 7.1 and 7.2 added to catch (potential) future errors.
#
test wm-transient-7.1 {Destroying transient} {
    deleteWindows
    toplevel .t 
    toplevel .transient 
    wm transient .transient .t
    destroy .transient
    destroy .t
    # OK: the above did not cause a panic.
} {}

test wm-transient-7.2 {Destroying master} {
    deleteWindows
    toplevel .t
    toplevel .transient 
    wm transient .transient .t
    destroy .t
    set result [wm transient .transient]
    destroy .transient
    set result
} {}

test wm-transient-7.3 {Reassign transient, destroy old master} {
    deleteWindows
    toplevel .t1 
    toplevel .t2 
    toplevel .transient
    wm transient .transient .t1
    wm transient .transient .t2
    destroy .t1	;# Caused panic in 8.4b1
    destroy .t2 
    destroy .transient
} {}

test wm-transient-7.4 {Reassign transient, destroy new master} {
    deleteWindows
    toplevel .t1 
    toplevel .t2 
    toplevel .transient
    wm transient .transient .t1
    wm transient .transient .t2
    destroy .t2 	;# caused panic in 8.4b1
    destroy .t1
    destroy .transient
} {}

test wm-transient-7.5 {Reassign transient, destroy transient} {
    deleteWindows
    toplevel .t1 
    toplevel .t2 
    toplevel .transient
    wm transient .transient .t1
    wm transient .transient .t2
    destroy .transient
    destroy .t2 	;# caused panic in 8.4b1
    destroy .t1		;# so did this
} {}

test wm-state-1.1 {usage} {
    list [catch {wm state} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-state-1.2 {usage} {
    list [catch {wm state . _ _} err] $err
} {1 {wrong # args: should be "wm state window ?state?"}}

test wm-state-2.1 {initial state} {
    deleteWindows
    toplevel .t
    wm state .t
} {normal}

test wm-state-2.2 {state change before map} {
    deleteWindows
    toplevel .t
    wm state .t withdrawn
    wm state .t
} {withdrawn}

test wm-state-2.3 {state change before map} {
    deleteWindows
    toplevel .t
    wm withdraw .t
    wm state .t
} {withdrawn}

test wm-state-2.4 {state change after map} {
    deleteWindows
    toplevel .t
    update
    wm state .t withdrawn
    wm state .t
} {withdrawn}

test wm-state-2.5 {state change after map} {
    deleteWindows
    toplevel .t
    update
    wm withdraw .t
    wm state .t
} {withdrawn}

test wm-state-2.6 {state change before map} {
    deleteWindows
    toplevel .t
    wm state .t iconic
    wm state .t
} {iconic}

test wm-state-2.7 {state change before map} {
    deleteWindows
    toplevel .t
    wm iconify .t
    wm state .t
} {iconic}

test wm-state-2.8 {state change after map} {
    deleteWindows
    toplevel .t
    update
    wm state .t iconic
    wm state .t
} {iconic}

test wm-state-2.9 {state change after map} {
    deleteWindows
    toplevel .t
    update
    wm iconify .t
    wm state .t
} {iconic}

test wm-state-2.10 {state change before map} {
    deleteWindows
    toplevel .t
    wm withdraw .t
    wm state .t normal
    wm state .t
} {normal}

test wm-state-2.11 {state change before map} {
    deleteWindows
    toplevel .t
    wm withdraw .t
    wm deiconify .t
    wm state .t
} {normal}

test wm-state-2.12 {state change after map} {
    deleteWindows
    toplevel .t
    update
    wm withdraw .t
    wm state .t normal
    wm state .t
} {normal}

test wm-state-2.13 {state change after map} {
    deleteWindows
    toplevel .t
    update
    wm withdraw .t
    wm deiconify .t
    wm state .t
} {normal}

test wm-state-2.14 {state change before map} {
    deleteWindows
    toplevel .t
    wm iconify .t
    wm state .t normal
    wm state .t
} {normal}

test wm-state-2.15 {state change before map} {
    deleteWindows
    toplevel .t
    wm iconify .t
    wm deiconify .t
    wm state .t
} {normal}

test wm-state-2.16 {state change after map} {
    deleteWindows
    toplevel .t
    update
    wm iconify .t
    wm state .t normal
    wm state .t
} {normal}

test wm-state-2.17 {state change after map} {
    deleteWindows
    toplevel .t
    update
    wm iconify .t
    wm deiconify .t
    wm state .t
} {normal}


test wm-withdraw-1.1 {usage} {
    list [catch {wm withdraw} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-withdraw-1.2 {usage} {
    list [catch {wm withdraw . _} msg] $msg
} {1 {wrong # args: should be "wm withdraw window"}}

test wm-withdraw-2.1 {Misc errors} {
    deleteWindows
    toplevel .t
    toplevel .t2
    wm iconwindow .t .t2
    set result [list [catch {wm withdraw .t2} msg] $msg]
    destroy .t2
    set result
} {1 {can't withdraw .t2: it is an icon for .t}}

test wm-withdraw-3.1 {} {
    update
    set result {}
    wm withdraw .t
    lappend result [wm state .t] [winfo ismapped .t]
    wm deiconify .t
    lappend result [wm state .t] [winfo ismapped .t]
} {withdrawn 0 normal 1}


# FIXME:

# Test delivery of virtual events to the WM. We could check to see
# if the window was raised after a button click for example.
# This sort of testing may not be possible.


deleteWindows
tcltest::cleanupTests
return



@


1.5
log
@touched all sources to ease next import
@
text
@d6 3
a8 1
# Copyright (c) 1994-1995 Sun Microsystems, Inc.
d10 1
a10 4
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# SCCS: @@(#) wm.test 1.31 96/03/01 11:36:58
d12 14
a25 2
if {[string compare test [info procs test]] == 1} {
    source defs
d28 5
a32 4
proc sleep ms {
    global x
    after $ms {set x 1}
    tkwait variable x
d35 7
a41 10
set i 1
foreach geom {+20+80 +80+20 +0+0} {
    catch {destroy .t}
    test wm-1.$i {initial window position} {
	toplevel .t -width 200 -height 150
	wm geom .t $geom
	update
	wm geom .t
    } 200x150$geom
    incr i
a43 25
# The tests below are tricky because window managers don't all move
# windows correctly.  Try one motion and compute the window manager's
# error, then factor this error into the actual tests.  In other words,
# this just makes sure that things are consistent between moves.

set i 1
catch {destroy .t}
toplevel .t -width 100 -height 150
wm geom .t +200+200
update
wm geom .t +150+150
update
scan [wm geom .t] %dx%d+%d+%d width height x y
set xerr [expr 150-$x]
set yerr [expr 150-$y]
foreach geom {+20+80 +80+20 +0+0 -0-0 +0-0 -0+0 -10-5 -10+5 +10-5} {
    test wm-2.$i {moving window while mapped} {
	wm geom .t $geom
	update
	scan [wm geom .t] %dx%d%1s%d%1s%d width height xsign x ysign y
	format "%s%d%s%d" $xsign [expr $x$xsign$xerr] $ysign \
		[expr $y$ysign$yerr]
    } $geom
    incr i
}
d45 126
a170 14
set i 1
foreach geom {+20+80 +80+20 +0+0 -0-0 +0-0 -0+0 -10-5 -10+5 +10-5} {
    test wm-3.$i {moving window while iconified} {
	wm iconify .t
	sleep 200
	wm geom .t $geom
	update
	wm deiconify .t
	scan [wm geom .t] %dx%d%1s%d%1s%d width height xsign x ysign y
	format "%s%d%s%d" $xsign [expr $x$xsign$xerr] $ysign \
		[expr $y$ysign$yerr]
    } $geom
    incr i
}
d172 3
a174 12
set i 1
foreach geom {+20+80 +100+40 +0+0} {
    test wm-4.$i {moving window while withdrawn} {
	wm withdraw .t
	sleep 200
	wm geom .t $geom
	update
	wm deiconify .t
	wm geom .t
    } 100x150$geom
    incr i
}
d176 11
a186 4
test wm-5.1 {compounded state changes} {nonPortable} {
    catch {destroy .t}
    toplevel .t -width 200 -height 100
    wm geometry .t +100+100
d188 81
d271 22
a292 7
    list [winfo ismapped .t] [wm state .t]
} {1 normal}
test wm-5.2 {compounded state changes} {nonPortable} {
    catch {destroy .t}
    toplevel .t -width 200 -height 100
    wm geometry .t +100+100
    update
d295 1
a295 7
    wm withdraw .t
    list [winfo ismapped .t] [wm state .t]
} {0 withdrawn}
test wm-5.3 {compounded state changes} {nonPortable} {
    catch {destroy .t}
    toplevel .t -width 200 -height 100
    wm geometry .t +100+100
d297 52
a348 10
    wm iconify .t
    wm deiconify .t
    wm iconify .t
    wm deiconify .t
    list [winfo ismapped .t] [wm state .t]
} {1 normal}
test wm-5.4 {compounded state changes} {nonPortable} {
    catch {destroy .t}
    toplevel .t -width 200 -height 100
    wm geometry .t +100+100
d350 2
a351 9
    wm iconify .t
    wm deiconify .t
    wm iconify .t
    list [winfo ismapped .t] [wm state .t]
} {0 iconic}
test wm-5.5 {compounded state changes} {nonPortable} {
    catch {destroy .t}
    toplevel .t -width 200 -height 100
    wm geometry .t +100+100
d353 164
a516 8
    wm iconify .t
    wm withdraw .t
    list [winfo ismapped .t] [wm state .t]
} {0 withdrawn}
test wm-5.6 {compounded state changes} {nonPortable} {
    catch {destroy .t}
    toplevel .t -width 200 -height 100
    wm geometry .t +100+100
d518 2
a519 9
    wm iconify .t
    wm withdraw .t
    wm deiconify .t
    list [winfo ismapped .t] [wm state .t]
} {1 normal}
test wm-5.7 {compounded state changes} {nonPortable} {
    catch {destroy .t}
    toplevel .t -width 200 -height 100
    wm geometry .t +100+100
d521 44
a564 4
    wm withdraw .t
    wm iconify .t
    list [winfo ismapped .t] [wm state .t]
} {0 iconic}
a565 45
catch {destroy .t}
toplevel .t -width 200 -height 100
wm geom .t +10+10
wm minsize .t 1 1
update
test wm-6.1 {size changes} {
    .t config -width 180 -height 150
    update
    wm geom .t
} 180x150+10+10
test wm-6.2 {size changes} {
    wm geom .t 250x60
    .t config -width 170 -height 140
    update
    wm geom .t
} 250x60+10+10
test wm-6.3 {size changes} {
    wm geom .t 250x60
    .t config -width 170 -height 140
    wm geom .t {}
    update
    wm geom .t
} 170x140+10+10
test wm-6.4 {size changes} {nonPortable} {
    wm minsize .t 1 1
    update
    puts stdout "Please resize window \"t\" with the mouse (but don't move it!),"
    puts -nonewline stdout "then hit return: "
    flush stdout
    gets stdin
    update
    set width [winfo width .t]
    set height [winfo height .t]
    .t config -width 230 -height 110
    update
    incr width -[winfo width .t]
    incr height -[winfo height .t]
    wm geom .t {}
    update
    set w2 [winfo width .t]
    set h2 [winfo height .t]
    .t config -width 114 -height 261
    update
    list $width $height $w2 $h2 [wm geom .t]
} {0 0 230 110 114x261+10+10}
d567 28
a594 19
test wm-7.1 {window initially withdrawn} {
    catch {destroy .t}
    toplevel .t -width 100 -height 30
    wm geometry .t +0+0
    wm withdraw .t
    sleep 200
    set result [winfo ismapped .t]
    wm deiconify .t
    list $result [winfo ismapped .t]
} {0 1}
test wm-7.2 {window initially withdrawn} {
    catch {destroy .t}
    toplevel .t -width 100 -height 30
    wm geometry .t +0+0
    wm withdraw .t
    wm deiconify .t
    sleep 200
    winfo ismapped .t
} 1
a595 9
test wm-8.1 {window initially iconic} {
    catch {destroy .t}
    toplevel .t -width 100 -height 30
    wm geometry .t +0+0
    wm title .t 1
    wm iconify .t
    update idletasks
    list [winfo ismapped .t] [wm state .t]
} {0 iconic}
d597 3
a599 15
# I don't know why the wait below is needed, but without it the test
# fails under twm.
sleep 200

test wm-8.2 {window initially iconic} {nonPortable} {
    catch {destroy .t}
    toplevel .t -width 100 -height 30
    wm geometry .t +0+0
    wm title .t 2
    wm iconify .t
    update idletasks
    wm withdraw .t
    wm deiconify .t
    list [winfo ismapped .t] [wm state .t]
} {1 normal}
d601 15
a615 19
catch {destroy .m}
menu .m
foreach i {{Test label} Another {Yet another} {Last label}} {
    .m add command -label $i
}
.m post 100 200
test wm-9.1 {override_redirect and Tk_MoveTopLevelWindow} {
    list [winfo ismapped .m] [wm state .m] [winfo x .m] [winfo y .m]
} {1 normal 100 200}
.m post 150 210
test wm-9.2 {override_redirect and Tk_MoveTopLevelWindow} {
    list [winfo ismapped .m] [wm state .m] [winfo x .m] [winfo y .m]
} {1 normal 150 210}
.m unpost
test wm-9.3 {override_redirect and Tk_MoveTopLevelWindow} {
    list [winfo ismapped .m]
} 0
destroy .m
catch {destroy .t}
d617 1
a617 2
test wm-10.1 {icon windows} {
    catch {destroy .t}
d619 14
a632 17
    toplevel .t -width 100 -height 30
    wm geometry .t +0+0
    toplevel .icon -width 50 -height 50 -bg red
    wm iconwindow .t .icon
    list [catch {wm iconify .icon} msg] $msg
} {1 {can't iconify .icon: it is an icon for .t}}
test wm-10.2 {icon windows} {
    catch {destroy .t}
    catch {destroy .icon}
    toplevel .t -width 100 -height 30
    wm geometry .t +0+0
    toplevel .icon -width 50 -height 50 -bg red
    wm iconwindow .t .icon
    list [catch {wm deiconify .icon} msg] $msg
} {1 {can't deiconify .icon: it is an icon for .t}}
test wm-10.3 {icon windows} {
    catch {destroy .t}
d634 1
a634 23
    toplevel .t -width 100 -height 30
    wm geometry .t +0+0
    toplevel .icon -width 50 -height 50 -bg red
    wm iconwindow .t .icon
    list [catch {wm withdraw .icon} msg] $msg
} {1 {can't withdraw .icon: it is an icon for .t}}
test wm-10.4 {icon windows} {
    catch {destroy .t}
    toplevel .t -width 100 -height 30
    list [catch {wm iconwindow} msg] $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}
test wm-10.5 {icon windows} {
    catch {destroy .t}
    toplevel .t -width 100 -height 30
    list [catch {wm iconwindow .t b c} msg] $msg
} {1 {wrong # arguments: must be "wm iconwindow window ?pathName?"}}
test wm-10.6 {icon windows} {
    catch {destroy .t}
    catch {destroy .icon}
    toplevel .t -width 100 -height 30
    wm geom .t +0+0
    set result [wm iconwindow .t]
    toplevel .icon -width 50 -height 50 -bg red
d636 1
a636 1
    lappend result [wm iconwindow .t] [wm state .icon]
d638 3
a640 48
    lappend result [wm iconwindow .t] [wm state .icon]
    update
    lappend result [winfo ismapped .t] [winfo ismapped .icon]
    wm iconify .t
    update
    lappend result [winfo ismapped .t] [winfo ismapped .icon]
} {.icon icon {} withdrawn 1 0 0 0}
test wm-10.7 {icon windows} {
    catch {destroy .t}
    toplevel .t -width 100 -height 30
    list [catch {wm iconwindow .t .gorp} msg] $msg
} {1 {bad window path name ".gorp"}}
test wm-10.8 {icon windows} {
    catch {destroy .t}
    toplevel .t -width 100 -height 30
    frame .t.icon -width 50 -height 50 -bg red
    list [catch {wm iconwindow .t .t.icon} msg] $msg
} {1 {can't use .t.icon as icon window: not at top level}}
test wm-10.9 {icon windows} {
    catch {destroy .t}
    catch {destroy .icon}
    toplevel .t -width 100 -height 30
    wm geom .t +0+0
    toplevel .icon -width 50 -height 50 -bg red
    toplevel .icon2 -width 50 -height 50 -bg green
    wm iconwindow .t .icon
    set result "[wm iconwindow .t] [wm state .icon] [wm state .icon2]"
    wm iconwindow .t .icon2
    lappend result [wm iconwindow .t] [wm state .icon] [wm state .icon2]
} {.icon icon normal .icon2 withdrawn icon}
catch {destroy .icon2}
test wm-10.10 {icon windows} {
    catch {destroy .t}
    catch {destroy .icon}
    toplevel .icon -width 50 -height 50 -bg red
    wm geom .icon +0+0
    update
    set result [winfo ismapped .icon]
    toplevel .t -width 100 -height 30
    wm geom .t +0+0
    wm iconwindow .t .icon
    after 500 {set x 1}
    tkwait variable x
    lappend result [winfo ismapped .t] [winfo ismapped .icon]
} {1 1 0}
test wm-10.11 {icon windows} {nonPortable} {
    # This test is non-portable because some window managers will
    # destroy an icon window when it's associated window is destroyed.
a641 16
    catch {destroy .t}
    catch {destroy .icon}
    toplevel .t -width 100 -height 30
    toplevel .icon -width 50 -height 50 -bg red
    wm geom .t +0+0
    wm iconwindow .t .icon
    update
    set result "[wm state .icon] [winfo ismapped .t] [winfo ismapped .icon]"
    destroy .t
    wm geom .icon +0+0
    update
    lappend result [winfo ismapped .icon] [wm state .icon]
    wm deiconify .icon
    update
    lappend result [winfo ismapped .icon] [wm state .icon]
} {icon 1 0 0 withdrawn 1 normal}
d643 1
a643 61
test wm-11.1 {colormapwindows} {
    catch {destroy .t}
    toplevel .t -width 200 -height 200 -colormap new
    wm geom .t +0+0
    frame .t.a -width 100 -height 30
    frame .t.b -width 100 -height 30 -colormap new
    pack .t.a .t.b -side top
    update
    set x [wm colormapwindows .t]
    frame .t.c -width 100 -height 30 -colormap new
    pack .t.c -side top
    update
    list $x [wm colormapwindows .t]
} {{.t.b .t} {.t.b .t.c .t}}
test wm-11.2 {colormapwindows} {
    list [catch {wm colormapwindows . 1 2} msg] $msg
} {1 {wrong # arguments: must be "wm colormapwindows window ?windowList?"}}
test wm-11.3 {colormapwindows} {
    list [catch {wm col . "a \{"} msg] $msg
} {1 {unmatched open brace in list}}
test wm-11.4 {colormapwindows} {
    list [catch {wm colormapwindows . foo} msg] $msg
} {1 {bad window path name "foo"}}
test wm-11.5 {colormapwindows} {
    catch {destroy .t}
    toplevel .t -width 200 -height 200 -colormap new
    wm geom .t +0+0
    frame .t.a -width 100 -height 30
    frame .t.b -width 100 -height 30
    frame .t.c -width 100 -height 30
    pack .t.a .t.b .t.c -side top
    wm colormapwindows .t {.t.c .t .t.a}
    wm colormapwindows .t
} {.t.c .t .t.a}
test wm-11.6 {colormapwindows} {
    catch {destroy .t}
    toplevel .t -width 200 -height 200
    wm geom .t +0+0
    frame .t.a -width 100 -height 30
    frame .t.b -width 100 -height 30
    frame .t.c -width 100 -height 30
    pack .t.a .t.b .t.c -side top
    wm colormapwindows .t {.t.b .t.a}
    wm colormapwindows .t
} {.t.b .t.a}
test wm-11.7 {colormapwindows} {
    catch {destroy .t}
    toplevel .t -width 200 -height 200 -colormap new
    wm geom .t +0+0
    set x [wm colormapwindows .t]
    wm colormapwindows .t {}
    list $x [wm colormapwindows .t]
} {{} {}}

catch {destroy .t}
catch {destroy .icon}

toplevel .t -width 100 -height 50
wm geom .t +0+0
update
test wm-12.1 {Tk_WmCmd procedure, "maxsize" option} {
d646 2
a647 1
test wm-12.2 {Tk_WmCmd procedure, "maxsize" option} {
d649 3
a651 2
} {1 {wrong # arguments: must be "wm maxsize window ?width height?"}}
test wm-12.3 {Tk_WmCmd procedure, "maxsize" option} {
d653 3
a655 5
} {1 {wrong # arguments: must be "wm maxsize window ?width height?"}}
test wm-12.4 {Tk_WmCmd procedure, "maxsize" option} {nonPortable} {
    wm maxsize .t
}  {1137 870}
test wm-12.5 {Tk_WmCmd procedure, "maxsize" option} {
d658 2
a659 1
test wm-12.6 {Tk_WmCmd procedure, "maxsize" option} {
d662 8
a669 3
test wm-12.7 {Tk_WmCmd procedure, "maxsize" option} {
    wm maxsize .t 200 150
    wm maxsize .t
a670 3
test wm-12.8 {Tk_WmCmd procedure, "maxsize" option} {nonPortable} {
    # Not portable, because some window managers let applications override
    # minsize and maxsize.
a671 6
    wm maxsize .t 200 150
    wm geom .t 300x200
    update
    list [winfo width .t] [winfo height .t]
} {200 150}
destroy .t
d673 1
a673 4
toplevel .t -width 300 -height 200
wm geom .t +0+0
update
test wm-13.1 {Tk_WmCmd procedure, "minsize" option} {
d676 2
a677 1
test wm-13.2 {Tk_WmCmd procedure, "minsize" option} {
d679 3
a681 2
} {1 {wrong # arguments: must be "wm minsize window ?width height?"}}
test wm-13.3 {Tk_WmCmd procedure, "minsize" option} {
d683 3
a685 5
} {1 {wrong # arguments: must be "wm minsize window ?width height?"}}
test wm-13.4 {Tk_WmCmd procedure, "minsize" option} {
    wm minsize .t
}  {1 1}
test wm-13.5 {Tk_WmCmd procedure, "minsize" option} {
d688 2
a689 1
test wm-13.6 {Tk_WmCmd procedure, "minsize" option} {
d692 8
a699 3
test wm-13.7 {Tk_WmCmd procedure, "minsize" option} {
    wm minsize .t 200 150
    wm minsize .t
d701 37
a737 25
test wm-13.8 {Tk_WmCmd procedure, "minsize" option} {nonPortable} {
    # Not portable, because some window managers let applications override
    # minsize and maxsize.

    wm minsize .t 150 100
    wm geom .t 50x50
    update
    list [winfo width .t] [winfo height .t]
} {150 100}
test wm-13.9 {Tk_WmCmd procedure, "resizable" option} {
    list [catch {wm resizable . a} msg]  $msg
} {1 {wrong # arguments: must be "wm resizable window ?width height?"}}
test wm-13.10 {Tk_WmCmd procedure, "resizable" option} {
    list [catch {wm resizable . a b c} msg]  $msg
} {1 {wrong # arguments: must be "wm resizable window ?width height?"}}
test wm-13.11 {Tk_WmCmd procedure, "resizable" option} {
    list [catch {wm resizable .foo a b c} msg]  $msg
} {1 {bad window path name ".foo"}}
test wm-13.12 {Tk_WmCmd procedure, "resizable" option} {
    list [catch {wm resizable . x 1} msg]  $msg
} {1 {expected boolean value but got "x"}}
test wm-13.13 {Tk_WmCmd procedure, "resizable" option} {
    list [catch {wm resizable . 0 gorp} msg]  $msg
} {1 {expected boolean value but got "gorp"}}
test wm-13.14 {Tk_WmCmd procedure, "resizable" option} {
d739 133
a871 12
    toplevel .t2 -width 200 -height 100
    wm geom .t2 +0+0
    set result ""
    lappend result [wm resizable .t2]
    wm resizable .t2 1 0
    lappend result [wm resizable .t2]
    wm resizable .t2 no off
    lappend result [wm resizable .t2]
    wm resizable .t2 false true
    lappend result [wm resizable .t2]
} {{1 1} {1 0} {0 0} {0 1}}
destroy .t2
d873 1
a873 2
test wm-14.1 {TopLevelReqProc procedure, resize causes window to move} \
	{nonPortable} {
d875 3
a877 2
    toplevel .t -width 200 -height 200
    wm geom .t +0+0
d879 8
a886 1
    wm geom .t -0-0
d888 205
a1092 7
    set x [winfo x .t]
    set y [winfo y .t]
    .t configure -width 300 -height 150
    update
    list [expr [winfo x .t] - $x] [expr [winfo y .t] - $y] \
	    [winfo width .t] [winfo height .t]
} {-100 50 300 150}
d1094 2
a1095 1
test wm-15.1 {Tk_SetGrid procedure, set grid dimensions before turning on grid} {nonPortable} {
d1098 2
a1099 3
    wm geometry .t 30x10+0+0
    listbox .t.l -height 20 -width 20 -setgrid 1 
    pack .t.l -fill both -expand 1
d1101 6
a1106 3
    wm geometry .t
} {30x10+0+0}
test wm-15.2 {Tk_SetGrid procedure, turning on grid when dimensions already set} {
d1109 2
a1110 3
    wm geometry .t 200x100+0+0
    listbox .t.l -height 20 -width 20 
    pack .t.l -fill both -expand 1
d1112 9
a1120 1
    .t.l configure -setgrid 1
d1122 2
a1123 2
    wm geometry .t
} {20x20+0+0}
d1125 367
a1491 4
test wm-16.1 {WaitForEvent procedure, use of modal timeout} {
    catch {destroy .t}
    toplevel .t -width 200 -height 200
    wm geom .t +0+0
d1493 14
d1508 6
a1513 4
    set x no
    after 0 {set x yes}
    wm deiconify .t
    set result $x
d1515 3
a1517 2
    list $result $x
} {no yes}
d1519 3
a1521 4
test wm-17.1 {ParseGeometry procedure, resize causes window to move} {
    catch {destroy .t}
    toplevel .t -width 200 -height 200
    wm geom .t +0+0
d1523 23
a1545 1
    wm geom .t -0-0
d1547 8
a1554 3
    set x [winfo x .t]
    set y [winfo y .t]
    wm geometry .t 150x300
d1556 20
a1575 3
    list [expr [winfo x .t] - $x] [expr [winfo y .t] - $y] \
	    [winfo width .t] [winfo height .t]
} {50 -100 150 300}
d1577 3
a1579 4
test wm-18.1 {TkWmAddToColormapWindows procedure} {
    catch {destroy .t}
    toplevel .t -width 200 -height 200 -colormap new -relief raised -bd 2
    wm geom .t +0+0
d1581 8
a1588 8
    wm colormap .t
} {}
test wm-18.2 {TkWmAddToColormapWindows procedure} {
    catch {destroy .t}
    toplevel .t -colormap new -relief raised -bd 2
    wm geom .t +0+0
    frame .t.f -width 100 -height 100 -colormap new -relief sunken -bd 2
    pack .t.f
d1590 25
a1614 19
    wm colormap .t
} {.t.f .t}
test wm-18.3 {TkWmAddToColormapWindows procedure} {
    catch {destroy .t}
    toplevel .t -colormap new
    wm geom .t +0+0
    frame .t.f -width 100 -height 100 -colormap new -relief sunken -bd 2
    pack .t.f
    frame .t.f2 -width 100 -height 100 -colormap new -relief sunken -bd 2
    pack .t.f2
    update
    wm colormap .t
} {.t.f .t.f2 .t}
test wm-18.4 {TkWmAddToColormapWindows procedure} {
    catch {destroy .t}
    toplevel .t -colormap new
    wm geom .t +0+0
    frame .t.f -width 100 -height 100 -colormap new -relief sunken -bd 2
    pack .t.f
d1616 19
a1634 6
    wm colormapwindows .t .t.f
    frame .t.f2 -width 100 -height 100 -colormap new -relief sunken -bd 2
    pack .t.f2
    update
    wm colormapwindows .t
} {.t.f}
a1635 25
test wm-19.1 {TkWmRemoveFromColormapWindows procedure} {
    catch {destroy .t}
    toplevel .t -colormap new
    wm geom .t +0+0
    frame .t.f -width 100 -height 100 -colormap new -relief sunken -bd 2
    pack .t.f
    frame .t.f2 -width 100 -height 100 -colormap new -relief sunken -bd 2
    pack .t.f2
    update
    destroy .t.f2
    wm colormap .t
} {.t.f .t}
test wm-19.2 {TkWmRemoveFromColormapWindows procedure} {
    catch {destroy .t}
    toplevel .t -colormap new
    wm geom .t +0+0
    frame .t.f -width 100 -height 100 -colormap new -relief sunken -bd 2
    pack .t.f
    frame .t.f2 -width 100 -height 100 -colormap new -relief sunken -bd 2
    pack .t.f2
    update
    wm colormapwindows .t .t.f2
    destroy .t.f2
    wm colormap .t
} {}
a1636 2
catch {destroy .t}
concat {}
@


1.4
log
@touched all sources to ease next import
@
text
@@


1.3
log
@        From Mo DeJong  <supermo@@bayarea.net>
        * generic/tkText.c (ExecSyncCmd):
        Remove -synccommand option from Tk text widget.
        This local modification was used by an very old
        version of Source-Navigator, but is no longer
        needed. Remove ExecSyncCmd function.
        * generic/tkText.h (TkText): Remove SyncCmd member.
        * library/msgbox.tcl (tkMessageBox): Remove unused
        -modal option. This was a local mod to tk.
        * tests/text.test: Add default value for -tabsize.
        This is a local mod to tk.
        * tests/wm.test: Fixup iconwindow error messages.
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@d278 1
a278 1
} {1 {can't iconify .icon: it is an icon for .icon}}
d287 1
a287 1
} {1 {can't deiconify .icon: it is an icon for .icon}}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Tk 8.3 upgrade
@
text
@@


1.1.1.2
log
@import tk 8.4.0
@
text
@d6 1
a6 3
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
d8 4
a11 1
# RCS: @@(#) $Id$
d13 2
a14 14
# This file tests window manager interactions that work across
# platforms. Window manager tests that only work on a specific
# platform should be placed in unixWm.test or winWm.test.

package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands

wm deiconify .
if {![winfo ismapped .]} {
    tkwait visibility .
d17 4
a20 5
proc stdWindow {} {
    destroy .t
    toplevel .t -width 100 -height 50
    wm geom .t +0+0
    update
d23 11
a33 4
# [raise] and [lower] may return before the window manager
# has completed the operation.  The raiseDelay procedure
# idles for a while to give the operation a chance to complete.
#
d35 24
a58 2
proc raiseDelay {} {
    after 100; update
d61 14
d76 12
a87 2
deleteWindows
stdWindow
d89 13
a101 139
test wm-1.1 {Tk_WmObjCmd procedure, miscellaneous errors} {
    list [catch {wm} msg] $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-1.2 {Tk_WmObjCmd procedure, miscellaneous errors} {
    list [catch {wm foo} msg] $msg
} {1 {bad option "foo": must be aspect, attributes, client, colormapwindows, command, deiconify, focusmodel, frame, geometry, grid, group, iconbitmap, iconify, iconmask, iconname, iconposition, iconwindow, maxsize, minsize, overrideredirect, positionfrom, protocol, resizable, sizefrom, stackorder, state, title, transient, or withdraw}}

test wm-1.3 {Tk_WmObjCmd procedure, miscellaneous errors} {
    list [catch {wm command} msg] $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-1.4 {Tk_WmObjCmd procedure, miscellaneous errors} {
    list [catch {wm aspect bogus} msg] $msg
} {1 {bad window path name "bogus"}}

test wm-1.5 {Tk_WmObjCmd procedure, miscellaneous errors} {
    catch {destroy .b}
    button .b -text hello
    list [catch {wm geometry .b} msg] $msg
} {1 {window ".b" isn't a top-level window}}


test wm-aspect-1.1 {usage} {
    list [catch {wm aspect} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-aspect-1.2 {usage} {
    list [catch {wm aspect . _} err] $err
} {1 {wrong # args: should be "wm aspect window ?minNumer minDenom maxNumer maxDenom?"}}

test wm-aspect-1.3 {usage} {
    list [catch {wm aspect . _ _ _} err] $err
} {1 {wrong # args: should be "wm aspect window ?minNumer minDenom maxNumer maxDenom?"}}

test wm-aspect-1.4 {usage} {
    list [catch {wm aspect . _ _ _ _ _} err] $err
} {1 {wrong # args: should be "wm aspect window ?minNumer minDenom maxNumer maxDenom?"}}

test wm-aspect-1.5 {usage} {
    list [catch {wm aspect . bad 14 15 16} msg] $msg
} {1 {expected integer but got "bad"}}

test wm-aspect-1.6 {usage} {
    list [catch {wm aspect . 13 foo 15 16} msg] $msg
} {1 {expected integer but got "foo"}}

test wm-aspect-1.7 {usage} {
    list [catch {wm aspect . 13 14 bar 16} msg] $msg
} {1 {expected integer but got "bar"}}

test wm-aspect-1.8 {usage} {
    list [catch {wm aspect . 13 14 15 baz} msg] $msg
} {1 {expected integer but got "baz"}}

test wm-aspect-1.9 {usage} {
    list [catch {wm aspect . 0 14 15 16} msg] $msg
} {1 {aspect number can't be <= 0}}

test wm-aspect-1.10 {usage} {
    list [catch {wm aspect . 13 0 15 16} msg] $msg
} {1 {aspect number can't be <= 0}}

test wm-aspect-1.11 {usage} {
    list [catch {wm aspect . 13 14 0 16} msg] $msg
} {1 {aspect number can't be <= 0}}

test wm-aspect-1.12 {usage} {
    list [catch {wm aspect . 13 14 15 0} msg] $msg
} {1 {aspect number can't be <= 0}}

test wm-aspect-2.1 {setting and reading values} {
    set result {}
    lappend result [wm aspect .t]
    wm aspect .t 3 4 10 2
    lappend result [wm aspect .t]
    wm aspect .t {} {} {} {}
    lappend result [wm aspect .t]
} [list {} {3 4 10 2} {}]


test wm-attributes-1.1 {usage} {
    list [catch {wm attributes} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-attributes-1.2.1 {usage} {pcOnly} {
    list [catch {wm attributes . _} err] $err
} {1 {wrong # args: should be "wm attributes window ?-disabled ?bool?? ?-toolwindow ?bool?? ?-topmost ?bool??"}}

test wm-attributes-1.2.2 {usage} {macOrUnix} {
    list [catch {wm attributes . _} err] $err
} {1 {wrong # args: should be "wm attributes window"}}


test wm-client-1.1 {usage} {
    list [catch {wm client} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-client-1.2 {usage} {
    list [catch {wm client . _ _} err] $err
} {1 {wrong # args: should be "wm client window ?name?"}}

test wm-client-2.1 {setting and reading values} {
    set result {}
    lappend result [wm client .t]
    wm client .t Miffo
    lappend result [wm client .t]
    wm client .t {}
    lappend result [wm client .t]
} [list {} Miffo {}]


test wm-colormapwindows-1.1 {usage} {
    list [catch {wm colormapwindows} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-colormapwindows-1.2 {usage} {
    list [catch {wm colormapwindows . _ _} err] $err
} {1 {wrong # args: should be "wm colormapwindows window ?windowList?"}}

test wm-colormapwindows-1.3 {usage} {
    list [catch {wm colormapwindows . "a \{"} msg] $msg
} {1 {unmatched open brace in list}}

test wm-colormapwindows-1.4 {usage} {
    list [catch {wm colormapwindows . foo} msg] $msg
} {1 {bad window path name "foo"}}

test wm-colormapwindows-2.1 {reading values} {
    catch {destroy .t2}
    toplevel .t2 -width 200 -height 200 -colormap new
    wm geom .t2 +0+0
    frame .t2.a -width 100 -height 30
    frame .t2.b -width 100 -height 30 -colormap new
    pack .t2.a .t2.b -side top
    update
    set x [wm colormapwindows .t2]
    frame .t2.c -width 100 -height 30 -colormap new
    pack .t2.c -side top
d103 1
a103 72
    list $x [wm colormapwindows .t2]
} {{.t2.b .t2} {.t2.b .t2.c .t2}}

test wm-colormapwindows-2.2 {setting and reading values} {
    catch {destroy .t2}
    toplevel .t2 -width 200 -height 200
    wm geom .t2 +0+0
    frame .t2.a -width 100 -height 30
    frame .t2.b -width 100 -height 30
    frame .t2.c -width 100 -height 30
    pack .t2.a .t2.b .t2.c -side top
    wm colormapwindows .t2 {.t2.b .t2.a}
    wm colormapwindows .t2
} {.t2.b .t2.a}


test wm-command-1.1 {usage} {
    list [catch {wm command} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-command-1.2 {usage} {
    list [catch {wm command . _ _} err] $err
} {1 {wrong # args: should be "wm command window ?value?"}}

test wm-command-1.3 {usage} {
    list [catch {wm command . "a \{"} msg] $msg
} {1 {unmatched open brace in list}}

test wm-command-2.1 {setting and reading values} {
    set result {}
    lappend result [wm command .t]
    wm command .t [list Miffo Foo]
    lappend result [wm command .t]
    wm command .t {}
    lappend result [wm command .t]
} [list {} [list Miffo Foo] {}]


test wm-deiconify-1.1 {usage} {
    list [catch {wm deiconify} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-deiconify-1.2 {usage} {
    list [catch {wm deiconify . _} err] $err
} {1 {wrong # args: should be "wm deiconify window"}}

test wm-deiconify-1.3 {usage} {
    list [catch {wm deiconify _} err] $err
} {1 {bad window path name "_"}}

test wm-deiconify-1.4 {usage} {
    catch {destroy .icon}
    toplevel .icon -width 50 -height 50 -bg red
    wm iconwindow .t .icon
    set result [list [catch {wm deiconify .icon} msg] $msg]
    destroy .icon
    set result
} {1 {can't deiconify .icon: it is an icon for .t}}

test wm-deiconify-1.5 {usage} {
    catch {destroy .embed}
    frame .t.f -container 1
    toplevel .embed -use [winfo id .t.f]
    set result [list [catch {wm deiconify .embed} msg] $msg]
    destroy .t.f .embed
    set result
} {1 {can't deiconify .embed: it is an embedded window}}

test wm-deiconify-2.1 {a window that has never been mapped
        should not be mapped by a call to deiconify} {
    deleteWindows
    toplevel .t
a104 8
    winfo ismapped .t
} 0

test wm-deiconify-2.2 {a window that has already been
        mapped should be mapped by deiconify} {
    deleteWindows
    toplevel .t
    update idletasks
d106 8
d115 1
a115 10
    winfo ismapped .t
} 1

test wm-deiconify-2.3 {geometry for an unmapped window
        should not be calculated by a call to deiconify,
        it should be done at idle time} {
    deleteWindows
    set results {}
    toplevel .t -width 200 -height 200
    lappend results [wm geometry .t]
d117 8
a124 12
    lappend results [wm geometry .t]
    update idletasks
    lappend results [lindex [split \
        [wm geometry .t] +] 0]
} {1x1+0+0 1x1+0+0 200x200}

test wm-deiconify-2.4 {invoking destroy after a deiconify
        should not result in a crash because of a callback
        set on the toplevel} {
    deleteWindows
    toplevel .t
    wm withdraw .t
d126 7
a132 1
    destroy .t
d134 8
a141 52
} {}


test wm-focusmodel-1.1 {usage} {
    list [catch {wm focusmodel} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-focusmodel-1.2 {usage} {
    list [catch {wm focusmodel . _ _} err] $err
} {1 {wrong # args: should be "wm focusmodel window ?active|passive?"}}

test wm-focusmodel-1.3 {usage} {
    list [catch {wm focusmodel . bogus} msg] $msg
} {1 {bad argument "bogus": must be active or passive}}

stdWindow

test wm-focusmodel-2.1 {setting and reading values} {
    set result {} 
    lappend result [wm focusmodel .t]
    wm focusmodel .t active
    lappend result [wm focusmodel .t]
    wm focusmodel .t passive
    lappend result [wm focusmodel .t]
    set result
} {passive active passive}


test wm-frame-1.1 {usage} {
    list [catch {wm frame} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-frame-1.2 {usage} {
    list [catch {wm frame . _} err] $err
} {1 {wrong # args: should be "wm frame window"}}


test wm-geometry-1.1 {usage} {
    list [catch {wm geometry} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-geometry-1.2 {usage} {
    list [catch {wm geometry . _ _} err] $err
} {1 {wrong # args: should be "wm geometry window ?newGeometry?"}}

test wm-geometry-1.3 {usage} {
    list [catch {wm geometry . bogus} msg] $msg
} {1 {bad geometry specifier "bogus"}}

test wm-geometry-2.1 {setting values} {
    set result {}
    wm geometry .t 150x150+50+50
d143 9
a151 2
    lappend result [wm geometry .t]
    wm geometry .t {}
d153 4
a156 2
    lappend result [string equal [wm geometry .t] "150x150+50+50"]
} [list 150x150+50+50 0]
d158 45
d204 19
a222 3
test wm-grid-1.1 {usage} {
    list [catch {wm grid} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}
d224 9
a232 52
test wm-grid-1.2 {usage} {
    list [catch {wm grid . _} err] $err
} {1 {wrong # args: should be "wm grid window ?baseWidth baseHeight widthInc heightInc?"}}

test wm-grid-1.3 {usage} {
    list [catch {wm grid . _ _ _} err] $err
} {1 {wrong # args: should be "wm grid window ?baseWidth baseHeight widthInc heightInc?"}}

test wm-grid-1.4 {usage} {
    list [catch {wm grid . _ _ _ _ _} err] $err
} {1 {wrong # args: should be "wm grid window ?baseWidth baseHeight widthInc heightInc?"}}

test wm-grid-1.5 {usage} {
    list [catch {wm grid . bad 14 15 16} msg] $msg
} {1 {expected integer but got "bad"}}

test wm-grid-1.6 {usage} {
    list [catch {wm grid . 13 foo 15 16} msg] $msg
} {1 {expected integer but got "foo"}}

test wm-grid-1.7 {usage} {
    list [catch {wm grid . 13 14 bar 16} msg] $msg
} {1 {expected integer but got "bar"}}

test wm-grid-1.8 {usage} {
    list [catch {wm grid . 13 14 15 baz} msg] $msg
} {1 {expected integer but got "baz"}}

test wm-grid-1.9 {usage} {
    list [catch {wm grid . -1 14 15 16} msg] $msg
} {1 {baseWidth can't be < 0}}

test wm-grid-1.10 {usage} {
    list [catch {wm grid . 13 -1 15 16} msg] $msg
} {1 {baseHeight can't be < 0}}

test wm-grid-1.11 {usage} {
    list [catch {wm grid . 13 14 -1 16} msg] $msg
} {1 {widthInc can't be < 0}}

test wm-grid-1.12 {usage} {
    list [catch {wm grid . 13 14 15 -1} msg] $msg
} {1 {heightInc can't be < 0}}

test wm-grid-2.1 {setting and reading values} {
    set result {}
    lappend result [wm grid .t]
    wm grid .t 3 4 10 2
    lappend result [wm grid .t]
    wm grid .t {} {} {} {}
    lappend result [wm grid .t]
} [list {} {3 4 10 2} {}]
d234 15
d250 19
a268 3
test wm-group-1.1 {usage} {
    list [catch {wm group} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}
d270 48
a317 98
test wm-group-1.2 {usage} {
    list [catch {wm group .t 12 13} msg] $msg
} {1 {wrong # args: should be "wm group window ?pathName?"}}

test wm-group-1.3 {usage} {
    list [catch {wm group .t bogus} msg] $msg
} {1 {bad window path name "bogus"}}

test wm-group-2.1 {setting and reading values} {
    set result {}
    lappend result [wm group .t]
    wm group .t .
    lappend result [wm group .t]
    wm group .t {}
    lappend result [wm group .t]
} [list {} . {}]


test wm-iconbitmap-1.1 {usage} {
    list [catch {wm iconbitmap} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-iconbitmap-1.2.1 {usage} {macOrUnix} {
    list [catch {wm iconbitmap .t 12 13} msg] $msg
} {1 {wrong # args: should be "wm iconbitmap window ?bitmap?"}}

test wm-iconbitmap-1.2.2 {usage} {pcOnly} {
    list [catch {wm iconbitmap .t 12 13 14} msg] $msg
} {1 {wrong # args: should be "wm iconbitmap window ?-default? ?image?"}}

test wm-iconbitmap-1.3 {usage} {pcOnly} {
    list [catch {wm iconbitmap .t 12 13} msg] $msg
} {1 {illegal option "12" must be "-default"}}

test wm-iconbitmap-1.4 {usage} {
    list [catch {wm iconbitmap .t bad-bitmap} msg] $msg
} {1 {bitmap "bad-bitmap" not defined}}

test wm-iconbitmap-2.1 {setting and reading values} {
    set result {}
    lappend result [wm iconbitmap .t]
    wm iconbitmap .t hourglass
    lappend result [wm iconbitmap .t]
    wm iconbitmap .t {}
    lappend result [wm iconbitmap .t]
} [list {} hourglass {}]


test wm-iconify-1.1 {usage} {
    list [catch {wm iconify} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-iconify-1.2 {usage} {
    list [catch {wm iconify .t _} msg] $msg
} {1 {wrong # args: should be "wm iconify window"}}

test wm-iconify-2.1 {Misc errors} {
    catch {destroy .t2}
    toplevel .t2
    wm overrideredirect .t2 1
    set result [list [catch {wm iconify .t2} msg] $msg]
    destroy .t2
    set result
} {1 {can't iconify ".t2": override-redirect flag is set}}

test wm-iconify-2.2 {Misc errors} {
    catch {destroy .t2}
    toplevel .t2
    wm geom .t2 +0+0
    wm transient .t2 .t
    set result [list [catch {wm iconify .t2} msg] $msg]
    destroy .t2
    set result
} {1 {can't iconify ".t2": it is a transient}}

test wm-iconify-2.3 {Misc errors} {
    catch {destroy .t2}
    toplevel .t2
    wm geom .t2 +0+0
    wm iconwindow .t .t2
    set result [list [catch {wm iconify .t2} msg] $msg]
    destroy .t2
    set result
} {1 {can't iconify .t2: it is an icon for .t}}

test wm-iconify-2.4 {Misc errors} {
    catch {destroy .t2}
    frame .t.f -container 1
    toplevel .t2 -use [winfo id .t.f]
    set result [list [catch {wm iconify .t2} msg] $msg]
    destroy .t2 .r.f
    set result
} {1 {can't iconify .t2: it is an embedded window}}

test wm-iconify-3.1 {} {
    catch {destroy .t2}
    toplevel .t2
    wm geom .t2 -0+0
d319 2
a320 2
    set result [winfo ismapped .t2]
    wm iconify .t2
d322 15
a336 97
    lappend result [winfo ismapped .t2]
    destroy .t2
    set result
} {1 0}


test wm-iconmask-1.1 {usage} {
    list [catch {wm iconmask} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-iconmask-1.2 {usage} {
    list [catch {wm iconmask .t 12 13} msg] $msg
} {1 {wrong # args: should be "wm iconmask window ?bitmap?"}}

test wm-iconmask-1.3 {usage} {
    list [catch {wm iconmask .t bad-bitmap} msg] $msg
} {1 {bitmap "bad-bitmap" not defined}}

test wm-iconmask-2.1 {setting and reading values} {
    set result {}
    lappend result [wm iconmask .t]
    wm iconmask .t hourglass
    lappend result [wm iconmask .t]
    wm iconmask .t {}
    lappend result [wm iconmask .t]
} [list {} hourglass {}]


test wm-iconname-1.1 {usage} {
    list [catch {wm iconname} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-iconname-1.2 {usage} {
    list [catch {wm iconname .t 12 13} msg] $msg
} {1 {wrong # args: should be "wm iconname window ?newName?"}}

test wm-iconname-2.1 {setting and reading values} {
    set result {}
    lappend result [wm iconname .t]
    wm iconname .t ThisIconHasAName
    lappend result [wm iconname .t]
    wm iconname .t {}
    lappend result [wm iconname .t]
} [list {} ThisIconHasAName {}]


test wm-iconposition-1.1 {usage} {
    list [catch {wm iconposition} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-iconposition-1.2 {usage} {
    list [catch {wm iconposition .t 12} msg] $msg
} {1 {wrong # args: should be "wm iconposition window ?x y?"}}

test wm-iconposition-1.3 {usage} {
    list [catch {wm iconposition .t 12 13 14} msg] $msg
} {1 {wrong # args: should be "wm iconposition window ?x y?"}}

test wm-iconposition-1.4 {usage} {
    list [catch {wm iconposition .t bad 13} msg] $msg
} {1 {expected integer but got "bad"}}

test wm-iconposition-1.5 {usage} {
    list [catch {wm iconposition .t 13 lousy} msg] $msg
} {1 {expected integer but got "lousy"}}

test wm-iconposition-2.1 {setting and reading values} {
    set result {}
    lappend result [wm iconposition .t]
    wm iconposition .t 10 20
    lappend result [wm iconposition .t]
    wm iconposition .t {} {}
    lappend result [wm iconposition .t]
} [list {} {10 20} {}]


test wm-iconwindow-1.1 {usage} {
    list [catch {wm iconwindow} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-iconwindow-1.2 {usage} {
    list [catch {wm iconwindow .t 12 13} msg] $msg
} {1 {wrong # args: should be "wm iconwindow window ?pathName?"}}

test wm-iconwindow-1.3 {usage} {
    list [catch {wm iconwindow .t bogus} msg] $msg
} {1 {bad window path name "bogus"}}

test wm-iconwindow-1.4 {usage} {
    catch {destroy .b}
    button .b -text Help
    set result [list [catch {wm iconwindow .t .b} msg] $msg]
    destroy .b
    set result
} {1 {can't use .b as icon window: not at top level}}

test wm-iconwindow-1.5 {usage} {
d338 12
a349 14
    toplevel .icon -width 50 -height 50 -bg green
    catch {destroy .t2}
    toplevel .t2
    wm geom .t2 -0+0
    wm iconwindow .t2 .icon
    set result [list [catch {wm iconwindow .t .icon} msg] $msg]
    destroy .t2
    destroy .icon
    set result
} {1 {.icon is already an icon for .t2}}

test wm-iconwindow-2.1 {setting and reading values} {
    set result {}
    lappend result [wm iconwindow .t]
d351 6
a356 1
    toplevel .icon -width 50 -height 50 -bg green
d358 7
a364 5
    lappend result [wm iconwindow .t]
    wm iconwindow .t {}
    destroy .icon
    lappend result [wm iconwindow .t]
} [list {} .icon {}]
d366 16
d383 61
a443 1
test wm-maxsize-1.1 {usage} {
d446 1
a446 2

test wm-maxsize-1.2 {usage} {
d448 2
a449 3
} {1 {wrong # args: should be "wm maxsize window ?width height?"}}

test wm-maxsize-1.3 {usage} {
d451 5
a455 3
} {1 {wrong # args: should be "wm maxsize window ?width height?"}}

test wm-maxsize-1.4 {usage} {
d458 1
a458 2

test wm-maxsize-1.5 {usage} {
d461 7
d469 4
a472 7
test wm-maxsize-1.6 {usage} {
    catch {destroy .t2}
    toplevel .t2
    wm maxsize .t2 200 150
    set result [wm maxsize .t2]
    destroy .t2
    set result
d474 1
d476 4
a479 2

test wm-minsize-1.1 {usage} {
d482 1
a482 2

test wm-minsize-1.2 {usage} {
d484 2
a485 3
} {1 {wrong # args: should be "wm minsize window ?width height?"}}

test wm-minsize-1.3 {usage} {
d487 5
a491 3
} {1 {wrong # args: should be "wm minsize window ?width height?"}}

test wm-minsize-1.4 {usage} {
d494 1
a494 2

test wm-minsize-1.5 {usage} {
d497 3
a499 8

test wm-minsize-1.6 {usage} {
    catch {destroy .t2}
    toplevel .t2
    wm minsize .t2 200 150
    set result [wm minsize .t2]
    destroy .t2
    set result
d501 25
a525 37


test wm-overrideredirect-1.1 {usage} {
    list [catch {wm overrideredirect} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-overrideredirect-1.2 {usage} {
    list [catch {wm overrideredirect .t 1 2} msg]  $msg
} {1 {wrong # args: should be "wm overrideredirect window ?boolean?"}}

test wm-overrideredirect-1.3 {usage} {
    list [catch {wm overrideredirect .t boo} msg]  $msg
} {1 {expected boolean value but got "boo"}}

test wm-overrideredirect-2.1 {setting and reading values} {
    set result {}
    lappend result [wm overrideredirect .t]
    wm overrideredirect .t true
    lappend result [wm overrideredirect .t]
    wm overrideredirect .t off
    lappend result [wm overrideredirect .t]
} {0 1 0}


test wm-positionfrom-1.1 {usage} {
    list [catch {wm positionfrom} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-positionfrom-1.2 {usage} {
    list [catch {wm positionfrom .t 1 2} msg]  $msg
} {1 {wrong # args: should be "wm positionfrom window ?user/program?"}}

test wm-positionfrom-1.3 {usage} {
    list [catch {wm positionfrom .t none} msg]  $msg
} {1 {bad argument "none": must be program or user}}

test wm-positionfrom-2.1 {setting and reading values} {
d527 12
a538 52
    toplevel .t2
    set result {}
    wm positionfrom .t user
    lappend result [wm positionfrom .t]
    wm positionfrom .t program
    lappend result [wm positionfrom .t]
    wm positionfrom .t {}
    lappend result [wm positionfrom .t]
    destroy .t2
    set result
} {user program {}}


test wm-protocol-1.1 {usage} {
    list [catch {wm protocol} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-protocol-1.2 {usage} {
    list [catch {wm protocol .t 1 2 3} msg]  $msg
} {1 {wrong # args: should be "wm protocol window ?name? ?command?"}}

test wm-protocol-2.1 {setting and reading values} {
    wm protocol .t {foo a} {a b c}
    wm protocol .t bar {test script for bar}
    set result [wm protocol .t]
    wm protocol .t {foo a} {}
    wm protocol .t bar {}
    set result
} {bar {foo a}}

test wm-protocol-2.2 {setting and reading values} {
    set result {}
    wm protocol .t foo {a b c}
    wm protocol .t bar {test script for bar}
    lappend result [wm protocol .t foo] [wm protocol .t bar]
    wm protocol .t foo {}
    wm protocol .t bar {}
    lappend result [wm protocol .t foo] [wm protocol .t bar]
} {{a b c} {test script for bar} {} {}}

test wm-protocol-2.3 {setting and reading values} {
    wm protocol .t foo {a b c}
    wm protocol .t foo {test script}
    set result [wm protocol .t foo]
    wm protocol .t foo {}
    set result
} {test script}


test wm-resizable-1.1 {usage} {
    list [catch {wm resizable} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}
d540 2
a541 75
test wm-resizable-1.2 {usage} {
    list [catch {wm resizable .t 1} msg]  $msg
} {1 {wrong # args: should be "wm resizable window ?width height?"}}

test wm-resizable-1.3 {usage} {
    list [catch {wm resizable .t 1 2 3} msg]  $msg
} {1 {wrong # args: should be "wm resizable window ?width height?"}}

test wm-resizable-1.4 {usage} {
    list [catch {wm resizable .t bad 0} msg]  $msg
} {1 {expected boolean value but got "bad"}}

test wm-resizable-1.5 {usage} {
    list [catch {wm resizable .t 1 bad} msg]  $msg
} {1 {expected boolean value but got "bad"}}

test wm-resizable-2.1 {setting and reading values} {
    wm resizable .t 0 1
    set result [wm resizable .t]
    wm resizable .t 1 0
    lappend result [wm resizable .t]
    wm resizable .t 1 1
    lappend result [wm resizable .t]
} {0 1 {1 0} {1 1}}


test wm-sizefrom-1.1 {usage} {
    list [catch {wm sizefrom} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-sizefrom-1.2 {usage} {
    list [catch {wm sizefrom .t 1 2} msg]  $msg
} {1 {wrong # args: should be "wm sizefrom window ?user|program?"}}

test wm-sizefrom-1.4 {usage} {
    list [catch {wm sizefrom .t bad} msg]  $msg
} {1 {bad argument "bad": must be program or user}}

test wm-sizefrom-2.1 {setting and reading values} {
    set result [list [wm sizefrom .t]]
    wm sizefrom .t user
    lappend result [wm sizefrom .t]
    wm sizefrom .t program
    lappend result [wm sizefrom .t]
    wm sizefrom .t {}
    lappend result [wm sizefrom .t]
} {{} user program {}}



test wm-stackorder-1.1 {usage} {
    list [catch {wm stackorder} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-stackorder-1.2 {usage} {
    list [catch {wm stackorder . _} err] $err
} {1 {wrong # args: should be "wm stackorder window ?isabove|isbelow window?"}}

test wm-stackorder-1.3 {usage} {
    list [catch {wm stackorder . _ _ _} err] $err
} {1 {wrong # args: should be "wm stackorder window ?isabove|isbelow window?"}}

test wm-stackorder-1.4 {usage} {
    list [catch {wm stackorder . is .} err] $err
} {1 {ambiguous argument "is": must be isabove or isbelow}}

test wm-stackorder-1.5 {usage} {
    list [catch {wm stackorder _} err] $err
} {1 {bad window path name "_"}}

test wm-stackorder-1.6 {usage} {
    list [catch {wm stackorder . isabove _} err] $err
} {1 {bad window path name "_"}}

test wm-stackorder-1.7 {usage} {
d543 4
a546 10
    toplevel .t
    button .t.b
    list [catch {wm stackorder .t.b} err] $err
} {1 {window ".t.b" isn't a top-level window}}

test wm-stackorder-1.8 {usage} {
    catch {destroy .t}
    toplevel .t
    button .t.b
    pack .t.b
d548 3
a550 8
    list [catch {wm stackorder . isabove .t.b} err] $err
} {1 {window ".t.b" isn't a top-level window}}

test wm-stackorder-1.9 {usage} {
    catch {destroy .t}
    toplevel .t
    button .t.b
    pack .t.b
d552 3
a554 118
    list [catch {wm stackorder . isbelow .t.b} err] $err
} {1 {window ".t.b" isn't a top-level window}}

test wm-stackorder-1.10 {usage, isabove|isbelow toplevels must be mapped} {
    catch {destroy .t}
    toplevel .t ; update
    wm withdraw .t
    list [catch {wm stackorder .t isabove .} err] $err
} {1 {window ".t" isn't mapped}}

test wm-stackorder-1.11 {usage, isabove|isbelow toplevels must be mapped} {
    catch {destroy .t}
    toplevel .t ; update
    wm withdraw .t
    list [catch {wm stackorder . isbelow .t} err] $err
} {1 {window ".t" isn't mapped}}


deleteWindows


test wm-stackorder-2.1 {} {
    catch {destroy .t}
    toplevel .t ; update
    wm stackorder .
} {. .t}

test wm-stackorder-2.2 {} {
    catch {destroy .t}
    toplevel .t ; update
    raise .
    raiseDelay
    wm stackorder .
} {.t .}

test wm-stackorder-2.3 {} {
    catch {destroy .t}
    toplevel .t ; update
    catch {destroy .t2}
    toplevel .t2 ; update
    raise .
    raise .t2
    raiseDelay
    wm stackorder .
} {.t . .t2}

test wm-stackorder-2.4 {} {
    catch {destroy .t}
    toplevel .t ; update
    catch {destroy .t2}
    toplevel .t2 ; update
    raise .
    lower .t2
    raiseDelay
    wm stackorder .
} {.t2 .t .}

test wm-stackorder-2.5 {} {
    catch {destroy .parent}
    toplevel .parent ; update
    catch {destroy .parent.child1}
    toplevel .parent.child1 ; update
    catch {destroy .parent.child2}
    toplevel .parent.child2 ; update
    catch {destroy .extra}
    toplevel .extra ; update
    raise .parent
    lower .parent.child2
    raiseDelay
    wm stackorder .parent
} {.parent.child2 .parent.child1 .parent}

deleteWindows

test wm-stackorder-2.6 {non-toplevel widgets ignored} {
    catch {destroy .t1}
    toplevel .t1
    button .t1.b
    pack .t1.b
    update
    wm stackorder .
} {. .t1}

deleteWindows

test wm-stackorder-2.7 {no children returns self} {
    wm stackorder .
} {.}

deleteWindows


test wm-stackorder-3.1 {unmapped toplevel} {
    catch {destroy .t1}
    toplevel .t1 ; update
    catch {destroy .t2}
    toplevel .t2 ; update
    wm iconify .t1
    wm stackorder .
} {. .t2}

test wm-stackorder-3.2 {unmapped toplevel} {
    catch {destroy .t1}
    toplevel .t1 ; update
    catch {destroy .t2}
    toplevel .t2 ; update
    wm withdraw .t2
    wm stackorder .
} {. .t1}

test wm-stackorder-3.3 {unmapped toplevel} {
    catch {destroy .t1}
    toplevel .t1 ; update
    catch {destroy .t2}
    toplevel .t2 ; update
    wm withdraw .t2
    wm stackorder .t2
} {}
d556 1
a556 76
test wm-stackorder-3.4 {unmapped toplevel} {
    catch {destroy .t1}
    toplevel .t1 ; update
    toplevel .t1.t2 ; update
    wm withdraw .t1.t2
    wm stackorder .t1
} {.t1}

test wm-stackorder-3.5 {unmapped toplevel} {
    catch {destroy .t1}
    toplevel .t1 ; update
    toplevel .t1.t2 ; update
    wm withdraw .t1
    wm stackorder .t1
} {.t1.t2}

test wm-stackorder-3.6 {unmapped toplevel} {
    catch {destroy .t1}
    toplevel .t1 ; update
    toplevel .t1.t2 ; update
    toplevel .t1.t2.t3 ; update
    wm withdraw .t1.t2
    wm stackorder .t1
} {.t1 .t1.t2.t3}

test wm-stackorder-3.7 {unmapped toplevel, mapped children returned} {
    catch {destroy .t1}
    toplevel .t1 ; update
    toplevel .t1.t2 ; update
    wm withdraw .t1
    wm stackorder .t1
} {.t1.t2}

test wm-stackorder-3.8 {toplevel mapped in idle callback } {
    catch {destroy .t1}
    toplevel .t1
    wm stackorder .
} {.}


deleteWindows


test wm-stackorder-4.1 {wm stackorder isabove|isbelow} {
    catch {destroy .t}
    toplevel .t ; update
    raise .t
    wm stackorder . isabove .t
} {0}

test wm-stackorder-4.2 {wm stackorder isabove|isbelow} {
    catch {destroy .t}
    toplevel .t ; update
    raise .t
    wm stackorder . isbelow .t
} {1}

test wm-stackorder-4.3 {wm stackorder isabove|isbelow} {
    catch {destroy .t}
    toplevel .t ; update
    raise .
    raiseDelay
    wm stackorder .t isa .
} {0}

test wm-stackorder-4.4 {wm stackorder isabove|isbelow} {
    catch {destroy .t}
    toplevel .t ; update
    raise .
    raiseDelay
    wm stackorder .t isb .
} {1}

deleteWindows

test wm-stackorder-5.1 {a menu is not a toplevel} {
d559 3
a561 15
    menu .t.m -type menubar
    .t.m add cascade -label "File"
    .t configure -menu .t.m
    update
    raise .
    raiseDelay
    wm stackorder .
} {.t .}

test wm-stackorder-5.2 {A normal toplevel can't be
        raised above an overrideredirect toplevel } {
    catch {destroy .t}
    toplevel .t
    wm overrideredirect .t 1
    raise .
d563 3
a565 6
    raiseDelay
    wm stackorder . isabove .t
} 0

test wm-stackorder-5.3 {An overrideredirect window
        can be explicitly lowered } {
d568 3
a570 2
    wm overrideredirect .t 1
    lower .t
d572 1
a572 9
    raiseDelay
    wm stackorder .t isbelow .
} 1

test wm-stackorder-6.1 {An embedded toplevel does not
        appear in the stacking order} {
    deleteWindows
    toplevel .real -container 1
    toplevel .embd -bg blue -use [winfo id .real]
d574 2
a575 2
    wm stackorder .
} {. .real}
d577 4
a580 211
stdWindow

test wm-title-1.1 {usage} {
    list [catch {wm title} msg]  $msg
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-title-1.2 {usage} {
    list [catch {wm title . 1 2} msg]  $msg
} {1 {wrong # args: should be "wm title window ?newTitle?"}}

test wm-title-2.1 {setting and reading values} {
    destroy .t
    toplevel .t
    set result [wm title .t]
    wm title .t Apa
    lappend result [wm title .t]
    wm title .t {}
    lappend result [wm title .t]
} {t Apa {}}


test wm-transient-1.1 {usage} {
    catch {destroy .t} ; toplevel .t
    list [catch {wm transient .t 1 2} msg]  $msg
} {1 {wrong # args: should be "wm transient window ?master?"}}

test wm-transient-1.2 {usage} {
    catch {destroy .t} ; toplevel .t
    list [catch {wm transient .t foo} msg]  $msg
} {1 {bad window path name "foo"}}

test wm-transient-1.3 {usage} {
    catch {destroy .t} ; toplevel .t
    list [catch {wm transient foo .t} msg]  $msg
} {1 {bad window path name "foo"}}

test wm-transient-1.4 {usage} {
    deleteWindows
    toplevel .master
    toplevel .subject
    wm transient .subject .master
    list [catch {wm iconify .subject} msg] $msg
} {1 {can't iconify ".subject": it is a transient}}

test wm-transient-1.5 {usage} {
    deleteWindows
    toplevel .icon -bg blue
    toplevel .top
    wm iconwindow .top .icon
    toplevel .dummy
    list [catch {wm transient .icon .dummy} msg] $msg
} {1 {can't make ".icon" a transient: it is an icon for .top}}

test wm-transient-1.6 {usage} {
    deleteWindows
    toplevel .icon -bg blue
    toplevel .top
    wm iconwindow .top .icon
    toplevel .dummy
    list [catch {wm transient .dummy .icon} msg] $msg
} {1 {can't make ".icon" a master: it is an icon for .top}}

test wm-transient-1.7 {usage} {
    deleteWindows
    toplevel .master
    list [catch {wm transient .master .master} err] $err
} {1 {can't make ".master" its own master}}

test wm-transient-1.8 {usage} {
    deleteWindows
    toplevel .master
    frame .master.f
    list [catch {wm transient .master .master.f} err] $err
} {1 {can't make ".master" its own master}}

test wm-transient-2.1 { basic get/set of master } {
    deleteWindows
    set results [list]    
    toplevel .master
    toplevel .subject
    lappend results [wm transient .subject]
    wm transient .subject .master
    lappend results [wm transient .subject]
    wm transient .subject {}
    lappend results [wm transient .subject]
    set results
} {{} .master {}}

test wm-transient-2.2 { first toplevel parent of
        non-toplevel master is used } {
    deleteWindows
    toplevel .master
    frame .master.f
    toplevel .subject
    wm transient .subject .master.f
    wm transient .subject
} {.master}

test wm-transient-3.1 { transient toplevel is withdrawn
        when mapped if master is withdrawn } {
    deleteWindows
    toplevel .master
    wm withdraw .master
    update
    toplevel .subject
    wm transient .subject .master
    update
    list [wm state .subject] [winfo ismapped .subject]
} {withdrawn 0}

test wm-transient-3.2 { already mapped transient toplevel
        takes on withdrawn state of master } {
    deleteWindows
    toplevel .master
    wm withdraw .master
    update
    toplevel .subject
    update
    wm transient .subject .master
    update
    list [wm state .subject] [winfo ismapped .subject]
} {withdrawn 0}

test wm-transient-3.3 { withdraw/deiconify on the master
        also does a withdraw/deiconify on the transient } {
    deleteWindows
    set results [list]
    toplevel .master
    toplevel .subject
    update
    wm transient .subject .master
    wm withdraw .master
    update
    lappend results [wm state .subject] \
        [winfo ismapped .subject]
    wm deiconify .master
    update
    lappend results [wm state .subject] \
        [winfo ismapped .subject]
    set results
} {withdrawn 0 normal 1}

test wm-transient-4.1 { transient toplevel is withdrawn
        when mapped if master is iconic } {
    deleteWindows
    toplevel .master
    wm iconify .master
    update
    toplevel .subject
    wm transient .subject .master
    update
    list [wm state .subject] [winfo ismapped .subject]
} {withdrawn 0}

test wm-transient-4.2 { already mapped transient toplevel
        is withdrawn if master is iconic } {
    deleteWindows
    toplevel .master
    wm iconify .master
    update
    toplevel .subject
    update
    wm transient .subject .master
    update
    list [wm state .subject] [winfo ismapped .subject]
} {withdrawn 0}

test wm-transient-4.3 { iconify/deiconify on the master
        does a withdraw/deiconify on the transient } {
    deleteWindows
    set results [list]
    toplevel .master
    toplevel .subject
    update
    wm transient .subject .master
    wm iconify .master
    update
    lappend results [wm state .subject] \
        [winfo ismapped .subject]
    wm deiconify .master
    update
    lappend results [wm state .subject] \
        [winfo ismapped .subject]
    set results
} {withdrawn 0 normal 1}

test wm-transient-5.1 { an error during transient command should not
        cause the map/unmap binding to be deleted } {
    deleteWindows
    set results [list]
    toplevel .master
    toplevel .subject
    update
    wm transient .subject .master
    # Expect a bad window path error here
    lappend results [catch {wm transient .subject .bad}]
    wm withdraw .master
    update
    lappend results [wm state .subject]
    wm deiconify .master
    update
    lappend results [wm state .subject]
    set results
} {1 withdrawn normal}

test wm-transient-5.2 { remove transient property when master
        is destroyed } {
    deleteWindows
    toplevel .master
    toplevel .subject
    wm transient .subject .master
d582 5
a586 1
    destroy .master
d588 2
a589 2
    wm transient .subject
} {}
d591 4
a594 142
test wm-transient-5.3 { remove transient property from window
        that had never been mapped when master is destroyed } {
    deleteWindows
    toplevel .master
    toplevel .subject
    wm transient .subject .master
    destroy .master
    wm transient .subject
} {}

test wm-transient-6.1 { a withdrawn transient does not track
        state changes in the master } {
    deleteWindows
    toplevel .master
    toplevel .subject
    update
    wm transient .subject .master
    wm withdraw .subject
    wm withdraw .master
    wm deiconify .master
    # idle handler should not map the transient
    update
    wm state .subject
} {withdrawn}

test wm-transient-6.2 { a withdrawn transient does not track
        state changes in the master } {
    set results [list]
    deleteWindows
    toplevel .master
    toplevel .subject
    update
    wm transient .subject .master
    wm withdraw .subject
    wm withdraw .master
    wm deiconify .master
    # idle handler should not map the transient
    update
    lappend results [wm state .subject]
    wm deiconify .subject
    lappend results [wm state .subject]
    wm withdraw .master
    lappend results [wm state .subject]
    wm deiconify .master
    # idle handler should map transient
    update
    lappend results [wm state .subject]
} {withdrawn normal withdrawn normal}


# wm-transient-7.*: See SF Tk Bug #592201 "wm transient fails with two masters"
# wm-transient-7.3 through 7.5 all caused panics on Unix in Tk 8.4b1.
# 7.1 and 7.2 added to catch (potential) future errors.
#
test wm-transient-7.1 {Destroying transient} {
    deleteWindows
    toplevel .t 
    toplevel .transient 
    wm transient .transient .t
    destroy .transient
    destroy .t
    # OK: the above did not cause a panic.
} {}

test wm-transient-7.2 {Destroying master} {
    deleteWindows
    toplevel .t
    toplevel .transient 
    wm transient .transient .t
    destroy .t
    set result [wm transient .transient]
    destroy .transient
    set result
} {}

test wm-transient-7.3 {Reassign transient, destroy old master} {
    deleteWindows
    toplevel .t1 
    toplevel .t2 
    toplevel .transient
    wm transient .transient .t1
    wm transient .transient .t2
    destroy .t1	;# Caused panic in 8.4b1
    destroy .t2 
    destroy .transient
} {}

test wm-transient-7.4 {Reassign transient, destroy new master} {
    deleteWindows
    toplevel .t1 
    toplevel .t2 
    toplevel .transient
    wm transient .transient .t1
    wm transient .transient .t2
    destroy .t2 	;# caused panic in 8.4b1
    destroy .t1
    destroy .transient
} {}

test wm-transient-7.5 {Reassign transient, destroy transient} {
    deleteWindows
    toplevel .t1 
    toplevel .t2 
    toplevel .transient
    wm transient .transient .t1
    wm transient .transient .t2
    destroy .transient
    destroy .t2 	;# caused panic in 8.4b1
    destroy .t1		;# so did this
} {}

test wm-state-1.1 {usage} {
    list [catch {wm state} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-state-1.2 {usage} {
    list [catch {wm state . _ _} err] $err
} {1 {wrong # args: should be "wm state window ?state?"}}

test wm-state-2.1 {initial state} {
    deleteWindows
    toplevel .t
    wm state .t
} {normal}

test wm-state-2.2 {state change before map} {
    deleteWindows
    toplevel .t
    wm state .t withdrawn
    wm state .t
} {withdrawn}

test wm-state-2.3 {state change before map} {
    deleteWindows
    toplevel .t
    wm withdraw .t
    wm state .t
} {withdrawn}

test wm-state-2.4 {state change after map} {
    deleteWindows
    toplevel .t
d596 1
a596 7
    wm state .t withdrawn
    wm state .t
} {withdrawn}

test wm-state-2.5 {state change after map} {
    deleteWindows
    toplevel .t
d598 3
a600 21
    wm withdraw .t
    wm state .t
} {withdrawn}

test wm-state-2.6 {state change before map} {
    deleteWindows
    toplevel .t
    wm state .t iconic
    wm state .t
} {iconic}

test wm-state-2.7 {state change before map} {
    deleteWindows
    toplevel .t
    wm iconify .t
    wm state .t
} {iconic}

test wm-state-2.8 {state change after map} {
    deleteWindows
    toplevel .t
d602 3
a604 3
    wm state .t iconic
    wm state .t
} {iconic}
d606 4
a609 3
test wm-state-2.9 {state change after map} {
    deleteWindows
    toplevel .t
d611 8
a618 23
    wm iconify .t
    wm state .t
} {iconic}

test wm-state-2.10 {state change before map} {
    deleteWindows
    toplevel .t
    wm withdraw .t
    wm state .t normal
    wm state .t
} {normal}

test wm-state-2.11 {state change before map} {
    deleteWindows
    toplevel .t
    wm withdraw .t
    wm deiconify .t
    wm state .t
} {normal}

test wm-state-2.12 {state change after map} {
    deleteWindows
    toplevel .t
d620 19
a638 33
    wm withdraw .t
    wm state .t normal
    wm state .t
} {normal}

test wm-state-2.13 {state change after map} {
    deleteWindows
    toplevel .t
    update
    wm withdraw .t
    wm deiconify .t
    wm state .t
} {normal}

test wm-state-2.14 {state change before map} {
    deleteWindows
    toplevel .t
    wm iconify .t
    wm state .t normal
    wm state .t
} {normal}

test wm-state-2.15 {state change before map} {
    deleteWindows
    toplevel .t
    wm iconify .t
    wm deiconify .t
    wm state .t
} {normal}

test wm-state-2.16 {state change after map} {
    deleteWindows
    toplevel .t
d640 3
a642 8
    wm iconify .t
    wm state .t normal
    wm state .t
} {normal}

test wm-state-2.17 {state change after map} {
    deleteWindows
    toplevel .t
d644 2
a645 45
    wm iconify .t
    wm deiconify .t
    wm state .t
} {normal}


test wm-withdraw-1.1 {usage} {
    list [catch {wm withdraw} err] $err
} {1 {wrong # args: should be "wm option window ?arg ...?"}}

test wm-withdraw-1.2 {usage} {
    list [catch {wm withdraw . _} msg] $msg
} {1 {wrong # args: should be "wm withdraw window"}}

test wm-withdraw-2.1 {Misc errors} {
    deleteWindows
    toplevel .t
    toplevel .t2
    wm iconwindow .t .t2
    set result [list [catch {wm withdraw .t2} msg] $msg]
    destroy .t2
    set result
} {1 {can't withdraw .t2: it is an icon for .t}}

test wm-withdraw-3.1 {} {
    update
    set result {}
    wm withdraw .t
    lappend result [wm state .t] [winfo ismapped .t]
    wm deiconify .t
    lappend result [wm state .t] [winfo ismapped .t]
} {withdrawn 0 normal 1}


# FIXME:

# Test delivery of virtual events to the WM. We could check to see
# if the window was raised after a button click for example.
# This sort of testing may not be possible.


deleteWindows
tcltest::cleanupTests
return

d647 25
d673 2
@

