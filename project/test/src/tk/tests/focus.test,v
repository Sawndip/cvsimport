head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.20.24.50;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.16;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.29;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.53;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.36;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.39.06;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@# This file is a Tcl script to test out the "focus" command and the
# other procedures in the file tkFocus.c.  It is organized in the
# standard fashion for Tcl tests.
#
# Copyright (c) 1994-1996 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
#
# RCS: @@(#) $Id: focus.test,v 1.8 2002/07/14 05:48:46 dgp Exp $

package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands

button .b -text .b -relief raised -bd 2
pack .b

proc focusSetup {} {
    catch {destroy .t}
    toplevel .t
    wm geom .t +0+0
    foreach i {b1 b2 b3 b4} {
	button .t.$i -text .t.$i -relief raised -bd 2
	pack .t.$i
    }
    tkwait visibility .t.b4
}
proc focusSetupAlt {} {
    global env
    catch {destroy .alt}
    toplevel .alt -screen $env(TK_ALT_DISPLAY)
    foreach i {a b c d} {
	button .alt.$i -text .alt.$i -relief raised -bd 2
	pack .alt.$i
    }
    tkwait visibility .alt.d
}

# Make sure the window manager knows who has focus
catch {fixfocus}

# The following procedure ensures that there is no input focus
# in this application.  It does it by arranging for another
# application to grab the focus.  The "after" and "update" stuff
# is needed to wait long enough for pending actions to get through
# the X server and possibly also the window manager.

setupbg
proc focusClear {} {
    global x;
    after 200 {set x 1}
    tkwait variable x
    dobg {focus -force .; update}
    update
}

focusSetup
if {[testConstraint altDisplay]} {
    focusSetupAlt
}
update

bind all <FocusIn> {
    append focusInfo "in %W %d\n"
}
bind all <FocusOut> {
    append focusInfo "out %W %d\n"
}
bind all <KeyPress> {
    append focusInfo "press %W %K"
}

test focus-1.1 {Tk_FocusCmd procedure} {unixOnly} {
    focusClear
    focus
} {}
test focus-1.2 {Tk_FocusCmd procedure} {unixOnly altDisplay} {
    focus .alt.b
    focus
} {}
test focus-1.3 {Tk_FocusCmd procedure} {unixOnly} {
    focusClear
    focus .t.b3
    focus
} {}
test focus-1.4 {Tk_FocusCmd procedure} {unixOnly} {
    list [catch {focus ""} msg] $msg
} {0 {}}
test focus-1.5 {Tk_FocusCmd procedure} {unixOnly} {
    focusClear
    focus -force .t
    focus .t.b3
    focus
} {.t.b3}
test focus-1.6 {Tk_FocusCmd procedure} {unixOnly} {
    list [catch {focus .gorp} msg] $msg
} {1 {bad window path name ".gorp"}}
test focus-1.7 {Tk_FocusCmd procedure} {unixOnly} {
    list [catch {focus .gorp a} msg] $msg
} {1 {bad option ".gorp": must be -displayof, -force, or -lastfor}}
test focus-1.8 {Tk_FocusCmd procedure, focussing on dead window} {unixOnly} {
    toplevel .t2
    wm geom .t2 +10+10
    frame .t2.f -width 200 -height 100 -bd 2 -relief raised
    frame .t2.f2 -width 200 -height 100 -bd 2 -relief raised
    pack .t2.f .t2.f2
    bind .t2.f <Destroy> {focus .t2.f}
    bind .t2.f2 <Destroy> {focus .t2}
    focus -force .t2.f2
    tkwait visibility .t2.f2
    update
    set x [focus]
    destroy .t2.f2
    lappend x [focus]
    destroy .t2.f
    lappend x [focus]
    destroy .t2
    set x
} {.t2.f2 .t2 .t2}
test focus-1.9 {Tk_FocusCmd procedure, -displayof option} {unixOnly} {
    list [catch {focus -displayof} msg] $msg
} {1 {wrong # args: should be "focus -displayof window"}}
test focus-1.10 {Tk_FocusCmd procedure, -displayof option} {unixOnly} {
    list [catch {focus -displayof a b} msg] $msg
} {1 {wrong # args: should be "focus -displayof window"}}
test focus-1.11 {Tk_FocusCmd procedure, -displayof option} {unixOnly} {
    list [catch {focus -displayof .lousy} msg] $msg
} {1 {bad window path name ".lousy"}}
test focus-1.12 {Tk_FocusCmd procedure, -displayof option} {unixOnly} {
    focusClear
    focus .t
    focus -displayof .t.b3
} {}
test focus-1.13 {Tk_FocusCmd procedure, -displayof option} {unixOnly} {
    focusClear
    focus -force .t
    focus -displayof .t.b3
} {.t}
test focus-1.14 {Tk_FocusCmd procedure, -displayof option} {unixOnly altDisplay} {
    focus -force .alt.c
    focus -displayof .alt
} {.alt.c}
test focus-1.15 {Tk_FocusCmd procedure, -force option} {unixOnly} {
    list [catch {focus -force} msg] $msg
} {1 {wrong # args: should be "focus -force window"}}
test focus-1.16 {Tk_FocusCmd procedure, -force option} {unixOnly} {
    list [catch {focus -force a b} msg] $msg
} {1 {wrong # args: should be "focus -force window"}}
test focus-1.17 {Tk_FocusCmd procedure, -force option} {unixOnly} {
    list [catch {focus -force foo} msg] $msg
} {1 {bad window path name "foo"}}
test focus-1.18 {Tk_FocusCmd procedure, -force option} {unixOnly} {
    list [catch {focus -force ""} msg] $msg
} {0 {}}
test focus-1.19 {Tk_FocusCmd procedure, -force option} {unixOnly} {
    focusClear
    focus .t.b1
    set x  [list [focus]]
    focus -force .t.b1
    lappend x [focus]
} {{} .t.b1}
test focus-1.20 {Tk_FocusCmd procedure, -lastfor option} {unixOnly} {
    list [catch {focus -lastfor} msg] $msg
} {1 {wrong # args: should be "focus -lastfor window"}}
test focus-1.21 {Tk_FocusCmd procedure, -lastfor option} {unixOnly} {
    list [catch {focus -lastfor 1 2} msg] $msg
} {1 {wrong # args: should be "focus -lastfor window"}}
test focus-1.22 {Tk_FocusCmd procedure, -lastfor option} {unixOnly} {
    list [catch {focus -lastfor who_knows?} msg] $msg
} {1 {bad window path name "who_knows?"}}
test focus-1.23 {Tk_FocusCmd procedure, -lastfor option} {unixOnly} {
    focus .b
    focus .t.b1
    list [focus -lastfor .] [focus -lastfor .t.b3]
} {.b .t.b1}
test focus-1.24 {Tk_FocusCmd procedure, -lastfor option} {unixOnly} {
    destroy .t
    focusSetup
    update
    focus -lastfor .t.b2
} {.t}
test focus-1.25 {Tk_FocusCmd procedure} {unixOnly} {
    list [catch {focus -unknown} msg] $msg
} {1 {bad option "-unknown": must be -displayof, -force, or -lastfor}}

test focus-2.1 {TkFocusFilterEvent procedure} {unixOnly nonPortable testwrapper} {
    focus -force .b
    destroy .t
    focusSetup
    update
    set focusInfo {}
    event gen [testwrapper .t] <FocusIn> -detail NotifyAncestor \
	    -sendevent 0x54217567
    list $focusInfo
} {{}}
test focus-2.2 {TkFocusFilterEvent procedure} {unixOnly nonPortable testwrapper} {
    focus -force .b
    destroy .t
    focusSetup
    update
    set focusInfo {}
    event gen .t <FocusIn> -detail NotifyAncestor -sendevent 0x547321ac
    list $focusInfo [focus]
} {{in .t NotifyAncestor
} .b}
test focus-2.3 {TkFocusFilterEvent procedure} {unixOnly nonPortable testwrapper} {
    focus -force .b
    destroy .t
    focusSetup
    update
    set focusInfo {}
    event gen [testwrapper .t] <FocusIn> -detail NotifyAncestor
    update
    list $focusInfo [focus -lastfor .t]
} {{out .b NotifyNonlinear
out . NotifyNonlinearVirtual
in .t NotifyNonlinear
} .t}
test focus-2.4 {TkFocusFilterEvent procedure, FocusIn events} \
	{unixOnly nonPortable testwrapper} {
    set result {}
    focus .t.b1
    # Important to end with NotifyAncestor, which is an
    # event that is processed normally. This has a side
    # effect on text 2.5
    foreach detail {NotifyAncestor NotifyNonlinear
	    NotifyNonlinearVirtual NotifyPointer NotifyPointerRoot
	    NotifyVirtual NotifyAncestor} {
	focus -force .
	update
	event gen [testwrapper .t] <FocusIn> -detail $detail
	set focusInfo {}
	update
	lappend result $focusInfo
    }
    set result
} {{out . NotifyNonlinear
in .t NotifyNonlinearVirtual
in .t.b1 NotifyNonlinear
} {out . NotifyNonlinear
in .t NotifyNonlinearVirtual
in .t.b1 NotifyNonlinear
} {} {out . NotifyNonlinear
in .t NotifyNonlinearVirtual
in .t.b1 NotifyNonlinear
} {} {} {out . NotifyNonlinear
in .t NotifyNonlinearVirtual
in .t.b1 NotifyNonlinear
}}
test focus-2.5 {TkFocusFilterEvent procedure, creating FocusInfo struct} \
	{unixOnly nonPortable testwrapper} {
    focusSetup
    focus .t.b1
    update
    event gen [testwrapper .t] <FocusIn> -detail NotifyAncestor
    list $focusInfo [focus]
} {{out . NotifyNonlinear
in .t NotifyNonlinearVirtual
in .t.b1 NotifyNonlinear
} .t.b1}
test focus-2.6 {TkFocusFilterEvent procedure, FocusIn events} \
	{unixOnly testwrapper} {
    focus .t.b1
    focus .
    update
    event gen [testwrapper .t] <FocusIn> -detail NotifyAncestor
    set focusInfo {}
    set x [focus]
    event gen . <KeyPress-x>
    list $x $focusInfo
} {.t.b1 {press .t.b1 x}}
test focus-2.7 {TkFocusFilterEvent procedure, FocusOut events} \
	{unixOnly testwrapper} {
    set result {}
    foreach detail {NotifyAncestor NotifyInferior NotifyNonlinear
	    NotifyNonlinearVirtual NotifyPointer NotifyPointerRoot
	    NotifyVirtual} {
	focus -force .t.b1
	event gen [testwrapper .t] <FocusOut> -detail $detail
	update
	lappend result [focus]
    }
    set result
} {{} .t.b1 {} {} .t.b1 .t.b1 {}}
test focus-2.8 {TkFocusFilterEvent procedure, FocusOut events} \
	{unixOnly testwrapper} {
    focus -force .t.b1
    event gen .t.b1 <FocusOut> -detail NotifyAncestor
    focus
} {.t.b1}
test focus-2.9 {TkFocusFilterEvent procedure, FocusOut events} \
	{unixOnly testwrapper} {
    focus .t.b1
    event gen [testwrapper .] <FocusOut> -detail NotifyAncestor
    focus
} {}
test focus-2.10 {TkFocusFilterEvent procedure, Enter events} \
	{unixOnly testwrapper} {
    set result {}
    focus .t.b1
    focusClear
    foreach detail {NotifyAncestor NotifyInferior NotifyNonlinear
	    NotifyNonlinearVirtual NotifyVirtual} {
	event gen [testwrapper .t] <Enter> -detail $detail -focus 1
	update
	lappend result [focus]
	event gen [testwrapper .t] <Leave> -detail NotifyAncestor
	update
    }
    set result
} {.t.b1 {} .t.b1 .t.b1 .t.b1}
test focus-2.11 {TkFocusFilterEvent procedure, Enter events} \
	{unixOnly testwrapper} {
    focusClear
    set focusInfo {}
    event gen [testwrapper .t] <Enter> -detail NotifyAncestor
    update
    set focusInfo
} {}
test focus-2.12 {TkFocusFilterEvent procedure, Enter events} \
	{unixOnly testwrapper} {
    focus -force .b
    update
    set focusInfo {}
    event gen [testwrapper .t] <Enter> -detail NotifyAncestor -focus 1
    update
    set focusInfo
} {}
test focus-2.13 {TkFocusFilterEvent procedure, Enter events} \
	{unixOnly testwrapper} {
    focus .t.b1
    focusClear
    event gen [testwrapper .t] <Enter> -detail NotifyAncestor -focus 1
    set focusInfo {}
    update
    set focusInfo
} {in .t NotifyVirtual
in .t.b1 NotifyAncestor
}
test focus-2.14 {TkFocusFilterEvent procedure, Enter events, ignore errors when setting focus due to implicit focus} {unixOnly testwrapper} {
    focusClear
    catch {destroy .t2}
    toplevel .t2
    wm withdraw .t2
    update
    set focusInfo {}
    event gen [testwrapper .t2] <Enter> -detail NotifyAncestor -focus 1
    update
    destroy .t2
} {}
test focus-2.15 {TkFocusFilterEvent procedure, Leave events} \
	{unixOnly testwrapper} {
    set result {}
    focus .t.b1
    foreach detail {NotifyAncestor NotifyInferior NotifyNonlinear
	    NotifyNonlinearVirtual NotifyVirtual} {
	focusClear
	event gen [testwrapper .t] <Enter> -detail NotifyAncestor -focus 1
	update
	event gen [testwrapper .t] <Leave> -detail $detail
	update
	lappend result [focus]
    }
    set result
} {{} .t.b1 {} {} {}}
test focus-2.16 {TkFocusFilterEvent procedure, Leave events} \
	{unixOnly testwrapper} {
    set result {}
    focus .t.b1
    event gen [testwrapper .t] <Enter> -detail NotifyAncestor -focus 1
    update
    set focusInfo {}
    event gen [testwrapper .t] <Leave> -detail NotifyAncestor
    update
    set focusInfo
} {out .t.b1 NotifyAncestor
out .t NotifyVirtual
}
test focus-2.17 {TkFocusFilterEvent procedure, Leave events} \
	{unixOnly testwrapper} {
    set result {}
    focus .t.b1
    event gen [testwrapper .t] <Enter> -detail NotifyAncestor -focus 1
    update
    set focusInfo {}
    event gen .t.b1 <Leave> -detail NotifyAncestor
    event gen [testwrapper .] <Leave> -detail NotifyAncestor
    update
    list $focusInfo [focus]
} {{out .t.b1 NotifyAncestor
out .t NotifyVirtual
} {}}

test focus-3.1 {SetFocus procedure, create record on focus} \
	{unixOnly testwrapper} {
    toplevel .t2 -width 250 -height 100
    wm geometry .t2 +0+0
    update
    focus -force .t2
    update
    focus
} {.t2}
catch {destroy .t2}
# This test produces no result, but it will generate a protocol
# error if Tk forgets to make the window exist before focussing
# on it.
test focus-3.2 {SetFocus procedure, making window exist} \
	{unixOnly testwrapper} {
    update
    button .b2 -text "Another button"
    focus .b2
    update
} {}
catch {destroy .b2}
update
# The following test doesn't produce a check-able result, but if
# there are bugs it may generate an X protocol error.
test focus-3.3 {SetFocus procedure, delaying claim of X focus} \
	{unixOnly testwrapper} {
    focusSetup
    focus -force .t.b2
    update
} {}
test focus-3.4 {SetFocus procedure, delaying claim of X focus} \
	{unixOnly testwrapper} {
    focusSetup
    wm withdraw .t
    focus -force .t.b2
    toplevel .t2 -width 250 -height 100
    wm geometry .t2 +10+10
    focus -force .t2
    wm withdraw .t2
    update
    wm deiconify .t2
    wm deiconify .t
} {}
catch {destroy .t2}
test focus-3.5 {SetFocus procedure, generating events} \
	{unixOnly testwrapper} {
    focusSetup
    focusClear
    set focusInfo {}
    focus -force .t.b2
    update
    set focusInfo
} {in .t NotifyVirtual
in .t.b2 NotifyAncestor
}
test focus-3.6 {SetFocus procedure, generating events} \
	{unixOnly testwrapper} {
    focusSetup
    focus -force .b
    update
    set focusInfo {}
    focus .t.b2
    update
    set focusInfo
} {out .b NotifyNonlinear
out . NotifyNonlinearVirtual
in .t NotifyNonlinearVirtual
in .t.b2 NotifyNonlinear
}
test focus-3.7 {SetFocus procedure, generating events} \
	{unixOnly nonPortable testwrapper} {
    # Non-portable because some platforms generate extra events.

    focusSetup
    focusClear
    set focusInfo {}
    focus .t.b2
    update
    set focusInfo
} {}

test focus-4.1 {TkFocusDeadWindow procedure} {unixOnly testwrapper} {
    focusSetup
    update
    focus -force .b
    update
    destroy .t
    focus
} {.b}
test focus-4.2 {TkFocusDeadWindow procedure} {unixOnly testwrapper} {
    focusSetup
    update
    focus -force .t.b2
    focus .b
    update
    destroy .t.b2
    update
    focus
} {.b}

# Non-portable due to wm-specific redirection of input focus when
# windows are deleted:

test focus-4.3 {TkFocusDeadWindow procedure} {unixOnly nonPortable testwrapper} {
    focusSetup
    update
    focus .t
    update
    destroy .t
    update
    focus
} {}
test focus-4.4 {TkFocusDeadWindow procedure} {unixOnly testwrapper} {
    focusSetup
    focus -force .t.b2
    update
    destroy .t.b2
    focus
} {.t}

# I don't know how to test most of the remaining procedures of this file
# explicitly;  they've already been exercised by the preceding tests.

setupbg
test focus-5.1 {ChangeXFocus procedure, don't take focus unless have it} \
	{unixOnly testwrapper secureserver} {
    focusSetup
    focus -force .t
    update
    set result [focus]
    send [dobg {tk appname}] {focus -force .; update}
    lappend result [focus]
    focus .t.b2
    update
    lappend result [focus]
} {.t {} {}}

catch {destroy .t}
bind all <FocusIn> {}
bind all <FocusOut> {}
bind all <KeyPress> {}
cleanupbg
fixfocus

test focus-6.1 {miscellaneous - embedded application in same process} \
	{unixOnly testwrapper} {
    eval interp delete [interp slaves]
    catch {destroy .t}
    toplevel .t
    wm geometry .t +0+0
    frame .t.f1 -container 1
    frame .t.f2
    pack .t.f1 .t.f2
    entry .t.f2.e1 -bg red
    pack .t.f2.e1
    bind all <FocusIn> {lappend x "focus in %W %d"}
    bind all <FocusOut> {lappend x "focus out %W %d"}
    interp create child
    child eval "set argv {-use [winfo id .t.f1]}"
    load {} Tk child
    child eval {
	entry .e1 -bg lightBlue
	pack .e1
	bind all <FocusIn> {lappend x "focus in %W %d"}
	bind all <FocusOut> {lappend x "focus out %W %d"}
	set x {}
    }

    # Claim the focus and wait long enough for it to really arrive.

    focus -force .t.f2.e1
    after 300 {set timer 1}
    vwait timer
    set x {}
    lappend x [focus] [child eval focus]

    # See if a "focus" command will move the focus to the embedded
    # application.

    child eval {focus .e1}
    after 300 {set timer 1}
    vwait timer
    lappend x |
    child eval {lappend x |}

    # Bring the focus back to the main application.

    focus .t.f2.e1
    after 300 {set timer 1}
    vwait timer
    set result [list $x [child eval {set x}]]
    interp delete child
    set result
} {{.t.f2.e1 {} {focus out .t.f2.e1 NotifyNonlinear} {focus out .t.f2 NotifyNonlinearVirtual} {focus in .t.f1 NotifyNonlinear} | {focus out .t.f1 NotifyNonlinear} {focus in .t.f2 NotifyNonlinearVirtual} {focus in .t.f2.e1 NotifyNonlinear}} {{focus in . NotifyVirtual} {focus in .e1 NotifyAncestor} | {focus out .e1 NotifyAncestor} {focus out . NotifyVirtual}}}
test focus-6.2 {miscellaneous - embedded application in different process} \
	{unixOnly testwrapper} {
    eval interp delete [interp slaves]
    catch {destroy .t}
    setupbg
    toplevel .t
    wm geometry .t +0+0
    frame .t.f1 -container 1
    frame .t.f2
    pack .t.f1 .t.f2
    entry .t.f2.e1 -bg red
    pack .t.f2.e1
    bind all <FocusIn> {lappend x "focus in %W %d"}
    bind all <FocusOut> {lappend x "focus out %W %d"}
    setupbg -use [winfo id .t.f1]
    dobg {
	entry .e1 -bg lightBlue
	pack .e1
	bind all <FocusIn> {lappend x "focus in %W %d"}
	bind all <FocusOut> {lappend x "focus out %W %d"}
	set x {}
    }

    # Claim the focus and wait long enough for it to really arrive.

    focus -force .t.f2.e1
    after 300 {set timer 1}
    vwait timer
    set x {}
    lappend x [focus] [dobg focus]

    # See if a "focus" command will move the focus to the embedded
    # application.

    dobg {focus .e1}
    after 300 {set timer 1}
    vwait timer
    lappend x |
    dobg {lappend x |}

    # Bring the focus back to the main application.

    focus .t.f2.e1
    after 300 {set timer 1}
    vwait timer
    set result [list $x [dobg {set x}]]
    cleanupbg
    set result
} {{.t.f2.e1 {} {focus out .t.f2.e1 NotifyNonlinear} {focus out .t.f2 NotifyNonlinearVirtual} {focus in .t.f1 NotifyNonlinear} | {focus out .t.f1 NotifyNonlinear} {focus in .t.f2 NotifyNonlinearVirtual} {focus in .t.f2.e1 NotifyNonlinear}} {{focus in . NotifyVirtual} {focus in .e1 NotifyAncestor} | {focus out .e1 NotifyAncestor} {focus out . NotifyVirtual}}}

deleteWindows
bind all <FocusIn> {}
bind all <FocusOut> {}

# cleanup
::tcltest::cleanupTests
return













@


1.4
log
@touched all sources to ease next import
@
text
@d9 1
a9 1
# RCS: @@(#) $Id: focus.test,v 1.7.6.2 2000/09/26 16:09:18 spolk Exp $
d11 6
a16 7
if {[lsearch [namespace children] ::tcltest] == -1} {
    source [file join [pwd] [file dirname [info script]] defs.tcl]
}

eval destroy [winfo children .]
wm geometry . {}
raise .
d61 1
a61 2
set ::tcltest::testConfig(altDisplay) [info exists env(TK_ALT_DISPLAY)]
if {$::tcltest::testConfig(altDisplay)} {
a188 5
# Some tests require the testwrapper command

set ::tcltest::testConfig(testwrapper) \
	[expr {[info commands testwrapper] != {}}]

a519 12
# If send is disabled because of inadequate security, don't run any
# of these tests at all.

setupbg
set app [dobg {tk appname}]
set ::tcltest::testConfig(secureServer) 1
if {[catch {send $app set a 0} msg] == 1} {
    if [string match "X server insecure *" $msg] {
	set ::tcltest::testConfig(secureServer) 0
    }
}
cleanupbg
d522 1
a522 1
	{unixOnly testwrapper secureServer} {
d556 1
a556 1
    load {} tk child
d641 1
a641 1
eval destroy [winfo children .]
a647 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d6 2
d9 1
a9 8
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: focus.test,v 1.9 1999/01/26 04:11:34 jingham Exp $

if {$tcl_platform(platform) != "unix"} {
    return
}
d11 2
a12 2
if {[info procs test] != "test"} {
    source defs
a35 1
    wm withdraw .alt
d44 1
a44 1
fixfocus
d62 2
a63 2
set altDisplay [info exists env(TK_ALT_DISPLAY)]
if $altDisplay {
d78 1
a78 1
test focus-1.1 {Tk_FocusCmd procedure} {
d82 5
a86 7
if $altDisplay {
    test focus-1.2 {Tk_FocusCmd procedure} {
	focus .alt.b
	focus
    } {}
}
test focus-1.3 {Tk_FocusCmd procedure} {
d91 1
a91 1
test focus-1.4 {Tk_FocusCmd procedure} {
d94 1
a94 1
test focus-1.5 {Tk_FocusCmd procedure} {
d100 1
a100 1
test focus-1.6 {Tk_FocusCmd procedure} {
d103 1
a103 1
test focus-1.7 {Tk_FocusCmd procedure} {
d106 1
a106 1
test focus-1.8 {Tk_FocusCmd procedure, focussing on dead window} {
d125 1
a125 1
test focus-1.9 {Tk_FocusCmd procedure, -displayof option} {
d128 1
a128 1
test focus-1.10 {Tk_FocusCmd procedure, -displayof option} {
d131 1
a131 1
test focus-1.11 {Tk_FocusCmd procedure, -displayof option} {
d134 1
a134 1
test focus-1.12 {Tk_FocusCmd procedure, -displayof option} {
d139 1
a139 1
test focus-1.13 {Tk_FocusCmd procedure, -displayof option} {
d144 5
a148 7
if $altDisplay {
    test focus-1.14 {Tk_FocusCmd procedure, -displayof option} {
	focus -force .alt.c
	focus -displayof .alt
    } {.alt.c}
}
test focus-1.15 {Tk_FocusCmd procedure, -force option} {
d151 1
a151 1
test focus-1.16 {Tk_FocusCmd procedure, -force option} {
d154 1
a154 1
test focus-1.17 {Tk_FocusCmd procedure, -force option} {
d157 1
a157 1
test focus-1.18 {Tk_FocusCmd procedure, -force option} {
d160 1
a160 1
test focus-1.19 {Tk_FocusCmd procedure, -force option} {
d167 1
a167 1
test focus-1.20 {Tk_FocusCmd procedure, -lastfor option} {
d170 1
a170 1
test focus-1.21 {Tk_FocusCmd procedure, -lastfor option} {
d173 1
a173 1
test focus-1.22 {Tk_FocusCmd procedure, -lastfor option} {
d176 1
a176 1
test focus-1.23 {Tk_FocusCmd procedure, -lastfor option} {
d181 1
a181 1
test focus-1.24 {Tk_FocusCmd procedure, -lastfor option} {
d187 1
a187 1
test focus-1.25 {Tk_FocusCmd procedure} {
d191 4
a194 5
if {[string compare testwrapper [info commands testwrapper]] != 0} {
    puts "This application hasn't been compiled with the testwrapper command,"
    puts "therefore I am skipping all of these tests."
    return
}
d196 1
a196 1
test focus-2.1 {TkFocusFilterEvent procedure} {nonPortable} {
d202 2
a203 1
    event gen [testwrapper .t] <FocusIn> -detail NotifyAncestor -sendevent 0x54217567
d206 1
a206 1
test focus-2.2 {TkFocusFilterEvent procedure} {nonPortable} {
d216 1
a216 1
test focus-2.3 {TkFocusFilterEvent procedure} {nonPortable} {
d229 2
a230 1
test focus-2.4 {TkFocusFilterEvent procedure, FocusIn events} {nonPortable} {
d260 2
a261 1
test focus-2.5 {TkFocusFilterEvent procedure, creating FocusInfo struct} {nonPortable} {
d271 2
a272 1
test focus-2.6 {TkFocusFilterEvent procedure, FocusIn events} {
d282 2
a283 1
test focus-2.7 {TkFocusFilterEvent procedure, FocusOut events} {
d295 2
a296 1
test focus-2.8 {TkFocusFilterEvent procedure, FocusOut events} {
d301 2
a302 1
test focus-2.9 {TkFocusFilterEvent procedure, FocusOut events} {
d307 2
a308 1
test focus-2.10 {TkFocusFilterEvent procedure, Enter events} {
d322 2
a323 1
test focus-2.11 {TkFocusFilterEvent procedure, Enter events} {
d330 2
a331 1
test focus-2.12 {TkFocusFilterEvent procedure, Enter events} {
d339 2
a340 1
test focus-2.13 {TkFocusFilterEvent procedure, Enter events} {
d350 1
a350 1
test focus-2.14 {TkFocusFilterEvent procedure, Enter events, ignore errors when setting focus due to implicit focus} {
d361 2
a362 1
test focus-2.15 {TkFocusFilterEvent procedure, Leave events} {
d376 2
a377 1
test focus-2.16 {TkFocusFilterEvent procedure, Leave events} {
d389 2
a390 1
test focus-2.17 {TkFocusFilterEvent procedure, Leave events} {
d404 2
a405 1
test focus-3.1 {SetFocus procedure, create record on focus} {
d417 2
a418 1
test focus-3.2 {SetFocus procedure, making window exist} {
d428 2
a429 1
test focus-3.3 {SetFocus procedure, delaying claim of X focus} {
d434 2
a435 1
test focus-3.4 {SetFocus procedure, delaying claim of X focus} {
d448 2
a449 1
test focus-3.5 {SetFocus procedure, generating events} {
d459 2
a460 1
test focus-3.6 {SetFocus procedure, generating events} {
d473 2
a474 1
test focus-3.7 {SetFocus procedure, generating events} {nonPortable} {
d485 1
a485 1
test focus-4.1 {TkFocusDeadWindow procedure} {
d493 1
a493 1
test focus-4.2 {TkFocusDeadWindow procedure} {
d507 1
a507 1
test focus-4.3 {TkFocusDeadWindow procedure} {nonPortable} {
d516 1
a516 1
test focus-4.4 {TkFocusDeadWindow procedure} {
d527 15
a541 1
test focus-5.1 {ChangeXFocus procedure, don't take focus unless have it} {
d551 1
a551 1
} {.t .t {}}
d560 2
a561 1
test focus-6.1 {miscellaneous - embedded application in same process} {unixOnly} {
d610 2
a611 1
test focus-6.2 {miscellaneous - embedded application in different process} {unixOnly} {
d663 18
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@a5 2
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
d7 8
a14 1
# RCS: @@(#) $Id: focus.test,v 1.7.6.2 2000/09/26 16:09:18 spolk Exp $
d16 2
a17 2
if {[lsearch [namespace children] ::tcltest] == -1} {
    source [file join [pwd] [file dirname [info script]] defs.tcl]
d41 1
d50 1
a50 1
catch {fixfocus}
d68 2
a69 2
set ::tcltest::testConfig(altDisplay) [info exists env(TK_ALT_DISPLAY)]
if {$::tcltest::testConfig(altDisplay)} {
d84 1
a84 1
test focus-1.1 {Tk_FocusCmd procedure} {unixOnly} {
d88 7
a94 5
test focus-1.2 {Tk_FocusCmd procedure} {unixOnly altDisplay} {
    focus .alt.b
    focus
} {}
test focus-1.3 {Tk_FocusCmd procedure} {unixOnly} {
d99 1
a99 1
test focus-1.4 {Tk_FocusCmd procedure} {unixOnly} {
d102 1
a102 1
test focus-1.5 {Tk_FocusCmd procedure} {unixOnly} {
d108 1
a108 1
test focus-1.6 {Tk_FocusCmd procedure} {unixOnly} {
d111 1
a111 1
test focus-1.7 {Tk_FocusCmd procedure} {unixOnly} {
d114 1
a114 1
test focus-1.8 {Tk_FocusCmd procedure, focussing on dead window} {unixOnly} {
d133 1
a133 1
test focus-1.9 {Tk_FocusCmd procedure, -displayof option} {unixOnly} {
d136 1
a136 1
test focus-1.10 {Tk_FocusCmd procedure, -displayof option} {unixOnly} {
d139 1
a139 1
test focus-1.11 {Tk_FocusCmd procedure, -displayof option} {unixOnly} {
d142 1
a142 1
test focus-1.12 {Tk_FocusCmd procedure, -displayof option} {unixOnly} {
d147 1
a147 1
test focus-1.13 {Tk_FocusCmd procedure, -displayof option} {unixOnly} {
d152 7
a158 5
test focus-1.14 {Tk_FocusCmd procedure, -displayof option} {unixOnly altDisplay} {
    focus -force .alt.c
    focus -displayof .alt
} {.alt.c}
test focus-1.15 {Tk_FocusCmd procedure, -force option} {unixOnly} {
d161 1
a161 1
test focus-1.16 {Tk_FocusCmd procedure, -force option} {unixOnly} {
d164 1
a164 1
test focus-1.17 {Tk_FocusCmd procedure, -force option} {unixOnly} {
d167 1
a167 1
test focus-1.18 {Tk_FocusCmd procedure, -force option} {unixOnly} {
d170 1
a170 1
test focus-1.19 {Tk_FocusCmd procedure, -force option} {unixOnly} {
d177 1
a177 1
test focus-1.20 {Tk_FocusCmd procedure, -lastfor option} {unixOnly} {
d180 1
a180 1
test focus-1.21 {Tk_FocusCmd procedure, -lastfor option} {unixOnly} {
d183 1
a183 1
test focus-1.22 {Tk_FocusCmd procedure, -lastfor option} {unixOnly} {
d186 1
a186 1
test focus-1.23 {Tk_FocusCmd procedure, -lastfor option} {unixOnly} {
d191 1
a191 1
test focus-1.24 {Tk_FocusCmd procedure, -lastfor option} {unixOnly} {
d197 1
a197 1
test focus-1.25 {Tk_FocusCmd procedure} {unixOnly} {
d201 5
a205 4
# Some tests require the testwrapper command

set ::tcltest::testConfig(testwrapper) \
	[expr {[info commands testwrapper] != {}}]
d207 1
a207 1
test focus-2.1 {TkFocusFilterEvent procedure} {unixOnly nonPortable testwrapper} {
d213 1
a213 2
    event gen [testwrapper .t] <FocusIn> -detail NotifyAncestor \
	    -sendevent 0x54217567
d216 1
a216 1
test focus-2.2 {TkFocusFilterEvent procedure} {unixOnly nonPortable testwrapper} {
d226 1
a226 1
test focus-2.3 {TkFocusFilterEvent procedure} {unixOnly nonPortable testwrapper} {
d239 1
a239 2
test focus-2.4 {TkFocusFilterEvent procedure, FocusIn events} \
	{unixOnly nonPortable testwrapper} {
d269 1
a269 2
test focus-2.5 {TkFocusFilterEvent procedure, creating FocusInfo struct} \
	{unixOnly nonPortable testwrapper} {
d279 1
a279 2
test focus-2.6 {TkFocusFilterEvent procedure, FocusIn events} \
	{unixOnly testwrapper} {
d289 1
a289 2
test focus-2.7 {TkFocusFilterEvent procedure, FocusOut events} \
	{unixOnly testwrapper} {
d301 1
a301 2
test focus-2.8 {TkFocusFilterEvent procedure, FocusOut events} \
	{unixOnly testwrapper} {
d306 1
a306 2
test focus-2.9 {TkFocusFilterEvent procedure, FocusOut events} \
	{unixOnly testwrapper} {
d311 1
a311 2
test focus-2.10 {TkFocusFilterEvent procedure, Enter events} \
	{unixOnly testwrapper} {
d325 1
a325 2
test focus-2.11 {TkFocusFilterEvent procedure, Enter events} \
	{unixOnly testwrapper} {
d332 1
a332 2
test focus-2.12 {TkFocusFilterEvent procedure, Enter events} \
	{unixOnly testwrapper} {
d340 1
a340 2
test focus-2.13 {TkFocusFilterEvent procedure, Enter events} \
	{unixOnly testwrapper} {
d350 1
a350 1
test focus-2.14 {TkFocusFilterEvent procedure, Enter events, ignore errors when setting focus due to implicit focus} {unixOnly testwrapper} {
d361 1
a361 2
test focus-2.15 {TkFocusFilterEvent procedure, Leave events} \
	{unixOnly testwrapper} {
d375 1
a375 2
test focus-2.16 {TkFocusFilterEvent procedure, Leave events} \
	{unixOnly testwrapper} {
d387 1
a387 2
test focus-2.17 {TkFocusFilterEvent procedure, Leave events} \
	{unixOnly testwrapper} {
d401 1
a401 2
test focus-3.1 {SetFocus procedure, create record on focus} \
	{unixOnly testwrapper} {
d413 1
a413 2
test focus-3.2 {SetFocus procedure, making window exist} \
	{unixOnly testwrapper} {
d423 1
a423 2
test focus-3.3 {SetFocus procedure, delaying claim of X focus} \
	{unixOnly testwrapper} {
d428 1
a428 2
test focus-3.4 {SetFocus procedure, delaying claim of X focus} \
	{unixOnly testwrapper} {
d441 1
a441 2
test focus-3.5 {SetFocus procedure, generating events} \
	{unixOnly testwrapper} {
d451 1
a451 2
test focus-3.6 {SetFocus procedure, generating events} \
	{unixOnly testwrapper} {
d464 1
a464 2
test focus-3.7 {SetFocus procedure, generating events} \
	{unixOnly nonPortable testwrapper} {
d475 1
a475 1
test focus-4.1 {TkFocusDeadWindow procedure} {unixOnly testwrapper} {
d483 1
a483 1
test focus-4.2 {TkFocusDeadWindow procedure} {unixOnly testwrapper} {
d497 1
a497 1
test focus-4.3 {TkFocusDeadWindow procedure} {unixOnly nonPortable testwrapper} {
d506 1
a506 1
test focus-4.4 {TkFocusDeadWindow procedure} {unixOnly testwrapper} {
d517 1
a517 15
# If send is disabled because of inadequate security, don't run any
# of these tests at all.

setupbg
set app [dobg {tk appname}]
set ::tcltest::testConfig(secureServer) 1
if {[catch {send $app set a 0} msg] == 1} {
    if [string match "X server insecure *" $msg] {
	set ::tcltest::testConfig(secureServer) 0
    }
}
cleanupbg
setupbg
test focus-5.1 {ChangeXFocus procedure, don't take focus unless have it} \
	{unixOnly testwrapper secureServer} {
d527 1
a527 1
} {.t {} {}}
d536 1
a536 2
test focus-6.1 {miscellaneous - embedded application in same process} \
	{unixOnly testwrapper} {
d585 1
a585 2
test focus-6.2 {miscellaneous - embedded application in different process} \
	{unixOnly testwrapper} {
a636 18

# cleanup
::tcltest::cleanupTests
return














@


1.1.1.3
log
@import tk 8.4.0
@
text
@d9 1
a9 1
# RCS: @@(#) $Id: focus.test,v 1.8 2002/07/14 05:48:46 dgp Exp $
d11 7
a17 6
package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands
d62 2
a63 1
if {[testConstraint altDisplay]} {
d191 5
d527 12
d541 1
a541 1
	{unixOnly testwrapper secureserver} {
d575 1
a575 1
    load {} Tk child
d660 1
a660 1
deleteWindows
d667 1
@


