head	1.36;
access;
symbols
	binutils-2_24-branch:1.36.0.2
	binutils-2_24-branchpoint:1.36
	binutils-2_21_1:1.32
	binutils-2_23_2:1.35
	binutils-2_23_1:1.35
	binutils-2_23:1.35
	binutils-2_23-branch:1.35.0.2
	binutils-2_23-branchpoint:1.35
	binutils-2_22_branch:1.33.0.4
	binutils-2_22:1.33
	binutils-2_22-branch:1.33.0.2
	binutils-2_22-branchpoint:1.33
	binutils-2_21:1.32
	binutils-2_21-branch:1.32.0.2
	binutils-2_21-branchpoint:1.32
	binutils-2_20_1:1.25.2.1
	binutils-2_20:1.25.2.1
	binutils-arc-20081103-branch:1.18.0.6
	binutils-arc-20081103-branchpoint:1.18
	binutils-2_20-branch:1.25.0.2
	binutils-2_20-branchpoint:1.25
	dje-cgen-play1-branch:1.24.0.2
	dje-cgen-play1-branchpoint:1.24
	arc-20081103-branch:1.18.0.4
	arc-20081103-branchpoint:1.18
	binutils-2_19_1:1.18
	binutils-2_19:1.18
	binutils-2_19-branch:1.18.0.2
	binutils-2_19-branchpoint:1.18
	binutils_latest_snapshot:1.36
	added-to-binutils:1.14;
locks; strict;
comment	@ * @;


1.36
date	2012.09.15.17.11.27;	author walt;	state Exp;
branches;
next	1.35;

1.35
date	2012.01.28.01.04.22;	author ian;	state Exp;
branches;
next	1.34;

1.34
date	2012.01.28.00.59.27;	author ian;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.03.13.37.07;	author tschwinge;	state Exp;
branches;
next	1.32;

1.32
date	2010.08.12.22.18.14;	author ccoutant;	state Exp;
branches;
next	1.31;

1.31
date	2010.08.12.22.01.10;	author ccoutant;	state Exp;
branches;
next	1.30;

1.30
date	2010.03.05.21.04.58;	author ro;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.19.17.55.49;	author ian;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.03.15.12.03;	author ian;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.30.18.49.59;	author dougkwan;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.16.23.07.23;	author dougkwan;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.23.13.00.26;	author nickc;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2009.06.22.06.56.05;	author ian;	state Exp;
branches;
next	1.23;

1.23
date	2009.05.27.18.27.42;	author dougkwan;	state Exp;
branches;
next	1.22;

1.22
date	2009.04.30.15.47.11;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2009.03.20.23.37.51;	author ian;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.06.18.20.45;	author hjl;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.03.14.50.56;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.12.16.58.40;	author dje;	state Exp;
branches;
next	1.17;

1.17
date	2008.04.16.23.21.01;	author davem;	state Exp;
branches;
next	1.16;

1.16
date	2008.04.11.19.13.08;	author davem;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.25.05.00.01;	author ian;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.06.00.15.04;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.22.20.56.19;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.06.00.02.36;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.16.00.38.25;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.07.18.51.39;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.06.22.45.08;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.29.19.58.16;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.25.21.29.06;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.07.21.21.41;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.18.22.29.20;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.04.23.10.59;	author iant;	state Exp;
branches;
next	;

1.25.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Add support for tilegx in gold.
	* configure.ac (ENABLE_GOLD): support tilegx*
	* configure: rebuild
elfcpp:
	* tilegx.h: New file.
	* elfcpp.h: add EM_TILEGX.
gold:
	* tilegx.cc: New file.
	* Makefile.am (TARGETSOURCES): Add tilegx.cc
	(ALL_TARGETOBJS): Add tilegx.$(OBJEXT)
	* configure.tgt: Add entries for tilegx*.
	* configure.ac: Likewise.
	* Makefile.in: Rebuild.
	* configure: Likewise.
	* testsuite/icf_safe_test.sh (arch_specific_safe_fold): Handle
	tilegx.
@
text
@// elfcpp.h -- main header file for elfcpp    -*- C++ -*-

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of elfcpp.

// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Library General Public License
// as published by the Free Software Foundation; either version 2, or
// (at your option) any later version.

// In addition to the permissions in the GNU Library General Public
// License, the Free Software Foundation gives you unlimited
// permission to link the compiled version of this file into
// combinations with other programs, and to distribute those
// combinations without any restriction coming from the use of this
// file.  (The Library Public License restrictions do apply in other
// respects; for example, they cover modification of the file, and
// distribution when not linked into a combined executable.)

// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Library General Public License for more details.

// You should have received a copy of the GNU Library General Public
// License along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
// 02110-1301, USA.

// This is the external interface for elfcpp.

#ifndef ELFCPP_H
#define ELFCPP_H

#include "elfcpp_swap.h"

#include <stdint.h>

namespace elfcpp
{

// Basic ELF types.

// These types are always the same size.

typedef uint16_t Elf_Half;
typedef uint32_t Elf_Word;
typedef int32_t Elf_Sword;
typedef uint64_t Elf_Xword;
typedef int64_t Elf_Sxword;

// These types vary in size depending on the ELF file class.  The
// template parameter should be 32 or 64.

template<int size>
struct Elf_types;

template<>
struct Elf_types<32>
{
  typedef uint32_t Elf_Addr;
  typedef uint32_t Elf_Off;
  typedef uint32_t Elf_WXword;
  typedef int32_t Elf_Swxword;
};

template<>
struct Elf_types<64>
{
  typedef uint64_t Elf_Addr;
  typedef uint64_t Elf_Off;
  typedef uint64_t Elf_WXword;
  typedef int64_t Elf_Swxword;
};

// Offsets within the Ehdr e_ident field.

const int EI_MAG0 = 0;
const int EI_MAG1 = 1;
const int EI_MAG2 = 2;
const int EI_MAG3 = 3;
const int EI_CLASS = 4;
const int EI_DATA = 5;
const int EI_VERSION = 6;
const int EI_OSABI = 7;
const int EI_ABIVERSION = 8;
const int EI_PAD = 9;
const int EI_NIDENT = 16;

// The valid values found in Ehdr e_ident[EI_MAG0 through EI_MAG3].

const int ELFMAG0 = 0x7f;
const int ELFMAG1 = 'E';
const int ELFMAG2 = 'L';
const int ELFMAG3 = 'F';

// The valid values found in Ehdr e_ident[EI_CLASS].

enum
{
  ELFCLASSNONE = 0,
  ELFCLASS32 = 1,
  ELFCLASS64 = 2
};

// The valid values found in Ehdr e_ident[EI_DATA].

enum
{
  ELFDATANONE = 0,
  ELFDATA2LSB = 1,
  ELFDATA2MSB = 2
};

// The valid values found in Ehdr e_ident[EI_VERSION] and e_version.

enum
{
  EV_NONE = 0,
  EV_CURRENT = 1
};

// The valid values found in Ehdr e_ident[EI_OSABI].

enum ELFOSABI
{
  ELFOSABI_NONE = 0,
  ELFOSABI_HPUX = 1,
  ELFOSABI_NETBSD = 2,
  ELFOSABI_GNU = 3,
  // ELFOSABI_LINUX is an alias for ELFOSABI_GNU.
  ELFOSABI_LINUX = 3,
  ELFOSABI_SOLARIS = 6,
  ELFOSABI_AIX = 7,
  ELFOSABI_IRIX = 8,
  ELFOSABI_FREEBSD = 9,
  ELFOSABI_TRU64 = 10,
  ELFOSABI_MODESTO = 11,
  ELFOSABI_OPENBSD = 12,
  ELFOSABI_OPENVMS = 13,
  ELFOSABI_NSK = 14,
  ELFOSABI_AROS = 15,
  // A GNU extension for the ARM.
  ELFOSABI_ARM = 97,
  // A GNU extension for the MSP.
  ELFOSABI_STANDALONE = 255
};

// The valid values found in the Ehdr e_type field.

enum ET
{
  ET_NONE = 0,
  ET_REL = 1,
  ET_EXEC = 2,
  ET_DYN = 3,
  ET_CORE = 4,
  ET_LOOS = 0xfe00,
  ET_HIOS = 0xfeff,
  ET_LOPROC = 0xff00,
  ET_HIPROC = 0xffff
};

// The valid values found in the Ehdr e_machine field.

enum EM
{
  EM_NONE = 0,
  EM_M32 = 1,
  EM_SPARC = 2,
  EM_386 = 3,
  EM_68K = 4,
  EM_88K = 5,
  // 6 used to be EM_486
  EM_860 = 7,
  EM_MIPS = 8,
  EM_S370 = 9,
  EM_MIPS_RS3_LE = 10,
  // 11 was the old Sparc V9 ABI.
  // 12 through 14 are reserved.
  EM_PARISC = 15,
  // 16 is reserved.
  // Some old PowerPC object files use 17.
  EM_VPP500 = 17,
  EM_SPARC32PLUS = 18,
  EM_960 = 19,
  EM_PPC = 20,
  EM_PPC64 = 21,
  EM_S390 = 22,
  // 23 through 35 are served.
  EM_V800 = 36,
  EM_FR20 = 37,
  EM_RH32 = 38,
  EM_RCE = 39,
  EM_ARM = 40,
  EM_ALPHA = 41,
  EM_SH = 42,
  EM_SPARCV9 = 43,
  EM_TRICORE = 44,
  EM_ARC = 45,
  EM_H8_300 = 46,
  EM_H8_300H = 47,
  EM_H8S = 48,
  EM_H8_500 = 49,
  EM_IA_64 = 50,
  EM_MIPS_X = 51,
  EM_COLDFIRE = 52,
  EM_68HC12 = 53,
  EM_MMA = 54,
  EM_PCP = 55,
  EM_NCPU = 56,
  EM_NDR1 = 57,
  EM_STARCORE = 58,
  EM_ME16 = 59,
  EM_ST100 = 60,
  EM_TINYJ = 61,
  EM_X86_64 = 62,
  EM_PDSP = 63,
  EM_PDP10 = 64,
  EM_PDP11 = 65,
  EM_FX66 = 66,
  EM_ST9PLUS = 67,
  EM_ST7 = 68,
  EM_68HC16 = 69,
  EM_68HC11 = 70,
  EM_68HC08 = 71,
  EM_68HC05 = 72,
  EM_SVX = 73,
  EM_ST19 = 74,
  EM_VAX = 75,
  EM_CRIS = 76,
  EM_JAVELIN = 77,
  EM_FIREPATH = 78,
  EM_ZSP = 79,
  EM_MMIX = 80,
  EM_HUANY = 81,
  EM_PRISM = 82,
  EM_AVR = 83,
  EM_FR30 = 84,
  EM_D10V = 85,
  EM_D30V = 86,
  EM_V850 = 87,
  EM_M32R = 88,
  EM_MN10300 = 89,
  EM_MN10200 = 90,
  EM_PJ = 91,
  EM_OPENRISC = 92,
  EM_ARC_A5 = 93,
  EM_XTENSA = 94,
  EM_VIDEOCORE = 95,
  EM_TMM_GPP = 96,
  EM_NS32K = 97,
  EM_TPC = 98,
  // Some old picoJava object files use 99 (EM_PJ is correct).
  EM_SNP1K = 99,
  EM_ST200 = 100,
  EM_IP2K = 101,
  EM_MAX = 102,
  EM_CR = 103,
  EM_F2MC16 = 104,
  EM_MSP430 = 105,
  EM_BLACKFIN = 106,
  EM_SE_C33 = 107,
  EM_SEP = 108,
  EM_ARCA = 109,
  EM_UNICORE = 110,
  EM_ALTERA_NIOS2 = 113,
  EM_CRX = 114,
  EM_TILEGX = 191,
  // The Morph MT.
  EM_MT = 0x2530,
  // DLX.
  EM_DLX = 0x5aa5,
  // FRV.
  EM_FRV = 0x5441,
  // Infineon Technologies 16-bit microcontroller with C166-V2 core.
  EM_X16X = 0x4688,
  // Xstorym16
  EM_XSTORMY16 = 0xad45,
  // Renesas M32C
  EM_M32C = 0xfeb0,
  // Vitesse IQ2000
  EM_IQ2000 = 0xfeba,
  // NIOS
  EM_NIOS32 = 0xfebb
  // Old AVR objects used 0x1057 (EM_AVR is correct).
  // Old MSP430 objects used 0x1059 (EM_MSP430 is correct).
  // Old FR30 objects used 0x3330 (EM_FR30 is correct).
  // Old OpenRISC objects used 0x3426 and 0x8472 (EM_OPENRISC is correct).
  // Old D10V objects used 0x7650 (EM_D10V is correct).
  // Old D30V objects used 0x7676 (EM_D30V is correct).
  // Old IP2X objects used 0x8217 (EM_IP2K is correct).
  // Old PowerPC objects used 0x9025 (EM_PPC is correct).
  // Old Alpha objects used 0x9026 (EM_ALPHA is correct).
  // Old M32R objects used 0x9041 (EM_M32R is correct).
  // Old V850 objects used 0x9080 (EM_V850 is correct).
  // Old S/390 objects used 0xa390 (EM_S390 is correct).
  // Old Xtensa objects used 0xabc7 (EM_XTENSA is correct).
  // Old MN10300 objects used 0xbeef (EM_MN10300 is correct).
  // Old MN10200 objects used 0xdead (EM_MN10200 is correct).
};

// A special value found in the Ehdr e_phnum field.

enum
{
  // Number of program segments stored in sh_info field of first
  // section headre.
  PN_XNUM = 0xffff
};

// Special section indices.

enum
{
  SHN_UNDEF = 0,
  SHN_LORESERVE = 0xff00,
  SHN_LOPROC = 0xff00,
  SHN_HIPROC = 0xff1f,
  SHN_LOOS = 0xff20,
  SHN_HIOS = 0xff3f,
  SHN_ABS = 0xfff1,
  SHN_COMMON = 0xfff2,
  SHN_XINDEX = 0xffff,
  SHN_HIRESERVE = 0xffff,

  // Provide for initial and final section ordering in conjunction
  // with the SHF_LINK_ORDER and SHF_ORDERED section flags.
  SHN_BEFORE = 0xff00,
  SHN_AFTER = 0xff01,

  // x86_64 specific large common symbol.
  SHN_X86_64_LCOMMON = 0xff02
};

// The valid values found in the Shdr sh_type field.

enum SHT
{
  SHT_NULL = 0,
  SHT_PROGBITS = 1,
  SHT_SYMTAB = 2,
  SHT_STRTAB = 3,
  SHT_RELA = 4,
  SHT_HASH = 5,
  SHT_DYNAMIC = 6,
  SHT_NOTE = 7,
  SHT_NOBITS = 8,
  SHT_REL = 9,
  SHT_SHLIB = 10,
  SHT_DYNSYM = 11,
  SHT_INIT_ARRAY = 14,
  SHT_FINI_ARRAY = 15,
  SHT_PREINIT_ARRAY = 16,
  SHT_GROUP = 17,
  SHT_SYMTAB_SHNDX = 18,
  SHT_LOOS = 0x60000000,
  SHT_HIOS = 0x6fffffff,
  SHT_LOPROC = 0x70000000,
  SHT_HIPROC = 0x7fffffff,
  SHT_LOUSER = 0x80000000,
  SHT_HIUSER = 0xffffffff,
  // The remaining values are not in the standard.
  // Incremental build data.
  SHT_GNU_INCREMENTAL_INPUTS = 0x6fff4700,
  SHT_GNU_INCREMENTAL_SYMTAB = 0x6fff4701,
  SHT_GNU_INCREMENTAL_RELOCS = 0x6fff4702,
  SHT_GNU_INCREMENTAL_GOT_PLT = 0x6fff4703,
  // Object attributes.
  SHT_GNU_ATTRIBUTES = 0x6ffffff5,
  // GNU style dynamic hash table.
  SHT_GNU_HASH = 0x6ffffff6,
  // List of prelink dependencies.
  SHT_GNU_LIBLIST = 0x6ffffff7,
  // Versions defined by file.
  SHT_SUNW_verdef = 0x6ffffffd,
  SHT_GNU_verdef = 0x6ffffffd,
  // Versions needed by file.
  SHT_SUNW_verneed = 0x6ffffffe,
  SHT_GNU_verneed = 0x6ffffffe,
  // Symbol versions,
  SHT_SUNW_versym = 0x6fffffff,
  SHT_GNU_versym = 0x6fffffff,

  SHT_SPARC_GOTDATA = 0x70000000,

  // ARM-specific section types.
  // Exception Index table.
  SHT_ARM_EXIDX = 0x70000001,
  // BPABI DLL dynamic linking pre-emption map.
  SHT_ARM_PREEMPTMAP = 0x70000002,
  // Object file compatibility attributes.
  SHT_ARM_ATTRIBUTES = 0x70000003,
  // Support for debugging overlaid programs.
  SHT_ARM_DEBUGOVERLAY = 0x70000004,
  SHT_ARM_OVERLAYSECTION = 0x70000005,

  // x86_64 unwind information.
  SHT_X86_64_UNWIND = 0x70000001,

  //MIPS-specific section types.
  // Register info section
  SHT_MIPS_REGINFO = 0x70000006,

  // Link editor is to sort the entries in this section based on the
  // address specified in the associated symbol table entry.
  SHT_ORDERED = 0x7fffffff
};

// The valid bit flags found in the Shdr sh_flags field.

enum SHF
{
  SHF_WRITE = 0x1,
  SHF_ALLOC = 0x2,
  SHF_EXECINSTR = 0x4,
  SHF_MERGE = 0x10,
  SHF_STRINGS = 0x20,
  SHF_INFO_LINK = 0x40,
  SHF_LINK_ORDER = 0x80,
  SHF_OS_NONCONFORMING = 0x100,
  SHF_GROUP = 0x200,
  SHF_TLS = 0x400,
  SHF_MASKOS = 0x0ff00000,
  SHF_MASKPROC = 0xf0000000,

  // Indicates this section requires ordering in relation to
  // other sections of the same type.  Ordered sections are
  // combined within the section pointed to by the sh_link entry.
  // The sh_info values SHN_BEFORE and SHN_AFTER imply that the
  // sorted section is to precede or follow, respectively, all
  // other sections in the set being ordered.
  SHF_ORDERED = 0x40000000,
  // This section is excluded from input to the link-edit of an
  // executable or shared object.  This flag is ignored if SHF_ALLOC
  // is also set, or if relocations exist against the section.
  SHF_EXCLUDE = 0x80000000,

  // Section with data that is GP relative addressable.
  SHF_MIPS_GPREL = 0x10000000,

  // x86_64 specific large section.
  SHF_X86_64_LARGE = 0x10000000
};

// Bit flags which appear in the first 32-bit word of the section data
// of a SHT_GROUP section.

enum
{
  GRP_COMDAT = 0x1,
  GRP_MASKOS = 0x0ff00000,
  GRP_MASKPROC = 0xf0000000
};

// The valid values found in the Phdr p_type field.

enum PT
{
  PT_NULL = 0,
  PT_LOAD = 1,
  PT_DYNAMIC = 2,
  PT_INTERP = 3,
  PT_NOTE = 4,
  PT_SHLIB = 5,
  PT_PHDR = 6,
  PT_TLS = 7,
  PT_LOOS = 0x60000000,
  PT_HIOS = 0x6fffffff,
  PT_LOPROC = 0x70000000,
  PT_HIPROC = 0x7fffffff,
  // The remaining values are not in the standard.
  // Frame unwind information.
  PT_GNU_EH_FRAME = 0x6474e550,
  PT_SUNW_EH_FRAME = 0x6474e550,
  // Stack flags.
  PT_GNU_STACK = 0x6474e551,
  // Read only after relocation.
  PT_GNU_RELRO = 0x6474e552,
  // Platform architecture compatibility information
  PT_ARM_ARCHEXT = 0x70000000,
  // Exception unwind tables
  PT_ARM_EXIDX = 0x70000001,
  // Register usage information.  Identifies one .reginfo section.
  PT_MIPS_REGINFO =0x70000000,
  // Runtime procedure table.
  PT_MIPS_RTPROC = 0x70000001,
  // .MIPS.options section.
  PT_MIPS_OPTIONS = 0x70000002
};

// The valid bit flags found in the Phdr p_flags field.

enum PF
{
  PF_X = 0x1,
  PF_W = 0x2,
  PF_R = 0x4,
  PF_MASKOS = 0x0ff00000,
  PF_MASKPROC = 0xf0000000
};

// Symbol binding from Sym st_info field.

enum STB
{
  STB_LOCAL = 0,
  STB_GLOBAL = 1,
  STB_WEAK = 2,
  STB_LOOS = 10,
  STB_GNU_UNIQUE = 10,
  STB_HIOS = 12,
  STB_LOPROC = 13,
  STB_HIPROC = 15
};

// Symbol types from Sym st_info field.

enum STT
{
  STT_NOTYPE = 0,
  STT_OBJECT = 1,
  STT_FUNC = 2,
  STT_SECTION = 3,
  STT_FILE = 4,
  STT_COMMON = 5,
  STT_TLS = 6,

  // GNU extension: symbol value points to a function which is called
  // at runtime to determine the final value of the symbol.
  STT_GNU_IFUNC = 10,

  STT_LOOS = 10,
  STT_HIOS = 12,
  STT_LOPROC = 13,
  STT_HIPROC = 15,

  // The section type that must be used for register symbols on
  // Sparc.  These symbols initialize a global register.
  STT_SPARC_REGISTER = 13,

  // ARM: a THUMB function.  This is not defined in ARM ELF Specification but
  // used by the GNU tool-chain.
  STT_ARM_TFUNC = 13
};

inline STB
elf_st_bind(unsigned char info)
{
  return static_cast<STB>(info >> 4);
}

inline STT
elf_st_type(unsigned char info)
{
  return static_cast<STT>(info & 0xf);
}

inline unsigned char
elf_st_info(STB bind, STT type)
{
  return ((static_cast<unsigned char>(bind) << 4)
	  + (static_cast<unsigned char>(type) & 0xf));
}

// Symbol visibility from Sym st_other field.

enum STV
{
  STV_DEFAULT = 0,
  STV_INTERNAL = 1,
  STV_HIDDEN = 2,
  STV_PROTECTED = 3
};

inline STV
elf_st_visibility(unsigned char other)
{
  return static_cast<STV>(other & 0x3);
}

inline unsigned char
elf_st_nonvis(unsigned char other)
{
  return static_cast<STV>(other >> 2);
}

inline unsigned char
elf_st_other(STV vis, unsigned char nonvis)
{
  return ((nonvis << 2)
	  + (static_cast<unsigned char>(vis) & 3));
}

// Reloc information from Rel/Rela r_info field.

template<int size>
unsigned int
elf_r_sym(typename Elf_types<size>::Elf_WXword);

template<>
inline unsigned int
elf_r_sym<32>(Elf_Word v)
{
  return v >> 8;
}

template<>
inline unsigned int
elf_r_sym<64>(Elf_Xword v)
{
  return v >> 32;
}

template<int size>
unsigned int
elf_r_type(typename Elf_types<size>::Elf_WXword);

template<>
inline unsigned int
elf_r_type<32>(Elf_Word v)
{
  return v & 0xff;
}

template<>
inline unsigned int
elf_r_type<64>(Elf_Xword v)
{
  return v & 0xffffffff;
}

template<int size>
typename Elf_types<size>::Elf_WXword
elf_r_info(unsigned int s, unsigned int t);

template<>
inline Elf_Word
elf_r_info<32>(unsigned int s, unsigned int t)
{
  return (s << 8) + (t & 0xff);
}

template<>
inline Elf_Xword
elf_r_info<64>(unsigned int s, unsigned int t)
{
  return (static_cast<Elf_Xword>(s) << 32) + (t & 0xffffffff);
}

// Dynamic tags found in the PT_DYNAMIC segment.

enum DT
{
  DT_NULL = 0,
  DT_NEEDED = 1,
  DT_PLTRELSZ = 2,
  DT_PLTGOT = 3,
  DT_HASH = 4,
  DT_STRTAB = 5,
  DT_SYMTAB = 6,
  DT_RELA = 7,
  DT_RELASZ = 8,
  DT_RELAENT = 9,
  DT_STRSZ = 10,
  DT_SYMENT = 11,
  DT_INIT = 12,
  DT_FINI = 13,
  DT_SONAME = 14,
  DT_RPATH = 15,
  DT_SYMBOLIC = 16,
  DT_REL = 17,
  DT_RELSZ = 18,
  DT_RELENT = 19,
  DT_PLTREL = 20,
  DT_DEBUG = 21,
  DT_TEXTREL = 22,
  DT_JMPREL = 23,
  DT_BIND_NOW = 24,
  DT_INIT_ARRAY = 25,
  DT_FINI_ARRAY = 26,
  DT_INIT_ARRAYSZ = 27,
  DT_FINI_ARRAYSZ = 28,
  DT_RUNPATH = 29,
  DT_FLAGS = 30,

  // This is used to mark a range of dynamic tags.  It is not really
  // a tag value.
  DT_ENCODING = 32,

  DT_PREINIT_ARRAY = 32,
  DT_PREINIT_ARRAYSZ = 33,
  DT_LOOS = 0x6000000d,
  DT_HIOS = 0x6ffff000,
  DT_LOPROC = 0x70000000,
  DT_HIPROC = 0x7fffffff,

  // The remaining values are extensions used by GNU or Solaris.
  DT_VALRNGLO = 0x6ffffd00,
  DT_GNU_PRELINKED = 0x6ffffdf5,
  DT_GNU_CONFLICTSZ = 0x6ffffdf6,
  DT_GNU_LIBLISTSZ = 0x6ffffdf7,
  DT_CHECKSUM = 0x6ffffdf8,
  DT_PLTPADSZ = 0x6ffffdf9,
  DT_MOVEENT = 0x6ffffdfa,
  DT_MOVESZ = 0x6ffffdfb,
  DT_FEATURE = 0x6ffffdfc,
  DT_POSFLAG_1 = 0x6ffffdfd,
  DT_SYMINSZ = 0x6ffffdfe,
  DT_SYMINENT = 0x6ffffdff,
  DT_VALRNGHI = 0x6ffffdff,

  DT_ADDRRNGLO = 0x6ffffe00,
  DT_GNU_HASH = 0x6ffffef5,
  DT_TLSDESC_PLT = 0x6ffffef6,
  DT_TLSDESC_GOT = 0x6ffffef7,
  DT_GNU_CONFLICT = 0x6ffffef8,
  DT_GNU_LIBLIST = 0x6ffffef9,
  DT_CONFIG = 0x6ffffefa,
  DT_DEPAUDIT = 0x6ffffefb,
  DT_AUDIT = 0x6ffffefc,
  DT_PLTPAD = 0x6ffffefd,
  DT_MOVETAB = 0x6ffffefe,
  DT_SYMINFO = 0x6ffffeff,
  DT_ADDRRNGHI = 0x6ffffeff,

  DT_RELACOUNT = 0x6ffffff9,
  DT_RELCOUNT = 0x6ffffffa,
  DT_FLAGS_1 = 0x6ffffffb,
  DT_VERDEF = 0x6ffffffc,
  DT_VERDEFNUM = 0x6ffffffd,
  DT_VERNEED = 0x6ffffffe,
  DT_VERNEEDNUM = 0x6fffffff,

  DT_VERSYM = 0x6ffffff0,

  // Specify the value of _GLOBAL_OFFSET_TABLE_.
  DT_PPC_GOT = 0x70000000,

  // Specify the start of the .glink section.
  DT_PPC64_GLINK = 0x70000000,

  // Specify the start and size of the .opd section.
  DT_PPC64_OPD = 0x70000001,
  DT_PPC64_OPDSZ = 0x70000002,

  // The index of an STT_SPARC_REGISTER symbol within the DT_SYMTAB
  // symbol table.  One dynamic entry exists for every STT_SPARC_REGISTER
  // symbol in the symbol table.
  DT_SPARC_REGISTER = 0x70000001,

  // MIPS specific dynamic array tags.
  // 32 bit version number for runtime linker interface.
  DT_MIPS_RLD_VERSION = 0x70000001,
  // Time stamp.
  DT_MIPS_TIME_STAMP = 0x70000002,
  // Checksum of external strings and common sizes.
  DT_MIPS_ICHECKSUM = 0x70000003,
  // Index of version string in string table.
  DT_MIPS_IVERSION = 0x70000004,
  // 32 bits of flags.
  DT_MIPS_FLAGS = 0x70000005,
  // Base address of the segment.
  DT_MIPS_BASE_ADDRESS = 0x70000006,
  // ???
  DT_MIPS_MSYM = 0x70000007,
  // Address of .conflict section.
  DT_MIPS_CONFLICT = 0x70000008,
  // Address of .liblist section.
  DT_MIPS_LIBLIST = 0x70000009,
  // Number of local global offset table entries.
  DT_MIPS_LOCAL_GOTNO = 0x7000000a,
  // Number of entries in the .conflict section.
  DT_MIPS_CONFLICTNO = 0x7000000b,
  // Number of entries in the .liblist section.
  DT_MIPS_LIBLISTNO = 0x70000010,
  // Number of entries in the .dynsym section.
  DT_MIPS_SYMTABNO = 0x70000011,
  // Index of first external dynamic symbol not referenced locally.
  DT_MIPS_UNREFEXTNO = 0x70000012,
  // Index of first dynamic symbol in global offset table.
  DT_MIPS_GOTSYM = 0x70000013,
  // Number of page table entries in global offset table.
  DT_MIPS_HIPAGENO = 0x70000014,
  // Address of run time loader map, used for debugging.
  DT_MIPS_RLD_MAP = 0x70000016,
  // Delta C++ class definition.
  DT_MIPS_DELTA_CLASS = 0x70000017,
  // Number of entries in DT_MIPS_DELTA_CLASS.
  DT_MIPS_DELTA_CLASS_NO = 0x70000018,
  // Delta C++ class instances.
  DT_MIPS_DELTA_INSTANCE = 0x70000019,
  // Number of entries in DT_MIPS_DELTA_INSTANCE.
  DT_MIPS_DELTA_INSTANCE_NO = 0x7000001a,
  // Delta relocations.
  DT_MIPS_DELTA_RELOC = 0x7000001b,
  // Number of entries in DT_MIPS_DELTA_RELOC.
  DT_MIPS_DELTA_RELOC_NO = 0x7000001c,
  // Delta symbols that Delta relocations refer to.
  DT_MIPS_DELTA_SYM = 0x7000001d,
  // Number of entries in DT_MIPS_DELTA_SYM.
  DT_MIPS_DELTA_SYM_NO = 0x7000001e,
  // Delta symbols that hold class declarations.
  DT_MIPS_DELTA_CLASSSYM = 0x70000020,
  // Number of entries in DT_MIPS_DELTA_CLASSSYM.
  DT_MIPS_DELTA_CLASSSYM_NO = 0x70000021,
  // Flags indicating information about C++ flavor.
  DT_MIPS_CXX_FLAGS = 0x70000022,
  // Pixie information (???).
  DT_MIPS_PIXIE_INIT = 0x70000023,
  // Address of .MIPS.symlib
  DT_MIPS_SYMBOL_LIB = 0x70000024,
  // The GOT index of the first PTE for a segment
  DT_MIPS_LOCALPAGE_GOTIDX = 0x70000025,
  // The GOT index of the first PTE for a local symbol
  DT_MIPS_LOCAL_GOTIDX = 0x70000026,
  // The GOT index of the first PTE for a hidden symbol
  DT_MIPS_HIDDEN_GOTIDX = 0x70000027,
  // The GOT index of the first PTE for a protected symbol
  DT_MIPS_PROTECTED_GOTIDX = 0x70000028,
  // Address of `.MIPS.options'.
  DT_MIPS_OPTIONS = 0x70000029,
  // Address of `.interface'.
  DT_MIPS_INTERFACE = 0x7000002a,
  // ???
  DT_MIPS_DYNSTR_ALIGN = 0x7000002b,
  // Size of the .interface section.
  DT_MIPS_INTERFACE_SIZE = 0x7000002c,
  // Size of rld_text_resolve function stored in the GOT.
  DT_MIPS_RLD_TEXT_RESOLVE_ADDR = 0x7000002d,
  // Default suffix of DSO to be added by rld on dlopen() calls.
  DT_MIPS_PERF_SUFFIX = 0x7000002e,
  // Size of compact relocation section (O32).
  DT_MIPS_COMPACT_SIZE = 0x7000002f,
  // GP value for auxiliary GOTs.
  DT_MIPS_GP_VALUE = 0x70000030,
  // Address of auxiliary .dynamic.
  DT_MIPS_AUX_DYNAMIC = 0x70000031,
  // Address of the base of the PLTGOT.
  DT_MIPS_PLTGOT = 0x70000032,
  // Points to the base of a writable PLT.
  DT_MIPS_RWPLT = 0x70000034,

  DT_AUXILIARY = 0x7ffffffd,
  DT_USED = 0x7ffffffe,
  DT_FILTER = 0x7fffffff
};

// Flags found in the DT_FLAGS dynamic element.

enum DF
{
  DF_ORIGIN = 0x1,
  DF_SYMBOLIC = 0x2,
  DF_TEXTREL = 0x4,
  DF_BIND_NOW = 0x8,
  DF_STATIC_TLS = 0x10
};

// Flags found in the DT_FLAGS_1 dynamic element.

enum DF_1
{
  DF_1_NOW = 0x1,
  DF_1_GLOBAL = 0x2,
  DF_1_GROUP = 0x4,
  DF_1_NODELETE = 0x8,
  DF_1_LOADFLTR = 0x10,
  DF_1_INITFIRST = 0x20,
  DF_1_NOOPEN = 0x40,
  DF_1_ORIGIN = 0x80,
  DF_1_DIRECT = 0x100,
  DF_1_TRANS = 0x200,
  DF_1_INTERPOSE = 0x400,
  DF_1_NODEFLIB = 0x800,
  DF_1_NODUMP = 0x1000,
  DF_1_CONLFAT = 0x2000
};

// Version numbers which appear in the vd_version field of a Verdef
// structure.

const int VER_DEF_NONE = 0;
const int VER_DEF_CURRENT = 1;

// Version numbers which appear in the vn_version field of a Verneed
// structure.

const int VER_NEED_NONE = 0;
const int VER_NEED_CURRENT = 1;

// Bit flags which appear in vd_flags of Verdef and vna_flags of
// Vernaux.

const int VER_FLG_BASE = 0x1;
const int VER_FLG_WEAK = 0x2;
const int VER_FLG_INFO = 0x4;

// Special constants found in the SHT_GNU_versym entries.

const int VER_NDX_LOCAL = 0;
const int VER_NDX_GLOBAL = 1;

// A SHT_GNU_versym section holds 16-bit words.  This bit is set if
// the symbol is hidden and can only be seen when referenced using an
// explicit version number.  This is a GNU extension.

const int VERSYM_HIDDEN = 0x8000;

// This is the mask for the rest of the data in a word read from a
// SHT_GNU_versym section.

const int VERSYM_VERSION = 0x7fff;

// Note descriptor type codes for notes in a non-core file with an
// empty name.

enum
{
  // A version string.
  NT_VERSION = 1,
  // An architecture string.
  NT_ARCH = 2
};

// Note descriptor type codes for notes in a non-core file with the
// name "GNU".

enum
{
  // The minimum ABI level.  This is used by the dynamic linker to
  // describe the minimal kernel version on which a shared library may
  // be used.  Th value should be four words.  Word 0 is an OS
  // descriptor (see below).  Word 1 is the major version of the ABI.
  // Word 2 is the minor version.  Word 3 is the subminor version.
  NT_GNU_ABI_TAG = 1,
  // Hardware capabilities information.  Word 0 is the number of
  // entries.  Word 1 is a bitmask of enabled entries.  The rest of
  // the descriptor is a series of entries, where each entry is a
  // single byte followed by a nul terminated string.  The byte gives
  // the bit number to test if enabled in the bitmask.
  NT_GNU_HWCAP = 2,
  // The build ID as set by the linker's --build-id option.  The
  // format of the descriptor depends on the build ID style.
  NT_GNU_BUILD_ID = 3,
  // The version of gold used to link.  Th descriptor is just a
  // string.
  NT_GNU_GOLD_VERSION = 4
};

// The OS values which may appear in word 0 of a NT_GNU_ABI_TAG note.

enum
{
  ELF_NOTE_OS_LINUX = 0,
  ELF_NOTE_OS_GNU = 1,
  ELF_NOTE_OS_SOLARIS2 = 2,
  ELF_NOTE_OS_FREEBSD = 3,
  ELF_NOTE_OS_NETBSD = 4,
  ELF_NOTE_OS_SYLLABLE = 5
};

} // End namespace elfcpp.

// Include internal details after defining the types.
#include "elfcpp_internal.h"

namespace elfcpp
{

// The offset of the ELF file header in the ELF file.

const int file_header_offset = 0;

// ELF structure sizes.

template<int size>
struct Elf_sizes
{
  // Size of ELF file header.
  static const int ehdr_size = sizeof(internal::Ehdr_data<size>);
  // Size of ELF segment header.
  static const int phdr_size = sizeof(internal::Phdr_data<size>);
  // Size of ELF section header.
  static const int shdr_size = sizeof(internal::Shdr_data<size>);
  // Size of ELF symbol table entry.
  static const int sym_size = sizeof(internal::Sym_data<size>);
  // Sizes of ELF reloc entries.
  static const int rel_size = sizeof(internal::Rel_data<size>);
  static const int rela_size = sizeof(internal::Rela_data<size>);
  // Size of ELF dynamic entry.
  static const int dyn_size = sizeof(internal::Dyn_data<size>);
  // Size of ELF version structures.
  static const int verdef_size = sizeof(internal::Verdef_data);
  static const int verdaux_size = sizeof(internal::Verdaux_data);
  static const int verneed_size = sizeof(internal::Verneed_data);
  static const int vernaux_size = sizeof(internal::Vernaux_data);
};

// Accessor class for the ELF file header.

template<int size, bool big_endian>
class Ehdr
{
 public:
  Ehdr(const unsigned char* p)
    : p_(reinterpret_cast<const internal::Ehdr_data<size>*>(p))
  { }

  template<typename File>
  Ehdr(File* file, typename File::Location loc)
    : p_(reinterpret_cast<const internal::Ehdr_data<size>*>(
	   file->view(loc.file_offset, loc.data_size).data()))
  { }

  const unsigned char*
  get_e_ident() const
  { return this->p_->e_ident; }

  Elf_Half
  get_e_type() const
  { return Convert<16, big_endian>::convert_host(this->p_->e_type); }

  Elf_Half
  get_e_machine() const
  { return Convert<16, big_endian>::convert_host(this->p_->e_machine); }

  Elf_Word
  get_e_version() const
  { return Convert<32, big_endian>::convert_host(this->p_->e_version); }

  typename Elf_types<size>::Elf_Addr
  get_e_entry() const
  { return Convert<size, big_endian>::convert_host(this->p_->e_entry); }

  typename Elf_types<size>::Elf_Off
  get_e_phoff() const
  { return Convert<size, big_endian>::convert_host(this->p_->e_phoff); }

  typename Elf_types<size>::Elf_Off
  get_e_shoff() const
  { return Convert<size, big_endian>::convert_host(this->p_->e_shoff); }

  Elf_Word
  get_e_flags() const
  { return Convert<32, big_endian>::convert_host(this->p_->e_flags); }

  Elf_Half
  get_e_ehsize() const
  { return Convert<16, big_endian>::convert_host(this->p_->e_ehsize); }

  Elf_Half
  get_e_phentsize() const
  { return Convert<16, big_endian>::convert_host(this->p_->e_phentsize); }

  Elf_Half
  get_e_phnum() const
  { return Convert<16, big_endian>::convert_host(this->p_->e_phnum); }

  Elf_Half
  get_e_shentsize() const
  { return Convert<16, big_endian>::convert_host(this->p_->e_shentsize); }

  Elf_Half
  get_e_shnum() const
  { return Convert<16, big_endian>::convert_host(this->p_->e_shnum); }

  Elf_Half
  get_e_shstrndx() const
  { return Convert<16, big_endian>::convert_host(this->p_->e_shstrndx); }

 private:
  const internal::Ehdr_data<size>* p_;
};

// Write class for the ELF file header.

template<int size, bool big_endian>
class Ehdr_write
{
 public:
  Ehdr_write(unsigned char* p)
    : p_(reinterpret_cast<internal::Ehdr_data<size>*>(p))
  { }

  void
  put_e_ident(const unsigned char v[EI_NIDENT]) const
  { memcpy(this->p_->e_ident, v, EI_NIDENT); }

  void
  put_e_type(Elf_Half v)
  { this->p_->e_type = Convert<16, big_endian>::convert_host(v); }

  void
  put_e_machine(Elf_Half v)
  { this->p_->e_machine = Convert<16, big_endian>::convert_host(v); }

  void
  put_e_version(Elf_Word v)
  { this->p_->e_version = Convert<32, big_endian>::convert_host(v); }

  void
  put_e_entry(typename Elf_types<size>::Elf_Addr v)
  { this->p_->e_entry = Convert<size, big_endian>::convert_host(v); }

  void
  put_e_phoff(typename Elf_types<size>::Elf_Off v)
  { this->p_->e_phoff = Convert<size, big_endian>::convert_host(v); }

  void
  put_e_shoff(typename Elf_types<size>::Elf_Off v)
  { this->p_->e_shoff = Convert<size, big_endian>::convert_host(v); }

  void
  put_e_flags(Elf_Word v)
  { this->p_->e_flags = Convert<32, big_endian>::convert_host(v); }

  void
  put_e_ehsize(Elf_Half v)
  { this->p_->e_ehsize = Convert<16, big_endian>::convert_host(v); }

  void
  put_e_phentsize(Elf_Half v)
  { this->p_->e_phentsize = Convert<16, big_endian>::convert_host(v); }

  void
  put_e_phnum(Elf_Half v)
  { this->p_->e_phnum = Convert<16, big_endian>::convert_host(v); }

  void
  put_e_shentsize(Elf_Half v)
  { this->p_->e_shentsize = Convert<16, big_endian>::convert_host(v); }

  void
  put_e_shnum(Elf_Half v)
  { this->p_->e_shnum = Convert<16, big_endian>::convert_host(v); }

  void
  put_e_shstrndx(Elf_Half v)
  { this->p_->e_shstrndx = Convert<16, big_endian>::convert_host(v); }

 private:
  internal::Ehdr_data<size>* p_;
};

// Accessor class for an ELF section header.

template<int size, bool big_endian>
class Shdr
{
 public:
  Shdr(const unsigned char* p)
    : p_(reinterpret_cast<const internal::Shdr_data<size>*>(p))
  { }

  template<typename File>
  Shdr(File* file, typename File::Location loc)
    : p_(reinterpret_cast<const internal::Shdr_data<size>*>(
	   file->view(loc.file_offset, loc.data_size).data()))
  { }

  Elf_Word
  get_sh_name() const
  { return Convert<32, big_endian>::convert_host(this->p_->sh_name); }

  Elf_Word
  get_sh_type() const
  { return Convert<32, big_endian>::convert_host(this->p_->sh_type); }

  typename Elf_types<size>::Elf_WXword
  get_sh_flags() const
  { return Convert<size, big_endian>::convert_host(this->p_->sh_flags); }

  typename Elf_types<size>::Elf_Addr
  get_sh_addr() const
  { return Convert<size, big_endian>::convert_host(this->p_->sh_addr); }

  typename Elf_types<size>::Elf_Off
  get_sh_offset() const
  { return Convert<size, big_endian>::convert_host(this->p_->sh_offset); }

  typename Elf_types<size>::Elf_WXword
  get_sh_size() const
  { return Convert<size, big_endian>::convert_host(this->p_->sh_size); }

  Elf_Word
  get_sh_link() const
  { return Convert<32, big_endian>::convert_host(this->p_->sh_link); }

  Elf_Word
  get_sh_info() const
  { return Convert<32, big_endian>::convert_host(this->p_->sh_info); }

  typename Elf_types<size>::Elf_WXword
  get_sh_addralign() const
  { return
      Convert<size, big_endian>::convert_host(this->p_->sh_addralign); }

  typename Elf_types<size>::Elf_WXword
  get_sh_entsize() const
  { return Convert<size, big_endian>::convert_host(this->p_->sh_entsize); }

 private:
  const internal::Shdr_data<size>* p_;
};

// Write class for an ELF section header.

template<int size, bool big_endian>
class Shdr_write
{
 public:
  Shdr_write(unsigned char* p)
    : p_(reinterpret_cast<internal::Shdr_data<size>*>(p))
  { }

  void
  put_sh_name(Elf_Word v)
  { this->p_->sh_name = Convert<32, big_endian>::convert_host(v); }

  void
  put_sh_type(Elf_Word v)
  { this->p_->sh_type = Convert<32, big_endian>::convert_host(v); }

  void
  put_sh_flags(typename Elf_types<size>::Elf_WXword v)
  { this->p_->sh_flags = Convert<size, big_endian>::convert_host(v); }

  void
  put_sh_addr(typename Elf_types<size>::Elf_Addr v)
  { this->p_->sh_addr = Convert<size, big_endian>::convert_host(v); }

  void
  put_sh_offset(typename Elf_types<size>::Elf_Off v)
  { this->p_->sh_offset = Convert<size, big_endian>::convert_host(v); }

  void
  put_sh_size(typename Elf_types<size>::Elf_WXword v)
  { this->p_->sh_size = Convert<size, big_endian>::convert_host(v); }

  void
  put_sh_link(Elf_Word v)
  { this->p_->sh_link = Convert<32, big_endian>::convert_host(v); }

  void
  put_sh_info(Elf_Word v)
  { this->p_->sh_info = Convert<32, big_endian>::convert_host(v); }

  void
  put_sh_addralign(typename Elf_types<size>::Elf_WXword v)
  { this->p_->sh_addralign = Convert<size, big_endian>::convert_host(v); }

  void
  put_sh_entsize(typename Elf_types<size>::Elf_WXword v)
  { this->p_->sh_entsize = Convert<size, big_endian>::convert_host(v); }

 private:
  internal::Shdr_data<size>* p_;
};

// Accessor class for an ELF segment header.

template<int size, bool big_endian>
class Phdr
{
 public:
  Phdr(const unsigned char* p)
    : p_(reinterpret_cast<const internal::Phdr_data<size>*>(p))
  { }

  template<typename File>
  Phdr(File* file, typename File::Location loc)
    : p_(reinterpret_cast<internal::Phdr_data<size>*>(
	   file->view(loc.file_offset, loc.data_size).data()))
  { }

  Elf_Word
  get_p_type() const
  { return Convert<32, big_endian>::convert_host(this->p_->p_type); }

  typename Elf_types<size>::Elf_Off
  get_p_offset() const
  { return Convert<size, big_endian>::convert_host(this->p_->p_offset); }

  typename Elf_types<size>::Elf_Addr
  get_p_vaddr() const
  { return Convert<size, big_endian>::convert_host(this->p_->p_vaddr); }

  typename Elf_types<size>::Elf_Addr
  get_p_paddr() const
  { return Convert<size, big_endian>::convert_host(this->p_->p_paddr); }

  typename Elf_types<size>::Elf_WXword
  get_p_filesz() const
  { return Convert<size, big_endian>::convert_host(this->p_->p_filesz); }

  typename Elf_types<size>::Elf_WXword
  get_p_memsz() const
  { return Convert<size, big_endian>::convert_host(this->p_->p_memsz); }

  Elf_Word
  get_p_flags() const
  { return Convert<32, big_endian>::convert_host(this->p_->p_flags); }

  typename Elf_types<size>::Elf_WXword
  get_p_align() const
  { return Convert<size, big_endian>::convert_host(this->p_->p_align); }

 private:
  const internal::Phdr_data<size>* p_;
};

// Write class for an ELF segment header.

template<int size, bool big_endian>
class Phdr_write
{
 public:
  Phdr_write(unsigned char* p)
    : p_(reinterpret_cast<internal::Phdr_data<size>*>(p))
  { }

  void
  put_p_type(Elf_Word v)
  { this->p_->p_type = Convert<32, big_endian>::convert_host(v); }

  void
  put_p_offset(typename Elf_types<size>::Elf_Off v)
  { this->p_->p_offset = Convert<size, big_endian>::convert_host(v); }

  void
  put_p_vaddr(typename Elf_types<size>::Elf_Addr v)
  { this->p_->p_vaddr = Convert<size, big_endian>::convert_host(v); }

  void
  put_p_paddr(typename Elf_types<size>::Elf_Addr v)
  { this->p_->p_paddr = Convert<size, big_endian>::convert_host(v); }

  void
  put_p_filesz(typename Elf_types<size>::Elf_WXword v)
  { this->p_->p_filesz = Convert<size, big_endian>::convert_host(v); }

  void
  put_p_memsz(typename Elf_types<size>::Elf_WXword v)
  { this->p_->p_memsz = Convert<size, big_endian>::convert_host(v); }

  void
  put_p_flags(Elf_Word v)
  { this->p_->p_flags = Convert<32, big_endian>::convert_host(v); }

  void
  put_p_align(typename Elf_types<size>::Elf_WXword v)
  { this->p_->p_align = Convert<size, big_endian>::convert_host(v); }

 private:
  internal::Phdr_data<size>* p_;
};

// Accessor class for an ELF symbol table entry.

template<int size, bool big_endian>
class Sym
{
 public:
  Sym(const unsigned char* p)
    : p_(reinterpret_cast<const internal::Sym_data<size>*>(p))
  { }

  template<typename File>
  Sym(File* file, typename File::Location loc)
    : p_(reinterpret_cast<const internal::Sym_data<size>*>(
	   file->view(loc.file_offset, loc.data_size).data()))
  { }

  Elf_Word
  get_st_name() const
  { return Convert<32, big_endian>::convert_host(this->p_->st_name); }

  typename Elf_types<size>::Elf_Addr
  get_st_value() const
  { return Convert<size, big_endian>::convert_host(this->p_->st_value); }

  typename Elf_types<size>::Elf_WXword
  get_st_size() const
  { return Convert<size, big_endian>::convert_host(this->p_->st_size); }

  unsigned char
  get_st_info() const
  { return this->p_->st_info; }

  STB
  get_st_bind() const
  { return elf_st_bind(this->get_st_info()); }

  STT
  get_st_type() const
  { return elf_st_type(this->get_st_info()); }

  unsigned char
  get_st_other() const
  { return this->p_->st_other; }

  STV
  get_st_visibility() const
  { return elf_st_visibility(this->get_st_other()); }

  unsigned char
  get_st_nonvis() const
  { return elf_st_nonvis(this->get_st_other()); }

  Elf_Half
  get_st_shndx() const
  { return Convert<16, big_endian>::convert_host(this->p_->st_shndx); }

 private:
  const internal::Sym_data<size>* p_;
};

// Writer class for an ELF symbol table entry.

template<int size, bool big_endian>
class Sym_write
{
 public:
  Sym_write(unsigned char* p)
    : p_(reinterpret_cast<internal::Sym_data<size>*>(p))
  { }

  void
  put_st_name(Elf_Word v)
  { this->p_->st_name = Convert<32, big_endian>::convert_host(v); }

  void
  put_st_value(typename Elf_types<size>::Elf_Addr v)
  { this->p_->st_value = Convert<size, big_endian>::convert_host(v); }

  void
  put_st_size(typename Elf_types<size>::Elf_WXword v)
  { this->p_->st_size = Convert<size, big_endian>::convert_host(v); }

  void
  put_st_info(unsigned char v)
  { this->p_->st_info = v; }

  void
  put_st_info(STB bind, STT type)
  { this->p_->st_info = elf_st_info(bind, type); }

  void
  put_st_other(unsigned char v)
  { this->p_->st_other = v; }

  void
  put_st_other(STV vis, unsigned char nonvis)
  { this->p_->st_other = elf_st_other(vis, nonvis); }

  void
  put_st_shndx(Elf_Half v)
  { this->p_->st_shndx = Convert<16, big_endian>::convert_host(v); }

  Sym<size, big_endian>
  sym()
  { return Sym<size, big_endian>(reinterpret_cast<unsigned char*>(this->p_)); }

 private:
  internal::Sym_data<size>* p_;
};

// Accessor classes for an ELF REL relocation entry.

template<int size, bool big_endian>
class Rel
{
 public:
  Rel(const unsigned char* p)
    : p_(reinterpret_cast<const internal::Rel_data<size>*>(p))
  { }

  template<typename File>
  Rel(File* file, typename File::Location loc)
    : p_(reinterpret_cast<const internal::Rel_data<size>*>(
	   file->view(loc.file_offset, loc.data_size).data()))
  { }

  typename Elf_types<size>::Elf_Addr
  get_r_offset() const
  { return Convert<size, big_endian>::convert_host(this->p_->r_offset); }

  typename Elf_types<size>::Elf_WXword
  get_r_info() const
  { return Convert<size, big_endian>::convert_host(this->p_->r_info); }

 private:
  const internal::Rel_data<size>* p_;
};

// Writer class for an ELF Rel relocation.

template<int size, bool big_endian>
class Rel_write
{
 public:
  Rel_write(unsigned char* p)
    : p_(reinterpret_cast<internal::Rel_data<size>*>(p))
  { }

  void
  put_r_offset(typename Elf_types<size>::Elf_Addr v)
  { this->p_->r_offset = Convert<size, big_endian>::convert_host(v); }

  void
  put_r_info(typename Elf_types<size>::Elf_WXword v)
  { this->p_->r_info = Convert<size, big_endian>::convert_host(v); }

 private:
  internal::Rel_data<size>* p_;
};

// Accessor class for an ELF Rela relocation.

template<int size, bool big_endian>
class Rela
{
 public:
  Rela(const unsigned char* p)
    : p_(reinterpret_cast<const internal::Rela_data<size>*>(p))
  { }

  template<typename File>
  Rela(File* file, typename File::Location loc)
    : p_(reinterpret_cast<const internal::Rela_data<size>*>(
	   file->view(loc.file_offset, loc.data_size).data()))
  { }

  typename Elf_types<size>::Elf_Addr
  get_r_offset() const
  { return Convert<size, big_endian>::convert_host(this->p_->r_offset); }

  typename Elf_types<size>::Elf_WXword
  get_r_info() const
  { return Convert<size, big_endian>::convert_host(this->p_->r_info); }

  typename Elf_types<size>::Elf_Swxword
  get_r_addend() const
  { return Convert<size, big_endian>::convert_host(this->p_->r_addend); }

 private:
  const internal::Rela_data<size>* p_;
};

// Writer class for an ELF Rela relocation.

template<int size, bool big_endian>
class Rela_write
{
 public:
  Rela_write(unsigned char* p)
    : p_(reinterpret_cast<internal::Rela_data<size>*>(p))
  { }

  void
  put_r_offset(typename Elf_types<size>::Elf_Addr v)
  { this->p_->r_offset = Convert<size, big_endian>::convert_host(v); }

  void
  put_r_info(typename Elf_types<size>::Elf_WXword v)
  { this->p_->r_info = Convert<size, big_endian>::convert_host(v); }

  void
  put_r_addend(typename Elf_types<size>::Elf_Swxword v)
  { this->p_->r_addend = Convert<size, big_endian>::convert_host(v); }

 private:
  internal::Rela_data<size>* p_;
};

// Accessor classes for entries in the ELF SHT_DYNAMIC section aka
// PT_DYNAMIC segment.

template<int size, bool big_endian>
class Dyn
{
 public:
  Dyn(const unsigned char* p)
    : p_(reinterpret_cast<const internal::Dyn_data<size>*>(p))
  { }

  template<typename File>
  Dyn(File* file, typename File::Location loc)
    : p_(reinterpret_cast<const internal::Dyn_data<size>*>(
	   file->view(loc.file_offset, loc.data_size).data()))
  { }

  typename Elf_types<size>::Elf_Swxword
  get_d_tag() const
  { return Convert<size, big_endian>::convert_host(this->p_->d_tag); }

  typename Elf_types<size>::Elf_WXword
  get_d_val() const
  { return Convert<size, big_endian>::convert_host(this->p_->d_val); }

  typename Elf_types<size>::Elf_Addr
  get_d_ptr() const
  { return Convert<size, big_endian>::convert_host(this->p_->d_val); }

 private:
  const internal::Dyn_data<size>* p_;
};

// Write class for an entry in the SHT_DYNAMIC section.

template<int size, bool big_endian>
class Dyn_write
{
 public:
  Dyn_write(unsigned char* p)
    : p_(reinterpret_cast<internal::Dyn_data<size>*>(p))
  { }

  void
  put_d_tag(typename Elf_types<size>::Elf_Swxword v)
  { this->p_->d_tag = Convert<size, big_endian>::convert_host(v); }

  void
  put_d_val(typename Elf_types<size>::Elf_WXword v)
  { this->p_->d_val = Convert<size, big_endian>::convert_host(v); }

  void
  put_d_ptr(typename Elf_types<size>::Elf_Addr v)
  { this->p_->d_val = Convert<size, big_endian>::convert_host(v); }

 private:
  internal::Dyn_data<size>* p_;
};

// Accessor classes for entries in the ELF SHT_GNU_verdef section.

template<int size, bool big_endian>
class Verdef
{
 public:
  Verdef(const unsigned char* p)
    : p_(reinterpret_cast<const internal::Verdef_data*>(p))
  { }

  template<typename File>
  Verdef(File* file, typename File::Location loc)
    : p_(reinterpret_cast<const internal::Verdef_data*>(
	   file->view(loc.file_offset, loc.data_size).data()))
  { }

  Elf_Half
  get_vd_version() const
  { return Convert<16, big_endian>::convert_host(this->p_->vd_version); }

  Elf_Half
  get_vd_flags() const
  { return Convert<16, big_endian>::convert_host(this->p_->vd_flags); }

  Elf_Half
  get_vd_ndx() const
  { return Convert<16, big_endian>::convert_host(this->p_->vd_ndx); }

  Elf_Half
  get_vd_cnt() const
  { return Convert<16, big_endian>::convert_host(this->p_->vd_cnt); }

  Elf_Word
  get_vd_hash() const
  { return Convert<32, big_endian>::convert_host(this->p_->vd_hash); }

  Elf_Word
  get_vd_aux() const
  { return Convert<32, big_endian>::convert_host(this->p_->vd_aux); }

  Elf_Word
  get_vd_next() const
  { return Convert<32, big_endian>::convert_host(this->p_->vd_next); }

 private:
  const internal::Verdef_data* p_;
};

template<int size, bool big_endian>
class Verdef_write
{
 public:
  Verdef_write(unsigned char* p)
    : p_(reinterpret_cast<internal::Verdef_data*>(p))
  { }

  void
  set_vd_version(Elf_Half v)
  { this->p_->vd_version = Convert<16, big_endian>::convert_host(v); }

  void
  set_vd_flags(Elf_Half v)
  { this->p_->vd_flags = Convert<16, big_endian>::convert_host(v); }

  void
  set_vd_ndx(Elf_Half v)
  { this->p_->vd_ndx = Convert<16, big_endian>::convert_host(v); }

  void
  set_vd_cnt(Elf_Half v)
  { this->p_->vd_cnt = Convert<16, big_endian>::convert_host(v); }

  void
  set_vd_hash(Elf_Word v)
  { this->p_->vd_hash = Convert<32, big_endian>::convert_host(v); }

  void
  set_vd_aux(Elf_Word v)
  { this->p_->vd_aux = Convert<32, big_endian>::convert_host(v); }

  void
  set_vd_next(Elf_Word v)
  { this->p_->vd_next = Convert<32, big_endian>::convert_host(v); }

 private:
  internal::Verdef_data* p_;
};

// Accessor classes for auxiliary entries in the ELF SHT_GNU_verdef
// section.

template<int size, bool big_endian>
class Verdaux
{
 public:
  Verdaux(const unsigned char* p)
    : p_(reinterpret_cast<const internal::Verdaux_data*>(p))
  { }

  template<typename File>
  Verdaux(File* file, typename File::Location loc)
    : p_(reinterpret_cast<const internal::Verdaux_data*>(
	   file->view(loc.file_offset, loc.data_size).data()))
  { }

  Elf_Word
  get_vda_name() const
  { return Convert<32, big_endian>::convert_host(this->p_->vda_name); }

  Elf_Word
  get_vda_next() const
  { return Convert<32, big_endian>::convert_host(this->p_->vda_next); }

 private:
  const internal::Verdaux_data* p_;
};

template<int size, bool big_endian>
class Verdaux_write
{
 public:
  Verdaux_write(unsigned char* p)
    : p_(reinterpret_cast<internal::Verdaux_data*>(p))
  { }

  void
  set_vda_name(Elf_Word v)
  { this->p_->vda_name = Convert<32, big_endian>::convert_host(v); }

  void
  set_vda_next(Elf_Word v)
  { this->p_->vda_next = Convert<32, big_endian>::convert_host(v); }

 private:
  internal::Verdaux_data* p_;
};

// Accessor classes for entries in the ELF SHT_GNU_verneed section.

template<int size, bool big_endian>
class Verneed
{
 public:
  Verneed(const unsigned char* p)
    : p_(reinterpret_cast<const internal::Verneed_data*>(p))
  { }

  template<typename File>
  Verneed(File* file, typename File::Location loc)
    : p_(reinterpret_cast<const internal::Verneed_data*>(
	   file->view(loc.file_offset, loc.data_size).data()))
  { }

  Elf_Half
  get_vn_version() const
  { return Convert<16, big_endian>::convert_host(this->p_->vn_version); }

  Elf_Half
  get_vn_cnt() const
  { return Convert<16, big_endian>::convert_host(this->p_->vn_cnt); }

  Elf_Word
  get_vn_file() const
  { return Convert<32, big_endian>::convert_host(this->p_->vn_file); }

  Elf_Word
  get_vn_aux() const
  { return Convert<32, big_endian>::convert_host(this->p_->vn_aux); }

  Elf_Word
  get_vn_next() const
  { return Convert<32, big_endian>::convert_host(this->p_->vn_next); }

 private:
  const internal::Verneed_data* p_;
};

template<int size, bool big_endian>
class Verneed_write
{
 public:
  Verneed_write(unsigned char* p)
    : p_(reinterpret_cast<internal::Verneed_data*>(p))
  { }

  void
  set_vn_version(Elf_Half v)
  { this->p_->vn_version = Convert<16, big_endian>::convert_host(v); }

  void
  set_vn_cnt(Elf_Half v)
  { this->p_->vn_cnt = Convert<16, big_endian>::convert_host(v); }

  void
  set_vn_file(Elf_Word v)
  { this->p_->vn_file = Convert<32, big_endian>::convert_host(v); }

  void
  set_vn_aux(Elf_Word v)
  { this->p_->vn_aux = Convert<32, big_endian>::convert_host(v); }

  void
  set_vn_next(Elf_Word v)
  { this->p_->vn_next = Convert<32, big_endian>::convert_host(v); }

 private:
  internal::Verneed_data* p_;
};

// Accessor classes for auxiliary entries in the ELF SHT_GNU_verneed
// section.

template<int size, bool big_endian>
class Vernaux
{
 public:
  Vernaux(const unsigned char* p)
    : p_(reinterpret_cast<const internal::Vernaux_data*>(p))
  { }

  template<typename File>
  Vernaux(File* file, typename File::Location loc)
    : p_(reinterpret_cast<const internal::Vernaux_data*>(
	   file->view(loc.file_offset, loc.data_size).data()))
  { }

  Elf_Word
  get_vna_hash() const
  { return Convert<32, big_endian>::convert_host(this->p_->vna_hash); }

  Elf_Half
  get_vna_flags() const
  { return Convert<16, big_endian>::convert_host(this->p_->vna_flags); }

  Elf_Half
  get_vna_other() const
  { return Convert<16, big_endian>::convert_host(this->p_->vna_other); }

  Elf_Word
  get_vna_name() const
  { return Convert<32, big_endian>::convert_host(this->p_->vna_name); }

  Elf_Word
  get_vna_next() const
  { return Convert<32, big_endian>::convert_host(this->p_->vna_next); }

 private:
  const internal::Vernaux_data* p_;
};

template<int size, bool big_endian>
class Vernaux_write
{
 public:
  Vernaux_write(unsigned char* p)
    : p_(reinterpret_cast<internal::Vernaux_data*>(p))
  { }

  void
  set_vna_hash(Elf_Word v)
  { this->p_->vna_hash = Convert<32, big_endian>::convert_host(v); }

  void
  set_vna_flags(Elf_Half v)
  { this->p_->vna_flags = Convert<16, big_endian>::convert_host(v); }

  void
  set_vna_other(Elf_Half v)
  { this->p_->vna_other = Convert<16, big_endian>::convert_host(v); }

  void
  set_vna_name(Elf_Word v)
  { this->p_->vna_name = Convert<32, big_endian>::convert_host(v); }

  void
  set_vna_next(Elf_Word v)
  { this->p_->vna_next = Convert<32, big_endian>::convert_host(v); }

 private:
  internal::Vernaux_data* p_;
};

} // End namespace elfcpp.

#endif // !defined(ELFPCP_H)
@


1.35
log
@	* mips.h: New file
	* elfcpp.h (SHT_MIPS_REGINFO): New enums for processor-specific flags.
	(SHF_MIPS_GPREL): Likewise.
	(PT_MIPS_REGINFO, PT_MIPS_RTPROC, PT_MIPS_OPTIONS): Likewise.
	(DT_MIPS_RLD_VERSION, DT_MIPS_TIME_STAMP, DT_MIPS_ICHECKSUM,
	 DT_MIPS_IVERSION, DT_MIPS_FLAGS, DT_MIPS_BASE_ADDRESS, DT_MIPS_MSYM,
	 DT_MIPS_CONFLICT, DT_MIPS_LIBLIST, DT_MIPS_LOCAL_GOTNO,
	 DT_MIPS_CONFLICTNO, DT_MIPS_LIBLISTNO, DT_MIPS_SYMTABNO,
	 DT_MIPS_UNREFEXTNO, DT_MIPS_GOTSYM, DT_MIPS_HIPAGENO, DT_MIPS_RLD_MAP,
	 DT_MIPS_DELTA_CLASS, DT_MIPS_DELTA_CLASS_NO, DT_MIPS_DELTA_INSTANCE,
	 DT_MIPS_DELTA_INSTANCE_NO, DT_MIPS_DELTA_RELOC, DT_MIPS_DELTA_RELOC_NO,
	 DT_MIPS_DELTA_SYM, DT_MIPS_DELTA_SYM_NO, DT_MIPS_DELTA_CLASSSYM,
	 DT_MIPS_DELTA_CLASSSYM_NO, DT_MIPS_CXX_FLAGS, DT_MIPS_PIXIE_INIT,
	 DT_MIPS_SYMBOL_LIB, DT_MIPS_LOCALPAGE_GOTIDX, DT_MIPS_LOCAL_GOTIDX,
	 DT_MIPS_HIDDEN_GOTIDX, DT_MIPS_PROTECTED_GOTIDX, DT_MIPS_OPTIONS,
	 DT_MIPS_INTERFACE, DT_MIPS_DYNSTR_ALIGN, DT_MIPS_INTERFACE_SIZE,
	 DT_MIPS_RLD_TEXT_RESOLVE_ADDR, DT_MIPS_PERF_SUFFIX,
	 DT_MIPS_COMPACT_SIZE, DT_MIPS_GP_VALUE, DT_MIPS_AUX_DYNAMIC,
	 DT_MIPS_PLTGOT, DT_MIPS_RWPLT): Likewise.
@
text
@d272 1
@


1.34
log
@	* elfcpp.h (STT_GNU_IFUNC): Add comment.
@
text
@d403 4
d441 3
d485 7
a491 1
  PT_ARM_EXIDX = 0x70000001
d754 92
@


1.33
log
@ELFOSABI_GNU

	bfd/
	* elf.c (_bfd_elf_set_osabi): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf64-hppa.c: Likewise.

	binutils/
	* elfedit.c (osabis): Use ELFOSABI_GNU name instead of ELFOSABI_LINUX
	alias and ELFOSABI_HURD.  Add GNU alias.
	* readelf.c (get_osabi_name, get_symbol_binding, get_symbol_type):
	Likewise.
	* doc/binutils.texi <elfedit>: Update accordingly.

	elfcpp/
	* elfcpp.h (ELFOSABI): Add ELFOSABI_GNU with value of ELFOSABI_LINUX,
	keep ELFOSABI_LINUX as an alias.  Remove ELFOSABI_HURD.

	gas/
	* config/obj-elf.c (obj_elf_type): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* config/tc-ia64.c: Likewise.

	include/elf/
	* common.h (ELFOSABI_GNU): Define, replaces...
	(ELFOSABI_LINUX): ... this, kept as an alias.
	(ELFOSABI_HURD): Remove.

	ld/testsuite/
	* ld-ifunc/ifunc.exp: Update for changed output.
	* ld-unique/unique.exp: Likewise.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d517 5
a522 1
  STT_GNU_IFUNC = 10,
@


1.32
log
@        * elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_GOT_PLT.
@
text
@d132 2
a133 1
  // ELFOSABI_LINUX is not listed in the ELF standard.
a134 2
  // ELFOSABI_HURD is not listed in the ELF standard.
  ELFOSABI_HURD = 4,
@


1.31
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_SYMTAB,
	SHT_GNU_INCREMENTAL_RELOCS.

gold/ChangeLog:

	* archive.cc: Include incremental.h.
	(Archive::Archive): Initialize incremental_info_.
	(Archive::include_member): Record archive members in incremental info.
	(Add_archive_symbols::run): Record begin and end of an archive in
	incremental info.
	(Lib_group::include_member): Record objects in incremental info.
	* archive.h (Incremental_archive_entry): Forward declaration.
	(Archive::set_incremental_info): New member function.
	(Archive::incremental_info): New member function.
	(Archive::Unused_symbol_iterator): New class.
	(Archive::unused_symbols_begin): New member function.
	(Archive::unused_symbols_end): New member function.
	(Archive::incremental_info_): New data member.
	* incremental-dump.cc (find_input_containing_global): New function.
	(dump_incremental_inputs): Dump new incremental info sections.
	* incremental.cc: Include symtab.h.
	(Output_section_incremental_inputs): New class.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Support
	new incremental info sections.
	(Sized_incremental_binary::do_check_inputs): Likewise.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): New function.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Rewrite.
	(Incremental_inputs::finalize): Do nothing but finalize string table.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Output_section_incremental_inputs::set_final_data_size): New function.
	(Output_section_incremental_inputs::do_write): New function.
	(Output_section_incremental_inputs::write_header): New function.
	(Output_section_incremental_inputs::write_input_files): New function.
	(Output_section_incremental_inputs::write_info_blocks): New function.
	(Output_section_incremental_inputs::write_symtab): New function.
	* incremental.h (Incremental_script_entry): Forward declaration.
	(Incremental_object_entry): Forward declaration.
	(Incremental_archive_entry): Forward declaration.
	(Incremental_inputs): Forward declaration.
	(Incremental_inputs_header_data): Remove.
	(Incremental_inputs_header): Remove.
	(Incremental_inputs_header_write): Remove.
	(Incremental_inputs_entry_data): Remove.
	(Incremental_inputs_entry): Remove.
	(Incremental_inputs_entry_write): Remove.
	(enum Incremental_input_type): Add INCREMENTAL_INPUT_ARCHIVE_MEMBER.
	(Incremental_binary::find_incremental_inputs_sections): Add parameters.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Sized_ncremental_binary::do_find_incremental_inputs_sections):
	Likewise.
	(Incremental_input_entry): New class.
	(Incremental_script_entry): New class.
	(Incremental_object_entry): New class.
	(Incremental_archive_entry): New class.
	(Incremental_inputs::Incremental_inputs): Initialize new data members.
	(Incremental_inputs::report_inputs): Remove.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): Change prototype.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Change prototype.
	(Incremental_inputs::get_reloc_count): New function.
	(Incremental_inputs::set_reloc_count): New function.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::inputs_section): New function.
	(Incremental_inputs::symtab_section): New function.
	(Incremental_inputs::relocs_section): New function.
	(Incremental_inputs::get_stringpool): Add const.
	(Incremental_inputs::command_line): Add const.
	(Incremental_inputs::inputs): Remove.
	(Incremental_inputs::command_line_key): New function.
	(Incremental_inputs::input_file_count): New function.
	(Incremental_inputs::input_files): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::Input_info): Remove.
	(Incremental_inputs::lock_): Remove.
	(Incremental_inputs::inputs_): Change type.
	(Incremental_inputs::inputs_map_): Remove.
	(Incremental_inputs::current_object_entry_): New data member.
	(Incremental_inputs::inputs_section_): New data member.
	(Incremental_inputs::symtab_section_): New data member.
	(Incremental_inputs::relocs_section_): New data member.
	(Incremental_inputs::reloc_count_): New data member.
	(Incremental_inputs_reader): New class.
	(Incremental_symtab_reader): New class.
	(Incremental_relocs_reader): New class.
	* layout.cc (Layout::finalize): Move finalization of incremental info
	and creation of incremental info sections to follow finalization of
	symbol table.  Set offsets for postprocessing sections.
	(Layout::create_incremental_info_sections): Call
	Incremental_inputs::create_data_sections.  Add incremental symtab
	and relocs sections.  Set sh_entsize and sh_link fields.  Arrange for
	sections to layout after input sections.
	* layout.h (struct Timespec): Forward declaration.
	(Layout::incremental_inputs): Add const.
	(Layout::create_incremental_info_sections): Add parameter.
	* main.cc (main): Remove call to Incremental_inputs::report_inputs.
	* object.cc: Include incremental.h.
	(Relobj::finalize_incremental_relocs): New function.
	(Sized_relobj::do_layout): Record input sections in incremental info.
	* object.h (Object::output_section): New function.
	(Object::output_section_offset): Moved from Relobj.
	(Object::get_incremental_reloc_base): New function.
	(Object::get_incremental_reloc_count): New function.
	(Object::do_output_section): New function.
	(Object::do_output_section_offset): Moved from Relobj.
	(Object::do_get_incremental_reloc_base): New function.
	(Object::do_get_incremental_reloc_count): New function.
	(Object::Object): Initialize new data members.
	(Relobj::output_section): Renamed do_output_section and moved to
	protected.
	(Relobj::output_section_offset): Moved to Object.
	(Relobj::do_get_incremental_reloc_base): New function.
	(Relobj::do_get_incremental_reloc_count): New function.
	(Relobj::allocate_incremental_reloc_counts): New function.
	(Relobj::count_incremental_reloc): New function.
	(Relobj::finalize_incremental_relocs): New function.
	(Relobj::next_incremental_reloc_index): New function.
	(Relobj::reloc_counts_): New data member.
	(Relobj::reloc_bases_): New data member.
	(Sized_relobj::do_relocate_sections): Add parameter.  Change caller.
	(Sized_relobj::relocate_sections): Add parameter.  Change all callers.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* plugin.cc (Plugin_manager::add_input_file): Rewrite test for
	incremental link.
	* readsyms.cc (Read_symbols::do_read_symbols): Move reporting of
	archives and object files elsewhere.
	(Add_symbols::run): Report object files here.
	(Finish_group::run): Report end of archive at end of group.
	* reloc.cc: Include layout.h, incremental.h.
	(Sized_relobj::do_read_relocs): Need relocations for incremental link.
	(Sized_relobj::do_scan_relocs): Record relocations for incremental link.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::do_relocate_sections): Write incremental relocations.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* script.cc (read_input_script): Rewrite test for incremental link.
	Change call to Incremental_inputs::report_script.
	* symtab.h (Symbol_table::first_global_index): New function.
	(Symbol_table::output_count): New function.
@
text
@d370 1
@


1.30
log
@	include:
	* elf/common.h (VER_FLG_*): Document.
	(VER_FLG_INFO): Define.

	gold:
	* dynobj.h (Verdef::Verdef): Add is_info arg, is_info member
	function, is_info_ member.
	* dynobj.cc (Verdef::write): Set VER_FLG_INFO if this->is_info_.
	(Versions::Versions): Update caller.
	(Versions::define_base_version): Likewise.
	(Versions::add_def): Likewise.

	elfcpp:
	* elfcpp.h (VER_FLG_INFO): Define.

	binutils:
	* readelf.c (get_ver_flags): Handle VER_FLG_INFO.
@
text
@d368 2
@


1.29
log
@elfcpp/:
	* elfcpp.h (PN_XNUM): Define.
gold/:
	* output.cc (Output_section_headers::do_sized_write): Write large
	segment count to sh_info field.
	(Output_file_header::do_sized_write): For large segment count,
	write PN_XNUM to e_phnum field.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d787 1
@


1.28
log
@	* elfcpp.h: Remove trailing commas from enum definitions.
@
text
@d305 9
@


1.27
log
@2009-10-30  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:
	* arm.h (EF_ARM_BE8, EF_ARM_EABIMASK, EF_ARM_EABI_UNKNOWN,
	EF_ARM_EABI_VER1, EF_ARM_EABI_VER2, EF_ARM_EABI_VER3,
	EF_ARM_EABI_VER4, EF_ARM_EABI_VER5): New enums for processor-specific
	flags.
	(arm_eabi_version): New inline function.
	* elfcpp.h: Add a comment about DT_ENCODING.

gold/ChangeLog:
	* arm.cc (Arm_relobj::processor_specific_flags): New method
	definition.
	(Arm_relobj::do_read_symbols): New method declaration.
	(Arm_relobj::processor_specific_flags_): New data member declaration.
	(Arm_dynobj): New class definition.
	(Target_arm::do_finalize_sections): Add input_objects parameter.
	(Target_arm::do_adjust_elf_header): New method declaration.
	(Target_arm::are_eabi_versions_compatible,
	(Target_arm::merge_processor_specific_flags): New method declaration.
	(Target_arm::do_make_elf_object): New overloaded method definitions
	and declaration.
	(Arm_relobj::do_read_symbols): New method definition.
	(Arm_dynobj::do_read_symbols): Ditto.
	(Target_arm::do_finalize_sections): Add input_objects parameters.
	Merge processor-specific flags from all input objects.
	(Target_arm::are_eabi_versions_compatible,
	Target_arm::merge_processor_specific_flags,
	Target_arm::do_adjust_elf_header, Target_arm::do_make_elf_object):
	New method definitions.
	* i386.cc (Target_i386::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* layout.cc (Layout::finalize): Pass input objects to target's.
	finalize_sections function.
	* output.cc (Output_file_header::do_sized_write): Set ELF file
	header's processor-specific flags.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* sparc.cc (Target_sparc::do_finalize_sections): Same.
	* target.h (Input_objects): New forward class declaration.
	(Target::processor_specific_flags,
	Target::are_processor_specific_flags_sect): New method definitions.
	(Target::finalize_sections): Add input_objects parameter.
	(Target::Target): Initialize processor_specific_flags_ and
	are_processor_specific_flags_set_.
	(Target::do_finalize_sections): Add unnamed Input_objects pointer type
	parameter.
	(Target::set_processor_specific_flags): New method definition.
	(Target::processor_specific_flags_,
	Target::are_processor_specific_flags_set_): New data member
	declarations.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
@
text
@d20 1
a20 1
/// distribution when not linked into a combined executable.)
d393 1
a393 1
  SHT_ORDERED = 0x7fffffff,
d517 1
a517 1
  STT_ARM_TFUNC = 13,
d758 1
a758 1
  DF_1_CONLFAT = 0x2000,
@


1.26
log
@2009-10-16  Doug Kwan  <dougkwan@@google.com>

	* elfcpp/elfcpp.h (DT_PREINIT_ARRAY): Correct enum value.
@
text
@d659 3
d663 1
@


1.25
log
@        * config/obj-elf.c (obj_elf_type): Add code to support a type of
        gnu_unique_object.
        * doc/as.texinfo: Document new feature of .type directive.
        * NEWS: Mention support for gnu_unique_object symbol type.

        * common.h (STB_GNU_UNIQUE): Define.

        * NEWS: Mention the linker's support for symbols with a binding of
        STB_GNU_UNIQUE.

        * gas/elf/type.s: Add unique global symbol definition.
        * gas/elf/type.e: Add expected readelf output for global unique
        symbol.

        * elfcpp.h (enum STB): Add STB_GNU_UNIQUE.

        * readelf.c (get_symbol_binding): For Linux targeted files return
        UNIQUE for symbols with the STB_GNU_UNIQUE binding.
        * doc/binutils.texi: Document the meaning of the 'u' symbol
        binding in the output of nm and objdump --syms.

        * elf-bfd.h (struct elf_link_hash_entry): Add unique_global field.
        * elf.c (swap_out_syms): Set binding to STB_GNU_UNIQUE for symbols
        with the BSF_GNU_UNIQUE flag bit set.
        * elfcode.h (elf_slurp_symbol_table): Set the BSF_GNU_UNIQUE flag
        for symbols with STB_GNU_UNIQUE binding.
        * elflink.c (_bfd_elf_merge_symbol): Set unique_global for symbols
        with the STB_GNU_UNIQUE binding.
        (elf_link_add_object_symbols): Set the BSF_GNU_UNIQUE flag for
        symbols with STB_GNU_UNIQUE binding.  Set STB_GNU_UNIQUE for
        symbols with the unique_global field set.
        (elf_link_output_extsym): Set unique_global field for symbols with
        the STB_GNU_UNIQUE binding.
        * syms.c (struct bfd_symbol): Define BSF_GNU_UNIQUE flag bit.
        (bfd_print_symbol_vandf): Print a 'u' character for BSF_GNU_UNIQUE
        symbols.
        (bfd_decode_symclass): Return a 'u' character for BSF_GNU_UNIQUE
        symbols.
        * bfd-in2.h: Regenerate.
@
text
@d660 1
a660 1
  DT_PREINIT_ARRAY = 33,
@


1.25.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@d20 1
a20 1
// distribution when not linked into a combined executable.)
d660 1
a660 1
  DT_PREINIT_ARRAY = 32,
@


1.24
log
@	* elfcpp.h (SHN_X86_64_LCOMMON): Define enum constant.
	(enum SHT): Add SHT_X86_64_UNWIND.
	(enum SHF): Add SHT_X86_64_LARGE.
@
text
@d488 1
@


1.23
log
@2009-05-27  Doug Kwan  <dougkwan@@google.com>

        * arm.h: New file.
        * elfcpp.h (enum SHT): Add ARM-specific special sections.
        (enum PT): Add ARM-specific section types.
        (enum SST): Add STT_ARM_TFUNC.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, Free Software Foundation, Inc.
d324 3
d388 3
d424 3
@


1.22
log
@include/elf
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * common.h (STT_GNU_IFUNC): Define.

elfcpp
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * (enum STT): Add STT_GNU_IFUNC.

gas
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * config/obj-elf.c (obj_elf_type): Add support for a
        gnu_indirect_function type.
        * config/tc-i386.c (tc_i386_fix_adjustable): Do not adjust fixups
        against indirect function symbols.
        * doc/as.texinfo (.type): Document the support for the
        gnu_indirect_function symbol type.
        * NEWS: Mention the new feature.

gas/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * gas/elf/elf.exp: Extend type test to include an ifunc symbol.
        Provide an alternative test for targets which do not support ifunc
        symbols.
        (type.s): Add entry for an ifunc symbol.
        (type.e): Add ifunc entry to expected symbol dump.
        (section2.e-armelf): Add  entry for ifunc symbol.
        (type-noifunc.s): New file.
        (type-noifunc.e): New file.

bfd/
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs
        section pointer.
        (struct elf_obj_data): Add has_ifunc_symbols boolean.
        * elf.c (swap_out_syms): Convert BSF_GNU_INDIRECT_FUNCTION flags
        into a STT_GNU_IFUNC symbol type.
        (_bfd_elf_is_function_type): Accept STT_GNU_IFUNC as a function
        type.
        (_bfd_elf_set_osabi): Set the osasbi field to ELFOSABI_LINUX if
        the binary contains ifunc symbols.
        * elfcode.h (elf_slurp_symbol_table): Translate the STT_GNU_IFUNC
        symbol type into a BSF_GNU_INDIRECT_FUNCTION flag.
        * elf32-i386.c (is_indirect_function): New function.
        (elf_i386_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf_i386_relocate_section): Emit a reloc against an ifunc symbol
        if necessary.
        (elf_i386_add_symbol_hook): New function. Set the
        has_ifunc_symbols field of the elf_obj_data structure if an ifunc
        symbol is encountered.
        (elf_backend_post_process_headers): Define.
        (elf_backend_add_symbol_hook): Define.
        (elf_i386_post_process_headers): Rename to
        elf_i388_fbsd_post_process_headers.
        * elf64-x86_64.c (IS_X86_64_PCREL_TYPE): New macro.
        (is_indirect_function): New function.
        (elf64_x86_64_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf64_x86_64_relocate_section): Emit a reloc against an ifunc
        symbol if necessary.
        (elf_i386_add_symbol_hook): Set the has_ifunc_symbols field of the
        elf_obj_data structure if an ifunc symbol is encountered.
        (elf_backend_post_process_headers): Define.
        * elflink.c (_bfd_elf_adjust_dynamic_symbol): Always create a PLT
        if we have ifunc symbols to handle.
        (get_ifunc_reloc_section_name): New function.  Computes the name
        for an ifunc section.
        (_bfd_elf_make_ifunc_reloc_section): New function.  Creates a
        section to hold ifunc relocs.
        * syms.c (BSF_GNU_INDIRECT_FUNCTION): Define.
        (bfd_print_symbol_vandf): Handle ifunc symbols.
        (bfd_decode_symclass): Likewise.
        * bfd-in2.h: Regenerate.

binutils
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * readelf.c (dump_relocations): Display a relocation against an
        ifunc symbol as if it were a function invocation.
        (get_symbol_type): Handle STT_GNU_IFUNC.

ld
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * NEWS: Mention support for IFUNC symbols.

ld/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * ld-ifunc: New directory.
        * ld-ifunc/ifunc.exp: New file: Run the IFUNC tests.
        * ld-ifunc/prog.c: New file.
        * ld-ifunc/lib.c: New file.
@
text
@d374 11
d453 5
a457 1
  PT_GNU_RELRO = 0x6474e552
d504 4
@


1.21
log
@include/elf:
	* common.h (SHT_GNU_INCREMENTAL_INPUTS): Define.
elfcpp:
	* elfcpp.h (SHT_GNU_INCREMENTAL_INPUTS): Define.
gold:
	* incremental.cc: New file.
	* Makefile.am (CCFILES): Add incremental.cc.
	* Makefile.in: Rebuild.
@
text
@d481 1
@


1.20
log
@2009-01-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfcpp.h (enum STT): Remove STT_IFUNC.
@
text
@d7 1
a7 1
   
d354 2
d939 1
a939 1
  
@


1.19
log
@include/elf/
            * common.h (STT_IFUNC): Define.
elfcpp/
            * elfcpp.h (enum STT): Add STT_IFUNC.
bfd/
            * syms.c (struct bfd_symbol): Add new flag BSF_INDIRECT_FUNCTION.
            Remove redundant flag BFD_FORT_COMM_DEFAULT_VALUE.  Renumber flags
            to remove gaps.
            (bfd_print_symbol_vandf): Return 'i' for BSF_INDIRECT_FUNCTION.
            (bfd_decode_symclass): Likewise.
            * elf.c (swap_out_syms): Translate BSF_INDIRECT_FUNCTION into
            STT_IFUNC.
            (elf_find_function): Treat STT_IFUNC in the same way as STT_FUNC.
            (_bfd_elf_is_function_type): Likewise.
            * elf32-arm.c (arm_elf_find_function): Likewise.
            (elf32_arm_adjust_dynamic_symbol): Likewise.
            (elf32_arm_swap_symbol_in): Likewise.
            (elf32_arm_additional_program_headers): Likewise.
            * elf32-i386.c (is_indirect_symbol): New function.
            (elf_i386_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf_i386_relocate_section): Likewise.
            * elf64-x86-64.c (is_indirect_symbol): New function.
            (elf64_x86_64_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf64_x86_64_relocate_section): Likewise.
            * elfcode.h (elf_slurp_symbol_table): Translate STT_IFUNC into
            BSF_INDIRECT_FUNCTION.
            * elflink.c (_bfd_elf_adjust_dynamic_reloc_section): Add support
            for STT_IFUNC symbols.
            (get_ifunc_reloc_section_name): New function.
            (_bfd_elf_make_ifunc_reloc_section): New function.
            * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs field.
            * bfd-in2.h: Regenerate.
gas/
            * config/obj-elf.c (obj_elf_type): Add support for STT_IFUNC type.
            * doc/as.texinfo: Document new feature.
            * NEWS: Mention new feature.
gas/testsuite/
            * gas/elf/type.s: Add test of STT_IFUNC symbol type.
            * gas/elf/type.e: Update expected disassembly.
            * gas/elf/elf.exp: Update grep of symbol types.
ld/
            * NEWS: Mention new feature.
            * pe-dll.c (process_def_file): Replace use of redundant
            BFD_FORT_COMM_DEFAULT_VALUE with 0.
            * scripttempl/elf.sc: Add .rel.ifunc.dyn and .rela.ifunc.dyn
            sections.
ld/testsuite/
            * ld-mips-elf/reloc-1-n32.d: Updated expected output for reloc
            descriptions.
            * ld-mips-elf/reloc-1-n64.d: Likewise.
            * ld-i386/ifunc.d: New test.
            * ld-i386/ifunc.s: Source file for the new test.
            * ld-i386/i386.exp: Run the new test.
@
text
@a478 1
  STT_IFUNC = 10,
@


1.18
log
@2008-06-12  David S. Miller  <davem@@davemloft.net>

        * powerpc.h: New file.
        * elfcpp.h (SHT_ORDERED): New enum constant.
        (DT_PPC_GOT, DT_PPC64_GLINK, DT_PPC64_OPD, DT_PPC64_OPDSZ): Same.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, Free Software Foundation, Inc.
d479 1
@


1.17
log
@elfcpp/

	* elfcpp.h (DF_1_NOW, DF_1_GLOBAL, DF_1_GROUP,
	DF_1_NODELETE, DF_1_LOADFLTR, DF_1_INITFIRST,
	DF_1_NOOPEN, DF_1_ORIGIN, DF_1_DIRECT, DF_1_TRANS,
	DF_1_INTERPOSE, DF_1_NODEFLIB, DF_1_NODUMP,
	DF_1_CONLFAT): New enum constants.

gold/

	* options.h (DEFINE_enable): New macro.
	(new_dtags): New enable option.
	(initfirst, interpose, loadfltr, nodefaultlib,
	nodelete, nodlopen, nodump): New -z options.
	* layout.cc (Layout:finish_dynamic_section): If new
	dtags enabled, emit DT_RUNPATH.  Also, emit a
	DT_FLAGS_1 containing any specified -z flags.
@
text
@d371 4
d674 10
@


1.16
log
@	* sparc.h: New file
	* elfcpp.h (SHN_BEFORE, SHN_AFTER): New enum constants.
	(SHT_SPARC_GOTDATA, SHF_ORDERED, SHF_EXCLUDE,
	STT_SPARC_REGISTER, DT_SPARC_REGISTER): Likewise.
@
text
@d691 20
@


1.15
log
@	* elfcpp.h (NT_VERSION, NT_ARCH): Define as enum constants.
	(NT_GNU_ABI_TAG, NT_GNU_HWCAP): Likewise.
	(NT_GNU_BUILD_ID, NT_GNU_GOLD_VERSION): Likewise.
	(ELF_NOTE_OS_LINUX, ELF_NOTE_OS_GNU): Likewise.
	(ELF_NOTE_OS_SOLARIS2, ELF_NOTE_OS_NETBSD): Likewise.
	(ELF_NOTE_OS_SYLLABLE): Likewise.
@
text
@d318 6
a323 1
  SHN_HIRESERVE = 0xffff
d369 2
d388 13
a400 1
  SHF_MASKPROC = 0xf0000000
d477 5
a481 1
  STT_HIPROC = 15
d670 5
@


1.14
log
@Support --hash-style=gnu.
@
text
@d697 48
@


1.13
log
@Add licensing text to every source file.
@
text
@d349 4
@


1.12
log
@Remove unnecessary elfcpp_config.h file.
@
text
@d3 29
@


1.11
log
@Generate version information.
@
text
@a7 1
#include "elfcpp_config.h"
@


1.10
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d695 5
d1386 40
d1455 20
d1515 32
d1588 31
@


1.9
log
@Snapshot.  Includes first cut at output relocation sections.
@
text
@d1307 26
@


1.8
log
@More dynamic object support, initial scripting support.
@
text
@d1166 1
a1166 1
// Accessor classes for Elf relocation table entries.
d1194 24
d1246 26
@


1.7
log
@Add Elf_file interface which can be used by both Sized_relobj and
Sized_dynobj.
@
text
@d533 132
d693 2
d1223 192
@


1.6
log
@Rework swapping code.
@
text
@d573 6
d719 6
d834 6
d932 6
d1042 6
d1066 6
@


1.5
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d9 1
a562 18
// Given the address of an Elf_Word, return the value.

template<bool big_endian>
inline Elf_Word
read_elf_word(const Elf_Word* p)
{
  return internal::convert_word<big_endian>(*p);
}

// Store an Elf_Word into an address.

template<bool big_endian>
inline void
write_elf_word(Elf_Word* p, Elf_Word v)
{
  *p = internal::convert_word<big_endian>(v);
}

d579 1
a579 1
  { return internal::convert_half<big_endian>(this->p_->e_type); }
d583 1
a583 1
  { return internal::convert_half<big_endian>(this->p_->e_machine); }
d587 1
a587 1
  { return internal::convert_word<big_endian>(this->p_->e_version); }
d591 1
a591 1
  { return internal::convert_addr<size, big_endian>(this->p_->e_entry); }
d595 1
a595 1
  { return internal::convert_off<size, big_endian>(this->p_->e_phoff); }
d599 1
a599 1
  { return internal::convert_off<size, big_endian>(this->p_->e_shoff); }
d603 1
a603 1
  { return internal::convert_word<big_endian>(this->p_->e_flags); }
d607 1
a607 1
  { return internal::convert_half<big_endian>(this->p_->e_ehsize); }
d611 1
a611 1
  { return internal::convert_half<big_endian>(this->p_->e_phentsize); }
d615 1
a615 1
  { return internal::convert_half<big_endian>(this->p_->e_phnum); }
d619 1
a619 1
  { return internal::convert_half<big_endian>(this->p_->e_shentsize); }
d623 1
a623 1
  { return internal::convert_half<big_endian>(this->p_->e_shnum); }
d627 1
a627 1
  { return internal::convert_half<big_endian>(this->p_->e_shstrndx); }
d649 1
a649 1
  { this->p_->e_type = internal::convert_half<big_endian>(v); }
d653 1
a653 1
  { this->p_->e_machine = internal::convert_half<big_endian>(v); }
d657 1
a657 1
  { this->p_->e_version = internal::convert_word<big_endian>(v); }
d661 1
a661 1
  { this->p_->e_entry = internal::convert_addr<size, big_endian>(v); }
d665 1
a665 1
  { this->p_->e_phoff = internal::convert_off<size, big_endian>(v); }
d669 1
a669 1
  { this->p_->e_shoff = internal::convert_off<size, big_endian>(v); }
d673 1
a673 1
  { this->p_->e_flags = internal::convert_word<big_endian>(v); }
d677 1
a677 1
  { this->p_->e_ehsize = internal::convert_half<big_endian>(v); }
d681 1
a681 1
  { this->p_->e_phentsize = internal::convert_half<big_endian>(v); }
d685 1
a685 1
  { this->p_->e_phnum = internal::convert_half<big_endian>(v); }
d689 1
a689 1
  { this->p_->e_shentsize = internal::convert_half<big_endian>(v); }
d693 1
a693 1
  { this->p_->e_shnum = internal::convert_half<big_endian>(v); }
d697 1
a697 1
  { this->p_->e_shstrndx = internal::convert_half<big_endian>(v); }
d715 1
a715 1
  { return internal::convert_word<big_endian>(this->p_->sh_name); }
d719 1
a719 1
  { return internal::convert_word<big_endian>(this->p_->sh_type); }
d723 1
a723 1
  { return internal::convert_wxword<size, big_endian>(this->p_->sh_flags); }
d727 1
a727 1
  { return internal::convert_addr<size, big_endian>(this->p_->sh_addr); }
d731 1
a731 1
  { return internal::convert_off<size, big_endian>(this->p_->sh_offset); }
d735 1
a735 1
  { return internal::convert_wxword<size, big_endian>(this->p_->sh_size); }
d739 1
a739 1
  { return internal::convert_word<big_endian>(this->p_->sh_link); }
d743 1
a743 1
  { return internal::convert_word<big_endian>(this->p_->sh_info); }
d748 1
a748 1
      internal::convert_wxword<size, big_endian>(this->p_->sh_addralign); }
d752 1
a752 1
  { return internal::convert_wxword<size, big_endian>(this->p_->sh_entsize); }
d770 1
a770 1
  { this->p_->sh_name = internal::convert_word<big_endian>(v); }
d774 1
a774 1
  { this->p_->sh_type = internal::convert_word<big_endian>(v); }
d778 1
a778 1
  { this->p_->sh_flags = internal::convert_wxword<size, big_endian>(v); }
d782 1
a782 1
  { this->p_->sh_addr = internal::convert_addr<size, big_endian>(v); }
d786 1
a786 1
  { this->p_->sh_offset = internal::convert_off<size, big_endian>(v); }
d790 1
a790 1
  { this->p_->sh_size = internal::convert_wxword<size, big_endian>(v); }
d794 1
a794 1
  { this->p_->sh_link = internal::convert_word<big_endian>(v); }
d798 1
a798 1
  { this->p_->sh_info = internal::convert_word<big_endian>(v); }
d802 1
a802 1
  { this->p_->sh_addralign = internal::convert_wxword<size, big_endian>(v); }
d806 1
a806 1
  { this->p_->sh_entsize = internal::convert_wxword<size, big_endian>(v); }
d824 1
a824 1
  { return internal::convert_word<big_endian>(this->p_->p_type); }
d828 1
a828 1
  { return internal::convert_off<size, big_endian>(this->p_->p_offset); }
d832 1
a832 1
  { return internal::convert_addr<size, big_endian>(this->p_->p_vaddr); }
d836 1
a836 1
  { return internal::convert_addr<size, big_endian>(this->p_->p_paddr); }
d840 1
a840 1
  { return internal::convert_wxword<size, big_endian>(this->p_->p_filesz); }
d844 1
a844 1
  { return internal::convert_wxword<size, big_endian>(this->p_->p_memsz); }
d848 1
a848 1
  { return internal::convert_word<big_endian>(this->p_->p_flags); }
d852 1
a852 1
  { return internal::convert_wxword<size, big_endian>(this->p_->p_align); }
d870 1
a870 1
  { this->p_->p_type = internal::convert_word<big_endian>(v); }
d874 1
a874 1
  { this->p_->p_offset = internal::convert_off<size, big_endian>(v); }
d878 1
a878 1
  { this->p_->p_vaddr = internal::convert_addr<size, big_endian>(v); }
d882 1
a882 1
  { this->p_->p_paddr = internal::convert_addr<size, big_endian>(v); }
d886 1
a886 1
  { this->p_->p_filesz = internal::convert_wxword<size, big_endian>(v); }
d890 1
a890 1
  { this->p_->p_memsz = internal::convert_wxword<size, big_endian>(v); }
d894 1
a894 1
  { this->p_->p_flags = internal::convert_word<big_endian>(v); }
d898 1
a898 1
  { this->p_->p_align = internal::convert_wxword<size, big_endian>(v); }
d916 1
a916 1
  { return internal::convert_word<big_endian>(this->p_->st_name); }
d920 1
a920 1
  { return internal::convert_addr<size, big_endian>(this->p_->st_value); }
d924 1
a924 1
  { return internal::convert_wxword<size, big_endian>(this->p_->st_size); }
d952 1
a952 1
  { return internal::convert_half<big_endian>(this->p_->st_shndx); }
d970 1
a970 1
  { this->p_->st_name = internal::convert_word<big_endian>(v); }
d974 1
a974 1
  { this->p_->st_value = internal::convert_addr<size, big_endian>(v); }
d978 1
a978 1
  { this->p_->st_size = internal::convert_wxword<size, big_endian>(v); }
d998 1
a998 1
  { this->p_->st_shndx = internal::convert_half<big_endian>(v); }
d1020 1
a1020 1
  { return internal::convert_addr<size, big_endian>(this->p_->r_offset); }
d1024 1
a1024 1
  { return internal::convert_wxword<size, big_endian>(this->p_->r_info); }
d1040 1
a1040 1
  { return internal::convert_addr<size, big_endian>(this->p_->r_offset); }
d1044 1
a1044 1
  { return internal::convert_wxword<size, big_endian>(this->p_->r_info); }
d1048 1
a1048 1
  { return internal::convert_swxword<size, big_endian>(this->p_->r_addend); }
@


1.4
log
@Add program segments.
@
text
@d37 1
d46 1
d476 56
d551 2
d557 3
d571 9
d650 70
d775 54
d875 46
d1023 46
@


1.3
log
@More symbol resolution code.
@
text
@d29 1
a29 8
struct Elf_types
{
  // Dummy types which should not be used.
  typedef unsigned char Elf_Addr;
  typedef unsigned char Elf_Off;
  // WXword is for fields which are Elf32_Word and Elf64_Xword.
  typedef unsigned char Elf_WXword;
};
a44 3
  static const int ehdr_size;
  static const int shdr_size;
  static const int sym_size;
d292 1
a292 1
enum
d333 1
a333 1
enum
d359 37
d499 9
d631 46
@


1.2
log
@Another snapshot of the current state of the sources.  Gets to the
point of symbol resolution and can now issue a multiple definition
error.  Also added target selection infrastructure.
@
text
@d440 7
d649 50
@


1.1
log
@Initial CVS checkin of gold
@
text
@d399 19
d428 12
d610 1
a610 1
  { return internal::convert_wxword<big_endian>(this->p_->st_size); }
d616 8
d627 8
@

