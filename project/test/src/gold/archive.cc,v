head	1.73;
access;
symbols
	binutils-2_24-branch:1.72.0.2
	binutils-2_24-branchpoint:1.72
	binutils-2_21_1:1.60.2.1
	binutils-2_23_2:1.71
	binutils-2_23_1:1.71
	binutils-2_23:1.71
	binutils-2_23-branch:1.71.0.2
	binutils-2_23-branchpoint:1.71
	binutils-2_22_branch:1.70.0.4
	binutils-2_22:1.70
	binutils-2_22-branch:1.70.0.2
	binutils-2_22-branchpoint:1.70
	binutils-2_21:1.60
	binutils-2_21-branch:1.60.0.2
	binutils-2_21-branchpoint:1.60
	binutils-2_20_1:1.44.4.1
	binutils-2_20:1.44.4.1
	binutils-arc-20081103-branch:1.37.0.4
	binutils-arc-20081103-branchpoint:1.37
	binutils-2_20-branch:1.44.0.4
	binutils-2_20-branchpoint:1.44
	dje-cgen-play1-branch:1.44.0.2
	dje-cgen-play1-branchpoint:1.44
	arc-20081103-branch:1.37.0.2
	arc-20081103-branchpoint:1.37
	binutils-2_19_1:1.35
	binutils-2_19:1.35
	binutils-2_19-branch:1.35.0.2
	binutils-2_19-branchpoint:1.35
	binutils_latest_snapshot:1.73
	added-to-binutils:1.26;
locks; strict;
comment	@// @;


1.73
date	2013.10.11.21.11.49;	author roland;	state Exp;
branches;
next	1.72;

1.72
date	2013.03.30.01.03.23;	author tmsriram;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2012.04.17.00.28.41;	author ccoutant;	state Exp;
branches;
next	1.70;

1.70
date	2011.07.14.00.55.17;	author tmsriram;	state Exp;
branches;
next	1.69;

1.69
date	2011.06.02.20.13.23;	author ccoutant;	state Exp;
branches;
next	1.68;

1.68
date	2011.05.25.00.17.44;	author ian;	state Exp;
branches;
next	1.67;

1.67
date	2011.04.12.00.44.47;	author ccoutant;	state Exp;
branches;
next	1.66;

1.66
date	2011.03.30.21.07.13;	author ccoutant;	state Exp;
branches;
next	1.65;

1.65
date	2011.03.30.01.31.57;	author ccoutant;	state Exp;
branches;
next	1.64;

1.64
date	2011.03.27.17.00.56;	author ian;	state Exp;
branches;
next	1.63;

1.63
date	2011.01.24.21.48.40;	author ian;	state Exp;
branches;
next	1.62;

1.62
date	2010.12.14.19.03.29;	author rwild;	state Exp;
branches;
next	1.61;

1.61
date	2010.12.07.15.47.47;	author ian;	state Exp;
branches;
next	1.60;

1.60
date	2010.11.03.17.18.23;	author nickc;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2010.08.23.20.28.24;	author ccoutant;	state Exp;
branches;
next	1.57;

1.57
date	2010.08.20.00.35.12;	author ccoutant;	state Exp;
branches;
next	1.56;

1.56
date	2010.08.12.22.01.11;	author ccoutant;	state Exp;
branches;
next	1.55;

1.55
date	2010.08.02.13.34.33;	author ian;	state Exp;
branches;
next	1.54;

1.54
date	2010.07.13.07.56.08;	author ian;	state Exp;
branches;
next	1.53;

1.53
date	2010.04.07.22.58.23;	author ccoutant;	state Exp;
branches;
next	1.52;

1.52
date	2010.03.22.14.18.24;	author espindola;	state Exp;
branches;
next	1.51;

1.51
date	2010.03.09.19.17.14;	author espindola;	state Exp;
branches;
next	1.50;

1.50
date	2010.02.12.03.23.25;	author ian;	state Exp;
branches;
next	1.49;

1.49
date	2009.12.15.22.05.22;	author ian;	state Exp;
branches;
next	1.48;

1.48
date	2009.12.14.19.53.04;	author ian;	state Exp;
branches;
next	1.47;

1.47
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.10.07.39.04;	author cgd;	state Exp;
branches;
next	1.45;

1.45
date	2009.09.30.22.21.13;	author ian;	state Exp;
branches;
next	1.44;

1.44
date	2009.05.19.22.14.17;	author ccoutant;	state Exp;
branches
	1.44.4.1;
next	1.43;

1.43
date	2009.03.24.18.42.10;	author ian;	state Exp;
branches;
next	1.42;

1.42
date	2009.03.18.05.09.52;	author ian;	state Exp;
branches;
next	1.41;

1.41
date	2009.03.14.05.56.46;	author ian;	state Exp;
branches;
next	1.40;

1.40
date	2009.03.13.21.30.06;	author ian;	state Exp;
branches;
next	1.39;

1.39
date	2009.02.13.19.04.44;	author ccoutant;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.15.01.29.25;	author ccoutant;	state Exp;
branches;
next	1.37;

1.37
date	2008.09.29.21.23.02;	author ccoutant;	state Exp;
branches;
next	1.36;

1.36
date	2008.09.19.22.54.57;	author ccoutant;	state Exp;
branches;
next	1.35;

1.35
date	2008.08.07.17.02.11;	author ccoutant;	state Exp;
branches;
next	1.34;

1.34
date	2008.07.25.04.25.49;	author ian;	state Exp;
branches;
next	1.33;

1.33
date	2008.07.22.22.08.43;	author ian;	state Exp;
branches;
next	1.32;

1.32
date	2008.05.30.21.24.43;	author ccoutant;	state Exp;
branches;
next	1.31;

1.31
date	2008.05.21.21.37.44;	author ian;	state Exp;
branches;
next	1.30;

1.30
date	2008.05.07.06.08.01;	author ian;	state Exp;
branches;
next	1.29;

1.29
date	2008.04.23.17.29.04;	author ian;	state Exp;
branches;
next	1.28;

1.28
date	2008.04.02.20.58.21;	author ian;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.01.20.57.36;	author ccoutant;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2008.02.26.21.45.30;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2008.01.02.23.48.48;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.14.19.00.21;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.22.00.05.51;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.16.18.44.20;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.07.00.31.32;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.14.06.57.58;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.14.06.49.13;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.02.20.52.18;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.25.17.50.26;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.25.06.43.17;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.25.05.16.35;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.25.00.27.29;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.21.07.20.01;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.20.19.31.54;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.20.05.56.14;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.20.05.43.14;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.21.23.37.56;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.03.18.26.10;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.20.20.40.49;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.06.20.40.16;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.29.19.58.16;	author iant;	state Exp;
branches;
next	;

1.72.2.1
date	2013.10.11.21.23.42;	author roland;	state Exp;
branches;
next	;

1.60.2.1
date	2011.01.24.21.54.56;	author ian;	state Exp;
branches;
next	;

1.44.4.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	;


desc
@@


1.73
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@// archive.cc -- archive support for gold

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2013
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cerrno>
#include <cstring>
#include <climits>
#include <vector>
#include "libiberty.h"
#include "filenames.h"

#include "elfcpp.h"
#include "options.h"
#include "mapfile.h"
#include "fileread.h"
#include "readsyms.h"
#include "symtab.h"
#include "object.h"
#include "layout.h"
#include "archive.h"
#include "plugin.h"
#include "incremental.h"

namespace gold
{

// Library_base methods.

// Determine whether a definition of SYM_NAME should cause an archive
// library member to be included in the link.  Returns SHOULD_INCLUDE_YES
// if the symbol is referenced but not defined, SHOULD_INCLUDE_NO if the
// symbol is already defined, and SHOULD_INCLUDE_UNKNOWN if the symbol is
// neither referenced nor defined.

Library_base::Should_include
Library_base::should_include_member(Symbol_table* symtab, Layout* layout,
				    const char* sym_name, Symbol** symp,
				    std::string* why, char** tmpbufp,
				    size_t* tmpbuflen)
{
  // In an object file, and therefore in an archive map, an
  // '@@' in the name separates the symbol name from the
  // version name.  If there are two '@@' characters, this is
  // the default version.
  char* tmpbuf = *tmpbufp;
  const char* ver = strchr(sym_name, '@@');
  bool def = false;
  if (ver != NULL)
    {
      size_t symlen = ver - sym_name;
      if (symlen + 1 > *tmpbuflen)
        {
          tmpbuf = static_cast<char*>(xrealloc(tmpbuf, symlen + 1));
          *tmpbufp = tmpbuf;
          *tmpbuflen = symlen + 1;
        }
      memcpy(tmpbuf, sym_name, symlen);
      tmpbuf[symlen] = '\0';
      sym_name = tmpbuf;

      ++ver;
      if (*ver == '@@')
        {
          ++ver;
          def = true;
        }
    }

  Symbol* sym = symtab->lookup(sym_name, ver);
  if (def
      && ver != NULL
      && (sym == NULL
          || !sym->is_undefined()
          || sym->binding() == elfcpp::STB_WEAK))
    sym = symtab->lookup(sym_name, NULL);

  *symp = sym;

  if (sym == NULL)
    {
      // Check whether the symbol was named in a -u option.
      if (parameters->options().is_undefined(sym_name))
        {
          *why = "-u ";
          *why += sym_name;
        }
      else if (parameters->options().is_export_dynamic_symbol(sym_name))
        {
          *why = "--export-dynamic-symbol ";
          *why += sym_name;
        }
      else if (layout->script_options()->is_referenced(sym_name))
	{
	  size_t alc = 100 + strlen(sym_name);
	  char* buf = new char[alc];
	  snprintf(buf, alc, _("script or expression reference to %s"),
		   sym_name);
	  *why = buf;
	  delete[] buf;
	}
      else if (strcmp(sym_name, parameters->entry()) == 0)
	{
	  *why = "entry symbol ";
	  *why += sym_name;
	}
      else
	return Library_base::SHOULD_INCLUDE_UNKNOWN;
    }
  else if (!sym->is_undefined())
    return Library_base::SHOULD_INCLUDE_NO;
  // PR 12001: Do not include an archive when the undefined
  // symbol has actually been defined on the command line.
  else if (layout->script_options()->is_pending_assignment(sym_name))
    return Library_base::SHOULD_INCLUDE_NO;
  else if (sym->binding() == elfcpp::STB_WEAK)
    return Library_base::SHOULD_INCLUDE_UNKNOWN;

  return Library_base::SHOULD_INCLUDE_YES;
}

// The header of an entry in the archive.  This is all readable text,
// padded with spaces where necessary.  If the contents of an archive
// are all text file, the entire archive is readable.

struct Archive::Archive_header
{
  // The entry name.
  char ar_name[16];
  // The file modification time.
  char ar_date[12];
  // The user's UID in decimal.
  char ar_uid[6];
  // The user's GID in decimal.
  char ar_gid[6];
  // The file mode in octal.
  char ar_mode[8];
  // The file size in decimal.
  char ar_size[10];
  // The final magic code.
  char ar_fmag[2];
};

// Class Archive static variables.
unsigned int Archive::total_archives;
unsigned int Archive::total_members;
unsigned int Archive::total_members_loaded;

// Archive methods.

const char Archive::armag[sarmag] =
{
  '!', '<', 'a', 'r', 'c', 'h', '>', '\n'
};

const char Archive::armagt[sarmag] =
{
  '!', '<', 't', 'h', 'i', 'n', '>', '\n'
};

const char Archive::arfmag[2] = { '`', '\n' };

Archive::Archive(const std::string& name, Input_file* input_file,
                 bool is_thin_archive, Dirsearch* dirpath, Task* task)
  : Library_base(task), name_(name), input_file_(input_file), armap_(),
    armap_names_(), extended_names_(), armap_checked_(), seen_offsets_(),
    members_(), is_thin_archive_(is_thin_archive), included_member_(false),
    nested_archives_(), dirpath_(dirpath), num_members_(0),
    included_all_members_(false)
{
  this->no_export_ =
    parameters->options().check_excluded_libs(input_file->found_name());
}

// Set up the archive: read the symbol map and the extended name
// table.

void
Archive::setup()
{
  // We need to ignore empty archives.
  if (this->input_file_->file().filesize() == sarmag)
    return;

  // The first member of the archive should be the symbol table.
  std::string armap_name;
  off_t header_size = this->read_header(sarmag, false, &armap_name, NULL);
  if (header_size == -1)
    return;

  section_size_type armap_size = convert_to_section_size_type(header_size);
  off_t off = sarmag;
  if (armap_name.empty())
    {
      this->read_armap(sarmag + sizeof(Archive_header), armap_size);
      off = sarmag + sizeof(Archive_header) + armap_size;
    }
  else if (!this->input_file_->options().whole_archive())
    gold_error(_("%s: no archive symbol table (run ranlib)"),
	       this->name().c_str());

  // See if there is an extended name table.  We cache these views
  // because it is likely that we will want to read the following
  // header in the add_symbols routine.
  if ((off & 1) != 0)
    ++off;
  std::string xname;
  header_size = this->read_header(off, true, &xname, NULL);
  if (header_size == -1)
    return;

  section_size_type extended_size = convert_to_section_size_type(header_size);
  if (xname == "/")
    {
      const unsigned char* p = this->get_view(off + sizeof(Archive_header),
                                              extended_size, false, true);
      const char* px = reinterpret_cast<const char*>(p);
      this->extended_names_.assign(px, extended_size);
    }
  bool preread_syms = (parameters->options().threads()
                       && parameters->options().preread_archive_symbols());
#ifndef ENABLE_THREADS
  preread_syms = false;
#else
  if (parameters->options().has_plugins())
    preread_syms = false;
#endif
  if (preread_syms)
    this->read_all_symbols();
}

// Unlock any nested archives.

void
Archive::unlock_nested_archives()
{
  for (Nested_archive_table::iterator p = this->nested_archives_.begin();
       p != this->nested_archives_.end();
       ++p)
    {
      p->second->unlock(this->task_);
    }
}

// Read the archive symbol map.

void
Archive::read_armap(off_t start, section_size_type size)
{
  // To count the total number of archive members, we'll just count
  // the number of times the file offset changes.  Since most archives
  // group the symbols in the armap by object, this ought to give us
  // an accurate count.
  off_t last_seen_offset = -1;

  // Read in the entire armap.
  const unsigned char* p = this->get_view(start, size, true, false);

  // Numbers in the armap are always big-endian.
  const elfcpp::Elf_Word* pword = reinterpret_cast<const elfcpp::Elf_Word*>(p);
  unsigned int nsyms = elfcpp::Swap<32, true>::readval(pword);
  ++pword;

  // Note that the addition is in units of sizeof(elfcpp::Elf_Word).
  const char* pnames = reinterpret_cast<const char*>(pword + nsyms);
  section_size_type names_size =
    reinterpret_cast<const char*>(p) + size - pnames;
  this->armap_names_.assign(pnames, names_size);

  this->armap_.resize(nsyms);

  section_offset_type name_offset = 0;
  for (unsigned int i = 0; i < nsyms; ++i)
    {
      this->armap_[i].name_offset = name_offset;
      this->armap_[i].file_offset = elfcpp::Swap<32, true>::readval(pword);
      name_offset += strlen(pnames + name_offset) + 1;
      ++pword;
      if (this->armap_[i].file_offset != last_seen_offset)
        {
          last_seen_offset = this->armap_[i].file_offset;
          ++this->num_members_;
        }
    }

  if (static_cast<section_size_type>(name_offset) > names_size)
    gold_error(_("%s: bad archive symbol table names"),
	       this->name().c_str());

  // This array keeps track of which symbols are for archive elements
  // which we have already included in the link.
  this->armap_checked_.resize(nsyms);
}

// Read the header of an archive member at OFF.  Fail if something
// goes wrong.  Return the size of the member.  Set *PNAME to the name
// of the member.

off_t
Archive::read_header(off_t off, bool cache, std::string* pname,
                     off_t* nested_off)
{
  const unsigned char* p = this->get_view(off, sizeof(Archive_header), true,
					  cache);
  const Archive_header* hdr = reinterpret_cast<const Archive_header*>(p);
  return this->interpret_header(hdr, off,  pname, nested_off);
}

// Interpret the header of HDR, the header of the archive member at
// file offset OFF.  Return the size of the member, or -1 if something
// has gone wrong.  Set *PNAME to the name of the member.

off_t
Archive::interpret_header(const Archive_header* hdr, off_t off,
                          std::string* pname, off_t* nested_off) const
{
  if (memcmp(hdr->ar_fmag, arfmag, sizeof arfmag) != 0)
    {
      gold_error(_("%s: malformed archive header at %zu"),
		 this->name().c_str(), static_cast<size_t>(off));
      return -1;
    }

  const int size_string_size = sizeof hdr->ar_size;
  char size_string[size_string_size + 1];
  memcpy(size_string, hdr->ar_size, size_string_size);
  char* ps = size_string + size_string_size;
  while (ps[-1] == ' ')
    --ps;
  *ps = '\0';

  errno = 0;
  char* end;
  off_t member_size = strtol(size_string, &end, 10);
  if (*end != '\0'
      || member_size < 0
      || (member_size == LONG_MAX && errno == ERANGE))
    {
      gold_error(_("%s: malformed archive header size at %zu"),
		 this->name().c_str(), static_cast<size_t>(off));
      return -1;
    }

  if (hdr->ar_name[0] != '/')
    {
      const char* name_end = strchr(hdr->ar_name, '/');
      if (name_end == NULL
	  || name_end - hdr->ar_name >= static_cast<int>(sizeof hdr->ar_name))
	{
	  gold_error(_("%s: malformed archive header name at %zu"),
		     this->name().c_str(), static_cast<size_t>(off));
	  return -1;
	}
      pname->assign(hdr->ar_name, name_end - hdr->ar_name);
      if (nested_off != NULL)
        *nested_off = 0;
    }
  else if (hdr->ar_name[1] == ' ')
    {
      // This is the symbol table.
      if (!pname->empty())
	pname->clear();
    }
  else if (hdr->ar_name[1] == '/')
    {
      // This is the extended name table.
      pname->assign(1, '/');
    }
  else
    {
      errno = 0;
      long x = strtol(hdr->ar_name + 1, &end, 10);
      long y = 0;
      if (*end == ':')
        y = strtol(end + 1, &end, 10);
      if (*end != ' '
	  || x < 0
	  || (x == LONG_MAX && errno == ERANGE)
	  || static_cast<size_t>(x) >= this->extended_names_.size())
	{
	  gold_error(_("%s: bad extended name index at %zu"),
		     this->name().c_str(), static_cast<size_t>(off));
	  return -1;
	}

      const char* name = this->extended_names_.data() + x;
      const char* name_end = strchr(name, '\n');
      if (static_cast<size_t>(name_end - name) > this->extended_names_.size()
	  || name_end[-1] != '/')
	{
	  gold_error(_("%s: bad extended name entry at header %zu"),
		     this->name().c_str(), static_cast<size_t>(off));
	  return -1;
	}
      pname->assign(name, name_end - 1 - name);
      if (nested_off != NULL)
        *nested_off = y;
    }

  return member_size;
}

// An archive member iterator.

class Archive::const_iterator
{
 public:
  // The header of an archive member.  This is what this iterator
  // points to.
  struct Header
  {
    // The name of the member.
    std::string name;
    // The file offset of the member.
    off_t off;
    // The file offset of a nested archive member.
    off_t nested_off;
    // The size of the member.
    off_t size;
  };

  const_iterator(Archive* archive, off_t off)
    : archive_(archive), off_(off)
  { this->read_next_header(); }

  const Header&
  operator*() const
  { return this->header_; }

  const Header*
  operator->() const
  { return &this->header_; }

  const_iterator&
  operator++()
  {
    if (this->off_ == this->archive_->file().filesize())
      return *this;
    this->off_ += sizeof(Archive_header);
    if (!this->archive_->is_thin_archive())
      this->off_ += this->header_.size;
    if ((this->off_ & 1) != 0)
      ++this->off_;
    this->read_next_header();
    return *this;
  }

  const_iterator
  operator++(int)
  {
    const_iterator ret = *this;
    ++*this;
    return ret;
  }

  bool
  operator==(const const_iterator p) const
  { return this->off_ == p->off; }

  bool
  operator!=(const const_iterator p) const
  { return this->off_ != p->off; }

 private:
  void
  read_next_header();

  // The underlying archive.
  Archive* archive_;
  // The current offset in the file.
  off_t off_;
  // The current archive header.
  Header header_;
};

// Read the next archive header.

void
Archive::const_iterator::read_next_header()
{
  off_t filesize = this->archive_->file().filesize();
  while (true)
    {
      if (filesize - this->off_ < static_cast<off_t>(sizeof(Archive_header)))
	{
	  if (filesize != this->off_)
	    {
	      gold_error(_("%s: short archive header at %zu"),
			 this->archive_->filename().c_str(),
			 static_cast<size_t>(this->off_));
	      this->off_ = filesize;
	    }
	  this->header_.off = filesize;
	  return;
	}

      unsigned char buf[sizeof(Archive_header)];
      this->archive_->file().read(this->off_, sizeof(Archive_header), buf);

      const Archive_header* hdr = reinterpret_cast<const Archive_header*>(buf);
      off_t size = this->archive_->interpret_header(hdr, this->off_,
						    &this->header_.name,
						    &this->header_.nested_off);
      if (size == -1)
	{
	  this->header_.off = filesize;
	  return;
	}

      this->header_.size = size;
      this->header_.off = this->off_;

      // Skip special members.
      if (!this->header_.name.empty() && this->header_.name != "/")
	return;

      this->off_ += sizeof(Archive_header) + this->header_.size;
      if ((this->off_ & 1) != 0)
	++this->off_;
    }
}

// Initial iterator.

Archive::const_iterator
Archive::begin()
{
  return Archive::const_iterator(this, sarmag);
}

// Final iterator.

Archive::const_iterator
Archive::end()
{
  return Archive::const_iterator(this, this->input_file_->file().filesize());
}

// Get the file and offset for an archive member, which may be an
// external member of a thin archive.  Set *INPUT_FILE to the
// file containing the actual member, *MEMOFF to the offset
// within that file (0 if not a nested archive), and *MEMBER_NAME
// to the name of the archive member.  Return TRUE on success.

bool
Archive::get_file_and_offset(off_t off, Input_file** input_file, off_t* memoff,
                             off_t* memsize, std::string* member_name)
{
  off_t nested_off;

  *memsize = this->read_header(off, false, member_name, &nested_off);
  if (*memsize == -1)
    return false;

  *input_file = this->input_file_;
  *memoff = off + static_cast<off_t>(sizeof(Archive_header));

  if (!this->is_thin_archive_)
    return true;

  // Adjust a relative pathname so that it is relative
  // to the directory containing the archive.
  if (!IS_ABSOLUTE_PATH(member_name->c_str()))
    {
      const char* arch_path = this->filename().c_str();
      const char* basename = lbasename(arch_path);
      if (basename > arch_path)
        member_name->replace(0, 0,
                             this->filename().substr(0, basename - arch_path));
    }

  if (nested_off > 0)
    {
      // This is a member of a nested archive.  Open the containing
      // archive if we don't already have it open, then do a recursive
      // call to include the member from that archive.
      Archive* arch;
      Nested_archive_table::const_iterator p =
        this->nested_archives_.find(*member_name);
      if (p != this->nested_archives_.end())
        arch = p->second;
      else
        {
          Input_file_argument* input_file_arg =
            new Input_file_argument(member_name->c_str(),
                                    Input_file_argument::INPUT_FILE_TYPE_FILE,
                                    "", false, parameters->options());
          *input_file = new Input_file(input_file_arg);
	  int dummy = 0;
          if (!(*input_file)->open(*this->dirpath_, this->task_, &dummy))
            return false;
          arch = new Archive(*member_name, *input_file, false, this->dirpath_,
                             this->task_);
          arch->setup();
          std::pair<Nested_archive_table::iterator, bool> ins =
            this->nested_archives_.insert(std::make_pair(*member_name, arch));
          gold_assert(ins.second);
        }
      return arch->get_file_and_offset(nested_off, input_file, memoff,
				       memsize, member_name);
    }

  // This is an external member of a thin archive.  Open the
  // file as a regular relocatable object file.
  Input_file_argument* input_file_arg =
      new Input_file_argument(member_name->c_str(),
                              Input_file_argument::INPUT_FILE_TYPE_FILE,
                              "", false, this->input_file_->options());
  *input_file = new Input_file(input_file_arg);
  int dummy = 0;
  if (!(*input_file)->open(*this->dirpath_, this->task_, &dummy))
    return false;

  *memoff = 0;
  *memsize = (*input_file)->file().filesize();
  return true;
}

// Return an ELF object for the member at offset OFF.  If
// PUNCONFIGURED is not NULL, then if the ELF object has an
// unsupported target type, set *PUNCONFIGURED to true and return
// NULL.

Object*
Archive::get_elf_object_for_member(off_t off, bool* punconfigured)
{
  if (punconfigured != NULL)
    *punconfigured = false;

  Input_file* input_file;
  off_t memoff;
  off_t memsize;
  std::string member_name;
  if (!this->get_file_and_offset(off, &input_file, &memoff, &memsize,
				 &member_name))
    return NULL;

  const unsigned char* ehdr;
  int read_size;
  Object *obj = NULL;
  bool is_elf_obj = false;

  if (is_elf_object(input_file, memoff, &ehdr, &read_size))
    {
      obj = make_elf_object((std::string(this->input_file_->filename())
			     + "(" + member_name + ")"),
			    input_file, memoff, ehdr, read_size,
			    punconfigured);
      is_elf_obj = true;
    }

  if (parameters->options().has_plugins())
    {
      Object* plugin_obj
	= parameters->options().plugins()->claim_file(input_file,
						      memoff,
						      memsize,
						      obj);
      if (plugin_obj != NULL)
        {
          // The input file was claimed by a plugin, and its symbols
          // have been provided by the plugin.
	  // Delete its elf object.
	  if (obj != NULL)
	    delete obj;
          return plugin_obj;
        }
    }

  if (!is_elf_obj)
    {
      gold_error(_("%s: member at %zu is not an ELF object"),
		 this->name().c_str(), static_cast<size_t>(off));
      return NULL;
    }

  if (obj == NULL)
    return NULL;
  obj->set_no_export(this->no_export());
  return obj;
}

// Read the symbols from all the archive members in the link.

void
Archive::read_all_symbols()
{
  for (Archive::const_iterator p = this->begin();
       p != this->end();
       ++p)
    this->read_symbols(p->off);
}

// Read the symbols from an archive member in the link.  OFF is the file
// offset of the member header.

void
Archive::read_symbols(off_t off)
{
  Object* obj = this->get_elf_object_for_member(off, NULL);
  if (obj == NULL)
    return;

  Read_symbols_data* sd = new Read_symbols_data;
  obj->read_symbols(sd);
  Archive_member member(obj, sd);
  this->members_[off] = member;
}

// Select members from the archive and add them to the link.  We walk
// through the elements in the archive map, and look each one up in
// the symbol table.  If it exists as a strong undefined symbol, we
// pull in the corresponding element.  We have to do this in a loop,
// since pulling in one element may create new undefined symbols which
// may be satisfied by other objects in the archive.  Return true in
// the normal case, false if the first member we tried to add from
// this archive had an incompatible target.

bool
Archive::add_symbols(Symbol_table* symtab, Layout* layout,
		     Input_objects* input_objects, Mapfile* mapfile)
{
  ++Archive::total_archives;

  if (this->input_file_->options().whole_archive())
    return this->include_all_members(symtab, layout, input_objects,
				     mapfile);

  Archive::total_members += this->num_members_;

  input_objects->archive_start(this);

  const size_t armap_size = this->armap_.size();

  // This is a quick optimization, since we usually see many symbols
  // in a row with the same offset.  last_seen_offset holds the last
  // offset we saw that was present in the seen_offsets_ set.
  off_t last_seen_offset = -1;

  // Track which symbols in the symbol table we've already found to be
  // defined.

  char* tmpbuf = NULL;
  size_t tmpbuflen = 0;
  bool added_new_object;
  do
    {
      added_new_object = false;
      for (size_t i = 0; i < armap_size; ++i)
	{
          if (this->armap_checked_[i])
            continue;
	  if (this->armap_[i].file_offset == last_seen_offset)
            {
              this->armap_checked_[i] = true;
              continue;
            }
	  if (this->seen_offsets_.find(this->armap_[i].file_offset)
              != this->seen_offsets_.end())
	    {
              this->armap_checked_[i] = true;
	      last_seen_offset = this->armap_[i].file_offset;
	      continue;
	    }

	  const char* sym_name = (this->armap_names_.data()
				  + this->armap_[i].name_offset);

          Symbol* sym;
          std::string why;
          Archive::Should_include t =
	    Archive::should_include_member(symtab, layout, sym_name, &sym,
					   &why, &tmpbuf, &tmpbuflen);

	  if (t == Archive::SHOULD_INCLUDE_NO
              || t == Archive::SHOULD_INCLUDE_YES)
	    this->armap_checked_[i] = true;

	  if (t != Archive::SHOULD_INCLUDE_YES)
	    continue;

	  // We want to include this object in the link.
	  last_seen_offset = this->armap_[i].file_offset;
	  this->seen_offsets_.insert(last_seen_offset);

	  if (!this->include_member(symtab, layout, input_objects,
				    last_seen_offset, mapfile, sym,
				    why.c_str()))
	    {
	      if (tmpbuf != NULL)
		free(tmpbuf);
	      return false;
	    }

	  added_new_object = true;
	}
    }
  while (added_new_object);

  if (tmpbuf != NULL)
    free(tmpbuf);

  input_objects->archive_stop(this);

  return true;
}

// Return whether the archive includes a member which defines the
// symbol SYM.

bool
Archive::defines_symbol(Symbol* sym) const
{
  const char* symname = sym->name();
  size_t symname_len = strlen(symname);
  size_t armap_size = this->armap_.size();
  for (size_t i = 0; i < armap_size; ++i)
    {
      if (this->armap_checked_[i])
	continue;
      const char* archive_symname = (this->armap_names_.data()
				     + this->armap_[i].name_offset);
      if (strncmp(archive_symname, symname, symname_len) != 0)
	continue;
      char c = archive_symname[symname_len];
      if (c == '\0' && sym->version() == NULL)
	return true;
      if (c == '@@')
	{
	  const char* ver = archive_symname + symname_len + 1;
	  if (*ver == '@@')
	    {
	      if (sym->version() == NULL)
		return true;
	      ++ver;
	    }
	  if (sym->version() != NULL && strcmp(sym->version(), ver) == 0)
	    return true;
	}
    }
  return false;
}

// Include all the archive members in the link.  This is for --whole-archive.

bool
Archive::include_all_members(Symbol_table* symtab, Layout* layout,
                             Input_objects* input_objects, Mapfile* mapfile)
{
  // Don't include the same archive twice.  This can happen if
  // --whole-archive is nested inside --start-group (PR gold/12163).
  if (this->included_all_members_)
    return true;

  this->included_all_members_ = true;

  input_objects->archive_start(this);

  if (this->members_.size() > 0)
    {
      std::map<off_t, Archive_member>::const_iterator p;
      for (p = this->members_.begin();
           p != this->members_.end();
           ++p)
        {
          if (!this->include_member(symtab, layout, input_objects, p->first,
				    mapfile, NULL, "--whole-archive"))
	    return false;
          ++Archive::total_members;
        }
    }
  else
    {
      for (Archive::const_iterator p = this->begin();
           p != this->end();
           ++p)
        {
          if (!this->include_member(symtab, layout, input_objects, p->off,
				    mapfile, NULL, "--whole-archive"))
	    return false;
          ++Archive::total_members;
        }
    }

  input_objects->archive_stop(this);

  return true;
}

// Return the number of members in the archive.  This is only used for
// reports.

size_t
Archive::count_members()
{
  size_t ret = 0;
  for (Archive::const_iterator p = this->begin();
       p != this->end();
       ++p)
    ++ret;
  return ret;
}

// Include an archive member in the link.  OFF is the file offset of
// the member header.  WHY is the reason we are including this member.
// Return true if we added the member or if we had an error, return
// false if this was the first member we tried to add from this
// archive and it had an incompatible format.

bool
Archive::include_member(Symbol_table* symtab, Layout* layout,
			Input_objects* input_objects, off_t off,
			Mapfile* mapfile, Symbol* sym, const char* why)
{
  ++Archive::total_members_loaded;

  std::map<off_t, Archive_member>::const_iterator p = this->members_.find(off);
  if (p != this->members_.end())
    {
      Object* obj = p->second.obj_;

      Read_symbols_data* sd = p->second.sd_;
      if (mapfile != NULL)
        mapfile->report_include_archive_member(obj->name(), sym, why);
      if (input_objects->add_object(obj))
        {
          obj->layout(symtab, layout, sd);
          obj->add_symbols(symtab, sd, layout);
	  this->included_member_ = true;
        }
      delete sd;
      return true;
    }

  // If this is the first object we are including from this archive,
  // and we searched for this archive, most likely because it was
  // found via a -l option, then if the target is incompatible we want
  // to move on to the next archive found in the search path.
  bool unconfigured = false;
  bool* punconfigured = NULL;
  if (!this->included_member_ && this->searched_for())
    punconfigured = &unconfigured;

  Object* obj = this->get_elf_object_for_member(off, punconfigured);
  if (obj == NULL)
    {
      // Return false to search for another archive, true if we found
      // an error.
      return unconfigured ? false : true;
    }

  if (mapfile != NULL)
    mapfile->report_include_archive_member(obj->name(), sym, why);

  Pluginobj* pluginobj = obj->pluginobj();
  if (pluginobj != NULL)
    {
      pluginobj->add_symbols(symtab, NULL, layout);
      this->included_member_ = true;
      return true;
    }

  if (!input_objects->add_object(obj))
    {
      // If this is an external member of a thin archive, unlock the
      // file.
      if (obj->offset() == 0)
	obj->unlock(this->task_);
      delete obj;
    }
  else
    {
      {
	if (layout->incremental_inputs() != NULL)
	  layout->incremental_inputs()->report_object(obj, 0, this, NULL);
	Read_symbols_data sd;
	obj->read_symbols(&sd);
	obj->layout(symtab, layout, &sd);
	obj->add_symbols(symtab, &sd, layout);
      }

      // If this is an external member of a thin archive, unlock the file
      // for the next task.
      if (obj->offset() == 0)
        obj->unlock(this->task_);

      this->included_member_ = true;
    }

  return true;
}

// Iterate over all unused symbols, and call the visitor class V for each.

void
Archive::do_for_all_unused_symbols(Symbol_visitor_base* v) const
{
  for (std::vector<Armap_entry>::const_iterator p = this->armap_.begin();
       p != this->armap_.end();
       ++p)
    {
      if (this->seen_offsets_.find(p->file_offset)
          == this->seen_offsets_.end())
        v->visit(this->armap_names_.data() + p->name_offset);
    }
}

// Print statistical information to stderr.  This is used for --stats.

void
Archive::print_stats()
{
  fprintf(stderr, _("%s: archive libraries: %u\n"),
          program_name, Archive::total_archives);
  fprintf(stderr, _("%s: total archive members: %u\n"),
          program_name, Archive::total_members);
  fprintf(stderr, _("%s: loaded archive members: %u\n"),
          program_name, Archive::total_members_loaded);
}

// Add_archive_symbols methods.

Add_archive_symbols::~Add_archive_symbols()
{
  if (this->this_blocker_ != NULL)
    delete this->this_blocker_;
  // next_blocker_ is deleted by the task associated with the next
  // input file.
}

// Return whether we can add the archive symbols.  We are blocked by
// this_blocker_.  We block next_blocker_.  We also lock the file.

Task_token*
Add_archive_symbols::is_runnable()
{
  if (this->this_blocker_ != NULL && this->this_blocker_->is_blocked())
    return this->this_blocker_;
  return NULL;
}

void
Add_archive_symbols::locks(Task_locker* tl)
{
  tl->add(this, this->next_blocker_);
  tl->add(this, this->archive_->token());
}

void
Add_archive_symbols::run(Workqueue* workqueue)
{
  // For an incremental link, begin recording layout information.
  Incremental_inputs* incremental_inputs = this->layout_->incremental_inputs();
  if (incremental_inputs != NULL)
    {
      unsigned int arg_serial = this->input_argument_->file().arg_serial();
      Script_info* script_info = this->input_argument_->script_info();
      incremental_inputs->report_archive_begin(this->archive_, arg_serial,
					       script_info);
    }

  bool added = this->archive_->add_symbols(this->symtab_, this->layout_,
					   this->input_objects_,
					   this->mapfile_);
  this->archive_->unlock_nested_archives();

  this->archive_->release();
  this->archive_->clear_uncached_views();

  if (!added)
    {
      // This archive holds object files which are incompatible with
      // our output file.
      Read_symbols::incompatible_warning(this->input_argument_,
					 this->archive_->input_file());
      Read_symbols::requeue(workqueue, this->input_objects_, this->symtab_,
			    this->layout_, this->dirpath_, this->dirindex_,
			    this->mapfile_, this->input_argument_,
			    this->input_group_, this->next_blocker_);
      delete this->archive_;
      return;
    }

  if (this->input_group_ != NULL)
    this->input_group_->add_archive(this->archive_);
  else
    {
      // For an incremental link, finish recording the layout information.
      if (incremental_inputs != NULL)
	incremental_inputs->report_archive_end(this->archive_);

      if (!parameters->options().has_plugins()
	  || this->archive_->input_file()->options().whole_archive())
	{
	  // We no longer need to know about this archive.
	  delete this->archive_;
	}
      else
	{
	  // The plugin interface may want to rescan this archive.
	  parameters->options().plugins()->save_archive(this->archive_);
	}

      this->archive_ = NULL;
    }
}

// Class Lib_group static variables.
unsigned int Lib_group::total_lib_groups;
unsigned int Lib_group::total_members;
unsigned int Lib_group::total_members_loaded;

Lib_group::Lib_group(const Input_file_lib* lib, Task* task)
  : Library_base(task), members_()
{
  this->members_.resize(lib->size());
}

const std::string&
Lib_group::do_filename() const
{
  std::string *filename = new std::string("/group/");
  return *filename;
}

// Select members from the lib group and add them to the link.  We walk
// through the members, and check if each one up should be included.
// If the object says it should be included, we do so.  We have to do
// this in a loop, since including one member may create new undefined
// symbols which may be satisfied by other members.

void
Lib_group::add_symbols(Symbol_table* symtab, Layout* layout,
                       Input_objects* input_objects)
{
  ++Lib_group::total_lib_groups;

  Lib_group::total_members += this->members_.size();

  bool added_new_object;
  do
    {
      added_new_object = false;
      unsigned int i = 0;
      while (i < this->members_.size())
	{
	  const Archive_member& member = this->members_[i];
	  Object* obj = member.obj_;
	  std::string why;

          // Skip files with no symbols. Plugin objects have
          // member.sd_ == NULL.
          if (obj != NULL
	      && (member.sd_ == NULL || member.sd_->symbol_names != NULL))
            {
	      Archive::Should_include t = obj->should_include_member(symtab,
								     layout,
								     member.sd_,
								     &why);

	      if (t != Archive::SHOULD_INCLUDE_YES)
		{
		  ++i;
		  continue;
		}

	      this->include_member(symtab, layout, input_objects, member);

	      added_new_object = true;
	    }
          else
            {
              if (member.sd_ != NULL)
		{
		  // The file must be locked in order to destroy the views
		  // associated with it.
		  gold_assert(obj != NULL);
		  obj->lock(this->task_);
		  delete member.sd_;
		  obj->unlock(this->task_);
		}
            }

	  this->members_[i] = this->members_.back();
	  this->members_.pop_back();
	}
    }
  while (added_new_object);
}

// Include a lib group member in the link.

void
Lib_group::include_member(Symbol_table* symtab, Layout* layout,
			  Input_objects* input_objects,
			  const Archive_member& member)
{
  ++Lib_group::total_members_loaded;

  Object* obj = member.obj_;
  gold_assert(obj != NULL);

  Pluginobj* pluginobj = obj->pluginobj();
  if (pluginobj != NULL)
    {
      pluginobj->add_symbols(symtab, NULL, layout);
      return;
    }

  Read_symbols_data* sd = member.sd_;
  gold_assert(sd != NULL);
  obj->lock(this->task_);
  if (input_objects->add_object(obj))
    {
      if (layout->incremental_inputs() != NULL)
	layout->incremental_inputs()->report_object(obj, member.arg_serial_,
						    this, NULL);
      obj->layout(symtab, layout, sd);
      obj->add_symbols(symtab, sd, layout);
    }
  delete sd;
  // Unlock the file for the next task.
  obj->unlock(this->task_);
}

// Iterate over all unused symbols, and call the visitor class V for each.

void
Lib_group::do_for_all_unused_symbols(Symbol_visitor_base* v) const
{
  // Files are removed from the members list when used, so all the
  // files remaining on the list are unused.
  for (std::vector<Archive_member>::const_iterator p = this->members_.begin();
       p != this->members_.end();
       ++p)
    {
      Object* obj = p->obj_;
      obj->for_all_global_symbols(p->sd_, v);
    }
}

// Print statistical information to stderr.  This is used for --stats.

void
Lib_group::print_stats()
{
  fprintf(stderr, _("%s: lib groups: %u\n"),
          program_name, Lib_group::total_lib_groups);
  fprintf(stderr, _("%s: total lib groups members: %u\n"),
          program_name, Lib_group::total_members);
  fprintf(stderr, _("%s: loaded lib groups members: %u\n"),
          program_name, Lib_group::total_members_loaded);
}

Task_token*
Add_lib_group_symbols::is_runnable()
{
  if (this->readsyms_blocker_ != NULL && this->readsyms_blocker_->is_blocked())
    return this->readsyms_blocker_;
  if (this->this_blocker_ != NULL && this->this_blocker_->is_blocked())
    return this->this_blocker_;
  return NULL;
}

void
Add_lib_group_symbols::locks(Task_locker* tl)
{
  tl->add(this, this->next_blocker_);
}

void
Add_lib_group_symbols::run(Workqueue*)
{
  // For an incremental link, begin recording layout information.
  Incremental_inputs* incremental_inputs = this->layout_->incremental_inputs();
  if (incremental_inputs != NULL)
    incremental_inputs->report_archive_begin(this->lib_, 0, NULL);

  this->lib_->add_symbols(this->symtab_, this->layout_, this->input_objects_);

  if (incremental_inputs != NULL)
    incremental_inputs->report_archive_end(this->lib_);
}

Add_lib_group_symbols::~Add_lib_group_symbols()
{
  if (this->this_blocker_ != NULL)
    delete this->this_blocker_;
  // next_blocker_ is deleted by the task associated with the next
  // input file.
}

} // End namespace gold.
@


1.72
log
@2013-03-29  Sriraman Tallam  <tmsriram@@google.com>

	* archive.cc (Archive::get_elf_object_for_member):  Create the elf
	object before calling the plugin claim_file handler.  Pass the elf
	object of the archive to the plugin. Delete the elf object if the
	plugin claims the file.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d1134 1
a1134 1
  : Library_base(task), lib_(lib), members_()
@


1.72.2.1
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@d3 1
a3 2
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2013
// Free Software Foundation, Inc.
d1133 1
a1133 1
  : Library_base(task), members_()
@


1.71
log
@	* archive.cc (Library_base::should_include_member): Check for
	--export-dynamic-symbol.
	* options.h (class General_options): Add --export-dynamic-symbol.
	* symtab.cc (Symbol::should_add_dynsym_entry): Check for
	--export-dynamic-symbol.
	(Symbol_table::gc_mark_undef_symbols): Likewise.
	(Symbol_table::do_add_undefined_symbols_from_command_line): Likewise.
@
text
@d657 14
d673 6
a678 5
      Object* obj = parameters->options().plugins()->claim_file(input_file,
                                                                memoff,
                                                                memsize,
								NULL);
      if (obj != NULL)
d682 4
a685 1
          return obj;
d689 1
a689 3
  const unsigned char* ehdr;
  int read_size;
  if (!is_elf_object(input_file, memoff, &ehdr, &read_size))
a695 4
  Object* obj = make_elf_object((std::string(this->input_file_->filename())
				 + "(" + member_name + ")"),
				input_file, memoff, ehdr, read_size,
				punconfigured);
@


1.70
log
@2011-07-13  Sriraman Tallam  <tmsriram@@google.com>

	* plugin-api.h
	(ld_plugin_section): New struct.
	(ld_plugin_get_section_count): New typedef.
	(ld_plugin_get_section_type): New typedef.
	(ld_plugin_get_section_name): New typedef.
	(ld_plugin_get_section_contents): New typedef.
	(ld_plugin_update_section_order): New typedef.
	(ld_plugin_allow_section_ordering): New typedef.
	(LDPT_GET_SECTION_COUNT): New enum value.
	(LDPT_GET_SECTION_TYPE): New enum value.
	(LDPT_GET_SECTION_NAME): New enum value.
	(LDPT_GET_SECTION_CONTENTS): New enum value.
	(LDPT_UPDATE_SECTION_ORDER): New enum value.
	(LDPT_ALLOW_SECTION_ORDERING): New enum value.
	(tv_get_section_count): New struct members.
	(tv_get_section_type): New struct members.
	(tv_get_section_name): New struct members.
	(tv_get_section_contents): New struct members.
	(tv_update_section_order): New struct members.
	(tv_allow_section_ordering): New struct members.
	* archive.cc (Archive::get_elf_object_for_member): Add extra parameter
	to claim_file call.
	* layout.cc (Layout::Layout): Initialize section_ordering_specified_,
	input_section_position_, and input_section_glob_.
	(read_layout_from_file): Call function section_ordering_specified.
	* layout.h (is_section_ordering_specified): New function.
	(section_ordering_specified): New function.
	(section_ordering_specified_): New boolean member.
	* main.cc(main): Call load_plugins after layout object is defined.
	* output.cc (Output_section::add_input_section): Use
	function section_ordering_specified to check if section ordering is
	needed.
	* output.cc (Output_section::add_relaxed_input_section): Use
	function section_ordering_specified to check if section ordering is
	needed.
	(Output_section::update_section_layout): New function.
	(Output_section::sort_attached_input_sections): Check if input section
	must be reordered.
	* output.h (Output_section::update_section_layout): New function.
	* plugin.cc (get_section_count): New function.
	(get_section_type): New function.
	(get_section_name): New function.
	(get_section_contents): New function.
	(update_section_order): New function.
	(allow_section_ordering): New function.
	(Plugin::load): Add the new interfaces to the transfer vector.
	(Plugin_manager::load_plugins): New parameter.
	(Plugin_manager::all_symbols_read): New parameter.
	(Plugin_manager::claim_file): New parameter. Save the elf object for
	unclaimed objects.
	(Plugin_manager::get_elf_object): New function.
	(Plugin_manager::get_view): Change to directly use the bool to check
	if get_view is called from claim_file_hook.
	* plugin.h (input_objects): New function
	(Plugin__manager::load_plugins): New parameter.
	(Plugin_manager::claim_file): New parameter.
	(Plugin_manager::get_elf_object): New function.
	(Plugin_manager::in_claim_file_handler): New function.
	(Plugin_manager::in_claim_file_handler_): New member.
	(layout): New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Call the claim_file
	handler with an extra parameter. Make the elf object before calling
	claim_file handler.
	* testsuite/plugin_test.c (get_section_count): New function pointer.
	(get_section_type): New function pointer.
	(get_section_name): New function pointer.
	(get_section_contents): New function pointer.
	(update_section_order): New function pointer.
	(allow_section_ordering): New function pointer.
	(onload): Check if the new interfaces exist.
@
text
@d107 5
@


1.69
log
@	PR gold/12163
	* gold/archive.cc (Archive::Archive): Initialize new data member.
	(Archive::include_all_members): Return if archive has already been
	included.
	* gold/archive.h (Archive::include_all_members_): New data member.
@
text
@d656 2
a657 1
                                                                memsize);
@


1.68
log
@	* archive.cc (Library_base::should_include_member): Pull in object
	from archive if it defines the entry symbol.
	* parameters.cc (Parameters::entry): New function.
	* parameters.h (class Parameters): Declare entry.
	* output.h (class Output_file_header): Remove entry_ field.
	* output.cc (Output_file_header::Output_file_header): Remove entry
	parameter.  Change all callers.
	(Output_file_header::entry): Use parameters->entry.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (Plugin_hook::run): Likewise.
@
text
@d182 2
a183 1
    nested_archives_(), dirpath_(dirpath), num_members_(0)
d851 7
@


1.67
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d116 5
@


1.66
log
@	* archive.cc (Archive::include_member): Adjust call to report_object.
	(Add_archive_symbols::run): Add script_info to call to
	report_archive_begin.
	(Lib_group::include_member): Adjust call to report_object.
	(Add_lib_group_symbols::run): Adjust call to report_object.
	* incremental-dump.cc (dump_incremental_inputs): Remove unnecessary
	blocks.  Add object count for script input files.
	* incremental.cc (Incremental_inputs::report_archive_begin): Add
	script_info parameter; change all callers.
	(Incremental_inputs::report_object): Add script_info parameter;
	change all callers.
	(Incremental_inputs::report_script): Store backpointer to
	incremental info entry.
	(Output_section_incremental_inputs::set_final_data_size): Record
	additional information for scripts.
	(Output_section_incremental_inputs::write_info_blocks): Likewise.
	* incremental.h (Incremental_script_entry::add_object): New function.
	(Incremental_script_entry::get_object_count): New function.
	(Incremental_script_entry::get_object): New function.
	(Incremental_script_entry::objects_): New data member; adjust
	constructor.
	(Incremental_inputs::report_archive_begin): Add script_info parameter.
	(Incremental_inputs::report_object): Add script_info parameter.
	(Incremental_inputs_reader::get_object_count): New function.
	(Incremental_inputs_reader::get_object_offset): New function.
	* options.cc (Input_arguments::add_file): Return reference to
	new input argument.
	* options.h (Input_argument::set_script_info): New function.
	(Input_argument::script_info): New function.
	(Input_argument::script_info_): New data member; adjust all
	constructors.
	(Input_file_group::add_file): Return reference to new input argument.
	(Input_file_lib::add_file): Likewise.
	(Input_arguments::add_file): Likewise.
	* readsyms.cc (Add_symbols::run): Adjust call to report_object.
	* script.cc (Parser_closure::Parser_closure): Add script_info
	parameter; adjust all callers.
	(Parser_closure::script_info): New function.
	(Parser_closure::script_info_): New data member.
	(read_input_script): Report scripts earlier to incremental info.
	(script_add_file): Set script_info in Input_argument.
	(script_add_library): Likewise.
	* script.h (Script_options::Script_info): Rewrite class.
@
text
@d963 1
a963 1
	  layout->incremental_inputs()->report_object(obj, this, NULL);
d1043 6
a1048 2
    incremental_inputs->report_archive_begin(this->archive_,
					this->input_argument_->script_info());
d1110 1
a1110 1
  std::string *filename = new std::string("<group>");
d1204 2
a1205 1
	layout->incremental_inputs()->report_object(obj, this, NULL);
d1265 1
a1265 1
    incremental_inputs->report_archive_begin(this->lib_, NULL);
@


1.65
log
@	* archive.cc (Library_base::should_include_member): Move
	method here from class Archive.
	(Archive::Archive): Initialize base class.
	(Archive::should_include_member): Move to base class.
	(Archive::do_for_all_unused_symbols): New function.
	(Add_archive_symbols::run): Remove redundant access to
	incremental_inputs.
	(Lib_group::Lib_group): Initialize base class.
	(Lib_group::do_filename): New function.
	(Lib_group::include_member): Pass pointer to Lib_group to
	report_object.
	(Lib_group::do_for_all_unused_symbols): New function.
	(Add_lib_group_symbols::run): Report archive information for
	incremental links.
	* archive.h (class Library_base): New base class.
	(class Archive): Derive from Library_base.
	(Archive::filename): Move to base class.
	(Archive::set_incremental_info): Likewise.
	(Archive::incremental_info): Likewise.
	(Archive::Should_include): Likewise.
	(Archive::should_include_member): Likewise.
	(Archive::Armap_entry): Remove.
	(Archive::Unused_symbol_iterator): Remove.
	(Archive::unused_symbols_begin): Remove.
	(Archive::unused_symbols_end): Remove.
	(Archive::do_filename): New function.
	(Archive::do_get_mtime): New function.
	(Archive::do_for_all_unused_symbols): New function.
	(Archive::task_): Move to base class.
	(Archive::incremental_info_): Likewise.
	(class Lib_group): Derive from Library_base.
	(Lib_group::do_filename): New function.
	(Lib_group::do_get_mtime): New function.
	(Lib_group::do_for_all_unused_symbols): New function.
	(Lib_group::task_): Move to base class.
	* dynobj.cc (Sized_dynobj::do_for_all_global_symbols): New
	function.
	* dynobj.h (Sized_dynobj::do_for_all_global_symbols): New
	function.
	* incremental.cc (Incremental_inputs::report_archive_begin):
	Use Library_base; call library's get_mtime; add incremental inputs
	entry before members.
	(class Unused_symbol_visitor): New class.
	(Incremental_inputs::report_archive_end): Use Library_base; use
	visitor class to record unused symbols; don't add incremental inputs
	entry after members.
	(Incremental_inputs::report_object): Use Library_base.
	* incremental.h
	(Incremental_archive_entry::Incremental_archive_entry): Remove
	unused Archive parameter.
	(Incremental_inputs::report_archive_begin): Use Library_base.
	(Incremental_inputs::report_archive_end): Likewise.
	(Incremental_inputs::report_object): Likewise.
	* object.cc (Sized_relobj::do_for_all_global_symbols): New
	function.
	* object.h (Object::for_all_global_symbols): New function.
	(Object::do_for_all_global_symbols): New function.
	(Sized_relobj::do_for_all_global_symbols): New function.
	* plugin.cc (Sized_pluginobj::do_for_all_global_symbols):  New
	function.
	* plugin.h (Sized_pluginobj::do_for_all_global_symbols):  New
	function.
@
text
@d963 1
a963 1
	  layout->incremental_inputs()->report_object(obj, this);
d1043 2
a1044 1
    incremental_inputs->report_archive_begin(this->archive_);
d1200 1
a1200 1
	layout->incremental_inputs()->report_object(obj, this);
d1260 1
a1260 1
    incremental_inputs->report_archive_begin(this->lib_);
@


1.64
log
@	* archive.cc (Archive::interpret_header): Return -1 if something
	goes wrong.  Change callers accordingly.
@
text
@d47 84
d174 4
a177 5
  : name_(name), input_file_(input_file), armap_(), armap_names_(),
    extended_names_(), armap_checked_(), seen_offsets_(), members_(),
    is_thin_archive_(is_thin_archive), included_member_(false),
    nested_archives_(), dirpath_(dirpath), task_(task), num_members_(0),
    incremental_info_(NULL)
a704 76
Archive::Should_include
Archive::should_include_member(Symbol_table* symtab, Layout* layout,
			       const char* sym_name, Symbol** symp,
			       std::string* why, char** tmpbufp,
                               size_t* tmpbuflen)
{
  // In an object file, and therefore in an archive map, an
  // '@@' in the name separates the symbol name from the
  // version name.  If there are two '@@' characters, this is
  // the default version.
  char* tmpbuf = *tmpbufp;
  const char* ver = strchr(sym_name, '@@');
  bool def = false;
  if (ver != NULL)
    {
      size_t symlen = ver - sym_name;
      if (symlen + 1 > *tmpbuflen)
        {
          tmpbuf = static_cast<char*>(xrealloc(tmpbuf, symlen + 1));
          *tmpbufp = tmpbuf;
          *tmpbuflen = symlen + 1;
        }
      memcpy(tmpbuf, sym_name, symlen);
      tmpbuf[symlen] = '\0';
      sym_name = tmpbuf;

      ++ver;
      if (*ver == '@@')
        {
          ++ver;
          def = true;
        }
    }

  Symbol* sym = symtab->lookup(sym_name, ver);
  if (def
      && ver != NULL
      && (sym == NULL
          || !sym->is_undefined()
          || sym->binding() == elfcpp::STB_WEAK))
    sym = symtab->lookup(sym_name, NULL);

  *symp = sym;

  if (sym == NULL)
    {
      // Check whether the symbol was named in a -u option.
      if (parameters->options().is_undefined(sym_name))
        {
          *why = "-u ";
          *why += sym_name;
        }
      else if (layout->script_options()->is_referenced(sym_name))
	{
	  size_t alc = 100 + strlen(sym_name);
	  char* buf = new char[alc];
	  snprintf(buf, alc, _("script or expression reference to %s"),
		   sym_name);
	  *why = buf;
	  delete[] buf;
	}
      else
	return Archive::SHOULD_INCLUDE_UNKNOWN;
    }
  else if (!sym->is_undefined())
    return Archive::SHOULD_INCLUDE_NO;
  // PR 12001: Do not include an archive when the undefined
  // symbol has actually been defined on the command line.
  else if (layout->script_options()->is_pending_assignment(sym_name))
    return Archive::SHOULD_INCLUDE_NO;
  else if (sym->binding() == elfcpp::STB_WEAK)
    return Archive::SHOULD_INCLUDE_UNKNOWN;

  return Archive::SHOULD_INCLUDE_YES;
}

d981 15
a1071 1
      Incremental_inputs* incremental_inputs = this->layout_->incremental_inputs();
d1097 1
a1097 1
  : lib_(lib), task_(task), members_()
d1102 7
a1197 1
      // FIXME: Record incremental link info for --start-lib/--end-lib.
d1199 1
a1199 1
	layout->incremental_inputs()->report_object(obj, NULL);
d1208 16
d1256 5
d1263 2
a1264 1
  // FIXME: Record incremental link info for --start_lib/--end_lib.
@


1.63
log
@	* plugin.cc (class Plugin_rescan): Define new class.
	(Plugin_manager::claim_file): Set any_claimed_.
	(Plugin_manager::save_archive): New function.
	(Plugin_manager::save_input_group): New function.
	(Plugin_manager::all_symbols_read): Create Plugin_rescan task if
	necessary.
	(Plugin_manager::new_undefined_symbol): New function.
	(Plugin_manager::rescan): New function.
	(Plugin_manager::rescannable_defines): New function.
	(Plugin_manager::add_input_file): Set any_added_.
	* plugin.h (class Plugin_manager): define new fields rescannable_,
	undefined_symbols_, any_claimed_, and any_added_.  Declare
	Plugin_rescan as friend.  Declare new functions.
	(Plugin_manager::Rescannable): Define type.
	(Plugin_manager::Rescannable_list): Define type.
	(Plugin_manager::Undefined_symbol_list): Define type.
	(Plugin_manager::Plugin_manager): Initialize new fields.
	* archive.cc (Archive::defines_symbol): New function.
	(Add_archive_symbols::run): Pass archive to plugins if any.
	* archive.h (class Archive): Declare defines_symbol.
	* readsyms.cc (Input_group::~Input_group): New function.
	(Finish_group::run): Pass input_group to plugins if any.
	* readsyms.h (class Input_group): Declare destructor.
	* symtab.cc (add_from_object): Pass undefined symbol to plugins if
	any.
@
text
@d112 5
a116 3
  section_size_type armap_size =
    convert_to_section_size_type(this->read_header(sarmag, false,
						   &armap_name, NULL));
d133 5
a137 2
  section_size_type extended_size =
    convert_to_section_size_type(this->read_header(off, true, &xname, NULL));
d235 2
a236 2
// file offset OFF.  Fail if something goes wrong.  Return the size of
// the member.  Set *PNAME to the name of the member.
d246 1
a246 1
      return this->input_file_->file().filesize() - off;
d266 1
a266 1
      return this->input_file_->file().filesize() - off;
d277 1
a277 1
	  return this->input_file_->file().filesize() - off;
d308 1
a308 1
	  return this->input_file_->file().filesize() - off;
d318 1
a318 1
	  return this->input_file_->file().filesize() - off;
d426 10
a435 3
      this->header_.size =
	this->archive_->interpret_header(hdr, this->off_, &this->header_.name,
					 &this->header_.nested_off);
d477 2
@


1.62
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d782 36
d1040 12
a1051 2
      // We no longer need to know about this archive.
      delete this->archive_;
@


1.61
log
@	* archive.cc (Archive::get_elf_object_for_member): Permit
	punconfigured to be NULL.
	(Archive::read_symbols): Pass NULL to get_elf_object_for_member.
	(Archive::include_member): Pass NULL to get_elf_object_for_member
	if we searched for the archive and this is the first included
	object.
@
text
@d48 1
a48 1
// padded with spaces where necesary.  If the contents of an archive
d1022 1
a1022 1
// through the the members, and check if each one up should be included.
@


1.60
log
@        PR ld/12001
        * ldlang.c (ldlang_def_chain_list): New variable.  Contains a list
        of symbols defined via the --defsym command line option and
        currently waiting assignment.
        (insert_defined): Add a defined symbol to the symbol table.
        (ldlang_add_def): Add a entry to the ldlang_def_chain_list.
        (lang_place_defineds): Walk ldlang_def_chain_list defining the
        symbols.
        (lang_process): Call lang_place_defineds.
        (lang_add_assignment): If the assignment has come from a --defsym
        command line option then call lang_add_def.

        * ld-script/default-script2.d: Fix expected address for text
        section.

        PR gold/12001
        * script.h (class Symbol_assignment: name): New member.  Returns
        the name of the symbol.
        * scrfipt.cc (Script_options::is_pending_assignment): New member.
        Returns true if the given symbol name is on the list of
        assignments wating to be processed.
        * archive.cc (should_incldue_member): If the symbol is undefined,
        check to see if it is on the list of symbols pending assignment.
@
text
@d530 4
a533 3
// Return an ELF object for the member at offset OFF.  If the ELF
// object has an unsupported target type, set *PUNCONFIGURED to true
// and return NULL.
d538 2
a539 1
  *punconfigured = false;
d598 1
a598 3
  bool dummy;
  Object* obj = this->get_elf_object_for_member(off, &dummy);

d866 8
a873 8
  bool unconfigured;
  Object* obj = this->get_elf_object_for_member(off, &unconfigured);

  if (!this->included_member_
      && this->searched_for()
      && obj == NULL
      && unconfigured)
    return false;
d875 1
d877 5
a881 1
    return true;
@


1.60.2.1
log
@	* plugin.cc (class Plugin_rescan): Define new class.
	(Plugin_manager::claim_file): Set any_claimed_.
	(Plugin_manager::save_archive): New function.
	(Plugin_manager::save_input_group): New function.
	(Plugin_manager::all_symbols_read): Create Plugin_rescan task if
	necessary.
	(Plugin_manager::new_undefined_symbol): New function.
	(Plugin_manager::rescan): New function.
	(Plugin_manager::rescannable_defines): New function.
	(Plugin_manager::add_input_file): Set any_added_.
	* plugin.h (class Plugin_manager): define new fields rescannable_,
	undefined_symbols_, any_claimed_, and any_added_.  Declare
	Plugin_rescan as friend.  Declare new functions.
	(Plugin_manager::Rescannable): Define type.
	(Plugin_manager::Rescannable_list): Define type.
	(Plugin_manager::Undefined_symbol_list): Define type.
	(Plugin_manager::Plugin_manager): Initialize new fields.
	* archive.cc (Archive::defines_symbol): New function.
	(Add_archive_symbols::run): Pass archive to plugins if any.
	* archive.h (class Archive): Declare defines_symbol.
	* readsyms.cc (Input_group::~Input_group): New function.
	(Finish_group::run): Pass input_group to plugins if any.
	* readsyms.h (class Input_group): Declare destructor.
	* symtab.cc (add_from_object): Pass undefined symbol to plugins if
	any.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
a781 36
// Return whether the archive includes a member which defines the
// symbol SYM.

bool
Archive::defines_symbol(Symbol* sym) const
{
  const char* symname = sym->name();
  size_t symname_len = strlen(symname);
  size_t armap_size = this->armap_.size();
  for (size_t i = 0; i < armap_size; ++i)
    {
      if (this->armap_checked_[i])
	continue;
      const char* archive_symname = (this->armap_names_.data()
				     + this->armap_[i].name_offset);
      if (strncmp(archive_symname, symname, symname_len) != 0)
	continue;
      char c = archive_symname[symname_len];
      if (c == '\0' && sym->version() == NULL)
	return true;
      if (c == '@@')
	{
	  const char* ver = archive_symname + symname_len + 1;
	  if (*ver == '@@')
	    {
	      if (sym->version() == NULL)
		return true;
	      ++ver;
	    }
	  if (sym->version() != NULL && strcmp(sym->version(), ver) == 0)
	    return true;
	}
    }
  return false;
}

d999 2
a1000 12
      if (!parameters->options().has_plugins()
	  || this->archive_->input_file()->options().whole_archive())
	{
	  // We no longer need to know about this archive.
	  delete this->archive_;
	}
      else
	{
	  // The plugin interface may want to rescan this archive.
	  parameters->options().plugins()->save_archive(this->archive_);
	}

@


1.59
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d674 4
@


1.58
log
@	* archive.cc (Lib_group::add_symbols): Lock object before deleting its
	symbols data.
	(Lib_group::include_member): Unlock object after deleting its
	symbols data.
	* testsuite/start_lib_test_3.c: Remove all global symbols to trigger
	the bug fixed here.
@
text
@d569 1
a569 1
  Object *obj = make_elf_object((std::string(this->input_file_->filename())
d847 1
a847 1
      Object *obj = p->second.obj_;
d849 1
a849 1
      Read_symbols_data *sd = p->second.sd_;
d1034 1
a1034 1
	  Object *obj = member.obj_;
@


1.57
log
@	* gold/archive.h (Add_lib_group_symbols): Add readsyms_blocker_, adjust
	constructor, and set_blocker.
	* gold/archive.cc (Add_lib_group_symbols::is_runnable): Also check
	readsyms_blocker_.
	* gold/readsyms.cc (Read_symbols::do_lib_group): Also pass
	this->this_blocker_ to Add_lib_group_symbols::set_blocker.
	* testsuite/Makefile.am (start_lib_test): New test case.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/start_lib_test_main.c: New file.
	* testsuite/start_lib_test_1.c: New file.
	* testsuite/start_lib_test_2.c: New file.
	* testsuite/start_lib_test_3.c: New file.
@
text
@d1060 8
a1067 1
                delete member.sd_;
a1105 2
      // Unlock the file for the next task.
      obj->unlock(this->task_);
d1108 2
@


1.56
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_SYMTAB,
	SHT_GNU_INCREMENTAL_RELOCS.

gold/ChangeLog:

	* archive.cc: Include incremental.h.
	(Archive::Archive): Initialize incremental_info_.
	(Archive::include_member): Record archive members in incremental info.
	(Add_archive_symbols::run): Record begin and end of an archive in
	incremental info.
	(Lib_group::include_member): Record objects in incremental info.
	* archive.h (Incremental_archive_entry): Forward declaration.
	(Archive::set_incremental_info): New member function.
	(Archive::incremental_info): New member function.
	(Archive::Unused_symbol_iterator): New class.
	(Archive::unused_symbols_begin): New member function.
	(Archive::unused_symbols_end): New member function.
	(Archive::incremental_info_): New data member.
	* incremental-dump.cc (find_input_containing_global): New function.
	(dump_incremental_inputs): Dump new incremental info sections.
	* incremental.cc: Include symtab.h.
	(Output_section_incremental_inputs): New class.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Support
	new incremental info sections.
	(Sized_incremental_binary::do_check_inputs): Likewise.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): New function.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Rewrite.
	(Incremental_inputs::finalize): Do nothing but finalize string table.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Output_section_incremental_inputs::set_final_data_size): New function.
	(Output_section_incremental_inputs::do_write): New function.
	(Output_section_incremental_inputs::write_header): New function.
	(Output_section_incremental_inputs::write_input_files): New function.
	(Output_section_incremental_inputs::write_info_blocks): New function.
	(Output_section_incremental_inputs::write_symtab): New function.
	* incremental.h (Incremental_script_entry): Forward declaration.
	(Incremental_object_entry): Forward declaration.
	(Incremental_archive_entry): Forward declaration.
	(Incremental_inputs): Forward declaration.
	(Incremental_inputs_header_data): Remove.
	(Incremental_inputs_header): Remove.
	(Incremental_inputs_header_write): Remove.
	(Incremental_inputs_entry_data): Remove.
	(Incremental_inputs_entry): Remove.
	(Incremental_inputs_entry_write): Remove.
	(enum Incremental_input_type): Add INCREMENTAL_INPUT_ARCHIVE_MEMBER.
	(Incremental_binary::find_incremental_inputs_sections): Add parameters.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Sized_ncremental_binary::do_find_incremental_inputs_sections):
	Likewise.
	(Incremental_input_entry): New class.
	(Incremental_script_entry): New class.
	(Incremental_object_entry): New class.
	(Incremental_archive_entry): New class.
	(Incremental_inputs::Incremental_inputs): Initialize new data members.
	(Incremental_inputs::report_inputs): Remove.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): Change prototype.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Change prototype.
	(Incremental_inputs::get_reloc_count): New function.
	(Incremental_inputs::set_reloc_count): New function.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::inputs_section): New function.
	(Incremental_inputs::symtab_section): New function.
	(Incremental_inputs::relocs_section): New function.
	(Incremental_inputs::get_stringpool): Add const.
	(Incremental_inputs::command_line): Add const.
	(Incremental_inputs::inputs): Remove.
	(Incremental_inputs::command_line_key): New function.
	(Incremental_inputs::input_file_count): New function.
	(Incremental_inputs::input_files): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::Input_info): Remove.
	(Incremental_inputs::lock_): Remove.
	(Incremental_inputs::inputs_): Change type.
	(Incremental_inputs::inputs_map_): Remove.
	(Incremental_inputs::current_object_entry_): New data member.
	(Incremental_inputs::inputs_section_): New data member.
	(Incremental_inputs::symtab_section_): New data member.
	(Incremental_inputs::relocs_section_): New data member.
	(Incremental_inputs::reloc_count_): New data member.
	(Incremental_inputs_reader): New class.
	(Incremental_symtab_reader): New class.
	(Incremental_relocs_reader): New class.
	* layout.cc (Layout::finalize): Move finalization of incremental info
	and creation of incremental info sections to follow finalization of
	symbol table.  Set offsets for postprocessing sections.
	(Layout::create_incremental_info_sections): Call
	Incremental_inputs::create_data_sections.  Add incremental symtab
	and relocs sections.  Set sh_entsize and sh_link fields.  Arrange for
	sections to layout after input sections.
	* layout.h (struct Timespec): Forward declaration.
	(Layout::incremental_inputs): Add const.
	(Layout::create_incremental_info_sections): Add parameter.
	* main.cc (main): Remove call to Incremental_inputs::report_inputs.
	* object.cc: Include incremental.h.
	(Relobj::finalize_incremental_relocs): New function.
	(Sized_relobj::do_layout): Record input sections in incremental info.
	* object.h (Object::output_section): New function.
	(Object::output_section_offset): Moved from Relobj.
	(Object::get_incremental_reloc_base): New function.
	(Object::get_incremental_reloc_count): New function.
	(Object::do_output_section): New function.
	(Object::do_output_section_offset): Moved from Relobj.
	(Object::do_get_incremental_reloc_base): New function.
	(Object::do_get_incremental_reloc_count): New function.
	(Object::Object): Initialize new data members.
	(Relobj::output_section): Renamed do_output_section and moved to
	protected.
	(Relobj::output_section_offset): Moved to Object.
	(Relobj::do_get_incremental_reloc_base): New function.
	(Relobj::do_get_incremental_reloc_count): New function.
	(Relobj::allocate_incremental_reloc_counts): New function.
	(Relobj::count_incremental_reloc): New function.
	(Relobj::finalize_incremental_relocs): New function.
	(Relobj::next_incremental_reloc_index): New function.
	(Relobj::reloc_counts_): New data member.
	(Relobj::reloc_bases_): New data member.
	(Sized_relobj::do_relocate_sections): Add parameter.  Change caller.
	(Sized_relobj::relocate_sections): Add parameter.  Change all callers.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* plugin.cc (Plugin_manager::add_input_file): Rewrite test for
	incremental link.
	* readsyms.cc (Read_symbols::do_read_symbols): Move reporting of
	archives and object files elsewhere.
	(Add_symbols::run): Report object files here.
	(Finish_group::run): Report end of archive at end of group.
	* reloc.cc: Include layout.h, incremental.h.
	(Sized_relobj::do_read_relocs): Need relocations for incremental link.
	(Sized_relobj::do_scan_relocs): Record relocations for incremental link.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::do_relocate_sections): Write incremental relocations.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* script.cc (read_input_script): Rewrite test for incremental link.
	Change call to Incremental_inputs::report_script.
	* symtab.h (Symbol_table::first_global_index): New function.
	(Symbol_table::output_count): New function.
@
text
@d1121 2
@


1.55
log
@	PR 11855
	* script.cc (Script_options::Script_options): Initialize
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_assignment): Update
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_reference): New function.
	(script_symbol): New function.
	* script.h (class Script_options): Add symbol_definitions_ and
	symbol_references_ fields.
	(Script_options::referenced_const_iterator): New type.
	(Script_options::referenced_begin): New function.
	(Script_options::referenced_end): New function.
	(Script_options::is_referenced): New function.
	(Script_options::any_unreferenced): New function.
	* script-c.h (script_symbol): Declare.
	* yyscript.y (exp): Call script_symbol.
	* symtab.cc: Include "script.h".
	(Symbol_table::gc_mark_undef_symbols): Add layout parameter.
	Change all callers.  Check symbols referenced by scripts.
	(Symbol_table::add_undefined_symbols_from_command_line): Add
	layout parameter.  Change all callers.
	(Symbol_table::do_add_undefined_symbols_from_command_line):
	Likewise.  Break out loop body.  Check symbols referenced by
	scripts.
	(Symbol_table::add_undefined_symbol_from_command_line): New
	function broken out of
	do_add_undefined_symbols_from_command_line.
	* symtab.h (class Symbol_table): Update declarations.
	* archive.cc: Include "layout.h".
	(Archive::should_include_member): Add layout parameter.  Change
	all callers.  Check for symbol mentioned in expression.
	* archive.h (class Archive): Update declaration.
	* object.cc (Sized_relobj::do_should_include_member): Add layout
	parameter.
	* object.h (Object::should_include_member): Add layout parameter.
	Change all callers.
	(Object::do_should_include_member): Add layout parameter.
	(class Sized_relobj): Update declaration.
	* dynobj.cc (Sized_dynobj::do_should_include_member): Add layout
	parameter.
	* dynobj.h (class Sized_dynobj): Update declaration.
	* plugin.cc (Sized_pluginobj::do_should_include_member): Add
	layout parameter.
	* plugin.h (class Sized_pluginobj): Update declaration.
@
text
@d42 1
d93 2
a94 1
    nested_archives_(), dirpath_(dirpath), task_(task), num_members_(0)
d896 2
d959 5
d990 5
d1094 3
d1136 2
@


1.54
log
@	* archive.cc (Archive::include_member): Unlock an external member
	of a thin archive.  Don't bother to delete an object we know is
	NULL.
@
text
@d39 1
d607 3
a609 2
Archive::should_include_member(Symbol_table* symtab, const char* sym_name,
                               Symbol** symp, std::string* why, char** tmpbufp,
d653 1
a653 3
      if (!parameters->options().is_undefined(sym_name))
	return Archive::SHOULD_INCLUDE_UNKNOWN;
      else
d658 11
d740 2
a741 2
              Archive::should_include_member(symtab, sym_name, &sym, &why,
                                             &tmpbuf, &tmpbuflen);
d1029 1
@


1.53
log
@	* archive.cc (include_member): Destroy Read_symbols_data object before
	releasing file.
	* object.cc (Read_symbols_data::~Read_symbols_data) New destructor.
	* object.h (Read_symbols_data::Read_symbols_data) New constructor.
	(Read_symbols_data::~Read_symbols_data) New destructor.
	(Section_relocs::Section_relocs) New constructor.
	(Section_relocs::~Section_relocs) New destructor.
	(Read_relocs_data::Read_relocs_data) New constructor.
	(Read_relocs_data::~Read_relocs_data) New destructor.
	* testsuite/binary_unittest.cc (Sized_binary_test): Set sd member
	pointers to NULL after deleting.
@
text
@d856 1
a856 5
    {
      if (obj != NULL)
	delete obj;
      return false;
    }
d873 7
a879 1
    delete obj;
@


1.52
log
@2010-03-22  Rafael Espindola  <espindola@@google.com>

	* archive.cc (Should_include): Move to archive.h.
	(should_include_member): Make it a member of Archive.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* archive.h: Include options.h.
	(Archive_member): Moved from Archive.
	(Should_include): Moved from archive.cc.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* dynobj.cc (do_should_include_member): New.
	* dynobj.h (do_should_include_member): New.
	* gold.cc (queue_initial_tasks): Update call to queue.
	* main.cc (main): Print lib group stats.
	* object.cc (do_should_include_member): New.
	* object.h: Include archive.h.
	(Object::should_include_member): New.
	(Object::do_should_include_member): New.
	(Sized_relobj::do_should_include_member): New.
	* options.cc (General_options::parse_start_lib): New.
	(General_options::parse_end_lib): New.
	(Input_arguments::add_file): Handle lib groups.
	(Input_arguments::start_group): Check we are not in a lib.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib): New.
	* options.h (General_options): Add start_lib and end_lib.
	(Input_argument::lib_): New.
	(Input_argument::lib): New.
	(Input_argument::is_lib): New.
	(Input_file_lib): New.
	(Input_arguments::in_lib_): New.
	(Input_arguments::in_lib): New.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib_): New.
	* plugin.cc (Pluginobj::get_symbol_resolution_info): Mark symbols
	in unused members as preempted.
	(Sized_pluginobj::do_should_include_member): New.
	* plugin.h (Sized_pluginobj::do_should_include_member): New.
	* readsyms.cc (Read_symbols::locks): If we are just reading a member,
	return the blocker.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::do_read_symbols): Handle lib groups.
	(Read_symbols::get_name): Handle lib groups.
	* readsyms.h (Read_symbols): Add an archive member pointer.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::member_): New.
	* script.cc (read_input_script): Update call to queue_soon.
@
text
@d880 6
a885 4
      Read_symbols_data sd;
      obj->read_symbols(&sd);
      obj->layout(symtab, layout, &sd);
      obj->add_symbols(symtab, &sd, layout);
@


1.51
log
@2010-03-09   Rafael Espindola  <espindola@@google.com>

	* archive.cc (should_include_member): New.
	(Archive::add_symbols): Use should_include_member.
@
text
@d605 4
a608 14
// When we see a symbol in an archive we might decide to include the member,
// not include the member or be undecided.  This enum represents these
// possibilities.

enum Should_include
{
 SHOULD_INCLUDE_NO,
 SHOULD_INCLUDE_YES,
 SHOULD_INCLUDE_UNKNOWN
};

static Should_include
should_include_member(Symbol_table* symtab, const char* sym_name, Symbol** symp,
                      std::string* why, char** tmpbufp, size_t* tmpbuflen)
d652 1
a652 1
	return SHOULD_INCLUDE_UNKNOWN;
d660 1
a660 1
    return SHOULD_INCLUDE_NO;
d662 1
a662 1
    return SHOULD_INCLUDE_UNKNOWN;
d664 1
a664 1
  return SHOULD_INCLUDE_YES;
d728 3
a730 3
          Should_include t = should_include_member(symtab, sym_name,
                                                   &sym, &why, &tmpbuf,
                                                   &tmpbuflen);
d732 2
a733 1
	  if (t == SHOULD_INCLUDE_NO || t == SHOULD_INCLUDE_YES)
d736 1
a736 1
	  if (t != SHOULD_INCLUDE_YES)
d972 141
@


1.50
log
@	* gold-threads.h (class Once): Define.
	(class Initialize_lock): Rewrite as child of Once.
	* gold-threads.cc (class Once_initialize): Define.
	(once_pointer_control): New static variable.
	(once_pointer, once_arg): New static variables.
	(c_run_once): New static function.
	(Once::Once, Once::run_once, Once::internal_run): New functions.
	(class Initialize_lock_once): Remove.
	(initialize_lock_control): Remove.
	(initialize_lock_pointer): Remove.
	(initialize_lock_once): Remove.
	(Initialize_lock::Initialize_lock): Move to gold-threads.h.
	(Initialize_lock::initialize): Rewrite.
	(Initialize_lock::do_run_once): New function.
	* archive.cc (Archive::interpret_header): Only clear name if it is
	not already empty.
	* fileread.cc: Include "gold-threads.h"
	(file_counts_lock): New static variable.
	(file_counts_initialize_lock): Likewise.
	(File_read::release): Only increment counts when using --stats.
	Use a lock around the increment.
	* parameters.cc (class Set_parameters_target_once): Define.
	(set_parameters_target_once): New static variable.
	(Parameters::Parameters): Move here from parameters.h.
	(Parameters::set_target): Rewrite.
	(Parameters::set_target_once): New function.
	(Parameters::clear_target): Move here and rewrite.
	* parameters.h (class Parameters): Update declarations.  Add
	set_parameters_target_once_ field.
	(Parameters::Parameters): Move to parameters.cc.
	(Parameters::clear_target): Likewise.
	* readsyms.cc (Read_symbols::do_group): Create a Start_group
	task.
	(Start_group::~Start_group): New function.
	(Start_group::is_runnable): New function.
	(Start_group::locks, Start_group::run): New functions.
	(Finish_group::run): Change saw_undefined to size_t.
	* readsyms.h (class Start_group): Define.
	(class Finish_group): Change saw_undefined_ field to size_t.
	(Finish_group::Finish_group): Remove saw_undefined and
	this_blocker parameters.  Change all callers.
	(Finish_group::set_saw_undefined): New function.
	(Finish_group::set_blocker): New function.
	* symtab.h (class Symbol_table): Change saw_undefined to return
	size_t.  Change saw_undefined_ field to size_t.
	* target-select.cc (Set_target_once::do_run_once): New function.
	(Target_selector::Target_selector): Initialize set_target_once_
	field.  Don't initialize lock_ and initialize_lock_ fields.
	(Target_selector::instantiate_target): Rewrite.
	(Target_selector::set_target): New function.
	* target-select.h (class Set_target_once): Define.
	(class Target_selector): Update declarations.  Make
	Set_target_once a friend.  Remove lock_ and initialize_lock_
	fields.  Add set_target_once_ field.
@
text
@d605 72
d736 5
a740 25
	  // In an object file, and therefore in an archive map, an
	  // '@@' in the name separates the symbol name from the
	  // version name.  If there are two '@@' characters, this is
	  // the default version.
	  const char* ver = strchr(sym_name, '@@');
	  bool def = false;
	  if (ver != NULL)
	    {
	      size_t symlen = ver - sym_name;
	      if (symlen + 1 > tmpbuflen)
		{
		  tmpbuf = static_cast<char*>(realloc(tmpbuf, symlen + 1));
		  tmpbuflen = symlen + 1;
		}
	      memcpy(tmpbuf, sym_name, symlen);
	      tmpbuf[symlen] = '\0';
	      sym_name = tmpbuf;

	      ++ver;
	      if (*ver == '@@')
		{
		  ++ver;
		  def = true;
		}
	    }
d742 2
a743 7
	  Symbol* sym = symtab->lookup(sym_name, ver);
	  if (def
	      && ver != NULL
	      && (sym == NULL
		  || !sym->is_undefined()
		  || sym->binding() == elfcpp::STB_WEAK))
	    sym = symtab->lookup(sym_name, NULL);
d745 1
a745 12
	  if (sym == NULL)
	    {
	      // Check whether the symbol was named in a -u option.
	      if (!parameters->options().is_undefined(sym_name))
		continue;
	    }
	  else if (!sym->is_undefined())
	    {
              this->armap_checked_[i] = true;
	      continue;
	    }
	  else if (sym->binding() == elfcpp::STB_WEAK)
a750 1
          this->armap_checked_[i] = true;
a751 6
	  std::string why;
	  if (sym == NULL)
	    {
	      why = "-u ";
	      why += sym_name;
	    }
@


1.49
log
@	* archive.cc (Archive::add_symbols): Only look up a symbol without
	a version if there is, in fact, a version.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d278 2
a279 1
      pname->clear();
@


1.48
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d691 1
@


1.47
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d86 3
a88 3
Archive::Archive(const std::string& aname, Input_file* ainput_file,
                 bool is_a_thin_archive, Dirsearch* dirpath, Task* task)
  : name_(aname), input_file_(ainput_file), armap_(), armap_names_(),
d90 1
a90 1
    is_thin_archive_(is_a_thin_archive), included_member_(false),
d94 1
a94 1
    parameters->options().check_excluded_libs(ainput_file->found_name());
d250 3
a252 3
  char* hend;
  off_t member_size = strtol(size_string, &hend, 10);
  if (*hend != '\0'
d288 1
a288 1
      long x = strtol(hdr->ar_name + 1, &hend, 10);
d290 3
a292 3
      if (*hend == ':')
        y = strtol(hend + 1, &hend, 10);
      if (*hend != ' '
d302 3
a304 3
      const char* name_start = this->extended_names_.data() + x;
      const char* name_end = strchr(name_start, '\n');
      if (static_cast<size_t>(name_end - name_start) > this->extended_names_.size()
d311 1
a311 1
      pname->assign(name_start, name_end - 1 - name_start);
d455 1
a455 1
Archive::get_file_and_offset(off_t off, Input_file** in_file, off_t* memoff,
d462 1
a462 1
  *in_file = this->input_file_;
d495 1
a495 1
          *in_file = new Input_file(input_file_arg);
d497 1
a497 1
          if (!(*in_file)->open(*this->dirpath_, this->task_, &dummy))
d499 1
a499 1
          arch = new Archive(*member_name, *in_file, false, this->dirpath_,
d506 1
a506 1
      return arch->get_file_and_offset(nested_off, in_file, memoff,
d516 1
a516 1
  *in_file = new Input_file(input_file_arg);
d518 1
a518 1
  if (!(*in_file)->open(*this->dirpath_, this->task_, &dummy))
d522 1
a522 1
  *memsize = (*in_file)->file().filesize();
d535 1
a535 1
  Input_file* in_file;
d539 1
a539 1
  if (!this->get_file_and_offset(off, &in_file, &memoff, &memsize,
d545 1
a545 1
      Object* obj = parameters->options().plugins()->claim_file(in_file,
d558 1
a558 1
  if (!is_elf_object(in_file, memoff, &ehdr, &read_size))
d567 1
a567 1
				in_file, memoff, ehdr, read_size,
@


1.46
log
@2009-10-10  Chris Demetriou  <cgd@@google.com>

	* options.h (Input_file_argument::Input_file_type): New enum.
	(Input_file_argument::is_lib_): Replace with...
	(Input_file_argument::type_): New member.
	(Input_file_argument::Input_file_argument): Take Input_file_type
	'type' rather than boolean 'is_lib' as second argument.
	(Input_file_argument::is_lib): Use type_.
	(Input_file_argument::is_searched_file): New function.
	(Input_file_argument::may_need_search): Handle is_searched_file.
	* options.cc (General_options::parse_library): Support -l:filename.
	(General_options::parse_just_symbols): Update for Input_file_argument
	changes.
	(Command_line::process): Likewise.
	* archive.cc (Archive::get_file_and_offset): Likewise.
	* plugin.cc (Plugin_manager::release_input_file): Likewise.
	* script.cc (read_script_file, script_add_file): Likewise.
	* fileread.cc (Input_file::Input_file): Likewise.
	(Input_file::will_search_for): Handle is_searched_file.
	(Input_file::open): Likewise.
	* readsyms.cc (Read_symbols::get_name): Likewise.
	* testsuite/Makefile.am (searched_file_test): New test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/searched_file_test.cc: New file.
	* testsuite/searched_file_test_lib.cc: New file.
@
text
@d86 3
a88 3
Archive::Archive(const std::string& name, Input_file* input_file,
                 bool is_thin_archive, Dirsearch* dirpath, Task* task)
  : name_(name), input_file_(input_file), armap_(), armap_names_(),
d90 1
a90 1
    is_thin_archive_(is_thin_archive), included_member_(false),
d94 1
a94 1
    parameters->options().check_excluded_libs(input_file->found_name());
d250 3
a252 3
  char* end;
  off_t member_size = strtol(size_string, &end, 10);
  if (*end != '\0'
d288 1
a288 1
      long x = strtol(hdr->ar_name + 1, &end, 10);
d290 3
a292 3
      if (*end == ':')
        y = strtol(end + 1, &end, 10);
      if (*end != ' '
d302 3
a304 3
      const char* name = this->extended_names_.data() + x;
      const char* name_end = strchr(name, '\n');
      if (static_cast<size_t>(name_end - name) > this->extended_names_.size()
d311 1
a311 1
      pname->assign(name, name_end - 1 - name);
d455 1
a455 1
Archive::get_file_and_offset(off_t off, Input_file** input_file, off_t* memoff,
d462 1
a462 1
  *input_file = this->input_file_;
d495 1
a495 1
          *input_file = new Input_file(input_file_arg);
d497 1
a497 1
          if (!(*input_file)->open(*this->dirpath_, this->task_, &dummy))
d499 1
a499 1
          arch = new Archive(*member_name, *input_file, false, this->dirpath_,
d506 1
a506 1
      return arch->get_file_and_offset(nested_off, input_file, memoff,
d516 1
a516 1
  *input_file = new Input_file(input_file_arg);
d518 1
a518 1
  if (!(*input_file)->open(*this->dirpath_, this->task_, &dummy))
d522 1
a522 1
  *memsize = (*input_file)->file().filesize();
d535 1
a535 1
  Input_file* input_file;
d539 1
a539 1
  if (!this->get_file_and_offset(off, &input_file, &memoff, &memsize,
d545 1
a545 1
      Object* obj = parameters->options().plugins()->claim_file(input_file,
d558 1
a558 1
  if (!is_elf_object(input_file, memoff, &ehdr, &read_size))
d567 1
a567 1
				input_file, memoff, ehdr, read_size,
@


1.45
log
@	* object.h (class Object): Remove target_ field, and target,
	sized_target, and set_target methods.
	(Object::sized_target): Remove.
	(class Sized_relobj): Update declarations.  Remove sized_target.
	* object.cc (Sized_relobj::setup): Remove target parameter.
	Change all callers.
	(Input_objects::add_object): Don't do anything with the target.
	(make_elf_sized_object): Add punconfigured parameter.  Change all
	callers.  Set or test parameter target.
	* dynobj.cc (Sized_dynobj::target): Remove target parameter.
	Change all callers.
	* parameters.cc (Parameters::set_target): Change parameter type to
	be non-const.
	(Parameters::default_target): Remove.
	(set_parameters_target): Change parameter type to be non-const.
	(parameters_force_valid_target): New function.
	(parameters_clear_target): New function.
	* parameters.h (class Parameters): Update declarations.  Remove
	default_target method.  Add sized_target and clear_target
	methods.  Change target_ to be non-const.
	(set_parameters_target): Update declaration.
	(parameters_force_valid_target): Declare.
	(parameters_clear_target): Declare.
	* readsyms.cc (Read_symbols::do_read_symbols): Pass punconfigured
	as NULL if we aren't searching.
	(Add_symbols::run): Don't check for compatible target.
	* fileread.cc (Input_file::open_binary): Call
	parameters_force_valid_target.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (make_sized_plugin_object): Likewise.  Don't call
	set_target on object.
	* dynobj.h (class Sized_dynobj): Update declarations.
	* archive.cc (Archive::get_elf_object_for_member): Return NULL if
	make_elf_object returns NULL.
	(Archive::include_member): Don't check whether object target is
	compatible.
	* output.cc (Output_section::add_input_section): Get target from
	parameters.
	(Output_section::relax_input_section): Likewise.
	* reloc.cc (Sized_relobj::do_gc_process_relocs): Get target from
	parameters.
	(Sized_relobj::do_scan_relocs): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* symtab.cc (Symbol_table::wrap_symbol): Likewise.  Remove object
	parameter.  Change all callers.
	(Symbol_table::add_from_object): Get target from parameters.
	(Symbol_table::add_from_relobj): Don't check object target.
	(Symbol_table::add_from_dynobj): Likewise.
	(Symbol_table::define_special_symbol): Get target from
	parameters.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/binary_unittest.cc (gold_testsuite): Remove target
	parameter.  Change all callers.  Clear parameter target.
	(Binary_test): Test target here.
	* testsuite/object_unittest.cc (gold_testsuite): Remove
	target_test_pointer parameter.  Change all callers.
	(Object_test): Test target here.
@
text
@d492 3
a494 2
            new Input_file_argument(member_name->c_str(), false, "", false,
                                    parameters->options());
d513 3
a515 2
      new Input_file_argument(member_name->c_str(), false, "", false,
                              this->input_file_->options());
@


1.44
log
@2009-05-19  Doug Kwan  <dougkwan@@google.com>

	* archive.cc (Archive::Archive): Move constructor from archive.h
	to here.  Initialize no_export_.
	(Archive::get_elf_object_for_member): Set no_export flag of object.
	* archive.h (Archive::Archive): Move constructor body to
	archive.cc.
	(Archive::no_export): New method.
	(Archive::no_export_): New field.
	* object.h (Object::Object): Initialize no_export_ to false.
	(Object::no_export, Object::set_no_export): New methods.
	(Object::no_export_): New field.
	* options.cc (General_options::parse_exclude_libs): New method.
	(General_options::check_excluded_libs) Same.
	* options.h (exclude_libs): New option.
	(General_options::check_excluded_libs): New method declaration.
	(General_options::excluded_libs_): New field.
	* symtab.cc (Symbol_table::add_from_relobj): Hide symbols with
	default or protected visibility if an object has no-export flag set.
	testsuite/Makefile.am (check_PROGRAMS): Add exclude_libs_test.
	(check_SCRIPTS): Add exclude_libs_test.sh.
	(check_DATA): Add exclude_libs_test.syms.
	(MOSTLYCLEANFILES): Add exclude_libs_test.syms,
	libexclude_libs_test_1.a and libexclude_libs_test_2.a.
	(exclude_libs_test_SOURCES, exclude_libs_test_DEPENDENCIES,
	exclude_libs_test_LDFLAGS and exclude_libs_test_LDADD): Define.
	(exclude_libs_test.syms, libexclude_libs_test_1.a,
	libexclude_libs_test_2.a): New rules.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/exclude_libs_test.c: New file.
	* testsuite/exclude_libs_test.sh: Ditto.
	* testsuite/exclude_libs_test_1.c: Ditto.
	* testsuite/exclude_libs_test_2.c: Ditto.
@
text
@d567 2
a811 5
      if (!this->included_member_
	  && this->searched_for()
	  && !parameters->is_compatible_target(obj->target()))
	return false;

d830 2
a831 3
      && (obj == NULL
	  ? unconfigured
	  : !parameters->is_compatible_target(obj->target())))
@


1.44.4.1
log
@Merge elfcpp and gold from trunk.
@
text
@d492 2
a493 3
            new Input_file_argument(member_name->c_str(),
                                    Input_file_argument::INPUT_FILE_TYPE_FILE,
                                    "", false, parameters->options());
d512 2
a513 3
      new Input_file_argument(member_name->c_str(),
                              Input_file_argument::INPUT_FILE_TYPE_FILE,
                              "", false, this->input_file_->options());
a566 2
  if (obj == NULL)
    return NULL;
d810 5
d833 3
a835 2
      && obj == NULL
      && unconfigured)
@


1.43
log
@	* object.cc (is_elf_object): Define.
	* object.h (is_elf_object): Declare.
	* archive.cc (Archive::get_elf_object_for_member): Call
	is_elf_object.
	* readsymc.cc (Read_symbols::do_read_symbols): Likewise.
@
text
@d86 11
d563 6
a568 4
  return make_elf_object((std::string(this->input_file_->filename())
			  + "(" + member_name + ")"),
			 input_file, memoff, ehdr, read_size,
			 punconfigured);
@


1.42
log
@	* archive.cc (Archive::add_symbols): Check for a version attached
	to the symbol name in the archive map.
	* testsuite/Makefile.am (check_PROGRAMS): Add ver_test_11.
	(ver_test_11_SOURCES, ver_test_11_DEPENDENCIES): Define.
	(ver_test_11_LDFLAGS, ver_test_11_LDADD): Define.
	(ver_test_11.a): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d543 3
a545 21
  off_t filesize = input_file->file().filesize();
  int read_size = elfcpp::Elf_sizes<64>::ehdr_size;
  if (filesize - memoff < read_size)
    read_size = filesize - memoff;

  if (read_size < 4)
    {
      gold_error(_("%s: member at %zu is not an ELF object"),
		 this->name().c_str(), static_cast<size_t>(off));
      return NULL;
    }

  const unsigned char* ehdr = input_file->file().get_view(memoff, 0, read_size,
							  true, false);

  static unsigned char elfmagic[4] =
    {
      elfcpp::ELFMAG0, elfcpp::ELFMAG1,
      elfcpp::ELFMAG2, elfcpp::ELFMAG3
    };
  if (memcmp(ehdr, elfmagic, 4) != 0)
@


1.41
log
@	* readsyms.cc (Read_symbols::incompatible_warning): New function.
	(Read_symbols::requeue): New function.
	(Read_symbols::do_read_symbols): If make_elf_object fails because
	the target type is not configured, and the file was searched for,
	issue a warning and retry with the next directory.
	(Add_symbols::run): If the file has an incompatible format, and
	it was searched for, requeue the Read_symbols task.  On error,
	release the object.
	* readsyms.h (class Read_symbols): Add dirindex_ field.  Add
	dirindex parameter to constructor.  Change all callers.  Declare
	incompatible_warning and requeue.
	(class Add_symbols): Add dirpath_, dirindex_, mapfile_,
	input_argument_ and input_group_ fields.  Add them to
	constructor.  Change all callers.
	(class Read_script): Add dirindex_ field.  Add it to constructor.
	Change all callers.
	* archive.cc (Archive::setup): Remove input_objects parameter.
	Change all callers.
	(Archive::get_file_and_offset): Likewise.
	(Archive::read_all_symbols): Likewise.
	(Archive::read_symbols): Likewise.
	(Archive::get_elf_object_for_member): Remove input_objects
	parameter.  Add punconfigured parameter.  Change all callers.
	(Archive::add_symbols): Change return type to bool.  Check return
	value of include_member.
	(Archive::include_all_members): Likewise.
	(Archive::include_member): Change return type to bool.  Return
	false if first included object has incompatible target.  Set
	included_member_ field.
	(Add_archive_symbols::run): If add_symbols returns false, requeue
	Read_symbols task.
	* archive.h (class Archive): Add included_member_ field.
	Initialize it in constructor.  Add input_file and searched_for
	methods.  Update declarations.
	(class Add_archive_symbols): Add dirpath_, dirindex_, and
	input_argument_ fields.  Add them to constructor.  Change all
	callers.
	* script.cc: Include "target-select.h".
	(class Parser_closure): Add skip_on_incompatible_target_ and
	found_incompatible_target_ fields.  Add
	skip_on_incompatible_target parameter to constructor.  Change all
	callers.  Add methods skip_on_incompatible_target,
	clear_skip_on_incompatible_target, found_incompatible_target, and
	set_found_incompatible_target.
	(read_input_script): Add dirindex parameter.  Change all callers.
	If parser finds an incompatible target, requeue Read_symbols
	task.
	(script_set_symbol): Clear skip_on_incompatible_target in
	closure.
	(script_add_assertion, script_parse_option): Likewise.
	(script_start_sections, script_add_phdr): Likewise.
	(script_check_output_format): New function.
	* script.h (read_input_script): Update declaration.
	* script-c.h (script_check_output_format): Declare.
	* yyscript.y (file_cmd): Handle OUTPUT_FORMAT.
	(ignore_cmd): Remove OUTPUT_FORMAT.
	* fileread.cc (Input_file::Input_file): Add explicit this.
	(Input_file::will_search_for): New function.
	(Input_file::open): Add pindex parameter.  Change all callers.
	* fileread.h (class Input_file): Add input_file_argument method.
	Declare will_search_for.  Update declarations.
	* object.cc (make_elf_object): Add punconfigured parameter.
	Change all callers.
	* object.h (class Object): Make input_file public.  Add
	searched_for method.
	(make_elf_object): Update declaration.
	* dirsearch.cc (Dirsearch::find): Add pindex parameter.  Use it to
	restart search.
	* dirsearch.h (class Dirsearch): Update declaration.
	* options.h (class General_options): Add --warn-search-mismatch.
	* parameters.cc (Parameters::is_compatible_target): New function.
	* parameters.h (class Parameters): Declare is_compatible_target.
	* workqueue.cc (Workqueue::add_blocker): New function.
	* workqueue.h (class Workqueue): Declare add_blocker.
@
text
@d638 2
d663 34
a696 1
	  Symbol* sym = symtab->lookup(sym_name);
d725 5
a729 1
	    return false;
d736 3
@


1.40
log
@	* fileread.cc (Input_file::open): Remove options parameter.
	Change all callers.
	(Input_file::open_binary): Likewise.
	* script.cc (read_input_script): Likewise.
	* readsyms.h (class Read_symbols): Remove options_ field.  Remove
	options parameter from constructor.  Change all callers.
	(class Read_script): Likewise.
	* fileread.h (class Input_file): Update declarations.
	* script.h (read_input_script): Update declaration.
@
text
@d90 1
a90 1
Archive::setup(Input_objects* input_objects)
d135 1
a135 1
    this->read_all_symbols(input_objects);
d444 1
a444 2
Archive::get_file_and_offset(off_t off, Input_objects* input_objects,
                             Input_file** input_file, off_t* memoff,
d484 2
a485 1
          if (!(*input_file)->open(*this->dirpath_, this->task_))
d489 1
a489 1
          arch->setup(input_objects);
d494 2
a495 2
      return arch->get_file_and_offset(nested_off, input_objects, input_file,
                                       memoff, memsize, member_name);
d504 2
a505 1
  if (!(*input_file)->open(*this->dirpath_, this->task_))
d513 3
a515 2
// Return an ELF object for the member at offset OFF.  Set *MEMBER_NAME to
// the name of the member.
d518 1
a518 1
Archive::get_elf_object_for_member(off_t off, Input_objects* input_objects)
d520 2
a521 1
  std::string member_name;
d525 3
a527 3

  if (!this->get_file_and_offset(off, input_objects, &input_file, &memoff,
                                 &memsize, &member_name))
d571 3
a573 2
				 + "(" + member_name + ")"),
				input_file, memoff, ehdr, read_size);
d579 1
a579 1
Archive::read_all_symbols(Input_objects* input_objects)
d584 1
a584 1
    this->read_symbols(input_objects, p->off);
d591 1
a591 1
Archive::read_symbols(Input_objects* input_objects, off_t off)
d593 2
a594 1
  Object* obj = this->get_elf_object_for_member(off, input_objects);
d610 3
a612 1
// may be satisfied by other objects in the archive.
d614 1
a614 1
void
d687 4
a690 2
	  this->include_member(symtab, layout, input_objects,
			       last_seen_offset, mapfile, sym, why.c_str());
d698 2
d704 1
a704 1
void
d717 3
a719 2
          this->include_member(symtab, layout, input_objects, p->first,
			       mapfile, NULL, "--whole-archive");
d729 3
a731 2
          this->include_member(symtab, layout, input_objects, p->off,
			       mapfile, NULL, "--whole-archive");
d737 2
d757 3
d761 1
a761 1
void
d772 6
d785 1
d788 15
a802 1
      return;
a804 1
  Object* obj = this->get_elf_object_for_member(off, input_objects);
d806 1
a806 1
    return;
d815 2
a816 1
      return;
d819 3
a821 1
  if (input_objects->add_object(obj))
d832 2
d835 2
a836 5
  else
    {
      // FIXME: We need to close the descriptor here.
      delete obj;
    }
d881 1
a881 1
Add_archive_symbols::run(Workqueue*)
d883 3
a885 3
  this->archive_->add_symbols(this->symtab_, this->layout_,
			      this->input_objects_, this->mapfile_);

d891 14
@


1.39
log
@	(From Rafael Espindola)
	* archive.cc (Archive::include_member): Update calls to add_symbols.
	* dynobj.cc (Sized_dynobj<size, big_endian>::make_version_map): Add
	the Layout argument.
	* dynobj.h (do_add_symbols): Add the Layout argument.
	* object.cc (Sized_relobj<size, big_endian>::do_add_symbols): Add the
	Layout argument.
	* object.h (Object::add_symbols): Add the Layout argument.
	(Object::do_add_symbols): Add the Layout argument.
	(Sized_relobj::do_add_symbols): Add the Layout argument.
	* plugin.cc (Sized_pluginobj<size, big_endian>::do_add_symbols):
	Unify the two versions.
	(Add_plugin_symbols): Remove.
	* plugin.h (Pluginobj::add_symbols, Pluginobj::do_add_symbols): Remove.
	(Sized_pluginobj::do_add_symbols): Unify the two versions.
	(Add_plugin_symbols): Remove.
	* readsyms.cc (Read_symbols::do_read_symbols): Update call to
	Add_symbols. Use Add_symbols instead of Add_plugin_symbols.
	(Add_symbols::run): Make it work with Pulginobj.
@
text
@d485 1
a485 2
          if (!(*input_file)->open(parameters->options(), *this->dirpath_,
                                   this->task_))
d504 1
a504 2
  if (!(*input_file)->open(parameters->options(), *this->dirpath_,
                           this->task_))
@


1.38
log
@	* archive.cc (Archive::get_elf_object_for_member): Remove call
	to File_read::claim_for_plugin.
	* descriptors.cc (Descriptors::open): Remove reference to
	is_claimed.
	(Descriptors::claim_for_plugin): Remove.
	* descriptors.h (Descriptors::claim_for_plugin): Remove.
	(Descriptors::is_claimed): Remove.
	(claim_descriptor_for_plugin): Remove.
	* fileread.cc (File_read::claim_for_plugin): Remove.
	* fileread.h (File_read::claim_for_plugin): Remove.
	(File_read::descriptor): Reopen descriptor if necessary.
	* plugin.cc  (Plugin::load): Add two new APIs to transfer vector.
	(Plugin_manager::all_symbols_read): Add task parameter. Change
	all callers.
	(Plugin_manager::get_input_file): New function.
	(Plugin_manager::release_input_file): New function.
	(Pluginobj::Pluginobj): Add filesize parameter and initialize
	corresponding data member.
	(Sized_pluginobj::Sized_pluginobj): Add filesize parameter
	and pass to base constructor. Change all callers.
	(get_input_file, release_input_file): New functions.
	(make_sized_plugin_object): Add filesize parameter. Change all callers.
	* plugin.h (Plugin_manager::Plugin_manager): Initialize task_ member.
	(Plugin_manager::all_symbols_read): Add task parameter.
	(Plugin_manager::get_input_file): New function.
	(Plugin_manager::release_input_file): New function.
	(Plugin_manager::task_): New data member.
	(Pluginobj::Pluginobj): Add filesize parameter.
	(Pluginobj::filename): New function.
	(Pluginobj::descriptor): New function.
	(Pluginobj::filesize): New function.
	(Pluginobj::filesize_): New data member.
	(Sized_pluginobj::Sized_pluginobj): Add filesize parameter.
	* readsyms.cc (Read_symbols::do_read_symbols): Remove call to
	File_read::claim_for_plugin; use Object::unlock to unlock the file.

	* testsuite/Makefile.am (plugin_test_4): New test case for plugins
	with archive libraries.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_test.c (struct sym_info): New type.
	(get_input_file, release_input_file): New static variables.
	(onload): Capture new transfer vector entries.
	(claim_file_hook): Stop reading at end of file according to filesize.
	Factor out parsing of readelf output into separate function.
	(all_symbols_read_hook): Exercise get_input_file and release_input_file
	APIs and get the source file name from the symbol table.  Convert
	source file name to corresponding object file name.  Print info
	message when adding new input files.
	(parse_readelf_line): New function.
	* testsuite/plugin_test_1.sh: Add checks for new info messages.
	* testsuite/plugin_test_2.sh: Likewise.
	* testsuite/plugin_test_3.sh: Likewise.
	* testsuite/plugin_test_4.sh: New test case.
@
text
@d762 1
a762 1
          obj->add_symbols(symtab, sd);
d778 1
a778 1
      pluginobj->add_symbols(symtab, layout);
d787 1
a787 1
      obj->add_symbols(symtab, &sd);
@


1.37
log
@	* archive.cc (Archive::get_file_and_offset): Use filename instead
	of name to get library path.
	(Archive::include_member): Unlock external member of a thin archive.

	* testsuite/Makefile.am (TEST_AR): New variable.
	(thin_archive_test_1): New test.
	(thin_archive_test_2): New test.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
a537 1
	  input_file->file().claim_for_plugin();
@


1.36
log
@Add plugin functionality for link-time optimization (LTO).

include/:
	* plugin-api.h: New file.

gold/:
	* configure.ac (plugins): Add --enable-plugins option.
	* configure: Regenerate.
	* config.in: Regenerate.
	* Makefile.am (LIBDL): New variable.
	(CCFILES): Add plugin.cc.
	(HFILES): Add plugin.h.
	(ldadd_var): Add LIBDL.
	* Makefile.in: Regenerate.

	* archive.cc: Include "plugin.h".
	(Archive::setup): Don't preread archive symbols when using a plugin.
	(Archive::get_file_and_offset): Add memsize parameter.  Change callers.
	(Archive::get_elf_object_for_member): Call plugin hooks for claiming
	files.
	(Archive::include_member): Add symbols from plugin objects.
	* archive.h (Archive::get_file_and_offset): Add memsize parameter.
	* descriptors.cc (Descriptors::open): Check for file descriptors
	abandoned by plugins.
	(Descriptors::claim_for_plugin): New function.
	* descriptors.h (Descriptors::claim_for_plugin): New function.
	(Open_descriptor::is_claimed): New field.
	(claim_descriptor_for_plugin): New function.
	* fileread.cc (File_read::claim_for_plugin): New function.
	* fileread.h (File_read::claim_for_plugin): New function.
	(File_read::descriptor): New function.
	* gold.cc: Include "plugin.h".
	(queue_initial_tasks): Add task to call plugin hooks for generating
	new object files.
	* main.cc: Include "plugin.h".
	(main): Load plugin libraries.
	* object.h (Pluginobj): Declare.
	(Object::pluginobj): New function.
	(Object::do_pluginobj): New function.
	(Object::set_target): New function.
	* options.cc: Include "plugin.h".
	(General_options::parse_plugin): New function.
	(General_options::General_options): Initialize plugins_ field.
	(General_options::add_plugin): New function.
	* options.h (Plugin_manager): Declare.
	(General_options): Add --plugin option.
	(General_options::has_plugins): New function.
	(General_options::plugins): New function.
	(General_options::add_plugin): New function.
	(General_options::plugins_): New field.
	* plugin.cc: New file.
	* plugin.h: New file.
	* readsyms.cc: Include "plugin.h".
	(Read_symbols::do_read_symbols): Check for archive before checking
	for ELF file.  Call plugin hooks to claim files.
	* resolve.cc (Symbol_table::resolve): Record when symbol is referenced
	from a real object file; force override when processing replacement
	files.
	* symtab.cc (Symbol::init_fields): Initialize in_real_elf_ field.
	(Symbol::init_base_object): Likewise.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): Likewise.
	(Symbol::output_section): Assert that object is not a plugin.
	(Symbol_table::add_from_pluginobj): New function.
	(Symbol_table::sized_finalize_symbol): Treat symbols from plugins as
	undefined.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::add_from_pluginobj): Instantiate template.
	* symtab.h (Sized_pluginobj): Declare.
	(Symbol::in_real_elf): New function.
	(Symbol::set_in_real_elf): New function.
	(Symbol::in_real_elf_): New field.
	(Symbol_table::add_from_pluginobj): New function.

	* testsuite/Makefile.am (AM_CFLAGS): New variable.
	(LIBDL): New variable.
	(LDADD): Add LIBDL.
	(check_PROGRAMS): Add plugin_test_1 and plugin_test_2.
	(check_SCRIPTS): Add plugin_test_1.sh and plugin_test_2.sh.
	(check_DATA): Add plugin_test_1.err and plugin_test_2.err.
	(MOSTLYCLEANFILES): Likewise.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_test.c: New file.
	* testsuite/plugin_test_1.sh: New file.
	* testsuite/plugin_test_2.sh: New file.
@
text
@d462 1
a462 1
      const char* arch_path = this->name().c_str();
d466 1
a466 1
                             this->name().substr(0, basename - arch_path));
d789 5
@


1.35
log
@2008-08-06  Cary Coutant <ccoutant@@google.com>

	* archive.cc (Archive::total_archives, Archive::total_members)
	(Archive::total_members_loaded): New variables.
	(Archive::setup): Add parameter.  Add option to preread
	archive symbols.
	(Archive::read_armap): Add counter.
	(Archive::get_file_and_offset): New function.
	(Archive::get_elf_object_for_member): New function.
	(Archive::read_all_symbols): New function.
	(Archive::read_symbols): New function.
	(Archive::add_symbols): Add counters.
	(Archive::include_all_members): Use armap to find members if it's
	already built.
	(Archive::include_member): Skip reading symbols if already read.
	Factored code into Archive::get_file_and_offset and
	Archive::get_elf_object_for_member.  Changed call to
	Mapfile::report_include_archive_member.
	(Archive::print_stats): New function.
	* archive.h: Declare Object and Read_symbols_data classes.
	(Archive::Archive): Add initializers for new members.
	(Archive::setup): Add parameter.
	(Archive::print_stats): New function.
	(Archive::total_archives, Archive::total_members)
	(Archive::total_members_loaded): New variables.
	(Archive::get_file_and_offset): New function.
	(Archive::get_elf_object_for_member): New function.
	(Archive::read_all_symbols): New function.
	(Archive::read_symbols): New function.
	(Archive::Archive_member): New class.
	(Archive::members_): New member.
	(Archive::num_members_): New member.
	* main.cc: Include archive.h.
	(main): Call Archive::print_stats.
	* mapfile.cc (Mapfile::report_include_archive_member): Delete
	archive parameter; member_name is now the fully-decorated name.
	* mapfile.h (Mapfile::report_include_archive_member): Likewise.
	* options.h: (General_options): Add --preread-archive-symbols option.
	* readsyms.cc (Read_symbols::do_read_symbols): Change call to
	Archive::setup.
@
text
@d40 1
d130 3
d446 1
a446 1
                             std::string* member_name)
d450 1
a450 1
  this->read_header(off, false, member_name, &nested_off);
d495 2
a496 2
      return arch->get_file_and_offset(nested_off, input_objects,
                                       input_file, memoff, member_name);
d510 1
d523 1
d526 1
a526 1
                                 &member_name))
d529 14
d776 7
@


1.34
log
@	PR 5990
	* descriptors.cc: New file.
	* descriptors.h: New file.
	* gold-threads.h (class Hold_optional_lock): New class.
	* fileread.cc: Include "descriptors.h".
	(File_read::~File_read): Release descriptor rather than closing
	it.
	(File_read::open) [file]: Call open_descriptor rather than open.
	Set is_descriptor_opened_.
	(File_read::open) [memory]: Assert that descriptor is not open.
	(File_read::reopen_descriptor): New function.
	(File_read::release): Release descriptor.
	(File_read::do_read): Make non-const.  Reopen descriptor.
	(File_read::read): Make non-const.
	(File_read::make_view): Reopen descriptor.
	(File_read::do_readv): Likewise.
	* fileread.h (class File_read): Add is_descriptor_opened_ field.
	Update declarations.
	* layout.cc: Include "descriptors.h".
	(Layout::create_build_id): Use open_descriptor rather than open.
	* output.cc: Include "descriptors.h".
	(Output_file::open): Use open_descriptor rather than open.
	* archive.cc (Archive::const_iterator): Change Archive to be
	non-const.
	(Archive::begin, Archive::end): Make non-const.
	(Archive::count_members): Likewise.
	* archive.h (class Archive): Update declarations.
	* object.h (Object::read): Make non-const.
	* Makefile.am (CCFILES): Add descriptors.cc.
	(HFILES): Add descriptors.h.
	* Makefile.in: Rebuild.
@
text
@d66 5
d89 1
a89 1
Archive::setup()
d125 7
d152 6
d181 5
a303 87
// Select members from the archive and add them to the link.  We walk
// through the elements in the archive map, and look each one up in
// the symbol table.  If it exists as a strong undefined symbol, we
// pull in the corresponding element.  We have to do this in a loop,
// since pulling in one element may create new undefined symbols which
// may be satisfied by other objects in the archive.

void
Archive::add_symbols(Symbol_table* symtab, Layout* layout,
		     Input_objects* input_objects, Mapfile* mapfile)
{
  if (this->input_file_->options().whole_archive())
    return this->include_all_members(symtab, layout, input_objects,
				     mapfile);

  input_objects->archive_start(this);

  const size_t armap_size = this->armap_.size();

  // This is a quick optimization, since we usually see many symbols
  // in a row with the same offset.  last_seen_offset holds the last
  // offset we saw that was present in the seen_offsets_ set.
  off_t last_seen_offset = -1;

  // Track which symbols in the symbol table we've already found to be
  // defined.

  bool added_new_object;
  do
    {
      added_new_object = false;
      for (size_t i = 0; i < armap_size; ++i)
	{
          if (this->armap_checked_[i])
            continue;
	  if (this->armap_[i].file_offset == last_seen_offset)
            {
              this->armap_checked_[i] = true;
              continue;
            }
	  if (this->seen_offsets_.find(this->armap_[i].file_offset)
              != this->seen_offsets_.end())
	    {
              this->armap_checked_[i] = true;
	      last_seen_offset = this->armap_[i].file_offset;
	      continue;
	    }

	  const char* sym_name = (this->armap_names_.data()
				  + this->armap_[i].name_offset);
	  Symbol* sym = symtab->lookup(sym_name);
	  if (sym == NULL)
	    {
	      // Check whether the symbol was named in a -u option.
	      if (!parameters->options().is_undefined(sym_name))
		continue;
	    }
	  else if (!sym->is_undefined())
	    {
              this->armap_checked_[i] = true;
	      continue;
	    }
	  else if (sym->binding() == elfcpp::STB_WEAK)
	    continue;

	  // We want to include this object in the link.
	  last_seen_offset = this->armap_[i].file_offset;
	  this->seen_offsets_.insert(last_seen_offset);
          this->armap_checked_[i] = true;

	  std::string why;
	  if (sym == NULL)
	    {
	      why = "-u ";
	      why += sym_name;
	    }
	  this->include_member(symtab, layout, input_objects,
			       last_seen_offset, mapfile, sym, why.c_str());

	  added_new_object = true;
	}
    }
  while (added_new_object);

  input_objects->archive_stop(this);
}

d433 241
d682 23
a704 5
  for (Archive::const_iterator p = this->begin();
       p != this->end();
       ++p)
    this->include_member(symtab, layout, input_objects, p->off,
			 mapfile, NULL, "--whole-archive");
d731 1
a731 6
  std::string n;
  off_t nested_off;
  this->read_header(off, false, &n, &nested_off);

  if (mapfile != NULL)
    mapfile->report_include_archive_member(this, n, sym, why);
d733 2
a734 4
  Input_file* input_file;
  off_t memoff;

  if (!this->is_thin_archive_)
d736 5
a740 15
      input_file = this->input_file_;
      memoff = off + static_cast<off_t>(sizeof(Archive_header));
    }
  else
    {
      // Adjust a relative pathname so that it is relative
      // to the directory containing the archive.
      if (!IS_ABSOLUTE_PATH(n.c_str()))
        {
          const char *arch_path = this->name().c_str();
          const char *basename = lbasename(arch_path);
          if (basename > arch_path)
            n.replace(0, 0, this->name().substr(0, basename - arch_path));
        }
      if (nested_off > 0)
d742 2
a743 27
          // This is a member of a nested archive.  Open the containing
          // archive if we don't already have it open, then do a recursive
          // call to include the member from that archive.
          Archive* arch;
          Nested_archive_table::const_iterator p =
            this->nested_archives_.find(n);
          if (p != this->nested_archives_.end())
            arch = p->second;
          else
            {
              Input_file_argument* input_file_arg =
                new Input_file_argument(n.c_str(), false, "", false,
                                        parameters->options());
              input_file = new Input_file(input_file_arg);
              if (!input_file->open(parameters->options(), *this->dirpath_,
                                    this->task_))
                return;
              arch = new Archive(n, input_file, false, this->dirpath_,
                                 this->task_);
              arch->setup();
              std::pair<Nested_archive_table::iterator, bool> ins =
                this->nested_archives_.insert(std::make_pair(n, arch));
              gold_assert(ins.second);
            }
          arch->include_member(symtab, layout, input_objects, nested_off,
			       NULL, NULL, NULL);
          return;
d745 1
a745 23
      // This is an external member of a thin archive.  Open the
      // file as a regular relocatable object file.
      Input_file_argument* input_file_arg =
          new Input_file_argument(n.c_str(), false, "", false,
                                  this->input_file_->options());
      input_file = new Input_file(input_file_arg);
      if (!input_file->open(parameters->options(), *this->dirpath_,
                            this->task_))
        {
          return;
        }
      memoff = 0;
    }

  off_t filesize = input_file->file().filesize();
  int read_size = elfcpp::Elf_sizes<64>::ehdr_size;
  if (filesize - memoff < read_size)
    read_size = filesize - memoff;

  if (read_size < 4)
    {
      gold_error(_("%s: member at %zu is not an ELF object"),
		 this->name().c_str(), static_cast<size_t>(off));
d749 3
a751 2
  const unsigned char* ehdr = input_file->file().get_view(memoff, 0, read_size,
							  true, false);
d753 2
a754 15
  static unsigned char elfmagic[4] =
    {
      elfcpp::ELFMAG0, elfcpp::ELFMAG1,
      elfcpp::ELFMAG2, elfcpp::ELFMAG3
    };
  if (memcmp(ehdr, elfmagic, 4) != 0)
    {
      gold_error(_("%s: member at %zu is not an ELF object"),
		 this->name().c_str(), static_cast<size_t>(off));
      return;
    }

  Object* obj = make_elf_object((std::string(this->input_file_->filename())
				 + "(" + n + ")"),
				input_file, memoff, ehdr, read_size);
d768 3
d772 9
a780 5
  if (this->is_thin_archive_)
    {
      // Opening the file locked it.  Unlock it now.
      input_file->file().unlock(this->task_);
    }
@


1.33
log
@	* cref.cc: New file.
	* cref.h: New file.
	* options.h (class General_options): Add --print-symbol-counts.
	* main.cc (main): Issue defined symbol report if requested.
	* archive.cc (Archive::interpret_header): Make into a const member
	function.
	(Archive::add_symbols): Call Input_objects::archive_start and
	archive_stop.
	(Archive::const_iterator): Define new class.
	(Archive::begin, Archive::end): New functions.
	(Archive::include_all_members): Rewrite to use iterator.
	(Archive::count_members): New function.
	* archive.h (class Archive): Update declarations.
	(Archive::filename): New function.
	* object.cc: Include "cref.h".
	(Sized_relobj::Sized_relobj): Initialize defined_count_.
	(Sized_relobj::do_get_global_symbol_counts): New function.
	(Input_objects::add_object): Add object to cross-referencer.
	(Input_objects::archive_start): New function.
	(Input_objects::archive_stop): New function.
	(Input_objects::print_symbol_counts): New function.
	* object.h: Declare Cref and Archive.
	(Object::get_global_symbol_counts): New function.
	(Object::do_get_global_symbol_counts): New pure virtual function.
	(class Sized_relobj): Add defined_count_ field.  Update
	declarations.
	(class Input_objects): Add cref_ field.  Update constructor.
	Update declarations.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize symbols_ and
	defined_count_.
	(Sized_dynobj::do_add_symbols): Allocate symbols_ if printing
	symbol counts.
	(Sized_dynobj::do_get_global_symbol_counts): New function.
	* dynobj.h (class Sized_dynobj): Add fields symbols_ and
	defined_count_.  Update declarations.  Define Symbols typedef.
	* symtab.cc (Symbol_table::add_from_relobj): Add defined
	parameter.  Change all callers.
	(Symbol_table::add_from_dynobj): Add sympointers and defined
	parameters.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* Makefile.am (CCFILES): Add cref.cc.
	(HFILES): Add cref.h.
	* Makefile.in: Rebuild.
@
text
@d387 1
a387 1
  const_iterator(const Archive* archive, off_t off)
d434 1
a434 1
  const Archive* archive_;
d484 1
a484 1
Archive::begin() const
d492 1
a492 1
Archive::end() const
d518 1
a518 1
Archive::count_members() const
@


1.32
log
@	* archive.cc (Archive::include_all_members) Correct to step
	over symbol table and extended name table in thin archives.
@
text
@d194 1
a194 1
                          std::string* pname, off_t* nested_off)
d296 2
d364 131
d503 10
a512 11
  off_t off = sarmag;
  off_t filesize = this->input_file_->file().filesize();
  while (true)
    {
      if (filesize - off < static_cast<off_t>(sizeof(Archive_header)))
        {
          if (filesize != off)
	    gold_error(_("%s: short archive header at %zu"),
		       this->name().c_str(), static_cast<size_t>(off));
          break;
        }
d514 2
a515 2
      unsigned char hdr_buf[sizeof(Archive_header)];
      this->input_file_->file().read(off, sizeof(Archive_header), hdr_buf);
d517 9
a525 25
      const Archive_header* hdr =
	reinterpret_cast<const Archive_header*>(hdr_buf);
      std::string name;
      off_t size = this->interpret_header(hdr, off, &name, NULL);
      bool special_member = false;
      if (name.empty())
        {
          // Symbol table.
          special_member = true;
        }
      else if (name == "/")
        {
          // Extended name table.
          special_member = true;
        }
      else
        this->include_member(symtab, layout, input_objects, off,
			     mapfile, NULL, "--whole-archive");

      off += sizeof(Archive_header);
      if (special_member || !this->is_thin_archive_)
        off += size;
      if ((off & 1) != 0)
        ++off;
    }
@


1.31
log
@	* mapfile.cc: New file.
	* mapfile.h: New file.
	* options.h (class General_options): Add -M/--print-map and -Map.
	* options.cc (General_options::finalize): Make -M equivalent to
	-Map -.
	* main.cc: Include <cstdio> and "mapfile.h".
	(main): Open mapfile if requested.
	* gold.cc (class Middle_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(queue_initial_tasks): Add mapfile parameter.  Change caller.
	(queue_middle_tasks): Likewise.
	* gold.h (queue_initial_tasks, queue_middle_tasks): Update
	declarations.
	* archive.cc: Include "mapfile.h".
	(Archive::add_symbols): Add mapfile parameter.  Change all
	callers.  Pass mapfile, symbol, and reason to include_member.
	(Archive::include_all_members): Add mapfile parameter.  Change all
	callers.
	(Archive::include_member): Add mapfile, sym, and why parameters.
	Change all callers.  Report inclusion to map file.
	* archive.h: Include "fileread.h".
	(class Archive): Update declarations.
	(Archive::file): New const method.
	(class Add_archive_symbols): Add mapfile_ field.  Update
	constructor.  Change all callers.
	* readsyms.h (class Read_symbols): Likewise.
	(class Finish_group): Likewise.
	(class Read_script): Likewise.
	* common.cc: Include "mapfile.h".
	(Symbol_table::allocate_commons): Add mapfile parameter.  Change
	all callers.
	(Symbol_table::do_allocate_commons): Likewise.
	(Symbol_table::do_allocate_commons_list): Likewise.  Report common
	symbol allocation to mapfile.
	* common.h (class Allocate_commons_task): Add mapfile_ field.
	Update constructor.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* layout.cc: Include "mapfile.h".
	(Layout_task_runner::run): Print information to mapfile.
	(Layout::create_gold_note): Change Output_data_fixed_space to
	Output_data_zero_fill.
	(Layout::create_build_id): Likewise.
	(Layout::print_to_mapfile): New function.
	* layout.h (class Layout_task_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(class Layout): Declare print_to_mapfile.
	* output.cc (Output_section::Input_section::print_to_mapfile): New
	function.
	(Output_section::add_input_section): If producing a map, always
	add to input_sections_ list.
	(Output_section::do_print_to_mapfile): New function.
	(Output_segment::print_sections_to_mapfile): New function.
	(Output_segment::print_section_list_to_mapfile): New function.
	* output.h: Include "mapfile.h".
	(Output_data::print_to_mapfile): New function.
	(Output_data::do_print_to_mapfile): New virtual function.
	(Output_segment_headers::do_print_to_mapfile): New function.
	(Output_file_header::do_print_to_mapfile): New function.
	(Output_data_const::do_print_to_mapfile): New function.
	(class Output_data_const_buffer): Add map_name_ field.  Update
	constructor.  Change all callers.  Add do_print_to_mapfile
	function.
	(class Output_data_fixed_space): Likewise.
	(class Output_data_space): Likewise.
	(class Output_data_zero_fill): New class.
	(Output_data_strtab::do_print_to_mapfile): New function.
	(Output_data_reloc_base::do_print_to_mapfile): New function.
	(Output_relocatable_relocs::do_print_to_mapfile): New function.
	(Output_data_group::do_print_to_mapfile): New function.
	(Output_data_got::do_print_to_mapfile): New function.
	(Output_data_dynamic::do_print_to_mapfile): New function.
	(Output_symtab_xindex::do_print_to_mapfile): New function.
	(class Output_section): Declare do_print_to_mapflie.  Declare
	print_to_mapfile in Input_section.
	(class Output_segment): Declare new functions.
	* object.h (Sized_relobj::symbol_count): New function.
	* script-sections.cc
	(Output_section_element_dot_assignment::set_section_addresses):
	Change Output_data_fixed_space to Output_data_zero_fill.
	(Output_data_expression::do_print_to_mapfile): New function.
	* script.cc (read_input_script): Add mapfile parameter.  Change
	all callers.
	* script.h (read_input_script): Update declaration.
	* ehframe.h (Eh_frame_hdr::do_print_to_mapfile): New function.
	(Eh_frame::do_print_to_mapfile): New function.
	* merge.h (Output_merge_data::do_print_to_mapfile): New function.
	(Output_merge_string::do_print_to_mapfile): New function.
	* i386.cc (Output_data_plt_i386::do_print_to_mapfile): New
	function.
	* sparc.cc (Output_data_plt_sparc::do_print_to_mapfile): New
	function.
	* x86_64.cc (Output_data_plt_x86_64::do_print_to_mapfile): New
	function.
	* Makefile.am (CCFILES): Add mapfile.cc.
	(HFILES): Add mapfile.h.
	* Makefile.in: Rebuild.
@
text
@d389 1
d393 1
d398 1
d405 1
a405 1
      if (!this->is_thin_archive_)
@


1.30
log
@	PR 6049
	* options.h (DEFINE_set): Add VARNAME_begin and VARNAME_end
	functions.
	(class General_options): Remove existing --undefined, and add
	--no-undefined instead.  Add new --undefined as synonym for -u.
	* archive.cc (Archive::add_symbols): Check whether symbol was
	named with -u.
	* gold.cc (queue_middle_tasks): Add -u symbols to symbol table.
	* symtab.h (class Symbol): Rename CONSTANT to IS_CONSTANT; change
	all uses.  Add IS_UNDEFINED.  Update declarations to split
	different versions of init_base.  Declare init_base_undefined.
	(Symbol::is_defined): Handle IS_UNDEFINED.
	(Symbol::is_undefined): Likewise.
	(Symbol::is_weak_undefined): Call is_undefined.
	(Symbol::is_absolute): Handle IS_CONSTANT.
	(class Sized_symbol): Update declarations to split different
	versions of init.  Declare init_undefined.
	(class Symbol_table): Declare new functions.
	* symtab.cc (Symbol::init_base_object): Rename from init_base.
	Change all callers.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): New function.
	(Sized_symbol::init_object): Rename from init.  Change all
	callers.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Sized_symbol::init_undefined): New function.
	(Symbol_table::add_undefined_symbols_from_command_line): New
	function.
	(Symbol_table::do_add_undefined_symbols_from_command_line): New
	function.
	(Symbol::final_value_is_known): Handle IS_UNDEFINED.
	(Symbol::output_section): Likewise.
	(Symbol::set_output_section): Likewise.
	(Symbol_table::sized_finalize_symbol): Likewise.
	(Symbol_table::sized_write_globals): Likewise.
	* resolve.cc (Symbol_table::should_override): Likewise.
	(Symbol::override_base_with_special): Likewise.
@
text
@d34 1
d290 1
a290 1
		     Input_objects* input_objects)
d293 2
a294 1
    return this->include_all_members(symtab, layout, input_objects);
d348 7
d356 2
a357 1
			       last_seen_offset);
d368 1
a368 1
                             Input_objects* input_objects)
d398 2
a399 1
        this->include_member(symtab, layout, input_objects, off);
d410 1
a410 1
// the member header.
d414 2
a415 1
			Input_objects* input_objects, off_t off)
d421 3
d469 2
a470 1
          arch->include_member(symtab, layout, input_objects, nested_off);
d570 1
a570 1
			      this->input_objects_);
@


1.29
log
@	* readsyms.cc (Read_symbols::do_read_symbols): Use get_view rather
	than read for file header.
	* archive.cc (Archive::include_member): Likewise.
@
text
@d329 5
a333 1
	    continue;
@


1.28
log
@	* fileread.cc (File_read::find_view): Add byteshift and vshifted
	parameters.  Update for new key type to views_.  Change all
	callers.
	(File_read::read): Adjust for byteshift in returned view.
	(File_read::add_view): New function, broken out of
	find_and_make_view.
	(File_read::make_view): New function, broken out of
	find_and_make_view.
	(File_read::find_or_make_view): Add offset and aligned
	parameters.  Rewrite accordingly.  Change all callers.
	(File_read::get_view): Add offset and aligned parameters.  Adjust
	for byteshift in return value.
	(File_read::get_lasting_view): Likewise.
	* fileread.h (class File_read): Update declarations.
	(class File_read::View): Add byteshift_ field.  Add byteshift to
	constructor.  Add byteshift method.
	* archive.h (Archive::clear_uncached_views): New function.
	(Archive::get_view): Add aligned parameter.  Change all callers.
	* object.h (Object::get_view): Add aligned parameter.  Change all
	callers.
	(Object::get_lasting_view): Likewise.

	* fileread.cc (File_read::release): Don't call clear_views if
	there are multiple objects.
	* fileread.h (File_read::clear_uncached_views): New function.
	* archive.cc (Add_archive_symbols::run): Call clear_uncached_views
	on the archive.
@
text
@a466 3
  // Read enough of the file to pick up the entire ELF header.
  unsigned char ehdr_buf[elfcpp::Elf_sizes<64>::ehdr_size];

d479 2
a480 1
  input_file->file().read(memoff, read_size, ehdr_buf);
d487 1
a487 1
  if (memcmp(ehdr_buf, elfmagic, 4) != 0)
d496 1
a496 2
				input_file, memoff, ehdr_buf,
				read_size);
@


1.27
log
@2008-03-31  Cary Coutant  <ccoutant@@google.com>

	Add thin archive support.
	* archive.cc (Archive::armagt): New const.
	(Archive::setup): Remove task parameter and calls to unlock.
	(Archive::unlock_nested_archives): New function.
	(Archive::read_header): Add nested_off parameter. Change
	all callers.
	(Archive::interpret_header): Likewise.
	(Archive::include_all_members): Change to handle thin
	archives.
	(Archive::include_member): Likewise.
	* archive.h (Archive::Archive): Add new parameters and
	initializers.
	(Archive::armagt): New const.
	(Archive::setup): Remove task parameter.
	(Archive::unlock_nested_archives): New function.
	(Archive::read_header): Add nested_off parameter.
	(Archive::interpret_header): Likewise.
	(Archive::Nested_archive_table): New typedef.
	(Archive::is_thin_archive_): New field.
	(Archive::nested_archives_): New field.
	(Archive::options_): New field.
	(Archive::dirpath_): New field.
	(Archive::task_): New field.
	* readsyms.cc (Read_symbols::do_read_symbols): Add check
	for thin archives.  Pass additional parameters to
	Archive::Archive.  Unlock the archive file after calling
	Archive::setup.
@
text
@d115 1
a115 1
                                              extended_size, true);
d140 1
a140 1
  const unsigned char* p = this->get_view(start, size, false);
d181 2
a182 1
  const unsigned char* p = this->get_view(off, sizeof(Archive_header), cache);
d558 1
@


1.26
log
@Update copyright years.  Update language files.
@
text
@d29 2
d72 5
d83 1
a83 1
Archive::setup(Task* task)
d87 1
a87 4
    {
      this->input_file_->file().unlock(task);
      return;
    }
d93 1
a93 1
						   &armap_name));
d111 1
a111 1
    convert_to_section_size_type(this->read_header(off, true, &xname));
d119 3
d123 9
a131 2
  // Opening the file locked it.  Unlock it now.
  this->input_file_->file().unlock(task);
d178 2
a179 1
Archive::read_header(off_t off, bool cache, std::string* pname)
d183 1
a183 1
  return this->interpret_header(hdr, off,  pname);
d192 1
a192 1
                          std::string* pname)
d232 2
d249 3
d263 1
a263 1
      const char* name_end = strchr(name, '/');
d265 1
a265 1
	  || name_end[1] != '\n')
d271 3
a273 1
      pname->assign(name, name_end - name);
d373 1
a373 1
      off_t size = this->interpret_header(hdr, off, &name);
d385 3
a387 1
      off += sizeof(Archive_header) + size;
d401 2
a402 1
  this->read_header(off, false, &n);
d404 61
a464 1
  const off_t memoff = off + static_cast<off_t>(sizeof(Archive_header));
d469 1
a469 1
  off_t filesize = this->input_file_->file().filesize();
d481 1
a481 1
  this->input_file_->file().read(memoff, read_size, ehdr_buf);
d497 1
a497 1
				this->input_file_, memoff, ehdr_buf,
d513 5
d554 2
@


1.25
log
@From Craig Silverstein: rename option functions for future option
handling rewrite.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.24
log
@Reduce the number of system calls.  Use readv instead of pread.  Do
better handling of cached views.
@
text
@d96 1
a96 1
  else if (!this->input_file_->options().include_whole_archive())
d268 1
a268 1
  if (this->input_file_->options().include_whole_archive())
@


1.23
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d88 2
a89 1
    convert_to_section_size_type(this->read_header(sarmag, &armap_name));
d100 3
a102 1
  // See if there is an extended name table.
d106 2
a107 1
  off_t extended_size = this->read_header(off, &xname);
d111 1
a111 1
                                              extended_size, false);
d164 1
a164 1
Archive::read_header(off_t off, std::string* pname)
d166 1
a166 1
  const unsigned char* p = this->get_view(off, sizeof(Archive_header), false);
d377 1
a377 1
  this->read_header(off, &n);
@


1.22
log
@Rewrite workqueue.  This version eliminates the master thread, and
reduces the amount of locking required to find a new thread to run.
@
text
@d87 2
a88 1
  off_t armap_size = this->read_header(sarmag, &armap_name);
d119 1
a119 1
Archive::read_armap(off_t start, off_t size)
d131 2
a132 1
  off_t names_size = reinterpret_cast<const char*>(p) + size - pnames;
d137 1
a137 1
  off_t name_offset = 0;
d146 1
a146 1
  if (reinterpret_cast<const unsigned char*>(pnames) - p > size)
@


1.21
log
@Add threading support.
@
text
@d76 1
a76 1
Archive::setup()
d81 1
a81 1
      this->input_file_->file().unlock();
d112 1
a112 1
  this->input_file_->file().unlock();
d437 2
a438 2
Task::Is_runnable_type
Add_archive_symbols::is_runnable(Workqueue*)
d441 2
a442 2
    return IS_BLOCKED;
  return IS_RUNNABLE;
d445 2
a446 1
class Add_archive_symbols::Add_archive_symbols_locker : public Task_locker
d448 2
a449 17
 public:
  Add_archive_symbols_locker(Task_token& token, Workqueue* workqueue,
			     File_read& file)
    : blocker_(token, workqueue), filelock_(file)
  { }

 private:
  Task_locker_block blocker_;
  Task_locker_obj<File_read> filelock_;
};

Task_locker*
Add_archive_symbols::locks(Workqueue* workqueue)
{
  return new Add_archive_symbols_locker(*this->next_blocker_,
					workqueue,
					this->archive_->file());
d457 2
@


1.20
log
@Ignore empty archives.
@
text
@d478 1
@


1.19
log
@From Craig Silverstein: Don't crash if we see a file we don't recognize.
@
text
@d78 7
@


1.18
log
@Remove extraneous newlines.
@
text
@d402 12
a413 1
  input_objects->add_object(obj);
a414 4
  Read_symbols_data sd;
  obj->read_symbols(&sd);
  obj->layout(symtab, layout, &sd);
  obj->add_symbols(symtab, &sd);
@


1.17
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d199 1
a199 1
	  gold_error(_("%s: malformed archive header name at %zu\n"),
@


1.16
log
@From Craig Silverstein: avoid some signed/unsigned warnings from gcc 4.2.
@
text
@d81 1
a81 1
  off_t off;
d88 2
a89 7
    {
      fprintf(stderr, _("%s: %s: no archive symbol table (run ranlib)\n"),
	      program_name, this->name().c_str());
      gold_exit(false);
    }
  else
    off = sarmag;
d138 2
a139 5
    {
      fprintf(stderr, _("%s: %s: bad archive symbol table names\n"),
	      program_name, this->name().c_str());
      gold_exit(false);
    }
d168 3
a170 4
      fprintf(stderr, _("%s; %s: malformed archive header at %ld\n"),
	      program_name, this->name().c_str(),
	      static_cast<long>(off));
      gold_exit(false);
d188 3
a190 4
      fprintf(stderr, _("%s: %s: malformed archive header size at %ld\n"),
	      program_name, this->name().c_str(),
	      static_cast<long>(off));
      gold_exit(false);
d199 3
a201 4
	  fprintf(stderr, _("%s: %s: malformed archive header name at %ld\n"),
		  program_name, this->name().c_str(),
		  static_cast<long>(off));
	  gold_exit(false);
d224 3
a226 4
	  fprintf(stderr, _("%s: %s: bad extended name index at %ld\n"),
		  program_name, this->name().c_str(),
		  static_cast<long>(off));
	  gold_exit(false);
d234 3
a236 4
	  fprintf(stderr, _("%s: %s: bad extended name entry at header %ld\n"),
		  program_name, this->name().c_str(),
		  static_cast<long>(off));
	  gold_exit(false);
d327 2
a328 7
            {
              fprintf(stderr, _("%s: %s: short archive header at %ld\n"),
                      program_name, this->name().c_str(),
                      static_cast<long>(off));
              gold_exit(false);
            }

d378 3
a380 4
      fprintf(stderr, _("%s: %s: member at %ld is not an ELF object"),
	      program_name, this->name().c_str(),
	      static_cast<long>(off));
      gold_exit(false);
d392 3
a394 4
      fprintf(stderr, _("%s: %s: member at %ld is not an ELF object"),
	      program_name, this->name().c_str(),
	      static_cast<long>(off));
      gold_exit(false);
@


1.15
log
@Add cache parameter to get_view.  Discard uncached views on unlock.
Fix bug this exposed in archive armap symbol name handling.
@
text
@d337 1
a337 1
      if (filesize - off < sizeof(Archive_header))
d384 1
a384 1
  size_t memoff = off + sizeof(Archive_header);
@


1.14
log
@Rework File_read interface.  Get file size.  Use pread when
available.
@
text
@d104 1
a104 1
                                              extended_size);
d119 1
a119 1
  const unsigned char* p = this->get_view(start, size);
d128 2
d133 1
d136 3
a138 3
      this->armap_[i].name = pnames;
      this->armap_[i].offset = elfcpp::Swap<32, true>::readval(pword);
      pnames += strlen(pnames) + 1;
d161 1
a161 1
  const unsigned char* p = this->get_view(off, sizeof(Archive_header));
d289 1
a289 1
	  if (this->armap_[i].offset == last_seen_offset)
d294 1
a294 1
	  if (this->seen_offsets_.find(this->armap_[i].offset)
d298 1
a298 1
	      last_seen_offset = this->armap_[i].offset;
d302 3
a304 1
	  Symbol* sym = symtab->lookup(this->armap_[i].name);
d316 1
a316 1
	  last_seen_offset = this->armap_[i].offset;
@


1.13
log
@Remove get_view_and_size.
@
text
@d329 1
d332 1
a332 6
      unsigned char hdr_buf[sizeof(Archive_header)];
      off_t bytes;
      this->input_file_->file().read_up_to(off, sizeof(Archive_header),
					   hdr_buf, &bytes);

      if (bytes < sizeof(Archive_header))
d334 1
a334 1
          if (bytes != 0)
d345 3
d382 8
a389 5
  int ehdr_size = elfcpp::Elf_sizes<64>::ehdr_size;
  unsigned char ehdr_buf[ehdr_size];
  off_t bytes;
  this->input_file_->file().read_up_to(memoff, ehdr_size, ehdr_buf, &bytes);
  if (bytes < 4)
d397 2
d414 2
a415 1
				this->input_file_, memoff, ehdr_buf, bytes);
@


1.12
log
@Break out default pbytes argument to read and get_view routines,
adding new routines.
@
text
@d331 1
d333 3
a335 3
      const unsigned char* p = this->get_view_and_size(off,
						       sizeof(Archive_header),
						       &bytes);
d349 2
a350 1
      const Archive_header* hdr = reinterpret_cast<const Archive_header*>(p);
d384 1
d386 1
a386 2
  const unsigned char* p =
    this->input_file_->file().get_view_and_size(memoff, ehdr_size, &bytes);
d400 1
a400 1
  if (memcmp(p, elfmagic, 4) != 0)
d410 1
a410 1
				this->input_file_, memoff, p, bytes);
@


1.11
log
@Add licensing text to every source file.
@
text
@d332 3
a334 2
      const unsigned char* p = this->get_view(off, sizeof(Archive_header),
                                              &bytes);
d383 2
a384 3
  const unsigned char* p = this->input_file_->file().get_view(memoff,
							      ehdr_size,
							      &bytes);
@


1.10
log
@Add global parameters.
@
text
@d3 20
@


1.9
log
@Fix comment.
@
text
@d11 1
d242 2
a243 2
Archive::add_symbols(const General_options& options, Symbol_table* symtab,
		     Layout* layout, Input_objects* input_objects)
d246 1
a246 1
    return this->include_all_members(options, symtab, layout, input_objects);
d294 1
a294 1
	  this->include_member(options, symtab, layout, input_objects,
d305 1
a305 2
Archive::include_all_members(const General_options& options,
                             Symbol_table* symtab, Layout* layout,
d339 1
a339 1
        this->include_member(options, symtab, layout, input_objects, off);
d351 2
a352 3
Archive::include_member(const General_options& options, Symbol_table* symtab,
			Layout* layout, Input_objects* input_objects,
			off_t off)
d394 1
a394 1
  obj->layout(options, symtab, layout, &sd);
d443 2
a444 2
  this->archive_->add_symbols(this->options_, this->symtab_, this->layout_,
                              this->input_objects_);
@


1.8
log
@Rework patch to check by both armap entry and archive offset.  Also,
preserve information for --group.
@
text
@d250 2
a251 2
  // in a row with the same offset.  last_seen holds the last offset
  // we saw that was present in the seen_ set.
@


1.7
log
@From Craig Silverstein: rework seen handling to be based on archive
offsets rather than entries in archive symbol table.
@
text
@d124 4
a232 8
// A simple hash code for off_t values.
class Seen_hash
{
 public:
  size_t operator()(off_t val) const
  { return static_cast<size_t>(val); }
};

a248 3
  // Track which elements in the archive map have already been included
  // in the link.  Elements are identified by their offset.
  Unordered_set<off_t, Seen_hash> seen;
d252 4
a255 1
  off_t last_seen = -1;
d263 9
a271 3
	  if (this->armap_[i].offset == last_seen)
	    continue;
	  if (seen.find(this->armap_[i].offset) != seen.end())
d273 2
a274 1
	      last_seen = this->armap_[i].offset;
d283 1
a283 2
	      seen.insert(this->armap_[i].offset);
	      last_seen = this->armap_[i].offset;
d290 3
a292 2
	  last_seen = this->armap_[i].offset;
	  seen.insert(last_seen);
d294 1
a294 1
			       last_seen);
@


1.6
log
@Implement --whole-archive.
@
text
@a123 4

  // This array keeps track of which symbols are for archive elements
  // which we have already included in the link.
  this->seen_.resize(nsyms);
d229 8
d253 8
a264 1
      off_t last = -1;
d267 1
a267 1
	  if (this->seen_[i])
d269 1
a269 1
	  if (this->armap_[i].offset == last)
d271 1
a271 1
	      this->seen_[i] = true;
d280 2
a281 1
	      this->seen_[i] = true;
d288 4
a291 3
	  last = this->armap_[i].offset;
	  this->include_member(options, symtab, layout, input_objects, last);
	  this->seen_[i] = true;
@


1.5
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@d60 7
a66 1
  if (!armap_name.empty())
d72 19
d92 5
d98 1
a98 2
  const unsigned char* p = this->get_view(sarmag + sizeof(Archive_header),
					  armap_size);
d118 1
a118 1
  if (reinterpret_cast<const unsigned char*>(pnames) - p > armap_size)
a124 13
  // See if there is an extended name table.
  off_t off = sarmag + sizeof(Archive_header) + armap_size;
  if ((off & 1) != 0)
    ++off;
  std::string xname;
  off_t extended_size = this->read_header(off, &xname);
  if (xname == "/")
    {
      p = this->get_view(off + sizeof(Archive_header), extended_size);
      const char* px = reinterpret_cast<const char*>(p);
      this->extended_names_.assign(px, extended_size);
    }

a127 3

  // Opening the file locked it.  Unlock it now.
  this->input_file_->file().unlock();
d139 2
d142 8
d244 3
d285 46
d414 1
a414 1
  Task_locker_obj<File_read> filelock_;			     
d429 1
a429 1
			      this->input_objects_);
@


1.4
log
@Can now do a full static link of hello, world in C or C++
@
text
@d73 1
a73 1
  unsigned int nsyms = elfcpp::read_elf_word<true>(pword);
d84 1
a84 1
      this->armap_[i].offset = elfcpp::read_elf_word<true>(pword);
d218 2
a219 2
Archive::add_symbols(Symbol_table* symtab, Layout* layout,
		     Input_objects* input_objects)
d251 1
a251 1
	  this->include_member(symtab, layout, input_objects, last);
d263 3
a265 2
Archive::include_member(Symbol_table* symtab, Layout* layout,
			Input_objects* input_objects, off_t off)
d307 1
a307 1
  obj->layout(layout, &sd);
d356 1
a356 1
  this->archive_->add_symbols(this->symtab_, this->layout_,
@


1.3
log
@Framework for relocation scanning.  Implement simple static TLS
relocations.
@
text
@d12 1
a50 8
// Get a view into the underlying file.

const unsigned char*
Archive::get_view(off_t start, off_t size)
{
  return this->input_file_->file().get_view(start, size);
}

d109 4
d221 1
a221 4
  size_t armap_size = this->armap_.size();
  std::vector<bool> seen;
  seen.resize(this->armap_.size());
  seen.clear();
d230 1
a230 1
	  if (seen[i])
d234 1
a234 1
	      seen[i] = true;
d241 1
a241 1
	  else if (sym->shnum() != elfcpp::SHN_UNDEF)
d243 1
a243 1
	      seen[i] = true;
d252 1
d335 2
a336 2
			     Archive* archive)
    : blocker_(token, workqueue), archlock_(*archive)
d341 1
a341 1
  Task_locker_obj<Archive> archlock_;			     
d349 1
a349 1
					this->archive_);
d357 8
@


1.2
log
@Lay out object file sections when we add the symbols to the symbol
table.
@
text
@d303 1
a303 1
  Object* obj = make_elf_object((std::string(this->input_file_->name())
@


1.1
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d221 2
a222 1
Archive::add_symbols(Symbol_table* symtab, Input_objects* input_objects)
d257 1
a257 1
	  this->include_member(symtab, input_objects, last);
d268 2
a269 2
Archive::include_member(Symbol_table* symtab, Input_objects* input_objects,
			off_t off)
d309 4
a312 2
  Read_symbols_data sd = obj->read_symbols();
  obj->add_symbols(symtab, sd);
d360 2
a361 1
  this->archive_->add_symbols(this->symtab_, this->input_objects_);
@

