head	1.19;
access;
symbols
	binutils-2_24-branch:1.19.0.2
	binutils-2_24-branchpoint:1.19
	binutils-2_21_1:1.14
	binutils-2_23_2:1.16
	binutils-2_23_1:1.16
	binutils-2_23:1.16
	binutils-2_23-branch:1.16.0.2
	binutils-2_23-branchpoint:1.16
	binutils-2_22_branch:1.15.0.4
	binutils-2_22:1.15
	binutils-2_22-branch:1.15.0.2
	binutils-2_22-branchpoint:1.15
	binutils-2_21:1.14
	binutils-2_21-branch:1.14.0.2
	binutils-2_21-branchpoint:1.14
	binutils-2_20_1:1.2.2.1
	binutils-2_20:1.2.2.1
	binutils-2_20-branch:1.2.0.2
	binutils-2_20-branchpoint:1.2
	dje-cgen-play1-branch:1.1.0.2
	dje-cgen-play1-branchpoint:1.1
	binutils_latest_snapshot:1.19;
locks; strict;
comment	@ * @;


1.19
date	2013.03.15.07.51.32;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.12.00.42.14;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2012.09.09.03.43.51;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2012.04.26.00.07.17;	author ian;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.14;

1.14
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2010.07.29.18.57.28;	author tmsriram;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.23.18.49.22;	author tmsriram;	state Exp;
branches;
next	1.11;

1.11
date	2010.02.21.00.57.59;	author tmsriram;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.13.02.04.20;	author tmsriram;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.20.17.29.52;	author dougkwan;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.12.07.22.56;	author dougkwan;	state Exp;
branches;
next	1.7;

1.7
date	2010.01.07.07.14.29;	author tmsriram;	state Exp;
branches;
next	1.6;

1.6
date	2010.01.04.19.08.39;	author tmsriram;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.29.05.16.23;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.13.21.17.43;	author tmsriram;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.13.00.39.31;	author tmsriram;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.05.20.51.56;	author tmsriram;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	;

1.2.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	;


desc
@@


1.19
log
@	* gc.h (gc_process_relocs): Don't look through function descriptors.
	* icf.cc (get_section_contents): Do so here instead.
@
text
@// gc.h -- garbage collection of unused sections

// Copyright 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
// Written by Sriraman Tallam <tmsriram@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#ifndef GOLD_GC_H
#define GOLD_GC_H

#include <queue>
#include <vector>

#include "elfcpp.h"
#include "symtab.h"
#include "object.h"
#include "icf.h"

namespace gold
{

class Object;

template<int size, bool big_endian>
class Sized_relobj_file;

template<int sh_type, int size, bool big_endian>
struct Reloc_types;

class Output_section;
class General_options;
class Layout;

class Garbage_collection
{
 public:

  typedef Unordered_set<Section_id, Section_id_hash> Sections_reachable;
  typedef std::map<Section_id, Sections_reachable> Section_ref;
  typedef std::queue<Section_id> Worklist_type;
  // This maps the name of the section which can be represented as a C
  // identifier (cident) to the list of sections that have that name.
  // Different object files can have cident sections with the same name.
  typedef std::map<std::string, Sections_reachable> Cident_section_map;

  Garbage_collection()
  : is_worklist_ready_(false)
  { }

  // Accessor methods for the private members.

  Sections_reachable&
  referenced_list()
  { return referenced_list_; }

  Section_ref&
  section_reloc_map()
  { return this->section_reloc_map_; }

  Worklist_type&
  worklist()
  { return this->work_list_; }

  bool
  is_worklist_ready()
  { return this->is_worklist_ready_; }

  void
  worklist_ready()
  { this->is_worklist_ready_ = true; }

  void
  do_transitive_closure();

  bool
  is_section_garbage(Object* obj, unsigned int shndx)
  { return (this->referenced_list().find(Section_id(obj, shndx))
            == this->referenced_list().end()); }

  Cident_section_map*
  cident_sections()
  { return &cident_sections_; }

  void
  add_cident_section(std::string section_name,
		     Section_id secn)
  { this->cident_sections_[section_name].insert(secn); }

  // Add a reference from the SRC_SHNDX-th section of SRC_OBJECT to
  // DST_SHNDX-th section of DST_OBJECT.
  void
  add_reference(Object* src_object, unsigned int src_shndx,
		Object* dst_object, unsigned int dst_shndx)
  {
    Section_id src_id(src_object, src_shndx);
    Section_id dst_id(dst_object, dst_shndx);
    Section_ref::iterator p = this->section_reloc_map_.find(src_id);
    if (p == this->section_reloc_map_.end())
      this->section_reloc_map_[src_id].insert(dst_id);
    else
      p->second.insert(dst_id);
  }

 private:

  Worklist_type work_list_;
  bool is_worklist_ready_;
  Section_ref section_reloc_map_;
  Sections_reachable referenced_list_;
  Cident_section_map cident_sections_;
};

// Data to pass between successive invocations of do_layout
// in object.cc while garbage collecting.  This data structure
// is filled by using the data from Read_symbols_data.

struct Symbols_data
{
  // Section headers.
  unsigned char* section_headers_data;
  // Section names.
  unsigned char* section_names_data;
  // Size of section name data in bytes.
  section_size_type section_names_size;
  // Symbol data.
  unsigned char* symbols_data;
  // Size of symbol data in bytes.
  section_size_type symbols_size;
  // Offset of external symbols within symbol data.  This structure
  // sometimes contains only external symbols, in which case this will
  // be zero.  Sometimes it contains all symbols.
  section_offset_type external_symbols_offset;
  // Symbol names.
  unsigned char* symbol_names_data;
  // Size of symbol name data in bytes.
  section_size_type symbol_names_size;
};

// Relocations of type SHT_REL store the addend value in their bytes.
// This function returns the size of the embedded addend which is
// nothing but the size of the relocation.

template<typename Classify_reloc>
inline unsigned int
get_embedded_addend_size(int sh_type, int r_type, Relobj* obj)
{
  if (sh_type != elfcpp::SHT_REL)
    return 0;
  Classify_reloc classify_reloc;
  return classify_reloc.get_size_for_reloc(r_type, obj);
}

// This function implements the generic part of reloc
// processing to map a section to all the sections it
// references through relocs.  It is called only during
// garbage collection (--gc-sections) and identical code
// folding (--icf).

template<int size, bool big_endian, typename Target_type, int sh_type,
	 typename Scan, typename Classify_reloc>
inline void
gc_process_relocs(
    Symbol_table* symtab,
    Layout*,
    Target_type* target,
    Sized_relobj_file<size, big_endian>* src_obj,
    unsigned int src_indx,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section*,
    bool,
    size_t local_count,
    const unsigned char* plocal_syms)
{
  Scan scan;

  typedef typename Reloc_types<sh_type, size, big_endian>::Reloc Reltype;
  const int reloc_size = Reloc_types<sh_type, size, big_endian>::reloc_size;
  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;

  Icf::Sections_reachable_info* secvec = NULL;
  Icf::Symbol_info* symvec = NULL;
  Icf::Addend_info* addendvec = NULL;
  Icf::Offset_info* offsetvec = NULL;
  Icf::Reloc_addend_size_info* reloc_addend_size_vec = NULL;
  bool is_icf_tracked = false;
  const char* cident_section_name = NULL;

  std::string src_section_name = (parameters->options().icf_enabled()
                                  ? src_obj->section_name(src_indx)
                                  : "");

  bool check_section_for_function_pointers = false;

  if (parameters->options().icf_enabled()
      && is_section_foldable_candidate(src_section_name.c_str()))
    {
      is_icf_tracked = true;
      Section_id src_id(src_obj, src_indx);
      Icf::Reloc_info* reloc_info =
        &symtab->icf()->reloc_info_list()[src_id];
      secvec = &reloc_info->section_info;
      symvec = &reloc_info->symbol_info;
      addendvec = &reloc_info->addend_info;
      offsetvec = &reloc_info->offset_info;
      reloc_addend_size_vec = &reloc_info->reloc_addend_size_info;
    }

  check_section_for_function_pointers =
    symtab->icf()->check_section_for_function_pointers(src_section_name,
                                                       target);

  for (size_t i = 0; i < reloc_count; ++i, prelocs += reloc_size)
    {
      Reltype reloc(prelocs);
      typename elfcpp::Elf_types<size>::Elf_WXword r_info = reloc.get_r_info();
      unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);
      unsigned int r_type = elfcpp::elf_r_type<size>(r_info);
      typename elfcpp::Elf_types<size>::Elf_Swxword addend =
      Reloc_types<sh_type, size, big_endian>::get_reloc_addend_noerror(&reloc);
      Object* dst_obj;
      unsigned int dst_indx;
      typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
      Address dst_off;

      if (r_sym < local_count)
        {
          gold_assert(plocal_syms != NULL);
          typename elfcpp::Sym<size, big_endian> lsym(plocal_syms
                                                      + r_sym * sym_size);
	  dst_indx = lsym.get_st_shndx();
          bool is_ordinary;
	  dst_indx = src_obj->adjust_sym_shndx(r_sym, dst_indx, &is_ordinary);
          dst_obj = src_obj;
	  dst_off = lsym.get_st_value() + addend;

          if (is_icf_tracked)
            {
	      Address symvalue = dst_off - addend;
	      if (is_ordinary) 
		(*secvec).push_back(Section_id(dst_obj, dst_indx));
	      else
                (*secvec).push_back(Section_id(NULL, 0));
              (*symvec).push_back(NULL);
	      (*addendvec).push_back(std::make_pair(
					static_cast<long long>(symvalue),
					static_cast<long long>(addend)));
              uint64_t reloc_offset =
                convert_to_section_size_type(reloc.get_r_offset());
	      (*offsetvec).push_back(reloc_offset);
              (*reloc_addend_size_vec).push_back(
                get_embedded_addend_size<Classify_reloc>(sh_type, r_type,
                                                         src_obj));
            }

	  // When doing safe folding, check to see if this relocation is that
	  // of a function pointer being taken.
	  if (is_ordinary
	      && check_section_for_function_pointers
              && lsym.get_st_type() != elfcpp::STT_OBJECT
 	      && scan.local_reloc_may_be_function_pointer(symtab, NULL, NULL,
							  src_obj, src_indx,
			                       		  NULL, reloc, r_type,
							  lsym))
            symtab->icf()->set_section_has_function_pointers(
              src_obj, lsym.get_st_shndx());

          if (!is_ordinary || dst_indx == src_indx)
            continue;
        }
      else
        {
          Symbol* gsym = src_obj->global_symbol(r_sym);
          gold_assert(gsym != NULL);
          if (gsym->is_forwarder())
            gsym = symtab->resolve_forwards(gsym);

          dst_obj = NULL;
          dst_indx = 0;
          bool is_ordinary = false;
          if (gsym->source() == Symbol::FROM_OBJECT)
            {
              dst_obj = gsym->object();
              dst_indx = gsym->shndx(&is_ordinary);
            }
	  dst_off = static_cast<const Sized_symbol<size>*>(gsym)->value();
	  dst_off += addend;

	  // When doing safe folding, check to see if this relocation is that
	  // of a function pointer being taken.
	  if (gsym->source() == Symbol::FROM_OBJECT
              && check_section_for_function_pointers
              && gsym->type() != elfcpp::STT_OBJECT
              && (!is_ordinary
                  || scan.global_reloc_may_be_function_pointer(
                       symtab, NULL, NULL, src_obj, src_indx, NULL, reloc,
                       r_type, gsym)))
            symtab->icf()->set_section_has_function_pointers(dst_obj, dst_indx);

          // If the symbol name matches '__start_XXX' then the section with
          // the C identifier like name 'XXX' should not be garbage collected.
          // A similar treatment to symbols with the name '__stop_XXX'.
          if (is_prefix_of(cident_section_start_prefix, gsym->name()))
            {
              cident_section_name = (gsym->name() 
                                     + strlen(cident_section_start_prefix));
            }
          else if (is_prefix_of(cident_section_stop_prefix, gsym->name()))
            {
              cident_section_name = (gsym->name() 
                                     + strlen(cident_section_stop_prefix));
            }
          if (is_icf_tracked)
            {
	      Address symvalue = dst_off - addend;
              if (is_ordinary && gsym->source() == Symbol::FROM_OBJECT)
		(*secvec).push_back(Section_id(dst_obj, dst_indx));
	      else
                (*secvec).push_back(Section_id(NULL, 0));
              (*symvec).push_back(gsym);
	      (*addendvec).push_back(std::make_pair(
					static_cast<long long>(symvalue),
					static_cast<long long>(addend)));
              uint64_t reloc_offset =
                convert_to_section_size_type(reloc.get_r_offset());
	      (*offsetvec).push_back(reloc_offset);
              (*reloc_addend_size_vec).push_back(
                get_embedded_addend_size<Classify_reloc>(sh_type, r_type,
                                                         src_obj));
	    }

          if (gsym->source() != Symbol::FROM_OBJECT)
            continue;
          if (!is_ordinary)
            continue;
        }
      if (parameters->options().gc_sections())
        {
	  symtab->gc()->add_reference(src_obj, src_indx, dst_obj, dst_indx);
	  parameters->sized_target<size, big_endian>()
	    ->gc_add_reference(symtab, src_obj, src_indx,
			       dst_obj, dst_indx, dst_off);
          if (cident_section_name != NULL)
            {
              Garbage_collection::Cident_section_map::iterator ele =
                symtab->gc()->cident_sections()->find(std::string(cident_section_name));
              if (ele == symtab->gc()->cident_sections()->end())
                continue;
	      Section_id src_id(src_obj, src_indx);
              Garbage_collection::Sections_reachable&
                v(symtab->gc()->section_reloc_map()[src_id]);
              Garbage_collection::Sections_reachable& cident_secn(ele->second);
              for (Garbage_collection::Sections_reachable::iterator it_v
                     = cident_secn.begin();
                   it_v != cident_secn.end();
                   ++it_v)
                {
                  v.insert(*it_v);
                }
            }
        }
    }
  return;
}

} // End of namespace gold.

#endif
@


1.18
log
@	* gc.h (gc_process_relocs): Look through function descriptors
	to determine shndx, symvalue and addend used by ICF.  Tidy
	variable duplication.
@
text
@d256 1
a256 15
		{
		  Symbol_location loc;
		  loc.object = dst_obj;
		  loc.shndx = dst_indx;
		  loc.offset = convert_types<off_t, Address>(dst_off);
		  // Look through function descriptors.
		  parameters->target().function_location(&loc);
		  if (loc.shndx != dst_indx)
		    {
		      // Modify symvalue/addend to the code entry.
		      symvalue = loc.offset;
		      addend = 0;
		    }
		  (*secvec).push_back(Section_id(loc.object, loc.shndx));
		}
d332 1
a332 15
		{
		  Symbol_location loc;
		  loc.object = dst_obj;
		  loc.shndx = dst_indx;
		  loc.offset = convert_types<off_t, Address>(dst_off);
		  // Look through function descriptors.
		  parameters->target().function_location(&loc);
		  if (loc.shndx != dst_indx)
		    {
		      // Modify symvalue/addend to the code entry.
		      symvalue = loc.offset;
		      addend = 0;
		    }
		  (*secvec).push_back(Section_id(loc.object, loc.shndx));
		}
@


1.17
log
@	* target.h (Target::gc_mark_symbol, do_gc_mark_symbol): New functions.
	(Sized_target::gc_add_reference, do_gc_add_reference): New functions.
	* gc.h (gc_process_relocs): Call target gc_add_reference.
	* gold.cc (queue_middle_tasks): Use gc_mark_symbol on start sym.
	* symtab.cc (Symbol_table::gc_mark_undef_symbols): Use gc_mark_symbol.
	(Symbol_table::gc_mark_symbol): Call target gc_mark_symbol. Remove
	unnecessary cast.
	* powerpc.cc (Powerpc_relobj::get_opd_ent): Rearrange parameters
	to cater for when we don't need code offset.  Update use.
	(Powerpc_relobj::access_from_map_, opd_valid_): New vars.
	(Powerpc_relobj::access_from_map, add_reference, opd_valid,
	set_opd_valid): New functions.
	(Target_powerpc::do_gc_add_reference): New function.
	(Target_powerpc::gc_process_relocs): Call gc()->add_reference on
	stashed refs.
	(Target_powerpc::do_gc_mark_symbol): New function.
@
text
@d238 2
a239 1
      typename elfcpp::Elf_types<size>::Elf_Addr dst_off;
d246 1
a246 1
          unsigned int shndx = lsym.get_st_shndx();
d248 1
a248 1
          shndx = src_obj->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
d250 1
a250 2
          dst_indx = shndx;
	  dst_off = lsym.get_st_value();
d254 1
d256 15
a270 1
                (*secvec).push_back(Section_id(dst_obj, dst_indx));
d274 3
a276 3
              long long symvalue = static_cast<long long>(lsym.get_st_value());
              (*addendvec).push_back(std::make_pair(symvalue,
                                              static_cast<long long>(addend)));
d297 1
a297 1
          if (!is_ordinary || shndx == src_indx)
a308 1
	  dst_off = 0;
a313 1
	      dst_off = static_cast<const Sized_symbol<size>*>(gsym)->value();
d315 2
d344 1
d346 15
a360 1
                (*secvec).push_back(Section_id(dst_obj, dst_indx));
d364 3
a366 6
              Sized_symbol<size>* sized_gsym =
                        static_cast<Sized_symbol<size>* >(gsym);
              long long symvalue =
                        static_cast<long long>(sized_gsym->value());
              (*addendvec).push_back(std::make_pair(symvalue,
                                        static_cast<long long>(addend)));
a382 1
	  dst_off += addend;
@


1.16
log
@	* arm.cc (Target_arm::do_is_defined_by_abi): Make sym a const
	pointer.
	(Stub_addend_reader::operator()): Declare Arm_relocate_functions
	as a class, not a struct.
	(Target_arm::scan_span_for_cortex_a8_erratum): Likewise.
	(Target_arm::apply_cortex_a8_workaround): Likewise.
	* gc.h: Declare Reloc_types as a struct, not a class.
	* object.h: Declare Symbols_data as a struct.
	* reloc.h: Declare Read_relocs_data as a struct.
	* target.h: Declare Relocate_info as a struct.
@
text
@a189 2
  Object* dst_obj;
  unsigned int dst_indx;
d236 3
d250 2
d294 1
d300 1
d356 4
@


1.15
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d3 1
a3 1
// Copyright 2009, 2010 Free Software Foundation, Inc.
d43 1
a43 1
class Reloc_types;
@


1.14
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d40 1
a40 1
class Sized_relobj;
d181 1
a181 1
    Sized_relobj<size, big_endian>* src_obj,
@


1.13
log
@	* arm.cc (Target_arm<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* i386.cc (Target_i386<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* x86_64.cc (Target_x86_64<big_endian>::gc_process_relocs): Add template
	parameter to the call to gold::gc_process_relocs.
	* powerpc.cc (Target_powerpc<big_endian>::gc_process_relocs): Add
	template parameter to the call to gold::gc_process_relocs.
	* sparc.cc (Target_sparc<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* gc.h (get_embedded_addend_size): New function.
	(gc_process_relocs): Save the size of the reloc for use by ICF.
	* icf.cc (get_section_contents): Get the addend from the text section
	for SHT_REL relocation sections.
	* icf.h (Icf::Reloc_addend_size_info): New typedef.
	(Icf::Reloc_info): Add new member reloc_addend_size_info.
	* int_encoding.h (read_from_pointer): New overloaded function.
	* testsuite/Makefile.am (icf_sht_rel_addend_test): New test.
	* testsuite/icf_sht_rel_addend_test.sh: New file.
	* testsuite/icf_sht_rel_addend_test_1.cc: New file.
	* testsuite/icf_sht_rel_addend_test_2.cc: New file.
@
text
@d190 1
a190 1
  Object *dst_obj;
@


1.12
log
@2010-04-23  Sriraman Tallam  <tmsriram@@google.com>

	* gc.h (gc_process_relocs): Pass information on relocs pointing to
	sections that are not ordinary to icf.
	* icf.cc (get_section_contents): Handle relocation pointing to section
	with no object or shndx information.
	* testsuite/Makefile.am: Remove icf_virtual_function_folding_test.sh
	* testsuite/Makefile.in: Regenerate.
	* testsuite/icf_virtual_function_folding_test.cc: Remove printf.
	* testsuite/icf_virtual_function_folding_test.sh: Delete file.
@
text
@d154 14
d175 1
a175 1
	 typename Scan>
d202 1
d223 1
d262 3
d338 3
@


1.11
log
@2010-02-20  Sriraman Tallam  <tmsriram@@google.com>

	* gc.h (gc_process_relocs): Change vectors to point to the new list.
	Add reloc offset information.
	* icf.cc (get_section_contents): Change iterators to point to the new
	vectors. Add reloc offset information to the contents.
	* icf.h (Icf::Sections_reachable_info): New typedef.
	(Icf::Sections_reachable_list): New typedef.
	(Icf::Offset_info): New typedef.
	(Icf::Reloc_info): New struct typedef.
	(Icf::Reloc_info_list): New typedef.
	(Icf::symbol_reloc_list): Delete method.
	(Icf::addend_reloc_list): Delete method.
	(Icf::section_reloc_list): Delete method.
	(Icf::reloc_info_list): New method.
	(Icf::reloc_info_list_): New member.
@
text
@a230 2
          if (!is_ordinary)
            continue;
a232 1
          Section_id dst_id(dst_obj, dst_indx);
d235 4
a238 1
              (*secvec).push_back(dst_id);
d250 2
a251 1
	  if (check_section_for_function_pointers
d260 1
a260 1
          if (shndx == src_indx)
d269 9
a277 6
          if (gsym->source() != Symbol::FROM_OBJECT)
            continue;
          bool is_ordinary;
          dst_obj = gsym->object();
          dst_indx = gsym->shndx(&is_ordinary);
          Section_id dst_id(dst_obj, dst_indx);
d281 2
a282 1
	  if (check_section_for_function_pointers
a289 3
          if (!is_ordinary)
            continue;

d305 4
a308 1
              (*secvec).push_back(dst_id);
d320 5
@


1.10
log
@2010-02-12  Sriraman Tallam  <tmsriram@@google.com>

	* arm.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* sparc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* powerpc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* i386.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* x86_64.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	(Scan::possible_function_pointer_reloc): New function.
	(Target_x86_64::can_check_for_function_pointers): New function.
	* gc.h (gc_process_relocs): Scan relocation types to determine if
	function pointers were taken for targets that support it.
	* icf.cc (Icf::find_identical_sections): Include functions for
	folding in safe ICF whose pointer is not taken.
	* icf.h (Secn_fptr_taken_set): New typedef.
	(fptr_section_id_): New member.
	(section_has_function_pointers): New function.
	(set_section_has_function_pointers): New function.
	(check_section_for_function_pointers): New function.
	* options.h: Fix comment for safe ICF option.
	* target.h (can_check_for_function_pointers): New function.
	* testsuite/Makefile.am: Add icf_safe_so_test test case.
	Modify icf_safe_test for X86-64.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/icf_safe_so_test.cc: New file.
	* testsuite/icf_safe_so_test.sh: New file.
	* testsuite/icf_safe_test.cc (kept_func_3): New function.
	(main): Change to take pointer to function kept_func_3.
	* testsuite/icf_safe_test.sh (arch_specific_safe_fold): Check if safe
	folding is done correctly for X86-64.
@
text
@d184 4
a187 3
  std::vector<Section_id>* secvec = NULL;
  std::vector<Symbol*>* symvec = NULL;
  std::vector<std::pair<long long, long long> >* addendvec = NULL;
d202 6
a207 3
      secvec = &symtab->icf()->section_reloc_list()[src_id];
      symvec = &symtab->icf()->symbol_reloc_list()[src_id];
      addendvec = &symtab->icf()->addend_reloc_list()[src_id];
d243 3
d311 3
@


1.9
log
@2010-01-20  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::Arm_input_section_map): Change key type from
	Input_section_specifier to Section_id.
	(Target_arm::new_arm_input_section: Adjust code for change of key
	type.
	(Target_arm::find_arm_input_section): Ditto.
	* gc.h (object.h): Include for Section_id nand Section_id_hash.
	(Section_id): Remove.
	(Garbage_collection::Section_id_hash): Remove.
	* icf.h (object.h): Include for Section_id nand Section_id_hash.
	(Section_id): Remove.
	(Icf::Section_id_hash): Remove.
	* object.h (Section_id, Const_section_id, Section_id_hash,
	Const_section_id_hash): New type definitions.
	* output.cc (Output_section::add_relaxed_input_section): Change to
	use Const_section_id instead of Input_section_specifier as key type.
	(Output_section::add_merge_input_section): Ditto.
	(Output_section::build_relaxation_map): Change to use Section_id
	instead of Input_section_specifier as key type.
 	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Ditto.
	(Output_section::convert_input_sections_to_relaxed_sections): Change
	to use Const_section_id instead of Input_section_specifier as key type.
 	(Output_section::find_merge_section): Ditto.
	(Output_section::find_relaxed_input_section): Ditto.
	* output.h (Input_section_specifier): Remove class.
	(Output_section::Output_section_data_by_input_section_map): Change
	key type to Const_section_id.
	(Output_section::Output_relaxed_input_section_by_input_section_map):
	Ditto.
	(Output_section::Relaxation_map): Change key type to Section_id.
@
text
@d166 1
a166 1
    Target_type* ,
d172 1
a172 1
    bool ,
d178 1
d190 6
d197 1
a197 1
      && is_section_foldable_candidate(src_obj->section_name(src_indx).c_str()))
d206 4
d215 1
d240 12
d266 12
d280 1
a280 1
          Section_id dst_id(dst_obj, dst_indx);
d304 1
a304 1
            }
@


1.8
log
@2010-01-11  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::do_gc_process_relocs): New method.
	(Target_arm::do_finalize_sections): Define special EXIDX section
	symbols only if referenced.
	* gc.h (Garbage_collection::add_reference): New method.
	(gc_process_relocs): Use Garbage_collection::add_reference to avoid
	code duplication.
@
text
@d31 1
a48 2
typedef std::pair<Object *, unsigned int> Section_id;

a50 6
  struct Section_id_hash
  {
    size_t operator()(const Section_id& loc) const
    { return reinterpret_cast<uintptr_t>(loc.first) ^ loc.second; }
  };

@


1.7
log
@	* gc.h (Garbage_collection::Cident_section_map): New typedef.
	(Garbage_collection::cident_sections): New function.
	(Garbage_collection::add_cident_section): New function.
	(Garbage_collection::cident_sections_): New member.
	(gc_process_relocs): Add references to sections whose names are C
	identifiers.
	* gold.h (cident_section_start_prefix): New constant.
	(cident_section_stop_prefix): New constant.
	(is_cident): New function.
	* layout.cc (Layout::define_section_symbols): Replace string constants
	with the newly defined constants.
	* object.cc (Sized_relobj::do_layout): Track sections whose names are
	C identifiers.
	* testsuite/Makefile.am: Add gc_orphan_section_test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/gc_orphan_section_test.cc: New file.
	* testsuite/gc_orphan_section_test.sh: New file.
@
text
@d111 15
d279 1
a279 13
          Section_id src_id(src_obj, src_indx);
          Section_id dst_id(dst_obj, dst_indx);
          Garbage_collection::Section_ref::iterator map_it;
          map_it = symtab->gc()->section_reloc_map().find(src_id);
          if (map_it == symtab->gc()->section_reloc_map().end())
            {
              symtab->gc()->section_reloc_map()[src_id].insert(dst_id);
            }
          else
            {
              Garbage_collection::Sections_reachable& v(map_it->second);
              v.insert(dst_id);
            }
d286 1
@


1.6
log
@	* gc.h (gc_process_relocs): Call is_section_foldable_candidate to
	check for .text or .gnu.linkonce.t sections.
	* icf.cc (Icf::find_identical_sections): Ditto.
	Change the detection for mangled function name within the section
	name.
	* icf.h (is_section_foldable_candidate): New function.
@
text
@d63 4
d101 10
d117 1
d179 1
d237 13
d277 17
@


1.5
log
@	* object.h (class Relobj): Drop options parameter from
	gc_process_relocs, scan_relocs, relocate, do_gc_process_relocs,
	do_scan_relocs, do_relocate.  Change all callers.
	(class Sized_relobj): Drop options parameters from
	do_gc_process_relocs, do_scan_relocs, do_relocate,
	do_relocate_sections, relocate_sections, emit_relocs_scan,
	emit_relocs_scan_reltype.  Change all callers.
	(struct Relocate_info): Remove options field and all references to
	it.
	* reloc.h (class Read_relocs): Remove options constructor
	parameter and options_ field.  Change all callers.
	(class Gc_process_relocs, class Scan_relocs): Likewise.
	(class Relocate_task): Likewise.
	* target-reloc.h (scan_relocs): Remove options parameter.  Change
	all callers.
	(scan_relocatable_relocs): Likewise.
	* target.h (class Sized_target): Remove options parameter from
	gc_process_relocs, scan_relocs, scan_relocatable_relocs.  Change
	all callers.
	* gc.h (gc_process_relocs): Remove options parameter.  Change all
	callers.
	* arm.cc: Update functions to remove options parameters.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* testsuite/testfile.cc: Likewise.
@
text
@d3 1
a3 1
// Copyright 2009 Free Software Foundation, Inc.
d166 1
a166 1
      && is_prefix_of(".text.", (src_obj)->section_name(src_indx).c_str()))
@


1.4
log
@	* gc.h (gc_process_relocs): Check if icf is enabled using new
	function.
	* gold.cc (queue_initial_tasks): Likewise.
	(queue_middle_tasks): Likewise.
	* object.cc (do_layout): Likewise.
	* symtab.cc (is_section_folded): Likewise.
	* main.cc (main): Likewise.
	* reloc.cc (Read_relocs::run): Likewise.
	(Sized_relobj::do_scan_relocs): Likewise.
	* icf.cc (is_function_ctor_or_dtor): New function.
	(Icf::find_identical_sections): Check if function is ctor or dtor when
	safe icf is chosen.
	* options.h (General_options::icf): Change option to be an enum.
	(Icf_status): New enum.
	(icf_enabled): New method.
	(icf_safe_folding): New method.
	(set_icf_status): New method.
	(icf_status_): New variable.
	* (options.cc) (General_options::finalize): Set icf_status_.
	* testsuite/Makefile.am: Add commands to build icf_safe_test. Modify
	icf_test and icf_keep_unique_test to use the --icf enum flag.
	* testsuite/icf_safe_test.sh: New file.
	* testsuite/icf_safe_test.cc: New file.
@
text
@a140 1
    const General_options& ,
@


1.3
log
@	* symtab.h: Check for GOLD_SYMTAB_H before header includes. Remove
	includes to gc.h and icf.h.
	* arm.cc: Include gc.h.
	* gold.cc: Likewise.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* gc.h: Include icf.h.
@
text
@d166 1
a166 1
  if (parameters->options().icf()
@


1.2
log
@*** empty log message ***
@
text
@d31 1
@


1.2.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a30 1
#include "icf.h"
d165 1
a165 1
  if (parameters->options().icf_enabled()
@


1.1
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d27 1
d57 2
d63 39
a101 35
  public :  
    Garbage_collection() 
      :is_worklist_ready_(false)
    { }

    // Accessor methods for the private members.

    Sections_reachable&
    referenced_list()
    { return referenced_list_; }

    Section_ref&
    section_reloc_map()
    { return section_reloc_map_; }

    Worklist_type&
    worklist()
    { return work_list_; }
 
    bool
    is_worklist_ready()
    { return is_worklist_ready_; }

    void
    worklist_ready()
    { is_worklist_ready_ = true; }

    void
    do_transitive_closure();

  private :
    Worklist_type work_list_;
    bool is_worklist_ready_;
    Section_ref section_reloc_map_;
    Sections_reachable referenced_list_;
d130 5
a134 4
// This function implements the  the generic part of reloc 
// processing to map a section to all the sections it 
// references through relocs.  It is used only during garbage 
// collection.
d144 2
a145 2
    Sized_relobj<size, big_endian>* object,
    unsigned int data_shndx,
d153 2
a154 2
  Object *src_obj, *dst_obj;
  unsigned int src_indx, dst_indx;
a155 3
  src_obj = object;
  src_indx = data_shndx; 
  
d160 15
d180 3
a182 1
      
d190 2
a191 2
          shndx = object->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
          if (!is_ordinary) 
d194 11
a204 1
          if (shndx == src_indx) 
a205 1
          dst_indx = shndx;
d209 1
a209 1
          Symbol* gsym = object->global_symbol(r_sym);
d220 12
d233 1
a233 9
      Section_id p1(src_obj, src_indx);
      Section_id p2(dst_obj, dst_indx);
      Garbage_collection::Section_ref::iterator map_it;
      map_it = symtab->gc()->section_reloc_map().find(p1);
      if (map_it == symtab->gc()->section_reloc_map().end())
        {
          symtab->gc()->section_reloc_map()[p1].insert(p2);
        }
      else
d235 13
a247 2
          Garbage_collection::Sections_reachable& v(map_it->second);
          v.insert(p2);
@

