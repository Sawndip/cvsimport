head	1.34;
access;
symbols
	binutils-2_24-branch:1.33.0.2
	binutils-2_24-branchpoint:1.33
	binutils-2_21_1:1.13
	binutils-2_23_2:1.32
	binutils-2_23_1:1.32
	binutils-2_23:1.32
	binutils-2_23-branch:1.32.0.2
	binutils-2_23-branchpoint:1.32
	binutils-2_22_branch:1.28.0.4
	binutils-2_22:1.28
	binutils-2_22-branch:1.28.0.2
	binutils-2_22-branchpoint:1.28
	binutils-2_21:1.13
	binutils-2_21-branch:1.13.0.2
	binutils-2_21-branchpoint:1.13
	binutils-2_20_1:1.4.2.1
	binutils-2_20:1.4.2.1
	binutils-2_20-branch:1.4.0.2
	binutils-2_20-branchpoint:1.4
	dje-cgen-play1-branch:1.2.0.2
	dje-cgen-play1-branchpoint:1.2
	binutils_latest_snapshot:1.34;
locks; strict;
comment	@ * @;


1.34
date	2013.10.11.21.11.49;	author roland;	state Exp;
branches;
next	1.33;

1.33
date	2012.09.12.18.29.18;	author ian;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2012.04.24.22.05.28;	author ccoutant;	state Exp;
branches;
next	1.31;

1.31
date	2012.03.21.19.02.21;	author ccoutant;	state Exp;
branches;
next	1.30;

1.30
date	2011.12.19.21.07.16;	author ian;	state Exp;
branches;
next	1.29;

1.29
date	2011.10.10.17.38.07;	author ccoutant;	state Exp;
branches;
next	1.28;

1.28
date	2011.09.19.19.29.55;	author ccoutant;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2011.09.18.15.06.28;	author ccoutant;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.06.22.07.59;	author ccoutant;	state Exp;
branches;
next	1.25;

1.25
date	2011.06.08.03.50.11;	author ccoutant;	state Exp;
branches;
next	1.24;

1.24
date	2011.05.26.18.44.27;	author ccoutant;	state Exp;
branches;
next	1.23;

1.23
date	2011.05.24.21.57.28;	author ccoutant;	state Exp;
branches;
next	1.22;

1.22
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.21;

1.21
date	2011.05.23.23.27.10;	author ccoutant;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.25.20.28.48;	author ccoutant;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.22.22.39.55;	author ccoutant;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.12.00.44.47;	author ccoutant;	state Exp;
branches;
next	1.17;

1.17
date	2011.04.05.20.16.17;	author ccoutant;	state Exp;
branches;
next	1.16;

1.16
date	2011.03.30.21.07.13;	author ccoutant;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.30.01.31.57;	author ccoutant;	state Exp;
branches;
next	1.14;

1.14
date	2010.12.14.19.03.30;	author rwild;	state Exp;
branches;
next	1.13;

1.13
date	2010.08.27.18.00.58;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	2010.08.12.22.15.00;	author ccoutant;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.12.22.01.11;	author ccoutant;	state Exp;
branches;
next	1.10;

1.10
date	2009.12.14.19.53.04;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2009.12.03.15.43.01;	author espindola;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.25.00.10.05;	author espindola;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.09.22.38.07;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.09.16.40.51;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.01.17.32.35;	author ian;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2009.07.06.23.11.21;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.15.17.01.04;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.24.15.44.02;	author ian;	state Exp;
branches;
next	;

1.33.2.1
date	2013.10.11.21.23.43;	author roland;	state Exp;
branches;
next	;

1.28.2.1
date	2011.12.19.21.14.39;	author ian;	state Exp;
branches;
next	;

1.4.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	;


desc
@@


1.34
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@// inremental.h -- incremental linking support for gold   -*- C++ -*-

// Copyright 2009, 2010, 2011, 2012, 2013 Free Software Foundation, Inc.
// Written by Mikolaj Zalewski <mikolajz@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#ifndef GOLD_INCREMENTAL_H
#define GOLD_INCREMENTAL_H

#include <map>
#include <vector>

#include "elfcpp_file.h"
#include "stringpool.h"
#include "workqueue.h"
#include "fileread.h"
#include "output.h"
#include "archive.h"

namespace gold
{

class Input_argument;
class Incremental_inputs_checker;
class Incremental_script_entry;
class Incremental_object_entry;
class Incremental_dynobj_entry;
class Incremental_archive_entry;
class Incremental_inputs;
class Incremental_binary;
class Incremental_library;
class Object;

// Incremental input type as stored in .gnu_incremental_inputs.

enum Incremental_input_type
{
  INCREMENTAL_INPUT_OBJECT = 1,
  INCREMENTAL_INPUT_ARCHIVE_MEMBER = 2,
  INCREMENTAL_INPUT_ARCHIVE = 3,
  INCREMENTAL_INPUT_SHARED_LIBRARY = 4,
  INCREMENTAL_INPUT_SCRIPT = 5
};

// Incremental input file flags.
// The input file type is stored in the lower eight bits.

enum Incremental_input_flags
{
  INCREMENTAL_INPUT_IN_SYSTEM_DIR = 0x8000,
  INCREMENTAL_INPUT_AS_NEEDED = 0x4000
};

// Symbol flags for the incremental symbol table.
// These flags are stored in the top two bits of
// the symbol index field.

enum Incremental_shlib_symbol_flags
{
  // Symbol is defined in this library.
  INCREMENTAL_SHLIB_SYM_DEF = 2,
  // Symbol is defined in this library, with a COPY relocation.
  INCREMENTAL_SHLIB_SYM_COPY = 3
};

static const int INCREMENTAL_SHLIB_SYM_FLAGS_SHIFT = 30;

// Return TRUE if a section of type SH_TYPE can be updated in place
// during an incremental update.
bool
can_incremental_update(unsigned int sh_type);

// Create an Incremental_binary object for FILE. Returns NULL is this is not
// possible, e.g. FILE is not an ELF file or has an unsupported target.

Incremental_binary*
open_incremental_binary(Output_file* file);

// Base class for recording each input file.

class Incremental_input_entry
{
 public:
  Incremental_input_entry(Stringpool::Key filename_key, unsigned int arg_serial,
			  Timespec mtime)
    : filename_key_(filename_key), file_index_(0), offset_(0), info_offset_(0),
      arg_serial_(arg_serial), mtime_(mtime), is_in_system_directory_(false),
      as_needed_(false)
  { }

  virtual
  ~Incremental_input_entry()
  { }

  // Return the type of input file.
  Incremental_input_type
  type() const
  { return this->do_type(); }

  // Set the index and section offset of this input file entry.
  void
  set_offset(unsigned int file_index, unsigned int offset)
  {
    this->file_index_ = file_index;
    this->offset_ = offset;
  }

  // Set the section offset of the supplemental information for this entry.
  void
  set_info_offset(unsigned int info_offset)
  { this->info_offset_ = info_offset; }

  // Get the index of this input file entry.
  unsigned int
  get_file_index() const
  { return this->file_index_; }

  // Get the section offset of this input file entry.
  unsigned int
  get_offset() const
  { return this->offset_; }

  // Get the section offset of the supplemental information for this entry.
  unsigned int
  get_info_offset() const
  { return this->info_offset_; }

  // Get the stringpool key for the input filename.
  Stringpool::Key
  get_filename_key() const
  { return this->filename_key_; }

  // Get the serial number of the input file.
  unsigned int
  arg_serial() const
  { return this->arg_serial_; }

  // Get the modification time of the input file.
  const Timespec&
  get_mtime() const
  { return this->mtime_; }

  // Record that the file was found in a system directory.
  void
  set_is_in_system_directory()
  { this->is_in_system_directory_ = true; }

  // Return TRUE if the file was found in a system directory.
  bool
  is_in_system_directory() const
  { return this->is_in_system_directory_; }

  // Record that the file was linked with --as-needed.
  void
  set_as_needed()
  { this->as_needed_ = true; }

  // Return TRUE if the file was linked with --as-needed.
  bool
  as_needed() const
  { return this->as_needed_; }

  // Return a pointer to the derived Incremental_script_entry object.
  // Return NULL for input entries that are not script files.
  Incremental_script_entry*
  script_entry()
  { return this->do_script_entry(); }

  // Return a pointer to the derived Incremental_object_entry object.
  // Return NULL for input entries that are not object files.
  Incremental_object_entry*
  object_entry()
  { return this->do_object_entry(); }

  // Return a pointer to the derived Incremental_dynobj_entry object.
  // Return NULL for input entries that are not shared object files.
  Incremental_dynobj_entry*
  dynobj_entry()
  { return this->do_dynobj_entry(); }

  // Return a pointer to the derived Incremental_archive_entry object.
  // Return NULL for input entries that are not archive files.
  Incremental_archive_entry*
  archive_entry()
  { return this->do_archive_entry(); }

 protected:
  // Return the type of input file.
  virtual Incremental_input_type
  do_type() const = 0;

  // Return a pointer to the derived Incremental_script_entry object.
  // Return NULL for input entries that are not script files.
  virtual Incremental_script_entry*
  do_script_entry()
  { return NULL; }

  // Return a pointer to the derived Incremental_object_entry object.
  // Return NULL for input entries that are not object files.
  virtual Incremental_object_entry*
  do_object_entry()
  { return NULL; }

  // Return a pointer to the derived Incremental_dynobj_entry object.
  // Return NULL for input entries that are not shared object files.
  virtual Incremental_dynobj_entry*
  do_dynobj_entry()
  { return NULL; }

  // Return a pointer to the derived Incremental_archive_entry object.
  // Return NULL for input entries that are not archive files.
  virtual Incremental_archive_entry*
  do_archive_entry()
  { return NULL; }

 private:
  // Key of the filename string in the section stringtable.
  Stringpool::Key filename_key_;

  // Index of the entry in the output section.
  unsigned int file_index_;

  // Offset of the entry in the output section.
  unsigned int offset_;

  // Offset of the extra information in the output section.
  unsigned int info_offset_;

  // Serial number of the file in the argument list.
  unsigned int arg_serial_;

  // Last modification time of the file.
  Timespec mtime_;

  // TRUE if the file was found in a system directory.
  bool is_in_system_directory_;

  // TRUE if the file was linked with --as-needed.
  bool as_needed_;
};

// Information about a script input that will persist during the whole linker
// run.  Needed only during an incremental build to retrieve the input files
// added by this script.

class Script_info
{
 public:
  Script_info(const std::string& filename)
    : filename_(filename), input_file_index_(0),
      incremental_script_entry_(NULL)
  { }

  Script_info(const std::string& filename, unsigned int input_file_index)
    : filename_(filename), input_file_index_(input_file_index),
      incremental_script_entry_(NULL)
  { }

  // Store a pointer to the incremental information for this script.
  void
  set_incremental_info(Incremental_script_entry* entry)
  { this->incremental_script_entry_ = entry; }

  // Return the filename.
  const std::string&
  filename() const
  { return this->filename_; }

  // Return the input file index.
  unsigned int
  input_file_index() const
  { return this->input_file_index_; }

  // Return the pointer to the incremental information for this script.
  Incremental_script_entry*
  incremental_info() const
  { return this->incremental_script_entry_; }

 private:
  const std::string filename_;
  unsigned int input_file_index_;
  Incremental_script_entry* incremental_script_entry_;
};

// Class for recording input scripts.

class Incremental_script_entry : public Incremental_input_entry
{
 public:
  Incremental_script_entry(Stringpool::Key filename_key,
			   unsigned int arg_serial, Script_info* /*script*/,
			   Timespec mtime)
    : Incremental_input_entry(filename_key, arg_serial, mtime),
      objects_()
  { }

  // Add a member object to the archive.
  void
  add_object(Incremental_input_entry* obj_entry)
  {
    this->objects_.push_back(obj_entry);
  }

  // Return the number of objects included by this script.
  unsigned int
  get_object_count()
  { return this->objects_.size(); }

  // Return the Nth object.
  Incremental_input_entry*
  get_object(unsigned int n)
  {
    gold_assert(n < this->objects_.size());
    return this->objects_[n];
  }

 protected:
  virtual Incremental_input_type
  do_type() const
  { return INCREMENTAL_INPUT_SCRIPT; }

  // Return a pointer to the derived Incremental_script_entry object.
  virtual Incremental_script_entry*
  do_script_entry()
  { return this; }

 private:
  // Objects that have been included by this script.
  std::vector<Incremental_input_entry*> objects_;
};

// Class for recording input object files.

class Incremental_object_entry : public Incremental_input_entry
{
 public:
  Incremental_object_entry(Stringpool::Key filename_key, Object* obj,
			   unsigned int arg_serial, Timespec mtime)
    : Incremental_input_entry(filename_key, arg_serial, mtime), obj_(obj),
      is_member_(false), sections_(), groups_()
  { this->sections_.reserve(obj->shnum()); }

  // Get the object.
  Object*
  object() const
  { return this->obj_; }

  // Record that this object is an archive member.
  void
  set_is_member()
  { this->is_member_ = true; }

  // Return true if this object is an archive member.
  bool
  is_member() const
  { return this->is_member_; }

  // Add an input section.
  void
  add_input_section(unsigned int shndx, Stringpool::Key name_key, off_t sh_size)
  { this->sections_.push_back(Input_section(shndx, name_key, sh_size)); }

  // Return the number of input sections in this object.
  unsigned int
  get_input_section_count() const
  { return this->sections_.size(); }

  // Return the input section index for the Nth input section.
  Stringpool::Key
  get_input_section_index(unsigned int n) const
  { return this->sections_[n].shndx_; }

  // Return the stringpool key of the Nth input section.
  Stringpool::Key
  get_input_section_name_key(unsigned int n) const
  { return this->sections_[n].name_key_; }

  // Return the size of the Nth input section.
  off_t
  get_input_section_size(unsigned int n) const
  { return this->sections_[n].sh_size_; }

  // Add a kept COMDAT group.
  void
  add_comdat_group(Stringpool::Key signature_key)
  { this->groups_.push_back(signature_key); }

  // Return the number of COMDAT groups.
  unsigned int
  get_comdat_group_count() const
  { return this->groups_.size(); }

  // Return the stringpool key for the signature of the Nth comdat group.
  Stringpool::Key
  get_comdat_signature_key(unsigned int n) const
  { return this->groups_[n]; }

 protected:
  virtual Incremental_input_type
  do_type() const
  {
    return (this->is_member_
	    ? INCREMENTAL_INPUT_ARCHIVE_MEMBER
	    : INCREMENTAL_INPUT_OBJECT);
  }

  // Return a pointer to the derived Incremental_object_entry object.
  virtual Incremental_object_entry*
  do_object_entry()
  { return this; }

 private:
  // The object file itself.
  Object* obj_;

  // Whether this object is an archive member.
  bool is_member_;

  // Input sections.
  struct Input_section
  {
    Input_section(unsigned int shndx, Stringpool::Key name_key, off_t sh_size)
      : shndx_(shndx), name_key_(name_key), sh_size_(sh_size)
    { }
    unsigned int shndx_;
    Stringpool::Key name_key_;
    off_t sh_size_;
  };
  std::vector<Input_section> sections_;

  // COMDAT groups.
  std::vector<Stringpool::Key> groups_;
};

// Class for recording shared library input files.

class Incremental_dynobj_entry : public Incremental_input_entry
{
 public:
  Incremental_dynobj_entry(Stringpool::Key filename_key,
  			   Stringpool::Key soname_key, Object* obj,
			   unsigned int arg_serial, Timespec mtime)
    : Incremental_input_entry(filename_key, arg_serial, mtime),
      soname_key_(soname_key), obj_(obj)
  { }

  // Get the object.
  Object*
  object() const
  { return this->obj_; }

  // Get the stringpool key for the soname.
  Stringpool::Key
  get_soname_key() const
  { return this->soname_key_; }

 protected:
  virtual Incremental_input_type
  do_type() const
  { return INCREMENTAL_INPUT_SHARED_LIBRARY; }

  // Return a pointer to the derived Incremental_dynobj_entry object.
  virtual Incremental_dynobj_entry*
  do_dynobj_entry()
  { return this; }

 private:
  // Key of the soname string in the section stringtable.
  Stringpool::Key soname_key_;

  // The object file itself.
  Object* obj_;
};

// Class for recording archive library input files.

class Incremental_archive_entry : public Incremental_input_entry
{
 public:
  Incremental_archive_entry(Stringpool::Key filename_key,
			    unsigned int arg_serial, Timespec mtime)
    : Incremental_input_entry(filename_key, arg_serial, mtime), members_(),
      unused_syms_()
  { }

  // Add a member object to the archive.
  void
  add_object(Incremental_object_entry* obj_entry)
  {
    this->members_.push_back(obj_entry);
    obj_entry->set_is_member();
  }

  // Add an unused global symbol to the archive.
  void
  add_unused_global_symbol(Stringpool::Key symbol_key)
  { this->unused_syms_.push_back(symbol_key); }

  // Return the number of member objects included in the link.
  unsigned int
  get_member_count()
  { return this->members_.size(); }

  // Return the Nth member object.
  Incremental_object_entry*
  get_member(unsigned int n)
  { return this->members_[n]; }

  // Return the number of unused global symbols in this archive.
  unsigned int
  get_unused_global_symbol_count()
  { return this->unused_syms_.size(); }

  // Return the Nth unused global symbol.
  Stringpool::Key
  get_unused_global_symbol(unsigned int n)
  { return this->unused_syms_[n]; }

 protected:
  virtual Incremental_input_type
  do_type() const
  { return INCREMENTAL_INPUT_ARCHIVE; }

  // Return a pointer to the derived Incremental_archive_entry object.
  virtual Incremental_archive_entry*
  do_archive_entry()
  { return this; }

 private:
  // Members of the archive that have been included in the link.
  std::vector<Incremental_object_entry*> members_;

  // Unused global symbols from this archive.
  std::vector<Stringpool::Key> unused_syms_;
};

// This class contains the information needed during an incremental
// build about the inputs necessary to build the .gnu_incremental_inputs.

class Incremental_inputs
{
 public:
  typedef std::vector<Incremental_input_entry*> Input_list;

  Incremental_inputs()
    : inputs_(), command_line_(), command_line_key_(0),
      strtab_(new Stringpool()), current_object_(NULL),
      current_object_entry_(NULL), inputs_section_(NULL),
      symtab_section_(NULL), relocs_section_(NULL),
      reloc_count_(0)
  { }

  ~Incremental_inputs() { delete this->strtab_; }

  // Record the command line.
  void
  report_command_line(int argc, const char* const* argv);

  // Record the initial info for archive file ARCHIVE.
  void
  report_archive_begin(Library_base* arch, unsigned int arg_serial,
		       Script_info* script_info);

  // Record the final info for archive file ARCHIVE.
  void
  report_archive_end(Library_base* arch);

  // Record the info for object file OBJ.  If ARCH is not NULL,
  // attach the object file to the archive.
  void
  report_object(Object* obj, unsigned int arg_serial, Library_base* arch,
		Script_info* script_info);

  // Record an input section belonging to object file OBJ.
  void
  report_input_section(Object* obj, unsigned int shndx, const char* name,
		       off_t sh_size);

  // Record a kept COMDAT group belonging to object file OBJ.
  void
  report_comdat_group(Object* obj, const char* name);

  // Record the info for input script SCRIPT.
  void
  report_script(Script_info* script, unsigned int arg_serial,
		Timespec mtime);

  // Return the running count of incremental relocations.
  unsigned int
  get_reloc_count() const
  { return this->reloc_count_; }

  // Update the running count of incremental relocations.
  void
  set_reloc_count(unsigned int count)
  { this->reloc_count_ = count; }

  // Prepare for layout.  Called from Layout::finalize.
  void
  finalize();

  // Create the .gnu_incremental_inputs and related sections.
  void
  create_data_sections(Symbol_table* symtab);

  // Return the .gnu_incremental_inputs section.
  Output_section_data*
  inputs_section() const
  { return this->inputs_section_; }

  // Return the .gnu_incremental_symtab section.
  Output_data_space*
  symtab_section() const
  { return this->symtab_section_; }

  // Return the .gnu_incremental_relocs section.
  Output_data_space*
  relocs_section() const
  { return this->relocs_section_; }

  // Return the .gnu_incremental_got_plt section.
  Output_data_space*
  got_plt_section() const
  { return this->got_plt_section_; }

  // Return the .gnu_incremental_strtab stringpool.
  Stringpool*
  get_stringpool() const
  { return this->strtab_; }

  // Return the canonical form of the command line, as will be stored in
  // .gnu_incremental_strtab.
  const std::string&
  command_line() const
  { return this->command_line_; }

  // Return the stringpool key of the command line.
  Stringpool::Key
  command_line_key() const
  { return this->command_line_key_; }

  // Return the number of input files.
  int
  input_file_count() const
  { return this->inputs_.size(); }

  // Return the input files.
  const Input_list&
  input_files() const
  { return this->inputs_; }

  // Return the sh_entsize value for the .gnu_incremental_relocs section.
  unsigned int
  relocs_entsize() const;

 private:
  // The list of input files.
  Input_list inputs_;

  // Canonical form of the command line, as will be stored in
  // .gnu_incremental_strtab.
  std::string command_line_;

  // The key of the command line string in the string pool.
  Stringpool::Key command_line_key_;

  // The .gnu_incremental_strtab string pool associated with the
  // .gnu_incremental_inputs.
  Stringpool* strtab_;

  // Keep track of the object currently being processed.
  Object* current_object_;
  Incremental_object_entry* current_object_entry_;

  // The .gnu_incremental_inputs section.
  Output_section_data* inputs_section_;

  // The .gnu_incremental_symtab section.
  Output_data_space* symtab_section_;

  // The .gnu_incremental_relocs section.
  Output_data_space* relocs_section_;

  // The .gnu_incremental_got_plt section.
  Output_data_space* got_plt_section_;

  // Total count of incremental relocations.  Updated during Scan_relocs
  // phase at the completion of each object file.
  unsigned int reloc_count_;
};

// Reader class for global symbol info from an object file entry in
// the .gnu_incremental_inputs section.

template<bool big_endian>
class Incremental_global_symbol_reader
{
 private:
  typedef elfcpp::Swap<32, big_endian> Swap32;

 public:
  Incremental_global_symbol_reader(const unsigned char* p)
    : p_(p)
  { }

  unsigned int
  output_symndx() const
  { return Swap32::readval(this->p_); }

  unsigned int
  shndx() const
  { return Swap32::readval(this->p_ + 4); }

  unsigned int
  next_offset() const
  { return Swap32::readval(this->p_ + 8); }

  unsigned int
  reloc_count() const
  { return Swap32::readval(this->p_ + 12); }

  unsigned int
  reloc_offset() const
  { return Swap32::readval(this->p_ + 16); }

 private:
  // Base address of the symbol entry.
  const unsigned char* p_;
};

// Reader class for .gnu_incremental_inputs section.

template<int size, bool big_endian>
class Incremental_inputs_reader
{
 private:
  typedef elfcpp::Swap<size, big_endian> Swap;
  typedef elfcpp::Swap<16, big_endian> Swap16;
  typedef elfcpp::Swap<32, big_endian> Swap32;
  typedef elfcpp::Swap<64, big_endian> Swap64;

 public:
  // Size of the .gnu_incremental_inputs header.
  // (3 x 4-byte fields, plus 4 bytes padding.)
  static const unsigned int header_size = 16;
  // Size of an input file entry.
  // (2 x 4-byte fields, 1 x 12-byte field, 2 x 2-byte fields.)
  static const unsigned int input_entry_size = 24;
  // Size of the first part of the supplemental info block for
  // relocatable objects and archive members.
  // (7 x 4-byte fields, plus 4 bytes padding.)
  static const unsigned int object_info_size = 32;
  // Size of an input section entry.
  // (2 x 4-byte fields, 2 x address-sized fields.)
  static const unsigned int input_section_entry_size = 8 + 2 * size / 8;
  // Size of a global symbol entry in the supplemental info block.
  // (5 x 4-byte fields.)
  static const unsigned int global_sym_entry_size = 20;

  Incremental_inputs_reader()
    : p_(NULL), strtab_(NULL, 0), input_file_count_(0)
  { }

  Incremental_inputs_reader(const unsigned char* p,
			    const elfcpp::Elf_strtab& strtab)
    : p_(p), strtab_(strtab)
  { this->input_file_count_ = Swap32::readval(this->p_ + 4); }

  // Return the version number.
  unsigned int
  version() const
  { return Swap32::readval(this->p_); }

  // Return the count of input file entries.
  unsigned int
  input_file_count() const
  { return this->input_file_count_; }

  // Return the command line.
  const char*
  command_line() const
  {
    unsigned int offset = Swap32::readval(this->p_ + 8);
    return this->get_string(offset);
  }

  // Reader class for an input file entry and its supplemental info.
  class Incremental_input_entry_reader
  {
   private:
    static const unsigned int object_info_size =
	Incremental_inputs_reader<size, big_endian>::object_info_size;
    static const unsigned int input_section_entry_size =
	Incremental_inputs_reader<size, big_endian>::input_section_entry_size;
    static const unsigned int global_sym_entry_size =
	Incremental_inputs_reader<size, big_endian>::global_sym_entry_size;

   public:
    Incremental_input_entry_reader(const Incremental_inputs_reader* inputs,
				   unsigned int offset)
      : inputs_(inputs), offset_(offset)
    {
      this->info_offset_ = Swap32::readval(inputs->p_ + offset + 4);
      this->flags_ = Swap16::readval(this->inputs_->p_ + offset + 20);
    }

    // Return the filename.
    const char*
    filename() const
    {
      unsigned int offset = Swap32::readval(this->inputs_->p_ + this->offset_);
      return this->inputs_->get_string(offset);
    }

    // Return the argument serial number.
    unsigned int
    arg_serial() const
    {
      return Swap16::readval(this->inputs_->p_ + this->offset_ + 22);
    }

    // Return the timestamp.
    Timespec
    get_mtime() const
    {
      Timespec t;
      const unsigned char* p = this->inputs_->p_ + this->offset_ + 8;
      t.seconds = Swap64::readval(p);
      t.nanoseconds = Swap32::readval(p+8);
      return t;
    }

    // Return the type of input file.
    Incremental_input_type
    type() const
    { return static_cast<Incremental_input_type>(this->flags_ & 0xff); }

    // Return TRUE if the file was found in a system directory.
    bool
    is_in_system_directory() const
    { return (this->flags_ & INCREMENTAL_INPUT_IN_SYSTEM_DIR) != 0; }

    // Return TRUE if the file was linked with --as-needed.
    bool
    as_needed() const
    { return (this->flags_ & INCREMENTAL_INPUT_AS_NEEDED) != 0; }

    // Return the input section count -- for objects only.
    unsigned int
    get_input_section_count() const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_OBJECT
		  || this->type() == INCREMENTAL_INPUT_ARCHIVE_MEMBER);
      return Swap32::readval(this->inputs_->p_ + this->info_offset_);
    }

    // Return the soname -- for shared libraries only.
    const char*
    get_soname() const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_SHARED_LIBRARY);
      unsigned int offset = Swap32::readval(this->inputs_->p_
					    + this->info_offset_);
      return this->inputs_->get_string(offset);
    }

    // Return the offset of the supplemental info for symbol SYMNDX --
    // for objects only.
    unsigned int
    get_symbol_offset(unsigned int symndx) const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_OBJECT
		  || this->type() == INCREMENTAL_INPUT_ARCHIVE_MEMBER);

      unsigned int section_count = this->get_input_section_count();
      return (this->info_offset_
	      + this->object_info_size
	      + section_count * this->input_section_entry_size
	      + symndx * this->global_sym_entry_size);
    }

    // Return the global symbol count -- for objects & shared libraries only.
    unsigned int
    get_global_symbol_count() const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_OBJECT
		  || this->type() == INCREMENTAL_INPUT_ARCHIVE_MEMBER
		  || this->type() == INCREMENTAL_INPUT_SHARED_LIBRARY);
      return Swap32::readval(this->inputs_->p_ + this->info_offset_ + 4);
    }

    // Return the offset of the first local symbol -- for objects only.
    unsigned int
    get_local_symbol_offset() const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_OBJECT
		  || this->type() == INCREMENTAL_INPUT_ARCHIVE_MEMBER);

      return Swap32::readval(this->inputs_->p_ + this->info_offset_ + 8);
    }

    // Return the local symbol count -- for objects only.
    unsigned int
    get_local_symbol_count() const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_OBJECT
		  || this->type() == INCREMENTAL_INPUT_ARCHIVE_MEMBER);

      return Swap32::readval(this->inputs_->p_ + this->info_offset_ + 12);
    }

    // Return the index of the first dynamic relocation -- for objects only.
    unsigned int
    get_first_dyn_reloc() const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_OBJECT
		  || this->type() == INCREMENTAL_INPUT_ARCHIVE_MEMBER);

      return Swap32::readval(this->inputs_->p_ + this->info_offset_ + 16);
    }

    // Return the dynamic relocation count -- for objects only.
    unsigned int
    get_dyn_reloc_count() const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_OBJECT
		  || this->type() == INCREMENTAL_INPUT_ARCHIVE_MEMBER);

      return Swap32::readval(this->inputs_->p_ + this->info_offset_ + 20);
    }

    // Return the COMDAT group count -- for objects only.
    unsigned int
    get_comdat_group_count() const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_OBJECT
		  || this->type() == INCREMENTAL_INPUT_ARCHIVE_MEMBER);

      return Swap32::readval(this->inputs_->p_ + this->info_offset_ + 24);
    }

    // Return the object count -- for scripts only.
    unsigned int
    get_object_count() const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_SCRIPT);
      return Swap32::readval(this->inputs_->p_ + this->info_offset_);
    }

    // Return the input file offset for object N -- for scripts only.
    unsigned int
    get_object_offset(unsigned int n) const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_SCRIPT);
      return Swap32::readval(this->inputs_->p_ + this->info_offset_
			     + 4 + n * 4);
    }

    // Return the member count -- for archives only.
    unsigned int
    get_member_count() const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_ARCHIVE);
      return Swap32::readval(this->inputs_->p_ + this->info_offset_);
    }

    // Return the unused symbol count -- for archives only.
    unsigned int
    get_unused_symbol_count() const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_ARCHIVE);
      return Swap32::readval(this->inputs_->p_ + this->info_offset_ + 4);
    }

    // Return the input file offset for archive member N -- for archives only.
    unsigned int
    get_member_offset(unsigned int n) const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_ARCHIVE);
      return Swap32::readval(this->inputs_->p_ + this->info_offset_
			     + 8 + n * 4);
    }

    // Return the Nth unused global symbol -- for archives only.
    const char*
    get_unused_symbol(unsigned int n) const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_ARCHIVE);
      unsigned int member_count = this->get_member_count();
      unsigned int offset = Swap32::readval(this->inputs_->p_
					    + this->info_offset_ + 8
					    + member_count * 4
					    + n * 4);
      return this->inputs_->get_string(offset);
    }

    // Information about an input section.
    struct Input_section_info
    {
      const char* name;
      unsigned int output_shndx;
      off_t sh_offset;
      off_t sh_size;
    };

    // Return info about the Nth input section -- for objects only.
    Input_section_info
    get_input_section(unsigned int n) const
    {
      Input_section_info info;
      const unsigned char* p = (this->inputs_->p_
				+ this->info_offset_
				+ this->object_info_size
				+ n * this->input_section_entry_size);
      unsigned int name_offset = Swap32::readval(p);
      info.name = this->inputs_->get_string(name_offset);
      info.output_shndx = Swap32::readval(p + 4);
      info.sh_offset = Swap::readval(p + 8);
      info.sh_size = Swap::readval(p + 8 + size / 8);
      return info;
    }

    // Return info about the Nth global symbol -- for objects only.
    Incremental_global_symbol_reader<big_endian>
    get_global_symbol_reader(unsigned int n) const
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_OBJECT
		  || this->type() == INCREMENTAL_INPUT_ARCHIVE_MEMBER);
      unsigned int section_count = this->get_input_section_count();
      const unsigned char* p = (this->inputs_->p_
				+ this->info_offset_
				+ this->object_info_size
				+ section_count * this->input_section_entry_size
				+ n * this->global_sym_entry_size);
      return Incremental_global_symbol_reader<big_endian>(p);
    }

    // Return the signature of the Nth comdat group -- for objects only.
    const char*
    get_comdat_group_signature(unsigned int n) const
    {
      unsigned int section_count = this->get_input_section_count();
      unsigned int symbol_count = this->get_global_symbol_count();
      const unsigned char* p = (this->inputs_->p_
				+ this->info_offset_
				+ this->object_info_size
				+ section_count * this->input_section_entry_size
				+ symbol_count * this->global_sym_entry_size
				+ n * 4);
      unsigned int name_offset = Swap32::readval(p);
      return this->inputs_->get_string(name_offset);
    }

    // Return the output symbol index for the Nth global symbol -- for shared
    // libraries only.  Sets *IS_DEF to TRUE if the symbol is defined in this
    // input file.  Sets *IS_COPY to TRUE if the symbol was copied from this
    // input file with a COPY relocation.
    unsigned int
    get_output_symbol_index(unsigned int n, bool* is_def, bool* is_copy)
    {
      gold_assert(this->type() == INCREMENTAL_INPUT_SHARED_LIBRARY);
      const unsigned char* p = (this->inputs_->p_
				+ this->info_offset_ + 8
				+ n * 4);
      unsigned int output_symndx = Swap32::readval(p);
      unsigned int flags = output_symndx >> INCREMENTAL_SHLIB_SYM_FLAGS_SHIFT;
      output_symndx &= ((1U << INCREMENTAL_SHLIB_SYM_FLAGS_SHIFT) - 1);
      switch (flags)
	{
	  case INCREMENTAL_SHLIB_SYM_DEF:
	    *is_def = true;
	    *is_copy = false;
	    break;
	  case INCREMENTAL_SHLIB_SYM_COPY:
	    *is_def = true;
	    *is_copy = true;
	    break;
	  default:
	    *is_def = false;
	    *is_copy = false;
	}
      return output_symndx;
    }

   private:
    // The reader instance for the containing section.
    const Incremental_inputs_reader* inputs_;
    // The flags, including the type of input file.
    unsigned int flags_;
    // Section offset to the input file entry.
    unsigned int offset_;
    // Section offset to the supplemental info for the input file.
    unsigned int info_offset_;
  };

  // Return the offset of an input file entry given its index N.
  unsigned int
  input_file_offset(unsigned int n) const
  {
    gold_assert(n < this->input_file_count_);
    return this->header_size + n * this->input_entry_size;
  }

  // Return the index of an input file entry given its OFFSET.
  unsigned int
  input_file_index(unsigned int offset) const
  {
    int n = ((offset - this->header_size) / this->input_entry_size);
    gold_assert(input_file_offset(n) == offset);
    return n;
  }

  // Return a reader for the Nth input file entry.
  Incremental_input_entry_reader
  input_file(unsigned int n) const
  { return Incremental_input_entry_reader(this, this->input_file_offset(n)); }

  // Return a reader for the input file entry at OFFSET.
  Incremental_input_entry_reader
  input_file_at_offset(unsigned int offset) const
  {
    gold_assert(offset < (this->header_size
			  + this->input_file_count_ * this->input_entry_size));
    return Incremental_input_entry_reader(this, offset);
  }

  // Return a reader for the global symbol info at OFFSET.
  Incremental_global_symbol_reader<big_endian>
  global_symbol_reader_at_offset(unsigned int offset) const
  {
    const unsigned char* p = this->p_ + offset;
    return Incremental_global_symbol_reader<big_endian>(p);
  }

 private:
  // Lookup a string in the ELF string table.
  const char* get_string(unsigned int offset) const
  {
    const char* s;
    if (this->strtab_.get_c_string(offset, &s))
      return s;
    return NULL;
  }

  // Base address of the .gnu_incremental_inputs section.
  const unsigned char* p_;
  // The associated ELF string table.
  elfcpp::Elf_strtab strtab_;
  // The number of input file entries in this section.
  unsigned int input_file_count_;
};

// Reader class for the .gnu_incremental_symtab section.

template<bool big_endian>
class Incremental_symtab_reader
{
 public:
  Incremental_symtab_reader()
    : p_(NULL), len_(0)
  { }

  Incremental_symtab_reader(const unsigned char* p, off_t len)
    : p_(p), len_(len)
  { }

  // Return the count of symbols in this section.
  unsigned int
  symbol_count() const
  { return static_cast<unsigned int>(this->len_ / 4); }

  // Return the list head for symbol table entry N.
  unsigned int
  get_list_head(unsigned int n) const
  { return elfcpp::Swap<32, big_endian>::readval(this->p_ + 4 * n); }

 private:
  // Base address of the .gnu_incremental_relocs section.
  const unsigned char* p_;
  // Size of the section.
  off_t len_;
};

// Reader class for the .gnu_incremental_relocs section.

template<int size, bool big_endian>
class Incremental_relocs_reader
{
 private:
  // Size of each field.
  static const unsigned int field_size = size / 8;

 public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  typedef typename elfcpp::Elf_types<size>::Elf_Swxword Addend;

  // Size of each entry.
  static const unsigned int reloc_size = 8 + 2 * field_size;

  Incremental_relocs_reader()
    : p_(NULL), len_(0)
  { }

  Incremental_relocs_reader(const unsigned char* p, off_t len)
    : p_(p), len_(len)
  { }

  // Return the count of relocations in this section.
  unsigned int
  reloc_count() const
  { return static_cast<unsigned int>(this->len_ / reloc_size); }

  // Return the relocation type for relocation entry at offset OFF.
  unsigned int
  get_r_type(unsigned int off) const
  { return elfcpp::Swap<32, big_endian>::readval(this->p_ + off); }

  // Return the output section index for relocation entry at offset OFF.
  unsigned int
  get_r_shndx(unsigned int off) const
  { return elfcpp::Swap<32, big_endian>::readval(this->p_ + off + 4); }

  // Return the output section offset for relocation entry at offset OFF.
  Address
  get_r_offset(unsigned int off) const
  { return elfcpp::Swap<size, big_endian>::readval(this->p_ + off + 8); }

  // Return the addend for relocation entry at offset OFF.
  Addend
  get_r_addend(unsigned int off) const
  {
    return elfcpp::Swap<size, big_endian>::readval(this->p_ + off + 8
						   + this->field_size);
  }

  // Return a pointer to the relocation entry at offset OFF.
  const unsigned char*
  data(unsigned int off) const
  { return this->p_ + off; }

 private:
  // Base address of the .gnu_incremental_relocs section.
  const unsigned char* p_;
  // Size of the section.
  off_t len_;
};

// Reader class for the .gnu_incremental_got_plt section.

template<bool big_endian>
class Incremental_got_plt_reader
{
 public:
  Incremental_got_plt_reader()
    : p_(NULL), got_count_(0), got_desc_p_(NULL), plt_desc_p_(NULL)
  { }

  Incremental_got_plt_reader(const unsigned char* p) : p_(p)
  {
    this->got_count_ = elfcpp::Swap<32, big_endian>::readval(p);
    this->got_desc_p_ = p + 8 + ((this->got_count_ + 3) & ~3);
    this->plt_desc_p_ = this->got_desc_p_ + this->got_count_ * 8;
  }

  // Return the GOT entry count.
  unsigned int
  get_got_entry_count() const
  {
    return this->got_count_;
  }

  // Return the PLT entry count.
  unsigned int
  get_plt_entry_count() const
  {
    return elfcpp::Swap<32, big_endian>::readval(this->p_ + 4);
  }

  // Return the GOT type for GOT entry N.
  unsigned int
  get_got_type(unsigned int n)
  {
    return this->p_[8 + n];
  }

  // Return the symbol index for GOT entry N.
  unsigned int
  get_got_symndx(unsigned int n)
  {
    return elfcpp::Swap<32, big_endian>::readval(this->got_desc_p_ + n * 8);
  }

  // Return the input file index for GOT entry N.
  unsigned int
  get_got_input_index(unsigned int n)
  {
    return elfcpp::Swap<32, big_endian>::readval(this->got_desc_p_ + n * 8 + 4);
  }

  // Return the PLT descriptor for PLT entry N.
  unsigned int
  get_plt_desc(unsigned int n)
  {
    return elfcpp::Swap<32, big_endian>::readval(this->plt_desc_p_ + n * 4);
  }

 private:
  // Base address of the .gnu_incremental_got_plt section.
  const unsigned char* p_;
  // GOT entry count.
  unsigned int got_count_;
  // Base address of the GOT descriptor array.
  const unsigned char* got_desc_p_;
  // Base address of the PLT descriptor array.
  const unsigned char* plt_desc_p_;
};

// An object representing the ELF file we edit during an incremental build.
// Similar to Object or Dynobj, but operates on Output_file and contains
// methods to support incremental updating. This is the abstract parent class
// implemented in Sized_incremental_binary<size, big_endian> for a specific
// endianness and size.

class Incremental_binary
{
 public:
  Incremental_binary(Output_file* output, Target* /*target*/)
    : input_args_map_(), library_map_(), script_map_(),
      output_(output)
  { }

  virtual
  ~Incremental_binary()
  { }

  // Check the .gnu_incremental_inputs section to see whether an incremental
  // build is possible.
  bool
  check_inputs(const Command_line& cmdline,
	       Incremental_inputs* incremental_inputs)
  { return this->do_check_inputs(cmdline, incremental_inputs); }

  // Report an error.
  void
  error(const char* format, ...) const ATTRIBUTE_PRINTF_2;

  // Proxy class for a sized Incremental_input_entry_reader.

  class Input_reader
  {
   public:
    Input_reader()
    { }

    virtual
    ~Input_reader()
    { }

    const char*
    filename() const
    { return this->do_filename(); }

    Timespec
    get_mtime() const
    { return this->do_get_mtime(); }

    Incremental_input_type
    type() const
    { return this->do_type(); }

    unsigned int
    arg_serial() const
    { return this->do_arg_serial(); }

    unsigned int
    get_unused_symbol_count() const
    { return this->do_get_unused_symbol_count(); }

    const char*
    get_unused_symbol(unsigned int n) const
    { return this->do_get_unused_symbol(n); }

   protected:
    virtual const char*
    do_filename() const = 0;

    virtual Timespec
    do_get_mtime() const = 0;

    virtual Incremental_input_type
    do_type() const = 0;

    virtual unsigned int
    do_arg_serial() const = 0;

    virtual unsigned int
    do_get_unused_symbol_count() const = 0;

    virtual const char*
    do_get_unused_symbol(unsigned int n) const = 0;
  };

  // Return the number of input files.
  unsigned int
  input_file_count() const
  { return this->do_input_file_count(); }

  // Return an Input_reader for input file N.
  const Input_reader*
  get_input_reader(unsigned int n) const
  { return this->do_get_input_reader(n); }

  // Return TRUE if the input file N has changed since the last link.
  bool
  file_has_changed(unsigned int n) const
  { return this->do_file_has_changed(n); }

  // Return the Input_argument for input file N.  Returns NULL if
  // the Input_argument is not available.
  const Input_argument*
  get_input_argument(unsigned int n) const
  {
    const Input_reader* input_file = this->do_get_input_reader(n);
    unsigned int arg_serial = input_file->arg_serial();
    if (arg_serial == 0 || arg_serial > this->input_args_map_.size())
      return NULL;
    return this->input_args_map_[arg_serial - 1];
  }

  // Return an Incremental_library for the given input file.
  Incremental_library*
  get_library(unsigned int n) const
  { return this->library_map_[n]; }

  // Return a Script_info for the given input file.
  Script_info*
  get_script_info(unsigned int n) const
  { return this->script_map_[n]; }

  // Initialize the layout of the output file based on the existing
  // output file.
  void
  init_layout(Layout* layout)
  { this->do_init_layout(layout); }

  // Mark regions of the input file that must be kept unchanged.
  void
  reserve_layout(unsigned int input_file_index)
  { this->do_reserve_layout(input_file_index); }

  // Process the GOT and PLT entries from the existing output file.
  void
  process_got_plt(Symbol_table* symtab, Layout* layout)
  { this->do_process_got_plt(symtab, layout); }

  // Emit COPY relocations from the existing output file.
  void
  emit_copy_relocs(Symbol_table* symtab)
  { this->do_emit_copy_relocs(symtab); }

  // Apply incremental relocations for symbols whose values have changed.
  void
  apply_incremental_relocs(const Symbol_table* symtab, Layout* layout,
			   Output_file* of)
  { this->do_apply_incremental_relocs(symtab, layout, of); }

  // Functions and types for the elfcpp::Elf_file interface.  This
  // permit us to use Incremental_binary as the File template parameter for
  // elfcpp::Elf_file.

  // The View class is returned by view.  It must support a single
  // method, data().  This is trivial, because Output_file::get_output_view
  // does what we need.
  class View
  {
   public:
    View(const unsigned char* p)
      : p_(p)
    { }

    const unsigned char*
    data() const
    { return this->p_; }

   private:
    const unsigned char* p_;
  };

  // Return a View.
  View
  view(off_t file_offset, section_size_type data_size)
  { return View(this->output_->get_input_view(file_offset, data_size)); }

  // A location in the file.
  struct Location
  {
    off_t file_offset;
    off_t data_size;

    Location(off_t fo, section_size_type ds)
      : file_offset(fo), data_size(ds)
    { }

    Location()
      : file_offset(0), data_size(0)
    { }
  };

  // Get a View given a Location.
  View
  view(Location loc)
  { return View(this->view(loc.file_offset, loc.data_size)); }

  // Return the Output_file.
  Output_file*
  output_file()
  { return this->output_; }

 protected:
  // Check the .gnu_incremental_inputs section to see whether an incremental
  // build is possible.
  virtual bool
  do_check_inputs(const Command_line& cmdline,
		  Incremental_inputs* incremental_inputs) = 0;

  // Return TRUE if input file N has changed since the last incremental link.
  virtual bool
  do_file_has_changed(unsigned int n) const = 0;

  // Initialize the layout of the output file based on the existing
  // output file.
  virtual void
  do_init_layout(Layout* layout) = 0;

  // Mark regions of the input file that must be kept unchanged.
  virtual void
  do_reserve_layout(unsigned int input_file_index) = 0;

  // Process the GOT and PLT entries from the existing output file.
  virtual void
  do_process_got_plt(Symbol_table* symtab, Layout* layout) = 0;

  // Emit COPY relocations from the existing output file.
  virtual void
  do_emit_copy_relocs(Symbol_table* symtab) = 0;

  // Apply incremental relocations for symbols whose values have changed.
  virtual void
  do_apply_incremental_relocs(const Symbol_table*, Layout*, Output_file*) = 0;

  virtual unsigned int
  do_input_file_count() const = 0;

  virtual const Input_reader*
  do_get_input_reader(unsigned int) const = 0;

  // Map from input file index to Input_argument.
  std::vector<const Input_argument*> input_args_map_;
  // Map from an input file index to an Incremental_library.
  std::vector<Incremental_library*> library_map_;
  // Map from an input file index to a Script_info.
  std::vector<Script_info*> script_map_;

 private:
  // Edited output file object.
  Output_file* output_;
};

template<int size, bool big_endian>
class Sized_relobj_incr;

template<int size, bool big_endian>
class Sized_incremental_binary : public Incremental_binary
{
 public:
  Sized_incremental_binary(Output_file* output,
                           const elfcpp::Ehdr<size, big_endian>& ehdr,
                           Target* target)
    : Incremental_binary(output, target), elf_file_(this, ehdr),
      input_objects_(), section_map_(), symbol_map_(), copy_relocs_(),
      main_symtab_loc_(), main_strtab_loc_(), has_incremental_info_(false),
      inputs_reader_(), symtab_reader_(), relocs_reader_(), got_plt_reader_(),
      input_entry_readers_()
  { this->setup_readers(); }

  // Returns TRUE if the file contains incremental info.
  bool
  has_incremental_info() const
  { return this->has_incremental_info_; }

  // Record a pointer to the object for input file N.
  void
  set_input_object(unsigned int n,
		   Sized_relobj_incr<size, big_endian>* obj)
  { this->input_objects_[n] = obj; }

  // Return a pointer to the object for input file N.
  Sized_relobj_incr<size, big_endian>*
  input_object(unsigned int n) const
  {
    gold_assert(n < this->input_objects_.size());
    return this->input_objects_[n];
  }

  // Return the Output_section for section index SHNDX.
  Output_section*
  output_section(unsigned int shndx)
  { return this->section_map_[shndx]; }

  // Map a symbol table entry from the base file to the output symbol table.
  // SYMNDX is relative to the first forced-local or global symbol in the
  // input file symbol table.
  void
  add_global_symbol(unsigned int symndx, Symbol* gsym)
  { this->symbol_map_[symndx] = gsym; }

  // Map a symbol table entry from the base file to the output symbol table.
  // SYMNDX is relative to the first forced-local or global symbol in the
  // input file symbol table.
  Symbol*
  global_symbol(unsigned int symndx) const
  { return this->symbol_map_[symndx]; }

  // Add a COPY relocation for a global symbol.
  void
  add_copy_reloc(Symbol* gsym, Output_section* os, off_t offset)
  { this->copy_relocs_.push_back(Copy_reloc(gsym, os, offset)); }

  // Readers for the incremental info sections.

  const Incremental_inputs_reader<size, big_endian>&
  inputs_reader() const
  { return this->inputs_reader_; }

  const Incremental_symtab_reader<big_endian>&
  symtab_reader() const
  { return this->symtab_reader_; }

  const Incremental_relocs_reader<size, big_endian>&
  relocs_reader() const
  { return this->relocs_reader_; }

  const Incremental_got_plt_reader<big_endian>&
  got_plt_reader() const
  { return this->got_plt_reader_; }

  void
  get_symtab_view(View* symtab_view, unsigned int* sym_count,
		  elfcpp::Elf_strtab* strtab);

 protected:
  typedef Incremental_inputs_reader<size, big_endian> Inputs_reader;
  typedef typename Inputs_reader::Incremental_input_entry_reader
      Input_entry_reader;

  virtual bool
  do_check_inputs(const Command_line& cmdline,
		  Incremental_inputs* incremental_inputs);

  // Return TRUE if input file N has changed since the last incremental link.
  virtual bool
  do_file_has_changed(unsigned int n) const;

  // Initialize the layout of the output file based on the existing
  // output file.
  virtual void
  do_init_layout(Layout* layout);

  // Mark regions of the input file that must be kept unchanged.
  virtual void
  do_reserve_layout(unsigned int input_file_index);

  // Process the GOT and PLT entries from the existing output file.
  virtual void
  do_process_got_plt(Symbol_table* symtab, Layout* layout);

  // Emit COPY relocations from the existing output file.
  virtual void
  do_emit_copy_relocs(Symbol_table* symtab);

  // Apply incremental relocations for symbols whose values have changed.
  virtual void
  do_apply_incremental_relocs(const Symbol_table* symtab, Layout* layout,
			      Output_file* of);

  // Proxy class for a sized Incremental_input_entry_reader.

  class Sized_input_reader : public Input_reader
  {
   public:
    Sized_input_reader(Input_entry_reader r)
      : Input_reader(), reader_(r)
    { }

    virtual
    ~Sized_input_reader()
    { }

   private:
    const char*
    do_filename() const
    { return this->reader_.filename(); }

    Timespec
    do_get_mtime() const
    { return this->reader_.get_mtime(); }

    Incremental_input_type
    do_type() const
    { return this->reader_.type(); }

    unsigned int
    do_arg_serial() const
    { return this->reader_.arg_serial(); }

    unsigned int
    do_get_unused_symbol_count() const
    { return this->reader_.get_unused_symbol_count(); }

    const char*
    do_get_unused_symbol(unsigned int n) const
    { return this->reader_.get_unused_symbol(n); }

    Input_entry_reader reader_;
  };

  virtual unsigned int
  do_input_file_count() const
  { return this->inputs_reader_.input_file_count(); }

  virtual const Input_reader*
  do_get_input_reader(unsigned int n) const
  {
    gold_assert(n < this->input_entry_readers_.size());
    return &this->input_entry_readers_[n];
  }

 private:
  // List of symbols that need COPY relocations.
  struct Copy_reloc
  {
    Copy_reloc(Symbol* sym, Output_section* os, off_t off)
      : symbol(sym), output_section(os), offset(off)
    { }

    // The global symbol to copy.
    Symbol* symbol;
    // The output section into which the symbol was copied.
    Output_section* output_section;
    // The offset within that output section.
    off_t offset;
  };
  typedef std::vector<Copy_reloc> Copy_relocs;

  bool
  find_incremental_inputs_sections(unsigned int* p_inputs_shndx,
				   unsigned int* p_symtab_shndx,
				   unsigned int* p_relocs_shndx,
				   unsigned int* p_got_plt_shndx,
				   unsigned int* p_strtab_shndx);

  void
  setup_readers();

  // Output as an ELF file.
  elfcpp::Elf_file<size, big_endian, Incremental_binary> elf_file_;

  // Vector of pointers to the input objects for the unchanged files.
  // For replaced files, the corresponding pointer is NULL.
  std::vector<Sized_relobj_incr<size, big_endian>*> input_objects_;

  // Map section index to an Output_section in the updated layout.
  std::vector<Output_section*> section_map_;

  // Map global symbols from the input file to the symbol table.
  std::vector<Symbol*> symbol_map_;

  // List of symbols that need COPY relocations.
  Copy_relocs copy_relocs_;

  // Locations of the main symbol table and symbol string table.
  Location main_symtab_loc_;
  Location main_strtab_loc_;

  // Readers for the incremental info sections.
  bool has_incremental_info_;
  Incremental_inputs_reader<size, big_endian> inputs_reader_;
  Incremental_symtab_reader<big_endian> symtab_reader_;
  Incremental_relocs_reader<size, big_endian> relocs_reader_;
  Incremental_got_plt_reader<big_endian> got_plt_reader_;
  std::vector<Sized_input_reader> input_entry_readers_;
};

// An incremental Relobj.  This class represents a relocatable object
// that has not changed since the last incremental link, and whose contents
// can be used directly from the base file.

template<int size, bool big_endian>
class Sized_relobj_incr : public Sized_relobj<size, big_endian>
{
 public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  typedef typename Sized_relobj<size, big_endian>::Symbols Symbols;

  Sized_relobj_incr(const std::string& name,
		    Sized_incremental_binary<size, big_endian>* ibase,
		    unsigned int input_file_index);

 private:
  // For convenience.
  typedef Sized_relobj_incr<size, big_endian> This;
  static const int sym_size = elfcpp::Elf_sizes<size>::sym_size;

  typedef typename Sized_relobj<size, big_endian>::Output_sections
      Output_sections;
  typedef Incremental_inputs_reader<size, big_endian> Inputs_reader;
  typedef typename Inputs_reader::Incremental_input_entry_reader
      Input_entry_reader;

  // A local symbol.
  struct Local_symbol
  {
    Local_symbol(const char* name_, Address value_, unsigned int size_,
		 unsigned int shndx_, unsigned int type_,
		 bool needs_dynsym_entry_)
      : st_value(value_), name(name_), st_size(size_), st_shndx(shndx_),
	st_type(type_), output_dynsym_index(0),
	needs_dynsym_entry(needs_dynsym_entry_)
    { }
    // The symbol value.
    Address st_value;
    // The symbol name.  This points to the stringpool entry.
    const char* name;
    // The symbol size.
    unsigned int st_size;
    // The output section index.
    unsigned int st_shndx : 28;
    // The symbol type.
    unsigned int st_type : 4;
    // The index of the symbol in the output dynamic symbol table.
    unsigned int output_dynsym_index : 31;
    // TRUE if the symbol needs to appear in the dynamic symbol table.
    unsigned int needs_dynsym_entry : 1;
  };

  // Return TRUE if this is an incremental (unchanged) input file.
  bool
  do_is_incremental() const
  { return true; }

  // Return the last modified time of the file.
  Timespec
  do_get_mtime()
  { return this->input_reader_.get_mtime(); }

  // Read the symbols.
  void
  do_read_symbols(Read_symbols_data*);

  // Lay out the input sections.
  void
  do_layout(Symbol_table*, Layout*, Read_symbols_data*);

  // Layout sections whose layout was deferred while waiting for
  // input files from a plugin.
  void
  do_layout_deferred_sections(Layout*);

  // Add the symbols to the symbol table.
  void
  do_add_symbols(Symbol_table*, Read_symbols_data*, Layout*);

  Archive::Should_include
  do_should_include_member(Symbol_table* symtab, Layout*, Read_symbols_data*,
                           std::string* why);

  // Iterate over global symbols, calling a visitor class V for each.
  void
  do_for_all_global_symbols(Read_symbols_data* sd,
			    Library_base::Symbol_visitor_base* v);

  // Get the size of a section.
  uint64_t
  do_section_size(unsigned int shndx);

  // Get the name of a section.
  std::string
  do_section_name(unsigned int shndx);

  // Return a view of the contents of a section.
  const unsigned char*
  do_section_contents(unsigned int shndx, section_size_type* plen,
		      bool cache);

  // Return section flags.
  uint64_t
  do_section_flags(unsigned int shndx);

  // Return section entsize.
  uint64_t
  do_section_entsize(unsigned int shndx);

  // Return section address.
  uint64_t
  do_section_address(unsigned int shndx);

  // Return section type.
  unsigned int
  do_section_type(unsigned int shndx);

  // Return the section link field.
  unsigned int
  do_section_link(unsigned int shndx);

  // Return the section link field.
  unsigned int
  do_section_info(unsigned int shndx);

  // Return the section alignment.
  uint64_t
  do_section_addralign(unsigned int shndx);

  // Return the Xindex structure to use.
  Xindex*
  do_initialize_xindex();

  // Get symbol counts.
  void
  do_get_global_symbol_counts(const Symbol_table*, size_t*, size_t*) const;

  // Get global symbols.
  const Symbols*
  do_get_global_symbols() const
  { return &this->symbols_; }

  // Return the value of a local symbol.
  uint64_t
  do_local_symbol_value(unsigned int, uint64_t) const
  { gold_unreachable(); }

  unsigned int
  do_local_plt_offset(unsigned int) const
  { gold_unreachable(); }

  bool
  do_local_is_tls(unsigned int) const
  { gold_unreachable(); }

  // Return the number of local symbols.
  unsigned int
  do_local_symbol_count() const
  { return this->local_symbol_count_; }

  // Return the number of local symbols in the output symbol table.
  unsigned int
  do_output_local_symbol_count() const
  { return this->local_symbol_count_; }

  // Return the file offset for local symbols in the output symbol table.
  off_t
  do_local_symbol_offset() const
  { return this->local_symbol_offset_; }

  // Read the relocs.
  void
  do_read_relocs(Read_relocs_data*);

  // Process the relocs to find list of referenced sections. Used only
  // during garbage collection.
  void
  do_gc_process_relocs(Symbol_table*, Layout*, Read_relocs_data*);

  // Scan the relocs and adjust the symbol table.
  void
  do_scan_relocs(Symbol_table*, Layout*, Read_relocs_data*);

  // Count the local symbols.
  void
  do_count_local_symbols(Stringpool_template<char>*,
			 Stringpool_template<char>*);

  // Finalize the local symbols.
  unsigned int
  do_finalize_local_symbols(unsigned int, off_t, Symbol_table*);

  // Set the offset where local dynamic symbol information will be stored.
  unsigned int
  do_set_local_dynsym_indexes(unsigned int);

  // Set the offset where local dynamic symbol information will be stored.
  unsigned int
  do_set_local_dynsym_offset(off_t);

  // Relocate the input sections and write out the local symbols.
  void
  do_relocate(const Symbol_table* symtab, const Layout*, Output_file* of);

  // Set the offset of a section.
  void
  do_set_section_offset(unsigned int shndx, uint64_t off);

  // The Incremental_binary base file.
  Sized_incremental_binary<size, big_endian>* ibase_;
  // The index of the object in the input file list.
  unsigned int input_file_index_;
  // The reader for the input file.
  Input_entry_reader input_reader_;
  // The number of local symbols.
  unsigned int local_symbol_count_;
  // The number of local symbols which go into the output file's dynamic
  // symbol table.
  unsigned int output_local_dynsym_count_;
  // This starting symbol index in the output symbol table.
  unsigned int local_symbol_index_;
  // The file offset for local symbols in the output symbol table.
  unsigned int local_symbol_offset_;
  // The file offset for local symbols in the output symbol table.
  unsigned int local_dynsym_offset_;
  // The entries in the symbol table for the external symbols.
  Symbols symbols_;
  // Number of symbols defined in object file itself.
  size_t defined_count_;
  // The offset of the first incremental relocation for this object.
  unsigned int incr_reloc_offset_;
  // The number of incremental relocations for this object.
  unsigned int incr_reloc_count_;
  // The index of the first incremental relocation for this object in the
  // updated output file.
  unsigned int incr_reloc_output_index_;
  // A copy of the incremental relocations from this object.
  unsigned char* incr_relocs_;
  // The local symbols.
  std::vector<Local_symbol> local_symbols_;
};

// An incremental Dynobj.  This class represents a shared object that has
// not changed since the last incremental link, and whose contents can be
// used directly from the base file.

template<int size, bool big_endian>
class Sized_incr_dynobj : public Dynobj
{
 public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;

  static const Address invalid_address = static_cast<Address>(0) - 1;

  Sized_incr_dynobj(const std::string& name,
		    Sized_incremental_binary<size, big_endian>* ibase,
		    unsigned int input_file_index);

 private:
  typedef Incremental_inputs_reader<size, big_endian> Inputs_reader;
  typedef typename Inputs_reader::Incremental_input_entry_reader
      Input_entry_reader;

  // Return TRUE if this is an incremental (unchanged) input file.
  bool
  do_is_incremental() const
  { return true; }

  // Return the last modified time of the file.
  Timespec
  do_get_mtime()
  { return this->input_reader_.get_mtime(); }

  // Read the symbols.
  void
  do_read_symbols(Read_symbols_data*);

  // Lay out the input sections.
  void
  do_layout(Symbol_table*, Layout*, Read_symbols_data*);

  // Add the symbols to the symbol table.
  void
  do_add_symbols(Symbol_table*, Read_symbols_data*, Layout*);

  Archive::Should_include
  do_should_include_member(Symbol_table* symtab, Layout*, Read_symbols_data*,
                           std::string* why);

  // Iterate over global symbols, calling a visitor class V for each.
  void
  do_for_all_global_symbols(Read_symbols_data* sd,
			    Library_base::Symbol_visitor_base* v);

  // Iterate over local symbols, calling a visitor class V for each GOT offset
  // associated with a local symbol.
  void
  do_for_all_local_got_entries(Got_offset_list::Visitor* v) const;

  // Get the size of a section.
  uint64_t
  do_section_size(unsigned int shndx);

  // Get the name of a section.
  std::string
  do_section_name(unsigned int shndx);

  // Return a view of the contents of a section.
  const unsigned char*
  do_section_contents(unsigned int shndx, section_size_type* plen,
		      bool cache);

  // Return section flags.
  uint64_t
  do_section_flags(unsigned int shndx);

  // Return section entsize.
  uint64_t
  do_section_entsize(unsigned int shndx);

  // Return section address.
  uint64_t
  do_section_address(unsigned int shndx);

  // Return section type.
  unsigned int
  do_section_type(unsigned int shndx);

  // Return the section link field.
  unsigned int
  do_section_link(unsigned int shndx);

  // Return the section link field.
  unsigned int
  do_section_info(unsigned int shndx);

  // Return the section alignment.
  uint64_t
  do_section_addralign(unsigned int shndx);

  // Return the Xindex structure to use.
  Xindex*
  do_initialize_xindex();

  // Get symbol counts.
  void
  do_get_global_symbol_counts(const Symbol_table*, size_t*, size_t*) const;

  // Get global symbols.
  const Symbols*
  do_get_global_symbols() const
  { return &this->symbols_; }

  // The Incremental_binary base file.
  Sized_incremental_binary<size, big_endian>* ibase_;
  // The index of the object in the input file list.
  unsigned int input_file_index_;
  // The reader for the input file.
  Input_entry_reader input_reader_;
  // The entries in the symbol table for the external symbols.
  Symbols symbols_;
  // Number of symbols defined in object file itself.
  size_t defined_count_;
};

// Allocate an incremental object of the appropriate size and endianness.
extern Object*
make_sized_incremental_object(
    Incremental_binary* base,
    unsigned int input_file_index,
    Incremental_input_type input_type,
    const Incremental_binary::Input_reader* input_reader);

// This class represents an Archive library (or --start-lib/--end-lib group)
// that has not changed since the last incremental link.  Its contents come
// from the incremental inputs entry in the base file.

class Incremental_library : public Library_base
{
 public:
  Incremental_library(const char* filename, unsigned int input_file_index,
		      const Incremental_binary::Input_reader* input_reader)
    : Library_base(NULL), filename_(filename),
      input_file_index_(input_file_index), input_reader_(input_reader),
      unused_symbols_(), is_reported_(false)
  { }

  // Return the input file index.
  unsigned int
  input_file_index() const
  { return this->input_file_index_; }

  // Return the serial number of the input file.
  unsigned int
  arg_serial() const
  { return this->input_reader_->arg_serial(); }

  // Copy the unused symbols from the incremental input info.
  // We need to do this because we may be overwriting the incremental
  // input info in the base file before we write the new incremental
  // info.
  void
  copy_unused_symbols();

  // Return FALSE on the first call to indicate that the library needs
  // to be recorded; return TRUE subsequently.
  bool
  is_reported()
  {
    bool was_reported = this->is_reported_;
    is_reported_ = true;
    return was_reported;
  }

 private:
  typedef std::vector<std::string> Symbol_list;

  // The file name.
  const std::string&
  do_filename() const
  { return this->filename_; }

  // Return the modification time of the archive file.
  Timespec
  do_get_mtime()
  { return this->input_reader_->get_mtime(); }

  // Iterator for unused global symbols in the library.
  void
  do_for_all_unused_symbols(Symbol_visitor_base* v) const;

  // The name of the library.
  std::string filename_;
  // The input file index of this library.
  unsigned int input_file_index_;
  // A reader for the incremental input information.
  const Incremental_binary::Input_reader* input_reader_;
  // List of unused symbols defined in this library.
  Symbol_list unused_symbols_;
  // TRUE when this library has been reported to the new incremental info.
  bool is_reported_;
};

} // End namespace gold.

#endif // !defined(GOLD_INCREMENTAL_H)
@


1.33
log
@	PR gold/14570
	* output.cc: Rename Output_data_got template parameter from size
	to got_size for all functions.  Compile all variants of
	Output_data_got.
	(Output_data_got::Got_entry::write): Correct use of size for
	symbol value.  Use local_is_tls rather than casting to
	Sized_relobj_file.
	* object.h (class Object): Add local_is_tls and do_local_is_tls.
	(class Sized_relobj_file): Add do_local_is_tls.
	* incremental.h (class Sized_relobj_incr): Add do_local_is_tls.
@
text
@d3 1
a3 1
// Copyright 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
d307 1
a307 1
			   unsigned int arg_serial, Script_info* script,
d310 1
a310 1
      script_(script), objects_()
a343 2
  // Information about the script file.
  Script_info* script_;
d1343 1
a1343 1
  Incremental_binary(Output_file* output, Target* target)
d1345 1
a1345 1
      output_(output), target_(target)
a1582 2
  // Target of the output file.
  Target* target_;
@


1.33.2.1
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@d3 1
a3 1
// Copyright 2009, 2010, 2011, 2012, 2013 Free Software Foundation, Inc.
d307 1
a307 1
			   unsigned int arg_serial, Script_info* /*script*/,
d310 1
a310 1
      objects_()
d344 2
d1345 1
a1345 1
  Incremental_binary(Output_file* output, Target* /*target*/)
d1347 1
a1347 1
      output_(output)
d1585 2
@


1.32
log
@	* incremental-dump.cc (find_input_containing_global): Replace
	magic number with symbolic constant.
	(dump_incremental_inputs): Update version number.
	* incremental.cc (Output_section_incremental_inputs): Update version
	number; import symbolic constants from Incremental_inputs_reader.
	(Incremental_inputs::create_data_sections): Align relocations
	section correctly for 64-bit targets.
	(Output_section_incremental_inputs::set_final_data_size): Use symbolic
	constants; add padding.
	(Output_section_incremental_inputs::write_header): Add assert for
	header_size.
	(Output_section_incremental_inputs::write_input_files): Add assert
	for input_entry_size.
	(Output_section_incremental_inputs::write_info_blocks): Add padding;
	add assert for object_info_size, input_section_entry_size,
	global_sym_entry_size.
	* incremental.h (Incremental_inputs_reader): Add symbolic constants
	for data structure sizes; use them.
	(Incremental_input_entry_reader): Import symbolic constants from
	Incremental_inputs_reader; use them.
@
text
@d3 1
a3 1
// Copyright 2009, 2010, 2011 Free Software Foundation, Inc.
d1965 4
@


1.31
log
@2012-03-21  Cary Coutant  <ccoutant@@google.com>

	* Makefile.am: Add gdb-index.cc, gdb-index.h.
	* Makefile.in: Regenerate.
	* dwarf_reader.cc (Sized_elf_reloc_mapper::do_initialize): New function.
	(Sized_elf_reloc_mapper::symbol_section): New function.
	(Sized_elf_reloc_mapper::do_get_reloc_target): New function.
	(make_elf_reloc_mapper): New function.
	(Dwarf_abbrev_table::clear_abbrev_codes): New function.
	(Dwarf_abbrev_table::do_read_abbrevs): New function.
	(Dwarf_abbrev_table::do_get_abbrev): New function.
	(Dwarf_ranges_table::read_ranges_table): New function.
	(Dwarf_ranges_table::read_range_list): New function.
	(Dwarf_pubnames_table::read_section): New function.
	(Dwarf_pubnames_table::read_header): New function.
	(Dwarf_pubnames_table::next_name): New function.
	(Dwarf_die::Dwarf_die): New function.
	(Dwarf_die::read_attributes): New function.
	(Dwarf_die::skip_attributes): New function.
	(Dwarf_die::set_name): New function.
	(Dwarf_die::set_linkage_name): New function.
	(Dwarf_die::attribute): New function.
	(Dwarf_die::string_attribute): New function.
	(Dwarf_die::int_attribute): New function.
	(Dwarf_die::uint_attribute): New function.
	(Dwarf_die::ref_attribute): New function.
	(Dwarf_die::child_offset): New function.
	(Dwarf_die::sibling_offset): New function.
	(Dwarf_info_reader::check_buffer): New function.
	(Dwarf_info_reader::parse): New function.
	(Dwarf_info_reader::do_parse): New function.
	(Dwarf_info_reader::do_read_string_table): New function.
	(Dwarf_info_reader::lookup_reloc): New function.
	(Dwarf_info_reader::get_string): New function.
	(Dwarf_info_reader::visit_compilation_unit): New function.
	(Dwarf_info_reader::visit_type_unit): New function.
	(Sized_dwarf_line_info::Sized_dwarf_line_info): Use
	Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::symbol_section): Remove function.
	(Sized_dwarf_line_info::read_relocs): Use Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::read_line_mappings): Remove object
	parameter, adjust callers.
	(Sized_dwarf_line_info::format_file_lineno): Fix type of cast.
	* dwarf_reader.h: Include <sys/types.h>.
	(class Track_relocs): Remove forward declaration.
	(class Elf_reloc_mapper): New class.
	(class Sized_elf_reloc_mapper): New class.
	(class Dwarf_abbrev_table): New class.
	(class Dwarf_range_list): New class.
	(class Dwarf_ranges_table): New class.
	(class Dwarf_pubnames_table): New class.
	(class Dwarf_die): New class.
	(class Dwarf_info_reader): New class.
	(Sized_dwarf_line_info::read_line_mappings): Remove object parameter.
	(Sized_dwarf_line_info::symbol_section): Remove member function.
	* dynobj.h (Sized_dynobj::do_section_contents): Refactor code from
	base class.
	* gdb-index.cc: New source file.
	* gdb-index.h: New source file.
	* incremental.cc (Sized_relobj_incr::do_layout): Track .debug_info
	and .debug_types sections, call Layout::add_to_gdb_index.
	(Sized_relobj_incr::do_section_name): Implement.
	(Sized_relobj_incr::do_section_contents): Adjust parameter list and
	return type; Implement.
	(Sized_incr_dynobj::do_section_contents): Adjust parameter list and
	return type.
	* incremental.h (Sized_relobj_incr::do_section_contents): Adjust
	parameter list and return type.
	(Sized_incr_dynobj::do_section_contents): Likewise.
	* layout.cc: Include gdb-index.h.
	(Layout::Layout): Initialize gdb_index_data_.
	(Layout::init_fixed_output_section): Check for .gdb_index section.
	(Layout::add_to_gdb_index): New function. Instantiate.
	* layout.h: Add forward declaration for class Gdb_index.
	(Layout::add_to_gdb_index): New member function.
	(Layout::gdb_index_data_): New data member.
	* main.cc: Include gdb-index.h.
	(main): Print statistics for gdb index.
	* object.cc (Object::section_contents): Move code into
	do_section_contents.
	(need_decompressed_section): Check for sections needed when building
	gdb index.
	(build_compressed_section_map): Likewise.
	(Sized_relobj_file::do_read_symbols): Need local symbols when building
	gdb index.
	(Sized_relobj_file::do_layout): Track .debug_info and .debug_types
	sections; call Layout::add_to_gdb_index.
	(Sized_relobj_file::do_decompressed_section_contents): Call
	do_section_contents directly.
	* object.h (Object::do_section_contents): Adjust parameter list and
	return type.
	(Object::do_decompressed_section_contents): Call do_section_contents
	directly.
	(Sized_relobj_file::do_section_contents): Adjust parameter list and
	return type.
	* options.h (class General_options): Add --gdb-index option.
	* plugin.cc (Sized_pluginobj::do_section_contents): Adjust parameter
	list and return type.
	* plugin.h (Sized_pluginobj::do_section_contents): Likewise.
	* reloc.h (Track_relocs::checkpoint): New function.
	(Track_relocs::reset): New function.

	* testsuite/Makefile.am (gdb_index_test_1.sh, gdb_index_test_2.sh):
	New test cases.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/gdb_index_test.cc: New test source file.
	* testsuite/gdb_index_test_1.sh: New test source file.
	* testsuite/gdb_index_test_2.sh: New test source file.
@
text
@d761 17
d808 8
d894 4
a897 3
      return (this->info_offset_ + 28
	      + section_count * input_section_entry_size
	      + symndx * 20);
d1030 3
a1032 2
				+ this->info_offset_ + 28
				+ n * input_section_entry_size);
d1049 4
a1052 3
				+ this->info_offset_ + 28
				+ section_count * input_section_entry_size
				+ n * 20);
d1063 4
a1066 3
				+ this->info_offset_ + 28
				+ section_count * input_section_entry_size
				+ symbol_count * 20
a1103 2
    // Size of an input section entry.
    static const unsigned int input_section_entry_size = 8 + 2 * size / 8;
d1119 1
a1119 1
    return 16 + n * 24;
d1126 1
a1126 1
    int n = (offset - 16) / 24;
d1140 2
a1141 1
    gold_assert(offset < 16 + this->input_file_count_ * 24);
@


1.30
log
@	* object.h (Relobj::local_symbol_value): New function.
	(Relobj::local_plt_offset): New function.
	(Relobj::local_has_got_offset): New function.
	(Relobj::local_got_offset): New function.
	(Relobj::set_local_got_offset): New function.
	(Relobj::do_local_symbol_value): New pure virtual function.
	(Relobj::do_local_plt_offset): Likewise.
	(Relobj::do_local_has_got_offset): Likewise.
	(Relobj::do_local_got_offset): Likewise.
	(Relobj::do_set_local_got_offset): Likewise.
	(Sized_relobj::do_local_has_got_offset): Rename from
	local_has_got_offset.
	(Sized_relobj::do_local_got_offset): Rename from local_got_offset.
	(Sized_relobj::do_set_local_got_offset): Rename from
	set_local_got_offset.
	(Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	(Sized_relobj_file::do_local_symbol_value): New function.
	* object.cc (Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	* output.cc (Output_data_got::Got_entry::write): Change object to
	Relobj.  Use local_symbol_value.
	(Output_data_got::add_global_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_with_rela): Remove.  Change all
	callers to use add_global_with_rel.
	(Output_data_got::add_global_pair_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_pair_with_rela): Remove.  Change all
	callers to use add_global_pair_with_rel.
	(Output_data_got::add_local): Change object to Relobj*.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Change object to Relobj*,
	change rel_dyn to Output_data_reloc_generic*.  Use
	add_local_generic.
	(Output_data_got::add_local_with_rela): Remove.  Change all
	callers to use all_local_with_rel.
	(Output_data_got::add_local_pair_with_rel): Change object to
	Relobj*, change rel_dyn to Output_data_reloc_generic*.  Use
	add_output_section_generic.
	(Output_data_got::add_local_pair_with_rela): Remove.  Change all
	callers to use add_local_pair_with_rel.
	(Output_data_got::reserve_local): Change object to Relobj*.
	* output.h: (class Output_data_reloc_generic): Add pure virtual
	declarations for add_global_generic, add_local_generic,
	add_output_section_generic.
	(class Output_data_reloc) [SHT_REL, SHT_RELA]: Implement new
	functions for Output_data_reloc_generic.  Update declarations for
	changes listed in output.cc.
	(class Output_data_got): Change template parameter to got_size.
	Don't define Rel_dyn or Rela_dyn.  Update declarations per above.
	* incremental.h (Sized_relobj_incr::do_local_symbol_value): New
	function.
	(Sized_relobj_incr::do_local_plt_offset): New function.
	* copy-relocs.cc (Copy_relocs::Copy_reloc_entry::emit): Call
	add_global_generic.
@
text
@d1883 3
a1885 2
  Object::Location
  do_section_contents(unsigned int shndx);
d2090 3
a2092 2
  Object::Location
  do_section_contents(unsigned int shndx);
@


1.29
log
@	* gold/incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* gold/incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* gold/plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.
@
text
@d3 1
a3 1
// Copyright 2009, 2010 Free Software Foundation, Inc.
d1927 9
@


1.28
log
@	* incremental.cc (can_incremental_update): Fix typo in comment.
	* incremental.h (can_incremental_update): Likewise.
@
text
@d1999 2
d2132 2
@


1.28.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@a1998 2
  // Number of symbols defined in object file itself.
  size_t defined_count_;
a2129 2
  // Number of symbols defined in object file itself.
  size_t defined_count_;
@


1.27
log
@	* incremental.cc (can_incremental_update): New function.
	* incremental.h (can_incremental_update): New function.
	* layout.cc (Layout::init_fixed_output_section): Call it.
	(Layout::make_output_section): Don't allow patch space in .eh_frame.
	* object.cc (Sized_relobj_file::do_layout): Call
	can_incremental_update.
@
text
@d84 1
a84 1
// Return TRUE if a section of type SH_TYPE will can be updated in place
@


1.26
log
@	* incremental.cc (Sized_incremental_binary::setup_readers): Pass
	input file index to Script_info ctor.
	(Sized_incremental_binary::do_file_has_changed): Find the
	command-line argument for files named in scripts.
	* incremental.h (Script_info::Script_info): New ctor
	with input file index.
	(Script_info::input_file_index): New function.
	(Script_info::input_file_index_): New data member.
	(Incremental_binary::get_library): Add const.
	(Incremental_binary::get_script_info): Add const.
	* readsyms.cc (Read_member::is_runnable): Check for this_blocker_.
	* testsuite/Makefile.am (incremental_test_5): New test case.
	(incremental_test_6): New test case.
	* testsuite/Makefile.in: Regenerate.
@
text
@d84 5
@


1.25
log
@	* copy-relocs.cc (Copy_relocs::copy_reloc): Call make_copy_reloc
	instead of emit_copy_reloc.
	(Copy_relocs::emit_copy_reloc): Refactor.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* copy-relocs.h (Copy_relocs::emit_copy_reloc): Move to public
	section.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* gold.cc (queue_middle_tasks): Emit old COPY relocations from
	unchanged input files.
	* incremental-dump.cc (dump_incremental_inputs): Print "COPY" flag.
	* incremental.cc (Sized_incremental_binary::do_reserve_layout):
	Reserve BSS space for COPY relocations.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Output_section_incremental_inputs::write_info_blocks): Record
	whether a symbol is copied from a shared object.
	(Sized_incr_dynobj::do_add_symbols): Record COPY relocations.
	* incremental.h (enum Incremental_shlib_symbol_flags): New type.
	(INCREMENTAL_SHLIB_SYM_FLAGS_SHIFT): New constant.
	(Incremental_input_entry_reader::get_output_symbol_index): Add
	is_copy parameter.
	(Incremental_binary::emit_copy_relocs): New function.
	(Incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data member.
	(Sized_incremental_binary::add_copy_reloc): New function.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Copy_reloc): New struct.
	(Sized_incremental_binary::Copy_relocs): New typedef.
	(Sized_incremental_binary::copy_relocs_): New data member.
	* symtab.cc (Symbol_table::add_from_incrobj): Change return type.
	* symtab.h (Symbol_table::add_from_incrobj): Change return type.
	* target.h (Sized_target::emit_copy_reloc): New function.
	* x86_64.cc (Target_x86_64::emit_copy_reloc): New function.
@
text
@a48 1
class Script_info;
d261 7
a267 1
    : filename_(filename), incremental_script_entry_(NULL)
d280 5
d292 1
d1417 1
a1417 1
  get_library(unsigned int n)
d1422 1
a1422 1
  get_script_info(unsigned int n)
@


1.24
log
@	* incremental-dump.cc (dump_incremental_inputs): Print COMDAT groups.
	* incremental.cc (Incremental_inputs::report_input_section): Fix
	comment, indentation.
	(Incremental_inputs::report_comdat_group): New function.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of data for incremental input file entry.
	(Output_section_incremental_inputs::write_info_blocks): Write COMDAT
	group count, COMDAT group signatures.
	(Sized_incr_relobj::do_layout): Record kept COMDAT group info from
	an unchanged input file.
	* incremental.h (Incremental_object_entry::Incremental_object_entry):
	Initialize new data member.
	(Incremental_object_entry::add_comdat_group): New function.
	(Incremental_object_entry::get_comdat_group_count): New function.
	(Incremental_object_entry::get_comdat_signature_key): New function.
	(Incremental_object_entry::groups_): New data member.
	(Incremental_inputs::report_comdat_group): New function.
	(Incremental_input_entry_reader::get_symbol_offset): Adjust size of
	data for incremental input file entry.
	(Incremental_input_entry_reader::get_comdat_group_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	data for incremental input file entry.
	(Incremental_input_entry_reader::get_global_symbol_reader): Likewise.
	(Incremental_input_entry_reader::get_comdat_group_signature): New
	function.
	* object.cc (Sized_relobj::include_section_group): Report kept
	COMDAT groups for incremental links.
@
text
@d71 14
d1029 2
a1030 1
    // input file.
d1032 1
a1032 1
    get_output_symbol_index(unsigned int n, bool* is_def)
d1039 17
a1055 2
      *is_def = (output_symndx & (1U << 31)) != 0;
      return output_symndx & ((1U << 31) - 1);
d1430 5
d1517 4
d1556 3
a1558 3
      input_objects_(), section_map_(), symbol_map_(), main_symtab_loc_(),
      main_strtab_loc_(), has_incremental_info_(false), inputs_reader_(),
      symtab_reader_(), relocs_reader_(), got_plt_reader_(),
d1600 5
d1653 4
d1715 16
d1754 3
@


1.23
log
@	* dynobj.h (Dynobj::do_dynobj): New function.
	* incremental-dump.cc (dump_incremental_inputs): Print as_needed
	flag and soname for shared objects.
	* incremental.cc (Incremental_inputs::report_object): Make
	either Incremental_object_entry or Incremental_dynobj_entry; add
	soname to string table.
	(Incremental_inputs::report_input_section): Add assertion.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	type of input file entry for shared libraries; adjust size of
	shared library info entry.
	(Output_section_incremental_inputs::write_input_files): Write
	as_needed flag for shared libraries.
	(Output_section_incremental_inputs::write_info_blocks): Adjust type
	of input file entry for shared libraries; write soname.
	(Sized_incr_dynobj::Sized_incr_dynobj): Read as_needed flag and
	soname from incremental info.
	* incremental.h (enum Incremental_input_flags): Add
	INCREMENTAL_INPUT_AS_NEEDED.
	(Incremental_input_entry::Incremental_input_entry): Initialize new
	data member.
	(Incremental_input_entry::set_as_needed): New function.
	(Incremental_input_entry::as_needed): New function.
	(Incremental_input_entry::do_dynobj_entry): New function.
	(Incremental_input_entry::as_needed_): New data member.
	(Incremental_object_entry::Incremental_object_entry): Don't check
	for shared library.
	(Incremental_object_entry::do_type): Likewise.
	(class Incremental_dynobj_entry): New class.
	(Incremental_input_entry_reader::as_needed): New function.
	(Incremental_input_entry_reader::get_soname): New function.
	(Incremental_input_entry_reader::get_global_symbol_count): Rewrite.
	(Incremental_input_entry_reader::get_output_symbol_index): Adjust
	size of shared library info entry.
	* layout.cc (Layout::finish_dynamic_section): Don't test for
	incremental link when adding DT_NEEDED entries.
	* object.h (Object::Object): Initialize new data member.
	(Object::dynobj): New function.
	(Object::set_as_needed): New function.
	(Object::as_needed): New function.
	(Object::do_dynobj): New function.
	(Object::as_needed_): New data member.
@
text
@d328 1
a328 1
      is_member_(false), sections_()
d371 15
d418 3
d567 4
d839 1
a839 1
      return (this->info_offset_ + 24
d894 10
d974 1
a974 1
				+ this->info_offset_ + 24
d992 1
a992 1
				+ this->info_offset_ + 24
d998 15
@


1.22
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d43 1
d67 2
a68 1
  INCREMENTAL_INPUT_IN_SYSTEM_DIR = 0x0800
d85 2
a86 1
      arg_serial_(arg_serial), mtime_(mtime), is_in_system_directory_(false)
d151 10
d173 6
d202 6
d235 3
d329 1
a329 4
  {
    if (!obj_->is_dynamic())
      this->sections_.reserve(obj->shnum());
  }
d377 1
a377 3
	    : (this->obj_->is_dynamic()
	       ? INCREMENTAL_INPUT_SHARED_LIBRARY
	       : INCREMENTAL_INPUT_OBJECT));
d405 40
d784 5
d798 10
d826 4
a829 10
      switch (this->type())
	{
	case INCREMENTAL_INPUT_OBJECT:
	case INCREMENTAL_INPUT_ARCHIVE_MEMBER:
	  return Swap32::readval(this->inputs_->p_ + this->info_offset_ + 4);
	case INCREMENTAL_INPUT_SHARED_LIBRARY:
	  return Swap32::readval(this->inputs_->p_ + this->info_offset_);
	default:
	  gold_unreachable();
	}
d974 1
a974 1
				+ this->info_offset_ + 4
@


1.21
log
@	* gold.cc (queue_middle_tasks): Process existing GOT/PLT entries.
	* incremental-dump.cc (dump_incremental_inputs): Mask high-order
	bit when checking got_type.
	* incremental.cc (Sized_incremental_binary::setup_readers):
	Store symbol table and string table locations; initialize bit vector
	of file status flags.
	(Sized_incremental_binary::do_reserve_layout): Set bit flag for
	unchanged files.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::get_symtab_view): Use stored locations.
	(Output_section_incremental_inputs::set_final_data_size): Record
	file index for each input file.
	(Output_section_incremental_inputs::write_got_plt): Store file index
	instead of input entry offset for each GOT entry.
	* incremental.h
	(Incremental_input_entry::Incremental_input_entry): Initialize new
	data member.
	(Incremental_input_entry::set_offset): Store file index.
	(Incremental_input_entry::get_file_index): New function.
	(Incremental_input_entry::file_index_): New data member.
	(Incremental_binary::process_got_plt): New function.
	(Incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data members.
	(Sized_incremental_binary::~Sized_incremental_binary): New destructor.
	(Sized_incremental_binary::set_file_is_unchanged): New function.
	(Sized_incremental_binary::file_is_unchanged): New function.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::file_status_): New data member.
	(Sized_incremental_binary::main_symtab_loc_): New data member.
	(Sized_incremental_binary::main_strtab_loc_): New data member.
	* output.cc (Output_data_got::Got_entry::write): Add case
	RESERVED_CODE.
	(Output_data_got::add_global): Call add_got_entry.
	(Output_data_got::add_global_plt): Likewise.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_global_pair_with_rela): Likewise.
	(Output_data_got::add_local): Call add_got_entry.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_local_pair_with_rela): Likewise.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_section::add_output_section_data): Edit FIXME.
	* output.h
	(Output_section_data_build::Output_section_data_build): New
	constructor with size parameter.
	(Output_data_space::Output_data_space): Likewise.
	(Output_data_got::Output_data_got): Initialize new data member; new
	constructor with size parameter.
	(Output_data_got::add_constant): Call add_got_entry.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(class Output_data_got::Got_entry): Add RESERVED_CODE.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_data_got::free_list_): New data member.
	* target.h (Sized_target::init_got_plt_for_update): New function.
	(Sized_target::register_global_plt_entry): New function.
	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Initialize new data member; call init; add constructor with PLT count.
	(Output_data_plt_x86_64::init): New function.
	(Output_data_plt_x86_64::add_relocation): New function.
	(Output_data_plt_x86_64::reserve_slot): New function.
	(Output_data_plt_x86_64::free_list_): New data member.
	(Target_x86_64::init_got_plt_for_update): New function.
	(Target_x86_64::register_global_plt_entry): New function.
	(Output_data_plt_x86_64::add_entry): Allocate from free list for
	incremental updates.
	(Output_data_plt_x86_64::add_relocation): New function.
	* testsuite/object_unittest.cc (Object_test): Set default options.
@
text
@d739 1
a739 1
      return (this->info_offset_ + 16
d780 20
d870 1
a870 1
				+ this->info_offset_ + 16
d888 1
a888 1
				+ this->info_offset_ + 16
d1087 1
a1087 1
    this->plt_desc_p_ = this->got_desc_p_ + this->got_count_ * 4;
d1111 8
a1118 1
  // Return the GOT descriptor for GOT entry N.
d1120 1
a1120 1
  get_got_desc(unsigned int n)
d1122 1
a1122 1
    return elfcpp::Swap<32, big_endian>::readval(this->got_desc_p_ + n * 4);
d1388 3
d1398 1
a1398 1
      file_status_(NULL), section_map_(), symbol_map_(), main_symtab_loc_(),
a1403 7
  virtual
  ~Sized_incremental_binary()
  {
    if (this->file_status_ != NULL)
      delete[] this->file_status_;
  }

d1409 1
a1409 1
  // Set the flag for input file N to indicate that the file is unchanged.
d1411 7
a1417 9
  set_file_is_unchanged(unsigned int n)
  {
    gold_assert(this->file_status_ != NULL);
    this->file_status_[n / 8] |= 1U << (n % 8);
  }

  // Returns TRUE if input file N is unchanged.
  bool
  file_is_unchanged(unsigned int n) const
d1419 2
a1420 2
    gold_assert(this->file_status_ != NULL);
    return (this->file_status_[n / 8] & (1U << (n % 8))) != 0;
d1561 3
a1563 4
  // Status flags for each input file.  Each bit represents one input file;
  // 0 indicates that the file was replaced; 1 indicates that the file was
  // unchanged.
  unsigned char* file_status_;
d1589 1
a1589 1
class Sized_incr_relobj : public Sized_relobj_base<size, big_endian>
d1593 1
a1593 1
  typedef typename Sized_relobj_base<size, big_endian>::Symbols Symbols;
d1595 1
a1595 3
  static const Address invalid_address = static_cast<Address>(0) - 1;

  Sized_incr_relobj(const std::string& name,
a1598 20
  // Checks if the offset of input section SHNDX within its output
  // section is invalid.
  bool
  is_output_section_offset_invalid(unsigned int shndx) const
  { return this->section_offsets_[shndx] == invalid_address; }

  // Get the offset of input section SHNDX within its output section.
  // This is -1 if the input section requires a special mapping, such
  // as a merge section.  The output section can be found in the
  // output_sections_ field of the parent class Incrobj.
  uint64_t
  do_output_section_offset(unsigned int shndx) const
  {
    gold_assert(shndx < this->section_offsets_.size());
    Address off = this->section_offsets_[shndx];
    if (off == invalid_address)
      return -1ULL;
    return off;
  }

d1601 1
a1601 1
  typedef Sized_incr_relobj<size, big_endian> This;
d1604 1
a1604 1
  typedef typename Sized_relobj_base<size, big_endian>::Output_sections
a1671 5
  // Iterate over local symbols, calling a visitor class V for each GOT offset
  // associated with a local symbol.
  void
  do_for_all_local_got_entries(Got_offset_list::Visitor* v) const;

a1796 4
  // For each input section, the offset of the input section in its
  // output section.  This is INVALID_ADDRESS if the input section requires a
  // special mapping.
  std::vector<Address> section_offsets_;
@


1.20
log
@	* incremental-dump.cc (dump_incremental_inputs): Print local
	symbol info for each input file.
	* incremental.cc
	(Output_section_incremental_inputs::set_final_data_size): Add local
	symbol info to input file entries in incremental info.
	(Output_section_incremental_inputs::write_info_blocks): Likewise.
	(Sized_incr_relobj::Sized_incr_relobj): Initialize new data members.
	(Sized_incr_relobj::do_add_symbols): Cosmetic change.
	(Sized_incr_relobj::do_count_local_symbols): Replace stub with
	implementation.
	(Sized_incr_relobj::do_finalize_local_symbols): Likewise.
	(Sized_incr_relobj::do_relocate): Write the local symbols.
	(Sized_incr_dynobj::do_add_symbols): Cosmetic change.
	* incremental.h (Incremental_inputs_reader::get_symbol_offset):
	Adjust size of input file header.
	(Incremental_inputs_reader::get_local_symbol_offset): New function.
	(Incremental_inputs_reader::get_local_symbol_count): New function.
	(Incremental_inputs_reader::get_input_section): Adjust size of input
	file header.
	(Incremental_inputs_reader::get_global_symbol_reader): Likewise.
	(Sized_incr_relobj::This): New typedef.
	(Sized_incr_relobj::sym_size): New const data member.
	(Sized_incr_relobj::Local_symbol): New struct.
	(Sized_incr_relobj::do_output_local_symbol_count): New function.
	(Sized_incr_relobj::do_local_symbol_offset): New function.
	(Sized_incr_relobj::local_symbol_count_): New data member.
	(Sized_incr_relobj::output_local_dynsym_count_): New data member.
	(Sized_incr_relobj::local_symbol_index_): New data member.
	(Sized_incr_relobj::local_symbol_offset_): New data member.
	(Sized_incr_relobj::local_dynsym_offset_): New data member.
	(Sized_incr_relobj::local_symbols_): New data member.
	* object.h (Relobj::output_local_symbol_count): New function.
	(Relobj::local_symbol_offset): New function.
	(Relobj::do_output_local_symbol_count): New function.
	(Relobj::do_local_symbol_offset): New function.
	(Sized_relobj::do_output_local_symbol_count): New function.
	(Sized_relobj::do_local_symbol_offset): New function.
@
text
@d82 1
a82 1
    : filename_key_(filename_key), offset_(0), info_offset_(0),
d95 1
a95 1
  // Set the section offset of this input file entry.
d97 5
a101 2
  set_offset(unsigned int offset)
  { this->offset_ = offset; }
d108 5
d193 3
d1249 5
d1332 4
d1368 3
a1370 2
      section_map_(), symbol_map_(), has_incremental_info_(false),
      inputs_reader_(), symtab_reader_(), relocs_reader_(), got_plt_reader_(),
d1374 7
d1386 16
d1407 1
a1407 1
  // Map a symbol table entry from the input file to the output symbol table.
d1414 1
a1414 1
  // Map a symbol table entry from the input file to the output symbol table.
d1465 4
d1540 5
d1551 4
@


1.19
log
@	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	global symbol map.
	(Sized_incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incr_relobj::do_add_symbols): Add symbols to global symbol map.
	(Sized_incr_relobj::do_relocate): Remap section indices in incremental
	relocations.
	(Sized_incr_dynobj::do_add_symbols): Add symbols to global symbol map.
	(Sized_incr_dynobj::do_for_all_global_symbols): Remove FIXME.
	(Sized_incr_dynobj::do_for_all_local_got_entries): Likewise.
	* incremental.h
	(Incremental_inputs_reader::global_symbol_reader_at_offset): New
	function.
	(Incremental_binary::apply_incremental_relocs): New function.
	(Incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data member.
	(Sized_incremental_binary::add_global_symbol): New function.
	(Sized_incremental_binary::global_symbol): New function.
	(Sized_incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incremental_binary::symbol_map_): New data member.
	* layout.cc (Layout_task_runner::run): Apply incremental relocations.
	* target.h (Sized_target::apply_relocation): New function.
	* target-reloc.h (apply_relocation): New function.
	* x86_64.cc (Target_x86_64::apply_relocation): New function.
@
text
@d728 1
a728 1
      return (this->info_offset_ + 8
d749 20
d839 1
a839 1
				+ this->info_offset_ + 8
d857 1
a857 1
				+ this->info_offset_ + 8
d1545 4
d1555 26
d1678 11
a1688 1
  { return 0; }
d1734 11
d1760 2
@


1.18
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d901 8
d1218 6
d1296 4
d1328 2
a1329 2
      section_map_(), has_incremental_info_(false), inputs_reader_(),
      symtab_reader_(), relocs_reader_(), got_plt_reader_(),
d1343 14
d1401 5
d1475 3
@


1.17
log
@	* incremental-dump.cc (dump_incremental_inputs): Change signature
	to take a Sized_incremental_binary; change caller.  Use readers
	in Sized_incremental_binary.
	* incremental.cc
	(Sized_incremental_binary::find_incremental_inputs_sections):
	Rename do_find_incremental_inputs_sections to this.
	(Sized_incremental_binary::setup_readers): New function.
	(Sized_incremental_binary::do_check_inputs): Check
	has_incremental_info_ flag; move setup code to setup_readers;
	use input readers.
	(Sized_incremental_binary::do_file_is_unchanged): New function.
	(Sized_incremental_binary::do_get_input_reader): New function.
	* incremental.h (class Incremental_binary): Move to end of file.
	(Incremental_binary::file_is_unchanged): New function.
	(Incremental_binary::do_file_is_unchanged): New function.
	(Incremental_binary::Input_reader): New class.
	(Incremental_binary::get_input_reader): New function.
	(class Sized_incremental_binary): Move to end of file.
	(Sized_incremental_binary::Sized_incremental_binary): Setup the
	input section reader classes.
	(Sized_incremental_binary::has_incremental_info): New function.
	(Sized_incremental_binary::inputs_reader): New function.
	(Sized_incremental_binary::symtab_reader): New function.
	(Sized_incremental_binary::relocs_reader): New function.
	(Sized_incremental_binary::got_plt_reader): New function.
	(Sized_incremental_binary::do_file_is_unchanged): New function.
	(Sized_incremental_binary::Sized_input_reader): New class.
	(Sized_incremental_binary::get_input_reader): New function.
	(Sized_incremental_binary::find_incremental_inputs_sections):
	Rename do_find_incremental_inputs_sections to this.
	(Sized_incremental_binary::setup_readers): New function.
	(Sized_incremental_binary::has_incremental_info_): New data member.
	(Sized_incremental_binary::inputs_reader_): New data member.
	(Sized_incremental_binary::symtab_reader_): New data member.
	(Sized_incremental_binary::relocs_reader_): New data member.
	(Sized_incremental_binary::got_plt_reader_): New data member.
	(Sized_incremental_binary::current_input_file_): New data member.
@
text
@d34 1
a38 1
class Archive;
d46 1
d48 1
d61 8
a74 30
// Code invoked early during an incremental link that checks what files need
// to be relinked.

class Incremental_checker
{
 public:
  // Check if the file named OUTPUT_NAME can be linked incrementally.
  // INCREMENTAL_INPUTS must have the canonical form of the command line
  // and input arguments filled - at this point of linking other fields are
  // probably not filled yet.  TODO: for inputs that don't need to be
  // rebuilt, this function should fill the incremental input information.
  Incremental_checker(const char* output_name,
                      Incremental_inputs* incremental_inputs)
    : output_name_(output_name), incremental_inputs_(incremental_inputs)
  { }

  // Analyzes the output file to check if incremental linking is possible and
  // what files needs to be relinked.
  bool
  can_incrementally_link_output_file();

 private:
  // Name of the output file to analyze.
  const char* output_name_;

  // The Incremental_inputs object. At this stage of link, only the command
  // line and inputs are filled.
  Incremental_inputs* incremental_inputs_;
};

d80 4
a83 2
  Incremental_input_entry(Stringpool::Key filename_key, Timespec mtime)
    : filename_key_(filename_key), offset_(0), info_offset_(0), mtime_(mtime)
d120 5
d130 10
d191 3
d196 34
d237 2
a238 1
  Incremental_script_entry(Stringpool::Key filename_key, Script_info* script,
d240 2
a241 1
    : Incremental_input_entry(filename_key, mtime), script_(script), objects_()
d287 2
a288 2
			   Timespec mtime)
    : Incremental_input_entry(filename_key, mtime), obj_(obj),
d313 1
a313 6
  {
    if (shndx >= this->sections_.size())
      this->sections_.resize(shndx + 1);
    this->sections_[shndx].name_key = name_key;
    this->sections_[shndx].sh_size = sh_size;
  }
d320 5
d328 1
a328 1
  { return this->sections_[n].name_key; }
d333 1
a333 1
  { return this->sections_[n].sh_size; }
d361 6
a366 2
    Stringpool::Key name_key;
    off_t sh_size;
d376 4
a379 2
  Incremental_archive_entry(Stringpool::Key filename_key, Timespec mtime)
    : Incremental_input_entry(filename_key, mtime), members_(), unused_syms_()
d457 2
a458 1
  report_archive_begin(Library_base* arch, Script_info* script_info);
d467 2
a468 1
  report_object(Object* obj, Library_base* arch, Script_info* script_info);
d477 1
a477 1
  report_script(const std::string& filename, Script_info* script,
d584 39
d671 1
a671 2
      int type = Swap16::readval(this->inputs_->p_ + offset + 20);
      this->type_ = static_cast<Incremental_input_type>(type);
d682 7
d703 6
a708 1
    { return this->type_; }
d714 2
a715 2
      gold_assert(this->type_ == INCREMENTAL_INPUT_OBJECT
		  || this->type_ == INCREMENTAL_INPUT_ARCHIVE_MEMBER);
d724 2
a725 2
      gold_assert(this->type_ == INCREMENTAL_INPUT_OBJECT
		  || this->type_ == INCREMENTAL_INPUT_ARCHIVE_MEMBER);
d730 1
a730 1
	      + symndx * 16);
d737 1
a737 1
      switch (this->type_)
d753 1
a753 1
      gold_assert(this->type_ == INCREMENTAL_INPUT_SCRIPT);
d761 1
a761 1
      gold_assert(this->type_ == INCREMENTAL_INPUT_SCRIPT);
d770 1
a770 1
      gold_assert(this->type_ == INCREMENTAL_INPUT_ARCHIVE);
d778 1
a778 1
      gold_assert(this->type_ == INCREMENTAL_INPUT_ARCHIVE);
d786 1
a786 1
      gold_assert(this->type_ == INCREMENTAL_INPUT_ARCHIVE);
d795 1
a795 1
      gold_assert(this->type_ == INCREMENTAL_INPUT_ARCHIVE);
a828 9
    // Information about a global symbol.
    struct Global_symbol_info
    {
      unsigned int output_symndx;
      unsigned int next_offset;
      unsigned int reloc_count;
      unsigned int reloc_offset;
    };

d830 2
a831 2
    Global_symbol_info
    get_global_symbol_info(unsigned int n) const
d833 2
a834 1
      Global_symbol_info info;
d839 17
a855 6
				+ n * 16);
      info.output_symndx = Swap32::readval(p);
      info.next_offset = Swap32::readval(p + 4);
      info.reloc_count = Swap::readval(p + 8);
      info.reloc_offset = Swap::readval(p + 12);
      return info;
d863 2
a864 2
    // The type of input file.
    Incremental_input_type type_;
d871 17
d891 5
d897 2
a898 3
    gold_assert(n < this->input_file_count_);
    Incremental_input_entry_reader input(this, 16 + n * 24);
    return input;
d982 1
a982 3
  {
    return elfcpp::Swap<32, big_endian>::readval(this->p_ + off);
  }
d987 1
a987 3
  {
    return elfcpp::Swap<32, big_endian>::readval(this->p_ + off + 4);
  }
d992 1
a992 3
  {
    return elfcpp::Swap<size, big_endian>::readval(this->p_ + off + 8);
  }
d1002 5
d1087 2
a1088 1
    : output_(output), target_(target)
d1098 3
a1100 8
  check_inputs(Incremental_inputs* incremental_inputs)
  { return this->do_check_inputs(incremental_inputs); }

  // Return TRUE if the file specified by INPUT_ARGUMENT is unchanged
  // with respect to the base file.
  bool
  file_is_unchanged(const Input_argument* input_argument) const
  { return this->do_file_is_unchanged(input_argument); }
d1106 2
a1107 2
  // Wrapper class for a sized Incremental_input_entry_reader.
  
d1130 12
d1151 9
d1162 47
a1208 3
  Input_reader*
  get_input_reader(const char* filename)
  { return this->do_get_input_reader(filename); }
d1257 5
d1266 2
a1267 1
  do_check_inputs(Incremental_inputs* incremental_inputs) = 0;
d1269 1
a1269 2
  // Return TRUE if the file specified by INPUT_ARGUMENT is unchanged
  // with respect to the base file.
d1271 1
a1271 1
  do_file_is_unchanged(const Input_argument* input_argument) const = 0;
d1273 21
a1293 2
  virtual Input_reader*
  do_get_input_reader(const char* filename) = 0;
d1310 3
a1312 2
      has_incremental_info_(false), inputs_reader_(), symtab_reader_(),
      relocs_reader_(), got_plt_reader_(), current_input_file_(0)
d1320 5
d1327 1
a1327 1
  Incremental_inputs_reader<size, big_endian>
d1331 1
a1331 1
  Incremental_symtab_reader<big_endian>
d1335 1
a1335 1
  Incremental_relocs_reader<size, big_endian>
d1339 1
a1339 1
  Incremental_got_plt_reader<big_endian>
d1343 4
d1348 4
d1353 2
a1354 1
  do_check_inputs(Incremental_inputs* incremental_inputs);
d1356 1
a1356 2
  // Return TRUE if the file specified by INPUT_ARGUMENT is unchanged
  // with respect to the base file.
d1358 12
a1369 1
  do_file_is_unchanged(const Input_argument* input_argument) const;
a1370 2
  // Wrapper class for a sized Incremental_input_entry_reader.
  
a1373 4
    typedef Incremental_inputs_reader<size, big_endian> Inputs_reader;
    typedef typename Inputs_reader::Incremental_input_entry_reader
        Input_entry_reader;

d1395 12
d1410 10
a1419 2
  virtual Input_reader*
  do_get_input_reader(const char* filename);
d1435 3
d1444 392
d1837 10
a1846 2
  // Index of the current input file entry.
  int current_input_file_;
@


1.16
log
@	* archive.cc (Archive::include_member): Adjust call to report_object.
	(Add_archive_symbols::run): Add script_info to call to
	report_archive_begin.
	(Lib_group::include_member): Adjust call to report_object.
	(Add_lib_group_symbols::run): Adjust call to report_object.
	* incremental-dump.cc (dump_incremental_inputs): Remove unnecessary
	blocks.  Add object count for script input files.
	* incremental.cc (Incremental_inputs::report_archive_begin): Add
	script_info parameter; change all callers.
	(Incremental_inputs::report_object): Add script_info parameter;
	change all callers.
	(Incremental_inputs::report_script): Store backpointer to
	incremental info entry.
	(Output_section_incremental_inputs::set_final_data_size): Record
	additional information for scripts.
	(Output_section_incremental_inputs::write_info_blocks): Likewise.
	* incremental.h (Incremental_script_entry::add_object): New function.
	(Incremental_script_entry::get_object_count): New function.
	(Incremental_script_entry::get_object): New function.
	(Incremental_script_entry::objects_): New data member; adjust
	constructor.
	(Incremental_inputs::report_archive_begin): Add script_info parameter.
	(Incremental_inputs::report_object): Add script_info parameter.
	(Incremental_inputs_reader::get_object_count): New function.
	(Incremental_inputs_reader::get_object_offset): New function.
	* options.cc (Input_arguments::add_file): Return reference to
	new input argument.
	* options.h (Input_argument::set_script_info): New function.
	(Input_argument::script_info): New function.
	(Input_argument::script_info_): New data member; adjust all
	constructors.
	(Input_file_group::add_file): Return reference to new input argument.
	(Input_file_lib::add_file): Likewise.
	(Input_arguments::add_file): Likewise.
	* readsyms.cc (Add_symbols::run): Adjust call to report_object.
	* script.cc (Parser_closure::Parser_closure): Add script_info
	parameter; adjust all callers.
	(Parser_closure::script_info): New function.
	(Parser_closure::script_info_): New data member.
	(read_input_script): Report scripts earlier to incremental info.
	(script_add_file): Set script_info in Input_argument.
	(script_add_library): Likewise.
	* script.h (Script_options::Script_info): Rewrite class.
@
text
@d45 1
a58 141
// An object representing the ELF file we edit during an incremental build.
// Similar to Object or Dynobj, but operates on Output_file and contains
// method specific to file edition (TBD). This is the abstract parent class
// implemented in Sized_incremental_binary<size, big_endian> for a specific
// endianness and size.

class Incremental_binary
{
 public:
  Incremental_binary(Output_file* output, Target* target)
    : output_(output), target_(target)
  { }

  virtual
  ~Incremental_binary()
  { }

  // Functions and types for the elfcpp::Elf_file interface.  This
  // permit us to use Incremental_binary as the File template parameter for
  // elfcpp::Elf_file.

  // The View class is returned by view.  It must support a single
  // method, data().  This is trivial, because Output_file::get_output_view
  // does what we need.
  class View
  {
   public:
    View(const unsigned char* p)
      : p_(p)
    { }

    const unsigned char*
    data() const
    { return this->p_; }

   private:
    const unsigned char* p_;
  };

  // Return a View.
  View
  view(off_t file_offset, section_size_type data_size)
  { return View(this->output_->get_input_view(file_offset, data_size)); }

  // A location in the file.
  struct Location
  {
    off_t file_offset;
    off_t data_size;

    Location(off_t fo, section_size_type ds)
      : file_offset(fo), data_size(ds)
    { }

    Location()
      : file_offset(0), data_size(0)
    { }
  };

  // Get a View given a Location.
  View
  view(Location loc)
  { return View(this->view(loc.file_offset, loc.data_size)); }

  // Report an error.
  void
  error(const char* format, ...) const ATTRIBUTE_PRINTF_2;

  // Find the .gnu_incremental_inputs and related sections.  It selects the
  // first section of type SHT_GNU_INCREMENTAL_INPUTS,
  // SHT_GNU_INCREMENTAL_SYMTAB, and SHT_GNU_INCREMENTAL_RELOCS.
  // Returns false if the sections are not found.
  bool
  find_incremental_inputs_sections(unsigned int* p_inputs_shndx,
				   unsigned int* p_symtab_shndx,
				   unsigned int* p_relocs_shndx,
				   unsigned int* p_got_plt_shndx,
				   unsigned int* p_strtab_shndx)
  {
    return do_find_incremental_inputs_sections(p_inputs_shndx, p_symtab_shndx,
					       p_relocs_shndx, p_got_plt_shndx,
  					       p_strtab_shndx);
  }

  // Check the .gnu_incremental_inputs section to see whether an incremental
  // build is possible.
  // TODO: on success, should report what files needs to be rebuilt.
  // INCREMENTAL_INPUTS is used to read the canonical form of the command line
  // and read the input arguments.  TODO: for items that don't need to be
  // rebuilt, we should also copy the incremental input information.
  virtual bool
  check_inputs(Incremental_inputs* incremental_inputs)
  { return do_check_inputs(incremental_inputs); }

 protected:
  // Find incremental inputs section.
  virtual bool
  do_find_incremental_inputs_sections(unsigned int* p_inputs_shndx,
				      unsigned int* p_symtab_shndx,
				      unsigned int* p_relocs_shndx,
				      unsigned int* p_got_plt_shndx,
				      unsigned int* p_strtab_shndx) = 0;

  // Check the .gnu_incremental_inputs section to see whether an incremental
  // build is possible.
  virtual bool
  do_check_inputs(Incremental_inputs* incremental_inputs) = 0;

 private:
  // Edited output file object.
  Output_file* output_;
  // Target of the output file.
  Target* target_;
};

template<int size, bool big_endian>
class Sized_incremental_binary : public Incremental_binary
{
 public:
  Sized_incremental_binary(Output_file* output,
                           const elfcpp::Ehdr<size, big_endian>& ehdr,
                           Target* target)
    : Incremental_binary(output, target), elf_file_(this, ehdr)
  { }

 protected:
  virtual bool
  do_find_incremental_inputs_sections(unsigned int* p_inputs_shndx,
				      unsigned int* p_symtab_shndx,
				      unsigned int* p_relocs_shndx,
				      unsigned int* p_got_plt_shndx,
				      unsigned int* p_strtab_shndx);

  virtual bool
  do_check_inputs(Incremental_inputs* incremental_inputs);

 private:
  // Output as an ELF file.
  elfcpp::Elf_file<size, big_endian, Incremental_binary> elf_file_;
};

d552 6
a557 1
  Incremental_inputs_reader(const unsigned char* p, elfcpp::Elf_strtab& strtab)
d807 2
a808 1
  Incremental_symtab_reader(const unsigned char* p) : p_(p)
d811 9
d821 2
a822 1
  unsigned int get_list_head(unsigned int n) const
d828 2
d848 2
a849 1
  Incremental_relocs_reader(const unsigned char* p) : p_(p)
d852 9
d893 2
d903 4
d960 245
@


1.15
log
@	* archive.cc (Library_base::should_include_member): Move
	method here from class Archive.
	(Archive::Archive): Initialize base class.
	(Archive::should_include_member): Move to base class.
	(Archive::do_for_all_unused_symbols): New function.
	(Add_archive_symbols::run): Remove redundant access to
	incremental_inputs.
	(Lib_group::Lib_group): Initialize base class.
	(Lib_group::do_filename): New function.
	(Lib_group::include_member): Pass pointer to Lib_group to
	report_object.
	(Lib_group::do_for_all_unused_symbols): New function.
	(Add_lib_group_symbols::run): Report archive information for
	incremental links.
	* archive.h (class Library_base): New base class.
	(class Archive): Derive from Library_base.
	(Archive::filename): Move to base class.
	(Archive::set_incremental_info): Likewise.
	(Archive::incremental_info): Likewise.
	(Archive::Should_include): Likewise.
	(Archive::should_include_member): Likewise.
	(Archive::Armap_entry): Remove.
	(Archive::Unused_symbol_iterator): Remove.
	(Archive::unused_symbols_begin): Remove.
	(Archive::unused_symbols_end): Remove.
	(Archive::do_filename): New function.
	(Archive::do_get_mtime): New function.
	(Archive::do_for_all_unused_symbols): New function.
	(Archive::task_): Move to base class.
	(Archive::incremental_info_): Likewise.
	(class Lib_group): Derive from Library_base.
	(Lib_group::do_filename): New function.
	(Lib_group::do_get_mtime): New function.
	(Lib_group::do_for_all_unused_symbols): New function.
	(Lib_group::task_): Move to base class.
	* dynobj.cc (Sized_dynobj::do_for_all_global_symbols): New
	function.
	* dynobj.h (Sized_dynobj::do_for_all_global_symbols): New
	function.
	* incremental.cc (Incremental_inputs::report_archive_begin):
	Use Library_base; call library's get_mtime; add incremental inputs
	entry before members.
	(class Unused_symbol_visitor): New class.
	(Incremental_inputs::report_archive_end): Use Library_base; use
	visitor class to record unused symbols; don't add incremental inputs
	entry after members.
	(Incremental_inputs::report_object): Use Library_base.
	* incremental.h
	(Incremental_archive_entry::Incremental_archive_entry): Remove
	unused Archive parameter.
	(Incremental_inputs::report_archive_begin): Use Library_base.
	(Incremental_inputs::report_archive_end): Likewise.
	(Incremental_inputs::report_object): Likewise.
	* object.cc (Sized_relobj::do_for_all_global_symbols): New
	function.
	* object.h (Object::for_all_global_symbols): New function.
	(Object::do_for_all_global_symbols): New function.
	(Sized_relobj::do_for_all_global_symbols): New function.
	* plugin.cc (Sized_pluginobj::do_for_all_global_symbols):  New
	function.
	* plugin.h (Sized_pluginobj::do_for_all_global_symbols):  New
	function.
@
text
@d345 1
a345 1
    : Incremental_input_entry(filename_key, mtime), script_(script)
d348 20
d381 2
d555 1
a555 1
  report_archive_begin(Library_base* arch);
d564 1
a564 1
  report_object(Object* obj, Library_base* arch);
d790 17
@


1.14
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d454 1
a454 2
  Incremental_archive_entry(Stringpool::Key filename_key, Archive*,
			    Timespec mtime)
d533 1
a533 1
  report_archive_begin(Archive* arch);
d537 1
a537 1
  report_archive_end(Archive* arch);
d542 1
a542 1
  report_object(Object* obj, Archive* arch);
@


1.13
log
@	* incremental.h (class Incremental_input_entry): Add virtual
	destructor.
@
text
@d128 1
a128 1
  // SHT_GNU_INCRMENTAL_SYMTAB, and SHT_GNU_INCREMENTAL_RELOCS.
@


1.12
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_GOT_PLT.

gold/ChangeLog:

	* arm.cc (Target_arm::got_size): Add const.
	(Target_arm::got_entry_count): New function.
	(Target_arm::plt_entry_count): New function.
	(Target_arm::first_plt_entry_offset): New function.
	(Target_arm::plt_entry_size): New function.
	(Output_data_plt_arm::entry_count): New function.
	(Output_data_plt_arm::first_plt_entry_offset): New function.
	(Output_data_plt_arm::get_plt_entry_size): New function.
	* i386.cc (Target_i386::got_size): Add const.
	(Target_i386::got_entry_count): New function.
	(Target_i386::plt_entry_count): New function.
	(Target_i386::first_plt_entry_offset): New function.
	(Target_i386::plt_entry_size): New function.
	(Output_data_plt_i386::entry_count): New function.
	(Output_data_plt_i386::first_plt_entry_offset): New function.
	(Output_data_plt_i386::get_plt_entry_size): New function.
	* incremental-dump.cc (dump_incremental_inputs): Adjust call to
	find_incremental_inputs_sections.  Dump incremental_got_plt section.
	* incremental.cc: Include target.h.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Add
	parameter.  Adjust all callers.  Find incremental_got_plt section.
	(Incremental_inputs::create_data_sections): Create incremental_got_plt
	section.
	(Output_section_incremental_inputs::set_final_data_size): Calculate
	size of incremental_got_plt section.
	(Output_section_incremental_inputs::do_write): Write the
	incremental_got_plt section.
	(Got_plt_view_info): New struct.
	(Local_got_offset_visitor): New class.
	(Global_got_offset_visitor): New class.
	(Global_symbol_visitor_got_plt): New class.
	(Output_section_incremental_inputs::write_got_plt): New function.
	* incremental.h (Incremental_binary::find_incremental_inputs_sections):
	Add parameter.  Adjust all callers.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Incremental_inputs::got_plt_section): New function.
	(Incremental_inputs::got_plt_section_): New data member.
	(Incremental_got_plt_reader): New class.
	* layout.cc (Layout::create_incremental_info_sections): Add the
	incremental_got_plt section.
	* object.h (Got_offset_list::get_list): New function.
	(Got offset_list::for_all_got_offsets): New function.
	(Sized_relobj::local_got_offset_list): New function.
	* powerpc.cc (Target_powerpc::got_size): Add const.
	(Target_powerpc::got_entry_count): New function.
	(Target_powerpc::plt_entry_count): New function.
	(Target_powerpc::first_plt_entry_offset): New function.
	(Target_powerpc::plt_entry_size): New function.
	(Output_data_plt_powerpc::entry_count): New function.
	(Output_data_plt_powerpc::first_plt_entry_offset): New function.
	(Output_data_plt_powerpc::get_plt_entry_size): New function.
	* sparc.cc (Target_sparc::got_size): Add const.
	(Target_sparc::got_entry_count): New function.
	(Target_sparc::plt_entry_count): New function.
	(Target_sparc::first_plt_entry_offset): New function.
	(Target_sparc::plt_entry_size): New function.
	(Output_data_plt_sparc::entry_count): New function.
	(Output_data_plt_sparc::first_plt_entry_offset): New function.
	(Output_data_plt_sparc::get_plt_entry_size): New function.
	* symtab.h (Symbol::got_offset_list): New function.
	(Symbol_table::for_all_symbols): New function.
	* target.h (Sized_target::got_entry_count): New function.
	(Sized_target::plt_entry_count): New function.
	(Sized_target::plt_entry_size): New function.
	* x86_64.cc (Target_x86_64::got_size): Add const.
	(Target_x86_64::got_entry_count): New function.
	(Target_x86_64::plt_entry_count): New function.
	(Target_x86_64::first_plt_entry_offset): New function.
	(Target_x86_64::plt_entry_size): New function.
	(Output_data_plt_x86_64::entry_count): New function.
	(Output_data_plt_x86_64::first_plt_entry_offset): New function.
	(Output_data_plt_x86_64::get_plt_entry_size): New function.
@
text
@d244 4
@


1.11
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_SYMTAB,
	SHT_GNU_INCREMENTAL_RELOCS.

gold/ChangeLog:

	* archive.cc: Include incremental.h.
	(Archive::Archive): Initialize incremental_info_.
	(Archive::include_member): Record archive members in incremental info.
	(Add_archive_symbols::run): Record begin and end of an archive in
	incremental info.
	(Lib_group::include_member): Record objects in incremental info.
	* archive.h (Incremental_archive_entry): Forward declaration.
	(Archive::set_incremental_info): New member function.
	(Archive::incremental_info): New member function.
	(Archive::Unused_symbol_iterator): New class.
	(Archive::unused_symbols_begin): New member function.
	(Archive::unused_symbols_end): New member function.
	(Archive::incremental_info_): New data member.
	* incremental-dump.cc (find_input_containing_global): New function.
	(dump_incremental_inputs): Dump new incremental info sections.
	* incremental.cc: Include symtab.h.
	(Output_section_incremental_inputs): New class.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Support
	new incremental info sections.
	(Sized_incremental_binary::do_check_inputs): Likewise.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): New function.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Rewrite.
	(Incremental_inputs::finalize): Do nothing but finalize string table.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Output_section_incremental_inputs::set_final_data_size): New function.
	(Output_section_incremental_inputs::do_write): New function.
	(Output_section_incremental_inputs::write_header): New function.
	(Output_section_incremental_inputs::write_input_files): New function.
	(Output_section_incremental_inputs::write_info_blocks): New function.
	(Output_section_incremental_inputs::write_symtab): New function.
	* incremental.h (Incremental_script_entry): Forward declaration.
	(Incremental_object_entry): Forward declaration.
	(Incremental_archive_entry): Forward declaration.
	(Incremental_inputs): Forward declaration.
	(Incremental_inputs_header_data): Remove.
	(Incremental_inputs_header): Remove.
	(Incremental_inputs_header_write): Remove.
	(Incremental_inputs_entry_data): Remove.
	(Incremental_inputs_entry): Remove.
	(Incremental_inputs_entry_write): Remove.
	(enum Incremental_input_type): Add INCREMENTAL_INPUT_ARCHIVE_MEMBER.
	(Incremental_binary::find_incremental_inputs_sections): Add parameters.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Sized_ncremental_binary::do_find_incremental_inputs_sections):
	Likewise.
	(Incremental_input_entry): New class.
	(Incremental_script_entry): New class.
	(Incremental_object_entry): New class.
	(Incremental_archive_entry): New class.
	(Incremental_inputs::Incremental_inputs): Initialize new data members.
	(Incremental_inputs::report_inputs): Remove.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): Change prototype.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Change prototype.
	(Incremental_inputs::get_reloc_count): New function.
	(Incremental_inputs::set_reloc_count): New function.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::inputs_section): New function.
	(Incremental_inputs::symtab_section): New function.
	(Incremental_inputs::relocs_section): New function.
	(Incremental_inputs::get_stringpool): Add const.
	(Incremental_inputs::command_line): Add const.
	(Incremental_inputs::inputs): Remove.
	(Incremental_inputs::command_line_key): New function.
	(Incremental_inputs::input_file_count): New function.
	(Incremental_inputs::input_files): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::Input_info): Remove.
	(Incremental_inputs::lock_): Remove.
	(Incremental_inputs::inputs_): Change type.
	(Incremental_inputs::inputs_map_): Remove.
	(Incremental_inputs::current_object_entry_): New data member.
	(Incremental_inputs::inputs_section_): New data member.
	(Incremental_inputs::symtab_section_): New data member.
	(Incremental_inputs::relocs_section_): New data member.
	(Incremental_inputs::reloc_count_): New data member.
	(Incremental_inputs_reader): New class.
	(Incremental_symtab_reader): New class.
	(Incremental_relocs_reader): New class.
	* layout.cc (Layout::finalize): Move finalization of incremental info
	and creation of incremental info sections to follow finalization of
	symbol table.  Set offsets for postprocessing sections.
	(Layout::create_incremental_info_sections): Call
	Incremental_inputs::create_data_sections.  Add incremental symtab
	and relocs sections.  Set sh_entsize and sh_link fields.  Arrange for
	sections to layout after input sections.
	* layout.h (struct Timespec): Forward declaration.
	(Layout::incremental_inputs): Add const.
	(Layout::create_incremental_info_sections): Add parameter.
	* main.cc (main): Remove call to Incremental_inputs::report_inputs.
	* object.cc: Include incremental.h.
	(Relobj::finalize_incremental_relocs): New function.
	(Sized_relobj::do_layout): Record input sections in incremental info.
	* object.h (Object::output_section): New function.
	(Object::output_section_offset): Moved from Relobj.
	(Object::get_incremental_reloc_base): New function.
	(Object::get_incremental_reloc_count): New function.
	(Object::do_output_section): New function.
	(Object::do_output_section_offset): Moved from Relobj.
	(Object::do_get_incremental_reloc_base): New function.
	(Object::do_get_incremental_reloc_count): New function.
	(Object::Object): Initialize new data members.
	(Relobj::output_section): Renamed do_output_section and moved to
	protected.
	(Relobj::output_section_offset): Moved to Object.
	(Relobj::do_get_incremental_reloc_base): New function.
	(Relobj::do_get_incremental_reloc_count): New function.
	(Relobj::allocate_incremental_reloc_counts): New function.
	(Relobj::count_incremental_reloc): New function.
	(Relobj::finalize_incremental_relocs): New function.
	(Relobj::next_incremental_reloc_index): New function.
	(Relobj::reloc_counts_): New data member.
	(Relobj::reloc_bases_): New data member.
	(Sized_relobj::do_relocate_sections): Add parameter.  Change caller.
	(Sized_relobj::relocate_sections): Add parameter.  Change all callers.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* plugin.cc (Plugin_manager::add_input_file): Rewrite test for
	incremental link.
	* readsyms.cc (Read_symbols::do_read_symbols): Move reporting of
	archives and object files elsewhere.
	(Add_symbols::run): Report object files here.
	(Finish_group::run): Report end of archive at end of group.
	* reloc.cc: Include layout.h, incremental.h.
	(Sized_relobj::do_read_relocs): Need relocations for incremental link.
	(Sized_relobj::do_scan_relocs): Record relocations for incremental link.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::do_relocate_sections): Write incremental relocations.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* script.cc (read_input_script): Rewrite test for incremental link.
	Change call to Incremental_inputs::report_script.
	* symtab.h (Symbol_table::first_global_index): New function.
	(Symbol_table::output_count): New function.
@
text
@d134 1
d138 2
a139 1
					       p_relocs_shndx, p_strtab_shndx);
d158 1
d188 1
d584 5
d647 3
d904 1
a904 1
  unsigned int get_list_head(unsigned int n)
d933 1
a933 1
  get_r_type(unsigned int off)
d940 1
a940 1
  get_r_shndx(unsigned int off)
d947 1
a947 1
  get_r_offset(unsigned int off)
d954 1
a954 1
  get_r_addend(unsigned int off)
d965 59
@


1.10
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d3 1
a3 1
// Copyright 2009 Free Software Foundation, Inc.
d41 4
a45 1
class Output_section_data;
a50 1
  INCREMENTAL_INPUT_INVALID = 0,
d52 4
a55 206
  INCREMENTAL_INPUT_ARCHIVE = 2,
  INCREMENTAL_INPUT_SHARED_LIBRARY = 3,
  INCREMENTAL_INPUT_SCRIPT = 4
};

// Header of the .gnu_incremental_input section.
struct Incremental_inputs_header_data
{
  // Incremental linker version.
  elfcpp::Elf_Word version;

  // Numer of input files in the link.
  elfcpp::Elf_Word input_file_count;

  // Offset of command line options in .gnu_incremental_strtab.
  elfcpp::Elf_Word command_line_offset;

  // Padding.
  elfcpp::Elf_Word reserved;
};

// Reader class for .gnu_incremental_inputs header. See
// Incremental_inputs_header_data for fields descriptions.

template<int size, bool big_endian>
class Incremental_inputs_header
{
 private:
  typedef Incremental_inputs_header_data Data_type;
  typedef elfcpp::Convert<32, big_endian> Convert32;

 public:
  Incremental_inputs_header(const unsigned char *p)
    : p_(reinterpret_cast<const Data_type*>(p))
  { }

  static const int data_size = sizeof(Data_type);

  elfcpp::Elf_Word
  get_version() const
  { return Convert32::convert_host(this->p_->version); }

  elfcpp::Elf_Word
  get_input_file_count() const
  { return Convert32::convert_host(this->p_->input_file_count); }

  elfcpp::Elf_Word
  get_command_line_offset() const
  { return Convert32::convert_host(this->p_->command_line_offset); }

  elfcpp::Elf_Word
  get_reserved() const
  { return Convert32::convert_host(this->p_->reserved); }

 private:
  const Data_type* p_;
};

// Writer class for .gnu_incremental_inputs header. See
// Incremental_inputs_header_data for fields descriptions.

template<int size, bool big_endian>
class Incremental_inputs_header_write
{
 private:
  typedef Incremental_inputs_header_data Data_type;
  typedef elfcpp::Convert<32, big_endian> Convert32;

 public:
  Incremental_inputs_header_write(unsigned char *p)
    : p_(reinterpret_cast<Data_type*>(p))
  { }

  static const int data_size = sizeof(Data_type);

  void
  put_version(elfcpp::Elf_Word v)
  { this->p_->version = Convert32::convert_host(v); }

  void
  put_input_file_count(elfcpp::Elf_Word v)
  { this->p_->input_file_count = Convert32::convert_host(v); }

  void
  put_command_line_offset(elfcpp::Elf_Word v)
  { this->p_->command_line_offset = Convert32::convert_host(v); }

  void
  put_reserved(elfcpp::Elf_Word v)
  { this->p_->reserved = Convert32::convert_host(v); }

 private:
  Data_type* p_;
};

// Data stored in .gnu_incremental_input after the header for each of the
// Incremental_input_header_data::input_file_count input entries.
struct Incremental_inputs_entry_data
{
  // Offset of file name in .gnu_incremental_strtab section.
  elfcpp::Elf_Word filename_offset;

  // Offset of data in .gnu_incremental_input.
  elfcpp::Elf_Word data_offset;

  // Timestamp (in seconds).
  elfcpp::Elf_Xword timestamp_sec;

  // Nano-second part of timestamp (if supported).
  elfcpp::Elf_Word timestamp_nsec;

  // Type of the input entry.
  elfcpp::Elf_Half input_type;

  // Padding.
  elfcpp::Elf_Half reserved;
};

// Reader class for an .gnu_incremental_inputs entry. See
// Incremental_inputs_entry_data for fields descriptions.
template<int size, bool big_endian>
class Incremental_inputs_entry
{
 private:
  typedef Incremental_inputs_entry_data Data_type;
  typedef elfcpp::Convert<32, big_endian> Convert32;
  typedef elfcpp::Convert<64, big_endian> Convert64;

 public:
  Incremental_inputs_entry(const unsigned char *p)
    : p_(reinterpret_cast<const Data_type*>(p))
  { }

  static const int data_size = sizeof(Data_type);

  elfcpp::Elf_Word
  get_filename_offset()
  { return Convert32::convert_host(this->p_->filename_offset); }

  elfcpp::Elf_Word
  get_data_offset()
  { return Convert32::convert_host(this->p_->data_offset); }

  elfcpp::Elf_Xword
  get_timestamp_sec()
  { return Convert64::convert_host(this->p_->timestamp_sec); }

  elfcpp::Elf_Word
  get_timestamp_nsec()
  { return Convert32::convert_host(this->p_->timestamp_nsec); }

  elfcpp::Elf_Word
  get_input_type()
  { return Convert32::convert_host(this->p_->input_type); }

  elfcpp::Elf_Word
  get_reserved()
  { return Convert32::convert_host(this->p_->reserved); }

 private:
  const Data_type* p_;
};

// Writer class for an .gnu_incremental_inputs entry. See
// Incremental_inputs_entry_data for fields descriptions.
template<int size, bool big_endian>
class Incremental_inputs_entry_write
{
 private:
  typedef Incremental_inputs_entry_data Data_type;
  typedef elfcpp::Convert<32, big_endian> Convert32;
  typedef elfcpp::Convert<64, big_endian> Convert64;

 public:
  Incremental_inputs_entry_write(unsigned char *p)
    : p_(reinterpret_cast<Data_type*>(p))
  { }

  static const int data_size = sizeof(Data_type);

  void
  put_filename_offset(elfcpp::Elf_Word v)
  { this->p_->filename_offset = Convert32::convert_host(v); }

  void
  put_data_offset(elfcpp::Elf_Word v)
  { this->p_->data_offset = Convert32::convert_host(v); }

  void
  put_timestamp_sec(elfcpp::Elf_Xword v)
  { this->p_->timestamp_sec = Convert64::convert_host(v); }

  void
  put_timestamp_nsec(elfcpp::Elf_Word v)
  { this->p_->timestamp_nsec = Convert32::convert_host(v); }

  void
  put_input_type(elfcpp::Elf_Word v)
  { this->p_->input_type = Convert32::convert_host(v); }

  void
  put_reserved(elfcpp::Elf_Word v)
  { this->p_->reserved = Convert32::convert_host(v); }

 private:
  Data_type* p_;
d118 2
a119 1
  View view(Location loc)
d126 4
a129 3
  // Find the .gnu_incremental_inputs section.  It selects the first section
  // of type SHT_GNU_INCREMENTAL_INPUTS.  Returns false if such a section
  // is not found.
d131 8
a138 3
  find_incremental_inputs_section(Location* location,
                                  unsigned int* strtab_shndx)
  { return do_find_incremental_inputs_section(location, strtab_shndx); }
d153 4
a156 2
  do_find_incremental_inputs_section(Location* location,
                                     unsigned int* strtab_shndx) = 0;
d182 4
a185 2
  do_find_incremental_inputs_section(Location* location,
                                     unsigned int* strtab_shndx);
d197 1
d203 1
d231 271
d504 1
d508 2
d511 5
a515 2
    : lock_(new Lock()), inputs_(NULL), command_line_key_(0),
      strtab_(new Stringpool())
d517 1
d524 10
a533 1
  // Record the input arguments obtained from parsing the command line.
d535 1
a535 2
  report_inputs(const Input_arguments& inputs)
  { this->inputs_ = &inputs; }
d537 1
a537 1
  // Record that the input argument INPUT is an archive ARCHIVE.
d539 2
a540 1
  report_archive(const Input_argument* input, Archive* archive);
d542 1
a542 1
  // Record that the input argument INPUT is to an object OBJ.
d544 7
a550 1
  report_object(const Input_argument* input, Object* obj);
d552 1
a552 1
  // Record that the input argument INPUT is to an script SCRIPT.
d554 2
a555 2
  report_script(const Input_argument* input, Timespec mtime,
                Script_info* script);
d561 5
a565 1
  // Create the content of the .gnu_incremental_inputs section.
d567 12
a578 1
  create_incremental_inputs_section_data();
d582 1
a582 1
  get_stringpool()
d588 1
a588 1
  command_line()
d591 13
a603 3
  // Return the input files found in the command line.
  const Input_arguments*
  inputs()
d606 4
d611 31
a641 4
  // Code for each of the four possible variants of create_inputs_section_data.
  template<int size, bool big_endian>
  Output_section_data*
  sized_create_inputs_section_data();
d643 1
a643 3
  // Compute indexes in the order in which the inputs should appear in
  // .gnu_incremental_inputs and put file names to the stringtable.
  // This needs to be done after all the scripts are parsed.
d645 8
a652 4
  void
  finalize_inputs(Input_argument_list::const_iterator begin,
		  Input_argument_list::const_iterator end,
		  unsigned int* index);
d654 18
a671 3
  // Additional data about an input needed for an incremental link.
  // None of these pointers is owned by the structure.
  struct Input_info
d673 3
a675 4
    Input_info()
      : type(INCREMENTAL_INPUT_INVALID), archive(NULL), filename_key(0),
        index(0)
    { }
d677 53
a729 2
    // Type of the file pointed by this argument.
    Incremental_input_type type;
d731 33
a763 1
    union
d765 34
a798 2
      // Present if type == INCREMENTAL_INPUT_ARCHIVE.
      Archive* archive;
d800 15
a814 3
      // Present if type == INCREMENTAL_INPUT_OBJECT or
      // INCREMENTAL_INPUT_SHARED_LIBRARY.
      Object* object;
d816 7
a822 2
      // Present if type == INCREMENTAL_INPUT_SCRIPT.
      Script_info* script;
d825 69
a893 2
    // Key of the filename string in the section stringtable.
    Stringpool::Key filename_key;
d895 13
a907 2
    // Position of the entry information in the output section.
    unsigned int index;
d909 3
a911 3
    // Last modification time of the file.
    Timespec mtime;
  };
d913 2
a914 1
  typedef std::map<const Input_argument*, Input_info> Inputs_info_map;
d916 2
a917 3
  // A lock guarding access to inputs_ during the first phase of linking, when
  // report_ function may be called from multiple threads.
  Lock* lock_;
d919 6
a924 2
  // The list of input arguments obtained from parsing the command line.
  const Input_arguments* inputs_;
d926 6
a931 2
  // A map containing additional information about the input elements.
  Inputs_info_map inputs_map_;
d933 6
a938 3
  // Canonical form of the command line, as will be stored in
  // .gnu_incremental_strtab.
  std::string command_line_;
d940 7
a946 2
  // The key of the command line string in the string pool.
  Stringpool::Key command_line_key_;
d948 3
a950 3
  // The .gnu_incremental_strtab string pool associated with the
  // .gnu_incremental_inputs.
  Stringpool* strtab_;
@


1.9
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d435 2
a436 2
  report_inputs(const Input_arguments& ins)
  { this->inputs_ = &ins; }
@


1.8
log
@2009-12-03  Rafael Avila de Espindola  <espindola@@google.com>

	* incremental.cc (Incremental_inputs_header)
	(Incremental_inputs_header_write, Incremental_inputs_entry)
	(Incremental_inputs_entry_write): Move ...
	* incremental.h (Incremental_inputs_header)
	(Incremental_inputs_header_write, Incremental_inputs_entry)
	(Incremental_inputs_entry_write): here.
@
text
@d435 2
a436 2
  report_inputs(const Input_arguments& inputs)
  { this->inputs_ = &inputs; }
@


1.7
log
@2009-11-24  Rafael Avila de Espindola  <espindola@@google.com>

	* Makefile.am: Build incremental-dump
	* Makefile.in: Regenerate.
	* incremental-dump.cc: New.
	* incremental.cc (Incremental_inputs_header_data,
	Incremental_inputs_entry_data): Move to incremental.h
	* incremental.h: (Incremental_inputs_header_data,
	Incremental_inputs_entry_data): Move from incremental.cc

2009-11-24  Rafael Avila de Espindola  <espindola@@google.com>

	* elfcpp_file.h: Include elfcpp.h.
@
text
@d71 74
d168 90
@


1.6
log
@elfcpp/:
	* elf_file.h: (class Elf_strtab): New class.
gold/:
	* gold.cc: (queue_initial_tasks): Pass incremental_inputs to
	Incremental_checker.
	* incremental.cc: (INCREMENTAL_LINK_VERSION): Change type to
	unsigned int.
	(class Incremental_inputs_header): New class.
	(Incremental_inputs_header_writer): Edit comment.
	(Incremental_inputs_entry): New class.
	(Incremental_inputs_entry_writer): Edit comment.
	(Sized_incremental_binary::do_find_incremental_inputs_section):
	Add *strtab_shndx parameter, fill it.
	(Sized_incremental_binary::do_check_inputs): New method.
	(Incremental_checker::can_incrementally_link_output_file): Use
	Sized_incremental_binary::check_inputs.
	(Incremental_inputs::report_command_line): Save command line in
	command_line_.
	* incremental.h:
	(Incremental_binary::find_incremental_inputs_section): New
	method.
	(Incremental_binary::do_find_incremental_inputs_section): Add
	strtab_shndx parameter.
	(Incremental_binary::do_check_inputs): New pure virtual method.
	(Sized_incremental_binary::do_check_inputs): Declare.
	(Incremental_checker::Incremental_checker): Add incremental_inputs
	parameter, use it to initialize incremental_inputs_.
	(Incremental_checker::incremental_inputs_): New field.
	(Incremental_checker::command_line): New method.
	(Incremental_checker::inputs): New method.
	(Incremental_checker::command_line_): New field.
@
text
@d55 39
@


1.5
log
@elfcpp/:
	* elfcpp_file.h: Fix header guard.  Include <cstdio>.
	(class Elf_recognizer): New class, code from gold/object.cc.
	(Elf_file::find_section_by_type): New method.
gold/:
	* incremental.cc: Include <cstdarg> and "target-select.h".
	(vexplain_no_incremental): New function.
	(explain_no_incremental): New function.
	(Incremental_binary::error): New method.
	(Sized_incremental_binary::do_find_incremental_inputs_section): New
	method.
	(make_sized_incremental_binary): New function.
	(open_incremental_binary): New function.
	(can_incrementally_link_file): Add checks if output is ELF and has
	inputs section.
	* incremental.h: Include "elfcpp_file.h" and "output.h".
	(Incremental_binary): New class.
	(Sized_incremental_binary): New class.
	(open_incremental_binary): Declare.
	* object.cc (is_elf_object): Use
	elfcpp::Elf_recognizer::is_elf_file.
	(make_elf_object): Use elfcpp::Elf_recognizer::is_valid_header.
	* output.h (Output_file::filesize): New method.
@
text
@a121 1

d126 13
a138 2
  find_incremental_inputs_section(Location* location)
  { return do_find_incremental_inputs_section(location); }
d143 7
a149 1
  do_find_incremental_inputs_section(Location* location) = 0;
d170 5
a174 1
  do_find_incremental_inputs_section(Location* location);
d191 8
a198 2
  Incremental_checker(const char* output_name)
    : output_name_(output_name)
d207 1
d209 4
d261 11
d334 4
d340 1
@


1.4
log
@	* gold.cc: Include "incremental.h".
	(queue_initial_tasks): Call Incremental_checker methods.
	* incremental.cc: Include "output.h".
	(Incremental_checker::can_incrementally_link_output_file): New
	method.
	* incremental.h (Incremental_checker): New class.
@
text
@d29 1
d33 1
d55 111
@


1.4.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a28 1
#include "elfcpp_file.h"
a31 1
#include "output.h"
a52 131
// An object representing the ELF file we edit during an incremental build.
// Similar to Object or Dynobj, but operates on Output_file and contains
// method specific to file edition (TBD). This is the abstract parent class
// implemented in Sized_incremental_binary<size, big_endian> for a specific
// endianness and size.

class Incremental_binary
{
 public:
  Incremental_binary(Output_file* output, Target* target)
    : output_(output), target_(target)
  { }

  virtual
  ~Incremental_binary()
  { }

  // Functions and types for the elfcpp::Elf_file interface.  This
  // permit us to use Incremental_binary as the File template parameter for
  // elfcpp::Elf_file.

  // The View class is returned by view.  It must support a single
  // method, data().  This is trivial, because Output_file::get_output_view
  // does what we need.
  class View
  {
   public:
    View(const unsigned char* p)
      : p_(p)
    { }

    const unsigned char*
    data() const
    { return this->p_; }

   private:
    const unsigned char* p_;
  };

  // Return a View.
  View
  view(off_t file_offset, section_size_type data_size)
  { return View(this->output_->get_input_view(file_offset, data_size)); }

  // A location in the file.
  struct Location
  {
    off_t file_offset;
    off_t data_size;

    Location(off_t fo, section_size_type ds)
      : file_offset(fo), data_size(ds)
    { }

    Location()
      : file_offset(0), data_size(0)
    { }
  };

  // Get a View given a Location.
  View view(Location loc)
  { return View(this->view(loc.file_offset, loc.data_size)); }

  // Report an error.
  void
  error(const char* format, ...) const ATTRIBUTE_PRINTF_2;

  // Find the .gnu_incremental_inputs section.  It selects the first section
  // of type SHT_GNU_INCREMENTAL_INPUTS.  Returns false if such a section
  // is not found.
  bool
  find_incremental_inputs_section(Location* location,
                                  unsigned int* strtab_shndx)
  { return do_find_incremental_inputs_section(location, strtab_shndx); }

  // Check the .gnu_incremental_inputs section to see whether an incremental
  // build is possible.
  // TODO: on success, should report what files needs to be rebuilt.
  // INCREMENTAL_INPUTS is used to read the canonical form of the command line
  // and read the input arguments.  TODO: for items that don't need to be
  // rebuilt, we should also copy the incremental input information.
  virtual bool
  check_inputs(Incremental_inputs* incremental_inputs)
  { return do_check_inputs(incremental_inputs); }

 protected:
  // Find incremental inputs section.
  virtual bool
  do_find_incremental_inputs_section(Location* location,
                                     unsigned int* strtab_shndx) = 0;

  // Check the .gnu_incremental_inputs section to see whether an incremental
  // build is possible.
  virtual bool
  do_check_inputs(Incremental_inputs* incremental_inputs) = 0;

 private:
  // Edited output file object.
  Output_file* output_;
  // Target of the output file.
  Target* target_;
};

template<int size, bool big_endian>
class Sized_incremental_binary : public Incremental_binary
{
 public:
  Sized_incremental_binary(Output_file* output,
                           const elfcpp::Ehdr<size, big_endian>& ehdr,
                           Target* target)
    : Incremental_binary(output, target), elf_file_(this, ehdr)
  { }

 protected:
  virtual bool
  do_find_incremental_inputs_section(Location* location,
                                     unsigned int* strtab_shndx);

  virtual bool
  do_check_inputs(Incremental_inputs* incremental_inputs);

 private:
  // Output as an ELF file.
  elfcpp::Elf_file<size, big_endian, Incremental_binary> elf_file_;
};

// Create an Incremental_binary object for FILE. Returns NULL is this is not
// possible, e.g. FILE is not an ELF file or has an unsupported target.
Incremental_binary*
open_incremental_binary(Output_file* file);

d58 2
a59 8
  // Check if the file named OUTPUT_NAME can be linked incrementally.
  // INCREMENTAL_INPUTS must have the canonical form of the command line
  // and input arguments filled - at this point of linking other fields are
  // probably not filled yet.  TODO: for inputs that don't need to be
  // rebuilt, this function should fill the incremental input information.
  Incremental_checker(const char* output_name,
                      Incremental_inputs* incremental_inputs)
    : output_name_(output_name), incremental_inputs_(incremental_inputs)
a67 1
  // Name of the output file to analyze.
a68 4

  // The Incremental_inputs object. At this stage of link, only the command
  // line and inputs are filled.
  Incremental_inputs* incremental_inputs_;
a116 11
  // Return the canonical form of the command line, as will be stored in
  // .gnu_incremental_strtab.
  const std::string&
  command_line()
  { return this->command_line_; }

  // Return the input files found in the command line.
  const Input_arguments*
  inputs()
  { return this->inputs_; }

a178 4
  // Canonical form of the command line, as will be stored in
  // .gnu_incremental_strtab.
  std::string command_line_;

a180 1

@


1.3
log
@	* fileread.cc (File_read::get_mtime): New method.
	* fileread.h (Timespec): New structure.
	(File_read::get_mtime): New method.
	* incremental.cc (Incremental_inputs_entry_data::timestamp_usec):
	Renamed from timestamp_nsec.
	(Incremental_inputs_entry_write::timestamp_sec): Fix argument to
	Elf_Xword.
	(Incremental_inputs_entry_write::timestamp_usec): Renamed from
	timestamp_nsec.
	(Incremental_inputs::report_archive): Save mtime; style fix.
	(Incremental_inputs::report_obejct): Save mtime; style fix.
	(Incremental_inputs::report_script): Save mtime; style fix.
	(Incremental_inputs::finalize_inputs): Style fix.
	(Incremental_inputs::finalize): Style fix.
	(Incremental_inputs::create_input_section_data): Store inputs
	mtime.
	* incremental.h (Incremental_inputs::report_script): Add mtime
	argument.
	(Incremental_inputs::Input_info::Input_info): Intialize only one
	union member.
	(Incremental_inputs::Input_info::archive): Move to nameless
	union.
	(Incremental_inputs::Input_info::obejct): Move to nameless union.
	(Incremental_inputs::Input_info::script): Move to nameless union.
	(Incremental_inputs::mtime): New field.
	* script.cc (read_input_script): Pass file mtime to
	Incremental_input.
	* script.h (Script_info::inputs): Style fix.
@
text
@d53 18
d148 1
a148 1
  
d152 1
a152 1
  
d162 1
a162 1
    
d172 1
a172 1
  
@


1.2
log
@	* gold.h (Incremental_argument_list): Remove (invalid) forward
	declaration.
	* incremental.cc (Incremental_inputs::report_achive): New method.
	(Incremental_inputs::report_object): New method.
	(Incremental_inputs::report_script): New method.
	(Incremental_inputs::finalize_inputs): New method.
	(Incremental_inputs::finalize): Call finalize_inputs().
	(Incremental_inputs::sized_create_incremental_inputs_section_data):
	Create inputs entries.
	* incremental.h (Incremental_input_type): New enum.
	(Incremental_inputs::Incremental_input): Initialize new fields.
	(Incremental_inputs::report_inputs): New method.
	(Incremental_inputs::report_achive): New method.
	(Incremental_inputs::report_object): New method.
	(Incremental_inputs::report_script): New method.
	(Incremental_inputs::finalize_inputs): New method.
	(Incremental_inputs::Input_info): New struct.
	(Incremental_inputs::Input_info_map): New typedef.
	(Incremental_inputs::lock_): New field.
	(Incremental_inputs::Inputs_): New field.
	(Incremental_inputs::Inputs_map): New field.
	* main.cc (main): Call Incremental_input::report_inputs.
	* options.h (Input_argument_list): Typedef moved from
	Input_arguments.
	(Input_file_group::Files): Remove, use ::Input_argument_list.
	(Input_file_group::Input_argument_list): Remove, use
	::Input_argument_list.
	* plugin.cc (Plugin_manager::add_input_file): Add error in
	incremental build.
	* read_syms.cc (do_read_syms): Call Incremental_input::report_*
	functions.
	* script.cc (read_input_script): Call
	Incremental_input::report_script.
	* script.h (Script_info): New class.
@
text
@d31 1
d83 2
a84 1
  report_script(const Input_argument* input, Script_info* script);
d119 2
a120 2
      : type(INCREMENTAL_INPUT_INVALID), archive(NULL), object(NULL),
        script(NULL), filename_key(0), index(0)
d126 12
a137 9
    // Present if type == INCREMENTAL_INPUT_ARCHIVE.
    Archive* archive;

    // Present if type == INCREMENTAL_INPUT_OBJECT or
    // INCREMENTAL_INPUT_SHARED_LIBRARY.
    Object* object;

    // Present if type == INCREMENTAL_INPUT_SCRIPT.
    Script_info* script;
d144 3
@


1.1
log
@	* incremental.cc (Incremental_inputs_header_data): Renamed from
	Incremental_input_header_data.
	(Incremental_inputs_header_data::data_size): New field.
	(Incremental_inputs_header_data::put_input_file_count): Renamed
	from input_file_count.
	(Incremental_inputs_header_data::put_command_line_offset): Renamed
	from command_line_offset.
	(Incremental_inputs_header_data::put_reserved): Renamed from
	put_reserved.
	(Incremental_inputs_entry_data): Renamed from
	Incremental_input_entry_data.
	(Incremental_inputs_entry_data::data_size): New field.
	(Incremental_inputs::report_command_line): New method.
	(Incremental_inputs::finalize): New method.
	(Incremental_inputs::create_incremental_inputs_data): New method.
	(Incremental_inputs::sized_create_incremental_inputs_data): New method.
	* incremental.h: New file.
	* layout.cc (Layout::Layout): Handle new incremental_inputs_.
       (Layout::finalize): Create incremental inputs section in
	incremental builds.
       (Layout::create_incremental_info_sections): New method.
	* layout.h (Layout::incremental_inputs): New method.
       (Layout::create_incremental_info_sections): New method.
       (Layout::incremental_inputs_): New field.
	* main.cc (main): Notify Incremental_input of the command line.
@
text
@d26 1
d41 11
d58 2
a59 1
    : command_line_key_(0), strtab_(new Stringpool())
d66 18
a83 1
  
d91 2
a92 2
  
  // Return the .gnu_incremental_strtab stringpool. 
d101 51
a151 1
  sized_create_inputs_section_data();  
@

