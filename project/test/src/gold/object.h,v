head	1.126;
access;
symbols
	binutils-2_24-branch:1.126.0.2
	binutils-2_24-branchpoint:1.126
	binutils-2_21_1:1.103.2.1
	binutils-2_23_2:1.117
	binutils-2_23_1:1.117
	binutils-2_23:1.117
	binutils-2_23-branch:1.117.0.2
	binutils-2_23-branchpoint:1.117
	binutils-2_22_branch:1.113.0.4
	binutils-2_22:1.113
	binutils-2_22-branch:1.113.0.2
	binutils-2_22-branchpoint:1.113
	binutils-2_21:1.103
	binutils-2_21-branch:1.103.0.2
	binutils-2_21-branchpoint:1.103
	binutils-2_20_1:1.78.2.2
	binutils-2_20:1.78.2.1
	binutils-arc-20081103-branch:1.66.0.4
	binutils-arc-20081103-branchpoint:1.66
	binutils-2_20-branch:1.78.0.2
	binutils-2_20-branchpoint:1.78
	dje-cgen-play1-branch:1.75.0.2
	dje-cgen-play1-branchpoint:1.75
	arc-20081103-branch:1.66.0.2
	arc-20081103-branchpoint:1.66
	binutils-2_19_1:1.64
	binutils-2_19:1.64
	binutils-2_19-branch:1.64.0.2
	binutils-2_19-branchpoint:1.64
	binutils_latest_snapshot:1.126
	added-to-binutils:1.55;
locks; strict;
comment	@ * @;


1.126
date	2013.08.23.07.54.19;	author nickc;	state Exp;
branches;
next	1.125;

1.125
date	2013.07.31.18.47.50;	author ccoutant;	state Exp;
branches;
next	1.124;

1.124
date	2013.05.21.20.56.13;	author ccoutant;	state Exp;
branches;
next	1.123;

1.123
date	2013.03.10.23.08.18;	author amodra;	state Exp;
branches;
next	1.122;

1.122
date	2012.10.23.21.34.58;	author ccoutant;	state Exp;
branches;
next	1.121;

1.121
date	2012.09.25.00.59.25;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2012.09.12.18.29.18;	author ian;	state Exp;
branches;
next	1.119;

1.119
date	2012.09.05.00.34.20;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2012.08.11.04.41.27;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2012.04.26.00.07.17;	author ian;	state Exp;
branches;
next	1.116;

1.116
date	2012.03.21.19.02.21;	author ccoutant;	state Exp;
branches;
next	1.115;

1.115
date	2012.02.29.21.22.29;	author ccoutant;	state Exp;
branches;
next	1.114;

1.114
date	2011.12.19.21.07.16;	author ian;	state Exp;
branches;
next	1.113;

1.113
date	2011.08.01.18.25.21;	author ccoutant;	state Exp;
branches;
next	1.112;

1.112
date	2011.06.30.00.50.13;	author ian;	state Exp;
branches;
next	1.111;

1.111
date	2011.06.25.00.40.56;	author ian;	state Exp;
branches;
next	1.110;

1.110
date	2011.05.24.21.57.28;	author ccoutant;	state Exp;
branches;
next	1.109;

1.109
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.108;

1.108
date	2011.04.25.20.28.48;	author ccoutant;	state Exp;
branches;
next	1.107;

1.107
date	2011.04.12.00.44.48;	author ccoutant;	state Exp;
branches;
next	1.106;

1.106
date	2011.03.30.01.31.57;	author ccoutant;	state Exp;
branches;
next	1.105;

1.105
date	2011.02.10.01.12.37;	author ian;	state Exp;
branches;
next	1.104;

1.104
date	2010.12.14.19.03.30;	author rwild;	state Exp;
branches;
next	1.103;

1.103
date	2010.09.08.23.54.51;	author dougkwan;	state Exp;
branches
	1.103.2.1;
next	1.102;

1.102
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.101;

1.101
date	2010.08.19.22.50.15;	author ian;	state Exp;
branches;
next	1.100;

1.100
date	2010.08.12.22.15.00;	author ccoutant;	state Exp;
branches;
next	1.99;

1.99
date	2010.08.12.22.01.11;	author ccoutant;	state Exp;
branches;
next	1.98;

1.98
date	2010.08.02.13.34.33;	author ian;	state Exp;
branches;
next	1.97;

1.97
date	2010.07.12.17.59.58;	author ccoutant;	state Exp;
branches;
next	1.96;

1.96
date	2010.06.10.17.20.26;	author ccoutant;	state Exp;
branches;
next	1.95;

1.95
date	2010.04.07.22.58.23;	author ccoutant;	state Exp;
branches;
next	1.94;

1.94
date	2010.03.22.14.18.24;	author espindola;	state Exp;
branches;
next	1.93;

1.93
date	2010.03.03.19.31.54;	author ian;	state Exp;
branches;
next	1.92;

1.92
date	2010.02.11.07.42.17;	author ian;	state Exp;
branches;
next	1.91;

1.91
date	2010.01.29.18.23.18;	author dougkwan;	state Exp;
branches;
next	1.90;

1.90
date	2010.01.26.21.29.10;	author dougkwan;	state Exp;
branches;
next	1.89;

1.89
date	2010.01.20.17.29.52;	author dougkwan;	state Exp;
branches;
next	1.88;

1.88
date	2010.01.05.21.52.51;	author ian;	state Exp;
branches;
next	1.87;

1.87
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.86;

1.86
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	2009.11.05.06.24.39;	author ian;	state Exp;
branches;
next	1.84;

1.84
date	2009.10.29.05.16.23;	author ian;	state Exp;
branches;
next	1.83;

1.83
date	2009.10.25.16.57.32;	author dougkwan;	state Exp;
branches;
next	1.82;

1.82
date	2009.10.15.00.33.18;	author ian;	state Exp;
branches;
next	1.81;

1.81
date	2009.10.09.23.18.19;	author dougkwan;	state Exp;
branches;
next	1.80;

1.80
date	2009.10.06.22.58.27;	author ian;	state Exp;
branches;
next	1.79;

1.79
date	2009.09.30.22.21.13;	author ian;	state Exp;
branches;
next	1.78;

1.78
date	2009.08.18.23.49.29;	author dougkwan;	state Exp;
branches
	1.78.2.1;
next	1.77;

1.77
date	2009.08.05.20.51.56;	author tmsriram;	state Exp;
branches;
next	1.76;

1.76
date	2009.07.17.01.07.33;	author ian;	state Exp;
branches;
next	1.75;

1.75
date	2009.06.05.18.16.31;	author dougkwan;	state Exp;
branches;
next	1.74;

1.74
date	2009.05.19.22.14.17;	author ccoutant;	state Exp;
branches;
next	1.73;

1.73
date	2009.03.24.18.42.10;	author ian;	state Exp;
branches;
next	1.72;

1.72
date	2009.03.14.05.56.46;	author ian;	state Exp;
branches;
next	1.71;

1.71
date	2009.03.01.22.22.02;	author ian;	state Exp;
branches;
next	1.70;

1.70
date	2009.02.28.04.39.57;	author ian;	state Exp;
branches;
next	1.69;

1.69
date	2009.02.13.19.04.45;	author ccoutant;	state Exp;
branches;
next	1.68;

1.68
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	1.67;

1.67
date	2008.12.23.02.02.20;	author ccoutant;	state Exp;
branches;
next	1.66;

1.66
date	2008.09.29.21.10.26;	author ccoutant;	state Exp;
branches;
next	1.65;

1.65
date	2008.09.19.22.54.57;	author ccoutant;	state Exp;
branches;
next	1.64;

1.64
date	2008.07.25.04.25.49;	author ian;	state Exp;
branches;
next	1.63;

1.63
date	2008.07.24.01.24.50;	author ian;	state Exp;
branches;
next	1.62;

1.62
date	2008.07.22.22.08.43;	author ian;	state Exp;
branches;
next	1.61;

1.61
date	2008.07.10.23.01.19;	author ian;	state Exp;
branches;
next	1.60;

1.60
date	2008.05.21.21.37.44;	author ian;	state Exp;
branches;
next	1.59;

1.59
date	2008.05.01.01.23.21;	author ccoutant;	state Exp;
branches;
next	1.58;

1.58
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.57;

1.57
date	2008.04.02.20.58.21;	author ian;	state Exp;
branches;
next	1.56;

1.56
date	2008.03.25.18.37.16;	author ccoutant;	state Exp;
branches;
next	1.55;

1.55
date	2008.03.16.23.51.19;	author iant;	state Exp;
branches;
next	1.54;

1.54
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.53;

1.53
date	2008.02.29.19.19.17;	author iant;	state Exp;
branches;
next	1.52;

1.52
date	2008.02.27.22.38.18;	author iant;	state Exp;
branches;
next	1.51;

1.51
date	2008.02.12.00.28.48;	author iant;	state Exp;
branches;
next	1.50;

1.50
date	2008.02.07.01.51.25;	author iant;	state Exp;
branches;
next	1.49;

1.49
date	2008.02.06.20.32.10;	author iant;	state Exp;
branches;
next	1.48;

1.48
date	2008.02.06.08.13.50;	author iant;	state Exp;
branches;
next	1.47;

1.47
date	2008.02.04.05.41.40;	author iant;	state Exp;
branches;
next	1.46;

1.46
date	2008.01.02.23.48.49;	author iant;	state Exp;
branches;
next	1.45;

1.45
date	2007.12.21.21.19.45;	author iant;	state Exp;
branches;
next	1.44;

1.44
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.43;

1.43
date	2007.12.14.19.00.21;	author iant;	state Exp;
branches;
next	1.42;

1.42
date	2007.12.14.18.50.01;	author iant;	state Exp;
branches;
next	1.41;

1.41
date	2007.12.14.05.24.17;	author iant;	state Exp;
branches;
next	1.40;

1.40
date	2007.12.07.00.54.28;	author iant;	state Exp;
branches;
next	1.39;

1.39
date	2007.12.06.05.55.50;	author iant;	state Exp;
branches;
next	1.38;

1.38
date	2007.12.01.06.34.12;	author iant;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.27.06.13.33;	author iant;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.14.22.31.02;	author iant;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.14.16.53.24;	author iant;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.14.07.34.53;	author iant;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.09.23.16.54;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.02.03.28.52;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.17.06.24.50;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.14.06.49.14;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.10.06.33.56;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.08.07.22.21;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.06.05.40.44;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.25.17.50.26;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.21.07.20.01;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.16.17.42.48;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.06.06.28.56;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.30.23.52.50;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.16.00.38.25;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.07.18.51.39;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.03.18.38.43;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.03.18.26.10;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.20.20.40.49;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.10.18.54.06;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.06.20.40.16;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.29.22.34.01;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.09.29.19.58.16;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.09.27.22.53.42;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.26.21.50.25;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.26.21.20.56;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.26.21.00.34;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.21.22.13.18;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.18.22.29.20;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.04.23.10.59;	author iant;	state Exp;
branches;
next	;

1.103.2.1
date	2011.02.10.01.15.28;	author ian;	state Exp;
branches;
next	;

1.78.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	1.78.2.2;

1.78.2.2
date	2009.11.05.06.25.01;	author ian;	state Exp;
branches;
next	;


desc
@@


1.126
log
@	PR binutils/15834
	Fix typos:
---
 bfd/bfdio.c                                  |  2 +-
 bfd/elf32-spu.c                              |  2 +-
 bfd/elfnn-aarch64.c                          |  2 +-
 binutils/od-xcoff.c                          |  2 +-
 config/tcl.m4                                |  2 +-
 gas/config/tc-ia64.c                         |  2 +-
 gas/config/tc-sparc.c                        |  2 +-
 gas/config/tc-z80.c                          | 12 ++++++------
 gas/doc/c-i386.texi                          |  6 +++---
 gas/doc/c-m32r.texi                          |  2 +-
 gas/testsuite/gas/d10v/instruction_packing.d |  2 +-
 gas/testsuite/gas/z80/atend.d                |  2 +-
 gold/object.h                                |  2 +-
 include/gdb/remote-sim.h                     |  2 +-
 include/opcode/ChangeLog                     |  2 +-
 include/opcode/i960.h                        |  2 +-
 ld/testsuite/ld-mips-elf/mips16-pic-1.inc    |  2 +-
 opcodes/aarch64-asm.c                        |  2 +-
 opcodes/aarch64-dis.c                        |  2 +-
 opcodes/msp430-dis.c                         |  2 +-
@
text
@// object.h -- support for an object file for linking in gold  -*- C++ -*-

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#ifndef GOLD_OBJECT_H
#define GOLD_OBJECT_H

#include <string>
#include <vector>

#include "elfcpp.h"
#include "elfcpp_file.h"
#include "fileread.h"
#include "target.h"
#include "archive.h"

namespace gold
{

class General_options;
class Task;
class Cref;
class Layout;
class Output_data;
class Output_section;
class Output_file;
class Output_symtab_xindex;
class Pluginobj;
class Dynobj;
class Object_merge_map;
class Relocatable_relocs;
struct Symbols_data;

template<typename Stringpool_char>
class Stringpool_template;

// Data to pass from read_symbols() to add_symbols().

struct Read_symbols_data
{
  Read_symbols_data()
    : section_headers(NULL), section_names(NULL), symbols(NULL),
      symbol_names(NULL), versym(NULL), verdef(NULL), verneed(NULL)
  { }

  ~Read_symbols_data();

  // Section headers.
  File_view* section_headers;
  // Section names.
  File_view* section_names;
  // Size of section name data in bytes.
  section_size_type section_names_size;
  // Symbol data.
  File_view* symbols;
  // Size of symbol data in bytes.
  section_size_type symbols_size;
  // Offset of external symbols within symbol data.  This structure
  // sometimes contains only external symbols, in which case this will
  // be zero.  Sometimes it contains all symbols.
  section_offset_type external_symbols_offset;
  // Symbol names.
  File_view* symbol_names;
  // Size of symbol name data in bytes.
  section_size_type symbol_names_size;

  // Version information.  This is only used on dynamic objects.
  // Version symbol data (from SHT_GNU_versym section).
  File_view* versym;
  section_size_type versym_size;
  // Version definition data (from SHT_GNU_verdef section).
  File_view* verdef;
  section_size_type verdef_size;
  unsigned int verdef_info;
  // Needed version data  (from SHT_GNU_verneed section).
  File_view* verneed;
  section_size_type verneed_size;
  unsigned int verneed_info;
};

// Information used to print error messages.

struct Symbol_location_info
{
  std::string source_file;
  std::string enclosing_symbol_name;
  elfcpp::STT enclosing_symbol_type;
};

// Data about a single relocation section.  This is read in
// read_relocs and processed in scan_relocs.

struct Section_relocs
{
  Section_relocs()
    : contents(NULL)
  { }

  ~Section_relocs()
  { delete this->contents; }

  // Index of reloc section.
  unsigned int reloc_shndx;
  // Index of section that relocs apply to.
  unsigned int data_shndx;
  // Contents of reloc section.
  File_view* contents;
  // Reloc section type.
  unsigned int sh_type;
  // Number of reloc entries.
  size_t reloc_count;
  // Output section.
  Output_section* output_section;
  // Whether this section has special handling for offsets.
  bool needs_special_offset_handling;
  // Whether the data section is allocated (has the SHF_ALLOC flag set).
  bool is_data_section_allocated;
};

// Relocations in an object file.  This is read in read_relocs and
// processed in scan_relocs.

struct Read_relocs_data
{
  Read_relocs_data()
    : local_symbols(NULL)
  { }

  ~Read_relocs_data()
  { delete this->local_symbols; }

  typedef std::vector<Section_relocs> Relocs_list;
  // The relocations.
  Relocs_list relocs;
  // The local symbols.
  File_view* local_symbols;
};

// The Xindex class manages section indexes for objects with more than
// 0xff00 sections.

class Xindex
{
 public:
  Xindex(int large_shndx_offset)
    : large_shndx_offset_(large_shndx_offset), symtab_xindex_()
  { }

  // Initialize the symtab_xindex_ array, given the object and the
  // section index of the symbol table to use.
  template<int size, bool big_endian>
  void
  initialize_symtab_xindex(Object*, unsigned int symtab_shndx);

  // Read in the symtab_xindex_ array, given its section index.
  // PSHDRS may optionally point to the section headers.
  template<int size, bool big_endian>
  void
  read_symtab_xindex(Object*, unsigned int xindex_shndx,
		     const unsigned char* pshdrs);

  // Symbol SYMNDX in OBJECT has a section of SHN_XINDEX; return the
  // real section index.
  unsigned int
  sym_xindex_to_shndx(Object* object, unsigned int symndx);

 private:
  // The type of the array giving the real section index for symbols
  // whose st_shndx field holds SHN_XINDEX.
  typedef std::vector<unsigned int> Symtab_xindex;

  // Adjust a section index if necessary.  This should only be called
  // for ordinary section indexes.
  unsigned int
  adjust_shndx(unsigned int shndx)
  {
    if (shndx >= elfcpp::SHN_LORESERVE)
      shndx += this->large_shndx_offset_;
    return shndx;
  }

  // Adjust to apply to large section indexes.
  int large_shndx_offset_;
  // The data from the SHT_SYMTAB_SHNDX section.
  Symtab_xindex symtab_xindex_;
};

// A GOT offset list.  A symbol may have more than one GOT offset
// (e.g., when mixing modules compiled with two different TLS models),
// but will usually have at most one.  GOT_TYPE identifies the type of
// GOT entry; its values are specific to each target.

class Got_offset_list
{
 public:
  Got_offset_list()
    : got_type_(-1U), got_offset_(0), got_next_(NULL)
  { }

  Got_offset_list(unsigned int got_type, unsigned int got_offset)
    : got_type_(got_type), got_offset_(got_offset), got_next_(NULL)
  { }

  ~Got_offset_list()
  {
    if (this->got_next_ != NULL)
      {
        delete this->got_next_;
        this->got_next_ = NULL;
      }
  }

  // Initialize the fields to their default values.
  void
  init()
  {
    this->got_type_ = -1U;
    this->got_offset_ = 0;
    this->got_next_ = NULL;
  }

  // Set the offset for the GOT entry of type GOT_TYPE.
  void
  set_offset(unsigned int got_type, unsigned int got_offset)
  {
    if (this->got_type_ == -1U)
      {
        this->got_type_ = got_type;
        this->got_offset_ = got_offset;
      }
    else
      {
        for (Got_offset_list* g = this; g != NULL; g = g->got_next_)
          {
            if (g->got_type_ == got_type)
              {
                g->got_offset_ = got_offset;
                return;
              }
          }
        Got_offset_list* g = new Got_offset_list(got_type, got_offset);
        g->got_next_ = this->got_next_;
        this->got_next_ = g;
      }
  }

  // Return the offset for a GOT entry of type GOT_TYPE.
  unsigned int
  get_offset(unsigned int got_type) const
  {
    for (const Got_offset_list* g = this; g != NULL; g = g->got_next_)
      {
        if (g->got_type_ == got_type)
          return g->got_offset_;
      }
    return -1U;
  }

  // Return a pointer to the list, or NULL if the list is empty.
  const Got_offset_list*
  get_list() const
  {
    if (this->got_type_ == -1U)
      return NULL;
    return this;
  }

  // Abstract visitor class for iterating over GOT offsets.
  class Visitor
  {
   public:
    Visitor()
    { }

    virtual
    ~Visitor()
    { }

    virtual void
    visit(unsigned int, unsigned int) = 0;
  };

  // Loop over all GOT offset entries, calling a visitor class V for each.
  void
  for_all_got_offsets(Visitor* v) const
  {
    if (this->got_type_ == -1U)
      return;
    for (const Got_offset_list* g = this; g != NULL; g = g->got_next_)
      v->visit(g->got_type_, g->got_offset_);
  }

 private:
  unsigned int got_type_;
  unsigned int got_offset_;
  Got_offset_list* got_next_;
};

// Object is an abstract base class which represents either a 32-bit
// or a 64-bit input object.  This can be a regular object file
// (ET_REL) or a shared object (ET_DYN).

class Object
{
 public:
  typedef std::vector<Symbol*> Symbols;

  // NAME is the name of the object as we would report it to the user
  // (e.g., libfoo.a(bar.o) if this is in an archive.  INPUT_FILE is
  // used to read the file.  OFFSET is the offset within the input
  // file--0 for a .o or .so file, something else for a .a file.
  Object(const std::string& name, Input_file* input_file, bool is_dynamic,
	 off_t offset = 0)
    : name_(name), input_file_(input_file), offset_(offset), shnum_(-1U),
      is_dynamic_(is_dynamic), is_needed_(false), uses_split_stack_(false),
      has_no_split_stack_(false), no_export_(false),
      is_in_system_directory_(false), as_needed_(false), xindex_(NULL)
  {
    if (input_file != NULL)
      {
	input_file->file().add_object();
	this->is_in_system_directory_ = input_file->is_in_system_directory();
	this->as_needed_ = input_file->options().as_needed();
      }
  }

  virtual ~Object()
  {
    if (this->input_file_ != NULL)
      this->input_file_->file().remove_object();
  }

  // Return the name of the object as we would report it to the user.
  const std::string&
  name() const
  { return this->name_; }

  // Get the offset into the file.
  off_t
  offset() const
  { return this->offset_; }

  // Return whether this is a dynamic object.
  bool
  is_dynamic() const
  { return this->is_dynamic_; }

  // Return whether this object is needed--true if it is a dynamic
  // object which defines some symbol referenced by a regular object.
  // We keep the flag here rather than in Dynobj for convenience when
  // setting it.
  bool
  is_needed() const
  { return this->is_needed_; }

  // Record that this object is needed.
  void
  set_is_needed()
  { this->is_needed_ = true; }

  // Return whether this object was compiled with -fsplit-stack.
  bool
  uses_split_stack() const
  { return this->uses_split_stack_; }

  // Return whether this object contains any functions compiled with
  // the no_split_stack attribute.
  bool
  has_no_split_stack() const
  { return this->has_no_split_stack_; }

  // Returns NULL for Objects that are not dynamic objects.  This method
  // is overridden in the Dynobj class.
  Dynobj*
  dynobj()
  { return this->do_dynobj(); }

  // Returns NULL for Objects that are not plugin objects.  This method
  // is overridden in the Pluginobj class.
  Pluginobj*
  pluginobj()
  { return this->do_pluginobj(); }

  // Get the file.  We pass on const-ness.
  Input_file*
  input_file()
  {
    gold_assert(this->input_file_ != NULL);
    return this->input_file_;
  }

  const Input_file*
  input_file() const
  {
    gold_assert(this->input_file_ != NULL);
    return this->input_file_;
  }

  // Lock the underlying file.
  void
  lock(const Task* t)
  {
    if (this->input_file_ != NULL)
      this->input_file_->file().lock(t);
  }

  // Unlock the underlying file.
  void
  unlock(const Task* t)
  {
    if (this->input_file_ != NULL)
      this->input_file()->file().unlock(t);
  }

  // Return whether the underlying file is locked.
  bool
  is_locked() const
  { return this->input_file_ != NULL && this->input_file_->file().is_locked(); }

  // Return the token, so that the task can be queued.
  Task_token*
  token()
  {
    if (this->input_file_ == NULL)
      return NULL;
    return this->input_file()->file().token();
  }

  // Release the underlying file.
  void
  release()
  {
    if (this->input_file_ != NULL)
      this->input_file()->file().release();
  }

  // Return whether we should just read symbols from this file.
  bool
  just_symbols() const
  { return this->input_file()->just_symbols(); }

  // Return whether this is an incremental object.
  bool
  is_incremental() const
  { return this->do_is_incremental(); }

  // Return the last modified time of the file.
  Timespec
  get_mtime()
  { return this->do_get_mtime(); }

  // Get the number of sections.
  unsigned int
  shnum() const
  { return this->shnum_; }

  // Return a view of the contents of a section.  Set *PLEN to the
  // size.  CACHE is a hint as in File_read::get_view.
  const unsigned char*
  section_contents(unsigned int shndx, section_size_type* plen, bool cache);

  // Adjust a symbol's section index as needed.  SYMNDX is the index
  // of the symbol and SHNDX is the symbol's section from
  // get_st_shndx.  This returns the section index.  It sets
  // *IS_ORDINARY to indicate whether this is a normal section index,
  // rather than a special code between SHN_LORESERVE and
  // SHN_HIRESERVE.
  unsigned int
  adjust_sym_shndx(unsigned int symndx, unsigned int shndx, bool* is_ordinary)
  {
    if (shndx < elfcpp::SHN_LORESERVE)
      *is_ordinary = true;
    else if (shndx == elfcpp::SHN_XINDEX)
      {
	if (this->xindex_ == NULL)
	  this->xindex_ = this->do_initialize_xindex();
	shndx = this->xindex_->sym_xindex_to_shndx(this, symndx);
	*is_ordinary = true;
      }
    else
      *is_ordinary = false;
    return shndx;
  }

  // Return the size of a section given a section index.
  uint64_t
  section_size(unsigned int shndx)
  { return this->do_section_size(shndx); }

  // Return the name of a section given a section index.
  std::string
  section_name(unsigned int shndx)
  { return this->do_section_name(shndx); }

  // Return the section flags given a section index.
  uint64_t
  section_flags(unsigned int shndx)
  { return this->do_section_flags(shndx); }

  // Return the section entsize given a section index.
  uint64_t
  section_entsize(unsigned int shndx)
  { return this->do_section_entsize(shndx); }

  // Return the section address given a section index.
  uint64_t
  section_address(unsigned int shndx)
  { return this->do_section_address(shndx); }

  // Return the section type given a section index.
  unsigned int
  section_type(unsigned int shndx)
  { return this->do_section_type(shndx); }

  // Return the section link field given a section index.
  unsigned int
  section_link(unsigned int shndx)
  { return this->do_section_link(shndx); }

  // Return the section info field given a section index.
  unsigned int
  section_info(unsigned int shndx)
  { return this->do_section_info(shndx); }

  // Return the required section alignment given a section index.
  uint64_t
  section_addralign(unsigned int shndx)
  { return this->do_section_addralign(shndx); }

  // Return the output section given a section index.
  Output_section*
  output_section(unsigned int shndx) const
  { return this->do_output_section(shndx); }

  // Given a section index, return its address.
  // The return value will be -1U if the section is specially mapped,
  // such as a merge section.
  uint64_t
  output_section_address(unsigned int shndx)
  { return this->do_output_section_address(shndx); }

  // Given a section index, return the offset in the Output_section.
  // The return value will be -1U if the section is specially mapped,
  // such as a merge section.
  uint64_t
  output_section_offset(unsigned int shndx) const
  { return this->do_output_section_offset(shndx); }

  // Read the symbol information.
  void
  read_symbols(Read_symbols_data* sd)
  { return this->do_read_symbols(sd); }

  // Pass sections which should be included in the link to the Layout
  // object, and record where the sections go in the output file.
  void
  layout(Symbol_table* symtab, Layout* layout, Read_symbols_data* sd)
  { this->do_layout(symtab, layout, sd); }

  // Add symbol information to the global symbol table.
  void
  add_symbols(Symbol_table* symtab, Read_symbols_data* sd, Layout *layout)
  { this->do_add_symbols(symtab, sd, layout); }

  // Add symbol information to the global symbol table.
  Archive::Should_include
  should_include_member(Symbol_table* symtab, Layout* layout,
			Read_symbols_data* sd, std::string* why)
  { return this->do_should_include_member(symtab, layout, sd, why); }

  // Iterate over global symbols, calling a visitor class V for each.
  void
  for_all_global_symbols(Read_symbols_data* sd,
			 Library_base::Symbol_visitor_base* v)
  { return this->do_for_all_global_symbols(sd, v); }

  // Iterate over local symbols, calling a visitor class V for each GOT offset
  // associated with a local symbol.
  void
  for_all_local_got_entries(Got_offset_list::Visitor* v) const
  { this->do_for_all_local_got_entries(v); }

  // Functions and types for the elfcpp::Elf_file interface.  This
  // permit us to use Object as the File template parameter for
  // elfcpp::Elf_file.

  // The View class is returned by view.  It must support a single
  // method, data().  This is trivial, because get_view does what we
  // need.
  class View
  {
   public:
    View(const unsigned char* p)
      : p_(p)
    { }

    const unsigned char*
    data() const
    { return this->p_; }

   private:
    const unsigned char* p_;
  };

  // Return a View.
  View
  view(off_t file_offset, section_size_type data_size)
  { return View(this->get_view(file_offset, data_size, true, true)); }

  // Report an error.
  void
  error(const char* format, ...) const ATTRIBUTE_PRINTF_2;

  // A location in the file.
  struct Location
  {
    off_t file_offset;
    off_t data_size;

    Location(off_t fo, section_size_type ds)
      : file_offset(fo), data_size(ds)
    { }
  };

  // Get a View given a Location.
  View view(Location loc)
  { return View(this->get_view(loc.file_offset, loc.data_size, true, true)); }

  // Get a view into the underlying file.
  const unsigned char*
  get_view(off_t start, section_size_type size, bool aligned, bool cache)
  {
    return this->input_file()->file().get_view(this->offset_, start, size,
					       aligned, cache);
  }

  // Get a lasting view into the underlying file.
  File_view*
  get_lasting_view(off_t start, section_size_type size, bool aligned,
		   bool cache)
  {
    return this->input_file()->file().get_lasting_view(this->offset_, start,
						       size, aligned, cache);
  }

  // Read data from the underlying file.
  void
  read(off_t start, section_size_type size, void* p)
  { this->input_file()->file().read(start + this->offset_, size, p); }

  // Read multiple data from the underlying file.
  void
  read_multiple(const File_read::Read_multiple& rm)
  { this->input_file()->file().read_multiple(this->offset_, rm); }

  // Stop caching views in the underlying file.
  void
  clear_view_cache_marks()
  {
    if (this->input_file_ != NULL)
      this->input_file_->file().clear_view_cache_marks();
  }

  // Get the number of global symbols defined by this object, and the
  // number of the symbols whose final definition came from this
  // object.
  void
  get_global_symbol_counts(const Symbol_table* symtab, size_t* defined,
			   size_t* used) const
  { this->do_get_global_symbol_counts(symtab, defined, used); }

  // Get the symbols defined in this object.
  const Symbols*
  get_global_symbols() const
  { return this->do_get_global_symbols(); }

  // Set flag that this object was found in a system directory.
  void
  set_is_in_system_directory()
  { this->is_in_system_directory_ = true; }

  // Return whether this object was found in a system directory.
  bool
  is_in_system_directory() const
  { return this->is_in_system_directory_; }

  // Set flag that this object was linked with --as-needed.
  void
  set_as_needed()
  { this->as_needed_ = true; }

  // Return whether this object was linked with --as-needed.
  bool
  as_needed() const
  { return this->as_needed_; }

  // Return whether we found this object by searching a directory.
  bool
  searched_for() const
  { return this->input_file()->will_search_for(); }

  bool
  no_export() const
  { return this->no_export_; }

  void
  set_no_export(bool value)
  { this->no_export_ = value; }

  // Return TRUE if the section is a compressed debug section, and set
  // *UNCOMPRESSED_SIZE to the size of the uncompressed data.
  bool
  section_is_compressed(unsigned int shndx,
			section_size_type* uncompressed_size) const
  { return this->do_section_is_compressed(shndx, uncompressed_size); }

  // Return a view of the decompressed contents of a section.  Set *PLEN
  // to the size.  Set *IS_NEW to true if the contents need to be freed
  // by the caller.
  const unsigned char*
  decompressed_section_contents(unsigned int shndx, section_size_type* plen,
				bool* is_cached)
  { return this->do_decompressed_section_contents(shndx, plen, is_cached); }

  // Discard any buffers of decompressed sections.  This is done
  // at the end of the Add_symbols task.
  void
  discard_decompressed_sections()
  { this->do_discard_decompressed_sections(); }

  // Return the index of the first incremental relocation for symbol SYMNDX.
  unsigned int
  get_incremental_reloc_base(unsigned int symndx) const
  { return this->do_get_incremental_reloc_base(symndx); }

  // Return the number of incremental relocations for symbol SYMNDX.
  unsigned int
  get_incremental_reloc_count(unsigned int symndx) const
  { return this->do_get_incremental_reloc_count(symndx); }

 protected:
  // Returns NULL for Objects that are not dynamic objects.  This method
  // is overridden in the Dynobj class.
  virtual Dynobj*
  do_dynobj()
  { return NULL; }

  // Returns NULL for Objects that are not plugin objects.  This method
  // is overridden in the Pluginobj class.
  virtual Pluginobj*
  do_pluginobj()
  { return NULL; }

  // Return TRUE if this is an incremental (unchanged) input file.
  // We return FALSE by default; the incremental object classes
  // override this method.
  virtual bool
  do_is_incremental() const
  { return false; }

  // Return the last modified time of the file.  This method may be
  // overridden for subclasses that don't use an actual file (e.g.,
  // Incremental objects).
  virtual Timespec
  do_get_mtime()
  { return this->input_file()->file().get_mtime(); }

  // Read the symbols--implemented by child class.
  virtual void
  do_read_symbols(Read_symbols_data*) = 0;

  // Lay out sections--implemented by child class.
  virtual void
  do_layout(Symbol_table*, Layout*, Read_symbols_data*) = 0;

  // Add symbol information to the global symbol table--implemented by
  // child class.
  virtual void
  do_add_symbols(Symbol_table*, Read_symbols_data*, Layout*) = 0;

  virtual Archive::Should_include
  do_should_include_member(Symbol_table* symtab, Layout*, Read_symbols_data*,
                           std::string* why) = 0;

  // Iterate over global symbols, calling a visitor class V for each.
  virtual void
  do_for_all_global_symbols(Read_symbols_data* sd,
			    Library_base::Symbol_visitor_base* v) = 0;

  // Iterate over local symbols, calling a visitor class V for each GOT offset
  // associated with a local symbol.
  virtual void
  do_for_all_local_got_entries(Got_offset_list::Visitor* v) const = 0;

  // Return the location of the contents of a section.  Implemented by
  // child class.
  virtual const unsigned char*
  do_section_contents(unsigned int shndx, section_size_type* plen,
		      bool cache) = 0;

  // Get the size of a section--implemented by child class.
  virtual uint64_t
  do_section_size(unsigned int shndx) = 0;

  // Get the name of a section--implemented by child class.
  virtual std::string
  do_section_name(unsigned int shndx) = 0;

  // Get section flags--implemented by child class.
  virtual uint64_t
  do_section_flags(unsigned int shndx) = 0;

  // Get section entsize--implemented by child class.
  virtual uint64_t
  do_section_entsize(unsigned int shndx) = 0;

  // Get section address--implemented by child class.
  virtual uint64_t
  do_section_address(unsigned int shndx) = 0;

  // Get section type--implemented by child class.
  virtual unsigned int
  do_section_type(unsigned int shndx) = 0;

  // Get section link field--implemented by child class.
  virtual unsigned int
  do_section_link(unsigned int shndx) = 0;

  // Get section info field--implemented by child class.
  virtual unsigned int
  do_section_info(unsigned int shndx) = 0;

  // Get section alignment--implemented by child class.
  virtual uint64_t
  do_section_addralign(unsigned int shndx) = 0;

  // Return the output section given a section index--implemented
  // by child class.
  virtual Output_section*
  do_output_section(unsigned int) const
  { gold_unreachable(); }

  // Get the address of a section--implemented by child class.
  virtual uint64_t
  do_output_section_address(unsigned int)
  { gold_unreachable(); }

  // Get the offset of a section--implemented by child class.
  virtual uint64_t
  do_output_section_offset(unsigned int) const
  { gold_unreachable(); }

  // Return the Xindex structure to use.
  virtual Xindex*
  do_initialize_xindex() = 0;

  // Implement get_global_symbol_counts--implemented by child class.
  virtual void
  do_get_global_symbol_counts(const Symbol_table*, size_t*, size_t*) const = 0;

  virtual const Symbols*
  do_get_global_symbols() const = 0;

  // Set the number of sections.
  void
  set_shnum(int shnum)
  { this->shnum_ = shnum; }

  // Functions used by both Sized_relobj_file and Sized_dynobj.

  // Read the section data into a Read_symbols_data object.
  template<int size, bool big_endian>
  void
  read_section_data(elfcpp::Elf_file<size, big_endian, Object>*,
		    Read_symbols_data*);

  // Find the section header with the given NAME.  If HDR is non-NULL
  // then it is a section header returned from a previous call to this
  // function and the next section header with the same name will be
  // returned.
  template<int size, bool big_endian>
  const unsigned char*
  find_shdr(const unsigned char* pshdrs, const char* name,
	    const char* names, section_size_type names_size,
	    const unsigned char* hdr) const;

  // Let the child class initialize the xindex object directly.
  void
  set_xindex(Xindex* xindex)
  {
    gold_assert(this->xindex_ == NULL);
    this->xindex_ = xindex;
  }

  // If NAME is the name of a special .gnu.warning section, arrange
  // for the warning to be issued.  SHNDX is the section index.
  // Return whether it is a warning section.
  bool
  handle_gnu_warning_section(const char* name, unsigned int shndx,
			     Symbol_table*);

  // If NAME is the name of the special section which indicates that
  // this object was compiled with -fsplit-stack, mark it accordingly,
  // and return true.  Otherwise return false.
  bool
  handle_split_stack_section(const char* name);

  // Return TRUE if the section is a compressed debug section, and set
  // *UNCOMPRESSED_SIZE to the size of the uncompressed data.
  virtual bool
  do_section_is_compressed(unsigned int, section_size_type*) const
  { return false; }

  // Return a view of the decompressed contents of a section.  Set *PLEN
  // to the size.  This default implementation simply returns the
  // raw section contents and sets *IS_NEW to false to indicate
  // that the contents do not need to be freed by the caller.
  // This function must be overridden for any types of object files
  // that might contain compressed sections.
  virtual const unsigned char*
  do_decompressed_section_contents(unsigned int shndx,
				   section_size_type* plen,
				   bool* is_new)
  {
    *is_new = false;
    return this->do_section_contents(shndx, plen, false);
  }

  // Discard any buffers of decompressed sections.  This is done
  // at the end of the Add_symbols task.
  virtual void
  do_discard_decompressed_sections()
  { }

  // Return the index of the first incremental relocation for symbol SYMNDX--
  // implemented by child class.
  virtual unsigned int
  do_get_incremental_reloc_base(unsigned int) const
  { gold_unreachable(); }

  // Return the number of incremental relocations for symbol SYMNDX--
  // implemented by child class.
  virtual unsigned int
  do_get_incremental_reloc_count(unsigned int) const
  { gold_unreachable(); }

 private:
  // This class may not be copied.
  Object(const Object&);
  Object& operator=(const Object&);

  // Name of object as printed to user.
  std::string name_;
  // For reading the file.
  Input_file* input_file_;
  // Offset within the file--0 for an object file, non-0 for an
  // archive.
  off_t offset_;
  // Number of input sections.
  unsigned int shnum_;
  // Whether this is a dynamic object.
  bool is_dynamic_ : 1;
  // Whether this object is needed.  This is only set for dynamic
  // objects, and means that the object defined a symbol which was
  // used by a reference from a regular object.
  bool is_needed_ : 1;
  // Whether this object was compiled with -fsplit-stack.
  bool uses_split_stack_ : 1;
  // Whether this object contains any functions compiled with the
  // no_split_stack attribute.
  bool has_no_split_stack_ : 1;
  // True if exclude this object from automatic symbol export.
  // This is used only for archive objects.
  bool no_export_ : 1;
  // True if the object was found in a system directory.
  bool is_in_system_directory_ : 1;
  // True if the object was linked with --as-needed.
  bool as_needed_ : 1;
  // Many sections for objects with more than SHN_LORESERVE sections.
  Xindex* xindex_;
};

// A regular object (ET_REL).  This is an abstract base class itself.
// The implementation is the template class Sized_relobj_file.

class Relobj : public Object
{
 public:
  Relobj(const std::string& name, Input_file* input_file, off_t offset = 0)
    : Object(name, input_file, false, offset),
      output_sections_(),
      map_to_relocatable_relocs_(NULL),
      object_merge_map_(NULL),
      relocs_must_follow_section_writes_(false),
      sd_(NULL),
      reloc_counts_(NULL),
      reloc_bases_(NULL),
      first_dyn_reloc_(0),
      dyn_reloc_count_(0)
  { }

  // During garbage collection, the Read_symbols_data pass for 
  // each object is stored as layout needs to be done after 
  // reloc processing.
  Symbols_data* 
  get_symbols_data()
  { return this->sd_; }

  // Decides which section names have to be included in the worklist
  // as roots.
  bool
  is_section_name_included(const char* name);
 
  void
  copy_symbols_data(Symbols_data* gc_sd, Read_symbols_data* sd,
                    unsigned int section_header_size);

  void
  set_symbols_data(Symbols_data* sd)
  { this->sd_ = sd; }

  // During garbage collection, the Read_relocs pass for all objects 
  // is done before scanning the relocs.  In that case, this->rd_ is
  // used to store the information from Read_relocs for each object.
  // This data is also used to compute the list of relevant sections.
  Read_relocs_data*
  get_relocs_data()
  { return this->rd_; }

  void
  set_relocs_data(Read_relocs_data* rd)
  { this->rd_ = rd; }

  virtual bool
  is_output_section_offset_invalid(unsigned int shndx) const = 0;

  // Read the relocs.
  void
  read_relocs(Read_relocs_data* rd)
  { return this->do_read_relocs(rd); }

  // Process the relocs, during garbage collection only.
  void
  gc_process_relocs(Symbol_table* symtab, Layout* layout, Read_relocs_data* rd)
  { return this->do_gc_process_relocs(symtab, layout, rd); }

  // Scan the relocs and adjust the symbol table.
  void
  scan_relocs(Symbol_table* symtab, Layout* layout, Read_relocs_data* rd)
  { return this->do_scan_relocs(symtab, layout, rd); }

  // Return the value of the local symbol whose index is SYMNDX, plus
  // ADDEND.  ADDEND is passed in so that we can correctly handle the
  // section symbol for a merge section.
  uint64_t
  local_symbol_value(unsigned int symndx, uint64_t addend) const
  { return this->do_local_symbol_value(symndx, addend); }

  // Return the PLT offset for a local symbol.  It is an error to call
  // this if it doesn't have one.
  unsigned int
  local_plt_offset(unsigned int symndx) const
  { return this->do_local_plt_offset(symndx); }

  // Return whether the local symbol SYMNDX has a GOT offset of type
  // GOT_TYPE.
  bool
  local_has_got_offset(unsigned int symndx, unsigned int got_type) const
  { return this->do_local_has_got_offset(symndx, got_type); }

  // Return the GOT offset of type GOT_TYPE of the local symbol
  // SYMNDX.  It is an error to call this if the symbol does not have
  // a GOT offset of the specified type.
  unsigned int
  local_got_offset(unsigned int symndx, unsigned int got_type) const
  { return this->do_local_got_offset(symndx, got_type); }

  // Set the GOT offset with type GOT_TYPE of the local symbol SYMNDX
  // to GOT_OFFSET.
  void
  set_local_got_offset(unsigned int symndx, unsigned int got_type,
		       unsigned int got_offset)
  { this->do_set_local_got_offset(symndx, got_type, got_offset); }

  // Return whether the local symbol SYMNDX is a TLS symbol.
  bool
  local_is_tls(unsigned int symndx) const
  { return this->do_local_is_tls(symndx); }

  // The number of local symbols in the input symbol table.
  virtual unsigned int
  local_symbol_count() const
  { return this->do_local_symbol_count(); }

  // The number of local symbols in the output symbol table.
  virtual unsigned int
  output_local_symbol_count() const
  { return this->do_output_local_symbol_count(); }

  // The file offset for local symbols in the output symbol table.
  virtual off_t
  local_symbol_offset() const
  { return this->do_local_symbol_offset(); }

  // Initial local symbol processing: count the number of local symbols
  // in the output symbol table and dynamic symbol table; add local symbol
  // names to *POOL and *DYNPOOL.
  void
  count_local_symbols(Stringpool_template<char>* pool,
                      Stringpool_template<char>* dynpool)
  { return this->do_count_local_symbols(pool, dynpool); }

  // Set the values of the local symbols, set the output symbol table
  // indexes for the local variables, and set the offset where local
  // symbol information will be stored. Returns the new local symbol index.
  unsigned int
  finalize_local_symbols(unsigned int index, off_t off, Symbol_table* symtab)
  { return this->do_finalize_local_symbols(index, off, symtab); }

  // Set the output dynamic symbol table indexes for the local variables.
  unsigned int
  set_local_dynsym_indexes(unsigned int index)
  { return this->do_set_local_dynsym_indexes(index); }

  // Set the offset where local dynamic symbol information will be stored.
  unsigned int
  set_local_dynsym_offset(off_t off)
  { return this->do_set_local_dynsym_offset(off); }

  // Record a dynamic relocation against an input section from this object.
  void
  add_dyn_reloc(unsigned int index)
  {
    if (this->dyn_reloc_count_ == 0)
      this->first_dyn_reloc_ = index;
    ++this->dyn_reloc_count_;
  }

  // Return the index of the first dynamic relocation.
  unsigned int
  first_dyn_reloc() const
  { return this->first_dyn_reloc_; }

  // Return the count of dynamic relocations.
  unsigned int
  dyn_reloc_count() const
  { return this->dyn_reloc_count_; }

  // Relocate the input sections and write out the local symbols.
  void
  relocate(const Symbol_table* symtab, const Layout* layout, Output_file* of)
  { return this->do_relocate(symtab, layout, of); }

  // Return whether an input section is being included in the link.
  bool
  is_section_included(unsigned int shndx) const
  {
    gold_assert(shndx < this->output_sections_.size());
    return this->output_sections_[shndx] != NULL;
  }

  // The output section of the input section with index SHNDX.
  // This is only used currently to remove a section from the link in
  // relaxation.
  void
  set_output_section(unsigned int shndx, Output_section* os)
  {
    gold_assert(shndx < this->output_sections_.size());
    this->output_sections_[shndx] = os;
  }
  
  // Set the offset of an input section within its output section.
  void
  set_section_offset(unsigned int shndx, uint64_t off)
  { this->do_set_section_offset(shndx, off); }

  // Return true if we need to wait for output sections to be written
  // before we can apply relocations.  This is true if the object has
  // any relocations for sections which require special handling, such
  // as the exception frame section.
  bool
  relocs_must_follow_section_writes() const
  { return this->relocs_must_follow_section_writes_; }

  // Return the object merge map.
  Object_merge_map*
  merge_map() const
  { return this->object_merge_map_; }

  // Set the object merge map.
  void
  set_merge_map(Object_merge_map* object_merge_map)
  {
    gold_assert(this->object_merge_map_ == NULL);
    this->object_merge_map_ = object_merge_map;
  }

  // Record the relocatable reloc info for an input reloc section.
  void
  set_relocatable_relocs(unsigned int reloc_shndx, Relocatable_relocs* rr)
  {
    gold_assert(reloc_shndx < this->shnum());
    (*this->map_to_relocatable_relocs_)[reloc_shndx] = rr;
  }

  // Get the relocatable reloc info for an input reloc section.
  Relocatable_relocs*
  relocatable_relocs(unsigned int reloc_shndx)
  {
    gold_assert(reloc_shndx < this->shnum());
    return (*this->map_to_relocatable_relocs_)[reloc_shndx];
  }

  // Layout sections whose layout was deferred while waiting for
  // input files from a plugin.
  void
  layout_deferred_sections(Layout* layout)
  { this->do_layout_deferred_sections(layout); }

  // Return the index of the first incremental relocation for symbol SYMNDX.
  virtual unsigned int
  do_get_incremental_reloc_base(unsigned int symndx) const
  { return this->reloc_bases_[symndx]; }

  // Return the number of incremental relocations for symbol SYMNDX.
  virtual unsigned int
  do_get_incremental_reloc_count(unsigned int symndx) const
  { return this->reloc_counts_[symndx]; }

  // Return the word size of the object file.
  int
  elfsize() const
  { return this->do_elfsize(); }

  // Return TRUE if this is a big-endian object file.
  bool
  is_big_endian() const
  { return this->do_is_big_endian(); }

 protected:
  // The output section to be used for each input section, indexed by
  // the input section number.  The output section is NULL if the
  // input section is to be discarded.
  typedef std::vector<Output_section*> Output_sections;

  // Read the relocs--implemented by child class.
  virtual void
  do_read_relocs(Read_relocs_data*) = 0;

  // Process the relocs--implemented by child class.
  virtual void
  do_gc_process_relocs(Symbol_table*, Layout*, Read_relocs_data*) = 0;

  // Scan the relocs--implemented by child class.
  virtual void
  do_scan_relocs(Symbol_table*, Layout*, Read_relocs_data*) = 0;

  // Return the value of a local symbol.
  virtual uint64_t
  do_local_symbol_value(unsigned int symndx, uint64_t addend) const = 0;

  // Return the PLT offset of a local symbol.
  virtual unsigned int
  do_local_plt_offset(unsigned int symndx) const = 0;

  // Return whether a local symbol has a GOT offset of a given type.
  virtual bool
  do_local_has_got_offset(unsigned int symndx,
			  unsigned int got_type) const = 0;

  // Return the GOT offset of a given type of a local symbol.
  virtual unsigned int
  do_local_got_offset(unsigned int symndx, unsigned int got_type) const = 0;

  // Set the GOT offset with a given type for a local symbol.
  virtual void
  do_set_local_got_offset(unsigned int symndx, unsigned int got_type,
			  unsigned int got_offset) = 0;

  // Return whether local symbol SYMNDX is a TLS symbol.
  virtual bool
  do_local_is_tls(unsigned int symndx) const = 0;

  // Return the number of local symbols--implemented by child class.
  virtual unsigned int
  do_local_symbol_count() const = 0;

  // Return the number of output local symbols--implemented by child class.
  virtual unsigned int
  do_output_local_symbol_count() const = 0;

  // Return the file offset for local symbols--implemented by child class.
  virtual off_t
  do_local_symbol_offset() const = 0;

  // Count local symbols--implemented by child class.
  virtual void
  do_count_local_symbols(Stringpool_template<char>*,
			 Stringpool_template<char>*) = 0;

  // Finalize the local symbols.  Set the output symbol table indexes
  // for the local variables, and set the offset where local symbol
  // information will be stored.
  virtual unsigned int
  do_finalize_local_symbols(unsigned int, off_t, Symbol_table*) = 0;

  // Set the output dynamic symbol table indexes for the local variables.
  virtual unsigned int
  do_set_local_dynsym_indexes(unsigned int) = 0;

  // Set the offset where local dynamic symbol information will be stored.
  virtual unsigned int
  do_set_local_dynsym_offset(off_t) = 0;

  // Relocate the input sections and write out the local
  // symbols--implemented by child class.
  virtual void
  do_relocate(const Symbol_table* symtab, const Layout*, Output_file* of) = 0;

  // Set the offset of a section--implemented by child class.
  virtual void
  do_set_section_offset(unsigned int shndx, uint64_t off) = 0;

  // Layout sections whose layout was deferred while waiting for
  // input files from a plugin--implemented by child class.
  virtual void
  do_layout_deferred_sections(Layout*) = 0;

  // Given a section index, return the corresponding Output_section.
  // The return value will be NULL if the section is not included in
  // the link.
  Output_section*
  do_output_section(unsigned int shndx) const
  {
    gold_assert(shndx < this->output_sections_.size());
    return this->output_sections_[shndx];
  }

  // Return the vector mapping input sections to output sections.
  Output_sections&
  output_sections()
  { return this->output_sections_; }

  const Output_sections&
  output_sections() const
  { return this->output_sections_; }

  // Set the size of the relocatable relocs array.
  void
  size_relocatable_relocs()
  {
    this->map_to_relocatable_relocs_ =
      new std::vector<Relocatable_relocs*>(this->shnum());
  }

  // Record that we must wait for the output sections to be written
  // before applying relocations.
  void
  set_relocs_must_follow_section_writes()
  { this->relocs_must_follow_section_writes_ = true; }

  // Allocate the array for counting incremental relocations.
  void
  allocate_incremental_reloc_counts()
  {
    unsigned int nsyms = this->do_get_global_symbols()->size();
    this->reloc_counts_ = new unsigned int[nsyms];
    gold_assert(this->reloc_counts_ != NULL);
    memset(this->reloc_counts_, 0, nsyms * sizeof(unsigned int));
  }

  // Record a relocation in this object referencing global symbol SYMNDX.
  // Used for tracking incremental link information.
  void
  count_incremental_reloc(unsigned int symndx)
  {
    unsigned int nsyms = this->do_get_global_symbols()->size();
    gold_assert(symndx < nsyms);
    gold_assert(this->reloc_counts_ != NULL);
    ++this->reloc_counts_[symndx];
  }

  // Finalize the incremental relocation information.
  void
  finalize_incremental_relocs(Layout* layout, bool clear_counts);

  // Return the index of the next relocation to be written for global symbol
  // SYMNDX.  Only valid after finalize_incremental_relocs() has been called.
  unsigned int
  next_incremental_reloc_index(unsigned int symndx)
  {
    unsigned int nsyms = this->do_get_global_symbols()->size();

    gold_assert(this->reloc_counts_ != NULL);
    gold_assert(this->reloc_bases_ != NULL);
    gold_assert(symndx < nsyms);

    unsigned int counter = this->reloc_counts_[symndx]++;
    return this->reloc_bases_[symndx] + counter;
  }

  // Return the word size of the object file--
  // implemented by child class.
  virtual int
  do_elfsize() const = 0;

  // Return TRUE if this is a big-endian object file--
  // implemented by child class.
  virtual bool
  do_is_big_endian() const = 0;

 private:
  // Mapping from input sections to output section.
  Output_sections output_sections_;
  // Mapping from input section index to the information recorded for
  // the relocations.  This is only used for a relocatable link.
  std::vector<Relocatable_relocs*>* map_to_relocatable_relocs_;
  // Mappings for merge sections.  This is managed by the code in the
  // Merge_map class.
  Object_merge_map* object_merge_map_;
  // Whether we need to wait for output sections to be written before
  // we can apply relocations.
  bool relocs_must_follow_section_writes_;
  // Used to store the relocs data computed by the Read_relocs pass. 
  // Used during garbage collection of unused sections.
  Read_relocs_data* rd_;
  // Used to store the symbols data computed by the Read_symbols pass.
  // Again used during garbage collection when laying out referenced
  // sections.
  gold::Symbols_data* sd_;
  // Per-symbol counts of relocations, for incremental links.
  unsigned int* reloc_counts_;
  // Per-symbol base indexes of relocations, for incremental links.
  unsigned int* reloc_bases_;
  // Index of the first dynamic relocation for this object.
  unsigned int first_dyn_reloc_;
  // Count of dynamic relocations for this object.
  unsigned int dyn_reloc_count_;
};

// This class is used to handle relocations against a section symbol
// in an SHF_MERGE section.  For such a symbol, we need to know the
// addend of the relocation before we can determine the final value.
// The addend gives us the location in the input section, and we can
// determine how it is mapped to the output section.  For a
// non-section symbol, we apply the addend to the final value of the
// symbol; that is done in finalize_local_symbols, and does not use
// this class.

template<int size>
class Merged_symbol_value
{
 public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Value;

  // We use a hash table to map offsets in the input section to output
  // addresses.
  typedef Unordered_map<section_offset_type, Value> Output_addresses;

  Merged_symbol_value(Value input_value, Value output_start_address)
    : input_value_(input_value), output_start_address_(output_start_address),
      output_addresses_()
  { }

  // Initialize the hash table.
  void
  initialize_input_to_output_map(const Relobj*, unsigned int input_shndx);

  // Release the hash table to save space.
  void
  free_input_to_output_map()
  { this->output_addresses_.clear(); }

  // Get the output value corresponding to an addend.  The object and
  // input section index are passed in because the caller will have
  // them; otherwise we could store them here.
  Value
  value(const Relobj* object, unsigned int input_shndx, Value addend) const
  {
    // This is a relocation against a section symbol.  ADDEND is the
    // offset in the section.  The result should be the start of some
    // merge area.  If the object file wants something else, it should
    // use a regular symbol rather than a section symbol.
    // Unfortunately, PR 6658 shows a case in which the object file
    // refers to the section symbol, but uses a negative ADDEND to
    // compensate for a PC relative reloc.  We can't handle the
    // general case.  However, we can handle the special case of a
    // negative addend, by assuming that it refers to the start of the
    // section.  Of course, that means that we have to guess when
    // ADDEND is negative.  It is normal to see a 32-bit value here
    // even when the template parameter size is 64, as 64-bit object
    // file formats have 32-bit relocations.  We know this is a merge
    // section, so we know it has to fit into memory.  So we assume
    // that we won't see a value larger than a large 32-bit unsigned
    // value.  This will break objects with very very large merge
    // sections; they probably break in other ways anyhow.
    Value input_offset = this->input_value_;
    if (addend < 0xffffff00)
      {
	input_offset += addend;
	addend = 0;
      }
    typename Output_addresses::const_iterator p =
      this->output_addresses_.find(input_offset);
    if (p != this->output_addresses_.end())
      return p->second + addend;

    return (this->value_from_output_section(object, input_shndx, input_offset)
	    + addend);
  }

 private:
  // Get the output value for an input offset if we couldn't find it
  // in the hash table.
  Value
  value_from_output_section(const Relobj*, unsigned int input_shndx,
			    Value input_offset) const;

  // The value of the section symbol in the input file.  This is
  // normally zero, but could in principle be something else.
  Value input_value_;
  // The start address of this merged section in the output file.
  Value output_start_address_;
  // A hash table which maps offsets in the input section to output
  // addresses.  This only maps specific offsets, not all offsets.
  Output_addresses output_addresses_;
};

// This POD class is holds the value of a symbol.  This is used for
// local symbols, and for all symbols during relocation processing.
// For special sections, such as SHF_MERGE sections, this calls a
// function to get the final symbol value.

template<int size>
class Symbol_value
{
 public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Value;

  Symbol_value()
    : output_symtab_index_(0), output_dynsym_index_(-1U), input_shndx_(0),
      is_ordinary_shndx_(false), is_section_symbol_(false),
      is_tls_symbol_(false), is_ifunc_symbol_(false), has_output_value_(true)
  { this->u_.value = 0; }

  ~Symbol_value()
  {
    if (!this->has_output_value_)
      delete this->u_.merged_symbol_value;
  }

  // Get the value of this symbol.  OBJECT is the object in which this
  // symbol is defined, and ADDEND is an addend to add to the value.
  template<bool big_endian>
  Value
  value(const Sized_relobj_file<size, big_endian>* object, Value addend) const
  {
    if (this->has_output_value_)
      return this->u_.value + addend;
    else
      {
	gold_assert(this->is_ordinary_shndx_);
	return this->u_.merged_symbol_value->value(object, this->input_shndx_,
						   addend);
      }
  }

  // Set the value of this symbol in the output symbol table.
  void
  set_output_value(Value value)
  { this->u_.value = value; }

  // For a section symbol in a merged section, we need more
  // information.
  void
  set_merged_symbol_value(Merged_symbol_value<size>* msv)
  {
    gold_assert(this->is_section_symbol_);
    this->has_output_value_ = false;
    this->u_.merged_symbol_value = msv;
  }

  // Initialize the input to output map for a section symbol in a
  // merged section.  We also initialize the value of a non-section
  // symbol in a merged section.
  void
  initialize_input_to_output_map(const Relobj* object)
  {
    if (!this->has_output_value_)
      {
	gold_assert(this->is_section_symbol_ && this->is_ordinary_shndx_);
	Merged_symbol_value<size>* msv = this->u_.merged_symbol_value;
	msv->initialize_input_to_output_map(object, this->input_shndx_);
      }
  }

  // Free the input to output map for a section symbol in a merged
  // section.
  void
  free_input_to_output_map()
  {
    if (!this->has_output_value_)
      this->u_.merged_symbol_value->free_input_to_output_map();
  }

  // Set the value of the symbol from the input file.  This is only
  // called by count_local_symbols, to communicate the value to
  // finalize_local_symbols.
  void
  set_input_value(Value value)
  { this->u_.value = value; }

  // Return the input value.  This is only called by
  // finalize_local_symbols and (in special cases) relocate_section.
  Value
  input_value() const
  { return this->u_.value; }

  // Return whether we have set the index in the output symbol table
  // yet.
  bool
  is_output_symtab_index_set() const
  {
    return (this->output_symtab_index_ != 0
	    && this->output_symtab_index_ != -2U);
  }

  // Return whether this symbol may be discarded from the normal
  // symbol table.
  bool
  may_be_discarded_from_output_symtab() const
  {
    gold_assert(!this->is_output_symtab_index_set());
    return this->output_symtab_index_ != -2U;
  }

  // Return whether this symbol has an entry in the output symbol
  // table.
  bool
  has_output_symtab_entry() const
  {
    gold_assert(this->is_output_symtab_index_set());
    return this->output_symtab_index_ != -1U;
  }

  // Return the index in the output symbol table.
  unsigned int
  output_symtab_index() const
  {
    gold_assert(this->is_output_symtab_index_set()
		&& this->output_symtab_index_ != -1U);
    return this->output_symtab_index_;
  }

  // Set the index in the output symbol table.
  void
  set_output_symtab_index(unsigned int i)
  {
    gold_assert(!this->is_output_symtab_index_set());
    gold_assert(i != 0 && i != -1U && i != -2U);
    this->output_symtab_index_ = i;
  }

  // Record that this symbol should not go into the output symbol
  // table.
  void
  set_no_output_symtab_entry()
  {
    gold_assert(this->output_symtab_index_ == 0);
    this->output_symtab_index_ = -1U;
  }

  // Record that this symbol must go into the output symbol table,
  // because it there is a relocation that uses it.
  void
  set_must_have_output_symtab_entry()
  {
    gold_assert(!this->is_output_symtab_index_set());
    this->output_symtab_index_ = -2U;
  }

  // Set the index in the output dynamic symbol table.
  void
  set_needs_output_dynsym_entry()
  {
    gold_assert(!this->is_section_symbol());
    this->output_dynsym_index_ = 0;
  }

  // Return whether this symbol should go into the dynamic symbol
  // table.
  bool
  needs_output_dynsym_entry() const
  {
    return this->output_dynsym_index_ != -1U;
  }

  // Return whether this symbol has an entry in the dynamic symbol
  // table.
  bool
  has_output_dynsym_entry() const
  {
    gold_assert(this->output_dynsym_index_ != 0);
    return this->output_dynsym_index_ != -1U;
  }

  // Record that this symbol should go into the dynamic symbol table.
  void
  set_output_dynsym_index(unsigned int i)
  {
    gold_assert(this->output_dynsym_index_ == 0);
    gold_assert(i != 0 && i != -1U);
    this->output_dynsym_index_ = i;
  }

  // Return the index in the output dynamic symbol table.
  unsigned int
  output_dynsym_index() const
  {
    gold_assert(this->output_dynsym_index_ != 0
                && this->output_dynsym_index_ != -1U);
    return this->output_dynsym_index_;
  }

  // Set the index of the input section in the input file.
  void
  set_input_shndx(unsigned int i, bool is_ordinary)
  {
    this->input_shndx_ = i;
    // input_shndx_ field is a bitfield, so make sure that the value
    // fits.
    gold_assert(this->input_shndx_ == i);
    this->is_ordinary_shndx_ = is_ordinary;
  }

  // Return the index of the input section in the input file.
  unsigned int
  input_shndx(bool* is_ordinary) const
  {
    *is_ordinary = this->is_ordinary_shndx_;
    return this->input_shndx_;
  }

  // Whether this is a section symbol.
  bool
  is_section_symbol() const
  { return this->is_section_symbol_; }

  // Record that this is a section symbol.
  void
  set_is_section_symbol()
  {
    gold_assert(!this->needs_output_dynsym_entry());
    this->is_section_symbol_ = true;
  }

  // Record that this is a TLS symbol.
  void
  set_is_tls_symbol()
  { this->is_tls_symbol_ = true; }

  // Return true if this is a TLS symbol.
  bool
  is_tls_symbol() const
  { return this->is_tls_symbol_; }

  // Record that this is an IFUNC symbol.
  void
  set_is_ifunc_symbol()
  { this->is_ifunc_symbol_ = true; }

  // Return true if this is an IFUNC symbol.
  bool
  is_ifunc_symbol() const
  { return this->is_ifunc_symbol_; }

  // Return true if this has output value.
  bool
  has_output_value() const
  { return this->has_output_value_; }

 private:
  // The index of this local symbol in the output symbol table.  This
  // will be 0 if no value has been assigned yet, and the symbol may
  // be omitted.  This will be -1U if the symbol should not go into
  // the symbol table.  This will be -2U if the symbol must go into
  // the symbol table, but no index has been assigned yet.
  unsigned int output_symtab_index_;
  // The index of this local symbol in the dynamic symbol table.  This
  // will be -1U if the symbol should not go into the symbol table.
  unsigned int output_dynsym_index_;
  // The section index in the input file in which this symbol is
  // defined.
  unsigned int input_shndx_ : 27;
  // Whether the section index is an ordinary index, not a special
  // value.
  bool is_ordinary_shndx_ : 1;
  // Whether this is a STT_SECTION symbol.
  bool is_section_symbol_ : 1;
  // Whether this is a STT_TLS symbol.
  bool is_tls_symbol_ : 1;
  // Whether this is a STT_GNU_IFUNC symbol.
  bool is_ifunc_symbol_ : 1;
  // Whether this symbol has a value for the output file.  This is
  // normally set to true during Layout::finalize, by
  // finalize_local_symbols.  It will be false for a section symbol in
  // a merge section, as for such symbols we can not determine the
  // value to use in a relocation until we see the addend.
  bool has_output_value_ : 1;
  union
  {
    // This is used if has_output_value_ is true.  Between
    // count_local_symbols and finalize_local_symbols, this is the
    // value in the input file.  After finalize_local_symbols, it is
    // the value in the output file.
    Value value;
    // This is used if has_output_value_ is false.  It points to the
    // information we need to get the value for a merge section.
    Merged_symbol_value<size>* merged_symbol_value;
  } u_;
};

// This type is used to modify relocations for -fsplit-stack.  It is
// indexed by relocation index, and means that the relocation at that
// index should use the symbol from the vector, rather than the one
// indicated by the relocation.

class Reloc_symbol_changes
{
 public:
  Reloc_symbol_changes(size_t count)
    : vec_(count, NULL)
  { }

  void
  set(size_t i, Symbol* sym)
  { this->vec_[i] = sym; }

  const Symbol*
  operator[](size_t i) const
  { return this->vec_[i]; }

 private:
  std::vector<Symbol*> vec_;
};

// Type for mapping section index to uncompressed size and contents.

struct Compressed_section_info
{
  section_size_type size;
  const unsigned char* contents;
};
typedef std::map<unsigned int, Compressed_section_info> Compressed_section_map;

// Abstract base class for a regular object file, either a real object file
// or an incremental (unchanged) object.  This is size and endian specific.

template<int size, bool big_endian>
class Sized_relobj : public Relobj
{
 public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  typedef Relobj::Symbols Symbols;

  static const Address invalid_address = static_cast<Address>(0) - 1;

  Sized_relobj(const std::string& name, Input_file* input_file)
    : Relobj(name, input_file), local_got_offsets_(), section_offsets_()
  { }

  Sized_relobj(const std::string& name, Input_file* input_file,
		    off_t offset)
    : Relobj(name, input_file, offset), local_got_offsets_(), section_offsets_()
  { }

  ~Sized_relobj()
  { }

  // If this is a regular object, return a pointer to the Sized_relobj_file
  // object.  Otherwise, return NULL.
  virtual Sized_relobj_file<size, big_endian>*
  sized_relobj()
  { return NULL; }

  const virtual Sized_relobj_file<size, big_endian>*
  sized_relobj() const
  { return NULL; }

  // Checks if the offset of input section SHNDX within its output
  // section is invalid.
  bool
  is_output_section_offset_invalid(unsigned int shndx) const
  { return this->get_output_section_offset(shndx) == invalid_address; }

  // Get the offset of input section SHNDX within its output section.
  // This is -1 if the input section requires a special mapping, such
  // as a merge section.  The output section can be found in the
  // output_sections_ field of the parent class Relobj.
  Address
  get_output_section_offset(unsigned int shndx) const
  {
    gold_assert(shndx < this->section_offsets_.size());
    return this->section_offsets_[shndx];
  }

  // Iterate over local symbols, calling a visitor class V for each GOT offset
  // associated with a local symbol.
  void
  do_for_all_local_got_entries(Got_offset_list::Visitor* v) const;

 protected:
  typedef Relobj::Output_sections Output_sections;

  // Clear the local symbol information.
  void
  clear_got_offsets()
  { this->local_got_offsets_.clear(); }

  // Return the vector of section offsets.
  std::vector<Address>&
  section_offsets()
  { return this->section_offsets_; }

  // Get the address of an output section.
  uint64_t
  do_output_section_address(unsigned int shndx);

  // Get the offset of a section.
  uint64_t
  do_output_section_offset(unsigned int shndx) const
  {
    Address off = this->get_output_section_offset(shndx);
    if (off == invalid_address)
      return -1ULL;
    return off;
  }

  // Set the offset of a section.
  void
  do_set_section_offset(unsigned int shndx, uint64_t off)
  {
    gold_assert(shndx < this->section_offsets_.size());
    this->section_offsets_[shndx] =
      (off == static_cast<uint64_t>(-1)
       ? invalid_address
       : convert_types<Address, uint64_t>(off));
  }

  // Return whether the local symbol SYMNDX has a GOT offset of type
  // GOT_TYPE.
  bool
  do_local_has_got_offset(unsigned int symndx, unsigned int got_type) const
  {
    Local_got_offsets::const_iterator p =
        this->local_got_offsets_.find(symndx);
    return (p != this->local_got_offsets_.end()
            && p->second->get_offset(got_type) != -1U);
  }

  // Return the GOT offset of type GOT_TYPE of the local symbol
  // SYMNDX.
  unsigned int
  do_local_got_offset(unsigned int symndx, unsigned int got_type) const
  {
    Local_got_offsets::const_iterator p =
        this->local_got_offsets_.find(symndx);
    gold_assert(p != this->local_got_offsets_.end());
    unsigned int off = p->second->get_offset(got_type);
    gold_assert(off != -1U);
    return off;
  }

  // Set the GOT offset with type GOT_TYPE of the local symbol SYMNDX
  // to GOT_OFFSET.
  void
  do_set_local_got_offset(unsigned int symndx, unsigned int got_type,
			  unsigned int got_offset)
  {
    Local_got_offsets::const_iterator p =
        this->local_got_offsets_.find(symndx);
    if (p != this->local_got_offsets_.end())
      p->second->set_offset(got_type, got_offset);
    else
      {
        Got_offset_list* g = new Got_offset_list(got_type, got_offset);
        std::pair<Local_got_offsets::iterator, bool> ins =
            this->local_got_offsets_.insert(std::make_pair(symndx, g));
        gold_assert(ins.second);
      }
  }

  // Return the word size of the object file.
  virtual int
  do_elfsize() const
  { return size; }

  // Return TRUE if this is a big-endian object file.
  virtual bool
  do_is_big_endian() const
  { return big_endian; }

 private:
  // The GOT offsets of local symbols. This map also stores GOT offsets
  // for tp-relative offsets for TLS symbols.
  typedef Unordered_map<unsigned int, Got_offset_list*> Local_got_offsets;

  // GOT offsets for local non-TLS symbols, and tp-relative offsets
  // for TLS symbols, indexed by symbol number.
  Local_got_offsets local_got_offsets_;
  // For each input section, the offset of the input section in its
  // output section.  This is INVALID_ADDRESS if the input section requires a
  // special mapping.
  std::vector<Address> section_offsets_;
};

// A regular object file.  This is size and endian specific.

template<int size, bool big_endian>
class Sized_relobj_file : public Sized_relobj<size, big_endian>
{
 public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  typedef typename Sized_relobj<size, big_endian>::Symbols Symbols;
  typedef std::vector<Symbol_value<size> > Local_values;

  static const Address invalid_address = static_cast<Address>(0) - 1;

  enum Compute_final_local_value_status
  {
    // No error.
    CFLV_OK,
    // An error occurred.
    CFLV_ERROR,
    // The local symbol has no output section.
    CFLV_DISCARDED
  };

  Sized_relobj_file(const std::string& name,
		    Input_file* input_file,
		    off_t offset,
		    const typename elfcpp::Ehdr<size, big_endian>&);

  ~Sized_relobj_file();

  // Set up the object file based on TARGET.
  void
  setup()
  { this->do_setup(); }

  // Return a pointer to the Sized_relobj_file object.
  Sized_relobj_file<size, big_endian>*
  sized_relobj()
  { return this; }

  const Sized_relobj_file<size, big_endian>*
  sized_relobj() const
  { return this; }

  // Return the ELF file type.
  int
  e_type() const
  { return this->e_type_; }

  // Return the number of symbols.  This is only valid after
  // Object::add_symbols has been called.
  unsigned int
  symbol_count() const
  { return this->local_symbol_count_ + this->symbols_.size(); }

  // If SYM is the index of a global symbol in the object file's
  // symbol table, return the Symbol object.  Otherwise, return NULL.
  Symbol*
  global_symbol(unsigned int sym) const
  {
    if (sym >= this->local_symbol_count_)
      {
	gold_assert(sym - this->local_symbol_count_ < this->symbols_.size());
	return this->symbols_[sym - this->local_symbol_count_];
      }
    return NULL;
  }

  // Return the section index of symbol SYM.  Set *VALUE to its value
  // in the object file.  Set *IS_ORDINARY if this is an ordinary
  // section index, not a special code between SHN_LORESERVE and
  // SHN_HIRESERVE.  Note that for a symbol which is not defined in
  // this object file, this will set *VALUE to 0 and return SHN_UNDEF;
  // it will not return the final value of the symbol in the link.
  unsigned int
  symbol_section_and_value(unsigned int sym, Address* value, bool* is_ordinary);

  // Return a pointer to the Symbol_value structure which holds the
  // value of a local symbol.
  const Symbol_value<size>*
  local_symbol(unsigned int sym) const
  {
    gold_assert(sym < this->local_values_.size());
    return &this->local_values_[sym];
  }

  // Return the index of local symbol SYM in the ordinary symbol
  // table.  A value of -1U means that the symbol is not being output.
  unsigned int
  symtab_index(unsigned int sym) const
  {
    gold_assert(sym < this->local_values_.size());
    return this->local_values_[sym].output_symtab_index();
  }

  // Return the index of local symbol SYM in the dynamic symbol
  // table.  A value of -1U means that the symbol is not being output.
  unsigned int
  dynsym_index(unsigned int sym) const
  {
    gold_assert(sym < this->local_values_.size());
    return this->local_values_[sym].output_dynsym_index();
  }

  // Return the input section index of local symbol SYM.
  unsigned int
  local_symbol_input_shndx(unsigned int sym, bool* is_ordinary) const
  {
    gold_assert(sym < this->local_values_.size());
    return this->local_values_[sym].input_shndx(is_ordinary);
  }

  // Record that local symbol SYM must be in the output symbol table.
  void
  set_must_have_output_symtab_entry(unsigned int sym)
  {
    gold_assert(sym < this->local_values_.size());
    this->local_values_[sym].set_must_have_output_symtab_entry();
  }

  // Record that local symbol SYM needs a dynamic symbol entry.
  void
  set_needs_output_dynsym_entry(unsigned int sym)
  {
    gold_assert(sym < this->local_values_.size());
    this->local_values_[sym].set_needs_output_dynsym_entry();
  }

  // Return whether the local symbol SYMNDX has a PLT offset.
  bool
  local_has_plt_offset(unsigned int symndx) const;

  // Set the PLT offset of the local symbol SYMNDX.
  void
  set_local_plt_offset(unsigned int symndx, unsigned int plt_offset);

  // Adjust this local symbol value.  Return false if the symbol
  // should be discarded from the output file.
  bool
  adjust_local_symbol(Symbol_value<size>* lv) const
  { return this->do_adjust_local_symbol(lv); }

  // Return the name of the symbol that spans the given offset in the
  // specified section in this object.  This is used only for error
  // messages and is not particularly efficient.
  bool
  get_symbol_location_info(unsigned int shndx, off_t offset,
			   Symbol_location_info* info);

  // Look for a kept section corresponding to the given discarded section,
  // and return its output address.  This is used only for relocations in
  // debugging sections.
  Address
  map_to_kept_section(unsigned int shndx, bool* found) const;

  // Compute final local symbol value.  R_SYM is the local symbol index.
  // LV_IN points to a local symbol value containing the input value.
  // LV_OUT points to a local symbol value storing the final output value,
  // which must not be a merged symbol value since before calling this
  // method to avoid memory leak.  SYMTAB points to a symbol table.
  //
  // The method returns a status code at return.  If the return status is
  // CFLV_OK, *LV_OUT contains the final value.  If the return status is
  // CFLV_ERROR, *LV_OUT is 0.  If the return status is CFLV_DISCARDED,
  // *LV_OUT is not modified.
  Compute_final_local_value_status
  compute_final_local_value(unsigned int r_sym,
			    const Symbol_value<size>* lv_in,
			    Symbol_value<size>* lv_out,
			    const Symbol_table* symtab);

 protected:
  typedef typename Sized_relobj<size, big_endian>::Output_sections
      Output_sections;

  // Set up.
  virtual void
  do_setup();

  // Read the symbols.
  void
  do_read_symbols(Read_symbols_data*);

  // Return the value of a local symbol.
  uint64_t
  do_local_symbol_value(unsigned int symndx, uint64_t addend) const
  {
    const Symbol_value<size>* symval = this->local_symbol(symndx);
    return symval->value(this, addend);
  }

  // Return the PLT offset for a local symbol.  It is an error to call
  // this if it doesn't have one.
  unsigned int
  do_local_plt_offset(unsigned int symndx) const;

  // Return whether local symbol SYMNDX is a TLS symbol.
  bool
  do_local_is_tls(unsigned int symndx) const
  { return this->local_symbol(symndx)->is_tls_symbol(); }

  // Return the number of local symbols.
  unsigned int
  do_local_symbol_count() const
  { return this->local_symbol_count_; }

  // Return the number of local symbols in the output symbol table.
  unsigned int
  do_output_local_symbol_count() const
  { return this->output_local_symbol_count_; }

  // Return the number of local symbols in the output symbol table.
  off_t
  do_local_symbol_offset() const
  { return this->local_symbol_offset_; }

  // Lay out the input sections.
  void
  do_layout(Symbol_table*, Layout*, Read_symbols_data*);

  // Layout sections whose layout was deferred while waiting for
  // input files from a plugin.
  void
  do_layout_deferred_sections(Layout*);

  // Add the symbols to the symbol table.
  void
  do_add_symbols(Symbol_table*, Read_symbols_data*, Layout*);

  Archive::Should_include
  do_should_include_member(Symbol_table* symtab, Layout*, Read_symbols_data*,
                           std::string* why);

  // Iterate over global symbols, calling a visitor class V for each.
  void
  do_for_all_global_symbols(Read_symbols_data* sd,
			    Library_base::Symbol_visitor_base* v);

  // Read the relocs.
  void
  do_read_relocs(Read_relocs_data*);

  // Process the relocs to find list of referenced sections. Used only
  // during garbage collection.
  void
  do_gc_process_relocs(Symbol_table*, Layout*, Read_relocs_data*);

  // Scan the relocs and adjust the symbol table.
  void
  do_scan_relocs(Symbol_table*, Layout*, Read_relocs_data*);

  // Count the local symbols.
  void
  do_count_local_symbols(Stringpool_template<char>*,
                            Stringpool_template<char>*);

  // Finalize the local symbols.
  unsigned int
  do_finalize_local_symbols(unsigned int, off_t, Symbol_table*);

  // Set the offset where local dynamic symbol information will be stored.
  unsigned int
  do_set_local_dynsym_indexes(unsigned int);

  // Set the offset where local dynamic symbol information will be stored.
  unsigned int
  do_set_local_dynsym_offset(off_t);

  // Relocate the input sections and write out the local symbols.
  void
  do_relocate(const Symbol_table* symtab, const Layout*, Output_file* of);

  // Get the size of a section.
  uint64_t
  do_section_size(unsigned int shndx)
  { return this->elf_file_.section_size(shndx); }

  // Get the name of a section.
  std::string
  do_section_name(unsigned int shndx)
  { return this->elf_file_.section_name(shndx); }

  // Return the location of the contents of a section.
  const unsigned char*
  do_section_contents(unsigned int shndx, section_size_type* plen,
		      bool cache)
  {
    Object::Location loc(this->elf_file_.section_contents(shndx));
    *plen = convert_to_section_size_type(loc.data_size);
    if (*plen == 0)
      {
	static const unsigned char empty[1] = { '\0' };
	return empty;
      }
    return this->get_view(loc.file_offset, *plen, true, cache);
  }

  // Return section flags.
  uint64_t
  do_section_flags(unsigned int shndx);

  // Return section entsize.
  uint64_t
  do_section_entsize(unsigned int shndx);

  // Return section address.
  uint64_t
  do_section_address(unsigned int shndx)
  { return this->elf_file_.section_addr(shndx); }

  // Return section type.
  unsigned int
  do_section_type(unsigned int shndx)
  { return this->elf_file_.section_type(shndx); }

  // Return the section link field.
  unsigned int
  do_section_link(unsigned int shndx)
  { return this->elf_file_.section_link(shndx); }

  // Return the section info field.
  unsigned int
  do_section_info(unsigned int shndx)
  { return this->elf_file_.section_info(shndx); }

  // Return the section alignment.
  uint64_t
  do_section_addralign(unsigned int shndx)
  { return this->elf_file_.section_addralign(shndx); }

  // Return the Xindex structure to use.
  Xindex*
  do_initialize_xindex();

  // Get symbol counts.
  void
  do_get_global_symbol_counts(const Symbol_table*, size_t*, size_t*) const;

  // Get the global symbols.
  const Symbols*
  do_get_global_symbols() const
  { return &this->symbols_; }

  // Adjust a section index if necessary.
  unsigned int
  adjust_shndx(unsigned int shndx)
  {
    if (shndx >= elfcpp::SHN_LORESERVE)
      shndx += this->elf_file_.large_shndx_offset();
    return shndx;
  }

  // Initialize input to output maps for section symbols in merged
  // sections.
  void
  initialize_input_to_output_maps();

  // Free the input to output maps for section symbols in merged
  // sections.
  void
  free_input_to_output_maps();

  // Return symbol table section index.
  unsigned int
  symtab_shndx() const
  { return this->symtab_shndx_; }

  // Allow a child class to access the ELF file.
  elfcpp::Elf_file<size, big_endian, Object>*
  elf_file()
  { return &this->elf_file_; }
  
  // Allow a child class to access the local values.
  Local_values*
  local_values()
  { return &this->local_values_; }

  // Views and sizes when relocating.
  struct View_size
  {
    unsigned char* view;
    typename elfcpp::Elf_types<size>::Elf_Addr address;
    off_t offset;
    section_size_type view_size;
    bool is_input_output_view;
    bool is_postprocessing_view;
    bool is_ctors_reverse_view;
  };

  typedef std::vector<View_size> Views;

  // Stash away info for a number of special sections.
  // Return true if any of the sections found require local symbols to be read.
  virtual bool
  do_find_special_sections(Read_symbols_data* sd);

  // This may be overriden by a child class.
  virtual void
  do_relocate_sections(const Symbol_table* symtab, const Layout* layout,
		       const unsigned char* pshdrs, Output_file* of,
		       Views* pviews);

  // Adjust this local symbol value.  Return false if the symbol
  // should be discarded from the output file.
  virtual bool
  do_adjust_local_symbol(Symbol_value<size>*) const
  { return true; }

  // Allow a child to set output local symbol count.
  void
  set_output_local_symbol_count(unsigned int value)
  { this->output_local_symbol_count_ = value; }

  // Return TRUE if the section is a compressed debug section, and set
  // *UNCOMPRESSED_SIZE to the size of the uncompressed data.
  bool
  do_section_is_compressed(unsigned int shndx,
			   section_size_type* uncompressed_size) const
  {
    if (this->compressed_sections_ == NULL)
      return false;
    Compressed_section_map::const_iterator p =
        this->compressed_sections_->find(shndx);
    if (p != this->compressed_sections_->end())
      {
	if (uncompressed_size != NULL)
	  *uncompressed_size = p->second.size;
	return true;
      }
    return false;
  }

  // Return a view of the uncompressed contents of a section.  Set *PLEN
  // to the size.  Set *IS_NEW to true if the contents need to be deleted
  // by the caller.
  const unsigned char*
  do_decompressed_section_contents(unsigned int shndx,
				   section_size_type* plen,
				   bool* is_new);

  // Discard any buffers of decompressed sections.  This is done
  // at the end of the Add_symbols task.
  void
  do_discard_decompressed_sections();

 private:
  // For convenience.
  typedef Sized_relobj_file<size, big_endian> This;
  static const int ehdr_size = elfcpp::Elf_sizes<size>::ehdr_size;
  static const int shdr_size = elfcpp::Elf_sizes<size>::shdr_size;
  static const int sym_size = elfcpp::Elf_sizes<size>::sym_size;
  typedef elfcpp::Shdr<size, big_endian> Shdr;

  // To keep track of discarded comdat sections, we need to map a member
  // section index to the object and section index of the corresponding
  // kept section.
  struct Kept_comdat_section
  {
    Kept_comdat_section(Relobj* a_object, unsigned int a_shndx)
      : object(a_object), shndx(a_shndx)
    { }
    Relobj* object;
    unsigned int shndx;
  };
  typedef std::map<unsigned int, Kept_comdat_section>
      Kept_comdat_section_table;

  // Find the SHT_SYMTAB section, given the section headers.
  void
  find_symtab(const unsigned char* pshdrs);

  // Return whether SHDR has the right flags for a GNU style exception
  // frame section.
  bool
  check_eh_frame_flags(const elfcpp::Shdr<size, big_endian>* shdr) const;

  // Return whether there is a section named .eh_frame which might be
  // a GNU style exception frame section.
  bool
  find_eh_frame(const unsigned char* pshdrs, const char* names,
		section_size_type names_size) const;

  // Whether to include a section group in the link.
  bool
  include_section_group(Symbol_table*, Layout*, unsigned int, const char*,
			const unsigned char*, const char*, section_size_type,
			std::vector<bool>*);

  // Whether to include a linkonce section in the link.
  bool
  include_linkonce_section(Layout*, unsigned int, const char*,
			   const elfcpp::Shdr<size, big_endian>&);

  // Layout an input section.
  void
  layout_section(Layout* layout, unsigned int shndx, const char* name,
                 const typename This::Shdr& shdr, unsigned int reloc_shndx,
                 unsigned int reloc_type);

  // Layout an input .eh_frame section.
  void
  layout_eh_frame_section(Layout* layout, const unsigned char* symbols_data,
			  section_size_type symbols_size,
			  const unsigned char* symbol_names_data,
			  section_size_type symbol_names_size,
			  unsigned int shndx, const typename This::Shdr&,
			  unsigned int reloc_shndx, unsigned int reloc_type);

  // Write section data to the output file.  Record the views and
  // sizes in VIEWS for use when relocating.
  void
  write_sections(const Layout*, const unsigned char* pshdrs, Output_file*,
		 Views*);

  // Relocate the sections in the output file.
  void
  relocate_sections(const Symbol_table* symtab, const Layout* layout,
		    const unsigned char* pshdrs, Output_file* of,
		    Views* pviews)
  { this->do_relocate_sections(symtab, layout, pshdrs, of, pviews); }

  // Reverse the words in a section.  Used for .ctors sections mapped
  // to .init_array sections.
  void
  reverse_words(unsigned char*, section_size_type);

  // Scan the input relocations for --emit-relocs.
  void
  emit_relocs_scan(Symbol_table*, Layout*, const unsigned char* plocal_syms,
		   const Read_relocs_data::Relocs_list::iterator&);

  // Scan the input relocations for --emit-relocs, templatized on the
  // type of the relocation section.
  template<int sh_type>
  void
  emit_relocs_scan_reltype(Symbol_table*, Layout*,
			   const unsigned char* plocal_syms,
			   const Read_relocs_data::Relocs_list::iterator&,
			   Relocatable_relocs*);

  // Scan the input relocations for --incremental.
  void
  incremental_relocs_scan(const Read_relocs_data::Relocs_list::iterator&);

  // Scan the input relocations for --incremental, templatized on the
  // type of the relocation section.
  template<int sh_type>
  void
  incremental_relocs_scan_reltype(
      const Read_relocs_data::Relocs_list::iterator&);

  void
  incremental_relocs_write(const Relocate_info<size, big_endian>*,
			   unsigned int sh_type,
			   const unsigned char* prelocs,
			   size_t reloc_count,
			   Output_section*,
			   Address output_offset,
			   Output_file*);

  template<int sh_type>
  void
  incremental_relocs_write_reltype(const Relocate_info<size, big_endian>*,
				   const unsigned char* prelocs,
				   size_t reloc_count,
				   Output_section*,
				   Address output_offset,
				   Output_file*);

  // A type shared by split_stack_adjust_reltype and find_functions.
  typedef std::map<section_offset_type, section_size_type> Function_offsets;

  // Check for -fsplit-stack routines calling non-split-stack routines.
  void
  split_stack_adjust(const Symbol_table*, const unsigned char* pshdrs,
		     unsigned int sh_type, unsigned int shndx,
		     const unsigned char* prelocs, size_t reloc_count,
		     unsigned char* view, section_size_type view_size,
		     Reloc_symbol_changes** reloc_map);

  template<int sh_type>
  void
  split_stack_adjust_reltype(const Symbol_table*, const unsigned char* pshdrs,
			     unsigned int shndx, const unsigned char* prelocs,
			     size_t reloc_count, unsigned char* view,
			     section_size_type view_size,
			     Reloc_symbol_changes** reloc_map);

  // Find all functions in a section.
  void
  find_functions(const unsigned char* pshdrs, unsigned int shndx,
		 Function_offsets*);

  // Write out the local symbols.
  void
  write_local_symbols(Output_file*,
		      const Stringpool_template<char>*,
		      const Stringpool_template<char>*,
		      Output_symtab_xindex*,
		      Output_symtab_xindex*,
		      off_t);

  // Record a mapping from discarded section SHNDX to the corresponding
  // kept section.
  void
  set_kept_comdat_section(unsigned int shndx, Relobj* kept_object,
			  unsigned int kept_shndx)
  {
    Kept_comdat_section kept(kept_object, kept_shndx);
    this->kept_comdat_sections_.insert(std::make_pair(shndx, kept));
  }

  // Find the kept section corresponding to the discarded section
  // SHNDX.  Return true if found.
  bool
  get_kept_comdat_section(unsigned int shndx, Relobj** kept_object,
			  unsigned int* kept_shndx) const
  {
    typename Kept_comdat_section_table::const_iterator p =
      this->kept_comdat_sections_.find(shndx);
    if (p == this->kept_comdat_sections_.end())
      return false;
    *kept_object = p->second.object;
    *kept_shndx = p->second.shndx;
    return true;
  }

  // Compute final local symbol value.  R_SYM is the local symbol index.
  // LV_IN points to a local symbol value containing the input value.
  // LV_OUT points to a local symbol value storing the final output value,
  // which must not be a merged symbol value since before calling this
  // method to avoid memory leak.  RELOCATABLE indicates whether we are
  // linking a relocatable output.  OUT_SECTIONS is an array of output
  // sections.  OUT_OFFSETS is an array of offsets of the sections.  SYMTAB
  // points to a symbol table.
  //
  // The method returns a status code at return.  If the return status is
  // CFLV_OK, *LV_OUT contains the final value.  If the return status is
  // CFLV_ERROR, *LV_OUT is 0.  If the return status is CFLV_DISCARDED,
  // *LV_OUT is not modified.
  inline Compute_final_local_value_status
  compute_final_local_value_internal(unsigned int r_sym,
				     const Symbol_value<size>* lv_in,
				     Symbol_value<size>* lv_out,
				     bool relocatable,
				     const Output_sections& out_sections,
				     const std::vector<Address>& out_offsets,
				     const Symbol_table* symtab);

  // The PLT offsets of local symbols.
  typedef Unordered_map<unsigned int, unsigned int> Local_plt_offsets;

  // Saved information for sections whose layout was deferred.
  struct Deferred_layout
  {
    static const int shdr_size = elfcpp::Elf_sizes<size>::shdr_size;
    Deferred_layout(unsigned int shndx, const char* name,
                    const unsigned char* pshdr,
                    unsigned int reloc_shndx, unsigned int reloc_type)
      : shndx_(shndx), name_(name), reloc_shndx_(reloc_shndx),
        reloc_type_(reloc_type)
    {
      memcpy(this->shdr_data_, pshdr, shdr_size);
    }
    unsigned int shndx_;
    std::string name_;
    unsigned int reloc_shndx_;
    unsigned int reloc_type_;
    unsigned char shdr_data_[shdr_size];
  };

  // General access to the ELF file.
  elfcpp::Elf_file<size, big_endian, Object> elf_file_;
  // Type of ELF file (ET_REL or ET_EXEC).  ET_EXEC files are allowed
  // as input files only for the --just-symbols option.
  int e_type_;
  // Index of SHT_SYMTAB section.
  unsigned int symtab_shndx_;
  // The number of local symbols.
  unsigned int local_symbol_count_;
  // The number of local symbols which go into the output file.
  unsigned int output_local_symbol_count_;
  // The number of local symbols which go into the output file's dynamic
  // symbol table.
  unsigned int output_local_dynsym_count_;
  // The entries in the symbol table for the external symbols.
  Symbols symbols_;
  // Number of symbols defined in object file itself.
  size_t defined_count_;
  // File offset for local symbols (relative to start of symbol table).
  off_t local_symbol_offset_;
  // File offset for local dynamic symbols (absolute).
  off_t local_dynsym_offset_;
  // Values of local symbols.
  Local_values local_values_;
  // PLT offsets for local symbols.
  Local_plt_offsets local_plt_offsets_;
  // Table mapping discarded comdat sections to corresponding kept sections.
  Kept_comdat_section_table kept_comdat_sections_;
  // Whether this object has a GNU style .eh_frame section.
  bool has_eh_frame_;
  // If this object has a GNU style .eh_frame section that is discarded in
  // output, record the index here.  Otherwise it is -1U.
  unsigned int discarded_eh_frame_shndx_;
  // The list of sections whose layout was deferred.
  std::vector<Deferred_layout> deferred_layout_;
  // The list of relocation sections whose layout was deferred.
  std::vector<Deferred_layout> deferred_layout_relocs_;
  // For compressed debug sections, map section index to uncompressed size
  // and contents.
  Compressed_section_map* compressed_sections_;
};

// A class to manage the list of all objects.

class Input_objects
{
 public:
  Input_objects()
    : relobj_list_(), dynobj_list_(), sonames_(), cref_(NULL)
  { }

  // The type of the list of input relocateable objects.
  typedef std::vector<Relobj*> Relobj_list;
  typedef Relobj_list::const_iterator Relobj_iterator;

  // The type of the list of input dynamic objects.
  typedef std::vector<Dynobj*> Dynobj_list;
  typedef Dynobj_list::const_iterator Dynobj_iterator;

  // Add an object to the list.  Return true if all is well, or false
  // if this object should be ignored.
  bool
  add_object(Object*);

  // Start processing an archive.
  void
  archive_start(Archive*);

  // Stop processing an archive.
  void
  archive_stop(Archive*);

  // For each dynamic object, check whether we've seen all of its
  // explicit dependencies.
  void
  check_dynamic_dependencies() const;

  // Return whether an object was found in the system library
  // directory.
  bool
  found_in_system_library_directory(const Object*) const;

  // Print symbol counts.
  void
  print_symbol_counts(const Symbol_table*) const;

  // Print a cross reference table.
  void
  print_cref(const Symbol_table*, FILE*) const;

  // Iterate over all regular objects.

  Relobj_iterator
  relobj_begin() const
  { return this->relobj_list_.begin(); }

  Relobj_iterator
  relobj_end() const
  { return this->relobj_list_.end(); }

  // Iterate over all dynamic objects.

  Dynobj_iterator
  dynobj_begin() const
  { return this->dynobj_list_.begin(); }

  Dynobj_iterator
  dynobj_end() const
  { return this->dynobj_list_.end(); }

  // Return whether we have seen any dynamic objects.
  bool
  any_dynamic() const
  { return !this->dynobj_list_.empty(); }

  // Return the number of non dynamic objects.
  int
  number_of_relobjs() const
  { return this->relobj_list_.size(); }

  // Return the number of input objects.
  int
  number_of_input_objects() const
  { return this->relobj_list_.size() + this->dynobj_list_.size(); }

 private:
  Input_objects(const Input_objects&);
  Input_objects& operator=(const Input_objects&);

  // The list of ordinary objects included in the link.
  Relobj_list relobj_list_;
  // The list of dynamic objects included in the link.
  Dynobj_list dynobj_list_;
  // SONAMEs that we have seen.
  Unordered_set<std::string> sonames_;
  // Manage cross-references if requested.
  Cref* cref_;
};

// Some of the information we pass to the relocation routines.  We
// group this together to avoid passing a dozen different arguments.

template<int size, bool big_endian>
struct Relocate_info
{
  // Symbol table.
  const Symbol_table* symtab;
  // Layout.
  const Layout* layout;
  // Object being relocated.
  Sized_relobj_file<size, big_endian>* object;
  // Section index of relocation section.
  unsigned int reloc_shndx;
  // Section header of relocation section.
  const unsigned char* reloc_shdr;
  // Section index of section being relocated.
  unsigned int data_shndx;
  // Section header of data section.
  const unsigned char* data_shdr;

  // Return a string showing the location of a relocation.  This is
  // only used for error messages.
  std::string
  location(size_t relnum, off_t reloffset) const;
};

// This is used to represent a section in an object and is used as the
// key type for various section maps.
typedef std::pair<Object*, unsigned int> Section_id;

// This is similar to Section_id but is used when the section
// pointers are const.
typedef std::pair<const Object*, unsigned int> Const_section_id;

// The hash value is based on the address of an object in memory during
// linking.  It is okay to use this for looking up sections but never use
// this in an unordered container that we want to traverse in a repeatable
// manner.

struct Section_id_hash
{
  size_t operator()(const Section_id& loc) const
  { return reinterpret_cast<uintptr_t>(loc.first) ^ loc.second; }
};

struct Const_section_id_hash
{
  size_t operator()(const Const_section_id& loc) const
  { return reinterpret_cast<uintptr_t>(loc.first) ^ loc.second; }
};

// Return whether INPUT_FILE contains an ELF object start at file
// offset OFFSET.  This sets *START to point to a view of the start of
// the file.  It sets *READ_SIZE to the number of bytes in the view.

extern bool
is_elf_object(Input_file* input_file, off_t offset,
	      const unsigned char** start, int* read_size);

// Return an Object appropriate for the input file.  P is BYTES long,
// and holds the ELF header.  If PUNCONFIGURED is not NULL, then if
// this sees an object the linker is not configured to support, it
// sets *PUNCONFIGURED to true and returns NULL without giving an
// error message.

extern Object*
make_elf_object(const std::string& name, Input_file*,
		off_t offset, const unsigned char* p,
		section_offset_type bytes, bool* punconfigured);

} // end namespace gold

#endif // !defined(GOLD_OBJECT_H)
@


1.125
log
@gold/
	* object.cc (Sized_relobj::do_output_section_address): New function.
	(Sized_relobj): Instantiate explicitly.
	* object.h (Object::output_section_address): New function.
	(Object::do_output_section_address): New function.
	(Sized_relobj::do_output_section_address): New function.
	* powerpc.cc (Target_powerpc::symval_for_branch): Use it.
@
text
@d1181 1
a1181 1
  // The the output section of the input section with index SHNDX.
@


1.124
log
@gold/
    	* object.cc (Sized_relobj_file::get_symbol_location_info): Set
    	type of enclosing symbol.
    	(Relocate_info::location): Check symbol type when describing symbol.
    	* object.h (Symbol_location_info): Remove unused line_number;
    	add enclosing_symbol_type.
    	* testsuite/debug_msg.sh: Adjust expected output.
@
text
@d554 7
d862 5
d1944 4
@


1.123
log
@	* gold.cc (queue_middle_tasks): Move detect_odr_violations..
	* layout.cc (Layout_task_runner::run): ..to here.
	* symtab.h (struct Symbol_location): Extract from..
	(class Symbol_table): ..here.
	* symtab.cc (Symbol_table::linenos_from_loc): Invoke function_location.
	* target.h (class Target): Add function_location and
	do_function_location functions.
	(class Sized_target): Add do_function_location.
	* object.h (class Sized_relobj_file): Move find_shdr..
	(class Object): ..to here.
	* object.cc: Likewise.  Update to suit.  Instantiate.
	(Sized_relobj_file::find_eh_frame): Update find_shdr call.
	* powerpc.cc (class Powerpc_dynobj): New.
	(Target_powerpc::do_function_location): New function.
	(Powerpc_relobj::do_find_special_sections): Update find_shdr call.
	(Powerpc_dynobj::do_read_symbols): New function.
	(Target_powerpc::do_make_elf_object): Make a Powerpc_dynobj.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
d106 1
a106 1
  int line_number;
@


1.122
log
@gold/
	* dwarf_reader.cc (make_elf_reloc_mapper): Check size and endianness
	from object, not parameters.
	(Dwarf_info_reader::parse): Likewise.
	* object.h (Relobj::elfsize, Relobj::is_big_endian): New methods.
	(Relobj::do_elfsize, Relobj::do_is_big_endian): New methods.
	(Sized_relobj::do_elfsize, Sized_relobj::do_is_big_endian): New
	methods.
@
text
@d884 10
a2173 9
  // Find the section header with the given NAME.  If HDR is non-NULL
  // then it is a section header returned from a previous call to this
  // function and the next section header with the same name will be
  // returned.
  const unsigned char*
  find_shdr(const unsigned char* pshdrs, const char* name,
	    const char* names, section_size_type names_size,
	    const unsigned char* hdr) const;

@


1.121
log
@	* object.h (Sized_relobj_file::adjust_local_symbol,
	do_adjust_local_symbol): New functions.
	* object.cc (Sized_relobj_file::do_count_local_symbols): Use the above.
	* powerpc.cc (Powerpc_relobj::do_adjust_local_symbol): New function.
	(Powerpc_relobj::scan_opd_relocs): Warn on unexpected opd relocs
	and irregular opd entry spacing.
	(Powerpc_relobj::do_read_relocs): Add opd size checks.
	(Global_symbol_visitor_opd): New functor.
	(Target_powerpc::do_finalize_sections): Omit global symbols defined
	on deleted opd entries.
@
text
@d1227 10
d1399 10
d1986 10
@


1.120
log
@	PR gold/14570
	* output.cc: Rename Output_data_got template parameter from size
	to got_size for all functions.  Compile all variants of
	Output_data_got.
	(Output_data_got::Got_entry::write): Correct use of size for
	symbol value.  Use local_is_tls rather than casting to
	Sized_relobj_file.
	* object.h (class Object): Add local_is_tls and do_local_is_tls.
	(class Sized_relobj_file): Add do_local_is_tls.
	* incremental.h (class Sized_relobj_incr): Add do_local_is_tls.
@
text
@d2115 6
d2390 6
@


1.119
log
@	* object.h (Sized_relobj_file::emit_relocs): Delete.
	(Sized_relobj_file::emit_relocs_reltype): Delete.
	* reloc.cc (Sized_relobj_file::do_relocate_sections): Call target
	relocate_relocs for --emit-relocs.
	(Sized_relobj_file::emit_relocs, emit_relocs_reltype): Delete.
	* output.h: Update comment.
	(Output_segment::first_section): New function.
	(Output_segment::first_section_load_address): Use first_section.
	* output.cc (Output_segment::first_section): New function extracted..
	(Output_segment::first_section_load_address): ..from here.  Delete.
	* target-reloc.h (relocate_for_relocatable): Rename to relocate_relocs.
	* target.h (Sized_target::relocate_for_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise, and
	adjust call to target.h function.
	* i386.cc (Target_i386): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	(Target_powerpc::Scan::local, global): Handle R_POWERPC_TLS.  Ensure
	first tls section has section symbol for optimised local dynamic
	output relocs.
	(Target_powerpc::Relocate::relocate): Correct local dynamic value.
	(Target_powerpc::relocate_relocs): Adjust relocs emitted for
	optimised tls code.
	* testsuite/testfile.cc (Target_test::relocate_for_relocatable):
	Rename to relocate_relocs.  Update error message.
@
text
@d1082 5
d1267 4
d2178 5
@


1.118
log
@	* object.h (Sized_relobj_file::find_shdr): New function.
	(Sized_relobj_file::find_special_sections): New function.
	* object.cc (Sized_relobj_file::find_shdr): New function.
	(Sized_relobj_file::find_eh_frame): Use find_shdr.
	(Sized_relobj_file::find_special_sections): New function, split out..
	(Sized_relobj_file::do_read_symbols): ..from here.
	* output.h (Output_data_got::replace_constant): New function.
	(Output_data_got::num_entries): New function.
	(Output_data_got::last_got_offset,set_got_size): Use num_entries.
	(Output_data_got::got_offset): Protected rather than private.
	(Output_data_got::replace_got_entry): New function.
	* output.cc (Output_data_got::replace_got_entry): New function.
	* powerpc.cc (class Powerpc_relobj): New.
	(class Powerpc_relocate_functions): Delete all psymval variants or
	convert to value,addend type.  Delete pcrela, pcrela_unaligned.
	Implement _ha functions using corresponding _hi function.
	(Powerpc_relobj::find_special_sections): New function.
	(Target_powerpc::do_make_elf_object): New function.
	(class Output_data_got_powerpc): New.
	(class Output_data_glink): New.
	(class Powerpc_scan_relocatable_reloc): New.
	Many more changes througout file.
@
text
@a2501 21
  // Emit the relocs for --emit-relocs.
  void
  emit_relocs(const Relocate_info<size, big_endian>*, unsigned int,
	      unsigned int sh_type, const unsigned char* prelocs,
	      size_t reloc_count, Output_section*, Address output_offset,
	      unsigned char* view, Address address,
	      section_size_type view_size,
	      unsigned char* reloc_view, section_size_type reloc_view_size);

  // Emit the relocs for --emit-relocs, templatized on the type of the
  // relocation section.
  template<int sh_type>
  void
  emit_relocs_reltype(const Relocate_info<size, big_endian>*, unsigned int,
		      const unsigned char* prelocs, size_t reloc_count,
		      Output_section*, Address output_offset,
		      unsigned char* view, Address address,
		      section_size_type view_size,
		      unsigned char* reloc_view,
		      section_size_type reloc_view_size);

@


1.117
log
@	* arm.cc (Target_arm::do_is_defined_by_abi): Make sym a const
	pointer.
	(Stub_addend_reader::operator()): Declare Arm_relocate_functions
	as a class, not a struct.
	(Target_arm::scan_span_for_cortex_a8_erratum): Likewise.
	(Target_arm::apply_cortex_a8_workaround): Likewise.
	* gc.h: Declare Reloc_types as a struct, not a class.
	* object.h: Declare Symbols_data as a struct.
	* reloc.h: Declare Read_relocs_data as a struct.
	* target.h: Declare Relocate_info as a struct.
@
text
@d352 1
a352 1
  // Return the name of the object as we would report it to the tuser.
d2119 9
d2359 5
@


1.116
log
@2012-03-21  Cary Coutant  <ccoutant@@google.com>

	* Makefile.am: Add gdb-index.cc, gdb-index.h.
	* Makefile.in: Regenerate.
	* dwarf_reader.cc (Sized_elf_reloc_mapper::do_initialize): New function.
	(Sized_elf_reloc_mapper::symbol_section): New function.
	(Sized_elf_reloc_mapper::do_get_reloc_target): New function.
	(make_elf_reloc_mapper): New function.
	(Dwarf_abbrev_table::clear_abbrev_codes): New function.
	(Dwarf_abbrev_table::do_read_abbrevs): New function.
	(Dwarf_abbrev_table::do_get_abbrev): New function.
	(Dwarf_ranges_table::read_ranges_table): New function.
	(Dwarf_ranges_table::read_range_list): New function.
	(Dwarf_pubnames_table::read_section): New function.
	(Dwarf_pubnames_table::read_header): New function.
	(Dwarf_pubnames_table::next_name): New function.
	(Dwarf_die::Dwarf_die): New function.
	(Dwarf_die::read_attributes): New function.
	(Dwarf_die::skip_attributes): New function.
	(Dwarf_die::set_name): New function.
	(Dwarf_die::set_linkage_name): New function.
	(Dwarf_die::attribute): New function.
	(Dwarf_die::string_attribute): New function.
	(Dwarf_die::int_attribute): New function.
	(Dwarf_die::uint_attribute): New function.
	(Dwarf_die::ref_attribute): New function.
	(Dwarf_die::child_offset): New function.
	(Dwarf_die::sibling_offset): New function.
	(Dwarf_info_reader::check_buffer): New function.
	(Dwarf_info_reader::parse): New function.
	(Dwarf_info_reader::do_parse): New function.
	(Dwarf_info_reader::do_read_string_table): New function.
	(Dwarf_info_reader::lookup_reloc): New function.
	(Dwarf_info_reader::get_string): New function.
	(Dwarf_info_reader::visit_compilation_unit): New function.
	(Dwarf_info_reader::visit_type_unit): New function.
	(Sized_dwarf_line_info::Sized_dwarf_line_info): Use
	Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::symbol_section): Remove function.
	(Sized_dwarf_line_info::read_relocs): Use Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::read_line_mappings): Remove object
	parameter, adjust callers.
	(Sized_dwarf_line_info::format_file_lineno): Fix type of cast.
	* dwarf_reader.h: Include <sys/types.h>.
	(class Track_relocs): Remove forward declaration.
	(class Elf_reloc_mapper): New class.
	(class Sized_elf_reloc_mapper): New class.
	(class Dwarf_abbrev_table): New class.
	(class Dwarf_range_list): New class.
	(class Dwarf_ranges_table): New class.
	(class Dwarf_pubnames_table): New class.
	(class Dwarf_die): New class.
	(class Dwarf_info_reader): New class.
	(Sized_dwarf_line_info::read_line_mappings): Remove object parameter.
	(Sized_dwarf_line_info::symbol_section): Remove member function.
	* dynobj.h (Sized_dynobj::do_section_contents): Refactor code from
	base class.
	* gdb-index.cc: New source file.
	* gdb-index.h: New source file.
	* incremental.cc (Sized_relobj_incr::do_layout): Track .debug_info
	and .debug_types sections, call Layout::add_to_gdb_index.
	(Sized_relobj_incr::do_section_name): Implement.
	(Sized_relobj_incr::do_section_contents): Adjust parameter list and
	return type; Implement.
	(Sized_incr_dynobj::do_section_contents): Adjust parameter list and
	return type.
	* incremental.h (Sized_relobj_incr::do_section_contents): Adjust
	parameter list and return type.
	(Sized_incr_dynobj::do_section_contents): Likewise.
	* layout.cc: Include gdb-index.h.
	(Layout::Layout): Initialize gdb_index_data_.
	(Layout::init_fixed_output_section): Check for .gdb_index section.
	(Layout::add_to_gdb_index): New function. Instantiate.
	* layout.h: Add forward declaration for class Gdb_index.
	(Layout::add_to_gdb_index): New member function.
	(Layout::gdb_index_data_): New data member.
	* main.cc: Include gdb-index.h.
	(main): Print statistics for gdb index.
	* object.cc (Object::section_contents): Move code into
	do_section_contents.
	(need_decompressed_section): Check for sections needed when building
	gdb index.
	(build_compressed_section_map): Likewise.
	(Sized_relobj_file::do_read_symbols): Need local symbols when building
	gdb index.
	(Sized_relobj_file::do_layout): Track .debug_info and .debug_types
	sections; call Layout::add_to_gdb_index.
	(Sized_relobj_file::do_decompressed_section_contents): Call
	do_section_contents directly.
	* object.h (Object::do_section_contents): Adjust parameter list and
	return type.
	(Object::do_decompressed_section_contents): Call do_section_contents
	directly.
	(Sized_relobj_file::do_section_contents): Adjust parameter list and
	return type.
	* options.h (class General_options): Add --gdb-index option.
	* plugin.cc (Sized_pluginobj::do_section_contents): Adjust parameter
	list and return type.
	* plugin.h (Sized_pluginobj::do_section_contents): Likewise.
	* reloc.h (Track_relocs::checkpoint): New function.
	(Track_relocs::reset): New function.

	* testsuite/Makefile.am (gdb_index_test_1.sh, gdb_index_test_2.sh):
	New test cases.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/gdb_index_test.cc: New test source file.
	* testsuite/gdb_index_test_1.sh: New test source file.
	* testsuite/gdb_index_test_2.sh: New test source file.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d51 1
a51 1
class Symbols_data;
@


1.115
log
@	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Call Object::decompressed_section_contents.
	* dwarf_reader.h (Sized_dwarf_line_info::~Sized_dwarf_line_info):
	New dtor.
	(Sized_dwarf_line_info::buffer_start_): New data member.
	* merge.cc (Output_merge_data::do_add_input_section): Call
	Object::decompressed_section_contents.
	(Output_merge_string::do_add_input_section): Likewise.
	* object.cc (need_decompressed_section): New function.
	(build_compressed_section_map): Decompress sections needed later.
	(Sized_relobj_file::do_decompressed_section_contents): New function.
	(Sized_relobj_file::do_discard_decompressed_sections): New function.
	* object.h (Object::decompressed_section_contents): New function.
	(Object::discard_decompressed_sections): New function.
	(Object::do_decompressed_section_contents): New function.
	(Object::do_discard_decompressed_sections): New function.
	(Compressed_section_info): New type.
	(Compressed_section_map): Include decompressed section contents.
	(Sized_relobj_file::do_decompressed_section_contents): New function.
	(Sized_relobj_file::do_discard_decompressed_sections): New function.
@
text
@d728 1
a728 1
  // Return a view of the uncompressed contents of a section.  Set *PLEN
d808 3
a810 2
  virtual Location
  do_section_contents(unsigned int shndx) = 0;
d922 1
a922 1
    return this->section_contents(shndx, plen, false);
d2241 13
a2253 3
  Object::Location
  do_section_contents(unsigned int shndx)
  { return this->elf_file_.section_contents(shndx); }
d2387 1
a2387 1
  // Discard any buffers of uncompressed sections.  This is done
@


1.114
log
@	* object.h (Relobj::local_symbol_value): New function.
	(Relobj::local_plt_offset): New function.
	(Relobj::local_has_got_offset): New function.
	(Relobj::local_got_offset): New function.
	(Relobj::set_local_got_offset): New function.
	(Relobj::do_local_symbol_value): New pure virtual function.
	(Relobj::do_local_plt_offset): Likewise.
	(Relobj::do_local_has_got_offset): Likewise.
	(Relobj::do_local_got_offset): Likewise.
	(Relobj::do_set_local_got_offset): Likewise.
	(Sized_relobj::do_local_has_got_offset): Rename from
	local_has_got_offset.
	(Sized_relobj::do_local_got_offset): Rename from local_got_offset.
	(Sized_relobj::do_set_local_got_offset): Rename from
	set_local_got_offset.
	(Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	(Sized_relobj_file::do_local_symbol_value): New function.
	* object.cc (Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	* output.cc (Output_data_got::Got_entry::write): Change object to
	Relobj.  Use local_symbol_value.
	(Output_data_got::add_global_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_with_rela): Remove.  Change all
	callers to use add_global_with_rel.
	(Output_data_got::add_global_pair_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_pair_with_rela): Remove.  Change all
	callers to use add_global_pair_with_rel.
	(Output_data_got::add_local): Change object to Relobj*.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Change object to Relobj*,
	change rel_dyn to Output_data_reloc_generic*.  Use
	add_local_generic.
	(Output_data_got::add_local_with_rela): Remove.  Change all
	callers to use all_local_with_rel.
	(Output_data_got::add_local_pair_with_rel): Change object to
	Relobj*, change rel_dyn to Output_data_reloc_generic*.  Use
	add_output_section_generic.
	(Output_data_got::add_local_pair_with_rela): Remove.  Change all
	callers to use add_local_pair_with_rel.
	(Output_data_got::reserve_local): Change object to Relobj*.
	* output.h: (class Output_data_reloc_generic): Add pure virtual
	declarations for add_global_generic, add_local_generic,
	add_output_section_generic.
	(class Output_data_reloc) [SHT_REL, SHT_RELA]: Implement new
	functions for Output_data_reloc_generic.  Update declarations for
	changes listed in output.cc.
	(class Output_data_got): Change template parameter to got_size.
	Don't define Rel_dyn or Rela_dyn.  Update declarations per above.
	* incremental.h (Sized_relobj_incr::do_local_symbol_value): New
	function.
	(Sized_relobj_incr::do_local_plt_offset): New function.
	* copy-relocs.cc (Copy_relocs::Copy_reloc_entry::emit): Call
	add_global_generic.
@
text
@d728 14
d909 21
d1813 1
a1813 1
// Type for mapping section index to uncompressed size.
d1815 6
a1820 1
typedef std::map<unsigned int, section_size_type> Compressed_section_map;
d2362 1
a2362 1
	  *uncompressed_size = p->second;
d2368 13
d2665 2
a2666 1
  // For compressed debug sections, map section index to uncompressed size.
@


1.113
log
@	* layout.cc (Layout::set_segment_offsets): Don't realign text
	segment if -Ttext was specified.
	* object.cc (Sized_relobj_file::Sized_relobj_file): Store the ELF
	file type.
	* object.h (Sized_relobj_file::e_type): New function.
	(Sized_relobj_file::e_type_): New data member.
	* symtab.cc (Symbol_table::add_from_relobj): Don't add section
	base address for ET_EXEC files.
	* target.cc (Target::do_make_elf_object_implementation): Allow
	ET_EXEC files with --just-symbols option.
@
text
@d1012 33
d1203 22
a1832 41
  // Return whether the local symbol SYMNDX has a GOT offset.
  // For TLS symbols, the GOT entry will hold its tp-relative offset.
  bool
  local_has_got_offset(unsigned int symndx, unsigned int got_type) const
  {
    Local_got_offsets::const_iterator p =
        this->local_got_offsets_.find(symndx);
    return (p != this->local_got_offsets_.end()
            && p->second->get_offset(got_type) != -1U);
  }

  // Return the GOT offset of the local symbol SYMNDX.
  unsigned int
  local_got_offset(unsigned int symndx, unsigned int got_type) const
  {
    Local_got_offsets::const_iterator p =
        this->local_got_offsets_.find(symndx);
    gold_assert(p != this->local_got_offsets_.end());
    unsigned int off = p->second->get_offset(got_type);
    gold_assert(off != -1U);
    return off;
  }

  // Set the GOT offset of the local symbol SYMNDX to GOT_OFFSET.
  void
  set_local_got_offset(unsigned int symndx, unsigned int got_type,
                       unsigned int got_offset)
  {
    Local_got_offsets::const_iterator p =
        this->local_got_offsets_.find(symndx);
    if (p != this->local_got_offsets_.end())
      p->second->set_offset(got_type, got_offset);
    else
      {
        Got_offset_list* g = new Got_offset_list(got_type, got_offset);
        std::pair<Local_got_offsets::iterator, bool> ins =
            this->local_got_offsets_.insert(std::make_pair(symndx, g));
        gold_assert(ins.second);
      }
  }

d1872 43
a2059 5
  // Return the PLT offset for a local symbol.  It is an error to call
  // this if it doesn't have one.
  unsigned int
  local_plt_offset(unsigned int symndx) const;

d2105 13
@


1.112
log
@	PR gold/12629
	* object.cc (Sized_relobj_file::layout_section): Change shdr
	parameter to be const.
	(Sized_relobj_file::layout_eh_frame_section): New function, broken
	out of do_layout.
	(Sized_relobj_file::do_layout): Defer .eh_frame sections if
	appropriate.  Call layout_eh_frame_section.
	(Sized_relobj_file::do_layout_deferred_sections): Handle .eh_frame
	sections.
	* object.h (class Sized_relobj_file): Update declarations.
@
text
@d1915 5
d2512 3
@


1.111
log
@	* layout.cc: Include "object.h".
	(ctors_sections_in_init_array): New static variable.
	(Layout::is_ctors_in_init_array): New function.
	(Layout::layout): Add entry to ctors_sections_in_init_array if
	appropriate.
	* layout.h (class Layout): Declare is_ctors_in_init_array.
	* reloc.cc (Sized_relobj_file::do_relocate): Call reverse_words if
	is_ctors_reverse_view is set.
	(Sized_relobj_file::write_sections): Add layout parameter.  Change
	all callers.  Set is_ctors_reverse_view field of View_size.
	(Sized_relobj_file::reverse_words): New function.
	* object.h (Sized_relobj_file::View_size): Add
	is_ctors_reverse_view field.
	(class Sized_relobj_file): Update declarations.
	* testsuite/initpri3.c: New test.
	* testsuite/Makefile.am: (check_PROGRAMS): Add initpri3a and
	initpri3b.
	(initpri3a_SOURCES, initpri3a_DEPENDENCIES): New variables.
	(initpri3a_LDFLAGS, initpri3a_LDADD): New variables.
	(initpri3b_SOURCES, initpri3b_DEPENDENCIES): New variables.
	(initpri3b_LDFLAGS, initpri3b_LDADD): New variables.
	* testsuite/Makefile.in: Rebuild.
@
text
@d2309 1
a2309 1
                 typename This::Shdr& shdr, unsigned int reloc_shndx,
d2312 9
@


1.110
log
@	* dynobj.h (Dynobj::do_dynobj): New function.
	* incremental-dump.cc (dump_incremental_inputs): Print as_needed
	flag and soname for shared objects.
	* incremental.cc (Incremental_inputs::report_object): Make
	either Incremental_object_entry or Incremental_dynobj_entry; add
	soname to string table.
	(Incremental_inputs::report_input_section): Add assertion.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	type of input file entry for shared libraries; adjust size of
	shared library info entry.
	(Output_section_incremental_inputs::write_input_files): Write
	as_needed flag for shared libraries.
	(Output_section_incremental_inputs::write_info_blocks): Adjust type
	of input file entry for shared libraries; write soname.
	(Sized_incr_dynobj::Sized_incr_dynobj): Read as_needed flag and
	soname from incremental info.
	* incremental.h (enum Incremental_input_flags): Add
	INCREMENTAL_INPUT_AS_NEEDED.
	(Incremental_input_entry::Incremental_input_entry): Initialize new
	data member.
	(Incremental_input_entry::set_as_needed): New function.
	(Incremental_input_entry::as_needed): New function.
	(Incremental_input_entry::do_dynobj_entry): New function.
	(Incremental_input_entry::as_needed_): New data member.
	(Incremental_object_entry::Incremental_object_entry): Don't check
	for shared library.
	(Incremental_object_entry::do_type): Likewise.
	(class Incremental_dynobj_entry): New class.
	(Incremental_input_entry_reader::as_needed): New function.
	(Incremental_input_entry_reader::get_soname): New function.
	(Incremental_input_entry_reader::get_global_symbol_count): Rewrite.
	(Incremental_input_entry_reader::get_output_symbol_index): Adjust
	size of shared library info entry.
	* layout.cc (Layout::finish_dynamic_section): Don't test for
	incremental link when adding DT_NEEDED entries.
	* object.h (Object::Object): Initialize new data member.
	(Object::dynobj): New function.
	(Object::set_as_needed): New function.
	(Object::as_needed): New function.
	(Object::do_dynobj): New function.
	(Object::as_needed_): New data member.
@
text
@d2223 1
d2315 2
a2316 1
  write_sections(const unsigned char* pshdrs, Output_file*, Views*);
d2325 5
@


1.109
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d335 1
a335 1
      is_in_system_directory_(false), xindex_(NULL)
d341 1
d390 6
d698 10
d739 6
d937 2
@


1.108
log
@	* incremental-dump.cc (dump_incremental_inputs): Print local
	symbol info for each input file.
	* incremental.cc
	(Output_section_incremental_inputs::set_final_data_size): Add local
	symbol info to input file entries in incremental info.
	(Output_section_incremental_inputs::write_info_blocks): Likewise.
	(Sized_incr_relobj::Sized_incr_relobj): Initialize new data members.
	(Sized_incr_relobj::do_add_symbols): Cosmetic change.
	(Sized_incr_relobj::do_count_local_symbols): Replace stub with
	implementation.
	(Sized_incr_relobj::do_finalize_local_symbols): Likewise.
	(Sized_incr_relobj::do_relocate): Write the local symbols.
	(Sized_incr_dynobj::do_add_symbols): Cosmetic change.
	* incremental.h (Incremental_inputs_reader::get_symbol_offset):
	Adjust size of input file header.
	(Incremental_inputs_reader::get_local_symbol_offset): New function.
	(Incremental_inputs_reader::get_local_symbol_count): New function.
	(Incremental_inputs_reader::get_input_section): Adjust size of input
	file header.
	(Incremental_inputs_reader::get_global_symbol_reader): Likewise.
	(Sized_incr_relobj::This): New typedef.
	(Sized_incr_relobj::sym_size): New const data member.
	(Sized_incr_relobj::Local_symbol): New struct.
	(Sized_incr_relobj::do_output_local_symbol_count): New function.
	(Sized_incr_relobj::do_local_symbol_offset): New function.
	(Sized_incr_relobj::local_symbol_count_): New data member.
	(Sized_incr_relobj::output_local_dynsym_count_): New data member.
	(Sized_incr_relobj::local_symbol_index_): New data member.
	(Sized_incr_relobj::local_symbol_offset_): New data member.
	(Sized_incr_relobj::local_dynsym_offset_): New data member.
	(Sized_incr_relobj::local_symbols_): New data member.
	* object.h (Relobj::output_local_symbol_count): New function.
	(Relobj::local_symbol_offset): New function.
	(Relobj::do_output_local_symbol_count): New function.
	(Relobj::do_local_symbol_offset): New function.
	(Sized_relobj::do_output_local_symbol_count): New function.
	(Sized_relobj::do_local_symbol_offset): New function.
@
text
@d837 1
a837 1
  // Functions used by both Sized_relobj and Sized_dynobj.
d919 1
a919 1
// The implementation is the template class Sized_relobj.
d932 3
a934 1
      reloc_bases_(NULL)
d1027 19
d1286 4
d1407 1
a1407 1
  value(const Sized_relobj<size, big_endian>* object, Value addend) const
d1706 1
a1706 1
class Sized_relobj_base : public Relobj
d1709 1
d1712 4
a1715 2
  Sized_relobj_base(const std::string& name, Input_file* input_file)
    : Relobj(name, input_file)
d1718 1
a1718 1
  Sized_relobj_base(const std::string& name, Input_file* input_file,
d1720 1
a1720 1
    : Relobj(name, input_file, offset)
d1723 1
a1723 1
  ~Sized_relobj_base()
d1726 73
d1802 31
d1834 11
d1850 1
a1850 1
class Sized_relobj : public Sized_relobj_base<size, big_endian>
d1854 1
a1854 1
  typedef typename Sized_relobj_base<size, big_endian>::Symbols Symbols;
d1869 4
a1872 2
  Sized_relobj(const std::string& name, Input_file* input_file, off_t offset,
	       const typename elfcpp::Ehdr<size, big_endian>&);
d1874 1
a1874 7
  ~Sized_relobj();

  // Checks if the offset of input section SHNDX within its output
  // section is invalid. 
  bool
  is_output_section_offset_invalid(unsigned int shndx) const
  { return this->get_output_section_offset(shndx) == invalid_address; }
d1881 9
a1968 41
  // Return whether the local symbol SYMNDX has a GOT offset.
  // For TLS symbols, the GOT entry will hold its tp-relative offset.
  bool
  local_has_got_offset(unsigned int symndx, unsigned int got_type) const
  {
    Local_got_offsets::const_iterator p =
        this->local_got_offsets_.find(symndx);
    return (p != this->local_got_offsets_.end()
            && p->second->get_offset(got_type) != -1U);
  }

  // Return the GOT offset of the local symbol SYMNDX.
  unsigned int
  local_got_offset(unsigned int symndx, unsigned int got_type) const
  {
    Local_got_offsets::const_iterator p =
        this->local_got_offsets_.find(symndx);
    gold_assert(p != this->local_got_offsets_.end());
    unsigned int off = p->second->get_offset(got_type);
    gold_assert(off != -1U);
    return off;
  }

  // Set the GOT offset of the local symbol SYMNDX to GOT_OFFSET.
  void
  set_local_got_offset(unsigned int symndx, unsigned int got_type,
                       unsigned int got_offset)
  {
    Local_got_offsets::const_iterator p =
        this->local_got_offsets_.find(symndx);
    if (p != this->local_got_offsets_.end())
      p->second->set_offset(got_type, got_offset);
    else
      {
        Got_offset_list* g = new Got_offset_list(got_type, got_offset);
        std::pair<Local_got_offsets::iterator, bool> ins =
            this->local_got_offsets_.insert(std::make_pair(symndx, g));
        gold_assert(ins.second);
      }
  }

a1981 11
  // Get the offset of input section SHNDX within its output section.
  // This is -1 if the input section requires a special mapping, such
  // as a merge section.  The output section can be found in the
  // output_sections_ field of the parent class Relobj.
  Address
  get_output_section_offset(unsigned int shndx) const
  {
    gold_assert(shndx < this->section_offsets_.size());
    return this->section_offsets_[shndx];
  }

d2012 1
a2012 1
  typedef typename Sized_relobj_base<size, big_endian>::Output_sections
a2059 5
  // Iterate over local symbols, calling a visitor class V for each GOT offset
  // associated with a local symbol.
  void
  do_for_all_local_got_entries(Got_offset_list::Visitor* v) const;

a2154 21
  // Get the offset of a section.
  uint64_t
  do_output_section_offset(unsigned int shndx) const
  {
    Address off = this->get_output_section_offset(shndx);
    if (off == invalid_address)
      return -1ULL;
    return off;
  }

  // Set the offset of a section.
  void
  do_set_section_offset(unsigned int shndx, uint64_t off)
  {
    gold_assert(shndx < this->section_offsets_.size());
    this->section_offsets_[shndx] =
      (off == static_cast<uint64_t>(-1)
       ? invalid_address
       : convert_types<Address, uint64_t>(off));
  }

d2234 1
a2234 1
  typedef Sized_relobj<size, big_endian> This;
a2441 4
  // The GOT offsets of local symbols. This map also stores GOT offsets
  // for tp-relative offsets for TLS symbols.
  typedef Unordered_map<unsigned int, Got_offset_list*> Local_got_offsets;

a2484 3
  // GOT offsets for local non-TLS symbols, and tp-relative offsets
  // for TLS symbols, indexed by symbol number.
  Local_got_offsets local_got_offsets_;
a2486 4
  // For each input section, the offset of the input section in its
  // output section.  This is INVALID_ADDRESS if the input section requires a
  // special mapping.
  std::vector<Address> section_offsets_;
d2610 1
a2610 1
  Sized_relobj<size, big_endian>* object;
@


1.107
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d990 10
d1128 8
d1932 10
@


1.106
log
@	* archive.cc (Library_base::should_include_member): Move
	method here from class Archive.
	(Archive::Archive): Initialize base class.
	(Archive::should_include_member): Move to base class.
	(Archive::do_for_all_unused_symbols): New function.
	(Add_archive_symbols::run): Remove redundant access to
	incremental_inputs.
	(Lib_group::Lib_group): Initialize base class.
	(Lib_group::do_filename): New function.
	(Lib_group::include_member): Pass pointer to Lib_group to
	report_object.
	(Lib_group::do_for_all_unused_symbols): New function.
	(Add_lib_group_symbols::run): Report archive information for
	incremental links.
	* archive.h (class Library_base): New base class.
	(class Archive): Derive from Library_base.
	(Archive::filename): Move to base class.
	(Archive::set_incremental_info): Likewise.
	(Archive::incremental_info): Likewise.
	(Archive::Should_include): Likewise.
	(Archive::should_include_member): Likewise.
	(Archive::Armap_entry): Remove.
	(Archive::Unused_symbol_iterator): Remove.
	(Archive::unused_symbols_begin): Remove.
	(Archive::unused_symbols_end): Remove.
	(Archive::do_filename): New function.
	(Archive::do_get_mtime): New function.
	(Archive::do_for_all_unused_symbols): New function.
	(Archive::task_): Move to base class.
	(Archive::incremental_info_): Likewise.
	(class Lib_group): Derive from Library_base.
	(Lib_group::do_filename): New function.
	(Lib_group::do_get_mtime): New function.
	(Lib_group::do_for_all_unused_symbols): New function.
	(Lib_group::task_): Move to base class.
	* dynobj.cc (Sized_dynobj::do_for_all_global_symbols): New
	function.
	* dynobj.h (Sized_dynobj::do_for_all_global_symbols): New
	function.
	* incremental.cc (Incremental_inputs::report_archive_begin):
	Use Library_base; call library's get_mtime; add incremental inputs
	entry before members.
	(class Unused_symbol_visitor): New class.
	(Incremental_inputs::report_archive_end): Use Library_base; use
	visitor class to record unused symbols; don't add incremental inputs
	entry after members.
	(Incremental_inputs::report_object): Use Library_base.
	* incremental.h
	(Incremental_archive_entry::Incremental_archive_entry): Remove
	unused Archive parameter.
	(Incremental_inputs::report_archive_begin): Use Library_base.
	(Incremental_inputs::report_archive_end): Likewise.
	(Incremental_inputs::report_object): Likewise.
	* object.cc (Sized_relobj::do_for_all_global_symbols): New
	function.
	* object.h (Object::for_all_global_symbols): New function.
	(Object::do_for_all_global_symbols): New function.
	(Sized_relobj::do_for_all_global_symbols): New function.
	* plugin.cc (Sized_pluginobj::do_for_all_global_symbols):  New
	function.
	* plugin.h (Sized_pluginobj::do_for_all_global_symbols):  New
	function.
@
text
@d206 111
d334 9
a342 2
      has_no_split_stack_(false), no_export_(false), xindex_(NULL)
  { input_file->file().add_object(); }
d345 4
a348 1
  { this->input_file_->file().remove_object(); }
d398 4
a401 1
  { return this->input_file_; }
d405 4
a408 1
  { return this->input_file_; }
d413 4
a416 1
  { this->input_file()->file().lock(t); }
d421 4
a424 1
  { this->input_file()->file().unlock(t); }
d429 1
a429 1
  { return this->input_file()->file().is_locked(); }
d434 5
a438 1
  { return this->input_file()->file().token(); }
d443 4
a446 1
  { this->input_file_->file().release(); }
d453 10
d581 6
d663 4
a666 1
  { this->input_file()->file().clear_view_cache_marks(); }
d681 5
d689 1
a689 1
  { return this->input_file()->is_in_system_directory(); }
d728 14
d764 5
d912 2
d1207 1
a1207 1
  finalize_incremental_relocs(Layout* layout);
a1630 97
// A GOT offset list.  A symbol may have more than one GOT offset
// (e.g., when mixing modules compiled with two different TLS models),
// but will usually have at most one.  GOT_TYPE identifies the type of
// GOT entry; its values are specific to each target.

class Got_offset_list
{
 public:
  Got_offset_list()
    : got_type_(-1U), got_offset_(0), got_next_(NULL)
  { }

  Got_offset_list(unsigned int got_type, unsigned int got_offset)
    : got_type_(got_type), got_offset_(got_offset), got_next_(NULL)
  { }

  ~Got_offset_list()
  { 
    if (this->got_next_ != NULL)
      {
        delete this->got_next_;
        this->got_next_ = NULL;
      }
  }

  // Initialize the fields to their default values.
  void
  init()
  {
    this->got_type_ = -1U;
    this->got_offset_ = 0;
    this->got_next_ = NULL;
  }

  // Set the offset for the GOT entry of type GOT_TYPE.
  void
  set_offset(unsigned int got_type, unsigned int got_offset)
  {
    if (this->got_type_ == -1U)
      {
        this->got_type_ = got_type;
        this->got_offset_ = got_offset;
      }
    else
      {
        for (Got_offset_list* g = this; g != NULL; g = g->got_next_)
          {
            if (g->got_type_ == got_type)
              {
                g->got_offset_ = got_offset;
                return;
              }
          }
        Got_offset_list* g = new Got_offset_list(got_type, got_offset);
        g->got_next_ = this->got_next_;
        this->got_next_ = g;
      }
  }

  // Return the offset for a GOT entry of type GOT_TYPE.
  unsigned int
  get_offset(unsigned int got_type) const
  {
    for (const Got_offset_list* g = this; g != NULL; g = g->got_next_)
      {
        if (g->got_type_ == got_type)
          return g->got_offset_;
      }
    return -1U;
  }

  // Return a pointer to the list, or NULL if the list is empty.
  const Got_offset_list*
  get_list() const
  {
    if (this->got_type_ == -1U)
      return NULL;
    return this;
  }

  // Loop over all GOT offset entries, applying the function F to each.
  template<typename F>
  void
  for_all_got_offsets(F f) const
  {
    if (this->got_type_ == -1U)
      return;
    for (const Got_offset_list* g = this; g != NULL; g = g->got_next_)
      f(g->got_type_, g->got_offset_);
  }

 private:
  unsigned int got_type_;
  unsigned int got_offset_;
  Got_offset_list* got_next_;
};

d1659 27
d1689 1
a1689 1
class Sized_relobj : public Relobj
d1693 1
a1693 1
  typedef std::vector<Symbol*> Symbols;
a1843 11
  // Return the GOT offset list for the local symbol SYMNDX.
  const Got_offset_list*
  local_got_offset_list(unsigned int symndx) const
  {
    Local_got_offsets::const_iterator p =
        this->local_got_offsets_.find(symndx);
    if (p == this->local_got_offsets_.end())
      return NULL;
    return p->second;
  }

d1898 3
d1936 5
d2294 2
a2295 1
		      Output_symtab_xindex*);
d2385 1
a2385 1
  // File offset for local symbols.
d2387 1
a2387 1
  // File offset for local dynamic symbols.
@


1.105
log
@	PR gold/12316
	* object.h (class Sized_relobj): Remove clear_local_symbols.
	* reloc.cc (Sized_relobj::do_relocate): Don't call
	clear_local_symbols.
@
text
@d425 6
d581 5
d1824 5
@


1.104
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
a2167 9
  // Clear the local symbol information.
  void
  clear_local_symbols()
  {
    this->local_values_.clear();
    this->local_got_offsets_.clear();
    this->local_plt_offsets_.clear();
  }

@


1.103
log
@2010-09-08  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_exidx_cantunwind::do_print_to_mapfile): New method.
	(Arm_relobj::do_relocate_sections): Add new parameter for output
	file to match the parent.
	(Target_arm::scan_reloc_section_for_stubs): Use would-be final values
	of local symbols instead of input values.  Update code to track
	changes in gold::relocate_section.
	* object.cc (Sized_relobj::compute_final_local_value): New methods.
	(Sized_relobj::compute_final_local_value_internal): New methods.
	(Sized_relobj::do_finalize_local_symbols): Move code from loop
	body into private version of Sized_relobj::compute_final_local_value.
	Call the inline method.
	* object.h (Symbol_value::Symbol_value): Define destructor.  Free
	merged symbol value if there is one.
	(Symbol_value::has_output_value): New method defintiion.
	(Sized_relobj::Compute_final_local_value_status): New enum type.
	(Sized_relobj::compute_final_local_value): New methods.
	(Sized_relobj::compute_final_local_value_internal): New methods.
	* Makefile.am (check_SCRIPTS): Add arm_branch_out_of_range.sh
	and arm_cortex_a8.sh.
	(thumb_bl_out_of_range_local, arm_cortex_a8_b_cond, arm_cortex_a8_bl,
	arm_cortex_a8_blx, arm_cortex_a8_local, arm_corte_a8_local_reloc):
	New tests.
	* Makefile.in: Regenerate.
	* testsuite/arm_bl_out_of_range.s: Update test.
	* testsuite/thumb_bl_out_of_range.s: Ditto.
	* testsuite/thumb_blx_out_of_range.s: Ditto.
	* testsuite/arm_branch_out_of_range.sh: New file.
	* testsuite/arm_cortex_a8.sh: Ditto.
	* testsuite/arm_cortex_a8_b.s: Ditto.
	* testsuite/arm_cortex_a8_b_cond.s: Ditto.
	* testsuite/arm_cortex_a8_b_local.s: Ditto.
	* testsuite/arm_cortex_a8_bl.s: Ditto.
	* testsuite/arm_cortex_a8_blx.s: Ditto.
	* testsuite/arm_cortex_a8_local.s: Ditto.
	* testsuite/arm_cortex_a8_local_reloc.s: Ditto.
	* testsuite/thumb_bl_out_of_range_local.s: Ditto.
@
text
@d667 1
a667 1
  // this object was compiled with -fstack-split, mark it accordingly,
@


1.103.2.1
log
@	PR gold/12316
	* object.h (class Sized_relobj): Remove clear_local_symbols.
	* reloc.cc (Sized_relobj::do_relocate): Don't call
	clear_local_symbols.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d2168 9
@


1.102
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d1158 6
d1389 5
d1572 10
d1766 16
d2202 22
@


1.101
log
@	PR 10893
	* i386.cc (class Output_data_plt_i386): Update declarations.
	Define Global_ifunc and Local_ifunc types.  Add global_ifuncs_ and
	local_ifuncs_ fields.
	(Target_i386::do_plt_section_for_global): New function.
	(Target_i386::do_plt_section_for_local): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Add symtab
	parameter; change all callers.  Initialize global_ifuncs_ and
	local_ifuncs_.  If doing a static link define __rel_iplt_start and
	__rel_iplt_end.
	(Output_data_plt_i386::add_entry): Handle IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): New function.
	(Output_data_plt_i386::do_write): Fix GOT entries for IFUNC
	symbols.
	(Target_i386::make_plt_section): New function, broken out of
	make_plt_entry.  Set sh_info field of .rel.plt to point to .plt.
	(Target_i386::make_plt_entry): Call make_plt_section.
	(Target_i386::make_local_ifunc_plt_entry): New function.
	(Target_i386::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_i386::Scan::local): Handle IFUNC symbols.  Add
	R_386_IRELATIVE to switch.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocatable_size_for_reloc): Add R_386_IRELATIVE to
	switch.
	* x86_64.cc (class Output_data_plt_x86_64): Update declarations.
	(Target_x86_64::do_plt_section_for_global): New function.
	(Target_x86_64::do_plt_section_for_local): New function.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Add symtab
	parameter; change all callers.  If doing a static link define
	__rela_iplt_start and __rela_iplt_end.
	(Output_data_plt_x86_64::add_entry): Handle IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): New function.
	(Target_x86_64::make_plt_section): Set sh_info field of .rel.plt
	to point to .plt.
	(Target_x86_64::make_local_ifunc_plt_entry): New function.
	(Target_x86_64::Scan::check_non_pic): Add R_X86_64_IRELATIVE to
	switch.
	(Target_x86_64::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_x86_64::Scan::local): Handle IFUNC symbols.  Add
	R_X86_64_IRELATIVE to switch.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocatable_size_for_reloc): Add R_X86_64_IRELATIVE to
	switch.
	* target.h (class Target): Add plt_section_for_global and
	plt_section_for_local functions.  Add do_plt_section_for_global
	and do_plt_section_for_local virtual functions.
	* symtab.h (Symbol::needs_plt_entry): Handle IFUNC symbol.  Add
	clarifying comments.
	(Symbol::use_plt_offset): Handle IFUNC symbol.
	* object.cc (Sized_relobj::Sized_relobj): Initialize
	local_plt_offsets_.
	(Sized_relobj::local_has_plt_offset): New function.
	(Sized_relobj::local_plt_offset): New function.
	(Sized_relobj::set_local_plt_offset): New function.
	(Sized_relobj::do_count): Handle IFUNC symbol.
	* object.h (class Symbol_value): Add is_ifunc_symbol_ field.  Take
	a bit away from input_shndx_ field.  Add set_is_func_symbol and
	is_ifunc_symbol functions.
	(class Sized_relobj): Update declarations.  Remove Tls_got_entry
	and Local_tls_got_offsets.  Define Local_plt_offsets.  Add
	local_plt_offsets_ field.
	(Sized_relobj::clear_local_symbols): Clear local_plt_offsets_.
	* output.h (class Output_section_data): Add non-const
	output_section function.
	(class Output_data_got): Update declarations.
	(class Output_data_got::Got_entry): Add use_plt_offset_ field.
	Add use_plt_offset parameter to global and local constructors.
	Change all callers.  Change local_sym_index_ field to 31 bits.
	Change GSYM_CODE and CONSTANT_CODE accordingly.
	* output.cc (Output_data_reloc_base::do_adjust_output_section): If
	doing a static link don't set sh_link field.
	(Output_data_got::Got_entry::write): Use PLT offset if
	appropriate.
	(Output_data_got::add_global_plt): New function.
	(Output_data_got::add_local_plt): New function.
	* target-reloc.h (relocate_section): Handle IFUNC symbol.
	* defstd.cc (in_section): Remove entries for __rel_iplt_start,
	__rel_iplt_end, __rela_iplt_start, and __rela_iplt_end.
	* configure.ac: Set IFUNC automake conditional for glibc >= 2.11.
	* testsuite/Makefile.am: Add a bunch of IFUNC tests, all within
	IFUNC conditional.
	* testsuite/ifunc-sel.h: New file.
	* testsuite/ifuncmain1.c: New file.
	* testsuite/ifuncmain1vis.c: New file.
	* testsuite/ifuncmod1.c: New file.
	* testsuite/ifuncdep2.c: New file.
	* testsuite/ifuncmain2.c: New file.
	* testsuite/ifuncmain3.c: New file.
	* testsuite/ifuncmod3.c: New file.
	* testsuite/ifuncmain4.c: New file.
	* testsuite/ifuncmain5.c: New file.
	* testsuite/ifuncmod5.c: New file.
	* testsuite/ifuncmain6pie.c: New file.
	* testsuite/ifuncmod6.c: New file.
	* testsuite/ifuncmain7.c: New file.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d749 1
a749 1
  is_section_name_included(const char *name);
d1046 1
a1046 1
  gold::Symbols_data *sd_;
d2009 1
a2009 1
			const unsigned char*, const char *, section_size_type,
d2391 1
a2391 1
	      const unsigned char** start, int *read_size);
@


1.100
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_GOT_PLT.

gold/ChangeLog:

	* arm.cc (Target_arm::got_size): Add const.
	(Target_arm::got_entry_count): New function.
	(Target_arm::plt_entry_count): New function.
	(Target_arm::first_plt_entry_offset): New function.
	(Target_arm::plt_entry_size): New function.
	(Output_data_plt_arm::entry_count): New function.
	(Output_data_plt_arm::first_plt_entry_offset): New function.
	(Output_data_plt_arm::get_plt_entry_size): New function.
	* i386.cc (Target_i386::got_size): Add const.
	(Target_i386::got_entry_count): New function.
	(Target_i386::plt_entry_count): New function.
	(Target_i386::first_plt_entry_offset): New function.
	(Target_i386::plt_entry_size): New function.
	(Output_data_plt_i386::entry_count): New function.
	(Output_data_plt_i386::first_plt_entry_offset): New function.
	(Output_data_plt_i386::get_plt_entry_size): New function.
	* incremental-dump.cc (dump_incremental_inputs): Adjust call to
	find_incremental_inputs_sections.  Dump incremental_got_plt section.
	* incremental.cc: Include target.h.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Add
	parameter.  Adjust all callers.  Find incremental_got_plt section.
	(Incremental_inputs::create_data_sections): Create incremental_got_plt
	section.
	(Output_section_incremental_inputs::set_final_data_size): Calculate
	size of incremental_got_plt section.
	(Output_section_incremental_inputs::do_write): Write the
	incremental_got_plt section.
	(Got_plt_view_info): New struct.
	(Local_got_offset_visitor): New class.
	(Global_got_offset_visitor): New class.
	(Global_symbol_visitor_got_plt): New class.
	(Output_section_incremental_inputs::write_got_plt): New function.
	* incremental.h (Incremental_binary::find_incremental_inputs_sections):
	Add parameter.  Adjust all callers.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Incremental_inputs::got_plt_section): New function.
	(Incremental_inputs::got_plt_section_): New data member.
	(Incremental_got_plt_reader): New class.
	* layout.cc (Layout::create_incremental_info_sections): Add the
	incremental_got_plt section.
	* object.h (Got_offset_list::get_list): New function.
	(Got offset_list::for_all_got_offsets): New function.
	(Sized_relobj::local_got_offset_list): New function.
	* powerpc.cc (Target_powerpc::got_size): Add const.
	(Target_powerpc::got_entry_count): New function.
	(Target_powerpc::plt_entry_count): New function.
	(Target_powerpc::first_plt_entry_offset): New function.
	(Target_powerpc::plt_entry_size): New function.
	(Output_data_plt_powerpc::entry_count): New function.
	(Output_data_plt_powerpc::first_plt_entry_offset): New function.
	(Output_data_plt_powerpc::get_plt_entry_size): New function.
	* sparc.cc (Target_sparc::got_size): Add const.
	(Target_sparc::got_entry_count): New function.
	(Target_sparc::plt_entry_count): New function.
	(Target_sparc::first_plt_entry_offset): New function.
	(Target_sparc::plt_entry_size): New function.
	(Output_data_plt_sparc::entry_count): New function.
	(Output_data_plt_sparc::first_plt_entry_offset): New function.
	(Output_data_plt_sparc::get_plt_entry_size): New function.
	* symtab.h (Symbol::got_offset_list): New function.
	(Symbol_table::for_all_symbols): New function.
	* target.h (Sized_target::got_entry_count): New function.
	(Sized_target::plt_entry_count): New function.
	(Sized_target::plt_entry_size): New function.
	* x86_64.cc (Target_x86_64::got_size): Add const.
	(Target_x86_64::got_entry_count): New function.
	(Target_x86_64::plt_entry_count): New function.
	(Target_x86_64::first_plt_entry_offset): New function.
	(Target_x86_64::plt_entry_size): New function.
	(Output_data_plt_x86_64::entry_count): New function.
	(Output_data_plt_x86_64::first_plt_entry_offset): New function.
	(Output_data_plt_x86_64::get_plt_entry_size): New function.
@
text
@d42 1
d1155 1
a1155 1
      is_tls_symbol_(false), has_output_value_(true)
d1368 1
a1368 1
  // Return TRUE if this is a TLS symbol.
d1373 10
d1395 1
a1395 1
  unsigned int input_shndx_ : 28;
d1403 2
d1708 13
d2137 1
d2169 2
a2170 14
  // The TLS GOT offsets of local symbols. The map stores the offsets
  // for either a single GOT entry that holds the module index of a TLS
  // symbol, or a pair of GOT entries containing the module index and
  // dtv-relative offset.
  struct Tls_got_entry
  {
    Tls_got_entry(int got_offset, bool have_pair)
      : got_offset_(got_offset),
        have_pair_(have_pair)
    { }
    int got_offset_;
    bool have_pair_;
  };
  typedef Unordered_map<unsigned int, Tls_got_entry> Local_tls_got_offsets;
d2215 2
@


1.99
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_SYMTAB,
	SHT_GNU_INCREMENTAL_RELOCS.

gold/ChangeLog:

	* archive.cc: Include incremental.h.
	(Archive::Archive): Initialize incremental_info_.
	(Archive::include_member): Record archive members in incremental info.
	(Add_archive_symbols::run): Record begin and end of an archive in
	incremental info.
	(Lib_group::include_member): Record objects in incremental info.
	* archive.h (Incremental_archive_entry): Forward declaration.
	(Archive::set_incremental_info): New member function.
	(Archive::incremental_info): New member function.
	(Archive::Unused_symbol_iterator): New class.
	(Archive::unused_symbols_begin): New member function.
	(Archive::unused_symbols_end): New member function.
	(Archive::incremental_info_): New data member.
	* incremental-dump.cc (find_input_containing_global): New function.
	(dump_incremental_inputs): Dump new incremental info sections.
	* incremental.cc: Include symtab.h.
	(Output_section_incremental_inputs): New class.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Support
	new incremental info sections.
	(Sized_incremental_binary::do_check_inputs): Likewise.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): New function.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Rewrite.
	(Incremental_inputs::finalize): Do nothing but finalize string table.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Output_section_incremental_inputs::set_final_data_size): New function.
	(Output_section_incremental_inputs::do_write): New function.
	(Output_section_incremental_inputs::write_header): New function.
	(Output_section_incremental_inputs::write_input_files): New function.
	(Output_section_incremental_inputs::write_info_blocks): New function.
	(Output_section_incremental_inputs::write_symtab): New function.
	* incremental.h (Incremental_script_entry): Forward declaration.
	(Incremental_object_entry): Forward declaration.
	(Incremental_archive_entry): Forward declaration.
	(Incremental_inputs): Forward declaration.
	(Incremental_inputs_header_data): Remove.
	(Incremental_inputs_header): Remove.
	(Incremental_inputs_header_write): Remove.
	(Incremental_inputs_entry_data): Remove.
	(Incremental_inputs_entry): Remove.
	(Incremental_inputs_entry_write): Remove.
	(enum Incremental_input_type): Add INCREMENTAL_INPUT_ARCHIVE_MEMBER.
	(Incremental_binary::find_incremental_inputs_sections): Add parameters.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Sized_ncremental_binary::do_find_incremental_inputs_sections):
	Likewise.
	(Incremental_input_entry): New class.
	(Incremental_script_entry): New class.
	(Incremental_object_entry): New class.
	(Incremental_archive_entry): New class.
	(Incremental_inputs::Incremental_inputs): Initialize new data members.
	(Incremental_inputs::report_inputs): Remove.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): Change prototype.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Change prototype.
	(Incremental_inputs::get_reloc_count): New function.
	(Incremental_inputs::set_reloc_count): New function.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::inputs_section): New function.
	(Incremental_inputs::symtab_section): New function.
	(Incremental_inputs::relocs_section): New function.
	(Incremental_inputs::get_stringpool): Add const.
	(Incremental_inputs::command_line): Add const.
	(Incremental_inputs::inputs): Remove.
	(Incremental_inputs::command_line_key): New function.
	(Incremental_inputs::input_file_count): New function.
	(Incremental_inputs::input_files): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::Input_info): Remove.
	(Incremental_inputs::lock_): Remove.
	(Incremental_inputs::inputs_): Change type.
	(Incremental_inputs::inputs_map_): Remove.
	(Incremental_inputs::current_object_entry_): New data member.
	(Incremental_inputs::inputs_section_): New data member.
	(Incremental_inputs::symtab_section_): New data member.
	(Incremental_inputs::relocs_section_): New data member.
	(Incremental_inputs::reloc_count_): New data member.
	(Incremental_inputs_reader): New class.
	(Incremental_symtab_reader): New class.
	(Incremental_relocs_reader): New class.
	* layout.cc (Layout::finalize): Move finalization of incremental info
	and creation of incremental info sections to follow finalization of
	symbol table.  Set offsets for postprocessing sections.
	(Layout::create_incremental_info_sections): Call
	Incremental_inputs::create_data_sections.  Add incremental symtab
	and relocs sections.  Set sh_entsize and sh_link fields.  Arrange for
	sections to layout after input sections.
	* layout.h (struct Timespec): Forward declaration.
	(Layout::incremental_inputs): Add const.
	(Layout::create_incremental_info_sections): Add parameter.
	* main.cc (main): Remove call to Incremental_inputs::report_inputs.
	* object.cc: Include incremental.h.
	(Relobj::finalize_incremental_relocs): New function.
	(Sized_relobj::do_layout): Record input sections in incremental info.
	* object.h (Object::output_section): New function.
	(Object::output_section_offset): Moved from Relobj.
	(Object::get_incremental_reloc_base): New function.
	(Object::get_incremental_reloc_count): New function.
	(Object::do_output_section): New function.
	(Object::do_output_section_offset): Moved from Relobj.
	(Object::do_get_incremental_reloc_base): New function.
	(Object::do_get_incremental_reloc_count): New function.
	(Object::Object): Initialize new data members.
	(Relobj::output_section): Renamed do_output_section and moved to
	protected.
	(Relobj::output_section_offset): Moved to Object.
	(Relobj::do_get_incremental_reloc_base): New function.
	(Relobj::do_get_incremental_reloc_count): New function.
	(Relobj::allocate_incremental_reloc_counts): New function.
	(Relobj::count_incremental_reloc): New function.
	(Relobj::finalize_incremental_relocs): New function.
	(Relobj::next_incremental_reloc_index): New function.
	(Relobj::reloc_counts_): New data member.
	(Relobj::reloc_bases_): New data member.
	(Sized_relobj::do_relocate_sections): Add parameter.  Change caller.
	(Sized_relobj::relocate_sections): Add parameter.  Change all callers.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* plugin.cc (Plugin_manager::add_input_file): Rewrite test for
	incremental link.
	* readsyms.cc (Read_symbols::do_read_symbols): Move reporting of
	archives and object files elsewhere.
	(Add_symbols::run): Report object files here.
	(Finish_group::run): Report end of archive at end of group.
	* reloc.cc: Include layout.h, incremental.h.
	(Sized_relobj::do_read_relocs): Need relocations for incremental link.
	(Sized_relobj::do_scan_relocs): Record relocations for incremental link.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::do_relocate_sections): Write incremental relocations.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* script.cc (read_input_script): Rewrite test for incremental link.
	Change call to Incremental_inputs::report_script.
	* symtab.h (Symbol_table::first_global_index): New function.
	(Symbol_table::output_count): New function.
@
text
@d1482 20
d1684 11
@


1.98
log
@	PR 11855
	* script.cc (Script_options::Script_options): Initialize
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_assignment): Update
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_reference): New function.
	(script_symbol): New function.
	* script.h (class Script_options): Add symbol_definitions_ and
	symbol_references_ fields.
	(Script_options::referenced_const_iterator): New type.
	(Script_options::referenced_begin): New function.
	(Script_options::referenced_end): New function.
	(Script_options::is_referenced): New function.
	(Script_options::any_unreferenced): New function.
	* script-c.h (script_symbol): Declare.
	* yyscript.y (exp): Call script_symbol.
	* symtab.cc: Include "script.h".
	(Symbol_table::gc_mark_undef_symbols): Add layout parameter.
	Change all callers.  Check symbols referenced by scripts.
	(Symbol_table::add_undefined_symbols_from_command_line): Add
	layout parameter.  Change all callers.
	(Symbol_table::do_add_undefined_symbols_from_command_line):
	Likewise.  Break out loop body.  Check symbols referenced by
	scripts.
	(Symbol_table::add_undefined_symbol_from_command_line): New
	function broken out of
	do_add_undefined_symbols_from_command_line.
	* symtab.h (class Symbol_table): Update declarations.
	* archive.cc: Include "layout.h".
	(Archive::should_include_member): Add layout parameter.  Change
	all callers.  Check for symbol mentioned in expression.
	* archive.h (class Archive): Update declaration.
	* object.cc (Sized_relobj::do_should_include_member): Add layout
	parameter.
	* object.h (Object::should_include_member): Add layout parameter.
	Change all callers.
	(Object::do_should_include_member): Add layout parameter.
	(class Sized_relobj): Update declaration.
	* dynobj.cc (Sized_dynobj::do_should_include_member): Add layout
	parameter.
	* dynobj.h (class Sized_dynobj): Update declaration.
	* plugin.cc (Sized_pluginobj::do_should_include_member): Add
	layout parameter.
	* plugin.h (class Sized_pluginobj): Update declaration.
@
text
@d390 12
d540 10
d615 11
d677 12
d733 3
a735 1
      sd_(NULL)
a830 10
  // Given a section index, return the corresponding Output_section.
  // The return value will be NULL if the section is not included in
  // the link.
  Output_section*
  output_section(unsigned int shndx) const
  {
    gold_assert(shndx < this->output_sections_.size());
    return this->output_sections_[shndx];
  }

a840 7
  // Given a section index, return the offset in the Output_section.
  // The return value will be -1U if the section is specially mapped,
  // such as a merge section.
  uint64_t
  output_section_offset(unsigned int shndx) const
  { return this->do_output_section_offset(shndx); }

d889 10
a944 4
  // Get the offset of a section--implemented by child class.
  virtual uint64_t
  do_output_section_offset(unsigned int shndx) const = 0;

d954 10
d987 40
d1046 4
d1885 2
a1886 1
		       const unsigned char* pshdrs, Views* pviews);
d1974 3
a1976 2
		    const unsigned char* pshdrs, Views* pviews)
  { this->do_relocate_sections(symtab, layout, pshdrs, pviews); }
d2013 29
@


1.97
log
@	* compressed_output.cc (zlib_decompress): New function.
	(get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* compressed_output.h (get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info)
	Handle compressed debug sections.
	* layout.cc (is_compressed_debug_section): New function.
	(Layout::output_section_name): Map compressed section names to
	canonical names.
	* layout.h (is_compressed_debug_section): New function.
	(is_debug_info_section): Recognize compressed debug sections.
	* merge.cc: Include compressed_output.h.
	(Output_merge_data::do_add_input_section): Handle compressed
	debug sections.
	(Output_merge_string::do_add_input_section): Handle compressed
	debug sections.
	* object.cc: Include compressed_output.h.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(build_compressed_section_map): New function.
	(Sized_relobj::do_read_symbols): Handle compressed debug sections.
	* object.h (Object::section_is_compressed): New method.
	(Object::do_section_is_compressed): New method.
	(Sized_relobj::Compressed_section_map): New type.
	(Sized_relobj::do_section_is_compressed): New method.
	(Sized_relobj::compressed_sections_): New data member.
	* output.cc (Output_section::add_input_section): Handle compressed
	debug sections.
	* reloc.cc: Include compressed_output.h.
	(Sized_relobj::write_sections): Handle compressed debug sections.
@
text
@d408 3
a410 3
  should_include_member(Symbol_table* symtab, Read_symbols_data* sd,
                        std::string* why)
  { return this->do_should_include_member(symtab, sd, why); }
d549 1
a549 1
  do_should_include_member(Symbol_table* symtab, Read_symbols_data*,
d1626 1
a1626 1
  do_should_include_member(Symbol_table* symtab, Read_symbols_data*,
@


1.96
log
@	* object.cc (Sized_relobj::do_layout): Defer layout for reloc sections.
	(Sized_relobj::do_layout_deferred_sections): Do layout for deferred
	reloc sections.
	* object.h (Sized_relobj::deferred_layout_relocs_): New data member.

	PR 11683
	* symtab.h (Symbol::is_placeholder): New member function.
	* target-reloc.h (relocate_section): Check for placeholder symbols.

	* testsuite/Makefile.am (plugin_test_8): New test.
	(plugin_test_9): New test.
	* testsuite/Makefile.in: Regenerate.
@
text
@d521 7
d638 6
d1422 4
d1801 20
a1820 1
   
d2063 2
@


1.95
log
@	* archive.cc (include_member): Destroy Read_symbols_data object before
	releasing file.
	* object.cc (Read_symbols_data::~Read_symbols_data) New destructor.
	* object.h (Read_symbols_data::Read_symbols_data) New constructor.
	(Read_symbols_data::~Read_symbols_data) New destructor.
	(Section_relocs::Section_relocs) New constructor.
	(Section_relocs::~Section_relocs) New destructor.
	(Read_relocs_data::Read_relocs_data) New constructor.
	(Read_relocs_data::~Read_relocs_data) New destructor.
	* testsuite/binary_unittest.cc (Sized_binary_test): Set sd member
	pointers to NULL after deleting.
@
text
@d2025 2
@


1.94
log
@2010-03-22  Rafael Espindola  <espindola@@google.com>

	* archive.cc (Should_include): Move to archive.h.
	(should_include_member): Make it a member of Archive.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* archive.h: Include options.h.
	(Archive_member): Moved from Archive.
	(Should_include): Moved from archive.cc.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* dynobj.cc (do_should_include_member): New.
	* dynobj.h (do_should_include_member): New.
	* gold.cc (queue_initial_tasks): Update call to queue.
	* main.cc (main): Print lib group stats.
	* object.cc (do_should_include_member): New.
	* object.h: Include archive.h.
	(Object::should_include_member): New.
	(Object::do_should_include_member): New.
	(Sized_relobj::do_should_include_member): New.
	* options.cc (General_options::parse_start_lib): New.
	(General_options::parse_end_lib): New.
	(Input_arguments::add_file): Handle lib groups.
	(Input_arguments::start_group): Check we are not in a lib.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib): New.
	* options.h (General_options): Add start_lib and end_lib.
	(Input_argument::lib_): New.
	(Input_argument::lib): New.
	(Input_argument::is_lib): New.
	(Input_file_lib): New.
	(Input_arguments::in_lib_): New.
	(Input_arguments::in_lib): New.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib_): New.
	* plugin.cc (Pluginobj::get_symbol_resolution_info): Mark symbols
	in unused members as preempted.
	(Sized_pluginobj::do_should_include_member): New.
	* plugin.h (Sized_pluginobj::do_should_include_member): New.
	* readsyms.cc (Read_symbols::locks): If we are just reading a member,
	return the blocker.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::do_read_symbols): Handle lib groups.
	(Read_symbols::get_name): Handle lib groups.
	* readsyms.h (Read_symbols): Add an archive member pointer.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::member_): New.
	* script.cc (read_input_script): Update call to queue_soon.
@
text
@d58 7
d112 7
d142 7
@


1.93
log
@	* target-reloc.h (relocate_section): Check the symbol table index
	for -1U before setting the local symbol index.
	(scan_relocatable_relocs): If copying the relocation, record that
	the local symbol is required.
	* object.h (Symbol_value::is_output_symtab_index_set): New
	function.
	(Symbol_value::may_be_discarded_from_output_symtab): New
	function.
	(Symbol_value::has_output_symtab_entry): New function.
	(Symbol_value::needs_output_symtab_entry): Remove.
	(Symbol_value::output_symtab_index): Make sure the symbol index is
	set.
	(Symbol_value::set_output_symtab_index): Make sure the symbol
	index is not set.  Make sure the new index is valid.
	(Symbol_value::set_must_have_output_symtab_entry): New function.
	(Symbol_value::has_output_dynsym_entry): New function.
	(Symbol_value::set_output_dynsym_index): Make sure the new index
	is valid.
	(Sized_relobj::set_must_have_output_symtab_entry): New function.
	* object.cc (Sized_relobj::do_count_local_symbols): Only discard a
	local symbol if permitted.
	(Sized_relobj::do_finalize_local_symbols): Call
	is_output_symtab_index_set rather than needs_output_symtab_entry.
	(Sized_relobj::write_local_symbols): Call has_output_symtab_entry
	rather than needs_output_symtab_entry.  Call
	has_output_dynsym_entry rather than needs_output_dynsym_entry.
	* arm.cc (Arm_relobj::update_output_local_symbol_count): Call
	is_output_symtab_index_set rather than needs_output_symtab_entry.
	* testsuite/discard_locals_relocatable_test.c: New file.
	* testsuite/discard_locals_test.sh: Test -r.
	* testsuite/Makefile.am (check_DATA): Add
	discard_locals_relocatable_test1.syms,
	discard_local_relocatable_test2.syms.
	(MOSTLYCLEANFILES): Likewise.  Also add
	discard_locals_relocatable_test1.lout and
	discard_locals_relocatable_test2.out.
	(discard_locals_relocatable_test1.syms): New target.
	(discard_locals_relocatable_test.o): New target.
	(discard_locals_relocatable_test1.out): New target.
	(discard_locals_relocatable_test2.syms): New target.
	(discard_locals_relocatable_test2.out): New target.
	(various): Add missing ../ld-new dependencies.
	* testsuite/Makefile.in: Rebuild.
@
text
@d33 1
a40 1
class Archive;
d385 6
d520 4
d1587 4
@


1.92
log
@	* dirsearch.cc (Dirsearch::initialize): Add all blockers before
	queueing any tasks.
	* gold.cc (queue_middle_gc_tasks): Likewise.  Fix final blocker.
	(queue_middle_tasks): Add all blockers before queueing any tasks.
	(queue_final_tasks): Likewise.
	* token.h (Task_token::add_blockers): New function.
	* object.h (Input_objects::number_of_relobjs): New function.
@
text
@d1090 19
a1108 1
  // Return whether this symbol should go into the output symbol
d1111 5
a1115 2
  needs_output_symtab_entry() const
  { return this->output_symtab_index_ != -1U; }
d1121 2
a1122 1
    gold_assert(this->output_symtab_index_ != 0);
d1130 2
a1131 1
    gold_assert(this->output_symtab_index_ == 0);
d1144 9
d1161 1
a1161 1
  // Return whether this symbol should go into the output symbol
d1169 9
d1183 1
d1240 4
a1243 1
  // will be -1 if the symbol should not go into the symbol table.
d1246 1
a1246 1
  // will be -1 if the symbol should not go into the symbol table.
d1469 8
@


1.91
log
@2010-01-29  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::Arm_relobj): Initialize new data member
	output_local_symbol_count_needs_update_.
	(Arm_relobj::output_local_symbol_count_needs_update,
	 Arm_relobj::set_output_local_symbol_count_needs_update,
	 Arm_relobj::update_output_local_symbol_count): New methods.
	(Arm_relobj::output_local_symbol_count_needs_update_): New data
	member.
	(Arm_exidx_cantunwind::do_fixed_endian_write): Write address
	of pointed function as in a R_ARM_PREL31 relocation.
	(Arm_output_section<big_endian>::fix_exidx_coverage): Mark objects
	for output local symbol count updating.
	(Target_arm::do_relax): Update output local symbol counts in objects
	if necessary.
	* object.h (Sized_relobj::set_output_local_symbol_count): New method.
@
text
@d2012 5
@


1.90
log
@2010-01-26  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (set): Include.
	(class Arm_exidx_fixup): Change type of last_input_section_ to const
	pointer type.
 	(Arm_output_section::Text_section_list): New type.
	(Arm_output_section::append_text_sections_to_list): New method.
	(Arm_output_section::fix_exidx_coverage): Ditto.
	(Arm_relobj::Arm_relobj): Initialize exidx_section_map_.
   	(Arm_relobj::convert_input_section_to_relaxed_section): Use
	Relobj::set_section_offset() instead of
	Sized_relobj::invalidate_section_offset().
   	(Arm_relobj::section_needs_reloc_stub_scanning): Add an extra
	parameter for section headers. Ignore relocation sections for
	unallocated sections and EXIDX sections.
	(Target_arm::fix_exidx_coverage): New method.
	(Target_arm::output_section_address_less_than): New type.
	(Arm_exidx_fixup::add_exidx_cantunwind_as_needed): Use index of the
	linked text section instead of the EXIDX section.
	(Arm_output_section::create_stub_group): Add an assertion to check
	that this is not an EXIDX output section.
	(Arm_output_section::append_text_sections_to_list): New method.
	(Arm_output_section::fix_exidx_coverage): Ditto.
	(Arm_relobj::scan_sections_for_stubs): Adjust call to
   	Arm_relobj::section_needs_reloc_stub_scanning.
	(Target_arm::do_relax): Fix EXIDX output section coverage in the
	first pass.
	(Target_arm::fix_exidx_coverage): New method.
	* object.h (Relobj::set_output_section): New method.
	(Sized_relobj::invalidate_section_offset): Remove method.
	(Sized_relobj::do_invalidate_section_offset): Remove method.
	(Sized_relobj::do_set_section_offset): Handle offset value -1.
@
text
@d1692 5
@


1.89
log
@2010-01-20  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::Arm_input_section_map): Change key type from
	Input_section_specifier to Section_id.
	(Target_arm::new_arm_input_section: Adjust code for change of key
	type.
	(Target_arm::find_arm_input_section): Ditto.
	* gc.h (object.h): Include for Section_id nand Section_id_hash.
	(Section_id): Remove.
	(Garbage_collection::Section_id_hash): Remove.
	* icf.h (object.h): Include for Section_id nand Section_id_hash.
	(Section_id): Remove.
	(Icf::Section_id_hash): Remove.
	* object.h (Section_id, Const_section_id, Section_id_hash,
	Const_section_id_hash): New type definitions.
	* output.cc (Output_section::add_relaxed_input_section): Change to
	use Const_section_id instead of Input_section_specifier as key type.
	(Output_section::add_merge_input_section): Ditto.
	(Output_section::build_relaxation_map): Change to use Section_id
	instead of Input_section_specifier as key type.
 	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Ditto.
	(Output_section::convert_input_sections_to_relaxed_sections): Change
	to use Const_section_id instead of Input_section_specifier as key type.
 	(Output_section::find_merge_section): Ditto.
	(Output_section::find_relaxed_input_section): Ditto.
	* output.h (Input_section_specifier): Remove class.
	(Output_section::Output_section_data_by_input_section_map): Change
	key type to Const_section_id.
	(Output_section::Output_relaxed_input_section_by_input_section_map):
	Ditto.
	(Output_section::Relaxation_map): Change key type to Section_id.
@
text
@d750 10
a1496 5
  // Make section offset invalid.  This is needed for relaxation.
  void
  invalidate_section_offset(unsigned int shndx)
  { this->do_invalidate_section_offset(shndx); }

d1634 4
a1637 9
    this->section_offsets_[shndx] = convert_types<Address, uint64_t>(off);
  }

  // Set the offset of a section to invalid_address.
  virtual void
  do_invalidate_section_offset(unsigned int shndx)
  {
    gold_assert(shndx < this->section_offsets_.size());
    this->section_offsets_[shndx] = invalid_address;
@


1.88
log
@	PR 10980
	* options.h (class General_options): Add --cref.
	* main.cc (main): Print cref table if --cref.  Don't close mapfile
	until after printing cref table.
	* cref.cc: Include "symtab.h".
	(class Cref_inputs): Define Cref_table_compare and Cref_table.
	(Cref_table_compare::operator()): New function.
	(Cref_inputs::gather_cref): New function.
	(filecol): New static const.
	(Cref_inputs::print_cref): New function.
	(Cref::print_cref): New function.
	* cref.h: Include <cstdio>.
	(class Cref): Update declarations.
	* mapfile.h (Mapfile::file): New function.
	* object.h (class Object): Define Symbols.  Declare virtual
	do_get_global_symbols.
	(Object::get_global_symbols): New function.
	* object.cc (Input_objects::add_object): Pass object to cref_ if
	--cref.
	(Input_objects::archive_start): Likewise.
	(Input_objects::archive_stop): Likewise.
	(Input_objects::print_cref): New function.
	* dynobj.h (Sized_dynobj::do_get_global_symbols): New function.
	* dynobj.cc (big_endian>::do_add_symbols): Create symbols_ if
	--cref.
	* plugin.cc (Sized_pluginobj::do_get_global_symbols): New
	function.
	* plugin.h (class Sized_pluginobj): Update declarations.
@
text
@d2053 25
@


1.87
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d191 2
d471 5
d563 3
d1609 5
d1978 4
@


1.86
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d195 4
a198 4
  Object(const std::string& oname, Input_file* oinput_file, bool ois_dynamic,
	 off_t ooffset = 0)
    : name_(oname), input_file_(oinput_file), offset_(ooffset), shnum_(-1U),
      is_dynamic_(ois_dynamic), is_needed_(false), uses_split_stack_(false),
d200 1
a200 1
  { oinput_file->file().add_object(); }
d375 2
a376 2
  layout(Symbol_table* symtab, Layout* olayout, Read_symbols_data* sd)
  { this->do_layout(symtab, olayout, sd); }
d380 2
a381 2
  add_symbols(Symbol_table* symtab, Read_symbols_data* sd, Layout *olayout)
  { this->do_add_symbols(symtab, sd, olayout); }
d558 2
a559 2
  set_shnum(int sec_shnum)
  { this->shnum_ = sec_shnum; }
d628 2
a629 2
  Relobj(const std::string& rname, Input_file* rinput_file, off_t roffset = 0)
    : Object(rname, rinput_file, false, roffset),
d679 2
a680 2
  gc_process_relocs(Symbol_table* symtab, Layout* olayout, Read_relocs_data* rd)
  { return this->do_gc_process_relocs(symtab, olayout, rd); }
d684 2
a685 2
  scan_relocs(Symbol_table* symtab, Layout* olayout, Read_relocs_data* rd)
  { return this->do_scan_relocs(symtab, olayout, rd); }
d719 2
a720 2
  relocate(const Symbol_table* symtab, const Layout* olayout, Output_file* of)
  { return this->do_relocate(symtab, olayout, of); }
d792 2
a793 2
  layout_deferred_sections(Layout* olayout)
  { this->do_layout_deferred_sections(olayout); }
d1021 2
a1022 2
  set_output_value(Value val)
  { this->u_.value = val; }
d1061 2
a1062 2
  set_input_value(Value val)
  { this->u_.value = val; }
d1738 1
a1738 1
  relocate_sections(const Symbol_table* symtab, const Layout* olayout,
d1740 1
a1740 1
  { this->do_relocate_sections(symtab, olayout, pshdrs, pviews); }
@


1.85
log
@	PR 10880
	* object.h (class Object): Add is_needed and set_is_needed
	methods.  Add is_needed_ field.  Make bool fields into bitfields.
	* symtab.cc (Symbol_table::set_dynsym_indexes): If a symbol is
	defined in a dynamic object and referenced by a regular object,
	set is_needed for the dynamic object.
	* layout.cc (Layout::finish_dynamic_section): Don't add DT_NEEDED
	if the file is marked with as_needed and it is not needed.
@
text
@d195 4
a198 4
  Object(const std::string& name, Input_file* input_file, bool is_dynamic,
	 off_t offset = 0)
    : name_(name), input_file_(input_file), offset_(offset), shnum_(-1U),
      is_dynamic_(is_dynamic), is_needed_(false), uses_split_stack_(false),
d200 1
a200 1
  { input_file->file().add_object(); }
d375 2
a376 2
  layout(Symbol_table* symtab, Layout* layout, Read_symbols_data* sd)
  { this->do_layout(symtab, layout, sd); }
d380 2
a381 2
  add_symbols(Symbol_table* symtab, Read_symbols_data* sd, Layout *layout)
  { this->do_add_symbols(symtab, sd, layout); }
d558 2
a559 2
  set_shnum(int shnum)
  { this->shnum_ = shnum; }
d628 2
a629 2
  Relobj(const std::string& name, Input_file* input_file, off_t offset = 0)
    : Object(name, input_file, false, offset),
d679 2
a680 2
  gc_process_relocs(Symbol_table* symtab, Layout* layout, Read_relocs_data* rd)
  { return this->do_gc_process_relocs(symtab, layout, rd); }
d684 2
a685 2
  scan_relocs(Symbol_table* symtab, Layout* layout, Read_relocs_data* rd)
  { return this->do_scan_relocs(symtab, layout, rd); }
d719 2
a720 2
  relocate(const Symbol_table* symtab, const Layout* layout, Output_file* of)
  { return this->do_relocate(symtab, layout, of); }
d792 2
a793 2
  layout_deferred_sections(Layout* layout)
  { this->do_layout_deferred_sections(layout); }
d1021 2
a1022 2
  set_output_value(Value value)
  { this->u_.value = value; }
d1061 2
a1062 2
  set_input_value(Value value)
  { this->u_.value = value; }
d1738 1
a1738 1
  relocate_sections(const Symbol_table* symtab, const Layout* layout,
d1740 1
a1740 1
  { this->do_relocate_sections(symtab, layout, pshdrs, pviews); }
@


1.84
log
@	* object.h (class Relobj): Drop options parameter from
	gc_process_relocs, scan_relocs, relocate, do_gc_process_relocs,
	do_scan_relocs, do_relocate.  Change all callers.
	(class Sized_relobj): Drop options parameters from
	do_gc_process_relocs, do_scan_relocs, do_relocate,
	do_relocate_sections, relocate_sections, emit_relocs_scan,
	emit_relocs_scan_reltype.  Change all callers.
	(struct Relocate_info): Remove options field and all references to
	it.
	* reloc.h (class Read_relocs): Remove options constructor
	parameter and options_ field.  Change all callers.
	(class Gc_process_relocs, class Scan_relocs): Likewise.
	(class Relocate_task): Likewise.
	* target-reloc.h (scan_relocs): Remove options parameter.  Change
	all callers.
	(scan_relocatable_relocs): Likewise.
	* target.h (class Sized_target): Remove options parameter from
	gc_process_relocs, scan_relocs, scan_relocatable_relocs.  Change
	all callers.
	* gc.h (gc_process_relocs): Remove options parameter.  Change all
	callers.
	* arm.cc: Update functions to remove options parameters.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* testsuite/testfile.cc: Likewise.
@
text
@d198 2
a199 2
      is_dynamic_(is_dynamic), uses_split_stack_(false),
      has_no_split_stack_(false), xindex_(NULL), no_export_(false)
d220 13
d605 5
a609 1
  bool is_dynamic_;
d611 1
a611 1
  bool uses_split_stack_;
d614 4
a617 1
  bool has_no_split_stack_;
a619 3
  // True if exclude this object from automatic symbol export.
  // This is used only for archive objects.
  bool no_export_;
@


1.83
log
@2009-10-25  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_output_section, Arm_relobj): Forward class declarations.
	(Arm_input_section::as_arm_input_section): New method.
	(Arm_output_section): New class definition.
	(Arm_output_section::create_stub_group,
	Arm_output_section::group_sections): New method definitions.
@
text
@d662 2
a663 3
  gc_process_relocs(const General_options& options, Symbol_table* symtab,
	            Layout* layout, Read_relocs_data* rd)
  { return this->do_gc_process_relocs(options, symtab, layout, rd); }
d667 2
a668 3
  scan_relocs(const General_options& options, Symbol_table* symtab,
	      Layout* layout, Read_relocs_data* rd)
  { return this->do_scan_relocs(options, symtab, layout, rd); }
d702 2
a703 3
  relocate(const General_options& options, const Symbol_table* symtab,
	   const Layout* layout, Output_file* of)
  { return this->do_relocate(options, symtab, layout, of); }
d790 1
a790 2
  do_gc_process_relocs(const General_options&, Symbol_table*, Layout*,
		 Read_relocs_data*) = 0;
d794 1
a794 2
  do_scan_relocs(const General_options&, Symbol_table*, Layout*,
		 Read_relocs_data*) = 0;
d822 1
a822 2
  do_relocate(const General_options& options, const Symbol_table* symtab,
	      const Layout*, Output_file* of) = 0;
d1499 1
a1499 2
  do_gc_process_relocs(const General_options&, Symbol_table*, Layout*,
		       Read_relocs_data*);
d1503 1
a1503 2
  do_scan_relocs(const General_options&, Symbol_table*, Layout*,
		 Read_relocs_data*);
d1524 1
a1524 2
  do_relocate(const General_options& options, const Symbol_table* symtab,
	      const Layout*, Output_file* of);
d1657 1
a1657 2
  do_relocate_sections(const General_options& options,
		       const Symbol_table* symtab, const Layout* layout,
d1721 3
a1723 4
  relocate_sections(const General_options& options, const Symbol_table* symtab,
		    const Layout* layout, const unsigned char* pshdrs,
		    Views* pviews)
  { this->do_relocate_sections(options, symtab, layout, pshdrs, pviews); }
d1727 1
a1727 2
  emit_relocs_scan(const General_options&, Symbol_table*, Layout*,
		   const unsigned char* plocal_syms,
d1734 1
a1734 1
  emit_relocs_scan_reltype(const General_options&, Symbol_table*, Layout*,
a1995 2
  // Command line options.
  const General_options* options;
@


1.82
log
@	* object.h (class Relocate_info): Add reloc_shdr and data_shdr
	fields.
	* object.cc (Sized_relobj::relocate_sections): Set reloc_shdr and
	data_shdr fields of relinfo.
	* i386.cc (class Target_i386::Relocate): Remove ldo_addrs_ field.
	(Target_i386::Relocate::relocate_tls): Don't call fix_up_ldo.  For
	R_386_TLS_LDO_32, adjust based on section flags.
	(Target_i386::Relocate::fix_up_ldo): Remove.
@
text
@d1651 19
a1723 13
  // Views and sizes when relocating.
  struct View_size
  {
    unsigned char* view;
    typename elfcpp::Elf_types<size>::Elf_Addr address;
    off_t offset;
    section_size_type view_size;
    bool is_input_output_view;
    bool is_postprocessing_view;
  };

  typedef std::vector<View_size> Views;

d1731 4
a1734 2
  relocate_sections(const General_options& options, const Symbol_table*,
		    const Layout*, const unsigned char* pshdrs, Views*);
@


1.81
log
@2009-10-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::make_output_section): Call target hook to make
	ordinary output section.
	(Layout::finalize): Adjust parameter list of call the
	Target::may_relax().
	* layout.h (class Layout::section_list): New method.
	* merge.h (Output_merge_base::entsize): Change visibility to public.
	(Output_merge_base::is_string, Output_merge_base::do_is_string):
	New methods.
	(Output_merge_string::do_is_string): New method.
	* object.cc (Sized_relobj::do_setup): renamed from
	Sized_relobj::set_up.
	* object.h (Sized_relobj::adjust_shndx,
	Sized_relobj::initializ_input_to_output_maps,
	Sized_relobj::free_input_to_output_maps): Change visibilities to
	protected.
	(Sized_relobj::setup): Virtualize.
	(Sized_relobj::do_setup): New method declaration.
	(Sized_relobj::invalidate_section_offset,
	Sized_relobj::do_invalidate_section_offset): New method decfinitions.
	(Sized_relobj::elf_file, Sized_relobj::local_values): New methods.
	* options.cc (parse_int): New function.
	* options.h (parse_int): New declaration.
	(DEFINE_int): New macro.
	(stub_group_size): New option.
	* output.cc (Output_section::Output_section): Initialize memebers
	merge_section_map_, merge_section_by_properties_map_,
	relaxed_input_section_map_, is_relaxed_input_section_map_valid_.
	(Output_section::add_input_section): Handled deferred code-fill
	generation and remove an old comment.
	(Output_section::add_relaxed_input_section): New method definition.
	(Output_section::add_merge_input_section): Use merge section by
	properties map to speed to search.  Update merge section maps
	as appropriate.
	(Output_section::build_relaxation_map): New method definition.
	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Same.
	(Output_section::relax_input_section): Renamed to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of pointers to relaxed sections.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section): New method definitions.
	(Output_section::is_input_address_mapped,
	Output_section::output_offset, Output_section::output_address):
	Use output section data maps to speed up searching.
	(Output_section::find_starting_output_address): Add comments.
	(Output_section::do_write,
	Output_section::write_to_postprocessing_buffer): Do code-fill
	generation as appropriate.
	(Output_section::get_input_sections): Invalidate relaxed input section
	map.
	(Output_section::restore_states): Adjust type of checkpoint .
	Invalidate relaxed input section map.
	* output.h (Output_merge_base): New class declaration.
	(Input_section_specifier): New class defintion.
	(class Output_relaxed_input_section) Change base class to
	Output_section_data_build.
	(Output_relaxed_input_section::Output_relaxed_input_section): Adjust
	base class initializer.
	(Output_section::add_relaxed_input_section): New method declaration.
	(Output_section::Input_section): Change visibility to protected.
     	(Output_section::Input_section::relobj,
	Output_section::Input_section::shndx): Handle relaxed input sections.
	Output_section::input_sections) Change visibility to protected.  Also
	define overload to return a non-const pointer.
	(Output_section::Merge_section_properties): New class defintion.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Relaxation_map): New types.
	(Output_section::relax_input_section): Rename method to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of relaxed section pointers.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section,
	Output_section::build_relaxation_map,
	Output_section::convert_input_sections_in_list_to_relaxed_sections):
	New method declarations.
	(Output_section::merge_section_map_
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_,
	Output_section::generate_code_fills_at_write_): New data members.
	* script-sections.cc
	(Output_section_element_input::set_section_addresses): Call
	current_data_size and addralign methods of relaxed input sections.
	(Orphan_output_section::set_section_addresses): Call current_data_size
	and addralign methods of relaxed input sections.
	* symtab.cc (Symbol_table::compute_final_value): Extract template
	from the body of Symbol_table::sized_finalize_symbol.
	(Symbol_table::sized_finalized_symbol): Call
	Symbol_table::compute_final_value.
	* symtab.h (Symbol_table::Compute_final_value_status): New enum type.
	(Symbol_table::compute_final_value): New templated method declaration.
	* target.cc (Target::do_make_output_section): New method defintion.
	* target.h (Target::make_output_section): New method declaration.
	(Target::relax): Add more parameters for input objects, symbol table
	and layout.  Adjust call to do_relax.
	(Target::do_make_output_section): New method declaration.
	(Target::do_relax): Add parameters for input objects, symbol table
	and layout.
@
text
@d2010 2
d2014 2
@


1.80
log
@	* options.h (class General_options): Define
	split_stack_adjust_size parameter.
	* object.h (class Object): Add uses_split_stack_ and
	has_no_split_stack_ fields.  Add uses_split_stack and
	has_no_split_stack accessor functions.  Declare
	handle_split_stack_section.
	(class Reloc_symbol_changes): Define.
	(class Sized_relobj): Define Function_offsets.  Declare
	split_stack_adjust, split_stack_adjust_reltype, and
	find_functions.
	* object.cc (Object::handle_split_stack_section): New function.
	(Sized_relobj::do_layout): Call handle_split_stack_section.
	* dynobj.cc (Sized_dynobj::do_layout): Call
	handle_split_stack_section.
	* reloc.cc (Sized_relobj::relocate_sections): Call
	split_stack_adjust for executable sections in split_stack
	objects.  Pass reloc_map to relocate_section.
	(Sized_relobj::split_stack_adjust): New function.
	(Sized_relobj::split_stack_adjust_reltype): New function.
	(Sized_relobj::find_functions): New function.
	* target-reloc.h: Include "object.h".
	(relocate_section): Add reloc_symbol_changes parameter.  Change
	all callers.
	* target.h (class Target): Add calls_non_split method.  Declare
	do_calls_non_split virtual method.  Declare match_view and
	set_view_to_nop.
	* target.cc: Include "elfcpp.h".
	(Target::do_calls_non_split): New function.
	(Target::match_view): New function.
	(Target::set_view_to_nop): New function.
	* gold.cc (queue_middle_tasks): Give an error if mixing
	split-stack and non-split-stack objects with -r.
	* i386.cc (Target_i386::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_i386::do_calls_non_split): New function.
	* x86_64.cc (Target_x86_64::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_x86_64::do_calls_non_split): New function.
	* arm.cc (Target_arm::relocate_section): Add reloc_symbol_changes
	parameter.
	* powerpc.cc (Target_powerpc::relocate_section): Add
	reloc_symbol_changes parameter.
	* sparc.cc (Target_sparc::relocate_section): Add
	reloc_symbol_changes parameter.
	* configure.ac: Call AM_CONDITIONAL for the default target.
	* configure: Rebuild.
	* testsuite/Makefile.am (TEST_AS): New variable.
	(check_SCRIPTS): Add split_i386.sh and split_x86_64.sh.
	(check_DATA): Add split_i386 and split_x86_64 files.
	(SPLIT_DEFSYMS): Define.
	(split_i386_[1234n].o): New targets.
	(split_i386_[124]): New targets.
	(split_i386_[1234r].stdout): New targets.
	(split_x86_64_[1234n].o): New targets.
	(split_x86_64_[124]): New targets.
	(split_x86_64_[1234r].stdout): New targets.
	(MOSTLYCLEANFILES): Add new executables.
	* testsuite/split_i386.sh: New file.
	* testsuite/split_x86_64.sh: New file.
	* testsuite/split_i386_1.s: New file.
	* testsuite/split_i386_2.s: New file.
	* testsuite/split_i386_3.s: New file.
	* testsuite/split_i386_4.s: New file.
	* testsuite/split_i386_n.s: New file.
	* testsuite/split_x86_64_1.s: New file.
	* testsuite/split_x86_64_2.s: New file.
	* testsuite/split_x86_64_3.s: New file.
	* testsuite/split_x86_64_4.s: New file.
	* testsuite/split_x86_64_n.s: New file.
	* testsuite/testfile.cc (Target_test): Update relocation_section
	function.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1327 2
a1328 1
  setup();
d1466 5
d1472 4
d1609 42
a1672 9
  // Adjust a section index if necessary.
  unsigned int
  adjust_shndx(unsigned int shndx)
  {
    if (shndx >= elfcpp::SHN_LORESERVE)
      shndx += this->elf_file_.large_shndx_offset();
    return shndx;
  }

a1787 10
  // Initialize input to output maps for section symbols in merged
  // sections.
  void
  initialize_input_to_output_maps();

  // Free the input to output maps for section symbols in merged
  // sections.
  void
  free_input_to_output_maps();

@


1.79
log
@	* object.h (class Object): Remove target_ field, and target,
	sized_target, and set_target methods.
	(Object::sized_target): Remove.
	(class Sized_relobj): Update declarations.  Remove sized_target.
	* object.cc (Sized_relobj::setup): Remove target parameter.
	Change all callers.
	(Input_objects::add_object): Don't do anything with the target.
	(make_elf_sized_object): Add punconfigured parameter.  Change all
	callers.  Set or test parameter target.
	* dynobj.cc (Sized_dynobj::target): Remove target parameter.
	Change all callers.
	* parameters.cc (Parameters::set_target): Change parameter type to
	be non-const.
	(Parameters::default_target): Remove.
	(set_parameters_target): Change parameter type to be non-const.
	(parameters_force_valid_target): New function.
	(parameters_clear_target): New function.
	* parameters.h (class Parameters): Update declarations.  Remove
	default_target method.  Add sized_target and clear_target
	methods.  Change target_ to be non-const.
	(set_parameters_target): Update declaration.
	(parameters_force_valid_target): Declare.
	(parameters_clear_target): Declare.
	* readsyms.cc (Read_symbols::do_read_symbols): Pass punconfigured
	as NULL if we aren't searching.
	(Add_symbols::run): Don't check for compatible target.
	* fileread.cc (Input_file::open_binary): Call
	parameters_force_valid_target.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (make_sized_plugin_object): Likewise.  Don't call
	set_target on object.
	* dynobj.h (class Sized_dynobj): Update declarations.
	* archive.cc (Archive::get_elf_object_for_member): Return NULL if
	make_elf_object returns NULL.
	(Archive::include_member): Don't check whether object target is
	compatible.
	* output.cc (Output_section::add_input_section): Get target from
	parameters.
	(Output_section::relax_input_section): Likewise.
	* reloc.cc (Sized_relobj::do_gc_process_relocs): Get target from
	parameters.
	(Sized_relobj::do_scan_relocs): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* symtab.cc (Symbol_table::wrap_symbol): Likewise.  Remove object
	parameter.  Change all callers.
	(Symbol_table::add_from_object): Get target from parameters.
	(Symbol_table::add_from_relobj): Don't check object target.
	(Symbol_table::add_from_dynobj): Likewise.
	(Symbol_table::define_special_symbol): Get target from
	parameters.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/binary_unittest.cc (gold_testsuite): Remove target
	parameter.  Change all callers.  Clear parameter target.
	(Binary_test): Test target here.
	* testsuite/object_unittest.cc (gold_testsuite): Remove
	target_test_pointer parameter.  Change all callers.
	(Object_test): Test target here.
@
text
@d198 2
a199 1
      is_dynamic_(is_dynamic), xindex_(NULL), no_export_(false)
d220 11
d571 6
d593 5
d1278 24
d1721 24
@


1.78
log
@2009-08-18  Doug Kwan  <dougkwan@@google.com>

	* dynobj.cc (Sized_dynobj::setup): Take a Target object instead of
	an elcpp::Ehdr as parameter.  Adjust call to set_target.
	* dynobj.h (Sized_dynobj::setup): Take a Target object instead of
	an elfcpp::Ehdr as parameter.
	* object.cc (Object::set_target): Remove the version that looks up
	a target and sets it.
	(Sized_relobj::setup): Take a Target object instead of
	an elfcpp::Ehdr as parameter.  Adjust call to set_target.
	(make_elf_sized_object): Find target and ask target to
	make an ELF object.
	* object.h: (Object::set_target): Remove the version that looks up
	a target and sets it.
	(Sized_relobj::setup): Take a Target object instead of
	an elfcpp:Ehdr as parameter.
	* target.cc: Include dynobj.h.
	(Target::do_make_elf_object_implementation): New.
 	(Target::do_make_elf_object): New.
	* target.h (Target::make_elf_object): New template declaration.
	(Target::do_make_elf_object): New method declarations.
	(Target::do_make_elf_object_implementation): New template declaration.
@
text
@d198 1
a198 1
      is_dynamic_(is_dynamic), target_(NULL), xindex_(NULL), no_export_(false)
a224 5
  // Return the target structure associated with this object.
  Target*
  target() const
  { return this->target_; }

a263 7
  // Return the sized target structure associated with this object.
  // This is like the target method but it returns a pointer of
  // appropriate checked type.
  template<int size, bool big_endian>
  Sized_target<size, big_endian>*
  sized_target() const;

a443 5
  // Set the target.
  void
  set_target(Target* target)
  { this->target_ = target; }

a574 2
  // Target functions--may be NULL if the target is not known.
  Target* target_;
a581 12
// Implement sized_target inline for efficiency.  This approach breaks
// static type checking, but is made safe using asserts.

template<int size, bool big_endian>
inline Sized_target<size, big_endian>*
Object::sized_target() const
{
  gold_assert(this->target_->get_size() == size);
  gold_assert(this->target_->is_big_endian() ? big_endian : !big_endian);
  return static_cast<Sized_target<size, big_endian>*>(this->target_);
}

d1280 1
a1280 1
  setup(Target *target);
a1344 5
  // Return the appropriate Sized_target structure.
  Sized_target<size, big_endian>*
  sized_target()
  { return this->Object::sized_target<size, big_endian>(); }

@


1.78.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@d198 1
a198 2
      is_dynamic_(is_dynamic), uses_split_stack_(false),
      has_no_split_stack_(false), xindex_(NULL), no_export_(false)
a218 11
  // Return whether this object was compiled with -fsplit-stack.
  bool
  uses_split_stack() const
  { return this->uses_split_stack_; }

  // Return whether this object contains any functions compiled with
  // the no_split_stack attribute.
  bool
  has_no_split_stack() const
  { return this->has_no_split_stack_; }

d225 5
d269 7
d456 5
a575 6
  // If NAME is the name of the special section which indicates that
  // this object was compiled with -fstack-split, mark it accordingly,
  // and return true.  Otherwise return false.
  bool
  handle_split_stack_section(const char* name);

d592 2
a593 5
  // Whether this object was compiled with -fsplit-stack.
  bool uses_split_stack_;
  // Whether this object contains any functions compiled with the
  // no_split_stack attribute.
  bool has_no_split_stack_;
d601 12
a1285 24
// This type is used to modify relocations for -fsplit-stack.  It is
// indexed by relocation index, and means that the relocation at that
// index should use the symbol from the vector, rather than the one
// indicated by the relocation.

class Reloc_symbol_changes
{
 public:
  Reloc_symbol_changes(size_t count)
    : vec_(count, NULL)
  { }

  void
  set(size_t i, Symbol* sym)
  { this->vec_[i] = sym; }

  const Symbol*
  operator[](size_t i) const
  { return this->vec_[i]; }

 private:
  std::vector<Symbol*> vec_;
};

d1311 1
a1311 2
  setup()
  { this->do_setup(); }
d1376 5
a1453 5
  // Make section offset invalid.  This is needed for relaxation.
  void
  invalidate_section_offset(unsigned int shndx)
  { this->do_invalidate_section_offset(shndx); }

a1454 4
  // Set up.
  virtual void
  do_setup();

a1587 42
  // Set the offset of a section to invalid_address.
  virtual void
  do_invalidate_section_offset(unsigned int shndx)
  {
    gold_assert(shndx < this->section_offsets_.size());
    this->section_offsets_[shndx] = invalid_address;
  }

  // Adjust a section index if necessary.
  unsigned int
  adjust_shndx(unsigned int shndx)
  {
    if (shndx >= elfcpp::SHN_LORESERVE)
      shndx += this->elf_file_.large_shndx_offset();
    return shndx;
  }

  // Initialize input to output maps for section symbols in merged
  // sections.
  void
  initialize_input_to_output_maps();

  // Free the input to output maps for section symbols in merged
  // sections.
  void
  free_input_to_output_maps();

  // Return symbol table section index.
  unsigned int
  symtab_shndx() const
  { return this->symtab_shndx_; }

  // Allow a child class to access the ELF file.
  elfcpp::Elf_file<size, big_endian, Object>*
  elf_file()
  { return &this->elf_file_; }
  
  // Allow a child class to access the local values.
  Local_values*
  local_values()
  { return &this->local_values_; }

d1610 9
d1710 2
a1711 4
  // A type shared by split_stack_adjust_reltype and find_functions.
  typedef std::map<section_offset_type, section_size_type> Function_offsets;

  // Check for -fsplit-stack routines calling non-split-stack routines.
d1713 1
a1713 5
  split_stack_adjust(const Symbol_table*, const unsigned char* pshdrs,
		     unsigned int sh_type, unsigned int shndx,
		     const unsigned char* prelocs, size_t reloc_count,
		     unsigned char* view, section_size_type view_size,
		     Reloc_symbol_changes** reloc_map);
d1715 2
a1716 1
  template<int sh_type>
d1718 1
a1718 10
  split_stack_adjust_reltype(const Symbol_table*, const unsigned char* pshdrs,
			     unsigned int shndx, const unsigned char* prelocs,
			     size_t reloc_count, unsigned char* view,
			     section_size_type view_size,
			     Reloc_symbol_changes** reloc_map);

  // Find all functions in a section.
  void
  find_functions(const unsigned char* pshdrs, unsigned int shndx,
		 Function_offsets*);
a1941 2
  // Section header of relocation section.
  const unsigned char* reloc_shdr;
a1943 2
  // Section header of data section.
  const unsigned char* data_shdr;
@


1.78.2.2
log
@	PR 10880
	* object.h (class Object): Add is_needed and set_is_needed
	methods.  Add is_needed_ field.  Make bool fields into bitfields.
	* symtab.cc (Symbol_table::set_dynsym_indexes): If a symbol is
	defined in a dynamic object and referenced by a regular object,
	set is_needed for the dynamic object.
	* layout.cc (Layout::finish_dynamic_section): Don't add DT_NEEDED
	if the file is marked with as_needed and it is not needed.
@
text
@d198 2
a199 2
      is_dynamic_(is_dynamic), is_needed_(false), uses_split_stack_(false),
      has_no_split_stack_(false), no_export_(false), xindex_(NULL)
a219 13
  // Return whether this object is needed--true if it is a dynamic
  // object which defines some symbol referenced by a regular object.
  // We keep the flag here rather than in Dynobj for convenience when
  // setting it.
  bool
  is_needed() const
  { return this->is_needed_; }

  // Record that this object is needed.
  void
  set_is_needed()
  { this->is_needed_ = true; }

d592 1
a592 5
  bool is_dynamic_ : 1;
  // Whether this object is needed.  This is only set for dynamic
  // objects, and means that the object defined a symbol which was
  // used by a reference from a regular object.
  bool is_needed_ : 1;
d594 1
a594 1
  bool uses_split_stack_ : 1;
d597 3
a599 1
  bool has_no_split_stack_ : 1;
d602 1
a602 3
  bool no_export_ : 1;
  // Many sections for objects with more than SHN_LORESERVE sections.
  Xindex* xindex_;
@


1.77
log
@*** empty log message ***
@
text
@a547 5
  // Set the target.
  void
  set_target(int machine, int size, bool big_endian, int osabi,
	     int abiversion);

d1309 1
a1309 1
  // Set up the object file based on the ELF header.
d1311 1
a1311 1
  setup(const typename elfcpp::Ehdr<size, big_endian>&);
@


1.76
log
@	PR 10400
	* layout.h: #include <map>.
	(class Kept_section): Change from struct to class.  Add accessors
	and setters.  Add section size to Comdat_group mapping.  Change
	Comdat_group to std::map.  Add is_comdat_ field.  Add
	linkonce_size field in union.
	(class Layout): Update declaration of find_or_add_kept_section.
	Don't declare find_kept_object.
	* layout.cc (Layout::find_or_add_kept_section): Remove candidate
	parameter.  Add object, shndx, is_comdat, and is_group_name
	parameters.  Change all callers.  Adjust for new Kept_section.
	(Layout::find_kept_object): Remove.
	* object.cc (Sized_relobj::include_section_group): Update use of
	Kept_section.  Rename secnum to shndx.  Only record
	Kept_comdat_section if sections are the same size.
	(Sized_relobj::include_linkonce_section): Update use of
	Kept_section.  Only record Kept_comdat_section if sections are the
	same size.  Set size of linkonce section.
	(Sized_relobj::map_to_kept_section): Update call to
	get_kept_comdat_section.
	* object.h (class Sized_relobj): Rename fields in
	Kept_comdat_section to drop trailing underscores; change object
	field to Relobj*.  Change Kept_comdat_section_table to store
	struct rather than pointer.
	(Sized_relobj::set_kept_comdat_section): Remove kept parameter.
	Add kept_object and kept_shndx parameters.  Change all callers.
	(Sized_relobj::get_kept_comdat_section): Change return type to
	bool.  Add kept_object and kept_shndx parameters.  Change all
	callers.
	* plugin.cc (Pluginobj::include_comdat_group): Update call to
	Layout::find_or_add_kept_section.
@
text
@d324 5
d516 4
d629 2
a630 1
      relocs_must_follow_section_writes_(false)
d702 2
a703 2
  finalize_local_symbols(unsigned int index, off_t off)
  { return this->do_finalize_local_symbols(index, off); }
d827 1
a827 1
  do_finalize_local_symbols(unsigned int, off_t) = 0;
d1504 1
a1504 1
  do_finalize_local_symbols(unsigned int, off_t);
d1536 5
a1540 2
  do_section_flags(unsigned int shndx)
  { return this->elf_file_.section_flags(shndx); }
@


1.75
log
@2009-06-05  Doug Kwan  <dougkwan@@google.com>

	* object.cc (Sized_relobj::Sized_relobj): Initialize
	discarded_eh_frame_shndx_ to -1U.
	(Sized_relobj::do_layout): Record index of a discard .eh_frame
	section.
	(Sized_relobj::do_count_local_symbols): Skip local symbols in
	a discarded .eh_frame section.
	(Sized_relobj::do_finalize_local_symbols): Ditto.
	* object.h (class Sized_relobj): Declare new member
	discarded_eh_frame_shndx_.
	* testsuite/Makefile.am (check_PROGRAMS): Add local_labels_test.
	(local_labels_test.o, local_labels_test): New rules.
	* testsuite/Makefile.in: Regenerate.
@
text
@d1593 2
a1594 3
    Kept_comdat_section(Sized_relobj<size, big_endian>* object,
                        unsigned int shndx)
      : object_(object), shndx_(shndx)
d1596 2
a1597 2
    Sized_relobj<size, big_endian>* object_;
    unsigned int shndx_;
d1599 1
a1599 1
  typedef std::map<unsigned int, Kept_comdat_section*>
d1731 2
a1732 1
  set_kept_comdat_section(unsigned int shndx, Kept_comdat_section* kept)
d1734 2
a1735 1
    this->kept_comdat_sections_[shndx] = kept;
d1738 5
a1742 3
  // Find the kept section corresponding to the discarded section SHNDX.
  Kept_comdat_section*
  get_kept_comdat_section(unsigned int shndx) const
d1747 4
a1750 2
      return NULL;
    return p->second;
@


1.74
log
@2009-05-19  Doug Kwan  <dougkwan@@google.com>

	* archive.cc (Archive::Archive): Move constructor from archive.h
	to here.  Initialize no_export_.
	(Archive::get_elf_object_for_member): Set no_export flag of object.
	* archive.h (Archive::Archive): Move constructor body to
	archive.cc.
	(Archive::no_export): New method.
	(Archive::no_export_): New field.
	* object.h (Object::Object): Initialize no_export_ to false.
	(Object::no_export, Object::set_no_export): New methods.
	(Object::no_export_): New field.
	* options.cc (General_options::parse_exclude_libs): New method.
	(General_options::check_excluded_libs) Same.
	* options.h (exclude_libs): New option.
	(General_options::check_excluded_libs): New method declaration.
	(General_options::excluded_libs_): New field.
	* symtab.cc (Symbol_table::add_from_relobj): Hide symbols with
	default or protected visibility if an object has no-export flag set.
	testsuite/Makefile.am (check_PROGRAMS): Add exclude_libs_test.
	(check_SCRIPTS): Add exclude_libs_test.sh.
	(check_DATA): Add exclude_libs_test.syms.
	(MOSTLYCLEANFILES): Add exclude_libs_test.syms,
	libexclude_libs_test_1.a and libexclude_libs_test_2.a.
	(exclude_libs_test_SOURCES, exclude_libs_test_DEPENDENCIES,
	exclude_libs_test_LDFLAGS and exclude_libs_test_LDADD): Define.
	(exclude_libs_test.syms, libexclude_libs_test_1.a,
	libexclude_libs_test_2.a): New rules.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/exclude_libs_test.c: New file.
	* testsuite/exclude_libs_test.sh: Ditto.
	* testsuite/exclude_libs_test_1.c: Ditto.
	* testsuite/exclude_libs_test_2.c: Ditto.
@
text
@d1818 3
@


1.73
log
@	* object.cc (is_elf_object): Define.
	* object.h (is_elf_object): Declare.
	* archive.cc (Archive::get_elf_object_for_member): Call
	is_elf_object.
	* readsymc.cc (Read_symbols::do_read_symbols): Likewise.
@
text
@d198 1
a198 1
      is_dynamic_(is_dynamic), target_(NULL), xindex_(NULL)
d466 8
d592 3
@


1.72
log
@	* readsyms.cc (Read_symbols::incompatible_warning): New function.
	(Read_symbols::requeue): New function.
	(Read_symbols::do_read_symbols): If make_elf_object fails because
	the target type is not configured, and the file was searched for,
	issue a warning and retry with the next directory.
	(Add_symbols::run): If the file has an incompatible format, and
	it was searched for, requeue the Read_symbols task.  On error,
	release the object.
	* readsyms.h (class Read_symbols): Add dirindex_ field.  Add
	dirindex parameter to constructor.  Change all callers.  Declare
	incompatible_warning and requeue.
	(class Add_symbols): Add dirpath_, dirindex_, mapfile_,
	input_argument_ and input_group_ fields.  Add them to
	constructor.  Change all callers.
	(class Read_script): Add dirindex_ field.  Add it to constructor.
	Change all callers.
	* archive.cc (Archive::setup): Remove input_objects parameter.
	Change all callers.
	(Archive::get_file_and_offset): Likewise.
	(Archive::read_all_symbols): Likewise.
	(Archive::read_symbols): Likewise.
	(Archive::get_elf_object_for_member): Remove input_objects
	parameter.  Add punconfigured parameter.  Change all callers.
	(Archive::add_symbols): Change return type to bool.  Check return
	value of include_member.
	(Archive::include_all_members): Likewise.
	(Archive::include_member): Change return type to bool.  Return
	false if first included object has incompatible target.  Set
	included_member_ field.
	(Add_archive_symbols::run): If add_symbols returns false, requeue
	Read_symbols task.
	* archive.h (class Archive): Add included_member_ field.
	Initialize it in constructor.  Add input_file and searched_for
	methods.  Update declarations.
	(class Add_archive_symbols): Add dirpath_, dirindex_, and
	input_argument_ fields.  Add them to constructor.  Change all
	callers.
	* script.cc: Include "target-select.h".
	(class Parser_closure): Add skip_on_incompatible_target_ and
	found_incompatible_target_ fields.  Add
	skip_on_incompatible_target parameter to constructor.  Change all
	callers.  Add methods skip_on_incompatible_target,
	clear_skip_on_incompatible_target, found_incompatible_target, and
	set_found_incompatible_target.
	(read_input_script): Add dirindex parameter.  Change all callers.
	If parser finds an incompatible target, requeue Read_symbols
	task.
	(script_set_symbol): Clear skip_on_incompatible_target in
	closure.
	(script_add_assertion, script_parse_option): Likewise.
	(script_start_sections, script_add_phdr): Likewise.
	(script_check_output_format): New function.
	* script.h (read_input_script): Update declaration.
	* script-c.h (script_check_output_format): Declare.
	* yyscript.y (file_cmd): Handle OUTPUT_FORMAT.
	(ignore_cmd): Remove OUTPUT_FORMAT.
	* fileread.cc (Input_file::Input_file): Add explicit this.
	(Input_file::will_search_for): New function.
	(Input_file::open): Add pindex parameter.  Change all callers.
	* fileread.h (class Input_file): Add input_file_argument method.
	Declare will_search_for.  Update declarations.
	* object.cc (make_elf_object): Add punconfigured parameter.
	Change all callers.
	* object.h (class Object): Make input_file public.  Add
	searched_for method.
	(make_elf_object): Update declaration.
	* dirsearch.cc (Dirsearch::find): Add pindex parameter.  Use it to
	restart search.
	* dirsearch.h (class Dirsearch): Update declaration.
	* options.h (class General_options): Add --warn-search-mismatch.
	* parameters.cc (Parameters::is_compatible_target): New function.
	* parameters.h (class Parameters): Declare is_compatible_target.
	* workqueue.cc (Workqueue::add_blocker): New function.
	* workqueue.h (class Workqueue): Declare add_blocker.
@
text
@d1924 8
@


1.71
log
@	* layout.cc (Layout::find_or_add_kept_section): New function.
	(Layout::add_comdat): Removed.
	* layout.h (struct Kept_section): Move out of class Layout.
	Remove trailing underscores from field names.  Add group_sections
	field.  Rename group_ field to is_group.  Change all uses.
	(class Layout): Declare find_or_add_kept_section, not add_comdat.
	* object.cc (Sized_relobj::Sized_relobj): Don't initialize
	comdat_groups_ field.
	(Sized_relobj::include_section_group): Use
	find_or_add_kept_section and Kept_section::group_sections.
	(Sized_relobj::include_linkonce_section): Likewise.
	* object.cc (class Sized_relobj): Don't define Comdat_group or
	Comdat_group_table.  Remove find_comdat_group and
	add_comdat_group.  Remove comdat_groups_ field.
	* plugin.cc (include_comdat_group): Use
	Layout::find_or_add_kept_section.
@
text
@d230 9
d461 5
a530 9
  // Get the file.  We pass on const-ness.
  Input_file*
  input_file()
  { return this->input_file_; }

  const Input_file*
  input_file() const
  { return this->input_file_; }

d1925 4
a1928 1
// and holds the ELF header.
d1933 1
a1933 1
		section_offset_type bytes);
@


1.70
log
@	PR 6811
	* options.h (class Search_directory): Add is_system_directory.
	(class General_options): Declare is_in_system_directory.
	* options.cc (get_relative_sysroot): Make static.
	(get_default_sysroot): Make static.
	(General_optoins::is_in_system_directory): New function.
	* fileread.cc (Input_file::is_in_system_directory): New function.
	* fileread.h (class Input_file): Declare is_in_system_directory.
	* object.h (class Object): Add is_in_system_directory.
	(class Input_objects): Remove system_library_directory_ field.
	* object.cc (Input_objects::add_object): Don't set
	system_library_directory_.
	(input_objects::found_in_system_library_directory): Remove.
	* symtab.cc (Symbol_table::write_globals): Remove input_objects
	parameter.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::warn_about_undefined_dynobj_symbol): Likewise.
	Call Object::is_in_system_directory.
	* symtab.h (class Symbol_table): Update declarations.
@
text
@a1586 26
  // Information needed to keep track of kept comdat groups.  This is
  // simply a map from the section name to its section index.  This may
  // not be a one-to-one mapping, but we ignore that possibility since
  // this is used only to attempt to handle stray relocations from
  // non-comdat debug sections that refer to comdat loadable sections.
  typedef Unordered_map<std::string, unsigned int> Comdat_group;

  // A map from group section index to the table of group members.
  typedef std::map<unsigned int, Comdat_group*> Comdat_group_table;

  // Find a comdat group table given its group section SHNDX.
  Comdat_group*
  find_comdat_group(unsigned int shndx) const
  {
    Comdat_group_table::const_iterator p =
      this->comdat_groups_.find(shndx);
    if (p != this->comdat_groups_.end())
      return p->second;
    return NULL;
  }

  // Record a new comdat group whose group section index is SHNDX.
  void
  add_comdat_group(unsigned int shndx, Comdat_group* group)
  { this->comdat_groups_[shndx] = group; }

a1799 2
  // Table of kept comdat groups.
  Comdat_group_table comdat_groups_;
@


1.69
log
@	(From Rafael Espindola)
	* archive.cc (Archive::include_member): Update calls to add_symbols.
	* dynobj.cc (Sized_dynobj<size, big_endian>::make_version_map): Add
	the Layout argument.
	* dynobj.h (do_add_symbols): Add the Layout argument.
	* object.cc (Sized_relobj<size, big_endian>::do_add_symbols): Add the
	Layout argument.
	* object.h (Object::add_symbols): Add the Layout argument.
	(Object::do_add_symbols): Add the Layout argument.
	(Sized_relobj::do_add_symbols): Add the Layout argument.
	* plugin.cc (Sized_pluginobj<size, big_endian>::do_add_symbols):
	Unify the two versions.
	(Add_plugin_symbols): Remove.
	* plugin.h (Pluginobj::add_symbols, Pluginobj::do_add_symbols): Remove.
	(Sized_pluginobj::do_add_symbols): Unify the two versions.
	(Add_plugin_symbols): Remove.
	* readsyms.cc (Read_symbols::do_read_symbols): Update call to
	Add_symbols. Use Add_symbols instead of Add_plugin_symbols.
	(Add_symbols::run): Make it work with Pulginobj.
@
text
@d447 5
d1840 1
a1840 2
    : relobj_list_(), dynobj_list_(), sonames_(), system_library_directory_(),
      cref_(NULL)
a1917 2
  // The directory in which we find the libc.so.
  std::string system_library_directory_;
@


1.68
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d353 2
a354 2
  add_symbols(Symbol_table* symtab, Read_symbols_data* sd)
  { this->do_add_symbols(symtab, sd); }
d465 1
a465 1
  do_add_symbols(Symbol_table*, Read_symbols_data*) = 0;
d1449 1
a1449 1
  do_add_symbols(Symbol_table*, Read_symbols_data*);
@


1.67
log
@	* object.cc (Sized_relobj::layout_section): New function.
	(Sized_relobj::do_layout): Defer layout of input sections until after
	plugin has provided replacement files.
	(Sized_relobj::do_layout_deferred_sections): New function.
	* object.h (Relobj::set_section_offset): Remove virtual keyword.
	(Relobj::layout_deferred_sections): New function.
	(Relobj::do_layout_deferred_sections): New function.
	(Sized_relobj::do_layout_deferred_sections): New function.
	(Sized_relobj::layout_section): New function.
	(Sized_relobj::Deferred_layout): New structure.
	(Sized_relobj::deferred_layout_): New field.
	* plugin.cc (Plugin_manager::finish): Renamed, was cleanup.
	Change all callers.  Layout deferred sections.
	(class Plugin_finish): Renamed, was Plugin_cleanup.  Change all
	references.
	(Plugin_hook::run): Move code from do_plugin_hook inline.
	(Plugin_hook::do_plugin_hook): Remove.
	* plugin.h (Plugin_manager::Plugin_manager): Add missing initializers.
	(Plugin_manager::finish): Renamed, was cleanup.
	(Plugin_manager::should_defer_layout): New function.
	(Plugin_manager::add_deferred_layout_object): New function.
	(Plugin_manager::Deferred_layout_list): New type.
	(Plugin_manager::deferred_layout_objects_): New field.
	(Plugin_hook::do_plugin_hook): Remove.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d49 1
d602 35
d642 6
d773 5
d860 7
d1277 6
d1455 6
@


1.66
log
@	* mapfile.cc (Mapfile::print_input_section): Change -1U to -1ULL.
	* object.cc (Sized_relobj::do_layout): Use constant invalid_address
	instead of -1U.
	(Sized_relobj::do_finalize_local_symbols): Likewise.
	(Sized_relobj::map_to_kept_section): Likewise.
	* object.h (Sized_relobj::invalid_address): New constant.
	(Sized_relobj::do_output_section_offset): Check for invalid_address
	and return -1ULL.
	* output.cc (Output_reloc::local_section_offset): Use constant
	invalid_address instead of -1U.
	(Output_reloc::get_address): Likewise.
	(Output_section::output_address): Change -1U to -1ULL.
	* output.h (Output_reloc::invalid_address): New constant.
	* reloc.cc (Sized_relobj::write_sections): Use constant
	invalid_address instead of -1U.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (Symbol_table::sized_finalize_symbol): Handle symbol
	values for merge sections.
	* target-reloc.h (relocate_for_relocatable): Use constant
	invalid_address instead of -1U.
@
text
@d674 1
a674 1
  virtual void
d715 6
d773 5
d1382 5
d1577 6
d1706 19
d1759 2
@


1.65
log
@Add plugin functionality for link-time optimization (LTO).

include/:
	* plugin-api.h: New file.

gold/:
	* configure.ac (plugins): Add --enable-plugins option.
	* configure: Regenerate.
	* config.in: Regenerate.
	* Makefile.am (LIBDL): New variable.
	(CCFILES): Add plugin.cc.
	(HFILES): Add plugin.h.
	(ldadd_var): Add LIBDL.
	* Makefile.in: Regenerate.

	* archive.cc: Include "plugin.h".
	(Archive::setup): Don't preread archive symbols when using a plugin.
	(Archive::get_file_and_offset): Add memsize parameter.  Change callers.
	(Archive::get_elf_object_for_member): Call plugin hooks for claiming
	files.
	(Archive::include_member): Add symbols from plugin objects.
	* archive.h (Archive::get_file_and_offset): Add memsize parameter.
	* descriptors.cc (Descriptors::open): Check for file descriptors
	abandoned by plugins.
	(Descriptors::claim_for_plugin): New function.
	* descriptors.h (Descriptors::claim_for_plugin): New function.
	(Open_descriptor::is_claimed): New field.
	(claim_descriptor_for_plugin): New function.
	* fileread.cc (File_read::claim_for_plugin): New function.
	* fileread.h (File_read::claim_for_plugin): New function.
	(File_read::descriptor): New function.
	* gold.cc: Include "plugin.h".
	(queue_initial_tasks): Add task to call plugin hooks for generating
	new object files.
	* main.cc: Include "plugin.h".
	(main): Load plugin libraries.
	* object.h (Pluginobj): Declare.
	(Object::pluginobj): New function.
	(Object::do_pluginobj): New function.
	(Object::set_target): New function.
	* options.cc: Include "plugin.h".
	(General_options::parse_plugin): New function.
	(General_options::General_options): Initialize plugins_ field.
	(General_options::add_plugin): New function.
	* options.h (Plugin_manager): Declare.
	(General_options): Add --plugin option.
	(General_options::has_plugins): New function.
	(General_options::plugins): New function.
	(General_options::add_plugin): New function.
	(General_options::plugins_): New field.
	* plugin.cc: New file.
	* plugin.h: New file.
	* readsyms.cc: Include "plugin.h".
	(Read_symbols::do_read_symbols): Check for archive before checking
	for ELF file.  Call plugin hooks to claim files.
	* resolve.cc (Symbol_table::resolve): Record when symbol is referenced
	from a real object file; force override when processing replacement
	files.
	* symtab.cc (Symbol::init_fields): Initialize in_real_elf_ field.
	(Symbol::init_base_object): Likewise.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): Likewise.
	(Symbol::output_section): Assert that object is not a plugin.
	(Symbol_table::add_from_pluginobj): New function.
	(Symbol_table::sized_finalize_symbol): Treat symbols from plugins as
	undefined.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::add_from_pluginobj): Instantiate template.
	* symtab.h (Sized_pluginobj): Declare.
	(Symbol::in_real_elf): New function.
	(Symbol::set_in_real_elf): New function.
	(Symbol::in_real_elf_): New field.
	(Symbol_table::add_from_pluginobj): New function.

	* testsuite/Makefile.am (AM_CFLAGS): New variable.
	(LIBDL): New variable.
	(LDADD): Add LIBDL.
	(check_PROGRAMS): Add plugin_test_1 and plugin_test_2.
	(check_SCRIPTS): Add plugin_test_1.sh and plugin_test_2.sh.
	(check_DATA): Add plugin_test_1.err and plugin_test_2.err.
	(MOSTLYCLEANFILES): Likewise.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_test.c: New file.
	* testsuite/plugin_test_1.sh: New file.
	* testsuite/plugin_test_2.sh: New file.
@
text
@d1205 2
d1462 6
a1467 1
  { return this->get_output_section_offset(shndx); }
d1709 1
a1709 1
  // output section.  This is -1U if the input section requires a
@


1.64
log
@	PR 5990
	* descriptors.cc: New file.
	* descriptors.h: New file.
	* gold-threads.h (class Hold_optional_lock): New class.
	* fileread.cc: Include "descriptors.h".
	(File_read::~File_read): Release descriptor rather than closing
	it.
	(File_read::open) [file]: Call open_descriptor rather than open.
	Set is_descriptor_opened_.
	(File_read::open) [memory]: Assert that descriptor is not open.
	(File_read::reopen_descriptor): New function.
	(File_read::release): Release descriptor.
	(File_read::do_read): Make non-const.  Reopen descriptor.
	(File_read::read): Make non-const.
	(File_read::make_view): Reopen descriptor.
	(File_read::do_readv): Likewise.
	* fileread.h (class File_read): Add is_descriptor_opened_ field.
	Update declarations.
	* layout.cc: Include "descriptors.h".
	(Layout::create_build_id): Use open_descriptor rather than open.
	* output.cc: Include "descriptors.h".
	(Output_file::open): Use open_descriptor rather than open.
	* archive.cc (Archive::const_iterator): Change Archive to be
	non-const.
	(Archive::begin, Archive::end): Make non-const.
	(Archive::count_members): Likewise.
	* archive.h (class Archive): Update declarations.
	* object.h (Object::read): Make non-const.
	* Makefile.am (CCFILES): Add descriptors.cc.
	(HFILES): Add descriptors.h.
	* Makefile.in: Rebuild.
@
text
@d45 1
d218 6
d441 5
d447 6
@


1.63
log
@	PR 6658
	* object.h (Merged_symbol_value::value): Do our best to handle a
	negative addend.
@
text
@d413 1
a413 1
  read(off_t start, section_size_type size, void* p) const
@


1.62
log
@	* cref.cc: New file.
	* cref.h: New file.
	* options.h (class General_options): Add --print-symbol-counts.
	* main.cc (main): Issue defined symbol report if requested.
	* archive.cc (Archive::interpret_header): Make into a const member
	function.
	(Archive::add_symbols): Call Input_objects::archive_start and
	archive_stop.
	(Archive::const_iterator): Define new class.
	(Archive::begin, Archive::end): New functions.
	(Archive::include_all_members): Rewrite to use iterator.
	(Archive::count_members): New function.
	* archive.h (class Archive): Update declarations.
	(Archive::filename): New function.
	* object.cc: Include "cref.h".
	(Sized_relobj::Sized_relobj): Initialize defined_count_.
	(Sized_relobj::do_get_global_symbol_counts): New function.
	(Input_objects::add_object): Add object to cross-referencer.
	(Input_objects::archive_start): New function.
	(Input_objects::archive_stop): New function.
	(Input_objects::print_symbol_counts): New function.
	* object.h: Declare Cref and Archive.
	(Object::get_global_symbol_counts): New function.
	(Object::do_get_global_symbol_counts): New pure virtual function.
	(class Sized_relobj): Add defined_count_ field.  Update
	declarations.
	(class Input_objects): Add cref_ field.  Update constructor.
	Update declarations.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize symbols_ and
	defined_count_.
	(Sized_dynobj::do_add_symbols): Allocate symbols_ if printing
	symbol counts.
	(Sized_dynobj::do_get_global_symbol_counts): New function.
	* dynobj.h (class Sized_dynobj): Add fields symbols_ and
	defined_count_.  Update declarations.  Define Symbols typedef.
	* symtab.cc (Symbol_table::add_from_relobj): Add defined
	parameter.  Change all callers.
	(Symbol_table::add_from_dynobj): Add sympointers and defined
	parameters.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* Makefile.am (CCFILES): Add cref.cc.
	(HFILES): Add cref.h.
	* Makefile.in: Rebuild.
@
text
@d825 23
a847 1
    Value input_offset = this->input_value_ + addend;
d851 1
a851 1
      return p->second;
d853 2
a854 1
    return this->value_from_output_section(object, input_shndx, input_offset);
@


1.61
log
@	Handle output sections with more than 0x7fffffff bytes.
	* object.h (class Relobj): Change map_to_output_ to
	output_sections_, and just keep a section pointer.  Change all
	uses.  Move comdat group support to Sized_relobj.
	(Relobj::is_section_specially_mapped): Remove.
	(Relobj::output_section): Remove poff parameter.  Change all
	callers.
	(Relobj::output_section_offset): New function.
	(Relobj::set_section_offset): Rewrite.
	(Relobj::map_to_output): Remove.
	(Relobj::output_sections): New function.
	(Relobj::do_output_section_offset): New pure virtual function.
	(Relobj::do_set_section_offset): Likewise.
	(class Sized_relobj): Add section_offsets_ field.  Add comdat
	group support from Relobj.  Update declarations.
	(Sized_relobj::get_output_section_offset): New function.
	(Sized_relobj::do_output_section_offset): New function.
	(Sized_relobj::do_set_section_offset): New function.
	* object.cc (Relobj::output_section_address): Remove.
	(Sized_relobj::Sized_relobj): Initialize new fields.
	(Sized_relobj::include_section_group): Cast find_kept_object to
	Sized_relobj.
	(Sized_relobj::include_linkonce_section): Likewise.
	(Sized_relobj::do_layout): Use separate arrays for output section
	and output offset.
	(Sized_relobj::do_count_local_symbols): Change map_to_output to
	output_sections.
	(Sized_relobj::do_finalize_local_symbols): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_local_symbols): Likewise.
	(map_to_kept_section): Compute output address directly.
	* reloc.cc (Sized_relobj::do_read_relocs): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_sections): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (sized_finalize_symbol): Use output_section_offset.
	* output.h (class Output_reloc): Update declarations.  Change
	u2_.relobj to Sized_relobj*.
	(class Output_data_reloc): Change add functions to use
	Sized_relobj*.
	* output.cc (Output_reloc::Output_reloc): Change relobj to
	Sized_relobj*.
	(Output_reloc::local_section_offset): Change return type to
	Elf_Addr.  Use get_output_section_offset.
	(Output_reloc::get_address): Likewise.
	(Output_section::is_input_address_mapped): Don't call
	is_section_specially_mapped.
	(Output_section::output_offset): Likewise.
	(Output_section::output_address): Likewise.
	(Output_section::starting_output_address): Likewise.
	* copy-relocs.cc (Copy_relocs::copy_reloc): Change object
	parameter to Sized_relobj*.
	(Copy_relocs::need_copy_reloc): Likewise.
	(Copy_relocs::save): Likewise.
	* copy-relocs.h (class Copy_relocs): Update declarations.
	(class Copy_relocs::Copy_reloc_entry): Change constructor to use
	Sized_relobj*.  Change relobj_ field to Sized_relobj*.
	* target-reloc.h (relocate_for_relocatable): Change
	offset_in_output_section type to Elf_Addr.  Change code that uses
	it as well.
	* layout.cc (Layout::layout): Always set *off.
	* mapfile.cc (Mapfile::print_input_section): Use
	output_section_offset.
	* i386.cc (Target_i386::copy_reloc): Change object parameter to
	Sized_relobj*.
	* powerpc.cc (Target_powerpc::copy_reloc): Likewise.
	* sparc.cc (Target_sparc::copy_reloc): Likewise.
	* x86_64.cc (Target_x86_64::copy_reloc): Likewise.
@
text
@d39 2
d426 8
d489 4
d1412 4
d1649 2
d1678 2
a1679 1
    : relobj_list_(), dynobj_list_(), sonames_(), system_library_directory_()
d1695 8
d1713 4
d1759 2
@


1.60
log
@	* mapfile.cc: New file.
	* mapfile.h: New file.
	* options.h (class General_options): Add -M/--print-map and -Map.
	* options.cc (General_options::finalize): Make -M equivalent to
	-Map -.
	* main.cc: Include <cstdio> and "mapfile.h".
	(main): Open mapfile if requested.
	* gold.cc (class Middle_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(queue_initial_tasks): Add mapfile parameter.  Change caller.
	(queue_middle_tasks): Likewise.
	* gold.h (queue_initial_tasks, queue_middle_tasks): Update
	declarations.
	* archive.cc: Include "mapfile.h".
	(Archive::add_symbols): Add mapfile parameter.  Change all
	callers.  Pass mapfile, symbol, and reason to include_member.
	(Archive::include_all_members): Add mapfile parameter.  Change all
	callers.
	(Archive::include_member): Add mapfile, sym, and why parameters.
	Change all callers.  Report inclusion to map file.
	* archive.h: Include "fileread.h".
	(class Archive): Update declarations.
	(Archive::file): New const method.
	(class Add_archive_symbols): Add mapfile_ field.  Update
	constructor.  Change all callers.
	* readsyms.h (class Read_symbols): Likewise.
	(class Finish_group): Likewise.
	(class Read_script): Likewise.
	* common.cc: Include "mapfile.h".
	(Symbol_table::allocate_commons): Add mapfile parameter.  Change
	all callers.
	(Symbol_table::do_allocate_commons): Likewise.
	(Symbol_table::do_allocate_commons_list): Likewise.  Report common
	symbol allocation to mapfile.
	* common.h (class Allocate_commons_task): Add mapfile_ field.
	Update constructor.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* layout.cc: Include "mapfile.h".
	(Layout_task_runner::run): Print information to mapfile.
	(Layout::create_gold_note): Change Output_data_fixed_space to
	Output_data_zero_fill.
	(Layout::create_build_id): Likewise.
	(Layout::print_to_mapfile): New function.
	* layout.h (class Layout_task_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(class Layout): Declare print_to_mapfile.
	* output.cc (Output_section::Input_section::print_to_mapfile): New
	function.
	(Output_section::add_input_section): If producing a map, always
	add to input_sections_ list.
	(Output_section::do_print_to_mapfile): New function.
	(Output_segment::print_sections_to_mapfile): New function.
	(Output_segment::print_section_list_to_mapfile): New function.
	* output.h: Include "mapfile.h".
	(Output_data::print_to_mapfile): New function.
	(Output_data::do_print_to_mapfile): New virtual function.
	(Output_segment_headers::do_print_to_mapfile): New function.
	(Output_file_header::do_print_to_mapfile): New function.
	(Output_data_const::do_print_to_mapfile): New function.
	(class Output_data_const_buffer): Add map_name_ field.  Update
	constructor.  Change all callers.  Add do_print_to_mapfile
	function.
	(class Output_data_fixed_space): Likewise.
	(class Output_data_space): Likewise.
	(class Output_data_zero_fill): New class.
	(Output_data_strtab::do_print_to_mapfile): New function.
	(Output_data_reloc_base::do_print_to_mapfile): New function.
	(Output_relocatable_relocs::do_print_to_mapfile): New function.
	(Output_data_group::do_print_to_mapfile): New function.
	(Output_data_got::do_print_to_mapfile): New function.
	(Output_data_dynamic::do_print_to_mapfile): New function.
	(Output_symtab_xindex::do_print_to_mapfile): New function.
	(class Output_section): Declare do_print_to_mapflie.  Declare
	print_to_mapfile in Input_section.
	(class Output_segment): Declare new functions.
	* object.h (Sized_relobj::symbol_count): New function.
	* script-sections.cc
	(Output_section_element_dot_assignment::set_section_addresses):
	Change Output_data_fixed_space to Output_data_zero_fill.
	(Output_data_expression::do_print_to_mapfile): New function.
	* script.cc (read_input_script): Add mapfile parameter.  Change
	all callers.
	* script.h (read_input_script): Update declaration.
	* ehframe.h (Eh_frame_hdr::do_print_to_mapfile): New function.
	(Eh_frame::do_print_to_mapfile): New function.
	* merge.h (Output_merge_data::do_print_to_mapfile): New function.
	(Output_merge_string::do_print_to_mapfile): New function.
	* i386.cc (Output_data_plt_i386::do_print_to_mapfile): New
	function.
	* sparc.cc (Output_data_plt_sparc::do_print_to_mapfile): New
	function.
	* x86_64.cc (Output_data_plt_x86_64::do_print_to_mapfile): New
	function.
	* Makefile.am (CCFILES): Add mapfile.cc.
	(HFILES): Add mapfile.h.
	* Makefile.in: Rebuild.
@
text
@d563 1
a563 3
      map_to_output_(),
      comdat_groups_(),
      kept_comdat_sections_(),
d620 2
a621 2
    gold_assert(shndx < this->map_to_output_.size());
    return this->map_to_output_[shndx].output_section != NULL;
d624 5
a628 5
  // Return whether an input section requires special
  // handling--whether it is not simply mapped from the input file to
  // the output file.
  bool
  is_section_specially_mapped(unsigned int shndx) const
d630 2
a631 3
    gold_assert(shndx < this->map_to_output_.size());
    return (this->map_to_output_[shndx].output_section != NULL
	    && this->map_to_output_[shndx].offset == -1);
d634 6
a639 6
  // Given a section index, return the corresponding Output_section
  // (which will be NULL if the section is not included in the link)
  // and set *POFF to the offset within that section.  *POFF will be
  // set to -1 if the section requires special handling.
  inline Output_section*
  output_section(unsigned int shndx, section_offset_type* poff) const;
d642 3
a644 10
  void
  set_section_offset(unsigned int shndx, section_offset_type off)
  {
    gold_assert(shndx < this->map_to_output_.size());
    this->map_to_output_[shndx].offset = off;
  }

  // Return the output address of the input section SHNDX.
  uint64_t
  output_section_address(unsigned int shndx) const;
a682 18
  // Information needed to keep track of kept comdat groups.  This is
  // simply a map from the section name to its section index.  This may
  // not be a one-to-one mapping, but we ignore that possibility since
  // this is used only to attempt to handle stray relocations from
  // non-comdat debug sections that refer to comdat loadable sections.
  typedef Unordered_map<std::string, unsigned int> Comdat_group;

  // Find a comdat group table given its group section SHNDX.
  Comdat_group*
  find_comdat_group(unsigned int shndx) const
  {
    Comdat_group_table::const_iterator p =
      this->comdat_groups_.find(shndx);
    if (p != this->comdat_groups_.end())
      return p->second;
    return NULL;
  }

d684 4
a687 29
  // What we need to know to map an input section to an output
  // section.  We keep an array of these, one for each input section,
  // indexed by the input section number.
  struct Map_to_output
  {
    // The output section.  This is NULL if the input section is to be
    // discarded.
    Output_section* output_section;
    // The offset within the output section.  This is -1 if the
    // section requires special handling.
    section_offset_type offset;
  };

  // A map from group section index to the table of group members.
  typedef std::map<unsigned int, Comdat_group*> Comdat_group_table;

  // To keep track of discarded comdat sections, we need to map a member
  // section index to the object and section index of the corresponding
  // kept section.
  struct Kept_comdat_section
  {
    Kept_comdat_section(Relobj* object, unsigned int shndx)
      : object_(object), shndx_(shndx)
    { }
    Relobj* object_;
    unsigned int shndx_;
  };
  typedef std::map<unsigned int, Kept_comdat_section*>
      Kept_comdat_section_table;
d727 3
a729 8
  // Return the vector mapping input sections to output sections.
  std::vector<Map_to_output>&
  map_to_output()
  { return this->map_to_output_; }

  const std::vector<Map_to_output>&
  map_to_output() const
  { return this->map_to_output_; }
d731 3
a733 4
  // Record a new comdat group whose group section index is SHNDX.
  void
  add_comdat_group(unsigned int shndx, Comdat_group* group)
  { this->comdat_groups_[shndx] = group; }
d735 8
a742 18
  // Record a mapping from discarded section SHNDX to the corresponding
  // kept section.
  void
  set_kept_comdat_section(unsigned int shndx, Kept_comdat_section* kept)
  {
    this->kept_comdat_sections_[shndx] = kept;
  }

  // Find the kept section corresponding to the discarded section SHNDX.
  Kept_comdat_section*
  get_kept_comdat_section(unsigned int shndx) const
  {
    Kept_comdat_section_table::const_iterator p =
      this->kept_comdat_sections_.find(shndx);
    if (p == this->kept_comdat_sections_.end())
      return NULL;
    return p->second;
  }
d760 1
a760 5
  std::vector<Map_to_output> map_to_output_;
  // Table of kept comdat groups.
  Comdat_group_table comdat_groups_;
  // Table mapping discarded comdat sections to corresponding kept sections.
  Kept_comdat_section_table kept_comdat_sections_;
a771 10
// Implement Object::output_section inline for efficiency.
inline Output_section*
Relobj::output_section(unsigned int shndx, section_offset_type* poff) const
{
  gold_assert(shndx < this->map_to_output_.size());
  const Map_to_output& mo(this->map_to_output_[shndx]);
  *poff = mo.offset;
  return mo.output_section;
}

d1276 11
d1398 13
d1419 41
d1537 1
a1537 1
	      size_t reloc_count, Output_section*, off_t output_offset,
d1548 1
a1548 1
		      Output_section*, off_t output_offset,
d1580 19
d1640 8
@


1.59
log
@	* layout.cc (Layout::include_section): Refactored check for debug
	info section.
	(Layout::add_comdat): Add new parameters.  Change type
	of signature parameter.  Add object and shndx to signatures table.
	(Layout::find_kept_object): New function.
	* layout.h: Include <cstring>.
	(Layout::is_debug_info_section): New function.
	(Layout::add_comdat): Add new parameters.
	(Layout::find_kept_object): New function.
	(Layout::Kept_section): New struct.
	(Layout::Signatures): Change type of map range.
	* object.cc (Relobj::output_section_address): New function.
	(Sized_relobj::include_section_group): Add new parameters.  Change
	calls to Layout::add_comdat.  Change to build table of kept comdat
	groups and table mapping discarded sections to kept sections.
	(Sized_relobj::include_linkonce_section): Likewise.  Add new parameter.
	(Sized_relobj::do_layout): Change calls to include_section_group and
	include_linkonce_section.
	(Sized_relobj::do_finalize_local_symbols): Do not set local symbol
	value to zero when section is discarded.
	(Sized_relobj::map_to_kept_section): New function.
	* object.h (Relobj::output_section_address): New function.
	(Relobj::Comdat_group): New type.
	(Relobj::find_comdat_group): New function.
	(Relobj::Comdat_group_table): New type.
	(Relobj::Kept_comdat_section): New type.
	(Relobj::Kept_comdat_section_table): New type.
	(Relobj::add_comdat_group): New function.
	(Relobj::set_kept_comdat_section): New function.
	(Relobj::get_kept_comdat_section): New function.
	(Relobj::comdat_groups_): New field.
	(Relobj::kept_comdat_sections_): New field.
	(Symbol_value::input_value): Update comment.
	(Sized_relobj::map_to_kept_section) New function.
	(Sized_relobj::include_linkonce_section): Add new parameter.
	* target-reloc.h (Comdat_behavior): New type.
	(get_comdat_behavior): New function.
	(relocate_section): Add code to map a discarded section to the
	corresponding kept section when applying a relocation.
@
text
@d1242 6
@


1.58
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d564 2
d652 4
d693 18
d725 17
d789 24
d830 4
d999 1
a999 1
  // finalize_local_symbols.
d1360 6
d1499 1
a1499 1
			const elfcpp::Shdr<size, big_endian>&,
d1504 1
a1504 1
  include_linkonce_section(Layout*, const char*,
@


1.57
log
@	* fileread.cc (File_read::find_view): Add byteshift and vshifted
	parameters.  Update for new key type to views_.  Change all
	callers.
	(File_read::read): Adjust for byteshift in returned view.
	(File_read::add_view): New function, broken out of
	find_and_make_view.
	(File_read::make_view): New function, broken out of
	find_and_make_view.
	(File_read::find_or_make_view): Add offset and aligned
	parameters.  Rewrite accordingly.  Change all callers.
	(File_read::get_view): Add offset and aligned parameters.  Adjust
	for byteshift in return value.
	(File_read::get_lasting_view): Likewise.
	* fileread.h (class File_read): Update declarations.
	(class File_read::View): Add byteshift_ field.  Add byteshift to
	constructor.  Add byteshift method.
	* archive.h (Archive::clear_uncached_views): New function.
	(Archive::get_view): Add aligned parameter.  Change all callers.
	* object.h (Object::get_view): Add aligned parameter.  Change all
	callers.
	(Object::get_lasting_view): Likewise.

	* fileread.cc (File_read::release): Don't call clear_views if
	there are multiple objects.
	* fileread.h (File_read::clear_uncached_views): New function.
	* archive.cc (Add_archive_symbols::run): Call clear_uncached_views
	on the archive.
@
text
@d42 1
d131 49
d194 1
a194 1
      is_dynamic_(is_dynamic), target_(NULL)
d267 23
d475 4
d506 8
d539 2
d864 2
a865 2
      is_section_symbol_(false), is_tls_symbol_(false),
      has_output_value_(true)
d877 5
a881 2
      return this->u_.merged_symbol_value->value(object, this->input_shndx_,
						 addend);
d907 1
a907 1
	gold_assert(this->is_section_symbol_);
d1001 1
a1001 1
  set_input_shndx(unsigned int i)
d1007 1
d1012 5
a1016 2
  input_shndx() const
  { return this->input_shndx_; }
d1050 4
a1053 1
  unsigned int input_shndx_ : 29;
d1187 5
a1191 4
  // in the object file.  Note that for a symbol which is not defined
  // in this object file, this will set *VALUE to 0 and return
  // SHN_UNDEF; it will not return the final value of the symbol in
  // the link.
d1193 1
a1193 1
  symbol_section_and_value(unsigned int sym, Address* value);
d1224 1
a1224 1
  local_symbol_input_shndx(unsigned int sym) const
d1227 1
a1227 1
    return this->local_values_[sym].input_shndx();
d1385 4
d1397 9
d1505 3
a1507 1
		      const Stringpool_template<char>*);
@


1.56
log
@	* i386.cc (Target_i386::Got_type): New enum declaration.
	(Target_i386::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocate::relocate_tls): Likewise.
	* object.h (Got_offset_list): New class.
	(Sized_relobj::local_has_got_offset): Added got_type parameter.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::local_has_tls_got_offset): Removed.
	(Sized_relobj::local_tls_got_offset): Removed.
	(Sized_relobj::set_local_tls_got_offset): Removed.
	(Sized_relobj::Local_got_offsets): Changed to store a list of offsets.
	* output.cc (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* output.h (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* resolve.cc (Symbol::override_base_with_special): Removed
	reference to has_got_offset_ field.
	* symtab.cc (Symbol::init_fields): Replaced initialization
	of got_offset_ with got_offsets_.  Removed initialization
	of has_got_offset_
	*symtab.h (Symbol::has_got_offset): Aded got_type parameter.
	(Symbol::got_offset): Likewise.
	(Symbol::set_got_offset): Likewise.
	(Symbol::has_tls_got_offset): Removed.
	(Symbol::tls_got_offset): Removed.
	(Symbol::set_tls_got_offset): Removed.
	(Symbol::got_offset_): Removed.
	(Symbol::tls_mod_got_offset_): Removed.
	(Symbol::tls_pair_got_offset_): Removed.
	(Symbol::got_offsets_): New field.
	(Symbol::has_got_offset): Removed.
	(Symbol::has_tls_mod_got_offset): Removed.
	(Symbol::has_tls_pair_got_offset): Removed.
	* x86_64.cc (Target_x86_64::Got_type): New enum declaration.
	(Target_x86_64::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocate::relocate_tls): Likewise.
@
text
@d298 1
a298 1
  { return View(this->get_view(file_offset, data_size, true)); }
d317 1
a317 1
  { return View(this->get_view(loc.file_offset, loc.data_size, true)); }
d321 1
a321 1
  get_view(off_t start, section_size_type size, bool cache)
d323 2
a324 2
    return this->input_file()->file().get_view(start + this->offset_, size,
					       cache);
d329 2
a330 1
  get_lasting_view(off_t start, section_size_type size, bool cache)
d332 2
a333 2
    return this->input_file()->file().get_lasting_view(start + this->offset_,
						       size, cache);
@


1.55
log
@Fix handling of RELA relative relocs against local symbols in merge
sections.
@
text
@d979 77
d1147 1
a1147 1
  local_has_got_offset(unsigned int symndx) const
d1149 4
a1152 2
    return (this->local_got_offsets_.find(symndx)
            != this->local_got_offsets_.end());
d1157 1
a1157 1
  local_got_offset(unsigned int symndx) const
d1162 3
a1164 1
    return p->second;
d1169 2
a1170 1
  set_local_got_offset(unsigned int symndx, unsigned int got_offset)
d1172 4
a1175 53
    std::pair<Local_got_offsets::iterator, bool> ins =
        this->local_got_offsets_.insert(std::make_pair(symndx, got_offset));
    gold_assert(ins.second);
  }

  // Return whether the local TLS symbol SYMNDX has a GOT offset.
  // The GOT entry at this offset will contain a module index. If
  // NEED_PAIR is true, a second entry immediately following the first
  // will contain the dtv-relative offset.
  bool
  local_has_tls_got_offset(unsigned int symndx, bool need_pair) const
  {
    typename Local_tls_got_offsets::const_iterator p =
        this->local_tls_got_offsets_.find(symndx);
    if (p == this->local_tls_got_offsets_.end()
        || (need_pair && !p->second.have_pair_))
      return false;
    return true;
  }

  // Return the offset of the GOT entry for the local TLS symbol SYMNDX.
  // If NEED_PAIR is true, we need the offset of a pair of GOT entries;
  // otherwise we need the offset of the GOT entry for the module index.
  unsigned int
  local_tls_got_offset(unsigned int symndx, bool need_pair) const
  {
    typename Local_tls_got_offsets::const_iterator p =
        this->local_tls_got_offsets_.find(symndx);
    gold_assert(p != this->local_tls_got_offsets_.end());
    gold_assert(!need_pair || p->second.have_pair_);
    return p->second.got_offset_;
  }

  // Set the offset of the GOT entry for the local TLS symbol SYMNDX
  // to GOT_OFFSET. If HAVE_PAIR is true, we have a pair of GOT entries;
  // otherwise, we have just a single entry for the module index.
  void
  set_local_tls_got_offset(unsigned int symndx, unsigned int got_offset,
                           bool have_pair)
  {
    typename Local_tls_got_offsets::iterator p =
        this->local_tls_got_offsets_.find(symndx);
    if (p != this->local_tls_got_offsets_.end())
      {
        // An entry already existed for this symbol. This can happen
        // if we see a relocation asking for the module index before
        // a relocation asking for the pair. In that case, the original
        // GOT entry will remain, but won't get used by any further
        // relocations.
        p->second.got_offset_ = got_offset;
	gold_assert(have_pair);
        p->second.have_pair_ = true;
      }
d1178 3
a1180 3
        std::pair<typename Local_tls_got_offsets::iterator, bool> ins =
            this->local_tls_got_offsets_.insert(
              std::make_pair(symndx, Tls_got_entry(got_offset, have_pair)));
a1400 1
    this->local_tls_got_offsets_.clear();
d1405 1
a1405 1
  typedef Unordered_map<unsigned int, unsigned int> Local_got_offsets;
a1443 3
  // GOT offsets for local TLS symbols, indexed by symbol number
  // and GOT entry type.
  Local_tls_got_offsets local_tls_got_offsets_;
@


1.54
log
@Update copyright years.  Update language files.
@
text
@d1059 1
a1059 4
  // Return the value of the local symbol symndx.
  Address
  local_symbol_value(unsigned int symndx) const;

@


1.53
log
@Remove gcc 3.2 compatibility hacks.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.52
log
@Implement -q/--emit-relocs.
@
text
@d205 1
a205 1
  sized_target(ACCEPT_SIZE_ENDIAN_ONLY) const;
d460 1
a460 1
Object::sized_target(ACCEPT_SIZE_ENDIAN_ONLY) const
d1057 1
a1057 5
  {
    return this->Object::sized_target
      SELECT_SIZE_ENDIAN_NAME(size, big_endian) (
          SELECT_SIZE_ENDIAN_ONLY(size, big_endian));
  }
@


1.51
log
@Support dynamic relocations against local section symbols.
@
text
@d114 2
d1316 36
@


1.50
log
@Implement --just-symbols, including -R FILE.  Fix symbol values when
doing a relocatable link.
@
text
@d877 1
d901 2
a902 1
    gold_assert(this->output_dynsym_index_ != 0);
d929 4
a932 1
  { this->is_section_symbol_ = true; }
@


1.49
log
@Support creating empty output when there are no input objects.
@
text
@d193 5
d230 5
d379 4
d1227 5
@


1.48
log
@Initial -r support.
@
text
@d1370 1
a1370 2
    : relobj_list_(), dynobj_list_(), target_(NULL), sonames_(),
      system_library_directory_()
a1385 5
  // Get the target we should use for the output file.
  Target*
  target() const
  { return this->target_; }

a1433 2
  // The target.
  Target* target_;
@


1.47
log
@Fully implement the SECTIONS clause.
@
text
@d44 1
d460 1
d567 16
d613 1
a613 1
			    Stringpool_template<char>*) = 0;
d615 3
a617 2
  // Finalize the local symbols.  Set the output symbol table indexes for the local variables, and set the
  // offset where local symbol information will be stored.
d644 8
d661 3
d1025 8
d1259 1
a1259 1
  include_section_group(Layout*, unsigned int,
@


1.46
log
@Reduce the number of system calls.  Use readv instead of pread.  Do
better handling of cached views.
@
text
@d209 6
a214 2
  // Return the name of a section given a section index.  This is only
  // used for error messages.
d239 5
d356 4
d380 4
d1156 5
d1190 5
@


1.45
log
@Speed up relocations against local symbols in merged sections.
@
text
@d142 1
a142 1
  { }
d145 1
a145 1
  { }
d297 31
a375 21
  // Get a view into the underlying file.
  const unsigned char*
  get_view(off_t start, section_size_type size, bool cache)
  {
    return this->input_file()->file().get_view(start + this->offset_, size,
					       cache);
  }

  // Get a lasting view into the underlying file.
  File_view*
  get_lasting_view(off_t start, section_size_type size, bool cache)
  {
    return this->input_file()->file().get_lasting_view(start + this->offset_,
						       size, cache);
  }

  // Read data from the underlying file.
  void
  read(off_t start, section_size_type size, void* p) const
  { this->input_file()->file().read(start + this->offset_, size, p); }

d1219 1
a1219 1
  write_sections(const unsigned char* pshdrs, Output_file*, Views*) const;
d1241 9
@


1.44
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d625 65
d704 2
a705 2
      needs_output_address_(false), value_(0)
  { }
d713 5
a717 4
    if (!this->needs_output_address_)
      return this->value_ + addend;
    return object->local_value(this->input_shndx_, this->value_,
			       this->is_section_symbol_, addend);
d723 17
d741 6
a746 2
    this->value_ = value;
    this->needs_output_address_ = false;
d749 2
a750 6
  // Set the value of the symbol from the input file.  This value
  // will usually be replaced during finalization with the output
  // value, but if the symbol is mapped to an output section which
  // requires special handling to determine the output value, we
  // leave the input value in place until later.  This is used for
  // SHF_MERGE sections.
d752 1
a752 1
  set_input_value(Value value)
d754 2
a755 2
    this->value_ = value;
    this->needs_output_address_ = true;
d758 9
a766 1
  // Return the input value.
d769 1
a769 4
  {
    gold_assert(this->needs_output_address_);
    return this->value_;
  }
d848 5
d882 17
a898 8
  // Whether getting the value of this symbol requires calling an
  // Output_section method.  For example, this will be true of a
  // symbol in a SHF_MERGE section.
  bool needs_output_address_ : 1;
  // The value of the symbol.  If !needs_output_address_, this is the
  // value in the output file.  If needs_output_address_, this is the
  // value in the input file.
  Value value_;
a980 8
  // Return the value of a local symbol defined in input section
  // SHNDX, with value VALUE, adding addend ADDEND.  IS_SECTION_SYMBOL
  // indicates whether the symbol is a section symbol.  This handles
  // SHF_MERGE sections.
  Address
  local_value(unsigned int shndx, Address value, bool is_section_symbol,
	      Address addend) const;

d1215 10
@


1.43
log
@Rewrite workqueue.  This version eliminates the master thread, and
reduces the amount of locking required to find a new thread to run.
@
text
@d57 1
a57 1
  off_t section_names_size;
d61 1
a61 1
  off_t symbols_size;
d65 1
a65 1
  off_t external_symbols_offset;
d69 1
a69 1
  off_t symbol_names_size;
d74 1
a74 1
  off_t versym_size;
d77 1
a77 1
  off_t verdef_size;
d81 1
a81 1
  off_t verneed_size;
d207 1
a207 1
  section_contents(unsigned int shndx, off_t* plen, bool cache);
d275 1
a275 1
  view(off_t file_offset, off_t data_size)
d288 1
a288 1
    Location(off_t fo, off_t ds)
d347 1
a347 1
  get_view(off_t start, off_t size, bool cache)
d355 1
a355 1
  get_lasting_view(off_t start, off_t size, bool cache)
d363 1
a363 1
  read(off_t start, off_t size, void* p) const
d507 1
a507 1
  output_section(unsigned int shndx, off_t* poff) const;
d511 1
a511 1
  set_section_offset(unsigned int shndx, off_t off)
d549 1
a549 1
    off_t offset;
d617 1
a617 1
Relobj::output_section(unsigned int shndx, off_t* poff) const
d1086 1
a1086 1
		off_t names_size) const;
d1105 1
a1105 1
    off_t view_size;
d1291 1
a1291 1
		off_t bytes);
@


1.42
log
@Add const to Object::read and Object::sized_target.
@
text
@d38 1
d169 2
a170 2
  lock()
  { this->input_file()->file().lock(); }
d174 2
a175 2
  unlock()
  { this->input_file()->file().unlock(); }
d182 10
d336 1
a336 1
  // Get the file.
d522 1
a522 1
  relocs_must_follow_section_writes()
d1115 1
a1115 1
  write_sections(const unsigned char* pshdrs, Output_file*, Views*);
@


1.41
log
@From Craig Silverstein: size hash tables to avoid resizing.
@
text
@d169 1
a169 1
  { this->input_file_->file().lock(); }
d174 1
a174 1
  { this->input_file_->file().unlock(); }
d179 1
a179 1
  { return this->input_file_->file().is_locked(); }
d186 1
a186 1
  sized_target(ACCEPT_SIZE_ENDIAN_ONLY);
d327 4
d338 2
a339 2
    return this->input_file_->file().get_view(start + this->offset_, size,
					      cache);
d346 2
a347 2
    return this->input_file_->file().get_lasting_view(start + this->offset_,
						      size, cache);
d352 2
a353 2
  read(off_t start, off_t size, void* p)
  { this->input_file_->file().read(start + this->offset_, size, p); }
d405 1
a405 1
Object::sized_target(ACCEPT_SIZE_ENDIAN_ONLY)
@


1.40
log
@From Cary Coutant: Remove commented out assert.  Also add comment for
bitfield check.
@
text
@d432 5
d546 4
a802 5
  // Return the number of local symbols.
  unsigned int
  local_symbol_count() const
  { return this->local_symbol_count_; }

d971 1
d975 5
@


1.39
log
@From Cary Coutant: More support for generating shared libraries.
@
text
@d663 1
a663 4
  {
    // gold_assert(this->output_symtab_index_ != 0);
    return this->output_symtab_index_ != -1U;
  }
d726 2
@


1.38
log
@Compress all debug sections.
@
text
@d432 24
a455 7
  // Initial local symbol processing: set the offset where local
  // symbol information will be stored; add local symbol names to
  // *POOL; return the new local symbol index.
  unsigned int
  finalize_local_symbols(unsigned int index, off_t off,
			 Stringpool_template<char>* pool)
  { return this->do_finalize_local_symbols(index, off, pool); }
d541 11
a551 1
  // Finalize local symbols--implemented by child class.
d553 5
a557 2
  do_finalize_local_symbols(unsigned int, off_t,
			    Stringpool_template<char>*) = 0;
d613 2
a614 1
    : output_symtab_index_(0), input_shndx_(0), is_section_symbol_(false),
d638 5
a642 3
  // If this symbol is mapped to an output section which requires
  // special handling to determine the output value, we store the
  // value of the symbol in the input file.  This is used for
d651 8
d664 1
a664 1
    gold_assert(this->output_symtab_index_ != 0);
d693 31
d732 5
d742 10
d756 3
d761 1
a761 1
  unsigned int input_shndx_ : 30;
d764 2
d839 9
d869 7
d989 5
d996 9
a1004 2
  do_finalize_local_symbols(unsigned int, off_t,
			    Stringpool_template<char>*);
d1101 1
d1131 3
d1138 2
@


1.37
log
@Rework merge_map for speed.
@
text
@d963 1
@


1.36
log
@From Cary Coutant: Improve i386 shared library TLS support.
@
text
@d42 1
d415 4
a418 1
    : Object(name, input_file, false, offset)
d488 13
d553 3
@


1.35
log
@Add heuristics for undefined symbol warnings.
@
text
@d749 1
d776 57
d962 2
a963 1
  // The GOT offsets of local symbols.
d966 15
d995 2
a996 1
  // GOT offsets for local symbols, indexed by symbol number.
d998 3
@


1.34
log
@Warn about undefined references in shared libraries if we have seen
all the DT_NEEDED entries for that library.
@
text
@d933 2
a934 1
    : relobj_list_(), dynobj_list_(), target_(NULL), sonames_()
d960 5
d1007 2
@


1.33
log
@From Craig Silverstein: Use relocations in reporting error message
locations.
@
text
@d954 5
@


1.32
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d218 5
d320 4
d837 5
@


1.31
log
@Reworked from Andrew Chatham: report error locations.
@
text
@d60 4
d107 4
d208 5
d307 4
d441 11
d454 2
a455 1
  // and set *POFF to the offset within that section.
d467 8
d518 6
d527 3
d544 2
a545 2
// In order to process relocs we need to be able to handle SHF_MERGE
// sections correctly.
d626 4
a629 1
  { this->input_shndx_ = i; }
d662 1
d674 35
d819 5
d841 11
d870 1
d902 1
a902 1
  Symbol** symbols_;
d909 2
a997 6
  // Number of local symbols.
  unsigned int local_symbol_count;
  // Values of local symbols.
  const typename Sized_relobj<size, big_endian>::Local_values* local_values;
  // Global symbols.
  const Symbol* const * symbols;
@


1.30
log
@Add infrastructure for threading support.
@
text
@d79 9
d200 5
d294 4
d681 7
d733 5
@


1.29
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d831 5
@


1.28
log
@From Craig Silverstein: don't get confused if the same file name
occurs in an archive.
@
text
@d236 1
a236 1
  error(const char* format, ...) ATTRIBUTE_PRINTF_2;
@


1.27
log
@Add support for local GOT offsets.
@
text
@d133 5
a283 5

  // Get the offset into the file.
  off_t
  offset() const
  { return this->offset_; }
@


1.26
log
@Correct handling of addends in merged sections.
@
text
@d615 48
a708 17
  // Return the appropriate Sized_target structure.
  Sized_target<size, big_endian>*
  sized_target()
  {
    return this->Object::sized_target
      SELECT_SIZE_ENDIAN_NAME(size, big_endian) (
          SELECT_SIZE_ENDIAN_ONLY(size, big_endian));
  }

  // Return the value of a local symbol define in input section SHNDX,
  // with value VALUE, adding addend ADDEND.  IS_SECTION_SYMBOL
  // indicates whether the symbol is a section symbol.  This handles
  // SHF_MERGE sections.
  Address
  local_value(unsigned int shndx, Address value, bool is_section_symbol,
	      Address addend) const;

d758 3
d775 2
@


1.25
log
@Add cache parameter to get_view.  Discard uncached views on unlock.
Fix bug this exposed in archive armap symbol name handling.
@
text
@d490 2
a491 2
    : output_symtab_index_(0), input_shndx_(0), needs_output_address_(false),
      value_(0)
d502 2
a503 1
    return object->local_value(this->input_shndx_, this->value_, addend);
d564 5
d575 3
a577 1
  unsigned int input_shndx_ : 31;
d580 1
a580 1
  // STT_SECTION symbol in a SHF_MERGE section.
d671 3
a673 2
  // with value VALUE, adding addend ADDEND.  This handles SHF_MERGE
  // sections.
d675 2
a676 1
  local_value(unsigned int shndx, Address value, Address addend) const;
@


1.24
log
@Add licensing text to every source file.
@
text
@d171 1
a171 1
  // size.
d173 1
a173 1
  section_contents(unsigned int shndx, off_t* plen);
d227 1
a227 1
  { return View(this->get_view(file_offset, data_size)); }
d246 1
a246 1
  { return View(this->get_view(loc.file_offset, loc.data_size)); }
d287 5
a291 2
  get_view(off_t start, off_t size)
  { return this->input_file_->file().get_view(start + this->offset_, size); }
d295 1
a295 1
  get_lasting_view(off_t start, off_t size)
d298 1
a298 1
						      size);
@


1.23
log
@Add global parameters.
@
text
@d3 20
@


1.22
log
@Add support for SHF_MERGE sections.
@
text
@d174 2
a175 3
  layout(const General_options& options, Symbol_table* symtab,
	 Layout* layout, Read_symbols_data* sd)
  { this->do_layout(options, symtab, layout, sd); }
d235 1
a235 2
  do_layout(const General_options&, Symbol_table*, Layout*,
	    Read_symbols_data*) = 0;
d590 1
a590 2
  do_layout(const General_options&, Symbol_table*, Layout*,
	    Read_symbols_data*);
@


1.21
log
@Don't emit symbols seen only in dynamic object, don't read duplicate
dynamic object.
@
text
@a17 1
class Stringpool;
d23 3
d343 1
a343 1
// The implementations is the template class Sized_relobj.
d367 2
a368 1
  finalize_local_symbols(unsigned int index, off_t off, Stringpool* pool)
d389 1
a389 1
  output_section(unsigned int shndx, off_t* poff);
d408 2
a409 1
    // The offset within the output section.
d424 2
a425 1
  do_finalize_local_symbols(unsigned int, off_t, Stringpool*) = 0;
d438 4
d449 1
a449 1
Relobj::output_section(unsigned int shndx, off_t* poff)
d457 102
d566 1
a566 1
  typedef std::vector<Address> Local_values;
d582 2
a583 3
    gold_assert(sym < this->local_indexes_.size());
    gold_assert(this->local_indexes_[sym] != 0);
    return this->local_indexes_[sym];
d610 2
a611 1
  do_finalize_local_symbols(unsigned int, off_t, Stringpool*);
d642 6
d694 2
a695 1
  write_local_symbols(Output_file*, const Stringpool*);
a710 2
  // Indexes of local symbols in the output file; -1U if not present.
  std::vector<unsigned int> local_indexes_;
@


1.20
log
@Added a testsuite.  More support for COPY relocations.
@
text
@d603 1
a603 1
    : relobj_list_(), target_(NULL)
d614 3
a616 2
  // Add an object to the list.
  void
d653 1
d655 1
d657 1
d659 2
@


1.19
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d143 21
a180 16
  // Return a view of the contents of a section.  Set *PLEN to the
  // size.
  const unsigned char*
  section_contents(unsigned int shndx, off_t* plen);

  // Return the name of a section given a section index.  This is only
  // used for error messages.
  std::string
  section_name(unsigned int shndx)
  { return this->do_section_name(shndx); }

  // Return the section flags given a section index.
  uint64_t
  section_flags(unsigned int shndx)
  { return this->do_section_flags(shndx); }

a287 5
  // Get the number of sections.
  unsigned int
  shnum() const
  { return this->shnum_; }

d376 1
a376 1
  is_section_included(unsigned int shnum) const
d378 2
a379 2
    gold_assert(shnum < this->map_to_output_.size());
    return this->map_to_output_[shnum].output_section != NULL;
d386 1
a386 1
  output_section(unsigned int shnum, off_t* poff);
d440 1
a440 1
Relobj::output_section(unsigned int shnum, off_t* poff)
d442 2
a443 2
  gold_assert(shnum < this->map_to_output_.size());
  const Map_to_output& mo(this->map_to_output_[shnum]);
@


1.18
log
@Snapshot.  Includes first cut at output relocation sections.
@
text
@a5 1
#include <cassert>
d168 7
a174 2
  section_name(unsigned int shnum)
  { return this->do_section_name(shnum); }
d240 1
a240 1
  do_section_contents(unsigned int shnum) = 0;
d244 5
a248 1
  do_section_name(unsigned int shnum) = 0;
d335 2
a336 2
  assert(this->target_->get_size() == size);
  assert(this->target_->is_big_endian() ? big_endian : !big_endian);
d378 1
a378 1
    assert(shnum < this->map_to_output_.size());
d392 1
a392 1
    assert(shndx < this->map_to_output_.size());
d442 1
a442 1
  assert(shnum < this->map_to_output_.size());
d471 2
a472 2
    assert(sym < this->local_indexes_.size());
    assert(this->local_indexes_[sym] != 0);
d516 5
@


1.17
log
@More dynamic object support, initial scripting support.
@
text
@d355 4
a358 4
  // *POOL; return the offset following the local symbols.
  off_t
  finalize_local_symbols(off_t off, Stringpool* pool)
  { return this->do_finalize_local_symbols(off, pool); }
d411 2
a412 2
  virtual off_t
  do_finalize_local_symbols(off_t, Stringpool*) = 0;
d446 3
d458 10
d491 2
a492 2
  off_t
  do_finalize_local_symbols(off_t, Stringpool*);
d579 3
a581 1
  typename elfcpp::Elf_types<size>::Elf_Addr *values_;
d661 1
a661 1
  typename elfcpp::Elf_types<size>::Elf_Addr *values;
d663 1
a663 1
  Symbol** symbols;
@


1.16
log
@Add Elf_file interface which can be used by both Sized_relobj and
Sized_dynobj.
@
text
@d43 13
d100 1
a100 1
    : name_(name), input_file_(input_file), offset_(offset),
d272 27
a298 2
  set_target(Target* target)
  { this->target_ = target; }
d312 2
a419 10
  // Get the number of sections.
  unsigned int
  shnum() const
  { return this->shnum_; }

  // Set the number of sections.
  void
  set_shnum(int shnum)
  { this->shnum_ = shnum; }

a425 2
  // Number of input sections.
  unsigned int shnum_;
d459 5
a476 5
  // Lay out the input sections.
  void
  do_layout(const General_options&, Symbol_table*, Layout*,
	    Read_symbols_data*);

d492 1
a492 1
  Location
d513 4
a554 2
  // If non-NULL, a view of the section header data.
  File_view* section_headers_;
@


1.15
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@d11 1
d151 1
a151 2
  section_contents(unsigned int shnum, off_t* plen)
  { return this->do_section_contents(shnum, plen); }
d159 46
d220 4
a223 4
  // Return a view of the contents of a section.  Set *PLEN to the
  // size.  Implemented by child class.
  virtual const unsigned char*
  do_section_contents(unsigned int shnum, off_t* plen) = 0;
d460 2
a461 1
  do_section_name(unsigned int shnum);
d463 4
a466 4
  // Return a view of the contents of a section.  Set *PLEN to the
  // size.
  const unsigned char*
  do_section_contents(unsigned int shnum, off_t* plen);
a484 4
  // Read the section header for section SHNUM.
  const unsigned char*
  section_header(unsigned int shnum);

d521 2
a524 6
  // ELF file header e_flags field.
  unsigned int flags_;
  // File offset of section header table.
  off_t shoff_;
  // Offset of SHT_STRTAB section holding section names.
  unsigned int shstrndx_;
d526 1
a526 1
  unsigned int symtab_shnum_;
@


1.14
log
@gcc 3.2.2 portability hacks.
@
text
@a6 1
#include <list>
a12 1
#include "symtab.h"
d22 1
d73 3
a75 4
// Object is an interface which represents either a 32-bit or a 64-bit
// input object.  This can be a regular object file (ET_REL) or a
// shared object (ET_DYN).  The actual instantiations are
// Sized_object<32> and Sized_object<64>
d87 1
a87 2
      shnum_(0), is_dynamic_(is_dynamic), target_(NULL),
      map_to_output_()
d138 3
a140 2
  layout(Layout* lay, Read_symbols_data* sd)
  { this->do_layout(lay, sd); }
d147 109
a301 6
  // Return the name of a section given a section index.  This is only
  // used for error messages.
  std::string
  section_name(unsigned int shnum)
  { return this->do_section_name(shnum); }

a314 9
  // Read the symbols--implemented by child class.
  virtual void
  do_read_symbols(Read_symbols_data*) = 0;

  // Add symbol information to the global symbol table--implemented by
  // child class.
  virtual void
  do_add_symbols(Symbol_table*, Read_symbols_data*) = 0;

a323 4
  // Lay out sections--implemented by child class.
  virtual void
  do_layout(Layout*, Read_symbols_data*) = 0;

a333 19
  // Get the name of a section--implemented by child class.
  virtual std::string
  do_section_name(unsigned int shnum) = 0;

  // Get the file.
  Input_file*
  input_file() const
  { return this->input_file_; }

  // Get the offset into the file.
  off_t
  offset() const
  { return this->offset_; }

  // Get a view into the underlying file.
  const unsigned char*
  get_view(off_t start, off_t size)
  { return this->input_file_->file().get_view(start + this->offset_, size); }

a343 18
  // Set the target.
  void
  set_target(Target* target)
  { this->target_ = target; }

  // Read data from the underlying file.
  void
  read(off_t start, off_t size, void* p)
  { this->input_file_->file().read(start + this->offset_, size, p); }

  // Get a lasting view into the underlying file.
  File_view*
  get_lasting_view(off_t start, off_t size)
  {
    return this->input_file_->file().get_lasting_view(start + this->offset_,
						      size);
  }

a349 11
  // This class may not be copied.
  Object(const Object&);
  Object& operator=(const Object&);

  // Name of object as printed to user.
  std::string name_;
  // For reading the file.
  Input_file* input_file_;
  // Offset within the file--0 for an object file, non-0 for an
  // archive.
  off_t offset_;
a351 4
  // Whether this is a dynamic object.
  bool is_dynamic_;
  // Target functions--may be NULL if the target is not known.
  Target* target_;
a355 12
// Implement sized_target inline for efficiency.  This approach breaks
// static type checking, but is made safe using asserts.

template<int size, bool big_endian>
inline Sized_target<size, big_endian>*
Object::sized_target(ACCEPT_SIZE_ENDIAN_ONLY)
{
  assert(this->target_->get_size() == size);
  assert(this->target_->is_big_endian() ? big_endian : !big_endian);
  return static_cast<Sized_target<size, big_endian>*>(this->target_);
}

d358 1
a358 1
Object::output_section(unsigned int shnum, off_t* poff)
d369 1
a369 1
class Sized_object : public Object
d372 1
a372 1
  Sized_object(const std::string& name, Input_file* input_file, off_t offset,
d375 1
a375 1
  ~Sized_object();
d400 2
a401 1
  do_layout(Layout*, Read_symbols_data*);
d416 5
a430 4
  // This object may not be copied.
  Sized_object(const Sized_object&);
  Sized_object& operator=(const Sized_object&);

d432 1
a432 1
  typedef Sized_object<size, big_endian> This;
d506 1
a506 1
    : object_list_(), target_(NULL), any_dynamic_(false)
d509 7
a515 2
  // The type of the list of input objects.
  typedef std::list<Object*> Object_list;
d526 19
a544 8
  // Iterate over all objects.
  Object_list::const_iterator
  begin() const
  { return this->object_list_.begin(); }

  Object_list::const_iterator
  end() const
  { return this->object_list_.end(); }
d549 1
a549 1
  { return this->any_dynamic_; }
d555 2
a556 1
  Object_list object_list_;
a557 1
  bool any_dynamic_;
d573 1
a573 1
  Sized_object<size, big_endian>* object;
@


1.13
log
@Can now do a full static link of hello, world in C or C++
@
text
@d395 3
a397 2
    return this->Object::sized_target SELECT_SIZE_ENDIAN_NAME (
      SELECT_SIZE_ENDIAN_ONLY(size, big_endian));
@


1.12
log
@Framework for relocation scanning.  Implement simple static TLS
relocations.
@
text
@d157 2
a158 2
	      Read_relocs_data* rd)
  { return this->do_scan_relocs(options, symtab, rd); }
d187 8
d229 2
a230 1
  do_scan_relocs(const General_options&, Symbol_table*, Read_relocs_data*) = 0;
d262 2
a263 1
  get_view(off_t start, off_t size);
d282 2
a283 1
  read(off_t start, off_t size, void* p);
d287 5
a291 1
  get_lasting_view(off_t start, off_t size);
d371 2
a372 1
  do_scan_relocs(const General_options&, Symbol_table*, Read_relocs_data*);
@


1.11
log
@Avoid multiple definition errors from linkonce sections.
@
text
@d7 2
d19 1
d45 29
d133 1
a133 1
  // Read the symbol and relocation information.
d138 6
d149 6
a154 2
  // Pass sections which should be included in the link to the Layout
  // object, and record where the sections go in the output file.
d156 3
a158 2
  layout(Layout* lay, Read_symbols_data* sd)
  { this->do_layout(lay, sd); }
d170 2
a171 2
	   const Stringpool* sympool, Output_file* of)
  { return this->do_relocate(options, symtab, sympool, of); }
d187 6
d215 8
d235 5
a239 1
	      const Stringpool*, Output_file* of) = 0;
d346 12
a361 4
  // Add the symbols to the symbol table.
  void
  do_add_symbols(Symbol_table*, Read_symbols_data*);

d369 5
a373 1
	      const Stringpool*, Output_file* of);
d428 2
a429 1
  relocate_sections(const Symbol_table*, const unsigned char* pshdrs, Views*);
d499 31
@


1.10
log
@Lay out object file sections when we add the symbols to the symbol
table.
@
text
@d130 15
a156 10
  // Given a section index, return the corresponding Map_to_output
  // information.
  const Map_to_output*
  section_output_info(unsigned int shnum) const
  {
    assert(shnum < this->map_to_output_.size());
    return &this->map_to_output_[shnum];
  }

 protected:
d254 10
@


1.9
log
@Clean up HAVE_MEMBER_TEMPLATE_SPECIFICATIONS somewhat.
@
text
@d26 6
d102 3
a104 3
  Read_symbols_data
  read_symbols()
  { return this->do_read_symbols(); }
d108 2
a109 2
  add_symbols(Symbol_table* symtab, Read_symbols_data rd)
  { this->do_add_symbols(symtab, rd); }
d114 2
a115 2
  layout(Layout* lay)
  { this->do_layout(lay); }
d153 2
a154 2
  virtual Read_symbols_data
  do_read_symbols() = 0;
d159 1
a159 1
  do_add_symbols(Symbol_table*, Read_symbols_data) = 0;
d163 1
a163 1
  do_layout(Layout*) = 0;
d267 2
a268 2
  Read_symbols_data
  do_read_symbols();
d270 1
a270 1
  // Add the symbols to the symbol table.
d272 1
a272 1
  do_add_symbols(Symbol_table*, Read_symbols_data);
d274 1
a274 1
  // Lay out the input sections.
d276 1
a276 1
  do_layout(Layout*);
d346 2
@


1.8
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@a87 1
#ifdef HAVE_MEMBER_TEMPLATE_SPECIFICATIONS
d93 1
a93 2
  sized_target();
#endif
a232 2
#ifdef HAVE_MEMBER_TEMPLATE_SPECIFICATIONS

d238 1
a238 1
Object::sized_target()
a244 2
#endif

d285 2
a286 5
#ifdef HAVE_MEMBER_TEMPLATE_SPECIFICATIONS
    return this->Object::sized_target<size, big_endian>();
#else
    return static_cast<Sized_target<size, big_endian>*>(this->target());
#endif
@


1.7
log
@Finished layout code.
@
text
@d18 1
d20 1
a20 1
class Layout;
d120 6
d142 4
a145 1
  { return &this->map_to_output_[shnum]; }
d165 6
d218 1
a218 1
  // Name of object as printed to use.
d282 5
d325 24
d357 4
d365 2
d416 4
a419 3
extern Object* make_elf_object(const std::string& name, Input_file*,
			       off_t offset, const unsigned char* p,
			       off_t bytes);
@


1.6
log
@g++ 3.2.2 portability fixes.
@
text
@d17 1
a28 2
  // Index of first global symbol.
  unsigned int first_global;
d112 7
a118 1
 protected:
d131 7
d151 4
d171 1
a171 1
  shnum(void) const
d262 4
d287 5
d314 2
d324 1
a324 1
    : object_list_(), any_dynamic_(false)
d334 5
d358 1
@


1.5
log
@g++ 3.2.2 portability for grhat.
@
text
@a94 2
#else
  virtual Target* sized_target() = 0;
d249 7
a255 1
  { return this->Object::sized_target<size, big_endian>(); }
d297 1
a297 1
    : object_list_()
@


1.4
log
@More section layout code.
@
text
@d88 1
d95 3
d205 2
d218 2
@


1.3
log
@New drop, with first cut of section layout code.
@
text
@d28 2
d279 1
a279 1
// The type of the list of input objects.
d281 35
a315 1
typedef std::list<Object*> Object_list;
@


1.2
log
@Another snapshot of the current state of the sources.  Gets to the
point of symbol resolution and can now issue a multiple definition
error.  Also added target selection infrastructure.
@
text
@d7 1
d17 3
d49 2
a50 1
      is_dynamic_(is_dynamic), target_(NULL)
d66 27
d103 5
a107 4
  // Return the target structure associated with this object.
  Target*
  target()
  { return this->target_; }
d109 12
a120 6
  // Return the sized target structure associated with this object.
  // This is like the target method but it returns a pointer of
  // appropriate checked type.
  template<int size, bool big_endian>
  Sized_target<size, big_endian>*
  sized_target();
a121 1
 protected:
d131 4
d149 10
d172 5
d189 2
d195 2
d222 1
d226 1
d230 1
d234 5
d248 17
a264 6
  // ELF file header EI_OSABI field.
  unsigned char osabi_;
  // ELF file header EI_ABIVERSION field.
  unsigned char abiversion_;
  // ELF file header e_machine field.
  elfcpp::Elf_Half machine_;
a268 2
  // Number of input sections.
  unsigned int shnum_;
d276 4
@


1.1
log
@Initial CVS checkin of gold
@
text
@d6 2
d9 1
a9 1
#include "targetsize.h"
d11 1
a11 1
#include "fileread.h"
d31 3
a33 2
// object file.  The actual instantiations are Sized_object<32> and
// Sized_object<64>
d42 4
a45 2
  Object(const std::string& name, Input_file* input_file, off_t offset = 0)
    : name_(name), input_file_(input_file), offset_(offset)
d51 1
d56 5
d68 14
a81 2
  add_symbols(Read_symbols_data rd)
  { this->do_add_symbols(rd); }
d91 1
a91 1
  do_add_symbols(Read_symbols_data) = 0;
d107 5
d132 4
d138 13
a150 1
// The functions of Object which are size specific.
d168 5
a172 1
  do_add_symbols(Read_symbols_data);
a186 2
  // Target functions--may be NULL.
  Target* target_;
d195 2
@

