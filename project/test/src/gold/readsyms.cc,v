head	1.53;
access;
symbols
	binutils-2_24-branch:1.53.0.4
	binutils-2_24-branchpoint:1.53
	binutils-2_21_1:1.45.2.1
	binutils-2_23_2:1.53
	binutils-2_23_1:1.53
	binutils-2_23:1.53
	binutils-2_23-branch:1.53.0.2
	binutils-2_23-branchpoint:1.53
	binutils-2_22_branch:1.51.0.4
	binutils-2_22:1.51
	binutils-2_22-branch:1.51.0.2
	binutils-2_22-branchpoint:1.51
	binutils-2_21:1.45
	binutils-2_21-branch:1.45.0.2
	binutils-2_21-branchpoint:1.45
	binutils-2_20_1:1.37.4.1
	binutils-2_20:1.37.4.1
	binutils-arc-20081103-branch:1.31.0.4
	binutils-arc-20081103-branchpoint:1.31
	binutils-2_20-branch:1.37.0.4
	binutils-2_20-branchpoint:1.37
	dje-cgen-play1-branch:1.37.0.2
	dje-cgen-play1-branchpoint:1.37
	arc-20081103-branch:1.31.0.2
	arc-20081103-branchpoint:1.31
	binutils-2_19_1:1.30
	binutils-2_19:1.30
	binutils-2_19-branch:1.30.0.2
	binutils-2_19-branchpoint:1.30
	binutils_latest_snapshot:1.53
	added-to-binutils:1.26;
locks; strict;
comment	@// @;


1.53
date	2012.02.29.21.22.29;	author ccoutant;	state Exp;
branches;
next	1.52;

1.52
date	2011.10.17.23.43.18;	author ccoutant;	state Exp;
branches;
next	1.51;

1.51
date	2011.07.14.00.55.18;	author tmsriram;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2011.07.06.22.07.59;	author ccoutant;	state Exp;
branches;
next	1.49;

1.49
date	2011.04.12.00.44.48;	author ccoutant;	state Exp;
branches;
next	1.48;

1.48
date	2011.03.30.21.07.13;	author ccoutant;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.24.21.48.40;	author ian;	state Exp;
branches;
next	1.46;

1.46
date	2010.12.14.19.03.30;	author rwild;	state Exp;
branches;
next	1.45;

1.45
date	2010.08.20.00.35.12;	author ccoutant;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2010.08.12.22.01.11;	author ccoutant;	state Exp;
branches;
next	1.43;

1.43
date	2010.03.22.14.18.24;	author espindola;	state Exp;
branches;
next	1.42;

1.42
date	2010.03.15.14.46.16;	author espindola;	state Exp;
branches;
next	1.41;

1.41
date	2010.03.10.17.37.11;	author ccoutant;	state Exp;
branches;
next	1.40;

1.40
date	2010.02.12.03.23.26;	author ian;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.10.07.39.04;	author cgd;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.30.22.21.13;	author ian;	state Exp;
branches;
next	1.37;

1.37
date	2009.05.15.17.01.04;	author ian;	state Exp;
branches
	1.37.4.1;
next	1.36;

1.36
date	2009.03.24.18.42.10;	author ian;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.14.05.56.46;	author ian;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.13.21.30.06;	author ian;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.13.19.04.45;	author ccoutant;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.15.01.29.25;	author ccoutant;	state Exp;
branches;
next	1.31;

1.31
date	2008.09.19.22.54.57;	author ccoutant;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.07.17.02.11;	author ccoutant;	state Exp;
branches;
next	1.29;

1.29
date	2008.05.21.21.37.44;	author ian;	state Exp;
branches;
next	1.28;

1.28
date	2008.04.23.17.29.04;	author ian;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.01.20.57.36;	author ccoutant;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2008.02.28.19.46.06;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2008.01.26.01.35.10;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.12.14.19.00.21;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.22.00.05.51;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.22.18.02.36;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.14.06.49.14;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.02.21.24.41;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.25.06.43.17;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.25.05.16.35;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.25.00.27.29;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.21.07.20.01;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.06.06.28.56;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.30.23.52.50;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.03.18.26.10;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.20.20.40.49;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.06.20.40.16;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.29.19.58.17;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.26.21.00.34;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.21.22.13.18;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.18.22.29.20;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.04.23.10.59;	author iant;	state Exp;
branches;
next	;

1.51.2.1
date	2011.12.19.21.14.39;	author ian;	state Exp;
branches;
next	;

1.45.2.1
date	2011.01.24.21.54.56;	author ian;	state Exp;
branches;
next	;

1.37.4.1
date	2009.10.16.05.51.18;	author ian;	state Exp;
branches;
next	;


desc
@@


1.53
log
@	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Call Object::decompressed_section_contents.
	* dwarf_reader.h (Sized_dwarf_line_info::~Sized_dwarf_line_info):
	New dtor.
	(Sized_dwarf_line_info::buffer_start_): New data member.
	* merge.cc (Output_merge_data::do_add_input_section): Call
	Object::decompressed_section_contents.
	(Output_merge_string::do_add_input_section): Likewise.
	* object.cc (need_decompressed_section): New function.
	(build_compressed_section_map): Decompress sections needed later.
	(Sized_relobj_file::do_decompressed_section_contents): New function.
	(Sized_relobj_file::do_discard_decompressed_sections): New function.
	* object.h (Object::decompressed_section_contents): New function.
	(Object::discard_decompressed_sections): New function.
	(Object::do_decompressed_section_contents): New function.
	(Object::do_discard_decompressed_sections): New function.
	(Compressed_section_info): New type.
	(Compressed_section_map): Include decompressed section contents.
	(Sized_relobj_file::do_decompressed_section_contents): New function.
	(Sized_relobj_file::do_discard_decompressed_sections): New function.
@
text
@// readsyms.cc -- read input file symbols for gold

// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cstring>

#include "elfcpp.h"
#include "options.h"
#include "dirsearch.h"
#include "symtab.h"
#include "object.h"
#include "archive.h"
#include "script.h"
#include "readsyms.h"
#include "plugin.h"
#include "layout.h"
#include "incremental.h"

namespace gold
{

// If we fail to open the object, then we won't create an Add_symbols
// task.  However, we still need to unblock the token, or else the
// link won't proceed to generate more error messages.  We can only
// unblock tokens when the workqueue lock is held, so we need a dummy
// task to do that.  The dummy task has to maintain the right sequence
// of blocks, so we need both this_blocker and next_blocker.

class Unblock_token : public Task
{
 public:
  Unblock_token(Task_token* this_blocker, Task_token* next_blocker)
    : this_blocker_(this_blocker), next_blocker_(next_blocker)
  { }

  ~Unblock_token()
  {
    if (this->this_blocker_ != NULL)
      delete this->this_blocker_;
  }

  Task_token*
  is_runnable()
  {
    if (this->this_blocker_ != NULL && this->this_blocker_->is_blocked())
      return this->this_blocker_;
    return NULL;
  }

  void
  locks(Task_locker* tl)
  { tl->add(this, this->next_blocker_); }

  void
  run(Workqueue*)
  { }

  std::string
  get_name() const
  { return "Unblock_token"; }

 private:
  Task_token* this_blocker_;
  Task_token* next_blocker_;
};

// Class read_symbols.

Read_symbols::~Read_symbols()
{
  // The this_blocker_ and next_blocker_ pointers are passed on to the
  // Add_symbols task.
}

// If appropriate, issue a warning about skipping an incompatible
// file.

void
Read_symbols::incompatible_warning(const Input_argument* input_argument,
				   const Input_file* input_file)
{
  if (parameters->options().warn_search_mismatch())
    gold_warning("skipping incompatible %s while searching for %s",
		 input_file->filename().c_str(),
		 input_argument->file().name());
}

// Requeue a Read_symbols task to search for the next object with the
// same name.

void
Read_symbols::requeue(Workqueue* workqueue, Input_objects* input_objects,
		      Symbol_table* symtab, Layout* layout, Dirsearch* dirpath,
		      int dirindex, Mapfile* mapfile,
		      const Input_argument* input_argument,
		      Input_group* input_group, Task_token* next_blocker)
{
  // Bump the directory search index.
  ++dirindex;

  // We don't need to worry about this_blocker, since we already
  // reached it.  However, we are removing the blocker on next_blocker
  // because the calling task is completing.  So we need to add a new
  // blocker.  Since next_blocker may be shared by several tasks, we
  // need to increment the count with the workqueue lock held.
  workqueue->add_blocker(next_blocker);

  workqueue->queue(new Read_symbols(input_objects, symtab, layout, dirpath,
				    dirindex, mapfile, input_argument,
				    input_group, NULL, NULL, next_blocker));
}

// Return whether a Read_symbols task is runnable.  We can read an
// ordinary input file immediately.  For an archive specified using
// -l, we have to wait until the search path is complete.

Task_token*
Read_symbols::is_runnable()
{
  if (this->input_argument_->is_file()
      && this->input_argument_->file().may_need_search()
      && this->dirpath_->token()->is_blocked())
    return this->dirpath_->token();

  return NULL;
}

// Return a Task_locker for a Read_symbols task.  We don't need any
// locks here.

void
Read_symbols::locks(Task_locker* tl)
{
  if (this->member_ != NULL)
    tl->add(this, this->next_blocker_);
}

// Run a Read_symbols task.

void
Read_symbols::run(Workqueue* workqueue)
{
  // If we didn't queue a new task, then we need to explicitly unblock
  // the token. If the object is a member of a lib group, however,
  // the token was already added to the list of locks for the task,
  // and it will be unblocked automatically at the end of the task.
  if (!this->do_read_symbols(workqueue) && this->member_ == NULL)
    workqueue->queue_soon(new Unblock_token(this->this_blocker_,
					    this->next_blocker_));
}

// Handle a whole lib group. Other than collecting statistics, this just
// mimics what we do for regular object files in the command line.

bool
Read_symbols::do_whole_lib_group(Workqueue* workqueue)
{
  const Input_file_lib* lib_group = this->input_argument_->lib();

  ++Lib_group::total_lib_groups;

  Task_token* this_blocker = this->this_blocker_;
  for (Input_file_lib::const_iterator i = lib_group->begin();
       i != lib_group->end();
       ++i)
    {
      ++Lib_group::total_members;
      ++Lib_group::total_members_loaded;

      const Input_argument* arg = &*i;

      Task_token* next_blocker;
      if (i != lib_group->end() - 1)
        {
          next_blocker = new Task_token(true);
          next_blocker->add_blocker();
        }
      else
        next_blocker = this->next_blocker_;

      workqueue->queue_soon(new Read_symbols(this->input_objects_,
					     this->symtab_, this->layout_,
					     this->dirpath_, this->dirindex_,
					     this->mapfile_, arg, NULL,
					     NULL, this_blocker, next_blocker));
      this_blocker = next_blocker;
    }

  return true;
}

// Handle a lib group. We set Read_symbols Tasks as usual, but have them
// just record the symbol data instead of adding the objects.  We also start
// a Add_lib_group_symbols Task which runs after we've read all the symbols.
// In that task we process the members in a loop until we are done.

bool
Read_symbols::do_lib_group(Workqueue* workqueue)
{
  const Input_file_lib* lib_group = this->input_argument_->lib();

  if (lib_group->options().whole_archive())
    return this->do_whole_lib_group(workqueue);

  Lib_group* lib = new Lib_group(lib_group, this);

  Add_lib_group_symbols* add_lib_group_symbols =
    new Add_lib_group_symbols(this->symtab_, this->layout_,
			      this->input_objects_,
			      lib, this->next_blocker_);


  Task_token* next_blocker = new Task_token(true);
  int j = 0;
  for (Input_file_lib::const_iterator i = lib_group->begin();
       i != lib_group->end();
       ++i, ++j)
    {
      const Input_argument* arg = &*i;
      Archive_member* m = lib->get_member(j);

      next_blocker->add_blocker();

      // Since this Read_symbols will not create an Add_symbols,
      // just pass NULL as this_blocker.
      workqueue->queue_soon(new Read_symbols(this->input_objects_,
					     this->symtab_, this->layout_,
					     this->dirpath_, this->dirindex_,
					     this->mapfile_, arg, NULL,
					     m, NULL, next_blocker));
    }

  add_lib_group_symbols->set_blocker(next_blocker, this->this_blocker_);
  workqueue->queue_soon(add_lib_group_symbols);

  return true;
}

// Open the file and read the symbols.  Return true if a new task was
// queued, false if that could not happen due to some error.

bool
Read_symbols::do_read_symbols(Workqueue* workqueue)
{
  if (this->input_argument_->is_group())
    {
      gold_assert(this->input_group_ == NULL);
      this->do_group(workqueue);
      return true;
    }

  if (this->input_argument_->is_lib())
    return this->do_lib_group(workqueue);

  Input_file* input_file = new Input_file(&this->input_argument_->file());
  if (!input_file->open(*this->dirpath_, this, &this->dirindex_))
    return false;

  // Read enough of the file to pick up the entire ELF header.

  off_t filesize = input_file->file().filesize();

  if (filesize == 0)
    {
      gold_error(_("%s: file is empty"),
		 input_file->file().filename().c_str());
      return false;
    }

  const unsigned char* ehdr;
  int read_size;
  bool is_elf = is_elf_object(input_file, 0, &ehdr, &read_size);

  if (read_size >= Archive::sarmag)
    {
      bool is_thin_archive
          = memcmp(ehdr, Archive::armagt, Archive::sarmag) == 0;
      if (is_thin_archive
          || memcmp(ehdr, Archive::armag, Archive::sarmag) == 0)
	{
	  // This is an archive.
	  Archive* arch = new Archive(this->input_argument_->file().name(),
				      input_file, is_thin_archive,
				      this->dirpath_, this);
	  arch->setup();

	  // Unlock the archive so it can be used in the next task.
	  arch->unlock(this);

	  workqueue->queue_next(new Add_archive_symbols(this->symtab_,
							this->layout_,
							this->input_objects_,
							this->dirpath_,
							this->dirindex_,
							this->mapfile_,
							this->input_argument_,
							arch,
							this->input_group_,
							this->this_blocker_,
							this->next_blocker_));
	  return true;
	}
    }

  Object* elf_obj = NULL;
  bool unconfigured;
  bool* punconfigured = NULL;
  if (is_elf)
    {
      // This is an ELF object.

      unconfigured = false;
      punconfigured = (input_file->will_search_for()
		       ? &unconfigured
		       : NULL);
      elf_obj = make_elf_object(input_file->filename(),
				input_file, 0, ehdr, read_size,
				punconfigured);
    }

  if (parameters->options().has_plugins())
    {
      Pluginobj* obj = parameters->options().plugins()->claim_file(input_file,
                                                                   0, filesize,
								   elf_obj);
      if (obj != NULL)
        {
	  // Delete the elf_obj, this file has been claimed.
	  if (elf_obj != NULL)
	    delete elf_obj;

          // The input file was claimed by a plugin, and its symbols
          // have been provided by the plugin.

          // We are done with the file at this point, so unlock it.
          obj->unlock(this);

          if (this->member_ != NULL)
	    {
	      this->member_->sd_ = NULL;
	      this->member_->obj_ = obj;
	      return true;
	    }

          workqueue->queue_next(new Add_symbols(this->input_objects_,
                                                this->symtab_,
                                                this->layout_,
						this->dirpath_,
						this->dirindex_,
						this->mapfile_,
						this->input_argument_,
                                                obj,
                                                NULL,
						NULL,
                                                this->this_blocker_,
                                                this->next_blocker_));
          return true;
        }
    }

  if (is_elf)
    {
      // This is an ELF object.

      if (elf_obj == NULL)
	{
	  if (unconfigured)
	    {
	      Read_symbols::incompatible_warning(this->input_argument_,
						 input_file);
	      input_file->file().release();
	      input_file->file().unlock(this);
	      delete input_file;
	      ++this->dirindex_;
	      return this->do_read_symbols(workqueue);
	    }
	  return false;
	}

      Read_symbols_data* sd = new Read_symbols_data;
      elf_obj->read_symbols(sd);

      // Opening the file locked it, so now we need to unlock it.  We
      // need to unlock it before queuing the Add_symbols task,
      // because the workqueue doesn't know about our lock on the
      // file.  If we queue the Add_symbols task first, it will be
      // stuck on the end of the file lock, but since the workqueue
      // doesn't know about that lock, it will never release the
      // Add_symbols task.

      input_file->file().unlock(this);

      if (this->member_ != NULL)
        {
          this->member_->sd_ = sd;
          this->member_->obj_ = elf_obj;
          this->member_->arg_serial_ =
              this->input_argument_->file().arg_serial();
          return true;
        }

      // We use queue_next because everything is cached for this
      // task to run right away if possible.

      workqueue->queue_next(new Add_symbols(this->input_objects_,
					    this->symtab_, this->layout_,
					    this->dirpath_,
					    this->dirindex_,
					    this->mapfile_,
					    this->input_argument_,
					    elf_obj,
					    NULL,
					    sd,
					    this->this_blocker_,
					    this->next_blocker_));

      return true;
    }

  // Queue up a task to try to parse this file as a script.  We use a
  // separate task so that the script will be read in order with other
  // objects named on the command line.  Also so that we don't try to
  // read multiple scripts simultaneously, which could lead to
  // unpredictable changes to the General_options structure.

  workqueue->queue_soon(new Read_script(this->symtab_,
					this->layout_,
					this->dirpath_,
					this->dirindex_,
					this->input_objects_,
					this->mapfile_,
					this->input_group_,
					this->input_argument_,
					input_file,
					this->this_blocker_,
					this->next_blocker_));
  return true;
}

// Handle a group.  We need to walk through the arguments over and
// over until we don't see any new undefined symbols.  We do this by
// setting off Read_symbols Tasks as usual, but recording the archive
// entries instead of deleting them.  We also start a Finish_group
// Task which runs after we've read all the symbols.  In that task we
// process the archives in a loop until we are done.

void
Read_symbols::do_group(Workqueue* workqueue)
{
  Input_group* input_group = new Input_group();

  const Input_file_group* group = this->input_argument_->group();
  Task_token* this_blocker = this->this_blocker_;

  Finish_group* finish_group = new Finish_group(this->input_objects_,
						this->symtab_,
						this->layout_,
						this->mapfile_,
						input_group,
						this->next_blocker_);

  Task_token* next_blocker = new Task_token(true);
  next_blocker->add_blocker();
  workqueue->queue_soon(new Start_group(this->symtab_, finish_group,
					this_blocker, next_blocker));
  this_blocker = next_blocker;

  for (Input_file_group::const_iterator p = group->begin();
       p != group->end();
       ++p)
    {
      const Input_argument* arg = &*p;
      gold_assert(arg->is_file());

      next_blocker = new Task_token(true);
      next_blocker->add_blocker();
      workqueue->queue_soon(new Read_symbols(this->input_objects_,
					     this->symtab_, this->layout_,
					     this->dirpath_, this->dirindex_,
					     this->mapfile_, arg, input_group,
					     NULL, this_blocker, next_blocker));
      this_blocker = next_blocker;
    }

  finish_group->set_blocker(this_blocker);

  workqueue->queue_soon(finish_group);
}

// Return a debugging name for a Read_symbols task.

std::string
Read_symbols::get_name() const
{
  if (this->input_argument_->is_group())
    {
      std::string ret("Read_symbols group (");
      bool add_space = false;
      const Input_file_group* group = this->input_argument_->group();
      for (Input_file_group::const_iterator p = group->begin();
           p != group->end();
           ++p)
      {
        if (add_space)
          ret += ' ';
        ret += p->file().name();
        add_space = true;
      }
      return ret + ')';
    }
  else if (this->input_argument_->is_lib())
    {
      std::string ret("Read_symbols lib (");
      bool add_space = false;
      const Input_file_lib* lib = this->input_argument_->lib();
      for (Input_file_lib::const_iterator p = lib->begin();
           p != lib->end();
           ++p)
      {
        if (add_space)
          ret += ' ';
        ret += p->file().name();
        add_space = true;
      }
      return ret + ')';
    }
  else
    {
      std::string ret("Read_symbols ");
      if (this->input_argument_->file().is_lib())
	ret += "-l";
      else if (this->input_argument_->file().is_searched_file())
	ret += "-l:";
      ret += this->input_argument_->file().name();
      return ret;
    }
}

// Class Add_symbols.

Add_symbols::~Add_symbols()
{
  if (this->this_blocker_ != NULL)
    delete this->this_blocker_;
  // next_blocker_ is deleted by the task associated with the next
  // input file.
}

// We are blocked by this_blocker_.  We block next_blocker_.  We also
// lock the file.

Task_token*
Add_symbols::is_runnable()
{
  if (this->this_blocker_ != NULL && this->this_blocker_->is_blocked())
    return this->this_blocker_;
  if (this->object_->is_locked())
    return this->object_->token();
  return NULL;
}

void
Add_symbols::locks(Task_locker* tl)
{
  tl->add(this, this->next_blocker_);
  Task_token* token = this->object_->token();
  if (token != NULL)
    tl->add(this, token);
}

// Add the symbols in the object to the symbol table.

void
Add_symbols::run(Workqueue*)
{
  Pluginobj* pluginobj = this->object_->pluginobj();
  if (pluginobj != NULL)
    {
      this->object_->add_symbols(this->symtab_, this->sd_, this->layout_);
      return;
    }

  if (!this->input_objects_->add_object(this->object_))
    {
      this->object_->discard_decompressed_sections();
      gold_assert(this->sd_ != NULL);
      delete this->sd_;
      this->sd_ = NULL;
      this->object_->release();
      delete this->object_;
    }
  else
    {
      Incremental_inputs* incremental_inputs =
          this->layout_->incremental_inputs();
      if (incremental_inputs != NULL)
	{
          if (this->library_ != NULL && !this->library_->is_reported())
            {
              Incremental_binary* ibase = this->layout_->incremental_base();
              gold_assert(ibase != NULL);
              unsigned int lib_serial = this->library_->arg_serial();
              unsigned int lib_index = this->library_->input_file_index();
	      Script_info* lib_script_info = ibase->get_script_info(lib_index);
	      incremental_inputs->report_archive_begin(this->library_,
						       lib_serial,
						       lib_script_info);
	    }
	  unsigned int arg_serial = this->input_argument_->file().arg_serial();
	  Script_info* script_info = this->input_argument_->script_info();
	  incremental_inputs->report_object(this->object_, arg_serial,
					    this->library_, script_info);
	}
      this->object_->layout(this->symtab_, this->layout_, this->sd_);
      this->object_->add_symbols(this->symtab_, this->sd_, this->layout_);
      this->object_->discard_decompressed_sections();
      delete this->sd_;
      this->sd_ = NULL;
      this->object_->release();
    }
}

// Class Read_member.

Read_member::~Read_member()
{
  if (this->this_blocker_ != NULL)
    delete this->this_blocker_;
  // next_blocker_ is deleted by the task associated with the next
  // input file.
}

// Return whether a Read_member task is runnable.

Task_token*
Read_member::is_runnable()
{
  if (this->this_blocker_ != NULL && this->this_blocker_->is_blocked())
    return this->this_blocker_;
  return NULL;
}

void
Read_member::locks(Task_locker* tl)
{
  tl->add(this, this->next_blocker_);
}

// Run a Read_member task.

void
Read_member::run(Workqueue*)
{
  // This task doesn't need to do anything for now.  The Read_symbols task
  // that is queued for the archive library will cause the archive to be
  // processed from scratch.
}

// Class Check_script.

Check_script::~Check_script()
{
  if (this->this_blocker_ != NULL)
    delete this->this_blocker_;
  // next_blocker_ is deleted by the task associated with the next
  // input file.
}

// Return whether a Check_script task is runnable.

Task_token*
Check_script::is_runnable()
{
  if (this->this_blocker_ != NULL && this->this_blocker_->is_blocked())
    return this->this_blocker_;
  return NULL;
}

void
Check_script::locks(Task_locker* tl)
{
  tl->add(this, this->next_blocker_);
}

// Run a Check_script task.

void
Check_script::run(Workqueue*)
{
  Incremental_inputs* incremental_inputs = this->layout_->incremental_inputs();
  gold_assert(incremental_inputs != NULL);
  unsigned int arg_serial = this->input_reader_->arg_serial();
  Script_info* script_info =
      this->ibase_->get_script_info(this->input_file_index_);
  Timespec mtime = this->input_reader_->get_mtime();
  incremental_inputs->report_script(script_info, arg_serial, mtime);
}

// Class Check_library.

Check_library::~Check_library()
{
  if (this->this_blocker_ != NULL)
    delete this->this_blocker_;
  // next_blocker_ is deleted by the task associated with the next
  // input file.
}

// Return whether a Check_library task is runnable.

Task_token*
Check_library::is_runnable()
{
  if (this->this_blocker_ != NULL && this->this_blocker_->is_blocked())
    return this->this_blocker_;
  return NULL;
}

void
Check_library::locks(Task_locker* tl)
{
  tl->add(this, this->next_blocker_);
}

// Run a Check_library task.

void
Check_library::run(Workqueue*)
{
  Incremental_inputs* incremental_inputs = this->layout_->incremental_inputs();
  gold_assert(incremental_inputs != NULL);
  Incremental_library* lib = this->ibase_->get_library(this->input_file_index_);
  gold_assert(lib != NULL);
  lib->copy_unused_symbols();
  // FIXME: Check that unused symbols remain unused.
  if (!lib->is_reported())
    {
      unsigned int lib_serial = lib->arg_serial();
      unsigned int lib_index = lib->input_file_index();
      Script_info* script_info = this->ibase_->get_script_info(lib_index);
      incremental_inputs->report_archive_begin(lib, lib_serial, script_info);
    }
  incremental_inputs->report_archive_end(lib);
}

// Class Input_group.

// When we delete an Input_group we can delete the archive
// information.

Input_group::~Input_group()
{
  for (Input_group::const_iterator p = this->begin();
       p != this->end();
       ++p)
    delete *p;
}

// Class Start_group.

Start_group::~Start_group()
{
  if (this->this_blocker_ != NULL)
    delete this->this_blocker_;
  // next_blocker_ is deleted by the task associated with the first
  // file in the group.
}

// We need to wait for THIS_BLOCKER_ and unblock NEXT_BLOCKER_.

Task_token*
Start_group::is_runnable()
{
  if (this->this_blocker_ != NULL && this->this_blocker_->is_blocked())
    return this->this_blocker_;
  return NULL;
}

void
Start_group::locks(Task_locker* tl)
{
  tl->add(this, this->next_blocker_);
}

// Store the number of undefined symbols we see now.

void
Start_group::run(Workqueue*)
{
  this->finish_group_->set_saw_undefined(this->symtab_->saw_undefined());
}

// Class Finish_group.

Finish_group::~Finish_group()
{
  if (this->this_blocker_ != NULL)
    delete this->this_blocker_;
  // next_blocker_ is deleted by the task associated with the next
  // input file following the group.
}

// We need to wait for THIS_BLOCKER_ and unblock NEXT_BLOCKER_.

Task_token*
Finish_group::is_runnable()
{
  if (this->this_blocker_ != NULL && this->this_blocker_->is_blocked())
    return this->this_blocker_;
  return NULL;
}

void
Finish_group::locks(Task_locker* tl)
{
  tl->add(this, this->next_blocker_);
}

// Loop over the archives until there are no new undefined symbols.

void
Finish_group::run(Workqueue*)
{
  size_t saw_undefined = this->saw_undefined_;
  while (saw_undefined != this->symtab_->saw_undefined())
    {
      saw_undefined = this->symtab_->saw_undefined();

      for (Input_group::const_iterator p = this->input_group_->begin();
	   p != this->input_group_->end();
	   ++p)
	{
	  Task_lock_obj<Archive> tl(this, *p);

	  (*p)->add_symbols(this->symtab_, this->layout_,
			    this->input_objects_, this->mapfile_);
	}
    }

  // Now that we're done with the archives, record the incremental
  // layout information.
  for (Input_group::const_iterator p = this->input_group_->begin();
       p != this->input_group_->end();
       ++p)
    {
      // For an incremental link, finish recording the layout information.
      Incremental_inputs* incremental_inputs =
          this->layout_->incremental_inputs();
      if (incremental_inputs != NULL)
	incremental_inputs->report_archive_end(*p);
    }

  if (parameters->options().has_plugins())
    parameters->options().plugins()->save_input_group(this->input_group_);
  else
    delete this->input_group_;
}

// Class Read_script

Read_script::~Read_script()
{
  if (this->this_blocker_ != NULL)
    delete this->this_blocker_;
  // next_blocker_ is deleted by the task associated with the next
  // input file.
}

// We are blocked by this_blocker_.

Task_token*
Read_script::is_runnable()
{
  if (this->this_blocker_ != NULL && this->this_blocker_->is_blocked())
    return this->this_blocker_;
  return NULL;
}

// We don't unlock next_blocker_ here.  If the script names any input
// files, then the last file will be responsible for unlocking it.

void
Read_script::locks(Task_locker*)
{
}

// Read the script, if it is a script.

void
Read_script::run(Workqueue* workqueue)
{
  bool used_next_blocker;
  if (!read_input_script(workqueue, this->symtab_, this->layout_,
			 this->dirpath_, this->dirindex_, this->input_objects_,
			 this->mapfile_, this->input_group_,
			 this->input_argument_, this->input_file_,
			 this->next_blocker_, &used_next_blocker))
    {
      // Here we have to handle any other input file types we need.
      gold_error(_("%s: not an object or archive"),
		 this->input_file_->file().filename().c_str());
    }

  if (!used_next_blocker)
    {
      // Queue up a task to unlock next_blocker.  We can't just unlock
      // it here, as we don't hold the workqueue lock.
      workqueue->queue_soon(new Unblock_token(NULL, this->next_blocker_));
    }
}

// Return a debugging name for a Read_script task.

std::string
Read_script::get_name() const
{
  std::string ret("Read_script ");
  if (this->input_argument_->file().is_lib())
    ret += "-l";
  else if (this->input_argument_->file().is_searched_file())
    ret += "-l:";
  ret += this->input_argument_->file().name();
  return ret;
}

} // End namespace gold.
@


1.52
log
@	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.
@
text
@d605 1
d636 1
@


1.51
log
@2011-07-13  Sriraman Tallam  <tmsriram@@google.com>

	* plugin-api.h
	(ld_plugin_section): New struct.
	(ld_plugin_get_section_count): New typedef.
	(ld_plugin_get_section_type): New typedef.
	(ld_plugin_get_section_name): New typedef.
	(ld_plugin_get_section_contents): New typedef.
	(ld_plugin_update_section_order): New typedef.
	(ld_plugin_allow_section_ordering): New typedef.
	(LDPT_GET_SECTION_COUNT): New enum value.
	(LDPT_GET_SECTION_TYPE): New enum value.
	(LDPT_GET_SECTION_NAME): New enum value.
	(LDPT_GET_SECTION_CONTENTS): New enum value.
	(LDPT_UPDATE_SECTION_ORDER): New enum value.
	(LDPT_ALLOW_SECTION_ORDERING): New enum value.
	(tv_get_section_count): New struct members.
	(tv_get_section_type): New struct members.
	(tv_get_section_name): New struct members.
	(tv_get_section_contents): New struct members.
	(tv_update_section_order): New struct members.
	(tv_allow_section_ordering): New struct members.
	* archive.cc (Archive::get_elf_object_for_member): Add extra parameter
	to claim_file call.
	* layout.cc (Layout::Layout): Initialize section_ordering_specified_,
	input_section_position_, and input_section_glob_.
	(read_layout_from_file): Call function section_ordering_specified.
	* layout.h (is_section_ordering_specified): New function.
	(section_ordering_specified): New function.
	(section_ordering_specified_): New boolean member.
	* main.cc(main): Call load_plugins after layout object is defined.
	* output.cc (Output_section::add_input_section): Use
	function section_ordering_specified to check if section ordering is
	needed.
	* output.cc (Output_section::add_relaxed_input_section): Use
	function section_ordering_specified to check if section ordering is
	needed.
	(Output_section::update_section_layout): New function.
	(Output_section::sort_attached_input_sections): Check if input section
	must be reordered.
	* output.h (Output_section::update_section_layout): New function.
	* plugin.cc (get_section_count): New function.
	(get_section_type): New function.
	(get_section_name): New function.
	(get_section_contents): New function.
	(update_section_order): New function.
	(allow_section_ordering): New function.
	(Plugin::load): Add the new interfaces to the transfer vector.
	(Plugin_manager::load_plugins): New parameter.
	(Plugin_manager::all_symbols_read): New parameter.
	(Plugin_manager::claim_file): New parameter. Save the elf object for
	unclaimed objects.
	(Plugin_manager::get_elf_object): New function.
	(Plugin_manager::get_view): Change to directly use the bool to check
	if get_view is called from claim_file_hook.
	* plugin.h (input_objects): New function
	(Plugin__manager::load_plugins): New parameter.
	(Plugin_manager::claim_file): New parameter.
	(Plugin_manager::get_elf_object): New function.
	(Plugin_manager::in_claim_file_handler): New function.
	(Plugin_manager::in_claim_file_handler_): New member.
	(layout): New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Call the claim_file
	handler with an extra parameter. Make the elf object before calling
	claim_file handler.
	* testsuite/plugin_test.c (get_section_count): New function pointer.
	(get_section_type): New function pointer.
	(get_section_name): New function pointer.
	(get_section_contents): New function pointer.
	(update_section_order): New function pointer.
	(allow_section_ordering): New function pointer.
	(onload): Check if the new interfaces exist.
@
text
@d164 4
a167 2
  // the token.
  if (!this->do_read_symbols(workqueue))
@


1.51.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d164 2
a165 4
  // the token. If the object is a member of a lib group, however,
  // the token was already added to the list of locks for the task,
  // and it will be unblocked automatically at the end of the task.
  if (!this->do_read_symbols(workqueue) && this->member_ == NULL)
@


1.50
log
@	* incremental.cc (Sized_incremental_binary::setup_readers): Pass
	input file index to Script_info ctor.
	(Sized_incremental_binary::do_file_has_changed): Find the
	command-line argument for files named in scripts.
	* incremental.h (Script_info::Script_info): New ctor
	with input file index.
	(Script_info::input_file_index): New function.
	(Script_info::input_file_index_): New data member.
	(Incremental_binary::get_library): Add const.
	(Incremental_binary::get_script_info): Add const.
	* readsyms.cc (Read_member::is_runnable): Check for this_blocker_.
	* testsuite/Makefile.am (incremental_test_5): New test case.
	(incremental_test_6): New test case.
	* testsuite/Makefile.in: Regenerate.
@
text
@d323 16
d342 2
a343 1
                                                                   0, filesize);
d346 4
d383 1
a383 8
      bool unconfigured = false;
      bool* punconfigured = (input_file->will_search_for()
			     ? &unconfigured
			     : NULL);
      Object* obj = make_elf_object(input_file->filename(),
				    input_file, 0, ehdr, read_size,
				    punconfigured);
      if (obj == NULL)
d399 1
a399 1
      obj->read_symbols(sd);
d414 1
a414 1
          this->member_->obj_ = obj;
d429 1
a429 1
					    obj,
@


1.49
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d640 2
@


1.48
log
@	* archive.cc (Archive::include_member): Adjust call to report_object.
	(Add_archive_symbols::run): Add script_info to call to
	report_archive_begin.
	(Lib_group::include_member): Adjust call to report_object.
	(Add_lib_group_symbols::run): Adjust call to report_object.
	* incremental-dump.cc (dump_incremental_inputs): Remove unnecessary
	blocks.  Add object count for script input files.
	* incremental.cc (Incremental_inputs::report_archive_begin): Add
	script_info parameter; change all callers.
	(Incremental_inputs::report_object): Add script_info parameter;
	change all callers.
	(Incremental_inputs::report_script): Store backpointer to
	incremental info entry.
	(Output_section_incremental_inputs::set_final_data_size): Record
	additional information for scripts.
	(Output_section_incremental_inputs::write_info_blocks): Likewise.
	* incremental.h (Incremental_script_entry::add_object): New function.
	(Incremental_script_entry::get_object_count): New function.
	(Incremental_script_entry::get_object): New function.
	(Incremental_script_entry::objects_): New data member; adjust
	constructor.
	(Incremental_inputs::report_archive_begin): Add script_info parameter.
	(Incremental_inputs::report_object): Add script_info parameter.
	(Incremental_inputs_reader::get_object_count): New function.
	(Incremental_inputs_reader::get_object_offset): New function.
	* options.cc (Input_arguments::add_file): Return reference to
	new input argument.
	* options.h (Input_argument::set_script_info): New function.
	(Input_argument::script_info): New function.
	(Input_argument::script_info_): New data member; adjust all
	constructors.
	(Input_file_group::add_file): Return reference to new input argument.
	(Input_file_lib::add_file): Likewise.
	(Input_arguments::add_file): Likewise.
	* readsyms.cc (Add_symbols::run): Adjust call to report_object.
	* script.cc (Parser_closure::Parser_closure): Add script_info
	parameter; adjust all callers.
	(Parser_closure::script_info): New function.
	(Parser_closure::script_info_): New data member.
	(read_input_script): Report scripts earlier to incremental info.
	(script_add_file): Set script_info in Input_argument.
	(script_add_library): Likewise.
	* script.h (Script_options::Script_info): Rewrite class.
@
text
@d350 1
d401 2
d416 1
d570 3
a572 1
  tl->add(this, this->object_->token());
d589 1
d600 17
a616 2
	incremental_inputs->report_object(this->object_, NULL,
					  this->input_argument_->script_info());
d625 121
@


1.47
log
@	* plugin.cc (class Plugin_rescan): Define new class.
	(Plugin_manager::claim_file): Set any_claimed_.
	(Plugin_manager::save_archive): New function.
	(Plugin_manager::save_input_group): New function.
	(Plugin_manager::all_symbols_read): Create Plugin_rescan task if
	necessary.
	(Plugin_manager::new_undefined_symbol): New function.
	(Plugin_manager::rescan): New function.
	(Plugin_manager::rescannable_defines): New function.
	(Plugin_manager::add_input_file): Set any_added_.
	* plugin.h (class Plugin_manager): define new fields rescannable_,
	undefined_symbols_, any_claimed_, and any_added_.  Declare
	Plugin_rescan as friend.  Declare new functions.
	(Plugin_manager::Rescannable): Define type.
	(Plugin_manager::Rescannable_list): Define type.
	(Plugin_manager::Undefined_symbol_list): Define type.
	(Plugin_manager::Plugin_manager): Initialize new fields.
	* archive.cc (Archive::defines_symbol): New function.
	(Add_archive_symbols::run): Pass archive to plugins if any.
	* archive.h (class Archive): Declare defines_symbol.
	* readsyms.cc (Input_group::~Input_group): New function.
	(Finish_group::run): Pass input_group to plugins if any.
	* readsyms.h (class Input_group): Declare destructor.
	* symtab.cc (add_from_object): Pass undefined symbol to plugins if
	any.
@
text
@d593 2
a594 1
	incremental_inputs->report_object(this->object_, NULL);
@


1.46
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d602 13
d696 2
a697 2
  // Now that we're done with the archives, record the incremental layout
  // information, then delete them.
d707 1
d709 4
a712 3
      delete *p;
    }
  delete this->input_group_;
@


1.45
log
@	* gold/archive.h (Add_lib_group_symbols): Add readsyms_blocker_, adjust
	constructor, and set_blocker.
	* gold/archive.cc (Add_lib_group_symbols::is_runnable): Also check
	readsyms_blocker_.
	* gold/readsyms.cc (Read_symbols::do_lib_group): Also pass
	this->this_blocker_ to Add_lib_group_symbols::set_blocker.
	* testsuite/Makefile.am (start_lib_test): New test case.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/start_lib_test_main.c: New file.
	* testsuite/start_lib_test_1.c: New file.
	* testsuite/start_lib_test_2.c: New file.
	* testsuite/start_lib_test_3.c: New file.
@
text
@d170 1
a170 1
// Handle a whole lib group. Other then collecting statisticts, this just
@


1.45.2.1
log
@	* plugin.cc (class Plugin_rescan): Define new class.
	(Plugin_manager::claim_file): Set any_claimed_.
	(Plugin_manager::save_archive): New function.
	(Plugin_manager::save_input_group): New function.
	(Plugin_manager::all_symbols_read): Create Plugin_rescan task if
	necessary.
	(Plugin_manager::new_undefined_symbol): New function.
	(Plugin_manager::rescan): New function.
	(Plugin_manager::rescannable_defines): New function.
	(Plugin_manager::add_input_file): Set any_added_.
	* plugin.h (class Plugin_manager): define new fields rescannable_,
	undefined_symbols_, any_claimed_, and any_added_.  Declare
	Plugin_rescan as friend.  Declare new functions.
	(Plugin_manager::Rescannable): Define type.
	(Plugin_manager::Rescannable_list): Define type.
	(Plugin_manager::Undefined_symbol_list): Define type.
	(Plugin_manager::Plugin_manager): Initialize new fields.
	* archive.cc (Archive::defines_symbol): New function.
	(Add_archive_symbols::run): Pass archive to plugins if any.
	* archive.h (class Archive): Declare defines_symbol.
	* readsyms.cc (Input_group::~Input_group): New function.
	(Finish_group::run): Pass input_group to plugins if any.
	* readsyms.h (class Input_group): Declare destructor.
	* symtab.cc (add_from_object): Pass undefined symbol to plugins if
	any.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
a601 13
// Class Input_group.

// When we delete an Input_group we can delete the archive
// information.

Input_group::~Input_group()
{
  for (Input_group::const_iterator p = this->begin();
       p != this->end();
       ++p)
    delete *p;
}

d683 2
a684 2
  // Now that we're done with the archives, record the incremental
  // layout information.
d694 2
d697 1
a697 5

  if (parameters->options().has_plugins())
    parameters->options().plugins()->save_input_group(this->input_group_);
  else
    delete this->input_group_;
@


1.44
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_SYMTAB,
	SHT_GNU_INCREMENTAL_RELOCS.

gold/ChangeLog:

	* archive.cc: Include incremental.h.
	(Archive::Archive): Initialize incremental_info_.
	(Archive::include_member): Record archive members in incremental info.
	(Add_archive_symbols::run): Record begin and end of an archive in
	incremental info.
	(Lib_group::include_member): Record objects in incremental info.
	* archive.h (Incremental_archive_entry): Forward declaration.
	(Archive::set_incremental_info): New member function.
	(Archive::incremental_info): New member function.
	(Archive::Unused_symbol_iterator): New class.
	(Archive::unused_symbols_begin): New member function.
	(Archive::unused_symbols_end): New member function.
	(Archive::incremental_info_): New data member.
	* incremental-dump.cc (find_input_containing_global): New function.
	(dump_incremental_inputs): Dump new incremental info sections.
	* incremental.cc: Include symtab.h.
	(Output_section_incremental_inputs): New class.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Support
	new incremental info sections.
	(Sized_incremental_binary::do_check_inputs): Likewise.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): New function.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Rewrite.
	(Incremental_inputs::finalize): Do nothing but finalize string table.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Output_section_incremental_inputs::set_final_data_size): New function.
	(Output_section_incremental_inputs::do_write): New function.
	(Output_section_incremental_inputs::write_header): New function.
	(Output_section_incremental_inputs::write_input_files): New function.
	(Output_section_incremental_inputs::write_info_blocks): New function.
	(Output_section_incremental_inputs::write_symtab): New function.
	* incremental.h (Incremental_script_entry): Forward declaration.
	(Incremental_object_entry): Forward declaration.
	(Incremental_archive_entry): Forward declaration.
	(Incremental_inputs): Forward declaration.
	(Incremental_inputs_header_data): Remove.
	(Incremental_inputs_header): Remove.
	(Incremental_inputs_header_write): Remove.
	(Incremental_inputs_entry_data): Remove.
	(Incremental_inputs_entry): Remove.
	(Incremental_inputs_entry_write): Remove.
	(enum Incremental_input_type): Add INCREMENTAL_INPUT_ARCHIVE_MEMBER.
	(Incremental_binary::find_incremental_inputs_sections): Add parameters.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Sized_ncremental_binary::do_find_incremental_inputs_sections):
	Likewise.
	(Incremental_input_entry): New class.
	(Incremental_script_entry): New class.
	(Incremental_object_entry): New class.
	(Incremental_archive_entry): New class.
	(Incremental_inputs::Incremental_inputs): Initialize new data members.
	(Incremental_inputs::report_inputs): Remove.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): Change prototype.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Change prototype.
	(Incremental_inputs::get_reloc_count): New function.
	(Incremental_inputs::set_reloc_count): New function.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::inputs_section): New function.
	(Incremental_inputs::symtab_section): New function.
	(Incremental_inputs::relocs_section): New function.
	(Incremental_inputs::get_stringpool): Add const.
	(Incremental_inputs::command_line): Add const.
	(Incremental_inputs::inputs): Remove.
	(Incremental_inputs::command_line_key): New function.
	(Incremental_inputs::input_file_count): New function.
	(Incremental_inputs::input_files): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::Input_info): Remove.
	(Incremental_inputs::lock_): Remove.
	(Incremental_inputs::inputs_): Change type.
	(Incremental_inputs::inputs_map_): Remove.
	(Incremental_inputs::current_object_entry_): New data member.
	(Incremental_inputs::inputs_section_): New data member.
	(Incremental_inputs::symtab_section_): New data member.
	(Incremental_inputs::relocs_section_): New data member.
	(Incremental_inputs::reloc_count_): New data member.
	(Incremental_inputs_reader): New class.
	(Incremental_symtab_reader): New class.
	(Incremental_relocs_reader): New class.
	* layout.cc (Layout::finalize): Move finalization of incremental info
	and creation of incremental info sections to follow finalization of
	symbol table.  Set offsets for postprocessing sections.
	(Layout::create_incremental_info_sections): Call
	Incremental_inputs::create_data_sections.  Add incremental symtab
	and relocs sections.  Set sh_entsize and sh_link fields.  Arrange for
	sections to layout after input sections.
	* layout.h (struct Timespec): Forward declaration.
	(Layout::incremental_inputs): Add const.
	(Layout::create_incremental_info_sections): Add parameter.
	* main.cc (main): Remove call to Incremental_inputs::report_inputs.
	* object.cc: Include incremental.h.
	(Relobj::finalize_incremental_relocs): New function.
	(Sized_relobj::do_layout): Record input sections in incremental info.
	* object.h (Object::output_section): New function.
	(Object::output_section_offset): Moved from Relobj.
	(Object::get_incremental_reloc_base): New function.
	(Object::get_incremental_reloc_count): New function.
	(Object::do_output_section): New function.
	(Object::do_output_section_offset): Moved from Relobj.
	(Object::do_get_incremental_reloc_base): New function.
	(Object::do_get_incremental_reloc_count): New function.
	(Object::Object): Initialize new data members.
	(Relobj::output_section): Renamed do_output_section and moved to
	protected.
	(Relobj::output_section_offset): Moved to Object.
	(Relobj::do_get_incremental_reloc_base): New function.
	(Relobj::do_get_incremental_reloc_count): New function.
	(Relobj::allocate_incremental_reloc_counts): New function.
	(Relobj::count_incremental_reloc): New function.
	(Relobj::finalize_incremental_relocs): New function.
	(Relobj::next_incremental_reloc_index): New function.
	(Relobj::reloc_counts_): New data member.
	(Relobj::reloc_bases_): New data member.
	(Sized_relobj::do_relocate_sections): Add parameter.  Change caller.
	(Sized_relobj::relocate_sections): Add parameter.  Change all callers.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* plugin.cc (Plugin_manager::add_input_file): Rewrite test for
	incremental link.
	* readsyms.cc (Read_symbols::do_read_symbols): Move reporting of
	archives and object files elsewhere.
	(Add_symbols::run): Report object files here.
	(Finish_group::run): Report end of archive at end of group.
	* reloc.cc: Include layout.h, incremental.h.
	(Sized_relobj::do_read_relocs): Need relocations for incremental link.
	(Sized_relobj::do_scan_relocs): Record relocations for incremental link.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::do_relocate_sections): Write incremental relocations.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* script.cc (read_input_script): Rewrite test for incremental link.
	Change call to Incremental_inputs::report_script.
	* symtab.h (Symbol_table::first_global_index): New function.
	(Symbol_table::output_count): New function.
@
text
@d251 1
a251 1
  add_lib_group_symbols->set_blocker(next_blocker);
@


1.43
log
@2010-03-22  Rafael Espindola  <espindola@@google.com>

	* archive.cc (Should_include): Move to archive.h.
	(should_include_member): Make it a member of Archive.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* archive.h: Include options.h.
	(Archive_member): Moved from Archive.
	(Should_include): Moved from archive.cc.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* dynobj.cc (do_should_include_member): New.
	* dynobj.h (do_should_include_member): New.
	* gold.cc (queue_initial_tasks): Update call to queue.
	* main.cc (main): Print lib group stats.
	* object.cc (do_should_include_member): New.
	* object.h: Include archive.h.
	(Object::should_include_member): New.
	(Object::do_should_include_member): New.
	(Sized_relobj::do_should_include_member): New.
	* options.cc (General_options::parse_start_lib): New.
	(General_options::parse_end_lib): New.
	(Input_arguments::add_file): Handle lib groups.
	(Input_arguments::start_group): Check we are not in a lib.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib): New.
	* options.h (General_options): Add start_lib and end_lib.
	(Input_argument::lib_): New.
	(Input_argument::lib): New.
	(Input_argument::is_lib): New.
	(Input_file_lib): New.
	(Input_arguments::in_lib_): New.
	(Input_arguments::in_lib): New.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib_): New.
	* plugin.cc (Pluginobj::get_symbol_resolution_info): Mark symbols
	in unused members as preempted.
	(Sized_pluginobj::do_should_include_member): New.
	* plugin.h (Sized_pluginobj::do_should_include_member): New.
	* readsyms.cc (Read_symbols::locks): If we are just reading a member,
	return the blocker.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::do_read_symbols): Handle lib groups.
	(Read_symbols::get_name): Handle lib groups.
	* readsyms.h (Read_symbols): Add an archive member pointer.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::member_): New.
	* script.cc (read_input_script): Update call to queue_soon.
@
text
@a304 6
	  if (this->layout_->incremental_inputs())
	    {
	      const Input_argument* ia = this->input_argument_;
	      this->layout_->incremental_inputs()->report_archive(ia, arch);
	    }

a385 6
      if (this->layout_->incremental_inputs())
	{
	  const Input_argument* ia = this->input_argument_;
	  this->layout_->incremental_inputs()->report_object(ia, obj);
	}

d590 4
d683 2
a684 1
  // Delete all the archives now that we no longer need them.
d688 9
a696 1
    delete *p;
@


1.42
log
@2010-03-15   Rafael Espindola  <espindola@@google.com>

	* readsyms.cc (Read_symbols::do_read_symbols): Update calls to
	Add_symbols' constructor.
	* readsyms.h (Add_symbols): Remove the input_group member.
@
text
@d130 1
a130 1
				    input_group, NULL, next_blocker));
d152 1
a152 1
Read_symbols::locks(Task_locker*)
d154 2
d170 87
d270 3
d307 1
a307 1
	      const Input_argument* ia = this->input_argument_;	      
d341 7
d408 7
d493 1
a493 1
					     this_blocker, next_blocker));
d507 33
a539 1
  if (!this->input_argument_->is_group())
a548 14

  std::string ret("Read_symbols group (");
  bool add_space = false;
  const Input_file_group* group = this->input_argument_->group();
  for (Input_file_group::const_iterator p = group->begin();
       p != group->end();
       ++p)
    {
      if (add_space)
	ret += ' ';
      ret += p->file().name();
      add_space = true;
    }
  return ret + ')';
@


1.41
log
@	* fileread.cc (File_read::~File_read): Don't delete whole_file_view_.
	(File_read::open[1]): Remove initial mapping of whole_file_view_.
	(File_read::open[2]): Add whole_file_view_ to list of views.
	(File_read::make_view): Remove test of whole_file_view_.
	(File_read::find_or_make_view): Create whole_file_view_ if
	necessary.
	(File_read::clear_views): Replace bool parameter with enum;
	adjust all callers.  Don't delete views with permanent data;
	do delete cached views and views from archives if
	--no-keep-files-mapped is set.  Set whole_file_view_ to NULL
	if clearing the corresponding view.
	* fileread.h (File_read::Clear_views_mode): New enum.
	(File_read::View::is_permanent_view): New method.
	(File_read::clear_views): Replace bool parameter
	with enum; adjust all callers.
	* options.h (General_options): Change keep_files_mapped option;
	add map_whole_files.
	* readsyms.cc (Add_symbols::run): Delete sd_ object before
	releasing the file.
	* reloc.cc (Scan_relocs::run): Delete rd_ object before releasing
	the file.
@
text
@a255 1
						this->input_group_,
a317 1
					    this->input_group_,
@


1.40
log
@	* gold-threads.h (class Once): Define.
	(class Initialize_lock): Rewrite as child of Once.
	* gold-threads.cc (class Once_initialize): Define.
	(once_pointer_control): New static variable.
	(once_pointer, once_arg): New static variables.
	(c_run_once): New static function.
	(Once::Once, Once::run_once, Once::internal_run): New functions.
	(class Initialize_lock_once): Remove.
	(initialize_lock_control): Remove.
	(initialize_lock_pointer): Remove.
	(initialize_lock_once): Remove.
	(Initialize_lock::Initialize_lock): Move to gold-threads.h.
	(Initialize_lock::initialize): Rewrite.
	(Initialize_lock::do_run_once): New function.
	* archive.cc (Archive::interpret_header): Only clear name if it is
	not already empty.
	* fileread.cc: Include "gold-threads.h"
	(file_counts_lock): New static variable.
	(file_counts_initialize_lock): Likewise.
	(File_read::release): Only increment counts when using --stats.
	Use a lock around the increment.
	* parameters.cc (class Set_parameters_target_once): Define.
	(set_parameters_target_once): New static variable.
	(Parameters::Parameters): Move here from parameters.h.
	(Parameters::set_target): Rewrite.
	(Parameters::set_target_once): New function.
	(Parameters::clear_target): Move here and rewrite.
	* parameters.h (class Parameters): Update declarations.  Add
	set_parameters_target_once_ field.
	(Parameters::Parameters): Move to parameters.cc.
	(Parameters::clear_target): Likewise.
	* readsyms.cc (Read_symbols::do_group): Create a Start_group
	task.
	(Start_group::~Start_group): New function.
	(Start_group::is_runnable): New function.
	(Start_group::locks, Start_group::run): New functions.
	(Finish_group::run): Change saw_undefined to size_t.
	* readsyms.h (class Start_group): Define.
	(class Finish_group): Change saw_undefined_ field to size_t.
	(Finish_group::Finish_group): Remove saw_undefined and
	this_blocker parameters.  Change all callers.
	(Finish_group::set_saw_undefined): New function.
	(Finish_group::set_blocker): New function.
	* symtab.h (class Symbol_table): Change saw_undefined to return
	size_t.  Change saw_undefined_ field to size_t.
	* target-select.cc (Set_target_once::do_run_once): New function.
	(Target_selector::Target_selector): Initialize set_target_once_
	field.  Don't initialize lock_ and initialize_lock_ fields.
	(Target_selector::instantiate_target): Rewrite.
	(Target_selector::set_target): New function.
	* target-select.h (class Set_target_once): Define.
	(class Target_selector): Update declarations.  Make
	Set_target_once a friend.  Remove lock_ and initialize_lock_
	fields.  Add set_target_once_ field.
@
text
@d473 2
d482 2
a485 2
  delete this->sd_;
  this->sd_ = NULL;
@


1.39
log
@2009-10-10  Chris Demetriou  <cgd@@google.com>

	* options.h (Input_file_argument::Input_file_type): New enum.
	(Input_file_argument::is_lib_): Replace with...
	(Input_file_argument::type_): New member.
	(Input_file_argument::Input_file_argument): Take Input_file_type
	'type' rather than boolean 'is_lib' as second argument.
	(Input_file_argument::is_lib): Use type_.
	(Input_file_argument::is_searched_file): New function.
	(Input_file_argument::may_need_search): Handle is_searched_file.
	* options.cc (General_options::parse_library): Support -l:filename.
	(General_options::parse_just_symbols): Update for Input_file_argument
	changes.
	(Command_line::process): Likewise.
	* archive.cc (Archive::get_file_and_offset): Likewise.
	* plugin.cc (Plugin_manager::release_input_file): Likewise.
	* script.cc (read_script_file, script_add_file): Likewise.
	* fileread.cc (Input_file::Input_file): Likewise.
	(Input_file::will_search_for): Handle is_searched_file.
	(Input_file::open): Likewise.
	* readsyms.cc (Read_symbols::get_name): Likewise.
	* testsuite/Makefile.am (searched_file_test): New test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/searched_file_test.cc: New file.
	* testsuite/searched_file_test_lib.cc: New file.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d363 13
d383 1
a383 1
      Task_token* next_blocker = new Task_token(true);
d393 3
a395 9
  const int saw_undefined = this->symtab_->saw_undefined();
  workqueue->queue_soon(new Finish_group(this->input_objects_,
					 this->symtab_,
					 this->layout_,
					 this->mapfile_,
					 input_group,
					 saw_undefined,
					 this_blocker,
					 this->next_blocker_));
d486 34
d551 1
a551 1
  int saw_undefined = this->saw_undefined_;
@


1.38
log
@	* object.h (class Object): Remove target_ field, and target,
	sized_target, and set_target methods.
	(Object::sized_target): Remove.
	(class Sized_relobj): Update declarations.  Remove sized_target.
	* object.cc (Sized_relobj::setup): Remove target parameter.
	Change all callers.
	(Input_objects::add_object): Don't do anything with the target.
	(make_elf_sized_object): Add punconfigured parameter.  Change all
	callers.  Set or test parameter target.
	* dynobj.cc (Sized_dynobj::target): Remove target parameter.
	Change all callers.
	* parameters.cc (Parameters::set_target): Change parameter type to
	be non-const.
	(Parameters::default_target): Remove.
	(set_parameters_target): Change parameter type to be non-const.
	(parameters_force_valid_target): New function.
	(parameters_clear_target): New function.
	* parameters.h (class Parameters): Update declarations.  Remove
	default_target method.  Add sized_target and clear_target
	methods.  Change target_ to be non-const.
	(set_parameters_target): Update declaration.
	(parameters_force_valid_target): Declare.
	(parameters_clear_target): Declare.
	* readsyms.cc (Read_symbols::do_read_symbols): Pass punconfigured
	as NULL if we aren't searching.
	(Add_symbols::run): Don't check for compatible target.
	* fileread.cc (Input_file::open_binary): Call
	parameters_force_valid_target.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (make_sized_plugin_object): Likewise.  Don't call
	set_target on object.
	* dynobj.h (class Sized_dynobj): Update declarations.
	* archive.cc (Archive::get_elf_object_for_member): Return NULL if
	make_elf_object returns NULL.
	(Archive::include_member): Don't check whether object target is
	compatible.
	* output.cc (Output_section::add_input_section): Get target from
	parameters.
	(Output_section::relax_input_section): Likewise.
	* reloc.cc (Sized_relobj::do_gc_process_relocs): Get target from
	parameters.
	(Sized_relobj::do_scan_relocs): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* symtab.cc (Symbol_table::wrap_symbol): Likewise.  Remove object
	parameter.  Change all callers.
	(Symbol_table::add_from_object): Get target from parameters.
	(Symbol_table::add_from_relobj): Don't check object target.
	(Symbol_table::add_from_dynobj): Likewise.
	(Symbol_table::define_special_symbol): Get target from
	parameters.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/binary_unittest.cc (gold_testsuite): Remove target
	parameter.  Change all callers.  Clear parameter target.
	(Binary_test): Test target here.
	* testsuite/object_unittest.cc (gold_testsuite): Remove
	target_test_pointer parameter.  Change all callers.
	(Object_test): Test target here.
@
text
@d401 2
d595 2
@


1.37
log
@	* gold.h (Incremental_argument_list): Remove (invalid) forward
	declaration.
	* incremental.cc (Incremental_inputs::report_achive): New method.
	(Incremental_inputs::report_object): New method.
	(Incremental_inputs::report_script): New method.
	(Incremental_inputs::finalize_inputs): New method.
	(Incremental_inputs::finalize): Call finalize_inputs().
	(Incremental_inputs::sized_create_incremental_inputs_section_data):
	Create inputs entries.
	* incremental.h (Incremental_input_type): New enum.
	(Incremental_inputs::Incremental_input): Initialize new fields.
	(Incremental_inputs::report_inputs): New method.
	(Incremental_inputs::report_achive): New method.
	(Incremental_inputs::report_object): New method.
	(Incremental_inputs::report_script): New method.
	(Incremental_inputs::finalize_inputs): New method.
	(Incremental_inputs::Input_info): New struct.
	(Incremental_inputs::Input_info_map): New typedef.
	(Incremental_inputs::lock_): New field.
	(Incremental_inputs::Inputs_): New field.
	(Incremental_inputs::Inputs_map): New field.
	* main.cc (main): Call Incremental_input::report_inputs.
	* options.h (Input_argument_list): Typedef moved from
	Input_arguments.
	(Input_file_group::Files): Remove, use ::Input_argument_list.
	(Input_file_group::Input_argument_list): Remove, use
	::Input_argument_list.
	* plugin.cc (Plugin_manager::add_input_file): Add error in
	incremental build.
	* read_syms.cc (do_read_syms): Call Incremental_input::report_*
	functions.
	* script.cc (read_input_script): Call
	Incremental_input::report_script.
	* script.h (Script_info): New class.
@
text
@d269 4
a272 1
      bool unconfigured;
d275 1
a275 1
				    &unconfigured);
d278 1
a278 1
	  if (unconfigured && input_file->will_search_for())
d453 1
a453 1
Add_symbols::run(Workqueue* workqueue)
d462 1
a462 15
  // If this file has an incompatible format, try for another file
  // with the same name.
  if (this->object_->searched_for()
      && !parameters->is_compatible_target(this->object_->target()))
    {
      Read_symbols::incompatible_warning(this->input_argument_,
					 this->object_->input_file());
      Read_symbols::requeue(workqueue, this->input_objects_, this->symtab_,
			    this->layout_, this->dirpath_, this->dirindex_,
			    this->mapfile_, this->input_argument_,
			    this->input_group_, this->next_blocker_);
      this->object_->release();
      delete this->object_;
    }
  else if (!this->input_objects_->add_object(this->object_))
@


1.37.4.1
log
@Merge elfcpp and gold from trunk.
@
text
@d269 1
a269 4
      bool unconfigured = false;
      bool* punconfigured = (input_file->will_search_for()
			     ? &unconfigured
			     : NULL);
d272 1
a272 1
				    punconfigured);
d275 1
a275 1
	  if (unconfigured)
a397 2
      else if (this->input_argument_->file().is_searched_file())
	ret += "-l:";
d450 1
a450 1
Add_symbols::run(Workqueue*)
d459 15
a473 1
  if (!this->input_objects_->add_object(this->object_))
a603 2
  else if (this->input_argument_->file().is_searched_file())
    ret += "-l:";
@


1.36
log
@	* object.cc (is_elf_object): Define.
	* object.h (is_elf_object): Declare.
	* archive.cc (Archive::get_elf_object_for_member): Call
	is_elf_object.
	* readsymc.cc (Read_symbols::do_read_symbols): Likewise.
@
text
@d36 2
d204 1
a204 1
      if (is_thin_archive 
d212 7
a218 1
	  
d291 6
@


1.35
log
@	* readsyms.cc (Read_symbols::incompatible_warning): New function.
	(Read_symbols::requeue): New function.
	(Read_symbols::do_read_symbols): If make_elf_object fails because
	the target type is not configured, and the file was searched for,
	issue a warning and retry with the next directory.
	(Add_symbols::run): If the file has an incompatible format, and
	it was searched for, requeue the Read_symbols task.  On error,
	release the object.
	* readsyms.h (class Read_symbols): Add dirindex_ field.  Add
	dirindex parameter to constructor.  Change all callers.  Declare
	incompatible_warning and requeue.
	(class Add_symbols): Add dirpath_, dirindex_, mapfile_,
	input_argument_ and input_group_ fields.  Add them to
	constructor.  Change all callers.
	(class Read_script): Add dirindex_ field.  Add it to constructor.
	Change all callers.
	* archive.cc (Archive::setup): Remove input_objects parameter.
	Change all callers.
	(Archive::get_file_and_offset): Likewise.
	(Archive::read_all_symbols): Likewise.
	(Archive::read_symbols): Likewise.
	(Archive::get_elf_object_for_member): Remove input_objects
	parameter.  Add punconfigured parameter.  Change all callers.
	(Archive::add_symbols): Change return type to bool.  Check return
	value of include_member.
	(Archive::include_all_members): Likewise.
	(Archive::include_member): Change return type to bool.  Return
	false if first included object has incompatible target.  Set
	included_member_ field.
	(Add_archive_symbols::run): If add_symbols returns false, requeue
	Read_symbols task.
	* archive.h (class Archive): Add included_member_ field.
	Initialize it in constructor.  Add input_file and searched_for
	methods.  Update declarations.
	(class Add_archive_symbols): Add dirpath_, dirindex_, and
	input_argument_ fields.  Add them to constructor.  Change all
	callers.
	* script.cc: Include "target-select.h".
	(class Parser_closure): Add skip_on_incompatible_target_ and
	found_incompatible_target_ fields.  Add
	skip_on_incompatible_target parameter to constructor.  Change all
	callers.  Add methods skip_on_incompatible_target,
	clear_skip_on_incompatible_target, found_incompatible_target, and
	set_found_incompatible_target.
	(read_input_script): Add dirindex parameter.  Change all callers.
	If parser finds an incompatible target, requeue Read_symbols
	task.
	(script_set_symbol): Clear skip_on_incompatible_target in
	closure.
	(script_add_assertion, script_parse_option): Likewise.
	(script_start_sections, script_add_phdr): Likewise.
	(script_check_output_format): New function.
	* script.h (read_input_script): Update declaration.
	* script-c.h (script_check_output_format): Declare.
	* yyscript.y (file_cmd): Handle OUTPUT_FORMAT.
	(ignore_cmd): Remove OUTPUT_FORMAT.
	* fileread.cc (Input_file::Input_file): Add explicit this.
	(Input_file::will_search_for): New function.
	(Input_file::open): Add pindex parameter.  Change all callers.
	* fileread.h (class Input_file): Add input_file_argument method.
	Declare will_search_for.  Update declarations.
	* object.cc (make_elf_object): Add punconfigured parameter.
	Change all callers.
	* object.h (class Object): Make input_file public.  Add
	searched_for method.
	(make_elf_object): Update declaration.
	* dirsearch.cc (Dirsearch::find): Add pindex parameter.  Use it to
	restart search.
	* dirsearch.h (class Dirsearch): Update declaration.
	* options.h (class General_options): Add --warn-search-mismatch.
	* parameters.cc (Parameters::is_compatible_target): New function.
	* parameters.h (class Parameters): Declare is_compatible_target.
	* workqueue.cc (Workqueue::add_blocker): New function.
	* workqueue.h (class Workqueue): Declare add_blocker.
@
text
@d194 3
a196 6
  int read_size = elfcpp::Elf_sizes<64>::ehdr_size;
  if (filesize < read_size)
    read_size = filesize;

  const unsigned char* ehdr = input_file->file().get_view(0, 0, read_size,
							  true, false);
d257 1
a257 1
  if (read_size >= 4)
d259 7
a265 1
      static unsigned char elfmagic[4] =
d267 1
a267 12
	  elfcpp::ELFMAG0, elfcpp::ELFMAG1,
	  elfcpp::ELFMAG2, elfcpp::ELFMAG3
	};
      if (memcmp(ehdr, elfmagic, 4) == 0)
	{
	  // This is an ELF object.

	  bool unconfigured;
	  Object* obj = make_elf_object(input_file->filename(),
					input_file, 0, ehdr, read_size,
					&unconfigured);
	  if (obj == NULL)
d269 7
a275 11
	      if (unconfigured && input_file->will_search_for())
		{
		  Read_symbols::incompatible_warning(this->input_argument_,
						     input_file);
		  input_file->file().release();
		  input_file->file().unlock(this);
		  delete input_file;
		  ++this->dirindex_;
		  return this->do_read_symbols(workqueue);
		}
	      return false;
d277 2
d280 2
a281 10
	  Read_symbols_data* sd = new Read_symbols_data;
	  obj->read_symbols(sd);

	  // Opening the file locked it, so now we need to unlock it.
	  // We need to unlock it before queuing the Add_symbols task,
	  // because the workqueue doesn't know about our lock on the
	  // file.  If we queue the Add_symbols task first, it will be
	  // stuck on the end of the file lock, but since the
	  // workqueue doesn't know about that lock, it will never
	  // release the Add_symbols task.
d283 24
a306 1
	  input_file->file().unlock(this);
d308 1
a308 17
	  // We use queue_next because everything is cached for this
	  // task to run right away if possible.

	  workqueue->queue_next(new Add_symbols(this->input_objects_,
						this->symtab_, this->layout_,
						this->dirpath_,
						this->dirindex_,
						this->mapfile_,
						this->input_argument_,
						this->input_group_,
						obj,
						sd,
						this->this_blocker_,
						this->next_blocker_));

	  return true;
	}
@


1.34
log
@	* fileread.cc (Input_file::open): Remove options parameter.
	Change all callers.
	(Input_file::open_binary): Likewise.
	* script.cc (read_input_script): Likewise.
	* readsyms.h (class Read_symbols): Remove options_ field.  Remove
	options parameter from constructor.  Change all callers.
	(class Read_script): Likewise.
	* fileread.h (class Input_file): Update declarations.
	* script.h (read_input_script): Update declaration.
@
text
@d93 38
d180 1
a180 1
  if (!input_file->open(*this->dirpath_, this))
d212 1
a212 1
	  arch->setup(this->input_objects_);
d220 2
d223 1
d247 7
a253 1
                                                obj, NULL,
d271 1
d273 2
a274 1
					input_file, 0, ehdr, read_size);
d276 13
a288 1
	    return false;
d308 7
a314 1
						obj, sd,
d331 1
d368 2
a369 2
					     this->dirpath_, this->mapfile_,
					     arg, input_group,
d447 1
a447 1
Add_symbols::run(Workqueue*)
d456 15
a470 1
  if (!this->input_objects_->add_object(this->object_))
d472 1
a472 1
      // FIXME: We need to close the descriptor here.
d575 1
a575 1
			 this->dirpath_, this->input_objects_,
@


1.33
log
@	(From Rafael Espindola)
	* archive.cc (Archive::include_member): Update calls to add_symbols.
	* dynobj.cc (Sized_dynobj<size, big_endian>::make_version_map): Add
	the Layout argument.
	* dynobj.h (do_add_symbols): Add the Layout argument.
	* object.cc (Sized_relobj<size, big_endian>::do_add_symbols): Add the
	Layout argument.
	* object.h (Object::add_symbols): Add the Layout argument.
	(Object::do_add_symbols): Add the Layout argument.
	(Sized_relobj::do_add_symbols): Add the Layout argument.
	* plugin.cc (Sized_pluginobj<size, big_endian>::do_add_symbols):
	Unify the two versions.
	(Add_plugin_symbols): Remove.
	* plugin.h (Pluginobj::add_symbols, Pluginobj::do_add_symbols): Remove.
	(Sized_pluginobj::do_add_symbols): Unify the two versions.
	(Add_plugin_symbols): Remove.
	* readsyms.cc (Read_symbols::do_read_symbols): Update call to
	Add_symbols. Use Add_symbols instead of Add_plugin_symbols.
	(Add_symbols::run): Make it work with Pulginobj.
@
text
@d142 1
a142 1
  if (!input_file->open(this->options_, *this->dirpath_, this))
d261 1
a261 2
  workqueue->queue_soon(new Read_script(this->options_,
					this->symtab_,
d298 1
a298 2
      workqueue->queue_soon(new Read_symbols(this->options_,
					     this->input_objects_,
d492 2
a493 2
  if (!read_input_script(workqueue, this->options_, this->symtab_,
			 this->layout_, this->dirpath_, this->input_objects_,
@


1.32
log
@	* archive.cc (Archive::get_elf_object_for_member): Remove call
	to File_read::claim_for_plugin.
	* descriptors.cc (Descriptors::open): Remove reference to
	is_claimed.
	(Descriptors::claim_for_plugin): Remove.
	* descriptors.h (Descriptors::claim_for_plugin): Remove.
	(Descriptors::is_claimed): Remove.
	(claim_descriptor_for_plugin): Remove.
	* fileread.cc (File_read::claim_for_plugin): Remove.
	* fileread.h (File_read::claim_for_plugin): Remove.
	(File_read::descriptor): Reopen descriptor if necessary.
	* plugin.cc  (Plugin::load): Add two new APIs to transfer vector.
	(Plugin_manager::all_symbols_read): Add task parameter. Change
	all callers.
	(Plugin_manager::get_input_file): New function.
	(Plugin_manager::release_input_file): New function.
	(Pluginobj::Pluginobj): Add filesize parameter and initialize
	corresponding data member.
	(Sized_pluginobj::Sized_pluginobj): Add filesize parameter
	and pass to base constructor. Change all callers.
	(get_input_file, release_input_file): New functions.
	(make_sized_plugin_object): Add filesize parameter. Change all callers.
	* plugin.h (Plugin_manager::Plugin_manager): Initialize task_ member.
	(Plugin_manager::all_symbols_read): Add task parameter.
	(Plugin_manager::get_input_file): New function.
	(Plugin_manager::release_input_file): New function.
	(Plugin_manager::task_): New data member.
	(Pluginobj::Pluginobj): Add filesize parameter.
	(Pluginobj::filename): New function.
	(Pluginobj::descriptor): New function.
	(Pluginobj::filesize): New function.
	(Pluginobj::filesize_): New data member.
	(Sized_pluginobj::Sized_pluginobj): Add filesize parameter.
	* readsyms.cc (Read_symbols::do_read_symbols): Remove call to
	File_read::claim_for_plugin; use Object::unlock to unlock the file.

	* testsuite/Makefile.am (plugin_test_4): New test case for plugins
	with archive libraries.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_test.c (struct sym_info): New type.
	(get_input_file, release_input_file): New static variables.
	(onload): Capture new transfer vector entries.
	(claim_file_hook): Stop reading at end of file according to filesize.
	Factor out parsing of readelf output into separate function.
	(all_symbols_read_hook): Exercise get_input_file and release_input_file
	APIs and get the source file name from the symbol table.  Convert
	source file name to corresponding object file name.  Print info
	message when adding new input files.
	(parse_readelf_line): New function.
	* testsuite/plugin_test_1.sh: Add checks for new info messages.
	* testsuite/plugin_test_2.sh: Likewise.
	* testsuite/plugin_test_3.sh: Likewise.
	* testsuite/plugin_test_4.sh: New test case.
@
text
@d203 6
a208 5
          workqueue->queue_next(new Add_plugin_symbols(this->symtab_,
                                                       this->layout_,
                                                       obj,
                                                       this->this_blocker_,
                                                       this->next_blocker_));
d383 7
d398 1
a398 1
      this->object_->add_symbols(this->symtab_, this->sd_);
@


1.31
log
@Add plugin functionality for link-time optimization (LTO).

include/:
	* plugin-api.h: New file.

gold/:
	* configure.ac (plugins): Add --enable-plugins option.
	* configure: Regenerate.
	* config.in: Regenerate.
	* Makefile.am (LIBDL): New variable.
	(CCFILES): Add plugin.cc.
	(HFILES): Add plugin.h.
	(ldadd_var): Add LIBDL.
	* Makefile.in: Regenerate.

	* archive.cc: Include "plugin.h".
	(Archive::setup): Don't preread archive symbols when using a plugin.
	(Archive::get_file_and_offset): Add memsize parameter.  Change callers.
	(Archive::get_elf_object_for_member): Call plugin hooks for claiming
	files.
	(Archive::include_member): Add symbols from plugin objects.
	* archive.h (Archive::get_file_and_offset): Add memsize parameter.
	* descriptors.cc (Descriptors::open): Check for file descriptors
	abandoned by plugins.
	(Descriptors::claim_for_plugin): New function.
	* descriptors.h (Descriptors::claim_for_plugin): New function.
	(Open_descriptor::is_claimed): New field.
	(claim_descriptor_for_plugin): New function.
	* fileread.cc (File_read::claim_for_plugin): New function.
	* fileread.h (File_read::claim_for_plugin): New function.
	(File_read::descriptor): New function.
	* gold.cc: Include "plugin.h".
	(queue_initial_tasks): Add task to call plugin hooks for generating
	new object files.
	* main.cc: Include "plugin.h".
	(main): Load plugin libraries.
	* object.h (Pluginobj): Declare.
	(Object::pluginobj): New function.
	(Object::do_pluginobj): New function.
	(Object::set_target): New function.
	* options.cc: Include "plugin.h".
	(General_options::parse_plugin): New function.
	(General_options::General_options): Initialize plugins_ field.
	(General_options::add_plugin): New function.
	* options.h (Plugin_manager): Declare.
	(General_options): Add --plugin option.
	(General_options::has_plugins): New function.
	(General_options::plugins): New function.
	(General_options::add_plugin): New function.
	(General_options::plugins_): New field.
	* plugin.cc: New file.
	* plugin.h: New file.
	* readsyms.cc: Include "plugin.h".
	(Read_symbols::do_read_symbols): Check for archive before checking
	for ELF file.  Call plugin hooks to claim files.
	* resolve.cc (Symbol_table::resolve): Record when symbol is referenced
	from a real object file; force override when processing replacement
	files.
	* symtab.cc (Symbol::init_fields): Initialize in_real_elf_ field.
	(Symbol::init_base_object): Likewise.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): Likewise.
	(Symbol::output_section): Assert that object is not a plugin.
	(Symbol_table::add_from_pluginobj): New function.
	(Symbol_table::sized_finalize_symbol): Treat symbols from plugins as
	undefined.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::add_from_pluginobj): Instantiate template.
	* symtab.h (Sized_pluginobj): Declare.
	(Symbol::in_real_elf): New function.
	(Symbol::set_in_real_elf): New function.
	(Symbol::in_real_elf_): New field.
	(Symbol_table::add_from_pluginobj): New function.

	* testsuite/Makefile.am (AM_CFLAGS): New variable.
	(LIBDL): New variable.
	(LDADD): Add LIBDL.
	(check_PROGRAMS): Add plugin_test_1 and plugin_test_2.
	(check_SCRIPTS): Add plugin_test_1.sh and plugin_test_2.sh.
	(check_DATA): Add plugin_test_1.err and plugin_test_2.err.
	(MOSTLYCLEANFILES): Likewise.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_test.c: New file.
	* testsuite/plugin_test_1.sh: New file.
	* testsuite/plugin_test_2.sh: New file.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d199 4
a202 2
	  input_file->file().claim_for_plugin();
	  input_file->file().unlock(this);
@


1.30
log
@2008-08-06  Cary Coutant <ccoutant@@google.com>

	* archive.cc (Archive::total_archives, Archive::total_members)
	(Archive::total_members_loaded): New variables.
	(Archive::setup): Add parameter.  Add option to preread
	archive symbols.
	(Archive::read_armap): Add counter.
	(Archive::get_file_and_offset): New function.
	(Archive::get_elf_object_for_member): New function.
	(Archive::read_all_symbols): New function.
	(Archive::read_symbols): New function.
	(Archive::add_symbols): Add counters.
	(Archive::include_all_members): Use armap to find members if it's
	already built.
	(Archive::include_member): Skip reading symbols if already read.
	Factored code into Archive::get_file_and_offset and
	Archive::get_elf_object_for_member.  Changed call to
	Mapfile::report_include_archive_member.
	(Archive::print_stats): New function.
	* archive.h: Declare Object and Read_symbols_data classes.
	(Archive::Archive): Add initializers for new members.
	(Archive::setup): Add parameter.
	(Archive::print_stats): New function.
	(Archive::total_archives, Archive::total_members)
	(Archive::total_members_loaded): New variables.
	(Archive::get_file_and_offset): New function.
	(Archive::get_elf_object_for_member): New function.
	(Archive::read_all_symbols): New function.
	(Archive::read_symbols): New function.
	(Archive::Archive_member): New class.
	(Archive::members_): New member.
	(Archive::num_members_): New member.
	* main.cc: Include archive.h.
	(main): Call Archive::print_stats.
	* mapfile.cc (Mapfile::report_include_archive_member): Delete
	archive parameter; member_name is now the fully-decorated name.
	* mapfile.h (Mapfile::report_include_archive_member): Likewise.
	* options.h: (General_options): Add --preread-archive-symbols option.
	* readsyms.cc (Read_symbols::do_read_symbols): Change call to
	Archive::setup.
@
text
@d35 1
d163 47
a251 28
  if (read_size >= Archive::sarmag)
    {
      bool is_thin_archive
          = memcmp(ehdr, Archive::armagt, Archive::sarmag) == 0;
      if (is_thin_archive 
          || memcmp(ehdr, Archive::armag, Archive::sarmag) == 0)
	{
	  // This is an archive.
	  Archive* arch = new Archive(this->input_argument_->file().name(),
				      input_file, is_thin_archive,
				      this->dirpath_, this);
	  arch->setup(this->input_objects_);
	  
	  // Unlock the archive so it can be used in the next task.
	  arch->unlock(this);

	  workqueue->queue_next(new Add_archive_symbols(this->symtab_,
							this->layout_,
							this->input_objects_,
							this->mapfile_,
							arch,
							this->input_group_,
							this->this_blocker_,
							this->next_blocker_));
	  return true;
	}
    }

@


1.29
log
@	* mapfile.cc: New file.
	* mapfile.h: New file.
	* options.h (class General_options): Add -M/--print-map and -Map.
	* options.cc (General_options::finalize): Make -M equivalent to
	-Map -.
	* main.cc: Include <cstdio> and "mapfile.h".
	(main): Open mapfile if requested.
	* gold.cc (class Middle_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(queue_initial_tasks): Add mapfile parameter.  Change caller.
	(queue_middle_tasks): Likewise.
	* gold.h (queue_initial_tasks, queue_middle_tasks): Update
	declarations.
	* archive.cc: Include "mapfile.h".
	(Archive::add_symbols): Add mapfile parameter.  Change all
	callers.  Pass mapfile, symbol, and reason to include_member.
	(Archive::include_all_members): Add mapfile parameter.  Change all
	callers.
	(Archive::include_member): Add mapfile, sym, and why parameters.
	Change all callers.  Report inclusion to map file.
	* archive.h: Include "fileread.h".
	(class Archive): Update declarations.
	(Archive::file): New const method.
	(class Add_archive_symbols): Add mapfile_ field.  Update
	constructor.  Change all callers.
	* readsyms.h (class Read_symbols): Likewise.
	(class Finish_group): Likewise.
	(class Read_script): Likewise.
	* common.cc: Include "mapfile.h".
	(Symbol_table::allocate_commons): Add mapfile parameter.  Change
	all callers.
	(Symbol_table::do_allocate_commons): Likewise.
	(Symbol_table::do_allocate_commons_list): Likewise.  Report common
	symbol allocation to mapfile.
	* common.h (class Allocate_commons_task): Add mapfile_ field.
	Update constructor.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* layout.cc: Include "mapfile.h".
	(Layout_task_runner::run): Print information to mapfile.
	(Layout::create_gold_note): Change Output_data_fixed_space to
	Output_data_zero_fill.
	(Layout::create_build_id): Likewise.
	(Layout::print_to_mapfile): New function.
	* layout.h (class Layout_task_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(class Layout): Declare print_to_mapfile.
	* output.cc (Output_section::Input_section::print_to_mapfile): New
	function.
	(Output_section::add_input_section): If producing a map, always
	add to input_sections_ list.
	(Output_section::do_print_to_mapfile): New function.
	(Output_segment::print_sections_to_mapfile): New function.
	(Output_segment::print_section_list_to_mapfile): New function.
	* output.h: Include "mapfile.h".
	(Output_data::print_to_mapfile): New function.
	(Output_data::do_print_to_mapfile): New virtual function.
	(Output_segment_headers::do_print_to_mapfile): New function.
	(Output_file_header::do_print_to_mapfile): New function.
	(Output_data_const::do_print_to_mapfile): New function.
	(class Output_data_const_buffer): Add map_name_ field.  Update
	constructor.  Change all callers.  Add do_print_to_mapfile
	function.
	(class Output_data_fixed_space): Likewise.
	(class Output_data_space): Likewise.
	(class Output_data_zero_fill): New class.
	(Output_data_strtab::do_print_to_mapfile): New function.
	(Output_data_reloc_base::do_print_to_mapfile): New function.
	(Output_relocatable_relocs::do_print_to_mapfile): New function.
	(Output_data_group::do_print_to_mapfile): New function.
	(Output_data_got::do_print_to_mapfile): New function.
	(Output_data_dynamic::do_print_to_mapfile): New function.
	(Output_symtab_xindex::do_print_to_mapfile): New function.
	(class Output_section): Declare do_print_to_mapflie.  Declare
	print_to_mapfile in Input_section.
	(class Output_segment): Declare new functions.
	* object.h (Sized_relobj::symbol_count): New function.
	* script-sections.cc
	(Output_section_element_dot_assignment::set_section_addresses):
	Change Output_data_fixed_space to Output_data_zero_fill.
	(Output_data_expression::do_print_to_mapfile): New function.
	* script.cc (read_input_script): Add mapfile parameter.  Change
	all callers.
	* script.h (read_input_script): Update declaration.
	* ehframe.h (Eh_frame_hdr::do_print_to_mapfile): New function.
	(Eh_frame::do_print_to_mapfile): New function.
	* merge.h (Output_merge_data::do_print_to_mapfile): New function.
	(Output_merge_string::do_print_to_mapfile): New function.
	* i386.cc (Output_data_plt_i386::do_print_to_mapfile): New
	function.
	* sparc.cc (Output_data_plt_sparc::do_print_to_mapfile): New
	function.
	* x86_64.cc (Output_data_plt_x86_64::do_print_to_mapfile): New
	function.
	* Makefile.am (CCFILES): Add mapfile.cc.
	(HFILES): Add mapfile.h.
	* Makefile.in: Rebuild.
@
text
@d215 1
a215 1
	  arch->setup();
@


1.28
log
@	* readsyms.cc (Read_symbols::do_read_symbols): Use get_view rather
	than read for file header.
	* archive.cc (Archive::include_member): Likewise.
@
text
@d223 1
d243 1
d279 2
a280 1
					     this->dirpath_, arg, input_group,
d289 1
d418 1
a418 1
			    this->input_objects_);
d466 3
a468 3
			 this->input_group_, this->input_argument_,
			 this->input_file_, this->next_blocker_,
			 &used_next_blocker))
@


1.27
log
@2008-03-31  Cary Coutant  <ccoutant@@google.com>

	Add thin archive support.
	* archive.cc (Archive::armagt): New const.
	(Archive::setup): Remove task parameter and calls to unlock.
	(Archive::unlock_nested_archives): New function.
	(Archive::read_header): Add nested_off parameter. Change
	all callers.
	(Archive::interpret_header): Likewise.
	(Archive::include_all_members): Change to handle thin
	archives.
	(Archive::include_member): Likewise.
	* archive.h (Archive::Archive): Add new parameters and
	initializers.
	(Archive::armagt): New const.
	(Archive::setup): Remove task parameter.
	(Archive::unlock_nested_archives): New function.
	(Archive::read_header): Add nested_off parameter.
	(Archive::interpret_header): Likewise.
	(Archive::Nested_archive_table): New typedef.
	(Archive::is_thin_archive_): New field.
	(Archive::nested_archives_): New field.
	(Archive::options_): New field.
	(Archive::dirpath_): New field.
	(Archive::task_): New field.
	* readsyms.cc (Read_symbols::do_read_symbols): Add check
	for thin archives.  Pass additional parameters to
	Archive::Archive.  Unlock the archive file after calling
	Archive::setup.
@
text
@a154 2
  unsigned char ehdr_buf[elfcpp::Elf_sizes<64>::ehdr_size];

d159 2
a160 1
  input_file->file().read(0, read_size, ehdr_buf);
d169 1
a169 1
      if (memcmp(ehdr_buf, elfmagic, 4) == 0)
d174 1
a174 1
					input_file, 0, ehdr_buf, read_size);
d207 1
a207 1
          = memcmp(ehdr_buf, Archive::armagt, Archive::sarmag) == 0;
d209 1
a209 1
          || memcmp(ehdr_buf, Archive::armag, Archive::sarmag) == 0)
@


1.26
log
@Update copyright years.  Update language files.
@
text
@d207 4
a210 1
      if (memcmp(ehdr_buf, Archive::armag, Archive::sarmag) == 0)
d214 6
a219 2
				      input_file);
	  arch->setup(this);
@


1.25
log
@Read input scripts which look like input objects with proper
serialization.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.24
log
@Permit ordinary object files in groups.
@
text
@d123 2
a124 2
    workqueue->queue_front(new Unblock_token(this->this_blocker_,
					     this->next_blocker_));
d192 8
a199 5
	  workqueue->queue_front(new Add_symbols(this->input_objects_,
						 this->symtab_, this->layout_,
						 obj, sd,
						 this->this_blocker_,
						 this->next_blocker_));
d214 7
a220 7
	  workqueue->queue_front(new Add_archive_symbols(this->symtab_,
							 this->layout_,
							 this->input_objects_,
							 arch,
							 this->input_group_,
							 this->this_blocker_,
							 this->next_blocker_));
d225 17
a241 13
  // Try to parse this file as a script.
  if (read_input_script(workqueue, this->options_, this->symtab_,
			this->layout_, this->dirpath_, this->input_objects_,
			this->input_group_, this->input_argument_, input_file,
			ehdr_buf, read_size, this->this_blocker_,
			this->next_blocker_))
    return true;

  // Here we have to handle any other input file types we need.
  gold_error(_("%s: not an object or archive"),
	     input_file->file().filename().c_str());

  return false;
d268 5
a272 4
      workqueue->queue(new Read_symbols(this->options_, this->input_objects_,
					this->symtab_, this->layout_,
					this->dirpath_, arg, input_group,
					this_blocker, next_blocker));
d277 7
a283 7
  workqueue->queue(new Finish_group(this->input_objects_,
				    this->symtab_,
				    this->layout_,
				    input_group,
				    saw_undefined,
				    this_blocker,
				    this->next_blocker_));
d418 65
@


1.23
log
@Rewrite workqueue.  This version eliminates the master thread, and
reduces the amount of locking required to find a new thread to run.
@
text
@a178 11
	  // We don't have a way to record a non-archive in an input
	  // group.  If this is an ordinary object file, we can't
	  // include it more than once anyhow.  If this is a dynamic
	  // object, then including it a second time changes nothing.
	  if (this->input_group_ != NULL && !obj->is_dynamic())
	    {
	      gold_error(_("%s: ordinary object found in input group"),
			 input_file->name());
	      return false;
	    }

@


1.22
log
@Add threading support.
@
text
@d42 3
a44 3
// unblock tokens in the main thread, so we need a dummy task to do
// that.  The dummy task has to maintain the right sequence of blocks,
// so we need both this_blocker and next_blocker.
d59 2
a60 2
  Is_runnable_type
  is_runnable(Workqueue*)
d63 2
a64 2
      return IS_BLOCKED;
    return IS_RUNNABLE;
d67 3
a69 3
  Task_locker*
  locks(Workqueue* workqueue)
  { return new Task_locker_block(*this->next_blocker_, workqueue); }
d96 2
a97 2
Task::Is_runnable_type
Read_symbols::is_runnable(Workqueue*)
d101 2
a102 2
      && this->dirpath_.token().is_blocked())
    return IS_BLOCKED;
d104 1
a104 1
  return IS_RUNNABLE;
d110 2
a111 2
Task_locker*
Read_symbols::locks(Workqueue*)
a112 1
  return NULL;
d141 1
a141 1
  if (!input_file->open(this->options_, this->dirpath_))
d192 11
a208 3
	  // Opening the file locked it, so now we need to unlock it.
	  input_file->file().unlock();

d220 9
a228 8
	  arch->setup();
	  workqueue->queue(new Add_archive_symbols(this->symtab_,
						   this->layout_,
						   this->input_objects_,
						   arch,
						   this->input_group_,
						   this->this_blocker_,
						   this->next_blocker_));
d262 1
d270 1
a270 1
      Task_token* next_blocker = new Task_token();
d331 2
a332 2
Task::Is_runnable_type
Add_symbols::is_runnable(Workqueue*)
d335 1
a335 1
    return IS_BLOCKED;
d337 2
a338 2
    return IS_LOCKED;
  return IS_RUNNABLE;
d341 2
a342 1
class Add_symbols::Add_symbols_locker : public Task_locker
d344 2
a345 16
 public:
  Add_symbols_locker(Task_token& token, Workqueue* workqueue,
		     Object* object)
    : blocker_(token, workqueue), objlock_(*object)
  { }

 private:
  Task_locker_block blocker_;
  Task_locker_obj<Object> objlock_;
};

Task_locker*
Add_symbols::locks(Workqueue* workqueue)
{
  return new Add_symbols_locker(*this->next_blocker_, workqueue,
				this->object_);
d362 1
d380 2
a381 2
Task::Is_runnable_type
Finish_group::is_runnable(Workqueue*)
d384 2
a385 2
    return IS_BLOCKED;
  return IS_RUNNABLE;
d388 2
a389 2
Task_locker*
Finish_group::locks(Workqueue* workqueue)
d391 1
a391 1
  return new Task_locker_block(*this->next_blocker_, workqueue);
d408 1
a408 1
	  Task_lock_obj<Archive> tl(**p);
@


1.21
log
@Correct locking if a file could not be opened.
@
text
@d75 4
d278 29
@


1.20
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d39 41
d112 1
a112 2
// Run a Read_symbols task.  This is where we actually read the
// symbols and relocations.
d117 13
d134 1
a134 1
      return;
d139 1
a139 1
    return;
d149 1
a149 1
      return;
d174 1
a174 1
	    return;
d184 1
a184 1
	      return;
d198 1
a198 1
	  return;
d217 1
a217 1
	  return;
d227 1
a227 1
    return;
d232 2
@


1.19
log
@From Craig Silverstein: add support for searching for input files
named in linker scripts.
@
text
@d85 2
a86 1
  input_file->open(this->options_, this->dirpath_);
d94 3
a96 3
      fprintf(stderr, _("%s: %s: file is empty\n"),
	      program_name, input_file->file().filename().c_str());
      gold_exit(false);
d120 2
d129 3
a131 4
	      fprintf(stderr,
		      _("%s: %s: ordinary object found in input group\n"),
		      program_name, input_file->name());
	      gold_exit(false);
d177 2
a178 3
  fprintf(stderr, _("%s: %s: not an object or archive\n"),
	  program_name, input_file->file().filename().c_str());
  gold_exit(false);
@


1.18
log
@Rework File_read interface.  Get file size.  Use pread when
available.
@
text
@d55 1
a55 1
      && this->input_argument_->file().is_lib()
@


1.17
log
@Remove get_view_and_size.
@
text
@d89 1
a89 4
  const int ehdr_size = elfcpp::Elf_sizes<64>::ehdr_size;
  unsigned char ehdr_buf[ehdr_size];
  off_t bytes;
  input_file->file().read_up_to(0, ehdr_size, ehdr_buf, &bytes);
d91 16
a106 1
  if (bytes >= 4)
d118 1
a118 1
					input_file, 0, ehdr_buf, bytes);
d147 1
a147 1
  if (bytes >= Archive::sarmag)
a165 7
  if (bytes == 0)
    {
      fprintf(stderr, _("%s: %s: file is empty\n"),
	      program_name, input_file->file().filename().c_str());
      gold_exit(false);
    }

d170 1
a170 1
			ehdr_buf, bytes, this->this_blocker_,
@


1.16
log
@Break out default pbytes argument to read and get_view routines,
adding new routines.
@
text
@d89 2
a90 1
  int ehdr_size = elfcpp::Elf_sizes<64>::ehdr_size;
d92 2
a93 2
  const unsigned char* p = input_file->file().get_view_and_size(0, ehdr_size,
								&bytes);
d101 1
a101 1
      if (memcmp(p, elfmagic, 4) == 0)
d106 1
a106 1
					input_file, 0, p, bytes);
d137 1
a137 1
      if (memcmp(p, Archive::armag, Archive::sarmag) == 0)
d165 2
a166 1
			p, bytes, this->this_blocker_, this->next_blocker_))
@


1.15
log
@Add licensing text to every source file.
@
text
@d91 2
a92 1
  const unsigned char* p = input_file->file().get_view(0, ehdr_size, &bytes);
@


1.14
log
@Add global parameters.
@
text
@d3 20
@


1.13
log
@Don't emit symbols seen only in dynamic object, don't read duplicate
dynamic object.
@
text
@d100 1
a100 2
	  workqueue->queue_front(new Add_symbols(this->options_,
						 this->input_objects_,
d121 1
a121 2
	  workqueue->queue(new Add_archive_symbols(this->options_,
						   this->symtab_,
d183 1
a183 2
  workqueue->queue(new Finish_group(this->options_,
				    this->input_objects_,
d247 1
a247 2
      this->object_->layout(this->options_, this->symtab_, this->layout_,
			    this->sd_);
d296 1
a296 1
	  (*p)->add_symbols(this->options_, this->symtab_, this->layout_,
@


1.12
log
@Added a testsuite.  More support for COPY relocations.
@
text
@d243 11
a253 4
  this->input_objects_->add_object(this->object_);
  this->object_->layout(this->options_, this->symtab_, this->layout_,
			this->sd_);
  this->object_->add_symbols(this->symtab_, this->sd_);
@


1.11
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d64 1
a64 1
  Input_file* input_file = new Input_file(this->input_argument_->file());
@


1.10
log
@More dynamic object support, initial scripting support.
@
text
@d59 1
a59 1
      assert(this->input_group_ == NULL);
d173 1
a173 1
      assert(arg->is_file());
@


1.9
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@d13 1
d34 2
a35 2
  if (this->input_.is_file()
      && this->input_.file().is_lib()
d57 1
a57 1
  if (this->input_.is_group())
d64 1
a64 1
  Input_file* input_file = new Input_file(this->input_.file());
d83 8
a90 1
	  if (this->input_group_ != NULL)
a97 3
	  Object* obj = make_elf_object(this->input_.file().name(),
					input_file, 0, p, bytes);

d119 2
a120 1
	  Archive* arch = new Archive(this->input_.file().name(), input_file);
d134 14
d166 1
a166 1
  const Input_file_group* group = this->input_.group();
d172 2
a173 2
      const Input_argument& arg(*p);
      assert(arg.is_file());
@


1.8
log
@Can now do a full static link of hello, world in C or C++
@
text
@d10 1
d95 2
a96 1
	  workqueue->queue_front(new Add_symbols(this->input_objects_,
d116 2
a117 1
	  workqueue->queue(new Add_archive_symbols(this->symtab_,
d165 2
a166 1
  workqueue->queue(new Finish_group(this->input_objects_,
d224 2
a225 1
  this->object_->layout(this->layout_, this->sd_);
d273 1
a273 1
	  (*p)->add_symbols(this->symtab_, this->layout_,
@


1.7
log
@Framework for relocation scanning.  Implement simple static TLS
relocations.
@
text
@d25 3
a27 4
// Return whether a Read_symbols task is runnable.  We need write
// access to the symbol table.  We can read an ordinary input file
// immediately.  For an archive specified using -l, we have to wait
// until the search path is complete.
d32 3
a34 1
  if (this->input_.is_lib() && this->dirpath_.token().is_blocked())
d55 8
a62 1
  Input_file* input_file = new Input_file(this->input_);
a79 2
	  Object* obj = make_elf_object(this->input_.name(), input_file, 0,
					p, bytes);
d81 10
a90 1
	  this->input_objects_->add_object(obj);
d94 2
a95 1
	  workqueue->queue_front(new Add_symbols(this->symtab_, this->layout_,
d112 1
a112 1
	  Archive* arch = new Archive(this->input_.name(), input_file);
d118 1
d131 40
d214 2
d219 1
d224 55
@


1.6
log
@Lay out object file sections when we add the symbols to the symbol
table.
@
text
@d79 4
a82 4
	  workqueue->queue(new Add_symbols(this->symtab_, this->layout_,
					   obj, sd,
					   this->this_blocker_,
					   this->next_blocker_));
d108 1
a108 2
  // Here we have to handle archives and any other input file
  // types we need.
@


1.5
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d77 4
a80 2
	  Read_symbols_data sd = obj->read_symbols();
	  workqueue->queue(new Add_symbols(this->symtab_, obj, sd,
d99 1
d161 1
d163 2
@


1.4
log
@More section layout code.
@
text
@d10 2
a12 1
#include "object.h"
d89 16
d107 3
a109 1
  gold_fatal("only objects are currently supported", false);
@


1.3
log
@New drop, with first cut of section layout code.
@
text
@d74 1
a74 1
	  this->input_objects_->push_back(obj);
@


1.2
log
@Another snapshot of the current state of the sources.  Gets to the
point of symbol resolution and can now issue a multiple definition
error.  Also added target selection infrastructure.
@
text
@d11 1
a52 2
  // We don't keep track of Input_file objects, so this is a memory
  // leak.
d73 3
a75 1
					
d103 2
a104 1
// We are blocked by this_blocker_.  We block next_blocker_.
d111 2
d116 13
d132 2
a133 1
  return new Task_locker_block(*this->next_blocker_, workqueue);
@


1.1
log
@Initial CVS checkin of gold
@
text
@d76 2
a77 1
	  workqueue->queue(new Add_symbols(obj, sd, this->this_blocker_,
d121 1
a121 1
  this->object_->add_symbols(this->sd_);
@

