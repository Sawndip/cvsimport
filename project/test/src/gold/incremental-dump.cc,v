head	1.20;
access;
symbols
	binutils-2_24-branch:1.20.0.4
	binutils-2_24-branchpoint:1.20
	binutils-2_21_1:1.8
	binutils-2_23_2:1.20
	binutils-2_23_1:1.20
	binutils-2_23:1.20
	binutils-2_23-branch:1.20.0.2
	binutils-2_23-branchpoint:1.20
	binutils-2_22_branch:1.19.0.4
	binutils-2_22:1.19
	binutils-2_22-branch:1.19.0.2
	binutils-2_22-branchpoint:1.19
	binutils-2_21:1.8
	binutils-2_21-branch:1.8.0.2
	binutils-2_21-branchpoint:1.8
	binutils_latest_snapshot:1.20;
locks; strict;
comment	@// @;


1.20
date	2012.04.24.22.05.28;	author ccoutant;	state Exp;
branches;
next	1.19;

1.19
date	2011.06.08.04.05.24;	author ccoutant;	state Exp;
branches;
next	1.18;

1.18
date	2011.06.08.03.50.10;	author ccoutant;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.26.18.44.26;	author ccoutant;	state Exp;
branches;
next	1.16;

1.16
date	2011.05.24.23.31.07;	author ccoutant;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.24.21.57.28;	author ccoutant;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.13;

1.13
date	2011.05.23.23.27.10;	author ccoutant;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.25.20.28.48;	author ccoutant;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.12.00.44.47;	author ccoutant;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.05.20.16.17;	author ccoutant;	state Exp;
branches;
next	1.9;

1.9
date	2011.03.30.21.07.13;	author ccoutant;	state Exp;
branches;
next	1.8;

1.8
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2010.08.12.22.14.59;	author ccoutant;	state Exp;
branches;
next	1.6;

1.6
date	2010.08.12.22.01.11;	author ccoutant;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.07.21.36.52;	author espindola;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.02.16.27.15;	author espindola;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.01.21.15.06;	author espindola;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.27.16.15.26;	author espindola;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.25.00.10.05;	author espindola;	state Exp;
branches;
next	;


desc
@@


1.20
log
@	* incremental-dump.cc (find_input_containing_global): Replace
	magic number with symbolic constant.
	(dump_incremental_inputs): Update version number.
	* incremental.cc (Output_section_incremental_inputs): Update version
	number; import symbolic constants from Incremental_inputs_reader.
	(Incremental_inputs::create_data_sections): Align relocations
	section correctly for 64-bit targets.
	(Output_section_incremental_inputs::set_final_data_size): Use symbolic
	constants; add padding.
	(Output_section_incremental_inputs::write_header): Add assert for
	header_size.
	(Output_section_incremental_inputs::write_input_files): Add assert
	for input_entry_size.
	(Output_section_incremental_inputs::write_info_blocks): Add padding;
	add assert for object_info_size, input_section_entry_size,
	global_sym_entry_size.
	* incremental.h (Incremental_inputs_reader): Add symbolic constants
	for data structure sizes; use them.
	(Incremental_input_entry_reader): Import symbolic constants from
	Incremental_inputs_reader; use them.
@
text
@// incremental.cc -- incremental linking test/debug tool

// Copyright 2009, 2010 Free Software Foundation, Inc.
// Written by Rafael Avila de Espindola <rafael.espindola@@gmail.com>

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.


// This file is a (still incomplete) test/debug tool that should display
// all information available in the incremental linking sections in a
// format that is easy to read.
// Once the format is a bit more stable, this should probably be moved to
// readelf. Because of that, the use of gold's data structures and functions
// is just a short term convenience and not a design decision.

#include "gold.h"

#include <stdio.h>
#include <errno.h>
#include <time.h>

#include "incremental.h"

namespace gold
{
  class Output_file;
}

using namespace gold;

template<int size, bool big_endian>
static typename Incremental_inputs_reader<size, big_endian>::
    Incremental_input_entry_reader
find_input_containing_global(
    Incremental_inputs_reader<size, big_endian>& incremental_inputs,
    unsigned int offset,
    unsigned int* symndx)
{
  typedef Incremental_inputs_reader<size, big_endian> Inputs_reader;
  static const unsigned int global_sym_entry_size =
      Incremental_inputs_reader<size, big_endian>::global_sym_entry_size;

  for (unsigned int i = 0; i < incremental_inputs.input_file_count(); ++i)
    {
      typename Inputs_reader::Incremental_input_entry_reader input_file =
	  incremental_inputs.input_file(i);
      if (input_file.type() != INCREMENTAL_INPUT_OBJECT
          && input_file.type() != INCREMENTAL_INPUT_ARCHIVE_MEMBER)
        continue;
      unsigned int nsyms = input_file.get_global_symbol_count();
      if (offset >= input_file.get_symbol_offset(0)
          && offset < input_file.get_symbol_offset(nsyms))
	{
	  *symndx = ((offset - input_file.get_symbol_offset(0))
		     / global_sym_entry_size);
	  return input_file;
	}
    }
  gold_unreachable();
}

template<int size, bool big_endian>
static void
dump_incremental_inputs(const char* argv0, const char* filename,
			Sized_incremental_binary<size, big_endian>* inc)
{
  typedef Incremental_binary::Location Location;
  typedef Incremental_binary::View View;
  typedef Incremental_inputs_reader<size, big_endian> Inputs_reader;
  typedef typename Inputs_reader::Incremental_input_entry_reader Entry_reader;

  if (!inc->has_incremental_info())
    {
      fprintf(stderr, "%s: %s: no .gnu_incremental_inputs section\n", argv0,
              filename);
      exit(1);
    }

  // Create a reader object for the .gnu_incremental_inputs section.

  Incremental_inputs_reader<size, big_endian>
      incremental_inputs(inc->inputs_reader());

  if (incremental_inputs.version() != 2)
    {
      fprintf(stderr, "%s: %s: unknown incremental version %d\n", argv0,
              filename, incremental_inputs.version());
      exit(1);
    }

  const char* command_line = incremental_inputs.command_line();
  if (command_line == NULL)
    {
      fprintf(stderr,
              "%s: %s: failed to get link command line\n",
              argv0, filename);
      exit(1);
    }
  printf("Link command line: %s\n", command_line);

  printf("\nInput files:\n");
  for (unsigned int i = 0; i < incremental_inputs.input_file_count(); ++i)
    {
      Entry_reader input_file = incremental_inputs.input_file(i);

      const char* objname = input_file.filename();
      if (objname == NULL)
	{
	  fprintf(stderr,"%s: %s: failed to get file name for object %u\n",
		  argv0, filename, i);
	  exit(1);
	}
      printf("[%d] %s\n", i, objname);

      Timespec mtime = input_file.get_mtime();
      printf("    Timestamp: %llu.%09d  %s",
	     static_cast<unsigned long long>(mtime.seconds),
	     mtime.nanoseconds,
	     ctime(&mtime.seconds));

      printf("    Serial Number: %d\n", input_file.arg_serial());
      printf("    In System Directory: %s\n",
	     input_file.is_in_system_directory() ? "true" : "false");

      Incremental_input_type input_type = input_file.type();
      printf("    Type: ");
      switch (input_type)
	{
	case INCREMENTAL_INPUT_OBJECT:
	case INCREMENTAL_INPUT_ARCHIVE_MEMBER:
	  printf("%s\n", (input_type == INCREMENTAL_INPUT_OBJECT
			  ? "Object" : "Archive member"));
	  printf("    Input section count: %d\n",
		 input_file.get_input_section_count());
	  printf("    Global symbol count: %d\n",
		 input_file.get_global_symbol_count());
	  printf("    Local symbol offset: %d\n",
		 input_file.get_local_symbol_offset());
	  printf("    Local symbol count: %d\n",
		 input_file.get_local_symbol_count());
	  printf("    First dynamic reloc: %d\n",
		 input_file.get_first_dyn_reloc());
	  printf("    Dynamic reloc count: %d\n",
		 input_file.get_dyn_reloc_count());
	  printf("    COMDAT group count: %d\n",
		 input_file.get_comdat_group_count());
	  break;
	case INCREMENTAL_INPUT_ARCHIVE:
	  printf("Archive\n");
	  printf("    Member count: %d\n", input_file.get_member_count());
	  printf("    Unused symbol count: %d\n",
		 input_file.get_unused_symbol_count());
	  break;
	case INCREMENTAL_INPUT_SHARED_LIBRARY:
	  printf("Shared library\n");
	  printf("    As needed: %s\n",
		 input_file.as_needed() ? "true" : "false");
	  printf("    soname: %s\n",
		 input_file.get_soname());
	  printf("    Symbol count: %d\n",
		 input_file.get_global_symbol_count());
	  break;
	case INCREMENTAL_INPUT_SCRIPT:
	  printf("Linker script\n");
	  printf("    Object count: %d\n", input_file.get_object_count());
	  break;
	default:
	  fprintf(stderr, "%s: invalid file type for object %u: %d\n",
		  argv0, i, input_type);
	  exit(1);
	}
    }

  printf("\nInput sections:\n");
  for (unsigned int i = 0; i < incremental_inputs.input_file_count(); ++i)
    {
      Entry_reader input_file(incremental_inputs.input_file(i));

      if (input_file.type() != INCREMENTAL_INPUT_OBJECT
	  && input_file.type() != INCREMENTAL_INPUT_ARCHIVE_MEMBER)
	continue;

      const char* objname = input_file.filename();
      if (objname == NULL)
	{
	  fprintf(stderr,"%s: %s: failed to get file name for object %u\n",
		  argv0, filename, i);
	  exit(1);
	}

      printf("[%d] %s\n", i, objname);

      printf("    %3s  %6s  %8s  %8s  %s\n",
	     "n", "outndx", "offset", "size", "name");
      unsigned int nsections = input_file.get_input_section_count();
      for (unsigned int shndx = 0; shndx < nsections; ++shndx)
	{
	  typename Entry_reader::Input_section_info info(
	      input_file.get_input_section(shndx));
	  printf("    %3d  %6d  %8lld  %8lld  %s\n", shndx + 1,
		 info.output_shndx,
		 static_cast<long long>(info.sh_offset),
		 static_cast<long long>(info.sh_size),
		 info.name);
	}

      unsigned int ncomdat = input_file.get_comdat_group_count();
      for (unsigned int i = 0; i < ncomdat; ++i)
	printf("    Comdat group: %s\n",
	       input_file.get_comdat_group_signature(i));
    }

  // Get a view of the .symtab section.

  elfcpp::Elf_file<size, big_endian, Incremental_binary> elf_file(inc);

  unsigned int symtab_shndx = elf_file.find_section_by_type(elfcpp::SHT_SYMTAB);
  if (symtab_shndx == elfcpp::SHN_UNDEF)  // Not found.
    {
      fprintf(stderr, "%s: %s: no symbol table section\n", argv0, filename);
      exit(1);
    }
  Location symtab_location(elf_file.section_contents(symtab_shndx));
  View symtab_view(inc->view(symtab_location));

  // Get a view of the .strtab section.

  unsigned int strtab_shndx = elf_file.section_link(symtab_shndx);
  if (strtab_shndx == elfcpp::SHN_UNDEF
      || strtab_shndx > elf_file.shnum()
      || elf_file.section_type(strtab_shndx) != elfcpp::SHT_STRTAB)
    {
      fprintf(stderr, "%s: %s: no string table section\n", argv0, filename);
      exit(1);
    }
  Location strtab_location(elf_file.section_contents(strtab_shndx));
  View strtab_view(inc->view(strtab_location));
  elfcpp::Elf_strtab strtab(strtab_view.data(), strtab_location.data_size);

  // The .gnu_incremental_symtab section contains entries that parallel
  // the global symbols of the main symbol table.  The sh_info field
  // of the main symbol table's section header tells us how many global
  // symbols there are, but that count does not include any global
  // symbols that were forced local during the link.  Therefore, we
  // use the size of the .gnu_incremental_symtab section to deduce
  // the number of global symbols + forced-local symbols there are
  // in the symbol table.
  Incremental_symtab_reader<big_endian> isymtab(inc->symtab_reader());
  Incremental_relocs_reader<size, big_endian> irelocs(inc->relocs_reader());
  unsigned int sym_size = elfcpp::Elf_sizes<size>::sym_size;
  unsigned int nsyms = symtab_location.data_size / sym_size;
  unsigned int nglobals = isymtab.symbol_count();
  unsigned int first_global = nsyms - nglobals;
  unsigned const char* sym_p;

  printf("\nGlobal symbols per input file:\n");
  for (unsigned int i = 0; i < incremental_inputs.input_file_count(); ++i)
    {
      Entry_reader input_file(incremental_inputs.input_file(i));

      if (input_file.type() != INCREMENTAL_INPUT_OBJECT
	  && input_file.type() != INCREMENTAL_INPUT_ARCHIVE_MEMBER
	  && input_file.type() != INCREMENTAL_INPUT_SHARED_LIBRARY)
	continue;

      const char* objname = input_file.filename();
      if (objname == NULL)
	{
	  fprintf(stderr,"%s: %s: failed to get file name for object %u\n",
		  argv0, filename, i);
	  exit(1);
	}

      printf("[%d] %s\n", i, objname);

      unsigned int nsyms = input_file.get_global_symbol_count();
      if (nsyms > 0)
	printf("    %6s  %6s  %8s  %8s  %8s  %8s\n",
	       "outndx", "shndx", "offset", "chain", "#relocs", "rbase");
      if (input_file.type() == INCREMENTAL_INPUT_SHARED_LIBRARY)
	{
	  for (unsigned int symndx = 0; symndx < nsyms; ++symndx)
	    {
	      bool is_def;
	      bool is_copy;
	      unsigned int output_symndx =
		  input_file.get_output_symbol_index(symndx, &is_def, &is_copy);
	      sym_p = symtab_view.data() + output_symndx * sym_size;
	      elfcpp::Sym<size, big_endian> sym(sym_p);
	      const char* symname;
	      if (!strtab.get_c_string(sym.get_st_name(), &symname))
		symname = "<unknown>";
	      printf("    %6d  %6s  %8s  %8s  %8s  %8s  %-5s  %s\n",
		     output_symndx,
		     "", "", "", "", "",
		     is_copy ? "COPY" : (is_def ? "DEF" : "UNDEF"),
		     symname);
	    }
	}
      else
	{
	  for (unsigned int symndx = 0; symndx < nsyms; ++symndx)
	    {
	      Incremental_global_symbol_reader<big_endian> info(
		  input_file.get_global_symbol_reader(symndx));
	      unsigned int output_symndx = info.output_symndx();
	      sym_p = symtab_view.data() + output_symndx * sym_size;
	      elfcpp::Sym<size, big_endian> sym(sym_p);
	      const char* symname;
	      if (!strtab.get_c_string(sym.get_st_name(), &symname))
		symname = "<unknown>";
	      printf("    %6d  %6d  %8d  %8d  %8d  %8d  %-5s  %s\n",
		     output_symndx,
		     info.shndx() == -1U ? -1 : info.shndx(),
		     input_file.get_symbol_offset(symndx),
		     info.next_offset(),
		     info.reloc_count(),
		     info.reloc_offset(),
		     (info.shndx() == -1U
		      ? "BASE"
		      : info.shndx() == 0 ? "UNDEF" : "DEF"),
		     symname);
	    }
	}
    }

  sym_p = symtab_view.data() + first_global * sym_size;
  printf("\nGlobal symbol table:\n");
  for (unsigned int i = 0; i < nglobals; i++)
    {
      elfcpp::Sym<size, big_endian> sym(sym_p);
      const char* symname;
      if (!strtab.get_c_string(sym.get_st_name(), &symname))
	symname = "<unknown>";
      printf("[%d] %s\n", first_global + i, symname);
      unsigned int offset = isymtab.get_list_head(i);
      while (offset > 0)
        {
	  unsigned int sym_ndx;
	  Entry_reader input_file =
	      find_input_containing_global<size, big_endian>(incremental_inputs,
							     offset, &sym_ndx);
	  Incremental_global_symbol_reader<big_endian> sym_info(
	      input_file.get_global_symbol_reader(sym_ndx));
	  printf("    %s (first reloc: %d, reloc count: %d)",
		 input_file.filename(), sym_info.reloc_offset(),
		 sym_info.reloc_count());
	  if (sym_info.output_symndx() != first_global + i)
	    printf(" ** wrong output symndx (%d) **", sym_info.output_symndx());
	  printf("\n");
	  // Dump the relocations from this input file for this symbol.
	  unsigned int r_off = sym_info.reloc_offset();
	  for (unsigned int j = 0; j < sym_info.reloc_count(); j++)
	    {
	      printf("      %4d  relocation type %3d  shndx %2d"
		     "  offset %016llx  addend %016llx  %s\n",
		     r_off,
		     irelocs.get_r_type(r_off),
		     irelocs.get_r_shndx(r_off),
		     static_cast<long long>(irelocs.get_r_offset(r_off)),
		     static_cast<long long>(irelocs.get_r_addend(r_off)),
		     symname);
	      r_off += irelocs.reloc_size;
	    }
	  offset = sym_info.next_offset();
	}
      sym_p += sym_size;
    }

  Incremental_got_plt_reader<big_endian> igot_plt(inc->got_plt_reader());
  unsigned int ngot = igot_plt.get_got_entry_count();
  unsigned int nplt = igot_plt.get_plt_entry_count();
  
  printf("\nGOT entries:\n");
  for (unsigned int i = 0; i < ngot; ++i)
    {
      unsigned int got_type = igot_plt.get_got_type(i);
      unsigned int got_symndx = igot_plt.get_got_symndx(i);
      unsigned int got_input_index = igot_plt.get_got_input_index(i);
      printf("[%d] type %02x, ", i, got_type & 0x7f);
      if ((got_type & 0x7f) == 0x7f)
	printf("reserved");
      else if (got_type & 0x80)
	{
	  Entry_reader input_file =
	      incremental_inputs.input_file(got_input_index);
	  const char* objname = input_file.filename();
	  printf("local: %s (%d)", objname, got_symndx);
	}
      else
	{
	  sym_p = symtab_view.data() + got_symndx * sym_size;
	  elfcpp::Sym<size, big_endian> sym(sym_p);
	  const char* symname;
	  if (!strtab.get_c_string(sym.get_st_name(), &symname))
	    symname = "<unknown>";
	  printf("global %s (%d)", symname, got_symndx);
	}
      printf("\n");
    }

  printf("\nPLT entries:\n");
  for (unsigned int i = 0; i < nplt; ++i)
    {
      unsigned int plt_desc = igot_plt.get_plt_desc(i);
      printf("[%d] ", i);
      sym_p = symtab_view.data() + plt_desc * sym_size;
      elfcpp::Sym<size, big_endian> sym(sym_p);
      const char* symname;
      if (!strtab.get_c_string(sym.get_st_name(), &symname))
	symname = "<unknown>";
      printf("%s (%d)\n", symname, plt_desc);
    }

  printf("\nUnused archive symbols:\n");
  for (unsigned int i = 0; i < incremental_inputs.input_file_count(); ++i)
    {
      Entry_reader input_file(incremental_inputs.input_file(i));

      if (input_file.type() != INCREMENTAL_INPUT_ARCHIVE)
	continue;

      const char* objname = input_file.filename();
      if (objname == NULL)
	{
	  fprintf(stderr,"%s: %s: failed to get file name for object %u\n",
		  argv0, filename, i);
	  exit(1);
	}

      printf("[%d] %s\n", i, objname);
      unsigned int nsyms = input_file.get_unused_symbol_count();
      for (unsigned int symndx = 0; symndx < nsyms; ++symndx)
        printf("    %s\n", input_file.get_unused_symbol(symndx));
    }

}

int
main(int argc, char** argv)
{
  if (argc != 2)
    {
      fprintf(stderr, "Usage: %s <file>\n", argv[0]);
      return 1;
    }
  const char* filename = argv[1];

  Output_file* file = new Output_file(filename);

  bool t = file->open_base_file(NULL, false);
  if (!t)
    {
      fprintf(stderr, "%s: open_base_file(%s): %s\n", argv[0], filename,
              strerror(errno));
      return 1;
    }

  Incremental_binary* inc = open_incremental_binary(file);

  if (inc == NULL)
    {
      fprintf(stderr, "%s: open_incremental_binary(%s): %s\n", argv[0],
              filename, strerror(errno));
      return 1;
    }

  switch (parameters->size_and_endianness())
    {
#ifdef HAVE_TARGET_32_LITTLE
    case Parameters::TARGET_32_LITTLE:
      dump_incremental_inputs<32, false>(
          argv[0], filename,
          static_cast<Sized_incremental_binary<32, false>*>(inc));
      break;
#endif
#ifdef HAVE_TARGET_32_BIG
    case Parameters::TARGET_32_BIG:
      dump_incremental_inputs<32, true>(
	  argv[0], filename,
          static_cast<Sized_incremental_binary<32, true>*>(inc));
      break;
#endif
#ifdef HAVE_TARGET_64_LITTLE
    case Parameters::TARGET_64_LITTLE:
      dump_incremental_inputs<64, false>(
	  argv[0], filename,
          static_cast<Sized_incremental_binary<64, false>*>(inc));
      break;
#endif
#ifdef HAVE_TARGET_64_BIG
    case Parameters::TARGET_64_BIG:
      dump_incremental_inputs<64, true>(
	  argv[0], filename,
          static_cast<Sized_incremental_binary<64, true>*>(inc));
      break;
#endif
    default:
      gold_unreachable();
    }

  return 0;
}
@


1.19
log
@	* common.cc (Symbol_table::do_allocate_commons_list): For incremental
	update, allocate common from bss section's free list.
	* incremental-dump.cc (dump_incremental_inputs): Print flag for
	linker-defined symbols.
	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Skip GOT and PLT entries that are no longer referenced.
	(Output_section_incremental_inputs::write_info_blocks): Mark
	linker-defined symbols.
	(Sized_incr_relobj::do_add_symbols): Process linker-defined symbols.
	* output.cc (Output_section::allocate): New function.
	* output.h (Output_section::allocate): New function.
	* resolve.cc (Symbol_table::report_resolve_problem): Add case for
	linker-defined symbols.
	(Symbol::override_base_with_special): Copy is_predefined_ flag.
	* symtab.cc (Symbol::init_fields): Initialize is_predefined_ flag.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* symtab.h (Symbol::is_predefined): New function.
	(Symbol::init_base_output_data): Add is_predefined parameter.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::is_predefined_): New data member.
	(Sized_symbol::init_output_data): Add is_predefined parameter.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(enum Symbol_table::Defined): Add INCREMENTAL_BASE.
@
text
@d55 3
d69 2
a70 1
	  *symndx = (offset - input_file.get_symbol_offset(0)) / 20;
d99 1
a99 1
  if (incremental_inputs.version() != 1)
@


1.18
log
@	* copy-relocs.cc (Copy_relocs::copy_reloc): Call make_copy_reloc
	instead of emit_copy_reloc.
	(Copy_relocs::emit_copy_reloc): Refactor.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* copy-relocs.h (Copy_relocs::emit_copy_reloc): Move to public
	section.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* gold.cc (queue_middle_tasks): Emit old COPY relocations from
	unchanged input files.
	* incremental-dump.cc (dump_incremental_inputs): Print "COPY" flag.
	* incremental.cc (Sized_incremental_binary::do_reserve_layout):
	Reserve BSS space for COPY relocations.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Output_section_incremental_inputs::write_info_blocks): Record
	whether a symbol is copied from a shared object.
	(Sized_incr_dynobj::do_add_symbols): Record COPY relocations.
	* incremental.h (enum Incremental_shlib_symbol_flags): New type.
	(INCREMENTAL_SHLIB_SYM_FLAGS_SHIFT): New constant.
	(Incremental_input_entry_reader::get_output_symbol_index): Add
	is_copy parameter.
	(Incremental_binary::emit_copy_relocs): New function.
	(Incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data member.
	(Sized_incremental_binary::add_copy_reloc): New function.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Copy_reloc): New struct.
	(Sized_incremental_binary::Copy_relocs): New typedef.
	(Sized_incremental_binary::copy_relocs_): New data member.
	* symtab.cc (Symbol_table::add_from_incrobj): Change return type.
	* symtab.h (Symbol_table::add_from_incrobj): Change return type.
	* target.h (Sized_target::emit_copy_reloc): New function.
	* x86_64.cc (Target_x86_64::emit_copy_reloc): New function.
@
text
@d325 1
a325 1
		     info.shndx(),
d330 3
a332 1
		     info.shndx() != elfcpp::SHN_UNDEF ? "DEF" : "UNDEF",
@


1.17
log
@	* incremental-dump.cc (dump_incremental_inputs): Print COMDAT groups.
	* incremental.cc (Incremental_inputs::report_input_section): Fix
	comment, indentation.
	(Incremental_inputs::report_comdat_group): New function.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of data for incremental input file entry.
	(Output_section_incremental_inputs::write_info_blocks): Write COMDAT
	group count, COMDAT group signatures.
	(Sized_incr_relobj::do_layout): Record kept COMDAT group info from
	an unchanged input file.
	* incremental.h (Incremental_object_entry::Incremental_object_entry):
	Initialize new data member.
	(Incremental_object_entry::add_comdat_group): New function.
	(Incremental_object_entry::get_comdat_group_count): New function.
	(Incremental_object_entry::get_comdat_signature_key): New function.
	(Incremental_object_entry::groups_): New data member.
	(Incremental_inputs::report_comdat_group): New function.
	(Incremental_input_entry_reader::get_symbol_offset): Adjust size of
	data for incremental input file entry.
	(Incremental_input_entry_reader::get_comdat_group_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	data for incremental input file entry.
	(Incremental_input_entry_reader::get_global_symbol_reader): Likewise.
	(Incremental_input_entry_reader::get_comdat_group_signature): New
	function.
	* object.cc (Sized_relobj::include_section_group): Report kept
	COMDAT groups for incremental links.
@
text
@d296 1
d298 1
a298 1
		  input_file.get_output_symbol_index(symndx, &is_def);
d307 1
a307 1
		     is_def ? "DEF" : "UNDEF",
@


1.16
log
@	* gold.cc (queue_initial_tasks): Pass incremental base filename
	to Output_file::open_base_file; don't print error message.
	* incremental-dump.cc (main): Adjust call to
	Output_file::open_for_modification.
	* incremental-dump.cc (main): Likewise.
	* incremental.cc (Incremental_inputs::report_command_line):
	Ignore --incremental-base option when comparing command lines.
	Ignore parameter when given as separate argument.
	* options.h (class General_options): Add --incremental-base.
	* output.cc (Output_file::Output_file):
	(Output_file::open_base_file): Add base_name and writable parameters;
	read base file into new file; print error message here.
	(Output_file::map_no_anonymous): Add writable parameter; adjust all
	callers.
	* output.h (Output_file::open_for_modification): Rename to...
	(Output_file::open_base_file): ...this; add base_name and
	writable parameters; adjust all callers.
	(Output_file::map_no_anonymous): Add writable parameter; adjust all
	callers.
	* testsuite/Makefile.am (incremental_test_4): Test
	--incremental-base.
	* testsuite/Makefile.in: Regenerate.
@
text
@d156 2
d217 5
@


1.15
log
@	* dynobj.h (Dynobj::do_dynobj): New function.
	* incremental-dump.cc (dump_incremental_inputs): Print as_needed
	flag and soname for shared objects.
	* incremental.cc (Incremental_inputs::report_object): Make
	either Incremental_object_entry or Incremental_dynobj_entry; add
	soname to string table.
	(Incremental_inputs::report_input_section): Add assertion.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	type of input file entry for shared libraries; adjust size of
	shared library info entry.
	(Output_section_incremental_inputs::write_input_files): Write
	as_needed flag for shared libraries.
	(Output_section_incremental_inputs::write_info_blocks): Adjust type
	of input file entry for shared libraries; write soname.
	(Sized_incr_dynobj::Sized_incr_dynobj): Read as_needed flag and
	soname from incremental info.
	* incremental.h (enum Incremental_input_flags): Add
	INCREMENTAL_INPUT_AS_NEEDED.
	(Incremental_input_entry::Incremental_input_entry): Initialize new
	data member.
	(Incremental_input_entry::set_as_needed): New function.
	(Incremental_input_entry::as_needed): New function.
	(Incremental_input_entry::do_dynobj_entry): New function.
	(Incremental_input_entry::as_needed_): New data member.
	(Incremental_object_entry::Incremental_object_entry): Don't check
	for shared library.
	(Incremental_object_entry::do_type): Likewise.
	(class Incremental_dynobj_entry): New class.
	(Incremental_input_entry_reader::as_needed): New function.
	(Incremental_input_entry_reader::get_soname): New function.
	(Incremental_input_entry_reader::get_global_symbol_count): Rewrite.
	(Incremental_input_entry_reader::get_output_symbol_index): Adjust
	size of shared library info entry.
	* layout.cc (Layout::finish_dynamic_section): Don't test for
	incremental link when adding DT_NEEDED entries.
	* object.h (Object::Object): Initialize new data member.
	(Object::dynobj): New function.
	(Object::set_as_needed): New function.
	(Object::as_needed): New function.
	(Object::do_dynobj): New function.
	(Object::as_needed_): New data member.
@
text
@d452 1
a452 1
  bool t = file->open_for_modification();
d455 1
a455 1
      fprintf(stderr, "%s: open_for_modification(%s): %s\n", argv[0], filename,
@


1.14
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d165 4
@


1.13
log
@	* gold.cc (queue_middle_tasks): Process existing GOT/PLT entries.
	* incremental-dump.cc (dump_incremental_inputs): Mask high-order
	bit when checking got_type.
	* incremental.cc (Sized_incremental_binary::setup_readers):
	Store symbol table and string table locations; initialize bit vector
	of file status flags.
	(Sized_incremental_binary::do_reserve_layout): Set bit flag for
	unchanged files.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::get_symtab_view): Use stored locations.
	(Output_section_incremental_inputs::set_final_data_size): Record
	file index for each input file.
	(Output_section_incremental_inputs::write_got_plt): Store file index
	instead of input entry offset for each GOT entry.
	* incremental.h
	(Incremental_input_entry::Incremental_input_entry): Initialize new
	data member.
	(Incremental_input_entry::set_offset): Store file index.
	(Incremental_input_entry::get_file_index): New function.
	(Incremental_input_entry::file_index_): New data member.
	(Incremental_binary::process_got_plt): New function.
	(Incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data members.
	(Sized_incremental_binary::~Sized_incremental_binary): New destructor.
	(Sized_incremental_binary::set_file_is_unchanged): New function.
	(Sized_incremental_binary::file_is_unchanged): New function.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::file_status_): New data member.
	(Sized_incremental_binary::main_symtab_loc_): New data member.
	(Sized_incremental_binary::main_strtab_loc_): New data member.
	* output.cc (Output_data_got::Got_entry::write): Add case
	RESERVED_CODE.
	(Output_data_got::add_global): Call add_got_entry.
	(Output_data_got::add_global_plt): Likewise.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_global_pair_with_rela): Likewise.
	(Output_data_got::add_local): Call add_got_entry.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_local_pair_with_rela): Likewise.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_section::add_output_section_data): Edit FIXME.
	* output.h
	(Output_section_data_build::Output_section_data_build): New
	constructor with size parameter.
	(Output_data_space::Output_data_space): Likewise.
	(Output_data_got::Output_data_got): Initialize new data member; new
	constructor with size parameter.
	(Output_data_got::add_constant): Call add_got_entry.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(class Output_data_got::Got_entry): Add RESERVED_CODE.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_data_got::free_list_): New data member.
	* target.h (Sized_target::init_got_plt_for_update): New function.
	(Sized_target::register_global_plt_entry): New function.
	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Initialize new data member; call init; add constructor with PLT count.
	(Output_data_plt_x86_64::init): New function.
	(Output_data_plt_x86_64::add_relocation): New function.
	(Output_data_plt_x86_64::reserve_slot): New function.
	(Output_data_plt_x86_64::free_list_): New data member.
	(Target_x86_64::init_got_plt_for_update): New function.
	(Target_x86_64::register_global_plt_entry): New function.
	(Output_data_plt_x86_64::add_entry): Allocate from free list for
	incremental updates.
	(Output_data_plt_x86_64::add_relocation): New function.
	* testsuite/object_unittest.cc (Object_test): Set default options.
@
text
@d152 4
d375 2
a376 1
      unsigned int got_desc = igot_plt.get_got_desc(i);
d382 2
a383 1
	  Entry_reader input_file = incremental_inputs.input_file(got_desc);
d385 1
a385 1
	  printf("local: %s (%d)", objname, got_desc);
d389 1
a389 1
	  sym_p = symtab_view.data() + got_desc * sym_size;
d394 1
a394 1
	  printf("global %s (%d)", symname, got_desc);
@


1.12
log
@	* incremental-dump.cc (dump_incremental_inputs): Print local
	symbol info for each input file.
	* incremental.cc
	(Output_section_incremental_inputs::set_final_data_size): Add local
	symbol info to input file entries in incremental info.
	(Output_section_incremental_inputs::write_info_blocks): Likewise.
	(Sized_incr_relobj::Sized_incr_relobj): Initialize new data members.
	(Sized_incr_relobj::do_add_symbols): Cosmetic change.
	(Sized_incr_relobj::do_count_local_symbols): Replace stub with
	implementation.
	(Sized_incr_relobj::do_finalize_local_symbols): Likewise.
	(Sized_incr_relobj::do_relocate): Write the local symbols.
	(Sized_incr_dynobj::do_add_symbols): Cosmetic change.
	* incremental.h (Incremental_inputs_reader::get_symbol_offset):
	Adjust size of input file header.
	(Incremental_inputs_reader::get_local_symbol_offset): New function.
	(Incremental_inputs_reader::get_local_symbol_count): New function.
	(Incremental_inputs_reader::get_input_section): Adjust size of input
	file header.
	(Incremental_inputs_reader::get_global_symbol_reader): Likewise.
	(Sized_incr_relobj::This): New typedef.
	(Sized_incr_relobj::sym_size): New const data member.
	(Sized_incr_relobj::Local_symbol): New struct.
	(Sized_incr_relobj::do_output_local_symbol_count): New function.
	(Sized_incr_relobj::do_local_symbol_offset): New function.
	(Sized_incr_relobj::local_symbol_count_): New data member.
	(Sized_incr_relobj::output_local_dynsym_count_): New data member.
	(Sized_incr_relobj::local_symbol_index_): New data member.
	(Sized_incr_relobj::local_symbol_offset_): New data member.
	(Sized_incr_relobj::local_dynsym_offset_): New data member.
	(Sized_incr_relobj::local_symbols_): New data member.
	* object.h (Relobj::output_local_symbol_count): New function.
	(Relobj::local_symbol_offset): New function.
	(Relobj::do_output_local_symbol_count): New function.
	(Relobj::do_local_symbol_offset): New function.
	(Sized_relobj::do_output_local_symbol_count): New function.
	(Sized_relobj::do_local_symbol_offset): New function.
@
text
@d373 1
a373 1
      if (got_type == 0x7f)
@


1.11
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@a140 6
	  printf("Object\n");
	  printf("    Input section count: %d\n",
		 input_file.get_input_section_count());
	  printf("    Symbol count: %d\n",
		 input_file.get_global_symbol_count());
	  break;
d142 2
a143 1
	  printf("Archive member\n");
d146 1
a146 1
	  printf("    Symbol count: %d\n",
d148 4
@


1.10
log
@	* incremental-dump.cc (dump_incremental_inputs): Change signature
	to take a Sized_incremental_binary; change caller.  Use readers
	in Sized_incremental_binary.
	* incremental.cc
	(Sized_incremental_binary::find_incremental_inputs_sections):
	Rename do_find_incremental_inputs_sections to this.
	(Sized_incremental_binary::setup_readers): New function.
	(Sized_incremental_binary::do_check_inputs): Check
	has_incremental_info_ flag; move setup code to setup_readers;
	use input readers.
	(Sized_incremental_binary::do_file_is_unchanged): New function.
	(Sized_incremental_binary::do_get_input_reader): New function.
	* incremental.h (class Incremental_binary): Move to end of file.
	(Incremental_binary::file_is_unchanged): New function.
	(Incremental_binary::do_file_is_unchanged): New function.
	(Incremental_binary::Input_reader): New class.
	(Incremental_binary::get_input_reader): New function.
	(class Sized_incremental_binary): Move to end of file.
	(Sized_incremental_binary::Sized_incremental_binary): Setup the
	input section reader classes.
	(Sized_incremental_binary::has_incremental_info): New function.
	(Sized_incremental_binary::inputs_reader): New function.
	(Sized_incremental_binary::symtab_reader): New function.
	(Sized_incremental_binary::relocs_reader): New function.
	(Sized_incremental_binary::got_plt_reader): New function.
	(Sized_incremental_binary::do_file_is_unchanged): New function.
	(Sized_incremental_binary::Sized_input_reader): New class.
	(Sized_incremental_binary::get_input_reader): New function.
	(Sized_incremental_binary::find_incremental_inputs_sections):
	Rename do_find_incremental_inputs_sections to this.
	(Sized_incremental_binary::setup_readers): New function.
	(Sized_incremental_binary::has_incremental_info_): New data member.
	(Sized_incremental_binary::inputs_reader_): New data member.
	(Sized_incremental_binary::symtab_reader_): New data member.
	(Sized_incremental_binary::relocs_reader_): New data member.
	(Sized_incremental_binary::got_plt_reader_): New data member.
	(Sized_incremental_binary::current_input_file_): New data member.
@
text
@d66 1
a66 1
	  *symndx = (offset - input_file.get_symbol_offset(0)) / 16;
d132 4
d202 1
a202 1
	  printf("    %3d  %6d  %8lld  %8lld  %s\n", shndx,
a209 36
  printf("\nGlobal symbols per input file:\n");
  for (unsigned int i = 0; i < incremental_inputs.input_file_count(); ++i)
    {
      Entry_reader input_file(incremental_inputs.input_file(i));

      if (input_file.type() != INCREMENTAL_INPUT_OBJECT
	  && input_file.type() != INCREMENTAL_INPUT_ARCHIVE_MEMBER)
	continue;

      const char* objname = input_file.filename();
      if (objname == NULL)
	{
	  fprintf(stderr,"%s: %s: failed to get file name for object %u\n",
		  argv0, filename, i);
	  exit(1);
	}

      printf("[%d] %s\n", i, objname);

      unsigned int nsyms = input_file.get_global_symbol_count();
      if (nsyms > 0)
	printf("    %6s  %8s  %8s  %8s  %8s\n",
	       "outndx", "offset", "chain", "#relocs", "rbase");
      for (unsigned int symndx = 0; symndx < nsyms; ++symndx)
	{
	  typename Entry_reader::Global_symbol_info info(
	      input_file.get_global_symbol_info(symndx));
	  printf("    %6d  %8d  %8d  %8d  %8d\n",
		 info.output_symndx,
		 input_file.get_symbol_offset(symndx),
		 info.next_offset,
		 info.reloc_count,
		 info.reloc_offset);
	}
    }

d251 69
a319 1
  unsigned const char* sym_p = symtab_view.data() + first_global * sym_size;
d321 1
d337 2
a338 2
	  typename Entry_reader::Global_symbol_info sym_info(
	      input_file.get_global_symbol_info(sym_ndx));
d340 4
a343 4
		 input_file.filename(), sym_info.reloc_offset,
		 sym_info.reloc_count);
	  if (sym_info.output_symndx != first_global + i)
	    printf(" ** wrong output symndx (%d) **", sym_info.output_symndx);
d346 2
a347 2
	  unsigned int r_off = sym_info.reloc_offset;
	  for (unsigned int j = 0; j < sym_info.reloc_count; j++)
d349 1
a349 1
	      printf("      %4d  relocation type %3d  shndx %d"
d359 1
a359 1
	  offset = sym_info.next_offset;
@


1.9
log
@	* archive.cc (Archive::include_member): Adjust call to report_object.
	(Add_archive_symbols::run): Add script_info to call to
	report_archive_begin.
	(Lib_group::include_member): Adjust call to report_object.
	(Add_lib_group_symbols::run): Adjust call to report_object.
	* incremental-dump.cc (dump_incremental_inputs): Remove unnecessary
	blocks.  Add object count for script input files.
	* incremental.cc (Incremental_inputs::report_archive_begin): Add
	script_info parameter; change all callers.
	(Incremental_inputs::report_object): Add script_info parameter;
	change all callers.
	(Incremental_inputs::report_script): Store backpointer to
	incremental info entry.
	(Output_section_incremental_inputs::set_final_data_size): Record
	additional information for scripts.
	(Output_section_incremental_inputs::write_info_blocks): Likewise.
	* incremental.h (Incremental_script_entry::add_object): New function.
	(Incremental_script_entry::get_object_count): New function.
	(Incremental_script_entry::get_object): New function.
	(Incremental_script_entry::objects_): New data member; adjust
	constructor.
	(Incremental_inputs::report_archive_begin): Add script_info parameter.
	(Incremental_inputs::report_object): Add script_info parameter.
	(Incremental_inputs_reader::get_object_count): New function.
	(Incremental_inputs_reader::get_object_offset): New function.
	* options.cc (Input_arguments::add_file): Return reference to
	new input argument.
	* options.h (Input_argument::set_script_info): New function.
	(Input_argument::script_info): New function.
	(Input_argument::script_info_): New data member; adjust all
	constructors.
	(Input_file_group::add_file): Return reference to new input argument.
	(Input_file_lib::add_file): Likewise.
	(Input_arguments::add_file): Likewise.
	* readsyms.cc (Add_symbols::run): Adjust call to report_object.
	* script.cc (Parser_closure::Parser_closure): Add script_info
	parameter; adjust all callers.
	(Parser_closure::script_info): New function.
	(Parser_closure::script_info_): New data member.
	(read_input_script): Report scripts earlier to incremental info.
	(script_add_file): Set script_info in Input_argument.
	(script_add_library): Likewise.
	* script.h (Script_options::Script_info): Rewrite class.
@
text
@d76 1
a76 1
			Incremental_binary* inc)
a77 6
  bool t;
  unsigned int inputs_shndx;
  unsigned int isymtab_shndx;
  unsigned int irelocs_shndx;
  unsigned int igot_plt_shndx;
  unsigned int istrtab_shndx;
d83 1
a83 6
  // Find the .gnu_incremental_inputs, _symtab, _relocs, and _strtab sections.

  t = inc->find_incremental_inputs_sections(&inputs_shndx, &isymtab_shndx,
					    &irelocs_shndx, &igot_plt_shndx,
					    &istrtab_shndx);
  if (!t)
a89 13
  elfcpp::Elf_file<size, big_endian, Incremental_binary> elf_file(inc);

  // Get a view of the .gnu_incremental_inputs section.

  Location inputs_location(elf_file.section_contents(inputs_shndx));
  View inputs_view(inc->view(inputs_location));

  // Get the .gnu_incremental_strtab section as a string table.

  Location istrtab_location(elf_file.section_contents(istrtab_shndx));
  View istrtab_view(inc->view(istrtab_location));
  elfcpp::Elf_strtab istrtab(istrtab_view.data(), istrtab_location.data_size);

d93 1
a93 1
      incremental_inputs(inputs_view.data(), istrtab);
d244 2
a268 10
  // Get a view of the .gnu_incremental_symtab section.

  Location isymtab_location(elf_file.section_contents(isymtab_shndx));
  View isymtab_view(inc->view(isymtab_location));

  // Get a view of the .gnu_incremental_relocs section.

  Location irelocs_location(elf_file.section_contents(irelocs_shndx));
  View irelocs_view(inc->view(irelocs_location));

d277 2
d281 1
a281 1
  unsigned int nglobals = isymtab_location.data_size / 4;
a283 4
  unsigned const char* isym_p = isymtab_view.data();

  Incremental_symtab_reader<big_endian> isymtab(isymtab_view.data());
  Incremental_relocs_reader<size, big_endian> irelocs(irelocs_view.data());
a324 1
      isym_p += 4;
d327 1
a327 6
  // Get a view of the .gnu_incremental_got_plt section.

  Location igot_plt_location(elf_file.section_contents(igot_plt_shndx));
  View igot_plt_view(inc->view(igot_plt_location));

  Incremental_got_plt_reader<big_endian> igot_plt(igot_plt_view.data());
d427 3
a429 1
      dump_incremental_inputs<32, false>(argv[0], filename, inc);
d434 3
a436 1
      dump_incremental_inputs<32, true>(argv[0], filename, inc);
d441 3
a443 1
      dump_incremental_inputs<64, false>(argv[0], filename, inc);
d448 3
a450 1
      dump_incremental_inputs<64, true>(argv[0], filename, inc);
@


1.8
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d161 5
a165 7
	  {
	    printf("Object\n");
	    printf("    Input section count: %d\n",
		   input_file.get_input_section_count());
	    printf("    Symbol count: %d\n",
		   input_file.get_global_symbol_count());
	  }
d168 5
a172 7
	  {
	    printf("Archive member\n");
	    printf("    Input section count: %d\n",
		   input_file.get_input_section_count());
	    printf("    Symbol count: %d\n",
		   input_file.get_global_symbol_count());
	  }
d175 4
a178 6
	  {
	    printf("Archive\n");
	    printf("    Member count: %d\n", input_file.get_member_count());
	    printf("    Unused symbol count: %d\n",
		   input_file.get_unused_symbol_count());
	  }
d181 3
a183 5
	  {
	    printf("Shared library\n");
	    printf("    Symbol count: %d\n",
		   input_file.get_global_symbol_count());
	  }
d187 1
@


1.7
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_GOT_PLT.

gold/ChangeLog:

	* arm.cc (Target_arm::got_size): Add const.
	(Target_arm::got_entry_count): New function.
	(Target_arm::plt_entry_count): New function.
	(Target_arm::first_plt_entry_offset): New function.
	(Target_arm::plt_entry_size): New function.
	(Output_data_plt_arm::entry_count): New function.
	(Output_data_plt_arm::first_plt_entry_offset): New function.
	(Output_data_plt_arm::get_plt_entry_size): New function.
	* i386.cc (Target_i386::got_size): Add const.
	(Target_i386::got_entry_count): New function.
	(Target_i386::plt_entry_count): New function.
	(Target_i386::first_plt_entry_offset): New function.
	(Target_i386::plt_entry_size): New function.
	(Output_data_plt_i386::entry_count): New function.
	(Output_data_plt_i386::first_plt_entry_offset): New function.
	(Output_data_plt_i386::get_plt_entry_size): New function.
	* incremental-dump.cc (dump_incremental_inputs): Adjust call to
	find_incremental_inputs_sections.  Dump incremental_got_plt section.
	* incremental.cc: Include target.h.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Add
	parameter.  Adjust all callers.  Find incremental_got_plt section.
	(Incremental_inputs::create_data_sections): Create incremental_got_plt
	section.
	(Output_section_incremental_inputs::set_final_data_size): Calculate
	size of incremental_got_plt section.
	(Output_section_incremental_inputs::do_write): Write the
	incremental_got_plt section.
	(Got_plt_view_info): New struct.
	(Local_got_offset_visitor): New class.
	(Global_got_offset_visitor): New class.
	(Global_symbol_visitor_got_plt): New class.
	(Output_section_incremental_inputs::write_got_plt): New function.
	* incremental.h (Incremental_binary::find_incremental_inputs_sections):
	Add parameter.  Adjust all callers.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Incremental_inputs::got_plt_section): New function.
	(Incremental_inputs::got_plt_section_): New data member.
	(Incremental_got_plt_reader): New class.
	* layout.cc (Layout::create_incremental_info_sections): Add the
	incremental_got_plt section.
	* object.h (Got_offset_list::get_list): New function.
	(Got offset_list::for_all_got_offsets): New function.
	(Sized_relobj::local_got_offset_list): New function.
	* powerpc.cc (Target_powerpc::got_size): Add const.
	(Target_powerpc::got_entry_count): New function.
	(Target_powerpc::plt_entry_count): New function.
	(Target_powerpc::first_plt_entry_offset): New function.
	(Target_powerpc::plt_entry_size): New function.
	(Output_data_plt_powerpc::entry_count): New function.
	(Output_data_plt_powerpc::first_plt_entry_offset): New function.
	(Output_data_plt_powerpc::get_plt_entry_size): New function.
	* sparc.cc (Target_sparc::got_size): Add const.
	(Target_sparc::got_entry_count): New function.
	(Target_sparc::plt_entry_count): New function.
	(Target_sparc::first_plt_entry_offset): New function.
	(Target_sparc::plt_entry_size): New function.
	(Output_data_plt_sparc::entry_count): New function.
	(Output_data_plt_sparc::first_plt_entry_offset): New function.
	(Output_data_plt_sparc::get_plt_entry_size): New function.
	* symtab.h (Symbol::got_offset_list): New function.
	(Symbol_table::for_all_symbols): New function.
	* target.h (Sized_target::got_entry_count): New function.
	(Sized_target::plt_entry_count): New function.
	(Sized_target::plt_entry_size): New function.
	* x86_64.cc (Target_x86_64::got_size): Add const.
	(Target_x86_64::got_entry_count): New function.
	(Target_x86_64::plt_entry_count): New function.
	(Target_x86_64::first_plt_entry_offset): New function.
	(Target_x86_64::plt_entry_size): New function.
	(Output_data_plt_x86_64::entry_count): New function.
	(Output_data_plt_x86_64::first_plt_entry_offset): New function.
	(Output_data_plt_x86_64::get_plt_entry_size): New function.
@
text
@d98 1
a98 1
      exit (1);
d279 1
a279 1
      exit (1);
d292 1
a292 1
      exit (1);
@


1.6
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_SYMTAB,
	SHT_GNU_INCREMENTAL_RELOCS.

gold/ChangeLog:

	* archive.cc: Include incremental.h.
	(Archive::Archive): Initialize incremental_info_.
	(Archive::include_member): Record archive members in incremental info.
	(Add_archive_symbols::run): Record begin and end of an archive in
	incremental info.
	(Lib_group::include_member): Record objects in incremental info.
	* archive.h (Incremental_archive_entry): Forward declaration.
	(Archive::set_incremental_info): New member function.
	(Archive::incremental_info): New member function.
	(Archive::Unused_symbol_iterator): New class.
	(Archive::unused_symbols_begin): New member function.
	(Archive::unused_symbols_end): New member function.
	(Archive::incremental_info_): New data member.
	* incremental-dump.cc (find_input_containing_global): New function.
	(dump_incremental_inputs): Dump new incremental info sections.
	* incremental.cc: Include symtab.h.
	(Output_section_incremental_inputs): New class.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Support
	new incremental info sections.
	(Sized_incremental_binary::do_check_inputs): Likewise.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): New function.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Rewrite.
	(Incremental_inputs::finalize): Do nothing but finalize string table.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Output_section_incremental_inputs::set_final_data_size): New function.
	(Output_section_incremental_inputs::do_write): New function.
	(Output_section_incremental_inputs::write_header): New function.
	(Output_section_incremental_inputs::write_input_files): New function.
	(Output_section_incremental_inputs::write_info_blocks): New function.
	(Output_section_incremental_inputs::write_symtab): New function.
	* incremental.h (Incremental_script_entry): Forward declaration.
	(Incremental_object_entry): Forward declaration.
	(Incremental_archive_entry): Forward declaration.
	(Incremental_inputs): Forward declaration.
	(Incremental_inputs_header_data): Remove.
	(Incremental_inputs_header): Remove.
	(Incremental_inputs_header_write): Remove.
	(Incremental_inputs_entry_data): Remove.
	(Incremental_inputs_entry): Remove.
	(Incremental_inputs_entry_write): Remove.
	(enum Incremental_input_type): Add INCREMENTAL_INPUT_ARCHIVE_MEMBER.
	(Incremental_binary::find_incremental_inputs_sections): Add parameters.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Sized_ncremental_binary::do_find_incremental_inputs_sections):
	Likewise.
	(Incremental_input_entry): New class.
	(Incremental_script_entry): New class.
	(Incremental_object_entry): New class.
	(Incremental_archive_entry): New class.
	(Incremental_inputs::Incremental_inputs): Initialize new data members.
	(Incremental_inputs::report_inputs): Remove.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): Change prototype.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Change prototype.
	(Incremental_inputs::get_reloc_count): New function.
	(Incremental_inputs::set_reloc_count): New function.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::inputs_section): New function.
	(Incremental_inputs::symtab_section): New function.
	(Incremental_inputs::relocs_section): New function.
	(Incremental_inputs::get_stringpool): Add const.
	(Incremental_inputs::command_line): Add const.
	(Incremental_inputs::inputs): Remove.
	(Incremental_inputs::command_line_key): New function.
	(Incremental_inputs::input_file_count): New function.
	(Incremental_inputs::input_files): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::Input_info): Remove.
	(Incremental_inputs::lock_): Remove.
	(Incremental_inputs::inputs_): Change type.
	(Incremental_inputs::inputs_map_): Remove.
	(Incremental_inputs::current_object_entry_): New data member.
	(Incremental_inputs::inputs_section_): New data member.
	(Incremental_inputs::symtab_section_): New data member.
	(Incremental_inputs::relocs_section_): New data member.
	(Incremental_inputs::reloc_count_): New data member.
	(Incremental_inputs_reader): New class.
	(Incremental_symtab_reader): New class.
	(Incremental_relocs_reader): New class.
	* layout.cc (Layout::finalize): Move finalization of incremental info
	and creation of incremental info sections to follow finalization of
	symbol table.  Set offsets for postprocessing sections.
	(Layout::create_incremental_info_sections): Call
	Incremental_inputs::create_data_sections.  Add incremental symtab
	and relocs sections.  Set sh_entsize and sh_link fields.  Arrange for
	sections to layout after input sections.
	* layout.h (struct Timespec): Forward declaration.
	(Layout::incremental_inputs): Add const.
	(Layout::create_incremental_info_sections): Add parameter.
	* main.cc (main): Remove call to Incremental_inputs::report_inputs.
	* object.cc: Include incremental.h.
	(Relobj::finalize_incremental_relocs): New function.
	(Sized_relobj::do_layout): Record input sections in incremental info.
	* object.h (Object::output_section): New function.
	(Object::output_section_offset): Moved from Relobj.
	(Object::get_incremental_reloc_base): New function.
	(Object::get_incremental_reloc_count): New function.
	(Object::do_output_section): New function.
	(Object::do_output_section_offset): Moved from Relobj.
	(Object::do_get_incremental_reloc_base): New function.
	(Object::do_get_incremental_reloc_count): New function.
	(Object::Object): Initialize new data members.
	(Relobj::output_section): Renamed do_output_section and moved to
	protected.
	(Relobj::output_section_offset): Moved to Object.
	(Relobj::do_get_incremental_reloc_base): New function.
	(Relobj::do_get_incremental_reloc_count): New function.
	(Relobj::allocate_incremental_reloc_counts): New function.
	(Relobj::count_incremental_reloc): New function.
	(Relobj::finalize_incremental_relocs): New function.
	(Relobj::next_incremental_reloc_index): New function.
	(Relobj::reloc_counts_): New data member.
	(Relobj::reloc_bases_): New data member.
	(Sized_relobj::do_relocate_sections): Add parameter.  Change caller.
	(Sized_relobj::relocate_sections): Add parameter.  Change all callers.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* plugin.cc (Plugin_manager::add_input_file): Rewrite test for
	incremental link.
	* readsyms.cc (Read_symbols::do_read_symbols): Move reporting of
	archives and object files elsewhere.
	(Add_symbols::run): Report object files here.
	(Finish_group::run): Report end of archive at end of group.
	* reloc.cc: Include layout.h, incremental.h.
	(Sized_relobj::do_read_relocs): Need relocations for incremental link.
	(Sized_relobj::do_scan_relocs): Record relocations for incremental link.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::do_relocate_sections): Write incremental relocations.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* script.cc (read_input_script): Rewrite test for incremental link.
	Change call to Incremental_inputs::report_script.
	* symtab.h (Symbol_table::first_global_index): New function.
	(Symbol_table::output_count): New function.
@
text
@d82 1
d92 2
a93 1
					    &irelocs_shndx, &istrtab_shndx);
d139 1
a139 3
      typedef Incremental_inputs_reader<size, big_endian> Inputs_reader;
      typename Inputs_reader::Incremental_input_entry_reader input_file =
	  incremental_inputs.input_file(i);
a205 4
      typedef Incremental_inputs_reader<size, big_endian> Inputs_reader;
      typedef typename Inputs_reader::Incremental_input_entry_reader
          Entry_reader;

a239 4
      typedef Incremental_inputs_reader<size, big_endian> Inputs_reader;
      typedef typename Inputs_reader::Incremental_input_entry_reader
          Entry_reader;

d369 48
@


1.5
log
@2009-12-07  Rafael Avila de Espindola  <espindola@@google.com>

	PR gold/11055
	* incremental-dump.cc (dump_incremental_inputs): New.
	(main): Use dump_incremental_inputs.
@
text
@d1 1
a1 1
// inremental.cc -- incremental linking test/deubg tool
d3 1
a3 1
// Copyright 2009 Free Software Foundation, Inc.
d35 1
d47 27
d75 2
a76 2
dump_incremental_inputs(const char* argv0,
                        const char* filename, Incremental_binary* inc)
d79 8
a86 2
  unsigned int strtab_shndx;
  Incremental_binary::Location location;
d88 4
a91 1
  t = inc->find_incremental_inputs_section(&location, &strtab_shndx);
d99 12
a110 2
  Incremental_binary::View inputs_view(inc->view(location));
  const unsigned char* p = inputs_view.data();
d112 1
a112 1
  Incremental_inputs_header<size, big_endian> incremental_header(p);
d114 2
a115 2
  const unsigned char* incremental_inputs_base =
    (p + sizeof(Incremental_inputs_header_data));
d117 1
a117 1
  if (incremental_header.get_version() != 1)
d120 1
a120 1
              filename, incremental_header.get_version());
d124 2
a125 3
  elfcpp::Elf_file<size, big_endian, Incremental_binary> elf_file(inc);

  if (elf_file.section_type(strtab_shndx) != elfcpp::SHT_STRTAB)
d128 2
a129 3
              "%s: %s: invalid string table section %u (type %d != %d)\n",
              argv0, filename, strtab_shndx,
              elf_file.section_type(strtab_shndx), elfcpp::SHT_STRTAB);
d132 1
d134 21
a154 2
  Incremental_binary::Location
    strtab_location(elf_file.section_contents(strtab_shndx));
d156 124
a279 2
  Incremental_binary::View strtab_view(inc->view(strtab_location));
  p = strtab_view.data();
d281 1
a281 5
  elfcpp::Elf_strtab strtab(strtab_view.data(), strtab_location.data_size);
  const char* command_line;
  elfcpp::Elf_Word command_line_offset =
    incremental_header.get_command_line_offset();
  t = strtab.get_c_string(command_line_offset, &command_line);
d283 2
a284 1
  if (!t)
d286 2
a287 5
      fprintf(stderr,
              "%s: %s: failed to get link command line: %zu out of range\n",
              argv0, filename,
              static_cast<size_t>(command_line_offset));
      exit(1);
d289 2
d292 1
a292 1
  printf("Link command line: %s\n", command_line);
d294 4
a297 2
  printf("Input files:\n");
  for (unsigned i = 0; i < incremental_header.get_input_file_count(); ++i)
d299 11
a309 4
      const unsigned char* input_p = incremental_inputs_base +
        i * sizeof(Incremental_inputs_entry_data);
      Incremental_inputs_entry<size, big_endian> input(input_p);
      const char* objname;
d311 33
a343 2
      t = strtab.get_c_string(input.get_filename_offset(), &objname);
      if (!t)
d345 52
a396 38
          fprintf(stderr,"%s: %s: failed to get file name for object %u:"
                  " %zu out of range\n", argv0, filename, i,
                  static_cast<size_t>(input.get_filename_offset()));
          exit(1);
        }
      printf("  %s\n", objname);
      printf("    Timestamp sec = %llu\n",
             static_cast<unsigned long long>(input.get_timestamp_sec()));
      printf("    Timestamp nsec = %d\n", input.get_timestamp_nsec());
      printf("    Type = ");
      // TODO: print the data at input->data_offset once we have it.
      elfcpp::Elf_Word input_type = input.get_input_type();
      switch (input_type)
      {
      case INCREMENTAL_INPUT_OBJECT:
        printf("Object\n");
        break;
      case INCREMENTAL_INPUT_ARCHIVE:
        printf("Archive\n");
        break;
      case INCREMENTAL_INPUT_SHARED_LIBRARY:
        printf("Shared library\n");
        break;
      case INCREMENTAL_INPUT_SCRIPT:
        printf("Linker script\n");
        if (input.get_data_offset() != 0)
          {
            fprintf(stderr,"%s: %s: %u is a script but offset is not zero",
                    argv0, filename, i);
            exit(1);
          }
        break;
      case INCREMENTAL_INPUT_INVALID:
      default:
        fprintf(stderr, "%s: invalid file type for object %u: %d\n",
                argv0, i, input_type);
        exit(1);
      }
d398 1
@


1.4
log
@2009-12-02  Rafael Avila de Espindola  <espindola@@google.com>

	* incremental-dump.cc (main): Check that the offeset of a script is 0.
	* incremental.cc (Incremental_inputs::sized_create_inputs_section_data):
	Write 0 for the data_offset of scripts.
@
text
@d45 4
a48 2
int
main(int argc, char** argv)
d50 1
a50 26
  if (argc != 2)
    {
      fprintf(stderr, "Usage: %s <file>\n", argv[0]);
      return 1;
    }
  const char* filename = argv[1];

  Output_file* file = new Output_file(filename);

  bool t = file->open_for_modification();
  if (!t)
    {
      fprintf(stderr, "%s: open_for_modification(%s): %s\n", argv[0], filename,
              strerror(errno));
      return 1;
    }

  Incremental_binary* inc = open_incremental_binary(file);

  if (inc == NULL)
    {
      fprintf(stderr, "%s: open_incremental_binary(%s): %s\n", argv[0],
              filename, strerror(errno));
      return 1;
    }

d57 1
a57 1
      fprintf(stderr, "%s: %s: no .gnu_incremental_inputs section\n", argv[0],
d59 1
a59 1
      return 1;
d63 1
a63 1
  const unsigned char *p = inputs_view.data();
d65 1
a65 2
  const Incremental_inputs_header_data* incremental_header =
    reinterpret_cast<const Incremental_inputs_header_data*> (p);
d67 1
a67 2
  const Incremental_inputs_entry_data* incremental_inputs =
    reinterpret_cast<const Incremental_inputs_entry_data*>
d70 1
a70 1
  if (incremental_header->version != 1)
d72 3
a74 3
      fprintf(stderr, "%s: %s: unknown incremental version %d\n", argv[0],
              filename, incremental_header->version);
      return 1;
d77 1
a77 1
  elfcpp::Elf_file<64, false, Incremental_binary> elf_file(inc);
d83 1
a83 1
              argv[0], filename, strtab_shndx,
d85 1
a85 1
      return 1;
d96 3
a98 2
  t = strtab.get_c_string(incremental_header->command_line_offset,
                          &command_line);
d104 3
a106 3
              argv[0], filename,
              static_cast<size_t>(incremental_header->command_line_offset));
      return 1;
d112 1
a112 1
  for (unsigned i = 0; i < incremental_header->input_file_count; ++i)
d114 4
a117 3
      const Incremental_inputs_entry_data* input =
        &incremental_inputs[i];
      const char *objname;
d119 1
a119 1
      t = strtab.get_c_string(input->filename_offset, &objname);
d123 3
a125 3
                  " %zu out of range\n", argv[0], filename, i,
                  static_cast<size_t>(input->filename_offset));
          return 1;
d129 2
a130 2
             static_cast<unsigned long long>(input->timestamp_sec));
      printf("    Timestamp nsec = %d\n", input->timestamp_nsec);
d133 2
a134 1
      switch (input->input_type)
d147 1
a147 1
        if (input->data_offset != 0)
d150 2
a151 2
                    argv[0], filename, i);
            return 1;
d157 2
a158 2
                argv[0], i, input->input_type);
        return 1;
d161 56
@


1.3
log
@2009-12-01  Rafael Avila de Espindola  <espindola@@google.com>

       * incremental-dump.cc (main): Fix typos.
@
text
@d169 6
@


1.2
log
@2009-11-27  Rafael Avila de Espindola  <espindola@@google.com>

	PR gold/11025
	* incremental-dump.cc (main): Use llu to print 64 bit values.
@
text
@d97 1
a97 1
      fprintf(stderr, "%s: %s: unknown incremestal version %d\n", argv[0],
d159 1
a159 1
        printf("Abject\n");
@


1.1
log
@2009-11-24  Rafael Avila de Espindola  <espindola@@google.com>

	* Makefile.am: Build incremental-dump
	* Makefile.in: Regenerate.
	* incremental-dump.cc: New.
	* incremental.cc (Incremental_inputs_header_data,
	Incremental_inputs_entry_data): Move to incremental.h
	* incremental.h: (Incremental_inputs_header_data,
	Incremental_inputs_entry_data): Move from incremental.cc

2009-11-24  Rafael Avila de Espindola  <espindola@@google.com>

	* elfcpp_file.h: Include elfcpp.h.
@
text
@d151 2
a152 1
      printf("    Timestamp sec = %ld\n", input->timestamp_sec);
@

