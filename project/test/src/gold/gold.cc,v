head	1.105;
access;
symbols
	binutils-2_24-branch:1.105.0.2
	binutils-2_24-branchpoint:1.105
	binutils-2_21_1:1.85.2.1
	binutils-2_23_2:1.100
	binutils-2_23_1:1.100
	binutils-2_23:1.100
	binutils-2_23-branch:1.100.0.2
	binutils-2_23-branchpoint:1.100
	binutils-2_22_branch:1.94.0.4
	binutils-2_22:1.94
	binutils-2_22-branch:1.94.0.2
	binutils-2_22-branchpoint:1.94
	binutils-2_21:1.85
	binutils-2_21-branch:1.85.0.2
	binutils-2_21-branchpoint:1.85
	binutils-2_20_1:1.67.2.1
	binutils-2_20:1.67.2.1
	binutils-arc-20081103-branch:1.59.0.4
	binutils-arc-20081103-branchpoint:1.59
	binutils-2_20-branch:1.67.0.2
	binutils-2_20-branchpoint:1.67
	dje-cgen-play1-branch:1.65.0.2
	dje-cgen-play1-branchpoint:1.65
	arc-20081103-branch:1.59.0.2
	arc-20081103-branchpoint:1.59
	binutils-2_19_1:1.57
	binutils-2_19:1.57
	binutils-2_19-branch:1.57.0.2
	binutils-2_19-branchpoint:1.57
	binutils_latest_snapshot:1.105
	added-to-binutils:1.51;
locks; strict;
comment	@// @;


1.105
date	2013.04.26.21.38.57;	author ccoutant;	state Exp;
branches;
next	1.104;

1.104
date	2013.03.10.23.08.18;	author amodra;	state Exp;
branches;
next	1.103;

1.103
date	2012.10.17.11.58.39;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2012.09.09.03.43.51;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2012.08.24.18.35.34;	author tmsriram;	state Exp;
branches;
next	1.100;

1.100
date	2012.07.16.19.00.18;	author tmsriram;	state Exp;
branches;
next	1.99;

1.99
date	2012.05.02.21.37.23;	author roland;	state Exp;
branches;
next	1.98;

1.98
date	2012.03.19.23.54.07;	author dougkwan;	state Exp;
branches;
next	1.97;

1.97
date	2011.10.18.00.06.09;	author ccoutant;	state Exp;
branches;
next	1.96;

1.96
date	2011.09.29.23.45.57;	author tmsriram;	state Exp;
branches;
next	1.95;

1.95
date	2011.09.26.23.42.06;	author ccoutant;	state Exp;
branches;
next	1.94;

1.94
date	2011.07.15.21.43.08;	author ian;	state Exp;
branches
	1.94.2.1;
next	1.93;

1.93
date	2011.06.09.18.18.44;	author ccoutant;	state Exp;
branches;
next	1.92;

1.92
date	2011.06.08.04.43.28;	author ccoutant;	state Exp;
branches;
next	1.91;

1.91
date	2011.06.08.03.50.10;	author ccoutant;	state Exp;
branches;
next	1.90;

1.90
date	2011.05.25.00.17.46;	author ian;	state Exp;
branches;
next	1.89;

1.89
date	2011.05.24.23.31.06;	author ccoutant;	state Exp;
branches;
next	1.88;

1.88
date	2011.05.23.23.27.10;	author ccoutant;	state Exp;
branches;
next	1.87;

1.87
date	2011.04.12.00.44.47;	author ccoutant;	state Exp;
branches;
next	1.86;

1.86
date	2010.11.05.21.14.12;	author ccoutant;	state Exp;
branches;
next	1.85;

1.85
date	2010.10.14.22.10.22;	author ccoutant;	state Exp;
branches
	1.85.2.1;
next	1.84;

1.84
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	2010.08.02.13.34.33;	author ian;	state Exp;
branches;
next	1.82;

1.82
date	2010.04.15.00.42.15;	author dougkwan;	state Exp;
branches;
next	1.81;

1.81
date	2010.04.07.21.42.22;	author dougkwan;	state Exp;
branches;
next	1.80;

1.80
date	2010.03.22.14.18.24;	author espindola;	state Exp;
branches;
next	1.79;

1.79
date	2010.02.23.17.42.26;	author ian;	state Exp;
branches;
next	1.78;

1.78
date	2010.02.12.04.33.53;	author ian;	state Exp;
branches;
next	1.77;

1.77
date	2010.02.11.07.42.17;	author ian;	state Exp;
branches;
next	1.76;

1.76
date	2010.01.06.05.30.24;	author ian;	state Exp;
branches;
next	1.75;

1.75
date	2009.12.29.00.22.43;	author ian;	state Exp;
branches;
next	1.74;

1.74
date	2009.10.29.05.16.23;	author ian;	state Exp;
branches;
next	1.73;

1.73
date	2009.10.14.05.25.01;	author ian;	state Exp;
branches;
next	1.72;

1.72
date	2009.10.13.21.17.43;	author tmsriram;	state Exp;
branches;
next	1.71;

1.71
date	2009.10.13.00.39.31;	author tmsriram;	state Exp;
branches;
next	1.70;

1.70
date	2009.10.09.22.38.07;	author ian;	state Exp;
branches;
next	1.69;

1.69
date	2009.10.06.22.58.27;	author ian;	state Exp;
branches;
next	1.68;

1.68
date	2009.09.30.22.21.13;	author ian;	state Exp;
branches;
next	1.67;

1.67
date	2009.09.01.17.32.34;	author ian;	state Exp;
branches
	1.67.2.1;
next	1.66;

1.66
date	2009.08.05.20.51.56;	author tmsriram;	state Exp;
branches;
next	1.65;

1.65
date	2009.06.24.19.48.51;	author ian;	state Exp;
branches;
next	1.64;

1.64
date	2009.06.24.05.01.16;	author ian;	state Exp;
branches;
next	1.63;

1.63
date	2009.03.14.05.56.46;	author ian;	state Exp;
branches;
next	1.62;

1.62
date	2009.03.13.21.30.06;	author ian;	state Exp;
branches;
next	1.61;

1.61
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	1.60;

1.60
date	2008.12.24.06.17.18;	author ccoutant;	state Exp;
branches;
next	1.59;

1.59
date	2008.10.07.23.40.21;	author ccoutant;	state Exp;
branches;
next	1.58;

1.58
date	2008.09.19.22.54.57;	author ccoutant;	state Exp;
branches;
next	1.57;

1.57
date	2008.05.21.21.37.44;	author ian;	state Exp;
branches;
next	1.56;

1.56
date	2008.05.09.14.13.06;	author ian;	state Exp;
branches;
next	1.55;

1.55
date	2008.05.07.06.08.01;	author ian;	state Exp;
branches;
next	1.54;

1.54
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.53;

1.53
date	2008.04.17.07.12.00;	author ian;	state Exp;
branches;
next	1.52;

1.52
date	2008.04.15.04.06.40;	author ian;	state Exp;
branches;
next	1.51;

1.51
date	2008.03.04.18.21.43;	author iant;	state Exp;
branches;
next	1.50;

1.50
date	2008.02.28.20.35.39;	author iant;	state Exp;
branches;
next	1.49;

1.49
date	2008.02.28.04.45.47;	author iant;	state Exp;
branches;
next	1.48;

1.48
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.47;

1.47
date	2008.02.26.21.45.30;	author iant;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.13.02.44.50;	author iant;	state Exp;
branches;
next	1.45;

1.45
date	2008.02.08.07.06.57;	author iant;	state Exp;
branches;
next	1.44;

1.44
date	2008.02.07.07.33.46;	author iant;	state Exp;
branches;
next	1.43;

1.43
date	2008.02.07.04.35.41;	author iant;	state Exp;
branches;
next	1.42;

1.42
date	2008.02.06.20.32.10;	author iant;	state Exp;
branches;
next	1.41;

1.41
date	2008.02.06.19.32.32;	author iant;	state Exp;
branches;
next	1.40;

1.40
date	2008.02.06.08.13.50;	author iant;	state Exp;
branches;
next	1.39;

1.39
date	2008.02.04.05.41.40;	author iant;	state Exp;
branches;
next	1.38;

1.38
date	2008.01.26.01.17.45;	author iant;	state Exp;
branches;
next	1.37;

1.37
date	2008.01.23.01.31.13;	author iant;	state Exp;
branches;
next	1.36;

1.36
date	2008.01.09.19.57.45;	author iant;	state Exp;
branches;
next	1.35;

1.35
date	2007.12.14.19.00.21;	author iant;	state Exp;
branches;
next	1.34;

1.34
date	2007.12.06.05.00.00;	author iant;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.29.20.10.16;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.28.19.39.40;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.22.00.05.51;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.14.18.44.57;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.14.16.53.24;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.14.07.34.53;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.13.20.02.32;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.26.22.27.52;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.26.22.12.03;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.17.06.24.50;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.16.23.23.08;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.14.06.49.13;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.14.04.06.18;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.14.02.52.13;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.28.06.36.25;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.26.07.01.34;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.22.04.42.09;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.01.16.51.25;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.30.23.52.50;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.03.18.26.10;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.10.20.20.40.49;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.06.20.40.16;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.29.19.58.16;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.27.22.53.42;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.26.21.00.34;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.21.22.13.18;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.18.22.29.20;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.04.23.10.59;	author iant;	state Exp;
branches;
next	;

1.94.2.1
date	2011.12.19.21.14.39;	author ian;	state Exp;
branches;
next	;

1.85.2.1
date	2011.02.27.15.17.29;	author ian;	state Exp;
branches;
next	;

1.67.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	;


desc
@@


1.105
log
@2013-04-26  Geoff Pike  <gpike@@chromium.org>

gold/
	* gold.cc (queue_final_tasks): invoke layout->queue_build_id_tasks().
	* layout.cc (Hash_task): New class.
	(Layout::queue_build_id_tasks): New function.
	(Layout::write_build_id): Handle single-thread portion of build ID
	computation.  (In some cases, all of it is single-threaded.)  Replace
	{sha1,md5}_process_bytes with {sha1,md5}_buffer to get the same
	functionality in fewer lines of code.
	* layout.h (Layout::queue_build_id_tasks): New function declaration.
	* options.h (General_options): make "--build-id" default to tree
	rather than sha1.  Add two new options related to --build-id=tree:
	--build-id-chunk-size-for-treehash and
	--build-id-min-file-size-for-treehash.
	* Makefile.am: add testing of --build-id=tree and related new options
	(these tests will be invoked by "make check").
	* Makefile.in: Regenerate.
@
text
@// gold.cc -- main linker functions

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <unistd.h>
#include <algorithm>
#include "libiberty.h"

#include "options.h"
#include "target-select.h"
#include "debug.h"
#include "workqueue.h"
#include "dirsearch.h"
#include "readsyms.h"
#include "symtab.h"
#include "common.h"
#include "object.h"
#include "layout.h"
#include "reloc.h"
#include "defstd.h"
#include "plugin.h"
#include "gc.h"
#include "icf.h"
#include "incremental.h"
#include "timer.h"

namespace gold
{

class Object;

const char* program_name;

static Task*
process_incremental_input(Incremental_binary*, unsigned int, Input_objects*,
			  Symbol_table*, Layout*, Dirsearch*, Mapfile*,
			  Task_token*, Task_token*);

void
gold_exit(Exit_status status)
{
  if (parameters != NULL
      && parameters->options_valid()
      && parameters->options().has_plugins())
    parameters->options().plugins()->cleanup();
  if (status != GOLD_OK && parameters != NULL && parameters->options_valid())
    unlink_if_ordinary(parameters->options().output_file_name());
  exit(status);
}

void
gold_nomem()
{
  // We are out of memory, so try hard to print a reasonable message.
  // Note that we don't try to translate this message, since the
  // translation process itself will require memory.

  // LEN only exists to avoid a pointless warning when write is
  // declared with warn_use_result, as when compiling with
  // -D_USE_FORTIFY on GNU/Linux.  Casting to void does not appear to
  // work, at least not with gcc 4.3.0.

  ssize_t len = write(2, program_name, strlen(program_name));
  if (len >= 0)
    {
      const char* const s = ": out of memory\n";
      len = write(2, s, strlen(s));
    }
  gold_exit(GOLD_ERR);
}

// Handle an unreachable case.

void
do_gold_unreachable(const char* filename, int lineno, const char* function)
{
  fprintf(stderr, _("%s: internal error in %s, at %s:%d\n"),
	  program_name, function, filename, lineno);
  gold_exit(GOLD_ERR);
}

// This class arranges to run the functions done in the middle of the
// link.  It is just a closure.

class Middle_runner : public Task_function_runner
{
 public:
  Middle_runner(const General_options& options,
		const Input_objects* input_objects,
		Symbol_table* symtab,
		Layout* layout, Mapfile* mapfile)
    : options_(options), input_objects_(input_objects), symtab_(symtab),
      layout_(layout), mapfile_(mapfile)
  { }

  void
  run(Workqueue*, const Task*);

 private:
  const General_options& options_;
  const Input_objects* input_objects_;
  Symbol_table* symtab_;
  Layout* layout_;
  Mapfile* mapfile_;
};

void
Middle_runner::run(Workqueue* workqueue, const Task* task)
{
  queue_middle_tasks(this->options_, task, this->input_objects_, this->symtab_,
		     this->layout_, workqueue, this->mapfile_);
}

// This class arranges the tasks to process the relocs for garbage collection.

class Gc_runner : public Task_function_runner
{
  public:
   Gc_runner(const General_options& options,
	     const Input_objects* input_objects,
	     Symbol_table* symtab,
	     Layout* layout, Mapfile* mapfile)
    : options_(options), input_objects_(input_objects), symtab_(symtab),
      layout_(layout), mapfile_(mapfile)
   { }

  void
  run(Workqueue*, const Task*);

 private:
  const General_options& options_;
  const Input_objects* input_objects_;
  Symbol_table* symtab_;
  Layout* layout_;
  Mapfile* mapfile_;
};

void
Gc_runner::run(Workqueue* workqueue, const Task* task)
{
  queue_middle_gc_tasks(this->options_, task, this->input_objects_,
			this->symtab_, this->layout_, workqueue,
			this->mapfile_);
}

// Queue up the initial set of tasks for this link job.

void
queue_initial_tasks(const General_options& options,
		    Dirsearch& search_path,
		    const Command_line& cmdline,
		    Workqueue* workqueue, Input_objects* input_objects,
		    Symbol_table* symtab, Layout* layout, Mapfile* mapfile)
{
  if (cmdline.begin() == cmdline.end())
    {
      bool is_ok = false;
      if (options.printed_version())
	is_ok = true;
      if (options.print_output_format())
	{
	  print_output_format();
	  is_ok = true;
	}
      if (is_ok)
	gold_exit(GOLD_OK);
      gold_fatal(_("no input files"));
    }

  int thread_count = options.thread_count_initial();
  if (thread_count == 0)
    thread_count = cmdline.number_of_input_files();
  workqueue->set_thread_count(thread_count);

  // For incremental links, the base output file.
  Incremental_binary* ibase = NULL;

  if (parameters->incremental_update())
    {
      Output_file* of = new Output_file(options.output_file_name());
      if (of->open_base_file(options.incremental_base(), true))
	{
	  ibase = open_incremental_binary(of);
	  if (ibase != NULL
	      && ibase->check_inputs(cmdline, layout->incremental_inputs()))
	    ibase->init_layout(layout);
	  else
	    {
	      delete ibase;
	      ibase = NULL;
	      of->close();
	    }
	}
      if (ibase == NULL)
	{
	  if (set_parameters_incremental_full())
	    gold_info(_("linking with --incremental-full"));
	  else
	    gold_fallback(_("restart link with --incremental-full"));
	}
    }

  // Read the input files.  We have to add the symbols to the symbol
  // table in order.  We do this by creating a separate blocker for
  // each input file.  We associate the blocker with the following
  // input file, to give us a convenient place to delete it.
  Task_token* this_blocker = NULL;
  if (ibase == NULL)
    {
      // Normal link.  Queue a Read_symbols task for each input file
      // on the command line.
      for (Command_line::const_iterator p = cmdline.begin();
	   p != cmdline.end();
	   ++p)
	{
	  Task_token* next_blocker = new Task_token(true);
	  next_blocker->add_blocker();
	  workqueue->queue(new Read_symbols(input_objects, symtab, layout,
					    &search_path, 0, mapfile, &*p, NULL,
					    NULL, this_blocker, next_blocker));
	  this_blocker = next_blocker;
	}
    }
  else
    {
      // Incremental update link.  Process the list of input files
      // stored in the base file, and queue a task for each file:
      // a Read_symbols task for a changed file, and an Add_symbols task
      // for an unchanged file.  We need to mark all the space used by
      // unchanged files before we can start any tasks running.
      unsigned int input_file_count = ibase->input_file_count();
      std::vector<Task*> tasks;
      tasks.reserve(input_file_count);
      for (unsigned int i = 0; i < input_file_count; ++i)
	{
	  Task_token* next_blocker = new Task_token(true);
	  next_blocker->add_blocker();
	  Task* t = process_incremental_input(ibase, i, input_objects, symtab,
					      layout, &search_path, mapfile,
					      this_blocker, next_blocker);
	  tasks.push_back(t);
	  this_blocker = next_blocker;
	}
      // Now we can queue the tasks.
      for (unsigned int i = 0; i < tasks.size(); i++)
	workqueue->queue(tasks[i]);
    }

  if (options.has_plugins())
    {
      Task_token* next_blocker = new Task_token(true);
      next_blocker->add_blocker();
      workqueue->queue(new Plugin_hook(options, input_objects, symtab, layout,
				       &search_path, mapfile, this_blocker,
				       next_blocker));
      this_blocker = next_blocker;
    }

  if (options.relocatable()
      && (options.gc_sections() || options.icf_enabled()))
    gold_error(_("cannot mix -r with --gc-sections or --icf"));

  if (options.gc_sections() || options.icf_enabled())
    {
      workqueue->queue(new Task_function(new Gc_runner(options,
						       input_objects,
						       symtab,
						       layout,
						       mapfile),
					 this_blocker,
					 "Task_function Gc_runner"));
    }
  else
    {
      workqueue->queue(new Task_function(new Middle_runner(options,
							   input_objects,
							   symtab,
							   layout,
							   mapfile),
					 this_blocker,
					 "Task_function Middle_runner"));
    }
}

// Process an incremental input file: if it is unchanged from the previous
// link, return a task to add its symbols from the base file's incremental
// info; if it has changed, return a normal Read_symbols task.  We create a
// task for every input file, if only to report the file for rebuilding the
// incremental info.

static Task*
process_incremental_input(Incremental_binary* ibase,
			  unsigned int input_file_index,
			  Input_objects* input_objects,
			  Symbol_table* symtab,
			  Layout* layout,
			  Dirsearch* search_path,
			  Mapfile* mapfile,
			  Task_token* this_blocker,
			  Task_token* next_blocker)
{
  const Incremental_binary::Input_reader* input_reader =
      ibase->get_input_reader(input_file_index);
  Incremental_input_type input_type = input_reader->type();

  // Get the input argument corresponding to this input file, matching on
  // the argument serial number.  If the input file cannot be matched
  // to an existing input argument, synthesize a new one.
  const Input_argument* input_argument =
      ibase->get_input_argument(input_file_index);
  if (input_argument == NULL)
    {
      Input_file_argument file(input_reader->filename(),
			       Input_file_argument::INPUT_FILE_TYPE_FILE,
			       "", false, parameters->options());
      Input_argument* arg = new Input_argument(file);
      arg->set_script_info(ibase->get_script_info(input_file_index));
      input_argument = arg;
    }

  gold_debug(DEBUG_INCREMENTAL, "Incremental object: %s, type %d",
	     input_reader->filename(), input_type);

  if (input_type == INCREMENTAL_INPUT_SCRIPT)
    {
      // Incremental_binary::check_inputs should have cancelled the
      // incremental update if the script has changed.
      gold_assert(!ibase->file_has_changed(input_file_index));
      return new Check_script(layout, ibase, input_file_index, input_reader,
			      this_blocker, next_blocker);
    }

  if (input_type == INCREMENTAL_INPUT_ARCHIVE)
    {
      Incremental_library* lib = ibase->get_library(input_file_index);
      gold_assert(lib != NULL);
      if (lib->filename() == "/group/"
	  || !ibase->file_has_changed(input_file_index))
	{
	  // Queue a task to check that no references have been added to any
	  // of the library's unused symbols.
	  return new Check_library(symtab, layout, ibase, input_file_index,
				   input_reader, this_blocker, next_blocker);
	}
      else
	{
	  // Queue a Read_symbols task to process the archive normally.
	  return new Read_symbols(input_objects, symtab, layout, search_path,
				  0, mapfile, input_argument, NULL, NULL,
				  this_blocker, next_blocker);
	}
    }

  if (input_type == INCREMENTAL_INPUT_ARCHIVE_MEMBER)
    {
      // For archive members, check the timestamp of the containing archive.
      Incremental_library* lib = ibase->get_library(input_file_index);
      gold_assert(lib != NULL);
      // Process members of a --start-lib/--end-lib group as normal objects.
      if (lib->filename() != "/group/")
	{
	  if (ibase->file_has_changed(lib->input_file_index()))
	    {
	      return new Read_member(input_objects, symtab, layout, mapfile,
				     input_reader, this_blocker, next_blocker);
	    }
	  else
	    {
	      // The previous contributions from this file will be kept.
	      // Mark the pieces of output sections contributed by this
	      // object.
	      ibase->reserve_layout(input_file_index);
	      Object* obj = make_sized_incremental_object(ibase,
							  input_file_index,
							  input_type,
							  input_reader);
	      return new Add_symbols(input_objects, symtab, layout,
				     search_path, 0, mapfile, input_argument,
				     obj, lib, NULL, this_blocker,
				     next_blocker);
	    }
	}
    }

  // Normal object file or shared library.  Check if the file has changed
  // since the last incremental link.
  if (ibase->file_has_changed(input_file_index))
    {
      return new Read_symbols(input_objects, symtab, layout, search_path, 0,
			      mapfile, input_argument, NULL, NULL,
			      this_blocker, next_blocker);
    }
  else
    {
      // The previous contributions from this file will be kept.
      // Mark the pieces of output sections contributed by this object.
      ibase->reserve_layout(input_file_index);
      Object* obj = make_sized_incremental_object(ibase,
						  input_file_index,
						  input_type,
						  input_reader);
      return new Add_symbols(input_objects, symtab, layout, search_path, 0,
			     mapfile, input_argument, obj, NULL, NULL,
			     this_blocker, next_blocker);
    }
}

// Queue up a set of tasks to be done before queueing the middle set
// of tasks.  This is only necessary when garbage collection
// (--gc-sections) of unused sections is desired.  The relocs are read
// and processed here early to determine the garbage sections before the
// relocs can be scanned in later tasks.

void
queue_middle_gc_tasks(const General_options& options,
		      const Task* ,
		      const Input_objects* input_objects,
		      Symbol_table* symtab,
		      Layout* layout,
		      Workqueue* workqueue,
		      Mapfile* mapfile)
{
  // Read_relocs for all the objects must be done and processed to find
  // unused sections before any scanning of the relocs can take place.
  Task_token* this_blocker = NULL;
  for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
       p != input_objects->relobj_end();
       ++p)
    {
      Task_token* next_blocker = new Task_token(true);
      next_blocker->add_blocker();
      workqueue->queue(new Read_relocs(symtab, layout, *p, this_blocker,
				       next_blocker));
      this_blocker = next_blocker;
    }

  // If we are given only archives in input, we have no regular
  // objects and THIS_BLOCKER is NULL here.  Create a dummy
  // blocker here so that we can run the middle tasks immediately.
  if (this_blocker == NULL)
    {
      gold_assert(input_objects->number_of_relobjs() == 0);
      this_blocker = new Task_token(true);
    }

  workqueue->queue(new Task_function(new Middle_runner(options,
						       input_objects,
						       symtab,
						       layout,
						       mapfile),
				     this_blocker,
				     "Task_function Middle_runner"));
}

// Queue up the middle set of tasks.  These are the tasks which run
// after all the input objects have been found and all the symbols
// have been read, but before we lay out the output file.

void
queue_middle_tasks(const General_options& options,
		   const Task* task,
		   const Input_objects* input_objects,
		   Symbol_table* symtab,
		   Layout* layout,
		   Workqueue* workqueue,
		   Mapfile* mapfile)
{
  Timer* timer = parameters->timer();
  if (timer != NULL)
    timer->stamp(0);

  // Add any symbols named with -u options to the symbol table.
  symtab->add_undefined_symbols_from_command_line(layout);

  // If garbage collection was chosen, relocs have been read and processed
  // at this point by pre_middle_tasks.  Layout can then be done for all
  // objects.
  if (parameters->options().gc_sections())
    {
      // Find the start symbol if any.
      Symbol* sym = symtab->lookup(parameters->entry());
      if (sym != NULL)
	symtab->gc_mark_symbol(sym);
      sym = symtab->lookup(parameters->options().init());
      if (sym != NULL && sym->is_defined() && !sym->is_from_dynobj())
	symtab->gc_mark_symbol(sym);
      sym = symtab->lookup(parameters->options().fini());
      if (sym != NULL && sym->is_defined() && !sym->is_from_dynobj())
	symtab->gc_mark_symbol(sym);
      // Symbols named with -u should not be considered garbage.
      symtab->gc_mark_undef_symbols(layout);
      gold_assert(symtab->gc() != NULL);
      // Do a transitive closure on all references to determine the worklist.
      symtab->gc()->do_transitive_closure();
    }

  // If identical code folding (--icf) is chosen it makes sense to do it
  // only after garbage collection (--gc-sections) as we do not want to
  // be folding sections that will be garbage.
  if (parameters->options().icf_enabled())
    {
      symtab->icf()->find_identical_sections(input_objects, symtab);
    }

  // Call Object::layout for the second time to determine the
  // output_sections for all referenced input sections.  When
  // --gc-sections or --icf is turned on, or when certain input
  // sections have to be mapped to unique segments, Object::layout
  // is called twice.  It is called the first time when symbols
  // are added.
  if (parameters->options().gc_sections()
      || parameters->options().icf_enabled()
      || layout->is_unique_segment_for_sections_specified())
    {
      for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
	   p != input_objects->relobj_end();
	   ++p)
	{
	  Task_lock_obj<Object> tlo(task, *p);
	  (*p)->layout(symtab, layout, NULL);
	}
    }

  // Layout deferred objects due to plugins.
  if (parameters->options().has_plugins())
    {
      Plugin_manager* plugins = parameters->options().plugins();
      gold_assert(plugins != NULL);
      plugins->layout_deferred_objects();
    }

  /* If plugins have specified a section order, re-arrange input sections
     according to a specified section order.  If --section-ordering-file is
     also specified, do not do anything here.  */
  if (parameters->options().has_plugins()
      && layout->is_section_ordering_specified()
      && !parameters->options().section_ordering_file ())
    {
      for (Layout::Section_list::const_iterator p
	     = layout->section_list().begin();
	   p != layout->section_list().end();
	   ++p)
	(*p)->update_section_layout(layout->get_section_order_map());
    }

  if (parameters->options().gc_sections()
      || parameters->options().icf_enabled())
    {
      for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
	   p != input_objects->relobj_end();
	   ++p)
	{
	  // Update the value of output_section stored in rd.
	  Read_relocs_data* rd = (*p)->get_relocs_data();
	  for (Read_relocs_data::Relocs_list::iterator q = rd->relocs.begin();
	       q != rd->relocs.end();
	       ++q)
	    {
	      q->output_section = (*p)->output_section(q->data_shndx);
	      q->needs_special_offset_handling =
		      (*p)->is_output_section_offset_invalid(q->data_shndx);
	    }
	}
    }

  // We have to support the case of not seeing any input objects, and
  // generate an empty file.  Existing builds depend on being able to
  // pass an empty archive to the linker and get an empty object file
  // out.  In order to do this we need to use a default target.
  if (input_objects->number_of_input_objects() == 0
      && layout->incremental_base() == NULL)
    parameters_force_valid_target();

  int thread_count = options.thread_count_middle();
  if (thread_count == 0)
    thread_count = std::max(2, input_objects->number_of_input_objects());
  workqueue->set_thread_count(thread_count);

  // Now we have seen all the input files.
  const bool doing_static_link =
    (!input_objects->any_dynamic()
     && !parameters->options().output_is_position_independent());
  set_parameters_doing_static_link(doing_static_link);
  if (!doing_static_link && options.is_static())
    {
      // We print out just the first .so we see; there may be others.
      gold_assert(input_objects->dynobj_begin() != input_objects->dynobj_end());
      gold_error(_("cannot mix -static with dynamic object %s"),
		 (*input_objects->dynobj_begin())->name().c_str());
    }
  if (!doing_static_link && parameters->options().relocatable())
    gold_fatal(_("cannot mix -r with dynamic object %s"),
	       (*input_objects->dynobj_begin())->name().c_str());
  if (!doing_static_link
      && options.oformat_enum() != General_options::OBJECT_FORMAT_ELF)
    gold_fatal(_("cannot use non-ELF output format with dynamic object %s"),
	       (*input_objects->dynobj_begin())->name().c_str());

  if (parameters->options().relocatable())
    {
      Input_objects::Relobj_iterator p = input_objects->relobj_begin();
      if (p != input_objects->relobj_end())
	{
	  bool uses_split_stack = (*p)->uses_split_stack();
	  for (++p; p != input_objects->relobj_end(); ++p)
	    {
	      if ((*p)->uses_split_stack() != uses_split_stack)
		gold_fatal(_("cannot mix split-stack '%s' and "
			     "non-split-stack '%s' when using -r"),
			   (*input_objects->relobj_begin())->name().c_str(),
			   (*p)->name().c_str());
	    }
	}
    }

  // For incremental updates, record the existing GOT and PLT entries,
  // and the COPY relocations.
  if (parameters->incremental_update())
    {
      Incremental_binary* ibase = layout->incremental_base();
      ibase->process_got_plt(symtab, layout);
      ibase->emit_copy_relocs(symtab);
    }

  if (is_debugging_enabled(DEBUG_SCRIPT))
    layout->script_options()->print(stderr);

  // For each dynamic object, record whether we've seen all the
  // dynamic objects that it depends upon.
  input_objects->check_dynamic_dependencies();

  // Do the --no-undefined-version check.
  if (!parameters->options().undefined_version())
    {
      Script_options* so = layout->script_options();
      so->version_script_info()->check_unmatched_names(symtab);
    }

  // Create any automatic note sections.
  layout->create_notes();

  // Create any output sections required by any linker script.
  layout->create_script_sections();

  // Define some sections and symbols needed for a dynamic link.  This
  // handles some cases we want to see before we read the relocs.
  layout->create_initial_dynamic_sections(symtab);

  // Define symbols from any linker scripts.
  layout->define_script_symbols(symtab);

  // TODO(csilvers): figure out a more principled way to get the target
  Target* target = const_cast<Target*>(&parameters->target());

  // Attach sections to segments.
  layout->attach_sections_to_segments(target);

  if (!parameters->options().relocatable())
    {
      // Predefine standard symbols.
      define_standard_symbols(symtab, layout);

      // Define __start and __stop symbols for output sections where
      // appropriate.
      layout->define_section_symbols(symtab);

      // Define target-specific symbols.
      target->define_standard_symbols(symtab, layout);
    }

  // Make sure we have symbols for any required group signatures.
  layout->define_group_signatures(symtab);

  Task_token* this_blocker = NULL;

  // Allocate common symbols.  We use a blocker to run this before the
  // Scan_relocs tasks, because it writes to the symbol table just as
  // they do.
  if (parameters->options().define_common())
    {
      this_blocker = new Task_token(true);
      this_blocker->add_blocker();
      workqueue->queue(new Allocate_commons_task(symtab, layout, mapfile,
						 this_blocker));
    }

  // If doing garbage collection, the relocations have already been read.
  // Otherwise, read and scan the relocations.
  if (parameters->options().gc_sections()
      || parameters->options().icf_enabled())
    {
      for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
	   p != input_objects->relobj_end();
	   ++p)
	{
	  Task_token* next_blocker = new Task_token(true);
	  next_blocker->add_blocker();
	  workqueue->queue(new Scan_relocs(symtab, layout, *p,
					   (*p)->get_relocs_data(),
					   this_blocker, next_blocker));
	  this_blocker = next_blocker;
	}
    }
  else
    {
      // Read the relocations of the input files.  We do this to find
      // which symbols are used by relocations which require a GOT and/or
      // a PLT entry, or a COPY reloc.  When we implement garbage
      // collection we will do it here by reading the relocations in a
      // breadth first search by references.
      //
      // We could also read the relocations during the first pass, and
      // mark symbols at that time.  That is how the old GNU linker works.
      // Doing that is more complex, since we may later decide to discard
      // some of the sections, and thus change our minds about the types
      // of references made to the symbols.
      for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
	   p != input_objects->relobj_end();
	   ++p)
	{
	  Task_token* next_blocker = new Task_token(true);
	  next_blocker->add_blocker();
	  workqueue->queue(new Read_relocs(symtab, layout, *p, this_blocker,
					   next_blocker));
	  this_blocker = next_blocker;
	}
    }

  if (this_blocker == NULL)
    {
      if (input_objects->number_of_relobjs() == 0)
	{
	  // If we are given only archives in input, we have no regular
	  // objects and THIS_BLOCKER is NULL here.  Create a dummy
	  // blocker here so that we can run the layout task immediately.
	  this_blocker = new Task_token(true);
	}
      else
	{
	  // If we failed to open any input files, it's possible for
	  // THIS_BLOCKER to be NULL here.  There's no real point in
	  // continuing if that happens.
	  gold_assert(parameters->errors()->error_count() > 0);
	  gold_exit(GOLD_ERR);
	}
    }

  // When all those tasks are complete, we can start laying out the
  // output file.
  workqueue->queue(new Task_function(new Layout_task_runner(options,
							    input_objects,
							    symtab,
							    target,
							    layout,
							    mapfile),
				     this_blocker,
				     "Task_function Layout_task_runner"));
}

// Queue up the final set of tasks.  This is called at the end of
// Layout_task.

void
queue_final_tasks(const General_options& options,
		  const Input_objects* input_objects,
		  const Symbol_table* symtab,
		  Layout* layout,
		  Workqueue* workqueue,
		  Output_file* of)
{
  Timer* timer = parameters->timer();
  if (timer != NULL)
    timer->stamp(1);

  int thread_count = options.thread_count_final();
  if (thread_count == 0)
    thread_count = std::max(2, input_objects->number_of_input_objects());
  workqueue->set_thread_count(thread_count);

  bool any_postprocessing_sections = layout->any_postprocessing_sections();

  // Use a blocker to wait until all the input sections have been
  // written out.
  Task_token* input_sections_blocker = NULL;
  if (!any_postprocessing_sections)
    {
      input_sections_blocker = new Task_token(true);
      input_sections_blocker->add_blockers(input_objects->number_of_relobjs());
    }

  // Use a blocker to block any objects which have to wait for the
  // output sections to complete before they can apply relocations.
  Task_token* output_sections_blocker = new Task_token(true);
  output_sections_blocker->add_blocker();

  // Use a blocker to block the final cleanup task.
  Task_token* final_blocker = new Task_token(true);
  // Write_symbols_task, Write_sections_task, Write_data_task,
  // Relocate_tasks.
  final_blocker->add_blockers(3);
  final_blocker->add_blockers(input_objects->number_of_relobjs());
  if (!any_postprocessing_sections)
    final_blocker->add_blocker();

  // Queue a task to write out the symbol table.
  workqueue->queue(new Write_symbols_task(layout,
					  symtab,
					  input_objects,
					  layout->sympool(),
					  layout->dynpool(),
					  of,
					  final_blocker));

  // Queue a task to write out the output sections.
  workqueue->queue(new Write_sections_task(layout, of, output_sections_blocker,
					   final_blocker));

  // Queue a task to write out everything else.
  workqueue->queue(new Write_data_task(layout, symtab, of, final_blocker));

  // Queue a task for each input object to relocate the sections and
  // write out the local symbols.
  for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
       p != input_objects->relobj_end();
       ++p)
    workqueue->queue(new Relocate_task(symtab, layout, *p, of,
				       input_sections_blocker,
				       output_sections_blocker,
				       final_blocker));

  // Queue a task to write out the output sections which depend on
  // input sections.  If there are any sections which require
  // postprocessing, then we need to do this last, since it may resize
  // the output file.
  if (!any_postprocessing_sections)
    {
      Task* t = new Write_after_input_sections_task(layout, of,
						    input_sections_blocker,
						    final_blocker);
      workqueue->queue(t);
    }
  else
    {
      Task_token* new_final_blocker = new Task_token(true);
      new_final_blocker->add_blocker();
      Task* t = new Write_after_input_sections_task(layout, of,
						    final_blocker,
						    new_final_blocker);
      workqueue->queue(t);
      final_blocker = new_final_blocker;
    }

  // Create tasks for tree-style build ID computation, if necessary.
  final_blocker = layout->queue_build_id_tasks(workqueue, final_blocker, of);

  // Queue a task to close the output file.  This will be blocked by
  // FINAL_BLOCKER.
  workqueue->queue(new Task_function(new Close_task_runner(&options, layout,
							   of),
				     final_blocker,
				     "Task_function Close_task_runner"));
}

} // End namespace gold.
@


1.104
log
@	* gold.cc (queue_middle_tasks): Move detect_odr_violations..
	* layout.cc (Layout_task_runner::run): ..to here.
	* symtab.h (struct Symbol_location): Extract from..
	(class Symbol_table): ..here.
	* symtab.cc (Symbol_table::linenos_from_loc): Invoke function_location.
	* target.h (class Target): Add function_location and
	do_function_location functions.
	(class Sized_target): Add do_function_location.
	* object.h (class Sized_relobj_file): Move find_shdr..
	(class Object): ..to here.
	* object.cc: Likewise.  Update to suit.  Instantiate.
	(Sized_relobj_file::find_eh_frame): Update find_shdr call.
	* powerpc.cc (class Powerpc_dynobj): New.
	(Target_powerpc::do_function_location): New function.
	(Powerpc_relobj::do_find_special_sections): Update find_shdr call.
	(Powerpc_dynobj::do_read_symbols): New function.
	(Target_powerpc::do_make_elf_object): Make a Powerpc_dynobj.
@
text
@d877 3
@


1.103
log
@	PR gold/14726
	* gold.cc (queue_middle_tasks): Call gc_mark_symbol on _init and _fini.
@
text
@a655 4
  // See if any of the input definitions violate the One Definition Rule.
  // TODO: if this is too slow, do this as a task, rather than inline.
  symtab->detect_odr_violations(task, options.output_file_name());

@


1.102
log
@	* target.h (Target::gc_mark_symbol, do_gc_mark_symbol): New functions.
	(Sized_target::gc_add_reference, do_gc_add_reference): New functions.
	* gc.h (gc_process_relocs): Call target gc_add_reference.
	* gold.cc (queue_middle_tasks): Use gc_mark_symbol on start sym.
	* symtab.cc (Symbol_table::gc_mark_undef_symbols): Use gc_mark_symbol.
	(Symbol_table::gc_mark_symbol): Call target gc_mark_symbol. Remove
	unnecessary cast.
	* powerpc.cc (Powerpc_relobj::get_opd_ent): Rearrange parameters
	to cater for when we don't need code offset.  Update use.
	(Powerpc_relobj::access_from_map_, opd_valid_): New vars.
	(Powerpc_relobj::access_from_map, add_reference, opd_valid,
	set_opd_valid): New functions.
	(Target_powerpc::do_gc_add_reference): New function.
	(Target_powerpc::gc_process_relocs): Call gc()->add_reference on
	stashed refs.
	(Target_powerpc::do_gc_mark_symbol): New function.
@
text
@d505 9
a513 3
      Symbol* start_sym = symtab->lookup(parameters->entry());
      if (start_sym != NULL)
	symtab->gc_mark_symbol(start_sym);
@


1.101
log
@Patch adds support to allow plugins to map selected subset of sections to unique
segments.


2012-08-24  Sriraman Tallam  <tmsriram@@google.com>

	* gold.cc (queue_middle_tasks): Call layout again when unique
	segments for sections is desired.
	* layout.cc (Layout::Layout): Initialize new members.
	(Layout::get_output_section_flags): New function.
	(Layout::choose_output_section): Call get_output_section_flags.
	(Layout::layout): Make output section for mapping to a unique segment.
	(Layout::insert_section_segment_map): New function.
	(Layout::attach_allocated_section_to_segment): Make unique segment for
	output sections marked so.
	(Layout::segment_precedes): Check for unique segments when sorting.
	* layout.h (Layout::Unique_segment_info): New struct.
	(Layout::Section_segment_map): New typedef.
	(Layout::insert_section_segment_map): New function.
	(Layout::get_output_section_flags): New function.
	(Layout::is_unique_segment_for_sections_specified): New function.
	(Layout::set_unique_segment_for_sections_specified): New function.
	(Layout::unique_segment_for_sections_specified_): New member.
	(Layout::section_segment_map_): New member.
	* object.cc (Sized_relobj_file<size, big_endian>::do_layout):
	Rename is_gc_pass_one to is_pass_one.
	Rename is_gc_pass_two to is_pass_two.
	Rename is_gc_or_icf to is_two_pass.
	Check for which pass based on whether symbols data is present.
	Make it two pass when unique segments for sections is desired.
	* output.cc (Output_section::Output_section): Initialize new
	members.
	* output.h (Output_section::is_unique_segment): New function.
	(Output_section::set_is_unique_segment): New function.
	(Output_section::is_unique_segment_): New member.
	(Output_section::extra_segment_flags): New function.
	(Output_section::set_extra_segment_flags): New function.
	(Output_section::extra_segment_flags_): New member.
	(Output_section::segment_alignment): New function.
	(Output_section::set_segment_alignment): New function.
	(Output_section::segment_alignment_): New member.
	(Output_segment::Output_segment): Initialize is_unique_segment_.
	(Output_segment::is_unique_segment): New function.
	(Output_segment::set_is_unique_segment): New function.
	(Output_segment::is_unique_segment_): New member.
	* plugin.cc (allow_unique_segment_for_sections): New function.
	(unique_segment_for_sections): New function.
	(Plugin::load): Add new functions to transfer vector.
	* Makefile.am (plugin_final_layout.readelf.stdout): Add readelf output.
	* Makefile.in: Regenerate.
	* testsuite/plugin_final_layout.sh: Check if unique segment
	functionality works.
	* testsuite/plugin_section_order.c (onload): Check if new interfaces
	are available.
	(allow_unique_segment_for_sections): New global.
	(unique_segment_for_sections): New global.
	(claim_file_hook): Call allow_unique_segment_for_sections.
	(all_symbols_read_hook): Call unique_segment_for_sections.


2012-08-24  Sriraman Tallam  <tmsriram@@google.com>

	* plugin-api.h (ld_plugin_allow_unique_segment_for_sections):
	New interface.
	(ld_plugin_unique_segment_for_sections): New interface.
	(LDPT_ALLOW_UNIQUE_SEGMENT_FOR_SECTIONS): New enum val.
	(LDPT_UNIQUE_SEGMENT_FOR_SECTIONS): New enum val.
	(tv_allow_unique_segment_for_sections): New member.
	(tv_unique_segment_for_sections): New member.
@
text
@d507 1
a507 9
	{
	  bool is_ordinary;
	  unsigned int shndx = start_sym->shndx(&is_ordinary);
	  if (is_ordinary)
	    {
	      symtab->gc()->worklist().push(
		Section_id(start_sym->object(), shndx));
	    }
	}
@


1.100
log
@2012-07-16  Sriraman Tallam  <tmsriram@@google.com>

	* gold.cc (queue_middle_tasks): Update function order only after
	deferred objects due to plugins are processed.
@
text
@d533 4
a536 3
  // --gc-sections or --icf is turned on, Object::layout is
  // called twice.  It is called the first time when the
  // symbols are added.
d538 2
a539 1
      || parameters->options().icf_enabled())
@


1.99
log
@	* configure.ac (ENABLE_GOLD): Consider *-*-nacl* targets ELF.
	* configure: Regenerate.

gold/
	* nacl.cc: New file.
	* nacl.h: New file.
	* Makefile.am (CCFILES, HFILES): Add them.
	* Makefile.in: Regenerate.
	* i386.cc (Output_data_plt_i386_nacl): New class.
	(Output_data_plt_i386_nacl_exec): New class.
	(Output_data_plt_i386_nacl_dyn): New class.
	(Target_i386_nacl): New class.
	(Target_selector_i386_nacl): New class.
	(target_selector_i386): Use it instead of Target_selector_i386.
	* x86_64.cc (Output_data_plt_x86_64_nacl): New class.
	(Target_x86_64_nacl): New class.
	(Target_selector_x86_64_nacl): New class.
	(target_selector_x86_64, target_selector_x32): Use it instead of
	Target_selector_x86_64.
	* arm.cc (Output_data_plt_arm_nacl): New class.
	(Target_arm_nacl): New class.
	(Target_selector_arm_nacl): New class.
	(target_selector_arm, target_selector_armbe): Use it instead of
	Target_selector_arm.

	* target-select.cc (select_target): Take new Input_file* and off_t
	arguments, pass them on to recognize method of selector.
	* object.cc (make_elf_sized_object): Update caller.
	* parameters.cc (parameters_force_valid_target): Likewise.
	* incremental.cc (make_sized_incremental_binary): Likewise.
	* target-select.h: Update decl.
	(Target_selector::recognize): Take new Input_file* argument,
	pass it on to do_recognize.
	(Target_selector::do_recognize): Take new Input_file* argument.
	* freebsd.h (Target_selector_freebsd::do_recognize): Likewise.
	* powerpc.cc (Target_selector_powerpc::do_recognize): Likewise.
	* sparc.cc (Target_selector_sparc::do_recognize): Likewise.
	* testsuite/testfile.cc (Target_selector::do_recognize): Likewise.

	* target.h (Target::Target_info): New members isolate_execinstr
	and rosegment_gap.
	(Target::isolate_execinstr, Target::rosegment_gap): New methods.
	* arm.cc (Target_arm::arm_info): Update initializer.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
	* sparc.cc (Target_sparc::sparc_info): Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
	* layout.cc (Layout::attach_allocated_section_to_segment):
	Take new const Target* argument.  If target->isolate_execinstr(), act
	like --rosegment.
	(Layout::find_first_load_seg): Take new const Target* argument;
	if target->isolate_execinstr(), reject PF_X segments.
	(Layout::relaxation_loop_body): Update caller.
	(Layout::set_segment_offsets): If target->isolate_execinstr(),
	reset file offset to zero when we hit LOAD_SEG, and then do a second
	loop over the segments before LOAD_SEG to reassign offsets after
	addresses have been determined.  Handle target->rosegment_gap().
	(Layout::attach_section_to_segment): Take new const Target* argument;
	pass it to attach_allocated_section_to_segment.
	(Layout::make_output_section): Update caller.
	(Layout::attach_sections_to_segments): Take new const Target* argument;
	pass it to attach_section_to_segment.
	* gold.cc (queue_middle_tasks): Update caller.
	* layout.h (Layout): Update method decls with new arguments.

	* arm.cc (Target_arm::Target_arm): Take optional argument for the
	Target_info pointer to use.
	(Target_arm::do_make_data_plt): New virtual method.
	(Target_arm::make_data_plt): New method that calls it.
	(Target_arm::make_plt_entry): Use it.
	(Output_data_plt_arm::Output_data_plt_arm): Take additional argument
	for the section alignment.
	(Output_data_plt_arm::do_first_plt_entry_offset): New abstract virtual
	method.
	(Output_data_plt_arm::first_plt_entry_offset): Call it.
	(Output_data_plt_arm::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_arm::get_plt_entry_size): Call it.
	(Output_data_plt_arm::do_fill_plt_entry): New abstract virtual method.
	(Output_data_plt_arm::fill_plt_entry): New method that calls it.
	(Output_data_plt_arm::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_arm::fill_first_plt_entry): New method that calls it.
	(Output_data_plt_arm::set_final_data_size): Use get_plt_entry_size
	method instead of sizeof(plt_entry).
	(Output_data_plt_arm::add_entry): Likewise.
	Use first_plt_entry_offset method instead of sizeof(first_plt_entry).
	(Target_arm::first_plt_entry_offset): Call method on this->plt_ rather
	than static method.
	(Target_arm::plt_entry_size): Likewise.
	(Output_data_plt_arm::first_plt_entry, Output_data_plt_arm::plt_entry):
	Move to ...
	(Output_data_plt_arm_standard): ... here, new class.
	(Output_data_plt_arm::do_write): Move guts of PLT filling to...
	(Output_data_plt_arm_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_arm_standard::do_fill_plt_entry): ... and here.

	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Take additional argument for the PLT entry size.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset):
	Use get_plt_entry_size method rather than plt_entry_size variable.
	(Output_data_plt_x86_64::reserve_slot): Likewise.
	(Output_data_plt_x86_64::do_adjust_output_section): Likewise.
	(Output_data_plt_x86_64::add_entry): Likewise.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Likewise.
	(Output_data_plt_x86_64::address_for_global): Likewise.
	(Output_data_plt_x86_64::address_for_local): Likewise.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::first_plt_entry_offset): Likewise.
	Make method non-static.
	(Output_data_plt_x86_64::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_x86_64::get_plt_entry_size): Just call that.
	(Output_data_plt_x86_64::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_x86_64::add_eh_frame): New method to call it.
	(Output_data_plt_x86_64::do_fill_first_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_first_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_tlsdesc_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_tlsdesc_entry): New method to call it.
	(Output_data_plt_x86_64::plt_entry_size)
	(Output_data_plt_x86_64::first_plt_entry)
	(Output_data_plt_x86_64::plt_entry)
	(Output_data_plt_x86_64::tlsdesc_plt_entry)
	(Output_data_plt_x86_64::plt_eh_frame_fde_size)
	(Output_data_plt_x86_64::plt_eh_frame_fde): Move to ...
	(Output_data_plt_x86_64_standard): ... here, new class.
	(Target_x86_64::Target_x86_64): Take optional argument for the
	Target_info pointer to use.
	(Target_x86_64::do_make_data_plt): New virtual method.
	(Target_x86_64::make_data_plt): New method to call it.
	(Target_x86_64::init_got_plt_for_update): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_x86_64::init):	Don't do add_eh_frame_for_plt here.
	(Target_x86_64::first_plt_entry_offset): Call method on this->plt_
	rather than static method.
	(Target_x86_64::plt_entry_size): Likewise.
	(Output_data_plt_x86_64::do_write): Use get_plt_entry_size method
	rather than plt_entry_size variable.  Move guts of PLT filling to...
	(Output_data_plt_x86_64_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_x86_64_standard::do_fill_plt_entry): ... and here ...
	(Output_data_plt_x86_64_standard::do_fill_tlsdesc_entry): ... and here.

	* i386.cc (Output_data_plt_i386::Output_data_plt_i386): Take
	additional argument for the section alignment.
	Don't do add_eh_frame_for_plt here.
	(Output_data_plt_i386::first_plt_entry_offset): Make the method
	non-static.  Use get_plt_entry_size method rather than plt_entry_size
	variable.
	(Output_data_plt_i386::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_i386::get_plt_entry_size): Call it.
	(Output_data_plt_i386::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_i386::add_eh_frame): New method to call it.
	(Output_data_plt_i386::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_first_plt_entry): New method to call it.
	(Output_data_plt_i386::do_fill_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_plt_entry): New method to call it.
	(Output_data_plt_i386::set_final_data_size): Use get_plt_entry_size
	method instead of plt_entry_size.
	(Output_data_plt_i386::plt_entry_size)
	(Output_data_plt_i386::plt_eh_frame_fde_size)
	(Output_data_plt_i386::plt_eh_frame_fde): Move to ...
	(Output_data_plt_i386_standard): ... here, new class.
	(Output_data_plt_i386_exec): New class.
	(Output_data_plt_i386::exec_first_plt_entry): Move to ...
	(Output_data_plt_i386_exec::first_plt_entry): ... here.
	(Output_data_plt_i386::exec_plt_entry): Move to ...
	(Output_data_plt_i386_exec::plt_entry): ... here.
	(Output_data_plt_i386_dyn): New class.
	(Output_data_plt_i386::first_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::first_plt_entry): ... here.
	(Output_data_plt_i386::dyn_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::plt_entry): ... here.
	(Target_i386::Target_i386): Take optional argument for the Target_info
	pointer to use.
	(Target_i386::do_make_data_plt): New virtual method.
	(Target_i386::make_data_plt): New method to call it.
	(Target_i386::make_plt_section): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_i386::add_entry): Use get_plt_entry_size method
	rather than plt_entry_size variable.
	(Output_data_plt_i386::add_local_ifunc_entry): Likewise.
	(Output_data_plt_i386::address_for_local): Likewise.
	(Output_data_plt_i386::do_write): Likewise.
	Move guts of PLT filling to...
	(Output_data_plt_i386_exec::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_i386_exec::do_fill_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_first_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_plt_entry): ... and here.

Change-Id: Id24b95600489835ff5e860a39c147203d4380c2b
@
text
@d548 8
a569 8
  // Layout deferred objects due to plugins.
  if (parameters->options().has_plugins())
    {
      Plugin_manager* plugins = parameters->options().plugins();
      gold_assert(plugins != NULL);
      plugins->layout_deferred_objects();
    }

@


1.98
log
@2012-03-19  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_define_standard_symbols): New method.
 	(Target_arm::do_finalize_sections): Remove code which defines
	__exidx_start and __exidx_end.  Make symbol table parameter
	anonymous as it is not used.
	* gold.cc (queue_middle_tasks): Call target hook to define any
	target-specific symbols.
	* target.h (Target::define_standard_symbols): New method.
	(Target::do_define_standard_symbols): Same.
	* testsuite/Makefile.am (arm_exidx_test): Dump relocations also.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/arm_exidx.s: Generate data relocations for __exidx_start
	and __exidx_end.
	* testsuite/arm_exidx_test.sh: Check that no unused dynamic
	relocations are generated for __exidx_start and __exidx_end.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d140 1
a140 1
class Gc_runner : public Task_function_runner 
d165 3
a167 3
  queue_middle_gc_tasks(this->options_, task, this->input_objects_, 
                        this->symtab_, this->layout_, workqueue, 
                        this->mapfile_);
d291 5
a295 5
                                                       symtab,
                                                       layout,
                                                       mapfile),
                                         this_blocker,
                                         "Task_function Gc_runner"));
d300 6
a305 6
                                                           input_objects,
                                                           symtab,
                                                           layout,
                                                           mapfile),
                                         this_blocker,
                                         "Task_function Middle_runner"));
d471 6
a476 6
                                                       input_objects,
                                                       symtab,
                                                       layout,
                                                       mapfile),
                                     this_blocker,
                                     "Task_function Middle_runner"));
d500 1
a500 1
  // at this point by pre_middle_tasks.  Layout can then be done for all 
d507 9
a515 9
        {
          bool is_ordinary;
          unsigned int shndx = start_sym->shndx(&is_ordinary);
          if (is_ordinary) 
            {
              symtab->gc()->worklist().push(
                Section_id(start_sym->object(), shndx));
            }
        }
d523 2
a524 2
  // If identical code folding (--icf) is chosen it makes sense to do it 
  // only after garbage collection (--gc-sections) as we do not want to 
d531 4
a534 4
  // Call Object::layout for the second time to determine the 
  // output_sections for all referenced input sections.  When 
  // --gc-sections or --icf is turned on, Object::layout is 
  // called twice.  It is called the first time when the 
d540 6
a545 6
           p != input_objects->relobj_end();
           ++p)
        {
          Task_lock_obj<Object> tlo(task, *p);
          (*p)->layout(symtab, layout, NULL);
        }
d557 3
a559 3
           p != layout->section_list().end();
           ++p)
        (*p)->update_section_layout(layout->get_section_order_map());
d568 1
a568 1
    }     
d574 14
a587 14
           p != input_objects->relobj_end();
           ++p)
        {
          // Update the value of output_section stored in rd.
          Read_relocs_data* rd = (*p)->get_relocs_data();
          for (Read_relocs_data::Relocs_list::iterator q = rd->relocs.begin();
               q != rd->relocs.end();
               ++q)
            {
              q->output_section = (*p)->output_section(q->data_shndx);
              q->needs_special_offset_handling = 
                      (*p)->is_output_section_offset_invalid(q->data_shndx);
            }
        }
d680 3
d684 1
a684 1
  layout->attach_sections_to_segments();
a685 2
  // TODO(csilvers): figure out a more principled way to get the target
  Target* target = const_cast<Target*>(&parameters->target());
d721 2
a722 2
           p != input_objects->relobj_end();
           ++p)
d726 1
a726 1
	  workqueue->queue(new Scan_relocs(symtab, layout, *p, 
d746 3
a748 3
           p != input_objects->relobj_end();
           ++p)
        {
d751 1
a751 1
          workqueue->queue(new Read_relocs(symtab, layout, *p, this_blocker,
d754 1
a754 1
        }
d766 1
a766 1
      else 
d781 1
a781 1
                                                            target,
@


1.97
log
@	* gold.cc: Include timer.h.
	(queue_middle_tasks): Stamp time.
	(queue_final_tasks): Likewise.
	* main.cc (main): Store timer in parameters.  Print timers
	for each pass.
	* parameters.cc (Parameters::Parameters): Initialize timer_.
	(Parameters::set_timer): New function.
	(set_parameters_timer): New function.
	* parameters.h (Parameters::set_timer): New function.
	(Parameters::timer): New function.
	(Parameters::timer_): New data member.
	(set_parameters_timer): New function.
	* timer.cc (Timer::stamp): New function.
	(Timer::get_pass_time): New function.
	* timer.h (Timer::stamp): New function.
	(Timer::get_pass_time): New function.
	(Timer::pass_times_): New data member.
@
text
@d682 2
d692 3
a775 2
  // TODO(csilvers): figure out a more principled way to get the target
  Target* target = const_cast<Target*>(&parameters->target());
@


1.96
log
@
2011-09-29 Sriraman Tallam  <tmsriram@@google.com>

	* layout.h (section_order_map_): New member.
	(get_section_order_map): New member function.
	* output.cc (Output_section::add_input_section): Check for patterns
	only when --section-ordering-file is specified.
	* gold.cc (queue_middle_tasks): Delay updating order of sections till
	output_sections have been formed.
	* layout.cc (Layout_Layout): Initialize section_order_map_.
	* plugin.cc (update_section_order): Store order in order_map. Do not
	update the order.
	* testsuite/Makefile.am: Add test case for plugin_final_layout.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_section_order.c: New file.
	* testsuite/plugin_final_layout.cc: New file.
	* testsuite/plugin_final_layout.sh: New file.
@
text
@d48 1
d491 4
d794 4
@


1.95
log
@	* gold/gold.cc (queue_initial_tasks): Move option checks ...
	* gold/options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.
@
text
@d542 14
@


1.94
log
@	* options.h (class General_options): Add --print-output-format.
	Move -EL next to -EB, for  better --help output.
	* target-select.cc: Include <cstdio>, "options.h", and
	"parameters.h".
	(Target_selector::do_target_bfd_name): New function.
	(print_output_format): New function.
	* target-select.h (class Target_selector): Update declarations.
	(Target_selector::target_bfd_name): New function.
	(print_output_format): Declare.
	* main.cc: Include "target-select.h".
	(main): Handle --print-output-format.
	* gold.cc: Include "target-select.h".
	(queue_initial_tasks): Handle --print-output-format when there are
	no input files.
	* parameters.cc (parameters_force_valid_target): Give a better
	error message if -EB/-EL does not match target.
	* freebsd.h (Target_selector_freebsd::do_target_bfd_name): New
	function.
@
text
@d200 1
a200 1
  if (parameters->incremental())
d202 2
a203 15
      if (options.relocatable())
	gold_error(_("incremental linking is incompatible with -r"));
      if (options.emit_relocs())
	gold_error(_("incremental linking is incompatible with --emit-relocs"));
      if (options.gc_sections())
	gold_error(_("incremental linking is incompatible with --gc-sections"));
      if (options.icf_enabled())
	gold_error(_("incremental linking is incompatible with --icf"));
      if (options.has_plugins())
	gold_error(_("incremental linking is incompatible with --plugin"));
      if (strcmp(options.compress_debug_sections(), "none") != 0)
	gold_error(_("incremental linking is incompatible with "
		     "--compress-debug-sections"));

      if (parameters->incremental_update())
d205 5
a209 2
	  Output_file* of = new Output_file(options.output_file_name());
	  if (of->open_base_file(options.incremental_base(), true))
d211 3
a213 17
	      ibase = open_incremental_binary(of);
	      if (ibase != NULL
		  && ibase->check_inputs(cmdline, layout->incremental_inputs()))
		ibase->init_layout(layout);
	      else
		{
		  delete ibase;
		  ibase = NULL;
		  of->close();
		}
	    }
	  if (ibase == NULL)
	    {
	      if (set_parameters_incremental_full())
		gold_info(_("linking with --incremental-full"));
	      else
		gold_fallback(_("restart link with --incremental-full"));
d215 7
@


1.94.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d200 1
a200 1
  if (parameters->incremental_update())
d202 15
a216 2
      Output_file* of = new Output_file(options.output_file_name());
      if (of->open_base_file(options.incremental_base(), true))
d218 15
a232 5
	  ibase = open_incremental_binary(of);
	  if (ibase != NULL
	      && ibase->check_inputs(cmdline, layout->incremental_inputs()))
	    ibase->init_layout(layout);
	  else
d234 4
a237 3
	      delete ibase;
	      ibase = NULL;
	      of->close();
a239 7
      if (ibase == NULL)
	{
	  if (set_parameters_incremental_full())
	    gold_info(_("linking with --incremental-full"));
	  else
	    gold_fallback(_("restart link with --incremental-full"));
	}
@


1.93
log
@	PR gold/12804
	* gold/gold.cc (queue_initial_tasks): Warn if --incremental is
	used with --compress-debug-sections.
	* gold/object.cc (Sized_relobj_file::do_layout): Report
	uncompressed size of compressed input sections.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d33 1
d179 1
d181 7
@


1.92
log
@	* common.cc (Symbol_table::do_allocate_commons_list): Call
	gold_fallback.
	* errors.cc (Errors::fatal): Adjust call to gold_exit.
	(Errors::fallback): New function.
	(gold_fallback): New function.
	* errors.h (Errors::fallback): New function.
	* gold.cc (gold_exit): Change status parameter to enum; adjust
	all callers.
	(queue_initial_tasks): Call gold_fallback.
	* gold.h: Include cstdlib.
	(Exit_status): New enum type.
	(gold_exit): Change status parameter to enum.
	(gold_fallback): New function.
	* layout.cc (Layout::set_section_offsets): Call gold_fallback.
	(Layout::create_symtab_sections): Likewise.
	(Layout::create_shdrs): Likewise.
	* main.cc (main): Adjust call to gold_exit.
	* output.cc (Output_data_got::add_got_entry): Call gold_fallback.
	(Output_data_got::add_got_entry_pair): Likewise.
	(Output_section::add_input_section): Likewise.
	(Output_section::add_output_section_data): Likewise.
	(Output_segment::set_section_list_addresses): Likewise.
	* x86_64.cc (Output_data_plt_x86_64::add_entry): Likewise.
@
text
@d203 3
@


1.91
log
@	* copy-relocs.cc (Copy_relocs::copy_reloc): Call make_copy_reloc
	instead of emit_copy_reloc.
	(Copy_relocs::emit_copy_reloc): Refactor.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* copy-relocs.h (Copy_relocs::emit_copy_reloc): Move to public
	section.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* gold.cc (queue_middle_tasks): Emit old COPY relocations from
	unchanged input files.
	* incremental-dump.cc (dump_incremental_inputs): Print "COPY" flag.
	* incremental.cc (Sized_incremental_binary::do_reserve_layout):
	Reserve BSS space for COPY relocations.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Output_section_incremental_inputs::write_info_blocks): Record
	whether a symbol is copied from a shared object.
	(Sized_incr_dynobj::do_add_symbols): Record COPY relocations.
	* incremental.h (enum Incremental_shlib_symbol_flags): New type.
	(INCREMENTAL_SHLIB_SYM_FLAGS_SHIFT): New constant.
	(Incremental_input_entry_reader::get_output_symbol_index): Add
	is_copy parameter.
	(Incremental_binary::emit_copy_relocs): New function.
	(Incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data member.
	(Sized_incremental_binary::add_copy_reloc): New function.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Copy_reloc): New struct.
	(Sized_incremental_binary::Copy_relocs): New typedef.
	(Sized_incremental_binary::copy_relocs_): New data member.
	* symtab.cc (Symbol_table::add_from_incrobj): Change return type.
	* symtab.h (Symbol_table::add_from_incrobj): Change return type.
	* target.h (Sized_target::emit_copy_reloc): New function.
	* x86_64.cc (Target_x86_64::emit_copy_reloc): New function.
@
text
@d61 1
a61 1
gold_exit(bool status)
d67 1
a67 1
  if (!status && parameters != NULL && parameters->options_valid())
d69 1
a69 1
  exit(status ? EXIT_SUCCESS : EXIT_FAILURE);
d90 1
a90 1
  gold_exit(false);
d100 1
a100 1
  gold_exit(false);
d179 1
a179 1
	gold_exit(true);
d225 1
a225 1
		gold_fatal(_("restart link with --incremental-full"));
d751 1
a751 1
	  gold_exit(false);
@


1.90
log
@	* archive.cc (Library_base::should_include_member): Pull in object
	from archive if it defines the entry symbol.
	* parameters.cc (Parameters::entry): New function.
	* parameters.h (class Parameters): Declare entry.
	* output.h (class Output_file_header): Remove entry_ field.
	* output.cc (Output_file_header::Output_file_header): Remove entry
	parameter.  Change all callers.
	(Output_file_header::entry): Use parameters->entry.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (Plugin_hook::run): Likewise.
@
text
@d625 2
a626 1
  // For incremental updates, record the existing GOT and PLT entries.
d631 1
@


1.89
log
@	* gold.cc (queue_initial_tasks): Pass incremental base filename
	to Output_file::open_base_file; don't print error message.
	* incremental-dump.cc (main): Adjust call to
	Output_file::open_for_modification.
	* incremental-dump.cc (main): Likewise.
	* incremental.cc (Incremental_inputs::report_command_line):
	Ignore --incremental-base option when comparing command lines.
	Ignore parameter when given as separate argument.
	* options.h (class General_options): Add --incremental-base.
	* output.cc (Output_file::Output_file):
	(Output_file::open_base_file): Add base_name and writable parameters;
	read base file into new file; print error message here.
	(Output_file::map_no_anonymous): Add writable parameter; adjust all
	callers.
	* output.h (Output_file::open_for_modification): Rename to...
	(Output_file::open_base_file): ...this; add base_name and
	writable parameters; adjust all callers.
	(Output_file::map_no_anonymous): Add writable parameter; adjust all
	callers.
	* testsuite/Makefile.am (incremental_test_4): Test
	--incremental-base.
	* testsuite/Makefile.in: Regenerate.
@
text
@d504 1
a504 5
      Symbol* start_sym;
      if (parameters->options().entry())
        start_sym = symtab->lookup(parameters->options().entry());
      else
        start_sym = symtab->lookup("_start");
@


1.88
log
@	* gold.cc (queue_middle_tasks): Process existing GOT/PLT entries.
	* incremental-dump.cc (dump_incremental_inputs): Mask high-order
	bit when checking got_type.
	* incremental.cc (Sized_incremental_binary::setup_readers):
	Store symbol table and string table locations; initialize bit vector
	of file status flags.
	(Sized_incremental_binary::do_reserve_layout): Set bit flag for
	unchanged files.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::get_symtab_view): Use stored locations.
	(Output_section_incremental_inputs::set_final_data_size): Record
	file index for each input file.
	(Output_section_incremental_inputs::write_got_plt): Store file index
	instead of input entry offset for each GOT entry.
	* incremental.h
	(Incremental_input_entry::Incremental_input_entry): Initialize new
	data member.
	(Incremental_input_entry::set_offset): Store file index.
	(Incremental_input_entry::get_file_index): New function.
	(Incremental_input_entry::file_index_): New data member.
	(Incremental_binary::process_got_plt): New function.
	(Incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data members.
	(Sized_incremental_binary::~Sized_incremental_binary): New destructor.
	(Sized_incremental_binary::set_file_is_unchanged): New function.
	(Sized_incremental_binary::file_is_unchanged): New function.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::file_status_): New data member.
	(Sized_incremental_binary::main_symtab_loc_): New data member.
	(Sized_incremental_binary::main_strtab_loc_): New data member.
	* output.cc (Output_data_got::Got_entry::write): Add case
	RESERVED_CODE.
	(Output_data_got::add_global): Call add_got_entry.
	(Output_data_got::add_global_plt): Likewise.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_global_pair_with_rela): Likewise.
	(Output_data_got::add_local): Call add_got_entry.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_local_pair_with_rela): Likewise.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_section::add_output_section_data): Edit FIXME.
	* output.h
	(Output_section_data_build::Output_section_data_build): New
	constructor with size parameter.
	(Output_data_space::Output_data_space): Likewise.
	(Output_data_got::Output_data_got): Initialize new data member; new
	constructor with size parameter.
	(Output_data_got::add_constant): Call add_got_entry.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(class Output_data_got::Got_entry): Add RESERVED_CODE.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_data_got::free_list_): New data member.
	* target.h (Sized_target::init_got_plt_for_update): New function.
	(Sized_target::register_global_plt_entry): New function.
	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Initialize new data member; call init; add constructor with PLT count.
	(Output_data_plt_x86_64::init): New function.
	(Output_data_plt_x86_64::add_relocation): New function.
	(Output_data_plt_x86_64::reserve_slot): New function.
	(Output_data_plt_x86_64::free_list_): New data member.
	(Target_x86_64::init_got_plt_for_update): New function.
	(Target_x86_64::register_global_plt_entry): New function.
	(Output_data_plt_x86_64::add_entry): Allocate from free list for
	incremental updates.
	(Output_data_plt_x86_64::add_relocation): New function.
	* testsuite/object_unittest.cc (Object_test): Set default options.
@
text
@d207 1
a207 5
	  if (!of->open_for_modification())
	    gold_info(_("incremental update not possible: "
			"cannot open %s"),
		      options.output_file_name());
	  else
@


1.87
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d633 7
@


1.86
log
@	PR gold/10708
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Hold a lock on the
	object when reading from the file.
	* gold.cc (queue_middle_tasks): Hold a lock on the object when doing
	second layout pass.
	* icf.cc (preprocess_for_unique_sections): Hold a lock on the object
	when reading section contents.
	(get_section_contents): Likewise.
	(icf::find_identical_sections): Likewise.
	* mapfile.cc (Mapfile::print_discarded_sections): Hold a lock on the
	object when reading from the file.
	* plugin.cc (Plugin_manager::layout_deferred_objects): Hold a lock on
	the object when doing deferred section layout.
@
text
@d51 2
d55 5
d188 3
d193 39
a231 11
      Incremental_checker incremental_checker(
          parameters->options().output_file_name(),
          layout->incremental_inputs());
      if (incremental_checker.can_incrementally_link_output_file())
        {
          // TODO: remove when incremental linking implemented.
          printf("Incremental linking might be possible "
              "(not implemented yet)\n");
        }
      // TODO: If we decide on an incremental build, fewer tasks
      // should be scheduled.
d239 17
a255 3
  for (Command_line::const_iterator p = cmdline.begin();
       p != cmdline.end();
       ++p)
d257 21
a277 6
      Task_token* next_blocker = new Task_token(true);
      next_blocker->add_blocker();
      workqueue->queue(new Read_symbols(input_objects, symtab, layout,
					&search_path, 0, mapfile, &*p, NULL,
					NULL, this_blocker, next_blocker));
      this_blocker = next_blocker;
d290 2
a291 3
  if (parameters->options().relocatable()
      && (parameters->options().gc_sections()
	  || parameters->options().icf_enabled()))
d294 1
a294 2
  if (parameters->options().gc_sections()
      || parameters->options().icf_enabled())
d316 123
d587 2
a588 1
  if (input_objects->number_of_input_objects() == 0)
@


1.85
log
@	* debug.h (DEBUG_INCREMENTAL): New flag.
	(debug_string_to_enum): Add DEBUG_INCREMENTAL).
	* gold.cc (queue_initial_tasks): Check parameters for incremental link
	mode.
	* incremental.cc (report_command_line): Ignore all forms of
	--incremental.
	* layout.cc (Layout::Layout): Check parameters for incremental link
	mode.
	* options.cc (General_options::parse_incremental): New function.
	(General_options::parse_no_incremental): New function.
	(General_options::parse_incremental_full): New function.
	(General_options::parse_incremental_update): New function.
	(General_options::incremental_mode_): New data member.
	(General_options::finalize): Check incremental_mode_.
	* options.h (General_options): Update help text for --incremental.
	Add --no-incremental, --incremental-full, --incremental-update.
	(General_options::Incremental_mode): New enum type.
	(General_options::incremental_mode): New function.
	(General_options::incremental_mode_): New data member.
	* parameters.cc (Parameters::incremental_mode_): New data member.
	(Parameters::set_options): Set incremental_mode_.
	(Parameters::set_incremental_full): New function.
	(Parameters::incremental): New function.
	(Parameters::incremental_update): New function.
	(set_parameters_incremental_full): New function.
	* parameters.h (Parameters::set_incremental_full): New function.
	(Parameters::incremental): New function.
	(Parameters::incremental_update): New function.
	(Parameters::incremental_mode_): New data member.
	(set_parameters_incremental_full): New function.
	* plugin.cc (Plugin_manager::add_input_file): Check parameters for
	incremental link mode.
	* reloc.cc (Sized_relobj::do_read_relocs): Likewise.
	(Sized_relobj::do_relocate_sections): Likewise.
	* testsuite/Makefile.am (incremental_test): Use --incremental-full
	option.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/incremental_test.sh: Filter all forms of --incremental.
@
text
@d362 1
@


1.85.2.1
log
@	Backport from mainline:
	2010-11-05  Cary Coutant  <ccoutant@@google.com>
	PR gold/10708
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Hold a lock on the
	object when reading from the file.
	* gold.cc (queue_middle_tasks): Hold a lock on the object when doing
	second layout pass.
	* icf.cc (preprocess_for_unique_sections): Hold a lock on the object
	when reading section contents.
	(get_section_contents): Likewise.
	(icf::find_identical_sections): Likewise.
	* mapfile.cc (Mapfile::print_discarded_sections): Hold a lock on the
	object when reading from the file.
	* plugin.cc (Plugin_manager::layout_deferred_objects): Hold a lock on
	the object when doing deferred section layout.
@
text
@a361 1
          Task_lock_obj<Object> tlo(task, *p);
@


1.84
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d181 1
a181 1
  if (cmdline.options().incremental())
@


1.83
log
@	PR 11855
	* script.cc (Script_options::Script_options): Initialize
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_assignment): Update
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_reference): New function.
	(script_symbol): New function.
	* script.h (class Script_options): Add symbol_definitions_ and
	symbol_references_ fields.
	(Script_options::referenced_const_iterator): New type.
	(Script_options::referenced_begin): New function.
	(Script_options::referenced_end): New function.
	(Script_options::is_referenced): New function.
	(Script_options::any_unreferenced): New function.
	* script-c.h (script_symbol): Declare.
	* yyscript.y (exp): Call script_symbol.
	* symtab.cc: Include "script.h".
	(Symbol_table::gc_mark_undef_symbols): Add layout parameter.
	Change all callers.  Check symbols referenced by scripts.
	(Symbol_table::add_undefined_symbols_from_command_line): Add
	layout parameter.  Change all callers.
	(Symbol_table::do_add_undefined_symbols_from_command_line):
	Likewise.  Break out loop body.  Check symbols referenced by
	scripts.
	(Symbol_table::add_undefined_symbol_from_command_line): New
	function broken out of
	do_add_undefined_symbols_from_command_line.
	* symtab.h (class Symbol_table): Update declarations.
	* archive.cc: Include "layout.h".
	(Archive::should_include_member): Add layout parameter.  Change
	all callers.  Check for symbol mentioned in expression.
	* archive.h (class Archive): Update declaration.
	* object.cc (Sized_relobj::do_should_include_member): Add layout
	parameter.
	* object.h (Object::should_include_member): Add layout parameter.
	Change all callers.
	(Object::do_should_include_member): Add layout parameter.
	(class Sized_relobj): Update declaration.
	* dynobj.cc (Sized_dynobj::do_should_include_member): Add layout
	parameter.
	* dynobj.h (class Sized_dynobj): Update declaration.
	* plugin.cc (Sized_pluginobj::do_should_include_member): Add
	layout parameter.
	* plugin.h (class Sized_pluginobj): Update declaration.
@
text
@d382 1
a382 1
          Read_relocs_data *rd = (*p)->get_relocs_data();
d658 1
a658 1
      Task_token *new_final_blocker = new Task_token(true);
@


1.82
log
@2010-04-14  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_output_section::fix_exidx_coverage): Mark object
	for local symbol recounting if we remove a section due to ICF.
	* gold.cc (queue_middle_gc_tasks): Create a dummy blocker if
	there are no regular objects in input.
@
text
@d312 1
a312 1
  symtab->add_undefined_symbols_from_command_line();
d336 1
a336 1
      symtab->gc_mark_undef_symbols();
@


1.81
log
@2010-04-07  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Replace "endianity" with "endianness" in comments.
	(Arm_exidx_cantunwind): Ditto.
	(Arm_relobj::Arm_relobj): Initialize merge_flags_and_attribures.
	(Arm_relobj::merge_flags_and_attributes): New method.
	(Arm_relobj::merge_flags_and_attributes_): New data member.
	(Arm_exidx_cantunwind::do_fixed_endian_write): Fix formatting.
	(Arm_relobj::scan_sections_for_stubs): Ditto.
	(Arm_relobj::do_read_symbols): Check to see if we really want to
	merge processor-specific flags and attributes.  Exit early if
	an object is empty except for section names and the undefined symbol.
	(Target_arm::do_finalize_sections): Move check for ELF format to
	Arm_relobj::do_read_symbols.  Merge processor specific flags and
	attributes from a regular object only when we have determined that
	it is aapropriate.  Do not create an .ARM.attributes section in
	output if there is no regular input object.
	(Target_arm::merge_processor_specific_flags): Check
	--warn-mismatch before printing any error.
	(Target_arm::merge_object_attributes): Ditto.
	* gold.cc (queue_middle_tasks): Handle the case in which there is
	no regular object in input.
	* options.cc (General_options::parse_EB): New method.
	(General_options::parse_EL): Same.
	(General_options::General_options): Initialize endianness_.
	* options.h (-EB, -EL, -no-pipeline-knowledge, -p, --warn-mismatch):
	New options.
	(General_options::Endianness): New enum.
	(General_options::endianness): New method.
	(General_options::endianness_): New data member.
	* parameters.cc (Parameters::set_options): Check target endianness.
	(Parameters::set_target_once): Ditto.
	(Parameters::check_target_endianness): New method.
	(parameters_force_valid_target): If either -EL or -EB is specified,
	use it to define endianness of default target.
	* parameters.h (Parameters::check_target_endianness): New method
	declaration.
	* target.h (class Target): Change "endianity" to "endianness"
	in comments.
@
text
@d279 10
@


1.80
log
@2010-03-22  Rafael Espindola  <espindola@@google.com>

	* archive.cc (Should_include): Move to archive.h.
	(should_include_member): Make it a member of Archive.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* archive.h: Include options.h.
	(Archive_member): Moved from Archive.
	(Should_include): Moved from archive.cc.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* dynobj.cc (do_should_include_member): New.
	* dynobj.h (do_should_include_member): New.
	* gold.cc (queue_initial_tasks): Update call to queue.
	* main.cc (main): Print lib group stats.
	* object.cc (do_should_include_member): New.
	* object.h: Include archive.h.
	(Object::should_include_member): New.
	(Object::do_should_include_member): New.
	(Sized_relobj::do_should_include_member): New.
	* options.cc (General_options::parse_start_lib): New.
	(General_options::parse_end_lib): New.
	(Input_arguments::add_file): Handle lib groups.
	(Input_arguments::start_group): Check we are not in a lib.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib): New.
	* options.h (General_options): Add start_lib and end_lib.
	(Input_argument::lib_): New.
	(Input_argument::lib): New.
	(Input_argument::is_lib): New.
	(Input_file_lib): New.
	(Input_arguments::in_lib_): New.
	(Input_arguments::in_lib): New.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib_): New.
	* plugin.cc (Pluginobj::get_symbol_resolution_info): Mark symbols
	in unused members as preempted.
	(Sized_pluginobj::do_should_include_member): New.
	* plugin.h (Sized_pluginobj::do_should_include_member): New.
	* readsyms.cc (Read_symbols::locks): If we are just reading a member,
	return the blocker.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::do_read_symbols): Handle lib groups.
	(Read_symbols::get_name): Handle lib groups.
	* readsyms.h (Read_symbols): Add an archive member pointer.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::member_): New.
	* script.cc (read_input_script): Update call to queue_soon.
@
text
@a534 3
  // If we failed to open any input files, it's possible for
  // THIS_BLOCKER to be NULL here.  There's no real point in
  // continuing if that happens.
d537 15
a551 2
      gold_assert(parameters->errors()->error_count() > 0);
      gold_exit(false);
@


1.79
log
@	* gold.cc (queue_middle_tasks): If no input files were opened,
	exit.
	* workqueue.h (Task_function::Task_function): Assert that there is
	a blocker.
@
text
@d209 1
a209 1
					this_blocker, next_blocker));
@


1.78
log
@	* gold.cc (queue_middle_gc_tasks): Use a separate blocker for each
	Read_relocs task.
	(queue_middle_tasks): Likewise, and also for Scan_relocs.  Run
	Allocate_commons_task first.
	* reloc.cc (Read_relocs::run): Pass next_blocker_ down to next
	task, rather than symtab_lock_.
	(Gc_process_relocs::~Gc_process_relocs): New function.
	(Gc_process_relocs::is_runnable): Check this_blocker_.
	(Gc_process_relocs::locks): Use next_blocker_ rather than
	blocker_.
	(Scan_relocs::~Scan_relocs): New function.
	(Scan_relocs::is_runnable): Check this_blocker_ rather than
	symtab_lock_.
	(Scan_relocs::locks): Drop symtab_lock_ and blocker_.  Add
	next_blocker_.
	* reloc.h (class Read_relocs): Drop symtab_lock_ and blocker_
	fields.  Add this_blocker_ and next_blocker_ fields.  Adjust
	constructor accordingly.
	(class Gc_process_relocs): Likewise.
	(class Scan_relocs): Likewise.
	* common.h (class Allocate_commons_task): Remove symtab_lock_
	field, and corresponding constructor parameter.
	* common.cc (Allocate_commons_tasK::is_runnable): Remove use of
	symtab_lock_.
	(Allocate_commons_task::locks): Likewise.
@
text
@d535 9
@


1.77
log
@	* dirsearch.cc (Dirsearch::initialize): Add all blockers before
	queueing any tasks.
	* gold.cc (queue_middle_gc_tasks): Likewise.  Fix final blocker.
	(queue_middle_tasks): Add all blockers before queueing any tasks.
	(queue_final_tasks): Likewise.
	* token.h (Task_token::add_blockers): New function.
	* object.h (Input_objects::number_of_relobjs): New function.
@
text
@d268 1
a268 3
  Task_token* blocker = new Task_token(true);
  blocker->add_blockers(input_objects->number_of_relobjs());
  Task_token* symtab_lock = new Task_token(false);
d272 7
a278 3
    workqueue->queue(new Read_relocs(symtab, layout, *p, symtab_lock,
				     blocker));

d284 1
a284 1
                                     blocker,
d480 5
a484 2
  Task_token* blocker = new Task_token(true);
  blocker->add_blockers(input_objects->number_of_relobjs());
d486 6
a491 3
    blocker->add_blocker();

  Task_token* symtab_lock = new Task_token(false);
d501 8
a508 3
	workqueue->queue(new Scan_relocs(symtab, layout, *p, 
					 (*p)->get_relocs_data(),
					 symtab_lock, blocker));
d527 5
a531 7
          // We can read and process the relocations in any order.  But we
          // only want one task to write to the symbol table at a time.
          // So we queue up a task for each object to read the
          // relocations.  That task will in turn queue a task to wait
          // until it can write to the symbol table.
          workqueue->queue(new Read_relocs(symtab, layout, *p, symtab_lock,
					   blocker));
a534 6
  // Allocate common symbols.  This requires write access to the
  // symbol table, but is independent of the relocation processing.
  if (parameters->options().define_common())
    workqueue->queue(new Allocate_commons_task(symtab, layout, mapfile,
					       symtab_lock, blocker));

d545 1
a545 1
				     blocker,
@


1.76
log
@	PR 10980
	* options.h (class General_options): Add --undefined-version.
	* script.cc (struct Version_expression): Add was_matched_by_symbol
	field.
	(Version_script_info::matched_symbol): New function.
	(Version_script_info::get_symbol_version_helper): Call
	matched_symbol.
	(Version_script_info::check_unmatched_names): New function.
	* script.h (class Version_script_info): Update declarations.
	* gold.cc (queue_middle_tasks): Handle --no-undefined-version.
@
text
@d269 1
d274 2
a275 6
    {
      // We can read and process the relocations in any order.  
      blocker->add_blocker();
      workqueue->queue(new Read_relocs(symtab, layout, *p, symtab_lock,
				       blocker));
    }
a276 1
  Task_token* this_blocker = new Task_token(true);
d282 1
a282 1
                                     this_blocker,
d479 4
d493 3
a495 6
        {
          blocker->add_blocker();
          workqueue->queue(new Scan_relocs(symtab, layout, *p, 
					   (*p)->get_relocs_data(),
					   symtab_lock, blocker));
        }
a518 1
          blocker->add_blocker();
d527 2
a528 5
    {
      blocker->add_blocker();
      workqueue->queue(new Allocate_commons_task(symtab, layout, mapfile,
						 symtab_lock, blocker));
    }
d566 4
a569 1
    input_sections_blocker = new Task_token(true);
d574 1
d578 6
a585 1
  final_blocker->add_blocker();
a594 2
  output_sections_blocker->add_blocker();
  final_blocker->add_blocker();
a598 1
  final_blocker->add_blocker();
d606 4
a609 9
    {
      if (input_sections_blocker != NULL)
	input_sections_blocker->add_blocker();
      final_blocker->add_blocker();
      workqueue->queue(new Relocate_task(symtab, layout, *p, of,
					 input_sections_blocker,
					 output_sections_blocker,
					 final_blocker));
    }
a616 1
      final_blocker->add_blocker();
@


1.75
log
@	* gold.cc (queue_middle_tasks): Fix formatting.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d446 7
@


1.74
log
@	* object.h (class Relobj): Drop options parameter from
	gc_process_relocs, scan_relocs, relocate, do_gc_process_relocs,
	do_scan_relocs, do_relocate.  Change all callers.
	(class Sized_relobj): Drop options parameters from
	do_gc_process_relocs, do_scan_relocs, do_relocate,
	do_relocate_sections, relocate_sections, emit_relocs_scan,
	emit_relocs_scan_reltype.  Change all callers.
	(struct Relocate_info): Remove options field and all references to
	it.
	* reloc.h (class Read_relocs): Remove options constructor
	parameter and options_ field.  Change all callers.
	(class Gc_process_relocs, class Scan_relocs): Likewise.
	(class Relocate_task): Likewise.
	* target-reloc.h (scan_relocs): Remove options parameter.  Change
	all callers.
	(scan_relocatable_relocs): Likewise.
	* target.h (class Sized_target): Remove options parameter from
	gc_process_relocs, scan_relocs, scan_relocatable_relocs.  Change
	all callers.
	* gc.h (gc_process_relocs): Remove options parameter.  Change all
	callers.
	* arm.cc: Update functions to remove options parameters.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* testsuite/testfile.cc: Likewise.
@
text
@d317 1
a317 1
      if (start_sym !=NULL)
@


1.73
log
@	Add support for -pie.
	* options.h (class General_options): Add -pie and
	--pic-executable.
	(General_options::output_is_position_independent): Test -pie.
	(General_options::output_is_executable): Return true if not shared
	and not relocatable.
	(General_options::output_is_pie): Remove.
	* options.cc (General_options::finalize): Reject incompatible uses
	of -pie.
	* gold.cc (queue_middle_tasks): A -pie link is not static.
	* symtab.h (Symbol::needs_plt_entry): Return false if -pie.
	* symtab.cc (Symbol::final_value_is_known): Return false if
	output_is_position_independent.
	* layout.cc (Layout::set_segment_offsets): Start at address 0 if
	output_is_position_independent.
	* output.cc (Output_file_header::do_sized_write): Use ET_DYN if
	output_is_position_independent.
	* i386.cc (Output_data_plt_i386::do_write): Use the PIC PLT if
	output_is_position_independent.
	* testsuite/Makefile.am (check_PROGRAMS): Add basic_pie_test and
	two_file_pie_test.
	(basic_pie_test.o, basic_pie_test): New targets.
	(two_file_test_1_pie.o, two_file_test_1b_pie.o): New targets.
	(two_file_test_2_pie.o, two_file_test_main_pie.o): New targets.
	(two_file_pie_test): New target.
	* testsuite/Makefile.in: Rebuild.
	* README: Remove note saying that -pie is not supported.
@
text
@d232 1
a232 1
                                                       input_objects,
d276 2
a277 2
      workqueue->queue(new Read_relocs(options, symtab, layout, *p,
				       symtab_lock, blocker));
d488 3
a490 2
          workqueue->queue(new Scan_relocs(options, symtab, layout, *p, 
                           (*p)->get_relocs_data(),symtab_lock, blocker));
d516 2
a517 2
          workqueue->queue(new Read_relocs(options, symtab, layout, *p,
                   symtab_lock, blocker));
d604 1
a604 1
      workqueue->queue(new Relocate_task(options, symtab, layout, *p, of,
@


1.72
log
@	* gc.h (gc_process_relocs): Check if icf is enabled using new
	function.
	* gold.cc (queue_initial_tasks): Likewise.
	(queue_middle_tasks): Likewise.
	* object.cc (do_layout): Likewise.
	* symtab.cc (is_section_folded): Likewise.
	* main.cc (main): Likewise.
	* reloc.cc (Read_relocs::run): Likewise.
	(Sized_relobj::do_scan_relocs): Likewise.
	* icf.cc (is_function_ctor_or_dtor): New function.
	(Icf::find_identical_sections): Check if function is ctor or dtor when
	safe icf is chosen.
	* options.h (General_options::icf): Change option to be an enum.
	(Icf_status): New enum.
	(icf_enabled): New method.
	(icf_safe_folding): New method.
	(set_icf_status): New method.
	(icf_status_): New variable.
	* (options.cc) (General_options::finalize): Set icf_status_.
	* testsuite/Makefile.am: Add commands to build icf_safe_test. Modify
	icf_test and icf_keep_unique_test to use the --icf enum flag.
	* testsuite/icf_safe_test.sh: New file.
	* testsuite/icf_safe_test.cc: New file.
@
text
@d399 3
a401 2
  const bool doing_static_link = (!input_objects->any_dynamic()
				  && !parameters->options().shared());
@


1.71
log
@	* symtab.h: Check for GOLD_SYMTAB_H before header includes. Remove
	includes to gc.h and icf.h.
	* arm.cc: Include gc.h.
	* gold.cc: Likewise.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* gc.h: Include icf.h.
@
text
@d224 2
a225 1
      && (parameters->options().gc_sections() || parameters->options().icf()))
d228 2
a229 1
  if (parameters->options().gc_sections() || parameters->options().icf())
d337 1
a337 1
  if (parameters->options().icf())
d347 2
a348 1
  if (parameters->options().gc_sections() || parameters->options().icf())
d366 2
a367 1
  if (parameters->options().gc_sections() || parameters->options().icf())
d479 2
a480 1
  if (parameters->options().gc_sections() || parameters->options().icf())
@


1.70
log
@elfcpp/:
	* elf_file.h: (class Elf_strtab): New class.
gold/:
	* gold.cc: (queue_initial_tasks): Pass incremental_inputs to
	Incremental_checker.
	* incremental.cc: (INCREMENTAL_LINK_VERSION): Change type to
	unsigned int.
	(class Incremental_inputs_header): New class.
	(Incremental_inputs_header_writer): Edit comment.
	(Incremental_inputs_entry): New class.
	(Incremental_inputs_entry_writer): Edit comment.
	(Sized_incremental_binary::do_find_incremental_inputs_section):
	Add *strtab_shndx parameter, fill it.
	(Sized_incremental_binary::do_check_inputs): New method.
	(Incremental_checker::can_incrementally_link_output_file): Use
	Sized_incremental_binary::check_inputs.
	(Incremental_inputs::report_command_line): Save command line in
	command_line_.
	* incremental.h:
	(Incremental_binary::find_incremental_inputs_section): New
	method.
	(Incremental_binary::do_find_incremental_inputs_section): Add
	strtab_shndx parameter.
	(Incremental_binary::do_check_inputs): New pure virtual method.
	(Sized_incremental_binary::do_check_inputs): Declare.
	(Incremental_checker::Incremental_checker): Add incremental_inputs
	parameter, use it to initialize incremental_inputs_.
	(Incremental_checker::incremental_inputs_): New field.
	(Incremental_checker::command_line): New method.
	(Incremental_checker::inputs): New method.
	(Incremental_checker::command_line_): New field.
@
text
@d44 1
@


1.69
log
@	* options.h (class General_options): Define
	split_stack_adjust_size parameter.
	* object.h (class Object): Add uses_split_stack_ and
	has_no_split_stack_ fields.  Add uses_split_stack and
	has_no_split_stack accessor functions.  Declare
	handle_split_stack_section.
	(class Reloc_symbol_changes): Define.
	(class Sized_relobj): Define Function_offsets.  Declare
	split_stack_adjust, split_stack_adjust_reltype, and
	find_functions.
	* object.cc (Object::handle_split_stack_section): New function.
	(Sized_relobj::do_layout): Call handle_split_stack_section.
	* dynobj.cc (Sized_dynobj::do_layout): Call
	handle_split_stack_section.
	* reloc.cc (Sized_relobj::relocate_sections): Call
	split_stack_adjust for executable sections in split_stack
	objects.  Pass reloc_map to relocate_section.
	(Sized_relobj::split_stack_adjust): New function.
	(Sized_relobj::split_stack_adjust_reltype): New function.
	(Sized_relobj::find_functions): New function.
	* target-reloc.h: Include "object.h".
	(relocate_section): Add reloc_symbol_changes parameter.  Change
	all callers.
	* target.h (class Target): Add calls_non_split method.  Declare
	do_calls_non_split virtual method.  Declare match_view and
	set_view_to_nop.
	* target.cc: Include "elfcpp.h".
	(Target::do_calls_non_split): New function.
	(Target::match_view): New function.
	(Target::set_view_to_nop): New function.
	* gold.cc (queue_middle_tasks): Give an error if mixing
	split-stack and non-split-stack objects with -r.
	* i386.cc (Target_i386::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_i386::do_calls_non_split): New function.
	* x86_64.cc (Target_x86_64::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_x86_64::do_calls_non_split): New function.
	* arm.cc (Target_arm::relocate_section): Add reloc_symbol_changes
	parameter.
	* powerpc.cc (Target_powerpc::relocate_section): Add
	reloc_symbol_changes parameter.
	* sparc.cc (Target_sparc::relocate_section): Add
	reloc_symbol_changes parameter.
	* configure.ac: Call AM_CONDITIONAL for the default target.
	* configure: Rebuild.
	* testsuite/Makefile.am (TEST_AS): New variable.
	(check_SCRIPTS): Add split_i386.sh and split_x86_64.sh.
	(check_DATA): Add split_i386 and split_x86_64 files.
	(SPLIT_DEFSYMS): Define.
	(split_i386_[1234n].o): New targets.
	(split_i386_[124]): New targets.
	(split_i386_[1234r].stdout): New targets.
	(split_x86_64_[1234n].o): New targets.
	(split_x86_64_[124]): New targets.
	(split_x86_64_[1234r].stdout): New targets.
	(MOSTLYCLEANFILES): Add new executables.
	* testsuite/split_i386.sh: New file.
	* testsuite/split_x86_64.sh: New file.
	* testsuite/split_i386_1.s: New file.
	* testsuite/split_i386_2.s: New file.
	* testsuite/split_i386_3.s: New file.
	* testsuite/split_i386_4.s: New file.
	* testsuite/split_i386_n.s: New file.
	* testsuite/split_x86_64_1.s: New file.
	* testsuite/split_x86_64_2.s: New file.
	* testsuite/split_x86_64_3.s: New file.
	* testsuite/split_x86_64_4.s: New file.
	* testsuite/split_x86_64_n.s: New file.
	* testsuite/testfile.cc (Target_test): Update relocation_section
	function.
	* testsuite/Makefile.in: Rebuild.
@
text
@d183 2
a184 1
          parameters->options().output_file_name());
@


1.68
log
@	* object.h (class Object): Remove target_ field, and target,
	sized_target, and set_target methods.
	(Object::sized_target): Remove.
	(class Sized_relobj): Update declarations.  Remove sized_target.
	* object.cc (Sized_relobj::setup): Remove target parameter.
	Change all callers.
	(Input_objects::add_object): Don't do anything with the target.
	(make_elf_sized_object): Add punconfigured parameter.  Change all
	callers.  Set or test parameter target.
	* dynobj.cc (Sized_dynobj::target): Remove target parameter.
	Change all callers.
	* parameters.cc (Parameters::set_target): Change parameter type to
	be non-const.
	(Parameters::default_target): Remove.
	(set_parameters_target): Change parameter type to be non-const.
	(parameters_force_valid_target): New function.
	(parameters_clear_target): New function.
	* parameters.h (class Parameters): Update declarations.  Remove
	default_target method.  Add sized_target and clear_target
	methods.  Change target_ to be non-const.
	(set_parameters_target): Update declaration.
	(parameters_force_valid_target): Declare.
	(parameters_clear_target): Declare.
	* readsyms.cc (Read_symbols::do_read_symbols): Pass punconfigured
	as NULL if we aren't searching.
	(Add_symbols::run): Don't check for compatible target.
	* fileread.cc (Input_file::open_binary): Call
	parameters_force_valid_target.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (make_sized_plugin_object): Likewise.  Don't call
	set_target on object.
	* dynobj.h (class Sized_dynobj): Update declarations.
	* archive.cc (Archive::get_elf_object_for_member): Return NULL if
	make_elf_object returns NULL.
	(Archive::include_member): Don't check whether object target is
	compatible.
	* output.cc (Output_section::add_input_section): Get target from
	parameters.
	(Output_section::relax_input_section): Likewise.
	* reloc.cc (Sized_relobj::do_gc_process_relocs): Get target from
	parameters.
	(Sized_relobj::do_scan_relocs): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* symtab.cc (Symbol_table::wrap_symbol): Likewise.  Remove object
	parameter.  Change all callers.
	(Symbol_table::add_from_object): Get target from parameters.
	(Symbol_table::add_from_relobj): Don't check object target.
	(Symbol_table::add_from_dynobj): Likewise.
	(Symbol_table::define_special_symbol): Get target from
	parameters.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/binary_unittest.cc (gold_testsuite): Remove target
	parameter.  Change all callers.  Clear parameter target.
	(Binary_test): Test target here.
	* testsuite/object_unittest.cc (gold_testsuite): Remove
	target_test_pointer parameter.  Change all callers.
	(Object_test): Test target here.
@
text
@d411 17
@


1.67
log
@	* gold.cc: Include "incremental.h".
	(queue_initial_tasks): Call Incremental_checker methods.
	* incremental.cc: Include "output.h".
	(Incremental_checker::can_incrementally_link_output_file): New
	method.
	* incremental.h (Incremental_checker): New class.
@
text
@d385 1
a385 1
    set_parameters_target(&parameters->default_target());
@


1.67.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a43 1
#include "gc.h"
d183 1
a183 2
          parameters->options().output_file_name(),
          layout->incremental_inputs());
d222 1
a222 2
      && (parameters->options().gc_sections()
	  || parameters->options().icf_enabled()))
d225 1
a225 2
  if (parameters->options().gc_sections()
      || parameters->options().icf_enabled())
d333 1
a333 1
  if (parameters->options().icf_enabled())
d343 1
a343 2
  if (parameters->options().gc_sections()
      || parameters->options().icf_enabled())
d361 1
a361 2
  if (parameters->options().gc_sections()
      || parameters->options().icf_enabled())
d385 1
a385 1
    parameters_force_valid_target();
d393 2
a394 3
  const bool doing_static_link =
    (!input_objects->any_dynamic()
     && !parameters->options().output_is_position_independent());
a410 17
  if (parameters->options().relocatable())
    {
      Input_objects::Relobj_iterator p = input_objects->relobj_begin();
      if (p != input_objects->relobj_end())
	{
	  bool uses_split_stack = (*p)->uses_split_stack();
	  for (++p; p != input_objects->relobj_end(); ++p)
	    {
	      if ((*p)->uses_split_stack() != uses_split_stack)
		gold_fatal(_("cannot mix split-stack '%s' and "
			     "non-split-stack '%s' when using -r"),
			   (*input_objects->relobj_begin())->name().c_str(),
			   (*p)->name().c_str());
	    }
	}
    }

d456 1
a456 2
  if (parameters->options().gc_sections()
      || parameters->options().icf_enabled())
@


1.66
log
@*** empty log message ***
@
text
@d45 1
d180 14
d247 2
a248 2
// Queue up a set of tasks to be done before queueing the middle set 
// of tasks.  This is only necessary when garbage collection 
@


1.65
log
@	PR 10156
	* layout.cc (Layout::choose_output_section): If we find an
	existing section, update the flags.
	(Layout::create_notes): New function, broken out of
	Layout::finalize.
	(Layout::finalize): Don't create note sections.
	(Layout::create_note): Don't crash if linker script discards
	section.
	(Layout::create_gold_note): Likewise.
	(Layout::create_build_id): Likewise.  Don't set
	after_input_sections on the section.
	(Layout::create_executable_stack_info): Remove target parameter.
	Change caller.
	* layout.h (class Layout): Declare create_notes.  Update
	declaration of create_executable_stack_info.
	* gold.cc (queue_middle_tasks): Call create_notes.
	* output.cc (Output_section::update_flags_for_input_section): Move
	here from output.h.  If SHF_ALLOC flag is newly set, mark address
	invalid.
	* output.h (Output_data::mark_address_invalid): New function.
	(class Output_section): Only declare, not define,
	update_flags_for_input_section.  Remove set_flags.
@
text
@d44 1
d207 2
a208 2
      && parameters->options().gc_sections())
    gold_error(_("cannot mix -r with garbage collection"));
d210 1
a210 1
  if (parameters->options().gc_sections())
d313 17
a329 2
      // Call do_layout again to determine the output_sections for all 
      // referenced input sections.
d337 1
d345 2
a346 1
  if (parameters->options().gc_sections())
d441 1
a441 1
  if (parameters->options().gc_sections())
@


1.64
log
@	PR 10237
	* options.cc (General_options::parse_V): Set printed_version_.
	(General_options::General_options): Initialize printed_version_.
	* options.h (class General_options): Add printed_version_ field.
	* gold.cc (queue_initial_tasks): If there are no input files,
	don't give a fatal error if we printed the version information.
	(queue_middle_tasks): If using -r with a shared object, give a
	fatal error rather than an ordinary error.
@
text
@d389 3
@


1.63
log
@	* readsyms.cc (Read_symbols::incompatible_warning): New function.
	(Read_symbols::requeue): New function.
	(Read_symbols::do_read_symbols): If make_elf_object fails because
	the target type is not configured, and the file was searched for,
	issue a warning and retry with the next directory.
	(Add_symbols::run): If the file has an incompatible format, and
	it was searched for, requeue the Read_symbols task.  On error,
	release the object.
	* readsyms.h (class Read_symbols): Add dirindex_ field.  Add
	dirindex parameter to constructor.  Change all callers.  Declare
	incompatible_warning and requeue.
	(class Add_symbols): Add dirpath_, dirindex_, mapfile_,
	input_argument_ and input_group_ fields.  Add them to
	constructor.  Change all callers.
	(class Read_script): Add dirindex_ field.  Add it to constructor.
	Change all callers.
	* archive.cc (Archive::setup): Remove input_objects parameter.
	Change all callers.
	(Archive::get_file_and_offset): Likewise.
	(Archive::read_all_symbols): Likewise.
	(Archive::read_symbols): Likewise.
	(Archive::get_elf_object_for_member): Remove input_objects
	parameter.  Add punconfigured parameter.  Change all callers.
	(Archive::add_symbols): Change return type to bool.  Check return
	value of include_member.
	(Archive::include_all_members): Likewise.
	(Archive::include_member): Change return type to bool.  Return
	false if first included object has incompatible target.  Set
	included_member_ field.
	(Add_archive_symbols::run): If add_symbols returns false, requeue
	Read_symbols task.
	* archive.h (class Archive): Add included_member_ field.
	Initialize it in constructor.  Add input_file and searched_for
	methods.  Update declarations.
	(class Add_archive_symbols): Add dirpath_, dirindex_, and
	input_argument_ fields.  Add them to constructor.  Change all
	callers.
	* script.cc: Include "target-select.h".
	(class Parser_closure): Add skip_on_incompatible_target_ and
	found_incompatible_target_ fields.  Add
	skip_on_incompatible_target parameter to constructor.  Change all
	callers.  Add methods skip_on_incompatible_target,
	clear_skip_on_incompatible_target, found_incompatible_target, and
	set_found_incompatible_target.
	(read_input_script): Add dirindex parameter.  Change all callers.
	If parser finds an incompatible target, requeue Read_symbols
	task.
	(script_set_symbol): Clear skip_on_incompatible_target in
	closure.
	(script_add_assertion, script_parse_option): Likewise.
	(script_start_sections, script_add_phdr): Likewise.
	(script_check_output_format): New function.
	* script.h (read_input_script): Update declaration.
	* script-c.h (script_check_output_format): Declare.
	* yyscript.y (file_cmd): Handle OUTPUT_FORMAT.
	(ignore_cmd): Remove OUTPUT_FORMAT.
	* fileread.cc (Input_file::Input_file): Add explicit this.
	(Input_file::will_search_for): New function.
	(Input_file::open): Add pindex parameter.  Change all callers.
	* fileread.h (class Input_file): Add input_file_argument method.
	Declare will_search_for.  Update declarations.
	* object.cc (make_elf_object): Add punconfigured parameter.
	Change all callers.
	* object.h (class Object): Make input_file public.  Add
	searched_for method.
	(make_elf_object): Update declaration.
	* dirsearch.cc (Dirsearch::find): Add pindex parameter.  Use it to
	restart search.
	* dirsearch.h (class Dirsearch): Update declaration.
	* options.h (class General_options): Add --warn-search-mismatch.
	* parameters.cc (Parameters::is_compatible_target): New function.
	* parameters.h (class Parameters): Declare is_compatible_target.
	* workqueue.cc (Workqueue::add_blocker): New function.
	* workqueue.h (class Workqueue): Declare add_blocker.
@
text
@d167 5
a171 1
    gold_fatal(_("no input files"));
d371 1
a371 1
    gold_error(_("cannot mix -r with dynamic object %s"),
@


1.62
log
@	* fileread.cc (Input_file::open): Remove options parameter.
	Change all callers.
	(Input_file::open_binary): Likewise.
	* script.cc (read_input_script): Likewise.
	* readsyms.h (class Read_symbols): Remove options_ field.  Remove
	options parameter from constructor.  Change all callers.
	(class Read_script): Likewise.
	* fileread.h (class Input_file): Update declarations.
	* script.h (read_input_script): Update declaration.
@
text
@d186 1
a186 1
					&search_path, mapfile, &*p, NULL,
@


1.61
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d185 1
a185 1
      workqueue->queue(new Read_symbols(options, input_objects, symtab, layout,
@


1.60
log
@	* gold.cc (gold_exit): Call plugin cleanup handlers on exit.
	* plugin.cc (Plugin_manager::finish): Rename as
	layout_deferred_objects.  Move cleanup to separate function.
	(Plugin_manager::cleanup): New function.
	(Plugin_finish::run): Call layout_deferred_objects and cleanup
	separately.
	* plugin.h (Plugin_manager::finish): Rename as
	layout_deferred_objects.
	(Plugin_manager::cleanup): New function.
	(Plugin_manager::cleanup_done): New field.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d125 32
d201 56
d258 6
a263 6
						       input_objects,
						       symtab,
						       layout,
						       mapfile),
				     this_blocker,
				     "Task_function Middle_runner"));
d279 64
a394 3
  // Add any symbols named with -u options to the symbol table.
  symtab->add_undefined_symbols_from_command_line();

a410 11
  // Read the relocations of the input files.  We do this to find
  // which symbols are used by relocations which require a GOT and/or
  // a PLT entry, or a COPY reloc.  When we implement garbage
  // collection we will do it here by reading the relocations in a
  // breadth first search by references.
  //
  // We could also read the relocations during the first pass, and
  // mark symbols at that time.  That is how the old GNU linker works.
  // Doing that is more complex, since we may later decide to discard
  // some of the sections, and thus change our minds about the types
  // of references made to the symbols.
d413 15
a427 3
  for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
       p != input_objects->relobj_end();
       ++p)
d429 24
a452 8
      // We can read and process the relocations in any order.  But we
      // only want one task to write to the symbol table at a time.
      // So we queue up a task for each object to read the
      // relocations.  That task will in turn queue a task to wait
      // until it can write to the symbol table.
      blocker->add_blocker();
      workqueue->queue(new Read_relocs(options, symtab, layout, *p,
				       symtab_lock, blocker));
@


1.59
log
@	* options.c (General_options::finalize): Add check for -static and
	-shared.
	* gold.cc (queue_middle_tasks): Assert that list of dynamic objects
	is not empty.
@
text
@d53 4
@


1.58
log
@Add plugin functionality for link-time optimization (LTO).

include/:
	* plugin-api.h: New file.

gold/:
	* configure.ac (plugins): Add --enable-plugins option.
	* configure: Regenerate.
	* config.in: Regenerate.
	* Makefile.am (LIBDL): New variable.
	(CCFILES): Add plugin.cc.
	(HFILES): Add plugin.h.
	(ldadd_var): Add LIBDL.
	* Makefile.in: Regenerate.

	* archive.cc: Include "plugin.h".
	(Archive::setup): Don't preread archive symbols when using a plugin.
	(Archive::get_file_and_offset): Add memsize parameter.  Change callers.
	(Archive::get_elf_object_for_member): Call plugin hooks for claiming
	files.
	(Archive::include_member): Add symbols from plugin objects.
	* archive.h (Archive::get_file_and_offset): Add memsize parameter.
	* descriptors.cc (Descriptors::open): Check for file descriptors
	abandoned by plugins.
	(Descriptors::claim_for_plugin): New function.
	* descriptors.h (Descriptors::claim_for_plugin): New function.
	(Open_descriptor::is_claimed): New field.
	(claim_descriptor_for_plugin): New function.
	* fileread.cc (File_read::claim_for_plugin): New function.
	* fileread.h (File_read::claim_for_plugin): New function.
	(File_read::descriptor): New function.
	* gold.cc: Include "plugin.h".
	(queue_initial_tasks): Add task to call plugin hooks for generating
	new object files.
	* main.cc: Include "plugin.h".
	(main): Load plugin libraries.
	* object.h (Pluginobj): Declare.
	(Object::pluginobj): New function.
	(Object::do_pluginobj): New function.
	(Object::set_target): New function.
	* options.cc: Include "plugin.h".
	(General_options::parse_plugin): New function.
	(General_options::General_options): Initialize plugins_ field.
	(General_options::add_plugin): New function.
	* options.h (Plugin_manager): Declare.
	(General_options): Add --plugin option.
	(General_options::has_plugins): New function.
	(General_options::plugins): New function.
	(General_options::add_plugin): New function.
	(General_options::plugins_): New field.
	* plugin.cc: New file.
	* plugin.h: New file.
	* readsyms.cc: Include "plugin.h".
	(Read_symbols::do_read_symbols): Check for archive before checking
	for ELF file.  Call plugin hooks to claim files.
	* resolve.cc (Symbol_table::resolve): Record when symbol is referenced
	from a real object file; force override when processing replacement
	files.
	* symtab.cc (Symbol::init_fields): Initialize in_real_elf_ field.
	(Symbol::init_base_object): Likewise.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): Likewise.
	(Symbol::output_section): Assert that object is not a plugin.
	(Symbol_table::add_from_pluginobj): New function.
	(Symbol_table::sized_finalize_symbol): Treat symbols from plugins as
	undefined.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::add_from_pluginobj): Instantiate template.
	* symtab.h (Sized_pluginobj): Declare.
	(Symbol::in_real_elf): New function.
	(Symbol::set_in_real_elf): New function.
	(Symbol::in_real_elf_): New field.
	(Symbol_table::add_from_pluginobj): New function.

	* testsuite/Makefile.am (AM_CFLAGS): New variable.
	(LIBDL): New variable.
	(LDADD): Add LIBDL.
	(check_PROGRAMS): Add plugin_test_1 and plugin_test_2.
	(check_SCRIPTS): Add plugin_test_1.sh and plugin_test_2.sh.
	(check_DATA): Add plugin_test_1.err and plugin_test_2.err.
	(MOSTLYCLEANFILES): Likewise.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_test.c: New file.
	* testsuite/plugin_test_1.sh: New file.
	* testsuite/plugin_test_2.sh: New file.
@
text
@d206 1
@


1.57
log
@	* mapfile.cc: New file.
	* mapfile.h: New file.
	* options.h (class General_options): Add -M/--print-map and -Map.
	* options.cc (General_options::finalize): Make -M equivalent to
	-Map -.
	* main.cc: Include <cstdio> and "mapfile.h".
	(main): Open mapfile if requested.
	* gold.cc (class Middle_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(queue_initial_tasks): Add mapfile parameter.  Change caller.
	(queue_middle_tasks): Likewise.
	* gold.h (queue_initial_tasks, queue_middle_tasks): Update
	declarations.
	* archive.cc: Include "mapfile.h".
	(Archive::add_symbols): Add mapfile parameter.  Change all
	callers.  Pass mapfile, symbol, and reason to include_member.
	(Archive::include_all_members): Add mapfile parameter.  Change all
	callers.
	(Archive::include_member): Add mapfile, sym, and why parameters.
	Change all callers.  Report inclusion to map file.
	* archive.h: Include "fileread.h".
	(class Archive): Update declarations.
	(Archive::file): New const method.
	(class Add_archive_symbols): Add mapfile_ field.  Update
	constructor.  Change all callers.
	* readsyms.h (class Read_symbols): Likewise.
	(class Finish_group): Likewise.
	(class Read_script): Likewise.
	* common.cc: Include "mapfile.h".
	(Symbol_table::allocate_commons): Add mapfile parameter.  Change
	all callers.
	(Symbol_table::do_allocate_commons): Likewise.
	(Symbol_table::do_allocate_commons_list): Likewise.  Report common
	symbol allocation to mapfile.
	* common.h (class Allocate_commons_task): Add mapfile_ field.
	Update constructor.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* layout.cc: Include "mapfile.h".
	(Layout_task_runner::run): Print information to mapfile.
	(Layout::create_gold_note): Change Output_data_fixed_space to
	Output_data_zero_fill.
	(Layout::create_build_id): Likewise.
	(Layout::print_to_mapfile): New function.
	* layout.h (class Layout_task_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(class Layout): Declare print_to_mapfile.
	* output.cc (Output_section::Input_section::print_to_mapfile): New
	function.
	(Output_section::add_input_section): If producing a map, always
	add to input_sections_ list.
	(Output_section::do_print_to_mapfile): New function.
	(Output_segment::print_sections_to_mapfile): New function.
	(Output_segment::print_section_list_to_mapfile): New function.
	* output.h: Include "mapfile.h".
	(Output_data::print_to_mapfile): New function.
	(Output_data::do_print_to_mapfile): New virtual function.
	(Output_segment_headers::do_print_to_mapfile): New function.
	(Output_file_header::do_print_to_mapfile): New function.
	(Output_data_const::do_print_to_mapfile): New function.
	(class Output_data_const_buffer): Add map_name_ field.  Update
	constructor.  Change all callers.  Add do_print_to_mapfile
	function.
	(class Output_data_fixed_space): Likewise.
	(class Output_data_space): Likewise.
	(class Output_data_zero_fill): New class.
	(Output_data_strtab::do_print_to_mapfile): New function.
	(Output_data_reloc_base::do_print_to_mapfile): New function.
	(Output_relocatable_relocs::do_print_to_mapfile): New function.
	(Output_data_group::do_print_to_mapfile): New function.
	(Output_data_got::do_print_to_mapfile): New function.
	(Output_data_dynamic::do_print_to_mapfile): New function.
	(Output_symtab_xindex::do_print_to_mapfile): New function.
	(class Output_section): Declare do_print_to_mapflie.  Declare
	print_to_mapfile in Input_section.
	(class Output_segment): Declare new functions.
	* object.h (Sized_relobj::symbol_count): New function.
	* script-sections.cc
	(Output_section_element_dot_assignment::set_section_addresses):
	Change Output_data_fixed_space to Output_data_zero_fill.
	(Output_data_expression::do_print_to_mapfile): New function.
	* script.cc (read_input_script): Add mapfile parameter.  Change
	all callers.
	* script.h (read_input_script): Update declaration.
	* ehframe.h (Eh_frame_hdr::do_print_to_mapfile): New function.
	(Eh_frame::do_print_to_mapfile): New function.
	* merge.h (Output_merge_data::do_print_to_mapfile): New function.
	(Output_merge_string::do_print_to_mapfile): New function.
	* i386.cc (Output_data_plt_i386::do_print_to_mapfile): New
	function.
	* sparc.cc (Output_data_plt_sparc::do_print_to_mapfile): New
	function.
	* x86_64.cc (Output_data_plt_x86_64::do_print_to_mapfile): New
	function.
	* Makefile.am (CCFILES): Add mapfile.cc.
	(HFILES): Add mapfile.h.
	* Makefile.in: Rebuild.
@
text
@d43 1
d155 10
@


1.56
log
@	PR 6493
	* gold.cc (gold_nomem): Use return value of write.
@
text
@d97 1
a97 1
		Layout* layout)
d99 1
a99 1
      layout_(layout)
d110 1
d117 1
a117 1
		     this->layout_, workqueue);
d127 1
a127 1
		    Symbol_table* symtab, Layout* layout)
d149 2
a150 2
					&search_path, &*p, NULL, this_blocker,
					next_blocker));
d157 2
a158 1
						       layout),
d173 2
a174 1
		   Workqueue* workqueue)
d278 2
a279 2
      workqueue->queue(new Allocate_commons_task(symtab, layout, symtab_lock,
						 blocker));
d290 2
a291 1
							    layout),
@


1.55
log
@	PR 6049
	* options.h (DEFINE_set): Add VARNAME_begin and VARNAME_end
	functions.
	(class General_options): Remove existing --undefined, and add
	--no-undefined instead.  Add new --undefined as synonym for -u.
	* archive.cc (Archive::add_symbols): Check whether symbol was
	named with -u.
	* gold.cc (queue_middle_tasks): Add -u symbols to symbol table.
	* symtab.h (class Symbol): Rename CONSTANT to IS_CONSTANT; change
	all uses.  Add IS_UNDEFINED.  Update declarations to split
	different versions of init_base.  Declare init_base_undefined.
	(Symbol::is_defined): Handle IS_UNDEFINED.
	(Symbol::is_undefined): Likewise.
	(Symbol::is_weak_undefined): Call is_undefined.
	(Symbol::is_absolute): Handle IS_CONSTANT.
	(class Sized_symbol): Update declarations to split different
	versions of init.  Declare init_undefined.
	(class Symbol_table): Declare new functions.
	* symtab.cc (Symbol::init_base_object): Rename from init_base.
	Change all callers.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): New function.
	(Sized_symbol::init_object): Rename from init.  Change all
	callers.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Sized_symbol::init_undefined): New function.
	(Symbol_table::add_undefined_symbols_from_command_line): New
	function.
	(Symbol_table::do_add_undefined_symbols_from_command_line): New
	function.
	(Symbol::final_value_is_known): Handle IS_UNDEFINED.
	(Symbol::output_section): Likewise.
	(Symbol::set_output_section): Likewise.
	(Symbol_table::sized_finalize_symbol): Likewise.
	(Symbol_table::sized_write_globals): Likewise.
	* resolve.cc (Symbol_table::should_override): Likewise.
	(Symbol::override_base_with_special): Likewise.
@
text
@d63 12
a74 3
  write(2, program_name, strlen(program_name));
  const char* const s = ": out of memory\n";
  write(2, s, strlen(s));
@


1.54
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d215 3
@


1.53
log
@	* common.cc (Symbol_table::allocate_commons): Remove options
	parameter.  Change caller.
	(Symbol_table::do_allocate_commons): Remove options parameter.
	Change caller.  Just call do_allocate_commons_list twice.
	(Symbol_table::do_allocate_commons_list): New function, broken out
	of do_allocate_commons.
	* common.h (class Allocate_commons_task): Remove options_ field.
	Update constructor.
	* symtab.cc (Symbol_table::Symbol_table): Initialize
	tls_commons_.
	(Symbol_table::add_from_object): Put TLS common symbols on
	tls_commons_ list.
	(Symbol_table::sized_finalize_symbol): Handle STT_TLS symbols
	which are IN_OUTPUT_DATA.
	* symtab.h (class Symbol_table): Add tls_commons_ field.  Update
	allocate_commons and do_allocate_commons declarations.  Declare
	do_allocate_commons_list.
	* gold.cc (queue_middle_tasks): Update creation of
	Allocate_commons_task to not pass options.
	* testsuite/Makefile.am (INCLUDES): Add -I.. .
	(TLS_TEST_C_FLAGS): New variable.
	(tls_test_c_pic.o): New target.
	(tls_test_shared.so): Link in tls_test_c_pic.o.
	(tls_test_c_pic_ie.o): New target.
	(tls_test_ie_shared.so): Link in tls_test_c_pic_ie.o.
	(tls_test_DEPENDENCIES, tls_test_LDADD): Add tls_test_c.o.
	(tls_test_c.o): New target.
	(tls_pic_test_DEPENDENCIES): Add tls_test_c_pic.o.
	(tls_pic_test_LDADD): Likewise.
	(tls_shared_gd_to_ie_test_DEPENDENCIES): Add tls_test_c_pic.o.
	(tls_shared_gd_to_ie_test_LDADD): Likewise.
	(tls_test_c_gnu2.o): New target.
	(tls_shared_gnu2_gd_to_ie_test_DEPENDENCIES): Add
	tls_test_c_gnu2.o.
	(tls_shared_gnu2_gd_to_ie_test_LDADD): Likewise.
	(tls_test_gnu2_shared.so): Link in tls_test_c_gnu2.o.
	(tls_test_shared_nonpic.so): Link in tls_test_c.o.
	* testsuite/tls_test.cc: Include "config.h".
	(t_last): Call t11_last.
	* testsuite/tls_test.h (t11, t11_last): Declare.
	* testsuite/tls_test_c.c: New file.
	* testsuite/tls_test_main.cc (thread_routine): Call t11.
	* configure.ac: Check for OpenMP support.
	* configure, config.in, Makefile.in: Rebuild.
	* testsuite/Makefile.in: Rebuild.
@
text
@d313 2
a314 1
  workqueue->queue(new Write_symbols_task(symtab,
@


1.52
log
@	* layout.cc (Layout::Layout): Initialize sections_are_attached_.
	(Layout::get_output_section): Ignore SHF_WRITE and SHF_EXECINSTR
	in the name/type/flags to section mapping.  Don't call
	allocate_output_section.
	(Layout::choose_output_section): Change parameter from adjust_name
	to is_input_section.  Don't permit input sections after sections
	are attached to segments.  Don't call allocate_output_section.
	(Layout::layout_eh_frame): Call update_flags_for_input_section,
	not write_enable_output_section.
	(Layout::make_output_section): Don't push to
	unattached_section_list_ nor call attach_to_segment.  Call
	attach_section_to_segment if sections are attached.
	(Layout::attach_sections_to_segments): New function.
	(Layout::attach_section_to_segment): New function.
	(Layout::attach_allocated_section_to_segment): Rename from
	attach_to_segment.  Remove flags parameter.
	(Layout::allocate_output_section): Remove function.
	(Layout::write_enable_output_section): Remove function.
	* layout.h (class Layout): Update for above changes.  Add new
	field sections_are_attached_.
	* output.h (Output_section::update_flags_for_input_section): New
	function.
	* output.cc (Output_section::add_input_section): Call
	update_flags_for_input_section.
	* gold.cc (queue_middle_tasks): Call attach_sections_to_segments.
@
text
@d263 2
a264 2
      workqueue->queue(new Allocate_commons_task(options, symtab, layout,
						 symtab_lock, blocker));
@


1.51
log
@From Craig Silverstein: rename some option functions in preparation
for reworking option handling.
@
text
@d215 3
@


1.50
log
@Support -d/--define-common.
@
text
@d190 1
a190 1
      && options.oformat() != General_options::OBJECT_FORMAT_ELF)
@


1.49
log
@Don't check assertions until symbols are finalized.  Create an output
section if the script uses a data statement with no input sections.
Don't create a loadable segment for the headers if there is no room.
@
text
@d257 1
a257 3
  // FIXME: We should have an option to do this even for a relocatable
  // link.
  if (!parameters->options().relocatable())
@


1.48
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d205 3
@


1.47
log
@From Craig Silverstein: rename option functions for future option
handling rewrite.
@
text
@d53 1
a53 1
    unlink_if_ordinary(parameters->output_file_name());
d169 1
a169 1
    set_parameters_target(options.default_target());
d178 1
a178 1
				  && !parameters->output_is_shared());
d186 1
a186 1
  if (!doing_static_link && parameters->output_is_object())
d212 1
a212 1
  if (!parameters->output_is_object())
d256 1
a256 1
  if (!parameters->output_is_object())
d265 2
d270 1
@


1.46
log
@Support selecting target by name.
@
text
@d190 1
a190 1
      && options.output_format() != General_options::OBJECT_FORMAT_ELF)
@


1.45
log
@Add support for --format binary for input files.
@
text
@a33 1
#include "target-select.h"
d169 1
a169 9
    {
      // The GOLD_xx macros are defined by the configure script.
      Target* target = select_target(elfcpp::GOLD_DEFAULT_MACHINE,
				     GOLD_DEFAULT_SIZE,
				     GOLD_DEFAULT_BIG_ENDIAN,
				     0, 0);
      gold_assert(target != NULL);
      set_parameters_target(target);
    }
@


1.44
log
@Support --oformat binary.
@
text
@d199 1
a199 1
      && options.output_format() != General_options::OUTPUT_FORMAT_ELF)
@


1.43
log
@Even when stripping all symbols, we need to write out the dynamic
symbol table.
@
text
@d198 4
d372 2
a373 1
  workqueue->queue(new Task_function(new Close_task_runner(of),
@


1.42
log
@Support creating empty output when there are no input objects.
@
text
@d310 7
a316 10
  if (!options.strip_all())
    {
      final_blocker->add_blocker();
      workqueue->queue(new Write_symbols_task(symtab,
					      input_objects,
					      layout->sympool(),
					      layout->dynpool(),
					      of,
					      final_blocker));
    }
@


1.41
log
@Fix group signature handling for relocatable link, add bootstrap
relocatable test.
@
text
@d29 1
d34 1
d165 4
d171 7
a177 3
      // We had some input files, but we weren't able to open any of
      // them.
      gold_fatal(_("no input files"));
d182 1
a182 1
    thread_count = input_objects->number_of_input_objects();
d291 1
a291 1
    thread_count = input_objects->number_of_input_objects();
@


1.40
log
@Initial -r support.
@
text
@d217 3
@


1.39
log
@Fully implement the SECTIONS clause.
@
text
@d185 3
d207 4
a210 2
  // Predefine standard symbols.
  define_standard_symbols(symtab, layout);
d212 4
a215 3
  // Define __start and __stop symbols for output sections where
  // appropriate.
  layout->define_section_symbols(symtab);
d246 8
a253 3
  blocker->add_blocker();
  workqueue->queue(new Allocate_commons_task(options, symtab, layout,
  					     symtab_lock, blocker));
@


1.38
log
@Don't pass around the target in order to define symbols; get it from
the parameters instead.
@
text
@d201 4
a204 2
  // Predefine standard symbols.  This should be fast, so we don't
  // bother to create a task for it.
a209 3

  // Define symbols from any linker scripts.
  layout->define_script_symbols(symtab);
@


1.37
log
@Parse a SECTIONS clause in a linker script.
@
text
@d199 1
a199 1
  layout->create_initial_dynamic_sections(input_objects, symtab);
d203 1
a203 1
  define_standard_symbols(symtab, layout, input_objects->target());
d207 1
a207 1
  layout->define_section_symbols(symtab, input_objects->target());
d210 1
a210 1
  layout->define_script_symbols(symtab, input_objects->target());
@


1.36
log
@Support assignments and expressions in linker scripts.
@
text
@d32 1
d185 3
@


1.35
log
@Rewrite workqueue.  This version eliminates the master thread, and
reduces the amount of locking required to find a new thread to run.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
d204 3
@


1.34
log
@Don't write out the symbol table when stripping.
@
text
@d92 1
a92 1
  run(Workqueue*);
d102 1
a102 1
Middle_runner::run(Workqueue* workqueue)
d104 1
a104 1
  queue_middle_tasks(this->options_, this->input_objects_, this->symtab_,
d112 1
a112 1
		    const Dirsearch& search_path,
d134 1
a134 1
      Task_token* next_blocker = new Task_token();
d137 1
a137 1
					search_path, &*p, NULL, this_blocker,
d156 1
d191 1
a191 1
  symtab->detect_odr_violations(options.output_file_name());
d216 2
a217 2
  Task_token* blocker = new Task_token();
  Task_token* symtab_lock = new Task_token();
d264 2
d268 3
a270 1
  Task_token* input_sections_blocker = new Task_token();
d274 1
a274 1
  Task_token* output_sections_blocker = new Task_token();
d277 1
a277 15
  Task_token* final_blocker = new Task_token();

  // Queue a task for each input object to relocate the sections and
  // write out the local symbols.
  for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
       p != input_objects->relobj_end();
       ++p)
    {
      input_sections_blocker->add_blocker();
      final_blocker->add_blocker();
      workqueue->queue(new Relocate_task(options, symtab, layout, *p, of,
					 input_sections_blocker,
					 output_sections_blocker,
					 final_blocker));
    }
d301 15
d317 21
a337 5
  // input sections.
  final_blocker->add_blocker();
  workqueue->queue(new Write_after_input_sections_task(layout, of,
						       input_sections_blocker,
						       final_blocker));
@


1.33
log
@Clean up setting address and section offset.
@
text
@d289 10
a298 7
  final_blocker->add_blocker();
  workqueue->queue(new Write_symbols_task(symtab,
					  input_objects,
					  layout->sympool(),
					  layout->dynpool(),
					  of,
					  final_blocker));
@


1.32
log
@Don't try to delete the output file if we don't know its name yet.
@
text
@d254 1
a254 1
		  const Layout* layout,
@


1.31
log
@Add threading support.
@
text
@d50 1
a50 1
  if (!status && parameters != NULL)
@


1.30
log
@From Craig Silverstein: Report output file name with ODR violation
warning message.
@
text
@d146 2
a147 1
				     this_blocker));
d243 2
a244 1
				     blocker));
d317 2
a318 1
				     final_blocker));
@


1.29
log
@Add heuristics for undefined symbol warnings.
@
text
@d189 1
a189 1
  symtab->detect_odr_violations();
@


1.28
log
@Warn about undefined references in shared libraries if we have seen
all the DT_NEEDED entries for that library.
@
text
@d289 1
a289 1
					  input_objects->target(),
@


1.27
log
@From Craig Silverstein: First cut at detecting ODR violations.
@
text
@d183 4
@


1.26
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d183 4
@


1.25
log
@Simplify some code to avoid extra tests of number of objects.
@
text
@d253 8
d270 1
d273 2
d287 6
d296 7
@


1.24
log
@Exit if we couldn't open any input files.
@
text
@d117 3
d122 1
a122 5
    {
      thread_count = cmdline.number_of_input_files();
      if (thread_count == 0)
	thread_count = 1;
    }
a124 3
  if (cmdline.begin() == cmdline.end())
    gold_fatal(_("no input files"));

d169 1
a169 5
    {
      thread_count = input_objects->number_of_input_objects();
      if (thread_count == 0)
	thread_count = 1;
    }
d250 1
a250 5
    {
      thread_count = input_objects->number_of_input_objects();
      if (thread_count == 0)
	thread_count = 1;
    }
@


1.23
log
@Add infrastructure for threading support.
@
text
@d164 7
@


1.22
log
@From Cary Coutant: preliminary shared library support.
@
text
@d117 9
d164 9
d249 9
@


1.21
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d156 2
a157 1
  const bool doing_static_link = !input_objects->any_dynamic();
@


1.20
log
@From Craig Silverstein: add some internationalization calls.
@
text
@d29 1
d50 2
a55 11
gold_fatal(const char* msg, bool perrno)
{
  fprintf(stderr, "%s: ", program_name);
  if (perrno)
    perror(msg);
  else
    fprintf(stderr, "%s\n", msg);
  gold_exit(false);
}

void
d118 1
a118 1
    gold_fatal(_("no input files"), false);
d161 2
a162 3
      fprintf(stderr, _("%s: cannot mix -static with dynamic object %s\n"),
              program_name, (*input_objects->dynobj_begin())->name().c_str());
      gold_exit(false);
@


1.19
log
@From Craig Silverstein: error if we see a dynamic object when the
-static option was given.
@
text
@d80 1
a80 1
  fprintf(stderr, "%s: internal error in %s, at %s:%d\n",
@


1.18
log
@Use parameters to track whether we are doing a static link.  Fix up
final_value_is_known for weak undefined symbols.  Pointed out by Cary
Coutant.
@
text
@d164 9
a172 1
  set_parameters_doing_static_link(!input_objects->any_dynamic());
@


1.17
log
@Put size and endianness in parameters.
@
text
@d163 3
@


1.16
log
@Add licensing text to every source file.
@
text
@d253 1
a253 3
  workqueue->queue(new Write_data_task(layout, symtab,
				       input_objects->target(),
				       of, final_blocker));
@


1.15
log
@Define __start and __stop symbols.
@
text
@d3 20
@


1.14
log
@Can now dynamically link hello, world.
@
text
@d151 4
@


1.13
log
@Added a testsuite.  More support for COPY relocations.
@
text
@d220 5
a224 2
  workqueue->queue(new Write_symbols_task(symtab, input_objects->target(),
					  layout->sympool(), of,
@


1.12
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d1 1
a1 1
// ld.c -- linker main function
a236 47

using namespace gold;

int
main(int argc, char** argv)
{
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  gold::program_name = argv[0];

  // Handle the command line options.
  gold::Command_line command_line;
  command_line.process(argc - 1, argv + 1);

  // The work queue.
  gold::Workqueue workqueue(command_line.options());

  // The list of input objects.
  Input_objects input_objects;

  // The symbol table.
  Symbol_table symtab;

  // The layout object.
  Layout layout(command_line.options());

  // Get the search path from the -L options.
  Dirsearch search_path;
  search_path.add(&workqueue, command_line.options().search_path());

  // Queue up the first set of tasks.
  queue_initial_tasks(command_line.options(), search_path,
		      command_line, &workqueue, &input_objects,
		      &symtab, &layout);

  // Run the main task processing loop.
  workqueue.process();

  gold::gold_exit(true);
}
@


1.11
log
@More dynamic object support, initial scripting support.
@
text
@d55 2
d58 1
a58 1
gold_unreachable()
d60 3
a62 1
  abort();
d143 4
d226 3
a228 1
  workqueue->queue(new Write_data_task(layout, of, final_blocker));
@


1.10
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@d116 1
a116 1
					search_path, *p, NULL, this_blocker,
@


1.9
log
@Can now do a full static link of hello, world in C or C++
@
text
@d156 2
a157 2
  for (Input_objects::Object_list::const_iterator p = input_objects->begin();
       p != input_objects->end();
d201 2
a202 2
  for (Input_objects::Object_list::const_iterator p = input_objects->begin();
       p != input_objects->end();
@


1.8
log
@Framework for relocation scanning.  Implement simple static TLS
relocations.
@
text
@d15 1
d19 1
d97 1
a97 1
		    const Input_argument_list& inputs,
d101 1
a101 1
  if (inputs.empty())
d109 2
a110 2
  for (Input_argument_list::const_iterator p = inputs.begin();
       p != inputs.end();
d116 1
a116 1
					search_path, *p, this_blocker,
d139 4
d166 2
a167 2
      workqueue->queue(new Read_relocs(options, symtab, *p, symtab_lock,
				       blocker));
d172 3
a174 3
  // blocker->add_blocker();
  // workqueue->queue(new Allocate_commons_task(options, symtab, layout,
  //					     symtab_lock, blocker));
d266 1
a266 1
		      command_line.inputs(), &workqueue, &input_objects,
@


1.7
log
@Lay out object file sections when we add the symbols to the symbol
table.
@
text
@d59 2
a60 1
} // End namespace gold.
d62 1
a62 1
namespace
d64 18
d83 6
a88 1
using namespace gold;
d95 1
a95 1
		    const Command_line::Input_argument_list& inputs,
d107 1
a107 1
  for (Command_line::Input_argument_list::const_iterator p = inputs.begin();
d119 5
a123 2
  workqueue->queue(new Layout_task(options, input_objects, symtab, layout,
				   this_blocker));
d126 3
a128 1
} // end anonymous namespace.
d130 6
a135 1
namespace gold
d137 41
d200 2
a201 2
      workqueue->queue(new Relocate_task(options, symtab, layout->sympool(),
					 *p, of, final_blocker));
d216 2
a217 1
  workqueue->queue(new Close_task(of, final_blocker));
d221 2
@


1.6
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d73 1
a73 1
		    Symbol_table* symtab)
d89 1
a89 1
      workqueue->queue(new Read_symbols(options, input_objects, symtab,
d95 1
a95 1
  workqueue->queue(new Layout_task(options, input_objects, symtab,
d173 3
d183 1
a183 1
		      &symtab);
@


1.5
log
@Finished layout code.
@
text
@d17 1
d100 45
@


1.4
log
@More section layout code.
@
text
@d94 2
a95 1
  workqueue->queue(new Layout_task(options, input_objects, this_blocker));
@


1.3
log
@New drop, with first cut of section layout code.
@
text
@d15 1
d71 1
a71 1
		    Workqueue* workqueue, Object_list* input_objects,
d121 1
a121 1
  Object_list input_objects;
@


1.2
log
@Another snapshot of the current state of the sources.  Gets to the
point of symbol resolution and can now issue a multiple definition
error.  Also added target selection infrastructure.
@
text
@d15 1
d70 2
a71 1
		    Workqueue* workqueue, Symbol_table* symtab)
d87 3
a89 2
      workqueue->queue(new Read_symbols(options, symtab, search_path,
					*p, this_blocker, next_blocker));
d93 1
a93 1
  // workqueue->queue(new Layout(options, inputs, this_blocker));
d119 3
d131 2
a132 1
		      command_line.inputs(), &workqueue, &symtab);
@


1.1
log
@Initial CVS checkin of gold
@
text
@d14 1
d69 1
a69 1
		    Workqueue* workqueue)
d85 2
a86 2
      workqueue->queue(new Read_symbols(options, search_path, *p, this_blocker,
					next_blocker));
d117 1
d125 1
a125 1
		      command_line.inputs(), &workqueue);
@

