head	1.37;
access;
symbols
	binutils-2_24-branch:1.37.0.4
	binutils-2_24-branchpoint:1.37
	binutils-2_21_1:1.29
	binutils-2_23_2:1.37
	binutils-2_23_1:1.37
	binutils-2_23:1.37
	binutils-2_23-branch:1.37.0.2
	binutils-2_23-branchpoint:1.37
	binutils-2_22_branch:1.31.2.2.0.2
	binutils-2_22:1.31.2.2
	binutils-2_22-branch:1.31.0.2
	binutils-2_22-branchpoint:1.31
	binutils-2_21:1.29
	binutils-2_21-branch:1.29.0.2
	binutils-2_21-branchpoint:1.29
	binutils-2_20_1:1.25
	binutils-2_20:1.25
	binutils-arc-20081103-branch:1.23.0.6
	binutils-arc-20081103-branchpoint:1.23
	binutils-2_20-branch:1.25.0.4
	binutils-2_20-branchpoint:1.25
	dje-cgen-play1-branch:1.25.0.2
	dje-cgen-play1-branchpoint:1.25
	arc-20081103-branch:1.23.0.4
	arc-20081103-branchpoint:1.23
	binutils-2_19_1:1.23
	binutils-2_19:1.23
	binutils-2_19-branch:1.23.0.2
	binutils-2_19-branchpoint:1.23
	binutils_latest_snapshot:1.37
	added-to-binutils:1.22;
locks; strict;
comment	@ * @;


1.37
date	2012.04.26.00.07.21;	author ian;	state Exp;
branches;
next	1.36;

1.36
date	2012.03.21.19.02.21;	author ccoutant;	state Exp;
branches;
next	1.35;

1.35
date	2012.02.03.20.01.01;	author dougkwan;	state Exp;
branches;
next	1.34;

1.34
date	2012.01.28.01.47.01;	author ian;	state Exp;
branches;
next	1.33;

1.33
date	2011.11.10.20.53.36;	author dougkwan;	state Exp;
branches;
next	1.32;

1.32
date	2011.11.10.00.41.53;	author dougkwan;	state Exp;
branches;
next	1.31;

1.31
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2010.12.01.19.49.22;	author ian;	state Exp;
branches;
next	1.29;

1.29
date	2010.02.12.04.33.53;	author ian;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.29.05.16.23;	author ian;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.23.18.10.42;	author dougkwan;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	1.23;

1.23
date	2008.04.16.22.54.29;	author ian;	state Exp;
branches;
next	1.22;

1.22
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2008.02.27.22.38.18;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2008.02.06.08.13.50;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.14.19.00.21;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.22.00.05.51;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.15.23.46.46;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.12.20.35.21;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.09.23.16.54;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.01.23.42.58;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.01.21.25.23;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.01.00.05.08;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.28.06.00.26;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.16.17.42.48;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.30.23.52.50;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.03.18.26.11;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.20.20.40.49;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.29.19.58.17;	author iant;	state Exp;
branches;
next	;

1.31.2.1
date	2011.11.21.09.32.16;	author gingold;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2011.11.21.09.39.58;	author gingold;	state Exp;
branches;
next	;


desc
@@


1.37
log
@	* arm.cc (Target_arm::do_is_defined_by_abi): Make sym a const
	pointer.
	(Stub_addend_reader::operator()): Declare Arm_relocate_functions
	as a class, not a struct.
	(Target_arm::scan_span_for_cortex_a8_erratum): Likewise.
	(Target_arm::apply_cortex_a8_workaround): Likewise.
	* gc.h: Declare Reloc_types as a struct, not a class.
	* object.h: Declare Symbols_data as a struct.
	* reloc.h: Declare Read_relocs_data as a struct.
	* target.h: Declare Relocate_info as a struct.
@
text
@// reloc.h -- relocate input files for gold   -*- C++ -*-

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#ifndef GOLD_RELOC_H
#define GOLD_RELOC_H

#include <vector>
#ifdef HAVE_BYTESWAP_H
#include <byteswap.h>
#endif

#include "elfcpp.h"
#include "workqueue.h"

namespace gold
{

class General_options;
class Object;
class Relobj;
struct Read_relocs_data;
class Symbol;
class Layout;
class Output_data;
class Output_section;

template<int size>
class Sized_symbol;

template<int size, bool big_endian>
class Sized_relobj_file;

template<int size>
class Symbol_value;

template<int sh_type, bool dynamic, int size, bool big_endian>
class Output_data_reloc;

// A class to read the relocations for an object file, and then queue
// up a task to see if they require any GOT/PLT/COPY relocations in
// the symbol table.

class Read_relocs : public Task
{
 public:
  //   THIS_BLOCKER and NEXT_BLOCKER are passed along to a Scan_relocs
  // or Gc_process_relocs task, so that they run in a deterministic
  // order.
  Read_relocs(Symbol_table* symtab, Layout* layout, Relobj* object,
	      Task_token* this_blocker, Task_token* next_blocker)
    : symtab_(symtab), layout_(layout), object_(object),
      this_blocker_(this_blocker), next_blocker_(next_blocker)
  { }

  // The standard Task methods.

  Task_token*
  is_runnable();

  void
  locks(Task_locker*);

  void
  run(Workqueue*);

  std::string
  get_name() const;

 private:
  Symbol_table* symtab_;
  Layout* layout_;
  Relobj* object_;
  Task_token* this_blocker_;
  Task_token* next_blocker_;
};

// Process the relocs to figure out which sections are garbage.
// Very similar to scan relocs.

class Gc_process_relocs : public Task
{
 public:
  // THIS_BLOCKER prevents this task from running until the previous
  // one is finished.  NEXT_BLOCKER prevents the next task from
  // running.
  Gc_process_relocs(Symbol_table* symtab, Layout* layout, Relobj* object,
		    Read_relocs_data* rd, Task_token* this_blocker,
		    Task_token* next_blocker)
    : symtab_(symtab), layout_(layout), object_(object), rd_(rd),
      this_blocker_(this_blocker), next_blocker_(next_blocker)
  { }

  ~Gc_process_relocs();

  // The standard Task methods.

  Task_token*
  is_runnable();

  void
  locks(Task_locker*);

  void
  run(Workqueue*);

  std::string
  get_name() const;

 private:
  Symbol_table* symtab_;
  Layout* layout_;
  Relobj* object_;
  Read_relocs_data* rd_;
  Task_token* this_blocker_;
  Task_token* next_blocker_;
};

// Scan the relocations for an object to see if they require any
// GOT/PLT/COPY relocations.

class Scan_relocs : public Task
{
 public:
  // THIS_BLOCKER prevents this task from running until the previous
  // one is finished.  NEXT_BLOCKER prevents the next task from
  // running.
  Scan_relocs(Symbol_table* symtab, Layout* layout, Relobj* object,
	      Read_relocs_data* rd, Task_token* this_blocker,
	      Task_token* next_blocker)
    : symtab_(symtab), layout_(layout), object_(object), rd_(rd),
      this_blocker_(this_blocker), next_blocker_(next_blocker)
  { }

  ~Scan_relocs();

  // The standard Task methods.

  Task_token*
  is_runnable();

  void
  locks(Task_locker*);

  void
  run(Workqueue*);

  std::string
  get_name() const;

 private:
  Symbol_table* symtab_;
  Layout* layout_;
  Relobj* object_;
  Read_relocs_data* rd_;
  Task_token* this_blocker_;
  Task_token* next_blocker_;
};

// A class to perform all the relocations for an object file.

class Relocate_task : public Task
{
 public:
  Relocate_task(const Symbol_table* symtab, const Layout* layout,
		Relobj* object, Output_file* of,
		Task_token* input_sections_blocker,
		Task_token* output_sections_blocker, Task_token* final_blocker)
    : symtab_(symtab), layout_(layout), object_(object), of_(of),
      input_sections_blocker_(input_sections_blocker),
      output_sections_blocker_(output_sections_blocker),
      final_blocker_(final_blocker)
  { }

  // The standard Task methods.

  Task_token*
  is_runnable();

  void
  locks(Task_locker*);

  void
  run(Workqueue*);

  std::string
  get_name() const;

 private:
  const Symbol_table* symtab_;
  const Layout* layout_;
  Relobj* object_;
  Output_file* of_;
  Task_token* input_sections_blocker_;
  Task_token* output_sections_blocker_;
  Task_token* final_blocker_;
};

// During a relocatable link, this class records how relocations
// should be handled for a single input reloc section.  An instance of
// this class is created while scanning relocs, and it is used while
// processing relocs.

class Relocatable_relocs
{
 public:
  // We use a vector of unsigned char to indicate how the input relocs
  // should be handled.  Each element is one of the following values.
  // We create this vector when we initially scan the relocations.
  enum Reloc_strategy
  {
    // Copy the input reloc.  Don't modify it other than updating the
    // r_offset field and the r_sym part of the r_info field.
    RELOC_COPY,
    // Copy the input reloc which is against an STT_SECTION symbol.
    // Update the r_offset and r_sym part of the r_info field.  Adjust
    // the addend by subtracting the value of the old local symbol and
    // adding the value of the new local symbol.  The addend is in the
    // SHT_RELA reloc and the contents of the data section do not need
    // to be changed.
    RELOC_ADJUST_FOR_SECTION_RELA,
    // Like RELOC_ADJUST_FOR_SECTION_RELA but the addend should not be
    // adjusted.
    RELOC_ADJUST_FOR_SECTION_0,
    // Like RELOC_ADJUST_FOR_SECTION_RELA but the contents of the
    // section need to be changed.  The number indicates the number of
    // bytes in the addend in the section contents.
    RELOC_ADJUST_FOR_SECTION_1,
    RELOC_ADJUST_FOR_SECTION_2,
    RELOC_ADJUST_FOR_SECTION_4,
    RELOC_ADJUST_FOR_SECTION_8,
    // Like RELOC_ADJUST_FOR_SECTION_4 but for unaligned relocs.
    RELOC_ADJUST_FOR_SECTION_4_UNALIGNED,
    // Discard the input reloc--process it completely when relocating
    // the data section contents.
    RELOC_DISCARD,
    // An input reloc which is not discarded, but which requires
    // target specific processing in order to update it.
    RELOC_SPECIAL
  };

  Relocatable_relocs()
    : reloc_strategies_(), output_reloc_count_(0), posd_(NULL)
  { }

  // Record the number of relocs.
  void
  set_reloc_count(size_t reloc_count)
  { this->reloc_strategies_.reserve(reloc_count); }

  // Record what to do for the next reloc.
  void
  set_next_reloc_strategy(Reloc_strategy strategy)
  {
    this->reloc_strategies_.push_back(static_cast<unsigned char>(strategy));
    if (strategy != RELOC_DISCARD)
      ++this->output_reloc_count_;
  }

  // Record the Output_data associated with this reloc section.
  void
  set_output_data(Output_data* posd)
  {
    gold_assert(this->posd_ == NULL);
    this->posd_ = posd;
  }

  // Return the Output_data associated with this reloc section.
  Output_data*
  output_data() const
  { return this->posd_; }

  // Return what to do for reloc I.
  Reloc_strategy
  strategy(unsigned int i) const
  {
    gold_assert(i < this->reloc_strategies_.size());
    return static_cast<Reloc_strategy>(this->reloc_strategies_[i]);
  }

  // Return the number of relocations to create in the output file.
  size_t
  output_reloc_count() const
  { return this->output_reloc_count_; }

 private:
  typedef std::vector<unsigned char> Reloc_strategies;

  // The strategies for the input reloc.  There is one entry in this
  // vector for each relocation in the input section.
  Reloc_strategies reloc_strategies_;
  // The number of relocations to be created in the output file.
  size_t output_reloc_count_;
  // The output data structure associated with this relocation.
  Output_data* posd_;
};

// Standard relocation routines which are used on many targets.  Here
// SIZE and BIG_ENDIAN refer to the target, not the relocation type.

template<int size, bool big_endian>
class Relocate_functions
{
private:
  // Do a simple relocation with the addend in the section contents.
  // VALSIZE is the size of the value.
  template<int valsize>
  static inline void
  rel(unsigned char* view,
      typename elfcpp::Swap<valsize, big_endian>::Valtype value)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype x = elfcpp::Swap<valsize, big_endian>::readval(wv);
    elfcpp::Swap<valsize, big_endian>::writeval(wv, x + value);
  }

  // Like the above but for relocs at unaligned addresses.
  template<int valsize>
  static inline void
  rel_unaligned(unsigned char* view,
	        typename elfcpp::Swap<valsize, big_endian>::Valtype value)
  {
    typedef typename elfcpp::Swap_unaligned<valsize, big_endian>::Valtype
	Valtype;
    Valtype x = elfcpp::Swap_unaligned<valsize, big_endian>::readval(view);
    elfcpp::Swap_unaligned<valsize, big_endian>::writeval(view, x + value);
  }

  // Do a simple relocation using a Symbol_value with the addend in
  // the section contents.  VALSIZE is the size of the value to
  // relocate.
  template<int valsize>
  static inline void
  rel(unsigned char* view,
      const Sized_relobj_file<size, big_endian>* object,
      const Symbol_value<size>* psymval)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype x = elfcpp::Swap<valsize, big_endian>::readval(wv);
    x = psymval->value(object, x);
    elfcpp::Swap<valsize, big_endian>::writeval(wv, x);
  }

  // Like the above but for relocs at unaligned addresses.
  template<int valsize>
  static inline void
  rel_unaligned(unsigned char* view,
                const Sized_relobj_file<size, big_endian>* object,
                const Symbol_value<size>* psymval)
  {
    typedef typename elfcpp::Swap_unaligned<valsize, big_endian>::Valtype
        Valtype;
    Valtype x = elfcpp::Swap_unaligned<valsize, big_endian>::readval(view);
    x = psymval->value(object, x);
    elfcpp::Swap_unaligned<valsize, big_endian>::writeval(view, x);
  }

  // Do a simple relocation with the addend in the relocation.
  // VALSIZE is the size of the value.
  template<int valsize>
  static inline void
  rela(unsigned char* view,
       typename elfcpp::Swap<valsize, big_endian>::Valtype value,
       typename elfcpp::Swap<valsize, big_endian>::Valtype addend)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    elfcpp::Swap<valsize, big_endian>::writeval(wv, value + addend);
  }

  // Do a simple relocation using a symbol value with the addend in
  // the relocation.  VALSIZE is the size of the value.
  template<int valsize>
  static inline void
  rela(unsigned char* view,
       const Sized_relobj_file<size, big_endian>* object,
       const Symbol_value<size>* psymval,
       typename elfcpp::Swap<valsize, big_endian>::Valtype addend)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype x = psymval->value(object, addend);
    elfcpp::Swap<valsize, big_endian>::writeval(wv, x);
  }

  // Do a simple PC relative relocation with the addend in the section
  // contents.  VALSIZE is the size of the value.
  template<int valsize>
  static inline void
  pcrel(unsigned char* view,
	typename elfcpp::Swap<valsize, big_endian>::Valtype value,
	typename elfcpp::Elf_types<size>::Elf_Addr address)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype x = elfcpp::Swap<valsize, big_endian>::readval(wv);
    elfcpp::Swap<valsize, big_endian>::writeval(wv, x + value - address);
  }

  // Like the above but for relocs at unaligned addresses.
  template<int valsize>
  static inline void
  pcrel_unaligned(unsigned char* view,
		  typename elfcpp::Swap<valsize, big_endian>::Valtype value,
		  typename elfcpp::Elf_types<size>::Elf_Addr address)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    Valtype x = elfcpp::Swap_unaligned<valsize, big_endian>::readval(view);
    elfcpp::Swap_unaligned<valsize, big_endian>::writeval(view,
							  x + value - address);
  }

  // Do a simple PC relative relocation with a Symbol_value with the
  // addend in the section contents.  VALSIZE is the size of the
  // value.
  template<int valsize>
  static inline void
  pcrel(unsigned char* view,
	const Sized_relobj_file<size, big_endian>* object,
	const Symbol_value<size>* psymval,
	typename elfcpp::Elf_types<size>::Elf_Addr address)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype x = elfcpp::Swap<valsize, big_endian>::readval(wv);
    x = psymval->value(object, x);
    elfcpp::Swap<valsize, big_endian>::writeval(wv, x - address);
  }

  // Do a simple PC relative relocation with the addend in the
  // relocation.  VALSIZE is the size of the value.
  template<int valsize>
  static inline void
  pcrela(unsigned char* view,
	 typename elfcpp::Swap<valsize, big_endian>::Valtype value,
	 typename elfcpp::Swap<valsize, big_endian>::Valtype addend,
	 typename elfcpp::Elf_types<size>::Elf_Addr address)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    elfcpp::Swap<valsize, big_endian>::writeval(wv, value + addend - address);
  }

  // Do a simple PC relative relocation with a Symbol_value with the
  // addend in the relocation.  VALSIZE is the size of the value.
  template<int valsize>
  static inline void
  pcrela(unsigned char* view,
	 const Sized_relobj_file<size, big_endian>* object,
	 const Symbol_value<size>* psymval,
	 typename elfcpp::Swap<valsize, big_endian>::Valtype addend,
	 typename elfcpp::Elf_types<size>::Elf_Addr address)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype x = psymval->value(object, addend);
    elfcpp::Swap<valsize, big_endian>::writeval(wv, x - address);
  }

  typedef Relocate_functions<size, big_endian> This;

public:
  // Do a simple 8-bit REL relocation with the addend in the section
  // contents.
  static inline void
  rel8(unsigned char* view, unsigned char value)
  { This::template rel<8>(view, value); }

  static inline void
  rel8(unsigned char* view,
       const Sized_relobj_file<size, big_endian>* object,
       const Symbol_value<size>* psymval)
  { This::template rel<8>(view, object, psymval); }

  // Do an 8-bit RELA relocation with the addend in the relocation.
  static inline void
  rela8(unsigned char* view, unsigned char value, unsigned char addend)
  { This::template rela<8>(view, value, addend); }

  static inline void
  rela8(unsigned char* view,
	const Sized_relobj_file<size, big_endian>* object,
	const Symbol_value<size>* psymval,
	unsigned char addend)
  { This::template rela<8>(view, object, psymval, addend); }

  // Do a simple 8-bit PC relative relocation with the addend in the
  // section contents.
  static inline void
  pcrel8(unsigned char* view, unsigned char value,
	 typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrel<8>(view, value, address); }

  static inline void
  pcrel8(unsigned char* view,
	 const Sized_relobj_file<size, big_endian>* object,
	 const Symbol_value<size>* psymval,
	 typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrel<8>(view, object, psymval, address); }

  // Do a simple 8-bit PC relative RELA relocation with the addend in
  // the reloc.
  static inline void
  pcrela8(unsigned char* view, unsigned char value, unsigned char addend,
	  typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrela<8>(view, value, addend, address); }

  static inline void
  pcrela8(unsigned char* view,
	  const Sized_relobj_file<size, big_endian>* object,
	  const Symbol_value<size>* psymval,
	  unsigned char addend,
	  typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrela<8>(view, object, psymval, addend, address); }

  // Do a simple 16-bit REL relocation with the addend in the section
  // contents.
  static inline void
  rel16(unsigned char* view, elfcpp::Elf_Half value)
  { This::template rel<16>(view, value); }

  static inline void
  rel16(unsigned char* view,
	const Sized_relobj_file<size, big_endian>* object,
	const Symbol_value<size>* psymval)
  { This::template rel<16>(view, object, psymval); }

  // Do an 16-bit RELA relocation with the addend in the relocation.
  static inline void
  rela16(unsigned char* view, elfcpp::Elf_Half value, elfcpp::Elf_Half addend)
  { This::template rela<16>(view, value, addend); }

  static inline void
  rela16(unsigned char* view,
	 const Sized_relobj_file<size, big_endian>* object,
	 const Symbol_value<size>* psymval,
	 elfcpp::Elf_Half addend)
  { This::template rela<16>(view, object, psymval, addend); }

  // Do a simple 16-bit PC relative REL relocation with the addend in
  // the section contents.
  static inline void
  pcrel16(unsigned char* view, elfcpp::Elf_Half value,
	  typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrel<16>(view, value, address); }

  static inline void
  pcrel16(unsigned char* view,
	  const Sized_relobj_file<size, big_endian>* object,
	  const Symbol_value<size>* psymval,
	  typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrel<16>(view, object, psymval, address); }

  // Do a simple 16-bit PC relative RELA relocation with the addend in
  // the reloc.
  static inline void
  pcrela16(unsigned char* view, elfcpp::Elf_Half value,
	   elfcpp::Elf_Half addend,
           typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrela<16>(view, value, addend, address); }

  static inline void
  pcrela16(unsigned char* view,
	   const Sized_relobj_file<size, big_endian>* object,
	   const Symbol_value<size>* psymval,
	   elfcpp::Elf_Half addend,
	   typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrela<16>(view, object, psymval, addend, address); }

  // Do a simple 32-bit REL relocation with the addend in the section
  // contents.
  static inline void
  rel32(unsigned char* view, elfcpp::Elf_Word value)
  { This::template rel<32>(view, value); }

  // Like above but for relocs at unaligned addresses.
  static inline void
  rel32_unaligned(unsigned char* view, elfcpp::Elf_Word value)
  { This::template rel_unaligned<32>(view, value); }

  static inline void
  rel32(unsigned char* view,
	const Sized_relobj_file<size, big_endian>* object,
	const Symbol_value<size>* psymval)
  { This::template rel<32>(view, object, psymval); }

  // Like above but for relocs at unaligned addresses.
  static inline void
  rel32_unaligned(unsigned char* view,
	          const Sized_relobj_file<size, big_endian>* object,
	          const Symbol_value<size>* psymval)
  { This::template rel_unaligned<32>(view, object, psymval); }

  // Do an 32-bit RELA relocation with the addend in the relocation.
  static inline void
  rela32(unsigned char* view, elfcpp::Elf_Word value, elfcpp::Elf_Word addend)
  { This::template rela<32>(view, value, addend); }

  static inline void
  rela32(unsigned char* view,
	 const Sized_relobj_file<size, big_endian>* object,
	 const Symbol_value<size>* psymval,
	 elfcpp::Elf_Word addend)
  { This::template rela<32>(view, object, psymval, addend); }

  // Do a simple 32-bit PC relative REL relocation with the addend in
  // the section contents.
  static inline void
  pcrel32(unsigned char* view, elfcpp::Elf_Word value,
	  typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrel<32>(view, value, address); }

  // Unaligned version of the above.
  static inline void
  pcrel32_unaligned(unsigned char* view, elfcpp::Elf_Word value,
		    typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrel_unaligned<32>(view, value, address); }

  static inline void
  pcrel32(unsigned char* view,
	  const Sized_relobj_file<size, big_endian>* object,
	  const Symbol_value<size>* psymval,
	  typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrel<32>(view, object, psymval, address); }

  // Do a simple 32-bit PC relative RELA relocation with the addend in
  // the relocation.
  static inline void
  pcrela32(unsigned char* view, elfcpp::Elf_Word value,
           elfcpp::Elf_Word addend,
           typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrela<32>(view, value, addend, address); }

  static inline void
  pcrela32(unsigned char* view,
	   const Sized_relobj_file<size, big_endian>* object,
	   const Symbol_value<size>* psymval,
	   elfcpp::Elf_Word addend,
	   typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrela<32>(view, object, psymval, addend, address); }

  // Do a simple 64-bit REL relocation with the addend in the section
  // contents.
  static inline void
  rel64(unsigned char* view, elfcpp::Elf_Xword value)
  { This::template rel<64>(view, value); }

  static inline void
  rel64(unsigned char* view,
	const Sized_relobj_file<size, big_endian>* object,
	const Symbol_value<size>* psymval)
  { This::template rel<64>(view, object, psymval); }

  // Do a 64-bit RELA relocation with the addend in the relocation.
  static inline void
  rela64(unsigned char* view, elfcpp::Elf_Xword value,
         elfcpp::Elf_Xword addend)
  { This::template rela<64>(view, value, addend); }

  static inline void
  rela64(unsigned char* view,
	 const Sized_relobj_file<size, big_endian>* object,
	 const Symbol_value<size>* psymval,
	 elfcpp::Elf_Xword addend)
  { This::template rela<64>(view, object, psymval, addend); }

  // Do a simple 64-bit PC relative REL relocation with the addend in
  // the section contents.
  static inline void
  pcrel64(unsigned char* view, elfcpp::Elf_Xword value,
	  typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrel<64>(view, value, address); }

  static inline void
  pcrel64(unsigned char* view,
	  const Sized_relobj_file<size, big_endian>* object,
	  const Symbol_value<size>* psymval,
	  typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrel<64>(view, object, psymval, address); }

  // Do a simple 64-bit PC relative RELA relocation with the addend in
  // the relocation.
  static inline void
  pcrela64(unsigned char* view, elfcpp::Elf_Xword value,
           elfcpp::Elf_Xword addend,
           typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrela<64>(view, value, addend, address); }

  static inline void
  pcrela64(unsigned char* view,
	   const Sized_relobj_file<size, big_endian>* object,
	   const Symbol_value<size>* psymval,
	   elfcpp::Elf_Xword addend,
	   typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrela<64>(view, object, psymval, addend, address); }
};

// Integer manipulation functions used by various targets when
// performing relocations.

template<int bits>
class Bits
{
 public:
  // Sign extend an n-bit unsigned integer stored in a uint32_t into
  // an int32_t.  BITS must be between 1 and 32.
  static inline int32_t
  sign_extend32(uint32_t val)
  {
    gold_assert(bits > 0 && bits <= 32);
    if (bits == 32)
      return static_cast<int32_t>(val);
    uint32_t mask = (~static_cast<uint32_t>(0)) >> (32 - bits);
    val &= mask;
    uint32_t top_bit = 1U << (bits - 1);
    int32_t as_signed = static_cast<int32_t>(val);
    if ((val & top_bit) != 0)
      as_signed -= static_cast<int32_t>(top_bit * 2);
    return as_signed;    
  }

  // Return true if VAL (stored in a uint32_t) has overflowed a signed
  // value with BITS bits.
  static inline bool
  has_overflow32(uint32_t val)
  {
    gold_assert(bits > 0 && bits <= 32);
    if (bits == 32)
      return false;
    int32_t max = (1 << (bits - 1)) - 1;
    int32_t min = -(1 << (bits - 1));
    int32_t as_signed = static_cast<int32_t>(val);
    return as_signed > max || as_signed < min;
  }

  // Return true if VAL (stored in a uint32_t) has overflowed both a
  // signed and an unsigned value.  E.g.,
  // Bits<8>::has_signed_unsigned_overflow32 would check -128 <= VAL <
  // 255.
  static inline bool
  has_signed_unsigned_overflow32(uint32_t val)
  {
    gold_assert(bits > 0 && bits <= 32);
    if (bits == 32)
      return false;
    int32_t max = static_cast<int32_t>((1U << bits) - 1);
    int32_t min = -(1 << (bits - 1));
    int32_t as_signed = static_cast<int32_t>(val);
    return as_signed > max || as_signed < min;
  }

  // Select bits from A and B using bits in MASK.  For each n in
  // [0..31], the n-th bit in the result is chosen from the n-th bits
  // of A and B.  A zero selects A and a one selects B.
  static inline uint32_t
  bit_select32(uint32_t a, uint32_t b, uint32_t mask)
  { return (a & ~mask) | (b & mask); }

  // Sign extend an n-bit unsigned integer stored in a uint64_t into
  // an int64_t.  BITS must be between 1 and 64.
  static inline int64_t
  sign_extend(uint64_t val)
  {
    gold_assert(bits > 0 && bits <= 64);
    if (bits == 64)
      return static_cast<int64_t>(val);
    uint64_t mask = (~static_cast<uint64_t>(0)) >> (64 - bits);
    val &= mask;
    uint64_t top_bit = static_cast<uint64_t>(1) << (bits - 1);
    int64_t as_signed = static_cast<int64_t>(val);
    if ((val & top_bit) != 0)
      as_signed -= static_cast<int64_t>(top_bit * 2);
    return as_signed;    
  }

  // Return true if VAL (stored in a uint64_t) has overflowed a signed
  // value with BITS bits.
  static inline bool
  has_overflow(uint64_t val)
  {
    gold_assert(bits > 0 && bits <= 64);
    if (bits == 64)
      return false;
    int64_t max = (static_cast<int64_t>(1) << (bits - 1)) - 1;
    int64_t min = -(static_cast<int64_t>(1) << (bits - 1));
    int64_t as_signed = static_cast<int64_t>(val);
    return as_signed > max || as_signed < min;
  }

  // Return true if VAL (stored in a uint64_t) has overflowed both a
  // signed and an unsigned value.  E.g.,
  // Bits<8>::has_signed_unsigned_overflow would check -128 <= VAL <
  // 255.
  static inline bool
  has_signed_unsigned_overflow64(uint64_t val)
  {
    gold_assert(bits > 0 && bits <= 64);
    if (bits == 64)
      return false;
    int64_t max = static_cast<int64_t>((static_cast<uint64_t>(1) << bits) - 1);
    int64_t min = -(static_cast<int64_t>(1) << (bits - 1));
    int64_t as_signed = static_cast<int64_t>(val);
    return as_signed > max || as_signed < min;
  }

  // Select bits from A and B using bits in MASK.  For each n in
  // [0..31], the n-th bit in the result is chosen from the n-th bits
  // of A and B.  A zero selects A and a one selects B.
  static inline uint64_t
  bit_select64(uint64_t a, uint64_t b, uint64_t mask)
  { return (a & ~mask) | (b & mask); }
};

// Track relocations while reading a section.  This lets you ask for
// the relocation at a certain offset, and see how relocs occur
// between points of interest.

template<int size, bool big_endian>
class Track_relocs
{
 public:
  Track_relocs()
    : prelocs_(NULL), len_(0), pos_(0), reloc_size_(0)
  { }

  // Initialize the Track_relocs object.  OBJECT is the object holding
  // the reloc section, RELOC_SHNDX is the section index of the reloc
  // section, and RELOC_TYPE is the type of the reloc section
  // (elfcpp::SHT_REL or elfcpp::SHT_RELA).  This returns false if
  // something went wrong.
  bool
  initialize(Object* object, unsigned int reloc_shndx,
	     unsigned int reloc_type);

  // Return the offset in the data section to which the next reloc
  // applies.  This returns -1 if there is no next reloc.
  off_t
  next_offset() const;

  // Return the symbol index of the next reloc.  This returns -1U if
  // there is no next reloc.
  unsigned int
  next_symndx() const;

  // Return the addend of the next reloc.  This returns 0 if there is
  // no next reloc.
  uint64_t
  next_addend() const;

  // Advance to OFFSET within the data section, and return the number
  // of relocs which would be skipped.
  int
  advance(off_t offset);

  // Checkpoint the current position in the reloc section.
  section_size_type
  checkpoint() const
  { return this->pos_; }

  // Reset the position to CHECKPOINT.
  void
  reset(section_size_type checkpoint)
  { this->pos_ = checkpoint; }

 private:
  // The contents of the input object's reloc section.
  const unsigned char* prelocs_;
  // The length of the reloc section.
  section_size_type len_;
  // Our current position in the reloc section.
  section_size_type pos_;
  // The size of the relocs in the section.
  int reloc_size_;
};

} // End namespace gold.

#endif // !defined(GOLD_RELOC_H)
@


1.36
log
@2012-03-21  Cary Coutant  <ccoutant@@google.com>

	* Makefile.am: Add gdb-index.cc, gdb-index.h.
	* Makefile.in: Regenerate.
	* dwarf_reader.cc (Sized_elf_reloc_mapper::do_initialize): New function.
	(Sized_elf_reloc_mapper::symbol_section): New function.
	(Sized_elf_reloc_mapper::do_get_reloc_target): New function.
	(make_elf_reloc_mapper): New function.
	(Dwarf_abbrev_table::clear_abbrev_codes): New function.
	(Dwarf_abbrev_table::do_read_abbrevs): New function.
	(Dwarf_abbrev_table::do_get_abbrev): New function.
	(Dwarf_ranges_table::read_ranges_table): New function.
	(Dwarf_ranges_table::read_range_list): New function.
	(Dwarf_pubnames_table::read_section): New function.
	(Dwarf_pubnames_table::read_header): New function.
	(Dwarf_pubnames_table::next_name): New function.
	(Dwarf_die::Dwarf_die): New function.
	(Dwarf_die::read_attributes): New function.
	(Dwarf_die::skip_attributes): New function.
	(Dwarf_die::set_name): New function.
	(Dwarf_die::set_linkage_name): New function.
	(Dwarf_die::attribute): New function.
	(Dwarf_die::string_attribute): New function.
	(Dwarf_die::int_attribute): New function.
	(Dwarf_die::uint_attribute): New function.
	(Dwarf_die::ref_attribute): New function.
	(Dwarf_die::child_offset): New function.
	(Dwarf_die::sibling_offset): New function.
	(Dwarf_info_reader::check_buffer): New function.
	(Dwarf_info_reader::parse): New function.
	(Dwarf_info_reader::do_parse): New function.
	(Dwarf_info_reader::do_read_string_table): New function.
	(Dwarf_info_reader::lookup_reloc): New function.
	(Dwarf_info_reader::get_string): New function.
	(Dwarf_info_reader::visit_compilation_unit): New function.
	(Dwarf_info_reader::visit_type_unit): New function.
	(Sized_dwarf_line_info::Sized_dwarf_line_info): Use
	Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::symbol_section): Remove function.
	(Sized_dwarf_line_info::read_relocs): Use Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::read_line_mappings): Remove object
	parameter, adjust callers.
	(Sized_dwarf_line_info::format_file_lineno): Fix type of cast.
	* dwarf_reader.h: Include <sys/types.h>.
	(class Track_relocs): Remove forward declaration.
	(class Elf_reloc_mapper): New class.
	(class Sized_elf_reloc_mapper): New class.
	(class Dwarf_abbrev_table): New class.
	(class Dwarf_range_list): New class.
	(class Dwarf_ranges_table): New class.
	(class Dwarf_pubnames_table): New class.
	(class Dwarf_die): New class.
	(class Dwarf_info_reader): New class.
	(Sized_dwarf_line_info::read_line_mappings): Remove object parameter.
	(Sized_dwarf_line_info::symbol_section): Remove member function.
	* dynobj.h (Sized_dynobj::do_section_contents): Refactor code from
	base class.
	* gdb-index.cc: New source file.
	* gdb-index.h: New source file.
	* incremental.cc (Sized_relobj_incr::do_layout): Track .debug_info
	and .debug_types sections, call Layout::add_to_gdb_index.
	(Sized_relobj_incr::do_section_name): Implement.
	(Sized_relobj_incr::do_section_contents): Adjust parameter list and
	return type; Implement.
	(Sized_incr_dynobj::do_section_contents): Adjust parameter list and
	return type.
	* incremental.h (Sized_relobj_incr::do_section_contents): Adjust
	parameter list and return type.
	(Sized_incr_dynobj::do_section_contents): Likewise.
	* layout.cc: Include gdb-index.h.
	(Layout::Layout): Initialize gdb_index_data_.
	(Layout::init_fixed_output_section): Check for .gdb_index section.
	(Layout::add_to_gdb_index): New function. Instantiate.
	* layout.h: Add forward declaration for class Gdb_index.
	(Layout::add_to_gdb_index): New member function.
	(Layout::gdb_index_data_): New data member.
	* main.cc: Include gdb-index.h.
	(main): Print statistics for gdb index.
	* object.cc (Object::section_contents): Move code into
	do_section_contents.
	(need_decompressed_section): Check for sections needed when building
	gdb index.
	(build_compressed_section_map): Likewise.
	(Sized_relobj_file::do_read_symbols): Need local symbols when building
	gdb index.
	(Sized_relobj_file::do_layout): Track .debug_info and .debug_types
	sections; call Layout::add_to_gdb_index.
	(Sized_relobj_file::do_decompressed_section_contents): Call
	do_section_contents directly.
	* object.h (Object::do_section_contents): Adjust parameter list and
	return type.
	(Object::do_decompressed_section_contents): Call do_section_contents
	directly.
	(Sized_relobj_file::do_section_contents): Adjust parameter list and
	return type.
	* options.h (class General_options): Add --gdb-index option.
	* plugin.cc (Sized_pluginobj::do_section_contents): Adjust parameter
	list and return type.
	* plugin.h (Sized_pluginobj::do_section_contents): Likewise.
	* reloc.h (Track_relocs::checkpoint): New function.
	(Track_relocs::reset): New function.

	* testsuite/Makefile.am (gdb_index_test_1.sh, gdb_index_test_2.sh):
	New test cases.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/gdb_index_test.cc: New test source file.
	* testsuite/gdb_index_test_1.sh: New test source file.
	* testsuite/gdb_index_test_2.sh: New test source file.
@
text
@d41 1
a41 1
class Read_relocs_data;
@


1.35
log
@2012-02-03  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relocate_functions::abs8,
	Arm_relocate_functions::abs16): Use
	Bits::has_signed_unsigned_overflow32.
	(Arm_relocate_functions::thm_abs8): Correct range of
	overflow check.
	* reloc.h (Bits class): Change minimum number of bits from 0 to 1
	in assertions.
@
text
@d876 10
@


1.34
log
@	* reloc.h (Bits): New class with static functions, copied from
	namespace utils in arm.cc.
	* arm.cc (namespace utils): Remove.  Rewrite all uses to use Bits
	instead.
@
text
@d727 1
a727 1
  // an int32_t.  BITS must be between 0 and 32.
d731 1
a731 1
    gold_assert(bits >= 0 && bits <= 32);
d748 1
a748 1
    gold_assert(bits >= 0 && bits <= 32);
d764 1
a764 1
    gold_assert(bits >= 0 && bits <= 32);
d781 1
a781 1
  // an int64_t.  BITS must be between 0 and 64.
d785 1
a785 1
    gold_assert(bits >= 0 && bits <= 64);
d802 1
a802 1
    gold_assert(bits >= 0 && bits <= 64);
d818 1
a818 1
    gold_assert(bits >= 0 && bits <= 64);
@


1.33
log
@2011-11-10  Doug Kwan  <dougkwan@@google.com>

	PR gold/13362
	* arm.cc (Target_arm::Relocate::relocate_tls): Do unaligned accesses
	when processing data relocs.
	* reloc.h (Relocate_functions::rel_unaligned): New method.
	(Relocate_functions::pcrel_unaligned): Ditto.
	(Relocate_functions::rel32_unaligned): Ditto.
	(Relocate_functions::pcrel32_unaligned): Ditto.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d719 116
@


1.32
log
@2011-11-09  Doug Kwan  <dougkwan@@google.com>

	PR gold/13362
	* arm.cc (Arm_scan_relocatable_relocs::Default_scan_relocatable_relocs):
	Use unaligned 4-byte relocs for static 32-bit data as required by EABI.
	* reloc.h (Relocatable_relocs::Reloc_strategy): New enum
	RELOC_ADJUST_FOR_SECTION_4_UNALIGNED.
	(Relocate_functions::rel_unaligned): New.
	(Relocate_functions::rel32_unaligned): New.
	* target-reloc.h (relocate_for_relocatable): Add code to handle
	RELOC_ADJUST_FOR_SECTION_4_UNALIGNED.
	* testsuite/Makefile.am (arm_unaligned_reloc_r.stdout,
	arm_unaligned_reloc_r): New targets.
	* testsuite/Makefile.in: Regenerate.
	* arm_unaligned_reloc.sh: Check unaligned relocs in relocatable
	linking.
@
text
@d336 12
d420 13
d596 5
d633 6
@


1.31
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d250 2
d352 14
d577 7
@


1.31.2.1
log
@Merge of
CVSROOT:	/cvs/src
Module name:	src
Changes by:	dougkwan@@sourceware.org	2011-11-10 00:41:53

Modified files:
	gold           : ChangeLog arm.cc reloc.h target-reloc.h
	gold/testsuite : Makefile.am Makefile.in arm_unaligned_reloc.sh

Log message:
	2011-11-09  Doug Kwan  <dougkwan@@google.com>

	PR gold/13362
	* arm.cc (Arm_scan_relocatable_relocs::Default_scan_relocatable_relocs):
	Use unaligned 4-byte relocs for static 32-bit data as required by EABI.
	* reloc.h (Relocatable_relocs::Reloc_strategy): New enum
	RELOC_ADJUST_FOR_SECTION_4_UNALIGNED.
	(Relocate_functions::rel_unaligned): New.
	(Relocate_functions::rel32_unaligned): New.
	* target-reloc.h (relocate_for_relocatable): Add code to handle
	RELOC_ADJUST_FOR_SECTION_4_UNALIGNED.
	* testsuite/Makefile.am (arm_unaligned_reloc_r.stdout,
	arm_unaligned_reloc_r): New targets.
	* testsuite/Makefile.in: Regenerate.
	* arm_unaligned_reloc.sh: Check unaligned relocs in relocatable
	linking.
@
text
@a249 2
    // Like RELOC_ADJUST_FOR_SECTION_4 but for unaligned relocs.
    RELOC_ADJUST_FOR_SECTION_4_UNALIGNED,
a349 14
  // Like the above but for relocs at unaligned addresses.
  template<int valsize>
  static inline void
  rel_unaligned(unsigned char* view,
                const Sized_relobj_file<size, big_endian>* object,
                const Symbol_value<size>* psymval)
  {
    typedef typename elfcpp::Swap_unaligned<valsize, big_endian>::Valtype
        Valtype;
    Valtype x = elfcpp::Swap_unaligned<valsize, big_endian>::readval(view);
    x = psymval->value(object, x);
    elfcpp::Swap_unaligned<valsize, big_endian>::writeval(view, x);
  }

a560 7
  // Like above but for relocs at unaligned addresses.
  static inline void
  rel32_unaligned(unsigned char* view,
	          const Sized_relobj_file<size, big_endian>* object,
	          const Symbol_value<size>* psymval)
  { This::template rel_unaligned<32>(view, object, psymval); }

@


1.31.2.2
log
@Merge of:
CVSROOT:	/cvs/src
Module name:	src
Changes by:	dougkwan@@sourceware.org	2011-11-10 20:53:36

Modified files:
	gold           : ChangeLog arm.cc reloc.h

Log message:
	2011-11-10  Doug Kwan  <dougkwan@@google.com>

	PR gold/13362
	* arm.cc (Target_arm::Relocate::relocate_tls): Do unaligned accesses
	when processing data relocs.
	* reloc.h (Relocate_functions::rel_unaligned): New method.
	(Relocate_functions::pcrel_unaligned): Ditto.
	(Relocate_functions::rel32_unaligned): Ditto.
	(Relocate_functions::pcrel32_unaligned): Ditto.
@
text
@a335 12
  // Like the above but for relocs at unaligned addresses.
  template<int valsize>
  static inline void
  rel_unaligned(unsigned char* view,
	        typename elfcpp::Swap<valsize, big_endian>::Valtype value)
  {
    typedef typename elfcpp::Swap_unaligned<valsize, big_endian>::Valtype
	Valtype;
    Valtype x = elfcpp::Swap_unaligned<valsize, big_endian>::readval(view);
    elfcpp::Swap_unaligned<valsize, big_endian>::writeval(view, x + value);
  }

a407 13
  // Like the above but for relocs at unaligned addresses.
  template<int valsize>
  static inline void
  pcrel_unaligned(unsigned char* view,
		  typename elfcpp::Swap<valsize, big_endian>::Valtype value,
		  typename elfcpp::Elf_types<size>::Elf_Addr address)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    Valtype x = elfcpp::Swap_unaligned<valsize, big_endian>::readval(view);
    elfcpp::Swap_unaligned<valsize, big_endian>::writeval(view,
							  x + value - address);
  }

a570 5
  // Like above but for relocs at unaligned addresses.
  static inline void
  rel32_unaligned(unsigned char* view, elfcpp::Elf_Word value)
  { This::template rel_unaligned<32>(view, value); }

a602 6
  // Unaligned version of the above.
  static inline void
  pcrel32_unaligned(unsigned char* view, elfcpp::Elf_Word value,
		    typename elfcpp::Elf_types<size>::Elf_Addr address)
  { This::template pcrel_unaligned<32>(view, value, address); }

@


1.30
log
@	* dwarf_reader.h (class Sized_dwarf_line_info): Add
	track_relocs_type_ field.
	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Set track_relocs_type_.
	(Sized_dwarf_line_info::process_one_opcode): Ignore the section
	contents when using RELA relocs.
	(Sized_dwarf_line_info::read_relocs): Add the reloc addend to
	reloc_map_.
	* reloc.cc (Track_relocs::next_addend): New function.
	* reloc.h (class Track_relocs): Declare next_addend.
@
text
@d50 1
a50 1
class Sized_relobj;
d340 1
a340 1
      const Sized_relobj<size, big_endian>* object,
d368 1
a368 1
       const Sized_relobj<size, big_endian>* object,
d398 1
a398 1
	const Sized_relobj<size, big_endian>* object,
d428 1
a428 1
	 const Sized_relobj<size, big_endian>* object,
d450 1
a450 1
       const Sized_relobj<size, big_endian>* object,
d461 1
a461 1
	const Sized_relobj<size, big_endian>* object,
d475 1
a475 1
	 const Sized_relobj<size, big_endian>* object,
d489 1
a489 1
	  const Sized_relobj<size, big_endian>* object,
d503 1
a503 1
	const Sized_relobj<size, big_endian>* object,
d514 1
a514 1
	 const Sized_relobj<size, big_endian>* object,
d528 1
a528 1
	  const Sized_relobj<size, big_endian>* object,
d543 1
a543 1
	   const Sized_relobj<size, big_endian>* object,
d557 1
a557 1
	const Sized_relobj<size, big_endian>* object,
d568 1
a568 1
	 const Sized_relobj<size, big_endian>* object,
d582 1
a582 1
	  const Sized_relobj<size, big_endian>* object,
d597 1
a597 1
	   const Sized_relobj<size, big_endian>* object,
d611 1
a611 1
	const Sized_relobj<size, big_endian>* object,
d623 1
a623 1
	 const Sized_relobj<size, big_endian>* object,
d637 1
a637 1
	  const Sized_relobj<size, big_endian>* object,
d652 1
a652 1
	   const Sized_relobj<size, big_endian>* object,
@


1.29
log
@	* gold.cc (queue_middle_gc_tasks): Use a separate blocker for each
	Read_relocs task.
	(queue_middle_tasks): Likewise, and also for Scan_relocs.  Run
	Allocate_commons_task first.
	* reloc.cc (Read_relocs::run): Pass next_blocker_ down to next
	task, rather than symtab_lock_.
	(Gc_process_relocs::~Gc_process_relocs): New function.
	(Gc_process_relocs::is_runnable): Check this_blocker_.
	(Gc_process_relocs::locks): Use next_blocker_ rather than
	blocker_.
	(Scan_relocs::~Scan_relocs): New function.
	(Scan_relocs::is_runnable): Check this_blocker_ rather than
	symtab_lock_.
	(Scan_relocs::locks): Drop symtab_lock_ and blocker_.  Add
	next_blocker_.
	* reloc.h (class Read_relocs): Drop symtab_lock_ and blocker_
	fields.  Add this_blocker_ and next_blocker_ fields.  Adjust
	constructor accordingly.
	(class Gc_process_relocs): Likewise.
	(class Scan_relocs): Likewise.
	* common.h (class Allocate_commons_task): Remove symtab_lock_
	field, and corresponding constructor parameter.
	* common.cc (Allocate_commons_tasK::is_runnable): Remove use of
	symtab_lock_.
	(Allocate_commons_task::locks): Likewise.
@
text
@d681 1
a681 1
  // applies.  THis returns -1 if there is no next reloc.
d690 5
@


1.28
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d65 3
a67 2
  // SYMTAB_LOCK is used to lock the symbol table.  BLOCKER should be
  // unblocked when the Scan_relocs task completes.
d69 1
a69 1
	      Task_token* symtab_lock, Task_token* blocker)
d71 1
a71 1
      symtab_lock_(symtab_lock), blocker_(blocker)
d92 2
a93 2
  Task_token* symtab_lock_;
  Task_token* blocker_;
d102 3
a104 2
  // SYMTAB_LOCK is used to lock the symbol table.  BLOCKER should be
  // unblocked when the task completes.
d106 2
a107 2
		    Read_relocs_data* rd, Task_token* symtab_lock,
		    Task_token* blocker)
d109 1
a109 1
      symtab_lock_(symtab_lock), blocker_(blocker)
d112 2
d133 2
a134 2
  Task_token* symtab_lock_;
  Task_token* blocker_;
d143 3
a145 2
  // SYMTAB_LOCK is used to lock the symbol table.  BLOCKER should be
  // unblocked when the task completes.
d147 2
a148 2
	      Read_relocs_data* rd, Task_token* symtab_lock,
	      Task_token* blocker)
d150 1
a150 1
      symtab_lock_(symtab_lock), blocker_(blocker)
d153 2
d174 2
a175 2
  Task_token* symtab_lock_;
  Task_token* blocker_;
@


1.27
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d262 1
a262 1
  set_next_reloc_strategy(Reloc_strategy astrategy)
d264 2
a265 2
    this->reloc_strategies_.push_back(static_cast<unsigned char>(astrategy));
    if (astrategy != RELOC_DISCARD)
@


1.26
log
@	* object.h (class Relobj): Drop options parameter from
	gc_process_relocs, scan_relocs, relocate, do_gc_process_relocs,
	do_scan_relocs, do_relocate.  Change all callers.
	(class Sized_relobj): Drop options parameters from
	do_gc_process_relocs, do_scan_relocs, do_relocate,
	do_relocate_sections, relocate_sections, emit_relocs_scan,
	emit_relocs_scan_reltype.  Change all callers.
	(struct Relocate_info): Remove options field and all references to
	it.
	* reloc.h (class Read_relocs): Remove options constructor
	parameter and options_ field.  Change all callers.
	(class Gc_process_relocs, class Scan_relocs): Likewise.
	(class Relocate_task): Likewise.
	* target-reloc.h (scan_relocs): Remove options parameter.  Change
	all callers.
	(scan_relocatable_relocs): Likewise.
	* target.h (class Sized_target): Remove options parameter from
	gc_process_relocs, scan_relocs, scan_relocatable_relocs.  Change
	all callers.
	* gc.h (gc_process_relocs): Remove options parameter.  Change all
	callers.
	* arm.cc: Update functions to remove options parameters.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* testsuite/testfile.cc: Likewise.
@
text
@d262 1
a262 1
  set_next_reloc_strategy(Reloc_strategy strategy)
d264 2
a265 2
    this->reloc_strategies_.push_back(static_cast<unsigned char>(strategy));
    if (strategy != RELOC_DISCARD)
@


1.25
log
@2009-06-23  Doug Kwan  <dougkwan@@google.com>

	* Makefile.am (libgold_a_LIBADD): New.
	(ld_new_DEPENDENCIES, ld_new_LDADD): Remove LIBOBJS
 	* Makefile.in: Regenerate.
	* config.in (HAVE_DECL_MEMMEM, HAVE_DECL_STRNDUP): New.
	* configure: Regenerate.
	* configure.ac (AC_CHECK_DECLS): Add strndup and memmem.
	* fileread.cc: Include sys/state.h
	* gold.h: Declare memmem and strndup if found missing.
	* gold_reloc.h: Include byteswap.h if HAVE_BYTESWAP_H is defined.
@
text
@d67 3
a69 4
  Read_relocs(const General_options& options, Symbol_table* symtab,
	      Layout* layout, Relobj* object, Task_token* symtab_lock,
	      Task_token* blocker)
    : options_(options), symtab_(symtab), layout_(layout), object_(object),
a87 1
  const General_options& options_;
d103 5
a107 5
  Gc_process_relocs(const General_options& options, Symbol_table* symtab,
	      Layout* layout, Relobj* object, Read_relocs_data* rd,
	      Task_token* symtab_lock, Task_token* blocker)
    : options_(options), symtab_(symtab), layout_(layout), object_(object),
      rd_(rd), symtab_lock_(symtab_lock), blocker_(blocker)
a124 1
  const General_options& options_;
d141 5
a145 5
  Scan_relocs(const General_options& options, Symbol_table* symtab,
	      Layout* layout, Relobj* object, Read_relocs_data* rd,
	      Task_token* symtab_lock, Task_token* blocker)
    : options_(options), symtab_(symtab), layout_(layout), object_(object),
      rd_(rd), symtab_lock_(symtab_lock), blocker_(blocker)
a162 1
  const General_options& options_;
d176 2
a177 2
  Relocate_task(const General_options& options, const Symbol_table* symtab,
		const Layout* layout, Relobj* object, Output_file* of,
d180 2
a181 2
    : options_(options), symtab_(symtab), layout_(layout), object_(object),
      of_(of), input_sections_blocker_(input_sections_blocker),
a200 1
  const General_options& options_;
@


1.24
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d27 1
d29 1
@


1.23
log
@	* copy-relocs.cc: New file.
	* copy-relocs.h: New file.
	* reloc.cc: Remove Copy_relocs code.
	* reloc.h: Likewise.
	* reloc-types.h (struct Reloc_types) [both versions]: Add
	get_reloc_addend_noerror.
	* output.h (class Output_data_reloc<elfcpp::SHT_REL>): Add
	variants of add_global which take an addend which must be zero.
	* i386.cc: Include "copy-relocs.h".
	(class Target_i386): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_i386::copy_reloc): Rewrite to pass to Copy_relocs class.
	Change all callers.
	(Target_i386::do_finalize_sections): Change handling of
	copy_relocs_.
	* sparc.cc: Include "copy-relocs.h".
	(class Target_sparc): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_sparc::copy_reloc): Rewrite to pass to Copy_relocs class.
	Change all callers.
	(Target_sparc::do_finalize_sections): Change handling of
	copy_relocs_.
	* x86_64.cc: Include "copy-relocs.h".
	(class Target_x86_64): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_x86_64::copy_reloc): Rewrite to pass to Copy_relocs
	class.  Change all callers.
	(Target_x86_64::do_finalize_sections): Change handling of
	copy_relocs_.
	* Makefile.am (CCFILES): Add copy-relocs.cc.
	(HFILES): Add copy-relocs.h.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d95 39
@


1.22
log
@Update copyright years.  Update language files.
@
text
@a615 96
// We try to avoid COPY relocations when possible.  A COPY relocation
// may be required when an executable refers to a variable defined in
// a shared library.  COPY relocations are problematic because they
// tie the executable to the exact size of the variable in the shared
// library.  We can avoid them if all the references to the variable
// are in a writeable section.  In that case we can simply use dynamic
// relocations.  However, when scanning relocs, we don't know when we
// see the relocation whether we will be forced to use a COPY
// relocation or not.  So we have to save the relocation during the
// reloc scanning, and then emit it as a dynamic relocation if
// necessary.  This class implements that.  It is used by the target
// specific code.

template<int size, bool big_endian>
class Copy_relocs
{
 public:
  Copy_relocs()
    : entries_()
  { }

  // Return whether we need a COPY reloc for a reloc against GSYM,
  // which is being applied to section SHNDX in OBJECT.
  static bool
  need_copy_reloc(const General_options*, Relobj* object, unsigned int shndx,
		  Sized_symbol<size>* gsym);

  // Save a Rel against SYM for possible emission later.  SHNDX is the
  // index of the section to which the reloc is being applied.
  void
  save(Symbol* sym, Relobj*, unsigned int shndx,
       Output_section* output_section, const elfcpp::Rel<size, big_endian>&);

  // Save a Rela against SYM for possible emission later.
  void
  save(Symbol* sym, Relobj*, unsigned int shndx,
       Output_section* output_section, const elfcpp::Rela<size, big_endian>&);

  // Return whether there are any relocs to emit.  This also discards
  // entries which need not be emitted.
  bool
  any_to_emit();

  // Emit relocs for each symbol which did not get a COPY reloc (i.e.,
  // is still defined in the dynamic object).
  template<int sh_type>
  void
  emit(Output_data_reloc<sh_type, true, size, big_endian>*);

 private:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Addend;

  // This POD class holds the entries we are saving.
  class Copy_reloc_entry
  {
   public:
    Copy_reloc_entry(Symbol* sym, unsigned int reloc_type,
		     Relobj* relobj, unsigned int shndx,
		     Output_section* output_section,
		     Address address, Addend addend)
      : sym_(sym), reloc_type_(reloc_type), relobj_(relobj),
	shndx_(shndx), output_section_(output_section),
	address_(address), addend_(addend)
    { }

    // Return whether we should emit this reloc.  If we should not
    // emit, we clear it.
    bool
    should_emit();

    // Emit this reloc.

    void
    emit(Output_data_reloc<elfcpp::SHT_REL, true, size, big_endian>*);

    void
    emit(Output_data_reloc<elfcpp::SHT_RELA, true, size, big_endian>*);

   private:
    Symbol* sym_;
    unsigned int reloc_type_;
    Relobj* relobj_;
    unsigned int shndx_;
    Output_section* output_section_;
    Address address_;
    Addend addend_;
  };

  // A list of relocs to be saved.
  typedef std::vector<Copy_reloc_entry> Copy_reloc_entries;

  // The list of relocs we are saving.
  Copy_reloc_entries entries_;
};

@


1.21
log
@Implement -q/--emit-relocs.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.20
log
@Initial -r support.
@
text
@d197 3
@


1.19
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d41 1
d172 94
@


1.18
log
@Rewrite workqueue.  This version eliminates the master thread, and
reduces the amount of locking required to find a new thread to run.
@
text
@d654 1
a654 1
  off_t len_;
d656 1
a656 1
  off_t pos_;
@


1.17
log
@Add threading support.
@
text
@d26 1
d73 2
a74 2
  Is_runnable_type
  is_runnable(Workqueue*);
d76 2
a77 2
  Task_locker*
  locks(Workqueue*);
d111 2
a112 2
  Is_runnable_type
  is_runnable(Workqueue*);
d114 2
a115 2
  Task_locker*
  locks(Workqueue*);
a123 2
  class Scan_relocs_locker;

d150 2
a151 2
  Is_runnable_type
  is_runnable(Workqueue*);
d153 2
a154 2
  Task_locker*
  locks(Workqueue*);
a162 2
  class Relocate_locker;

@


1.16
log
@From Cary Coutant: Count textrel with output sections rather than
setting a flag as we add each reloc in the target code.
@
text
@d81 3
d119 3
d159 3
@


1.15
log
@From Craig Silverstein: Track_relocs doesn't need to hold onto the
object.
@
text
@d40 1
d543 1
a543 1
       const elfcpp::Rel<size, big_endian>&);
d548 1
a548 1
       const elfcpp::Rela<size, big_endian>&);
d571 1
d574 2
a575 1
	shndx_(shndx), address_(address), addend_(addend)
d596 1
@


1.14
log
@From Craig Silverstein: Use relocations in reporting error message
locations.
@
text
@d35 1
d613 1
a613 1
    : object_(NULL), prelocs_(NULL), len_(0), pos_(0), reloc_size_(0)
d622 1
a622 1
  initialize(Sized_relobj<size, big_endian>* object, unsigned int reloc_shndx,
d641 1
a641 3
  // The object file.
  Sized_relobj<size, big_endian>* object_;
  // The contents of the reloc section.
@


1.13
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d28 1
@


1.12
log
@Cleanups from Craig Silverstein.
@
text
@d132 2
a133 1
		Task_token* final_blocker)
d135 3
a137 1
      of_(of), final_blocker_(final_blocker)
d159 2
d600 49
@


1.11
log
@Add Signed_valtype and use it for sign extension.  Fix names of rela8.
@
text
@a222 25
  // Like rel(), but sign-extends the value to SIZE.
  template<int valsize>
  static inline void
  signedrel(unsigned char* view,
            const Sized_relobj<size, big_endian>* object,
            const Symbol_value<size>* psymval)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<valsize, big_endian>::Signed_valtype
      Signed_valtype;
    typedef typename elfcpp::Swap<size, big_endian>::Valtype Sizetype;
    typedef typename elfcpp::Swap<size, big_endian>::Signed_valtype
      Signed_sizetype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype x = elfcpp::Swap<valsize, big_endian>::readval(wv);

    // Sign extend the value.
    Signed_valtype signed_x = static_cast<Signed_valtype>(x);
    Signed_sizetype signed_extended_x = static_cast<Signed_sizetype>(signed_x);
    Sizetype unsigned_extended_x = static_cast<Sizetype>(signed_extended_x);

    x = psymval->value(object, unsigned_extended_x);
    elfcpp::Swap<valsize, big_endian>::writeval(wv, x);
  }

a310 7
  // Do an 8-bit REL relocation, sign extending the addend to SIZE.
  static inline void
  rel8s(unsigned char* view,
         const Sized_relobj<size, big_endian>* object,
         const Symbol_value<size>* psymval)
  { This::template signedrel<8>(view, object, psymval); }

a363 7
  // Do a 16-bit REL relocation, sign extending the addend to SIZE.
  static inline void
  rel16s(unsigned char* view,
         const Sized_relobj<size, big_endian>* object,
         const Symbol_value<size>* psymval)
  { This::template signedrel<16>(view, object, psymval); }

a416 7

  // Do a 32-bit REL relocation, sign extending the addend to SIZE.
  static inline void
  rel32s(unsigned char* view,
         const Sized_relobj<size, big_endian>* object,
         const Symbol_value<size>* psymval)
  { This::template signedrel<32>(view, object, psymval); }
@


1.10
log
@Add RELA versions of the relocation routines.  Original patch from
Craig Silverstein, with Symbol_value<> versions added.
@
text
@d231 2
d234 2
d238 7
a244 5
    // Fancy formula to sign-extend x to size.
    const Sizetype mask = 1U << (sizeof(valsize) * 8 - 1);
    Sizetype sign_extended_x = x;
    sign_extended_x = (sign_extended_x ^ mask) - mask;
    x = psymval->value(object, sign_extended_x);
d326 1
a326 1
  rel8a(unsigned char* view, unsigned char value, unsigned char addend)
d330 1
a330 1
  rel8a(unsigned char* view,
@


1.9
log
@From Andrew Chatham: add signedrel<>, rel32s and friends.
@
text
@d195 28
d273 30
d318 12
d351 15
d378 12
d397 1
a397 1
  // Do a simple 32-bit PC relative REL relocation with the addend in
d400 1
a400 1
  pcrel16(unsigned char* view, elfcpp::Elf_Word value,
d411 16
d439 12
d472 16
d500 13
d526 16
@


1.8
log
@Add licensing text to every source file.
@
text
@d195 19
d260 7
d293 7
d325 7
@


1.7
log
@Add support for SHF_MERGE sections.
@
text
@d3 20
@


1.6
log
@Added a testsuite.  More support for COPY relocations.
@
text
@a15 1
class Stringpool;
d22 6
d159 16
d189 17
d209 2
a210 2
  // Do a simple 8-bit REL relocation with the addend in the object
  // file data.
d213 7
a219 3
  {
    This::template rel<8>(view, value);
  }
d222 1
a222 1
  // object file data.
d226 8
a233 3
  {
    This::template pcrel<8>(view, value, address);
  }
d235 2
a236 2
  // Do a simple 16-bit REL relocation with the addend in the object
  // file data.
d239 7
a245 3
  {
    This::template rel<16>(view, value);
  }
d248 1
a248 1
  // the object file data.
d252 8
a259 3
  {
    This::template pcrel<16>(view, value, address);
  }
d265 7
a271 3
  {
    This::template rel<32>(view, value);
  }
d278 8
a285 3
  {
    This::template pcrel<32>(view, value, address);
  }
d291 7
a297 3
  {
    This::template rel<64>(view, value);
  }
d304 8
a311 3
  {
    This::template pcrel<64>(view, value, address);
  }
@


1.5
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d20 6
d238 22
d265 66
a330 1
		  Symbol* gsym);
@


1.4
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@d13 1
d17 1
d232 6
@


1.3
log
@Can now do a full static link of hello, world in C or C++
@
text
@d13 1
a13 1
class Object;
d28 1
a28 1
	      Layout* layout, Object* object, Task_token* symtab_lock,
d49 1
a49 1
  Object* object_;
d63 1
a63 1
	      Layout* layout, Object* object, Read_relocs_data* rd,
d86 1
a86 1
  Object* object_;
d98 1
a98 1
		const Layout* layout, Object* object, Output_file* of,
d121 1
a121 1
  Object* object_;
a125 316
// Integer swapping routines used by relocation functions.  FIXME:
// Maybe these should be more general, and/or shared with elfcpp.

// Endian simply indicates whether the host is big endian or not,
// based on the results of the configure script.

struct Endian
{
 public:
  // Used for template specializations.
#ifdef WORDS_BIGENDIAN
  static const bool host_big_endian = true;
#else
  static const bool host_big_endian = false;
#endif
};

// Valtype_base is a template based on size (8, 16, 32, 64) which
// defines a typedef Valtype for the unsigned integer of the specified
// size.

template<int size>
struct Valtype_base;

template<>
struct Valtype_base<8>
{
  typedef unsigned char Valtype;
};

template<>
struct Valtype_base<16>
{
  typedef uint16_t Valtype;
};

template<>
struct Valtype_base<32>
{
  typedef uint32_t Valtype;
};

template<>
struct Valtype_base<64>
{
  typedef uint64_t Valtype;
};

// Convert_host is a template based on size and on whether the host
// and target have the same endianness.  It defines the type Valtype,
// and defines a function convert_host which takes an argument of type
// Valtype and swaps it if the host and target have different
// endianness.

template<int size, bool same_endian>
struct Convert_host;

template<int size>
struct Convert_host<size, true>
{
  typedef typename Valtype_base<size>::Valtype Valtype;

  static inline Valtype
  convert_host(Valtype v)
  { return v; }
};

template<>
struct Convert_host<8, false>
{
  typedef Valtype_base<8>::Valtype Valtype;

  static inline Valtype
  convert_host(Valtype v)
  { return v; }
};

template<>
struct Convert_host<16, false>
{
  typedef Valtype_base<16>::Valtype Valtype;

  static inline Valtype
  convert_host(Valtype v)
  { return bswap_16(v); }
};

template<>
struct Convert_host<32, false>
{
  typedef Valtype_base<32>::Valtype Valtype;

  static inline Valtype
  convert_host(Valtype v)
  { return bswap_32(v); }
};

template<>
struct Convert_host<64, false>
{
  typedef Valtype_base<64>::Valtype Valtype;

  static inline Valtype
  convert_host(Valtype v)
  { return bswap_64(v); }
};

// Convert is a template based on size and on whether we have a big
// endian target.  It defines Valtype and convert_host like
// Convert_host.  That is, it is just like Convert_host except in the
// meaning of the second template parameter.

template<int size, bool big_endian>
struct Convert
{
  typedef typename Valtype_base<size>::Valtype Valtype;

  static inline Valtype
  convert_host(Valtype v)
  { return Convert_host<size, big_endian == Endian::host_big_endian>
      ::convert_host(v); }
};

// Swap is a template based on size and on whether the target is big
// endian.  It defines the type Valtype and the functions readval and
// writeval.  The functions read and write values of the appropriate
// size out of buffers, swapping them if necessary.

template<int size, bool big_endian>
struct Swap
{
  typedef typename Valtype_base<size>::Valtype Valtype;

  static inline Valtype
  readval(const Valtype* wv)
  { return Convert<size, big_endian>::convert_host(*wv); }

  static inline void
  writeval(Valtype* wv, Valtype v)
  { *wv = Convert<size, big_endian>::convert_host(v); }
};

// Swap_unaligned is a template based on size and on whether the
// target is big endian.  It defines the type Valtype and the
// functions readval_unaligned and writeval_unaligned.  The functions
// read and write values of the appropriate size out of buffers which
// may be misaligned.

template<int size, bool big_endian>
class Swap_unaligned;

template<bool big_endian>
class Swap_unaligned<8, big_endian>
{
public:
  typedef typename Valtype_base<8>::Valtype Valtype;

  static inline Valtype
  readval_unaligned(const unsigned char* wv)
  { return *wv; }

  static inline void
  writeval_unaligned(unsigned char* wv, Valtype v)
  { *wv = v; }
};

template<>
class Swap_unaligned<16, false>
{
public:
  typedef Valtype_base<16>::Valtype Valtype;

  static inline Valtype
  readval_unaligned(const unsigned char* wv)
  {
    return (wv[1] << 8) | wv[0];
  }

  static inline void
  writeval_unaligned(unsigned char* wv, Valtype v)
  {
    wv[1] = v >> 8;
    wv[0] = v;
  }
};

template<>
class Swap_unaligned<16, true>
{
public:
  typedef Valtype_base<16>::Valtype Valtype;

  static inline Valtype
  readval_unaligned(const unsigned char* wv)
  {
    return (wv[0] << 8) | wv[1];
  }

  static inline void
  writeval_unaligned(unsigned char* wv, Valtype v)
  {
    wv[0] = v >> 8;
    wv[1] = v;
  }
};

template<>
class Swap_unaligned<32, false>
{
public:
  typedef Valtype_base<32>::Valtype Valtype;

  static inline Valtype
  readval_unaligned(const unsigned char* wv)
  {
    return (wv[3] << 24) | (wv[2] << 16) | (wv[1] << 8) | wv[0];
  }

  static inline void
  writeval_unaligned(unsigned char* wv, Valtype v)
  {
    wv[3] = v >> 24;
    wv[2] = v >> 16;
    wv[1] = v >> 8;
    wv[0] = v;
  }
};

template<>
class Swap_unaligned<32, true>
{
public:
  typedef Valtype_base<32>::Valtype Valtype;

  static inline Valtype
  readval_unaligned(const unsigned char* wv)
  {
    return (wv[0] << 24) | (wv[1] << 16) | (wv[2] << 8) | wv[3];
  }

  static inline void
  writeval_unaligned(unsigned char* wv, Valtype v)
  {
    wv[0] = v >> 24;
    wv[1] = v >> 16;
    wv[2] = v >> 8;
    wv[3] = v;
  }
};

template<>
class Swap_unaligned<64, false>
{
public:
  typedef Valtype_base<64>::Valtype Valtype;

  static inline Valtype
  readval_unaligned(const unsigned char* wv)
  {
    return ((static_cast<Valtype>(wv[7]) << 56)
	    | (static_cast<Valtype>(wv[6]) << 48)
	    | (static_cast<Valtype>(wv[5]) << 40)
	    | (static_cast<Valtype>(wv[4]) << 32)
	    | (static_cast<Valtype>(wv[3]) << 24)
	    | (static_cast<Valtype>(wv[2]) << 16)
	    | (static_cast<Valtype>(wv[1]) << 8)
	    | static_cast<Valtype>(wv[0]));
  }

  static inline void
  writeval_unaligned(unsigned char* wv, Valtype v)
  {
    wv[7] = v >> 56;
    wv[6] = v >> 48;
    wv[5] = v >> 40;
    wv[4] = v >> 32;
    wv[3] = v >> 24;
    wv[2] = v >> 16;
    wv[1] = v >> 8;
    wv[0] = v;
  }
};

template<>
class Swap_unaligned<64, true>
{
public:
  typedef Valtype_base<64>::Valtype Valtype;

  static inline Valtype
  readval_unaligned(const unsigned char* wv)
  {
    return ((static_cast<Valtype>(wv[0]) << 56)
	    | (static_cast<Valtype>(wv[1]) << 48)
	    | (static_cast<Valtype>(wv[2]) << 40)
	    | (static_cast<Valtype>(wv[3]) << 32)
	    | (static_cast<Valtype>(wv[4]) << 24)
	    | (static_cast<Valtype>(wv[5]) << 16)
	    | (static_cast<Valtype>(wv[6]) << 8)
	    | static_cast<Valtype>(wv[7]));
  }

  static inline void
  writeval_unaligned(unsigned char* wv, Valtype v)
  {
    wv[7] = v >> 56;
    wv[6] = v >> 48;
    wv[5] = v >> 40;
    wv[4] = v >> 32;
    wv[3] = v >> 24;
    wv[2] = v >> 16;
    wv[1] = v >> 8;
    wv[0] = v;
  }
};

d137 2
a138 1
  rel(unsigned char* view, typename Swap<valsize, big_endian>::Valtype value)
d140 1
a140 1
    typedef typename Swap<valsize, big_endian>::Valtype Valtype;
d142 2
a143 2
    Valtype x = Swap<valsize, big_endian>::readval(wv);
    Swap<valsize, big_endian>::writeval(wv, x + value);
d150 2
a151 1
  pcrel(unsigned char* view, typename Swap<valsize, big_endian>::Valtype value,
d154 1
a154 1
    typedef typename Swap<valsize, big_endian>::Valtype Valtype;
d156 2
a157 2
    Valtype x = Swap<valsize, big_endian>::readval(wv);
    Swap<valsize, big_endian>::writeval(wv, x + value - address);
d217 1
a217 1
  rel64(unsigned char* view, elfcpp::Elf_Word value)
d225 1
a225 1
  pcrel64(unsigned char* view, elfcpp::Elf_Word value,
@


1.2
log
@Framework for relocation scanning.  Implement simple static TLS
relocations.
@
text
@d16 1
d28 1
a28 1
	      Object* object, Task_token* symtab_lock,
d30 1
a30 1
    : options_(options), symtab_(symtab), object_(object),
d48 1
d63 4
a66 4
	      Object* object, Read_relocs_data* rd, Task_token* symtab_lock,
	      Task_token* blocker)
    : options_(options), symtab_(symtab), object_(object), rd_(rd),
      symtab_lock_(symtab_lock), blocker_(blocker)
d85 1
@


1.1
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d6 2
d13 78
d95 1
a95 1
		const Stringpool* sympool, Object* object, Output_file* of,
d97 1
a97 1
    : options_(options), symtab_(symtab), sympool_(sympool), object_(object),
d117 1
a117 1
  const Stringpool* sympool_;
d121 420
@

