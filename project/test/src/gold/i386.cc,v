head	1.156;
access;
symbols
	binutils-2_24-branch:1.155.0.2
	binutils-2_24-branchpoint:1.155
	binutils-2_21_1:1.125
	binutils-2_23_2:1.145.2.2
	binutils-2_23_1:1.145.2.2
	binutils-2_23:1.145
	binutils-2_23-branch:1.145.0.2
	binutils-2_23-branchpoint:1.145
	binutils-2_22_branch:1.141.0.4
	binutils-2_22:1.141
	binutils-2_22-branch:1.141.0.2
	binutils-2_22-branchpoint:1.141
	binutils-2_21:1.125
	binutils-2_21-branch:1.125.0.2
	binutils-2_21-branchpoint:1.125
	binutils-2_20_1:1.88.4.3
	binutils-2_20:1.88.4.1
	binutils-arc-20081103-branch:1.82.0.4
	binutils-arc-20081103-branchpoint:1.82
	binutils-2_20-branch:1.88.0.4
	binutils-2_20-branchpoint:1.88
	dje-cgen-play1-branch:1.88.0.2
	dje-cgen-play1-branchpoint:1.88
	arc-20081103-branch:1.82.0.2
	arc-20081103-branchpoint:1.82
	binutils-2_19_1:1.79
	binutils-2_19:1.79
	binutils-2_19-branch:1.79.0.2
	binutils-2_19-branchpoint:1.79
	binutils_latest_snapshot:1.156
	added-to-binutils:1.64;
locks; strict;
comment	@// @;


1.156
date	2013.10.11.21.11.49;	author roland;	state Exp;
branches;
next	1.155;

1.155
date	2013.08.16.18.12.05;	author roland;	state Exp;
branches
	1.155.2.1;
next	1.154;

1.154
date	2013.07.30.21.26.52;	author ccoutant;	state Exp;
branches;
next	1.153;

1.153
date	2013.04.27.00.53.16;	author ian;	state Exp;
branches;
next	1.152;

1.152
date	2012.11.02.19.50.36;	author roland;	state Exp;
branches;
next	1.151;

1.151
date	2012.11.01.23.27.00;	author roland;	state Exp;
branches;
next	1.150;

1.150
date	2012.10.18.04.18.18;	author amodra;	state Exp;
branches;
next	1.149;

1.149
date	2012.10.05.00.45.54;	author amodra;	state Exp;
branches;
next	1.148;

1.148
date	2012.09.12.22.43.53;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2012.09.10.23.05.54;	author amodra;	state Exp;
branches;
next	1.146;

1.146
date	2012.09.05.00.34.20;	author amodra;	state Exp;
branches;
next	1.145;

1.145
date	2012.05.02.21.37.23;	author roland;	state Exp;
branches
	1.145.2.1;
next	1.144;

1.144
date	2012.01.24.06.21.11;	author ian;	state Exp;
branches;
next	1.143;

1.143
date	2011.12.17.22.39.52;	author ccoutant;	state Exp;
branches;
next	1.142;

1.142
date	2011.10.31.22.33.04;	author ccoutant;	state Exp;
branches;
next	1.141;

1.141
date	2011.07.15.15.31.54;	author ian;	state Exp;
branches
	1.141.2.1;
next	1.140;

1.140
date	2011.07.13.22.47.07;	author ian;	state Exp;
branches;
next	1.139;

1.139
date	2011.07.12.22.29.09;	author ian;	state Exp;
branches;
next	1.138;

1.138
date	2011.07.09.00.47.11;	author ian;	state Exp;
branches;
next	1.137;

1.137
date	2011.07.08.23.49.11;	author ian;	state Exp;
branches;
next	1.136;

1.136
date	2011.07.08.22.48.08;	author ian;	state Exp;
branches;
next	1.135;

1.135
date	2011.07.06.05.12.03;	author ian;	state Exp;
branches;
next	1.134;

1.134
date	2011.07.02.00.03.25;	author ian;	state Exp;
branches;
next	1.133;

1.133
date	2011.07.01.22.54.04;	author ian;	state Exp;
branches;
next	1.132;

1.132
date	2011.07.01.22.05.01;	author ian;	state Exp;
branches;
next	1.131;

1.131
date	2011.06.28.23.12.31;	author ian;	state Exp;
branches;
next	1.130;

1.130
date	2011.06.28.22.25.13;	author ian;	state Exp;
branches;
next	1.129;

1.129
date	2011.06.28.21.15.42;	author ian;	state Exp;
branches;
next	1.128;

1.128
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.127;

1.127
date	2010.12.14.19.03.30;	author rwild;	state Exp;
branches;
next	1.126;

1.126
date	2010.11.11.10.43.30;	author rsandifo;	state Exp;
branches;
next	1.125;

1.125
date	2010.09.28.17.14.15;	author tmsriram;	state Exp;
branches;
next	1.124;

1.124
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.123;

1.123
date	2010.08.19.22.50.15;	author ian;	state Exp;
branches;
next	1.122;

1.122
date	2010.08.12.22.14.59;	author ccoutant;	state Exp;
branches;
next	1.121;

1.121
date	2010.08.03.14.07.13;	author ian;	state Exp;
branches;
next	1.120;

1.120
date	2010.08.02.10.07.03;	author ian;	state Exp;
branches;
next	1.119;

1.119
date	2010.07.29.18.57.28;	author tmsriram;	state Exp;
branches;
next	1.118;

1.118
date	2010.07.13.12.04.03;	author ian;	state Exp;
branches;
next	1.117;

1.117
date	2010.03.11.01.18.26;	author ian;	state Exp;
branches;
next	1.116;

1.116
date	2010.03.11.01.10.53;	author ian;	state Exp;
branches;
next	1.115;

1.115
date	2010.03.04.01.33.22;	author tmsriram;	state Exp;
branches;
next	1.114;

1.114
date	2010.02.13.02.04.20;	author tmsriram;	state Exp;
branches;
next	1.113;

1.113
date	2010.02.10.23.00.29;	author ian;	state Exp;
branches;
next	1.112;

1.112
date	2010.02.09.20.29.44;	author davem;	state Exp;
branches;
next	1.111;

1.111
date	2010.01.08.19.33.17;	author ian;	state Exp;
branches;
next	1.110;

1.110
date	2010.01.07.20.43.35;	author ian;	state Exp;
branches;
next	1.109;

1.109
date	2009.12.30.07.22.06;	author ian;	state Exp;
branches;
next	1.108;

1.108
date	2009.12.30.06.57.17;	author ian;	state Exp;
branches;
next	1.107;

1.107
date	2009.12.29.00.31.48;	author ian;	state Exp;
branches;
next	1.106;

1.106
date	2009.12.23.23.53.43;	author ian;	state Exp;
branches;
next	1.105;

1.105
date	2009.12.14.19.53.04;	author ian;	state Exp;
branches;
next	1.104;

1.104
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	2009.12.07.17.14.55;	author hjl;	state Exp;
branches;
next	1.102;

1.102
date	2009.12.06.02.49.46;	author dougkwan;	state Exp;
branches;
next	1.101;

1.101
date	2009.12.03.23.13.55;	author dougkwan;	state Exp;
branches;
next	1.100;

1.100
date	2009.11.09.23.07.30;	author dougkwan;	state Exp;
branches;
next	1.99;

1.99
date	2009.11.04.16.35.51;	author ian;	state Exp;
branches;
next	1.98;

1.98
date	2009.11.04.15.56.03;	author ian;	state Exp;
branches;
next	1.97;

1.97
date	2009.10.30.18.49.59;	author dougkwan;	state Exp;
branches;
next	1.96;

1.96
date	2009.10.29.05.16.23;	author ian;	state Exp;
branches;
next	1.95;

1.95
date	2009.10.15.00.33.18;	author ian;	state Exp;
branches;
next	1.94;

1.94
date	2009.10.14.05.25.01;	author ian;	state Exp;
branches;
next	1.93;

1.93
date	2009.10.13.00.39.31;	author tmsriram;	state Exp;
branches;
next	1.92;

1.92
date	2009.10.06.22.58.27;	author ian;	state Exp;
branches;
next	1.91;

1.91
date	2009.10.06.21.44.11;	author ian;	state Exp;
branches;
next	1.90;

1.90
date	2009.10.06.21.36.00;	author ian;	state Exp;
branches;
next	1.89;

1.89
date	2009.10.01.00.58.38;	author dougkwan;	state Exp;
branches;
next	1.88;

1.88
date	2009.06.22.06.51.53;	author ian;	state Exp;
branches
	1.88.4.1;
next	1.87;

1.87
date	2009.06.05.21.32.56;	author dougkwan;	state Exp;
branches;
next	1.86;

1.86
date	2009.03.24.00.31.28;	author ian;	state Exp;
branches;
next	1.85;

1.85
date	2009.03.04.06.46.27;	author ian;	state Exp;
branches;
next	1.84;

1.84
date	2009.01.30.00.21.46;	author ccoutant;	state Exp;
branches;
next	1.83;

1.83
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	1.82;

1.82
date	2008.09.16.17.23.37;	author ian;	state Exp;
branches;
next	1.81;

1.81
date	2008.09.16.04.31.25;	author aoliva;	state Exp;
branches;
next	1.80;

1.80
date	2008.09.16.04.23.29;	author aoliva;	state Exp;
branches;
next	1.79;

1.79
date	2008.08.04.22.22.13;	author ian;	state Exp;
branches;
next	1.78;

1.78
date	2008.07.10.23.01.19;	author ian;	state Exp;
branches;
next	1.77;

1.77
date	2008.05.21.21.37.44;	author ian;	state Exp;
branches;
next	1.76;

1.76
date	2008.05.20.04.00.46;	author ian;	state Exp;
branches;
next	1.75;

1.75
date	2008.05.16.20.44.22;	author ian;	state Exp;
branches;
next	1.74;

1.74
date	2008.05.06.05.03.15;	author ian;	state Exp;
branches;
next	1.73;

1.73
date	2008.04.28.23.09.21;	author ccoutant;	state Exp;
branches;
next	1.72;

1.72
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.71;

1.71
date	2008.04.17.02.00.54;	author ccoutant;	state Exp;
branches;
next	1.70;

1.70
date	2008.04.16.22.54.29;	author ian;	state Exp;
branches;
next	1.69;

1.69
date	2008.04.11.23.37.24;	author ccoutant;	state Exp;
branches;
next	1.68;

1.68
date	2008.04.11.21.24.29;	author ccoutant;	state Exp;
branches;
next	1.67;

1.67
date	2008.04.09.00.48.13;	author ian;	state Exp;
branches;
next	1.66;

1.66
date	2008.03.25.21.39.01;	author ian;	state Exp;
branches;
next	1.65;

1.65
date	2008.03.25.18.37.16;	author ccoutant;	state Exp;
branches;
next	1.64;

1.64
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.63;

1.63
date	2008.02.29.19.19.17;	author iant;	state Exp;
branches;
next	1.62;

1.62
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.61;

1.61
date	2008.02.27.22.38.18;	author iant;	state Exp;
branches;
next	1.60;

1.60
date	2008.02.26.22.10.32;	author iant;	state Exp;
branches;
next	1.59;

1.59
date	2008.02.13.02.44.50;	author iant;	state Exp;
branches;
next	1.58;

1.58
date	2008.02.12.00.28.48;	author iant;	state Exp;
branches;
next	1.57;

1.57
date	2008.02.08.22.49.22;	author iant;	state Exp;
branches;
next	1.56;

1.56
date	2008.02.06.08.13.50;	author iant;	state Exp;
branches;
next	1.55;

1.55
date	2008.02.01.00.39.09;	author iant;	state Exp;
branches;
next	1.54;

1.54
date	2008.01.26.01.17.45;	author iant;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.23.07.15.59;	author iant;	state Exp;
branches;
next	1.52;

1.52
date	2007.12.21.23.31.19;	author iant;	state Exp;
branches;
next	1.51;

1.51
date	2007.12.20.21.21.24;	author iant;	state Exp;
branches;
next	1.50;

1.50
date	2007.12.11.23.30.52;	author iant;	state Exp;
branches;
next	1.49;

1.49
date	2007.12.11.04.23.05;	author iant;	state Exp;
branches;
next	1.48;

1.48
date	2007.12.07.19.32.56;	author iant;	state Exp;
branches;
next	1.47;

1.47
date	2007.12.06.05.55.50;	author iant;	state Exp;
branches;
next	1.46;

1.46
date	2007.11.29.20.10.16;	author iant;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.15.23.46.46;	author iant;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.15.01.12.55;	author iant;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.14.22.31.02;	author iant;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.14.16.53.24;	author iant;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.14.08.03.41;	author iant;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.14.07.52.21;	author iant;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.12.17.51.55;	author iant;	state Exp;
branches;
next	1.38;

1.38
date	2007.11.09.19.45.08;	author iant;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.02.04.08.52;	author iant;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.01.00.19.30;	author iant;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.29.20.09.35;	author iant;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.23.05.05.48;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.22.23.08.22;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.20.00.33.31;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.16.23.23.08;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.16.22.38.35;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.16.00.42.36;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.14.06.57.58;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.14.06.49.13;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.13.00.15.07;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.11.19.13.02;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.08.05.12.59;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.07.17.05.07;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.04.22.28.36;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.01.23.42.58;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.23.05.31.48;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.21.07.34.51;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.21.07.20.01;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.21.05.31.19;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.12.16.38.04;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.16.17.42.48;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.06.00.02.36;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.01.16.51.25;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.30.23.52.50;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.16.00.38.25;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.03.18.26.10;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.20.20.40.49;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.29.19.58.16;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.27.22.53.42;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.18.22.29.20;	author iant;	state Exp;
branches;
next	;

1.155.2.1
date	2013.10.11.21.23.42;	author roland;	state Exp;
branches;
next	;

1.145.2.1
date	2012.11.07.17.34.23;	author roland;	state Exp;
branches;
next	1.145.2.2;

1.145.2.2
date	2012.11.07.17.36.16;	author roland;	state Exp;
branches;
next	1.145.2.3;

1.145.2.3
date	2013.08.16.18.12.30;	author roland;	state Exp;
branches;
next	;

1.141.2.1
date	2011.12.19.21.14.39;	author ian;	state Exp;
branches;
next	;

1.88.4.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	1.88.4.2;

1.88.4.2
date	2009.11.04.15.56.34;	author ian;	state Exp;
branches;
next	1.88.4.3;

1.88.4.3
date	2009.11.04.16.36.08;	author ian;	state Exp;
branches;
next	;


desc
@@


1.156
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@// i386.cc -- i386 target support for gold.

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cstring>

#include "elfcpp.h"
#include "dwarf.h"
#include "parameters.h"
#include "reloc.h"
#include "i386.h"
#include "object.h"
#include "symtab.h"
#include "layout.h"
#include "output.h"
#include "copy-relocs.h"
#include "target.h"
#include "target-reloc.h"
#include "target-select.h"
#include "tls.h"
#include "freebsd.h"
#include "nacl.h"
#include "gc.h"

namespace
{

using namespace gold;

// A class to handle the PLT data.
// This is an abstract base class that handles most of the linker details
// but does not know the actual contents of PLT entries.  The derived
// classes below fill in those details.

class Output_data_plt_i386 : public Output_section_data
{
 public:
  typedef Output_data_reloc<elfcpp::SHT_REL, true, 32, false> Reloc_section;

  Output_data_plt_i386(Layout*, uint64_t addralign,
		       Output_data_space*, Output_data_space*);

  // Add an entry to the PLT.
  void
  add_entry(Symbol_table*, Layout*, Symbol* gsym);

  // Add an entry to the PLT for a local STT_GNU_IFUNC symbol.
  unsigned int
  add_local_ifunc_entry(Symbol_table*, Layout*,
			Sized_relobj_file<32, false>* relobj,
			unsigned int local_sym_index);

  // Return the .rel.plt section data.
  Reloc_section*
  rel_plt() const
  { return this->rel_; }

  // Return where the TLS_DESC relocations should go.
  Reloc_section*
  rel_tls_desc(Layout*);

  // Return where the IRELATIVE relocations should go.
  Reloc_section*
  rel_irelative(Symbol_table*, Layout*);

  // Return whether we created a section for IRELATIVE relocations.
  bool
  has_irelative_section() const
  { return this->irelative_rel_ != NULL; }

  // Return the number of PLT entries.
  unsigned int
  entry_count() const
  { return this->count_ + this->irelative_count_; }

  // Return the offset of the first non-reserved PLT entry.
  unsigned int
  first_plt_entry_offset()
  { return this->get_plt_entry_size(); }

  // Return the size of a PLT entry.
  unsigned int
  get_plt_entry_size() const
  { return this->do_get_plt_entry_size(); }

  // Return the PLT address to use for a global symbol.
  uint64_t
  address_for_global(const Symbol*);

  // Return the PLT address to use for a local symbol.
  uint64_t
  address_for_local(const Relobj*, unsigned int symndx);

  // Add .eh_frame information for the PLT.
  void
  add_eh_frame(Layout* layout)
  { this->do_add_eh_frame(layout); }

 protected:
  // Fill the first PLT entry, given the pointer to the PLT section data
  // and the runtime address of the GOT.
  void
  fill_first_plt_entry(unsigned char* pov,
		       elfcpp::Elf_types<32>::Elf_Addr got_address)
  { this->do_fill_first_plt_entry(pov, got_address); }

  // Fill a normal PLT entry, given the pointer to the entry's data in the
  // section, the runtime address of the GOT, the offset into the GOT of
  // the corresponding slot, the offset into the relocation section of the
  // corresponding reloc, and the offset of this entry within the whole
  // PLT.  Return the offset from this PLT entry's runtime address that
  // should be used to compute the initial value of the GOT slot.
  unsigned int
  fill_plt_entry(unsigned char* pov,
		 elfcpp::Elf_types<32>::Elf_Addr got_address,
		 unsigned int got_offset,
		 unsigned int plt_offset,
		 unsigned int plt_rel_offset)
  {
    return this->do_fill_plt_entry(pov, got_address, got_offset,
				   plt_offset, plt_rel_offset);
  }

  virtual unsigned int
  do_get_plt_entry_size() const = 0;

  virtual void
  do_fill_first_plt_entry(unsigned char* pov,
			  elfcpp::Elf_types<32>::Elf_Addr got_address) = 0;

  virtual unsigned int
  do_fill_plt_entry(unsigned char* pov,
		    elfcpp::Elf_types<32>::Elf_Addr got_address,
		    unsigned int got_offset,
		    unsigned int plt_offset,
		    unsigned int plt_rel_offset) = 0;

  virtual void
  do_add_eh_frame(Layout*) = 0;

  void
  do_adjust_output_section(Output_section* os);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** PLT")); }

  // The .eh_frame unwind information for the PLT.
  // The CIE is common across variants of the PLT format.
  static const int plt_eh_frame_cie_size = 16;
  static const unsigned char plt_eh_frame_cie[plt_eh_frame_cie_size];

 private:
  // Set the final size.
  void
  set_final_data_size()
  {
    this->set_data_size((this->count_ + this->irelative_count_ + 1)
			* this->get_plt_entry_size());
  }

  // Write out the PLT data.
  void
  do_write(Output_file*);

  // We keep a list of global STT_GNU_IFUNC symbols, each with its
  // offset in the GOT.
  struct Global_ifunc
  {
    Symbol* sym;
    unsigned int got_offset;
  };

  // We keep a list of local STT_GNU_IFUNC symbols, each with its
  // offset in the GOT.
  struct Local_ifunc
  {
    Sized_relobj_file<32, false>* object;
    unsigned int local_sym_index;
    unsigned int got_offset;
  };

  // A pointer to the Layout class, so that we can find the .dynamic
  // section when we write out the GOT PLT section.
  Layout* layout_;
  // The reloc section.
  Reloc_section* rel_;
  // The TLS_DESC relocations, if necessary.  These must follow the
  // regular PLT relocs.
  Reloc_section* tls_desc_rel_;
  // The IRELATIVE relocations, if necessary.  These must follow the
  // regular relocatoins and the TLS_DESC relocations.
  Reloc_section* irelative_rel_;
  // The .got.plt section.
  Output_data_space* got_plt_;
  // The part of the .got.plt section used for IRELATIVE relocs.
  Output_data_space* got_irelative_;
  // The number of PLT entries.
  unsigned int count_;
  // Number of PLT entries with R_386_IRELATIVE relocs.  These follow
  // the regular PLT entries.
  unsigned int irelative_count_;
  // Global STT_GNU_IFUNC symbols.
  std::vector<Global_ifunc> global_ifuncs_;
  // Local STT_GNU_IFUNC symbols.
  std::vector<Local_ifunc> local_ifuncs_;
};

// This is an abstract class for the standard PLT layout.
// The derived classes below handle the actual PLT contents
// for the executable (non-PIC) and shared-library (PIC) cases.
// The unwind information is uniform across those two, so it's here.

class Output_data_plt_i386_standard : public Output_data_plt_i386
{
 public:
  Output_data_plt_i386_standard(Layout* layout,
				Output_data_space* got_plt,
				Output_data_space* got_irelative)
    : Output_data_plt_i386(layout, plt_entry_size, got_plt, got_irelative)
  { }

 protected:
  virtual unsigned int
  do_get_plt_entry_size() const
  { return plt_entry_size; }

  virtual void
  do_add_eh_frame(Layout* layout)
  {
    layout->add_eh_frame_for_plt(this, plt_eh_frame_cie, plt_eh_frame_cie_size,
				 plt_eh_frame_fde, plt_eh_frame_fde_size);
  }

  // The size of an entry in the PLT.
  static const int plt_entry_size = 16;

  // The .eh_frame unwind information for the PLT.
  static const int plt_eh_frame_fde_size = 32;
  static const unsigned char plt_eh_frame_fde[plt_eh_frame_fde_size];
};

// Actually fill the PLT contents for an executable (non-PIC).

class Output_data_plt_i386_exec : public Output_data_plt_i386_standard
{
public:
  Output_data_plt_i386_exec(Layout* layout,
			    Output_data_space* got_plt,
			    Output_data_space* got_irelative)
    : Output_data_plt_i386_standard(layout, got_plt, got_irelative)
  { }

 protected:
  virtual void
  do_fill_first_plt_entry(unsigned char* pov,
			  elfcpp::Elf_types<32>::Elf_Addr got_address);

  virtual unsigned int
  do_fill_plt_entry(unsigned char* pov,
		    elfcpp::Elf_types<32>::Elf_Addr got_address,
		    unsigned int got_offset,
		    unsigned int plt_offset,
		    unsigned int plt_rel_offset);

 private:
  // The first entry in the PLT for an executable.
  static const unsigned char first_plt_entry[plt_entry_size];

  // Other entries in the PLT for an executable.
  static const unsigned char plt_entry[plt_entry_size];
};

// Actually fill the PLT contents for a shared library (PIC).

class Output_data_plt_i386_dyn : public Output_data_plt_i386_standard
{
 public:
  Output_data_plt_i386_dyn(Layout* layout,
			   Output_data_space* got_plt,
			   Output_data_space* got_irelative)
    : Output_data_plt_i386_standard(layout, got_plt, got_irelative)
  { }

 protected:
  virtual void
  do_fill_first_plt_entry(unsigned char* pov, elfcpp::Elf_types<32>::Elf_Addr);

  virtual unsigned int
  do_fill_plt_entry(unsigned char* pov,
		    elfcpp::Elf_types<32>::Elf_Addr,
		    unsigned int got_offset,
		    unsigned int plt_offset,
		    unsigned int plt_rel_offset);

 private:
  // The first entry in the PLT for a shared object.
  static const unsigned char first_plt_entry[plt_entry_size];

  // Other entries in the PLT for a shared object.
  static const unsigned char plt_entry[plt_entry_size];
};

// The i386 target class.
// TLS info comes from
//   http://people.redhat.com/drepper/tls.pdf
//   http://www.lsd.ic.unicamp.br/~oliva/writeups/TLS/RFC-TLSDESC-x86.txt

class Target_i386 : public Sized_target<32, false>
{
 public:
  typedef Output_data_reloc<elfcpp::SHT_REL, true, 32, false> Reloc_section;

  Target_i386(const Target::Target_info* info = &i386_info)
    : Sized_target<32, false>(info),
      got_(NULL), plt_(NULL), got_plt_(NULL), got_irelative_(NULL),
      got_tlsdesc_(NULL), global_offset_table_(NULL), rel_dyn_(NULL),
      rel_irelative_(NULL), copy_relocs_(elfcpp::R_386_COPY),
      got_mod_index_offset_(-1U), tls_base_symbol_defined_(false)
  { }

  // Process the relocations to determine unreferenced sections for
  // garbage collection.
  void
  gc_process_relocs(Symbol_table* symtab,
		    Layout* layout,
		    Sized_relobj_file<32, false>* object,
		    unsigned int data_shndx,
		    unsigned int sh_type,
		    const unsigned char* prelocs,
		    size_t reloc_count,
		    Output_section* output_section,
		    bool needs_special_offset_handling,
		    size_t local_symbol_count,
		    const unsigned char* plocal_symbols);

  // Scan the relocations to look for symbol adjustments.
  void
  scan_relocs(Symbol_table* symtab,
	      Layout* layout,
	      Sized_relobj_file<32, false>* object,
	      unsigned int data_shndx,
	      unsigned int sh_type,
	      const unsigned char* prelocs,
	      size_t reloc_count,
	      Output_section* output_section,
	      bool needs_special_offset_handling,
	      size_t local_symbol_count,
	      const unsigned char* plocal_symbols);

  // Finalize the sections.
  void
  do_finalize_sections(Layout*, const Input_objects*, Symbol_table*);

  // Return the value to use for a dynamic which requires special
  // treatment.
  uint64_t
  do_dynsym_value(const Symbol*) const;

  // Relocate a section.
  void
  relocate_section(const Relocate_info<32, false>*,
		   unsigned int sh_type,
		   const unsigned char* prelocs,
		   size_t reloc_count,
		   Output_section* output_section,
		   bool needs_special_offset_handling,
		   unsigned char* view,
		   elfcpp::Elf_types<32>::Elf_Addr view_address,
		   section_size_type view_size,
		   const Reloc_symbol_changes*);

  // Scan the relocs during a relocatable link.
  void
  scan_relocatable_relocs(Symbol_table* symtab,
			  Layout* layout,
			  Sized_relobj_file<32, false>* object,
			  unsigned int data_shndx,
			  unsigned int sh_type,
			  const unsigned char* prelocs,
			  size_t reloc_count,
			  Output_section* output_section,
			  bool needs_special_offset_handling,
			  size_t local_symbol_count,
			  const unsigned char* plocal_symbols,
			  Relocatable_relocs*);

  // Emit relocations for a section.
  void
  relocate_relocs(const Relocate_info<32, false>*,
		  unsigned int sh_type,
		  const unsigned char* prelocs,
		  size_t reloc_count,
		  Output_section* output_section,
		  elfcpp::Elf_types<32>::Elf_Off offset_in_output_section,
		  const Relocatable_relocs*,
		  unsigned char* view,
		  elfcpp::Elf_types<32>::Elf_Addr view_address,
		  section_size_type view_size,
		  unsigned char* reloc_view,
		  section_size_type reloc_view_size);

  // Return a string used to fill a code section with nops.
  std::string
  do_code_fill(section_size_type length) const;

  // Return whether SYM is defined by the ABI.
  bool
  do_is_defined_by_abi(const Symbol* sym) const
  { return strcmp(sym->name(), "___tls_get_addr") == 0; }

  // Return whether a symbol name implies a local label.  The UnixWare
  // 2.1 cc generates temporary symbols that start with .X, so we
  // recognize them here.  FIXME: do other SVR4 compilers also use .X?.
  // If so, we should move the .X recognition into
  // Target::do_is_local_label_name.
  bool
  do_is_local_label_name(const char* name) const
  {
    if (name[0] == '.' && name[1] == 'X')
      return true;
    return Target::do_is_local_label_name(name);
  }

  // Return the PLT address to use for a global symbol.
  uint64_t
  do_plt_address_for_global(const Symbol* gsym) const
  { return this->plt_section()->address_for_global(gsym); }

  uint64_t
  do_plt_address_for_local(const Relobj* relobj, unsigned int symndx) const
  { return this->plt_section()->address_for_local(relobj, symndx); }

  // We can tell whether we take the address of a function.
  inline bool
  do_can_check_for_function_pointers() const
  { return true; }

  // Return the base for a DW_EH_PE_datarel encoding.
  uint64_t
  do_ehframe_datarel_base() const;

  // Return whether SYM is call to a non-split function.
  bool
  do_is_call_to_non_split(const Symbol* sym, unsigned int) const;

  // Adjust -fsplit-stack code which calls non-split-stack code.
  void
  do_calls_non_split(Relobj* object, unsigned int shndx,
		     section_offset_type fnoffset, section_size_type fnsize,
		     unsigned char* view, section_size_type view_size,
		     std::string* from, std::string* to) const;

  // Return the size of the GOT section.
  section_size_type
  got_size() const
  {
    gold_assert(this->got_ != NULL);
    return this->got_->data_size();
  }

  // Return the number of entries in the GOT.
  unsigned int
  got_entry_count() const
  {
    if (this->got_ == NULL)
      return 0;
    return this->got_size() / 4;
  }

  // Return the number of entries in the PLT.
  unsigned int
  plt_entry_count() const;

  // Return the offset of the first non-reserved PLT entry.
  unsigned int
  first_plt_entry_offset() const;

  // Return the size of each PLT entry.
  unsigned int
  plt_entry_size() const;

 protected:
  // Instantiate the plt_ member.
  // This chooses the right PLT flavor for an executable or a shared object.
  Output_data_plt_i386*
  make_data_plt(Layout* layout,
		Output_data_space* got_plt,
		Output_data_space* got_irelative,
		bool dyn)
  { return this->do_make_data_plt(layout, got_plt, got_irelative, dyn); }

  virtual Output_data_plt_i386*
  do_make_data_plt(Layout* layout,
		   Output_data_space* got_plt,
		   Output_data_space* got_irelative,
		   bool dyn)
  {
    if (dyn)
      return new Output_data_plt_i386_dyn(layout, got_plt, got_irelative);
    else
      return new Output_data_plt_i386_exec(layout, got_plt, got_irelative);
  }

 private:
  // The class which scans relocations.
  struct Scan
  {
    static inline int

    get_reference_flags(unsigned int r_type);

    inline void
    local(Symbol_table* symtab, Layout* layout, Target_i386* target,
	  Sized_relobj_file<32, false>* object,
	  unsigned int data_shndx,
	  Output_section* output_section,
	  const elfcpp::Rel<32, false>& reloc, unsigned int r_type,
	  const elfcpp::Sym<32, false>& lsym,
	  bool is_discarded);

    inline void
    global(Symbol_table* symtab, Layout* layout, Target_i386* target,
	   Sized_relobj_file<32, false>* object,
	   unsigned int data_shndx,
	   Output_section* output_section,
	   const elfcpp::Rel<32, false>& reloc, unsigned int r_type,
	   Symbol* gsym);

    inline bool
    local_reloc_may_be_function_pointer(Symbol_table* symtab, Layout* layout,
					Target_i386* target,
					Sized_relobj_file<32, false>* object,
					unsigned int data_shndx,
					Output_section* output_section,
					const elfcpp::Rel<32, false>& reloc,
					unsigned int r_type,
					const elfcpp::Sym<32, false>& lsym);

    inline bool
    global_reloc_may_be_function_pointer(Symbol_table* symtab, Layout* layout,
					 Target_i386* target,
					 Sized_relobj_file<32, false>* object,
					 unsigned int data_shndx,
					 Output_section* output_section,
					 const elfcpp::Rel<32, false>& reloc,
					 unsigned int r_type,
					 Symbol* gsym);

    inline bool
    possible_function_pointer_reloc(unsigned int r_type);

    bool
    reloc_needs_plt_for_ifunc(Sized_relobj_file<32, false>*,
			      unsigned int r_type);

    static void
    unsupported_reloc_local(Sized_relobj_file<32, false>*, unsigned int r_type);

    static void
    unsupported_reloc_global(Sized_relobj_file<32, false>*, unsigned int r_type,
			     Symbol*);
  };

  // The class which implements relocation.
  class Relocate
  {
   public:
    Relocate()
      : skip_call_tls_get_addr_(false),
	local_dynamic_type_(LOCAL_DYNAMIC_NONE)
    { }

    ~Relocate()
    {
      if (this->skip_call_tls_get_addr_)
	{
	  // FIXME: This needs to specify the location somehow.
	  gold_error(_("missing expected TLS relocation"));
	}
    }

    // Return whether the static relocation needs to be applied.
    inline bool
    should_apply_static_reloc(const Sized_symbol<32>* gsym,
			      unsigned int r_type,
			      bool is_32bit,
			      Output_section* output_section);

    // Do a relocation.  Return false if the caller should not issue
    // any warnings about this relocation.
    inline bool
    relocate(const Relocate_info<32, false>*, Target_i386*, Output_section*,
	     size_t relnum, const elfcpp::Rel<32, false>&,
	     unsigned int r_type, const Sized_symbol<32>*,
	     const Symbol_value<32>*,
	     unsigned char*, elfcpp::Elf_types<32>::Elf_Addr,
	     section_size_type);

   private:
    // Do a TLS relocation.
    inline void
    relocate_tls(const Relocate_info<32, false>*, Target_i386* target,
		 size_t relnum, const elfcpp::Rel<32, false>&,
		 unsigned int r_type, const Sized_symbol<32>*,
		 const Symbol_value<32>*,
		 unsigned char*, elfcpp::Elf_types<32>::Elf_Addr,
		 section_size_type);

    // Do a TLS General-Dynamic to Initial-Exec transition.
    inline void
    tls_gd_to_ie(const Relocate_info<32, false>*, size_t relnum,
		 Output_segment* tls_segment,
		 const elfcpp::Rel<32, false>&, unsigned int r_type,
		 elfcpp::Elf_types<32>::Elf_Addr value,
		 unsigned char* view,
		 section_size_type view_size);

    // Do a TLS General-Dynamic to Local-Exec transition.
    inline void
    tls_gd_to_le(const Relocate_info<32, false>*, size_t relnum,
		 Output_segment* tls_segment,
		 const elfcpp::Rel<32, false>&, unsigned int r_type,
		 elfcpp::Elf_types<32>::Elf_Addr value,
		 unsigned char* view,
		 section_size_type view_size);

    // Do a TLS_GOTDESC or TLS_DESC_CALL General-Dynamic to Initial-Exec
    // transition.
    inline void
    tls_desc_gd_to_ie(const Relocate_info<32, false>*, size_t relnum,
		      Output_segment* tls_segment,
		      const elfcpp::Rel<32, false>&, unsigned int r_type,
		      elfcpp::Elf_types<32>::Elf_Addr value,
		      unsigned char* view,
		      section_size_type view_size);

    // Do a TLS_GOTDESC or TLS_DESC_CALL General-Dynamic to Local-Exec
    // transition.
    inline void
    tls_desc_gd_to_le(const Relocate_info<32, false>*, size_t relnum,
		      Output_segment* tls_segment,
		      const elfcpp::Rel<32, false>&, unsigned int r_type,
		      elfcpp::Elf_types<32>::Elf_Addr value,
		      unsigned char* view,
		      section_size_type view_size);

    // Do a TLS Local-Dynamic to Local-Exec transition.
    inline void
    tls_ld_to_le(const Relocate_info<32, false>*, size_t relnum,
		 Output_segment* tls_segment,
		 const elfcpp::Rel<32, false>&, unsigned int r_type,
		 elfcpp::Elf_types<32>::Elf_Addr value,
		 unsigned char* view,
		 section_size_type view_size);

    // Do a TLS Initial-Exec to Local-Exec transition.
    static inline void
    tls_ie_to_le(const Relocate_info<32, false>*, size_t relnum,
		 Output_segment* tls_segment,
		 const elfcpp::Rel<32, false>&, unsigned int r_type,
		 elfcpp::Elf_types<32>::Elf_Addr value,
		 unsigned char* view,
		 section_size_type view_size);

    // We need to keep track of which type of local dynamic relocation
    // we have seen, so that we can optimize R_386_TLS_LDO_32 correctly.
    enum Local_dynamic_type
    {
      LOCAL_DYNAMIC_NONE,
      LOCAL_DYNAMIC_SUN,
      LOCAL_DYNAMIC_GNU
    };

    // This is set if we should skip the next reloc, which should be a
    // PLT32 reloc against ___tls_get_addr.
    bool skip_call_tls_get_addr_;
    // The type of local dynamic relocation we have seen in the section
    // being relocated, if any.
    Local_dynamic_type local_dynamic_type_;
  };

  // A class which returns the size required for a relocation type,
  // used while scanning relocs during a relocatable link.
  class Relocatable_size_for_reloc
  {
   public:
    unsigned int
    get_size_for_reloc(unsigned int, Relobj*);
  };

  // Adjust TLS relocation type based on the options and whether this
  // is a local symbol.
  static tls::Tls_optimization
  optimize_tls_reloc(bool is_final, int r_type);

  // Get the GOT section, creating it if necessary.
  Output_data_got<32, false>*
  got_section(Symbol_table*, Layout*);

  // Get the GOT PLT section.
  Output_data_space*
  got_plt_section() const
  {
    gold_assert(this->got_plt_ != NULL);
    return this->got_plt_;
  }

  // Get the GOT section for TLSDESC entries.
  Output_data_got<32, false>*
  got_tlsdesc_section() const
  {
    gold_assert(this->got_tlsdesc_ != NULL);
    return this->got_tlsdesc_;
  }

  // Create the PLT section.
  void
  make_plt_section(Symbol_table* symtab, Layout* layout);

  // Create a PLT entry for a global symbol.
  void
  make_plt_entry(Symbol_table*, Layout*, Symbol*);

  // Create a PLT entry for a local STT_GNU_IFUNC symbol.
  void
  make_local_ifunc_plt_entry(Symbol_table*, Layout*,
			     Sized_relobj_file<32, false>* relobj,
			     unsigned int local_sym_index);

  // Define the _TLS_MODULE_BASE_ symbol in the TLS segment.
  void
  define_tls_base_symbol(Symbol_table*, Layout*);

  // Create a GOT entry for the TLS module index.
  unsigned int
  got_mod_index_entry(Symbol_table* symtab, Layout* layout,
		      Sized_relobj_file<32, false>* object);

  // Get the PLT section.
  Output_data_plt_i386*
  plt_section() const
  {
    gold_assert(this->plt_ != NULL);
    return this->plt_;
  }

  // Get the dynamic reloc section, creating it if necessary.
  Reloc_section*
  rel_dyn_section(Layout*);

  // Get the section to use for TLS_DESC relocations.
  Reloc_section*
  rel_tls_desc_section(Layout*) const;

  // Get the section to use for IRELATIVE relocations.
  Reloc_section*
  rel_irelative_section(Layout*);

  // Add a potential copy relocation.
  void
  copy_reloc(Symbol_table* symtab, Layout* layout,
	     Sized_relobj_file<32, false>* object,
	     unsigned int shndx, Output_section* output_section,
	     Symbol* sym, const elfcpp::Rel<32, false>& reloc)
  {
    this->copy_relocs_.copy_reloc(symtab, layout,
				  symtab->get_sized_symbol<32>(sym),
				  object, shndx, output_section, reloc,
				  this->rel_dyn_section(layout));
  }

  // Information about this specific target which we pass to the
  // general Target structure.
  static const Target::Target_info i386_info;

  // The types of GOT entries needed for this platform.
  // These values are exposed to the ABI in an incremental link.
  // Do not renumber existing values without changing the version
  // number of the .gnu_incremental_inputs section.
  enum Got_type
  {
    GOT_TYPE_STANDARD = 0,      // GOT entry for a regular symbol
    GOT_TYPE_TLS_NOFFSET = 1,   // GOT entry for negative TLS offset
    GOT_TYPE_TLS_OFFSET = 2,    // GOT entry for positive TLS offset
    GOT_TYPE_TLS_PAIR = 3,      // GOT entry for TLS module/offset pair
    GOT_TYPE_TLS_DESC = 4       // GOT entry for TLS_DESC pair
  };

  // The GOT section.
  Output_data_got<32, false>* got_;
  // The PLT section.
  Output_data_plt_i386* plt_;
  // The GOT PLT section.
  Output_data_space* got_plt_;
  // The GOT section for IRELATIVE relocations.
  Output_data_space* got_irelative_;
  // The GOT section for TLSDESC relocations.
  Output_data_got<32, false>* got_tlsdesc_;
  // The _GLOBAL_OFFSET_TABLE_ symbol.
  Symbol* global_offset_table_;
  // The dynamic reloc section.
  Reloc_section* rel_dyn_;
  // The section to use for IRELATIVE relocs.
  Reloc_section* rel_irelative_;
  // Relocs saved to avoid a COPY reloc.
  Copy_relocs<elfcpp::SHT_REL, 32, false> copy_relocs_;
  // Offset of the GOT entry for the TLS module index.
  unsigned int got_mod_index_offset_;
  // True if the _TLS_MODULE_BASE_ symbol has been defined.
  bool tls_base_symbol_defined_;
};

const Target::Target_info Target_i386::i386_info =
{
  32,			// size
  false,		// is_big_endian
  elfcpp::EM_386,	// machine_code
  false,		// has_make_symbol
  false,		// has_resolve
  true,			// has_code_fill
  true,			// is_default_stack_executable
  true,			// can_icf_inline_merge_sections
  '\0',			// wrap_char
  "/usr/lib/libc.so.1",	// dynamic_linker
  0x08048000,		// default_text_segment_address
  0x1000,		// abi_pagesize (overridable by -z max-page-size)
  0x1000,		// common_pagesize (overridable by -z common-page-size)
  false,                // isolate_execinstr
  0,                    // rosegment_gap
  elfcpp::SHN_UNDEF,	// small_common_shndx
  elfcpp::SHN_UNDEF,	// large_common_shndx
  0,			// small_common_section_flags
  0,			// large_common_section_flags
  NULL,			// attributes_section
  NULL,			// attributes_vendor
  "_start"		// entry_symbol_name
};

// Get the GOT section, creating it if necessary.

Output_data_got<32, false>*
Target_i386::got_section(Symbol_table* symtab, Layout* layout)
{
  if (this->got_ == NULL)
    {
      gold_assert(symtab != NULL && layout != NULL);

      this->got_ = new Output_data_got<32, false>();

      // When using -z now, we can treat .got.plt as a relro section.
      // Without -z now, it is modified after program startup by lazy
      // PLT relocations.
      bool is_got_plt_relro = parameters->options().now();
      Output_section_order got_order = (is_got_plt_relro
					? ORDER_RELRO
					: ORDER_RELRO_LAST);
      Output_section_order got_plt_order = (is_got_plt_relro
					    ? ORDER_RELRO
					    : ORDER_NON_RELRO_FIRST);

      layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_WRITE),
				      this->got_, got_order, true);

      this->got_plt_ = new Output_data_space(4, "** GOT PLT");
      layout->add_output_section_data(".got.plt", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_WRITE),
				      this->got_plt_, got_plt_order,
				      is_got_plt_relro);

      // The first three entries are reserved.
      this->got_plt_->set_current_data_size(3 * 4);

      if (!is_got_plt_relro)
	{
	  // Those bytes can go into the relro segment.
	  layout->increase_relro(3 * 4);
	}

      // Define _GLOBAL_OFFSET_TABLE_ at the start of the PLT.
      this->global_offset_table_ =
	symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
				      Symbol_table::PREDEFINED,
				      this->got_plt_,
				      0, 0, elfcpp::STT_OBJECT,
				      elfcpp::STB_LOCAL,
				      elfcpp::STV_HIDDEN, 0,
				      false, false);

      // If there are any IRELATIVE relocations, they get GOT entries
      // in .got.plt after the jump slot relocations.
      this->got_irelative_ = new Output_data_space(4, "** GOT IRELATIVE PLT");
      layout->add_output_section_data(".got.plt", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_WRITE),
				      this->got_irelative_,
				      got_plt_order, is_got_plt_relro);

      // If there are any TLSDESC relocations, they get GOT entries in
      // .got.plt after the jump slot entries.
      this->got_tlsdesc_ = new Output_data_got<32, false>();
      layout->add_output_section_data(".got.plt", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_WRITE),
				      this->got_tlsdesc_,
				      got_plt_order, is_got_plt_relro);
    }

  return this->got_;
}

// Get the dynamic reloc section, creating it if necessary.

Target_i386::Reloc_section*
Target_i386::rel_dyn_section(Layout* layout)
{
  if (this->rel_dyn_ == NULL)
    {
      gold_assert(layout != NULL);
      this->rel_dyn_ = new Reloc_section(parameters->options().combreloc());
      layout->add_output_section_data(".rel.dyn", elfcpp::SHT_REL,
				      elfcpp::SHF_ALLOC, this->rel_dyn_,
				      ORDER_DYNAMIC_RELOCS, false);
    }
  return this->rel_dyn_;
}

// Get the section to use for IRELATIVE relocs, creating it if
// necessary.  These go in .rel.dyn, but only after all other dynamic
// relocations.  They need to follow the other dynamic relocations so
// that they can refer to global variables initialized by those
// relocs.

Target_i386::Reloc_section*
Target_i386::rel_irelative_section(Layout* layout)
{
  if (this->rel_irelative_ == NULL)
    {
      // Make sure we have already create the dynamic reloc section.
      this->rel_dyn_section(layout);
      this->rel_irelative_ = new Reloc_section(false);
      layout->add_output_section_data(".rel.dyn", elfcpp::SHT_REL,
				      elfcpp::SHF_ALLOC, this->rel_irelative_,
				      ORDER_DYNAMIC_RELOCS, false);
      gold_assert(this->rel_dyn_->output_section()
		  == this->rel_irelative_->output_section());
    }
  return this->rel_irelative_;
}

// Create the PLT section.  The ordinary .got section is an argument,
// since we need to refer to the start.  We also create our own .got
// section just for PLT entries.

Output_data_plt_i386::Output_data_plt_i386(Layout* layout,
					   uint64_t addralign,
					   Output_data_space* got_plt,
					   Output_data_space* got_irelative)
  : Output_section_data(addralign),
    layout_(layout), tls_desc_rel_(NULL),
    irelative_rel_(NULL), got_plt_(got_plt), got_irelative_(got_irelative),
    count_(0), irelative_count_(0), global_ifuncs_(), local_ifuncs_()
{
  this->rel_ = new Reloc_section(false);
  layout->add_output_section_data(".rel.plt", elfcpp::SHT_REL,
				  elfcpp::SHF_ALLOC, this->rel_,
				  ORDER_DYNAMIC_PLT_RELOCS, false);
}

void
Output_data_plt_i386::do_adjust_output_section(Output_section* os)
{
  // UnixWare sets the entsize of .plt to 4, and so does the old GNU
  // linker, and so do we.
  os->set_entsize(4);
}

// Add an entry to the PLT.

void
Output_data_plt_i386::add_entry(Symbol_table* symtab, Layout* layout,
				Symbol* gsym)
{
  gold_assert(!gsym->has_plt_offset());

  // Every PLT entry needs a reloc.
  if (gsym->type() == elfcpp::STT_GNU_IFUNC
      && gsym->can_use_relative_reloc(false))
    {
      gsym->set_plt_offset(this->irelative_count_ * this->get_plt_entry_size());
      ++this->irelative_count_;
      section_offset_type got_offset =
	this->got_irelative_->current_data_size();
      this->got_irelative_->set_current_data_size(got_offset + 4);
      Reloc_section* rel = this->rel_irelative(symtab, layout);
      rel->add_symbolless_global_addend(gsym, elfcpp::R_386_IRELATIVE,
					this->got_irelative_, got_offset);
      struct Global_ifunc gi;
      gi.sym = gsym;
      gi.got_offset = got_offset;
      this->global_ifuncs_.push_back(gi);
    }
  else
    {
      // When setting the PLT offset we skip the initial reserved PLT
      // entry.
      gsym->set_plt_offset((this->count_ + 1) * this->get_plt_entry_size());

      ++this->count_;

      section_offset_type got_offset = this->got_plt_->current_data_size();

      // Every PLT entry needs a GOT entry which points back to the
      // PLT entry (this will be changed by the dynamic linker,
      // normally lazily when the function is called).
      this->got_plt_->set_current_data_size(got_offset + 4);

      gsym->set_needs_dynsym_entry();
      this->rel_->add_global(gsym, elfcpp::R_386_JUMP_SLOT, this->got_plt_,
			     got_offset);
    }

  // Note that we don't need to save the symbol.  The contents of the
  // PLT are independent of which symbols are used.  The symbols only
  // appear in the relocations.
}

// Add an entry to the PLT for a local STT_GNU_IFUNC symbol.  Return
// the PLT offset.

unsigned int
Output_data_plt_i386::add_local_ifunc_entry(
    Symbol_table* symtab,
    Layout* layout,
    Sized_relobj_file<32, false>* relobj,
    unsigned int local_sym_index)
{
  unsigned int plt_offset = this->irelative_count_ * this->get_plt_entry_size();
  ++this->irelative_count_;

  section_offset_type got_offset = this->got_irelative_->current_data_size();

  // Every PLT entry needs a GOT entry which points back to the PLT
  // entry.
  this->got_irelative_->set_current_data_size(got_offset + 4);

  // Every PLT entry needs a reloc.
  Reloc_section* rel = this->rel_irelative(symtab, layout);
  rel->add_symbolless_local_addend(relobj, local_sym_index,
				   elfcpp::R_386_IRELATIVE,
				   this->got_irelative_, got_offset);

  struct Local_ifunc li;
  li.object = relobj;
  li.local_sym_index = local_sym_index;
  li.got_offset = got_offset;
  this->local_ifuncs_.push_back(li);

  return plt_offset;
}

// Return where the TLS_DESC relocations should go, creating it if
// necessary. These follow the JUMP_SLOT relocations.

Output_data_plt_i386::Reloc_section*
Output_data_plt_i386::rel_tls_desc(Layout* layout)
{
  if (this->tls_desc_rel_ == NULL)
    {
      this->tls_desc_rel_ = new Reloc_section(false);
      layout->add_output_section_data(".rel.plt", elfcpp::SHT_REL,
				      elfcpp::SHF_ALLOC, this->tls_desc_rel_,
				      ORDER_DYNAMIC_PLT_RELOCS, false);
      gold_assert(this->tls_desc_rel_->output_section()
		  == this->rel_->output_section());
    }
  return this->tls_desc_rel_;
}

// Return where the IRELATIVE relocations should go in the PLT.  These
// follow the JUMP_SLOT and TLS_DESC relocations.

Output_data_plt_i386::Reloc_section*
Output_data_plt_i386::rel_irelative(Symbol_table* symtab, Layout* layout)
{
  if (this->irelative_rel_ == NULL)
    {
      // Make sure we have a place for the TLS_DESC relocations, in
      // case we see any later on.
      this->rel_tls_desc(layout);
      this->irelative_rel_ = new Reloc_section(false);
      layout->add_output_section_data(".rel.plt", elfcpp::SHT_REL,
				      elfcpp::SHF_ALLOC, this->irelative_rel_,
				      ORDER_DYNAMIC_PLT_RELOCS, false);
      gold_assert(this->irelative_rel_->output_section()
		  == this->rel_->output_section());

      if (parameters->doing_static_link())
	{
	  // A statically linked executable will only have a .rel.plt
	  // section to hold R_386_IRELATIVE relocs for STT_GNU_IFUNC
	  // symbols.  The library will use these symbols to locate
	  // the IRELATIVE relocs at program startup time.
	  symtab->define_in_output_data("__rel_iplt_start", NULL,
					Symbol_table::PREDEFINED,
					this->irelative_rel_, 0, 0,
					elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
					elfcpp::STV_HIDDEN, 0, false, true);
	  symtab->define_in_output_data("__rel_iplt_end", NULL,
					Symbol_table::PREDEFINED,
					this->irelative_rel_, 0, 0,
					elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
					elfcpp::STV_HIDDEN, 0, true, true);
	}
    }
  return this->irelative_rel_;
}

// Return the PLT address to use for a global symbol.

uint64_t
Output_data_plt_i386::address_for_global(const Symbol* gsym)
{
  uint64_t offset = 0;
  if (gsym->type() == elfcpp::STT_GNU_IFUNC
      && gsym->can_use_relative_reloc(false))
    offset = (this->count_ + 1) * this->get_plt_entry_size();
  return this->address() + offset + gsym->plt_offset();
}

// Return the PLT address to use for a local symbol.  These are always
// IRELATIVE relocs.

uint64_t
Output_data_plt_i386::address_for_local(const Relobj* object,
					unsigned int r_sym)
{
  return (this->address()
	  + (this->count_ + 1) * this->get_plt_entry_size()
	  + object->local_plt_offset(r_sym));
}

// The first entry in the PLT for an executable.

const unsigned char Output_data_plt_i386_exec::first_plt_entry[plt_entry_size] =
{
  0xff, 0x35,	// pushl contents of memory address
  0, 0, 0, 0,	// replaced with address of .got + 4
  0xff, 0x25,	// jmp indirect
  0, 0, 0, 0,	// replaced with address of .got + 8
  0, 0, 0, 0	// unused
};

void
Output_data_plt_i386_exec::do_fill_first_plt_entry(
    unsigned char* pov,
    elfcpp::Elf_types<32>::Elf_Addr got_address)
{
  memcpy(pov, first_plt_entry, plt_entry_size);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2, got_address + 4);
  elfcpp::Swap<32, false>::writeval(pov + 8, got_address + 8);
}

// The first entry in the PLT for a shared object.

const unsigned char Output_data_plt_i386_dyn::first_plt_entry[plt_entry_size] =
{
  0xff, 0xb3, 4, 0, 0, 0,	// pushl 4(%ebx)
  0xff, 0xa3, 8, 0, 0, 0,	// jmp *8(%ebx)
  0, 0, 0, 0			// unused
};

void
Output_data_plt_i386_dyn::do_fill_first_plt_entry(
    unsigned char* pov,
    elfcpp::Elf_types<32>::Elf_Addr)
{
  memcpy(pov, first_plt_entry, plt_entry_size);
}

// Subsequent entries in the PLT for an executable.

const unsigned char Output_data_plt_i386_exec::plt_entry[plt_entry_size] =
{
  0xff, 0x25,	// jmp indirect
  0, 0, 0, 0,	// replaced with address of symbol in .got
  0x68,		// pushl immediate
  0, 0, 0, 0,	// replaced with offset into relocation table
  0xe9,		// jmp relative
  0, 0, 0, 0	// replaced with offset to start of .plt
};

unsigned int
Output_data_plt_i386_exec::do_fill_plt_entry(
    unsigned char* pov,
    elfcpp::Elf_types<32>::Elf_Addr got_address,
    unsigned int got_offset,
    unsigned int plt_offset,
    unsigned int plt_rel_offset)
{
  memcpy(pov, plt_entry, plt_entry_size);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2,
					      got_address + got_offset);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 7, plt_rel_offset);
  elfcpp::Swap<32, false>::writeval(pov + 12, - (plt_offset + 12 + 4));
  return 6;
}

// Subsequent entries in the PLT for a shared object.

const unsigned char Output_data_plt_i386_dyn::plt_entry[plt_entry_size] =
{
  0xff, 0xa3,	// jmp *offset(%ebx)
  0, 0, 0, 0,	// replaced with offset of symbol in .got
  0x68,		// pushl immediate
  0, 0, 0, 0,	// replaced with offset into relocation table
  0xe9,		// jmp relative
  0, 0, 0, 0	// replaced with offset to start of .plt
};

unsigned int
Output_data_plt_i386_dyn::do_fill_plt_entry(unsigned char* pov,
					    elfcpp::Elf_types<32>::Elf_Addr,
					    unsigned int got_offset,
					    unsigned int plt_offset,
					    unsigned int plt_rel_offset)
{
  memcpy(pov, plt_entry, plt_entry_size);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2, got_offset);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 7, plt_rel_offset);
  elfcpp::Swap<32, false>::writeval(pov + 12, - (plt_offset + 12 + 4));
  return 6;
}

// The .eh_frame unwind information for the PLT.

const unsigned char
Output_data_plt_i386::plt_eh_frame_cie[plt_eh_frame_cie_size] =
{
  1,				// CIE version.
  'z',				// Augmentation: augmentation size included.
  'R',				// Augmentation: FDE encoding included.
  '\0',				// End of augmentation string.
  1,				// Code alignment factor.
  0x7c,				// Data alignment factor.
  8,				// Return address column.
  1,				// Augmentation size.
  (elfcpp::DW_EH_PE_pcrel	// FDE encoding.
   | elfcpp::DW_EH_PE_sdata4),
  elfcpp::DW_CFA_def_cfa, 4, 4,	// DW_CFA_def_cfa: r4 (esp) ofs 4.
  elfcpp::DW_CFA_offset + 8, 1,	// DW_CFA_offset: r8 (eip) at cfa-4.
  elfcpp::DW_CFA_nop,		// Align to 16 bytes.
  elfcpp::DW_CFA_nop
};

const unsigned char
Output_data_plt_i386_standard::plt_eh_frame_fde[plt_eh_frame_fde_size] =
{
  0, 0, 0, 0,				// Replaced with offset to .plt.
  0, 0, 0, 0,				// Replaced with size of .plt.
  0,					// Augmentation size.
  elfcpp::DW_CFA_def_cfa_offset, 8,	// DW_CFA_def_cfa_offset: 8.
  elfcpp::DW_CFA_advance_loc + 6,	// Advance 6 to __PLT__ + 6.
  elfcpp::DW_CFA_def_cfa_offset, 12,	// DW_CFA_def_cfa_offset: 12.
  elfcpp::DW_CFA_advance_loc + 10,	// Advance 10 to __PLT__ + 16.
  elfcpp::DW_CFA_def_cfa_expression,	// DW_CFA_def_cfa_expression.
  11,					// Block length.
  elfcpp::DW_OP_breg4, 4,		// Push %esp + 4.
  elfcpp::DW_OP_breg8, 0,		// Push %eip.
  elfcpp::DW_OP_lit15,			// Push 0xf.
  elfcpp::DW_OP_and,			// & (%eip & 0xf).
  elfcpp::DW_OP_lit11,			// Push 0xb.
  elfcpp::DW_OP_ge,			// >= ((%eip & 0xf) >= 0xb)
  elfcpp::DW_OP_lit2,			// Push 2.
  elfcpp::DW_OP_shl,			// << (((%eip & 0xf) >= 0xb) << 2)
  elfcpp::DW_OP_plus,			// + ((((%eip&0xf)>=0xb)<<2)+%esp+4
  elfcpp::DW_CFA_nop,			// Align to 32 bytes.
  elfcpp::DW_CFA_nop,
  elfcpp::DW_CFA_nop,
  elfcpp::DW_CFA_nop
};

// Write out the PLT.  This uses the hand-coded instructions above,
// and adjusts them as needed.  This is all specified by the i386 ELF
// Processor Supplement.

void
Output_data_plt_i386::do_write(Output_file* of)
{
  const off_t offset = this->offset();
  const section_size_type oview_size =
    convert_to_section_size_type(this->data_size());
  unsigned char* const oview = of->get_output_view(offset, oview_size);

  const off_t got_file_offset = this->got_plt_->offset();
  gold_assert(parameters->incremental_update()
	      || (got_file_offset + this->got_plt_->data_size()
		  == this->got_irelative_->offset()));
  const section_size_type got_size =
    convert_to_section_size_type(this->got_plt_->data_size()
				 + this->got_irelative_->data_size());
  unsigned char* const got_view = of->get_output_view(got_file_offset,
						      got_size);

  unsigned char* pov = oview;

  elfcpp::Elf_types<32>::Elf_Addr plt_address = this->address();
  elfcpp::Elf_types<32>::Elf_Addr got_address = this->got_plt_->address();

  this->fill_first_plt_entry(pov, got_address);
  pov += this->get_plt_entry_size();

  unsigned char* got_pov = got_view;

  // The first entry in the GOT is the address of the .dynamic section
  // aka the PT_DYNAMIC segment.  The next two entries are reserved.
  // We saved space for them when we created the section in
  // Target_i386::got_section.
  Output_section* dynamic = this->layout_->dynamic_section();
  uint32_t dynamic_addr = dynamic == NULL ? 0 : dynamic->address();
  elfcpp::Swap<32, false>::writeval(got_pov, dynamic_addr);
  got_pov += 4;
  memset(got_pov, 0, 8);
  got_pov += 8;

  const int rel_size = elfcpp::Elf_sizes<32>::rel_size;

  unsigned int plt_offset = this->get_plt_entry_size();
  unsigned int plt_rel_offset = 0;
  unsigned int got_offset = 12;
  const unsigned int count = this->count_ + this->irelative_count_;
  for (unsigned int i = 0;
       i < count;
       ++i,
	 pov += this->get_plt_entry_size(),
	 got_pov += 4,
	 plt_offset += this->get_plt_entry_size(),
	 plt_rel_offset += rel_size,
	 got_offset += 4)
    {
      // Set and adjust the PLT entry itself.
      unsigned int lazy_offset = this->fill_plt_entry(pov,
						      got_address,
						      got_offset,
						      plt_offset,
						      plt_rel_offset);

      // Set the entry in the GOT.
      elfcpp::Swap<32, false>::writeval(got_pov,
					plt_address + plt_offset + lazy_offset);
    }

  // If any STT_GNU_IFUNC symbols have PLT entries, we need to change
  // the GOT to point to the actual symbol value, rather than point to
  // the PLT entry.  That will let the dynamic linker call the right
  // function when resolving IRELATIVE relocations.
  unsigned char* got_irelative_view = got_view + this->got_plt_->data_size();
  for (std::vector<Global_ifunc>::const_iterator p =
	 this->global_ifuncs_.begin();
       p != this->global_ifuncs_.end();
       ++p)
    {
      const Sized_symbol<32>* ssym =
	static_cast<const Sized_symbol<32>*>(p->sym);
      elfcpp::Swap<32, false>::writeval(got_irelative_view + p->got_offset,
					ssym->value());
    }

  for (std::vector<Local_ifunc>::const_iterator p =
	 this->local_ifuncs_.begin();
       p != this->local_ifuncs_.end();
       ++p)
    {
      const Symbol_value<32>* psymval =
	p->object->local_symbol(p->local_sym_index);
      elfcpp::Swap<32, false>::writeval(got_irelative_view + p->got_offset,
					psymval->value(p->object, 0));
    }

  gold_assert(static_cast<section_size_type>(pov - oview) == oview_size);
  gold_assert(static_cast<section_size_type>(got_pov - got_view) == got_size);

  of->write_output_view(offset, oview_size, oview);
  of->write_output_view(got_file_offset, got_size, got_view);
}

// Create the PLT section.

void
Target_i386::make_plt_section(Symbol_table* symtab, Layout* layout)
{
  if (this->plt_ == NULL)
    {
      // Create the GOT sections first.
      this->got_section(symtab, layout);

      const bool dyn = parameters->options().output_is_position_independent();
      this->plt_ = this->make_data_plt(layout,
				       this->got_plt_,
				       this->got_irelative_,
				       dyn);

      // Add unwind information if requested.
      if (parameters->options().ld_generated_unwind_info())
	this->plt_->add_eh_frame(layout);

      layout->add_output_section_data(".plt", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_EXECINSTR),
				      this->plt_, ORDER_PLT, false);

      // Make the sh_info field of .rel.plt point to .plt.
      Output_section* rel_plt_os = this->plt_->rel_plt()->output_section();
      rel_plt_os->set_info_section(this->plt_->output_section());
    }
}

// Create a PLT entry for a global symbol.

void
Target_i386::make_plt_entry(Symbol_table* symtab, Layout* layout, Symbol* gsym)
{
  if (gsym->has_plt_offset())
    return;
  if (this->plt_ == NULL)
    this->make_plt_section(symtab, layout);
  this->plt_->add_entry(symtab, layout, gsym);
}

// Make a PLT entry for a local STT_GNU_IFUNC symbol.

void
Target_i386::make_local_ifunc_plt_entry(Symbol_table* symtab, Layout* layout,
					Sized_relobj_file<32, false>* relobj,
					unsigned int local_sym_index)
{
  if (relobj->local_has_plt_offset(local_sym_index))
    return;
  if (this->plt_ == NULL)
    this->make_plt_section(symtab, layout);
  unsigned int plt_offset = this->plt_->add_local_ifunc_entry(symtab, layout,
							      relobj,
							      local_sym_index);
  relobj->set_local_plt_offset(local_sym_index, plt_offset);
}

// Return the number of entries in the PLT.

unsigned int
Target_i386::plt_entry_count() const
{
  if (this->plt_ == NULL)
    return 0;
  return this->plt_->entry_count();
}

// Return the offset of the first non-reserved PLT entry.

unsigned int
Target_i386::first_plt_entry_offset() const
{
  return this->plt_->first_plt_entry_offset();
}

// Return the size of each PLT entry.

unsigned int
Target_i386::plt_entry_size() const
{
  return this->plt_->get_plt_entry_size();
}

// Get the section to use for TLS_DESC relocations.

Target_i386::Reloc_section*
Target_i386::rel_tls_desc_section(Layout* layout) const
{
  return this->plt_section()->rel_tls_desc(layout);
}

// Define the _TLS_MODULE_BASE_ symbol in the TLS segment.

void
Target_i386::define_tls_base_symbol(Symbol_table* symtab, Layout* layout)
{
  if (this->tls_base_symbol_defined_)
    return;

  Output_segment* tls_segment = layout->tls_segment();
  if (tls_segment != NULL)
    {
      bool is_exec = parameters->options().output_is_executable();
      symtab->define_in_output_segment("_TLS_MODULE_BASE_", NULL,
				       Symbol_table::PREDEFINED,
				       tls_segment, 0, 0,
				       elfcpp::STT_TLS,
				       elfcpp::STB_LOCAL,
				       elfcpp::STV_HIDDEN, 0,
				       (is_exec
					? Symbol::SEGMENT_END
					: Symbol::SEGMENT_START),
				       true);
    }
  this->tls_base_symbol_defined_ = true;
}

// Create a GOT entry for the TLS module index.

unsigned int
Target_i386::got_mod_index_entry(Symbol_table* symtab, Layout* layout,
				 Sized_relobj_file<32, false>* object)
{
  if (this->got_mod_index_offset_ == -1U)
    {
      gold_assert(symtab != NULL && layout != NULL && object != NULL);
      Reloc_section* rel_dyn = this->rel_dyn_section(layout);
      Output_data_got<32, false>* got = this->got_section(symtab, layout);
      unsigned int got_offset = got->add_constant(0);
      rel_dyn->add_local(object, 0, elfcpp::R_386_TLS_DTPMOD32, got,
			 got_offset);
      got->add_constant(0);
      this->got_mod_index_offset_ = got_offset;
    }
  return this->got_mod_index_offset_;
}

// Optimize the TLS relocation type based on what we know about the
// symbol.  IS_FINAL is true if the final address of this symbol is
// known at link time.

tls::Tls_optimization
Target_i386::optimize_tls_reloc(bool is_final, int r_type)
{
  // If we are generating a shared library, then we can't do anything
  // in the linker.
  if (parameters->options().shared())
    return tls::TLSOPT_NONE;

  switch (r_type)
    {
    case elfcpp::R_386_TLS_GD:
    case elfcpp::R_386_TLS_GOTDESC:
    case elfcpp::R_386_TLS_DESC_CALL:
      // These are General-Dynamic which permits fully general TLS
      // access.  Since we know that we are generating an executable,
      // we can convert this to Initial-Exec.  If we also know that
      // this is a local symbol, we can further switch to Local-Exec.
      if (is_final)
	return tls::TLSOPT_TO_LE;
      return tls::TLSOPT_TO_IE;

    case elfcpp::R_386_TLS_LDM:
      // This is Local-Dynamic, which refers to a local symbol in the
      // dynamic TLS block.  Since we know that we generating an
      // executable, we can switch to Local-Exec.
      return tls::TLSOPT_TO_LE;

    case elfcpp::R_386_TLS_LDO_32:
      // Another type of Local-Dynamic relocation.
      return tls::TLSOPT_TO_LE;

    case elfcpp::R_386_TLS_IE:
    case elfcpp::R_386_TLS_GOTIE:
    case elfcpp::R_386_TLS_IE_32:
      // These are Initial-Exec relocs which get the thread offset
      // from the GOT.  If we know that we are linking against the
      // local symbol, we can switch to Local-Exec, which links the
      // thread offset into the instruction.
      if (is_final)
	return tls::TLSOPT_TO_LE;
      return tls::TLSOPT_NONE;

    case elfcpp::R_386_TLS_LE:
    case elfcpp::R_386_TLS_LE_32:
      // When we already have Local-Exec, there is nothing further we
      // can do.
      return tls::TLSOPT_NONE;

    default:
      gold_unreachable();
    }
}

// Get the Reference_flags for a particular relocation.

int
Target_i386::Scan::get_reference_flags(unsigned int r_type)
{
  switch (r_type)
    {
    case elfcpp::R_386_NONE:
    case elfcpp::R_386_GNU_VTINHERIT:
    case elfcpp::R_386_GNU_VTENTRY:
    case elfcpp::R_386_GOTPC:
      // No symbol reference.
      return 0;

    case elfcpp::R_386_32:
    case elfcpp::R_386_16:
    case elfcpp::R_386_8:
      return Symbol::ABSOLUTE_REF;

    case elfcpp::R_386_PC32:
    case elfcpp::R_386_PC16:
    case elfcpp::R_386_PC8:
    case elfcpp::R_386_GOTOFF:
      return Symbol::RELATIVE_REF;

    case elfcpp::R_386_PLT32:
      return Symbol::FUNCTION_CALL | Symbol::RELATIVE_REF;

    case elfcpp::R_386_GOT32:
      // Absolute in GOT.
      return Symbol::ABSOLUTE_REF;

    case elfcpp::R_386_TLS_GD:            // Global-dynamic
    case elfcpp::R_386_TLS_GOTDESC:       // Global-dynamic (from ~oliva url)
    case elfcpp::R_386_TLS_DESC_CALL:
    case elfcpp::R_386_TLS_LDM:           // Local-dynamic
    case elfcpp::R_386_TLS_LDO_32:        // Alternate local-dynamic
    case elfcpp::R_386_TLS_IE:            // Initial-exec
    case elfcpp::R_386_TLS_IE_32:
    case elfcpp::R_386_TLS_GOTIE:
    case elfcpp::R_386_TLS_LE:            // Local-exec
    case elfcpp::R_386_TLS_LE_32:
      return Symbol::TLS_REF;

    case elfcpp::R_386_COPY:
    case elfcpp::R_386_GLOB_DAT:
    case elfcpp::R_386_JUMP_SLOT:
    case elfcpp::R_386_RELATIVE:
    case elfcpp::R_386_IRELATIVE:
    case elfcpp::R_386_TLS_TPOFF:
    case elfcpp::R_386_TLS_DTPMOD32:
    case elfcpp::R_386_TLS_DTPOFF32:
    case elfcpp::R_386_TLS_TPOFF32:
    case elfcpp::R_386_TLS_DESC:
    case elfcpp::R_386_32PLT:
    case elfcpp::R_386_TLS_GD_32:
    case elfcpp::R_386_TLS_GD_PUSH:
    case elfcpp::R_386_TLS_GD_CALL:
    case elfcpp::R_386_TLS_GD_POP:
    case elfcpp::R_386_TLS_LDM_32:
    case elfcpp::R_386_TLS_LDM_PUSH:
    case elfcpp::R_386_TLS_LDM_CALL:
    case elfcpp::R_386_TLS_LDM_POP:
    case elfcpp::R_386_USED_BY_INTEL_200:
    default:
      // Not expected.  We will give an error later.
      return 0;
    }
}

// Report an unsupported relocation against a local symbol.

void
Target_i386::Scan::unsupported_reloc_local(Sized_relobj_file<32, false>* object,
					   unsigned int r_type)
{
  gold_error(_("%s: unsupported reloc %u against local symbol"),
	     object->name().c_str(), r_type);
}

// Return whether we need to make a PLT entry for a relocation of a
// given type against a STT_GNU_IFUNC symbol.

bool
Target_i386::Scan::reloc_needs_plt_for_ifunc(
    Sized_relobj_file<32, false>* object,
    unsigned int r_type)
{
  int flags = Scan::get_reference_flags(r_type);
  if (flags & Symbol::TLS_REF)
    gold_error(_("%s: unsupported TLS reloc %u for IFUNC symbol"),
	       object->name().c_str(), r_type);
  return flags != 0;
}

// Scan a relocation for a local symbol.

inline void
Target_i386::Scan::local(Symbol_table* symtab,
			 Layout* layout,
			 Target_i386* target,
			 Sized_relobj_file<32, false>* object,
			 unsigned int data_shndx,
			 Output_section* output_section,
			 const elfcpp::Rel<32, false>& reloc,
			 unsigned int r_type,
			 const elfcpp::Sym<32, false>& lsym,
			 bool is_discarded)
{
  if (is_discarded)
    return;

  // A local STT_GNU_IFUNC symbol may require a PLT entry.
  if (lsym.get_st_type() == elfcpp::STT_GNU_IFUNC
      && this->reloc_needs_plt_for_ifunc(object, r_type))
    {
      unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
      target->make_local_ifunc_plt_entry(symtab, layout, object, r_sym);
    }

  switch (r_type)
    {
    case elfcpp::R_386_NONE:
    case elfcpp::R_386_GNU_VTINHERIT:
    case elfcpp::R_386_GNU_VTENTRY:
      break;

    case elfcpp::R_386_32:
      // If building a shared library (or a position-independent
      // executable), we need to create a dynamic relocation for
      // this location. The relocation applied at link time will
      // apply the link-time value, so we flag the location with
      // an R_386_RELATIVE relocation so the dynamic loader can
      // relocate it easily.
      if (parameters->options().output_is_position_independent())
	{
	  Reloc_section* rel_dyn = target->rel_dyn_section(layout);
	  unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
	  rel_dyn->add_local_relative(object, r_sym, elfcpp::R_386_RELATIVE,
				      output_section, data_shndx,
				      reloc.get_r_offset());
	}
      break;

    case elfcpp::R_386_16:
    case elfcpp::R_386_8:
      // If building a shared library (or a position-independent
      // executable), we need to create a dynamic relocation for
      // this location. Because the addend needs to remain in the
      // data section, we need to be careful not to apply this
      // relocation statically.
      if (parameters->options().output_is_position_independent())
	{
	  Reloc_section* rel_dyn = target->rel_dyn_section(layout);
	  unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
	  if (lsym.get_st_type() != elfcpp::STT_SECTION)
	    rel_dyn->add_local(object, r_sym, r_type, output_section,
			       data_shndx, reloc.get_r_offset());
	  else
	    {
	      gold_assert(lsym.get_st_value() == 0);
	      unsigned int shndx = lsym.get_st_shndx();
	      bool is_ordinary;
	      shndx = object->adjust_sym_shndx(r_sym, shndx,
					       &is_ordinary);
	      if (!is_ordinary)
		object->error(_("section symbol %u has bad shndx %u"),
			      r_sym, shndx);
	      else
		rel_dyn->add_local_section(object, shndx,
					   r_type, output_section,
					   data_shndx, reloc.get_r_offset());
	    }
	}
      break;

    case elfcpp::R_386_PC32:
    case elfcpp::R_386_PC16:
    case elfcpp::R_386_PC8:
      break;

    case elfcpp::R_386_PLT32:
      // Since we know this is a local symbol, we can handle this as a
      // PC32 reloc.
      break;

    case elfcpp::R_386_GOTOFF:
    case elfcpp::R_386_GOTPC:
      // We need a GOT section.
      target->got_section(symtab, layout);
      break;

    case elfcpp::R_386_GOT32:
      {
	// The symbol requires a GOT entry.
	Output_data_got<32, false>* got = target->got_section(symtab, layout);
	unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());

	// For a STT_GNU_IFUNC symbol we want the PLT offset.  That
	// lets function pointers compare correctly with shared
	// libraries.  Otherwise we would need an IRELATIVE reloc.
	bool is_new;
	if (lsym.get_st_type() == elfcpp::STT_GNU_IFUNC)
	  is_new = got->add_local_plt(object, r_sym, GOT_TYPE_STANDARD);
	else
	  is_new = got->add_local(object, r_sym, GOT_TYPE_STANDARD);
	if (is_new)
	  {
	    // If we are generating a shared object, we need to add a
	    // dynamic RELATIVE relocation for this symbol's GOT entry.
	    if (parameters->options().output_is_position_independent())
	      {
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		unsigned int got_offset =
		  object->local_got_offset(r_sym, GOT_TYPE_STANDARD);
		rel_dyn->add_local_relative(object, r_sym,
					    elfcpp::R_386_RELATIVE,
					    got, got_offset);
	      }
	  }
      }
      break;

      // These are relocations which should only be seen by the
      // dynamic linker, and should never be seen here.
    case elfcpp::R_386_COPY:
    case elfcpp::R_386_GLOB_DAT:
    case elfcpp::R_386_JUMP_SLOT:
    case elfcpp::R_386_RELATIVE:
    case elfcpp::R_386_IRELATIVE:
    case elfcpp::R_386_TLS_TPOFF:
    case elfcpp::R_386_TLS_DTPMOD32:
    case elfcpp::R_386_TLS_DTPOFF32:
    case elfcpp::R_386_TLS_TPOFF32:
    case elfcpp::R_386_TLS_DESC:
      gold_error(_("%s: unexpected reloc %u in object file"),
		 object->name().c_str(), r_type);
      break;

      // These are initial TLS relocs, which are expected when
      // linking.
    case elfcpp::R_386_TLS_GD:            // Global-dynamic
    case elfcpp::R_386_TLS_GOTDESC:       // Global-dynamic (from ~oliva url)
    case elfcpp::R_386_TLS_DESC_CALL:
    case elfcpp::R_386_TLS_LDM:           // Local-dynamic
    case elfcpp::R_386_TLS_LDO_32:        // Alternate local-dynamic
    case elfcpp::R_386_TLS_IE:            // Initial-exec
    case elfcpp::R_386_TLS_IE_32:
    case elfcpp::R_386_TLS_GOTIE:
    case elfcpp::R_386_TLS_LE:            // Local-exec
    case elfcpp::R_386_TLS_LE_32:
      {
	bool output_is_shared = parameters->options().shared();
	const tls::Tls_optimization optimized_type
	    = Target_i386::optimize_tls_reloc(!output_is_shared, r_type);
	switch (r_type)
	  {
	  case elfcpp::R_386_TLS_GD:          // Global-dynamic
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a pair of GOT entries for the module index and
		// dtv-relative offset.
		Output_data_got<32, false>* got
		    = target->got_section(symtab, layout);
		unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
		unsigned int shndx = lsym.get_st_shndx();
		bool is_ordinary;
		shndx = object->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
		if (!is_ordinary)
		  object->error(_("local symbol %u has bad shndx %u"),
			      r_sym, shndx);
		else
		  got->add_local_pair_with_rel(object, r_sym, shndx,
					       GOT_TYPE_TLS_PAIR,
					       target->rel_dyn_section(layout),
					       elfcpp::R_386_TLS_DTPMOD32);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_local(object, r_type);
	    break;

	  case elfcpp::R_386_TLS_GOTDESC:     // Global-dynamic (from ~oliva)
	    target->define_tls_base_symbol(symtab, layout);
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a double GOT entry with an R_386_TLS_DESC
		// reloc.  The R_386_TLS_DESC reloc is resolved
		// lazily, so the GOT entry needs to be in an area in
		// .got.plt, not .got.  Call got_section to make sure
		// the section has been created.
		target->got_section(symtab, layout);
		Output_data_got<32, false>* got = target->got_tlsdesc_section();
		unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
		if (!object->local_has_got_offset(r_sym, GOT_TYPE_TLS_DESC))
		  {
		    unsigned int got_offset = got->add_constant(0);
		    // The local symbol value is stored in the second
		    // GOT entry.
		    got->add_local(object, r_sym, GOT_TYPE_TLS_DESC);
		    // That set the GOT offset of the local symbol to
		    // point to the second entry, but we want it to
		    // point to the first.
		    object->set_local_got_offset(r_sym, GOT_TYPE_TLS_DESC,
						 got_offset);
		    Reloc_section* rt = target->rel_tls_desc_section(layout);
		    rt->add_absolute(elfcpp::R_386_TLS_DESC, got, got_offset);
		  }
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_local(object, r_type);
	    break;

	  case elfcpp::R_386_TLS_DESC_CALL:
	    break;

	  case elfcpp::R_386_TLS_LDM:         // Local-dynamic
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a GOT entry for the module index.
		target->got_mod_index_entry(symtab, layout, object);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_local(object, r_type);
	    break;

	  case elfcpp::R_386_TLS_LDO_32:      // Alternate local-dynamic
	    break;

	  case elfcpp::R_386_TLS_IE:          // Initial-exec
	  case elfcpp::R_386_TLS_IE_32:
	  case elfcpp::R_386_TLS_GOTIE:
	    layout->set_has_static_tls();
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// For the R_386_TLS_IE relocation, we need to create a
		// dynamic relocation when building a shared library.
		if (r_type == elfcpp::R_386_TLS_IE
		    && parameters->options().shared())
		  {
		    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		    unsigned int r_sym
			= elfcpp::elf_r_sym<32>(reloc.get_r_info());
		    rel_dyn->add_local_relative(object, r_sym,
						elfcpp::R_386_RELATIVE,
						output_section, data_shndx,
						reloc.get_r_offset());
		  }
		// Create a GOT entry for the tp-relative offset.
		Output_data_got<32, false>* got
		    = target->got_section(symtab, layout);
		unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
		unsigned int dyn_r_type = (r_type == elfcpp::R_386_TLS_IE_32
					   ? elfcpp::R_386_TLS_TPOFF32
					   : elfcpp::R_386_TLS_TPOFF);
		unsigned int got_type = (r_type == elfcpp::R_386_TLS_IE_32
					 ? GOT_TYPE_TLS_OFFSET
					 : GOT_TYPE_TLS_NOFFSET);
		got->add_local_with_rel(object, r_sym, got_type,
					target->rel_dyn_section(layout),
					dyn_r_type);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_local(object, r_type);
	    break;

	  case elfcpp::R_386_TLS_LE:          // Local-exec
	  case elfcpp::R_386_TLS_LE_32:
	    layout->set_has_static_tls();
	    if (output_is_shared)
	      {
		// We need to create a dynamic relocation.
		gold_assert(lsym.get_st_type() != elfcpp::STT_SECTION);
		unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
		unsigned int dyn_r_type = (r_type == elfcpp::R_386_TLS_LE_32
					   ? elfcpp::R_386_TLS_TPOFF32
					   : elfcpp::R_386_TLS_TPOFF);
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		rel_dyn->add_local(object, r_sym, dyn_r_type, output_section,
				   data_shndx, reloc.get_r_offset());
	      }
	    break;

	  default:
	    gold_unreachable();
	  }
      }
      break;

    case elfcpp::R_386_32PLT:
    case elfcpp::R_386_TLS_GD_32:
    case elfcpp::R_386_TLS_GD_PUSH:
    case elfcpp::R_386_TLS_GD_CALL:
    case elfcpp::R_386_TLS_GD_POP:
    case elfcpp::R_386_TLS_LDM_32:
    case elfcpp::R_386_TLS_LDM_PUSH:
    case elfcpp::R_386_TLS_LDM_CALL:
    case elfcpp::R_386_TLS_LDM_POP:
    case elfcpp::R_386_USED_BY_INTEL_200:
    default:
      unsupported_reloc_local(object, r_type);
      break;
    }
}

// Report an unsupported relocation against a global symbol.

void
Target_i386::Scan::unsupported_reloc_global(
    Sized_relobj_file<32, false>* object,
    unsigned int r_type,
    Symbol* gsym)
{
  gold_error(_("%s: unsupported reloc %u against global symbol %s"),
	     object->name().c_str(), r_type, gsym->demangled_name().c_str());
}

inline bool
Target_i386::Scan::possible_function_pointer_reloc(unsigned int r_type)
{
  switch (r_type)
    {
    case elfcpp::R_386_32:
    case elfcpp::R_386_16:
    case elfcpp::R_386_8:
    case elfcpp::R_386_GOTOFF:
    case elfcpp::R_386_GOT32:
      {
	return true;
      }
    default:
      return false;
    }
  return false;
}

inline bool
Target_i386::Scan::local_reloc_may_be_function_pointer(
  Symbol_table* ,
  Layout* ,
  Target_i386* ,
  Sized_relobj_file<32, false>* ,
  unsigned int ,
  Output_section* ,
  const elfcpp::Rel<32, false>& ,
  unsigned int r_type,
  const elfcpp::Sym<32, false>&)
{
  return possible_function_pointer_reloc(r_type);
}

inline bool
Target_i386::Scan::global_reloc_may_be_function_pointer(
  Symbol_table* ,
  Layout* ,
  Target_i386* ,
  Sized_relobj_file<32, false>* ,
  unsigned int ,
  Output_section* ,
  const elfcpp::Rel<32, false>& ,
  unsigned int r_type,
  Symbol*)
{
  return possible_function_pointer_reloc(r_type);
}

// Scan a relocation for a global symbol.

inline void
Target_i386::Scan::global(Symbol_table* symtab,
				 Layout* layout,
				 Target_i386* target,
				 Sized_relobj_file<32, false>* object,
				 unsigned int data_shndx,
				 Output_section* output_section,
				 const elfcpp::Rel<32, false>& reloc,
				 unsigned int r_type,
				 Symbol* gsym)
{
  // A STT_GNU_IFUNC symbol may require a PLT entry.
  if (gsym->type() == elfcpp::STT_GNU_IFUNC
      && this->reloc_needs_plt_for_ifunc(object, r_type))
    target->make_plt_entry(symtab, layout, gsym);

  switch (r_type)
    {
    case elfcpp::R_386_NONE:
    case elfcpp::R_386_GNU_VTINHERIT:
    case elfcpp::R_386_GNU_VTENTRY:
      break;

    case elfcpp::R_386_32:
    case elfcpp::R_386_16:
    case elfcpp::R_386_8:
      {
	// Make a PLT entry if necessary.
	if (gsym->needs_plt_entry())
	  {
	    target->make_plt_entry(symtab, layout, gsym);
	    // Since this is not a PC-relative relocation, we may be
	    // taking the address of a function. In that case we need to
	    // set the entry in the dynamic symbol table to the address of
	    // the PLT entry.
	    if (gsym->is_from_dynobj() && !parameters->options().shared())
	      gsym->set_needs_dynsym_value();
	  }
	// Make a dynamic relocation if necessary.
	if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
	  {
	    if (gsym->may_need_copy_reloc())
	      {
		target->copy_reloc(symtab, layout, object,
				   data_shndx, output_section, gsym, reloc);
	      }
	    else if (r_type == elfcpp::R_386_32
		     && gsym->type() == elfcpp::STT_GNU_IFUNC
		     && gsym->can_use_relative_reloc(false)
		     && !gsym->is_from_dynobj()
		     && !gsym->is_undefined()
		     && !gsym->is_preemptible())
	      {
		// Use an IRELATIVE reloc for a locally defined
		// STT_GNU_IFUNC symbol.  This makes a function
		// address in a PIE executable match the address in a
		// shared library that it links against.
		Reloc_section* rel_dyn = target->rel_irelative_section(layout);
		rel_dyn->add_symbolless_global_addend(gsym,
						      elfcpp::R_386_IRELATIVE,
						      output_section,
						      object, data_shndx,
						      reloc.get_r_offset());
	      }
	    else if (r_type == elfcpp::R_386_32
		     && gsym->can_use_relative_reloc(false))
	      {
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		rel_dyn->add_global_relative(gsym, elfcpp::R_386_RELATIVE,
					     output_section, object,
					     data_shndx, reloc.get_r_offset());
	      }
	    else
	      {
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		rel_dyn->add_global(gsym, r_type, output_section, object,
				    data_shndx, reloc.get_r_offset());
	      }
	  }
      }
      break;

    case elfcpp::R_386_PC32:
    case elfcpp::R_386_PC16:
    case elfcpp::R_386_PC8:
      {
	// Make a PLT entry if necessary.
	if (gsym->needs_plt_entry())
	  {
	    // These relocations are used for function calls only in
	    // non-PIC code.  For a 32-bit relocation in a shared library,
	    // we'll need a text relocation anyway, so we can skip the
	    // PLT entry and let the dynamic linker bind the call directly
	    // to the target.  For smaller relocations, we should use a
	    // PLT entry to ensure that the call can reach.
	    if (!parameters->options().shared()
		|| r_type != elfcpp::R_386_PC32)
	      target->make_plt_entry(symtab, layout, gsym);
	  }
	// Make a dynamic relocation if necessary.
	if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
	  {
	    if (gsym->may_need_copy_reloc())
	      {
		target->copy_reloc(symtab, layout, object,
				   data_shndx, output_section, gsym, reloc);
	      }
	    else
	      {
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		rel_dyn->add_global(gsym, r_type, output_section, object,
				    data_shndx, reloc.get_r_offset());
	      }
	  }
      }
      break;

    case elfcpp::R_386_GOT32:
      {
	// The symbol requires a GOT entry.
	Output_data_got<32, false>* got = target->got_section(symtab, layout);
	if (gsym->final_value_is_known())
	  {
	    // For a STT_GNU_IFUNC symbol we want the PLT address.
	    if (gsym->type() == elfcpp::STT_GNU_IFUNC)
	      got->add_global_plt(gsym, GOT_TYPE_STANDARD);
	    else
	      got->add_global(gsym, GOT_TYPE_STANDARD);
	  }
	else
	  {
	    // If this symbol is not fully resolved, we need to add a
	    // GOT entry with a dynamic relocation.
	    Reloc_section* rel_dyn = target->rel_dyn_section(layout);

	    // Use a GLOB_DAT rather than a RELATIVE reloc if:
	    //
	    // 1) The symbol may be defined in some other module.
	    //
	    // 2) We are building a shared library and this is a
	    // protected symbol; using GLOB_DAT means that the dynamic
	    // linker can use the address of the PLT in the main
	    // executable when appropriate so that function address
	    // comparisons work.
	    //
	    // 3) This is a STT_GNU_IFUNC symbol in position dependent
	    // code, again so that function address comparisons work.
	    if (gsym->is_from_dynobj()
		|| gsym->is_undefined()
		|| gsym->is_preemptible()
		|| (gsym->visibility() == elfcpp::STV_PROTECTED
		    && parameters->options().shared())
		|| (gsym->type() == elfcpp::STT_GNU_IFUNC
		    && parameters->options().output_is_position_independent()))
	      got->add_global_with_rel(gsym, GOT_TYPE_STANDARD,
				       rel_dyn, elfcpp::R_386_GLOB_DAT);
	    else
	      {
		// For a STT_GNU_IFUNC symbol we want to write the PLT
		// offset into the GOT, so that function pointer
		// comparisons work correctly.
		bool is_new;
		if (gsym->type() != elfcpp::STT_GNU_IFUNC)
		  is_new = got->add_global(gsym, GOT_TYPE_STANDARD);
		else
		  {
		    is_new = got->add_global_plt(gsym, GOT_TYPE_STANDARD);
		    // Tell the dynamic linker to use the PLT address
		    // when resolving relocations.
		    if (gsym->is_from_dynobj()
			&& !parameters->options().shared())
		      gsym->set_needs_dynsym_value();
		  }
		if (is_new)
		  {
		    unsigned int got_off = gsym->got_offset(GOT_TYPE_STANDARD);
		    rel_dyn->add_global_relative(gsym, elfcpp::R_386_RELATIVE,
						 got, got_off);
		  }
	      }
	  }
      }
      break;

    case elfcpp::R_386_PLT32:
      // If the symbol is fully resolved, this is just a PC32 reloc.
      // Otherwise we need a PLT entry.
      if (gsym->final_value_is_known())
	break;
      // If building a shared library, we can also skip the PLT entry
      // if the symbol is defined in the output file and is protected
      // or hidden.
      if (gsym->is_defined()
	  && !gsym->is_from_dynobj()
	  && !gsym->is_preemptible())
	break;
      target->make_plt_entry(symtab, layout, gsym);
      break;

    case elfcpp::R_386_GOTOFF:
    case elfcpp::R_386_GOTPC:
      // We need a GOT section.
      target->got_section(symtab, layout);
      break;

      // These are relocations which should only be seen by the
      // dynamic linker, and should never be seen here.
    case elfcpp::R_386_COPY:
    case elfcpp::R_386_GLOB_DAT:
    case elfcpp::R_386_JUMP_SLOT:
    case elfcpp::R_386_RELATIVE:
    case elfcpp::R_386_IRELATIVE:
    case elfcpp::R_386_TLS_TPOFF:
    case elfcpp::R_386_TLS_DTPMOD32:
    case elfcpp::R_386_TLS_DTPOFF32:
    case elfcpp::R_386_TLS_TPOFF32:
    case elfcpp::R_386_TLS_DESC:
      gold_error(_("%s: unexpected reloc %u in object file"),
		 object->name().c_str(), r_type);
      break;

      // These are initial tls relocs, which are expected when
      // linking.
    case elfcpp::R_386_TLS_GD:            // Global-dynamic
    case elfcpp::R_386_TLS_GOTDESC:       // Global-dynamic (from ~oliva url)
    case elfcpp::R_386_TLS_DESC_CALL:
    case elfcpp::R_386_TLS_LDM:           // Local-dynamic
    case elfcpp::R_386_TLS_LDO_32:        // Alternate local-dynamic
    case elfcpp::R_386_TLS_IE:            // Initial-exec
    case elfcpp::R_386_TLS_IE_32:
    case elfcpp::R_386_TLS_GOTIE:
    case elfcpp::R_386_TLS_LE:            // Local-exec
    case elfcpp::R_386_TLS_LE_32:
      {
	const bool is_final = gsym->final_value_is_known();
	const tls::Tls_optimization optimized_type
	    = Target_i386::optimize_tls_reloc(is_final, r_type);
	switch (r_type)
	  {
	  case elfcpp::R_386_TLS_GD:          // Global-dynamic
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a pair of GOT entries for the module index and
		// dtv-relative offset.
		Output_data_got<32, false>* got
		    = target->got_section(symtab, layout);
		got->add_global_pair_with_rel(gsym, GOT_TYPE_TLS_PAIR,
					     target->rel_dyn_section(layout),
					     elfcpp::R_386_TLS_DTPMOD32,
					     elfcpp::R_386_TLS_DTPOFF32);
	      }
	    else if (optimized_type == tls::TLSOPT_TO_IE)
	      {
		// Create a GOT entry for the tp-relative offset.
		Output_data_got<32, false>* got
		    = target->got_section(symtab, layout);
		got->add_global_with_rel(gsym, GOT_TYPE_TLS_NOFFSET,
					 target->rel_dyn_section(layout),
					 elfcpp::R_386_TLS_TPOFF);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_global(object, r_type, gsym);
	    break;

	  case elfcpp::R_386_TLS_GOTDESC:     // Global-dynamic (~oliva url)
	    target->define_tls_base_symbol(symtab, layout);
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a double GOT entry with an R_386_TLS_DESC
		// reloc.  The R_386_TLS_DESC reloc is resolved
		// lazily, so the GOT entry needs to be in an area in
		// .got.plt, not .got.  Call got_section to make sure
		// the section has been created.
		target->got_section(symtab, layout);
		Output_data_got<32, false>* got = target->got_tlsdesc_section();
		Reloc_section* rt = target->rel_tls_desc_section(layout);
		got->add_global_pair_with_rel(gsym, GOT_TYPE_TLS_DESC, rt,
					     elfcpp::R_386_TLS_DESC, 0);
	      }
	    else if (optimized_type == tls::TLSOPT_TO_IE)
	      {
		// Create a GOT entry for the tp-relative offset.
		Output_data_got<32, false>* got
		    = target->got_section(symtab, layout);
		got->add_global_with_rel(gsym, GOT_TYPE_TLS_NOFFSET,
					 target->rel_dyn_section(layout),
					 elfcpp::R_386_TLS_TPOFF);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_global(object, r_type, gsym);
	    break;

	  case elfcpp::R_386_TLS_DESC_CALL:
	    break;

	  case elfcpp::R_386_TLS_LDM:         // Local-dynamic
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a GOT entry for the module index.
		target->got_mod_index_entry(symtab, layout, object);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_global(object, r_type, gsym);
	    break;

	  case elfcpp::R_386_TLS_LDO_32:      // Alternate local-dynamic
	    break;

	  case elfcpp::R_386_TLS_IE:          // Initial-exec
	  case elfcpp::R_386_TLS_IE_32:
	  case elfcpp::R_386_TLS_GOTIE:
	    layout->set_has_static_tls();
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// For the R_386_TLS_IE relocation, we need to create a
		// dynamic relocation when building a shared library.
		if (r_type == elfcpp::R_386_TLS_IE
		    && parameters->options().shared())
		  {
		    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		    rel_dyn->add_global_relative(gsym, elfcpp::R_386_RELATIVE,
						 output_section, object,
						 data_shndx,
						 reloc.get_r_offset());
		  }
		// Create a GOT entry for the tp-relative offset.
		Output_data_got<32, false>* got
		    = target->got_section(symtab, layout);
		unsigned int dyn_r_type = (r_type == elfcpp::R_386_TLS_IE_32
					   ? elfcpp::R_386_TLS_TPOFF32
					   : elfcpp::R_386_TLS_TPOFF);
		unsigned int got_type = (r_type == elfcpp::R_386_TLS_IE_32
					 ? GOT_TYPE_TLS_OFFSET
					 : GOT_TYPE_TLS_NOFFSET);
		got->add_global_with_rel(gsym, got_type,
					 target->rel_dyn_section(layout),
					 dyn_r_type);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_global(object, r_type, gsym);
	    break;

	  case elfcpp::R_386_TLS_LE:          // Local-exec
	  case elfcpp::R_386_TLS_LE_32:
	    layout->set_has_static_tls();
	    if (parameters->options().shared())
	      {
		// We need to create a dynamic relocation.
		unsigned int dyn_r_type = (r_type == elfcpp::R_386_TLS_LE_32
					   ? elfcpp::R_386_TLS_TPOFF32
					   : elfcpp::R_386_TLS_TPOFF);
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		rel_dyn->add_global(gsym, dyn_r_type, output_section, object,
				    data_shndx, reloc.get_r_offset());
	      }
	    break;

	  default:
	    gold_unreachable();
	  }
      }
      break;

    case elfcpp::R_386_32PLT:
    case elfcpp::R_386_TLS_GD_32:
    case elfcpp::R_386_TLS_GD_PUSH:
    case elfcpp::R_386_TLS_GD_CALL:
    case elfcpp::R_386_TLS_GD_POP:
    case elfcpp::R_386_TLS_LDM_32:
    case elfcpp::R_386_TLS_LDM_PUSH:
    case elfcpp::R_386_TLS_LDM_CALL:
    case elfcpp::R_386_TLS_LDM_POP:
    case elfcpp::R_386_USED_BY_INTEL_200:
    default:
      unsupported_reloc_global(object, r_type, gsym);
      break;
    }
}

// Process relocations for gc.

void
Target_i386::gc_process_relocs(Symbol_table* symtab,
				      Layout* layout,
				      Sized_relobj_file<32, false>* object,
				      unsigned int data_shndx,
				      unsigned int,
				      const unsigned char* prelocs,
				      size_t reloc_count,
				      Output_section* output_section,
				      bool needs_special_offset_handling,
				      size_t local_symbol_count,
				      const unsigned char* plocal_symbols)
{
  gold::gc_process_relocs<32, false, Target_i386, elfcpp::SHT_REL,
			  Target_i386::Scan,
			  Target_i386::Relocatable_size_for_reloc>(
    symtab,
    layout,
    this,
    object,
    data_shndx,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    local_symbol_count,
    plocal_symbols);
}

// Scan relocations for a section.

void
Target_i386::scan_relocs(Symbol_table* symtab,
				Layout* layout,
				Sized_relobj_file<32, false>* object,
				unsigned int data_shndx,
				unsigned int sh_type,
				const unsigned char* prelocs,
				size_t reloc_count,
				Output_section* output_section,
				bool needs_special_offset_handling,
				size_t local_symbol_count,
				const unsigned char* plocal_symbols)
{
  if (sh_type == elfcpp::SHT_RELA)
    {
      gold_error(_("%s: unsupported RELA reloc section"),
		 object->name().c_str());
      return;
    }

  gold::scan_relocs<32, false, Target_i386, elfcpp::SHT_REL,
		    Target_i386::Scan>(
    symtab,
    layout,
    this,
    object,
    data_shndx,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    local_symbol_count,
    plocal_symbols);
}

// Finalize the sections.

void
Target_i386::do_finalize_sections(
    Layout* layout,
    const Input_objects*,
    Symbol_table* symtab)
{
  const Reloc_section* rel_plt = (this->plt_ == NULL
				  ? NULL
				  : this->plt_->rel_plt());
  layout->add_target_dynamic_tags(true, this->got_plt_, rel_plt,
				  this->rel_dyn_, true, false);

  // Emit any relocs we saved in an attempt to avoid generating COPY
  // relocs.
  if (this->copy_relocs_.any_saved_relocs())
    this->copy_relocs_.emit(this->rel_dyn_section(layout));

  // Set the size of the _GLOBAL_OFFSET_TABLE_ symbol to the size of
  // the .got.plt section.
  Symbol* sym = this->global_offset_table_;
  if (sym != NULL)
    {
      uint32_t data_size = this->got_plt_->current_data_size();
      symtab->get_sized_symbol<32>(sym)->set_symsize(data_size);
    }

  if (parameters->doing_static_link()
      && (this->plt_ == NULL || !this->plt_->has_irelative_section()))
    {
      // If linking statically, make sure that the __rel_iplt symbols
      // were defined if necessary, even if we didn't create a PLT.
      static const Define_symbol_in_segment syms[] =
	{
	  {
	    "__rel_iplt_start",		// name
	    elfcpp::PT_LOAD,		// segment_type
	    elfcpp::PF_W,		// segment_flags_set
	    elfcpp::PF(0),		// segment_flags_clear
	    0,				// value
	    0,				// size
	    elfcpp::STT_NOTYPE,		// type
	    elfcpp::STB_GLOBAL,		// binding
	    elfcpp::STV_HIDDEN,		// visibility
	    0,				// nonvis
	    Symbol::SEGMENT_START,	// offset_from_base
	    true			// only_if_ref
	  },
	  {
	    "__rel_iplt_end",		// name
	    elfcpp::PT_LOAD,		// segment_type
	    elfcpp::PF_W,		// segment_flags_set
	    elfcpp::PF(0),		// segment_flags_clear
	    0,				// value
	    0,				// size
	    elfcpp::STT_NOTYPE,		// type
	    elfcpp::STB_GLOBAL,		// binding
	    elfcpp::STV_HIDDEN,		// visibility
	    0,				// nonvis
	    Symbol::SEGMENT_START,	// offset_from_base
	    true			// only_if_ref
	  }
	};

      symtab->define_symbols(layout, 2, syms,
			     layout->script_options()->saw_sections_clause());
    }
}

// Return whether a direct absolute static relocation needs to be applied.
// In cases where Scan::local() or Scan::global() has created
// a dynamic relocation other than R_386_RELATIVE, the addend
// of the relocation is carried in the data, and we must not
// apply the static relocation.

inline bool
Target_i386::Relocate::should_apply_static_reloc(const Sized_symbol<32>* gsym,
						 unsigned int r_type,
						 bool is_32bit,
						 Output_section* output_section)
{
  // If the output section is not allocated, then we didn't call
  // scan_relocs, we didn't create a dynamic reloc, and we must apply
  // the reloc here.
  if ((output_section->flags() & elfcpp::SHF_ALLOC) == 0)
    return true;

  int ref_flags = Scan::get_reference_flags(r_type);

  // For local symbols, we will have created a non-RELATIVE dynamic
  // relocation only if (a) the output is position independent,
  // (b) the relocation is absolute (not pc- or segment-relative), and
  // (c) the relocation is not 32 bits wide.
  if (gsym == NULL)
    return !(parameters->options().output_is_position_independent()
	     && (ref_flags & Symbol::ABSOLUTE_REF)
	     && !is_32bit);

  // For global symbols, we use the same helper routines used in the
  // scan pass.  If we did not create a dynamic relocation, or if we
  // created a RELATIVE dynamic relocation, we should apply the static
  // relocation.
  bool has_dyn = gsym->needs_dynamic_reloc(ref_flags);
  bool is_rel = (ref_flags & Symbol::ABSOLUTE_REF)
		&& gsym->can_use_relative_reloc(ref_flags
						& Symbol::FUNCTION_CALL);
  return !has_dyn || is_rel;
}

// Perform a relocation.

inline bool
Target_i386::Relocate::relocate(const Relocate_info<32, false>* relinfo,
				       Target_i386* target,
				       Output_section* output_section,
				       size_t relnum,
				       const elfcpp::Rel<32, false>& rel,
				       unsigned int r_type,
				       const Sized_symbol<32>* gsym,
				       const Symbol_value<32>* psymval,
				       unsigned char* view,
				       elfcpp::Elf_types<32>::Elf_Addr address,
				       section_size_type view_size)
{
  if (this->skip_call_tls_get_addr_)
    {
      if ((r_type != elfcpp::R_386_PLT32
	   && r_type != elfcpp::R_386_PC32)
	  || gsym == NULL
	  || strcmp(gsym->name(), "___tls_get_addr") != 0)
	gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			       _("missing expected TLS relocation"));
      else
	{
	  this->skip_call_tls_get_addr_ = false;
	  return false;
	}
    }

  if (view == NULL)
    return true;

  const Sized_relobj_file<32, false>* object = relinfo->object;

  // Pick the value to use for symbols defined in shared objects.
  Symbol_value<32> symval;
  if (gsym != NULL
      && gsym->type() == elfcpp::STT_GNU_IFUNC
      && r_type == elfcpp::R_386_32
      && gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type))
      && gsym->can_use_relative_reloc(false)
      && !gsym->is_from_dynobj()
      && !gsym->is_undefined()
      && !gsym->is_preemptible())
    {
      // In this case we are generating a R_386_IRELATIVE reloc.  We
      // want to use the real value of the symbol, not the PLT offset.
    }
  else if (gsym != NULL
	   && gsym->use_plt_offset(Scan::get_reference_flags(r_type)))
    {
      symval.set_output_value(target->plt_address_for_global(gsym));
      psymval = &symval;
    }
  else if (gsym == NULL && psymval->is_ifunc_symbol())
    {
      unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
      if (object->local_has_plt_offset(r_sym))
	{
	  symval.set_output_value(target->plt_address_for_local(object, r_sym));
	  psymval = &symval;
	}
    }

  // Get the GOT offset if needed.
  // The GOT pointer points to the end of the GOT section.
  // We need to subtract the size of the GOT section to get
  // the actual offset to use in the relocation.
  bool have_got_offset = false;
  unsigned int got_offset = 0;
  switch (r_type)
    {
    case elfcpp::R_386_GOT32:
      if (gsym != NULL)
	{
	  gold_assert(gsym->has_got_offset(GOT_TYPE_STANDARD));
	  got_offset = (gsym->got_offset(GOT_TYPE_STANDARD)
			- target->got_size());
	}
      else
	{
	  unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
	  gold_assert(object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD));
	  got_offset = (object->local_got_offset(r_sym, GOT_TYPE_STANDARD)
			- target->got_size());
	}
      have_got_offset = true;
      break;

    default:
      break;
    }

  switch (r_type)
    {
    case elfcpp::R_386_NONE:
    case elfcpp::R_386_GNU_VTINHERIT:
    case elfcpp::R_386_GNU_VTENTRY:
      break;

    case elfcpp::R_386_32:
      if (should_apply_static_reloc(gsym, r_type, true, output_section))
	Relocate_functions<32, false>::rel32(view, object, psymval);
      break;

    case elfcpp::R_386_PC32:
      if (should_apply_static_reloc(gsym, r_type, true, output_section))
	Relocate_functions<32, false>::pcrel32(view, object, psymval, address);
      break;

    case elfcpp::R_386_16:
      if (should_apply_static_reloc(gsym, r_type, false, output_section))
	Relocate_functions<32, false>::rel16(view, object, psymval);
      break;

    case elfcpp::R_386_PC16:
      if (should_apply_static_reloc(gsym, r_type, false, output_section))
	Relocate_functions<32, false>::pcrel16(view, object, psymval, address);
      break;

    case elfcpp::R_386_8:
      if (should_apply_static_reloc(gsym, r_type, false, output_section))
	Relocate_functions<32, false>::rel8(view, object, psymval);
      break;

    case elfcpp::R_386_PC8:
      if (should_apply_static_reloc(gsym, r_type, false, output_section))
	Relocate_functions<32, false>::pcrel8(view, object, psymval, address);
      break;

    case elfcpp::R_386_PLT32:
      gold_assert(gsym == NULL
		  || gsym->has_plt_offset()
		  || gsym->final_value_is_known()
		  || (gsym->is_defined()
		      && !gsym->is_from_dynobj()
		      && !gsym->is_preemptible()));
      Relocate_functions<32, false>::pcrel32(view, object, psymval, address);
      break;

    case elfcpp::R_386_GOT32:
      gold_assert(have_got_offset);
      Relocate_functions<32, false>::rel32(view, got_offset);
      break;

    case elfcpp::R_386_GOTOFF:
      {
	elfcpp::Elf_types<32>::Elf_Addr value;
	value = (psymval->value(object, 0)
		 - target->got_plt_section()->address());
	Relocate_functions<32, false>::rel32(view, value);
      }
      break;

    case elfcpp::R_386_GOTPC:
      {
	elfcpp::Elf_types<32>::Elf_Addr value;
	value = target->got_plt_section()->address();
	Relocate_functions<32, false>::pcrel32(view, value, address);
      }
      break;

    case elfcpp::R_386_COPY:
    case elfcpp::R_386_GLOB_DAT:
    case elfcpp::R_386_JUMP_SLOT:
    case elfcpp::R_386_RELATIVE:
    case elfcpp::R_386_IRELATIVE:
      // These are outstanding tls relocs, which are unexpected when
      // linking.
    case elfcpp::R_386_TLS_TPOFF:
    case elfcpp::R_386_TLS_DTPMOD32:
    case elfcpp::R_386_TLS_DTPOFF32:
    case elfcpp::R_386_TLS_TPOFF32:
    case elfcpp::R_386_TLS_DESC:
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			     _("unexpected reloc %u in object file"),
			     r_type);
      break;

      // These are initial tls relocs, which are expected when
      // linking.
    case elfcpp::R_386_TLS_GD:             // Global-dynamic
    case elfcpp::R_386_TLS_GOTDESC:        // Global-dynamic (from ~oliva url)
    case elfcpp::R_386_TLS_DESC_CALL:
    case elfcpp::R_386_TLS_LDM:            // Local-dynamic
    case elfcpp::R_386_TLS_LDO_32:         // Alternate local-dynamic
    case elfcpp::R_386_TLS_IE:             // Initial-exec
    case elfcpp::R_386_TLS_IE_32:
    case elfcpp::R_386_TLS_GOTIE:
    case elfcpp::R_386_TLS_LE:             // Local-exec
    case elfcpp::R_386_TLS_LE_32:
      this->relocate_tls(relinfo, target, relnum, rel, r_type, gsym, psymval,
			 view, address, view_size);
      break;

    case elfcpp::R_386_32PLT:
    case elfcpp::R_386_TLS_GD_32:
    case elfcpp::R_386_TLS_GD_PUSH:
    case elfcpp::R_386_TLS_GD_CALL:
    case elfcpp::R_386_TLS_GD_POP:
    case elfcpp::R_386_TLS_LDM_32:
    case elfcpp::R_386_TLS_LDM_PUSH:
    case elfcpp::R_386_TLS_LDM_CALL:
    case elfcpp::R_386_TLS_LDM_POP:
    case elfcpp::R_386_USED_BY_INTEL_200:
    default:
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			     _("unsupported reloc %u"),
			     r_type);
      break;
    }

  return true;
}

// Perform a TLS relocation.

inline void
Target_i386::Relocate::relocate_tls(const Relocate_info<32, false>* relinfo,
				    Target_i386* target,
				    size_t relnum,
				    const elfcpp::Rel<32, false>& rel,
				    unsigned int r_type,
				    const Sized_symbol<32>* gsym,
				    const Symbol_value<32>* psymval,
				    unsigned char* view,
				    elfcpp::Elf_types<32>::Elf_Addr,
				    section_size_type view_size)
{
  Output_segment* tls_segment = relinfo->layout->tls_segment();

  const Sized_relobj_file<32, false>* object = relinfo->object;

  elfcpp::Elf_types<32>::Elf_Addr value = psymval->value(object, 0);

  const bool is_final = (gsym == NULL
			 ? !parameters->options().shared()
			 : gsym->final_value_is_known());
  const tls::Tls_optimization optimized_type
      = Target_i386::optimize_tls_reloc(is_final, r_type);
  switch (r_type)
    {
    case elfcpp::R_386_TLS_GD:           // Global-dynamic
      if (optimized_type == tls::TLSOPT_TO_LE)
	{
	  if (tls_segment == NULL)
	    {
	      gold_assert(parameters->errors()->error_count() > 0
			  || issue_undefined_symbol_error(gsym));
	      return;
	    }
	  this->tls_gd_to_le(relinfo, relnum, tls_segment,
			     rel, r_type, value, view,
			     view_size);
	  break;
	}
      else
	{
	  unsigned int got_type = (optimized_type == tls::TLSOPT_TO_IE
				   ? GOT_TYPE_TLS_NOFFSET
				   : GOT_TYPE_TLS_PAIR);
	  unsigned int got_offset;
	  if (gsym != NULL)
	    {
	      gold_assert(gsym->has_got_offset(got_type));
	      got_offset = gsym->got_offset(got_type) - target->got_size();
	    }
	  else
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
	      gold_assert(object->local_has_got_offset(r_sym, got_type));
	      got_offset = (object->local_got_offset(r_sym, got_type)
			    - target->got_size());
	    }
	  if (optimized_type == tls::TLSOPT_TO_IE)
	    {
	      this->tls_gd_to_ie(relinfo, relnum, tls_segment, rel, r_type,
				 got_offset, view, view_size);
	      break;
	    }
	  else if (optimized_type == tls::TLSOPT_NONE)
	    {
	      // Relocate the field with the offset of the pair of GOT
	      // entries.
	      Relocate_functions<32, false>::rel32(view, got_offset);
	      break;
	    }
	}
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			     _("unsupported reloc %u"),
			     r_type);
      break;

    case elfcpp::R_386_TLS_GOTDESC:      // Global-dynamic (from ~oliva url)
    case elfcpp::R_386_TLS_DESC_CALL:
      this->local_dynamic_type_ = LOCAL_DYNAMIC_GNU;
      if (optimized_type == tls::TLSOPT_TO_LE)
	{
	  if (tls_segment == NULL)
	    {
	      gold_assert(parameters->errors()->error_count() > 0
			  || issue_undefined_symbol_error(gsym));
	      return;
	    }
	  this->tls_desc_gd_to_le(relinfo, relnum, tls_segment,
				  rel, r_type, value, view,
				  view_size);
	  break;
	}
      else
	{
	  unsigned int got_type = (optimized_type == tls::TLSOPT_TO_IE
				   ? GOT_TYPE_TLS_NOFFSET
				   : GOT_TYPE_TLS_DESC);
	  unsigned int got_offset = 0;
	  if (r_type == elfcpp::R_386_TLS_GOTDESC
	      && optimized_type == tls::TLSOPT_NONE)
	    {
	      // We created GOT entries in the .got.tlsdesc portion of
	      // the .got.plt section, but the offset stored in the
	      // symbol is the offset within .got.tlsdesc.
	      got_offset = (target->got_size()
			    + target->got_plt_section()->data_size());
	    }
	  if (gsym != NULL)
	    {
	      gold_assert(gsym->has_got_offset(got_type));
	      got_offset += gsym->got_offset(got_type) - target->got_size();
	    }
	  else
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
	      gold_assert(object->local_has_got_offset(r_sym, got_type));
	      got_offset += (object->local_got_offset(r_sym, got_type)
			     - target->got_size());
	    }
	  if (optimized_type == tls::TLSOPT_TO_IE)
	    {
	      if (tls_segment == NULL)
		{
		  gold_assert(parameters->errors()->error_count() > 0
			      || issue_undefined_symbol_error(gsym));
		  return;
		}
	      this->tls_desc_gd_to_ie(relinfo, relnum, tls_segment, rel, r_type,
				      got_offset, view, view_size);
	      break;
	    }
	  else if (optimized_type == tls::TLSOPT_NONE)
	    {
	      if (r_type == elfcpp::R_386_TLS_GOTDESC)
		{
		  // Relocate the field with the offset of the pair of GOT
		  // entries.
		  Relocate_functions<32, false>::rel32(view, got_offset);
		}
	      break;
	    }
	}
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			     _("unsupported reloc %u"),
			     r_type);
      break;

    case elfcpp::R_386_TLS_LDM:          // Local-dynamic
      if (this->local_dynamic_type_ == LOCAL_DYNAMIC_SUN)
	{
	  gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
				 _("both SUN and GNU model "
				   "TLS relocations"));
	  break;
	}
      this->local_dynamic_type_ = LOCAL_DYNAMIC_GNU;
      if (optimized_type == tls::TLSOPT_TO_LE)
	{
	  if (tls_segment == NULL)
	    {
	      gold_assert(parameters->errors()->error_count() > 0
			  || issue_undefined_symbol_error(gsym));
	      return;
	    }
	  this->tls_ld_to_le(relinfo, relnum, tls_segment, rel, r_type,
			     value, view, view_size);
	  break;
	}
      else if (optimized_type == tls::TLSOPT_NONE)
	{
	  // Relocate the field with the offset of the GOT entry for
	  // the module index.
	  unsigned int got_offset;
	  got_offset = (target->got_mod_index_entry(NULL, NULL, NULL)
			- target->got_size());
	  Relocate_functions<32, false>::rel32(view, got_offset);
	  break;
	}
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			     _("unsupported reloc %u"),
			     r_type);
      break;

    case elfcpp::R_386_TLS_LDO_32:       // Alternate local-dynamic
      if (optimized_type == tls::TLSOPT_TO_LE)
	{
	  // This reloc can appear in debugging sections, in which
	  // case we must not convert to local-exec.  We decide what
	  // to do based on whether the section is marked as
	  // containing executable code.  That is what the GNU linker
	  // does as well.
	  elfcpp::Shdr<32, false> shdr(relinfo->data_shdr);
	  if ((shdr.get_sh_flags() & elfcpp::SHF_EXECINSTR) != 0)
	    {
	      if (tls_segment == NULL)
		{
		  gold_assert(parameters->errors()->error_count() > 0
			      || issue_undefined_symbol_error(gsym));
		  return;
		}
	      value -= tls_segment->memsz();
	    }
	}
      Relocate_functions<32, false>::rel32(view, value);
      break;

    case elfcpp::R_386_TLS_IE:           // Initial-exec
    case elfcpp::R_386_TLS_GOTIE:
    case elfcpp::R_386_TLS_IE_32:
      if (optimized_type == tls::TLSOPT_TO_LE)
	{
	  if (tls_segment == NULL)
	    {
	      gold_assert(parameters->errors()->error_count() > 0
			  || issue_undefined_symbol_error(gsym));
	      return;
	    }
	  Target_i386::Relocate::tls_ie_to_le(relinfo, relnum, tls_segment,
					      rel, r_type, value, view,
					      view_size);
	  break;
	}
      else if (optimized_type == tls::TLSOPT_NONE)
	{
	  // Relocate the field with the offset of the GOT entry for
	  // the tp-relative offset of the symbol.
	  unsigned int got_type = (r_type == elfcpp::R_386_TLS_IE_32
				   ? GOT_TYPE_TLS_OFFSET
				   : GOT_TYPE_TLS_NOFFSET);
	  unsigned int got_offset;
	  if (gsym != NULL)
	    {
	      gold_assert(gsym->has_got_offset(got_type));
	      got_offset = gsym->got_offset(got_type);
	    }
	  else
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
	      gold_assert(object->local_has_got_offset(r_sym, got_type));
	      got_offset = object->local_got_offset(r_sym, got_type);
	    }
	  // For the R_386_TLS_IE relocation, we need to apply the
	  // absolute address of the GOT entry.
	  if (r_type == elfcpp::R_386_TLS_IE)
	    got_offset += target->got_plt_section()->address();
	  // All GOT offsets are relative to the end of the GOT.
	  got_offset -= target->got_size();
	  Relocate_functions<32, false>::rel32(view, got_offset);
	  break;
	}
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			     _("unsupported reloc %u"),
			     r_type);
      break;

    case elfcpp::R_386_TLS_LE:           // Local-exec
      // If we're creating a shared library, a dynamic relocation will
      // have been created for this location, so do not apply it now.
      if (!parameters->options().shared())
	{
	  if (tls_segment == NULL)
	    {
	      gold_assert(parameters->errors()->error_count() > 0
			  || issue_undefined_symbol_error(gsym));
	      return;
	    }
	  value -= tls_segment->memsz();
	  Relocate_functions<32, false>::rel32(view, value);
	}
      break;

    case elfcpp::R_386_TLS_LE_32:
      // If we're creating a shared library, a dynamic relocation will
      // have been created for this location, so do not apply it now.
      if (!parameters->options().shared())
	{
	  if (tls_segment == NULL)
	    {
	      gold_assert(parameters->errors()->error_count() > 0
			  || issue_undefined_symbol_error(gsym));
	      return;
	    }
	  value = tls_segment->memsz() - value;
	  Relocate_functions<32, false>::rel32(view, value);
	}
      break;
    }
}

// Do a relocation in which we convert a TLS General-Dynamic to a
// Local-Exec.

inline void
Target_i386::Relocate::tls_gd_to_le(const Relocate_info<32, false>* relinfo,
				    size_t relnum,
				    Output_segment* tls_segment,
				    const elfcpp::Rel<32, false>& rel,
				    unsigned int,
				    elfcpp::Elf_types<32>::Elf_Addr value,
				    unsigned char* view,
				    section_size_type view_size)
{
  // leal foo(,%reg,1),%eax; call ___tls_get_addr
  //  ==> movl %gs:0,%eax; subl $foo@@tpoff,%eax
  // leal foo(%reg),%eax; call ___tls_get_addr
  //  ==> movl %gs:0,%eax; subl $foo@@tpoff,%eax

  tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, -2);
  tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, 9);

  unsigned char op1 = view[-1];
  unsigned char op2 = view[-2];

  tls::check_tls(relinfo, relnum, rel.get_r_offset(),
		 op2 == 0x8d || op2 == 0x04);
  tls::check_tls(relinfo, relnum, rel.get_r_offset(), view[4] == 0xe8);

  int roff = 5;

  if (op2 == 0x04)
    {
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, -3);
      tls::check_tls(relinfo, relnum, rel.get_r_offset(), view[-3] == 0x8d);
      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
		     ((op1 & 0xc7) == 0x05 && op1 != (4 << 3)));
      memcpy(view - 3, "\x65\xa1\0\0\0\0\x81\xe8\0\0\0", 12);
    }
  else
    {
      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
		     (op1 & 0xf8) == 0x80 && (op1 & 7) != 4);
      if (rel.get_r_offset() + 9 < view_size
	  && view[9] == 0x90)
	{
	  // There is a trailing nop.  Use the size byte subl.
	  memcpy(view - 2, "\x65\xa1\0\0\0\0\x81\xe8\0\0\0", 12);
	  roff = 6;
	}
      else
	{
	  // Use the five byte subl.
	  memcpy(view - 2, "\x65\xa1\0\0\0\0\x2d\0\0\0", 11);
	}
    }

  value = tls_segment->memsz() - value;
  Relocate_functions<32, false>::rel32(view + roff, value);

  // The next reloc should be a PLT32 reloc against __tls_get_addr.
  // We can skip it.
  this->skip_call_tls_get_addr_ = true;
}

// Do a relocation in which we convert a TLS General-Dynamic to an
// Initial-Exec.

inline void
Target_i386::Relocate::tls_gd_to_ie(const Relocate_info<32, false>* relinfo,
				    size_t relnum,
				    Output_segment*,
				    const elfcpp::Rel<32, false>& rel,
				    unsigned int,
				    elfcpp::Elf_types<32>::Elf_Addr value,
				    unsigned char* view,
				    section_size_type view_size)
{
  // leal foo(,%ebx,1),%eax; call ___tls_get_addr
  //  ==> movl %gs:0,%eax; addl foo@@gotntpoff(%ebx),%eax

  tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, -2);
  tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, 9);

  unsigned char op1 = view[-1];
  unsigned char op2 = view[-2];

  tls::check_tls(relinfo, relnum, rel.get_r_offset(),
		 op2 == 0x8d || op2 == 0x04);
  tls::check_tls(relinfo, relnum, rel.get_r_offset(), view[4] == 0xe8);

  int roff = 5;

  // FIXME: For now, support only the first (SIB) form.
  tls::check_tls(relinfo, relnum, rel.get_r_offset(), op2 == 0x04);

  if (op2 == 0x04)
    {
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, -3);
      tls::check_tls(relinfo, relnum, rel.get_r_offset(), view[-3] == 0x8d);
      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
		     ((op1 & 0xc7) == 0x05 && op1 != (4 << 3)));
      memcpy(view - 3, "\x65\xa1\0\0\0\0\x03\x83\0\0\0", 12);
    }
  else
    {
      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
		     (op1 & 0xf8) == 0x80 && (op1 & 7) != 4);
      if (rel.get_r_offset() + 9 < view_size
	  && view[9] == 0x90)
	{
	  // FIXME: This is not the right instruction sequence.
	  // There is a trailing nop.  Use the size byte subl.
	  memcpy(view - 2, "\x65\xa1\0\0\0\0\x81\xe8\0\0\0", 12);
	  roff = 6;
	}
      else
	{
	  // FIXME: This is not the right instruction sequence.
	  // Use the five byte subl.
	  memcpy(view - 2, "\x65\xa1\0\0\0\0\x2d\0\0\0", 11);
	}
    }

  Relocate_functions<32, false>::rel32(view + roff, value);

  // The next reloc should be a PLT32 reloc against __tls_get_addr.
  // We can skip it.
  this->skip_call_tls_get_addr_ = true;
}

// Do a relocation in which we convert a TLS_GOTDESC or TLS_DESC_CALL
// General-Dynamic to a Local-Exec.

inline void
Target_i386::Relocate::tls_desc_gd_to_le(
    const Relocate_info<32, false>* relinfo,
    size_t relnum,
    Output_segment* tls_segment,
    const elfcpp::Rel<32, false>& rel,
    unsigned int r_type,
    elfcpp::Elf_types<32>::Elf_Addr value,
    unsigned char* view,
    section_size_type view_size)
{
  if (r_type == elfcpp::R_386_TLS_GOTDESC)
    {
      // leal foo@@TLSDESC(%ebx), %eax
      // ==> leal foo@@NTPOFF, %eax
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, -2);
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, 4);
      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
		     view[-2] == 0x8d && view[-1] == 0x83);
      view[-1] = 0x05;
      value -= tls_segment->memsz();
      Relocate_functions<32, false>::rel32(view, value);
    }
  else
    {
      // call *foo@@TLSCALL(%eax)
      // ==> nop; nop
      gold_assert(r_type == elfcpp::R_386_TLS_DESC_CALL);
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, 2);
      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
		     view[0] == 0xff && view[1] == 0x10);
      view[0] = 0x66;
      view[1] = 0x90;
    }
}

// Do a relocation in which we convert a TLS_GOTDESC or TLS_DESC_CALL
// General-Dynamic to an Initial-Exec.

inline void
Target_i386::Relocate::tls_desc_gd_to_ie(
    const Relocate_info<32, false>* relinfo,
    size_t relnum,
    Output_segment*,
    const elfcpp::Rel<32, false>& rel,
    unsigned int r_type,
    elfcpp::Elf_types<32>::Elf_Addr value,
    unsigned char* view,
    section_size_type view_size)
{
  if (r_type == elfcpp::R_386_TLS_GOTDESC)
    {
      // leal foo@@TLSDESC(%ebx), %eax
      // ==> movl foo@@GOTNTPOFF(%ebx), %eax
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, -2);
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, 4);
      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
		     view[-2] == 0x8d && view[-1] == 0x83);
      view[-2] = 0x8b;
      Relocate_functions<32, false>::rel32(view, value);
    }
  else
    {
      // call *foo@@TLSCALL(%eax)
      // ==> nop; nop
      gold_assert(r_type == elfcpp::R_386_TLS_DESC_CALL);
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, 2);
      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
		     view[0] == 0xff && view[1] == 0x10);
      view[0] = 0x66;
      view[1] = 0x90;
    }
}

// Do a relocation in which we convert a TLS Local-Dynamic to a
// Local-Exec.

inline void
Target_i386::Relocate::tls_ld_to_le(const Relocate_info<32, false>* relinfo,
				    size_t relnum,
				    Output_segment*,
				    const elfcpp::Rel<32, false>& rel,
				    unsigned int,
				    elfcpp::Elf_types<32>::Elf_Addr,
				    unsigned char* view,
				    section_size_type view_size)
{
  // leal foo(%reg), %eax; call ___tls_get_addr
  // ==> movl %gs:0,%eax; nop; leal 0(%esi,1),%esi

  tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, -2);
  tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, 9);

  // FIXME: Does this test really always pass?
  tls::check_tls(relinfo, relnum, rel.get_r_offset(),
		 view[-2] == 0x8d && view[-1] == 0x83);

  tls::check_tls(relinfo, relnum, rel.get_r_offset(), view[4] == 0xe8);

  memcpy(view - 2, "\x65\xa1\0\0\0\0\x90\x8d\x74\x26\0", 11);

  // The next reloc should be a PLT32 reloc against __tls_get_addr.
  // We can skip it.
  this->skip_call_tls_get_addr_ = true;
}

// Do a relocation in which we convert a TLS Initial-Exec to a
// Local-Exec.

inline void
Target_i386::Relocate::tls_ie_to_le(const Relocate_info<32, false>* relinfo,
				    size_t relnum,
				    Output_segment* tls_segment,
				    const elfcpp::Rel<32, false>& rel,
				    unsigned int r_type,
				    elfcpp::Elf_types<32>::Elf_Addr value,
				    unsigned char* view,
				    section_size_type view_size)
{
  // We have to actually change the instructions, which means that we
  // need to examine the opcodes to figure out which instruction we
  // are looking at.
  if (r_type == elfcpp::R_386_TLS_IE)
    {
      // movl %gs:XX,%eax  ==>  movl $YY,%eax
      // movl %gs:XX,%reg  ==>  movl $YY,%reg
      // addl %gs:XX,%reg  ==>  addl $YY,%reg
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, -1);
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, 4);

      unsigned char op1 = view[-1];
      if (op1 == 0xa1)
	{
	  // movl XX,%eax  ==>  movl $YY,%eax
	  view[-1] = 0xb8;
	}
      else
	{
	  tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, -2);

	  unsigned char op2 = view[-2];
	  if (op2 == 0x8b)
	    {
	      // movl XX,%reg  ==>  movl $YY,%reg
	      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
			     (op1 & 0xc7) == 0x05);
	      view[-2] = 0xc7;
	      view[-1] = 0xc0 | ((op1 >> 3) & 7);
	    }
	  else if (op2 == 0x03)
	    {
	      // addl XX,%reg  ==>  addl $YY,%reg
	      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
			     (op1 & 0xc7) == 0x05);
	      view[-2] = 0x81;
	      view[-1] = 0xc0 | ((op1 >> 3) & 7);
	    }
	  else
	    tls::check_tls(relinfo, relnum, rel.get_r_offset(), 0);
	}
    }
  else
    {
      // subl %gs:XX(%reg1),%reg2  ==>  subl $YY,%reg2
      // movl %gs:XX(%reg1),%reg2  ==>  movl $YY,%reg2
      // addl %gs:XX(%reg1),%reg2  ==>  addl $YY,$reg2
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, -2);
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, 4);

      unsigned char op1 = view[-1];
      unsigned char op2 = view[-2];
      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
		     (op1 & 0xc0) == 0x80 && (op1 & 7) != 4);
      if (op2 == 0x8b)
	{
	  // movl %gs:XX(%reg1),%reg2  ==>  movl $YY,%reg2
	  view[-2] = 0xc7;
	  view[-1] = 0xc0 | ((op1 >> 3) & 7);
	}
      else if (op2 == 0x2b)
	{
	  // subl %gs:XX(%reg1),%reg2  ==>  subl $YY,%reg2
	  view[-2] = 0x81;
	  view[-1] = 0xe8 | ((op1 >> 3) & 7);
	}
      else if (op2 == 0x03)
	{
	  // addl %gs:XX(%reg1),%reg2  ==>  addl $YY,$reg2
	  view[-2] = 0x81;
	  view[-1] = 0xc0 | ((op1 >> 3) & 7);
	}
      else
	tls::check_tls(relinfo, relnum, rel.get_r_offset(), 0);
    }

  value = tls_segment->memsz() - value;
  if (r_type == elfcpp::R_386_TLS_IE || r_type == elfcpp::R_386_TLS_GOTIE)
    value = - value;

  Relocate_functions<32, false>::rel32(view, value);
}

// Relocate section data.

void
Target_i386::relocate_section(const Relocate_info<32, false>* relinfo,
			      unsigned int sh_type,
			      const unsigned char* prelocs,
			      size_t reloc_count,
			      Output_section* output_section,
			      bool needs_special_offset_handling,
			      unsigned char* view,
			      elfcpp::Elf_types<32>::Elf_Addr address,
			      section_size_type view_size,
			      const Reloc_symbol_changes* reloc_symbol_changes)
{
  gold_assert(sh_type == elfcpp::SHT_REL);

  gold::relocate_section<32, false, Target_i386, elfcpp::SHT_REL,
			 Target_i386::Relocate, gold::Default_comdat_behavior>(
    relinfo,
    this,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    view,
    address,
    view_size,
    reloc_symbol_changes);
}

// Return the size of a relocation while scanning during a relocatable
// link.

unsigned int
Target_i386::Relocatable_size_for_reloc::get_size_for_reloc(
    unsigned int r_type,
    Relobj* object)
{
  switch (r_type)
    {
    case elfcpp::R_386_NONE:
    case elfcpp::R_386_GNU_VTINHERIT:
    case elfcpp::R_386_GNU_VTENTRY:
    case elfcpp::R_386_TLS_GD:            // Global-dynamic
    case elfcpp::R_386_TLS_GOTDESC:       // Global-dynamic (from ~oliva url)
    case elfcpp::R_386_TLS_DESC_CALL:
    case elfcpp::R_386_TLS_LDM:           // Local-dynamic
    case elfcpp::R_386_TLS_LDO_32:        // Alternate local-dynamic
    case elfcpp::R_386_TLS_IE:            // Initial-exec
    case elfcpp::R_386_TLS_IE_32:
    case elfcpp::R_386_TLS_GOTIE:
    case elfcpp::R_386_TLS_LE:            // Local-exec
    case elfcpp::R_386_TLS_LE_32:
      return 0;

    case elfcpp::R_386_32:
    case elfcpp::R_386_PC32:
    case elfcpp::R_386_GOT32:
    case elfcpp::R_386_PLT32:
    case elfcpp::R_386_GOTOFF:
    case elfcpp::R_386_GOTPC:
     return 4;

    case elfcpp::R_386_16:
    case elfcpp::R_386_PC16:
      return 2;

    case elfcpp::R_386_8:
    case elfcpp::R_386_PC8:
      return 1;

      // These are relocations which should only be seen by the
      // dynamic linker, and should never be seen here.
    case elfcpp::R_386_COPY:
    case elfcpp::R_386_GLOB_DAT:
    case elfcpp::R_386_JUMP_SLOT:
    case elfcpp::R_386_RELATIVE:
    case elfcpp::R_386_IRELATIVE:
    case elfcpp::R_386_TLS_TPOFF:
    case elfcpp::R_386_TLS_DTPMOD32:
    case elfcpp::R_386_TLS_DTPOFF32:
    case elfcpp::R_386_TLS_TPOFF32:
    case elfcpp::R_386_TLS_DESC:
      object->error(_("unexpected reloc %u in object file"), r_type);
      return 0;

    case elfcpp::R_386_32PLT:
    case elfcpp::R_386_TLS_GD_32:
    case elfcpp::R_386_TLS_GD_PUSH:
    case elfcpp::R_386_TLS_GD_CALL:
    case elfcpp::R_386_TLS_GD_POP:
    case elfcpp::R_386_TLS_LDM_32:
    case elfcpp::R_386_TLS_LDM_PUSH:
    case elfcpp::R_386_TLS_LDM_CALL:
    case elfcpp::R_386_TLS_LDM_POP:
    case elfcpp::R_386_USED_BY_INTEL_200:
    default:
      object->error(_("unsupported reloc %u in object file"), r_type);
      return 0;
    }
}

// Scan the relocs during a relocatable link.

void
Target_i386::scan_relocatable_relocs(Symbol_table* symtab,
				     Layout* layout,
				     Sized_relobj_file<32, false>* object,
				     unsigned int data_shndx,
				     unsigned int sh_type,
				     const unsigned char* prelocs,
				     size_t reloc_count,
				     Output_section* output_section,
				     bool needs_special_offset_handling,
				     size_t local_symbol_count,
				     const unsigned char* plocal_symbols,
				     Relocatable_relocs* rr)
{
  gold_assert(sh_type == elfcpp::SHT_REL);

  typedef gold::Default_scan_relocatable_relocs<elfcpp::SHT_REL,
    Relocatable_size_for_reloc> Scan_relocatable_relocs;

  gold::scan_relocatable_relocs<32, false, elfcpp::SHT_REL,
      Scan_relocatable_relocs>(
    symtab,
    layout,
    object,
    data_shndx,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    local_symbol_count,
    plocal_symbols,
    rr);
}

// Emit relocations for a section.

void
Target_i386::relocate_relocs(
    const Relocate_info<32, false>* relinfo,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    elfcpp::Elf_types<32>::Elf_Off offset_in_output_section,
    const Relocatable_relocs* rr,
    unsigned char* view,
    elfcpp::Elf_types<32>::Elf_Addr view_address,
    section_size_type view_size,
    unsigned char* reloc_view,
    section_size_type reloc_view_size)
{
  gold_assert(sh_type == elfcpp::SHT_REL);

  gold::relocate_relocs<32, false, elfcpp::SHT_REL>(
    relinfo,
    prelocs,
    reloc_count,
    output_section,
    offset_in_output_section,
    rr,
    view,
    view_address,
    view_size,
    reloc_view,
    reloc_view_size);
}

// Return the value to use for a dynamic which requires special
// treatment.  This is how we support equality comparisons of function
// pointers across shared library boundaries, as described in the
// processor specific ABI supplement.

uint64_t
Target_i386::do_dynsym_value(const Symbol* gsym) const
{
  gold_assert(gsym->is_from_dynobj() && gsym->has_plt_offset());
  return this->plt_address_for_global(gsym);
}

// Return a string used to fill a code section with nops to take up
// the specified length.

std::string
Target_i386::do_code_fill(section_size_type length) const
{
  if (length >= 16)
    {
      // Build a jmp instruction to skip over the bytes.
      unsigned char jmp[5];
      jmp[0] = 0xe9;
      elfcpp::Swap_unaligned<32, false>::writeval(jmp + 1, length - 5);
      return (std::string(reinterpret_cast<char*>(&jmp[0]), 5)
	      + std::string(length - 5, static_cast<char>(0x90)));
    }

  // Nop sequences of various lengths.
  const char nop1[1] = { '\x90' };                   // nop
  const char nop2[2] = { '\x66', '\x90' };           // xchg %ax %ax
  const char nop3[3] = { '\x8d', '\x76', '\x00' };   // leal 0(%esi),%esi
  const char nop4[4] = { '\x8d', '\x74', '\x26',     // leal 0(%esi,1),%esi
			 '\x00'};
  const char nop5[5] = { '\x90', '\x8d', '\x74',     // nop
			 '\x26', '\x00' };           // leal 0(%esi,1),%esi
  const char nop6[6] = { '\x8d', '\xb6', '\x00',     // leal 0L(%esi),%esi
			 '\x00', '\x00', '\x00' };
  const char nop7[7] = { '\x8d', '\xb4', '\x26',     // leal 0L(%esi,1),%esi
			 '\x00', '\x00', '\x00',
			 '\x00' };
  const char nop8[8] = { '\x90', '\x8d', '\xb4',     // nop
			 '\x26', '\x00', '\x00',     // leal 0L(%esi,1),%esi
			 '\x00', '\x00' };
  const char nop9[9] = { '\x89', '\xf6', '\x8d',     // movl %esi,%esi
			 '\xbc', '\x27', '\x00',     // leal 0L(%edi,1),%edi
			 '\x00', '\x00', '\x00' };
  const char nop10[10] = { '\x8d', '\x76', '\x00',   // leal 0(%esi),%esi
			   '\x8d', '\xbc', '\x27',   // leal 0L(%edi,1),%edi
			   '\x00', '\x00', '\x00',
			   '\x00' };
  const char nop11[11] = { '\x8d', '\x74', '\x26',   // leal 0(%esi,1),%esi
			   '\x00', '\x8d', '\xbc',   // leal 0L(%edi,1),%edi
			   '\x27', '\x00', '\x00',
			   '\x00', '\x00' };
  const char nop12[12] = { '\x8d', '\xb6', '\x00',   // leal 0L(%esi),%esi
			   '\x00', '\x00', '\x00',   // leal 0L(%edi),%edi
			   '\x8d', '\xbf', '\x00',
			   '\x00', '\x00', '\x00' };
  const char nop13[13] = { '\x8d', '\xb6', '\x00',   // leal 0L(%esi),%esi
			   '\x00', '\x00', '\x00',   // leal 0L(%edi,1),%edi
			   '\x8d', '\xbc', '\x27',
			   '\x00', '\x00', '\x00',
			   '\x00' };
  const char nop14[14] = { '\x8d', '\xb4', '\x26',   // leal 0L(%esi,1),%esi
			   '\x00', '\x00', '\x00',   // leal 0L(%edi,1),%edi
			   '\x00', '\x8d', '\xbc',
			   '\x27', '\x00', '\x00',
			   '\x00', '\x00' };
  const char nop15[15] = { '\xeb', '\x0d', '\x90',   // jmp .+15
			   '\x90', '\x90', '\x90',   // nop,nop,nop,...
			   '\x90', '\x90', '\x90',
			   '\x90', '\x90', '\x90',
			   '\x90', '\x90', '\x90' };

  const char* nops[16] = {
    NULL,
    nop1, nop2, nop3, nop4, nop5, nop6, nop7,
    nop8, nop9, nop10, nop11, nop12, nop13, nop14, nop15
  };

  return std::string(nops[length], length);
}

// Return the value to use for the base of a DW_EH_PE_datarel offset
// in an FDE.  Solaris and SVR4 use DW_EH_PE_datarel because their
// assembler can not write out the difference between two labels in
// different sections, so instead of using a pc-relative value they
// use an offset from the GOT.

uint64_t
Target_i386::do_ehframe_datarel_base() const
{
  gold_assert(this->global_offset_table_ != NULL);
  Symbol* sym = this->global_offset_table_;
  Sized_symbol<32>* ssym = static_cast<Sized_symbol<32>*>(sym);
  return ssym->value();
}

// Return whether SYM should be treated as a call to a non-split
// function.  We don't want that to be true of a call to a
// get_pc_thunk function.

bool
Target_i386::do_is_call_to_non_split(const Symbol* sym, unsigned int) const
{
  return (sym->type() == elfcpp::STT_FUNC
	  && !is_prefix_of("__i686.get_pc_thunk.", sym->name()));
}

// FNOFFSET in section SHNDX in OBJECT is the start of a function
// compiled with -fsplit-stack.  The function calls non-split-stack
// code.  We have to change the function so that it always ensures
// that it has enough stack space to run some random function.

void
Target_i386::do_calls_non_split(Relobj* object, unsigned int shndx,
				       section_offset_type fnoffset,
				       section_size_type fnsize,
				       unsigned char* view,
				       section_size_type view_size,
				       std::string* from,
				       std::string* to) const
{
  // The function starts with a comparison of the stack pointer and a
  // field in the TCB.  This is followed by a jump.

  // cmp %gs:NN,%esp
  if (this->match_view(view, view_size, fnoffset, "\x65\x3b\x25", 3)
      && fnsize > 7)
    {
      // We will call __morestack if the carry flag is set after this
      // comparison.  We turn the comparison into an stc instruction
      // and some nops.
      view[fnoffset] = '\xf9';
      this->set_view_to_nop(view, view_size, fnoffset + 1, 6);
    }
  // lea NN(%esp),%ecx
  // lea NN(%esp),%edx
  else if ((this->match_view(view, view_size, fnoffset, "\x8d\x8c\x24", 3)
	    || this->match_view(view, view_size, fnoffset, "\x8d\x94\x24", 3))
	   && fnsize > 7)
    {
      // This is loading an offset from the stack pointer for a
      // comparison.  The offset is negative, so we decrease the
      // offset by the amount of space we need for the stack.  This
      // means we will avoid calling __morestack if there happens to
      // be plenty of space on the stack already.
      unsigned char* pval = view + fnoffset + 3;
      uint32_t val = elfcpp::Swap_unaligned<32, false>::readval(pval);
      val -= parameters->options().split_stack_adjust_size();
      elfcpp::Swap_unaligned<32, false>::writeval(pval, val);
    }
  else
    {
      if (!object->has_no_split_stack())
	object->error(_("failed to match split-stack sequence at "
			"section %u offset %0zx"),
		      shndx, static_cast<size_t>(fnoffset));
      return;
    }

  // We have to change the function so that it calls
  // __morestack_non_split instead of __morestack.  The former will
  // allocate additional stack space.
  *from = "__morestack";
  *to = "__morestack_non_split";
}

// The selector for i386 object files.  Note this is never instantiated
// directly.  It's only used in Target_selector_i386_nacl, below.

class Target_selector_i386 : public Target_selector_freebsd
{
public:
  Target_selector_i386()
    : Target_selector_freebsd(elfcpp::EM_386, 32, false,
			      "elf32-i386", "elf32-i386-freebsd",
			      "elf_i386")
  { }

  Target*
  do_instantiate_target()
  { return new Target_i386(); }
};

// NaCl variant.  It uses different PLT contents.

class Output_data_plt_i386_nacl : public Output_data_plt_i386
{
 public:
  Output_data_plt_i386_nacl(Layout* layout,
			    Output_data_space* got_plt,
			    Output_data_space* got_irelative)
    : Output_data_plt_i386(layout, plt_entry_size, got_plt, got_irelative)
  { }

 protected:
  virtual unsigned int
  do_get_plt_entry_size() const
  { return plt_entry_size; }

  virtual void
  do_add_eh_frame(Layout* layout)
  {
    layout->add_eh_frame_for_plt(this, plt_eh_frame_cie, plt_eh_frame_cie_size,
				 plt_eh_frame_fde, plt_eh_frame_fde_size);
  }

  // The size of an entry in the PLT.
  static const int plt_entry_size = 64;

  // The .eh_frame unwind information for the PLT.
  static const int plt_eh_frame_fde_size = 32;
  static const unsigned char plt_eh_frame_fde[plt_eh_frame_fde_size];
};

class Output_data_plt_i386_nacl_exec : public Output_data_plt_i386_nacl
{
public:
  Output_data_plt_i386_nacl_exec(Layout* layout,
				 Output_data_space* got_plt,
				 Output_data_space* got_irelative)
    : Output_data_plt_i386_nacl(layout, got_plt, got_irelative)
  { }

 protected:
  virtual void
  do_fill_first_plt_entry(unsigned char* pov,
			  elfcpp::Elf_types<32>::Elf_Addr got_address);

  virtual unsigned int
  do_fill_plt_entry(unsigned char* pov,
		    elfcpp::Elf_types<32>::Elf_Addr got_address,
		    unsigned int got_offset,
		    unsigned int plt_offset,
		    unsigned int plt_rel_offset);

 private:
  // The first entry in the PLT for an executable.
  static const unsigned char first_plt_entry[plt_entry_size];

  // Other entries in the PLT for an executable.
  static const unsigned char plt_entry[plt_entry_size];
};

class Output_data_plt_i386_nacl_dyn : public Output_data_plt_i386_nacl
{
 public:
  Output_data_plt_i386_nacl_dyn(Layout* layout,
				Output_data_space* got_plt,
				Output_data_space* got_irelative)
    : Output_data_plt_i386_nacl(layout, got_plt, got_irelative)
  { }

 protected:
  virtual void
  do_fill_first_plt_entry(unsigned char* pov, elfcpp::Elf_types<32>::Elf_Addr);

  virtual unsigned int
  do_fill_plt_entry(unsigned char* pov,
		    elfcpp::Elf_types<32>::Elf_Addr,
		    unsigned int got_offset,
		    unsigned int plt_offset,
		    unsigned int plt_rel_offset);

 private:
  // The first entry in the PLT for a shared object.
  static const unsigned char first_plt_entry[plt_entry_size];

  // Other entries in the PLT for a shared object.
  static const unsigned char plt_entry[plt_entry_size];
};

class Target_i386_nacl : public Target_i386
{
 public:
  Target_i386_nacl()
    : Target_i386(&i386_nacl_info)
  { }

 protected:
  virtual Output_data_plt_i386*
  do_make_data_plt(Layout* layout,
		   Output_data_space* got_plt,
		   Output_data_space* got_irelative,
		   bool dyn)
  {
    if (dyn)
      return new Output_data_plt_i386_nacl_dyn(layout, got_plt, got_irelative);
    else
      return new Output_data_plt_i386_nacl_exec(layout, got_plt, got_irelative);
  }

  virtual std::string
  do_code_fill(section_size_type length) const;

 private:
  static const Target::Target_info i386_nacl_info;
};

const Target::Target_info Target_i386_nacl::i386_nacl_info =
{
  32,			// size
  false,		// is_big_endian
  elfcpp::EM_386,	// machine_code
  false,		// has_make_symbol
  false,		// has_resolve
  true,			// has_code_fill
  true,			// is_default_stack_executable
  true,			// can_icf_inline_merge_sections
  '\0',			// wrap_char
  "/lib/ld-nacl-x86-32.so.1", // dynamic_linker
  0x20000,		// default_text_segment_address
  0x10000,		// abi_pagesize (overridable by -z max-page-size)
  0x10000,		// common_pagesize (overridable by -z common-page-size)
  true,                 // isolate_execinstr
  0x10000000,           // rosegment_gap
  elfcpp::SHN_UNDEF,	// small_common_shndx
  elfcpp::SHN_UNDEF,	// large_common_shndx
  0,			// small_common_section_flags
  0,			// large_common_section_flags
  NULL,			// attributes_section
  NULL,			// attributes_vendor
  "_start"		// entry_symbol_name
};

#define	NACLMASK	0xe0            // 32-byte alignment mask

const unsigned char
Output_data_plt_i386_nacl_exec::first_plt_entry[plt_entry_size] =
{
  0xff, 0x35,                          // pushl contents of memory address
  0, 0, 0, 0,                          // replaced with address of .got + 4
  0x8b, 0x0d,                          // movl contents of address, %ecx
  0, 0, 0, 0,                          // replaced with address of .got + 8
  0x83, 0xe1, NACLMASK,                // andl $NACLMASK, %ecx
  0xff, 0xe1,                          // jmp *%ecx
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90
};

void
Output_data_plt_i386_nacl_exec::do_fill_first_plt_entry(
    unsigned char* pov,
    elfcpp::Elf_types<32>::Elf_Addr got_address)
{
  memcpy(pov, first_plt_entry, plt_entry_size);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2, got_address + 4);
  elfcpp::Swap<32, false>::writeval(pov + 8, got_address + 8);
}

// The first entry in the PLT for a shared object.

const unsigned char
Output_data_plt_i386_nacl_dyn::first_plt_entry[plt_entry_size] =
{
  0xff, 0xb3, 4, 0, 0, 0,	// pushl 4(%ebx)
  0x8b, 0x4b, 0x08,		// mov 0x8(%ebx), %ecx
  0x83, 0xe1, NACLMASK,         // andl $NACLMASK, %ecx
  0xff, 0xe1,                   // jmp *%ecx
  0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90,  // nops
  0x90, 0x90, 0x90, 0x90, 0x90   // nops
};

void
Output_data_plt_i386_nacl_dyn::do_fill_first_plt_entry(
    unsigned char* pov,
    elfcpp::Elf_types<32>::Elf_Addr)
{
  memcpy(pov, first_plt_entry, plt_entry_size);
}

// Subsequent entries in the PLT for an executable.

const unsigned char
Output_data_plt_i386_nacl_exec::plt_entry[plt_entry_size] =
{
  0x8b, 0x0d,                    // movl contents of address, %ecx */
  0, 0, 0, 0,                    // replaced with address of symbol in .got
  0x83, 0xe1, NACLMASK,          // andl $NACLMASK, %ecx
  0xff, 0xe1,                    // jmp *%ecx

  // Pad to the next 32-byte boundary with nop instructions.
  0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,

  // Lazy GOT entries point here (32-byte aligned).
  0x68,                       // pushl immediate
  0, 0, 0, 0,                 // replaced with offset into relocation table
  0xe9,                       // jmp relative
  0, 0, 0, 0,                 // replaced with offset to start of .plt

  // Pad to the next 32-byte boundary with nop instructions.
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90
};

unsigned int
Output_data_plt_i386_nacl_exec::do_fill_plt_entry(
    unsigned char* pov,
    elfcpp::Elf_types<32>::Elf_Addr got_address,
    unsigned int got_offset,
    unsigned int plt_offset,
    unsigned int plt_rel_offset)
{
  memcpy(pov, plt_entry, plt_entry_size);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2,
					      got_address + got_offset);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 33, plt_rel_offset);
  elfcpp::Swap<32, false>::writeval(pov + 38, - (plt_offset + 38 + 4));
  return 32;
}

// Subsequent entries in the PLT for a shared object.

const unsigned char
Output_data_plt_i386_nacl_dyn::plt_entry[plt_entry_size] =
{
  0x8b, 0x8b,          // movl offset(%ebx), %ecx
  0, 0, 0, 0,          // replaced with offset of symbol in .got
  0x83, 0xe1, 0xe0,    // andl $NACLMASK, %ecx
  0xff, 0xe1,          // jmp *%ecx

  // Pad to the next 32-byte boundary with nop instructions.
  0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,

  // Lazy GOT entries point here (32-byte aligned).
  0x68,                // pushl immediate
  0, 0, 0, 0,          // replaced with offset into relocation table.
  0xe9,                // jmp relative
  0, 0, 0, 0,          // replaced with offset to start of .plt.

  // Pad to the next 32-byte boundary with nop instructions.
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90
};

unsigned int
Output_data_plt_i386_nacl_dyn::do_fill_plt_entry(
    unsigned char* pov,
    elfcpp::Elf_types<32>::Elf_Addr,
    unsigned int got_offset,
    unsigned int plt_offset,
    unsigned int plt_rel_offset)
{
  memcpy(pov, plt_entry, plt_entry_size);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2, got_offset);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 33, plt_rel_offset);
  elfcpp::Swap<32, false>::writeval(pov + 38, - (plt_offset + 38 + 4));
  return 32;
}

const unsigned char
Output_data_plt_i386_nacl::plt_eh_frame_fde[plt_eh_frame_fde_size] =
{
  0, 0, 0, 0,				// Replaced with offset to .plt.
  0, 0, 0, 0,				// Replaced with size of .plt.
  0,					// Augmentation size.
  elfcpp::DW_CFA_def_cfa_offset, 8,	// DW_CFA_def_cfa_offset: 8.
  elfcpp::DW_CFA_advance_loc + 6,	// Advance 6 to __PLT__ + 6.
  elfcpp::DW_CFA_def_cfa_offset, 12,	// DW_CFA_def_cfa_offset: 12.
  elfcpp::DW_CFA_advance_loc + 58,	// Advance 58 to __PLT__ + 64.
  elfcpp::DW_CFA_def_cfa_expression,	// DW_CFA_def_cfa_expression.
  13,					// Block length.
  elfcpp::DW_OP_breg4, 4,		// Push %esp + 4.
  elfcpp::DW_OP_breg8, 0,		// Push %eip.
  elfcpp::DW_OP_const1u, 63,            // Push 0x3f.
  elfcpp::DW_OP_and,			// & (%eip & 0x3f).
  elfcpp::DW_OP_const1u, 37,            // Push 0x25.
  elfcpp::DW_OP_ge,			// >= ((%eip & 0x3f) >= 0x25)
  elfcpp::DW_OP_lit2,			// Push 2.
  elfcpp::DW_OP_shl,			// << (((%eip & 0x3f) >= 0x25) << 2)
  elfcpp::DW_OP_plus,			// + ((((%eip&0x3f)>=0x25)<<2)+%esp+4
  elfcpp::DW_CFA_nop,			// Align to 32 bytes.
  elfcpp::DW_CFA_nop
};

// Return a string used to fill a code section with nops.
// For NaCl, long NOPs are only valid if they do not cross
// bundle alignment boundaries, so keep it simple with one-byte NOPs.
std::string
Target_i386_nacl::do_code_fill(section_size_type length) const
{
  return std::string(length, static_cast<char>(0x90));
}

// The selector for i386-nacl object files.

class Target_selector_i386_nacl
  : public Target_selector_nacl<Target_selector_i386, Target_i386_nacl>
{
 public:
  Target_selector_i386_nacl()
    : Target_selector_nacl<Target_selector_i386,
			   Target_i386_nacl>("x86-32",
					     "elf32-i386-nacl",
					     "elf_i386_nacl")
  { }
};

Target_selector_i386_nacl target_selector_i386;

} // End anonymous namespace.
@


1.155
log
@gold/
	* i386.cc (Target_i386_nacl::do_code_fill): New virtual function.
	* x86_64.cc (Target_x86_64_nacl::do_code_fill): New virtual function.
@
text
@d340 1
a340 1
      rel_irelative_(NULL), copy_relocs_(elfcpp::R_386_COPY), dynbss_(NULL),
a829 2
  // Space for variables copied with a COPY reloc.
  Output_data_space* dynbss_;
@


1.155.2.1
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@d340 1
a340 1
      rel_irelative_(NULL), copy_relocs_(elfcpp::R_386_COPY),
d830 2
@


1.154
log
@    gold/
    	* parameters.cc (Parameters::entry): Return target-specific entry
    	symbol name.
    	* target.h (Target::entry_symbol_name): New function.
    	(Target_info::entry_symbol_name): New data member.

    	* arm.cc (Target_arm::arm_info): Add entry_symbol_name.
    	(Target_arm_nacl::arm_nacl_info): Likewise.
    	* i386.cc (Target_i386::i386_info): Likewise.
    	(Target_i386_nacl::i386_nacl_info): Likewise.
    	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
    	* sparc.cc (Target_sparc::sparc_info): Likewise.
    	* tilegx.cc (Target_tilegx::tilegx_info): Likewise.
    	* x86_64.cc: (Target_x86_64::x86_64_info) Likewise.
    	(Target_x86_64_nacl::x86_64_nacl_info) Likewise.
    	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
@
text
@d3942 3
d4145 9
@


1.153
log
@	* target-reloc.h (relocate_section): If the reloc offset is out of
	range, pass VIEW as NULL to relocate.relocate.
	* arm.cc (Target_arm:Relocate::relocate): Check for a NULL view.
	* i386.cc (Target_i386::Relocate::relocate): Likewise.
	* powerpc.cc (Target_powerpc::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Relocate::relocate): Likewise.
	* tilegx.cc (Target_tilegx::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Relocate::relocate): Likewise.
@
text
@d860 2
a861 1
  NULL			// attributes_vendor
d3968 2
a3969 1
  NULL			// attributes_vendor
@


1.152
log
@gold/
	* i386.cc (Target_i386::relocate_relocs): Remove extraneous typename
	from last change.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
d2664 3
@


1.151
log
@gold/
	* target.h (Sized_target::relocate_relocs): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_relocs): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_relocs): Likewise.
	* powerpc.cc (Target_powerpc::relocate_relocs): Likewise.
	* sparc.cc (Target_sparc::relocate_relocs): Likewise.
	* target-reloc.h (relocate_relocs): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_relocs): Likewise.
	* x86_64.cc (Target_x86_64::relocate_relocs): Likewise.
@
text
@d417 1
a417 2
		  typename elfcpp::Elf_types<32>::Elf_Off
                    offset_in_output_section,
d3620 1
a3620 1
    typename elfcpp::Elf_types<32>::Elf_Off offset_in_output_section,
@


1.150
log
@	* target-reloc.h (class Default_comdat_behavior): New, package up..
	(get_comdat_behaviour): ..this.
	(relocate_section): Add Relocate_comdat_behavior template arg,
	adjust code to suit.
	* arm.cc (Target_arm::relocate_section): Adjust to suit.
	(Target_arm::scan_reloc_section): Likewise.
	* i386.cc (Target_i386::relocate_section): Likewise.
	* sparc.cc (Target_sparc::relocate_section): Likewise.
	* tilegx.cc (Target_tilegx::relocate_section): Likewise.
	* x86_64.cc (Target_x86_64::relocate_section): Likewise.
	* powerpc.cc (class Relocate_comdat_behavior): New.
	(Target_powerpc::relocate_section): Don't zap opd relocs.  Supply
	gold::relocate_section with new template arg.
@
text
@d417 2
a418 1
		  off_t offset_in_output_section,
d3621 1
a3621 1
    off_t offset_in_output_section,
@


1.149
log
@	* i386.cc (Output_data_plt_i386::address_for_global,
	address_for_local): Add plt offset to returned value.  Adjust uses.
	* sparc.cc (Output_data_plt_sparc::address_for_global,
	address_for_local): Likewise.
	* tilegx.cc (Output_data_plt_tilegx::address_for_global,
	address_for_local): Likewise.
	* x86_64.cc (Output_data_plt_x86_64::address_for_global,
	address_for_local): Likewise.
	* target.h (Target::plt_address_for_global, plt_address_for_local):
	Update comment.
	* output.cc (Output_reloc::symbol_value): Don't add plt offset here.
	(Output_data_got::Got_entry::write): Nor here.
	* output.h: Comment fix.
@
text
@d3490 1
a3490 1
			 Target_i386::Relocate>(
@


1.148
log
@	* target-reloc.h (scan_relocs): Call scan.local for relocs
	against symbols in discarded sections.  Pass is_discarded
	param.
	* arm.cc, * i386.cc, * sparc.cc, * x86_64.cc (Target_*::Scan::local):
	Add is_discarded param.
	* powerpc (Target_powerpc::Scan::local): Likewise.  Use
	is_discarded to flag opd entry as discarded.  Don't emit dyn
	relocs on such entries.
	(Target_powerpc::Scan::global): Similarly detect and handle
	such opd entries.
	(Powerpc_relobj): Replace opd_ent_shndx_ and opd_ent_off_ with
	opd_ent_.  Update all uses.
	(Powerpc_relobj::get_opd_discard, set_opd_discard): New functions.
	(Target_powerpc::relocate_section): Zero out discarded opd
	entry relocs.
@
text
@d1154 1
a1154 1
  return this->address() + offset;
d1161 2
a1162 1
Output_data_plt_i386::address_for_local(const Relobj*, unsigned int)
d1164 3
a1166 1
  return this->address() + (this->count_ + 1) * this->get_plt_entry_size();
d2683 1
a2683 2
      symval.set_output_value(target->plt_address_for_global(gsym)
			      + gsym->plt_offset());
d2691 1
a2691 2
	  symval.set_output_value(target->plt_address_for_local(object, r_sym)
				  + object->local_plt_offset(r_sym));
d3653 1
a3653 1
  return this->plt_address_for_global(gsym) + gsym->plt_offset();
@


1.147
log
@	* output.h (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::add_local_pair_with_rel): Remove second
	reloc param.  Expand comment.
	(Output_data_got::Got_entry): Rename use_plt_offset_ to
	use_plt_or_tls_offset_, similarly for constructor param.
	(Output_data_got::Got_entry::write): Add got_index param.
	* output.cc (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::Got_entry::write): Handle tls symbols
	with use_plt_or_tls_offset_ set specially.
	(Output_data_got::add_local_pair_with_rel): Only one reloc.
	(Output_data_got::do_write): Replace iterator with index, pass
	index to entry write function.
	* target.h (Target::tls_offset_for_local, tls_offset_for_global,
	do_tls_offset_for_local, do_tls_offset_for_global): New functions.
	* arm.cc (Target_arm::Scan::local): Update add_local_pair_with_rel
	call.
	* i386.cc (Target_i386::Scan::local): Likewise.
	* sparc.cc (Target_sparc::Scan::local): Likewise.
	* x86_64.cc (Target_x86_64::Scan::local): Likewise.
	* powerpc.cc (Target_powerpc::do_tls_offset_for_local,
	do_tls_offset_for_global): New functions.
	(Target_powerpc::Scan::local): Correct TLS relocations and got
	entry values.
	(Target_powerpc::Scan::global): Don't emit unnecessary
	dynamic relocations on TLS GOT entries.
@
text
@d541 2
a542 1
	  const elfcpp::Sym<32, false>& lsym);
d1706 9
a1714 8
				Layout* layout,
				Target_i386* target,
				Sized_relobj_file<32, false>* object,
				unsigned int data_shndx,
				Output_section* output_section,
				const elfcpp::Rel<32, false>& reloc,
				unsigned int r_type,
				const elfcpp::Sym<32, false>& lsym)
d1716 3
@


1.146
log
@	* object.h (Sized_relobj_file::emit_relocs): Delete.
	(Sized_relobj_file::emit_relocs_reltype): Delete.
	* reloc.cc (Sized_relobj_file::do_relocate_sections): Call target
	relocate_relocs for --emit-relocs.
	(Sized_relobj_file::emit_relocs, emit_relocs_reltype): Delete.
	* output.h: Update comment.
	(Output_segment::first_section): New function.
	(Output_segment::first_section_load_address): Use first_section.
	* output.cc (Output_segment::first_section): New function extracted..
	(Output_segment::first_section_load_address): ..from here.  Delete.
	* target-reloc.h (relocate_for_relocatable): Rename to relocate_relocs.
	* target.h (Sized_target::relocate_for_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise, and
	adjust call to target.h function.
	* i386.cc (Target_i386): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	(Target_powerpc::Scan::local, global): Handle R_POWERPC_TLS.  Ensure
	first tls section has section symbol for optimised local dynamic
	output relocs.
	(Target_powerpc::Relocate::relocate): Correct local dynamic value.
	(Target_powerpc::relocate_relocs): Adjust relocs emitted for
	optimised tls code.
	* testsuite/testfile.cc (Target_test::relocate_for_relocatable):
	Rename to relocate_relocs.  Update error message.
@
text
@d1877 1
a1877 1
					       elfcpp::R_386_TLS_DTPMOD32, 0);
@


1.145
log
@	* configure.ac (ENABLE_GOLD): Consider *-*-nacl* targets ELF.
	* configure: Regenerate.

gold/
	* nacl.cc: New file.
	* nacl.h: New file.
	* Makefile.am (CCFILES, HFILES): Add them.
	* Makefile.in: Regenerate.
	* i386.cc (Output_data_plt_i386_nacl): New class.
	(Output_data_plt_i386_nacl_exec): New class.
	(Output_data_plt_i386_nacl_dyn): New class.
	(Target_i386_nacl): New class.
	(Target_selector_i386_nacl): New class.
	(target_selector_i386): Use it instead of Target_selector_i386.
	* x86_64.cc (Output_data_plt_x86_64_nacl): New class.
	(Target_x86_64_nacl): New class.
	(Target_selector_x86_64_nacl): New class.
	(target_selector_x86_64, target_selector_x32): Use it instead of
	Target_selector_x86_64.
	* arm.cc (Output_data_plt_arm_nacl): New class.
	(Target_arm_nacl): New class.
	(Target_selector_arm_nacl): New class.
	(target_selector_arm, target_selector_armbe): Use it instead of
	Target_selector_arm.

	* target-select.cc (select_target): Take new Input_file* and off_t
	arguments, pass them on to recognize method of selector.
	* object.cc (make_elf_sized_object): Update caller.
	* parameters.cc (parameters_force_valid_target): Likewise.
	* incremental.cc (make_sized_incremental_binary): Likewise.
	* target-select.h: Update decl.
	(Target_selector::recognize): Take new Input_file* argument,
	pass it on to do_recognize.
	(Target_selector::do_recognize): Take new Input_file* argument.
	* freebsd.h (Target_selector_freebsd::do_recognize): Likewise.
	* powerpc.cc (Target_selector_powerpc::do_recognize): Likewise.
	* sparc.cc (Target_selector_sparc::do_recognize): Likewise.
	* testsuite/testfile.cc (Target_selector::do_recognize): Likewise.

	* target.h (Target::Target_info): New members isolate_execinstr
	and rosegment_gap.
	(Target::isolate_execinstr, Target::rosegment_gap): New methods.
	* arm.cc (Target_arm::arm_info): Update initializer.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
	* sparc.cc (Target_sparc::sparc_info): Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
	* layout.cc (Layout::attach_allocated_section_to_segment):
	Take new const Target* argument.  If target->isolate_execinstr(), act
	like --rosegment.
	(Layout::find_first_load_seg): Take new const Target* argument;
	if target->isolate_execinstr(), reject PF_X segments.
	(Layout::relaxation_loop_body): Update caller.
	(Layout::set_segment_offsets): If target->isolate_execinstr(),
	reset file offset to zero when we hit LOAD_SEG, and then do a second
	loop over the segments before LOAD_SEG to reassign offsets after
	addresses have been determined.  Handle target->rosegment_gap().
	(Layout::attach_section_to_segment): Take new const Target* argument;
	pass it to attach_allocated_section_to_segment.
	(Layout::make_output_section): Update caller.
	(Layout::attach_sections_to_segments): Take new const Target* argument;
	pass it to attach_section_to_segment.
	* gold.cc (queue_middle_tasks): Update caller.
	* layout.h (Layout): Update method decls with new arguments.

	* arm.cc (Target_arm::Target_arm): Take optional argument for the
	Target_info pointer to use.
	(Target_arm::do_make_data_plt): New virtual method.
	(Target_arm::make_data_plt): New method that calls it.
	(Target_arm::make_plt_entry): Use it.
	(Output_data_plt_arm::Output_data_plt_arm): Take additional argument
	for the section alignment.
	(Output_data_plt_arm::do_first_plt_entry_offset): New abstract virtual
	method.
	(Output_data_plt_arm::first_plt_entry_offset): Call it.
	(Output_data_plt_arm::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_arm::get_plt_entry_size): Call it.
	(Output_data_plt_arm::do_fill_plt_entry): New abstract virtual method.
	(Output_data_plt_arm::fill_plt_entry): New method that calls it.
	(Output_data_plt_arm::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_arm::fill_first_plt_entry): New method that calls it.
	(Output_data_plt_arm::set_final_data_size): Use get_plt_entry_size
	method instead of sizeof(plt_entry).
	(Output_data_plt_arm::add_entry): Likewise.
	Use first_plt_entry_offset method instead of sizeof(first_plt_entry).
	(Target_arm::first_plt_entry_offset): Call method on this->plt_ rather
	than static method.
	(Target_arm::plt_entry_size): Likewise.
	(Output_data_plt_arm::first_plt_entry, Output_data_plt_arm::plt_entry):
	Move to ...
	(Output_data_plt_arm_standard): ... here, new class.
	(Output_data_plt_arm::do_write): Move guts of PLT filling to...
	(Output_data_plt_arm_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_arm_standard::do_fill_plt_entry): ... and here.

	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Take additional argument for the PLT entry size.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset):
	Use get_plt_entry_size method rather than plt_entry_size variable.
	(Output_data_plt_x86_64::reserve_slot): Likewise.
	(Output_data_plt_x86_64::do_adjust_output_section): Likewise.
	(Output_data_plt_x86_64::add_entry): Likewise.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Likewise.
	(Output_data_plt_x86_64::address_for_global): Likewise.
	(Output_data_plt_x86_64::address_for_local): Likewise.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::first_plt_entry_offset): Likewise.
	Make method non-static.
	(Output_data_plt_x86_64::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_x86_64::get_plt_entry_size): Just call that.
	(Output_data_plt_x86_64::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_x86_64::add_eh_frame): New method to call it.
	(Output_data_plt_x86_64::do_fill_first_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_first_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_tlsdesc_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_tlsdesc_entry): New method to call it.
	(Output_data_plt_x86_64::plt_entry_size)
	(Output_data_plt_x86_64::first_plt_entry)
	(Output_data_plt_x86_64::plt_entry)
	(Output_data_plt_x86_64::tlsdesc_plt_entry)
	(Output_data_plt_x86_64::plt_eh_frame_fde_size)
	(Output_data_plt_x86_64::plt_eh_frame_fde): Move to ...
	(Output_data_plt_x86_64_standard): ... here, new class.
	(Target_x86_64::Target_x86_64): Take optional argument for the
	Target_info pointer to use.
	(Target_x86_64::do_make_data_plt): New virtual method.
	(Target_x86_64::make_data_plt): New method to call it.
	(Target_x86_64::init_got_plt_for_update): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_x86_64::init):	Don't do add_eh_frame_for_plt here.
	(Target_x86_64::first_plt_entry_offset): Call method on this->plt_
	rather than static method.
	(Target_x86_64::plt_entry_size): Likewise.
	(Output_data_plt_x86_64::do_write): Use get_plt_entry_size method
	rather than plt_entry_size variable.  Move guts of PLT filling to...
	(Output_data_plt_x86_64_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_x86_64_standard::do_fill_plt_entry): ... and here ...
	(Output_data_plt_x86_64_standard::do_fill_tlsdesc_entry): ... and here.

	* i386.cc (Output_data_plt_i386::Output_data_plt_i386): Take
	additional argument for the section alignment.
	Don't do add_eh_frame_for_plt here.
	(Output_data_plt_i386::first_plt_entry_offset): Make the method
	non-static.  Use get_plt_entry_size method rather than plt_entry_size
	variable.
	(Output_data_plt_i386::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_i386::get_plt_entry_size): Call it.
	(Output_data_plt_i386::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_i386::add_eh_frame): New method to call it.
	(Output_data_plt_i386::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_first_plt_entry): New method to call it.
	(Output_data_plt_i386::do_fill_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_plt_entry): New method to call it.
	(Output_data_plt_i386::set_final_data_size): Use get_plt_entry_size
	method instead of plt_entry_size.
	(Output_data_plt_i386::plt_entry_size)
	(Output_data_plt_i386::plt_eh_frame_fde_size)
	(Output_data_plt_i386::plt_eh_frame_fde): Move to ...
	(Output_data_plt_i386_standard): ... here, new class.
	(Output_data_plt_i386_exec): New class.
	(Output_data_plt_i386::exec_first_plt_entry): Move to ...
	(Output_data_plt_i386_exec::first_plt_entry): ... here.
	(Output_data_plt_i386::exec_plt_entry): Move to ...
	(Output_data_plt_i386_exec::plt_entry): ... here.
	(Output_data_plt_i386_dyn): New class.
	(Output_data_plt_i386::first_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::first_plt_entry): ... here.
	(Output_data_plt_i386::dyn_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::plt_entry): ... here.
	(Target_i386::Target_i386): Take optional argument for the Target_info
	pointer to use.
	(Target_i386::do_make_data_plt): New virtual method.
	(Target_i386::make_data_plt): New method to call it.
	(Target_i386::make_plt_section): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_i386::add_entry): Use get_plt_entry_size method
	rather than plt_entry_size variable.
	(Output_data_plt_i386::add_local_ifunc_entry): Likewise.
	(Output_data_plt_i386::address_for_local): Likewise.
	(Output_data_plt_i386::do_write): Likewise.
	Move guts of PLT filling to...
	(Output_data_plt_i386_exec::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_i386_exec::do_fill_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_first_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_plt_entry): ... and here.

Change-Id: Id24b95600489835ff5e860a39c147203d4380c2b
@
text
@d410 1
a410 1
  // Relocate a section during a relocatable link.
d412 12
a423 12
  relocate_for_relocatable(const Relocate_info<32, false>*,
			   unsigned int sh_type,
			   const unsigned char* prelocs,
			   size_t reloc_count,
			   Output_section* output_section,
			   off_t offset_in_output_section,
			   const Relocatable_relocs*,
			   unsigned char* view,
			   elfcpp::Elf_types<32>::Elf_Addr view_address,
			   section_size_type view_size,
			   unsigned char* reloc_view,
			   section_size_type reloc_view_size);
d3605 1
a3605 1
// Relocate a section during a relocatable link.
d3608 1
a3608 1
Target_i386::relocate_for_relocatable(
d3624 1
a3624 1
  gold::relocate_for_relocatable<32, false, elfcpp::SHT_REL>(
@


1.145.2.1
log
@gold/
	* target.h (Sized_target::relocate_for_relocatable): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_for_relocatable): Likewise.
	* powerpc.cc (Target_powerpc::relocate_for_relocatable): Likewise.
	* sparc.cc (Target_sparc::relocate_for_relocatable): Likewise.
	* target-reloc.h (relocate_for_relocatable): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_for_relocatable): Likewise.
	* x86_64.cc (Target_x86_64::relocate_for_relocatable): Likewise.
@
text
@d417 1
a417 2
                           typename elfcpp::Elf_types<32>::Elf_Off
                             offset_in_output_section,
d3614 1
a3614 1
    typename elfcpp::Elf_types<32>::Elf_Off offset_in_output_section,
@


1.145.2.2
log
@gold/
	* i386.cc (Target_i386::relocate_for_relocatable): Remove extraneous
	typename from last change.
@
text
@d417 1
a417 1
                           elfcpp::Elf_types<32>::Elf_Off
d3615 1
a3615 1
    elfcpp::Elf_types<32>::Elf_Off offset_in_output_section,
@


1.145.2.3
log
@gold/
	* i386.cc (Target_i386_nacl::do_code_fill): New virtual function.
	* x86_64.cc (Target_x86_64_nacl::do_code_fill): New virtual function.
@
text
@a3932 3
  virtual std::string
  do_code_fill(section_size_type length) const;

a4131 9
// Return a string used to fill a code section with nops.
// For NaCl, long NOPs are only valid if they do not cross
// bundle alignment boundaries, so keep it simple with one-byte NOPs.
std::string
Target_i386_nacl::do_code_fill(section_size_type length) const
{
  return std::string(length, static_cast<char>(0x90));
}

@


1.144
log
@	PR gold/13617
	* i386.cc (Target_i386::do_code_fill): When using a jmp
	instruction, pad with nop instructions.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.
@
text
@d43 1
d52 3
d61 2
a62 1
  Output_data_plt_i386(Layout*, Output_data_space*, Output_data_space*);
d98 1
a98 1
  static unsigned int
d100 1
a100 1
  { return plt_entry_size; }
d103 3
a105 3
  static unsigned int
  get_plt_entry_size()
  { return plt_entry_size; }
d115 5
d121 41
a169 16
 private:
  // The size of an entry in the PLT.
  static const int plt_entry_size = 16;

  // The first entry in the PLT for an executable.
  static const unsigned char exec_first_plt_entry[plt_entry_size];

  // The first entry in the PLT for a shared object.
  static const unsigned char dyn_first_plt_entry[plt_entry_size];

  // Other entries in the PLT for an executable.
  static const unsigned char exec_plt_entry[plt_entry_size];

  // Other entries in the PLT for a shared object.
  static const unsigned char dyn_plt_entry[plt_entry_size];

d171 1
a172 1
  static const int plt_eh_frame_fde_size = 32;
a173 1
  static const unsigned char plt_eh_frame_fde[plt_eh_frame_fde_size];
d175 1
d181 1
a181 1
			* plt_entry_size);
d231 95
d336 2
a337 2
  Target_i386()
    : Sized_target<32, false>(&i386_info),
d344 1
a344 1
  // Process the relocations to determine unreferenced sections for 
d348 10
a357 10
                    Layout* layout,
                    Sized_relobj_file<32, false>* object,
                    unsigned int data_shndx,
                    unsigned int sh_type,
                    const unsigned char* prelocs,
                    size_t reloc_count,
                    Output_section* output_section,
                    bool needs_special_offset_handling,
                    size_t local_symbol_count,
                    const unsigned char* plocal_symbols);
d505 22
d553 5
a557 5
 					Target_i386* target,
	  				Sized_relobj_file<32, false>* object,
	  				unsigned int data_shndx,
	  				Output_section* output_section,
	  				const elfcpp::Rel<32, false>& reloc,
d559 1
a559 1
	  				const elfcpp::Sym<32, false>& lsym);
d564 3
a566 3
	   				 Sized_relobj_file<32, false>* object,
				         unsigned int data_shndx,
	   				 Output_section* output_section,
d569 1
a569 1
			   		 Symbol* gsym);
d607 2
a608 2
                              unsigned int r_type,
                              bool is_32bit,
d625 1
a625 1
                 size_t relnum, const elfcpp::Rel<32, false>&,
d784 1
a784 1
             Sized_relobj_file<32, false>* object,
d852 2
d981 1
d984 2
a985 1
  : Output_section_data(16), layout_(layout), tls_desc_rel_(NULL),
a992 5

  // Add unwind information if requested.
  if (parameters->options().ld_generated_unwind_info())
    layout->add_eh_frame_for_plt(this, plt_eh_frame_cie, plt_eh_frame_cie_size,
				 plt_eh_frame_fde, plt_eh_frame_fde_size);
d1015 1
a1015 1
      gsym->set_plt_offset(this->irelative_count_ * plt_entry_size);
d1032 1
a1032 1
      gsym->set_plt_offset((this->count_ + 1) * plt_entry_size);
d1063 1
a1063 1
  unsigned int plt_offset = this->irelative_count_ * plt_entry_size;
d1152 1
a1152 1
    offset = (this->count_ + 1) * plt_entry_size;
d1162 1
a1162 1
  return this->address() + (this->count_ + 1) * plt_entry_size;
d1167 1
a1167 1
const unsigned char Output_data_plt_i386::exec_first_plt_entry[plt_entry_size] =
d1176 10
d1188 1
a1188 1
const unsigned char Output_data_plt_i386::dyn_first_plt_entry[plt_entry_size] =
d1195 8
d1205 1
a1205 1
const unsigned char Output_data_plt_i386::exec_plt_entry[plt_entry_size] =
d1215 16
d1233 1
a1233 1
const unsigned char Output_data_plt_i386::dyn_plt_entry[plt_entry_size] =
d1243 14
d1279 1
a1279 1
Output_data_plt_i386::plt_eh_frame_fde[plt_eh_frame_fde_size] =
d1332 2
a1333 9
  if (parameters->options().output_is_position_independent())
    memcpy(pov, dyn_first_plt_entry, plt_entry_size);
  else
    {
      memcpy(pov, exec_first_plt_entry, plt_entry_size);
      elfcpp::Swap_unaligned<32, false>::writeval(pov + 2, got_address + 4);
      elfcpp::Swap<32, false>::writeval(pov + 8, got_address + 8);
    }
  pov += plt_entry_size;
d1350 1
a1350 1
  unsigned int plt_offset = plt_entry_size;
d1357 1
a1357 1
	 pov += plt_entry_size,
d1359 1
a1359 1
	 plt_offset += plt_entry_size,
d1364 5
a1368 17

      if (parameters->options().output_is_position_independent())
	{
	  memcpy(pov, dyn_plt_entry, plt_entry_size);
	  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2, got_offset);
	}
      else
	{
	  memcpy(pov, exec_plt_entry, plt_entry_size);
	  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2,
						      (got_address
						       + got_offset));
	}

      elfcpp::Swap_unaligned<32, false>::writeval(pov + 7, plt_rel_offset);
      elfcpp::Swap<32, false>::writeval(pov + 12,
					- (plt_offset + plt_entry_size));
d1371 2
a1372 1
      elfcpp::Swap<32, false>::writeval(got_pov, plt_address + plt_offset + 6);
d1419 10
a1428 2
      this->plt_ = new Output_data_plt_i386(layout, this->got_plt_,
					    this->got_irelative_);
d1484 1
a1484 1
  return Output_data_plt_i386::first_plt_entry_offset();
d1492 1
a1492 1
  return Output_data_plt_i386::get_plt_entry_size();
d1533 1
a1533 1
			         Sized_relobj_file<32, false>* object)
d1542 1
a1542 1
                         got_offset);
d1697 1
a1697 1
               object->name().c_str(), r_type);
d1705 8
a1712 8
			 Layout* layout,
			 Target_i386* target,
			 Sized_relobj_file<32, false>* object,
			 unsigned int data_shndx,
			 Output_section* output_section,
			 const elfcpp::Rel<32, false>& reloc,
			 unsigned int r_type,
			 const elfcpp::Sym<32, false>& lsym)
d1737 3
a1739 3
        {
          Reloc_section* rel_dyn = target->rel_dyn_section(layout);
          unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
d1743 1
a1743 1
        }
d1754 2
a1755 2
        {
          Reloc_section* rel_dyn = target->rel_dyn_section(layout);
d1757 1
a1757 1
          if (lsym.get_st_type() != elfcpp::STT_SECTION)
d1760 3
a1762 3
          else
            {
              gold_assert(lsym.get_st_value() == 0);
d1774 2
a1775 2
            }
        }
d1796 3
a1798 3
        // The symbol requires a GOT entry.
        Output_data_got<32, false>* got = target->got_section(symtab, layout);
        unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
d1808 7
a1814 7
        if (is_new)
          {
            // If we are generating a shared object, we need to add a
            // dynamic RELATIVE relocation for this symbol's GOT entry.
            if (parameters->options().output_is_position_independent())
              {
                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
d1820 2
a1821 2
              }
          }
d1856 1
a1856 1
            = Target_i386::optimize_tls_reloc(!output_is_shared, r_type);
d1862 5
a1866 5
	        // Create a pair of GOT entries for the module index and
	        // dtv-relative offset.
                Output_data_got<32, false>* got
                    = target->got_section(symtab, layout);
                unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
d1873 1
a1873 1
                else
d1885 7
a1891 7
            if (optimized_type == tls::TLSOPT_NONE)
              {
                // Create a double GOT entry with an R_386_TLS_DESC
                // reloc.  The R_386_TLS_DESC reloc is resolved
                // lazily, so the GOT entry needs to be in an area in
                // .got.plt, not .got.  Call got_section to make sure
                // the section has been created.
d1893 2
a1894 2
                Output_data_got<32, false>* got = target->got_tlsdesc_section();
                unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
d1909 3
a1911 3
              }
            else if (optimized_type != tls::TLSOPT_TO_LE)
              unsupported_reloc_local(object, r_type);
d1920 2
a1921 2
	        // Create a GOT entry for the module index.
	        target->got_mod_index_entry(symtab, layout, object);
d1936 26
a1961 26
	        // For the R_386_TLS_IE relocation, we need to create a
	        // dynamic relocation when building a shared library.
	        if (r_type == elfcpp::R_386_TLS_IE
	            && parameters->options().shared())
	          {
                    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                    unsigned int r_sym
                        = elfcpp::elf_r_sym<32>(reloc.get_r_info());
                    rel_dyn->add_local_relative(object, r_sym,
                                                elfcpp::R_386_RELATIVE,
                                                output_section, data_shndx,
                                                reloc.get_r_offset());
	          }
	        // Create a GOT entry for the tp-relative offset.
                Output_data_got<32, false>* got
                    = target->got_section(symtab, layout);
                unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
	        unsigned int dyn_r_type = (r_type == elfcpp::R_386_TLS_IE_32
		                           ? elfcpp::R_386_TLS_TPOFF32
		                           : elfcpp::R_386_TLS_TPOFF);
	        unsigned int got_type = (r_type == elfcpp::R_386_TLS_IE_32
		                         ? GOT_TYPE_TLS_OFFSET
		                         : GOT_TYPE_TLS_NOFFSET);
                got->add_local_with_rel(object, r_sym, got_type,
                                        target->rel_dyn_section(layout),
                                        dyn_r_type);
d1972 9
a1980 9
	        // We need to create a dynamic relocation.
                gold_assert(lsym.get_st_type() != elfcpp::STT_SECTION);
                unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
                unsigned int dyn_r_type = (r_type == elfcpp::R_386_TLS_LE_32
                                           ? elfcpp::R_386_TLS_TPOFF32
                                           : elfcpp::R_386_TLS_TPOFF);
                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                rel_dyn->add_local(object, r_sym, dyn_r_type, output_section,
                                   data_shndx, reloc.get_r_offset());
d2029 1
a2029 1
        return true;
d2071 8
a2078 8
			  Layout* layout,
			  Target_i386* target,
			  Sized_relobj_file<32, false>* object,
			  unsigned int data_shndx,
                          Output_section* output_section,
			  const elfcpp::Rel<32, false>& reloc,
			  unsigned int r_type,
			  Symbol* gsym)
d2096 19
a2114 19
        // Make a PLT entry if necessary.
        if (gsym->needs_plt_entry())
          {
            target->make_plt_entry(symtab, layout, gsym);
            // Since this is not a PC-relative relocation, we may be
            // taking the address of a function. In that case we need to
            // set the entry in the dynamic symbol table to the address of
            // the PLT entry.
            if (gsym->is_from_dynobj() && !parameters->options().shared())
              gsym->set_needs_dynsym_value();
          }
        // Make a dynamic relocation if necessary.
        if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
          {
            if (gsym->may_need_copy_reloc())
              {
	        target->copy_reloc(symtab, layout, object,
	                           data_shndx, output_section, gsym, reloc);
              }
d2133 4
a2136 4
            else if (r_type == elfcpp::R_386_32
                     && gsym->can_use_relative_reloc(false))
              {
                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
d2140 8
a2147 8
              }
            else
              {
                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                rel_dyn->add_global(gsym, r_type, output_section, object,
                                    data_shndx, reloc.get_r_offset());
              }
          }
d2155 28
a2182 28
        // Make a PLT entry if necessary.
        if (gsym->needs_plt_entry())
          {
            // These relocations are used for function calls only in
            // non-PIC code.  For a 32-bit relocation in a shared library,
            // we'll need a text relocation anyway, so we can skip the
            // PLT entry and let the dynamic linker bind the call directly
            // to the target.  For smaller relocations, we should use a
            // PLT entry to ensure that the call can reach.
            if (!parameters->options().shared()
                || r_type != elfcpp::R_386_PC32)
              target->make_plt_entry(symtab, layout, gsym);
          }
        // Make a dynamic relocation if necessary.
        if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
          {
            if (gsym->may_need_copy_reloc())
              {
	        target->copy_reloc(symtab, layout, object,
	                           data_shndx, output_section, gsym, reloc);
              }
            else
              {
                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                rel_dyn->add_global(gsym, r_type, output_section, object,
                                    data_shndx, reloc.get_r_offset());
              }
          }
d2188 3
a2190 3
        // The symbol requires a GOT entry.
        Output_data_got<32, false>* got = target->got_section(symtab, layout);
        if (gsym->final_value_is_known())
d2198 5
a2202 5
        else
          {
            // If this symbol is not fully resolved, we need to add a
            // GOT entry with a dynamic relocation.
            Reloc_section* rel_dyn = target->rel_dyn_section(layout);
d2216 3
a2218 3
            if (gsym->is_from_dynobj()
                || gsym->is_undefined()
                || gsym->is_preemptible()
d2223 4
a2226 4
              got->add_global_with_rel(gsym, GOT_TYPE_STANDARD,
                                       rel_dyn, elfcpp::R_386_GLOB_DAT);
            else
              {
d2242 1
a2242 1
                if (is_new)
d2248 2
a2249 2
              }
          }
d2262 2
a2263 2
          && !gsym->is_from_dynobj()
          && !gsym->is_preemptible())
d2305 1
a2305 1
            = Target_i386::optimize_tls_reloc(is_final, r_type);
d2311 8
a2318 8
	        // Create a pair of GOT entries for the module index and
	        // dtv-relative offset.
                Output_data_got<32, false>* got
                    = target->got_section(symtab, layout);
                got->add_global_pair_with_rel(gsym, GOT_TYPE_TLS_PAIR,
                                             target->rel_dyn_section(layout),
                                             elfcpp::R_386_TLS_DTPMOD32,
                                             elfcpp::R_386_TLS_DTPOFF32);
d2322 6
a2327 6
	        // Create a GOT entry for the tp-relative offset.
                Output_data_got<32, false>* got
                    = target->got_section(symtab, layout);
                got->add_global_with_rel(gsym, GOT_TYPE_TLS_NOFFSET,
                                         target->rel_dyn_section(layout),
                                         elfcpp::R_386_TLS_TPOFF);
d2335 7
a2341 7
            if (optimized_type == tls::TLSOPT_NONE)
              {
                // Create a double GOT entry with an R_386_TLS_DESC
                // reloc.  The R_386_TLS_DESC reloc is resolved
                // lazily, so the GOT entry needs to be in an area in
                // .got.plt, not .got.  Call got_section to make sure
                // the section has been created.
d2343 1
a2343 1
                Output_data_got<32, false>* got = target->got_tlsdesc_section();
d2345 14
a2358 14
                got->add_global_pair_with_rel(gsym, GOT_TYPE_TLS_DESC, rt,
                                             elfcpp::R_386_TLS_DESC, 0);
              }
            else if (optimized_type == tls::TLSOPT_TO_IE)
              {
	        // Create a GOT entry for the tp-relative offset.
                Output_data_got<32, false>* got
                    = target->got_section(symtab, layout);
                got->add_global_with_rel(gsym, GOT_TYPE_TLS_NOFFSET,
                                         target->rel_dyn_section(layout),
                                         elfcpp::R_386_TLS_TPOFF);
              }
            else if (optimized_type != tls::TLSOPT_TO_LE)
              unsupported_reloc_global(object, r_type, gsym);
d2367 2
a2368 2
	        // Create a GOT entry for the module index.
	        target->got_mod_index_entry(symtab, layout, object);
d2383 23
a2405 23
	        // For the R_386_TLS_IE relocation, we need to create a
	        // dynamic relocation when building a shared library.
	        if (r_type == elfcpp::R_386_TLS_IE
	            && parameters->options().shared())
	          {
                    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                    rel_dyn->add_global_relative(gsym, elfcpp::R_386_RELATIVE,
                                                 output_section, object,
                                                 data_shndx,
                                                 reloc.get_r_offset());
	          }
	        // Create a GOT entry for the tp-relative offset.
                Output_data_got<32, false>* got
                    = target->got_section(symtab, layout);
	        unsigned int dyn_r_type = (r_type == elfcpp::R_386_TLS_IE_32
		                           ? elfcpp::R_386_TLS_TPOFF32
		                           : elfcpp::R_386_TLS_TPOFF);
	        unsigned int got_type = (r_type == elfcpp::R_386_TLS_IE_32
		                         ? GOT_TYPE_TLS_OFFSET
		                         : GOT_TYPE_TLS_NOFFSET);
                got->add_global_with_rel(gsym, got_type,
                                         target->rel_dyn_section(layout),
                                         dyn_r_type);
d2416 7
a2422 7
	        // We need to create a dynamic relocation.
                unsigned int dyn_r_type = (r_type == elfcpp::R_386_TLS_LE_32
                                           ? elfcpp::R_386_TLS_TPOFF32
                                           : elfcpp::R_386_TLS_TPOFF);
                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                rel_dyn->add_global(gsym, dyn_r_type, output_section, object,
                                    data_shndx, reloc.get_r_offset());
d2452 10
a2461 10
                               Layout* layout,
                               Sized_relobj_file<32, false>* object,
                               unsigned int data_shndx,
                               unsigned int,
                               const unsigned char* prelocs,
                               size_t reloc_count,
                               Output_section* output_section,
                               bool needs_special_offset_handling,
                               size_t local_symbol_count,
                               const unsigned char* plocal_symbols)
d2464 2
a2465 2
		          Target_i386::Scan,
                          Target_i386::Relocatable_size_for_reloc>(
d2483 10
a2492 10
			 Layout* layout,
			 Sized_relobj_file<32, false>* object,
			 unsigned int data_shndx,
			 unsigned int sh_type,
			 const unsigned char* prelocs,
			 size_t reloc_count,
			 Output_section* output_section,
			 bool needs_special_offset_handling,
			 size_t local_symbol_count,
			 const unsigned char* plocal_symbols)
d2594 2
a2595 2
                                                 unsigned int r_type,
                                                 bool is_32bit,
d2612 2
a2613 2
             && (ref_flags & Symbol::ABSOLUTE_REF)
             && !is_32bit);
d2621 2
a2622 2
                && gsym->can_use_relative_reloc(ref_flags
                                                & Symbol::FUNCTION_CALL);
d2630 10
a2639 10
				Target_i386* target,
				Output_section* output_section,
				size_t relnum,
				const elfcpp::Rel<32, false>& rel,
				unsigned int r_type,
				const Sized_symbol<32>* gsym,
				const Symbol_value<32>* psymval,
				unsigned char* view,
				elfcpp::Elf_types<32>::Elf_Addr address,
				section_size_type view_size)
d2644 1
a2644 1
           && r_type != elfcpp::R_386_PC32)
d2700 5
a2704 5
        {
          gold_assert(gsym->has_got_offset(GOT_TYPE_STANDARD));
          got_offset = (gsym->got_offset(GOT_TYPE_STANDARD)
                        - target->got_size());
        }
d2706 6
a2711 6
        {
          unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
          gold_assert(object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD));
          got_offset = (object->local_got_offset(r_sym, GOT_TYPE_STANDARD)
                        - target->got_size());
        }
d2728 1
a2728 1
        Relocate_functions<32, false>::rel32(view, object, psymval);
d2733 1
a2733 1
        Relocate_functions<32, false>::pcrel32(view, object, psymval, address);
d2738 1
a2738 1
        Relocate_functions<32, false>::rel16(view, object, psymval);
d2743 1
a2743 1
        Relocate_functions<32, false>::pcrel16(view, object, psymval, address);
d2748 1
a2748 1
        Relocate_functions<32, false>::rel8(view, object, psymval);
d2753 1
a2753 1
        Relocate_functions<32, false>::pcrel8(view, object, psymval, address);
d2818 1
a2818 1
                         view, address, view_size);
d2845 1
a2845 1
                                    Target_i386* target,
d2883 15
a2897 15
        {
          unsigned int got_type = (optimized_type == tls::TLSOPT_TO_IE
                                   ? GOT_TYPE_TLS_NOFFSET
                                   : GOT_TYPE_TLS_PAIR);
          unsigned int got_offset;
          if (gsym != NULL)
            {
              gold_assert(gsym->has_got_offset(got_type));
              got_offset = gsym->got_offset(got_type) - target->got_size();
            }
          else
            {
              unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
              gold_assert(object->local_has_got_offset(r_sym, got_type));
              got_offset = (object->local_got_offset(r_sym, got_type)
d2899 2
a2900 2
            }
          if (optimized_type == tls::TLSOPT_TO_IE)
d2903 2
a2904 2
                                 got_offset, view, view_size);
              break;
d2906 8
a2913 8
          else if (optimized_type == tls::TLSOPT_NONE)
            {
              // Relocate the field with the offset of the pair of GOT
              // entries.
              Relocate_functions<32, false>::rel32(view, got_offset);
              break;
            }
        }
d2923 1
a2923 1
        {
d2931 2
a2932 2
			          rel, r_type, value, view,
			          view_size);
d2934 1
a2934 1
        }
d2936 5
a2940 5
        {
          unsigned int got_type = (optimized_type == tls::TLSOPT_TO_IE
                                   ? GOT_TYPE_TLS_NOFFSET
                                   : GOT_TYPE_TLS_DESC);
          unsigned int got_offset = 0;
d2950 10
a2959 10
          if (gsym != NULL)
            {
              gold_assert(gsym->has_got_offset(got_type));
              got_offset += gsym->got_offset(got_type) - target->got_size();
            }
          else
            {
              unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
              gold_assert(object->local_has_got_offset(r_sym, got_type));
              got_offset += (object->local_got_offset(r_sym, got_type)
d2961 2
a2962 2
            }
          if (optimized_type == tls::TLSOPT_TO_IE)
d2971 2
a2972 2
                                      got_offset, view, view_size);
              break;
d2974 11
a2984 11
          else if (optimized_type == tls::TLSOPT_NONE)
            {
              if (r_type == elfcpp::R_386_TLS_GOTDESC)
                {
                  // Relocate the field with the offset of the pair of GOT
                  // entries.
                  Relocate_functions<32, false>::rel32(view, got_offset);
                }
              break;
            }
        }
d3012 5
a3016 5
        {
          // Relocate the field with the offset of the GOT entry for
          // the module index.
          unsigned int got_offset;
          got_offset = (target->got_mod_index_entry(NULL, NULL, NULL)
d3018 3
a3020 3
          Relocate_functions<32, false>::rel32(view, got_offset);
          break;
        }
d3066 3
a3068 3
        {
          // Relocate the field with the offset of the GOT entry for
          // the tp-relative offset of the symbol.
d3070 23
a3092 23
		                   ? GOT_TYPE_TLS_OFFSET
		                   : GOT_TYPE_TLS_NOFFSET);
          unsigned int got_offset;
          if (gsym != NULL)
            {
              gold_assert(gsym->has_got_offset(got_type));
              got_offset = gsym->got_offset(got_type);
            }
          else
            {
              unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
              gold_assert(object->local_has_got_offset(r_sym, got_type));
              got_offset = object->local_got_offset(r_sym, got_type);
            }
          // For the R_386_TLS_IE relocation, we need to apply the
          // absolute address of the GOT entry.
          if (r_type == elfcpp::R_386_TLS_IE)
            got_offset += target->got_plt_section()->address();
          // All GOT offsets are relative to the end of the GOT.
          got_offset -= target->got_size();
          Relocate_functions<32, false>::rel32(view, got_offset);
          break;
        }
d3102 1
a3102 1
        {
d3109 3
a3111 3
          value -= tls_segment->memsz();
          Relocate_functions<32, false>::rel32(view, value);
        }
d3118 1
a3118 1
        {
d3125 3
a3127 3
          value = tls_segment->memsz() - value;
          Relocate_functions<32, false>::rel32(view, value);
        }
d3157 1
a3157 1
                 op2 == 0x8d || op2 == 0x04);
d3167 1
a3167 1
                     ((op1 & 0xc7) == 0x05 && op1 != (4 << 3)));
d3173 1
a3173 1
                     (op1 & 0xf8) == 0x80 && (op1 & 7) != 4);
d3175 1
a3175 1
          && view[9] == 0x90)
d3219 1
a3219 1
                 op2 == 0x8d || op2 == 0x04);
d3232 1
a3232 1
                     ((op1 & 0xc7) == 0x05 && op1 != (4 << 3)));
d3238 1
a3238 1
                     (op1 & 0xf8) == 0x80 && (op1 & 7) != 4);
d3240 1
a3240 1
          && view[9] == 0x90)
d3242 1
a3242 1
          // FIXME: This is not the right instruction sequence.
d3249 1
a3249 1
          // FIXME: This is not the right instruction sequence.
d3283 1
a3283 1
                     view[-2] == 0x8d && view[-1] == 0x83);
d3295 1
a3295 1
                     view[0] == 0xff && view[1] == 0x10);
d3322 1
a3322 1
                     view[-2] == 0x8d && view[-1] == 0x83);
d3333 1
a3333 1
                     view[0] == 0xff && view[1] == 0x10);
d3360 1
a3360 1
                 view[-2] == 0x8d && view[-1] == 0x83);
d3410 1
a3410 1
                             (op1 & 0xc7) == 0x05);
d3418 1
a3418 1
                             (op1 & 0xc7) == 0x05);
d3437 1
a3437 1
                     (op1 & 0xc0) == 0x80 && (op1 & 7) != 4);
d3663 1
a3663 1
              + std::string(length - 5, static_cast<char>(0x90)));
d3673 1
a3673 1
  			 '\x26', '\x00' };           // leal 0(%esi,1),%esi
d3675 1
a3675 1
  			 '\x00', '\x00', '\x00' };
d3677 1
a3677 1
  			 '\x00', '\x00', '\x00',
d3680 1
a3680 1
  			 '\x26', '\x00', '\x00',     // leal 0L(%esi,1),%esi
d3683 1
a3683 1
  			 '\xbc', '\x27', '\x00',     // leal 0L(%edi,1),%edi
d3686 1
a3686 1
  			   '\x8d', '\xbc', '\x27',   // leal 0L(%edi,1),%edi
d3690 1
a3690 1
  			   '\x00', '\x8d', '\xbc',   // leal 0L(%edi,1),%edi
d3694 1
a3694 1
  			   '\x00', '\x00', '\x00',   // leal 0L(%edi),%edi
d3698 1
a3698 1
  			   '\x00', '\x00', '\x00',   // leal 0L(%edi,1),%edi
d3701 1
a3701 1
                           '\x00' };
d3703 1
a3703 1
  			   '\x00', '\x00', '\x00',   // leal 0L(%edi,1),%edi
d3706 1
a3706 1
                           '\x00', '\x00' };
d3708 1
a3708 1
  			   '\x90', '\x90', '\x90',   // nop,nop,nop,...
d3711 1
a3711 1
                           '\x90', '\x90', '\x90' };
d3755 6
a3760 6
				section_offset_type fnoffset,
				section_size_type fnsize,
				unsigned char* view,
				section_size_type view_size,
				std::string* from,
				std::string* to) const
d3807 2
a3808 1
// The selector for i386 object files.
d3824 322
a4145 1
Target_selector_i386 target_selector_i386;
@


1.143
log
@2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d3474 1
a3474 1
              + std::string(length - 5, '\0'));
@


1.142
log
@	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.
@
text
@d3477 45
a3521 36
  const char nop1[1] = { 0x90 };                   // nop
  const char nop2[2] = { 0x66, 0x90 };             // xchg %ax %ax
  const char nop3[3] = { 0x8d, 0x76, 0x00 };       // leal 0(%esi),%esi
  const char nop4[4] = { 0x8d, 0x74, 0x26, 0x00};  // leal 0(%esi,1),%esi
  const char nop5[5] = { 0x90, 0x8d, 0x74, 0x26,   // nop
                         0x00 };                   // leal 0(%esi,1),%esi
  const char nop6[6] = { 0x8d, 0xb6, 0x00, 0x00,   // leal 0L(%esi),%esi
                         0x00, 0x00 };
  const char nop7[7] = { 0x8d, 0xb4, 0x26, 0x00,   // leal 0L(%esi,1),%esi
                         0x00, 0x00, 0x00 };
  const char nop8[8] = { 0x90, 0x8d, 0xb4, 0x26,   // nop
                         0x00, 0x00, 0x00, 0x00 }; // leal 0L(%esi,1),%esi
  const char nop9[9] = { 0x89, 0xf6, 0x8d, 0xbc,   // movl %esi,%esi
                         0x27, 0x00, 0x00, 0x00,   // leal 0L(%edi,1),%edi
                         0x00 };
  const char nop10[10] = { 0x8d, 0x76, 0x00, 0x8d, // leal 0(%esi),%esi
                           0xbc, 0x27, 0x00, 0x00, // leal 0L(%edi,1),%edi
                           0x00, 0x00 };
  const char nop11[11] = { 0x8d, 0x74, 0x26, 0x00, // leal 0(%esi,1),%esi
                           0x8d, 0xbc, 0x27, 0x00, // leal 0L(%edi,1),%edi
                           0x00, 0x00, 0x00 };
  const char nop12[12] = { 0x8d, 0xb6, 0x00, 0x00, // leal 0L(%esi),%esi
                           0x00, 0x00, 0x8d, 0xbf, // leal 0L(%edi),%edi
                           0x00, 0x00, 0x00, 0x00 };
  const char nop13[13] = { 0x8d, 0xb6, 0x00, 0x00, // leal 0L(%esi),%esi
                           0x00, 0x00, 0x8d, 0xbc, // leal 0L(%edi,1),%edi
                           0x27, 0x00, 0x00, 0x00,
                           0x00 };
  const char nop14[14] = { 0x8d, 0xb4, 0x26, 0x00, // leal 0L(%esi,1),%esi
                           0x00, 0x00, 0x00, 0x8d, // leal 0L(%edi,1),%edi
                           0xbc, 0x27, 0x00, 0x00,
                           0x00, 0x00 };
  const char nop15[15] = { 0xeb, 0x0d, 0x90, 0x90, // jmp .+15
                           0x90, 0x90, 0x90, 0x90, // nop,nop,nop,...
                           0x90, 0x90, 0x90, 0x90,
                           0x90, 0x90, 0x90 };
@


1.141
log
@	* i386.cc (class Output_data_plt_i386): Add layout_ field.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize layout_.
	(Output_data_plt_i386::do_write): Write address of .dynamic
	section to first entry in .got.plt section.
	* x86_64.cc (class Output_data_plt_x86_64): Add layout_ field.
	(Output_data_plt_x86_64::Output_data_plt_x86_64) [both versions]:
	Initialize layout_.
	(Output_data_plt_x86_64::do_write): Write address of .dynamic
	section to first entry in .got.plt section.
	* layout.h (Layout::dynamic_section): New function.
@
text
@a2711 6
	      if (tls_segment == NULL)
		{
		  gold_assert(parameters->errors()->error_count() > 0
			      || issue_undefined_symbol_error(gsym));
		  return;
		}
@


1.141.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d2712 6
d3483 36
a3518 45
  const char nop1[1] = { '\x90' };                   // nop
  const char nop2[2] = { '\x66', '\x90' };           // xchg %ax %ax
  const char nop3[3] = { '\x8d', '\x76', '\x00' };   // leal 0(%esi),%esi
  const char nop4[4] = { '\x8d', '\x74', '\x26',     // leal 0(%esi,1),%esi
			 '\x00'};
  const char nop5[5] = { '\x90', '\x8d', '\x74',     // nop
  			 '\x26', '\x00' };           // leal 0(%esi,1),%esi
  const char nop6[6] = { '\x8d', '\xb6', '\x00',     // leal 0L(%esi),%esi
  			 '\x00', '\x00', '\x00' };
  const char nop7[7] = { '\x8d', '\xb4', '\x26',     // leal 0L(%esi,1),%esi
  			 '\x00', '\x00', '\x00',
			 '\x00' };
  const char nop8[8] = { '\x90', '\x8d', '\xb4',     // nop
  			 '\x26', '\x00', '\x00',     // leal 0L(%esi,1),%esi
			 '\x00', '\x00' };
  const char nop9[9] = { '\x89', '\xf6', '\x8d',     // movl %esi,%esi
  			 '\xbc', '\x27', '\x00',     // leal 0L(%edi,1),%edi
			 '\x00', '\x00', '\x00' };
  const char nop10[10] = { '\x8d', '\x76', '\x00',   // leal 0(%esi),%esi
  			   '\x8d', '\xbc', '\x27',   // leal 0L(%edi,1),%edi
			   '\x00', '\x00', '\x00',
			   '\x00' };
  const char nop11[11] = { '\x8d', '\x74', '\x26',   // leal 0(%esi,1),%esi
  			   '\x00', '\x8d', '\xbc',   // leal 0L(%edi,1),%edi
			   '\x27', '\x00', '\x00',
			   '\x00', '\x00' };
  const char nop12[12] = { '\x8d', '\xb6', '\x00',   // leal 0L(%esi),%esi
  			   '\x00', '\x00', '\x00',   // leal 0L(%edi),%edi
			   '\x8d', '\xbf', '\x00',
			   '\x00', '\x00', '\x00' };
  const char nop13[13] = { '\x8d', '\xb6', '\x00',   // leal 0L(%esi),%esi
  			   '\x00', '\x00', '\x00',   // leal 0L(%edi,1),%edi
			   '\x8d', '\xbc', '\x27',
			   '\x00', '\x00', '\x00',
                           '\x00' };
  const char nop14[14] = { '\x8d', '\xb4', '\x26',   // leal 0L(%esi,1),%esi
  			   '\x00', '\x00', '\x00',   // leal 0L(%edi,1),%edi
			   '\x00', '\x8d', '\xbc',
			   '\x27', '\x00', '\x00',
                           '\x00', '\x00' };
  const char nop15[15] = { '\xeb', '\x0d', '\x90',   // jmp .+15
  			   '\x90', '\x90', '\x90',   // nop,nop,nop,...
			   '\x90', '\x90', '\x90',
			   '\x90', '\x90', '\x90',
                           '\x90', '\x90', '\x90' };
@


1.140
log
@	* i386.cc (Target_i386::got_section): If -z now, make .got.plt a
	relro section.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_now_test.
	(relro_now_test_SOURCES): New variable.
	(relro_now_test_DEPENDENCIES): New variable.
	(relro_now_test_LDFLAGS): New variable.
	(relro_now_test_LDADD): New variable.
	(relro_now_test.so): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d169 3
d828 3
a830 3
  : Output_section_data(16), tls_desc_rel_(NULL), irelative_rel_(NULL),
    got_plt_(got_plt), got_irelative_(got_irelative), count_(0),
    irelative_count_(0), global_ifuncs_(), local_ifuncs_()
d1144 10
a1153 2
  memset(got_pov, 0, 12);
  got_pov += 12;
@


1.139
log
@	PR gold/12980
	* i386.cc (Target_i386::Scan::global): For a GOT reloc, use a
	GLOB_DAT relocation rather than a RELATIVE relocation for a
	protected symbol when creating a shared library.
	* x86_64.cc (Target_x86_64::Scan::global): Likewise.
	* testsuite/protected_1.cc (f2, get_f2_addr): New functions.
	* testsuite/protected_main_1.cc (main): Test that protected
	function has same address.
@
text
@d715 11
d729 1
a729 1
				      this->got_, ORDER_RELRO_LAST, true);
d735 2
a736 2
				      this->got_plt_, ORDER_NON_RELRO_FIRST,
				      false);
d741 5
a745 2
      // Those bytes can go into the relro segment.
      layout->increase_relro(3 * 4);
d764 1
a764 1
				      ORDER_NON_RELRO_FIRST, false);
d773 1
a773 1
				      ORDER_NON_RELRO_FIRST, false);
@


1.138
log
@	PR gold/11317
	* target-reloc.h (issue_undefined_symbol_error): New inline
	function, broken out of relocate_section.
	(relocate_section): Call issue_undefined_symbol_error.
	* i386.cc (Target_i386::Relocate::relocate_tls): Don't crash if
	there is no TLS segment if we are about to issue an undefined
	symbol error.
	* x86_64.cc (Target_x86_64::relocate_tls): Likewise.
@
text
@d1988 13
d2004 2
@


1.137
log
@	PR gold/12279
	* resolve.cc (Symbol_table::should_override): Add fromtype
	parameter.  Change all callers.  Give error when linking together
	TLS and non-TLS symbol.
	(Symbol_table::should_override_with_special): Add fromtype
	parameter.  Change all callers.
	* i386.cc (Target_i386::Relocate::relocate_tls): Don't crash if
	there is no TLS segment if we have reported some errors.
	* x86_64.cc (Target_x86_64::relocate_tls): Likewise.
@
text
@d2643 2
a2644 1
	      gold_assert(parameters->errors()->error_count() > 0);
d2674 2
a2675 1
		  gold_assert(parameters->errors()->error_count() > 0);
d2702 2
a2703 1
	      gold_assert(parameters->errors()->error_count() > 0);
d2742 2
a2743 1
		  gold_assert(parameters->errors()->error_count() > 0);
d2779 2
a2780 1
	      gold_assert(parameters->errors()->error_count() > 0);
d2815 2
a2816 1
		  gold_assert(parameters->errors()->error_count() > 0);
d2832 2
a2833 1
	      gold_assert(parameters->errors()->error_count() > 0);
d2881 2
a2882 1
	      gold_assert(parameters->errors()->error_count() > 0);
d2897 2
a2898 1
	      gold_assert(parameters->errors()->error_count() > 0);
@


1.136
log
@	PR gold/12372
	* target.h (Target::plt_address_for_global): New function.
	(Target::plt_address_for_local): New function.
	(Target::plt_section_for_global): Remove.
	(Target::plt_section_for_local): Remove.
	(Target::do_plt_address_for_global): New virtual function.
	(Target::do_plt_address_for_local): New virtual function.
	(Target::do_plt_section_for_global): Remove.
	(Target::do_plt_section_for_local): Remove.
	(Target::register_global_plt_entry): Add Symbol_table and Layout
	parameters.
	* output.cc (Output_data_got::Got_entry::write): Use
	plt_address_for_global and plt_address_for_local.
	* layout.cc (Layout::add_target_dynamic_tags): Use size and
	address of output section.
	* i386.cc (class Output_data_plt_i386): Add irelative_rel_,
	got_irelative_, and irelative_count_ fields.  Update
	declarations.
	(Output_data_plt_i386::has_irelative_section): New function.
	(Output_data_plt_i386::entry_count): Add irelative_count_.
	(Output_data_plt_i386::set_final_data_size): Likewise.
	(class Target_i386): Add got_irelative_ and rel_irelative_
	fields.  Update declarations.
	(Target_i386::Target_i386): Initialize new fields.
	(Target_i386::do_plt_address_for_global): New function replacing
	do_plt_section_for_global.
	(Target_i386::do_plt_address_for_local): New function replacing
	do_plt_section_for_local.
	(Target_i386::got_section): Create got_irelative_.
	(Target_i386::rel_irelative_section): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize new
	fields.  Don't define __rel_iplt_{start,end}.
	(Output_data_plt_i386::add_entry): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): Add symtab and
	layout parameters.  Change all callers.  Use different PLT and
	GOT.
	(Output_data_plt_i386::rel_tls_desc): Fix formatting.
	(Output_data_plt_i386::rel_irelative): New function.
	(Output_data_plt_i386::address_for_global): New function.
	(Output_data_plt_i386::address_for_local): New function.
	(Output_data_plt_i386::do_write): Write out IRELATIVE area.  Use
	IRELATIVE GOT when changing IFUNC GOT entries.
	(Target_i386::Scan::global): Use IRELATIVE GOT for IRELATIVE
	reloc.
	(Target_i386::do_finalize_sections): Create the __rel_iplt symbols
	if we didn't create an IRELATIVE GOT.
	(Target_i386::Relocate::relocate): Use plt_address_for_global and
	plt_address_for_local.
	(Target_i386::do_dynsym_value): Use plt_address_for_global.
	* x86_64.cc (class Output_data_plt_x86_64): Add irelative_rel_,
	got_irelative_, and irelative_count_ fields.  Update
	declarations.
	(Output_data_plt_x86_64::Output_data_plt_x86_64) [both versions]:
	Initialize new fields.  Remove symtab parameter.  Change all
	callers.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset): Add
	irelative_count_.
	(Output_data_plt_x86_64::has_irelative_section): New function.
	(Output_data_plt_x86_64::entry_count): Add irelative_count_.
	(class Target_x86_64): Add got_irelative_ and rel_irelative_
	fields.  Update declarations.
	(Target_x86_64::Target_x86_64): Initialize new fields.
	(Target_x86_64::do_plt_address_for_global): New function replacing
	do_plt_section_for_global.
	(Target_x86_64::do_plt_address_for_local): New function replacing
	do_plt_section_for_local.
	(Target_x86_64::got_section): Create got_irelative_.
	(Target_x86_64::rela_irelative_section): New function.
	(Output_data_plt_x86_64::init): Remove symtab parameter.  Change
	all callers.  Don't create __rel_iplt_{start,end}.
	(Output_data_plt_x86_64::add_entry): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Add symtab and
	layout parameters.  Change all callers.  Use different PLT and
	GOT.
	(Output_data_plt_x86_64::add_relocation): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_x86_64::rela_tlsdesc): Fix formatting.
	(Output_data_plt_x86_64::rela_irelative): New function.
	(Output_data_plt_x86_64::address_for_global): New function.
	(Output_data_plt_x86_64::address_for_local): New function.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::do_write): Write out IRELATIVE area.
	(Target_x86_64::init_got_plt_for_update): Create got_irelative_.
	(Target_x86_64::register_global_plt_entry): Add symtab and layout
	parameters.
	(Target_x86_64::Scan::global): Use IRELATIVE GOT for IRELATIVE
	reloc.
	(Target_x86_64::do_finalize_sections): Create the __rela_iplt
	symbols if we didn't create an IRELATIVE GOT.
	(Target_x86_64::Relocate::relocate): Use plt_address_for_global and
	plt_address_for_local.
	(Target_x86_64::do_dynsym_value): Use plt_address_for_global.
	* testsuite/ifuncvar1.c: New test file.
	* testsuite/ifuncvar2.c: New test file.
	* testsuite/ifuncvar3.c: New test file.
	* testsuite/Makefile.am (check_PROGRAMS): Add ifuncvar.
	(ifuncvar1_pic.o, ifuncvar2_pic.o, ifuncvar.so): New targets.
	(ifuncvar_SOURCES, ifuncvar_DEPENDENCIES): New variables.
	(ifuncvar_LDFLAGS, ifuncvar_LDADD): New variables.
	* testsuite/Makefile.in: Rebuild.
@
text
@d2641 5
a2645 1
	  gold_assert(tls_segment != NULL);
d2671 5
a2675 1
              gold_assert(tls_segment != NULL);
d2698 5
a2702 1
	  gold_assert(tls_segment != NULL);
d2737 5
a2741 1
              gold_assert(tls_segment != NULL);
d2773 5
a2777 1
          gold_assert(tls_segment != NULL);
d2808 5
a2812 1
	      gold_assert(tls_segment != NULL);
d2824 5
a2828 1
          gold_assert(tls_segment != NULL);
d2872 5
a2876 1
          gold_assert(tls_segment != NULL);
d2887 5
a2891 1
          gold_assert(tls_segment != NULL);
@


1.135
log
@	PR gold/12392
	* i386.cc (Target_i386::do_finalize_sections): Define __rel_iplt
	symbols if necessary.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d56 1
a56 1
  Output_data_plt_i386(Symbol_table*, Layout*, Output_data_space*);
d60 1
a60 1
  add_entry(Symbol* gsym);
d64 2
a65 1
  add_local_ifunc_entry(Sized_relobj_file<32, false>* relobj,
d77 9
d89 1
a89 1
  { return this->count_; }
d101 8
d143 4
a146 1
  { this->set_data_size((this->count_ + 1) * plt_entry_size); }
d174 3
d179 2
d183 3
d204 3
a206 3
      got_(NULL), plt_(NULL), got_plt_(NULL), got_tlsdesc_(NULL),
      global_offset_table_(NULL), rel_dyn_(NULL),
      copy_relocs_(elfcpp::R_386_COPY), dynbss_(NULL),
d313 8
a320 8
  // Return the PLT section.
  Output_data*
  do_plt_section_for_global(const Symbol*) const
  { return this->plt_section(); }

  Output_data*
  do_plt_section_for_local(const Relobj*, unsigned int) const
  { return this->plt_section(); }
d621 4
d661 2
d669 2
d743 9
d781 23
d808 6
a813 5
Output_data_plt_i386::Output_data_plt_i386(Symbol_table* symtab,
					   Layout* layout,
					   Output_data_space* got_plt)
  : Output_section_data(16), tls_desc_rel_(NULL), got_plt_(got_plt), count_(0),
    global_ifuncs_(), local_ifuncs_()
a819 18
  if (parameters->doing_static_link())
    {
      // A statically linked executable will only have a .rel.plt
      // section to hold R_386_IRELATIVE relocs for STT_GNU_IFUNC
      // symbols.  The library will use these symbols to locate the
      // IRELATIVE relocs at program startup time.
      symtab->define_in_output_data("__rel_iplt_start", NULL,
				    Symbol_table::PREDEFINED,
				    this->rel_, 0, 0, elfcpp::STT_NOTYPE,
				    elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN,
				    0, false, true);
      symtab->define_in_output_data("__rel_iplt_end", NULL,
				    Symbol_table::PREDEFINED,
				    this->rel_, 0, 0, elfcpp::STT_NOTYPE,
				    elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN,
				    0, true, true);
    }

d837 2
a838 1
Output_data_plt_i386::add_entry(Symbol* gsym)
a841 13
  // Note that when setting the PLT offset we skip the initial
  // reserved PLT entry.
  gsym->set_plt_offset((this->count_ + 1) * plt_entry_size);

  ++this->count_;

  section_offset_type got_offset = this->got_plt_->current_data_size();

  // Every PLT entry needs a GOT entry which points back to the PLT
  // entry (this will be changed by the dynamic linker, normally
  // lazily when the function is called).
  this->got_plt_->set_current_data_size(got_offset + 4);

d846 8
a853 2
      this->rel_->add_symbolless_global_addend(gsym, elfcpp::R_386_IRELATIVE,
					       this->got_plt_, got_offset);
d861 13
d889 2
d894 2
a895 2
  unsigned int plt_offset = (this->count_ + 1) * plt_entry_size;
  ++this->count_;
d897 1
a897 1
  section_offset_type got_offset = this->got_plt_->current_data_size();
d901 1
a901 1
  this->got_plt_->set_current_data_size(got_offset + 4);
d904 4
a907 3
  this->rel_->add_symbolless_local_addend(relobj, local_sym_index,
					  elfcpp::R_386_IRELATIVE,
					  this->got_plt_, got_offset);
d930 2
a931 2
      gold_assert(this->tls_desc_rel_->output_section() ==
		  this->rel_->output_section());
d936 60
d1101 3
d1105 2
a1106 1
    convert_to_section_size_type(this->got_plt_->data_size());
d1135 1
a1135 1
  const unsigned int count = this->count_;
d1172 1
d1180 1
a1180 1
      elfcpp::Swap<32, false>::writeval(got_view + p->got_offset,
d1191 1
a1191 1
      elfcpp::Swap<32, false>::writeval(got_view + p->got_offset,
d1212 2
a1213 1
      this->plt_ = new Output_data_plt_i386(symtab, layout, this->got_plt_);
d1234 1
a1234 1
  this->plt_->add_entry(gsym);
d1248 2
a1249 1
  unsigned int plt_offset = this->plt_->add_local_ifunc_entry(relobj,
d1911 1
a1911 1
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
d2314 2
a2315 1
  if (parameters->doing_static_link() && this->plt_ == NULL)
d2445 1
a2445 1
      symval.set_output_value(target->plt_section()->address()
d2454 1
a2454 1
	  symval.set_output_value(target->plt_section()->address()
d3378 1
a3378 1
  return this->plt_section()->address() + gsym->plt_offset();
@


1.134
log
@	PR gold/12525
	* ehframe.cc (Eh_frame_hdr::get_fde_pc): Handle DW_EH_PE_datarel.
	Assert if we see DW_EH_PE_indirect.
	* target.h (Target::ehframe_datarel_base): New function.
	(Target::do_ehframe_datarel_base): New target function.
	* i386.cc (Target_i386::do_ehframe_datarel_base): New function.
	* x86_64.cc (Target_x86_64::do_ehframe_datarel_base): New
	function.
@
text
@d2184 40
@


1.133
log
@Correct comment in last commit.
@
text
@d298 4
d3274 15
@


1.132
log
@	PR gold/12571
	* options.h (class General_options): Add
	--ld-generated-unwind-info.
	* ehframe.cc (Fde::write): Add address parameter.  Change all
	callers.  If associated with PLT, fill in address and size.
	(Cie::set_output_offset): Only add merge mapping if there is an
	object.
	(Cie::write): Add address parameter.  Change all callers.
	(Eh_frame::add_ehframe_for_plt): New function.
	* ehframe.h (class Fde): Update declarations.  Move shndx_ and
	input_offset_ fields into union u_, with new plt field.
	(Fde::Fde): Adjust for new union field.
	(Fde::Fde) [Output_data version]: New constructor.
	(Fde::add_mapping): Only add merge mapping if there is an object.
	(class Cie): Update declarations.
	(class Eh_frame): Declare add_ehframe_for_plt.
	* layout.cc (Layout::layout_eh_frame): Break out code into
	make_eh_frame_section, and call it.
	(Layout::make_eh_frame_section): New function.
	(Layout::add_eh_frame_for_plt): New function.
	* layout.h (class Layout): Update declarations.
	* merge.cc (Merge_map::add_mapping): Add assertion.
	* i386.cc: Include "dwarf.h".
	(class Output_data_plt_i386): Make first_plt_entry,
	dyn_first_plt_entry, exec_plt_entry, and dyn_plt_entry const.  Add
	plt_eh_frame_cie_size, plt_eh_frame_fde_size, plt_eh_frame_cie,
	and plt_eh_frame_fde.
	(Output_data_plt_i386::Output_data_plt_i386): Align to 16-byte
	boundary.  Call add_eh_frame_for_plt if appropriate.
	* x86_64.cc: Include "dwarf.h".
	(class Output_data_plt_x86_64): Align to 16-byte boundary.  Make
	first_plt_entry, plt_entry and tlsdesc_plt_entry const.  Add
	plt_eh_frame_cie_size, plt_eh_frame_fde_size, plt_eh_frame_cie,
	and plt_eh_frame_fde.
	(Output_data_plt_x86_64::init): Call add_eh_frame_for_plt if
	appropriate.
@
text
@d955 1
a955 1
  elfcpp::DW_OP_plus,			// + ((((%eip&0xf)>=0xb)<<2)+%esp+8
@


1.131
log
@	PR gold/12934
	* target-select.cc (Target_selector::Target_selector): Add
	emulation parameter.  Change all callers.
	(select_target_by_bfd_name): Rename from select_target_by_name.
	Change all callers.
	(select_target_by_emulation): New function.
	(supported_emulation_names): New function.
	* target-select.h (class Target_selector): Add emulation_ field.
	Update declarations.
	(Target_selector::recognize_by_bfd_name): Rename from
	recognize_by_name.  Change all callers.
	(Target_selector::supported_bfd_names): Rename from
	supported_names.  Change all callers.
	(Target_selector::recognize_by_emulation): New function.
	(Target_selector::supported_emulations): New function.
	(Target_selector::emulation): New function.
	(Target_selector::do_recognize_by_bfd_name): Rename from
	do_recognize_by_name.  Change all callers.
	(Target_selector::do_supported_bfd_names): Rename from
	do_supported_names.  Change all callers.
	(Target_selector::do_recognize_by_emulation): New function.
	(Target_selector::do_supported_emulations): New function.
	(select_target_by_bfd_name): Change name in declaration.
	(select_target_by_emulation): Declare.
	(supported_emulation_names): Declare.
	* parameters.cc (parameters_force_valid_target): Try to find
	target based on emulation from -m option.
	* options.h (class General_options): Change doc string for -m.
	* options.cc (help): Print emulations.
	(General_options::parse_V): Likewise.
	* freebsd.h (Target_selector_freebsd::Target_selector_freebsd):
	Add emulation parameter.  Change all callers.
@
text
@d28 1
d105 1
a105 1
  static unsigned char exec_first_plt_entry[plt_entry_size];
d108 1
a108 1
  static unsigned char dyn_first_plt_entry[plt_entry_size];
d111 1
a111 1
  static unsigned char exec_plt_entry[plt_entry_size];
d114 7
a120 1
  static unsigned char dyn_plt_entry[plt_entry_size];
d738 1
a738 1
  : Output_section_data(4), tls_desc_rel_(NULL), got_plt_(got_plt), count_(0),
d763 5
d872 1
a872 1
unsigned char Output_data_plt_i386::exec_first_plt_entry[plt_entry_size] =
d883 1
a883 1
unsigned char Output_data_plt_i386::dyn_first_plt_entry[plt_entry_size] =
d892 1
a892 1
unsigned char Output_data_plt_i386::exec_plt_entry[plt_entry_size] =
d904 1
a904 1
unsigned char Output_data_plt_i386::dyn_plt_entry[plt_entry_size] =
d914 48
@


1.130
log
@	* target.h (class Target): Add osabi_ field.
	(Target::osabi): New function.
	(Target::set_osabi): New function.
	(Target::Target): Initialize osabi_.
	(Target::do_adjust_elf_header): Make pure virtual.
	(Sized_target::do_adjust_elf_header): Declare.
	* target.cc (Sized_target::do_adjust_elf_header): New function.
	(class Sized_target): Instantiate all versions.
	* freebsd.h (class Target_freebsd): Remove.
	(Target_selector_freebsd::do_recognize): Call set_osabi on
	Target.
	(Target_selector_freebsd::do_recognize_by_name): Likewise.
	(Target_selector_freebsd::set_osabi): Remove.
	* i386.cc (class Target_i386): Inherit from Sized_target rather
	than Target_freebsd.
	* x86_64.cc (class Target_x86_64): Likewise.
@
text
@d3287 2
a3288 1
			      "elf32-i386", "elf32-i386-freebsd")
@


1.129
log
@	* target.h (Target::can_check_for_function_pointers): Rewrite.
	Make non-virtual.
	(Target::can_icf_inline_merge_sections): Likewise.
	(Target::section_may_have_icf_unsafe_poineters): Likewise.
	(Target::Target_info): Add can_icf_inline_merge_sections field.
	(Target::do_can_check_for_function_pointers): New virtual
	function.
	(Target::do_section_may_have_icf_unsafe_pointers): Likewise.
	* arm.cc (Target_arm::do_can_check_for_function_pointers): Rename
	from can_check_for_function_pointers, move in file.
	(Target_arm::do_section_may_have_icf_unsafe_pointers): Rename from
	section_may_have_icf_unsafe_poineters, move in file.
	(Target_arm::arm_info): Initialize can_icf_inline_merge_sections.
	* i386.cc (Target_i386::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_i386::can_icf_inline_merge_sections): Remove.
	(Target_i386::i386_info): Initialize
	can_icf_inline_merge_sections.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Initialize can_icf_inline_merge_sections.
	* sparc.cc (Target_sparc::sparc_info) [both version]: Likewise.
	* x86_64.cc (Target_x86_64::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_x86_64::can_icf_inline_merge_sections): Remove.
	(Target_x86_64::x86_64_info): Initialize
	can_icf_inline_merge_sections.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Likewise.
	* icf.cc (get_section_contents): Correct formatting.
@
text
@d161 1
a161 1
class Target_i386 : public Target_freebsd<32, false>
d167 1
a167 1
    : Target_freebsd<32, false>(&i386_info),
@


1.128
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
a173 8
  inline bool
  can_check_for_function_pointers() const
  { return true; }

  virtual bool
  can_icf_inline_merge_sections () const
  { return true; }

d286 5
d642 1
@


1.127
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d63 1
a63 1
  add_local_ifunc_entry(Sized_relobj<32, false>* relobj,
d136 1
a136 1
    Sized_relobj<32, false>* object;
d187 1
a187 1
                    Sized_relobj<32, false>* object,
d201 1
a201 1
	      Sized_relobj<32, false>* object,
d237 1
a237 1
			  Sized_relobj<32, false>* object,
d344 1
a344 1
	  Sized_relobj<32, false>* object,
d352 1
a352 1
	   Sized_relobj<32, false>* object,
d361 1
a361 1
	  				Sized_relobj<32, false>* object,
d371 1
a371 1
	   				 Sized_relobj<32, false>* object,
d382 2
a383 1
    reloc_needs_plt_for_ifunc(Sized_relobj<32, false>*, unsigned int r_type);
d386 1
a386 1
    unsupported_reloc_local(Sized_relobj<32, false>*, unsigned int r_type);
d389 1
a389 1
    unsupported_reloc_global(Sized_relobj<32, false>*, unsigned int r_type,
d556 1
a556 1
			     Sized_relobj<32, false>* relobj,
d566 1
a566 1
		      Sized_relobj<32, false>* object);
d587 1
a587 1
             Sized_relobj<32, false>* object,
d815 3
a817 2
Output_data_plt_i386::add_local_ifunc_entry(Sized_relobj<32, false>* relobj,
					    unsigned int local_sym_index)
d1051 1
a1051 1
					Sized_relobj<32, false>* relobj,
d1127 1
a1127 1
			         Sized_relobj<32, false>* object)
d1273 1
a1273 1
Target_i386::Scan::unsupported_reloc_local(Sized_relobj<32, false>* object,
d1284 3
a1286 2
Target_i386::Scan::reloc_needs_plt_for_ifunc(Sized_relobj<32, false>* object,
					     unsigned int r_type)
d1301 1
a1301 1
			 Sized_relobj<32, false>* object,
d1603 4
a1606 3
Target_i386::Scan::unsupported_reloc_global(Sized_relobj<32, false>* object,
					    unsigned int r_type,
					    Symbol* gsym)
d1636 1
a1636 1
  Sized_relobj<32, false>* ,
d1651 1
a1651 1
  Sized_relobj<32, false>* ,
d1667 1
a1667 1
			  Sized_relobj<32, false>* object,
d2032 1
a2032 1
                               Sized_relobj<32, false>* object,
d2063 1
a2063 1
			 Sized_relobj<32, false>* object,
d2194 1
a2194 1
  const Sized_relobj<32, false>* object = relinfo->object;
d2395 1
a2395 1
  const Sized_relobj<32, false>* object = relinfo->object;
d3073 1
a3073 1
				     Sized_relobj<32, false>* object,
@


1.126
log
@gold/
	* symtab.h (Symbol::NON_PIC_REF): Remove.
	(Symbol::RELATIVE_REF, Symbol::TLS_REF): New Reference_flags.
	(Symbol::FUNCTION_CALL): Renumber.  Reword comment.
	(Symbol::needs_dynamic_reloc): Don't check NON_PIC_REF.
	(Symbol::use_plt_offset): Take a flags argument and pass it
	directly to needs_dynamic_reloc.  Restrict check for undefined
	weak symbols to function calls.
	* arm.cc (Target_arm::Scan::get_reference_flags): New function.
	(Target_arm::Scan::global): Use it.
	(Target_arm::Scan::scan_reloc_for_stub): Likewise.
	(Target_arm::Relocate::relocate): Likewise.
	(Target_arm::Relocate::should_apply_static_reloc): Replace flags
	parameter with an r_type parameter.  Use get_reference_flags
	to get the flags.
	(Target_arm::Relocate::relocate): Update accordingly.
	* i386.cc (Target_i386::Scan::get_reference_flags): New function.
	(Target_i386::Scan::reloc_needs_plt_for_ifunc): Use it.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocate::should_apply_static_reloc): Replace flags
	parameter with an r_type parameter.  Use get_reference_flags
	to get the flags.
	(Target_i386::Relocate::relocate): Update accordingly.
	* powerpc.cc (Target_powerpc::Scan::get_reference_flags): New function.
	(Target_powerpc::Scan::global): Use it.
	(Target_powerpc::Scan::scan_reloc_for_stub): Likewise.
	(Target_powerpc::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Scan::get_reference_flags): New function.
	(Target_sparc::Scan::global): Use it.
	(Target_sparc::Scan::scan_reloc_for_stub): Likewise.
	(Target_sparc::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Scan::get_reference_flags): New function.
	(Target_x86_64::Scan::reloc_needs_plt_for_ifunc): Use it.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
@
text
@d298 1
a298 1
  // Adjust -fstack-split code which calls non-stack-split code.
d3220 1
a3220 1
// compiled with -fstack-split.  The function calls non-stack-split
@


1.125
log
@2010-09-28  Sriraman Tallam  <tmsriram@@google.com>

	* target.h (Target::can_icf_inline_merge_sections): New virtual
	function.
	* x86_64.cc (Target__x86_64::can_icf_inline_merge_sections): New
	virtual function.
	* i386.cc (Target_i386::can_icf_inline_merge_sections): New
	virtual function.
	* icf.cc (get_section_contents): Inline merge sections only when
	target allows it.
@
text
@d338 4
d413 1
a413 1
                              int ref_flags,
d1198 1
a1198 12
// Report an unsupported relocation against a local symbol.

void
Target_i386::Scan::unsupported_reloc_local(Sized_relobj<32, false>* object,
					   unsigned int r_type)
{
  gold_error(_("%s: unsupported reloc %u against local symbol"),
	     object->name().c_str(), r_type);
}

// Return whether we need to make a PLT entry for a relocation of a
// given type against a STT_GNU_IFUNC symbol.
d1200 2
a1201 3
bool
Target_i386::Scan::reloc_needs_plt_for_ifunc(Sized_relobj<32, false>* object,
					     unsigned int r_type)
d1208 3
a1210 1
      return false;
d1215 2
d1220 3
d1224 2
a1225 2
    case elfcpp::R_386_GOTOFF:
    case elfcpp::R_386_GOTPC:
d1227 14
a1240 1
      return true;
a1251 17
      // We will give an error later.
      return false;

    case elfcpp::R_386_TLS_GD:
    case elfcpp::R_386_TLS_GOTDESC:
    case elfcpp::R_386_TLS_DESC_CALL:
    case elfcpp::R_386_TLS_LDM:
    case elfcpp::R_386_TLS_LDO_32:
    case elfcpp::R_386_TLS_IE:
    case elfcpp::R_386_TLS_IE_32:
    case elfcpp::R_386_TLS_GOTIE:
    case elfcpp::R_386_TLS_LE:
    case elfcpp::R_386_TLS_LE_32:
      gold_error(_("%s: unsupported TLS reloc %u for IFUNC symbol"),
		 object->name().c_str(), r_type);
      return false;

d1263 2
a1264 2
      // We will give an error later.
      return false;
d1268 24
d1698 1
a1698 1
        if (gsym->needs_dynamic_reloc(Symbol::ABSOLUTE_REF))
d1759 1
a1759 4
        int flags = Symbol::NON_PIC_REF;
        if (gsym->is_func())
          flags |= Symbol::FUNCTION_CALL;
        if (gsym->needs_dynamic_reloc(flags))
d2128 1
a2128 1
                                                 int ref_flags,
d2138 2
d2197 1
a2197 1
      && gsym->needs_dynamic_reloc(Symbol::ABSOLUTE_REF)
d2207 1
a2207 3
	   && gsym->use_plt_offset(r_type == elfcpp::R_386_PC8
				   || r_type == elfcpp::R_386_PC16
				   || r_type == elfcpp::R_386_PC32))
d2261 1
a2261 2
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
				    output_section))
d2266 2
a2267 7
      {
        int ref_flags = Symbol::NON_PIC_REF;
        if (gsym != NULL && gsym->is_func())
          ref_flags |= Symbol::FUNCTION_CALL;
        if (should_apply_static_reloc(gsym, ref_flags, true, output_section))
          Relocate_functions<32, false>::pcrel32(view, object, psymval, address);
      }
d2271 1
a2271 2
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
d2276 2
a2277 7
      {
        int ref_flags = Symbol::NON_PIC_REF;
        if (gsym != NULL && gsym->is_func())
          ref_flags |= Symbol::FUNCTION_CALL;
        if (should_apply_static_reloc(gsym, ref_flags, false, output_section))
          Relocate_functions<32, false>::pcrel16(view, object, psymval, address);
      }
d2281 1
a2281 2
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
d2286 2
a2287 8
      {
        int ref_flags = Symbol::NON_PIC_REF;
        if (gsym != NULL && gsym->is_func())
          ref_flags |= Symbol::FUNCTION_CALL;
        if (should_apply_static_reloc(gsym, ref_flags, false,
				      output_section))
          Relocate_functions<32, false>::pcrel8(view, object, psymval, address);
      }
@


1.124
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d178 4
@


1.123
log
@	PR 10893
	* i386.cc (class Output_data_plt_i386): Update declarations.
	Define Global_ifunc and Local_ifunc types.  Add global_ifuncs_ and
	local_ifuncs_ fields.
	(Target_i386::do_plt_section_for_global): New function.
	(Target_i386::do_plt_section_for_local): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Add symtab
	parameter; change all callers.  Initialize global_ifuncs_ and
	local_ifuncs_.  If doing a static link define __rel_iplt_start and
	__rel_iplt_end.
	(Output_data_plt_i386::add_entry): Handle IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): New function.
	(Output_data_plt_i386::do_write): Fix GOT entries for IFUNC
	symbols.
	(Target_i386::make_plt_section): New function, broken out of
	make_plt_entry.  Set sh_info field of .rel.plt to point to .plt.
	(Target_i386::make_plt_entry): Call make_plt_section.
	(Target_i386::make_local_ifunc_plt_entry): New function.
	(Target_i386::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_i386::Scan::local): Handle IFUNC symbols.  Add
	R_386_IRELATIVE to switch.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocatable_size_for_reloc): Add R_386_IRELATIVE to
	switch.
	* x86_64.cc (class Output_data_plt_x86_64): Update declarations.
	(Target_x86_64::do_plt_section_for_global): New function.
	(Target_x86_64::do_plt_section_for_local): New function.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Add symtab
	parameter; change all callers.  If doing a static link define
	__rela_iplt_start and __rela_iplt_end.
	(Output_data_plt_x86_64::add_entry): Handle IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): New function.
	(Target_x86_64::make_plt_section): Set sh_info field of .rel.plt
	to point to .plt.
	(Target_x86_64::make_local_ifunc_plt_entry): New function.
	(Target_x86_64::Scan::check_non_pic): Add R_X86_64_IRELATIVE to
	switch.
	(Target_x86_64::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_x86_64::Scan::local): Handle IFUNC symbols.  Add
	R_X86_64_IRELATIVE to switch.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocatable_size_for_reloc): Add R_X86_64_IRELATIVE to
	switch.
	* target.h (class Target): Add plt_section_for_global and
	plt_section_for_local functions.  Add do_plt_section_for_global
	and do_plt_section_for_local virtual functions.
	* symtab.h (Symbol::needs_plt_entry): Handle IFUNC symbol.  Add
	clarifying comments.
	(Symbol::use_plt_offset): Handle IFUNC symbol.
	* object.cc (Sized_relobj::Sized_relobj): Initialize
	local_plt_offsets_.
	(Sized_relobj::local_has_plt_offset): New function.
	(Sized_relobj::local_plt_offset): New function.
	(Sized_relobj::set_local_plt_offset): New function.
	(Sized_relobj::do_count): Handle IFUNC symbol.
	* object.h (class Symbol_value): Add is_ifunc_symbol_ field.  Take
	a bit away from input_shndx_ field.  Add set_is_func_symbol and
	is_ifunc_symbol functions.
	(class Sized_relobj): Update declarations.  Remove Tls_got_entry
	and Local_tls_got_offsets.  Define Local_plt_offsets.  Add
	local_plt_offsets_ field.
	(Sized_relobj::clear_local_symbols): Clear local_plt_offsets_.
	* output.h (class Output_section_data): Add non-const
	output_section function.
	(class Output_data_got): Update declarations.
	(class Output_data_got::Got_entry): Add use_plt_offset_ field.
	Add use_plt_offset parameter to global and local constructors.
	Change all callers.  Change local_sym_index_ field to 31 bits.
	Change GSYM_CODE and CONSTANT_CODE accordingly.
	* output.cc (Output_data_reloc_base::do_adjust_output_section): If
	doing a static link don't set sh_link field.
	(Output_data_got::Got_entry::write): Use PLT offset if
	appropriate.
	(Output_data_got::add_global_plt): New function.
	(Output_data_got::add_local_plt): New function.
	* target-reloc.h (relocate_section): Handle IFUNC symbol.
	* defstd.cc (in_section): Remove entries for __rel_iplt_start,
	__rel_iplt_end, __rela_iplt_start, and __rela_iplt_end.
	* configure.ac: Set IFUNC automake conditional for glibc >= 2.11.
	* testsuite/Makefile.am: Add a bunch of IFUNC tests, all within
	IFUNC conditional.
	* testsuite/ifunc-sel.h: New file.
	* testsuite/ifuncmain1.c: New file.
	* testsuite/ifuncmain1vis.c: New file.
	* testsuite/ifuncmod1.c: New file.
	* testsuite/ifuncdep2.c: New file.
	* testsuite/ifuncmain2.c: New file.
	* testsuite/ifuncmain3.c: New file.
	* testsuite/ifuncmod3.c: New file.
	* testsuite/ifuncmain4.c: New file.
	* testsuite/ifuncmain5.c: New file.
	* testsuite/ifuncmod5.c: New file.
	* testsuite/ifuncmain6pie.c: New file.
	* testsuite/ifuncmod6.c: New file.
	* testsuite/ifuncmain7.c: New file.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d2143 1
a2143 1
				Output_section *output_section,
@


1.122
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_GOT_PLT.

gold/ChangeLog:

	* arm.cc (Target_arm::got_size): Add const.
	(Target_arm::got_entry_count): New function.
	(Target_arm::plt_entry_count): New function.
	(Target_arm::first_plt_entry_offset): New function.
	(Target_arm::plt_entry_size): New function.
	(Output_data_plt_arm::entry_count): New function.
	(Output_data_plt_arm::first_plt_entry_offset): New function.
	(Output_data_plt_arm::get_plt_entry_size): New function.
	* i386.cc (Target_i386::got_size): Add const.
	(Target_i386::got_entry_count): New function.
	(Target_i386::plt_entry_count): New function.
	(Target_i386::first_plt_entry_offset): New function.
	(Target_i386::plt_entry_size): New function.
	(Output_data_plt_i386::entry_count): New function.
	(Output_data_plt_i386::first_plt_entry_offset): New function.
	(Output_data_plt_i386::get_plt_entry_size): New function.
	* incremental-dump.cc (dump_incremental_inputs): Adjust call to
	find_incremental_inputs_sections.  Dump incremental_got_plt section.
	* incremental.cc: Include target.h.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Add
	parameter.  Adjust all callers.  Find incremental_got_plt section.
	(Incremental_inputs::create_data_sections): Create incremental_got_plt
	section.
	(Output_section_incremental_inputs::set_final_data_size): Calculate
	size of incremental_got_plt section.
	(Output_section_incremental_inputs::do_write): Write the
	incremental_got_plt section.
	(Got_plt_view_info): New struct.
	(Local_got_offset_visitor): New class.
	(Global_got_offset_visitor): New class.
	(Global_symbol_visitor_got_plt): New class.
	(Output_section_incremental_inputs::write_got_plt): New function.
	* incremental.h (Incremental_binary::find_incremental_inputs_sections):
	Add parameter.  Adjust all callers.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Incremental_inputs::got_plt_section): New function.
	(Incremental_inputs::got_plt_section_): New data member.
	(Incremental_got_plt_reader): New class.
	* layout.cc (Layout::create_incremental_info_sections): Add the
	incremental_got_plt section.
	* object.h (Got_offset_list::get_list): New function.
	(Got offset_list::for_all_got_offsets): New function.
	(Sized_relobj::local_got_offset_list): New function.
	* powerpc.cc (Target_powerpc::got_size): Add const.
	(Target_powerpc::got_entry_count): New function.
	(Target_powerpc::plt_entry_count): New function.
	(Target_powerpc::first_plt_entry_offset): New function.
	(Target_powerpc::plt_entry_size): New function.
	(Output_data_plt_powerpc::entry_count): New function.
	(Output_data_plt_powerpc::first_plt_entry_offset): New function.
	(Output_data_plt_powerpc::get_plt_entry_size): New function.
	* sparc.cc (Target_sparc::got_size): Add const.
	(Target_sparc::got_entry_count): New function.
	(Target_sparc::plt_entry_count): New function.
	(Target_sparc::first_plt_entry_offset): New function.
	(Target_sparc::plt_entry_size): New function.
	(Output_data_plt_sparc::entry_count): New function.
	(Output_data_plt_sparc::first_plt_entry_offset): New function.
	(Output_data_plt_sparc::get_plt_entry_size): New function.
	* symtab.h (Symbol::got_offset_list): New function.
	(Symbol_table::for_all_symbols): New function.
	* target.h (Sized_target::got_entry_count): New function.
	(Sized_target::plt_entry_count): New function.
	(Sized_target::plt_entry_size): New function.
	* x86_64.cc (Target_x86_64::got_size): Add const.
	(Target_x86_64::got_entry_count): New function.
	(Target_x86_64::plt_entry_count): New function.
	(Target_x86_64::first_plt_entry_offset): New function.
	(Target_x86_64::plt_entry_size): New function.
	(Output_data_plt_x86_64::entry_count): New function.
	(Output_data_plt_x86_64::first_plt_entry_offset): New function.
	(Output_data_plt_x86_64::get_plt_entry_size): New function.
@
text
@d48 107
a154 1
class Output_data_plt_i386;
d281 9
d373 3
d536 4
d544 6
a716 82
// A class to handle the PLT data.

class Output_data_plt_i386 : public Output_section_data
{
 public:
  typedef Output_data_reloc<elfcpp::SHT_REL, true, 32, false> Reloc_section;

  Output_data_plt_i386(Layout*, Output_data_space*);

  // Add an entry to the PLT.
  void
  add_entry(Symbol* gsym);

  // Return the .rel.plt section data.
  const Reloc_section*
  rel_plt() const
  { return this->rel_; }

  // Return where the TLS_DESC relocations should go.
  Reloc_section*
  rel_tls_desc(Layout*);

  // Return the number of PLT entries.
  unsigned int
  entry_count() const
  { return this->count_; }

  // Return the offset of the first non-reserved PLT entry.
  static unsigned int
  first_plt_entry_offset()
  { return plt_entry_size; }

  // Return the size of a PLT entry.
  static unsigned int
  get_plt_entry_size()
  { return plt_entry_size; }

 protected:
  void
  do_adjust_output_section(Output_section* os);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** PLT")); }

 private:
  // The size of an entry in the PLT.
  static const int plt_entry_size = 16;

  // The first entry in the PLT for an executable.
  static unsigned char exec_first_plt_entry[plt_entry_size];

  // The first entry in the PLT for a shared object.
  static unsigned char dyn_first_plt_entry[plt_entry_size];

  // Other entries in the PLT for an executable.
  static unsigned char exec_plt_entry[plt_entry_size];

  // Other entries in the PLT for a shared object.
  static unsigned char dyn_plt_entry[plt_entry_size];

  // Set the final size.
  void
  set_final_data_size()
  { this->set_data_size((this->count_ + 1) * plt_entry_size); }

  // Write out the PLT data.
  void
  do_write(Output_file*);

  // The reloc section.
  Reloc_section* rel_;
  // The TLS_DESC relocations, if necessary.  These must follow the
  // regular PLT relocs.
  Reloc_section* tls_desc_rel_;
  // The .got.plt section.
  Output_data_space* got_plt_;
  // The number of PLT entries.
  unsigned int count_;
};

d721 2
a722 1
Output_data_plt_i386::Output_data_plt_i386(Layout* layout,
d724 2
a725 1
  : Output_section_data(4), tls_desc_rel_(NULL), got_plt_(got_plt), count_(0)
d731 18
d780 16
a795 3
  gsym->set_needs_dynsym_entry();
  this->rel_->add_global(gsym, elfcpp::R_386_JUMP_SLOT, this->got_plt_,
			 got_offset);
d802 30
d970 26
d1003 1
a1003 1
// Create a PLT entry for a global symbol.
d1006 1
a1006 1
Target_i386::make_plt_entry(Symbol_table* symtab, Layout* layout, Symbol* gsym)
a1007 3
  if (gsym->has_plt_offset())
    return;

d1013 1
a1013 1
      this->plt_ = new Output_data_plt_i386(layout, this->got_plt_);
d1018 4
d1023 1
d1025 9
d1037 16
d1200 69
d1282 8
d1308 3
a1310 3
          rel_dyn->add_local_relative(object, r_sym, elfcpp::R_386_RELATIVE,
                                      output_section, data_shndx,
                                      reloc.get_r_offset());
d1367 10
a1376 1
        if (got->add_local(object, r_sym, GOT_TYPE_STANDARD))
d1383 5
a1387 4
                unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
                rel_dyn->add_local_relative(
                    object, r_sym, elfcpp::R_386_RELATIVE, got,
                    object->local_got_offset(r_sym, GOT_TYPE_STANDARD));
d1399 1
d1647 5
d1682 18
d1704 3
a1706 3
                rel_dyn->add_global_relative(gsym, elfcpp::R_386_RELATIVE,
                                             output_section, object,
                                             data_shndx, reloc.get_r_offset());
d1761 7
a1767 1
          got->add_global(gsym, GOT_TYPE_STANDARD);
d1775 3
a1777 1
                || gsym->is_preemptible())
d1782 21
a1802 4
                if (got->add_global(gsym, GOT_TYPE_STANDARD))
                  rel_dyn->add_global_relative(
                      gsym, elfcpp::R_386_RELATIVE, got,
                      gsym->got_offset(GOT_TYPE_STANDARD));
d1835 1
d2168 2
d2173 15
a2187 3
      && gsym->use_plt_offset(r_type == elfcpp::R_386_PC8
			      || r_type == elfcpp::R_386_PC16
			      || r_type == elfcpp::R_386_PC32))
d2193 10
a2202 2

  const Sized_relobj<32, false>* object = relinfo->object;
d2325 1
d3038 1
@


1.121
log
@2010-08-03  Ian Lance Taylor  <iant@@google.com>

	PR 11805
	* layout.h (enum Output_section_order): Define.
	(class Layout): Update declarations.
	* layout.cc (Layout::get_output_section): Add order parameter.
	Remove is_interp, is_dynamic_linker_section, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.  Set order.
	(Layout::default_section_order): New function.
	(Layout::layout_eh_frame): Call add_output_section_to_nonload.
	* output.cc (Output_section::Output_section): Initialize order_.
	Don't initialize deleted fields.
	(Output_segment::Output_segment): Don't initialize deleted
	fields.
	(Output_segment::add_output_section_to_load): New function
	replacing add_output_section.  Change all callers to call this or
	add_output_section_to_nonload.
	(Output_segment::add_output_section_to_nonload): New function.
	(Output_segment::remove_output_section): Rewrite.
	(Output_segment::add_initial_output_data): Likewise.
	(Output_segment::has_any_data_sections): Likewise.
	(Output_segment::is_first_section_relro): Likewise.
	(Output_segment::maximum_alignment): Likewise.
	(Output_segment::has_dynamic_reloc): New function replacing
	dynamic_reloc_count.  Change all callers.
	(Output_segment::has_dynamic_reloc_list): New function replacing
	dynamic_reloc_count_list.  Change all callers.
	(Output_segment::set_section_addresses): Rewrite.
	(Output_segment::set_offset): Rewrite.
	(Output_segment::find_first_and_last_list): Remove.
	(Output_segment::set_tls_offsets): Rewrite.
	(Output_segment::first_section_load_address): Likewise.
	(Output_segment::output_section_count): Likewise.
	(Output_segment::section_with_lowest_load_address): Likewise.
	(Output_segment::write_section_headers): Likewise.
	(Output_segment::print_sections_to_map): Likewise.
	* output.h (class Output_data): Remove dynamic_reloc_count_
	field.  Add has_dynamic_reloc_ field.  Make bools into bitfields.
	(Output_data::add_dynamic_reloc): Rewrite.
	(Output_data::has_dynamic_reloc): New function.
	(Output_data::dynamic_reloc_count): Remove.
	(class Output_section): Add order_ field.  Remvoe is_relro_local_,
	is_last_relro_, is_first_non_relro_, is_interp_,
	is_dynamic_linker_section_ fields.  Add order and set_order
	functions.  Remove is_relro_local, set_is_relro_local,
	is_last_relro, set_is_last_relro, is_first_non_relro,
	set_is_first_non_relro functions, is_interp, set_is_interp,
	is_dynamic_linker_section, and set_is_dynamic_linker_section
	functions.
	(class Output_segment): Change Output_data_list from std::list to
	std:;vector.  Add output_lists_ field.  Remove output_data_ and
	output_bss_ fields.  Update declarations.
@
text
@d188 1
a188 1
  got_size()
d194 21
d465 3
d611 15
d891 26
@


1.120
log
@	* i386.cc (class Target_i386): Add got_tlsdesc_ field.
	(Target_i386::Target_i386):: Initialize got_tlsdesc_.
	(Target_i386::got_tlsdesc_section): New function.
	(Target_i386::got_section): Create space for GOT entries for
	TLSDESC relocations.
	(Target_i386::Scan::local): Use TLSDESC GOT for unoptimized
	R_386_TLS_GOTDESC.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate_tls): Adjust GOT offset when
	using TLSDESC GOT.
	* x86_64.cc (class Target_x86_64): Add got_tlsdesc_ field.
	(Target_x86_64::Target_x86_64):: Initialize got_tlsdesc_.
	(Target_x86_64::got_tlsdesc_section): New function.
	(Target_x86_64::got_section): Create space for GOT entries for
	TLSDESC relocations.
	(Target_x86_64::Scan::local): Use TLSDESC GOT for unoptimized
	R_386_TLS_GOTDESC.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate_tls): Adjust GOT offset when
	using TLSDESC GOT.
@
text
@d511 1
a511 1
				      this->got_, false, true, true, false);
d517 2
a518 2
				      this->got_plt_, false, false, false,
				      true);
d542 2
a543 2
				      this->got_tlsdesc_, false, false, false,
				      true);
d559 2
a560 2
				      elfcpp::SHF_ALLOC, this->rel_dyn_, true,
				      false, false, false);
d642 2
a643 2
				  elfcpp::SHF_ALLOC, this->rel_, true,
				  false, false, false);
d695 1
a695 1
				      true, false, false, false);
d846 1
a846 1
				      this->plt_, false, false, false, false);
@


1.119
log
@	* arm.cc (Target_arm<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* i386.cc (Target_i386<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* x86_64.cc (Target_x86_64<big_endian>::gc_process_relocs): Add template
	parameter to the call to gold::gc_process_relocs.
	* powerpc.cc (Target_powerpc<big_endian>::gc_process_relocs): Add
	template parameter to the call to gold::gc_process_relocs.
	* sparc.cc (Target_sparc<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* gc.h (get_embedded_addend_size): New function.
	(gc_process_relocs): Save the size of the reloc for use by ICF.
	* icf.cc (get_section_contents): Get the addend from the text section
	for SHT_REL relocation sections.
	* icf.h (Icf::Reloc_addend_size_info): New typedef.
	(Icf::Reloc_info): Add new member reloc_addend_size_info.
	* int_encoding.h (read_from_pointer): New overloaded function.
	* testsuite/Makefile.am (icf_sht_rel_addend_test): New test.
	* testsuite/icf_sht_rel_addend_test.sh: New file.
	* testsuite/icf_sht_rel_addend_test_1.cc: New file.
	* testsuite/icf_sht_rel_addend_test_2.cc: New file.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d62 3
a64 2
      got_(NULL), plt_(NULL), got_plt_(NULL), global_offset_table_(NULL),
      rel_dyn_(NULL), copy_relocs_(elfcpp::R_386_COPY), dynbss_(NULL),
d389 8
d459 2
d535 9
d1140 7
a1146 3
                // Create a double GOT entry with an R_386_TLS_DESC reloc.
                Output_data_got<32, false>* got
                    = target->got_section(symtab, layout);
d1528 7
a1534 3
                // Create a double GOT entry with an R_386_TLS_DESC reloc.
                Output_data_got<32, false>* got
                    = target->got_section(symtab, layout);
d2077 10
a2086 1
          unsigned int got_offset;
d2090 1
a2090 1
              got_offset = gsym->got_offset(got_type) - target->got_size();
d2096 2
a2097 2
              got_offset = (object->local_got_offset(r_sym, got_type)
			    - target->got_size());
@


1.118
log
@	* output.h (Output_section_lookup_maps::add_merge_section):
	Correct check of whether value was inserted.
	(Output_section_lookup_maps::add_merge_input_section): Likewise.
	(Output_section_lookup_maps::add_relaxed_input_section):
	Likewise.
	* arm.cc (Target_arm::got_section): Remove used local os.
	* i386.cc (Target_i386::got_section): Likewise.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* sparc.cc (Target_sparc::got_section): Likewise.
	(Target_sparc::relocate): Remove unused local have_got_offset.
	* powerpc.cc (Target_powerpc::relocate): Likewise.
@
text
@d1627 2
a1628 1
		          Target_i386::Scan>(
@


1.117
log
@Adjust last patch--same ChangeLog entry, same e-mail.
@
text
@d497 4
a500 6
      Output_section* os;
      os = layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
					   (elfcpp::SHF_ALLOC
					    | elfcpp::SHF_WRITE),
					   this->got_, false, true, true,
					   false);
d503 5
a507 5
      os = layout->add_output_section_data(".got.plt", elfcpp::SHT_PROGBITS,
					   (elfcpp::SHF_ALLOC
					    | elfcpp::SHF_WRITE),
					   this->got_plt_, false, false, false,
					   true);
@


1.116
log
@	* reloc.cc (Sized_relobj::split_stack_adjust_reltype): Call the
	target to ask whether a reference to a symbol requires a stack
	split.
	* target.h (Target::is_call_to_non_split): New function.
	(Target::do_is_call_to_non_split): Declare virtual function.
	* target.cc: Include "symtab.h".
	(Target::do_is_call_to_non_split): New function.
	* i386.cc (Target_i386::do_is_call_to_non_split): New function.
@
text
@a2790 1
	  && !this->is_defined_by_abi(sym)
@


1.115
log
@	* i386.cc (Target_i386::can_check_for_function_pointers): New function.
	(Scan::possible_function_pointer_reloc): New function.
	(Scan::local_reloc_may_be_function_pointer): Change to call
	possible_function_pointer_reloc.
	(Scan::global_reloc_may_be_function_pointer): Ditto.
	* icf.h (Icf::check_section_for_function_pointers): Change to reject
	relocations in ".data.rel.ro._ZTV" section.
	* testsuite/icf_safe_so_test.sh: Change to pass i386.
	* testsuite/icf_safe_so_test.cc: Ditto.
	* testsuite/icf_safe_test.cc: Ditto.
	* testsuite/icf_safe_test.sh: Ditto.
@
text
@d174 4
d2783 12
@


1.114
log
@2010-02-12  Sriraman Tallam  <tmsriram@@google.com>

	* arm.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* sparc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* powerpc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* i386.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* x86_64.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	(Scan::possible_function_pointer_reloc): New function.
	(Target_x86_64::can_check_for_function_pointers): New function.
	* gc.h (gc_process_relocs): Scan relocation types to determine if
	function pointers were taken for targets that support it.
	* icf.cc (Icf::find_identical_sections): Include functions for
	folding in safe ICF whose pointer is not taken.
	* icf.h (Secn_fptr_taken_set): New typedef.
	(fptr_section_id_): New member.
	(section_has_function_pointers): New function.
	(set_section_has_function_pointers): New function.
	(check_section_for_function_pointers): New function.
	* options.h: Fix comment for safe ICF option.
	* target.h (can_check_for_function_pointers): New function.
	* testsuite/Makefile.am: Add icf_safe_so_test test case.
	Modify icf_safe_test for X86-64.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/icf_safe_so_test.cc: New file.
	* testsuite/icf_safe_so_test.sh: New file.
	* testsuite/icf_safe_test.cc (kept_func_3): New function.
	(main): Change to take pointer to function kept_func_3.
	* testsuite/icf_safe_test.sh (arch_specific_safe_fold): Check if safe
	folding is done correctly for X86-64.
@
text
@d67 4
d210 18
a227 8
    local_reloc_may_be_function_pointer(Symbol_table* , Layout* , Target_i386* ,
		  			Sized_relobj<32, false>* ,
		  			unsigned int ,
		  			Output_section* ,
		  			const elfcpp::Rel<32, false>& ,
	 				unsigned int ,
		  			const elfcpp::Sym<32, false>&)
    { return false; }
d230 1
a230 8
    global_reloc_may_be_function_pointer(Symbol_table* , Layout* ,
					 Target_i386* ,
		   			 Sized_relobj<32, false>* ,
		   			 unsigned int ,
		   			 Output_section* ,
		   			 const elfcpp::Rel<32, false>& ,
					 unsigned int , Symbol*)
    { return false; }
d1244 49
@


1.113
log
@	* i386.cc (Relocate::relocate_tls): A local symbol is final if not
	shared, not if not position independent.
	* x86_64.cc (Relocate::relocate_tls): Likewise.
	* testsuite/Makefile.am (check_PROGRAMS): Add tls_pie_pic_test.
	(tls_pie_pic_test): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d205 20
@


1.112
log
@	* output.h (Output_data_dynamic::add_section_size): New method
	that takes two Output_data objects.
	(Output_data_dynamic::Dynamic_entry): Create storage for secondary
	entry param.  Handle it in initializers.
	* output.cc (Output_data_dynamic::Dynamic_entry::write): For
	DYNAMIC_SECTION_SIZE, add in second object size if non-NULL.
	* layout.h (Layout::add_target_dynamic_tags): Add dynrel_includes_plt
	arg.
	* layout.cc (Layout::add_target_dynamic_tags): If dynrel_includes_plt,
	and .rela.plt exists, set DT_REL{,A}SZ to sum of .rela.dyn and .rela.plt
	* arm.cc (Target_arm::do_finalize_sections): Update to pass false
	for dynrel_includes_plt.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::make_plt_entry): Force .rela.dyn to be output
	before .rela.plt
	(Target_sparc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt.
	* powerpc.cc (Target_powerpc::make_plt_entry): Force .rela.dyn to be
	output before .rela.plt
	(Target_powerpc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt when 32-bit.
@
text
@d1900 3
a1902 4
  const bool is_final =
    (gsym == NULL
     ? !parameters->options().output_is_position_independent()
     : gsym->final_value_is_known());
@


1.111
log
@	PR 10287
	PR 11063
	* i386.cc (class Target_i386): Change return type of plt_section
	to be non-const.
	(class Output_data_plt_i386): Add tls_desc_rel_ field.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize
	tls_desc_rel_ field.
	(Output_data_plt_i386::rel_tls_desc): New function.
	(Target_i386::rel_tls_desc_section): New function.
	(Target_i386::Scan::local): Rewrite R_386_TLS_GOTDESC handling.
	(Target_i386::Scan::global): For R_386_TLS_GOTDESC put
	R_386_TLS_DESC reloc in rel_tls_desc_section.
	* x86_64.cc (class Target_x86_64): Add tlsdesc_reloc_info_ field.
	Define struct Tlsdesc_info.
	(Target_x86_64::Target_x86_64): Initialize tlsdesc_reloc_info_.
	(Target_x86_64::do_reloc_symbol_index): New function.
	(Target_x86_64::add_tlsdesc_info): New function.
	(class Output_data_plt_x86_64): Add tlsdesc_rel_ field.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Initialize
	tlsdesc_rel_ field.
	(Output_data_plt_x86_64::rela_plt): Rename from rel_plt.  Change
	all callers.
	(Output_data_plt_x86_64::rela_tlsdesc): New function.
	(Target_x86_64::rela_tlsdesc_section): New function.
	(Target_x86_64::Scan::local): Rewrite R_X86_64_GOTPC32_TLSDESC
	handling.
	(Target_x86_64::Scan::global): For R_X86_64_GOTPC32_TLSDESC put
	(Target_x86_64::do_reloc_addend): New function.
	R_X86_64_TLSDESC reloc in rela_tlsdesc_section.
	* output.h (class Output_reloc) [SHT_REL]: Add new constructor
	declarations.  Define TARGET_CODE.  Add arg field to u1_ union.
	(Output_reloc::type): New function.
	(Output_reloc::is_local_section_symbol): Check for TARGET_CODE.
	(Output_reloc::is_target_specific): New function.
	(Output_reloc::target_arg): New function.
	(class Output_reloc) [SHT_RELA]: Add four new constructors for
	absolute relocs and target specific relocs.
	(class Output_data_reloc) [SHT_REL]: Add add_absolute and
	add_target_specific.
	(class Output_data_reloc) [SHT_RELA]: Likewise.
	* output.cc (Output_reloc::Output_reloc): Add four new versions
	for absolute relocs and target specific relocs.
	(Output_reloc::set_needs_dynsym_index): Add TARGET_CODE case.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Check that local_sym_index_
	is not TARGET_CODE or 0.
	(Output_reloc::symbol_value): Likewise.
	(Output_reloc::write) [SHT_RELA]: Call target for target specific
	reloc.
	* target.h (class Target): Add reloc_symbol_index and reloc_addend
	functions.  Add do_reloc_symbol_index and do_reloc_addend virtual
	functions.
	* layout.cc (add_target_dynamic_tags): Use output section for
	DT_PLTRELSZ and DT_JMPREL.
@
text
@d1612 1
a1612 1
				  this->rel_dyn_, true);
@


1.110
log
@	* output.h (class Output_data): Add const version of
	output_section and do_output_section.
	(class Output_section_data): Add const version of
	do_output_section.
	(class Output_section): Likewise.
	* layout.cc (Layout::add_target_dynamic_tags): New function.
	* layout.h (class Layout): Update declarations.
	* arm.cc (Target_arm::do_finalize_sections): Use
	add_target_dynamic_tags.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d371 1
a371 1
  const Output_data_plt_i386*
d382 4
d534 4
d574 3
d589 1
a589 1
  : Output_section_data(4), got_plt_(got_plt), count_(0)
d635 18
d803 8
d1095 14
a1108 11
		unsigned int shndx = lsym.get_st_shndx();
		bool is_ordinary;
		shndx = object->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
		if (!is_ordinary)
		  object->error(_("local symbol %u has bad shndx %u"),
			      r_sym, shndx);
                else
		  got->add_local_pair_with_rel(object, r_sym, shndx,
					       GOT_TYPE_TLS_DESC,
					       target->rel_dyn_section(layout),
					       elfcpp::R_386_TLS_DESC, 0);
d1429 2
a1430 2
                got->add_global_pair_with_rel(gsym, GOT_TYPE_TLS_DESC,
                                             target->rel_dyn_section(layout),
@


1.109
log
@	PR 10450
	* i386.cc (class Target_i386): Initialize global_offset_table_ in
	constructor.  Add global_offset_table_ field.
	(Target_i386::got_section): Set global_offset_table_.
	(Target_i386::do_finalize_sections): Set global_offset_table_
	size.
	* x86_64.cc (class Target_x86_64): Initialize global_offset_table_
	in constructor.  Add global_offset_table_ field.
	(Target_x86_64::got_section): Set global_offset_table_.
	(Target_x86_64::do_finalize_sections): Set global_offset_table_
	size.
@
text
@d1568 5
a1572 34
  // Fill in some more dynamic tags.
  Output_data_dynamic* const odyn = layout->dynamic_data();
  if (odyn != NULL)
    {
      if (this->got_plt_ != NULL
	  && this->got_plt_->output_section() != NULL)
	odyn->add_section_address(elfcpp::DT_PLTGOT, this->got_plt_);

      if (this->plt_ != NULL
	  && this->plt_->output_section() != NULL)
	{
	  const Output_data* od = this->plt_->rel_plt();
	  odyn->add_section_size(elfcpp::DT_PLTRELSZ, od);
	  odyn->add_section_address(elfcpp::DT_JMPREL, od);
	  odyn->add_constant(elfcpp::DT_PLTREL, elfcpp::DT_REL);
	}

      if (this->rel_dyn_ != NULL
	  && this->rel_dyn_->output_section() != NULL)
	{
	  const Output_data* od = this->rel_dyn_;
	  odyn->add_section_address(elfcpp::DT_REL, od);
	  odyn->add_section_size(elfcpp::DT_RELSZ, od);
	  odyn->add_constant(elfcpp::DT_RELENT,
			     elfcpp::Elf_sizes<32>::rel_size);
	}

      if (!parameters->options().shared())
	{
	  // The value of the DT_DEBUG tag is filled in by the dynamic
	  // linker at run time, and used by the debugger.
	  odyn->add_constant(elfcpp::DT_DEBUG, 0);
	}
    }
@


1.108
log
@	* layout.cc (Layout::Layout): Initialize increase_relro_.
	(Layout::get_output_section): Add is_relro, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::set_segment_offsets): Clear increase_relro when using a
	linker script.
	* layout.h (class Layout): Add increase_relro method.  Add
	increase_relro_ field.  Update declarations.
	* output.cc (Output_section::Output_section): Initialize
	is_last_relro_ and is_first_non_relro_.
	(Output_segment::add_output_section): Group relro sections is
	do_sort is true.  Handle is_last_relro and is_first_non_relro.
	(Output_segment::maximum_alignment): Remove relro handling.
	(Output_segment::set_section_addresses): Add increase_relro
	parameter.  Change all callers.  Add initial alignment to align
	relro sections on separate page.  Remove old relro handling.
	(Output_segment::set_section_list_addresses): Remove in_relro
	parameter.  Change all callers.
	(Output_segment::set_offset): Add increase parameter.  Change all
	callers.  Remove old relro handling.
	* output.h (class Output_section): Add new methods: is_last_relro,
	set_is_last_relro, is_first_non_relro, set_is_first_non_relro.
	Add is_last_relro_ and is_first_non_relro_ fields.
	* i386.cc (Target_i386::got_section): Don't call set_is_relro.
	Create separate .got.plt section.  Call increase_relro.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/relro_script_test.t: Add .got.plt.
@
text
@d62 2
a63 2
      got_(NULL), plt_(NULL), got_plt_(NULL), rel_dyn_(NULL),
      copy_relocs_(elfcpp::R_386_COPY), dynbss_(NULL),
d415 2
d483 8
a490 7
      symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
				    Symbol_table::PREDEFINED,
				    this->got_plt_,
				    0, 0, elfcpp::STT_OBJECT,
				    elfcpp::STB_LOCAL,
				    elfcpp::STV_HIDDEN, 0,
				    false, false);
d1566 1
a1566 1
    Symbol_table*)
d1607 9
@


1.107
log
@	* symtab.h (class Symbol_table): Add enum Defined.
	* resolve.cc (Symbol_table::should_override): Add defined
	parameter.  Change all callers.  Test whether object is NULL
	before calling a method on it.
	(Symbol_table::report_resolve_problem): Add defined parameter.
	Change all callers.
	(Symbol_table::should_override_with_special): Likewise.
	* symtab.cc (Symbol_table::define_in_output_data): Add defined
	parameter.  Change all callers.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::define_in_output_segment): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::define_as_constant): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* script.h (class Symbol_assignment): Add is_defsym parameter to
	constructor; change all callers.
	* script.cc (Script_options::add_symbol_assignment): Add is_defsym
	parameter.  Change all callers.  Add is_defsym_ field.
	(class Parser_closure): Add parsing_defsym parameter to
	constructor; change all callers.  Add parsing_defsym accessor
	function.  Add parsing_defsym_ field.
@
text
@d464 2
a465 2
					   this->got_, false);
      os->set_is_relro();
a466 4
      // The old GNU linker creates a .got.plt section.  We just
      // create another set of data in the .got section.  Note that we
      // always create a PLT if we create a GOT, although the PLT
      // might be empty.
d468 1
a468 1
      os = layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
d471 2
a472 2
					   this->got_plt_, false);
      os->set_is_relro();
d477 3
d503 2
a504 1
				      elfcpp::SHF_ALLOC, this->rel_dyn_, true);
d579 2
a580 1
				  elfcpp::SHF_ALLOC, this->rel_, true);
d765 1
a765 1
				      this->plt_, false);
@


1.106
log
@	* i386.cc (Target_i386::do_calls_non_split): Recognize
	-fsplit-stack prologue for a function with a static chain.
@
text
@d483 1
d783 1
@


1.105
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d2706 3
a2708 1
  else if (this->match_view(view, view_size, fnoffset, "\x8d\x8c\x24", 3)
@


1.104
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d670 1
a670 1
  const off_t off = this->offset();
d673 1
a673 1
  unsigned char* const oview = of->get_output_view(off, oview_size);
d742 1
a742 1
  of->write_output_view(off, oview_size, oview);
d978 1
a978 1
                r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
@


1.103
log
@2009-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gold/10893
	* i386.cc (Target_i386::Scan::globa): Use is_func instead of
	checking elfcpp::STT_FUNC.
	(Target_i386::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Scan::global): Likewise.

	* symtab.cc (Symbol_table::sized_write_symbol): Turn IFUNC
	symbols from shared libraries into normal FUNC symbols.

	* symtab.h (Symbol): Add is_func and use it.
@
text
@d670 1
a670 1
  const off_t offset = this->offset();
d673 1
a673 1
  unsigned char* const oview = of->get_output_view(offset, oview_size);
d742 1
a742 1
  of->write_output_view(offset, oview_size, oview);
d978 1
a978 1
                unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
@


1.102
log
@2009-12-05  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:

	* arm.h: Define enums for Tag_CPU_arch EABI attribute.

gold/ChangeLog:
	* arm.cc (Target_arm::arm_info): Initialize new fields
	attributes_section and attributes_vendor.
	* i386.cc (Target_i386::i386_info): Same.
	* object.cc (Sized_relobj::do_layout): Skip attribute section.
	* gold/powerpc.cc (Target_powerpc::powerpc_info): Initialize new
	fields attributes_section and attributes_vendor.
 	* sparc.cc (Target_sparc::sparc_info): Same.
	* target.h (Target::attributes_section, Target::attributes_vendor,
	Target::is_attributes_section, Target::attribute_arg_type,
	Target::attributes_order): New method definitions.
	(Target::Target_info::attributes_section,
	Target::Target_info::attributes_vendor): New fields.
	(Target::do_attribute_arg_type, Target::do_attributes_order): New
	virtual method definitions.
	* x86_64.cc (Target_x86_64::x86_64_info): Initialize new fields
	attributes_section and attributes_vendor.
	* testsuite/testfile.cc (Target_test::test_target_info): Same.
@
text
@d1251 1
a1251 1
        if (gsym->type() == elfcpp::STT_FUNC)
d1730 1
a1730 1
        if (gsym != NULL && gsym->type() == elfcpp::STT_FUNC)
d1746 1
a1746 1
        if (gsym != NULL && gsym->type() == elfcpp::STT_FUNC)
d1762 1
a1762 1
        if (gsym != NULL && gsym->type() == elfcpp::STT_FUNC)
@


1.101
log
@2009-12-03  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Remove comment about missing .ARM.exidx section symbols.
	(Target_arm::do_finalize_sections): Add parameter for symbol table
	pointer.  Add __exidx_start and __exidx_end symbols as appropriate.
	* i386.cc (Target_i386::do_finalize_sections): Add an additional
	parameter for symbol table pointer.
	* layout.cc (Layout::finalize): Call Target::finalize_sections with
	an additional parameter for a pointer to symbol table.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add an additional
	parameter for a symbol table pointer.
	* sparc.cc (Target_sparc::do_finalize_sections): Ditto.
	* target.h (Target::finalize_sections, Target::do_finalize_sections):
	Ditto.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add an additional
	parameter for a symbol table pointer.
@
text
@d444 3
a446 1
  0			// large_common_section_flags
@


1.100
log
@2009-11-10  Doug Kwan  <dougkwan@@google.com>

	* i386.cc (Target_i386::do_calls_non_split): Add a cast to avoid
	a format warning.
	* incremental.cc (open_incremental_binary): Initialized local
	variables to avoid warnings.
	* object.cc (make_elf_object): Ditto.
	* x86_64.cc (Target_x86_64::do_calls_non_split): Add a cast to avoid
	a format warning.
@
text
@d98 1
a98 1
  do_finalize_sections(Layout*, const Input_objects*);
d1555 4
a1558 1
Target_i386::do_finalize_sections(Layout* layout, const Input_objects*)
@


1.99
log
@	PR 10887
	* arm.cc (Target_arm::do_finalize_sections): Don't add dynamic
	tags if data is discarded by linker script.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d2719 1
a2719 1
		      shndx, fnoffset);
@


1.98
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d1561 2
a1562 1
      if (this->got_plt_ != NULL)
d1565 2
a1566 1
      if (this->plt_ != NULL)
d1574 2
a1575 1
      if (this->rel_dyn_ != NULL)
@


1.97
log
@2009-10-30  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:
	* arm.h (EF_ARM_BE8, EF_ARM_EABIMASK, EF_ARM_EABI_UNKNOWN,
	EF_ARM_EABI_VER1, EF_ARM_EABI_VER2, EF_ARM_EABI_VER3,
	EF_ARM_EABI_VER4, EF_ARM_EABI_VER5): New enums for processor-specific
	flags.
	(arm_eabi_version): New inline function.
	* elfcpp.h: Add a comment about DT_ENCODING.

gold/ChangeLog:
	* arm.cc (Arm_relobj::processor_specific_flags): New method
	definition.
	(Arm_relobj::do_read_symbols): New method declaration.
	(Arm_relobj::processor_specific_flags_): New data member declaration.
	(Arm_dynobj): New class definition.
	(Target_arm::do_finalize_sections): Add input_objects parameter.
	(Target_arm::do_adjust_elf_header): New method declaration.
	(Target_arm::are_eabi_versions_compatible,
	(Target_arm::merge_processor_specific_flags): New method declaration.
	(Target_arm::do_make_elf_object): New overloaded method definitions
	and declaration.
	(Arm_relobj::do_read_symbols): New method definition.
	(Arm_dynobj::do_read_symbols): Ditto.
	(Target_arm::do_finalize_sections): Add input_objects parameters.
	Merge processor-specific flags from all input objects.
	(Target_arm::are_eabi_versions_compatible,
	Target_arm::merge_processor_specific_flags,
	Target_arm::do_adjust_elf_header, Target_arm::do_make_elf_object):
	New method definitions.
	* i386.cc (Target_i386::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* layout.cc (Layout::finalize): Pass input objects to target's.
	finalize_sections function.
	* output.cc (Output_file_header::do_sized_write): Set ELF file
	header's processor-specific flags.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* sparc.cc (Target_sparc::do_finalize_sections): Same.
	* target.h (Input_objects): New forward class declaration.
	(Target::processor_specific_flags,
	Target::are_processor_specific_flags_sect): New method definitions.
	(Target::finalize_sections): Add input_objects parameter.
	(Target::Target): Initialize processor_specific_flags_ and
	are_processor_specific_flags_set_.
	(Target::do_finalize_sections): Add unnamed Input_objects pointer type
	parameter.
	(Target::set_processor_specific_flags): New method definition.
	(Target::processor_specific_flags_,
	Target::are_processor_specific_flags_set_): New data member
	declarations.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
@
text
@d462 1
a462 1
					   this->got_);
d473 1
a473 1
					   this->got_plt_);
d501 1
a501 1
				      elfcpp::SHF_ALLOC, this->rel_dyn_);
d576 1
a576 1
				  elfcpp::SHF_ALLOC, this->rel_);
d761 1
a761 1
				      this->plt_);
@


1.96
log
@	* object.h (class Relobj): Drop options parameter from
	gc_process_relocs, scan_relocs, relocate, do_gc_process_relocs,
	do_scan_relocs, do_relocate.  Change all callers.
	(class Sized_relobj): Drop options parameters from
	do_gc_process_relocs, do_scan_relocs, do_relocate,
	do_relocate_sections, relocate_sections, emit_relocs_scan,
	emit_relocs_scan_reltype.  Change all callers.
	(struct Relocate_info): Remove options field and all references to
	it.
	* reloc.h (class Read_relocs): Remove options constructor
	parameter and options_ field.  Change all callers.
	(class Gc_process_relocs, class Scan_relocs): Likewise.
	(class Relocate_task): Likewise.
	* target-reloc.h (scan_relocs): Remove options parameter.  Change
	all callers.
	(scan_relocatable_relocs): Likewise.
	* target.h (class Sized_target): Remove options parameter from
	gc_process_relocs, scan_relocs, scan_relocatable_relocs.  Change
	all callers.
	* gc.h (gc_process_relocs): Remove options parameter.  Change all
	callers.
	* arm.cc: Update functions to remove options parameters.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* testsuite/testfile.cc: Likewise.
@
text
@d98 1
a98 1
  do_finalize_sections(Layout*);
d1555 1
a1555 1
Target_i386::do_finalize_sections(Layout* layout)
@


1.95
log
@	* object.h (class Relocate_info): Add reloc_shdr and data_shdr
	fields.
	* object.cc (Sized_relobj::relocate_sections): Set reloc_shdr and
	data_shdr fields of relinfo.
	* i386.cc (class Target_i386::Relocate): Remove ldo_addrs_ field.
	(Target_i386::Relocate::relocate_tls): Don't call fix_up_ldo.  For
	R_386_TLS_LDO_32, adjust based on section flags.
	(Target_i386::Relocate::fix_up_ldo): Remove.
@
text
@d70 1
a70 2
  gc_process_relocs(const General_options& options,
                    Symbol_table* symtab,
d84 1
a84 2
  scan_relocs(const General_options& options,
	      Symbol_table* symtab,
d120 1
a120 2
  scan_relocatable_relocs(const General_options& options,
			  Symbol_table* symtab,
d190 1
a190 2
    local(const General_options& options, Symbol_table* symtab,
	  Layout* layout, Target_i386* target,
d198 1
a198 2
    global(const General_options& options, Symbol_table* symtab,
	   Layout* layout, Target_i386* target,
d882 1
a882 2
Target_i386::Scan::local(const General_options&,
			 Symbol_table* symtab,
d1172 1
a1172 2
Target_i386::Scan::global(const General_options&,
			  Symbol_table* symtab,
d1488 1
a1488 2
Target_i386::gc_process_relocs(const General_options& options,
                               Symbol_table* symtab,
a1501 1
    options,
d1518 1
a1518 2
Target_i386::scan_relocs(const General_options& options,
			 Symbol_table* symtab,
a1538 1
    options,
d2529 1
a2529 2
Target_i386::scan_relocatable_relocs(const General_options& options,
				     Symbol_table* symtab,
a2548 1
    options,
@


1.94
log
@	Add support for -pie.
	* options.h (class General_options): Add -pie and
	--pic-executable.
	(General_options::output_is_position_independent): Test -pie.
	(General_options::output_is_executable): Return true if not shared
	and not relocatable.
	(General_options::output_is_pie): Remove.
	* options.cc (General_options::finalize): Reject incompatible uses
	of -pie.
	* gold.cc (queue_middle_tasks): A -pie link is not static.
	* symtab.h (Symbol::needs_plt_entry): Return false if -pie.
	* symtab.cc (Symbol::final_value_is_known): Return false if
	output_is_position_independent.
	* layout.cc (Layout::set_segment_offsets): Start at address 0 if
	output_is_position_independent.
	* output.cc (Output_file_header::do_sized_write): Use ET_DYN if
	output_is_position_independent.
	* i386.cc (Output_data_plt_i386::do_write): Use the PIC PLT if
	output_is_position_independent.
	* testsuite/Makefile.am (check_PROGRAMS): Add basic_pie_test and
	two_file_pie_test.
	(basic_pie_test.o, basic_pie_test): New targets.
	(two_file_test_1_pie.o, two_file_test_1b_pie.o): New targets.
	(two_file_test_2_pie.o, two_file_test_main_pie.o): New targets.
	(two_file_pie_test): New target.
	* testsuite/Makefile.in: Rebuild.
	* README: Remove note saying that -pie is not supported.
@
text
@d224 1
a224 1
	local_dynamic_type_(LOCAL_DYNAMIC_NONE), ldo_addrs_()
a318 4
    // Fix up LDO_32 relocations we've already seen.
    void
    fix_up_ldo(const Relocate_info<32, false>*);

a333 2
    // A list of LDO_32 offsets, in case we find LDM after LDO_32.
    std::vector<unsigned char*> ldo_addrs_;
a1933 2
      if (this->local_dynamic_type_ == LOCAL_DYNAMIC_NONE)
	this->fix_up_ldo(relinfo);
a1991 2
      else if (this->local_dynamic_type_ == LOCAL_DYNAMIC_NONE)
	this->fix_up_ldo(relinfo);
a2015 3
      // This reloc can appear in debugging sections, in which case we
      // won't see the TLS_LDM reloc.  The local_dynamic_type field
      // tells us this.
d2018 7
a2024 1
          if (this->local_dynamic_type_ != LOCAL_DYNAMIC_NONE)
a2028 5
	  else
	    {
	      // We may see the LDM later.
	      this->ldo_addrs_.push_back(view);
	    }
a2435 18
// If we see an LDM reloc after we handled any LDO_32 relocs, fix up
// the LDO_32 relocs.

void
Target_i386::Relocate::fix_up_ldo(const Relocate_info<32, false>* relinfo)
{
  if (this->ldo_addrs_.empty())
    return;
  Output_segment* tls_segment = relinfo->layout->tls_segment();
  gold_assert(tls_segment != NULL);
  elfcpp::Elf_types<32>::Elf_Addr value = - tls_segment->memsz();
  for (std::vector<unsigned char*>::const_iterator p = this->ldo_addrs_.begin();
       p != this->ldo_addrs_.end();
       ++p)
    Relocate_functions<32, false>::rel32(*p, value);
  this->ldo_addrs_.clear();
}

@


1.93
log
@	* symtab.h: Check for GOLD_SYMTAB_H before header includes. Remove
	includes to gc.h and icf.h.
	* arm.cc: Include gc.h.
	* gold.cc: Likewise.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* gc.h: Include icf.h.
@
text
@d695 1
a695 1
  if (parameters->options().shared())
d727 1
a727 1
      if (parameters->options().shared())
@


1.92
log
@	* options.h (class General_options): Define
	split_stack_adjust_size parameter.
	* object.h (class Object): Add uses_split_stack_ and
	has_no_split_stack_ fields.  Add uses_split_stack and
	has_no_split_stack accessor functions.  Declare
	handle_split_stack_section.
	(class Reloc_symbol_changes): Define.
	(class Sized_relobj): Define Function_offsets.  Declare
	split_stack_adjust, split_stack_adjust_reltype, and
	find_functions.
	* object.cc (Object::handle_split_stack_section): New function.
	(Sized_relobj::do_layout): Call handle_split_stack_section.
	* dynobj.cc (Sized_dynobj::do_layout): Call
	handle_split_stack_section.
	* reloc.cc (Sized_relobj::relocate_sections): Call
	split_stack_adjust for executable sections in split_stack
	objects.  Pass reloc_map to relocate_section.
	(Sized_relobj::split_stack_adjust): New function.
	(Sized_relobj::split_stack_adjust_reltype): New function.
	(Sized_relobj::find_functions): New function.
	* target-reloc.h: Include "object.h".
	(relocate_section): Add reloc_symbol_changes parameter.  Change
	all callers.
	* target.h (class Target): Add calls_non_split method.  Declare
	do_calls_non_split virtual method.  Declare match_view and
	set_view_to_nop.
	* target.cc: Include "elfcpp.h".
	(Target::do_calls_non_split): New function.
	(Target::match_view): New function.
	(Target::set_view_to_nop): New function.
	* gold.cc (queue_middle_tasks): Give an error if mixing
	split-stack and non-split-stack objects with -r.
	* i386.cc (Target_i386::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_i386::do_calls_non_split): New function.
	* x86_64.cc (Target_x86_64::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_x86_64::do_calls_non_split): New function.
	* arm.cc (Target_arm::relocate_section): Add reloc_symbol_changes
	parameter.
	* powerpc.cc (Target_powerpc::relocate_section): Add
	reloc_symbol_changes parameter.
	* sparc.cc (Target_sparc::relocate_section): Add
	reloc_symbol_changes parameter.
	* configure.ac: Call AM_CONDITIONAL for the default target.
	* configure: Rebuild.
	* testsuite/Makefile.am (TEST_AS): New variable.
	(check_SCRIPTS): Add split_i386.sh and split_x86_64.sh.
	(check_DATA): Add split_i386 and split_x86_64 files.
	(SPLIT_DEFSYMS): Define.
	(split_i386_[1234n].o): New targets.
	(split_i386_[124]): New targets.
	(split_i386_[1234r].stdout): New targets.
	(split_x86_64_[1234n].o): New targets.
	(split_x86_64_[124]): New targets.
	(split_x86_64_[1234r].stdout): New targets.
	(MOSTLYCLEANFILES): Add new executables.
	* testsuite/split_i386.sh: New file.
	* testsuite/split_x86_64.sh: New file.
	* testsuite/split_i386_1.s: New file.
	* testsuite/split_i386_2.s: New file.
	* testsuite/split_i386_3.s: New file.
	* testsuite/split_i386_4.s: New file.
	* testsuite/split_i386_n.s: New file.
	* testsuite/split_x86_64_1.s: New file.
	* testsuite/split_x86_64_2.s: New file.
	* testsuite/split_x86_64_3.s: New file.
	* testsuite/split_x86_64_4.s: New file.
	* testsuite/split_x86_64_n.s: New file.
	* testsuite/testfile.cc (Target_test): Update relocation_section
	function.
	* testsuite/Makefile.in: Rebuild.
@
text
@d41 1
@


1.91
log
@Tweak last patch.
@
text
@d116 2
a117 1
		   section_size_type view_size);
d172 7
d2476 2
a2477 1
			      section_size_type view_size)
d2491 2
a2492 1
    view_size);
d2712 57
@


1.90
log
@	* i386.cc (class Target_i386::Relocate): Add ldo_addrs_ field.
	(Target_i386::Relocate::relocate_tls): Call fix_up_ldo before
	changing local_dynamic_type_ from LOCAL_DYNAMIC_NONE.  When
	handling R_386_TLS_LDO_32, if local_dynamic_type_ is NONE, push
	the address on ldo_addrs_.
	(Target_i386::Relocate::fix_up_ldo): New function.
@
text
@d2020 1
a2020 2
      if (optimized_type == tls::TLSOPT_TO_LE
          && this->local_dynamic_type_ != LOCAL_DYNAMIC_NONE)
d2022 10
a2031 7
          gold_assert(tls_segment != NULL);
          value -= tls_segment->memsz();
	}
      else
	{
	  // We may see the LDM later.
	  this->ldo_addrs_.push_back(view);
@


1.89
log
@2009-09-30  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::may_need_copy_reloc): Check for THUMB function
	symbol and call Symbol::may_need_copy_reloc to determine if
	a copy reloc is needed.
	* copy-relocs.cc (Copy_relocs::need_copy_reloc): Return false if -z
	nocopyreloc is given in command line.
	(Copy_relocs::emit_copy_reloc): Assert that -z nocopyreloc is not
	given in command line.
	* i386.cc (Target_i386::may_need_copy_reloc): Remove.
	(Target_i386::Scan::global): Use Symbol::may_need_copy_reloc instead
	of the removed Target_i386::may_need_copy_reloc.
	* options.h (copyreloc): New option with default value false.
	* powerpc.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_powerpc::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_powerpc::may_need_copy_reloc.
	* sparc.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_sparc::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_sparc::may_need_copy_reloc.
	* symtab.h (Symbol::may_need_copy_reloc): New method definition.
	* x86_64.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_x86_64::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_x86_64::may_need_copy_reloc.
@
text
@d215 1
a215 1
	local_dynamic_type_(LOCAL_DYNAMIC_NONE)
d310 4
d329 2
d1931 2
d1991 2
d2026 5
d2437 18
@


1.88
log
@	* layout.cc (Layout::make_output_section): Call
	Target::new_output_section.
	(Layout::attach_allocated_section_to_segment): Put large section
	sections in a separate load segment with the large segment flag
	set.
	(Layout::segment_precedes): Sort large data segments after other
	load segments.
	(align_file_offset): New static function.
	(Layout::set_segment_offsets): Use align_file_offset.
	* output.h (class Output_section): Add is_small_section_ and
	is_large_section_ fields.
	(Output_section::is_small_section): New function.
	(Output_section::set_is_small_section):  New function.
	(Output_section::is_large_section): New function.
	(Output_section::set_is_large_section): New function.
	(Output_section::is_large_data_section): New function.
	(class Output_segment): Add is_large_data_segment_ field.
	(Output_segment::is_large_data_segment): New function.
	(Output_segment::set_is_large_data_segment): New function.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_segment::Output_segment): Likewise.
	(Output_segment::add_output_section): Add assertion that large
	data sections always go in large data segments.  Force small data
	sections to the end of the list of data sections.  Force small BSS
	sections to the start of the list of BSS sections.  For large BSS
	sections to the end of the list of BSS sections.
	* symtab.h (class Symbol): Declare is_common_shndx.
	(Symbol::is_defined): Check Symbol::is_common_shndx.
	(Symbol::is_common): Likewise.
	(class Symbol_table): Define enum Commons_section_type.  Update
	declarations.  Add small_commons_ and large_commons_ fields.
	* symtab.cc (Symbol::is_common_shndx): New function.
	(Symbol_table::Symbol_table): Initialize new fields.
	(Symbol_table::add_from_object): Put small and large common
	symbols in the right list.
	(Symbol_table::sized_finalized_symbol): Check
	Symbol::is_common_shndx.
	(Symbol_table::sized_write_globals): Likewise.
	* common.cc (Symbol_table::do_allocate_commons): Allocate new
	common symbol lists.  Don't call do_allocate_commons_list if the
	list is empty.
	(Symbol_table::do_allocate_commons_list): Remove is_tls
	parameter.  Add comons_section_type parameter.  Change all
	callers.  Handle small and large common symbols.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Check
	Symbol::is_common_shndx.
	* resolve.cc (symbol_to_bits): Likewise.
	* target.h (Target::small_common_shndx): New function.
	(Target::small_common_section_flags): New function.
	(Target::large_common_shndx): New function.
	(Target::large_common_section_flags): New function.
	(Target::new_output_section): New function.
	(Target::Target_info): Add small_common_shndx, large_common_shndx,
	small_common_section_flags, and large_common_section_flags
	fields.
	(Target::do_new_output_section): New virtual function.
	* arm.cc (Target_arm::arm_info): Initialize new fields.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Likewise.
	* sparc.c (Target_sparc::sparc_info) [all versions]: Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	(Target_x86_64::do_new_output_section): New function.
	* configure.ac: Define conditional MCMODEL_MEDIUM.
	* testsuite/Makefile.am (check_PROGRAMS): Add large.
	(large_SOURCES, large_CFLAGS, large_DEPENDENCIES): Define.
	(large_LDFLAGS): Define.
	* testsuite/large.c: New file.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Initialize new fields.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@a377 11
  // Return true if the symbol may need a COPY relocation.
  // References from an executable object to non-function symbols
  // defined in a dynamic object may need a COPY relocation.
  bool
  may_need_copy_reloc(Symbol* gsym)
  {
    return (!parameters->options().shared()
            && gsym->is_from_dynobj()
            && gsym->type() != elfcpp::STT_FUNC);
  }

d1205 1
a1205 1
            if (target->may_need_copy_reloc(gsym))
d1251 1
a1251 1
            if (target->may_need_copy_reloc(gsym))
@


1.88.4.1
log
@Merge elfcpp and gold from trunk.
@
text
@a40 1
#include "gc.h"
d116 1
a116 2
		   section_size_type view_size,
		   const Reloc_symbol_changes*);
a170 7
  // Adjust -fstack-split code which calls non-stack-split code.
  void
  do_calls_non_split(Relobj* object, unsigned int shndx,
		     section_offset_type fnoffset, section_size_type fnsize,
		     unsigned char* view, section_size_type view_size,
		     std::string* from, std::string* to) const;

d378 11
d691 1
a691 1
  if (parameters->options().output_is_position_independent())
d723 1
a723 1
      if (parameters->options().output_is_position_independent())
d1216 1
a1216 1
            if (gsym->may_need_copy_reloc())
d1262 1
a1262 1
            if (gsym->may_need_copy_reloc())
d2018 5
a2022 1
      if (optimized_type == tls::TLSOPT_TO_LE)
d2024 2
a2025 11
	  // This reloc can appear in debugging sections, in which
	  // case we must not convert to local-exec.  We decide what
	  // to do based on whether the section is marked as
	  // containing executable code.  That is what the GNU linker
	  // does as well.
	  elfcpp::Shdr<32, false> shdr(relinfo->data_shdr);
	  if ((shdr.get_sh_flags() & elfcpp::SHF_EXECINSTR) != 0)
	    {
	      gold_assert(tls_segment != NULL);
	      value -= tls_segment->memsz();
	    }
d2444 1
a2444 2
			      section_size_type view_size,
			      const Reloc_symbol_changes* reloc_symbol_changes)
d2458 1
a2458 2
    view_size,
    reloc_symbol_changes);
a2677 57
// FNOFFSET in section SHNDX in OBJECT is the start of a function
// compiled with -fstack-split.  The function calls non-stack-split
// code.  We have to change the function so that it always ensures
// that it has enough stack space to run some random function.

void
Target_i386::do_calls_non_split(Relobj* object, unsigned int shndx,
				section_offset_type fnoffset,
				section_size_type fnsize,
				unsigned char* view,
				section_size_type view_size,
				std::string* from,
				std::string* to) const
{
  // The function starts with a comparison of the stack pointer and a
  // field in the TCB.  This is followed by a jump.

  // cmp %gs:NN,%esp
  if (this->match_view(view, view_size, fnoffset, "\x65\x3b\x25", 3)
      && fnsize > 7)
    {
      // We will call __morestack if the carry flag is set after this
      // comparison.  We turn the comparison into an stc instruction
      // and some nops.
      view[fnoffset] = '\xf9';
      this->set_view_to_nop(view, view_size, fnoffset + 1, 6);
    }
  // lea NN(%esp),%ecx
  else if (this->match_view(view, view_size, fnoffset, "\x8d\x8c\x24", 3)
	   && fnsize > 7)
    {
      // This is loading an offset from the stack pointer for a
      // comparison.  The offset is negative, so we decrease the
      // offset by the amount of space we need for the stack.  This
      // means we will avoid calling __morestack if there happens to
      // be plenty of space on the stack already.
      unsigned char* pval = view + fnoffset + 3;
      uint32_t val = elfcpp::Swap_unaligned<32, false>::readval(pval);
      val -= parameters->options().split_stack_adjust_size();
      elfcpp::Swap_unaligned<32, false>::writeval(pval, val);
    }
  else
    {
      if (!object->has_no_split_stack())
	object->error(_("failed to match split-stack sequence at "
			"section %u offset %0zx"),
		      shndx, fnoffset);
      return;
    }

  // We have to change the function so that it calls
  // __morestack_non_split instead of __morestack.  The former will
  // allocate additional stack space.
  *from = "__morestack";
  *to = "__morestack_non_split";
}

@


1.88.4.2
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d467 1
a467 1
					   this->got_, false);
d478 1
a478 1
					   this->got_plt_, false);
d506 1
a506 1
				      elfcpp::SHF_ALLOC, this->rel_dyn_, true);
d581 1
a581 1
				  elfcpp::SHF_ALLOC, this->rel_, true);
d766 1
a766 1
				      this->plt_, false);
@


1.88.4.3
log
@	PR 10887
	* arm.cc (Target_arm::do_finalize_sections): Don't add dynamic
	tags if data is discarded by linker script.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d1572 1
a1572 2
      if (this->got_plt_ != NULL
	  && this->got_plt_->output_section() != NULL)
d1575 1
a1575 2
      if (this->plt_ != NULL
	  && this->plt_->output_section() != NULL)
d1583 1
a1583 2
      if (this->rel_dyn_ != NULL
	  && this->rel_dyn_->output_section() != NULL)
@


1.87
log
@2009-06-05  Doug Kwan  <dougkwan@@google.com>

	* Makefile.am (CCFILES): Add target.cc.
	* Makefile.in: Regenerate.
	* i386.cc (class Target_i386): Define new virtual method to
	override do_is_local_label_name in parent.
	* object.cc (Sized_relobj::do_count_local_symbols): Discard
	local symbols if --discard-locals or -X is given.
	* options.h (class General_options): Declare new options
	'--discard-locals' and '-X' for discarding locals.
	* target.h (class Target): Define new methods is_local_label_name.
	Declare new virtual method do_is_local_label_name.
	* target.cc: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add discard_locals_test.
	(check_SCRIPTS): Add discard_locals_test.sh.
	(check_DATA): Add discard_local_tests.syms.
	(discard_locals_test_SOURCES, discard_locals_test_LDFLAGS): Define.
	(discard_local_tests.syms, discard_locals_test.o): New make rules.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/discard_locals_test.c: New file.
	* testsuite/discard_locals_test.sh: Same.
@
text
@d447 5
a451 1
  0x1000		// common_pagesize (overridable by -z common-page-size)
@


1.86
log
@2009-03-23  Ian Lance Taylor  <iant@@google.com>

	* freebsd.h: New file.
	* i386.cc: Include "freebsd.h".
	(Target_i386): Derive from Target_freebsd rather than
	Sized_target.
	(Target_selector_i386): Derive from Target_selector_freebsd rather
	than Target_selector.
	* x86_64.cc: Include "freebsd.h".
	(Target_x86_64): Derive from Target_freebsd rather than
	Sized_target.
	(Target_selector_x86_64): Derive from Target_selector_freebsd
	rather than Target_selector.
	* target.h (class Target): Add adjust_elf_header and
	do_adjust_elf_header.
	* output.cc (Output_file_header:: do_sized_write): Call target
	adjust_elf_header routine.
	* configure.tgt: Set targ_osabi.
	* configure.ac: Define GOLD_DEFAULT_OSABI.
	* parameters.cc (Parameters::default_target): Pass
	GOLD_DEFAULT_OSABI to select_target.
	* target-select.h (class Target_selector): Make instantiate_target
	protected rather than private.
	* Makefile.am (HFILES): Add freebsd.h.
	* configure, Makefile.in, config.in: Rebuild.
@
text
@d158 13
@


1.85
log
@	PR 9918
	* target-reloc.h (relocate_section): Pass output_section to
	relocate.
	* i386.cc (Target_i386::should_apply_static_reloc): Add
	output_section parameter.  Change all callers.
	(Target_i386::Relocate::relocate): Add output_section parameter.
	* x86_64.cc (Target_x86_64::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Relocate::relocate): Likewise.
	* powerpc.cc (Target_powerpc::Relocate::relocate): Likewise.
	* testsuite/two_file_shared.sh: New script.
	* testsuite/Makefile.am (check_SCRIPTS): Add two_file_shared.sh.
	(check_DATA): Add two_file_shared.dbg.
	(two_file_shared.dbg): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d40 1
d54 1
a54 1
class Target_i386 : public Sized_target<32, false>
d60 1
a60 1
    : Sized_target<32, false>(&i386_info),
d2663 1
a2663 1
class Target_selector_i386 : public Target_selector
d2667 2
a2668 1
    : Target_selector(elfcpp::EM_386, 32, false, "elf32-i386")
@


1.84
log
@	* i386.cc (Target_i386::Relocate::relocate): Recognize non-PIC calls
	to __tls_get_addr.
	* x86_64.cc (Target_x86_64::Relocate::relocate): Likewise.

	* ChangeLog: Fixed typo in previous ChangeLog entry (version 1.9).
@
text
@d217 2
a218 1
                              bool is_32bit);
d223 2
a224 2
    relocate(const Relocate_info<32, false>*, Target_i386*, size_t relnum,
	     const elfcpp::Rel<32, false>&,
d1599 2
a1600 1
                                                 bool is_32bit)
d1602 6
d1633 1
d1709 2
a1710 1
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true))
d1719 1
a1719 1
        if (should_apply_static_reloc(gsym, ref_flags, true))
d1725 2
a1726 1
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false))
d1735 1
a1735 1
        if (should_apply_static_reloc(gsym, ref_flags, false))
d1741 2
a1742 1
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false))
d1751 2
a1752 1
        if (should_apply_static_reloc(gsym, ref_flags, false))
@


1.83
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d1636 2
a1637 1
      if (r_type != elfcpp::R_386_PLT32
@


1.82
log
@	* target-reloc.h (relocate_section): Check whether a symbol is
	defined by the ABI before reporting an undefined symbol error.
	* target.h (Target::is_defined_by_abi): Make parameter const.
	(Target::do_is_defined_by_abi): Likewise.
	* i386.cc (Target_i386::do_is_defined_by_abi): Likewise.
	* powerpc.cc (Target_powerpc::do_is_defined_by_abi): Likewise.
	* sparc.cc (Target_sparc::do_is_defined_by_abi): Likewise.
	* x86_64.cc (Target_x86_64::do_is_defined_by_abi): Likewise.
	* testsuite/Makefile.am (tls_test_shared.so): Add -Wl,-z,defs.
	* testsuite/Makefile.in: Rebuild.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d65 16
d1475 32
@


1.81
log
@* i386.cc (Target_i386::define_tls_base_symbol): Update comments.
* x86_64.cc (Target_x86_64::define_tls_base_symbol): Likewise.
@
text
@d138 1
a138 1
  do_is_defined_by_abi(Symbol* sym) const
@


1.80
log
@* options.h (General_options::output_is_executable): New.
(General_options::output_is_pie): New.
* i386.cc (Target_i386::define_tls_base_symbol): Use SEGMENT_START
for shared libraries.
* x86_64.cc (Target_x86_64::define_tls_base_symbol): Likewise.
@
text
@d326 1
a326 1
  // Define the _TLS_MODULE_BASE_ symbol at the end of the TLS segment.
d739 1
a739 1
// Define the _TLS_MODULE_BASE_ symbol at the end of the TLS segment.
@


1.79
log
@	* symtab.h (Symbol::use_plt_offset): New function.
	* i386.cc (Relocate::relocate): Call Symbol::use_plt_offset.
	* powerpc.cc (Relocate::relocate): Likewise.
	* sparc.cc (Relocate::relocate): Likewise.
	* x86_64.cc (Relocate::relocate): Likewise.
	* testsuite/weak_plt.sh: New test.
	* testsuite/weak_plt_main.cc: New test.
	* testsuite/weak_plt_shared.cc: New test.
	* testsuite/Makefile.am (check_SCRIPTS): Add weak_plt.sh.
	(check_PROGRAMS): Add weak_plt.
	(check_DATA): Add weak_plt_shared.so.
	(weak_plt_main_pic.o, weak_plt): New targets.
	(weak_plt_shared_pic.o, weak_plt_shared.so): New targets.
	* testsuite/Makefile.in: Rebuild.

	* testsuite/Makefile.am (weak_alias_test_1.so): Depend upon
	gcctestdir/ld.
	(weak_alias_test_2.so, weak_alias_test_4.so): Likewise.
	* testsuite/Makefile.in: Rebuild.
@
text
@d750 1
d756 4
a759 1
				       Symbol::SEGMENT_END, true);
@


1.78
log
@	Handle output sections with more than 0x7fffffff bytes.
	* object.h (class Relobj): Change map_to_output_ to
	output_sections_, and just keep a section pointer.  Change all
	uses.  Move comdat group support to Sized_relobj.
	(Relobj::is_section_specially_mapped): Remove.
	(Relobj::output_section): Remove poff parameter.  Change all
	callers.
	(Relobj::output_section_offset): New function.
	(Relobj::set_section_offset): Rewrite.
	(Relobj::map_to_output): Remove.
	(Relobj::output_sections): New function.
	(Relobj::do_output_section_offset): New pure virtual function.
	(Relobj::do_set_section_offset): Likewise.
	(class Sized_relobj): Add section_offsets_ field.  Add comdat
	group support from Relobj.  Update declarations.
	(Sized_relobj::get_output_section_offset): New function.
	(Sized_relobj::do_output_section_offset): New function.
	(Sized_relobj::do_set_section_offset): New function.
	* object.cc (Relobj::output_section_address): Remove.
	(Sized_relobj::Sized_relobj): Initialize new fields.
	(Sized_relobj::include_section_group): Cast find_kept_object to
	Sized_relobj.
	(Sized_relobj::include_linkonce_section): Likewise.
	(Sized_relobj::do_layout): Use separate arrays for output section
	and output offset.
	(Sized_relobj::do_count_local_symbols): Change map_to_output to
	output_sections.
	(Sized_relobj::do_finalize_local_symbols): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_local_symbols): Likewise.
	(map_to_kept_section): Compute output address directly.
	* reloc.cc (Sized_relobj::do_read_relocs): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_sections): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (sized_finalize_symbol): Use output_section_offset.
	* output.h (class Output_reloc): Update declarations.  Change
	u2_.relobj to Sized_relobj*.
	(class Output_data_reloc): Change add functions to use
	Sized_relobj*.
	* output.cc (Output_reloc::Output_reloc): Change relobj to
	Sized_relobj*.
	(Output_reloc::local_section_offset): Change return type to
	Elf_Addr.  Use get_output_section_offset.
	(Output_reloc::get_address): Likewise.
	(Output_section::is_input_address_mapped): Don't call
	is_section_specially_mapped.
	(Output_section::output_offset): Likewise.
	(Output_section::output_address): Likewise.
	(Output_section::starting_output_address): Likewise.
	* copy-relocs.cc (Copy_relocs::copy_reloc): Change object
	parameter to Sized_relobj*.
	(Copy_relocs::need_copy_reloc): Likewise.
	(Copy_relocs::save): Likewise.
	* copy-relocs.h (class Copy_relocs): Update declarations.
	(class Copy_relocs::Copy_reloc_entry): Change constructor to use
	Sized_relobj*.  Change relobj_ field to Sized_relobj*.
	* target-reloc.h (relocate_for_relocatable): Change
	offset_in_output_section type to Elf_Addr.  Change code that uses
	it as well.
	* layout.cc (Layout::layout): Always set *off.
	* mapfile.cc (Mapfile::print_input_section): Use
	output_section_offset.
	* i386.cc (Target_i386::copy_reloc): Change object parameter to
	Sized_relobj*.
	* powerpc.cc (Target_powerpc::copy_reloc): Likewise.
	* sparc.cc (Target_sparc::copy_reloc): Likewise.
	* x86_64.cc (Target_x86_64::copy_reloc): Likewise.
@
text
@a1597 3
  bool is_nonpic = (r_type == elfcpp::R_386_PC8
                    || r_type == elfcpp::R_386_PC16
                    || r_type == elfcpp::R_386_PC32);
d1599 3
a1601 5
      && (gsym->is_from_dynobj()
          || (parameters->options().shared()
              && (gsym->is_undefined() || gsym->is_preemptible())))
      && gsym->has_plt_offset()
      && (!is_nonpic || !parameters->options().shared()))
@


1.77
log
@	* mapfile.cc: New file.
	* mapfile.h: New file.
	* options.h (class General_options): Add -M/--print-map and -Map.
	* options.cc (General_options::finalize): Make -M equivalent to
	-Map -.
	* main.cc: Include <cstdio> and "mapfile.h".
	(main): Open mapfile if requested.
	* gold.cc (class Middle_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(queue_initial_tasks): Add mapfile parameter.  Change caller.
	(queue_middle_tasks): Likewise.
	* gold.h (queue_initial_tasks, queue_middle_tasks): Update
	declarations.
	* archive.cc: Include "mapfile.h".
	(Archive::add_symbols): Add mapfile parameter.  Change all
	callers.  Pass mapfile, symbol, and reason to include_member.
	(Archive::include_all_members): Add mapfile parameter.  Change all
	callers.
	(Archive::include_member): Add mapfile, sym, and why parameters.
	Change all callers.  Report inclusion to map file.
	* archive.h: Include "fileread.h".
	(class Archive): Update declarations.
	(Archive::file): New const method.
	(class Add_archive_symbols): Add mapfile_ field.  Update
	constructor.  Change all callers.
	* readsyms.h (class Read_symbols): Likewise.
	(class Finish_group): Likewise.
	(class Read_script): Likewise.
	* common.cc: Include "mapfile.h".
	(Symbol_table::allocate_commons): Add mapfile parameter.  Change
	all callers.
	(Symbol_table::do_allocate_commons): Likewise.
	(Symbol_table::do_allocate_commons_list): Likewise.  Report common
	symbol allocation to mapfile.
	* common.h (class Allocate_commons_task): Add mapfile_ field.
	Update constructor.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* layout.cc: Include "mapfile.h".
	(Layout_task_runner::run): Print information to mapfile.
	(Layout::create_gold_note): Change Output_data_fixed_space to
	Output_data_zero_fill.
	(Layout::create_build_id): Likewise.
	(Layout::print_to_mapfile): New function.
	* layout.h (class Layout_task_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(class Layout): Declare print_to_mapfile.
	* output.cc (Output_section::Input_section::print_to_mapfile): New
	function.
	(Output_section::add_input_section): If producing a map, always
	add to input_sections_ list.
	(Output_section::do_print_to_mapfile): New function.
	(Output_segment::print_sections_to_mapfile): New function.
	(Output_segment::print_section_list_to_mapfile): New function.
	* output.h: Include "mapfile.h".
	(Output_data::print_to_mapfile): New function.
	(Output_data::do_print_to_mapfile): New virtual function.
	(Output_segment_headers::do_print_to_mapfile): New function.
	(Output_file_header::do_print_to_mapfile): New function.
	(Output_data_const::do_print_to_mapfile): New function.
	(class Output_data_const_buffer): Add map_name_ field.  Update
	constructor.  Change all callers.  Add do_print_to_mapfile
	function.
	(class Output_data_fixed_space): Likewise.
	(class Output_data_space): Likewise.
	(class Output_data_zero_fill): New class.
	(Output_data_strtab::do_print_to_mapfile): New function.
	(Output_data_reloc_base::do_print_to_mapfile): New function.
	(Output_relocatable_relocs::do_print_to_mapfile): New function.
	(Output_data_group::do_print_to_mapfile): New function.
	(Output_data_got::do_print_to_mapfile): New function.
	(Output_data_dynamic::do_print_to_mapfile): New function.
	(Output_symtab_xindex::do_print_to_mapfile): New function.
	(class Output_section): Declare do_print_to_mapflie.  Declare
	print_to_mapfile in Input_section.
	(class Output_segment): Declare new functions.
	* object.h (Sized_relobj::symbol_count): New function.
	* script-sections.cc
	(Output_section_element_dot_assignment::set_section_addresses):
	Change Output_data_fixed_space to Output_data_zero_fill.
	(Output_data_expression::do_print_to_mapfile): New function.
	* script.cc (read_input_script): Add mapfile parameter.  Change
	all callers.
	* script.h (read_input_script): Update declaration.
	* ehframe.h (Eh_frame_hdr::do_print_to_mapfile): New function.
	(Eh_frame::do_print_to_mapfile): New function.
	* merge.h (Output_merge_data::do_print_to_mapfile): New function.
	(Output_merge_string::do_print_to_mapfile): New function.
	* i386.cc (Output_data_plt_i386::do_print_to_mapfile): New
	function.
	* sparc.cc (Output_data_plt_sparc::do_print_to_mapfile): New
	function.
	* x86_64.cc (Output_data_plt_x86_64::do_print_to_mapfile): New
	function.
	* Makefile.am (CCFILES): Add mapfile.cc.
	(HFILES): Add mapfile.h.
	* Makefile.in: Rebuild.
@
text
@d360 2
a361 1
  copy_reloc(Symbol_table* symtab, Layout* layout, Relobj* object,
@


1.76
log
@	* options.h (class General_options): Add -z relro.
	* layout.cc (Layout::Layout): Initialize relro_segment_.
	(Layout::add_output_section_data): Return the output section.
	(Layout::make_output_section): Rcognize relro sections and mark
	them appropriately.
	(Layout::attach_allocated_section_to_segment): Put relro sections
	in a PT_GNU_RELRO segment.
	(Layout::create_initial_dynamic_sections): Mark the .dynamic
	section as relro.
	(Layout::segment_precedes): Sort PT_GNU_RELRO segments after
	PT_TLS segments.
	(Layout::linkonce_mapping): Map d.rel.ro.local to
	.data.rel.ro.local.
	(Layout::output_section_name): Us .data.rel.ro.local for any
	section which begins with that.
	* layout.h (class Layout): Update add_output_section_data
	declaration.  Add relro_segment_ field.
	* output.cc (Output_section::Output_section): Initialize is_relro_
	and is_relro_local_ fields.
	(Output_segment::add_output_section): Group relro sections.
	(Output_segment::is_first_section_relro): New function.
	(Output_segment::maximum_alignment): If there is a relro section,
	align the segment to the common page size.
	(Output_segment::set_section_addresses): Track whether we are
	looking at relro sections.  If the last section is a relro
	section, align to the common page size.
	(Output_segment::set_section_list_addresses): Add in_relro
	parameter.  Change all callers.  Align to the page size when
	moving from relro to non-relro section.
	(Output_segment::set_offset): Align memsz of a PT_GNU_RELRO
	segment.
	* output.h (class Output_section): Add is_relro_ and
	is_relro_local_ fields.
	(Output_section::is_relro): New function.
	(Output_section::set_is_relro): New function.
	(Output_section::is_relro_local): New function.
	(Output_section::set_is_relro_local): New function.
	(class Output_segment): Update declarations.
	* i386.cc (Target_i386::got_section): Mark .got section as relro.
	* sparc.cc (Target_sparc::got_section): Likewise.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/relro_test_main.cc: New file.
	* testsuite/relro_test.cc: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_test.
	(relro_test_SOURCES, relro_test_DEPENDENCIES): New variables.
	(relro_test_LDFLAGS, relro_test_LDADD): New variables.
	(relro_test.so, relro_test_pic.o): New targets.
	* testsuite/Makefile.in: Rebuild.
@
text
@d440 1
a440 1
      this->got_plt_ = new Output_data_space(4);
d499 5
@


1.75
log
@	* i386.cc (Target_i386::Relocate::relocate_tls): Set dynamic type
	for TLS_GOTDESC and TLS_DESC_CALL.  Only optimize TLS_LDO_32 if we
	know the dynamic type.
	* x86_64.cc (Target_x86_64::Relocate): Add saw_tls_block_reloc_
	field.  Initialize it in constructor.
	(Target_x86_64::Relocate::relocate_tls): Record that we saw a TLS
	block reloc for TLSGD, GOTPC32_TLSDESC, TLSDESC_CALL, and TLSLD.
	Only optimize DTPOFF32 and DTPOFF64 if we have seen a TLS block
	reloc.
@
text
@d429 6
a434 3
      layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
				      elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE,
				      this->got_);
d441 5
a445 3
      layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
				      elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE,
				      this->got_plt_);
@


1.74
log
@2008-05-05  Ian Lance Taylor  <iant@@google.com>

	* options.h (DEFINE_bool): For DASH_Z, create the negative option
	as noVARNAME rather than no-VARNAME.
	(class General_options): Add option -z combreloc.
	* output.h (class Output_reloc) [SHT_REL]: Declare compare and
	get_address.
	(Output_reloc::sort_before) [SHT_REL]: New function.
	(Output_reloc::sort_before) [SHT_RELA]: New function.
	(class Output_data_reloc_base): Add sort_relocs_ field.  Define
	Sort_relocs_comparison.
	(Output_data_reloc_base::Output_data_reloc_base): Add sort_relocs
	parameter.  Change all callers.
	(Output_data_reloc::Output_data_reloc) [both versions]: Add
	sort_relocs parameter.  Change all callers.
	* output.cc (Output_reloc::get_address): New function, broken out
	of write_rel.
	(Output_reloc::write_rel): Call it.
	(Output_reloc::compare): New function.
	(Output_data_reloc_base::do_write): Optionally sort relocs.
@
text
@d1846 1
d1931 2
a1932 1
      if (optimized_type == tls::TLSOPT_TO_LE)
@


1.73
log
@	* i386.cc (Relocate::relocate): Fix typos for R_386_PC16 and
	R_386_PC8 relocations.
@
text
@d465 1
a465 1
      this->rel_dyn_ = new Reloc_section();
d535 1
a535 1
  this->rel_ = new Reloc_section();
@


1.72
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1666 1
a1666 1
          Relocate_functions<32, false>::pcrel32(view, object, psymval, address);
d1681 1
a1681 1
          Relocate_functions<32, false>::pcrel32(view, object, psymval, address);
@


1.71
log
@	* i386.cc (Target_i386::define_tls_base_symbol): New function.
	(Target_i386::tls_base_symbol_defined_): New field.
	(Target_i386::Scan::local): Define _TLS_MODULE_BASE_ symbol.
	(Target_i386::Scan::global): Likewise.
	* symtab.cc (sized_finalize_symbol): Add check for TLS symbol.
	* x86_64.cc (Target_x86_64::define_tls_base_symbol): New function.
	(Target_x86_64::tls_base_symbol_defined_): New field.
	(Target_x86_64::Scan::local): Define _TLS_MODULE_BASE_ symbol.
	(Target_x86_64::Scan::global): Likewise.
@
text
@d884 1
d886 2
a887 5
            {
              unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
              rel_dyn->add_local(object, r_sym, r_type, output_section,
                                 data_shndx, reloc.get_r_offset());
            }
d891 11
a901 3
              rel_dyn->add_local_section(object, lsym.get_st_shndx(),
                                         r_type, output_section,
                                         data_shndx, reloc.get_r_offset());
d984 11
a994 5
                got->add_local_pair_with_rel(object, r_sym, 
                                             lsym.get_st_shndx(),
                                             GOT_TYPE_TLS_PAIR,
                                             target->rel_dyn_section(layout),
                                             elfcpp::R_386_TLS_DTPMOD32, 0);
d1008 11
a1018 5
                got->add_local_pair_with_rel(object, r_sym, 
                                             lsym.get_st_shndx(),
                                             GOT_TYPE_TLS_DESC,
                                             target->rel_dyn_section(layout),
                                             elfcpp::R_386_TLS_DESC, 0);
@


1.70
log
@	* copy-relocs.cc: New file.
	* copy-relocs.h: New file.
	* reloc.cc: Remove Copy_relocs code.
	* reloc.h: Likewise.
	* reloc-types.h (struct Reloc_types) [both versions]: Add
	get_reloc_addend_noerror.
	* output.h (class Output_data_reloc<elfcpp::SHT_REL>): Add
	variants of add_global which take an addend which must be zero.
	* i386.cc: Include "copy-relocs.h".
	(class Target_i386): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_i386::copy_reloc): Rewrite to pass to Copy_relocs class.
	Change all callers.
	(Target_i386::do_finalize_sections): Change handling of
	copy_relocs_.
	* sparc.cc: Include "copy-relocs.h".
	(class Target_sparc): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_sparc::copy_reloc): Rewrite to pass to Copy_relocs class.
	Change all callers.
	(Target_sparc::do_finalize_sections): Change handling of
	copy_relocs_.
	* x86_64.cc: Include "copy-relocs.h".
	(class Target_x86_64): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_x86_64::copy_reloc): Rewrite to pass to Copy_relocs
	class.  Change all callers.
	(Target_x86_64::do_finalize_sections): Change handling of
	copy_relocs_.
	* Makefile.am (CCFILES): Add copy-relocs.cc.
	(HFILES): Add copy-relocs.h.
@
text
@d62 1
a62 1
      got_mod_index_offset_(-1U)
d326 4
d398 2
d728 21
d989 1
d1316 1
@


1.69
log
@	* i386.cc (Target_i386::got_mod_index_entry): Restore code previously
	thought unnecessary.
	* x86_64.cc (Target_x86_64::got_mod_index_entry): Likewise.
@
text
@d35 1
d61 2
a62 1
      copy_relocs_(NULL), dynbss_(NULL), got_mod_index_offset_(-1U)
d354 1
a354 1
  // Copy a relocation against a global symbol.
d356 9
a364 3
  copy_reloc(const General_options*, Symbol_table*, Layout*,
	     Sized_relobj<32, false>*, unsigned int,
	     Output_section*, Symbol*, const elfcpp::Rel<32, false>&);
d389 1
a389 1
  Copy_relocs<32, false>* copy_relocs_;
a741 81
// Handle a relocation against a non-function symbol defined in a
// dynamic object.  The traditional way to handle this is to generate
// a COPY relocation to copy the variable at runtime from the shared
// object into the executable's data segment.  However, this is
// undesirable in general, as if the size of the object changes in the
// dynamic object, the executable will no longer work correctly.  If
// this relocation is in a writable section, then we can create a
// dynamic reloc and the dynamic linker will resolve it to the correct
// address at runtime.  However, we do not want do that if the
// relocation is in a read-only section, as it would prevent the
// readonly segment from being shared.  And if we have to eventually
// generate a COPY reloc, then any dynamic relocations will be
// useless.  So this means that if this is a writable section, we need
// to save the relocation until we see whether we have to create a
// COPY relocation for this symbol for any other relocation.

void
Target_i386::copy_reloc(const General_options* options,
			Symbol_table* symtab,
			Layout* layout,
			Sized_relobj<32, false>* object,
			unsigned int data_shndx,
			Output_section* output_section,
			Symbol* gsym,
			const elfcpp::Rel<32, false>& rel)
{
  Sized_symbol<32>* ssym = symtab->get_sized_symbol<32>(gsym);

  if (!Copy_relocs<32, false>::need_copy_reloc(options, object,
					       data_shndx, ssym))
    {
      // So far we do not need a COPY reloc.  Save this relocation.
      // If it turns out that we never need a COPY reloc for this
      // symbol, then we will emit the relocation.
      if (this->copy_relocs_ == NULL)
	this->copy_relocs_ = new Copy_relocs<32, false>();
      this->copy_relocs_->save(ssym, object, data_shndx, output_section, rel);
    }
  else
    {
      // Allocate space for this symbol in the .bss section.

      elfcpp::Elf_types<32>::Elf_WXword symsize = ssym->symsize();

      // There is no defined way to determine the required alignment
      // of the symbol.  We pick the alignment based on the size.  We
      // set an arbitrary maximum of 256.
      unsigned int align;
      for (align = 1; align < 512; align <<= 1)
	if ((symsize & align) != 0)
	  break;

      if (this->dynbss_ == NULL)
	{
	  this->dynbss_ = new Output_data_space(align);
	  layout->add_output_section_data(".bss",
					  elfcpp::SHT_NOBITS,
					  (elfcpp::SHF_ALLOC
					   | elfcpp::SHF_WRITE),
					  this->dynbss_);
	}

      Output_data_space* dynbss = this->dynbss_;

      if (align > dynbss->addralign())
	dynbss->set_space_alignment(align);

      section_size_type dynbss_size =
	convert_to_section_size_type(dynbss->current_data_size());
      dynbss_size = align_address(dynbss_size, align);
      section_size_type offset = dynbss_size;
      dynbss->set_current_data_size(dynbss_size + symsize);

      symtab->define_with_copy_reloc(ssym, dynbss, offset);

      // Add the COPY reloc.
      Reloc_section* rel_dyn = this->rel_dyn_section(layout);
      rel_dyn->add_global(ssym, elfcpp::R_386_COPY, dynbss, offset);
    }
}

d1084 1
a1084 1
Target_i386::Scan::global(const General_options& options,
d1122 1
a1122 1
	        target->copy_reloc(&options, symtab, layout, object,
d1168 1
a1168 1
	        target->copy_reloc(&options, symtab, layout, object,
d1475 2
a1476 9
  if (this->copy_relocs_ == NULL)
    return;
  if (this->copy_relocs_->any_to_emit())
    {
      Reloc_section* rel_dyn = this->rel_dyn_section(layout);
      this->copy_relocs_->emit(rel_dyn);
    }
  delete this->copy_relocs_;
  this->copy_relocs_ = NULL;
@


1.68
log
@2008-04-11  Cary Coutant  <ccoutant@@google.com>

	Add support for TLS descriptors for i386 and x86_64.
	* i386.cc (Target_i386::Relocate::tls_desc_gd_to_ie): New function.
	(Target_i386::Relocate::tls_desc_gd_to_le): New function.
	(Target_i386::Got_type): Add GOT_TYPE_TLS_NOFFSET and
	GOT_TYPE_TLS_DESC.
	(Target_i386::got_mod_index_entry): Remove unnecessary code.
	(Target_i386::Scan::local): Implement R_386_TLS_GOTDESC and
	R_386_TLS_DESC_CALL relocations.  Fix problem with initial-exec
	relocations.
	(Target_i386::Scan::global): Fix problem with GD-to-IE relaxation.
	Implement R_386_TLS_GOTDESC and R_386_TLS_DESC_CALL relocations;
	Fix problem with initial-exec relocations.
	(Target_i386::Relocate::relocate_tls): Likewise.
	(Target_i386::Relocate::tls_gd_to_ie): Fix problem with GD-to-IE
	relaxation.
	* output.cc (Output_data_dynamic::Dynamic_entry::write): Add
	support for section-plus-offset dynamic table entries.
	* output.h (Output_data_dynamic::add_section_plus_offset): New function.
	(Output_data_dynamic::Dynamic_entry): Add support for
	section-plus-offset dynamic table entries.
	(Output_data_dynamic::Classification): Likewise.
	(Output_data_dynamic::classification_): Renamed offset_.
	* x86_64.cc (Target_x86_64::Relocate::tls_desc_gd_to_ie): New function.
	(Target_x86_64::Relocate::tls_desc_gd_to_le): New function.
	(Target_x86_64::make_plt_section): New function.
	(Target_x86_64::reserve_tlsdesc_entries): New function.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Add new parameter.
	(Output_data_plt_x86_64::reserve_tlsdesc_entry): New function.
	(Output_data_plt_x86_64::has_tlsdesc_entry): New function.
	(Output_data_plt_x86_64::get_tlsdesc_got_offset): New function.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset): New function.
	(Output_data_plt_x86_64::tlsdesc_plt_entry): New field.
	(Output_data_plt_x86_64::set_final_data_size): Move out of line;
	add extra PLT entry for TLS descriptors.
	(Output_data_plt_x86_64::got_): New field.
	(Output_data_plt_x86_64::tlsdesc_got_offset_): New field.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Initialize new
	fields.
	(Output_data_plt_x86_64::do_write): Write extra PLT entry for TLS
	descriptors.
	(Target_x86_64::make_plt_entry): Factor out make_plt_section.
	(Target_x86_64::got_mod_index_entry): Remove unnecessary code.
	(Target_x86_64::Scan::local): Implement R_386_TLS_GOTDESC and
	R_386_TLS_DESC_CALL relocations.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::do_finalize_sections): Add dynamic table entries
	for TLS descriptors.
	(Relocate::relocate_tls): Fix problem with GD-to-IE relaxation.
	Implement R_386_TLS_GOTDESC and R_386_TLS_DESC_CALL relocations.
	(Target_x86_64::Relocate::tls_gd_to_ie): Fix problem with
	GD-to-IE relaxation.
	* configure.ac: Export new conditional variables TLS_GNU2_DIALECT
	and TLS_DESCRIPTORS.
	* Makefile.in: Rebuild.
	* configure: Rebuild.
	* testsuite/Makefile.am (tls_shared_gd_to_ie_test): New target.
	(tls_test_shared2.so): New target.
	(tls_shared_gd_to_ie_test_SOURCES): New variable.
	(tls_shared_gd_to_ie_test_DEPENDENCIES): New variable.
	(tls_shared_gd_to_ie_test_LDFLAGS): New variable.
	(tls_shared_gd_to_ie_test_LDADD): New variable.
	(tls_shared_gnu2_gd_to_ie_test): New target.
	(tls_test_gnu2.o, tls_test_file2_gnu2.o, tls_test_gnu2_shared2.so):
	New targets.
	(tls_shared_gnu2_gd_to_ie_test_SOURCES): New variable.
	(ls_shared_gnu2_gd_to_ie_test_DEPENDENCIES): New variable.
	(tls_shared_gnu2_gd_to_ie_test_LDFLAGS): New variable.
	(tls_shared_gnu2_gd_to_ie_test_LDADD): New variable.
	(tls_shared_gnu2_test): New target.
	(tls_test_gnu2_shared.so): New target.
	(tls_shared_gnu2_test_SOURCES): New variable.
	(tls_shared_gnu2_test_DEPENDENCIES): New variable.
	(tls_shared_gnu2_test_LDFLAGS): New variable.
	(tls_shared_gnu2_test_LDADD): New variable.
	* testsuite/Makefile.in: Rebuild.
	* testsuite/Makefile.
@
text
@d728 1
@


1.67
log
@	* options.h (class General_options): Define --wrap as a special
	option.  Add wrap_symbols_ field.
	(General_options::any_wrap_symbols): New function.
	(General_options::is_wrap_symbol): New function.
	* options.cc (General_options::parse_wrap): New function.
	(General_options::General_options): Initialize wrap_symbols_.
	* symtab.cc (Symbol_table::wrap_symbol): New function.
	(Symbol_table::add_from_object): Handle --wrap.
	* symtab.h (class Symbol_table): Declare wrap_symbol.
	* target.h (Target::wrap_char): New function.
	(Target::Target_info): Add wrap_char field.
	* i386.cc (Target_i386::i386_info): Initialize wrap_char.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Likewise.
@
text
@d239 20
d366 4
a369 3
    GOT_TYPE_TLS_OFFSET = 1,    // GOT entry for TLS offset
    GOT_TYPE_TLS_PAIR = 2,      // GOT entry for TLS module/offset pair
    GOT_TYPE_TLS_DESC = 3       // GOT entry for TLS_DESC pair
d384 1
a384 1
  // Offset of the GOT entry for the TLS module index;
a727 1
      got->add_constant(0);
d1034 16
a1050 4
            // FIXME: If not relaxing to LE, we need to generate
            // a GOT entry with an R_386_TLS_DESC reloc.
            if (optimized_type != tls::TLSOPT_TO_LE)
              unsupported_reloc_local(object, r_type);
d1092 4
a1095 1
                got->add_local_with_rel(object, r_sym, GOT_TYPE_TLS_OFFSET,
d1351 1
a1351 1
                got->add_global_with_rel(gsym, GOT_TYPE_TLS_OFFSET,
d1353 1
a1353 1
                                         elfcpp::R_386_TLS_TPOFF32);
d1360 22
a1382 5
            // FIXME: If not relaxing to LE, we need to generate
            // a GOT entry with an R_386_TLS_DESC reloc.
            if (optimized_type != tls::TLSOPT_TO_LE)
              unsupported_reloc_global(object, r_type, gsym);
            unsupported_reloc_global(object, r_type, gsym);
d1421 4
a1424 1
                got->add_global_with_rel(gsym, GOT_TYPE_TLS_OFFSET,
d1840 3
d1846 2
a1847 3
              gold_assert(gsym->has_got_offset(GOT_TYPE_TLS_PAIR));
              got_offset = (gsym->got_offset(GOT_TYPE_TLS_PAIR)
                            - target->got_size());
d1852 2
a1853 3
              gold_assert(object->local_has_got_offset(r_sym,
                                                       GOT_TYPE_TLS_PAIR));
              got_offset = (object->local_got_offset(r_sym, GOT_TYPE_TLS_PAIR)
d1878 44
d1985 3
d1991 2
a1992 2
              gold_assert(gsym->has_got_offset(GOT_TYPE_TLS_OFFSET));
              got_offset = gsym->got_offset(GOT_TYPE_TLS_OFFSET);
d1997 2
a1998 4
              gold_assert(object->local_has_got_offset(r_sym,
                                                       GOT_TYPE_TLS_OFFSET));
              got_offset = object->local_got_offset(r_sym,
                                                    GOT_TYPE_TLS_OFFSET);
d2108 1
a2108 1
				    Output_segment* tls_segment,
d2130 2
a2131 3
  // FIXME: For now, support only one form.
  tls::check_tls(relinfo, relnum, rel.get_r_offset(),
                 op1 == 0x8d && op2 == 0x04);
a2160 1
  value = tls_segment->memsz() - value;
d2168 77
@


1.66
log
@	* options.cc (options::help): Print list of supported targets.
	* target-select.h: Include <vector>.
	(class Target_selector): Make machine_, size_, and is_big_endian_
	fields const.  Add bfd_name_ and instantiated_target_ fields.
	(Target_selector::Target_selector): Add bfd_name parameter.
	(Target_selector::recognize): Make non-virtual, call
	do_recognize.
	(Target_selector::recognize_by_name): Make non-virtual, call
	do_recognize_by_name.
	(Target_selector::supported_names): New function.
	(Target_selector::bfd_name): New function.
	(Target_selector::do_instantiate_target): New pure virtual
	function.
	(Target_selector::do_recognize): New virtual function.
	(Target_selector::do_recognize_by_name): New virtual function.
	(Target_selector::instantiate_target): New private function.
	(supported_target_names): Declare.
	* target-select.cc (Target_selector::Target_selector): Update for
	new parameter and fields.
	(select_target_by_name): Check that the name matches before
	calling recognize_by_name.
	(supported_target_names): New function.
	* i386.cc (class Target_selector_i386): Update Target_selector
	constructor call.  Remove recognize and recognize_by_name.  Add
	do_instantiate_target.
	* x86_64.cc (class Target_selector_x86_64): Likewise.
	* testsuite/testfile.cc (class Target_selector_test): Update for
	changes to Target_selector.
@
text
@d376 1
@


1.65
log
@	* i386.cc (Target_i386::Got_type): New enum declaration.
	(Target_i386::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocate::relocate_tls): Likewise.
	* object.h (Got_offset_list): New class.
	(Sized_relobj::local_has_got_offset): Added got_type parameter.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::local_has_tls_got_offset): Removed.
	(Sized_relobj::local_tls_got_offset): Removed.
	(Sized_relobj::set_local_tls_got_offset): Removed.
	(Sized_relobj::Local_got_offsets): Changed to store a list of offsets.
	* output.cc (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* output.h (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* resolve.cc (Symbol::override_base_with_special): Removed
	reference to has_got_offset_ field.
	* symtab.cc (Symbol::init_fields): Replaced initialization
	of got_offset_ with got_offsets_.  Removed initialization
	of has_got_offset_
	*symtab.h (Symbol::has_got_offset): Aded got_type parameter.
	(Symbol::got_offset): Likewise.
	(Symbol::set_got_offset): Likewise.
	(Symbol::has_tls_got_offset): Removed.
	(Symbol::tls_got_offset): Removed.
	(Symbol::set_tls_got_offset): Removed.
	(Symbol::got_offset_): Removed.
	(Symbol::tls_mod_got_offset_): Removed.
	(Symbol::tls_pair_got_offset_): Removed.
	(Symbol::got_offsets_): New field.
	(Symbol::has_got_offset): Removed.
	(Symbol::has_tls_mod_got_offset): Removed.
	(Symbol::has_tls_pair_got_offset): Removed.
	* x86_64.cc (Target_x86_64::Got_type): New enum declaration.
	(Target_x86_64::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocate::relocate_tls): Likewise.
@
text
@d2447 1
a2447 1
    : Target_selector(elfcpp::EM_386, 32, false)
d2451 2
a2452 7
  recognize(int machine, int osabi, int abiversion);

  Target*
  recognize_by_name(const char* name);

 private:
  Target_i386* target_;
a2454 21
// Recognize an i386 object file when we already know that the machine
// number is EM_386.

Target*
Target_selector_i386::recognize(int, int, int)
{
  if (this->target_ == NULL)
    this->target_ = new Target_i386();
  return this->target_;
}

Target*
Target_selector_i386::recognize_by_name(const char* name)
{
  if (strcmp(name, "elf32-i386") != 0)
    return NULL;
  if (this->target_ == NULL)
    this->target_ = new Target_i386();
  return this->target_;
}

@


1.64
log
@Update copyright years.  Update language files.
@
text
@d342 9
d945 1
a945 1
        if (got->add_local(object, r_sym))
d953 3
a955 4
                rel_dyn->add_local_relative(object, r_sym,
                                            elfcpp::R_386_RELATIVE,
                                            got,
                                            object->local_got_offset(r_sym));
d1002 5
a1006 4
                got->add_local_tls_with_rel(object, r_sym, 
                                            lsym.get_st_shndx(), true,
                                            target->rel_dyn_section(layout),
                                            elfcpp::R_386_TLS_DTPMOD32);
d1059 1
a1059 1
                got->add_local_with_rel(object, r_sym,
d1222 1
a1222 1
          got->add_global(gsym);
d1231 2
a1232 1
              got->add_global_with_rel(gsym, rel_dyn, elfcpp::R_386_GLOB_DAT);
d1235 4
a1238 3
                if (got->add_global(gsym))
                  rel_dyn->add_global_relative(gsym, elfcpp::R_386_RELATIVE,
                                               got, gsym->got_offset());
d1305 1
a1305 1
                got->add_global_tls_with_rel(gsym,
d1315 2
a1316 1
                got->add_global_with_rel(gsym, target->rel_dyn_section(layout),
d1368 1
a1368 1
                got->add_global_with_rel(gsym,
d1591 3
a1593 2
          gold_assert(gsym->has_got_offset());
          got_offset = gsym->got_offset() - target->got_size();
d1598 3
a1600 2
          gold_assert(object->local_has_got_offset(r_sym));
          got_offset = object->local_got_offset(r_sym) - target->got_size();
d1787 3
a1789 2
              gold_assert(gsym->has_tls_got_offset(true));
              got_offset = gsym->tls_got_offset(true) - target->got_size();
d1794 3
a1796 2
              gold_assert(object->local_has_tls_got_offset(r_sym, true));
              got_offset = (object->local_tls_got_offset(r_sym, true)
d1887 2
a1888 2
              gold_assert(gsym->has_got_offset());
              got_offset = gsym->got_offset();
d1893 4
a1896 2
              gold_assert(object->local_has_got_offset(r_sym));
              got_offset = object->local_got_offset(r_sym);
@


1.63
log
@Remove gcc 3.2 compatibility hacks.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.62
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d729 1
a729 3
  Sized_symbol<32>* ssym;
  ssym = symtab->get_sized_symbol SELECT_SIZE_NAME(32) (gsym
							SELECT_SIZE(32));
@


1.61
log
@Implement -q/--emit-relocs.
@
text
@d132 1
a132 1
  do_code_fill(section_size_type length);
d327 1
a327 1
    return (!parameters->output_is_shared()
d600 1
a600 1
  if (parameters->output_is_shared())
d632 1
a632 1
      if (parameters->output_is_shared())
d795 1
a795 1
  if (parameters->output_is_shared())
d881 1
a881 1
      if (parameters->output_is_position_independent())
d898 1
a898 1
      if (parameters->output_is_position_independent())
d942 1
a942 1
            if (parameters->output_is_position_independent())
d983 1
a983 1
	bool output_is_shared = parameters->output_is_shared();
d1035 1
a1035 1
	            && parameters->output_is_shared())
d1143 1
a1143 1
            if (gsym->is_from_dynobj() && !parameters->output_is_shared())
d1185 1
a1185 1
            if (!parameters->output_is_shared()
d1344 1
a1344 1
	            && parameters->output_is_shared())
d1369 1
a1369 1
	    if (parameters->output_is_shared())
d1471 1
a1471 1
      if (!parameters->output_is_shared())
d1508 1
a1508 1
    return !(parameters->output_is_position_independent()
d1558 1
a1558 1
          || (parameters->output_is_shared()
d1561 1
a1561 1
      && (!is_nonpic || !parameters->output_is_shared()))
d1753 4
a1756 3
  const bool is_final = (gsym == NULL
			 ? !parameters->output_is_position_independent()
			 : gsym->final_value_is_known());
d1899 1
a1899 1
      if (!parameters->output_is_shared())
d1910 1
a1910 1
      if (!parameters->output_is_shared())
d2366 1
a2366 1
Target_i386::do_code_fill(section_size_type length)
@


1.60
log
@From Craig Silverstein: implement -z max-page-size and -z
common-page-size.
@
text
@d2300 1
a2300 1
  gold::scan_relocatable_relocs<32, false, Target_i386, elfcpp::SHT_REL,
d2335 1
a2335 1
  gold::relocate_for_relocatable<32, false, Target_i386, elfcpp::SHT_REL>(
@


1.59
log
@Support selecting target by name.
@
text
@d369 2
a370 2
  0x1000,		// abi_pagesize
  0x1000		// common_pagesize
@


1.58
log
@Support dynamic relocations against local section symbols.
@
text
@d2436 3
d2449 10
@


1.57
log
@From Cary Coutant: fix handling of undefined symbols in shared
libraries.
@
text
@d901 13
a913 3
          unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
          rel_dyn->add_local(object, r_sym, r_type, output_section, data_shndx,
                             reloc.get_r_offset());
d1066 1
@


1.56
log
@Initial -r support.
@
text
@d1210 3
a1212 1
            if (gsym->is_from_dynobj() || gsym->is_preemptible())
d1548 1
a1548 1
              && gsym->is_preemptible()))
@


1.55
log
@From Cary Coutant: Fix a case in which code takes the address of a
function and also calls it directly.
@
text
@d99 31
d274 9
d2192 142
@


1.54
log
@Don't pass around the target in order to define symbols; get it from
the parameters instead.
@
text
@d1092 1
a1092 1
            if (gsym->is_from_dynobj())
@


1.53
log
@From Cary Coutant: Fix mixing PIC and non-PIC relocs in the same
shared library.
@
text
@d361 1
a361 1
      symtab->define_in_output_data(this, "_GLOBAL_OFFSET_TABLE_", NULL,
d738 1
a738 1
      symtab->define_with_copy_reloc(this, ssym, dynbss, offset);
@


1.52
log
@From Cary Coutant: Fix handling of versioned symbols, add some tests.
@
text
@d167 1
a167 2
                              bool is_absolute_ref,
                              bool is_function_call,
d1096 1
a1096 1
        if (gsym->needs_dynamic_reloc(true, false))
d1139 4
a1142 2
        bool is_function_call = (gsym->type() == elfcpp::STT_FUNC);
        if (gsym->needs_dynamic_reloc(false, is_function_call))
d1447 1
a1447 2
                                                 bool is_absolute_ref,
                                                 bool is_function_call,
d1456 1
a1456 1
             && is_absolute_ref
d1459 9
a1467 3
  // For global symbols, we use the same helper routines used in the scan pass.
  return !(gsym->needs_dynamic_reloc(is_absolute_ref, is_function_call)
           && !gsym->can_use_relative_reloc(is_function_call));
d1500 3
d1507 2
a1508 1
      && gsym->has_plt_offset())
d1552 1
a1552 1
      if (should_apply_static_reloc(gsym, true, false, true))
d1558 4
a1561 3
        bool is_function_call = (gsym != NULL
                                 && gsym->type() == elfcpp::STT_FUNC);
        if (should_apply_static_reloc(gsym, false, is_function_call, true))
d1567 1
a1567 1
      if (should_apply_static_reloc(gsym, true, false, false))
d1573 4
a1576 3
        bool is_function_call = (gsym != NULL
                                 && gsym->type() == elfcpp::STT_FUNC);
        if (should_apply_static_reloc(gsym, false, is_function_call, false))
d1582 1
a1582 1
      if (should_apply_static_reloc(gsym, true, false, false))
d1588 4
a1591 3
        bool is_function_call = (gsym != NULL
                                 && gsym->type() == elfcpp::STT_FUNC);
        if (should_apply_static_reloc(gsym, false, is_function_call, false))
@


1.51
log
@Convert more instances of off_t to be 32-bit types.
@
text
@d1586 4
a1589 1
		  || gsym->final_value_is_known());
@


1.50
log
@From Cary Coutant: Set DF_STATIC_TLS as appropriate.
@
text
@d97 1
a97 1
		   off_t view_size);
d101 1
a101 1
  do_code_fill(off_t length);
d109 1
a109 1
  off_t
d179 1
a179 1
	     off_t);
d188 2
a189 1
		 unsigned char*, elfcpp::Elf_types<32>::Elf_Addr, off_t);
d198 1
a198 1
		 off_t view_size);
d207 1
a207 1
		 off_t view_size);
d216 1
a216 1
		 off_t view_size);
d225 1
a225 1
		 off_t view_size);
d477 1
a477 1
  off_t got_offset = this->got_plt_->current_data_size();
d546 2
a547 1
  const off_t oview_size = this->data_size();
d551 2
a552 1
  const off_t got_size = this->got_plt_->data_size();
d614 2
a615 2
  gold_assert(pov - oview == oview_size);
  gold_assert(got_pov - got_view == got_size);
d733 2
a734 1
      off_t dynbss_size = dynbss->current_data_size();
d736 1
a736 1
      off_t offset = dynbss_size;
d1476 1
a1476 1
				off_t view_size)
d1676 1
a1676 1
				    off_t view_size)
d1861 1
a1861 1
				    off_t view_size)
d1892 1
a1892 1
      if (static_cast<off_t>(rel.get_r_offset() + 9) < view_size
d1925 1
a1925 1
				    off_t view_size)
d1958 1
a1958 1
      if (static_cast<off_t>(rel.get_r_offset() + 9) < view_size
d1993 1
a1993 1
				    off_t view_size)
d2025 1
a2025 1
				    off_t view_size)
d2121 1
a2121 1
			      off_t view_size)
d2154 1
a2154 1
Target_i386::do_code_fill(off_t length)
@


1.49
log
@From Cary Coutant: Handle TLS entry for TLS module index.
@
text
@d976 1
d1009 1
d1280 1
d1310 1
@


1.48
log
@From Cary Coutant: Fix handling of RELATIVE RELA relocs.
@
text
@d60 1
a60 1
      copy_relocs_(NULL), dynbss_(NULL)
d264 5
d314 2
d641 20
d964 1
a964 7
                Output_data_got<32, false>* got
                    = target->got_section(symtab, layout);
                unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
                got->add_local_tls_with_rel(object, r_sym,
                                            lsym.get_st_shndx(), false,
                                            target->rel_dyn_section(layout),
                                            elfcpp::R_386_TLS_DTPMOD32);
a1262 2
	    // FIXME: If not relaxing to LE, we need to generate a
	    // DTPMOD32 reloc.
d1266 1
a1266 5
                Output_data_got<32, false>* got
                    = target->got_section(symtab, layout);
                got->add_global_tls_with_rel(gsym,
                                             target->rel_dyn_section(layout),
                                             elfcpp::R_386_TLS_DTPMOD32);
d1755 2
a1756 12
          if (gsym != NULL)
            {
              gold_assert(gsym->has_tls_got_offset(false));
              got_offset = gsym->tls_got_offset(false) - target->got_size();
            }
          else
            {
              unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
              gold_assert(object->local_has_tls_got_offset(r_sym, false));
              got_offset = (object->local_tls_got_offset(r_sym, false)
			    - target->got_size());
            }
d1769 5
a1773 6
      gold_assert(tls_segment != NULL);
      if (this->local_dynamic_type_ == LOCAL_DYNAMIC_GNU)
	value -= tls_segment->memsz();
      else if (optimized_type == tls::TLSOPT_TO_LE
	       && this->local_dynamic_type_ != LOCAL_DYNAMIC_NONE)
	value = tls_segment->memsz() - value;
@


1.47
log
@From Cary Coutant: More support for generating shared libraries.
@
text
@d814 4
a817 2
          rel_dyn->add_local(object, 0, elfcpp::R_386_RELATIVE, output_section,
                             data_shndx, reloc.get_r_offset());
d865 5
a869 2
                rel_dyn->add_local(object, 0, elfcpp::R_386_RELATIVE,
                                   got, object->local_got_offset(r_sym));
d963 6
a968 3
                    rel_dyn->add_local(object, 0, elfcpp::R_386_RELATIVE,
                                       output_section, data_shndx,
                                       reloc.get_r_offset());
d1081 3
a1083 3
                rel_dyn->add_local(object, 0, elfcpp::R_386_RELATIVE,
                                   output_section, data_shndx,
                                   reloc.get_r_offset());
d1147 2
a1148 6
                  {
                    rel_dyn->add_local(object, 0, elfcpp::R_386_RELATIVE,
                                       got, gsym->got_offset());
                    // Make sure we write the link-time value to the GOT.
                    gsym->set_needs_value_in_got();
                  }
d1271 4
a1274 3
                    rel_dyn->add_local(object, 0, elfcpp::R_386_RELATIVE,
                                       output_section, data_shndx,
                                       reloc.get_r_offset());
@


1.46
log
@Clean up setting address and section offset.
@
text
@d795 1
a795 1
			 const elfcpp::Sym<32, false>&)
d859 1
a859 1
            // dynamic RELATIVE relocation for this symbol.
d864 1
a864 2
                                   output_section, data_shndx,
                                   reloc.get_r_offset());
d911 4
a914 12
                if (got->add_local_tls(object, r_sym, true))
	          {
                    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                    unsigned int got_off
                        = object->local_tls_got_offset(r_sym, true);
                    rel_dyn->add_local(object, r_sym,
                                       elfcpp::R_386_TLS_DTPMOD32,
                                       got, got_off);
                    rel_dyn->add_local(object, r_sym,
                                       elfcpp::R_386_TLS_DTPOFF32,
                                       got, got_off + 4);
	          }
d922 4
a925 1
	    unsupported_reloc_local(object, r_type);
d935 4
a938 9
                if (got->add_local_tls(object, r_sym, false))
	          {
                    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                    unsigned int got_off
                        = object->local_tls_got_offset(r_sym, false);
                    rel_dyn->add_local(object, r_sym,
                                       elfcpp::R_386_TLS_DTPMOD32, got,
                                       got_off);
	          }
d952 10
d966 6
a971 11
                if (got->add_local(object, r_sym))
	          {
	            unsigned int dyn_r_type
	                = (r_type == elfcpp::R_386_TLS_IE_32
			   ? elfcpp::R_386_TLS_TPOFF32
			   : elfcpp::R_386_TLS_TPOFF);
                    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                    unsigned int got_off = object->local_got_offset(r_sym);
                    rel_dyn->add_local(object, r_sym, dyn_r_type, got,
                                       got_off);
	          }
d980 10
a989 1
	      unsupported_reloc_local(object, r_type);
d1093 11
a1103 1
          target->make_plt_entry(symtab, layout, gsym);
d1127 4
a1130 2
        if (got->add_global(gsym))
	  {
d1132 5
a1136 2
            // dynamic relocation for it.
            if (!gsym->final_value_is_known())
d1138 1
a1138 6
                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                if (gsym->is_from_dynobj()
		    || gsym->is_preemptible())
		  rel_dyn->add_global(gsym, elfcpp::R_386_GLOB_DAT, got,
				      gsym->got_offset());
                else
d1211 4
a1214 9
                if (got->add_global_tls(gsym, true))
	          {
                    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                    unsigned int got_off = gsym->tls_got_offset(true);
                    rel_dyn->add_global(gsym, elfcpp::R_386_TLS_DTPMOD32,
                                        got, got_off);
                    rel_dyn->add_global(gsym, elfcpp::R_386_TLS_DTPOFF32,
                                        got, got_off + 4);
	          }
d1221 2
a1222 7
                if (got->add_global(gsym))
	          {
                    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                    unsigned int got_off = gsym->got_offset();
                    rel_dyn->add_global(gsym, elfcpp::R_386_TLS_TPOFF32,
                                        got, got_off);
	          }
d1230 4
d1245 3
a1247 7
                if (got->add_global_tls(gsym, false))
	          {
                    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                    unsigned int got_off = gsym->tls_got_offset(false);
                    rel_dyn->add_global(gsym, elfcpp::R_386_TLS_DTPMOD32,
                                        got, got_off);
	          }
d1261 10
d1274 6
a1279 10
                if (got->add_global(gsym))
	          {
	            unsigned int dyn_r_type
		      = (r_type == elfcpp::R_386_TLS_IE_32
			 ? elfcpp::R_386_TLS_TPOFF32
			 : elfcpp::R_386_TLS_TPOFF);
                    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                    unsigned int got_off = gsym->got_offset();
                    rel_dyn->add_global(gsym, dyn_r_type, got, got_off);
	          }
d1288 9
a1296 1
	      unsupported_reloc_global(object, r_type, gsym);
d1690 2
a1691 3
	      this->tls_gd_to_ie(relinfo, relnum, tls_segment,
                                 rel, r_type, got_offset, view,
                                 view_size);
d1760 5
a1764 7
      if (optimized_type != tls::TLSOPT_TO_LE
	  || this->local_dynamic_type_ == LOCAL_DYNAMIC_NONE)
	value = value - tls_segment->vaddr();
      else if (this->local_dynamic_type_ == LOCAL_DYNAMIC_GNU)
	value = value - (tls_segment->vaddr() + tls_segment->memsz());
      else
	value = tls_segment->vaddr() + tls_segment->memsz() - value;
d1810 8
a1817 3
      gold_assert(tls_segment != NULL);
      value = value - (tls_segment->vaddr() + tls_segment->memsz());
      Relocate_functions<32, false>::rel32(view, value);
d1821 8
a1828 3
      gold_assert(tls_segment != NULL);
      value = tls_segment->vaddr() + tls_segment->memsz() - value;
      Relocate_functions<32, false>::rel32(view, value);
d1889 1
a1889 1
  value = tls_segment->vaddr() + tls_segment->memsz() - value;
d1897 1
a1897 1
// Do a relocation in which we convert a TLS General-Dynamic to a
d1957 1
a1957 1
  value = tls_segment->vaddr() + tls_segment->memsz() - value;
d2086 1
a2086 1
  value = tls_segment->vaddr() + tls_segment->memsz() - value;
@


1.45
log
@From Cary Coutant: Count textrel with output sections rather than
setting a flag as we add each reloc in the target code.
@
text
@d351 1
a351 1
      this->got_plt_->set_space_size(3 * 4);
d420 1
a420 1
  do_set_address(uint64_t, off_t)
d469 1
a469 1
  off_t got_offset = this->got_plt_->data_size();
d474 1
a474 1
  this->got_plt_->set_space_size(got_offset + 4);
d703 1
a703 1
      off_t dynbss_size = dynbss->data_size();
d706 1
a706 1
      dynbss->set_space_size(dynbss_size + symsize);
@


1.44
log
@From Craig Silverstein: Add support for --demangle.
@
text
@d291 1
a291 1
	     Symbol*, const elfcpp::Rel<32, false>&);
d655 3
a657 1
			unsigned int data_shndx, Symbol* gsym,
d672 1
a672 1
      this->copy_relocs_->save(ssym, object, data_shndx, rel);
d814 2
a815 4
          rel_dyn->add_local(object, 0, elfcpp::R_386_RELATIVE, data_shndx,
                             reloc.get_r_offset());
          if (!output_section->is_section_flag_set(elfcpp::SHF_WRITE))
	    layout->set_have_textrel();
d830 1
a830 1
          rel_dyn->add_local(object, r_sym, r_type, data_shndx,
a831 2
          if (!output_section->is_section_flag_set(elfcpp::SHF_WRITE))
	    layout->set_have_textrel();
d864 2
a865 3
                                   data_shndx, reloc.get_r_offset());
                if (!output_section->is_section_flag_set(elfcpp::SHF_WRITE))
		  layout->set_have_textrel();
d1064 1
a1064 1
	                           data_shndx, gsym, reloc);
d1071 2
a1072 3
                                   data_shndx, reloc.get_r_offset());
                if (!output_section->is_section_flag_set(elfcpp::SHF_WRITE))
		  layout->set_have_textrel();
d1077 2
a1078 4
                rel_dyn->add_global(gsym, r_type, object, data_shndx, 
                                    reloc.get_r_offset());
                if (!output_section->is_section_flag_set(elfcpp::SHF_WRITE))
		  layout->set_have_textrel();
d1098 1
a1098 1
	                           data_shndx, gsym, reloc);
d1103 2
a1104 4
                rel_dyn->add_global(gsym, r_type, object, data_shndx, 
                                    reloc.get_r_offset());
                if (!output_section->is_section_flag_set(elfcpp::SHF_WRITE))
		  layout->set_have_textrel();
@


1.43
log
@From Cary Coutant: Improve i386 shared library TLS support.
@
text
@d1022 1
a1022 1
	     object->name().c_str(), r_type, gsym->name());
@


1.42
log
@Add heuristics for undefined symbol warnings.
@
text
@d125 1
d134 1
d184 2
a185 2
    relocate_tls(const Relocate_info<32, false>*, size_t relnum,
		 const elfcpp::Rel<32, false>&,
d190 9
d790 1
d814 2
d832 2
d867 2
d908 24
d934 1
a934 4
	    // FIXME: If not relaxing to LE, we need to generate
	    // DTPMOD32 and DTPOFF32 relocs.
	    if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_local(object, r_type);
d938 17
a954 3
	    // FIXME: If not relaxing to LE, we need to generate a
	    // DTPMOD32 reloc.
	    if (optimized_type != tls::TLSOPT_TO_LE)
d964 19
a982 3
	    // FIXME: If not relaxing to LE, we need to generate a
	    // TPOFF or TPOFF32 reloc.
	    if (optimized_type != tls::TLSOPT_TO_LE)
d988 2
a989 3
	    // FIXME: If generating a shared object, we need to copy
	    // this relocation into the object.
	    gold_assert(!output_is_shared);
d1034 1
d1066 2
a1067 2
	        target->copy_reloc(&options, symtab, layout, object, data_shndx,
                                   gsym, reloc);
d1073 4
a1076 2
                rel_dyn->add_local(object, 0, elfcpp::R_386_RELATIVE, data_shndx,
                                   reloc.get_r_offset());
d1083 2
d1103 2
a1104 2
	        target->copy_reloc(&options, symtab, layout, object, data_shndx,
                                   gsym, reloc);
d1111 2
d1200 33
d1235 1
a1235 4
	    // FIXME: If not relaxing to LE, we need to generate
	    // DTPMOD32 and DTPOFF32 relocs.
	    if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_global(object, r_type, gsym);
d1241 14
a1254 1
	    if (optimized_type != tls::TLSOPT_TO_LE)
d1264 17
a1280 3
	    // FIXME: If not relaxing to LE, we need to generate a
	    // TPOFF or TPOFF32 reloc.
	    if (optimized_type != tls::TLSOPT_TO_LE)
d1286 2
a1287 3
	    // FIXME: If generating a shared object, we need to copy
	    // this relocation into the object.
	    gold_assert(!parameters->output_is_shared());
d1487 1
d1603 2
a1604 2
      this->relocate_tls(relinfo, relnum, rel, r_type, gsym, psymval, view,
			 address, view_size);
d1631 1
a1641 6
  if (tls_segment == NULL)
    {
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			     _("TLS reloc but no TLS segment"));
      return;
    }
d1643 3
a1645 1
  elfcpp::Elf_types<32>::Elf_Addr value = psymval->value(relinfo->object, 0);
d1657 1
d1663 31
d1717 1
d1722 20
d1751 1
d1767 1
d1773 25
d1804 1
d1810 1
d1868 68
@


1.41
log
@Revert last patch.
@
text
@d103 5
@


1.40
log
@Support special always-defined symbols for targets.
@
text
@a86 5
  // Return whether SYM is always defined.
  bool
  do_is_always_defined(Symbol* sym) const
  { return strcmp(sym->name(), "___tls_get_addr") == 0; }

@


1.39
log
@Correct handling of GOT references in a regular object.
@
text
@d87 5
@


1.38
log
@From Cary Coutant: More shared library support, some refactorization.
@
text
@d1049 4
a1052 3
                if (gsym->is_preemptible())
                    rel_dyn->add_global(gsym, elfcpp::R_386_GLOB_DAT, got,
                                        gsym->got_offset());
@


1.37
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d160 2
a161 1
                              bool is_pcrel,
d260 11
a785 2
    case elfcpp::R_386_16:
    case elfcpp::R_386_8:
d795 18
a812 9
          if (r_type == elfcpp::R_386_32)
            rel_dyn->add_local(object, 0, elfcpp::R_386_RELATIVE, data_shndx,
                               reloc.get_r_offset());
          else
            {
              unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
              rel_dyn->add_local(object, r_sym, r_type, data_shndx,
                                 reloc.get_r_offset());
            }
a972 1
    case elfcpp::R_386_PC32:
a973 1
    case elfcpp::R_386_PC16:
a974 1
    case elfcpp::R_386_PC8:
d976 28
a1003 39
        bool is_pcrel = (r_type == elfcpp::R_386_PC32
		         || r_type == elfcpp::R_386_PC16
		         || r_type == elfcpp::R_386_PC8);

        if (gsym->is_from_dynobj()
            || (parameters->output_is_shared()
                && gsym->is_preemptible()))
	  {
	    // (a) This symbol is defined in a dynamic object.  If it is a
	    // function, we make a PLT entry.  Otherwise we need to
	    // either generate a COPY reloc or copy this reloc.
	    // (b) We are building a shared object and this symbol is
	    // preemptible. If it is a function, we make a PLT entry.
	    // Otherwise, we copy the reloc.
	    if (gsym->type() == elfcpp::STT_FUNC)
	      {
	        target->make_plt_entry(symtab, layout, gsym);
  
	        // If this is not a PC relative reference, then we may
	        // be taking the address of the function.  In that case
	        // we need to set the entry in the dynamic symbol table
	        // to the address of the PLT entry. We will also need to
	        // create a dynamic relocation.
	        if (!is_pcrel)
		  {
		    if (gsym->is_from_dynobj())
		      gsym->set_needs_dynsym_value();
                    if (parameters->output_is_position_independent())
                      {
                        Reloc_section* rel_dyn =
                          target->rel_dyn_section(layout);
                        rel_dyn->add_global(gsym, r_type, object, data_shndx, 
                                            reloc.get_r_offset());
                      }
		  }
	      }
	    else if (parameters->output_is_shared())
	      {
	        // We do not make COPY relocs in shared objects.
d1007 15
a1021 6
	      }
	    else
	      target->copy_reloc(&options, symtab, layout, object, data_shndx,
			         gsym, reloc);
	  }
        else if (!is_pcrel && parameters->output_is_position_independent())
d1023 5
a1027 7
            // This is not a PC-relative reference, so we need to generate
            // a dynamic relocation. At this point, we know the symbol
            // is not preemptible, so we can use the RELATIVE relocation.
            Reloc_section* rel_dyn = target->rel_dyn_section(layout);
            if (r_type == elfcpp::R_386_32)
              rel_dyn->add_local(object, 0, elfcpp::R_386_RELATIVE, data_shndx,
                                 reloc.get_r_offset());
d1029 5
a1033 2
              rel_dyn->add_global(gsym, r_type, object, data_shndx, 
                                  reloc.get_r_offset());
d1049 10
a1058 2
                rel_dyn->add_global(gsym, elfcpp::R_386_GLOB_DAT, got,
                                    gsym->got_offset());
d1272 2
a1273 1
                                                 bool is_pcrel,
d1276 4
a1279 2
  // For local symbols, return FALSE if a non-RELATIVE dynamic
  // relocation was created; return TRUE otherwise.
d1281 7
a1287 24
    return (!parameters->output_is_position_independent() || is_32bit);

  // For global symbols, mimic the logic in Scan::global()
  // to decide whether a non-RELATIVE dynamic relocation was
  // created.
  // FIXME: This is ugly. Try to refactor this logic so it can be
  // shared by Scan::global() and Relocate::relocate().
  if (gsym->is_from_dynobj()
      || (parameters->output_is_shared()
          && gsym->is_preemptible()))
    {
      if (gsym->type() == elfcpp::STT_FUNC)
	{
	  if (!is_pcrel && parameters->output_is_position_independent())
            return false;
	}
      else
	return false;
    }
  else if (!is_pcrel && parameters->output_is_position_independent())
    return is_32bit;

  // For all other cases, return TRUE 
  return true;
d1367 1
a1367 1
      if (should_apply_static_reloc(gsym, false, true))
d1372 6
a1377 2
      if (should_apply_static_reloc(gsym, true, true))
        Relocate_functions<32, false>::pcrel32(view, object, psymval, address);
d1381 1
a1381 1
      if (should_apply_static_reloc(gsym, false, false))
d1386 6
a1391 2
      if (should_apply_static_reloc(gsym, true, false))
        Relocate_functions<32, false>::pcrel16(view, object, psymval, address);
d1395 1
a1395 1
      if (should_apply_static_reloc(gsym, false, false))
d1400 6
a1405 2
      if (should_apply_static_reloc(gsym, true, false))
        Relocate_functions<32, false>::pcrel8(view, object, psymval, address);
@


1.36
log
@From Cary Coutant: Correct generation of RELATIVE relocs.
@
text
@d73 2
d76 1
a76 2
	      const unsigned char* plocal_symbols,
	      Symbol** global_symbols);
d93 2
d1163 2
d1166 1
a1166 2
			 const unsigned char* plocal_symbols,
			 Symbol** global_symbols)
d1185 2
d1188 1
a1188 2
    plocal_symbols,
    global_symbols);
d1778 2
d1792 2
@


1.35
log
@From Cary Coutant: More support for -shared, including fixes to GOT
handling.
@
text
@d154 6
a780 3
	  // FIXME: R_386_RELATIVE only works for a 32-bit relocation.
	  gold_assert(r_type != elfcpp::R_386_16 && r_type != elfcpp::R_386_8);

d782 9
a790 2
          rel_dyn->add_local(object, 0, elfcpp::R_386_RELATIVE, data_shndx,
                             reloc.get_r_offset());
a985 5
			// FIXME: If this is an 8-bit or 16-bit
			// relocation, R_386_RELATIVE won't work.
			gold_assert(r_type != elfcpp::R_386_16
				    && r_type != elfcpp::R_386_8);

d988 2
a989 2
                        rel_dyn->add_local(object, 0, elfcpp::R_386_RELATIVE,
                                           data_shndx, reloc.get_r_offset());
a1005 5
	    // FIXME: If this is an 8-bit or 16-bit relocation,
	    // R_386_RELATIVE won't work.
	    gold_assert(r_type != elfcpp::R_386_16
			&& r_type != elfcpp::R_386_8);

d1007 2
a1008 1
            // a dynamic relocation.
d1010 6
a1015 2
            rel_dyn->add_local(object, 0, elfcpp::R_386_RELATIVE, data_shndx,
                               reloc.get_r_offset());
d1236 40
d1353 2
a1354 1
      Relocate_functions<32, false>::rel32(view, object, psymval);
d1358 2
a1359 1
      Relocate_functions<32, false>::pcrel32(view, object, psymval, address);
d1363 2
a1364 1
      Relocate_functions<32, false>::rel16(view, object, psymval);
d1368 2
a1369 1
      Relocate_functions<32, false>::pcrel16(view, object, psymval, address);
d1373 2
a1374 1
      Relocate_functions<32, false>::rel8(view, object, psymval);
d1378 2
a1379 1
      Relocate_functions<32, false>::pcrel8(view, object, psymval, address);
@


1.34
log
@From Craig Silverstein: better organization for TLS code.
@
text
@d100 8
d226 8
d775 3
d946 67
a1012 36
      if (gsym->is_from_dynobj()
          || (parameters->output_is_shared()
              && gsym->is_preemptible()))
	{
	  // (a) This symbol is defined in a dynamic object.  If it is a
	  // function, we make a PLT entry.  Otherwise we need to
	  // either generate a COPY reloc or copy this reloc.
	  // (b) We are building a shared object and this symbol is
	  // preemptible. If it is a function, we make a PLT entry.
	  // Otherwise, we copy the reloc. We do not make COPY relocs
	  // in shared objects.
	  if (gsym->type() == elfcpp::STT_FUNC)
	    {
	      target->make_plt_entry(symtab, layout, gsym);

	      // If this is not a PC relative reference, then we may
	      // be taking the address of the function.  In that case
	      // we need to set the entry in the dynamic symbol table
	      // to the address of the PLT entry.
	      if (r_type != elfcpp::R_386_PC32
		  && r_type != elfcpp::R_386_PC16
		  && r_type != elfcpp::R_386_PC8
		  && gsym->is_from_dynobj())
		gsym->set_needs_dynsym_value();
	    }
	  else if (parameters->output_is_shared())
	    {
              Reloc_section* rel_dyn = target->rel_dyn_section(layout);
              rel_dyn->add_global(gsym, r_type, object, data_shndx, 
                                  reloc.get_r_offset());
	    }
	  else
	    target->copy_reloc(&options, symtab, layout, object, data_shndx,
			       gsym, reloc);
	}

d1275 3
d1286 1
a1286 1
          got_offset = gsym->got_offset();
d1291 1
a1291 1
          got_offset = object->local_got_offset(r_sym);
d1347 1
a1347 1
		 - target->got_section(NULL, NULL)->address());
d1355 1
a1355 1
	value = target->got_section(NULL, NULL)->address();
@


1.33
log
@Add support for PT_GNU_STACK.
@
text
@d165 3
a167 3
    // Do a TLS Initial-Exec to Local-Exec transition.
    static inline void
    tls_ie_to_le(const Relocate_info<32, false>*, size_t relnum,
d174 1
a174 1
    // Do a TLS General-Dynamic to Local-Exec transition.
d176 1
a176 1
    tls_gd_to_le(const Relocate_info<32, false>*, size_t relnum,
d183 3
a185 3
    // Do a TLS Local-Dynamic to Local-Exec transition.
    inline void
    tls_ld_to_le(const Relocate_info<32, false>*, size_t relnum,
d817 7
a823 1
    case elfcpp::R_386_TLS_IE:
d825 1
a825 5
    case elfcpp::R_386_TLS_LE:
    case elfcpp::R_386_TLS_GD:
    case elfcpp::R_386_TLS_LDM:
    case elfcpp::R_386_TLS_LDO_32:
    case elfcpp::R_386_TLS_IE_32:
a826 2
    case elfcpp::R_386_TLS_GOTDESC:
    case elfcpp::R_386_TLS_DESC_CALL:
d833 5
a837 12
	  case elfcpp::R_386_TLS_LE:
	  case elfcpp::R_386_TLS_LE_32:
	    // FIXME: If generating a shared object, we need to copy
	    // this relocation into the object.
	    gold_assert(!output_is_shared);
	    break;

	  case elfcpp::R_386_TLS_IE:
	  case elfcpp::R_386_TLS_IE_32:
	  case elfcpp::R_386_TLS_GOTIE:
	    // FIXME: If not relaxing to LE, we need to generate a
	    // TPOFF or TPOFF32 reloc.
d842 1
a842 1
	  case elfcpp::R_386_TLS_LDM:
d849 1
a849 1
	  case elfcpp::R_386_TLS_LDO_32:
d852 5
a856 5
	  case elfcpp::R_386_TLS_GD:
	  case elfcpp::R_386_TLS_GOTDESC:
	  case elfcpp::R_386_TLS_DESC_CALL:
	    // FIXME: If not relaxing to LE, we need to generate
	    // DTPMOD32 and DTPOFF32 relocs.
d861 7
d1021 7
a1027 1
    case elfcpp::R_386_TLS_IE:
d1029 1
a1029 5
    case elfcpp::R_386_TLS_LE:
    case elfcpp::R_386_TLS_GD:
    case elfcpp::R_386_TLS_LDM:
    case elfcpp::R_386_TLS_LDO_32:
    case elfcpp::R_386_TLS_IE_32:
a1030 2
    case elfcpp::R_386_TLS_GOTDESC:
    case elfcpp::R_386_TLS_DESC_CALL:
d1037 5
a1041 12
	  case elfcpp::R_386_TLS_LE:
	  case elfcpp::R_386_TLS_LE_32:
	    // FIXME: If generating a shared object, we need to copy
	    // this relocation into the object.
	    gold_assert(!parameters->output_is_shared());
	    break;

	  case elfcpp::R_386_TLS_IE:
	  case elfcpp::R_386_TLS_IE_32:
	  case elfcpp::R_386_TLS_GOTIE:
	    // FIXME: If not relaxing to LE, we need to generate a
	    // TPOFF or TPOFF32 reloc.
d1046 1
a1046 1
	  case elfcpp::R_386_TLS_LDM:
d1053 1
a1053 1
	  case elfcpp::R_386_TLS_LDO_32:
d1056 5
a1060 5
	  case elfcpp::R_386_TLS_GD:
	  case elfcpp::R_386_TLS_GOTDESC:
	  case elfcpp::R_386_TLS_DESC_CALL:
	    // FIXME: If not relaxing to LE, we need to generate
	    // DTPMOD32 and DTPOFF32 relocs.
d1065 7
d1325 7
a1331 1
    case elfcpp::R_386_TLS_IE:
d1333 1
a1333 5
    case elfcpp::R_386_TLS_LE:
    case elfcpp::R_386_TLS_GD:
    case elfcpp::R_386_TLS_LDM:
    case elfcpp::R_386_TLS_LDO_32:
    case elfcpp::R_386_TLS_IE_32:
a1334 2
    case elfcpp::R_386_TLS_GOTDESC:
    case elfcpp::R_386_TLS_DESC_CALL:
d1389 1
a1389 13
    case elfcpp::R_386_TLS_LE_32:
      value = tls_segment->vaddr() + tls_segment->memsz() - value;
      Relocate_functions<32, false>::rel32(view, value);
      break;

    case elfcpp::R_386_TLS_LE:
      value = value - (tls_segment->vaddr() + tls_segment->memsz());
      Relocate_functions<32, false>::rel32(view, value);
      break;

    case elfcpp::R_386_TLS_IE:
    case elfcpp::R_386_TLS_GOTIE:
    case elfcpp::R_386_TLS_IE_32:
d1392 3
a1394 3
	  Target_i386::Relocate::tls_ie_to_le(relinfo, relnum, tls_segment,
					      rel, r_type, value, view,
					      view_size);
d1402 2
a1403 8
    case elfcpp::R_386_TLS_GD:
      if (optimized_type == tls::TLSOPT_TO_LE)
	{
	  this->tls_gd_to_le(relinfo, relnum, tls_segment,
			     rel, r_type, value, view,
			     view_size);
	  break;
	}
d1409 1
a1409 1
    case elfcpp::R_386_TLS_LDM:
d1429 1
a1429 1
    case elfcpp::R_386_TLS_LDO_32:
d1443 10
a1452 2
    case elfcpp::R_386_TLS_GOTDESC:
    case elfcpp::R_386_TLS_DESC_CALL:
a1456 2
    }
}
d1458 4
a1461 2
// Do a relocation in which we convert a TLS Initial-Exec to a
// Local-Exec.
d1463 4
a1466 84
inline void
Target_i386::Relocate::tls_ie_to_le(const Relocate_info<32, false>* relinfo,
				    size_t relnum,
				    Output_segment* tls_segment,
				    const elfcpp::Rel<32, false>& rel,
				    unsigned int r_type,
				    elfcpp::Elf_types<32>::Elf_Addr value,
				    unsigned char* view,
				    off_t view_size)
{
  // We have to actually change the instructions, which means that we
  // need to examine the opcodes to figure out which instruction we
  // are looking at.
  if (r_type == elfcpp::R_386_TLS_IE)
    {
      // movl %gs:XX,%eax  ==>  movl $YY,%eax
      // movl %gs:XX,%reg  ==>  movl $YY,%reg
      // addl %gs:XX,%reg  ==>  addl $YY,%reg
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, -1);
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, 4);

      unsigned char op1 = view[-1];
      if (op1 == 0xa1)
	{
	  // movl XX,%eax  ==>  movl $YY,%eax
	  view[-1] = 0xb8;
	}
      else
	{
	  tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, -2);

	  unsigned char op2 = view[-2];
	  if (op2 == 0x8b)
	    {
	      // movl XX,%reg  ==>  movl $YY,%reg
	      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
                             (op1 & 0xc7) == 0x05);
	      view[-2] = 0xc7;
	      view[-1] = 0xc0 | ((op1 >> 3) & 7);
	    }
	  else if (op2 == 0x03)
	    {
	      // addl XX,%reg  ==>  addl $YY,%reg
	      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
                             (op1 & 0xc7) == 0x05);
	      view[-2] = 0x81;
	      view[-1] = 0xc0 | ((op1 >> 3) & 7);
	    }
	  else
	    tls::check_tls(relinfo, relnum, rel.get_r_offset(), 0);
	}
    }
  else
    {
      // subl %gs:XX(%reg1),%reg2  ==>  subl $YY,%reg2
      // movl %gs:XX(%reg1),%reg2  ==>  movl $YY,%reg2
      // addl %gs:XX(%reg1),%reg2  ==>  addl $YY,$reg2
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, -2);
      tls::check_range(relinfo, relnum, rel.get_r_offset(), view_size, 4);

      unsigned char op1 = view[-1];
      unsigned char op2 = view[-2];
      tls::check_tls(relinfo, relnum, rel.get_r_offset(),
                     (op1 & 0xc0) == 0x80 && (op1 & 7) != 4);
      if (op2 == 0x8b)
	{
	  // movl %gs:XX(%reg1),%reg2  ==>  movl $YY,%reg2
	  view[-2] = 0xc7;
	  view[-1] = 0xc0 | ((op1 >> 3) & 7);
	}
      else if (op2 == 0x2b)
	{
	  // subl %gs:XX(%reg1),%reg2  ==>  subl $YY,%reg2
	  view[-2] = 0x81;
	  view[-1] = 0xe8 | ((op1 >> 3) & 7);
	}
      else if (op2 == 0x03)
	{
	  // addl %gs:XX(%reg1),%reg2  ==>  addl $YY,$reg2
	  view[-2] = 0x81;
	  view[-1] = 0xc0 | ((op1 >> 3) & 7);
	}
      else
	tls::check_tls(relinfo, relnum, rel.get_r_offset(), 0);
a1467 6

  value = tls_segment->vaddr() + tls_segment->memsz() - value;
  if (r_type == elfcpp::R_386_TLS_IE || r_type == elfcpp::R_386_TLS_GOTIE)
    value = - value;

  Relocate_functions<32, false>::rel32(view, value);
d1564 96
@


1.32
log
@Fix versions of copied symbols.
@
text
@d266 1
@


1.31
log
@Handle PLT32 against local symbols.
@
text
@d652 1
a652 5
      // Define the symbol in the .dynbss section.
      symtab->define_in_output_data(this, ssym->name(), ssym->version(),
				    dynbss, offset, symsize, ssym->type(),
				    ssym->binding(), ssym->visibility(),
				    ssym->nonvis(), false, false);
a654 1
      ssym->set_needs_dynsym_entry();
@


1.30
log
@From Cary Coutant: preliminary shared library support.
@
text
@d774 5
a877 1
    case elfcpp::R_386_PLT32:
d1283 3
a1285 2
      gold_assert(gsym->has_plt_offset()
                 || gsym->final_value_is_known());
@


1.29
log
@From Craig Silverstein: implement -Ttext.
@
text
@d755 12
a766 3
      // FIXME: If we are generating a shared object we need to copy
      // this relocation into the object.
      gold_assert(!parameters->output_is_shared());
d789 1
a789 1
            if (parameters->output_is_shared())
d927 3
a929 7
      // FIXME: If we are generating a shared object we may need to
      // copy this relocation into the object.  If this symbol is
      // defined in a shared object, we may need to copy this
      // relocation in order to avoid a COPY relocation.
      gold_assert(!parameters->output_is_shared());

      if (gsym->is_from_dynobj())
d931 1
a931 1
	  // This symbol is defined in a dynamic object.  If it is a
d934 4
d948 2
a949 1
		  && r_type != elfcpp::R_386_PC8)
d952 6
d988 7
d1211 5
a1215 1
  if (gsym != NULL && gsym->is_from_dynobj() && gsym->has_plt_offset())
d1280 1
a1280 1
		  || gsym->final_value_is_known());
d1382 1
a1382 1
			 ? !parameters->output_is_shared()
@


1.28
log
@From Craig Silverstein: support local GOT relocs for i386.
@
text
@d267 1
a267 1
  0x08048000,		// text_segment_address
@


1.27
log
@Remove extraneous newlines.
@
text
@d740 2
a741 2
			 unsigned int,
			 const elfcpp::Rel<32, false>&,
d771 19
a863 1
    case elfcpp::R_386_GOT32:
d1197 23
d1258 2
a1259 4
      // Local GOT offsets not yet supported.
      gold_assert(gsym);
      gold_assert(gsym->has_got_offset());
      Relocate_functions<32, false>::rel32(view, gsym->got_offset());
@


1.26
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d782 1
a782 1
      gold_error(_("%s: unexpected reloc %u in object file\n"),
@


1.25
log
@From Craig Silverstein: use tls.h in x86_64.cc.
@
text
@d142 1
a142 3
	  fprintf(stderr, _("%s: missing expected TLS relocation\n"),
		  program_name);
	  gold_exit(false);
d728 2
a729 2
  fprintf(stderr, _("%s: %s: unsupported reloc %u against local symbol\n"),
	  program_name, object->name().c_str(), r_type);
d782 2
a783 3
      fprintf(stderr, _("%s: %s: unexpected reloc %u in object file\n"),
	      program_name, object->name().c_str(), r_type);
      gold_exit(false);
d870 2
a871 3
  fprintf(stderr,
	  _("%s: %s: unsupported reloc %u against global symbol %s\n"),
	  program_name, object->name().c_str(), r_type, gsym->name());
d974 2
a975 3
      fprintf(stderr, _("%s: %s: unexpected reloc %u in object file\n"),
	      program_name, object->name().c_str(), r_type);
      gold_exit(false);
d1070 3
a1072 3
      fprintf(stderr, _("%s: %s: unsupported RELA reloc section\n"),
	      program_name, object->name().c_str());
      gold_exit(false);
d1159 3
d1163 2
a1164 4
	  fprintf(stderr, _("%s: %s: missing expected TLS relocation\n"),
		  program_name,
		  relinfo->location(relnum, rel.get_r_offset()).c_str());
	  gold_exit(false);
a1165 4

      this->skip_call_tls_get_addr_ = false;

      return false;
d1251 3
a1253 5
      fprintf(stderr, _("%s: %s: unexpected reloc %u in object file\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str(),
	      r_type);
      gold_exit(false);
d1283 3
a1285 5
      fprintf(stderr, _("%s: %s: unsupported reloc %u\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str(),
	      r_type);
      gold_exit(false);
d1308 3
a1310 4
      fprintf(stderr, _("%s: %s: TLS reloc but no TLS segment\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str());
      gold_exit(false);
d1342 3
a1344 5
      fprintf(stderr, _("%s: %s: unsupported reloc %u\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str(),
	      r_type);
      gold_exit(false);
d1355 3
a1357 5
      fprintf(stderr, _("%s: %s: unsupported reloc %u\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str(),
	      r_type);
      gold_exit(false);
d1363 4
a1366 5
	  fprintf(stderr,
		  _("%s: %s: both SUN and GNU model TLS relocations\n"),
		  program_name,
		  relinfo->location(relnum, rel.get_r_offset()).c_str());
	  gold_exit(false);
d1375 3
a1377 5
      fprintf(stderr, _("%s: %s: unsupported reloc %u\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str(),
	      r_type);
      gold_exit(false);
d1396 3
a1398 5
      fprintf(stderr, _("%s: %s: unsupported reloc %u\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str(),
	      r_type);
      gold_exit(false);
@


1.24
log
@From Andrew Chatham: exit on relocation error.
@
text
@d48 3
d176 1
a176 1
    // Do a TLS Global-Dynamic to Local-Exec transition.
d684 1
a684 1
      // These are Global-Dynamic which permits fully general TLS
d1521 1
a1521 1
// Do a relocation in which we convert a TLS Global-Dynamic to a
@


1.23
log
@From Craig Silverstein: add tls.h, use it in i386.cc.
@
text
@d1294 1
a1294 1
      // gold_exit(false);
d1356 1
a1356 1
      // gold_exit(false);
d1371 1
a1371 1
      // gold_exit(false);
d1394 1
a1394 1
      // gold_exit(false);
d1417 1
a1417 1
      // gold_exit(false);
@


1.22
log
@Add support for local dynamic relocations.
@
text
@d38 1
d116 7
a190 10
    // Check the range for a TLS relocation.
    static inline void
    check_range(const Relocate_info<32, false>*, size_t relnum,
		const elfcpp::Rel<32, false>&, off_t, off_t);

    // Check the validity of a TLS relocation.  This is like assert.
    static inline void
    check_tls(const Relocate_info<32, false>*, size_t relnum,
	      const elfcpp::Rel<32, false>&, bool);

d210 1
a210 1
  static unsigned int
d668 1
a668 1
unsigned int
d674 1
a674 1
    return r_type;
d686 2
a687 2
	return elfcpp::R_386_TLS_LE_32;
      return elfcpp::R_386_TLS_IE_32;
d693 1
a693 1
      return elfcpp::R_386_TLS_LE_32;
d696 2
a697 4
      // Another type of Local-Dynamic relocation.  We return a
      // different value as we need to negate the thread segment
      // offset.  FIXME: Returning reloc types makes no sense.
      return elfcpp::R_386_TLS_LE;
d707 2
a708 2
	return elfcpp::R_386_TLS_LE_32;
      return r_type;
d714 1
a714 1
      return r_type;
d721 10
d770 2
a775 2
      // These are outstanding tls relocs, which are unexpected when
      // linking.
d786 1
a786 1
      // These are initial tls relocs, which are expected when
d800 2
a801 2
	r_type = Target_i386::optimize_tls_reloc(!output_is_shared,
						 r_type);
d811 9
d821 6
a829 2
	  case elfcpp::R_386_TLS_IE:
	  case elfcpp::R_386_TLS_GOTIE:
a830 1
	  case elfcpp::R_386_TLS_IE_32:
d833 4
a836 3
	    fprintf(stderr,
		    _("%s: %s: unsupported reloc %u against local symbol\n"),
		    program_name, object->name().c_str(), r_type);
d838 3
d858 1
a858 2
      fprintf(stderr, _("%s: %s: unsupported reloc %u against local symbol\n"),
	      program_name, object->name().c_str(), r_type);
d863 12
d964 2
a969 2
      // These are outstanding tls relocs, which are unexpected when
      // linking.
d994 2
a995 1
	r_type = Target_i386::optimize_tls_reloc(is_final, r_type);
d1005 9
d1015 6
a1023 2
	  case elfcpp::R_386_TLS_IE:
	  case elfcpp::R_386_TLS_GOTIE:
a1024 1
	  case elfcpp::R_386_TLS_IE_32:
d1027 4
a1030 5
	    fprintf(stderr,
		    _("%s: %s: unsupported reloc %u "
		      "against global symbol %s\n"),
		    program_name, object->name().c_str(), r_type,
		    gsym->name());
d1032 3
d1050 1
a1050 3
      fprintf(stderr,
	      _("%s: %s: unsupported reloc %u against global symbol %s\n"),
	      program_name, object->name().c_str(), r_type, gsym->name());
d1328 2
a1329 2
  const unsigned int opt_r_type =
    Target_i386::optimize_tls_reloc(is_final, r_type);
d1345 1
a1345 1
      if (opt_r_type == elfcpp::R_386_TLS_LE_32)
d1352 1
a1352 1
      fprintf(stderr, _("%s: %s: unsupported reloc type %u\n"),
d1360 1
a1360 1
      if (opt_r_type == elfcpp::R_386_TLS_LE_32)
d1384 1
a1384 1
      if (opt_r_type == elfcpp::R_386_TLS_LE_32)
d1401 1
a1401 1
      if (opt_r_type == elfcpp::R_386_TLS_LDO_32
d1443 2
a1444 2
      Target_i386::Relocate::check_range(relinfo, relnum, rel, view_size, -1);
      Target_i386::Relocate::check_range(relinfo, relnum, rel, view_size, 4);
d1454 1
a1454 2
	  Target_i386::Relocate::check_range(relinfo, relnum, rel,
					     view_size, -2);
d1460 2
a1461 2
	      Target_i386::Relocate::check_tls(relinfo, relnum, rel,
					       (op1 & 0xc7) == 0x05);
d1468 2
a1469 2
	      Target_i386::Relocate::check_tls(relinfo, relnum, rel,
					       (op1 & 0xc7) == 0x05);
d1474 1
a1474 1
	    Target_i386::Relocate::check_tls(relinfo, relnum, rel, 0);
d1482 2
a1483 2
      Target_i386::Relocate::check_range(relinfo, relnum, rel, view_size, -2);
      Target_i386::Relocate::check_range(relinfo, relnum, rel, view_size, 4);
d1487 2
a1488 2
      Target_i386::Relocate::check_tls(relinfo, relnum, rel,
				       (op1 & 0xc0) == 0x80 && (op1 & 7) != 4);
d1508 1
a1508 1
	Target_i386::Relocate::check_tls(relinfo, relnum, rel, 0);
d1536 2
a1537 2
  Target_i386::Relocate::check_range(relinfo, relnum, rel, view_size, -2);
  Target_i386::Relocate::check_range(relinfo, relnum, rel, view_size, 9);
d1542 3
a1544 4
  Target_i386::Relocate::check_tls(relinfo, relnum, rel,
				   op2 == 0x8d || op2 == 0x04);
  Target_i386::Relocate::check_tls(relinfo, relnum, rel,
				   view[4] == 0xe8);
d1550 4
a1553 6
      Target_i386::Relocate::check_range(relinfo, relnum, rel, view_size, -3);
      Target_i386::Relocate::check_tls(relinfo, relnum, rel,
				       view[-3] == 0x8d);
      Target_i386::Relocate::check_tls(relinfo, relnum, rel,
				       ((op1 & 0xc7) == 0x05
					&& op1 != (4 << 3)));
d1558 2
a1559 2
      Target_i386::Relocate::check_tls(relinfo, relnum, rel,
				       (op1 & 0xf8) == 0x80 && (op1 & 7) != 4);
d1598 2
a1599 2
  Target_i386::Relocate::check_range(relinfo, relnum, rel, view_size, -2);
  Target_i386::Relocate::check_range(relinfo, relnum, rel, view_size, 9);
d1602 2
a1603 2
  Target_i386::Relocate::check_tls(relinfo, relnum, rel,
				   view[-2] == 0x8d && view[-1] == 0x83);
d1605 1
a1605 2
  Target_i386::Relocate::check_tls(relinfo, relnum, rel,
				   view[4] == 0xe8);
a1611 36
}

// Check the range for a TLS relocation.

inline void
Target_i386::Relocate::check_range(const Relocate_info<32, false>* relinfo,
				   size_t relnum,
				   const elfcpp::Rel<32, false>& rel,
				   off_t view_size, off_t off)
{
  off_t offset = rel.get_r_offset() + off;
  if (offset < 0 || offset > view_size)
    {
      fprintf(stderr, _("%s: %s: TLS relocation out of range\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str());
      gold_exit(false);
    }
}

// Check the validity of a TLS relocation.  This is like assert.

inline void
Target_i386::Relocate::check_tls(const Relocate_info<32, false>* relinfo,
				 size_t relnum,
				 const elfcpp::Rel<32, false>& rel,
				 bool valid)
{
  if (!valid)
    {
      fprintf(stderr,
	      _("%s: %s: TLS relocation against invalid instruction\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str());
      gold_exit(false);
    }
@


1.21
log
@From Craig Silverstein: x86_64 TLS support.
@
text
@d122 2
a123 1
      : skip_call_tls_get_addr_(false)
d174 9
d193 9
d205 3
d698 3
a700 1
      // Another type of Local-Dynamic relocation.
d805 4
a811 2
	  case elfcpp::R_386_TLS_LDM:
	  case elfcpp::R_386_TLS_LDO_32:
d971 4
a977 2
	  case elfcpp::R_386_TLS_LDM:
	  case elfcpp::R_386_TLS_LDO_32:
d1329 22
d1352 13
d1487 1
a1487 1
  //  ==> movl %gs,0,%eax; subl $foo@@tpoff,%eax
d1534 33
@


1.20
log
@Cleanups from Craig Silverstein.
@
text
@d744 2
d756 2
d909 2
d921 2
d1175 2
d1189 2
d1455 2
a1456 1
      if (rel.get_r_offset() + 9 < view_size && view[9] == 0x90)
@


1.19
log
@Use special value when we refer a function symbol in some way other
than calling it.
@
text
@d202 1
a202 1
  Output_data_plt_i386*
a371 2

// For some reason
@


1.18
log
@Add licensing text to every source file.
@
text
@d77 5
d852 12
a863 1
	    target->make_plt_entry(symtab, layout, gsym);
d1524 12
@


1.17
log
@Initialize count_ field, tweak parameters testing.
@
text
@d3 20
@


1.16
log
@Add global parameters.
@
text
@d341 1
a341 1
  : Output_section_data(4), got_plt_(got_plt)
d742 2
a743 2
	bool output_is_executable = parameters->output_is_executable();
	r_type = Target_i386::optimize_tls_reloc(output_is_executable,
d751 1
a751 1
	    gold_assert(output_is_executable);
@


1.15
log
@Use nops when doing alignment padding between code sections.
@
text
@d8 1
d55 1
a55 1
  do_finalize_sections(const General_options*, Layout*);
d166 1
a166 1
  optimize_tls_reloc(const General_options*, bool is_final, int r_type);
d170 1
a170 1
  got_section(const General_options*, Symbol_table*, Layout*);
d174 1
a174 2
  make_plt_entry(const General_options* options, Symbol_table*,
		 Layout*, Symbol*);
d229 1
a229 2
Target_i386::got_section(const General_options* options, Symbol_table* symtab,
			 Layout* layout)
d233 1
a233 1
      gold_assert(options != NULL && symtab != NULL && layout != NULL);
d235 1
a235 1
      this->got_ = new Output_data_got<32, false>(options);
d287 1
a287 1
  Output_data_plt_i386(Layout*, Output_data_space*, bool is_shared);
a332 2
  // Whether we are generated a shared object.
  bool is_shared_;
d340 2
a341 3
					   Output_data_space* got_plt,
					   bool is_shared)
  : Output_section_data(4), got_plt_(got_plt), is_shared_(is_shared)
d453 1
a453 1
  if (this->is_shared_)
d485 1
a485 1
      if (this->is_shared_)
d516 1
a516 2
Target_i386::make_plt_entry(const General_options* options,
			    Symbol_table* symtab, Layout* layout, Symbol* gsym)
d524 1
a524 1
      this->got_section(options, symtab, layout);
d526 1
a526 2
      this->plt_ = new Output_data_plt_i386(layout, this->got_plt_,
					    options->is_shared());
d626 1
a626 3
Target_i386::optimize_tls_reloc(const General_options* options,
				bool is_final,
				int r_type)
d630 1
a630 1
  if (options->is_shared())
d681 1
a681 1
Target_i386::Scan::local(const General_options& options,
d703 1
a703 1
      gold_assert(!options.is_shared());
d714 1
a714 1
      target->got_section(&options, symtab, layout);
d741 12
a752 11
      r_type = Target_i386::optimize_tls_reloc(&options,
					       !options.is_shared(),
					       r_type);
      switch (r_type)
	{
	case elfcpp::R_386_TLS_LE:
	case elfcpp::R_386_TLS_LE_32:
	  // FIXME: If generating a shared object, we need to copy
	  // this relocation into the object.
	  gold_assert(!options.is_shared());
	  break;
d754 14
a767 13
	case elfcpp::R_386_TLS_IE:
	case elfcpp::R_386_TLS_GOTIE:
	case elfcpp::R_386_TLS_GD:
	case elfcpp::R_386_TLS_LDM:
	case elfcpp::R_386_TLS_LDO_32:
	case elfcpp::R_386_TLS_IE_32:
	case elfcpp::R_386_TLS_GOTDESC:
	case elfcpp::R_386_TLS_DESC_CALL:
	  fprintf(stderr,
		  _("%s: %s: unsupported reloc %u against local symbol\n"),
		  program_name, object->name().c_str(), r_type);
	  break;
	}
d819 1
a819 1
      gold_assert(!options.is_shared());
d827 1
a827 1
	    target->make_plt_entry(&options, symtab, layout, gsym);
d838 1
a838 2
        Output_data_got<32, false>* got = target->got_section(&options, symtab,
                                                              layout);
d843 1
a843 1
            if (!gsym->final_value_is_known(&options))
d856 1
a856 1
      if (gsym->final_value_is_known(&options))
d858 1
a858 1
      target->make_plt_entry(&options, symtab, layout, gsym);
d864 1
a864 1
      target->got_section(&options, symtab, layout);
d892 2
a893 2
	const bool is_final = gsym->final_value_is_known(&options);
	r_type = Target_i386::optimize_tls_reloc(&options, is_final, r_type);
d900 1
a900 1
	    gold_assert(!options.is_shared());
d979 1
a979 2
Target_i386::do_finalize_sections(const General_options* options,
				  Layout* layout)
d1005 1
a1005 1
      if (!options->is_shared())
d1101 1
a1101 1
		  || gsym->final_value_is_known(relinfo->options));
d1116 1
a1116 1
		 - target->got_section(NULL, NULL, NULL)->address());
d1124 1
a1124 1
	value = target->got_section(NULL, NULL, NULL)->address();
d1206 2
a1207 2
			 ? !relinfo->options->is_shared()
			 : gsym->final_value_is_known(relinfo->options));
d1209 1
a1209 1
    Target_i386::optimize_tls_reloc(relinfo->options, is_final, r_type);
@


1.14
log
@Generate a GLOB_DAT reloc for a GOT32 reloc against a symbol defined
in a dynamic object.
@
text
@d66 4
d219 1
d1496 63
@


1.13
log
@Add support for SHF_MERGE sections.
@
text
@d669 1
a669 1
	
d807 1
a807 1
    case elfcpp::R_386_GNU_VTENTRY: 
d837 16
a852 8
      // The symbol requires a GOT entry.
      if (target->got_section(&options, symtab, layout)->add_global(gsym))
	{
	  // If this symbol is not fully resolved, we need to add a
	  // dynamic relocation for it.
	  if (!gsym->final_value_is_known(&options))
	    gold_unreachable();
	}
d1062 1
a1062 1
  if (gsym != NULL && gsym->is_from_dynobj())
a1063 3
      if (!gsym->has_plt_offset())
	gold_unreachable();

@


1.12
log
@Generate version information.
@
text
@d112 1
a112 1
	     elfcpp::Elf_types<32>::Elf_Addr,
d122 1
a122 1
		 elfcpp::Elf_types<32>::Elf_Addr,
d1030 1
a1030 1
				elfcpp::Elf_types<32>::Elf_Addr value,
d1053 1
d1056 1
a1056 3
      if (gsym->has_plt_offset())
	value = target->plt_section()->address() + gsym->plt_offset();
      else
d1058 4
d1064 2
d1074 1
a1074 1
      Relocate_functions<32, false>::rel32(view, value);
d1078 1
a1078 1
      Relocate_functions<32, false>::pcrel32(view, value, address);
d1082 1
a1082 1
      Relocate_functions<32, false>::rel16(view, value);
d1086 1
a1086 1
      Relocate_functions<32, false>::pcrel16(view, value, address);
d1090 1
a1090 1
      Relocate_functions<32, false>::rel8(view, value);
d1094 1
a1094 1
      Relocate_functions<32, false>::pcrel8(view, value, address);
d1100 1
a1100 1
      Relocate_functions<32, false>::pcrel32(view, value, address);
d1107 1
a1107 2
      value = gsym->got_offset();
      Relocate_functions<32, false>::rel32(view, value);
d1111 6
a1116 2
      value -= target->got_section(NULL, NULL, NULL)->address();
      Relocate_functions<32, false>::rel32(view, value);
d1120 5
a1124 2
      value = target->got_section(NULL, NULL, NULL)->address();
      Relocate_functions<32, false>::pcrel32(view, value, address);
d1153 1
a1153 1
      this->relocate_tls(relinfo, relnum, rel, r_type, gsym, value, view,
d1187 1
a1187 1
				    elfcpp::Elf_types<32>::Elf_Addr value,
d1200 2
@


1.11
log
@Can now dynamically link hello, world.
@
text
@d250 1
a250 1
      symtab->define_in_output_data(this, "_GLOBAL_OFFSET_TABLE_",
d610 4
a613 4
      symtab->define_in_output_data(this, ssym->name(), dynbss, offset,
				    symsize, ssym->type(), ssym->binding(),
				    ssym->visibility(), ssym->nonvis(),
				    false, false);
d822 1
a822 1
      if (gsym->is_defined_in_dynobj())
d1053 1
a1053 1
  if (gsym != NULL && gsym->is_defined_in_dynobj())
@


1.10
log
@Added a testsuite.  More support for COPY relocations.
@
text
@d54 1
a54 1
  do_finalize_sections(Layout*);
d234 2
a235 1
				      elfcpp::SHF_ALLOC, this->got_);
d243 2
a244 1
				      elfcpp::SHF_ALLOC, this->got_plt_);
d253 1
a253 1
				    elfcpp::STB_GLOBAL,
d289 9
d347 10
d378 1
d528 4
d616 1
d970 1
a970 2
// Finalize the sections.  This is where we emit any relocs we saved
// in an attempt to avoid generating extra COPY relocs.
d973 2
a974 1
Target_i386::do_finalize_sections(Layout* layout)
d976 34
d1056 1
a1056 1
	address = target->plt_section()->address() + gsym->plt_offset();
@


1.9
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d30 2
d34 2
a35 1
      got_(NULL), plt_(NULL), got_plt_(NULL)
d52 4
d180 4
d186 2
a187 1
  copy_reloc(const General_options*, Sized_relobj<32, false>*, unsigned int,
d200 6
d259 15
d529 2
d533 1
a533 1
			const elfcpp::Rel<32, false>&)
d535 6
a540 2
  if (!Relocate_functions<32, false>::need_copy_reloc(options, object,
						      data_shndx, gsym))
d543 5
a547 2
      // If it turns out that we never a COPY reloc for this symbol,
      // then we emit the relocation.
d549 13
d563 30
d803 2
a804 1
	    target->copy_reloc(&options, object, data_shndx, gsym, reloc);
d941 17
@


1.8
log
@Snapshot.  Includes first cut at output relocation sections.
@
text
@d23 2
d32 1
a32 1
      got_(NULL)
d41 1
d67 1
d75 1
d154 1
a154 1
  optimize_tls_reloc(const General_options*, bool is_local, int r_type);
d158 19
a176 1
  got_section(Symbol_table*, Layout*);
d184 4
d206 2
a207 1
Target_i386::got_section(Symbol_table* symtab, Layout* layout)
d211 3
a213 1
      this->got_ = new Output_data_got<32, false>();
a214 1
      assert(symtab != NULL && layout != NULL);
d218 8
d227 1
a227 3
      this->got_->add_constant(0);
      this->got_->add_constant(0);
      this->got_->add_constant(0);
d229 3
a231 2
      // Define _GLOBAL_OFFSET_TABLE_ at the start of the section.
      symtab->define_in_output_data(this, "_GLOBAL_OFFSET_TABLE_", this->got_,
d237 1
d241 269
d511 2
a512 2
// symbol.  IS_LOCAL is true if this symbol can be resolved entirely
// locally--i.e., does not have to be in the dynamic symbol table.
d515 2
a516 1
Target_i386::optimize_tls_reloc(const General_options* options, bool is_local,
d533 1
a533 1
      if (is_local)
d554 1
a554 1
      if (is_local)
d565 1
a565 1
      abort();
d577 3
a579 1
			 const elfcpp::Rel<32, false>&, unsigned int r_type,
d594 1
d605 1
a605 1
      target->got_section(symtab, layout);
d632 3
a634 1
      r_type = Target_i386::optimize_tls_reloc(&options, true, r_type);
d641 1
d686 3
a688 1
			  const elfcpp::Rel<32, false>&, unsigned int r_type,
d708 13
d725 1
a725 1
      if (target->got_section(symtab, layout)->add_global(gsym))
d727 1
a727 1
	  // If this symbol is not resolved locally, we need to add a
d729 2
a730 2
	  if (!gsym->is_resolved_locally())
	    abort();
d735 3
a737 2
      // If the symbol is resolved locally, this is just a PC32 reloc.
      if (gsym->is_resolved_locally())
d739 1
a739 3
      fprintf(stderr,
	      _("%s: %s: unsupported reloc %u against global symbol %s\n"),
	      program_name, object->name().c_str(), r_type, gsym->name());
d745 1
a745 1
      target->got_section(symtab, layout);
d772 28
a799 24
      r_type = Target_i386::optimize_tls_reloc(&options,
					       gsym->is_resolved_locally(),
					       r_type);
      switch (r_type)
	{
	case elfcpp::R_386_TLS_LE:
	case elfcpp::R_386_TLS_LE_32:
	  // FIXME: If generating a shared object, we need to copy
	  // this relocation into the object.
	  break;

	case elfcpp::R_386_TLS_IE:
	case elfcpp::R_386_TLS_GOTIE:
	case elfcpp::R_386_TLS_GD:
	case elfcpp::R_386_TLS_LDM:
	case elfcpp::R_386_TLS_LDO_32:
	case elfcpp::R_386_TLS_IE_32:
	case elfcpp::R_386_TLS_GOTDESC:
	case elfcpp::R_386_TLS_DESC_CALL:
	  fprintf(stderr,
		  _("%s: %s: unsupported reloc %u against global symbol %s\n"),
		  program_name, object->name().c_str(), r_type, gsym->name());
	  break;
	}
d827 1
d849 1
d888 9
d929 3
a931 7
      if (gsym->is_resolved_locally())
	Relocate_functions<32, false>::pcrel32(view, value, address);
      else
	fprintf(stderr, _("%s: %s: unsupported reloc %u\n"),
		program_name,
		relinfo->location(relnum, rel.get_r_offset()).c_str(),
		r_type);
d936 2
a937 2
      assert(gsym);
      assert(gsym->has_got_offset());
d943 1
a943 1
      value -= target->got_section(NULL, NULL)->address();
d948 1
a948 1
      value = target->got_section(NULL, NULL)->address();
d1026 3
a1028 1
  const bool is_local = gsym == NULL || gsym->is_resolved_locally();
d1030 1
a1030 1
    Target_i386::optimize_tls_reloc(relinfo->options, is_local, r_type);
d1298 1
a1298 1
  assert(sh_type == elfcpp::SHT_REL);
@


1.7
log
@More dynamic object support, initial scripting support.
@
text
@d99 1
a99 1
	     unsigned int r_type, Sized_symbol<32>*,
d109 1
a109 1
		 unsigned int r_type, Sized_symbol<32>*,
d532 1
a532 1
				Sized_symbol<32>* gsym,
d673 1
a673 1
				    Sized_symbol<32>* gsym,
@


1.6
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@d152 1
a152 1
  Output_section_got<32, false>*
d160 1
a160 1
  Output_section_got<32, false>* got_;
d169 3
a171 2
  false,		// has_resolve,
  0x08048000,		// text_segment_address,
d178 1
a178 1
Output_section_got<32, false>*
d183 1
a183 1
      this->got_ = new Output_section_got<32, false>();
d397 1
a397 1
      if (!gsym->has_got_offset())
a398 5
	  Output_section_got<32, false>* got = target->got_section(symtab,
								   layout);
	  const unsigned int got_offset = got->add_global(gsym);
	  gsym->set_got_offset(got_offset);

@


1.5
log
@Can now do a full static link of hello, world in C or C++
@
text
@d38 1
a38 1
	      Sized_object<32, false>* object,
d63 1
a63 1
	  Sized_object<32, false>* object,
d70 1
a70 1
	   Sized_object<32, false>* object,
d268 1
a268 1
			 Sized_object<32, false>* object,
d371 1
a371 1
			  Sized_object<32, false>* object,
d499 1
a499 1
			 Sized_object<32, false>* object,
@


1.4
log
@Framework for relocation scanning.  Implement simple static TLS
relocations.
@
text
@d4 3
d11 1
d29 2
a30 1
    : Sized_target<32, false>(&i386_info)
d37 1
d61 3
a63 1
    local(const General_options& options, Sized_object<32, false>* object,
d68 3
a70 1
    global(const General_options& options, Sized_object<32, false>* object,
d79 19
a97 3
    // Do a relocation.
    static inline void
    relocate(const Relocate_info<32, false>*, size_t relnum,
d106 1
a106 1
    static inline void
d122 9
d140 4
d151 4
d158 3
d175 28
d265 3
d291 6
a346 2
    case elfcpp::R_386_GOTOFF:
    case elfcpp::R_386_GOTPC:
d368 3
d394 31
d450 1
a450 1
					       !gsym->in_dynsym(),
a474 4
    case elfcpp::R_386_GOT32:
    case elfcpp::R_386_PLT32:
    case elfcpp::R_386_GOTOFF:
    case elfcpp::R_386_GOTPC:
d498 1
d514 2
a515 1
  gold::scan_relocs<32, false, elfcpp::SHT_REL, Target_i386::Scan>(
d518 2
d530 1
a530 1
inline void
d532 1
d542 17
d590 28
d644 2
a645 3
      Target_i386::Relocate::relocate_tls(relinfo, relnum, rel, r_type,
					  gsym, value, view, address,
					  view_size);
a647 4
    case elfcpp::R_386_GOT32:
    case elfcpp::R_386_PLT32:
    case elfcpp::R_386_GOTOFF:
    case elfcpp::R_386_GOTPC:
d666 2
d692 1
a692 1
  const bool is_local = gsym == NULL || !gsym->in_dynsym();
d725 14
d842 3
a844 4
  if (r_type == elfcpp::R_386_TLS_IE_32)
    value = tls_segment->vaddr() + tls_segment->memsz() - value;
  else // elfcpp::R_386_TLS_IE, elfcpp::R_386_TLS_GOTIE
    value = value - (tls_segment->vaddr() + tls_segment->memsz());
d849 66
d964 2
a965 1
  gold::relocate_section<32, false, elfcpp::SHT_REL, Target_i386::Relocate>(
d967 1
a974 4
// The i386 target.

Target_i386 target_i386;

d985 4
a988 1
  recognize(int machine, int osabi, int abiversion) const;
d995 1
a995 1
Target_selector_i386::recognize(int, int, int) const
d997 3
a999 1
  return &target_i386;
@


1.3
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d5 1
d8 2
d28 1
d30 9
a38 11
  relocate_section(const Symbol_table* symtab,
		   Sized_object<32, false>*,
		   unsigned int,
		   const unsigned char*,
		   size_t,
		   unsigned int,
		   const elfcpp::Elf_types<32>::Elf_Addr*,
		   Symbol**,
		   unsigned char*,
		   elfcpp::Elf_types<32>::Elf_Addr,
		   off_t);
d40 13
a52 2
  // The class which implements relocation.
  struct Relocate
d55 9
a63 4
    operator()(Sized_object<32, false>*, const elfcpp::Rel<32, false>&,
	       unsigned int r_type, Sized_symbol<32>*,
	       elfcpp::Elf_types<32>::Elf_Addr,
	       unsigned char*, elfcpp::Elf_types<32>::Elf_Addr);
d65 40
d107 7
a113 1
 private:
d129 284
d416 9
a424 7
Target_i386::Relocate::operator()(Sized_object<32, false>* object,
				  const elfcpp::Rel<32, false>&,
				  unsigned int r_type,
				  Sized_symbol<32>*,
				  elfcpp::Elf_types<32>::Elf_Addr value,
				  unsigned char* view,
				  elfcpp::Elf_types<32>::Elf_Addr address)
d429 2
d434 1
a434 5
      {
	elfcpp::Elf_Word* wv = reinterpret_cast<elfcpp::Elf_Word*>(view);
	unsigned int x = elfcpp::read_elf_word<false>(wv);
	elfcpp::write_elf_word<false>(wv, x + value);
      }
d438 9
a446 5
      {
	elfcpp::Elf_Word* wv = reinterpret_cast<elfcpp::Elf_Word*>(view);
	unsigned int x = elfcpp::read_elf_word<false>(wv);
	elfcpp::write_elf_word<false>(wv, x + value - address);
      }
d449 53
d504 71
a574 1
	      program_name, object->name().c_str(), r_type);
d576 135
d717 1
a717 2
Target_i386::relocate_section(const Symbol_table* symtab,
			      Sized_object<32, false>* object,
a720 3
			      unsigned int local_count,
			      const elfcpp::Elf_types<32>::Elf_Addr* values,
			      Symbol** global_syms,
d725 1
a725 6
  if (sh_type == elfcpp::SHT_RELA)
    {
      fprintf(stderr, _("%s: %s: unsupported RELA reloc section\n"),
	      program_name, object->name().c_str());
      gold_exit(false);
    }
d728 1
a728 2
    symtab,
    object,
a730 3
    local_count,
    values,
    global_syms,
@


1.2
log
@Finished layout code.
@
text
@d5 2
d8 1
d25 24
d55 8
a62 7
  32,		// size
  false,	// is_big_endian
  false,	// has_make_symbol
  false,	// has_resolve,
  0x08048000,	// text_segment_address,
  0x1000,	// abi_pagesize
  0x1000	// common_pagesize
d65 78
d162 1
a162 1
  return new Target_i386();
@


1.1
log
@Another snapshot of the current state of the sources.  Gets to the
point of symbol resolution and can now issue a multiple definition
error.  Also added target selection infrastructure.
@
text
@d19 1
a19 1
    : Sized_target<32, false>(false, false)
d21 14
@

