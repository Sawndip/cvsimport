head	1.58;
access;
symbols
	binutils-2_24-branch:1.58.0.2
	binutils-2_24-branchpoint:1.58
	binutils-2_21_1:1.46.2.3
	binutils-2_23_2:1.55
	binutils-2_23_1:1.55
	binutils-2_23:1.55
	binutils-2_23-branch:1.55.0.2
	binutils-2_23-branchpoint:1.55
	binutils-2_22_branch:1.53.0.4
	binutils-2_22:1.53
	binutils-2_22-branch:1.53.0.2
	binutils-2_22-branchpoint:1.53
	binutils-2_21:1.46
	binutils-2_21-branch:1.46.0.2
	binutils-2_21-branchpoint:1.46
	binutils-2_20_1:1.20.4.2
	binutils-2_20:1.20.4.1
	binutils-arc-20081103-branch:1.17.0.6
	binutils-arc-20081103-branchpoint:1.17
	binutils-2_20-branch:1.20.0.4
	binutils-2_20-branchpoint:1.20
	dje-cgen-play1-branch:1.20.0.2
	dje-cgen-play1-branchpoint:1.20
	arc-20081103-branch:1.17.0.4
	arc-20081103-branchpoint:1.17
	binutils-2_19_1:1.17
	binutils-2_19:1.17
	binutils-2_19-branch:1.17.0.2
	binutils-2_19-branchpoint:1.17
	binutils_latest_snapshot:1.58
	added-to-binutils:1.11;
locks; strict;
comment	@// @;


1.58
date	2013.04.15.16.37.30;	author ccoutant;	state Exp;
branches;
next	1.57;

1.57
date	2013.01.10.00.18.14;	author tmsriram;	state Exp;
branches;
next	1.56;

1.56
date	2012.08.14.08.31.56;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2011.10.31.22.51.03;	author ccoutant;	state Exp;
branches;
next	1.54;

1.54
date	2011.10.19.15.51.00;	author ian;	state Exp;
branches;
next	1.53;

1.53
date	2011.06.29.00.39.54;	author ian;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2011.06.19.22.09.17;	author ian;	state Exp;
branches;
next	1.51;

1.51
date	2011.06.17.13.00.01;	author ian;	state Exp;
branches;
next	1.50;

1.50
date	2011.06.09.19.25.02;	author ian;	state Exp;
branches;
next	1.49;

1.49
date	2011.03.14.15.22.16;	author ian;	state Exp;
branches;
next	1.48;

1.48
date	2011.01.04.21.46.06;	author ccoutant;	state Exp;
branches;
next	1.47;

1.47
date	2010.12.14.19.03.30;	author rwild;	state Exp;
branches;
next	1.46;

1.46
date	2010.11.03.14.07.49;	author ian;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2010.10.12.19.21.41;	author ian;	state Exp;
branches;
next	1.44;

1.44
date	2010.10.06.08.58.57;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2010.10.01.15.02.33;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2010.09.16.15.52.15;	author ccoutant;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.08.20.08.14;	author espindola;	state Exp;
branches;
next	1.40;

1.40
date	2010.09.08.16.10.31;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2010.08.03.14.07.13;	author ian;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.01.23.37.58;	author tmsriram;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.26.15.15.05;	author espindola;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.19.17.49.18;	author espindola;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.19.07.09.36;	author dougkwan;	state Exp;
branches;
next	1.33;

1.33
date	2010.04.23.04.47.33;	author ian;	state Exp;
branches;
next	1.32;

1.32
date	2010.04.09.17.32.58;	author dougkwan;	state Exp;
branches;
next	1.31;

1.31
date	2010.03.23.21.06.10;	author ian;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.23.01.07.59;	author dougkwan;	state Exp;
branches;
next	1.29;

1.29
date	2009.12.29.00.31.48;	author ian;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.04.15.56.03;	author ian;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.16.18.56.07;	author dougkwan;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.16.05.19.07;	author ian;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.16.05.00.29;	author ian;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.09.23.18.19;	author dougkwan;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.18.01.10.38;	author dougkwan;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.24.19.00.15;	author ian;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2009.06.23.06.07.50;	author ian;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.19.05.51.49;	author ian;	state Exp;
branches;
next	1.17;

1.17
date	2008.08.13.07.37.46;	author ian;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.22.23.01.20;	author ian;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.18.04.15.52;	author ian;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.21.21.37.44;	author ian;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.15.22.50.37;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.10.01.02.46;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	2008.02.29.00.04.06;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2008.02.28.04.45.47;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.14.02.34.22;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2008.02.12.00.17.35;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.09.01.22.17;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.04.23.53.15;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2008.02.04.22.54.31;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2008.02.04.06.45.50;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.04.05.41.40;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2008.01.23.01.31.13;	author iant;	state Exp;
branches;
next	;

1.53.2.1
date	2011.12.19.21.14.40;	author ian;	state Exp;
branches;
next	;

1.46.2.1
date	2011.03.01.21.50.06;	author ian;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2011.03.14.15.24.08;	author ian;	state Exp;
branches;
next	1.46.2.3;

1.46.2.3
date	2011.06.09.19.27.35;	author ian;	state Exp;
branches;
next	;

1.20.4.1
date	2009.10.16.05.51.18;	author ian;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2009.11.04.15.56.34;	author ian;	state Exp;
branches;
next	;


desc
@@


1.58
log
@gold/
	* script-sections.cc (Orphan_output_section): Reset address
	to zero after each orphaned section for relocatable links.
@
text
@// script-sections.cc -- linker script SECTIONS for gold

// Copyright 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cstring>
#include <algorithm>
#include <list>
#include <map>
#include <string>
#include <vector>
#include <fnmatch.h>

#include "parameters.h"
#include "object.h"
#include "layout.h"
#include "output.h"
#include "script-c.h"
#include "script.h"
#include "script-sections.h"

// Support for the SECTIONS clause in linker scripts.

namespace gold
{

// A region of memory.
class Memory_region
{
 public:
  Memory_region(const char* name, size_t namelen, unsigned int attributes,
		Expression* start, Expression* length)
    : name_(name, namelen),
      attributes_(attributes),
      start_(start),
      length_(length),
      current_offset_(0),
      vma_sections_(),
      lma_sections_(),
      last_section_(NULL)
  { }

  // Return the name of this region.
  const std::string&
  name() const
  { return this->name_; }

  // Return the start address of this region.
  Expression*
  start_address() const
  { return this->start_; }

  // Return the length of this region.
  Expression*
  length() const
  { return this->length_; }

  // Print the region (when debugging).
  void
  print(FILE*) const;

  // Return true if <name,namelen> matches this region.
  bool
  name_match(const char* name, size_t namelen)
  {
    return (this->name_.length() == namelen
	    && strncmp(this->name_.c_str(), name, namelen) == 0);
  }

  Expression*
  get_current_address() const
  {
    return
      script_exp_binary_add(this->start_,
			    script_exp_integer(this->current_offset_));
  }
  
  void
  increment_offset(std::string section_name, uint64_t amount,
		   const Symbol_table* symtab, const Layout* layout)
  {
    this->current_offset_ += amount;

    if (this->current_offset_
	> this->length_->eval(symtab, layout, false))
      gold_error(_("section %s overflows end of region %s"),
		 section_name.c_str(), this->name_.c_str());
  }
  
  // Returns true iff there is room left in this region
  // for AMOUNT more bytes of data.
  bool
  has_room_for(const Symbol_table* symtab, const Layout* layout,
	       uint64_t amount) const
  {
    return (this->current_offset_ + amount
	    < this->length_->eval(symtab, layout, false));
  }

  // Return true if the provided section flags
  // are compatible with this region's attributes.
  bool
  attributes_compatible(elfcpp::Elf_Xword flags, elfcpp::Elf_Xword type) const;
  
  void
  add_section(Output_section_definition* sec, bool vma)
  {
    if (vma)
      this->vma_sections_.push_back(sec);
    else
      this->lma_sections_.push_back(sec);
  }

  typedef std::vector<Output_section_definition*> Section_list;

  // Return the start of the list of sections
  // whose VMAs are taken from this region.
  Section_list::const_iterator
  get_vma_section_list_start() const
  { return this->vma_sections_.begin(); }

  // Return the start of the list of sections
  // whose LMAs are taken from this region.
  Section_list::const_iterator
  get_lma_section_list_start() const
  { return this->lma_sections_.begin(); }

  // Return the end of the list of sections
  // whose VMAs are taken from this region.
  Section_list::const_iterator
  get_vma_section_list_end() const
  { return this->vma_sections_.end(); }

  // Return the end of the list of sections
  // whose LMAs are taken from this region.
  Section_list::const_iterator
  get_lma_section_list_end() const
  { return this->lma_sections_.end(); }

  Output_section_definition*
  get_last_section() const
  { return this->last_section_; }

  void
  set_last_section(Output_section_definition* sec)
  { this->last_section_ = sec; }

 private:

  std::string name_;
  unsigned int attributes_;
  Expression* start_;
  Expression* length_;
  // The offset to the next free byte in the region.
  // Note - for compatibility with GNU LD we only maintain one offset
  // regardless of whether the region is being used for VMA values,
  // LMA values, or both.
  uint64_t current_offset_;
  // A list of sections whose VMAs are set inside this region.
  Section_list vma_sections_;
  // A list of sections whose LMAs are set inside this region.
  Section_list lma_sections_;
  // The latest section to make use of this region.
  Output_section_definition* last_section_;
};

// Return true if the provided section flags
// are compatible with this region's attributes.

bool
Memory_region::attributes_compatible(elfcpp::Elf_Xword flags,
				     elfcpp::Elf_Xword type) const
{
  unsigned int attrs = this->attributes_;

  // No attributes means that this region is not compatible with anything.
  if (attrs == 0)
    return false;

  bool match = true;
  do
    {
      switch (attrs & - attrs)
	{
	case MEM_EXECUTABLE:
	  if ((flags & elfcpp::SHF_EXECINSTR) == 0)
	    match = false;
	  break;

	case MEM_WRITEABLE:
	  if ((flags & elfcpp::SHF_WRITE) == 0)
	    match = false;
	  break;

	case MEM_READABLE:
	  // All sections are presumed readable.
	  break;

	case MEM_ALLOCATABLE:
	  if ((flags & elfcpp::SHF_ALLOC) == 0)
	    match = false;
	  break;

	case MEM_INITIALIZED:
	  if ((type & elfcpp::SHT_NOBITS) != 0)
	    match = false;
	  break;
	}
      attrs &= ~ (attrs & - attrs);
    }
  while (attrs != 0);
  
  return match;
}
  
// Print a memory region.

void
Memory_region::print(FILE* f) const
{
  fprintf(f, "  %s", this->name_.c_str());

  unsigned int attrs = this->attributes_;
  if (attrs != 0)
    {
      fprintf(f, " (");
      do
	{
	  switch (attrs & - attrs)
	    {
	    case MEM_EXECUTABLE:  fputc('x', f); break;
	    case MEM_WRITEABLE:   fputc('w', f); break;
	    case MEM_READABLE:    fputc('r', f); break;
	    case MEM_ALLOCATABLE: fputc('a', f); break;
	    case MEM_INITIALIZED: fputc('i', f); break;
	    default:
	      gold_unreachable();
	    }
	  attrs &= ~ (attrs & - attrs);
	}
      while (attrs != 0);
      fputc(')', f);
    }

  fprintf(f, " : origin = ");
  this->start_->print(f);
  fprintf(f, ", length = ");
  this->length_->print(f);
  fprintf(f, "\n");
}

// Manage orphan sections.  This is intended to be largely compatible
// with the GNU linker.  The Linux kernel implicitly relies on
// something similar to the GNU linker's orphan placement.  We
// originally used a simpler scheme here, but it caused the kernel
// build to fail, and was also rather inefficient.

class Orphan_section_placement
{
 private:
  typedef Script_sections::Elements_iterator Elements_iterator;

 public:
  Orphan_section_placement();

  // Handle an output section during initialization of this mapping.
  void
  output_section_init(const std::string& name, Output_section*,
		      Elements_iterator location);

  // Initialize the last location.
  void
  last_init(Elements_iterator location);

  // Set *PWHERE to the address of an iterator pointing to the
  // location to use for an orphan section.  Return true if the
  // iterator has a value, false otherwise.
  bool
  find_place(Output_section*, Elements_iterator** pwhere);

  // Return the iterator being used for sections at the very end of
  // the linker script.
  Elements_iterator
  last_place() const;

 private:
  // The places that we specifically recognize.  This list is copied
  // from the GNU linker.
  enum Place_index
  {
    PLACE_TEXT,
    PLACE_RODATA,
    PLACE_DATA,
    PLACE_TLS,
    PLACE_TLS_BSS,
    PLACE_BSS,
    PLACE_REL,
    PLACE_INTERP,
    PLACE_NONALLOC,
    PLACE_LAST,
    PLACE_MAX
  };

  // The information we keep for a specific place.
  struct Place
  {
    // The name of sections for this place.
    const char* name;
    // Whether we have a location for this place.
    bool have_location;
    // The iterator for this place.
    Elements_iterator location;
  };

  // Initialize one place element.
  void
  initialize_place(Place_index, const char*);

  // The places.
  Place places_[PLACE_MAX];
  // True if this is the first call to output_section_init.
  bool first_init_;
};

// Initialize Orphan_section_placement.

Orphan_section_placement::Orphan_section_placement()
  : first_init_(true)
{
  this->initialize_place(PLACE_TEXT, ".text");
  this->initialize_place(PLACE_RODATA, ".rodata");
  this->initialize_place(PLACE_DATA, ".data");
  this->initialize_place(PLACE_TLS, NULL);
  this->initialize_place(PLACE_TLS_BSS, NULL);
  this->initialize_place(PLACE_BSS, ".bss");
  this->initialize_place(PLACE_REL, NULL);
  this->initialize_place(PLACE_INTERP, ".interp");
  this->initialize_place(PLACE_NONALLOC, NULL);
  this->initialize_place(PLACE_LAST, NULL);
}

// Initialize one place element.

void
Orphan_section_placement::initialize_place(Place_index index, const char* name)
{
  this->places_[index].name = name;
  this->places_[index].have_location = false;
}

// While initializing the Orphan_section_placement information, this
// is called once for each output section named in the linker script.
// If we found an output section during the link, it will be passed in
// OS.

void
Orphan_section_placement::output_section_init(const std::string& name,
					      Output_section* os,
					      Elements_iterator location)
{
  bool first_init = this->first_init_;
  this->first_init_ = false;

  for (int i = 0; i < PLACE_MAX; ++i)
    {
      if (this->places_[i].name != NULL && this->places_[i].name == name)
	{
	  if (this->places_[i].have_location)
	    {
	      // We have already seen a section with this name.
	      return;
	    }

	  this->places_[i].location = location;
	  this->places_[i].have_location = true;

	  // If we just found the .bss section, restart the search for
	  // an unallocated section.  This follows the GNU linker's
	  // behaviour.
	  if (i == PLACE_BSS)
	    this->places_[PLACE_NONALLOC].have_location = false;

	  return;
	}
    }

  // Relocation sections.
  if (!this->places_[PLACE_REL].have_location
      && os != NULL
      && (os->type() == elfcpp::SHT_REL || os->type() == elfcpp::SHT_RELA)
      && (os->flags() & elfcpp::SHF_ALLOC) != 0)
    {
      this->places_[PLACE_REL].location = location;
      this->places_[PLACE_REL].have_location = true;
    }

  // We find the location for unallocated sections by finding the
  // first debugging or comment section after the BSS section (if
  // there is one).
  if (!this->places_[PLACE_NONALLOC].have_location
      && (name == ".comment" || Layout::is_debug_info_section(name.c_str())))
    {
      // We add orphan sections after the location in PLACES_.  We
      // want to store unallocated sections before LOCATION.  If this
      // is the very first section, we can't use it.
      if (!first_init)
	{
	  --location;
	  this->places_[PLACE_NONALLOC].location = location;
	  this->places_[PLACE_NONALLOC].have_location = true;
	}
    }
}

// Initialize the last location.

void
Orphan_section_placement::last_init(Elements_iterator location)
{
  this->places_[PLACE_LAST].location = location;
  this->places_[PLACE_LAST].have_location = true;
}

// Set *PWHERE to the address of an iterator pointing to the location
// to use for an orphan section.  Return true if the iterator has a
// value, false otherwise.

bool
Orphan_section_placement::find_place(Output_section* os,
				     Elements_iterator** pwhere)
{
  // Figure out where OS should go.  This is based on the GNU linker
  // code.  FIXME: The GNU linker handles small data sections
  // specially, but we don't.
  elfcpp::Elf_Word type = os->type();
  elfcpp::Elf_Xword flags = os->flags();
  Place_index index;
  if ((flags & elfcpp::SHF_ALLOC) == 0
      && !Layout::is_debug_info_section(os->name()))
    index = PLACE_NONALLOC;
  else if ((flags & elfcpp::SHF_ALLOC) == 0)
    index = PLACE_LAST;
  else if (type == elfcpp::SHT_NOTE)
    index = PLACE_INTERP;
  else if ((flags & elfcpp::SHF_TLS) != 0)
    {
      if (type == elfcpp::SHT_NOBITS)
	index = PLACE_TLS_BSS;
      else
	index = PLACE_TLS;
    }
  else if (type == elfcpp::SHT_NOBITS)
    index = PLACE_BSS;
  else if ((flags & elfcpp::SHF_WRITE) != 0)
    index = PLACE_DATA;
  else if (type == elfcpp::SHT_REL || type == elfcpp::SHT_RELA)
    index = PLACE_REL;
  else if ((flags & elfcpp::SHF_EXECINSTR) == 0)
    index = PLACE_RODATA;
  else
    index = PLACE_TEXT;

  // If we don't have a location yet, try to find one based on a
  // plausible ordering of sections.
  if (!this->places_[index].have_location)
    {
      Place_index follow;
      switch (index)
	{
	default:
	  follow = PLACE_MAX;
	  break;
	case PLACE_RODATA:
	  follow = PLACE_TEXT;
	  break;
	case PLACE_BSS:
	  follow = PLACE_DATA;
	  break;
	case PLACE_REL:
	  follow = PLACE_TEXT;
	  break;
	case PLACE_INTERP:
	  follow = PLACE_TEXT;
	  break;
	case PLACE_TLS:
	  follow = PLACE_DATA;
	  break;
	case PLACE_TLS_BSS:
	  follow = PLACE_TLS;
	  if (!this->places_[PLACE_TLS].have_location)
	    follow = PLACE_DATA;
	  break;
	}
      if (follow != PLACE_MAX && this->places_[follow].have_location)
	{
	  // Set the location of INDEX to the location of FOLLOW.  The
	  // location of INDEX will then be incremented by the caller,
	  // so anything in INDEX will continue to be after anything
	  // in FOLLOW.
	  this->places_[index].location = this->places_[follow].location;
	  this->places_[index].have_location = true;
	}
    }

  *pwhere = &this->places_[index].location;
  bool ret = this->places_[index].have_location;

  // The caller will set the location.
  this->places_[index].have_location = true;

  return ret;
}

// Return the iterator being used for sections at the very end of the
// linker script.

Orphan_section_placement::Elements_iterator
Orphan_section_placement::last_place() const
{
  gold_assert(this->places_[PLACE_LAST].have_location);
  return this->places_[PLACE_LAST].location;
}

// An element in a SECTIONS clause.

class Sections_element
{
 public:
  Sections_element()
  { }

  virtual ~Sections_element()
  { }

  // Return whether an output section is relro.
  virtual bool
  is_relro() const
  { return false; }

  // Record that an output section is relro.
  virtual void
  set_is_relro()
  { }

  // Create any required output sections.  The only real
  // implementation is in Output_section_definition.
  virtual void
  create_sections(Layout*)
  { }

  // Add any symbol being defined to the symbol table.
  virtual void
  add_symbols_to_table(Symbol_table*)
  { }

  // Finalize symbols and check assertions.
  virtual void
  finalize_symbols(Symbol_table*, const Layout*, uint64_t*)
  { }

  // Return the output section name to use for an input file name and
  // section name.  This only real implementation is in
  // Output_section_definition.
  virtual const char*
  output_section_name(const char*, const char*, Output_section***,
		      Script_sections::Section_type*, bool*)
  { return NULL; }

  // Initialize OSP with an output section.
  virtual void
  orphan_section_init(Orphan_section_placement*,
		      Script_sections::Elements_iterator)
  { }

  // Set section addresses.  This includes applying assignments if the
  // expression is an absolute value.
  virtual void
  set_section_addresses(Symbol_table*, Layout*, uint64_t*, uint64_t*,
			uint64_t*)
  { }

  // Check a constraint (ONLY_IF_RO, etc.) on an output section.  If
  // this section is constrained, and the input sections do not match,
  // return the constraint, and set *POSD.
  virtual Section_constraint
  check_constraint(Output_section_definition**)
  { return CONSTRAINT_NONE; }

  // See if this is the alternate output section for a constrained
  // output section.  If it is, transfer the Output_section and return
  // true.  Otherwise return false.
  virtual bool
  alternate_constraint(Output_section_definition*, Section_constraint)
  { return false; }

  // Get the list of segments to use for an allocated section when
  // using a PHDRS clause.  If this is an allocated section, return
  // the Output_section, and set *PHDRS_LIST (the first parameter) to
  // the list of PHDRS to which it should be attached.  If the PHDRS
  // were not specified, don't change *PHDRS_LIST.  When not returning
  // NULL, set *ORPHAN (the second parameter) according to whether
  // this is an orphan section--one that is not mentioned in the
  // linker script.
  virtual Output_section*
  allocate_to_segment(String_list**, bool*)
  { return NULL; }

  // Look for an output section by name and return the address, the
  // load address, the alignment, and the size.  This is used when an
  // expression refers to an output section which was not actually
  // created.  This returns true if the section was found, false
  // otherwise.  The only real definition is for
  // Output_section_definition.
  virtual bool
  get_output_section_info(const char*, uint64_t*, uint64_t*, uint64_t*,
                          uint64_t*) const
  { return false; }

  // Return the associated Output_section if there is one.
  virtual Output_section*
  get_output_section() const
  { return NULL; }

  // Set the section's memory regions.
  virtual void
  set_memory_region(Memory_region*, bool)
  { gold_error(_("Attempt to set a memory region for a non-output section")); }

  // Print the element for debugging purposes.
  virtual void
  print(FILE* f) const = 0;
};

// An assignment in a SECTIONS clause outside of an output section.

class Sections_element_assignment : public Sections_element
{
 public:
  Sections_element_assignment(const char* name, size_t namelen,
			      Expression* val, bool provide, bool hidden)
    : assignment_(name, namelen, false, val, provide, hidden)
  { }

  // Add the symbol to the symbol table.
  void
  add_symbols_to_table(Symbol_table* symtab)
  { this->assignment_.add_to_table(symtab); }

  // Finalize the symbol.
  void
  finalize_symbols(Symbol_table* symtab, const Layout* layout,
		   uint64_t* dot_value)
  {
    this->assignment_.finalize_with_dot(symtab, layout, *dot_value, NULL);
  }

  // Set the section address.  There is no section here, but if the
  // value is absolute, we set the symbol.  This permits us to use
  // absolute symbols when setting dot.
  void
  set_section_addresses(Symbol_table* symtab, Layout* layout,
			uint64_t* dot_value, uint64_t*, uint64_t*)
  {
    this->assignment_.set_if_absolute(symtab, layout, true, *dot_value, NULL);
  }

  // Print for debugging.
  void
  print(FILE* f) const
  {
    fprintf(f, "  ");
    this->assignment_.print(f);
  }

 private:
  Symbol_assignment assignment_;
};

// An assignment to the dot symbol in a SECTIONS clause outside of an
// output section.

class Sections_element_dot_assignment : public Sections_element
{
 public:
  Sections_element_dot_assignment(Expression* val)
    : val_(val)
  { }

  // Finalize the symbol.
  void
  finalize_symbols(Symbol_table* symtab, const Layout* layout,
		   uint64_t* dot_value)
  {
    // We ignore the section of the result because outside of an
    // output section definition the dot symbol is always considered
    // to be absolute.
    *dot_value = this->val_->eval_with_dot(symtab, layout, true, *dot_value,
					   NULL, NULL, NULL, false);
  }

  // Update the dot symbol while setting section addresses.
  void
  set_section_addresses(Symbol_table* symtab, Layout* layout,
			uint64_t* dot_value, uint64_t* dot_alignment,
			uint64_t* load_address)
  {
    *dot_value = this->val_->eval_with_dot(symtab, layout, false, *dot_value,
					   NULL, NULL, dot_alignment, false);
    *load_address = *dot_value;
  }

  // Print for debugging.
  void
  print(FILE* f) const
  {
    fprintf(f, "  . = ");
    this->val_->print(f);
    fprintf(f, "\n");
  }

 private:
  Expression* val_;
};

// An assertion in a SECTIONS clause outside of an output section.

class Sections_element_assertion : public Sections_element
{
 public:
  Sections_element_assertion(Expression* check, const char* message,
			     size_t messagelen)
    : assertion_(check, message, messagelen)
  { }

  // Check the assertion.
  void
  finalize_symbols(Symbol_table* symtab, const Layout* layout, uint64_t*)
  { this->assertion_.check(symtab, layout); }

  // Print for debugging.
  void
  print(FILE* f) const
  {
    fprintf(f, "  ");
    this->assertion_.print(f);
  }

 private:
  Script_assertion assertion_;
};

// An element in an output section in a SECTIONS clause.

class Output_section_element
{
 public:
  // A list of input sections.
  typedef std::list<Output_section::Input_section> Input_section_list;

  Output_section_element()
  { }

  virtual ~Output_section_element()
  { }

  // Return whether this element requires an output section to exist.
  virtual bool
  needs_output_section() const
  { return false; }

  // Add any symbol being defined to the symbol table.
  virtual void
  add_symbols_to_table(Symbol_table*)
  { }

  // Finalize symbols and check assertions.
  virtual void
  finalize_symbols(Symbol_table*, const Layout*, uint64_t*, Output_section**)
  { }

  // Return whether this element matches FILE_NAME and SECTION_NAME.
  // The only real implementation is in Output_section_element_input.
  virtual bool
  match_name(const char*, const char*, bool *) const
  { return false; }

  // Set section addresses.  This includes applying assignments if the
  // expression is an absolute value.
  virtual void
  set_section_addresses(Symbol_table*, Layout*, Output_section*, uint64_t,
			uint64_t*, uint64_t*, Output_section**, std::string*,
			Input_section_list*)
  { }

  // Print the element for debugging purposes.
  virtual void
  print(FILE* f) const = 0;

 protected:
  // Return a fill string that is LENGTH bytes long, filling it with
  // FILL.
  std::string
  get_fill_string(const std::string* fill, section_size_type length) const;
};

std::string
Output_section_element::get_fill_string(const std::string* fill,
					section_size_type length) const
{
  std::string this_fill;
  this_fill.reserve(length);
  while (this_fill.length() + fill->length() <= length)
    this_fill += *fill;
  if (this_fill.length() < length)
    this_fill.append(*fill, 0, length - this_fill.length());
  return this_fill;
}

// A symbol assignment in an output section.

class Output_section_element_assignment : public Output_section_element
{
 public:
  Output_section_element_assignment(const char* name, size_t namelen,
				    Expression* val, bool provide,
				    bool hidden)
    : assignment_(name, namelen, false, val, provide, hidden)
  { }

  // Add the symbol to the symbol table.
  void
  add_symbols_to_table(Symbol_table* symtab)
  { this->assignment_.add_to_table(symtab); }

  // Finalize the symbol.
  void
  finalize_symbols(Symbol_table* symtab, const Layout* layout,
		   uint64_t* dot_value, Output_section** dot_section)
  {
    this->assignment_.finalize_with_dot(symtab, layout, *dot_value,
					*dot_section);
  }

  // Set the section address.  There is no section here, but if the
  // value is absolute, we set the symbol.  This permits us to use
  // absolute symbols when setting dot.
  void
  set_section_addresses(Symbol_table* symtab, Layout* layout, Output_section*,
			uint64_t, uint64_t* dot_value, uint64_t*,
			Output_section** dot_section, std::string*,
			Input_section_list*)
  {
    this->assignment_.set_if_absolute(symtab, layout, true, *dot_value,
				      *dot_section);
  }

  // Print for debugging.
  void
  print(FILE* f) const
  {
    fprintf(f, "    ");
    this->assignment_.print(f);
  }

 private:
  Symbol_assignment assignment_;
};

// An assignment to the dot symbol in an output section.

class Output_section_element_dot_assignment : public Output_section_element
{
 public:
  Output_section_element_dot_assignment(Expression* val)
    : val_(val)
  { }

  // An assignment to dot within an output section is enough to force
  // the output section to exist.
  bool
  needs_output_section() const
  { return true; }

  // Finalize the symbol.
  void
  finalize_symbols(Symbol_table* symtab, const Layout* layout,
		   uint64_t* dot_value, Output_section** dot_section)
  {
    *dot_value = this->val_->eval_with_dot(symtab, layout, true, *dot_value,
					   *dot_section, dot_section, NULL,
					   true);
  }

  // Update the dot symbol while setting section addresses.
  void
  set_section_addresses(Symbol_table* symtab, Layout* layout, Output_section*,
			uint64_t, uint64_t* dot_value, uint64_t*,
			Output_section** dot_section, std::string*,
			Input_section_list*);

  // Print for debugging.
  void
  print(FILE* f) const
  {
    fprintf(f, "    . = ");
    this->val_->print(f);
    fprintf(f, "\n");
  }

 private:
  Expression* val_;
};

// Update the dot symbol while setting section addresses.

void
Output_section_element_dot_assignment::set_section_addresses(
    Symbol_table* symtab,
    Layout* layout,
    Output_section* output_section,
    uint64_t,
    uint64_t* dot_value,
    uint64_t* dot_alignment,
    Output_section** dot_section,
    std::string* fill,
    Input_section_list*)
{
  uint64_t next_dot = this->val_->eval_with_dot(symtab, layout, false,
						*dot_value, *dot_section,
						dot_section, dot_alignment,
						true);
  if (next_dot < *dot_value)
    gold_error(_("dot may not move backward"));
  if (next_dot > *dot_value && output_section != NULL)
    {
      section_size_type length = convert_to_section_size_type(next_dot
							      - *dot_value);
      Output_section_data* posd;
      if (fill->empty())
	posd = new Output_data_zero_fill(length, 0);
      else
	{
	  std::string this_fill = this->get_fill_string(fill, length);
	  posd = new Output_data_const(this_fill, 0);
	}
      output_section->add_output_section_data(posd);
      layout->new_output_section_data_from_script(posd);
    }
  *dot_value = next_dot;
}

// An assertion in an output section.

class Output_section_element_assertion : public Output_section_element
{
 public:
  Output_section_element_assertion(Expression* check, const char* message,
				   size_t messagelen)
    : assertion_(check, message, messagelen)
  { }

  void
  print(FILE* f) const
  {
    fprintf(f, "    ");
    this->assertion_.print(f);
  }

 private:
  Script_assertion assertion_;
};

// We use a special instance of Output_section_data to handle BYTE,
// SHORT, etc.  This permits forward references to symbols in the
// expressions.

class Output_data_expression : public Output_section_data
{
 public:
  Output_data_expression(int size, bool is_signed, Expression* val,
			 const Symbol_table* symtab, const Layout* layout,
			 uint64_t dot_value, Output_section* dot_section)
    : Output_section_data(size, 0, true),
      is_signed_(is_signed), val_(val), symtab_(symtab),
      layout_(layout), dot_value_(dot_value), dot_section_(dot_section)
  { }

 protected:
  // Write the data to the output file.
  void
  do_write(Output_file*);

  // Write the data to a buffer.
  void
  do_write_to_buffer(unsigned char*);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** expression")); }

 private:
  template<bool big_endian>
  void
  endian_write_to_buffer(uint64_t, unsigned char*);

  bool is_signed_;
  Expression* val_;
  const Symbol_table* symtab_;
  const Layout* layout_;
  uint64_t dot_value_;
  Output_section* dot_section_;
};

// Write the data element to the output file.

void
Output_data_expression::do_write(Output_file* of)
{
  unsigned char* view = of->get_output_view(this->offset(), this->data_size());
  this->write_to_buffer(view);
  of->write_output_view(this->offset(), this->data_size(), view);
}

// Write the data element to a buffer.

void
Output_data_expression::do_write_to_buffer(unsigned char* buf)
{
  uint64_t val = this->val_->eval_with_dot(this->symtab_, this->layout_,
					   true, this->dot_value_,
					   this->dot_section_, NULL, NULL,
					   false);

  if (parameters->target().is_big_endian())
    this->endian_write_to_buffer<true>(val, buf);
  else
    this->endian_write_to_buffer<false>(val, buf);
}

template<bool big_endian>
void
Output_data_expression::endian_write_to_buffer(uint64_t val,
					       unsigned char* buf)
{
  switch (this->data_size())
    {
    case 1:
      elfcpp::Swap_unaligned<8, big_endian>::writeval(buf, val);
      break;
    case 2:
      elfcpp::Swap_unaligned<16, big_endian>::writeval(buf, val);
      break;
    case 4:
      elfcpp::Swap_unaligned<32, big_endian>::writeval(buf, val);
      break;
    case 8:
      if (parameters->target().get_size() == 32)
	{
	  val &= 0xffffffff;
	  if (this->is_signed_ && (val & 0x80000000) != 0)
	    val |= 0xffffffff00000000LL;
	}
      elfcpp::Swap_unaligned<64, big_endian>::writeval(buf, val);
      break;
    default:
      gold_unreachable();
    }
}

// A data item in an output section.

class Output_section_element_data : public Output_section_element
{
 public:
  Output_section_element_data(int size, bool is_signed, Expression* val)
    : size_(size), is_signed_(is_signed), val_(val)
  { }

  // If there is a data item, then we must create an output section.
  bool
  needs_output_section() const
  { return true; }

  // Finalize symbols--we just need to update dot.
  void
  finalize_symbols(Symbol_table*, const Layout*, uint64_t* dot_value,
		   Output_section**)
  { *dot_value += this->size_; }

  // Store the value in the section.
  void
  set_section_addresses(Symbol_table*, Layout*, Output_section*, uint64_t,
			uint64_t* dot_value, uint64_t*, Output_section**,
			std::string*, Input_section_list*);

  // Print for debugging.
  void
  print(FILE*) const;

 private:
  // The size in bytes.
  int size_;
  // Whether the value is signed.
  bool is_signed_;
  // The value.
  Expression* val_;
};

// Store the value in the section.

void
Output_section_element_data::set_section_addresses(
    Symbol_table* symtab,
    Layout* layout,
    Output_section* os,
    uint64_t,
    uint64_t* dot_value,
    uint64_t*,
    Output_section** dot_section,
    std::string*,
    Input_section_list*)
{
  gold_assert(os != NULL);
  Output_data_expression* expression =
    new Output_data_expression(this->size_, this->is_signed_, this->val_,
			       symtab, layout, *dot_value, *dot_section);
  os->add_output_section_data(expression);
  layout->new_output_section_data_from_script(expression);
  *dot_value += this->size_;
}

// Print for debugging.

void
Output_section_element_data::print(FILE* f) const
{
  const char* s;
  switch (this->size_)
    {
    case 1:
      s = "BYTE";
      break;
    case 2:
      s = "SHORT";
      break;
    case 4:
      s = "LONG";
      break;
    case 8:
      if (this->is_signed_)
	s = "SQUAD";
      else
	s = "QUAD";
      break;
    default:
      gold_unreachable();
    }
  fprintf(f, "    %s(", s);
  this->val_->print(f);
  fprintf(f, ")\n");
}

// A fill value setting in an output section.

class Output_section_element_fill : public Output_section_element
{
 public:
  Output_section_element_fill(Expression* val)
    : val_(val)
  { }

  // Update the fill value while setting section addresses.
  void
  set_section_addresses(Symbol_table* symtab, Layout* layout, Output_section*,
			uint64_t, uint64_t* dot_value, uint64_t*,
			Output_section** dot_section,
			std::string* fill, Input_section_list*)
  {
    Output_section* fill_section;
    uint64_t fill_val = this->val_->eval_with_dot(symtab, layout, false,
						  *dot_value, *dot_section,
						  &fill_section, NULL, false);
    if (fill_section != NULL)
      gold_warning(_("fill value is not absolute"));
    // FIXME: The GNU linker supports fill values of arbitrary length.
    unsigned char fill_buff[4];
    elfcpp::Swap_unaligned<32, true>::writeval(fill_buff, fill_val);
    fill->assign(reinterpret_cast<char*>(fill_buff), 4);
  }

  // Print for debugging.
  void
  print(FILE* f) const
  {
    fprintf(f, "    FILL(");
    this->val_->print(f);
    fprintf(f, ")\n");
  }

 private:
  // The new fill value.
  Expression* val_;
};

// An input section specification in an output section

class Output_section_element_input : public Output_section_element
{
 public:
  Output_section_element_input(const Input_section_spec* spec, bool keep);

  // Finalize symbols--just update the value of the dot symbol.
  void
  finalize_symbols(Symbol_table*, const Layout*, uint64_t* dot_value,
		   Output_section** dot_section)
  {
    *dot_value = this->final_dot_value_;
    *dot_section = this->final_dot_section_;
  }

  // See whether we match FILE_NAME and SECTION_NAME as an input section.
  // If we do then also indicate whether the section should be KEPT.
  bool
  match_name(const char* file_name, const char* section_name, bool* keep) const;

  // Set the section address.
  void
  set_section_addresses(Symbol_table* symtab, Layout* layout, Output_section*,
			uint64_t subalign, uint64_t* dot_value, uint64_t*,
			Output_section**, std::string* fill,
			Input_section_list*);

  // Print for debugging.
  void
  print(FILE* f) const;

 private:
  // An input section pattern.
  struct Input_section_pattern
  {
    std::string pattern;
    bool pattern_is_wildcard;
    Sort_wildcard sort;

    Input_section_pattern(const char* patterna, size_t patternlena,
			  Sort_wildcard sorta)
      : pattern(patterna, patternlena),
	pattern_is_wildcard(is_wildcard_string(this->pattern.c_str())),
	sort(sorta)
    { }
  };

  typedef std::vector<Input_section_pattern> Input_section_patterns;

  // Filename_exclusions is a pair of filename pattern and a bool
  // indicating whether the filename is a wildcard.
  typedef std::vector<std::pair<std::string, bool> > Filename_exclusions;

  // Return whether STRING matches PATTERN, where IS_WILDCARD_PATTERN
  // indicates whether this is a wildcard pattern.
  static inline bool
  match(const char* string, const char* pattern, bool is_wildcard_pattern)
  {
    return (is_wildcard_pattern
	    ? fnmatch(pattern, string, 0) == 0
	    : strcmp(string, pattern) == 0);
  }

  // See if we match a file name.
  bool
  match_file_name(const char* file_name) const;

  // The file name pattern.  If this is the empty string, we match all
  // files.
  std::string filename_pattern_;
  // Whether the file name pattern is a wildcard.
  bool filename_is_wildcard_;
  // How the file names should be sorted.  This may only be
  // SORT_WILDCARD_NONE or SORT_WILDCARD_BY_NAME.
  Sort_wildcard filename_sort_;
  // The list of file names to exclude.
  Filename_exclusions filename_exclusions_;
  // The list of input section patterns.
  Input_section_patterns input_section_patterns_;
  // Whether to keep this section when garbage collecting.
  bool keep_;
  // The value of dot after including all matching sections.
  uint64_t final_dot_value_;
  // The section where dot is defined after including all matching
  // sections.
  Output_section* final_dot_section_;
};

// Construct Output_section_element_input.  The parser records strings
// as pointers into a copy of the script file, which will go away when
// parsing is complete.  We make sure they are in std::string objects.

Output_section_element_input::Output_section_element_input(
    const Input_section_spec* spec,
    bool keep)
  : filename_pattern_(),
    filename_is_wildcard_(false),
    filename_sort_(spec->file.sort),
    filename_exclusions_(),
    input_section_patterns_(),
    keep_(keep),
    final_dot_value_(0),
    final_dot_section_(NULL)
{
  // The filename pattern "*" is common, and matches all files.  Turn
  // it into the empty string.
  if (spec->file.name.length != 1 || spec->file.name.value[0] != '*')
    this->filename_pattern_.assign(spec->file.name.value,
				   spec->file.name.length);
  this->filename_is_wildcard_ = is_wildcard_string(this->filename_pattern_.c_str());

  if (spec->input_sections.exclude != NULL)
    {
      for (String_list::const_iterator p =
	     spec->input_sections.exclude->begin();
	   p != spec->input_sections.exclude->end();
	   ++p)
	{
	  bool is_wildcard = is_wildcard_string((*p).c_str());
	  this->filename_exclusions_.push_back(std::make_pair(*p,
							      is_wildcard));
	}
    }

  if (spec->input_sections.sections != NULL)
    {
      Input_section_patterns& isp(this->input_section_patterns_);
      for (String_sort_list::const_iterator p =
	     spec->input_sections.sections->begin();
	   p != spec->input_sections.sections->end();
	   ++p)
	isp.push_back(Input_section_pattern(p->name.value, p->name.length,
					    p->sort));
    }
}

// See whether we match FILE_NAME.

bool
Output_section_element_input::match_file_name(const char* file_name) const
{
  if (!this->filename_pattern_.empty())
    {
      // If we were called with no filename, we refuse to match a
      // pattern which requires a file name.
      if (file_name == NULL)
	return false;

      if (!match(file_name, this->filename_pattern_.c_str(),
		 this->filename_is_wildcard_))
	return false;
    }

  if (file_name != NULL)
    {
      // Now we have to see whether FILE_NAME matches one of the
      // exclusion patterns, if any.
      for (Filename_exclusions::const_iterator p =
	     this->filename_exclusions_.begin();
	   p != this->filename_exclusions_.end();
	   ++p)
	{
	  if (match(file_name, p->first.c_str(), p->second))
	    return false;
	}
    }

  return true;
}

// See whether we match FILE_NAME and SECTION_NAME.  If we do then
// KEEP indicates whether the section should survive garbage collection.

bool
Output_section_element_input::match_name(const char* file_name,
					 const char* section_name,
					 bool *keep) const
{
  if (!this->match_file_name(file_name))
    return false;

  *keep = this->keep_;

  // If there are no section name patterns, then we match.
  if (this->input_section_patterns_.empty())
    return true;

  // See whether we match the section name patterns.
  for (Input_section_patterns::const_iterator p =
	 this->input_section_patterns_.begin();
       p != this->input_section_patterns_.end();
       ++p)
    {
      if (match(section_name, p->pattern.c_str(), p->pattern_is_wildcard))
	return true;
    }

  // We didn't match any section names, so we didn't match.
  return false;
}

// Information we use to sort the input sections.

class Input_section_info
{
 public:
  Input_section_info(const Output_section::Input_section& input_section)
    : input_section_(input_section), section_name_(),
      size_(0), addralign_(1)
  { }

  // Return the simple input section.
  const Output_section::Input_section&
  input_section() const
  { return this->input_section_; }

  // Return the object.
  Relobj*
  relobj() const
  { return this->input_section_.relobj(); }

  // Return the section index.
  unsigned int
  shndx()
  { return this->input_section_.shndx(); }

  // Return the section name.
  const std::string&
  section_name() const
  { return this->section_name_; }

  // Set the section name.
  void
  set_section_name(const std::string name)
  { this->section_name_ = name; }

  // Return the section size.
  uint64_t
  size() const
  { return this->size_; }

  // Set the section size.
  void
  set_size(uint64_t size)
  { this->size_ = size; }

  // Return the address alignment.
  uint64_t
  addralign() const
  { return this->addralign_; }

  // Set the address alignment.
  void
  set_addralign(uint64_t addralign)
  { this->addralign_ = addralign; }

 private:
  // Input section, can be a relaxed section.
  Output_section::Input_section input_section_;
  // Name of the section. 
  std::string section_name_;
  // Section size.
  uint64_t size_;
  // Address alignment.
  uint64_t addralign_;
};

// A class to sort the input sections.

class Input_section_sorter
{
 public:
  Input_section_sorter(Sort_wildcard filename_sort, Sort_wildcard section_sort)
    : filename_sort_(filename_sort), section_sort_(section_sort)
  { }

  bool
  operator()(const Input_section_info&, const Input_section_info&) const;

 private:
  Sort_wildcard filename_sort_;
  Sort_wildcard section_sort_;
};

bool
Input_section_sorter::operator()(const Input_section_info& isi1,
				 const Input_section_info& isi2) const
{
  if (this->section_sort_ == SORT_WILDCARD_BY_NAME
      || this->section_sort_ == SORT_WILDCARD_BY_NAME_BY_ALIGNMENT
      || (this->section_sort_ == SORT_WILDCARD_BY_ALIGNMENT_BY_NAME
	  && isi1.addralign() == isi2.addralign()))
    {
      if (isi1.section_name() != isi2.section_name())
	return isi1.section_name() < isi2.section_name();
    }
  if (this->section_sort_ == SORT_WILDCARD_BY_ALIGNMENT
      || this->section_sort_ == SORT_WILDCARD_BY_NAME_BY_ALIGNMENT
      || this->section_sort_ == SORT_WILDCARD_BY_ALIGNMENT_BY_NAME)
    {
      if (isi1.addralign() != isi2.addralign())
	return isi1.addralign() < isi2.addralign();
    }
  if (this->filename_sort_ == SORT_WILDCARD_BY_NAME)
    {
      if (isi1.relobj()->name() != isi2.relobj()->name())
	return (isi1.relobj()->name() < isi2.relobj()->name());
    }

  // Otherwise we leave them in the same order.
  return false;
}

// Set the section address.  Look in INPUT_SECTIONS for sections which
// match this spec, sort them as specified, and add them to the output
// section.

void
Output_section_element_input::set_section_addresses(
    Symbol_table*,
    Layout* layout,
    Output_section* output_section,
    uint64_t subalign,
    uint64_t* dot_value,
    uint64_t*,
    Output_section** dot_section,
    std::string* fill,
    Input_section_list* input_sections)
{
  // We build a list of sections which match each
  // Input_section_pattern.

  typedef std::vector<std::vector<Input_section_info> > Matching_sections;
  size_t input_pattern_count = this->input_section_patterns_.size();
  if (input_pattern_count == 0)
    input_pattern_count = 1;
  Matching_sections matching_sections(input_pattern_count);

  // Look through the list of sections for this output section.  Add
  // each one which matches to one of the elements of
  // MATCHING_SECTIONS.

  Input_section_list::iterator p = input_sections->begin();
  while (p != input_sections->end())
    {
      Relobj* relobj = p->relobj();
      unsigned int shndx = p->shndx();      
      Input_section_info isi(*p);

      // Calling section_name and section_addralign is not very
      // efficient.

      // Lock the object so that we can get information about the
      // section.  This is OK since we know we are single-threaded
      // here.
      {
	const Task* task = reinterpret_cast<const Task*>(-1);
	Task_lock_obj<Object> tl(task, relobj);

	isi.set_section_name(relobj->section_name(shndx));
	if (p->is_relaxed_input_section())
	  {
	    // We use current data size because relaxed section sizes may not
	    // have finalized yet.
	    isi.set_size(p->relaxed_input_section()->current_data_size());
	    isi.set_addralign(p->relaxed_input_section()->addralign());
	  }
	else
	  {
	    isi.set_size(relobj->section_size(shndx));
	    isi.set_addralign(relobj->section_addralign(shndx));
	  }
      }

      if (!this->match_file_name(relobj->name().c_str()))
	++p;
      else if (this->input_section_patterns_.empty())
	{
	  matching_sections[0].push_back(isi);
	  p = input_sections->erase(p);
	}
      else
	{
	  size_t i;
	  for (i = 0; i < input_pattern_count; ++i)
	    {
	      const Input_section_pattern&
		isp(this->input_section_patterns_[i]);
	      if (match(isi.section_name().c_str(), isp.pattern.c_str(),
			isp.pattern_is_wildcard))
		break;
	    }

	  if (i >= this->input_section_patterns_.size())
	    ++p;
	  else
	    {
	      matching_sections[i].push_back(isi);
	      p = input_sections->erase(p);
	    }
	}
    }

  // Look through MATCHING_SECTIONS.  Sort each one as specified,
  // using a stable sort so that we get the default order when
  // sections are otherwise equal.  Add each input section to the
  // output section.

  uint64_t dot = *dot_value;
  for (size_t i = 0; i < input_pattern_count; ++i)
    {
      if (matching_sections[i].empty())
	continue;

      gold_assert(output_section != NULL);

      const Input_section_pattern& isp(this->input_section_patterns_[i]);
      if (isp.sort != SORT_WILDCARD_NONE
	  || this->filename_sort_ != SORT_WILDCARD_NONE)
	std::stable_sort(matching_sections[i].begin(),
			 matching_sections[i].end(),
			 Input_section_sorter(this->filename_sort_,
					      isp.sort));

      for (std::vector<Input_section_info>::const_iterator p =
	     matching_sections[i].begin();
	   p != matching_sections[i].end();
	   ++p)
	{
	  // Override the original address alignment if SUBALIGN is specified
	  // and is greater than the original alignment.  We need to make a
	  // copy of the input section to modify the alignment.
	  Output_section::Input_section sis(p->input_section());

	  uint64_t this_subalign = sis.addralign();
	  if (!sis.is_input_section())
	    sis.output_section_data()->finalize_data_size();	
	  uint64_t data_size = sis.data_size();
	  if (this_subalign < subalign)
	    {
	      this_subalign = subalign;
	      sis.set_addralign(subalign);
	    }

	  uint64_t address = align_address(dot, this_subalign);

	  if (address > dot && !fill->empty())
	    {
	      section_size_type length =
		convert_to_section_size_type(address - dot);
	      std::string this_fill = this->get_fill_string(fill, length);
	      Output_section_data* posd = new Output_data_const(this_fill, 0);
	      output_section->add_output_section_data(posd);
	      layout->new_output_section_data_from_script(posd);
	    }

	  output_section->add_script_input_section(sis);
	  dot = address + data_size;
	}
    }

  // An SHF_TLS/SHT_NOBITS section does not take up any
  // address space.
  if (output_section == NULL
      || (output_section->flags() & elfcpp::SHF_TLS) == 0
      || output_section->type() != elfcpp::SHT_NOBITS)
    *dot_value = dot;

  this->final_dot_value_ = *dot_value;
  this->final_dot_section_ = *dot_section;
}

// Print for debugging.

void
Output_section_element_input::print(FILE* f) const
{
  fprintf(f, "    ");

  if (this->keep_)
    fprintf(f, "KEEP(");

  if (!this->filename_pattern_.empty())
    {
      bool need_close_paren = false;
      switch (this->filename_sort_)
	{
	case SORT_WILDCARD_NONE:
	  break;
	case SORT_WILDCARD_BY_NAME:
	  fprintf(f, "SORT_BY_NAME(");
	  need_close_paren = true;
	  break;
	default:
	  gold_unreachable();
	}

      fprintf(f, "%s", this->filename_pattern_.c_str());

      if (need_close_paren)
	fprintf(f, ")");
    }

  if (!this->input_section_patterns_.empty()
      || !this->filename_exclusions_.empty())
    {
      fprintf(f, "(");

      bool need_space = false;
      if (!this->filename_exclusions_.empty())
	{
	  fprintf(f, "EXCLUDE_FILE(");
	  bool need_comma = false;
	  for (Filename_exclusions::const_iterator p =
		 this->filename_exclusions_.begin();
	       p != this->filename_exclusions_.end();
	       ++p)
	    {
	      if (need_comma)
		fprintf(f, ", ");
	      fprintf(f, "%s", p->first.c_str());
	      need_comma = true;
	    }
	  fprintf(f, ")");
	  need_space = true;
	}

      for (Input_section_patterns::const_iterator p =
	     this->input_section_patterns_.begin();
	   p != this->input_section_patterns_.end();
	   ++p)
	{
	  if (need_space)
	    fprintf(f, " ");

	  int close_parens = 0;
	  switch (p->sort)
	    {
	    case SORT_WILDCARD_NONE:
	      break;
	    case SORT_WILDCARD_BY_NAME:
	      fprintf(f, "SORT_BY_NAME(");
	      close_parens = 1;
	      break;
	    case SORT_WILDCARD_BY_ALIGNMENT:
	      fprintf(f, "SORT_BY_ALIGNMENT(");
	      close_parens = 1;
	      break;
	    case SORT_WILDCARD_BY_NAME_BY_ALIGNMENT:
	      fprintf(f, "SORT_BY_NAME(SORT_BY_ALIGNMENT(");
	      close_parens = 2;
	      break;
	    case SORT_WILDCARD_BY_ALIGNMENT_BY_NAME:
	      fprintf(f, "SORT_BY_ALIGNMENT(SORT_BY_NAME(");
	      close_parens = 2;
	      break;
	    default:
	      gold_unreachable();
	    }

	  fprintf(f, "%s", p->pattern.c_str());

	  for (int i = 0; i < close_parens; ++i)
	    fprintf(f, ")");

	  need_space = true;
	}

      fprintf(f, ")");
    }

  if (this->keep_)
    fprintf(f, ")");

  fprintf(f, "\n");
}

// An output section.

class Output_section_definition : public Sections_element
{
 public:
  typedef Output_section_element::Input_section_list Input_section_list;

  Output_section_definition(const char* name, size_t namelen,
			    const Parser_output_section_header* header);

  // Finish the output section with the information in the trailer.
  void
  finish(const Parser_output_section_trailer* trailer);

  // Add a symbol to be defined.
  void
  add_symbol_assignment(const char* name, size_t length, Expression* value,
			bool provide, bool hidden);

  // Add an assignment to the special dot symbol.
  void
  add_dot_assignment(Expression* value);

  // Add an assertion.
  void
  add_assertion(Expression* check, const char* message, size_t messagelen);

  // Add a data item to the current output section.
  void
  add_data(int size, bool is_signed, Expression* val);

  // Add a setting for the fill value.
  void
  add_fill(Expression* val);

  // Add an input section specification.
  void
  add_input_section(const Input_section_spec* spec, bool keep);

  // Return whether the output section is relro.
  bool
  is_relro() const
  { return this->is_relro_; }

  // Record that the output section is relro.
  void
  set_is_relro()
  { this->is_relro_ = true; }

  // Create any required output sections.
  void
  create_sections(Layout*);

  // Add any symbols being defined to the symbol table.
  void
  add_symbols_to_table(Symbol_table* symtab);

  // Finalize symbols and check assertions.
  void
  finalize_symbols(Symbol_table*, const Layout*, uint64_t*);

  // Return the output section name to use for an input file name and
  // section name.
  const char*
  output_section_name(const char* file_name, const char* section_name,
		      Output_section***, Script_sections::Section_type*,
		      bool*);

  // Initialize OSP with an output section.
  void
  orphan_section_init(Orphan_section_placement* osp,
		      Script_sections::Elements_iterator p)
  { osp->output_section_init(this->name_, this->output_section_, p); }

  // Set the section address.
  void
  set_section_addresses(Symbol_table* symtab, Layout* layout,
			uint64_t* dot_value, uint64_t*,
			uint64_t* load_address);

  // Check a constraint (ONLY_IF_RO, etc.) on an output section.  If
  // this section is constrained, and the input sections do not match,
  // return the constraint, and set *POSD.
  Section_constraint
  check_constraint(Output_section_definition** posd);

  // See if this is the alternate output section for a constrained
  // output section.  If it is, transfer the Output_section and return
  // true.  Otherwise return false.
  bool
  alternate_constraint(Output_section_definition*, Section_constraint);

  // Get the list of segments to use for an allocated section when
  // using a PHDRS clause.
  Output_section*
  allocate_to_segment(String_list** phdrs_list, bool* orphan);

  // Look for an output section by name and return the address, the
  // load address, the alignment, and the size.  This is used when an
  // expression refers to an output section which was not actually
  // created.  This returns true if the section was found, false
  // otherwise.
  bool
  get_output_section_info(const char*, uint64_t*, uint64_t*, uint64_t*,
                          uint64_t*) const;

  // Return the associated Output_section if there is one.
  Output_section*
  get_output_section() const
  { return this->output_section_; }

  // Print the contents to the FILE.  This is for debugging.
  void
  print(FILE*) const;

  // Return the output section type if specified or Script_sections::ST_NONE.
  Script_sections::Section_type
  section_type() const;

  // Store the memory region to use.
  void
  set_memory_region(Memory_region*, bool set_vma);

  void
  set_section_vma(Expression* address)
  { this->address_ = address; }
  
  void
  set_section_lma(Expression* address)
  { this->load_address_ = address; }

  const std::string&
  get_section_name() const
  { return this->name_; }
  
 private:
  static const char*
  script_section_type_name(Script_section_type);

  typedef std::vector<Output_section_element*> Output_section_elements;

  // The output section name.
  std::string name_;
  // The address.  This may be NULL.
  Expression* address_;
  // The load address.  This may be NULL.
  Expression* load_address_;
  // The alignment.  This may be NULL.
  Expression* align_;
  // The input section alignment.  This may be NULL.
  Expression* subalign_;
  // The constraint, if any.
  Section_constraint constraint_;
  // The fill value.  This may be NULL.
  Expression* fill_;
  // The list of segments this section should go into.  This may be
  // NULL.
  String_list* phdrs_;
  // The list of elements defining the section.
  Output_section_elements elements_;
  // The Output_section created for this definition.  This will be
  // NULL if none was created.
  Output_section* output_section_;
  // The address after it has been evaluated.
  uint64_t evaluated_address_;
  // The load address after it has been evaluated.
  uint64_t evaluated_load_address_;
  // The alignment after it has been evaluated.
  uint64_t evaluated_addralign_;
  // The output section is relro.
  bool is_relro_;
  // The output section type if specified.
  enum Script_section_type script_section_type_;
};

// Constructor.

Output_section_definition::Output_section_definition(
    const char* name,
    size_t namelen,
    const Parser_output_section_header* header)
  : name_(name, namelen),
    address_(header->address),
    load_address_(header->load_address),
    align_(header->align),
    subalign_(header->subalign),
    constraint_(header->constraint),
    fill_(NULL),
    phdrs_(NULL),
    elements_(),
    output_section_(NULL),
    evaluated_address_(0),
    evaluated_load_address_(0),
    evaluated_addralign_(0),
    is_relro_(false),
    script_section_type_(header->section_type)
{
}

// Finish an output section.

void
Output_section_definition::finish(const Parser_output_section_trailer* trailer)
{
  this->fill_ = trailer->fill;
  this->phdrs_ = trailer->phdrs;
}

// Add a symbol to be defined.

void
Output_section_definition::add_symbol_assignment(const char* name,
						 size_t length,
						 Expression* value,
						 bool provide,
						 bool hidden)
{
  Output_section_element* p = new Output_section_element_assignment(name,
								    length,
								    value,
								    provide,
								    hidden);
  this->elements_.push_back(p);
}

// Add an assignment to the special dot symbol.

void
Output_section_definition::add_dot_assignment(Expression* value)
{
  Output_section_element* p = new Output_section_element_dot_assignment(value);
  this->elements_.push_back(p);
}

// Add an assertion.

void
Output_section_definition::add_assertion(Expression* check,
					 const char* message,
					 size_t messagelen)
{
  Output_section_element* p = new Output_section_element_assertion(check,
								   message,
								   messagelen);
  this->elements_.push_back(p);
}

// Add a data item to the current output section.

void
Output_section_definition::add_data(int size, bool is_signed, Expression* val)
{
  Output_section_element* p = new Output_section_element_data(size, is_signed,
							      val);
  this->elements_.push_back(p);
}

// Add a setting for the fill value.

void
Output_section_definition::add_fill(Expression* val)
{
  Output_section_element* p = new Output_section_element_fill(val);
  this->elements_.push_back(p);
}

// Add an input section specification.

void
Output_section_definition::add_input_section(const Input_section_spec* spec,
					     bool keep)
{
  Output_section_element* p = new Output_section_element_input(spec, keep);
  this->elements_.push_back(p);
}

// Create any required output sections.  We need an output section if
// there is a data statement here.

void
Output_section_definition::create_sections(Layout* layout)
{
  if (this->output_section_ != NULL)
    return;
  for (Output_section_elements::const_iterator p = this->elements_.begin();
       p != this->elements_.end();
       ++p)
    {
      if ((*p)->needs_output_section())
	{
	  const char* name = this->name_.c_str();
	  this->output_section_ =
	    layout->make_output_section_for_script(name, this->section_type());
	  return;
	}
    }
}

// Add any symbols being defined to the symbol table.

void
Output_section_definition::add_symbols_to_table(Symbol_table* symtab)
{
  for (Output_section_elements::iterator p = this->elements_.begin();
       p != this->elements_.end();
       ++p)
    (*p)->add_symbols_to_table(symtab);
}

// Finalize symbols and check assertions.

void
Output_section_definition::finalize_symbols(Symbol_table* symtab,
					    const Layout* layout,
					    uint64_t* dot_value)
{
  if (this->output_section_ != NULL)
    *dot_value = this->output_section_->address();
  else
    {
      uint64_t address = *dot_value;
      if (this->address_ != NULL)
	{
	  address = this->address_->eval_with_dot(symtab, layout, true,
						  *dot_value, NULL,
						  NULL, NULL, false);
	}
      if (this->align_ != NULL)
	{
	  uint64_t align = this->align_->eval_with_dot(symtab, layout, true,
						       *dot_value, NULL,
						       NULL, NULL, false);
	  address = align_address(address, align);
	}
      *dot_value = address;
    }

  Output_section* dot_section = this->output_section_;
  for (Output_section_elements::iterator p = this->elements_.begin();
       p != this->elements_.end();
       ++p)
    (*p)->finalize_symbols(symtab, layout, dot_value, &dot_section);
}

// Return the output section name to use for an input section name.

const char*
Output_section_definition::output_section_name(
    const char* file_name,
    const char* section_name,
    Output_section*** slot,
    Script_sections::Section_type* psection_type,
    bool* keep)
{
  // Ask each element whether it matches NAME.
  for (Output_section_elements::const_iterator p = this->elements_.begin();
       p != this->elements_.end();
       ++p)
    {
      if ((*p)->match_name(file_name, section_name, keep))
	{
	  // We found a match for NAME, which means that it should go
	  // into this output section.
	  *slot = &this->output_section_;
	  *psection_type = this->section_type();
	  return this->name_.c_str();
	}
    }

  // We don't know about this section name.
  return NULL;
}

// Return true if memory from START to START + LENGTH is contained
// within a memory region.

bool
Script_sections::block_in_region(Symbol_table* symtab, Layout* layout,
				 uint64_t start, uint64_t length) const
{
  if (this->memory_regions_ == NULL)
    return false;

  for (Memory_regions::const_iterator mr = this->memory_regions_->begin();
       mr != this->memory_regions_->end();
       ++mr)
    {
      uint64_t s = (*mr)->start_address()->eval(symtab, layout, false);
      uint64_t l = (*mr)->length()->eval(symtab, layout, false);

      if (s <= start
	  && (s + l) >= (start + length))
	return true;
    }

  return false;
}

// Find a memory region that should be used by a given output SECTION.
// If provided set PREVIOUS_SECTION_RETURN to point to the last section
// that used the return memory region.

Memory_region*
Script_sections::find_memory_region(
    Output_section_definition* section,
    bool find_vma_region,
    Output_section_definition** previous_section_return)
{
  if (previous_section_return != NULL)
    * previous_section_return = NULL;

  // Walk the memory regions specified in this script, if any.
  if (this->memory_regions_ == NULL)
    return NULL;

  // The /DISCARD/ section never gets assigned to any region.
  if (section->get_section_name() == "/DISCARD/")
    return NULL;

  Memory_region* first_match = NULL;

  // First check to see if a region has been assigned to this section.
  for (Memory_regions::const_iterator mr = this->memory_regions_->begin();
       mr != this->memory_regions_->end();
       ++mr)
    {
      if (find_vma_region)
	{
	  for (Memory_region::Section_list::const_iterator s =
		 (*mr)->get_vma_section_list_start();
	       s != (*mr)->get_vma_section_list_end();
	       ++s)
	    if ((*s) == section)
	      {
		(*mr)->set_last_section(section);
		return *mr;
	      }
	}
      else
	{
	  for (Memory_region::Section_list::const_iterator s =
		 (*mr)->get_lma_section_list_start();
	       s != (*mr)->get_lma_section_list_end();
	       ++s)
	    if ((*s) == section)
	      {
		(*mr)->set_last_section(section);
		return *mr;
	      }
	}

      // Make a note of the first memory region whose attributes
      // are compatible with the section.  If we do not find an
      // explicit region assignment, then we will return this region.
      Output_section* out_sec = section->get_output_section();
      if (first_match == NULL
	  && out_sec != NULL
	  && (*mr)->attributes_compatible(out_sec->flags(),
					  out_sec->type()))
	first_match = *mr;
    }

  // With LMA computations, if an explicit region has not been specified then
  // we will want to set the difference between the VMA and the LMA of the
  // section were searching for to be the same as the difference between the
  // VMA and LMA of the last section to be added to first matched region.
  // Hence, if it was asked for, we return a pointer to the last section
  // known to be used by the first matched region.
  if (first_match != NULL
      && previous_section_return != NULL)
    *previous_section_return = first_match->get_last_section();

  return first_match;
}

// Set the section address.  Note that the OUTPUT_SECTION_ field will
// be NULL if no input sections were mapped to this output section.
// We still have to adjust dot and process symbol assignments.

void
Output_section_definition::set_section_addresses(Symbol_table* symtab,
						 Layout* layout,
						 uint64_t* dot_value,
						 uint64_t* dot_alignment,
                                                 uint64_t* load_address)
{
  Memory_region* vma_region = NULL;
  Memory_region* lma_region = NULL;
  Script_sections* script_sections =
    layout->script_options()->script_sections();
  uint64_t address;
  uint64_t old_dot_value = *dot_value;
  uint64_t old_load_address = *load_address;

  // If input section sorting is requested via --section-ordering-file or
  // linker plugins, then do it here.  This is important because we want 
  // any sorting specified in the linker scripts, which will be done after
  // this, to take precedence.  The final order of input sections is then 
  // guaranteed to be according to the linker script specification.
  if (this->output_section_ != NULL
      && this->output_section_->input_section_order_specified())
    this->output_section_->sort_attached_input_sections();

  // Decide the start address for the section.  The algorithm is:
  // 1) If an address has been specified in a linker script, use that.
  // 2) Otherwise if a memory region has been specified for the section,
  //    use the next free address in the region.
  // 3) Otherwise if memory regions have been specified find the first
  //    region whose attributes are compatible with this section and
  //    install it into that region.
  // 4) Otherwise use the current location counter.

  if (this->output_section_ != NULL
      // Check for --section-start.
      && parameters->options().section_start(this->output_section_->name(),
					     &address))
    ;
  else if (this->address_ == NULL)
    {
      vma_region = script_sections->find_memory_region(this, true, NULL);

      if (vma_region != NULL)
	address = vma_region->get_current_address()->eval(symtab, layout,
							  false);
      else
	address = *dot_value;
    }
  else
    address = this->address_->eval_with_dot(symtab, layout, true,
					    *dot_value, NULL, NULL,
					    dot_alignment, false);
  uint64_t align;
  if (this->align_ == NULL)
    {
      if (this->output_section_ == NULL)
	align = 0;
      else
	align = this->output_section_->addralign();
    }
  else
    {
      Output_section* align_section;
      align = this->align_->eval_with_dot(symtab, layout, true, *dot_value,
					  NULL, &align_section, NULL, false);
      if (align_section != NULL)
	gold_warning(_("alignment of section %s is not absolute"),
		     this->name_.c_str());
      if (this->output_section_ != NULL)
	this->output_section_->set_addralign(align);
    }

  address = align_address(address, align);

  uint64_t start_address = address;

  *dot_value = address;

  // Except for NOLOAD sections, the address of non-SHF_ALLOC sections is
  // forced to zero, regardless of what the linker script wants.
  if (this->output_section_ != NULL
      && ((this->output_section_->flags() & elfcpp::SHF_ALLOC) != 0
	  || this->output_section_->is_noload()))
    this->output_section_->set_address(address);

  this->evaluated_address_ = address;
  this->evaluated_addralign_ = align;

  uint64_t laddr;

  if (this->load_address_ == NULL)
    {
      Output_section_definition* previous_section;

      // Determine if an LMA region has been set for this section.
      lma_region = script_sections->find_memory_region(this, false,
						       &previous_section);

      if (lma_region != NULL)
	{
	  if (previous_section == NULL)
	    // The LMA address was explicitly set to the given region.
	    laddr = lma_region->get_current_address()->eval(symtab, layout,
							    false);
	  else 
	    {
	      // We are not going to use the discovered lma_region, so
	      // make sure that we do not update it in the code below.
	      lma_region = NULL;

	      if (this->address_ != NULL || previous_section == this)
		{
		  // Either an explicit VMA address has been set, or an
		  // explicit VMA region has been set, so set the LMA equal to
		  // the VMA.
		  laddr = address;
		}
	      else
		{
		  // The LMA address was not explicitly or implicitly set.
		  //
		  // We have been given the first memory region that is
		  // compatible with the current section and a pointer to the
		  // last section to use this region.  Set the LMA of this
		  // section so that the difference between its' VMA and LMA
		  // is the same as the difference between the VMA and LMA of
		  // the last section in the given region.
		  laddr = address + (previous_section->evaluated_load_address_
				     - previous_section->evaluated_address_);
		}
	    }

	  if (this->output_section_ != NULL)
	    this->output_section_->set_load_address(laddr);
	}
      else
	{
	  // Do not set the load address of the output section, if one exists.
	  // This allows future sections to determine what the load address
	  // should be.  If none is ever set, it will default to being the
	  // same as the vma address.
	  laddr = address;
	}
    }
  else
    {
      laddr = this->load_address_->eval_with_dot(symtab, layout, true,
						 *dot_value,
						 this->output_section_,
						 NULL, NULL, false);
      if (this->output_section_ != NULL)
        this->output_section_->set_load_address(laddr);
    }

  this->evaluated_load_address_ = laddr;

  uint64_t subalign;
  if (this->subalign_ == NULL)
    subalign = 0;
  else
    {
      Output_section* subalign_section;
      subalign = this->subalign_->eval_with_dot(symtab, layout, true,
						*dot_value, NULL,
						&subalign_section, NULL,
						false);
      if (subalign_section != NULL)
	gold_warning(_("subalign of section %s is not absolute"),
		     this->name_.c_str());
    }

  std::string fill;
  if (this->fill_ != NULL)
    {
      // FIXME: The GNU linker supports fill values of arbitrary
      // length.
      Output_section* fill_section;
      uint64_t fill_val = this->fill_->eval_with_dot(symtab, layout, true,
						     *dot_value,
						     NULL, &fill_section,
						     NULL, false);
      if (fill_section != NULL)
	gold_warning(_("fill of section %s is not absolute"),
		     this->name_.c_str());
      unsigned char fill_buff[4];
      elfcpp::Swap_unaligned<32, true>::writeval(fill_buff, fill_val);
      fill.assign(reinterpret_cast<char*>(fill_buff), 4);
    }

  Input_section_list input_sections;
  if (this->output_section_ != NULL)
    {
      // Get the list of input sections attached to this output
      // section.  This will leave the output section with only
      // Output_section_data entries.
      address += this->output_section_->get_input_sections(address,
							   fill,
							   &input_sections);
      *dot_value = address;
    }

  Output_section* dot_section = this->output_section_;
  for (Output_section_elements::iterator p = this->elements_.begin();
       p != this->elements_.end();
       ++p)
    (*p)->set_section_addresses(symtab, layout, this->output_section_,
				subalign, dot_value, dot_alignment,
				&dot_section, &fill, &input_sections);

  gold_assert(input_sections.empty());

  if (vma_region != NULL)
    {
      // Update the VMA region being used by the section now that we know how
      // big it is.  Use the current address in the region, rather than
      // start_address because that might have been aligned upwards and we
      // need to allow for the padding.
      Expression* addr = vma_region->get_current_address();
      uint64_t size = *dot_value - addr->eval(symtab, layout, false);

      vma_region->increment_offset(this->get_section_name(), size,
				   symtab, layout);
    }

  // If the LMA region is different from the VMA region, then increment the
  // offset there as well.  Note that we use the same "dot_value -
  // start_address" formula that is used in the load_address assignment below.
  if (lma_region != NULL && lma_region != vma_region)
    lma_region->increment_offset(this->get_section_name(),
				 *dot_value - start_address,
				 symtab, layout);

  // Compute the load address for the following section.
  if (this->output_section_ == NULL)
    *load_address = *dot_value;
  else if (this->load_address_ == NULL)
    {
      if (lma_region == NULL)
	*load_address = *dot_value;
      else
	*load_address =
	  lma_region->get_current_address()->eval(symtab, layout, false);
    }
  else
    *load_address = (this->output_section_->load_address()
                     + (*dot_value - start_address));

  if (this->output_section_ != NULL)
    {
      if (this->is_relro_)
	this->output_section_->set_is_relro();
      else
	this->output_section_->clear_is_relro();

      // If this is a NOLOAD section, keep dot and load address unchanged.
      if (this->output_section_->is_noload())
	{
	  *dot_value = old_dot_value;
	  *load_address = old_load_address;
	}
    }
}

// Check a constraint (ONLY_IF_RO, etc.) on an output section.  If
// this section is constrained, and the input sections do not match,
// return the constraint, and set *POSD.

Section_constraint
Output_section_definition::check_constraint(Output_section_definition** posd)
{
  switch (this->constraint_)
    {
    case CONSTRAINT_NONE:
      return CONSTRAINT_NONE;

    case CONSTRAINT_ONLY_IF_RO:
      if (this->output_section_ != NULL
	  && (this->output_section_->flags() & elfcpp::SHF_WRITE) != 0)
	{
	  *posd = this;
	  return CONSTRAINT_ONLY_IF_RO;
	}
      return CONSTRAINT_NONE;

    case CONSTRAINT_ONLY_IF_RW:
      if (this->output_section_ != NULL
	  && (this->output_section_->flags() & elfcpp::SHF_WRITE) == 0)
	{
	  *posd = this;
	  return CONSTRAINT_ONLY_IF_RW;
	}
      return CONSTRAINT_NONE;

    case CONSTRAINT_SPECIAL:
      if (this->output_section_ != NULL)
	gold_error(_("SPECIAL constraints are not implemented"));
      return CONSTRAINT_NONE;

    default:
      gold_unreachable();
    }
}

// See if this is the alternate output section for a constrained
// output section.  If it is, transfer the Output_section and return
// true.  Otherwise return false.

bool
Output_section_definition::alternate_constraint(
    Output_section_definition* posd,
    Section_constraint constraint)
{
  if (this->name_ != posd->name_)
    return false;

  switch (constraint)
    {
    case CONSTRAINT_ONLY_IF_RO:
      if (this->constraint_ != CONSTRAINT_ONLY_IF_RW)
	return false;
      break;

    case CONSTRAINT_ONLY_IF_RW:
      if (this->constraint_ != CONSTRAINT_ONLY_IF_RO)
	return false;
      break;

    default:
      gold_unreachable();
    }

  // We have found the alternate constraint.  We just need to move
  // over the Output_section.  When constraints are used properly,
  // THIS should not have an output_section pointer, as all the input
  // sections should have matched the other definition.

  if (this->output_section_ != NULL)
    gold_error(_("mismatched definition for constrained sections"));

  this->output_section_ = posd->output_section_;
  posd->output_section_ = NULL;

  if (this->is_relro_)
    this->output_section_->set_is_relro();
  else
    this->output_section_->clear_is_relro();

  return true;
}

// Get the list of segments to use for an allocated section when using
// a PHDRS clause.

Output_section*
Output_section_definition::allocate_to_segment(String_list** phdrs_list,
					       bool* orphan)
{
  // Update phdrs_list even if we don't have an output section. It
  // might be used by the following sections.
  if (this->phdrs_ != NULL)
    *phdrs_list = this->phdrs_;

  if (this->output_section_ == NULL)
    return NULL;
  if ((this->output_section_->flags() & elfcpp::SHF_ALLOC) == 0)
    return NULL;
  *orphan = false;
  return this->output_section_;
}

// Look for an output section by name and return the address, the load
// address, the alignment, and the size.  This is used when an
// expression refers to an output section which was not actually
// created.  This returns true if the section was found, false
// otherwise.

bool
Output_section_definition::get_output_section_info(const char* name,
                                                   uint64_t* address,
                                                   uint64_t* load_address,
                                                   uint64_t* addralign,
                                                   uint64_t* size) const
{
  if (this->name_ != name)
    return false;

  if (this->output_section_ != NULL)
    {
      *address = this->output_section_->address();
      if (this->output_section_->has_load_address())
        *load_address = this->output_section_->load_address();
      else
        *load_address = *address;
      *addralign = this->output_section_->addralign();
      *size = this->output_section_->current_data_size();
    }
  else
    {
      *address = this->evaluated_address_;
      *load_address = this->evaluated_load_address_;
      *addralign = this->evaluated_addralign_;
      *size = 0;
    }

  return true;
}

// Print for debugging.

void
Output_section_definition::print(FILE* f) const
{
  fprintf(f, "  %s ", this->name_.c_str());

  if (this->address_ != NULL)
    {
      this->address_->print(f);
      fprintf(f, " ");
    }

  if (this->script_section_type_ != SCRIPT_SECTION_TYPE_NONE)
      fprintf(f, "(%s) ",
	      this->script_section_type_name(this->script_section_type_));

  fprintf(f, ": ");

  if (this->load_address_ != NULL)
    {
      fprintf(f, "AT(");
      this->load_address_->print(f);
      fprintf(f, ") ");
    }

  if (this->align_ != NULL)
    {
      fprintf(f, "ALIGN(");
      this->align_->print(f);
      fprintf(f, ") ");
    }

  if (this->subalign_ != NULL)
    {
      fprintf(f, "SUBALIGN(");
      this->subalign_->print(f);
      fprintf(f, ") ");
    }

  fprintf(f, "{\n");

  for (Output_section_elements::const_iterator p = this->elements_.begin();
       p != this->elements_.end();
       ++p)
    (*p)->print(f);

  fprintf(f, "  }");

  if (this->fill_ != NULL)
    {
      fprintf(f, " = ");
      this->fill_->print(f);
    }

  if (this->phdrs_ != NULL)
    {
      for (String_list::const_iterator p = this->phdrs_->begin();
	   p != this->phdrs_->end();
	   ++p)
	fprintf(f, " :%s", p->c_str());
    }

  fprintf(f, "\n");
}

Script_sections::Section_type
Output_section_definition::section_type() const
{
  switch (this->script_section_type_)
    {
    case SCRIPT_SECTION_TYPE_NONE:
      return Script_sections::ST_NONE;
    case SCRIPT_SECTION_TYPE_NOLOAD:
      return Script_sections::ST_NOLOAD;
    case SCRIPT_SECTION_TYPE_COPY:
    case SCRIPT_SECTION_TYPE_DSECT:
    case SCRIPT_SECTION_TYPE_INFO:
    case SCRIPT_SECTION_TYPE_OVERLAY:
      // There are not really support so we treat them as ST_NONE.  The
      // parse should have issued errors for them already.
      return Script_sections::ST_NONE;
    default:
      gold_unreachable();
    }
}

// Return the name of a script section type.

const char*
Output_section_definition::script_section_type_name(
    Script_section_type script_section_type)
{
  switch (script_section_type)
    {
    case SCRIPT_SECTION_TYPE_NONE:
      return "NONE";
    case SCRIPT_SECTION_TYPE_NOLOAD:
      return "NOLOAD";
    case SCRIPT_SECTION_TYPE_DSECT:
      return "DSECT";
    case SCRIPT_SECTION_TYPE_COPY:
      return "COPY";
    case SCRIPT_SECTION_TYPE_INFO:
      return "INFO";
    case SCRIPT_SECTION_TYPE_OVERLAY:
      return "OVERLAY";
    default:
      gold_unreachable();
    }
}

void
Output_section_definition::set_memory_region(Memory_region* mr, bool set_vma)
{
  gold_assert(mr != NULL);
  // Add the current section to the specified region's list.
  mr->add_section(this, set_vma);
}

// An output section created to hold orphaned input sections.  These
// do not actually appear in linker scripts.  However, for convenience
// when setting the output section addresses, we put a marker to these
// sections in the appropriate place in the list of SECTIONS elements.

class Orphan_output_section : public Sections_element
{
 public:
  Orphan_output_section(Output_section* os)
    : os_(os)
  { }

  // Return whether the orphan output section is relro.  We can just
  // check the output section because we always set the flag, if
  // needed, just after we create the Orphan_output_section.
  bool
  is_relro() const
  { return this->os_->is_relro(); }

  // Initialize OSP with an output section.  This should have been
  // done already.
  void
  orphan_section_init(Orphan_section_placement*,
		      Script_sections::Elements_iterator)
  { gold_unreachable(); }

  // Set section addresses.
  void
  set_section_addresses(Symbol_table*, Layout*, uint64_t*, uint64_t*,
			uint64_t*);

  // Get the list of segments to use for an allocated section when
  // using a PHDRS clause.
  Output_section*
  allocate_to_segment(String_list**, bool*);

  // Return the associated Output_section.
  Output_section*
  get_output_section() const
  { return this->os_; }

  // Print for debugging.
  void
  print(FILE* f) const
  {
    fprintf(f, "  marker for orphaned output section %s\n",
	    this->os_->name());
  }

 private:
  Output_section* os_;
};

// Set section addresses.

void
Orphan_output_section::set_section_addresses(Symbol_table*, Layout*,
					     uint64_t* dot_value,
					     uint64_t*,
                                             uint64_t* load_address)
{
  typedef std::list<Output_section::Input_section> Input_section_list;

  bool have_load_address = *load_address != *dot_value;

  uint64_t address = *dot_value;
  address = align_address(address, this->os_->addralign());

  // If input section sorting is requested via --section-ordering-file or
  // linker plugins, then do it here.  This is important because we want 
  // any sorting specified in the linker scripts, which will be done after
  // this, to take precedence.  The final order of input sections is then 
  // guaranteed to be according to the linker script specification.
  if (this->os_ != NULL
      && this->os_->input_section_order_specified())
    this->os_->sort_attached_input_sections();

  // For a relocatable link, all orphan sections are put at
  // address 0.  In general we expect all sections to be at
  // address 0 for a relocatable link, but we permit the linker
  // script to override that for specific output sections.
  if (parameters->options().relocatable())
    {
      address = 0;
      *load_address = 0;
      have_load_address = false;
    }

  if ((this->os_->flags() & elfcpp::SHF_ALLOC) != 0)
    {
      this->os_->set_address(address);
      if (have_load_address)
        this->os_->set_load_address(align_address(*load_address,
                                                  this->os_->addralign()));
    }

  Input_section_list input_sections;
  address += this->os_->get_input_sections(address, "", &input_sections);

  for (Input_section_list::iterator p = input_sections.begin();
       p != input_sections.end();
       ++p)
    {
      uint64_t addralign = p->addralign();
      if (!p->is_input_section())
	p->output_section_data()->finalize_data_size();	
      uint64_t size = p->data_size();
      address = align_address(address, addralign);
      this->os_->add_script_input_section(*p);
      address += size;
    }

  if (parameters->options().relocatable())
    {
      // For a relocatable link, reset DOT_VALUE to 0.
      *dot_value = 0;
      *load_address = 0;
    }
  else if (this->os_ == NULL
	   || (this->os_->flags() & elfcpp::SHF_TLS) == 0
	   || this->os_->type() != elfcpp::SHT_NOBITS)
    {
      // An SHF_TLS/SHT_NOBITS section does not take up any address space.
      if (!have_load_address)
	*load_address = address;
      else
	*load_address += address - *dot_value;

      *dot_value = address;
    }
}

// Get the list of segments to use for an allocated section when using
// a PHDRS clause.  If this is an allocated section, return the
// Output_section.  We don't change the list of segments.

Output_section*
Orphan_output_section::allocate_to_segment(String_list**, bool* orphan)
{
  if ((this->os_->flags() & elfcpp::SHF_ALLOC) == 0)
    return NULL;
  *orphan = true;
  return this->os_;
}

// Class Phdrs_element.  A program header from a PHDRS clause.

class Phdrs_element
{
 public:
  Phdrs_element(const char* name, size_t namelen, unsigned int type,
		bool includes_filehdr, bool includes_phdrs,
		bool is_flags_valid, unsigned int flags,
		Expression* load_address)
    : name_(name, namelen), type_(type), includes_filehdr_(includes_filehdr),
      includes_phdrs_(includes_phdrs), is_flags_valid_(is_flags_valid),
      flags_(flags), load_address_(load_address), load_address_value_(0),
      segment_(NULL)
  { }

  // Return the name of this segment.
  const std::string&
  name() const
  { return this->name_; }

  // Return the type of the segment.
  unsigned int
  type() const
  { return this->type_; }

  // Whether to include the file header.
  bool
  includes_filehdr() const
  { return this->includes_filehdr_; }

  // Whether to include the program headers.
  bool
  includes_phdrs() const
  { return this->includes_phdrs_; }

  // Return whether there is a load address.
  bool
  has_load_address() const
  { return this->load_address_ != NULL; }

  // Evaluate the load address expression if there is one.
  void
  eval_load_address(Symbol_table* symtab, Layout* layout)
  {
    if (this->load_address_ != NULL)
      this->load_address_value_ = this->load_address_->eval(symtab, layout,
							    true);
  }

  // Return the load address.
  uint64_t
  load_address() const
  {
    gold_assert(this->load_address_ != NULL);
    return this->load_address_value_;
  }

  // Create the segment.
  Output_segment*
  create_segment(Layout* layout)
  {
    this->segment_ = layout->make_output_segment(this->type_, this->flags_);
    return this->segment_;
  }

  // Return the segment.
  Output_segment*
  segment()
  { return this->segment_; }

  // Release the segment.
  void
  release_segment()
  { this->segment_ = NULL; }

  // Set the segment flags if appropriate.
  void
  set_flags_if_valid()
  {
    if (this->is_flags_valid_)
      this->segment_->set_flags(this->flags_);
  }

  // Print for debugging.
  void
  print(FILE*) const;

 private:
  // The name used in the script.
  std::string name_;
  // The type of the segment (PT_LOAD, etc.).
  unsigned int type_;
  // Whether this segment includes the file header.
  bool includes_filehdr_;
  // Whether this segment includes the section headers.
  bool includes_phdrs_;
  // Whether the flags were explicitly specified.
  bool is_flags_valid_;
  // The flags for this segment (PF_R, etc.) if specified.
  unsigned int flags_;
  // The expression for the load address for this segment.  This may
  // be NULL.
  Expression* load_address_;
  // The actual load address from evaluating the expression.
  uint64_t load_address_value_;
  // The segment itself.
  Output_segment* segment_;
};

// Print for debugging.

void
Phdrs_element::print(FILE* f) const
{
  fprintf(f, "  %s 0x%x", this->name_.c_str(), this->type_);
  if (this->includes_filehdr_)
    fprintf(f, " FILEHDR");
  if (this->includes_phdrs_)
    fprintf(f, " PHDRS");
  if (this->is_flags_valid_)
    fprintf(f, " FLAGS(%u)", this->flags_);
  if (this->load_address_ != NULL)
    {
      fprintf(f, " AT(");
      this->load_address_->print(f);
      fprintf(f, ")");
    }
  fprintf(f, ";\n");
}

// Add a memory region.

void
Script_sections::add_memory_region(const char* name, size_t namelen,
				   unsigned int attributes,
				   Expression* start, Expression* length)
{
  if (this->memory_regions_ == NULL)
    this->memory_regions_ = new Memory_regions();
  else if (this->find_memory_region(name, namelen))
    {
      gold_error(_("region '%.*s' already defined"), static_cast<int>(namelen),
                  name);
      // FIXME: Add a GOLD extension to allow multiple regions with the same
      // name.  This would amount to a single region covering disjoint blocks
      // of memory, which is useful for embedded devices.
    }

  // FIXME: Check the length and start values.  Currently we allow
  // non-constant expressions for these values, whereas LD does not.

  // FIXME: Add a GOLD extension to allow NEGATIVE LENGTHS.  This would
  // describe a region that packs from the end address going down, rather
  // than the start address going up.  This would be useful for embedded
  // devices.

  this->memory_regions_->push_back(new Memory_region(name, namelen, attributes,
						     start, length));
}

// Find a memory region.

Memory_region*
Script_sections::find_memory_region(const char* name, size_t namelen)
{
  if (this->memory_regions_ == NULL)
    return NULL;

  for (Memory_regions::const_iterator m = this->memory_regions_->begin();
       m != this->memory_regions_->end();
       ++m)
    if ((*m)->name_match(name, namelen))
      return *m;

  return NULL;
}

// Find a memory region's origin.

Expression*
Script_sections::find_memory_region_origin(const char* name, size_t namelen)
{
  Memory_region* mr = find_memory_region(name, namelen);
  if (mr == NULL)
    return NULL;

  return mr->start_address();
}

// Find a memory region's length.

Expression*
Script_sections::find_memory_region_length(const char* name, size_t namelen)
{
  Memory_region* mr = find_memory_region(name, namelen);
  if (mr == NULL)
    return NULL;

  return mr->length();
}

// Set the memory region to use for the current section.

void
Script_sections::set_memory_region(Memory_region* mr, bool set_vma)
{
  gold_assert(!this->sections_elements_->empty());
  this->sections_elements_->back()->set_memory_region(mr, set_vma);
}

// Class Script_sections.

Script_sections::Script_sections()
  : saw_sections_clause_(false),
    in_sections_clause_(false),
    sections_elements_(NULL),
    output_section_(NULL),
    memory_regions_(NULL),
    phdrs_elements_(NULL),
    orphan_section_placement_(NULL),
    data_segment_align_start_(),
    saw_data_segment_align_(false),
    saw_relro_end_(false),
    saw_segment_start_expression_(false)
{
}

// Start a SECTIONS clause.

void
Script_sections::start_sections()
{
  gold_assert(!this->in_sections_clause_ && this->output_section_ == NULL);
  this->saw_sections_clause_ = true;
  this->in_sections_clause_ = true;
  if (this->sections_elements_ == NULL)
    this->sections_elements_ = new Sections_elements;
}

// Finish a SECTIONS clause.

void
Script_sections::finish_sections()
{
  gold_assert(this->in_sections_clause_ && this->output_section_ == NULL);
  this->in_sections_clause_ = false;
}

// Add a symbol to be defined.

void
Script_sections::add_symbol_assignment(const char* name, size_t length,
				       Expression* val, bool provide,
				       bool hidden)
{
  if (this->output_section_ != NULL)
    this->output_section_->add_symbol_assignment(name, length, val,
						 provide, hidden);
  else
    {
      Sections_element* p = new Sections_element_assignment(name, length,
							    val, provide,
							    hidden);
      this->sections_elements_->push_back(p);
    }
}

// Add an assignment to the special dot symbol.

void
Script_sections::add_dot_assignment(Expression* val)
{
  if (this->output_section_ != NULL)
    this->output_section_->add_dot_assignment(val);
  else
    {
      // The GNU linker permits assignments to . to appears outside of
      // a SECTIONS clause, and treats it as appearing inside, so
      // sections_elements_ may be NULL here.
      if (this->sections_elements_ == NULL)
	{
	  this->sections_elements_ = new Sections_elements;
	  this->saw_sections_clause_ = true;
	}

      Sections_element* p = new Sections_element_dot_assignment(val);
      this->sections_elements_->push_back(p);
    }
}

// Add an assertion.

void
Script_sections::add_assertion(Expression* check, const char* message,
			       size_t messagelen)
{
  if (this->output_section_ != NULL)
    this->output_section_->add_assertion(check, message, messagelen);
  else
    {
      Sections_element* p = new Sections_element_assertion(check, message,
							   messagelen);
      this->sections_elements_->push_back(p);
    }
}

// Start processing entries for an output section.

void
Script_sections::start_output_section(
    const char* name,
    size_t namelen,
    const Parser_output_section_header* header)
{
  Output_section_definition* posd = new Output_section_definition(name,
								  namelen,
								  header);
  this->sections_elements_->push_back(posd);
  gold_assert(this->output_section_ == NULL);
  this->output_section_ = posd;
}

// Stop processing entries for an output section.

void
Script_sections::finish_output_section(
    const Parser_output_section_trailer* trailer)
{
  gold_assert(this->output_section_ != NULL);
  this->output_section_->finish(trailer);
  this->output_section_ = NULL;
}

// Add a data item to the current output section.

void
Script_sections::add_data(int size, bool is_signed, Expression* val)
{
  gold_assert(this->output_section_ != NULL);
  this->output_section_->add_data(size, is_signed, val);
}

// Add a fill value setting to the current output section.

void
Script_sections::add_fill(Expression* val)
{
  gold_assert(this->output_section_ != NULL);
  this->output_section_->add_fill(val);
}

// Add an input section specification to the current output section.

void
Script_sections::add_input_section(const Input_section_spec* spec, bool keep)
{
  gold_assert(this->output_section_ != NULL);
  this->output_section_->add_input_section(spec, keep);
}

// This is called when we see DATA_SEGMENT_ALIGN.  It means that any
// subsequent output sections may be relro.

void
Script_sections::data_segment_align()
{
  if (this->saw_data_segment_align_)
    gold_error(_("DATA_SEGMENT_ALIGN may only appear once in a linker script"));
  gold_assert(!this->sections_elements_->empty());
  Sections_elements::iterator p = this->sections_elements_->end();
  --p;
  this->data_segment_align_start_ = p;
  this->saw_data_segment_align_ = true;
}

// This is called when we see DATA_SEGMENT_RELRO_END.  It means that
// any output sections seen since DATA_SEGMENT_ALIGN are relro.

void
Script_sections::data_segment_relro_end()
{
  if (this->saw_relro_end_)
    gold_error(_("DATA_SEGMENT_RELRO_END may only appear once "
		 "in a linker script"));
  this->saw_relro_end_ = true;

  if (!this->saw_data_segment_align_)
    gold_error(_("DATA_SEGMENT_RELRO_END must follow DATA_SEGMENT_ALIGN"));
  else
    {
      Sections_elements::iterator p = this->data_segment_align_start_;
      for (++p; p != this->sections_elements_->end(); ++p)
	(*p)->set_is_relro();
    }
}

// Create any required sections.

void
Script_sections::create_sections(Layout* layout)
{
  if (!this->saw_sections_clause_)
    return;
  for (Sections_elements::iterator p = this->sections_elements_->begin();
       p != this->sections_elements_->end();
       ++p)
    (*p)->create_sections(layout);
}

// Add any symbols we are defining to the symbol table.

void
Script_sections::add_symbols_to_table(Symbol_table* symtab)
{
  if (!this->saw_sections_clause_)
    return;
  for (Sections_elements::iterator p = this->sections_elements_->begin();
       p != this->sections_elements_->end();
       ++p)
    (*p)->add_symbols_to_table(symtab);
}

// Finalize symbols and check assertions.

void
Script_sections::finalize_symbols(Symbol_table* symtab, const Layout* layout)
{
  if (!this->saw_sections_clause_)
    return;
  uint64_t dot_value = 0;
  for (Sections_elements::iterator p = this->sections_elements_->begin();
       p != this->sections_elements_->end();
       ++p)
    (*p)->finalize_symbols(symtab, layout, &dot_value);
}

// Return the name of the output section to use for an input file name
// and section name.

const char*
Script_sections::output_section_name(
    const char* file_name,
    const char* section_name,
    Output_section*** output_section_slot,
    Script_sections::Section_type* psection_type,
    bool* keep)
{
  for (Sections_elements::const_iterator p = this->sections_elements_->begin();
       p != this->sections_elements_->end();
       ++p)
    {
      const char* ret = (*p)->output_section_name(file_name, section_name,
						  output_section_slot,
						  psection_type, keep);

      if (ret != NULL)
	{
	  // The special name /DISCARD/ means that the input section
	  // should be discarded.
	  if (strcmp(ret, "/DISCARD/") == 0)
	    {
	      *output_section_slot = NULL;
	      *psection_type = Script_sections::ST_NONE;
	      return NULL;
	    }
	  return ret;
	}
    }

  // If we couldn't find a mapping for the name, the output section
  // gets the name of the input section.

  *output_section_slot = NULL;
  *psection_type = Script_sections::ST_NONE;

  return section_name;
}

// Place a marker for an orphan output section into the SECTIONS
// clause.

void
Script_sections::place_orphan(Output_section* os)
{
  Orphan_section_placement* osp = this->orphan_section_placement_;
  if (osp == NULL)
    {
      // Initialize the Orphan_section_placement structure.
      osp = new Orphan_section_placement();
      for (Sections_elements::iterator p = this->sections_elements_->begin();
	   p != this->sections_elements_->end();
	   ++p)
	(*p)->orphan_section_init(osp, p);
      gold_assert(!this->sections_elements_->empty());
      Sections_elements::iterator last = this->sections_elements_->end();
      --last;
      osp->last_init(last);
      this->orphan_section_placement_ = osp;
    }

  Orphan_output_section* orphan = new Orphan_output_section(os);

  // Look for where to put ORPHAN.
  Sections_elements::iterator* where;
  if (osp->find_place(os, &where))
    {
      if ((**where)->is_relro())
	os->set_is_relro();
      else
	os->clear_is_relro();

      // We want to insert ORPHAN after *WHERE, and then update *WHERE
      // so that the next one goes after this one.
      Sections_elements::iterator p = *where;
      gold_assert(p != this->sections_elements_->end());
      ++p;
      *where = this->sections_elements_->insert(p, orphan);
    }
  else
    {
      os->clear_is_relro();
      // We don't have a place to put this orphan section.  Put it,
      // and all other sections like it, at the end, but before the
      // sections which always come at the end.
      Sections_elements::iterator last = osp->last_place();
      *where = this->sections_elements_->insert(last, orphan);
    }
}

// Set the addresses of all the output sections.  Walk through all the
// elements, tracking the dot symbol.  Apply assignments which set
// absolute symbol values, in case they are used when setting dot.
// Fill in data statement values.  As we find output sections, set the
// address, set the address of all associated input sections, and
// update dot.  Return the segment which should hold the file header
// and segment headers, if any.

Output_segment*
Script_sections::set_section_addresses(Symbol_table* symtab, Layout* layout)
{
  gold_assert(this->saw_sections_clause_);
	 
  // Implement ONLY_IF_RO/ONLY_IF_RW constraints.  These are a pain
  // for our representation.
  for (Sections_elements::iterator p = this->sections_elements_->begin();
       p != this->sections_elements_->end();
       ++p)
    {
      Output_section_definition* posd;
      Section_constraint failed_constraint = (*p)->check_constraint(&posd);
      if (failed_constraint != CONSTRAINT_NONE)
	{
	  Sections_elements::iterator q;
	  for (q = this->sections_elements_->begin();
	       q != this->sections_elements_->end();
	       ++q)
	    {
	      if (q != p)
		{
		  if ((*q)->alternate_constraint(posd, failed_constraint))
		    break;
		}
	    }

	  if (q == this->sections_elements_->end())
	    gold_error(_("no matching section constraint"));
	}
    }

  // Force the alignment of the first TLS section to be the maximum
  // alignment of all TLS sections.
  Output_section* first_tls = NULL;
  uint64_t tls_align = 0;
  for (Sections_elements::const_iterator p = this->sections_elements_->begin();
       p != this->sections_elements_->end();
       ++p)
    {
      Output_section* os = (*p)->get_output_section();
      if (os != NULL && (os->flags() & elfcpp::SHF_TLS) != 0)
	{
	  if (first_tls == NULL)
	    first_tls = os;
	  if (os->addralign() > tls_align)
	    tls_align = os->addralign();
	}
    }
  if (first_tls != NULL)
    first_tls->set_addralign(tls_align);

  // For a relocatable link, we implicitly set dot to zero.
  uint64_t dot_value = 0;
  uint64_t dot_alignment = 0;
  uint64_t load_address = 0;

  // Check to see if we want to use any of -Ttext, -Tdata and -Tbss options
  // to set section addresses.  If the script has any SEGMENT_START
  // expression, we do not set the section addresses.
  bool use_tsection_options =
    (!this->saw_segment_start_expression_
     && (parameters->options().user_set_Ttext()
	 || parameters->options().user_set_Tdata()
	 || parameters->options().user_set_Tbss()));

  for (Sections_elements::iterator p = this->sections_elements_->begin();
       p != this->sections_elements_->end();
       ++p)
    {
      Output_section* os = (*p)->get_output_section();

      // Handle -Ttext, -Tdata and -Tbss options.  We do this by looking for
      // the special sections by names and doing dot assignments. 
      if (use_tsection_options
	  && os != NULL
	  && (os->flags() & elfcpp::SHF_ALLOC) != 0)
	{
	  uint64_t new_dot_value = dot_value;

	  if (parameters->options().user_set_Ttext()
	      && strcmp(os->name(), ".text") == 0)
	    new_dot_value = parameters->options().Ttext();
	  else if (parameters->options().user_set_Tdata()
	      && strcmp(os->name(), ".data") == 0)
	    new_dot_value = parameters->options().Tdata();
	  else if (parameters->options().user_set_Tbss()
	      && strcmp(os->name(), ".bss") == 0)
	    new_dot_value = parameters->options().Tbss();

	  // Update dot and load address if necessary.
	  if (new_dot_value < dot_value)
	    gold_error(_("dot may not move backward"));
	  else if (new_dot_value != dot_value)
	    {
	      dot_value = new_dot_value;
	      load_address = new_dot_value;
	    }
	}

      (*p)->set_section_addresses(symtab, layout, &dot_value, &dot_alignment,
				  &load_address);
    } 

  if (this->phdrs_elements_ != NULL)
    {
      for (Phdrs_elements::iterator p = this->phdrs_elements_->begin();
	   p != this->phdrs_elements_->end();
	   ++p)
	(*p)->eval_load_address(symtab, layout);
    }

  return this->create_segments(layout, dot_alignment);
}

// Sort the sections in order to put them into segments.

class Sort_output_sections
{
 public:
  Sort_output_sections(const Script_sections::Sections_elements* elements)
   : elements_(elements)
  { }

  bool
  operator()(const Output_section* os1, const Output_section* os2) const;

 private:
  int
  script_compare(const Output_section* os1, const Output_section* os2) const;

 private:
  const Script_sections::Sections_elements* elements_;
};

bool
Sort_output_sections::operator()(const Output_section* os1,
				 const Output_section* os2) const
{
  // Sort first by the load address.
  uint64_t lma1 = (os1->has_load_address()
		   ? os1->load_address()
		   : os1->address());
  uint64_t lma2 = (os2->has_load_address()
		   ? os2->load_address()
		   : os2->address());
  if (lma1 != lma2)
    return lma1 < lma2;

  // Then sort by the virtual address.
  if (os1->address() != os2->address())
    return os1->address() < os2->address();

  // If the linker script says which of these sections is first, go
  // with what it says.
  int i = this->script_compare(os1, os2);
  if (i != 0)
    return i < 0;

  // Sort PROGBITS before NOBITS.
  bool nobits1 = os1->type() == elfcpp::SHT_NOBITS;
  bool nobits2 = os2->type() == elfcpp::SHT_NOBITS;
  if (nobits1 != nobits2)
    return nobits2;

  // Sort PROGBITS TLS sections to the end, NOBITS TLS sections to the
  // beginning.
  bool tls1 = (os1->flags() & elfcpp::SHF_TLS) != 0;
  bool tls2 = (os2->flags() & elfcpp::SHF_TLS) != 0;
  if (tls1 != tls2)
    return nobits1 ? tls1 : tls2;

  // Sort non-NOLOAD before NOLOAD.
  if (os1->is_noload() && !os2->is_noload())
    return true;
  if (!os1->is_noload() && os2->is_noload())
    return true;

  // The sections seem practically identical.  Sort by name to get a
  // stable sort.
  return os1->name() < os2->name();
}

// Return -1 if OS1 comes before OS2 in ELEMENTS_, 1 if comes after, 0
// if either OS1 or OS2 is not mentioned.  This ensures that we keep
// empty sections in the order in which they appear in a linker
// script.

int
Sort_output_sections::script_compare(const Output_section* os1,
				     const Output_section* os2) const
{
  if (this->elements_ == NULL)
    return 0;

  bool found_os1 = false;
  bool found_os2 = false;
  for (Script_sections::Sections_elements::const_iterator
	 p = this->elements_->begin();
       p != this->elements_->end();
       ++p)
    {
      if (os2 == (*p)->get_output_section())
	{
	  if (found_os1)
	    return -1;
	  found_os2 = true;
	}
      else if (os1 == (*p)->get_output_section())
	{
	  if (found_os2)
	    return 1;
	  found_os1 = true;
	}
    }

  return 0;
}

// Return whether OS is a BSS section.  This is a SHT_NOBITS section.
// We treat a section with the SHF_TLS flag set as taking up space
// even if it is SHT_NOBITS (this is true of .tbss), as we allocate
// space for them in the file.

bool
Script_sections::is_bss_section(const Output_section* os)
{
  return (os->type() == elfcpp::SHT_NOBITS
	  && (os->flags() & elfcpp::SHF_TLS) == 0);
}

// Return the size taken by the file header and the program headers.

size_t
Script_sections::total_header_size(Layout* layout) const
{
  size_t segment_count = layout->segment_count();
  size_t file_header_size;
  size_t segment_headers_size;
  if (parameters->target().get_size() == 32)
    {
      file_header_size = elfcpp::Elf_sizes<32>::ehdr_size;
      segment_headers_size = segment_count * elfcpp::Elf_sizes<32>::phdr_size;
    }
  else if (parameters->target().get_size() == 64)
    {
      file_header_size = elfcpp::Elf_sizes<64>::ehdr_size;
      segment_headers_size = segment_count * elfcpp::Elf_sizes<64>::phdr_size;
    }
  else
    gold_unreachable();

  return file_header_size + segment_headers_size;
}

// Return the amount we have to subtract from the LMA to accommodate
// headers of the given size.  The complication is that the file
// header have to be at the start of a page, as otherwise it will not
// be at the start of the file.

uint64_t
Script_sections::header_size_adjustment(uint64_t lma,
					size_t sizeof_headers) const
{
  const uint64_t abi_pagesize = parameters->target().abi_pagesize();
  uint64_t hdr_lma = lma - sizeof_headers;
  hdr_lma &= ~(abi_pagesize - 1);
  return lma - hdr_lma;
}

// Create the PT_LOAD segments when using a SECTIONS clause.  Returns
// the segment which should hold the file header and segment headers,
// if any.

Output_segment*
Script_sections::create_segments(Layout* layout, uint64_t dot_alignment)
{
  gold_assert(this->saw_sections_clause_);

  if (parameters->options().relocatable())
    return NULL;

  if (this->saw_phdrs_clause())
    return create_segments_from_phdrs_clause(layout, dot_alignment);

  Layout::Section_list sections;
  layout->get_allocated_sections(&sections);

  // Sort the sections by address.
  std::stable_sort(sections.begin(), sections.end(), 
		   Sort_output_sections(this->sections_elements_));

  this->create_note_and_tls_segments(layout, &sections);

  // Walk through the sections adding them to PT_LOAD segments.
  const uint64_t abi_pagesize = parameters->target().abi_pagesize();
  Output_segment* first_seg = NULL;
  Output_segment* current_seg = NULL;
  bool is_current_seg_readonly = true;
  Layout::Section_list::iterator plast = sections.end();
  uint64_t last_vma = 0;
  uint64_t last_lma = 0;
  uint64_t last_size = 0;
  for (Layout::Section_list::iterator p = sections.begin();
       p != sections.end();
       ++p)
    {
      const uint64_t vma = (*p)->address();
      const uint64_t lma = ((*p)->has_load_address()
			    ? (*p)->load_address()
			    : vma);
      const uint64_t size = (*p)->current_data_size();

      bool need_new_segment;
      if (current_seg == NULL)
	need_new_segment = true;
      else if (lma - vma != last_lma - last_vma)
	{
	  // This section has a different LMA relationship than the
	  // last one; we need a new segment.
	  need_new_segment = true;
	}
      else if (align_address(last_lma + last_size, abi_pagesize)
	       < align_address(lma, abi_pagesize))
	{
	  // Putting this section in the segment would require
	  // skipping a page.
	  need_new_segment = true;
	}
      else if (is_bss_section(*plast) && !is_bss_section(*p))
	{
	  // A non-BSS section can not follow a BSS section in the
	  // same segment.
	  need_new_segment = true;
	}
      else if (is_current_seg_readonly
	       && ((*p)->flags() & elfcpp::SHF_WRITE) != 0
	       && !parameters->options().omagic())
	{
	  // Don't put a writable section in the same segment as a
	  // non-writable section.
	  need_new_segment = true;
	}
      else
	{
	  // Otherwise, reuse the existing segment.
	  need_new_segment = false;
	}

      elfcpp::Elf_Word seg_flags =
	Layout::section_flags_to_segment((*p)->flags());

      if (need_new_segment)
	{
	  current_seg = layout->make_output_segment(elfcpp::PT_LOAD,
						    seg_flags);
	  current_seg->set_addresses(vma, lma);
	  current_seg->set_minimum_p_align(dot_alignment);
	  if (first_seg == NULL)
	    first_seg = current_seg;
	  is_current_seg_readonly = true;
	}

      current_seg->add_output_section_to_load(layout, *p, seg_flags);

      if (((*p)->flags() & elfcpp::SHF_WRITE) != 0)
	is_current_seg_readonly = false;

      plast = p;
      last_vma = vma;
      last_lma = lma;
      last_size = size;
    }

  // An ELF program should work even if the program headers are not in
  // a PT_LOAD segment.  However, it appears that the Linux kernel
  // does not set the AT_PHDR auxiliary entry in that case.  It sets
  // the load address to p_vaddr - p_offset of the first PT_LOAD
  // segment.  It then sets AT_PHDR to the load address plus the
  // offset to the program headers, e_phoff in the file header.  This
  // fails when the program headers appear in the file before the
  // first PT_LOAD segment.  Therefore, we always create a PT_LOAD
  // segment to hold the file header and the program headers.  This is
  // effectively what the GNU linker does, and it is slightly more
  // efficient in any case.  We try to use the first PT_LOAD segment
  // if we can, otherwise we make a new one.

  if (first_seg == NULL)
    return NULL;

  // -n or -N mean that the program is not demand paged and there is
  // no need to put the program headers in a PT_LOAD segment.
  if (parameters->options().nmagic() || parameters->options().omagic())
    return NULL;

  size_t sizeof_headers = this->total_header_size(layout);

  uint64_t vma = first_seg->vaddr();
  uint64_t lma = first_seg->paddr();

  uint64_t subtract = this->header_size_adjustment(lma, sizeof_headers);

  if ((lma & (abi_pagesize - 1)) >= sizeof_headers)
    {
      first_seg->set_addresses(vma - subtract, lma - subtract);
      return first_seg;
    }

  // If there is no room to squeeze in the headers, then punt.  The
  // resulting executable probably won't run on GNU/Linux, but we
  // trust that the user knows what they are doing.
  if (lma < subtract || vma < subtract)
    return NULL;

  // If memory regions have been specified and the address range
  // we are about to use is not contained within any region then
  // issue a warning message about the segment we are going to
  // create.  It will be outside of any region and so possibly
  // using non-existent or protected memory.  We test LMA rather
  // than VMA since we assume that the headers will never be
  // relocated.
  if (this->memory_regions_ != NULL
      && !this->block_in_region (NULL, layout, lma - subtract, subtract))
    gold_warning(_("creating a segment to contain the file and program"
		   " headers outside of any MEMORY region"));

  Output_segment* load_seg = layout->make_output_segment(elfcpp::PT_LOAD,
							 elfcpp::PF_R);
  load_seg->set_addresses(vma - subtract, lma - subtract);

  return load_seg;
}

// Create a PT_NOTE segment for each SHT_NOTE section and a PT_TLS
// segment if there are any SHT_TLS sections.

void
Script_sections::create_note_and_tls_segments(
    Layout* layout,
    const Layout::Section_list* sections)
{
  gold_assert(!this->saw_phdrs_clause());

  bool saw_tls = false;
  for (Layout::Section_list::const_iterator p = sections->begin();
       p != sections->end();
       ++p)
    {
      if ((*p)->type() == elfcpp::SHT_NOTE)
	{
	  elfcpp::Elf_Word seg_flags =
	    Layout::section_flags_to_segment((*p)->flags());
	  Output_segment* oseg = layout->make_output_segment(elfcpp::PT_NOTE,
							     seg_flags);
	  oseg->add_output_section_to_nonload(*p, seg_flags);

	  // Incorporate any subsequent SHT_NOTE sections, in the
	  // hopes that the script is sensible.
	  Layout::Section_list::const_iterator pnext = p + 1;
	  while (pnext != sections->end()
		 && (*pnext)->type() == elfcpp::SHT_NOTE)
	    {
	      seg_flags = Layout::section_flags_to_segment((*pnext)->flags());
	      oseg->add_output_section_to_nonload(*pnext, seg_flags);
	      p = pnext;
	      ++pnext;
	    }
	}

      if (((*p)->flags() & elfcpp::SHF_TLS) != 0)
	{
	  if (saw_tls)
	    gold_error(_("TLS sections are not adjacent"));

	  elfcpp::Elf_Word seg_flags =
	    Layout::section_flags_to_segment((*p)->flags());
	  Output_segment* oseg = layout->make_output_segment(elfcpp::PT_TLS,
							     seg_flags);
	  oseg->add_output_section_to_nonload(*p, seg_flags);

	  Layout::Section_list::const_iterator pnext = p + 1;
	  while (pnext != sections->end()
		 && ((*pnext)->flags() & elfcpp::SHF_TLS) != 0)
	    {
	      seg_flags = Layout::section_flags_to_segment((*pnext)->flags());
	      oseg->add_output_section_to_nonload(*pnext, seg_flags);
	      p = pnext;
	      ++pnext;
	    }

	  saw_tls = true;
	}

      // If we are making a shared library, and we see a section named
      // .interp then put the .interp section in a PT_INTERP segment.
      // This is for GNU ld compatibility.
      if (strcmp((*p)->name(), ".interp") == 0)
	{
	  elfcpp::Elf_Word seg_flags =
	    Layout::section_flags_to_segment((*p)->flags());
	  Output_segment* oseg = layout->make_output_segment(elfcpp::PT_INTERP,
							     seg_flags);
	  oseg->add_output_section_to_nonload(*p, seg_flags);
	}
    }
}

// Add a program header.  The PHDRS clause is syntactically distinct
// from the SECTIONS clause, but we implement it with the SECTIONS
// support because PHDRS is useless if there is no SECTIONS clause.

void
Script_sections::add_phdr(const char* name, size_t namelen, unsigned int type,
			  bool includes_filehdr, bool includes_phdrs,
			  bool is_flags_valid, unsigned int flags,
			  Expression* load_address)
{
  if (this->phdrs_elements_ == NULL)
    this->phdrs_elements_ = new Phdrs_elements();
  this->phdrs_elements_->push_back(new Phdrs_element(name, namelen, type,
						     includes_filehdr,
						     includes_phdrs,
						     is_flags_valid, flags,
						     load_address));
}

// Return the number of segments we expect to create based on the
// SECTIONS clause.  This is used to implement SIZEOF_HEADERS.

size_t
Script_sections::expected_segment_count(const Layout* layout) const
{
  if (this->saw_phdrs_clause())
    return this->phdrs_elements_->size();

  Layout::Section_list sections;
  layout->get_allocated_sections(&sections);

  // We assume that we will need two PT_LOAD segments.
  size_t ret = 2;

  bool saw_note = false;
  bool saw_tls = false;
  for (Layout::Section_list::const_iterator p = sections.begin();
       p != sections.end();
       ++p)
    {
      if ((*p)->type() == elfcpp::SHT_NOTE)
	{
	  // Assume that all note sections will fit into a single
	  // PT_NOTE segment.
	  if (!saw_note)
	    {
	      ++ret;
	      saw_note = true;
	    }
	}
      else if (((*p)->flags() & elfcpp::SHF_TLS) != 0)
	{
	  // There can only be one PT_TLS segment.
	  if (!saw_tls)
	    {
	      ++ret;
	      saw_tls = true;
	    }
	}
    }

  return ret;
}

// Create the segments from a PHDRS clause.  Return the segment which
// should hold the file header and program headers, if any.

Output_segment*
Script_sections::create_segments_from_phdrs_clause(Layout* layout,
						   uint64_t dot_alignment)
{
  this->attach_sections_using_phdrs_clause(layout);
  return this->set_phdrs_clause_addresses(layout, dot_alignment);
}

// Create the segments from the PHDRS clause, and put the output
// sections in them.

void
Script_sections::attach_sections_using_phdrs_clause(Layout* layout)
{
  typedef std::map<std::string, Output_segment*> Name_to_segment;
  Name_to_segment name_to_segment;
  for (Phdrs_elements::const_iterator p = this->phdrs_elements_->begin();
       p != this->phdrs_elements_->end();
       ++p)
    name_to_segment[(*p)->name()] = (*p)->create_segment(layout);

  // Walk through the output sections and attach them to segments.
  // Output sections in the script which do not list segments are
  // attached to the same set of segments as the immediately preceding
  // output section.
  
  String_list* phdr_names = NULL;
  bool load_segments_only = false;
  for (Sections_elements::const_iterator p = this->sections_elements_->begin();
       p != this->sections_elements_->end();
       ++p)
    {
      bool is_orphan;
      String_list* old_phdr_names = phdr_names;
      Output_section* os = (*p)->allocate_to_segment(&phdr_names, &is_orphan);
      if (os == NULL)
	continue;

      elfcpp::Elf_Word seg_flags =
	Layout::section_flags_to_segment(os->flags());

      if (phdr_names == NULL)
	{
	  // Don't worry about empty orphan sections.
	  if (is_orphan && os->current_data_size() > 0)
	    gold_error(_("allocated section %s not in any segment"),
		       os->name());

	  // To avoid later crashes drop this section into the first
	  // PT_LOAD segment.
	  for (Phdrs_elements::const_iterator ppe =
		 this->phdrs_elements_->begin();
	       ppe != this->phdrs_elements_->end();
	       ++ppe)
	    {
	      Output_segment* oseg = (*ppe)->segment();
	      if (oseg->type() == elfcpp::PT_LOAD)
		{
		  oseg->add_output_section_to_load(layout, os, seg_flags);
		  break;
		}
	    }

	  continue;
	}

      // We see a list of segments names.  Disable PT_LOAD segment only
      // filtering.
      if (old_phdr_names != phdr_names)
	load_segments_only = false;
		
      // If this is an orphan section--one that was not explicitly
      // mentioned in the linker script--then it should not inherit
      // any segment type other than PT_LOAD.  Otherwise, e.g., the
      // PT_INTERP segment will pick up following orphan sections,
      // which does not make sense.  If this is not an orphan section,
      // we trust the linker script.
      if (is_orphan)
	{
	  // Enable PT_LOAD segments only filtering until we see another
	  // list of segment names.
	  load_segments_only = true;
	}

      bool in_load_segment = false;
      for (String_list::const_iterator q = phdr_names->begin();
	   q != phdr_names->end();
	   ++q)
	{
	  Name_to_segment::const_iterator r = name_to_segment.find(*q);
	  if (r == name_to_segment.end())
	    gold_error(_("no segment %s"), q->c_str());
	  else
	    {
	      if (load_segments_only
		  && r->second->type() != elfcpp::PT_LOAD)
		continue;

	      if (r->second->type() != elfcpp::PT_LOAD)
		r->second->add_output_section_to_nonload(os, seg_flags);
	      else
		{
		  r->second->add_output_section_to_load(layout, os, seg_flags);
		  if (in_load_segment)
		    gold_error(_("section in two PT_LOAD segments"));
		  in_load_segment = true;
		}
	    }
	}

      if (!in_load_segment)
	gold_error(_("allocated section not in any PT_LOAD segment"));
    }
}

// Set the addresses for segments created from a PHDRS clause.  Return
// the segment which should hold the file header and program headers,
// if any.

Output_segment*
Script_sections::set_phdrs_clause_addresses(Layout* layout,
					    uint64_t dot_alignment)
{
  Output_segment* load_seg = NULL;
  for (Phdrs_elements::const_iterator p = this->phdrs_elements_->begin();
       p != this->phdrs_elements_->end();
       ++p)
    {
      // Note that we have to set the flags after adding the output
      // sections to the segment, as adding an output segment can
      // change the flags.
      (*p)->set_flags_if_valid();

      Output_segment* oseg = (*p)->segment();

      if (oseg->type() != elfcpp::PT_LOAD)
	{
	  // The addresses of non-PT_LOAD segments are set from the
	  // PT_LOAD segments.
	  if ((*p)->has_load_address())
	    gold_error(_("may only specify load address for PT_LOAD segment"));
	  continue;
	}

      oseg->set_minimum_p_align(dot_alignment);

      // The output sections should have addresses from the SECTIONS
      // clause.  The addresses don't have to be in order, so find the
      // one with the lowest load address.  Use that to set the
      // address of the segment.

      Output_section* osec = oseg->section_with_lowest_load_address();
      if (osec == NULL)
	{
	  oseg->set_addresses(0, 0);
	  continue;
	}

      uint64_t vma = osec->address();
      uint64_t lma = osec->has_load_address() ? osec->load_address() : vma;

      // Override the load address of the section with the load
      // address specified for the segment.
      if ((*p)->has_load_address())
	{
	  if (osec->has_load_address())
	    gold_warning(_("PHDRS load address overrides "
			   "section %s load address"),
			 osec->name());

	  lma = (*p)->load_address();
	}

      bool headers = (*p)->includes_filehdr() && (*p)->includes_phdrs();
      if (!headers && ((*p)->includes_filehdr() || (*p)->includes_phdrs()))
	{
	  // We could support this if we wanted to.
	  gold_error(_("using only one of FILEHDR and PHDRS is "
		       "not currently supported"));
	}
      if (headers)
	{
	  size_t sizeof_headers = this->total_header_size(layout);
	  uint64_t subtract = this->header_size_adjustment(lma,
							   sizeof_headers);
	  if (lma >= subtract && vma >= subtract)
	    {
	      lma -= subtract;
	      vma -= subtract;
	    }
	  else
	    {
	      gold_error(_("sections loaded on first page without room "
			   "for file and program headers "
			   "are not supported"));
	    }

	  if (load_seg != NULL)
	    gold_error(_("using FILEHDR and PHDRS on more than one "
			 "PT_LOAD segment is not currently supported"));
	  load_seg = oseg;
	}

      oseg->set_addresses(vma, lma);
    }

  return load_seg;
}

// Add the file header and segment headers to non-load segments
// specified in the PHDRS clause.

void
Script_sections::put_headers_in_phdrs(Output_data* file_header,
				      Output_data* segment_headers)
{
  gold_assert(this->saw_phdrs_clause());
  for (Phdrs_elements::iterator p = this->phdrs_elements_->begin();
       p != this->phdrs_elements_->end();
       ++p)
    {
      if ((*p)->type() != elfcpp::PT_LOAD)
	{
	  if ((*p)->includes_phdrs())
	    (*p)->segment()->add_initial_output_data(segment_headers);
	  if ((*p)->includes_filehdr())
	    (*p)->segment()->add_initial_output_data(file_header);
	}
    }
}

// Look for an output section by name and return the address, the load
// address, the alignment, and the size.  This is used when an
// expression refers to an output section which was not actually
// created.  This returns true if the section was found, false
// otherwise.

bool
Script_sections::get_output_section_info(const char* name, uint64_t* address,
                                         uint64_t* load_address,
                                         uint64_t* addralign,
                                         uint64_t* size) const
{
  if (!this->saw_sections_clause_)
    return false;
  for (Sections_elements::const_iterator p = this->sections_elements_->begin();
       p != this->sections_elements_->end();
       ++p)
    if ((*p)->get_output_section_info(name, address, load_address, addralign,
                                      size))
      return true;
  return false;
}

// Release all Output_segments.  This remove all pointers to all
// Output_segments.

void
Script_sections::release_segments()
{
  if (this->saw_phdrs_clause())
    {
      for (Phdrs_elements::const_iterator p = this->phdrs_elements_->begin();
	   p != this->phdrs_elements_->end();
	   ++p)
	(*p)->release_segment();
    }
}

// Print the SECTIONS clause to F for debugging.

void
Script_sections::print(FILE* f) const
{
  if (this->phdrs_elements_ != NULL)
    {
      fprintf(f, "PHDRS {\n");
      for (Phdrs_elements::const_iterator p = this->phdrs_elements_->begin();
	   p != this->phdrs_elements_->end();
	   ++p)
	(*p)->print(f);
      fprintf(f, "}\n");
    }

  if (this->memory_regions_ != NULL)
    {
      fprintf(f, "MEMORY {\n");
      for (Memory_regions::const_iterator m = this->memory_regions_->begin();
	   m != this->memory_regions_->end();
	   ++m)
	(*m)->print(f);
      fprintf(f, "}\n");
    }

  if (!this->saw_sections_clause_)
    return;

  fprintf(f, "SECTIONS {\n");

  for (Sections_elements::const_iterator p = this->sections_elements_->begin();
       p != this->sections_elements_->end();
       ++p)
    (*p)->print(f);

  fprintf(f, "}\n");
}

} // End namespace gold.
@


1.57
log
@Make linker scripts and section ordering via --section-ordering-file or
linker plugins work. This patch lets linker scripts take precedence.

2013-01-09  Sriraman Tallam  <tmsriram@@google.com>

	* output.h (sort_attached_input_sections): Change to be public.
	* script-sections.cc
	(Output_section_definition::set_section_addresses): Sort
	attached input sections according to section order before linker
	script assigns section addresses.
	(Orphan_output_section::set_section_addresses): Sort
	attached input sections according to section order before linker
	script assigns section addresses.
	* Makefile.am (final_layout.sh): Use a simple linker script to
	check if section ordering still works.
	* Makefile.in: Regenerate.
@
text
@d2921 9
a2929 4
  // An SHF_TLS/SHT_NOBITS section does not take up any address space.
  if (this->os_ == NULL
      || (this->os_->flags() & elfcpp::SHF_TLS) == 0
      || this->os_->type() != elfcpp::SHT_NOBITS)
d2931 1
@


1.56
log
@	PR ld/14265
	* script-sections.cc (Sections_element::output_section_name): Add
	keep return parameter.
	(Output_section_element::match_name): Add keep return parameter.
	Return the value of the keep_ member.
	* script-sections.h (class Output_section): Update
	output_section_name prototype.
	* layout.cc (Layout::keep_input_section): New public member
	function.
	(Layout::choose_output_section): Pass keep parameter to
	output_section_name.
	* layout.h (class Layout): Add keep_input_section.
	* object.cc (Sized_relobj_file::do_layout): Check for kept input
	sections.
	* testsuite/Makefile.am: Add a test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/pr14265.c: Source file for the test.
	* testsuite/pr14265.t: Linker script for the test.
	* testsuite/pr14265.sh: Shell script for the test.

	* ld-gc/gc.exp: Add a new test.
	* ld-gc/pr14265.c: Source file for the new test.
	* ld-gc/pr14265.t: Linker script for the new test.
	* ld-gc/pr14265.d: Expected symbol dump.
@
text
@d2297 9
d2877 9
@


1.55
log
@	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.
@
text
@d585 1
a585 1
		      Script_sections::Section_type*)
d803 1
a803 1
  match_name(const char*, const char*) const
d1241 2
a1242 2
  // See whether we match FILE_NAME and SECTION_NAME as an input
  // section.
d1244 1
a1244 1
  match_name(const char* file_name, const char* section_name) const;
d1396 2
a1397 1
// See whether we match FILE_NAME and SECTION_NAME.
d1401 2
a1402 1
					 const char* section_name) const
d1407 2
d1868 2
a1869 1
		      Output_section***, Script_sections::Section_type*);
d2154 2
a2155 1
    Script_sections::Section_type* psection_type)
d2162 1
a2162 1
      if ((*p)->match_name(file_name, section_name))
d3374 2
a3375 1
    Script_sections::Section_type* psection_type)
d3383 1
a3383 1
						  psection_type);
@


1.54
log
@	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.
@
text
@d683 1
a683 1
    this->assignment_.set_if_absolute(symtab, layout, true, *dot_value);
d717 1
a717 1
					   NULL, NULL, NULL);
d727 1
a727 1
					   NULL, NULL, dot_alignment);
d869 2
a870 1
			Output_section**, std::string*, Input_section_list*)
d872 2
a873 1
    this->assignment_.set_if_absolute(symtab, layout, true, *dot_value);
d909 2
a910 1
					   *dot_section, dot_section, NULL);
d917 2
a918 1
			Output_section**, std::string*, Input_section_list*);
d949 2
a950 1
						dot_section, dot_alignment);
d1051 2
a1052 1
					   this->dot_section_, NULL, NULL);
d1202 1
a1202 1
						  &fill_section, NULL);
d2123 1
a2123 1
						  NULL, NULL);
d2129 1
a2129 1
						       NULL, NULL);
d2318 1
a2318 1
					    dot_alignment);
d2331 1
a2331 1
					  NULL, &align_section, NULL);
d2416 1
a2416 1
						 NULL, NULL);
d2431 2
a2432 1
						&subalign_section, NULL);
d2447 1
a2447 1
						     NULL);
@


1.53
log
@	PR gold/12898
	* layout.cc (Layout::segment_precedes): Don't crash if a linker
	script create indistinguishable segments.
	(Layout::set_segment_offsets): Use stable_sort when sorting
	segments.  Pass this to Compare_segments constructor.
	* layout.h (class Layout): Make segment_precedes non-static.
	(class Compare_segments): Change from struct to class.  Add
	layout_ field.  Add constructor.
	* script-sections.cc
	(Script_sections::attach_sections_using_phdrs_clause): Rename
	local orphan to is_orphan.  Don't report failure to put empty
	section in segment.  On attachment failure, report name of
	section, and attach to first PT_LOAD segment.
@
text
@d895 6
@


1.53.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d683 1
a683 1
    this->assignment_.set_if_absolute(symtab, layout, true, *dot_value, NULL);
d717 1
a717 1
					   NULL, NULL, NULL, false);
d727 1
a727 1
					   NULL, NULL, dot_alignment, false);
d869 1
a869 2
			Output_section** dot_section, std::string*,
			Input_section_list*)
d871 1
a871 2
    this->assignment_.set_if_absolute(symtab, layout, true, *dot_value,
				      *dot_section);
a894 6
  // An assignment to dot within an output section is enough to force
  // the output section to exist.
  bool
  needs_output_section() const
  { return true; }

d901 1
a901 2
					   *dot_section, dot_section, NULL,
					   true);
d908 1
a908 2
			Output_section** dot_section, std::string*,
			Input_section_list*);
d939 1
a939 2
						dot_section, dot_alignment,
						true);
d1040 1
a1040 2
					   this->dot_section_, NULL, NULL,
					   false);
d1190 1
a1190 1
						  &fill_section, NULL, false);
d2111 1
a2111 1
						  NULL, NULL, false);
d2117 1
a2117 1
						       NULL, NULL, false);
d2306 1
a2306 1
					    dot_alignment, false);
d2319 1
a2319 1
					  NULL, &align_section, NULL, false);
d2404 1
a2404 1
						 NULL, NULL, false);
d2419 1
a2419 2
						&subalign_section, NULL,
						false);
d2434 1
a2434 1
						     NULL, false);
@


1.52
log
@	PR gold/12880
	* layout.cc (Layout::attach_allocated_section_to_segment): Add a
	.interp section to a PT_INTERP segment even if we have seen a
	--dynamic-linker option.  Don't do it if we have seen a PHDRS
	clause in a linker script.
	(Layout::finalize): Don't create a .interp section if we've
	already create a PT_INTERP segment.
	(Layout::create_interp): Always call choose_output_section (revert
	patch of 2011-06-17).  Don't create PT_INTERP segment.
	* script-sections.cc
	(Script_sections::create_note_and_tls_segments): Add a .interp
	section to a PT_INTERP segment even if we have seen a
	--dynamic-linker option.
@
text
@d4053 1
a4053 1
      bool orphan;
d4055 1
a4055 1
      Output_section* os = (*p)->allocate_to_segment(&phdr_names, &orphan);
d4059 3
d4064 20
a4083 1
	  gold_error(_("allocated section not in any segment"));
d4098 1
a4098 1
      if (orphan)
a4118 3
	      elfcpp::Elf_Word seg_flags =
		Layout::section_flags_to_segment(os->flags());

@


1.51
log
@	PR gold/12880
	* layout.h (class Layout): Add interp_segment_ field.
	* layout.cc (Layout::Layout): Initialize interp_segment_ field.
	(Layout::attach_allocated_section_to_segment): If making shared
	library, put .interp section in PT_INTERP segment.
	(Layout::finalize): Also call create_interp if -dynamic-linker
	option was used.
	(Layout::create_interp): Assert that there is no PT_INTERP
	segment.  If not using a SECTIONS clause, use make_output_section.
	(Layout::make_output_segment): Set interp_segment_ if PT_INTERP.
	* script-sections.cc
	(Script_sections::create_note_and_tls_segments): If making shared
	library, put .interp section in PT_INTERP segment.
@
text
@d3941 3
a3943 6
      // .interp, and the -dynamic-linker option was not used, then
      // put the .interp section in a PT_INTERP segment.  This is for
      // GNU ld compatibility.
      if (strcmp((*p)->name(), ".interp") == 0
	  && parameters->options().shared()
	  && parameters->options().dynamic_linker() == NULL)
@


1.50
log
@	* script-sections.cc
	(Orphan_output_section::set_section_addresses): For a relocatable
	link set address to 0.
@
text
@d3939 15
@


1.49
log
@	* script-sections.cc (Sort_output_sections::script_compare):
	Rename from is_before, change return type.
	(Sort_output_sections::operator()): Adjust accordingly.
@
text
@d2849 11
@


1.48
log
@	* script-sections.cc (Sort_output_sections::operator()): Sort TLS
	sections before NOBITS sections.
@
text
@d3564 2
a3565 2
  bool
  is_before(const Output_section* os1, const Output_section* os2) const;
d3589 6
d3613 4
a3616 4
  
  // The sections have the same address. Check the section positions 
  // in accordance with the linker script.
  return this->is_before(os1, os2);
d3619 8
a3626 7
// Return true if OS1 comes before OS2 in ELEMENTS_.  This ensures
// that we keep empty sections in the order in which they appear in a
// linker script.

bool
Sort_output_sections::is_before(const Output_section* os1,
				const Output_section* os2) const
d3629 1
a3629 1
    return false;
d3631 2
d3638 7
a3644 1
      if (os1 == (*p)->get_output_section())
d3646 3
a3648 4
	  for (++p; p != this->elements_->end(); ++p)
	    if (os2 == (*p)->get_output_section())
	      return true;
	  break;
d3652 1
a3652 1
  return false;
@


1.47
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d3 1
a3 1
// Copyright 2008, 2009, 2010 Free Software Foundation, Inc.
d3589 8
a3596 1
  // Sort TLS sections to the end.
d3600 1
a3600 7
    return tls2;

  // Sort PROGBITS before NOBITS.
  if (os1->type() == elfcpp::SHT_PROGBITS && os2->type() == elfcpp::SHT_NOBITS)
    return true;
  if (os1->type() == elfcpp::SHT_NOBITS && os2->type() == elfcpp::SHT_PROGBITS)
    return false;
@


1.46
log
@	* script-sections.cc (Script_sections::find_memory_region): Check
	for a NULL output section pointer.
@
text
@d3 1
a3 1
// Copyright 2008, 2009 Free Software Foundation, Inc.
d595 1
a595 1
  // the expression is an absolute value.
d807 1
a807 1
  // the expression is an absolute value.
d3676 1
a3676 1
// Return the amount we have to subtract from the LMA to accomodate
@


1.46.2.1
log
@	Backport from mainline:
	2011-01-04  Cary Coutant  <ccoutant@@google.com>
	* script-sections.cc (Sort_output_sections::operator()): Sort TLS
	sections before NOBITS sections.
@
text
@d3 1
a3 1
// Copyright 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d3589 1
a3589 8
  // Sort PROGBITS before NOBITS.
  bool nobits1 = os1->type() == elfcpp::SHT_NOBITS;
  bool nobits2 = os2->type() == elfcpp::SHT_NOBITS;
  if (nobits1 != nobits2)
    return nobits2;

  // Sort PROGBITS TLS sections to the end, NOBITS TLS sections to the
  // beginning.
d3593 7
a3599 1
    return nobits1 ? tls1 : tls2;
@


1.46.2.2
log
@	* script-sections.cc (Sort_output_sections::script_compare):
	Rename from is_before, change return type.
	(Sort_output_sections::operator()): Adjust accordingly.
@
text
@d3564 2
a3565 2
  int
  script_compare(const Output_section* os1, const Output_section* os2) const;
a3588 6
  // If the linker script says which of these sections is first, go
  // with what it says.
  int i = this->script_compare(os1, os2);
  if (i != 0)
    return i < 0;

d3607 5
d3613 3
a3615 4
  // The sections seem practically identical.  Sort by name to get a
  // stable sort.
  return os1->name() < os2->name();
}
d3617 3
a3619 8
// Return -1 if OS1 comes before OS2 in ELEMENTS_, 1 if comes after, 0
// if either OS1 or OS2 is not mentioned.  This ensures that we keep
// empty sections in the order in which they appear in a linker
// script.

int
Sort_output_sections::script_compare(const Output_section* os1,
				     const Output_section* os2) const
d3622 1
a3622 1
    return 0;
a3623 2
  bool found_os1 = false;
  bool found_os2 = false;
d3629 1
a3629 7
      if (os2 == (*p)->get_output_section())
	{
	  if (found_os1)
	    return -1;
	  found_os2 = true;
	}
      else if (os1 == (*p)->get_output_section())
d3631 4
a3634 3
	  if (found_os2)
	    return 1;
	  found_os1 = true;
d3638 1
a3638 1
  return 0;
@


1.46.2.3
log
@	* script-sections.cc
	(Orphan_output_section::set_section_addresses): For a relocatable
	link set address to 0.
@
text
@a2848 11
  // For a relocatable link, all orphan sections are put at
  // address 0.  In general we expect all sections to be at
  // address 0 for a relocatable link, but we permit the linker
  // script to override that for specific output sections.
  if (parameters->options().relocatable())
    {
      address = 0;
      *load_address = 0;
      have_load_address = false;
    }

@


1.45
log
@	* script-sections.h (class Script_sections): Make
	Sections_elements typedef public.
	* script-sections.cc (class Sort_output_sections): Add elements_
	field.  Add constructor which sets it; change all callers.
	(Sort_output_sections::is_before): New function.
	(Sort_output_sections::operator()): Call is_before.
	* configure.ac (NATIVE_OR_CROSS_LINKER): New automake
	conditional.
	* testsuite/script_test_10.sh: New test. Test script section
	order.
	* testsuite/script_test_10.t: Likewise.
	* testsuite/script_test_10.s: Likewise.
	* testsuite/Makefile.am: Wrap the cross linker tests and the
	common tests into NATIVE_OR_CROSS_LINKER.
	(check_SCRIPTS): Add script_test_10.sh.
	(check_DATA): Add script_test_10.stdout.
	(script_test_10.o, script_test_10): New targets.
	(script_test_10.stdout): New target.
	* configure, testsuite/Makefile.in: Regenerate.
@
text
@d2241 1
@


1.44
log
@        * script-sections.cc(class Memory_region): Remove
        current_lma_offset_ field.  Rename current_vma_offset_ to
        current_offset_.  Add last_section_ field.
        (Memory_region::get_current_vma_address): Rename to
        get_current_address.
        (Memory_region::get_current_lma_address): Delete.
        (Memory_region::increment_vma_offset): Rename to
        increment_offset.
        (Memory_region::increment_lma_offset): Delete.
        (Memory_region::attributes_compatible): New method.  Returns
        true if the provided section is compatible with the region.
        (Memory_region::get_last_section): New method.  Returns the last
        section to use the region.
        (Memory_region::set_last_section): New method.  Stores the last
        section to use the region.
        (Script_sections::block_in_region): New method.  Returns true if
        a block of memory is contained within a region.
        (Script_sections::find_memory_region): New method.  Locates a
        memory region to be used to set a VMA or LMA address.
        (Output_section_definition::set_section_addresses): Add code to
        check for addresses set by memory regions.
        (Output_segment::set_section_addresses): Remove memory region
        walking code.
        (Script_sections::create_segment): Add a warning if a header
        segment is created outside of any region.
        * script-sections.h (class Script_sections): Add prototypes for
        find_memory_region and block_in_region methods.
        * testsuite/memory_test.s: Use .long instead of .word.
        * testsuite/memory_test.t: Add some more output sections.
        * testsuite/memory_test.sh: Update expected output.

        * ld.texinfo: Update description of computation of VMA and LMA
        addresses for output sections.

        * ld-scripts/rgn-at5.t: Add some more output sections.
        * ld-scripts/rgn-at5.d: Update expected output.
@
text
@d3555 4
d3561 7
d3606 30
a3635 1
  // Otherwise we don't care.
d3709 2
a3710 1
  std::stable_sort(sections.begin(), sections.end(), Sort_output_sections());
@


1.43
log
@        * expression.cc (eval): Replace dummy argument with NULL.
        (eval_maybe_dot): Check for a NULL result section pointer.
        (Symbol_expression::value): Likewise.
        (Dot_expression::value): Likewise.
        (BINARY_EXPRESSION): Likewise.
        (Max_expression::value): Likewise.
        (Min_expression::value): Likewise.
        (Absolute_expression::value): Likewise.
        (Addr_expression::value_from_output_section): Likewise.
        (Loaddddr_expression::value_from_output_section): Likewise.
        (Segment_start_expression::value): Likewise.
        * script-sections.cc
        (Sections_elememt_dot_assignment::finalize_symbols): Replace dummy
        argument with NULL.
        (Sections_elememt_dot_assignment::set_section_addresses):
        Likewise.
        (Output_data_expression::do_write_to_buffer): Likewise.
        (Output_section_definition::finalize_symbols): Likewise.
        (Output_section_definition::set_section_addresses): Likewise.
@
text
@d56 1
a56 2
      current_vma_offset_(0),
      current_lma_offset_(0),
d58 2
a59 1
      lma_sections_()
d90 1
a90 1
  get_current_vma_address(void) const
d94 1
a94 9
			    script_exp_integer(this->current_vma_offset_));
  }
  
  Expression*
  get_current_lma_address(void) const
  {
    return
      script_exp_binary_add(this->start_,
			    script_exp_integer(this->current_lma_offset_));
d98 2
a99 2
  increment_vma_offset(std::string section_name, uint64_t amount,
		       const Symbol_table* symtab, const Layout* layout)
d101 1
a101 1
    this->current_vma_offset_ += amount;
d103 1
a103 1
    if (this->current_vma_offset_
d105 2
a106 2
      gold_error (_("section %s overflows end of region %s"),
		  section_name.c_str(), this->name_.c_str());
d109 5
a113 3
  void
  increment_lma_offset(std::string section_name, uint64_t amount,
		       const Symbol_table* symtab, const Layout* layout)
d115 2
a116 6
    this->current_lma_offset_ += amount;

    if (this->current_lma_offset_
	> this->length_->eval(symtab, layout, false))
      gold_error (_("section %s overflows end of region %s (based on load address)"),
		  section_name.c_str(), this->name_.c_str());
d119 5
d138 1
a138 1
  get_vma_section_list_start(void) const
d144 1
a144 1
  get_lma_section_list_start(void) const
d150 1
a150 1
  get_vma_section_list_end(void) const
d156 1
a156 1
  get_lma_section_list_end(void) const
d159 8
d173 5
a177 2
  uint64_t current_vma_offset_;
  uint64_t current_lma_offset_;
d182 2
d186 49
d1572 1
a1572 1
	    // We use current data size because relxed section sizes may not
d1917 2
a1918 2
  std::string
  get_section_name(void) const
d2158 101
d2270 4
d2278 21
a2298 10
  // Check for --section-start.
  bool is_address_set = false;
  if (this->output_section_ != NULL)
    is_address_set =
      parameters->options().section_start(this->output_section_->name(),
                                          &address);
  if (!is_address_set)
    {
      if (this->address_ == NULL)
        address = *dot_value;
d2300 1
a2300 5
        {
          address = this->address_->eval_with_dot(symtab, layout, true,
                                                  *dot_value, NULL, NULL,
                                                  dot_alignment);
        }
d2302 4
a2305 1

d2342 2
d2345 53
a2397 1
    this->evaluated_load_address_ = address;
d2400 4
a2403 3
      uint64_t laddr =
	this->load_address_->eval_with_dot(symtab, layout, true, *dot_value,
					   this->output_section_, NULL, NULL);
a2405 1
      this->evaluated_load_address_ = laddr;
d2408 2
d2464 23
a2486 1
  if (this->load_address_ == NULL || this->output_section_ == NULL)
d2488 8
d3040 1
a3040 1
      gold_error (_("region '%.*s' already defined"), static_cast<int>(namelen),
a3438 35

  // Walk the memory regions specified in this script, if any.
  if (this->memory_regions_ != NULL)
    {
      for (Memory_regions::const_iterator mr = this->memory_regions_->begin();
	   mr != this->memory_regions_->end();
	   ++mr)
	{
	  // FIXME: What should we do with the attributes of the regions ?

	  // For each region, set the VMA of the sections associated with it.
	  for (Memory_region::Section_list::const_iterator s =
		 (*mr)->get_vma_section_list_start();
	       s != (*mr)->get_vma_section_list_end();
	       ++s)
	    {
	      (*s)->set_section_vma((*mr)->get_current_vma_address());
	      (*mr)->increment_vma_offset((*s)->get_section_name(),
					  (*s)->get_output_section()->current_data_size(),
					  symtab, layout);
	    }

	  // Similarly, set the LMA values.
	  for (Memory_region::Section_list::const_iterator s =
		 (*mr)->get_lma_section_list_start();
	       s != (*mr)->get_lma_section_list_end();
	       ++s)
	    {
	      (*s)->set_section_lma((*mr)->get_current_lma_address());
	      (*mr)->increment_lma_offset((*s)->get_section_name(),
					  (*s)->get_output_section()->current_data_size(),
					  symtab, layout);
	    }
	}
    }
d3793 12
@


1.42
log
@	* script_sections.cc (class Memory_region): Remove "NULL" from
	vector initializations.
@
text
@a658 1
    Output_section* dummy;
d660 1
a660 1
					   NULL, &dummy, NULL);
a668 1
    Output_section* dummy;
d670 1
a670 1
					   NULL, &dummy, dot_alignment);
a980 1
  Output_section* dummy;
d983 1
a983 1
					   this->dot_section_, &dummy, NULL);
a2051 1
	  Output_section* dummy;
d2054 1
a2054 1
						  &dummy, NULL);
a2057 1
	  Output_section* dummy;
d2059 2
a2060 3
						       *dot_value,
						       NULL,
						       &dummy, NULL);
a2127 1
          Output_section* dummy;
d2129 1
a2129 1
                                                  *dot_value, NULL, &dummy,
a2173 1
      Output_section* dummy;
d2176 1
a2176 2
					   this->output_section_, &dummy,
					   NULL);
@


1.41
log
@2010-09-08  Rafael Espindola  <espindola@@google.com>

	* script-sections.cc (Script_sections::add_memory_region): Convert
	field precision to int.
	* script.cc (script_set_section_region, script_set_section_region):
	Convert field precision to int.
@
text
@d58 2
a59 2
      vma_sections_(NULL),
      lma_sections_(NULL)
@


1.40
log
@        * README: Remove claim that MEMORY is not supported.
        * expression.cc (script_exp_function_origin)
        (script_exp_function_length): Move from here to ...
        * script.cc: ... here.
        (script_set_section_region, script_add_memory)
        (script_parse_memory_attr, script_include_directive): New
        functions.
        * script-sections.cc
        (class Memory_region): New class.
        (class Output_section_definition): Add set_memory_region,
        set_section_vma, set_section_lma and get_section_name methods.
        (class Script_Sections): Add add_memory_region,
        find_memory_region, find_memory_region_origin,
        find_memory_region_length and set_memory_region methods.
        Have set_section_addresses method walk the list of set memory
        regions.
        Extend the print methos to display memory regions.
        * script-sections.h: Add prototypes for new methods.
        Add enum for MEMORY region attributes.
        * yyscript.y: Add support for parsing MEMORY regions.
        * script-c.h: Add prototypes for new functions.
        * testsuite/Makefile.am: Add test of MEMORY region functionality.
        * testsuite/Makefile.in: Regenerate.
        * testsuite/memory_test.sh: New script.
        * testsuite/memory_test.s: New assembler source file.
        * testsuite/memory_test.t: New linker script.
@
text
@d2791 2
a2792 1
      gold_error (_("region '%.*s' already defined"), namelen, name);
@


1.39
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d46 168
d586 5
d1851 16
d2523 8
d2780 79
d2866 1
d3190 35
d3969 20
a3999 10

  if (this->phdrs_elements_ != NULL)
    {
      fprintf(f, "PHDRS {\n");
      for (Phdrs_elements::const_iterator p = this->phdrs_elements_->begin();
	   p != this->phdrs_elements_->end();
	   ++p)
	(*p)->print(f);
      fprintf(f, "}\n");
    }
@


1.38
log
@2010-08-03  Ian Lance Taylor  <iant@@google.com>

	PR 11805
	* layout.h (enum Output_section_order): Define.
	(class Layout): Update declarations.
	* layout.cc (Layout::get_output_section): Add order parameter.
	Remove is_interp, is_dynamic_linker_section, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.  Set order.
	(Layout::default_section_order): New function.
	(Layout::layout_eh_frame): Call add_output_section_to_nonload.
	* output.cc (Output_section::Output_section): Initialize order_.
	Don't initialize deleted fields.
	(Output_segment::Output_segment): Don't initialize deleted
	fields.
	(Output_segment::add_output_section_to_load): New function
	replacing add_output_section.  Change all callers to call this or
	add_output_section_to_nonload.
	(Output_segment::add_output_section_to_nonload): New function.
	(Output_segment::remove_output_section): Rewrite.
	(Output_segment::add_initial_output_data): Likewise.
	(Output_segment::has_any_data_sections): Likewise.
	(Output_segment::is_first_section_relro): Likewise.
	(Output_segment::maximum_alignment): Likewise.
	(Output_segment::has_dynamic_reloc): New function replacing
	dynamic_reloc_count.  Change all callers.
	(Output_segment::has_dynamic_reloc_list): New function replacing
	dynamic_reloc_count_list.  Change all callers.
	(Output_segment::set_section_addresses): Rewrite.
	(Output_segment::set_offset): Rewrite.
	(Output_segment::find_first_and_last_list): Remove.
	(Output_segment::set_tls_offsets): Rewrite.
	(Output_segment::first_section_load_address): Likewise.
	(Output_segment::output_section_count): Likewise.
	(Output_segment::section_with_lowest_load_address): Likewise.
	(Output_segment::write_section_headers): Likewise.
	(Output_segment::print_sections_to_map): Likewise.
	* output.h (class Output_data): Remove dynamic_reloc_count_
	field.  Add has_dynamic_reloc_ field.  Make bools into bitfields.
	(Output_data::add_dynamic_reloc): Rewrite.
	(Output_data::has_dynamic_reloc): New function.
	(Output_data::dynamic_reloc_count): Remove.
	(class Output_section): Add order_ field.  Remvoe is_relro_local_,
	is_last_relro_, is_first_non_relro_, is_interp_,
	is_dynamic_linker_section_ fields.  Add order and set_order
	functions.  Remove is_relro_local, set_is_relro_local,
	is_last_relro, set_is_last_relro, is_first_non_relro,
	set_is_first_non_relro functions, is_interp, set_is_interp,
	is_dynamic_linker_section, and set_is_dynamic_linker_section
	functions.
	(class Output_segment): Change Output_data_list from std::list to
	std:;vector.  Add output_lists_ field.  Remove output_data_ and
	output_bss_ fields.  Update declarations.
@
text
@d1897 1
a1897 1
    Script_sections::Section_type *psection_type)
d2312 1
a2312 1
Output_section_definition::script_section_type_name (
d2684 1
a2684 1
    const Parser_output_section_header *header)
d2816 1
a2816 1
    Script_sections::Section_type *psection_type)
d2948 1
a2948 1
      Output_section *os = (*p)->get_output_section();
@


1.37
log
@	* gold.h (is_wildcard_string): New function.
	* layout.cc (Layout::layout): Pass this pointer to add_input_section.
	(Layout::layout_eh_frame): Ditto.
	(Layout::find_section_order_index): New method.
	(Layout::read_layout_from_file): New method.
	* layout.h (Layout::find_section_order_index): New method.
	(Layout::read_layout_from_file): New method.
	(Layout::input_section_position_): New private member.
	(Layout::input_section_glob_): New private member.
	* main.cc (main): Call read_layout_from_file here.
	* options.h (--section-ordering-file): New option.
	* output.cc (Output_section::input_section_order_specified_): New
	member.
	(Output_section::Output_section): Initialize new member.
	(Output_section::add_input_section): Add new parameter.
	Keep input sections when --section-ordering-file is used.
	(Output_section::set_final_data_size): Sort input sections when
	section ordering file is specified.
	(Output_section::Input_section_sort_entry): Add new parameter.
	Check sorting type.
	(Output_section::Input_section_sort_entry::compare_section_ordering):
	New method.
	(Output_section::Input_section_sort_compare::operator()): Change to
	consider section_order_index.
	(Output_section::Input_section_sort_init_fini_compare::operator()):
	Change to consider section_order_index.
	(Output_section::Input_section_sort_section_order_index_compare
	::operator()): New method.
	(Output_section::sort_attached_input_sections): Change to sort
	according to section order when specified.
	(Output_section::add_input_section<32, true>): Add new parameter.
	(Output_section::add_input_section<64, true>): Add new parameter.
	(Output_section::add_input_section<32, false>): Add new parameter.
	(Output_section::add_input_section<64, false>): Add new parameter.
	* output.h (Output_section::add_input_section): Add new parameter.
	(Output_section::input_section_order_specified): New
	method.
	(Output_section::set_input_section_order_specified): New method.
	(Input_section::Input_section): Initialize section_order_index_.
	(Input_section::section_order_index): New method.
	(Input_section::set_section_order_index): New method.
	(Input_section::section_order_index_): New member.
	(Input_section::Input_section_sort_section_order_index_compare): New
	struct.
	(Output_section::input_section_order_specified_): New member.
	* script-sections.cc (is_wildcard_string): Delete and move modified
	method to gold.h.
	(Output_section_element_input::Output_section_element_input): Modify
	call to is_wildcard_string.
	(Output_section_element_input::Input_section_pattern
	::Input_section_pattern): Ditto.
	(Output_section_element_input::Output_section_element_input): Ditto.
	* testsuite/Makefile.am (final_layout): New test case.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/final_layout.cc: New file.
	* testsuite/final_layout.sh: New file.
@
text
@d3215 1
a3215 1
      current_seg->add_output_section(*p, seg_flags, false);
d3294 1
a3294 1
	  oseg->add_output_section(*p, seg_flags, false);
d3303 1
a3303 1
	      oseg->add_output_section(*pnext, seg_flags, false);
d3318 1
a3318 1
	  oseg->add_output_section(*p, seg_flags, false);
d3325 1
a3325 1
	      oseg->add_output_section(*pnext, seg_flags, false);
a3479 1
	      r->second->add_output_section(os, seg_flags, false);
d3481 3
a3483 1
	      if (r->second->type() == elfcpp::PT_LOAD)
d3485 1
@


1.36
log
@2010-05-26  Rafael Espindola  <espindola@@google.com>

	* script-sections.cc (Output_section_definition::set_section_addresses):
	Check for --section-start.
@
text
@a985 9
// Return whether STRING contains a wildcard character.  This is used
// to speed up matching.

static inline bool
is_wildcard_string(const std::string& s)
{
  return strpbrk(s.c_str(), "?*[") != NULL;
}

d1029 1
a1029 1
	pattern_is_wildcard(is_wildcard_string(this->pattern)),
d1096 1
a1096 1
  this->filename_is_wildcard_ = is_wildcard_string(this->filename_pattern_);
d1105 1
a1105 1
	  bool is_wildcard = is_wildcard_string(*p);
@


1.35
log
@2010-05-19  Rafael Espindola  <espindola@@google.com>

	* script-sections.cc (Output_section_definition::allocate_to_segment):
	Update the phdrs_list even when the output section is NULL.
	* testsuite/Makefile.am: Add test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/script_test_9.cc: New.
	* testsuite/script_test_9.sh: New.
	* testsuite/script_test_9.t: New.
@
text
@d1942 7
a1948 3
  if (this->address_ == NULL)
    address = *dot_value;
  else
d1950 9
a1958 4
      Output_section* dummy;
      address = this->address_->eval_with_dot(symtab, layout, true,
					      *dot_value, NULL, &dummy,
					      dot_alignment);
@


1.34
log
@2010-05-14  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section::original_size): New method.
	(Arm_input_section::do_addralign): Add a cast.
	(Arm_input_section::do_output_offset): Remove static cast.
	(Arm_input_section::original_addralign,
	 Arm_input_section::original_size_): Change type to uint32_t.
	(Arm_input_section::init): Add safe casts for section alignment
	and size.
	(Arm_input_section::set_final_data_size): Do not set address and
	offset of stub table.
	(Arm_output_section::fix_exidx_coverage): Change use of of
	Output_section::Simple_input_section to that of
	Output_section::Input_section.
	(Target_arm::do_relax): Set addresses and file offsets of Stub_tables
	except for the first pass.
	* output.cc (Output_section::get_input_sections): Change type of
	input_sections to std::list<Input_section>.
	(Output_section::add_script_input_section): Rename from
	Output_section::add_simple_input_section.  Change type of SIS
	parameter from Simple_input_section to Input_section.
	* output.h (Output_section::Simple_input_section): Remove class.
	(Output_section::Input_section): Change class visibility to public.
	(Output_section::Input_section::addralign): Use stored alignments
	for special input sections if set.
	(Output_section::Input_section::set_addralign): New method.
	(Output_section::get_input_sections): Change parameter type from
	list of Simple_input_section to list of Input_section.
	(Output_section::add_script_input_section): Rename from
	Output_section::add_simple_input_section. Change first parameter's
	type from Simple_input_section to Input_section and remove the
	second and third parameters.
	* script-sections.cc (Input_section::Input_section_list): Change
	type to list of Output_section::Input_section/
	(Input_section_info::Input_section_info): Change parameter type of
	INPUT_SECTION to Output_section::Input_section.
	(Input_section_info::input_section): Change return type.
	(Input_section_info::input_section_): Change type to
	Output_section::Input_section.
	(Output_section_element_input::set_section_addresses): Adjust code
	to use Output_section::Input_section instead of
	Output_section::Simple_input_section.  Adjust code for renaming
	of Output_section::add_simple_input_section.
	(Orphan_output_section::set_section_addresses): Ditto.
@
text
@d2172 5
a2181 2
  if (this->phdrs_ != NULL)
    *phdrs_list = this->phdrs_;
@


1.33
log
@	* expression.cc (Expression::Expression_eval_info): Add
	result_alignment_pointer field.
	(Expression::eval_with_dot): Add result_alignment_pointer
	parameter.  Change all callers.
	(Expression::eval_maybe_dot): Likewise.
	(class Binary_expression): Add alignment_pointer parameter to
	left_value and right_value.  Change all callers.
	(BINARY_EXPRESSION): Set result alignment.
	(class Trinary_expression): Add alignment_pointer parameter to
	arg2_value and arg3_value.  Change all callers.
	(Trinary_cond::value): Set result alignment.
	(Max_expression::value, Min_expression::value): Likewise.
	(Align_expression::value): Likewise.
	* script-sections.cc (class Sections_element): Add dot_alignment
	parameter to set_section_addresses virtual function.  Update
	instantiations.
	(class Output_section_element): Likewise.
	(Script_sections::create_segments): Add dot_alignment parameter.
	Change all callers.
	(Script_sections::create_segments_from_phdrs_clause): Likewise.
	(Script_sections::set_phdrs_clause_addresses): Likewise.
	* script-sections.h: Update declarations.
	* script.h: Update declarations.
	* output.h (Output_segment::set_minimum_p_align): Don't decrease
	min_p_align.
	* testsuite/script_test_3.t: Set large alignment.
	* testsuite/script_test_3.sh: Make sure that at least one LOAD
	segment has expected alignment.
@
text
@d549 1
a549 1
  typedef std::list<Output_section::Simple_input_section> Input_section_list;
d1198 1
a1198 1
  Input_section_info(const Output_section::Simple_input_section& input_section)
d1204 1
a1204 1
  const Output_section::Simple_input_section&
d1250 1
a1250 1
  Output_section::Simple_input_section input_section_;
d1421 9
a1429 1
	  uint64_t this_subalign = p->addralign();
d1431 4
a1434 1
	    this_subalign = subalign;
d1448 2
a1449 5
	  output_section->add_simple_input_section(p->input_section(),
						   p->size(),
						   this_subalign);

	  dot = address + p->size();
d2392 1
a2392 1
  typedef std::list<Output_section::Simple_input_section> Input_section_list;
d2414 4
a2417 17
      uint64_t addralign;
      uint64_t size;

      // We know we are single-threaded, so it is OK to lock the
      // object.
      {
	const Task* task = reinterpret_cast<const Task*>(-1);
	Task_lock_obj<Object> tl(task, p->relobj());
	addralign = p->relobj()->section_addralign(p->shndx());
	if (p->is_relaxed_input_section())
	  // We use current data size because relxed section sizes may not
	  // have finalized yet.
	  size = p->relaxed_input_section()->current_data_size();
	else
	  size = p->relobj()->section_size(p->shndx());
      }

d2419 1
a2419 1
      this->os_->add_simple_input_section(*p, size, addralign);
@


1.32
log
@2010-04-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::choose_output_section): Handle script section
	types.
	(Layout::make_output_section_for_script): Add section type parameter.
	Handle script section types.
	* layout.h (Layout::make_output_section_for_script): Add section
	type parameter.
	* output.cc (Output_section::Output_section): Initialize data member
	is_noload_.
	(Output_section::do_reset_address_and_file_offset): Do not set address
	to 0 if section is a NOLOAD section.
	* output.h (Output_section::is_noload): New method.
	(Output_section::set_is_noload): Ditto.
	(Output_section::is_noload_): New data member.
	* script-c.h (Script_section_type): New enum type.
	(struct Parser_output_section_header): Add new file section_type.
	* script-sections.cc (Sections_element::output_section_name): Add
	parameter for returning script section type.
	(Output_section_definition::output_section_name): Ditto.
	(Output_section_definition::section_type)P; New method.
	(Output_section_definiton::script_section_type_name): Ditto.
	(Output_section_definition::script_section_type_): New data member.
	(Output_section_definition::Output_section_definition): Initialize
	data member Output_section_definition::script_section_type_.
	(Output_section_definition::create_sections): Pass script section type
	to Layout::make_output_section_for_script.
	(Output_section_definition::output_section_name): Return script
	section type to caller.
	(Output_section_definition::set_section_address): Do not advance
	dot value and load address if section type is NOLOAD.  Set address
	of NOLOAD sections regardless of section flags.
	(Output_section_definition::print): Print section type if it is
	not SCRIPT_SECTION_TYPE_NONE.
	(Output_section_definition::section_type): New method.
	(Output_section_definition::script_section_type_name): Ditto.
	(Script_sections::output_section_name): Add new parameter
	PSECTION_TYPE for returning script section type.  Pass it to
	section elements.  Handle discard sections.
	(Sort_output_sections::operator()): Handle NOLOAD sections.
	* script-sections.h (Script_sections::Section_type): New enum type.
   	(Script_sections::output_section_name): Add a new parameter for
	returning script section type.
	* script.cc (script_keyword_parsecodes): Add keywords COPY, DSECT,
	INFO and NOLOAD.
	* yyscript.y (union): Add new field SECTION_TYPE.
	(COPY, DSECT, INFO, NOLOAD): New tokens.
	(opt_address_and_section_type): Change type to output_section_header.
	(section_type): New non-terminal
	(section_header): Handle section type.
 	(opt_address_and_section_type): Return section type value.
@
text
@d372 2
a373 1
  set_section_addresses(Symbol_table*, Layout*, uint64_t*, uint64_t*)
d451 1
a451 1
			uint64_t* dot_value, uint64_t*)
d488 1
a488 1
					   NULL, &dummy);
d494 2
a495 1
			uint64_t* dot_value, uint64_t* load_address)
d499 1
a499 1
					   NULL, &dummy);
d582 1
a582 1
			uint64_t*, Output_section**, std::string*,
d640 2
a641 2
			uint64_t, uint64_t* dot_value, Output_section**,
			std::string*, Input_section_list*)
d673 1
a673 1
					   *dot_section, dot_section);
d679 2
a680 2
			uint64_t, uint64_t* dot_value, Output_section**,
			std::string*, Input_section_list*);
d704 1
d711 1
a711 1
						dot_section);
d813 1
a813 1
					   this->dot_section_, &dummy);
d874 2
a875 2
			uint64_t* dot_value, Output_section**, std::string*,
			Input_section_list*);
d899 1
d956 1
a956 1
			uint64_t, uint64_t* dot_value,
d963 1
a963 1
						  &fill_section);
d1019 1
a1019 1
			uint64_t subalign, uint64_t* dot_value,
d1316 1
d1637 2
a1638 1
			uint64_t* dot_value, uint64_t* load_address);
d1870 1
a1870 1
						  &dummy);
d1878 1
a1878 1
						       &dummy);
d1927 1
d1940 2
a1941 1
					      *dot_value, NULL, &dummy);
d1956 1
a1956 1
					  NULL, &align_section);
d1987 2
a1988 1
					   this->output_section_, &dummy);
d2002 1
a2002 1
						&subalign_section);
d2016 2
a2017 2
						     NULL,
						     &fill_section);
d2043 2
a2044 2
				subalign, dot_value, &dot_section, &fill,
				&input_sections);
d2351 2
a2352 1
  set_section_addresses(Symbol_table*, Layout*, uint64_t*, uint64_t*);
d2381 1
d2964 1
d3010 2
a3011 1
      (*p)->set_section_addresses(symtab, layout, &dot_value, &load_address);
d3022 1
a3022 1
  return this->create_segments(layout);
d3130 1
a3130 1
Script_sections::create_segments(Layout* layout)
d3138 1
a3138 1
    return create_segments_from_phdrs_clause(layout);
d3211 1
d3405 2
a3406 1
Script_sections::create_segments_from_phdrs_clause(Layout* layout)
d3409 1
a3409 1
  return this->set_phdrs_clause_addresses(layout);
d3503 2
a3504 1
Script_sections::set_phdrs_clause_addresses(Layout* layout)
d3527 2
@


1.31
log
@	* script-sections.cc (class Orphan_section_placement): Define
	PLACE_TLS and PLACE_TLS_BSS.
	(Orphan_section_placement::Orphan_section_placement): Initialize
	new places.
	(Orphan_section_placement::find_place): Handle SHF_TLS sections.
	* testsuite/Makefile.am (check_PROGRAMS): Add tls_script_test.
	(tls_script_test_SOURCES): Define.
	(tls_script_test_DEPENDENCIES): Define.
	(tls_script_test_LDFLAGS): Define.
	(tls_script_test_LDADD): Define.
	* testsuite/Makefile.in: Rebuild.
@
text
@d359 2
a360 1
  output_section_name(const char*, const char*, Output_section***)
d1621 1
a1621 1
		      Output_section***);
d1669 4
d1674 3
d1709 2
d1732 2
a1733 1
    is_relro_(false)
d1829 2
a1830 1
	  this->output_section_ = layout->make_output_section_for_script(name);
d1888 5
a1892 3
Output_section_definition::output_section_name(const char* file_name,
					       const char* section_name,
					       Output_section*** slot)
d1904 1
d1924 3
d1962 2
a1963 2
  // The address of non-SHF_ALLOC sections is forced to zero,
  // regardless of what the linker script wants.
d1965 2
a1966 1
      && (this->output_section_->flags() & elfcpp::SHF_ALLOC) != 0)
d2051 7
d2215 4
d2268 46
d2803 5
a2807 3
Script_sections::output_section_name(const char* file_name,
				     const char* section_name,
				     Output_section*** output_section_slot)
d2814 2
a2815 1
						  output_section_slot);
d2824 1
d2835 1
d3051 6
@


1.30
log
@2010-01-22  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_relax): Record an output section for section
	offset adjustment it contains any stub table that has changed.
	* layout.cc (Layout::clean_up_after_relaxation): Adjust section
	offsets in an output section if necessary.
	* output.cc (Output_section::Output_section): Initialize
	section_offsets_need_adjustments_.
	(Output_section::add_input_section_for_script): Renamed to
	Output_section::add_simple_input_section.
	(Output_section::save_states): Add a comment.
	(Output_section::discard_states): New method defintion.
	(Output_section::adjust_section_offsets): Same.
	* output.h (Output_section::add_input_section_for_script): Renamed to
	Output_section::add_simple_input_section.
	(Output_section::discard_states): New method declaration.
	(Output_section::adjust_section_offsets): Same.
	(Output_section::section_offsets_need_adjustment,
	Output_section::set_section_offsets_need_adjustment): New method
	definitions.
	(Output_section::section_offsets_need_adjustment_): New data member.
	* script-sections.cc
	(Output_section_element_input::set_section_address): Adjust code for
	renaming of Output_section::add_input_section_for_script.
	(Orphan_output_section::set_section_address): Same.
@
text
@d88 2
d127 2
d239 7
d279 8
d2322 1
a2322 1
      // We know what are single-threaded, so it is OK to lock the
@


1.29
log
@	* symtab.h (class Symbol_table): Add enum Defined.
	* resolve.cc (Symbol_table::should_override): Add defined
	parameter.  Change all callers.  Test whether object is NULL
	before calling a method on it.
	(Symbol_table::report_resolve_problem): Add defined parameter.
	Change all callers.
	(Symbol_table::should_override_with_special): Likewise.
	* symtab.cc (Symbol_table::define_in_output_data): Add defined
	parameter.  Change all callers.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::define_in_output_segment): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::define_as_constant): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* script.h (class Symbol_assignment): Add is_defsym parameter to
	constructor; change all callers.
	* script.cc (Script_options::add_symbol_assignment): Add is_defsym
	parameter.  Change all callers.  Add is_defsym_ field.
	(class Parser_closure): Add parsing_defsym parameter to
	constructor; change all callers.  Add parsing_defsym accessor
	function.  Add parsing_defsym_ field.
@
text
@d1412 3
a1414 3
	  output_section->add_input_section_for_script(p->input_section(),
						       p->size(),
						       this_subalign);
d2318 1
a2318 1
      this->os_->add_input_section_for_script(*p, size, addralign);
@


1.28
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d409 1
a409 1
    : assignment_(name, namelen, val, provide, hidden)
d596 1
a596 1
    : assignment_(name, namelen, val, provide, hidden)
@


1.27
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d1174 2
a1175 2
  Input_section_info(const Output_section::Simple_input_section& inputsection)
    : input_section_(inputsection), section_name_(),
d1201 2
a1202 2
  set_section_name(const std::string aname)
  { this->section_name_ = aname; }
d1211 2
a1212 2
  set_size(uint64_t sec_size)
  { this->size_ = sec_size; }
d1221 2
a1222 2
  set_addralign(uint64_t addr_align)
  { this->addralign_ = addr_align; }
d1391 1
a1391 1
      for (std::vector<Input_section_info>::const_iterator q =
d1393 2
a1394 2
	   q != matching_sections[i].end();
	   ++q)
d1396 1
a1396 1
	  uint64_t this_subalign = q->addralign();
d1412 2
a1413 2
	  output_section->add_input_section_for_script(q->input_section(),
						       q->size(),
d1416 1
a1416 1
	  dot = address + q->size();
d2130 1
a2130 1
                                                   uint64_t* addr_align,
d2143 1
a2143 1
      *addr_align = this->output_section_->addralign();
d2150 1
a2150 1
      *addr_align = this->evaluated_addralign_;
d2300 1
a2300 1
      uint64_t addr_align;
d2308 1
a2308 1
	addr_align = p->relobj()->section_addralign(p->shndx());
d2317 2
a2318 2
      address = align_address(address, addr_align);
      this->os_->add_input_section_for_script(*p, size, addr_align);
d2354 2
a2355 2
  Phdrs_element(const char* aname, size_t namelen, unsigned int atype,
		bool include_filehdr, bool include_phdrs,
d2357 4
a2360 4
		Expression* aload_address)
    : name_(aname, namelen), type_(atype), includes_filehdr_(include_filehdr),
      includes_phdrs_(include_phdrs), is_flags_valid_(is_flags_valid),
      flags_(flags), load_address_(aload_address), load_address_value_(0),
d2391 1
a2391 1
  eval_load_address(Symbol_table* symtab, Layout* alayout)
d2394 1
a2394 1
      this->load_address_value_ = this->load_address_->eval(symtab, alayout,
d3499 1
a3499 1
                                         uint64_t* addr_align,
d3507 1
a3507 1
    if ((*p)->get_output_section_info(name, address, load_address, addr_align,
@


1.26
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d1174 2
a1175 2
  Input_section_info(const Output_section::Simple_input_section& input_section)
    : input_section_(input_section), section_name_(),
d1201 2
a1202 2
  set_section_name(const std::string name)
  { this->section_name_ = name; }
d1211 2
a1212 2
  set_size(uint64_t size)
  { this->size_ = size; }
d1221 2
a1222 2
  set_addralign(uint64_t addralign)
  { this->addralign_ = addralign; }
d1391 1
a1391 1
      for (std::vector<Input_section_info>::const_iterator p =
d1393 2
a1394 2
	   p != matching_sections[i].end();
	   ++p)
d1396 1
a1396 1
	  uint64_t this_subalign = p->addralign();
d1412 2
a1413 2
	  output_section->add_input_section_for_script(p->input_section(),
						       p->size(),
d1416 1
a1416 1
	  dot = address + p->size();
d2130 1
a2130 1
                                                   uint64_t* addralign,
d2143 1
a2143 1
      *addralign = this->output_section_->addralign();
d2150 1
a2150 1
      *addralign = this->evaluated_addralign_;
d2300 1
a2300 1
      uint64_t addralign;
d2308 1
a2308 1
	addralign = p->relobj()->section_addralign(p->shndx());
d2317 2
a2318 2
      address = align_address(address, addralign);
      this->os_->add_input_section_for_script(*p, size, addralign);
d2354 2
a2355 2
  Phdrs_element(const char* name, size_t namelen, unsigned int type,
		bool includes_filehdr, bool includes_phdrs,
d2357 4
a2360 4
		Expression* load_address)
    : name_(name, namelen), type_(type), includes_filehdr_(includes_filehdr),
      includes_phdrs_(includes_phdrs), is_flags_valid_(is_flags_valid),
      flags_(flags), load_address_(load_address), load_address_value_(0),
d2391 1
a2391 1
  eval_load_address(Symbol_table* symtab, Layout* layout)
d2394 1
a2394 1
      this->load_address_value_ = this->load_address_->eval(symtab, layout,
d3499 1
a3499 1
                                         uint64_t* addralign,
d3507 1
a3507 1
    if ((*p)->get_output_section_info(name, address, load_address, addralign,
@


1.25
log
@2009-10-16  Doug Kwan  <dougkwan@@google.com>

	* expression.cc (class Segment_start_expression): New class definition.
	(Segment_start_expression::value): New method definition.
	(script_exp_function_segment_start): Return a new
	Segment_start_expression.
	* gold/script-c.h (script_saw_segment_start_expression): New function
	prototype.
	* script-sections.cc (Script_sections::Script_sections): Initialize
	SAW_SEGMENT_START_EXPRESSION_ to false.
	(Script_sections::set_section_addresses): Use -Ttext, -Tdata
	and -Tbbs options to specify section addresses if given in
	command line and no SEGMENT_START expression is seen in a script.
	* script-sections.h (Script_sections::saw_segment_start_expression,
	Script_sections::set_saw_segment_start_expression): New method
	definition.
	(Script_sections::saw_segment_start_expression_): New data member
	declaration.
	* script.cc (script_saw_segment_start_expression): New function.
	* yyscript.y (SEGMENT_START): Call script_saw_segment_start_expression.
	* testsuite/Makefile.am (check_SCRIPTS): Add script_test_6.sh,
	script_test_7.sh and script_test_8.sh.
	(check_DATA): Add script_test_6.stdout, script_test_7.stdout and
	script_test_8.stdout.
	(MOSTLYCLEANFILES): Add script_test_6, script_test_7 and script_test_8.
	(script_test_6, script_test_6.stdout, script_test_7,
	script_test_7.stdout, script_test_8, script_test_8.stdout): New rules.
	* Makefile.in: Regenerate.
	* testsuite/script_test_6.sh: New file.
	* testsuite/script_test_6.t: Same.
	* testsuite/script_test_7.sh: Same.
	* testsuite/script_test_7.t: Same.
	* testsuite/script_test_8.sh: Same.
@
text
@d3097 1
a3097 1
      current_seg->add_output_section(*p, seg_flags);
d3176 1
a3176 1
	  oseg->add_output_section(*p, seg_flags);
d3185 1
a3185 1
	      oseg->add_output_section(*pnext, seg_flags);
d3200 1
a3200 1
	  oseg->add_output_section(*p, seg_flags);
d3207 1
a3207 1
	      oseg->add_output_section(*pnext, seg_flags);
d3361 1
a3361 1
	      r->second->add_output_section(os, seg_flags);
@


1.24
log
@	* script.cc (Script_options::add_symbol_assignment): Always add a
	dot assginment to script_sections_.
	* script-sections.cc (Script_sections::add_dot_assignment):
	Initialize if necessary.
@
text
@d2490 2
a2491 1
    saw_relro_end_(false)
d2854 10
d2867 33
a2899 1
    (*p)->set_section_addresses(symtab, layout, &dot_value, &load_address);
@


1.23
log
@	* layout.cc (Layout::set_segment_offsets): Align the file offset
	to the segment aligment for -N or -n with no load segment.
	* output.cc (Output_segment::add_output_section): Don't crash if
	the first section is a TLS section.
	(Output_segment::set_section_list_addresses): Print an error
	message if the address moves backward in a linker script.
	* script-sections.cc
	(Output_section_element_input::set_section_addresses): Don't
	increase *dot_value for a SHF_TLS/SHT_NOBITS section.
	(Orphan_output_section::set_section_addresses): Likewise.
@
text
@d2543 9
@


1.22
log
@2009-10-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::make_output_section): Call target hook to make
	ordinary output section.
	(Layout::finalize): Adjust parameter list of call the
	Target::may_relax().
	* layout.h (class Layout::section_list): New method.
	* merge.h (Output_merge_base::entsize): Change visibility to public.
	(Output_merge_base::is_string, Output_merge_base::do_is_string):
	New methods.
	(Output_merge_string::do_is_string): New method.
	* object.cc (Sized_relobj::do_setup): renamed from
	Sized_relobj::set_up.
	* object.h (Sized_relobj::adjust_shndx,
	Sized_relobj::initializ_input_to_output_maps,
	Sized_relobj::free_input_to_output_maps): Change visibilities to
	protected.
	(Sized_relobj::setup): Virtualize.
	(Sized_relobj::do_setup): New method declaration.
	(Sized_relobj::invalidate_section_offset,
	Sized_relobj::do_invalidate_section_offset): New method decfinitions.
	(Sized_relobj::elf_file, Sized_relobj::local_values): New methods.
	* options.cc (parse_int): New function.
	* options.h (parse_int): New declaration.
	(DEFINE_int): New macro.
	(stub_group_size): New option.
	* output.cc (Output_section::Output_section): Initialize memebers
	merge_section_map_, merge_section_by_properties_map_,
	relaxed_input_section_map_, is_relaxed_input_section_map_valid_.
	(Output_section::add_input_section): Handled deferred code-fill
	generation and remove an old comment.
	(Output_section::add_relaxed_input_section): New method definition.
	(Output_section::add_merge_input_section): Use merge section by
	properties map to speed to search.  Update merge section maps
	as appropriate.
	(Output_section::build_relaxation_map): New method definition.
	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Same.
	(Output_section::relax_input_section): Renamed to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of pointers to relaxed sections.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section): New method definitions.
	(Output_section::is_input_address_mapped,
	Output_section::output_offset, Output_section::output_address):
	Use output section data maps to speed up searching.
	(Output_section::find_starting_output_address): Add comments.
	(Output_section::do_write,
	Output_section::write_to_postprocessing_buffer): Do code-fill
	generation as appropriate.
	(Output_section::get_input_sections): Invalidate relaxed input section
	map.
	(Output_section::restore_states): Adjust type of checkpoint .
	Invalidate relaxed input section map.
	* output.h (Output_merge_base): New class declaration.
	(Input_section_specifier): New class defintion.
	(class Output_relaxed_input_section) Change base class to
	Output_section_data_build.
	(Output_relaxed_input_section::Output_relaxed_input_section): Adjust
	base class initializer.
	(Output_section::add_relaxed_input_section): New method declaration.
	(Output_section::Input_section): Change visibility to protected.
     	(Output_section::Input_section::relobj,
	Output_section::Input_section::shndx): Handle relaxed input sections.
	Output_section::input_sections) Change visibility to protected.  Also
	define overload to return a non-const pointer.
	(Output_section::Merge_section_properties): New class defintion.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Relaxation_map): New types.
	(Output_section::relax_input_section): Rename method to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of relaxed section pointers.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section,
	Output_section::build_relaxation_map,
	Output_section::convert_input_sections_in_list_to_relaxed_sections):
	New method declarations.
	(Output_section::merge_section_map_
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_,
	Output_section::generate_code_fills_at_write_): New data members.
	* script-sections.cc
	(Output_section_element_input::set_section_addresses): Call
	current_data_size and addralign methods of relaxed input sections.
	(Orphan_output_section::set_section_addresses): Call current_data_size
	and addralign methods of relaxed input sections.
	* symtab.cc (Symbol_table::compute_final_value): Extract template
	from the body of Symbol_table::sized_finalize_symbol.
	(Symbol_table::sized_finalized_symbol): Call
	Symbol_table::compute_final_value.
	* symtab.h (Symbol_table::Compute_final_value_status): New enum type.
	(Symbol_table::compute_final_value): New templated method declaration.
	* target.cc (Target::do_make_output_section): New method defintion.
	* target.h (Target::make_output_section): New method declaration.
	(Target::relax): Add more parameters for input objects, symbol table
	and layout.  Adjust call to do_relax.
	(Target::do_make_output_section): New method declaration.
	(Target::do_relax): Add parameters for input objects, symbol table
	and layout.
@
text
@d1375 1
d1400 1
a1400 1
	  uint64_t address = align_address(*dot_value, this_subalign);
d1402 1
a1402 1
	  if (address > *dot_value && !fill->empty())
d1405 1
a1405 1
		convert_to_section_size_type(address - *dot_value);
d1416 1
a1416 1
	  *dot_value = address + p->size();
d1420 7
d2322 9
a2330 4
  if (!have_load_address)
    *load_address = address;
  else
    *load_address += address - *dot_value;
d2332 2
a2333 1
  *dot_value = address;
@


1.21
log
@2009-09-17  Doug Kwan  <dougkwan@@google.com>

	* debug.h (DEBUG_RELAXATION): New constant.
	(DEBUG_ALL): Add DEBUG_RELAXATION.
	(debug_string_to_enum): Add relaxation debug option.
	* layout.cc
	(Layout::Relaxation_debug_check::check_output_data_for_reset_values,
	Layout::Relaxation_debug_check::read_sections,
	Layout::Relaxation_debug_check::read_sections): New method definitions.
	(Layout::Layout): Initialize data members
	record_output_section_data_from_scrips_,
	script_output_section_data_list_ and relaxation_debug_check_.
	(Layout::save_segments, Layout::restore_segments,
	Layout::clean_up_after_relaxation, Layout::prepare_for_relaxation,
	Layout::relaxation_loop_body): New method definitions.
	(Layout::finalize): Support relaxation.  Move section layout code to
	Layout::relaxation_loop_body.
	(Layout::set_asection_address_from_script): Move code for orphan
	section placement out.
	(Layout::place_orphan_sections_in_script): New method definition.
	* layout.h (Output_segment_headers, Output_file_header):
	New forward class declarations.
	(Layout::~Layout): Define.
	(Layout::new_output_section_data_from_script): New method definition.
	(Layout::place_orphan_sections_in_script): New method declaration.
	(Layout::Segment_states): New type declaration.
	(Layout::save_segments, Layout::restore_segments,
	Layout::clean_up_after_relaxation, Layout::prepare_for_relaxation,
	Layout::relaxation_loop_body): New method declarations.
	(Layout::Output_section_data_list): New type declaration.
	(Layout::Relaxation_debug_check): New class definition.
	(Layout::record_output_section_data_from_script_,
	Layout::script_output_section_data_list_, Layout::segment_states_,
	Layout::relaxation_debug_check_): New data members.
	* output.cc: (Output_section_headers::do_size): New method definition.
	(Output_section_headers::Output_section_headers): Move size
	computation to Output_section_headers::do_size.
	(Output_segment_headers::do_size): New method definition.
	(Output_file_header::Output_file_header): Move size computation to
	Output_file_header::do_size and call it.
	(Output_file_header::do_size): New method definition.
	(Output_data_group::Output_data_group): Adjust call to
	Output_section_data.
	(Output_data_dynamic::set_final_data_size): Add DT_NULL tag only once.
	(Output_symtab_xindex::do_write): Add array bound check.
 	(Output_section::Input_section::print_to_mapfile): Handle
	RELAXED_INPUT_SECTION_CODE.
	(Output_section::Output_section): Initialize data member checkpoint_.
	(Output_section::~Output_section): Delete checkpoint object pointed
	by checkpoint_.
	(Output_section::add_input_section): Always add an Input_section if
	relaxing.
	(Output_section::add_merge_input_section): Add assert.
	(Output_section::relax_input_section): New method definition.
	(Output_section::set_final_data_size): Set load address to zero for
	an unallocated section.
	(Output_section::do_address_and_file_offset_have_reset_values):
	New method definition.
	(Output_section::Input_section_sort_enty::Input_section_sort_enty):
	Handle relaxed input section.
	(Output_section::sort_attached_input_sections): Checkpoint input
	section list lazily.
	(Output_section::get_input_sections): Change type of input_sections to
	list of Simple_input_section pointers.  Checkpoint input section list
	lazily.  Also handle relaxed input sections.
	(Output_section::add_input_section_for_script): Take a reference to
	a Simple_input_section object instead of Relobj pointer and section
	index as parameter.  Handle relaxed input sections.
	(Output_section::save_states, Output_section::restore_states): New
	method definitions.
	* output.h (Output_data::Output_data): Initialize is_data_size_fixed_.
	(Output_data::is_data_size_fixed): New method definition.
	(Output_data::reset_addresss_and_file_offset): Do not reset data size
	if it is fixed.
	(Output_data::address_and_file_offset_have_reset_values): New method
	definition.
	(Output_data::do_address_and_file_offset_have_reset_values): New method
	definition.
	(Output_data::set_data_size): Check that data size is not fixed.
	(Output_data::fix_data_size): New method definition.
	(Output_data::is_data_size_fixed_): New data member.
	(Output_section_headers::set_final_data_size): New method definition.
	(Output_section_headers::do_size): New method declaration.
	(Output_segment_headers::set_final_data_size): New method definition.
	(Output_segment_headers::do_size): New method declaration.
	(Output_file_header::set_final_data_size)::New method definition.
	(Output_file_header::do_size)::New method declaration.
	(Output_section_data::Output_section_data): Add new parameter
	is_data_size_fixed and use it to fix data size.
	(Output_data_const::Output_data_const): Adjust call to base class
	constructor and fix data size.
	(Output_data_const_buffer::Output_data_const_buffer): Adjust call to
	base class constructor and fix data size.
	(Output_data_fixed_space::Output_data_fixed_space): Adjust call to
	base class constructor and fix data size.
	(Output_data_zero_fill::Output_data_zero_fill): Adjust call to base
	class constructor and fix data size.
	(Output_data_group::set_final_data_size): New method definition.
	(Output_data_dynamic::Dynamic_entry::tag): New method definition.
	(Output_symtab_xindex::Output_symtab_xindex): Adjust call to base
	class constructor and fix data size.
	(Output_relaxed_input_section): New class definition.
	(Output_section::Simple_input_section): New class definition.
	(Output_section::get_input_sections): Adjust parameter list.
	(Output_section::add_input_section_for_script): Same.
	(Output_section::save_states, Output_section::restore_states,
	Output_section::do_address_and_file_offset_have_reset_values,
	(Output_section::Input_section::Input_section): Handle
	RELAXED_INPUT_SECTION_CODE.  Add new overload for
	Output_relaxed_input_section.
	(Output_section::Input_section::is_input_section,
	Output_section::Input_section::set_output_section): Handle relaxed
	input section.
	(Output_section::Input_section::is_relaxed_input_section,
	Output_section::Input_section::output_section_data,
	Output_section::Input_section::relaxed_input_section): New method
	definitions.
	(Output_section::Input_section::RELAXED_INPUT_SECTION_CODE): New enum
	value.
	(Output_section::Input_section::u1_): Update comments.
	(Output_section::Input_section::u2_): Add new union member poris.
	(Output_section::Checkpoint_output_section): New classs definition.
	(Output_section::relax_input_section): New method declaration.
	(Output_section::checkpoint_): New data member.
	(Output_segment): Update comments.
	(Output_segment::Output_segment): Un-privatize copy constructor.
	(Output_segment::operator=): Un-privatize.
	* script-sections.cc (Output_section_element::Input_section_list):
	Change element type to Output_section::Simple_input_section.
	(Output_section_element_dot_assignment::set_section_addresses):
	Register output section data for relaxation clean up.
	(Output_data_exression::Output_data_expression): Adjust call to base
	constructor to fix data size.
	(Output_section_element_data::set_section_addresses): Register
	Output_data_expression object for relaxation clean up.
	(struct Input_section_info): Replace Relobj pointer and section index
	pair with Output_section::Simple_input_section and Convert struct to a
	class.
	(Input_section_sorter::operator()): Adjust access to
	Input_section_info data member to use accessors.
	(Output_section_element_input::set_section_addresses): Use layout
	parameter.  Adjust code to use Output_section::Simple_input_section
	and Input_secction_info classes.  Register filler for relaxation
	clean up.
	(Orphan_output_section::set_section_addresses): Replace Relobj pointer
	and section index pair with Output_section::Simple_input_section
	class.  Adjust code accordingly.
	(Phdrs_element::release_segment): New method definition.
	(Script_sections::attach_sections_using_phdrs_clause): Do not modify
	segment list.
	(Script_sections::release_segments): New method definition.
	* gold/script-sections.h (Script_sections::release_segments): New
	method declaration.
	* gold/target.h (Target::may_relax, Target::relax,
	Target::do_may_relax, Target::do_relax): New method definitions.
@
text
@d1328 6
a1333 1
	  isi.set_size(p->relaxed_input_section()->data_size());
d1335 4
a1338 2
	  isi.set_size(relobj->section_size(shndx));
	isi.set_addralign(relobj->section_addralign(shndx));
d2302 3
a2304 1
	  size = p->relaxed_input_section()->data_size();
@


1.20
log
@	* script-sections.cc (Output_section_definition::
	set_section_addresses): Rename shadowing local load_address to
	laddr.
@
text
@d527 1
a527 1
  typedef std::list<std::pair<Relobj*, unsigned int> > Input_section_list;
d704 1
d740 1
a740 1
    : Output_section_data(size, 0),
d881 5
a885 7
  os->add_output_section_data(new Output_data_expression(this->size_,
							 this->is_signed_,
							 this->val_,
							 symtab,
							 layout,
							 *dot_value,
							 *dot_section));
d1171 1
a1171 1
struct Input_section_info
d1173 60
a1232 5
  Relobj* relobj;
  unsigned int shndx;
  std::string section_name;
  uint64_t size;
  uint64_t addralign;
d1259 1
a1259 1
	  && isi1.addralign == isi2.addralign))
d1261 2
a1262 2
      if (isi1.section_name != isi2.section_name)
	return isi1.section_name < isi2.section_name;
d1268 2
a1269 2
      if (isi1.addralign != isi2.addralign)
	return isi1.addralign < isi2.addralign;
d1273 2
a1274 2
      if (isi1.relobj->name() != isi2.relobj->name())
	return isi1.relobj->name() < isi2.relobj->name();
d1288 1
a1288 1
    Layout*,
d1312 4
a1317 3
      Input_section_info isi;
      isi.relobj = p->first;
      isi.shndx = p->second;
d1324 1
a1324 1
	Task_lock_obj<Object> tl(task, p->first);
d1326 6
a1331 3
	isi.section_name = p->first->section_name(p->second);
	isi.size = p->first->section_size(p->second);
	isi.addralign = p->first->section_addralign(p->second);
d1334 1
a1334 1
      if (!this->match_file_name(isi.relobj->name().c_str()))
d1348 1
a1348 1
	      if (match(isi.section_name.c_str(), isp.pattern.c_str(),
d1388 1
a1388 1
	  uint64_t this_subalign = p->addralign;
d1401 1
d1404 2
a1405 3
	  output_section->add_input_section_for_script(p->relobj,
						       p->shndx,
						       p->size,
d1408 1
a1408 1
	  *dot_value = address + p->size;
d2263 1
a2263 1
  typedef std::list<std::pair<Relobj*, unsigned int> > Input_section_list;
d2292 6
a2297 3
	Task_lock_obj<Object> tl(task, p->first);
	addralign = p->first->section_addralign(p->second);
	size = p->first->section_size(p->second);
d2301 1
a2301 2
      this->os_->add_input_section_for_script(p->first, p->second, size,
                                              addralign);
d2396 5
d3233 1
d3235 1
d3241 1
d3252 5
d3265 3
a3267 11
	  String_list::iterator q = phdr_names->begin();
	  while (q != phdr_names->end())
	    {
	      Name_to_segment::const_iterator r = name_to_segment.find(*q);
	      // We give errors about unknown segments below.
	      if (r == name_to_segment.end()
		  || r->second->type() == elfcpp::PT_LOAD)
		++q;
	      else
		q = phdr_names->erase(q);
	    }
d3280 4
d3438 15
@


1.20.4.1
log
@Merge elfcpp and gold from trunk.
@
text
@d527 1
a527 1
  typedef std::list<Output_section::Simple_input_section> Input_section_list;
a703 1
      layout->new_output_section_data_from_script(posd);
d739 1
a739 1
    : Output_section_data(size, 0, true),
d880 7
a886 5
  Output_data_expression* expression =
    new Output_data_expression(this->size_, this->is_signed_, this->val_,
			       symtab, layout, *dot_value, *dot_section);
  os->add_output_section_data(expression);
  layout->new_output_section_data_from_script(expression);
d1172 1
a1172 1
class Input_section_info
d1174 5
a1178 60
 public:
  Input_section_info(const Output_section::Simple_input_section& input_section)
    : input_section_(input_section), section_name_(),
      size_(0), addralign_(1)
  { }

  // Return the simple input section.
  const Output_section::Simple_input_section&
  input_section() const
  { return this->input_section_; }

  // Return the object.
  Relobj*
  relobj() const
  { return this->input_section_.relobj(); }

  // Return the section index.
  unsigned int
  shndx()
  { return this->input_section_.shndx(); }

  // Return the section name.
  const std::string&
  section_name() const
  { return this->section_name_; }

  // Set the section name.
  void
  set_section_name(const std::string name)
  { this->section_name_ = name; }

  // Return the section size.
  uint64_t
  size() const
  { return this->size_; }

  // Set the section size.
  void
  set_size(uint64_t size)
  { this->size_ = size; }

  // Return the address alignment.
  uint64_t
  addralign() const
  { return this->addralign_; }

  // Set the address alignment.
  void
  set_addralign(uint64_t addralign)
  { this->addralign_ = addralign; }

 private:
  // Input section, can be a relaxed section.
  Output_section::Simple_input_section input_section_;
  // Name of the section. 
  std::string section_name_;
  // Section size.
  uint64_t size_;
  // Address alignment.
  uint64_t addralign_;
d1205 1
a1205 1
	  && isi1.addralign() == isi2.addralign()))
d1207 2
a1208 2
      if (isi1.section_name() != isi2.section_name())
	return isi1.section_name() < isi2.section_name();
d1214 2
a1215 2
      if (isi1.addralign() != isi2.addralign())
	return isi1.addralign() < isi2.addralign();
d1219 2
a1220 2
      if (isi1.relobj()->name() != isi2.relobj()->name())
	return (isi1.relobj()->name() < isi2.relobj()->name());
d1234 1
a1234 1
    Layout* layout,
a1257 4
      Relobj* relobj = p->relobj();
      unsigned int shndx = p->shndx();      
      Input_section_info isi(*p);

d1260 3
d1269 1
a1269 1
	Task_lock_obj<Object> tl(task, relobj);
d1271 3
a1273 13
	isi.set_section_name(relobj->section_name(shndx));
	if (p->is_relaxed_input_section())
	  {
	    // We use current data size because relxed section sizes may not
	    // have finalized yet.
	    isi.set_size(p->relaxed_input_section()->current_data_size());
	    isi.set_addralign(p->relaxed_input_section()->addralign());
	  }
	else
	  {
	    isi.set_size(relobj->section_size(shndx));
	    isi.set_addralign(relobj->section_addralign(shndx));
	  }
d1276 1
a1276 1
      if (!this->match_file_name(relobj->name().c_str()))
d1290 1
a1290 1
	      if (match(isi.section_name().c_str(), isp.pattern.c_str(),
a1309 1
  uint64_t dot = *dot_value;
d1330 1
a1330 1
	  uint64_t this_subalign = p->addralign();
d1334 1
a1334 1
	  uint64_t address = align_address(dot, this_subalign);
d1336 1
a1336 1
	  if (address > dot && !fill->empty())
d1339 1
a1339 1
		convert_to_section_size_type(address - dot);
a1342 1
	      layout->new_output_section_data_from_script(posd);
d1345 3
a1347 2
	  output_section->add_input_section_for_script(p->input_section(),
						       p->size(),
d1350 1
a1350 1
	  dot = address + p->size();
a1353 7
  // An SHF_TLS/SHT_NOBITS section does not take up any
  // address space.
  if (output_section == NULL
      || (output_section->flags() & elfcpp::SHF_TLS) == 0
      || output_section->type() != elfcpp::SHT_NOBITS)
    *dot_value = dot;

d2205 1
a2205 1
  typedef std::list<Output_section::Simple_input_section> Input_section_list;
d2234 3
a2236 8
	Task_lock_obj<Object> tl(task, p->relobj());
	addralign = p->relobj()->section_addralign(p->shndx());
	if (p->is_relaxed_input_section())
	  // We use current data size because relxed section sizes may not
	  // have finalized yet.
	  size = p->relaxed_input_section()->current_data_size();
	else
	  size = p->relobj()->section_size(p->shndx());
d2240 2
a2241 1
      this->os_->add_input_section_for_script(*p, size, addralign);
d2245 4
a2248 9
  // An SHF_TLS/SHT_NOBITS section does not take up any address space.
  if (this->os_ == NULL
      || (this->os_->flags() & elfcpp::SHF_TLS) == 0
      || this->os_->type() != elfcpp::SHT_NOBITS)
    {
      if (!have_load_address)
	*load_address = address;
      else
	*load_address += address - *dot_value;
d2250 1
a2250 2
      *dot_value = address;
    }
a2335 5
  // Release the segment.
  void
  release_segment()
  { this->segment_ = NULL; }

a2454 9
      // The GNU linker permits assignments to . to appears outside of
      // a SECTIONS clause, and treats it as appearing inside, so
      // sections_elements_ may be NULL here.
      if (this->sections_elements_ == NULL)
	{
	  this->sections_elements_ = new Sections_elements;
	  this->saw_sections_clause_ = true;
	}

a3167 1
  
a3168 1
  bool load_segments_only = false;
a3173 1
      String_list* old_phdr_names = phdr_names;
a3183 5
      // We see a list of segments names.  Disable PT_LOAD segment only
      // filtering.
      if (old_phdr_names != phdr_names)
	load_segments_only = false;
		
d3192 11
a3202 3
	  // Enable PT_LOAD segments only filtering until we see another
	  // list of segment names.
	  load_segments_only = true;
a3214 4
	      if (load_segments_only
		  && r->second->type() != elfcpp::PT_LOAD)
		continue;

a3368 15
// Release all Output_segments.  This remove all pointers to all
// Output_segments.

void
Script_sections::release_segments()
{
  if (this->saw_phdrs_clause())
    {
      for (Phdrs_elements::const_iterator p = this->phdrs_elements_->begin();
	   p != this->phdrs_elements_->end();
	   ++p)
	(*p)->release_segment();
    }
}

@


1.20.4.2
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d3054 1
a3054 1
      current_seg->add_output_section(*p, seg_flags, false);
d3133 1
a3133 1
	  oseg->add_output_section(*p, seg_flags, false);
d3142 1
a3142 1
	      oseg->add_output_section(*pnext, seg_flags, false);
d3157 1
a3157 1
	  oseg->add_output_section(*p, seg_flags, false);
d3164 1
a3164 1
	      oseg->add_output_section(*pnext, seg_flags, false);
d3318 1
a3318 1
	      r->second->add_output_section(os, seg_flags, false);
@


1.19
log
@	* script-sections.cc (Script_sections::create_segments): Don't put
	program headers in a PT_LOAD segment if -n or -N.
@
text
@d1866 1
a1866 1
      uint64_t load_address =
d1870 2
a1871 2
        this->output_section_->set_load_address(load_address);
      this->evaluated_load_address_ = load_address;
d3079 1
a3079 1
// support becauase PHDRS is useless if there is no SECTIONS clause.
@


1.18
log
@	* script-sections.h: Include <list>.
	(class Script_sections): Change Sections_elements from std::vector
	to std::list.  Typedef public Elements_iterator.  Add
	orphan_section_placement_, data_segment_align_start_, and
	saw_data_segment_align_ fields.  Remove data_segment_align_index_
	field.
	* script-sections.cc (class Orphan_section_placement): New class.
	(class Sections_element): Add virtual functions is_relro and
	orphan_section_init.  Remove virtual function place_orphan_here.
	(class Output_section_definition): Add is_relro and
	orphan_section_init.  Remove place_orphan_here.
	(class Orphan_output_section): Likewise.
	(Script_sections::Script_sections): Update for field changes.
	(Script_sections::data_segment_align): Set saw_data_segment_align_
	and data_segment_align_start_, not data_segment_align_index.
	(Script_sections::data_segment_relro_end): Check
	saw_data_segment_align_.  Use data_segment_align_start_ rather
	than data_segment_align_index_.
	(Script_sections::place_orphan): Rewrite to use
	Orphan_section_placement.
@
text
@d2984 5
@


1.17
log
@	* layout.cc (Layout::attach_allocated_section_to_segment): Don't
	set tls_segment_ or relro_segment_.
	(Layout::make_output_segment): Set tls_segment_ and relro_segment_
	when appropriate.
	* output.h (Output_section::clear_is_relro): New function.
	* output.cc (Output_segment::add_output_section): Handle SHF_TLS
	sections specially even when output_data_ is empty.
	(Output_segment::maximum_alignment): When first section is relro,
	only force alignment for PT_LOAD segments.
	* script.cc (script_data_segment_align): New function.
	(script_data_segment_relro_end): New function.
	* script-c.h (script_data_segment_align): Declare.
	(script_data_segment_relro_end): Declare.
	* script-sections.h (class Script_sections): Declare
	data_segment_align and data_segment_relro_end.  Add fields
	segment_align_index_ and saw_relro_end_.
	* script-sections.cc (class Sections_element): Add set_is_relro
	virtual function.  Add new bool* parameter to place_orphan_here.
	Add get_output_section virtual function.
	(class Output_section_definition): Add set_is_relro.  Add new
	bool* parameter to place_orphan_here.  Add get_output_section.
	Add is_relro_ field.
	(Output_section_definition::Output_section_definition): Initialize
	evaluated_address_, evaluated_load_address, evaluated_addralign_,
	and is_relro_ fields.
	(Output_section_definition::place_orphan_here): Add is_relro
	parameter.
	(Output_section_definition::set_section_addresses): Set relro for
	output section.
	(Output_section_definition::alternate_constraint): Likewise.
	(class Orphan_output_section): Add new bool* parameter to
	place_orphan_here.  Add get_output_section.
	(Orphan_output_section::place_orphan_here): Add is_relro
	parameter.
	(Script_sections::Script_sections): Initialize
	data_segment_align_index_ and saw_relro_end_.
	(Script_sections::data_segment_align): New function.
	(Script_sections::data_segment_relro_end): New function.
	(Script_sections::place_orphan): Set or clear is_relro.
	(Script_sections::set_section_addresses): Force alignment of first
	TLS section.
	* yyscript.y (exp): Call script_data_segment_align and
	script_data_segment_relro_end.
	* testsuite/relro_script_test.t: New file.
	* testsuite/relro_test.cc (using_script): Declare.
	(t1, t2): Test using_script.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_script_test.
	(relro_script_test_SOURCES): Define.
	(relro_script_test_DEPENDENCIES): Define.
	(relro_script_test_LDFLAGS): Define.
	(relro_script_test_LDADD): Define.
	(relro_script_test.so): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d3 1
a3 1
// Copyright 2008 Free Software Foundation, Inc.
d46 253
d310 5
d343 5
a347 5
  // Return whether to place an orphan output section after this
  // element.
  virtual bool
  place_orphan_here(const Output_section *, bool*, bool*) const
  { return false; }
d1502 5
d1530 5
a1534 3
  // Return whether to place an orphan section after this one.
  bool
  place_orphan_here(const Output_section *os, bool* exact, bool*) const;
a1805 118
// Return whether to place an orphan output section after this
// section.

bool
Output_section_definition::place_orphan_here(const Output_section *os,
					     bool* exact,
					     bool* is_relro) const
{
  *is_relro = this->is_relro_;

  // Check for the simple case first.
  if (this->output_section_ != NULL
      && this->output_section_->type() == os->type()
      && this->output_section_->flags() == os->flags())
    {
      *exact = true;
      return true;
    }

  // Otherwise use some heuristics.

  if ((os->flags() & elfcpp::SHF_ALLOC) == 0)
    return false;

  if (os->type() == elfcpp::SHT_NOBITS)
    {
      if (this->name_ == ".bss")
	{
	  *exact = true;
	  return true;
	}
      if (this->output_section_ != NULL
	  && this->output_section_->type() == elfcpp::SHT_NOBITS)
	return true;
    }
  else if (os->type() == elfcpp::SHT_NOTE)
    {
      if (this->output_section_ != NULL
	  && this->output_section_->type() == elfcpp::SHT_NOTE)
	{
	  *exact = true;
	  return true;
	}
      if (this->name_.compare(0, 5, ".note") == 0)
	{
	  *exact = true;
	  return true;
	}
      if (this->name_ == ".interp")
	return true;
      if (this->output_section_ != NULL
	  && this->output_section_->type() == elfcpp::SHT_PROGBITS
	  && (this->output_section_->flags() & elfcpp::SHF_WRITE) == 0)
	return true;
    }
  else if (os->type() == elfcpp::SHT_REL || os->type() == elfcpp::SHT_RELA)
    {
      if (this->name_.compare(0, 4, ".rel") == 0)
	{
	  *exact = true;
	  return true;
	}
      if (this->output_section_ != NULL
	  && (this->output_section_->type() == elfcpp::SHT_REL
	      || this->output_section_->type() == elfcpp::SHT_RELA))
	{
	  *exact = true;
	  return true;
	}
      if (this->output_section_ != NULL
	  && this->output_section_->type() == elfcpp::SHT_PROGBITS
	  && (this->output_section_->flags() & elfcpp::SHF_WRITE) == 0)
	return true;
    }
  else if (os->type() == elfcpp::SHT_PROGBITS
	   && (os->flags() & elfcpp::SHF_WRITE) != 0)
    {
      if (this->name_ == ".data")
	{
	  *exact = true;
	  return true;
	}
      if (this->output_section_ != NULL
	  && this->output_section_->type() == elfcpp::SHT_PROGBITS
	  && (this->output_section_->flags() & elfcpp::SHF_WRITE) != 0)
	return true;
    }
  else if (os->type() == elfcpp::SHT_PROGBITS
	   && (os->flags() & elfcpp::SHF_EXECINSTR) != 0)
    {
      if (this->name_ == ".text")
	{
	  *exact = true;
	  return true;
	}
      if (this->output_section_ != NULL
	  && this->output_section_->type() == elfcpp::SHT_PROGBITS
	  && (this->output_section_->flags() & elfcpp::SHF_EXECINSTR) != 0)
	return true;
    }
  else if (os->type() == elfcpp::SHT_PROGBITS
	   || (os->type() != elfcpp::SHT_PROGBITS
	       && (os->flags() & elfcpp::SHF_WRITE) == 0))
    {
      if (this->name_ == ".rodata")
	{
	  *exact = true;
	  return true;
	}
      if (this->output_section_ != NULL
	  && this->output_section_->type() == elfcpp::SHT_PROGBITS
	  && (this->output_section_->flags() & elfcpp::SHF_WRITE) == 0)
	return true;
    }

  return false;
}

d2158 3
a2160 1
  // Return whether to place an orphan section after this one.
d2162 9
a2170 1
  place_orphan_here(const Output_section *os, bool* exact, bool*) const;
a2197 17
// Whether to place another orphan section after this one.

bool
Orphan_output_section::place_orphan_here(const Output_section* os,
					 bool* exact,
					 bool* is_relro) const
{
  if (this->os_->type() == os->type()
      && this->os_->flags() == os->flags())
    {
      *exact = true;
      *is_relro = this->os_->is_relro();
      return true;
    }
  return false;
}

d2399 3
a2401 1
    data_segment_align_index_(-1U),
d2536 1
a2536 1
  if (this->data_segment_align_index_ != -1U)
d2538 5
a2542 1
  this->data_segment_align_index_ = this->sections_elements_->size();
d2556 1
a2556 1
  if (this->data_segment_align_index_ == -1U)
d2560 3
a2562 4
      for (size_t i = this->data_segment_align_index_;
	   i < this->sections_elements_->size();
	   ++i)
	(*this->sections_elements_)[i]->set_is_relro();
d2648 21
a2668 7
  // Look for an output section definition which matches the output
  // section.  Put a marker after that section.
  bool is_relro = false;
  Sections_elements::iterator place = this->sections_elements_->end();
  for (Sections_elements::iterator p = this->sections_elements_->begin();
       p != this->sections_elements_->end();
       ++p)
d2670 11
a2680 9
      bool exact = false;
      bool is_relro_here;
      if ((*p)->place_orphan_here(os, &exact, &is_relro_here))
	{
	  place = p;
	  is_relro = is_relro_here;
	  if (exact)
	    break;
	}
a2681 9

  // The insert function puts the new element before the iterator.
  if (place != this->sections_elements_->end())
    ++place;

  this->sections_elements_->insert(place, new Orphan_output_section(os));

  if (is_relro)
    os->set_is_relro();
d2683 8
a2690 1
    os->clear_is_relro();
@


1.16
log
@	* options.h (class General_options): Define -n/--nmagic and
	-N/--omagic.
	* options.cc (General_options::finalize): For -n/--nmagic or
	-N/--omagic, set -static.
	* layout.cc (Layout::attach_allocated_section_to_segment): If
	-N/--omagic, don't put read-only and read-write sections in
	different segments.
	(Layout::find_first_load_seg): If -N/--omagic, don't insist on
	finding a read-only segment.
	(Layout::set_segment_offsets): If -N/--omagic or -n/--nmagic,
	don't set the minimum segment alignment to the common page size,
	and don't set the file offset to the address modulo the page size.
	* script-sections.cc (Script_sections::create_segments): If
	-n/--omagic, don't put read-only and read-write sections in
	different segments.
@
text
@d57 5
d88 1
a88 1
  place_orphan_here(const Output_section *, bool*) const
d134 5
d1244 5
d1269 1
a1269 1
  place_orphan_here(const Output_section *os, bool* exact) const;
d1302 5
d1342 2
d1361 5
a1365 1
    output_section_(NULL)
d1546 2
a1547 1
					     bool* exact) const
d1549 2
d1786 8
d1875 5
d2013 1
a2013 1
  place_orphan_here(const Output_section *os, bool* exact) const;
d2024 5
d2045 2
a2046 1
					 bool* exact) const
d2052 1
d2258 3
a2260 1
    phdrs_elements_(NULL)
d2388 33
d2505 1
d2512 2
a2513 1
      if ((*p)->place_orphan_here(os, &exact))
d2516 1
d2527 5
d2574 20
@


1.15
log
@	* script-sections.cc (Script_sections::place_orphan): Initialize
	local variable exact.
@
text
@d2660 2
a2661 1
	       && ((*p)->flags() & elfcpp::SHF_WRITE) != 0)
@


1.14
log
@	* mapfile.cc: New file.
	* mapfile.h: New file.
	* options.h (class General_options): Add -M/--print-map and -Map.
	* options.cc (General_options::finalize): Make -M equivalent to
	-Map -.
	* main.cc: Include <cstdio> and "mapfile.h".
	(main): Open mapfile if requested.
	* gold.cc (class Middle_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(queue_initial_tasks): Add mapfile parameter.  Change caller.
	(queue_middle_tasks): Likewise.
	* gold.h (queue_initial_tasks, queue_middle_tasks): Update
	declarations.
	* archive.cc: Include "mapfile.h".
	(Archive::add_symbols): Add mapfile parameter.  Change all
	callers.  Pass mapfile, symbol, and reason to include_member.
	(Archive::include_all_members): Add mapfile parameter.  Change all
	callers.
	(Archive::include_member): Add mapfile, sym, and why parameters.
	Change all callers.  Report inclusion to map file.
	* archive.h: Include "fileread.h".
	(class Archive): Update declarations.
	(Archive::file): New const method.
	(class Add_archive_symbols): Add mapfile_ field.  Update
	constructor.  Change all callers.
	* readsyms.h (class Read_symbols): Likewise.
	(class Finish_group): Likewise.
	(class Read_script): Likewise.
	* common.cc: Include "mapfile.h".
	(Symbol_table::allocate_commons): Add mapfile parameter.  Change
	all callers.
	(Symbol_table::do_allocate_commons): Likewise.
	(Symbol_table::do_allocate_commons_list): Likewise.  Report common
	symbol allocation to mapfile.
	* common.h (class Allocate_commons_task): Add mapfile_ field.
	Update constructor.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* layout.cc: Include "mapfile.h".
	(Layout_task_runner::run): Print information to mapfile.
	(Layout::create_gold_note): Change Output_data_fixed_space to
	Output_data_zero_fill.
	(Layout::create_build_id): Likewise.
	(Layout::print_to_mapfile): New function.
	* layout.h (class Layout_task_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(class Layout): Declare print_to_mapfile.
	* output.cc (Output_section::Input_section::print_to_mapfile): New
	function.
	(Output_section::add_input_section): If producing a map, always
	add to input_sections_ list.
	(Output_section::do_print_to_mapfile): New function.
	(Output_segment::print_sections_to_mapfile): New function.
	(Output_segment::print_section_list_to_mapfile): New function.
	* output.h: Include "mapfile.h".
	(Output_data::print_to_mapfile): New function.
	(Output_data::do_print_to_mapfile): New virtual function.
	(Output_segment_headers::do_print_to_mapfile): New function.
	(Output_file_header::do_print_to_mapfile): New function.
	(Output_data_const::do_print_to_mapfile): New function.
	(class Output_data_const_buffer): Add map_name_ field.  Update
	constructor.  Change all callers.  Add do_print_to_mapfile
	function.
	(class Output_data_fixed_space): Likewise.
	(class Output_data_space): Likewise.
	(class Output_data_zero_fill): New class.
	(Output_data_strtab::do_print_to_mapfile): New function.
	(Output_data_reloc_base::do_print_to_mapfile): New function.
	(Output_relocatable_relocs::do_print_to_mapfile): New function.
	(Output_data_group::do_print_to_mapfile): New function.
	(Output_data_got::do_print_to_mapfile): New function.
	(Output_data_dynamic::do_print_to_mapfile): New function.
	(Output_symtab_xindex::do_print_to_mapfile): New function.
	(class Output_section): Declare do_print_to_mapflie.  Declare
	print_to_mapfile in Input_section.
	(class Output_segment): Declare new functions.
	* object.h (Sized_relobj::symbol_count): New function.
	* script-sections.cc
	(Output_section_element_dot_assignment::set_section_addresses):
	Change Output_data_fixed_space to Output_data_zero_fill.
	(Output_data_expression::do_print_to_mapfile): New function.
	* script.cc (read_input_script): Add mapfile parameter.  Change
	all callers.
	* script.h (read_input_script): Update declaration.
	* ehframe.h (Eh_frame_hdr::do_print_to_mapfile): New function.
	(Eh_frame::do_print_to_mapfile): New function.
	* merge.h (Output_merge_data::do_print_to_mapfile): New function.
	(Output_merge_string::do_print_to_mapfile): New function.
	* i386.cc (Output_data_plt_i386::do_print_to_mapfile): New
	function.
	* sparc.cc (Output_data_plt_sparc::do_print_to_mapfile): New
	function.
	* x86_64.cc (Output_data_plt_x86_64::do_print_to_mapfile): New
	function.
	* Makefile.am (CCFILES): Add mapfile.cc.
	(HFILES): Add mapfile.h.
	* Makefile.in: Rebuild.
@
text
@d2426 1
a2426 1
      bool exact;
@


1.13
log
@	* script-sections.cc (Script_sections::create_segments): Use
	header_size_adjustment even when there is enough room for the
	headers.
	* testsuite/script_test_4.sh: New file.
	* testsuite/script_test_4.t: New file.
	* testsuite/Makefile.am (check_SCRIPTS): Add script_test_4.sh.
	(check_DATA): Add script_test_4.stdout.
	(MOSTLYCLEANFILES): Likewise.
	(script_test_4): New target.
	(script_test_4.stdout): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d429 1
a429 1
	posd = new Output_data_fixed_space(length, 0);
d485 5
@


1.12
log
@	PR gold/5996
	* script-sections.cc (Sections_element::allocate_to_segment): Add
	orphan parameter.
	(Output_section_definition::allocate_to_segment): Likewise.
	(Orphan_output_section::allocate_to_segment): Likewise.
	(Script_sections::attach_sections_using_phdrs_clause): Don't
	propagate non-PT_LOAD segments to orphan sections.
	* testsuite/Makefile.am (script_test_3.stdout): Generate using
	readelf rather than objdump.
	* testsuite/script_test_3.sh: Adjust accordingly.  Test that
	.interp section and PT_INTERP segment are the same size.
	* testsuite/Makefile.in: Rebuild.
@
text
@a2708 7
  if ((first_seg->paddr() & (abi_pagesize - 1)) >= sizeof_headers)
    {
      first_seg->set_addresses(first_seg->vaddr() - sizeof_headers,
			       first_seg->paddr() - sizeof_headers);
      return first_seg;
    }

d2714 6
@


1.11
log
@Permit scripts to refer to the addresses of output sections which were
not created.
@
text
@d108 6
a113 3
  // the Output_section, and set *PHDRS_LIST to the list of PHDRS to
  // which it should be attached.  If the PHDRS were not specified,
  // don't change *PHDRS_LIST.
d115 1
a115 1
  allocate_to_segment(String_list**)
d1269 1
a1269 4
  // using a PHDRS clause.  If this is an allocated section, return
  // the Output_section, and set *PHDRS_LIST to the list of PHDRS to
  // which it should be attached.  If the PHDRS were not specified,
  // don't change *PHDRS_LIST.
d1271 1
a1271 1
  allocate_to_segment(String_list** phdrs_list);
d1837 1
a1837 4
// a PHDRS clause.  If this is an allocated section, return the
// Output_section, and set *PHDRS_LIST to the list of PHDRS to which
// it should be attached.  If the PHDRS were not specified, don't
// change *PHDRS_LIST.
d1840 2
a1841 1
Output_section_definition::allocate_to_segment(String_list** phdrs_list)
d1847 1
d1973 1
a1973 2
  // using a PHDRS clause.  If this is an allocated section, return
  // the Output_section.
d1975 1
a1975 1
  allocate_to_segment(String_list**);
d2064 1
a2064 1
Orphan_output_section::allocate_to_segment(String_list**)
d2068 1
d2892 2
a2893 1
      Output_section* os = (*p)->allocate_to_segment(&phdr_names);
d2903 21
@


1.10
log
@Don't check assertions until symbols are finalized.  Create an output
section if the script uses a data statement with no input sections.
Don't create a loadable segment for the headers if there is no room.
@
text
@d115 11
d1273 9
d1311 6
d1677 6
a1682 1
  if (this->load_address_ != NULL && this->output_section_ != NULL)
d1688 3
a1690 1
      this->output_section_->set_load_address(load_address);
d1854 37
d3042 23
@


1.9
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d57 6
d184 1
a184 1
    *dot_value = this->val_->eval_with_dot(symtab, layout, *dot_value,
d194 1
a194 1
    *dot_value = this->val_->eval_with_dot(symtab, layout, *dot_value,
d253 5
d368 1
a368 1
    *dot_value = this->val_->eval_with_dot(symtab, layout, *dot_value,
d404 3
a406 2
  uint64_t next_dot = this->val_->eval_with_dot(symtab, layout, *dot_value,
						*dot_section, dot_section);
d501 1
a501 1
					   this->dot_value_,
d549 5
d651 1
a651 1
    uint64_t fill_val = this->val_->eval_with_dot(symtab, layout,
d1215 4
d1389 21
d1436 1
a1436 1
	  address = this->address_->eval_with_dot(symtab, layout,
d1443 1
a1443 1
	  uint64_t align = this->align_->eval_with_dot(symtab, layout,
d1615 2
a1616 2
      address = this->address_->eval_with_dot(symtab, layout, *dot_value,
					      NULL, &dummy);
d1630 1
a1630 1
      align = this->align_->eval_with_dot(symtab, layout, *dot_value,
d1655 1
a1655 1
	this->load_address_->eval_with_dot(symtab, layout, *dot_value,
d1666 3
a1668 2
      subalign = this->subalign_->eval_with_dot(symtab, layout, *dot_value,
						NULL, &subalign_section);
d1680 1
a1680 1
      uint64_t fill_val = this->fill_->eval_with_dot(symtab, layout,
d2048 2
a2049 1
      this->load_address_value_ = this->load_address_->eval(symtab, layout);
d2263 13
d2635 3
d2640 1
a2640 2
  if (first_seg != NULL
      && (first_seg->paddr() & (abi_pagesize - 1)) >= sizeof_headers)
d2647 11
d2660 1
a2660 20
  if (first_seg == NULL)
    load_seg->set_addresses(0, 0);
  else
    {
      uint64_t vma = first_seg->vaddr();
      uint64_t lma = first_seg->paddr();

      uint64_t subtract = this->header_size_adjustment(lma, sizeof_headers);
      if (lma >= subtract && vma >= subtract)
	load_seg->set_addresses(vma - subtract, lma - subtract);
      else
	{
	  // We could handle this case by create the file header
	  // outside of any PT_LOAD segment, and creating a new
	  // PT_LOAD segment after the others to hold the segment
	  // headers.
	  gold_error(_("sections loaded on first page without room for "
		       "file and program headers are not supported"));
	}
    }
@


1.8
log
@Set load address for orphan sections.
@
text
@d492 1
a492 1
  if (parameters->is_big_endian())
d515 1
a515 1
      if (parameters->get_size() == 32)
d2433 1
a2433 1
  if (parameters->get_size() == 32)
d2438 1
a2438 1
  else if (parameters->get_size() == 64)
d2458 1
a2458 1
  const uint64_t abi_pagesize = parameters->target()->abi_pagesize();
d2473 1
a2473 1
  if (parameters->output_is_object())
d2488 1
a2488 1
  const uint64_t abi_pagesize = parameters->target()->abi_pagesize();
@


1.7
log
@Pass down alignment when adding input section to orphan section.
@
text
@d83 1
a83 1
  set_section_addresses(Symbol_table*, Layout*, uint64_t*)
d142 1
a142 1
			uint64_t* dot_value)
d185 1
a185 1
			uint64_t* dot_value)
d190 1
d1219 1
a1219 1
			uint64_t* dot_value);
d1564 2
a1565 1
						 uint64_t* dot_value)
d1599 2
d1670 6
d1858 1
a1858 1
  set_section_addresses(Symbol_table*, Layout*, uint64_t*);
d1897 2
a1898 1
					     uint64_t* dot_value)
d1902 2
d1908 6
a1913 1
    this->os_->set_address(address);
d1940 5
d2353 1
d2357 1
a2357 1
    (*p)->set_section_addresses(symtab, layout, &dot_value);
@


1.6
log
@Track sections for expressions.
@
text
@d1917 2
a1918 1
      this->os_->add_input_section_for_script(p->first, p->second, size, 0);
@


1.5
log
@Print PHDRS clause for debugging.
@
text
@d64 1
a64 1
  finalize_symbols(Symbol_table*, const Layout*, bool*, uint64_t*)
d83 1
a83 1
  set_section_addresses(Symbol_table*, Layout*, bool*, uint64_t*)
d132 1
a132 1
		   bool* dot_has_value, uint64_t* dot_value)
d134 1
a134 2
    this->assignment_.finalize_with_dot(symtab, layout, *dot_has_value,
					*dot_value);
d142 1
a142 1
			bool* dot_has_value, uint64_t* dot_value)
d144 1
a144 2
    this->assignment_.set_if_absolute(symtab, layout, true, *dot_has_value,
				      *dot_value);
d172 1
a172 1
		   bool* dot_has_value, uint64_t* dot_value)
d174 6
a179 4
    bool dummy;
    *dot_value = this->val_->eval_with_dot(symtab, layout, *dot_has_value,
					   *dot_value, &dummy);
    *dot_has_value = true;
d185 1
a185 1
			bool* dot_has_value, uint64_t* dot_value)
d187 3
a189 6
    bool is_absolute;
    *dot_value = this->val_->eval_with_dot(symtab, layout, *dot_has_value,
					   *dot_value, &is_absolute);
    if (!is_absolute)
      gold_error(_("dot set to non-absolute value"));
    *dot_has_value = true;
d217 1
a217 2
  finalize_symbols(Symbol_table* symtab, const Layout* layout, bool*,
		   uint64_t*)
d253 1
a253 1
  finalize_symbols(Symbol_table*, const Layout*, bool*, uint64_t*)
d266 2
a267 1
			uint64_t*, std::string*, Input_section_list*)
d313 1
a313 1
		   bool* dot_has_value, uint64_t* dot_value)
d315 2
a316 2
    this->assignment_.finalize_with_dot(symtab, layout, *dot_has_value,
					*dot_value);
d324 2
a325 2
			uint64_t, uint64_t* dot_value, std::string*,
			Input_section_list*)
d327 1
a327 1
    this->assignment_.set_if_absolute(symtab, layout, true, true, *dot_value);
d354 1
a354 1
		   bool* dot_has_value, uint64_t* dot_value)
d356 2
a357 4
    bool dummy;
    *dot_value = this->val_->eval_with_dot(symtab, layout, *dot_has_value,
					   *dot_value, &dummy);
    *dot_has_value = true;
d363 2
a364 2
			uint64_t, uint64_t* dot_value, std::string*,
			Input_section_list*);
d388 1
d392 2
a393 5
  bool is_absolute;
  uint64_t next_dot = this->val_->eval_with_dot(symtab, layout, true,
						*dot_value, &is_absolute);
  if (!is_absolute)
    gold_error(_("dot set to non-absolute value"));
d434 3
a436 1
// A data item in an output section.
d438 1
a438 1
class Output_section_element_data : public Output_section_element
d441 6
a446 2
  Output_section_element_data(int size, bool is_signed, Expression* val)
    : size_(size), is_signed_(is_signed), val_(val)
d449 2
a450 1
  // Finalize symbols--we just need to update dot.
d452 1
a452 2
  finalize_symbols(Symbol_table*, const Layout*, bool*, uint64_t* dot_value)
  { *dot_value += this->size_; }
d454 1
a454 1
  // Store the value in the section.
d456 1
a456 7
  set_section_addresses(Symbol_table*, Layout*, Output_section*, uint64_t,
			uint64_t* dot_value, std::string*,
			Input_section_list*);

  // Print for debugging.
  void
  print(FILE*) const;
d460 2
a461 2
  std::string
  set_fill_string(uint64_t);
a462 3
  // The size in bytes.
  int size_;
  // Whether the value is signed.
a463 1
  // The value.
d465 4
d471 1
a471 1
// Store the value in the section.
d474 1
a474 7
Output_section_element_data::set_section_addresses(Symbol_table* symtab,
						   Layout* layout,
						   Output_section* os,
						   uint64_t,
						   uint64_t* dot_value,
						   std::string*,
						   Input_section_list*)
d476 6
a481 1
  gold_assert(os != NULL);
d483 7
a489 5
  bool is_absolute;
  uint64_t val = this->val_->eval_with_dot(symtab, layout, true, *dot_value,
					   &is_absolute);
  if (!is_absolute)
    gold_error(_("data directive with non-absolute value"));
a490 1
  std::string fill;
d492 1
a492 1
    fill = this->set_fill_string<true>(val);
d494 1
a494 5
    fill = this->set_fill_string<false>(val);

  os->add_output_section_data(new Output_data_const(fill, 0));

  *dot_value += this->size_;
a496 2
// Get the value to store in a std::string.

d498 3
a500 2
std::string
    Output_section_element_data::set_fill_string(uint64_t val)
d502 1
a502 3
  std::string ret;
  unsigned char buf[8];
  switch (this->size_)
a505 1
      ret.assign(reinterpret_cast<char*>(buf), 1);
a508 1
      ret.assign(reinterpret_cast<char*>(buf), 2);
a511 1
      ret.assign(reinterpret_cast<char*>(buf), 4);
a520 1
      ret.assign(reinterpret_cast<char*>(buf), 8);
d525 58
a582 1
  return ret;
d628 10
a637 9
			uint64_t, uint64_t* dot_value, std::string* fill,
			Input_section_list*)
  {
    bool is_absolute;
    uint64_t fill_val = this->val_->eval_with_dot(symtab, layout, true,
						  *dot_value,
						  &is_absolute);
    if (!is_absolute)
      gold_error(_("fill set to non-absolute value"));
d676 2
a677 2
  finalize_symbols(Symbol_table*, const Layout*, bool* dot_has_value,
		   uint64_t* dot_value)
d680 1
a680 1
    *dot_has_value = true;
d692 2
a693 1
			std::string* fill, Input_section_list*);
d751 3
d769 2
a770 1
    final_dot_value_(0)
d933 1
d1050 1
d1203 1
a1203 1
  finalize_symbols(Symbol_table*, const Layout*, bool*, uint64_t*);
d1218 1
a1218 1
			bool* dot_has_value, uint64_t* dot_value);
a1382 1
					    bool* dot_has_value,
d1392 1
a1392 1
	  bool dummy;
d1394 1
a1394 1
						  *dot_has_value, *dot_value,
d1399 1
a1399 1
	  bool dummy;
a1400 1
						       *dot_has_value,
d1402 1
a1407 1
  *dot_has_value = true;
d1409 1
d1413 1
a1413 1
    (*p)->finalize_symbols(symtab, layout, dot_has_value, dot_value);
a1562 1
						 bool* dot_has_value,
a1564 1
  bool is_absolute;
d1566 2
a1567 8
  if (this->address_ != NULL)
    {
      address = this->address_->eval_with_dot(symtab, layout, *dot_has_value,
					      *dot_value, &is_absolute);
      if (!is_absolute)
	gold_error(_("address of section %s is not absolute"),
		   this->name_.c_str());
    }
d1570 3
a1572 4
      if (!*dot_has_value)
	gold_error(_("no address given for section %s"),
		   this->name_.c_str());
      address = *dot_value;
d1585 6
a1590 5
      align = this->align_->eval_with_dot(symtab, layout, *dot_has_value,
					  *dot_value, &is_absolute);
      if (!is_absolute)
	gold_error(_("alignment of section %s is not absolute"),
		   this->name_.c_str());
a1597 1
  *dot_has_value = true;
d1607 1
d1609 2
a1610 5
	this->load_address_->eval_with_dot(symtab, layout, *dot_has_value,
					   *dot_value, &is_absolute);
      if (!is_absolute)
	gold_error(_("load address of section %s is not absolute"),
		   this->name_.c_str());
d1619 6
a1624 5
      subalign = this->subalign_->eval_with_dot(symtab, layout, *dot_has_value,
						*dot_value, &is_absolute);
      if (!is_absolute)
	gold_error(_("subalign of section %s is not absolute"),
		   this->name_.c_str());
d1632 1
a1633 1
						     *dot_has_value,
d1635 5
a1639 4
						     &is_absolute);
      if (!is_absolute)
	gold_error(_("fill of section %s is not absolute"),
		   this->name_.c_str());
d1657 1
d1662 2
a1663 1
				subalign, dot_value, &fill, &input_sections);
d1848 1
a1848 1
  set_section_addresses(Symbol_table*, Layout*, bool*, uint64_t*);
a1886 1
					     bool* dot_has_value,
a1890 3
  if (!*dot_has_value)
    gold_error(_("no address for orphan section %s"), this->os_->name());

a2214 1
  bool dot_has_value = false;
d2219 1
a2219 1
    (*p)->finalize_symbols(symtab, layout, &dot_has_value, &dot_value);
d2327 1
a2327 1
  bool dot_has_value = false;
d2332 1
a2332 1
    (*p)->set_section_addresses(symtab, layout, &dot_has_value, &dot_value);
@


1.4
log
@Implement PHDRS.
@
text
@d1780 8
d1978 4
d2004 21
d2880 10
@


1.3
log
@Implement SIZEOF_HEADERS, section constraints, other minor linker
script items.
@
text
@d28 1
d100 9
d1185 8
d1214 3
d1237 1
d1249 1
d1418 5
a1425 2
      if (this->name_ == ".bss")
	return true;
d1431 10
d1442 3
a1444 2
      if (this->name_ == ".interp"
	  || this->name_.compare(0, 5, ".note") == 0)
d1449 5
d1457 7
a1463 2
	return true;
      if (this->name_.compare(0, 4, ".rel") == 0)
d1469 5
a1477 2
      if (this->name_ == ".data")
	return true;
d1482 5
a1490 2
      if (this->name_ == ".text")
	return true;
d1492 3
a1494 1
  else if (os->type() == elfcpp::SHT_PROGBITS)
d1496 5
d1503 1
a1503 4
	  && (this->output_section_->flags() & elfcpp::SHF_WRITE) == 0
	  && (this->output_section_->flags() & elfcpp::SHF_EXECINSTR) == 0)
	return true;
      if (this->name_ == ".rodata")
d1711 18
d1803 6
d1881 111
d1998 2
a1999 1
    output_section_(NULL)
d2267 8
d2333 39
d2384 3
d2486 1
a2486 17
  size_t segment_count = layout->segment_count();
  size_t file_header_size;
  size_t segment_headers_size;
  if (parameters->get_size() == 32)
    {
      file_header_size = elfcpp::Elf_sizes<32>::ehdr_size;
      segment_headers_size = segment_count * elfcpp::Elf_sizes<32>::phdr_size;
    }
  else if (parameters->get_size() == 64)
    {
      file_header_size = elfcpp::Elf_sizes<64>::ehdr_size;
      segment_headers_size = segment_count * elfcpp::Elf_sizes<64>::phdr_size;
    }
  else
    gold_unreachable();

  size_t sizeof_headers = file_header_size + segment_headers_size;
d2505 3
a2507 7
      // We want a segment with the same relationship between VMA and
      // LMA, but with enough room for the headers, and aligned to
      // load at the start of a page.
      uint64_t hdr_lma = lma - sizeof_headers;
      hdr_lma &= ~(abi_pagesize - 1);
      if (lma >= hdr_lma && vma >= (lma - hdr_lma))
	load_seg->set_addresses(vma - (lma - hdr_lma), hdr_lma);
d2530 2
d2584 19
d2609 3
d2646 183
@


1.2
log
@Fully implement the SECTIONS clause.
@
text
@d85 14
d1163 12
d1192 2
d1214 1
d1572 82
d2040 27
d2259 2
d2262 6
a2267 3
      && ((first_seg->paddr() & (abi_pagesize - 1))
	  >= file_header_size + segment_headers_size))
    return first_seg;
d2278 7
a2284 10
      if (lma >= file_header_size + segment_headers_size
	  && lma >= abi_pagesize)
	{
	  // We want a segment with the same relationship between VMA
	  // and LMA, but with enough room for the headers.
	  uint64_t size_for_page = align_address((file_header_size
						  + segment_headers_size),
						 abi_pagesize);
	  load_seg->set_addresses(vma - size_for_page, lma - size_for_page);
	}
d2357 42
@


1.1
log
@Parse a SECTIONS clause in a linker script.
@
text
@d25 3
d30 1
d32 4
d56 30
d100 26
d137 47
d194 7
d217 3
d226 24
d252 6
d260 13
d284 26
d321 75
d426 12
d442 4
d454 68
d562 19
d594 9
a607 3
  // Note that an Input_section_spec holds some pointers to vectors.
  // This constructor takes ownership of them.  The parser is
  // implemented such that this works.
d610 21
d639 1
d644 3
a646 1
      : pattern(patterna, patternlena), sort(sorta)
d652 17
a668 1
  typedef std::vector<std::string> Filename_exclusions;
d670 2
a671 1
  // The file name pattern.
d673 2
d684 2
d695 2
a696 1
  : filename_pattern_(spec->file.name.value, spec->file.name.length),
d700 2
a701 1
    keep_(keep)
d703 7
d716 5
a720 1
	this->filename_exclusions_.push_back(*p);
d735 247
d1030 1
a1030 1
	      fprintf(f, "%s", p->c_str());
d1092 2
d1105 5
d1126 23
d1170 3
d1187 2
a1188 1
    elements_()
d1217 9
d1268 275
d1597 92
d1739 14
d1821 396
@

