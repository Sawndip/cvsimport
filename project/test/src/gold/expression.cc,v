head	1.20;
access;
symbols
	binutils-2_24-branch:1.20.0.4
	binutils-2_24-branchpoint:1.20
	binutils-2_21_1:1.17.2.1
	binutils-2_23_2:1.20
	binutils-2_23_1:1.20
	binutils-2_23:1.20
	binutils-2_23-branch:1.20.0.2
	binutils-2_23-branchpoint:1.20
	binutils-2_22_branch:1.18.0.4
	binutils-2_22:1.18
	binutils-2_22-branch:1.18.0.2
	binutils-2_22-branchpoint:1.18
	binutils-2_21:1.17.2.1
	binutils-2_21-branch:1.17.0.2
	binutils-2_21-branchpoint:1.17
	binutils-2_20_1:1.10
	binutils-2_20:1.10
	binutils-arc-20081103-branch:1.10.0.10
	binutils-arc-20081103-branchpoint:1.10
	binutils-2_20-branch:1.10.0.8
	binutils-2_20-branchpoint:1.10
	dje-cgen-play1-branch:1.10.0.6
	dje-cgen-play1-branchpoint:1.10
	arc-20081103-branch:1.10.0.4
	arc-20081103-branchpoint:1.10
	binutils-2_19_1:1.10
	binutils-2_19:1.10
	binutils-2_19-branch:1.10.0.2
	binutils-2_19-branchpoint:1.10
	binutils_latest_snapshot:1.20
	added-to-binutils:1.10;
locks; strict;
comment	@// @;


1.20
date	2011.12.19.21.07.16;	author ian;	state Exp;
branches;
next	1.19;

1.19
date	2011.10.31.22.51.03;	author ccoutant;	state Exp;
branches;
next	1.18;

1.18
date	2010.11.18.23.25.08;	author dougkwan;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2010.10.01.15.02.33;	author nickc;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2010.09.08.16.10.31;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.23.04.47.32;	author ian;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.14.19.53.04;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.16.18.56.07;	author dougkwan;	state Exp;
branches;
next	1.10;

1.10
date	2008.02.29.00.04.06;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.28.04.45.47;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2008.02.13.22.44.50;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.13.01.18.53;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.09.01.22.17;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2008.02.04.06.45.50;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2008.02.04.05.41.39;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.23.01.31.13;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2008.01.09.19.57.45;	author iant;	state Exp;
branches;
next	;

1.18.2.1
date	2011.12.19.21.14.39;	author ian;	state Exp;
branches;
next	;

1.17.2.1
date	2010.11.19.11.39.38;	author gingold;	state Exp;
branches;
next	;


desc
@@


1.20
log
@	* object.h (Relobj::local_symbol_value): New function.
	(Relobj::local_plt_offset): New function.
	(Relobj::local_has_got_offset): New function.
	(Relobj::local_got_offset): New function.
	(Relobj::set_local_got_offset): New function.
	(Relobj::do_local_symbol_value): New pure virtual function.
	(Relobj::do_local_plt_offset): Likewise.
	(Relobj::do_local_has_got_offset): Likewise.
	(Relobj::do_local_got_offset): Likewise.
	(Relobj::do_set_local_got_offset): Likewise.
	(Sized_relobj::do_local_has_got_offset): Rename from
	local_has_got_offset.
	(Sized_relobj::do_local_got_offset): Rename from local_got_offset.
	(Sized_relobj::do_set_local_got_offset): Rename from
	set_local_got_offset.
	(Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	(Sized_relobj_file::do_local_symbol_value): New function.
	* object.cc (Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	* output.cc (Output_data_got::Got_entry::write): Change object to
	Relobj.  Use local_symbol_value.
	(Output_data_got::add_global_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_with_rela): Remove.  Change all
	callers to use add_global_with_rel.
	(Output_data_got::add_global_pair_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_pair_with_rela): Remove.  Change all
	callers to use add_global_pair_with_rel.
	(Output_data_got::add_local): Change object to Relobj*.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Change object to Relobj*,
	change rel_dyn to Output_data_reloc_generic*.  Use
	add_local_generic.
	(Output_data_got::add_local_with_rela): Remove.  Change all
	callers to use all_local_with_rel.
	(Output_data_got::add_local_pair_with_rel): Change object to
	Relobj*, change rel_dyn to Output_data_reloc_generic*.  Use
	add_output_section_generic.
	(Output_data_got::add_local_pair_with_rela): Remove.  Change all
	callers to use add_local_pair_with_rel.
	(Output_data_got::reserve_local): Change object to Relobj*.
	* output.h: (class Output_data_reloc_generic): Add pure virtual
	declarations for add_global_generic, add_local_generic,
	add_output_section_generic.
	(class Output_data_reloc) [SHT_REL, SHT_RELA]: Implement new
	functions for Output_data_reloc_generic.  Update declarations for
	changes listed in output.cc.
	(class Output_data_got): Change template parameter to got_size.
	Don't define Rel_dyn or Rela_dyn.  Update declarations per above.
	* incremental.h (Sized_relobj_incr::do_local_symbol_value): New
	function.
	(Sized_relobj_incr::do_local_plt_offset): New function.
	* copy-relocs.cc (Copy_relocs::Copy_reloc_entry::emit): Call
	add_global_generic.
@
text
@// expression.cc -- expressions in linker scripts for gold

// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <string>

#include "elfcpp.h"
#include "parameters.h"
#include "symtab.h"
#include "layout.h"
#include "output.h"
#include "script.h"
#include "script-c.h"

namespace gold
{

// This file holds the code which handles linker expressions.

// The dot symbol, which linker scripts refer to simply as ".",
// requires special treatment.  The dot symbol is set several times,
// section addresses will refer to it, output sections will change it,
// and it can be set based on the value of other symbols.  We simplify
// the handling by prohibiting setting the dot symbol to the value of
// a non-absolute symbol.

// When evaluating the value of an expression, we pass in a pointer to
// this struct, so that the expression evaluation can find the
// information it needs.

struct Expression::Expression_eval_info
{
  // The symbol table.
  const Symbol_table* symtab;
  // The layout--we use this to get section information.
  const Layout* layout;
  // Whether to check assertions.
  bool check_assertions;
  // Whether expressions can refer to the dot symbol.  The dot symbol
  // is only available within a SECTIONS clause.
  bool is_dot_available;
  // The current value of the dot symbol.
  uint64_t dot_value;
  // The section in which the dot symbol is defined; this is NULL if
  // it is absolute.
  Output_section* dot_section;
  // Points to where the section of the result should be stored.
  Output_section** result_section_pointer;
  // Pointer to where the alignment of the result should be stored.
  uint64_t* result_alignment_pointer;
};

// Evaluate an expression.

uint64_t
Expression::eval(const Symbol_table* symtab, const Layout* layout,
		 bool check_assertions)
{
  return this->eval_maybe_dot(symtab, layout, check_assertions,
			      false, 0, NULL, NULL, NULL, false);
}

// Evaluate an expression which may refer to the dot symbol.

uint64_t
Expression::eval_with_dot(const Symbol_table* symtab, const Layout* layout,
			  bool check_assertions, uint64_t dot_value,
			  Output_section* dot_section,
			  Output_section** result_section_pointer,
			  uint64_t* result_alignment_pointer,
			  bool is_section_dot_assignment)
{
  return this->eval_maybe_dot(symtab, layout, check_assertions, true,
			      dot_value, dot_section, result_section_pointer,
			      result_alignment_pointer,
			      is_section_dot_assignment);
}

// Evaluate an expression which may or may not refer to the dot
// symbol.

uint64_t
Expression::eval_maybe_dot(const Symbol_table* symtab, const Layout* layout,
			   bool check_assertions, bool is_dot_available,
			   uint64_t dot_value, Output_section* dot_section,
			   Output_section** result_section_pointer,
			   uint64_t* result_alignment_pointer,
			   bool is_section_dot_assignment)
{
  Expression_eval_info eei;
  eei.symtab = symtab;
  eei.layout = layout;
  eei.check_assertions = check_assertions;
  eei.is_dot_available = is_dot_available;
  eei.dot_value = dot_value;
  eei.dot_section = dot_section;

  // We assume the value is absolute, and only set this to a section
  // if we find a section-relative reference.
  if (result_section_pointer != NULL)
    *result_section_pointer = NULL;
  eei.result_section_pointer = result_section_pointer;

  eei.result_alignment_pointer = result_alignment_pointer;

  uint64_t val = this->value(&eei);

  // If this is an assignment to dot within a section, and the value
  // is absolute, treat it as a section-relative offset.
  if (is_section_dot_assignment && *result_section_pointer == NULL)
    {
      gold_assert(dot_section != NULL);
      val += dot_section->address();
      *result_section_pointer = dot_section;
    }
  return val;
}

// A number.

class Integer_expression : public Expression
{
 public:
  Integer_expression(uint64_t val)
    : val_(val)
  { }

  uint64_t
  value(const Expression_eval_info*)
  { return this->val_; }

  void
  print(FILE* f) const
  { fprintf(f, "0x%llx", static_cast<unsigned long long>(this->val_)); }

 private:
  uint64_t val_;
};

extern "C" Expression*
script_exp_integer(uint64_t val)
{
  return new Integer_expression(val);
}

// An expression whose value is the value of a symbol.

class Symbol_expression : public Expression
{
 public:
  Symbol_expression(const char* name, size_t length)
    : name_(name, length)
  { }

  uint64_t
  value(const Expression_eval_info*);

  void
  print(FILE* f) const
  { fprintf(f, "%s", this->name_.c_str()); }

 private:
  std::string name_;
};

uint64_t
Symbol_expression::value(const Expression_eval_info* eei)
{
  Symbol* sym = eei->symtab->lookup(this->name_.c_str());
  if (sym == NULL || !sym->is_defined())
    {
      gold_error(_("undefined symbol '%s' referenced in expression"),
		 this->name_.c_str());
      return 0;
    }

  if (eei->result_section_pointer != NULL)
    *eei->result_section_pointer = sym->output_section();

  if (parameters->target().get_size() == 32)
    return eei->symtab->get_sized_symbol<32>(sym)->value();
  else if (parameters->target().get_size() == 64)
    return eei->symtab->get_sized_symbol<64>(sym)->value();
  else
    gold_unreachable();
}

// An expression whose value is the value of the special symbol ".".
// This is only valid within a SECTIONS clause.

class Dot_expression : public Expression
{
 public:
  Dot_expression()
  { }

  uint64_t
  value(const Expression_eval_info*);

  void
  print(FILE* f) const
  { fprintf(f, "."); }
};

uint64_t
Dot_expression::value(const Expression_eval_info* eei)
{
  if (!eei->is_dot_available)
    {
      gold_error(_("invalid reference to dot symbol outside of "
		   "SECTIONS clause"));
      return 0;
    }
  if (eei->result_section_pointer != NULL)
    *eei->result_section_pointer = eei->dot_section;
  return eei->dot_value;
}

// A string.  This is either the name of a symbol, or ".".

extern "C" Expression*
script_exp_string(const char* name, size_t length)
{
  if (length == 1 && name[0] == '.')
    return new Dot_expression();
  else
    return new Symbol_expression(name, length);
}

// A unary expression.

class Unary_expression : public Expression
{
 public:
  Unary_expression(Expression* arg)
    : arg_(arg)
  { }

  ~Unary_expression()
  { delete this->arg_; }

 protected:
  uint64_t
  arg_value(const Expression_eval_info* eei,
	    Output_section** arg_section_pointer) const
  {
    return this->arg_->eval_maybe_dot(eei->symtab, eei->layout,
				      eei->check_assertions,
				      eei->is_dot_available,
				      eei->dot_value,
				      eei->dot_section,
				      arg_section_pointer,
				      eei->result_alignment_pointer,
				      false);
  }

  void
  arg_print(FILE* f) const
  { this->arg_->print(f); }

 private:
  Expression* arg_;
};

// Handle unary operators.  We use a preprocessor macro as a hack to
// capture the C operator.

#define UNARY_EXPRESSION(NAME, OPERATOR)				\
  class Unary_ ## NAME : public Unary_expression			\
  {									\
  public:								\
    Unary_ ## NAME(Expression* arg)					\
      : Unary_expression(arg)						\
    { }									\
    									\
    uint64_t								\
    value(const Expression_eval_info* eei)				\
    {									\
      Output_section* arg_section;					\
      uint64_t ret = OPERATOR this->arg_value(eei, &arg_section);	\
      if (arg_section != NULL && parameters->options().relocatable())	\
	gold_warning(_("unary " #NAME " applied to section "		\
		       "relative value"));				\
      return ret;							\
    }									\
									\
    void								\
    print(FILE* f) const						\
    {									\
      fprintf(f, "(%s ", #OPERATOR);					\
      this->arg_print(f);						\
      fprintf(f, ")");							\
    }									\
  };									\
									\
  extern "C" Expression*						\
  script_exp_unary_ ## NAME(Expression* arg)				\
  {									\
      return new Unary_ ## NAME(arg);					\
  }

UNARY_EXPRESSION(minus, -)
UNARY_EXPRESSION(logical_not, !)
UNARY_EXPRESSION(bitwise_not, ~)

// A binary expression.

class Binary_expression : public Expression
{
 public:
  Binary_expression(Expression* left, Expression* right)
    : left_(left), right_(right)
  { }

  ~Binary_expression()
  {
    delete this->left_;
    delete this->right_;
  }

 protected:
  uint64_t
  left_value(const Expression_eval_info* eei,
	     Output_section** section_pointer,
	     uint64_t* alignment_pointer) const
  {
    return this->left_->eval_maybe_dot(eei->symtab, eei->layout,
				       eei->check_assertions,
				       eei->is_dot_available,
				       eei->dot_value,
				       eei->dot_section,
				       section_pointer,
				       alignment_pointer,
				       false);
  }

  uint64_t
  right_value(const Expression_eval_info* eei,
	      Output_section** section_pointer,
	      uint64_t* alignment_pointer) const
  {
    return this->right_->eval_maybe_dot(eei->symtab, eei->layout,
					eei->check_assertions,
					eei->is_dot_available,
					eei->dot_value,
					eei->dot_section,
					section_pointer,
					alignment_pointer,
					false);
  }

  void
  left_print(FILE* f) const
  { this->left_->print(f); }

  void
  right_print(FILE* f) const
  { this->right_->print(f); }

  // This is a call to function FUNCTION_NAME.  Print it.  This is for
  // debugging.
  void
  print_function(FILE* f, const char* function_name) const
  {
    fprintf(f, "%s(", function_name);
    this->left_print(f);
    fprintf(f, ", ");
    this->right_print(f);
    fprintf(f, ")");
  }

 private:
  Expression* left_;
  Expression* right_;
};

// Handle binary operators.  We use a preprocessor macro as a hack to
// capture the C operator.  KEEP_LEFT means that if the left operand
// is section relative and the right operand is not, the result uses
// the same section as the left operand.  KEEP_RIGHT is the same with
// left and right swapped.  IS_DIV means that we need to give an error
// if the right operand is zero.  WARN means that we should warn if
// used on section relative values in a relocatable link.  We always
// warn if used on values in different sections in a relocatable link.

#define BINARY_EXPRESSION(NAME, OPERATOR, KEEP_LEFT, KEEP_RIGHT, IS_DIV, WARN) \
  class Binary_ ## NAME : public Binary_expression			\
  {									\
  public:								\
    Binary_ ## NAME(Expression* left, Expression* right)		\
      : Binary_expression(left, right)					\
    { }									\
									\
    uint64_t								\
    value(const Expression_eval_info* eei)				\
    {									\
      Output_section* left_section;					\
      uint64_t left_alignment = 0;					\
      uint64_t left = this->left_value(eei, &left_section,		\
				       &left_alignment);		\
      Output_section* right_section;					\
      uint64_t right_alignment = 0;					\
      uint64_t right = this->right_value(eei, &right_section,		\
					 &right_alignment);		\
      if (KEEP_RIGHT && left_section == NULL && right_section != NULL)	\
	{								\
	  if (eei->result_section_pointer != NULL)			\
	    *eei->result_section_pointer = right_section;		\
	  if (eei->result_alignment_pointer != NULL			\
	      && right_alignment > *eei->result_alignment_pointer)	\
	    *eei->result_alignment_pointer = right_alignment;		\
	}								\
      else if (KEEP_LEFT						\
	       && left_section != NULL					\
	       && right_section == NULL)				\
	{								\
	  if (eei->result_section_pointer != NULL)			\
	    *eei->result_section_pointer = left_section;		\
	  if (eei->result_alignment_pointer != NULL			\
	      && left_alignment > *eei->result_alignment_pointer)	\
	    *eei->result_alignment_pointer = left_alignment;		\
	}								\
      else if ((WARN || left_section != right_section)			\
	       && (left_section != NULL || right_section != NULL)	\
	       && parameters->options().relocatable())			\
	gold_warning(_("binary " #NAME " applied to section "		\
		       "relative value"));				\
      if (IS_DIV && right == 0)						\
	{								\
	  gold_error(_(#NAME " by zero"));				\
	  return 0;							\
	}								\
      return left OPERATOR right;					\
    }									\
									\
    void								\
    print(FILE* f) const						\
    {									\
      fprintf(f, "(");							\
      this->left_print(f);						\
      fprintf(f, " %s ", #OPERATOR);					\
      this->right_print(f);						\
      fprintf(f, ")");							\
    }									\
  };									\
									\
  extern "C" Expression*						\
  script_exp_binary_ ## NAME(Expression* left, Expression* right)	\
  {									\
    return new Binary_ ## NAME(left, right);				\
  }

BINARY_EXPRESSION(mult, *, false, false, false, true)
BINARY_EXPRESSION(div, /, false, false, true, true)
BINARY_EXPRESSION(mod, %, false, false, true, true)
BINARY_EXPRESSION(add, +, true, true, false, true)
BINARY_EXPRESSION(sub, -, true, false, false, false)
BINARY_EXPRESSION(lshift, <<, false, false, false, true)
BINARY_EXPRESSION(rshift, >>, false, false, false, true)
BINARY_EXPRESSION(eq, ==, false, false, false, false)
BINARY_EXPRESSION(ne, !=, false, false, false, false)
BINARY_EXPRESSION(le, <=, false, false, false, false)
BINARY_EXPRESSION(ge, >=, false, false, false, false)
BINARY_EXPRESSION(lt, <, false, false, false, false)
BINARY_EXPRESSION(gt, >, false, false, false, false)
BINARY_EXPRESSION(bitwise_and, &, true, true, false, true)
BINARY_EXPRESSION(bitwise_xor, ^, true, true, false, true)
BINARY_EXPRESSION(bitwise_or, |, true, true, false, true)
BINARY_EXPRESSION(logical_and, &&, false, false, false, true)
BINARY_EXPRESSION(logical_or, ||, false, false, false, true)

// A trinary expression.

class Trinary_expression : public Expression
{
 public:
  Trinary_expression(Expression* arg1, Expression* arg2, Expression* arg3)
    : arg1_(arg1), arg2_(arg2), arg3_(arg3)
  { }

  ~Trinary_expression()
  {
    delete this->arg1_;
    delete this->arg2_;
    delete this->arg3_;
  }

 protected:
  uint64_t
  arg1_value(const Expression_eval_info* eei,
	     Output_section** section_pointer) const
  {
    return this->arg1_->eval_maybe_dot(eei->symtab, eei->layout,
				       eei->check_assertions,
				       eei->is_dot_available,
				       eei->dot_value,
				       eei->dot_section,
				       section_pointer,
				       NULL,
				       false);
  }

  uint64_t
  arg2_value(const Expression_eval_info* eei,
	     Output_section** section_pointer,
	     uint64_t* alignment_pointer) const
  {
    return this->arg1_->eval_maybe_dot(eei->symtab, eei->layout,
				       eei->check_assertions,
				       eei->is_dot_available,
				       eei->dot_value,
				       eei->dot_section,
				       section_pointer,
				       alignment_pointer,
				       false);
  }

  uint64_t
  arg3_value(const Expression_eval_info* eei,
	     Output_section** section_pointer,
	     uint64_t* alignment_pointer) const
  {
    return this->arg1_->eval_maybe_dot(eei->symtab, eei->layout,
				       eei->check_assertions,
				       eei->is_dot_available,
				       eei->dot_value,
				       eei->dot_section,
				       section_pointer,
				       alignment_pointer,
				       false);
  }

  void
  arg1_print(FILE* f) const
  { this->arg1_->print(f); }

  void
  arg2_print(FILE* f) const
  { this->arg2_->print(f); }

  void
  arg3_print(FILE* f) const
  { this->arg3_->print(f); }

 private:
  Expression* arg1_;
  Expression* arg2_;
  Expression* arg3_;
};

// The conditional operator.

class Trinary_cond : public Trinary_expression
{
 public:
  Trinary_cond(Expression* arg1, Expression* arg2, Expression* arg3)
    : Trinary_expression(arg1, arg2, arg3)
  { }

  uint64_t
  value(const Expression_eval_info* eei)
  {
    Output_section* arg1_section;
    uint64_t arg1 = this->arg1_value(eei, &arg1_section);
    return (arg1
	    ? this->arg2_value(eei, eei->result_section_pointer,
			       eei->result_alignment_pointer)
	    : this->arg3_value(eei, eei->result_section_pointer,
			       eei->result_alignment_pointer));
  }

  void
  print(FILE* f) const
  {
    fprintf(f, "(");
    this->arg1_print(f);
    fprintf(f, " ? ");
    this->arg2_print(f);
    fprintf(f, " : ");
    this->arg3_print(f);
    fprintf(f, ")");
  }
};

extern "C" Expression*
script_exp_trinary_cond(Expression* arg1, Expression* arg2, Expression* arg3)
{
  return new Trinary_cond(arg1, arg2, arg3);
}

// Max function.

class Max_expression : public Binary_expression
{
 public:
  Max_expression(Expression* left, Expression* right)
    : Binary_expression(left, right)
  { }

  uint64_t
  value(const Expression_eval_info* eei)
  {
    Output_section* left_section;
    uint64_t left_alignment;
    uint64_t left = this->left_value(eei, &left_section, &left_alignment);
    Output_section* right_section;
    uint64_t right_alignment;
    uint64_t right = this->right_value(eei, &right_section, &right_alignment);
    if (left_section == right_section)
      {
	if (eei->result_section_pointer != NULL)
	  *eei->result_section_pointer = left_section;
      }
    else if ((left_section != NULL || right_section != NULL)
	     && parameters->options().relocatable())
      gold_warning(_("max applied to section relative value"));
    if (eei->result_alignment_pointer != NULL)
      {
	uint64_t ra = *eei->result_alignment_pointer;
	if (left > right)
	  ra = std::max(ra, left_alignment);
	else if (right > left)
	  ra = std::max(ra, right_alignment);
	else
	  ra = std::max(ra, std::max(left_alignment, right_alignment));
	*eei->result_alignment_pointer = ra;
      }
    return std::max(left, right);
  }

  void
  print(FILE* f) const
  { this->print_function(f, "MAX"); }
};

extern "C" Expression*
script_exp_function_max(Expression* left, Expression* right)
{
  return new Max_expression(left, right);
}

// Min function.

class Min_expression : public Binary_expression
{
 public:
  Min_expression(Expression* left, Expression* right)
    : Binary_expression(left, right)
  { }

  uint64_t
  value(const Expression_eval_info* eei)
  {
    Output_section* left_section;
    uint64_t left_alignment;
    uint64_t left = this->left_value(eei, &left_section, &left_alignment);
    Output_section* right_section;
    uint64_t right_alignment;
    uint64_t right = this->right_value(eei, &right_section, &right_alignment);
    if (left_section == right_section)
      {
	if (eei->result_section_pointer != NULL)
	  *eei->result_section_pointer = left_section;
      }
    else if ((left_section != NULL || right_section != NULL)
	     && parameters->options().relocatable())
      gold_warning(_("min applied to section relative value"));
    if (eei->result_alignment_pointer != NULL)
      {
	uint64_t ra = *eei->result_alignment_pointer;
	if (left < right)
	  ra = std::max(ra, left_alignment);
	else if (right < left)
	  ra = std::max(ra, right_alignment);
	else
	  ra = std::max(ra, std::max(left_alignment, right_alignment));
	*eei->result_alignment_pointer = ra;
      }
    return std::min(left, right);
  }

  void
  print(FILE* f) const
  { this->print_function(f, "MIN"); }
};

extern "C" Expression*
script_exp_function_min(Expression* left, Expression* right)
{
  return new Min_expression(left, right);
}

// Class Section_expression.  This is a parent class used for
// functions which take the name of an output section.

class Section_expression : public Expression
{
 public:
  Section_expression(const char* section_name, size_t section_name_len)
    : section_name_(section_name, section_name_len)
  { }

  uint64_t
  value(const Expression_eval_info*);

  void
  print(FILE* f) const
  { fprintf(f, "%s(%s)", this->function_name(), this->section_name_.c_str()); }

 protected:
  // The child class must implement this.
  virtual uint64_t
  value_from_output_section(const Expression_eval_info*,
			    Output_section*) = 0;

  // The child class must implement this.
  virtual uint64_t
  value_from_script_output_section(uint64_t address, uint64_t load_address,
                                   uint64_t addralign, uint64_t size) = 0;

  // The child class must implement this.
  virtual const char*
  function_name() const = 0;

 private:
  std::string section_name_;
};

uint64_t
Section_expression::value(const Expression_eval_info* eei)
{
  const char* section_name = this->section_name_.c_str();
  Output_section* os = eei->layout->find_output_section(section_name);
  if (os != NULL)
    return this->value_from_output_section(eei, os);

  uint64_t address;
  uint64_t load_address;
  uint64_t addralign;
  uint64_t size;
  const Script_options* ss = eei->layout->script_options();
  if (ss->saw_sections_clause())
    {
      if (ss->script_sections()->get_output_section_info(section_name,
                                                         &address,
                                                         &load_address,
                                                         &addralign,
                                                         &size))
        return this->value_from_script_output_section(address, load_address,
                                                      addralign, size);
    }

  gold_error("%s called on nonexistent output section '%s'",
             this->function_name(), section_name);
  return 0;
}

// ABSOLUTE function.

class Absolute_expression : public Unary_expression
{
 public:
  Absolute_expression(Expression* arg)
    : Unary_expression(arg)
  { }

  uint64_t
  value(const Expression_eval_info* eei)
  {
    uint64_t ret = this->arg_value(eei, NULL);
    // Force the value to be absolute.
    if (eei->result_section_pointer != NULL)
      *eei->result_section_pointer = NULL;
    return ret;
  }

  void
  print(FILE* f) const
  {
    fprintf(f, "ABSOLUTE(");
    this->arg_print(f);
    fprintf(f, ")");
  }
};

extern "C" Expression*
script_exp_function_absolute(Expression* arg)
{
  return new Absolute_expression(arg);
}

// ALIGN function.

class Align_expression : public Binary_expression
{
 public:
  Align_expression(Expression* left, Expression* right)
    : Binary_expression(left, right)
  { }

  uint64_t
  value(const Expression_eval_info* eei)
  {
    Output_section* align_section;
    uint64_t align = this->right_value(eei, &align_section, NULL);
    if (align_section != NULL
	&& parameters->options().relocatable())
      gold_warning(_("aligning to section relative value"));

    if (eei->result_alignment_pointer != NULL
	&& align > *eei->result_alignment_pointer)
      {
	uint64_t a = align;
	while ((a & (a - 1)) != 0)
	  a &= a - 1;
	*eei->result_alignment_pointer = a;
      }

    uint64_t value = this->left_value(eei, eei->result_section_pointer, NULL);
    if (align <= 1)
      return value;
    return ((value + align - 1) / align) * align;
  }

  void
  print(FILE* f) const
  { this->print_function(f, "ALIGN"); }
};

extern "C" Expression*
script_exp_function_align(Expression* left, Expression* right)
{
  return new Align_expression(left, right);
}

// ASSERT function.

class Assert_expression : public Unary_expression
{
 public:
  Assert_expression(Expression* arg, const char* message, size_t length)
    : Unary_expression(arg), message_(message, length)
  { }

  uint64_t
  value(const Expression_eval_info* eei)
  {
    uint64_t value = this->arg_value(eei, eei->result_section_pointer);
    if (!value && eei->check_assertions)
      gold_error("%s", this->message_.c_str());
    return value;
  }

  void
  print(FILE* f) const
  {
    fprintf(f, "ASSERT(");
    this->arg_print(f);
    fprintf(f, ", %s)", this->message_.c_str());
  }

 private:
  std::string message_;
};

extern "C" Expression*
script_exp_function_assert(Expression* expr, const char* message,
			   size_t length)
{
  return new Assert_expression(expr, message, length);
}

// ADDR function.

class Addr_expression : public Section_expression
{
 public:
  Addr_expression(const char* section_name, size_t section_name_len)
    : Section_expression(section_name, section_name_len)
  { }

 protected:
  uint64_t
  value_from_output_section(const Expression_eval_info* eei,
			    Output_section* os)
  {
    if (eei->result_section_pointer != NULL)
      *eei->result_section_pointer = os;
    return os->address();
  }

  uint64_t
  value_from_script_output_section(uint64_t address, uint64_t, uint64_t,
                                   uint64_t)
  { return address; }

  const char*
  function_name() const
  { return "ADDR"; }
};

extern "C" Expression*
script_exp_function_addr(const char* section_name, size_t section_name_len)
{
  return new Addr_expression(section_name, section_name_len);
}

// ALIGNOF.

class Alignof_expression : public Section_expression
{
 public:
  Alignof_expression(const char* section_name, size_t section_name_len)
    : Section_expression(section_name, section_name_len)
  { }

 protected:
  uint64_t
  value_from_output_section(const Expression_eval_info*,
			    Output_section* os)
  { return os->addralign(); }

  uint64_t
  value_from_script_output_section(uint64_t, uint64_t, uint64_t addralign,
                                   uint64_t)
  { return addralign; }

  const char*
  function_name() const
  { return "ALIGNOF"; }
};

extern "C" Expression*
script_exp_function_alignof(const char* section_name, size_t section_name_len)
{
  return new Alignof_expression(section_name, section_name_len);
}

// CONSTANT.  It would be nice if we could simply evaluate this
// immediately and return an Integer_expression, but unfortunately we
// don't know the target.

class Constant_expression : public Expression
{
 public:
  Constant_expression(const char* name, size_t length);

  uint64_t
  value(const Expression_eval_info*);

  void
  print(FILE* f) const;

 private:
  enum Constant_function
  {
    CONSTANT_MAXPAGESIZE,
    CONSTANT_COMMONPAGESIZE
  };

  Constant_function function_;
};

Constant_expression::Constant_expression(const char* name, size_t length)
{
  if (length == 11 && strncmp(name, "MAXPAGESIZE", length) == 0)
    this->function_ = CONSTANT_MAXPAGESIZE;
  else if (length == 14 && strncmp(name, "COMMONPAGESIZE", length) == 0)
    this->function_ = CONSTANT_COMMONPAGESIZE;
  else
    {
      std::string s(name, length);
      gold_error(_("unknown constant %s"), s.c_str());
      this->function_ = CONSTANT_MAXPAGESIZE;
    }
}

uint64_t
Constant_expression::value(const Expression_eval_info*)
{
  switch (this->function_)
    {
    case CONSTANT_MAXPAGESIZE:
      return parameters->target().abi_pagesize();
    case CONSTANT_COMMONPAGESIZE:
      return parameters->target().common_pagesize();
    default:
      gold_unreachable();
    }
}

void
Constant_expression::print(FILE* f) const
{
  const char* name;
  switch (this->function_)
    {
    case CONSTANT_MAXPAGESIZE:
      name = "MAXPAGESIZE";
      break;
    case CONSTANT_COMMONPAGESIZE:
      name = "COMMONPAGESIZE";
      break;
    default:
      gold_unreachable();
    }
  fprintf(f, "CONSTANT(%s)", name);
}
  
extern "C" Expression*
script_exp_function_constant(const char* name, size_t length)
{
  return new Constant_expression(name, length);
}

// DATA_SEGMENT_ALIGN.  FIXME: we don't implement this; we always fall
// back to the general case.

extern "C" Expression*
script_exp_function_data_segment_align(Expression* left, Expression*)
{
  Expression* e1 = script_exp_function_align(script_exp_string(".", 1), left);
  Expression* e2 = script_exp_binary_sub(left, script_exp_integer(1));
  Expression* e3 = script_exp_binary_bitwise_and(script_exp_string(".", 1),
						 e2);
  return script_exp_binary_add(e1, e3);
}

// DATA_SEGMENT_RELRO.  FIXME: This is not implemented.

extern "C" Expression*
script_exp_function_data_segment_relro_end(Expression*, Expression* right)
{
  return right;
}

// DATA_SEGMENT_END.  FIXME: This is not implemented.

extern "C" Expression*
script_exp_function_data_segment_end(Expression* val)
{
  return val;
}

// DEFINED function.

class Defined_expression : public Expression
{
 public:
  Defined_expression(const char* symbol_name, size_t symbol_name_len)
    : symbol_name_(symbol_name, symbol_name_len)
  { }

  uint64_t
  value(const Expression_eval_info* eei)
  {
    Symbol* sym = eei->symtab->lookup(this->symbol_name_.c_str());
    return sym != NULL && sym->is_defined();
  }

  void
  print(FILE* f) const
  { fprintf(f, "DEFINED(%s)", this->symbol_name_.c_str()); }

 private:
  std::string symbol_name_;
};

extern "C" Expression*
script_exp_function_defined(const char* symbol_name, size_t symbol_name_len)
{
  return new Defined_expression(symbol_name, symbol_name_len);
}

// LOADADDR function

class Loadaddr_expression : public Section_expression
{
 public:
  Loadaddr_expression(const char* section_name, size_t section_name_len)
    : Section_expression(section_name, section_name_len)
  { }

 protected:
  uint64_t
  value_from_output_section(const Expression_eval_info* eei,
			    Output_section* os)
  {
    if (os->has_load_address())
      return os->load_address();
    else
      {
	if (eei->result_section_pointer != NULL)
	  *eei->result_section_pointer = os;
	return os->address();
      }
  }

  uint64_t
  value_from_script_output_section(uint64_t, uint64_t load_address, uint64_t,
                                   uint64_t)
  { return load_address; }

  const char*
  function_name() const
  { return "LOADADDR"; }
};

extern "C" Expression*
script_exp_function_loadaddr(const char* section_name, size_t section_name_len)
{
  return new Loadaddr_expression(section_name, section_name_len);
}

// SIZEOF function

class Sizeof_expression : public Section_expression
{
 public:
  Sizeof_expression(const char* section_name, size_t section_name_len)
    : Section_expression(section_name, section_name_len)
  { }

 protected:
  uint64_t
  value_from_output_section(const Expression_eval_info*,
			    Output_section* os)
  {
    // We can not use data_size here, as the size of the section may
    // not have been finalized.  Instead we get whatever the current
    // size is.  This will work correctly for backward references in
    // linker scripts.
    return os->current_data_size();
  }

  uint64_t
  value_from_script_output_section(uint64_t, uint64_t, uint64_t,
                                   uint64_t size)
  { return size; }

  const char*
  function_name() const
  { return "SIZEOF"; }
};

extern "C" Expression*
script_exp_function_sizeof(const char* section_name, size_t section_name_len)
{
  return new Sizeof_expression(section_name, section_name_len);
}

// SIZEOF_HEADERS.

class Sizeof_headers_expression : public Expression
{
 public:
  Sizeof_headers_expression()
  { }

  uint64_t
  value(const Expression_eval_info*);

  void
  print(FILE* f) const
  { fprintf(f, "SIZEOF_HEADERS"); }
};

uint64_t
Sizeof_headers_expression::value(const Expression_eval_info* eei)
{
  unsigned int ehdr_size;
  unsigned int phdr_size;
  if (parameters->target().get_size() == 32)
    {
      ehdr_size = elfcpp::Elf_sizes<32>::ehdr_size;
      phdr_size = elfcpp::Elf_sizes<32>::phdr_size;
    }
  else if (parameters->target().get_size() == 64)
    {
      ehdr_size = elfcpp::Elf_sizes<64>::ehdr_size;
      phdr_size = elfcpp::Elf_sizes<64>::phdr_size;
    }
  else
    gold_unreachable();

  return ehdr_size + phdr_size * eei->layout->expected_segment_count();
}

extern "C" Expression*
script_exp_function_sizeof_headers()
{
  return new Sizeof_headers_expression();
}

// SEGMENT_START.

class Segment_start_expression : public Unary_expression
{
 public:
  Segment_start_expression(const char* segment_name, size_t segment_name_len,
			   Expression* default_value)
    : Unary_expression(default_value),
      segment_name_(segment_name, segment_name_len)
  { }

  uint64_t
  value(const Expression_eval_info*);

  void
  print(FILE* f) const
  {
    fprintf(f, "SEGMENT_START(\"%s\", ", this->segment_name_.c_str());
    this->arg_print(f);
    fprintf(f, ")");
  }

 private:
  std::string segment_name_;
};

uint64_t
Segment_start_expression::value(const Expression_eval_info* eei)
{
  // Check for command line overrides.
  if (parameters->options().user_set_Ttext()
      && this->segment_name_ == ".text")
    return parameters->options().Ttext();
  else if (parameters->options().user_set_Tdata()
	   && this->segment_name_ == ".data")
    return parameters->options().Tdata();
  else if (parameters->options().user_set_Tbss()
	   && this->segment_name_ == ".bss")
    return parameters->options().Tbss();
  else
    {
      uint64_t ret = this->arg_value(eei, NULL);
      // Force the value to be absolute.
      if (eei->result_section_pointer != NULL)
        *eei->result_section_pointer = NULL;
      return ret;
    }
}

extern "C" Expression*
script_exp_function_segment_start(const char* segment_name,
				  size_t segment_name_len,
				  Expression* default_value)
{
  return new Segment_start_expression(segment_name, segment_name_len,
				      default_value);
}

} // End namespace gold.
@


1.19
log
@	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.18
log
@2010-11-18  Doug Kwan  <dougkwan@@google.com>

	* expression.cc (BINARY_EXPRESSION): Initialize left_alignment
	and right_alignment to be zero.  Store result alignment only if it is
	greater than existing alignment.
@
text
@d80 1
a80 1
			      false, 0, NULL, NULL, NULL);
d90 2
a91 1
			  uint64_t* result_alignment_pointer)
d95 2
a96 1
			      result_alignment_pointer);
d107 2
a108 1
			   uint64_t* result_alignment_pointer)
d119 1
a119 1
  // if we find a section relative reference.
d126 11
a136 1
  return this->value(&eei);
d273 2
a274 1
				      eei->result_alignment_pointer);
d353 2
a354 1
				       alignment_pointer);
d368 2
a369 1
					alignment_pointer);
d519 2
a520 1
				       NULL);
d534 2
a535 1
				       alignment_pointer);
d549 2
a550 1
				       alignment_pointer);
@


1.18.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d80 1
a80 1
			      false, 0, NULL, NULL, NULL, false);
d90 1
a90 2
			  uint64_t* result_alignment_pointer,
			  bool is_section_dot_assignment)
d94 1
a94 2
			      result_alignment_pointer,
			      is_section_dot_assignment);
d105 1
a105 2
			   uint64_t* result_alignment_pointer,
			   bool is_section_dot_assignment)
d116 1
a116 1
  // if we find a section-relative reference.
d123 1
a123 11
  uint64_t val = this->value(&eei);

  // If this is an assignment to dot within a section, and the value
  // is absolute, treat it as a section-relative offset.
  if (is_section_dot_assignment && *result_section_pointer == NULL)
    {
      gold_assert(dot_section != NULL);
      val += dot_section->address();
      *result_section_pointer = dot_section;
    }
  return val;
d260 1
a260 2
				      eei->result_alignment_pointer,
				      false);
d339 1
a339 2
				       alignment_pointer,
				       false);
d353 1
a353 2
					alignment_pointer,
					false);
d503 1
a503 2
				       NULL,
				       false);
d517 1
a517 2
				       alignment_pointer,
				       false);
d531 1
a531 2
				       alignment_pointer,
				       false);
@


1.17
log
@        * expression.cc (eval): Replace dummy argument with NULL.
        (eval_maybe_dot): Check for a NULL result section pointer.
        (Symbol_expression::value): Likewise.
        (Dot_expression::value): Likewise.
        (BINARY_EXPRESSION): Likewise.
        (Max_expression::value): Likewise.
        (Min_expression::value): Likewise.
        (Absolute_expression::value): Likewise.
        (Addr_expression::value_from_output_section): Likewise.
        (Loaddddr_expression::value_from_output_section): Likewise.
        (Segment_start_expression::value): Likewise.
        * script-sections.cc
        (Sections_elememt_dot_assignment::finalize_symbols): Replace dummy
        argument with NULL.
        (Sections_elememt_dot_assignment::set_section_addresses):
        Likewise.
        (Output_data_expression::do_write_to_buffer): Likewise.
        (Output_section_definition::finalize_symbols): Likewise.
        (Output_section_definition::set_section_addresses): Likewise.
@
text
@d402 1
a402 1
      uint64_t left_alignment;						\
d406 1
a406 1
      uint64_t right_alignment;						\
d413 2
a414 1
	  if (eei->result_alignment_pointer != NULL)			\
d423 3
a425 2
	  if (eei->result_alignment_pointer != NULL)			\
	    *eei->result_alignment_pointer = right_alignment;		\
@


1.17.2.1
log
@Merge from trunk:

Modified files:
	gold           : ChangeLog expression.cc

Log message:
	2010-11-18  Doug Kwan  <dougkwan@@google.com>

	* expression.cc (BINARY_EXPRESSION): Initialize left_alignment
	and right_alignment to be zero.  Store result alignment only if it is
	greater than existing alignment.
@
text
@d402 1
a402 1
      uint64_t left_alignment = 0;					\
d406 1
a406 1
      uint64_t right_alignment = 0;					\
d413 1
a413 2
	  if (eei->result_alignment_pointer != NULL			\
	      && right_alignment > *eei->result_alignment_pointer)	\
d422 2
a423 3
	  if (eei->result_alignment_pointer != NULL			\
	      && left_alignment > *eei->result_alignment_pointer)	\
	    *eei->result_alignment_pointer = left_alignment;		\
@


1.16
log
@        * README: Remove claim that MEMORY is not supported.
        * expression.cc (script_exp_function_origin)
        (script_exp_function_length): Move from here to ...
        * script.cc: ... here.
        (script_set_section_region, script_add_memory)
        (script_parse_memory_attr, script_include_directive): New
        functions.
        * script-sections.cc
        (class Memory_region): New class.
        (class Output_section_definition): Add set_memory_region,
        set_section_vma, set_section_lma and get_section_name methods.
        (class Script_Sections): Add add_memory_region,
        find_memory_region, find_memory_region_origin,
        find_memory_region_length and set_memory_region methods.
        Have set_section_addresses method walk the list of set memory
        regions.
        Extend the print methos to display memory regions.
        * script-sections.h: Add prototypes for new methods.
        Add enum for MEMORY region attributes.
        * yyscript.y: Add support for parsing MEMORY regions.
        * script-c.h: Add prototypes for new functions.
        * testsuite/Makefile.am: Add test of MEMORY region functionality.
        * testsuite/Makefile.in: Regenerate.
        * testsuite/memory_test.sh: New script.
        * testsuite/memory_test.s: New assembler source file.
        * testsuite/memory_test.t: New linker script.
@
text
@a78 1
  Output_section* dummy;
d80 1
a80 1
			      false, 0, NULL, &dummy, NULL);
d117 2
a118 1
  *result_section_pointer = NULL;
d184 2
a185 1
  *eei->result_section_pointer = sym->output_section();
d221 2
a222 1
  *eei->result_section_pointer = eei->dot_section;
d411 2
a412 1
	  *eei->result_section_pointer = right_section;			\
d420 2
a421 1
	  *eei->result_section_pointer = left_section;			\
d609 4
a612 1
      *eei->result_section_pointer = left_section;
d660 4
a663 1
      *eei->result_section_pointer = left_section;
d769 1
a769 2
    Output_section* dummy;
    uint64_t ret = this->arg_value(eei, &dummy);
d771 2
a772 1
    *eei->result_section_pointer = NULL;
d886 2
a887 1
    *eei->result_section_pointer = os;
d1092 2
a1093 1
	*eei->result_section_pointer = os;
d1235 1
a1235 2
      Output_section* dummy;
      uint64_t ret = this->arg_value(eei, &dummy);
d1237 2
a1238 1
      *eei->result_section_pointer = NULL;
@


1.15
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@a1239 15
// Functions for memory regions.  These can not be implemented unless
// and until we implement memory regions.

extern "C" Expression*
script_exp_function_origin(const char*, size_t)
{
  gold_fatal(_("ORIGIN not implemented"));
}

extern "C" Expression*
script_exp_function_length(const char*, size_t)
{
  gold_fatal(_("LENGTH not implemented"));
}

@


1.14
log
@	* expression.cc (Expression::Expression_eval_info): Add
	result_alignment_pointer field.
	(Expression::eval_with_dot): Add result_alignment_pointer
	parameter.  Change all callers.
	(Expression::eval_maybe_dot): Likewise.
	(class Binary_expression): Add alignment_pointer parameter to
	left_value and right_value.  Change all callers.
	(BINARY_EXPRESSION): Set result alignment.
	(class Trinary_expression): Add alignment_pointer parameter to
	arg2_value and arg3_value.  Change all callers.
	(Trinary_cond::value): Set result alignment.
	(Max_expression::value, Min_expression::value): Likewise.
	(Align_expression::value): Likewise.
	* script-sections.cc (class Sections_element): Add dot_alignment
	parameter to set_section_addresses virtual function.  Update
	instantiations.
	(class Output_section_element): Likewise.
	(Script_sections::create_segments): Add dot_alignment parameter.
	Change all callers.
	(Script_sections::create_segments_from_phdrs_clause): Likewise.
	(Script_sections::set_phdrs_clause_addresses): Likewise.
	* script-sections.h: Update declarations.
	* script.h: Update declarations.
	* output.h (Output_segment::set_minimum_p_align): Don't decrease
	min_p_align.
	* testsuite/script_test_3.t: Set large alignment.
	* testsuite/script_test_3.sh: Make sure that at least one LOAD
	segment has expected alignment.
@
text
@d365 1
a365 1
  print_function(FILE* f, const char *function_name) const
@


1.13
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d69 2
d81 1
a81 1
			      false, 0, NULL, &dummy);
d90 2
a91 1
			  Output_section** result_section_pointer)
d94 2
a95 1
			      dot_value, dot_section, result_section_pointer);
d105 2
a106 1
			   Output_section** result_section_pointer)
d121 2
d257 2
a258 1
				      arg_section_pointer);
d328 2
a329 1
	     Output_section** section_pointer) const
d336 2
a337 1
				       section_pointer);
d342 2
a343 1
	      Output_section** section_pointer) const
d350 2
a351 1
					section_pointer);
d400 3
a402 1
      uint64_t left = this->left_value(eei, &left_section);		\
d404 3
a406 1
      uint64_t right = this->right_value(eei, &right_section);		\
d408 5
a412 1
	*eei->result_section_pointer = right_section;			\
d416 5
a420 1
	*eei->result_section_pointer = left_section;			\
d496 2
a497 1
				       section_pointer);
d502 2
a503 1
	     Output_section** section_pointer) const
d510 2
a511 1
				       section_pointer);
d516 2
a517 1
	     Output_section** section_pointer) const
d524 2
a525 1
				       section_pointer);
d561 4
a564 2
	    ? this->arg2_value(eei, eei->result_section_pointer)
	    : this->arg3_value(eei, eei->result_section_pointer));
d599 2
a600 1
    uint64_t left = this->left_value(eei, &left_section);
d602 2
a603 1
    uint64_t right = this->right_value(eei, &right_section);
d609 11
d647 2
a648 1
    uint64_t left = this->left_value(eei, &left_section);
d650 2
a651 1
    uint64_t right = this->right_value(eei, &right_section);
d657 11
d794 1
a794 1
    uint64_t align = this->right_value(eei, &align_section);
d799 10
a808 1
    uint64_t value = this->left_value(eei, eei->result_section_pointer);
@


1.12
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d742 1
a742 1
    uint64_t val = this->left_value(eei, eei->result_section_pointer);
d744 2
a745 2
      return val;
    return ((val + align - 1) / align) * align;
d771 2
a772 2
    uint64_t val = this->arg_value(eei, eei->result_section_pointer);
    if (!val && eei->check_assertions)
d774 1
a774 1
    return val;
@


1.11
log
@2009-10-16  Doug Kwan  <dougkwan@@google.com>

	* expression.cc (class Segment_start_expression): New class definition.
	(Segment_start_expression::value): New method definition.
	(script_exp_function_segment_start): Return a new
	Segment_start_expression.
	* gold/script-c.h (script_saw_segment_start_expression): New function
	prototype.
	* script-sections.cc (Script_sections::Script_sections): Initialize
	SAW_SEGMENT_START_EXPRESSION_ to false.
	(Script_sections::set_section_addresses): Use -Ttext, -Tdata
	and -Tbbs options to specify section addresses if given in
	command line and no SEGMENT_START expression is seen in a script.
	* script-sections.h (Script_sections::saw_segment_start_expression,
	Script_sections::set_saw_segment_start_expression): New method
	definition.
	(Script_sections::saw_segment_start_expression_): New data member
	declaration.
	* script.cc (script_saw_segment_start_expression): New function.
	* yyscript.y (SEGMENT_START): Call script_saw_segment_start_expression.
	* testsuite/Makefile.am (check_SCRIPTS): Add script_test_6.sh,
	script_test_7.sh and script_test_8.sh.
	(check_DATA): Add script_test_6.stdout, script_test_7.stdout and
	script_test_8.stdout.
	(MOSTLYCLEANFILES): Add script_test_6, script_test_7 and script_test_8.
	(script_test_6, script_test_6.stdout, script_test_7,
	script_test_7.stdout, script_test_8, script_test_8.stdout): New rules.
	* Makefile.in: Regenerate.
	* testsuite/script_test_6.sh: New file.
	* testsuite/script_test_6.t: Same.
	* testsuite/script_test_7.sh: Same.
	* testsuite/script_test_7.t: Same.
	* testsuite/script_test_8.sh: Same.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d742 1
a742 1
    uint64_t value = this->left_value(eei, eei->result_section_pointer);
d744 2
a745 2
      return value;
    return ((value + align - 1) / align) * align;
d771 2
a772 2
    uint64_t value = this->arg_value(eei, eei->result_section_pointer);
    if (!value && eei->check_assertions)
d774 1
a774 1
    return value;
@


1.10
log
@Permit scripts to refer to the addresses of output sections which were
not created.
@
text
@d1116 48
a1163 6
// In the GNU linker SEGMENT_START basically returns the value for
// -Ttext, -Tdata, or -Tbss.  We could implement this by copying the
// values from General_options to Parameters.  But I doubt that
// anybody actually uses it.  The point of it for the GNU linker was
// because -Ttext set the address of the .text section rather than the
// text segment.  In gold -Ttext sets the text segment address anyhow.
d1166 3
a1168 1
script_exp_function_segment_start(const char*, size_t, Expression*)
d1170 2
a1171 1
  gold_fatal(_("SEGMENT_START not implemented"));
@


1.9
log
@Don't check assertions until symbols are finalized.  Create an output
section if the script uses a data statement with no input sections.
Don't create a loadable segment for the headers if there is no room.
@
text
@d649 5
d666 9
a674 1
  if (os == NULL)
d676 7
a682 3
      gold_error("%s called on nonexistent output section '%s'",
		 this->function_name(), section_name);
      return 0;
d685 3
a687 1
  return this->value_from_output_section(eei, os);
d814 5
d845 5
d1020 5
d1056 5
@


1.8
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d57 2
d74 2
a75 1
Expression::eval(const Symbol_table* symtab, const Layout* layout)
d78 2
a79 1
  return this->eval_maybe_dot(symtab, layout, false, 0, NULL, &dummy);
d86 2
a87 1
			  uint64_t dot_value, Output_section* dot_section,
d90 2
a91 2
  return this->eval_maybe_dot(symtab, layout, true, dot_value, dot_section,
			      result_section_pointer);
d99 2
a100 2
			   bool is_dot_available, uint64_t dot_value,
			   Output_section* dot_section,
d106 1
d246 1
d323 1
d335 1
d468 1
d480 1
d492 1
d753 1
a753 1
    if (!value)
@


1.7
log
@Implement remaining linker script functions.
@
text
@d173 1
a173 1
  if (parameters->get_size() == 32)
d175 1
a175 1
  else if (parameters->get_size() == 64)
d270 1
a270 1
      if (arg_section != NULL && parameters->output_is_object())	\
d390 1
a390 1
	       && parameters->output_is_object())			\
d562 1
a562 1
	     && parameters->output_is_object())
d597 1
a597 1
	     && parameters->output_is_object())
d708 1
a708 1
	&& parameters->output_is_object())
d865 1
a865 1
      return parameters->target()->abi_pagesize();
d867 1
a867 1
      return parameters->target()->common_pagesize();
d1043 1
a1043 1
  if (parameters->get_size() == 32)
d1048 1
a1048 1
  else if (parameters->get_size() == 64)
@


1.6
log
@Implement LOADADDR and SIZEOF.
@
text
@d659 35
a693 1
// Align function.
d728 1
a728 1
// Assert function.
d776 1
a776 1
  value_from_output_section(const Expression_eval_info *eei,
d794 26
d926 30
d967 1
a967 1
  value_from_output_section(const Expression_eval_info *eei,
d1001 1
a1001 1
  value_from_output_section(const Expression_eval_info *,
d1065 6
a1070 1
// Functions.
d1073 1
a1073 1
script_exp_function_defined(const char*, size_t)
d1075 1
a1075 1
  gold_fatal(_("DEFINED not implemented"));
d1078 2
a1079 5
extern "C" Expression*
script_exp_function_alignof(const char*, size_t)
{
  gold_fatal(_("ALIGNOF not implemented"));
}
a1090 12
}

extern "C" Expression*
script_exp_function_absolute(Expression*)
{
  gold_fatal(_("ABSOLUTE not implemented"));
}

extern "C" Expression*
script_exp_function_segment_start(const char*, size_t, Expression*)
{
  gold_fatal(_("SEGMENT_START not implemented"));
@


1.5
log
@Track sections for expressions.
@
text
@d613 46
d731 1
a731 1
// Addr function.
d733 1
a733 1
class Addr_expression : public Expression
d737 1
a737 1
    : section_name_(section_name, section_name_len)
d740 1
d742 6
a747 5
  value(const Expression_eval_info*);

  void
  print(FILE* f) const
  { fprintf(f, "ADDR(%s)", this->section_name_.c_str()); }
d749 3
a751 2
 private:
  std::string section_name_;
a753 17
uint64_t
Addr_expression::value(const Expression_eval_info* eei)
{
  const char* section_name = this->section_name_.c_str();
  Output_section* os = eei->layout->find_output_section(section_name);
  if (os == NULL)
    {
      gold_error("ADDR called on nonexistent output section '%s'",
		 section_name);
      return 0;
    }

  *eei->result_section_pointer = os;

  return os->address();
}

d866 66
a986 12
}

extern "C" Expression*
script_exp_function_sizeof(const char*, size_t)
{
  gold_fatal(_("SIZEOF not implemented"));
}

extern "C" Expression*
script_exp_function_loadaddr(const char*, size_t)
{
  gold_fatal(_("LOADADDR not implemented"));
@


1.4
log
@Implement SIZEOF_HEADERS, section constraints, other minor linker
script items.
@
text
@a59 2
  // Whether the dot symbol currently has a value.
  bool dot_has_value;
d62 5
a66 3
  // Points to the IS_ABSOLUTE variable, which is set to false if the
  // expression uses a value which is not absolute.
  bool* is_absolute;
d74 2
a75 2
  bool dummy;
  return this->eval_maybe_dot(symtab, layout, false, false, 0, &dummy);
d82 2
a83 2
			  bool dot_has_value, uint64_t dot_value,
			  bool* is_absolute)
d85 2
a86 2
  return this->eval_maybe_dot(symtab, layout, true, dot_has_value, dot_value,
			      is_absolute);
d94 3
a96 2
			   bool is_dot_available, bool dot_has_value,
			   uint64_t dot_value, bool* is_absolute)
a101 1
  eei.dot_has_value = dot_has_value;
d103 1
d105 4
a108 4
  // We assume the value is absolute, and only set this to false if we
  // find a section relative reference.
  *is_absolute = true;
  eei.is_absolute = is_absolute;
d171 1
a171 7
  // If this symbol does not have an absolute value, then the whole
  // expression does not have an absolute value.  This is not strictly
  // accurate: the subtraction of two symbols in the same section is
  // absolute.  This is unlikely to matter in practice, as this value
  // is only used for error checking.
  if (!sym->value_is_absolute())
    *eei->is_absolute = false;
d207 1
a207 6
  else if (!eei->dot_has_value)
    {
      gold_error(_("invalid reference to dot symbol before "
		   "it has been given a value"));
      return 0;
    }
d236 9
a244 2
  arg_value(const Expression_eval_info* eei) const
  { return this->arg_->value(eei); }
d257 32
a288 25
#define UNARY_EXPRESSION(NAME, OPERATOR)			\
  class Unary_ ## NAME : public Unary_expression		\
  {								\
   public:							\
    Unary_ ## NAME(Expression* arg)				\
      : Unary_expression(arg)					\
    { }								\
    								\
    uint64_t							\
    value(const Expression_eval_info* eei)			\
    { return OPERATOR this->arg_value(eei); }			\
								\
    void							\
    print(FILE* f) const					\
    {								\
      fprintf(f, "(%s ", #OPERATOR);				\
      this->arg_print(f);					\
      fprintf(f, ")");						\
    }								\
  };								\
  								\
  extern "C" Expression*					\
  script_exp_unary_ ## NAME(Expression* arg)			\
  {								\
    return new Unary_ ## NAME(arg);				\
d312 9
a320 2
  left_value(const Expression_eval_info* eei) const
  { return this->left_->value(eei); }
d323 9
a331 2
  right_value(const Expression_eval_info* eei) const
  { return this->right_->value(eei); }
d359 7
a365 1
// capture the C operator.
d367 1
a367 1
#define BINARY_EXPRESSION(NAME, OPERATOR)				\
d378 21
a398 2
      return (this->left_value(eei)					\
	      OPERATOR this->right_value(eei));				\
d418 18
a435 18
BINARY_EXPRESSION(mult, *)
BINARY_EXPRESSION(div, /)
BINARY_EXPRESSION(mod, %)
BINARY_EXPRESSION(add, +)
BINARY_EXPRESSION(sub, -)
BINARY_EXPRESSION(lshift, <<)
BINARY_EXPRESSION(rshift, >>)
BINARY_EXPRESSION(eq, ==)
BINARY_EXPRESSION(ne, !=)
BINARY_EXPRESSION(le, <=)
BINARY_EXPRESSION(ge, >=)
BINARY_EXPRESSION(lt, <)
BINARY_EXPRESSION(gt, >)
BINARY_EXPRESSION(bitwise_and, &)
BINARY_EXPRESSION(bitwise_xor, ^)
BINARY_EXPRESSION(bitwise_or, |)
BINARY_EXPRESSION(logical_and, &&)
BINARY_EXPRESSION(logical_or, ||)
d455 9
a463 2
  arg1_value(const Expression_eval_info* eei) const
  { return this->arg1_->value(eei); }
d466 9
a474 2
  arg2_value(const Expression_eval_info* eei) const
  { return this->arg2_->value(eei); }
d477 9
a485 2
  arg3_value(const Expression_eval_info* eei) const
  { return this->arg3_->value(eei); }
d517 5
a521 3
    return (this->arg1_value(eei)
	    ? this->arg2_value(eei)
	    : this->arg3_value(eei));
d554 12
a565 1
  { return std::max(this->left_value(eei), this->right_value(eei)); }
d589 12
a600 1
  { return std::min(this->left_value(eei), this->right_value(eei)); }
d625 7
a631 2
    uint64_t align = this->right_value(eei);
    uint64_t value = this->left_value(eei);
d660 1
a660 1
    uint64_t value = this->arg_value(eei);
d717 1
a717 2
  // Note that the address of a section is an absolute address, and we
  // should not clear *EEI->IS_ABSOLUTE here.
@


1.3
log
@Fully implement the SECTIONS clause.
@
text
@d27 1
d636 52
a687 1
// Functions.
d689 18
d708 1
a708 1
script_exp_function_defined(const char*, size_t)
d710 1
a710 1
  gold_fatal(_("DEFINED not implemented"));
d713 3
d717 1
a717 1
script_exp_function_sizeof_headers()
d719 5
a723 1
  gold_fatal(_("SIZEOF_HEADERS not implemented"));
d726 2
d729 1
a729 1
script_exp_function_alignof(const char*, size_t)
d731 1
a731 1
  gold_fatal(_("ALIGNOF not implemented"));
d734 2
d737 23
a759 1
script_exp_function_sizeof(const char*, size_t)
d761 16
a776 1
  gold_fatal(_("SIZEOF not implemented"));
d780 1
a780 1
script_exp_function_loadaddr(const char*, size_t)
d782 1
a782 1
  gold_fatal(_("LOADADDR not implemented"));
d785 2
d788 1
a788 1
script_exp_function_origin(const char*, size_t)
d790 1
a790 1
  gold_fatal(_("ORIGIN not implemented"));
d794 1
a794 1
script_exp_function_length(const char*, size_t)
d796 1
a796 1
  gold_fatal(_("LENGTH not implemented"));
d800 1
a800 1
script_exp_function_constant(const char*, size_t)
d802 1
a802 1
  gold_fatal(_("CONSTANT not implemented"));
d806 1
a806 1
script_exp_function_absolute(Expression*)
d808 1
a808 1
  gold_fatal(_("ABSOLUTE not implemented"));
d812 1
a812 1
script_exp_function_data_segment_align(Expression*, Expression*)
d814 1
a814 1
  gold_fatal(_("DATA_SEGMENT_ALIGN not implemented"));
d818 1
a818 1
script_exp_function_data_segment_relro_end(Expression*, Expression*)
d820 1
a820 1
  gold_fatal(_("DATA_SEGMENT_RELRO_END not implemented"));
d824 1
a824 1
script_exp_function_data_segment_end(Expression*)
d826 1
a826 1
  gold_fatal(_("DATA_SEGMENT_END not implemented"));
@


1.2
log
@Parse a SECTIONS clause in a linker script.
@
text
@d39 7
d52 1
d54 1
d56 10
d73 23
d99 9
d169 8
d203 1
a203 1
Dot_expression::value(const Expression_eval_info*)
d205 13
a217 2
  gold_error("dot symbol unimplemented");
  return 0;
d622 4
@


1.1
log
@Support assignments and expressions in linker scripts.
@
text
@d30 1
d73 4
d99 4
d137 4
d178 4
d200 8
d244 20
d286 10
d352 12
d386 12
d418 4
d442 4
d472 4
d502 8
d521 40
a584 6
}

extern "C" Expression*
script_exp_function_addr(const char*, size_t)
{
  gold_fatal(_("ADDR not implemented"));
@

