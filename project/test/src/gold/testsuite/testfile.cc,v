head	1.25;
access;
symbols
	binutils-2_24-branch:1.25.0.2
	binutils-2_24-branchpoint:1.25
	binutils-2_21_1:1.18
	binutils-2_23_2:1.22.2.1
	binutils-2_23_1:1.22.2.1
	binutils-2_23:1.22
	binutils-2_23-branch:1.22.0.2
	binutils-2_23-branchpoint:1.22
	binutils-2_22_branch:1.21.0.4
	binutils-2_22:1.21
	binutils-2_22-branch:1.21.0.2
	binutils-2_22-branchpoint:1.21
	binutils-2_21:1.18
	binutils-2_21-branch:1.18.0.2
	binutils-2_21-branchpoint:1.18
	binutils-2_20_1:1.15.4.1
	binutils-2_20:1.15.4.1
	binutils-arc-20081103-branch:1.13.0.6
	binutils-arc-20081103-branchpoint:1.13
	binutils-2_20-branch:1.15.0.4
	binutils-2_20-branchpoint:1.15
	dje-cgen-play1-branch:1.15.0.2
	dje-cgen-play1-branchpoint:1.15
	arc-20081103-branch:1.13.0.4
	arc-20081103-branchpoint:1.13
	binutils-2_19_1:1.13
	binutils-2_19:1.13
	binutils-2_19-branch:1.13.0.2
	binutils-2_19-branchpoint:1.13
	binutils_latest_snapshot:1.25
	added-to-binutils:1.11;
locks; strict;
comment	@// @;


1.25
date	2013.07.30.21.26.53;	author ccoutant;	state Exp;
branches;
next	1.24;

1.24
date	2012.11.01.23.27.00;	author roland;	state Exp;
branches;
next	1.23;

1.23
date	2012.09.05.00.34.20;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2012.05.02.21.37.24;	author roland;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2011.06.28.23.12.31;	author ian;	state Exp;
branches;
next	1.20;

1.20
date	2011.06.28.21.15.42;	author ian;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.06.02.49.46;	author dougkwan;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.29.05.16.23;	author ian;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.06.22.58.27;	author ian;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.22.06.51.53;	author ian;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.09.00.48.13;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.25.21.39.01;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2008.02.13.02.44.50;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.06.08.13.50;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.20.21.21.24;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.23.05.05.48;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.16.22.38.36;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.03.00.34.49;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.21.06.25.35;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.30.23.52.50;	author iant;	state Exp;
branches;
next	;

1.22.2.1
date	2012.11.07.17.34.23;	author roland;	state Exp;
branches;
next	;

1.15.4.1
date	2009.10.16.05.51.18;	author ian;	state Exp;
branches;
next	;


desc
@@


1.25
log
@    gold/
    	* parameters.cc (Parameters::entry): Return target-specific entry
    	symbol name.
    	* target.h (Target::entry_symbol_name): New function.
    	(Target_info::entry_symbol_name): New data member.

    	* arm.cc (Target_arm::arm_info): Add entry_symbol_name.
    	(Target_arm_nacl::arm_nacl_info): Likewise.
    	* i386.cc (Target_i386::i386_info): Likewise.
    	(Target_i386_nacl::i386_nacl_info): Likewise.
    	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
    	* sparc.cc (Target_sparc::sparc_info): Likewise.
    	* tilegx.cc (Target_tilegx::tilegx_info): Likewise.
    	* x86_64.cc: (Target_x86_64::x86_64_info) Likewise.
    	(Target_x86_64_nacl::x86_64_nacl_info) Likewise.
    	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
@
text
@// testfile.cc -- Dummy ELF objects for testing purposes.

// Copyright 2006, 2007, 2008, 2009, 2011, 2012 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include "target.h"
#include "target-select.h"

#include "test.h"
#include "testfile.h"

namespace gold_testsuite
{

using namespace gold;

// A Target used for testing purposes.

template<int size, bool big_endian>
class Target_test : public Sized_target<size, big_endian>
{
 public:
  Target_test()
    : Sized_target<size, big_endian>(&test_target_info)
  { }

  void
  gc_process_relocs(Symbol_table*, Layout*,
		    Sized_relobj_file<size, big_endian>*,
		    unsigned int, unsigned int, const unsigned char*, size_t,
		    Output_section*, bool, size_t, const unsigned char*)
  { ERROR("call to Target_test::gc_process_relocs"); }

  void
  scan_relocs(Symbol_table*, Layout*, Sized_relobj_file<size, big_endian>*,
	      unsigned int, unsigned int, const unsigned char*, size_t,
	      Output_section*, bool, size_t, const unsigned char*)
  { ERROR("call to Target_test::scan_relocs"); }

  void
  relocate_section(const Relocate_info<size, big_endian>*, unsigned int,
		   const unsigned char*, size_t, Output_section*, bool,
		   unsigned char*, typename elfcpp::Elf_types<size>::Elf_Addr,
		   section_size_type, const Reloc_symbol_changes*)
  { ERROR("call to Target_test::relocate_section"); }

  void
  scan_relocatable_relocs(Symbol_table*, Layout*,
			  Sized_relobj_file<size, big_endian>*, unsigned int,
			  unsigned int, const unsigned char*,
			  size_t, Output_section*, bool, size_t,
			  const unsigned char*, Relocatable_relocs*)
  { ERROR("call to Target_test::scan_relocatable_relocs"); }

  void
  relocate_relocs(const Relocate_info<size, big_endian>*,
		  unsigned int, const unsigned char*, size_t,
		  Output_section*, typename elfcpp::Elf_types<size>::Elf_Off,
                  const Relocatable_relocs*, unsigned char*,
		  typename elfcpp::Elf_types<size>::Elf_Addr,
		  section_size_type, unsigned char*,
		  section_size_type)
  { ERROR("call to Target_test::relocate_relocs"); }

  static const Target::Target_info test_target_info;
};

template<int size, bool big_endian>
const Target::Target_info Target_test<size, big_endian>::test_target_info =
{
  size,					// size
  big_endian,				// is_big_endian
  static_cast<elfcpp::EM>(0xffff),	// machine_code
  false,				// has_make_symbol
  false,				// has_resolve
  false,				// has_code_fill
  false,				// is_default_stack_executable
  false,				// can_icf_inline_merge_sections
  '\0',					// wrap_char
  "/dummy",				// dynamic_linker
  0x08000000,				// default_text_segment_address
  0x1000,				// abi_pagesize
  0x1000,				// common_pagesize
  false,                                // isolate_execinstr
  0,                                    // rosegment_gap
  elfcpp::SHN_UNDEF,			// small_common_shndx
  elfcpp::SHN_UNDEF,			// large_common_shndx
  0,					// small_common_section_flags
  0,					// large_common_section_flags
  NULL,					// attributes_section
  NULL,					// attributes_vendor
  "_start"		// entry_symbol_name
};

// The test targets.

#ifdef HAVE_TARGET_32_LITTLE
Target_test<32, false> target_test_32_little;
#endif

#ifdef HAVE_TARGET_32_BIG
Target_test<32, true> target_test_32_big;
#endif

#ifdef HAVE_TARGET_64_LITTLE
Target_test<64, false> target_test_64_little;
#endif

#ifdef HAVE_TARGET_64_BIG
Target_test<64, true> target_test_64_big;
#endif

// A pointer to the test targets.  This is used in CHECKs.

#ifdef HAVE_TARGET_32_LITTLE
Target* target_test_pointer_32_little = &target_test_32_little;
#endif

#ifdef HAVE_TARGET_32_BIG
Target* target_test_pointer_32_big = &target_test_32_big;
#endif

#ifdef HAVE_TARGET_64_LITTLE
Target* target_test_pointer_64_little = &target_test_64_little;
#endif

#ifdef HAVE_TARGET_64_BIG
Target* target_test_pointer_64_big = &target_test_64_big;
#endif

// Select the test targets.

template<int size, bool big_endian>
class Target_selector_test : public Target_selector
{
 public:
  Target_selector_test()
    : Target_selector(0xffff, size, big_endian, NULL, NULL)
  { }

  virtual Target*
  do_instantiate_target()
  {
    gold_unreachable();
    return NULL;
  }

  virtual Target*
  do_recognize(Input_file*, off_t, int, int, int)
  {
    if (size == 32)
      {
	if (!big_endian)
	  {
#ifdef HAVE_TARGET_32_LITTLE
	    return &target_test_32_little;
#endif
	  }
	else
	  {
#ifdef HAVE_TARGET_32_BIG
	    return &target_test_32_big;
#endif
	  }
      }
    else
      {
	if (!big_endian)
	  {
#ifdef HAVE_TARGET_64_LITTLE
	    return &target_test_64_little;
#endif
	  }
	else
	  {
#ifdef HAVE_TARGET_64_BIG
	    return &target_test_64_big;
#endif
	  }
      }

    return NULL;
  }

  virtual Target*
  do_recognize_by_name(const char*)
  { return NULL; }

  virtual void
  do_supported_names(std::vector<const char*>*)
  { }
};

// Register the test target selectors.  These don't need to be
// conditionally compiled, as they will return NULL if there is no
// support for them.

Target_selector_test<32, false> target_selector_test_32_little;
Target_selector_test<32, true> target_selector_test_32_big;
Target_selector_test<64, false> target_selector_test_64_little;
Target_selector_test<64, true> target_selector_test_64_big;

// A simple ELF object with one empty section, named ".test" and one
// globally visible symbol named "test".

const unsigned char test_file_1_32_little[] =
{
  // Ehdr
  // EI_MAG[0-3]
  0x7f, 'E', 'L', 'F',
  // EI_CLASS: 32 bit.
  1,
  // EI_DATA: little endian
  1,
  // EI_VERSION
  1,
  // EI_OSABI
  0,
  // EI_ABIVERSION
  0,
  // EI_PAD
  0, 0, 0, 0, 0, 0, 0,
  // e_type: ET_REL
  1, 0,
  // e_machine: a magic value used for testing.
  0xff, 0xff,
  // e_version
  1, 0, 0, 0,
  // e_entry
  0, 0, 0, 0,
  // e_phoff
  0, 0, 0, 0,
  // e_shoff: starts right after file header
  52, 0, 0, 0,
  // e_flags
  0, 0, 0, 0,
  // e_ehsize
  52, 0,
  // e_phentsize
  32, 0,
  // e_phnum
  0, 0,
  // e_shentsize
  40, 0,
  // e_shnum: dummy, .test, .symtab, .strtab, .shstrtab
  5, 0,
  // e_shstrndx
  4, 0,

  // Offset 52
  // Shdr 0: dummy entry
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 92
  // Shdr 1: .test
  // sh_name: after initial null
  1, 0, 0, 0,
  // sh_type: SHT_PROGBITS
  1, 0, 0, 0,
  // sh_flags: SHF_ALLOC
  2, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0,
  // sh_offset: after file header + 5 section headers
  252, 0, 0, 0,
  // sh_size
  0, 0, 0, 0,
  // sh_link
  0, 0, 0, 0,
  // sh_info
  0, 0, 0, 0,
  // sh_addralign
  1, 0, 0, 0,
  // sh_entsize
  0, 0, 0, 0,

  // Offset 132
  // Shdr 2: .symtab
  // sh_name: 1 null byte + ".test\0"
  7, 0, 0, 0,
  // sh_type: SHT_SYMTAB
  2, 0, 0, 0,
  // sh_flags
  0, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0,
  // sh_offset: after file header + 5 section headers + empty section
  252, 0, 0, 0,
  // sh_size: two symbols: dummy symbol + test symbol
  32, 0, 0, 0,
  // sh_link: to .strtab
  3, 0, 0, 0,
  // sh_info: one local symbol, the dummy symbol
  1, 0, 0, 0,
  // sh_addralign
  4, 0, 0, 0,
  // sh_entsize: size of symbol
  16, 0, 0, 0,

  // Offset 172
  // Shdr 3: .strtab
  // sh_name: 1 null byte + ".test\0" + ".symtab\0"
  15, 0, 0, 0,
  // sh_type: SHT_STRTAB
  3, 0, 0, 0,
  // sh_flags
  0, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0,
  // sh_offset: after .symtab section.  284 == 0x11c
  0x1c, 0x1, 0, 0,
  // sh_size: 1 null byte + "test\0"
  6, 0, 0, 0,
  // sh_link
  0, 0, 0, 0,
  // sh_info
  0, 0, 0, 0,
  // sh_addralign
  1, 0, 0, 0,
  // sh_entsize
  0, 0, 0, 0,

  // Offset 212
  // Shdr 4: .shstrtab
  // sh_name: 1 null byte + ".test\0" + ".symtab\0" + ".strtab\0"
  23, 0, 0, 0,
  // sh_type: SHT_STRTAB
  3, 0, 0, 0,
  // sh_flags
  0, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0,
  // sh_offset: after .strtab section.  290 == 0x122
  0x22, 0x1, 0, 0,
  // sh_size: all section names
  33, 0, 0, 0,
  // sh_link
  0, 0, 0, 0,
  // sh_info
  0, 0, 0, 0,
  // sh_addralign
  1, 0, 0, 0,
  // sh_entsize
  0, 0, 0, 0,

  // Offset 252
  // Contents of .symtab section
  // Symbol 0
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 268
  // Symbol 1
  // st_name
  1, 0, 0, 0,
  // st_value
  0, 0, 0, 0,
  // st_size
  0, 0, 0, 0,
  // st_info: STT_NOTYPE, STB_GLOBAL
  0x10,
  // st_other
  0,
  // st_shndx: In .test
  1, 0,

  // Offset 284
  // Contents of .strtab section
  '\0',
  't', 'e', 's', 't', '\0',

  // Offset 290
  // Contents of .shstrtab section
  '\0',
  '.', 't', 'e', 's', 't', '\0',
  '.', 's', 'y', 'm', 't', 'a', 'b', '\0',
  '.', 's', 't', 'r', 't', 'a', 'b', '\0',
  '.', 's', 'h', 's', 't', 'r', 't', 'a', 'b', '\0'
};

const unsigned int test_file_1_size_32_little = sizeof test_file_1_32_little;

// 32-bit big-endian version of test_file_1_32_little.

const unsigned char test_file_1_32_big[] =
{
  // Ehdr
  // EI_MAG[0-3]
  0x7f, 'E', 'L', 'F',
  // EI_CLASS: 32 bit.
  1,
  // EI_DATA: big endian
  2,
  // EI_VERSION
  1,
  // EI_OSABI
  0,
  // EI_ABIVERSION
  0,
  // EI_PAD
  0, 0, 0, 0, 0, 0, 0,
  // e_type: ET_REL
  0, 1,
  // e_machine: a magic value used for testing.
  0xff, 0xff,
  // e_version
  0, 0, 0, 1,
  // e_entry
  0, 0, 0, 0,
  // e_phoff
  0, 0, 0, 0,
  // e_shoff: starts right after file header
  0, 0, 0, 52,
  // e_flags
  0, 0, 0, 0,
  // e_ehsize
  0, 52,
  // e_phentsize
  0, 32,
  // e_phnum
  0, 0,
  // e_shentsize
  0, 40,
  // e_shnum: dummy, .test, .symtab, .strtab, .shstrtab
  0, 5,
  // e_shstrndx
  0, 4,

  // Offset 52
  // Shdr 0: dummy entry
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 92
  // Shdr 1: .test
  // sh_name: after initial null
  0, 0, 0, 1,
  // sh_type: SHT_PROGBITS
  0, 0, 0, 1,
  // sh_flags: SHF_ALLOC
  0, 0, 0, 2,
  // sh_addr
  0, 0, 0, 0,
  // sh_offset: after file header + 5 section headers
  0, 0, 0, 252,
  // sh_size
  0, 0, 0, 0,
  // sh_link
  0, 0, 0, 0,
  // sh_info
  0, 0, 0, 0,
  // sh_addralign
  0, 0, 0, 1,
  // sh_entsize
  0, 0, 0, 0,

  // Offset 132
  // Shdr 2: .symtab
  // sh_name: 1 null byte + ".test\0"
  0, 0, 0, 7,
  // sh_type: SHT_SYMTAB
  0, 0, 0, 2,
  // sh_flags
  0, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0,
  // sh_offset: after file header + 5 section headers + empty section
  0, 0, 0, 252,
  // sh_size: two symbols: dummy symbol + test symbol
  0, 0, 0, 32,
  // sh_link: to .strtab
  0, 0, 0, 3,
  // sh_info: one local symbol, the dummy symbol
  0, 0, 0, 1,
  // sh_addralign
  0, 0, 0, 4,
  // sh_entsize: size of symbol
  0, 0, 0, 16,

  // Offset 172
  // Shdr 3: .strtab
  // sh_name: 1 null byte + ".test\0" + ".symtab\0"
  0, 0, 0, 15,
  // sh_type: SHT_STRTAB
  0, 0, 0, 3,
  // sh_flags
  0, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0,
  // sh_offset: after .symtab section.  284 == 0x11c
  0, 0, 0x1, 0x1c,
  // sh_size: 1 null byte + "test\0"
  0, 0, 0, 6,
  // sh_link
  0, 0, 0, 0,
  // sh_info
  0, 0, 0, 0,
  // sh_addralign
  0, 0, 0, 1,
  // sh_entsize
  0, 0, 0, 0,

  // Offset 212
  // Shdr 4: .shstrtab
  // sh_name: 1 null byte + ".test\0" + ".symtab\0" + ".strtab\0"
  0, 0, 0, 23,
  // sh_type: SHT_STRTAB
  0, 0, 0, 3,
  // sh_flags
  0, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0,
  // sh_offset: after .strtab section.  290 == 0x122
  0, 0, 0x1, 0x22,
  // sh_size: all section names
  0, 0, 0, 33,
  // sh_link
  0, 0, 0, 0,
  // sh_info
  0, 0, 0, 0,
  // sh_addralign
  0, 0, 0, 1,
  // sh_entsize
  0, 0, 0, 0,

  // Offset 252
  // Contents of .symtab section
  // Symbol 0
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 268
  // Symbol 1
  // st_name
  0, 0, 0, 1,
  // st_value
  0, 0, 0, 0,
  // st_size
  0, 0, 0, 0,
  // st_info: STT_NOTYPE, STB_GLOBAL
  0x10,
  // st_other
  0,
  // st_shndx: In .test
  0, 1,

  // Offset 284
  // Contents of .strtab section
  '\0',
  't', 'e', 's', 't', '\0',

  // Offset 290
  // Contents of .shstrtab section
  '\0',
  '.', 't', 'e', 's', 't', '\0',
  '.', 's', 'y', 'm', 't', 'a', 'b', '\0',
  '.', 's', 't', 'r', 't', 'a', 'b', '\0',
  '.', 's', 'h', 's', 't', 'r', 't', 'a', 'b', '\0'
};

const unsigned int test_file_1_size_32_big = sizeof test_file_1_32_big;

// 64-bit little-endian version of test_file_1_32_little.

const unsigned char test_file_1_64_little[] =
{
  // Ehdr
  // EI_MAG[0-3]
  0x7f, 'E', 'L', 'F',
  // EI_CLASS: 64 bit.
  2,
  // EI_DATA: little endian
  1,
  // EI_VERSION
  1,
  // EI_OSABI
  0,
  // EI_ABIVERSION
  0,
  // EI_PAD
  0, 0, 0, 0, 0, 0, 0,
  // e_type: ET_REL
  1, 0,
  // e_machine: a magic value used for testing.
  0xff, 0xff,
  // e_version
  1, 0, 0, 0,
  // e_entry
  0, 0, 0, 0, 0, 0, 0, 0,
  // e_phoff
  0, 0, 0, 0, 0, 0, 0, 0,
  // e_shoff: starts right after file header
  64, 0, 0, 0, 0, 0, 0, 0,
  // e_flags
  0, 0, 0, 0,
  // e_ehsize
  64, 0,
  // e_phentsize
  56, 0,
  // e_phnum
  0, 0,
  // e_shentsize
  64, 0,
  // e_shnum: dummy, .test, .symtab, .strtab, .shstrtab
  5, 0,
  // e_shstrndx
  4, 0,

  // Offset 64
  // Shdr 0: dummy entry
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 128
  // Shdr 1: .test
  // sh_name: after initial null
  1, 0, 0, 0,
  // sh_type: SHT_PROGBITS
  1, 0, 0, 0,
  // sh_flags: SHF_ALLOC
  2, 0, 0, 0, 0, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_offset: after file header + 5 section headers.  384 == 0x180.
  0x80, 0x1, 0, 0, 0, 0, 0, 0,
  // sh_size
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_link
  0, 0, 0, 0,
  // sh_info
  0, 0, 0, 0,
  // sh_addralign
  1, 0, 0, 0, 0, 0, 0, 0,
  // sh_entsize
  0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 192
  // Shdr 2: .symtab
  // sh_name: 1 null byte + ".test\0"
  7, 0, 0, 0,
  // sh_type: SHT_SYMTAB
  2, 0, 0, 0,
  // sh_flags
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_offset: after file header + 5 section headers + empty section
  // 384 == 0x180.
  0x80, 0x1, 0, 0, 0, 0, 0, 0,
  // sh_size: two symbols: dummy symbol + test symbol
  48, 0, 0, 0, 0, 0, 0, 0,
  // sh_link: to .strtab
  3, 0, 0, 0,
  // sh_info: one local symbol, the dummy symbol
  1, 0, 0, 0,
  // sh_addralign
  8, 0, 0, 0, 0, 0, 0, 0,
  // sh_entsize: size of symbol
  24, 0, 0, 0, 0, 0, 0, 0,

  // Offset 256
  // Shdr 3: .strtab
  // sh_name: 1 null byte + ".test\0" + ".symtab\0"
  15, 0, 0, 0,
  // sh_type: SHT_STRTAB
  3, 0, 0, 0,
  // sh_flags
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_offset: after .symtab section.  432 == 0x1b0
  0xb0, 0x1, 0, 0, 0, 0, 0, 0,
  // sh_size: 1 null byte + "test\0"
  6, 0, 0, 0, 0, 0, 0, 0,
  // sh_link
  0, 0, 0, 0,
  // sh_info
  0, 0, 0, 0,
  // sh_addralign
  1, 0, 0, 0, 0, 0, 0, 0,
  // sh_entsize
  0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 320
  // Shdr 4: .shstrtab
  // sh_name: 1 null byte + ".test\0" + ".symtab\0" + ".strtab\0"
  23, 0, 0, 0,
  // sh_type: SHT_STRTAB
  3, 0, 0, 0,
  // sh_flags
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_offset: after .strtab section.  438 == 0x1b6
  0xb6, 0x1, 0, 0, 0, 0, 0, 0,
  // sh_size: all section names
  33, 0, 0, 0, 0, 0, 0, 0,
  // sh_link
  0, 0, 0, 0,
  // sh_info
  0, 0, 0, 0,
  // sh_addralign
  1, 0, 0, 0, 0, 0, 0, 0,
  // sh_entsize
  0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 384
  // Contents of .symtab section
  // Symbol 0
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 408
  // Symbol 1
  // st_name
  1, 0, 0, 0,
  // st_info: STT_NOTYPE, STB_GLOBAL
  0x10,
  // st_other
  0,
  // st_shndx: In .test
  1, 0,
  // st_value
  0, 0, 0, 0, 0, 0, 0, 0,
  // st_size
  0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 432
  // Contents of .strtab section
  '\0',
  't', 'e', 's', 't', '\0',

  // Offset 438
  // Contents of .shstrtab section
  '\0',
  '.', 't', 'e', 's', 't', '\0',
  '.', 's', 'y', 'm', 't', 'a', 'b', '\0',
  '.', 's', 't', 'r', 't', 'a', 'b', '\0',
  '.', 's', 'h', 's', 't', 'r', 't', 'a', 'b', '\0'
};

const unsigned int test_file_1_size_64_little = sizeof test_file_1_64_little;

// 64-bit big-endian version of test_file_1_32_little.

const unsigned char test_file_1_64_big[] =
{
  // Ehdr
  // EI_MAG[0-3]
  0x7f, 'E', 'L', 'F',
  // EI_CLASS: 64 bit.
  2,
  // EI_DATA: big endian
  2,
  // EI_VERSION
  1,
  // EI_OSABI
  0,
  // EI_ABIVERSION
  0,
  // EI_PAD
  0, 0, 0, 0, 0, 0, 0,
  // e_type: ET_REL
  0, 1,
  // e_machine: a magic value used for testing.
  0xff, 0xff,
  // e_version
  0, 0, 0, 1,
  // e_entry
  0, 0, 0, 0, 0, 0, 0, 0,
  // e_phoff
  0, 0, 0, 0, 0, 0, 0, 0,
  // e_shoff: starts right after file header
  0, 0, 0, 0, 0, 0, 0, 64,
  // e_flags
  0, 0, 0, 0,
  // e_ehsize
  0, 64,
  // e_phentsize
  0, 56,
  // e_phnum
  0, 0,
  // e_shentsize
  0, 64,
  // e_shnum: dummy, .test, .symtab, .strtab, .shstrtab
  0, 5,
  // e_shstrndx
  0, 4,

  // Offset 64
  // Shdr 0: dummy entry
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 128
  // Shdr 1: .test
  // sh_name: after initial null
  0, 0, 0, 1,
  // sh_type: SHT_PROGBITS
  0, 0, 0, 1,
  // sh_flags: SHF_ALLOC
  0, 0, 0, 0, 0, 0, 0, 2,
  // sh_addr
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_offset: after file header + 5 section headers.  384 == 0x180.
  0, 0, 0, 0, 0, 0, 0x1, 0x80,
  // sh_size
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_link
  0, 0, 0, 0,
  // sh_info
  0, 0, 0, 0,
  // sh_addralign
  0, 0, 0, 0, 0, 0, 0, 1,
  // sh_entsize
  0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 192
  // Shdr 2: .symtab
  // sh_name: 1 null byte + ".test\0"
  0, 0, 0, 7,
  // sh_type: SHT_SYMTAB
  0, 0, 0, 2,
  // sh_flags
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_offset: after file header + 5 section headers + empty section
  // 384 == 0x180.
  0, 0, 0, 0, 0, 0, 0x1, 0x80,
  // sh_size: two symbols: dummy symbol + test symbol
  0, 0, 0, 0, 0, 0, 0, 48,
  // sh_link: to .strtab
  0, 0, 0, 3,
  // sh_info: one local symbol, the dummy symbol
  0, 0, 0, 1,
  // sh_addralign
  0, 0, 0, 0, 0, 0, 0, 8,
  // sh_entsize: size of symbol
  0, 0, 0, 0, 0, 0, 0, 24,

  // Offset 256
  // Shdr 3: .strtab
  // sh_name: 1 null byte + ".test\0" + ".symtab\0"
  0, 0, 0, 15,
  // sh_type: SHT_STRTAB
  0, 0, 0, 3,
  // sh_flags
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_offset: after .symtab section.  432 == 0x1b0
  0, 0, 0, 0, 0, 0, 0x1, 0xb0,
  // sh_size: 1 null byte + "test\0"
  0, 0, 0, 0, 0, 0, 0, 6,
  // sh_link
  0, 0, 0, 0,
  // sh_info
  0, 0, 0, 0,
  // sh_addralign
  0, 0, 0, 0, 0, 0, 0, 1,
  // sh_entsize
  0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 320
  // Shdr 4: .shstrtab
  // sh_name: 1 null byte + ".test\0" + ".symtab\0" + ".strtab\0"
  0, 0, 0, 23,
  // sh_type: SHT_STRTAB
  0, 0, 0, 3,
  // sh_flags
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_addr
  0, 0, 0, 0, 0, 0, 0, 0,
  // sh_offset: after .strtab section.  438 == 0x1b6
  0, 0, 0, 0, 0, 0, 0x1, 0xb6,
  // sh_size: all section names
  0, 0, 0, 0, 0, 0, 0, 33,
  // sh_link
  0, 0, 0, 0,
  // sh_info
  0, 0, 0, 0,
  // sh_addralign
  0, 0, 0, 0, 0, 0, 0, 1,
  // sh_entsize
  0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 384
  // Contents of .symtab section
  // Symbol 0
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 408
  // Symbol 1
  // st_name
  0, 0, 0, 1,
  // st_info: STT_NOTYPE, STB_GLOBAL
  0x10,
  // st_other
  0,
  // st_shndx: In .test
  0, 1,
  // st_value
  0, 0, 0, 0, 0, 0, 0, 0,
  // st_size
  0, 0, 0, 0, 0, 0, 0, 0,

  // Offset 432
  // Contents of .strtab section
  '\0',
  't', 'e', 's', 't', '\0',

  // Offset 438
  // Contents of .shstrtab section
  '\0',
  '.', 't', 'e', 's', 't', '\0',
  '.', 's', 'y', 'm', 't', 'a', 'b', '\0',
  '.', 's', 't', 'r', 't', 'a', 'b', '\0',
  '.', 's', 'h', 's', 't', 'r', 't', 'a', 'b', '\0'
};

const unsigned int test_file_1_size_64_big = sizeof test_file_1_64_big;

} // End namespace gold_testsuite.
@


1.24
log
@gold/
	* target.h (Sized_target::relocate_relocs): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_relocs): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_relocs): Likewise.
	* powerpc.cc (Target_powerpc::relocate_relocs): Likewise.
	* sparc.cc (Target_sparc::relocate_relocs): Likewise.
	* target-reloc.h (relocate_relocs): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_relocs): Likewise.
	* x86_64.cc (Target_x86_64::relocate_relocs): Likewise.
@
text
@d110 2
a111 1
  NULL					// attributes_vendor
@


1.23
log
@	* object.h (Sized_relobj_file::emit_relocs): Delete.
	(Sized_relobj_file::emit_relocs_reltype): Delete.
	* reloc.cc (Sized_relobj_file::do_relocate_sections): Call target
	relocate_relocs for --emit-relocs.
	(Sized_relobj_file::emit_relocs, emit_relocs_reltype): Delete.
	* output.h: Update comment.
	(Output_segment::first_section): New function.
	(Output_segment::first_section_load_address): Use first_section.
	* output.cc (Output_segment::first_section): New function extracted..
	(Output_segment::first_section_load_address): ..from here.  Delete.
	* target-reloc.h (relocate_for_relocatable): Rename to relocate_relocs.
	* target.h (Sized_target::relocate_for_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise, and
	adjust call to target.h function.
	* i386.cc (Target_i386): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	(Target_powerpc::Scan::local, global): Handle R_POWERPC_TLS.  Ensure
	first tls section has section symbol for optimised local dynamic
	output relocs.
	(Target_powerpc::Relocate::relocate): Correct local dynamic value.
	(Target_powerpc::relocate_relocs): Adjust relocs emitted for
	optimised tls code.
	* testsuite/testfile.cc (Target_test::relocate_for_relocatable):
	Rename to relocate_relocs.  Update error message.
@
text
@d77 2
a78 2
		  Output_section*, off_t, const Relocatable_relocs*,
		  unsigned char*,
@


1.22
log
@	* configure.ac (ENABLE_GOLD): Consider *-*-nacl* targets ELF.
	* configure: Regenerate.

gold/
	* nacl.cc: New file.
	* nacl.h: New file.
	* Makefile.am (CCFILES, HFILES): Add them.
	* Makefile.in: Regenerate.
	* i386.cc (Output_data_plt_i386_nacl): New class.
	(Output_data_plt_i386_nacl_exec): New class.
	(Output_data_plt_i386_nacl_dyn): New class.
	(Target_i386_nacl): New class.
	(Target_selector_i386_nacl): New class.
	(target_selector_i386): Use it instead of Target_selector_i386.
	* x86_64.cc (Output_data_plt_x86_64_nacl): New class.
	(Target_x86_64_nacl): New class.
	(Target_selector_x86_64_nacl): New class.
	(target_selector_x86_64, target_selector_x32): Use it instead of
	Target_selector_x86_64.
	* arm.cc (Output_data_plt_arm_nacl): New class.
	(Target_arm_nacl): New class.
	(Target_selector_arm_nacl): New class.
	(target_selector_arm, target_selector_armbe): Use it instead of
	Target_selector_arm.

	* target-select.cc (select_target): Take new Input_file* and off_t
	arguments, pass them on to recognize method of selector.
	* object.cc (make_elf_sized_object): Update caller.
	* parameters.cc (parameters_force_valid_target): Likewise.
	* incremental.cc (make_sized_incremental_binary): Likewise.
	* target-select.h: Update decl.
	(Target_selector::recognize): Take new Input_file* argument,
	pass it on to do_recognize.
	(Target_selector::do_recognize): Take new Input_file* argument.
	* freebsd.h (Target_selector_freebsd::do_recognize): Likewise.
	* powerpc.cc (Target_selector_powerpc::do_recognize): Likewise.
	* sparc.cc (Target_selector_sparc::do_recognize): Likewise.
	* testsuite/testfile.cc (Target_selector::do_recognize): Likewise.

	* target.h (Target::Target_info): New members isolate_execinstr
	and rosegment_gap.
	(Target::isolate_execinstr, Target::rosegment_gap): New methods.
	* arm.cc (Target_arm::arm_info): Update initializer.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
	* sparc.cc (Target_sparc::sparc_info): Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
	* layout.cc (Layout::attach_allocated_section_to_segment):
	Take new const Target* argument.  If target->isolate_execinstr(), act
	like --rosegment.
	(Layout::find_first_load_seg): Take new const Target* argument;
	if target->isolate_execinstr(), reject PF_X segments.
	(Layout::relaxation_loop_body): Update caller.
	(Layout::set_segment_offsets): If target->isolate_execinstr(),
	reset file offset to zero when we hit LOAD_SEG, and then do a second
	loop over the segments before LOAD_SEG to reassign offsets after
	addresses have been determined.  Handle target->rosegment_gap().
	(Layout::attach_section_to_segment): Take new const Target* argument;
	pass it to attach_allocated_section_to_segment.
	(Layout::make_output_section): Update caller.
	(Layout::attach_sections_to_segments): Take new const Target* argument;
	pass it to attach_section_to_segment.
	* gold.cc (queue_middle_tasks): Update caller.
	* layout.h (Layout): Update method decls with new arguments.

	* arm.cc (Target_arm::Target_arm): Take optional argument for the
	Target_info pointer to use.
	(Target_arm::do_make_data_plt): New virtual method.
	(Target_arm::make_data_plt): New method that calls it.
	(Target_arm::make_plt_entry): Use it.
	(Output_data_plt_arm::Output_data_plt_arm): Take additional argument
	for the section alignment.
	(Output_data_plt_arm::do_first_plt_entry_offset): New abstract virtual
	method.
	(Output_data_plt_arm::first_plt_entry_offset): Call it.
	(Output_data_plt_arm::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_arm::get_plt_entry_size): Call it.
	(Output_data_plt_arm::do_fill_plt_entry): New abstract virtual method.
	(Output_data_plt_arm::fill_plt_entry): New method that calls it.
	(Output_data_plt_arm::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_arm::fill_first_plt_entry): New method that calls it.
	(Output_data_plt_arm::set_final_data_size): Use get_plt_entry_size
	method instead of sizeof(plt_entry).
	(Output_data_plt_arm::add_entry): Likewise.
	Use first_plt_entry_offset method instead of sizeof(first_plt_entry).
	(Target_arm::first_plt_entry_offset): Call method on this->plt_ rather
	than static method.
	(Target_arm::plt_entry_size): Likewise.
	(Output_data_plt_arm::first_plt_entry, Output_data_plt_arm::plt_entry):
	Move to ...
	(Output_data_plt_arm_standard): ... here, new class.
	(Output_data_plt_arm::do_write): Move guts of PLT filling to...
	(Output_data_plt_arm_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_arm_standard::do_fill_plt_entry): ... and here.

	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Take additional argument for the PLT entry size.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset):
	Use get_plt_entry_size method rather than plt_entry_size variable.
	(Output_data_plt_x86_64::reserve_slot): Likewise.
	(Output_data_plt_x86_64::do_adjust_output_section): Likewise.
	(Output_data_plt_x86_64::add_entry): Likewise.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Likewise.
	(Output_data_plt_x86_64::address_for_global): Likewise.
	(Output_data_plt_x86_64::address_for_local): Likewise.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::first_plt_entry_offset): Likewise.
	Make method non-static.
	(Output_data_plt_x86_64::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_x86_64::get_plt_entry_size): Just call that.
	(Output_data_plt_x86_64::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_x86_64::add_eh_frame): New method to call it.
	(Output_data_plt_x86_64::do_fill_first_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_first_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_tlsdesc_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_tlsdesc_entry): New method to call it.
	(Output_data_plt_x86_64::plt_entry_size)
	(Output_data_plt_x86_64::first_plt_entry)
	(Output_data_plt_x86_64::plt_entry)
	(Output_data_plt_x86_64::tlsdesc_plt_entry)
	(Output_data_plt_x86_64::plt_eh_frame_fde_size)
	(Output_data_plt_x86_64::plt_eh_frame_fde): Move to ...
	(Output_data_plt_x86_64_standard): ... here, new class.
	(Target_x86_64::Target_x86_64): Take optional argument for the
	Target_info pointer to use.
	(Target_x86_64::do_make_data_plt): New virtual method.
	(Target_x86_64::make_data_plt): New method to call it.
	(Target_x86_64::init_got_plt_for_update): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_x86_64::init):	Don't do add_eh_frame_for_plt here.
	(Target_x86_64::first_plt_entry_offset): Call method on this->plt_
	rather than static method.
	(Target_x86_64::plt_entry_size): Likewise.
	(Output_data_plt_x86_64::do_write): Use get_plt_entry_size method
	rather than plt_entry_size variable.  Move guts of PLT filling to...
	(Output_data_plt_x86_64_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_x86_64_standard::do_fill_plt_entry): ... and here ...
	(Output_data_plt_x86_64_standard::do_fill_tlsdesc_entry): ... and here.

	* i386.cc (Output_data_plt_i386::Output_data_plt_i386): Take
	additional argument for the section alignment.
	Don't do add_eh_frame_for_plt here.
	(Output_data_plt_i386::first_plt_entry_offset): Make the method
	non-static.  Use get_plt_entry_size method rather than plt_entry_size
	variable.
	(Output_data_plt_i386::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_i386::get_plt_entry_size): Call it.
	(Output_data_plt_i386::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_i386::add_eh_frame): New method to call it.
	(Output_data_plt_i386::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_first_plt_entry): New method to call it.
	(Output_data_plt_i386::do_fill_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_plt_entry): New method to call it.
	(Output_data_plt_i386::set_final_data_size): Use get_plt_entry_size
	method instead of plt_entry_size.
	(Output_data_plt_i386::plt_entry_size)
	(Output_data_plt_i386::plt_eh_frame_fde_size)
	(Output_data_plt_i386::plt_eh_frame_fde): Move to ...
	(Output_data_plt_i386_standard): ... here, new class.
	(Output_data_plt_i386_exec): New class.
	(Output_data_plt_i386::exec_first_plt_entry): Move to ...
	(Output_data_plt_i386_exec::first_plt_entry): ... here.
	(Output_data_plt_i386::exec_plt_entry): Move to ...
	(Output_data_plt_i386_exec::plt_entry): ... here.
	(Output_data_plt_i386_dyn): New class.
	(Output_data_plt_i386::first_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::first_plt_entry): ... here.
	(Output_data_plt_i386::dyn_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::plt_entry): ... here.
	(Target_i386::Target_i386): Take optional argument for the Target_info
	pointer to use.
	(Target_i386::do_make_data_plt): New virtual method.
	(Target_i386::make_data_plt): New method to call it.
	(Target_i386::make_plt_section): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_i386::add_entry): Use get_plt_entry_size method
	rather than plt_entry_size variable.
	(Output_data_plt_i386::add_local_ifunc_entry): Likewise.
	(Output_data_plt_i386::address_for_local): Likewise.
	(Output_data_plt_i386::do_write): Likewise.
	Move guts of PLT filling to...
	(Output_data_plt_i386_exec::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_i386_exec::do_fill_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_first_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_plt_entry): ... and here.

Change-Id: Id24b95600489835ff5e860a39c147203d4380c2b
@
text
@d75 8
a82 8
  relocate_for_relocatable(const Relocate_info<size, big_endian>*,
			   unsigned int, const unsigned char*, size_t,
			   Output_section*, off_t, const Relocatable_relocs*,
			   unsigned char*,
			   typename elfcpp::Elf_types<size>::Elf_Addr,
			   section_size_type, unsigned char*,
			   section_size_type)
  { ERROR("call to Target_test::relocate_for_relocatable"); }
@


1.22.2.1
log
@gold/
	* target.h (Sized_target::relocate_for_relocatable): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_for_relocatable): Likewise.
	* powerpc.cc (Target_powerpc::relocate_for_relocatable): Likewise.
	* sparc.cc (Target_sparc::relocate_for_relocatable): Likewise.
	* target-reloc.h (relocate_for_relocatable): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_for_relocatable): Likewise.
	* x86_64.cc (Target_x86_64::relocate_for_relocatable): Likewise.
@
text
@d77 2
a78 3
                           Output_section*,
                           typename elfcpp::Elf_types<size>::Elf_Off,
                           const Relocatable_relocs*, unsigned char*,
@


1.21
log
@	PR gold/12934
	* target-select.cc (Target_selector::Target_selector): Add
	emulation parameter.  Change all callers.
	(select_target_by_bfd_name): Rename from select_target_by_name.
	Change all callers.
	(select_target_by_emulation): New function.
	(supported_emulation_names): New function.
	* target-select.h (class Target_selector): Add emulation_ field.
	Update declarations.
	(Target_selector::recognize_by_bfd_name): Rename from
	recognize_by_name.  Change all callers.
	(Target_selector::supported_bfd_names): Rename from
	supported_names.  Change all callers.
	(Target_selector::recognize_by_emulation): New function.
	(Target_selector::supported_emulations): New function.
	(Target_selector::emulation): New function.
	(Target_selector::do_recognize_by_bfd_name): Rename from
	do_recognize_by_name.  Change all callers.
	(Target_selector::do_supported_bfd_names): Rename from
	do_supported_names.  Change all callers.
	(Target_selector::do_recognize_by_emulation): New function.
	(Target_selector::do_supported_emulations): New function.
	(select_target_by_bfd_name): Change name in declaration.
	(select_target_by_emulation): Declare.
	(supported_emulation_names): Declare.
	* parameters.cc (parameters_force_valid_target): Try to find
	target based on emulation from -m option.
	* options.h (class General_options): Change doc string for -m.
	* options.cc (help): Print emulations.
	(General_options::parse_V): Likewise.
	* freebsd.h (Target_selector_freebsd::Target_selector_freebsd):
	Add emulation parameter.  Change all callers.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2011 Free Software Foundation, Inc.
d103 2
d159 1
a159 1
  Target*
d166 2
a167 2
  Target*
  do_recognize(int, int, int)
d203 1
a203 1
  Target*
d207 1
a207 1
  void
@


1.20
log
@	* target.h (Target::can_check_for_function_pointers): Rewrite.
	Make non-virtual.
	(Target::can_icf_inline_merge_sections): Likewise.
	(Target::section_may_have_icf_unsafe_poineters): Likewise.
	(Target::Target_info): Add can_icf_inline_merge_sections field.
	(Target::do_can_check_for_function_pointers): New virtual
	function.
	(Target::do_section_may_have_icf_unsafe_pointers): Likewise.
	* arm.cc (Target_arm::do_can_check_for_function_pointers): Rename
	from can_check_for_function_pointers, move in file.
	(Target_arm::do_section_may_have_icf_unsafe_pointers): Rename from
	section_may_have_icf_unsafe_poineters, move in file.
	(Target_arm::arm_info): Initialize can_icf_inline_merge_sections.
	* i386.cc (Target_i386::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_i386::can_icf_inline_merge_sections): Remove.
	(Target_i386::i386_info): Initialize
	can_icf_inline_merge_sections.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Initialize can_icf_inline_merge_sections.
	* sparc.cc (Target_sparc::sparc_info) [both version]: Likewise.
	* x86_64.cc (Target_x86_64::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_x86_64::can_icf_inline_merge_sections): Remove.
	(Target_x86_64::x86_64_info): Initialize
	can_icf_inline_merge_sections.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Likewise.
	* icf.cc (get_section_contents): Correct formatting.
@
text
@d154 1
a154 1
    : Target_selector(0xffff, size, big_endian, NULL)
@


1.19
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d97 1
@


1.18
log
@2009-12-05  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:

	* arm.h: Define enums for Tag_CPU_arch EABI attribute.

gold/ChangeLog:
	* arm.cc (Target_arm::arm_info): Initialize new fields
	attributes_section and attributes_vendor.
	* i386.cc (Target_i386::i386_info): Same.
	* object.cc (Sized_relobj::do_layout): Skip attribute section.
	* gold/powerpc.cc (Target_powerpc::powerpc_info): Initialize new
	fields attributes_section and attributes_vendor.
 	* sparc.cc (Target_sparc::sparc_info): Same.
	* target.h (Target::attributes_section, Target::attributes_vendor,
	Target::is_attributes_section, Target::attribute_arg_type,
	Target::attributes_order): New method definitions.
	(Target::Target_info::attributes_section,
	Target::Target_info::attributes_vendor): New fields.
	(Target::do_attribute_arg_type, Target::do_attributes_order): New
	virtual method definitions.
	* x86_64.cc (Target_x86_64::x86_64_info): Initialize new fields
	attributes_section and attributes_vendor.
	* testsuite/testfile.cc (Target_test::test_target_info): Same.
@
text
@d47 2
a48 1
  gc_process_relocs(Symbol_table*, Layout*, Sized_relobj<size, big_endian>*,
d54 1
a54 1
  scan_relocs(Symbol_table*, Layout*, Sized_relobj<size, big_endian>*,
d68 1
a68 1
			  Sized_relobj<size, big_endian>*, unsigned int,
@


1.17
log
@	* object.h (class Relobj): Drop options parameter from
	gc_process_relocs, scan_relocs, relocate, do_gc_process_relocs,
	do_scan_relocs, do_relocate.  Change all callers.
	(class Sized_relobj): Drop options parameters from
	do_gc_process_relocs, do_scan_relocs, do_relocate,
	do_relocate_sections, relocate_sections, emit_relocs_scan,
	emit_relocs_scan_reltype.  Change all callers.
	(struct Relocate_info): Remove options field and all references to
	it.
	* reloc.h (class Read_relocs): Remove options constructor
	parameter and options_ field.  Change all callers.
	(class Gc_process_relocs, class Scan_relocs): Likewise.
	(class Relocate_task): Likewise.
	* target-reloc.h (scan_relocs): Remove options parameter.  Change
	all callers.
	(scan_relocatable_relocs): Likewise.
	* target.h (class Sized_target): Remove options parameter from
	gc_process_relocs, scan_relocs, scan_relocatable_relocs.  Change
	all callers.
	* gc.h (gc_process_relocs): Remove options parameter.  Change all
	callers.
	* arm.cc: Update functions to remove options parameters.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* testsuite/testfile.cc: Likewise.
@
text
@d104 3
a106 1
  0					// large_common_section_flags
@


1.16
log
@	* options.h (class General_options): Define
	split_stack_adjust_size parameter.
	* object.h (class Object): Add uses_split_stack_ and
	has_no_split_stack_ fields.  Add uses_split_stack and
	has_no_split_stack accessor functions.  Declare
	handle_split_stack_section.
	(class Reloc_symbol_changes): Define.
	(class Sized_relobj): Define Function_offsets.  Declare
	split_stack_adjust, split_stack_adjust_reltype, and
	find_functions.
	* object.cc (Object::handle_split_stack_section): New function.
	(Sized_relobj::do_layout): Call handle_split_stack_section.
	* dynobj.cc (Sized_dynobj::do_layout): Call
	handle_split_stack_section.
	* reloc.cc (Sized_relobj::relocate_sections): Call
	split_stack_adjust for executable sections in split_stack
	objects.  Pass reloc_map to relocate_section.
	(Sized_relobj::split_stack_adjust): New function.
	(Sized_relobj::split_stack_adjust_reltype): New function.
	(Sized_relobj::find_functions): New function.
	* target-reloc.h: Include "object.h".
	(relocate_section): Add reloc_symbol_changes parameter.  Change
	all callers.
	* target.h (class Target): Add calls_non_split method.  Declare
	do_calls_non_split virtual method.  Declare match_view and
	set_view_to_nop.
	* target.cc: Include "elfcpp.h".
	(Target::do_calls_non_split): New function.
	(Target::match_view): New function.
	(Target::set_view_to_nop): New function.
	* gold.cc (queue_middle_tasks): Give an error if mixing
	split-stack and non-split-stack objects with -r.
	* i386.cc (Target_i386::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_i386::do_calls_non_split): New function.
	* x86_64.cc (Target_x86_64::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_x86_64::do_calls_non_split): New function.
	* arm.cc (Target_arm::relocate_section): Add reloc_symbol_changes
	parameter.
	* powerpc.cc (Target_powerpc::relocate_section): Add
	reloc_symbol_changes parameter.
	* sparc.cc (Target_sparc::relocate_section): Add
	reloc_symbol_changes parameter.
	* configure.ac: Call AM_CONDITIONAL for the default target.
	* configure: Rebuild.
	* testsuite/Makefile.am (TEST_AS): New variable.
	(check_SCRIPTS): Add split_i386.sh and split_x86_64.sh.
	(check_DATA): Add split_i386 and split_x86_64 files.
	(SPLIT_DEFSYMS): Define.
	(split_i386_[1234n].o): New targets.
	(split_i386_[124]): New targets.
	(split_i386_[1234r].stdout): New targets.
	(split_x86_64_[1234n].o): New targets.
	(split_x86_64_[124]): New targets.
	(split_x86_64_[1234r].stdout): New targets.
	(MOSTLYCLEANFILES): Add new executables.
	* testsuite/split_i386.sh: New file.
	* testsuite/split_x86_64.sh: New file.
	* testsuite/split_i386_1.s: New file.
	* testsuite/split_i386_2.s: New file.
	* testsuite/split_i386_3.s: New file.
	* testsuite/split_i386_4.s: New file.
	* testsuite/split_i386_n.s: New file.
	* testsuite/split_x86_64_1.s: New file.
	* testsuite/split_x86_64_2.s: New file.
	* testsuite/split_x86_64_3.s: New file.
	* testsuite/split_x86_64_4.s: New file.
	* testsuite/split_x86_64_n.s: New file.
	* testsuite/testfile.cc (Target_test): Update relocation_section
	function.
	* testsuite/Makefile.in: Rebuild.
@
text
@d47 3
a49 4
  gc_process_relocs(const General_options&, Symbol_table*, Layout*,
                    Sized_relobj<size, big_endian>*, unsigned int,
                    unsigned int, const unsigned char*, size_t, Output_section*,
                    bool, size_t, const unsigned char*)
d53 3
a55 4
  scan_relocs(const General_options&, Symbol_table*, Layout*,
	      Sized_relobj<size, big_endian>*, unsigned int,
	      unsigned int, const unsigned char*, size_t, Output_section*,
	      bool, size_t, const unsigned char*)
d66 1
a66 1
  scan_relocatable_relocs(const General_options&, Symbol_table*, Layout*,
@


1.15
log
@	* layout.cc (Layout::make_output_section): Call
	Target::new_output_section.
	(Layout::attach_allocated_section_to_segment): Put large section
	sections in a separate load segment with the large segment flag
	set.
	(Layout::segment_precedes): Sort large data segments after other
	load segments.
	(align_file_offset): New static function.
	(Layout::set_segment_offsets): Use align_file_offset.
	* output.h (class Output_section): Add is_small_section_ and
	is_large_section_ fields.
	(Output_section::is_small_section): New function.
	(Output_section::set_is_small_section):  New function.
	(Output_section::is_large_section): New function.
	(Output_section::set_is_large_section): New function.
	(Output_section::is_large_data_section): New function.
	(class Output_segment): Add is_large_data_segment_ field.
	(Output_segment::is_large_data_segment): New function.
	(Output_segment::set_is_large_data_segment): New function.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_segment::Output_segment): Likewise.
	(Output_segment::add_output_section): Add assertion that large
	data sections always go in large data segments.  Force small data
	sections to the end of the list of data sections.  Force small BSS
	sections to the start of the list of BSS sections.  For large BSS
	sections to the end of the list of BSS sections.
	* symtab.h (class Symbol): Declare is_common_shndx.
	(Symbol::is_defined): Check Symbol::is_common_shndx.
	(Symbol::is_common): Likewise.
	(class Symbol_table): Define enum Commons_section_type.  Update
	declarations.  Add small_commons_ and large_commons_ fields.
	* symtab.cc (Symbol::is_common_shndx): New function.
	(Symbol_table::Symbol_table): Initialize new fields.
	(Symbol_table::add_from_object): Put small and large common
	symbols in the right list.
	(Symbol_table::sized_finalized_symbol): Check
	Symbol::is_common_shndx.
	(Symbol_table::sized_write_globals): Likewise.
	* common.cc (Symbol_table::do_allocate_commons): Allocate new
	common symbol lists.  Don't call do_allocate_commons_list if the
	list is empty.
	(Symbol_table::do_allocate_commons_list): Remove is_tls
	parameter.  Add comons_section_type parameter.  Change all
	callers.  Handle small and large common symbols.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Check
	Symbol::is_common_shndx.
	* resolve.cc (symbol_to_bits): Likewise.
	* target.h (Target::small_common_shndx): New function.
	(Target::small_common_section_flags): New function.
	(Target::large_common_shndx): New function.
	(Target::large_common_section_flags): New function.
	(Target::new_output_section): New function.
	(Target::Target_info): Add small_common_shndx, large_common_shndx,
	small_common_section_flags, and large_common_section_flags
	fields.
	(Target::do_new_output_section): New virtual function.
	* arm.cc (Target_arm::arm_info): Initialize new fields.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Likewise.
	* sparc.c (Target_sparc::sparc_info) [all versions]: Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	(Target_x86_64::do_new_output_section): New function.
	* configure.ac: Define conditional MCMODEL_MEDIUM.
	* testsuite/Makefile.am (check_PROGRAMS): Add large.
	(large_SOURCES, large_CFLAGS, large_DEPENDENCIES): Define.
	(large_LDFLAGS): Define.
	* testsuite/large.c: New file.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Initialize new fields.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d64 1
a64 1
		   section_size_type)
@


1.15.4.1
log
@Merge elfcpp and gold from trunk.
@
text
@d64 1
a64 1
		   section_size_type, const Reloc_symbol_changes*)
@


1.14
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d102 5
a106 1
  0x1000				// common_pagesize
@


1.13
log
@	* options.h (class General_options): Define --wrap as a special
	option.  Add wrap_symbols_ field.
	(General_options::any_wrap_symbols): New function.
	(General_options::is_wrap_symbol): New function.
	* options.cc (General_options::parse_wrap): New function.
	(General_options::General_options): Initialize wrap_symbols_.
	* symtab.cc (Symbol_table::wrap_symbol): New function.
	(Symbol_table::add_from_object): Handle --wrap.
	* symtab.h (class Symbol_table): Declare wrap_symbol.
	* target.h (Target::wrap_char): New function.
	(Target::Target_info): Add wrap_char field.
	* i386.cc (Target_i386::i386_info): Initialize wrap_char.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Likewise.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d47 7
@


1.12
log
@	* options.cc (options::help): Print list of supported targets.
	* target-select.h: Include <vector>.
	(class Target_selector): Make machine_, size_, and is_big_endian_
	fields const.  Add bfd_name_ and instantiated_target_ fields.
	(Target_selector::Target_selector): Add bfd_name parameter.
	(Target_selector::recognize): Make non-virtual, call
	do_recognize.
	(Target_selector::recognize_by_name): Make non-virtual, call
	do_recognize_by_name.
	(Target_selector::supported_names): New function.
	(Target_selector::bfd_name): New function.
	(Target_selector::do_instantiate_target): New pure virtual
	function.
	(Target_selector::do_recognize): New virtual function.
	(Target_selector::do_recognize_by_name): New virtual function.
	(Target_selector::instantiate_target): New private function.
	(supported_target_names): Declare.
	* target-select.cc (Target_selector::Target_selector): Update for
	new parameter and fields.
	(select_target_by_name): Check that the name matches before
	calling recognize_by_name.
	(supported_target_names): New function.
	* i386.cc (class Target_selector_i386): Update Target_selector
	constructor call.  Remove recognize and recognize_by_name.  Add
	do_instantiate_target.
	* x86_64.cc (class Target_selector_x86_64): Likewise.
	* testsuite/testfile.cc (class Target_selector_test): Update for
	changes to Target_selector.
@
text
@d91 1
@


1.11
log
@Update copyright years.  Update language files.
@
text
@d140 1
a140 1
    : Target_selector(0xffff, size, big_endian)
d144 8
a151 1
  recognize(int, int, int)
d188 1
a188 1
  recognize_by_name(const char*)
d190 4
@


1.10
log
@Support selecting target by name.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.9
log
@Initial -r support.
@
text
@d179 4
@


1.8
log
@Convert more instances of off_t to be 32-bit types.
@
text
@d60 18
@


1.7
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d57 1
a57 1
		   off_t)
@


1.6
log
@Add support for PT_GNU_STACK.
@
text
@d49 2
a50 2
	      unsigned int, const unsigned char*, size_t, size_t,
	      const unsigned char*, Symbol**)
d55 3
a57 2
		   const unsigned char*, size_t, unsigned char*,
		   typename elfcpp::Elf_types<size>::Elf_Addr, off_t)
@


1.5
log
@From Craig Silverstein: implement -Ttext.
@
text
@d71 1
@


1.4
log
@Parameterize object_unittest to work for whatever target types are
supported.
@
text
@d72 1
a72 1
  0x08000000,				// text_segment_address
@


1.3
log
@Add licensing text to every source file.
@
text
@d38 2
a39 1
class Target_test : public Sized_target<32, false>
d43 1
a43 1
    : Sized_target<32, false>(&test_target_info)
d48 3
a50 3
	      Sized_relobj<32, false>*, unsigned int, unsigned int,
	      const unsigned char*, size_t, size_t, const unsigned char*,
	      Symbol**)
d54 1
a54 1
  relocate_section(const Relocate_info<32, false>*, unsigned int,
d56 1
a56 1
		   elfcpp::Elf_types<32>::Elf_Addr, off_t)
d62 2
a63 1
const Target::Target_info Target_test::test_target_info =
d65 2
a66 2
  32,					// size
  false,				// is_big_endian
d77 1
a77 1
// The single test target.
d79 3
a81 1
Target_test target_test;
d83 3
a85 1
// A pointer to the test target.  This is used in CHECKs.
d87 3
a89 1
Target* target_test_pointer = &target_test;
d91 3
a93 1
// Select the test target.
d95 21
d120 1
a120 1
    : Target_selector(0xffff, 32, false)
d125 34
a158 1
  { return &target_test; }
d161 8
a168 3
// Register the test target selector.

Target_selector_test target_selector_test;
d173 1
a173 1
const unsigned char test_file_1[] =
d349 547
a895 1
const unsigned int test_file_1_size = sizeof test_file_1;
@


1.2
log
@Update for have_code_fill field.
@
text
@d3 20
@


1.1
log
@Added a testsuite.  More support for COPY relocations.
@
text
@d48 1
@

