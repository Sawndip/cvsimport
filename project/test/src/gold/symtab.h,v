head	1.131;
access;
symbols
	binutils-2_24-branch:1.131.0.2
	binutils-2_24-branchpoint:1.131
	binutils-2_21_1:1.115
	binutils-2_23_2:1.127
	binutils-2_23_1:1.127
	binutils-2_23:1.127
	binutils-2_23-branch:1.127.0.2
	binutils-2_23-branchpoint:1.127
	binutils-2_22_branch:1.125.0.4
	binutils-2_22:1.125
	binutils-2_22-branch:1.125.0.2
	binutils-2_22-branchpoint:1.125
	binutils-2_21:1.115
	binutils-2_21-branch:1.115.0.2
	binutils-2_21-branchpoint:1.115
	binutils-2_20_1:1.90.2.2
	binutils-2_20:1.90.2.1
	binutils-arc-20081103-branch:1.83.0.4
	binutils-arc-20081103-branchpoint:1.83
	binutils-2_20-branch:1.90.0.2
	binutils-2_20-branchpoint:1.90
	dje-cgen-play1-branch:1.89.0.2
	dje-cgen-play1-branchpoint:1.89
	arc-20081103-branch:1.83.0.2
	arc-20081103-branchpoint:1.83
	binutils-2_19_1:1.82
	binutils-2_19:1.82
	binutils-2_19-branch:1.82.0.2
	binutils-2_19-branchpoint:1.82
	binutils_latest_snapshot:1.131
	added-to-binutils:1.69;
locks; strict;
comment	@ * @;


1.131
date	2013.05.21.21.14.39;	author ccoutant;	state Exp;
branches;
next	1.130;

1.130
date	2013.03.20.00.25.28;	author amodra;	state Exp;
branches;
next	1.129;

1.129
date	2013.03.10.23.08.18;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2012.08.18.11.12.50;	author amodra;	state Exp;
branches;
next	1.127;

1.127
date	2011.10.31.21.36.54;	author tmsriram;	state Exp;
branches;
next	1.126;

1.126
date	2011.10.18.00.25.52;	author ccoutant;	state Exp;
branches;
next	1.125;

1.125
date	2011.07.22.22.38.42;	author tmsriram;	state Exp;
branches
	1.125.2.1;
next	1.124;

1.124
date	2011.07.08.23.49.11;	author ian;	state Exp;
branches;
next	1.123;

1.123
date	2011.06.28.05.39.45;	author ian;	state Exp;
branches;
next	1.122;

1.122
date	2011.06.08.04.05.25;	author ccoutant;	state Exp;
branches;
next	1.121;

1.121
date	2011.06.08.03.50.11;	author ccoutant;	state Exp;
branches;
next	1.120;

1.120
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.119;

1.119
date	2011.04.12.00.44.48;	author ccoutant;	state Exp;
branches;
next	1.118;

1.118
date	2011.03.10.01.31.32;	author ian;	state Exp;
branches;
next	1.117;

1.117
date	2010.12.14.19.03.30;	author rwild;	state Exp;
branches;
next	1.116;

1.116
date	2010.11.11.10.43.30;	author rsandifo;	state Exp;
branches;
next	1.115;

1.115
date	2010.10.02.09.35.20;	author dougkwan;	state Exp;
branches;
next	1.114;

1.114
date	2010.09.12.19.58.01;	author ccoutant;	state Exp;
branches;
next	1.113;

1.113
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.112;

1.112
date	2010.08.19.22.50.15;	author ian;	state Exp;
branches;
next	1.111;

1.111
date	2010.08.12.22.15.00;	author ccoutant;	state Exp;
branches;
next	1.110;

1.110
date	2010.08.12.22.01.11;	author ccoutant;	state Exp;
branches;
next	1.109;

1.109
date	2010.08.02.13.34.33;	author ian;	state Exp;
branches;
next	1.108;

1.108
date	2010.07.09.01.34.31;	author ccoutant;	state Exp;
branches;
next	1.107;

1.107
date	2010.06.10.17.20.27;	author ccoutant;	state Exp;
branches;
next	1.106;

1.106
date	2010.04.20.21.13.30;	author tmsriram;	state Exp;
branches;
next	1.105;

1.105
date	2010.02.12.03.23.26;	author ian;	state Exp;
branches;
next	1.104;

1.104
date	2010.01.09.00.13.48;	author ian;	state Exp;
branches;
next	1.103;

1.103
date	2009.12.31.05.07.21;	author ian;	state Exp;
branches;
next	1.102;

1.102
date	2009.12.31.01.57.55;	author ian;	state Exp;
branches;
next	1.101;

1.101
date	2009.12.30.07.40.01;	author ian;	state Exp;
branches;
next	1.100;

1.100
date	2009.12.29.00.31.48;	author ian;	state Exp;
branches;
next	1.99;

1.99
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.98;

1.98
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2009.12.07.17.14.55;	author hjl;	state Exp;
branches;
next	1.96;

1.96
date	2009.11.04.01.24.41;	author ian;	state Exp;
branches;
next	1.95;

1.95
date	2009.10.14.05.25.02;	author ian;	state Exp;
branches;
next	1.94;

1.94
date	2009.10.13.00.39.31;	author tmsriram;	state Exp;
branches;
next	1.93;

1.93
date	2009.10.09.23.18.19;	author dougkwan;	state Exp;
branches;
next	1.92;

1.92
date	2009.10.01.00.58.38;	author dougkwan;	state Exp;
branches;
next	1.91;

1.91
date	2009.09.30.22.21.13;	author ian;	state Exp;
branches;
next	1.90;

1.90
date	2009.08.05.20.51.56;	author tmsriram;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2009.06.22.06.51.53;	author ian;	state Exp;
branches;
next	1.88;

1.88
date	2009.03.25.01.34.25;	author ccoutant;	state Exp;
branches;
next	1.87;

1.87
date	2009.03.17.07.07.21;	author ian;	state Exp;
branches;
next	1.86;

1.86
date	2009.02.28.04.39.57;	author ian;	state Exp;
branches;
next	1.85;

1.85
date	2009.02.27.19.57.46;	author ian;	state Exp;
branches;
next	1.84;

1.84
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	1.83;

1.83
date	2008.09.19.22.54.57;	author ccoutant;	state Exp;
branches;
next	1.82;

1.82
date	2008.08.04.22.22.13;	author ian;	state Exp;
branches;
next	1.81;

1.81
date	2008.07.23.14.36.09;	author ian;	state Exp;
branches;
next	1.80;

1.80
date	2008.07.22.22.08.43;	author ian;	state Exp;
branches;
next	1.79;

1.79
date	2008.05.21.21.37.44;	author ian;	state Exp;
branches;
next	1.78;

1.78
date	2008.05.08.18.44.33;	author ian;	state Exp;
branches;
next	1.77;

1.77
date	2008.05.07.06.08.01;	author ian;	state Exp;
branches;
next	1.76;

1.76
date	2008.05.06.17.46.31;	author ian;	state Exp;
branches;
next	1.75;

1.75
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.74;

1.74
date	2008.04.17.07.12.00;	author ian;	state Exp;
branches;
next	1.73;

1.73
date	2008.04.17.00.14.36;	author ccoutant;	state Exp;
branches;
next	1.72;

1.72
date	2008.04.09.00.48.13;	author ian;	state Exp;
branches;
next	1.71;

1.71
date	2008.04.04.17.24.47;	author ccoutant;	state Exp;
branches;
next	1.70;

1.70
date	2008.03.25.18.37.16;	author ccoutant;	state Exp;
branches;
next	1.69;

1.69
date	2008.03.14.05.57.19;	author iant;	state Exp;
branches;
next	1.68;

1.68
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.67;

1.67
date	2008.02.29.19.19.17;	author iant;	state Exp;
branches;
next	1.66;

1.66
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.65;

1.65
date	2008.02.26.21.45.30;	author iant;	state Exp;
branches;
next	1.64;

1.64
date	2008.02.13.01.20.38;	author iant;	state Exp;
branches;
next	1.63;

1.63
date	2008.02.09.01.22.17;	author iant;	state Exp;
branches;
next	1.62;

1.62
date	2008.02.08.22.49.22;	author iant;	state Exp;
branches;
next	1.61;

1.61
date	2008.02.04.05.41.40;	author iant;	state Exp;
branches;
next	1.60;

1.60
date	2008.01.26.01.17.45;	author iant;	state Exp;
branches;
next	1.59;

1.59
date	2008.01.24.00.51.57;	author iant;	state Exp;
branches;
next	1.58;

1.58
date	2008.01.24.00.15.00;	author iant;	state Exp;
branches;
next	1.57;

1.57
date	2008.01.23.07.15.59;	author iant;	state Exp;
branches;
next	1.56;

1.56
date	2008.01.15.23.41.28;	author iant;	state Exp;
branches;
next	1.55;

1.55
date	2008.01.02.23.48.49;	author iant;	state Exp;
branches;
next	1.54;

1.54
date	2007.12.20.21.21.24;	author iant;	state Exp;
branches;
next	1.53;

1.53
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.52;

1.52
date	2007.12.14.19.00.21;	author iant;	state Exp;
branches;
next	1.51;

1.51
date	2007.12.14.05.24.17;	author iant;	state Exp;
branches;
next	1.50;

1.50
date	2007.12.07.19.32.59;	author iant;	state Exp;
branches;
next	1.49;

1.49
date	2007.12.04.23.11.35;	author iant;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.22.00.05.51;	author iant;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.15.01.12.55;	author iant;	state Exp;
branches;
next	1.46;

1.46
date	2007.11.14.22.31.02;	author iant;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.14.18.44.58;	author iant;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.14.16.53.24;	author iant;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.13.20.02.32;	author iant;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.12.17.51.55;	author iant;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.09.19.45.08;	author iant;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.23.05.05.48;	author iant;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.22.23.08.22;	author iant;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.18.23.20.53;	author iant;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.16.23.23.08;	author iant;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.14.15.35.27;	author iant;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.14.07.10.20;	author iant;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.14.06.49.14;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.12.06.06.34;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.28.06.36.25;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.26.07.01.35;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.23.05.31.48;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.22.04.40.13;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.21.07.20.01;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.19.06.02.29;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.29.05.48.24;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.29.03.42.51;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.22.05.06.38;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.06.06.28.56;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2006.12.06.00.02.36;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2006.12.01.16.58.12;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.01.16.51.25;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.16.00.38.25;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.07.04.40.46;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.03.18.38.43;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.03.18.26.11;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.20.20.40.49;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.29.22.34.01;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.09.29.19.58.17;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.09.27.22.53.42;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.26.21.50.25;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.26.21.00.34;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.21.22.13.18;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.07.21.21.41;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.18.22.29.20;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.04.23.10.59;	author iant;	state Exp;
branches;
next	;

1.125.2.1
date	2011.12.19.21.14.40;	author ian;	state Exp;
branches;
next	;

1.90.2.1
date	2009.10.16.05.51.18;	author ian;	state Exp;
branches;
next	1.90.2.2;

1.90.2.2
date	2009.11.04.01.28.30;	author ian;	state Exp;
branches;
next	;


desc
@@


1.131
log
@gold/
	* symtab.h (Symbol::is_cxx_vtable): New function.
	* target-reloc.h (relocate_section): Check for vtable symbol.
	* testsuite/Makefile.am (missing_key_func.sh): New test case.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/missing_key_func.cc: New test source.
	* testsuite/missing_key_func.sh: New test script.
@
text
@// symtab.h -- the gold symbol table   -*- C++ -*-

// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

// Symbol_table
//   The symbol table.

#ifndef GOLD_SYMTAB_H
#define GOLD_SYMTAB_H

#include <string>
#include <utility>
#include <vector>

#include "elfcpp.h"
#include "parameters.h"
#include "stringpool.h"
#include "object.h"

namespace gold
{

class Mapfile;
class Object;
class Relobj;
template<int size, bool big_endian>
class Sized_relobj_file;
template<int size, bool big_endian>
class Sized_pluginobj;
class Dynobj;
template<int size, bool big_endian>
class Sized_dynobj;
template<int size, bool big_endian>
class Sized_incrobj;
class Versions;
class Version_script_info;
class Input_objects;
class Output_data;
class Output_section;
class Output_segment;
class Output_file;
class Output_symtab_xindex;
class Garbage_collection;
class Icf;

// The base class of an entry in the symbol table.  The symbol table
// can have a lot of entries, so we don't want this class too big.
// Size dependent fields can be found in the template class
// Sized_symbol.  Targets may support their own derived classes.

class Symbol
{
 public:
  // Because we want the class to be small, we don't use any virtual
  // functions.  But because symbols can be defined in different
  // places, we need to classify them.  This enum is the different
  // sources of symbols we support.
  enum Source
  {
    // Symbol defined in a relocatable or dynamic input file--this is
    // the most common case.
    FROM_OBJECT,
    // Symbol defined in an Output_data, a special section created by
    // the target.
    IN_OUTPUT_DATA,
    // Symbol defined in an Output_segment, with no associated
    // section.
    IN_OUTPUT_SEGMENT,
    // Symbol value is constant.
    IS_CONSTANT,
    // Symbol is undefined.
    IS_UNDEFINED
  };

  // When the source is IN_OUTPUT_SEGMENT, we need to describe what
  // the offset means.
  enum Segment_offset_base
  {
    // From the start of the segment.
    SEGMENT_START,
    // From the end of the segment.
    SEGMENT_END,
    // From the filesz of the segment--i.e., after the loaded bytes
    // but before the bytes which are allocated but zeroed.
    SEGMENT_BSS
  };

  // Return the symbol name.
  const char*
  name() const
  { return this->name_; }

  // Return the (ANSI) demangled version of the name, if
  // parameters.demangle() is true.  Otherwise, return the name.  This
  // is intended to be used only for logging errors, so it's not
  // super-efficient.
  std::string
  demangled_name() const;

  // Return the symbol version.  This will return NULL for an
  // unversioned symbol.
  const char*
  version() const
  { return this->version_; }

  void
  clear_version()
  { this->version_ = NULL; }

  // Return whether this version is the default for this symbol name
  // (eg, "foo@@@@V2" is a default version; "foo@@V1" is not).  Only
  // meaningful for versioned symbols.
  bool
  is_default() const
  {
    gold_assert(this->version_ != NULL);
    return this->is_def_;
  }

  // Set that this version is the default for this symbol name.
  void
  set_is_default()
  { this->is_def_ = true; }

  // Return the symbol's name as name@@version (or name@@@@version).
  std::string
  versioned_name() const;

  // Return the symbol source.
  Source
  source() const
  { return this->source_; }

  // Return the object with which this symbol is associated.
  Object*
  object() const
  {
    gold_assert(this->source_ == FROM_OBJECT);
    return this->u_.from_object.object;
  }

  // Return the index of the section in the input relocatable or
  // dynamic object file.
  unsigned int
  shndx(bool* is_ordinary) const
  {
    gold_assert(this->source_ == FROM_OBJECT);
    *is_ordinary = this->is_ordinary_shndx_;
    return this->u_.from_object.shndx;
  }

  // Return the output data section with which this symbol is
  // associated, if the symbol was specially defined with respect to
  // an output data section.
  Output_data*
  output_data() const
  {
    gold_assert(this->source_ == IN_OUTPUT_DATA);
    return this->u_.in_output_data.output_data;
  }

  // If this symbol was defined with respect to an output data
  // section, return whether the value is an offset from end.
  bool
  offset_is_from_end() const
  {
    gold_assert(this->source_ == IN_OUTPUT_DATA);
    return this->u_.in_output_data.offset_is_from_end;
  }

  // Return the output segment with which this symbol is associated,
  // if the symbol was specially defined with respect to an output
  // segment.
  Output_segment*
  output_segment() const
  {
    gold_assert(this->source_ == IN_OUTPUT_SEGMENT);
    return this->u_.in_output_segment.output_segment;
  }

  // If this symbol was defined with respect to an output segment,
  // return the offset base.
  Segment_offset_base
  offset_base() const
  {
    gold_assert(this->source_ == IN_OUTPUT_SEGMENT);
    return this->u_.in_output_segment.offset_base;
  }

  // Return the symbol binding.
  elfcpp::STB
  binding() const
  { return this->binding_; }

  // Return the symbol type.
  elfcpp::STT
  type() const
  { return this->type_; }

  // Return true for function symbol.
  bool
  is_func() const
  {
    return (this->type_ == elfcpp::STT_FUNC
	    || this->type_ == elfcpp::STT_GNU_IFUNC);
  }

  // Return the symbol visibility.
  elfcpp::STV
  visibility() const
  { return this->visibility_; }

  // Set the visibility.
  void
  set_visibility(elfcpp::STV visibility)
  { this->visibility_ = visibility; }

  // Override symbol visibility.
  void
  override_visibility(elfcpp::STV);

  // Set whether the symbol was originally a weak undef or a regular undef
  // when resolved by a dynamic def.
  inline void
  set_undef_binding(elfcpp::STB bind)
  {
    if (!this->undef_binding_set_ || this->undef_binding_weak_)
      {
        this->undef_binding_weak_ = bind == elfcpp::STB_WEAK;
        this->undef_binding_set_ = true;
      }
  }

  // Return TRUE if a weak undef was resolved by a dynamic def.
  inline bool
  is_undef_binding_weak() const
  { return this->undef_binding_weak_; }

  // Return the non-visibility part of the st_other field.
  unsigned char
  nonvis() const
  { return this->nonvis_; }

  // Return whether this symbol is a forwarder.  This will never be
  // true of a symbol found in the hash table, but may be true of
  // symbol pointers attached to object files.
  bool
  is_forwarder() const
  { return this->is_forwarder_; }

  // Mark this symbol as a forwarder.
  void
  set_forwarder()
  { this->is_forwarder_ = true; }

  // Return whether this symbol has an alias in the weak aliases table
  // in Symbol_table.
  bool
  has_alias() const
  { return this->has_alias_; }

  // Mark this symbol as having an alias.
  void
  set_has_alias()
  { this->has_alias_ = true; }

  // Return whether this symbol needs an entry in the dynamic symbol
  // table.
  bool
  needs_dynsym_entry() const
  {
    return (this->needs_dynsym_entry_
            || (this->in_reg()
		&& this->in_dyn()
		&& this->is_externally_visible()));
  }

  // Mark this symbol as needing an entry in the dynamic symbol table.
  void
  set_needs_dynsym_entry()
  { this->needs_dynsym_entry_ = true; }

  // Return whether this symbol should be added to the dynamic symbol
  // table.
  bool
  should_add_dynsym_entry(Symbol_table*) const;

  // Return whether this symbol has been seen in a regular object.
  bool
  in_reg() const
  { return this->in_reg_; }

  // Mark this symbol as having been seen in a regular object.
  void
  set_in_reg()
  { this->in_reg_ = true; }

  // Return whether this symbol has been seen in a dynamic object.
  bool
  in_dyn() const
  { return this->in_dyn_; }

  // Mark this symbol as having been seen in a dynamic object.
  void
  set_in_dyn()
  { this->in_dyn_ = true; }

  // Return whether this symbol has been seen in a real ELF object.
  // (IN_REG will return TRUE if the symbol has been seen in either
  // a real ELF object or an object claimed by a plugin.)
  bool
  in_real_elf() const
  { return this->in_real_elf_; }

  // Mark this symbol as having been seen in a real ELF object.
  void
  set_in_real_elf()
  { this->in_real_elf_ = true; }

  // Return whether this symbol was defined in a section that was
  // discarded from the link.  This is used to control some error
  // reporting.
  bool
  is_defined_in_discarded_section() const
  { return this->is_defined_in_discarded_section_; }

  // Mark this symbol as having been defined in a discarded section.
  void
  set_is_defined_in_discarded_section()
  { this->is_defined_in_discarded_section_ = true; }

  // Return the index of this symbol in the output file symbol table.
  // A value of -1U means that this symbol is not going into the
  // output file.  This starts out as zero, and is set to a non-zero
  // value by Symbol_table::finalize.  It is an error to ask for the
  // symbol table index before it has been set.
  unsigned int
  symtab_index() const
  {
    gold_assert(this->symtab_index_ != 0);
    return this->symtab_index_;
  }

  // Set the index of the symbol in the output file symbol table.
  void
  set_symtab_index(unsigned int index)
  {
    gold_assert(index != 0);
    this->symtab_index_ = index;
  }

  // Return whether this symbol already has an index in the output
  // file symbol table.
  bool
  has_symtab_index() const
  { return this->symtab_index_ != 0; }

  // Return the index of this symbol in the dynamic symbol table.  A
  // value of -1U means that this symbol is not going into the dynamic
  // symbol table.  This starts out as zero, and is set to a non-zero
  // during Layout::finalize.  It is an error to ask for the dynamic
  // symbol table index before it has been set.
  unsigned int
  dynsym_index() const
  {
    gold_assert(this->dynsym_index_ != 0);
    return this->dynsym_index_;
  }

  // Set the index of the symbol in the dynamic symbol table.
  void
  set_dynsym_index(unsigned int index)
  {
    gold_assert(index != 0);
    this->dynsym_index_ = index;
  }

  // Return whether this symbol already has an index in the dynamic
  // symbol table.
  bool
  has_dynsym_index() const
  { return this->dynsym_index_ != 0; }

  // Return whether this symbol has an entry in the GOT section.
  // For a TLS symbol, this GOT entry will hold its tp-relative offset.
  bool
  has_got_offset(unsigned int got_type) const
  { return this->got_offsets_.get_offset(got_type) != -1U; }

  // Return the offset into the GOT section of this symbol.
  unsigned int
  got_offset(unsigned int got_type) const
  {
    unsigned int got_offset = this->got_offsets_.get_offset(got_type);
    gold_assert(got_offset != -1U);
    return got_offset;
  }

  // Set the GOT offset of this symbol.
  void
  set_got_offset(unsigned int got_type, unsigned int got_offset)
  { this->got_offsets_.set_offset(got_type, got_offset); }

  // Return the GOT offset list.
  const Got_offset_list*
  got_offset_list() const
  { return this->got_offsets_.get_list(); }

  // Return whether this symbol has an entry in the PLT section.
  bool
  has_plt_offset() const
  { return this->plt_offset_ != -1U; }

  // Return the offset into the PLT section of this symbol.
  unsigned int
  plt_offset() const
  {
    gold_assert(this->has_plt_offset());
    return this->plt_offset_;
  }

  // Set the PLT offset of this symbol.
  void
  set_plt_offset(unsigned int plt_offset)
  {
    gold_assert(plt_offset != -1U);
    this->plt_offset_ = plt_offset;
  }

  // Return whether this dynamic symbol needs a special value in the
  // dynamic symbol table.
  bool
  needs_dynsym_value() const
  { return this->needs_dynsym_value_; }

  // Set that this dynamic symbol needs a special value in the dynamic
  // symbol table.
  void
  set_needs_dynsym_value()
  {
    gold_assert(this->object()->is_dynamic());
    this->needs_dynsym_value_ = true;
  }

  // Return true if the final value of this symbol is known at link
  // time.
  bool
  final_value_is_known() const;

  // Return true if SHNDX represents a common symbol.  This depends on
  // the target.
  static bool
  is_common_shndx(unsigned int shndx);

  // Return whether this is a defined symbol (not undefined or
  // common).
  bool
  is_defined() const
  {
    bool is_ordinary;
    if (this->source_ != FROM_OBJECT)
      return this->source_ != IS_UNDEFINED;
    unsigned int shndx = this->shndx(&is_ordinary);
    return (is_ordinary
	    ? shndx != elfcpp::SHN_UNDEF
	    : !Symbol::is_common_shndx(shndx));
  }

  // Return true if this symbol is from a dynamic object.
  bool
  is_from_dynobj() const
  {
    return this->source_ == FROM_OBJECT && this->object()->is_dynamic();
  }

  // Return whether this is a placeholder symbol from a plugin object.
  bool
  is_placeholder() const
  {
    return this->source_ == FROM_OBJECT && this->object()->pluginobj() != NULL;
  }

  // Return whether this is an undefined symbol.
  bool
  is_undefined() const
  {
    bool is_ordinary;
    return ((this->source_ == FROM_OBJECT
	     && this->shndx(&is_ordinary) == elfcpp::SHN_UNDEF
	     && is_ordinary)
	    || this->source_ == IS_UNDEFINED);
  }

  // Return whether this is a weak undefined symbol.
  bool
  is_weak_undefined() const
  { return this->is_undefined() && this->binding() == elfcpp::STB_WEAK; }

  // Return whether this is an absolute symbol.
  bool
  is_absolute() const
  {
    bool is_ordinary;
    return ((this->source_ == FROM_OBJECT
	     && this->shndx(&is_ordinary) == elfcpp::SHN_ABS
	     && !is_ordinary)
	    || this->source_ == IS_CONSTANT);
  }

  // Return whether this is a common symbol.
  bool
  is_common() const
  {
    if (this->source_ != FROM_OBJECT)
      return false;
    if (this->type_ == elfcpp::STT_COMMON)
      return true;
    bool is_ordinary;
    unsigned int shndx = this->shndx(&is_ordinary);
    return !is_ordinary && Symbol::is_common_shndx(shndx);
  }

  // Return whether this symbol can be seen outside this object.
  bool
  is_externally_visible() const
  {
    return ((this->visibility_ == elfcpp::STV_DEFAULT
             || this->visibility_ == elfcpp::STV_PROTECTED)
	    && !this->is_forced_local_);
  }

  // Return true if this symbol can be preempted by a definition in
  // another link unit.
  bool
  is_preemptible() const
  {
    // It doesn't make sense to ask whether a symbol defined in
    // another object is preemptible.
    gold_assert(!this->is_from_dynobj());

    // It doesn't make sense to ask whether an undefined symbol
    // is preemptible.
    gold_assert(!this->is_undefined());

    // If a symbol does not have default visibility, it can not be
    // seen outside this link unit and therefore is not preemptible.
    if (this->visibility_ != elfcpp::STV_DEFAULT)
      return false;

    // If this symbol has been forced to be a local symbol by a
    // version script, then it is not visible outside this link unit
    // and is not preemptible.
    if (this->is_forced_local_)
      return false;

    // If we are not producing a shared library, then nothing is
    // preemptible.
    if (!parameters->options().shared())
      return false;

    // If the user used -Bsymbolic, then nothing is preemptible.
    if (parameters->options().Bsymbolic())
      return false;

    // If the user used -Bsymbolic-functions, then functions are not
    // preemptible.  We explicitly check for not being STT_OBJECT,
    // rather than for being STT_FUNC, because that is what the GNU
    // linker does.
    if (this->type() != elfcpp::STT_OBJECT
	&& parameters->options().Bsymbolic_functions())
      return false;

    // Otherwise the symbol is preemptible.
    return true;
  }

  // Return true if this symbol is a function that needs a PLT entry.
  bool
  needs_plt_entry() const
  {
    // An undefined symbol from an executable does not need a PLT entry.
    if (this->is_undefined() && !parameters->options().shared())
      return false;

    // An STT_GNU_IFUNC symbol always needs a PLT entry, even when
    // doing a static link.
    if (this->type() == elfcpp::STT_GNU_IFUNC)
      return true;

    // We only need a PLT entry for a function.
    if (!this->is_func())
      return false;

    // If we're doing a static link or a -pie link, we don't create
    // PLT entries.
    if (parameters->doing_static_link()
	|| parameters->options().pie())
      return false;

    // We need a PLT entry if the function is defined in a dynamic
    // object, or is undefined when building a shared object, or if it
    // is subject to pre-emption.
    return (this->is_from_dynobj()
	    || this->is_undefined()
	    || this->is_preemptible());
  }

  // When determining whether a reference to a symbol needs a dynamic
  // relocation, we need to know several things about the reference.
  // These flags may be or'ed together.  0 means that the symbol
  // isn't referenced at all.
  enum Reference_flags
  {
    // A reference to the symbol's absolute address.  This includes
    // references that cause an absolute address to be stored in the GOT.
    ABSOLUTE_REF = 1,
    // A reference that calculates the offset of the symbol from some
    // anchor point, such as the PC or GOT.
    RELATIVE_REF = 2,
    // A TLS-related reference.
    TLS_REF = 4,
    // A reference that can always be treated as a function call.
    FUNCTION_CALL = 8
  };

  // Given a direct absolute or pc-relative static relocation against
  // the global symbol, this function returns whether a dynamic relocation
  // is needed.

  bool
  needs_dynamic_reloc(int flags) const
  {
    // No dynamic relocations in a static link!
    if (parameters->doing_static_link())
      return false;

    // A reference to an undefined symbol from an executable should be
    // statically resolved to 0, and does not need a dynamic relocation.
    // This matches gnu ld behavior.
    if (this->is_undefined() && !parameters->options().shared())
      return false;

    // A reference to an absolute symbol does not need a dynamic relocation.
    if (this->is_absolute())
      return false;

    // An absolute reference within a position-independent output file
    // will need a dynamic relocation.
    if ((flags & ABSOLUTE_REF)
        && parameters->options().output_is_position_independent())
      return true;

    // A function call that can branch to a local PLT entry does not need
    // a dynamic relocation.
    if ((flags & FUNCTION_CALL) && this->has_plt_offset())
      return false;

    // A reference to any PLT entry in a non-position-independent executable
    // does not need a dynamic relocation.
    if (!parameters->options().output_is_position_independent()
        && this->has_plt_offset())
      return false;

    // A reference to a symbol defined in a dynamic object or to a
    // symbol that is preemptible will need a dynamic relocation.
    if (this->is_from_dynobj()
        || this->is_undefined()
        || this->is_preemptible())
      return true;

    // For all other cases, return FALSE.
    return false;
  }

  // Whether we should use the PLT offset associated with a symbol for
  // a relocation.  FLAGS is a set of Reference_flags.

  bool
  use_plt_offset(int flags) const
  {
    // If the symbol doesn't have a PLT offset, then naturally we
    // don't want to use it.
    if (!this->has_plt_offset())
      return false;

    // For a STT_GNU_IFUNC symbol we always have to use the PLT entry.
    if (this->type() == elfcpp::STT_GNU_IFUNC)
      return true;

    // If we are going to generate a dynamic relocation, then we will
    // wind up using that, so no need to use the PLT entry.
    if (this->needs_dynamic_reloc(flags))
      return false;

    // If the symbol is from a dynamic object, we need to use the PLT
    // entry.
    if (this->is_from_dynobj())
      return true;

    // If we are generating a shared object, and this symbol is
    // undefined or preemptible, we need to use the PLT entry.
    if (parameters->options().shared()
	&& (this->is_undefined() || this->is_preemptible()))
      return true;

    // If this is a call to a weak undefined symbol, we need to use
    // the PLT entry; the symbol may be defined by a library loaded
    // at runtime.
    if ((flags & FUNCTION_CALL) && this->is_weak_undefined())
      return true;

    // Otherwise we can use the regular definition.
    return false;
  }

  // Given a direct absolute static relocation against
  // the global symbol, where a dynamic relocation is needed, this
  // function returns whether a relative dynamic relocation can be used.
  // The caller must determine separately whether the static relocation
  // is compatible with a relative relocation.

  bool
  can_use_relative_reloc(bool is_function_call) const
  {
    // A function call that can branch to a local PLT entry can
    // use a RELATIVE relocation.
    if (is_function_call && this->has_plt_offset())
      return true;

    // A reference to a symbol defined in a dynamic object or to a
    // symbol that is preemptible can not use a RELATIVE relocation.
    if (this->is_from_dynobj()
        || this->is_undefined()
        || this->is_preemptible())
      return false;

    // For all other cases, return TRUE.
    return true;
  }

  // Return the output section where this symbol is defined.  Return
  // NULL if the symbol has an absolute value.
  Output_section*
  output_section() const;

  // Set the symbol's output section.  This is used for symbols
  // defined in scripts.  This should only be called after the symbol
  // table has been finalized.
  void
  set_output_section(Output_section*);

  // Return whether there should be a warning for references to this
  // symbol.
  bool
  has_warning() const
  { return this->has_warning_; }

  // Mark this symbol as having a warning.
  void
  set_has_warning()
  { this->has_warning_ = true; }

  // Return whether this symbol is defined by a COPY reloc from a
  // dynamic object.
  bool
  is_copied_from_dynobj() const
  { return this->is_copied_from_dynobj_; }

  // Mark this symbol as defined by a COPY reloc.
  void
  set_is_copied_from_dynobj()
  { this->is_copied_from_dynobj_ = true; }

  // Return whether this symbol is forced to visibility STB_LOCAL
  // by a "local:" entry in a version script.
  bool
  is_forced_local() const
  { return this->is_forced_local_; }

  // Mark this symbol as forced to STB_LOCAL visibility.
  void
  set_is_forced_local()
  { this->is_forced_local_ = true; }

  // Return true if this may need a COPY relocation.
  // References from an executable object to non-function symbols
  // defined in a dynamic object may need a COPY relocation.
  bool
  may_need_copy_reloc() const
  {
    return (!parameters->options().output_is_position_independent()
	    && parameters->options().copyreloc()
	    && this->is_from_dynobj()
	    && !this->is_func());
  }

  // Return true if this symbol was predefined by the linker.
  bool
  is_predefined() const
  { return this->is_predefined_; }

  // Return true if this is a C++ vtable symbol.
  bool
  is_cxx_vtable() const
  { return is_prefix_of("_ZTV", this->name_); }

 protected:
  // Instances of this class should always be created at a specific
  // size.
  Symbol()
  { memset(this, 0, sizeof *this); }

  // Initialize the general fields.
  void
  init_fields(const char* name, const char* version,
	      elfcpp::STT type, elfcpp::STB binding,
	      elfcpp::STV visibility, unsigned char nonvis);

  // Initialize fields from an ELF symbol in OBJECT.  ST_SHNDX is the
  // section index, IS_ORDINARY is whether it is a normal section
  // index rather than a special code.
  template<int size, bool big_endian>
  void
  init_base_object(const char* name, const char* version, Object* object,
		   const elfcpp::Sym<size, big_endian>&, unsigned int st_shndx,
		   bool is_ordinary);

  // Initialize fields for an Output_data.
  void
  init_base_output_data(const char* name, const char* version, Output_data*,
			elfcpp::STT, elfcpp::STB, elfcpp::STV,
			unsigned char nonvis, bool offset_is_from_end,
			bool is_predefined);

  // Initialize fields for an Output_segment.
  void
  init_base_output_segment(const char* name, const char* version,
			   Output_segment* os, elfcpp::STT type,
			   elfcpp::STB binding, elfcpp::STV visibility,
			   unsigned char nonvis,
			   Segment_offset_base offset_base,
			   bool is_predefined);

  // Initialize fields for a constant.
  void
  init_base_constant(const char* name, const char* version, elfcpp::STT type,
		     elfcpp::STB binding, elfcpp::STV visibility,
		     unsigned char nonvis, bool is_predefined);

  // Initialize fields for an undefined symbol.
  void
  init_base_undefined(const char* name, const char* version, elfcpp::STT type,
		      elfcpp::STB binding, elfcpp::STV visibility,
		      unsigned char nonvis);

  // Override existing symbol.
  template<int size, bool big_endian>
  void
  override_base(const elfcpp::Sym<size, big_endian>&, unsigned int st_shndx,
		bool is_ordinary, Object* object, const char* version);

  // Override existing symbol with a special symbol.
  void
  override_base_with_special(const Symbol* from);

  // Override symbol version.
  void
  override_version(const char* version);

  // Allocate a common symbol by giving it a location in the output
  // file.
  void
  allocate_base_common(Output_data*);

 private:
  Symbol(const Symbol&);
  Symbol& operator=(const Symbol&);

  // Symbol name (expected to point into a Stringpool).
  const char* name_;
  // Symbol version (expected to point into a Stringpool).  This may
  // be NULL.
  const char* version_;

  union
  {
    // This struct is used if SOURCE_ == FROM_OBJECT.
    struct
    {
      // Object in which symbol is defined, or in which it was first
      // seen.
      Object* object;
      // Section number in object_ in which symbol is defined.
      unsigned int shndx;
    } from_object;

    // This struct is used if SOURCE_ == IN_OUTPUT_DATA.
    struct
    {
      // Output_data in which symbol is defined.  Before
      // Layout::finalize the symbol's value is an offset within the
      // Output_data.
      Output_data* output_data;
      // True if the offset is from the end, false if the offset is
      // from the beginning.
      bool offset_is_from_end;
    } in_output_data;

    // This struct is used if SOURCE_ == IN_OUTPUT_SEGMENT.
    struct
    {
      // Output_segment in which the symbol is defined.  Before
      // Layout::finalize the symbol's value is an offset.
      Output_segment* output_segment;
      // The base to use for the offset before Layout::finalize.
      Segment_offset_base offset_base;
    } in_output_segment;
  } u_;

  // The index of this symbol in the output file.  If the symbol is
  // not going into the output file, this value is -1U.  This field
  // starts as always holding zero.  It is set to a non-zero value by
  // Symbol_table::finalize.
  unsigned int symtab_index_;

  // The index of this symbol in the dynamic symbol table.  If the
  // symbol is not going into the dynamic symbol table, this value is
  // -1U.  This field starts as always holding zero.  It is set to a
  // non-zero value during Layout::finalize.
  unsigned int dynsym_index_;

  // The GOT section entries for this symbol.  A symbol may have more
  // than one GOT offset (e.g., when mixing modules compiled with two
  // different TLS models), but will usually have at most one.
  Got_offset_list got_offsets_;

  // If this symbol has an entry in the PLT section, then this is the
  // offset from the start of the PLT section.  This is -1U if there
  // is no PLT entry.
  unsigned int plt_offset_;

  // Symbol type (bits 0 to 3).
  elfcpp::STT type_ : 4;
  // Symbol binding (bits 4 to 7).
  elfcpp::STB binding_ : 4;
  // Symbol visibility (bits 8 to 9).
  elfcpp::STV visibility_ : 2;
  // Rest of symbol st_other field (bits 10 to 15).
  unsigned int nonvis_ : 6;
  // The type of symbol (bits 16 to 18).
  Source source_ : 3;
  // True if this is the default version of the symbol (bit 19).
  bool is_def_ : 1;
  // True if this symbol really forwards to another symbol.  This is
  // used when we discover after the fact that two different entries
  // in the hash table really refer to the same symbol.  This will
  // never be set for a symbol found in the hash table, but may be set
  // for a symbol found in the list of symbols attached to an Object.
  // It forwards to the symbol found in the forwarders_ map of
  // Symbol_table (bit 20).
  bool is_forwarder_ : 1;
  // True if the symbol has an alias in the weak_aliases table in
  // Symbol_table (bit 21).
  bool has_alias_ : 1;
  // True if this symbol needs to be in the dynamic symbol table (bit
  // 22).
  bool needs_dynsym_entry_ : 1;
  // True if we've seen this symbol in a regular object (bit 23).
  bool in_reg_ : 1;
  // True if we've seen this symbol in a dynamic object (bit 24).
  bool in_dyn_ : 1;
  // True if this is a dynamic symbol which needs a special value in
  // the dynamic symbol table (bit 25).
  bool needs_dynsym_value_ : 1;
  // True if there is a warning for this symbol (bit 26).
  bool has_warning_ : 1;
  // True if we are using a COPY reloc for this symbol, so that the
  // real definition lives in a dynamic object (bit 27).
  bool is_copied_from_dynobj_ : 1;
  // True if this symbol was forced to local visibility by a version
  // script (bit 28).
  bool is_forced_local_ : 1;
  // True if the field u_.from_object.shndx is an ordinary section
  // index, not one of the special codes from SHN_LORESERVE to
  // SHN_HIRESERVE (bit 29).
  bool is_ordinary_shndx_ : 1;
  // True if we've seen this symbol in a "real" ELF object (bit 30).
  // If the symbol has been seen in a relocatable, non-IR, object file,
  // it's known to be referenced from outside the IR.  A reference from
  // a dynamic object doesn't count as a "real" ELF, and we'll simply
  // mark the symbol as "visible" from outside the IR.  The compiler
  // can use this distinction to guide its handling of COMDAT symbols.
  bool in_real_elf_ : 1;
  // True if this symbol is defined in a section which was discarded
  // (bit 31).
  bool is_defined_in_discarded_section_ : 1;
  // True if UNDEF_BINDING_WEAK_ has been set (bit 32).
  bool undef_binding_set_ : 1;
  // True if this symbol was a weak undef resolved by a dynamic def
  // (bit 33).
  bool undef_binding_weak_ : 1;
  // True if this symbol is a predefined linker symbol (bit 34).
  bool is_predefined_ : 1;
};

// The parts of a symbol which are size specific.  Using a template
// derived class like this helps us use less space on a 32-bit system.

template<int size>
class Sized_symbol : public Symbol
{
 public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Value_type;
  typedef typename elfcpp::Elf_types<size>::Elf_WXword Size_type;

  Sized_symbol()
  { }

  // Initialize fields from an ELF symbol in OBJECT.  ST_SHNDX is the
  // section index, IS_ORDINARY is whether it is a normal section
  // index rather than a special code.
  template<bool big_endian>
  void
  init_object(const char* name, const char* version, Object* object,
	      const elfcpp::Sym<size, big_endian>&, unsigned int st_shndx,
	      bool is_ordinary);

  // Initialize fields for an Output_data.
  void
  init_output_data(const char* name, const char* version, Output_data*,
		   Value_type value, Size_type symsize, elfcpp::STT,
		   elfcpp::STB, elfcpp::STV, unsigned char nonvis,
		   bool offset_is_from_end, bool is_predefined);

  // Initialize fields for an Output_segment.
  void
  init_output_segment(const char* name, const char* version, Output_segment*,
		      Value_type value, Size_type symsize, elfcpp::STT,
		      elfcpp::STB, elfcpp::STV, unsigned char nonvis,
		      Segment_offset_base offset_base, bool is_predefined);

  // Initialize fields for a constant.
  void
  init_constant(const char* name, const char* version, Value_type value,
		Size_type symsize, elfcpp::STT, elfcpp::STB, elfcpp::STV,
		unsigned char nonvis, bool is_predefined);

  // Initialize fields for an undefined symbol.
  void
  init_undefined(const char* name, const char* version, elfcpp::STT,
		 elfcpp::STB, elfcpp::STV, unsigned char nonvis);

  // Override existing symbol.
  template<bool big_endian>
  void
  override(const elfcpp::Sym<size, big_endian>&, unsigned int st_shndx,
	   bool is_ordinary, Object* object, const char* version);

  // Override existing symbol with a special symbol.
  void
  override_with_special(const Sized_symbol<size>*);

  // Return the symbol's value.
  Value_type
  value() const
  { return this->value_; }

  // Return the symbol's size (we can't call this 'size' because that
  // is a template parameter).
  Size_type
  symsize() const
  { return this->symsize_; }

  // Set the symbol size.  This is used when resolving common symbols.
  void
  set_symsize(Size_type symsize)
  { this->symsize_ = symsize; }

  // Set the symbol value.  This is called when we store the final
  // values of the symbols into the symbol table.
  void
  set_value(Value_type value)
  { this->value_ = value; }

  // Allocate a common symbol by giving it a location in the output
  // file.
  void
  allocate_common(Output_data*, Value_type value);

 private:
  Sized_symbol(const Sized_symbol&);
  Sized_symbol& operator=(const Sized_symbol&);

  // Symbol value.  Before Layout::finalize this is the offset in the
  // input section.  This is set to the final value during
  // Layout::finalize.
  Value_type value_;
  // Symbol size.
  Size_type symsize_;
};

// A struct describing a symbol defined by the linker, where the value
// of the symbol is defined based on an output section.  This is used
// for symbols defined by the linker, like "_init_array_start".

struct Define_symbol_in_section
{
  // The symbol name.
  const char* name;
  // The name of the output section with which this symbol should be
  // associated.  If there is no output section with that name, the
  // symbol will be defined as zero.
  const char* output_section;
  // The offset of the symbol within the output section.  This is an
  // offset from the start of the output section, unless start_at_end
  // is true, in which case this is an offset from the end of the
  // output section.
  uint64_t value;
  // The size of the symbol.
  uint64_t size;
  // The symbol type.
  elfcpp::STT type;
  // The symbol binding.
  elfcpp::STB binding;
  // The symbol visibility.
  elfcpp::STV visibility;
  // The rest of the st_other field.
  unsigned char nonvis;
  // If true, the value field is an offset from the end of the output
  // section.
  bool offset_is_from_end;
  // If true, this symbol is defined only if we see a reference to it.
  bool only_if_ref;
};

// A struct describing a symbol defined by the linker, where the value
// of the symbol is defined based on a segment.  This is used for
// symbols defined by the linker, like "_end".  We describe the
// segment with which the symbol should be associated by its
// characteristics.  If no segment meets these characteristics, the
// symbol will be defined as zero.  If there is more than one segment
// which meets these characteristics, we will use the first one.

struct Define_symbol_in_segment
{
  // The symbol name.
  const char* name;
  // The segment type where the symbol should be defined, typically
  // PT_LOAD.
  elfcpp::PT segment_type;
  // Bitmask of segment flags which must be set.
  elfcpp::PF segment_flags_set;
  // Bitmask of segment flags which must be clear.
  elfcpp::PF segment_flags_clear;
  // The offset of the symbol within the segment.  The offset is
  // calculated from the position set by offset_base.
  uint64_t value;
  // The size of the symbol.
  uint64_t size;
  // The symbol type.
  elfcpp::STT type;
  // The symbol binding.
  elfcpp::STB binding;
  // The symbol visibility.
  elfcpp::STV visibility;
  // The rest of the st_other field.
  unsigned char nonvis;
  // The base from which we compute the offset.
  Symbol::Segment_offset_base offset_base;
  // If true, this symbol is defined only if we see a reference to it.
  bool only_if_ref;
};

// Specify an object/section/offset location.  Used by ODR code.

struct Symbol_location
{
  // Object where the symbol is defined.
  Object* object;
  // Section-in-object where the symbol is defined.
  unsigned int shndx;
  // For relocatable objects, offset-in-section where the symbol is defined.
  // For dynamic objects, address where the symbol is defined.
  off_t offset;
  bool operator==(const Symbol_location& that) const
  {
    return (this->object == that.object
	    && this->shndx == that.shndx
	    && this->offset == that.offset);
  }
};

// This class manages warnings.  Warnings are a GNU extension.  When
// we see a section named .gnu.warning.SYM in an object file, and if
// we wind using the definition of SYM from that object file, then we
// will issue a warning for any relocation against SYM from a
// different object file.  The text of the warning is the contents of
// the section.  This is not precisely the definition used by the old
// GNU linker; the old GNU linker treated an occurrence of
// .gnu.warning.SYM as defining a warning symbol.  A warning symbol
// would trigger a warning on any reference.  However, it was
// inconsistent in that a warning in a dynamic object only triggered
// if there was no definition in a regular object.  This linker is
// different in that we only issue a warning if we use the symbol
// definition from the same object file as the warning section.

class Warnings
{
 public:
  Warnings()
    : warnings_()
  { }

  // Add a warning for symbol NAME in object OBJ.  WARNING is the text
  // of the warning.
  void
  add_warning(Symbol_table* symtab, const char* name, Object* obj,
	      const std::string& warning);

  // For each symbol for which we should give a warning, make a note
  // on the symbol.
  void
  note_warnings(Symbol_table* symtab);

  // Issue a warning for a reference to SYM at RELINFO's location.
  template<int size, bool big_endian>
  void
  issue_warning(const Symbol* sym, const Relocate_info<size, big_endian>*,
		size_t relnum, off_t reloffset) const;

 private:
  Warnings(const Warnings&);
  Warnings& operator=(const Warnings&);

  // What we need to know to get the warning text.
  struct Warning_location
  {
    // The object the warning is in.
    Object* object;
    // The warning text.
    std::string text;

    Warning_location()
      : object(NULL), text()
    { }

    void
    set(Object* o, const std::string& t)
    {
      this->object = o;
      this->text = t;
    }
  };

  // A mapping from warning symbol names (canonicalized in
  // Symbol_table's namepool_ field) to warning information.
  typedef Unordered_map<const char*, Warning_location> Warning_table;

  Warning_table warnings_;
};

// The main linker symbol table.

class Symbol_table
{
 public:
  // The different places where a symbol definition can come from.
  enum Defined
  {
    // Defined in an object file--the normal case.
    OBJECT,
    // Defined for a COPY reloc.
    COPY,
    // Defined on the command line using --defsym.
    DEFSYM,
    // Defined (so to speak) on the command line using -u.
    UNDEFINED,
    // Defined in a linker script.
    SCRIPT,
    // Predefined by the linker.
    PREDEFINED,
    // Defined by the linker during an incremental base link, but not
    // a predefined symbol (e.g., common, defined in script).
    INCREMENTAL_BASE,
  };

  // The order in which we sort common symbols.
  enum Sort_commons_order
  {
    SORT_COMMONS_BY_SIZE_DESCENDING,
    SORT_COMMONS_BY_ALIGNMENT_DESCENDING,
    SORT_COMMONS_BY_ALIGNMENT_ASCENDING
  };

  // COUNT is an estimate of how many symbols will be inserted in the
  // symbol table.  It's ok to put 0 if you don't know; a correct
  // guess will just save some CPU by reducing hashtable resizes.
  Symbol_table(unsigned int count, const Version_script_info& version_script);

  ~Symbol_table();

  void
  set_icf(Icf* icf)
  { this->icf_ = icf;}

  Icf*
  icf() const
  { return this->icf_; }
 
  // Returns true if ICF determined that this is a duplicate section. 
  bool
  is_section_folded(Object* obj, unsigned int shndx) const;

  void
  set_gc(Garbage_collection* gc)
  { this->gc_ = gc; }

  Garbage_collection*
  gc() const
  { return this->gc_; }

  // During garbage collection, this keeps undefined symbols.
  void
  gc_mark_undef_symbols(Layout*);

  // This tells garbage collection that this symbol is referenced.
  void
  gc_mark_symbol(Symbol* sym);

  // During garbage collection, this keeps sections that correspond to 
  // symbols seen in dynamic objects.
  inline void
  gc_mark_dyn_syms(Symbol* sym);

  // Add COUNT external symbols from the relocatable object RELOBJ to
  // the symbol table.  SYMS is the symbols, SYMNDX_OFFSET is the
  // offset in the symbol table of the first symbol, SYM_NAMES is
  // their names, SYM_NAME_SIZE is the size of SYM_NAMES.  This sets
  // SYMPOINTERS to point to the symbols in the symbol table.  It sets
  // *DEFINED to the number of defined symbols.
  template<int size, bool big_endian>
  void
  add_from_relobj(Sized_relobj_file<size, big_endian>* relobj,
		  const unsigned char* syms, size_t count,
		  size_t symndx_offset, const char* sym_names,
		  size_t sym_name_size,
		  typename Sized_relobj_file<size, big_endian>::Symbols*,
		  size_t* defined);

  // Add one external symbol from the plugin object OBJ to the symbol table.
  // Returns a pointer to the resolved symbol in the symbol table.
  template<int size, bool big_endian>
  Symbol*
  add_from_pluginobj(Sized_pluginobj<size, big_endian>* obj,
                     const char* name, const char* ver,
                     elfcpp::Sym<size, big_endian>* sym);

  // Add COUNT dynamic symbols from the dynamic object DYNOBJ to the
  // symbol table.  SYMS is the symbols.  SYM_NAMES is their names.
  // SYM_NAME_SIZE is the size of SYM_NAMES.  The other parameters are
  // symbol version data.
  template<int size, bool big_endian>
  void
  add_from_dynobj(Sized_dynobj<size, big_endian>* dynobj,
		  const unsigned char* syms, size_t count,
		  const char* sym_names, size_t sym_name_size,
		  const unsigned char* versym, size_t versym_size,
		  const std::vector<const char*>*,
		  typename Sized_relobj_file<size, big_endian>::Symbols*,
		  size_t* defined);

  // Add one external symbol from the incremental object OBJ to the symbol
  // table.  Returns a pointer to the resolved symbol in the symbol table.
  template<int size, bool big_endian>
  Sized_symbol<size>*
  add_from_incrobj(Object* obj, const char* name,
		   const char* ver, elfcpp::Sym<size, big_endian>* sym);

  // Define a special symbol based on an Output_data.  It is a
  // multiple definition error if this symbol is already defined.
  Symbol*
  define_in_output_data(const char* name, const char* version, Defined,
			Output_data*, uint64_t value, uint64_t symsize,
			elfcpp::STT type, elfcpp::STB binding,
			elfcpp::STV visibility, unsigned char nonvis,
			bool offset_is_from_end, bool only_if_ref);

  // Define a special symbol based on an Output_segment.  It is a
  // multiple definition error if this symbol is already defined.
  Symbol*
  define_in_output_segment(const char* name, const char* version, Defined,
			   Output_segment*, uint64_t value, uint64_t symsize,
			   elfcpp::STT type, elfcpp::STB binding,
			   elfcpp::STV visibility, unsigned char nonvis,
			   Symbol::Segment_offset_base, bool only_if_ref);

  // Define a special symbol with a constant value.  It is a multiple
  // definition error if this symbol is already defined.
  Symbol*
  define_as_constant(const char* name, const char* version, Defined,
		     uint64_t value, uint64_t symsize, elfcpp::STT type,
		     elfcpp::STB binding, elfcpp::STV visibility,
		     unsigned char nonvis, bool only_if_ref,
                     bool force_override);

  // Define a set of symbols in output sections.  If ONLY_IF_REF is
  // true, only define them if they are referenced.
  void
  define_symbols(const Layout*, int count, const Define_symbol_in_section*,
		 bool only_if_ref);

  // Define a set of symbols in output segments.  If ONLY_IF_REF is
  // true, only defined them if they are referenced.
  void
  define_symbols(const Layout*, int count, const Define_symbol_in_segment*,
		 bool only_if_ref);

  // Define SYM using a COPY reloc.  POSD is the Output_data where the
  // symbol should be defined--typically a .dyn.bss section.  VALUE is
  // the offset within POSD.
  template<int size>
  void
  define_with_copy_reloc(Sized_symbol<size>* sym, Output_data* posd,
			 typename elfcpp::Elf_types<size>::Elf_Addr);

  // Look up a symbol.
  Symbol*
  lookup(const char*, const char* version = NULL) const;

  // Return the real symbol associated with the forwarder symbol FROM.
  Symbol*
  resolve_forwards(const Symbol* from) const;

  // Return the sized version of a symbol in this table.
  template<int size>
  Sized_symbol<size>*
  get_sized_symbol(Symbol*) const;

  template<int size>
  const Sized_symbol<size>*
  get_sized_symbol(const Symbol*) const;

  // Return the count of undefined symbols seen.
  size_t
  saw_undefined() const
  { return this->saw_undefined_; }

  // Allocate the common symbols
  void
  allocate_commons(Layout*, Mapfile*);

  // Add a warning for symbol NAME in object OBJ.  WARNING is the text
  // of the warning.
  void
  add_warning(const char* name, Object* obj, const std::string& warning)
  { this->warnings_.add_warning(this, name, obj, warning); }

  // Canonicalize a symbol name for use in the hash table.
  const char*
  canonicalize_name(const char* name)
  { return this->namepool_.add(name, true, NULL); }

  // Possibly issue a warning for a reference to SYM at LOCATION which
  // is in OBJ.
  template<int size, bool big_endian>
  void
  issue_warning(const Symbol* sym,
		const Relocate_info<size, big_endian>* relinfo,
		size_t relnum, off_t reloffset) const
  { this->warnings_.issue_warning(sym, relinfo, relnum, reloffset); }

  // Check candidate_odr_violations_ to find symbols with the same name
  // but apparently different definitions (different source-file/line-no).
  void
  detect_odr_violations(const Task*, const char* output_file_name) const;

  // Add any undefined symbols named on the command line to the symbol
  // table.
  void
  add_undefined_symbols_from_command_line(Layout*);

  // SYM is defined using a COPY reloc.  Return the dynamic object
  // where the original definition was found.
  Dynobj*
  get_copy_source(const Symbol* sym) const;

  // Set the dynamic symbol indexes.  INDEX is the index of the first
  // global dynamic symbol.  Pointers to the symbols are stored into
  // the vector.  The names are stored into the Stringpool.  This
  // returns an updated dynamic symbol index.
  unsigned int
  set_dynsym_indexes(unsigned int index, std::vector<Symbol*>*,
		     Stringpool*, Versions*);

  // Finalize the symbol table after we have set the final addresses
  // of all the input sections.  This sets the final symbol indexes,
  // values and adds the names to *POOL.  *PLOCAL_SYMCOUNT is the
  // index of the first global symbol.  OFF is the file offset of the
  // global symbol table, DYNOFF is the offset of the globals in the
  // dynamic symbol table, DYN_GLOBAL_INDEX is the index of the first
  // global dynamic symbol, and DYNCOUNT is the number of global
  // dynamic symbols.  This records the parameters, and returns the
  // new file offset.  It updates *PLOCAL_SYMCOUNT if it created any
  // local symbols.
  off_t
  finalize(off_t off, off_t dynoff, size_t dyn_global_index, size_t dyncount,
	   Stringpool* pool, unsigned int* plocal_symcount);

  // Set the final file offset of the symbol table.
  void
  set_file_offset(off_t off)
  { this->offset_ = off; }

  // Status code of Symbol_table::compute_final_value.
  enum Compute_final_value_status
  {
    // No error.
    CFVS_OK,
    // Unsupported symbol section.
    CFVS_UNSUPPORTED_SYMBOL_SECTION,
    // No output section.
    CFVS_NO_OUTPUT_SECTION
  };

  // Compute the final value of SYM and store status in location PSTATUS.
  // During relaxation, this may be called multiple times for a symbol to 
  // compute its would-be final value in each relaxation pass.

  template<int size>
  typename Sized_symbol<size>::Value_type
  compute_final_value(const Sized_symbol<size>* sym,
		      Compute_final_value_status* pstatus) const;

  // Return the index of the first global symbol.
  unsigned int
  first_global_index() const
  { return this->first_global_index_; }

  // Return the total number of symbols in the symbol table.
  unsigned int
  output_count() const
  { return this->output_count_; }

  // Write out the global symbols.
  void
  write_globals(const Stringpool*, const Stringpool*,
		Output_symtab_xindex*, Output_symtab_xindex*,
		Output_file*) const;

  // Write out a section symbol.  Return the updated offset.
  void
  write_section_symbol(const Output_section*, Output_symtab_xindex*,
		       Output_file*, off_t) const;

  // Loop over all symbols, applying the function F to each.
  template<int size, typename F>
  void
  for_all_symbols(F f) const
  {
    for (Symbol_table_type::const_iterator p = this->table_.begin();
         p != this->table_.end();
         ++p)
      {
	Sized_symbol<size>* sym = static_cast<Sized_symbol<size>*>(p->second);
	f(sym);
      }
  }

  // Dump statistical information to stderr.
  void
  print_stats() const;

  // Return the version script information.
  const Version_script_info&
  version_script() const
  { return version_script_; }

 private:
  Symbol_table(const Symbol_table&);
  Symbol_table& operator=(const Symbol_table&);

  // The type of the list of common symbols.
  typedef std::vector<Symbol*> Commons_type;

  // The type of the symbol hash table.

  typedef std::pair<Stringpool::Key, Stringpool::Key> Symbol_table_key;

  // The hash function.  The key values are Stringpool keys.
  struct Symbol_table_hash
  {
    inline size_t
    operator()(const Symbol_table_key& key) const
    {
      return key.first ^ key.second;
    }
  };

  struct Symbol_table_eq
  {
    bool
    operator()(const Symbol_table_key&, const Symbol_table_key&) const;
  };

  typedef Unordered_map<Symbol_table_key, Symbol*, Symbol_table_hash,
			Symbol_table_eq> Symbol_table_type;

  // A map from symbol name (as a pointer into the namepool) to all
  // the locations the symbols is (weakly) defined (and certain other
  // conditions are met).  This map will be used later to detect
  // possible One Definition Rule (ODR) violations.
  struct Symbol_location_hash
  {
    size_t operator()(const Symbol_location& loc) const
    { return reinterpret_cast<uintptr_t>(loc.object) ^ loc.offset ^ loc.shndx; }
  };

  typedef Unordered_map<const char*,
                        Unordered_set<Symbol_location, Symbol_location_hash> >
  Odr_map;

  // Make FROM a forwarder symbol to TO.
  void
  make_forwarder(Symbol* from, Symbol* to);

  // Add a symbol.
  template<int size, bool big_endian>
  Sized_symbol<size>*
  add_from_object(Object*, const char* name, Stringpool::Key name_key,
		  const char* version, Stringpool::Key version_key,
		  bool def, const elfcpp::Sym<size, big_endian>& sym,
		  unsigned int st_shndx, bool is_ordinary,
		  unsigned int orig_st_shndx);

  // Define a default symbol.
  template<int size, bool big_endian>
  void
  define_default_version(Sized_symbol<size>*, bool,
			 Symbol_table_type::iterator);

  // Resolve symbols.
  template<int size, bool big_endian>
  void
  resolve(Sized_symbol<size>* to,
	  const elfcpp::Sym<size, big_endian>& sym,
	  unsigned int st_shndx, bool is_ordinary,
	  unsigned int orig_st_shndx,
	  Object*, const char* version);

  template<int size, bool big_endian>
  void
  resolve(Sized_symbol<size>* to, const Sized_symbol<size>* from);

  // Record that a symbol is forced to be local by a version script or
  // by visibility.
  void
  force_local(Symbol*);

  // Adjust NAME and *NAME_KEY for wrapping.
  const char*
  wrap_symbol(const char* name, Stringpool::Key* name_key);

  // Whether we should override a symbol, based on flags in
  // resolve.cc.
  static bool
  should_override(const Symbol*, unsigned int, elfcpp::STT, Defined,
		  Object*, bool*, bool*);

  // Report a problem in symbol resolution.
  static void
  report_resolve_problem(bool is_error, const char* msg, const Symbol* to,
			 Defined, Object* object);

  // Override a symbol.
  template<int size, bool big_endian>
  void
  override(Sized_symbol<size>* tosym,
	   const elfcpp::Sym<size, big_endian>& fromsym,
	   unsigned int st_shndx, bool is_ordinary,
	   Object* object, const char* version);

  // Whether we should override a symbol with a special symbol which
  // is automatically defined by the linker.
  static bool
  should_override_with_special(const Symbol*, elfcpp::STT, Defined);

  // Override a symbol with a special symbol.
  template<int size>
  void
  override_with_special(Sized_symbol<size>* tosym,
			const Sized_symbol<size>* fromsym);

  // Record all weak alias sets for a dynamic object.
  template<int size>
  void
  record_weak_aliases(std::vector<Sized_symbol<size>*>*);

  // Define a special symbol.
  template<int size, bool big_endian>
  Sized_symbol<size>*
  define_special_symbol(const char** pname, const char** pversion,
			bool only_if_ref, Sized_symbol<size>** poldsym,
			bool* resolve_oldsym);

  // Define a symbol in an Output_data, sized version.
  template<int size>
  Sized_symbol<size>*
  do_define_in_output_data(const char* name, const char* version, Defined,
			   Output_data*,
			   typename elfcpp::Elf_types<size>::Elf_Addr value,
			   typename elfcpp::Elf_types<size>::Elf_WXword ssize,
			   elfcpp::STT type, elfcpp::STB binding,
			   elfcpp::STV visibility, unsigned char nonvis,
			   bool offset_is_from_end, bool only_if_ref);

  // Define a symbol in an Output_segment, sized version.
  template<int size>
  Sized_symbol<size>*
  do_define_in_output_segment(
    const char* name, const char* version, Defined, Output_segment* os,
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    typename elfcpp::Elf_types<size>::Elf_WXword ssize,
    elfcpp::STT type, elfcpp::STB binding,
    elfcpp::STV visibility, unsigned char nonvis,
    Symbol::Segment_offset_base offset_base, bool only_if_ref);

  // Define a symbol as a constant, sized version.
  template<int size>
  Sized_symbol<size>*
  do_define_as_constant(
    const char* name, const char* version, Defined,
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    typename elfcpp::Elf_types<size>::Elf_WXword ssize,
    elfcpp::STT type, elfcpp::STB binding,
    elfcpp::STV visibility, unsigned char nonvis,
    bool only_if_ref, bool force_override);

  // Add any undefined symbols named on the command line to the symbol
  // table, sized version.
  template<int size>
  void
  do_add_undefined_symbols_from_command_line(Layout*);

  // Add one undefined symbol.
  template<int size>
  void
  add_undefined_symbol_from_command_line(const char* name);

  // Types of common symbols.

  enum Commons_section_type
  {
    COMMONS_NORMAL,
    COMMONS_TLS,
    COMMONS_SMALL,
    COMMONS_LARGE
  };

  // Allocate the common symbols, sized version.
  template<int size>
  void
  do_allocate_commons(Layout*, Mapfile*, Sort_commons_order);

  // Allocate the common symbols from one list.
  template<int size>
  void
  do_allocate_commons_list(Layout*, Commons_section_type, Commons_type*,
			   Mapfile*, Sort_commons_order);

  // Returns all of the lines attached to LOC, not just the one the
  // instruction actually came from.  This helps the ODR checker avoid
  // false positives.
  static std::vector<std::string>
  linenos_from_loc(const Task* task, const Symbol_location& loc);

  // Implement detect_odr_violations.
  template<int size, bool big_endian>
  void
  sized_detect_odr_violations() const;

  // Finalize symbols specialized for size.
  template<int size>
  off_t
  sized_finalize(off_t, Stringpool*, unsigned int*);

  // Finalize a symbol.  Return whether it should be added to the
  // symbol table.
  template<int size>
  bool
  sized_finalize_symbol(Symbol*);

  // Add a symbol the final symtab by setting its index.
  template<int size>
  void
  add_to_final_symtab(Symbol*, Stringpool*, unsigned int* pindex, off_t* poff);

  // Write globals specialized for size and endianness.
  template<int size, bool big_endian>
  void
  sized_write_globals(const Stringpool*, const Stringpool*,
		      Output_symtab_xindex*, Output_symtab_xindex*,
		      Output_file*) const;

  // Write out a symbol to P.
  template<int size, bool big_endian>
  void
  sized_write_symbol(Sized_symbol<size>*,
		     typename elfcpp::Elf_types<size>::Elf_Addr value,
		     unsigned int shndx, elfcpp::STB,
		     const Stringpool*, unsigned char* p) const;

  // Possibly warn about an undefined symbol from a dynamic object.
  void
  warn_about_undefined_dynobj_symbol(Symbol*) const;

  // Write out a section symbol, specialized for size and endianness.
  template<int size, bool big_endian>
  void
  sized_write_section_symbol(const Output_section*, Output_symtab_xindex*,
			     Output_file*, off_t) const;

  // The type of the list of symbols which have been forced local.
  typedef std::vector<Symbol*> Forced_locals;

  // A map from symbols with COPY relocs to the dynamic objects where
  // they are defined.
  typedef Unordered_map<const Symbol*, Dynobj*> Copied_symbol_dynobjs;

  // We increment this every time we see a new undefined symbol, for
  // use in archive groups.
  size_t saw_undefined_;
  // The index of the first global symbol in the output file.
  unsigned int first_global_index_;
  // The file offset within the output symtab section where we should
  // write the table.
  off_t offset_;
  // The number of global symbols we want to write out.
  unsigned int output_count_;
  // The file offset of the global dynamic symbols, or 0 if none.
  off_t dynamic_offset_;
  // The index of the first global dynamic symbol.
  unsigned int first_dynamic_global_index_;
  // The number of global dynamic symbols, or 0 if none.
  unsigned int dynamic_count_;
  // The symbol hash table.
  Symbol_table_type table_;
  // A pool of symbol names.  This is used for all global symbols.
  // Entries in the hash table point into this pool.
  Stringpool namepool_;
  // Forwarding symbols.
  Unordered_map<const Symbol*, Symbol*> forwarders_;
  // Weak aliases.  A symbol in this list points to the next alias.
  // The aliases point to each other in a circular list.
  Unordered_map<Symbol*, Symbol*> weak_aliases_;
  // We don't expect there to be very many common symbols, so we keep
  // a list of them.  When we find a common symbol we add it to this
  // list.  It is possible that by the time we process the list the
  // symbol is no longer a common symbol.  It may also have become a
  // forwarder.
  Commons_type commons_;
  // This is like the commons_ field, except that it holds TLS common
  // symbols.
  Commons_type tls_commons_;
  // This is for small common symbols.
  Commons_type small_commons_;
  // This is for large common symbols.
  Commons_type large_commons_;
  // A list of symbols which have been forced to be local.  We don't
  // expect there to be very many of them, so we keep a list of them
  // rather than walking the whole table to find them.
  Forced_locals forced_locals_;
  // Manage symbol warnings.
  Warnings warnings_;
  // Manage potential One Definition Rule (ODR) violations.
  Odr_map candidate_odr_violations_;

  // When we emit a COPY reloc for a symbol, we define it in an
  // Output_data.  When it's time to emit version information for it,
  // we need to know the dynamic object in which we found the original
  // definition.  This maps symbols with COPY relocs to the dynamic
  // object where they were defined.
  Copied_symbol_dynobjs copied_symbol_dynobjs_;
  // Information parsed from the version script, if any.
  const Version_script_info& version_script_;
  Garbage_collection* gc_;
  Icf* icf_;
};

// We inline get_sized_symbol for efficiency.

template<int size>
Sized_symbol<size>*
Symbol_table::get_sized_symbol(Symbol* sym) const
{
  gold_assert(size == parameters->target().get_size());
  return static_cast<Sized_symbol<size>*>(sym);
}

template<int size>
const Sized_symbol<size>*
Symbol_table::get_sized_symbol(const Symbol* sym) const
{
  gold_assert(size == parameters->target().get_size());
  return static_cast<const Sized_symbol<size>*>(sym);
}

} // End namespace gold.

#endif // !defined(GOLD_SYMTAB_H)
@


1.130
log
@	* symtab.h (Symbol::clear_version): New function.
	* symtab.cc (Symbol_table::set_dynsym_indexes): Don't set object
	is_needed by weak references.  Clear version for symbols defined
	in as-needed objects that are not needed.
@
text
@d820 5
@


1.129
log
@	* gold.cc (queue_middle_tasks): Move detect_odr_violations..
	* layout.cc (Layout_task_runner::run): ..to here.
	* symtab.h (struct Symbol_location): Extract from..
	(class Symbol_table): ..here.
	* symtab.cc (Symbol_table::linenos_from_loc): Invoke function_location.
	* target.h (class Target): Add function_location and
	do_function_location functions.
	(class Sized_target): Add do_function_location.
	* object.h (class Sized_relobj_file): Move find_shdr..
	(class Object): ..to here.
	* object.cc: Likewise.  Update to suit.  Instantiate.
	(Sized_relobj_file::find_eh_frame): Update find_shdr call.
	* powerpc.cc (class Powerpc_dynobj): New.
	(Target_powerpc::do_function_location): New function.
	(Powerpc_relobj::do_find_special_sections): Update find_shdr call.
	(Powerpc_dynobj::do_read_symbols): New function.
	(Target_powerpc::do_make_elf_object): Make a Powerpc_dynobj.
@
text
@d124 4
@


1.128
log
@	* powerpc.cc: Formatting and white space.
	(Powerpc_relobj): Rename got2_section_ to special_.
	Add opd_ent_shndx_ and opd_ent_off_ vectors.
	(Powerpc_relobj::opd_shndx, init_opd, get_opd_ent, set_opd_ent,
	scan_opd_relocs, do_read_relocs, opd_ent_ndx): New functions.
	(Target_powerpc): Add Address typedef and invalid_address.  Use
	throughout.
	(Target_powerpc::is_branch_reloc): New function.
	(Powerpc_relocate_functions): Add Address typedef, use throughout.
	(Powerpc_relocate_functions:rela, rela_ua): Correct type used
	for dst_mask, value and addend.
	(Powerpc_relobj::do_find_special_sections): Find .opd for 64-bit.
	(ld_2_1, cror_15_15_15, cror_31_31_31): New insn constants.
	(Output_data_glink::do_write): Correct toc base.  Don't try to use
	uint16_t for 24-bit offset.  Use get_output_section_offset and
	check return.
	(Target_powerpc::Scan::local): Handle more relocs.
	(Target_powerpc::do_finalize_sections): Set up DT_PPC64_GLINK.
	(Target_powerpc::Relocate::relocate): Correct toc base calculation.
	Plug in toc restoring insn after plt calls.  Translate branches
	to function descriptor symbols to corresponding entry point.
	(Target_powerpc::relocate_for_relocatable): Check return from
	get_output_section_offset.
	* symtab.h: Comment typo.
@
text
@d1183 19
a1620 13
  struct Symbol_location
  {
    Object* object;         // Object where the symbol is defined.
    unsigned int shndx;     // Section-in-object where the symbol is defined.
    off_t offset;           // Offset-in-section where the symbol is defined.
    bool operator==(const Symbol_location& that) const
    {
      return (this->object == that.object
              && this->shndx == that.shndx
              && this->offset == that.offset);
    }
  };

@


1.127
log
@2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.
@
text
@d65 1
a65 1
// can have a lot of entries, so we don't want this class to big.
@


1.126
log
@	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.
@
text
@d1316 1
a1316 2
  // During garbage collection, this ensures externally visible symbols
  // are not treated as garbage while building shared objects.
d1318 1
a1318 1
  gc_mark_symbol_for_shlib(Symbol* sym);
@


1.125
log
@2011-07-22  Sriraman Tallam  <tmsriram@@google.com>

	* symtab.cc (Symbol_table::add_from_relobj): Mark symbol as referenced
	only after checking if it cannot be forced local.
	* symtab.h (is_externally_visible): Check if the symbol is not forced
	local.
@
text
@d996 6
a1001 1
  // True if we've seen this symbol in a real ELF object (bit 30).
@


1.125.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d1311 2
a1312 1
  // This tells garbage collection that this symbol is referenced.
d1314 1
a1314 1
  gc_mark_symbol(Symbol* sym);
@


1.124
log
@	PR gold/12279
	* resolve.cc (Symbol_table::should_override): Add fromtype
	parameter.  Change all callers.  Give error when linking together
	TLS and non-TLS symbol.
	(Symbol_table::should_override_with_special): Add fromtype
	parameter.  Change all callers.
	* i386.cc (Target_i386::Relocate::relocate_tls): Don't crash if
	there is no TLS segment if we have reported some errors.
	* x86_64.cc (Target_x86_64::relocate_tls): Likewise.
@
text
@d541 3
a543 2
    return (this->visibility_ == elfcpp::STV_DEFAULT
            || this->visibility_ == elfcpp::STV_PROTECTED);
@


1.123
log
@	* symtab.cc (Symbol::versioned_name): New function.
	(Symbol_table::add_to_final_symtab): Use versioned_name when
	appropriate.
	(Symbol_table::sized_write_symbol): Likewise.
	* symtab.h (class Symbol): Declare versioned_name.
	* stringpool.h (class Stringpool_template): Add variant of add
	which takes a std::basic_string.
	* testsuite/Makefile.am (check_PROGRAMS): Add ver_test_12.
	(ver_test_12_SOURCES, ver_test_12_DEPENDENCIES): New variables.
	(ver_test_12_LDFLAGS, ver_test_12_LDADD): New variables.
	(ver_test_12.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1664 2
a1665 1
  should_override(const Symbol*, unsigned int, Defined, Object*, bool*, bool*);
d1683 1
a1683 1
  should_override_with_special(const Symbol*, Defined);
@


1.122
log
@	* common.cc (Symbol_table::do_allocate_commons_list): For incremental
	update, allocate common from bss section's free list.
	* incremental-dump.cc (dump_incremental_inputs): Print flag for
	linker-defined symbols.
	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Skip GOT and PLT entries that are no longer referenced.
	(Output_section_incremental_inputs::write_info_blocks): Mark
	linker-defined symbols.
	(Sized_incr_relobj::do_add_symbols): Process linker-defined symbols.
	* output.cc (Output_section::allocate): New function.
	* output.h (Output_section::allocate): New function.
	* resolve.cc (Symbol_table::report_resolve_problem): Add case for
	linker-defined symbols.
	(Symbol::override_base_with_special): Copy is_predefined_ flag.
	* symtab.cc (Symbol::init_fields): Initialize is_predefined_ flag.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* symtab.h (Symbol::is_predefined): New function.
	(Symbol::init_base_output_data): Add is_predefined parameter.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::is_predefined_): New data member.
	(Sized_symbol::init_output_data): Add is_predefined parameter.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(enum Symbol_table::Defined): Add INCREMENTAL_BASE.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d139 4
@


1.121
log
@	* copy-relocs.cc (Copy_relocs::copy_reloc): Call make_copy_reloc
	instead of emit_copy_reloc.
	(Copy_relocs::emit_copy_reloc): Refactor.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* copy-relocs.h (Copy_relocs::emit_copy_reloc): Move to public
	section.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* gold.cc (queue_middle_tasks): Emit old COPY relocations from
	unchanged input files.
	* incremental-dump.cc (dump_incremental_inputs): Print "COPY" flag.
	* incremental.cc (Sized_incremental_binary::do_reserve_layout):
	Reserve BSS space for COPY relocations.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Output_section_incremental_inputs::write_info_blocks): Record
	whether a symbol is copied from a shared object.
	(Sized_incr_dynobj::do_add_symbols): Record COPY relocations.
	* incremental.h (enum Incremental_shlib_symbol_flags): New type.
	(INCREMENTAL_SHLIB_SYM_FLAGS_SHIFT): New constant.
	(Incremental_input_entry_reader::get_output_symbol_index): Add
	is_copy parameter.
	(Incremental_binary::emit_copy_relocs): New function.
	(Incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data member.
	(Sized_incremental_binary::add_copy_reloc): New function.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Copy_reloc): New struct.
	(Sized_incremental_binary::Copy_relocs): New typedef.
	(Sized_incremental_binary::copy_relocs_): New data member.
	* symtab.cc (Symbol_table::add_from_incrobj): Change return type.
	* symtab.h (Symbol_table::add_from_incrobj): Change return type.
	* target.h (Sized_target::emit_copy_reloc): New function.
	* x86_64.cc (Target_x86_64::emit_copy_reloc): New function.
@
text
@d806 5
d836 2
a837 1
			unsigned char nonvis, bool offset_is_from_end);
d845 2
a846 1
			   Segment_offset_base offset_base);
d852 1
a852 1
		     unsigned char nonvis);
d1001 2
d1032 1
a1032 1
		   bool offset_is_from_end);
d1039 1
a1039 1
		      Segment_offset_base offset_base);
d1045 1
a1045 1
		unsigned char nonvis);
d1262 3
@


1.120
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d1344 1
a1344 1
  Symbol*
@


1.119
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d45 1
a45 1
class Sized_relobj;
d1312 1
a1312 1
  add_from_relobj(Sized_relobj<size, big_endian>* relobj,
d1316 1
a1316 1
		  typename Sized_relobj<size, big_endian>::Symbols*,
d1338 1
a1338 1
		  typename Sized_relobj<size, big_endian>::Symbols*,
@


1.118
log
@	* dwarf_reader.cc (Sized_dwarf_line_info): Include all lines,
	but mark earlier ones as non-canonical
	(offset_to_iterator): Update search target and example
	(do_addr2line): Return extra lines in a vector*
	(format_file_lineno): Extract from do_addr2line
	(one_addr2line): Add vector* out-param
	* dwarf_reader.h (Offset_to_lineno_entry): New field recording
	when a lineno entry appeared last for its instruction
	(Dwarf_line_info): Add vector* out-param
	* object.cc (Relocate_info): Pass NULL for the vector* out-param
	* symtab.cc (Odr_violation_compare): Include the lineno in the
	comparison again.
	(linenos_from_loc): New. Combine the canonical line for an
	address with its other lines.
	(True_if_intersect): New. Helper functor to make
	std::set_intersection a query.
	(detect_odr_violations): Compare sets of lines instead of just
	one line for each function. This became less deterministic, but
	has fewer false positives.
	* symtab.h: Declarations.
	* testsuite/Makefile.am (odr_violation2.o): Compile with -O2 to
	mix an optimized and non-optimized object in the same binary
	(odr_violation2.so): Same.
	* testsuite/Makefile.in: Regenerate from Makefile.am.
	* testsuite/debug_msg.cc (main): Make OdrDerived classes.
	* testsuite/debug_msg.sh: Update line numbers and add
	assertions.
	* testsuite/odr_violation1.cc: Use OdrDerived, in a
	non-optimized context.
	* testsuite/odr_violation2.cc: Make sure Ordering::operator()
	isn't inlined, and use OdrDerived in an optimized context.
	* testsuite/odr_header1.h: Defines OdrDerived, where
	optimization will change the
	first-instruction-in-the-destructor's file and line number.
	* testsuite/odr_header2.h: Defines OdrBase.
@
text
@d51 2
d1341 7
d1478 5
@


1.117
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d1563 27
d1737 6
a1795 27
  // A map from symbol name (as a pointer into the namepool) to all
  // the locations the symbols is (weakly) defined (and certain other
  // conditions are met).  This map will be used later to detect
  // possible One Definition Rule (ODR) violations.
  struct Symbol_location
  {
    Object* object;         // Object where the symbol is defined.
    unsigned int shndx;     // Section-in-object where the symbol is defined.
    off_t offset;           // Offset-in-section where the symbol is defined.
    bool operator==(const Symbol_location& that) const
    {
      return (this->object == that.object
              && this->shndx == that.shndx
              && this->offset == that.offset);
    }
  };

  struct Symbol_location_hash
  {
    size_t operator()(const Symbol_location& loc) const
    { return reinterpret_cast<uintptr_t>(loc.object) ^ loc.offset ^ loc.shndx; }
  };

  typedef Unordered_map<const char*,
                        Unordered_set<Symbol_location, Symbol_location_hash> >
  Odr_map;

@


1.116
log
@gold/
	* symtab.h (Symbol::NON_PIC_REF): Remove.
	(Symbol::RELATIVE_REF, Symbol::TLS_REF): New Reference_flags.
	(Symbol::FUNCTION_CALL): Renumber.  Reword comment.
	(Symbol::needs_dynamic_reloc): Don't check NON_PIC_REF.
	(Symbol::use_plt_offset): Take a flags argument and pass it
	directly to needs_dynamic_reloc.  Restrict check for undefined
	weak symbols to function calls.
	* arm.cc (Target_arm::Scan::get_reference_flags): New function.
	(Target_arm::Scan::global): Use it.
	(Target_arm::Scan::scan_reloc_for_stub): Likewise.
	(Target_arm::Relocate::relocate): Likewise.
	(Target_arm::Relocate::should_apply_static_reloc): Replace flags
	parameter with an r_type parameter.  Use get_reference_flags
	to get the flags.
	(Target_arm::Relocate::relocate): Update accordingly.
	* i386.cc (Target_i386::Scan::get_reference_flags): New function.
	(Target_i386::Scan::reloc_needs_plt_for_ifunc): Use it.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocate::should_apply_static_reloc): Replace flags
	parameter with an r_type parameter.  Use get_reference_flags
	to get the flags.
	(Target_i386::Relocate::relocate): Update accordingly.
	* powerpc.cc (Target_powerpc::Scan::get_reference_flags): New function.
	(Target_powerpc::Scan::global): Use it.
	(Target_powerpc::Scan::scan_reloc_for_stub): Likewise.
	(Target_powerpc::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Scan::get_reference_flags): New function.
	(Target_sparc::Scan::global): Use it.
	(Target_sparc::Scan::scan_reloc_for_stub): Likewise.
	(Target_sparc::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Scan::get_reference_flags): New function.
	(Target_x86_64::Scan::reloc_needs_plt_for_ifunc): Use it.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
@
text
@d738 1
a738 1
    // symbol that is preemptible can not use a RELATIVE relocaiton.
d1261 1
a1261 1
  // COUNT is an estimate of how many symbosl will be inserted in the
d1474 1
a1474 1
    // Unspported symbol section.
@


1.115
log
@2010-10-02  Doug Kwan  <dougkwan@@google.com>

	* symtab.cc (Symbol_table::Symbol_table_hash::operator()): Move
	defintion to symtab.h
	* symtab.h (Symbol_table::Symbol_table_hash::operator()): Change
	declaration to defintion.
@
text
@d617 2
a618 1
  // These flags may be or'ed together.
d621 2
a622 1
    // Reference to the symbol's absolute address.
d624 7
a630 4
    // A non-PIC reference.
    NON_PIC_REF = 2,
    // A function call.
    FUNCTION_CALL = 4
d661 2
a662 6
    // a dynamic relocation.  A non-pic pc-relative function call in a
    // shared library cannot use a PLT entry.
    if ((flags & FUNCTION_CALL)
        && this->has_plt_offset()
        && !((flags & NON_PIC_REF)
             && parameters->options().output_is_position_independent()))
d683 1
a683 3
  // a relocation.  IS_NON_PIC_REFERENCE is true if this is a non-PIC
  // reloc--the same set of relocs for which we would pass NON_PIC_REF
  // to the needs_dynamic_reloc function.
d686 1
a686 1
  use_plt_offset(bool is_non_pic_reference) const
d699 1
a699 4
    if (this->needs_dynamic_reloc(FUNCTION_CALL
				  | (is_non_pic_reference
				     ? NON_PIC_REF
				     : 0)))
d713 4
a716 4
    // If this is a weak undefined symbol, we need to use the PLT
    // entry; the symbol may be defined by a library loaded at
    // runtime.
    if (this->is_weak_undefined())
@


1.114
log
@	* symtab.h (Symbol::needs_dynamic_reloc): Non-PIC calls from
	position-independent executables to shared libraries need dynamic
	relocations.
	(Symbol::may_need_copy_reloc): Do not generate COPY relocs in
	position-independent executables.
	* testsuite/Makefile.am (two_file_mixed_pie_test): New test.
	* testsuite/Makefile.in: Regenerate.
@
text
@d1548 1
d1551 5
a1555 2
    size_t
    operator()(const Symbol_table_key&) const;
@


1.113
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d660 2
a661 1
        && !((flags & NON_PIC_REF) && parameters->options().shared()))
d802 1
a802 1
    return (!parameters->options().shared()
@


1.112
log
@	PR 10893
	* i386.cc (class Output_data_plt_i386): Update declarations.
	Define Global_ifunc and Local_ifunc types.  Add global_ifuncs_ and
	local_ifuncs_ fields.
	(Target_i386::do_plt_section_for_global): New function.
	(Target_i386::do_plt_section_for_local): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Add symtab
	parameter; change all callers.  Initialize global_ifuncs_ and
	local_ifuncs_.  If doing a static link define __rel_iplt_start and
	__rel_iplt_end.
	(Output_data_plt_i386::add_entry): Handle IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): New function.
	(Output_data_plt_i386::do_write): Fix GOT entries for IFUNC
	symbols.
	(Target_i386::make_plt_section): New function, broken out of
	make_plt_entry.  Set sh_info field of .rel.plt to point to .plt.
	(Target_i386::make_plt_entry): Call make_plt_section.
	(Target_i386::make_local_ifunc_plt_entry): New function.
	(Target_i386::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_i386::Scan::local): Handle IFUNC symbols.  Add
	R_386_IRELATIVE to switch.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocatable_size_for_reloc): Add R_386_IRELATIVE to
	switch.
	* x86_64.cc (class Output_data_plt_x86_64): Update declarations.
	(Target_x86_64::do_plt_section_for_global): New function.
	(Target_x86_64::do_plt_section_for_local): New function.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Add symtab
	parameter; change all callers.  If doing a static link define
	__rela_iplt_start and __rela_iplt_end.
	(Output_data_plt_x86_64::add_entry): Handle IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): New function.
	(Target_x86_64::make_plt_section): Set sh_info field of .rel.plt
	to point to .plt.
	(Target_x86_64::make_local_ifunc_plt_entry): New function.
	(Target_x86_64::Scan::check_non_pic): Add R_X86_64_IRELATIVE to
	switch.
	(Target_x86_64::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_x86_64::Scan::local): Handle IFUNC symbols.  Add
	R_X86_64_IRELATIVE to switch.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocatable_size_for_reloc): Add R_X86_64_IRELATIVE to
	switch.
	* target.h (class Target): Add plt_section_for_global and
	plt_section_for_local functions.  Add do_plt_section_for_global
	and do_plt_section_for_local virtual functions.
	* symtab.h (Symbol::needs_plt_entry): Handle IFUNC symbol.  Add
	clarifying comments.
	(Symbol::use_plt_offset): Handle IFUNC symbol.
	* object.cc (Sized_relobj::Sized_relobj): Initialize
	local_plt_offsets_.
	(Sized_relobj::local_has_plt_offset): New function.
	(Sized_relobj::local_plt_offset): New function.
	(Sized_relobj::set_local_plt_offset): New function.
	(Sized_relobj::do_count): Handle IFUNC symbol.
	* object.h (class Symbol_value): Add is_ifunc_symbol_ field.  Take
	a bit away from input_shndx_ field.  Add set_is_func_symbol and
	is_ifunc_symbol functions.
	(class Sized_relobj): Update declarations.  Remove Tls_got_entry
	and Local_tls_got_offsets.  Define Local_plt_offsets.  Add
	local_plt_offsets_ field.
	(Sized_relobj::clear_local_symbols): Clear local_plt_offsets_.
	* output.h (class Output_section_data): Add non-const
	output_section function.
	(class Output_data_got): Update declarations.
	(class Output_data_got::Got_entry): Add use_plt_offset_ field.
	Add use_plt_offset parameter to global and local constructors.
	Change all callers.  Change local_sym_index_ field to 31 bits.
	Change GSYM_CODE and CONSTANT_CODE accordingly.
	* output.cc (Output_data_reloc_base::do_adjust_output_section): If
	doing a static link don't set sh_link field.
	(Output_data_got::Got_entry::write): Use PLT offset if
	appropriate.
	(Output_data_got::add_global_plt): New function.
	(Output_data_got::add_local_plt): New function.
	* target-reloc.h (relocate_section): Handle IFUNC symbol.
	* defstd.cc (in_section): Remove entries for __rel_iplt_start,
	__rel_iplt_end, __rela_iplt_start, and __rela_iplt_end.
	* configure.ac: Set IFUNC automake conditional for glibc >= 2.11.
	* testsuite/Makefile.am: Add a bunch of IFUNC tests, all within
	IFUNC conditional.
	* testsuite/ifunc-sel.h: New file.
	* testsuite/ifuncmain1.c: New file.
	* testsuite/ifuncmain1vis.c: New file.
	* testsuite/ifuncmod1.c: New file.
	* testsuite/ifuncdep2.c: New file.
	* testsuite/ifuncmain2.c: New file.
	* testsuite/ifuncmain3.c: New file.
	* testsuite/ifuncmod3.c: New file.
	* testsuite/ifuncmain4.c: New file.
	* testsuite/ifuncmain5.c: New file.
	* testsuite/ifuncmod5.c: New file.
	* testsuite/ifuncmain6pie.c: New file.
	* testsuite/ifuncmod6.c: New file.
	* testsuite/ifuncmain7.c: New file.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d824 1
a824 1
  init_base_object(const char *name, const char* version, Object* object,
d1015 1
a1015 1
  init_object(const char *name, const char* version, Object* object,
d1470 1
a1470 1
	   Stringpool* pool, unsigned int *plocal_symcount);
d1569 2
a1570 2
  add_from_object(Object*, const char *name, Stringpool::Key name_key,
		  const char *version, Stringpool::Key version_key,
@


1.111
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_GOT_PLT.

gold/ChangeLog:

	* arm.cc (Target_arm::got_size): Add const.
	(Target_arm::got_entry_count): New function.
	(Target_arm::plt_entry_count): New function.
	(Target_arm::first_plt_entry_offset): New function.
	(Target_arm::plt_entry_size): New function.
	(Output_data_plt_arm::entry_count): New function.
	(Output_data_plt_arm::first_plt_entry_offset): New function.
	(Output_data_plt_arm::get_plt_entry_size): New function.
	* i386.cc (Target_i386::got_size): Add const.
	(Target_i386::got_entry_count): New function.
	(Target_i386::plt_entry_count): New function.
	(Target_i386::first_plt_entry_offset): New function.
	(Target_i386::plt_entry_size): New function.
	(Output_data_plt_i386::entry_count): New function.
	(Output_data_plt_i386::first_plt_entry_offset): New function.
	(Output_data_plt_i386::get_plt_entry_size): New function.
	* incremental-dump.cc (dump_incremental_inputs): Adjust call to
	find_incremental_inputs_sections.  Dump incremental_got_plt section.
	* incremental.cc: Include target.h.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Add
	parameter.  Adjust all callers.  Find incremental_got_plt section.
	(Incremental_inputs::create_data_sections): Create incremental_got_plt
	section.
	(Output_section_incremental_inputs::set_final_data_size): Calculate
	size of incremental_got_plt section.
	(Output_section_incremental_inputs::do_write): Write the
	incremental_got_plt section.
	(Got_plt_view_info): New struct.
	(Local_got_offset_visitor): New class.
	(Global_got_offset_visitor): New class.
	(Global_symbol_visitor_got_plt): New class.
	(Output_section_incremental_inputs::write_got_plt): New function.
	* incremental.h (Incremental_binary::find_incremental_inputs_sections):
	Add parameter.  Adjust all callers.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Incremental_inputs::got_plt_section): New function.
	(Incremental_inputs::got_plt_section_): New data member.
	(Incremental_got_plt_reader): New class.
	* layout.cc (Layout::create_incremental_info_sections): Add the
	incremental_got_plt section.
	* object.h (Got_offset_list::get_list): New function.
	(Got offset_list::for_all_got_offsets): New function.
	(Sized_relobj::local_got_offset_list): New function.
	* powerpc.cc (Target_powerpc::got_size): Add const.
	(Target_powerpc::got_entry_count): New function.
	(Target_powerpc::plt_entry_count): New function.
	(Target_powerpc::first_plt_entry_offset): New function.
	(Target_powerpc::plt_entry_size): New function.
	(Output_data_plt_powerpc::entry_count): New function.
	(Output_data_plt_powerpc::first_plt_entry_offset): New function.
	(Output_data_plt_powerpc::get_plt_entry_size): New function.
	* sparc.cc (Target_sparc::got_size): Add const.
	(Target_sparc::got_entry_count): New function.
	(Target_sparc::plt_entry_count): New function.
	(Target_sparc::first_plt_entry_offset): New function.
	(Target_sparc::plt_entry_size): New function.
	(Output_data_plt_sparc::entry_count): New function.
	(Output_data_plt_sparc::first_plt_entry_offset): New function.
	(Output_data_plt_sparc::get_plt_entry_size): New function.
	* symtab.h (Symbol::got_offset_list): New function.
	(Symbol_table::for_all_symbols): New function.
	* target.h (Sized_target::got_entry_count): New function.
	(Sized_target::plt_entry_count): New function.
	(Sized_target::plt_entry_size): New function.
	* x86_64.cc (Target_x86_64::got_size): Add const.
	(Target_x86_64::got_entry_count): New function.
	(Target_x86_64::plt_entry_count): New function.
	(Target_x86_64::first_plt_entry_offset): New function.
	(Target_x86_64::plt_entry_size): New function.
	(Output_data_plt_x86_64::entry_count): New function.
	(Output_data_plt_x86_64::first_plt_entry_offset): New function.
	(Output_data_plt_x86_64::get_plt_entry_size): New function.
@
text
@a584 3
  // If the symbol is defined in a dynamic object or if it is subject
  // to pre-emption, we need to make a PLT entry. If we're doing a
  // static link or a -pie link, we don't create PLT entries.
d592 21
a612 6
    return (!parameters->doing_static_link()
	    && !parameters->options().pie()
            && this->is_func()
            && (this->is_from_dynobj()
                || this->is_undefined()
                || this->is_preemptible()));
d693 4
@


1.110
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_SYMTAB,
	SHT_GNU_INCREMENTAL_RELOCS.

gold/ChangeLog:

	* archive.cc: Include incremental.h.
	(Archive::Archive): Initialize incremental_info_.
	(Archive::include_member): Record archive members in incremental info.
	(Add_archive_symbols::run): Record begin and end of an archive in
	incremental info.
	(Lib_group::include_member): Record objects in incremental info.
	* archive.h (Incremental_archive_entry): Forward declaration.
	(Archive::set_incremental_info): New member function.
	(Archive::incremental_info): New member function.
	(Archive::Unused_symbol_iterator): New class.
	(Archive::unused_symbols_begin): New member function.
	(Archive::unused_symbols_end): New member function.
	(Archive::incremental_info_): New data member.
	* incremental-dump.cc (find_input_containing_global): New function.
	(dump_incremental_inputs): Dump new incremental info sections.
	* incremental.cc: Include symtab.h.
	(Output_section_incremental_inputs): New class.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Support
	new incremental info sections.
	(Sized_incremental_binary::do_check_inputs): Likewise.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): New function.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Rewrite.
	(Incremental_inputs::finalize): Do nothing but finalize string table.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Output_section_incremental_inputs::set_final_data_size): New function.
	(Output_section_incremental_inputs::do_write): New function.
	(Output_section_incremental_inputs::write_header): New function.
	(Output_section_incremental_inputs::write_input_files): New function.
	(Output_section_incremental_inputs::write_info_blocks): New function.
	(Output_section_incremental_inputs::write_symtab): New function.
	* incremental.h (Incremental_script_entry): Forward declaration.
	(Incremental_object_entry): Forward declaration.
	(Incremental_archive_entry): Forward declaration.
	(Incremental_inputs): Forward declaration.
	(Incremental_inputs_header_data): Remove.
	(Incremental_inputs_header): Remove.
	(Incremental_inputs_header_write): Remove.
	(Incremental_inputs_entry_data): Remove.
	(Incremental_inputs_entry): Remove.
	(Incremental_inputs_entry_write): Remove.
	(enum Incremental_input_type): Add INCREMENTAL_INPUT_ARCHIVE_MEMBER.
	(Incremental_binary::find_incremental_inputs_sections): Add parameters.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Sized_ncremental_binary::do_find_incremental_inputs_sections):
	Likewise.
	(Incremental_input_entry): New class.
	(Incremental_script_entry): New class.
	(Incremental_object_entry): New class.
	(Incremental_archive_entry): New class.
	(Incremental_inputs::Incremental_inputs): Initialize new data members.
	(Incremental_inputs::report_inputs): Remove.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): Change prototype.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Change prototype.
	(Incremental_inputs::get_reloc_count): New function.
	(Incremental_inputs::set_reloc_count): New function.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::inputs_section): New function.
	(Incremental_inputs::symtab_section): New function.
	(Incremental_inputs::relocs_section): New function.
	(Incremental_inputs::get_stringpool): Add const.
	(Incremental_inputs::command_line): Add const.
	(Incremental_inputs::inputs): Remove.
	(Incremental_inputs::command_line_key): New function.
	(Incremental_inputs::input_file_count): New function.
	(Incremental_inputs::input_files): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::Input_info): Remove.
	(Incremental_inputs::lock_): Remove.
	(Incremental_inputs::inputs_): Change type.
	(Incremental_inputs::inputs_map_): Remove.
	(Incremental_inputs::current_object_entry_): New data member.
	(Incremental_inputs::inputs_section_): New data member.
	(Incremental_inputs::symtab_section_): New data member.
	(Incremental_inputs::relocs_section_): New data member.
	(Incremental_inputs::reloc_count_): New data member.
	(Incremental_inputs_reader): New class.
	(Incremental_symtab_reader): New class.
	(Incremental_relocs_reader): New class.
	* layout.cc (Layout::finalize): Move finalization of incremental info
	and creation of incremental info sections to follow finalization of
	symbol table.  Set offsets for postprocessing sections.
	(Layout::create_incremental_info_sections): Call
	Incremental_inputs::create_data_sections.  Add incremental symtab
	and relocs sections.  Set sh_entsize and sh_link fields.  Arrange for
	sections to layout after input sections.
	* layout.h (struct Timespec): Forward declaration.
	(Layout::incremental_inputs): Add const.
	(Layout::create_incremental_info_sections): Add parameter.
	* main.cc (main): Remove call to Incremental_inputs::report_inputs.
	* object.cc: Include incremental.h.
	(Relobj::finalize_incremental_relocs): New function.
	(Sized_relobj::do_layout): Record input sections in incremental info.
	* object.h (Object::output_section): New function.
	(Object::output_section_offset): Moved from Relobj.
	(Object::get_incremental_reloc_base): New function.
	(Object::get_incremental_reloc_count): New function.
	(Object::do_output_section): New function.
	(Object::do_output_section_offset): Moved from Relobj.
	(Object::do_get_incremental_reloc_base): New function.
	(Object::do_get_incremental_reloc_count): New function.
	(Object::Object): Initialize new data members.
	(Relobj::output_section): Renamed do_output_section and moved to
	protected.
	(Relobj::output_section_offset): Moved to Object.
	(Relobj::do_get_incremental_reloc_base): New function.
	(Relobj::do_get_incremental_reloc_count): New function.
	(Relobj::allocate_incremental_reloc_counts): New function.
	(Relobj::count_incremental_reloc): New function.
	(Relobj::finalize_incremental_relocs): New function.
	(Relobj::next_incremental_reloc_index): New function.
	(Relobj::reloc_counts_): New data member.
	(Relobj::reloc_bases_): New data member.
	(Sized_relobj::do_relocate_sections): Add parameter.  Change caller.
	(Sized_relobj::relocate_sections): Add parameter.  Change all callers.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* plugin.cc (Plugin_manager::add_input_file): Rewrite test for
	incremental link.
	* readsyms.cc (Read_symbols::do_read_symbols): Move reporting of
	archives and object files elsewhere.
	(Add_symbols::run): Report object files here.
	(Finish_group::run): Report end of archive at end of group.
	* reloc.cc: Include layout.h, incremental.h.
	(Sized_relobj::do_read_relocs): Need relocations for incremental link.
	(Sized_relobj::do_scan_relocs): Record relocations for incremental link.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::do_relocate_sections): Write incremental relocations.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* script.cc (read_input_script): Rewrite test for incremental link.
	Change call to Incremental_inputs::report_script.
	* symtab.h (Symbol_table::first_global_index): New function.
	(Symbol_table::output_count): New function.
@
text
@d412 5
d1497 14
@


1.109
log
@	PR 11855
	* script.cc (Script_options::Script_options): Initialize
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_assignment): Update
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_reference): New function.
	(script_symbol): New function.
	* script.h (class Script_options): Add symbol_definitions_ and
	symbol_references_ fields.
	(Script_options::referenced_const_iterator): New type.
	(Script_options::referenced_begin): New function.
	(Script_options::referenced_end): New function.
	(Script_options::is_referenced): New function.
	(Script_options::any_unreferenced): New function.
	* script-c.h (script_symbol): Declare.
	* yyscript.y (exp): Call script_symbol.
	* symtab.cc: Include "script.h".
	(Symbol_table::gc_mark_undef_symbols): Add layout parameter.
	Change all callers.  Check symbols referenced by scripts.
	(Symbol_table::add_undefined_symbols_from_command_line): Add
	layout parameter.  Change all callers.
	(Symbol_table::do_add_undefined_symbols_from_command_line):
	Likewise.  Break out loop body.  Check symbols referenced by
	scripts.
	(Symbol_table::add_undefined_symbol_from_command_line): New
	function broken out of
	do_add_undefined_symbols_from_command_line.
	* symtab.h (class Symbol_table): Update declarations.
	* archive.cc: Include "layout.h".
	(Archive::should_include_member): Add layout parameter.  Change
	all callers.  Check for symbol mentioned in expression.
	* archive.h (class Archive): Update declaration.
	* object.cc (Sized_relobj::do_should_include_member): Add layout
	parameter.
	* object.h (Object::should_include_member): Add layout parameter.
	Change all callers.
	(Object::do_should_include_member): Add layout parameter.
	(class Sized_relobj): Update declaration.
	* dynobj.cc (Sized_dynobj::do_should_include_member): Add layout
	parameter.
	* dynobj.h (class Sized_dynobj): Update declaration.
	* plugin.cc (Sized_pluginobj::do_should_include_member): Add
	layout parameter.
	* plugin.h (class Sized_pluginobj): Update declaration.
@
text
@d1471 10
@


1.108
log
@	* resolve.cc (Symbol_table::resolve): Remember whether undef was
	weak when resolving to a dynamic def.
	(Symbol_table::should_override): Add adjust_dyndef flag; set it
	for weak undef/dynamic def cases. Adjust callers.
	* symtab.cc (Symbol::init_fields): Initialize undef_binding_set_ and
	undef_binding_weak_.
	(Symbol_table::sized_write_globals): Adjust symbol binding.
	(Symbol_table::sized_write_symbol): Add binding parameter.
	* symtab.h (Symbol::set_undef_binding): New method.
	(Symbol::is_undef_binding_weak): New method.
	(Symbol::undef_binding_set_, Symbol::undef_binding_weak_): New members.
	(Symbol_table::should_override): Add new parameter.
	(Symbol_table::sized_write_symbol): Add new parameter.

	* testsuite/weak_undef_file1.cc: Add new test case.
	* testsuite/weak_undef_file2.cc: Fix header comment.
	* testsuite/weak_undef_test.cc: Add new test case.
@
text
@d1272 1
a1272 1
  gc_mark_undef_symbols(); 
d1422 1
a1422 1
  add_undefined_symbols_from_command_line();
d1636 6
a1641 1
  do_add_undefined_symbols_from_command_line();
@


1.107
log
@	* object.cc (Sized_relobj::do_layout): Defer layout for reloc sections.
	(Sized_relobj::do_layout_deferred_sections): Do layout for deferred
	reloc sections.
	* object.h (Sized_relobj::deferred_layout_relocs_): New data member.

	PR 11683
	* symtab.h (Symbol::is_placeholder): New member function.
	* target-reloc.h (relocate_section): Check for placeholder symbols.

	* testsuite/Makefile.am (plugin_test_8): New test.
	(plugin_test_9): New test.
	* testsuite/Makefile.in: Regenerate.
@
text
@d230 17
d969 5
d1561 1
a1561 1
  should_override(const Symbol*, unsigned int, Defined, Object*, bool*);
d1692 1
a1692 1
		     unsigned int shndx,
@


1.106
log
@2010-04-18  Sriraman Tallam  <tmsriram@@google.com>

	* icf.cc (get_section_contents): Check for preemptible functions.
	Ignore addend when appropriate.
	* symtab.cc (should_add_dynsym_entry): Add new parameter.  Check for
	section folded.
	(add_from_relobj): Check for section folded.
	(set_dynsym_indexes): Fix call to should_add_dynsym_entry.
	* symtab.h (should_add_dynsym_entry): Add new parameter.
	* target-reloc.h (scan_relocs): Check for section folded.
	* x86_64.cc (Target_x86_64::Scan::possible_function_pointer_reloc):
	Check reloc types for function pointers in shared objects.
	* testsuite/Makefile.am (icf_virtual_function_folding_test): New test
	case.
	(icf_preemptible_functions_test): New test case.
	(icf_string_merge_test): New test case.
	* testsuite.Makefile.in: Regenerate.
	* testsuite/icf_safe_so_test.sh: Change to not fold foo_glob and
	bar_glob.  Refactor code.
	* testsuite/icf_preemptible_functions_test.cc: New file.
	* testsuite/icf_preemptible_functions_test.sh: New file.
	* testsuite/icf_string_merge_test.cc: New file.
	* testsuite/icf_string_merge_test.sh: New file.
	* testsuite/icf_virtual_function_folding_test.cc: New file.
	* testsuite/icf_virtual_function_folding_test.sh: New file.
@
text
@d462 7
@


1.105
log
@	* gold-threads.h (class Once): Define.
	(class Initialize_lock): Rewrite as child of Once.
	* gold-threads.cc (class Once_initialize): Define.
	(once_pointer_control): New static variable.
	(once_pointer, once_arg): New static variables.
	(c_run_once): New static function.
	(Once::Once, Once::run_once, Once::internal_run): New functions.
	(class Initialize_lock_once): Remove.
	(initialize_lock_control): Remove.
	(initialize_lock_pointer): Remove.
	(initialize_lock_once): Remove.
	(Initialize_lock::Initialize_lock): Move to gold-threads.h.
	(Initialize_lock::initialize): Rewrite.
	(Initialize_lock::do_run_once): New function.
	* archive.cc (Archive::interpret_header): Only clear name if it is
	not already empty.
	* fileread.cc: Include "gold-threads.h"
	(file_counts_lock): New static variable.
	(file_counts_initialize_lock): Likewise.
	(File_read::release): Only increment counts when using --stats.
	Use a lock around the increment.
	* parameters.cc (class Set_parameters_target_once): Define.
	(set_parameters_target_once): New static variable.
	(Parameters::Parameters): Move here from parameters.h.
	(Parameters::set_target): Rewrite.
	(Parameters::set_target_once): New function.
	(Parameters::clear_target): Move here and rewrite.
	* parameters.h (class Parameters): Update declarations.  Add
	set_parameters_target_once_ field.
	(Parameters::Parameters): Move to parameters.cc.
	(Parameters::clear_target): Likewise.
	* readsyms.cc (Read_symbols::do_group): Create a Start_group
	task.
	(Start_group::~Start_group): New function.
	(Start_group::is_runnable): New function.
	(Start_group::locks, Start_group::run): New functions.
	(Finish_group::run): Change saw_undefined to size_t.
	* readsyms.h (class Start_group): Define.
	(class Finish_group): Change saw_undefined_ field to size_t.
	(Finish_group::Finish_group): Remove saw_undefined and
	this_blocker parameters.  Change all callers.
	(Finish_group::set_saw_undefined): New function.
	(Finish_group::set_blocker): New function.
	* symtab.h (class Symbol_table): Change saw_undefined to return
	size_t.  Change saw_undefined_ field to size_t.
	* target-select.cc (Set_target_once::do_run_once): New function.
	(Target_selector::Target_selector): Initialize set_target_once_
	field.  Don't initialize lock_ and initialize_lock_ fields.
	(Target_selector::instantiate_target): Rewrite.
	(Target_selector::set_target): New function.
	* target-select.h (class Set_target_once): Define.
	(class Target_selector): Update declarations.  Make
	Set_target_once a friend.  Remove lock_ and initialize_lock_
	fields.  Add set_target_once_ field.
@
text
@d277 1
a277 1
  should_add_dynsym_entry() const;
@


1.104
log
@	PR 11108
	* symtab.h (class Symbol): Remove fields is_target_special_ and
	has_plt_offset_.  Add field is_defined_in_discarded_section_.
	(Symbol::is_defined_in_discarded_section): New function.
	(Symbol::set_is_defined_in_discarded_section): New function.
	(Symbol::has_plt_offset): Rewrite.
	(Symbol::set_plt_offset): Verify that new offset is not -1U.
	* symtab.cc (Symbol::init_fields): Initialize plt_offset_ to -1U.
	Don't initialize is_target_special_ or has_plt_offset_.
	Initialize is_defined_in_discarded_section_.
	(Symbol_table::add_from_relobj): If appropriate, set
	is_defined_in_discarded_section.
	* resolve.cc (Symbol::override_base_with_special): Don't test
	is_target_special_.  Change has_plt_offset_ to has_plt_offset().
	* target-reloc.h (relocate_section): Do special handling for
	symbols defined in discarded sections for global symbols as well
	as local symbols.
@
text
@d1357 1
a1357 1
  int
d1712 1
a1712 1
  int saw_undefined_;
@


1.103
log
@	PR 10979
	* common.cc (Sort_commons::operator()): Stabilize sort when both
	entries are NULL.
	(Symbol_table::do_allocate_commons_list): When allocating common
	symbols, skip a symbol which is no longer common.
	* symtab.h (Symbol::is_common): Test whether the symbol comes from
	an object before checking its type.
	* testsuite/common_test_2.c: New file.
	* testsuite/common_test_3.c: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add common_test_2.
	(common_test_2_SOURCES, common_test_2_DEPENDENCIES): Define.
	(common_test_2_LDFLAGS, common_test_2_LDADD): Define.
	(common_test_2_pic.o, common_test_2.so): New targets.
	(common_test_3_pic.o, common_test_3.so): New targets.
	* testsuite/Makefile.in: Rebuild.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d311 12
d398 1
a398 1
  { return this->has_plt_offset_; }
d412 1
a412 1
    this->has_plt_offset_ = true;
d885 3
a887 5
  // If this symbol has an entry in the GOT section (has_got_offset_
  // is true), this holds the offset from the start of the GOT section.
  // A symbol may have more than one GOT offset (e.g., when mixing
  // modules compiled with two different TLS models), but will usually
  // have at most one.
d890 3
a892 3
  // If this symbol has an entry in the PLT section (has_plt_offset_
  // is true), then this is the offset from the start of the PLT
  // section.
d905 1
a905 4
  // True if this symbol always requires special target-specific
  // handling (bit 19).
  bool is_target_special_ : 1;
  // True if this is the default version of the symbol (bit 20).
d913 1
a913 1
  // Symbol_table (bit 21).
d916 1
a916 1
  // Symbol_table (bit 22).
d919 1
a919 1
  // 23).
d921 1
a921 1
  // True if we've seen this symbol in a regular object (bit 24).
d923 1
a923 1
  // True if we've seen this symbol in a dynamic object (bit 25).
a924 2
  // True if the symbol has an entry in the PLT section (bit 26).
  bool has_plt_offset_ : 1;
d926 1
a926 1
  // the dynamic symbol table (bit 27).
d928 1
a928 1
  // True if there is a warning for this symbol (bit 28).
d931 1
a931 1
  // real definition lives in a dynamic object (bit 29).
d934 1
a934 1
  // script (bit 30).
d938 1
a938 1
  // SHN_HIRESERVE (bit 31).
d940 1
a940 1
  // True if we've seen this symbol in a real ELF object.
d942 3
@


1.102
log
@	PR 10931
	* options.h (class General_options): Add --sort-common option.
	* symtab.h (class Symbol_table): Define Sort_commons_order enum.
	* common.cc (Sort_common): Add sort_order parameter to
	constructor.  Add sort_order_ field.
	(Sort_commons::operator): Check sort_order_.
	(Symbol_table::allocate_commons): Determine the sort order.
	(Symbol_table::do_allocate_commons): Add sort_order parameter.
	Change all callers.
	(Symbol_table::do_allocate_commons_list): Likewise.
@
text
@d481 2
a484 2
    if (this->source_ != FROM_OBJECT)
      return false;
@


1.101
log
@	PR 10450
	* symtab.h (Symbol::needs_dynsym_entry): A symbol in both a
	regular and a dynamic object only needs a dynamic symbol table
	entry if it is externally visible.
@
text
@d1198 8
d1614 1
a1614 1
  do_allocate_commons(Layout*, Mapfile*);
d1620 1
a1620 1
			   Mapfile*);
@


1.100
log
@	* symtab.h (class Symbol_table): Add enum Defined.
	* resolve.cc (Symbol_table::should_override): Add defined
	parameter.  Change all callers.  Test whether object is NULL
	before calling a method on it.
	(Symbol_table::report_resolve_problem): Add defined parameter.
	Change all callers.
	(Symbol_table::should_override_with_special): Likewise.
	* symtab.cc (Symbol_table::define_in_output_data): Add defined
	parameter.  Change all callers.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::define_in_output_segment): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::define_as_constant): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* script.h (class Symbol_assignment): Add is_defsym parameter to
	constructor; change all callers.
	* script.cc (Script_options::add_symbol_assignment): Add is_defsym
	parameter.  Change all callers.  Add is_defsym_ field.
	(class Parser_closure): Add parsing_defsym parameter to
	constructor; change all callers.  Add parsing_defsym accessor
	function.  Add parsing_defsym_ field.
@
text
@d264 3
a266 1
            || (this->in_reg() && this->in_dyn()));
@


1.99
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d1179 17
d1277 1
a1277 1
  define_in_output_data(const char* name, const char* version,
d1286 1
a1286 1
  define_in_output_segment(const char* name, const char* version,
d1295 1
a1295 1
  define_as_constant(const char* name, const char* version,
d1514 1
a1514 1
  should_override(const Symbol*, unsigned int, Object*, bool*);
d1519 1
a1519 1
			 Object* object);
d1532 1
a1532 1
  should_override_with_special(const Symbol*);
d1555 2
a1556 1
  do_define_in_output_data(const char* name, const char* version, Output_data*,
d1567 1
a1567 1
    const char* name, const char* version, Output_segment* os,
d1578 1
a1578 1
    const char* name, const char* version,
@


1.98
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d223 2
a224 2
  set_visibility(elfcpp::STV vis)
  { this->visibility_ = vis; }
d371 3
a373 3
    unsigned int got_off = this->got_offsets_.get_offset(got_type);
    gold_assert(got_off != -1U);
    return got_off;
d378 2
a379 2
  set_got_offset(unsigned int got_type, unsigned int got_off)
  { this->got_offsets_.set_offset(got_type, got_off); }
d396 1
a396 1
  set_plt_offset(unsigned int plt_off)
d399 1
a399 1
    this->plt_offset_ = plt_off;
d435 1
a435 1
    unsigned int sec_shndx = this->shndx(&is_ordinary);
d437 2
a438 2
	    ? sec_shndx != elfcpp::SHN_UNDEF
	    : !Symbol::is_common_shndx(sec_shndx));
d484 2
a485 2
    unsigned int sec_shndx = this->shndx(&is_ordinary);
    return !is_ordinary && Symbol::is_common_shndx(sec_shndx);
d1007 2
a1008 2
  set_symsize(Size_type symsz)
  { this->symsize_ = symsz; }
d1013 2
a1014 2
  set_value(Value_type val)
  { this->value_ = val; }
d1187 2
a1188 2
  set_icf(Icf* _icf)
  { this->icf_ = _icf;}
d1199 2
a1200 2
  set_gc(Garbage_collection* garbage)
  { this->gc_ = garbage; }
@


1.97
log
@2009-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gold/10893
	* i386.cc (Target_i386::Scan::globa): Use is_func instead of
	checking elfcpp::STT_FUNC.
	(Target_i386::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Scan::global): Likewise.

	* symtab.cc (Symbol_table::sized_write_symbol): Turn IFUNC
	symbols from shared libraries into normal FUNC symbols.

	* symtab.h (Symbol): Add is_func and use it.
@
text
@d223 2
a224 2
  set_visibility(elfcpp::STV visibility)
  { this->visibility_ = visibility; }
d371 3
a373 3
    unsigned int got_offset = this->got_offsets_.get_offset(got_type);
    gold_assert(got_offset != -1U);
    return got_offset;
d378 2
a379 2
  set_got_offset(unsigned int got_type, unsigned int got_offset)
  { this->got_offsets_.set_offset(got_type, got_offset); }
d396 1
a396 1
  set_plt_offset(unsigned int plt_offset)
d399 1
a399 1
    this->plt_offset_ = plt_offset;
d435 1
a435 1
    unsigned int shndx = this->shndx(&is_ordinary);
d437 2
a438 2
	    ? shndx != elfcpp::SHN_UNDEF
	    : !Symbol::is_common_shndx(shndx));
d484 2
a485 2
    unsigned int shndx = this->shndx(&is_ordinary);
    return !is_ordinary && Symbol::is_common_shndx(shndx);
d1007 2
a1008 2
  set_symsize(Size_type symsize)
  { this->symsize_ = symsize; }
d1013 2
a1014 2
  set_value(Value_type value)
  { this->value_ = value; }
d1187 2
a1188 2
  set_icf(Icf* icf)
  { this->icf_ = icf;}
d1199 2
a1200 2
  set_gc(Garbage_collection* gc)
  { this->gc_ = gc; }
@


1.96
log
@	PR 10860
	* options.h (class General_options): Add --warn-common.
	* resolve.cc (Symbol_table::resolve): Handle --warn-common when
	merging two common symbols.
	(Symbol_table::should_override): Handle --warn-common when merging
	a common symbol with a defined symbol.  Use report_resolve_problem
	for multiple definitions.
	(Symbol_table::report_resolve_problem): New function.
	* symtab.h (class Symbol_table): Declare report_resolve_problem.
@
text
@d208 8
d554 1
a554 1
            && this->type() == elfcpp::STT_FUNC
d745 1
a745 1
	    && this->type() != elfcpp::STT_FUNC);
@


1.95
log
@	Add support for -pie.
	* options.h (class General_options): Add -pie and
	--pic-executable.
	(General_options::output_is_position_independent): Test -pie.
	(General_options::output_is_executable): Return true if not shared
	and not relocatable.
	(General_options::output_is_pie): Remove.
	* options.cc (General_options::finalize): Reject incompatible uses
	of -pie.
	* gold.cc (queue_middle_tasks): A -pie link is not static.
	* symtab.h (Symbol::needs_plt_entry): Return false if -pie.
	* symtab.cc (Symbol::final_value_is_known): Return false if
	output_is_position_independent.
	* layout.cc (Layout::set_segment_offsets): Start at address 0 if
	output_is_position_independent.
	* output.cc (Output_file_header::do_sized_write): Use ET_DYN if
	output_is_position_independent.
	* i386.cc (Output_data_plt_i386::do_write): Use the PIC PLT if
	output_is_position_independent.
	* testsuite/Makefile.am (check_PROGRAMS): Add basic_pie_test and
	two_file_pie_test.
	(basic_pie_test.o, basic_pie_test): New targets.
	(two_file_test_1_pie.o, two_file_test_1b_pie.o): New targets.
	(two_file_test_2_pie.o, two_file_test_main_pie.o): New targets.
	(two_file_pie_test): New target.
	* testsuite/Makefile.in: Rebuild.
	* README: Remove note saying that -pie is not supported.
@
text
@d1491 5
@


1.94
log
@	* symtab.h: Check for GOLD_SYMTAB_H before header includes. Remove
	includes to gc.h and icf.h.
	* arm.cc: Include gc.h.
	* gold.cc: Likewise.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* gc.h: Include icf.h.
@
text
@d536 1
a536 1
  // static link, we don't create PLT entries.
d545 1
@


1.93
log
@2009-10-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::make_output_section): Call target hook to make
	ordinary output section.
	(Layout::finalize): Adjust parameter list of call the
	Target::may_relax().
	* layout.h (class Layout::section_list): New method.
	* merge.h (Output_merge_base::entsize): Change visibility to public.
	(Output_merge_base::is_string, Output_merge_base::do_is_string):
	New methods.
	(Output_merge_string::do_is_string): New method.
	* object.cc (Sized_relobj::do_setup): renamed from
	Sized_relobj::set_up.
	* object.h (Sized_relobj::adjust_shndx,
	Sized_relobj::initializ_input_to_output_maps,
	Sized_relobj::free_input_to_output_maps): Change visibilities to
	protected.
	(Sized_relobj::setup): Virtualize.
	(Sized_relobj::do_setup): New method declaration.
	(Sized_relobj::invalidate_section_offset,
	Sized_relobj::do_invalidate_section_offset): New method decfinitions.
	(Sized_relobj::elf_file, Sized_relobj::local_values): New methods.
	* options.cc (parse_int): New function.
	* options.h (parse_int): New declaration.
	(DEFINE_int): New macro.
	(stub_group_size): New option.
	* output.cc (Output_section::Output_section): Initialize memebers
	merge_section_map_, merge_section_by_properties_map_,
	relaxed_input_section_map_, is_relaxed_input_section_map_valid_.
	(Output_section::add_input_section): Handled deferred code-fill
	generation and remove an old comment.
	(Output_section::add_relaxed_input_section): New method definition.
	(Output_section::add_merge_input_section): Use merge section by
	properties map to speed to search.  Update merge section maps
	as appropriate.
	(Output_section::build_relaxation_map): New method definition.
	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Same.
	(Output_section::relax_input_section): Renamed to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of pointers to relaxed sections.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section): New method definitions.
	(Output_section::is_input_address_mapped,
	Output_section::output_offset, Output_section::output_address):
	Use output section data maps to speed up searching.
	(Output_section::find_starting_output_address): Add comments.
	(Output_section::do_write,
	Output_section::write_to_postprocessing_buffer): Do code-fill
	generation as appropriate.
	(Output_section::get_input_sections): Invalidate relaxed input section
	map.
	(Output_section::restore_states): Adjust type of checkpoint .
	Invalidate relaxed input section map.
	* output.h (Output_merge_base): New class declaration.
	(Input_section_specifier): New class defintion.
	(class Output_relaxed_input_section) Change base class to
	Output_section_data_build.
	(Output_relaxed_input_section::Output_relaxed_input_section): Adjust
	base class initializer.
	(Output_section::add_relaxed_input_section): New method declaration.
	(Output_section::Input_section): Change visibility to protected.
     	(Output_section::Input_section::relobj,
	Output_section::Input_section::shndx): Handle relaxed input sections.
	Output_section::input_sections) Change visibility to protected.  Also
	define overload to return a non-const pointer.
	(Output_section::Merge_section_properties): New class defintion.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Relaxation_map): New types.
	(Output_section::relax_input_section): Rename method to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of relaxed section pointers.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section,
	Output_section::build_relaxation_map,
	Output_section::convert_input_sections_in_list_to_relaxed_sections):
	New method declarations.
	(Output_section::merge_section_map_
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_,
	Output_section::generate_code_fills_at_write_): New data members.
	* script-sections.cc
	(Output_section_element_input::set_section_addresses): Call
	current_data_size and addralign methods of relaxed input sections.
	(Orphan_output_section::set_section_addresses): Call current_data_size
	and addralign methods of relaxed input sections.
	* symtab.cc (Symbol_table::compute_final_value): Extract template
	from the body of Symbol_table::sized_finalize_symbol.
	(Symbol_table::sized_finalized_symbol): Call
	Symbol_table::compute_final_value.
	* symtab.h (Symbol_table::Compute_final_value_status): New enum type.
	(Symbol_table::compute_final_value): New templated method declaration.
	* target.cc (Target::do_make_output_section): New method defintion.
	* target.h (Target::make_output_section): New method declaration.
	(Target::relax): Add more parameters for input objects, symbol table
	and layout.  Adjust call to do_relax.
	(Target::do_make_output_section): New method declaration.
	(Target::do_relax): Add parameters for input objects, symbol table
	and layout.
@
text
@d26 3
a32 2
#include "gc.h"
#include "icf.h"
a37 3
#ifndef GOLD_SYMTAB_H
#define GOLD_SYMTAB_H

@


1.92
log
@2009-09-30  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::may_need_copy_reloc): Check for THUMB function
	symbol and call Symbol::may_need_copy_reloc to determine if
	a copy reloc is needed.
	* copy-relocs.cc (Copy_relocs::need_copy_reloc): Return false if -z
	nocopyreloc is given in command line.
	(Copy_relocs::emit_copy_reloc): Assert that -z nocopyreloc is not
	given in command line.
	* i386.cc (Target_i386::may_need_copy_reloc): Remove.
	(Target_i386::Scan::global): Use Symbol::may_need_copy_reloc instead
	of the removed Target_i386::may_need_copy_reloc.
	* options.h (copyreloc): New option with default value false.
	* powerpc.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_powerpc::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_powerpc::may_need_copy_reloc.
	* sparc.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_sparc::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_sparc::may_need_copy_reloc.
	* symtab.h (Symbol::may_need_copy_reloc): New method definition.
	* x86_64.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_x86_64::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_x86_64::may_need_copy_reloc.
@
text
@d1380 20
@


1.91
log
@	* object.h (class Object): Remove target_ field, and target,
	sized_target, and set_target methods.
	(Object::sized_target): Remove.
	(class Sized_relobj): Update declarations.  Remove sized_target.
	* object.cc (Sized_relobj::setup): Remove target parameter.
	Change all callers.
	(Input_objects::add_object): Don't do anything with the target.
	(make_elf_sized_object): Add punconfigured parameter.  Change all
	callers.  Set or test parameter target.
	* dynobj.cc (Sized_dynobj::target): Remove target parameter.
	Change all callers.
	* parameters.cc (Parameters::set_target): Change parameter type to
	be non-const.
	(Parameters::default_target): Remove.
	(set_parameters_target): Change parameter type to be non-const.
	(parameters_force_valid_target): New function.
	(parameters_clear_target): New function.
	* parameters.h (class Parameters): Update declarations.  Remove
	default_target method.  Add sized_target and clear_target
	methods.  Change target_ to be non-const.
	(set_parameters_target): Update declaration.
	(parameters_force_valid_target): Declare.
	(parameters_clear_target): Declare.
	* readsyms.cc (Read_symbols::do_read_symbols): Pass punconfigured
	as NULL if we aren't searching.
	(Add_symbols::run): Don't check for compatible target.
	* fileread.cc (Input_file::open_binary): Call
	parameters_force_valid_target.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (make_sized_plugin_object): Likewise.  Don't call
	set_target on object.
	* dynobj.h (class Sized_dynobj): Update declarations.
	* archive.cc (Archive::get_elf_object_for_member): Return NULL if
	make_elf_object returns NULL.
	(Archive::include_member): Don't check whether object target is
	compatible.
	* output.cc (Output_section::add_input_section): Get target from
	parameters.
	(Output_section::relax_input_section): Likewise.
	* reloc.cc (Sized_relobj::do_gc_process_relocs): Get target from
	parameters.
	(Sized_relobj::do_scan_relocs): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* symtab.cc (Symbol_table::wrap_symbol): Likewise.  Remove object
	parameter.  Change all callers.
	(Symbol_table::add_from_object): Get target from parameters.
	(Symbol_table::add_from_relobj): Don't check object target.
	(Symbol_table::add_from_dynobj): Likewise.
	(Symbol_table::define_special_symbol): Get target from
	parameters.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/binary_unittest.cc (gold_testsuite): Remove target
	parameter.  Change all callers.  Clear parameter target.
	(Binary_test): Test target here.
	* testsuite/object_unittest.cc (gold_testsuite): Remove
	target_test_pointer parameter.  Change all callers.
	(Object_test): Test target here.
@
text
@d729 12
@


1.90
log
@*** empty log message ***
@
text
@d1453 1
a1453 1
  wrap_symbol(Object* object, const char*, Stringpool::Key* name_key);
@


1.90.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a25 3
#ifndef GOLD_SYMTAB_H
#define GOLD_SYMTAB_H

d30 2
d37 3
d538 1
a538 1
  // static link or a -pie link, we don't create PLT entries.
a546 1
	    && !parameters->options().pie()
a728 12
  // Return true if this may need a COPY relocation.
  // References from an executable object to non-function symbols
  // defined in a dynamic object may need a COPY relocation.
  bool
  may_need_copy_reloc() const
  {
    return (!parameters->options().shared()
	    && parameters->options().copyreloc()
	    && this->is_from_dynobj()
	    && this->type() != elfcpp::STT_FUNC);
  }

a1367 20
  // Status code of Symbol_table::compute_final_value.
  enum Compute_final_value_status
  {
    // No error.
    CFVS_OK,
    // Unspported symbol section.
    CFVS_UNSUPPORTED_SYMBOL_SECTION,
    // No output section.
    CFVS_NO_OUTPUT_SECTION
  };

  // Compute the final value of SYM and store status in location PSTATUS.
  // During relaxation, this may be called multiple times for a symbol to 
  // compute its would-be final value in each relaxation pass.

  template<int size>
  typename Sized_symbol<size>::Value_type
  compute_final_value(const Sized_symbol<size>* sym,
		      Compute_final_value_status* pstatus) const;

d1453 1
a1453 1
  wrap_symbol(const char* name, Stringpool::Key* name_key);
@


1.90.2.2
log
@	PR 10860
	* options.h (class General_options): Add --warn-common.
	* resolve.cc (Symbol_table::resolve): Handle --warn-common when
	merging two common symbols.
	(Symbol_table::should_override): Handle --warn-common when merging
	a common symbol with a defined symbol.  Use report_resolve_problem
	for multiple definitions.
	(Symbol_table::report_resolve_problem): New function.
	* symtab.h (class Symbol_table): Declare report_resolve_problem.
@
text
@a1490 5
  // Report a problem in symbol resolution.
  static void
  report_resolve_problem(bool is_error, const char* msg, const Symbol* to,
			 Object* object);

@


1.89
log
@	* layout.cc (Layout::make_output_section): Call
	Target::new_output_section.
	(Layout::attach_allocated_section_to_segment): Put large section
	sections in a separate load segment with the large segment flag
	set.
	(Layout::segment_precedes): Sort large data segments after other
	load segments.
	(align_file_offset): New static function.
	(Layout::set_segment_offsets): Use align_file_offset.
	* output.h (class Output_section): Add is_small_section_ and
	is_large_section_ fields.
	(Output_section::is_small_section): New function.
	(Output_section::set_is_small_section):  New function.
	(Output_section::is_large_section): New function.
	(Output_section::set_is_large_section): New function.
	(Output_section::is_large_data_section): New function.
	(class Output_segment): Add is_large_data_segment_ field.
	(Output_segment::is_large_data_segment): New function.
	(Output_segment::set_is_large_data_segment): New function.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_segment::Output_segment): Likewise.
	(Output_segment::add_output_section): Add assertion that large
	data sections always go in large data segments.  Force small data
	sections to the end of the list of data sections.  Force small BSS
	sections to the start of the list of BSS sections.  For large BSS
	sections to the end of the list of BSS sections.
	* symtab.h (class Symbol): Declare is_common_shndx.
	(Symbol::is_defined): Check Symbol::is_common_shndx.
	(Symbol::is_common): Likewise.
	(class Symbol_table): Define enum Commons_section_type.  Update
	declarations.  Add small_commons_ and large_commons_ fields.
	* symtab.cc (Symbol::is_common_shndx): New function.
	(Symbol_table::Symbol_table): Initialize new fields.
	(Symbol_table::add_from_object): Put small and large common
	symbols in the right list.
	(Symbol_table::sized_finalized_symbol): Check
	Symbol::is_common_shndx.
	(Symbol_table::sized_write_globals): Likewise.
	* common.cc (Symbol_table::do_allocate_commons): Allocate new
	common symbol lists.  Don't call do_allocate_commons_list if the
	list is empty.
	(Symbol_table::do_allocate_commons_list): Remove is_tls
	parameter.  Add comons_section_type parameter.  Change all
	callers.  Handle small and large common symbols.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Check
	Symbol::is_common_shndx.
	* resolve.cc (symbol_to_bits): Likewise.
	* target.h (Target::small_common_shndx): New function.
	(Target::small_common_section_flags): New function.
	(Target::large_common_shndx): New function.
	(Target::large_common_section_flags): New function.
	(Target::new_output_section): New function.
	(Target::Target_info): Add small_common_shndx, large_common_shndx,
	small_common_section_flags, and large_common_section_flags
	fields.
	(Target::do_new_output_section): New virtual function.
	* arm.cc (Target_arm::arm_info): Initialize new fields.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Likewise.
	* sparc.c (Target_sparc::sparc_info) [all versions]: Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	(Target_x86_64::do_new_output_section): New function.
	* configure.ac: Define conditional MCMODEL_MEDIUM.
	* testsuite/Makefile.am (check_PROGRAMS): Add large.
	(large_SOURCES, large_CFLAGS, large_DEPENDENCIES): Define.
	(large_LDFLAGS): Define.
	* testsuite/large.c: New file.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Initialize new fields.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d31 1
d62 1
d1168 12
d1184 1
a1184 1
  gc()
d1687 1
@


1.88
log
@	* symtab.h (needs_plt_entry): Check for unsatisfied reference from
	an executable.
	(needs_dynamic_reloc): Likewise.
@
text
@d414 5
d430 1
a430 1
	    : shndx != elfcpp::SHN_COMMON);
d471 4
d476 2
a477 4
    return (this->source_ == FROM_OBJECT
	    && ((this->shndx(&is_ordinary) == elfcpp::SHN_COMMON
		 && !is_ordinary)
		|| this->type_ == elfcpp::STT_COMMON));
d1515 10
d1533 2
a1534 1
  do_allocate_commons_list(Layout*, bool is_tls, Commons_type*, Mapfile*);
d1651 4
@


1.87
log
@	* symtab.cc (Symbol_table::define_default_version): New function,
	broken out of add_from_object.
	(Symbol_table::add_from_object): Call define_default_version.
	(Symbol_table::define_special_symbol): Add resolve_oldsym
	parameter.  Change all callers.  If the version for a symbol comes
	from a version script, resolve it with the symbol with the same
	name with no version.  Also add the symbol without a version if
	appropriate.
	(do_define_in_output_data): If resolving with oldsym, don't delete
	sym.
	(do_define_in_output_segment): Likewise.
	(do_define_as_constant): Likewise.
	* symtab.h (class Symbol_table): Update declarations.
@
text
@d533 4
d568 1
a568 1
    // A reference to a weak undefined symbol from an executable should be
d571 1
a571 1
    if (this->is_weak_undefined() && !parameters->options().shared())
@


1.86
log
@	PR 6811
	* options.h (class Search_directory): Add is_system_directory.
	(class General_options): Declare is_in_system_directory.
	* options.cc (get_relative_sysroot): Make static.
	(get_default_sysroot): Make static.
	(General_optoins::is_in_system_directory): New function.
	* fileread.cc (Input_file::is_in_system_directory): New function.
	* fileread.h (class Input_file): Declare is_in_system_directory.
	* object.h (class Object): Add is_in_system_directory.
	(class Input_objects): Remove system_library_directory_ field.
	* object.cc (Input_objects::add_object): Don't set
	system_library_directory_.
	(input_objects::found_in_system_library_directory): Remove.
	* symtab.cc (Symbol_table::write_globals): Remove input_objects
	parameter.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::warn_about_undefined_dynobj_symbol): Likewise.
	Call Object::is_in_system_directory.
	* symtab.h (class Symbol_table): Update declarations.
@
text
@d1370 19
d1402 6
d1463 2
a1464 1
			bool only_if_ref, Sized_symbol<size>** poldsym);
a1559 19
  // The type of the symbol hash table.

  typedef std::pair<Stringpool::Key, Stringpool::Key> Symbol_table_key;

  struct Symbol_table_hash
  {
    size_t
    operator()(const Symbol_table_key&) const;
  };

  struct Symbol_table_eq
  {
    bool
    operator()(const Symbol_table_key&, const Symbol_table_key&) const;
  };

  typedef Unordered_map<Symbol_table_key, Symbol*, Symbol_table_hash,
			Symbol_table_eq> Symbol_table_type;

@


1.85
log
@	PR 9836
	* symtab.cc (Symbol_table::add_from_object): If the visibility is
	hidden or internal, force the symbol to be local.
	* resolve.cc (Symbol::override_visibility): Define.
	(Symbol::override_base): Use override_visibility.
	(Symbol_table::resolve): Likewise.
	(Symbol::override_base_with_special): Likewise.
	(Symbol_table::override_with_special): If the visibility is hidden
	or internal, force the symbol to be local.
	* symtab.h (class Symbol): Add set_visibility and
	override_visibility.
	* testsuite/ver_test_1.sh: New file.
	* testsuite/Makefile.am (check_SCRIPTS): Add ver_test_1.sh.
	(check_DATA): Add ver_test_1.syms.
	(ver_test_1.syms): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1345 1
a1345 1
  write_globals(const Input_objects*, const Stringpool*, const Stringpool*,
d1512 3
a1514 3
  sized_write_globals(const Input_objects*, const Stringpool*,
		      const Stringpool*, Output_symtab_xindex*,
		      Output_symtab_xindex*, Output_file*) const;
d1526 1
a1526 1
  warn_about_undefined_dynobj_symbol(const Input_objects*, Symbol*) const;
@


1.84
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d213 9
d1396 2
a1397 1
  // Record that a symbol is forced to be local by a version script.
@


1.83
log
@Add plugin functionality for link-time optimization (LTO).

include/:
	* plugin-api.h: New file.

gold/:
	* configure.ac (plugins): Add --enable-plugins option.
	* configure: Regenerate.
	* config.in: Regenerate.
	* Makefile.am (LIBDL): New variable.
	(CCFILES): Add plugin.cc.
	(HFILES): Add plugin.h.
	(ldadd_var): Add LIBDL.
	* Makefile.in: Regenerate.

	* archive.cc: Include "plugin.h".
	(Archive::setup): Don't preread archive symbols when using a plugin.
	(Archive::get_file_and_offset): Add memsize parameter.  Change callers.
	(Archive::get_elf_object_for_member): Call plugin hooks for claiming
	files.
	(Archive::include_member): Add symbols from plugin objects.
	* archive.h (Archive::get_file_and_offset): Add memsize parameter.
	* descriptors.cc (Descriptors::open): Check for file descriptors
	abandoned by plugins.
	(Descriptors::claim_for_plugin): New function.
	* descriptors.h (Descriptors::claim_for_plugin): New function.
	(Open_descriptor::is_claimed): New field.
	(claim_descriptor_for_plugin): New function.
	* fileread.cc (File_read::claim_for_plugin): New function.
	* fileread.h (File_read::claim_for_plugin): New function.
	(File_read::descriptor): New function.
	* gold.cc: Include "plugin.h".
	(queue_initial_tasks): Add task to call plugin hooks for generating
	new object files.
	* main.cc: Include "plugin.h".
	(main): Load plugin libraries.
	* object.h (Pluginobj): Declare.
	(Object::pluginobj): New function.
	(Object::do_pluginobj): New function.
	(Object::set_target): New function.
	* options.cc: Include "plugin.h".
	(General_options::parse_plugin): New function.
	(General_options::General_options): Initialize plugins_ field.
	(General_options::add_plugin): New function.
	* options.h (Plugin_manager): Declare.
	(General_options): Add --plugin option.
	(General_options::has_plugins): New function.
	(General_options::plugins): New function.
	(General_options::add_plugin): New function.
	(General_options::plugins_): New field.
	* plugin.cc: New file.
	* plugin.h: New file.
	* readsyms.cc: Include "plugin.h".
	(Read_symbols::do_read_symbols): Check for archive before checking
	for ELF file.  Call plugin hooks to claim files.
	* resolve.cc (Symbol_table::resolve): Record when symbol is referenced
	from a real object file; force override when processing replacement
	files.
	* symtab.cc (Symbol::init_fields): Initialize in_real_elf_ field.
	(Symbol::init_base_object): Likewise.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): Likewise.
	(Symbol::output_section): Assert that object is not a plugin.
	(Symbol_table::add_from_pluginobj): New function.
	(Symbol_table::sized_finalize_symbol): Treat symbols from plugins as
	undefined.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::add_from_pluginobj): Instantiate template.
	* symtab.h (Sized_pluginobj): Declare.
	(Symbol::in_real_elf): New function.
	(Symbol::set_in_real_elf): New function.
	(Symbol::in_real_elf_): New field.
	(Symbol_table::add_from_pluginobj): New function.

	* testsuite/Makefile.am (AM_CFLAGS): New variable.
	(LIBDL): New variable.
	(LDADD): Add LIBDL.
	(check_PROGRAMS): Add plugin_test_1 and plugin_test_2.
	(check_SCRIPTS): Add plugin_test_1.sh and plugin_test_2.sh.
	(check_DATA): Add plugin_test_1.err and plugin_test_2.err.
	(MOSTLYCLEANFILES): Likewise.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_test.c: New file.
	* testsuite/plugin_test_1.sh: New file.
	* testsuite/plugin_test_2.sh: New file.
@
text
@d30 1
d60 1
d1145 22
d1629 1
@


1.82
log
@	* symtab.h (Symbol::use_plt_offset): New function.
	* i386.cc (Relocate::relocate): Call Symbol::use_plt_offset.
	* powerpc.cc (Relocate::relocate): Likewise.
	* sparc.cc (Relocate::relocate): Likewise.
	* x86_64.cc (Relocate::relocate): Likewise.
	* testsuite/weak_plt.sh: New test.
	* testsuite/weak_plt_main.cc: New test.
	* testsuite/weak_plt_shared.cc: New test.
	* testsuite/Makefile.am (check_SCRIPTS): Add weak_plt.sh.
	(check_PROGRAMS): Add weak_plt.
	(check_DATA): Add weak_plt_shared.so.
	(weak_plt_main_pic.o, weak_plt): New targets.
	(weak_plt_shared_pic.o, weak_plt_shared.so): New targets.
	* testsuite/Makefile.in: Rebuild.

	* testsuite/Makefile.am (weak_alias_test_1.so): Depend upon
	gcctestdir/ld.
	(weak_alias_test_2.so, weak_alias_test_4.so): Likewise.
	* testsuite/Makefile.in: Rebuild.
@
text
@d46 2
d278 12
d888 1
a888 1
  // SHN_HIRESERVE.
d890 2
d1158 8
@


1.81
log
@	* symtab.cc (Symbol_table::resolve): Remove version parameter.
	Change all callers.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/ver_test_9.cc: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add ver_test_9.
	(ver_test_9_SOURCES, ver_test_9_DEPENDENCIES): Define.
	(ver_test_9_LDFLAGS, ver_test_9_LDADD): Define.
	(ver_test_9.so, ver_test_9.o): New targets.
	* testsuite/Makefile.in: Rebuild.
@
text
@d580 42
@


1.80
log
@	* cref.cc: New file.
	* cref.h: New file.
	* options.h (class General_options): Add --print-symbol-counts.
	* main.cc (main): Issue defined symbol report if requested.
	* archive.cc (Archive::interpret_header): Make into a const member
	function.
	(Archive::add_symbols): Call Input_objects::archive_start and
	archive_stop.
	(Archive::const_iterator): Define new class.
	(Archive::begin, Archive::end): New functions.
	(Archive::include_all_members): Rewrite to use iterator.
	(Archive::count_members): New function.
	* archive.h (class Archive): Update declarations.
	(Archive::filename): New function.
	* object.cc: Include "cref.h".
	(Sized_relobj::Sized_relobj): Initialize defined_count_.
	(Sized_relobj::do_get_global_symbol_counts): New function.
	(Input_objects::add_object): Add object to cross-referencer.
	(Input_objects::archive_start): New function.
	(Input_objects::archive_stop): New function.
	(Input_objects::print_symbol_counts): New function.
	* object.h: Declare Cref and Archive.
	(Object::get_global_symbol_counts): New function.
	(Object::do_get_global_symbol_counts): New pure virtual function.
	(class Sized_relobj): Add defined_count_ field.  Update
	declarations.
	(class Input_objects): Add cref_ field.  Update constructor.
	Update declarations.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize symbols_ and
	defined_count_.
	(Sized_dynobj::do_add_symbols): Allocate symbols_ if printing
	symbol counts.
	(Sized_dynobj::do_get_global_symbol_counts): New function.
	* dynobj.h (class Sized_dynobj): Add fields symbols_ and
	defined_count_.  Update declarations.  Define Symbols typedef.
	* symtab.cc (Symbol_table::add_from_relobj): Add defined
	parameter.  Change all callers.
	(Symbol_table::add_from_dynobj): Add sympointers and defined
	parameters.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* Makefile.am (CCFILES): Add cref.cc.
	(HFILES): Add cref.h.
	* Makefile.in: Rebuild.
@
text
@d1295 1
a1295 2
  resolve(Sized_symbol<size>* to, const Sized_symbol<size>* from,
          const char* version);
@


1.79
log
@	* mapfile.cc: New file.
	* mapfile.h: New file.
	* options.h (class General_options): Add -M/--print-map and -Map.
	* options.cc (General_options::finalize): Make -M equivalent to
	-Map -.
	* main.cc: Include <cstdio> and "mapfile.h".
	(main): Open mapfile if requested.
	* gold.cc (class Middle_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(queue_initial_tasks): Add mapfile parameter.  Change caller.
	(queue_middle_tasks): Likewise.
	* gold.h (queue_initial_tasks, queue_middle_tasks): Update
	declarations.
	* archive.cc: Include "mapfile.h".
	(Archive::add_symbols): Add mapfile parameter.  Change all
	callers.  Pass mapfile, symbol, and reason to include_member.
	(Archive::include_all_members): Add mapfile parameter.  Change all
	callers.
	(Archive::include_member): Add mapfile, sym, and why parameters.
	Change all callers.  Report inclusion to map file.
	* archive.h: Include "fileread.h".
	(class Archive): Update declarations.
	(Archive::file): New const method.
	(class Add_archive_symbols): Add mapfile_ field.  Update
	constructor.  Change all callers.
	* readsyms.h (class Read_symbols): Likewise.
	(class Finish_group): Likewise.
	(class Read_script): Likewise.
	* common.cc: Include "mapfile.h".
	(Symbol_table::allocate_commons): Add mapfile parameter.  Change
	all callers.
	(Symbol_table::do_allocate_commons): Likewise.
	(Symbol_table::do_allocate_commons_list): Likewise.  Report common
	symbol allocation to mapfile.
	* common.h (class Allocate_commons_task): Add mapfile_ field.
	Update constructor.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* layout.cc: Include "mapfile.h".
	(Layout_task_runner::run): Print information to mapfile.
	(Layout::create_gold_note): Change Output_data_fixed_space to
	Output_data_zero_fill.
	(Layout::create_build_id): Likewise.
	(Layout::print_to_mapfile): New function.
	* layout.h (class Layout_task_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(class Layout): Declare print_to_mapfile.
	* output.cc (Output_section::Input_section::print_to_mapfile): New
	function.
	(Output_section::add_input_section): If producing a map, always
	add to input_sections_ list.
	(Output_section::do_print_to_mapfile): New function.
	(Output_segment::print_sections_to_mapfile): New function.
	(Output_segment::print_section_list_to_mapfile): New function.
	* output.h: Include "mapfile.h".
	(Output_data::print_to_mapfile): New function.
	(Output_data::do_print_to_mapfile): New virtual function.
	(Output_segment_headers::do_print_to_mapfile): New function.
	(Output_file_header::do_print_to_mapfile): New function.
	(Output_data_const::do_print_to_mapfile): New function.
	(class Output_data_const_buffer): Add map_name_ field.  Update
	constructor.  Change all callers.  Add do_print_to_mapfile
	function.
	(class Output_data_fixed_space): Likewise.
	(class Output_data_space): Likewise.
	(class Output_data_zero_fill): New class.
	(Output_data_strtab::do_print_to_mapfile): New function.
	(Output_data_reloc_base::do_print_to_mapfile): New function.
	(Output_relocatable_relocs::do_print_to_mapfile): New function.
	(Output_data_group::do_print_to_mapfile): New function.
	(Output_data_got::do_print_to_mapfile): New function.
	(Output_data_dynamic::do_print_to_mapfile): New function.
	(Output_symtab_xindex::do_print_to_mapfile): New function.
	(class Output_section): Declare do_print_to_mapflie.  Declare
	print_to_mapfile in Input_section.
	(class Output_segment): Declare new functions.
	* object.h (Sized_relobj::symbol_count): New function.
	* script-sections.cc
	(Output_section_element_dot_assignment::set_section_addresses):
	Change Output_data_fixed_space to Output_data_zero_fill.
	(Output_data_expression::do_print_to_mapfile): New function.
	* script.cc (read_input_script): Add mapfile parameter.  Change
	all callers.
	* script.h (read_input_script): Update declaration.
	* ehframe.h (Eh_frame_hdr::do_print_to_mapfile): New function.
	(Eh_frame::do_print_to_mapfile): New function.
	* merge.h (Output_merge_data::do_print_to_mapfile): New function.
	(Output_merge_string::do_print_to_mapfile): New function.
	* i386.cc (Output_data_plt_i386::do_print_to_mapfile): New
	function.
	* sparc.cc (Output_data_plt_sparc::do_print_to_mapfile): New
	function.
	* x86_64.cc (Output_data_plt_x86_64::do_print_to_mapfile): New
	function.
	* Makefile.am (CCFILES): Add mapfile.cc.
	(HFILES): Add mapfile.h.
	* Makefile.in: Rebuild.
@
text
@d1089 2
a1090 1
  // SYMPOINTERS to point to the symbols in the symbol table.
d1097 2
a1098 1
		  typename Sized_relobj<size, big_endian>::Symbols*);
d1110 3
a1112 1
		  const std::vector<const char*>*);
@


1.78
log
@	* symtab.c (Symbol::init_base_output_data): Add version
	parameter.  Change all callers.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): Likewise.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Sized_symbol::init_undefined): Likewise.
	(Symbol_table::do_define_in_output_data): If the new symbol has a
	version, mark it as the default.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* symtab.h (class Symbol): Update declarations.
	(class Sized_symbol): Likewise.
	* resolve.cc (Symbol::override_version): New function.
	(Symbol::override_base: Call override_version.
	(Symbol::override_base_with_special): Likewise.
	* testsuite/ver_script_8.script: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add ver_test_8.
	(ver_test_8_SOURCES, ver_test_8_DEPENDENCIES): Define.
	(ver_test_8_LDFLAGS, ver_test_8_LDADD): Define.
	(ver_test_8_1.so, ver_test_8_2.so): New targets.
@
text
@d41 1
d1181 1
a1181 1
  allocate_commons(Layout*);
d1378 1
a1378 1
  do_allocate_commons(Layout*);
d1383 1
a1383 1
  do_allocate_commons_list(Layout*, bool is_tls, Commons_type*);
@


1.77
log
@	PR 6049
	* options.h (DEFINE_set): Add VARNAME_begin and VARNAME_end
	functions.
	(class General_options): Remove existing --undefined, and add
	--no-undefined instead.  Add new --undefined as synonym for -u.
	* archive.cc (Archive::add_symbols): Check whether symbol was
	named with -u.
	* gold.cc (queue_middle_tasks): Add -u symbols to symbol table.
	* symtab.h (class Symbol): Rename CONSTANT to IS_CONSTANT; change
	all uses.  Add IS_UNDEFINED.  Update declarations to split
	different versions of init_base.  Declare init_base_undefined.
	(Symbol::is_defined): Handle IS_UNDEFINED.
	(Symbol::is_undefined): Likewise.
	(Symbol::is_weak_undefined): Call is_undefined.
	(Symbol::is_absolute): Handle IS_CONSTANT.
	(class Sized_symbol): Update declarations to split different
	versions of init.  Declare init_undefined.
	(class Symbol_table): Declare new functions.
	* symtab.cc (Symbol::init_base_object): Rename from init_base.
	Change all callers.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): New function.
	(Sized_symbol::init_object): Rename from init.  Change all
	callers.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Sized_symbol::init_undefined): New function.
	(Symbol_table::add_undefined_symbols_from_command_line): New
	function.
	(Symbol_table::do_add_undefined_symbols_from_command_line): New
	function.
	(Symbol::final_value_is_known): Handle IS_UNDEFINED.
	(Symbol::output_section): Likewise.
	(Symbol::set_output_section): Likewise.
	(Symbol_table::sized_finalize_symbol): Likewise.
	(Symbol_table::sized_write_globals): Likewise.
	* resolve.cc (Symbol_table::should_override): Likewise.
	(Symbol::override_base_with_special): Likewise.
@
text
@d671 3
a673 3
  init_base_output_data(const char* name, Output_data*, elfcpp::STT,
			elfcpp::STB, elfcpp::STV, unsigned char nonvis,
			bool offset_is_from_end);
d677 4
a680 3
  init_base_output_segment(const char* name, Output_segment* os,
			   elfcpp::STT type, elfcpp::STB binding,
			   elfcpp::STV visibility, unsigned char nonvis,
d685 3
a687 2
  init_base_constant(const char* name, elfcpp::STT type, elfcpp::STB binding,
		     elfcpp::STV visibility, unsigned char nonvis);
d691 3
a693 2
  init_base_undefined(const char* name, elfcpp::STT type, elfcpp::STB binding,
		      elfcpp::STV visibility, unsigned char nonvis);
d705 4
d859 4
a862 3
  init_output_data(const char* name, Output_data*, Value_type value,
		   Size_type symsize, elfcpp::STT, elfcpp::STB, elfcpp::STV,
		   unsigned char nonvis, bool offset_is_from_end);
d866 4
a869 3
  init_output_segment(const char* name, Output_segment*, Value_type value,
		      Size_type symsize, elfcpp::STT, elfcpp::STB, elfcpp::STV,
		      unsigned char nonvis, Segment_offset_base offset_base);
d873 3
a875 2
  init_constant(const char* name, Value_type value, Size_type symsize,
		elfcpp::STT, elfcpp::STB, elfcpp::STV, unsigned char nonvis);
d879 2
a880 2
  init_undefined(const char* name, elfcpp::STT, elfcpp::STB, elfcpp::STV,
		 unsigned char nonvis);
@


1.76
log
@	* options.h (class General_options): Add -Bsymbolic-functions.
	* symtab.h (Symbol::is_preemptible): Check for
	-Bsymbolic-functions.
@
text
@d81 3
a83 1
    CONSTANT
d395 1
a395 1
      return true;
d414 4
a417 3
    return (this->source_ == FROM_OBJECT
	    && this->shndx(&is_ordinary) == elfcpp::SHN_UNDEF
	    && is_ordinary);
d423 1
a423 7
  {
    bool is_ordinary;
    return (this->source_ == FROM_OBJECT
            && this->binding() == elfcpp::STB_WEAK
            && this->shndx(&is_ordinary) == elfcpp::SHN_UNDEF
	    && is_ordinary);
  }
d430 4
a433 3
    return (this->source_ == FROM_OBJECT
	    && this->shndx(&is_ordinary) == elfcpp::SHN_ABS
	    && !is_ordinary);
d665 3
a667 3
  init_base(const char *name, const char* version, Object* object,
	    const elfcpp::Sym<size, big_endian>&, unsigned int st_shndx,
	    bool is_ordinary);
d671 3
a673 2
  init_base(const char* name, Output_data*, elfcpp::STT, elfcpp::STB,
	    elfcpp::STV, unsigned char nonvis, bool offset_is_from_end);
d677 4
a680 3
  init_base(const char* name, Output_segment* os, elfcpp::STT type,
	    elfcpp::STB binding, elfcpp::STV visibility,
	    unsigned char nonvis, Segment_offset_base offset_base);
d684 7
a690 2
  init_base(const char* name, elfcpp::STT type, elfcpp::STB binding,
	    elfcpp::STV visibility, unsigned char nonvis);
d846 3
a848 3
  init(const char *name, const char* version, Object* object,
       const elfcpp::Sym<size, big_endian>&, unsigned int st_shndx,
       bool is_ordinary);
d852 3
a854 3
  init(const char* name, Output_data*, Value_type value, Size_type symsize,
       elfcpp::STT, elfcpp::STB, elfcpp::STV, unsigned char nonvis,
       bool offset_is_from_end);
d858 3
a860 3
  init(const char* name, Output_segment*, Value_type value, Size_type symsize,
       elfcpp::STT, elfcpp::STB, elfcpp::STV, unsigned char nonvis,
       Segment_offset_base offset_base);
d864 7
a870 2
  init(const char* name, Value_type value, Size_type symsize,
       elfcpp::STT, elfcpp::STB, elfcpp::STV, unsigned char nonvis);
d1197 5
d1358 6
@


1.75
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d470 30
a499 6
    return (this->visibility_ != elfcpp::STV_INTERNAL
            && this->visibility_ != elfcpp::STV_HIDDEN
            && this->visibility_ != elfcpp::STV_PROTECTED
            && !this->is_forced_local_
            && parameters->options().shared()
	    && !parameters->options().Bsymbolic());
@


1.74
log
@	* common.cc (Symbol_table::allocate_commons): Remove options
	parameter.  Change caller.
	(Symbol_table::do_allocate_commons): Remove options parameter.
	Change caller.  Just call do_allocate_commons_list twice.
	(Symbol_table::do_allocate_commons_list): New function, broken out
	of do_allocate_commons.
	* common.h (class Allocate_commons_task): Remove options_ field.
	Update constructor.
	* symtab.cc (Symbol_table::Symbol_table): Initialize
	tls_commons_.
	(Symbol_table::add_from_object): Put TLS common symbols on
	tls_commons_ list.
	(Symbol_table::sized_finalize_symbol): Handle STT_TLS symbols
	which are IN_OUTPUT_DATA.
	* symtab.h (class Symbol_table): Add tls_commons_ field.  Update
	allocate_commons and do_allocate_commons declarations.  Declare
	do_allocate_commons_list.
	* gold.cc (queue_middle_tasks): Update creation of
	Allocate_commons_task to not pass options.
	* testsuite/Makefile.am (INCLUDES): Add -I.. .
	(TLS_TEST_C_FLAGS): New variable.
	(tls_test_c_pic.o): New target.
	(tls_test_shared.so): Link in tls_test_c_pic.o.
	(tls_test_c_pic_ie.o): New target.
	(tls_test_ie_shared.so): Link in tls_test_c_pic_ie.o.
	(tls_test_DEPENDENCIES, tls_test_LDADD): Add tls_test_c.o.
	(tls_test_c.o): New target.
	(tls_pic_test_DEPENDENCIES): Add tls_test_c_pic.o.
	(tls_pic_test_LDADD): Likewise.
	(tls_shared_gd_to_ie_test_DEPENDENCIES): Add tls_test_c_pic.o.
	(tls_shared_gd_to_ie_test_LDADD): Likewise.
	(tls_test_c_gnu2.o): New target.
	(tls_shared_gnu2_gd_to_ie_test_DEPENDENCIES): Add
	tls_test_c_gnu2.o.
	(tls_shared_gnu2_gd_to_ie_test_LDADD): Likewise.
	(tls_test_gnu2_shared.so): Link in tls_test_c_gnu2.o.
	(tls_test_shared_nonpic.so): Link in tls_test_c.o.
	* testsuite/tls_test.cc: Include "config.h".
	(t_last): Call t11_last.
	* testsuite/tls_test.h (t11, t11_last): Declare.
	* testsuite/tls_test_c.c: New file.
	* testsuite/tls_test_main.cc (thread_routine): Call t11.
	* configure.ac: Check for OpenMP support.
	* configure, config.in, Makefile.in: Rebuild.
	* testsuite/Makefile.in: Rebuild.
@
text
@d55 1
d146 1
a146 1
  shndx() const
d149 1
d391 7
a397 3
    return (this->source_ != FROM_OBJECT
	    || (this->shndx() != elfcpp::SHN_UNDEF
		&& this->shndx() != elfcpp::SHN_COMMON));
d411 4
a414 1
    return this->source_ == FROM_OBJECT && this->shndx() == elfcpp::SHN_UNDEF;
d421 1
d424 2
a425 1
            && this->shndx() == elfcpp::SHN_UNDEF);
d432 4
a435 1
    return this->source_ == FROM_OBJECT && this->shndx() == elfcpp::SHN_ABS;
d442 1
d444 2
a445 1
	    && (this->shndx() == elfcpp::SHN_COMMON
d638 3
a640 1
  // Initialize fields from an ELF symbol in OBJECT.
d644 2
a645 1
	    const elfcpp::Sym<size, big_endian>&);
d666 2
a667 2
  override_base(const elfcpp::Sym<size, big_endian>&, Object* object,
		const char* version);
d747 1
a747 1
  // Symbol type.
d749 1
a749 1
  // Symbol binding.
d751 1
a751 1
  // Symbol visibility.
d753 1
a753 1
  // Rest of symbol st_other field.
d755 1
a755 1
  // The type of symbol.
d758 1
a758 1
  // handling.
d760 1
a760 1
  // True if this is the default version of the symbol.
d768 1
a768 1
  // Symbol_table.
d771 1
a771 1
  // Symbol_table.
d773 2
a774 1
  // True if this symbol needs to be in the dynamic symbol table.
d776 1
a776 1
  // True if we've seen this symbol in a regular object.
d778 1
a778 1
  // True if we've seen this symbol in a dynamic object.
d780 1
a780 1
  // True if the symbol has an entry in the PLT section.
d783 1
a783 1
  // the dynamic symbol table.
d785 1
a785 1
  // True if there is a warning for this symbol.
d788 1
a788 1
  // real definition lives in a dynamic object.
d791 1
a791 1
  // script.
d793 4
d812 3
a814 1
  // Initialize fields from an ELF symbol in OBJECT.
d818 2
a819 1
       const elfcpp::Sym<size, big_endian>&);
d841 2
a842 2
  override(const elfcpp::Sym<size, big_endian>&, Object* object,
	   const char* version);
d1041 4
a1044 3
  // the symbol table.  SYMS is the symbols, SYM_NAMES is their names,
  // SYM_NAME_SIZE is the size of SYM_NAMES.  This sets SYMPOINTERS to
  // point to the symbols in the symbol table.
d1049 2
a1050 1
		  const char* sym_names, size_t sym_name_size,
d1193 1
d1198 2
a1199 1
  write_section_symbol(const Output_section*, Output_file*, off_t) const;
d1227 2
a1228 1
                  const elfcpp::Sym<size, big_endian>& orig_sym);
d1235 2
a1236 1
	  const elfcpp::Sym<size, big_endian>& orig_sym,
d1262 1
d1354 2
a1355 1
		      const Stringpool*, Output_file*) const;
d1372 2
a1373 1
  sized_write_section_symbol(const Output_section*, Output_file*, off_t) const;
@


1.73
log
@	* symtab.h (Symbol::is_strong_undefined): Removed unused function.
	(Symbol::needs_plt_entry): Allow weak undefined symbols.
	(Symbol::needs_dynamic_reloc): Allow weak undefined symbols when
	building shared libraries.
	* testsuite/Makefile.am (weak_undef_nonpic_test): New target.
	(weak_undef_file1_nonpic.o, weak_undef_file2_nonpic.o)
	(weak_undef_lib_nonpic.so, alt/weak_undef_lib_nonpic.so): New targets.
	* testsuite/Makefile.in: Rebuild.
	* testsuite/weak_undef.h: New file.
	* testsuite/weak_undef_file1.cc: Add extra test cases.
	* testsuite/weak_undef_file2.cc: Likewise.
	* testsuite/weak_undef_test.cc: Likewise.
@
text
@d1107 1
a1107 1
  allocate_commons(const General_options&, Layout*);
d1183 3
d1288 6
a1293 1
  do_allocate_commons(const General_options&, Layout*);
a1357 3
  // The type of the list of common symbols.
  typedef std::vector<Symbol*> Commons_type;

d1424 3
@


1.72
log
@	* options.h (class General_options): Define --wrap as a special
	option.  Add wrap_symbols_ field.
	(General_options::any_wrap_symbols): New function.
	(General_options::is_wrap_symbol): New function.
	* options.cc (General_options::parse_wrap): New function.
	(General_options::General_options): Initialize wrap_symbols_.
	* symtab.cc (Symbol_table::wrap_symbol): New function.
	(Symbol_table::add_from_object): Handle --wrap.
	* symtab.h (class Symbol_table): Declare wrap_symbol.
	* target.h (Target::wrap_char): New function.
	(Target::Target_info): Add wrap_char field.
	* i386.cc (Target_i386::i386_info): Initialize wrap_char.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Likewise.
@
text
@a416 9
  // Return whether this is a strong (i.e., not weak) undefined symbol.
  bool
  is_strong_undefined() const
  {
    return (this->source_ == FROM_OBJECT
            && this->binding() != elfcpp::STB_WEAK
            && this->shndx() == elfcpp::SHN_UNDEF);
  }

d472 1
a472 1
                || this->is_strong_undefined()
d500 8
a507 3
    // A reference to a weak undefined symbol or to an absolute symbol
    // does not need a dynamic relocation.
    if (this->is_weak_undefined() || this->is_absolute())
@


1.71
log
@2008-04-04  Cary Coutant  <ccoutant@@google.com>

	* symtab.h (Symbol::is_weak_undefined): New function.
	(Symbol::is_strong_undefined): New function.
	(Symbol::is_absolute): New function.
	(Symbol::needs_plt_entry): Exclude weak undefined symbols.
	(Symbol::needs_dynamic_reloc): Exclude weak undefined and
	absolute symbols.
	* testsuite/Makefile.am (check_PROGRAMS): Add weak_undef_test.
	(weak_undef_test): New target.
	* testsuite/Makefile.in: Rebuild.
	* testsuite/weak_undef_file1.cc: New file.
	* testsuite/weak_undef_file2.cc: New file.
	* testsuite/weak_undef_test.cc: New file.
@
text
@d1216 4
@


1.70
log
@	* i386.cc (Target_i386::Got_type): New enum declaration.
	(Target_i386::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocate::relocate_tls): Likewise.
	* object.h (Got_offset_list): New class.
	(Sized_relobj::local_has_got_offset): Added got_type parameter.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::local_has_tls_got_offset): Removed.
	(Sized_relobj::local_tls_got_offset): Removed.
	(Sized_relobj::set_local_tls_got_offset): Removed.
	(Sized_relobj::Local_got_offsets): Changed to store a list of offsets.
	* output.cc (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* output.h (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* resolve.cc (Symbol::override_base_with_special): Removed
	reference to has_got_offset_ field.
	* symtab.cc (Symbol::init_fields): Replaced initialization
	of got_offset_ with got_offsets_.  Removed initialization
	of has_got_offset_
	*symtab.h (Symbol::has_got_offset): Aded got_type parameter.
	(Symbol::got_offset): Likewise.
	(Symbol::set_got_offset): Likewise.
	(Symbol::has_tls_got_offset): Removed.
	(Symbol::tls_got_offset): Removed.
	(Symbol::set_tls_got_offset): Removed.
	(Symbol::got_offset_): Removed.
	(Symbol::tls_mod_got_offset_): Removed.
	(Symbol::tls_pair_got_offset_): Removed.
	(Symbol::got_offsets_): New field.
	(Symbol::has_got_offset): Removed.
	(Symbol::has_tls_mod_got_offset): Removed.
	(Symbol::has_tls_pair_got_offset): Removed.
	* x86_64.cc (Target_x86_64::Got_type): New enum declaration.
	(Target_x86_64::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocate::relocate_tls): Likewise.
@
text
@d408 25
d481 1
a481 1
                || this->is_undefined()
d509 5
@


1.69
log
@Don't get confused about whether a symbol is the default version if we
see a later reference to it.  Add tests for this case.
@
text
@d326 2
a327 2
  has_got_offset() const
  { return this->has_got_offset_; }
d331 1
a331 1
  got_offset() const
d333 3
a335 2
    gold_assert(this->has_got_offset());
    return this->got_offset_;
d340 2
a341 34
  set_got_offset(unsigned int got_offset)
  {
    this->has_got_offset_ = true;
    this->got_offset_ = got_offset;
  }

  // Return whether this TLS symbol has an entry in the GOT section for
  // its module index or, if NEED_PAIR is true, has a pair of entries
  // for its module index and dtv-relative offset.
  bool
  has_tls_got_offset(bool need_pair) const
  {
    return (this->has_tls_mod_got_offset_
            && (!need_pair || this->has_tls_pair_got_offset_));
  }

  // Return the offset into the GOT section for this symbol's TLS module
  // index or, if NEED_PAIR is true, for the pair of entries for the
  // module index and dtv-relative offset.
  unsigned int
  tls_got_offset(bool need_pair) const
  {
    gold_assert(this->has_tls_got_offset(need_pair));
    return this->tls_mod_got_offset_;
  }

  // Set the GOT offset of this symbol.
  void
  set_tls_got_offset(unsigned int got_offset, bool have_pair)
  {
    this->has_tls_mod_got_offset_ = true;
    this->has_tls_pair_got_offset_ = have_pair;
    this->tls_mod_got_offset_ = got_offset;
  }
d691 5
a695 12
  // is true), this is the offset from the start of the GOT section.
  // For a TLS symbol, if has_tls_tpoff_got_offset_ is true, this
  // serves as the GOT offset for the GOT entry that holds its
  // TP-relative offset.
  unsigned int got_offset_;

  // If this is a TLS symbol and has an entry in the GOT section
  // for a module index or a pair of entries (module index,
  // dtv-relative offset), these are the offsets from the start
  // of the GOT section.
  unsigned int tls_mod_got_offset_;
  unsigned int tls_pair_got_offset_;
a733 9
  // True if the symbol has an entry in the GOT section.
  // For a TLS symbol, this GOT entry will hold its tp-relative offset.
  bool has_got_offset_ : 1;
  // True if the symbol has an entry in the GOT section for its
  // module index.
  bool has_tls_mod_got_offset_ : 1;
  // True if the symbol has a pair of entries in the GOT section for its
  // module index and dtv-relative offset.
  bool has_tls_pair_got_offset_ : 1;
@


1.68
log
@Update copyright years.  Update language files.
@
text
@d124 1
a124 1
  // Set whether this version is the default for this symbol name.
d126 2
a127 2
  set_is_default(bool def)
  { this->is_def_ = def; }
@


1.67
log
@Remove gcc 3.2 compatibility hacks.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.66
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d1115 1
a1115 1
  get_sized_symbol(Symbol* ACCEPT_SIZE) const;
d1119 1
a1119 1
  get_sized_symbol(const Symbol* ACCEPT_SIZE) const;
d1227 1
a1227 1
          const char* version ACCEPT_SIZE_ENDIAN);
d1265 1
a1265 2
			bool only_if_ref, Sized_symbol<size>** poldsym
			ACCEPT_SIZE_ENDIAN);
d1337 1
a1337 2
		     const Stringpool*, unsigned char* p
                     ACCEPT_SIZE_ENDIAN) const;
d1459 1
a1459 1
Symbol_table::get_sized_symbol(Symbol* sym ACCEPT_SIZE) const
d1467 1
a1467 1
Symbol_table::get_sized_symbol(const Symbol* sym ACCEPT_SIZE) const
@


1.65
log
@From Craig Silverstein: rename option functions for future option
handling rewrite.
@
text
@d473 2
a474 2
            && parameters->output_is_shared()
	    && !parameters->Bsymbolic());
d518 1
a518 1
        && parameters->output_is_position_independent())
d526 1
a526 1
        && !((flags & NON_PIC_REF) && parameters->output_is_shared()))
d531 1
a531 1
    if (!parameters->output_is_position_independent()
d1463 1
a1463 1
  gold_assert(size == parameters->get_size());
d1471 1
a1471 1
  gold_assert(size == parameters->get_size());
@


1.64
log
@Assignments in linker scripts override definitions from object files.
@
text
@d474 1
a474 1
	    && !parameters->symbolic());
@


1.63
log
@Track sections for expressions.
@
text
@d1081 2
a1082 1
		     unsigned char nonvis, bool only_if_ref);
d1298 1
a1298 1
    bool only_if_ref);
@


1.62
log
@From Cary Coutant: fix handling of undefined symbols in shared
libraries.
@
text
@d571 10
a580 3
  // Return whether this symbol currently has an absolute value.
  bool
  value_is_absolute() const;
@


1.61
log
@Fully implement the SECTIONS clause.
@
text
@d465 4
d479 2
a480 1
  // to pre-emption, we need to make a PLT entry.
d484 5
a488 2
    return (this->type() == elfcpp::STT_FUNC
            && (this->is_from_dynobj() || this->is_preemptible()));
d511 4
d537 3
a539 1
    if (this->is_from_dynobj() || this->is_preemptible())
d562 3
a564 1
    if (this->is_from_dynobj() || this->is_preemptible())
@


1.60
log
@Don't pass around the target in order to define symbols; get it from
the parameters instead.
@
text
@d555 4
d1060 2
a1061 1
  // Define a set of symbols in output sections.
d1063 2
a1064 1
  define_symbols(const Layout*, int count, const Define_symbol_in_section*);
d1066 2
a1067 1
  // Define a set of symbols in output segments.
d1069 2
a1070 1
  define_symbols(const Layout*, int count, const Define_symbol_in_segment*);
@


1.59
log
@From Cary Coutant: Fix last patch.
@
text
@a54 1
class Target;
d1033 1
a1033 1
  define_in_output_data(const Target*, const char* name, const char* version,
d1042 2
a1043 3
  define_in_output_segment(const Target*, const char* name,
			   const char* version, Output_segment*,
			   uint64_t value, uint64_t symsize,
d1051 1
a1051 1
  define_as_constant(const Target*, const char* name, const char* version,
d1058 1
a1058 2
  define_symbols(const Layout*, const Target*, int count,
		 const Define_symbol_in_section*);
d1062 1
a1062 2
  define_symbols(const Layout*, const Target*, int count,
		 const Define_symbol_in_segment*);
d1069 1
a1069 2
  define_with_copy_reloc(const Target*, Sized_symbol<size>* sym,
			 Output_data* posd,
d1133 2
a1134 2
  set_dynsym_indexes(const Target*, unsigned int index,
		     std::vector<Symbol*>*, Stringpool*, Versions*);
d1232 3
a1234 3
  define_special_symbol(const Target* target, const char** pname,
			const char** pversion, bool only_if_ref,
			Sized_symbol<size>** poldsym ACCEPT_SIZE_ENDIAN);
d1239 1
a1239 2
  do_define_in_output_data(const Target*, const char* name,
			   const char* version, Output_data*,
d1250 1
a1250 1
    const Target*, const char* name, const char* version, Output_segment* os,
d1261 1
a1261 1
    const Target*, const char* name, const char* version,
@


1.58
log
@Originally from Craig Silverstein, with changes: support using a
version script to force symbols to be local.
@
text
@d511 2
a512 8
    // a dynamic relocation.
    if ((flags & FUNCTION_CALL) && this->has_plt_offset())
      return false;

    // A non-pic pc-relative function call in a shared library whose target
    // is defined in the same load module does not need a dynamic relocation.
    // Even if the target is preemptible, we will bind directly, since we
    // cannot use a PLT entry in this case.
d514 2
a515 3
        && (flags & NON_PIC_REF)
        && this->is_defined()
        && parameters->output_is_shared())
@


1.57
log
@From Cary Coutant: Fix mixing PIC and non-PIC relocs in the same
shared library.
@
text
@d469 1
d585 11
d772 3
d1150 8
a1157 6
  // values and adds the names to *POOL.  INDEX is the index of the
  // first global symbol.  OFF is the file offset of the global symbol
  // table, DYNOFF is the offset of the globals in the dynamic symbol
  // table, DYN_GLOBAL_INDEX is the index of the first global dynamic
  // symbol, and DYNCOUNT is the number of global dynamic symbols.
  // This records the parameters, and returns the new file offset.
d1159 2
a1160 2
  finalize(unsigned int index, off_t off, off_t dynoff,
	   size_t dyn_global_index, size_t dyncount, Stringpool* pool);
d1209 4
d1294 12
a1305 1
  sized_finalize(unsigned int, off_t, Stringpool*);
d1353 3
d1396 1
a1396 1
  size_t output_count_;
d1402 1
a1402 1
  off_t dynamic_count_;
d1419 4
@


1.56
log
@From Andrew Chatham and Craig Silverstein: Add support for version
scripts.
@
text
@d483 13
d501 1
a501 1
  needs_dynamic_reloc(bool is_absolute_ref, bool is_function_call) const
d504 3
a506 2
    // will need a dynamic relocaion.
    if (is_absolute_ref && parameters->output_is_position_independent())
d511 11
a521 1
    if (is_function_call && this->has_plt_offset())
@


1.55
log
@Reduce the number of system calls.  Use readv instead of pread.  Do
better handling of cached views.
@
text
@d49 1
d115 15
d972 1
a972 1
  Symbol_table(unsigned int count);
d1134 5
d1371 2
@


1.54
log
@Convert more instances of off_t to be 32-bit types.
@
text
@d900 2
a901 1
  // Add a warning for symbol NAME in section SHNDX in object OBJ.
d904 1
a904 1
	      unsigned int shndx);
d909 1
a909 1
  note_warnings(Symbol_table* symtab, const Task*);
d926 1
a926 3
    // The index of the warning section.
    unsigned int shndx;
    // The warning text if we have already loaded it.
d930 1
a930 1
      : object(NULL), shndx(0), text()
d934 1
a934 1
    set(Object* o, unsigned int s)
d937 1
a937 1
      this->shndx = s;
a938 4

    void
    set_text(const char* t, section_size_type l)
    { this->text.assign(t, l); }
d1055 2
a1056 1
  // Add a warning for symbol NAME in section SHNDX in object OBJ.
d1058 2
a1059 2
  add_warning(const char* name, Object* obj, unsigned int shndx)
  { this->warnings_.add_warning(this, name, obj, shndx); }
d1102 1
a1102 1
  finalize(const Task*, unsigned int index, off_t off, off_t dynoff,
@


1.53
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d1031 2
a1032 1
			 Output_data* posd, uint64_t value);
@


1.52
log
@Rewrite workqueue.  This version eliminates the master thread, and
reduces the amount of locking required to find a new thread to run.
@
text
@d942 1
a942 1
    set_text(const char* t, off_t l)
@


1.51
log
@From Craig Silverstein: size hash tables to avoid resizing.
@
text
@d908 1
a908 1
  note_warnings(Symbol_table* symtab);
d1081 1
a1081 1
  detect_odr_violations(const char* output_file_name) const;
d1105 1
a1105 1
  finalize(unsigned int index, off_t off, off_t dynoff,
@


1.50
log
@From Cary Coutant: Fix handling of RELATIVE RELA relocs.
@
text
@d958 4
a961 1
  Symbol_table();
@


1.49
log
@Print symbol table statistics with --stats.
@
text
@a543 13
  // Mark this symbol as needing its value written to the GOT even when
  // the value is subject to dynamic relocation (e.g., when the target
  // uses a RELATIVE relocation for the GOT entry).
  void
  set_needs_value_in_got()
  { this->needs_value_in_got_ = true; }

  // Return whether this symbol needs its value written to the GOT even
  // when the value is subject to dynamic relocation.
  bool
  needs_value_in_got() const
  { return this->needs_value_in_got_; }

a719 3
  // True if the static value should be written to the GOT even
  // when the final value is subject to dynamic relocation.
  bool needs_value_in_got_ : 1;
@


1.48
log
@Add threading support.
@
text
@d1130 4
@


1.47
log
@From Craig Silverstein: Add support for --demangle.
@
text
@d601 5
d805 5
@


1.46
log
@From Cary Coutant: Improve i386 shared library TLS support.
@
text
@d101 7
@


1.45
log
@From Craig Silverstein: Report output file name with ODR violation
warning message.
@
text
@d302 1
d323 29
d653 3
d658 7
d703 1
d705 6
@


1.44
log
@Add heuristics for undefined symbol warnings.
@
text
@d1030 1
a1030 1
  detect_odr_violations() const;
@


1.43
log
@From Craig Silverstein: First cut at detecting ODR violations.
@
text
@d49 1
d1059 1
a1059 1
  write_globals(const Target*, const Stringpool*, const Stringpool*,
d1181 2
a1182 2
  sized_write_globals(const Target*, const Stringpool*, const Stringpool*,
		      Output_file*) const;
d1192 4
@


1.42
log
@Correct handling of GOT references in a regular object.
@
text
@d898 1
a898 1
  // Symbol_table's namepool_ field) to 
d971 1
a971 1
		 const Define_symbol_in_segment*);  
d1026 5
d1078 2
a1079 1
		  bool def, const elfcpp::Sym<size, big_endian>& sym);
d1086 1
d1167 5
d1223 27
d1284 3
@


1.41
log
@From Cary Coutant: More shared library support, some refactorization.
@
text
@d408 4
@


1.40
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d411 1
d415 65
d502 13
d669 3
@


1.39
log
@Add support for PT_GNU_STACK.
@
text
@d836 1
a836 1
		  Symbol** sympointers);
@


1.38
log
@Fix versions of copied symbols.
@
text
@d950 1
a950 1
  set_dynsym_indexes(const General_options*, const Target*, unsigned int index,
@


1.37
log
@Add support for -Bsymbolic.
@
text
@d425 11
d587 3
d887 8
d940 5
d1119 1
d1121 3
a1123 1
  typedef std::vector<Symbol*> Commons_type;
a1127 1

a1129 1

a1132 1

a1134 1

a1136 1

a1138 1

a1140 1

a1142 1

a1145 1

a1147 1

a1150 1

a1156 1

d1159 6
@


1.36
log
@From Cary Coutant: preliminary shared library support.
@
text
@d410 2
a411 1
            && this->visibility_ != elfcpp::STV_PROTECTED);
@


1.35
log
@Keep track of weak aliases, so that overriding environ works.
@
text
@d223 5
d401 10
@


1.34
log
@Better multiple definition errors.
@
text
@d198 11
d542 3
d941 1
a941 1
  Symbol*
d948 1
a948 1
  static void
d954 1
a954 1
  static void
d963 7
d975 11
d1111 4
@


1.33
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d947 1
a947 1
  should_override(const Symbol*, unsigned int, bool*);
@


1.32
log
@Add an option for Stringpools to not copy strings.
@
text
@d731 2
a732 1
  // Issue a warning for a reference to SYM at LOCATION.
d734 2
a735 1
  issue_warning(const Symbol* sym, const std::string& location) const;
d881 1
d883 4
a886 2
  issue_warning(const Symbol* sym, const std::string& location) const
  { this->warnings_.issue_warning(sym, location); }
@


1.31
log
@Use parameters to track whether we are doing a static link.  Fix up
final_value_is_known for weak undefined symbols.  Pointed out by Cary
Coutant.
@
text
@d875 1
a875 1
  { return this->namepool_.add(name, NULL); }
@


1.30
log
@Put size and endianness in parameters.
@
text
@d344 1
a344 6
  final_value_is_known() const
  {
    if (parameters->output_is_shared())
      return false;
    return this->source_ != FROM_OBJECT || !this->object()->is_dynamic();
  }
@


1.29
log
@Use special value when we refer a function symbol in some way other
than calling it.
@
text
@a853 5
  // Return the bitsize (32 or 64) of the symbols in the table.
  int
  get_size() const
  { return this->size_; }

d915 1
a915 2
  write_section_symbol(const Target*, const Output_section*, Output_file*,
		       off_t) const;
a920 5
  // Set the size (32 or 64) of the symbols in the table.
  void
  set_size(int size)
  { this->size_ = size; }

a1046 3
  // The size of the symbols in the symbol table (32 or 64).
  int size_;

d1097 1
a1097 1
  gold_assert(size == this->get_size());
d1105 1
a1105 1
  gold_assert(size == this->get_size());
@


1.28
log
@Add licensing text to every source file.
@
text
@d326 15
d546 3
d1024 3
a1026 1
  sized_write_symbol(Sized_symbol<size>*, unsigned int shndx,
@


1.27
log
@Canonicalize name and version when working with special symbols.
@
text
@d3 20
@


1.26
log
@Add global parameters.
@
text
@d930 2
a931 2
  define_special_symbol(const Target* target, const char* name,
			const char* version, bool only_if_ref,
@


1.25
log
@Let special symbols override existing symbols rather than
reinitializing them.
@
text
@d11 1
d309 1
a309 1
  final_value_is_known(const General_options* options) const
d311 1
a311 1
    if (options->is_shared())
@


1.24
log
@Any symbol which is in both a regular object and a dynamic object
requires an entry in the dynamic symbol table.
@
text
@d407 4
d556 4
d916 10
d930 2
a931 2
			const char* version, bool only_if_ref
			ACCEPT_SIZE_ENDIAN);
@


1.23
log
@Copy in_reg and in_dyn when resolving NAME/VERSION with NAME/NULL.
@
text
@d181 4
a184 1
  { return this->needs_dynsym_entry_; }
@


1.22
log
@Add support for -E/--export-dynamic.  Also clean up --help output a bit.
@
text
@d198 5
@


1.21
log
@Don't emit symbols seen only in dynamic object, don't read duplicate
dynamic object.
@
text
@d340 8
@


1.20
log
@Generate version information.
@
text
@d188 10
d482 2
@


1.19
log
@gcc 3.2.2 portability hacks.
@
text
@d27 1
d307 1
a307 1
  // Return whether this symbol is defined in a dynamic object.
d309 1
a309 1
  is_defined_in_dynobj() const
d311 1
a311 3
    return (this->source_ == FROM_OBJECT
	    && this->object()->is_dynamic()
	    && this->is_defined());
d378 2
a379 1
  override_base(const elfcpp::Sym<size, big_endian>&, Object* object);
d521 2
a522 1
  override(const elfcpp::Sym<size, big_endian>&, Object* object);
a733 6
  // Define a special symbol.
  template<int size, bool big_endian>
  Sized_symbol<size>*
  define_special_symbol(Target* target, const char* name, bool only_if_ref
                        ACCEPT_SIZE_ENDIAN);

d736 3
a738 3
  void
  define_in_output_data(Target*, const char* name, Output_data*,
			uint64_t value, uint64_t symsize,
d745 3
a747 2
  void
  define_in_output_segment(Target*, const char* name, Output_segment*,
d755 5
a759 5
  void
  define_as_constant(Target*, const char* name, uint64_t value,
		     uint64_t symsize, elfcpp::STT type, elfcpp::STB binding,
		     elfcpp::STV visibility, unsigned char nonvis,
		     bool only_if_ref);
d763 1
a763 1
  define_symbols(const Layout*, Target*, int count,
d768 1
a768 1
  define_symbols(const Layout*, Target*, int count,
d823 2
a824 2
  set_dynsym_indexes(unsigned int index, std::vector<Symbol*>*,
		     Stringpool*);
d873 1
a873 1
	  Object*);
d877 9
a885 2
  resolve(Sized_symbol<size>* to, const Sized_symbol<size>* from
          ACCEPT_SIZE_ENDIAN);
d889 3
a891 2
  void
  do_define_in_output_data(Target*, const char* name, Output_data*,
d900 1
a900 1
  void
d902 1
a902 1
    Target*, const char* name, Output_segment* os,
d911 1
a911 1
  void
d913 1
a913 1
    Target*, const char* name,
@


1.18
log
@Can now dynamically link hello, world.
@
text
@d936 2
a937 1
		     const Stringpool*, unsigned char* p) const;
@


1.17
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d100 1
a100 1
  shnum() const
d103 1
a103 1
    return this->u_.from_object.shnum;
d238 6
d302 2
a303 2
	    || (this->shnum() != elfcpp::SHN_UNDEF
		&& this->shnum() != elfcpp::SHN_COMMON));
d319 1
a319 1
    return this->source_ == FROM_OBJECT && this->shnum() == elfcpp::SHN_UNDEF;
d327 1
a327 1
	    && (this->shnum() == elfcpp::SHN_COMMON
d400 1
a400 1
      unsigned int shnum;
d833 5
a837 2
  // first global symbol.  This records the file offset OFF, and
  // returns the new file offset.
d839 2
a840 1
  finalize(unsigned int index, off_t off, Stringpool* pool);
d844 2
a845 1
  write_globals(const Target*, const Stringpool*, Output_file*) const;
d929 8
a936 1
  sized_write_globals(const Target*, const Stringpool*, Output_file*) const;
d982 9
@


1.16
log
@Snapshot.  Includes first cut at output relocation sections.
@
text
@a8 1
#include <cassert>
d28 1
d93 1
a93 1
    assert(this->source_ == FROM_OBJECT);
d102 1
a102 1
    assert(this->source_ == FROM_OBJECT);
d112 1
a112 1
    assert(this->source_ == IN_OUTPUT_DATA);
d121 1
a121 1
    assert(this->source_ == IN_OUTPUT_DATA);
d131 1
a131 1
    assert(this->source_ == IN_OUTPUT_SEGMENT);
d140 1
a140 1
    assert(this->source_ == IN_OUTPUT_SEGMENT);
a186 5
  // Return whether this symbol was ever seen in a dynamic object.
  bool
  in_dyn() const
  { return this->in_dyn_; }

d200 1
a200 1
    assert(this->symtab_index_ != 0);
d208 1
a208 1
    assert(index != 0);
d212 6
d226 1
a226 1
    assert(this->dynsym_index_ != 0);
d234 1
a234 1
    assert(index != 0);
d247 1
a247 1
    assert(this->has_got_offset());
d259 1
a259 5
  // Return whether this symbol is resolved locally.  This is always
  // true when linking statically.  It is true for a symbol defined in
  // this object when using -Bsymbolic.  It is true for a symbol
  // marked local in a version file.  FIXME: This needs to be
  // completed.
d261 28
a288 2
  is_resolved_locally() const
  { return !this->in_dyn_; }
d296 11
a306 2
	    || (this->u_.from_object.shnum != elfcpp::SHN_UNDEF
		&& this->u_.from_object.shnum != elfcpp::SHN_COMMON));
d321 1
a321 1
	    && (this->u_.from_object.shnum == elfcpp::SHN_COMMON
d436 5
d470 2
d777 1
a777 1
  // Return the size of the symbols in the table.
d816 8
d836 5
d845 1
a845 1
  // Set the size of the symbols in the table.
d920 5
d992 1
a992 1
  assert(size == this->get_size());
d1000 1
a1000 1
  assert(size == this->get_size());
@


1.15
log
@More dynamic object support, initial scripting support.
@
text
@d176 11
d197 40
d388 12
d401 1
a401 1
  // is true), this is the offset.
d403 1
d427 2
d617 1
a617 1
  issue_warning(Symbol* sym, const std::string& location) const;
d736 1
a736 1
  resolve_forwards(Symbol* from) const;
d774 1
a774 1
  issue_warning(Symbol* sym, const std::string& location) const
d778 3
a780 2
  // of all the input sections.  This sets the final symbol values and
  // adds the names to *POOL.  It records the file offset OFF, and
d783 1
a783 1
  finalize(off_t, Stringpool*);
d861 1
a861 1
  sized_finalize(off_t, Stringpool*);
d898 3
d916 1
a916 1
  Unordered_map<Symbol*, Symbol*> forwarders_;
@


1.14
log
@Rework stringpool and hash tables so that we always generate the same
output regardless of randomize_va_space.
@
text
@d23 2
d26 2
d599 1
a599 1
  // Add COUNT external symbols from the relocatable object OBJECT to
d605 3
a607 2
  add_from_object(Relobj* object, const unsigned char* syms,
		  size_t count, const char* sym_names, size_t sym_name_size,
d609 12
@


1.13
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@d686 1
a686 1
  { return this->namepool_.add(name); }
d721 3
a723 3
  add_from_object(Object*, const char *name,
		  const char *version, bool def,
		  const elfcpp::Sym<size, big_endian>& sym);
d786 1
a786 1
  typedef std::pair<const char*, const char*> Symbol_table_key;
@


1.12
log
@gcc 3.2.2 portability hacks.
@
text
@d13 1
d22 2
a28 3
template<int size, bool big_endian>
class Sized_object;

d43 2
a44 1
    // Symbol defined in an input file--this is the most common case.
d93 2
a94 1
  // Return the index of the section in the input object file.
d172 1
a172 1
  // Return whether this symbol was seen in a dynamic object.
d177 1
a177 1
  // Mark this symbol as seen in a dynamic object.
d212 10
d233 3
a235 1
    return this->source_ == FROM_OBJECT && this->shnum() == elfcpp::SHN_COMMON;
d238 11
d253 1
a253 1
  { }
d345 1
a345 1
  Source source_ : 2;
d363 2
d514 72
d595 4
a598 4
  // Add COUNT external symbols from OBJECT to the symbol table.  SYMS
  // is the symbols, SYM_NAMES is their names, SYM_NAME_SIZE is the
  // size of SYM_NAMES.  This sets SYMPOINTERS to point to the symbols
  // in the symbol table.
d601 1
a601 2
  add_from_object(Sized_object<size, big_endian>* object,
		  const elfcpp::Sym<size, big_endian>* syms,
d678 16
d721 1
a721 1
  add_from_object(Sized_object<size, big_endian>*, const char *name,
d837 3
@


1.11
log
@Can now do a full static link of hello, world in C or C++
@
text
@d510 2
a511 1
  define_special_symbol(Target* target, const char* name, bool only_if_ref);
@


1.10
log
@Framework for relocation scanning.  Implement simple static TLS
relocations.
@
text
@d8 1
d21 2
d37 31
d79 5
d87 50
a136 1
  { return this->object_; }
d155 2
a156 7
  other() const
  { return this->other_; }

  // Return the section index.
  unsigned int
  shnum() const
  { return this->shnum_; }
d180 31
a210 2
  // Return whether this symbol needs an entry in the dynamic symbol
  // table.  FIXME: Needs to be fleshed out.
d212 11
a222 2
  in_dynsym() const
  { return this->in_dyn_; }
d230 6
d242 16
d272 39
a310 4
  // Object in which symbol is defined, or in which it was first seen.
  Object* object_;
  // Section number in object_ in which symbol is defined.
  unsigned int shnum_;
d318 3
a320 1
  unsigned int other_ : 6;
d323 1
a323 1
  bool is_special_ : 1;
d336 2
d359 17
d390 6
a395 1
  { return this->size_; }
d407 3
a409 1
  // Symbol value.
d412 73
a484 1
  Size_type size_;
d507 41
d570 9
d622 37
d688 4
d695 4
d715 7
@


1.9
log
@Clean up HAVE_MEMBER_TEMPLATE_SPECIFICATIONS somewhat.
@
text
@d97 6
@


1.8
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d239 1
a239 1
  get_sized_symbol(Symbol*) const;
d243 1
a243 1
  get_sized_symbol(const Symbol*) const;
a282 1
#ifdef HAVE_MEMBER_TEMPLATE_SPECIFICATIONS
d285 2
a286 7
  resolve(Sized_symbol<size>* to, const Sized_symbol<size>* from);
#else
  template<int size>
  static void
  resolve(Sized_symbol<size>* to, const Sized_symbol<size>* from,
          bool big_endian);
#endif
d342 1
a342 1
Symbol_table::get_sized_symbol(Symbol* sym) const
d350 1
a350 1
Symbol_table::get_sized_symbol(const Symbol* sym) const
@


1.7
log
@Finished layout code.
@
text
@d20 2
d223 4
d252 4
d299 5
d329 3
@


1.6
log
@g++ 3.2.2 portability fixes.
@
text
@d185 6
d239 6
a244 7
  // Record the names of the local symbols for an object.
  template<int size, bool big_endian>
  void
  add_local_symbol_names(Sized_object<size, big_endian>* object,
			 const elfcpp::Sym<size, big_endian>* syms,
			 size_t count, const char* sym_names,
			 size_t sym_name_size);
d284 5
d311 4
a320 5

  // A pool of symbol names to go into the output file.  This is used
  // for all symbols, global and local, but only the names of symbols
  // which will definitely be output are added to this pool.
  Stringpool output_pool_;
@


1.5
log
@More section layout code.
@
text
@d268 1
d272 6
@


1.4
log
@New drop, with first cut of section layout code.
@
text
@d8 1
a23 3
template<int size, bool big_endian>
class Sized_target;

d227 1
a227 1
  get_sized_symbol(Symbol*);
d231 9
a239 1
  get_sized_symbol(const Symbol*);
d272 2
d294 1
a294 1
  // The symbol table itself.
d297 2
a298 1
  // A pool of symbol names.
d301 5
d314 1
a314 1
Symbol_table::get_sized_symbol(Symbol* sym)
d322 1
a322 1
Symbol_table::get_sized_symbol(const Symbol* sym)
@


1.3
log
@More symbol resolution code.
@
text
@a9 1
#include "targetsize.h"
@


1.2
log
@Another snapshot of the current state of the sources.  Gets to the
point of symbol resolution and can now issue a multiple definition
error.  Also added target selection infrastructure.
@
text
@a34 2
  virtual ~Symbol();

a45 12
  // Return whether this symbol is a forwarder.  This will never be
  // true of a symbol found in the hash table, but may be true of
  // symbol pointers attached to object files.
  bool
  is_forwarder() const
  { return this->forwarder_; }

  // Mark this symbol as a forwarder.
  void
  set_forwarder()
  { this->forwarder_ = true; }

d56 15
d76 22
d110 5
d138 1
a138 1
  bool special_ : 1;
d140 1
a140 1
  bool def_ : 1;
d148 3
a150 1
  bool forwarder_ : 1;
d160 3
d172 16
d193 1
a193 1
  typename elfcpp::Elf_types<size>::Elf_Addr value_;
d195 1
a195 1
  typename elfcpp::Elf_types<size>::Elf_WXword size_;
d205 1
a205 1
  virtual ~Symbol_table();
d227 9
d259 3
a261 1
  resolve(Symbol* to, const elfcpp::Sym<size, big_endian>& sym, Object*);
d263 1
d265 1
a265 1
  resolve(Symbol* to, const Symbol* from);
d296 18
@


1.1
log
@Initial CVS checkin of gold
@
text
@a5 2
#include "gold.h"

d11 1
a11 2
#include "object.h"
#include "workqueue.h"
d19 12
a30 2
// An entry in the symbol table.  The symbol table can have a lot of
// entries, so we don't want this class to get too big.
a31 1
template<int size>
d35 51
a85 2
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Value;
  typedef typename Size_types<size>::Unsigned_type Size;
d88 7
a94 4
  // Every symbol has a unique name, more or less, so we use
  // std::string for the name.  There are only a few versions in a
  // given link, so for them we point into a pool.
  std::string name_;
d96 1
d98 1
d100 1
a100 2
  Value value_;
  Size size_;
d102 1
d104 3
a106 1
  elfcpp:STV visibility_ : 2;
d108 39
a150 1
template<int size>
d156 12
a167 3
  // Return a pointer to a symbol specified by name.
  Symbol*
  lookup(const std::string& name) const;
d169 1
a169 1
  // Return a pointer to a symbol specified by name plus version.
d171 1
a171 1
  lookup(const std::string& name, const char* version) const;
d173 4
a176 3
  Task_token&
  token() const
  { return this->token_; }
d182 49
a230 1
  typedef std::pair<std::string, std::string> Symbol_table_key;
d232 2
a233 2
  Unordered_map<Symbol_table_key, Symbol<size>*> table_;
  Task_token token_;
@

