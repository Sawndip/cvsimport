head	1.165;
access;
symbols
	binutils-2_24-branch:1.165.0.2
	binutils-2_24-branchpoint:1.165
	binutils-2_21_1:1.132.2.1
	binutils-2_23_2:1.155
	binutils-2_23_1:1.155
	binutils-2_23:1.155
	binutils-2_23-branch:1.155.0.2
	binutils-2_23-branchpoint:1.155
	binutils-2_22_branch:1.150.0.4
	binutils-2_22:1.150
	binutils-2_22-branch:1.150.0.2
	binutils-2_22-branchpoint:1.150
	binutils-2_21:1.132
	binutils-2_21-branch:1.132.0.2
	binutils-2_21-branchpoint:1.132
	binutils-2_20_1:1.98.2.2
	binutils-2_20:1.98.2.1
	binutils-arc-20081103-branch:1.78.0.4
	binutils-arc-20081103-branchpoint:1.78
	binutils-2_20-branch:1.98.0.2
	binutils-2_20-branchpoint:1.98
	dje-cgen-play1-branch:1.95.0.2
	dje-cgen-play1-branchpoint:1.95
	arc-20081103-branch:1.78.0.2
	arc-20081103-branchpoint:1.78
	binutils-2_19_1:1.77
	binutils-2_19:1.77
	binutils-2_19-branch:1.77.0.2
	binutils-2_19-branchpoint:1.77
	binutils_latest_snapshot:1.165
	added-to-binutils:1.63;
locks; strict;
comment	@// @;


1.165
date	2013.07.31.18.47.50;	author ccoutant;	state Exp;
branches;
next	1.164;

1.164
date	2013.05.21.20.56.13;	author ccoutant;	state Exp;
branches;
next	1.163;

1.163
date	2013.04.04.16.49.04;	author ian;	state Exp;
branches;
next	1.162;

1.162
date	2013.03.10.23.08.18;	author amodra;	state Exp;
branches;
next	1.161;

1.161
date	2012.10.18.05.36.02;	author amodra;	state Exp;
branches;
next	1.160;

1.160
date	2012.09.25.00.59.25;	author amodra;	state Exp;
branches;
next	1.159;

1.159
date	2012.09.07.20.14.06;	author ccoutant;	state Exp;
branches;
next	1.158;

1.158
date	2012.08.24.18.35.34;	author tmsriram;	state Exp;
branches;
next	1.157;

1.157
date	2012.08.14.08.31.56;	author nickc;	state Exp;
branches;
next	1.156;

1.156
date	2012.08.11.04.41.28;	author amodra;	state Exp;
branches;
next	1.155;

1.155
date	2012.05.02.21.37.23;	author roland;	state Exp;
branches;
next	1.154;

1.154
date	2012.03.21.19.02.21;	author ccoutant;	state Exp;
branches;
next	1.153;

1.153
date	2012.03.01.07.27.38;	author ccoutant;	state Exp;
branches;
next	1.152;

1.152
date	2012.02.29.21.22.29;	author ccoutant;	state Exp;
branches;
next	1.151;

1.151
date	2011.12.19.21.07.16;	author ian;	state Exp;
branches;
next	1.150;

1.150
date	2011.09.18.15.06.28;	author ccoutant;	state Exp;
branches;
next	1.149;

1.149
date	2011.09.13.16.16.51;	author ian;	state Exp;
branches;
next	1.148;

1.148
date	2011.09.12.17.34.26;	author ian;	state Exp;
branches;
next	1.147;

1.147
date	2011.08.01.18.25.21;	author ccoutant;	state Exp;
branches;
next	1.146;

1.146
date	2011.07.05.20.38.53;	author ian;	state Exp;
branches;
next	1.145;

1.145
date	2011.06.30.00.50.13;	author ian;	state Exp;
branches;
next	1.144;

1.144
date	2011.06.29.21.39.19;	author ian;	state Exp;
branches;
next	1.143;

1.143
date	2011.06.17.11.20.42;	author ian;	state Exp;
branches;
next	1.142;

1.142
date	2011.06.09.18.18.44;	author ccoutant;	state Exp;
branches;
next	1.141;

1.141
date	2011.05.26.18.44.27;	author ccoutant;	state Exp;
branches;
next	1.140;

1.140
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.139;

1.139
date	2011.05.11.00.29.57;	author ccoutant;	state Exp;
branches;
next	1.138;

1.138
date	2011.04.18.05.39.43;	author ian;	state Exp;
branches;
next	1.137;

1.137
date	2011.04.12.00.44.48;	author ccoutant;	state Exp;
branches;
next	1.136;

1.136
date	2011.03.30.01.31.57;	author ccoutant;	state Exp;
branches;
next	1.135;

1.135
date	2011.03.10.01.31.32;	author ian;	state Exp;
branches;
next	1.134;

1.134
date	2010.12.14.19.03.30;	author rwild;	state Exp;
branches;
next	1.133;

1.133
date	2010.12.09.23.19.50;	author ccoutant;	state Exp;
branches;
next	1.132;

1.132
date	2010.09.09.19.57.06;	author hjl;	state Exp;
branches
	1.132.2.1;
next	1.131;

1.131
date	2010.09.08.23.54.51;	author dougkwan;	state Exp;
branches;
next	1.130;

1.130
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.129;

1.129
date	2010.08.19.22.50.15;	author ian;	state Exp;
branches;
next	1.128;

1.128
date	2010.08.12.22.01.11;	author ccoutant;	state Exp;
branches;
next	1.127;

1.127
date	2010.08.02.13.34.33;	author ian;	state Exp;
branches;
next	1.126;

1.126
date	2010.07.12.17.59.58;	author ccoutant;	state Exp;
branches;
next	1.125;

1.125
date	2010.06.10.17.20.26;	author ccoutant;	state Exp;
branches;
next	1.124;

1.124
date	2010.05.26.18.53.46;	author dougkwan;	state Exp;
branches;
next	1.123;

1.123
date	2010.05.26.15.47.39;	author espindola;	state Exp;
branches;
next	1.122;

1.122
date	2010.04.07.22.58.23;	author ccoutant;	state Exp;
branches;
next	1.121;

1.121
date	2010.03.22.14.18.24;	author espindola;	state Exp;
branches;
next	1.120;

1.120
date	2010.03.03.19.31.54;	author ian;	state Exp;
branches;
next	1.119;

1.119
date	2010.02.11.07.40.11;	author ian;	state Exp;
branches;
next	1.118;

1.118
date	2010.01.15.01.44.22;	author tmsriram;	state Exp;
branches;
next	1.117;

1.117
date	2010.01.08.22.34.34;	author ian;	state Exp;
branches;
next	1.116;

1.116
date	2010.01.07.18.42.03;	author ian;	state Exp;
branches;
next	1.115;

1.115
date	2010.01.07.07.14.29;	author tmsriram;	state Exp;
branches;
next	1.114;

1.114
date	2010.01.05.21.52.51;	author ian;	state Exp;
branches;
next	1.113;

1.113
date	2010.01.05.00.32.22;	author ian;	state Exp;
branches;
next	1.112;

1.112
date	2009.12.30.20.23.29;	author ian;	state Exp;
branches;
next	1.111;

1.111
date	2009.12.29.00.24.31;	author ian;	state Exp;
branches;
next	1.110;

1.110
date	2009.12.17.00.00.26;	author dougkwan;	state Exp;
branches;
next	1.109;

1.109
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.108;

1.108
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.107;

1.107
date	2009.12.06.02.49.46;	author dougkwan;	state Exp;
branches;
next	1.106;

1.106
date	2009.11.09.23.07.30;	author dougkwan;	state Exp;
branches;
next	1.105;

1.105
date	2009.10.21.00.45.52;	author dougkwan;	state Exp;
branches;
next	1.104;

1.104
date	2009.10.13.21.17.43;	author tmsriram;	state Exp;
branches;
next	1.103;

1.103
date	2009.10.09.23.18.19;	author dougkwan;	state Exp;
branches;
next	1.102;

1.102
date	2009.10.09.16.40.51;	author ian;	state Exp;
branches;
next	1.101;

1.101
date	2009.10.06.22.58.27;	author ian;	state Exp;
branches;
next	1.100;

1.100
date	2009.09.30.22.21.13;	author ian;	state Exp;
branches;
next	1.99;

1.99
date	2009.09.18.20.02.21;	author csilvers;	state Exp;
branches;
next	1.98;

1.98
date	2009.08.18.23.49.29;	author dougkwan;	state Exp;
branches
	1.98.2.1;
next	1.97;

1.97
date	2009.08.05.20.51.56;	author tmsriram;	state Exp;
branches;
next	1.96;

1.96
date	2009.07.17.01.07.33;	author ian;	state Exp;
branches;
next	1.95;

1.95
date	2009.06.23.07.19.35;	author ian;	state Exp;
branches;
next	1.94;

1.94
date	2009.06.22.06.51.53;	author ian;	state Exp;
branches;
next	1.93;

1.93
date	2009.06.05.21.32.56;	author dougkwan;	state Exp;
branches;
next	1.92;

1.92
date	2009.06.05.18.16.31;	author dougkwan;	state Exp;
branches;
next	1.91;

1.91
date	2009.05.22.18.31.22;	author tmsriram;	state Exp;
branches;
next	1.90;

1.90
date	2009.03.24.18.42.10;	author ian;	state Exp;
branches;
next	1.89;

1.89
date	2009.03.14.05.56.46;	author ian;	state Exp;
branches;
next	1.88;

1.88
date	2009.03.01.22.22.02;	author ian;	state Exp;
branches;
next	1.87;

1.87
date	2009.02.28.17.53.16;	author ian;	state Exp;
branches;
next	1.86;

1.86
date	2009.02.28.04.39.57;	author ian;	state Exp;
branches;
next	1.85;

1.85
date	2009.02.28.00.12.26;	author ian;	state Exp;
branches;
next	1.84;

1.84
date	2009.02.13.19.04.44;	author ccoutant;	state Exp;
branches;
next	1.83;

1.83
date	2009.02.07.01.05.15;	author ian;	state Exp;
branches;
next	1.82;

1.82
date	2009.01.28.20.09.18;	author ian;	state Exp;
branches;
next	1.81;

1.81
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	1.80;

1.80
date	2009.01.15.18.10.54;	author ian;	state Exp;
branches;
next	1.79;

1.79
date	2008.12.23.02.02.20;	author ccoutant;	state Exp;
branches;
next	1.78;

1.78
date	2008.09.29.21.10.26;	author ccoutant;	state Exp;
branches;
next	1.77;

1.77
date	2008.07.22.22.08.43;	author ian;	state Exp;
branches;
next	1.76;

1.76
date	2008.07.10.23.01.19;	author ian;	state Exp;
branches;
next	1.75;

1.75
date	2008.06.25.17.10.08;	author ccoutant;	state Exp;
branches;
next	1.74;

1.74
date	2008.05.05.19.16.43;	author ian;	state Exp;
branches;
next	1.73;

1.73
date	2008.05.01.01.23.21;	author ccoutant;	state Exp;
branches;
next	1.72;

1.72
date	2008.04.23.17.40.19;	author ian;	state Exp;
branches;
next	1.71;

1.71
date	2008.04.23.17.32.53;	author ian;	state Exp;
branches;
next	1.70;

1.70
date	2008.04.19.19.34.41;	author ian;	state Exp;
branches;
next	1.69;

1.69
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.68;

1.68
date	2008.04.17.22.45.47;	author ccoutant;	state Exp;
branches;
next	1.67;

1.67
date	2008.04.09.00.26.48;	author ian;	state Exp;
branches;
next	1.66;

1.66
date	2008.04.02.20.58.21;	author ian;	state Exp;
branches;
next	1.65;

1.65
date	2008.03.26.23.36.46;	author ian;	state Exp;
branches;
next	1.64;

1.64
date	2008.03.24.03.48.29;	author ian;	state Exp;
branches;
next	1.63;

1.63
date	2008.03.16.23.51.19;	author iant;	state Exp;
branches;
next	1.62;

1.62
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.61;

1.61
date	2008.03.12.04.38.42;	author iant;	state Exp;
branches;
next	1.60;

1.60
date	2008.02.28.20.35.39;	author iant;	state Exp;
branches;
next	1.59;

1.59
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.58;

1.58
date	2008.02.27.22.38.18;	author iant;	state Exp;
branches;
next	1.57;

1.57
date	2008.02.12.00.28.48;	author iant;	state Exp;
branches;
next	1.56;

1.56
date	2008.02.07.01.51.25;	author iant;	state Exp;
branches;
next	1.55;

1.55
date	2008.02.06.20.32.10;	author iant;	state Exp;
branches;
next	1.54;

1.54
date	2008.02.06.08.13.50;	author iant;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.02.23.48.49;	author iant;	state Exp;
branches;
next	1.52;

1.52
date	2007.12.21.23.08.25;	author iant;	state Exp;
branches;
next	1.51;

1.51
date	2007.12.21.21.19.45;	author iant;	state Exp;
branches;
next	1.50;

1.50
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.49;

1.49
date	2007.12.14.19.00.21;	author iant;	state Exp;
branches;
next	1.48;

1.48
date	2007.12.06.06.03.00;	author iant;	state Exp;
branches;
next	1.47;

1.47
date	2007.12.06.05.55.50;	author iant;	state Exp;
branches;
next	1.46;

1.46
date	2007.12.01.06.34.12;	author iant;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.15.01.12.55;	author iant;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.14.16.53.24;	author iant;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.14.07.34.53;	author iant;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.14.01.03.01;	author iant;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.12.19.56.20;	author iant;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.09.23.56.32;	author iant;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.09.23.16.54;	author iant;	state Exp;
branches;
next	1.38;

1.38
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.07.00.49.56;	author iant;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.07.00.31.32;	author iant;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.02.23.02.44;	author iant;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.02.03.28.52;	author iant;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.23.05.05.48;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.14.07.27.10;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.14.06.49.14;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.14.04.06.18;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.12.06.06.34;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.10.19.02.56;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.08.07.22.21;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.06.05.40.44;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.02.20.52.18;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.26.07.01.34;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.25.17.50.26;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.21.07.20.01;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.20.06.02.06;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.04.20.00.53;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.16.17.42.48;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.06.06.28.56;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.16.00.38.25;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.07.18.51.39;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.07.04.40.46;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.03.18.26.10;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.10.20.20.40.49;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.10.10.18.54.06;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.06.20.40.16;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.29.19.58.16;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.27.22.53.42;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.26.21.00.34;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.21.22.13.18;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.18.22.29.20;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.04.23.10.59;	author iant;	state Exp;
branches;
next	;

1.132.2.1
date	2011.06.17.11.23.15;	author ian;	state Exp;
branches;
next	;

1.98.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	1.98.2.2;

1.98.2.2
date	2010.01.13.16.19.03;	author ian;	state Exp;
branches;
next	;


desc
@@


1.165
log
@gold/
	* object.cc (Sized_relobj::do_output_section_address): New function.
	(Sized_relobj): Instantiate explicitly.
	* object.h (Object::output_section_address): New function.
	(Object::do_output_section_address): New function.
	(Sized_relobj::do_output_section_address): New function.
	* powerpc.cc (Target_powerpc::symval_for_branch): Use it.
@
text
@// object.cc -- support for an object file for linking in gold

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cerrno>
#include <cstring>
#include <cstdarg>
#include "demangle.h"
#include "libiberty.h"

#include "gc.h"
#include "target-select.h"
#include "dwarf_reader.h"
#include "layout.h"
#include "output.h"
#include "symtab.h"
#include "cref.h"
#include "reloc.h"
#include "object.h"
#include "dynobj.h"
#include "plugin.h"
#include "compressed_output.h"
#include "incremental.h"

namespace gold
{

// Struct Read_symbols_data.

// Destroy any remaining File_view objects and buffers of decompressed
// sections.

Read_symbols_data::~Read_symbols_data()
{
  if (this->section_headers != NULL)
    delete this->section_headers;
  if (this->section_names != NULL)
    delete this->section_names;
  if (this->symbols != NULL)
    delete this->symbols;
  if (this->symbol_names != NULL)
    delete this->symbol_names;
  if (this->versym != NULL)
    delete this->versym;
  if (this->verdef != NULL)
    delete this->verdef;
  if (this->verneed != NULL)
    delete this->verneed;
}

// Class Xindex.

// Initialize the symtab_xindex_ array.  Find the SHT_SYMTAB_SHNDX
// section and read it in.  SYMTAB_SHNDX is the index of the symbol
// table we care about.

template<int size, bool big_endian>
void
Xindex::initialize_symtab_xindex(Object* object, unsigned int symtab_shndx)
{
  if (!this->symtab_xindex_.empty())
    return;

  gold_assert(symtab_shndx != 0);

  // Look through the sections in reverse order, on the theory that it
  // is more likely to be near the end than the beginning.
  unsigned int i = object->shnum();
  while (i > 0)
    {
      --i;
      if (object->section_type(i) == elfcpp::SHT_SYMTAB_SHNDX
	  && this->adjust_shndx(object->section_link(i)) == symtab_shndx)
	{
	  this->read_symtab_xindex<size, big_endian>(object, i, NULL);
	  return;
	}
    }

  object->error(_("missing SHT_SYMTAB_SHNDX section"));
}

// Read in the symtab_xindex_ array, given the section index of the
// SHT_SYMTAB_SHNDX section.  If PSHDRS is not NULL, it points at the
// section headers.

template<int size, bool big_endian>
void
Xindex::read_symtab_xindex(Object* object, unsigned int xindex_shndx,
			   const unsigned char* pshdrs)
{
  section_size_type bytecount;
  const unsigned char* contents;
  if (pshdrs == NULL)
    contents = object->section_contents(xindex_shndx, &bytecount, false);
  else
    {
      const unsigned char* p = (pshdrs
				+ (xindex_shndx
				   * elfcpp::Elf_sizes<size>::shdr_size));
      typename elfcpp::Shdr<size, big_endian> shdr(p);
      bytecount = convert_to_section_size_type(shdr.get_sh_size());
      contents = object->get_view(shdr.get_sh_offset(), bytecount, true, false);
    }

  gold_assert(this->symtab_xindex_.empty());
  this->symtab_xindex_.reserve(bytecount / 4);
  for (section_size_type i = 0; i < bytecount; i += 4)
    {
      unsigned int shndx = elfcpp::Swap<32, big_endian>::readval(contents + i);
      // We preadjust the section indexes we save.
      this->symtab_xindex_.push_back(this->adjust_shndx(shndx));
    }
}

// Symbol symndx has a section of SHN_XINDEX; return the real section
// index.

unsigned int
Xindex::sym_xindex_to_shndx(Object* object, unsigned int symndx)
{
  if (symndx >= this->symtab_xindex_.size())
    {
      object->error(_("symbol %u out of range for SHT_SYMTAB_SHNDX section"),
		    symndx);
      return elfcpp::SHN_UNDEF;
    }
  unsigned int shndx = this->symtab_xindex_[symndx];
  if (shndx < elfcpp::SHN_LORESERVE || shndx >= object->shnum())
    {
      object->error(_("extended index for symbol %u out of range: %u"),
		    symndx, shndx);
      return elfcpp::SHN_UNDEF;
    }
  return shndx;
}

// Class Object.

// Report an error for this object file.  This is used by the
// elfcpp::Elf_file interface, and also called by the Object code
// itself.

void
Object::error(const char* format, ...) const
{
  va_list args;
  va_start(args, format);
  char* buf = NULL;
  if (vasprintf(&buf, format, args) < 0)
    gold_nomem();
  va_end(args);
  gold_error(_("%s: %s"), this->name().c_str(), buf);
  free(buf);
}

// Return a view of the contents of a section.

const unsigned char*
Object::section_contents(unsigned int shndx, section_size_type* plen,
			 bool cache)
{ return this->do_section_contents(shndx, plen, cache); }

// Read the section data into SD.  This is code common to Sized_relobj_file
// and Sized_dynobj, so we put it into Object.

template<int size, bool big_endian>
void
Object::read_section_data(elfcpp::Elf_file<size, big_endian, Object>* elf_file,
			  Read_symbols_data* sd)
{
  const int shdr_size = elfcpp::Elf_sizes<size>::shdr_size;

  // Read the section headers.
  const off_t shoff = elf_file->shoff();
  const unsigned int shnum = this->shnum();
  sd->section_headers = this->get_lasting_view(shoff, shnum * shdr_size,
					       true, true);

  // Read the section names.
  const unsigned char* pshdrs = sd->section_headers->data();
  const unsigned char* pshdrnames = pshdrs + elf_file->shstrndx() * shdr_size;
  typename elfcpp::Shdr<size, big_endian> shdrnames(pshdrnames);

  if (shdrnames.get_sh_type() != elfcpp::SHT_STRTAB)
    this->error(_("section name section has wrong type: %u"),
		static_cast<unsigned int>(shdrnames.get_sh_type()));

  sd->section_names_size =
    convert_to_section_size_type(shdrnames.get_sh_size());
  sd->section_names = this->get_lasting_view(shdrnames.get_sh_offset(),
					     sd->section_names_size, false,
					     false);
}

// If NAME is the name of a special .gnu.warning section, arrange for
// the warning to be issued.  SHNDX is the section index.  Return
// whether it is a warning section.

bool
Object::handle_gnu_warning_section(const char* name, unsigned int shndx,
				   Symbol_table* symtab)
{
  const char warn_prefix[] = ".gnu.warning.";
  const int warn_prefix_len = sizeof warn_prefix - 1;
  if (strncmp(name, warn_prefix, warn_prefix_len) == 0)
    {
      // Read the section contents to get the warning text.  It would
      // be nicer if we only did this if we have to actually issue a
      // warning.  Unfortunately, warnings are issued as we relocate
      // sections.  That means that we can not lock the object then,
      // as we might try to issue the same warning multiple times
      // simultaneously.
      section_size_type len;
      const unsigned char* contents = this->section_contents(shndx, &len,
							     false);
      if (len == 0)
	{
	  const char* warning = name + warn_prefix_len;
	  contents = reinterpret_cast<const unsigned char*>(warning);
	  len = strlen(warning);
	}
      std::string warning(reinterpret_cast<const char*>(contents), len);
      symtab->add_warning(name + warn_prefix_len, this, warning);
      return true;
    }
  return false;
}

// If NAME is the name of the special section which indicates that
// this object was compiled with -fsplit-stack, mark it accordingly.

bool
Object::handle_split_stack_section(const char* name)
{
  if (strcmp(name, ".note.GNU-split-stack") == 0)
    {
      this->uses_split_stack_ = true;
      return true;
    }
  if (strcmp(name, ".note.GNU-no-split-stack") == 0)
    {
      this->has_no_split_stack_ = true;
      return true;
    }
  return false;
}

// Class Relobj

// To copy the symbols data read from the file to a local data structure.
// This function is called from do_layout only while doing garbage
// collection.

void
Relobj::copy_symbols_data(Symbols_data* gc_sd, Read_symbols_data* sd,
			  unsigned int section_header_size)
{
  gc_sd->section_headers_data =
	 new unsigned char[(section_header_size)];
  memcpy(gc_sd->section_headers_data, sd->section_headers->data(),
	 section_header_size);
  gc_sd->section_names_data =
	 new unsigned char[sd->section_names_size];
  memcpy(gc_sd->section_names_data, sd->section_names->data(),
	 sd->section_names_size);
  gc_sd->section_names_size = sd->section_names_size;
  if (sd->symbols != NULL)
    {
      gc_sd->symbols_data =
	     new unsigned char[sd->symbols_size];
      memcpy(gc_sd->symbols_data, sd->symbols->data(),
	    sd->symbols_size);
    }
  else
    {
      gc_sd->symbols_data = NULL;
    }
  gc_sd->symbols_size = sd->symbols_size;
  gc_sd->external_symbols_offset = sd->external_symbols_offset;
  if (sd->symbol_names != NULL)
    {
      gc_sd->symbol_names_data =
	     new unsigned char[sd->symbol_names_size];
      memcpy(gc_sd->symbol_names_data, sd->symbol_names->data(),
	    sd->symbol_names_size);
    }
  else
    {
      gc_sd->symbol_names_data = NULL;
    }
  gc_sd->symbol_names_size = sd->symbol_names_size;
}

// This function determines if a particular section name must be included
// in the link.  This is used during garbage collection to determine the
// roots of the worklist.

bool
Relobj::is_section_name_included(const char* name)
{
  if (is_prefix_of(".ctors", name)
      || is_prefix_of(".dtors", name)
      || is_prefix_of(".note", name)
      || is_prefix_of(".init", name)
      || is_prefix_of(".fini", name)
      || is_prefix_of(".gcc_except_table", name)
      || is_prefix_of(".jcr", name)
      || is_prefix_of(".preinit_array", name)
      || (is_prefix_of(".text", name)
	  && strstr(name, "personality"))
      || (is_prefix_of(".data", name)
	  && strstr(name, "personality"))
      || (is_prefix_of(".sdata", name)
	  && strstr(name, "personality"))
      || (is_prefix_of(".gnu.linkonce.d", name)
	  && strstr(name, "personality")))
    {
      return true;
    }
  return false;
}

// Finalize the incremental relocation information.  Allocates a block
// of relocation entries for each symbol, and sets the reloc_bases_
// array to point to the first entry in each block.  If CLEAR_COUNTS
// is TRUE, also clear the per-symbol relocation counters.

void
Relobj::finalize_incremental_relocs(Layout* layout, bool clear_counts)
{
  unsigned int nsyms = this->get_global_symbols()->size();
  this->reloc_bases_ = new unsigned int[nsyms];

  gold_assert(this->reloc_bases_ != NULL);
  gold_assert(layout->incremental_inputs() != NULL);

  unsigned int rindex = layout->incremental_inputs()->get_reloc_count();
  for (unsigned int i = 0; i < nsyms; ++i)
    {
      this->reloc_bases_[i] = rindex;
      rindex += this->reloc_counts_[i];
      if (clear_counts)
	this->reloc_counts_[i] = 0;
    }
  layout->incremental_inputs()->set_reloc_count(rindex);
}

// Class Sized_relobj.

// Iterate over local symbols, calling a visitor class V for each GOT offset
// associated with a local symbol.

template<int size, bool big_endian>
void
Sized_relobj<size, big_endian>::do_for_all_local_got_entries(
    Got_offset_list::Visitor* v) const
{
  unsigned int nsyms = this->local_symbol_count();
  for (unsigned int i = 0; i < nsyms; i++)
    {
      Local_got_offsets::const_iterator p = this->local_got_offsets_.find(i);
      if (p != this->local_got_offsets_.end())
	{
	  const Got_offset_list* got_offsets = p->second;
	  got_offsets->for_all_got_offsets(v);
	}
    }
}

// Get the address of an output section.

template<int size, bool big_endian>
uint64_t
Sized_relobj<size, big_endian>::do_output_section_address(
    unsigned int shndx)
{
  // If the input file is linked as --just-symbols, the output
  // section address is the input section address.
  if (this->just_symbols())
    return this->section_address(shndx);

  const Output_section* os = this->do_output_section(shndx);
  gold_assert(os != NULL);
  return os->address();
}

// Class Sized_relobj_file.

template<int size, bool big_endian>
Sized_relobj_file<size, big_endian>::Sized_relobj_file(
    const std::string& name,
    Input_file* input_file,
    off_t offset,
    const elfcpp::Ehdr<size, big_endian>& ehdr)
  : Sized_relobj<size, big_endian>(name, input_file, offset),
    elf_file_(this, ehdr),
    symtab_shndx_(-1U),
    local_symbol_count_(0),
    output_local_symbol_count_(0),
    output_local_dynsym_count_(0),
    symbols_(),
    defined_count_(0),
    local_symbol_offset_(0),
    local_dynsym_offset_(0),
    local_values_(),
    local_plt_offsets_(),
    kept_comdat_sections_(),
    has_eh_frame_(false),
    discarded_eh_frame_shndx_(-1U),
    deferred_layout_(),
    deferred_layout_relocs_(),
    compressed_sections_()
{
  this->e_type_ = ehdr.get_e_type();
}

template<int size, bool big_endian>
Sized_relobj_file<size, big_endian>::~Sized_relobj_file()
{
}

// Set up an object file based on the file header.  This sets up the
// section information.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_setup()
{
  const unsigned int shnum = this->elf_file_.shnum();
  this->set_shnum(shnum);
}

// Find the SHT_SYMTAB section, given the section headers.  The ELF
// standard says that maybe in the future there can be more than one
// SHT_SYMTAB section.  Until somebody figures out how that could
// work, we assume there is only one.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::find_symtab(const unsigned char* pshdrs)
{
  const unsigned int shnum = this->shnum();
  this->symtab_shndx_ = 0;
  if (shnum > 0)
    {
      // Look through the sections in reverse order, since gas tends
      // to put the symbol table at the end.
      const unsigned char* p = pshdrs + shnum * This::shdr_size;
      unsigned int i = shnum;
      unsigned int xindex_shndx = 0;
      unsigned int xindex_link = 0;
      while (i > 0)
	{
	  --i;
	  p -= This::shdr_size;
	  typename This::Shdr shdr(p);
	  if (shdr.get_sh_type() == elfcpp::SHT_SYMTAB)
	    {
	      this->symtab_shndx_ = i;
	      if (xindex_shndx > 0 && xindex_link == i)
		{
		  Xindex* xindex =
		    new Xindex(this->elf_file_.large_shndx_offset());
		  xindex->read_symtab_xindex<size, big_endian>(this,
							       xindex_shndx,
							       pshdrs);
		  this->set_xindex(xindex);
		}
	      break;
	    }

	  // Try to pick up the SHT_SYMTAB_SHNDX section, if there is
	  // one.  This will work if it follows the SHT_SYMTAB
	  // section.
	  if (shdr.get_sh_type() == elfcpp::SHT_SYMTAB_SHNDX)
	    {
	      xindex_shndx = i;
	      xindex_link = this->adjust_shndx(shdr.get_sh_link());
	    }
	}
    }
}

// Return the Xindex structure to use for object with lots of
// sections.

template<int size, bool big_endian>
Xindex*
Sized_relobj_file<size, big_endian>::do_initialize_xindex()
{
  gold_assert(this->symtab_shndx_ != -1U);
  Xindex* xindex = new Xindex(this->elf_file_.large_shndx_offset());
  xindex->initialize_symtab_xindex<size, big_endian>(this, this->symtab_shndx_);
  return xindex;
}

// Return whether SHDR has the right type and flags to be a GNU
// .eh_frame section.

template<int size, bool big_endian>
bool
Sized_relobj_file<size, big_endian>::check_eh_frame_flags(
    const elfcpp::Shdr<size, big_endian>* shdr) const
{
  elfcpp::Elf_Word sh_type = shdr->get_sh_type();
  return ((sh_type == elfcpp::SHT_PROGBITS
	   || sh_type == elfcpp::SHT_X86_64_UNWIND)
	  && (shdr->get_sh_flags() & elfcpp::SHF_ALLOC) != 0);
}

// Find the section header with the given name.

template<int size, bool big_endian>
const unsigned char*
Object::find_shdr(
    const unsigned char* pshdrs,
    const char* name,
    const char* names,
    section_size_type names_size,
    const unsigned char* hdr) const
{
  const int shdr_size = elfcpp::Elf_sizes<size>::shdr_size;
  const unsigned int shnum = this->shnum();
  const unsigned char* hdr_end = pshdrs + shdr_size * shnum;
  size_t sh_name = 0;

  while (1)
    {
      if (hdr)
	{
	  // We found HDR last time we were called, continue looking.
	  typename elfcpp::Shdr<size, big_endian> shdr(hdr);
	  sh_name = shdr.get_sh_name();
	}
      else
	{
	  // Look for the next occurrence of NAME in NAMES.
	  // The fact that .shstrtab produced by current GNU tools is
	  // string merged means we shouldn't have both .not.foo and
	  // .foo in .shstrtab, and multiple .foo sections should all
	  // have the same sh_name.  However, this is not guaranteed
	  // by the ELF spec and not all ELF object file producers may
	  // be so clever.
	  size_t len = strlen(name) + 1;
	  const char *p = sh_name ? names + sh_name + len : names;
	  p = reinterpret_cast<const char*>(memmem(p, names_size - (p - names),
						   name, len));
	  if (p == NULL)
	    return NULL;
	  sh_name = p - names;
	  hdr = pshdrs;
	  if (sh_name == 0)
	    return hdr;
	}

      hdr += shdr_size;
      while (hdr < hdr_end)
	{
	  typename elfcpp::Shdr<size, big_endian> shdr(hdr);
	  if (shdr.get_sh_name() == sh_name)
	    return hdr;
	  hdr += shdr_size;
	}
      hdr = NULL;
      if (sh_name == 0)
	return hdr;
    }
}

// Return whether there is a GNU .eh_frame section, given the section
// headers and the section names.

template<int size, bool big_endian>
bool
Sized_relobj_file<size, big_endian>::find_eh_frame(
    const unsigned char* pshdrs,
    const char* names,
    section_size_type names_size) const
{
  const unsigned char* s = NULL;

  while (1)
    {
      s = this->template find_shdr<size, big_endian>(pshdrs, ".eh_frame",
						     names, names_size, s);
      if (s == NULL)
	return false;

      typename This::Shdr shdr(s);
      if (this->check_eh_frame_flags(&shdr))
	return true;
    }
}

// Return TRUE if this is a section whose contents will be needed in the
// Add_symbols task.  This function is only called for sections that have
// already passed the test in is_compressed_debug_section(), so we know
// that the section name begins with ".zdebug".

static bool
need_decompressed_section(const char* name)
{
  // Skip over the ".zdebug" and a quick check for the "_".
  name += 7;
  if (*name++ != '_')
    return false;

#ifdef ENABLE_THREADS
  // Decompressing these sections now will help only if we're
  // multithreaded.
  if (parameters->options().threads())
    {
      // We will need .zdebug_str if this is not an incremental link
      // (i.e., we are processing string merge sections) or if we need
      // to build a gdb index.
      if ((!parameters->incremental() || parameters->options().gdb_index())
	  && strcmp(name, "str") == 0)
	return true;

      // We will need these other sections when building a gdb index.
      if (parameters->options().gdb_index()
	  && (strcmp(name, "info") == 0
	      || strcmp(name, "types") == 0
	      || strcmp(name, "pubnames") == 0
	      || strcmp(name, "pubtypes") == 0
	      || strcmp(name, "ranges") == 0
	      || strcmp(name, "abbrev") == 0))
	return true;
    }
#endif

  // Even when single-threaded, we will need .zdebug_str if this is
  // not an incremental link and we are building a gdb index.
  // Otherwise, we would decompress the section twice: once for
  // string merge processing, and once for building the gdb index.
  if (!parameters->incremental()
      && parameters->options().gdb_index()
      && strcmp(name, "str") == 0)
    return true;

  return false;
}

// Build a table for any compressed debug sections, mapping each section index
// to the uncompressed size and (if needed) the decompressed contents.

template<int size, bool big_endian>
Compressed_section_map*
build_compressed_section_map(
    const unsigned char* pshdrs,
    unsigned int shnum,
    const char* names,
    section_size_type names_size,
    Sized_relobj_file<size, big_endian>* obj)
{
  Compressed_section_map* uncompressed_map = new Compressed_section_map();
  const unsigned int shdr_size = elfcpp::Elf_sizes<size>::shdr_size;
  const unsigned char* p = pshdrs + shdr_size;

  for (unsigned int i = 1; i < shnum; ++i, p += shdr_size)
    {
      typename elfcpp::Shdr<size, big_endian> shdr(p);
      if (shdr.get_sh_type() == elfcpp::SHT_PROGBITS
	  && (shdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0)
	{
	  if (shdr.get_sh_name() >= names_size)
	    {
	      obj->error(_("bad section name offset for section %u: %lu"),
			 i, static_cast<unsigned long>(shdr.get_sh_name()));
	      continue;
	    }

	  const char* name = names + shdr.get_sh_name();
	  if (is_compressed_debug_section(name))
	    {
	      section_size_type len;
	      const unsigned char* contents =
		  obj->section_contents(i, &len, false);
	      uint64_t uncompressed_size = get_uncompressed_size(contents, len);
	      Compressed_section_info info;
	      info.size = convert_to_section_size_type(uncompressed_size);
	      info.contents = NULL;
	      if (uncompressed_size != -1ULL)
		{
		  unsigned char* uncompressed_data = NULL;
		  if (need_decompressed_section(name))
		    {
		      uncompressed_data = new unsigned char[uncompressed_size];
		      if (decompress_input_section(contents, len,
						   uncompressed_data,
						   uncompressed_size))
			info.contents = uncompressed_data;
		      else
			delete[] uncompressed_data;
		    }
		  (*uncompressed_map)[i] = info;
		}
	    }
	}
    }
  return uncompressed_map;
}

// Stash away info for a number of special sections.
// Return true if any of the sections found require local symbols to be read.

template<int size, bool big_endian>
bool
Sized_relobj_file<size, big_endian>::do_find_special_sections(
    Read_symbols_data* sd)
{
  const unsigned char* const pshdrs = sd->section_headers->data();
  const unsigned char* namesu = sd->section_names->data();
  const char* names = reinterpret_cast<const char*>(namesu);

  if (this->find_eh_frame(pshdrs, names, sd->section_names_size))
    this->has_eh_frame_ = true;

  if (memmem(names, sd->section_names_size, ".zdebug_", 8) != NULL)
    this->compressed_sections_
      = build_compressed_section_map(pshdrs, this->shnum(), names,
				     sd->section_names_size, this);
  return (this->has_eh_frame_
	  || (!parameters->options().relocatable()
	      && parameters->options().gdb_index()
	      && (memmem(names, sd->section_names_size, "debug_info", 12) == 0
		  || memmem(names, sd->section_names_size, "debug_types",
			    13) == 0)));
}

// Read the sections and symbols from an object file.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_read_symbols(Read_symbols_data* sd)
{
  this->read_section_data(&this->elf_file_, sd);

  const unsigned char* const pshdrs = sd->section_headers->data();

  this->find_symtab(pshdrs);

  bool need_local_symbols = this->do_find_special_sections(sd);

  sd->symbols = NULL;
  sd->symbols_size = 0;
  sd->external_symbols_offset = 0;
  sd->symbol_names = NULL;
  sd->symbol_names_size = 0;

  if (this->symtab_shndx_ == 0)
    {
      // No symbol table.  Weird but legal.
      return;
    }

  // Get the symbol table section header.
  typename This::Shdr symtabshdr(pshdrs
				 + this->symtab_shndx_ * This::shdr_size);
  gold_assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);

  // If this object has a .eh_frame section, or if building a .gdb_index
  // section and there is debug info, we need all the symbols.
  // Otherwise we only need the external symbols.  While it would be
  // simpler to just always read all the symbols, I've seen object
  // files with well over 2000 local symbols, which for a 64-bit
  // object file format is over 5 pages that we don't need to read
  // now.

  const int sym_size = This::sym_size;
  const unsigned int loccount = symtabshdr.get_sh_info();
  this->local_symbol_count_ = loccount;
  this->local_values_.resize(loccount);
  section_offset_type locsize = loccount * sym_size;
  off_t dataoff = symtabshdr.get_sh_offset();
  section_size_type datasize =
    convert_to_section_size_type(symtabshdr.get_sh_size());
  off_t extoff = dataoff + locsize;
  section_size_type extsize = datasize - locsize;

  off_t readoff = need_local_symbols ? dataoff : extoff;
  section_size_type readsize = need_local_symbols ? datasize : extsize;

  if (readsize == 0)
    {
      // No external symbols.  Also weird but also legal.
      return;
    }

  File_view* fvsymtab = this->get_lasting_view(readoff, readsize, true, false);

  // Read the section header for the symbol names.
  unsigned int strtab_shndx = this->adjust_shndx(symtabshdr.get_sh_link());
  if (strtab_shndx >= this->shnum())
    {
      this->error(_("invalid symbol table name index: %u"), strtab_shndx);
      return;
    }
  typename This::Shdr strtabshdr(pshdrs + strtab_shndx * This::shdr_size);
  if (strtabshdr.get_sh_type() != elfcpp::SHT_STRTAB)
    {
      this->error(_("symbol table name section has wrong type: %u"),
		  static_cast<unsigned int>(strtabshdr.get_sh_type()));
      return;
    }

  // Read the symbol names.
  File_view* fvstrtab = this->get_lasting_view(strtabshdr.get_sh_offset(),
					       strtabshdr.get_sh_size(),
					       false, true);

  sd->symbols = fvsymtab;
  sd->symbols_size = readsize;
  sd->external_symbols_offset = need_local_symbols ? locsize : 0;
  sd->symbol_names = fvstrtab;
  sd->symbol_names_size =
    convert_to_section_size_type(strtabshdr.get_sh_size());
}

// Return the section index of symbol SYM.  Set *VALUE to its value in
// the object file.  Set *IS_ORDINARY if this is an ordinary section
// index, not a special code between SHN_LORESERVE and SHN_HIRESERVE.
// Note that for a symbol which is not defined in this object file,
// this will set *VALUE to 0 and return SHN_UNDEF; it will not return
// the final value of the symbol in the link.

template<int size, bool big_endian>
unsigned int
Sized_relobj_file<size, big_endian>::symbol_section_and_value(unsigned int sym,
							      Address* value,
							      bool* is_ordinary)
{
  section_size_type symbols_size;
  const unsigned char* symbols = this->section_contents(this->symtab_shndx_,
							&symbols_size,
							false);

  const size_t count = symbols_size / This::sym_size;
  gold_assert(sym < count);

  elfcpp::Sym<size, big_endian> elfsym(symbols + sym * This::sym_size);
  *value = elfsym.get_st_value();

  return this->adjust_sym_shndx(sym, elfsym.get_st_shndx(), is_ordinary);
}

// Return whether to include a section group in the link.  LAYOUT is
// used to keep track of which section groups we have already seen.
// INDEX is the index of the section group and SHDR is the section
// header.  If we do not want to include this group, we set bits in
// OMIT for each section which should be discarded.

template<int size, bool big_endian>
bool
Sized_relobj_file<size, big_endian>::include_section_group(
    Symbol_table* symtab,
    Layout* layout,
    unsigned int index,
    const char* name,
    const unsigned char* shdrs,
    const char* section_names,
    section_size_type section_names_size,
    std::vector<bool>* omit)
{
  // Read the section contents.
  typename This::Shdr shdr(shdrs + index * This::shdr_size);
  const unsigned char* pcon = this->get_view(shdr.get_sh_offset(),
					     shdr.get_sh_size(), true, false);
  const elfcpp::Elf_Word* pword =
    reinterpret_cast<const elfcpp::Elf_Word*>(pcon);

  // The first word contains flags.  We only care about COMDAT section
  // groups.  Other section groups are always included in the link
  // just like ordinary sections.
  elfcpp::Elf_Word flags = elfcpp::Swap<32, big_endian>::readval(pword);

  // Look up the group signature, which is the name of a symbol.  ELF
  // uses a symbol name because some group signatures are long, and
  // the name is generally already in the symbol table, so it makes
  // sense to put the long string just once in .strtab rather than in
  // both .strtab and .shstrtab.

  // Get the appropriate symbol table header (this will normally be
  // the single SHT_SYMTAB section, but in principle it need not be).
  const unsigned int link = this->adjust_shndx(shdr.get_sh_link());
  typename This::Shdr symshdr(this, this->elf_file_.section_header(link));

  // Read the symbol table entry.
  unsigned int symndx = shdr.get_sh_info();
  if (symndx >= symshdr.get_sh_size() / This::sym_size)
    {
      this->error(_("section group %u info %u out of range"),
		  index, symndx);
      return false;
    }
  off_t symoff = symshdr.get_sh_offset() + symndx * This::sym_size;
  const unsigned char* psym = this->get_view(symoff, This::sym_size, true,
					     false);
  elfcpp::Sym<size, big_endian> sym(psym);

  // Read the symbol table names.
  section_size_type symnamelen;
  const unsigned char* psymnamesu;
  psymnamesu = this->section_contents(this->adjust_shndx(symshdr.get_sh_link()),
				      &symnamelen, true);
  const char* psymnames = reinterpret_cast<const char*>(psymnamesu);

  // Get the section group signature.
  if (sym.get_st_name() >= symnamelen)
    {
      this->error(_("symbol %u name offset %u out of range"),
		  symndx, sym.get_st_name());
      return false;
    }

  std::string signature(psymnames + sym.get_st_name());

  // It seems that some versions of gas will create a section group
  // associated with a section symbol, and then fail to give a name to
  // the section symbol.  In such a case, use the name of the section.
  if (signature[0] == '\0' && sym.get_st_type() == elfcpp::STT_SECTION)
    {
      bool is_ordinary;
      unsigned int sym_shndx = this->adjust_sym_shndx(symndx,
						      sym.get_st_shndx(),
						      &is_ordinary);
      if (!is_ordinary || sym_shndx >= this->shnum())
	{
	  this->error(_("symbol %u invalid section index %u"),
		      symndx, sym_shndx);
	  return false;
	}
      typename This::Shdr member_shdr(shdrs + sym_shndx * This::shdr_size);
      if (member_shdr.get_sh_name() < section_names_size)
	signature = section_names + member_shdr.get_sh_name();
    }

  // Record this section group in the layout, and see whether we've already
  // seen one with the same signature.
  bool include_group;
  bool is_comdat;
  Kept_section* kept_section = NULL;

  if ((flags & elfcpp::GRP_COMDAT) == 0)
    {
      include_group = true;
      is_comdat = false;
    }
  else
    {
      include_group = layout->find_or_add_kept_section(signature,
						       this, index, true,
						       true, &kept_section);
      is_comdat = true;
    }

  if (is_comdat && include_group)
    {
      Incremental_inputs* incremental_inputs = layout->incremental_inputs();
      if (incremental_inputs != NULL)
	incremental_inputs->report_comdat_group(this, signature.c_str());
    }

  size_t count = shdr.get_sh_size() / sizeof(elfcpp::Elf_Word);

  std::vector<unsigned int> shndxes;
  bool relocate_group = include_group && parameters->options().relocatable();
  if (relocate_group)
    shndxes.reserve(count - 1);

  for (size_t i = 1; i < count; ++i)
    {
      elfcpp::Elf_Word shndx =
	this->adjust_shndx(elfcpp::Swap<32, big_endian>::readval(pword + i));

      if (relocate_group)
	shndxes.push_back(shndx);

      if (shndx >= this->shnum())
	{
	  this->error(_("section %u in section group %u out of range"),
		      shndx, index);
	  continue;
	}

      // Check for an earlier section number, since we're going to get
      // it wrong--we may have already decided to include the section.
      if (shndx < index)
	this->error(_("invalid section group %u refers to earlier section %u"),
		    index, shndx);

      // Get the name of the member section.
      typename This::Shdr member_shdr(shdrs + shndx * This::shdr_size);
      if (member_shdr.get_sh_name() >= section_names_size)
	{
	  // This is an error, but it will be diagnosed eventually
	  // in do_layout, so we don't need to do anything here but
	  // ignore it.
	  continue;
	}
      std::string mname(section_names + member_shdr.get_sh_name());

      if (include_group)
	{
	  if (is_comdat)
	    kept_section->add_comdat_section(mname, shndx,
					     member_shdr.get_sh_size());
	}
      else
	{
	  (*omit)[shndx] = true;

	  if (is_comdat)
	    {
	      Relobj* kept_object = kept_section->object();
	      if (kept_section->is_comdat())
		{
		  // Find the corresponding kept section, and store
		  // that info in the discarded section table.
		  unsigned int kept_shndx;
		  uint64_t kept_size;
		  if (kept_section->find_comdat_section(mname, &kept_shndx,
							&kept_size))
		    {
		      // We don't keep a mapping for this section if
		      // it has a different size.  The mapping is only
		      // used for relocation processing, and we don't
		      // want to treat the sections as similar if the
		      // sizes are different.  Checking the section
		      // size is the approach used by the GNU linker.
		      if (kept_size == member_shdr.get_sh_size())
			this->set_kept_comdat_section(shndx, kept_object,
						      kept_shndx);
		    }
		}
	      else
		{
		  // The existing section is a linkonce section.  Add
		  // a mapping if there is exactly one section in the
		  // group (which is true when COUNT == 2) and if it
		  // is the same size.
		  if (count == 2
		      && (kept_section->linkonce_size()
			  == member_shdr.get_sh_size()))
		    this->set_kept_comdat_section(shndx, kept_object,
						  kept_section->shndx());
		}
	    }
	}
    }

  if (relocate_group)
    layout->layout_group(symtab, this, index, name, signature.c_str(),
			 shdr, flags, &shndxes);

  return include_group;
}

// Whether to include a linkonce section in the link.  NAME is the
// name of the section and SHDR is the section header.

// Linkonce sections are a GNU extension implemented in the original
// GNU linker before section groups were defined.  The semantics are
// that we only include one linkonce section with a given name.  The
// name of a linkonce section is normally .gnu.linkonce.T.SYMNAME,
// where T is the type of section and SYMNAME is the name of a symbol.
// In an attempt to make linkonce sections interact well with section
// groups, we try to identify SYMNAME and use it like a section group
// signature.  We want to block section groups with that signature,
// but not other linkonce sections with that signature.  We also use
// the full name of the linkonce section as a normal section group
// signature.

template<int size, bool big_endian>
bool
Sized_relobj_file<size, big_endian>::include_linkonce_section(
    Layout* layout,
    unsigned int index,
    const char* name,
    const elfcpp::Shdr<size, big_endian>& shdr)
{
  typename elfcpp::Elf_types<size>::Elf_WXword sh_size = shdr.get_sh_size();
  // In general the symbol name we want will be the string following
  // the last '.'.  However, we have to handle the case of
  // .gnu.linkonce.t.__i686.get_pc_thunk.bx, which was generated by
  // some versions of gcc.  So we use a heuristic: if the name starts
  // with ".gnu.linkonce.t.", we use everything after that.  Otherwise
  // we look for the last '.'.  We can't always simply skip
  // ".gnu.linkonce.X", because we have to deal with cases like
  // ".gnu.linkonce.d.rel.ro.local".
  const char* const linkonce_t = ".gnu.linkonce.t.";
  const char* symname;
  if (strncmp(name, linkonce_t, strlen(linkonce_t)) == 0)
    symname = name + strlen(linkonce_t);
  else
    symname = strrchr(name, '.') + 1;
  std::string sig1(symname);
  std::string sig2(name);
  Kept_section* kept1;
  Kept_section* kept2;
  bool include1 = layout->find_or_add_kept_section(sig1, this, index, false,
						   false, &kept1);
  bool include2 = layout->find_or_add_kept_section(sig2, this, index, false,
						   true, &kept2);

  if (!include2)
    {
      // We are not including this section because we already saw the
      // name of the section as a signature.  This normally implies
      // that the kept section is another linkonce section.  If it is
      // the same size, record it as the section which corresponds to
      // this one.
      if (kept2->object() != NULL
	  && !kept2->is_comdat()
	  && kept2->linkonce_size() == sh_size)
	this->set_kept_comdat_section(index, kept2->object(), kept2->shndx());
    }
  else if (!include1)
    {
      // The section is being discarded on the basis of its symbol
      // name.  This means that the corresponding kept section was
      // part of a comdat group, and it will be difficult to identify
      // the specific section within that group that corresponds to
      // this linkonce section.  We'll handle the simple case where
      // the group has only one member section.  Otherwise, it's not
      // worth the effort.
      unsigned int kept_shndx;
      uint64_t kept_size;
      if (kept1->object() != NULL
	  && kept1->is_comdat()
	  && kept1->find_single_comdat_section(&kept_shndx, &kept_size)
	  && kept_size == sh_size)
	this->set_kept_comdat_section(index, kept1->object(), kept_shndx);
    }
  else
    {
      kept1->set_linkonce_size(sh_size);
      kept2->set_linkonce_size(sh_size);
    }

  return include1 && include2;
}

// Layout an input section.

template<int size, bool big_endian>
inline void
Sized_relobj_file<size, big_endian>::layout_section(
    Layout* layout,
    unsigned int shndx,
    const char* name,
    const typename This::Shdr& shdr,
    unsigned int reloc_shndx,
    unsigned int reloc_type)
{
  off_t offset;
  Output_section* os = layout->layout(this, shndx, name, shdr,
					  reloc_shndx, reloc_type, &offset);

  this->output_sections()[shndx] = os;
  if (offset == -1)
    this->section_offsets()[shndx] = invalid_address;
  else
    this->section_offsets()[shndx] = convert_types<Address, off_t>(offset);

  // If this section requires special handling, and if there are
  // relocs that apply to it, then we must do the special handling
  // before we apply the relocs.
  if (offset == -1 && reloc_shndx != 0)
    this->set_relocs_must_follow_section_writes();
}

// Layout an input .eh_frame section.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::layout_eh_frame_section(
    Layout* layout,
    const unsigned char* symbols_data,
    section_size_type symbols_size,
    const unsigned char* symbol_names_data,
    section_size_type symbol_names_size,
    unsigned int shndx,
    const typename This::Shdr& shdr,
    unsigned int reloc_shndx,
    unsigned int reloc_type)
{
  gold_assert(this->has_eh_frame_);

  off_t offset;
  Output_section* os = layout->layout_eh_frame(this,
					       symbols_data,
					       symbols_size,
					       symbol_names_data,
					       symbol_names_size,
					       shndx,
					       shdr,
					       reloc_shndx,
					       reloc_type,
					       &offset);
  this->output_sections()[shndx] = os;
  if (os == NULL || offset == -1)
    {
      // An object can contain at most one section holding exception
      // frame information.
      gold_assert(this->discarded_eh_frame_shndx_ == -1U);
      this->discarded_eh_frame_shndx_ = shndx;
      this->section_offsets()[shndx] = invalid_address;
    }
  else
    this->section_offsets()[shndx] = convert_types<Address, off_t>(offset);

  // If this section requires special handling, and if there are
  // relocs that aply to it, then we must do the special handling
  // before we apply the relocs.
  if (os != NULL && offset == -1 && reloc_shndx != 0)
    this->set_relocs_must_follow_section_writes();
}

// Lay out the input sections.  We walk through the sections and check
// whether they should be included in the link.  If they should, we
// pass them to the Layout object, which will return an output section
// and an offset.
// This function is called twice sometimes, two passes, when mapping
// of input sections to output sections must be delayed.
// This is true for the following :
// * Garbage collection (--gc-sections): Some input sections will be
// discarded and hence the assignment must wait until the second pass.
// In the first pass,  it is for setting up some sections as roots to
// a work-list for --gc-sections and to do comdat processing.
// * Identical Code Folding (--icf=<safe,all>): Some input sections
// will be folded and hence the assignment must wait.
// * Using plugins to map some sections to unique segments: Mapping
// some sections to unique segments requires mapping them to unique
// output sections too.  This can be done via plugins now and this
// information is not available in the first pass.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_layout(Symbol_table* symtab,
					       Layout* layout,
					       Read_symbols_data* sd)
{
  const unsigned int shnum = this->shnum();

  /* Should this function be called twice?  */
  bool is_two_pass = (parameters->options().gc_sections()
		      || parameters->options().icf_enabled()
		      || layout->is_unique_segment_for_sections_specified());

  /* Only one of is_pass_one and is_pass_two is true.  Both are false when
     a two-pass approach is not needed.  */
  bool is_pass_one = false;
  bool is_pass_two = false;

  Symbols_data* gc_sd = NULL;

  /* Check if do_layout needs to be two-pass.  If so, find out which pass
     should happen.  In the first pass, the data in sd is saved to be used
     later in the second pass.  */
  if (is_two_pass)
    {
      gc_sd = this->get_symbols_data();
      if (gc_sd == NULL)
	{
	  gold_assert(sd != NULL);
	  is_pass_one = true;
	}
      else
	{
	  if (parameters->options().gc_sections())
	    gold_assert(symtab->gc()->is_worklist_ready());
	  if (parameters->options().icf_enabled())
	    gold_assert(symtab->icf()->is_icf_ready()); 
	  is_pass_two = true;
	}
    }
    
  if (shnum == 0)
    return;

  if (is_pass_one)
    {
      // During garbage collection save the symbols data to use it when
      // re-entering this function.
      gc_sd = new Symbols_data;
      this->copy_symbols_data(gc_sd, sd, This::shdr_size * shnum);
      this->set_symbols_data(gc_sd);
    }

  const unsigned char* section_headers_data = NULL;
  section_size_type section_names_size;
  const unsigned char* symbols_data = NULL;
  section_size_type symbols_size;
  const unsigned char* symbol_names_data = NULL;
  section_size_type symbol_names_size;

  if (is_two_pass)
    {
      section_headers_data = gc_sd->section_headers_data;
      section_names_size = gc_sd->section_names_size;
      symbols_data = gc_sd->symbols_data;
      symbols_size = gc_sd->symbols_size;
      symbol_names_data = gc_sd->symbol_names_data;
      symbol_names_size = gc_sd->symbol_names_size;
    }
  else
    {
      section_headers_data = sd->section_headers->data();
      section_names_size = sd->section_names_size;
      if (sd->symbols != NULL)
	symbols_data = sd->symbols->data();
      symbols_size = sd->symbols_size;
      if (sd->symbol_names != NULL)
	symbol_names_data = sd->symbol_names->data();
      symbol_names_size = sd->symbol_names_size;
    }

  // Get the section headers.
  const unsigned char* shdrs = section_headers_data;
  const unsigned char* pshdrs;

  // Get the section names.
  const unsigned char* pnamesu = (is_two_pass
				  ? gc_sd->section_names_data
				  : sd->section_names->data());

  const char* pnames = reinterpret_cast<const char*>(pnamesu);

  // If any input files have been claimed by plugins, we need to defer
  // actual layout until the replacement files have arrived.
  const bool should_defer_layout =
      (parameters->options().has_plugins()
       && parameters->options().plugins()->should_defer_layout());
  unsigned int num_sections_to_defer = 0;

  // For each section, record the index of the reloc section if any.
  // Use 0 to mean that there is no reloc section, -1U to mean that
  // there is more than one.
  std::vector<unsigned int> reloc_shndx(shnum, 0);
  std::vector<unsigned int> reloc_type(shnum, elfcpp::SHT_NULL);
  // Skip the first, dummy, section.
  pshdrs = shdrs + This::shdr_size;
  for (unsigned int i = 1; i < shnum; ++i, pshdrs += This::shdr_size)
    {
      typename This::Shdr shdr(pshdrs);

      // Count the number of sections whose layout will be deferred.
      if (should_defer_layout && (shdr.get_sh_flags() & elfcpp::SHF_ALLOC))
	++num_sections_to_defer;

      unsigned int sh_type = shdr.get_sh_type();
      if (sh_type == elfcpp::SHT_REL || sh_type == elfcpp::SHT_RELA)
	{
	  unsigned int target_shndx = this->adjust_shndx(shdr.get_sh_info());
	  if (target_shndx == 0 || target_shndx >= shnum)
	    {
	      this->error(_("relocation section %u has bad info %u"),
			  i, target_shndx);
	      continue;
	    }

	  if (reloc_shndx[target_shndx] != 0)
	    reloc_shndx[target_shndx] = -1U;
	  else
	    {
	      reloc_shndx[target_shndx] = i;
	      reloc_type[target_shndx] = sh_type;
	    }
	}
    }

  Output_sections& out_sections(this->output_sections());
  std::vector<Address>& out_section_offsets(this->section_offsets());

  if (!is_pass_two)
    {
      out_sections.resize(shnum);
      out_section_offsets.resize(shnum);
    }

  // If we are only linking for symbols, then there is nothing else to
  // do here.
  if (this->input_file()->just_symbols())
    {
      if (!is_pass_two)
	{
	  delete sd->section_headers;
	  sd->section_headers = NULL;
	  delete sd->section_names;
	  sd->section_names = NULL;
	}
      return;
    }

  if (num_sections_to_defer > 0)
    {
      parameters->options().plugins()->add_deferred_layout_object(this);
      this->deferred_layout_.reserve(num_sections_to_defer);
    }

  // Whether we've seen a .note.GNU-stack section.
  bool seen_gnu_stack = false;
  // The flags of a .note.GNU-stack section.
  uint64_t gnu_stack_flags = 0;

  // Keep track of which sections to omit.
  std::vector<bool> omit(shnum, false);

  // Keep track of reloc sections when emitting relocations.
  const bool relocatable = parameters->options().relocatable();
  const bool emit_relocs = (relocatable
			    || parameters->options().emit_relocs());
  std::vector<unsigned int> reloc_sections;

  // Keep track of .eh_frame sections.
  std::vector<unsigned int> eh_frame_sections;

  // Keep track of .debug_info and .debug_types sections.
  std::vector<unsigned int> debug_info_sections;
  std::vector<unsigned int> debug_types_sections;

  // Skip the first, dummy, section.
  pshdrs = shdrs + This::shdr_size;
  for (unsigned int i = 1; i < shnum; ++i, pshdrs += This::shdr_size)
    {
      typename This::Shdr shdr(pshdrs);

      if (shdr.get_sh_name() >= section_names_size)
	{
	  this->error(_("bad section name offset for section %u: %lu"),
		      i, static_cast<unsigned long>(shdr.get_sh_name()));
	  return;
	}

      const char* name = pnames + shdr.get_sh_name();

      if (!is_pass_two)
	{
	  if (this->handle_gnu_warning_section(name, i, symtab))
	    {
	      if (!relocatable && !parameters->options().shared())
		omit[i] = true;
	    }

	  // The .note.GNU-stack section is special.  It gives the
	  // protection flags that this object file requires for the stack
	  // in memory.
	  if (strcmp(name, ".note.GNU-stack") == 0)
	    {
	      seen_gnu_stack = true;
	      gnu_stack_flags |= shdr.get_sh_flags();
	      omit[i] = true;
	    }

	  // The .note.GNU-split-stack section is also special.  It
	  // indicates that the object was compiled with
	  // -fsplit-stack.
	  if (this->handle_split_stack_section(name))
	    {
	      if (!relocatable && !parameters->options().shared())
		omit[i] = true;
	    }

	  // Skip attributes section.
	  if (parameters->target().is_attributes_section(name))
	    {
	      omit[i] = true;
	    }

	  bool discard = omit[i];
	  if (!discard)
	    {
	      if (shdr.get_sh_type() == elfcpp::SHT_GROUP)
		{
		  if (!this->include_section_group(symtab, layout, i, name,
						   shdrs, pnames,
						   section_names_size,
						   &omit))
		    discard = true;
		}
	      else if ((shdr.get_sh_flags() & elfcpp::SHF_GROUP) == 0
		       && Layout::is_linkonce(name))
		{
		  if (!this->include_linkonce_section(layout, i, name, shdr))
		    discard = true;
		}
	    }

	  // Add the section to the incremental inputs layout.
	  Incremental_inputs* incremental_inputs = layout->incremental_inputs();
	  if (incremental_inputs != NULL
	      && !discard
	      && can_incremental_update(shdr.get_sh_type()))
	    {
	      off_t sh_size = shdr.get_sh_size();
	      section_size_type uncompressed_size;
	      if (this->section_is_compressed(i, &uncompressed_size))
		sh_size = uncompressed_size;
	      incremental_inputs->report_input_section(this, i, name, sh_size);
	    }

	  if (discard)
	    {
	      // Do not include this section in the link.
	      out_sections[i] = NULL;
	      out_section_offsets[i] = invalid_address;
	      continue;
	    }
	}

      if (is_pass_one && parameters->options().gc_sections())
	{
	  if (this->is_section_name_included(name)
	      || layout->keep_input_section (this, name)
	      || shdr.get_sh_type() == elfcpp::SHT_INIT_ARRAY
	      || shdr.get_sh_type() == elfcpp::SHT_FINI_ARRAY)
	    {
	      symtab->gc()->worklist().push(Section_id(this, i));
	    }
	  // If the section name XXX can be represented as a C identifier
	  // it cannot be discarded if there are references to
	  // __start_XXX and __stop_XXX symbols.  These need to be
	  // specially handled.
	  if (is_cident(name))
	    {
	      symtab->gc()->add_cident_section(name, Section_id(this, i));
	    }
	}

      // When doing a relocatable link we are going to copy input
      // reloc sections into the output.  We only want to copy the
      // ones associated with sections which are not being discarded.
      // However, we don't know that yet for all sections.  So save
      // reloc sections and process them later. Garbage collection is
      // not triggered when relocatable code is desired.
      if (emit_relocs
	  && (shdr.get_sh_type() == elfcpp::SHT_REL
	      || shdr.get_sh_type() == elfcpp::SHT_RELA))
	{
	  reloc_sections.push_back(i);
	  continue;
	}

      if (relocatable && shdr.get_sh_type() == elfcpp::SHT_GROUP)
	continue;

      // The .eh_frame section is special.  It holds exception frame
      // information that we need to read in order to generate the
      // exception frame header.  We process these after all the other
      // sections so that the exception frame reader can reliably
      // determine which sections are being discarded, and discard the
      // corresponding information.
      if (!relocatable
	  && strcmp(name, ".eh_frame") == 0
	  && this->check_eh_frame_flags(&shdr))
	{
	  if (is_pass_one)
	    {
	      out_sections[i] = reinterpret_cast<Output_section*>(1);
	      out_section_offsets[i] = invalid_address;
	    }
	  else if (should_defer_layout)
	    this->deferred_layout_.push_back(Deferred_layout(i, name,
							     pshdrs,
							     reloc_shndx[i],
							     reloc_type[i]));
	  else
	    eh_frame_sections.push_back(i);
	  continue;
	}

      if (is_pass_two && parameters->options().gc_sections())
	{
	  // This is executed during the second pass of garbage
	  // collection. do_layout has been called before and some
	  // sections have been already discarded. Simply ignore
	  // such sections this time around.
	  if (out_sections[i] == NULL)
	    {
	      gold_assert(out_section_offsets[i] == invalid_address);
	      continue;
	    }
	  if (((shdr.get_sh_flags() & elfcpp::SHF_ALLOC) != 0)
	      && symtab->gc()->is_section_garbage(this, i))
	      {
		if (parameters->options().print_gc_sections())
		  gold_info(_("%s: removing unused section from '%s'"
			      " in file '%s'"),
			    program_name, this->section_name(i).c_str(),
			    this->name().c_str());
		out_sections[i] = NULL;
		out_section_offsets[i] = invalid_address;
		continue;
	      }
	}

      if (is_pass_two && parameters->options().icf_enabled())
	{
	  if (out_sections[i] == NULL)
	    {
	      gold_assert(out_section_offsets[i] == invalid_address);
	      continue;
	    }
	  if (((shdr.get_sh_flags() & elfcpp::SHF_ALLOC) != 0)
	      && symtab->icf()->is_section_folded(this, i))
	      {
		if (parameters->options().print_icf_sections())
		  {
		    Section_id folded =
				symtab->icf()->get_folded_section(this, i);
		    Relobj* folded_obj =
				reinterpret_cast<Relobj*>(folded.first);
		    gold_info(_("%s: ICF folding section '%s' in file '%s'"
				"into '%s' in file '%s'"),
			      program_name, this->section_name(i).c_str(),
			      this->name().c_str(),
			      folded_obj->section_name(folded.second).c_str(),
			      folded_obj->name().c_str());
		  }
		out_sections[i] = NULL;
		out_section_offsets[i] = invalid_address;
		continue;
	      }
	}

      // Defer layout here if input files are claimed by plugins.  When gc
      // is turned on this function is called twice.  For the second call
      // should_defer_layout should be false.
      if (should_defer_layout && (shdr.get_sh_flags() & elfcpp::SHF_ALLOC))
	{
	  gold_assert(!is_pass_two);
	  this->deferred_layout_.push_back(Deferred_layout(i, name,
							   pshdrs,
							   reloc_shndx[i],
							   reloc_type[i]));
	  // Put dummy values here; real values will be supplied by
	  // do_layout_deferred_sections.
	  out_sections[i] = reinterpret_cast<Output_section*>(2);
	  out_section_offsets[i] = invalid_address;
	  continue;
	}

      // During gc_pass_two if a section that was previously deferred is
      // found, do not layout the section as layout_deferred_sections will
      // do it later from gold.cc.
      if (is_pass_two
	  && (out_sections[i] == reinterpret_cast<Output_section*>(2)))
	continue;

      if (is_pass_one)
	{
	  // This is during garbage collection. The out_sections are
	  // assigned in the second call to this function.
	  out_sections[i] = reinterpret_cast<Output_section*>(1);
	  out_section_offsets[i] = invalid_address;
	}
      else
	{
	  // When garbage collection is switched on the actual layout
	  // only happens in the second call.
	  this->layout_section(layout, i, name, shdr, reloc_shndx[i],
			       reloc_type[i]);

	  // When generating a .gdb_index section, we do additional
	  // processing of .debug_info and .debug_types sections after all
	  // the other sections for the same reason as above.
	  if (!relocatable
	      && parameters->options().gdb_index()
	      && !(shdr.get_sh_flags() & elfcpp::SHF_ALLOC))
	    {
	      if (strcmp(name, ".debug_info") == 0
		  || strcmp(name, ".zdebug_info") == 0)
		debug_info_sections.push_back(i);
	      else if (strcmp(name, ".debug_types") == 0
		       || strcmp(name, ".zdebug_types") == 0)
		debug_types_sections.push_back(i);
	    }
	}
    }

  if (!is_pass_two)
    layout->layout_gnu_stack(seen_gnu_stack, gnu_stack_flags, this);

  // When doing a relocatable link handle the reloc sections at the
  // end.  Garbage collection  and Identical Code Folding is not
  // turned on for relocatable code.
  if (emit_relocs)
    this->size_relocatable_relocs();

  gold_assert(!is_two_pass || reloc_sections.empty());

  for (std::vector<unsigned int>::const_iterator p = reloc_sections.begin();
       p != reloc_sections.end();
       ++p)
    {
      unsigned int i = *p;
      const unsigned char* pshdr;
      pshdr = section_headers_data + i * This::shdr_size;
      typename This::Shdr shdr(pshdr);

      unsigned int data_shndx = this->adjust_shndx(shdr.get_sh_info());
      if (data_shndx >= shnum)
	{
	  // We already warned about this above.
	  continue;
	}

      Output_section* data_section = out_sections[data_shndx];
      if (data_section == reinterpret_cast<Output_section*>(2))
	{
	  // The layout for the data section was deferred, so we need
	  // to defer the relocation section, too.
	  const char* name = pnames + shdr.get_sh_name();
	  this->deferred_layout_relocs_.push_back(
	      Deferred_layout(i, name, pshdr, 0, elfcpp::SHT_NULL));
	  out_sections[i] = reinterpret_cast<Output_section*>(2);
	  out_section_offsets[i] = invalid_address;
	  continue;
	}
      if (data_section == NULL)
	{
	  out_sections[i] = NULL;
	  out_section_offsets[i] = invalid_address;
	  continue;
	}

      Relocatable_relocs* rr = new Relocatable_relocs();
      this->set_relocatable_relocs(i, rr);

      Output_section* os = layout->layout_reloc(this, i, shdr, data_section,
						rr);
      out_sections[i] = os;
      out_section_offsets[i] = invalid_address;
    }

  // Handle the .eh_frame sections at the end.
  gold_assert(!is_pass_one || eh_frame_sections.empty());
  for (std::vector<unsigned int>::const_iterator p = eh_frame_sections.begin();
       p != eh_frame_sections.end();
       ++p)
    {
      unsigned int i = *p;
      const unsigned char* pshdr;
      pshdr = section_headers_data + i * This::shdr_size;
      typename This::Shdr shdr(pshdr);

      this->layout_eh_frame_section(layout,
				    symbols_data,
				    symbols_size,
				    symbol_names_data,
				    symbol_names_size,
				    i,
				    shdr,
				    reloc_shndx[i],
				    reloc_type[i]);
    }

  // When building a .gdb_index section, scan the .debug_info and
  // .debug_types sections.
  gold_assert(!is_pass_one
	      || (debug_info_sections.empty() && debug_types_sections.empty()));
  for (std::vector<unsigned int>::const_iterator p
	   = debug_info_sections.begin();
       p != debug_info_sections.end();
       ++p)
    {
      unsigned int i = *p;
      layout->add_to_gdb_index(false, this, symbols_data, symbols_size,
			       i, reloc_shndx[i], reloc_type[i]);
    }
  for (std::vector<unsigned int>::const_iterator p
	   = debug_types_sections.begin();
       p != debug_types_sections.end();
       ++p)
    {
      unsigned int i = *p;
      layout->add_to_gdb_index(true, this, symbols_data, symbols_size,
			       i, reloc_shndx[i], reloc_type[i]);
    }

  if (is_pass_two)
    {
      delete[] gc_sd->section_headers_data;
      delete[] gc_sd->section_names_data;
      delete[] gc_sd->symbols_data;
      delete[] gc_sd->symbol_names_data;
      this->set_symbols_data(NULL);
    }
  else
    {
      delete sd->section_headers;
      sd->section_headers = NULL;
      delete sd->section_names;
      sd->section_names = NULL;
    }
}

// Layout sections whose layout was deferred while waiting for
// input files from a plugin.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_layout_deferred_sections(Layout* layout)
{
  typename std::vector<Deferred_layout>::iterator deferred;

  for (deferred = this->deferred_layout_.begin();
       deferred != this->deferred_layout_.end();
       ++deferred)
    {
      typename This::Shdr shdr(deferred->shdr_data_);

      if (!parameters->options().relocatable()
	  && deferred->name_ == ".eh_frame"
	  && this->check_eh_frame_flags(&shdr))
	{
	  // Checking is_section_included is not reliable for
	  // .eh_frame sections, because they do not have an output
	  // section.  This is not a problem normally because we call
	  // layout_eh_frame_section unconditionally, but when
	  // deferring sections that is not true.  We don't want to
	  // keep all .eh_frame sections because that will cause us to
	  // keep all sections that they refer to, which is the wrong
	  // way around.  Instead, the eh_frame code will discard
	  // .eh_frame sections that refer to discarded sections.

	  // Reading the symbols again here may be slow.
	  Read_symbols_data sd;
	  this->read_symbols(&sd);
	  this->layout_eh_frame_section(layout,
					sd.symbols->data(),
					sd.symbols_size,
					sd.symbol_names->data(),
					sd.symbol_names_size,
					deferred->shndx_,
					shdr,
					deferred->reloc_shndx_,
					deferred->reloc_type_);
	  continue;
	}

      // If the section is not included, it is because the garbage collector
      // decided it is not needed.  Avoid reverting that decision.
      if (!this->is_section_included(deferred->shndx_))
	continue;

      this->layout_section(layout, deferred->shndx_, deferred->name_.c_str(),
			   shdr, deferred->reloc_shndx_,
			   deferred->reloc_type_);
    }

  this->deferred_layout_.clear();

  // Now handle the deferred relocation sections.

  Output_sections& out_sections(this->output_sections());
  std::vector<Address>& out_section_offsets(this->section_offsets());

  for (deferred = this->deferred_layout_relocs_.begin();
       deferred != this->deferred_layout_relocs_.end();
       ++deferred)
    {
      unsigned int shndx = deferred->shndx_;
      typename This::Shdr shdr(deferred->shdr_data_);
      unsigned int data_shndx = this->adjust_shndx(shdr.get_sh_info());

      Output_section* data_section = out_sections[data_shndx];
      if (data_section == NULL)
	{
	  out_sections[shndx] = NULL;
	  out_section_offsets[shndx] = invalid_address;
	  continue;
	}

      Relocatable_relocs* rr = new Relocatable_relocs();
      this->set_relocatable_relocs(shndx, rr);

      Output_section* os = layout->layout_reloc(this, shndx, shdr,
						data_section, rr);
      out_sections[shndx] = os;
      out_section_offsets[shndx] = invalid_address;
    }
}

// Add the symbols to the symbol table.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_add_symbols(Symbol_table* symtab,
						    Read_symbols_data* sd,
						    Layout*)
{
  if (sd->symbols == NULL)
    {
      gold_assert(sd->symbol_names == NULL);
      return;
    }

  const int sym_size = This::sym_size;
  size_t symcount = ((sd->symbols_size - sd->external_symbols_offset)
		     / sym_size);
  if (symcount * sym_size != sd->symbols_size - sd->external_symbols_offset)
    {
      this->error(_("size of symbols is not multiple of symbol size"));
      return;
    }

  this->symbols_.resize(symcount);

  const char* sym_names =
    reinterpret_cast<const char*>(sd->symbol_names->data());
  symtab->add_from_relobj(this,
			  sd->symbols->data() + sd->external_symbols_offset,
			  symcount, this->local_symbol_count_,
			  sym_names, sd->symbol_names_size,
			  &this->symbols_,
			  &this->defined_count_);

  delete sd->symbols;
  sd->symbols = NULL;
  delete sd->symbol_names;
  sd->symbol_names = NULL;
}

// Find out if this object, that is a member of a lib group, should be included
// in the link. We check every symbol defined by this object. If the symbol
// table has a strong undefined reference to that symbol, we have to include
// the object.

template<int size, bool big_endian>
Archive::Should_include
Sized_relobj_file<size, big_endian>::do_should_include_member(
    Symbol_table* symtab,
    Layout* layout,
    Read_symbols_data* sd,
    std::string* why)
{
  char* tmpbuf = NULL;
  size_t tmpbuflen = 0;
  const char* sym_names =
      reinterpret_cast<const char*>(sd->symbol_names->data());
  const unsigned char* syms =
      sd->symbols->data() + sd->external_symbols_offset;
  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;
  size_t symcount = ((sd->symbols_size - sd->external_symbols_offset)
			 / sym_size);

  const unsigned char* p = syms;

  for (size_t i = 0; i < symcount; ++i, p += sym_size)
    {
      elfcpp::Sym<size, big_endian> sym(p);
      unsigned int st_shndx = sym.get_st_shndx();
      if (st_shndx == elfcpp::SHN_UNDEF)
	continue;

      unsigned int st_name = sym.get_st_name();
      const char* name = sym_names + st_name;
      Symbol* symbol;
      Archive::Should_include t = Archive::should_include_member(symtab,
								 layout,
								 name,
								 &symbol, why,
								 &tmpbuf,
								 &tmpbuflen);
      if (t == Archive::SHOULD_INCLUDE_YES)
	{
	  if (tmpbuf != NULL)
	    free(tmpbuf);
	  return t;
	}
    }
  if (tmpbuf != NULL)
    free(tmpbuf);
  return Archive::SHOULD_INCLUDE_UNKNOWN;
}

// Iterate over global defined symbols, calling a visitor class V for each.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_for_all_global_symbols(
    Read_symbols_data* sd,
    Library_base::Symbol_visitor_base* v)
{
  const char* sym_names =
      reinterpret_cast<const char*>(sd->symbol_names->data());
  const unsigned char* syms =
      sd->symbols->data() + sd->external_symbols_offset;
  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;
  size_t symcount = ((sd->symbols_size - sd->external_symbols_offset)
		     / sym_size);
  const unsigned char* p = syms;

  for (size_t i = 0; i < symcount; ++i, p += sym_size)
    {
      elfcpp::Sym<size, big_endian> sym(p);
      if (sym.get_st_shndx() != elfcpp::SHN_UNDEF)
	v->visit(sym_names + sym.get_st_name());
    }
}

// Return whether the local symbol SYMNDX has a PLT offset.

template<int size, bool big_endian>
bool
Sized_relobj_file<size, big_endian>::local_has_plt_offset(
    unsigned int symndx) const
{
  typename Local_plt_offsets::const_iterator p =
    this->local_plt_offsets_.find(symndx);
  return p != this->local_plt_offsets_.end();
}

// Get the PLT offset of a local symbol.

template<int size, bool big_endian>
unsigned int
Sized_relobj_file<size, big_endian>::do_local_plt_offset(
    unsigned int symndx) const
{
  typename Local_plt_offsets::const_iterator p =
    this->local_plt_offsets_.find(symndx);
  gold_assert(p != this->local_plt_offsets_.end());
  return p->second;
}

// Set the PLT offset of a local symbol.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::set_local_plt_offset(
    unsigned int symndx, unsigned int plt_offset)
{
  std::pair<typename Local_plt_offsets::iterator, bool> ins =
    this->local_plt_offsets_.insert(std::make_pair(symndx, plt_offset));
  gold_assert(ins.second);
}

// First pass over the local symbols.  Here we add their names to
// *POOL and *DYNPOOL, and we store the symbol value in
// THIS->LOCAL_VALUES_.  This function is always called from a
// singleton thread.  This is followed by a call to
// finalize_local_symbols.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_count_local_symbols(Stringpool* pool,
							    Stringpool* dynpool)
{
  gold_assert(this->symtab_shndx_ != -1U);
  if (this->symtab_shndx_ == 0)
    {
      // This object has no symbols.  Weird but legal.
      return;
    }

  // Read the symbol table section header.
  const unsigned int symtab_shndx = this->symtab_shndx_;
  typename This::Shdr symtabshdr(this,
				 this->elf_file_.section_header(symtab_shndx));
  gold_assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);

  // Read the local symbols.
  const int sym_size = This::sym_size;
  const unsigned int loccount = this->local_symbol_count_;
  gold_assert(loccount == symtabshdr.get_sh_info());
  off_t locsize = loccount * sym_size;
  const unsigned char* psyms = this->get_view(symtabshdr.get_sh_offset(),
					      locsize, true, true);

  // Read the symbol names.
  const unsigned int strtab_shndx =
    this->adjust_shndx(symtabshdr.get_sh_link());
  section_size_type strtab_size;
  const unsigned char* pnamesu = this->section_contents(strtab_shndx,
							&strtab_size,
							true);
  const char* pnames = reinterpret_cast<const char*>(pnamesu);

  // Loop over the local symbols.

  const Output_sections& out_sections(this->output_sections());
  unsigned int shnum = this->shnum();
  unsigned int count = 0;
  unsigned int dyncount = 0;
  // Skip the first, dummy, symbol.
  psyms += sym_size;
  bool strip_all = parameters->options().strip_all();
  bool discard_all = parameters->options().discard_all();
  bool discard_locals = parameters->options().discard_locals();
  for (unsigned int i = 1; i < loccount; ++i, psyms += sym_size)
    {
      elfcpp::Sym<size, big_endian> sym(psyms);

      Symbol_value<size>& lv(this->local_values_[i]);

      bool is_ordinary;
      unsigned int shndx = this->adjust_sym_shndx(i, sym.get_st_shndx(),
						  &is_ordinary);
      lv.set_input_shndx(shndx, is_ordinary);

      if (sym.get_st_type() == elfcpp::STT_SECTION)
	lv.set_is_section_symbol();
      else if (sym.get_st_type() == elfcpp::STT_TLS)
	lv.set_is_tls_symbol();
      else if (sym.get_st_type() == elfcpp::STT_GNU_IFUNC)
	lv.set_is_ifunc_symbol();

      // Save the input symbol value for use in do_finalize_local_symbols().
      lv.set_input_value(sym.get_st_value());

      // Decide whether this symbol should go into the output file.

      if ((shndx < shnum && out_sections[shndx] == NULL)
	  || shndx == this->discarded_eh_frame_shndx_)
	{
	  lv.set_no_output_symtab_entry();
	  gold_assert(!lv.needs_output_dynsym_entry());
	  continue;
	}

      if (sym.get_st_type() == elfcpp::STT_SECTION
	  || !this->adjust_local_symbol(&lv))
	{
	  lv.set_no_output_symtab_entry();
	  gold_assert(!lv.needs_output_dynsym_entry());
	  continue;
	}

      if (sym.get_st_name() >= strtab_size)
	{
	  this->error(_("local symbol %u section name out of range: %u >= %u"),
		      i, sym.get_st_name(),
		      static_cast<unsigned int>(strtab_size));
	  lv.set_no_output_symtab_entry();
	  continue;
	}

      const char* name = pnames + sym.get_st_name();

      // If needed, add the symbol to the dynamic symbol table string pool.
      if (lv.needs_output_dynsym_entry())
	{
	  dynpool->add(name, true, NULL);
	  ++dyncount;
	}

      if (strip_all
	  || (discard_all && lv.may_be_discarded_from_output_symtab()))
	{
	  lv.set_no_output_symtab_entry();
	  continue;
	}

      // If --discard-locals option is used, discard all temporary local
      // symbols.  These symbols start with system-specific local label
      // prefixes, typically .L for ELF system.  We want to be compatible
      // with GNU ld so here we essentially use the same check in
      // bfd_is_local_label().  The code is different because we already
      // know that:
      //
      //   - the symbol is local and thus cannot have global or weak binding.
      //   - the symbol is not a section symbol.
      //   - the symbol has a name.
      //
      // We do not discard a symbol if it needs a dynamic symbol entry.
      if (discard_locals
	  && sym.get_st_type() != elfcpp::STT_FILE
	  && !lv.needs_output_dynsym_entry()
	  && lv.may_be_discarded_from_output_symtab()
	  && parameters->target().is_local_label_name(name))
	{
	  lv.set_no_output_symtab_entry();
	  continue;
	}

      // Discard the local symbol if -retain_symbols_file is specified
      // and the local symbol is not in that file.
      if (!parameters->options().should_retain_symbol(name))
	{
	  lv.set_no_output_symtab_entry();
	  continue;
	}

      // Add the symbol to the symbol table string pool.
      pool->add(name, true, NULL);
      ++count;
    }

  this->output_local_symbol_count_ = count;
  this->output_local_dynsym_count_ = dyncount;
}

// Compute the final value of a local symbol.

template<int size, bool big_endian>
typename Sized_relobj_file<size, big_endian>::Compute_final_local_value_status
Sized_relobj_file<size, big_endian>::compute_final_local_value_internal(
    unsigned int r_sym,
    const Symbol_value<size>* lv_in,
    Symbol_value<size>* lv_out,
    bool relocatable,
    const Output_sections& out_sections,
    const std::vector<Address>& out_offsets,
    const Symbol_table* symtab)
{
  // We are going to overwrite *LV_OUT, if it has a merged symbol value,
  // we may have a memory leak.
  gold_assert(lv_out->has_output_value());

  bool is_ordinary;
  unsigned int shndx = lv_in->input_shndx(&is_ordinary);

  // Set the output symbol value.

  if (!is_ordinary)
    {
      if (shndx == elfcpp::SHN_ABS || Symbol::is_common_shndx(shndx))
	lv_out->set_output_value(lv_in->input_value());
      else
	{
	  this->error(_("unknown section index %u for local symbol %u"),
		      shndx, r_sym);
	  lv_out->set_output_value(0);
	  return This::CFLV_ERROR;
	}
    }
  else
    {
      if (shndx >= this->shnum())
	{
	  this->error(_("local symbol %u section index %u out of range"),
		      r_sym, shndx);
	  lv_out->set_output_value(0);
	  return This::CFLV_ERROR;
	}

      Output_section* os = out_sections[shndx];
      Address secoffset = out_offsets[shndx];
      if (symtab->is_section_folded(this, shndx))
	{
	  gold_assert(os == NULL && secoffset == invalid_address);
	  // Get the os of the section it is folded onto.
	  Section_id folded = symtab->icf()->get_folded_section(this,
								shndx);
	  gold_assert(folded.first != NULL);
	  Sized_relobj_file<size, big_endian>* folded_obj = reinterpret_cast
	    <Sized_relobj_file<size, big_endian>*>(folded.first);
	  os = folded_obj->output_section(folded.second);
	  gold_assert(os != NULL);
	  secoffset = folded_obj->get_output_section_offset(folded.second);

	  // This could be a relaxed input section.
	  if (secoffset == invalid_address)
	    {
	      const Output_relaxed_input_section* relaxed_section =
		os->find_relaxed_input_section(folded_obj, folded.second);
	      gold_assert(relaxed_section != NULL);
	      secoffset = relaxed_section->address() - os->address();
	    }
	}

      if (os == NULL)
	{
	  // This local symbol belongs to a section we are discarding.
	  // In some cases when applying relocations later, we will
	  // attempt to match it to the corresponding kept section,
	  // so we leave the input value unchanged here.
	  return This::CFLV_DISCARDED;
	}
      else if (secoffset == invalid_address)
	{
	  uint64_t start;

	  // This is a SHF_MERGE section or one which otherwise
	  // requires special handling.
	  if (shndx == this->discarded_eh_frame_shndx_)
	    {
	      // This local symbol belongs to a discarded .eh_frame
	      // section.  Just treat it like the case in which
	      // os == NULL above.
	      gold_assert(this->has_eh_frame_);
	      return This::CFLV_DISCARDED;
	    }
	  else if (!lv_in->is_section_symbol())
	    {
	      // This is not a section symbol.  We can determine
	      // the final value now.
	      lv_out->set_output_value(
		  os->output_address(this, shndx, lv_in->input_value()));
	    }
	  else if (!os->find_starting_output_address(this, shndx, &start))
	    {
	      // This is a section symbol, but apparently not one in a
	      // merged section.  First check to see if this is a relaxed
	      // input section.  If so, use its address.  Otherwise just
	      // use the start of the output section.  This happens with
	      // relocatable links when the input object has section
	      // symbols for arbitrary non-merge sections.
	      const Output_section_data* posd =
		os->find_relaxed_input_section(this, shndx);
	      if (posd != NULL)
		{
		  Address relocatable_link_adjustment =
		    relocatable ? os->address() : 0;
		  lv_out->set_output_value(posd->address()
					   - relocatable_link_adjustment);
		}
	      else
		lv_out->set_output_value(os->address());
	    }
	  else
	    {
	      // We have to consider the addend to determine the
	      // value to use in a relocation.  START is the start
	      // of this input section.  If we are doing a relocatable
	      // link, use offset from start output section instead of
	      // address.
	      Address adjusted_start =
		relocatable ? start - os->address() : start;
	      Merged_symbol_value<size>* msv =
		new Merged_symbol_value<size>(lv_in->input_value(),
					      adjusted_start);
	      lv_out->set_merged_symbol_value(msv);
	    }
	}
      else if (lv_in->is_tls_symbol())
	lv_out->set_output_value(os->tls_offset()
				 + secoffset
				 + lv_in->input_value());
      else
	lv_out->set_output_value((relocatable ? 0 : os->address())
				 + secoffset
				 + lv_in->input_value());
    }
  return This::CFLV_OK;
}

// Compute final local symbol value.  R_SYM is the index of a local
// symbol in symbol table.  LV points to a symbol value, which is
// expected to hold the input value and to be over-written by the
// final value.  SYMTAB points to a symbol table.  Some targets may want
// to know would-be-finalized local symbol values in relaxation.
// Hence we provide this method.  Since this method updates *LV, a
// callee should make a copy of the original local symbol value and
// use the copy instead of modifying an object's local symbols before
// everything is finalized.  The caller should also free up any allocated
// memory in the return value in *LV.
template<int size, bool big_endian>
typename Sized_relobj_file<size, big_endian>::Compute_final_local_value_status
Sized_relobj_file<size, big_endian>::compute_final_local_value(
    unsigned int r_sym,
    const Symbol_value<size>* lv_in,
    Symbol_value<size>* lv_out,
    const Symbol_table* symtab)
{
  // This is just a wrapper of compute_final_local_value_internal.
  const bool relocatable = parameters->options().relocatable();
  const Output_sections& out_sections(this->output_sections());
  const std::vector<Address>& out_offsets(this->section_offsets());
  return this->compute_final_local_value_internal(r_sym, lv_in, lv_out,
						  relocatable, out_sections,
						  out_offsets, symtab);
}

// Finalize the local symbols.  Here we set the final value in
// THIS->LOCAL_VALUES_ and set their output symbol table indexes.
// This function is always called from a singleton thread.  The actual
// output of the local symbols will occur in a separate task.

template<int size, bool big_endian>
unsigned int
Sized_relobj_file<size, big_endian>::do_finalize_local_symbols(
    unsigned int index,
    off_t off,
    Symbol_table* symtab)
{
  gold_assert(off == static_cast<off_t>(align_address(off, size >> 3)));

  const unsigned int loccount = this->local_symbol_count_;
  this->local_symbol_offset_ = off;

  const bool relocatable = parameters->options().relocatable();
  const Output_sections& out_sections(this->output_sections());
  const std::vector<Address>& out_offsets(this->section_offsets());

  for (unsigned int i = 1; i < loccount; ++i)
    {
      Symbol_value<size>* lv = &this->local_values_[i];

      Compute_final_local_value_status cflv_status =
	this->compute_final_local_value_internal(i, lv, lv, relocatable,
						 out_sections, out_offsets,
						 symtab);
      switch (cflv_status)
	{
	case CFLV_OK:
	  if (!lv->is_output_symtab_index_set())
	    {
	      lv->set_output_symtab_index(index);
	      ++index;
	    }
	  break;
	case CFLV_DISCARDED:
	case CFLV_ERROR:
	  // Do nothing.
	  break;
	default:
	  gold_unreachable();
	}
    }
  return index;
}

// Set the output dynamic symbol table indexes for the local variables.

template<int size, bool big_endian>
unsigned int
Sized_relobj_file<size, big_endian>::do_set_local_dynsym_indexes(
    unsigned int index)
{
  const unsigned int loccount = this->local_symbol_count_;
  for (unsigned int i = 1; i < loccount; ++i)
    {
      Symbol_value<size>& lv(this->local_values_[i]);
      if (lv.needs_output_dynsym_entry())
	{
	  lv.set_output_dynsym_index(index);
	  ++index;
	}
    }
  return index;
}

// Set the offset where local dynamic symbol information will be stored.
// Returns the count of local symbols contributed to the symbol table by
// this object.

template<int size, bool big_endian>
unsigned int
Sized_relobj_file<size, big_endian>::do_set_local_dynsym_offset(off_t off)
{
  gold_assert(off == static_cast<off_t>(align_address(off, size >> 3)));
  this->local_dynsym_offset_ = off;
  return this->output_local_dynsym_count_;
}

// If Symbols_data is not NULL get the section flags from here otherwise
// get it from the file.

template<int size, bool big_endian>
uint64_t
Sized_relobj_file<size, big_endian>::do_section_flags(unsigned int shndx)
{
  Symbols_data* sd = this->get_symbols_data();
  if (sd != NULL)
    {
      const unsigned char* pshdrs = sd->section_headers_data
				    + This::shdr_size * shndx;
      typename This::Shdr shdr(pshdrs);
      return shdr.get_sh_flags();
    }
  // If sd is NULL, read the section header from the file.
  return this->elf_file_.section_flags(shndx);
}

// Get the section's ent size from Symbols_data.  Called by get_section_contents
// in icf.cc

template<int size, bool big_endian>
uint64_t
Sized_relobj_file<size, big_endian>::do_section_entsize(unsigned int shndx)
{
  Symbols_data* sd = this->get_symbols_data();
  gold_assert(sd != NULL);

  const unsigned char* pshdrs = sd->section_headers_data
				+ This::shdr_size * shndx;
  typename This::Shdr shdr(pshdrs);
  return shdr.get_sh_entsize();
}

// Write out the local symbols.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::write_local_symbols(
    Output_file* of,
    const Stringpool* sympool,
    const Stringpool* dynpool,
    Output_symtab_xindex* symtab_xindex,
    Output_symtab_xindex* dynsym_xindex,
    off_t symtab_off)
{
  const bool strip_all = parameters->options().strip_all();
  if (strip_all)
    {
      if (this->output_local_dynsym_count_ == 0)
	return;
      this->output_local_symbol_count_ = 0;
    }

  gold_assert(this->symtab_shndx_ != -1U);
  if (this->symtab_shndx_ == 0)
    {
      // This object has no symbols.  Weird but legal.
      return;
    }

  // Read the symbol table section header.
  const unsigned int symtab_shndx = this->symtab_shndx_;
  typename This::Shdr symtabshdr(this,
				 this->elf_file_.section_header(symtab_shndx));
  gold_assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);
  const unsigned int loccount = this->local_symbol_count_;
  gold_assert(loccount == symtabshdr.get_sh_info());

  // Read the local symbols.
  const int sym_size = This::sym_size;
  off_t locsize = loccount * sym_size;
  const unsigned char* psyms = this->get_view(symtabshdr.get_sh_offset(),
					      locsize, true, false);

  // Read the symbol names.
  const unsigned int strtab_shndx =
    this->adjust_shndx(symtabshdr.get_sh_link());
  section_size_type strtab_size;
  const unsigned char* pnamesu = this->section_contents(strtab_shndx,
							&strtab_size,
							false);
  const char* pnames = reinterpret_cast<const char*>(pnamesu);

  // Get views into the output file for the portions of the symbol table
  // and the dynamic symbol table that we will be writing.
  off_t output_size = this->output_local_symbol_count_ * sym_size;
  unsigned char* oview = NULL;
  if (output_size > 0)
    oview = of->get_output_view(symtab_off + this->local_symbol_offset_,
				output_size);

  off_t dyn_output_size = this->output_local_dynsym_count_ * sym_size;
  unsigned char* dyn_oview = NULL;
  if (dyn_output_size > 0)
    dyn_oview = of->get_output_view(this->local_dynsym_offset_,
				    dyn_output_size);

  const Output_sections out_sections(this->output_sections());

  gold_assert(this->local_values_.size() == loccount);

  unsigned char* ov = oview;
  unsigned char* dyn_ov = dyn_oview;
  psyms += sym_size;
  for (unsigned int i = 1; i < loccount; ++i, psyms += sym_size)
    {
      elfcpp::Sym<size, big_endian> isym(psyms);

      Symbol_value<size>& lv(this->local_values_[i]);

      bool is_ordinary;
      unsigned int st_shndx = this->adjust_sym_shndx(i, isym.get_st_shndx(),
						     &is_ordinary);
      if (is_ordinary)
	{
	  gold_assert(st_shndx < out_sections.size());
	  if (out_sections[st_shndx] == NULL)
	    continue;
	  st_shndx = out_sections[st_shndx]->out_shndx();
	  if (st_shndx >= elfcpp::SHN_LORESERVE)
	    {
	      if (lv.has_output_symtab_entry())
		symtab_xindex->add(lv.output_symtab_index(), st_shndx);
	      if (lv.has_output_dynsym_entry())
		dynsym_xindex->add(lv.output_dynsym_index(), st_shndx);
	      st_shndx = elfcpp::SHN_XINDEX;
	    }
	}

      // Write the symbol to the output symbol table.
      if (lv.has_output_symtab_entry())
	{
	  elfcpp::Sym_write<size, big_endian> osym(ov);

	  gold_assert(isym.get_st_name() < strtab_size);
	  const char* name = pnames + isym.get_st_name();
	  osym.put_st_name(sympool->get_offset(name));
	  osym.put_st_value(this->local_values_[i].value(this, 0));
	  osym.put_st_size(isym.get_st_size());
	  osym.put_st_info(isym.get_st_info());
	  osym.put_st_other(isym.get_st_other());
	  osym.put_st_shndx(st_shndx);

	  ov += sym_size;
	}

      // Write the symbol to the output dynamic symbol table.
      if (lv.has_output_dynsym_entry())
	{
	  gold_assert(dyn_ov < dyn_oview + dyn_output_size);
	  elfcpp::Sym_write<size, big_endian> osym(dyn_ov);

	  gold_assert(isym.get_st_name() < strtab_size);
	  const char* name = pnames + isym.get_st_name();
	  osym.put_st_name(dynpool->get_offset(name));
	  osym.put_st_value(this->local_values_[i].value(this, 0));
	  osym.put_st_size(isym.get_st_size());
	  osym.put_st_info(isym.get_st_info());
	  osym.put_st_other(isym.get_st_other());
	  osym.put_st_shndx(st_shndx);

	  dyn_ov += sym_size;
	}
    }


  if (output_size > 0)
    {
      gold_assert(ov - oview == output_size);
      of->write_output_view(symtab_off + this->local_symbol_offset_,
			    output_size, oview);
    }

  if (dyn_output_size > 0)
    {
      gold_assert(dyn_ov - dyn_oview == dyn_output_size);
      of->write_output_view(this->local_dynsym_offset_, dyn_output_size,
			    dyn_oview);
    }
}

// Set *INFO to symbolic information about the offset OFFSET in the
// section SHNDX.  Return true if we found something, false if we
// found nothing.

template<int size, bool big_endian>
bool
Sized_relobj_file<size, big_endian>::get_symbol_location_info(
    unsigned int shndx,
    off_t offset,
    Symbol_location_info* info)
{
  if (this->symtab_shndx_ == 0)
    return false;

  section_size_type symbols_size;
  const unsigned char* symbols = this->section_contents(this->symtab_shndx_,
							&symbols_size,
							false);

  unsigned int symbol_names_shndx =
    this->adjust_shndx(this->section_link(this->symtab_shndx_));
  section_size_type names_size;
  const unsigned char* symbol_names_u =
    this->section_contents(symbol_names_shndx, &names_size, false);
  const char* symbol_names = reinterpret_cast<const char*>(symbol_names_u);

  const int sym_size = This::sym_size;
  const size_t count = symbols_size / sym_size;

  const unsigned char* p = symbols;
  for (size_t i = 0; i < count; ++i, p += sym_size)
    {
      elfcpp::Sym<size, big_endian> sym(p);

      if (sym.get_st_type() == elfcpp::STT_FILE)
	{
	  if (sym.get_st_name() >= names_size)
	    info->source_file = "(invalid)";
	  else
	    info->source_file = symbol_names + sym.get_st_name();
	  continue;
	}

      bool is_ordinary;
      unsigned int st_shndx = this->adjust_sym_shndx(i, sym.get_st_shndx(),
						     &is_ordinary);
      if (is_ordinary
	  && st_shndx == shndx
	  && static_cast<off_t>(sym.get_st_value()) <= offset
	  && (static_cast<off_t>(sym.get_st_value() + sym.get_st_size())
	      > offset))
	{
	  info->enclosing_symbol_type = sym.get_st_type();
	  if (sym.get_st_name() > names_size)
	    info->enclosing_symbol_name = "(invalid)";
	  else
	    {
	      info->enclosing_symbol_name = symbol_names + sym.get_st_name();
	      if (parameters->options().do_demangle())
		{
		  char* demangled_name = cplus_demangle(
		      info->enclosing_symbol_name.c_str(),
		      DMGL_ANSI | DMGL_PARAMS);
		  if (demangled_name != NULL)
		    {
		      info->enclosing_symbol_name.assign(demangled_name);
		      free(demangled_name);
		    }
		}
	    }
	  return true;
	}
    }

  return false;
}

// Look for a kept section corresponding to the given discarded section,
// and return its output address.  This is used only for relocations in
// debugging sections.  If we can't find the kept section, return 0.

template<int size, bool big_endian>
typename Sized_relobj_file<size, big_endian>::Address
Sized_relobj_file<size, big_endian>::map_to_kept_section(
    unsigned int shndx,
    bool* found) const
{
  Relobj* kept_object;
  unsigned int kept_shndx;
  if (this->get_kept_comdat_section(shndx, &kept_object, &kept_shndx))
    {
      Sized_relobj_file<size, big_endian>* kept_relobj =
	static_cast<Sized_relobj_file<size, big_endian>*>(kept_object);
      Output_section* os = kept_relobj->output_section(kept_shndx);
      Address offset = kept_relobj->get_output_section_offset(kept_shndx);
      if (os != NULL && offset != invalid_address)
	{
	  *found = true;
	  return os->address() + offset;
	}
    }
  *found = false;
  return 0;
}

// Get symbol counts.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_get_global_symbol_counts(
    const Symbol_table*,
    size_t* defined,
    size_t* used) const
{
  *defined = this->defined_count_;
  size_t count = 0;
  for (typename Symbols::const_iterator p = this->symbols_.begin();
       p != this->symbols_.end();
       ++p)
    if (*p != NULL
	&& (*p)->source() == Symbol::FROM_OBJECT
	&& (*p)->object() == this
	&& (*p)->is_defined())
      ++count;
  *used = count;
}

// Return a view of the decompressed contents of a section.  Set *PLEN
// to the size.  Set *IS_NEW to true if the contents need to be freed
// by the caller.

template<int size, bool big_endian>
const unsigned char*
Sized_relobj_file<size, big_endian>::do_decompressed_section_contents(
    unsigned int shndx,
    section_size_type* plen,
    bool* is_new)
{
  section_size_type buffer_size;
  const unsigned char* buffer = this->do_section_contents(shndx, &buffer_size,
							  false);

  if (this->compressed_sections_ == NULL)
    {
      *plen = buffer_size;
      *is_new = false;
      return buffer;
    }

  Compressed_section_map::const_iterator p =
      this->compressed_sections_->find(shndx);
  if (p == this->compressed_sections_->end())
    {
      *plen = buffer_size;
      *is_new = false;
      return buffer;
    }

  section_size_type uncompressed_size = p->second.size;
  if (p->second.contents != NULL)
    {
      *plen = uncompressed_size;
      *is_new = false;
      return p->second.contents;
    }

  unsigned char* uncompressed_data = new unsigned char[uncompressed_size];
  if (!decompress_input_section(buffer,
				buffer_size,
				uncompressed_data,
				uncompressed_size))
    this->error(_("could not decompress section %s"),
		this->do_section_name(shndx).c_str());

  // We could cache the results in p->second.contents and store
  // false in *IS_NEW, but build_compressed_section_map() would
  // have done so if it had expected it to be profitable.  If
  // we reach this point, we expect to need the contents only
  // once in this pass.
  *plen = uncompressed_size;
  *is_new = true;
  return uncompressed_data;
}

// Discard any buffers of uncompressed sections.  This is done
// at the end of the Add_symbols task.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_discard_decompressed_sections()
{
  if (this->compressed_sections_ == NULL)
    return;

  for (Compressed_section_map::iterator p = this->compressed_sections_->begin();
       p != this->compressed_sections_->end();
       ++p)
    {
      if (p->second.contents != NULL)
	{
	  delete[] p->second.contents;
	  p->second.contents = NULL;
	}
    }
}

// Input_objects methods.

// Add a regular relocatable object to the list.  Return false if this
// object should be ignored.

bool
Input_objects::add_object(Object* obj)
{
  // Print the filename if the -t/--trace option is selected.
  if (parameters->options().trace())
    gold_info("%s", obj->name().c_str());

  if (!obj->is_dynamic())
    this->relobj_list_.push_back(static_cast<Relobj*>(obj));
  else
    {
      // See if this is a duplicate SONAME.
      Dynobj* dynobj = static_cast<Dynobj*>(obj);
      const char* soname = dynobj->soname();

      std::pair<Unordered_set<std::string>::iterator, bool> ins =
	this->sonames_.insert(soname);
      if (!ins.second)
	{
	  // We have already seen a dynamic object with this soname.
	  return false;
	}

      this->dynobj_list_.push_back(dynobj);
    }

  // Add this object to the cross-referencer if requested.
  if (parameters->options().user_set_print_symbol_counts()
      || parameters->options().cref())
    {
      if (this->cref_ == NULL)
	this->cref_ = new Cref();
      this->cref_->add_object(obj);
    }

  return true;
}

// For each dynamic object, record whether we've seen all of its
// explicit dependencies.

void
Input_objects::check_dynamic_dependencies() const
{
  bool issued_copy_dt_needed_error = false;
  for (Dynobj_list::const_iterator p = this->dynobj_list_.begin();
       p != this->dynobj_list_.end();
       ++p)
    {
      const Dynobj::Needed& needed((*p)->needed());
      bool found_all = true;
      Dynobj::Needed::const_iterator pneeded;
      for (pneeded = needed.begin(); pneeded != needed.end(); ++pneeded)
	{
	  if (this->sonames_.find(*pneeded) == this->sonames_.end())
	    {
	      found_all = false;
	      break;
	    }
	}
      (*p)->set_has_unknown_needed_entries(!found_all);

      // --copy-dt-needed-entries aka --add-needed is a GNU ld option
      // that gold does not support.  However, they cause no trouble
      // unless there is a DT_NEEDED entry that we don't know about;
      // warn only in that case.
      if (!found_all
	  && !issued_copy_dt_needed_error
	  && (parameters->options().copy_dt_needed_entries()
	      || parameters->options().add_needed()))
	{
	  const char* optname;
	  if (parameters->options().copy_dt_needed_entries())
	    optname = "--copy-dt-needed-entries";
	  else
	    optname = "--add-needed";
	  gold_error(_("%s is not supported but is required for %s in %s"),
		     optname, (*pneeded).c_str(), (*p)->name().c_str());
	  issued_copy_dt_needed_error = true;
	}
    }
}

// Start processing an archive.

void
Input_objects::archive_start(Archive* archive)
{
  if (parameters->options().user_set_print_symbol_counts()
      || parameters->options().cref())
    {
      if (this->cref_ == NULL)
	this->cref_ = new Cref();
      this->cref_->add_archive_start(archive);
    }
}

// Stop processing an archive.

void
Input_objects::archive_stop(Archive* archive)
{
  if (parameters->options().user_set_print_symbol_counts()
      || parameters->options().cref())
    this->cref_->add_archive_stop(archive);
}

// Print symbol counts

void
Input_objects::print_symbol_counts(const Symbol_table* symtab) const
{
  if (parameters->options().user_set_print_symbol_counts()
      && this->cref_ != NULL)
    this->cref_->print_symbol_counts(symtab);
}

// Print a cross reference table.

void
Input_objects::print_cref(const Symbol_table* symtab, FILE* f) const
{
  if (parameters->options().cref() && this->cref_ != NULL)
    this->cref_->print_cref(symtab, f);
}

// Relocate_info methods.

// Return a string describing the location of a relocation when file
// and lineno information is not available.  This is only used in
// error messages.

template<int size, bool big_endian>
std::string
Relocate_info<size, big_endian>::location(size_t, off_t offset) const
{
  Sized_dwarf_line_info<size, big_endian> line_info(this->object);
  std::string ret = line_info.addr2line(this->data_shndx, offset, NULL);
  if (!ret.empty())
    return ret;

  ret = this->object->name();

  Symbol_location_info info;
  if (this->object->get_symbol_location_info(this->data_shndx, offset, &info))
    {
      if (!info.source_file.empty())
	{
	  ret += ":";
	  ret += info.source_file;
	}
      ret += ":";
      if (info.enclosing_symbol_type == elfcpp::STT_FUNC)
	ret += _("function ");
      ret += info.enclosing_symbol_name;
      return ret;
    }

  ret += "(";
  ret += this->object->section_name(this->data_shndx);
  char buf[100];
  snprintf(buf, sizeof buf, "+0x%lx)", static_cast<long>(offset));
  ret += buf;
  return ret;
}

} // End namespace gold.

namespace
{

using namespace gold;

// Read an ELF file with the header and return the appropriate
// instance of Object.

template<int size, bool big_endian>
Object*
make_elf_sized_object(const std::string& name, Input_file* input_file,
		      off_t offset, const elfcpp::Ehdr<size, big_endian>& ehdr,
		      bool* punconfigured)
{
  Target* target = select_target(input_file, offset,
				 ehdr.get_e_machine(), size, big_endian,
				 ehdr.get_e_ident()[elfcpp::EI_OSABI],
				 ehdr.get_e_ident()[elfcpp::EI_ABIVERSION]);
  if (target == NULL)
    gold_fatal(_("%s: unsupported ELF machine number %d"),
	       name.c_str(), ehdr.get_e_machine());

  if (!parameters->target_valid())
    set_parameters_target(target);
  else if (target != &parameters->target())
    {
      if (punconfigured != NULL)
	*punconfigured = true;
      else
	gold_error(_("%s: incompatible target"), name.c_str());
      return NULL;
    }

  return target->make_elf_object<size, big_endian>(name, input_file, offset,
						   ehdr);
}

} // End anonymous namespace.

namespace gold
{

// Return whether INPUT_FILE is an ELF object.

bool
is_elf_object(Input_file* input_file, off_t offset,
	      const unsigned char** start, int* read_size)
{
  off_t filesize = input_file->file().filesize();
  int want = elfcpp::Elf_recognizer::max_header_size;
  if (filesize - offset < want)
    want = filesize - offset;

  const unsigned char* p = input_file->file().get_view(offset, 0, want,
						       true, false);
  *start = p;
  *read_size = want;

  return elfcpp::Elf_recognizer::is_elf_file(p, want);
}

// Read an ELF file and return the appropriate instance of Object.

Object*
make_elf_object(const std::string& name, Input_file* input_file, off_t offset,
		const unsigned char* p, section_offset_type bytes,
		bool* punconfigured)
{
  if (punconfigured != NULL)
    *punconfigured = false;

  std::string error;
  bool big_endian = false;
  int size = 0;
  if (!elfcpp::Elf_recognizer::is_valid_header(p, bytes, &size,
					       &big_endian, &error))
    {
      gold_error(_("%s: %s"), name.c_str(), error.c_str());
      return NULL;
    }

  if (size == 32)
    {
      if (big_endian)
	{
#ifdef HAVE_TARGET_32_BIG
	  elfcpp::Ehdr<32, true> ehdr(p);
	  return make_elf_sized_object<32, true>(name, input_file,
						 offset, ehdr, punconfigured);
#else
	  if (punconfigured != NULL)
	    *punconfigured = true;
	  else
	    gold_error(_("%s: not configured to support "
			 "32-bit big-endian object"),
		       name.c_str());
	  return NULL;
#endif
	}
      else
	{
#ifdef HAVE_TARGET_32_LITTLE
	  elfcpp::Ehdr<32, false> ehdr(p);
	  return make_elf_sized_object<32, false>(name, input_file,
						  offset, ehdr, punconfigured);
#else
	  if (punconfigured != NULL)
	    *punconfigured = true;
	  else
	    gold_error(_("%s: not configured to support "
			 "32-bit little-endian object"),
		       name.c_str());
	  return NULL;
#endif
	}
    }
  else if (size == 64)
    {
      if (big_endian)
	{
#ifdef HAVE_TARGET_64_BIG
	  elfcpp::Ehdr<64, true> ehdr(p);
	  return make_elf_sized_object<64, true>(name, input_file,
						 offset, ehdr, punconfigured);
#else
	  if (punconfigured != NULL)
	    *punconfigured = true;
	  else
	    gold_error(_("%s: not configured to support "
			 "64-bit big-endian object"),
		       name.c_str());
	  return NULL;
#endif
	}
      else
	{
#ifdef HAVE_TARGET_64_LITTLE
	  elfcpp::Ehdr<64, false> ehdr(p);
	  return make_elf_sized_object<64, false>(name, input_file,
						  offset, ehdr, punconfigured);
#else
	  if (punconfigured != NULL)
	    *punconfigured = true;
	  else
	    gold_error(_("%s: not configured to support "
			 "64-bit little-endian object"),
		       name.c_str());
	  return NULL;
#endif
	}
    }
  else
    gold_unreachable();
}

// Instantiate the templates we need.

#ifdef HAVE_TARGET_32_LITTLE
template
void
Object::read_section_data<32, false>(elfcpp::Elf_file<32, false, Object>*,
				     Read_symbols_data*);
template
const unsigned char*
Object::find_shdr<32,false>(const unsigned char*, const char*, const char*,
			    section_size_type, const unsigned char*) const;
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Object::read_section_data<32, true>(elfcpp::Elf_file<32, true, Object>*,
				    Read_symbols_data*);
template
const unsigned char*
Object::find_shdr<32,true>(const unsigned char*, const char*, const char*,
			   section_size_type, const unsigned char*) const;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Object::read_section_data<64, false>(elfcpp::Elf_file<64, false, Object>*,
				     Read_symbols_data*);
template
const unsigned char*
Object::find_shdr<64,false>(const unsigned char*, const char*, const char*,
			    section_size_type, const unsigned char*) const;
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Object::read_section_data<64, true>(elfcpp::Elf_file<64, true, Object>*,
				    Read_symbols_data*);
template
const unsigned char*
Object::find_shdr<64,true>(const unsigned char*, const char*, const char*,
			   section_size_type, const unsigned char*) const;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
class Sized_relobj<32, false>;

template
class Sized_relobj_file<32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Sized_relobj<32, true>;

template
class Sized_relobj_file<32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Sized_relobj<64, false>;

template
class Sized_relobj_file<64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Sized_relobj<64, true>;

template
class Sized_relobj_file<64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
struct Relocate_info<32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
struct Relocate_info<32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
struct Relocate_info<64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
struct Relocate_info<64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Xindex::initialize_symtab_xindex<32, false>(Object*, unsigned int);

template
void
Xindex::read_symtab_xindex<32, false>(Object*, unsigned int,
				      const unsigned char*);
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Xindex::initialize_symtab_xindex<32, true>(Object*, unsigned int);

template
void
Xindex::read_symtab_xindex<32, true>(Object*, unsigned int,
				     const unsigned char*);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Xindex::initialize_symtab_xindex<64, false>(Object*, unsigned int);

template
void
Xindex::read_symtab_xindex<64, false>(Object*, unsigned int,
				      const unsigned char*);
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Xindex::initialize_symtab_xindex<64, true>(Object*, unsigned int);

template
void
Xindex::read_symtab_xindex<64, true>(Object*, unsigned int,
				     const unsigned char*);
#endif

} // End namespace gold.
@


1.164
log
@gold/
    	* object.cc (Sized_relobj_file::get_symbol_location_info): Set
    	type of enclosing symbol.
    	(Relocate_info::location): Check symbol type when describing symbol.
    	* object.h (Symbol_location_info): Remove unused line_number;
    	add enclosing_symbol_type.
    	* testsuite/debug_msg.sh: Adjust expected output.
@
text
@d392 17
d3237 3
d3245 3
d3253 3
d3261 3
@


1.163
log
@	GCC PR c++/56840
	* object.cc (do_layout_deferred_sections): Handle .eh_frame
	sections before checking whether they are included in the link.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
d2690 1
d3000 4
a3003 6
      size_t len = info.enclosing_symbol_name.length() + 100;
      char* buf = new char[len];
      snprintf(buf, len, _(":function %s"),
	       info.enclosing_symbol_name.c_str());
      ret += buf;
      delete[] buf;
@


1.162
log
@	* gold.cc (queue_middle_tasks): Move detect_odr_violations..
	* layout.cc (Layout_task_runner::run): ..to here.
	* symtab.h (struct Symbol_location): Extract from..
	(class Symbol_table): ..here.
	* symtab.cc (Symbol_table::linenos_from_loc): Invoke function_location.
	* target.h (class Target): Add function_location and
	do_function_location functions.
	(class Sized_target): Add do_function_location.
	* object.h (class Sized_relobj_file): Move find_shdr..
	(class Object): ..to here.
	* object.cc: Likewise.  Update to suit.  Instantiate.
	(Sized_relobj_file::find_eh_frame): Update find_shdr call.
	* powerpc.cc (class Powerpc_dynobj): New.
	(Target_powerpc::do_function_location): New function.
	(Powerpc_relobj::do_find_special_sections): Update find_shdr call.
	(Powerpc_dynobj::do_read_symbols): New function.
	(Target_powerpc::do_make_elf_object): Make a Powerpc_dynobj.
@
text
@a1817 4
      // If the section is not included, it is because the garbage collector
      // decided it is not needed.  Avoid reverting that decision.
      if (!this->is_section_included(deferred->shndx_))
	continue;
d1819 14
a1832 8
      if (parameters->options().relocatable()
	  || deferred->name_ != ".eh_frame"
	  || !this->check_eh_frame_flags(&shdr))
	this->layout_section(layout, deferred->shndx_, deferred->name_.c_str(),
			     shdr, deferred->reloc_shndx_,
			     deferred->reloc_type_);
      else
	{
d1845 1
d1847 9
@


1.161
log
@	PR gold/14727
	* object.cc (Relobj::is_section_name_included): Also match
	.sdata personality section.
@
text
@d520 1
a520 1
Sized_relobj_file<size, big_endian>::find_shdr(
d527 1
d529 1
a529 1
  const unsigned char* hdr_end = pshdrs + This::shdr_size * shnum;
d537 1
a537 1
	  typename This::Shdr shdr(hdr);
d561 1
a561 1
      hdr += This::shdr_size;
d564 1
a564 1
	  typename This::Shdr shdr(hdr);
d567 1
a567 1
	  hdr += This::shdr_size;
d589 2
a590 1
      s = this->find_shdr(pshdrs, ".eh_frame", names, names_size, s);
d3168 4
d3179 4
d3190 4
d3201 4
@


1.160
log
@	* object.h (Sized_relobj_file::adjust_local_symbol,
	do_adjust_local_symbol): New functions.
	* object.cc (Sized_relobj_file::do_count_local_symbols): Use the above.
	* powerpc.cc (Powerpc_relobj::do_adjust_local_symbol): New function.
	(Powerpc_relobj::scan_opd_relocs): Warn on unexpected opd relocs
	and irregular opd entry spacing.
	(Powerpc_relobj::do_read_relocs): Add opd size checks.
	(Global_symbol_visitor_opd): New functor.
	(Target_powerpc::do_finalize_sections): Omit global symbols defined
	on deleted opd entries.
@
text
@d334 3
a336 1
	  &&  strstr(name, "personality"))
@


1.159
log
@2012-09-06  Cary Coutant  <ccoutant@@google.com>

gold/
	* dwarf_reader.cc (Dwarf_die::read_attributes): Add
	DW_FORM_GNU_addr_index and DW_FORM_GNU_str_index.
	(Dwarf_die::skip_attributes): Likewise.
	* object.cc (Read_symbols_data::~Read_symbols_data): Update comment.
	* testsuite/gdb_index_test.cc (inline_func_1): New function.
	(main): Call it.
	* testsuite/gdb_index_test_comm.sh: Check index for inline function.
@
text
@d2113 2
a2114 1
      if (sym.get_st_type() == elfcpp::STT_SECTION)
@


1.158
log
@Patch adds support to allow plugins to map selected subset of sections to unique
segments.


2012-08-24  Sriraman Tallam  <tmsriram@@google.com>

	* gold.cc (queue_middle_tasks): Call layout again when unique
	segments for sections is desired.
	* layout.cc (Layout::Layout): Initialize new members.
	(Layout::get_output_section_flags): New function.
	(Layout::choose_output_section): Call get_output_section_flags.
	(Layout::layout): Make output section for mapping to a unique segment.
	(Layout::insert_section_segment_map): New function.
	(Layout::attach_allocated_section_to_segment): Make unique segment for
	output sections marked so.
	(Layout::segment_precedes): Check for unique segments when sorting.
	* layout.h (Layout::Unique_segment_info): New struct.
	(Layout::Section_segment_map): New typedef.
	(Layout::insert_section_segment_map): New function.
	(Layout::get_output_section_flags): New function.
	(Layout::is_unique_segment_for_sections_specified): New function.
	(Layout::set_unique_segment_for_sections_specified): New function.
	(Layout::unique_segment_for_sections_specified_): New member.
	(Layout::section_segment_map_): New member.
	* object.cc (Sized_relobj_file<size, big_endian>::do_layout):
	Rename is_gc_pass_one to is_pass_one.
	Rename is_gc_pass_two to is_pass_two.
	Rename is_gc_or_icf to is_two_pass.
	Check for which pass based on whether symbols data is present.
	Make it two pass when unique segments for sections is desired.
	* output.cc (Output_section::Output_section): Initialize new
	members.
	* output.h (Output_section::is_unique_segment): New function.
	(Output_section::set_is_unique_segment): New function.
	(Output_section::is_unique_segment_): New member.
	(Output_section::extra_segment_flags): New function.
	(Output_section::set_extra_segment_flags): New function.
	(Output_section::extra_segment_flags_): New member.
	(Output_section::segment_alignment): New function.
	(Output_section::set_segment_alignment): New function.
	(Output_section::segment_alignment_): New member.
	(Output_segment::Output_segment): Initialize is_unique_segment_.
	(Output_segment::is_unique_segment): New function.
	(Output_segment::set_is_unique_segment): New function.
	(Output_segment::is_unique_segment_): New member.
	* plugin.cc (allow_unique_segment_for_sections): New function.
	(unique_segment_for_sections): New function.
	(Plugin::load): Add new functions to transfer vector.
	* Makefile.am (plugin_final_layout.readelf.stdout): Add readelf output.
	* Makefile.in: Regenerate.
	* testsuite/plugin_final_layout.sh: Check if unique segment
	functionality works.
	* testsuite/plugin_section_order.c (onload): Check if new interfaces
	are available.
	(allow_unique_segment_for_sections): New global.
	(unique_segment_for_sections): New global.
	(claim_file_hook): Call allow_unique_segment_for_sections.
	(all_symbols_read_hook): Call unique_segment_for_sections.


2012-08-24  Sriraman Tallam  <tmsriram@@google.com>

	* plugin-api.h (ld_plugin_allow_unique_segment_for_sections):
	New interface.
	(ld_plugin_unique_segment_for_sections): New interface.
	(LDPT_ALLOW_UNIQUE_SEGMENT_FOR_SECTIONS): New enum val.
	(LDPT_UNIQUE_SEGMENT_FOR_SECTIONS): New enum val.
	(tv_allow_unique_segment_for_sections): New member.
	(tv_unique_segment_for_sections): New member.
@
text
@d51 2
a52 1
// Destroy any remaining File_view objects.
@


1.157
log
@	PR ld/14265
	* script-sections.cc (Sections_element::output_section_name): Add
	keep return parameter.
	(Output_section_element::match_name): Add keep return parameter.
	Return the value of the keep_ member.
	* script-sections.h (class Output_section): Update
	output_section_name prototype.
	* layout.cc (Layout::keep_input_section): New public member
	function.
	(Layout::choose_output_section): Pass keep parameter to
	output_section_name.
	* layout.h (class Layout): Add keep_input_section.
	* object.cc (Sized_relobj_file::do_layout): Check for kept input
	sections.
	* testsuite/Makefile.am: Add a test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/pr14265.c: Source file for the test.
	* testsuite/pr14265.t: Linker script for the test.
	* testsuite/pr14265.sh: Shell script for the test.

	* ld-gc/gc.exp: Add a new test.
	* ld-gc/pr14265.c: Source file for the new test.
	* ld-gc/pr14265.t: Linker script for the new test.
	* ld-gc/pr14265.d: Expected symbol dump.
@
text
@d1224 13
a1236 9
// During garbage collection (--gc-sections) and identical code folding
// (--icf), this function is called twice.  When it is called the first
// time, it is for setting up some sections as roots to a work-list for
// --gc-sections and to do comdat processing.  Actual layout happens the
// second time around after all the relevant sections have been determined.
// The first time, is_worklist_ready or is_icf_ready is false. It is then
// set to true after the garbage collection worklist or identical code
// folding is processed and the relevant sections to be kept are
// determined.  Then, this function is called again to layout the sections.
a1244 9
  bool is_gc_pass_one = ((parameters->options().gc_sections()
			  && !symtab->gc()->is_worklist_ready())
			 || (parameters->options().icf_enabled()
			     && !symtab->icf()->is_icf_ready()));

  bool is_gc_pass_two = ((parameters->options().gc_sections()
			  && symtab->gc()->is_worklist_ready())
			 || (parameters->options().icf_enabled()
			     && symtab->icf()->is_icf_ready()));
d1246 9
a1254 2
  bool is_gc_or_icf = (parameters->options().gc_sections()
		       || parameters->options().icf_enabled());
d1256 1
a1256 2
  // Both is_gc_pass_one and is_gc_pass_two should not be true.
  gold_assert(!(is_gc_pass_one  && is_gc_pass_two));
d1258 21
d1281 2
a1282 2
  Symbols_data* gc_sd = NULL;
  if (is_gc_pass_one)
a1289 4
  else if (is_gc_pass_two)
    {
      gc_sd = this->get_symbols_data();
    }
d1298 1
a1298 1
  if (is_gc_or_icf)
d1324 3
a1326 3
  const unsigned char* pnamesu = (is_gc_or_icf)
				 ? gc_sd->section_names_data
				 : sd->section_names->data();
d1376 1
a1376 1
  if (!is_gc_pass_two)
d1386 1
a1386 1
      if (!is_gc_pass_two)
d1438 1
a1438 1
      if (!is_gc_pass_two)
d1512 1
a1512 1
      if (is_gc_pass_one && parameters->options().gc_sections())
d1558 1
a1558 1
	  if (is_gc_pass_one)
d1573 1
a1573 1
      if (is_gc_pass_two && parameters->options().gc_sections())
d1598 1
a1598 1
      if (is_gc_pass_two && parameters->options().icf_enabled())
d1632 1
a1632 1
	  gold_assert(!is_gc_pass_two);
d1647 1
a1647 1
      if (is_gc_pass_two
d1651 1
a1651 1
      if (is_gc_pass_one)
d1682 1
a1682 1
  if (!is_gc_pass_two)
d1691 1
a1691 1
  gold_assert(!(is_gc_or_icf) || reloc_sections.empty());
d1738 1
a1738 1
  gold_assert(!is_gc_pass_one || eh_frame_sections.empty());
d1761 1
a1761 1
  gold_assert(!is_gc_pass_one
d1782 1
a1782 1
  if (is_gc_pass_two)
@


1.156
log
@	* object.h (Sized_relobj_file::find_shdr): New function.
	(Sized_relobj_file::find_special_sections): New function.
	* object.cc (Sized_relobj_file::find_shdr): New function.
	(Sized_relobj_file::find_eh_frame): Use find_shdr.
	(Sized_relobj_file::find_special_sections): New function, split out..
	(Sized_relobj_file::do_read_symbols): ..from here.
	* output.h (Output_data_got::replace_constant): New function.
	(Output_data_got::num_entries): New function.
	(Output_data_got::last_got_offset,set_got_size): Use num_entries.
	(Output_data_got::got_offset): Protected rather than private.
	(Output_data_got::replace_got_entry): New function.
	* output.cc (Output_data_got::replace_got_entry): New function.
	* powerpc.cc (class Powerpc_relobj): New.
	(class Powerpc_relocate_functions): Delete all psymval variants or
	convert to value,addend type.  Delete pcrela, pcrela_unaligned.
	Implement _ha functions using corresponding _hi function.
	(Powerpc_relobj::find_special_sections): New function.
	(Target_powerpc::do_make_elf_object): New function.
	(class Output_data_got_powerpc): New.
	(class Output_data_glink): New.
	(class Powerpc_scan_relocatable_reloc): New.
	Many more changes througout file.
@
text
@d1497 1
@


1.155
log
@	* configure.ac (ENABLE_GOLD): Consider *-*-nacl* targets ELF.
	* configure: Regenerate.

gold/
	* nacl.cc: New file.
	* nacl.h: New file.
	* Makefile.am (CCFILES, HFILES): Add them.
	* Makefile.in: Regenerate.
	* i386.cc (Output_data_plt_i386_nacl): New class.
	(Output_data_plt_i386_nacl_exec): New class.
	(Output_data_plt_i386_nacl_dyn): New class.
	(Target_i386_nacl): New class.
	(Target_selector_i386_nacl): New class.
	(target_selector_i386): Use it instead of Target_selector_i386.
	* x86_64.cc (Output_data_plt_x86_64_nacl): New class.
	(Target_x86_64_nacl): New class.
	(Target_selector_x86_64_nacl): New class.
	(target_selector_x86_64, target_selector_x32): Use it instead of
	Target_selector_x86_64.
	* arm.cc (Output_data_plt_arm_nacl): New class.
	(Target_arm_nacl): New class.
	(Target_selector_arm_nacl): New class.
	(target_selector_arm, target_selector_armbe): Use it instead of
	Target_selector_arm.

	* target-select.cc (select_target): Take new Input_file* and off_t
	arguments, pass them on to recognize method of selector.
	* object.cc (make_elf_sized_object): Update caller.
	* parameters.cc (parameters_force_valid_target): Likewise.
	* incremental.cc (make_sized_incremental_binary): Likewise.
	* target-select.h: Update decl.
	(Target_selector::recognize): Take new Input_file* argument,
	pass it on to do_recognize.
	(Target_selector::do_recognize): Take new Input_file* argument.
	* freebsd.h (Target_selector_freebsd::do_recognize): Likewise.
	* powerpc.cc (Target_selector_powerpc::do_recognize): Likewise.
	* sparc.cc (Target_selector_sparc::do_recognize): Likewise.
	* testsuite/testfile.cc (Target_selector::do_recognize): Likewise.

	* target.h (Target::Target_info): New members isolate_execinstr
	and rosegment_gap.
	(Target::isolate_execinstr, Target::rosegment_gap): New methods.
	* arm.cc (Target_arm::arm_info): Update initializer.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
	* sparc.cc (Target_sparc::sparc_info): Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
	* layout.cc (Layout::attach_allocated_section_to_segment):
	Take new const Target* argument.  If target->isolate_execinstr(), act
	like --rosegment.
	(Layout::find_first_load_seg): Take new const Target* argument;
	if target->isolate_execinstr(), reject PF_X segments.
	(Layout::relaxation_loop_body): Update caller.
	(Layout::set_segment_offsets): If target->isolate_execinstr(),
	reset file offset to zero when we hit LOAD_SEG, and then do a second
	loop over the segments before LOAD_SEG to reassign offsets after
	addresses have been determined.  Handle target->rosegment_gap().
	(Layout::attach_section_to_segment): Take new const Target* argument;
	pass it to attach_allocated_section_to_segment.
	(Layout::make_output_section): Update caller.
	(Layout::attach_sections_to_segments): Take new const Target* argument;
	pass it to attach_section_to_segment.
	* gold.cc (queue_middle_tasks): Update caller.
	* layout.h (Layout): Update method decls with new arguments.

	* arm.cc (Target_arm::Target_arm): Take optional argument for the
	Target_info pointer to use.
	(Target_arm::do_make_data_plt): New virtual method.
	(Target_arm::make_data_plt): New method that calls it.
	(Target_arm::make_plt_entry): Use it.
	(Output_data_plt_arm::Output_data_plt_arm): Take additional argument
	for the section alignment.
	(Output_data_plt_arm::do_first_plt_entry_offset): New abstract virtual
	method.
	(Output_data_plt_arm::first_plt_entry_offset): Call it.
	(Output_data_plt_arm::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_arm::get_plt_entry_size): Call it.
	(Output_data_plt_arm::do_fill_plt_entry): New abstract virtual method.
	(Output_data_plt_arm::fill_plt_entry): New method that calls it.
	(Output_data_plt_arm::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_arm::fill_first_plt_entry): New method that calls it.
	(Output_data_plt_arm::set_final_data_size): Use get_plt_entry_size
	method instead of sizeof(plt_entry).
	(Output_data_plt_arm::add_entry): Likewise.
	Use first_plt_entry_offset method instead of sizeof(first_plt_entry).
	(Target_arm::first_plt_entry_offset): Call method on this->plt_ rather
	than static method.
	(Target_arm::plt_entry_size): Likewise.
	(Output_data_plt_arm::first_plt_entry, Output_data_plt_arm::plt_entry):
	Move to ...
	(Output_data_plt_arm_standard): ... here, new class.
	(Output_data_plt_arm::do_write): Move guts of PLT filling to...
	(Output_data_plt_arm_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_arm_standard::do_fill_plt_entry): ... and here.

	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Take additional argument for the PLT entry size.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset):
	Use get_plt_entry_size method rather than plt_entry_size variable.
	(Output_data_plt_x86_64::reserve_slot): Likewise.
	(Output_data_plt_x86_64::do_adjust_output_section): Likewise.
	(Output_data_plt_x86_64::add_entry): Likewise.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Likewise.
	(Output_data_plt_x86_64::address_for_global): Likewise.
	(Output_data_plt_x86_64::address_for_local): Likewise.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::first_plt_entry_offset): Likewise.
	Make method non-static.
	(Output_data_plt_x86_64::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_x86_64::get_plt_entry_size): Just call that.
	(Output_data_plt_x86_64::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_x86_64::add_eh_frame): New method to call it.
	(Output_data_plt_x86_64::do_fill_first_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_first_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_tlsdesc_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_tlsdesc_entry): New method to call it.
	(Output_data_plt_x86_64::plt_entry_size)
	(Output_data_plt_x86_64::first_plt_entry)
	(Output_data_plt_x86_64::plt_entry)
	(Output_data_plt_x86_64::tlsdesc_plt_entry)
	(Output_data_plt_x86_64::plt_eh_frame_fde_size)
	(Output_data_plt_x86_64::plt_eh_frame_fde): Move to ...
	(Output_data_plt_x86_64_standard): ... here, new class.
	(Target_x86_64::Target_x86_64): Take optional argument for the
	Target_info pointer to use.
	(Target_x86_64::do_make_data_plt): New virtual method.
	(Target_x86_64::make_data_plt): New method to call it.
	(Target_x86_64::init_got_plt_for_update): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_x86_64::init):	Don't do add_eh_frame_for_plt here.
	(Target_x86_64::first_plt_entry_offset): Call method on this->plt_
	rather than static method.
	(Target_x86_64::plt_entry_size): Likewise.
	(Output_data_plt_x86_64::do_write): Use get_plt_entry_size method
	rather than plt_entry_size variable.  Move guts of PLT filling to...
	(Output_data_plt_x86_64_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_x86_64_standard::do_fill_plt_entry): ... and here ...
	(Output_data_plt_x86_64_standard::do_fill_tlsdesc_entry): ... and here.

	* i386.cc (Output_data_plt_i386::Output_data_plt_i386): Take
	additional argument for the section alignment.
	Don't do add_eh_frame_for_plt here.
	(Output_data_plt_i386::first_plt_entry_offset): Make the method
	non-static.  Use get_plt_entry_size method rather than plt_entry_size
	variable.
	(Output_data_plt_i386::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_i386::get_plt_entry_size): Call it.
	(Output_data_plt_i386::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_i386::add_eh_frame): New method to call it.
	(Output_data_plt_i386::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_first_plt_entry): New method to call it.
	(Output_data_plt_i386::do_fill_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_plt_entry): New method to call it.
	(Output_data_plt_i386::set_final_data_size): Use get_plt_entry_size
	method instead of plt_entry_size.
	(Output_data_plt_i386::plt_entry_size)
	(Output_data_plt_i386::plt_eh_frame_fde_size)
	(Output_data_plt_i386::plt_eh_frame_fde): Move to ...
	(Output_data_plt_i386_standard): ... here, new class.
	(Output_data_plt_i386_exec): New class.
	(Output_data_plt_i386::exec_first_plt_entry): Move to ...
	(Output_data_plt_i386_exec::first_plt_entry): ... here.
	(Output_data_plt_i386::exec_plt_entry): Move to ...
	(Output_data_plt_i386_exec::plt_entry): ... here.
	(Output_data_plt_i386_dyn): New class.
	(Output_data_plt_i386::first_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::first_plt_entry): ... here.
	(Output_data_plt_i386::dyn_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::plt_entry): ... here.
	(Target_i386::Target_i386): Take optional argument for the Target_info
	pointer to use.
	(Target_i386::do_make_data_plt): New virtual method.
	(Target_i386::make_data_plt): New method to call it.
	(Target_i386::make_plt_section): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_i386::add_entry): Use get_plt_entry_size method
	rather than plt_entry_size variable.
	(Output_data_plt_i386::add_local_ifunc_entry): Likewise.
	(Output_data_plt_i386::address_for_local): Likewise.
	(Output_data_plt_i386::do_write): Likewise.
	Move guts of PLT filling to...
	(Output_data_plt_i386_exec::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_i386_exec::do_fill_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_first_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_plt_entry): ... and here.

Change-Id: Id24b95600489835ff5e860a39c147203d4380c2b
@
text
@d513 58
d581 3
a583 3
  const unsigned int shnum = this->shnum();
  const unsigned char* p = pshdrs + This::shdr_size;
  for (unsigned int i = 1; i < shnum; ++i, p += This::shdr_size)
d585 5
a589 1
      typename This::Shdr shdr(p);
d591 1
a591 12
	{
	  if (shdr.get_sh_name() >= names_size)
	    {
	      this->error(_("bad section name offset for section %u: %lu"),
			  i, static_cast<unsigned long>(shdr.get_sh_name()));
	      continue;
	    }

	  const char* name = names + shdr.get_sh_name();
	  if (strcmp(name, ".eh_frame") == 0)
	    return true;
	}
a592 1
  return false;
d704 27
a736 2
  bool need_local_symbols = false;

d743 1
a743 19
  const unsigned char* namesu = sd->section_names->data();
  const char* names = reinterpret_cast<const char*>(namesu);
  if (memmem(names, sd->section_names_size, ".eh_frame", 10) != NULL)
    {
      if (this->find_eh_frame(pshdrs, names, sd->section_names_size))
	this->has_eh_frame_ = true;
    }
  if (memmem(names, sd->section_names_size, ".zdebug_", 8) != NULL)
    this->compressed_sections_ =
	build_compressed_section_map(pshdrs, this->shnum(), names,
				     sd->section_names_size, this);

  if (this->has_eh_frame_
      || (!parameters->options().relocatable()
	  && parameters->options().gdb_index()
	  && (memmem(names, sd->section_names_size, "debug_info", 12) == 0
	      || memmem(names, sd->section_names_size, "debug_types",
			13) == 0)))
    need_local_symbols = true;
@


1.154
log
@2012-03-21  Cary Coutant  <ccoutant@@google.com>

	* Makefile.am: Add gdb-index.cc, gdb-index.h.
	* Makefile.in: Regenerate.
	* dwarf_reader.cc (Sized_elf_reloc_mapper::do_initialize): New function.
	(Sized_elf_reloc_mapper::symbol_section): New function.
	(Sized_elf_reloc_mapper::do_get_reloc_target): New function.
	(make_elf_reloc_mapper): New function.
	(Dwarf_abbrev_table::clear_abbrev_codes): New function.
	(Dwarf_abbrev_table::do_read_abbrevs): New function.
	(Dwarf_abbrev_table::do_get_abbrev): New function.
	(Dwarf_ranges_table::read_ranges_table): New function.
	(Dwarf_ranges_table::read_range_list): New function.
	(Dwarf_pubnames_table::read_section): New function.
	(Dwarf_pubnames_table::read_header): New function.
	(Dwarf_pubnames_table::next_name): New function.
	(Dwarf_die::Dwarf_die): New function.
	(Dwarf_die::read_attributes): New function.
	(Dwarf_die::skip_attributes): New function.
	(Dwarf_die::set_name): New function.
	(Dwarf_die::set_linkage_name): New function.
	(Dwarf_die::attribute): New function.
	(Dwarf_die::string_attribute): New function.
	(Dwarf_die::int_attribute): New function.
	(Dwarf_die::uint_attribute): New function.
	(Dwarf_die::ref_attribute): New function.
	(Dwarf_die::child_offset): New function.
	(Dwarf_die::sibling_offset): New function.
	(Dwarf_info_reader::check_buffer): New function.
	(Dwarf_info_reader::parse): New function.
	(Dwarf_info_reader::do_parse): New function.
	(Dwarf_info_reader::do_read_string_table): New function.
	(Dwarf_info_reader::lookup_reloc): New function.
	(Dwarf_info_reader::get_string): New function.
	(Dwarf_info_reader::visit_compilation_unit): New function.
	(Dwarf_info_reader::visit_type_unit): New function.
	(Sized_dwarf_line_info::Sized_dwarf_line_info): Use
	Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::symbol_section): Remove function.
	(Sized_dwarf_line_info::read_relocs): Use Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::read_line_mappings): Remove object
	parameter, adjust callers.
	(Sized_dwarf_line_info::format_file_lineno): Fix type of cast.
	* dwarf_reader.h: Include <sys/types.h>.
	(class Track_relocs): Remove forward declaration.
	(class Elf_reloc_mapper): New class.
	(class Sized_elf_reloc_mapper): New class.
	(class Dwarf_abbrev_table): New class.
	(class Dwarf_range_list): New class.
	(class Dwarf_ranges_table): New class.
	(class Dwarf_pubnames_table): New class.
	(class Dwarf_die): New class.
	(class Dwarf_info_reader): New class.
	(Sized_dwarf_line_info::read_line_mappings): Remove object parameter.
	(Sized_dwarf_line_info::symbol_section): Remove member function.
	* dynobj.h (Sized_dynobj::do_section_contents): Refactor code from
	base class.
	* gdb-index.cc: New source file.
	* gdb-index.h: New source file.
	* incremental.cc (Sized_relobj_incr::do_layout): Track .debug_info
	and .debug_types sections, call Layout::add_to_gdb_index.
	(Sized_relobj_incr::do_section_name): Implement.
	(Sized_relobj_incr::do_section_contents): Adjust parameter list and
	return type; Implement.
	(Sized_incr_dynobj::do_section_contents): Adjust parameter list and
	return type.
	* incremental.h (Sized_relobj_incr::do_section_contents): Adjust
	parameter list and return type.
	(Sized_incr_dynobj::do_section_contents): Likewise.
	* layout.cc: Include gdb-index.h.
	(Layout::Layout): Initialize gdb_index_data_.
	(Layout::init_fixed_output_section): Check for .gdb_index section.
	(Layout::add_to_gdb_index): New function. Instantiate.
	* layout.h: Add forward declaration for class Gdb_index.
	(Layout::add_to_gdb_index): New member function.
	(Layout::gdb_index_data_): New data member.
	* main.cc: Include gdb-index.h.
	(main): Print statistics for gdb index.
	* object.cc (Object::section_contents): Move code into
	do_section_contents.
	(need_decompressed_section): Check for sections needed when building
	gdb index.
	(build_compressed_section_map): Likewise.
	(Sized_relobj_file::do_read_symbols): Need local symbols when building
	gdb index.
	(Sized_relobj_file::do_layout): Track .debug_info and .debug_types
	sections; call Layout::add_to_gdb_index.
	(Sized_relobj_file::do_decompressed_section_contents): Call
	do_section_contents directly.
	* object.h (Object::do_section_contents): Adjust parameter list and
	return type.
	(Object::do_decompressed_section_contents): Call do_section_contents
	directly.
	(Sized_relobj_file::do_section_contents): Adjust parameter list and
	return type.
	* options.h (class General_options): Add --gdb-index option.
	* plugin.cc (Sized_pluginobj::do_section_contents): Adjust parameter
	list and return type.
	* plugin.h (Sized_pluginobj::do_section_contents): Likewise.
	* reloc.h (Track_relocs::checkpoint): New function.
	(Track_relocs::reset): New function.

	* testsuite/Makefile.am (gdb_index_test_1.sh, gdb_index_test_2.sh):
	New test cases.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/gdb_index_test.cc: New test source file.
	* testsuite/gdb_index_test_1.sh: New test source file.
	* testsuite/gdb_index_test_2.sh: New test source file.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d272 1
a272 1
// This function is called from do_layout only while doing garbage 
d276 2
a277 2
Relobj::copy_symbols_data(Symbols_data* gc_sd, Read_symbols_data* sd, 
                          unsigned int section_header_size)
d279 2
a280 2
  gc_sd->section_headers_data = 
         new unsigned char[(section_header_size)];
d282 3
a284 3
         section_header_size);
  gc_sd->section_names_data = 
         new unsigned char[sd->section_names_size];
d286 1
a286 1
         sd->section_names_size);
d290 2
a291 2
      gc_sd->symbols_data = 
             new unsigned char[sd->symbols_size];
d293 1
a293 1
            sd->symbols_size);
d304 1
a304 1
             new unsigned char[sd->symbol_names_size];
d306 1
a306 1
            sd->symbol_names_size);
d322 12
a333 12
  if (is_prefix_of(".ctors", name) 
      || is_prefix_of(".dtors", name) 
      || is_prefix_of(".note", name) 
      || is_prefix_of(".init", name) 
      || is_prefix_of(".fini", name) 
      || is_prefix_of(".gcc_except_table", name) 
      || is_prefix_of(".jcr", name) 
      || is_prefix_of(".preinit_array", name) 
      || (is_prefix_of(".text", name) 
          && strstr(name, "personality")) 
      || (is_prefix_of(".data", name) 
          &&  strstr(name, "personality")) 
d337 1
a337 1
      return true; 
d673 1
a673 1
        this->has_eh_frame_ = true;
d677 1
a677 1
        build_compressed_section_map(pshdrs, this->shnum(), names,
d878 1
a878 1
        signature = section_names + member_shdr.get_sh_name();
d932 2
a933 2
        this->error(_("invalid section group %u refers to earlier section %u"),
                    index, shndx);
d938 6
a943 6
        {
          // This is an error, but it will be diagnosed eventually
          // in do_layout, so we don't need to do anything here but
          // ignore it.
          continue;
        }
d953 2
a954 2
        {
          (*omit)[shndx] = true;
d957 1
a957 1
            {
d991 2
a992 2
            }
        }
d1166 3
a1168 3
// and an offset.  
// During garbage collection (--gc-sections) and identical code folding 
// (--icf), this function is called twice.  When it is called the first 
d1170 5
a1174 5
// --gc-sections and to do comdat processing.  Actual layout happens the 
// second time around after all the relevant sections have been determined.  
// The first time, is_worklist_ready or is_icf_ready is false. It is then 
// set to true after the garbage collection worklist or identical code 
// folding is processed and the relevant sections to be kept are 
d1184 9
a1192 9
  bool is_gc_pass_one = ((parameters->options().gc_sections() 
                          && !symtab->gc()->is_worklist_ready())
                         || (parameters->options().icf_enabled()
                             && !symtab->icf()->is_icf_ready()));
 
  bool is_gc_pass_two = ((parameters->options().gc_sections() 
                          && symtab->gc()->is_worklist_ready())
                         || (parameters->options().icf_enabled()
                             && symtab->icf()->is_icf_ready()));
d1195 1
a1195 1
                       || parameters->options().icf_enabled()); 
d1205 2
a1206 2
      // During garbage collection save the symbols data to use it when 
      // re-entering this function.   
d1222 1
a1222 1
 
d1237 1
a1237 1
        symbols_data = sd->symbols->data();
d1240 1
a1240 1
        symbol_names_data = sd->symbol_names->data();
d1249 3
a1251 3
  const unsigned char* pnamesu = (is_gc_or_icf) 
                                 ? gc_sd->section_names_data
                                 : sd->section_names->data();
d1275 1
a1275 1
        ++num_sections_to_defer;
d1312 6
a1317 6
        {
          delete sd->section_headers;
          sd->section_headers = NULL;
          delete sd->section_names;
          sd->section_names = NULL;
        }
d1364 5
a1368 5
        { 
          if (this->handle_gnu_warning_section(name, i, symtab))
            { 
    	      if (!relocatable && !parameters->options().shared())
	        omit[i] = true;
d1371 5
a1375 5
          // The .note.GNU-stack section is special.  It gives the
          // protection flags that this object file requires for the stack
          // in memory.
          if (strcmp(name, ".note.GNU-stack") == 0)
            {
d1379 1
a1379 1
            }
d1396 3
a1398 3
          bool discard = omit[i];
          if (!discard)
            {
d1400 11
a1410 5
	        {
	          if (!this->include_section_group(symtab, layout, i, name, 
                                                   shdrs, pnames, 
                                                   section_names_size,
					           &omit))
d1412 1
a1412 7
	        }
              else if ((shdr.get_sh_flags() & elfcpp::SHF_GROUP) == 0
                       && Layout::is_linkonce(name))
	        {
	          if (!this->include_linkonce_section(layout, i, name, shdr))
   		    discard = true;
	        }
d1428 2
a1429 2
          if (discard)
            {
d1432 1
a1432 1
              out_section_offsets[i] = invalid_address;
d1434 3
a1436 3
            }
        }
 
d1438 16
a1453 16
        {
          if (this->is_section_name_included(name)
              || shdr.get_sh_type() == elfcpp::SHT_INIT_ARRAY 
              || shdr.get_sh_type() == elfcpp::SHT_FINI_ARRAY)
            {
              symtab->gc()->worklist().push(Section_id(this, i)); 
            }
          // If the section name XXX can be represented as a C identifier
          // it cannot be discarded if there are references to
          // __start_XXX and __stop_XXX symbols.  These need to be
          // specially handled.
          if (is_cident(name))
            {
              symtab->gc()->add_cident_section(name, Section_id(this, i));
            }
        }
d1479 9
a1487 9
          && strcmp(name, ".eh_frame") == 0
          && this->check_eh_frame_flags(&shdr))
        {
          if (is_gc_pass_one)
            {
              out_sections[i] = reinterpret_cast<Output_section*>(1);
              out_section_offsets[i] = invalid_address;
            }
          else if (should_defer_layout)
d1493 3
a1495 3
            eh_frame_sections.push_back(i);
          continue;
        }
d1498 23
a1520 23
        {
          // This is executed during the second pass of garbage 
          // collection. do_layout has been called before and some 
          // sections have been already discarded. Simply ignore 
          // such sections this time around.
          if (out_sections[i] == NULL)
            {
              gold_assert(out_section_offsets[i] == invalid_address);
              continue; 
            }
          if (((shdr.get_sh_flags() & elfcpp::SHF_ALLOC) != 0)
              && symtab->gc()->is_section_garbage(this, i))
              {
                if (parameters->options().print_gc_sections())
                  gold_info(_("%s: removing unused section from '%s'" 
                              " in file '%s'"),
                            program_name, this->section_name(i).c_str(), 
                            this->name().c_str());
                out_sections[i] = NULL;
                out_section_offsets[i] = invalid_address;
                continue;
              }
        }
d1523 27
a1549 27
        {
          if (out_sections[i] == NULL)
            {
              gold_assert(out_section_offsets[i] == invalid_address);
              continue;
            }
          if (((shdr.get_sh_flags() & elfcpp::SHF_ALLOC) != 0)
              && symtab->icf()->is_section_folded(this, i))
              {
                if (parameters->options().print_icf_sections())
                  {
                    Section_id folded =
                                symtab->icf()->get_folded_section(this, i);
                    Relobj* folded_obj =
                                reinterpret_cast<Relobj*>(folded.first);
                    gold_info(_("%s: ICF folding section '%s' in file '%s'"
                                "into '%s' in file '%s'"),
                              program_name, this->section_name(i).c_str(),
                              this->name().c_str(),
                              folded_obj->section_name(folded.second).c_str(),
                              folded_obj->name().c_str());
                  }
                out_sections[i] = NULL;
                out_section_offsets[i] = invalid_address;
                continue;
              }
        }
d1555 12
a1566 12
        {
          gold_assert(!is_gc_pass_two);
          this->deferred_layout_.push_back(Deferred_layout(i, name, 
                                                           pshdrs,
                                                           reloc_shndx[i],
                                                           reloc_type[i]));
          // Put dummy values here; real values will be supplied by
          // do_layout_deferred_sections.
          out_sections[i] = reinterpret_cast<Output_section*>(2);
          out_section_offsets[i] = invalid_address;
          continue;
        }
d1571 3
a1573 3
      if (is_gc_pass_two 
          && (out_sections[i] == reinterpret_cast<Output_section*>(2)))
        continue;
d1576 6
a1581 6
        {
          // This is during garbage collection. The out_sections are 
          // assigned in the second call to this function. 
          out_sections[i] = reinterpret_cast<Output_section*>(1);
          out_section_offsets[i] = invalid_address;
        }
d1583 5
a1587 5
        {
          // When garbage collection is switched on the actual layout
          // only happens in the second call.
          this->layout_section(layout, i, name, shdr, reloc_shndx[i],
                               reloc_type[i]);
d1603 1
a1603 1
        }
d1610 2
a1611 2
  // end.  Garbage collection  and Identical Code Folding is not 
  // turned on for relocatable code. 
d1635 3
a1637 3
        {
          // The layout for the data section was deferred, so we need
          // to defer the relocation section, too.
d1639 2
a1640 2
          this->deferred_layout_relocs_.push_back(
              Deferred_layout(i, name, pshdr, 0, elfcpp::SHT_NULL));
d1642 3
a1644 3
          out_section_offsets[i] = invalid_address;
          continue;
        }
d1648 1
a1648 1
          out_section_offsets[i] = invalid_address;
d1740 1
a1740 1
        continue;
d1784 1
a1784 1
          out_section_offsets[shndx] = invalid_address;
d1859 1
a1859 1
                         / sym_size);
d1905 1
a1905 1
                     / sym_size);
d2030 1
a2030 1
        {
d2032 3
a2034 3
          gold_assert(!lv.needs_output_dynsym_entry());
          continue;
        }
d2039 1
a2039 1
          gold_assert(!lv.needs_output_dynsym_entry());
d2056 4
a2059 4
        {
          dynpool->add(name, true, NULL);
          ++dyncount;
        }
d2093 4
a2096 4
        {
          lv.set_no_output_symtab_entry();
          continue;
        }
d2126 1
a2126 1
  
d2128 1
a2128 1
  
d2150 1
a2150 1
      
d2165 1
a2165 1
	  
d2175 1
a2175 1
      
d2187 1
a2187 1
	  
d2340 4
a2343 4
        {
          lv.set_output_dynsym_index(index);
          ++index;
        }
d2372 1
a2372 1
                                    + This::shdr_size * shndx;
d2374 1
a2374 1
      return shdr.get_sh_flags(); 
d2377 1
a2377 1
  return this->elf_file_.section_flags(shndx); 
d2391 1
a2391 1
                                + This::shdr_size * shndx;
d2393 1
a2393 1
  return shdr.get_sh_entsize(); 
d2458 1
a2458 1
                                    dyn_output_size);
d2494 2
a2495 2
        {
          elfcpp::Sym_write<size, big_endian> osym(ov);
d2497 8
a2504 8
          gold_assert(isym.get_st_name() < strtab_size);
          const char* name = pnames + isym.get_st_name();
          osym.put_st_name(sympool->get_offset(name));
          osym.put_st_value(this->local_values_[i].value(this, 0));
          osym.put_st_size(isym.get_st_size());
          osym.put_st_info(isym.get_st_info());
          osym.put_st_other(isym.get_st_other());
          osym.put_st_shndx(st_shndx);
d2506 2
a2507 2
          ov += sym_size;
        }
d2511 12
a2522 12
        {
          gold_assert(dyn_ov < dyn_oview + dyn_output_size);
          elfcpp::Sym_write<size, big_endian> osym(dyn_ov);

          gold_assert(isym.get_st_name() < strtab_size);
          const char* name = pnames + isym.get_st_name();
          osym.put_st_name(dynpool->get_offset(name));
          osym.put_st_value(this->local_values_[i].value(this, 0));
          osym.put_st_size(isym.get_st_size());
          osym.put_st_info(isym.get_st_info());
          osym.put_st_other(isym.get_st_other());
          osym.put_st_shndx(st_shndx);
d2524 2
a2525 2
          dyn_ov += sym_size;
        }
d2540 1
a2540 1
                            dyn_oview);
d2595 2
a2596 2
        {
          if (sym.get_st_name() > names_size)
d2599 14
a2612 14
            {
              info->enclosing_symbol_name = symbol_names + sym.get_st_name();
              if (parameters->options().do_demangle())
                {
                  char* demangled_name = cplus_demangle(
                      info->enclosing_symbol_name.c_str(),
                      DMGL_ANSI | DMGL_PARAMS);
                  if (demangled_name != NULL)
                    {
                      info->enclosing_symbol_name.assign(demangled_name);
                      free(demangled_name);
                    }
                }
            }
d2614 1
a2614 1
        }
d2742 4
a2745 4
        {
          delete[] p->second.contents;
          p->second.contents = NULL;
        }
d2938 2
a2939 1
  Target* target = select_target(ehdr.get_e_machine(), size, big_endian,
d2999 1
a2999 1
                                               &big_endian, &error))
@


1.153
log
@	* object.cc (need_decompressed_section): Add #ifdef ENABLE_THREADS.
@
text
@d181 1
a181 10
{
  Location loc(this->do_section_contents(shndx));
  *plen = convert_to_section_size_type(loc.data_size);
  if (*plen == 0)
    {
      static const unsigned char empty[1] = { '\0' };
      return empty;
    }
  return this->get_view(loc.file_offset, *plen, true, cache);
}
a543 2
#ifdef ENABLE_THREADS

d545 3
a547 1
// Add_symbols task.
d552 36
a587 3
  // We will need .zdebug_str if this is not an incremental link
  // (i.e., we are processing string merge sections).
  if (!parameters->incremental() && strcmp(name, ".zdebug_str") == 0)
a592 2
#endif

d629 3
d634 2
a635 10
		  Compressed_section_info info;
		  info.size = convert_to_section_size_type(uncompressed_size);
		  info.contents = NULL;

#ifdef ENABLE_THREADS
		  // If we're multi-threaded, it will help to decompress
		  // any sections that will be needed during the Add_symbols
		  // task, so that several decompressions can run in
		  // parallel.
		  if (parameters->options().threads())
d637 7
a643 11
		      unsigned char* uncompressed_data = NULL;
		      if (need_decompressed_section(name))
			{
			  uncompressed_data = new unsigned char[uncompressed_size];
			  if (decompress_input_section(contents, len,
						       uncompressed_data,
						       uncompressed_size))
			    info.contents = uncompressed_data;
			  else
			    delete[] uncompressed_data;
			}
a644 2
#endif

d659 2
d679 8
d704 2
a705 1
  // If this object has a .eh_frame section, we need all the symbols.
d723 2
a724 2
  off_t readoff = this->has_eh_frame_ ? dataoff : extoff;
  section_size_type readsize = this->has_eh_frame_ ? datasize : extsize;
d756 1
a756 1
  sd->external_symbols_offset = this->has_eh_frame_ ? locsize : 0;
d1343 4
d1587 15
d1682 23
d2681 2
a2682 2
  const unsigned char* buffer = this->section_contents(shndx, &buffer_size,
						       false);
@


1.152
log
@	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Call Object::decompressed_section_contents.
	* dwarf_reader.h (Sized_dwarf_line_info::~Sized_dwarf_line_info):
	New dtor.
	(Sized_dwarf_line_info::buffer_start_): New data member.
	* merge.cc (Output_merge_data::do_add_input_section): Call
	Object::decompressed_section_contents.
	(Output_merge_string::do_add_input_section): Likewise.
	* object.cc (need_decompressed_section): New function.
	(build_compressed_section_map): Decompress sections needed later.
	(Sized_relobj_file::do_decompressed_section_contents): New function.
	(Sized_relobj_file::do_discard_decompressed_sections): New function.
	* object.h (Object::decompressed_section_contents): New function.
	(Object::discard_decompressed_sections): New function.
	(Object::do_decompressed_section_contents): New function.
	(Object::do_discard_decompressed_sections): New function.
	(Compressed_section_info): New type.
	(Compressed_section_map): Include decompressed section contents.
	(Sized_relobj_file::do_decompressed_section_contents): New function.
	(Sized_relobj_file::do_discard_decompressed_sections): New function.
@
text
@d553 2
d569 2
@


1.151
log
@	* object.h (Relobj::local_symbol_value): New function.
	(Relobj::local_plt_offset): New function.
	(Relobj::local_has_got_offset): New function.
	(Relobj::local_got_offset): New function.
	(Relobj::set_local_got_offset): New function.
	(Relobj::do_local_symbol_value): New pure virtual function.
	(Relobj::do_local_plt_offset): Likewise.
	(Relobj::do_local_has_got_offset): Likewise.
	(Relobj::do_local_got_offset): Likewise.
	(Relobj::do_set_local_got_offset): Likewise.
	(Sized_relobj::do_local_has_got_offset): Rename from
	local_has_got_offset.
	(Sized_relobj::do_local_got_offset): Rename from local_got_offset.
	(Sized_relobj::do_set_local_got_offset): Rename from
	set_local_got_offset.
	(Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	(Sized_relobj_file::do_local_symbol_value): New function.
	* object.cc (Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	* output.cc (Output_data_got::Got_entry::write): Change object to
	Relobj.  Use local_symbol_value.
	(Output_data_got::add_global_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_with_rela): Remove.  Change all
	callers to use add_global_with_rel.
	(Output_data_got::add_global_pair_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_pair_with_rela): Remove.  Change all
	callers to use add_global_pair_with_rel.
	(Output_data_got::add_local): Change object to Relobj*.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Change object to Relobj*,
	change rel_dyn to Output_data_reloc_generic*.  Use
	add_local_generic.
	(Output_data_got::add_local_with_rela): Remove.  Change all
	callers to use all_local_with_rel.
	(Output_data_got::add_local_pair_with_rel): Change object to
	Relobj*, change rel_dyn to Output_data_reloc_generic*.  Use
	add_output_section_generic.
	(Output_data_got::add_local_pair_with_rela): Remove.  Change all
	callers to use add_local_pair_with_rel.
	(Output_data_got::reserve_local): Change object to Relobj*.
	* output.h: (class Output_data_reloc_generic): Add pure virtual
	declarations for add_global_generic, add_local_generic,
	add_output_section_generic.
	(class Output_data_reloc) [SHT_REL, SHT_RELA]: Implement new
	functions for Output_data_reloc_generic.  Update declarations for
	changes listed in output.cc.
	(class Output_data_got): Change template parameter to got_size.
	Don't define Rel_dyn or Rela_dyn.  Update declarations per above.
	* incremental.h (Sized_relobj_incr::do_local_symbol_value): New
	function.
	(Sized_relobj_incr::do_local_plt_offset): New function.
	* copy-relocs.cc (Copy_relocs::Copy_reloc_entry::emit): Call
	add_global_generic.
@
text
@d553 14
d568 1
a568 1
// to the uncompressed size.
d579 1
a579 1
  Compressed_section_map* uncompressed_sizes = new Compressed_section_map();
d582 1
d604 28
a631 2
		(*uncompressed_sizes)[i] =
		    convert_to_section_size_type(uncompressed_size);
d635 1
a635 1
  return uncompressed_sizes;
d2601 79
@


1.150
log
@	* incremental.cc (can_incremental_update): New function.
	* incremental.h (can_incremental_update): New function.
	* layout.cc (Layout::init_fixed_output_section): Call it.
	(Layout::make_output_section): Don't allow patch space in .eh_frame.
	* object.cc (Sized_relobj_file::do_layout): Call
	can_incremental_update.
@
text
@d1822 2
a1823 1
Sized_relobj_file<size, big_endian>::local_plt_offset(unsigned int symndx) const
@


1.149
log
@	* object.cc (Sized_relobj_file::do_layout): Remove unused local
	variable external_symbols_offset.
@
text
@d1347 1
a1347 3
	      && (shdr.get_sh_type() == elfcpp::SHT_PROGBITS
	          || shdr.get_sh_type() == elfcpp::SHT_NOBITS
	          || shdr.get_sh_type() == elfcpp::SHT_NOTE))
@


1.148
log
@	* object.cc (Sized_relobj_file::do_layout): Remove assertion which
	triggered if object has no symbols.
@
text
@a1151 1
  section_offset_type external_symbols_offset;
a1160 1
      external_symbols_offset = gc_sd->external_symbols_offset;
a1170 1
      external_symbols_offset = sd->external_symbols_offset;
@


1.147
log
@	* layout.cc (Layout::set_segment_offsets): Don't realign text
	segment if -Ttext was specified.
	* object.cc (Sized_relobj_file::Sized_relobj_file): Store the ELF
	file type.
	* object.h (Sized_relobj_file::e_type): New function.
	(Sized_relobj_file::e_type_): New data member.
	* symtab.cc (Symbol_table::add_from_relobj): Don't add section
	base address for ET_EXEC files.
	* target.cc (Target::do_make_elf_object_implementation): Allow
	ET_EXEC files with --just-symbols option.
@
text
@a1584 2
      gold_assert(external_symbols_offset != 0);

@


1.146
log
@	* object.cc (Sized_relobj_file::include_section_group): Add
	information to comment about signature location.
@
text
@d424 1
@


1.145
log
@	PR gold/12629
	* object.cc (Sized_relobj_file::layout_section): Change shdr
	parameter to be const.
	(Sized_relobj_file::layout_eh_frame_section): New function, broken
	out of do_layout.
	(Sized_relobj_file::do_layout): Defer .eh_frame sections if
	appropriate.  Call layout_eh_frame_section.
	(Sized_relobj_file::do_layout_deferred_sections): Handle .eh_frame
	sections.
	* object.h (class Sized_relobj_file): Update declarations.
@
text
@d751 5
a755 4
  // Look up the group signature, which is the name of a symbol.  This
  // is a lot of effort to go to to read a string.  Why didn't they
  // just have the group signature point into the string table, rather
  // than indirect through a symbol?
@


1.144
log
@	PR gold/12675
	* object.cc (Sized_relobj_file::check_eh_frame_flags): Check for
	SHT_X86_64_UNWIND.
	* layout.cc (Layout::layout_eh_frame): Likewise.
@
text
@d1021 7
a1027 6
Sized_relobj_file<size, big_endian>::layout_section(Layout* layout,
						    unsigned int shndx,
						    const char* name,
						    typename This::Shdr& shdr,
						    unsigned int reloc_shndx,
						    unsigned int reloc_type)
d1046 47
d1418 6
a1423 1
          else
a1582 1
      gold_assert(this->has_eh_frame_);
d1590 9
a1598 27
      off_t offset;
      Output_section* os = layout->layout_eh_frame(this,
						   symbols_data,
						   symbols_size,
						   symbol_names_data,
						   symbol_names_size,
						   i, shdr,
						   reloc_shndx[i],
						   reloc_type[i],
						   &offset);
      out_sections[i] = os;
      if (os == NULL || offset == -1)
	{
	  // An object can contain at most one section holding exception
	  // frame information.
	  gold_assert(this->discarded_eh_frame_shndx_ == -1U);
	  this->discarded_eh_frame_shndx_ = i;
	  out_section_offsets[i] = invalid_address;
	}
      else
        out_section_offsets[i] = convert_types<Address, off_t>(offset);

      // If this section requires special handling, and if there are
      // relocs that apply to it, then we must do the special handling
      // before we apply the relocs.
      if (os != NULL && offset == -1 && reloc_shndx[i] != 0)
	this->set_relocs_must_follow_section_writes();
d1637 21
a1657 2
      this->layout_section(layout, deferred->shndx_, deferred->name_.c_str(),
                           shdr, deferred->reloc_shndx_, deferred->reloc_type_);
@


1.143
log
@	* object.cc (Sized_relobj_file::do_layout): Keep warning sections
	when making a shared library.
@
text
@d514 3
a516 1
  return (shdr->get_sh_type() == elfcpp::SHT_PROGBITS
@


1.142
log
@	PR gold/12804
	* gold/gold.cc (queue_initial_tasks): Warn if --incremental is
	used with --compress-debug-sections.
	* gold/object.cc (Sized_relobj_file::do_layout): Report
	uncompressed size of compressed input sections.
@
text
@d1246 1
a1246 1
    	      if (!relocatable)
d1265 1
a1265 2
	      if (!parameters->options().relocatable()
		  && !parameters->options().shared())
@


1.141
log
@	* incremental-dump.cc (dump_incremental_inputs): Print COMDAT groups.
	* incremental.cc (Incremental_inputs::report_input_section): Fix
	comment, indentation.
	(Incremental_inputs::report_comdat_group): New function.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of data for incremental input file entry.
	(Output_section_incremental_inputs::write_info_blocks): Write COMDAT
	group count, COMDAT group signatures.
	(Sized_incr_relobj::do_layout): Record kept COMDAT group info from
	an unchanged input file.
	* incremental.h (Incremental_object_entry::Incremental_object_entry):
	Initialize new data member.
	(Incremental_object_entry::add_comdat_group): New function.
	(Incremental_object_entry::get_comdat_group_count): New function.
	(Incremental_object_entry::get_comdat_signature_key): New function.
	(Incremental_object_entry::groups_): New data member.
	(Incremental_inputs::report_comdat_group): New function.
	(Incremental_input_entry_reader::get_symbol_offset): Adjust size of
	data for incremental input file entry.
	(Incremental_input_entry_reader::get_comdat_group_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	data for incremental input file entry.
	(Incremental_input_entry_reader::get_global_symbol_reader): Likewise.
	(Incremental_input_entry_reader::get_comdat_group_signature): New
	function.
	* object.cc (Sized_relobj::include_section_group): Report kept
	COMDAT groups for incremental links.
@
text
@d1302 7
a1308 2
	    incremental_inputs->report_input_section(this, i, name,
						     shdr.get_sh_size());
@


1.140
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d828 7
@


1.139
log
@	* object.cc (Sized_relobj::do_count_local_symbols): Check for
	strip_all (-s).
@
text
@d192 1
a192 1
// Read the section data into SD.  This is code common to Sized_relobj
d377 3
d381 20
a400 1
Sized_relobj<size, big_endian>::Sized_relobj(
d405 1
a405 1
  : Sized_relobj_base<size, big_endian>(name, input_file, offset),
a415 1
    local_got_offsets_(),
d427 1
a427 1
Sized_relobj<size, big_endian>::~Sized_relobj()
d436 1
a436 1
Sized_relobj<size, big_endian>::do_setup()
d449 1
a449 1
Sized_relobj<size, big_endian>::find_symtab(const unsigned char* pshdrs)
d498 1
a498 1
Sized_relobj<size, big_endian>::do_initialize_xindex()
d511 1
a511 1
Sized_relobj<size, big_endian>::check_eh_frame_flags(
d523 1
a523 1
Sized_relobj<size, big_endian>::find_eh_frame(
d560 1
a560 1
    Sized_relobj<size, big_endian>* obj)
d598 1
a598 1
Sized_relobj<size, big_endian>::do_read_symbols(Read_symbols_data* sd)
d701 3
a703 3
Sized_relobj<size, big_endian>::symbol_section_and_value(unsigned int sym,
							 Address* value,
							 bool* is_ordinary)
d727 1
a727 1
Sized_relobj<size, big_endian>::include_section_group(
d940 1
a940 1
Sized_relobj<size, big_endian>::include_linkonce_section(
d1012 6
a1017 6
Sized_relobj<size, big_endian>::layout_section(Layout* layout,
                                               unsigned int shndx,
                                               const char* name,
                                               typename This::Shdr& shdr,
                                               unsigned int reloc_shndx,
                                               unsigned int reloc_type)
d1025 1
a1025 1
    this->section_offsets_[shndx] = invalid_address;
d1027 1
a1027 1
    this->section_offsets_[shndx] = convert_types<Address, off_t>(offset);
d1052 3
a1054 3
Sized_relobj<size, big_endian>::do_layout(Symbol_table* symtab,
					  Layout* layout,
					  Read_symbols_data* sd)
d1175 1
a1175 1
  std::vector<Address>& out_section_offsets(this->section_offsets_);
d1576 1
a1576 1
Sized_relobj<size, big_endian>::do_layout_deferred_sections(Layout* layout)
d1599 1
a1599 1
  std::vector<Address>& out_section_offsets(this->section_offsets_);
d1631 3
a1633 3
Sized_relobj<size, big_endian>::do_add_symbols(Symbol_table* symtab,
					       Read_symbols_data* sd,
					       Layout*)
d1674 5
a1678 4
Sized_relobj<size, big_endian>::do_should_include_member(Symbol_table* symtab,
							 Layout* layout,
                                                         Read_symbols_data* sd,
                                                         std::string* why)
d1724 1
a1724 1
Sized_relobj<size, big_endian>::do_for_all_global_symbols(
a1744 20
// Iterate over local symbols, calling a visitor class V for each GOT offset
// associated with a local symbol.

template<int size, bool big_endian>
void
Sized_relobj<size, big_endian>::do_for_all_local_got_entries(
    Got_offset_list::Visitor* v) const
{
  unsigned int nsyms = this->local_symbol_count();
  for (unsigned int i = 0; i < nsyms; i++)
    {
      Local_got_offsets::const_iterator p = this->local_got_offsets_.find(i);
      if (p != this->local_got_offsets_.end())
	{
	  const Got_offset_list* got_offsets = p->second;
	  got_offsets->for_all_got_offsets(v);
	}
    }
}

d1749 2
a1750 1
Sized_relobj<size, big_endian>::local_has_plt_offset(unsigned int symndx) const
d1761 1
a1761 1
Sized_relobj<size, big_endian>::local_plt_offset(unsigned int symndx) const
d1773 2
a1774 2
Sized_relobj<size, big_endian>::set_local_plt_offset(unsigned int symndx,
						     unsigned int plt_offset)
d1789 2
a1790 2
Sized_relobj<size, big_endian>::do_count_local_symbols(Stringpool* pool,
						       Stringpool* dynpool)
d1938 2
a1939 2
typename Sized_relobj<size, big_endian>::Compute_final_local_value_status
Sized_relobj<size, big_endian>::compute_final_local_value_internal(
d1988 2
a1989 2
	  Sized_relobj<size, big_endian>* folded_obj = reinterpret_cast
	    <Sized_relobj<size, big_endian>*>(folded.first);
d2091 2
a2092 2
typename Sized_relobj<size, big_endian>::Compute_final_local_value_status
Sized_relobj<size, big_endian>::compute_final_local_value(
d2101 1
a2101 1
  const std::vector<Address>& out_offsets(this->section_offsets_);
d2114 4
a2117 3
Sized_relobj<size, big_endian>::do_finalize_local_symbols(unsigned int index,
							  off_t off,
                                                          Symbol_table* symtab)
d2126 1
a2126 1
  const std::vector<Address>& out_offsets(this->section_offsets_);
d2160 2
a2161 1
Sized_relobj<size, big_endian>::do_set_local_dynsym_indexes(unsigned int index)
d2182 1
a2182 1
Sized_relobj<size, big_endian>::do_set_local_dynsym_offset(off_t off)
d2194 1
a2194 1
Sized_relobj<size, big_endian>::do_section_flags(unsigned int shndx)
d2213 1
a2213 1
Sized_relobj<size, big_endian>::do_section_entsize(unsigned int shndx)
d2228 1
a2228 1
Sized_relobj<size, big_endian>::write_local_symbols(
d2378 1
a2378 1
Sized_relobj<size, big_endian>::get_symbol_location_info(
d2453 2
a2454 2
typename Sized_relobj<size, big_endian>::Address
Sized_relobj<size, big_endian>::map_to_kept_section(
d2462 2
a2463 2
      Sized_relobj<size, big_endian>* kept_relobj =
	static_cast<Sized_relobj<size, big_endian>*>(kept_object);
d2480 1
a2480 1
Sized_relobj<size, big_endian>::do_get_global_symbol_counts(
d2859 1
a2859 1
class Sized_relobj<32, false>;
d2864 1
a2864 1
class Sized_relobj<32, true>;
d2869 1
a2869 1
class Sized_relobj<64, false>;
d2874 1
a2874 1
class Sized_relobj<64, true>;
@


1.138
log
@	* object.cc (Relocate_info::location): Simplify location string.
	* errors.cc (Errors::error_at_location): Don't print program
	name.
	(Errors::warning_at_location): Likewise.
	(Errors::undefined_symbol): Likewise.
	* testsuite/debug_msg.sh: Update accordingly.
@
text
@d1827 1
d1886 2
a1887 1
      if (discard_all && lv.may_be_discarded_from_output_symtab())
@


1.137
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d2624 3
a2626 2
// Return a string describing the location of a relocation.  This is
// only used in error messages.
d2632 4
a2635 3
  // See if we can get line-number information from debugging sections.
  std::string filename;
  std::string file_and_lineno;   // Better than filename-only, if available.
d2637 1
a2637 3
  Sized_dwarf_line_info<size, big_endian> line_info(this->object);
  // This will be "" if we failed to parse the debug info for any reason.
  file_and_lineno = line_info.addr2line(this->data_shndx, offset, NULL);
a2638 2
  std::string ret(this->object->name());
  ret += ':';
d2642 12
a2653 4
      ret += " in function ";
      ret += info.enclosing_symbol_name;
      ret += ":";
      filename = info.source_file;
d2656 5
a2660 14
  if (!file_and_lineno.empty())
    ret += file_and_lineno;
  else
    {
      if (!filename.empty())
        ret += filename;
      ret += "(";
      ret += this->object->section_name(this->data_shndx);
      char buf[100];
      // Offsets into sections have to be positive.
      snprintf(buf, sizeof(buf), "+0x%lx", static_cast<long>(offset));
      ret += buf;
      ret += ")";
    }
@


1.136
log
@	* archive.cc (Library_base::should_include_member): Move
	method here from class Archive.
	(Archive::Archive): Initialize base class.
	(Archive::should_include_member): Move to base class.
	(Archive::do_for_all_unused_symbols): New function.
	(Add_archive_symbols::run): Remove redundant access to
	incremental_inputs.
	(Lib_group::Lib_group): Initialize base class.
	(Lib_group::do_filename): New function.
	(Lib_group::include_member): Pass pointer to Lib_group to
	report_object.
	(Lib_group::do_for_all_unused_symbols): New function.
	(Add_lib_group_symbols::run): Report archive information for
	incremental links.
	* archive.h (class Library_base): New base class.
	(class Archive): Derive from Library_base.
	(Archive::filename): Move to base class.
	(Archive::set_incremental_info): Likewise.
	(Archive::incremental_info): Likewise.
	(Archive::Should_include): Likewise.
	(Archive::should_include_member): Likewise.
	(Archive::Armap_entry): Remove.
	(Archive::Unused_symbol_iterator): Remove.
	(Archive::unused_symbols_begin): Remove.
	(Archive::unused_symbols_end): Remove.
	(Archive::do_filename): New function.
	(Archive::do_get_mtime): New function.
	(Archive::do_for_all_unused_symbols): New function.
	(Archive::task_): Move to base class.
	(Archive::incremental_info_): Likewise.
	(class Lib_group): Derive from Library_base.
	(Lib_group::do_filename): New function.
	(Lib_group::do_get_mtime): New function.
	(Lib_group::do_for_all_unused_symbols): New function.
	(Lib_group::task_): Move to base class.
	* dynobj.cc (Sized_dynobj::do_for_all_global_symbols): New
	function.
	* dynobj.h (Sized_dynobj::do_for_all_global_symbols): New
	function.
	* incremental.cc (Incremental_inputs::report_archive_begin):
	Use Library_base; call library's get_mtime; add incremental inputs
	entry before members.
	(class Unused_symbol_visitor): New class.
	(Incremental_inputs::report_archive_end): Use Library_base; use
	visitor class to record unused symbols; don't add incremental inputs
	entry after members.
	(Incremental_inputs::report_object): Use Library_base.
	* incremental.h
	(Incremental_archive_entry::Incremental_archive_entry): Remove
	unused Archive parameter.
	(Incremental_inputs::report_archive_begin): Use Library_base.
	(Incremental_inputs::report_archive_end): Likewise.
	(Incremental_inputs::report_object): Likewise.
	* object.cc (Sized_relobj::do_for_all_global_symbols): New
	function.
	* object.h (Object::for_all_global_symbols): New function.
	(Object::do_for_all_global_symbols): New function.
	(Sized_relobj::do_for_all_global_symbols): New function.
	* plugin.cc (Sized_pluginobj::do_for_all_global_symbols):  New
	function.
	* plugin.h (Sized_pluginobj::do_for_all_global_symbols):  New
	function.
@
text
@d352 2
a353 2
// array to point to the first entry in each block.  Returns the next
// available relocation index.
d356 1
a356 1
Relobj::finalize_incremental_relocs(Layout* layout)
d369 2
a370 1
      this->reloc_counts_[i] = 0;
d383 1
a383 1
  : Relobj(name, input_file, offset),
d1269 6
a1274 3
	  if (incremental_inputs != NULL)
	    incremental_inputs->report_input_section(this, i,
						     discard ? NULL : name,
d1288 1
a1288 1
          if (is_section_name_included(name)
d1723 20
d2226 2
a2227 1
    Output_symtab_xindex* dynsym_xindex)
d2272 2
a2273 1
    oview = of->get_output_view(this->local_symbol_offset_, output_size);
d2353 2
a2354 1
      of->write_output_view(this->local_symbol_offset_, output_size, oview);
d2480 1
a2480 1
  for (Symbols::const_iterator p = this->symbols_.begin();
@


1.135
log
@	* dwarf_reader.cc (Sized_dwarf_line_info): Include all lines,
	but mark earlier ones as non-canonical
	(offset_to_iterator): Update search target and example
	(do_addr2line): Return extra lines in a vector*
	(format_file_lineno): Extract from do_addr2line
	(one_addr2line): Add vector* out-param
	* dwarf_reader.h (Offset_to_lineno_entry): New field recording
	when a lineno entry appeared last for its instruction
	(Dwarf_line_info): Add vector* out-param
	* object.cc (Relocate_info): Pass NULL for the vector* out-param
	* symtab.cc (Odr_violation_compare): Include the lineno in the
	comparison again.
	(linenos_from_loc): New. Combine the canonical line for an
	address with its other lines.
	(True_if_intersect): New. Helper functor to make
	std::set_intersection a query.
	(detect_odr_violations): Compare sets of lines instead of just
	one line for each function. This became less deterministic, but
	has fewer false positives.
	* symtab.h: Declarations.
	* testsuite/Makefile.am (odr_violation2.o): Compile with -O2 to
	mix an optimized and non-optimized object in the same binary
	(odr_violation2.so): Same.
	* testsuite/Makefile.in: Regenerate from Makefile.am.
	* testsuite/debug_msg.cc (main): Make OdrDerived classes.
	* testsuite/debug_msg.sh: Update line numbers and add
	assertions.
	* testsuite/odr_violation1.cc: Use OdrDerived, in a
	non-optimized context.
	* testsuite/odr_violation2.cc: Make sure Ordering::operator()
	isn't inlined, and use OdrDerived in an optimized context.
	* testsuite/odr_header1.h: Defines OdrDerived, where
	optimization will change the
	first-instruction-in-the-destructor's file and line number.
	* testsuite/odr_header2.h: Defines OdrBase.
@
text
@d1694 25
@


1.134
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d2585 1
a2585 1
  file_and_lineno = line_info.addr2line(this->data_shndx, offset);
@


1.133
log
@	* layout.cc (Layout::layout_gnu_stack): Add warnings for executable
	stack.
	* layout.h (Layout::layout_gnu_stack): Add pointer to Object
	parameter; change all callers.
	* object.cc (Sized_relobj::do_layout): Adjust call to layout_gnu_stack.
	* options.h (warn_execstack): New option.
@
text
@d259 1
a259 1
// this object was compiled with -fstack-split, mark it accordingly.
d353 1
a353 1
// available reloation index.
d672 1
a672 1
// index.  not a special cod between SHN_LORESERVE and SHN_HIRESERVE.
@


1.132
log
@Support building gold with gcc 4.2/4.3.

2010-09-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gold/11996
	* object.cc (Sized_relobj::do_finalize_local_symbols): Remove
	"This::" to work around a bug in gcc 4.2.

	* testsuite/ifuncmain7.c (foo_ifunc): Add __attribute__ ((used)).
@
text
@d1432 1
a1432 1
    layout->layout_gnu_stack(seen_gnu_stack, gnu_stack_flags);
@


1.132.2.1
log
@	* object.cc (Sized_relobj::do_layout): Keep warning sections when
	making a shared library.
@
text
@d1217 1
a1217 1
    	      if (!relocatable && !parameters->options().shared())
d1236 2
a1237 1
	      if (!relocatable && !parameters->options().shared())
@


1.131
log
@2010-09-08  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_exidx_cantunwind::do_print_to_mapfile): New method.
	(Arm_relobj::do_relocate_sections): Add new parameter for output
	file to match the parent.
	(Target_arm::scan_reloc_section_for_stubs): Use would-be final values
	of local symbols instead of input values.  Update code to track
	changes in gold::relocate_section.
	* object.cc (Sized_relobj::compute_final_local_value): New methods.
	(Sized_relobj::compute_final_local_value_internal): New methods.
	(Sized_relobj::do_finalize_local_symbols): Move code from loop
	body into private version of Sized_relobj::compute_final_local_value.
	Call the inline method.
	* object.h (Symbol_value::Symbol_value): Define destructor.  Free
	merged symbol value if there is one.
	(Symbol_value::has_output_value): New method defintiion.
	(Sized_relobj::Compute_final_local_value_status): New enum type.
	(Sized_relobj::compute_final_local_value): New methods.
	(Sized_relobj::compute_final_local_value_internal): New methods.
	* Makefile.am (check_SCRIPTS): Add arm_branch_out_of_range.sh
	and arm_cortex_a8.sh.
	(thumb_bl_out_of_range_local, arm_cortex_a8_b_cond, arm_cortex_a8_bl,
	arm_cortex_a8_blx, arm_cortex_a8_local, arm_corte_a8_local_reloc):
	New tests.
	* Makefile.in: Regenerate.
	* testsuite/arm_bl_out_of_range.s: Update test.
	* testsuite/thumb_bl_out_of_range.s: Ditto.
	* testsuite/thumb_blx_out_of_range.s: Ditto.
	* testsuite/arm_branch_out_of_range.sh: New file.
	* testsuite/arm_cortex_a8.sh: Ditto.
	* testsuite/arm_cortex_a8_b.s: Ditto.
	* testsuite/arm_cortex_a8_b_cond.s: Ditto.
	* testsuite/arm_cortex_a8_b_local.s: Ditto.
	* testsuite/arm_cortex_a8_bl.s: Ditto.
	* testsuite/arm_cortex_a8_blx.s: Ditto.
	* testsuite/arm_cortex_a8_local.s: Ditto.
	* testsuite/arm_cortex_a8_local_reloc.s: Ditto.
	* testsuite/thumb_bl_out_of_range_local.s: Ditto.
@
text
@d2077 1
a2077 1
      This::Compute_final_local_value_status cflv_status =
@


1.130
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d1881 172
a2071 1
  unsigned int shnum = this->shnum();
d2075 1
a2075 1
      Symbol_value<size>& lv(this->local_values_[i]);
d2077 5
a2081 6
      bool is_ordinary;
      unsigned int shndx = lv.input_shndx(&is_ordinary);

      // Set the output symbol value.

      if (!is_ordinary)
d2083 2
a2084 3
	  if (shndx == elfcpp::SHN_ABS || Symbol::is_common_shndx(shndx))
	    lv.set_output_value(lv.input_value());
	  else
d2086 2
a2087 3
	      this->error(_("unknown section index %u for local symbol %u"),
			  shndx, i);
	      lv.set_output_value(0);
d2089 7
a2096 113
      else
	{
	  if (shndx >= shnum)
	    {
	      this->error(_("local symbol %u section index %u out of range"),
			  i, shndx);
	      shndx = 0;
	    }

	  Output_section* os = out_sections[shndx];
          Address secoffset = out_offsets[shndx];
          if (symtab->is_section_folded(this, shndx))
            {
              gold_assert(os == NULL && secoffset == invalid_address);
              // Get the os of the section it is folded onto.
              Section_id folded = symtab->icf()->get_folded_section(this,
                                                                    shndx);
              gold_assert(folded.first != NULL);
              Sized_relobj<size, big_endian>* folded_obj = reinterpret_cast
                <Sized_relobj<size, big_endian>*>(folded.first);
              os = folded_obj->output_section(folded.second);
              gold_assert(os != NULL);
              secoffset = folded_obj->get_output_section_offset(folded.second);

	      // This could be a relaxed input section.
              if (secoffset == invalid_address)
		{
		  const Output_relaxed_input_section* relaxed_section =
		    os->find_relaxed_input_section(folded_obj, folded.second);
		  gold_assert(relaxed_section != NULL);
		  secoffset = relaxed_section->address() - os->address();
		}
            }

	  if (os == NULL)
	    {
              // This local symbol belongs to a section we are discarding.
              // In some cases when applying relocations later, we will
              // attempt to match it to the corresponding kept section,
              // so we leave the input value unchanged here.
	      continue;
	    }
	  else if (secoffset == invalid_address)
	    {
	      uint64_t start;

	      // This is a SHF_MERGE section or one which otherwise
	      // requires special handling.
	      if (shndx == this->discarded_eh_frame_shndx_)
		{
		  // This local symbol belongs to a discarded .eh_frame
		  // section.  Just treat it like the case in which
		  // os == NULL above.
		  gold_assert(this->has_eh_frame_);
		  continue;
		}
	      else if (!lv.is_section_symbol())
		{
		  // This is not a section symbol.  We can determine
		  // the final value now.
		  lv.set_output_value(os->output_address(this, shndx,
							 lv.input_value()));
		}
	      else if (!os->find_starting_output_address(this, shndx, &start))
		{
		  // This is a section symbol, but apparently not one in a
		  // merged section.  First check to see if this is a relaxed
		  // input section.  If so, use its address.  Otherwise just
		  // use the start of the output section.  This happens with
		  // relocatable links when the input object has section
		  // symbols for arbitrary non-merge sections.
		  const Output_section_data* posd =
		    os->find_relaxed_input_section(this, shndx);
		  if (posd != NULL)
		    {
		      Address relocatable_link_adjustment =
			relocatable ? os->address() : 0;
		      lv.set_output_value(posd->address()
					  - relocatable_link_adjustment);
		    }
		  else
		    lv.set_output_value(os->address());
		}
	      else
		{
		  // We have to consider the addend to determine the
		  // value to use in a relocation.  START is the start
		  // of this input section.  If we are doing a relocatable
		  // link, use offset from start output section instead of
		  // address.
		  Address adjusted_start =
		    relocatable ? start - os->address() : start;
		  Merged_symbol_value<size>* msv =
		    new Merged_symbol_value<size>(lv.input_value(),
						  adjusted_start);
		  lv.set_merged_symbol_value(msv);
		}
	    }
          else if (lv.is_tls_symbol())
	    lv.set_output_value(os->tls_offset()
				+ secoffset
				+ lv.input_value());
	  else
	    lv.set_output_value((relocatable ? 0 : os->address())
				+ secoffset
				+ lv.input_value());
	}

      if (!lv.is_output_symtab_index_set())
        {
          lv.set_output_symtab_index(index);
          ++index;
        }
@


1.129
log
@	PR 10893
	* i386.cc (class Output_data_plt_i386): Update declarations.
	Define Global_ifunc and Local_ifunc types.  Add global_ifuncs_ and
	local_ifuncs_ fields.
	(Target_i386::do_plt_section_for_global): New function.
	(Target_i386::do_plt_section_for_local): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Add symtab
	parameter; change all callers.  Initialize global_ifuncs_ and
	local_ifuncs_.  If doing a static link define __rel_iplt_start and
	__rel_iplt_end.
	(Output_data_plt_i386::add_entry): Handle IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): New function.
	(Output_data_plt_i386::do_write): Fix GOT entries for IFUNC
	symbols.
	(Target_i386::make_plt_section): New function, broken out of
	make_plt_entry.  Set sh_info field of .rel.plt to point to .plt.
	(Target_i386::make_plt_entry): Call make_plt_section.
	(Target_i386::make_local_ifunc_plt_entry): New function.
	(Target_i386::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_i386::Scan::local): Handle IFUNC symbols.  Add
	R_386_IRELATIVE to switch.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocatable_size_for_reloc): Add R_386_IRELATIVE to
	switch.
	* x86_64.cc (class Output_data_plt_x86_64): Update declarations.
	(Target_x86_64::do_plt_section_for_global): New function.
	(Target_x86_64::do_plt_section_for_local): New function.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Add symtab
	parameter; change all callers.  If doing a static link define
	__rela_iplt_start and __rela_iplt_end.
	(Output_data_plt_x86_64::add_entry): Handle IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): New function.
	(Target_x86_64::make_plt_section): Set sh_info field of .rel.plt
	to point to .plt.
	(Target_x86_64::make_local_ifunc_plt_entry): New function.
	(Target_x86_64::Scan::check_non_pic): Add R_X86_64_IRELATIVE to
	switch.
	(Target_x86_64::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_x86_64::Scan::local): Handle IFUNC symbols.  Add
	R_X86_64_IRELATIVE to switch.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocatable_size_for_reloc): Add R_X86_64_IRELATIVE to
	switch.
	* target.h (class Target): Add plt_section_for_global and
	plt_section_for_local functions.  Add do_plt_section_for_global
	and do_plt_section_for_local virtual functions.
	* symtab.h (Symbol::needs_plt_entry): Handle IFUNC symbol.  Add
	clarifying comments.
	(Symbol::use_plt_offset): Handle IFUNC symbol.
	* object.cc (Sized_relobj::Sized_relobj): Initialize
	local_plt_offsets_.
	(Sized_relobj::local_has_plt_offset): New function.
	(Sized_relobj::local_plt_offset): New function.
	(Sized_relobj::set_local_plt_offset): New function.
	(Sized_relobj::do_count): Handle IFUNC symbol.
	* object.h (class Symbol_value): Add is_ifunc_symbol_ field.  Take
	a bit away from input_shndx_ field.  Add set_is_func_symbol and
	is_ifunc_symbol functions.
	(class Sized_relobj): Update declarations.  Remove Tls_got_entry
	and Local_tls_got_offsets.  Define Local_plt_offsets.  Add
	local_plt_offsets_ field.
	(Sized_relobj::clear_local_symbols): Clear local_plt_offsets_.
	* output.h (class Output_section_data): Add non-const
	output_section function.
	(class Output_data_got): Update declarations.
	(class Output_data_got::Got_entry): Add use_plt_offset_ field.
	Add use_plt_offset parameter to global and local constructors.
	Change all callers.  Change local_sym_index_ field to 31 bits.
	Change GSYM_CODE and CONSTANT_CODE accordingly.
	* output.cc (Output_data_reloc_base::do_adjust_output_section): If
	doing a static link don't set sh_link field.
	(Output_data_got::Got_entry::write): Use PLT offset if
	appropriate.
	(Output_data_got::add_global_plt): New function.
	(Output_data_got::add_local_plt): New function.
	* target-reloc.h (relocate_section): Handle IFUNC symbol.
	* defstd.cc (in_section): Remove entries for __rel_iplt_start,
	__rel_iplt_end, __rela_iplt_start, and __rela_iplt_end.
	* configure.ac: Set IFUNC automake conditional for glibc >= 2.11.
	* testsuite/Makefile.am: Add a bunch of IFUNC tests, all within
	IFUNC conditional.
	* testsuite/ifunc-sel.h: New file.
	* testsuite/ifuncmain1.c: New file.
	* testsuite/ifuncmain1vis.c: New file.
	* testsuite/ifuncmod1.c: New file.
	* testsuite/ifuncdep2.c: New file.
	* testsuite/ifuncmain2.c: New file.
	* testsuite/ifuncmain3.c: New file.
	* testsuite/ifuncmod3.c: New file.
	* testsuite/ifuncmain4.c: New file.
	* testsuite/ifuncmain5.c: New file.
	* testsuite/ifuncmod5.c: New file.
	* testsuite/ifuncmain6pie.c: New file.
	* testsuite/ifuncmod6.c: New file.
	* testsuite/ifuncmain7.c: New file.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d1496 1
a1496 1
      const unsigned char *pshdr;
d1935 1
a1935 1
              gold_assert (os == NULL && secoffset == invalid_address);
d2098 1
a2098 1
  gold_assert (sd != NULL);
d2600 1
a2600 1
	      const unsigned char** start, int *read_size)
@


1.128
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_SYMTAB,
	SHT_GNU_INCREMENTAL_RELOCS.

gold/ChangeLog:

	* archive.cc: Include incremental.h.
	(Archive::Archive): Initialize incremental_info_.
	(Archive::include_member): Record archive members in incremental info.
	(Add_archive_symbols::run): Record begin and end of an archive in
	incremental info.
	(Lib_group::include_member): Record objects in incremental info.
	* archive.h (Incremental_archive_entry): Forward declaration.
	(Archive::set_incremental_info): New member function.
	(Archive::incremental_info): New member function.
	(Archive::Unused_symbol_iterator): New class.
	(Archive::unused_symbols_begin): New member function.
	(Archive::unused_symbols_end): New member function.
	(Archive::incremental_info_): New data member.
	* incremental-dump.cc (find_input_containing_global): New function.
	(dump_incremental_inputs): Dump new incremental info sections.
	* incremental.cc: Include symtab.h.
	(Output_section_incremental_inputs): New class.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Support
	new incremental info sections.
	(Sized_incremental_binary::do_check_inputs): Likewise.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): New function.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Rewrite.
	(Incremental_inputs::finalize): Do nothing but finalize string table.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Output_section_incremental_inputs::set_final_data_size): New function.
	(Output_section_incremental_inputs::do_write): New function.
	(Output_section_incremental_inputs::write_header): New function.
	(Output_section_incremental_inputs::write_input_files): New function.
	(Output_section_incremental_inputs::write_info_blocks): New function.
	(Output_section_incremental_inputs::write_symtab): New function.
	* incremental.h (Incremental_script_entry): Forward declaration.
	(Incremental_object_entry): Forward declaration.
	(Incremental_archive_entry): Forward declaration.
	(Incremental_inputs): Forward declaration.
	(Incremental_inputs_header_data): Remove.
	(Incremental_inputs_header): Remove.
	(Incremental_inputs_header_write): Remove.
	(Incremental_inputs_entry_data): Remove.
	(Incremental_inputs_entry): Remove.
	(Incremental_inputs_entry_write): Remove.
	(enum Incremental_input_type): Add INCREMENTAL_INPUT_ARCHIVE_MEMBER.
	(Incremental_binary::find_incremental_inputs_sections): Add parameters.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Sized_ncremental_binary::do_find_incremental_inputs_sections):
	Likewise.
	(Incremental_input_entry): New class.
	(Incremental_script_entry): New class.
	(Incremental_object_entry): New class.
	(Incremental_archive_entry): New class.
	(Incremental_inputs::Incremental_inputs): Initialize new data members.
	(Incremental_inputs::report_inputs): Remove.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): Change prototype.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Change prototype.
	(Incremental_inputs::get_reloc_count): New function.
	(Incremental_inputs::set_reloc_count): New function.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::inputs_section): New function.
	(Incremental_inputs::symtab_section): New function.
	(Incremental_inputs::relocs_section): New function.
	(Incremental_inputs::get_stringpool): Add const.
	(Incremental_inputs::command_line): Add const.
	(Incremental_inputs::inputs): Remove.
	(Incremental_inputs::command_line_key): New function.
	(Incremental_inputs::input_file_count): New function.
	(Incremental_inputs::input_files): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::Input_info): Remove.
	(Incremental_inputs::lock_): Remove.
	(Incremental_inputs::inputs_): Change type.
	(Incremental_inputs::inputs_map_): Remove.
	(Incremental_inputs::current_object_entry_): New data member.
	(Incremental_inputs::inputs_section_): New data member.
	(Incremental_inputs::symtab_section_): New data member.
	(Incremental_inputs::relocs_section_): New data member.
	(Incremental_inputs::reloc_count_): New data member.
	(Incremental_inputs_reader): New class.
	(Incremental_symtab_reader): New class.
	(Incremental_relocs_reader): New class.
	* layout.cc (Layout::finalize): Move finalization of incremental info
	and creation of incremental info sections to follow finalization of
	symbol table.  Set offsets for postprocessing sections.
	(Layout::create_incremental_info_sections): Call
	Incremental_inputs::create_data_sections.  Add incremental symtab
	and relocs sections.  Set sh_entsize and sh_link fields.  Arrange for
	sections to layout after input sections.
	* layout.h (struct Timespec): Forward declaration.
	(Layout::incremental_inputs): Add const.
	(Layout::create_incremental_info_sections): Add parameter.
	* main.cc (main): Remove call to Incremental_inputs::report_inputs.
	* object.cc: Include incremental.h.
	(Relobj::finalize_incremental_relocs): New function.
	(Sized_relobj::do_layout): Record input sections in incremental info.
	* object.h (Object::output_section): New function.
	(Object::output_section_offset): Moved from Relobj.
	(Object::get_incremental_reloc_base): New function.
	(Object::get_incremental_reloc_count): New function.
	(Object::do_output_section): New function.
	(Object::do_output_section_offset): Moved from Relobj.
	(Object::do_get_incremental_reloc_base): New function.
	(Object::do_get_incremental_reloc_count): New function.
	(Object::Object): Initialize new data members.
	(Relobj::output_section): Renamed do_output_section and moved to
	protected.
	(Relobj::output_section_offset): Moved to Object.
	(Relobj::do_get_incremental_reloc_base): New function.
	(Relobj::do_get_incremental_reloc_count): New function.
	(Relobj::allocate_incremental_reloc_counts): New function.
	(Relobj::count_incremental_reloc): New function.
	(Relobj::finalize_incremental_relocs): New function.
	(Relobj::next_incremental_reloc_index): New function.
	(Relobj::reloc_counts_): New data member.
	(Relobj::reloc_bases_): New data member.
	(Sized_relobj::do_relocate_sections): Add parameter.  Change caller.
	(Sized_relobj::relocate_sections): Add parameter.  Change all callers.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* plugin.cc (Plugin_manager::add_input_file): Rewrite test for
	incremental link.
	* readsyms.cc (Read_symbols::do_read_symbols): Move reporting of
	archives and object files elsewhere.
	(Add_symbols::run): Report object files here.
	(Finish_group::run): Report end of archive at end of group.
	* reloc.cc: Include layout.h, incremental.h.
	(Sized_relobj::do_read_relocs): Need relocations for incremental link.
	(Sized_relobj::do_scan_relocs): Record relocations for incremental link.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::do_relocate_sections): Write incremental relocations.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* script.cc (read_input_script): Rewrite test for incremental link.
	Change call to Incremental_inputs::report_script.
	* symtab.h (Symbol_table::first_global_index): New function.
	(Symbol_table::output_count): New function.
@
text
@d394 1
d1694 35
d1795 2
a2105 1

@


1.127
log
@	PR 11855
	* script.cc (Script_options::Script_options): Initialize
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_assignment): Update
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_reference): New function.
	(script_symbol): New function.
	* script.h (class Script_options): Add symbol_definitions_ and
	symbol_references_ fields.
	(Script_options::referenced_const_iterator): New type.
	(Script_options::referenced_begin): New function.
	(Script_options::referenced_end): New function.
	(Script_options::is_referenced): New function.
	(Script_options::any_unreferenced): New function.
	* script-c.h (script_symbol): Declare.
	* yyscript.y (exp): Call script_symbol.
	* symtab.cc: Include "script.h".
	(Symbol_table::gc_mark_undef_symbols): Add layout parameter.
	Change all callers.  Check symbols referenced by scripts.
	(Symbol_table::add_undefined_symbols_from_command_line): Add
	layout parameter.  Change all callers.
	(Symbol_table::do_add_undefined_symbols_from_command_line):
	Likewise.  Break out loop body.  Check symbols referenced by
	scripts.
	(Symbol_table::add_undefined_symbol_from_command_line): New
	function broken out of
	do_add_undefined_symbols_from_command_line.
	* symtab.h (class Symbol_table): Update declarations.
	* archive.cc: Include "layout.h".
	(Archive::should_include_member): Add layout parameter.  Change
	all callers.  Check for symbol mentioned in expression.
	* archive.h (class Archive): Update declaration.
	* object.cc (Sized_relobj::do_should_include_member): Add layout
	parameter.
	* object.h (Object::should_include_member): Add layout parameter.
	Change all callers.
	(Object::do_should_include_member): Add layout parameter.
	(class Sized_relobj): Update declaration.
	* dynobj.cc (Sized_dynobj::do_should_include_member): Add layout
	parameter.
	* dynobj.h (class Sized_dynobj): Update declaration.
	* plugin.cc (Sized_pluginobj::do_should_include_member): Add
	layout parameter.
	* plugin.h (class Sized_pluginobj): Update declaration.
@
text
@d43 1
d350 24
d1265 7
@


1.126
log
@	* compressed_output.cc (zlib_decompress): New function.
	(get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* compressed_output.h (get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info)
	Handle compressed debug sections.
	* layout.cc (is_compressed_debug_section): New function.
	(Layout::output_section_name): Map compressed section names to
	canonical names.
	* layout.h (is_compressed_debug_section): New function.
	(is_debug_info_section): Recognize compressed debug sections.
	* merge.cc: Include compressed_output.h.
	(Output_merge_data::do_add_input_section): Handle compressed
	debug sections.
	(Output_merge_string::do_add_input_section): Handle compressed
	debug sections.
	* object.cc: Include compressed_output.h.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(build_compressed_section_map): New function.
	(Sized_relobj::do_read_symbols): Handle compressed debug sections.
	* object.h (Object::section_is_compressed): New method.
	(Object::do_section_is_compressed): New method.
	(Sized_relobj::Compressed_section_map): New type.
	(Sized_relobj::do_section_is_compressed): New method.
	(Sized_relobj::compressed_sections_): New data member.
	* output.cc (Output_section::add_input_section): Handle compressed
	debug sections.
	* reloc.cc: Include compressed_output.h.
	(Sized_relobj::write_sections): Handle compressed debug sections.
@
text
@d1617 1
d1643 3
a1645 1
      Archive::Should_include t = Archive::should_include_member(symtab, name,
@


1.125
log
@	* object.cc (Sized_relobj::do_layout): Defer layout for reloc sections.
	(Sized_relobj::do_layout_deferred_sections): Do layout for deferred
	reloc sections.
	* object.h (Sized_relobj::deferred_layout_relocs_): New data member.

	PR 11683
	* symtab.h (Symbol::is_placeholder): New member function.
	* target-reloc.h (relocate_section): Check for placeholder symbols.

	* testsuite/Makefile.am (plugin_test_8): New test.
	(plugin_test_9): New test.
	* testsuite/Makefile.in: Regenerate.
@
text
@d42 1
d371 4
a374 1
    discarded_eh_frame_shndx_(-1U)
d502 44
d565 4
@


1.124
log
@2010-05-27  Doug Kwan  <dougkwan@@google.com>

	* object.cc (Sized_relobj::do_finalize_local_symbols): Use offset
	from start of output section instead of address for a local symbol
	in a merged or relaxed section when doing a relocatable link.
@
text
@d1374 11
d1485 30
@


1.123
log
@2010-05-26  Rafael Espindola  <espindola@@google.com>

       PR 11604
	* gold/object.cc(Sized_relobj::do_layout_deferred_sections): Avoid
	adding sections the garbage collector removed.
	* gold/testsuite/Makefile.am: Add test.
	* gold/testsuite/Makefile.in: Regenerate.
	* gold/testsuite/plugin_test_7.sh: New.
	* gold/testsuite/plugin_test_7_1.c: New.
	* gold/testsuite/plugin_test_7_2.c: New.
@
text
@d1830 6
a1835 1
		    lv.set_output_value(posd->address());
d1843 5
a1847 1
		  // of this input section.
d1849 2
a1850 1
		    new Merged_symbol_value<size>(lv.input_value(), start);
@


1.122
log
@	* archive.cc (include_member): Destroy Read_symbols_data object before
	releasing file.
	* object.cc (Read_symbols_data::~Read_symbols_data) New destructor.
	* object.h (Read_symbols_data::Read_symbols_data) New constructor.
	(Read_symbols_data::~Read_symbols_data) New destructor.
	(Section_relocs::Section_relocs) New constructor.
	(Section_relocs::~Section_relocs) New destructor.
	(Read_relocs_data::Read_relocs_data) New constructor.
	(Read_relocs_data::~Read_relocs_data) New destructor.
	* testsuite/binary_unittest.cc (Sized_binary_test): Set sd member
	pointers to NULL after deleting.
@
text
@d1464 5
@


1.121
log
@2010-03-22  Rafael Espindola  <espindola@@google.com>

	* archive.cc (Should_include): Move to archive.h.
	(should_include_member): Make it a member of Archive.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* archive.h: Include options.h.
	(Archive_member): Moved from Archive.
	(Should_include): Moved from archive.cc.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* dynobj.cc (do_should_include_member): New.
	* dynobj.h (do_should_include_member): New.
	* gold.cc (queue_initial_tasks): Update call to queue.
	* main.cc (main): Print lib group stats.
	* object.cc (do_should_include_member): New.
	* object.h: Include archive.h.
	(Object::should_include_member): New.
	(Object::do_should_include_member): New.
	(Sized_relobj::do_should_include_member): New.
	* options.cc (General_options::parse_start_lib): New.
	(General_options::parse_end_lib): New.
	(Input_arguments::add_file): Handle lib groups.
	(Input_arguments::start_group): Check we are not in a lib.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib): New.
	* options.h (General_options): Add start_lib and end_lib.
	(Input_argument::lib_): New.
	(Input_argument::lib): New.
	(Input_argument::is_lib): New.
	(Input_file_lib): New.
	(Input_arguments::in_lib_): New.
	(Input_arguments::in_lib): New.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib_): New.
	* plugin.cc (Pluginobj::get_symbol_resolution_info): Mark symbols
	in unused members as preempted.
	(Sized_pluginobj::do_should_include_member): New.
	* plugin.h (Sized_pluginobj::do_should_include_member): New.
	* readsyms.cc (Read_symbols::locks): If we are just reading a member,
	return the blocker.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::do_read_symbols): Handle lib groups.
	(Read_symbols::get_name): Handle lib groups.
	* readsyms.h (Read_symbols): Add an archive member pointer.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::member_): New.
	* script.cc (read_input_script): Update call to queue_soon.
@
text
@d46 22
@


1.120
log
@	* target-reloc.h (relocate_section): Check the symbol table index
	for -1U before setting the local symbol index.
	(scan_relocatable_relocs): If copying the relocation, record that
	the local symbol is required.
	* object.h (Symbol_value::is_output_symtab_index_set): New
	function.
	(Symbol_value::may_be_discarded_from_output_symtab): New
	function.
	(Symbol_value::has_output_symtab_entry): New function.
	(Symbol_value::needs_output_symtab_entry): Remove.
	(Symbol_value::output_symtab_index): Make sure the symbol index is
	set.
	(Symbol_value::set_output_symtab_index): Make sure the symbol
	index is not set.  Make sure the new index is valid.
	(Symbol_value::set_must_have_output_symtab_entry): New function.
	(Symbol_value::has_output_dynsym_entry): New function.
	(Symbol_value::set_output_dynsym_index): Make sure the new index
	is valid.
	(Sized_relobj::set_must_have_output_symtab_entry): New function.
	* object.cc (Sized_relobj::do_count_local_symbols): Only discard a
	local symbol if permitted.
	(Sized_relobj::do_finalize_local_symbols): Call
	is_output_symtab_index_set rather than needs_output_symtab_entry.
	(Sized_relobj::write_local_symbols): Call has_output_symtab_entry
	rather than needs_output_symtab_entry.  Call
	has_output_dynsym_entry rather than needs_output_dynsym_entry.
	* arm.cc (Arm_relobj::update_output_local_symbol_count): Call
	is_output_symtab_index_set rather than needs_output_symtab_entry.
	* testsuite/discard_locals_relocatable_test.c: New file.
	* testsuite/discard_locals_test.sh: Test -r.
	* testsuite/Makefile.am (check_DATA): Add
	discard_locals_relocatable_test1.syms,
	discard_local_relocatable_test2.syms.
	(MOSTLYCLEANFILES): Likewise.  Also add
	discard_locals_relocatable_test1.lout and
	discard_locals_relocatable_test2.out.
	(discard_locals_relocatable_test1.syms): New target.
	(discard_locals_relocatable_test.o): New target.
	(discard_locals_relocatable_test1.out): New target.
	(discard_locals_relocatable_test2.syms): New target.
	(discard_locals_relocatable_test2.out): New target.
	(various): Add missing ../ld-new dependencies.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1489 49
@


1.119
log
@Fix comment.
@
text
@d1594 1
a1594 1
      if (discard_all)
d1615 1
d1778 1
a1778 1
      if (lv.needs_output_symtab_entry())
d1941 1
a1941 1
	      if (lv.needs_output_symtab_entry() && !strip_all)
d1943 1
a1943 1
	      if (lv.needs_output_dynsym_entry())
d1950 1
a1950 1
      if (!strip_all && lv.needs_output_symtab_entry())
d1967 1
a1967 1
      if (lv.needs_output_dynsym_entry())
@


1.118
log
@	* object.cc (Sized_relobj::do_layout): Change to call layout_gnu_stack
	in the first pass of do_layout.
@
text
@d2193 3
a2195 3
      // --that gold does not support.  However, they cause no trouble
      // --unless there is a DT_NEEDED entry that we don't know about;
      // --warn only in that case.
@


1.117
log
@	* object.cc (Sized_relobj::do_layout): Don't get confused if
	layout_eh_frame returns NULL.
@
text
@d1324 1
a1324 1
  if (!is_gc_pass_one)
@


1.116
log
@	PR 11019
	* object.cc: Instantiate Xindex::initialize_symtab_xindex and
	Xindex::read_symtab_xindex.
@
text
@d1393 1
a1393 1
      if (offset == -1)
d1407 1
a1407 1
      if (offset == -1 && reloc_shndx[i] != 0)
@


1.115
log
@	* gc.h (Garbage_collection::Cident_section_map): New typedef.
	(Garbage_collection::cident_sections): New function.
	(Garbage_collection::add_cident_section): New function.
	(Garbage_collection::cident_sections_): New member.
	(gc_process_relocs): Add references to sections whose names are C
	identifiers.
	* gold.h (cident_section_start_prefix): New constant.
	(cident_section_stop_prefix): New constant.
	(is_cident): New function.
	* layout.cc (Layout::define_section_symbols): Replace string constants
	with the newly defined constants.
	* object.cc (Sized_relobj::do_layout): Track sections whose names are
	C identifiers.
	* testsuite/Makefile.am: Add gc_orphan_section_test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/gc_orphan_section_test.cc: New file.
	* testsuite/gc_orphan_section_test.sh: New file.
@
text
@d2527 44
@


1.114
log
@	PR 10980
	* options.h (class General_options): Add --cref.
	* main.cc (main): Print cref table if --cref.  Don't close mapfile
	until after printing cref table.
	* cref.cc: Include "symtab.h".
	(class Cref_inputs): Define Cref_table_compare and Cref_table.
	(Cref_table_compare::operator()): New function.
	(Cref_inputs::gather_cref): New function.
	(filecol): New static const.
	(Cref_inputs::print_cref): New function.
	(Cref::print_cref): New function.
	* cref.h: Include <cstdio>.
	(class Cref): Update declarations.
	* mapfile.h (Mapfile::file): New function.
	* object.h (class Object): Define Symbols.  Declare virtual
	do_get_global_symbols.
	(Object::get_global_symbols): New function.
	* object.cc (Input_objects::add_object): Pass object to cref_ if
	--cref.
	(Input_objects::archive_start): Likewise.
	(Input_objects::archive_stop): Likewise.
	(Input_objects::print_cref): New function.
	* dynobj.h (Sized_dynobj::do_get_global_symbols): New function.
	* dynobj.cc (big_endian>::do_add_symbols): Create symbols_ if
	--cref.
	* plugin.cc (Sized_pluginobj::do_get_global_symbols): New
	function.
	* plugin.h (class Sized_pluginobj): Update declarations.
@
text
@d1183 8
@


1.113
log
@	PR 10980
	* options.h (class General_options): Add --add-needed and
	--copy-dt-needed-entries.  Tweak --as-needed help entry.
	* object.cc (Input_objects::check_dynamic_dependencies): Give an
	error if --copy-dt-needed-entries aka --add-needed is used and
	would cause a change in behaviour.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d2149 2
a2150 1
  if (parameters->options().user_set_print_symbol_counts())
d2210 2
a2211 1
  if (parameters->options().user_set_print_symbol_counts())
d2224 2
a2225 1
  if (parameters->options().user_set_print_symbol_counts())
d2239 9
@


1.112
log
@	PR 10670
	* options.h (class General_options): Add -x/--discard-all.
	* object.cc (Sized_relobj::do_count_local_symbols): Handle
	--discard-all.  If the local symbol needs a dynamic entry, check
	that before handling --discard-locals.
@
text
@d2165 1
d2172 2
a2173 3
      for (Dynobj::Needed::const_iterator pneeded = needed.begin();
	   pneeded != needed.end();
	   ++pneeded)
d2182 19
@


1.111
log
@	* object.cc (Relobj::is_section_name_included): Fix formatting.
@
text
@d1530 1
d1554 1
a1554 1
	  || (shndx == this->discarded_eh_frame_shndx_))
d1577 15
a1603 1
      const char* name = pnames + sym.get_st_name();
a1623 7

      // If needed, add the symbol to the dynamic symbol table string pool.
      if (lv.needs_output_dynsym_entry())
        {
          dynpool->add(name, true, NULL);
          ++dyncount;
        }
@


1.110
log
@2009-12-16  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::scan_sections_for_stubs): Exclude ICF-eliminated
	sections.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Handle
	relaxed input sections.
	* output.cc (Output_section::find_relaxed_input_section): Change
	return type to Output_relaxed_input_section pointer.  Adjust code
	for new type of relaxed_input_section_map_.
	* output.h (Output_section::find_relaxed_input_section): Change
	return type to Output_relaxed_input_section pointer.
	(Output_section::Output_relaxed_input_section_by_input_section_map):
	New type.
	(Output_section::relaxed_input_section_map_): Change type to
	Output_section::Output_relaxed_input_section_by_input_section_map.
	* symtab.cc (Symbol_table::compute_final_value): Handle relaxed
	input section.
@
text
@d318 2
a319 2
      || (is_prefix_of(".gnu.linkonce.d", name) && 
            strstr(name, "personality")))
@


1.109
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d1686 9
a1694 1
              gold_assert(secoffset != invalid_address);
@


1.108
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d54 1
a54 1
Xindex::initialize_symtab_xindex(Object* object, unsigned int sym_tab_shndx)
d59 1
a59 1
  gold_assert(sym_tab_shndx != 0);
d68 1
a68 1
	  && this->adjust_shndx(object->section_link(i)) == sym_tab_shndx)
d180 2
a181 2
  const unsigned int sec_shnum = this->shnum();
  sd->section_headers = this->get_lasting_view(shoff, sec_shnum * shdr_size,
d200 1
a200 1
// If SNAME is the name of a special .gnu.warning section, arrange for
d205 1
a205 1
Object::handle_gnu_warning_section(const char* sname, unsigned int shndx,
d210 1
a210 1
  if (strncmp(sname, warn_prefix, warn_prefix_len) == 0)
d223 1
a223 1
	  const char* warning = sname + warn_prefix_len;
d228 1
a228 1
      symtab->add_warning(sname + warn_prefix_len, this, warning);
d234 1
a234 1
// If SNAME is the name of the special section which indicates that
d238 1
a238 1
Object::handle_split_stack_section(const char* sname)
d240 1
a240 1
  if (strcmp(sname, ".note.GNU-split-stack") == 0)
d245 1
a245 1
  if (strcmp(sname, ".note.GNU-no-split-stack") == 0)
d304 1
a304 1
Relobj::is_section_name_included(const char* sname)
d306 14
a319 14
  if (is_prefix_of(".ctors", sname) 
      || is_prefix_of(".dtors", sname) 
      || is_prefix_of(".note", sname) 
      || is_prefix_of(".init", sname) 
      || is_prefix_of(".fini", sname) 
      || is_prefix_of(".gcc_except_table", sname) 
      || is_prefix_of(".jcr", sname) 
      || is_prefix_of(".preinit_array", sname) 
      || (is_prefix_of(".text", sname) 
          && strstr(sname, "personality")) 
      || (is_prefix_of(".data", sname) 
          &&  strstr(sname, "personality")) 
      || (is_prefix_of(".gnu.linkonce.d", sname)
	  &&  strstr(sname, "personality")))
d330 3
a332 3
    const std::string& aname,
    Input_file* ainput_file,
    off_t aoffset,
d334 1
a334 1
  : Relobj(aname, ainput_file, aoffset),
d364 2
a365 2
  const unsigned int sec_shnum = this->elf_file_.shnum();
  this->set_shnum(sec_shnum);
d377 1
a377 1
  const unsigned int sec_shnum = this->shnum();
d379 1
a379 1
  if (sec_shnum > 0)
d383 2
a384 2
      const unsigned char* p = pshdrs + sec_shnum * This::shdr_size;
      unsigned int i = sec_shnum;
d454 1
a454 1
  const unsigned int sec_shnum = this->shnum();
d456 1
a456 1
  for (unsigned int i = 1; i < sec_shnum; ++i, p += This::shdr_size)
d468 2
a469 2
	  const char* aname = names + shdr.get_sh_name();
	  if (strcmp(aname, ".eh_frame") == 0)
d520 1
a520 1
  const int symsize = This::sym_size;
d524 1
a524 1
  section_offset_type locsize = loccount * symsize;
d607 1
a607 1
    Layout* alayout,
d609 1
a609 1
    const char* aname,
d700 3
a702 3
      include_group = alayout->find_or_add_kept_section(signature,
							this, index, true,
							true, &kept_section);
d795 2
a796 2
    alayout->layout_group(symtab, this, index, aname, signature.c_str(),
			  shdr, flags, &shndxes);
d819 1
a819 1
    Layout* alayout,
d821 1
a821 1
    const char* aname,
d835 2
a836 2
  if (strncmp(aname, linkonce_t, strlen(linkonce_t)) == 0)
    symname = aname + strlen(linkonce_t);
d838 1
a838 1
    symname = strrchr(aname, '.') + 1;
d840 1
a840 1
  std::string sig2(aname);
d843 4
a846 4
  bool include1 = alayout->find_or_add_kept_section(sig1, this, index, false,
						    false, &kept1);
  bool include2 = alayout->find_or_add_kept_section(sig2, this, index, false,
						    true, &kept2);
d890 1
a890 1
Sized_relobj<size, big_endian>::layout_section(Layout* alayout,
d892 1
a892 1
                                               const char* aname,
d897 3
a899 3
  off_t aoffset;
  Output_section* os = alayout->layout(this, shndx, aname, shdr,
				       reloc_shndx, reloc_type, &aoffset);
d902 1
a902 1
  if (aoffset == -1)
d905 1
a905 1
    this->section_offsets_[shndx] = convert_types<Address, off_t>(aoffset);
d910 1
a910 1
  if (aoffset == -1 && reloc_shndx != 0)
d931 1
a931 1
					  Layout* alayout,
d934 1
a934 1
  const unsigned int sec_shnum = this->shnum();
d951 1
a951 1
  if (sec_shnum == 0)
d959 1
a959 1
      this->copy_symbols_data(gc_sd, sd, This::shdr_size * sec_shnum);
d1019 2
a1020 2
  std::vector<unsigned int> reloc_shndx(sec_shnum, 0);
  std::vector<unsigned int> reloc_type(sec_shnum, elfcpp::SHT_NULL);
d1023 1
a1023 1
  for (unsigned int i = 1; i < sec_shnum; ++i, pshdrs += This::shdr_size)
d1035 1
a1035 1
	  if (target_shndx == 0 || target_shndx >= sec_shnum)
d1057 2
a1058 2
      out_sections.resize(sec_shnum);
      out_section_offsets.resize(sec_shnum);
d1087 1
a1087 1
  std::vector<bool> omit(sec_shnum, false);
d1091 2
a1092 2
  const bool emit_rels = (relocatable
			  || parameters->options().emit_relocs());
d1100 1
a1100 1
  for (unsigned int i = 1; i < sec_shnum; ++i, pshdrs += This::shdr_size)
d1111 1
a1111 1
      const char* sname = pnames + shdr.get_sh_name();
d1115 1
a1115 1
          if (this->handle_gnu_warning_section(sname, i, symtab))
d1124 1
a1124 1
          if (strcmp(sname, ".note.GNU-stack") == 0)
d1134 1
a1134 1
	  if (this->handle_split_stack_section(sname))
d1142 1
a1142 1
	  if (parameters->target().is_attributes_section(sname))
d1152 1
a1152 1
	          if (!this->include_section_group(symtab, alayout, i, sname, 
d1159 1
a1159 1
                       && Layout::is_linkonce(sname))
d1161 1
a1161 1
	          if (!this->include_linkonce_section(alayout, i, sname, shdr))
d1177 1
a1177 1
          if (is_section_name_included(sname)
d1191 1
a1191 1
      if (emit_rels
d1209 1
a1209 1
          && strcmp(sname, ".eh_frame") == 0
d1282 1
a1282 1
          this->deferred_layout_.push_back(Deferred_layout(i, sname, 
d1311 1
a1311 1
          this->layout_section(alayout, i, sname, shdr, reloc_shndx[i],
d1317 1
a1317 1
    alayout->layout_gnu_stack(seen_gnu_stack, gnu_stack_flags);
d1322 1
a1322 1
  if (emit_rels)
d1337 1
a1337 1
      if (data_shndx >= sec_shnum)
d1354 2
a1355 2
      Output_section* os = alayout->layout_reloc(this, i, shdr, data_section,
						 rr);
d1374 10
a1383 10
      off_t off;
      Output_section* os = alayout->layout_eh_frame(this,
						    symbols_data,
						    symbols_size,
						    symbol_names_data,
						    symbol_names_size,
						    i, shdr,
						    reloc_shndx[i],
						    reloc_type[i],
						    &off);
d1385 1
a1385 1
      if (off == -1)
d1394 1
a1394 1
        out_section_offsets[i] = convert_types<Address, off_t>(off);
d1399 1
a1399 1
      if (off == -1 && reloc_shndx[i] != 0)
d1425 1
a1425 1
Sized_relobj<size, big_endian>::do_layout_deferred_sections(Layout* alayout)
d1434 1
a1434 1
      this->layout_section(alayout, deferred->shndx_, deferred->name_.c_str(),
d1455 1
a1455 1
  const int symsize = This::sym_size;
d1457 2
a1458 2
		     / symsize);
  if (symcount * symsize != sd->symbols_size - sd->external_symbols_offset)
d1500 1
a1500 1
  const unsigned int sym_tab_shndx = this->symtab_shndx_;
d1502 1
a1502 1
				 this->elf_file_.section_header(sym_tab_shndx));
d1506 1
a1506 1
  const int symsize = This::sym_size;
d1509 1
a1509 1
  off_t locsize = loccount * symsize;
d1525 1
a1525 1
  unsigned int sec_shnum = this->shnum();
d1529 1
a1529 1
  psyms += symsize;
d1531 1
a1531 1
  for (unsigned int i = 1; i < loccount; ++i, psyms += symsize)
d1552 1
a1552 1
      if ((shndx < sec_shnum && out_sections[shndx] == NULL)
d1588 1
a1588 1
      const char* sname = pnames + sym.get_st_name();
d1592 1
a1592 1
	  && parameters->target().is_local_label_name(sname))
d1600 1
a1600 1
      if (!parameters->options().should_retain_symbol(sname))
d1607 1
a1607 1
      pool->add(sname, true, NULL);
d1613 1
a1613 1
          dynpool->add(sname, true, NULL);
d1641 1
a1641 1
  unsigned int sec_shnum = this->shnum();
d1665 1
a1665 1
	  if (shndx >= sec_shnum)
d1857 1
a1857 1
  const unsigned int sym_tab_shndx = this->symtab_shndx_;
d1859 1
a1859 1
				 this->elf_file_.section_header(sym_tab_shndx));
d1865 2
a1866 2
  const int symsize = This::sym_size;
  off_t locsize = loccount * symsize;
d1881 1
a1881 1
  off_t output_size = this->output_local_symbol_count_ * symsize;
d1886 1
a1886 1
  off_t dyn_output_size = this->output_local_dynsym_count_ * symsize;
d1898 2
a1899 2
  psyms += symsize;
  for (unsigned int i = 1; i < loccount; ++i, psyms += symsize)
d1930 2
a1931 2
          const char* sname = pnames + isym.get_st_name();
          osym.put_st_name(sympool->get_offset(sname));
d1938 1
a1938 1
          ov += symsize;
d1948 2
a1949 2
          const char* sname = pnames + isym.get_st_name();
          osym.put_st_name(dynpool->get_offset(sname));
d1956 1
a1956 1
          dyn_ov += symsize;
d1983 1
a1983 1
    off_t sym_offset,
d2001 2
a2002 2
  const int symsize = This::sym_size;
  const size_t count = symbols_size / symsize;
d2005 1
a2005 1
  for (size_t i = 0; i < count; ++i, p += symsize)
d2023 1
a2023 1
	  && static_cast<off_t>(sym.get_st_value()) <= sym_offset
d2025 1
a2025 1
	      > sym_offset))
d2068 2
a2069 2
      Address addr_offset = kept_relobj->get_output_section_offset(kept_shndx);
      if (os != NULL && addr_offset != invalid_address)
d2072 1
a2072 1
	  return os->address() + addr_offset;
@


1.107
log
@2009-12-05  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:

	* arm.h: Define enums for Tag_CPU_arch EABI attribute.

gold/ChangeLog:
	* arm.cc (Target_arm::arm_info): Initialize new fields
	attributes_section and attributes_vendor.
	* i386.cc (Target_i386::i386_info): Same.
	* object.cc (Sized_relobj::do_layout): Skip attribute section.
	* gold/powerpc.cc (Target_powerpc::powerpc_info): Initialize new
	fields attributes_section and attributes_vendor.
 	* sparc.cc (Target_sparc::sparc_info): Same.
	* target.h (Target::attributes_section, Target::attributes_vendor,
	Target::is_attributes_section, Target::attribute_arg_type,
	Target::attributes_order): New method definitions.
	(Target::Target_info::attributes_section,
	Target::Target_info::attributes_vendor): New fields.
	(Target::do_attribute_arg_type, Target::do_attributes_order): New
	virtual method definitions.
	* x86_64.cc (Target_x86_64::x86_64_info): Initialize new fields
	attributes_section and attributes_vendor.
	* testsuite/testfile.cc (Target_test::test_target_info): Same.
@
text
@d54 1
a54 1
Xindex::initialize_symtab_xindex(Object* object, unsigned int symtab_shndx)
d59 1
a59 1
  gold_assert(symtab_shndx != 0);
d68 1
a68 1
	  && this->adjust_shndx(object->section_link(i)) == symtab_shndx)
d180 2
a181 2
  const unsigned int shnum = this->shnum();
  sd->section_headers = this->get_lasting_view(shoff, shnum * shdr_size,
d200 1
a200 1
// If NAME is the name of a special .gnu.warning section, arrange for
d205 1
a205 1
Object::handle_gnu_warning_section(const char* name, unsigned int shndx,
d210 1
a210 1
  if (strncmp(name, warn_prefix, warn_prefix_len) == 0)
d223 1
a223 1
	  const char* warning = name + warn_prefix_len;
d228 1
a228 1
      symtab->add_warning(name + warn_prefix_len, this, warning);
d234 1
a234 1
// If NAME is the name of the special section which indicates that
d238 1
a238 1
Object::handle_split_stack_section(const char* name)
d240 1
a240 1
  if (strcmp(name, ".note.GNU-split-stack") == 0)
d245 1
a245 1
  if (strcmp(name, ".note.GNU-no-split-stack") == 0)
d304 1
a304 1
Relobj::is_section_name_included(const char* name)
d306 14
a319 14
  if (is_prefix_of(".ctors", name) 
      || is_prefix_of(".dtors", name) 
      || is_prefix_of(".note", name) 
      || is_prefix_of(".init", name) 
      || is_prefix_of(".fini", name) 
      || is_prefix_of(".gcc_except_table", name) 
      || is_prefix_of(".jcr", name) 
      || is_prefix_of(".preinit_array", name) 
      || (is_prefix_of(".text", name) 
          && strstr(name, "personality")) 
      || (is_prefix_of(".data", name) 
          &&  strstr(name, "personality")) 
      || (is_prefix_of(".gnu.linkonce.d", name) && 
            strstr(name, "personality")))
d330 3
a332 3
    const std::string& name,
    Input_file* input_file,
    off_t offset,
d334 1
a334 1
  : Relobj(name, input_file, offset),
d364 2
a365 2
  const unsigned int shnum = this->elf_file_.shnum();
  this->set_shnum(shnum);
d377 1
a377 1
  const unsigned int shnum = this->shnum();
d379 1
a379 1
  if (shnum > 0)
d383 2
a384 2
      const unsigned char* p = pshdrs + shnum * This::shdr_size;
      unsigned int i = shnum;
d454 1
a454 1
  const unsigned int shnum = this->shnum();
d456 1
a456 1
  for (unsigned int i = 1; i < shnum; ++i, p += This::shdr_size)
d468 2
a469 2
	  const char* name = names + shdr.get_sh_name();
	  if (strcmp(name, ".eh_frame") == 0)
d520 1
a520 1
  const int sym_size = This::sym_size;
d524 1
a524 1
  section_offset_type locsize = loccount * sym_size;
d607 1
a607 1
    Layout* layout,
d609 1
a609 1
    const char* name,
d700 3
a702 3
      include_group = layout->find_or_add_kept_section(signature,
						       this, index, true,
						       true, &kept_section);
d795 2
a796 2
    layout->layout_group(symtab, this, index, name, signature.c_str(),
			 shdr, flags, &shndxes);
d819 1
a819 1
    Layout* layout,
d821 1
a821 1
    const char* name,
d835 2
a836 2
  if (strncmp(name, linkonce_t, strlen(linkonce_t)) == 0)
    symname = name + strlen(linkonce_t);
d838 1
a838 1
    symname = strrchr(name, '.') + 1;
d840 1
a840 1
  std::string sig2(name);
d843 4
a846 4
  bool include1 = layout->find_or_add_kept_section(sig1, this, index, false,
						   false, &kept1);
  bool include2 = layout->find_or_add_kept_section(sig2, this, index, false,
						   true, &kept2);
d890 1
a890 1
Sized_relobj<size, big_endian>::layout_section(Layout* layout,
d892 1
a892 1
                                               const char* name,
d897 3
a899 3
  off_t offset;
  Output_section* os = layout->layout(this, shndx, name, shdr,
					  reloc_shndx, reloc_type, &offset);
d902 1
a902 1
  if (offset == -1)
d905 1
a905 1
    this->section_offsets_[shndx] = convert_types<Address, off_t>(offset);
d910 1
a910 1
  if (offset == -1 && reloc_shndx != 0)
d931 1
a931 1
					  Layout* layout,
d934 1
a934 1
  const unsigned int shnum = this->shnum();
d951 1
a951 1
  if (shnum == 0)
d959 1
a959 1
      this->copy_symbols_data(gc_sd, sd, This::shdr_size * shnum);
d1019 2
a1020 2
  std::vector<unsigned int> reloc_shndx(shnum, 0);
  std::vector<unsigned int> reloc_type(shnum, elfcpp::SHT_NULL);
d1023 1
a1023 1
  for (unsigned int i = 1; i < shnum; ++i, pshdrs += This::shdr_size)
d1035 1
a1035 1
	  if (target_shndx == 0 || target_shndx >= shnum)
d1057 2
a1058 2
      out_sections.resize(shnum);
      out_section_offsets.resize(shnum);
d1087 1
a1087 1
  std::vector<bool> omit(shnum, false);
d1091 2
a1092 2
  const bool emit_relocs = (relocatable
			    || parameters->options().emit_relocs());
d1100 1
a1100 1
  for (unsigned int i = 1; i < shnum; ++i, pshdrs += This::shdr_size)
d1111 1
a1111 1
      const char* name = pnames + shdr.get_sh_name();
d1115 1
a1115 1
          if (this->handle_gnu_warning_section(name, i, symtab))
d1124 1
a1124 1
          if (strcmp(name, ".note.GNU-stack") == 0)
d1134 1
a1134 1
	  if (this->handle_split_stack_section(name))
d1142 1
a1142 1
	  if (parameters->target().is_attributes_section(name))
d1152 1
a1152 1
	          if (!this->include_section_group(symtab, layout, i, name, 
d1159 1
a1159 1
                       && Layout::is_linkonce(name))
d1161 1
a1161 1
	          if (!this->include_linkonce_section(layout, i, name, shdr))
d1177 1
a1177 1
          if (is_section_name_included(name)
d1191 1
a1191 1
      if (emit_relocs
d1209 1
a1209 1
          && strcmp(name, ".eh_frame") == 0
d1282 1
a1282 1
          this->deferred_layout_.push_back(Deferred_layout(i, name, 
d1311 1
a1311 1
          this->layout_section(layout, i, name, shdr, reloc_shndx[i],
d1317 1
a1317 1
    layout->layout_gnu_stack(seen_gnu_stack, gnu_stack_flags);
d1322 1
a1322 1
  if (emit_relocs)
d1337 1
a1337 1
      if (data_shndx >= shnum)
d1354 2
a1355 2
      Output_section* os = layout->layout_reloc(this, i, shdr, data_section,
						rr);
d1374 10
a1383 10
      off_t offset;
      Output_section* os = layout->layout_eh_frame(this,
						   symbols_data,
						   symbols_size,
						   symbol_names_data,
						   symbol_names_size,
						   i, shdr,
						   reloc_shndx[i],
						   reloc_type[i],
						   &offset);
d1385 1
a1385 1
      if (offset == -1)
d1394 1
a1394 1
        out_section_offsets[i] = convert_types<Address, off_t>(offset);
d1399 1
a1399 1
      if (offset == -1 && reloc_shndx[i] != 0)
d1425 1
a1425 1
Sized_relobj<size, big_endian>::do_layout_deferred_sections(Layout* layout)
d1434 1
a1434 1
      this->layout_section(layout, deferred->shndx_, deferred->name_.c_str(),
d1455 1
a1455 1
  const int sym_size = This::sym_size;
d1457 2
a1458 2
		     / sym_size);
  if (symcount * sym_size != sd->symbols_size - sd->external_symbols_offset)
d1500 1
a1500 1
  const unsigned int symtab_shndx = this->symtab_shndx_;
d1502 1
a1502 1
				 this->elf_file_.section_header(symtab_shndx));
d1506 1
a1506 1
  const int sym_size = This::sym_size;
d1509 1
a1509 1
  off_t locsize = loccount * sym_size;
d1525 1
a1525 1
  unsigned int shnum = this->shnum();
d1529 1
a1529 1
  psyms += sym_size;
d1531 1
a1531 1
  for (unsigned int i = 1; i < loccount; ++i, psyms += sym_size)
d1552 1
a1552 1
      if ((shndx < shnum && out_sections[shndx] == NULL)
d1588 1
a1588 1
      const char* name = pnames + sym.get_st_name();
d1592 1
a1592 1
	  && parameters->target().is_local_label_name(name))
d1600 1
a1600 1
      if (!parameters->options().should_retain_symbol(name))
d1607 1
a1607 1
      pool->add(name, true, NULL);
d1613 1
a1613 1
          dynpool->add(name, true, NULL);
d1641 1
a1641 1
  unsigned int shnum = this->shnum();
d1665 1
a1665 1
	  if (shndx >= shnum)
d1857 1
a1857 1
  const unsigned int symtab_shndx = this->symtab_shndx_;
d1859 1
a1859 1
				 this->elf_file_.section_header(symtab_shndx));
d1865 2
a1866 2
  const int sym_size = This::sym_size;
  off_t locsize = loccount * sym_size;
d1881 1
a1881 1
  off_t output_size = this->output_local_symbol_count_ * sym_size;
d1886 1
a1886 1
  off_t dyn_output_size = this->output_local_dynsym_count_ * sym_size;
d1898 2
a1899 2
  psyms += sym_size;
  for (unsigned int i = 1; i < loccount; ++i, psyms += sym_size)
d1930 2
a1931 2
          const char* name = pnames + isym.get_st_name();
          osym.put_st_name(sympool->get_offset(name));
d1938 1
a1938 1
          ov += sym_size;
d1948 2
a1949 2
          const char* name = pnames + isym.get_st_name();
          osym.put_st_name(dynpool->get_offset(name));
d1956 1
a1956 1
          dyn_ov += sym_size;
d1983 1
a1983 1
    off_t offset,
d2001 2
a2002 2
  const int sym_size = This::sym_size;
  const size_t count = symbols_size / sym_size;
d2005 1
a2005 1
  for (size_t i = 0; i < count; ++i, p += sym_size)
d2023 1
a2023 1
	  && static_cast<off_t>(sym.get_st_value()) <= offset
d2025 1
a2025 1
	      > offset))
d2068 2
a2069 2
      Address offset = kept_relobj->get_output_section_offset(kept_shndx);
      if (os != NULL && offset != invalid_address)
d2072 1
a2072 1
	  return os->address() + offset;
@


1.106
log
@2009-11-10  Doug Kwan  <dougkwan@@google.com>

	* i386.cc (Target_i386::do_calls_non_split): Add a cast to avoid
	a format warning.
	* incremental.cc (open_incremental_binary): Initialized local
	variables to avoid warnings.
	* object.cc (make_elf_object): Ditto.
	* x86_64.cc (Target_x86_64::do_calls_non_split): Add a cast to avoid
	a format warning.
@
text
@d1141 6
@


1.105
log
@2009-10-20  Doug Kwan  <dougkwan@@google.com>

	* object.cc (Sized_relobj::do_finalize_local_symbols): Handle section
	symbols of relaxed input sections.
	* output.h (Output_section::find_relaxed_input_section): Make
	method public.
@
text
@d2313 2
a2314 2
  bool big_endian;
  int size;
@


1.104
log
@	* gc.h (gc_process_relocs): Check if icf is enabled using new
	function.
	* gold.cc (queue_initial_tasks): Likewise.
	(queue_middle_tasks): Likewise.
	* object.cc (do_layout): Likewise.
	* symtab.cc (is_section_folded): Likewise.
	* main.cc (main): Likewise.
	* reloc.cc (Read_relocs::run): Likewise.
	(Sized_relobj::do_scan_relocs): Likewise.
	* icf.cc (is_function_ctor_or_dtor): New function.
	(Icf::find_identical_sections): Check if function is ctor or dtor when
	safe icf is chosen.
	* options.h (General_options::icf): Change option to be an enum.
	(Icf_status): New enum.
	(icf_enabled): New method.
	(icf_safe_folding): New method.
	(set_icf_status): New method.
	(icf_status_): New variable.
	* (options.cc) (General_options::finalize): Set icf_status_.
	* testsuite/Makefile.am: Add commands to build icf_safe_test. Modify
	icf_test and icf_keep_unique_test to use the --icf enum flag.
	* testsuite/icf_safe_test.sh: New file.
	* testsuite/icf_safe_test.cc: New file.
@
text
@d1714 12
a1725 6
		  // This is a section symbol, but apparently not one
		  // in a merged section.  Just use the start of the
		  // output section.  This happens with relocatable
		  // links when the input object has section symbols
		  // for arbitrary non-merge sections.
		  lv.set_output_value(os->address());
@


1.103
log
@2009-10-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::make_output_section): Call target hook to make
	ordinary output section.
	(Layout::finalize): Adjust parameter list of call the
	Target::may_relax().
	* layout.h (class Layout::section_list): New method.
	* merge.h (Output_merge_base::entsize): Change visibility to public.
	(Output_merge_base::is_string, Output_merge_base::do_is_string):
	New methods.
	(Output_merge_string::do_is_string): New method.
	* object.cc (Sized_relobj::do_setup): renamed from
	Sized_relobj::set_up.
	* object.h (Sized_relobj::adjust_shndx,
	Sized_relobj::initializ_input_to_output_maps,
	Sized_relobj::free_input_to_output_maps): Change visibilities to
	protected.
	(Sized_relobj::setup): Virtualize.
	(Sized_relobj::do_setup): New method declaration.
	(Sized_relobj::invalidate_section_offset,
	Sized_relobj::do_invalidate_section_offset): New method decfinitions.
	(Sized_relobj::elf_file, Sized_relobj::local_values): New methods.
	* options.cc (parse_int): New function.
	* options.h (parse_int): New declaration.
	(DEFINE_int): New macro.
	(stub_group_size): New option.
	* output.cc (Output_section::Output_section): Initialize memebers
	merge_section_map_, merge_section_by_properties_map_,
	relaxed_input_section_map_, is_relaxed_input_section_map_valid_.
	(Output_section::add_input_section): Handled deferred code-fill
	generation and remove an old comment.
	(Output_section::add_relaxed_input_section): New method definition.
	(Output_section::add_merge_input_section): Use merge section by
	properties map to speed to search.  Update merge section maps
	as appropriate.
	(Output_section::build_relaxation_map): New method definition.
	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Same.
	(Output_section::relax_input_section): Renamed to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of pointers to relaxed sections.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section): New method definitions.
	(Output_section::is_input_address_mapped,
	Output_section::output_offset, Output_section::output_address):
	Use output section data maps to speed up searching.
	(Output_section::find_starting_output_address): Add comments.
	(Output_section::do_write,
	Output_section::write_to_postprocessing_buffer): Do code-fill
	generation as appropriate.
	(Output_section::get_input_sections): Invalidate relaxed input section
	map.
	(Output_section::restore_states): Adjust type of checkpoint .
	Invalidate relaxed input section map.
	* output.h (Output_merge_base): New class declaration.
	(Input_section_specifier): New class defintion.
	(class Output_relaxed_input_section) Change base class to
	Output_section_data_build.
	(Output_relaxed_input_section::Output_relaxed_input_section): Adjust
	base class initializer.
	(Output_section::add_relaxed_input_section): New method declaration.
	(Output_section::Input_section): Change visibility to protected.
     	(Output_section::Input_section::relobj,
	Output_section::Input_section::shndx): Handle relaxed input sections.
	Output_section::input_sections) Change visibility to protected.  Also
	define overload to return a non-const pointer.
	(Output_section::Merge_section_properties): New class defintion.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Relaxation_map): New types.
	(Output_section::relax_input_section): Rename method to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of relaxed section pointers.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section,
	Output_section::build_relaxation_map,
	Output_section::convert_input_sections_in_list_to_relaxed_sections):
	New method declarations.
	(Output_section::merge_section_map_
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_,
	Output_section::generate_code_fills_at_write_): New data members.
	* script-sections.cc
	(Output_section_element_input::set_section_addresses): Call
	current_data_size and addralign methods of relaxed input sections.
	(Orphan_output_section::set_section_addresses): Call current_data_size
	and addralign methods of relaxed input sections.
	* symtab.cc (Symbol_table::compute_final_value): Extract template
	from the body of Symbol_table::sized_finalize_symbol.
	(Symbol_table::sized_finalized_symbol): Call
	Symbol_table::compute_final_value.
	* symtab.h (Symbol_table::Compute_final_value_status): New enum type.
	(Symbol_table::compute_final_value): New templated method declaration.
	* target.cc (Target::do_make_output_section): New method defintion.
	* target.h (Target::make_output_section): New method declaration.
	(Target::relax): Add more parameters for input objects, symbol table
	and layout.  Adjust call to do_relax.
	(Target::do_make_output_section): New method declaration.
	(Target::do_relax): Add parameters for input objects, symbol table
	and layout.
@
text
@d937 1
a937 1
                         || (parameters->options().icf()
d942 1
a942 1
                         || (parameters->options().icf()
d946 1
a946 1
                       || parameters->options().icf()); 
d1241 1
a1241 1
      if (is_gc_pass_two && parameters->options().icf())
@


1.102
log
@elfcpp/:
	* elfcpp_file.h: Fix header guard.  Include <cstdio>.
	(class Elf_recognizer): New class, code from gold/object.cc.
	(Elf_file::find_section_by_type): New method.
gold/:
	* incremental.cc: Include <cstdarg> and "target-select.h".
	(vexplain_no_incremental): New function.
	(explain_no_incremental): New function.
	(Incremental_binary::error): New method.
	(Sized_incremental_binary::do_find_incremental_inputs_section): New
	method.
	(make_sized_incremental_binary): New function.
	(open_incremental_binary): New function.
	(can_incrementally_link_file): Add checks if output is ELF and has
	inputs section.
	* incremental.h: Include "elfcpp_file.h" and "output.h".
	(Incremental_binary): New class.
	(Sized_incremental_binary): New class.
	(open_incremental_binary): Declare.
	* object.cc (is_elf_object): Use
	elfcpp::Elf_recognizer::is_elf_file.
	(make_elf_object): Use elfcpp::Elf_recognizer::is_valid_header.
	* output.h (Output_file::filesize): New method.
@
text
@d362 1
a362 1
Sized_relobj<size, big_endian>::setup()
@


1.101
log
@	* options.h (class General_options): Define
	split_stack_adjust_size parameter.
	* object.h (class Object): Add uses_split_stack_ and
	has_no_split_stack_ fields.  Add uses_split_stack and
	has_no_split_stack accessor functions.  Declare
	handle_split_stack_section.
	(class Reloc_symbol_changes): Define.
	(class Sized_relobj): Define Function_offsets.  Declare
	split_stack_adjust, split_stack_adjust_reltype, and
	find_functions.
	* object.cc (Object::handle_split_stack_section): New function.
	(Sized_relobj::do_layout): Call handle_split_stack_section.
	* dynobj.cc (Sized_dynobj::do_layout): Call
	handle_split_stack_section.
	* reloc.cc (Sized_relobj::relocate_sections): Call
	split_stack_adjust for executable sections in split_stack
	objects.  Pass reloc_map to relocate_section.
	(Sized_relobj::split_stack_adjust): New function.
	(Sized_relobj::split_stack_adjust_reltype): New function.
	(Sized_relobj::find_functions): New function.
	* target-reloc.h: Include "object.h".
	(relocate_section): Add reloc_symbol_changes parameter.  Change
	all callers.
	* target.h (class Target): Add calls_non_split method.  Declare
	do_calls_non_split virtual method.  Declare match_view and
	set_view_to_nop.
	* target.cc: Include "elfcpp.h".
	(Target::do_calls_non_split): New function.
	(Target::match_view): New function.
	(Target::set_view_to_nop): New function.
	* gold.cc (queue_middle_tasks): Give an error if mixing
	split-stack and non-split-stack objects with -r.
	* i386.cc (Target_i386::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_i386::do_calls_non_split): New function.
	* x86_64.cc (Target_x86_64::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_x86_64::do_calls_non_split): New function.
	* arm.cc (Target_arm::relocate_section): Add reloc_symbol_changes
	parameter.
	* powerpc.cc (Target_powerpc::relocate_section): Add
	reloc_symbol_changes parameter.
	* sparc.cc (Target_sparc::relocate_section): Add
	reloc_symbol_changes parameter.
	* configure.ac: Call AM_CONDITIONAL for the default target.
	* configure: Rebuild.
	* testsuite/Makefile.am (TEST_AS): New variable.
	(check_SCRIPTS): Add split_i386.sh and split_x86_64.sh.
	(check_DATA): Add split_i386 and split_x86_64 files.
	(SPLIT_DEFSYMS): Define.
	(split_i386_[1234n].o): New targets.
	(split_i386_[124]): New targets.
	(split_i386_[1234r].stdout): New targets.
	(split_x86_64_[1234n].o): New targets.
	(split_x86_64_[124]): New targets.
	(split_x86_64_[1234r].stdout): New targets.
	(MOSTLYCLEANFILES): Add new executables.
	* testsuite/split_i386.sh: New file.
	* testsuite/split_x86_64.sh: New file.
	* testsuite/split_i386_1.s: New file.
	* testsuite/split_i386_2.s: New file.
	* testsuite/split_i386_3.s: New file.
	* testsuite/split_i386_4.s: New file.
	* testsuite/split_i386_n.s: New file.
	* testsuite/split_x86_64_1.s: New file.
	* testsuite/split_x86_64_2.s: New file.
	* testsuite/split_x86_64_3.s: New file.
	* testsuite/split_x86_64_4.s: New file.
	* testsuite/split_x86_64_n.s: New file.
	* testsuite/testfile.cc (Target_test): Update relocation_section
	function.
	* testsuite/Makefile.in: Rebuild.
@
text
@d2284 1
a2284 1
  int want = elfcpp::Elf_sizes<64>::ehdr_size;
d2293 1
a2293 9
  if (want < 4)
    return false;

  static unsigned char elfmagic[4] =
    {
      elfcpp::ELFMAG0, elfcpp::ELFMAG1,
      elfcpp::ELFMAG2, elfcpp::ELFMAG3
    };
  return memcmp(p, elfmagic, 4) == 0;
d2306 5
a2310 37
  if (bytes < elfcpp::EI_NIDENT)
    {
      gold_error(_("%s: ELF file too short"), name.c_str());
      return NULL;
    }

  int v = p[elfcpp::EI_VERSION];
  if (v != elfcpp::EV_CURRENT)
    {
      if (v == elfcpp::EV_NONE)
	gold_error(_("%s: invalid ELF version 0"), name.c_str());
      else
	gold_error(_("%s: unsupported ELF version %d"), name.c_str(), v);
      return NULL;
    }

  int c = p[elfcpp::EI_CLASS];
  if (c == elfcpp::ELFCLASSNONE)
    {
      gold_error(_("%s: invalid ELF class 0"), name.c_str());
      return NULL;
    }
  else if (c != elfcpp::ELFCLASS32
	   && c != elfcpp::ELFCLASS64)
    {
      gold_error(_("%s: unsupported ELF class %d"), name.c_str(), c);
      return NULL;
    }

  int d = p[elfcpp::EI_DATA];
  if (d == elfcpp::ELFDATANONE)
    {
      gold_error(_("%s: invalid ELF data encoding"), name.c_str());
      return NULL;
    }
  else if (d != elfcpp::ELFDATA2LSB
	   && d != elfcpp::ELFDATA2MSB)
d2312 1
a2312 1
      gold_error(_("%s: unsupported ELF data encoding %d"), name.c_str(), d);
d2316 1
a2316 3
  bool big_endian = d == elfcpp::ELFDATA2MSB;

  if (c == elfcpp::ELFCLASS32)
a2317 5
      if (bytes < elfcpp::Elf_sizes<32>::ehdr_size)
	{
	  gold_error(_("%s: ELF file too short"), name.c_str());
	  return NULL;
	}
d2351 1
a2351 1
  else
a2352 5
      if (bytes < elfcpp::Elf_sizes<64>::ehdr_size)
	{
	  gold_error(_("%s: ELF file too short"), name.c_str());
	  return NULL;
	}
d2386 2
@


1.100
log
@	* object.h (class Object): Remove target_ field, and target,
	sized_target, and set_target methods.
	(Object::sized_target): Remove.
	(class Sized_relobj): Update declarations.  Remove sized_target.
	* object.cc (Sized_relobj::setup): Remove target parameter.
	Change all callers.
	(Input_objects::add_object): Don't do anything with the target.
	(make_elf_sized_object): Add punconfigured parameter.  Change all
	callers.  Set or test parameter target.
	* dynobj.cc (Sized_dynobj::target): Remove target parameter.
	Change all callers.
	* parameters.cc (Parameters::set_target): Change parameter type to
	be non-const.
	(Parameters::default_target): Remove.
	(set_parameters_target): Change parameter type to be non-const.
	(parameters_force_valid_target): New function.
	(parameters_clear_target): New function.
	* parameters.h (class Parameters): Update declarations.  Remove
	default_target method.  Add sized_target and clear_target
	methods.  Change target_ to be non-const.
	(set_parameters_target): Update declaration.
	(parameters_force_valid_target): Declare.
	(parameters_clear_target): Declare.
	* readsyms.cc (Read_symbols::do_read_symbols): Pass punconfigured
	as NULL if we aren't searching.
	(Add_symbols::run): Don't check for compatible target.
	* fileread.cc (Input_file::open_binary): Call
	parameters_force_valid_target.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (make_sized_plugin_object): Likewise.  Don't call
	set_target on object.
	* dynobj.h (class Sized_dynobj): Update declarations.
	* archive.cc (Archive::get_elf_object_for_member): Return NULL if
	make_elf_object returns NULL.
	(Archive::include_member): Don't check whether object target is
	compatible.
	* output.cc (Output_section::add_input_section): Get target from
	parameters.
	(Output_section::relax_input_section): Likewise.
	* reloc.cc (Sized_relobj::do_gc_process_relocs): Get target from
	parameters.
	(Sized_relobj::do_scan_relocs): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* symtab.cc (Symbol_table::wrap_symbol): Likewise.  Remove object
	parameter.  Change all callers.
	(Symbol_table::add_from_object): Get target from parameters.
	(Symbol_table::add_from_relobj): Don't check object target.
	(Symbol_table::add_from_dynobj): Likewise.
	(Symbol_table::define_special_symbol): Get target from
	parameters.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/binary_unittest.cc (gold_testsuite): Remove target
	parameter.  Change all callers.  Clear parameter target.
	(Binary_test): Test target here.
	* testsuite/object_unittest.cc (gold_testsuite): Remove
	target_test_pointer parameter.  Change all callers.
	(Object_test): Test target here.
@
text
@d234 19
d1131 10
@


1.99
log
@	* object.cc (Sized_relobj::do_count): Test should_retain_symbol map.
	* options.cc: Include <cerrno> and <fstream>.
	(General_options::finalize): Parse -retain-symbols-file tag.
	* options.h: New flag.
	(General_options): New method should_retain_symbol, new
	variable symbols_to_retain.
	* symtab.cc (Symbol_table::sized_finalize_symbol): Test
	should_retain_symbol map.
	* testsuite/Makefile.am (retain_symbols_file_test): New test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/retain_symbols_file_test.sh: New file.
@
text
@d339 1
a339 1
// target and reads the section information.
d343 1
a343 1
Sized_relobj<size, big_endian>::setup(Target *target)
a344 2
  this->set_target(target);

a2067 10
  // Set the global target from the first object file we recognize.
  Target* target = obj->target();
  if (!parameters->target_valid())
    set_parameters_target(target);
  else if (target != &parameters->target())
    {
      obj->error(_("incompatible target"));
      return false;
    }

d2218 2
a2219 1
		      off_t offset, const elfcpp::Ehdr<size, big_endian>& ehdr)
d2227 12
d2341 1
a2341 1
						 offset, ehdr);
d2357 1
a2357 1
						  offset, ehdr);
d2381 1
a2381 1
						 offset, ehdr);
d2397 1
a2397 1
						  offset, ehdr);
@


1.98
log
@2009-08-18  Doug Kwan  <dougkwan@@google.com>

	* dynobj.cc (Sized_dynobj::setup): Take a Target object instead of
	an elcpp::Ehdr as parameter.  Adjust call to set_target.
	* dynobj.h (Sized_dynobj::setup): Take a Target object instead of
	an elfcpp::Ehdr as parameter.
	* object.cc (Object::set_target): Remove the version that looks up
	a target and sets it.
	(Sized_relobj::setup): Take a Target object instead of
	an elfcpp::Ehdr as parameter.  Adjust call to set_target.
	(make_elf_sized_object): Find target and ask target to
	make an ELF object.
	* object.h: (Object::set_target): Remove the version that looks up
	a target and sets it.
	(Sized_relobj::setup): Take a Target object instead of
	an elfcpp:Ehdr as parameter.
	* target.cc: Include dynobj.h.
	(Target::do_make_elf_object_implementation): New.
 	(Target::do_make_elf_object): New.
	* target.h (Target::make_elf_object): New template declaration.
	(Target::do_make_elf_object): New method declarations.
	(Target::do_make_elf_object_implementation): New template declaration.
@
text
@d1565 8
@


1.98.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a233 19
// If NAME is the name of the special section which indicates that
// this object was compiled with -fstack-split, mark it accordingly.

bool
Object::handle_split_stack_section(const char* name)
{
  if (strcmp(name, ".note.GNU-split-stack") == 0)
    {
      this->uses_split_stack_ = true;
      return true;
    }
  if (strcmp(name, ".note.GNU-no-split-stack") == 0)
    {
      this->has_no_split_stack_ = true;
      return true;
    }
  return false;
}

d339 1
a339 1
// section information.
d343 1
a343 1
Sized_relobj<size, big_endian>::do_setup()
d345 2
d920 1
a920 1
                         || (parameters->options().icf_enabled()
d925 1
a925 1
                         || (parameters->options().icf_enabled()
d929 1
a929 1
                       || parameters->options().icf_enabled()); 
a1113 10
	  // The .note.GNU-split-stack section is also special.  It
	  // indicates that the object was compiled with
	  // -fsplit-stack.
	  if (this->handle_split_stack_section(name))
	    {
	      if (!parameters->options().relocatable()
		  && !parameters->options().shared())
		omit[i] = true;
	    }

d1214 1
a1214 1
      if (is_gc_pass_two && parameters->options().icf_enabled())
a1564 8
      // Discard the local symbol if -retain_symbols_file is specified
      // and the local symbol is not in that file.
      if (!parameters->options().should_retain_symbol(name))
        {
          lv.set_no_output_symtab_entry();
          continue;
        }

d2062 10
d2222 1
a2222 2
		      off_t offset, const elfcpp::Ehdr<size, big_endian>& ehdr,
		      bool* punconfigured)
a2229 12

  if (!parameters->target_valid())
    set_parameters_target(target);
  else if (target != &parameters->target())
    {
      if (punconfigured != NULL)
	*punconfigured = true;
      else
	gold_error(_("%s: incompatible target"), name.c_str());
      return NULL;
    }

d2246 1
a2246 1
  int want = elfcpp::Elf_recognizer::max_header_size;
d2255 9
a2263 1
  return elfcpp::Elf_recognizer::is_elf_file(p, want);
d2276 31
a2306 5
  std::string error;
  bool big_endian;
  int size;
  if (!elfcpp::Elf_recognizer::is_valid_header(p, bytes, &size,
                                               &big_endian, &error))
d2308 1
a2308 1
      gold_error(_("%s: %s"), name.c_str(), error.c_str());
d2311 8
d2320 1
a2320 1
  if (size == 32)
d2322 5
d2332 1
a2332 1
						 offset, ehdr, punconfigured);
d2348 1
a2348 1
						  offset, ehdr, punconfigured);
d2360 1
a2360 1
  else if (size == 64)
d2362 5
d2372 1
a2372 1
						 offset, ehdr, punconfigured);
d2388 1
a2388 1
						  offset, ehdr, punconfigured);
a2399 2
  else
    gold_unreachable();
@


1.98.2.2
log
@	Bring over from mainline:
	2010-01-04  Ian Lance Taylor  <iant@@google.com>

	PR 10980
	* options.h (class General_options): Add --add-needed and
	--copy-dt-needed-entries.  Tweak --as-needed help entry.
	* object.cc (Input_objects::check_dynamic_dependencies): Give an
	error if --copy-dt-needed-entries aka --add-needed is used and
	would cause a change in behaviour.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
a2136 1
  bool issued_copy_dt_needed_error = false;
d2143 3
a2145 2
      Dynobj::Needed::const_iterator pneeded;
      for (pneeded = needed.begin(); pneeded != needed.end(); ++pneeded)
a2153 19

      // --copy-dt-needed-entries aka --add-needed is a GNU ld option
      // --that gold does not support.  However, they cause no trouble
      // --unless there is a DT_NEEDED entry that we don't know about;
      // --warn only in that case.
      if (!found_all
	  && !issued_copy_dt_needed_error
	  && (parameters->options().copy_dt_needed_entries()
	      || parameters->options().add_needed()))
	{
	  const char* optname;
	  if (parameters->options().copy_dt_needed_entries())
	    optname = "--copy-dt-needed-entries";
	  else
	    optname = "--add-needed";
	  gold_error(_("%s is not supported but is required for %s in %s"),
		     optname, (*pneeded).c_str(), (*p)->name().c_str());
	  issued_copy_dt_needed_error = true;
	}
@


1.97
log
@*** empty log message ***
@
text
@a134 13
// Set the target based on fields in the ELF file header.

void
Object::set_target(int machine, int size, bool big_endian, int osabi,
		   int abiversion)
{
  Target* target = select_target(machine, size, big_endian, osabi, abiversion);
  if (target == NULL)
    gold_fatal(_("%s: unsupported ELF machine number %d"),
	       this->name().c_str(), machine);
  this->target_ = target;
}

d343 1
a343 2
Sized_relobj<size, big_endian>::setup(
    const elfcpp::Ehdr<size, big_endian>& ehdr)
d345 1
a345 3
  this->set_target(ehdr.get_e_machine(), size, big_endian,
		   ehdr.get_e_ident()[elfcpp::EI_OSABI],
		   ehdr.get_e_ident()[elfcpp::EI_ABIVERSION]);
d2224 8
a2231 21
  int et = ehdr.get_e_type();
  if (et == elfcpp::ET_REL)
    {
      Sized_relobj<size, big_endian>* obj =
	new Sized_relobj<size, big_endian>(name, input_file, offset, ehdr);
      obj->setup(ehdr);
      return obj;
    }
  else if (et == elfcpp::ET_DYN)
    {
      Sized_dynobj<size, big_endian>* obj =
	new Sized_dynobj<size, big_endian>(name, input_file, offset, ehdr);
      obj->setup(ehdr);
      return obj;
    }
  else
    {
      gold_error(_("%s: unsupported ELF file type %d"),
		 name.c_str(), et);
      return NULL;
    }
@


1.96
log
@	PR 10400
	* layout.h: #include <map>.
	(class Kept_section): Change from struct to class.  Add accessors
	and setters.  Add section size to Comdat_group mapping.  Change
	Comdat_group to std::map.  Add is_comdat_ field.  Add
	linkonce_size field in union.
	(class Layout): Update declaration of find_or_add_kept_section.
	Don't declare find_kept_object.
	* layout.cc (Layout::find_or_add_kept_section): Remove candidate
	parameter.  Add object, shndx, is_comdat, and is_group_name
	parameters.  Change all callers.  Adjust for new Kept_section.
	(Layout::find_kept_object): Remove.
	* object.cc (Sized_relobj::include_section_group): Update use of
	Kept_section.  Rename secnum to shndx.  Only record
	Kept_comdat_section if sections are the same size.
	(Sized_relobj::include_linkonce_section): Update use of
	Kept_section.  Only record Kept_comdat_section if sections are the
	same size.  Set size of linkonce section.
	(Sized_relobj::map_to_kept_section): Update call to
	get_kept_comdat_section.
	* object.h (class Sized_relobj): Rename fields in
	Kept_comdat_section to drop trailing underscores; change object
	field to Relobj*.  Change Kept_comdat_section_table to store
	struct rather than pointer.
	(Sized_relobj::set_kept_comdat_section): Remove kept parameter.
	Add kept_object and kept_shndx parameters.  Change all callers.
	(Sized_relobj::get_kept_comdat_section): Change return type to
	bool.  Add kept_object and kept_shndx parameters.  Change all
	callers.
	* plugin.cc (Pluginobj::include_comdat_group): Update call to
	Layout::find_or_add_kept_section.
@
text
@d917 9
a925 8
// During garbage collection (gc-sections), this function is called
// twice.  When it is called the first time, it is for setting up some
// sections as roots to a work-list and to do comdat processing.  Actual
// layout happens the second time around after all the relevant sections
// have been determined.  The first time, is_worklist_ready is false.  
// It is then set to true after the worklist is processed and the relevant 
// sections are determined.  Then, this function is called again to 
// layout the sections.
d934 16
a949 4
  bool is_gc_pass_one = (parameters->options().gc_sections() 
                         && !symtab->gc()->is_worklist_ready());
  bool is_gc_pass_two = (parameters->options().gc_sections() 
                         && symtab->gc()->is_worklist_ready());
d974 1
a974 1
  if (parameters->options().gc_sections())
d1002 4
a1005 3
  const unsigned char* pnamesu = parameters->options().gc_sections() ?
                                 gc_sd->section_names_data :
                                 sd->section_names->data();
d1158 1
a1158 1
      if (is_gc_pass_one)
d1205 1
a1205 1
      if (is_gc_pass_two)
d1216 2
a1217 3
          if ((shdr.get_sh_flags() & elfcpp::SHF_ALLOC) != 0)
            if (symtab->gc()->referenced_list().find(Section_id(this,i)) 
                == symtab->gc()->referenced_list().end())
d1221 1
a1221 1
                              " in file '%s"),
d1229 30
d1274 2
a1275 1
	}
d1303 2
a1304 1
  // end.  Garbage collection is not turned on for relocatable code. 
d1307 3
a1309 1
  gold_assert(!parameters->options().gc_sections() || reloc_sections.empty());
d1392 1
d1605 2
a1606 1
							  off_t off)
d1648 15
d1672 1
a1672 1
	  else if (out_offsets[shndx] == invalid_address)
d1714 1
a1714 1
				+ out_offsets[shndx]
d1718 1
a1718 1
				+ out_offsets[shndx]
d1763 36
@


1.95
log
@	PR 10147
	* object.cc (Object::section_contents): Don't try to get a view if
	the section has length zero.
	(Object::handle_gnu_warning_section): If the section is empty, use
	the name of the section as the warning.
@
text
@d689 2
a690 2
  Sized_relobj<size, big_endian>* kept_object = NULL;
  Kept_section::Comdat_group* kept_group = NULL;
d693 4
a696 1
    include_group = true;
a698 2
      Kept_section this_group(this, index, true);
      Kept_section *kept_section_group;
d700 3
a702 8
                                                       &this_group,
                                                       &kept_section_group);
      if (include_group)
        kept_section_group->group_sections = new Kept_section::Comdat_group;

      kept_group = kept_section_group->group_sections;
      kept_object = (static_cast<Sized_relobj<size, big_endian>*>
		     (kept_section_group->object));
d714 1
a714 1
      elfcpp::Elf_Word secnum =
d718 1
a718 1
	shndxes.push_back(secnum);
d720 1
a720 1
      if (secnum >= this->shnum())
d723 1
a723 1
		      secnum, index);
d729 1
a729 1
      if (secnum < index)
d731 1
a731 1
                    index, secnum);
d734 1
a734 1
      typename This::Shdr member_shdr(shdrs + secnum * This::shdr_size);
d744 7
a750 1
      if (!include_group)
d752 3
a754 2
          (*omit)[secnum] = true;
          if (kept_group != NULL)
d756 33
a788 10
              // Find the corresponding kept section, and store that info
              // in the discarded section table.
              Kept_section::Comdat_group::const_iterator p =
                kept_group->find(mname);
              if (p != kept_group->end())
                {
                  Kept_comdat_section* kept =
                    new Kept_comdat_section(kept_object, p->second);
                  this->set_kept_comdat_section(secnum, kept);
                }
a790 6
      else if (flags & elfcpp::GRP_COMDAT)
        {
          // Add the section to the kept group table.
          gold_assert(kept_group != NULL);
          kept_group->insert(std::make_pair(mname, secnum));
        }
d821 1
a821 1
    const elfcpp::Shdr<size, big_endian>&)
d823 1
a839 2
  Kept_section candidate1(this, index, false);
  Kept_section candidate2(this, index, true);
d842 4
a845 2
  bool include1 = layout->find_or_add_kept_section(sig1, &candidate1, &kept1);
  bool include2 = layout->find_or_add_kept_section(sig2, &candidate2, &kept2);
d849 9
a857 14
      // The section is being discarded on the basis of its section
      // name (i.e., the kept section was also a linkonce section).
      // In this case, the section index stored with the layout object
      // is the linkonce section that was kept.
      unsigned int kept_group_index = kept2->shndx;
      Relobj* kept_relobj = kept2->object;
      if (kept_relobj != NULL)
        {
          Sized_relobj<size, big_endian>* kept_object =
	    static_cast<Sized_relobj<size, big_endian>*>(kept_relobj);
          Kept_comdat_section* kept =
            new Kept_comdat_section(kept_object, kept_group_index);
          this->set_kept_comdat_section(index, kept);
        }
d868 12
a879 16
      Relobj* kept_relobj = kept1->object;
      if (kept_relobj != NULL)
        {
          Sized_relobj<size, big_endian>* kept_object =
	    static_cast<Sized_relobj<size, big_endian>*>(kept_relobj);
          Kept_section::Comdat_group* kept_group = kept1->group_sections;
          if (kept_group != NULL && kept_group->size() == 1)
            {
              Kept_section::Comdat_group::const_iterator p =
		kept_group->begin();
              gold_assert(p != kept_group->end());
              Kept_comdat_section* kept =
                new Kept_comdat_section(kept_object, p->second);
              this->set_kept_comdat_section(index, kept);
            }
        }
d1231 1
a1231 1
              }
d1930 8
a1937 7
  Kept_comdat_section *kept = this->get_kept_comdat_section(shndx);
  if (kept != NULL)
    {
      gold_assert(kept->object_ != NULL);
      *found = true;
      Output_section* os = kept->object_->output_section(kept->shndx_);
      Address offset = kept->object_->get_output_section_offset(kept->shndx_);
d1939 4
a1942 1
        return os->address() + offset;
@


1.94
log
@	* layout.cc (Layout::make_output_section): Call
	Target::new_output_section.
	(Layout::attach_allocated_section_to_segment): Put large section
	sections in a separate load segment with the large segment flag
	set.
	(Layout::segment_precedes): Sort large data segments after other
	load segments.
	(align_file_offset): New static function.
	(Layout::set_segment_offsets): Use align_file_offset.
	* output.h (class Output_section): Add is_small_section_ and
	is_large_section_ fields.
	(Output_section::is_small_section): New function.
	(Output_section::set_is_small_section):  New function.
	(Output_section::is_large_section): New function.
	(Output_section::set_is_large_section): New function.
	(Output_section::is_large_data_section): New function.
	(class Output_segment): Add is_large_data_segment_ field.
	(Output_segment::is_large_data_segment): New function.
	(Output_segment::set_is_large_data_segment): New function.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_segment::Output_segment): Likewise.
	(Output_segment::add_output_section): Add assertion that large
	data sections always go in large data segments.  Force small data
	sections to the end of the list of data sections.  Force small BSS
	sections to the start of the list of BSS sections.  For large BSS
	sections to the end of the list of BSS sections.
	* symtab.h (class Symbol): Declare is_common_shndx.
	(Symbol::is_defined): Check Symbol::is_common_shndx.
	(Symbol::is_common): Likewise.
	(class Symbol_table): Define enum Commons_section_type.  Update
	declarations.  Add small_commons_ and large_commons_ fields.
	* symtab.cc (Symbol::is_common_shndx): New function.
	(Symbol_table::Symbol_table): Initialize new fields.
	(Symbol_table::add_from_object): Put small and large common
	symbols in the right list.
	(Symbol_table::sized_finalized_symbol): Check
	Symbol::is_common_shndx.
	(Symbol_table::sized_write_globals): Likewise.
	* common.cc (Symbol_table::do_allocate_commons): Allocate new
	common symbol lists.  Don't call do_allocate_commons_list if the
	list is empty.
	(Symbol_table::do_allocate_commons_list): Remove is_tls
	parameter.  Add comons_section_type parameter.  Change all
	callers.  Handle small and large common symbols.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Check
	Symbol::is_common_shndx.
	* resolve.cc (symbol_to_bits): Likewise.
	* target.h (Target::small_common_shndx): New function.
	(Target::small_common_section_flags): New function.
	(Target::large_common_shndx): New function.
	(Target::large_common_section_flags): New function.
	(Target::new_output_section): New function.
	(Target::Target_info): Add small_common_shndx, large_common_shndx,
	small_common_section_flags, and large_common_section_flags
	fields.
	(Target::do_new_output_section): New virtual function.
	* arm.cc (Target_arm::arm_info): Initialize new fields.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Likewise.
	* sparc.c (Target_sparc::sparc_info) [all versions]: Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	(Target_x86_64::do_new_output_section): New function.
	* configure.ac: Define conditional MCMODEL_MEDIUM.
	* testsuite/Makefile.am (check_PROGRAMS): Add large.
	(large_SOURCES, large_CFLAGS, large_DEPENDENCIES): Define.
	(large_LDFLAGS): Define.
	* testsuite/large.c: New file.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Initialize new fields.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d173 5
d234 6
@


1.93
log
@2009-06-05  Doug Kwan  <dougkwan@@google.com>

	* Makefile.am (CCFILES): Add target.cc.
	* Makefile.in: Regenerate.
	* i386.cc (class Target_i386): Define new virtual method to
	override do_is_local_label_name in parent.
	* object.cc (Sized_relobj::do_count_local_symbols): Discard
	local symbols if --discard-locals or -X is given.
	* options.h (class General_options): Declare new options
	'--discard-locals' and '-X' for discarding locals.
	* target.h (class Target): Define new methods is_local_label_name.
	Declare new virtual method do_is_local_label_name.
	* target.cc: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add discard_locals_test.
	(check_SCRIPTS): Add discard_locals_test.sh.
	(check_DATA): Add discard_local_tests.syms.
	(discard_locals_test_SOURCES, discard_locals_test_LDFLAGS): Define.
	(discard_local_tests.syms, discard_locals_test.o): New make rules.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/discard_locals_test.c: New file.
	* testsuite/discard_locals_test.sh: Same.
@
text
@d1557 1
a1557 1
	  if (shndx == elfcpp::SHN_ABS || shndx == elfcpp::SHN_COMMON)
@


1.92
log
@2009-06-05  Doug Kwan  <dougkwan@@google.com>

	* object.cc (Sized_relobj::Sized_relobj): Initialize
	discarded_eh_frame_shndx_ to -1U.
	(Sized_relobj::do_layout): Record index of a discard .eh_frame
	section.
	(Sized_relobj::do_count_local_symbols): Skip local symbols in
	a discarded .eh_frame section.
	(Sized_relobj::do_finalize_local_symbols): Ditto.
	* object.h (class Sized_relobj): Declare new member
	discarded_eh_frame_shndx_.
	* testsuite/Makefile.am (check_PROGRAMS): Add local_labels_test.
	(local_labels_test.o, local_labels_test): New rules.
	* testsuite/Makefile.in: Regenerate.
@
text
@d1442 1
d1488 22
a1510 1
      const char* name = pnames + sym.get_st_name();
@


1.91
log
@	* object.cc (Sized_relobj::map_to_kept_section): Return NULL if the
	kept comdat section was garbage collected.
	* testsuite/Makefile.am: Add test gc_comdat_test.sh.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/gc_comdat_test.sh: New file.
	* testsuite/gc_comdat_test_1.cc: New file.
	* testsuite/gc_comdat_test_2.cc: New file.
@
text
@d330 2
a331 1
    has_eh_frame_(false)
d1299 7
a1305 1
        out_section_offsets[i] = invalid_address;
d1463 2
a1464 1
      if (shndx < shnum && out_sections[shndx] == NULL)
d1569 9
a1577 1
	      if (!lv.is_section_symbol())
@


1.90
log
@	* object.cc (is_elf_object): Define.
	* object.h (is_elf_object): Declare.
	* archive.cc (Archive::get_elf_object_for_member): Call
	is_elf_object.
	* readsymc.cc (Read_symbols::do_read_symbols): Likewise.
@
text
@d1876 2
a1877 2
      gold_assert(os != NULL && offset != invalid_address);
      return os->address() + offset;
@


1.89
log
@	* readsyms.cc (Read_symbols::incompatible_warning): New function.
	(Read_symbols::requeue): New function.
	(Read_symbols::do_read_symbols): If make_elf_object fails because
	the target type is not configured, and the file was searched for,
	issue a warning and retry with the next directory.
	(Add_symbols::run): If the file has an incompatible format, and
	it was searched for, requeue the Read_symbols task.  On error,
	release the object.
	* readsyms.h (class Read_symbols): Add dirindex_ field.  Add
	dirindex parameter to constructor.  Change all callers.  Declare
	incompatible_warning and requeue.
	(class Add_symbols): Add dirpath_, dirindex_, mapfile_,
	input_argument_ and input_group_ fields.  Add them to
	constructor.  Change all callers.
	(class Read_script): Add dirindex_ field.  Add it to constructor.
	Change all callers.
	* archive.cc (Archive::setup): Remove input_objects parameter.
	Change all callers.
	(Archive::get_file_and_offset): Likewise.
	(Archive::read_all_symbols): Likewise.
	(Archive::read_symbols): Likewise.
	(Archive::get_elf_object_for_member): Remove input_objects
	parameter.  Add punconfigured parameter.  Change all callers.
	(Archive::add_symbols): Change return type to bool.  Check return
	value of include_member.
	(Archive::include_all_members): Likewise.
	(Archive::include_member): Change return type to bool.  Return
	false if first included object has incompatible target.  Set
	included_member_ field.
	(Add_archive_symbols::run): If add_symbols returns false, requeue
	Read_symbols task.
	* archive.h (class Archive): Add included_member_ field.
	Initialize it in constructor.  Add input_file and searched_for
	methods.  Update declarations.
	(class Add_archive_symbols): Add dirpath_, dirindex_, and
	input_argument_ fields.  Add them to constructor.  Change all
	callers.
	* script.cc: Include "target-select.h".
	(class Parser_closure): Add skip_on_incompatible_target_ and
	found_incompatible_target_ fields.  Add
	skip_on_incompatible_target parameter to constructor.  Change all
	callers.  Add methods skip_on_incompatible_target,
	clear_skip_on_incompatible_target, found_incompatible_target, and
	set_found_incompatible_target.
	(read_input_script): Add dirindex parameter.  Change all callers.
	If parser finds an incompatible target, requeue Read_symbols
	task.
	(script_set_symbol): Clear skip_on_incompatible_target in
	closure.
	(script_add_assertion, script_parse_option): Likewise.
	(script_start_sections, script_add_phdr): Likewise.
	(script_check_output_format): New function.
	* script.h (read_input_script): Update declaration.
	* script-c.h (script_check_output_format): Declare.
	* yyscript.y (file_cmd): Handle OUTPUT_FORMAT.
	(ignore_cmd): Remove OUTPUT_FORMAT.
	* fileread.cc (Input_file::Input_file): Add explicit this.
	(Input_file::will_search_for): New function.
	(Input_file::open): Add pindex parameter.  Change all callers.
	* fileread.h (class Input_file): Add input_file_argument method.
	Declare will_search_for.  Update declarations.
	* object.cc (make_elf_object): Add punconfigured parameter.
	Change all callers.
	* object.h (class Object): Make input_file public.  Add
	searched_for method.
	(make_elf_object): Update declaration.
	* dirsearch.cc (Dirsearch::find): Add pindex parameter.  Use it to
	restart search.
	* dirsearch.h (class Dirsearch): Update declaration.
	* options.h (class General_options): Add --warn-search-mismatch.
	* parameters.cc (Parameters::is_compatible_target): New function.
	* parameters.h (class Parameters): Declare is_compatible_target.
	* workqueue.cc (Workqueue::add_blocker): New function.
	* workqueue.h (class Workqueue): Declare add_blocker.
@
text
@d2103 27
@


1.88
log
@	* layout.cc (Layout::find_or_add_kept_section): New function.
	(Layout::add_comdat): Removed.
	* layout.h (struct Kept_section): Move out of class Layout.
	Remove trailing underscores from field names.  Add group_sections
	field.  Rename group_ field to is_group.  Change all uses.
	(class Layout): Declare find_or_add_kept_section, not add_comdat.
	* object.cc (Sized_relobj::Sized_relobj): Don't initialize
	comdat_groups_ field.
	(Sized_relobj::include_section_group): Use
	find_or_add_kept_section and Kept_section::group_sections.
	(Sized_relobj::include_linkonce_section): Likewise.
	* object.cc (class Sized_relobj): Don't define Comdat_group or
	Comdat_group_table.  Remove find_comdat_group and
	add_comdat_group.  Remove comdat_groups_ field.
	* plugin.cc (include_comdat_group): Use
	Layout::find_or_add_kept_section.
@
text
@d2107 2
a2108 1
		const unsigned char* p, section_offset_type bytes)
d2110 3
d2171 6
a2176 3
          gold_error(_("%s: not configured to support "
		       "32-bit big-endian object"),
		     name.c_str());
d2187 6
a2192 3
          gold_error(_("%s: not configured to support "
		       "32-bit little-endian object"),
		     name.c_str());
d2211 6
a2216 3
          gold_error(_("%s: not configured to support "
		       "64-bit big-endian object"),
		     name.c_str());
d2227 6
a2232 3
          gold_error(_("%s: not configured to support "
		       "64-bit little-endian object"),
		     name.c_str());
@


1.87
log
@	PR 6992
	* symtab.cc (Symbol_table::sized_write_section_symbol): In a
	relocatable link set the value of the section symbol to zero.
	* object.cc (Sized_relobj::do_finalize_local_symbols): In a
	relocatable link don't include the section address in the local
	symbol value.
@
text
@a329 1
    comdat_groups_(),
d676 1
a676 3
  bool include_group = ((flags & elfcpp::GRP_COMDAT) == 0
                        || layout->add_comdat(this, index, signature, true));

d678 1
a678 1
  Comdat_group* kept_group = NULL;
d680 3
a682 1
  if (!include_group)
d684 11
a694 15
      // This group is being discarded.  Find the object and group
      // that was kept in its place.
      unsigned int kept_group_index = 0;
      Relobj* kept_relobj = layout->find_kept_object(signature,
                                                     &kept_group_index);
      kept_object = static_cast<Sized_relobj<size, big_endian>*>(kept_relobj);
      if (kept_object != NULL)
        kept_group = kept_object->find_comdat_group(kept_group_index);
    }
  else if (flags & elfcpp::GRP_COMDAT)
    {
      // This group is being kept.  Create the table to map section names
      // to section indexes and add it to the table of groups.
      kept_group = new Comdat_group();
      this->add_comdat_group(index, kept_group);
d743 2
a744 1
              Comdat_group::const_iterator p = kept_group->find(mname);
d807 6
a812 2
  bool include1 = layout->add_comdat(this, index, sig1, false);
  bool include2 = layout->add_comdat(this, index, sig2, true);
d820 2
a821 2
      unsigned int kept_group_index = 0;
      Relobj* kept_relobj = layout->find_kept_object(sig2, &kept_group_index);
d824 2
a825 2
          Sized_relobj<size, big_endian>* kept_object
              = static_cast<Sized_relobj<size, big_endian>*>(kept_relobj);
d840 1
a840 2
      unsigned int kept_group_index = 0;
      Relobj* kept_relobj = layout->find_kept_object(sig1, &kept_group_index);
d844 2
a845 3
              static_cast<Sized_relobj<size, big_endian>*>(kept_relobj);
          Comdat_group* kept_group =
            kept_object->find_comdat_group(kept_group_index);
d848 2
a849 1
              Comdat_group::const_iterator p = kept_group->begin();
@


1.86
log
@	PR 6811
	* options.h (class Search_directory): Add is_system_directory.
	(class General_options): Declare is_in_system_directory.
	* options.cc (get_relative_sysroot): Make static.
	(get_default_sysroot): Make static.
	(General_optoins::is_in_system_directory): New function.
	* fileread.cc (Input_file::is_in_system_directory): New function.
	* fileread.h (class Input_file): Declare is_in_system_directory.
	* object.h (class Object): Add is_in_system_directory.
	(class Input_objects): Remove system_library_directory_ field.
	* object.cc (Input_objects::add_object): Don't set
	system_library_directory_.
	(input_objects::found_in_system_library_directory): Remove.
	* symtab.cc (Symbol_table::write_globals): Remove input_objects
	parameter.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::warn_about_undefined_dynobj_symbol): Likewise.
	Call Object::is_in_system_directory.
	* symtab.h (class Symbol_table): Update declarations.
@
text
@d1512 1
d1593 1
a1593 1
	    lv.set_output_value(os->address()
@


1.85
log
@	PR 7091
	* output.cc (Output_section::find_starting_output_address): Rename
	from starting_output_address; add PADDR parameter; change return
	type.
	* output.h (class Output_section): Declare
	find_starting_output_address instead of starting_output_address.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Handle a
	section symbol for which we can't find a merge section.
@
text
@a1943 13

      // If this is -lc, remember the directory in which we found it.
      // We use this when issuing warnings about undefined symbols: as
      // a heuristic, we don't warn about system libraries found in
      // the same directory as -lc.
      if (strncmp(soname, "libc.so", 7) == 0)
	{
	  const char* object_name = dynobj->name().c_str();
	  const char* base = lbasename(object_name);
	  if (base != object_name)
	    this->system_library_directory_.assign(object_name,
						   base - 1 - object_name);
	}
a1956 11
// Return whether an object was found in the system library directory.

bool
Input_objects::found_in_system_library_directory(const Object* object) const
{
  return (!this->system_library_directory_.empty()
	  && object->name().compare(0,
				    this->system_library_directory_.size(),
				    this->system_library_directory_) == 0);
}

@


1.84
log
@	(From Rafael Espindola)
	* archive.cc (Archive::include_member): Update calls to add_symbols.
	* dynobj.cc (Sized_dynobj<size, big_endian>::make_version_map): Add
	the Layout argument.
	* dynobj.h (do_add_symbols): Add the Layout argument.
	* object.cc (Sized_relobj<size, big_endian>::do_add_symbols): Add the
	Layout argument.
	* object.h (Object::add_symbols): Add the Layout argument.
	(Object::do_add_symbols): Add the Layout argument.
	(Sized_relobj::do_add_symbols): Add the Layout argument.
	* plugin.cc (Sized_pluginobj<size, big_endian>::do_add_symbols):
	Unify the two versions.
	(Add_plugin_symbols): Remove.
	* plugin.h (Pluginobj::add_symbols, Pluginobj::do_add_symbols): Remove.
	(Sized_pluginobj::do_add_symbols): Unify the two versions.
	(Add_plugin_symbols): Remove.
	* readsyms.cc (Read_symbols::do_read_symbols): Update call to
	Add_symbols. Use Add_symbols instead of Add_plugin_symbols.
	(Add_symbols::run): Make it work with Pulginobj.
@
text
@d1557 2
d1560 1
a1560 6
	      // requires special handling.  We get the output address
	      // of the start of the merged section.  If this is not a
	      // section symbol, we can then determine the final
	      // value.  If it is a section symbol, we can not, as in
	      // that case we have to consider the addend to determine
	      // the value to use in a relocation.
d1562 15
a1576 2
		lv.set_output_value(os->output_address(this, shndx,
                                                       lv.input_value()));
d1579 3
a1581 2
                  section_offset_type start =
                    os->starting_output_address(this, shndx);
@


1.83
log
@	* object.cc (Sized_relobj::do_layout): Make info message start
	with lower case letter.
@
text
@d1352 2
a1353 1
					       Read_symbols_data* sd)
@


1.82
log
@	* gold.h: Include <cstring> and <stdint.h>.
	* version.cc: Include <cstdio>.
	* object.cc (Sized_relobj::do_layout): Initialize gc_sd to avoid a
	warning.
	* reduced_debug_output.cc (insert_into_vector): Rename from
	Insert_into_vector; change all callers.  Use Swap_unaligned to
	avoid aliasing issue; remove union since it is unnecessary.
@
text
@d1184 1
a1184 1
                  gold_info(_("%s: Removing unused section from '%s'" 
@


1.81
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d916 1
a916 1
  Symbols_data* gc_sd;
@


1.80
log
@	* object.cc (Sized_relobj::write_local_symbols): Don't write out
	local symbols when stripping all symbols.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d31 1
d236 73
d893 9
a901 1
// and an offset.
d910 4
d916 44
d962 1
a962 1
  const unsigned char* shdrs = sd->section_headers->data();
d966 3
a968 1
  const unsigned char* pnamesu = sd->section_names->data();
d1017 5
a1021 2
  out_sections.resize(shnum);
  out_section_offsets.resize(shnum);
d1027 7
a1033 4
      delete sd->section_headers;
      sd->section_headers = NULL;
      delete sd->section_names;
      sd->section_names = NULL;
d1066 1
a1066 1
      if (shdr.get_sh_name() >= sd->section_names_size)
d1075 7
a1081 5
      if (this->handle_gnu_warning_section(name, i, symtab))
	{
	  if (!relocatable)
	    omit[i] = true;
	}
d1083 9
a1091 9
      // The .note.GNU-stack section is special.  It gives the
      // protection flags that this object file requires for the stack
      // in memory.
      if (strcmp(name, ".note.GNU-stack") == 0)
	{
	  seen_gnu_stack = true;
	  gnu_stack_flags |= shdr.get_sh_flags();
	  omit[i] = true;
	}
d1093 17
a1109 15
      bool discard = omit[i];
      if (!discard)
	{
	  if (shdr.get_sh_type() == elfcpp::SHT_GROUP)
	    {
	      if (!this->include_section_group(symtab, layout, i, name, shdrs,
					       pnames, sd->section_names_size,
					       &omit))
		discard = true;
	    }
          else if ((shdr.get_sh_flags() & elfcpp::SHF_GROUP) == 0
                   && Layout::is_linkonce(name))
	    {
	      if (!this->include_linkonce_section(layout, i, name, shdr))
		discard = true;
a1110 1
	}
d1112 18
a1129 7
      if (discard)
	{
	  // Do not include this section in the link.
	  out_sections[i] = NULL;
          out_section_offsets[i] = invalid_address;
	  continue;
	}
d1135 2
a1136 1
      // reloc sections and process them later.
d1155 12
a1166 6
	  && strcmp(name, ".eh_frame") == 0
	  && this->check_eh_frame_flags(&shdr))
	{
	  eh_frame_sections.push_back(i);
	  continue;
	}
d1168 28
d1198 3
a1200 1
          this->deferred_layout_.push_back(Deferred_layout(i, name, pshdrs,
a1202 1

d1205 15
d1225 2
d1232 2
a1233 1
  layout->layout_gnu_stack(seen_gnu_stack, gnu_stack_flags);
d1236 1
a1236 1
  // end.
d1239 1
d1246 1
a1246 1
      pshdr = sd->section_headers->data() + i * This::shdr_size;
d1274 1
d1280 1
a1280 1
      gold_assert(sd->external_symbols_offset != 0);
d1284 1
a1284 1
      pshdr = sd->section_headers->data() + i * This::shdr_size;
d1289 4
a1292 4
						   sd->symbols->data(),
						   sd->symbols_size,
						   sd->symbol_names->data(),
						   sd->symbol_names_size,
d1310 14
a1323 4
  delete sd->section_headers;
  sd->section_headers = NULL;
  delete sd->section_names;
  sd->section_names = NULL;
@


1.79
log
@	* object.cc (Sized_relobj::layout_section): New function.
	(Sized_relobj::do_layout): Defer layout of input sections until after
	plugin has provided replacement files.
	(Sized_relobj::do_layout_deferred_sections): New function.
	* object.h (Relobj::set_section_offset): Remove virtual keyword.
	(Relobj::layout_deferred_sections): New function.
	(Relobj::do_layout_deferred_sections): New function.
	(Sized_relobj::do_layout_deferred_sections): New function.
	(Sized_relobj::layout_section): New function.
	(Sized_relobj::Deferred_layout): New structure.
	(Sized_relobj::deferred_layout_): New field.
	* plugin.cc (Plugin_manager::finish): Renamed, was cleanup.
	Change all callers.  Layout deferred sections.
	(class Plugin_finish): Renamed, was Plugin_cleanup.  Change all
	references.
	(Plugin_hook::run): Move code from do_plugin_hook inline.
	(Plugin_hook::do_plugin_hook): Remove.
	* plugin.h (Plugin_manager::Plugin_manager): Add missing initializers.
	(Plugin_manager::finish): Renamed, was cleanup.
	(Plugin_manager::should_defer_layout): New function.
	(Plugin_manager::add_deferred_layout_object): New function.
	(Plugin_manager::Deferred_layout_list): New type.
	(Plugin_manager::deferred_layout_objects_): New field.
	(Plugin_hook::do_plugin_hook): Remove.
@
text
@d1419 7
a1425 3
  if (parameters->options().strip_all()
      && this->output_local_dynsym_count_ == 0)
    return;
d1494 1
a1494 1
	      if (lv.needs_output_symtab_entry())
d1503 1
a1503 2
      if (!parameters->options().strip_all()
	  && lv.needs_output_symtab_entry())
@


1.78
log
@	* mapfile.cc (Mapfile::print_input_section): Change -1U to -1ULL.
	* object.cc (Sized_relobj::do_layout): Use constant invalid_address
	instead of -1U.
	(Sized_relobj::do_finalize_local_symbols): Likewise.
	(Sized_relobj::map_to_kept_section): Likewise.
	* object.h (Sized_relobj::invalid_address): New constant.
	(Sized_relobj::do_output_section_offset): Check for invalid_address
	and return -1ULL.
	* output.cc (Output_reloc::local_section_offset): Use constant
	invalid_address instead of -1U.
	(Output_reloc::get_address): Likewise.
	(Output_section::output_address): Change -1U to -1ULL.
	* output.h (Output_reloc::invalid_address): New constant.
	* reloc.cc (Sized_relobj::write_sections): Use constant
	invalid_address instead of -1U.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (Symbol_table::sized_finalize_symbol): Handle symbol
	values for merge sections.
	* target-reloc.h (relocate_for_relocatable): Use constant
	invalid_address instead of -1U.
@
text
@d40 1
d788 28
d839 7
d857 4
d899 6
d1009 11
a1019 8
      off_t offset;
      Output_section* os = layout->layout(this, i, name, shdr,
					  reloc_shndx[i], reloc_type[i],
					  &offset);

      out_sections[i] = os;
      if (offset == -1)
        out_section_offsets[i] = invalid_address;
d1021 4
a1024 7
        out_section_offsets[i] = convert_types<Address, off_t>(offset);

      // If this section requires special handling, and if there are
      // relocs that apply to it, then we must do the special handling
      // before we apply the relocs.
      if (offset == -1 && reloc_shndx[i] != 0)
	this->set_relocs_must_follow_section_writes();
d1108 21
@


1.77
log
@	* cref.cc: New file.
	* cref.h: New file.
	* options.h (class General_options): Add --print-symbol-counts.
	* main.cc (main): Issue defined symbol report if requested.
	* archive.cc (Archive::interpret_header): Make into a const member
	function.
	(Archive::add_symbols): Call Input_objects::archive_start and
	archive_stop.
	(Archive::const_iterator): Define new class.
	(Archive::begin, Archive::end): New functions.
	(Archive::include_all_members): Rewrite to use iterator.
	(Archive::count_members): New function.
	* archive.h (class Archive): Update declarations.
	(Archive::filename): New function.
	* object.cc: Include "cref.h".
	(Sized_relobj::Sized_relobj): Initialize defined_count_.
	(Sized_relobj::do_get_global_symbol_counts): New function.
	(Input_objects::add_object): Add object to cross-referencer.
	(Input_objects::archive_start): New function.
	(Input_objects::archive_stop): New function.
	(Input_objects::print_symbol_counts): New function.
	* object.h: Declare Cref and Archive.
	(Object::get_global_symbol_counts): New function.
	(Object::do_get_global_symbol_counts): New pure virtual function.
	(class Sized_relobj): Add defined_count_ field.  Update
	declarations.
	(class Input_objects): Add cref_ field.  Update constructor.
	Update declarations.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize symbols_ and
	defined_count_.
	(Sized_dynobj::do_add_symbols): Allocate symbols_ if printing
	symbol counts.
	(Sized_dynobj::do_get_global_symbol_counts): New function.
	* dynobj.h (class Sized_dynobj): Add fields symbols_ and
	defined_count_.  Update declarations.  Define Symbols typedef.
	* symtab.cc (Symbol_table::add_from_relobj): Add defined
	parameter.  Change all callers.
	(Symbol_table::add_from_dynobj): Add sympointers and defined
	parameters.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* Makefile.am (CCFILES): Add cref.cc.
	(HFILES): Add cref.h.
	* Makefile.in: Rebuild.
@
text
@d929 1
a929 1
          out_section_offsets[i] = -1U;
d970 1
a970 1
        out_section_offsets[i] = -1U;
d1007 1
a1007 1
          out_section_offsets[i] = -1U;
d1017 1
a1017 1
      out_section_offsets[i] = -1U;
d1045 1
a1045 1
        out_section_offsets[i] = -1U;
d1269 1
a1269 1
	  else if (out_offsets[shndx] == -1U)
d1576 1
a1576 1
      gold_assert(os != NULL && offset != -1U);
@


1.76
log
@	Handle output sections with more than 0x7fffffff bytes.
	* object.h (class Relobj): Change map_to_output_ to
	output_sections_, and just keep a section pointer.  Change all
	uses.  Move comdat group support to Sized_relobj.
	(Relobj::is_section_specially_mapped): Remove.
	(Relobj::output_section): Remove poff parameter.  Change all
	callers.
	(Relobj::output_section_offset): New function.
	(Relobj::set_section_offset): Rewrite.
	(Relobj::map_to_output): Remove.
	(Relobj::output_sections): New function.
	(Relobj::do_output_section_offset): New pure virtual function.
	(Relobj::do_set_section_offset): Likewise.
	(class Sized_relobj): Add section_offsets_ field.  Add comdat
	group support from Relobj.  Update declarations.
	(Sized_relobj::get_output_section_offset): New function.
	(Sized_relobj::do_output_section_offset): New function.
	(Sized_relobj::do_set_section_offset): New function.
	* object.cc (Relobj::output_section_address): Remove.
	(Sized_relobj::Sized_relobj): Initialize new fields.
	(Sized_relobj::include_section_group): Cast find_kept_object to
	Sized_relobj.
	(Sized_relobj::include_linkonce_section): Likewise.
	(Sized_relobj::do_layout): Use separate arrays for output section
	and output offset.
	(Sized_relobj::do_count_local_symbols): Change map_to_output to
	output_sections.
	(Sized_relobj::do_finalize_local_symbols): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_local_symbols): Likewise.
	(map_to_kept_section): Compute output address directly.
	* reloc.cc (Sized_relobj::do_read_relocs): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_sections): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (sized_finalize_symbol): Use output_section_offset.
	* output.h (class Output_reloc): Update declarations.  Change
	u2_.relobj to Sized_relobj*.
	(class Output_data_reloc): Change add functions to use
	Sized_relobj*.
	* output.cc (Output_reloc::Output_reloc): Change relobj to
	Sized_relobj*.
	(Output_reloc::local_section_offset): Change return type to
	Elf_Addr.  Use get_output_section_offset.
	(Output_reloc::get_address): Likewise.
	(Output_section::is_input_address_mapped): Don't call
	is_section_specially_mapped.
	(Output_section::output_offset): Likewise.
	(Output_section::output_address): Likewise.
	(Output_section::starting_output_address): Likewise.
	* copy-relocs.cc (Copy_relocs::copy_reloc): Change object
	parameter to Sized_relobj*.
	(Copy_relocs::need_copy_reloc): Likewise.
	(Copy_relocs::save): Likewise.
	* copy-relocs.h (class Copy_relocs): Update declarations.
	(class Copy_relocs::Copy_reloc_entry): Change constructor to use
	Sized_relobj*.  Change relobj_ field to Sized_relobj*.
	* target-reloc.h (relocate_for_relocatable): Change
	offset_in_output_section type to Elf_Addr.  Change code that uses
	it as well.
	* layout.cc (Layout::layout): Always set *off.
	* mapfile.cc (Mapfile::print_input_section): Use
	output_section_offset.
	* i386.cc (Target_i386::copy_reloc): Change object parameter to
	Sized_relobj*.
	* powerpc.cc (Target_powerpc::copy_reloc): Likewise.
	* sparc.cc (Target_sparc::copy_reloc): Likewise.
	* x86_64.cc (Target_x86_64::copy_reloc): Likewise.
@
text
@d36 1
d249 1
d1092 2
a1093 1
			  &this->symbols_);
d1583 22
d1659 8
d1707 32
@


1.75
log
@2008-06-25  Cary Coutant  <ccoutant@@google.com>

	* fileread.cc (File_read::make_view): Assert on zero-length view.
	* object.cc (Sized_relobj::do_read_symbols): Don't try to read
	symbol table when there are no symbols to read.
@
text
@a232 12
// Class Relobj.

// Return the output address of the input section SHNDX.
uint64_t
Relobj::output_section_address(unsigned int shndx) const
{
  section_offset_type offset;
  Output_section* os = this->output_section(shndx, &offset);
  gold_assert(os != NULL && offset != -1);
  return os->address() + offset;
}

d252 2
d603 1
a603 1
  Relobj* kept_object = NULL;
d611 3
a613 1
      kept_object = layout->find_kept_object(signature, &kept_group_index);
d744 2
a745 2
      Relobj* kept_object = layout->find_kept_object(sig2, &kept_group_index);
      if (kept_object != NULL)
d747 2
d764 2
a765 2
      Relobj* kept_object = layout->find_kept_object(sig1, &kept_group_index);
      if (kept_object != NULL)
d767 2
d840 5
a844 2
  std::vector<Map_to_output>& map_sections(this->map_to_output());
  map_sections.resize(shnum);
d926 2
a927 1
	  map_sections[i].output_section = NULL;
d966 5
a970 2
      map_sections[i].output_section = os;
      map_sections[i].offset = offset;
d1001 1
a1001 1
      Output_section* data_section = map_sections[data_shndx].output_section;
d1004 2
a1005 1
	  map_sections[i].output_section = NULL;
d1014 2
a1015 2
      map_sections[i].output_section = os;
      map_sections[i].offset = -1;
d1041 5
a1045 2
      map_sections[i].output_section = os;
      map_sections[i].offset = offset;
d1141 1
a1141 1
  const std::vector<Map_to_output>& mo(this->map_to_output());
d1168 1
a1168 1
      if (shndx < shnum && mo[shndx].output_section == NULL)
d1223 2
a1224 1
  const std::vector<Map_to_output>& mo(this->map_to_output());
d1235 1
a1235 1
      
d1256 1
a1256 1
	  Output_section* os = mo[shndx].output_section;
d1266 1
a1266 1
	  else if (mo[shndx].offset == -1)
d1289 1
a1289 1
				+ mo[shndx].offset
d1293 1
a1293 1
				+ mo[shndx].offset
d1396 1
a1396 1
  const std::vector<Map_to_output>& mo(this->map_to_output());
d1414 2
a1415 2
	  gold_assert(st_shndx < mo.size());
	  if (mo[st_shndx].output_section == NULL)
d1417 1
a1417 1
	  st_shndx = mo[st_shndx].output_section->out_shndx();
d1571 4
a1574 2
      return (static_cast<Address>
              (kept->object_->output_section_address(kept->shndx_)));
@


1.74
log
@	* object.cc (Sized_relobj::include_section_group): Adjust section
	indexes read from group data.  Build vector to pass to
	layout_group.
	* layout.cc (Layout::layout_group): Add flags and shndxes
	parameters.  Remove contents parameter.  Change caller.  Update
	explicit instantiations.
	* layout.h (class Layout): Update layout_group declaration.
	* output.cc (Output_data_group::Output_data_group): Add flags and
	input_shndxes parameters.  Remove contents parameter.  Change
	caller.
	(Output_data_group::do_write): Change input_sections_ to
	input_shndxes_.
	* output.h (class Output_data_group): Update constructor
	declaration.  Rename input_sections_ to input_shndxes_.
	* testsuite/many_sections_test.cc: Add template.
@
text
@d455 6
@


1.73
log
@	* layout.cc (Layout::include_section): Refactored check for debug
	info section.
	(Layout::add_comdat): Add new parameters.  Change type
	of signature parameter.  Add object and shndx to signatures table.
	(Layout::find_kept_object): New function.
	* layout.h: Include <cstring>.
	(Layout::is_debug_info_section): New function.
	(Layout::add_comdat): Add new parameters.
	(Layout::find_kept_object): New function.
	(Layout::Kept_section): New struct.
	(Layout::Signatures): Change type of map range.
	* object.cc (Relobj::output_section_address): New function.
	(Sized_relobj::include_section_group): Add new parameters.  Change
	calls to Layout::add_comdat.  Change to build table of kept comdat
	groups and table mapping discarded sections to kept sections.
	(Sized_relobj::include_linkonce_section): Likewise.  Add new parameter.
	(Sized_relobj::do_layout): Change calls to include_section_group and
	include_linkonce_section.
	(Sized_relobj::do_finalize_local_symbols): Do not set local symbol
	value to zero when section is discarded.
	(Sized_relobj::map_to_kept_section): New function.
	* object.h (Relobj::output_section_address): New function.
	(Relobj::Comdat_group): New type.
	(Relobj::find_comdat_group): New function.
	(Relobj::Comdat_group_table): New type.
	(Relobj::Kept_comdat_section): New type.
	(Relobj::Kept_comdat_section_table): New type.
	(Relobj::add_comdat_group): New function.
	(Relobj::set_kept_comdat_section): New function.
	(Relobj::get_kept_comdat_section): New function.
	(Relobj::comdat_groups_): New field.
	(Relobj::kept_comdat_sections_): New field.
	(Symbol_value::input_value): Update comment.
	(Sized_relobj::map_to_kept_section) New function.
	(Sized_relobj::include_linkonce_section): Add new parameter.
	* target-reloc.h (Comdat_behavior): New type.
	(get_comdat_behavior): New function.
	(relocate_section): Add code to map a discarded section to the
	corresponding kept section when applying a relocation.
@
text
@a606 4
  if (include_group && parameters->options().relocatable())
    layout->layout_group(symtab, this, index, name, signature.c_str(),
                           shdr, pword);

d628 6
d637 5
a641 1
	elfcpp::Swap<32, big_endian>::readval(pword + i);
d690 4
@


1.72
log
@	* object.cc (Sized_relobj::include_section_group): Check for
	invalid section group.
@
text
@d233 12
d525 3
a527 1
    const elfcpp::Shdr<size, big_endian>& shdr,
d531 1
d580 1
a580 1
  const char* signature = psymnames + sym.get_st_name();
a584 1
  std::string secname;
d597 32
a628 14
      secname = this->section_name(sym_shndx);
      signature = secname.c_str();
    }

  // Record this section group, and see whether we've already seen one
  // with the same signature.

  if ((flags & elfcpp::GRP_COMDAT) == 0
      || layout->add_comdat(signature, true))
    {
      if (parameters->options().relocatable())
	layout->layout_group(symtab, this, index, name, signature, shdr,
			     pword);
      return true;
a630 2
  // This is a duplicate.  We want to discard the sections in this
  // group.
d649 33
a681 1
      (*omit)[secnum] = true;
d684 1
a684 1
  return false;
d706 1
d724 46
a769 2
  bool include1 = layout->add_comdat(symname, false);
  bool include2 = layout->add_comdat(name, true);
d789 2
a790 1
  const unsigned char* pshdrs = sd->section_headers->data();
d802 1
a802 1
  pshdrs += This::shdr_size;
d860 1
a860 1
  pshdrs = sd->section_headers->data() + This::shdr_size;
d895 2
a896 1
	      if (!this->include_section_group(symtab, layout, i, name, shdr,
d903 1
a903 1
	      if (!this->include_linkonce_section(layout, name, shdr))
d1236 4
a1239 1
	      lv.set_output_value(0);
d1532 22
@


1.71
log
@	* object.cc (make_elf_object): Correct test for 64-bit ELF file
	header size.
@
text
@d612 7
@


1.70
log
@	* object.cc (Sized_relobj::do_add_symbols): Always pass
	local_symbol_count_ to add_from_relobj.
@
text
@d1681 1
a1681 1
      if (bytes < elfcpp::Elf_sizes<32>::ehdr_size)
@


1.69
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d949 1
a949 4
			  symcount,
			  (sd->external_symbols_offset == 0
			   ? this->local_symbol_count_
			   : 0),
@


1.68
log
@	* errors.cc (Errors::info): New function.
	(gold_info): New function.
	* errors.h (Errors::info): New function.
	* gold.h (gold_info): New function.
	* object.cc (Input_objects::add_object): Print trace output.
	* options.cc (options::parse_set): New function.
	(General_options::parse_wrap): Deleted.
	(General_options::General_options): Deleted initializer.
	* options.h (options::String_set): New typedef.
	(options::parse_set): New function.
	(DEFINE_set): New macro.
	(General_options::wrap): Changed to use DEFINE_set. Changed
	callers of any_wrap_symbols and is_wrap_symbol.
	(General_options::trace, General_options::trace_symbol):
	New options.
	(General_options::any_wrap_symbols, General_options::is_wrap_symbol)
	(General_options::wrap_symbols_): Deleted.
	* symtab.cc (Symbol_table::add_from_object): Print trace output.
@
text
@d43 87
d294 2
d304 9
d315 9
d328 13
d446 1
a446 1
  unsigned int strtab_shndx = symtabshdr.get_sh_link();
d474 5
a478 3
// the object file.  Note that for a symbol which is not defined in
// this object file, this will set *VALUE to 0 and return SHN_UNDEF;
// it will not return the final value of the symbol in the link.
d483 2
a484 1
							 Address* value)
d496 2
a497 2
  // FIXME: Handle SHN_XINDEX.
  return elfsym.get_st_shndx();
d534 1
a534 1
  const unsigned int link = shdr.get_sh_link();
d538 2
a539 1
  if (shdr.get_sh_info() >= symshdr.get_sh_size() / This::sym_size)
d542 1
a542 1
		  index, shdr.get_sh_info());
d545 1
a545 1
  off_t symoff = symshdr.get_sh_offset() + shdr.get_sh_info() * This::sym_size;
d553 2
a554 2
  psymnamesu = this->section_contents(symshdr.get_sh_link(), &symnamelen,
				      true);
d561 1
a561 1
		  shdr.get_sh_info(), sym.get_st_name());
a569 1
  // FIXME.
d573 11
a583 1
      secname = this->section_name(sym.get_st_shndx());
d695 1
a695 1
	  unsigned int target_shndx = shdr.get_sh_info();
d859 1
a859 1
      unsigned int data_shndx = shdr.get_sh_info();
d949 5
a953 1
			  symcount, sym_names, sd->symbol_names_size,
d995 2
a996 1
  const unsigned int strtab_shndx = symtabshdr.get_sh_link();
d1017 4
a1020 2
      unsigned int shndx = sym.get_st_shndx();
      lv.set_input_shndx(shndx);
d1080 1
a1080 1
                                                          off_t off)
d1094 2
a1095 1
      unsigned int shndx = lv.input_shndx();
d1099 1
a1099 1
      if (shndx >= elfcpp::SHN_LORESERVE)
a1104 1
	      // FIXME: Handle SHN_XINDEX.
d1205 3
a1207 1
    const Stringpool* dynpool)
d1235 2
a1236 1
  const unsigned int strtab_shndx = symtabshdr.get_sh_link();
d1267 6
a1272 2
      unsigned int st_shndx = isym.get_st_shndx();
      if (st_shndx < elfcpp::SHN_LORESERVE)
d1278 8
d1290 1
a1290 1
	  && this->local_values_[i].needs_output_symtab_entry())
d1307 1
a1307 1
      if (this->local_values_[i].needs_output_dynsym_entry())
d1359 2
a1360 1
  unsigned int symbol_names_shndx = this->section_link(this->symtab_shndx_);
d1380 1
d1382 9
a1390 4
      else if (sym.get_st_shndx() == shndx
               && static_cast<off_t>(sym.get_st_value()) <= offset
               && (static_cast<off_t>(sym.get_st_value() + sym.get_st_size())
                   > offset))
@


1.67
log
@	* layout.h (class Layout): Add added_eh_frame_data_ field.
	* layout.cc (Layout::Layout): Initialize new field.
	(Layout::layout_eh_frame): Don't add eh_frame_data_ to .eh_frame
	output section until we find a section we merged successfully.
	* object.cc (Sized_relobj::check_eh_frame_flags): Don't require
	that the size be non-zero.
@
text
@d1272 4
@


1.66
log
@	* fileread.cc (File_read::find_view): Add byteshift and vshifted
	parameters.  Update for new key type to views_.  Change all
	callers.
	(File_read::read): Adjust for byteshift in returned view.
	(File_read::add_view): New function, broken out of
	find_and_make_view.
	(File_read::make_view): New function, broken out of
	find_and_make_view.
	(File_read::find_or_make_view): Add offset and aligned
	parameters.  Rewrite accordingly.  Change all callers.
	(File_read::get_view): Add offset and aligned parameters.  Adjust
	for byteshift in return value.
	(File_read::get_lasting_view): Likewise.
	* fileread.h (class File_read): Update declarations.
	(class File_read::View): Add byteshift_ field.  Add byteshift to
	constructor.  Add byteshift method.
	* archive.h (Archive::clear_uncached_views): New function.
	(Archive::get_view): Add aligned parameter.  Change all callers.
	* object.h (Object::get_view): Add aligned parameter.  Change all
	callers.
	(Object::get_lasting_view): Likewise.

	* fileread.cc (File_read::release): Don't call clear_views if
	there are multiple objects.
	* fileread.h (File_read::clear_uncached_views): New function.
	* archive.cc (Add_archive_symbols::run): Call clear_uncached_views
	on the archive.
@
text
@d229 1
a229 2
  return (shdr->get_sh_size() > 0
	  && shdr->get_sh_type() == elfcpp::SHT_PROGBITS
@


1.65
log
@	PR gold/5986
	Fix problems building gold with gcc 4.3.0.
	* gold.h (TEMPLATE_ATTRIBUTE_PRINTF_4): Define.
	(gold_error_at_location, gold_warning_at_location): Use it.
	* configure.ac: Check whether we can compile and use a template
	function with a printf attribute.
	* x86_64.cc (Target_x86_64::do_code_fill): Swap out a 32-bit value
	when jumping over bytes.
	* object.cc: Instantiate Object::read_section_data.
	* debug.h: Include <cstring>
	* dwarf_reader.cc: Include <algorithm>
	* main.cc: Include <cstring>.
	* options.cc: Include <cstring>.
	* output.cc: Include <cstring>.
	* script.cc: Include <cstring>.
	* script.h: Include <string>.
	* symtab.cc: Include <cstring> and <algorithm>.
	* target-select.cc: Include <cstring>.
	* version.cc: Include <string>.
	* testsuite/testmain.cc: Include <cstdlib>.
	* configure, config.in: Rebuild.
@
text
@d83 1
a83 1
  return this->get_view(loc.file_offset, *plen, cache);
d99 2
a100 1
  sd->section_headers = this->get_lasting_view(shoff, shnum * shdr_size, true);
d114 2
a115 1
					     sd->section_names_size, false);
d324 1
a324 1
  File_view* fvsymtab = this->get_lasting_view(readoff, readsize, false);
d343 2
a344 1
					       strtabshdr.get_sh_size(), true);
d396 1
a396 1
					     shdr.get_sh_size(), false);
d423 2
a424 1
  const unsigned char* psym = this->get_view(symoff, This::sym_size, false);
d856 1
a856 1
					      locsize, true);
d1091 1
a1091 1
					      locsize, false);
@


1.64
log
@	* options.cc: Include "demangle.h".
	(parse_optional_string): New function.
	(parse_long_option): Handle takes_optional_argument.
	(parse_short_option): Update dash_z initializer.  Handle
	takes_optional_argument.
	(General_options::General_options): Initialize do_demangle_.
	(General_options::finalize): Set do_demangle_.  Handle demangling
	style.
	* options.h (parse_optional_string): Declare.
	(struct One_option): Add optional_arg field.  Update constructor.
	Update call constructor calls.  Add takes_optional_argument
	function.
	(DEFINE_var): Add optional_arg__ parameter.  Change all callers.
	(DEFINE_optional_string): Define.
	(General_options::demangle): Change from DEFINE_bool to
	DEFINE_optional_string.
	(General_options::no_demangle): New function.
	(General_options::do_demangle): New function.
	(General_options::set_do_demangle): New function.
	(General_options::execstack_status_): Move definition to end of
	class definition.
	(General_options::static_): Likewise.
	(General_options::do_demangle_): New field.
	* object.cc (big_endian>::get_symbol_location_info): Call
	Options::do_demangle, not Options::demangle.
	* symtab.cc (demangle): Likewise.
@
text
@d1549 29
a1577 2
// Instantiate the templates we need.  We could use the configure
// script to restrict this to only the ones for implemented targets.
@


1.63
log
@Fix handling of RELA relative relocs against local symbols in merge
sections.
@
text
@d1232 1
a1232 1
              if (parameters->options().demangle())
@


1.62
log
@Update copyright years.  Update language files.
@
text
@a1054 11
// Return the value of the local symbol symndx.
template<int size, bool big_endian>
typename elfcpp::Elf_types<size>::Elf_Addr
Sized_relobj<size, big_endian>::local_symbol_value(unsigned int symndx) const
{
  gold_assert(symndx < this->local_symbol_count_);
  gold_assert(symndx < this->local_values_.size());
  const Symbol_value<size>& lv(this->local_values_[symndx]);
  return lv.value(this, 0);
}

@


1.61
log
@Combine read-only .eh_frame sections with read-write .eh_frame
sections.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.60
log
@Support -d/--define-common.
@
text
@d229 1
a229 1
	  && shdr->get_sh_flags() == elfcpp::SHF_ALLOC);
d278 5
a282 2
  if (this->find_eh_frame(pshdrs, names, sd->section_names_size))
    this->has_eh_frame_ = true;
@


1.59
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d954 1
a954 1
	  if (shndx == elfcpp::SHN_ABS)
@


1.58
log
@Implement -q/--emit-relocs.
@
text
@d454 1
a454 1
      if (parameters->output_is_object())
d597 3
a599 2
  const bool output_is_object = parameters->output_is_object();
  const bool emit_relocs = output_is_object || parameters->emit_relocs();
d622 1
a622 1
	  if (!output_is_object)
d673 1
a673 1
      if (output_is_object && shdr.get_sh_type() == elfcpp::SHT_GROUP)
d682 1
a682 1
      if (!output_is_object
d1072 2
a1073 1
  if (parameters->strip_all() && this->output_local_dynsym_count_ == 0)
d1139 1
a1139 1
      if (!parameters->strip_all()
d1240 1
a1240 1
              if (parameters->demangle())
d1269 1
a1269 1
  if (!parameters->is_target_valid())
d1271 1
a1271 1
  else if (target != parameters->target())
@


1.57
log
@Support dynamic relocations against local section symbols.
@
text
@d596 1
a596 1
  // Keep track of reloc sections when doing a relocatable link.
d598 1
d664 1
a664 1
      if (output_is_object
d708 1
a708 1
  if (output_is_object)
@


1.56
log
@Implement --just-symbols, including -R FILE.  Fix symbol values when
doing a relocatable link.
@
text
@d887 1
d894 1
@


1.55
log
@Support creating empty output when there are no input objects.
@
text
@d577 11
@


1.54
log
@Initial -r support.
@
text
@d1251 1
d1253 3
a1255 3
  if (this->target_ == NULL)
    this->target_ = target;
  else if (this->target_ != target)
d1257 1
a1257 1
      gold_error(_("%s: incompatible target"), obj->name().c_str());
a1291 2

  set_parameters_target(target);
@


1.53
log
@Reduce the number of system calls.  Use readv instead of pread.  Do
better handling of cached views.
@
text
@d381 1
d384 1
a397 2
  if ((flags & elfcpp::GRP_COMDAT) == 0)
    return true;
d401 2
a402 2
  // just use the name of the SHT_GROUP section as the group
  // signature?
d450 9
a458 2
  if (layout->add_comdat(signature, true))
    return true;
d585 4
d609 1
a609 1
	  if (!parameters->output_is_object())
d628 2
a629 1
	      if (!this->include_section_group(layout, i, shdr, &omit))
d647 16
d669 1
a669 1
      if (!parameters->output_is_object()
d693 36
@


1.52
log
@Correct handling of non-section symbol in merged section.  Avoid some
64-bit signed/unsigned warnings.
@
text
@d128 11
a138 1
      symtab->add_warning(name + warn_prefix_len, this, shndx);
d417 1
a417 1
  const unsigned char* psym = this->get_view(symoff, This::sym_size, true);
d742 5
a746 4
// Finalize the local symbols.  Here we add their names to *POOL and
// *DYNPOOL, and we add their values to THIS->LOCAL_VALUES_.  This
// function is always called from a singleton thread.  The actual
// output of the local symbols will occur in a separate task.
d847 1
a847 1
// Finalize the local symbols.  Here we add their values to
d1022 1
a1022 1
							true);
@


1.51
log
@Speed up relocations against local symbols in merged sections.
@
text
@a898 2
	      section_offset_type start =
		os->starting_output_address(this, shndx);
d900 2
a901 1
		lv.set_output_value(lv.input_value() + start);
d904 2
@


1.50
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d892 17
a908 1
	      // Leave the input value in place for SHF_MERGE sections.
d911 1
a911 1
	    lv.set_output_value(mo[shndx].output_section->tls_offset()
d915 1
a915 1
	    lv.set_output_value(mo[shndx].output_section->address()
a969 34
}

// Return the value of a local symbol defined in input section SHNDX,
// with value VALUE, adding addend ADDEND.  IS_SECTION_SYMBOL
// indicates whether the symbol is a section symbol.  This handles
// SHF_MERGE sections.
template<int size, bool big_endian>
typename elfcpp::Elf_types<size>::Elf_Addr
Sized_relobj<size, big_endian>::local_value(unsigned int shndx,
					    Address value,
					    bool is_section_symbol,
					    Address addend) const
{
  const std::vector<Map_to_output>& mo(this->map_to_output());
  Output_section* os = mo[shndx].output_section;
  if (os == NULL)
    return addend;
  gold_assert(mo[shndx].offset == -1);

  // Do the mapping required by the output section.  If this is not a
  // section symbol, then we want to map the symbol value, and then
  // include the addend.  If this is a section symbol, then we need to
  // include the addend to figure out where in the section we are,
  // before we do the mapping.  This will do the right thing provided
  // the assembler is careful to only convert a relocation in a merged
  // section to a section symbol if there is a zero addend.  If the
  // assembler does not do this, then in general we can't know what to
  // do, because we can't distinguish the addend for the instruction
  // format from the addend for the section offset.

  if (is_section_symbol)
    return os->output_address(this, shndx, value + addend);
  else
    return addend + os->output_address(this, shndx, value);
@


1.49
log
@Rewrite workqueue.  This version eliminates the master thread, and
reduces the amount of locking required to find a new thread to run.
@
text
@d78 2
a79 1
Object::section_contents(unsigned int shndx, off_t* plen, bool cache)
d82 2
a83 2
  *plen = loc.data_size;
  return this->get_view(loc.file_offset, loc.data_size, cache);
d110 2
a111 1
  sd->section_names_size = shdrnames.get_sh_size();
d227 4
a230 3
Sized_relobj<size, big_endian>::find_eh_frame(const unsigned char* pshdrs,
					      const char* names,
					      off_t names_size) const
d299 1
a299 1
  off_t locsize = loccount * sym_size;
d301 2
a302 1
  off_t datasize = symtabshdr.get_sh_size();
d304 1
a304 1
  off_t extsize = datasize - locsize;
d307 1
a307 1
  off_t readsize = this->has_eh_frame_ ? datasize : extsize;
d334 2
a335 1
  sd->symbol_names_size = strtabshdr.get_sh_size();
d348 1
a348 1
  off_t symbols_size;
d411 1
a411 1
  off_t symnamelen;
d711 1
a711 2
  if (static_cast<off_t>(symcount * sym_size)
      != sd->symbols_size - sd->external_symbols_offset)
d765 1
a765 1
  off_t strtab_size;
d1025 1
a1025 1
  off_t strtab_size;
d1130 1
a1130 1
  off_t symbols_size;
d1136 1
a1136 1
  off_t names_size;
d1368 1
a1368 1
		const unsigned char* p, off_t bytes)
@


1.48
log
@Initialize variable to avoid warning.
@
text
@d729 2
a730 2
// *DYNPOOL, and we add their values to THIS->LOCAL_VALUES_.
// This function is always called from the main thread.  The actual
d834 1
a834 1
// This function is always called from the main thread.  The actual
d990 4
a993 3
Sized_relobj<size, big_endian>::write_local_symbols(Output_file* of,
						    const Stringpool* sympool,
						    const Stringpool* dynpool)
@


1.47
log
@From Cary Coutant: More support for generating shared libraries.
@
text
@d1029 1
a1029 1
  unsigned char* oview;
@


1.46
log
@Compress all debug sections.
@
text
@d145 1
d148 1
d295 1
d728 2
a729 3
// Finalize the local symbols.  Here we record the file offset at
// which they should be output, we add their names to *POOL, and we
// add their values to THIS->LOCAL_VALUES_.  Return the symbol index.
d734 3
a736 4
unsigned int
Sized_relobj<size, big_endian>::do_finalize_local_symbols(unsigned int index,
							  off_t off,
							  Stringpool* pool)
d742 1
a742 1
      return index;
a744 4
  gold_assert(off == static_cast<off_t>(align_address(off, size >> 3)));

  this->local_symbol_offset_ = off;

a758 2
  this->local_values_.resize(loccount);

d772 1
d786 67
d854 4
d861 1
a861 1
	    lv.set_output_value(sym.get_st_value());
a883 1
	      lv.set_no_output_symtab_entry();
d886 8
a893 3

	  if (mo[shndx].offset == -1)
	    lv.set_input_value(sym.get_st_value());
d897 1
a897 1
				+ sym.get_st_value());
d900 8
a907 1
      // Decide whether this symbol should go into the output file.
d909 1
a909 5
      if (sym.get_st_type() == elfcpp::STT_SECTION)
	{
	  lv.set_no_output_symtab_entry();
	  continue;
	}
d911 13
a923 14
      if (sym.get_st_name() >= strtab_size)
	{
	  this->error(_("local symbol %u section name out of range: %u >= %u"),
		      i, sym.get_st_name(),
		      static_cast<unsigned int>(strtab_size));
	  lv.set_no_output_symtab_entry();
	  continue;
	}

      const char* name = pnames + sym.get_st_name();
      pool->add(name, true, NULL);
      lv.set_output_symtab_index(index);
      ++index;
      ++count;
d925 2
d928 3
a930 1
  this->output_local_symbol_count_ = count;
d932 7
a938 1
  return index;
d991 2
a992 1
						    const Stringpool* sympool)
d994 1
a994 1
  if (parameters->strip_all())
d1026 2
a1027 1
  // Get a view into the output file.
d1029 9
a1037 2
  unsigned char* oview = of->get_output_view(this->local_symbol_offset_,
					     output_size);
d1044 1
a1049 3
      if (!this->local_values_[i].needs_output_symtab_entry())
	continue;

d1059 36
a1094 1
      elfcpp::Sym_write<size, big_endian> osym(ov);
a1095 8
      gold_assert(isym.get_st_name() < strtab_size);
      const char* name = pnames + isym.get_st_name();
      osym.put_st_name(sympool->get_offset(name));
      osym.put_st_value(this->local_values_[i].value(this, 0));
      osym.put_st_size(isym.get_st_size());
      osym.put_st_info(isym.get_st_info());
      osym.put_st_other(isym.get_st_other());
      osym.put_st_shndx(st_shndx);
d1097 11
a1107 1
      ov += sym_size;
a1108 4

  gold_assert(ov - oview == output_size);

  of->write_output_view(this->local_symbol_offset_, output_size, oview);
@


1.45
log
@From Craig Silverstein: Add support for --demangle.
@
text
@d1106 1
a1106 2
  set_parameters_size_and_endianness(target->get_size(),
				     target->is_big_endian());
@


1.44
log
@Add heuristics for undefined symbol warnings.
@
text
@d28 1
d1036 14
a1049 1
	    info->enclosing_symbol_name = symbol_names + sym.get_st_name();
a1171 5
      // We could demangle this name before printing, but we don't
      // bother because gcc runs linker output through a demangle
      // filter itself.  The only advantage to demangling here is if
      // someone might call ld directly, rather than via gcc.  If we
      // did want to demangle, cplus_demangle() is in libiberty.
@


1.43
log
@Warn about undefined references in shared libraries if we have seen
all the DT_NEEDED entries for that library.
@
text
@d28 1
d1066 1
d1069 1
a1069 1
	this->sonames_.insert(dynobj->soname());
d1077 13
d1096 11
@


1.42
log
@From Craig Silverstein: Rework debug info code a bit, add option for
ODR violations, add test case.
@
text
@d1083 26
@


1.41
log
@From Craig Silverstein: rework DWARF reader code a bit.
@
text
@d1096 1
a1096 1
  Dwarf_line_info<size, big_endian> line_info(this->object);
@


1.40
log
@From Craig Silverstein: Initialize got_relocs.
@
text
@d1096 3
a1098 51
  // The line-number information is in the ".debug_line" section.
  unsigned int debug_shndx;
  off_t debuglines_size;
  const unsigned char* debuglines = NULL;
  for (debug_shndx = 0; debug_shndx < this->object->shnum(); ++debug_shndx)
    if (this->object->section_name(debug_shndx) == ".debug_line")
      {
        debuglines = this->object->section_contents(
            debug_shndx, &debuglines_size, false);
        break;
      }

  // Find the relocation section for ".debug_line".
  Track_relocs<size, big_endian> track_relocs;
  bool got_relocs = false;
  for (unsigned int reloc_shndx = 0;
       reloc_shndx < this->object->shnum();
       ++reloc_shndx)
    {
      unsigned int reloc_sh_type = this->object->section_type(reloc_shndx);
      if ((reloc_sh_type == elfcpp::SHT_REL
	   || reloc_sh_type == elfcpp::SHT_RELA)
	  && this->object->section_info(reloc_shndx) == debug_shndx)
	{
	  got_relocs = track_relocs.initialize(this->object, reloc_shndx,
					       reloc_sh_type);
	  break;
	}
    }

  // Finally, we need the symtab section to interpret the relocs.
  unsigned int symtab_shndx;
  off_t symtab_size;
  const unsigned char* symtab = NULL;
  for (symtab_shndx = 0; symtab_shndx < this->object->shnum(); ++symtab_shndx)
    if (this->object->section_type(symtab_shndx) == elfcpp::SHT_SYMTAB)
      {
        symtab = this->object->section_contents(
            symtab_shndx, &symtab_size, false);
        break;
      }

  // If we got all three sections we need, we can try to read debug info.
  if (debuglines != NULL && got_relocs && symtab != NULL)
    {
      Dwarf_line_info<size, big_endian> line_info(debuglines, debuglines_size,
						  &track_relocs,
                                                  symtab, symtab_size);
      line_info.read_line_mappings();
      file_and_lineno = line_info.addr2line(this->data_shndx, offset);
    }
@


1.39
log
@From Craig Silverstein: Use relocations in reporting error message
locations.
@
text
@d1110 1
a1110 1
  bool got_relocs;
@


1.38
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d34 1
d1095 37
a1131 2
  for (unsigned int shndx = 0; shndx < this->object->shnum(); ++shndx)
    if (this->object->section_name(shndx) == ".debug_line")
d1133 2
a1134 10
        off_t debuglines_size;
        const unsigned char* debuglines = this->object->section_contents(
            shndx, &debuglines_size, false);
        if (debuglines)
          {
            Dwarf_line_info<size, big_endian> line_info(debuglines,
							debuglines_size);
            line_info.read_line_mappings();
            file_and_lineno = line_info.addr2line(this->data_shndx, offset);
          }
d1137 10
@


1.37
log
@From Craig Silverstein: Templatize the Dwarf reader.
@
text
@d142 1
a142 1
    symbols_(NULL),
d145 2
a146 1
    local_got_offsets_()
d202 44
d258 5
d265 1
d280 7
a286 1
  // We only need the external symbols.
d291 7
a297 2
  off_t extoff = symtabshdr.get_sh_offset() + locsize;
  off_t extsize = symtabshdr.get_sh_size() - locsize;
d299 1
a299 2
  // Read the symbol table.
  File_view* fvsymtab = this->get_lasting_view(extoff, extsize, false);
d321 2
a322 1
  sd->symbols_size = extsize;
d327 24
d514 32
d557 3
d561 1
a561 1
  pshdrs += This::shdr_size;
d614 14
d629 3
a631 1
      Output_section* os = layout->layout(this, i, name, shdr, &offset);
d635 6
d645 33
d698 4
a701 2
  size_t symcount = sd->symbols_size / sym_size;
  if (static_cast<off_t>(symcount * sym_size) != sd->symbols_size)
d707 1
a707 1
  this->symbols_ = new Symbol*[symcount];
d711 4
a714 2
  symtab->add_from_relobj(this, sd->symbols->data(), symcount, sym_names,
			  sd->symbol_names_size, this->symbols_);
@


1.36
log
@From Craig Silverstein: Don't crash if we see a file we don't recognize.
@
text
@d922 3
a924 2
            Dwarf_line_info line_info(debuglines, debuglines_size);
            line_info.read_line_mappings<size, big_endian>();
@


1.35
log
@From Craig Silverstein: Add first version of generating error messages
with file name and line number.
@
text
@d869 9
a893 9
    }

  Target* target = obj->target();
  if (this->target_ == NULL)
    this->target_ = target;
  else if (this->target_ != target)
    {
      gold_error(_("%s: incompatible target"), obj->name().c_str());
      return false;
@


1.34
log
@Reworked from Andrew Chatham: report error locations.
@
text
@d30 1
d848 1
a848 1
                   >= offset))
d911 18
a928 3
  // FIXME: We would like to print the following:
  // /tmp/foo.o: in function 'fn':foo.c:12: undefined reference to 'xxx'
  // We're missing line numbers.
d935 5
d942 16
a957 1
      ret += info.source_file;
a958 6
  ret += "(";
  ret += this->object->section_name(this->data_shndx);
  char buf[100];
  // Offsets into sections have to be positive.
  snprintf(buf, sizeof(buf), "+0x%lx)", static_cast<long>(offset));
  ret += buf;
@


1.33
log
@Add support for PT_GNU_STACK.
@
text
@d804 56
d908 1
a908 1
Relocate_info<size, big_endian>::location(size_t relnum, off_t) const
d910 3
d914 11
a924 1
  ret += ": reloc ";
d926 2
a927 8
  snprintf(buf, sizeof buf, "%zu", relnum);
  ret += buf;
  ret += " in reloc section ";
  snprintf(buf, sizeof buf, "%u", this->reloc_shndx);
  ret += buf;
  ret += " (" + this->object->section_name(this->reloc_shndx);
  ret += ") for section ";
  snprintf(buf, sizeof buf, "%u", this->data_shndx);
a928 1
  ret += " (" + this->object->section_name(this->data_shndx) + ")";
@


1.32
log
@Adjust linkonce symbol name algorithm to work for
.gnu.linkonce.t.__i686.get_pc_thunk.bx.
@
text
@d430 5
d459 10
d498 2
@


1.31
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d386 14
a399 1
  const char* symname = strrchr(name, '.') + 1;
@


1.30
log
@From Craig Silverstein: add some internationalization calls.
@
text
@d49 2
a50 5
    {
      fprintf(stderr, _("%s: %s: unsupported ELF machine number %d\n"),
	      program_name, this->name().c_str(), machine);
      gold_exit(false);
    }
d54 3
a56 1
// Report an error for the elfcpp::Elf_file interface.
d59 1
a59 1
Object::error(const char* format, ...)
a61 2

  fprintf(stderr, "%s: %s: ", program_name, this->name().c_str());
d63 3
a65 1
  vfprintf(stderr, format, args);
d67 2
a68 3
  putc('\n', stderr);

  gold_exit(false);
d102 2
a103 7
    {
      fprintf(stderr,
	      _("%s: %s: section name section has wrong type: %u\n"),
	      program_name, this->name().c_str(),
	      static_cast<unsigned int>(shdrnames.get_sh_type()));
      gold_exit(false);
    }
d212 5
a219 4
      sd->symbols = NULL;
      sd->symbols_size = 0;
      sd->symbol_names = NULL;
      sd->symbol_names_size = 0;
d243 2
a244 3
      fprintf(stderr, _("%s: %s: invalid symbol table name index: %u\n"),
	      program_name, this->name().c_str(), strtab_shndx);
      gold_exit(false);
d249 3
a251 5
      fprintf(stderr,
	      _("%s: %s: symbol table name section has wrong type: %u\n"),
	      program_name, this->name().c_str(),
	      static_cast<unsigned int>(strtabshdr.get_sh_type()));
      gold_exit(false);
d304 3
a306 3
      fprintf(stderr, _("%s: %s: section group %u info %u out of range\n"),
	      program_name, this->name().c_str(), index, shdr.get_sh_info());
      gold_exit(false);
d322 3
a324 4
      fprintf(stderr, _("%s: %s: symbol %u name offset %u out of range\n"),
	      program_name, this->name().c_str(), shdr.get_sh_info(),
	      sym.get_st_name());
      gold_exit(false);
d354 3
a356 5
	  fprintf(stderr,
		  _("%s: %s: section %u in section group %u out of range"),
		  program_name, this->name().c_str(), secnum,
		  index);
	  gold_exit(false);
d428 3
a430 5
	  fprintf(stderr,
		  _("%s: %s: bad section name offset for section %u: %lu\n"),
		  program_name, this->name().c_str(), i,
		  static_cast<unsigned long>(shdr.get_sh_name()));
	  gold_exit(false);
d494 2
a495 4
      fprintf(stderr,
	      _("%s: %s: size of symbols is not multiple of symbol size\n"),
	      program_name, this->name().c_str());
      gold_exit(false);
d584 3
a586 5
	      fprintf(stderr,
		      _("%s: %s: unknown section index %u "
			"for local symbol %u\n"),
		      program_name, this->name().c_str(), shndx, i);
	      gold_exit(false);
d593 3
a595 5
	      fprintf(stderr,
		      _("%s: %s: local symbol %u section index %u "
			"out of range\n"),
		      program_name, this->name().c_str(), i, shndx);
	      gold_exit(false);
d625 5
a629 7
	  fprintf(stderr,
		  _("%s: %s: local symbol %u section name "
		    "out of range: %u >= %u\n"),
		  program_name, this->name().c_str(),
		  i, sym.get_st_name(),
		  static_cast<unsigned int>(strtab_size));
	  gold_exit(false);
d805 2
a806 3
      fprintf(stderr, _("%s: %s: incompatible target\n"),
	      program_name, obj->name().c_str());
      gold_exit(false);
d872 3
a874 3
      fprintf(stderr, _("%s: %s: unsupported ELF file type %d\n"),
	      program_name, name.c_str(), et);
      gold_exit(false);
d891 2
a892 3
      fprintf(stderr, _("%s: %s: ELF file too short\n"),
	      program_name, name.c_str());
      gold_exit(false);
d899 1
a899 2
	fprintf(stderr, _("%s: %s: invalid ELF version 0\n"),
		program_name, name.c_str());
d901 2
a902 3
	fprintf(stderr, _("%s: %s: unsupported ELF version %d\n"),
		program_name, name.c_str(), v);
      gold_exit(false);
d908 2
a909 3
      fprintf(stderr, _("%s: %s: invalid ELF class 0\n"),
	      program_name, name.c_str());
      gold_exit(false);
d914 2
a915 3
      fprintf(stderr, _("%s: %s: unsupported ELF class %d\n"),
	      program_name, name.c_str(), c);
      gold_exit(false);
d921 2
a922 3
      fprintf(stderr, _("%s: %s: invalid ELF data encoding\n"),
	      program_name, name.c_str());
      gold_exit(false);
d927 2
a928 3
      fprintf(stderr, _("%s: %s: unsupported ELF data encoding %d\n"),
	      program_name, name.c_str(), d);
      gold_exit(false);
d937 2
a938 3
	  fprintf(stderr, _("%s: %s: ELF file too short\n"),
		  program_name, name.c_str());
	  gold_exit(false);
d947 4
a950 4
          fprintf(stderr,
                  _("%s: %s: not configured to support 32-bit big-endian object\n"),
                  program_name, name.c_str());
          gold_exit(false);
d960 4
a963 4
          fprintf(stderr,
                  _("%s: %s: not configured to support 32-bit little-endian object\n"),
                  program_name, name.c_str());
          gold_exit(false);
d971 2
a972 3
	  fprintf(stderr, _("%s: %s: ELF file too short\n"),
		  program_name, name.c_str());
	  gold_exit(false);
d981 4
a984 4
          fprintf(stderr,
                  _("%s: %s: not configured to support 64-bit big-endian object\n"),
                  program_name, name.c_str());
          gold_exit(false);
d994 4
a997 4
          fprintf(stderr,
                  _("%s: %s: not configured to support 64-bit little-endian object\n"),
                  program_name, name.c_str());
          gold_exit(false);
@


1.29
log
@Add an option for Stringpools to not copy strings.
@
text
@d827 1
a827 1
      fprintf(stderr, "%s: %s: incompatible target\n",
@


1.28
log
@Implement -s and -S options which strip symbols.
@
text
@d655 1
a655 1
      pool->add(name, NULL);
@


1.27
log
@Add support for local GOT offsets.
@
text
@d718 3
@


1.26
log
@Correct handling of addends in merged sections.
@
text
@d150 2
a151 1
    local_values_()
d664 11
@


1.25
log
@From Craig Silverstein: avoid some signed/unsigned warnings from gcc 4.2.
@
text
@d589 3
d666 3
a668 2
// with value VALUE, adding addend ADDEND.  This handles SHF_MERGE
// sections.
d673 1
d681 16
a696 1
  return os->output_address(this, shndx, value + addend);
@


1.24
log
@Put size and endianness in parameters.
@
text
@d505 1
a505 1
  if (symcount * sym_size != sd->symbols_size)
@


1.23
log
@Add cache parameter to get_view.  Discard uncached views on unlock.
Fix bug this exposed in archive armap symbol name handling.
@
text
@d797 3
@


1.22
log
@Add licensing text to every source file.
@
text
@d76 1
a76 1
Object::section_contents(unsigned int shndx, off_t* plen)
d80 1
a80 1
  return this->get_view(loc.file_offset, loc.data_size);
d96 1
a96 1
  sd->section_headers = this->get_lasting_view(shoff, shnum * shdr_size);
d114 1
a114 1
					     sd->section_names_size);
d242 1
a242 1
  File_view* fvsymtab = this->get_lasting_view(extoff, extsize);
d264 1
a264 1
					       strtabshdr.get_sh_size());
d288 1
a288 1
					     shdr.get_sh_size());
d317 1
a317 1
  const unsigned char* psym = this->get_view(symoff, This::sym_size);
d323 2
a324 1
  psymnamesu = this->section_contents(symshdr.get_sh_link(), &symnamelen);
d561 1
a561 1
					      locsize);
d569 2
a570 1
							&strtab_size);
d705 1
a705 1
					      locsize);
d711 2
a712 1
							&strtab_size);
@


1.21
log
@Add global parameters.
@
text
@d3 20
@


1.20
log
@From Cary Coutant: only check for a linkonce section if the SHF_GROUP
flag is clear.
@
text
@d389 1
a389 2
Sized_relobj<size, big_endian>::do_layout(const General_options& options,
					  Symbol_table* symtab,
d429 1
a429 1
	  if (!options.is_relocatable())
@


1.19
log
@Add support for --enable-target to control which template
specializations we generate.
@
text
@d442 2
a443 1
	  else if (Layout::is_linkonce(name))
@


1.18
log
@Add support for SHF_MERGE sections.
@
text
@d496 1
a496 1
  symtab->add_from_relobj(this, sd->symbols->data(), symcount, sym_names, 
d912 1
d916 6
d925 1
d929 6
d947 1
d951 6
d960 1
d964 6
d977 1
d980 1
d982 1
d985 1
d987 1
d990 1
d992 1
d995 1
d997 1
d1000 1
d1002 1
d1005 1
d1007 1
d1010 1
d1012 1
d1015 1
@


1.17
log
@Don't emit symbols seen only in dynamic object, don't read duplicate
dynamic object.
@
text
@d130 1
a130 2
    local_values_(),
    local_indexes_()
d507 3
a509 4
// add their values to THIS->LOCAL_VALUES_ and their indexes in the
// output symbol table to THIS->LOCAL_INDEXES_.  Return the symbol
// index.  This function is always called from the main thread.  The
// actual output of the local symbols will occur in a separate task.
a542 1
  this->local_indexes_.resize(loccount);
d562 2
d565 1
d570 1
a570 1
	    this->local_values_[i] = sym.get_st_value();
d592 3
a594 1
	  if (mo[shndx].output_section == NULL)
d596 2
a597 2
	      this->local_values_[i] = 0;
	      this->local_indexes_[i] = -1U;
d601 6
a606 3
	  this->local_values_[i] = (mo[shndx].output_section->address()
				    + mo[shndx].offset
				    + sym.get_st_value());
d613 1
a613 1
	  this->local_indexes_[i] = -1U;
d630 1
a630 1
      this->local_indexes_[i] = index;
a631 1
      off += sym_size;
d640 17
a699 1
  gold_assert(this->local_indexes_.size() == loccount);
d707 1
a707 1
      if (this->local_indexes_[i] == -1U)
a708 1
      gold_assert(this->local_indexes_[i] != 0);
d724 1
a724 1
      osym.put_st_value(this->local_values_[i]);
@


1.16
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d721 2
a722 1
// Add a regular relocatable object to the list.
d724 1
a724 1
void
d727 2
a728 2
  if (obj->is_dynamic())
    this->dynobj_list_.push_back(static_cast<Dynobj*>(obj));
d730 14
a743 1
    this->relobj_list_.push_back(static_cast<Relobj*>(obj));
d754 2
@


1.15
log
@Snapshot.  Includes first cut at output relocation sections.
@
text
@a6 1
#include <cassert>
d212 1
a212 1
  assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);
d479 1
a479 1
      assert(sd->symbol_names == NULL);
d519 1
a519 1
  assert(this->symtab_shndx_ != -1U);
d526 1
a526 1
  assert(off == static_cast<off_t>(align_address(off, size >> 3)));
d534 1
a534 1
  assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);
d539 1
a539 1
  assert(loccount == symtabshdr.get_sh_info());
d643 1
a643 1
  assert(this->symtab_shndx_ != -1U);
d654 1
a654 1
  assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);
d656 1
a656 1
  assert(loccount == symtabshdr.get_sh_info());
d678 2
a679 2
  assert(this->local_values_.size() == loccount);
  assert(this->local_indexes_.size() == loccount);
d689 1
a689 1
      assert(this->local_indexes_[i] != 0);
d694 1
a694 1
	  assert(st_shndx < mo.size());
d702 1
a702 1
      assert(isym.get_st_name() < strtab_size);
d714 1
a714 1
  assert(ov - oview == output_size);
@


1.14
log
@More dynamic object support, initial scripting support.
@
text
@d131 2
a132 1
    values_(NULL)
d509 4
a512 3
// add their values to THIS->VALUES_.  Return the new file offset.
// This function is always called from the main thread.  The actual
// output of the local symbols will occur in a separate task.
d515 3
a517 2
off_t
Sized_relobj<size, big_endian>::do_finalize_local_symbols(off_t off,
d524 1
a524 1
      return off;
d527 1
a527 1
  off = align_address(off, size >> 3);
d545 2
a546 1
  this->values_ = new typename elfcpp::Elf_types<size>::Elf_Addr[loccount];
d557 1
a557 1
  std::vector<Map_to_output>& mo(this->map_to_output());
d571 1
a571 1
	    this->values_[i] = sym.get_st_value();
d595 2
a596 1
	      this->values_[i] = 0;
d600 3
a602 3
	  this->values_[i] = (mo[shndx].output_section->address()
			      + mo[shndx].offset
			      + sym.get_st_value());
d605 3
a607 1
      if (sym.get_st_type() != elfcpp::STT_SECTION)
d609 3
a611 10
	  if (sym.get_st_name() >= strtab_size)
	    {
	      fprintf(stderr,
		      _("%s: %s: local symbol %u section name "
			"out of range: %u >= %u\n"),
		      program_name, this->name().c_str(),
		      i, sym.get_st_name(),
		      static_cast<unsigned int>(strtab_size));
	      gold_exit(false);
	    }
d613 9
a621 3
	  pool->add(pnames + sym.get_st_name(), NULL);
	  off += sym_size;
	  ++count;
d623 7
d634 1
a634 1
  return off;
d677 1
a677 1
  std::vector<Map_to_output>& mo(this->map_to_output());
d679 4
a683 1
  unsigned char* ov = oview;
d688 1
a688 1
      if (isym.get_st_type() == elfcpp::STT_SECTION)
d690 1
d704 3
a706 2
      osym.put_st_name(sympool->get_offset(pnames + isym.get_st_name()));
      osym.put_st_value(this->values_[i]);
@


1.13
log
@Add Elf_file interface which can be used by both Sized_relobj and
Sized_dynobj.
@
text
@d22 16
d64 52
d126 1
a126 2
    section_headers_(NULL),
    symtab_shndx_(0),
d148 3
a150 11
  int machine = ehdr.get_e_machine();
  Target* target = select_target(machine, size, big_endian,
				 ehdr.get_e_ident()[elfcpp::EI_OSABI],
				 ehdr.get_e_ident()[elfcpp::EI_ABIVERSION]);
  if (target == NULL)
    {
      fprintf(stderr, _("%s: %s: unsupported ELF machine number %d\n"),
	      program_name, this->name().c_str(), machine);
      gold_exit(false);
    }
  this->set_target(target);
d152 1
a152 1
  unsigned int shnum = this->elf_file_.shnum();
d154 6
a159 2
  if (shnum == 0)
    return;
d161 13
a173 17
  // We store the section headers in a File_view until do_read_symbols.
  off_t shoff = this->elf_file_.shoff();
  this->section_headers_ = this->get_lasting_view(shoff,
						  shnum * This::shdr_size);

  // Find the SHT_SYMTAB section.  The ELF standard says that maybe in
  // the future there can be more than one SHT_SYMTAB section.  Until
  // somebody figures out how that could work, we assume there is only
  // one.
  const unsigned char* p = this->section_headers_->data();

  // Skip the first section, which is always empty.
  p += This::shdr_size;
  for (unsigned int i = 1; i < shnum; ++i, p += This::shdr_size)
    {
      typename This::Shdr shdr(p);
      if (shdr.get_sh_type() == elfcpp::SHT_SYMTAB)
d175 8
a182 2
	  this->symtab_shndx_ = i;
	  break;
d193 1
a193 3
  // Transfer our view of the section headers to SD.
  sd->section_headers = this->section_headers_;
  this->section_headers_ = NULL;
d195 3
a197 9
  // Read the section names.
  const unsigned char* pshdrs = sd->section_headers->data();
  const unsigned char* pshdrnames = (pshdrs
				     + (this->elf_file_.shstrndx()
					* This::shdr_size));
  typename This::Shdr shdrnames(pshdrnames);
  sd->section_names_size = shdrnames.get_sh_size();
  sd->section_names = this->get_lasting_view(shdrnames.get_sh_offset(),
					     sd->section_names_size);
d226 2
a227 3
  unsigned int shnum = this->shnum();
  unsigned int strtab_shnum = symtabshdr.get_sh_link();
  if (strtab_shnum == 0 || strtab_shnum >= shnum)
d230 1
a230 1
	      program_name, this->name().c_str(), strtab_shnum);
d233 1
a233 1
  typename This::Shdr strtabshdr(pshdrs + strtab_shnum * This::shdr_size);
d395 1
a395 1
  unsigned int shnum = this->shnum();
a411 3
  const char warn_prefix[] = ".gnu.warning.";
  const int warn_prefix_len = sizeof warn_prefix - 1;

d429 1
a429 1
      if (strncmp(name, warn_prefix, warn_prefix_len) == 0)
a430 1
	  symtab->add_warning(name + warn_prefix_len, this, i);
d497 2
a498 4
  symtab->add_from_object<size, big_endian>(this, sd->symbols->data(),
					    symcount, sym_names, 
					    sd->symbol_names_size,
					    this->symbols_);
d517 1
d631 1
a765 7
  if (et != elfcpp::ET_REL && et != elfcpp::ET_DYN)
    {
      fprintf(stderr, "%s: %s: unsupported ELF type %d\n",
	      program_name, name.c_str(), static_cast<int>(et));
      gold_exit(false);
    }

d773 7
d782 2
a783 3
      // elfcpp::ET_DYN
      fprintf(stderr, _("%s: %s: dynamic objects are not yet supported\n"),
	      program_name, name.c_str());
a784 5
//       Sized_dynobj<size, big_endian>* obj =
// 	new Sized_dynobj<size, big_endian>(this->input_.name(), input_file,
// 					   offset, ehdr);
//       obj->setup(ehdr);
//       return obj;
@


1.12
log
@Rework stringpool and hash tables so that we always generate the same
output regardless of randomize_va_space.
@
text
@d8 1
d20 28
d57 1
d59 1
a59 4
    flags_(ehdr.get_e_flags()),
    shoff_(ehdr.get_e_shoff()),
    shstrndx_(0),
    symtab_shnum_(0),
a65 14
  if (ehdr.get_e_ehsize() != This::ehdr_size)
    {
      fprintf(stderr, _("%s: %s: bad e_ehsize field (%d != %d)\n"),
	      program_name, this->name().c_str(), ehdr.get_e_ehsize(),
	      This::ehdr_size);
      gold_exit(false);
    }
  if (ehdr.get_e_shentsize() != This::shdr_size)
    {
      fprintf(stderr, _("%s: %s: bad e_shentsize field (%d != %d)\n"),
	      program_name, this->name().c_str(), ehdr.get_e_shentsize(),
	      This::shdr_size);
      gold_exit(false);
    }
d73 1
a73 53
// Read the section header for section SHNUM.

template<int size, bool big_endian>
inline const unsigned char*
Sized_relobj<size, big_endian>::section_header(unsigned int shnum)
{
  assert(shnum < this->shnum());
  off_t symtabshdroff = this->shoff_ + shnum * This::shdr_size;
  return this->get_view(symtabshdroff, This::shdr_size);
}

// Return the name of section SHNUM.  The object must already be
// locked.

template<int size, bool big_endian>
std::string
Sized_relobj<size, big_endian>::do_section_name(unsigned int shnum)
{
  // Read the section names.
  typename This::Shdr shdrnames(this->section_header(this->shstrndx_));
  const unsigned char* pnamesu = this->get_view(shdrnames.get_sh_offset(),
						shdrnames.get_sh_size());
  const char* pnames = reinterpret_cast<const char*>(pnamesu);

  typename This::Shdr shdr(this->section_header(shnum));
  if (shdr.get_sh_name() >= shdrnames.get_sh_size())
    {
      fprintf(stderr,
	      _("%s: %s: bad section name offset for section %u: %lu\n"),
	      program_name, this->name().c_str(), shnum,
	      static_cast<unsigned long>(shdr.get_sh_name()));
      gold_exit(false);
    }

  return std::string(pnames + shdr.get_sh_name());
}

// Return a view of the contents of section SHNUM.  The object does
// not have to be locked.

template<int size, bool big_endian>
const unsigned char*
Sized_relobj<size, big_endian>::do_section_contents(unsigned int shnum,
						    off_t* plen)
{
  Task_locker_obj<Object> tl(*this);

  typename This::Shdr shdr(this->section_header(shnum));
  *plen = shdr.get_sh_size();
  return this->get_view(shdr.get_sh_offset(), shdr.get_sh_size());
}

// Set up an object file bsaed on the file header.  This sets up the
d93 1
a93 11
  unsigned int shnum = ehdr.get_e_shnum();
  unsigned int shstrndx = ehdr.get_e_shstrndx();
  if ((shnum == 0 || shstrndx == elfcpp::SHN_XINDEX)
      && this->shoff_ != 0)
    {
      typename This::Shdr shdr(this->section_header(0));
      if (shnum == 0)
	shnum = shdr.get_sh_size();
      if (shstrndx == elfcpp::SHN_XINDEX)
	shstrndx = shdr.get_sh_link();
    }
a94 2
  this->shstrndx_ = shstrndx;

d99 2
a100 1
  this->section_headers_ = this->get_lasting_view(this->shoff_,
d116 1
a116 1
	  this->symtab_shnum_ = i;
d134 3
a136 1
  const unsigned char* pshdrnames = pshdrs + this->shstrndx_ * This::shdr_size;
d142 1
a142 1
  if (this->symtab_shnum_ == 0)
d154 1
a154 1
				 + this->symtab_shnum_ * This::shdr_size);
d231 2
a232 8
  if (shdr.get_sh_link() >= this->shnum())
    {
      fprintf(stderr, _("%s: %s: section group %u link %u out of range\n"),
	      program_name, this->name().c_str(), index, shdr.get_sh_link());
      gold_exit(false);
    }

  typename This::Shdr symshdr(this->section_header(shdr.get_sh_link()));
a244 11
  // Read the section header for the symbol table names.
  if (symshdr.get_sh_link() >= this->shnum())
    {
      fprintf(stderr, _("%s; %s: symtab section %u link %u out of range\n"),
	      program_name, this->name().c_str(), shdr.get_sh_link(),
	      symshdr.get_sh_link());
      gold_exit(false);
    }

  typename This::Shdr symnamehdr(this->section_header(symshdr.get_sh_link()));

d246 3
a248 2
  const unsigned char *psymnamesu = this->get_view(symnamehdr.get_sh_offset(),
						   symnamehdr.get_sh_size());
d252 1
a252 1
  if (sym.get_st_name() >= symnamehdr.get_sh_size())
d266 5
a270 20
  if (signature[0] == '\0'
      && sym.get_st_type() == elfcpp::STT_SECTION
      && sym.get_st_shndx() < this->shnum())
    {
      typename This::Shdr shdrnames(this->section_header(this->shstrndx_));
      const unsigned char* pnamesu = this->get_view(shdrnames.get_sh_offset(),
						    shdrnames.get_sh_size());
      const char* pnames = reinterpret_cast<const char*>(pnamesu);
      
      typename This::Shdr sechdr(this->section_header(sym.get_st_shndx()));
      if (sechdr.get_sh_name() >= shdrnames.get_sh_size())
	{
	  fprintf(stderr,
		  _("%s: %s: bad section name offset for section %u: %lu\n"),
		  program_name, this->name().c_str(), sym.get_st_shndx(),
		  static_cast<unsigned long>(sechdr.get_sh_name()));
	  gold_exit(false);
	}

      signature = pnames + sechdr.get_sh_name();
d467 1
a467 1
  if (this->symtab_shnum_ == 0)
d478 3
a480 1
  typename This::Shdr symtabshdr(this->section_header(this->symtab_shnum_));
a492 5
  // Read the section header for the symbol names.
  typename This::Shdr strtabshdr(
    this->section_header(symtabshdr.get_sh_link()));
  assert(strtabshdr.get_sh_type() == elfcpp::SHT_STRTAB);

d494 4
a497 2
  const unsigned char* pnamesu = this->get_view(strtabshdr.get_sh_offset(),
						strtabshdr.get_sh_size());
d551 11
d580 1
a580 1
  if (this->symtab_shnum_ == 0)
d587 3
a589 1
  typename This::Shdr symtabshdr(this->section_header(this->symtab_shnum_));
a599 5
  // Read the section header for the symbol names.
  typename This::Shdr strtabshdr(
    this->section_header(symtabshdr.get_sh_link()));
  assert(strtabshdr.get_sh_type() == elfcpp::SHT_STRTAB);

d601 4
a604 2
  const unsigned char* pnamesu = this->get_view(strtabshdr.get_sh_offset(),
						strtabshdr.get_sh_size());
d634 1
@


1.11
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@d631 1
a631 1
	  pool->add(pnames + sym.get_st_name());
@


1.10
log
@Can now do a full static link of hello, world in C or C++
@
text
@a8 1
#include "object.h"
d12 3
d19 1
a19 3
// Class Object.

// Class Sized_object.
d22 1
a22 1
Sized_object<size, big_endian>::Sized_object(
d27 1
a27 1
  : Object(name, input_file, false, offset),
d56 1
a56 1
Sized_object<size, big_endian>::~Sized_object()
d64 1
a64 1
Sized_object<size, big_endian>::section_header(unsigned int shnum)
d71 2
a72 1
// Return the name of section SHNUM.
d76 1
a76 1
Sized_object<size, big_endian>::do_section_name(unsigned int shnum)
a77 2
  Task_lock_obj<Object> tl(*this);

d97 15
d117 1
a117 1
Sized_object<size, big_endian>::setup(
d176 1
a176 1
Sized_object<size, big_endian>::do_read_symbols(Read_symbols_data* sd)
d253 1
a253 1
Sized_object<size, big_endian>::include_section_group(
d268 1
a268 1
  elfcpp::Elf_Word flags = elfcpp::read_elf_word<big_endian>(pword);
d362 2
a363 1
      elfcpp::Elf_Word secnum = elfcpp::read_elf_word<big_endian>(pword + i);
d395 1
a395 1
Sized_object<size, big_endian>::include_linkonce_section(
d413 3
a415 1
Sized_object<size, big_endian>::do_layout(Layout* layout,
d435 6
a440 1
  for (unsigned int i = 0; i < shnum; ++i, pshdrs += This::shdr_size)
d455 7
d501 1
a501 1
Sized_object<size, big_endian>::do_add_symbols(Symbol_table* symtab,
a521 3
  const unsigned char* psyms = sd->symbols->data();
  const elfcpp::Sym<size, big_endian>* syms =
    reinterpret_cast<const elfcpp::Sym<size, big_endian>*>(psyms);
d524 4
a527 2
  symtab->add_from_object(this, syms, symcount, sym_names, 
			  sd->symbol_names_size,  this->symbols_);
d543 1
a543 1
Sized_object<size, big_endian>::do_finalize_local_symbols(off_t off,
d629 6
a634 3
      pool->add(pnames + sym.get_st_name());
      off += sym_size;
      ++count;
d646 1
a646 1
Sized_object<size, big_endian>::write_local_symbols(Output_file* of,
d689 3
a691 1
      elfcpp::Sym_write<size, big_endian> osym(ov);
d702 2
d721 2
d726 4
a729 1
  this->object_list_.push_back(obj);
a739 3

  if (obj->is_dynamic())
    this->any_dynamic_ = true;
d792 2
a793 2
      Sized_object<size, big_endian>* obj =
	new Sized_object<size, big_endian>(name, input_file, offset, ehdr);
d921 1
a921 1
class Sized_object<32, false>;
d924 1
a924 1
class Sized_object<32, true>;
d927 1
a927 1
class Sized_object<64, false>;
d930 1
a930 1
class Sized_object<64, true>;
@


1.9
log
@Framework for relocation scanning.  Implement simple static TLS
relocations.
@
text
@a18 19
const unsigned char*
Object::get_view(off_t start, off_t size)
{
  return this->input_file_->file().get_view(start + this->offset_, size);
}

void
Object::read(off_t start, off_t size, void* p)
{
  this->input_file_->file().read(start + this->offset_, size, p);
}

File_view*
Object::get_lasting_view(off_t start, off_t size)
{
  return this->input_file_->file().get_lasting_view(start + this->offset_,
						    size);
}

d63 1
a63 1
const unsigned char*
d312 26
d456 1
a456 1
      Output_section* os = layout->layout(this, name, shdr, &offset);
d524 1
a524 1
  off = (off + (size >> 3) - 1) & ~ ((off_t) (size >> 3) - 1);
d597 1
d666 1
a666 1
	  st_shndx = mo[st_shndx].output_section->shndx();
@


1.8
log
@Avoid multiple definition errors from linkonce sections.
@
text
@d90 27
d212 3
a214 1
  off_t locsize = symtabshdr.get_sh_info() * sym_size;
d222 1
d224 1
a224 1
  if (strtab_shnum == 0 || strtab_shnum >= this->shnum())
d230 1
a230 1
  typename This::Shdr strtabshdr(this->section_header(strtab_shnum));
a525 1
  unsigned int loccount = symtabshdr.get_sh_info();
d527 2
a532 2
  this->local_symbol_count_ = loccount;

d619 2
a620 2
  unsigned int local_symbol_count = this->local_symbol_count_;
  assert(local_symbol_count == symtabshdr.get_sh_info());
d624 1
a624 1
  off_t locsize = local_symbol_count * sym_size;
d647 1
a647 1
  for (unsigned int i = 1; i < local_symbol_count; ++i, psyms += sym_size)
d697 25
d886 12
@


1.7
log
@Lay out object file sections when we add the symbols to the symbol
table.
@
text
@d349 3
a351 3
  bool omit1 = layout->add_comdat(symname, false);
  bool omit2 = layout->add_comdat(name, true);
  return omit1 || omit2;
@


1.6
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d47 1
d109 1
d127 10
a136 3
  // Find the SHT_SYMTAB section.
  const unsigned char* p = this->get_view (this->shoff_,
					   shnum * This::shdr_size);
d139 1
a139 1
  for (unsigned int i = 1; i < shnum; ++i)
a146 1
      p += This::shdr_size;
d150 1
a150 1
// Read the symbols and relocations from an object file.
d153 2
a154 2
Read_symbols_data
Sized_object<size, big_endian>::do_read_symbols()
d156 12
d171 5
a175 6
      Read_symbols_data ret;
      ret.symbols = NULL;
      ret.symbols_size = 0;
      ret.symbol_names = NULL;
      ret.symbol_names_size = 0;
      return ret;
d178 3
a180 2
  // Read the symbol table section header.
  typename This::Shdr symtabshdr(this->section_header(this->symtab_shnum_));
d214 4
a217 43
  Read_symbols_data ret;
  ret.symbols = fvsymtab;
  ret.symbols_size = extsize;
  ret.symbol_names = fvstrtab;
  ret.symbol_names_size = strtabshdr.get_sh_size();

  return ret;
}

// Add the symbols to the symbol table.

template<int size, bool big_endian>
void
Sized_object<size, big_endian>::do_add_symbols(Symbol_table* symtab,
					       Read_symbols_data sd)
{
  if (sd.symbols == NULL)
    {
      assert(sd.symbol_names == NULL);
      return;
    }

  const int sym_size = This::sym_size;
  size_t symcount = sd.symbols_size / sym_size;
  if (symcount * sym_size != sd.symbols_size)
    {
      fprintf(stderr,
	      _("%s: %s: size of symbols is not multiple of symbol size\n"),
	      program_name, this->name().c_str());
      gold_exit(false);
    }

  this->symbols_ = new Symbol*[symcount];

  const elfcpp::Sym<size, big_endian>* syms =
    reinterpret_cast<const elfcpp::Sym<size, big_endian>*>(sd.symbols->data());
  const char* sym_names =
    reinterpret_cast<const char*>(sd.symbol_names->data());
  symtab->add_from_object(this, syms, symcount, sym_names, 
			  sd.symbol_names_size,  this->symbols_);

  delete sd.symbols;
  delete sd.symbol_names;
d361 2
a362 1
Sized_object<size, big_endian>::do_layout(Layout* layout)
d364 3
a366 3
  // This is always called from the main thread.  Lock the file to
  // keep the error checks happy.
  Task_locker_obj<File_read> frl(this->input_file()->file());
d369 1
a369 3
  unsigned int shnum = this->shnum();
  const unsigned char* pshdrs = this->get_view(this->shoff_,
					       shnum * This::shdr_size);
d372 1
a372 6
  const unsigned char* pshdrnames = pshdrs + this->shstrndx_ * This::shdr_size;
  typename This::Shdr shdrnames(pshdrnames);
  typename elfcpp::Elf_types<size>::Elf_WXword names_size =
    shdrnames.get_sh_size();
  const unsigned char* pnamesu = this->get_view(shdrnames.get_sh_offset(),
						shdrnames.get_sh_size());
d381 1
a381 1
  for (unsigned int i = 0; i < shnum; ++i)
d385 1
a385 1
      if (shdr.get_sh_name() >= names_size)
d423 1
d425 27
a451 1
      pshdrs += This::shdr_size;
d453 15
@


1.5
log
@Finished layout code.
@
text
@d12 1
d51 2
d54 2
a55 1
    local_symbol_offset_(0)
d84 1
d401 1
a401 1
  map_sections.reserve(shnum);
d454 4
a457 4
// which they should be output and we add their names to *POOL.
// Return the new file offset.  This function is always called from
// the main thread.  The actual output of the local symbols will occur
// in a separate task.
d464 8
d485 4
d503 1
d506 1
a506 1
  for (unsigned int i = 1; i < loccount; ++i)
d514 3
a516 1
	  if (shndx != elfcpp::SHN_ABS)
d518 1
a524 1
	  // FIXME: Handle SHN_XINDEX.
d538 7
a544 1
	    continue;
d549 2
d552 16
a567 1
      psyms += sym_size;
d570 58
a627 1
  return off;
@


1.4
log
@More section layout code.
@
text
@d50 2
a51 1
    symbols_(NULL)
d74 10
d108 1
a108 2
      const unsigned char* p = this->get_view (this->shoff_, This::shdr_size);
      elfcpp::Shdr<size, big_endian> shdr(p);
d127 1
a127 1
      elfcpp::Shdr<size, big_endian> shdr(p);
a148 1
      ret.first_global = 0;
a153 2
  const int shdr_size = This::shdr_size;

d155 1
a155 3
  off_t symtabshdroff = this->shoff_ + (this->symtab_shnum_ * shdr_size);
  const unsigned char* psymtabshdr = this->get_view(symtabshdroff, shdr_size);
  elfcpp::Shdr<size, big_endian> symtabshdr(psymtabshdr);
d158 6
d165 1
a165 2
  File_view* fvsymtab = this->get_lasting_view(symtabshdr.get_sh_offset(),
					       symtabshdr.get_sh_size());
d175 1
a175 3
  off_t strtabshdroff = this->shoff_ + (strtab_shnum * shdr_size);
  const unsigned char *pstrtabshdr = this->get_view(strtabshdroff, shdr_size);
  elfcpp::Shdr<size, big_endian> strtabshdr(pstrtabshdr);
d191 1
a191 2
  ret.symbols_size = symtabshdr.get_sh_size();
  ret.first_global = symtabshdr.get_sh_info();
d221 4
d227 2
a228 21

  // We only add the global symbols to the symbol table.
  if (symcount > sd.first_global)
    {
      this->symbols_ = new Symbol*[symcount - sd.first_global];

      const unsigned char* symdata = sd.symbols->data();
      symdata += sd.first_global * sym_size;
      const elfcpp::Sym<size, big_endian>* syms =
	reinterpret_cast<const elfcpp::Sym<size, big_endian>*>(symdata);

      symtab->add_from_object(this, syms, symcount - sd.first_global,
			      sym_names, sd.symbol_names_size, this->symbols_);
    }

  // Add the names of the local symbols.  FIXME: We shouldn't do this
  // if we are stripping symbols.
  const elfcpp::Sym<size, big_endian>* local_syms =
    reinterpret_cast<const elfcpp::Sym<size, big_endian>*>(sd.symbols->data());
  symtab->add_local_symbol_names(this, local_syms, sd.first_global,
				 sym_names, sd.symbol_names_size);
d274 2
a275 3
  off_t off = this->shoff_ + shdr.get_sh_link() * This::shdr_size;
  const unsigned char* psymshdr = this->get_view(off, This::shdr_size);
  elfcpp::Shdr<size, big_endian> symshdr(psymshdr);
d296 2
a297 4
  off_t symnameoff = this->shoff_ + symshdr.get_sh_link() * This::shdr_size;
  const unsigned char* psymnamehdr = this->get_view(symnameoff,
						    This::shdr_size);
  elfcpp::Shdr<size, big_endian> symnamehdr(psymnamehdr);
d388 1
a388 1
  elfcpp::Shdr<size, big_endian> shdrnames(pshdrnames);
d403 1
a403 1
      elfcpp::Shdr<size, big_endian> shdr(pshdrs);
d448 82
d536 11
@


1.3
log
@New drop, with first cut of section layout code.
@
text
@d139 1
a152 6
  // We only need the external symbols.
  const int sym_size = This::sym_size;
  off_t locsize = symtabshdr.get_sh_info() * sym_size;
  off_t extoff = symtabshdr.get_sh_offset() + locsize;
  off_t extsize = symtabshdr.get_sh_size() - locsize;

d154 2
a155 1
  File_view* fvsymtab = this->get_lasting_view(extoff, extsize);
d183 2
a184 1
  ret.symbols_size = extsize;
d214 16
a229 1
  this->symbols_ = new Symbol*[symcount];
d231 3
a233 1
  const elfcpp::Sym<size, big_endian>* syms =
d235 2
a236 4
  const char* sym_names =
    reinterpret_cast<const char*>(sd.symbol_names->data());
  symtab->add_from_object(this, syms, symcount, sym_names, 
			  sd.symbol_names_size,  this->symbols_);
d457 10
@


1.2
log
@Another snapshot of the current state of the sources.  Gets to the
point of symbol resolution and can now issue a multiple definition
error.  Also added target selection infrastructure.
@
text
@d11 1
a45 3
    osabi_(ehdr.get_e_ident()[elfcpp::EI_OSABI]),
    abiversion_(ehdr.get_e_ident()[elfcpp::EI_ABIVERSION]),
    machine_(ehdr.get_e_machine()),
a47 1
    shnum_(0),
d52 1
a52 1
  if (ehdr.get_e_ehsize() != elfcpp::Elf_sizes<size>::ehdr_size)
d56 1
a56 1
	      elfcpp::Elf_sizes<size>::ehdr_size);
d59 1
a59 1
  if (ehdr.get_e_shentsize() != elfcpp::Elf_sizes<size>::shdr_size)
d63 1
a63 1
	      elfcpp::Elf_sizes<size>::shdr_size);
d81 4
a84 2
  Target* target = select_target(this->machine_, size, big_endian,
				 this->osabi_, this->abiversion_);
d88 1
a88 1
	      program_name, this->name().c_str(), this->machine_);
d97 1
a97 2
      const unsigned char* p = this->get_view
	(this->shoff_, elfcpp::Elf_sizes<size>::shdr_size);
d104 1
a104 1
  this->shnum_ = shnum;
d111 2
a112 2
  const unsigned char* p = this->get_view
    (this->shoff_, shnum * elfcpp::Elf_sizes<size>::shdr_size);
d114 1
a114 1
  p += elfcpp::Elf_sizes<size>::shdr_size;
d123 1
a123 1
      p += elfcpp::Elf_sizes<size>::shdr_size;
d144 1
a144 1
  int shdr_size = elfcpp::Elf_sizes<size>::shdr_size;
d153 1
a153 1
  int sym_size = elfcpp::Elf_sizes<size>::sym_size;
d163 1
a163 1
  if (strtab_shnum == 0 || strtab_shnum >= this->shnum_)
d207 1
a207 1
  unsigned int sym_size = elfcpp::Elf_sizes<size>::sym_size;
d225 220
@


1.1
log
@Initial CVS checkin of gold
@
text
@d10 1
d44 1
a44 1
  : Object(name, input_file, offset),
a48 1
    target_(NULL),
d52 2
a53 1
    symtab_shnum_(0)
d84 9
a92 2
  //  this->target_ = select_target(this->machine_, size, big_endian,
  //				this->osabi_, this->abiversion_);
d154 6
d161 1
a161 2
  File_view* fvsymtab = this->get_lasting_view(symtabshdr.get_sh_offset(),
					       symtabshdr.get_sh_size());
d189 1
a189 1
  ret.symbols_size = symtabshdr.get_sh_size();
d200 2
a201 1
Sized_object<size, big_endian>::do_add_symbols(Read_symbols_data sd)
d209 3
a211 4
  int sym_size = elfcpp::Elf_sizes<size>::sym_size;
  const unsigned char* symstart = sd.symbols->data();
  const unsigned char* symend = symstart + sd.symbols_size;
  for (const unsigned char* p = symstart; p < symend; p += sym_size)
d213 7
a219 1
      elfcpp::Sym<size, big_endian> sym(p);
d221 6
a226 12
      unsigned int nameoff = sym.get_st_name();
      if (nameoff >= sd.symbol_names_size)
	{
	  fprintf(stderr,
		  _("%s: %s: invalid symbol name offset %u for symbol %d\n"),
		  program_name, this->name().c_str(), nameoff,
		  (p - symstart) / sym_size);
	  gold_exit(false);
	}
      const unsigned char* name = sd.symbol_names->data() + nameoff;
      printf("%s\n", name);
    }
@

