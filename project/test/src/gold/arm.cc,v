head	1.164;
access;
symbols
	binutils-2_24-branch:1.163.0.2
	binutils-2_24-branchpoint:1.163
	binutils-2_21_1:1.126
	binutils-2_23_2:1.152.2.2
	binutils-2_23_1:1.152.2.1
	binutils-2_23:1.152
	binutils-2_23-branch:1.152.0.2
	binutils-2_23-branchpoint:1.152
	binutils-2_22_branch:1.138.2.4.0.2
	binutils-2_22:1.138.2.4
	binutils-2_22-branch:1.138.0.2
	binutils-2_22-branchpoint:1.138
	binutils-2_21:1.126
	binutils-2_21-branch:1.126.0.2
	binutils-2_21-branchpoint:1.126
	binutils-2_20_1:1.8.2.3
	binutils-2_20:1.8.2.1
	binutils-2_20-branch:1.8.0.2
	binutils-2_20-branchpoint:1.8
	dje-cgen-play1-branch:1.7.0.2
	dje-cgen-play1-branchpoint:1.7
	binutils_latest_snapshot:1.164;
locks; strict;
comment	@// @;


1.164
date	2013.10.11.21.11.49;	author roland;	state Exp;
branches;
next	1.163;

1.163
date	2013.07.30.21.26.52;	author ccoutant;	state Exp;
branches
	1.163.2.1;
next	1.162;

1.162
date	2013.04.27.00.53.16;	author ian;	state Exp;
branches;
next	1.161;

1.161
date	2013.01.09.15.27.24;	author ian;	state Exp;
branches;
next	1.160;

1.160
date	2012.12.03.05.30.59;	author amodra;	state Exp;
branches;
next	1.159;

1.159
date	2012.11.15.00.30.11;	author roland;	state Exp;
branches;
next	1.158;

1.158
date	2012.11.01.23.26.59;	author roland;	state Exp;
branches;
next	1.157;

1.157
date	2012.10.30.12.44.55;	author nickc;	state Exp;
branches;
next	1.156;

1.156
date	2012.10.18.04.18.18;	author amodra;	state Exp;
branches;
next	1.155;

1.155
date	2012.09.12.22.43.53;	author amodra;	state Exp;
branches;
next	1.154;

1.154
date	2012.09.10.23.05.54;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2012.09.05.00.34.20;	author amodra;	state Exp;
branches;
next	1.152;

1.152
date	2012.07.11.14.18.39;	author ian;	state Exp;
branches
	1.152.2.1;
next	1.151;

1.151
date	2012.05.02.21.37.23;	author roland;	state Exp;
branches;
next	1.150;

1.150
date	2012.04.26.00.07.17;	author ian;	state Exp;
branches;
next	1.149;

1.149
date	2012.03.19.23.54.07;	author dougkwan;	state Exp;
branches;
next	1.148;

1.148
date	2012.03.15.18.24.06;	author dougkwan;	state Exp;
branches;
next	1.147;

1.147
date	2012.03.14.23.07.07;	author dougkwan;	state Exp;
branches;
next	1.146;

1.146
date	2012.02.03.20.01.01;	author dougkwan;	state Exp;
branches;
next	1.145;

1.145
date	2012.02.02.20.21.17;	author dougkwan;	state Exp;
branches;
next	1.144;

1.144
date	2012.01.28.01.47.01;	author ian;	state Exp;
branches;
next	1.143;

1.143
date	2011.11.11.21.49.36;	author dougkwan;	state Exp;
branches;
next	1.142;

1.142
date	2011.11.10.20.53.36;	author dougkwan;	state Exp;
branches;
next	1.141;

1.141
date	2011.11.10.00.41.53;	author dougkwan;	state Exp;
branches;
next	1.140;

1.140
date	2011.11.03.03.38.34;	author ian;	state Exp;
branches;
next	1.139;

1.139
date	2011.11.02.19.11.47;	author ian;	state Exp;
branches;
next	1.138;

1.138
date	2011.07.06.17.58.42;	author dougkwan;	state Exp;
branches
	1.138.2.1;
next	1.137;

1.137
date	2011.06.28.23.12.31;	author ian;	state Exp;
branches;
next	1.136;

1.136
date	2011.06.28.21.15.42;	author ian;	state Exp;
branches;
next	1.135;

1.135
date	2011.06.27.17.53.31;	author dougkwan;	state Exp;
branches;
next	1.134;

1.134
date	2011.06.24.16.40.34;	author dougkwan;	state Exp;
branches;
next	1.133;

1.133
date	2011.06.01.19.59.41;	author dougkwan;	state Exp;
branches;
next	1.132;

1.132
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.131;

1.131
date	2011.04.22.21.50.03;	author dougkwan;	state Exp;
branches;
next	1.130;

1.130
date	2010.12.14.19.03.29;	author rwild;	state Exp;
branches;
next	1.129;

1.129
date	2010.12.08.05.18.54;	author dougkwan;	state Exp;
branches;
next	1.128;

1.128
date	2010.11.11.10.43.30;	author rsandifo;	state Exp;
branches;
next	1.127;

1.127
date	2010.11.09.07.56.10;	author dougkwan;	state Exp;
branches;
next	1.126;

1.126
date	2010.10.29.20.49.20;	author dougkwan;	state Exp;
branches;
next	1.125;

1.125
date	2010.10.20.15.30.54;	author dougkwan;	state Exp;
branches;
next	1.124;

1.124
date	2010.10.17.15.12.50;	author dougkwan;	state Exp;
branches;
next	1.123;

1.123
date	2010.10.12.19.00.30;	author ian;	state Exp;
branches;
next	1.122;

1.122
date	2010.09.17.23.51.42;	author dougkwan;	state Exp;
branches;
next	1.121;

1.121
date	2010.09.08.23.54.51;	author dougkwan;	state Exp;
branches;
next	1.120;

1.120
date	2010.09.08.18.31.35;	author espindola;	state Exp;
branches;
next	1.119;

1.119
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.118;

1.118
date	2010.08.12.22.14.59;	author ccoutant;	state Exp;
branches;
next	1.117;

1.117
date	2010.08.12.18.27.46;	author dougkwan;	state Exp;
branches;
next	1.116;

1.116
date	2010.08.03.14.07.12;	author ian;	state Exp;
branches;
next	1.115;

1.115
date	2010.08.02.20.44.31;	author ian;	state Exp;
branches;
next	1.114;

1.114
date	2010.07.29.18.57.28;	author tmsriram;	state Exp;
branches;
next	1.113;

1.113
date	2010.07.13.20.07.08;	author dougkwan;	state Exp;
branches;
next	1.112;

1.112
date	2010.07.13.12.04.03;	author ian;	state Exp;
branches;
next	1.111;

1.111
date	2010.06.30.06.41.09;	author dougkwan;	state Exp;
branches;
next	1.110;

1.110
date	2010.06.25.00.37.40;	author dougkwan;	state Exp;
branches;
next	1.109;

1.109
date	2010.06.16.18.19.18;	author dougkwan;	state Exp;
branches;
next	1.108;

1.108
date	2010.06.15.23.51.51;	author dougkwan;	state Exp;
branches;
next	1.107;

1.107
date	2010.06.08.00.33.41;	author dougkwan;	state Exp;
branches;
next	1.106;

1.106
date	2010.05.26.03.33.59;	author dougkwan;	state Exp;
branches;
next	1.105;

1.105
date	2010.05.23.07.43.39;	author dougkwan;	state Exp;
branches;
next	1.104;

1.104
date	2010.05.22.01.06.49;	author hjl;	state Exp;
branches;
next	1.103;

1.103
date	2010.05.19.07.09.36;	author dougkwan;	state Exp;
branches;
next	1.102;

1.102
date	2010.05.13.02.41.15;	author dougkwan;	state Exp;
branches;
next	1.101;

1.101
date	2010.04.21.16.32.28;	author aph;	state Exp;
branches;
next	1.100;

1.100
date	2010.04.15.00.42.15;	author dougkwan;	state Exp;
branches;
next	1.99;

1.99
date	2010.04.13.20.37.55;	author dougkwan;	state Exp;
branches;
next	1.98;

1.98
date	2010.04.08.06.56.15;	author dougkwan;	state Exp;
branches;
next	1.97;

1.97
date	2010.04.07.21.42.22;	author dougkwan;	state Exp;
branches;
next	1.96;

1.96
date	2010.03.31.06.05.37;	author dougkwan;	state Exp;
branches;
next	1.95;

1.95
date	2010.03.26.04.53.34;	author dougkwan;	state Exp;
branches;
next	1.94;

1.94
date	2010.03.22.22.48.05;	author dougkwan;	state Exp;
branches;
next	1.93;

1.93
date	2010.03.19.19.11.21;	author dougkwan;	state Exp;
branches;
next	1.92;

1.92
date	2010.03.08.22.15.16;	author dougkwan;	state Exp;
branches;
next	1.91;

1.91
date	2010.03.03.19.31.54;	author ian;	state Exp;
branches;
next	1.90;

1.90
date	2010.02.27.00.46.00;	author dougkwan;	state Exp;
branches;
next	1.89;

1.89
date	2010.02.27.00.36.49;	author dougkwan;	state Exp;
branches;
next	1.88;

1.88
date	2010.02.25.05.11.26;	author dougkwan;	state Exp;
branches;
next	1.87;

1.87
date	2010.02.24.20.50.59;	author dougkwan;	state Exp;
branches;
next	1.86;

1.86
date	2010.02.24.20.45.10;	author dougkwan;	state Exp;
branches;
next	1.85;

1.85
date	2010.02.23.17.45.38;	author ian;	state Exp;
branches;
next	1.84;

1.84
date	2010.02.22.06.26.07;	author dougkwan;	state Exp;
branches;
next	1.83;

1.83
date	2010.02.19.22.53.54;	author dougkwan;	state Exp;
branches;
next	1.82;

1.82
date	2010.02.19.02.16.41;	author dougkwan;	state Exp;
branches;
next	1.81;

1.81
date	2010.02.13.02.04.20;	author tmsriram;	state Exp;
branches;
next	1.80;

1.80
date	2010.02.12.05.51.31;	author dougkwan;	state Exp;
branches;
next	1.79;

1.79
date	2010.02.09.20.29.44;	author davem;	state Exp;
branches;
next	1.78;

1.78
date	2010.02.09.06.46.00;	author dougkwan;	state Exp;
branches;
next	1.77;

1.77
date	2010.02.06.04.30.00;	author dougkwan;	state Exp;
branches;
next	1.76;

1.76
date	2010.02.04.03.32.18;	author dougkwan;	state Exp;
branches;
next	1.75;

1.75
date	2010.02.03.19.32.28;	author dougkwan;	state Exp;
branches;
next	1.74;

1.74
date	2010.02.03.05.36.55;	author dougkwan;	state Exp;
branches;
next	1.73;

1.73
date	2010.02.02.00.25.57;	author dougkwan;	state Exp;
branches;
next	1.72;

1.72
date	2010.01.30.00.11.00;	author dougkwan;	state Exp;
branches;
next	1.71;

1.71
date	2010.01.30.00.01.12;	author dougkwan;	state Exp;
branches;
next	1.70;

1.70
date	2010.01.29.22.16.17;	author dougkwan;	state Exp;
branches;
next	1.69;

1.69
date	2010.01.29.18.23.18;	author dougkwan;	state Exp;
branches;
next	1.68;

1.68
date	2010.01.29.15.46.43;	author ian;	state Exp;
branches;
next	1.67;

1.67
date	2010.01.27.15.17.46;	author ian;	state Exp;
branches;
next	1.66;

1.66
date	2010.01.26.21.29.10;	author dougkwan;	state Exp;
branches;
next	1.65;

1.65
date	2010.01.25.17.30.29;	author dougkwan;	state Exp;
branches;
next	1.64;

1.64
date	2010.01.23.01.07.59;	author dougkwan;	state Exp;
branches;
next	1.63;

1.63
date	2010.01.22.19.43.00;	author dougkwan;	state Exp;
branches;
next	1.62;

1.62
date	2010.01.22.17.53.18;	author dougkwan;	state Exp;
branches;
next	1.61;

1.61
date	2010.01.22.06.06.46;	author dougkwan;	state Exp;
branches;
next	1.60;

1.60
date	2010.01.22.00.51.17;	author dougkwan;	state Exp;
branches;
next	1.59;

1.59
date	2010.01.20.17.29.52;	author dougkwan;	state Exp;
branches;
next	1.58;

1.58
date	2010.01.20.16.49.09;	author ian;	state Exp;
branches;
next	1.57;

1.57
date	2010.01.15.15.41.42;	author ian;	state Exp;
branches;
next	1.56;

1.56
date	2010.01.15.04.58.34;	author dougkwan;	state Exp;
branches;
next	1.55;

1.55
date	2010.01.14.02.42.20;	author dougkwan;	state Exp;
branches;
next	1.54;

1.54
date	2010.01.13.21.36.47;	author dougkwan;	state Exp;
branches;
next	1.53;

1.53
date	2010.01.13.06.44.01;	author dougkwan;	state Exp;
branches;
next	1.52;

1.52
date	2010.01.13.02.00.39;	author dougkwan;	state Exp;
branches;
next	1.51;

1.51
date	2010.01.12.07.54.37;	author dougkwan;	state Exp;
branches;
next	1.50;

1.50
date	2010.01.12.07.22.56;	author dougkwan;	state Exp;
branches;
next	1.49;

1.49
date	2010.01.09.01.55.14;	author dougkwan;	state Exp;
branches;
next	1.48;

1.48
date	2010.01.07.20.43.35;	author ian;	state Exp;
branches;
next	1.47;

1.47
date	2010.01.07.18.38.43;	author dougkwan;	state Exp;
branches;
next	1.46;

1.46
date	2009.12.30.06.57.17;	author ian;	state Exp;
branches;
next	1.45;

1.45
date	2009.12.29.00.31.48;	author ian;	state Exp;
branches;
next	1.44;

1.44
date	2009.12.17.00.00.26;	author dougkwan;	state Exp;
branches;
next	1.43;

1.43
date	2009.12.14.19.53.04;	author ian;	state Exp;
branches;
next	1.42;

1.42
date	2009.12.12.01.26.12;	author dougkwan;	state Exp;
branches;
next	1.41;

1.41
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2009.12.10.20.55.33;	author dougkwan;	state Exp;
branches;
next	1.39;

1.39
date	2009.12.06.02.49.46;	author dougkwan;	state Exp;
branches;
next	1.38;

1.38
date	2009.12.06.02.20.53;	author dougkwan;	state Exp;
branches;
next	1.37;

1.37
date	2009.12.03.23.13.55;	author dougkwan;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.25.08.08.45;	author dougkwan;	state Exp;
branches;
next	1.35;

1.35
date	2009.11.25.04.32.36;	author dougkwan;	state Exp;
branches;
next	1.34;

1.34
date	2009.11.25.04.11.56;	author dougkwan;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.16.03.39.11;	author dougkwan;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.09.23.16.55;	author dougkwan;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.09.16.03.45;	author dougkwan;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.07.01.58.06;	author dougkwan;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.04.16.35.51;	author ian;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.04.15.56.03;	author ian;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.03.21.18.13;	author dougkwan;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.31.03.06.59;	author dougkwan;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.31.02.59.36;	author dougkwan;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.30.18.49.59;	author dougkwan;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.30.18.00.55;	author dougkwan;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.29.05.16.22;	author ian;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.29.01.53.35;	author dougkwan;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.24.09.36.15;	author dougkwan;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.22.18.58.02;	author dougkwan;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.21.18.33.18;	author dougkwan;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.21.08.08.41;	author dougkwan;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.13.00.39.31;	author tmsriram;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.09.22.56.41;	author ian;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.09.22.45.13;	author ian;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.07.15.41.50;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.07.15.30.40;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.06.22.58.27;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.01.00.58.38;	author dougkwan;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.18.00.45.53;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.11.17.09.14;	author dougkwan;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2009.06.22.06.51.53;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.04.01.31.01;	author dougkwan;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.03.19.33.05;	author dougkwan;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.03.14.05.07;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.03.00.06.15;	author dougkwan;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.30.00.55.42;	author dougkwan;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.29.00.15.12;	author dougkwan;	state Exp;
branches;
next	;

1.163.2.1
date	2013.10.11.21.23.42;	author roland;	state Exp;
branches;
next	;

1.152.2.1
date	2012.11.07.17.34.23;	author roland;	state Exp;
branches;
next	1.152.2.2;

1.152.2.2
date	2012.11.15.00.33.28;	author roland;	state Exp;
branches;
next	;

1.138.2.1
date	2011.11.15.15.31.56;	author mgretton;	state Exp;
branches;
next	1.138.2.2;

1.138.2.2
date	2011.11.21.09.32.16;	author gingold;	state Exp;
branches;
next	1.138.2.3;

1.138.2.3
date	2011.11.21.09.39.58;	author gingold;	state Exp;
branches;
next	1.138.2.4;

1.138.2.4
date	2011.11.21.09.40.39;	author gingold;	state Exp;
branches;
next	1.138.2.5;

1.138.2.5
date	2012.04.26.18.08.20;	author dougkwan;	state Exp;
branches;
next	;

1.8.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2009.11.04.15.56.34;	author ian;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2009.11.04.16.36.08;	author ian;	state Exp;
branches;
next	;


desc
@@


1.164
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@// arm.cc -- arm target support for gold.

// Copyright 2009, 2010, 2011, 2012, 2013 Free Software Foundation, Inc.
// Written by Doug Kwan <dougkwan@@google.com> based on the i386 code
// by Ian Lance Taylor <iant@@google.com>.
// This file also contains borrowed and adapted code from
// bfd/elf32-arm.c.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cstring>
#include <limits>
#include <cstdio>
#include <string>
#include <algorithm>
#include <map>
#include <utility>
#include <set>

#include "elfcpp.h"
#include "parameters.h"
#include "reloc.h"
#include "arm.h"
#include "object.h"
#include "symtab.h"
#include "layout.h"
#include "output.h"
#include "copy-relocs.h"
#include "target.h"
#include "target-reloc.h"
#include "target-select.h"
#include "tls.h"
#include "defstd.h"
#include "gc.h"
#include "attributes.h"
#include "arm-reloc-property.h"
#include "nacl.h"

namespace
{

using namespace gold;

template<bool big_endian>
class Output_data_plt_arm;

template<bool big_endian>
class Output_data_plt_arm_standard;

template<bool big_endian>
class Stub_table;

template<bool big_endian>
class Arm_input_section;

class Arm_exidx_cantunwind;

class Arm_exidx_merged_section;

class Arm_exidx_fixup;

template<bool big_endian>
class Arm_output_section;

class Arm_exidx_input_section;

template<bool big_endian>
class Arm_relobj;

template<bool big_endian>
class Arm_relocate_functions;

template<bool big_endian>
class Arm_output_data_got;

template<bool big_endian>
class Target_arm;

// For convenience.
typedef elfcpp::Elf_types<32>::Elf_Addr Arm_address;

// Maximum branch offsets for ARM, THUMB and THUMB2.
const int32_t ARM_MAX_FWD_BRANCH_OFFSET = ((((1 << 23) - 1) << 2) + 8);
const int32_t ARM_MAX_BWD_BRANCH_OFFSET = ((-((1 << 23) << 2)) + 8);
const int32_t THM_MAX_FWD_BRANCH_OFFSET = ((1 << 22) -2 + 4);
const int32_t THM_MAX_BWD_BRANCH_OFFSET = (-(1 << 22) + 4);
const int32_t THM2_MAX_FWD_BRANCH_OFFSET = (((1 << 24) - 2) + 4);
const int32_t THM2_MAX_BWD_BRANCH_OFFSET = (-(1 << 24) + 4);

// Thread Control Block size.
const size_t ARM_TCB_SIZE = 8;

// The arm target class.
//
// This is a very simple port of gold for ARM-EABI.  It is intended for
// supporting Android only for the time being.
//
// TODOs:
// - Implement all static relocation types documented in arm-reloc.def.
// - Make PLTs more flexible for different architecture features like
//   Thumb-2 and BE8.
// There are probably a lot more.

// Ideally we would like to avoid using global variables but this is used
// very in many places and sometimes in loops.  If we use a function
// returning a static instance of Arm_reloc_property_table, it will be very
// slow in an threaded environment since the static instance needs to be
// locked.  The pointer is below initialized in the
// Target::do_select_as_default_target() hook so that we do not spend time
// building the table if we are not linking ARM objects.
//
// An alternative is to to process the information in arm-reloc.def in
// compilation time and generate a representation of it in PODs only.  That
// way we can avoid initialization when the linker starts.

Arm_reloc_property_table* arm_reloc_property_table = NULL;

// Instruction template class.  This class is similar to the insn_sequence
// struct in bfd/elf32-arm.c.

class Insn_template
{
 public:
  // Types of instruction templates.
  enum Type
    {
      THUMB16_TYPE = 1,
      // THUMB16_SPECIAL_TYPE is used by sub-classes of Stub for instruction
      // templates with class-specific semantics.  Currently this is used
      // only by the Cortex_a8_stub class for handling condition codes in
      // conditional branches.
      THUMB16_SPECIAL_TYPE,
      THUMB32_TYPE,
      ARM_TYPE,
      DATA_TYPE
    };

  // Factory methods to create instruction templates in different formats.

  static const Insn_template
  thumb16_insn(uint32_t data)
  { return Insn_template(data, THUMB16_TYPE, elfcpp::R_ARM_NONE, 0); }

  // A Thumb conditional branch, in which the proper condition is inserted
  // when we build the stub.
  static const Insn_template
  thumb16_bcond_insn(uint32_t data)
  { return Insn_template(data, THUMB16_SPECIAL_TYPE, elfcpp::R_ARM_NONE, 1); }

  static const Insn_template
  thumb32_insn(uint32_t data)
  { return Insn_template(data, THUMB32_TYPE, elfcpp::R_ARM_NONE, 0); }

  static const Insn_template
  thumb32_b_insn(uint32_t data, int reloc_addend)
  {
    return Insn_template(data, THUMB32_TYPE, elfcpp::R_ARM_THM_JUMP24,
			 reloc_addend);
  }

  static const Insn_template
  arm_insn(uint32_t data)
  { return Insn_template(data, ARM_TYPE, elfcpp::R_ARM_NONE, 0); }

  static const Insn_template
  arm_rel_insn(unsigned data, int reloc_addend)
  { return Insn_template(data, ARM_TYPE, elfcpp::R_ARM_JUMP24, reloc_addend); }

  static const Insn_template
  data_word(unsigned data, unsigned int r_type, int reloc_addend)
  { return Insn_template(data, DATA_TYPE, r_type, reloc_addend); }

  // Accessors.  This class is used for read-only objects so no modifiers
  // are provided.

  uint32_t
  data() const
  { return this->data_; }

  // Return the instruction sequence type of this.
  Type
  type() const
  { return this->type_; }

  // Return the ARM relocation type of this.
  unsigned int
  r_type() const
  { return this->r_type_; }

  int32_t
  reloc_addend() const
  { return this->reloc_addend_; }

  // Return size of instruction template in bytes.
  size_t
  size() const;

  // Return byte-alignment of instruction template.
  unsigned
  alignment() const;

 private:
  // We make the constructor private to ensure that only the factory
  // methods are used.
  inline
  Insn_template(unsigned data, Type type, unsigned int r_type, int reloc_addend)
    : data_(data), type_(type), r_type_(r_type), reloc_addend_(reloc_addend)
  { }

  // Instruction specific data.  This is used to store information like
  // some of the instruction bits.
  uint32_t data_;
  // Instruction template type.
  Type type_;
  // Relocation type if there is a relocation or R_ARM_NONE otherwise.
  unsigned int r_type_;
  // Relocation addend.
  int32_t reloc_addend_;
};

// Macro for generating code to stub types. One entry per long/short
// branch stub

#define DEF_STUBS \
  DEF_STUB(long_branch_any_any) \
  DEF_STUB(long_branch_v4t_arm_thumb) \
  DEF_STUB(long_branch_thumb_only) \
  DEF_STUB(long_branch_v4t_thumb_thumb) \
  DEF_STUB(long_branch_v4t_thumb_arm) \
  DEF_STUB(short_branch_v4t_thumb_arm) \
  DEF_STUB(long_branch_any_arm_pic) \
  DEF_STUB(long_branch_any_thumb_pic) \
  DEF_STUB(long_branch_v4t_thumb_thumb_pic) \
  DEF_STUB(long_branch_v4t_arm_thumb_pic) \
  DEF_STUB(long_branch_v4t_thumb_arm_pic) \
  DEF_STUB(long_branch_thumb_only_pic) \
  DEF_STUB(a8_veneer_b_cond) \
  DEF_STUB(a8_veneer_b) \
  DEF_STUB(a8_veneer_bl) \
  DEF_STUB(a8_veneer_blx) \
  DEF_STUB(v4_veneer_bx)

// Stub types.

#define DEF_STUB(x) arm_stub_##x,
typedef enum
  {
    arm_stub_none,
    DEF_STUBS

    // First reloc stub type.
    arm_stub_reloc_first = arm_stub_long_branch_any_any,
    // Last  reloc stub type.
    arm_stub_reloc_last = arm_stub_long_branch_thumb_only_pic,

    // First Cortex-A8 stub type.
    arm_stub_cortex_a8_first = arm_stub_a8_veneer_b_cond,
    // Last Cortex-A8 stub type.
    arm_stub_cortex_a8_last = arm_stub_a8_veneer_blx,

    // Last stub type.
    arm_stub_type_last = arm_stub_v4_veneer_bx
  } Stub_type;
#undef DEF_STUB

// Stub template class.  Templates are meant to be read-only objects.
// A stub template for a stub type contains all read-only attributes
// common to all stubs of the same type.

class Stub_template
{
 public:
  Stub_template(Stub_type, const Insn_template*, size_t);

  ~Stub_template()
  { }

  // Return stub type.
  Stub_type
  type() const
  { return this->type_; }

  // Return an array of instruction templates.
  const Insn_template*
  insns() const
  { return this->insns_; }

  // Return size of template in number of instructions.
  size_t
  insn_count() const
  { return this->insn_count_; }

  // Return size of template in bytes.
  size_t
  size() const
  { return this->size_; }

  // Return alignment of the stub template.
  unsigned
  alignment() const
  { return this->alignment_; }

  // Return whether entry point is in thumb mode.
  bool
  entry_in_thumb_mode() const
  { return this->entry_in_thumb_mode_; }

  // Return number of relocations in this template.
  size_t
  reloc_count() const
  { return this->relocs_.size(); }

  // Return index of the I-th instruction with relocation.
  size_t
  reloc_insn_index(size_t i) const
  {
    gold_assert(i < this->relocs_.size());
    return this->relocs_[i].first;
  }

  // Return the offset of the I-th instruction with relocation from the
  // beginning of the stub.
  section_size_type
  reloc_offset(size_t i) const
  {
    gold_assert(i < this->relocs_.size());
    return this->relocs_[i].second;
  }

 private:
  // This contains information about an instruction template with a relocation
  // and its offset from start of stub.
  typedef std::pair<size_t, section_size_type> Reloc;

  // A Stub_template may not be copied.  We want to share templates as much
  // as possible.
  Stub_template(const Stub_template&);
  Stub_template& operator=(const Stub_template&);

  // Stub type.
  Stub_type type_;
  // Points to an array of Insn_templates.
  const Insn_template* insns_;
  // Number of Insn_templates in insns_[].
  size_t insn_count_;
  // Size of templated instructions in bytes.
  size_t size_;
  // Alignment of templated instructions.
  unsigned alignment_;
  // Flag to indicate if entry is in thumb mode.
  bool entry_in_thumb_mode_;
  // A table of reloc instruction indices and offsets.  We can find these by
  // looking at the instruction templates but we pre-compute and then stash
  // them here for speed.
  std::vector<Reloc> relocs_;
};

//
// A class for code stubs.  This is a base class for different type of
// stubs used in the ARM target.
//

class Stub
{
 private:
  static const section_offset_type invalid_offset =
    static_cast<section_offset_type>(-1);

 public:
  Stub(const Stub_template* stub_template)
    : stub_template_(stub_template), offset_(invalid_offset)
  { }

  virtual
   ~Stub()
  { }

  // Return the stub template.
  const Stub_template*
  stub_template() const
  { return this->stub_template_; }

  // Return offset of code stub from beginning of its containing stub table.
  section_offset_type
  offset() const
  {
    gold_assert(this->offset_ != invalid_offset);
    return this->offset_;
  }

  // Set offset of code stub from beginning of its containing stub table.
  void
  set_offset(section_offset_type offset)
  { this->offset_ = offset; }

  // Return the relocation target address of the i-th relocation in the
  // stub.  This must be defined in a child class.
  Arm_address
  reloc_target(size_t i)
  { return this->do_reloc_target(i); }

  // Write a stub at output VIEW.  BIG_ENDIAN select how a stub is written.
  void
  write(unsigned char* view, section_size_type view_size, bool big_endian)
  { this->do_write(view, view_size, big_endian); }

  // Return the instruction for THUMB16_SPECIAL_TYPE instruction template
  // for the i-th instruction.
  uint16_t
  thumb16_special(size_t i)
  { return this->do_thumb16_special(i); }

 protected:
  // This must be defined in the child class.
  virtual Arm_address
  do_reloc_target(size_t) = 0;

  // This may be overridden in the child class.
  virtual void
  do_write(unsigned char* view, section_size_type view_size, bool big_endian)
  {
    if (big_endian)
      this->do_fixed_endian_write<true>(view, view_size);
    else
      this->do_fixed_endian_write<false>(view, view_size);
  }

  // This must be overridden if a child class uses the THUMB16_SPECIAL_TYPE
  // instruction template.
  virtual uint16_t
  do_thumb16_special(size_t)
  { gold_unreachable(); }

 private:
  // A template to implement do_write.
  template<bool big_endian>
  void inline
  do_fixed_endian_write(unsigned char*, section_size_type);

  // Its template.
  const Stub_template* stub_template_;
  // Offset within the section of containing this stub.
  section_offset_type offset_;
};

// Reloc stub class.  These are stubs we use to fix up relocation because
// of limited branch ranges.

class Reloc_stub : public Stub
{
 public:
  static const unsigned int invalid_index = static_cast<unsigned int>(-1);
  // We assume we never jump to this address.
  static const Arm_address invalid_address = static_cast<Arm_address>(-1);

  // Return destination address.
  Arm_address
  destination_address() const
  {
    gold_assert(this->destination_address_ != this->invalid_address);
    return this->destination_address_;
  }

  // Set destination address.
  void
  set_destination_address(Arm_address address)
  {
    gold_assert(address != this->invalid_address);
    this->destination_address_ = address;
  }

  // Reset destination address.
  void
  reset_destination_address()
  { this->destination_address_ = this->invalid_address; }

  // Determine stub type for a branch of a relocation of R_TYPE going
  // from BRANCH_ADDRESS to BRANCH_TARGET.  If TARGET_IS_THUMB is set,
  // the branch target is a thumb instruction.  TARGET is used for look
  // up ARM-specific linker settings.
  static Stub_type
  stub_type_for_reloc(unsigned int r_type, Arm_address branch_address,
		      Arm_address branch_target, bool target_is_thumb);

  // Reloc_stub key.  A key is logically a triplet of a stub type, a symbol
  // and an addend.  Since we treat global and local symbol differently, we
  // use a Symbol object for a global symbol and a object-index pair for
  // a local symbol.
  class Key
  {
   public:
    // If SYMBOL is not null, this is a global symbol, we ignore RELOBJ and
    // R_SYM.  Otherwise, this is a local symbol and RELOBJ must non-NULL
    // and R_SYM must not be invalid_index.
    Key(Stub_type stub_type, const Symbol* symbol, const Relobj* relobj,
	unsigned int r_sym, int32_t addend)
      : stub_type_(stub_type), addend_(addend)
    {
      if (symbol != NULL)
	{
	  this->r_sym_ = Reloc_stub::invalid_index;
	  this->u_.symbol = symbol;
	}
      else
	{
	  gold_assert(relobj != NULL && r_sym != invalid_index);
	  this->r_sym_ = r_sym;
	  this->u_.relobj = relobj;
	}
    }

    ~Key()
    { }

    // Accessors: Keys are meant to be read-only object so no modifiers are
    // provided.

    // Return stub type.
    Stub_type
    stub_type() const
    { return this->stub_type_; }

    // Return the local symbol index or invalid_index.
    unsigned int
    r_sym() const
    { return this->r_sym_; }

    // Return the symbol if there is one.
    const Symbol*
    symbol() const
    { return this->r_sym_ == invalid_index ? this->u_.symbol : NULL; }

    // Return the relobj if there is one.
    const Relobj*
    relobj() const
    { return this->r_sym_ != invalid_index ? this->u_.relobj : NULL; }

    // Whether this equals to another key k.
    bool
    eq(const Key& k) const
    {
      return ((this->stub_type_ == k.stub_type_)
	      && (this->r_sym_ == k.r_sym_)
	      && ((this->r_sym_ != Reloc_stub::invalid_index)
		  ? (this->u_.relobj == k.u_.relobj)
		  : (this->u_.symbol == k.u_.symbol))
	      && (this->addend_ == k.addend_));
    }

    // Return a hash value.
    size_t
    hash_value() const
    {
      return (this->stub_type_
	      ^ this->r_sym_
	      ^ gold::string_hash<char>(
		    (this->r_sym_ != Reloc_stub::invalid_index)
		    ? this->u_.relobj->name().c_str()
		    : this->u_.symbol->name())
	      ^ this->addend_);
    }

    // Functors for STL associative containers.
    struct hash
    {
      size_t
      operator()(const Key& k) const
      { return k.hash_value(); }
    };

    struct equal_to
    {
      bool
      operator()(const Key& k1, const Key& k2) const
      { return k1.eq(k2); }
    };

    // Name of key.  This is mainly for debugging.
    std::string
    name() const;

   private:
    // Stub type.
    Stub_type stub_type_;
    // If this is a local symbol, this is the index in the defining object.
    // Otherwise, it is invalid_index for a global symbol.
    unsigned int r_sym_;
    // If r_sym_ is an invalid index, this points to a global symbol.
    // Otherwise, it points to a relobj.  We used the unsized and target
    // independent Symbol and Relobj classes instead of Sized_symbol<32> and
    // Arm_relobj, in order to avoid making the stub class a template
    // as most of the stub machinery is endianness-neutral.  However, it
    // may require a bit of casting done by users of this class.
    union
    {
      const Symbol* symbol;
      const Relobj* relobj;
    } u_;
    // Addend associated with a reloc.
    int32_t addend_;
  };

 protected:
  // Reloc_stubs are created via a stub factory.  So these are protected.
  Reloc_stub(const Stub_template* stub_template)
    : Stub(stub_template), destination_address_(invalid_address)
  { }

  ~Reloc_stub()
  { }

  friend class Stub_factory;

  // Return the relocation target address of the i-th relocation in the
  // stub.
  Arm_address
  do_reloc_target(size_t i)
  {
    // All reloc stub have only one relocation.
    gold_assert(i == 0);
    return this->destination_address_;
  }

 private:
  // Address of destination.
  Arm_address destination_address_;
};

// Cortex-A8 stub class.  We need a Cortex-A8 stub to redirect any 32-bit
// THUMB branch that meets the following conditions:
//
// 1. The branch straddles across a page boundary. i.e. lower 12-bit of
//    branch address is 0xffe.
// 2. The branch target address is in the same page as the first word of the
//    branch.
// 3. The branch follows a 32-bit instruction which is not a branch.
//
// To do the fix up, we need to store the address of the branch instruction
// and its target at least.  We also need to store the original branch
// instruction bits for the condition code in a conditional branch.  The
// condition code is used in a special instruction template.  We also want
// to identify input sections needing Cortex-A8 workaround quickly.  We store
// extra information about object and section index of the code section
// containing a branch being fixed up.  The information is used to mark
// the code section when we finalize the Cortex-A8 stubs.
//

class Cortex_a8_stub : public Stub
{
 public:
  ~Cortex_a8_stub()
  { }

  // Return the object of the code section containing the branch being fixed
  // up.
  Relobj*
  relobj() const
  { return this->relobj_; }

  // Return the section index of the code section containing the branch being
  // fixed up.
  unsigned int
  shndx() const
  { return this->shndx_; }

  // Return the source address of stub.  This is the address of the original
  // branch instruction.  LSB is 1 always set to indicate that it is a THUMB
  // instruction.
  Arm_address
  source_address() const
  { return this->source_address_; }

  // Return the destination address of the stub.  This is the branch taken
  // address of the original branch instruction.  LSB is 1 if it is a THUMB
  // instruction address.
  Arm_address
  destination_address() const
  { return this->destination_address_; }

  // Return the instruction being fixed up.
  uint32_t
  original_insn() const
  { return this->original_insn_; }

 protected:
  // Cortex_a8_stubs are created via a stub factory.  So these are protected.
  Cortex_a8_stub(const Stub_template* stub_template, Relobj* relobj,
		 unsigned int shndx, Arm_address source_address,
		 Arm_address destination_address, uint32_t original_insn)
    : Stub(stub_template), relobj_(relobj), shndx_(shndx),
      source_address_(source_address | 1U),
      destination_address_(destination_address),
      original_insn_(original_insn)
  { }

  friend class Stub_factory;

  // Return the relocation target address of the i-th relocation in the
  // stub.
  Arm_address
  do_reloc_target(size_t i)
  {
    if (this->stub_template()->type() == arm_stub_a8_veneer_b_cond)
      {
	// The conditional branch veneer has two relocations.
	gold_assert(i < 2);
	return i == 0 ? this->source_address_ + 4 : this->destination_address_;
      }
    else
      {
	// All other Cortex-A8 stubs have only one relocation.
	gold_assert(i == 0);
	return this->destination_address_;
      }
  }

  // Return an instruction for the THUMB16_SPECIAL_TYPE instruction template.
  uint16_t
  do_thumb16_special(size_t);

 private:
  // Object of the code section containing the branch being fixed up.
  Relobj* relobj_;
  // Section index of the code section containing the branch begin fixed up.
  unsigned int shndx_;
  // Source address of original branch.
  Arm_address source_address_;
  // Destination address of the original branch.
  Arm_address destination_address_;
  // Original branch instruction.  This is needed for copying the condition
  // code from a condition branch to its stub.
  uint32_t original_insn_;
};

// ARMv4 BX Rx branch relocation stub class.
class Arm_v4bx_stub : public Stub
{
 public:
  ~Arm_v4bx_stub()
  { }

  // Return the associated register.
  uint32_t
  reg() const
  { return this->reg_; }

 protected:
  // Arm V4BX stubs are created via a stub factory.  So these are protected.
  Arm_v4bx_stub(const Stub_template* stub_template, const uint32_t reg)
    : Stub(stub_template), reg_(reg)
  { }

  friend class Stub_factory;

  // Return the relocation target address of the i-th relocation in the
  // stub.
  Arm_address
  do_reloc_target(size_t)
  { gold_unreachable(); }

  // This may be overridden in the child class.
  virtual void
  do_write(unsigned char* view, section_size_type view_size, bool big_endian)
  {
    if (big_endian)
      this->do_fixed_endian_v4bx_write<true>(view, view_size);
    else
      this->do_fixed_endian_v4bx_write<false>(view, view_size);
  }

 private:
  // A template to implement do_write.
  template<bool big_endian>
  void inline
  do_fixed_endian_v4bx_write(unsigned char* view, section_size_type)
  {
    const Insn_template* insns = this->stub_template()->insns();
    elfcpp::Swap<32, big_endian>::writeval(view,
					   (insns[0].data()
					   + (this->reg_ << 16)));
    view += insns[0].size();
    elfcpp::Swap<32, big_endian>::writeval(view,
					   (insns[1].data() + this->reg_));
    view += insns[1].size();
    elfcpp::Swap<32, big_endian>::writeval(view,
					   (insns[2].data() + this->reg_));
  }

  // A register index (r0-r14), which is associated with the stub.
  uint32_t reg_;
};

// Stub factory class.

class Stub_factory
{
 public:
  // Return the unique instance of this class.
  static const Stub_factory&
  get_instance()
  {
    static Stub_factory singleton;
    return singleton;
  }

  // Make a relocation stub.
  Reloc_stub*
  make_reloc_stub(Stub_type stub_type) const
  {
    gold_assert(stub_type >= arm_stub_reloc_first
		&& stub_type <= arm_stub_reloc_last);
    return new Reloc_stub(this->stub_templates_[stub_type]);
  }

  // Make a Cortex-A8 stub.
  Cortex_a8_stub*
  make_cortex_a8_stub(Stub_type stub_type, Relobj* relobj, unsigned int shndx,
		      Arm_address source, Arm_address destination,
		      uint32_t original_insn) const
  {
    gold_assert(stub_type >= arm_stub_cortex_a8_first
		&& stub_type <= arm_stub_cortex_a8_last);
    return new Cortex_a8_stub(this->stub_templates_[stub_type], relobj, shndx,
			      source, destination, original_insn);
  }

  // Make an ARM V4BX relocation stub.
  // This method creates a stub from the arm_stub_v4_veneer_bx template only.
  Arm_v4bx_stub*
  make_arm_v4bx_stub(uint32_t reg) const
  {
    gold_assert(reg < 0xf);
    return new Arm_v4bx_stub(this->stub_templates_[arm_stub_v4_veneer_bx],
			     reg);
  }

 private:
  // Constructor and destructor are protected since we only return a single
  // instance created in Stub_factory::get_instance().

  Stub_factory();

  // A Stub_factory may not be copied since it is a singleton.
  Stub_factory(const Stub_factory&);
  Stub_factory& operator=(Stub_factory&);

  // Stub templates.  These are initialized in the constructor.
  const Stub_template* stub_templates_[arm_stub_type_last+1];
};

// A class to hold stubs for the ARM target.

template<bool big_endian>
class Stub_table : public Output_data
{
 public:
  Stub_table(Arm_input_section<big_endian>* owner)
    : Output_data(), owner_(owner), reloc_stubs_(), reloc_stubs_size_(0),
      reloc_stubs_addralign_(1), cortex_a8_stubs_(), arm_v4bx_stubs_(0xf),
      prev_data_size_(0), prev_addralign_(1)
  { }

  ~Stub_table()
  { }

  // Owner of this stub table.
  Arm_input_section<big_endian>*
  owner() const
  { return this->owner_; }

  // Whether this stub table is empty.
  bool
  empty() const
  {
    return (this->reloc_stubs_.empty()
	    && this->cortex_a8_stubs_.empty()
	    && this->arm_v4bx_stubs_.empty());
  }

  // Return the current data size.
  off_t
  current_data_size() const
  { return this->current_data_size_for_child(); }

  // Add a STUB using KEY.  The caller is responsible for avoiding addition
  // if a STUB with the same key has already been added.
  void
  add_reloc_stub(Reloc_stub* stub, const Reloc_stub::Key& key)
  {
    const Stub_template* stub_template = stub->stub_template();
    gold_assert(stub_template->type() == key.stub_type());
    this->reloc_stubs_[key] = stub;

    // Assign stub offset early.  We can do this because we never remove
    // reloc stubs and they are in the beginning of the stub table.
    uint64_t align = stub_template->alignment();
    this->reloc_stubs_size_ = align_address(this->reloc_stubs_size_, align);
    stub->set_offset(this->reloc_stubs_size_);
    this->reloc_stubs_size_ += stub_template->size();
    this->reloc_stubs_addralign_ =
      std::max(this->reloc_stubs_addralign_, align);
  }

  // Add a Cortex-A8 STUB that fixes up a THUMB branch at ADDRESS.
  // The caller is responsible for avoiding addition if a STUB with the same
  // address has already been added.
  void
  add_cortex_a8_stub(Arm_address address, Cortex_a8_stub* stub)
  {
    std::pair<Arm_address, Cortex_a8_stub*> value(address, stub);
    this->cortex_a8_stubs_.insert(value);
  }

  // Add an ARM V4BX relocation stub. A register index will be retrieved
  // from the stub.
  void
  add_arm_v4bx_stub(Arm_v4bx_stub* stub)
  {
    gold_assert(stub != NULL && this->arm_v4bx_stubs_[stub->reg()] == NULL);
    this->arm_v4bx_stubs_[stub->reg()] = stub;
  }

  // Remove all Cortex-A8 stubs.
  void
  remove_all_cortex_a8_stubs();

  // Look up a relocation stub using KEY.  Return NULL if there is none.
  Reloc_stub*
  find_reloc_stub(const Reloc_stub::Key& key) const
  {
    typename Reloc_stub_map::const_iterator p = this->reloc_stubs_.find(key);
    return (p != this->reloc_stubs_.end()) ? p->second : NULL;
  }

  // Look up an arm v4bx relocation stub using the register index.
  // Return NULL if there is none.
  Arm_v4bx_stub*
  find_arm_v4bx_stub(const uint32_t reg) const
  {
    gold_assert(reg < 0xf);
    return this->arm_v4bx_stubs_[reg];
  }

  // Relocate stubs in this stub table.
  void
  relocate_stubs(const Relocate_info<32, big_endian>*,
		 Target_arm<big_endian>*, Output_section*,
		 unsigned char*, Arm_address, section_size_type);

  // Update data size and alignment at the end of a relaxation pass.  Return
  // true if either data size or alignment is different from that of the
  // previous relaxation pass.
  bool
  update_data_size_and_addralign();

  // Finalize stubs.  Set the offsets of all stubs and mark input sections
  // needing the Cortex-A8 workaround.
  void
  finalize_stubs();

  // Apply Cortex-A8 workaround to an address range.
  void
  apply_cortex_a8_workaround_to_address_range(Target_arm<big_endian>*,
					      unsigned char*, Arm_address,
					      section_size_type);

 protected:
  // Write out section contents.
  void
  do_write(Output_file*);

  // Return the required alignment.
  uint64_t
  do_addralign() const
  { return this->prev_addralign_; }

  // Reset address and file offset.
  void
  do_reset_address_and_file_offset()
  { this->set_current_data_size_for_child(this->prev_data_size_); }

  // Set final data size.
  void
  set_final_data_size()
  { this->set_data_size(this->current_data_size()); }

 private:
  // Relocate one stub.
  void
  relocate_stub(Stub*, const Relocate_info<32, big_endian>*,
		Target_arm<big_endian>*, Output_section*,
		unsigned char*, Arm_address, section_size_type);

  // Unordered map of relocation stubs.
  typedef
    Unordered_map<Reloc_stub::Key, Reloc_stub*, Reloc_stub::Key::hash,
		  Reloc_stub::Key::equal_to>
    Reloc_stub_map;

  // List of Cortex-A8 stubs ordered by addresses of branches being
  // fixed up in output.
  typedef std::map<Arm_address, Cortex_a8_stub*> Cortex_a8_stub_list;
  // List of Arm V4BX relocation stubs ordered by associated registers.
  typedef std::vector<Arm_v4bx_stub*> Arm_v4bx_stub_list;

  // Owner of this stub table.
  Arm_input_section<big_endian>* owner_;
  // The relocation stubs.
  Reloc_stub_map reloc_stubs_;
  // Size of reloc stubs.
  off_t reloc_stubs_size_;
  // Maximum address alignment of reloc stubs.
  uint64_t reloc_stubs_addralign_;
  // The cortex_a8_stubs.
  Cortex_a8_stub_list cortex_a8_stubs_;
  // The Arm V4BX relocation stubs.
  Arm_v4bx_stub_list arm_v4bx_stubs_;
  // data size of this in the previous pass.
  off_t prev_data_size_;
  // address alignment of this in the previous pass.
  uint64_t prev_addralign_;
};

// Arm_exidx_cantunwind class.  This represents an EXIDX_CANTUNWIND entry
// we add to the end of an EXIDX input section that goes into the output.

class Arm_exidx_cantunwind : public Output_section_data
{
 public:
  Arm_exidx_cantunwind(Relobj* relobj, unsigned int shndx)
    : Output_section_data(8, 4, true), relobj_(relobj), shndx_(shndx)
  { }

  // Return the object containing the section pointed by this.
  Relobj*
  relobj() const
  { return this->relobj_; }

  // Return the section index of the section pointed by this.
  unsigned int
  shndx() const
  { return this->shndx_; }

 protected:
  void
  do_write(Output_file* of)
  {
    if (parameters->target().is_big_endian())
      this->do_fixed_endian_write<true>(of);
    else
      this->do_fixed_endian_write<false>(of);
  }

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** ARM cantunwind")); }

 private:
  // Implement do_write for a given endianness.
  template<bool big_endian>
  void inline
  do_fixed_endian_write(Output_file*);

  // The object containing the section pointed by this.
  Relobj* relobj_;
  // The section index of the section pointed by this.
  unsigned int shndx_;
};

// During EXIDX coverage fix-up, we compact an EXIDX section.  The
// Offset map is used to map input section offset within the EXIDX section
// to the output offset from the start of this EXIDX section.

typedef std::map<section_offset_type, section_offset_type>
	Arm_exidx_section_offset_map;

// Arm_exidx_merged_section class.  This represents an EXIDX input section
// with some of its entries merged.

class Arm_exidx_merged_section : public Output_relaxed_input_section
{
 public:
  // Constructor for Arm_exidx_merged_section.
  // EXIDX_INPUT_SECTION points to the unmodified EXIDX input section.
  // SECTION_OFFSET_MAP points to a section offset map describing how
  // parts of the input section are mapped to output.  DELETED_BYTES is
  // the number of bytes deleted from the EXIDX input section.
  Arm_exidx_merged_section(
      const Arm_exidx_input_section& exidx_input_section,
      const Arm_exidx_section_offset_map& section_offset_map,
      uint32_t deleted_bytes);

  // Build output contents.
  void
  build_contents(const unsigned char*, section_size_type);

  // Return the original EXIDX input section.
  const Arm_exidx_input_section&
  exidx_input_section() const
  { return this->exidx_input_section_; }

  // Return the section offset map.
  const Arm_exidx_section_offset_map&
  section_offset_map() const
  { return this->section_offset_map_; }

 protected:
  // Write merged section into file OF.
  void
  do_write(Output_file* of);

  bool
  do_output_offset(const Relobj*, unsigned int, section_offset_type,
		  section_offset_type*) const;

 private:
  // Original EXIDX input section.
  const Arm_exidx_input_section& exidx_input_section_;
  // Section offset map.
  const Arm_exidx_section_offset_map& section_offset_map_;
  // Merged section contents.  We need to keep build the merged section
  // and save it here to avoid accessing the original EXIDX section when
  // we cannot lock the sections' object.
  unsigned char* section_contents_;
};

// A class to wrap an ordinary input section containing executable code.

template<bool big_endian>
class Arm_input_section : public Output_relaxed_input_section
{
 public:
  Arm_input_section(Relobj* relobj, unsigned int shndx)
    : Output_relaxed_input_section(relobj, shndx, 1),
      original_addralign_(1), original_size_(0), stub_table_(NULL),
      original_contents_(NULL)
  { }

  ~Arm_input_section()
  { delete[] this->original_contents_; }

  // Initialize.
  void
  init();

  // Whether this is a stub table owner.
  bool
  is_stub_table_owner() const
  { return this->stub_table_ != NULL && this->stub_table_->owner() == this; }

  // Return the stub table.
  Stub_table<big_endian>*
  stub_table() const
  { return this->stub_table_; }

  // Set the stub_table.
  void
  set_stub_table(Stub_table<big_endian>* stub_table)
  { this->stub_table_ = stub_table; }

  // Downcast a base pointer to an Arm_input_section pointer.  This is
  // not type-safe but we only use Arm_input_section not the base class.
  static Arm_input_section<big_endian>*
  as_arm_input_section(Output_relaxed_input_section* poris)
  { return static_cast<Arm_input_section<big_endian>*>(poris); }

  // Return the original size of the section.
  uint32_t
  original_size() const
  { return this->original_size_; }

 protected:
  // Write data to output file.
  void
  do_write(Output_file*);

  // Return required alignment of this.
  uint64_t
  do_addralign() const
  {
    if (this->is_stub_table_owner())
      return std::max(this->stub_table_->addralign(),
		      static_cast<uint64_t>(this->original_addralign_));
    else
      return this->original_addralign_;
  }

  // Finalize data size.
  void
  set_final_data_size();

  // Reset address and file offset.
  void
  do_reset_address_and_file_offset();

  // Output offset.
  bool
  do_output_offset(const Relobj* object, unsigned int shndx,
		   section_offset_type offset,
		   section_offset_type* poutput) const
  {
    if ((object == this->relobj())
	&& (shndx == this->shndx())
	&& (offset >= 0)
	&& (offset <=
	    convert_types<section_offset_type, uint32_t>(this->original_size_)))
      {
	*poutput = offset;
	return true;
      }
    else
      return false;
  }

 private:
  // Copying is not allowed.
  Arm_input_section(const Arm_input_section&);
  Arm_input_section& operator=(const Arm_input_section&);

  // Address alignment of the original input section.
  uint32_t original_addralign_;
  // Section size of the original input section.
  uint32_t original_size_;
  // Stub table.
  Stub_table<big_endian>* stub_table_;
  // Original section contents.  We have to make a copy here since the file
  // containing the original section may not be locked when we need to access
  // the contents.
  unsigned char* original_contents_;
};

// Arm_exidx_fixup class.  This is used to define a number of methods
// and keep states for fixing up EXIDX coverage.

class Arm_exidx_fixup
{
 public:
  Arm_exidx_fixup(Output_section* exidx_output_section,
		  bool merge_exidx_entries = true)
    : exidx_output_section_(exidx_output_section), last_unwind_type_(UT_NONE),
      last_inlined_entry_(0), last_input_section_(NULL),
      section_offset_map_(NULL), first_output_text_section_(NULL),
      merge_exidx_entries_(merge_exidx_entries)
  { }

  ~Arm_exidx_fixup()
  { delete this->section_offset_map_; }

  // Process an EXIDX section for entry merging.  SECTION_CONTENTS points
  // to the EXIDX contents and SECTION_SIZE is the size of the contents. Return
  // number of bytes to be deleted in output.  If parts of the input EXIDX
  // section are merged a heap allocated Arm_exidx_section_offset_map is store
  // in the located PSECTION_OFFSET_MAP.   The caller owns the map and is
  // responsible for releasing it.
  template<bool big_endian>
  uint32_t
  process_exidx_section(const Arm_exidx_input_section* exidx_input_section,
			const unsigned char* section_contents,
			section_size_type section_size,
			Arm_exidx_section_offset_map** psection_offset_map);

  // Append an EXIDX_CANTUNWIND entry pointing at the end of the last
  // input section, if there is not one already.
  void
  add_exidx_cantunwind_as_needed();

  // Return the output section for the text section which is linked to the
  // first exidx input in output.
  Output_section*
  first_output_text_section() const
  { return this->first_output_text_section_; }

 private:
  // Copying is not allowed.
  Arm_exidx_fixup(const Arm_exidx_fixup&);
  Arm_exidx_fixup& operator=(const Arm_exidx_fixup&);

  // Type of EXIDX unwind entry.
  enum Unwind_type
  {
    // No type.
    UT_NONE,
    // EXIDX_CANTUNWIND.
    UT_EXIDX_CANTUNWIND,
    // Inlined entry.
    UT_INLINED_ENTRY,
    // Normal entry.
    UT_NORMAL_ENTRY,
  };

  // Process an EXIDX entry.  We only care about the second word of the
  // entry.  Return true if the entry can be deleted.
  bool
  process_exidx_entry(uint32_t second_word);

  // Update the current section offset map during EXIDX section fix-up.
  // If there is no map, create one.  INPUT_OFFSET is the offset of a
  // reference point, DELETED_BYTES is the number of deleted by in the
  // section so far.  If DELETE_ENTRY is true, the reference point and
  // all offsets after the previous reference point are discarded.
  void
  update_offset_map(section_offset_type input_offset,
		    section_size_type deleted_bytes, bool delete_entry);

  // EXIDX output section.
  Output_section* exidx_output_section_;
  // Unwind type of the last EXIDX entry processed.
  Unwind_type last_unwind_type_;
  // Last seen inlined EXIDX entry.
  uint32_t last_inlined_entry_;
  // Last processed EXIDX input section.
  const Arm_exidx_input_section* last_input_section_;
  // Section offset map created in process_exidx_section.
  Arm_exidx_section_offset_map* section_offset_map_;
  // Output section for the text section which is linked to the first exidx
  // input in output.
  Output_section* first_output_text_section_;

  bool merge_exidx_entries_;
};

// Arm output section class.  This is defined mainly to add a number of
// stub generation methods.

template<bool big_endian>
class Arm_output_section : public Output_section
{
 public:
  typedef std::vector<std::pair<Relobj*, unsigned int> > Text_section_list;

  // We need to force SHF_LINK_ORDER in a SHT_ARM_EXIDX section.
  Arm_output_section(const char* name, elfcpp::Elf_Word type,
		     elfcpp::Elf_Xword flags)
    : Output_section(name, type,
		     (type == elfcpp::SHT_ARM_EXIDX
		      ? flags | elfcpp::SHF_LINK_ORDER
		      : flags))
  {
    if (type == elfcpp::SHT_ARM_EXIDX)
      this->set_always_keeps_input_sections();
  }

  ~Arm_output_section()
  { }

  // Group input sections for stub generation.
  void
  group_sections(section_size_type, bool, Target_arm<big_endian>*, const Task*);

  // Downcast a base pointer to an Arm_output_section pointer.  This is
  // not type-safe but we only use Arm_output_section not the base class.
  static Arm_output_section<big_endian>*
  as_arm_output_section(Output_section* os)
  { return static_cast<Arm_output_section<big_endian>*>(os); }

  // Append all input text sections in this into LIST.
  void
  append_text_sections_to_list(Text_section_list* list);

  // Fix EXIDX coverage of this EXIDX output section.  SORTED_TEXT_SECTION
  // is a list of text input sections sorted in ascending order of their
  // output addresses.
  void
  fix_exidx_coverage(Layout* layout,
		     const Text_section_list& sorted_text_section,
		     Symbol_table* symtab,
		     bool merge_exidx_entries,
		     const Task* task);

  // Link an EXIDX section into its corresponding text section.
  void
  set_exidx_section_link();

 private:
  // For convenience.
  typedef Output_section::Input_section Input_section;
  typedef Output_section::Input_section_list Input_section_list;

  // Create a stub group.
  void create_stub_group(Input_section_list::const_iterator,
			 Input_section_list::const_iterator,
			 Input_section_list::const_iterator,
			 Target_arm<big_endian>*,
			 std::vector<Output_relaxed_input_section*>*,
			 const Task* task);
};

// Arm_exidx_input_section class.  This represents an EXIDX input section.

class Arm_exidx_input_section
{
 public:
  static const section_offset_type invalid_offset =
    static_cast<section_offset_type>(-1);

  Arm_exidx_input_section(Relobj* relobj, unsigned int shndx,
			  unsigned int link, uint32_t size,
			  uint32_t addralign, uint32_t text_size)
    : relobj_(relobj), shndx_(shndx), link_(link), size_(size),
      addralign_(addralign), text_size_(text_size), has_errors_(false)
  { }

  ~Arm_exidx_input_section()
  { }

  // Accessors:  This is a read-only class.

  // Return the object containing this EXIDX input section.
  Relobj*
  relobj() const
  { return this->relobj_; }

  // Return the section index of this EXIDX input section.
  unsigned int
  shndx() const
  { return this->shndx_; }

  // Return the section index of linked text section in the same object.
  unsigned int
  link() const
  { return this->link_; }

  // Return size of the EXIDX input section.
  uint32_t
  size() const
  { return this->size_; }

  // Return address alignment of EXIDX input section.
  uint32_t
  addralign() const
  { return this->addralign_; }

  // Return size of the associated text input section.
  uint32_t
  text_size() const
  { return this->text_size_; }

  // Whether there are any errors in the EXIDX input section.
  bool
  has_errors() const
  { return this->has_errors_; }

  // Set has-errors flag.
  void
  set_has_errors()
  { this->has_errors_ = true; }

 private:
  // Object containing this.
  Relobj* relobj_;
  // Section index of this.
  unsigned int shndx_;
  // text section linked to this in the same object.
  unsigned int link_;
  // Size of this.  For ARM 32-bit is sufficient.
  uint32_t size_;
  // Address alignment of this.  For ARM 32-bit is sufficient.
  uint32_t addralign_;
  // Size of associated text section.
  uint32_t text_size_;
  // Whether this has any errors.
  bool has_errors_;
};

// Arm_relobj class.

template<bool big_endian>
class Arm_relobj : public Sized_relobj_file<32, big_endian>
{
 public:
  static const Arm_address invalid_address = static_cast<Arm_address>(-1);

  Arm_relobj(const std::string& name, Input_file* input_file, off_t offset,
	     const typename elfcpp::Ehdr<32, big_endian>& ehdr)
    : Sized_relobj_file<32, big_endian>(name, input_file, offset, ehdr),
      stub_tables_(), local_symbol_is_thumb_function_(),
      attributes_section_data_(NULL), mapping_symbols_info_(),
      section_has_cortex_a8_workaround_(NULL), exidx_section_map_(),
      output_local_symbol_count_needs_update_(false),
      merge_flags_and_attributes_(true)
  { }

  ~Arm_relobj()
  { delete this->attributes_section_data_; }

  // Return the stub table of the SHNDX-th section if there is one.
  Stub_table<big_endian>*
  stub_table(unsigned int shndx) const
  {
    gold_assert(shndx < this->stub_tables_.size());
    return this->stub_tables_[shndx];
  }

  // Set STUB_TABLE to be the stub_table of the SHNDX-th section.
  void
  set_stub_table(unsigned int shndx, Stub_table<big_endian>* stub_table)
  {
    gold_assert(shndx < this->stub_tables_.size());
    this->stub_tables_[shndx] = stub_table;
  }

  // Whether a local symbol is a THUMB function.  R_SYM is the symbol table
  // index.  This is only valid after do_count_local_symbol is called.
  bool
  local_symbol_is_thumb_function(unsigned int r_sym) const
  {
    gold_assert(r_sym < this->local_symbol_is_thumb_function_.size());
    return this->local_symbol_is_thumb_function_[r_sym];
  }

  // Scan all relocation sections for stub generation.
  void
  scan_sections_for_stubs(Target_arm<big_endian>*, const Symbol_table*,
			  const Layout*);

  // Convert regular input section with index SHNDX to a relaxed section.
  void
  convert_input_section_to_relaxed_section(unsigned shndx)
  {
    // The stubs have relocations and we need to process them after writing
    // out the stubs.  So relocation now must follow section write.
    this->set_section_offset(shndx, -1ULL);
    this->set_relocs_must_follow_section_writes();
  }

  // Downcast a base pointer to an Arm_relobj pointer.  This is
  // not type-safe but we only use Arm_relobj not the base class.
  static Arm_relobj<big_endian>*
  as_arm_relobj(Relobj* relobj)
  { return static_cast<Arm_relobj<big_endian>*>(relobj); }

  // Processor-specific flags in ELF file header.  This is valid only after
  // reading symbols.
  elfcpp::Elf_Word
  processor_specific_flags() const
  { return this->processor_specific_flags_; }

  // Attribute section data  This is the contents of the .ARM.attribute section
  // if there is one.
  const Attributes_section_data*
  attributes_section_data() const
  { return this->attributes_section_data_; }

  // Mapping symbol location.
  typedef std::pair<unsigned int, Arm_address> Mapping_symbol_position;

  // Functor for STL container.
  struct Mapping_symbol_position_less
  {
    bool
    operator()(const Mapping_symbol_position& p1,
	       const Mapping_symbol_position& p2) const
    {
      return (p1.first < p2.first
	      || (p1.first == p2.first && p1.second < p2.second));
    }
  };

  // We only care about the first character of a mapping symbol, so
  // we only store that instead of the whole symbol name.
  typedef std::map<Mapping_symbol_position, char,
		   Mapping_symbol_position_less> Mapping_symbols_info;

  // Whether a section contains any Cortex-A8 workaround.
  bool
  section_has_cortex_a8_workaround(unsigned int shndx) const
  {
    return (this->section_has_cortex_a8_workaround_ != NULL
	    && (*this->section_has_cortex_a8_workaround_)[shndx]);
  }

  // Mark a section that has Cortex-A8 workaround.
  void
  mark_section_for_cortex_a8_workaround(unsigned int shndx)
  {
    if (this->section_has_cortex_a8_workaround_ == NULL)
      this->section_has_cortex_a8_workaround_ =
	new std::vector<bool>(this->shnum(), false);
    (*this->section_has_cortex_a8_workaround_)[shndx] = true;
  }

  // Return the EXIDX section of an text section with index SHNDX or NULL
  // if the text section has no associated EXIDX section.
  const Arm_exidx_input_section*
  exidx_input_section_by_link(unsigned int shndx) const
  {
    Exidx_section_map::const_iterator p = this->exidx_section_map_.find(shndx);
    return ((p != this->exidx_section_map_.end()
	     && p->second->link() == shndx)
	    ? p->second
	    : NULL);
  }

  // Return the EXIDX section with index SHNDX or NULL if there is none.
  const Arm_exidx_input_section*
  exidx_input_section_by_shndx(unsigned shndx) const
  {
    Exidx_section_map::const_iterator p = this->exidx_section_map_.find(shndx);
    return ((p != this->exidx_section_map_.end()
	     && p->second->shndx() == shndx)
	    ? p->second
	    : NULL);
  }

  // Whether output local symbol count needs updating.
  bool
  output_local_symbol_count_needs_update() const
  { return this->output_local_symbol_count_needs_update_; }

  // Set output_local_symbol_count_needs_update flag to be true.
  void
  set_output_local_symbol_count_needs_update()
  { this->output_local_symbol_count_needs_update_ = true; }

  // Update output local symbol count at the end of relaxation.
  void
  update_output_local_symbol_count();

  // Whether we want to merge processor-specific flags and attributes.
  bool
  merge_flags_and_attributes() const
  { return this->merge_flags_and_attributes_; }

  // Export list of EXIDX section indices.
  void
  get_exidx_shndx_list(std::vector<unsigned int>* list) const
  {
    list->clear();
    for (Exidx_section_map::const_iterator p = this->exidx_section_map_.begin();
	 p != this->exidx_section_map_.end();
	 ++p)
      {
	if (p->second->shndx() == p->first)
	  list->push_back(p->first);
      }
    // Sort list to make result independent of implementation of map.
    std::sort(list->begin(), list->end());
  }

 protected:
  // Post constructor setup.
  void
  do_setup()
  {
    // Call parent's setup method.
    Sized_relobj_file<32, big_endian>::do_setup();

    // Initialize look-up tables.
    Stub_table_list empty_stub_table_list(this->shnum(), NULL);
    this->stub_tables_.swap(empty_stub_table_list);
  }

  // Count the local symbols.
  void
  do_count_local_symbols(Stringpool_template<char>*,
			 Stringpool_template<char>*);

  void
  do_relocate_sections(
      const Symbol_table* symtab, const Layout* layout,
      const unsigned char* pshdrs, Output_file* of,
      typename Sized_relobj_file<32, big_endian>::Views* pivews);

  // Read the symbol information.
  void
  do_read_symbols(Read_symbols_data* sd);

  // Process relocs for garbage collection.
  void
  do_gc_process_relocs(Symbol_table*, Layout*, Read_relocs_data*);

 private:

  // Whether a section needs to be scanned for relocation stubs.
  bool
  section_needs_reloc_stub_scanning(const elfcpp::Shdr<32, big_endian>&,
				    const Relobj::Output_sections&,
				    const Symbol_table*, const unsigned char*);

  // Whether a section is a scannable text section.
  bool
  section_is_scannable(const elfcpp::Shdr<32, big_endian>&, unsigned int,
		       const Output_section*, const Symbol_table*);

  // Whether a section needs to be scanned for the Cortex-A8 erratum.
  bool
  section_needs_cortex_a8_stub_scanning(const elfcpp::Shdr<32, big_endian>&,
					unsigned int, Output_section*,
					const Symbol_table*);

  // Scan a section for the Cortex-A8 erratum.
  void
  scan_section_for_cortex_a8_erratum(const elfcpp::Shdr<32, big_endian>&,
				     unsigned int, Output_section*,
				     Target_arm<big_endian>*);

  // Find the linked text section of an EXIDX section by looking at the
  // first relocation of the EXIDX section.  PSHDR points to the section
  // headers of a relocation section and PSYMS points to the local symbols.
  // PSHNDX points to a location storing the text section index if found.
  // Return whether we can find the linked section.
  bool
  find_linked_text_section(const unsigned char* pshdr,
			   const unsigned char* psyms, unsigned int* pshndx);

  //
  // Make a new Arm_exidx_input_section object for EXIDX section with
  // index SHNDX and section header SHDR.  TEXT_SHNDX is the section
  // index of the linked text section.
  void
  make_exidx_input_section(unsigned int shndx,
			   const elfcpp::Shdr<32, big_endian>& shdr,
			   unsigned int text_shndx,
			   const elfcpp::Shdr<32, big_endian>& text_shdr);

  // Return the output address of either a plain input section or a
  // relaxed input section.  SHNDX is the section index.
  Arm_address
  simple_input_section_output_address(unsigned int, Output_section*);

  typedef std::vector<Stub_table<big_endian>*> Stub_table_list;
  typedef Unordered_map<unsigned int, const Arm_exidx_input_section*>
    Exidx_section_map;

  // List of stub tables.
  Stub_table_list stub_tables_;
  // Bit vector to tell if a local symbol is a thumb function or not.
  // This is only valid after do_count_local_symbol is called.
  std::vector<bool> local_symbol_is_thumb_function_;
  // processor-specific flags in ELF file header.
  elfcpp::Elf_Word processor_specific_flags_;
  // Object attributes if there is an .ARM.attributes section or NULL.
  Attributes_section_data* attributes_section_data_;
  // Mapping symbols information.
  Mapping_symbols_info mapping_symbols_info_;
  // Bitmap to indicate sections with Cortex-A8 workaround or NULL.
  std::vector<bool>* section_has_cortex_a8_workaround_;
  // Map a text section to its associated .ARM.exidx section, if there is one.
  Exidx_section_map exidx_section_map_;
  // Whether output local symbol count needs updating.
  bool output_local_symbol_count_needs_update_;
  // Whether we merge processor flags and attributes of this object to
  // output.
  bool merge_flags_and_attributes_;
};

// Arm_dynobj class.

template<bool big_endian>
class Arm_dynobj : public Sized_dynobj<32, big_endian>
{
 public:
  Arm_dynobj(const std::string& name, Input_file* input_file, off_t offset,
	     const elfcpp::Ehdr<32, big_endian>& ehdr)
    : Sized_dynobj<32, big_endian>(name, input_file, offset, ehdr),
      processor_specific_flags_(0), attributes_section_data_(NULL)
  { }

  ~Arm_dynobj()
  { delete this->attributes_section_data_; }

  // Downcast a base pointer to an Arm_relobj pointer.  This is
  // not type-safe but we only use Arm_relobj not the base class.
  static Arm_dynobj<big_endian>*
  as_arm_dynobj(Dynobj* dynobj)
  { return static_cast<Arm_dynobj<big_endian>*>(dynobj); }

  // Processor-specific flags in ELF file header.  This is valid only after
  // reading symbols.
  elfcpp::Elf_Word
  processor_specific_flags() const
  { return this->processor_specific_flags_; }

  // Attributes section data.
  const Attributes_section_data*
  attributes_section_data() const
  { return this->attributes_section_data_; }

 protected:
  // Read the symbol information.
  void
  do_read_symbols(Read_symbols_data* sd);

 private:
  // processor-specific flags in ELF file header.
  elfcpp::Elf_Word processor_specific_flags_;
  // Object attributes if there is an .ARM.attributes section or NULL.
  Attributes_section_data* attributes_section_data_;
};

// Functor to read reloc addends during stub generation.

template<int sh_type, bool big_endian>
struct Stub_addend_reader
{
  // Return the addend for a relocation of a particular type.  Depending
  // on whether this is a REL or RELA relocation, read the addend from a
  // view or from a Reloc object.
  elfcpp::Elf_types<32>::Elf_Swxword
  operator()(
    unsigned int /* r_type */,
    const unsigned char* /* view */,
    const typename Reloc_types<sh_type,
			       32, big_endian>::Reloc& /* reloc */) const;
};

// Specialized Stub_addend_reader for SHT_REL type relocation sections.

template<bool big_endian>
struct Stub_addend_reader<elfcpp::SHT_REL, big_endian>
{
  elfcpp::Elf_types<32>::Elf_Swxword
  operator()(
    unsigned int,
    const unsigned char*,
    const typename Reloc_types<elfcpp::SHT_REL, 32, big_endian>::Reloc&) const;
};

// Specialized Stub_addend_reader for RELA type relocation sections.
// We currently do not handle RELA type relocation sections but it is trivial
// to implement the addend reader.  This is provided for completeness and to
// make it easier to add support for RELA relocation sections in the future.

template<bool big_endian>
struct Stub_addend_reader<elfcpp::SHT_RELA, big_endian>
{
  elfcpp::Elf_types<32>::Elf_Swxword
  operator()(
    unsigned int,
    const unsigned char*,
    const typename Reloc_types<elfcpp::SHT_RELA, 32,
			       big_endian>::Reloc& reloc) const
  { return reloc.get_r_addend(); }
};

// Cortex_a8_reloc class.  We keep record of relocation that may need
// the Cortex-A8 erratum workaround.

class Cortex_a8_reloc
{
 public:
  Cortex_a8_reloc(Reloc_stub* reloc_stub, unsigned r_type,
		  Arm_address destination)
    : reloc_stub_(reloc_stub), r_type_(r_type), destination_(destination)
  { }

  ~Cortex_a8_reloc()
  { }

  // Accessors:  This is a read-only class.

  // Return the relocation stub associated with this relocation if there is
  // one.
  const Reloc_stub*
  reloc_stub() const
  { return this->reloc_stub_; }

  // Return the relocation type.
  unsigned int
  r_type() const
  { return this->r_type_; }

  // Return the destination address of the relocation.  LSB stores the THUMB
  // bit.
  Arm_address
  destination() const
  { return this->destination_; }

 private:
  // Associated relocation stub if there is one, or NULL.
  const Reloc_stub* reloc_stub_;
  // Relocation type.
  unsigned int r_type_;
  // Destination address of this relocation.  LSB is used to distinguish
  // ARM/THUMB mode.
  Arm_address destination_;
};

// Arm_output_data_got class.  We derive this from Output_data_got to add
// extra methods to handle TLS relocations in a static link.

template<bool big_endian>
class Arm_output_data_got : public Output_data_got<32, big_endian>
{
 public:
  Arm_output_data_got(Symbol_table* symtab, Layout* layout)
    : Output_data_got<32, big_endian>(), symbol_table_(symtab), layout_(layout)
  { }

  // Add a static entry for the GOT entry at OFFSET.  GSYM is a global
  // symbol and R_TYPE is the code of a dynamic relocation that needs to be
  // applied in a static link.
  void
  add_static_reloc(unsigned int got_offset, unsigned int r_type, Symbol* gsym)
  { this->static_relocs_.push_back(Static_reloc(got_offset, r_type, gsym)); }

  // Add a static reloc for the GOT entry at OFFSET.  RELOBJ is an object
  // defining a local symbol with INDEX.  R_TYPE is the code of a dynamic
  // relocation that needs to be applied in a static link.
  void
  add_static_reloc(unsigned int got_offset, unsigned int r_type,
		   Sized_relobj_file<32, big_endian>* relobj,
		   unsigned int index)
  {
    this->static_relocs_.push_back(Static_reloc(got_offset, r_type, relobj,
						index));
  }

  // Add a GOT pair for R_ARM_TLS_GD32.  The creates a pair of GOT entries.
  // The first one is initialized to be 1, which is the module index for
  // the main executable and the second one 0.  A reloc of the type
  // R_ARM_TLS_DTPOFF32 will be created for the second GOT entry and will
  // be applied by gold.  GSYM is a global symbol.
  void
  add_tls_gd32_with_static_reloc(unsigned int got_type, Symbol* gsym);

  // Same as the above but for a local symbol in OBJECT with INDEX.
  void
  add_tls_gd32_with_static_reloc(unsigned int got_type,
				 Sized_relobj_file<32, big_endian>* object,
				 unsigned int index);

 protected:
  // Write out the GOT table.
  void
  do_write(Output_file*);

 private:
  // This class represent dynamic relocations that need to be applied by
  // gold because we are using TLS relocations in a static link.
  class Static_reloc
  {
   public:
    Static_reloc(unsigned int got_offset, unsigned int r_type, Symbol* gsym)
      : got_offset_(got_offset), r_type_(r_type), symbol_is_global_(true)
    { this->u_.global.symbol = gsym; }

    Static_reloc(unsigned int got_offset, unsigned int r_type,
	  Sized_relobj_file<32, big_endian>* relobj, unsigned int index)
      : got_offset_(got_offset), r_type_(r_type), symbol_is_global_(false)
    {
      this->u_.local.relobj = relobj;
      this->u_.local.index = index;
    }

    // Return the GOT offset.
    unsigned int
    got_offset() const
    { return this->got_offset_; }

    // Relocation type.
    unsigned int
    r_type() const
    { return this->r_type_; }

    // Whether the symbol is global or not.
    bool
    symbol_is_global() const
    { return this->symbol_is_global_; }

    // For a relocation against a global symbol, the global symbol.
    Symbol*
    symbol() const
    {
      gold_assert(this->symbol_is_global_);
      return this->u_.global.symbol;
    }

    // For a relocation against a local symbol, the defining object.
    Sized_relobj_file<32, big_endian>*
    relobj() const
    {
      gold_assert(!this->symbol_is_global_);
      return this->u_.local.relobj;
    }

    // For a relocation against a local symbol, the local symbol index.
    unsigned int
    index() const
    {
      gold_assert(!this->symbol_is_global_);
      return this->u_.local.index;
    }

   private:
    // GOT offset of the entry to which this relocation is applied.
    unsigned int got_offset_;
    // Type of relocation.
    unsigned int r_type_;
    // Whether this relocation is against a global symbol.
    bool symbol_is_global_;
    // A global or local symbol.
    union
    {
      struct
      {
	// For a global symbol, the symbol itself.
	Symbol* symbol;
      } global;
      struct
      {
	// For a local symbol, the object defining object.
	Sized_relobj_file<32, big_endian>* relobj;
	// For a local symbol, the symbol index.
	unsigned int index;
      } local;
    } u_;
  };

  // Symbol table of the output object.
  Symbol_table* symbol_table_;
  // Layout of the output object.
  Layout* layout_;
  // Static relocs to be applied to the GOT.
  std::vector<Static_reloc> static_relocs_;
};

// The ARM target has many relocation types with odd-sizes or noncontiguous
// bits.  The default handling of relocatable relocation cannot process these
// relocations.  So we have to extend the default code.

template<bool big_endian, int sh_type, typename Classify_reloc>
class Arm_scan_relocatable_relocs :
  public Default_scan_relocatable_relocs<sh_type, Classify_reloc>
{
 public:
  // Return the strategy to use for a local symbol which is a section
  // symbol, given the relocation type.
  inline Relocatable_relocs::Reloc_strategy
  local_section_strategy(unsigned int r_type, Relobj*)
  {
    if (sh_type == elfcpp::SHT_RELA)
      return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_RELA;
    else
      {
	if (r_type == elfcpp::R_ARM_TARGET1
	    || r_type == elfcpp::R_ARM_TARGET2)
	  {
	    const Target_arm<big_endian>* arm_target =
	      Target_arm<big_endian>::default_target();
	    r_type = arm_target->get_real_reloc_type(r_type);
	  }

	switch(r_type)
	  {
	  // Relocations that write nothing.  These exclude R_ARM_TARGET1
	  // and R_ARM_TARGET2.
	  case elfcpp::R_ARM_NONE:
	  case elfcpp::R_ARM_V4BX:
	  case elfcpp::R_ARM_TLS_GOTDESC:
	  case elfcpp::R_ARM_TLS_CALL:
	  case elfcpp::R_ARM_TLS_DESCSEQ:
	  case elfcpp::R_ARM_THM_TLS_CALL:
	  case elfcpp::R_ARM_GOTRELAX:
	  case elfcpp::R_ARM_GNU_VTENTRY:
	  case elfcpp::R_ARM_GNU_VTINHERIT:
	  case elfcpp::R_ARM_THM_TLS_DESCSEQ16:
	  case elfcpp::R_ARM_THM_TLS_DESCSEQ32:
	    return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_0;
	  // These should have been converted to something else above.
	  case elfcpp::R_ARM_TARGET1:
	  case elfcpp::R_ARM_TARGET2:
	    gold_unreachable();
	  // Relocations that write full 32 bits and
	  // have alignment of 1.
	  case elfcpp::R_ARM_ABS32:
	  case elfcpp::R_ARM_REL32:
	  case elfcpp::R_ARM_SBREL32:
	  case elfcpp::R_ARM_GOTOFF32:
	  case elfcpp::R_ARM_BASE_PREL:
	  case elfcpp::R_ARM_GOT_BREL:
	  case elfcpp::R_ARM_BASE_ABS:
	  case elfcpp::R_ARM_ABS32_NOI:
	  case elfcpp::R_ARM_REL32_NOI:
	  case elfcpp::R_ARM_PLT32_ABS:
	  case elfcpp::R_ARM_GOT_ABS:
	  case elfcpp::R_ARM_GOT_PREL:
	  case elfcpp::R_ARM_TLS_GD32:
	  case elfcpp::R_ARM_TLS_LDM32:
	  case elfcpp::R_ARM_TLS_LDO32:
	  case elfcpp::R_ARM_TLS_IE32:
	  case elfcpp::R_ARM_TLS_LE32:
	    return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_4_UNALIGNED;
	  default:
	    // For all other static relocations, return RELOC_SPECIAL.
	    return Relocatable_relocs::RELOC_SPECIAL;
	  }
      }
  }
};

template<bool big_endian>
class Target_arm : public Sized_target<32, big_endian>
{
 public:
  typedef Output_data_reloc<elfcpp::SHT_REL, true, 32, big_endian>
    Reloc_section;

  // When were are relocating a stub, we pass this as the relocation number.
  static const size_t fake_relnum_for_stubs = static_cast<size_t>(-1);

  Target_arm(const Target::Target_info* info = &arm_info)
    : Sized_target<32, big_endian>(info),
      got_(NULL), plt_(NULL), got_plt_(NULL), rel_dyn_(NULL),
      copy_relocs_(elfcpp::R_ARM_COPY),
      got_mod_index_offset_(-1U), tls_base_symbol_defined_(false),
      stub_tables_(), stub_factory_(Stub_factory::get_instance()),
      should_force_pic_veneer_(false),
      arm_input_section_map_(), attributes_section_data_(NULL),
      fix_cortex_a8_(false), cortex_a8_relocs_info_()
  { }

  // Whether we force PCI branch veneers.
  bool
  should_force_pic_veneer() const
  { return this->should_force_pic_veneer_; }

  // Set PIC veneer flag.
  void
  set_should_force_pic_veneer(bool value)
  { this->should_force_pic_veneer_ = value; }

  // Whether we use THUMB-2 instructions.
  bool
  using_thumb2() const
  {
    Object_attribute* attr =
      this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);
    int arch = attr->int_value();
    return arch == elfcpp::TAG_CPU_ARCH_V6T2 || arch >= elfcpp::TAG_CPU_ARCH_V7;
  }

  // Whether we use THUMB/THUMB-2 instructions only.
  bool
  using_thumb_only() const
  {
    Object_attribute* attr =
      this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);

    if (attr->int_value() == elfcpp::TAG_CPU_ARCH_V6_M
	|| attr->int_value() == elfcpp::TAG_CPU_ARCH_V6S_M)
      return true;
    if (attr->int_value() != elfcpp::TAG_CPU_ARCH_V7
	&& attr->int_value() != elfcpp::TAG_CPU_ARCH_V7E_M)
      return false;
    attr = this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch_profile);
    return attr->int_value() == 'M';
  }

  // Whether we have an NOP instruction.  If not, use mov r0, r0 instead.
  bool
  may_use_arm_nop() const
  {
    Object_attribute* attr =
      this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);
    int arch = attr->int_value();
    return (arch == elfcpp::TAG_CPU_ARCH_V6T2
	    || arch == elfcpp::TAG_CPU_ARCH_V6K
	    || arch == elfcpp::TAG_CPU_ARCH_V7
	    || arch == elfcpp::TAG_CPU_ARCH_V7E_M);
  }

  // Whether we have THUMB-2 NOP.W instruction.
  bool
  may_use_thumb2_nop() const
  {
    Object_attribute* attr =
      this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);
    int arch = attr->int_value();
    return (arch == elfcpp::TAG_CPU_ARCH_V6T2
	    || arch == elfcpp::TAG_CPU_ARCH_V7
	    || arch == elfcpp::TAG_CPU_ARCH_V7E_M);
  }

  // Whether we have v4T interworking instructions available.
  bool
  may_use_v4t_interworking() const
  {
    Object_attribute* attr =
      this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);
    int arch = attr->int_value();
    return (arch != elfcpp::TAG_CPU_ARCH_PRE_V4
	    && arch != elfcpp::TAG_CPU_ARCH_V4);
  }

  // Whether we have v5T interworking instructions available.
  bool
  may_use_v5t_interworking() const
  {
    Object_attribute* attr =
      this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);
    int arch = attr->int_value();
    if (parameters->options().fix_arm1176())
      return (arch == elfcpp::TAG_CPU_ARCH_V6T2
	      || arch == elfcpp::TAG_CPU_ARCH_V7
	      || arch == elfcpp::TAG_CPU_ARCH_V6_M
	      || arch == elfcpp::TAG_CPU_ARCH_V6S_M
	      || arch == elfcpp::TAG_CPU_ARCH_V7E_M);
    else
      return (arch != elfcpp::TAG_CPU_ARCH_PRE_V4
	      && arch != elfcpp::TAG_CPU_ARCH_V4
	      && arch != elfcpp::TAG_CPU_ARCH_V4T);
  }

  // Process the relocations to determine unreferenced sections for
  // garbage collection.
  void
  gc_process_relocs(Symbol_table* symtab,
		    Layout* layout,
		    Sized_relobj_file<32, big_endian>* object,
		    unsigned int data_shndx,
		    unsigned int sh_type,
		    const unsigned char* prelocs,
		    size_t reloc_count,
		    Output_section* output_section,
		    bool needs_special_offset_handling,
		    size_t local_symbol_count,
		    const unsigned char* plocal_symbols);

  // Scan the relocations to look for symbol adjustments.
  void
  scan_relocs(Symbol_table* symtab,
	      Layout* layout,
	      Sized_relobj_file<32, big_endian>* object,
	      unsigned int data_shndx,
	      unsigned int sh_type,
	      const unsigned char* prelocs,
	      size_t reloc_count,
	      Output_section* output_section,
	      bool needs_special_offset_handling,
	      size_t local_symbol_count,
	      const unsigned char* plocal_symbols);

  // Finalize the sections.
  void
  do_finalize_sections(Layout*, const Input_objects*, Symbol_table*);

  // Return the value to use for a dynamic symbol which requires special
  // treatment.
  uint64_t
  do_dynsym_value(const Symbol*) const;

  // Relocate a section.
  void
  relocate_section(const Relocate_info<32, big_endian>*,
		   unsigned int sh_type,
		   const unsigned char* prelocs,
		   size_t reloc_count,
		   Output_section* output_section,
		   bool needs_special_offset_handling,
		   unsigned char* view,
		   Arm_address view_address,
		   section_size_type view_size,
		   const Reloc_symbol_changes*);

  // Scan the relocs during a relocatable link.
  void
  scan_relocatable_relocs(Symbol_table* symtab,
			  Layout* layout,
			  Sized_relobj_file<32, big_endian>* object,
			  unsigned int data_shndx,
			  unsigned int sh_type,
			  const unsigned char* prelocs,
			  size_t reloc_count,
			  Output_section* output_section,
			  bool needs_special_offset_handling,
			  size_t local_symbol_count,
			  const unsigned char* plocal_symbols,
			  Relocatable_relocs*);

  // Emit relocations for a section.
  void
  relocate_relocs(const Relocate_info<32, big_endian>*,
		  unsigned int sh_type,
		  const unsigned char* prelocs,
		  size_t reloc_count,
		  Output_section* output_section,
		  typename elfcpp::Elf_types<32>::Elf_Off
                    offset_in_output_section,
		  const Relocatable_relocs*,
		  unsigned char* view,
		  Arm_address view_address,
		  section_size_type view_size,
		  unsigned char* reloc_view,
		  section_size_type reloc_view_size);

  // Perform target-specific processing in a relocatable link.  This is
  // only used if we use the relocation strategy RELOC_SPECIAL.
  void
  relocate_special_relocatable(const Relocate_info<32, big_endian>* relinfo,
			       unsigned int sh_type,
			       const unsigned char* preloc_in,
			       size_t relnum,
			       Output_section* output_section,
			       typename elfcpp::Elf_types<32>::Elf_Off
                                 offset_in_output_section,
			       unsigned char* view,
			       typename elfcpp::Elf_types<32>::Elf_Addr
				 view_address,
			       section_size_type view_size,
			       unsigned char* preloc_out);

  // Return whether SYM is defined by the ABI.
  bool
  do_is_defined_by_abi(const Symbol* sym) const
  { return strcmp(sym->name(), "__tls_get_addr") == 0; }

  // Return whether there is a GOT section.
  bool
  has_got_section() const
  { return this->got_ != NULL; }

  // Return the size of the GOT section.
  section_size_type
  got_size() const
  {
    gold_assert(this->got_ != NULL);
    return this->got_->data_size();
  }

  // Return the number of entries in the GOT.
  unsigned int
  got_entry_count() const
  {
    if (!this->has_got_section())
      return 0;
    return this->got_size() / 4;
  }

  // Return the number of entries in the PLT.
  unsigned int
  plt_entry_count() const;

  // Return the offset of the first non-reserved PLT entry.
  unsigned int
  first_plt_entry_offset() const;

  // Return the size of each PLT entry.
  unsigned int
  plt_entry_size() const;

  // Map platform-specific reloc types
  static unsigned int
  get_real_reloc_type(unsigned int r_type);

  //
  // Methods to support stub-generations.
  //

  // Return the stub factory
  const Stub_factory&
  stub_factory() const
  { return this->stub_factory_; }

  // Make a new Arm_input_section object.
  Arm_input_section<big_endian>*
  new_arm_input_section(Relobj*, unsigned int);

  // Find the Arm_input_section object corresponding to the SHNDX-th input
  // section of RELOBJ.
  Arm_input_section<big_endian>*
  find_arm_input_section(Relobj* relobj, unsigned int shndx) const;

  // Make a new Stub_table
  Stub_table<big_endian>*
  new_stub_table(Arm_input_section<big_endian>*);

  // Scan a section for stub generation.
  void
  scan_section_for_stubs(const Relocate_info<32, big_endian>*, unsigned int,
			 const unsigned char*, size_t, Output_section*,
			 bool, const unsigned char*, Arm_address,
			 section_size_type);

  // Relocate a stub.
  void
  relocate_stub(Stub*, const Relocate_info<32, big_endian>*,
		Output_section*, unsigned char*, Arm_address,
		section_size_type);

  // Get the default ARM target.
  static Target_arm<big_endian>*
  default_target()
  {
    gold_assert(parameters->target().machine_code() == elfcpp::EM_ARM
		&& parameters->target().is_big_endian() == big_endian);
    return static_cast<Target_arm<big_endian>*>(
	     parameters->sized_target<32, big_endian>());
  }

  // Whether NAME belongs to a mapping symbol.
  static bool
  is_mapping_symbol_name(const char* name)
  {
    return (name
	    && name[0] == '$'
	    && (name[1] == 'a' || name[1] == 't' || name[1] == 'd')
	    && (name[2] == '\0' || name[2] == '.'));
  }

  // Whether we work around the Cortex-A8 erratum.
  bool
  fix_cortex_a8() const
  { return this->fix_cortex_a8_; }

  // Whether we merge exidx entries in debuginfo.
  bool
  merge_exidx_entries() const
  { return parameters->options().merge_exidx_entries(); }

  // Whether we fix R_ARM_V4BX relocation.
  // 0 - do not fix
  // 1 - replace with MOV instruction (armv4 target)
  // 2 - make interworking veneer (>= armv4t targets only)
  General_options::Fix_v4bx
  fix_v4bx() const
  { return parameters->options().fix_v4bx(); }

  // Scan a span of THUMB code section for Cortex-A8 erratum.
  void
  scan_span_for_cortex_a8_erratum(Arm_relobj<big_endian>*, unsigned int,
				  section_size_type, section_size_type,
				  const unsigned char*, Arm_address);

  // Apply Cortex-A8 workaround to a branch.
  void
  apply_cortex_a8_workaround(const Cortex_a8_stub*, Arm_address,
			     unsigned char*, Arm_address);

 protected:
  // Make the PLT-generator object.
  Output_data_plt_arm<big_endian>*
  make_data_plt(Layout* layout, Output_data_space* got_plt)
  { return this->do_make_data_plt(layout, got_plt); }

  // Make an ELF object.
  Object*
  do_make_elf_object(const std::string&, Input_file*, off_t,
		     const elfcpp::Ehdr<32, big_endian>& ehdr);

  Object*
  do_make_elf_object(const std::string&, Input_file*, off_t,
		     const elfcpp::Ehdr<32, !big_endian>&)
  { gold_unreachable(); }

  Object*
  do_make_elf_object(const std::string&, Input_file*, off_t,
		      const elfcpp::Ehdr<64, false>&)
  { gold_unreachable(); }

  Object*
  do_make_elf_object(const std::string&, Input_file*, off_t,
		     const elfcpp::Ehdr<64, true>&)
  { gold_unreachable(); }

  // Make an output section.
  Output_section*
  do_make_output_section(const char* name, elfcpp::Elf_Word type,
			 elfcpp::Elf_Xword flags)
  { return new Arm_output_section<big_endian>(name, type, flags); }

  void
  do_adjust_elf_header(unsigned char* view, int len);

  // We only need to generate stubs, and hence perform relaxation if we are
  // not doing relocatable linking.
  bool
  do_may_relax() const
  { return !parameters->options().relocatable(); }

  bool
  do_relax(int, const Input_objects*, Symbol_table*, Layout*, const Task*);

  // Determine whether an object attribute tag takes an integer, a
  // string or both.
  int
  do_attribute_arg_type(int tag) const;

  // Reorder tags during output.
  int
  do_attributes_order(int num) const;

  // This is called when the target is selected as the default.
  void
  do_select_as_default_target()
  {
    // No locking is required since there should only be one default target.
    // We cannot have both the big-endian and little-endian ARM targets
    // as the default.
    gold_assert(arm_reloc_property_table == NULL);
    arm_reloc_property_table = new Arm_reloc_property_table();
  }

  // Virtual function which is set to return true by a target if
  // it can use relocation types to determine if a function's
  // pointer is taken.
  virtual bool
  do_can_check_for_function_pointers() const
  { return true; }

  // Whether a section called SECTION_NAME may have function pointers to
  // sections not eligible for safe ICF folding.
  virtual bool
  do_section_may_have_icf_unsafe_pointers(const char* section_name) const
  {
    return (!is_prefix_of(".ARM.exidx", section_name)
	    && !is_prefix_of(".ARM.extab", section_name)
	    && Target::do_section_may_have_icf_unsafe_pointers(section_name));
  }

  virtual void
  do_define_standard_symbols(Symbol_table*, Layout*);

  virtual Output_data_plt_arm<big_endian>*
  do_make_data_plt(Layout* layout, Output_data_space* got_plt)
  {
    return new Output_data_plt_arm_standard<big_endian>(layout, got_plt);
  }

 private:
  // The class which scans relocations.
  class Scan
  {
   public:
    Scan()
      : issued_non_pic_error_(false)
    { }

    static inline int
    get_reference_flags(unsigned int r_type);

    inline void
    local(Symbol_table* symtab, Layout* layout, Target_arm* target,
	  Sized_relobj_file<32, big_endian>* object,
	  unsigned int data_shndx,
	  Output_section* output_section,
	  const elfcpp::Rel<32, big_endian>& reloc, unsigned int r_type,
	  const elfcpp::Sym<32, big_endian>& lsym,
	  bool is_discarded);

    inline void
    global(Symbol_table* symtab, Layout* layout, Target_arm* target,
	   Sized_relobj_file<32, big_endian>* object,
	   unsigned int data_shndx,
	   Output_section* output_section,
	   const elfcpp::Rel<32, big_endian>& reloc, unsigned int r_type,
	   Symbol* gsym);

    inline bool
    local_reloc_may_be_function_pointer(Symbol_table* , Layout* , Target_arm* ,
					Sized_relobj_file<32, big_endian>* ,
					unsigned int ,
					Output_section* ,
					const elfcpp::Rel<32, big_endian>& ,
					unsigned int ,
					const elfcpp::Sym<32, big_endian>&);

    inline bool
    global_reloc_may_be_function_pointer(Symbol_table* , Layout* , Target_arm* ,
					 Sized_relobj_file<32, big_endian>* ,
					 unsigned int ,
					 Output_section* ,
					 const elfcpp::Rel<32, big_endian>& ,
					 unsigned int , Symbol*);

   private:
    static void
    unsupported_reloc_local(Sized_relobj_file<32, big_endian>*,
			    unsigned int r_type);

    static void
    unsupported_reloc_global(Sized_relobj_file<32, big_endian>*,
			     unsigned int r_type, Symbol*);

    void
    check_non_pic(Relobj*, unsigned int r_type);

    // Almost identical to Symbol::needs_plt_entry except that it also
    // handles STT_ARM_TFUNC.
    static bool
    symbol_needs_plt_entry(const Symbol* sym)
    {
      // An undefined symbol from an executable does not need a PLT entry.
      if (sym->is_undefined() && !parameters->options().shared())
	return false;

      return (!parameters->doing_static_link()
	      && (sym->type() == elfcpp::STT_FUNC
		  || sym->type() == elfcpp::STT_ARM_TFUNC)
	      && (sym->is_from_dynobj()
		  || sym->is_undefined()
		  || sym->is_preemptible()));
    }

    inline bool
    possible_function_pointer_reloc(unsigned int r_type);

    // Whether we have issued an error about a non-PIC compilation.
    bool issued_non_pic_error_;
  };

  // The class which implements relocation.
  class Relocate
  {
   public:
    Relocate()
    { }

    ~Relocate()
    { }

    // Return whether the static relocation needs to be applied.
    inline bool
    should_apply_static_reloc(const Sized_symbol<32>* gsym,
			      unsigned int r_type,
			      bool is_32bit,
			      Output_section* output_section);

    // Do a relocation.  Return false if the caller should not issue
    // any warnings about this relocation.
    inline bool
    relocate(const Relocate_info<32, big_endian>*, Target_arm*,
	     Output_section*,  size_t relnum,
	     const elfcpp::Rel<32, big_endian>&,
	     unsigned int r_type, const Sized_symbol<32>*,
	     const Symbol_value<32>*,
	     unsigned char*, Arm_address,
	     section_size_type);

    // Return whether we want to pass flag NON_PIC_REF for this
    // reloc.  This means the relocation type accesses a symbol not via
    // GOT or PLT.
    static inline bool
    reloc_is_non_pic(unsigned int r_type)
    {
      switch (r_type)
	{
	// These relocation types reference GOT or PLT entries explicitly.
	case elfcpp::R_ARM_GOT_BREL:
	case elfcpp::R_ARM_GOT_ABS:
	case elfcpp::R_ARM_GOT_PREL:
	case elfcpp::R_ARM_GOT_BREL12:
	case elfcpp::R_ARM_PLT32_ABS:
	case elfcpp::R_ARM_TLS_GD32:
	case elfcpp::R_ARM_TLS_LDM32:
	case elfcpp::R_ARM_TLS_IE32:
	case elfcpp::R_ARM_TLS_IE12GP:

	// These relocate types may use PLT entries.
	case elfcpp::R_ARM_CALL:
	case elfcpp::R_ARM_THM_CALL:
	case elfcpp::R_ARM_JUMP24:
	case elfcpp::R_ARM_THM_JUMP24:
	case elfcpp::R_ARM_THM_JUMP19:
	case elfcpp::R_ARM_PLT32:
	case elfcpp::R_ARM_THM_XPC22:
	case elfcpp::R_ARM_PREL31:
	case elfcpp::R_ARM_SBREL31:
	  return false;

	default:
	  return true;
	}
    }

   private:
    // Do a TLS relocation.
    inline typename Arm_relocate_functions<big_endian>::Status
    relocate_tls(const Relocate_info<32, big_endian>*, Target_arm<big_endian>*,
		 size_t, const elfcpp::Rel<32, big_endian>&, unsigned int,
		 const Sized_symbol<32>*, const Symbol_value<32>*,
		 unsigned char*, elfcpp::Elf_types<32>::Elf_Addr,
		 section_size_type);

  };

  // A class which returns the size required for a relocation type,
  // used while scanning relocs during a relocatable link.
  class Relocatable_size_for_reloc
  {
   public:
    unsigned int
    get_size_for_reloc(unsigned int, Relobj*);
  };

  // Adjust TLS relocation type based on the options and whether this
  // is a local symbol.
  static tls::Tls_optimization
  optimize_tls_reloc(bool is_final, int r_type);

  // Get the GOT section, creating it if necessary.
  Arm_output_data_got<big_endian>*
  got_section(Symbol_table*, Layout*);

  // Get the GOT PLT section.
  Output_data_space*
  got_plt_section() const
  {
    gold_assert(this->got_plt_ != NULL);
    return this->got_plt_;
  }

  // Create a PLT entry for a global symbol.
  void
  make_plt_entry(Symbol_table*, Layout*, Symbol*);

  // Define the _TLS_MODULE_BASE_ symbol in the TLS segment.
  void
  define_tls_base_symbol(Symbol_table*, Layout*);

  // Create a GOT entry for the TLS module index.
  unsigned int
  got_mod_index_entry(Symbol_table* symtab, Layout* layout,
		      Sized_relobj_file<32, big_endian>* object);

  // Get the PLT section.
  const Output_data_plt_arm<big_endian>*
  plt_section() const
  {
    gold_assert(this->plt_ != NULL);
    return this->plt_;
  }

  // Get the dynamic reloc section, creating it if necessary.
  Reloc_section*
  rel_dyn_section(Layout*);

  // Get the section to use for TLS_DESC relocations.
  Reloc_section*
  rel_tls_desc_section(Layout*) const;

  // Return true if the symbol may need a COPY relocation.
  // References from an executable object to non-function symbols
  // defined in a dynamic object may need a COPY relocation.
  bool
  may_need_copy_reloc(Symbol* gsym)
  {
    return (gsym->type() != elfcpp::STT_ARM_TFUNC
	    && gsym->may_need_copy_reloc());
  }

  // Add a potential copy relocation.
  void
  copy_reloc(Symbol_table* symtab, Layout* layout,
	     Sized_relobj_file<32, big_endian>* object,
	     unsigned int shndx, Output_section* output_section,
	     Symbol* sym, const elfcpp::Rel<32, big_endian>& reloc)
  {
    this->copy_relocs_.copy_reloc(symtab, layout,
				  symtab->get_sized_symbol<32>(sym),
				  object, shndx, output_section, reloc,
				  this->rel_dyn_section(layout));
  }

  // Whether two EABI versions are compatible.
  static bool
  are_eabi_versions_compatible(elfcpp::Elf_Word v1, elfcpp::Elf_Word v2);

  // Merge processor-specific flags from input object and those in the ELF
  // header of the output.
  void
  merge_processor_specific_flags(const std::string&, elfcpp::Elf_Word);

  // Get the secondary compatible architecture.
  static int
  get_secondary_compatible_arch(const Attributes_section_data*);

  // Set the secondary compatible architecture.
  static void
  set_secondary_compatible_arch(Attributes_section_data*, int);

  static int
  tag_cpu_arch_combine(const char*, int, int*, int, int);

  // Helper to print AEABI enum tag value.
  static std::string
  aeabi_enum_name(unsigned int);

  // Return string value for TAG_CPU_name.
  static std::string
  tag_cpu_name_value(unsigned int);

  // Query attributes object to see if integer divide instructions may be
  // present in an object.
  static bool
  attributes_accept_div(int arch, int profile,
			const Object_attribute* div_attr);

  // Query attributes object to see if integer divide instructions are
  // forbidden to be in the object.  This is not the inverse of
  // attributes_accept_div.
  static bool
  attributes_forbid_div(const Object_attribute* div_attr);

  // Merge object attributes from input object and those in the output.
  void
  merge_object_attributes(const char*, const Attributes_section_data*);

  // Helper to get an AEABI object attribute
  Object_attribute*
  get_aeabi_object_attribute(int tag) const
  {
    Attributes_section_data* pasd = this->attributes_section_data_;
    gold_assert(pasd != NULL);
    Object_attribute* attr =
      pasd->get_attribute(Object_attribute::OBJ_ATTR_PROC, tag);
    gold_assert(attr != NULL);
    return attr;
  }

  //
  // Methods to support stub-generations.
  //

  // Group input sections for stub generation.
  void
  group_sections(Layout*, section_size_type, bool, const Task*);

  // Scan a relocation for stub generation.
  void
  scan_reloc_for_stub(const Relocate_info<32, big_endian>*, unsigned int,
		      const Sized_symbol<32>*, unsigned int,
		      const Symbol_value<32>*,
		      elfcpp::Elf_types<32>::Elf_Swxword, Arm_address);

  // Scan a relocation section for stub.
  template<int sh_type>
  void
  scan_reloc_section_for_stubs(
      const Relocate_info<32, big_endian>* relinfo,
      const unsigned char* prelocs,
      size_t reloc_count,
      Output_section* output_section,
      bool needs_special_offset_handling,
      const unsigned char* view,
      elfcpp::Elf_types<32>::Elf_Addr view_address,
      section_size_type);

  // Fix .ARM.exidx section coverage.
  void
  fix_exidx_coverage(Layout*, const Input_objects*,
		     Arm_output_section<big_endian>*, Symbol_table*,
		     const Task*);

  // Functors for STL set.
  struct output_section_address_less_than
  {
    bool
    operator()(const Output_section* s1, const Output_section* s2) const
    { return s1->address() < s2->address(); }
  };

  // Information about this specific target which we pass to the
  // general Target structure.
  static const Target::Target_info arm_info;

  // The types of GOT entries needed for this platform.
  // These values are exposed to the ABI in an incremental link.
  // Do not renumber existing values without changing the version
  // number of the .gnu_incremental_inputs section.
  enum Got_type
  {
    GOT_TYPE_STANDARD = 0,      // GOT entry for a regular symbol
    GOT_TYPE_TLS_NOFFSET = 1,   // GOT entry for negative TLS offset
    GOT_TYPE_TLS_OFFSET = 2,    // GOT entry for positive TLS offset
    GOT_TYPE_TLS_PAIR = 3,      // GOT entry for TLS module/offset pair
    GOT_TYPE_TLS_DESC = 4       // GOT entry for TLS_DESC pair
  };

  typedef typename std::vector<Stub_table<big_endian>*> Stub_table_list;

  // Map input section to Arm_input_section.
  typedef Unordered_map<Section_id,
			Arm_input_section<big_endian>*,
			Section_id_hash>
	  Arm_input_section_map;

  // Map output addresses to relocs for Cortex-A8 erratum.
  typedef Unordered_map<Arm_address, const Cortex_a8_reloc*>
	  Cortex_a8_relocs_info;

  // The GOT section.
  Arm_output_data_got<big_endian>* got_;
  // The PLT section.
  Output_data_plt_arm<big_endian>* plt_;
  // The GOT PLT section.
  Output_data_space* got_plt_;
  // The dynamic reloc section.
  Reloc_section* rel_dyn_;
  // Relocs saved to avoid a COPY reloc.
  Copy_relocs<elfcpp::SHT_REL, 32, big_endian> copy_relocs_;
  // Offset of the GOT entry for the TLS module index.
  unsigned int got_mod_index_offset_;
  // True if the _TLS_MODULE_BASE_ symbol has been defined.
  bool tls_base_symbol_defined_;
  // Vector of Stub_tables created.
  Stub_table_list stub_tables_;
  // Stub factory.
  const Stub_factory &stub_factory_;
  // Whether we force PIC branch veneers.
  bool should_force_pic_veneer_;
  // Map for locating Arm_input_sections.
  Arm_input_section_map arm_input_section_map_;
  // Attributes section data in output.
  Attributes_section_data* attributes_section_data_;
  // Whether we want to fix code for Cortex-A8 erratum.
  bool fix_cortex_a8_;
  // Map addresses to relocs for Cortex-A8 erratum.
  Cortex_a8_relocs_info cortex_a8_relocs_info_;
};

template<bool big_endian>
const Target::Target_info Target_arm<big_endian>::arm_info =
{
  32,			// size
  big_endian,		// is_big_endian
  elfcpp::EM_ARM,	// machine_code
  false,		// has_make_symbol
  false,		// has_resolve
  false,		// has_code_fill
  true,			// is_default_stack_executable
  false,		// can_icf_inline_merge_sections
  '\0',			// wrap_char
  "/usr/lib/libc.so.1",	// dynamic_linker
  0x8000,		// default_text_segment_address
  0x1000,		// abi_pagesize (overridable by -z max-page-size)
  0x1000,		// common_pagesize (overridable by -z common-page-size)
  false,                // isolate_execinstr
  0,                    // rosegment_gap
  elfcpp::SHN_UNDEF,	// small_common_shndx
  elfcpp::SHN_UNDEF,	// large_common_shndx
  0,			// small_common_section_flags
  0,			// large_common_section_flags
  ".ARM.attributes",	// attributes_section
  "aeabi",		// attributes_vendor
  "_start"		// entry_symbol_name
};

// Arm relocate functions class
//

template<bool big_endian>
class Arm_relocate_functions : public Relocate_functions<32, big_endian>
{
 public:
  typedef enum
  {
    STATUS_OKAY,	// No error during relocation.
    STATUS_OVERFLOW,	// Relocation overflow.
    STATUS_BAD_RELOC	// Relocation cannot be applied.
  } Status;

 private:
  typedef Relocate_functions<32, big_endian> Base;
  typedef Arm_relocate_functions<big_endian> This;

  // Encoding of imm16 argument for movt and movw ARM instructions
  // from ARM ARM:
  //
  //     imm16 := imm4 | imm12
  //
  //  f e d c b a 9 8 7 6 5 4 3 2 1 0 f e d c b a 9 8 7 6 5 4 3 2 1 0
  // +-------+---------------+-------+-------+-----------------------+
  // |       |               |imm4   |       |imm12                  |
  // +-------+---------------+-------+-------+-----------------------+

  // Extract the relocation addend from VAL based on the ARM
  // instruction encoding described above.
  static inline typename elfcpp::Swap<32, big_endian>::Valtype
  extract_arm_movw_movt_addend(
      typename elfcpp::Swap<32, big_endian>::Valtype val)
  {
    // According to the Elf ABI for ARM Architecture the immediate
    // field is sign-extended to form the addend.
    return Bits<16>::sign_extend32(((val >> 4) & 0xf000) | (val & 0xfff));
  }

  // Insert X into VAL based on the ARM instruction encoding described
  // above.
  static inline typename elfcpp::Swap<32, big_endian>::Valtype
  insert_val_arm_movw_movt(
      typename elfcpp::Swap<32, big_endian>::Valtype val,
      typename elfcpp::Swap<32, big_endian>::Valtype x)
  {
    val &= 0xfff0f000;
    val |= x & 0x0fff;
    val |= (x & 0xf000) << 4;
    return val;
  }

  // Encoding of imm16 argument for movt and movw Thumb2 instructions
  // from ARM ARM:
  //
  //     imm16 := imm4 | i | imm3 | imm8
  //
  //  f e d c b a 9 8 7 6 5 4 3 2 1 0  f e d c b a 9 8 7 6 5 4 3 2 1 0
  // +---------+-+-----------+-------++-+-----+-------+---------------+
  // |         |i|           |imm4   || |imm3 |       |imm8           |
  // +---------+-+-----------+-------++-+-----+-------+---------------+

  // Extract the relocation addend from VAL based on the Thumb2
  // instruction encoding described above.
  static inline typename elfcpp::Swap<32, big_endian>::Valtype
  extract_thumb_movw_movt_addend(
      typename elfcpp::Swap<32, big_endian>::Valtype val)
  {
    // According to the Elf ABI for ARM Architecture the immediate
    // field is sign-extended to form the addend.
    return Bits<16>::sign_extend32(((val >> 4) & 0xf000)
				   | ((val >> 15) & 0x0800)
				   | ((val >> 4) & 0x0700)
				   | (val & 0x00ff));
  }

  // Insert X into VAL based on the Thumb2 instruction encoding
  // described above.
  static inline typename elfcpp::Swap<32, big_endian>::Valtype
  insert_val_thumb_movw_movt(
      typename elfcpp::Swap<32, big_endian>::Valtype val,
      typename elfcpp::Swap<32, big_endian>::Valtype x)
  {
    val &= 0xfbf08f00;
    val |= (x & 0xf000) << 4;
    val |= (x & 0x0800) << 15;
    val |= (x & 0x0700) << 4;
    val |= (x & 0x00ff);
    return val;
  }

  // Calculate the smallest constant Kn for the specified residual.
  // (see (AAELF 4.6.1.4 Static ARM relocations, Group Relocations, p.32)
  static uint32_t
  calc_grp_kn(typename elfcpp::Swap<32, big_endian>::Valtype residual)
  {
    int32_t msb;

    if (residual == 0)
      return 0;
    // Determine the most significant bit in the residual and
    // align the resulting value to a 2-bit boundary.
    for (msb = 30; (msb >= 0) && !(residual & (3 << msb)); msb -= 2)
      ;
    // The desired shift is now (msb - 6), or zero, whichever
    // is the greater.
    return (((msb - 6) < 0) ? 0 : (msb - 6));
  }

  // Calculate the final residual for the specified group index.
  // If the passed group index is less than zero, the method will return
  // the value of the specified residual without any change.
  // (see (AAELF 4.6.1.4 Static ARM relocations, Group Relocations, p.32)
  static typename elfcpp::Swap<32, big_endian>::Valtype
  calc_grp_residual(typename elfcpp::Swap<32, big_endian>::Valtype residual,
		    const int group)
  {
    for (int n = 0; n <= group; n++)
      {
	// Calculate which part of the value to mask.
	uint32_t shift = calc_grp_kn(residual);
	// Calculate the residual for the next time around.
	residual &= ~(residual & (0xff << shift));
      }

    return residual;
  }

  // Calculate the value of Gn for the specified group index.
  // We return it in the form of an encoded constant-and-rotation.
  // (see (AAELF 4.6.1.4 Static ARM relocations, Group Relocations, p.32)
  static typename elfcpp::Swap<32, big_endian>::Valtype
  calc_grp_gn(typename elfcpp::Swap<32, big_endian>::Valtype residual,
	      const int group)
  {
    typename elfcpp::Swap<32, big_endian>::Valtype gn = 0;
    uint32_t shift = 0;

    for (int n = 0; n <= group; n++)
      {
	// Calculate which part of the value to mask.
	shift = calc_grp_kn(residual);
	// Calculate Gn in 32-bit as well as encoded constant-and-rotation form.
	gn = residual & (0xff << shift);
	// Calculate the residual for the next time around.
	residual &= ~gn;
      }
    // Return Gn in the form of an encoded constant-and-rotation.
    return ((gn >> shift) | ((gn <= 0xff ? 0 : (32 - shift) / 2) << 8));
  }

 public:
  // Handle ARM long branches.
  static typename This::Status
  arm_branch_common(unsigned int, const Relocate_info<32, big_endian>*,
		    unsigned char*, const Sized_symbol<32>*,
		    const Arm_relobj<big_endian>*, unsigned int,
		    const Symbol_value<32>*, Arm_address, Arm_address, bool);

  // Handle THUMB long branches.
  static typename This::Status
  thumb_branch_common(unsigned int, const Relocate_info<32, big_endian>*,
		      unsigned char*, const Sized_symbol<32>*,
		      const Arm_relobj<big_endian>*, unsigned int,
		      const Symbol_value<32>*, Arm_address, Arm_address, bool);


  // Return the branch offset of a 32-bit THUMB branch.
  static inline int32_t
  thumb32_branch_offset(uint16_t upper_insn, uint16_t lower_insn)
  {
    // We use the Thumb-2 encoding (backwards compatible with Thumb-1)
    // involving the J1 and J2 bits.
    uint32_t s = (upper_insn & (1U << 10)) >> 10;
    uint32_t upper = upper_insn & 0x3ffU;
    uint32_t lower = lower_insn & 0x7ffU;
    uint32_t j1 = (lower_insn & (1U << 13)) >> 13;
    uint32_t j2 = (lower_insn & (1U << 11)) >> 11;
    uint32_t i1 = j1 ^ s ? 0 : 1;
    uint32_t i2 = j2 ^ s ? 0 : 1;

    return Bits<25>::sign_extend32((s << 24) | (i1 << 23) | (i2 << 22)
				   | (upper << 12) | (lower << 1));
  }

  // Insert OFFSET to a 32-bit THUMB branch and return the upper instruction.
  // UPPER_INSN is the original upper instruction of the branch.  Caller is
  // responsible for overflow checking and BLX offset adjustment.
  static inline uint16_t
  thumb32_branch_upper(uint16_t upper_insn, int32_t offset)
  {
    uint32_t s = offset < 0 ? 1 : 0;
    uint32_t bits = static_cast<uint32_t>(offset);
    return (upper_insn & ~0x7ffU) | ((bits >> 12) & 0x3ffU) | (s << 10);
  }

  // Insert OFFSET to a 32-bit THUMB branch and return the lower instruction.
  // LOWER_INSN is the original lower instruction of the branch.  Caller is
  // responsible for overflow checking and BLX offset adjustment.
  static inline uint16_t
  thumb32_branch_lower(uint16_t lower_insn, int32_t offset)
  {
    uint32_t s = offset < 0 ? 1 : 0;
    uint32_t bits = static_cast<uint32_t>(offset);
    return ((lower_insn & ~0x2fffU)
	    | ((((bits >> 23) & 1) ^ !s) << 13)
	    | ((((bits >> 22) & 1) ^ !s) << 11)
	    | ((bits >> 1) & 0x7ffU));
  }

  // Return the branch offset of a 32-bit THUMB conditional branch.
  static inline int32_t
  thumb32_cond_branch_offset(uint16_t upper_insn, uint16_t lower_insn)
  {
    uint32_t s = (upper_insn & 0x0400U) >> 10;
    uint32_t j1 = (lower_insn & 0x2000U) >> 13;
    uint32_t j2 = (lower_insn & 0x0800U) >> 11;
    uint32_t lower = (lower_insn & 0x07ffU);
    uint32_t upper = (s << 8) | (j2 << 7) | (j1 << 6) | (upper_insn & 0x003fU);

    return Bits<21>::sign_extend32((upper << 12) | (lower << 1));
  }

  // Insert OFFSET to a 32-bit THUMB conditional branch and return the upper
  // instruction.  UPPER_INSN is the original upper instruction of the branch.
  // Caller is responsible for overflow checking.
  static inline uint16_t
  thumb32_cond_branch_upper(uint16_t upper_insn, int32_t offset)
  {
    uint32_t s = offset < 0 ? 1 : 0;
    uint32_t bits = static_cast<uint32_t>(offset);
    return (upper_insn & 0xfbc0U) | (s << 10) | ((bits & 0x0003f000U) >> 12);
  }

  // Insert OFFSET to a 32-bit THUMB conditional branch and return the lower
  // instruction.  LOWER_INSN is the original lower instruction of the branch.
  // The caller is responsible for overflow checking.
  static inline uint16_t
  thumb32_cond_branch_lower(uint16_t lower_insn, int32_t offset)
  {
    uint32_t bits = static_cast<uint32_t>(offset);
    uint32_t j2 = (bits & 0x00080000U) >> 19;
    uint32_t j1 = (bits & 0x00040000U) >> 18;
    uint32_t lo = (bits & 0x00000ffeU) >> 1;

    return (lower_insn & 0xd000U) | (j1 << 13) | (j2 << 11) | lo;
  }

  // R_ARM_ABS8: S + A
  static inline typename This::Status
  abs8(unsigned char* view,
       const Sized_relobj_file<32, big_endian>* object,
       const Symbol_value<32>* psymval)
  {
    typedef typename elfcpp::Swap<8, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<8, big_endian>::readval(wv);
    int32_t addend = Bits<8>::sign_extend32(val);
    Arm_address x = psymval->value(object, addend);
    val = Bits<32>::bit_select32(val, x, 0xffU);
    elfcpp::Swap<8, big_endian>::writeval(wv, val);

    // R_ARM_ABS8 permits signed or unsigned results.
    return (Bits<8>::has_signed_unsigned_overflow32(x)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_THM_ABS5: S + A
  static inline typename This::Status
  thm_abs5(unsigned char* view,
       const Sized_relobj_file<32, big_endian>* object,
       const Symbol_value<32>* psymval)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<16, big_endian>::readval(wv);
    Reltype addend = (val & 0x7e0U) >> 6;
    Reltype x = psymval->value(object, addend);
    val = Bits<32>::bit_select32(val, x << 6, 0x7e0U);
    elfcpp::Swap<16, big_endian>::writeval(wv, val);
    return (Bits<5>::has_overflow32(x)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_ABS12: S + A
  static inline typename This::Status
  abs12(unsigned char* view,
	const Sized_relobj_file<32, big_endian>* object,
	const Symbol_value<32>* psymval)
  {
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
    Reltype addend = val & 0x0fffU;
    Reltype x = psymval->value(object, addend);
    val = Bits<32>::bit_select32(val, x, 0x0fffU);
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
    return (Bits<12>::has_overflow32(x)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_ABS16: S + A
  static inline typename This::Status
  abs16(unsigned char* view,
	const Sized_relobj_file<32, big_endian>* object,
	const Symbol_value<32>* psymval)
  {
    typedef typename elfcpp::Swap_unaligned<16, big_endian>::Valtype Valtype;
    Valtype val = elfcpp::Swap_unaligned<16, big_endian>::readval(view);
    int32_t addend = Bits<16>::sign_extend32(val);
    Arm_address x = psymval->value(object, addend);
    val = Bits<32>::bit_select32(val, x, 0xffffU);
    elfcpp::Swap_unaligned<16, big_endian>::writeval(view, val);

    // R_ARM_ABS16 permits signed or unsigned results.
    return (Bits<16>::has_signed_unsigned_overflow32(x)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_ABS32: (S + A) | T
  static inline typename This::Status
  abs32(unsigned char* view,
	const Sized_relobj_file<32, big_endian>* object,
	const Symbol_value<32>* psymval,
	Arm_address thumb_bit)
  {
    typedef typename elfcpp::Swap_unaligned<32, big_endian>::Valtype Valtype;
    Valtype addend = elfcpp::Swap_unaligned<32, big_endian>::readval(view);
    Valtype x = psymval->value(object, addend) | thumb_bit;
    elfcpp::Swap_unaligned<32, big_endian>::writeval(view, x);
    return This::STATUS_OKAY;
  }

  // R_ARM_REL32: (S + A) | T - P
  static inline typename This::Status
  rel32(unsigned char* view,
	const Sized_relobj_file<32, big_endian>* object,
	const Symbol_value<32>* psymval,
	Arm_address address,
	Arm_address thumb_bit)
  {
    typedef typename elfcpp::Swap_unaligned<32, big_endian>::Valtype Valtype;
    Valtype addend = elfcpp::Swap_unaligned<32, big_endian>::readval(view);
    Valtype x = (psymval->value(object, addend) | thumb_bit) - address;
    elfcpp::Swap_unaligned<32, big_endian>::writeval(view, x);
    return This::STATUS_OKAY;
  }

  // R_ARM_THM_JUMP24: (S + A) | T - P
  static typename This::Status
  thm_jump19(unsigned char* view, const Arm_relobj<big_endian>* object,
	     const Symbol_value<32>* psymval, Arm_address address,
	     Arm_address thumb_bit);

  // R_ARM_THM_JUMP6: S + A  P
  static inline typename This::Status
  thm_jump6(unsigned char* view,
	    const Sized_relobj_file<32, big_endian>* object,
	    const Symbol_value<32>* psymval,
	    Arm_address address)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<16, big_endian>::readval(wv);
    // bit[9]:bit[7:3]:0 (mask: 0x02f8)
    Reltype addend = (((val & 0x0200) >> 3) | ((val & 0x00f8) >> 2));
    Reltype x = (psymval->value(object, addend) - address);
    val = (val & 0xfd07) | ((x  & 0x0040) << 3) | ((val & 0x003e) << 2);
    elfcpp::Swap<16, big_endian>::writeval(wv, val);
    // CZB does only forward jumps.
    return ((x > 0x007e)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_THM_JUMP8: S + A  P
  static inline typename This::Status
  thm_jump8(unsigned char* view,
	    const Sized_relobj_file<32, big_endian>* object,
	    const Symbol_value<32>* psymval,
	    Arm_address address)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<16, big_endian>::readval(wv);
    int32_t addend = Bits<8>::sign_extend32((val & 0x00ff) << 1);
    int32_t x = (psymval->value(object, addend) - address);
    elfcpp::Swap<16, big_endian>::writeval(wv, ((val & 0xff00)
						| ((x & 0x01fe) >> 1)));
    // We do a 9-bit overflow check because x is right-shifted by 1 bit.
    return (Bits<9>::has_overflow32(x)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_THM_JUMP11: S + A  P
  static inline typename This::Status
  thm_jump11(unsigned char* view,
	    const Sized_relobj_file<32, big_endian>* object,
	    const Symbol_value<32>* psymval,
	    Arm_address address)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<16, big_endian>::readval(wv);
    int32_t addend = Bits<11>::sign_extend32((val & 0x07ff) << 1);
    int32_t x = (psymval->value(object, addend) - address);
    elfcpp::Swap<16, big_endian>::writeval(wv, ((val & 0xf800)
						| ((x & 0x0ffe) >> 1)));
    // We do a 12-bit overflow check because x is right-shifted by 1 bit.
    return (Bits<12>::has_overflow32(x)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_BASE_PREL: B(S) + A - P
  static inline typename This::Status
  base_prel(unsigned char* view,
	    Arm_address origin,
	    Arm_address address)
  {
    Base::rel32(view, origin - address);
    return STATUS_OKAY;
  }

  // R_ARM_BASE_ABS: B(S) + A
  static inline typename This::Status
  base_abs(unsigned char* view,
	   Arm_address origin)
  {
    Base::rel32(view, origin);
    return STATUS_OKAY;
  }

  // R_ARM_GOT_BREL: GOT(S) + A - GOT_ORG
  static inline typename This::Status
  got_brel(unsigned char* view,
	   typename elfcpp::Swap<32, big_endian>::Valtype got_offset)
  {
    Base::rel32(view, got_offset);
    return This::STATUS_OKAY;
  }

  // R_ARM_GOT_PREL: GOT(S) + A - P
  static inline typename This::Status
  got_prel(unsigned char* view,
	   Arm_address got_entry,
	   Arm_address address)
  {
    Base::rel32(view, got_entry - address);
    return This::STATUS_OKAY;
  }

  // R_ARM_PREL: (S + A) | T - P
  static inline typename This::Status
  prel31(unsigned char* view,
	 const Sized_relobj_file<32, big_endian>* object,
	 const Symbol_value<32>* psymval,
	 Arm_address address,
	 Arm_address thumb_bit)
  {
    typedef typename elfcpp::Swap_unaligned<32, big_endian>::Valtype Valtype;
    Valtype val = elfcpp::Swap_unaligned<32, big_endian>::readval(view);
    Valtype addend = Bits<31>::sign_extend32(val);
    Valtype x = (psymval->value(object, addend) | thumb_bit) - address;
    val = Bits<32>::bit_select32(val, x, 0x7fffffffU);
    elfcpp::Swap_unaligned<32, big_endian>::writeval(view, val);
    return (Bits<31>::has_overflow32(x)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_MOVW_ABS_NC: (S + A) | T	(relative address base is )
  // R_ARM_MOVW_PREL_NC: (S + A) | T - P
  // R_ARM_MOVW_BREL_NC: ((S + A) | T) - B(S)
  // R_ARM_MOVW_BREL: ((S + A) | T) - B(S)
  static inline typename This::Status
  movw(unsigned char* view,
       const Sized_relobj_file<32, big_endian>* object,
       const Symbol_value<32>* psymval,
       Arm_address relative_address_base,
       Arm_address thumb_bit,
       bool check_overflow)
  {
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
    Valtype addend = This::extract_arm_movw_movt_addend(val);
    Valtype x = ((psymval->value(object, addend) | thumb_bit)
		 - relative_address_base);
    val = This::insert_val_arm_movw_movt(val, x);
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
    return ((check_overflow && Bits<16>::has_overflow32(x))
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_MOVT_ABS: S + A	(relative address base is 0)
  // R_ARM_MOVT_PREL: S + A - P
  // R_ARM_MOVT_BREL: S + A - B(S)
  static inline typename This::Status
  movt(unsigned char* view,
       const Sized_relobj_file<32, big_endian>* object,
       const Symbol_value<32>* psymval,
       Arm_address relative_address_base)
  {
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
    Valtype addend = This::extract_arm_movw_movt_addend(val);
    Valtype x = (psymval->value(object, addend) - relative_address_base) >> 16;
    val = This::insert_val_arm_movw_movt(val, x);
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
    // FIXME: IHI0044D says that we should check for overflow.
    return This::STATUS_OKAY;
  }

  // R_ARM_THM_MOVW_ABS_NC: S + A | T		(relative_address_base is 0)
  // R_ARM_THM_MOVW_PREL_NC: (S + A) | T - P
  // R_ARM_THM_MOVW_BREL_NC: ((S + A) | T) - B(S)
  // R_ARM_THM_MOVW_BREL: ((S + A) | T) - B(S)
  static inline typename This::Status
  thm_movw(unsigned char* view,
	   const Sized_relobj_file<32, big_endian>* object,
	   const Symbol_value<32>* psymval,
	   Arm_address relative_address_base,
	   Arm_address thumb_bit,
	   bool check_overflow)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Reltype val = (elfcpp::Swap<16, big_endian>::readval(wv) << 16)
		  | elfcpp::Swap<16, big_endian>::readval(wv + 1);
    Reltype addend = This::extract_thumb_movw_movt_addend(val);
    Reltype x =
      (psymval->value(object, addend) | thumb_bit) - relative_address_base;
    val = This::insert_val_thumb_movw_movt(val, x);
    elfcpp::Swap<16, big_endian>::writeval(wv, val >> 16);
    elfcpp::Swap<16, big_endian>::writeval(wv + 1, val & 0xffff);
    return ((check_overflow && Bits<16>::has_overflow32(x))
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_THM_MOVT_ABS: S + A		(relative address base is 0)
  // R_ARM_THM_MOVT_PREL: S + A - P
  // R_ARM_THM_MOVT_BREL: S + A - B(S)
  static inline typename This::Status
  thm_movt(unsigned char* view,
	   const Sized_relobj_file<32, big_endian>* object,
	   const Symbol_value<32>* psymval,
	   Arm_address relative_address_base)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Reltype val = (elfcpp::Swap<16, big_endian>::readval(wv) << 16)
		  | elfcpp::Swap<16, big_endian>::readval(wv + 1);
    Reltype addend = This::extract_thumb_movw_movt_addend(val);
    Reltype x = (psymval->value(object, addend) - relative_address_base) >> 16;
    val = This::insert_val_thumb_movw_movt(val, x);
    elfcpp::Swap<16, big_endian>::writeval(wv, val >> 16);
    elfcpp::Swap<16, big_endian>::writeval(wv + 1, val & 0xffff);
    return This::STATUS_OKAY;
  }

  // R_ARM_THM_ALU_PREL_11_0: ((S + A) | T) - Pa (Thumb32)
  static inline typename This::Status
  thm_alu11(unsigned char* view,
	    const Sized_relobj_file<32, big_endian>* object,
	    const Symbol_value<32>* psymval,
	    Arm_address address,
	    Arm_address thumb_bit)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Reltype insn = (elfcpp::Swap<16, big_endian>::readval(wv) << 16)
		   | elfcpp::Swap<16, big_endian>::readval(wv + 1);

    //	      f e d c b|a|9|8 7 6 5|4|3 2 1 0||f|e d c|b a 9 8|7 6 5 4 3 2 1 0
    // -----------------------------------------------------------------------
    // ADD{S} 1 1 1 1 0|i|0|1 0 0 0|S|1 1 0 1||0|imm3 |Rd     |imm8
    // ADDW   1 1 1 1 0|i|1|0 0 0 0|0|1 1 0 1||0|imm3 |Rd     |imm8
    // ADR[+] 1 1 1 1 0|i|1|0 0 0 0|0|1 1 1 1||0|imm3 |Rd     |imm8
    // SUB{S} 1 1 1 1 0|i|0|1 1 0 1|S|1 1 0 1||0|imm3 |Rd     |imm8
    // SUBW   1 1 1 1 0|i|1|0 1 0 1|0|1 1 0 1||0|imm3 |Rd     |imm8
    // ADR[-] 1 1 1 1 0|i|1|0 1 0 1|0|1 1 1 1||0|imm3 |Rd     |imm8

    // Determine a sign for the addend.
    const int sign = ((insn & 0xf8ef0000) == 0xf0ad0000
		      || (insn & 0xf8ef0000) == 0xf0af0000) ? -1 : 1;
    // Thumb2 addend encoding:
    // imm12 := i | imm3 | imm8
    int32_t addend = (insn & 0xff)
		     | ((insn & 0x00007000) >> 4)
		     | ((insn & 0x04000000) >> 15);
    // Apply a sign to the added.
    addend *= sign;

    int32_t x = (psymval->value(object, addend) | thumb_bit)
		- (address & 0xfffffffc);
    Reltype val = abs(x);
    // Mask out the value and a distinct part of the ADD/SUB opcode
    // (bits 7:5 of opword).
    insn = (insn & 0xfb0f8f00)
	   | (val & 0xff)
	   | ((val & 0x700) << 4)
	   | ((val & 0x800) << 15);
    // Set the opcode according to whether the value to go in the
    // place is negative.
    if (x < 0)
      insn |= 0x00a00000;

    elfcpp::Swap<16, big_endian>::writeval(wv, insn >> 16);
    elfcpp::Swap<16, big_endian>::writeval(wv + 1, insn & 0xffff);
    return ((val > 0xfff) ?
	    This::STATUS_OVERFLOW : This::STATUS_OKAY);
  }

  // R_ARM_THM_PC8: S + A - Pa (Thumb)
  static inline typename This::Status
  thm_pc8(unsigned char* view,
	  const Sized_relobj_file<32, big_endian>* object,
	  const Symbol_value<32>* psymval,
	  Arm_address address)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype insn = elfcpp::Swap<16, big_endian>::readval(wv);
    Reltype addend = ((insn & 0x00ff) << 2);
    int32_t x = (psymval->value(object, addend) - (address & 0xfffffffc));
    Reltype val = abs(x);
    insn = (insn & 0xff00) | ((val & 0x03fc) >> 2);

    elfcpp::Swap<16, big_endian>::writeval(wv, insn);
    return ((val > 0x03fc)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_THM_PC12: S + A - Pa (Thumb32)
  static inline typename This::Status
  thm_pc12(unsigned char* view,
	   const Sized_relobj_file<32, big_endian>* object,
	   const Symbol_value<32>* psymval,
	   Arm_address address)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Reltype insn = (elfcpp::Swap<16, big_endian>::readval(wv) << 16)
		   | elfcpp::Swap<16, big_endian>::readval(wv + 1);
    // Determine a sign for the addend (positive if the U bit is 1).
    const int sign = (insn & 0x00800000) ? 1 : -1;
    int32_t addend = (insn & 0xfff);
    // Apply a sign to the added.
    addend *= sign;

    int32_t x = (psymval->value(object, addend) - (address & 0xfffffffc));
    Reltype val = abs(x);
    // Mask out and apply the value and the U bit.
    insn = (insn & 0xff7ff000) | (val & 0xfff);
    // Set the U bit according to whether the value to go in the
    // place is positive.
    if (x >= 0)
      insn |= 0x00800000;

    elfcpp::Swap<16, big_endian>::writeval(wv, insn >> 16);
    elfcpp::Swap<16, big_endian>::writeval(wv + 1, insn & 0xffff);
    return ((val > 0xfff) ?
	    This::STATUS_OVERFLOW : This::STATUS_OKAY);
  }

  // R_ARM_V4BX
  static inline typename This::Status
  v4bx(const Relocate_info<32, big_endian>* relinfo,
       unsigned char* view,
       const Arm_relobj<big_endian>* object,
       const Arm_address address,
       const bool is_interworking)
  {

    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);

    // Ensure that we have a BX instruction.
    gold_assert((val & 0x0ffffff0) == 0x012fff10);
    const uint32_t reg = (val & 0xf);
    if (is_interworking && reg != 0xf)
      {
	Stub_table<big_endian>* stub_table =
	    object->stub_table(relinfo->data_shndx);
	gold_assert(stub_table != NULL);

	Arm_v4bx_stub* stub = stub_table->find_arm_v4bx_stub(reg);
	gold_assert(stub != NULL);

	int32_t veneer_address =
	    stub_table->address() + stub->offset() - 8 - address;
	gold_assert((veneer_address <= ARM_MAX_FWD_BRANCH_OFFSET)
		    && (veneer_address >= ARM_MAX_BWD_BRANCH_OFFSET));
	// Replace with a branch to veneer (B <addr>)
	val = (val & 0xf0000000) | 0x0a000000
	      | ((veneer_address >> 2) & 0x00ffffff);
      }
    else
      {
	// Preserve Rm (lowest four bits) and the condition code
	// (highest four bits). Other bits encode MOV PC,Rm.
	val = (val & 0xf000000f) | 0x01a0f000;
      }
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
    return This::STATUS_OKAY;
  }

  // R_ARM_ALU_PC_G0_NC: ((S + A) | T) - P
  // R_ARM_ALU_PC_G0:    ((S + A) | T) - P
  // R_ARM_ALU_PC_G1_NC: ((S + A) | T) - P
  // R_ARM_ALU_PC_G1:    ((S + A) | T) - P
  // R_ARM_ALU_PC_G2:    ((S + A) | T) - P
  // R_ARM_ALU_SB_G0_NC: ((S + A) | T) - B(S)
  // R_ARM_ALU_SB_G0:    ((S + A) | T) - B(S)
  // R_ARM_ALU_SB_G1_NC: ((S + A) | T) - B(S)
  // R_ARM_ALU_SB_G1:    ((S + A) | T) - B(S)
  // R_ARM_ALU_SB_G2:    ((S + A) | T) - B(S)
  static inline typename This::Status
  arm_grp_alu(unsigned char* view,
	const Sized_relobj_file<32, big_endian>* object,
	const Symbol_value<32>* psymval,
	const int group,
	Arm_address address,
	Arm_address thumb_bit,
	bool check_overflow)
  {
    gold_assert(group >= 0 && group < 3);
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype insn = elfcpp::Swap<32, big_endian>::readval(wv);

    // ALU group relocations are allowed only for the ADD/SUB instructions.
    // (0x00800000 - ADD, 0x00400000 - SUB)
    const Valtype opcode = insn & 0x01e00000;
    if (opcode != 0x00800000 && opcode != 0x00400000)
      return This::STATUS_BAD_RELOC;

    // Determine a sign for the addend.
    const int sign = (opcode == 0x00800000) ? 1 : -1;
    // shifter = rotate_imm * 2
    const uint32_t shifter = (insn & 0xf00) >> 7;
    // Initial addend value.
    int32_t addend = insn & 0xff;
    // Rotate addend right by shifter.
    addend = (addend >> shifter) | (addend << (32 - shifter));
    // Apply a sign to the added.
    addend *= sign;

    int32_t x = ((psymval->value(object, addend) | thumb_bit) - address);
    Valtype gn = Arm_relocate_functions::calc_grp_gn(abs(x), group);
    // Check for overflow if required
    if (check_overflow
	&& (Arm_relocate_functions::calc_grp_residual(abs(x), group) != 0))
      return This::STATUS_OVERFLOW;

    // Mask out the value and the ADD/SUB part of the opcode; take care
    // not to destroy the S bit.
    insn &= 0xff1ff000;
    // Set the opcode according to whether the value to go in the
    // place is negative.
    insn |= ((x < 0) ? 0x00400000 : 0x00800000);
    // Encode the offset (encoded Gn).
    insn |= gn;

    elfcpp::Swap<32, big_endian>::writeval(wv, insn);
    return This::STATUS_OKAY;
  }

  // R_ARM_LDR_PC_G0: S + A - P
  // R_ARM_LDR_PC_G1: S + A - P
  // R_ARM_LDR_PC_G2: S + A - P
  // R_ARM_LDR_SB_G0: S + A - B(S)
  // R_ARM_LDR_SB_G1: S + A - B(S)
  // R_ARM_LDR_SB_G2: S + A - B(S)
  static inline typename This::Status
  arm_grp_ldr(unsigned char* view,
	const Sized_relobj_file<32, big_endian>* object,
	const Symbol_value<32>* psymval,
	const int group,
	Arm_address address)
  {
    gold_assert(group >= 0 && group < 3);
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype insn = elfcpp::Swap<32, big_endian>::readval(wv);

    const int sign = (insn & 0x00800000) ? 1 : -1;
    int32_t addend = (insn & 0xfff) * sign;
    int32_t x = (psymval->value(object, addend) - address);
    // Calculate the relevant G(n-1) value to obtain this stage residual.
    Valtype residual =
	Arm_relocate_functions::calc_grp_residual(abs(x), group - 1);
    if (residual >= 0x1000)
      return This::STATUS_OVERFLOW;

    // Mask out the value and U bit.
    insn &= 0xff7ff000;
    // Set the U bit for non-negative values.
    if (x >= 0)
      insn |= 0x00800000;
    insn |= residual;

    elfcpp::Swap<32, big_endian>::writeval(wv, insn);
    return This::STATUS_OKAY;
  }

  // R_ARM_LDRS_PC_G0: S + A - P
  // R_ARM_LDRS_PC_G1: S + A - P
  // R_ARM_LDRS_PC_G2: S + A - P
  // R_ARM_LDRS_SB_G0: S + A - B(S)
  // R_ARM_LDRS_SB_G1: S + A - B(S)
  // R_ARM_LDRS_SB_G2: S + A - B(S)
  static inline typename This::Status
  arm_grp_ldrs(unsigned char* view,
	const Sized_relobj_file<32, big_endian>* object,
	const Symbol_value<32>* psymval,
	const int group,
	Arm_address address)
  {
    gold_assert(group >= 0 && group < 3);
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype insn = elfcpp::Swap<32, big_endian>::readval(wv);

    const int sign = (insn & 0x00800000) ? 1 : -1;
    int32_t addend = (((insn & 0xf00) >> 4) + (insn & 0xf)) * sign;
    int32_t x = (psymval->value(object, addend) - address);
    // Calculate the relevant G(n-1) value to obtain this stage residual.
    Valtype residual =
	Arm_relocate_functions::calc_grp_residual(abs(x), group - 1);
   if (residual >= 0x100)
      return This::STATUS_OVERFLOW;

    // Mask out the value and U bit.
    insn &= 0xff7ff0f0;
    // Set the U bit for non-negative values.
    if (x >= 0)
      insn |= 0x00800000;
    insn |= ((residual & 0xf0) << 4) | (residual & 0xf);

    elfcpp::Swap<32, big_endian>::writeval(wv, insn);
    return This::STATUS_OKAY;
  }

  // R_ARM_LDC_PC_G0: S + A - P
  // R_ARM_LDC_PC_G1: S + A - P
  // R_ARM_LDC_PC_G2: S + A - P
  // R_ARM_LDC_SB_G0: S + A - B(S)
  // R_ARM_LDC_SB_G1: S + A - B(S)
  // R_ARM_LDC_SB_G2: S + A - B(S)
  static inline typename This::Status
  arm_grp_ldc(unsigned char* view,
      const Sized_relobj_file<32, big_endian>* object,
      const Symbol_value<32>* psymval,
      const int group,
      Arm_address address)
  {
    gold_assert(group >= 0 && group < 3);
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype insn = elfcpp::Swap<32, big_endian>::readval(wv);

    const int sign = (insn & 0x00800000) ? 1 : -1;
    int32_t addend = ((insn & 0xff) << 2) * sign;
    int32_t x = (psymval->value(object, addend) - address);
    // Calculate the relevant G(n-1) value to obtain this stage residual.
    Valtype residual =
      Arm_relocate_functions::calc_grp_residual(abs(x), group - 1);
    if ((residual & 0x3) != 0 || residual >= 0x400)
      return This::STATUS_OVERFLOW;

    // Mask out the value and U bit.
    insn &= 0xff7fff00;
    // Set the U bit for non-negative values.
    if (x >= 0)
      insn |= 0x00800000;
    insn |= (residual >> 2);

    elfcpp::Swap<32, big_endian>::writeval(wv, insn);
    return This::STATUS_OKAY;
  }
};

// Relocate ARM long branches.  This handles relocation types
// R_ARM_CALL, R_ARM_JUMP24, R_ARM_PLT32 and R_ARM_XPC25.
// If IS_WEAK_UNDEFINED_WITH_PLT is true.  The target symbol is weakly
// undefined and we do not use PLT in this relocation.  In such a case,
// the branch is converted into an NOP.

template<bool big_endian>
typename Arm_relocate_functions<big_endian>::Status
Arm_relocate_functions<big_endian>::arm_branch_common(
    unsigned int r_type,
    const Relocate_info<32, big_endian>* relinfo,
    unsigned char* view,
    const Sized_symbol<32>* gsym,
    const Arm_relobj<big_endian>* object,
    unsigned int r_sym,
    const Symbol_value<32>* psymval,
    Arm_address address,
    Arm_address thumb_bit,
    bool is_weakly_undefined_without_plt)
{
  typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
  Valtype* wv = reinterpret_cast<Valtype*>(view);
  Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);

  bool insn_is_b = (((val >> 28) & 0xf) <= 0xe)
		    && ((val & 0x0f000000UL) == 0x0a000000UL);
  bool insn_is_uncond_bl = (val & 0xff000000UL) == 0xeb000000UL;
  bool insn_is_cond_bl = (((val >> 28) & 0xf) < 0xe)
			  && ((val & 0x0f000000UL) == 0x0b000000UL);
  bool insn_is_blx = (val & 0xfe000000UL) == 0xfa000000UL;
  bool insn_is_any_branch = (val & 0x0e000000UL) == 0x0a000000UL;

  // Check that the instruction is valid.
  if (r_type == elfcpp::R_ARM_CALL)
    {
      if (!insn_is_uncond_bl && !insn_is_blx)
	return This::STATUS_BAD_RELOC;
    }
  else if (r_type == elfcpp::R_ARM_JUMP24)
    {
      if (!insn_is_b && !insn_is_cond_bl)
	return This::STATUS_BAD_RELOC;
    }
  else if (r_type == elfcpp::R_ARM_PLT32)
    {
      if (!insn_is_any_branch)
	return This::STATUS_BAD_RELOC;
    }
  else if (r_type == elfcpp::R_ARM_XPC25)
    {
      // FIXME: AAELF document IH0044C does not say much about it other
      // than it being obsolete.
      if (!insn_is_any_branch)
	return This::STATUS_BAD_RELOC;
    }
  else
    gold_unreachable();

  // A branch to an undefined weak symbol is turned into a jump to
  // the next instruction unless a PLT entry will be created.
  // Do the same for local undefined symbols.
  // The jump to the next instruction is optimized as a NOP depending
  // on the architecture.
  const Target_arm<big_endian>* arm_target =
    Target_arm<big_endian>::default_target();
  if (is_weakly_undefined_without_plt)
    {
      gold_assert(!parameters->options().relocatable());
      Valtype cond = val & 0xf0000000U;
      if (arm_target->may_use_arm_nop())
	val = cond | 0x0320f000;
      else
	val = cond | 0x01a00000;	// Using pre-UAL nop: mov r0, r0.
      elfcpp::Swap<32, big_endian>::writeval(wv, val);
      return This::STATUS_OKAY;
    }

  Valtype addend = Bits<26>::sign_extend32(val << 2);
  Valtype branch_target = psymval->value(object, addend);
  int32_t branch_offset = branch_target - address;

  // We need a stub if the branch offset is too large or if we need
  // to switch mode.
  bool may_use_blx = arm_target->may_use_v5t_interworking();
  Reloc_stub* stub = NULL;

  if (!parameters->options().relocatable()
      && (Bits<26>::has_overflow32(branch_offset)
	  || ((thumb_bit != 0)
	      && !(may_use_blx && r_type == elfcpp::R_ARM_CALL))))
    {
      Valtype unadjusted_branch_target = psymval->value(object, 0);

      Stub_type stub_type =
	Reloc_stub::stub_type_for_reloc(r_type, address,
					unadjusted_branch_target,
					(thumb_bit != 0));
      if (stub_type != arm_stub_none)
	{
	  Stub_table<big_endian>* stub_table =
	    object->stub_table(relinfo->data_shndx);
	  gold_assert(stub_table != NULL);

	  Reloc_stub::Key stub_key(stub_type, gsym, object, r_sym, addend);
	  stub = stub_table->find_reloc_stub(stub_key);
	  gold_assert(stub != NULL);
	  thumb_bit = stub->stub_template()->entry_in_thumb_mode() ? 1 : 0;
	  branch_target = stub_table->address() + stub->offset() + addend;
	  branch_offset = branch_target - address;
	  gold_assert(!Bits<26>::has_overflow32(branch_offset));
	}
    }

  // At this point, if we still need to switch mode, the instruction
  // must either be a BLX or a BL that can be converted to a BLX.
  if (thumb_bit != 0)
    {
      // Turn BL to BLX.
      gold_assert(may_use_blx && r_type == elfcpp::R_ARM_CALL);
      val = (val & 0xffffff) | 0xfa000000 | ((branch_offset & 2) << 23);
    }

  val = Bits<32>::bit_select32(val, (branch_offset >> 2), 0xffffffUL);
  elfcpp::Swap<32, big_endian>::writeval(wv, val);
  return (Bits<26>::has_overflow32(branch_offset)
	  ? This::STATUS_OVERFLOW
	  : This::STATUS_OKAY);
}

// Relocate THUMB long branches.  This handles relocation types
// R_ARM_THM_CALL, R_ARM_THM_JUMP24 and R_ARM_THM_XPC22.
// If IS_WEAK_UNDEFINED_WITH_PLT is true.  The target symbol is weakly
// undefined and we do not use PLT in this relocation.  In such a case,
// the branch is converted into an NOP.

template<bool big_endian>
typename Arm_relocate_functions<big_endian>::Status
Arm_relocate_functions<big_endian>::thumb_branch_common(
    unsigned int r_type,
    const Relocate_info<32, big_endian>* relinfo,
    unsigned char* view,
    const Sized_symbol<32>* gsym,
    const Arm_relobj<big_endian>* object,
    unsigned int r_sym,
    const Symbol_value<32>* psymval,
    Arm_address address,
    Arm_address thumb_bit,
    bool is_weakly_undefined_without_plt)
{
  typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
  Valtype* wv = reinterpret_cast<Valtype*>(view);
  uint32_t upper_insn = elfcpp::Swap<16, big_endian>::readval(wv);
  uint32_t lower_insn = elfcpp::Swap<16, big_endian>::readval(wv + 1);

  // FIXME: These tests are too loose and do not take THUMB/THUMB-2 difference
  // into account.
  bool is_bl_insn = (lower_insn & 0x1000U) == 0x1000U;
  bool is_blx_insn = (lower_insn & 0x1000U) == 0x0000U;

  // Check that the instruction is valid.
  if (r_type == elfcpp::R_ARM_THM_CALL)
    {
      if (!is_bl_insn && !is_blx_insn)
	return This::STATUS_BAD_RELOC;
    }
  else if (r_type == elfcpp::R_ARM_THM_JUMP24)
    {
      // This cannot be a BLX.
      if (!is_bl_insn)
	return This::STATUS_BAD_RELOC;
    }
  else if (r_type == elfcpp::R_ARM_THM_XPC22)
    {
      // Check for Thumb to Thumb call.
      if (!is_blx_insn)
	return This::STATUS_BAD_RELOC;
      if (thumb_bit != 0)
	{
	  gold_warning(_("%s: Thumb BLX instruction targets "
			 "thumb function '%s'."),
			 object->name().c_str(),
			 (gsym ? gsym->name() : "(local)"));
	  // Convert BLX to BL.
	  lower_insn |= 0x1000U;
	}
    }
  else
    gold_unreachable();

  // A branch to an undefined weak symbol is turned into a jump to
  // the next instruction unless a PLT entry will be created.
  // The jump to the next instruction is optimized as a NOP.W for
  // Thumb-2 enabled architectures.
  const Target_arm<big_endian>* arm_target =
    Target_arm<big_endian>::default_target();
  if (is_weakly_undefined_without_plt)
    {
      gold_assert(!parameters->options().relocatable());
      if (arm_target->may_use_thumb2_nop())
	{
	  elfcpp::Swap<16, big_endian>::writeval(wv, 0xf3af);
	  elfcpp::Swap<16, big_endian>::writeval(wv + 1, 0x8000);
	}
      else
	{
	  elfcpp::Swap<16, big_endian>::writeval(wv, 0xe000);
	  elfcpp::Swap<16, big_endian>::writeval(wv + 1, 0xbf00);
	}
      return This::STATUS_OKAY;
    }

  int32_t addend = This::thumb32_branch_offset(upper_insn, lower_insn);
  Arm_address branch_target = psymval->value(object, addend);

  // For BLX, bit 1 of target address comes from bit 1 of base address.
  bool may_use_blx = arm_target->may_use_v5t_interworking();
  if (thumb_bit == 0 && may_use_blx)
    branch_target = Bits<32>::bit_select32(branch_target, address, 0x2);

  int32_t branch_offset = branch_target - address;

  // We need a stub if the branch offset is too large or if we need
  // to switch mode.
  bool thumb2 = arm_target->using_thumb2();
  if (!parameters->options().relocatable()
      && ((!thumb2 && Bits<23>::has_overflow32(branch_offset))
	  || (thumb2 && Bits<25>::has_overflow32(branch_offset))
	  || ((thumb_bit == 0)
	      && (((r_type == elfcpp::R_ARM_THM_CALL) && !may_use_blx)
		  || r_type == elfcpp::R_ARM_THM_JUMP24))))
    {
      Arm_address unadjusted_branch_target = psymval->value(object, 0);

      Stub_type stub_type =
	Reloc_stub::stub_type_for_reloc(r_type, address,
					unadjusted_branch_target,
					(thumb_bit != 0));

      if (stub_type != arm_stub_none)
	{
	  Stub_table<big_endian>* stub_table =
	    object->stub_table(relinfo->data_shndx);
	  gold_assert(stub_table != NULL);

	  Reloc_stub::Key stub_key(stub_type, gsym, object, r_sym, addend);
	  Reloc_stub* stub = stub_table->find_reloc_stub(stub_key);
	  gold_assert(stub != NULL);
	  thumb_bit = stub->stub_template()->entry_in_thumb_mode() ? 1 : 0;
	  branch_target = stub_table->address() + stub->offset() + addend;
	  if (thumb_bit == 0 && may_use_blx)
	    branch_target = Bits<32>::bit_select32(branch_target, address, 0x2);
	  branch_offset = branch_target - address;
	}
    }

  // At this point, if we still need to switch mode, the instruction
  // must either be a BLX or a BL that can be converted to a BLX.
  if (thumb_bit == 0)
    {
      gold_assert(may_use_blx
		  && (r_type == elfcpp::R_ARM_THM_CALL
		      || r_type == elfcpp::R_ARM_THM_XPC22));
      // Make sure this is a BLX.
      lower_insn &= ~0x1000U;
    }
  else
    {
      // Make sure this is a BL.
      lower_insn |= 0x1000U;
    }

  // For a BLX instruction, make sure that the relocation is rounded up
  // to a word boundary.  This follows the semantics of the instruction
  // which specifies that bit 1 of the target address will come from bit
  // 1 of the base address.
  if ((lower_insn & 0x5000U) == 0x4000U)
    gold_assert((branch_offset & 3) == 0);

  // Put BRANCH_OFFSET back into the insn.  Assumes two's complement.
  // We use the Thumb-2 encoding, which is safe even if dealing with
  // a Thumb-1 instruction by virtue of our overflow check above.  */
  upper_insn = This::thumb32_branch_upper(upper_insn, branch_offset);
  lower_insn = This::thumb32_branch_lower(lower_insn, branch_offset);

  elfcpp::Swap<16, big_endian>::writeval(wv, upper_insn);
  elfcpp::Swap<16, big_endian>::writeval(wv + 1, lower_insn);

  gold_assert(!Bits<25>::has_overflow32(branch_offset));

  return ((thumb2
	   ? Bits<25>::has_overflow32(branch_offset)
	   : Bits<23>::has_overflow32(branch_offset))
	  ? This::STATUS_OVERFLOW
	  : This::STATUS_OKAY);
}

// Relocate THUMB-2 long conditional branches.
// If IS_WEAK_UNDEFINED_WITH_PLT is true.  The target symbol is weakly
// undefined and we do not use PLT in this relocation.  In such a case,
// the branch is converted into an NOP.

template<bool big_endian>
typename Arm_relocate_functions<big_endian>::Status
Arm_relocate_functions<big_endian>::thm_jump19(
    unsigned char* view,
    const Arm_relobj<big_endian>* object,
    const Symbol_value<32>* psymval,
    Arm_address address,
    Arm_address thumb_bit)
{
  typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
  Valtype* wv = reinterpret_cast<Valtype*>(view);
  uint32_t upper_insn = elfcpp::Swap<16, big_endian>::readval(wv);
  uint32_t lower_insn = elfcpp::Swap<16, big_endian>::readval(wv + 1);
  int32_t addend = This::thumb32_cond_branch_offset(upper_insn, lower_insn);

  Arm_address branch_target = psymval->value(object, addend);
  int32_t branch_offset = branch_target - address;

  // ??? Should handle interworking?  GCC might someday try to
  // use this for tail calls.
  // FIXME: We do support thumb entry to PLT yet.
  if (thumb_bit == 0)
    {
      gold_error(_("conditional branch to PLT in THUMB-2 not supported yet."));
      return This::STATUS_BAD_RELOC;
    }

  // Put RELOCATION back into the insn.
  upper_insn = This::thumb32_cond_branch_upper(upper_insn, branch_offset);
  lower_insn = This::thumb32_cond_branch_lower(lower_insn, branch_offset);

  // Put the relocated value back in the object file:
  elfcpp::Swap<16, big_endian>::writeval(wv, upper_insn);
  elfcpp::Swap<16, big_endian>::writeval(wv + 1, lower_insn);

  return (Bits<21>::has_overflow32(branch_offset)
	  ? This::STATUS_OVERFLOW
	  : This::STATUS_OKAY);
}

// Get the GOT section, creating it if necessary.

template<bool big_endian>
Arm_output_data_got<big_endian>*
Target_arm<big_endian>::got_section(Symbol_table* symtab, Layout* layout)
{
  if (this->got_ == NULL)
    {
      gold_assert(symtab != NULL && layout != NULL);

      // When using -z now, we can treat .got as a relro section.
      // Without -z now, it is modified after program startup by lazy
      // PLT relocations.
      bool is_got_relro = parameters->options().now();
      Output_section_order got_order = (is_got_relro
					? ORDER_RELRO_LAST
					: ORDER_DATA);

      // Unlike some targets (.e.g x86), ARM does not use separate .got and
      // .got.plt sections in output.  The output .got section contains both
      // PLT and non-PLT GOT entries.
      this->got_ = new Arm_output_data_got<big_endian>(symtab, layout);

      layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE),
				      this->got_, got_order, is_got_relro);

      // The old GNU linker creates a .got.plt section.  We just
      // create another set of data in the .got section.  Note that we
      // always create a PLT if we create a GOT, although the PLT
      // might be empty.
      this->got_plt_ = new Output_data_space(4, "** GOT PLT");
      layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE),
				      this->got_plt_, got_order, is_got_relro);

      // The first three entries are reserved.
      this->got_plt_->set_current_data_size(3 * 4);

      // Define _GLOBAL_OFFSET_TABLE_ at the start of the PLT.
      symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
				    Symbol_table::PREDEFINED,
				    this->got_plt_,
				    0, 0, elfcpp::STT_OBJECT,
				    elfcpp::STB_LOCAL,
				    elfcpp::STV_HIDDEN, 0,
				    false, false);
    }
  return this->got_;
}

// Get the dynamic reloc section, creating it if necessary.

template<bool big_endian>
typename Target_arm<big_endian>::Reloc_section*
Target_arm<big_endian>::rel_dyn_section(Layout* layout)
{
  if (this->rel_dyn_ == NULL)
    {
      gold_assert(layout != NULL);
      this->rel_dyn_ = new Reloc_section(parameters->options().combreloc());
      layout->add_output_section_data(".rel.dyn", elfcpp::SHT_REL,
				      elfcpp::SHF_ALLOC, this->rel_dyn_,
				      ORDER_DYNAMIC_RELOCS, false);
    }
  return this->rel_dyn_;
}

// Insn_template methods.

// Return byte size of an instruction template.

size_t
Insn_template::size() const
{
  switch (this->type())
    {
    case THUMB16_TYPE:
    case THUMB16_SPECIAL_TYPE:
      return 2;
    case ARM_TYPE:
    case THUMB32_TYPE:
    case DATA_TYPE:
      return 4;
    default:
      gold_unreachable();
    }
}

// Return alignment of an instruction template.

unsigned
Insn_template::alignment() const
{
  switch (this->type())
    {
    case THUMB16_TYPE:
    case THUMB16_SPECIAL_TYPE:
    case THUMB32_TYPE:
      return 2;
    case ARM_TYPE:
    case DATA_TYPE:
      return 4;
    default:
      gold_unreachable();
    }
}

// Stub_template methods.

Stub_template::Stub_template(
    Stub_type type, const Insn_template* insns,
     size_t insn_count)
  : type_(type), insns_(insns), insn_count_(insn_count), alignment_(1),
    entry_in_thumb_mode_(false), relocs_()
{
  off_t offset = 0;

  // Compute byte size and alignment of stub template.
  for (size_t i = 0; i < insn_count; i++)
    {
      unsigned insn_alignment = insns[i].alignment();
      size_t insn_size = insns[i].size();
      gold_assert((offset & (insn_alignment - 1)) == 0);
      this->alignment_ = std::max(this->alignment_, insn_alignment);
      switch (insns[i].type())
	{
	case Insn_template::THUMB16_TYPE:
	case Insn_template::THUMB16_SPECIAL_TYPE:
	  if (i == 0)
	    this->entry_in_thumb_mode_ = true;
	  break;

	case Insn_template::THUMB32_TYPE:
	  if (insns[i].r_type() != elfcpp::R_ARM_NONE)
	    this->relocs_.push_back(Reloc(i, offset));
	  if (i == 0)
	    this->entry_in_thumb_mode_ = true;
	  break;

	case Insn_template::ARM_TYPE:
	  // Handle cases where the target is encoded within the
	  // instruction.
	  if (insns[i].r_type() == elfcpp::R_ARM_JUMP24)
	    this->relocs_.push_back(Reloc(i, offset));
	  break;

	case Insn_template::DATA_TYPE:
	  // Entry point cannot be data.
	  gold_assert(i != 0);
	  this->relocs_.push_back(Reloc(i, offset));
	  break;

	default:
	  gold_unreachable();
	}
      offset += insn_size;
    }
  this->size_ = offset;
}

// Stub methods.

// Template to implement do_write for a specific target endianness.

template<bool big_endian>
void inline
Stub::do_fixed_endian_write(unsigned char* view, section_size_type view_size)
{
  const Stub_template* stub_template = this->stub_template();
  const Insn_template* insns = stub_template->insns();

  // FIXME:  We do not handle BE8 encoding yet.
  unsigned char* pov = view;
  for (size_t i = 0; i < stub_template->insn_count(); i++)
    {
      switch (insns[i].type())
	{
	case Insn_template::THUMB16_TYPE:
	  elfcpp::Swap<16, big_endian>::writeval(pov, insns[i].data() & 0xffff);
	  break;
	case Insn_template::THUMB16_SPECIAL_TYPE:
	  elfcpp::Swap<16, big_endian>::writeval(
	      pov,
	      this->thumb16_special(i));
	  break;
	case Insn_template::THUMB32_TYPE:
	  {
	    uint32_t hi = (insns[i].data() >> 16) & 0xffff;
	    uint32_t lo = insns[i].data() & 0xffff;
	    elfcpp::Swap<16, big_endian>::writeval(pov, hi);
	    elfcpp::Swap<16, big_endian>::writeval(pov + 2, lo);
	  }
	  break;
	case Insn_template::ARM_TYPE:
	case Insn_template::DATA_TYPE:
	  elfcpp::Swap<32, big_endian>::writeval(pov, insns[i].data());
	  break;
	default:
	  gold_unreachable();
	}
      pov += insns[i].size();
    }
  gold_assert(static_cast<section_size_type>(pov - view) == view_size);
}

// Reloc_stub::Key methods.

// Dump a Key as a string for debugging.

std::string
Reloc_stub::Key::name() const
{
  if (this->r_sym_ == invalid_index)
    {
      // Global symbol key name
      // <stub-type>:<symbol name>:<addend>.
      const std::string sym_name = this->u_.symbol->name();
      // We need to print two hex number and two colons.  So just add 100 bytes
      // to the symbol name size.
      size_t len = sym_name.size() + 100;
      char* buffer = new char[len];
      int c = snprintf(buffer, len, "%d:%s:%x", this->stub_type_,
		       sym_name.c_str(), this->addend_);
      gold_assert(c > 0 && c < static_cast<int>(len));
      delete[] buffer;
      return std::string(buffer);
    }
  else
    {
      // local symbol key name
      // <stub-type>:<object>:<r_sym>:<addend>.
      const size_t len = 200;
      char buffer[len];
      int c = snprintf(buffer, len, "%d:%p:%u:%x", this->stub_type_,
		       this->u_.relobj, this->r_sym_, this->addend_);
      gold_assert(c > 0 && c < static_cast<int>(len));
      return std::string(buffer);
    }
}

// Reloc_stub methods.

// Determine the type of stub needed, if any, for a relocation of R_TYPE at
// LOCATION to DESTINATION.
// This code is based on the arm_type_of_stub function in
// bfd/elf32-arm.c.  We have changed the interface a little to keep the Stub
// class simple.

Stub_type
Reloc_stub::stub_type_for_reloc(
   unsigned int r_type,
   Arm_address location,
   Arm_address destination,
   bool target_is_thumb)
{
  Stub_type stub_type = arm_stub_none;

  // This is a bit ugly but we want to avoid using a templated class for
  // big and little endianities.
  bool may_use_blx;
  bool should_force_pic_veneer;
  bool thumb2;
  bool thumb_only;
  if (parameters->target().is_big_endian())
    {
      const Target_arm<true>* big_endian_target =
	Target_arm<true>::default_target();
      may_use_blx = big_endian_target->may_use_v5t_interworking();
      should_force_pic_veneer = big_endian_target->should_force_pic_veneer();
      thumb2 = big_endian_target->using_thumb2();
      thumb_only = big_endian_target->using_thumb_only();
    }
  else
    {
      const Target_arm<false>* little_endian_target =
	Target_arm<false>::default_target();
      may_use_blx = little_endian_target->may_use_v5t_interworking();
      should_force_pic_veneer = little_endian_target->should_force_pic_veneer();
      thumb2 = little_endian_target->using_thumb2();
      thumb_only = little_endian_target->using_thumb_only();
    }

  int64_t branch_offset;
  bool output_is_position_independent =
      parameters->options().output_is_position_independent();
  if (r_type == elfcpp::R_ARM_THM_CALL || r_type == elfcpp::R_ARM_THM_JUMP24)
    {
      // For THUMB BLX instruction, bit 1 of target comes from bit 1 of the
      // base address (instruction address + 4).
      if ((r_type == elfcpp::R_ARM_THM_CALL) && may_use_blx && !target_is_thumb)
	destination = Bits<32>::bit_select32(destination, location, 0x2);
      branch_offset = static_cast<int64_t>(destination) - location;

      // Handle cases where:
      // - this call goes too far (different Thumb/Thumb2 max
      //   distance)
      // - it's a Thumb->Arm call and blx is not available, or it's a
      //   Thumb->Arm branch (not bl). A stub is needed in this case.
      if ((!thumb2
	    && (branch_offset > THM_MAX_FWD_BRANCH_OFFSET
		|| (branch_offset < THM_MAX_BWD_BRANCH_OFFSET)))
	  || (thumb2
	      && (branch_offset > THM2_MAX_FWD_BRANCH_OFFSET
		  || (branch_offset < THM2_MAX_BWD_BRANCH_OFFSET)))
	  || ((!target_is_thumb)
	      && (((r_type == elfcpp::R_ARM_THM_CALL) && !may_use_blx)
		  || (r_type == elfcpp::R_ARM_THM_JUMP24))))
	{
	  if (target_is_thumb)
	    {
	      // Thumb to thumb.
	      if (!thumb_only)
		{
		  stub_type = (output_is_position_independent
			       || should_force_pic_veneer)
		    // PIC stubs.
		    ? ((may_use_blx
			&& (r_type == elfcpp::R_ARM_THM_CALL))
		       // V5T and above. Stub starts with ARM code, so
		       // we must be able to switch mode before
		       // reaching it, which is only possible for 'bl'
		       // (ie R_ARM_THM_CALL relocation).
		       ? arm_stub_long_branch_any_thumb_pic
		       // On V4T, use Thumb code only.
		       : arm_stub_long_branch_v4t_thumb_thumb_pic)

		    // non-PIC stubs.
		    : ((may_use_blx
			&& (r_type == elfcpp::R_ARM_THM_CALL))
		       ? arm_stub_long_branch_any_any // V5T and above.
		       : arm_stub_long_branch_v4t_thumb_thumb);	// V4T.
		}
	      else
		{
		  stub_type = (output_is_position_independent
			       || should_force_pic_veneer)
		    ? arm_stub_long_branch_thumb_only_pic	// PIC stub.
		    : arm_stub_long_branch_thumb_only;	// non-PIC stub.
		}
	    }
	  else
	    {
	      // Thumb to arm.

	      // FIXME: We should check that the input section is from an
	      // object that has interwork enabled.

	      stub_type = (output_is_position_independent
			   || should_force_pic_veneer)
		// PIC stubs.
		? ((may_use_blx
		    && (r_type == elfcpp::R_ARM_THM_CALL))
		   ? arm_stub_long_branch_any_arm_pic	// V5T and above.
		   : arm_stub_long_branch_v4t_thumb_arm_pic)	// V4T.

		// non-PIC stubs.
		: ((may_use_blx
		    && (r_type == elfcpp::R_ARM_THM_CALL))
		   ? arm_stub_long_branch_any_any	// V5T and above.
		   : arm_stub_long_branch_v4t_thumb_arm);	// V4T.

	      // Handle v4t short branches.
	      if ((stub_type == arm_stub_long_branch_v4t_thumb_arm)
		  && (branch_offset <= THM_MAX_FWD_BRANCH_OFFSET)
		  && (branch_offset >= THM_MAX_BWD_BRANCH_OFFSET))
		stub_type = arm_stub_short_branch_v4t_thumb_arm;
	    }
	}
    }
  else if (r_type == elfcpp::R_ARM_CALL
	   || r_type == elfcpp::R_ARM_JUMP24
	   || r_type == elfcpp::R_ARM_PLT32)
    {
      branch_offset = static_cast<int64_t>(destination) - location;
      if (target_is_thumb)
	{
	  // Arm to thumb.

	  // FIXME: We should check that the input section is from an
	  // object that has interwork enabled.

	  // We have an extra 2-bytes reach because of
	  // the mode change (bit 24 (H) of BLX encoding).
	  if (branch_offset > (ARM_MAX_FWD_BRANCH_OFFSET + 2)
	      || (branch_offset < ARM_MAX_BWD_BRANCH_OFFSET)
	      || ((r_type == elfcpp::R_ARM_CALL) && !may_use_blx)
	      || (r_type == elfcpp::R_ARM_JUMP24)
	      || (r_type == elfcpp::R_ARM_PLT32))
	    {
	      stub_type = (output_is_position_independent
			   || should_force_pic_veneer)
		// PIC stubs.
		? (may_use_blx
		   ? arm_stub_long_branch_any_thumb_pic// V5T and above.
		   : arm_stub_long_branch_v4t_arm_thumb_pic)	// V4T stub.

		// non-PIC stubs.
		: (may_use_blx
		   ? arm_stub_long_branch_any_any	// V5T and above.
		   : arm_stub_long_branch_v4t_arm_thumb);	// V4T.
	    }
	}
      else
	{
	  // Arm to arm.
	  if (branch_offset > ARM_MAX_FWD_BRANCH_OFFSET
	      || (branch_offset < ARM_MAX_BWD_BRANCH_OFFSET))
	    {
	      stub_type = (output_is_position_independent
			   || should_force_pic_veneer)
		? arm_stub_long_branch_any_arm_pic	// PIC stubs.
		: arm_stub_long_branch_any_any;		/// non-PIC.
	    }
	}
    }

  return stub_type;
}

// Cortex_a8_stub methods.

// Return the instruction for a THUMB16_SPECIAL_TYPE instruction template.
// I is the position of the instruction template in the stub template.

uint16_t
Cortex_a8_stub::do_thumb16_special(size_t i)
{
  // The only use of this is to copy condition code from a conditional
  // branch being worked around to the corresponding conditional branch in
  // to the stub.
  gold_assert(this->stub_template()->type() == arm_stub_a8_veneer_b_cond
	      && i == 0);
  uint16_t data = this->stub_template()->insns()[i].data();
  gold_assert((data & 0xff00U) == 0xd000U);
  data |= ((this->original_insn_ >> 22) & 0xf) << 8;
  return data;
}

// Stub_factory methods.

Stub_factory::Stub_factory()
{
  // The instruction template sequences are declared as static
  // objects and initialized first time the constructor runs.

  // Arm/Thumb -> Arm/Thumb long branch stub. On V5T and above, use blx
  // to reach the stub if necessary.
  static const Insn_template elf32_arm_stub_long_branch_any_any[] =
    {
      Insn_template::arm_insn(0xe51ff004),	// ldr   pc, [pc, #-4]
      Insn_template::data_word(0, elfcpp::R_ARM_ABS32, 0),
						// dcd   R_ARM_ABS32(X)
    };

  // V4T Arm -> Thumb long branch stub. Used on V4T where blx is not
  // available.
  static const Insn_template elf32_arm_stub_long_branch_v4t_arm_thumb[] =
    {
      Insn_template::arm_insn(0xe59fc000),	// ldr   ip, [pc, #0]
      Insn_template::arm_insn(0xe12fff1c),	// bx    ip
      Insn_template::data_word(0, elfcpp::R_ARM_ABS32, 0),
						// dcd   R_ARM_ABS32(X)
    };

  // Thumb -> Thumb long branch stub. Used on M-profile architectures.
  static const Insn_template elf32_arm_stub_long_branch_thumb_only[] =
    {
      Insn_template::thumb16_insn(0xb401),	// push {r0}
      Insn_template::thumb16_insn(0x4802),	// ldr  r0, [pc, #8]
      Insn_template::thumb16_insn(0x4684),	// mov  ip, r0
      Insn_template::thumb16_insn(0xbc01),	// pop  {r0}
      Insn_template::thumb16_insn(0x4760),	// bx   ip
      Insn_template::thumb16_insn(0xbf00),	// nop
      Insn_template::data_word(0, elfcpp::R_ARM_ABS32, 0),
						// dcd  R_ARM_ABS32(X)
    };

  // V4T Thumb -> Thumb long branch stub. Using the stack is not
  // allowed.
  static const Insn_template elf32_arm_stub_long_branch_v4t_thumb_thumb[] =
    {
      Insn_template::thumb16_insn(0x4778),	// bx   pc
      Insn_template::thumb16_insn(0x46c0),	// nop
      Insn_template::arm_insn(0xe59fc000),	// ldr  ip, [pc, #0]
      Insn_template::arm_insn(0xe12fff1c),	// bx   ip
      Insn_template::data_word(0, elfcpp::R_ARM_ABS32, 0),
						// dcd  R_ARM_ABS32(X)
    };

  // V4T Thumb -> ARM long branch stub. Used on V4T where blx is not
  // available.
  static const Insn_template elf32_arm_stub_long_branch_v4t_thumb_arm[] =
    {
      Insn_template::thumb16_insn(0x4778),	// bx   pc
      Insn_template::thumb16_insn(0x46c0),	// nop
      Insn_template::arm_insn(0xe51ff004),	// ldr   pc, [pc, #-4]
      Insn_template::data_word(0, elfcpp::R_ARM_ABS32, 0),
						// dcd   R_ARM_ABS32(X)
    };

  // V4T Thumb -> ARM short branch stub. Shorter variant of the above
  // one, when the destination is close enough.
  static const Insn_template elf32_arm_stub_short_branch_v4t_thumb_arm[] =
    {
      Insn_template::thumb16_insn(0x4778),		// bx   pc
      Insn_template::thumb16_insn(0x46c0),		// nop
      Insn_template::arm_rel_insn(0xea000000, -8),	// b    (X-8)
    };

  // ARM/Thumb -> ARM long branch stub, PIC.  On V5T and above, use
  // blx to reach the stub if necessary.
  static const Insn_template elf32_arm_stub_long_branch_any_arm_pic[] =
    {
      Insn_template::arm_insn(0xe59fc000),	// ldr   r12, [pc]
      Insn_template::arm_insn(0xe08ff00c),	// add   pc, pc, ip
      Insn_template::data_word(0, elfcpp::R_ARM_REL32, -4),
						// dcd   R_ARM_REL32(X-4)
    };

  // ARM/Thumb -> Thumb long branch stub, PIC.  On V5T and above, use
  // blx to reach the stub if necessary.  We can not add into pc;
  // it is not guaranteed to mode switch (different in ARMv6 and
  // ARMv7).
  static const Insn_template elf32_arm_stub_long_branch_any_thumb_pic[] =
    {
      Insn_template::arm_insn(0xe59fc004),	// ldr   r12, [pc, #4]
      Insn_template::arm_insn(0xe08fc00c),	// add   ip, pc, ip
      Insn_template::arm_insn(0xe12fff1c),	// bx    ip
      Insn_template::data_word(0, elfcpp::R_ARM_REL32, 0),
						// dcd   R_ARM_REL32(X)
    };

  // V4T ARM -> ARM long branch stub, PIC.
  static const Insn_template elf32_arm_stub_long_branch_v4t_arm_thumb_pic[] =
    {
      Insn_template::arm_insn(0xe59fc004),	// ldr   ip, [pc, #4]
      Insn_template::arm_insn(0xe08fc00c),	// add   ip, pc, ip
      Insn_template::arm_insn(0xe12fff1c),	// bx    ip
      Insn_template::data_word(0, elfcpp::R_ARM_REL32, 0),
						// dcd   R_ARM_REL32(X)
    };

  // V4T Thumb -> ARM long branch stub, PIC.
  static const Insn_template elf32_arm_stub_long_branch_v4t_thumb_arm_pic[] =
    {
      Insn_template::thumb16_insn(0x4778),	// bx   pc
      Insn_template::thumb16_insn(0x46c0),	// nop
      Insn_template::arm_insn(0xe59fc000),	// ldr  ip, [pc, #0]
      Insn_template::arm_insn(0xe08cf00f),	// add  pc, ip, pc
      Insn_template::data_word(0, elfcpp::R_ARM_REL32, -4),
						// dcd  R_ARM_REL32(X)
    };

  // Thumb -> Thumb long branch stub, PIC. Used on M-profile
  // architectures.
  static const Insn_template elf32_arm_stub_long_branch_thumb_only_pic[] =
    {
      Insn_template::thumb16_insn(0xb401),	// push {r0}
      Insn_template::thumb16_insn(0x4802),	// ldr  r0, [pc, #8]
      Insn_template::thumb16_insn(0x46fc),	// mov  ip, pc
      Insn_template::thumb16_insn(0x4484),	// add  ip, r0
      Insn_template::thumb16_insn(0xbc01),	// pop  {r0}
      Insn_template::thumb16_insn(0x4760),	// bx   ip
      Insn_template::data_word(0, elfcpp::R_ARM_REL32, 4),
						// dcd  R_ARM_REL32(X)
    };

  // V4T Thumb -> Thumb long branch stub, PIC. Using the stack is not
  // allowed.
  static const Insn_template elf32_arm_stub_long_branch_v4t_thumb_thumb_pic[] =
    {
      Insn_template::thumb16_insn(0x4778),	// bx   pc
      Insn_template::thumb16_insn(0x46c0),	// nop
      Insn_template::arm_insn(0xe59fc004),	// ldr  ip, [pc, #4]
      Insn_template::arm_insn(0xe08fc00c),	// add   ip, pc, ip
      Insn_template::arm_insn(0xe12fff1c),	// bx   ip
      Insn_template::data_word(0, elfcpp::R_ARM_REL32, 0),
						// dcd  R_ARM_REL32(X)
    };

  // Cortex-A8 erratum-workaround stubs.

  // Stub used for conditional branches (which may be beyond +/-1MB away,
  // so we can't use a conditional branch to reach this stub).

  // original code:
  //
  // 	b<cond> X
  // after:
  //
  static const Insn_template elf32_arm_stub_a8_veneer_b_cond[] =
    {
      Insn_template::thumb16_bcond_insn(0xd001),	//	b<cond>.n true
      Insn_template::thumb32_b_insn(0xf000b800, -4),	//	b.w after
      Insn_template::thumb32_b_insn(0xf000b800, -4)	// true:
							//	b.w X
    };

  // Stub used for b.w and bl.w instructions.

  static const Insn_template elf32_arm_stub_a8_veneer_b[] =
    {
      Insn_template::thumb32_b_insn(0xf000b800, -4)	// b.w dest
    };

  static const Insn_template elf32_arm_stub_a8_veneer_bl[] =
    {
      Insn_template::thumb32_b_insn(0xf000b800, -4)	// b.w dest
    };

  // Stub used for Thumb-2 blx.w instructions.  We modified the original blx.w
  // instruction (which switches to ARM mode) to point to this stub.  Jump to
  // the real destination using an ARM-mode branch.
  static const Insn_template elf32_arm_stub_a8_veneer_blx[] =
    {
      Insn_template::arm_rel_insn(0xea000000, -8)	// b dest
    };

  // Stub used to provide an interworking for R_ARM_V4BX relocation
  // (bx r[n] instruction).
  static const Insn_template elf32_arm_stub_v4_veneer_bx[] =
    {
      Insn_template::arm_insn(0xe3100001),		// tst   r<n>, #1
      Insn_template::arm_insn(0x01a0f000),		// moveq pc, r<n>
      Insn_template::arm_insn(0xe12fff10)		// bx    r<n>
    };

  // Fill in the stub template look-up table.  Stub templates are constructed
  // per instance of Stub_factory for fast look-up without locking
  // in a thread-enabled environment.

  this->stub_templates_[arm_stub_none] =
    new Stub_template(arm_stub_none, NULL, 0);

#define DEF_STUB(x)	\
  do \
    { \
      size_t array_size \
	= sizeof(elf32_arm_stub_##x) / sizeof(elf32_arm_stub_##x[0]); \
      Stub_type type = arm_stub_##x; \
      this->stub_templates_[type] = \
	new Stub_template(type, elf32_arm_stub_##x, array_size); \
    } \
  while (0);

  DEF_STUBS
#undef DEF_STUB
}

// Stub_table methods.

// Remove all Cortex-A8 stub.

template<bool big_endian>
void
Stub_table<big_endian>::remove_all_cortex_a8_stubs()
{
  for (Cortex_a8_stub_list::iterator p = this->cortex_a8_stubs_.begin();
       p != this->cortex_a8_stubs_.end();
       ++p)
    delete p->second;
  this->cortex_a8_stubs_.clear();
}

// Relocate one stub.  This is a helper for Stub_table::relocate_stubs().

template<bool big_endian>
void
Stub_table<big_endian>::relocate_stub(
    Stub* stub,
    const Relocate_info<32, big_endian>* relinfo,
    Target_arm<big_endian>* arm_target,
    Output_section* output_section,
    unsigned char* view,
    Arm_address address,
    section_size_type view_size)
{
  const Stub_template* stub_template = stub->stub_template();
  if (stub_template->reloc_count() != 0)
    {
      // Adjust view to cover the stub only.
      section_size_type offset = stub->offset();
      section_size_type stub_size = stub_template->size();
      gold_assert(offset + stub_size <= view_size);

      arm_target->relocate_stub(stub, relinfo, output_section, view + offset,
				address + offset, stub_size);
    }
}

// Relocate all stubs in this stub table.

template<bool big_endian>
void
Stub_table<big_endian>::relocate_stubs(
    const Relocate_info<32, big_endian>* relinfo,
    Target_arm<big_endian>* arm_target,
    Output_section* output_section,
    unsigned char* view,
    Arm_address address,
    section_size_type view_size)
{
  // If we are passed a view bigger than the stub table's.  we need to
  // adjust the view.
  gold_assert(address == this->address()
	      && (view_size
		  == static_cast<section_size_type>(this->data_size())));

  // Relocate all relocation stubs.
  for (typename Reloc_stub_map::const_iterator p = this->reloc_stubs_.begin();
      p != this->reloc_stubs_.end();
      ++p)
    this->relocate_stub(p->second, relinfo, arm_target, output_section, view,
			address, view_size);

  // Relocate all Cortex-A8 stubs.
  for (Cortex_a8_stub_list::iterator p = this->cortex_a8_stubs_.begin();
       p != this->cortex_a8_stubs_.end();
       ++p)
    this->relocate_stub(p->second, relinfo, arm_target, output_section, view,
			address, view_size);

  // Relocate all ARM V4BX stubs.
  for (Arm_v4bx_stub_list::iterator p = this->arm_v4bx_stubs_.begin();
       p != this->arm_v4bx_stubs_.end();
       ++p)
    {
      if (*p != NULL)
	this->relocate_stub(*p, relinfo, arm_target, output_section, view,
			    address, view_size);
    }
}

// Write out the stubs to file.

template<bool big_endian>
void
Stub_table<big_endian>::do_write(Output_file* of)
{
  off_t offset = this->offset();
  const section_size_type oview_size =
    convert_to_section_size_type(this->data_size());
  unsigned char* const oview = of->get_output_view(offset, oview_size);

  // Write relocation stubs.
  for (typename Reloc_stub_map::const_iterator p = this->reloc_stubs_.begin();
      p != this->reloc_stubs_.end();
      ++p)
    {
      Reloc_stub* stub = p->second;
      Arm_address address = this->address() + stub->offset();
      gold_assert(address
		  == align_address(address,
				   stub->stub_template()->alignment()));
      stub->write(oview + stub->offset(), stub->stub_template()->size(),
		  big_endian);
    }

  // Write Cortex-A8 stubs.
  for (Cortex_a8_stub_list::const_iterator p = this->cortex_a8_stubs_.begin();
       p != this->cortex_a8_stubs_.end();
       ++p)
    {
      Cortex_a8_stub* stub = p->second;
      Arm_address address = this->address() + stub->offset();
      gold_assert(address
		  == align_address(address,
				   stub->stub_template()->alignment()));
      stub->write(oview + stub->offset(), stub->stub_template()->size(),
		  big_endian);
    }

  // Write ARM V4BX relocation stubs.
  for (Arm_v4bx_stub_list::const_iterator p = this->arm_v4bx_stubs_.begin();
       p != this->arm_v4bx_stubs_.end();
       ++p)
    {
      if (*p == NULL)
	continue;

      Arm_address address = this->address() + (*p)->offset();
      gold_assert(address
		  == align_address(address,
				   (*p)->stub_template()->alignment()));
      (*p)->write(oview + (*p)->offset(), (*p)->stub_template()->size(),
		  big_endian);
    }

  of->write_output_view(this->offset(), oview_size, oview);
}

// Update the data size and address alignment of the stub table at the end
// of a relaxation pass.   Return true if either the data size or the
// alignment changed in this relaxation pass.

template<bool big_endian>
bool
Stub_table<big_endian>::update_data_size_and_addralign()
{
  // Go over all stubs in table to compute data size and address alignment.
  off_t size = this->reloc_stubs_size_;
  unsigned addralign = this->reloc_stubs_addralign_;

  for (Cortex_a8_stub_list::const_iterator p = this->cortex_a8_stubs_.begin();
       p != this->cortex_a8_stubs_.end();
       ++p)
    {
      const Stub_template* stub_template = p->second->stub_template();
      addralign = std::max(addralign, stub_template->alignment());
      size = (align_address(size, stub_template->alignment())
	      + stub_template->size());
    }

  for (Arm_v4bx_stub_list::const_iterator p = this->arm_v4bx_stubs_.begin();
       p != this->arm_v4bx_stubs_.end();
       ++p)
    {
      if (*p == NULL)
	continue;

      const Stub_template* stub_template = (*p)->stub_template();
      addralign = std::max(addralign, stub_template->alignment());
      size = (align_address(size, stub_template->alignment())
	      + stub_template->size());
    }

  // Check if either data size or alignment changed in this pass.
  // Update prev_data_size_ and prev_addralign_.  These will be used
  // as the current data size and address alignment for the next pass.
  bool changed = size != this->prev_data_size_;
  this->prev_data_size_ = size;

  if (addralign != this->prev_addralign_)
    changed = true;
  this->prev_addralign_ = addralign;

  return changed;
}

// Finalize the stubs.  This sets the offsets of the stubs within the stub
// table.  It also marks all input sections needing Cortex-A8 workaround.

template<bool big_endian>
void
Stub_table<big_endian>::finalize_stubs()
{
  off_t off = this->reloc_stubs_size_;
  for (Cortex_a8_stub_list::const_iterator p = this->cortex_a8_stubs_.begin();
       p != this->cortex_a8_stubs_.end();
       ++p)
    {
      Cortex_a8_stub* stub = p->second;
      const Stub_template* stub_template = stub->stub_template();
      uint64_t stub_addralign = stub_template->alignment();
      off = align_address(off, stub_addralign);
      stub->set_offset(off);
      off += stub_template->size();

      // Mark input section so that we can determine later if a code section
      // needs the Cortex-A8 workaround quickly.
      Arm_relobj<big_endian>* arm_relobj =
	Arm_relobj<big_endian>::as_arm_relobj(stub->relobj());
      arm_relobj->mark_section_for_cortex_a8_workaround(stub->shndx());
    }

  for (Arm_v4bx_stub_list::const_iterator p = this->arm_v4bx_stubs_.begin();
      p != this->arm_v4bx_stubs_.end();
      ++p)
    {
      if (*p == NULL)
	continue;

      const Stub_template* stub_template = (*p)->stub_template();
      uint64_t stub_addralign = stub_template->alignment();
      off = align_address(off, stub_addralign);
      (*p)->set_offset(off);
      off += stub_template->size();
    }

  gold_assert(off <= this->prev_data_size_);
}

// Apply Cortex-A8 workaround to an address range between VIEW_ADDRESS
// and VIEW_ADDRESS + VIEW_SIZE - 1.  VIEW points to the mapped address
// of the address range seen by the linker.

template<bool big_endian>
void
Stub_table<big_endian>::apply_cortex_a8_workaround_to_address_range(
    Target_arm<big_endian>* arm_target,
    unsigned char* view,
    Arm_address view_address,
    section_size_type view_size)
{
  // Cortex-A8 stubs are sorted by addresses of branches being fixed up.
  for (Cortex_a8_stub_list::const_iterator p =
	 this->cortex_a8_stubs_.lower_bound(view_address);
       ((p != this->cortex_a8_stubs_.end())
	&& (p->first < (view_address + view_size)));
       ++p)
    {
      // We do not store the THUMB bit in the LSB of either the branch address
      // or the stub offset.  There is no need to strip the LSB.
      Arm_address branch_address = p->first;
      const Cortex_a8_stub* stub = p->second;
      Arm_address stub_address = this->address() + stub->offset();

      // Offset of the branch instruction relative to this view.
      section_size_type offset =
	convert_to_section_size_type(branch_address - view_address);
      gold_assert((offset + 4) <= view_size);

      arm_target->apply_cortex_a8_workaround(stub, stub_address,
					     view + offset, branch_address);
    }
}

// Arm_input_section methods.

// Initialize an Arm_input_section.

template<bool big_endian>
void
Arm_input_section<big_endian>::init()
{
  Relobj* relobj = this->relobj();
  unsigned int shndx = this->shndx();

  // We have to cache original size, alignment and contents to avoid locking
  // the original file.
  this->original_addralign_ =
    convert_types<uint32_t, uint64_t>(relobj->section_addralign(shndx));

  // This is not efficient but we expect only a small number of relaxed
  // input sections for stubs.
  section_size_type section_size;
  const unsigned char* section_contents =
    relobj->section_contents(shndx, &section_size, false);
  this->original_size_ =
    convert_types<uint32_t, uint64_t>(relobj->section_size(shndx));

  gold_assert(this->original_contents_ == NULL);
  this->original_contents_ = new unsigned char[section_size];
  memcpy(this->original_contents_, section_contents, section_size);

  // We want to make this look like the original input section after
  // output sections are finalized.
  Output_section* os = relobj->output_section(shndx);
  off_t offset = relobj->output_section_offset(shndx);
  gold_assert(os != NULL && !relobj->is_output_section_offset_invalid(shndx));
  this->set_address(os->address() + offset);
  this->set_file_offset(os->offset() + offset);

  this->set_current_data_size(this->original_size_);
  this->finalize_data_size();
}

template<bool big_endian>
void
Arm_input_section<big_endian>::do_write(Output_file* of)
{
  // We have to write out the original section content.
  gold_assert(this->original_contents_ != NULL);
  of->write(this->offset(), this->original_contents_,
	    this->original_size_);

  // If this owns a stub table and it is not empty, write it.
  if (this->is_stub_table_owner() && !this->stub_table_->empty())
    this->stub_table_->write(of);
}

// Finalize data size.

template<bool big_endian>
void
Arm_input_section<big_endian>::set_final_data_size()
{
  off_t off = convert_types<off_t, uint64_t>(this->original_size_);

  if (this->is_stub_table_owner())
    {
      this->stub_table_->finalize_data_size();
      off = align_address(off, this->stub_table_->addralign());
      off += this->stub_table_->data_size();
    }
  this->set_data_size(off);
}

// Reset address and file offset.

template<bool big_endian>
void
Arm_input_section<big_endian>::do_reset_address_and_file_offset()
{
  // Size of the original input section contents.
  off_t off = convert_types<off_t, uint64_t>(this->original_size_);

  // If this is a stub table owner, account for the stub table size.
  if (this->is_stub_table_owner())
    {
      Stub_table<big_endian>* stub_table = this->stub_table_;

      // Reset the stub table's address and file offset.  The
      // current data size for child will be updated after that.
      stub_table_->reset_address_and_file_offset();
      off = align_address(off, stub_table_->addralign());
      off += stub_table->current_data_size();
    }

  this->set_current_data_size(off);
}

// Arm_exidx_cantunwind methods.

// Write this to Output file OF for a fixed endianness.

template<bool big_endian>
void
Arm_exidx_cantunwind::do_fixed_endian_write(Output_file* of)
{
  off_t offset = this->offset();
  const section_size_type oview_size = 8;
  unsigned char* const oview = of->get_output_view(offset, oview_size);

  Output_section* os = this->relobj_->output_section(this->shndx_);
  gold_assert(os != NULL);

  Arm_relobj<big_endian>* arm_relobj =
    Arm_relobj<big_endian>::as_arm_relobj(this->relobj_);
  Arm_address output_offset =
    arm_relobj->get_output_section_offset(this->shndx_);
  Arm_address section_start;
  section_size_type section_size;

  // Find out the end of the text section referred by this.
  if (output_offset != Arm_relobj<big_endian>::invalid_address)
    {
      section_start = os->address() + output_offset;
      const Arm_exidx_input_section* exidx_input_section =
	arm_relobj->exidx_input_section_by_link(this->shndx_);
      gold_assert(exidx_input_section != NULL);
      section_size =
	convert_to_section_size_type(exidx_input_section->text_size());
    }
  else
    {
      // Currently this only happens for a relaxed section.
      const Output_relaxed_input_section* poris =
	os->find_relaxed_input_section(this->relobj_, this->shndx_);
      gold_assert(poris != NULL);
      section_start = poris->address();
      section_size = convert_to_section_size_type(poris->data_size());
    }

  // We always append this to the end of an EXIDX section.
  Arm_address output_address = section_start + section_size;

  // Write out the entry.  The first word either points to the beginning
  // or after the end of a text section.  The second word is the special
  // EXIDX_CANTUNWIND value.
  uint32_t prel31_offset = output_address - this->address();
  if (Bits<31>::has_overflow32(offset))
    gold_error(_("PREL31 overflow in EXIDX_CANTUNWIND entry"));
  elfcpp::Swap_unaligned<32, big_endian>::writeval(oview,
						   prel31_offset & 0x7fffffffU);
  elfcpp::Swap_unaligned<32, big_endian>::writeval(oview + 4,
						   elfcpp::EXIDX_CANTUNWIND);

  of->write_output_view(this->offset(), oview_size, oview);
}

// Arm_exidx_merged_section methods.

// Constructor for Arm_exidx_merged_section.
// EXIDX_INPUT_SECTION points to the unmodified EXIDX input section.
// SECTION_OFFSET_MAP points to a section offset map describing how
// parts of the input section are mapped to output.  DELETED_BYTES is
// the number of bytes deleted from the EXIDX input section.

Arm_exidx_merged_section::Arm_exidx_merged_section(
    const Arm_exidx_input_section& exidx_input_section,
    const Arm_exidx_section_offset_map& section_offset_map,
    uint32_t deleted_bytes)
  : Output_relaxed_input_section(exidx_input_section.relobj(),
				 exidx_input_section.shndx(),
				 exidx_input_section.addralign()),
    exidx_input_section_(exidx_input_section),
    section_offset_map_(section_offset_map)
{
  // If we retain or discard the whole EXIDX input section,  we would
  // not be here.
  gold_assert(deleted_bytes != 0
	      && deleted_bytes != this->exidx_input_section_.size());

  // Fix size here so that we do not need to implement set_final_data_size.
  uint32_t size = exidx_input_section.size() - deleted_bytes;
  this->set_data_size(size);
  this->fix_data_size();

  // Allocate buffer for section contents and build contents.
  this->section_contents_ = new unsigned char[size];
}

// Build the contents of a merged EXIDX output section.

void
Arm_exidx_merged_section::build_contents(
    const unsigned char* original_contents,
    section_size_type original_size)
{
  // Go over spans of input offsets and write only those that are not
  // discarded.
  section_offset_type in_start = 0;
  section_offset_type out_start = 0;
  section_offset_type in_max =
    convert_types<section_offset_type>(original_size);
  section_offset_type out_max =
    convert_types<section_offset_type>(this->data_size());
  for (Arm_exidx_section_offset_map::const_iterator p =
	this->section_offset_map_.begin();
      p != this->section_offset_map_.end();
      ++p)
    {
      section_offset_type in_end = p->first;
      gold_assert(in_end >= in_start);
      section_offset_type out_end = p->second;
      size_t in_chunk_size = convert_types<size_t>(in_end - in_start + 1);
      if (out_end != -1)
	{
	  size_t out_chunk_size =
	    convert_types<size_t>(out_end - out_start + 1);

	  gold_assert(out_chunk_size == in_chunk_size
		      && in_end < in_max && out_end < out_max);

	  memcpy(this->section_contents_ + out_start,
		 original_contents + in_start,
		 out_chunk_size);
	  out_start += out_chunk_size;
	}
      in_start += in_chunk_size;
    }
}

// Given an input OBJECT, an input section index SHNDX within that
// object, and an OFFSET relative to the start of that input
// section, return whether or not the corresponding offset within
// the output section is known.  If this function returns true, it
// sets *POUTPUT to the output offset.  The value -1 indicates that
// this input offset is being discarded.

bool
Arm_exidx_merged_section::do_output_offset(
    const Relobj* relobj,
    unsigned int shndx,
    section_offset_type offset,
    section_offset_type* poutput) const
{
  // We only handle offsets for the original EXIDX input section.
  if (relobj != this->exidx_input_section_.relobj()
      || shndx != this->exidx_input_section_.shndx())
    return false;

  section_offset_type section_size =
    convert_types<section_offset_type>(this->exidx_input_section_.size());
  if (offset < 0 || offset >= section_size)
    // Input offset is out of valid range.
    *poutput = -1;
  else
    {
      // We need to look up the section offset map to determine the output
      // offset.  Find the reference point in map that is first offset
      // bigger than or equal to this offset.
      Arm_exidx_section_offset_map::const_iterator p =
	this->section_offset_map_.lower_bound(offset);

      // The section offset maps are build such that this should not happen if
      // input offset is in the valid range.
      gold_assert(p != this->section_offset_map_.end());

      // We need to check if this is dropped.
     section_offset_type ref = p->first;
     section_offset_type mapped_ref = p->second;

      if (mapped_ref != Arm_exidx_input_section::invalid_offset)
	// Offset is present in output.
	*poutput = mapped_ref + (offset - ref);
      else
	// Offset is discarded owing to EXIDX entry merging.
	*poutput = -1;
    }

  return true;
}

// Write this to output file OF.

void
Arm_exidx_merged_section::do_write(Output_file* of)
{
  off_t offset = this->offset();
  const section_size_type oview_size = this->data_size();
  unsigned char* const oview = of->get_output_view(offset, oview_size);

  Output_section* os = this->relobj()->output_section(this->shndx());
  gold_assert(os != NULL);

  memcpy(oview, this->section_contents_, oview_size);
  of->write_output_view(this->offset(), oview_size, oview);
}

// Arm_exidx_fixup methods.

// Append an EXIDX_CANTUNWIND in the current output section if the last entry
// is not an EXIDX_CANTUNWIND entry already.  The new EXIDX_CANTUNWIND entry
// points to the end of the last seen EXIDX section.

void
Arm_exidx_fixup::add_exidx_cantunwind_as_needed()
{
  if (this->last_unwind_type_ != UT_EXIDX_CANTUNWIND
      && this->last_input_section_ != NULL)
    {
      Relobj* relobj = this->last_input_section_->relobj();
      unsigned int text_shndx = this->last_input_section_->link();
      Arm_exidx_cantunwind* cantunwind =
	new Arm_exidx_cantunwind(relobj, text_shndx);
      this->exidx_output_section_->add_output_section_data(cantunwind);
      this->last_unwind_type_ = UT_EXIDX_CANTUNWIND;
    }
}

// Process an EXIDX section entry in input.  Return whether this entry
// can be deleted in the output.  SECOND_WORD in the second word of the
// EXIDX entry.

bool
Arm_exidx_fixup::process_exidx_entry(uint32_t second_word)
{
  bool delete_entry;
  if (second_word == elfcpp::EXIDX_CANTUNWIND)
    {
      // Merge if previous entry is also an EXIDX_CANTUNWIND.
      delete_entry = this->last_unwind_type_ == UT_EXIDX_CANTUNWIND;
      this->last_unwind_type_ = UT_EXIDX_CANTUNWIND;
    }
  else if ((second_word & 0x80000000) != 0)
    {
      // Inlined unwinding data.  Merge if equal to previous.
      delete_entry = (merge_exidx_entries_
		      && this->last_unwind_type_ == UT_INLINED_ENTRY
		      && this->last_inlined_entry_ == second_word);
      this->last_unwind_type_ = UT_INLINED_ENTRY;
      this->last_inlined_entry_ = second_word;
    }
  else
    {
      // Normal table entry.  In theory we could merge these too,
      // but duplicate entries are likely to be much less common.
      delete_entry = false;
      this->last_unwind_type_ = UT_NORMAL_ENTRY;
    }
  return delete_entry;
}

// Update the current section offset map during EXIDX section fix-up.
// If there is no map, create one.  INPUT_OFFSET is the offset of a
// reference point, DELETED_BYTES is the number of deleted by in the
// section so far.  If DELETE_ENTRY is true, the reference point and
// all offsets after the previous reference point are discarded.

void
Arm_exidx_fixup::update_offset_map(
    section_offset_type input_offset,
    section_size_type deleted_bytes,
    bool delete_entry)
{
  if (this->section_offset_map_ == NULL)
    this->section_offset_map_ = new Arm_exidx_section_offset_map();
  section_offset_type output_offset;
  if (delete_entry)
    output_offset = Arm_exidx_input_section::invalid_offset;
  else
    output_offset = input_offset - deleted_bytes;
  (*this->section_offset_map_)[input_offset] = output_offset;
}

// Process EXIDX_INPUT_SECTION for EXIDX entry merging.  Return the number of
// bytes deleted.  SECTION_CONTENTS points to the contents of the EXIDX
// section and SECTION_SIZE is the number of bytes pointed by SECTION_CONTENTS.
// If some entries are merged, also store a pointer to a newly created
// Arm_exidx_section_offset_map object in *PSECTION_OFFSET_MAP.  The caller
// owns the map and is responsible for releasing it after use.

template<bool big_endian>
uint32_t
Arm_exidx_fixup::process_exidx_section(
    const Arm_exidx_input_section* exidx_input_section,
    const unsigned char* section_contents,
    section_size_type section_size,
    Arm_exidx_section_offset_map** psection_offset_map)
{
  Relobj* relobj = exidx_input_section->relobj();
  unsigned shndx = exidx_input_section->shndx();

  if ((section_size % 8) != 0)
    {
      // Something is wrong with this section.  Better not touch it.
      gold_error(_("uneven .ARM.exidx section size in %s section %u"),
		 relobj->name().c_str(), shndx);
      this->last_input_section_ = exidx_input_section;
      this->last_unwind_type_ = UT_NONE;
      return 0;
    }

  uint32_t deleted_bytes = 0;
  bool prev_delete_entry = false;
  gold_assert(this->section_offset_map_ == NULL);

  for (section_size_type i = 0; i < section_size; i += 8)
    {
      typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
      const Valtype* wv =
	  reinterpret_cast<const Valtype*>(section_contents + i + 4);
      uint32_t second_word = elfcpp::Swap<32, big_endian>::readval(wv);

      bool delete_entry = this->process_exidx_entry(second_word);

      // Entry deletion causes changes in output offsets.  We use a std::map
      // to record these.  And entry (x, y) means input offset x
      // is mapped to output offset y.  If y is invalid_offset, then x is
      // dropped in the output.  Because of the way std::map::lower_bound
      // works, we record the last offset in a region w.r.t to keeping or
      // dropping.  If there is no entry (x0, y0) for an input offset x0,
      // the output offset y0 of it is determined by the output offset y1 of
      // the smallest input offset x1 > x0 that there is an (x1, y1) entry
      // in the map.  If y1 is not -1, then y0 = y1 + x0 - x1.  Otherwise, y1
      // y0 is also -1.
      if (delete_entry != prev_delete_entry && i != 0)
	this->update_offset_map(i - 1, deleted_bytes, prev_delete_entry);

      // Update total deleted bytes for this entry.
      if (delete_entry)
	deleted_bytes += 8;

      prev_delete_entry = delete_entry;
    }

  // If section offset map is not NULL, make an entry for the end of
  // section.
  if (this->section_offset_map_ != NULL)
    update_offset_map(section_size - 1, deleted_bytes, prev_delete_entry);

  *psection_offset_map = this->section_offset_map_;
  this->section_offset_map_ = NULL;
  this->last_input_section_ = exidx_input_section;

  // Set the first output text section so that we can link the EXIDX output
  // section to it.  Ignore any EXIDX input section that is completely merged.
  if (this->first_output_text_section_ == NULL
      && deleted_bytes != section_size)
    {
      unsigned int link = exidx_input_section->link();
      Output_section* os = relobj->output_section(link);
      gold_assert(os != NULL);
      this->first_output_text_section_ = os;
    }

  return deleted_bytes;
}

// Arm_output_section methods.

// Create a stub group for input sections from BEGIN to END.  OWNER
// points to the input section to be the owner a new stub table.

template<bool big_endian>
void
Arm_output_section<big_endian>::create_stub_group(
  Input_section_list::const_iterator begin,
  Input_section_list::const_iterator end,
  Input_section_list::const_iterator owner,
  Target_arm<big_endian>* target,
  std::vector<Output_relaxed_input_section*>* new_relaxed_sections,
  const Task* task)
{
  // We use a different kind of relaxed section in an EXIDX section.
  // The static casting from Output_relaxed_input_section to
  // Arm_input_section is invalid in an EXIDX section.  We are okay
  // because we should not be calling this for an EXIDX section.
  gold_assert(this->type() != elfcpp::SHT_ARM_EXIDX);

  // Currently we convert ordinary input sections into relaxed sections only
  // at this point but we may want to support creating relaxed input section
  // very early.  So we check here to see if owner is already a relaxed
  // section.

  Arm_input_section<big_endian>* arm_input_section;
  if (owner->is_relaxed_input_section())
    {
      arm_input_section =
	Arm_input_section<big_endian>::as_arm_input_section(
	  owner->relaxed_input_section());
    }
  else
    {
      gold_assert(owner->is_input_section());
      // Create a new relaxed input section.  We need to lock the original
      // file.
      Task_lock_obj<Object> tl(task, owner->relobj());
      arm_input_section =
	target->new_arm_input_section(owner->relobj(), owner->shndx());
      new_relaxed_sections->push_back(arm_input_section);
    }

  // Create a stub table.
  Stub_table<big_endian>* stub_table =
    target->new_stub_table(arm_input_section);

  arm_input_section->set_stub_table(stub_table);

  Input_section_list::const_iterator p = begin;
  Input_section_list::const_iterator prev_p;

  // Look for input sections or relaxed input sections in [begin ... end].
  do
    {
      if (p->is_input_section() || p->is_relaxed_input_section())
	{
	  // The stub table information for input sections live
	  // in their objects.
	  Arm_relobj<big_endian>* arm_relobj =
	    Arm_relobj<big_endian>::as_arm_relobj(p->relobj());
	  arm_relobj->set_stub_table(p->shndx(), stub_table);
	}
      prev_p = p++;
    }
  while (prev_p != end);
}

// Group input sections for stub generation.  GROUP_SIZE is roughly the limit
// of stub groups.  We grow a stub group by adding input section until the
// size is just below GROUP_SIZE.  The last input section will be converted
// into a stub table.  If STUB_ALWAYS_AFTER_BRANCH is false, we also add
// input section after the stub table, effectively double the group size.
//
// This is similar to the group_sections() function in elf32-arm.c but is
// implemented differently.

template<bool big_endian>
void
Arm_output_section<big_endian>::group_sections(
    section_size_type group_size,
    bool stubs_always_after_branch,
    Target_arm<big_endian>* target,
    const Task* task)
{
  // States for grouping.
  typedef enum
  {
    // No group is being built.
    NO_GROUP,
    // A group is being built but the stub table is not found yet.
    // We keep group a stub group until the size is just under GROUP_SIZE.
    // The last input section in the group will be used as the stub table.
    FINDING_STUB_SECTION,
    // A group is being built and we have already found a stub table.
    // We enter this state to grow a stub group by adding input section
    // after the stub table.  This effectively doubles the group size.
    HAS_STUB_SECTION
  } State;

  // Any newly created relaxed sections are stored here.
  std::vector<Output_relaxed_input_section*> new_relaxed_sections;

  State state = NO_GROUP;
  section_size_type off = 0;
  section_size_type group_begin_offset = 0;
  section_size_type group_end_offset = 0;
  section_size_type stub_table_end_offset = 0;
  Input_section_list::const_iterator group_begin =
    this->input_sections().end();
  Input_section_list::const_iterator stub_table =
    this->input_sections().end();
  Input_section_list::const_iterator group_end = this->input_sections().end();
  for (Input_section_list::const_iterator p = this->input_sections().begin();
       p != this->input_sections().end();
       ++p)
    {
      section_size_type section_begin_offset =
	align_address(off, p->addralign());
      section_size_type section_end_offset =
	section_begin_offset + p->data_size();

      // Check to see if we should group the previously seen sections.
      switch (state)
	{
	case NO_GROUP:
	  break;

	case FINDING_STUB_SECTION:
	  // Adding this section makes the group larger than GROUP_SIZE.
	  if (section_end_offset - group_begin_offset >= group_size)
	    {
	      if (stubs_always_after_branch)
		{
		  gold_assert(group_end != this->input_sections().end());
		  this->create_stub_group(group_begin, group_end, group_end,
					  target, &new_relaxed_sections,
					  task);
		  state = NO_GROUP;
		}
	      else
		{
		  // But wait, there's more!  Input sections up to
		  // stub_group_size bytes after the stub table can be
		  // handled by it too.
		  state = HAS_STUB_SECTION;
		  stub_table = group_end;
		  stub_table_end_offset = group_end_offset;
		}
	    }
	    break;

	case HAS_STUB_SECTION:
	  // Adding this section makes the post stub-section group larger
	  // than GROUP_SIZE.
	  if (section_end_offset - stub_table_end_offset >= group_size)
	   {
	     gold_assert(group_end != this->input_sections().end());
	     this->create_stub_group(group_begin, group_end, stub_table,
				     target, &new_relaxed_sections, task);
	     state = NO_GROUP;
	   }
	   break;

	  default:
	    gold_unreachable();
	}

      // If we see an input section and currently there is no group, start
      // a new one.  Skip any empty sections.  We look at the data size
      // instead of calling p->relobj()->section_size() to avoid locking.
      if ((p->is_input_section() || p->is_relaxed_input_section())
	  && (p->data_size() != 0))
	{
	  if (state == NO_GROUP)
	    {
	      state = FINDING_STUB_SECTION;
	      group_begin = p;
	      group_begin_offset = section_begin_offset;
	    }

	  // Keep track of the last input section seen.
	  group_end = p;
	  group_end_offset = section_end_offset;
	}

      off = section_end_offset;
    }

  // Create a stub group for any ungrouped sections.
  if (state == FINDING_STUB_SECTION || state == HAS_STUB_SECTION)
    {
      gold_assert(group_end != this->input_sections().end());
      this->create_stub_group(group_begin, group_end,
			      (state == FINDING_STUB_SECTION
			       ? group_end
			       : stub_table),
			       target, &new_relaxed_sections, task);
    }

  // Convert input section into relaxed input section in a batch.
  if (!new_relaxed_sections.empty())
    this->convert_input_sections_to_relaxed_sections(new_relaxed_sections);

  // Update the section offsets
  for (size_t i = 0; i < new_relaxed_sections.size(); ++i)
    {
      Arm_relobj<big_endian>* arm_relobj =
	Arm_relobj<big_endian>::as_arm_relobj(
	  new_relaxed_sections[i]->relobj());
      unsigned int shndx = new_relaxed_sections[i]->shndx();
      // Tell Arm_relobj that this input section is converted.
      arm_relobj->convert_input_section_to_relaxed_section(shndx);
    }
}

// Append non empty text sections in this to LIST in ascending
// order of their position in this.

template<bool big_endian>
void
Arm_output_section<big_endian>::append_text_sections_to_list(
    Text_section_list* list)
{
  gold_assert((this->flags() & elfcpp::SHF_ALLOC) != 0);

  for (Input_section_list::const_iterator p = this->input_sections().begin();
       p != this->input_sections().end();
       ++p)
    {
      // We only care about plain or relaxed input sections.  We also
      // ignore any merged sections.
      if (p->is_input_section() || p->is_relaxed_input_section())
	list->push_back(Text_section_list::value_type(p->relobj(),
						      p->shndx()));
    }
}

template<bool big_endian>
void
Arm_output_section<big_endian>::fix_exidx_coverage(
    Layout* layout,
    const Text_section_list& sorted_text_sections,
    Symbol_table* symtab,
    bool merge_exidx_entries,
    const Task* task)
{
  // We should only do this for the EXIDX output section.
  gold_assert(this->type() == elfcpp::SHT_ARM_EXIDX);

  // We don't want the relaxation loop to undo these changes, so we discard
  // the current saved states and take another one after the fix-up.
  this->discard_states();

  // Remove all input sections.
  uint64_t address = this->address();
  typedef std::list<Output_section::Input_section> Input_section_list;
  Input_section_list input_sections;
  this->reset_address_and_file_offset();
  this->get_input_sections(address, std::string(""), &input_sections);

  if (!this->input_sections().empty())
    gold_error(_("Found non-EXIDX input sections in EXIDX output section"));

  // Go through all the known input sections and record them.
  typedef Unordered_set<Section_id, Section_id_hash> Section_id_set;
  typedef Unordered_map<Section_id, const Output_section::Input_section*,
			Section_id_hash> Text_to_exidx_map;
  Text_to_exidx_map text_to_exidx_map;
  for (Input_section_list::const_iterator p = input_sections.begin();
       p != input_sections.end();
       ++p)
    {
      // This should never happen.  At this point, we should only see
      // plain EXIDX input sections.
      gold_assert(!p->is_relaxed_input_section());
      text_to_exidx_map[Section_id(p->relobj(), p->shndx())] = &(*p);
    }

  Arm_exidx_fixup exidx_fixup(this, merge_exidx_entries);

  // Go over the sorted text sections.
  typedef Unordered_set<Section_id, Section_id_hash> Section_id_set;
  Section_id_set processed_input_sections;
  for (Text_section_list::const_iterator p = sorted_text_sections.begin();
       p != sorted_text_sections.end();
       ++p)
    {
      Relobj* relobj = p->first;
      unsigned int shndx = p->second;

      Arm_relobj<big_endian>* arm_relobj =
	 Arm_relobj<big_endian>::as_arm_relobj(relobj);
      const Arm_exidx_input_section* exidx_input_section =
	 arm_relobj->exidx_input_section_by_link(shndx);

      // If this text section has no EXIDX section or if the EXIDX section
      // has errors, force an EXIDX_CANTUNWIND entry pointing to the end
      // of the last seen EXIDX section.
      if (exidx_input_section == NULL || exidx_input_section->has_errors())
	{
	  exidx_fixup.add_exidx_cantunwind_as_needed();
	  continue;
	}

      Relobj* exidx_relobj = exidx_input_section->relobj();
      unsigned int exidx_shndx = exidx_input_section->shndx();
      Section_id sid(exidx_relobj, exidx_shndx);
      Text_to_exidx_map::const_iterator iter = text_to_exidx_map.find(sid);
      if (iter == text_to_exidx_map.end())
	{
	  // This is odd.  We have not seen this EXIDX input section before.
	  // We cannot do fix-up.  If we saw a SECTIONS clause in a script,
	  // issue a warning instead.  We assume the user knows what he
	  // or she is doing.  Otherwise, this is an error.
	  if (layout->script_options()->saw_sections_clause())
	    gold_warning(_("unwinding may not work because EXIDX input section"
			   " %u of %s is not in EXIDX output section"),
			 exidx_shndx, exidx_relobj->name().c_str());
	  else
	    gold_error(_("unwinding may not work because EXIDX input section"
			 " %u of %s is not in EXIDX output section"),
		       exidx_shndx, exidx_relobj->name().c_str());

	  exidx_fixup.add_exidx_cantunwind_as_needed();
	  continue;
	}

      // We need to access the contents of the EXIDX section, lock the
      // object here.
      Task_lock_obj<Object> tl(task, exidx_relobj);
      section_size_type exidx_size;
      const unsigned char* exidx_contents =
	exidx_relobj->section_contents(exidx_shndx, &exidx_size, false);

      // Fix up coverage and append input section to output data list.
      Arm_exidx_section_offset_map* section_offset_map = NULL;
      uint32_t deleted_bytes =
	exidx_fixup.process_exidx_section<big_endian>(exidx_input_section,
						      exidx_contents,
						      exidx_size,
						      &section_offset_map);

      if (deleted_bytes == exidx_input_section->size())
	{
	  // The whole EXIDX section got merged.  Remove it from output.
	  gold_assert(section_offset_map == NULL);
	  exidx_relobj->set_output_section(exidx_shndx, NULL);

	  // All local symbols defined in this input section will be dropped.
	  // We need to adjust output local symbol count.
	  arm_relobj->set_output_local_symbol_count_needs_update();
	}
      else if (deleted_bytes > 0)
	{
	  // Some entries are merged.  We need to convert this EXIDX input
	  // section into a relaxed section.
	  gold_assert(section_offset_map != NULL);

	  Arm_exidx_merged_section* merged_section =
	    new Arm_exidx_merged_section(*exidx_input_section,
					 *section_offset_map, deleted_bytes);
	  merged_section->build_contents(exidx_contents, exidx_size);

	  const std::string secname = exidx_relobj->section_name(exidx_shndx);
	  this->add_relaxed_input_section(layout, merged_section, secname);
	  arm_relobj->convert_input_section_to_relaxed_section(exidx_shndx);

	  // All local symbols defined in discarded portions of this input
	  // section will be dropped.  We need to adjust output local symbol
	  // count.
	  arm_relobj->set_output_local_symbol_count_needs_update();
	}
      else
	{
	  // Just add back the EXIDX input section.
	  gold_assert(section_offset_map == NULL);
	  const Output_section::Input_section* pis = iter->second;
	  gold_assert(pis->is_input_section());
	  this->add_script_input_section(*pis);
	}

      processed_input_sections.insert(Section_id(exidx_relobj, exidx_shndx));
    }

  // Insert an EXIDX_CANTUNWIND entry at the end of output if necessary.
  exidx_fixup.add_exidx_cantunwind_as_needed();

  // Remove any known EXIDX input sections that are not processed.
  for (Input_section_list::const_iterator p = input_sections.begin();
       p != input_sections.end();
       ++p)
    {
      if (processed_input_sections.find(Section_id(p->relobj(), p->shndx()))
	  == processed_input_sections.end())
	{
	  // We discard a known EXIDX section because its linked
	  // text section has been folded by ICF.  We also discard an
	  // EXIDX section with error, the output does not matter in this
	  // case.  We do this to avoid triggering asserts.
	  Arm_relobj<big_endian>* arm_relobj =
	    Arm_relobj<big_endian>::as_arm_relobj(p->relobj());
	  const Arm_exidx_input_section* exidx_input_section =
	    arm_relobj->exidx_input_section_by_shndx(p->shndx());
	  gold_assert(exidx_input_section != NULL);
	  if (!exidx_input_section->has_errors())
	    {
	      unsigned int text_shndx = exidx_input_section->link();
	      gold_assert(symtab->is_section_folded(p->relobj(), text_shndx));
	    }

	  // Remove this from link.  We also need to recount the
	  // local symbols.
	  p->relobj()->set_output_section(p->shndx(), NULL);
	  arm_relobj->set_output_local_symbol_count_needs_update();
	}
    }

  // Link exidx output section to the first seen output section and
  // set correct entry size.
  this->set_link_section(exidx_fixup.first_output_text_section());
  this->set_entsize(8);

  // Make changes permanent.
  this->save_states();
  this->set_section_offsets_need_adjustment();
}

// Link EXIDX output sections to text output sections.

template<bool big_endian>
void
Arm_output_section<big_endian>::set_exidx_section_link()
{
  gold_assert(this->type() == elfcpp::SHT_ARM_EXIDX);
  if (!this->input_sections().empty())
    {
      Input_section_list::const_iterator p = this->input_sections().begin();
      Arm_relobj<big_endian>* arm_relobj =
	Arm_relobj<big_endian>::as_arm_relobj(p->relobj());
      unsigned exidx_shndx = p->shndx();
      const Arm_exidx_input_section* exidx_input_section =
	arm_relobj->exidx_input_section_by_shndx(exidx_shndx);
      gold_assert(exidx_input_section != NULL);
      unsigned int text_shndx = exidx_input_section->link();
      Output_section* os = arm_relobj->output_section(text_shndx);
      this->set_link_section(os);
    }
}

// Arm_relobj methods.

// Determine if an input section is scannable for stub processing.  SHDR is
// the header of the section and SHNDX is the section index.  OS is the output
// section for the input section and SYMTAB is the global symbol table used to
// look up ICF information.

template<bool big_endian>
bool
Arm_relobj<big_endian>::section_is_scannable(
    const elfcpp::Shdr<32, big_endian>& shdr,
    unsigned int shndx,
    const Output_section* os,
    const Symbol_table* symtab)
{
  // Skip any empty sections, unallocated sections or sections whose
  // type are not SHT_PROGBITS.
  if (shdr.get_sh_size() == 0
      || (shdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0
      || shdr.get_sh_type() != elfcpp::SHT_PROGBITS)
    return false;

  // Skip any discarded or ICF'ed sections.
  if (os == NULL || symtab->is_section_folded(this, shndx))
    return false;

  // If this requires special offset handling, check to see if it is
  // a relaxed section.  If this is not, then it is a merged section that
  // we cannot handle.
  if (this->is_output_section_offset_invalid(shndx))
    {
      const Output_relaxed_input_section* poris =
	os->find_relaxed_input_section(this, shndx);
      if (poris == NULL)
	return false;
    }

  return true;
}

// Determine if we want to scan the SHNDX-th section for relocation stubs.
// This is a helper for Arm_relobj::scan_sections_for_stubs() below.

template<bool big_endian>
bool
Arm_relobj<big_endian>::section_needs_reloc_stub_scanning(
    const elfcpp::Shdr<32, big_endian>& shdr,
    const Relobj::Output_sections& out_sections,
    const Symbol_table* symtab,
    const unsigned char* pshdrs)
{
  unsigned int sh_type = shdr.get_sh_type();
  if (sh_type != elfcpp::SHT_REL && sh_type != elfcpp::SHT_RELA)
    return false;

  // Ignore empty section.
  off_t sh_size = shdr.get_sh_size();
  if (sh_size == 0)
    return false;

  // Ignore reloc section with unexpected symbol table.  The
  // error will be reported in the final link.
  if (this->adjust_shndx(shdr.get_sh_link()) != this->symtab_shndx())
    return false;

  unsigned int reloc_size;
  if (sh_type == elfcpp::SHT_REL)
    reloc_size = elfcpp::Elf_sizes<32>::rel_size;
  else
    reloc_size = elfcpp::Elf_sizes<32>::rela_size;

  // Ignore reloc section with unexpected entsize or uneven size.
  // The error will be reported in the final link.
  if (reloc_size != shdr.get_sh_entsize() || sh_size % reloc_size != 0)
    return false;

  // Ignore reloc section with bad info.  This error will be
  // reported in the final link.
  unsigned int index = this->adjust_shndx(shdr.get_sh_info());
  if (index >= this->shnum())
    return false;

  const unsigned int shdr_size = elfcpp::Elf_sizes<32>::shdr_size;
  const elfcpp::Shdr<32, big_endian> text_shdr(pshdrs + index * shdr_size);
  return this->section_is_scannable(text_shdr, index,
				   out_sections[index], symtab);
}

// Return the output address of either a plain input section or a relaxed
// input section.  SHNDX is the section index.  We define and use this
// instead of calling Output_section::output_address because that is slow
// for large output.

template<bool big_endian>
Arm_address
Arm_relobj<big_endian>::simple_input_section_output_address(
    unsigned int shndx,
    Output_section* os)
{
  if (this->is_output_section_offset_invalid(shndx))
    {
      const Output_relaxed_input_section* poris =
	os->find_relaxed_input_section(this, shndx);
      // We do not handle merged sections here.
      gold_assert(poris != NULL);
      return poris->address();
    }
  else
    return os->address() + this->get_output_section_offset(shndx);
}

// Determine if we want to scan the SHNDX-th section for non-relocation stubs.
// This is a helper for Arm_relobj::scan_sections_for_stubs() below.

template<bool big_endian>
bool
Arm_relobj<big_endian>::section_needs_cortex_a8_stub_scanning(
    const elfcpp::Shdr<32, big_endian>& shdr,
    unsigned int shndx,
    Output_section* os,
    const Symbol_table* symtab)
{
  if (!this->section_is_scannable(shdr, shndx, os, symtab))
    return false;

  // If the section does not cross any 4K-boundaries, it does not need to
  // be scanned.
  Arm_address address = this->simple_input_section_output_address(shndx, os);
  if ((address & ~0xfffU) == ((address + shdr.get_sh_size() - 1) & ~0xfffU))
    return false;

  return true;
}

// Scan a section for Cortex-A8 workaround.

template<bool big_endian>
void
Arm_relobj<big_endian>::scan_section_for_cortex_a8_erratum(
    const elfcpp::Shdr<32, big_endian>& shdr,
    unsigned int shndx,
    Output_section* os,
    Target_arm<big_endian>* arm_target)
{
  // Look for the first mapping symbol in this section.  It should be
  // at (shndx, 0).
  Mapping_symbol_position section_start(shndx, 0);
  typename Mapping_symbols_info::const_iterator p =
    this->mapping_symbols_info_.lower_bound(section_start);

  // There are no mapping symbols for this section.  Treat it as a data-only
  // section.  Issue a warning if section is marked as containing
  // instructions.
  if (p == this->mapping_symbols_info_.end() || p->first.first != shndx)
    {
      if ((this->section_flags(shndx) & elfcpp::SHF_EXECINSTR) != 0)
	gold_warning(_("cannot scan executable section %u of %s for Cortex-A8 "
		       "erratum because it has no mapping symbols."),
		     shndx, this->name().c_str());
      return;
    }

  Arm_address output_address =
    this->simple_input_section_output_address(shndx, os);

  // Get the section contents.
  section_size_type input_view_size = 0;
  const unsigned char* input_view =
    this->section_contents(shndx, &input_view_size, false);

  // We need to go through the mapping symbols to determine what to
  // scan.  There are two reasons.  First, we should look at THUMB code and
  // THUMB code only.  Second, we only want to look at the 4K-page boundary
  // to speed up the scanning.

  while (p != this->mapping_symbols_info_.end()
	&& p->first.first == shndx)
    {
      typename Mapping_symbols_info::const_iterator next =
	this->mapping_symbols_info_.upper_bound(p->first);

      // Only scan part of a section with THUMB code.
      if (p->second == 't')
	{
	  // Determine the end of this range.
	  section_size_type span_start =
	    convert_to_section_size_type(p->first.second);
	  section_size_type span_end;
	  if (next != this->mapping_symbols_info_.end()
	      && next->first.first == shndx)
	    span_end = convert_to_section_size_type(next->first.second);
	  else
	    span_end = convert_to_section_size_type(shdr.get_sh_size());

	  if (((span_start + output_address) & ~0xfffUL)
	      != ((span_end + output_address - 1) & ~0xfffUL))
	    {
	      arm_target->scan_span_for_cortex_a8_erratum(this, shndx,
							  span_start, span_end,
							  input_view,
							  output_address);
	    }
	}

      p = next;
    }
}

// Scan relocations for stub generation.

template<bool big_endian>
void
Arm_relobj<big_endian>::scan_sections_for_stubs(
    Target_arm<big_endian>* arm_target,
    const Symbol_table* symtab,
    const Layout* layout)
{
  unsigned int shnum = this->shnum();
  const unsigned int shdr_size = elfcpp::Elf_sizes<32>::shdr_size;

  // Read the section headers.
  const unsigned char* pshdrs = this->get_view(this->elf_file()->shoff(),
					       shnum * shdr_size,
					       true, true);

  // To speed up processing, we set up hash tables for fast lookup of
  // input offsets to output addresses.
  this->initialize_input_to_output_maps();

  const Relobj::Output_sections& out_sections(this->output_sections());

  Relocate_info<32, big_endian> relinfo;
  relinfo.symtab = symtab;
  relinfo.layout = layout;
  relinfo.object = this;

  // Do relocation stubs scanning.
  const unsigned char* p = pshdrs + shdr_size;
  for (unsigned int i = 1; i < shnum; ++i, p += shdr_size)
    {
      const elfcpp::Shdr<32, big_endian> shdr(p);
      if (this->section_needs_reloc_stub_scanning(shdr, out_sections, symtab,
						  pshdrs))
	{
	  unsigned int index = this->adjust_shndx(shdr.get_sh_info());
	  Arm_address output_offset = this->get_output_section_offset(index);
	  Arm_address output_address;
	  if (output_offset != invalid_address)
	    output_address = out_sections[index]->address() + output_offset;
	  else
	    {
	      // Currently this only happens for a relaxed section.
	      const Output_relaxed_input_section* poris =
	      out_sections[index]->find_relaxed_input_section(this, index);
	      gold_assert(poris != NULL);
	      output_address = poris->address();
	    }

	  // Get the relocations.
	  const unsigned char* prelocs = this->get_view(shdr.get_sh_offset(),
							shdr.get_sh_size(),
							true, false);

	  // Get the section contents.  This does work for the case in which
	  // we modify the contents of an input section.  We need to pass the
	  // output view under such circumstances.
	  section_size_type input_view_size = 0;
	  const unsigned char* input_view =
	    this->section_contents(index, &input_view_size, false);

	  relinfo.reloc_shndx = i;
	  relinfo.data_shndx = index;
	  unsigned int sh_type = shdr.get_sh_type();
	  unsigned int reloc_size;
	  if (sh_type == elfcpp::SHT_REL)
	    reloc_size = elfcpp::Elf_sizes<32>::rel_size;
	  else
	    reloc_size = elfcpp::Elf_sizes<32>::rela_size;

	  Output_section* os = out_sections[index];
	  arm_target->scan_section_for_stubs(&relinfo, sh_type, prelocs,
					     shdr.get_sh_size() / reloc_size,
					     os,
					     output_offset == invalid_address,
					     input_view, output_address,
					     input_view_size);
	}
    }

  // Do Cortex-A8 erratum stubs scanning.  This has to be done for a section
  // after its relocation section, if there is one, is processed for
  // relocation stubs.  Merging this loop with the one above would have been
  // complicated since we would have had to make sure that relocation stub
  // scanning is done first.
  if (arm_target->fix_cortex_a8())
    {
      const unsigned char* p = pshdrs + shdr_size;
      for (unsigned int i = 1; i < shnum; ++i, p += shdr_size)
	{
	  const elfcpp::Shdr<32, big_endian> shdr(p);
	  if (this->section_needs_cortex_a8_stub_scanning(shdr, i,
							  out_sections[i],
							  symtab))
	    this->scan_section_for_cortex_a8_erratum(shdr, i, out_sections[i],
						     arm_target);
	}
    }

  // After we've done the relocations, we release the hash tables,
  // since we no longer need them.
  this->free_input_to_output_maps();
}

// Count the local symbols.  The ARM backend needs to know if a symbol
// is a THUMB function or not.  For global symbols, it is easy because
// the Symbol object keeps the ELF symbol type.  For local symbol it is
// harder because we cannot access this information.   So we override the
// do_count_local_symbol in parent and scan local symbols to mark
// THUMB functions.  This is not the most efficient way but I do not want to
// slow down other ports by calling a per symbol target hook inside
// Sized_relobj_file<size, big_endian>::do_count_local_symbols.

template<bool big_endian>
void
Arm_relobj<big_endian>::do_count_local_symbols(
    Stringpool_template<char>* pool,
    Stringpool_template<char>* dynpool)
{
  // We need to fix-up the values of any local symbols whose type are
  // STT_ARM_TFUNC.

  // Ask parent to count the local symbols.
  Sized_relobj_file<32, big_endian>::do_count_local_symbols(pool, dynpool);
  const unsigned int loccount = this->local_symbol_count();
  if (loccount == 0)
    return;

  // Initialize the thumb function bit-vector.
  std::vector<bool> empty_vector(loccount, false);
  this->local_symbol_is_thumb_function_.swap(empty_vector);

  // Read the symbol table section header.
  const unsigned int symtab_shndx = this->symtab_shndx();
  elfcpp::Shdr<32, big_endian>
      symtabshdr(this, this->elf_file()->section_header(symtab_shndx));
  gold_assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);

  // Read the local symbols.
  const int sym_size =elfcpp::Elf_sizes<32>::sym_size;
  gold_assert(loccount == symtabshdr.get_sh_info());
  off_t locsize = loccount * sym_size;
  const unsigned char* psyms = this->get_view(symtabshdr.get_sh_offset(),
					      locsize, true, true);

  // For mapping symbol processing, we need to read the symbol names.
  unsigned int strtab_shndx = this->adjust_shndx(symtabshdr.get_sh_link());
  if (strtab_shndx >= this->shnum())
    {
      this->error(_("invalid symbol table name index: %u"), strtab_shndx);
      return;
    }

  elfcpp::Shdr<32, big_endian>
    strtabshdr(this, this->elf_file()->section_header(strtab_shndx));
  if (strtabshdr.get_sh_type() != elfcpp::SHT_STRTAB)
    {
      this->error(_("symbol table name section has wrong type: %u"),
		  static_cast<unsigned int>(strtabshdr.get_sh_type()));
      return;
    }
  const char* pnames =
    reinterpret_cast<const char*>(this->get_view(strtabshdr.get_sh_offset(),
						 strtabshdr.get_sh_size(),
						 false, false));

  // Loop over the local symbols and mark any local symbols pointing
  // to THUMB functions.

  // Skip the first dummy symbol.
  psyms += sym_size;
  typename Sized_relobj_file<32, big_endian>::Local_values* plocal_values =
    this->local_values();
  for (unsigned int i = 1; i < loccount; ++i, psyms += sym_size)
    {
      elfcpp::Sym<32, big_endian> sym(psyms);
      elfcpp::STT st_type = sym.get_st_type();
      Symbol_value<32>& lv((*plocal_values)[i]);
      Arm_address input_value = lv.input_value();

      // Check to see if this is a mapping symbol.
      const char* sym_name = pnames + sym.get_st_name();
      if (Target_arm<big_endian>::is_mapping_symbol_name(sym_name))
	{
	  bool is_ordinary;
	  unsigned int input_shndx =
	    this->adjust_sym_shndx(i, sym.get_st_shndx(), &is_ordinary);
	  gold_assert(is_ordinary);

	  // Strip of LSB in case this is a THUMB symbol.
	  Mapping_symbol_position msp(input_shndx, input_value & ~1U);
	  this->mapping_symbols_info_[msp] = sym_name[1];
	}

      if (st_type == elfcpp::STT_ARM_TFUNC
	  || (st_type == elfcpp::STT_FUNC && ((input_value & 1) != 0)))
	{
	  // This is a THUMB function.  Mark this and canonicalize the
	  // symbol value by setting LSB.
	  this->local_symbol_is_thumb_function_[i] = true;
	  if ((input_value & 1) == 0)
	    lv.set_input_value(input_value | 1);
	}
    }
}

// Relocate sections.
template<bool big_endian>
void
Arm_relobj<big_endian>::do_relocate_sections(
    const Symbol_table* symtab,
    const Layout* layout,
    const unsigned char* pshdrs,
    Output_file* of,
    typename Sized_relobj_file<32, big_endian>::Views* pviews)
{
  // Call parent to relocate sections.
  Sized_relobj_file<32, big_endian>::do_relocate_sections(symtab, layout,
							  pshdrs, of, pviews);

  // We do not generate stubs if doing a relocatable link.
  if (parameters->options().relocatable())
    return;

  // Relocate stub tables.
  unsigned int shnum = this->shnum();

  Target_arm<big_endian>* arm_target =
    Target_arm<big_endian>::default_target();

  Relocate_info<32, big_endian> relinfo;
  relinfo.symtab = symtab;
  relinfo.layout = layout;
  relinfo.object = this;

  for (unsigned int i = 1; i < shnum; ++i)
    {
      Arm_input_section<big_endian>* arm_input_section =
	arm_target->find_arm_input_section(this, i);

      if (arm_input_section != NULL
	  && arm_input_section->is_stub_table_owner()
	  && !arm_input_section->stub_table()->empty())
	{
	  // We cannot discard a section if it owns a stub table.
	  Output_section* os = this->output_section(i);
	  gold_assert(os != NULL);

	  relinfo.reloc_shndx = elfcpp::SHN_UNDEF;
	  relinfo.reloc_shdr = NULL;
	  relinfo.data_shndx = i;
	  relinfo.data_shdr = pshdrs + i * elfcpp::Elf_sizes<32>::shdr_size;

	  gold_assert((*pviews)[i].view != NULL);

	  // We are passed the output section view.  Adjust it to cover the
	  // stub table only.
	  Stub_table<big_endian>* stub_table = arm_input_section->stub_table();
	  gold_assert((stub_table->address() >= (*pviews)[i].address)
		      && ((stub_table->address() + stub_table->data_size())
			  <= (*pviews)[i].address + (*pviews)[i].view_size));

	  off_t offset = stub_table->address() - (*pviews)[i].address;
	  unsigned char* view = (*pviews)[i].view + offset;
	  Arm_address address = stub_table->address();
	  section_size_type view_size = stub_table->data_size();

	  stub_table->relocate_stubs(&relinfo, arm_target, os, view, address,
				     view_size);
	}

      // Apply Cortex A8 workaround if applicable.
      if (this->section_has_cortex_a8_workaround(i))
	{
	  unsigned char* view = (*pviews)[i].view;
	  Arm_address view_address = (*pviews)[i].address;
	  section_size_type view_size = (*pviews)[i].view_size;
	  Stub_table<big_endian>* stub_table = this->stub_tables_[i];

	  // Adjust view to cover section.
	  Output_section* os = this->output_section(i);
	  gold_assert(os != NULL);
	  Arm_address section_address =
	    this->simple_input_section_output_address(i, os);
	  uint64_t section_size = this->section_size(i);

	  gold_assert(section_address >= view_address
		      && ((section_address + section_size)
			  <= (view_address + view_size)));

	  unsigned char* section_view = view + (section_address - view_address);

	  // Apply the Cortex-A8 workaround to the output address range
	  // corresponding to this input section.
	  stub_table->apply_cortex_a8_workaround_to_address_range(
	      arm_target,
	      section_view,
	      section_address,
	      section_size);
	}
    }
}

// Find the linked text section of an EXIDX section by looking at the first
// relocation.  4.4.1 of the EHABI specifications says that an EXIDX section
// must be linked to its associated code section via the sh_link field of
// its section header.  However, some tools are broken and the link is not
// always set.  LD just drops such an EXIDX section silently, causing the
// associated code not unwindabled.   Here we try a little bit harder to
// discover the linked code section.
//
// PSHDR points to the section header of a relocation section of an EXIDX
// section.  If we can find a linked text section, return true and
// store the text section index in the location PSHNDX.  Otherwise
// return false.

template<bool big_endian>
bool
Arm_relobj<big_endian>::find_linked_text_section(
    const unsigned char* pshdr,
    const unsigned char* psyms,
    unsigned int* pshndx)
{
  elfcpp::Shdr<32, big_endian> shdr(pshdr);

  // If there is no relocation, we cannot find the linked text section.
  size_t reloc_size;
  if (shdr.get_sh_type() == elfcpp::SHT_REL)
      reloc_size = elfcpp::Elf_sizes<32>::rel_size;
  else
      reloc_size = elfcpp::Elf_sizes<32>::rela_size;
  size_t reloc_count = shdr.get_sh_size() / reloc_size;

  // Get the relocations.
  const unsigned char* prelocs =
      this->get_view(shdr.get_sh_offset(), shdr.get_sh_size(), true, false);

  // Find the REL31 relocation for the first word of the first EXIDX entry.
  for (size_t i = 0; i < reloc_count; ++i, prelocs += reloc_size)
    {
      Arm_address r_offset;
      typename elfcpp::Elf_types<32>::Elf_WXword r_info;
      if (shdr.get_sh_type() == elfcpp::SHT_REL)
	{
	  typename elfcpp::Rel<32, big_endian> reloc(prelocs);
	  r_info = reloc.get_r_info();
	  r_offset = reloc.get_r_offset();
	}
      else
	{
	  typename elfcpp::Rela<32, big_endian> reloc(prelocs);
	  r_info = reloc.get_r_info();
	  r_offset = reloc.get_r_offset();
	}

      unsigned int r_type = elfcpp::elf_r_type<32>(r_info);
      if (r_type != elfcpp::R_ARM_PREL31 && r_type != elfcpp::R_ARM_SBREL31)
	continue;

      unsigned int r_sym = elfcpp::elf_r_sym<32>(r_info);
      if (r_sym == 0
	  || r_sym >= this->local_symbol_count()
	  || r_offset != 0)
	continue;

      // This is the relocation for the first word of the first EXIDX entry.
      // We expect to see a local section symbol.
      const int sym_size = elfcpp::Elf_sizes<32>::sym_size;
      elfcpp::Sym<32, big_endian> sym(psyms + r_sym * sym_size);
      if (sym.get_st_type() == elfcpp::STT_SECTION)
	{
	  bool is_ordinary;
	  *pshndx =
	    this->adjust_sym_shndx(r_sym, sym.get_st_shndx(), &is_ordinary);
	  gold_assert(is_ordinary);
	  return true;
	}
      else
	return false;
    }

  return false;
}

// Make an EXIDX input section object for an EXIDX section whose index is
// SHNDX.  SHDR is the section header of the EXIDX section and TEXT_SHNDX
// is the section index of the linked text section.

template<bool big_endian>
void
Arm_relobj<big_endian>::make_exidx_input_section(
    unsigned int shndx,
    const elfcpp::Shdr<32, big_endian>& shdr,
    unsigned int text_shndx,
    const elfcpp::Shdr<32, big_endian>& text_shdr)
{
  // Create an Arm_exidx_input_section object for this EXIDX section.
  Arm_exidx_input_section* exidx_input_section =
    new Arm_exidx_input_section(this, shndx, text_shndx, shdr.get_sh_size(),
				shdr.get_sh_addralign(),
				text_shdr.get_sh_size());

  gold_assert(this->exidx_section_map_[shndx] == NULL);
  this->exidx_section_map_[shndx] = exidx_input_section;

  if (text_shndx == elfcpp::SHN_UNDEF || text_shndx >= this->shnum())
    {
      gold_error(_("EXIDX section %s(%u) links to invalid section %u in %s"),
		 this->section_name(shndx).c_str(), shndx, text_shndx,
		 this->name().c_str());
      exidx_input_section->set_has_errors();
    }
  else if (this->exidx_section_map_[text_shndx] != NULL)
    {
      unsigned other_exidx_shndx =
	this->exidx_section_map_[text_shndx]->shndx();
      gold_error(_("EXIDX sections %s(%u) and %s(%u) both link to text section"
		   "%s(%u) in %s"),
		 this->section_name(shndx).c_str(), shndx,
		 this->section_name(other_exidx_shndx).c_str(),
		 other_exidx_shndx, this->section_name(text_shndx).c_str(),
		 text_shndx, this->name().c_str());
      exidx_input_section->set_has_errors();
    }
  else
     this->exidx_section_map_[text_shndx] = exidx_input_section;

  // Check section flags of text section.
  if ((text_shdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0)
    {
      gold_error(_("EXIDX section %s(%u) links to non-allocated section %s(%u) "
		   " in %s"),
		 this->section_name(shndx).c_str(), shndx,
		 this->section_name(text_shndx).c_str(), text_shndx,
		 this->name().c_str());
      exidx_input_section->set_has_errors();
    }
  else if ((text_shdr.get_sh_flags() & elfcpp::SHF_EXECINSTR) == 0)
    // I would like to make this an error but currently ld just ignores
    // this.
    gold_warning(_("EXIDX section %s(%u) links to non-executable section "
		   "%s(%u) in %s"),
		 this->section_name(shndx).c_str(), shndx,
		 this->section_name(text_shndx).c_str(), text_shndx,
		 this->name().c_str());
}

// Read the symbol information.

template<bool big_endian>
void
Arm_relobj<big_endian>::do_read_symbols(Read_symbols_data* sd)
{
  // Call parent class to read symbol information.
  Sized_relobj_file<32, big_endian>::do_read_symbols(sd);

  // If this input file is a binary file, it has no processor
  // specific flags and attributes section.
  Input_file::Format format = this->input_file()->format();
  if (format != Input_file::FORMAT_ELF)
    {
      gold_assert(format == Input_file::FORMAT_BINARY);
      this->merge_flags_and_attributes_ = false;
      return;
    }

  // Read processor-specific flags in ELF file header.
  const unsigned char* pehdr = this->get_view(elfcpp::file_header_offset,
					      elfcpp::Elf_sizes<32>::ehdr_size,
					      true, false);
  elfcpp::Ehdr<32, big_endian> ehdr(pehdr);
  this->processor_specific_flags_ = ehdr.get_e_flags();

  // Go over the section headers and look for .ARM.attributes and .ARM.exidx
  // sections.
  std::vector<unsigned int> deferred_exidx_sections;
  const size_t shdr_size = elfcpp::Elf_sizes<32>::shdr_size;
  const unsigned char* pshdrs = sd->section_headers->data();
  const unsigned char* ps = pshdrs + shdr_size;
  bool must_merge_flags_and_attributes = false;
  for (unsigned int i = 1; i < this->shnum(); ++i, ps += shdr_size)
    {
      elfcpp::Shdr<32, big_endian> shdr(ps);

      // Sometimes an object has no contents except the section name string
      // table and an empty symbol table with the undefined symbol.  We
      // don't want to merge processor-specific flags from such an object.
      if (shdr.get_sh_type() == elfcpp::SHT_SYMTAB)
	{
	  // Symbol table is not empty.
	  const elfcpp::Elf_types<32>::Elf_WXword sym_size =
	     elfcpp::Elf_sizes<32>::sym_size;
	  if (shdr.get_sh_size() > sym_size)
	    must_merge_flags_and_attributes = true;
	}
      else if (shdr.get_sh_type() != elfcpp::SHT_STRTAB)
	// If this is neither an empty symbol table nor a string table,
	// be conservative.
	must_merge_flags_and_attributes = true;

      if (shdr.get_sh_type() == elfcpp::SHT_ARM_ATTRIBUTES)
	{
	  gold_assert(this->attributes_section_data_ == NULL);
	  section_offset_type section_offset = shdr.get_sh_offset();
	  section_size_type section_size =
	    convert_to_section_size_type(shdr.get_sh_size());
	  const unsigned char* view =
	     this->get_view(section_offset, section_size, true, false);
	  this->attributes_section_data_ =
	    new Attributes_section_data(view, section_size);
	}
      else if (shdr.get_sh_type() == elfcpp::SHT_ARM_EXIDX)
	{
	  unsigned int text_shndx = this->adjust_shndx(shdr.get_sh_link());
	  if (text_shndx == elfcpp::SHN_UNDEF)
	    deferred_exidx_sections.push_back(i);
	  else
	    {
	      elfcpp::Shdr<32, big_endian> text_shdr(pshdrs
						     + text_shndx * shdr_size);
	      this->make_exidx_input_section(i, shdr, text_shndx, text_shdr);
	    }
	  // EHABI 4.4.1 requires that SHF_LINK_ORDER flag to be set.
	  if ((shdr.get_sh_flags() & elfcpp::SHF_LINK_ORDER) == 0)
	    gold_warning(_("SHF_LINK_ORDER not set in EXIDX section %s of %s"),
			 this->section_name(i).c_str(), this->name().c_str());
	}
    }

  // This is rare.
  if (!must_merge_flags_and_attributes)
    {
      gold_assert(deferred_exidx_sections.empty());
      this->merge_flags_and_attributes_ = false;
      return;
    }

  // Some tools are broken and they do not set the link of EXIDX sections.
  // We look at the first relocation to figure out the linked sections.
  if (!deferred_exidx_sections.empty())
    {
      // We need to go over the section headers again to find the mapping
      // from sections being relocated to their relocation sections.  This is
      // a bit inefficient as we could do that in the loop above.  However,
      // we do not expect any deferred EXIDX sections normally.  So we do not
      // want to slow down the most common path.
      typedef Unordered_map<unsigned int, unsigned int> Reloc_map;
      Reloc_map reloc_map;
      ps = pshdrs + shdr_size;
      for (unsigned int i = 1; i < this->shnum(); ++i, ps += shdr_size)
	{
	  elfcpp::Shdr<32, big_endian> shdr(ps);
	  elfcpp::Elf_Word sh_type = shdr.get_sh_type();
	  if (sh_type == elfcpp::SHT_REL || sh_type == elfcpp::SHT_RELA)
	    {
	      unsigned int info_shndx = this->adjust_shndx(shdr.get_sh_info());
	      if (info_shndx >= this->shnum())
		gold_error(_("relocation section %u has invalid info %u"),
			   i, info_shndx);
	      Reloc_map::value_type value(info_shndx, i);
	      std::pair<Reloc_map::iterator, bool> result =
		reloc_map.insert(value);
	      if (!result.second)
		gold_error(_("section %u has multiple relocation sections "
			     "%u and %u"),
			   info_shndx, i, reloc_map[info_shndx]);
	    }
	}

      // Read the symbol table section header.
      const unsigned int symtab_shndx = this->symtab_shndx();
      elfcpp::Shdr<32, big_endian>
	  symtabshdr(this, this->elf_file()->section_header(symtab_shndx));
      gold_assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);

      // Read the local symbols.
      const int sym_size =elfcpp::Elf_sizes<32>::sym_size;
      const unsigned int loccount = this->local_symbol_count();
      gold_assert(loccount == symtabshdr.get_sh_info());
      off_t locsize = loccount * sym_size;
      const unsigned char* psyms = this->get_view(symtabshdr.get_sh_offset(),
						  locsize, true, true);

      // Process the deferred EXIDX sections.
      for (unsigned int i = 0; i < deferred_exidx_sections.size(); ++i)
	{
	  unsigned int shndx = deferred_exidx_sections[i];
	  elfcpp::Shdr<32, big_endian> shdr(pshdrs + shndx * shdr_size);
	  unsigned int text_shndx = elfcpp::SHN_UNDEF;
	  Reloc_map::const_iterator it = reloc_map.find(shndx);
	  if (it != reloc_map.end())
	    find_linked_text_section(pshdrs + it->second * shdr_size,
				     psyms, &text_shndx);
	  elfcpp::Shdr<32, big_endian> text_shdr(pshdrs
						 + text_shndx * shdr_size);
	  this->make_exidx_input_section(shndx, shdr, text_shndx, text_shdr);
	}
    }
}

// Process relocations for garbage collection.  The ARM target uses .ARM.exidx
// sections for unwinding.  These sections are referenced implicitly by
// text sections linked in the section headers.  If we ignore these implicit
// references, the .ARM.exidx sections and any .ARM.extab sections they use
// will be garbage-collected incorrectly.  Hence we override the same function
// in the base class to handle these implicit references.

template<bool big_endian>
void
Arm_relobj<big_endian>::do_gc_process_relocs(Symbol_table* symtab,
					     Layout* layout,
					     Read_relocs_data* rd)
{
  // First, call base class method to process relocations in this object.
  Sized_relobj_file<32, big_endian>::do_gc_process_relocs(symtab, layout, rd);

  // If --gc-sections is not specified, there is nothing more to do.
  // This happens when --icf is used but --gc-sections is not.
  if (!parameters->options().gc_sections())
    return;

  unsigned int shnum = this->shnum();
  const unsigned int shdr_size = elfcpp::Elf_sizes<32>::shdr_size;
  const unsigned char* pshdrs = this->get_view(this->elf_file()->shoff(),
					       shnum * shdr_size,
					       true, true);

  // Scan section headers for sections of type SHT_ARM_EXIDX.  Add references
  // to these from the linked text sections.
  const unsigned char* ps = pshdrs + shdr_size;
  for (unsigned int i = 1; i < shnum; ++i, ps += shdr_size)
    {
      elfcpp::Shdr<32, big_endian> shdr(ps);
      if (shdr.get_sh_type() == elfcpp::SHT_ARM_EXIDX)
	{
	  // Found an .ARM.exidx section, add it to the set of reachable
	  // sections from its linked text section.
	  unsigned int text_shndx = this->adjust_shndx(shdr.get_sh_link());
	  symtab->gc()->add_reference(this, text_shndx, this, i);
	}
    }
}

// Update output local symbol count.  Owing to EXIDX entry merging, some local
// symbols  will be removed in output.  Adjust output local symbol count
// accordingly.  We can only changed the static output local symbol count.  It
// is too late to change the dynamic symbols.

template<bool big_endian>
void
Arm_relobj<big_endian>::update_output_local_symbol_count()
{
  // Caller should check that this needs updating.  We want caller checking
  // because output_local_symbol_count_needs_update() is most likely inlined.
  gold_assert(this->output_local_symbol_count_needs_update_);

  gold_assert(this->symtab_shndx() != -1U);
  if (this->symtab_shndx() == 0)
    {
      // This object has no symbols.  Weird but legal.
      return;
    }

  // Read the symbol table section header.
  const unsigned int symtab_shndx = this->symtab_shndx();
  elfcpp::Shdr<32, big_endian>
    symtabshdr(this, this->elf_file()->section_header(symtab_shndx));
  gold_assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);

  // Read the local symbols.
  const int sym_size = elfcpp::Elf_sizes<32>::sym_size;
  const unsigned int loccount = this->local_symbol_count();
  gold_assert(loccount == symtabshdr.get_sh_info());
  off_t locsize = loccount * sym_size;
  const unsigned char* psyms = this->get_view(symtabshdr.get_sh_offset(),
					      locsize, true, true);

  // Loop over the local symbols.

  typedef typename Sized_relobj_file<32, big_endian>::Output_sections
     Output_sections;
  const Output_sections& out_sections(this->output_sections());
  unsigned int shnum = this->shnum();
  unsigned int count = 0;
  // Skip the first, dummy, symbol.
  psyms += sym_size;
  for (unsigned int i = 1; i < loccount; ++i, psyms += sym_size)
    {
      elfcpp::Sym<32, big_endian> sym(psyms);

      Symbol_value<32>& lv((*this->local_values())[i]);

      // This local symbol was already discarded by do_count_local_symbols.
      if (lv.is_output_symtab_index_set() && !lv.has_output_symtab_entry())
	continue;

      bool is_ordinary;
      unsigned int shndx = this->adjust_sym_shndx(i, sym.get_st_shndx(),
						  &is_ordinary);

      if (shndx < shnum)
	{
	  Output_section* os = out_sections[shndx];

	  // This local symbol no longer has an output section.  Discard it.
	  if (os == NULL)
	    {
	      lv.set_no_output_symtab_entry();
	      continue;
	    }

	  // Currently we only discard parts of EXIDX input sections.
	  // We explicitly check for a merged EXIDX input section to avoid
	  // calling Output_section_data::output_offset unless necessary.
	  if ((this->get_output_section_offset(shndx) == invalid_address)
	      && (this->exidx_input_section_by_shndx(shndx) != NULL))
	    {
	      section_offset_type output_offset =
		os->output_offset(this, shndx, lv.input_value());
	      if (output_offset == -1)
		{
		  // This symbol is defined in a part of an EXIDX input section
		  // that is discarded due to entry merging.
		  lv.set_no_output_symtab_entry();
		  continue;
		}
	    }
	}

      ++count;
    }

  this->set_output_local_symbol_count(count);
  this->output_local_symbol_count_needs_update_ = false;
}

// Arm_dynobj methods.

// Read the symbol information.

template<bool big_endian>
void
Arm_dynobj<big_endian>::do_read_symbols(Read_symbols_data* sd)
{
  // Call parent class to read symbol information.
  Sized_dynobj<32, big_endian>::do_read_symbols(sd);

  // Read processor-specific flags in ELF file header.
  const unsigned char* pehdr = this->get_view(elfcpp::file_header_offset,
					      elfcpp::Elf_sizes<32>::ehdr_size,
					      true, false);
  elfcpp::Ehdr<32, big_endian> ehdr(pehdr);
  this->processor_specific_flags_ = ehdr.get_e_flags();

  // Read the attributes section if there is one.
  // We read from the end because gas seems to put it near the end of
  // the section headers.
  const size_t shdr_size = elfcpp::Elf_sizes<32>::shdr_size;
  const unsigned char* ps =
    sd->section_headers->data() + shdr_size * (this->shnum() - 1);
  for (unsigned int i = this->shnum(); i > 0; --i, ps -= shdr_size)
    {
      elfcpp::Shdr<32, big_endian> shdr(ps);
      if (shdr.get_sh_type() == elfcpp::SHT_ARM_ATTRIBUTES)
	{
	  section_offset_type section_offset = shdr.get_sh_offset();
	  section_size_type section_size =
	    convert_to_section_size_type(shdr.get_sh_size());
	  const unsigned char* view =
	    this->get_view(section_offset, section_size, true, false);
	  this->attributes_section_data_ =
	    new Attributes_section_data(view, section_size);
	  break;
	}
    }
}

// Stub_addend_reader methods.

// Read the addend of a REL relocation of type R_TYPE at VIEW.

template<bool big_endian>
elfcpp::Elf_types<32>::Elf_Swxword
Stub_addend_reader<elfcpp::SHT_REL, big_endian>::operator()(
    unsigned int r_type,
    const unsigned char* view,
    const typename Reloc_types<elfcpp::SHT_REL, 32, big_endian>::Reloc&) const
{
  typedef class Arm_relocate_functions<big_endian> RelocFuncs;

  switch (r_type)
    {
    case elfcpp::R_ARM_CALL:
    case elfcpp::R_ARM_JUMP24:
    case elfcpp::R_ARM_PLT32:
      {
	typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
	const Valtype* wv = reinterpret_cast<const Valtype*>(view);
	Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
	return Bits<26>::sign_extend32(val << 2);
      }

    case elfcpp::R_ARM_THM_CALL:
    case elfcpp::R_ARM_THM_JUMP24:
    case elfcpp::R_ARM_THM_XPC22:
      {
	typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
	const Valtype* wv = reinterpret_cast<const Valtype*>(view);
	Valtype upper_insn = elfcpp::Swap<16, big_endian>::readval(wv);
	Valtype lower_insn = elfcpp::Swap<16, big_endian>::readval(wv + 1);
	return RelocFuncs::thumb32_branch_offset(upper_insn, lower_insn);
      }

    case elfcpp::R_ARM_THM_JUMP19:
      {
	typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
	const Valtype* wv = reinterpret_cast<const Valtype*>(view);
	Valtype upper_insn = elfcpp::Swap<16, big_endian>::readval(wv);
	Valtype lower_insn = elfcpp::Swap<16, big_endian>::readval(wv + 1);
	return RelocFuncs::thumb32_cond_branch_offset(upper_insn, lower_insn);
      }

    default:
      gold_unreachable();
    }
}

// Arm_output_data_got methods.

// Add a GOT pair for R_ARM_TLS_GD32.  The creates a pair of GOT entries.
// The first one is initialized to be 1, which is the module index for
// the main executable and the second one 0.  A reloc of the type
// R_ARM_TLS_DTPOFF32 will be created for the second GOT entry and will
// be applied by gold.  GSYM is a global symbol.
//
template<bool big_endian>
void
Arm_output_data_got<big_endian>::add_tls_gd32_with_static_reloc(
    unsigned int got_type,
    Symbol* gsym)
{
  if (gsym->has_got_offset(got_type))
    return;

  // We are doing a static link.  Just mark it as belong to module 1,
  // the executable.
  unsigned int got_offset = this->add_constant(1);
  gsym->set_got_offset(got_type, got_offset);
  got_offset = this->add_constant(0);
  this->static_relocs_.push_back(Static_reloc(got_offset,
					      elfcpp::R_ARM_TLS_DTPOFF32,
					      gsym));
}

// Same as the above but for a local symbol.

template<bool big_endian>
void
Arm_output_data_got<big_endian>::add_tls_gd32_with_static_reloc(
  unsigned int got_type,
  Sized_relobj_file<32, big_endian>* object,
  unsigned int index)
{
  if (object->local_has_got_offset(index, got_type))
    return;

  // We are doing a static link.  Just mark it as belong to module 1,
  // the executable.
  unsigned int got_offset = this->add_constant(1);
  object->set_local_got_offset(index, got_type, got_offset);
  got_offset = this->add_constant(0);
  this->static_relocs_.push_back(Static_reloc(got_offset,
					      elfcpp::R_ARM_TLS_DTPOFF32,
					      object, index));
}

template<bool big_endian>
void
Arm_output_data_got<big_endian>::do_write(Output_file* of)
{
  // Call parent to write out GOT.
  Output_data_got<32, big_endian>::do_write(of);

  // We are done if there is no fix up.
  if (this->static_relocs_.empty())
    return;

  gold_assert(parameters->doing_static_link());

  const off_t offset = this->offset();
  const section_size_type oview_size =
    convert_to_section_size_type(this->data_size());
  unsigned char* const oview = of->get_output_view(offset, oview_size);

  Output_segment* tls_segment = this->layout_->tls_segment();
  gold_assert(tls_segment != NULL);

  // The thread pointer $tp points to the TCB, which is followed by the
  // TLS.  So we need to adjust $tp relative addressing by this amount.
  Arm_address aligned_tcb_size =
    align_address(ARM_TCB_SIZE, tls_segment->maximum_alignment());

  for (size_t i = 0; i < this->static_relocs_.size(); ++i)
    {
      Static_reloc& reloc(this->static_relocs_[i]);

      Arm_address value;
      if (!reloc.symbol_is_global())
	{
	  Sized_relobj_file<32, big_endian>* object = reloc.relobj();
	  const Symbol_value<32>* psymval =
	    reloc.relobj()->local_symbol(reloc.index());

	  // We are doing static linking.  Issue an error and skip this
	  // relocation if the symbol is undefined or in a discarded_section.
	  bool is_ordinary;
	  unsigned int shndx = psymval->input_shndx(&is_ordinary);
	  if ((shndx == elfcpp::SHN_UNDEF)
	      || (is_ordinary
		  && shndx != elfcpp::SHN_UNDEF
		  && !object->is_section_included(shndx)
		  && !this->symbol_table_->is_section_folded(object, shndx)))
	    {
	      gold_error(_("undefined or discarded local symbol %u from "
			   " object %s in GOT"),
			 reloc.index(), reloc.relobj()->name().c_str());
	      continue;
	    }

	  value = psymval->value(object, 0);
	}
      else
	{
	  const Symbol* gsym = reloc.symbol();
	  gold_assert(gsym != NULL);
	  if (gsym->is_forwarder())
	    gsym = this->symbol_table_->resolve_forwards(gsym);

	  // We are doing static linking.  Issue an error and skip this
	  // relocation if the symbol is undefined or in a discarded_section
	  // unless it is a weakly_undefined symbol.
	  if ((gsym->is_defined_in_discarded_section()
	       || gsym->is_undefined())
	      && !gsym->is_weak_undefined())
	    {
	      gold_error(_("undefined or discarded symbol %s in GOT"),
			 gsym->name());
	      continue;
	    }

	  if (!gsym->is_weak_undefined())
	    {
	      const Sized_symbol<32>* sym =
		static_cast<const Sized_symbol<32>*>(gsym);
	      value = sym->value();
	    }
	  else
	      value = 0;
	}

      unsigned got_offset = reloc.got_offset();
      gold_assert(got_offset < oview_size);

      typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
      Valtype* wv = reinterpret_cast<Valtype*>(oview + got_offset);
      Valtype x;
      switch (reloc.r_type())
	{
	case elfcpp::R_ARM_TLS_DTPOFF32:
	  x = value;
	  break;
	case elfcpp::R_ARM_TLS_TPOFF32:
	  x = value + aligned_tcb_size;
	  break;
	default:
	  gold_unreachable();
	}
      elfcpp::Swap<32, big_endian>::writeval(wv, x);
    }

  of->write_output_view(offset, oview_size, oview);
}

// A class to handle the PLT data.
// This is an abstract base class that handles most of the linker details
// but does not know the actual contents of PLT entries.  The derived
// classes below fill in those details.

template<bool big_endian>
class Output_data_plt_arm : public Output_section_data
{
 public:
  typedef Output_data_reloc<elfcpp::SHT_REL, true, 32, big_endian>
    Reloc_section;

  Output_data_plt_arm(Layout*, uint64_t addralign, Output_data_space*);

  // Add an entry to the PLT.
  void
  add_entry(Symbol* gsym);

  // Return the .rel.plt section data.
  const Reloc_section*
  rel_plt() const
  { return this->rel_; }

  // Return the number of PLT entries.
  unsigned int
  entry_count() const
  { return this->count_; }

  // Return the offset of the first non-reserved PLT entry.
  unsigned int
  first_plt_entry_offset() const
  { return this->do_first_plt_entry_offset(); }

  // Return the size of a PLT entry.
  unsigned int
  get_plt_entry_size() const
  { return this->do_get_plt_entry_size(); }

 protected:
  // Fill in the first PLT entry.
  void
  fill_first_plt_entry(unsigned char* pov,
		       Arm_address got_address,
		       Arm_address plt_address)
  { this->do_fill_first_plt_entry(pov, got_address, plt_address); }

  void
  fill_plt_entry(unsigned char* pov,
		 Arm_address got_address,
		 Arm_address plt_address,
		 unsigned int got_offset,
		 unsigned int plt_offset)
  { do_fill_plt_entry(pov, got_address, plt_address, got_offset, plt_offset); }

  virtual unsigned int
  do_first_plt_entry_offset() const = 0;

  virtual unsigned int
  do_get_plt_entry_size() const = 0;

  virtual void
  do_fill_first_plt_entry(unsigned char* pov,
			  Arm_address got_address,
			  Arm_address plt_address) = 0;

  virtual void
  do_fill_plt_entry(unsigned char* pov,
		    Arm_address got_address,
		    Arm_address plt_address,
		    unsigned int got_offset,
		    unsigned int plt_offset) = 0;

  void
  do_adjust_output_section(Output_section* os);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** PLT")); }

 private:
  // Set the final size.
  void
  set_final_data_size()
  {
    this->set_data_size(this->first_plt_entry_offset()
			+ this->count_ * this->get_plt_entry_size());
  }

  // Write out the PLT data.
  void
  do_write(Output_file*);

  // The reloc section.
  Reloc_section* rel_;
  // The .got.plt section.
  Output_data_space* got_plt_;
  // The number of PLT entries.
  unsigned int count_;
};

// Create the PLT section.  The ordinary .got section is an argument,
// since we need to refer to the start.  We also create our own .got
// section just for PLT entries.

template<bool big_endian>
Output_data_plt_arm<big_endian>::Output_data_plt_arm(Layout* layout,
						     uint64_t addralign,
						     Output_data_space* got_plt)
  : Output_section_data(addralign), got_plt_(got_plt), count_(0)
{
  this->rel_ = new Reloc_section(false);
  layout->add_output_section_data(".rel.plt", elfcpp::SHT_REL,
				  elfcpp::SHF_ALLOC, this->rel_,
				  ORDER_DYNAMIC_PLT_RELOCS, false);
}

template<bool big_endian>
void
Output_data_plt_arm<big_endian>::do_adjust_output_section(Output_section* os)
{
  os->set_entsize(0);
}

// Add an entry to the PLT.

template<bool big_endian>
void
Output_data_plt_arm<big_endian>::add_entry(Symbol* gsym)
{
  gold_assert(!gsym->has_plt_offset());

  // Note that when setting the PLT offset we skip the initial
  // reserved PLT entry.
  gsym->set_plt_offset((this->count_) * this->get_plt_entry_size()
		       + this->first_plt_entry_offset());

  ++this->count_;

  section_offset_type got_offset = this->got_plt_->current_data_size();

  // Every PLT entry needs a GOT entry which points back to the PLT
  // entry (this will be changed by the dynamic linker, normally
  // lazily when the function is called).
  this->got_plt_->set_current_data_size(got_offset + 4);

  // Every PLT entry needs a reloc.
  gsym->set_needs_dynsym_entry();
  this->rel_->add_global(gsym, elfcpp::R_ARM_JUMP_SLOT, this->got_plt_,
			 got_offset);

  // Note that we don't need to save the symbol.  The contents of the
  // PLT are independent of which symbols are used.  The symbols only
  // appear in the relocations.
}

template<bool big_endian>
class Output_data_plt_arm_standard : public Output_data_plt_arm<big_endian>
{
 public:
  Output_data_plt_arm_standard(Layout* layout, Output_data_space* got_plt)
    : Output_data_plt_arm<big_endian>(layout, 4, got_plt)
  { }

 protected:
  // Return the offset of the first non-reserved PLT entry.
  virtual unsigned int
  do_first_plt_entry_offset() const
  { return sizeof(first_plt_entry); }

  // Return the size of a PLT entry.
  virtual unsigned int
  do_get_plt_entry_size() const
  { return sizeof(plt_entry); }

  virtual void
  do_fill_first_plt_entry(unsigned char* pov,
			  Arm_address got_address,
			  Arm_address plt_address);

  virtual void
  do_fill_plt_entry(unsigned char* pov,
		    Arm_address got_address,
		    Arm_address plt_address,
		    unsigned int got_offset,
		    unsigned int plt_offset);

 private:
  // Template for the first PLT entry.
  static const uint32_t first_plt_entry[5];

  // Template for subsequent PLT entries.
  static const uint32_t plt_entry[3];
};

// ARM PLTs.
// FIXME:  This is not very flexible.  Right now this has only been tested
// on armv5te.  If we are to support additional architecture features like
// Thumb-2 or BE8, we need to make this more flexible like GNU ld.

// The first entry in the PLT.
template<bool big_endian>
const uint32_t Output_data_plt_arm_standard<big_endian>::first_plt_entry[5] =
{
  0xe52de004,	// str   lr, [sp, #-4]!
  0xe59fe004,   // ldr   lr, [pc, #4]
  0xe08fe00e,	// add   lr, pc, lr
  0xe5bef008,	// ldr   pc, [lr, #8]!
  0x00000000,	// &GOT[0] - .
};

template<bool big_endian>
void
Output_data_plt_arm_standard<big_endian>::do_fill_first_plt_entry(
    unsigned char* pov,
    Arm_address got_address,
    Arm_address plt_address)
{
  // Write first PLT entry.  All but the last word are constants.
  const size_t num_first_plt_words = (sizeof(first_plt_entry)
				      / sizeof(plt_entry[0]));
  for (size_t i = 0; i < num_first_plt_words - 1; i++)
    elfcpp::Swap<32, big_endian>::writeval(pov + i * 4, first_plt_entry[i]);
  // Last word in first PLT entry is &GOT[0] - .
  elfcpp::Swap<32, big_endian>::writeval(pov + 16,
					 got_address - (plt_address + 16));
}

// Subsequent entries in the PLT.

template<bool big_endian>
const uint32_t Output_data_plt_arm_standard<big_endian>::plt_entry[3] =
{
  0xe28fc600,	// add   ip, pc, #0xNN00000
  0xe28cca00,	// add   ip, ip, #0xNN000
  0xe5bcf000,	// ldr   pc, [ip, #0xNNN]!
};

template<bool big_endian>
void
Output_data_plt_arm_standard<big_endian>::do_fill_plt_entry(
    unsigned char* pov,
    Arm_address got_address,
    Arm_address plt_address,
    unsigned int got_offset,
    unsigned int plt_offset)
{
  int32_t offset = ((got_address + got_offset)
		    - (plt_address + plt_offset + 8));

  gold_assert(offset >= 0 && offset < 0x0fffffff);
  uint32_t plt_insn0 = plt_entry[0] | ((offset >> 20) & 0xff);
  elfcpp::Swap<32, big_endian>::writeval(pov, plt_insn0);
  uint32_t plt_insn1 = plt_entry[1] | ((offset >> 12) & 0xff);
  elfcpp::Swap<32, big_endian>::writeval(pov + 4, plt_insn1);
  uint32_t plt_insn2 = plt_entry[2] | (offset & 0xfff);
  elfcpp::Swap<32, big_endian>::writeval(pov + 8, plt_insn2);
}

// Write out the PLT.  This uses the hand-coded instructions above,
// and adjusts them as needed.  This is all specified by the arm ELF
// Processor Supplement.

template<bool big_endian>
void
Output_data_plt_arm<big_endian>::do_write(Output_file* of)
{
  const off_t offset = this->offset();
  const section_size_type oview_size =
    convert_to_section_size_type(this->data_size());
  unsigned char* const oview = of->get_output_view(offset, oview_size);

  const off_t got_file_offset = this->got_plt_->offset();
  const section_size_type got_size =
    convert_to_section_size_type(this->got_plt_->data_size());
  unsigned char* const got_view = of->get_output_view(got_file_offset,
						      got_size);
  unsigned char* pov = oview;

  Arm_address plt_address = this->address();
  Arm_address got_address = this->got_plt_->address();

  // Write first PLT entry.
  this->fill_first_plt_entry(pov, got_address, plt_address);
  pov += this->first_plt_entry_offset();

  unsigned char* got_pov = got_view;

  memset(got_pov, 0, 12);
  got_pov += 12;

  unsigned int plt_offset = this->first_plt_entry_offset();
  unsigned int got_offset = 12;
  const unsigned int count = this->count_;
  for (unsigned int i = 0;
       i < count;
       ++i,
	 pov += this->get_plt_entry_size(),
	 got_pov += 4,
	 plt_offset += this->get_plt_entry_size(),
	 got_offset += 4)
    {
      // Set and adjust the PLT entry itself.
      this->fill_plt_entry(pov, got_address, plt_address,
			   got_offset, plt_offset);

      // Set the entry in the GOT.
      elfcpp::Swap<32, big_endian>::writeval(got_pov, plt_address);
    }

  gold_assert(static_cast<section_size_type>(pov - oview) == oview_size);
  gold_assert(static_cast<section_size_type>(got_pov - got_view) == got_size);

  of->write_output_view(offset, oview_size, oview);
  of->write_output_view(got_file_offset, got_size, got_view);
}

// Create a PLT entry for a global symbol.

template<bool big_endian>
void
Target_arm<big_endian>::make_plt_entry(Symbol_table* symtab, Layout* layout,
				       Symbol* gsym)
{
  if (gsym->has_plt_offset())
    return;

  if (this->plt_ == NULL)
    {
      // Create the GOT sections first.
      this->got_section(symtab, layout);

      this->plt_ = this->make_data_plt(layout, this->got_plt_);

      layout->add_output_section_data(".plt", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_EXECINSTR),
				      this->plt_, ORDER_PLT, false);
    }
  this->plt_->add_entry(gsym);
}

// Return the number of entries in the PLT.

template<bool big_endian>
unsigned int
Target_arm<big_endian>::plt_entry_count() const
{
  if (this->plt_ == NULL)
    return 0;
  return this->plt_->entry_count();
}

// Return the offset of the first non-reserved PLT entry.

template<bool big_endian>
unsigned int
Target_arm<big_endian>::first_plt_entry_offset() const
{
  return this->plt_->first_plt_entry_offset();
}

// Return the size of each PLT entry.

template<bool big_endian>
unsigned int
Target_arm<big_endian>::plt_entry_size() const
{
  return this->plt_->get_plt_entry_size();
}

// Get the section to use for TLS_DESC relocations.

template<bool big_endian>
typename Target_arm<big_endian>::Reloc_section*
Target_arm<big_endian>::rel_tls_desc_section(Layout* layout) const
{
  return this->plt_section()->rel_tls_desc(layout);
}

// Define the _TLS_MODULE_BASE_ symbol in the TLS segment.

template<bool big_endian>
void
Target_arm<big_endian>::define_tls_base_symbol(
    Symbol_table* symtab,
    Layout* layout)
{
  if (this->tls_base_symbol_defined_)
    return;

  Output_segment* tls_segment = layout->tls_segment();
  if (tls_segment != NULL)
    {
      bool is_exec = parameters->options().output_is_executable();
      symtab->define_in_output_segment("_TLS_MODULE_BASE_", NULL,
				       Symbol_table::PREDEFINED,
				       tls_segment, 0, 0,
				       elfcpp::STT_TLS,
				       elfcpp::STB_LOCAL,
				       elfcpp::STV_HIDDEN, 0,
				       (is_exec
					? Symbol::SEGMENT_END
					: Symbol::SEGMENT_START),
				       true);
    }
  this->tls_base_symbol_defined_ = true;
}

// Create a GOT entry for the TLS module index.

template<bool big_endian>
unsigned int
Target_arm<big_endian>::got_mod_index_entry(
    Symbol_table* symtab,
    Layout* layout,
    Sized_relobj_file<32, big_endian>* object)
{
  if (this->got_mod_index_offset_ == -1U)
    {
      gold_assert(symtab != NULL && layout != NULL && object != NULL);
      Arm_output_data_got<big_endian>* got = this->got_section(symtab, layout);
      unsigned int got_offset;
      if (!parameters->doing_static_link())
	{
	  got_offset = got->add_constant(0);
	  Reloc_section* rel_dyn = this->rel_dyn_section(layout);
	  rel_dyn->add_local(object, 0, elfcpp::R_ARM_TLS_DTPMOD32, got,
			     got_offset);
	}
      else
	{
	  // We are doing a static link.  Just mark it as belong to module 1,
	  // the executable.
	  got_offset = got->add_constant(1);
	}

      got->add_constant(0);
      this->got_mod_index_offset_ = got_offset;
    }
  return this->got_mod_index_offset_;
}

// Optimize the TLS relocation type based on what we know about the
// symbol.  IS_FINAL is true if the final address of this symbol is
// known at link time.

template<bool big_endian>
tls::Tls_optimization
Target_arm<big_endian>::optimize_tls_reloc(bool, int)
{
  // FIXME: Currently we do not do any TLS optimization.
  return tls::TLSOPT_NONE;
}

// Get the Reference_flags for a particular relocation.

template<bool big_endian>
int
Target_arm<big_endian>::Scan::get_reference_flags(unsigned int r_type)
{
  switch (r_type)
    {
    case elfcpp::R_ARM_NONE:
    case elfcpp::R_ARM_V4BX:
    case elfcpp::R_ARM_GNU_VTENTRY:
    case elfcpp::R_ARM_GNU_VTINHERIT:
      // No symbol reference.
      return 0;

    case elfcpp::R_ARM_ABS32:
    case elfcpp::R_ARM_ABS16:
    case elfcpp::R_ARM_ABS12:
    case elfcpp::R_ARM_THM_ABS5:
    case elfcpp::R_ARM_ABS8:
    case elfcpp::R_ARM_BASE_ABS:
    case elfcpp::R_ARM_MOVW_ABS_NC:
    case elfcpp::R_ARM_MOVT_ABS:
    case elfcpp::R_ARM_THM_MOVW_ABS_NC:
    case elfcpp::R_ARM_THM_MOVT_ABS:
    case elfcpp::R_ARM_ABS32_NOI:
      return Symbol::ABSOLUTE_REF;

    case elfcpp::R_ARM_REL32:
    case elfcpp::R_ARM_LDR_PC_G0:
    case elfcpp::R_ARM_SBREL32:
    case elfcpp::R_ARM_THM_PC8:
    case elfcpp::R_ARM_BASE_PREL:
    case elfcpp::R_ARM_MOVW_PREL_NC:
    case elfcpp::R_ARM_MOVT_PREL:
    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
    case elfcpp::R_ARM_THM_MOVT_PREL:
    case elfcpp::R_ARM_THM_ALU_PREL_11_0:
    case elfcpp::R_ARM_THM_PC12:
    case elfcpp::R_ARM_REL32_NOI:
    case elfcpp::R_ARM_ALU_PC_G0_NC:
    case elfcpp::R_ARM_ALU_PC_G0:
    case elfcpp::R_ARM_ALU_PC_G1_NC:
    case elfcpp::R_ARM_ALU_PC_G1:
    case elfcpp::R_ARM_ALU_PC_G2:
    case elfcpp::R_ARM_LDR_PC_G1:
    case elfcpp::R_ARM_LDR_PC_G2:
    case elfcpp::R_ARM_LDRS_PC_G0:
    case elfcpp::R_ARM_LDRS_PC_G1:
    case elfcpp::R_ARM_LDRS_PC_G2:
    case elfcpp::R_ARM_LDC_PC_G0:
    case elfcpp::R_ARM_LDC_PC_G1:
    case elfcpp::R_ARM_LDC_PC_G2:
    case elfcpp::R_ARM_ALU_SB_G0_NC:
    case elfcpp::R_ARM_ALU_SB_G0:
    case elfcpp::R_ARM_ALU_SB_G1_NC:
    case elfcpp::R_ARM_ALU_SB_G1:
    case elfcpp::R_ARM_ALU_SB_G2:
    case elfcpp::R_ARM_LDR_SB_G0:
    case elfcpp::R_ARM_LDR_SB_G1:
    case elfcpp::R_ARM_LDR_SB_G2:
    case elfcpp::R_ARM_LDRS_SB_G0:
    case elfcpp::R_ARM_LDRS_SB_G1:
    case elfcpp::R_ARM_LDRS_SB_G2:
    case elfcpp::R_ARM_LDC_SB_G0:
    case elfcpp::R_ARM_LDC_SB_G1:
    case elfcpp::R_ARM_LDC_SB_G2:
    case elfcpp::R_ARM_MOVW_BREL_NC:
    case elfcpp::R_ARM_MOVT_BREL:
    case elfcpp::R_ARM_MOVW_BREL:
    case elfcpp::R_ARM_THM_MOVW_BREL_NC:
    case elfcpp::R_ARM_THM_MOVT_BREL:
    case elfcpp::R_ARM_THM_MOVW_BREL:
    case elfcpp::R_ARM_GOTOFF32:
    case elfcpp::R_ARM_GOTOFF12:
    case elfcpp::R_ARM_SBREL31:
      return Symbol::RELATIVE_REF;

    case elfcpp::R_ARM_PLT32:
    case elfcpp::R_ARM_CALL:
    case elfcpp::R_ARM_JUMP24:
    case elfcpp::R_ARM_THM_CALL:
    case elfcpp::R_ARM_THM_JUMP24:
    case elfcpp::R_ARM_THM_JUMP19:
    case elfcpp::R_ARM_THM_JUMP6:
    case elfcpp::R_ARM_THM_JUMP11:
    case elfcpp::R_ARM_THM_JUMP8:
    // R_ARM_PREL31 is not used to relocate call/jump instructions but
    // in unwind tables. It may point to functions via PLTs.
    // So we treat it like call/jump relocations above.
    case elfcpp::R_ARM_PREL31:
      return Symbol::FUNCTION_CALL | Symbol::RELATIVE_REF;

    case elfcpp::R_ARM_GOT_BREL:
    case elfcpp::R_ARM_GOT_ABS:
    case elfcpp::R_ARM_GOT_PREL:
      // Absolute in GOT.
      return Symbol::ABSOLUTE_REF;

    case elfcpp::R_ARM_TLS_GD32:	// Global-dynamic
    case elfcpp::R_ARM_TLS_LDM32:	// Local-dynamic
    case elfcpp::R_ARM_TLS_LDO32:	// Alternate local-dynamic
    case elfcpp::R_ARM_TLS_IE32:	// Initial-exec
    case elfcpp::R_ARM_TLS_LE32:	// Local-exec
      return Symbol::TLS_REF;

    case elfcpp::R_ARM_TARGET1:
    case elfcpp::R_ARM_TARGET2:
    case elfcpp::R_ARM_COPY:
    case elfcpp::R_ARM_GLOB_DAT:
    case elfcpp::R_ARM_JUMP_SLOT:
    case elfcpp::R_ARM_RELATIVE:
    case elfcpp::R_ARM_PC24:
    case elfcpp::R_ARM_LDR_SBREL_11_0_NC:
    case elfcpp::R_ARM_ALU_SBREL_19_12_NC:
    case elfcpp::R_ARM_ALU_SBREL_27_20_CK:
    default:
      // Not expected.  We will give an error later.
      return 0;
    }
}

// Report an unsupported relocation against a local symbol.

template<bool big_endian>
void
Target_arm<big_endian>::Scan::unsupported_reloc_local(
    Sized_relobj_file<32, big_endian>* object,
    unsigned int r_type)
{
  gold_error(_("%s: unsupported reloc %u against local symbol"),
	     object->name().c_str(), r_type);
}

// We are about to emit a dynamic relocation of type R_TYPE.  If the
// dynamic linker does not support it, issue an error.  The GNU linker
// only issues a non-PIC error for an allocated read-only section.
// Here we know the section is allocated, but we don't know that it is
// read-only.  But we check for all the relocation types which the
// glibc dynamic linker supports, so it seems appropriate to issue an
// error even if the section is not read-only.

template<bool big_endian>
void
Target_arm<big_endian>::Scan::check_non_pic(Relobj* object,
					    unsigned int r_type)
{
  switch (r_type)
    {
    // These are the relocation types supported by glibc for ARM.
    case elfcpp::R_ARM_RELATIVE:
    case elfcpp::R_ARM_COPY:
    case elfcpp::R_ARM_GLOB_DAT:
    case elfcpp::R_ARM_JUMP_SLOT:
    case elfcpp::R_ARM_ABS32:
    case elfcpp::R_ARM_ABS32_NOI:
    case elfcpp::R_ARM_PC24:
    // FIXME: The following 3 types are not supported by Android's dynamic
    // linker.
    case elfcpp::R_ARM_TLS_DTPMOD32:
    case elfcpp::R_ARM_TLS_DTPOFF32:
    case elfcpp::R_ARM_TLS_TPOFF32:
      return;

    default:
      {
	// This prevents us from issuing more than one error per reloc
	// section.  But we can still wind up issuing more than one
	// error per object file.
	if (this->issued_non_pic_error_)
	  return;
	const Arm_reloc_property* reloc_property =
	  arm_reloc_property_table->get_reloc_property(r_type);
	gold_assert(reloc_property != NULL);
	object->error(_("requires unsupported dynamic reloc %s; "
		      "recompile with -fPIC"),
		      reloc_property->name().c_str());
	this->issued_non_pic_error_ = true;
	return;
      }

    case elfcpp::R_ARM_NONE:
      gold_unreachable();
    }
}

// Scan a relocation for a local symbol.
// FIXME: This only handles a subset of relocation types used by Android
// on ARM v5te devices.

template<bool big_endian>
inline void
Target_arm<big_endian>::Scan::local(Symbol_table* symtab,
				    Layout* layout,
				    Target_arm* target,
				    Sized_relobj_file<32, big_endian>* object,
				    unsigned int data_shndx,
				    Output_section* output_section,
				    const elfcpp::Rel<32, big_endian>& reloc,
				    unsigned int r_type,
				    const elfcpp::Sym<32, big_endian>& lsym,
				    bool is_discarded)
{
  if (is_discarded)
    return;

  r_type = get_real_reloc_type(r_type);
  switch (r_type)
    {
    case elfcpp::R_ARM_NONE:
    case elfcpp::R_ARM_V4BX:
    case elfcpp::R_ARM_GNU_VTENTRY:
    case elfcpp::R_ARM_GNU_VTINHERIT:
      break;

    case elfcpp::R_ARM_ABS32:
    case elfcpp::R_ARM_ABS32_NOI:
      // If building a shared library (or a position-independent
      // executable), we need to create a dynamic relocation for
      // this location. The relocation applied at link time will
      // apply the link-time value, so we flag the location with
      // an R_ARM_RELATIVE relocation so the dynamic loader can
      // relocate it easily.
      if (parameters->options().output_is_position_independent())
	{
	  Reloc_section* rel_dyn = target->rel_dyn_section(layout);
	  unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
	  // If we are to add more other reloc types than R_ARM_ABS32,
	  // we need to add check_non_pic(object, r_type) here.
	  rel_dyn->add_local_relative(object, r_sym, elfcpp::R_ARM_RELATIVE,
				      output_section, data_shndx,
				      reloc.get_r_offset());
	}
      break;

    case elfcpp::R_ARM_ABS16:
    case elfcpp::R_ARM_ABS12:
    case elfcpp::R_ARM_THM_ABS5:
    case elfcpp::R_ARM_ABS8:
    case elfcpp::R_ARM_BASE_ABS:
    case elfcpp::R_ARM_MOVW_ABS_NC:
    case elfcpp::R_ARM_MOVT_ABS:
    case elfcpp::R_ARM_THM_MOVW_ABS_NC:
    case elfcpp::R_ARM_THM_MOVT_ABS:
      // If building a shared library (or a position-independent
      // executable), we need to create a dynamic relocation for
      // this location. Because the addend needs to remain in the
      // data section, we need to be careful not to apply this
      // relocation statically.
      if (parameters->options().output_is_position_independent())
	{
	  check_non_pic(object, r_type);
	  Reloc_section* rel_dyn = target->rel_dyn_section(layout);
	  unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
	  if (lsym.get_st_type() != elfcpp::STT_SECTION)
	    rel_dyn->add_local(object, r_sym, r_type, output_section,
			       data_shndx, reloc.get_r_offset());
	  else
	    {
	      gold_assert(lsym.get_st_value() == 0);
	      unsigned int shndx = lsym.get_st_shndx();
	      bool is_ordinary;
	      shndx = object->adjust_sym_shndx(r_sym, shndx,
					       &is_ordinary);
	      if (!is_ordinary)
		object->error(_("section symbol %u has bad shndx %u"),
			      r_sym, shndx);
	      else
		rel_dyn->add_local_section(object, shndx,
					   r_type, output_section,
					   data_shndx, reloc.get_r_offset());
	    }
	}
      break;

    case elfcpp::R_ARM_REL32:
    case elfcpp::R_ARM_LDR_PC_G0:
    case elfcpp::R_ARM_SBREL32:
    case elfcpp::R_ARM_THM_CALL:
    case elfcpp::R_ARM_THM_PC8:
    case elfcpp::R_ARM_BASE_PREL:
    case elfcpp::R_ARM_PLT32:
    case elfcpp::R_ARM_CALL:
    case elfcpp::R_ARM_JUMP24:
    case elfcpp::R_ARM_THM_JUMP24:
    case elfcpp::R_ARM_SBREL31:
    case elfcpp::R_ARM_PREL31:
    case elfcpp::R_ARM_MOVW_PREL_NC:
    case elfcpp::R_ARM_MOVT_PREL:
    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
    case elfcpp::R_ARM_THM_MOVT_PREL:
    case elfcpp::R_ARM_THM_JUMP19:
    case elfcpp::R_ARM_THM_JUMP6:
    case elfcpp::R_ARM_THM_ALU_PREL_11_0:
    case elfcpp::R_ARM_THM_PC12:
    case elfcpp::R_ARM_REL32_NOI:
    case elfcpp::R_ARM_ALU_PC_G0_NC:
    case elfcpp::R_ARM_ALU_PC_G0:
    case elfcpp::R_ARM_ALU_PC_G1_NC:
    case elfcpp::R_ARM_ALU_PC_G1:
    case elfcpp::R_ARM_ALU_PC_G2:
    case elfcpp::R_ARM_LDR_PC_G1:
    case elfcpp::R_ARM_LDR_PC_G2:
    case elfcpp::R_ARM_LDRS_PC_G0:
    case elfcpp::R_ARM_LDRS_PC_G1:
    case elfcpp::R_ARM_LDRS_PC_G2:
    case elfcpp::R_ARM_LDC_PC_G0:
    case elfcpp::R_ARM_LDC_PC_G1:
    case elfcpp::R_ARM_LDC_PC_G2:
    case elfcpp::R_ARM_ALU_SB_G0_NC:
    case elfcpp::R_ARM_ALU_SB_G0:
    case elfcpp::R_ARM_ALU_SB_G1_NC:
    case elfcpp::R_ARM_ALU_SB_G1:
    case elfcpp::R_ARM_ALU_SB_G2:
    case elfcpp::R_ARM_LDR_SB_G0:
    case elfcpp::R_ARM_LDR_SB_G1:
    case elfcpp::R_ARM_LDR_SB_G2:
    case elfcpp::R_ARM_LDRS_SB_G0:
    case elfcpp::R_ARM_LDRS_SB_G1:
    case elfcpp::R_ARM_LDRS_SB_G2:
    case elfcpp::R_ARM_LDC_SB_G0:
    case elfcpp::R_ARM_LDC_SB_G1:
    case elfcpp::R_ARM_LDC_SB_G2:
    case elfcpp::R_ARM_MOVW_BREL_NC:
    case elfcpp::R_ARM_MOVT_BREL:
    case elfcpp::R_ARM_MOVW_BREL:
    case elfcpp::R_ARM_THM_MOVW_BREL_NC:
    case elfcpp::R_ARM_THM_MOVT_BREL:
    case elfcpp::R_ARM_THM_MOVW_BREL:
    case elfcpp::R_ARM_THM_JUMP11:
    case elfcpp::R_ARM_THM_JUMP8:
      // We don't need to do anything for a relative addressing relocation
      // against a local symbol if it does not reference the GOT.
      break;

    case elfcpp::R_ARM_GOTOFF32:
    case elfcpp::R_ARM_GOTOFF12:
      // We need a GOT section:
      target->got_section(symtab, layout);
      break;

    case elfcpp::R_ARM_GOT_BREL:
    case elfcpp::R_ARM_GOT_PREL:
      {
	// The symbol requires a GOT entry.
	Arm_output_data_got<big_endian>* got =
	  target->got_section(symtab, layout);
	unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
	if (got->add_local(object, r_sym, GOT_TYPE_STANDARD))
	  {
	    // If we are generating a shared object, we need to add a
	    // dynamic RELATIVE relocation for this symbol's GOT entry.
	    if (parameters->options().output_is_position_independent())
	      {
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
		rel_dyn->add_local_relative(
		    object, r_sym, elfcpp::R_ARM_RELATIVE, got,
		    object->local_got_offset(r_sym, GOT_TYPE_STANDARD));
	      }
	  }
      }
      break;

    case elfcpp::R_ARM_TARGET1:
    case elfcpp::R_ARM_TARGET2:
      // This should have been mapped to another type already.
      // Fall through.
    case elfcpp::R_ARM_COPY:
    case elfcpp::R_ARM_GLOB_DAT:
    case elfcpp::R_ARM_JUMP_SLOT:
    case elfcpp::R_ARM_RELATIVE:
      // These are relocations which should only be seen by the
      // dynamic linker, and should never be seen here.
      gold_error(_("%s: unexpected reloc %u in object file"),
		 object->name().c_str(), r_type);
      break;


      // These are initial TLS relocs, which are expected when
      // linking.
    case elfcpp::R_ARM_TLS_GD32:	// Global-dynamic
    case elfcpp::R_ARM_TLS_LDM32:	// Local-dynamic
    case elfcpp::R_ARM_TLS_LDO32:	// Alternate local-dynamic
    case elfcpp::R_ARM_TLS_IE32:	// Initial-exec
    case elfcpp::R_ARM_TLS_LE32:	// Local-exec
      {
	bool output_is_shared = parameters->options().shared();
	const tls::Tls_optimization optimized_type
	    = Target_arm<big_endian>::optimize_tls_reloc(!output_is_shared,
							 r_type);
	switch (r_type)
	  {
	  case elfcpp::R_ARM_TLS_GD32:		// Global-dynamic
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a pair of GOT entries for the module index and
		// dtv-relative offset.
		Arm_output_data_got<big_endian>* got
		    = target->got_section(symtab, layout);
		unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
		unsigned int shndx = lsym.get_st_shndx();
		bool is_ordinary;
		shndx = object->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
		if (!is_ordinary)
		  {
		    object->error(_("local symbol %u has bad shndx %u"),
				  r_sym, shndx);
		    break;
		  }

		if (!parameters->doing_static_link())
		  got->add_local_pair_with_rel(object, r_sym, shndx,
					       GOT_TYPE_TLS_PAIR,
					       target->rel_dyn_section(layout),
					       elfcpp::R_ARM_TLS_DTPMOD32);
		else
		  got->add_tls_gd32_with_static_reloc(GOT_TYPE_TLS_PAIR,
						      object, r_sym);
	      }
	    else
	      // FIXME: TLS optimization not supported yet.
	      gold_unreachable();
	    break;

	  case elfcpp::R_ARM_TLS_LDM32:		// Local-dynamic
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a GOT entry for the module index.
		target->got_mod_index_entry(symtab, layout, object);
	      }
	    else
	      // FIXME: TLS optimization not supported yet.
	      gold_unreachable();
	    break;

	  case elfcpp::R_ARM_TLS_LDO32:		// Alternate local-dynamic
	    break;

	  case elfcpp::R_ARM_TLS_IE32:		// Initial-exec
	    layout->set_has_static_tls();
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a GOT entry for the tp-relative offset.
		Arm_output_data_got<big_endian>* got
		  = target->got_section(symtab, layout);
		unsigned int r_sym =
		   elfcpp::elf_r_sym<32>(reloc.get_r_info());
		if (!parameters->doing_static_link())
		    got->add_local_with_rel(object, r_sym, GOT_TYPE_TLS_OFFSET,
					    target->rel_dyn_section(layout),
					    elfcpp::R_ARM_TLS_TPOFF32);
		else if (!object->local_has_got_offset(r_sym,
						       GOT_TYPE_TLS_OFFSET))
		  {
		    got->add_local(object, r_sym, GOT_TYPE_TLS_OFFSET);
		    unsigned int got_offset =
		      object->local_got_offset(r_sym, GOT_TYPE_TLS_OFFSET);
		    got->add_static_reloc(got_offset,
					  elfcpp::R_ARM_TLS_TPOFF32, object,
					  r_sym);
		  }
	      }
	    else
	      // FIXME: TLS optimization not supported yet.
	      gold_unreachable();
	    break;

	  case elfcpp::R_ARM_TLS_LE32:		// Local-exec
	    layout->set_has_static_tls();
	    if (output_is_shared)
	      {
		// We need to create a dynamic relocation.
		gold_assert(lsym.get_st_type() != elfcpp::STT_SECTION);
		unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		rel_dyn->add_local(object, r_sym, elfcpp::R_ARM_TLS_TPOFF32,
				   output_section, data_shndx,
				   reloc.get_r_offset());
	      }
	    break;

	  default:
	    gold_unreachable();
	  }
      }
      break;

    case elfcpp::R_ARM_PC24:
    case elfcpp::R_ARM_LDR_SBREL_11_0_NC:
    case elfcpp::R_ARM_ALU_SBREL_19_12_NC:
    case elfcpp::R_ARM_ALU_SBREL_27_20_CK:
    default:
      unsupported_reloc_local(object, r_type);
      break;
    }
}

// Report an unsupported relocation against a global symbol.

template<bool big_endian>
void
Target_arm<big_endian>::Scan::unsupported_reloc_global(
    Sized_relobj_file<32, big_endian>* object,
    unsigned int r_type,
    Symbol* gsym)
{
  gold_error(_("%s: unsupported reloc %u against global symbol %s"),
	     object->name().c_str(), r_type, gsym->demangled_name().c_str());
}

template<bool big_endian>
inline bool
Target_arm<big_endian>::Scan::possible_function_pointer_reloc(
    unsigned int r_type)
{
  switch (r_type)
    {
    case elfcpp::R_ARM_PC24:
    case elfcpp::R_ARM_THM_CALL:
    case elfcpp::R_ARM_PLT32:
    case elfcpp::R_ARM_CALL:
    case elfcpp::R_ARM_JUMP24:
    case elfcpp::R_ARM_THM_JUMP24:
    case elfcpp::R_ARM_SBREL31:
    case elfcpp::R_ARM_PREL31:
    case elfcpp::R_ARM_THM_JUMP19:
    case elfcpp::R_ARM_THM_JUMP6:
    case elfcpp::R_ARM_THM_JUMP11:
    case elfcpp::R_ARM_THM_JUMP8:
      // All the relocations above are branches except SBREL31 and PREL31.
      return false;

    default:
      // Be conservative and assume this is a function pointer.
      return true;
    }
}

template<bool big_endian>
inline bool
Target_arm<big_endian>::Scan::local_reloc_may_be_function_pointer(
  Symbol_table*,
  Layout*,
  Target_arm<big_endian>* target,
  Sized_relobj_file<32, big_endian>*,
  unsigned int,
  Output_section*,
  const elfcpp::Rel<32, big_endian>&,
  unsigned int r_type,
  const elfcpp::Sym<32, big_endian>&)
{
  r_type = target->get_real_reloc_type(r_type);
  return possible_function_pointer_reloc(r_type);
}

template<bool big_endian>
inline bool
Target_arm<big_endian>::Scan::global_reloc_may_be_function_pointer(
  Symbol_table*,
  Layout*,
  Target_arm<big_endian>* target,
  Sized_relobj_file<32, big_endian>*,
  unsigned int,
  Output_section*,
  const elfcpp::Rel<32, big_endian>&,
  unsigned int r_type,
  Symbol* gsym)
{
  // GOT is not a function.
  if (strcmp(gsym->name(), "_GLOBAL_OFFSET_TABLE_") == 0)
    return false;

  r_type = target->get_real_reloc_type(r_type);
  return possible_function_pointer_reloc(r_type);
}

// Scan a relocation for a global symbol.

template<bool big_endian>
inline void
Target_arm<big_endian>::Scan::global(Symbol_table* symtab,
				     Layout* layout,
				     Target_arm* target,
				     Sized_relobj_file<32, big_endian>* object,
				     unsigned int data_shndx,
				     Output_section* output_section,
				     const elfcpp::Rel<32, big_endian>& reloc,
				     unsigned int r_type,
				     Symbol* gsym)
{
  // A reference to _GLOBAL_OFFSET_TABLE_ implies that we need a got
  // section.  We check here to avoid creating a dynamic reloc against
  // _GLOBAL_OFFSET_TABLE_.
  if (!target->has_got_section()
      && strcmp(gsym->name(), "_GLOBAL_OFFSET_TABLE_") == 0)
    target->got_section(symtab, layout);

  r_type = get_real_reloc_type(r_type);
  switch (r_type)
    {
    case elfcpp::R_ARM_NONE:
    case elfcpp::R_ARM_V4BX:
    case elfcpp::R_ARM_GNU_VTENTRY:
    case elfcpp::R_ARM_GNU_VTINHERIT:
      break;

    case elfcpp::R_ARM_ABS32:
    case elfcpp::R_ARM_ABS16:
    case elfcpp::R_ARM_ABS12:
    case elfcpp::R_ARM_THM_ABS5:
    case elfcpp::R_ARM_ABS8:
    case elfcpp::R_ARM_BASE_ABS:
    case elfcpp::R_ARM_MOVW_ABS_NC:
    case elfcpp::R_ARM_MOVT_ABS:
    case elfcpp::R_ARM_THM_MOVW_ABS_NC:
    case elfcpp::R_ARM_THM_MOVT_ABS:
    case elfcpp::R_ARM_ABS32_NOI:
      // Absolute addressing relocations.
      {
	// Make a PLT entry if necessary.
	if (this->symbol_needs_plt_entry(gsym))
	  {
	    target->make_plt_entry(symtab, layout, gsym);
	    // Since this is not a PC-relative relocation, we may be
	    // taking the address of a function. In that case we need to
	    // set the entry in the dynamic symbol table to the address of
	    // the PLT entry.
	    if (gsym->is_from_dynobj() && !parameters->options().shared())
	      gsym->set_needs_dynsym_value();
	  }
	// Make a dynamic relocation if necessary.
	if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
	  {
	    if (gsym->may_need_copy_reloc())
	      {
		target->copy_reloc(symtab, layout, object,
				   data_shndx, output_section, gsym, reloc);
	      }
	    else if ((r_type == elfcpp::R_ARM_ABS32
		      || r_type == elfcpp::R_ARM_ABS32_NOI)
		     && gsym->can_use_relative_reloc(false))
	      {
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		rel_dyn->add_global_relative(gsym, elfcpp::R_ARM_RELATIVE,
					     output_section, object,
					     data_shndx, reloc.get_r_offset());
	      }
	    else
	      {
		check_non_pic(object, r_type);
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		rel_dyn->add_global(gsym, r_type, output_section, object,
				    data_shndx, reloc.get_r_offset());
	      }
	  }
      }
      break;

    case elfcpp::R_ARM_GOTOFF32:
    case elfcpp::R_ARM_GOTOFF12:
      // We need a GOT section.
      target->got_section(symtab, layout);
      break;

    case elfcpp::R_ARM_REL32:
    case elfcpp::R_ARM_LDR_PC_G0:
    case elfcpp::R_ARM_SBREL32:
    case elfcpp::R_ARM_THM_PC8:
    case elfcpp::R_ARM_BASE_PREL:
    case elfcpp::R_ARM_MOVW_PREL_NC:
    case elfcpp::R_ARM_MOVT_PREL:
    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
    case elfcpp::R_ARM_THM_MOVT_PREL:
    case elfcpp::R_ARM_THM_ALU_PREL_11_0:
    case elfcpp::R_ARM_THM_PC12:
    case elfcpp::R_ARM_REL32_NOI:
    case elfcpp::R_ARM_ALU_PC_G0_NC:
    case elfcpp::R_ARM_ALU_PC_G0:
    case elfcpp::R_ARM_ALU_PC_G1_NC:
    case elfcpp::R_ARM_ALU_PC_G1:
    case elfcpp::R_ARM_ALU_PC_G2:
    case elfcpp::R_ARM_LDR_PC_G1:
    case elfcpp::R_ARM_LDR_PC_G2:
    case elfcpp::R_ARM_LDRS_PC_G0:
    case elfcpp::R_ARM_LDRS_PC_G1:
    case elfcpp::R_ARM_LDRS_PC_G2:
    case elfcpp::R_ARM_LDC_PC_G0:
    case elfcpp::R_ARM_LDC_PC_G1:
    case elfcpp::R_ARM_LDC_PC_G2:
    case elfcpp::R_ARM_ALU_SB_G0_NC:
    case elfcpp::R_ARM_ALU_SB_G0:
    case elfcpp::R_ARM_ALU_SB_G1_NC:
    case elfcpp::R_ARM_ALU_SB_G1:
    case elfcpp::R_ARM_ALU_SB_G2:
    case elfcpp::R_ARM_LDR_SB_G0:
    case elfcpp::R_ARM_LDR_SB_G1:
    case elfcpp::R_ARM_LDR_SB_G2:
    case elfcpp::R_ARM_LDRS_SB_G0:
    case elfcpp::R_ARM_LDRS_SB_G1:
    case elfcpp::R_ARM_LDRS_SB_G2:
    case elfcpp::R_ARM_LDC_SB_G0:
    case elfcpp::R_ARM_LDC_SB_G1:
    case elfcpp::R_ARM_LDC_SB_G2:
    case elfcpp::R_ARM_MOVW_BREL_NC:
    case elfcpp::R_ARM_MOVT_BREL:
    case elfcpp::R_ARM_MOVW_BREL:
    case elfcpp::R_ARM_THM_MOVW_BREL_NC:
    case elfcpp::R_ARM_THM_MOVT_BREL:
    case elfcpp::R_ARM_THM_MOVW_BREL:
      // Relative addressing relocations.
      {
	// Make a dynamic relocation if necessary.
	if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
	  {
	    if (target->may_need_copy_reloc(gsym))
	      {
		target->copy_reloc(symtab, layout, object,
				   data_shndx, output_section, gsym, reloc);
	      }
	    else
	      {
		check_non_pic(object, r_type);
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		rel_dyn->add_global(gsym, r_type, output_section, object,
				    data_shndx, reloc.get_r_offset());
	      }
	  }
      }
      break;

    case elfcpp::R_ARM_THM_CALL:
    case elfcpp::R_ARM_PLT32:
    case elfcpp::R_ARM_CALL:
    case elfcpp::R_ARM_JUMP24:
    case elfcpp::R_ARM_THM_JUMP24:
    case elfcpp::R_ARM_SBREL31:
    case elfcpp::R_ARM_PREL31:
    case elfcpp::R_ARM_THM_JUMP19:
    case elfcpp::R_ARM_THM_JUMP6:
    case elfcpp::R_ARM_THM_JUMP11:
    case elfcpp::R_ARM_THM_JUMP8:
      // All the relocation above are branches except for the PREL31 ones.
      // A PREL31 relocation can point to a personality function in a shared
      // library.  In that case we want to use a PLT because we want to
      // call the personality routine and the dynamic linkers we care about
      // do not support dynamic PREL31 relocations. An REL31 relocation may
      // point to a function whose unwinding behaviour is being described but
      // we will not mistakenly generate a PLT for that because we should use
      // a local section symbol.

      // If the symbol is fully resolved, this is just a relative
      // local reloc.  Otherwise we need a PLT entry.
      if (gsym->final_value_is_known())
	break;
      // If building a shared library, we can also skip the PLT entry
      // if the symbol is defined in the output file and is protected
      // or hidden.
      if (gsym->is_defined()
	  && !gsym->is_from_dynobj()
	  && !gsym->is_preemptible())
	break;
      target->make_plt_entry(symtab, layout, gsym);
      break;

    case elfcpp::R_ARM_GOT_BREL:
    case elfcpp::R_ARM_GOT_ABS:
    case elfcpp::R_ARM_GOT_PREL:
      {
	// The symbol requires a GOT entry.
	Arm_output_data_got<big_endian>* got =
	  target->got_section(symtab, layout);
	if (gsym->final_value_is_known())
	  got->add_global(gsym, GOT_TYPE_STANDARD);
	else
	  {
	    // If this symbol is not fully resolved, we need to add a
	    // GOT entry with a dynamic relocation.
	    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
	    if (gsym->is_from_dynobj()
		|| gsym->is_undefined()
		|| gsym->is_preemptible()
		|| (gsym->visibility() == elfcpp::STV_PROTECTED
		    && parameters->options().shared()))
	      got->add_global_with_rel(gsym, GOT_TYPE_STANDARD,
				       rel_dyn, elfcpp::R_ARM_GLOB_DAT);
	    else
	      {
		if (got->add_global(gsym, GOT_TYPE_STANDARD))
		  rel_dyn->add_global_relative(
		      gsym, elfcpp::R_ARM_RELATIVE, got,
		      gsym->got_offset(GOT_TYPE_STANDARD));
	      }
	  }
      }
      break;

    case elfcpp::R_ARM_TARGET1:
    case elfcpp::R_ARM_TARGET2:
      // These should have been mapped to other types already.
      // Fall through.
    case elfcpp::R_ARM_COPY:
    case elfcpp::R_ARM_GLOB_DAT:
    case elfcpp::R_ARM_JUMP_SLOT:
    case elfcpp::R_ARM_RELATIVE:
      // These are relocations which should only be seen by the
      // dynamic linker, and should never be seen here.
      gold_error(_("%s: unexpected reloc %u in object file"),
		 object->name().c_str(), r_type);
      break;

      // These are initial tls relocs, which are expected when
      // linking.
    case elfcpp::R_ARM_TLS_GD32:	// Global-dynamic
    case elfcpp::R_ARM_TLS_LDM32:	// Local-dynamic
    case elfcpp::R_ARM_TLS_LDO32:	// Alternate local-dynamic
    case elfcpp::R_ARM_TLS_IE32:	// Initial-exec
    case elfcpp::R_ARM_TLS_LE32:	// Local-exec
      {
	const bool is_final = gsym->final_value_is_known();
	const tls::Tls_optimization optimized_type
	    = Target_arm<big_endian>::optimize_tls_reloc(is_final, r_type);
	switch (r_type)
	  {
	  case elfcpp::R_ARM_TLS_GD32:		// Global-dynamic
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a pair of GOT entries for the module index and
		// dtv-relative offset.
		Arm_output_data_got<big_endian>* got
		    = target->got_section(symtab, layout);
		if (!parameters->doing_static_link())
		  got->add_global_pair_with_rel(gsym, GOT_TYPE_TLS_PAIR,
						target->rel_dyn_section(layout),
						elfcpp::R_ARM_TLS_DTPMOD32,
						elfcpp::R_ARM_TLS_DTPOFF32);
		else
		  got->add_tls_gd32_with_static_reloc(GOT_TYPE_TLS_PAIR, gsym);
	      }
	    else
	      // FIXME: TLS optimization not supported yet.
	      gold_unreachable();
	    break;

	  case elfcpp::R_ARM_TLS_LDM32:		// Local-dynamic
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a GOT entry for the module index.
		target->got_mod_index_entry(symtab, layout, object);
	      }
	    else
	      // FIXME: TLS optimization not supported yet.
	      gold_unreachable();
	    break;

	  case elfcpp::R_ARM_TLS_LDO32:		// Alternate local-dynamic
	    break;

	  case elfcpp::R_ARM_TLS_IE32:		// Initial-exec
	    layout->set_has_static_tls();
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a GOT entry for the tp-relative offset.
		Arm_output_data_got<big_endian>* got
		  = target->got_section(symtab, layout);
		if (!parameters->doing_static_link())
		  got->add_global_with_rel(gsym, GOT_TYPE_TLS_OFFSET,
					   target->rel_dyn_section(layout),
					   elfcpp::R_ARM_TLS_TPOFF32);
		else if (!gsym->has_got_offset(GOT_TYPE_TLS_OFFSET))
		  {
		    got->add_global(gsym, GOT_TYPE_TLS_OFFSET);
		    unsigned int got_offset =
		       gsym->got_offset(GOT_TYPE_TLS_OFFSET);
		    got->add_static_reloc(got_offset,
					  elfcpp::R_ARM_TLS_TPOFF32, gsym);
		  }
	      }
	    else
	      // FIXME: TLS optimization not supported yet.
	      gold_unreachable();
	    break;

	  case elfcpp::R_ARM_TLS_LE32:	// Local-exec
	    layout->set_has_static_tls();
	    if (parameters->options().shared())
	      {
		// We need to create a dynamic relocation.
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		rel_dyn->add_global(gsym, elfcpp::R_ARM_TLS_TPOFF32,
				    output_section, object,
				    data_shndx, reloc.get_r_offset());
	      }
	    break;

	  default:
	    gold_unreachable();
	  }
      }
      break;

    case elfcpp::R_ARM_PC24:
    case elfcpp::R_ARM_LDR_SBREL_11_0_NC:
    case elfcpp::R_ARM_ALU_SBREL_19_12_NC:
    case elfcpp::R_ARM_ALU_SBREL_27_20_CK:
    default:
      unsupported_reloc_global(object, r_type, gsym);
      break;
    }
}

// Process relocations for gc.

template<bool big_endian>
void
Target_arm<big_endian>::gc_process_relocs(
    Symbol_table* symtab,
    Layout* layout,
    Sized_relobj_file<32, big_endian>* object,
    unsigned int data_shndx,
    unsigned int,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    size_t local_symbol_count,
    const unsigned char* plocal_symbols)
{
  typedef Target_arm<big_endian> Arm;
  typedef typename Target_arm<big_endian>::Scan Scan;

  gold::gc_process_relocs<32, big_endian, Arm, elfcpp::SHT_REL, Scan,
			  typename Target_arm::Relocatable_size_for_reloc>(
    symtab,
    layout,
    this,
    object,
    data_shndx,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    local_symbol_count,
    plocal_symbols);
}

// Scan relocations for a section.

template<bool big_endian>
void
Target_arm<big_endian>::scan_relocs(Symbol_table* symtab,
				    Layout* layout,
				    Sized_relobj_file<32, big_endian>* object,
				    unsigned int data_shndx,
				    unsigned int sh_type,
				    const unsigned char* prelocs,
				    size_t reloc_count,
				    Output_section* output_section,
				    bool needs_special_offset_handling,
				    size_t local_symbol_count,
				    const unsigned char* plocal_symbols)
{
  typedef typename Target_arm<big_endian>::Scan Scan;
  if (sh_type == elfcpp::SHT_RELA)
    {
      gold_error(_("%s: unsupported RELA reloc section"),
		 object->name().c_str());
      return;
    }

  gold::scan_relocs<32, big_endian, Target_arm, elfcpp::SHT_REL, Scan>(
    symtab,
    layout,
    this,
    object,
    data_shndx,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    local_symbol_count,
    plocal_symbols);
}

// Finalize the sections.

template<bool big_endian>
void
Target_arm<big_endian>::do_finalize_sections(
    Layout* layout,
    const Input_objects* input_objects,
    Symbol_table*)
{
  bool merged_any_attributes = false;
  // Merge processor-specific flags.
  for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
       p != input_objects->relobj_end();
       ++p)
    {
      Arm_relobj<big_endian>* arm_relobj =
	Arm_relobj<big_endian>::as_arm_relobj(*p);
      if (arm_relobj->merge_flags_and_attributes())
	{
	  this->merge_processor_specific_flags(
	      arm_relobj->name(),
	      arm_relobj->processor_specific_flags());
	  this->merge_object_attributes(arm_relobj->name().c_str(),
					arm_relobj->attributes_section_data());
	  merged_any_attributes = true;
	}
    }

  for (Input_objects::Dynobj_iterator p = input_objects->dynobj_begin();
       p != input_objects->dynobj_end();
       ++p)
    {
      Arm_dynobj<big_endian>* arm_dynobj =
	Arm_dynobj<big_endian>::as_arm_dynobj(*p);
      this->merge_processor_specific_flags(
	  arm_dynobj->name(),
	  arm_dynobj->processor_specific_flags());
      this->merge_object_attributes(arm_dynobj->name().c_str(),
				    arm_dynobj->attributes_section_data());
      merged_any_attributes = true;
    }

  // Create an empty uninitialized attribute section if we still don't have it
  // at this moment.  This happens if there is no attributes sections in all
  // inputs.
  if (this->attributes_section_data_ == NULL)
    this->attributes_section_data_ = new Attributes_section_data(NULL, 0);

  const Object_attribute* cpu_arch_attr =
    this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);
  // Check if we need to use Cortex-A8 workaround.
  if (parameters->options().user_set_fix_cortex_a8())
    this->fix_cortex_a8_ = parameters->options().fix_cortex_a8();
  else
    {
      // If neither --fix-cortex-a8 nor --no-fix-cortex-a8 is used, turn on
      // Cortex-A8 erratum workaround for ARMv7-A or ARMv7 with unknown
      // profile.
      const Object_attribute* cpu_arch_profile_attr =
	this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch_profile);
      this->fix_cortex_a8_ =
	(cpu_arch_attr->int_value() == elfcpp::TAG_CPU_ARCH_V7
	 && (cpu_arch_profile_attr->int_value() == 'A'
	     || cpu_arch_profile_attr->int_value() == 0));
    }

  // Check if we can use V4BX interworking.
  // The V4BX interworking stub contains BX instruction,
  // which is not specified for some profiles.
  if (this->fix_v4bx() == General_options::FIX_V4BX_INTERWORKING
      && !this->may_use_v4t_interworking())
    gold_error(_("unable to provide V4BX reloc interworking fix up; "
		 "the target profile does not support BX instruction"));

  // Fill in some more dynamic tags.
  const Reloc_section* rel_plt = (this->plt_ == NULL
				  ? NULL
				  : this->plt_->rel_plt());
  layout->add_target_dynamic_tags(true, this->got_plt_, rel_plt,
				  this->rel_dyn_, true, false);

  // Emit any relocs we saved in an attempt to avoid generating COPY
  // relocs.
  if (this->copy_relocs_.any_saved_relocs())
    this->copy_relocs_.emit(this->rel_dyn_section(layout));

  // Handle the .ARM.exidx section.
  Output_section* exidx_section = layout->find_output_section(".ARM.exidx");

  if (!parameters->options().relocatable())
    {
      if (exidx_section != NULL
	  && exidx_section->type() == elfcpp::SHT_ARM_EXIDX)
	{
	  // For the ARM target, we need to add a PT_ARM_EXIDX segment for
	  // the .ARM.exidx section.
	  if (!layout->script_options()->saw_phdrs_clause())
	    {
	      gold_assert(layout->find_output_segment(elfcpp::PT_ARM_EXIDX, 0,
						      0)
			  == NULL);
	      Output_segment*  exidx_segment =
		layout->make_output_segment(elfcpp::PT_ARM_EXIDX, elfcpp::PF_R);
	      exidx_segment->add_output_section_to_nonload(exidx_section,
							   elfcpp::PF_R);
	    }
	}
    }

  // Create an .ARM.attributes section if we have merged any attributes
  // from inputs.
  if (merged_any_attributes)
    {
      Output_attributes_section_data* attributes_section =
      new Output_attributes_section_data(*this->attributes_section_data_);
      layout->add_output_section_data(".ARM.attributes",
				      elfcpp::SHT_ARM_ATTRIBUTES, 0,
				      attributes_section, ORDER_INVALID,
				      false);
    }

  // Fix up links in section EXIDX headers.
  for (Layout::Section_list::const_iterator p = layout->section_list().begin();
       p != layout->section_list().end();
       ++p)
    if ((*p)->type() == elfcpp::SHT_ARM_EXIDX)
      {
	Arm_output_section<big_endian>* os =
	  Arm_output_section<big_endian>::as_arm_output_section(*p);
	os->set_exidx_section_link();
      }
}

// Return whether a direct absolute static relocation needs to be applied.
// In cases where Scan::local() or Scan::global() has created
// a dynamic relocation other than R_ARM_RELATIVE, the addend
// of the relocation is carried in the data, and we must not
// apply the static relocation.

template<bool big_endian>
inline bool
Target_arm<big_endian>::Relocate::should_apply_static_reloc(
    const Sized_symbol<32>* gsym,
    unsigned int r_type,
    bool is_32bit,
    Output_section* output_section)
{
  // If the output section is not allocated, then we didn't call
  // scan_relocs, we didn't create a dynamic reloc, and we must apply
  // the reloc here.
  if ((output_section->flags() & elfcpp::SHF_ALLOC) == 0)
      return true;

  int ref_flags = Scan::get_reference_flags(r_type);

  // For local symbols, we will have created a non-RELATIVE dynamic
  // relocation only if (a) the output is position independent,
  // (b) the relocation is absolute (not pc- or segment-relative), and
  // (c) the relocation is not 32 bits wide.
  if (gsym == NULL)
    return !(parameters->options().output_is_position_independent()
	     && (ref_flags & Symbol::ABSOLUTE_REF)
	     && !is_32bit);

  // For global symbols, we use the same helper routines used in the
  // scan pass.  If we did not create a dynamic relocation, or if we
  // created a RELATIVE dynamic relocation, we should apply the static
  // relocation.
  bool has_dyn = gsym->needs_dynamic_reloc(ref_flags);
  bool is_rel = (ref_flags & Symbol::ABSOLUTE_REF)
		 && gsym->can_use_relative_reloc(ref_flags
						 & Symbol::FUNCTION_CALL);
  return !has_dyn || is_rel;
}

// Perform a relocation.

template<bool big_endian>
inline bool
Target_arm<big_endian>::Relocate::relocate(
    const Relocate_info<32, big_endian>* relinfo,
    Target_arm* target,
    Output_section* output_section,
    size_t relnum,
    const elfcpp::Rel<32, big_endian>& rel,
    unsigned int r_type,
    const Sized_symbol<32>* gsym,
    const Symbol_value<32>* psymval,
    unsigned char* view,
    Arm_address address,
    section_size_type view_size)
{
  if (view == NULL)
    return true;

  typedef Arm_relocate_functions<big_endian> Arm_relocate_functions;

  r_type = get_real_reloc_type(r_type);
  const Arm_reloc_property* reloc_property =
    arm_reloc_property_table->get_implemented_static_reloc_property(r_type);
  if (reloc_property == NULL)
    {
      std::string reloc_name =
	arm_reloc_property_table->reloc_name_in_error_message(r_type);
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			     _("cannot relocate %s in object file"),
			     reloc_name.c_str());
      return true;
    }

  const Arm_relobj<big_endian>* object =
    Arm_relobj<big_endian>::as_arm_relobj(relinfo->object);

  // If the final branch target of a relocation is THUMB instruction, this
  // is 1.  Otherwise it is 0.
  Arm_address thumb_bit = 0;
  Symbol_value<32> symval;
  bool is_weakly_undefined_without_plt = false;
  bool have_got_offset = false;
  unsigned int got_offset = 0;

  // If the relocation uses the GOT entry of a symbol instead of the symbol
  // itself, we don't care about whether the symbol is defined or what kind
  // of symbol it is.
  if (reloc_property->uses_got_entry())
    {
      // Get the GOT offset.
      // The GOT pointer points to the end of the GOT section.
      // We need to subtract the size of the GOT section to get
      // the actual offset to use in the relocation.
      // TODO: We should move GOT offset computing code in TLS relocations
      // to here.
      switch (r_type)
	{
	case elfcpp::R_ARM_GOT_BREL:
	case elfcpp::R_ARM_GOT_PREL:
	  if (gsym != NULL)
	    {
	      gold_assert(gsym->has_got_offset(GOT_TYPE_STANDARD));
	      got_offset = (gsym->got_offset(GOT_TYPE_STANDARD)
			    - target->got_size());
	    }
	  else
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
	      gold_assert(object->local_has_got_offset(r_sym,
						       GOT_TYPE_STANDARD));
	      got_offset = (object->local_got_offset(r_sym, GOT_TYPE_STANDARD)
			    - target->got_size());
	    }
	  have_got_offset = true;
	  break;

	default:
	  break;
	}
    }
  else if (relnum != Target_arm<big_endian>::fake_relnum_for_stubs)
    {
      if (gsym != NULL)
	{
	  // This is a global symbol.  Determine if we use PLT and if the
	  // final target is THUMB.
	  if (gsym->use_plt_offset(Scan::get_reference_flags(r_type)))
	    {
	      // This uses a PLT, change the symbol value.
	      symval.set_output_value(target->plt_section()->address()
				      + gsym->plt_offset());
	      psymval = &symval;
	    }
	  else if (gsym->is_weak_undefined())
	    {
	      // This is a weakly undefined symbol and we do not use PLT
	      // for this relocation.  A branch targeting this symbol will
	      // be converted into an NOP.
	      is_weakly_undefined_without_plt = true;
	    }
	  else if (gsym->is_undefined() && reloc_property->uses_symbol())
	    {
	      // This relocation uses the symbol value but the symbol is
	      // undefined.  Exit early and have the caller reporting an
	      // error.
	      return true;
	    }
	  else
	    {
	      // Set thumb bit if symbol:
	      // -Has type STT_ARM_TFUNC or
	      // -Has type STT_FUNC, is defined and with LSB in value set.
	      thumb_bit =
		(((gsym->type() == elfcpp::STT_ARM_TFUNC)
		 || (gsym->type() == elfcpp::STT_FUNC
		     && !gsym->is_undefined()
		     && ((psymval->value(object, 0) & 1) != 0)))
		? 1
		: 0);
	    }
	}
      else
	{
	  // This is a local symbol.  Determine if the final target is THUMB.
	  // We saved this information when all the local symbols were read.
	  elfcpp::Elf_types<32>::Elf_WXword r_info = rel.get_r_info();
	  unsigned int r_sym = elfcpp::elf_r_sym<32>(r_info);
	  thumb_bit = object->local_symbol_is_thumb_function(r_sym) ? 1 : 0;
	}
    }
  else
    {
      // This is a fake relocation synthesized for a stub.  It does not have
      // a real symbol.  We just look at the LSB of the symbol value to
      // determine if the target is THUMB or not.
      thumb_bit = ((psymval->value(object, 0) & 1) != 0);
    }

  // Strip LSB if this points to a THUMB target.
  if (thumb_bit != 0
      && reloc_property->uses_thumb_bit()
      && ((psymval->value(object, 0) & 1) != 0))
    {
      Arm_address stripped_value =
	psymval->value(object, 0) & ~static_cast<Arm_address>(1);
      symval.set_output_value(stripped_value);
      psymval = &symval;
    }

  // To look up relocation stubs, we need to pass the symbol table index of
  // a local symbol.
  unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());

  // Get the addressing origin of the output segment defining the
  // symbol gsym if needed (AAELF 4.6.1.2 Relocation types).
  Arm_address sym_origin = 0;
  if (reloc_property->uses_symbol_base())
    {
      if (r_type == elfcpp::R_ARM_BASE_ABS && gsym == NULL)
	// R_ARM_BASE_ABS with the NULL symbol will give the
	// absolute address of the GOT origin (GOT_ORG) (see ARM IHI
	// 0044C (AAELF): 4.6.1.8 Proxy generating relocations).
	sym_origin = target->got_plt_section()->address();
      else if (gsym == NULL)
	sym_origin = 0;
      else if (gsym->source() == Symbol::IN_OUTPUT_SEGMENT)
	sym_origin = gsym->output_segment()->vaddr();
      else if (gsym->source() == Symbol::IN_OUTPUT_DATA)
	sym_origin = gsym->output_data()->address();

      // TODO: Assumes the segment base to be zero for the global symbols
      // till the proper support for the segment-base-relative addressing
      // will be implemented.  This is consistent with GNU ld.
    }

  // For relative addressing relocation, find out the relative address base.
  Arm_address relative_address_base = 0;
  switch(reloc_property->relative_address_base())
    {
    case Arm_reloc_property::RAB_NONE:
    // Relocations with relative address bases RAB_TLS and RAB_tp are
    // handled by relocate_tls.  So we do not need to do anything here.
    case Arm_reloc_property::RAB_TLS:
    case Arm_reloc_property::RAB_tp:
      break;
    case Arm_reloc_property::RAB_B_S:
      relative_address_base = sym_origin;
      break;
    case Arm_reloc_property::RAB_GOT_ORG:
      relative_address_base = target->got_plt_section()->address();
      break;
    case Arm_reloc_property::RAB_P:
      relative_address_base = address;
      break;
    case Arm_reloc_property::RAB_Pa:
      relative_address_base = address & 0xfffffffcU;
      break;
    default:
      gold_unreachable();
    }

  typename Arm_relocate_functions::Status reloc_status =
	Arm_relocate_functions::STATUS_OKAY;
  bool check_overflow = reloc_property->checks_overflow();
  switch (r_type)
    {
    case elfcpp::R_ARM_NONE:
      break;

    case elfcpp::R_ARM_ABS8:
      if (should_apply_static_reloc(gsym, r_type, false, output_section))
	reloc_status = Arm_relocate_functions::abs8(view, object, psymval);
      break;

    case elfcpp::R_ARM_ABS12:
      if (should_apply_static_reloc(gsym, r_type, false, output_section))
	reloc_status = Arm_relocate_functions::abs12(view, object, psymval);
      break;

    case elfcpp::R_ARM_ABS16:
      if (should_apply_static_reloc(gsym, r_type, false, output_section))
	reloc_status = Arm_relocate_functions::abs16(view, object, psymval);
      break;

    case elfcpp::R_ARM_ABS32:
      if (should_apply_static_reloc(gsym, r_type, true, output_section))
	reloc_status = Arm_relocate_functions::abs32(view, object, psymval,
						     thumb_bit);
      break;

    case elfcpp::R_ARM_ABS32_NOI:
      if (should_apply_static_reloc(gsym, r_type, true, output_section))
	// No thumb bit for this relocation: (S + A)
	reloc_status = Arm_relocate_functions::abs32(view, object, psymval,
						     0);
      break;

    case elfcpp::R_ARM_MOVW_ABS_NC:
      if (should_apply_static_reloc(gsym, r_type, false, output_section))
	reloc_status = Arm_relocate_functions::movw(view, object, psymval,
						    0, thumb_bit,
						    check_overflow);
      break;

    case elfcpp::R_ARM_MOVT_ABS:
      if (should_apply_static_reloc(gsym, r_type, false, output_section))
	reloc_status = Arm_relocate_functions::movt(view, object, psymval, 0);
      break;

    case elfcpp::R_ARM_THM_MOVW_ABS_NC:
      if (should_apply_static_reloc(gsym, r_type, false, output_section))
	reloc_status = Arm_relocate_functions::thm_movw(view, object, psymval,
							0, thumb_bit, false);
      break;

    case elfcpp::R_ARM_THM_MOVT_ABS:
      if (should_apply_static_reloc(gsym, r_type, false, output_section))
	reloc_status = Arm_relocate_functions::thm_movt(view, object,
							psymval, 0);
      break;

    case elfcpp::R_ARM_MOVW_PREL_NC:
    case elfcpp::R_ARM_MOVW_BREL_NC:
    case elfcpp::R_ARM_MOVW_BREL:
      reloc_status =
	Arm_relocate_functions::movw(view, object, psymval,
				     relative_address_base, thumb_bit,
				     check_overflow);
      break;

    case elfcpp::R_ARM_MOVT_PREL:
    case elfcpp::R_ARM_MOVT_BREL:
      reloc_status =
	Arm_relocate_functions::movt(view, object, psymval,
				     relative_address_base);
      break;

    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
    case elfcpp::R_ARM_THM_MOVW_BREL_NC:
    case elfcpp::R_ARM_THM_MOVW_BREL:
      reloc_status =
	Arm_relocate_functions::thm_movw(view, object, psymval,
					 relative_address_base,
					 thumb_bit, check_overflow);
      break;

    case elfcpp::R_ARM_THM_MOVT_PREL:
    case elfcpp::R_ARM_THM_MOVT_BREL:
      reloc_status =
	Arm_relocate_functions::thm_movt(view, object, psymval,
					 relative_address_base);
      break;

    case elfcpp::R_ARM_REL32:
      reloc_status = Arm_relocate_functions::rel32(view, object, psymval,
						   address, thumb_bit);
      break;

    case elfcpp::R_ARM_THM_ABS5:
      if (should_apply_static_reloc(gsym, r_type, false, output_section))
	reloc_status = Arm_relocate_functions::thm_abs5(view, object, psymval);
      break;

    // Thumb long branches.
    case elfcpp::R_ARM_THM_CALL:
    case elfcpp::R_ARM_THM_XPC22:
    case elfcpp::R_ARM_THM_JUMP24:
      reloc_status =
	Arm_relocate_functions::thumb_branch_common(
	    r_type, relinfo, view, gsym, object, r_sym, psymval, address,
	    thumb_bit, is_weakly_undefined_without_plt);
      break;

    case elfcpp::R_ARM_GOTOFF32:
      {
	Arm_address got_origin;
	got_origin = target->got_plt_section()->address();
	reloc_status = Arm_relocate_functions::rel32(view, object, psymval,
						     got_origin, thumb_bit);
      }
      break;

    case elfcpp::R_ARM_BASE_PREL:
      gold_assert(gsym != NULL);
      reloc_status =
	  Arm_relocate_functions::base_prel(view, sym_origin, address);
      break;

    case elfcpp::R_ARM_BASE_ABS:
      if (should_apply_static_reloc(gsym, r_type, false, output_section))
	reloc_status = Arm_relocate_functions::base_abs(view, sym_origin);
      break;

    case elfcpp::R_ARM_GOT_BREL:
      gold_assert(have_got_offset);
      reloc_status = Arm_relocate_functions::got_brel(view, got_offset);
      break;

    case elfcpp::R_ARM_GOT_PREL:
      gold_assert(have_got_offset);
      // Get the address origin for GOT PLT, which is allocated right
      // after the GOT section, to calculate an absolute address of
      // the symbol GOT entry (got_origin + got_offset).
      Arm_address got_origin;
      got_origin = target->got_plt_section()->address();
      reloc_status = Arm_relocate_functions::got_prel(view,
						      got_origin + got_offset,
						      address);
      break;

    case elfcpp::R_ARM_PLT32:
    case elfcpp::R_ARM_CALL:
    case elfcpp::R_ARM_JUMP24:
    case elfcpp::R_ARM_XPC25:
      gold_assert(gsym == NULL
		  || gsym->has_plt_offset()
		  || gsym->final_value_is_known()
		  || (gsym->is_defined()
		      && !gsym->is_from_dynobj()
		      && !gsym->is_preemptible()));
      reloc_status =
	Arm_relocate_functions::arm_branch_common(
	    r_type, relinfo, view, gsym, object, r_sym, psymval, address,
	    thumb_bit, is_weakly_undefined_without_plt);
      break;

    case elfcpp::R_ARM_THM_JUMP19:
      reloc_status =
	Arm_relocate_functions::thm_jump19(view, object, psymval, address,
					   thumb_bit);
      break;

    case elfcpp::R_ARM_THM_JUMP6:
      reloc_status =
	Arm_relocate_functions::thm_jump6(view, object, psymval, address);
      break;

    case elfcpp::R_ARM_THM_JUMP8:
      reloc_status =
	Arm_relocate_functions::thm_jump8(view, object, psymval, address);
      break;

    case elfcpp::R_ARM_THM_JUMP11:
      reloc_status =
	Arm_relocate_functions::thm_jump11(view, object, psymval, address);
      break;

    case elfcpp::R_ARM_PREL31:
      reloc_status = Arm_relocate_functions::prel31(view, object, psymval,
						    address, thumb_bit);
      break;

    case elfcpp::R_ARM_V4BX:
      if (target->fix_v4bx() > General_options::FIX_V4BX_NONE)
	{
	  const bool is_v4bx_interworking =
	      (target->fix_v4bx() == General_options::FIX_V4BX_INTERWORKING);
	  reloc_status =
	    Arm_relocate_functions::v4bx(relinfo, view, object, address,
					 is_v4bx_interworking);
	}
      break;

    case elfcpp::R_ARM_THM_PC8:
      reloc_status =
	Arm_relocate_functions::thm_pc8(view, object, psymval, address);
      break;

    case elfcpp::R_ARM_THM_PC12:
      reloc_status =
	Arm_relocate_functions::thm_pc12(view, object, psymval, address);
      break;

    case elfcpp::R_ARM_THM_ALU_PREL_11_0:
      reloc_status =
	Arm_relocate_functions::thm_alu11(view, object, psymval, address,
					  thumb_bit);
      break;

    case elfcpp::R_ARM_ALU_PC_G0_NC:
    case elfcpp::R_ARM_ALU_PC_G0:
    case elfcpp::R_ARM_ALU_PC_G1_NC:
    case elfcpp::R_ARM_ALU_PC_G1:
    case elfcpp::R_ARM_ALU_PC_G2:
    case elfcpp::R_ARM_ALU_SB_G0_NC:
    case elfcpp::R_ARM_ALU_SB_G0:
    case elfcpp::R_ARM_ALU_SB_G1_NC:
    case elfcpp::R_ARM_ALU_SB_G1:
    case elfcpp::R_ARM_ALU_SB_G2:
      reloc_status =
	Arm_relocate_functions::arm_grp_alu(view, object, psymval,
					    reloc_property->group_index(),
					    relative_address_base,
					    thumb_bit, check_overflow);
      break;

    case elfcpp::R_ARM_LDR_PC_G0:
    case elfcpp::R_ARM_LDR_PC_G1:
    case elfcpp::R_ARM_LDR_PC_G2:
    case elfcpp::R_ARM_LDR_SB_G0:
    case elfcpp::R_ARM_LDR_SB_G1:
    case elfcpp::R_ARM_LDR_SB_G2:
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldr(view, object, psymval,
					      reloc_property->group_index(),
					      relative_address_base);
      break;

    case elfcpp::R_ARM_LDRS_PC_G0:
    case elfcpp::R_ARM_LDRS_PC_G1:
    case elfcpp::R_ARM_LDRS_PC_G2:
    case elfcpp::R_ARM_LDRS_SB_G0:
    case elfcpp::R_ARM_LDRS_SB_G1:
    case elfcpp::R_ARM_LDRS_SB_G2:
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldrs(view, object, psymval,
					       reloc_property->group_index(),
					       relative_address_base);
      break;

    case elfcpp::R_ARM_LDC_PC_G0:
    case elfcpp::R_ARM_LDC_PC_G1:
    case elfcpp::R_ARM_LDC_PC_G2:
    case elfcpp::R_ARM_LDC_SB_G0:
    case elfcpp::R_ARM_LDC_SB_G1:
    case elfcpp::R_ARM_LDC_SB_G2:
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldc(view, object, psymval,
					      reloc_property->group_index(),
					      relative_address_base);
      break;

      // These are initial tls relocs, which are expected when
      // linking.
    case elfcpp::R_ARM_TLS_GD32:	// Global-dynamic
    case elfcpp::R_ARM_TLS_LDM32:	// Local-dynamic
    case elfcpp::R_ARM_TLS_LDO32:	// Alternate local-dynamic
    case elfcpp::R_ARM_TLS_IE32:	// Initial-exec
    case elfcpp::R_ARM_TLS_LE32:	// Local-exec
      reloc_status =
	this->relocate_tls(relinfo, target, relnum, rel, r_type, gsym, psymval,
			   view, address, view_size);
      break;

    // The known and unknown unsupported and/or deprecated relocations.
    case elfcpp::R_ARM_PC24:
    case elfcpp::R_ARM_LDR_SBREL_11_0_NC:
    case elfcpp::R_ARM_ALU_SBREL_19_12_NC:
    case elfcpp::R_ARM_ALU_SBREL_27_20_CK:
    default:
      // Just silently leave the method. We should get an appropriate error
      // message in the scan methods.
      break;
    }

  // Report any errors.
  switch (reloc_status)
    {
    case Arm_relocate_functions::STATUS_OKAY:
      break;
    case Arm_relocate_functions::STATUS_OVERFLOW:
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			     _("relocation overflow in %s"),
			     reloc_property->name().c_str());
      break;
    case Arm_relocate_functions::STATUS_BAD_RELOC:
      gold_error_at_location(
	relinfo,
	relnum,
	rel.get_r_offset(),
	_("unexpected opcode while processing relocation %s"),
	reloc_property->name().c_str());
      break;
    default:
      gold_unreachable();
    }

  return true;
}

// Perform a TLS relocation.

template<bool big_endian>
inline typename Arm_relocate_functions<big_endian>::Status
Target_arm<big_endian>::Relocate::relocate_tls(
    const Relocate_info<32, big_endian>* relinfo,
    Target_arm<big_endian>* target,
    size_t relnum,
    const elfcpp::Rel<32, big_endian>& rel,
    unsigned int r_type,
    const Sized_symbol<32>* gsym,
    const Symbol_value<32>* psymval,
    unsigned char* view,
    elfcpp::Elf_types<32>::Elf_Addr address,
    section_size_type /*view_size*/ )
{
  typedef Arm_relocate_functions<big_endian> ArmRelocFuncs;
  typedef Relocate_functions<32, big_endian> RelocFuncs;
  Output_segment* tls_segment = relinfo->layout->tls_segment();

  const Sized_relobj_file<32, big_endian>* object = relinfo->object;

  elfcpp::Elf_types<32>::Elf_Addr value = psymval->value(object, 0);

  const bool is_final = (gsym == NULL
			 ? !parameters->options().shared()
			 : gsym->final_value_is_known());
  const tls::Tls_optimization optimized_type
      = Target_arm<big_endian>::optimize_tls_reloc(is_final, r_type);
  switch (r_type)
    {
    case elfcpp::R_ARM_TLS_GD32:	// Global-dynamic
	{
	  unsigned int got_type = GOT_TYPE_TLS_PAIR;
	  unsigned int got_offset;
	  if (gsym != NULL)
	    {
	      gold_assert(gsym->has_got_offset(got_type));
	      got_offset = gsym->got_offset(got_type) - target->got_size();
	    }
	  else
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
	      gold_assert(object->local_has_got_offset(r_sym, got_type));
	      got_offset = (object->local_got_offset(r_sym, got_type)
			    - target->got_size());
	    }
	  if (optimized_type == tls::TLSOPT_NONE)
	    {
	      Arm_address got_entry =
		target->got_plt_section()->address() + got_offset;

	      // Relocate the field with the PC relative offset of the pair of
	      // GOT entries.
	      RelocFuncs::pcrel32_unaligned(view, got_entry, address);
	      return ArmRelocFuncs::STATUS_OKAY;
	    }
	}
      break;

    case elfcpp::R_ARM_TLS_LDM32:	// Local-dynamic
      if (optimized_type == tls::TLSOPT_NONE)
	{
	  // Relocate the field with the offset of the GOT entry for
	  // the module index.
	  unsigned int got_offset;
	  got_offset = (target->got_mod_index_entry(NULL, NULL, NULL)
			- target->got_size());
	  Arm_address got_entry =
	    target->got_plt_section()->address() + got_offset;

	  // Relocate the field with the PC relative offset of the pair of
	  // GOT entries.
	  RelocFuncs::pcrel32_unaligned(view, got_entry, address);
	  return ArmRelocFuncs::STATUS_OKAY;
	}
      break;

    case elfcpp::R_ARM_TLS_LDO32:	// Alternate local-dynamic
      RelocFuncs::rel32_unaligned(view, value);
      return ArmRelocFuncs::STATUS_OKAY;

    case elfcpp::R_ARM_TLS_IE32:	// Initial-exec
      if (optimized_type == tls::TLSOPT_NONE)
	{
	  // Relocate the field with the offset of the GOT entry for
	  // the tp-relative offset of the symbol.
	  unsigned int got_type = GOT_TYPE_TLS_OFFSET;
	  unsigned int got_offset;
	  if (gsym != NULL)
	    {
	      gold_assert(gsym->has_got_offset(got_type));
	      got_offset = gsym->got_offset(got_type);
	    }
	  else
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
	      gold_assert(object->local_has_got_offset(r_sym, got_type));
	      got_offset = object->local_got_offset(r_sym, got_type);
	    }

	  // All GOT offsets are relative to the end of the GOT.
	  got_offset -= target->got_size();

	  Arm_address got_entry =
	    target->got_plt_section()->address() + got_offset;

	  // Relocate the field with the PC relative offset of the GOT entry.
	  RelocFuncs::pcrel32_unaligned(view, got_entry, address);
	  return ArmRelocFuncs::STATUS_OKAY;
	}
      break;

    case elfcpp::R_ARM_TLS_LE32:	// Local-exec
      // If we're creating a shared library, a dynamic relocation will
      // have been created for this location, so do not apply it now.
      if (!parameters->options().shared())
	{
	  gold_assert(tls_segment != NULL);

	  // $tp points to the TCB, which is followed by the TLS, so we
	  // need to add TCB size to the offset.
	  Arm_address aligned_tcb_size =
	    align_address(ARM_TCB_SIZE, tls_segment->maximum_alignment());
	  RelocFuncs::rel32_unaligned(view, value + aligned_tcb_size);

	}
      return ArmRelocFuncs::STATUS_OKAY;

    default:
      gold_unreachable();
    }

  gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			 _("unsupported reloc %u"),
			 r_type);
  return ArmRelocFuncs::STATUS_BAD_RELOC;
}

// Relocate section data.

template<bool big_endian>
void
Target_arm<big_endian>::relocate_section(
    const Relocate_info<32, big_endian>* relinfo,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    unsigned char* view,
    Arm_address address,
    section_size_type view_size,
    const Reloc_symbol_changes* reloc_symbol_changes)
{
  typedef typename Target_arm<big_endian>::Relocate Arm_relocate;
  gold_assert(sh_type == elfcpp::SHT_REL);

  // See if we are relocating a relaxed input section.  If so, the view
  // covers the whole output section and we need to adjust accordingly.
  if (needs_special_offset_handling)
    {
      const Output_relaxed_input_section* poris =
	output_section->find_relaxed_input_section(relinfo->object,
						   relinfo->data_shndx);
      if (poris != NULL)
	{
	  Arm_address section_address = poris->address();
	  section_size_type section_size = poris->data_size();

	  gold_assert((section_address >= address)
		      && ((section_address + section_size)
			  <= (address + view_size)));

	  off_t offset = section_address - address;
	  view += offset;
	  address += offset;
	  view_size = section_size;
	}
    }

  gold::relocate_section<32, big_endian, Target_arm, elfcpp::SHT_REL,
			 Arm_relocate, gold::Default_comdat_behavior>(
    relinfo,
    this,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    view,
    address,
    view_size,
    reloc_symbol_changes);
}

// Return the size of a relocation while scanning during a relocatable
// link.

template<bool big_endian>
unsigned int
Target_arm<big_endian>::Relocatable_size_for_reloc::get_size_for_reloc(
    unsigned int r_type,
    Relobj* object)
{
  r_type = get_real_reloc_type(r_type);
  const Arm_reloc_property* arp =
      arm_reloc_property_table->get_implemented_static_reloc_property(r_type);
  if (arp != NULL)
    return arp->size();
  else
    {
      std::string reloc_name =
	arm_reloc_property_table->reloc_name_in_error_message(r_type);
      gold_error(_("%s: unexpected %s in object file"),
		 object->name().c_str(), reloc_name.c_str());
      return 0;
    }
}

// Scan the relocs during a relocatable link.

template<bool big_endian>
void
Target_arm<big_endian>::scan_relocatable_relocs(
    Symbol_table* symtab,
    Layout* layout,
    Sized_relobj_file<32, big_endian>* object,
    unsigned int data_shndx,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    size_t local_symbol_count,
    const unsigned char* plocal_symbols,
    Relocatable_relocs* rr)
{
  gold_assert(sh_type == elfcpp::SHT_REL);

  typedef Arm_scan_relocatable_relocs<big_endian, elfcpp::SHT_REL,
    Relocatable_size_for_reloc> Scan_relocatable_relocs;

  gold::scan_relocatable_relocs<32, big_endian, elfcpp::SHT_REL,
      Scan_relocatable_relocs>(
    symtab,
    layout,
    object,
    data_shndx,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    local_symbol_count,
    plocal_symbols,
    rr);
}

// Emit relocations for a section.

template<bool big_endian>
void
Target_arm<big_endian>::relocate_relocs(
    const Relocate_info<32, big_endian>* relinfo,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    typename elfcpp::Elf_types<32>::Elf_Off offset_in_output_section,
    const Relocatable_relocs* rr,
    unsigned char* view,
    Arm_address view_address,
    section_size_type view_size,
    unsigned char* reloc_view,
    section_size_type reloc_view_size)
{
  gold_assert(sh_type == elfcpp::SHT_REL);

  gold::relocate_relocs<32, big_endian, elfcpp::SHT_REL>(
    relinfo,
    prelocs,
    reloc_count,
    output_section,
    offset_in_output_section,
    rr,
    view,
    view_address,
    view_size,
    reloc_view,
    reloc_view_size);
}

// Perform target-specific processing in a relocatable link.  This is
// only used if we use the relocation strategy RELOC_SPECIAL.

template<bool big_endian>
void
Target_arm<big_endian>::relocate_special_relocatable(
    const Relocate_info<32, big_endian>* relinfo,
    unsigned int sh_type,
    const unsigned char* preloc_in,
    size_t relnum,
    Output_section* output_section,
    typename elfcpp::Elf_types<32>::Elf_Off offset_in_output_section,
    unsigned char* view,
    elfcpp::Elf_types<32>::Elf_Addr view_address,
    section_size_type,
    unsigned char* preloc_out)
{
  // We can only handle REL type relocation sections.
  gold_assert(sh_type == elfcpp::SHT_REL);

  typedef typename Reloc_types<elfcpp::SHT_REL, 32, big_endian>::Reloc Reltype;
  typedef typename Reloc_types<elfcpp::SHT_REL, 32, big_endian>::Reloc_write
    Reltype_write;
  const Arm_address invalid_address = static_cast<Arm_address>(0) - 1;

  const Arm_relobj<big_endian>* object =
    Arm_relobj<big_endian>::as_arm_relobj(relinfo->object);
  const unsigned int local_count = object->local_symbol_count();

  Reltype reloc(preloc_in);
  Reltype_write reloc_write(preloc_out);

  elfcpp::Elf_types<32>::Elf_WXword r_info = reloc.get_r_info();
  const unsigned int r_sym = elfcpp::elf_r_sym<32>(r_info);
  const unsigned int r_type = elfcpp::elf_r_type<32>(r_info);

  const Arm_reloc_property* arp =
    arm_reloc_property_table->get_implemented_static_reloc_property(r_type);
  gold_assert(arp != NULL);

  // Get the new symbol index.
  // We only use RELOC_SPECIAL strategy in local relocations.
  gold_assert(r_sym < local_count);

  // We are adjusting a section symbol.  We need to find
  // the symbol table index of the section symbol for
  // the output section corresponding to input section
  // in which this symbol is defined.
  bool is_ordinary;
  unsigned int shndx = object->local_symbol_input_shndx(r_sym, &is_ordinary);
  gold_assert(is_ordinary);
  Output_section* os = object->output_section(shndx);
  gold_assert(os != NULL);
  gold_assert(os->needs_symtab_index());
  unsigned int new_symndx = os->symtab_index();

  // Get the new offset--the location in the output section where
  // this relocation should be applied.

  Arm_address offset = reloc.get_r_offset();
  Arm_address new_offset;
  if (offset_in_output_section != invalid_address)
    new_offset = offset + offset_in_output_section;
  else
    {
      section_offset_type sot_offset =
	  convert_types<section_offset_type, Arm_address>(offset);
      section_offset_type new_sot_offset =
	  output_section->output_offset(object, relinfo->data_shndx,
					sot_offset);
      gold_assert(new_sot_offset != -1);
      new_offset = new_sot_offset;
    }

  // In an object file, r_offset is an offset within the section.
  // In an executable or dynamic object, generated by
  // --emit-relocs, r_offset is an absolute address.
  if (!parameters->options().relocatable())
    {
      new_offset += view_address;
      if (offset_in_output_section != invalid_address)
	new_offset -= offset_in_output_section;
    }

  reloc_write.put_r_offset(new_offset);
  reloc_write.put_r_info(elfcpp::elf_r_info<32>(new_symndx, r_type));

  // Handle the reloc addend.
  // The relocation uses a section symbol in the input file.
  // We are adjusting it to use a section symbol in the output
  // file.  The input section symbol refers to some address in
  // the input section.  We need the relocation in the output
  // file to refer to that same address.  This adjustment to
  // the addend is the same calculation we use for a simple
  // absolute relocation for the input section symbol.

  const Symbol_value<32>* psymval = object->local_symbol(r_sym);

  // Handle THUMB bit.
  Symbol_value<32> symval;
  Arm_address thumb_bit =
     object->local_symbol_is_thumb_function(r_sym) ? 1 : 0;
  if (thumb_bit != 0
      && arp->uses_thumb_bit()
      && ((psymval->value(object, 0) & 1) != 0))
    {
      Arm_address stripped_value =
	psymval->value(object, 0) & ~static_cast<Arm_address>(1);
      symval.set_output_value(stripped_value);
      psymval = &symval;
    }

  unsigned char* paddend = view + offset;
  typename Arm_relocate_functions<big_endian>::Status reloc_status =
	Arm_relocate_functions<big_endian>::STATUS_OKAY;
  switch (r_type)
    {
    case elfcpp::R_ARM_ABS8:
      reloc_status = Arm_relocate_functions<big_endian>::abs8(paddend, object,
							      psymval);
      break;

    case elfcpp::R_ARM_ABS12:
      reloc_status = Arm_relocate_functions<big_endian>::abs12(paddend, object,
							       psymval);
      break;

    case elfcpp::R_ARM_ABS16:
      reloc_status = Arm_relocate_functions<big_endian>::abs16(paddend, object,
							       psymval);
      break;

    case elfcpp::R_ARM_THM_ABS5:
      reloc_status = Arm_relocate_functions<big_endian>::thm_abs5(paddend,
								  object,
								  psymval);
      break;

    case elfcpp::R_ARM_MOVW_ABS_NC:
    case elfcpp::R_ARM_MOVW_PREL_NC:
    case elfcpp::R_ARM_MOVW_BREL_NC:
    case elfcpp::R_ARM_MOVW_BREL:
      reloc_status = Arm_relocate_functions<big_endian>::movw(
	  paddend, object, psymval, 0, thumb_bit, arp->checks_overflow());
      break;

    case elfcpp::R_ARM_THM_MOVW_ABS_NC:
    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
    case elfcpp::R_ARM_THM_MOVW_BREL_NC:
    case elfcpp::R_ARM_THM_MOVW_BREL:
      reloc_status = Arm_relocate_functions<big_endian>::thm_movw(
	  paddend, object, psymval, 0, thumb_bit, arp->checks_overflow());
      break;

    case elfcpp::R_ARM_THM_CALL:
    case elfcpp::R_ARM_THM_XPC22:
    case elfcpp::R_ARM_THM_JUMP24:
      reloc_status =
	Arm_relocate_functions<big_endian>::thumb_branch_common(
	    r_type, relinfo, paddend, NULL, object, 0, psymval, 0, thumb_bit,
	    false);
      break;

    case elfcpp::R_ARM_PLT32:
    case elfcpp::R_ARM_CALL:
    case elfcpp::R_ARM_JUMP24:
    case elfcpp::R_ARM_XPC25:
      reloc_status =
	Arm_relocate_functions<big_endian>::arm_branch_common(
	    r_type, relinfo, paddend, NULL, object, 0, psymval, 0, thumb_bit,
	    false);
      break;

    case elfcpp::R_ARM_THM_JUMP19:
      reloc_status =
	Arm_relocate_functions<big_endian>::thm_jump19(paddend, object,
						       psymval, 0, thumb_bit);
      break;

    case elfcpp::R_ARM_THM_JUMP6:
      reloc_status =
	Arm_relocate_functions<big_endian>::thm_jump6(paddend, object, psymval,
						      0);
      break;

    case elfcpp::R_ARM_THM_JUMP8:
      reloc_status =
	Arm_relocate_functions<big_endian>::thm_jump8(paddend, object, psymval,
						      0);
      break;

    case elfcpp::R_ARM_THM_JUMP11:
      reloc_status =
	Arm_relocate_functions<big_endian>::thm_jump11(paddend, object, psymval,
						       0);
      break;

    case elfcpp::R_ARM_PREL31:
      reloc_status =
	Arm_relocate_functions<big_endian>::prel31(paddend, object, psymval, 0,
						   thumb_bit);
      break;

    case elfcpp::R_ARM_THM_PC8:
      reloc_status =
	Arm_relocate_functions<big_endian>::thm_pc8(paddend, object, psymval,
						    0);
      break;

    case elfcpp::R_ARM_THM_PC12:
      reloc_status =
	Arm_relocate_functions<big_endian>::thm_pc12(paddend, object, psymval,
						     0);
      break;

    case elfcpp::R_ARM_THM_ALU_PREL_11_0:
      reloc_status =
	Arm_relocate_functions<big_endian>::thm_alu11(paddend, object, psymval,
						      0, thumb_bit);
      break;

    // These relocation truncate relocation results so we cannot handle them
    // in a relocatable link.
    case elfcpp::R_ARM_MOVT_ABS:
    case elfcpp::R_ARM_THM_MOVT_ABS:
    case elfcpp::R_ARM_MOVT_PREL:
    case elfcpp::R_ARM_MOVT_BREL:
    case elfcpp::R_ARM_THM_MOVT_PREL:
    case elfcpp::R_ARM_THM_MOVT_BREL:
    case elfcpp::R_ARM_ALU_PC_G0_NC:
    case elfcpp::R_ARM_ALU_PC_G0:
    case elfcpp::R_ARM_ALU_PC_G1_NC:
    case elfcpp::R_ARM_ALU_PC_G1:
    case elfcpp::R_ARM_ALU_PC_G2:
    case elfcpp::R_ARM_ALU_SB_G0_NC:
    case elfcpp::R_ARM_ALU_SB_G0:
    case elfcpp::R_ARM_ALU_SB_G1_NC:
    case elfcpp::R_ARM_ALU_SB_G1:
    case elfcpp::R_ARM_ALU_SB_G2:
    case elfcpp::R_ARM_LDR_PC_G0:
    case elfcpp::R_ARM_LDR_PC_G1:
    case elfcpp::R_ARM_LDR_PC_G2:
    case elfcpp::R_ARM_LDR_SB_G0:
    case elfcpp::R_ARM_LDR_SB_G1:
    case elfcpp::R_ARM_LDR_SB_G2:
    case elfcpp::R_ARM_LDRS_PC_G0:
    case elfcpp::R_ARM_LDRS_PC_G1:
    case elfcpp::R_ARM_LDRS_PC_G2:
    case elfcpp::R_ARM_LDRS_SB_G0:
    case elfcpp::R_ARM_LDRS_SB_G1:
    case elfcpp::R_ARM_LDRS_SB_G2:
    case elfcpp::R_ARM_LDC_PC_G0:
    case elfcpp::R_ARM_LDC_PC_G1:
    case elfcpp::R_ARM_LDC_PC_G2:
    case elfcpp::R_ARM_LDC_SB_G0:
    case elfcpp::R_ARM_LDC_SB_G1:
    case elfcpp::R_ARM_LDC_SB_G2:
      gold_error(_("cannot handle %s in a relocatable link"),
		 arp->name().c_str());
      break;

    default:
      gold_unreachable();
    }

  // Report any errors.
  switch (reloc_status)
    {
    case Arm_relocate_functions<big_endian>::STATUS_OKAY:
      break;
    case Arm_relocate_functions<big_endian>::STATUS_OVERFLOW:
      gold_error_at_location(relinfo, relnum, reloc.get_r_offset(),
			     _("relocation overflow in %s"),
			     arp->name().c_str());
      break;
    case Arm_relocate_functions<big_endian>::STATUS_BAD_RELOC:
      gold_error_at_location(relinfo, relnum, reloc.get_r_offset(),
	_("unexpected opcode while processing relocation %s"),
	arp->name().c_str());
      break;
    default:
      gold_unreachable();
    }
}

// Return the value to use for a dynamic symbol which requires special
// treatment.  This is how we support equality comparisons of function
// pointers across shared library boundaries, as described in the
// processor specific ABI supplement.

template<bool big_endian>
uint64_t
Target_arm<big_endian>::do_dynsym_value(const Symbol* gsym) const
{
  gold_assert(gsym->is_from_dynobj() && gsym->has_plt_offset());
  return this->plt_section()->address() + gsym->plt_offset();
}

// Map platform-specific relocs to real relocs
//
template<bool big_endian>
unsigned int
Target_arm<big_endian>::get_real_reloc_type(unsigned int r_type)
{
  switch (r_type)
    {
    case elfcpp::R_ARM_TARGET1:
      // This is either R_ARM_ABS32 or R_ARM_REL32;
      return elfcpp::R_ARM_ABS32;

    case elfcpp::R_ARM_TARGET2:
      // This can be any reloc type but usually is R_ARM_GOT_PREL
      return elfcpp::R_ARM_GOT_PREL;

    default:
      return r_type;
    }
}

// Whether if two EABI versions V1 and V2 are compatible.

template<bool big_endian>
bool
Target_arm<big_endian>::are_eabi_versions_compatible(
    elfcpp::Elf_Word v1,
    elfcpp::Elf_Word v2)
{
  // v4 and v5 are the same spec before and after it was released,
  // so allow mixing them.
  if ((v1 == elfcpp::EF_ARM_EABI_UNKNOWN || v2 == elfcpp::EF_ARM_EABI_UNKNOWN)
      || (v1 == elfcpp::EF_ARM_EABI_VER4 && v2 == elfcpp::EF_ARM_EABI_VER5)
      || (v1 == elfcpp::EF_ARM_EABI_VER5 && v2 == elfcpp::EF_ARM_EABI_VER4))
    return true;

  return v1 == v2;
}

// Combine FLAGS from an input object called NAME and the processor-specific
// flags in the ELF header of the output.  Much of this is adapted from the
// processor-specific flags merging code in elf32_arm_merge_private_bfd_data
// in bfd/elf32-arm.c.

template<bool big_endian>
void
Target_arm<big_endian>::merge_processor_specific_flags(
    const std::string& name,
    elfcpp::Elf_Word flags)
{
  if (this->are_processor_specific_flags_set())
    {
      elfcpp::Elf_Word out_flags = this->processor_specific_flags();

      // Nothing to merge if flags equal to those in output.
      if (flags == out_flags)
	return;

      // Complain about various flag mismatches.
      elfcpp::Elf_Word version1 = elfcpp::arm_eabi_version(flags);
      elfcpp::Elf_Word version2 = elfcpp::arm_eabi_version(out_flags);
      if (!this->are_eabi_versions_compatible(version1, version2)
	  && parameters->options().warn_mismatch())
	gold_error(_("Source object %s has EABI version %d but output has "
		     "EABI version %d."),
		   name.c_str(),
		   (flags & elfcpp::EF_ARM_EABIMASK) >> 24,
		   (out_flags & elfcpp::EF_ARM_EABIMASK) >> 24);
    }
  else
    {
      // If the input is the default architecture and had the default
      // flags then do not bother setting the flags for the output
      // architecture, instead allow future merges to do this.  If no
      // future merges ever set these flags then they will retain their
      // uninitialised values, which surprise surprise, correspond
      // to the default values.
      if (flags == 0)
	return;

      // This is the first time, just copy the flags.
      // We only copy the EABI version for now.
      this->set_processor_specific_flags(flags & elfcpp::EF_ARM_EABIMASK);
    }
}

// Adjust ELF file header.
template<bool big_endian>
void
Target_arm<big_endian>::do_adjust_elf_header(
    unsigned char* view,
    int len)
{
  gold_assert(len == elfcpp::Elf_sizes<32>::ehdr_size);

  elfcpp::Ehdr<32, big_endian> ehdr(view);
  elfcpp::Elf_Word flags = this->processor_specific_flags();
  unsigned char e_ident[elfcpp::EI_NIDENT];
  memcpy(e_ident, ehdr.get_e_ident(), elfcpp::EI_NIDENT);

  if (elfcpp::arm_eabi_version(flags)
      == elfcpp::EF_ARM_EABI_UNKNOWN)
    e_ident[elfcpp::EI_OSABI] = elfcpp::ELFOSABI_ARM;
  else
    e_ident[elfcpp::EI_OSABI] = 0;
  e_ident[elfcpp::EI_ABIVERSION] = 0;

  // FIXME: Do EF_ARM_BE8 adjustment.

  // If we're working in EABI_VER5, set the hard/soft float ABI flags
  // as appropriate.
  if (elfcpp::arm_eabi_version(flags) == elfcpp::EF_ARM_EABI_VER5)
  {
    elfcpp::Elf_Half type = ehdr.get_e_type();
    if (type == elfcpp::ET_EXEC || type == elfcpp::ET_DYN)
      {
	Object_attribute* attr = this->get_aeabi_object_attribute(elfcpp::Tag_ABI_VFP_args);
	if (attr->int_value())
	  flags |= elfcpp::EF_ARM_ABI_FLOAT_HARD;
	else
	  flags |= elfcpp::EF_ARM_ABI_FLOAT_SOFT;
	this->set_processor_specific_flags(flags);
      }
  }
  elfcpp::Ehdr_write<32, big_endian> oehdr(view);
  oehdr.put_e_ident(e_ident);
}

// do_make_elf_object to override the same function in the base class.
// We need to use a target-specific sub-class of
// Sized_relobj_file<32, big_endian> to store ARM specific information.
// Hence we need to have our own ELF object creation.

template<bool big_endian>
Object*
Target_arm<big_endian>::do_make_elf_object(
    const std::string& name,
    Input_file* input_file,
    off_t offset, const elfcpp::Ehdr<32, big_endian>& ehdr)
{
  int et = ehdr.get_e_type();
  // ET_EXEC files are valid input for --just-symbols/-R,
  // and we treat them as relocatable objects.
  if (et == elfcpp::ET_REL
      || (et == elfcpp::ET_EXEC && input_file->just_symbols()))
    {
      Arm_relobj<big_endian>* obj =
	new Arm_relobj<big_endian>(name, input_file, offset, ehdr);
      obj->setup();
      return obj;
    }
  else if (et == elfcpp::ET_DYN)
    {
      Sized_dynobj<32, big_endian>* obj =
	new Arm_dynobj<big_endian>(name, input_file, offset, ehdr);
      obj->setup();
      return obj;
    }
  else
    {
      gold_error(_("%s: unsupported ELF file type %d"),
		 name.c_str(), et);
      return NULL;
    }
}

// Read the architecture from the Tag_also_compatible_with attribute, if any.
// Returns -1 if no architecture could be read.
// This is adapted from get_secondary_compatible_arch() in bfd/elf32-arm.c.

template<bool big_endian>
int
Target_arm<big_endian>::get_secondary_compatible_arch(
    const Attributes_section_data* pasd)
{
  const Object_attribute* known_attributes =
    pasd->known_attributes(Object_attribute::OBJ_ATTR_PROC);

  // Note: the tag and its argument below are uleb128 values, though
  // currently-defined values fit in one byte for each.
  const std::string& sv =
    known_attributes[elfcpp::Tag_also_compatible_with].string_value();
  if (sv.size() == 2
      && sv.data()[0] == elfcpp::Tag_CPU_arch
      && (sv.data()[1] & 128) != 128)
   return sv.data()[1];

  // This tag is "safely ignorable", so don't complain if it looks funny.
  return -1;
}

// Set, or unset, the architecture of the Tag_also_compatible_with attribute.
// The tag is removed if ARCH is -1.
// This is adapted from set_secondary_compatible_arch() in bfd/elf32-arm.c.

template<bool big_endian>
void
Target_arm<big_endian>::set_secondary_compatible_arch(
    Attributes_section_data* pasd,
    int arch)
{
  Object_attribute* known_attributes =
    pasd->known_attributes(Object_attribute::OBJ_ATTR_PROC);

  if (arch == -1)
    {
      known_attributes[elfcpp::Tag_also_compatible_with].set_string_value("");
      return;
    }

  // Note: the tag and its argument below are uleb128 values, though
  // currently-defined values fit in one byte for each.
  char sv[3];
  sv[0] = elfcpp::Tag_CPU_arch;
  gold_assert(arch != 0);
  sv[1] = arch;
  sv[2] = '\0';

  known_attributes[elfcpp::Tag_also_compatible_with].set_string_value(sv);
}

// Combine two values for Tag_CPU_arch, taking secondary compatibility tags
// into account.
// This is adapted from tag_cpu_arch_combine() in bfd/elf32-arm.c.

template<bool big_endian>
int
Target_arm<big_endian>::tag_cpu_arch_combine(
    const char* name,
    int oldtag,
    int* secondary_compat_out,
    int newtag,
    int secondary_compat)
{
#define T(X) elfcpp::TAG_CPU_ARCH_##X
  static const int v6t2[] =
    {
      T(V6T2),   // PRE_V4.
      T(V6T2),   // V4.
      T(V6T2),   // V4T.
      T(V6T2),   // V5T.
      T(V6T2),   // V5TE.
      T(V6T2),   // V5TEJ.
      T(V6T2),   // V6.
      T(V7),     // V6KZ.
      T(V6T2)    // V6T2.
    };
  static const int v6k[] =
    {
      T(V6K),    // PRE_V4.
      T(V6K),    // V4.
      T(V6K),    // V4T.
      T(V6K),    // V5T.
      T(V6K),    // V5TE.
      T(V6K),    // V5TEJ.
      T(V6K),    // V6.
      T(V6KZ),   // V6KZ.
      T(V7),     // V6T2.
      T(V6K)     // V6K.
    };
  static const int v7[] =
    {
      T(V7),     // PRE_V4.
      T(V7),     // V4.
      T(V7),     // V4T.
      T(V7),     // V5T.
      T(V7),     // V5TE.
      T(V7),     // V5TEJ.
      T(V7),     // V6.
      T(V7),     // V6KZ.
      T(V7),     // V6T2.
      T(V7),     // V6K.
      T(V7)      // V7.
    };
  static const int v6_m[] =
    {
      -1,        // PRE_V4.
      -1,        // V4.
      T(V6K),    // V4T.
      T(V6K),    // V5T.
      T(V6K),    // V5TE.
      T(V6K),    // V5TEJ.
      T(V6K),    // V6.
      T(V6KZ),   // V6KZ.
      T(V7),     // V6T2.
      T(V6K),    // V6K.
      T(V7),     // V7.
      T(V6_M)    // V6_M.
    };
  static const int v6s_m[] =
    {
      -1,        // PRE_V4.
      -1,        // V4.
      T(V6K),    // V4T.
      T(V6K),    // V5T.
      T(V6K),    // V5TE.
      T(V6K),    // V5TEJ.
      T(V6K),    // V6.
      T(V6KZ),   // V6KZ.
      T(V7),     // V6T2.
      T(V6K),    // V6K.
      T(V7),     // V7.
      T(V6S_M),  // V6_M.
      T(V6S_M)   // V6S_M.
    };
  static const int v7e_m[] =
    {
      -1,	// PRE_V4.
      -1,	// V4.
      T(V7E_M),	// V4T.
      T(V7E_M),	// V5T.
      T(V7E_M),	// V5TE.
      T(V7E_M),	// V5TEJ.
      T(V7E_M),	// V6.
      T(V7E_M),	// V6KZ.
      T(V7E_M),	// V6T2.
      T(V7E_M),	// V6K.
      T(V7E_M),	// V7.
      T(V7E_M),	// V6_M.
      T(V7E_M),	// V6S_M.
      T(V7E_M)	// V7E_M.
    };
  static const int v4t_plus_v6_m[] =
    {
      -1,		// PRE_V4.
      -1,		// V4.
      T(V4T),		// V4T.
      T(V5T),		// V5T.
      T(V5TE),		// V5TE.
      T(V5TEJ),		// V5TEJ.
      T(V6),		// V6.
      T(V6KZ),		// V6KZ.
      T(V6T2),		// V6T2.
      T(V6K),		// V6K.
      T(V7),		// V7.
      T(V6_M),		// V6_M.
      T(V6S_M),		// V6S_M.
      T(V7E_M),		// V7E_M.
      T(V4T_PLUS_V6_M)	// V4T plus V6_M.
    };
  static const int* comb[] =
    {
      v6t2,
      v6k,
      v7,
      v6_m,
      v6s_m,
      v7e_m,
      // Pseudo-architecture.
      v4t_plus_v6_m
    };

  // Check we've not got a higher architecture than we know about.

  if (oldtag > elfcpp::MAX_TAG_CPU_ARCH || newtag > elfcpp::MAX_TAG_CPU_ARCH)
    {
      gold_error(_("%s: unknown CPU architecture"), name);
      return -1;
    }

  // Override old tag if we have a Tag_also_compatible_with on the output.

  if ((oldtag == T(V6_M) && *secondary_compat_out == T(V4T))
      || (oldtag == T(V4T) && *secondary_compat_out == T(V6_M)))
    oldtag = T(V4T_PLUS_V6_M);

  // And override the new tag if we have a Tag_also_compatible_with on the
  // input.

  if ((newtag == T(V6_M) && secondary_compat == T(V4T))
      || (newtag == T(V4T) && secondary_compat == T(V6_M)))
    newtag = T(V4T_PLUS_V6_M);

  // Architectures before V6KZ add features monotonically.
  int tagh = std::max(oldtag, newtag);
  if (tagh <= elfcpp::TAG_CPU_ARCH_V6KZ)
    return tagh;

  int tagl = std::min(oldtag, newtag);
  int result = comb[tagh - T(V6T2)][tagl];

  // Use Tag_CPU_arch == V4T and Tag_also_compatible_with (Tag_CPU_arch V6_M)
  // as the canonical version.
  if (result == T(V4T_PLUS_V6_M))
    {
      result = T(V4T);
      *secondary_compat_out = T(V6_M);
    }
  else
    *secondary_compat_out = -1;

  if (result == -1)
    {
      gold_error(_("%s: conflicting CPU architectures %d/%d"),
		 name, oldtag, newtag);
      return -1;
    }

  return result;
#undef T
}

// Helper to print AEABI enum tag value.

template<bool big_endian>
std::string
Target_arm<big_endian>::aeabi_enum_name(unsigned int value)
{
  static const char* aeabi_enum_names[] =
    { "", "variable-size", "32-bit", "" };
  const size_t aeabi_enum_names_size =
    sizeof(aeabi_enum_names) / sizeof(aeabi_enum_names[0]);

  if (value < aeabi_enum_names_size)
    return std::string(aeabi_enum_names[value]);
  else
    {
      char buffer[100];
      sprintf(buffer, "<unknown value %u>", value);
      return std::string(buffer);
    }
}

// Return the string value to store in TAG_CPU_name.

template<bool big_endian>
std::string
Target_arm<big_endian>::tag_cpu_name_value(unsigned int value)
{
  static const char* name_table[] = {
    // These aren't real CPU names, but we can't guess
    // that from the architecture version alone.
   "Pre v4",
   "ARM v4",
   "ARM v4T",
   "ARM v5T",
   "ARM v5TE",
   "ARM v5TEJ",
   "ARM v6",
   "ARM v6KZ",
   "ARM v6T2",
   "ARM v6K",
   "ARM v7",
   "ARM v6-M",
   "ARM v6S-M",
   "ARM v7E-M"
 };
 const size_t name_table_size = sizeof(name_table) / sizeof(name_table[0]);

  if (value < name_table_size)
    return std::string(name_table[value]);
  else
    {
      char buffer[100];
      sprintf(buffer, "<unknown CPU value %u>", value);
      return std::string(buffer);
    }
}

// Query attributes object to see if integer divide instructions may be
// present in an object.

template<bool big_endian>
bool
Target_arm<big_endian>::attributes_accept_div(int arch, int profile,
    const Object_attribute* div_attr)
{
  switch (div_attr->int_value())
    {
    case 0:
      // Integer divide allowed if instruction contained in
      // archetecture.
      if (arch == elfcpp::TAG_CPU_ARCH_V7 && (profile == 'R' || profile == 'M'))
        return true;
      else if (arch >= elfcpp::TAG_CPU_ARCH_V7E_M)
        return true;
      else
        return false;

    case 1:
      // Integer divide explicitly prohibited.
      return false;

    default:
      // Unrecognised case - treat as allowing divide everywhere.
    case 2:
      // Integer divide allowed in ARM state.
      return true;
    }
}

// Query attributes object to see if integer divide instructions are
// forbidden to be in the object.  This is not the inverse of
// attributes_accept_div.

template<bool big_endian>
bool
Target_arm<big_endian>::attributes_forbid_div(const Object_attribute* div_attr)
{
  return div_attr->int_value() == 1;
}

// Merge object attributes from input file called NAME with those of the
// output.  The input object attributes are in the object pointed by PASD.

template<bool big_endian>
void
Target_arm<big_endian>::merge_object_attributes(
    const char* name,
    const Attributes_section_data* pasd)
{
  // Return if there is no attributes section data.
  if (pasd == NULL)
    return;

  // If output has no object attributes, just copy.
  const int vendor = Object_attribute::OBJ_ATTR_PROC;
  if (this->attributes_section_data_ == NULL)
    {
      this->attributes_section_data_ = new Attributes_section_data(*pasd);
      Object_attribute* out_attr =
	this->attributes_section_data_->known_attributes(vendor);

      // We do not output objects with Tag_MPextension_use_legacy - we move
      //  the attribute's value to Tag_MPextension_use.  */
      if (out_attr[elfcpp::Tag_MPextension_use_legacy].int_value() != 0)
	{
	  if (out_attr[elfcpp::Tag_MPextension_use].int_value() != 0
	      && out_attr[elfcpp::Tag_MPextension_use_legacy].int_value()
		!= out_attr[elfcpp::Tag_MPextension_use].int_value())
	    {
	      gold_error(_("%s has both the current and legacy "
			   "Tag_MPextension_use attributes"),
			 name);
	    }

	  out_attr[elfcpp::Tag_MPextension_use] =
	    out_attr[elfcpp::Tag_MPextension_use_legacy];
	  out_attr[elfcpp::Tag_MPextension_use_legacy].set_type(0);
	  out_attr[elfcpp::Tag_MPextension_use_legacy].set_int_value(0);
	}

      return;
    }

  const Object_attribute* in_attr = pasd->known_attributes(vendor);
  Object_attribute* out_attr =
    this->attributes_section_data_->known_attributes(vendor);

  // This needs to happen before Tag_ABI_FP_number_model is merged.  */
  if (in_attr[elfcpp::Tag_ABI_VFP_args].int_value()
      != out_attr[elfcpp::Tag_ABI_VFP_args].int_value())
    {
      // Ignore mismatches if the object doesn't use floating point.  */
      if (out_attr[elfcpp::Tag_ABI_FP_number_model].int_value() == 0)
	out_attr[elfcpp::Tag_ABI_VFP_args].set_int_value(
	    in_attr[elfcpp::Tag_ABI_VFP_args].int_value());
      else if (in_attr[elfcpp::Tag_ABI_FP_number_model].int_value() != 0
	       && parameters->options().warn_mismatch())
	gold_error(_("%s uses VFP register arguments, output does not"),
		   name);
    }

  for (int i = 4; i < Vendor_object_attributes::NUM_KNOWN_ATTRIBUTES; ++i)
    {
      // Merge this attribute with existing attributes.
      switch (i)
	{
	case elfcpp::Tag_CPU_raw_name:
	case elfcpp::Tag_CPU_name:
	  // These are merged after Tag_CPU_arch.
	  break;

	case elfcpp::Tag_ABI_optimization_goals:
	case elfcpp::Tag_ABI_FP_optimization_goals:
	  // Use the first value seen.
	  break;

	case elfcpp::Tag_CPU_arch:
	  {
	    unsigned int saved_out_attr = out_attr->int_value();
	    // Merge Tag_CPU_arch and Tag_also_compatible_with.
	    int secondary_compat =
	      this->get_secondary_compatible_arch(pasd);
	    int secondary_compat_out =
	      this->get_secondary_compatible_arch(
		  this->attributes_section_data_);
	    out_attr[i].set_int_value(
		tag_cpu_arch_combine(name, out_attr[i].int_value(),
				     &secondary_compat_out,
				     in_attr[i].int_value(),
				     secondary_compat));
	    this->set_secondary_compatible_arch(this->attributes_section_data_,
						secondary_compat_out);

	    // Merge Tag_CPU_name and Tag_CPU_raw_name.
	    if (out_attr[i].int_value() == saved_out_attr)
	      ; // Leave the names alone.
	    else if (out_attr[i].int_value() == in_attr[i].int_value())
	      {
		// The output architecture has been changed to match the
		// input architecture.  Use the input names.
		out_attr[elfcpp::Tag_CPU_name].set_string_value(
		    in_attr[elfcpp::Tag_CPU_name].string_value());
		out_attr[elfcpp::Tag_CPU_raw_name].set_string_value(
		    in_attr[elfcpp::Tag_CPU_raw_name].string_value());
	      }
	    else
	      {
		out_attr[elfcpp::Tag_CPU_name].set_string_value("");
		out_attr[elfcpp::Tag_CPU_raw_name].set_string_value("");
	      }

	    // If we still don't have a value for Tag_CPU_name,
	    // make one up now.  Tag_CPU_raw_name remains blank.
	    if (out_attr[elfcpp::Tag_CPU_name].string_value() == "")
	      {
		const std::string cpu_name =
		  this->tag_cpu_name_value(out_attr[i].int_value());
		// FIXME:  If we see an unknown CPU, this will be set
		// to "<unknown CPU n>", where n is the attribute value.
		// This is different from BFD, which leaves the name alone.
		out_attr[elfcpp::Tag_CPU_name].set_string_value(cpu_name);
	      }
	  }
	  break;

	case elfcpp::Tag_ARM_ISA_use:
	case elfcpp::Tag_THUMB_ISA_use:
	case elfcpp::Tag_WMMX_arch:
	case elfcpp::Tag_Advanced_SIMD_arch:
	  // ??? Do Advanced_SIMD (NEON) and WMMX conflict?
	case elfcpp::Tag_ABI_FP_rounding:
	case elfcpp::Tag_ABI_FP_exceptions:
	case elfcpp::Tag_ABI_FP_user_exceptions:
	case elfcpp::Tag_ABI_FP_number_model:
	case elfcpp::Tag_VFP_HP_extension:
	case elfcpp::Tag_CPU_unaligned_access:
	case elfcpp::Tag_T2EE_use:
	case elfcpp::Tag_Virtualization_use:
	case elfcpp::Tag_MPextension_use:
	  // Use the largest value specified.
	  if (in_attr[i].int_value() > out_attr[i].int_value())
	    out_attr[i].set_int_value(in_attr[i].int_value());
	  break;

	case elfcpp::Tag_ABI_align8_preserved:
	case elfcpp::Tag_ABI_PCS_RO_data:
	  // Use the smallest value specified.
	  if (in_attr[i].int_value() < out_attr[i].int_value())
	    out_attr[i].set_int_value(in_attr[i].int_value());
	  break;

	case elfcpp::Tag_ABI_align8_needed:
	  if ((in_attr[i].int_value() > 0 || out_attr[i].int_value() > 0)
	      && (in_attr[elfcpp::Tag_ABI_align8_preserved].int_value() == 0
		  || (out_attr[elfcpp::Tag_ABI_align8_preserved].int_value()
		      == 0)))
	    {
	      // This error message should be enabled once all non-conforming
	      // binaries in the toolchain have had the attributes set
	      // properly.
	      // gold_error(_("output 8-byte data alignment conflicts with %s"),
	      // 	    name);
	    }
	  // Fall through.
	case elfcpp::Tag_ABI_FP_denormal:
	case elfcpp::Tag_ABI_PCS_GOT_use:
	  {
	    // These tags have 0 = don't care, 1 = strong requirement,
	    // 2 = weak requirement.
	    static const int order_021[3] = {0, 2, 1};

	    // Use the "greatest" from the sequence 0, 2, 1, or the largest
	    // value if greater than 2 (for future-proofing).
	    if ((in_attr[i].int_value() > 2
		 && in_attr[i].int_value() > out_attr[i].int_value())
		|| (in_attr[i].int_value() <= 2
		    && out_attr[i].int_value() <= 2
		    && (order_021[in_attr[i].int_value()]
			> order_021[out_attr[i].int_value()])))
	      out_attr[i].set_int_value(in_attr[i].int_value());
	  }
	  break;

	case elfcpp::Tag_CPU_arch_profile:
	  if (out_attr[i].int_value() != in_attr[i].int_value())
	    {
	      // 0 will merge with anything.
	      // 'A' and 'S' merge to 'A'.
	      // 'R' and 'S' merge to 'R'.
	      // 'M' and 'A|R|S' is an error.
	      if (out_attr[i].int_value() == 0
		  || (out_attr[i].int_value() == 'S'
		      && (in_attr[i].int_value() == 'A'
			  || in_attr[i].int_value() == 'R')))
		out_attr[i].set_int_value(in_attr[i].int_value());
	      else if (in_attr[i].int_value() == 0
		       || (in_attr[i].int_value() == 'S'
			   && (out_attr[i].int_value() == 'A'
			       || out_attr[i].int_value() == 'R')))
		; // Do nothing.
	      else if (parameters->options().warn_mismatch())
		{
		  gold_error
		    (_("conflicting architecture profiles %c/%c"),
		     in_attr[i].int_value() ? in_attr[i].int_value() : '0',
		     out_attr[i].int_value() ? out_attr[i].int_value() : '0');
		}
	    }
	  break;
	case elfcpp::Tag_VFP_arch:
	    {
	      static const struct
	      {
		  int ver;
		  int regs;
	      } vfp_versions[7] =
		{
		  {0, 0},
		  {1, 16},
		  {2, 16},
		  {3, 32},
		  {3, 16},
		  {4, 32},
		  {4, 16}
		};

	      // Values greater than 6 aren't defined, so just pick the
	      // biggest.
	      if (in_attr[i].int_value() > 6
		  && in_attr[i].int_value() > out_attr[i].int_value())
		{
		  *out_attr = *in_attr;
		  break;
		}
	      // The output uses the superset of input features
	      // (ISA version) and registers.
	      int ver = std::max(vfp_versions[in_attr[i].int_value()].ver,
				 vfp_versions[out_attr[i].int_value()].ver);
	      int regs = std::max(vfp_versions[in_attr[i].int_value()].regs,
				  vfp_versions[out_attr[i].int_value()].regs);
	      // This assumes all possible supersets are also a valid
	      // options.
	      int newval;
	      for (newval = 6; newval > 0; newval--)
		{
		  if (regs == vfp_versions[newval].regs
		      && ver == vfp_versions[newval].ver)
		    break;
		}
	      out_attr[i].set_int_value(newval);
	    }
	  break;
	case elfcpp::Tag_PCS_config:
	  if (out_attr[i].int_value() == 0)
	    out_attr[i].set_int_value(in_attr[i].int_value());
	  else if (in_attr[i].int_value() != 0
		   && out_attr[i].int_value() != 0
		   && parameters->options().warn_mismatch())
	    {
	      // It's sometimes ok to mix different configs, so this is only
	      // a warning.
	      gold_warning(_("%s: conflicting platform configuration"), name);
	    }
	  break;
	case elfcpp::Tag_ABI_PCS_R9_use:
	  if (in_attr[i].int_value() != out_attr[i].int_value()
	      && out_attr[i].int_value() != elfcpp::AEABI_R9_unused
	      && in_attr[i].int_value() != elfcpp::AEABI_R9_unused
	      && parameters->options().warn_mismatch())
	    {
	      gold_error(_("%s: conflicting use of R9"), name);
	    }
	  if (out_attr[i].int_value() == elfcpp::AEABI_R9_unused)
	    out_attr[i].set_int_value(in_attr[i].int_value());
	  break;
	case elfcpp::Tag_ABI_PCS_RW_data:
	  if (in_attr[i].int_value() == elfcpp::AEABI_PCS_RW_data_SBrel
	      && (in_attr[elfcpp::Tag_ABI_PCS_R9_use].int_value()
		  != elfcpp::AEABI_R9_SB)
	      && (out_attr[elfcpp::Tag_ABI_PCS_R9_use].int_value()
		  != elfcpp::AEABI_R9_unused)
	      && parameters->options().warn_mismatch())
	    {
	      gold_error(_("%s: SB relative addressing conflicts with use "
			   "of R9"),
			   name);
	    }
	  // Use the smallest value specified.
	  if (in_attr[i].int_value() < out_attr[i].int_value())
	    out_attr[i].set_int_value(in_attr[i].int_value());
	  break;
	case elfcpp::Tag_ABI_PCS_wchar_t:
	  if (out_attr[i].int_value()
	      && in_attr[i].int_value()
	      && out_attr[i].int_value() != in_attr[i].int_value()
	      && parameters->options().warn_mismatch()
	      && parameters->options().wchar_size_warning())
	    {
	      gold_warning(_("%s uses %u-byte wchar_t yet the output is to "
			     "use %u-byte wchar_t; use of wchar_t values "
			     "across objects may fail"),
			   name, in_attr[i].int_value(),
			   out_attr[i].int_value());
	    }
	  else if (in_attr[i].int_value() && !out_attr[i].int_value())
	    out_attr[i].set_int_value(in_attr[i].int_value());
	  break;
	case elfcpp::Tag_ABI_enum_size:
	  if (in_attr[i].int_value() != elfcpp::AEABI_enum_unused)
	    {
	      if (out_attr[i].int_value() == elfcpp::AEABI_enum_unused
		  || out_attr[i].int_value() == elfcpp::AEABI_enum_forced_wide)
		{
		  // The existing object is compatible with anything.
		  // Use whatever requirements the new object has.
		  out_attr[i].set_int_value(in_attr[i].int_value());
		}
	      else if (in_attr[i].int_value() != elfcpp::AEABI_enum_forced_wide
		       && out_attr[i].int_value() != in_attr[i].int_value()
		       && parameters->options().warn_mismatch()
		       && parameters->options().enum_size_warning())
		{
		  unsigned int in_value = in_attr[i].int_value();
		  unsigned int out_value = out_attr[i].int_value();
		  gold_warning(_("%s uses %s enums yet the output is to use "
				 "%s enums; use of enum values across objects "
				 "may fail"),
			       name,
			       this->aeabi_enum_name(in_value).c_str(),
			       this->aeabi_enum_name(out_value).c_str());
		}
	    }
	  break;
	case elfcpp::Tag_ABI_VFP_args:
	  // Already done.
	  break;
	case elfcpp::Tag_ABI_WMMX_args:
	  if (in_attr[i].int_value() != out_attr[i].int_value()
	      && parameters->options().warn_mismatch())
	    {
	      gold_error(_("%s uses iWMMXt register arguments, output does "
			   "not"),
			 name);
	    }
	  break;
	case Object_attribute::Tag_compatibility:
	  // Merged in target-independent code.
	  break;
	case elfcpp::Tag_ABI_HardFP_use:
	  // 1 (SP) and 2 (DP) conflict, so combine to 3 (SP & DP).
	  if ((in_attr[i].int_value() == 1 && out_attr[i].int_value() == 2)
	      || (in_attr[i].int_value() == 2 && out_attr[i].int_value() == 1))
	    out_attr[i].set_int_value(3);
	  else if (in_attr[i].int_value() > out_attr[i].int_value())
	    out_attr[i].set_int_value(in_attr[i].int_value());
	  break;
	case elfcpp::Tag_ABI_FP_16bit_format:
	  if (in_attr[i].int_value() != 0 && out_attr[i].int_value() != 0)
	    {
	      if (in_attr[i].int_value() != out_attr[i].int_value()
		  && parameters->options().warn_mismatch())
		gold_error(_("fp16 format mismatch between %s and output"),
			   name);
	    }
	  if (in_attr[i].int_value() != 0)
	    out_attr[i].set_int_value(in_attr[i].int_value());
	  break;

	case elfcpp::Tag_DIV_use:
	  {
	    // A value of zero on input means that the divide
	    // instruction may be used if available in the base
	    // architecture as specified via Tag_CPU_arch and
	    // Tag_CPU_arch_profile.  A value of 1 means that the user
	    // did not want divide instructions.  A value of 2
	    // explicitly means that divide instructions were allowed
	    // in ARM and Thumb state.
	    int arch = this->
	      get_aeabi_object_attribute(elfcpp::Tag_CPU_arch)->
	      int_value();
	    int profile = this->
	      get_aeabi_object_attribute(elfcpp::Tag_CPU_arch_profile)->
	      int_value();
	    if (in_attr[i].int_value() == out_attr[i].int_value())
	      {
		// Do nothing.
	      }
	    else if (attributes_forbid_div(&in_attr[i])
		     && !attributes_accept_div(arch, profile, &out_attr[i]))
	      out_attr[i].set_int_value(1);
	    else if (attributes_forbid_div(&out_attr[i])
		     && attributes_accept_div(arch, profile, &in_attr[i]))
	      out_attr[i].set_int_value(in_attr[i].int_value());
	    else if (in_attr[i].int_value() == 2)
	      out_attr[i].set_int_value(in_attr[i].int_value());
	  }
	  break;

	case elfcpp::Tag_MPextension_use_legacy:
	  // We don't output objects with Tag_MPextension_use_legacy - we
	  // move the value to Tag_MPextension_use.
	  if (in_attr[i].int_value() != 0
	      && in_attr[elfcpp::Tag_MPextension_use].int_value() != 0)
	    {
	      if (in_attr[elfcpp::Tag_MPextension_use].int_value()
		  != in_attr[i].int_value())
		{
		  gold_error(_("%s has has both the current and legacy "
			       "Tag_MPextension_use attributes"),
			     name);
		}
	    }

	  if (in_attr[i].int_value()
	      > out_attr[elfcpp::Tag_MPextension_use].int_value())
	    out_attr[elfcpp::Tag_MPextension_use] = in_attr[i];

	  break;

	case elfcpp::Tag_nodefaults:
	  // This tag is set if it exists, but the value is unused (and is
	  // typically zero).  We don't actually need to do anything here -
	  // the merge happens automatically when the type flags are merged
	  // below.
	  break;
	case elfcpp::Tag_also_compatible_with:
	  // Already done in Tag_CPU_arch.
	  break;
	case elfcpp::Tag_conformance:
	  // Keep the attribute if it matches.  Throw it away otherwise.
	  // No attribute means no claim to conform.
	  if (in_attr[i].string_value() != out_attr[i].string_value())
	    out_attr[i].set_string_value("");
	  break;

	default:
	  {
	    const char* err_object = NULL;

	    // The "known_obj_attributes" table does contain some undefined
	    // attributes.  Ensure that there are unused.
	    if (out_attr[i].int_value() != 0
		|| out_attr[i].string_value() != "")
	      err_object = "output";
	    else if (in_attr[i].int_value() != 0
		     || in_attr[i].string_value() != "")
	      err_object = name;

	    if (err_object != NULL
		&& parameters->options().warn_mismatch())
	      {
		// Attribute numbers >=64 (mod 128) can be safely ignored.
		if ((i & 127) < 64)
		  gold_error(_("%s: unknown mandatory EABI object attribute "
			       "%d"),
			     err_object, i);
		else
		  gold_warning(_("%s: unknown EABI object attribute %d"),
			       err_object, i);
	      }

	    // Only pass on attributes that match in both inputs.
	    if (!in_attr[i].matches(out_attr[i]))
	      {
		out_attr[i].set_int_value(0);
		out_attr[i].set_string_value("");
	      }
	  }
	}

      // If out_attr was copied from in_attr then it won't have a type yet.
      if (in_attr[i].type() && !out_attr[i].type())
	out_attr[i].set_type(in_attr[i].type());
    }

  // Merge Tag_compatibility attributes and any common GNU ones.
  this->attributes_section_data_->merge(name, pasd);

  // Check for any attributes not known on ARM.
  typedef Vendor_object_attributes::Other_attributes Other_attributes;
  const Other_attributes* in_other_attributes = pasd->other_attributes(vendor);
  Other_attributes::const_iterator in_iter = in_other_attributes->begin();
  Other_attributes* out_other_attributes =
    this->attributes_section_data_->other_attributes(vendor);
  Other_attributes::iterator out_iter = out_other_attributes->begin();

  while (in_iter != in_other_attributes->end()
	 || out_iter != out_other_attributes->end())
    {
      const char* err_object = NULL;
      int err_tag = 0;

      // The tags for each list are in numerical order.
      // If the tags are equal, then merge.
      if (out_iter != out_other_attributes->end()
	  && (in_iter == in_other_attributes->end()
	      || in_iter->first > out_iter->first))
	{
	  // This attribute only exists in output.  We can't merge, and we
	  // don't know what the tag means, so delete it.
	  err_object = "output";
	  err_tag = out_iter->first;
	  int saved_tag = out_iter->first;
	  delete out_iter->second;
	  out_other_attributes->erase(out_iter);
	  out_iter = out_other_attributes->upper_bound(saved_tag);
	}
      else if (in_iter != in_other_attributes->end()
	       && (out_iter != out_other_attributes->end()
		   || in_iter->first < out_iter->first))
	{
	  // This attribute only exists in input. We can't merge, and we
	  // don't know what the tag means, so ignore it.
	  err_object = name;
	  err_tag = in_iter->first;
	  ++in_iter;
	}
      else // The tags are equal.
	{
	  // As present, all attributes in the list are unknown, and
	  // therefore can't be merged meaningfully.
	  err_object = "output";
	  err_tag = out_iter->first;

	  //  Only pass on attributes that match in both inputs.
	  if (!in_iter->second->matches(*(out_iter->second)))
	    {
	      // No match.  Delete the attribute.
	      int saved_tag = out_iter->first;
	      delete out_iter->second;
	      out_other_attributes->erase(out_iter);
	      out_iter = out_other_attributes->upper_bound(saved_tag);
	    }
	  else
	    {
	      // Matched.  Keep the attribute and move to the next.
	      ++out_iter;
	      ++in_iter;
	    }
	}

      if (err_object && parameters->options().warn_mismatch())
	{
	  // Attribute numbers >=64 (mod 128) can be safely ignored.  */
	  if ((err_tag & 127) < 64)
	    {
	      gold_error(_("%s: unknown mandatory EABI object attribute %d"),
			 err_object, err_tag);
	    }
	  else
	    {
	      gold_warning(_("%s: unknown EABI object attribute %d"),
			   err_object, err_tag);
	    }
	}
    }
}

// Stub-generation methods for Target_arm.

// Make a new Arm_input_section object.

template<bool big_endian>
Arm_input_section<big_endian>*
Target_arm<big_endian>::new_arm_input_section(
    Relobj* relobj,
    unsigned int shndx)
{
  Section_id sid(relobj, shndx);

  Arm_input_section<big_endian>* arm_input_section =
    new Arm_input_section<big_endian>(relobj, shndx);
  arm_input_section->init();

  // Register new Arm_input_section in map for look-up.
  std::pair<typename Arm_input_section_map::iterator, bool> ins =
    this->arm_input_section_map_.insert(std::make_pair(sid, arm_input_section));

  // Make sure that it we have not created another Arm_input_section
  // for this input section already.
  gold_assert(ins.second);

  return arm_input_section;
}

// Find the Arm_input_section object corresponding to the SHNDX-th input
// section of RELOBJ.

template<bool big_endian>
Arm_input_section<big_endian>*
Target_arm<big_endian>::find_arm_input_section(
    Relobj* relobj,
    unsigned int shndx) const
{
  Section_id sid(relobj, shndx);
  typename Arm_input_section_map::const_iterator p =
    this->arm_input_section_map_.find(sid);
  return (p != this->arm_input_section_map_.end()) ? p->second : NULL;
}

// Make a new stub table.

template<bool big_endian>
Stub_table<big_endian>*
Target_arm<big_endian>::new_stub_table(Arm_input_section<big_endian>* owner)
{
  Stub_table<big_endian>* stub_table =
    new Stub_table<big_endian>(owner);
  this->stub_tables_.push_back(stub_table);

  stub_table->set_address(owner->address() + owner->data_size());
  stub_table->set_file_offset(owner->offset() + owner->data_size());
  stub_table->finalize_data_size();

  return stub_table;
}

// Scan a relocation for stub generation.

template<bool big_endian>
void
Target_arm<big_endian>::scan_reloc_for_stub(
    const Relocate_info<32, big_endian>* relinfo,
    unsigned int r_type,
    const Sized_symbol<32>* gsym,
    unsigned int r_sym,
    const Symbol_value<32>* psymval,
    elfcpp::Elf_types<32>::Elf_Swxword addend,
    Arm_address address)
{
  const Arm_relobj<big_endian>* arm_relobj =
    Arm_relobj<big_endian>::as_arm_relobj(relinfo->object);

  bool target_is_thumb;
  Symbol_value<32> symval;
  if (gsym != NULL)
    {
      // This is a global symbol.  Determine if we use PLT and if the
      // final target is THUMB.
      if (gsym->use_plt_offset(Scan::get_reference_flags(r_type)))
	{
	  // This uses a PLT, change the symbol value.
	  symval.set_output_value(this->plt_section()->address()
				  + gsym->plt_offset());
	  psymval = &symval;
	  target_is_thumb = false;
	}
      else if (gsym->is_undefined())
	// There is no need to generate a stub symbol is undefined.
	return;
      else
	{
	  target_is_thumb =
	    ((gsym->type() == elfcpp::STT_ARM_TFUNC)
	     || (gsym->type() == elfcpp::STT_FUNC
		 && !gsym->is_undefined()
		 && ((psymval->value(arm_relobj, 0) & 1) != 0)));
	}
    }
  else
    {
      // This is a local symbol.  Determine if the final target is THUMB.
      target_is_thumb = arm_relobj->local_symbol_is_thumb_function(r_sym);
    }

  // Strip LSB if this points to a THUMB target.
  const Arm_reloc_property* reloc_property =
    arm_reloc_property_table->get_implemented_static_reloc_property(r_type);
  gold_assert(reloc_property != NULL);
  if (target_is_thumb
      && reloc_property->uses_thumb_bit()
      && ((psymval->value(arm_relobj, 0) & 1) != 0))
    {
      Arm_address stripped_value =
	psymval->value(arm_relobj, 0) & ~static_cast<Arm_address>(1);
      symval.set_output_value(stripped_value);
      psymval = &symval;
    }

  // Get the symbol value.
  Symbol_value<32>::Value value = psymval->value(arm_relobj, 0);

  // Owing to pipelining, the PC relative branches below actually skip
  // two instructions when the branch offset is 0.
  Arm_address destination;
  switch (r_type)
    {
    case elfcpp::R_ARM_CALL:
    case elfcpp::R_ARM_JUMP24:
    case elfcpp::R_ARM_PLT32:
      // ARM branches.
      destination = value + addend + 8;
      break;
    case elfcpp::R_ARM_THM_CALL:
    case elfcpp::R_ARM_THM_XPC22:
    case elfcpp::R_ARM_THM_JUMP24:
    case elfcpp::R_ARM_THM_JUMP19:
      // THUMB branches.
      destination = value + addend + 4;
      break;
    default:
      gold_unreachable();
    }

  Reloc_stub* stub = NULL;
  Stub_type stub_type =
    Reloc_stub::stub_type_for_reloc(r_type, address, destination,
				    target_is_thumb);
  if (stub_type != arm_stub_none)
    {
      // Try looking up an existing stub from a stub table.
      Stub_table<big_endian>* stub_table =
	arm_relobj->stub_table(relinfo->data_shndx);
      gold_assert(stub_table != NULL);

      // Locate stub by destination.
      Reloc_stub::Key stub_key(stub_type, gsym, arm_relobj, r_sym, addend);

      // Create a stub if there is not one already
      stub = stub_table->find_reloc_stub(stub_key);
      if (stub == NULL)
	{
	  // create a new stub and add it to stub table.
	  stub = this->stub_factory().make_reloc_stub(stub_type);
	  stub_table->add_reloc_stub(stub, stub_key);
	}

      // Record the destination address.
      stub->set_destination_address(destination
				    | (target_is_thumb ? 1 : 0));
    }

  // For Cortex-A8, we need to record a relocation at 4K page boundary.
  if (this->fix_cortex_a8_
      && (r_type == elfcpp::R_ARM_THM_JUMP24
	  || r_type == elfcpp::R_ARM_THM_JUMP19
	  || r_type == elfcpp::R_ARM_THM_CALL
	  || r_type == elfcpp::R_ARM_THM_XPC22)
      && (address & 0xfffU) == 0xffeU)
    {
      // Found a candidate.  Note we haven't checked the destination is
      // within 4K here: if we do so (and don't create a record) we can't
      // tell that a branch should have been relocated when scanning later.
      this->cortex_a8_relocs_info_[address] =
	new Cortex_a8_reloc(stub, r_type,
			    destination | (target_is_thumb ? 1 : 0));
    }
}

// This function scans a relocation sections for stub generation.
// The template parameter Relocate must be a class type which provides
// a single function, relocate(), which implements the machine
// specific part of a relocation.

// BIG_ENDIAN is the endianness of the data.  SH_TYPE is the section type:
// SHT_REL or SHT_RELA.

// PRELOCS points to the relocation data.  RELOC_COUNT is the number
// of relocs.  OUTPUT_SECTION is the output section.
// NEEDS_SPECIAL_OFFSET_HANDLING is true if input offsets need to be
// mapped to output offsets.

// VIEW is the section data, VIEW_ADDRESS is its memory address, and
// VIEW_SIZE is the size.  These refer to the input section, unless
// NEEDS_SPECIAL_OFFSET_HANDLING is true, in which case they refer to
// the output section.

template<bool big_endian>
template<int sh_type>
void inline
Target_arm<big_endian>::scan_reloc_section_for_stubs(
    const Relocate_info<32, big_endian>* relinfo,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    const unsigned char* view,
    elfcpp::Elf_types<32>::Elf_Addr view_address,
    section_size_type)
{
  typedef typename Reloc_types<sh_type, 32, big_endian>::Reloc Reltype;
  const int reloc_size =
    Reloc_types<sh_type, 32, big_endian>::reloc_size;

  Arm_relobj<big_endian>* arm_object =
    Arm_relobj<big_endian>::as_arm_relobj(relinfo->object);
  unsigned int local_count = arm_object->local_symbol_count();

  gold::Default_comdat_behavior default_comdat_behavior;
  Comdat_behavior comdat_behavior = CB_UNDETERMINED;

  for (size_t i = 0; i < reloc_count; ++i, prelocs += reloc_size)
    {
      Reltype reloc(prelocs);

      typename elfcpp::Elf_types<32>::Elf_WXword r_info = reloc.get_r_info();
      unsigned int r_sym = elfcpp::elf_r_sym<32>(r_info);
      unsigned int r_type = elfcpp::elf_r_type<32>(r_info);

      r_type = this->get_real_reloc_type(r_type);

      // Only a few relocation types need stubs.
      if ((r_type != elfcpp::R_ARM_CALL)
	 && (r_type != elfcpp::R_ARM_JUMP24)
	 && (r_type != elfcpp::R_ARM_PLT32)
	 && (r_type != elfcpp::R_ARM_THM_CALL)
	 && (r_type != elfcpp::R_ARM_THM_XPC22)
	 && (r_type != elfcpp::R_ARM_THM_JUMP24)
	 && (r_type != elfcpp::R_ARM_THM_JUMP19)
	 && (r_type != elfcpp::R_ARM_V4BX))
	continue;

      section_offset_type offset =
	convert_to_section_size_type(reloc.get_r_offset());

      if (needs_special_offset_handling)
	{
	  offset = output_section->output_offset(relinfo->object,
						 relinfo->data_shndx,
						 offset);
	  if (offset == -1)
	    continue;
	}

      // Create a v4bx stub if --fix-v4bx-interworking is used.
      if (r_type == elfcpp::R_ARM_V4BX)
	{
	  if (this->fix_v4bx() == General_options::FIX_V4BX_INTERWORKING)
	    {
	      // Get the BX instruction.
	      typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
	      const Valtype* wv =
		reinterpret_cast<const Valtype*>(view + offset);
	      elfcpp::Elf_types<32>::Elf_Swxword insn =
		elfcpp::Swap<32, big_endian>::readval(wv);
	      const uint32_t reg = (insn & 0xf);

	      if (reg < 0xf)
		{
		  // Try looking up an existing stub from a stub table.
		  Stub_table<big_endian>* stub_table =
		    arm_object->stub_table(relinfo->data_shndx);
		  gold_assert(stub_table != NULL);

		  if (stub_table->find_arm_v4bx_stub(reg) == NULL)
		    {
		      // create a new stub and add it to stub table.
		      Arm_v4bx_stub* stub =
			this->stub_factory().make_arm_v4bx_stub(reg);
		      gold_assert(stub != NULL);
		      stub_table->add_arm_v4bx_stub(stub);
		    }
		}
	    }
	  continue;
	}

      // Get the addend.
      Stub_addend_reader<sh_type, big_endian> stub_addend_reader;
      elfcpp::Elf_types<32>::Elf_Swxword addend =
	stub_addend_reader(r_type, view + offset, reloc);

      const Sized_symbol<32>* sym;

      Symbol_value<32> symval;
      const Symbol_value<32> *psymval;
      bool is_defined_in_discarded_section;
      unsigned int shndx;
      if (r_sym < local_count)
	{
	  sym = NULL;
	  psymval = arm_object->local_symbol(r_sym);

	  // If the local symbol belongs to a section we are discarding,
	  // and that section is a debug section, try to find the
	  // corresponding kept section and map this symbol to its
	  // counterpart in the kept section.  The symbol must not
	  // correspond to a section we are folding.
	  bool is_ordinary;
	  shndx = psymval->input_shndx(&is_ordinary);
	  is_defined_in_discarded_section =
	    (is_ordinary
	     && shndx != elfcpp::SHN_UNDEF
	     && !arm_object->is_section_included(shndx)
	     && !relinfo->symtab->is_section_folded(arm_object, shndx));

	  // We need to compute the would-be final value of this local
	  // symbol.
	  if (!is_defined_in_discarded_section)
	    {
	      typedef Sized_relobj_file<32, big_endian> ObjType;
	      typename ObjType::Compute_final_local_value_status status =
		arm_object->compute_final_local_value(r_sym, psymval, &symval,
						      relinfo->symtab);
	      if (status == ObjType::CFLV_OK)
		{
		  // Currently we cannot handle a branch to a target in
		  // a merged section.  If this is the case, issue an error
		  // and also free the merge symbol value.
		  if (!symval.has_output_value())
		    {
		      const std::string& section_name =
			arm_object->section_name(shndx);
		      arm_object->error(_("cannot handle branch to local %u "
					  "in a merged section %s"),
					r_sym, section_name.c_str());
		    }
		  psymval = &symval;
		}
	      else
		{
		  // We cannot determine the final value.
		  continue;
		}
	    }
	}
      else
	{
	  const Symbol* gsym;
	  gsym = arm_object->global_symbol(r_sym);
	  gold_assert(gsym != NULL);
	  if (gsym->is_forwarder())
	    gsym = relinfo->symtab->resolve_forwards(gsym);

	  sym = static_cast<const Sized_symbol<32>*>(gsym);
	  if (sym->has_symtab_index() && sym->symtab_index() != -1U)
	    symval.set_output_symtab_index(sym->symtab_index());
	  else
	    symval.set_no_output_symtab_entry();

	  // We need to compute the would-be final value of this global
	  // symbol.
	  const Symbol_table* symtab = relinfo->symtab;
	  const Sized_symbol<32>* sized_symbol =
	    symtab->get_sized_symbol<32>(gsym);
	  Symbol_table::Compute_final_value_status status;
	  Arm_address value =
	    symtab->compute_final_value<32>(sized_symbol, &status);

	  // Skip this if the symbol has not output section.
	  if (status == Symbol_table::CFVS_NO_OUTPUT_SECTION)
	    continue;
	  symval.set_output_value(value);

	  if (gsym->type() == elfcpp::STT_TLS)
	    symval.set_is_tls_symbol();
	  else if (gsym->type() == elfcpp::STT_GNU_IFUNC)
	    symval.set_is_ifunc_symbol();
	  psymval = &symval;

	  is_defined_in_discarded_section =
	    (gsym->is_defined_in_discarded_section()
	     && gsym->is_undefined());
	  shndx = 0;
	}

      Symbol_value<32> symval2;
      if (is_defined_in_discarded_section)
	{
	  if (comdat_behavior == CB_UNDETERMINED)
	    {
	      std::string name = arm_object->section_name(relinfo->data_shndx);
 	      comdat_behavior = default_comdat_behavior.get(name.c_str());
	    }
	  if (comdat_behavior == CB_PRETEND)
	    {
	      // FIXME: This case does not work for global symbols.
	      // We have no place to store the original section index.
	      // Fortunately this does not matter for comdat sections,
	      // only for sections explicitly discarded by a linker
	      // script.
	      bool found;
	      typename elfcpp::Elf_types<32>::Elf_Addr value =
		arm_object->map_to_kept_section(shndx, &found);
	      if (found)
		symval2.set_output_value(value + psymval->input_value());
	      else
		symval2.set_output_value(0);
	    }
	  else
	    {
	      if (comdat_behavior == CB_WARNING)
		gold_warning_at_location(relinfo, i, offset,
					 _("relocation refers to discarded "
					   "section"));
	      symval2.set_output_value(0);
	    }
	  symval2.set_no_output_symtab_entry();
	  psymval = &symval2;
	}

      // If symbol is a section symbol, we don't know the actual type of
      // destination.  Give up.
      if (psymval->is_section_symbol())
	continue;

      this->scan_reloc_for_stub(relinfo, r_type, sym, r_sym, psymval,
				addend, view_address + offset);
    }
}

// Scan an input section for stub generation.

template<bool big_endian>
void
Target_arm<big_endian>::scan_section_for_stubs(
    const Relocate_info<32, big_endian>* relinfo,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    const unsigned char* view,
    Arm_address view_address,
    section_size_type view_size)
{
  if (sh_type == elfcpp::SHT_REL)
    this->scan_reloc_section_for_stubs<elfcpp::SHT_REL>(
	relinfo,
	prelocs,
	reloc_count,
	output_section,
	needs_special_offset_handling,
	view,
	view_address,
	view_size);
  else if (sh_type == elfcpp::SHT_RELA)
    // We do not support RELA type relocations yet.  This is provided for
    // completeness.
    this->scan_reloc_section_for_stubs<elfcpp::SHT_RELA>(
	relinfo,
	prelocs,
	reloc_count,
	output_section,
	needs_special_offset_handling,
	view,
	view_address,
	view_size);
  else
    gold_unreachable();
}

// Group input sections for stub generation.
//
// We group input sections in an output section so that the total size,
// including any padding space due to alignment is smaller than GROUP_SIZE
// unless the only input section in group is bigger than GROUP_SIZE already.
// Then an ARM stub table is created to follow the last input section
// in group.  For each group an ARM stub table is created an is placed
// after the last group.  If STUB_ALWAYS_AFTER_BRANCH is false, we further
// extend the group after the stub table.

template<bool big_endian>
void
Target_arm<big_endian>::group_sections(
    Layout* layout,
    section_size_type group_size,
    bool stubs_always_after_branch,
    const Task* task)
{
  // Group input sections and insert stub table
  Layout::Section_list section_list;
  layout->get_executable_sections(&section_list);
  for (Layout::Section_list::const_iterator p = section_list.begin();
       p != section_list.end();
       ++p)
    {
      Arm_output_section<big_endian>* output_section =
	Arm_output_section<big_endian>::as_arm_output_section(*p);
      output_section->group_sections(group_size, stubs_always_after_branch,
				     this, task);
    }
}

// Relaxation hook.  This is where we do stub generation.

template<bool big_endian>
bool
Target_arm<big_endian>::do_relax(
    int pass,
    const Input_objects* input_objects,
    Symbol_table* symtab,
    Layout* layout,
    const Task* task)
{
  // No need to generate stubs if this is a relocatable link.
  gold_assert(!parameters->options().relocatable());

  // If this is the first pass, we need to group input sections into
  // stub groups.
  bool done_exidx_fixup = false;
  typedef typename Stub_table_list::iterator Stub_table_iterator;
  if (pass == 1)
    {
      // Determine the stub group size.  The group size is the absolute
      // value of the parameter --stub-group-size.  If --stub-group-size
      // is passed a negative value, we restrict stubs to be always after
      // the stubbed branches.
      int32_t stub_group_size_param =
	parameters->options().stub_group_size();
      bool stubs_always_after_branch = stub_group_size_param < 0;
      section_size_type stub_group_size = abs(stub_group_size_param);

      if (stub_group_size == 1)
	{
	  // Default value.
	  // Thumb branch range is +-4MB has to be used as the default
	  // maximum size (a given section can contain both ARM and Thumb
	  // code, so the worst case has to be taken into account).  If we are
	  // fixing cortex-a8 errata, the branch range has to be even smaller,
	  // since wide conditional branch has a range of +-1MB only.
	  //
	  // This value is 48K less than that, which allows for 4096
	  // 12-byte stubs.  If we exceed that, then we will fail to link.
	  // The user will have to relink with an explicit group size
	  // option.
	    stub_group_size = 4145152;
	}

      // The Cortex-A8 erratum fix depends on stubs not being in the same 4K
      // page as the first half of a 32-bit branch straddling two 4K pages.
      // This is a crude way of enforcing that.  In addition, long conditional
      // branches of THUMB-2 have a range of +-1M.  If we are fixing cortex-A8
      // erratum, limit the group size to  (1M - 12k) to avoid unreachable
      // cortex-A8 stubs from long conditional branches.
      if (this->fix_cortex_a8_)
	{
	  stubs_always_after_branch = true;
	  const section_size_type cortex_a8_group_size = 1024 * (1024 - 12);
	  stub_group_size = std::max(stub_group_size, cortex_a8_group_size);
	}

      group_sections(layout, stub_group_size, stubs_always_after_branch, task);

      // Also fix .ARM.exidx section coverage.
      Arm_output_section<big_endian>* exidx_output_section = NULL;
      for (Layout::Section_list::const_iterator p =
	     layout->section_list().begin();
	   p != layout->section_list().end();
	   ++p)
	if ((*p)->type() == elfcpp::SHT_ARM_EXIDX)
	  {
	    if (exidx_output_section == NULL)
	      exidx_output_section =
		Arm_output_section<big_endian>::as_arm_output_section(*p);
	    else
	      // We cannot handle this now.
	      gold_error(_("multiple SHT_ARM_EXIDX sections %s and %s in a "
			   "non-relocatable link"),
			  exidx_output_section->name(),
			  (*p)->name());
	  }

      if (exidx_output_section != NULL)
	{
	  this->fix_exidx_coverage(layout, input_objects, exidx_output_section,
				   symtab, task);
	  done_exidx_fixup = true;
	}
    }
  else
    {
      // If this is not the first pass, addresses and file offsets have
      // been reset at this point, set them here.
      for (Stub_table_iterator sp = this->stub_tables_.begin();
	   sp != this->stub_tables_.end();
	   ++sp)
	{
	  Arm_input_section<big_endian>* owner = (*sp)->owner();
	  off_t off = align_address(owner->original_size(),
				    (*sp)->addralign());
	  (*sp)->set_address_and_file_offset(owner->address() + off,
					     owner->offset() + off);
	}
    }

  // The Cortex-A8 stubs are sensitive to layout of code sections.  At the
  // beginning of each relaxation pass, just blow away all the stubs.
  // Alternatively, we could selectively remove only the stubs and reloc
  // information for code sections that have moved since the last pass.
  // That would require more book-keeping.
  if (this->fix_cortex_a8_)
    {
      // Clear all Cortex-A8 reloc information.
      for (typename Cortex_a8_relocs_info::const_iterator p =
	     this->cortex_a8_relocs_info_.begin();
	   p != this->cortex_a8_relocs_info_.end();
	   ++p)
	delete p->second;
      this->cortex_a8_relocs_info_.clear();

      // Remove all Cortex-A8 stubs.
      for (Stub_table_iterator sp = this->stub_tables_.begin();
	   sp != this->stub_tables_.end();
	   ++sp)
	(*sp)->remove_all_cortex_a8_stubs();
    }

  // Scan relocs for relocation stubs
  for (Input_objects::Relobj_iterator op = input_objects->relobj_begin();
       op != input_objects->relobj_end();
       ++op)
    {
      Arm_relobj<big_endian>* arm_relobj =
	Arm_relobj<big_endian>::as_arm_relobj(*op);
      // Lock the object so we can read from it.  This is only called
      // single-threaded from Layout::finalize, so it is OK to lock.
      Task_lock_obj<Object> tl(task, arm_relobj);
      arm_relobj->scan_sections_for_stubs(this, symtab, layout);
    }

  // Check all stub tables to see if any of them have their data sizes
  // or addresses alignments changed.  These are the only things that
  // matter.
  bool any_stub_table_changed = false;
  Unordered_set<const Output_section*> sections_needing_adjustment;
  for (Stub_table_iterator sp = this->stub_tables_.begin();
       (sp != this->stub_tables_.end()) && !any_stub_table_changed;
       ++sp)
    {
      if ((*sp)->update_data_size_and_addralign())
	{
	  // Update data size of stub table owner.
	  Arm_input_section<big_endian>* owner = (*sp)->owner();
	  uint64_t address = owner->address();
	  off_t offset = owner->offset();
	  owner->reset_address_and_file_offset();
	  owner->set_address_and_file_offset(address, offset);

	  sections_needing_adjustment.insert(owner->output_section());
	  any_stub_table_changed = true;
	}
    }

  // Output_section_data::output_section() returns a const pointer but we
  // need to update output sections, so we record all output sections needing
  // update above and scan the sections here to find out what sections need
  // to be updated.
  for (Layout::Section_list::const_iterator p = layout->section_list().begin();
      p != layout->section_list().end();
      ++p)
    {
      if (sections_needing_adjustment.find(*p)
	  != sections_needing_adjustment.end())
	(*p)->set_section_offsets_need_adjustment();
    }

  // Stop relaxation if no EXIDX fix-up and no stub table change.
  bool continue_relaxation = done_exidx_fixup || any_stub_table_changed;

  // Finalize the stubs in the last relaxation pass.
  if (!continue_relaxation)
    {
      for (Stub_table_iterator sp = this->stub_tables_.begin();
	   (sp != this->stub_tables_.end()) && !any_stub_table_changed;
	    ++sp)
	(*sp)->finalize_stubs();

      // Update output local symbol counts of objects if necessary.
      for (Input_objects::Relobj_iterator op = input_objects->relobj_begin();
	   op != input_objects->relobj_end();
	   ++op)
	{
	  Arm_relobj<big_endian>* arm_relobj =
	    Arm_relobj<big_endian>::as_arm_relobj(*op);

	  // Update output local symbol counts.  We need to discard local
	  // symbols defined in parts of input sections that are discarded by
	  // relaxation.
	  if (arm_relobj->output_local_symbol_count_needs_update())
	    {
	      // We need to lock the object's file to update it.
	      Task_lock_obj<Object> tl(task, arm_relobj);
	      arm_relobj->update_output_local_symbol_count();
	    }
	}
    }

  return continue_relaxation;
}

// Relocate a stub.

template<bool big_endian>
void
Target_arm<big_endian>::relocate_stub(
    Stub* stub,
    const Relocate_info<32, big_endian>* relinfo,
    Output_section* output_section,
    unsigned char* view,
    Arm_address address,
    section_size_type view_size)
{
  Relocate relocate;
  const Stub_template* stub_template = stub->stub_template();
  for (size_t i = 0; i < stub_template->reloc_count(); i++)
    {
      size_t reloc_insn_index = stub_template->reloc_insn_index(i);
      const Insn_template* insn = &stub_template->insns()[reloc_insn_index];

      unsigned int r_type = insn->r_type();
      section_size_type reloc_offset = stub_template->reloc_offset(i);
      section_size_type reloc_size = insn->size();
      gold_assert(reloc_offset + reloc_size <= view_size);

      // This is the address of the stub destination.
      Arm_address target = stub->reloc_target(i) + insn->reloc_addend();
      Symbol_value<32> symval;
      symval.set_output_value(target);

      // Synthesize a fake reloc just in case.  We don't have a symbol so
      // we use 0.
      unsigned char reloc_buffer[elfcpp::Elf_sizes<32>::rel_size];
      memset(reloc_buffer, 0, sizeof(reloc_buffer));
      elfcpp::Rel_write<32, big_endian> reloc_write(reloc_buffer);
      reloc_write.put_r_offset(reloc_offset);
      reloc_write.put_r_info(elfcpp::elf_r_info<32>(0, r_type));
      elfcpp::Rel<32, big_endian> rel(reloc_buffer);

      relocate.relocate(relinfo, this, output_section,
			this->fake_relnum_for_stubs, rel, r_type,
			NULL, &symval, view + reloc_offset,
			address + reloc_offset, reloc_size);
    }
}

// Determine whether an object attribute tag takes an integer, a
// string or both.

template<bool big_endian>
int
Target_arm<big_endian>::do_attribute_arg_type(int tag) const
{
  if (tag == Object_attribute::Tag_compatibility)
    return (Object_attribute::ATTR_TYPE_FLAG_INT_VAL
	    | Object_attribute::ATTR_TYPE_FLAG_STR_VAL);
  else if (tag == elfcpp::Tag_nodefaults)
    return (Object_attribute::ATTR_TYPE_FLAG_INT_VAL
	    | Object_attribute::ATTR_TYPE_FLAG_NO_DEFAULT);
  else if (tag == elfcpp::Tag_CPU_raw_name || tag == elfcpp::Tag_CPU_name)
    return Object_attribute::ATTR_TYPE_FLAG_STR_VAL;
  else if (tag < 32)
    return Object_attribute::ATTR_TYPE_FLAG_INT_VAL;
  else
    return ((tag & 1) != 0
	    ? Object_attribute::ATTR_TYPE_FLAG_STR_VAL
	    : Object_attribute::ATTR_TYPE_FLAG_INT_VAL);
}

// Reorder attributes.
//
// The ABI defines that Tag_conformance should be emitted first, and that
// Tag_nodefaults should be second (if either is defined).  This sets those
// two positions, and bumps up the position of all the remaining tags to
// compensate.

template<bool big_endian>
int
Target_arm<big_endian>::do_attributes_order(int num) const
{
  // Reorder the known object attributes in output.  We want to move
  // Tag_conformance to position 4 and Tag_conformance to position 5
  // and shift everything between 4 .. Tag_conformance - 1 to make room.
  if (num == 4)
    return elfcpp::Tag_conformance;
  if (num == 5)
    return elfcpp::Tag_nodefaults;
  if ((num - 2) < elfcpp::Tag_nodefaults)
    return num - 2;
  if ((num - 1) < elfcpp::Tag_conformance)
    return num - 1;
  return num;
}

// Scan a span of THUMB code for Cortex-A8 erratum.

template<bool big_endian>
void
Target_arm<big_endian>::scan_span_for_cortex_a8_erratum(
    Arm_relobj<big_endian>* arm_relobj,
    unsigned int shndx,
    section_size_type span_start,
    section_size_type span_end,
    const unsigned char* view,
    Arm_address address)
{
  // Scan for 32-bit Thumb-2 branches which span two 4K regions, where:
  //
  // The opcode is BLX.W, BL.W, B.W, Bcc.W
  // The branch target is in the same 4KB region as the
  // first half of the branch.
  // The instruction before the branch is a 32-bit
  // length non-branch instruction.
  section_size_type i = span_start;
  bool last_was_32bit = false;
  bool last_was_branch = false;
  while (i < span_end)
    {
      typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
      const Valtype* wv = reinterpret_cast<const Valtype*>(view + i);
      uint32_t insn = elfcpp::Swap<16, big_endian>::readval(wv);
      bool is_blx = false, is_b = false;
      bool is_bl = false, is_bcc = false;

      bool insn_32bit = (insn & 0xe000) == 0xe000 && (insn & 0x1800) != 0x0000;
      if (insn_32bit)
	{
	  // Load the rest of the insn (in manual-friendly order).
	  insn = (insn << 16) | elfcpp::Swap<16, big_endian>::readval(wv + 1);

	  // Encoding T4: B<c>.W.
	  is_b = (insn & 0xf800d000U) == 0xf0009000U;
	  // Encoding T1: BL<c>.W.
	  is_bl = (insn & 0xf800d000U) == 0xf000d000U;
	  // Encoding T2: BLX<c>.W.
	  is_blx = (insn & 0xf800d000U) == 0xf000c000U;
	  // Encoding T3: B<c>.W (not permitted in IT block).
	  is_bcc = ((insn & 0xf800d000U) == 0xf0008000U
		    && (insn & 0x07f00000U) != 0x03800000U);
	}

      bool is_32bit_branch = is_b || is_bl || is_blx || is_bcc;

      // If this instruction is a 32-bit THUMB branch that crosses a 4K
      // page boundary and it follows 32-bit non-branch instruction,
      // we need to work around.
      if (is_32bit_branch
	  && ((address + i) & 0xfffU) == 0xffeU
	  && last_was_32bit
	  && !last_was_branch)
	{
	  // Check to see if there is a relocation stub for this branch.
	  bool force_target_arm = false;
	  bool force_target_thumb = false;
	  const Cortex_a8_reloc* cortex_a8_reloc = NULL;
	  Cortex_a8_relocs_info::const_iterator p =
	    this->cortex_a8_relocs_info_.find(address + i);

	  if (p != this->cortex_a8_relocs_info_.end())
	    {
	      cortex_a8_reloc = p->second;
	      bool target_is_thumb = (cortex_a8_reloc->destination() & 1) != 0;

	      if (cortex_a8_reloc->r_type() == elfcpp::R_ARM_THM_CALL
		  && !target_is_thumb)
		force_target_arm = true;
	      else if (cortex_a8_reloc->r_type() == elfcpp::R_ARM_THM_CALL
		       && target_is_thumb)
		force_target_thumb = true;
	    }

	  off_t offset;
	  Stub_type stub_type = arm_stub_none;

	  // Check if we have an offending branch instruction.
	  uint16_t upper_insn = (insn >> 16) & 0xffffU;
	  uint16_t lower_insn = insn & 0xffffU;
	  typedef class Arm_relocate_functions<big_endian> RelocFuncs;

	  if (cortex_a8_reloc != NULL
	      && cortex_a8_reloc->reloc_stub() != NULL)
	    // We've already made a stub for this instruction, e.g.
	    // it's a long branch or a Thumb->ARM stub.  Assume that
	    // stub will suffice to work around the A8 erratum (see
	    // setting of always_after_branch above).
	    ;
	  else if (is_bcc)
	    {
	      offset = RelocFuncs::thumb32_cond_branch_offset(upper_insn,
							      lower_insn);
	      stub_type = arm_stub_a8_veneer_b_cond;
	    }
	  else if (is_b || is_bl || is_blx)
	    {
	      offset = RelocFuncs::thumb32_branch_offset(upper_insn,
							 lower_insn);
	      if (is_blx)
		offset &= ~3;

	      stub_type = (is_blx
			   ? arm_stub_a8_veneer_blx
			   : (is_bl
			      ? arm_stub_a8_veneer_bl
			      : arm_stub_a8_veneer_b));
	    }

	  if (stub_type != arm_stub_none)
	    {
	      Arm_address pc_for_insn = address + i + 4;

	      // The original instruction is a BL, but the target is
	      // an ARM instruction.  If we were not making a stub,
	      // the BL would have been converted to a BLX.  Use the
	      // BLX stub instead in that case.
	      if (this->may_use_v5t_interworking() && force_target_arm
		  && stub_type == arm_stub_a8_veneer_bl)
		{
		  stub_type = arm_stub_a8_veneer_blx;
		  is_blx = true;
		  is_bl = false;
		}
	      // Conversely, if the original instruction was
	      // BLX but the target is Thumb mode, use the BL stub.
	      else if (force_target_thumb
		       && stub_type == arm_stub_a8_veneer_blx)
		{
		  stub_type = arm_stub_a8_veneer_bl;
		  is_blx = false;
		  is_bl = true;
		}

	      if (is_blx)
		pc_for_insn &= ~3;

	      // If we found a relocation, use the proper destination,
	      // not the offset in the (unrelocated) instruction.
	      // Note this is always done if we switched the stub type above.
	      if (cortex_a8_reloc != NULL)
		offset = (off_t) (cortex_a8_reloc->destination() - pc_for_insn);

	      Arm_address target = (pc_for_insn + offset) | (is_blx ? 0 : 1);

	      // Add a new stub if destination address in in the same page.
	      if (((address + i) & ~0xfffU) == (target & ~0xfffU))
		{
		  Cortex_a8_stub* stub =
		    this->stub_factory_.make_cortex_a8_stub(stub_type,
							    arm_relobj, shndx,
							    address + i,
							    target, insn);
		  Stub_table<big_endian>* stub_table =
		    arm_relobj->stub_table(shndx);
		  gold_assert(stub_table != NULL);
		  stub_table->add_cortex_a8_stub(address + i, stub);
		}
	    }
	}

      i += insn_32bit ? 4 : 2;
      last_was_32bit = insn_32bit;
      last_was_branch = is_32bit_branch;
    }
}

// Apply the Cortex-A8 workaround.

template<bool big_endian>
void
Target_arm<big_endian>::apply_cortex_a8_workaround(
    const Cortex_a8_stub* stub,
    Arm_address stub_address,
    unsigned char* insn_view,
    Arm_address insn_address)
{
  typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
  Valtype* wv = reinterpret_cast<Valtype*>(insn_view);
  Valtype upper_insn = elfcpp::Swap<16, big_endian>::readval(wv);
  Valtype lower_insn = elfcpp::Swap<16, big_endian>::readval(wv + 1);
  off_t branch_offset = stub_address - (insn_address + 4);

  typedef class Arm_relocate_functions<big_endian> RelocFuncs;
  switch (stub->stub_template()->type())
    {
    case arm_stub_a8_veneer_b_cond:
      // For a conditional branch, we re-write it to be an unconditional
      // branch to the stub.  We use the THUMB-2 encoding here.
      upper_insn = 0xf000U;
      lower_insn = 0xb800U;
      // Fall through
    case arm_stub_a8_veneer_b:
    case arm_stub_a8_veneer_bl:
    case arm_stub_a8_veneer_blx:
      if ((lower_insn & 0x5000U) == 0x4000U)
	// For a BLX instruction, make sure that the relocation is
	// rounded up to a word boundary.  This follows the semantics of
	// the instruction which specifies that bit 1 of the target
	// address will come from bit 1 of the base address.
	branch_offset = (branch_offset + 2) & ~3;

      // Put BRANCH_OFFSET back into the insn.
      gold_assert(!Bits<25>::has_overflow32(branch_offset));
      upper_insn = RelocFuncs::thumb32_branch_upper(upper_insn, branch_offset);
      lower_insn = RelocFuncs::thumb32_branch_lower(lower_insn, branch_offset);
      break;

    default:
      gold_unreachable();
    }

  // Put the relocated value back in the object file:
  elfcpp::Swap<16, big_endian>::writeval(wv, upper_insn);
  elfcpp::Swap<16, big_endian>::writeval(wv + 1, lower_insn);
}

// Target selector for ARM.  Note this is never instantiated directly.
// It's only used in Target_selector_arm_nacl, below.

template<bool big_endian>
class Target_selector_arm : public Target_selector
{
 public:
  Target_selector_arm()
    : Target_selector(elfcpp::EM_ARM, 32, big_endian,
		      (big_endian ? "elf32-bigarm" : "elf32-littlearm"),
		      (big_endian ? "armelfb" : "armelf"))
  { }

  Target*
  do_instantiate_target()
  { return new Target_arm<big_endian>(); }
};

// Fix .ARM.exidx section coverage.

template<bool big_endian>
void
Target_arm<big_endian>::fix_exidx_coverage(
    Layout* layout,
    const Input_objects* input_objects,
    Arm_output_section<big_endian>* exidx_section,
    Symbol_table* symtab,
    const Task* task)
{
  // We need to look at all the input sections in output in ascending
  // order of of output address.  We do that by building a sorted list
  // of output sections by addresses.  Then we looks at the output sections
  // in order.  The input sections in an output section are already sorted
  // by addresses within the output section.

  typedef std::set<Output_section*, output_section_address_less_than>
      Sorted_output_section_list;
  Sorted_output_section_list sorted_output_sections;

  // Find out all the output sections of input sections pointed by
  // EXIDX input sections.
  for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
       p != input_objects->relobj_end();
       ++p)
    {
      Arm_relobj<big_endian>* arm_relobj =
	Arm_relobj<big_endian>::as_arm_relobj(*p);
      std::vector<unsigned int> shndx_list;
      arm_relobj->get_exidx_shndx_list(&shndx_list);
      for (size_t i = 0; i < shndx_list.size(); ++i)
	{
	  const Arm_exidx_input_section* exidx_input_section =
	    arm_relobj->exidx_input_section_by_shndx(shndx_list[i]);
	  gold_assert(exidx_input_section != NULL);
	  if (!exidx_input_section->has_errors())
	    {
	      unsigned int text_shndx = exidx_input_section->link();
	      Output_section* os = arm_relobj->output_section(text_shndx);
	      if (os != NULL && (os->flags() & elfcpp::SHF_ALLOC) != 0)
		sorted_output_sections.insert(os);
	    }
	}
    }

  // Go over the output sections in ascending order of output addresses.
  typedef typename Arm_output_section<big_endian>::Text_section_list
      Text_section_list;
  Text_section_list sorted_text_sections;
  for (typename Sorted_output_section_list::iterator p =
	sorted_output_sections.begin();
      p != sorted_output_sections.end();
      ++p)
    {
      Arm_output_section<big_endian>* arm_output_section =
	Arm_output_section<big_endian>::as_arm_output_section(*p);
      arm_output_section->append_text_sections_to_list(&sorted_text_sections);
    }

  exidx_section->fix_exidx_coverage(layout, sorted_text_sections, symtab,
				    merge_exidx_entries(), task);
}

template<bool big_endian>
void
Target_arm<big_endian>::do_define_standard_symbols(
    Symbol_table* symtab,
    Layout* layout)
{
  // Handle the .ARM.exidx section.
  Output_section* exidx_section = layout->find_output_section(".ARM.exidx");

  if (exidx_section != NULL)
    {
      // Create __exidx_start and __exidx_end symbols.
      symtab->define_in_output_data("__exidx_start",
				    NULL, // version
				    Symbol_table::PREDEFINED,
				    exidx_section,
				    0, // value
				    0, // symsize
				    elfcpp::STT_NOTYPE,
				    elfcpp::STB_GLOBAL,
				    elfcpp::STV_HIDDEN,
				    0, // nonvis
				    false, // offset_is_from_end
				    true); // only_if_ref

      symtab->define_in_output_data("__exidx_end",
				    NULL, // version
				    Symbol_table::PREDEFINED,
				    exidx_section,
				    0, // value
				    0, // symsize
				    elfcpp::STT_NOTYPE,
				    elfcpp::STB_GLOBAL,
				    elfcpp::STV_HIDDEN,
				    0, // nonvis
				    true, // offset_is_from_end
				    true); // only_if_ref
    }
  else
    {
      // Define __exidx_start and __exidx_end even when .ARM.exidx
      // section is missing to match ld's behaviour.
      symtab->define_as_constant("__exidx_start", NULL,
				 Symbol_table::PREDEFINED,
				 0, 0, elfcpp::STT_OBJECT,
				 elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN, 0,
				 true, false);
      symtab->define_as_constant("__exidx_end", NULL,
				 Symbol_table::PREDEFINED,
				 0, 0, elfcpp::STT_OBJECT,
				 elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN, 0,
				 true, false);
    }
}

// NaCl variant.  It uses different PLT contents.

template<bool big_endian>
class Output_data_plt_arm_nacl;

template<bool big_endian>
class Target_arm_nacl : public Target_arm<big_endian>
{
 public:
  Target_arm_nacl()
    : Target_arm<big_endian>(&arm_nacl_info)
  { }

 protected:
  virtual Output_data_plt_arm<big_endian>*
  do_make_data_plt(Layout* layout, Output_data_space* got_plt)
  { return new Output_data_plt_arm_nacl<big_endian>(layout, got_plt); }

 private:
  static const Target::Target_info arm_nacl_info;
};

template<bool big_endian>
const Target::Target_info Target_arm_nacl<big_endian>::arm_nacl_info =
{
  32,			// size
  big_endian,		// is_big_endian
  elfcpp::EM_ARM,	// machine_code
  false,		// has_make_symbol
  false,		// has_resolve
  false,		// has_code_fill
  true,			// is_default_stack_executable
  false,		// can_icf_inline_merge_sections
  '\0',			// wrap_char
  "/lib/ld-nacl-arm.so.1", // dynamic_linker
  0x20000,		// default_text_segment_address
  0x10000,		// abi_pagesize (overridable by -z max-page-size)
  0x10000,		// common_pagesize (overridable by -z common-page-size)
  true,                 // isolate_execinstr
  0x10000000,           // rosegment_gap
  elfcpp::SHN_UNDEF,	// small_common_shndx
  elfcpp::SHN_UNDEF,	// large_common_shndx
  0,			// small_common_section_flags
  0,			// large_common_section_flags
  ".ARM.attributes",	// attributes_section
  "aeabi",		// attributes_vendor
  "_start"		// entry_symbol_name
};

template<bool big_endian>
class Output_data_plt_arm_nacl : public Output_data_plt_arm<big_endian>
{
 public:
  Output_data_plt_arm_nacl(Layout* layout, Output_data_space* got_plt)
    : Output_data_plt_arm<big_endian>(layout, 16, got_plt)
  { }

 protected:
  // Return the offset of the first non-reserved PLT entry.
  virtual unsigned int
  do_first_plt_entry_offset() const
  { return sizeof(first_plt_entry); }

  // Return the size of a PLT entry.
  virtual unsigned int
  do_get_plt_entry_size() const
  { return sizeof(plt_entry); }

  virtual void
  do_fill_first_plt_entry(unsigned char* pov,
			  Arm_address got_address,
			  Arm_address plt_address);

  virtual void
  do_fill_plt_entry(unsigned char* pov,
		    Arm_address got_address,
		    Arm_address plt_address,
		    unsigned int got_offset,
		    unsigned int plt_offset);

 private:
  inline uint32_t arm_movw_immediate(uint32_t value)
  {
    return (value & 0x00000fff) | ((value & 0x0000f000) << 4);
  }

  inline uint32_t arm_movt_immediate(uint32_t value)
  {
    return ((value & 0x0fff0000) >> 16) | ((value & 0xf0000000) >> 12);
  }

  // Template for the first PLT entry.
  static const uint32_t first_plt_entry[16];

  // Template for subsequent PLT entries.
  static const uint32_t plt_entry[4];
};

// The first entry in the PLT.
template<bool big_endian>
const uint32_t Output_data_plt_arm_nacl<big_endian>::first_plt_entry[16] =
{
  // First bundle:
  0xe300c000,                           // movw	ip, #:lower16:&GOT[2]-.+8
  0xe340c000,                           // movt	ip, #:upper16:&GOT[2]-.+8
  0xe08cc00f,                           // add	ip, ip, pc
  0xe52dc008,                           // str	ip, [sp, #-8]!
  // Second bundle:
  0xe3ccc103,                           // bic	ip, ip, #0xc0000000
  0xe59cc000,                           // ldr	ip, [ip]
  0xe3ccc13f,                           // bic	ip, ip, #0xc000000f
  0xe12fff1c,                           // bx	ip
  // Third bundle:
  0xe320f000,                           // nop
  0xe320f000,                           // nop
  0xe320f000,                           // nop
  // .Lplt_tail:
  0xe50dc004,                           // str	ip, [sp, #-4]
  // Fourth bundle:
  0xe3ccc103,                           // bic	ip, ip, #0xc0000000
  0xe59cc000,                           // ldr	ip, [ip]
  0xe3ccc13f,                           // bic	ip, ip, #0xc000000f
  0xe12fff1c,                           // bx	ip
};

template<bool big_endian>
void
Output_data_plt_arm_nacl<big_endian>::do_fill_first_plt_entry(
    unsigned char* pov,
    Arm_address got_address,
    Arm_address plt_address)
{
  // Write first PLT entry.  All but first two words are constants.
  const size_t num_first_plt_words = (sizeof(first_plt_entry)
				      / sizeof(first_plt_entry[0]));

  int32_t got_displacement = got_address + 8 - (plt_address + 16);

  elfcpp::Swap<32, big_endian>::writeval
    (pov + 0, first_plt_entry[0] | arm_movw_immediate (got_displacement));
  elfcpp::Swap<32, big_endian>::writeval
    (pov + 4, first_plt_entry[1] | arm_movt_immediate (got_displacement));

  for (size_t i = 2; i < num_first_plt_words; ++i)
    elfcpp::Swap<32, big_endian>::writeval(pov + i * 4, first_plt_entry[i]);
}

// Subsequent entries in the PLT.

template<bool big_endian>
const uint32_t Output_data_plt_arm_nacl<big_endian>::plt_entry[4] =
{
  0xe300c000,                           // movw	ip, #:lower16:&GOT[n]-.+8
  0xe340c000,                           // movt	ip, #:upper16:&GOT[n]-.+8
  0xe08cc00f,                           // add	ip, ip, pc
  0xea000000,                           // b	.Lplt_tail
};

template<bool big_endian>
void
Output_data_plt_arm_nacl<big_endian>::do_fill_plt_entry(
    unsigned char* pov,
    Arm_address got_address,
    Arm_address plt_address,
    unsigned int got_offset,
    unsigned int plt_offset)
{
  // Calculate the displacement between the PLT slot and the
  // common tail that's part of the special initial PLT slot.
  int32_t tail_displacement = (plt_address + (11 * sizeof(uint32_t))
			       - (plt_address + plt_offset
				  + sizeof(plt_entry) + sizeof(uint32_t)));
  gold_assert((tail_displacement & 3) == 0);
  tail_displacement >>= 2;

  gold_assert ((tail_displacement & 0xff000000) == 0
	       || (-tail_displacement & 0xff000000) == 0);

  // Calculate the displacement between the PLT slot and the entry
  // in the GOT.  The offset accounts for the value produced by
  // adding to pc in the penultimate instruction of the PLT stub.
  const int32_t got_displacement = (got_address + got_offset
				    - (plt_address + sizeof(plt_entry)));

  elfcpp::Swap<32, big_endian>::writeval
    (pov + 0, plt_entry[0] | arm_movw_immediate (got_displacement));
  elfcpp::Swap<32, big_endian>::writeval
    (pov + 4, plt_entry[1] | arm_movt_immediate (got_displacement));
  elfcpp::Swap<32, big_endian>::writeval
    (pov + 8, plt_entry[2]);
  elfcpp::Swap<32, big_endian>::writeval
    (pov + 12, plt_entry[3] | (tail_displacement & 0x00ffffff));
}

// Target selectors.

template<bool big_endian>
class Target_selector_arm_nacl
  : public Target_selector_nacl<Target_selector_arm<big_endian>,
				Target_arm_nacl<big_endian> >
{
 public:
  Target_selector_arm_nacl()
    : Target_selector_nacl<Target_selector_arm<big_endian>,
			   Target_arm_nacl<big_endian> >(
	  "arm",
	  big_endian ? "elf32-bigarm-nacl" : "elf32-littlearm-nacl",
	  big_endian ? "armelfb_nacl" : "armelf_nacl")
  { }
};

Target_selector_arm_nacl<false> target_selector_arm;
Target_selector_arm_nacl<true> target_selector_armbe;

} // End anonymous namespace.
@


1.163
log
@    gold/
    	* parameters.cc (Parameters::entry): Return target-specific entry
    	symbol name.
    	* target.h (Target::entry_symbol_name): New function.
    	(Target_info::entry_symbol_name): New data member.

    	* arm.cc (Target_arm::arm_info): Add entry_symbol_name.
    	(Target_arm_nacl::arm_nacl_info): Likewise.
    	* i386.cc (Target_i386::i386_info): Likewise.
    	(Target_i386_nacl::i386_nacl_info): Likewise.
    	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
    	* sparc.cc (Target_sparc::sparc_info): Likewise.
    	* tilegx.cc (Target_tilegx::tilegx_info): Likewise.
    	* x86_64.cc: (Target_x86_64::x86_64_info) Likewise.
    	(Target_x86_64_nacl::x86_64_nacl_info) Likewise.
    	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
@
text
@d2123 1
a2123 1
      copy_relocs_(elfcpp::R_ARM_COPY), dynbss_(NULL),
a2909 2
  // Space for variables copied with a COPY reloc.
  Output_data_space* dynbss_;
d10830 1
a10830 1
		     && !attributes_accept_div(arch, profile, &out_attr[i])) 
@


1.163.2.1
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@d2123 1
a2123 1
      copy_relocs_(elfcpp::R_ARM_COPY),
d2910 2
d10832 1
a10832 1
		     && !attributes_accept_div(arch, profile, &out_attr[i]))
@


1.162
log
@	* target-reloc.h (relocate_section): If the reloc offset is out of
	range, pass VIEW as NULL to relocate.relocate.
	* arm.cc (Target_arm:Relocate::relocate): Check for a NULL view.
	* i386.cc (Target_i386::Relocate::relocate): Likewise.
	* powerpc.cc (Target_powerpc::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Relocate::relocate): Likewise.
	* tilegx.cc (Target_tilegx::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Relocate::relocate): Likewise.
@
text
@d2955 2
a2956 1
  "aeabi"		// attributes_vendor
d12220 2
a12221 1
  "aeabi"		// attributes_vendor
@


1.161
log
@	* arm.cc (Target_arm::attributes_accept_div): New function.
	(Target_arm::attributes_forbid_div): New function.
	(Target_arm::merge_object_attributes): Merge the Tag_DIV_use
	attribute using the same new functions as what bfd/elf32_arm.c
	does.
@
text
@d8847 3
@


1.160
log
@	* layout.h (Layout::get_executable_sections): Declare.
	* layout.cc (Layout::get_executable_sections): New function.
	* arm.cc (Target_arm::group_sections): Use it.
	(Arm_output_section::group_sections): Delete now redundant test.
	* output.cc (Output_reloc::Output_reloc): Add is_relative.
	param to handle relative relocs.
	* output.h (Output_reloc::Output_reloc <absolute reloc>): Likewise.
	(Output_data_reloc::add_absolute): Adjust.
	(Output_data_reloc::add_relative): New function.
	(Output_data::reset_data_size): New function.
	(Output_relaxed_input_section::set_relobj, set_shndx): New functions.
	(Output_section::set_addralign): New function.
	(Output_section::checkpoint_set_addralign): New function.
	(Output_section::clear_section_offsets_need_adjustment): New function.
	(Output_section::input_sections): Make public.
	* powerpc.cc (class Output_data_brlt_powerpc): New.
	(class Stub_table, class Stub_control): New.
	(Powerpc_relobj::has14_, set_has_14bit_branch, has_14bit_branch,
	stub_table_, set_stub_table, stub_table): New vectors and accessor
	functions.
	(Target_powerpc::do_may_relax, do_relax, push_branch,
	new_stub_table, stub_tables, brlt_section, group_sections,
	add_branch_lookup_table, find_branch_lookup_table,
	write_branch_lookup_table, make_brlt_section): New functions.
	(Target_powerpc::struct Sort_sections, class Branch_info): New.
	(Target_powerpc::brlt_section_, stub_tables_, branch_lookup_table_,
	branch_info_): New vars.
	(Target_powerpc::make_plt_entry, make_local_ifunc_plt_entry): Don't
	make call stubs here.
	(Output_data_glink): Remove all call stub handling from this class.
	(Target_powerpc::Scan::local, global): Save interesting branch
	relocs and relocs for ifunc.  Adjust calls to plt entry functions.
	(Target_powerpc::do_finalize_sections): Only make reg save/restore
	functions on final link.
	(Target_powerpc::Relocate::relocate): Adjust lookup of call stubs.
	Handle long branch destinations too.
	(Target_powerpc::do_dynsym_value, do_plt_address_for_global,
	do_plt_address_for_local): Adjust lookup of plt call stubs.
@
text
@d3 1
a3 1
// Copyright 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
d2801 12
d10397 43
d10809 27
a10835 21
	  // This tag is set to zero if we can use UDIV and SDIV in Thumb
	  // mode on a v7-M or v7-R CPU; to one if we can not use UDIV or
	  // SDIV at all; and to two if we can use UDIV or SDIV on a v7-A
	  // CPU.  We will merge as follows: If the input attribute's value
	  // is one then the output attribute's value remains unchanged.  If
	  // the input attribute's value is zero or two then if the output
	  // attribute's value is one the output value is set to the input
	  // value, otherwise the output value must be the same as the
	  // inputs.  */
	  if (in_attr[i].int_value() != 1 && out_attr[i].int_value() != 1)
	    {
	      if (in_attr[i].int_value() != out_attr[i].int_value())
		{
		  gold_error(_("DIV usage mismatch between %s and output"),
			     name);
		}
	    }

	  if (in_attr[i].int_value() != 1)
	    out_attr[i].set_int_value(in_attr[i].int_value());

@


1.159
log
@bfd/
	* elf32-arm.c (elf32_arm_nacl_plt0_entry): Use bic rather than bfc
	instruction for data sandboxing.

gold/
	* arm.cc (Output_data_plt_arm_nacl::first_plt_entry): Use bic rather
	than bfc instruction for data sandboxing.
@
text
@a5646 4
  // We only care about sections containing code.
  if ((this->flags() & elfcpp::SHF_EXECINSTR) == 0)
    return;

d11441 1
a11441 1
  layout->get_allocated_sections(&section_list);
@


1.158
log
@gold/
	* target.h (Sized_target::relocate_relocs): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_relocs): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_relocs): Likewise.
	* powerpc.cc (Target_powerpc::relocate_relocs): Likewise.
	* sparc.cc (Target_sparc::relocate_relocs): Likewise.
	* target-reloc.h (relocate_relocs): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_relocs): Likewise.
	* x86_64.cc (Target_x86_64::relocate_relocs): Likewise.
@
text
@d12221 1
a12221 1
  0xe7dfcf1f,                           // bfc	ip, #30, #2
d12232 1
a12232 1
  0xe7dfcf1f,                           // bfc	ip, #30, #2
@


1.157
log
@
bfd:
        * elf32-arm.c (elf32_arm_print_private_bfd_data): Recognise and
        display the new ARM hard-float/soft-float ABI flags for EABI_VER5
        (elf32_arm_post_process_headers): Add the hard-float/soft-float
        ABI flag as appropriate for ET_DYN/ET_EXEC in EABI_VER5.

binutils:
        * readelf.c (decode_ARM_machine_flags): Recognise and display the
        new ARM hard-float/soft-float ABI flags for EABI_VER5. Split out
        the code for EABI_VER4 and EABI_VER5 to allow this.

elfcpp:
        * arm.h: New enum for EABI soft- and hard-float flags.

gold:
        * gold.cc (Target_arm::do_adjust_elf_header): Add the
        hard-float/soft-float ABI flag as appropriate for ET_DYN/ET_EXEC
        in EABI_VER5.

include:
        * elf/arm.h (EF_ARM_ABI_FLOAT_SOFT): New define.
        (EF_ARM_ABI_FLOAT_HARD): Likewise.

ld/testsuite:
        * ld-arm/eabi-hard-float.s: New test source.
        * ld-arm/eabi-soft-float.s: New test source.
        * ld-arm/eabi-hard-float.d: New test.
        * ld-arm/eabi-soft-float.d: New test.
        * ld-arm/eabi-soft-float-ABI4.d: New test.
        * ld-arm/eabi-soft-float-r.d: New test.
        * ld-arm/arm-elf.xp: Use the new tests.

binutils:
	PR binutils/14779
	* configure.in: Add checks for wchar.h and mbstate_t.
	* config.in: Regenerate.
	* configure: Regenerate.
	* readelf.c: Conditionally include wchar.h.
	(print_symbol): Conditionally use mbstate_t.
@
text
@d2296 2
a2297 1
		  off_t offset_in_output_section,
d2313 2
a2314 1
			       off_t offset_in_output_section,
d9608 1
a9608 1
    off_t offset_in_output_section,
d9643 1
a9643 1
    off_t offset_in_output_section,
@


1.156
log
@	* target-reloc.h (class Default_comdat_behavior): New, package up..
	(get_comdat_behaviour): ..this.
	(relocate_section): Add Relocate_comdat_behavior template arg,
	adjust code to suit.
	* arm.cc (Target_arm::relocate_section): Adjust to suit.
	(Target_arm::scan_reloc_section): Likewise.
	* i386.cc (Target_i386::relocate_section): Likewise.
	* sparc.cc (Target_sparc::relocate_section): Likewise.
	* tilegx.cc (Target_tilegx::relocate_section): Likewise.
	* x86_64.cc (Target_x86_64::relocate_section): Likewise.
	* powerpc.cc (class Relocate_comdat_behavior): New.
	(Target_powerpc::relocate_section): Don't zap opd relocs.  Supply
	gold::relocate_section with new template arg.
@
text
@d2479 1
a2479 1
  do_adjust_elf_header(unsigned char* view, int len) const;
d10019 1
a10019 1
    int len) const
d10024 1
d10028 1
a10028 1
  if (elfcpp::arm_eabi_version(this->processor_specific_flags())
d10037 15
@


1.155
log
@	* target-reloc.h (scan_relocs): Call scan.local for relocs
	against symbols in discarded sections.  Pass is_discarded
	param.
	* arm.cc, * i386.cc, * sparc.cc, * x86_64.cc (Target_*::Scan::local):
	Add is_discarded param.
	* powerpc (Target_powerpc::Scan::local): Likewise.  Use
	is_discarded to flag opd entry as discarded.  Don't emit dyn
	relocs on such entries.
	(Target_powerpc::Scan::global): Similarly detect and handle
	such opd entries.
	(Powerpc_relobj): Replace opd_ent_shndx_ and opd_ent_off_ with
	opd_ent_.  Update all uses.
	(Powerpc_relobj::get_opd_discard, set_opd_discard): New functions.
	(Target_powerpc::relocate_section): Zero out discarded opd
	entry relocs.
@
text
@d9521 1
a9521 1
			 Arm_relocate>(
d11153 1
d11327 1
a11327 1
	      comdat_behavior = get_comdat_behavior(name.c_str());
@


1.154
log
@	* output.h (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::add_local_pair_with_rel): Remove second
	reloc param.  Expand comment.
	(Output_data_got::Got_entry): Rename use_plt_offset_ to
	use_plt_or_tls_offset_, similarly for constructor param.
	(Output_data_got::Got_entry::write): Add got_index param.
	* output.cc (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::Got_entry::write): Handle tls symbols
	with use_plt_or_tls_offset_ set specially.
	(Output_data_got::add_local_pair_with_rel): Only one reloc.
	(Output_data_got::do_write): Replace iterator with index, pass
	index to entry write function.
	* target.h (Target::tls_offset_for_local, tls_offset_for_global,
	do_tls_offset_for_local, do_tls_offset_for_global): New functions.
	* arm.cc (Target_arm::Scan::local): Update add_local_pair_with_rel
	call.
	* i386.cc (Target_i386::Scan::local): Likewise.
	* sparc.cc (Target_sparc::Scan::local): Likewise.
	* x86_64.cc (Target_x86_64::Scan::local): Likewise.
	* powerpc.cc (Target_powerpc::do_tls_offset_for_local,
	do_tls_offset_for_global): New functions.
	(Target_powerpc::Scan::local): Correct TLS relocations and got
	entry values.
	(Target_powerpc::Scan::global): Don't emit unnecessary
	dynamic relocations on TLS GOT entries.
@
text
@d2554 2
a2555 1
	  const elfcpp::Sym<32, big_endian>& lsym);
d7861 2
a7862 1
				    const elfcpp::Sym<32, big_endian>& lsym)
d7864 3
@


1.153
log
@	* object.h (Sized_relobj_file::emit_relocs): Delete.
	(Sized_relobj_file::emit_relocs_reltype): Delete.
	* reloc.cc (Sized_relobj_file::do_relocate_sections): Call target
	relocate_relocs for --emit-relocs.
	(Sized_relobj_file::emit_relocs, emit_relocs_reltype): Delete.
	* output.h: Update comment.
	(Output_segment::first_section): New function.
	(Output_segment::first_section_load_address): Use first_section.
	* output.cc (Output_segment::first_section): New function extracted..
	(Output_segment::first_section_load_address): ..from here.  Delete.
	* target-reloc.h (relocate_for_relocatable): Rename to relocate_relocs.
	* target.h (Sized_target::relocate_for_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise, and
	adjust call to target.h function.
	* i386.cc (Target_i386): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	(Target_powerpc::Scan::local, global): Handle R_POWERPC_TLS.  Ensure
	first tls section has section symbol for optimised local dynamic
	output relocs.
	(Target_powerpc::Relocate::relocate): Correct local dynamic value.
	(Target_powerpc::relocate_relocs): Adjust relocs emitted for
	optimised tls code.
	* testsuite/testfile.cc (Target_test::relocate_for_relocatable):
	Rename to relocate_relocs.  Update error message.
@
text
@d8071 1
a8071 1
					       elfcpp::R_ARM_TLS_DTPMOD32, 0);
@


1.152
log
@	* arm.cc (Arm_relocate_functions::abs16): Remove unused typedef.
	(Arm_exidx_cantunwind::do_fixed_endian_write): Likewise.
	(Target_arm::scan_reloc_for_stub): Likewise.
	* common.cc (Symbol_table::do_allocate_commons_list): Likewise.
	* dwarf_reader.cc (Dwarf_die::skip_attributes): Likewise.
	* ehframe.cc (Eh_frame::do_add_ehframe_input_section): Likewise.
	* incremental.cc (Sized_incr_dynobj::do_add_symbols): Likewise.
	* powerpc.cc (Target_powerpc::relocate_tls): Likewise.
@
text
@d2289 1
a2289 1
  // Relocate a section during a relocatable link.
d2291 12
a2302 12
  relocate_for_relocatable(const Relocate_info<32, big_endian>*,
			   unsigned int sh_type,
			   const unsigned char* prelocs,
			   size_t reloc_count,
			   Output_section* output_section,
			   off_t offset_in_output_section,
			   const Relocatable_relocs*,
			   unsigned char* view,
			   Arm_address view_address,
			   section_size_type view_size,
			   unsigned char* reloc_view,
			   section_size_type reloc_view_size);
d9591 1
a9591 1
// Relocate a section during a relocatable link.
d9595 1
a9595 1
Target_arm<big_endian>::relocate_for_relocatable(
d9611 1
a9611 1
  gold::relocate_for_relocatable<32, big_endian, elfcpp::SHT_REL>(
@


1.152.2.1
log
@gold/
	* target.h (Sized_target::relocate_for_relocatable): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_for_relocatable): Likewise.
	* powerpc.cc (Target_powerpc::relocate_for_relocatable): Likewise.
	* sparc.cc (Target_sparc::relocate_for_relocatable): Likewise.
	* target-reloc.h (relocate_for_relocatable): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_for_relocatable): Likewise.
	* x86_64.cc (Target_x86_64::relocate_for_relocatable): Likewise.
@
text
@d2296 1
a2296 2
			   typename elfcpp::Elf_types<32>::Elf_Off
                             offset_in_output_section,
d2312 1
a2312 2
			       typename elfcpp::Elf_types<32>::Elf_Off
                                 offset_in_output_section,
d9601 1
a9601 1
    typename elfcpp::Elf_types<32>::Elf_Off offset_in_output_section,
d9636 1
a9636 1
    typename elfcpp::Elf_types<32>::Elf_Off offset_in_output_section,
@


1.152.2.2
log
@bfd/
	* elf32-arm.c (elf32_arm_nacl_plt0_entry): Use bic rather than bfc
	instruction for data sandboxing.

gold/
	* arm.cc (Output_data_plt_arm_nacl::first_plt_entry): Use bic rather
	than bfc instruction for data sandboxing.
@
text
@d12199 1
a12199 1
  0xe3ccc103,                           // bic	ip, ip, #0xc0000000
d12210 1
a12210 1
  0xe3ccc103,                           // bic	ip, ip, #0xc0000000
@


1.151
log
@	* configure.ac (ENABLE_GOLD): Consider *-*-nacl* targets ELF.
	* configure: Regenerate.

gold/
	* nacl.cc: New file.
	* nacl.h: New file.
	* Makefile.am (CCFILES, HFILES): Add them.
	* Makefile.in: Regenerate.
	* i386.cc (Output_data_plt_i386_nacl): New class.
	(Output_data_plt_i386_nacl_exec): New class.
	(Output_data_plt_i386_nacl_dyn): New class.
	(Target_i386_nacl): New class.
	(Target_selector_i386_nacl): New class.
	(target_selector_i386): Use it instead of Target_selector_i386.
	* x86_64.cc (Output_data_plt_x86_64_nacl): New class.
	(Target_x86_64_nacl): New class.
	(Target_selector_x86_64_nacl): New class.
	(target_selector_x86_64, target_selector_x32): Use it instead of
	Target_selector_x86_64.
	* arm.cc (Output_data_plt_arm_nacl): New class.
	(Target_arm_nacl): New class.
	(Target_selector_arm_nacl): New class.
	(target_selector_arm, target_selector_armbe): Use it instead of
	Target_selector_arm.

	* target-select.cc (select_target): Take new Input_file* and off_t
	arguments, pass them on to recognize method of selector.
	* object.cc (make_elf_sized_object): Update caller.
	* parameters.cc (parameters_force_valid_target): Likewise.
	* incremental.cc (make_sized_incremental_binary): Likewise.
	* target-select.h: Update decl.
	(Target_selector::recognize): Take new Input_file* argument,
	pass it on to do_recognize.
	(Target_selector::do_recognize): Take new Input_file* argument.
	* freebsd.h (Target_selector_freebsd::do_recognize): Likewise.
	* powerpc.cc (Target_selector_powerpc::do_recognize): Likewise.
	* sparc.cc (Target_selector_sparc::do_recognize): Likewise.
	* testsuite/testfile.cc (Target_selector::do_recognize): Likewise.

	* target.h (Target::Target_info): New members isolate_execinstr
	and rosegment_gap.
	(Target::isolate_execinstr, Target::rosegment_gap): New methods.
	* arm.cc (Target_arm::arm_info): Update initializer.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
	* sparc.cc (Target_sparc::sparc_info): Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
	* layout.cc (Layout::attach_allocated_section_to_segment):
	Take new const Target* argument.  If target->isolate_execinstr(), act
	like --rosegment.
	(Layout::find_first_load_seg): Take new const Target* argument;
	if target->isolate_execinstr(), reject PF_X segments.
	(Layout::relaxation_loop_body): Update caller.
	(Layout::set_segment_offsets): If target->isolate_execinstr(),
	reset file offset to zero when we hit LOAD_SEG, and then do a second
	loop over the segments before LOAD_SEG to reassign offsets after
	addresses have been determined.  Handle target->rosegment_gap().
	(Layout::attach_section_to_segment): Take new const Target* argument;
	pass it to attach_allocated_section_to_segment.
	(Layout::make_output_section): Update caller.
	(Layout::attach_sections_to_segments): Take new const Target* argument;
	pass it to attach_section_to_segment.
	* gold.cc (queue_middle_tasks): Update caller.
	* layout.h (Layout): Update method decls with new arguments.

	* arm.cc (Target_arm::Target_arm): Take optional argument for the
	Target_info pointer to use.
	(Target_arm::do_make_data_plt): New virtual method.
	(Target_arm::make_data_plt): New method that calls it.
	(Target_arm::make_plt_entry): Use it.
	(Output_data_plt_arm::Output_data_plt_arm): Take additional argument
	for the section alignment.
	(Output_data_plt_arm::do_first_plt_entry_offset): New abstract virtual
	method.
	(Output_data_plt_arm::first_plt_entry_offset): Call it.
	(Output_data_plt_arm::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_arm::get_plt_entry_size): Call it.
	(Output_data_plt_arm::do_fill_plt_entry): New abstract virtual method.
	(Output_data_plt_arm::fill_plt_entry): New method that calls it.
	(Output_data_plt_arm::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_arm::fill_first_plt_entry): New method that calls it.
	(Output_data_plt_arm::set_final_data_size): Use get_plt_entry_size
	method instead of sizeof(plt_entry).
	(Output_data_plt_arm::add_entry): Likewise.
	Use first_plt_entry_offset method instead of sizeof(first_plt_entry).
	(Target_arm::first_plt_entry_offset): Call method on this->plt_ rather
	than static method.
	(Target_arm::plt_entry_size): Likewise.
	(Output_data_plt_arm::first_plt_entry, Output_data_plt_arm::plt_entry):
	Move to ...
	(Output_data_plt_arm_standard): ... here, new class.
	(Output_data_plt_arm::do_write): Move guts of PLT filling to...
	(Output_data_plt_arm_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_arm_standard::do_fill_plt_entry): ... and here.

	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Take additional argument for the PLT entry size.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset):
	Use get_plt_entry_size method rather than plt_entry_size variable.
	(Output_data_plt_x86_64::reserve_slot): Likewise.
	(Output_data_plt_x86_64::do_adjust_output_section): Likewise.
	(Output_data_plt_x86_64::add_entry): Likewise.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Likewise.
	(Output_data_plt_x86_64::address_for_global): Likewise.
	(Output_data_plt_x86_64::address_for_local): Likewise.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::first_plt_entry_offset): Likewise.
	Make method non-static.
	(Output_data_plt_x86_64::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_x86_64::get_plt_entry_size): Just call that.
	(Output_data_plt_x86_64::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_x86_64::add_eh_frame): New method to call it.
	(Output_data_plt_x86_64::do_fill_first_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_first_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_tlsdesc_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_tlsdesc_entry): New method to call it.
	(Output_data_plt_x86_64::plt_entry_size)
	(Output_data_plt_x86_64::first_plt_entry)
	(Output_data_plt_x86_64::plt_entry)
	(Output_data_plt_x86_64::tlsdesc_plt_entry)
	(Output_data_plt_x86_64::plt_eh_frame_fde_size)
	(Output_data_plt_x86_64::plt_eh_frame_fde): Move to ...
	(Output_data_plt_x86_64_standard): ... here, new class.
	(Target_x86_64::Target_x86_64): Take optional argument for the
	Target_info pointer to use.
	(Target_x86_64::do_make_data_plt): New virtual method.
	(Target_x86_64::make_data_plt): New method to call it.
	(Target_x86_64::init_got_plt_for_update): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_x86_64::init):	Don't do add_eh_frame_for_plt here.
	(Target_x86_64::first_plt_entry_offset): Call method on this->plt_
	rather than static method.
	(Target_x86_64::plt_entry_size): Likewise.
	(Output_data_plt_x86_64::do_write): Use get_plt_entry_size method
	rather than plt_entry_size variable.  Move guts of PLT filling to...
	(Output_data_plt_x86_64_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_x86_64_standard::do_fill_plt_entry): ... and here ...
	(Output_data_plt_x86_64_standard::do_fill_tlsdesc_entry): ... and here.

	* i386.cc (Output_data_plt_i386::Output_data_plt_i386): Take
	additional argument for the section alignment.
	Don't do add_eh_frame_for_plt here.
	(Output_data_plt_i386::first_plt_entry_offset): Make the method
	non-static.  Use get_plt_entry_size method rather than plt_entry_size
	variable.
	(Output_data_plt_i386::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_i386::get_plt_entry_size): Call it.
	(Output_data_plt_i386::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_i386::add_eh_frame): New method to call it.
	(Output_data_plt_i386::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_first_plt_entry): New method to call it.
	(Output_data_plt_i386::do_fill_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_plt_entry): New method to call it.
	(Output_data_plt_i386::set_final_data_size): Use get_plt_entry_size
	method instead of plt_entry_size.
	(Output_data_plt_i386::plt_entry_size)
	(Output_data_plt_i386::plt_eh_frame_fde_size)
	(Output_data_plt_i386::plt_eh_frame_fde): Move to ...
	(Output_data_plt_i386_standard): ... here, new class.
	(Output_data_plt_i386_exec): New class.
	(Output_data_plt_i386::exec_first_plt_entry): Move to ...
	(Output_data_plt_i386_exec::first_plt_entry): ... here.
	(Output_data_plt_i386::exec_plt_entry): Move to ...
	(Output_data_plt_i386_exec::plt_entry): ... here.
	(Output_data_plt_i386_dyn): New class.
	(Output_data_plt_i386::first_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::first_plt_entry): ... here.
	(Output_data_plt_i386::dyn_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::plt_entry): ... here.
	(Target_i386::Target_i386): Take optional argument for the Target_info
	pointer to use.
	(Target_i386::do_make_data_plt): New virtual method.
	(Target_i386::make_data_plt): New method to call it.
	(Target_i386::make_plt_section): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_i386::add_entry): Use get_plt_entry_size method
	rather than plt_entry_size variable.
	(Output_data_plt_i386::add_local_ifunc_entry): Likewise.
	(Output_data_plt_i386::address_for_local): Likewise.
	(Output_data_plt_i386::do_write): Likewise.
	Move guts of PLT filling to...
	(Output_data_plt_i386_exec::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_i386_exec::do_fill_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_first_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_plt_entry): ... and here.

Change-Id: Id24b95600489835ff5e860a39c147203d4380c2b
@
text
@a3255 1
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
a5210 2
  typedef typename elfcpp::Swap_unaligned<32, big_endian>::Valtype Valtype;

a10989 2
  typedef typename Target_arm<big_endian>::Relocate Relocate;

@


1.150
log
@	* arm.cc (Target_arm::do_is_defined_by_abi): Make sym a const
	pointer.
	(Stub_addend_reader::operator()): Declare Arm_relocate_functions
	as a class, not a struct.
	(Target_arm::scan_span_for_cortex_a8_erratum): Likewise.
	(Target_arm::apply_cortex_a8_workaround): Likewise.
	* gc.h: Declare Reloc_types as a struct, not a class.
	* object.h: Declare Symbols_data as a struct.
	* reloc.h: Declare Read_relocs_data as a struct.
	* target.h: Declare Relocate_info as a struct.
@
text
@d54 1
d65 3
d114 1
a114 1
// 
d145 1
a145 1
      // THUMB16_SPECIAL_TYPE is used by sub-classes of Stub for instruction 
d159 1
a159 1
  { return Insn_template(data, THUMB16_TYPE, elfcpp::R_ARM_NONE, 0); } 
d165 1
a165 1
  { return Insn_template(data, THUMB16_SPECIAL_TYPE, elfcpp::R_ARM_NONE, 1); } 
d169 1
a169 1
  { return Insn_template(data, THUMB32_TYPE, elfcpp::R_ARM_NONE, 0); } 
d176 1
a176 1
  } 
d188 1
a188 1
  { return Insn_template(data, DATA_TYPE, r_type, reloc_addend); } 
d277 1
a277 1
    
d319 1
a319 1
  
d356 1
a356 1
  
d371 1
a371 1
  // them here for speed. 
d412 1
a412 1
  
d444 1
a444 1
  
d557 1
a557 1
    eq(const Key& k) const 
d607 1
a607 1
    // independent Symbol and Relobj classes instead of Sized_symbol<32> and  
d648 1
a648 1
// 
d722 2
a723 2
        // The conditional branch veneer has two relocations.
        gold_assert(i < 2);
d728 3
a730 3
        // All other Cortex-A8 stubs have only one relocation.
        gold_assert(i == 0);
        return this->destination_address_;
d857 1
a857 1
  
d863 1
a863 1
  
d977 1
a977 1
  
d988 1
a988 1
 
d1003 1
a1003 1
  
d1081 1
a1081 1
  
d1090 1
a1090 1
// to the output offset from the start of this EXIDX section. 
d1139 1
a1139 1
  // Merged section contents.  We need to keep build the merged section 
d1163 1
a1163 1
  
d1218 1
a1218 1
                   section_offset_type* poutput) const
d1279 1
a1279 1
  
d1363 1
a1363 1
  
d1423 1
a1423 1
  	
d1492 1
a1492 1
             const typename elfcpp::Ehdr<32, big_endian>& ehdr)
d1503 1
a1503 1
 
d1528 1
a1528 1
  
d1576 1
a1576 1
  
d1585 1
a1585 1
  { 
d1589 1
a1589 1
  
d1632 1
a1632 1
  
d1641 1
a1641 1
  
d1654 1
a1654 1
    // Sort list to make result independent of implementation of map. 
d1674 1
a1674 1
                         Stringpool_template<char>*);
d1776 1
a1776 1
 
d1869 1
a1869 1
  
d1874 2
a1875 2
  { return this->reloc_stub_; } 
  
d2083 1
a2083 1
          // have alignment of 1.
d2120 2
a2121 2
  Target_arm()
    : Sized_target<32, big_endian>(&arm_info),
d2123 1
a2123 1
      copy_relocs_(elfcpp::R_ARM_COPY), dynbss_(NULL), 
d2140 1
a2140 1
  
d2203 1
a2203 1
  
d2222 2
a2223 2
  
  // Process the relocations to determine unreferenced sections for 
d2318 1
a2318 1
 
d2365 1
a2365 1
  
d2391 1
a2391 1
  // Relocate a stub. 
d2396 1
a2396 1
 
d2447 5
d2526 1
a2526 1
  
d2530 6
d2566 4
a2569 4
  	          			Sized_relobj_file<32, big_endian>* ,
        	  			unsigned int ,
  	          			Output_section* ,
	          			const elfcpp::Rel<32, big_endian>& ,
d2571 1
a2571 1
 	          			const elfcpp::Sym<32, big_endian>&);
d2575 4
a2578 4
  	           			 Sized_relobj_file<32, big_endian>* ,
	           			 unsigned int ,
	           			 Output_section* ,
	           			 const elfcpp::Rel<32, big_endian>& ,
d2685 1
a2685 1
                 size_t, const elfcpp::Rel<32, big_endian>&, unsigned int,
d2880 1
a2880 1
    
d2933 2
d2963 1
a2963 1
  //     
d2966 1
a2966 1
  //  f e d c b a 9 8 7 6 5 4 3 2 1 0 f e d c b a 9 8 7 6 5 4 3 2 1 0 
d2997 1
a2997 1
  //     
d3000 1
a3000 1
  //  f e d c b a 9 8 7 6 5 4 3 2 1 0  f e d c b a 9 8 7 6 5 4 3 2 1 0 
d3148 3
a3150 3
            | ((((bits >> 23) & 1) ^ !s) << 13)
            | ((((bits >> 22) & 1) ^ !s) << 11)
            | ((bits >> 1) & 0x7ffU));
d3339 1
a3339 1
                                                | ((x & 0x01fe) >> 1)));
d3359 1
a3359 1
                                                | ((x & 0x0ffe) >> 1)));
d3492 1
a3492 1
    	    ? This::STATUS_OVERFLOW
d3569 1
a3569 1
    	    This::STATUS_OVERFLOW : This::STATUS_OKAY);
d3624 1
a3624 1
    	    This::STATUS_OVERFLOW : This::STATUS_OKAY);
d3869 1
a3869 1
     
d3871 1
a3871 1
	            && ((val & 0x0f000000UL) == 0x0a000000UL);
d3922 1
a3922 1
 
d4004 1
a4004 1
     
d4027 1
a4027 1
			 (gsym ? gsym->name() : "(local)")); 
d4056 1
a4056 1
 
d4095 1
a4095 1
	  if (thumb_bit == 0 && may_use_blx) 
d4321 1
a4321 1
          if (insns[i].r_type() != elfcpp::R_ARM_NONE)
d4325 1
a4325 1
          break;
d4343 1
a4343 1
      offset += insn_size; 
d4380 1
a4380 1
          break;
d4391 1
a4391 1
} 
d4480 1
a4480 1
	
d4531 1
a4531 1
	     
d4632 1
a4632 1
 
d4639 1
a4639 1
  						// dcd   R_ARM_ABS32(X)
d4641 1
a4641 1
  
d4649 1
a4649 1
  						// dcd   R_ARM_ABS32(X)
d4651 1
a4651 1
  
d4662 1
a4662 1
  						// dcd  R_ARM_ABS32(X)
d4664 1
a4664 1
  
d4674 1
a4674 1
  						// dcd  R_ARM_ABS32(X)
d4676 1
a4676 1
  
d4685 1
a4685 1
  						// dcd   R_ARM_ABS32(X)
d4687 1
a4687 1
  
d4696 1
a4696 1
  
d4704 1
a4704 1
  						// dcd   R_ARM_REL32(X-4)
d4706 1
a4706 1
  
d4717 1
a4717 1
  						// dcd   R_ARM_REL32(X)
d4719 1
a4719 1
  
d4727 1
a4727 1
  						// dcd   R_ARM_REL32(X)
d4729 1
a4729 1
  
d4738 1
a4738 1
  						// dcd  R_ARM_REL32(X)
d4740 1
a4740 1
  
d4752 1
a4752 1
  						// dcd  R_ARM_REL32(X)
d4754 1
a4754 1
  
d4765 1
a4765 1
  						// dcd  R_ARM_REL32(X)
d4767 1
a4767 1
  
d4769 1
a4769 1
  
d4772 1
a4772 1
  
d4783 1
a4783 1
  							//	b.w X
d4785 1
a4785 1
  
d4787 1
a4787 1
  
d4792 1
a4792 1
  
d4797 1
a4797 1
  
d5018 1
a5018 1
  this->prev_data_size_ = size; 
d5152 1
a5152 1
	    this->original_size_); 
d5211 1
a5211 1
  
d5229 1
a5229 1
        arm_relobj->exidx_input_section_by_link(this->shndx_);
d5309 1
a5309 1
        this->section_offset_map_.begin();
d5381 1
a5381 1
  
d5393 1
a5393 1
  
d5504 1
a5504 1
  
d5537 1
a5537 1
  
d5546 1
a5546 1
  
d5579 1
a5579 1
  // because we should not be calling this for an EXIDX section. 
d5586 1
a5586 1
  
d5610 1
a5610 1
  
d5635 1
a5635 1
// 
d5686 2
a5687 2
	section_begin_offset + p->data_size(); 
      
d5699 1
a5699 1
		{	
d5732 1
a5732 1
	}	
d5829 1
a5829 1
  
d5899 1
a5899 1
	exidx_relobj->section_contents(exidx_shndx, &exidx_size, false); 
d5904 1
a5904 1
        exidx_fixup.process_exidx_section<big_endian>(exidx_input_section,
d5948 1
a5948 1
      processed_input_sections.insert(Section_id(exidx_relobj, exidx_shndx)); 
d5983 1
a5983 1
    
d6190 1
a6190 1
  
d6209 1
a6209 1
	  
d6220 1
a6220 1
      p = next; 
d6336 1
a6336 1
// Sized_relobj_file<size, big_endian>::do_count_local_symbols. 
d6346 1
a6346 1
  
d6383 1
a6383 1
	          static_cast<unsigned int>(strtabshdr.get_sh_type()));
d6443 1
a6443 1
							  pshdrs, of, pviews); 
d6491 1
a6491 1
 
d6549 1
a6549 1
  
d6557 1
a6557 1
 
d6560 1
a6560 1
      this->get_view(shdr.get_sh_offset(), shdr.get_sh_size(), true, false); 
d6636 1
a6636 1
    } 
d6727 1
a6727 1
     	  gold_assert(this->attributes_section_data_ == NULL);
d6762 1
a6762 1
  // Some tools are broken and they do not set the link of EXIDX sections. 
d6808 1
a6808 1
      // Process the deferred EXIDX sections. 
d6826 1
a6826 1
// sections for unwinding.  These sections are referenced implicitly by 
d6845 1
a6845 1
  
d6950 1
a6950 1
		}	
d7014 1
a7014 1
  
d7072 1
a7072 1
  gsym->set_got_offset(got_type, got_offset); 
d7096 2
a7097 2
  this->static_relocs_.push_back(Static_reloc(got_offset, 
					      elfcpp::R_ARM_TLS_DTPOFF32, 
d7121 1
a7121 1
  
d7130 1
a7130 1
      
d7153 1
a7153 1
	  
d7209 3
d7220 1
a7220 1
  Output_data_plt_arm(Layout*, Output_data_space*);
d7237 3
a7239 3
  static unsigned int
  first_plt_entry_offset()
  { return sizeof(first_plt_entry); }
d7242 3
a7244 3
  static unsigned int
  get_plt_entry_size()
  { return sizeof(plt_entry); }
d7247 33
a7288 6
  // Template for the first PLT entry.
  static const uint32_t first_plt_entry[5];

  // Template for subsequent PLT entries. 
  static const uint32_t plt_entry[3];

d7293 2
a7294 2
    this->set_data_size(sizeof(first_plt_entry)
			+ this->count_ * sizeof(plt_entry));
d7315 1
d7317 1
a7317 1
  : Output_section_data(4), got_plt_(got_plt), count_(0)
d7342 2
a7343 2
  gsym->set_plt_offset((this->count_) * sizeof(plt_entry)
		       + sizeof(first_plt_entry));
d7364 39
d7410 1
a7410 1
const uint32_t Output_data_plt_arm<big_endian>::first_plt_entry[5] =
d7414 1
a7414 1
  0xe08fe00e,	// add   lr, pc, lr 
d7419 17
d7439 1
a7439 1
const uint32_t Output_data_plt_arm<big_endian>::plt_entry[3] =
d7446 21
d7490 3
a7492 9
  // Write first PLT entry.  All but the last word are constants.
  const size_t num_first_plt_words = (sizeof(first_plt_entry)
				      / sizeof(plt_entry[0]));
  for (size_t i = 0; i < num_first_plt_words - 1; i++)
    elfcpp::Swap<32, big_endian>::writeval(pov + i * 4, first_plt_entry[i]);
  // Last word in first PLT entry is &GOT[0] - .
  elfcpp::Swap<32, big_endian>::writeval(pov + 16,
					 got_address - (plt_address + 16));
  pov += sizeof(first_plt_entry);
d7499 1
a7499 3
  const int rel_size = elfcpp::Elf_sizes<32>::rel_size;
  unsigned int plt_offset = sizeof(first_plt_entry);
  unsigned int plt_rel_offset = 0;
d7505 1
a7505 1
	 pov += sizeof(plt_entry),
d7507 1
a7507 2
	 plt_offset += sizeof(plt_entry),
	 plt_rel_offset += rel_size,
d7511 2
a7512 10
      int32_t offset = ((got_address + got_offset)
			 - (plt_address + plt_offset + 8));

      gold_assert(offset >= 0 && offset < 0x0fffffff);
      uint32_t plt_insn0 = plt_entry[0] | ((offset >> 20) & 0xff);
      elfcpp::Swap<32, big_endian>::writeval(pov, plt_insn0);
      uint32_t plt_insn1 = plt_entry[1] | ((offset >> 12) & 0xff);
      elfcpp::Swap<32, big_endian>::writeval(pov + 4, plt_insn1);
      uint32_t plt_insn2 = plt_entry[2] | (offset & 0xfff);
      elfcpp::Swap<32, big_endian>::writeval(pov + 8, plt_insn2);
d7540 2
a7541 1
      this->plt_ = new Output_data_plt_arm<big_endian>(layout, this->got_plt_);
d7567 1
a7567 1
  return Output_data_plt_arm<big_endian>::first_plt_entry_offset();
d7576 1
a7576 1
  return Output_data_plt_arm<big_endian>::get_plt_entry_size();
d7886 2
a7887 2
   	  // If we are to add more other reloc types than R_ARM_ABS32,
   	  // we need to add check_non_pic(object, r_type) here.
d7909 1
a7909 1
        {
d7911 1
a7911 1
          Reloc_section* rel_dyn = target->rel_dyn_section(layout);
d7913 1
a7913 1
          if (lsym.get_st_type() != elfcpp::STT_SECTION)
d7916 3
a7918 3
          else
            {
              gold_assert(lsym.get_st_value() == 0);
d7930 2
a7931 2
            }
        }
d8048 1
a8048 1
            = Target_arm<big_endian>::optimize_tls_reloc(!output_is_shared,
d8055 5
a8059 5
	        // Create a pair of GOT entries for the module index and
	        // dtv-relative offset.
                Arm_output_data_got<big_endian>* got
                    = target->got_section(symtab, layout);
                unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
d8087 2
a8088 2
	        // Create a GOT entry for the module index.
	        target->got_mod_index_entry(symtab, layout, object);
d8131 3
a8133 3
	        // We need to create a dynamic relocation.
                gold_assert(lsym.get_st_type() != elfcpp::STT_SECTION);
                unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
d8279 20
a8298 20
        // Make a PLT entry if necessary.
        if (this->symbol_needs_plt_entry(gsym))
          {
            target->make_plt_entry(symtab, layout, gsym);
            // Since this is not a PC-relative relocation, we may be
            // taking the address of a function. In that case we need to
            // set the entry in the dynamic symbol table to the address of
            // the PLT entry.
            if (gsym->is_from_dynobj() && !parameters->options().shared())
              gsym->set_needs_dynsym_value();
          }
        // Make a dynamic relocation if necessary.
        if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
          {
            if (gsym->may_need_copy_reloc())
              {
	        target->copy_reloc(symtab, layout, object,
	                           data_shndx, output_section, gsym, reloc);
              }
            else if ((r_type == elfcpp::R_ARM_ABS32
d8300 9
a8308 9
                     && gsym->can_use_relative_reloc(false))
              {
                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                rel_dyn->add_global_relative(gsym, elfcpp::R_ARM_RELATIVE,
                                             output_section, object,
                                             data_shndx, reloc.get_r_offset());
              }
            else
              {
d8310 5
a8314 5
                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                rel_dyn->add_global(gsym, r_type, output_section, object,
                                    data_shndx, reloc.get_r_offset());
              }
          }
d8323 1
a8323 1
      
d8480 1
a8480 1
            = Target_arm<big_endian>::optimize_tls_reloc(is_final, r_type);
d8486 4
a8489 4
	        // Create a pair of GOT entries for the module index and
	        // dtv-relative offset.
                Arm_output_data_got<big_endian>* got
                    = target->got_section(symtab, layout);
d8506 2
a8507 2
	        // Create a GOT entry for the module index.
	        target->got_mod_index_entry(symtab, layout, object);
d8546 3
a8548 3
	        // We need to create a dynamic relocation.
                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                rel_dyn->add_global(gsym, elfcpp::R_ARM_TLS_TPOFF32,
d8550 1
a8550 1
                                    data_shndx, reloc.get_r_offset());
d8669 1
a8669 1
    } 
d8700 1
a8700 1
      // profile.  
d8705 2
a8706 2
         && (cpu_arch_profile_attr->int_value() == 'A'
             || cpu_arch_profile_attr->int_value() == 0));
d8708 1
a8708 1
  
d8715 1
a8715 1
	         "the target profile does not support BX instruction"));
d8735 15
a8749 15
          && exidx_section->type() == elfcpp::SHT_ARM_EXIDX)
        {
          // For the ARM target, we need to add a PT_ARM_EXIDX segment for
          // the .ARM.exidx section.
          if (!layout->script_options()->saw_phdrs_clause())
            {
              gold_assert(layout->find_output_segment(elfcpp::PT_ARM_EXIDX, 0,
                                                      0)
                          == NULL);
              Output_segment*  exidx_segment =
                layout->make_output_segment(elfcpp::PT_ARM_EXIDX, elfcpp::PF_R);
              exidx_segment->add_output_section_to_nonload(exidx_section,
                                                           elfcpp::PF_R);
            }
        }
d8940 2
a8941 2
          // This is a local symbol.  Determine if the final target is THUMB.
          // We saved this information when all the local symbols were read.
d8957 1
a8957 1
      && reloc_property->uses_thumb_bit() 
d8964 1
a8964 1
    } 
d9015 1
a9015 1
      gold_unreachable(); 
d9017 1
a9017 1
    
d9069 1
a9069 1
       						        0, thumb_bit, false);
d9109 1
a9109 1
	
d9178 1
a9178 1
    	Arm_relocate_functions::arm_branch_common(
d9369 13
a9381 13
        {
          unsigned int got_type = GOT_TYPE_TLS_PAIR;
          unsigned int got_offset;
          if (gsym != NULL)
            {
              gold_assert(gsym->has_got_offset(got_type));
              got_offset = gsym->got_offset(got_type) - target->got_size();
            }
          else
            {
              unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
              gold_assert(object->local_has_got_offset(r_sym, got_type));
              got_offset = (object->local_got_offset(r_sym, got_type)
d9383 3
a9385 3
            }
          if (optimized_type == tls::TLSOPT_NONE)
            {
d9388 3
a9390 3
	      
              // Relocate the field with the PC relative offset of the pair of
              // GOT entries.
d9392 3
a9394 3
              return ArmRelocFuncs::STATUS_OKAY;
            }
        }
d9399 5
a9403 5
        {
          // Relocate the field with the offset of the GOT entry for
          // the module index.
          unsigned int got_offset;
          got_offset = (target->got_mod_index_entry(NULL, NULL, NULL)
d9408 3
a9410 3
          // Relocate the field with the PC relative offset of the pair of
          // GOT entries.
          RelocFuncs::pcrel32_unaligned(view, got_entry, address);
d9412 1
a9412 1
        }
d9421 3
a9423 3
        {
          // Relocate the field with the offset of the GOT entry for
          // the tp-relative offset of the symbol.
d9425 12
a9436 12
          unsigned int got_offset;
          if (gsym != NULL)
            {
              gold_assert(gsym->has_got_offset(got_type));
              got_offset = gsym->got_offset(got_type);
            }
          else
            {
              unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
              gold_assert(object->local_has_got_offset(r_sym, got_type));
              got_offset = object->local_got_offset(r_sym, got_type);
            }
d9438 2
a9439 2
          // All GOT offsets are relative to the end of the GOT.
          got_offset -= target->got_size();
d9444 1
a9444 1
          // Relocate the field with the PC relative offset of the GOT entry.
d9447 1
a9447 1
        }
d9454 2
a9455 2
        {
          gold_assert(tls_segment != NULL);
d9461 1
a9461 1
          RelocFuncs::rel32_unaligned(view, value + aligned_tcb_size);
d9463 1
a9463 1
        }
d9465 1
a9465 1
    
d9694 1
a9694 1
          convert_types<section_offset_type, Arm_address>(offset);
d9696 2
a9697 2
          output_section->output_offset(object, relinfo->data_shndx,
                                        sot_offset);
d9709 1
a9709 1
        new_offset -= offset_in_output_section;
d9731 1
a9731 1
      && arp->uses_thumb_bit() 
d9738 1
a9738 1
    } 
d9796 1
a9796 1
    	Arm_relocate_functions<big_endian>::arm_branch_common(
d10057 1
a10057 1
        new Arm_relobj<big_endian>(name, input_file, offset, ehdr);
d10064 1
a10064 1
        new Arm_dynobj<big_endian>(name, input_file, offset, ehdr);
d10071 1
a10071 1
                 name.c_str(), et);
d10366 1
a10366 1
    } 
d10396 1
a10396 1
	        != out_attr[elfcpp::Tag_MPextension_use].int_value())
d10426 1
a10426 1
        gold_error(_("%s uses VFP register arguments, output does not"),
d10746 3
a10748 3
	  // inputs.  */ 
	  if (in_attr[i].int_value() != 1 && out_attr[i].int_value() != 1) 
	    { 
d10754 1
a10754 1
	    } 
d10757 2
a10758 2
	    out_attr[i].set_int_value(in_attr[i].int_value()); 
	  
d10771 1
a10771 1
			       "Tag_MPextension_use attributes"), 
d10867 1
a10867 1
	  out_other_attributes->erase(out_iter); 
d10945 1
a10945 1
  return arm_input_section; 
d11042 1
a11042 1
    } 
d11076 1
a11076 1
      Stub_table<big_endian>* stub_table = 
d11079 1
a11079 1
   
d11167 7
a11173 7
         && (r_type != elfcpp::R_ARM_JUMP24)
         && (r_type != elfcpp::R_ARM_PLT32)
         && (r_type != elfcpp::R_ARM_THM_CALL)
         && (r_type != elfcpp::R_ARM_THM_XPC22)
         && (r_type != elfcpp::R_ARM_THM_JUMP24)
         && (r_type != elfcpp::R_ARM_THM_JUMP19)
         && (r_type != elfcpp::R_ARM_V4BX))
d11212 1
a11212 1
		        this->stub_factory().make_arm_v4bx_stub(reg);
d11237 5
a11241 5
          // If the local symbol belongs to a section we are discarding,
          // and that section is a debug section, try to find the
          // corresponding kept section and map this symbol to its
          // counterpart in the kept section.  The symbol must not 
          // correspond to a section we are folding.
d11257 1
a11257 1
						      relinfo->symtab); 
d11276 1
a11276 1
		  continue;  
d11497 1
a11497 1
     
d11561 1
a11561 1
  
d11777 3
a11779 3
      	  is_bl = (insn & 0xf800d000U) == 0xf000d000U;
       	  // Encoding T2: BLX<c>.W.
       	  is_blx = (insn & 0xf800d000U) == 0xf000c000U;
d11786 1
a11786 1
			   
d11841 1
a11841 1
	        offset &= ~3;
d11878 1
a11878 1
              // If we found a relocation, use the proper destination,
d11881 2
a11882 2
              if (cortex_a8_reloc != NULL)
                offset = (off_t) (cortex_a8_reloc->destination() - pc_for_insn);
d11884 1
a11884 1
              Arm_address target = (pc_for_insn + offset) | (is_blx ? 0 : 1);
d11887 2
a11888 2
              if (((address + i) & ~0xfffU) == (target & ~0xfffU))
                {
d11898 3
a11900 3
                }
            }
        }
d11958 3
d12034 1
a12034 1
    } 
d12069 1
a12069 1
			 	    0, // value
d12083 4
a12086 4
                                 Symbol_table::PREDEFINED,
                                 0, 0, elfcpp::STT_OBJECT,
                                 elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN, 0,
                                 true, false);
d12088 4
a12091 4
                                 Symbol_table::PREDEFINED,
                                 0, 0, elfcpp::STT_OBJECT,
                                 elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN, 0,
                                 true, false);
d12095 212
a12306 2
Target_selector_arm<false> target_selector_arm;
Target_selector_arm<true> target_selector_armbe;
@


1.149
log
@2012-03-19  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_define_standard_symbols): New method.
 	(Target_arm::do_finalize_sections): Remove code which defines
	__exidx_start and __exidx_end.  Make symbol table parameter
	anonymous as it is not used.
	* gold.cc (queue_middle_tasks): Call target hook to define any
	target-specific symbols.
	* target.h (Target::define_standard_symbols): New method.
	(Target::do_define_standard_symbols): Same.
	* testsuite/Makefile.am (arm_exidx_test): Dump relocations also.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/arm_exidx.s: Generate data relocations for __exidx_start
	and __exidx_end.
	* testsuite/arm_exidx_test.sh: Check that no unused dynamic
	relocations are generated for __exidx_start and __exidx_end.
@
text
@d2317 1
a2317 1
  do_is_defined_by_abi(Symbol* sym) const
d6996 1
a6996 1
  typedef struct Arm_relocate_functions<big_endian> RelocFuncs;
d11712 1
a11712 1
	  typedef struct Arm_relocate_functions<big_endian> RelocFuncs;
d11815 1
a11815 1
  typedef struct Arm_relocate_functions<big_endian> RelocFuncs;
@


1.148
log
@2012-03-15  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::got_section): Make .got section read-only
	if -z now is given.
@
text
@d2518 3
d8541 1
a8541 1
    Symbol_table* symtab)
a8627 12
          // Create __exidx_start and __exidx_end symbols.
          symtab->define_in_output_data("__exidx_start", NULL,
                                        Symbol_table::PREDEFINED,
                                        exidx_section, 0, 0, elfcpp::STT_OBJECT,
                                        elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN,
                                        0, false, true);
          symtab->define_in_output_data("__exidx_end", NULL,
                                        Symbol_table::PREDEFINED,
                                        exidx_section, 0, 0, elfcpp::STT_OBJECT,
                                        elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN,
                                        0, true, true);

a8640 13
      else
        {
          symtab->define_as_constant("__exidx_start", NULL,
                                     Symbol_table::PREDEFINED,
                                     0, 0, elfcpp::STT_OBJECT,
                                     elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN, 0,
                                     true, false);
          symtab->define_as_constant("__exidx_end", NULL,
                                     Symbol_table::PREDEFINED,
                                     0, 0, elfcpp::STT_OBJECT,
                                     elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN, 0,
                                     true, false);
        }
d11928 55
@


1.147
log
@2012-03-14  Doug Kwan  <dougkwan@@google.com>

	* gold/arm.cc (Target_arm::Scan::global): Generate R_ARM_GLOB_DAT
	dynamic relocations for protected symbols in shared objects.
@
text
@d4177 11
d4192 1
a4192 1
				      this->got_, ORDER_DATA, false);
d4201 1
a4201 1
				      this->got_plt_, ORDER_DATA, false);
@


1.146
log
@2012-02-03  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relocate_functions::abs8,
	Arm_relocate_functions::abs16): Use
	Bits::has_signed_unsigned_overflow32.
	(Arm_relocate_functions::thm_abs8): Correct range of
	overflow check.
	* reloc.h (Bits class): Change minimum number of bits from 0 to 1
	in assertions.
@
text
@d8317 3
a8319 1
		|| gsym->is_preemptible())
@


1.145
log
@2012-02-02  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Reloc_stub::stub_type_for_reloc): Use PIC stubs in all
	position independent outputs, not just shared objects.
@
text
@d3186 1
a3186 2
    int signed_x = static_cast<int32_t>(x);
    return ((signed_x < -128 || signed_x > 255)
d3205 1
a3205 4

    // R_ARM_ABS16 permits signed or unsigned results.
    int signed_x = static_cast<int32_t>(x);
    return ((signed_x < -32768 || signed_x > 65535)
d3244 1
a3244 2
    int signed_x = static_cast<int32_t>(x);
    return ((signed_x < -32768 || signed_x > 65536)
@


1.144
log
@	* reloc.h (Bits): New class with static functions, copied from
	namespace utils in arm.cc.
	* arm.cc (namespace utils): Remove.  Rewrite all uses to use Bits
	instead.
@
text
@d4445 2
d4475 1
a4475 1
		  stub_type = (parameters->options().shared()
d4496 1
a4496 1
		  stub_type = (parameters->options().shared()
d4509 1
a4509 1
	      stub_type = (parameters->options().shared()
d4551 1
a4551 1
	      stub_type = (parameters->options().shared()
d4570 1
a4570 1
	      stub_type = (parameters->options().shared()
@


1.143
log
@2011-11-11  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_make_elf_object): Allow executable also
	if --just-symbols is given.
@
text
@d3 1
a3 1
// Copyright 2009, 2010, 2011 Free Software Foundation, Inc.
a2105 59
// Utilities for manipulating integers of up to 32-bits

namespace utils
{
  // Sign extend an n-bit unsigned integer stored in an uint32_t into
  // an int32_t.  NO_BITS must be between 1 to 32.
  template<int no_bits>
  static inline int32_t
  sign_extend(uint32_t bits)
  {
    gold_assert(no_bits >= 0 && no_bits <= 32);
    if (no_bits == 32)
      return static_cast<int32_t>(bits);
    uint32_t mask = (~((uint32_t) 0)) >> (32 - no_bits);
    bits &= mask;
    uint32_t top_bit = 1U << (no_bits - 1);
    int32_t as_signed = static_cast<int32_t>(bits);
    return (bits & top_bit) ? as_signed + (-top_bit * 2) : as_signed;
  }

  // Detects overflow of an NO_BITS integer stored in a uint32_t.
  template<int no_bits>
  static inline bool
  has_overflow(uint32_t bits)
  {
    gold_assert(no_bits >= 0 && no_bits <= 32);
    if (no_bits == 32)
      return false;
    int32_t max = (1 << (no_bits - 1)) - 1;
    int32_t min = -(1 << (no_bits - 1));
    int32_t as_signed = static_cast<int32_t>(bits);
    return as_signed > max || as_signed < min;
  }

  // Detects overflow of an NO_BITS integer stored in a uint32_t when it
  // fits in the given number of bits as either a signed or unsigned value.
  // For example, has_signed_unsigned_overflow<8> would check
  // -128 <= bits <= 255
  template<int no_bits>
  static inline bool
  has_signed_unsigned_overflow(uint32_t bits)
  {
    gold_assert(no_bits >= 2 && no_bits <= 32);
    if (no_bits == 32)
      return false;
    int32_t max = static_cast<int32_t>((1U << no_bits) - 1);
    int32_t min = -(1 << (no_bits - 1));
    int32_t as_signed = static_cast<int32_t>(bits);
    return as_signed > max || as_signed < min;
  }

  // Select bits from A and B using bits in MASK.  For each n in [0..31],
  // the n-th bit in the result is chosen from the n-th bits of A and B.
  // A zero selects A and a one selects B.
  static inline uint32_t
  bit_select(uint32_t a, uint32_t b, uint32_t mask)
  { return (a & ~mask) | (b & mask); }
};

d2959 1
a2959 1
    return utils::sign_extend<16>(((val >> 4) & 0xf000) | (val & 0xfff));
d2993 4
a2996 4
    return utils::sign_extend<16>(((val >> 4) & 0xf000)
				  | ((val >> 15) & 0x0800)
				  | ((val >> 4) & 0x0700)
				  | (val & 0x00ff));
d3104 2
a3105 2
    return utils::sign_extend<25>((s << 24) | (i1 << 23) | (i2 << 22)
				  | (upper << 12) | (lower << 1));
d3143 1
a3143 1
    return utils::sign_extend<21>((upper << 12) | (lower << 1));
d3180 1
a3180 1
    int32_t addend = utils::sign_extend<8>(val);
d3182 1
a3182 1
    val = utils::bit_select(val, x, 0xffU);
d3204 1
a3204 1
    val = utils::bit_select(val, x << 6, 0x7e0U);
d3226 1
a3226 1
    val = utils::bit_select(val, x, 0x0fffU);
d3228 1
a3228 1
    return (utils::has_overflow<12>(x)
d3242 1
a3242 1
    int32_t addend = utils::sign_extend<16>(val);
d3244 1
a3244 1
    val = utils::bit_select(val, x, 0xffffU);
d3321 1
a3321 1
    int32_t addend = utils::sign_extend<8>((val & 0x00ff) << 1);
d3326 1
a3326 1
    return (utils::has_overflow<9>(x)
d3341 1
a3341 1
    int32_t addend = utils::sign_extend<11>((val & 0x07ff) << 1);
d3346 1
a3346 1
    return (utils::has_overflow<12>(x)
d3399 1
a3399 1
    Valtype addend = utils::sign_extend<31>(val);
d3401 1
a3401 1
    val = utils::bit_select(val, x, 0x7fffffffU);
d3403 3
a3405 2
    return (utils::has_overflow<31>(x) ?
	    This::STATUS_OVERFLOW : This::STATUS_OKAY);
d3428 1
a3428 1
    return ((check_overflow && utils::has_overflow<16>(x))
d3476 1
a3476 1
    return ((check_overflow && utils::has_overflow<16>(x))
d3908 1
a3908 1
  Valtype addend = utils::sign_extend<26>(val << 2);
d3918 1
a3918 1
      && (utils::has_overflow<26>(branch_offset)
d3940 1
a3940 1
	  gold_assert(!utils::has_overflow<26>(branch_offset));
d3953 1
a3953 1
  val = utils::bit_select(val, (branch_offset >> 2), 0xffffffUL);
d3955 3
a3957 2
  return (utils::has_overflow<26>(branch_offset)
	  ? This::STATUS_OVERFLOW : This::STATUS_OKAY);
d4048 1
a4048 1
    branch_target = utils::bit_select(branch_target, address, 0x2);
d4056 2
a4057 2
      && ((!thumb2 && utils::has_overflow<23>(branch_offset))
	  || (thumb2 && utils::has_overflow<25>(branch_offset))
d4081 1
a4081 1
	    branch_target = utils::bit_select(branch_target, address, 0x2);
d4118 1
a4118 1
  gold_assert(!utils::has_overflow<25>(branch_offset));
d4121 2
a4122 2
	   ? utils::has_overflow<25>(branch_offset)
	   : utils::has_overflow<23>(branch_offset))
d4167 1
a4167 1
  return (utils::has_overflow<21>(branch_offset)
d4450 1
a4450 1
	destination = utils::bit_select(destination, location, 0x2);
d5223 1
a5223 1
  if (utils::has_overflow<31>(offset))
d6996 1
a6996 1
	return utils::sign_extend<26>(val << 2);
d11847 1
a11847 1
      gold_assert(!utils::has_overflow<25>(branch_offset));
@


1.142
log
@2011-11-10  Doug Kwan  <dougkwan@@google.com>

	PR gold/13362
	* arm.cc (Target_arm::Relocate::relocate_tls): Do unaligned accesses
	when processing data relocs.
	* reloc.h (Relocate_functions::rel_unaligned): New method.
	(Relocate_functions::pcrel_unaligned): Ditto.
	(Relocate_functions::rel32_unaligned): Ditto.
	(Relocate_functions::pcrel32_unaligned): Ditto.
@
text
@d10011 4
a10014 1
  if (et == elfcpp::ET_REL)
@


1.141
log
@2011-11-09  Doug Kwan  <dougkwan@@google.com>

	PR gold/13362
	* arm.cc (Arm_scan_relocatable_relocs::Default_scan_relocatable_relocs):
	Use unaligned 4-byte relocs for static 32-bit data as required by EABI.
	* reloc.h (Relocatable_relocs::Reloc_strategy): New enum
	RELOC_ADJUST_FOR_SECTION_4_UNALIGNED.
	(Relocate_functions::rel_unaligned): New.
	(Relocate_functions::rel32_unaligned): New.
	* target-reloc.h (relocate_for_relocatable): Add code to handle
	RELOC_ADJUST_FOR_SECTION_4_UNALIGNED.
	* testsuite/Makefile.am (arm_unaligned_reloc_r.stdout,
	arm_unaligned_reloc_r): New targets.
	* testsuite/Makefile.in: Regenerate.
	* arm_unaligned_reloc.sh: Check unaligned relocs in relocatable
	linking.
@
text
@d9351 1
a9351 1
	      RelocFuncs::pcrel32(view, got_entry, address);
d9370 1
a9370 1
          RelocFuncs::pcrel32(view, got_entry, address);
d9376 1
a9376 1
      RelocFuncs::rel32(view, value);
d9405 1
a9405 1
	  RelocFuncs::pcrel32(view, got_entry, address);
d9421 1
a9421 1
          RelocFuncs::rel32(view, value + aligned_tcb_size);
@


1.140
log
@	* arm.cc (Target_arm::may_use_v5t_interworking): Check whether
	we are working around the ARM1176 Erratum.
	* options.h (General_options::fix_arm1176): Add option.
	* testsuite/Makefile.am: Add testcases, and keep current ones
	working.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/arm_fix_1176.s: New file.
	* testsuite/arm_fix_1176.sh: Likewise.
@
text
@d2078 2
a2079 1
	  // Relocations that write full 32 bits.
d2097 1
a2097 1
	    return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_4;
@


1.139
log
@	* arm.cc (Target_arm::Target_arm): Remove initialisation of
	may_use_blx_.
	(Target_arm::may_use_blx): Remove method.
	(Target_arm::set_may_use_blx): Likewise.
	(Target_arm::may_use_v4t_interworking): New method.
	(Target_arm::may_use_v5t_interworking): Likewise.
	(Target_arm::may_use_blx_): Remove member variable.
	(Arm_relocate_functions::arm_branch_common): Check for v5T
	interworking.
	(Arm_relocate_functions::thumb_branch_common): Likewise.
	(Reloc_stub::stub_type_for_reloc): Likewise.
	(Target_arm::do_finalize_sections): Correct interworking checks.
	* testsuite/Makefile.am: Add new tests.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/arm_farcall_arm_arm.s: New test.
	* testsuite/arm_farcall_arm_arm.sh: Likewise.
	* testsuite/arm_farcall_arm_thumb.s: Likewise.
	* testsuite/arm_farcall_arm_thumb.sh: Likewise.
	* testsuite/arm_farcall_thumb_arm.s: Likewise.
	* testsuite/arm_farcall_thumb_arm.sh: Likewise.
	* testsuite/arm_farcall_thumb_thumb.s: Likewise.
	* testsuite/arm_farcall_thumb_thumb.sh: Likewise.
@
text
@d2265 10
a2274 3
    return (arch != elfcpp::TAG_CPU_ARCH_PRE_V4
	    && arch != elfcpp::TAG_CPU_ARCH_V4
	    && arch != elfcpp::TAG_CPU_ARCH_V4T);
@


1.138
log
@2011-07-05  Doug Kwan  <dougkwan@@google.com>

	PR gold/12771
	* arm.cc (Arm_relocate_functions::abs8): Use int32_t for addend and
	Arm_Address type for relocation result.
	(Arm_relocate_functions::abs16): Use unaligned access.  Also fix
	overflow check.
	(Arm_relocate_functions::abs32): Use unaligned access.
	(Arm_relocate_functions::rel32): Ditto.
	(Arm_relocate_functions::prel31): Ditto.
	(Arm_exidix_cantunwind::do_fixed_endian_write): Ditto.
	* testsuite/Makefile.am: Add new test arm_unaligned_reloc for unaligned
	static data relocations.
	* testsuite/Makefile.in: Regnerate.
	* testsuite/arm_unaligned_reloc.{s,sh}: New files.
@
text
@d2180 1
a2180 1
      may_use_blx_(false), should_force_pic_veneer_(false),
a2184 10
  // Whether we can use BLX.
  bool
  may_use_blx() const
  { return this->may_use_blx_; }

  // Set use-BLX flag.
  void
  set_may_use_blx(bool value)
  { this->may_use_blx_ = value; }
  
d2246 23
a2937 2
  // Whether we can use BLX.
  bool may_use_blx_;
d3964 1
a3964 1
  bool may_use_blx = arm_target->may_use_blx();
d4095 1
a4095 1
  bool may_use_blx = arm_target->may_use_blx();
d4478 1
a4478 1
      may_use_blx = big_endian_target->may_use_blx();
d4487 1
a4487 1
      may_use_blx = little_endian_target->may_use_blx();
a8617 1
  // Check BLX use.
a8619 3
  if (cpu_arch_attr->int_value() > elfcpp::TAG_CPU_ARCH_V4)
    this->set_may_use_blx(true);
 
d8640 1
a8640 1
      && !this->may_use_blx())
d11807 1
a11807 1
	      if (this->may_use_blx() && force_target_arm
@


1.138.2.1
log
@	Apply mainline patches.
	2011-11-02  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gold/arm.cc (Target_arm::may_use_v5t_interworking): Check whether
	we are working around the ARM1176 Erratum.
	* gold/options.h (General_options::fix_arm1176): Add option.
	* gold/testsuite/Makefile.am: Add testcases, and keep current ones
	working.
	* gold/testsuite/Makefile.in: Regenerate.
	* gold/testsuite/arm_fix_1176.s: New file.
	* gold/testsuite/arm_fix_1176.sh: Likewise.
	2011-11-02  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gold/arm.cc (Target_arm::Target_arm): Remove initialisation of
	may_use_blx_.
	(Target_arm::may_use_blx): Remove method.
	(Target_arm::set_may_use_blx): Likewise.
	(Target_arm::may_use_v4t_interworking): New method.
	(Target_arm::may_use_v5t_interworking): Likewise.
	(Target_arm::may_use_blx_): Remove member variable.
	(Arm_relocate_functions::arm_branch_common): Check for v5T
	interworking.
	(Arm_relocate_functions::thumb_branch_common): Likewise.
	(Reloc_stub::stub_type_for_reloc): Likewise.
	(Target_arm::do_finalize_sections): Correct interworking checks.
	* gold/testsuite/Makefile.am: Add new tests.
	* gold/testsuite/Makefile.in: Regenerate.
	* gold/testsuite/arm_farcall_arm_arm.s: New test.
	* gold/testsuite/arm_farcall_arm_arm.sh: Likewise.
	* gold/testsuite/arm_farcall_arm_thumb.s: Likewise.
	* gold/testsuite/arm_farcall_arm_thumb.sh: Likewise.
	* gold/testsuite/arm_farcall_thumb_arm.s: Likewise.
	* gold/testsuite/arm_farcall_thumb_arm.sh: Likewise.
	* gold/testsuite/arm_farcall_thumb_thumb.s: Likewise.
	* gold/testsuite/arm_farcall_thumb_thumb.sh: Likewise.
@
text
@d2180 1
a2180 1
      should_force_pic_veneer_(false),
d2185 10
a2255 30

  // Whether we have v4T interworking instructions available.
  bool
  may_use_v4t_interworking() const
  {
    Object_attribute* attr =
      this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);
    int arch = attr->int_value();
    return (arch != elfcpp::TAG_CPU_ARCH_PRE_V4
	    && arch != elfcpp::TAG_CPU_ARCH_V4);
  }
  
  // Whether we have v5T interworking instructions available.
  bool
  may_use_v5t_interworking() const
  {
    Object_attribute* attr =
      this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);
    int arch = attr->int_value();
    if (parameters->options().fix_arm1176())
      return (arch == elfcpp::TAG_CPU_ARCH_V6T2
	      || arch == elfcpp::TAG_CPU_ARCH_V7
	      || arch == elfcpp::TAG_CPU_ARCH_V6_M
	      || arch == elfcpp::TAG_CPU_ARCH_V6S_M
	      || arch == elfcpp::TAG_CPU_ARCH_V7E_M);
    else
      return (arch != elfcpp::TAG_CPU_ARCH_PRE_V4
	      && arch != elfcpp::TAG_CPU_ARCH_V4
	      && arch != elfcpp::TAG_CPU_ARCH_V4T);
  }
d2925 2
d3953 1
a3953 1
  bool may_use_blx = arm_target->may_use_v5t_interworking();
d4084 1
a4084 1
  bool may_use_blx = arm_target->may_use_v5t_interworking();
d4467 1
a4467 1
      may_use_blx = big_endian_target->may_use_v5t_interworking();
d4476 1
a4476 1
      may_use_blx = little_endian_target->may_use_v5t_interworking();
d8607 1
d8610 3
d8633 1
a8633 1
      && !this->may_use_v4t_interworking())
d11800 1
a11800 1
	      if (this->may_use_v5t_interworking() && force_target_arm
@


1.138.2.2
log
@Merge of
CVSROOT:	/cvs/src
Module name:	src
Changes by:	dougkwan@@sourceware.org	2011-11-10 00:41:53

Modified files:
	gold           : ChangeLog arm.cc reloc.h target-reloc.h
	gold/testsuite : Makefile.am Makefile.in arm_unaligned_reloc.sh

Log message:
	2011-11-09  Doug Kwan  <dougkwan@@google.com>

	PR gold/13362
	* arm.cc (Arm_scan_relocatable_relocs::Default_scan_relocatable_relocs):
	Use unaligned 4-byte relocs for static 32-bit data as required by EABI.
	* reloc.h (Relocatable_relocs::Reloc_strategy): New enum
	RELOC_ADJUST_FOR_SECTION_4_UNALIGNED.
	(Relocate_functions::rel_unaligned): New.
	(Relocate_functions::rel32_unaligned): New.
	* target-reloc.h (relocate_for_relocatable): Add code to handle
	RELOC_ADJUST_FOR_SECTION_4_UNALIGNED.
	* testsuite/Makefile.am (arm_unaligned_reloc_r.stdout,
	arm_unaligned_reloc_r): New targets.
	* testsuite/Makefile.in: Regenerate.
	* arm_unaligned_reloc.sh: Check unaligned relocs in relocatable
	linking.
@
text
@d2078 1
a2078 2
	  // Relocations that write full 32 bits and
          // have alignment of 1.
d2096 1
a2096 1
	    return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_4_UNALIGNED;
@


1.138.2.3
log
@Merge of:
CVSROOT:	/cvs/src
Module name:	src
Changes by:	dougkwan@@sourceware.org	2011-11-10 20:53:36

Modified files:
	gold           : ChangeLog arm.cc reloc.h

Log message:
	2011-11-10  Doug Kwan  <dougkwan@@google.com>

	PR gold/13362
	* arm.cc (Target_arm::Relocate::relocate_tls): Do unaligned accesses
	when processing data relocs.
	* reloc.h (Relocate_functions::rel_unaligned): New method.
	(Relocate_functions::pcrel_unaligned): Ditto.
	(Relocate_functions::rel32_unaligned): Ditto.
	(Relocate_functions::pcrel32_unaligned): Ditto.
@
text
@d9351 1
a9351 1
	      RelocFuncs::pcrel32_unaligned(view, got_entry, address);
d9370 1
a9370 1
          RelocFuncs::pcrel32_unaligned(view, got_entry, address);
d9376 1
a9376 1
      RelocFuncs::rel32_unaligned(view, value);
d9405 1
a9405 1
	  RelocFuncs::pcrel32_unaligned(view, got_entry, address);
d9421 1
a9421 1
          RelocFuncs::rel32_unaligned(view, value + aligned_tcb_size);
@


1.138.2.4
log
@Merge of:
CVSROOT:	/cvs/src
Module name:	src
Changes by:	dougkwan@@sourceware.org	2011-11-11 21:49:36

Modified files:
	gold           : ChangeLog arm.cc

Log message:
	2011-11-11  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_make_elf_object): Allow executable also
	if --just-symbols is given.
@
text
@d10011 1
a10011 4
  // ET_EXEC files are valid input for --just-symbols/-R,
  // and we treat them as relocatable objects.
  if (et == elfcpp::ET_REL
      || (et == elfcpp::ET_EXEC && input_file->just_symbols()))
@


1.138.2.5
log
@2012-04-27  Doug Kwan  <dougkwan@@google.com>

	Backport from mainline:

	2012-03-16  Doug Kwan  <dougkwan@@google.com>

		* testsuite/Makefile.am: Disable test initpri3b.
		* testsuite/Makefile.in: Regenerate.

	2012-03-14  Doug Kwan  <dougkwan@@google.com>

		* gold/arm.cc (Target_arm::Scan::global): Generate
		 R_ARM_GLOB_DAT dynamic relocations for protected symbols in
		shared objects.
@
text
@d8377 1
a8377 3
		|| gsym->is_preemptible()
		|| (gsym->visibility() == elfcpp::STV_PROTECTED
		    && parameters->options().shared()))
@


1.137
log
@	PR gold/12934
	* target-select.cc (Target_selector::Target_selector): Add
	emulation parameter.  Change all callers.
	(select_target_by_bfd_name): Rename from select_target_by_name.
	Change all callers.
	(select_target_by_emulation): New function.
	(supported_emulation_names): New function.
	* target-select.h (class Target_selector): Add emulation_ field.
	Update declarations.
	(Target_selector::recognize_by_bfd_name): Rename from
	recognize_by_name.  Change all callers.
	(Target_selector::supported_bfd_names): Rename from
	supported_names.  Change all callers.
	(Target_selector::recognize_by_emulation): New function.
	(Target_selector::supported_emulations): New function.
	(Target_selector::emulation): New function.
	(Target_selector::do_recognize_by_bfd_name): Rename from
	do_recognize_by_name.  Change all callers.
	(Target_selector::do_supported_bfd_names): Rename from
	do_supported_names.  Change all callers.
	(Target_selector::do_recognize_by_emulation): New function.
	(Target_selector::do_supported_emulations): New function.
	(select_target_by_bfd_name): Change name in declaration.
	(select_target_by_emulation): Declare.
	(supported_emulation_names): Declare.
	* parameters.cc (parameters_force_valid_target): Try to find
	target based on emulation from -m option.
	* options.h (class General_options): Change doc string for -m.
	* options.cc (help): Print emulations.
	(General_options::parse_V): Likewise.
	* freebsd.h (Target_selector_freebsd::Target_selector_freebsd):
	Add emulation parameter.  Change all callers.
@
text
@a3217 1
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
d3220 2
a3221 2
    Reltype addend = utils::sign_extend<8>(val);
    Reltype x = psymval->value(object, addend);
d3279 1
a3279 1
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
d3281 3
a3283 4
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<16, big_endian>::readval(wv);
    Reltype addend = utils::sign_extend<16>(val);
    Reltype x = psymval->value(object, addend);
d3285 5
a3289 2
    elfcpp::Swap<16, big_endian>::writeval(wv, val);
    return (utils::has_signed_unsigned_overflow<16>(x)
d3301 2
a3302 3
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype addend = elfcpp::Swap<32, big_endian>::readval(wv);
d3304 1
a3304 1
    elfcpp::Swap<32, big_endian>::writeval(wv, x);
d3316 2
a3317 3
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype addend = elfcpp::Swap<32, big_endian>::readval(wv);
d3319 1
a3319 1
    elfcpp::Swap<32, big_endian>::writeval(wv, x);
d3437 2
a3438 3
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
d3442 1
a3442 1
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
d5222 1
a5222 2
  typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
  Valtype* wv = reinterpret_cast<Valtype*>(oview);
d5263 4
a5266 2
  elfcpp::Swap<32, big_endian>::writeval(wv, prel31_offset & 0x7fffffffU);
  elfcpp::Swap<32, big_endian>::writeval(wv + 1, elfcpp::EXIDX_CANTUNWIND);
@


1.136
log
@	* target.h (Target::can_check_for_function_pointers): Rewrite.
	Make non-virtual.
	(Target::can_icf_inline_merge_sections): Likewise.
	(Target::section_may_have_icf_unsafe_poineters): Likewise.
	(Target::Target_info): Add can_icf_inline_merge_sections field.
	(Target::do_can_check_for_function_pointers): New virtual
	function.
	(Target::do_section_may_have_icf_unsafe_pointers): Likewise.
	* arm.cc (Target_arm::do_can_check_for_function_pointers): Rename
	from can_check_for_function_pointers, move in file.
	(Target_arm::do_section_may_have_icf_unsafe_pointers): Rename from
	section_may_have_icf_unsafe_poineters, move in file.
	(Target_arm::arm_info): Initialize can_icf_inline_merge_sections.
	* i386.cc (Target_i386::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_i386::can_icf_inline_merge_sections): Remove.
	(Target_i386::i386_info): Initialize
	can_icf_inline_merge_sections.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Initialize can_icf_inline_merge_sections.
	* sparc.cc (Target_sparc::sparc_info) [both version]: Likewise.
	* x86_64.cc (Target_x86_64::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_x86_64::can_icf_inline_merge_sections): Remove.
	(Target_x86_64::x86_64_info): Initialize
	can_icf_inline_merge_sections.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Likewise.
	* icf.cc (get_section_contents): Correct formatting.
@
text
@d11907 2
a11908 1
		      (big_endian ? "elf32-bigarm" : "elf32-littlearm"))
@


1.135
log
@2011-06-27  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relocate_functions::thm_jump8,
	Arm_relocate_functions::thm_jump11): Use a wider signed
	type to compute offset.
	* testsuite/Makefile.am: Add new tests arm_thm_jump11 and
	arm_thm_jump8.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/arm_branch_in_range.sh: Check test results of
	arm_thm_jump11 and arm_thm_jump8.
	* testsuite/arm_thm_jump11.s: New test source file.
	* testsuite/arm_thm_jump11.t: New linker script.
	* testsuite/arm_thm_jump8.s: New test source file.
	* testsuite/arm_thm_jump8.t: New linker script.
@
text
@d3 1
a3 1
// Copyright 2009, 2010 Free Software Foundation, Inc.
a2184 17
  // Virtual function which is set to return true by a target if
  // it can use relocation types to determine if a function's
  // pointer is taken.
  virtual bool
  can_check_for_function_pointers() const
  { return true; }

  // Whether a section called SECTION_NAME may have function pointers to
  // sections not eligible for safe ICF folding.
  virtual bool
  section_may_have_icf_unsafe_pointers(const char* section_name) const
  {
    return (!is_prefix_of(".ARM.exidx", section_name)
	    && !is_prefix_of(".ARM.extab", section_name)
	    && Target::section_may_have_icf_unsafe_pointers(section_name));
  }
  
d2539 17
d2949 1
@


1.134
log
@2011-06-24  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_output_section::append_text_sections_to_list): Do not
	skip empty text sections.
	* testsuite/arm_exidx_test.s: Test handling of an empty text section.
@
text
@a3358 1
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Reltype;
d3361 6
a3366 4
    Reltype addend = utils::sign_extend<8>((val & 0x00ff) << 1);
    Reltype x = (psymval->value(object, addend) - address);
    elfcpp::Swap<16, big_endian>::writeval(wv, (val & 0xff00) | ((x & 0x01fe) >> 1));
    return (utils::has_overflow<8>(x)
a3378 1
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Reltype;
d3381 6
a3386 4
    Reltype addend = utils::sign_extend<11>((val & 0x07ff) << 1);
    Reltype x = (psymval->value(object, addend) - address);
    elfcpp::Swap<16, big_endian>::writeval(wv, (val & 0xf800) | ((x & 0x0ffe) >> 1));
    return (utils::has_overflow<11>(x)
@


1.133
log
@2011-05-31  Doug Kwan  <dougkwan@@google.com>
            Asier Llano

	PR gold/12826
	* arm.cc (Target_arm::tag_cpu_arch_combine): Fix handling of
	arch value that equals to elfcpp::MAX_TAG_CPU_ARCH.
	* testsuite/Makefile.am: (MOSTLYCLEANFILES): Clean up.  Remove
	redundant arm_exidx_test.so.
	* testsuite/Makefile.in: Regenerate.
	(check_SCRIPTS): Add pr12826.sh
	(check_DATA): Add pr12826.stdout
	(pr12826.stdout, pr12826.so, pr12826_1.o, pr12826_2.o): New rules.
	* testsuite/pr12826.sh: New file.
	* testsuite/pr12826_1.s: Ditto.
	* testsuite/pr12826_1.s: Ditto.
@
text
@d5806 1
a5806 2
      if ((p->is_input_section() || p->is_relaxed_input_section())
	  && p->data_size() != 0)
@


1.132
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d10205 1
a10205 1
  if (oldtag >= elfcpp::MAX_TAG_CPU_ARCH || newtag >= elfcpp::MAX_TAG_CPU_ARCH)
@


1.131
log
@2011-04-22  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_output_section::Arm_output_section): Set SHF_LINK_ORDER
	flag of a SHT_ARM_EXIDX section.
        * testsuite/Makefile.am (arm_exidx_test): New test rules.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/arm_exidx_test.s: New file.
	* testsuite/arm_exidx_test.sh: Same.
@
text
@d1482 1
a1482 1
class Arm_relobj : public Sized_relobj<32, big_endian>
d1489 1
a1489 1
    : Sized_relobj<32, big_endian>(name, input_file, offset, ehdr),
d1660 1
a1660 1
    Sized_relobj<32, big_endian>::do_setup();
d1673 4
a1676 3
  do_relocate_sections(const Symbol_table* symtab, const Layout* layout,
		       const unsigned char* pshdrs, Output_file* of,
		       typename Sized_relobj<32, big_endian>::Views* pivews);
d1916 2
a1917 1
		   Sized_relobj<32, big_endian>* relobj, unsigned int index)
d1934 1
a1934 1
				 Sized_relobj<32, big_endian>* object,
d1953 1
a1953 1
	  Sized_relobj<32, big_endian>* relobj, unsigned int index)
d1984 1
a1984 1
    Sized_relobj<32, big_endian>*
d2017 1
a2017 1
	Sized_relobj<32, big_endian>* relobj;
d2279 1
a2279 1
		    Sized_relobj<32, big_endian>* object,
d2293 1
a2293 1
	      Sized_relobj<32, big_endian>* object,
d2329 1
a2329 1
			  Sized_relobj<32, big_endian>* object,
d2570 1
a2570 1
	  Sized_relobj<32, big_endian>* object,
d2578 1
a2578 1
	   Sized_relobj<32, big_endian>* object,
d2586 1
a2586 1
  	          			Sized_relobj<32, big_endian>* ,
d2595 1
a2595 1
  	           			 Sized_relobj<32, big_endian>* ,
d2603 1
a2603 1
    unsupported_reloc_local(Sized_relobj<32, big_endian>*,
d2607 1
a2607 1
    unsupported_reloc_global(Sized_relobj<32, big_endian>*,
d2749 1
a2749 1
		      Sized_relobj<32, big_endian>* object);
d2780 1
a2780 1
	     Sized_relobj<32, big_endian>* object,
d3213 1
a3213 1
       const Sized_relobj<32, big_endian>* object,
d3235 1
a3235 1
       const Sized_relobj<32, big_endian>* object,
d3257 1
a3257 1
	const Sized_relobj<32, big_endian>* object,
d3276 1
a3276 1
	const Sized_relobj<32, big_endian>* object,
d3295 1
a3295 1
	const Sized_relobj<32, big_endian>* object,
d3310 1
a3310 1
	const Sized_relobj<32, big_endian>* object,
d3332 1
a3332 1
	    const Sized_relobj<32, big_endian>* object,
d3354 1
a3354 1
	    const Sized_relobj<32, big_endian>* object,
d3373 1
a3373 1
	    const Sized_relobj<32, big_endian>* object,
d3430 1
a3430 1
	 const Sized_relobj<32, big_endian>* object,
d3452 1
a3452 1
       const Sized_relobj<32, big_endian>* object,
d3476 1
a3476 1
       const Sized_relobj<32, big_endian>* object,
d3497 1
a3497 1
	   const Sized_relobj<32, big_endian>* object,
d3524 1
a3524 1
	   const Sized_relobj<32, big_endian>* object,
d3544 1
a3544 1
	    const Sized_relobj<32, big_endian>* object,
d3598 1
a3598 1
	  const Sized_relobj<32, big_endian>* object,
d3620 1
a3620 1
	   const Sized_relobj<32, big_endian>* object,
d3705 1
a3705 1
	const Sized_relobj<32, big_endian>* object,
d3762 1
a3762 1
	const Sized_relobj<32, big_endian>* object,
d3800 1
a3800 1
	const Sized_relobj<32, big_endian>* object,
d3838 1
a3838 1
      const Sized_relobj<32, big_endian>* object,
d6345 1
a6345 1
// Sized_relobj<size, big_endian>::do_count_local_symbols. 
d6357 1
a6357 1
  Sized_relobj<32, big_endian>::do_count_local_symbols(pool, dynpool);
d6405 1
a6405 1
  typename Sized_relobj<32, big_endian>::Local_values* plocal_values =
d6448 1
a6448 1
    typename Sized_relobj<32, big_endian>::Views* pviews)
d6451 2
a6452 2
  Sized_relobj<32, big_endian>::do_relocate_sections(symtab, layout, pshdrs,
						     of, pviews); 
d6688 1
a6688 1
  Sized_relobj<32, big_endian>::do_read_symbols(sd);
d6848 1
a6848 1
  Sized_relobj<32, big_endian>::do_gc_process_relocs(symtab, layout, rd);
d6913 1
a6913 1
  typedef typename Sized_relobj<32, big_endian>::Output_sections
d7094 1
a7094 1
  Sized_relobj<32, big_endian>* object,
d7143 1
a7143 1
	  Sized_relobj<32, big_endian>* object = reloc.relobj();
d7541 1
a7541 1
    Sized_relobj<32, big_endian>* object)
d7707 1
a7707 1
    Sized_relobj<32, big_endian>* object,
d7775 1
a7775 1
				    Sized_relobj<32, big_endian>* object,
d8079 1
a8079 1
    Sized_relobj<32, big_endian>* object,
d8121 1
a8121 1
  Sized_relobj<32, big_endian>*,
d8138 1
a8138 1
  Sized_relobj<32, big_endian>*,
d8160 1
a8160 1
				     Sized_relobj<32, big_endian>* object,
d8489 12
a8500 11
Target_arm<big_endian>::gc_process_relocs(Symbol_table* symtab,
					  Layout* layout,
					  Sized_relobj<32, big_endian>* object,
					  unsigned int data_shndx,
					  unsigned int,
					  const unsigned char* prelocs,
					  size_t reloc_count,
					  Output_section* output_section,
					  bool needs_special_offset_handling,
					  size_t local_symbol_count,
					  const unsigned char* plocal_symbols)
d8526 1
a8526 1
				    Sized_relobj<32, big_endian>* object,
d9301 1
a9301 1
  const Sized_relobj<32, big_endian>* object = relinfo->object;
d9507 1
a9507 1
    Sized_relobj<32, big_endian>* object,
d9983 3
a9985 3
// We need to use a target-specific sub-class of Sized_relobj<32, big_endian>
// to store ARM specific information.  Hence we need to have our own
// ELF object creation.
d11195 1
a11195 1
	      typedef Sized_relobj<32, big_endian> ObjType;
@


1.130
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d1345 1
d1348 4
a1351 1
    : Output_section(name, type, flags)
@


1.129
log
@2010-12-07  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::Scan::get_reference_flags): Treat R_ARM_PREL31
	like function call relocations.
@
text
@d119 1
a119 1
// returning a static instance of Arm_reloc_property_table, it will very
d601 2
a602 2
    // If r_sym_ is invalid index.  This points to a global symbol.
    // Otherwise, this points a relobj.  We used the unsized and target
d604 1
a604 1
    // Arm_relobj.  This is done to avoid making the stub class a template
d898 2
a899 2
  // Add a STUB with using KEY.  Caller is reponsible for avoid adding
  // if already a STUB with the same key has been added. 
d918 2
a919 2
  // Caller is reponsible for avoid adding if already a STUB with the same
  // address has been added. 
d1268 1
a1268 1
  // reponsible for releasing it.
d1707 1
a1707 1
  // first reloction of the EXIDX section.  PSHDR points to the section
d2026 1
a2026 1
// The ARM target has many relocation types with odd-sizes or incontigious
d2966 1
a2966 1
    STATUS_OVERFLOW,	// Relocation oveflow.
d3192 1
a3192 1
  // Caller is reponsible for overflow checking.
d4438 1
a4438 1
// bfd/elf32-arm.c.  We have changed the interface a liitle to keep the Stub
d4842 1
a4842 1
// Removel all Cortex-A8 stub.
d5528 1
a5528 1
      // in the map.  If y1 is not -1, then y0 = y1 + x0 - x1.  Othewise, y1
d5690 1
a5690 1
      // Check to see if we should group the previously seens sections.
d6338 1
a6338 1
// slow down other ports by calling a per symbol targer hook inside
d6356 1
a6356 1
  // Intialize the thumb function bit-vector.
d6531 1
a6531 1
// Find the linked text section of an EXIDX section by looking the the first
d6533 1
a6533 1
// must be linked to to its associated code section via the sh_link field of
d6666 1
a6666 1
    // I would like to make this an error but currenlty ld just ignores
d6830 1
a6830 1
// text sections linked in the section headers.  If we ignore these implict
d8315 1
a8315 1
      // call the personality routine and the dyanmic linkers we care about
d8649 1
a8649 1
          // Create __exidx_start and __exdix_end symbols.
d9876 1
a9876 1
      // This can be any reloc type but ususally is R_ARM_GOT_PREL
d10460 1
a10460 1
	      // This error message should be enabled once all non-conformant
d10637 1
a10637 1
	  // Aready done.
d11342 1
a11342 1
// We goup input sections in an output sections so that the total size,
d11347 1
a11347 1
// after the last group.  If STUB_ALWATS_AFTER_BRANCH is false, we further
d11394 1
a11394 1
      // is passed a negative value, we restict stubs to be always after
d11660 1
a11660 1
  // and shift eveything between 4 .. Tag_conformance - 1 to make room.
d11862 1
a11862 1
      // For a conditional branch, we re-write it to be a uncondition
@


1.128
log
@gold/
	* symtab.h (Symbol::NON_PIC_REF): Remove.
	(Symbol::RELATIVE_REF, Symbol::TLS_REF): New Reference_flags.
	(Symbol::FUNCTION_CALL): Renumber.  Reword comment.
	(Symbol::needs_dynamic_reloc): Don't check NON_PIC_REF.
	(Symbol::use_plt_offset): Take a flags argument and pass it
	directly to needs_dynamic_reloc.  Restrict check for undefined
	weak symbols to function calls.
	* arm.cc (Target_arm::Scan::get_reference_flags): New function.
	(Target_arm::Scan::global): Use it.
	(Target_arm::Scan::scan_reloc_for_stub): Likewise.
	(Target_arm::Relocate::relocate): Likewise.
	(Target_arm::Relocate::should_apply_static_reloc): Replace flags
	parameter with an r_type parameter.  Use get_reference_flags
	to get the flags.
	(Target_arm::Relocate::relocate): Update accordingly.
	* i386.cc (Target_i386::Scan::get_reference_flags): New function.
	(Target_i386::Scan::reloc_needs_plt_for_ifunc): Use it.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocate::should_apply_static_reloc): Replace flags
	parameter with an r_type parameter.  Use get_reference_flags
	to get the flags.
	(Target_i386::Relocate::relocate): Update accordingly.
	* powerpc.cc (Target_powerpc::Scan::get_reference_flags): New function.
	(Target_powerpc::Scan::global): Use it.
	(Target_powerpc::Scan::scan_reloc_for_stub): Likewise.
	(Target_powerpc::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Scan::get_reference_flags): New function.
	(Target_sparc::Scan::global): Use it.
	(Target_sparc::Scan::scan_reloc_for_stub): Likewise.
	(Target_sparc::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Scan::get_reference_flags): New function.
	(Target_x86_64::Scan::reloc_needs_plt_for_ifunc): Use it.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
@
text
@a7648 1
    case elfcpp::R_ARM_PREL31:
d7661 4
@


1.127
log
@2010-11-08  Doug Kwan  <dougkwan@@google.com>
	    Cary Coutant  <ccoutant@@google.com>

	* arm.cc (Arm_exidx_merge_section::build_contents): New method.
	(Arm_exidx_merge_section::section_contents_): New data member.
	(Arm_input_section::Arm_input_section): Initialize original_contents_.
	(Arm_input_section::~Arm_input_section): De-allocate memory.
	(Arm_input_section::original_contents_): New data member.
	(Arm_exidx_fixup::process_exidx_section): Pass EXIDX section contents
	in parameters instead of calling Object::section_contents without
	locking.
	(Arm_output_section::group_section): New parameter TASK.  Pass it
	to callees that need locking objects.
	(Arm_output_section::fix_exidx_coverage): New parameter TASK.  Use it
	to lock EXIDX input sections.  Fix a formatting issue.  Call
	Arm_exidx_merged_section::build_contents to create merged section
	contents.
	(Arm_output_section::create_stub_group): New parameter TASK.  Use it
	to lock object of stub table owner.
	(Arm_exidx_input_section::Arm_exidx_input_section): Add new parameter
	TEXT_SIZE to initialize data member TEXT_SIZE_.
	(Arm_exidx_input_section::addralign): Fix typo in comment.
	(Arm_exidx_input_section::text_size): New method.
	(Target_arm::do_relax): New parameter TASK.  Pass it to callees
	that require locking objects.  Lock objects before scanning for stubs
	and updating local symbols.
	(Arm_input_section<big_endian>::init): Copy contents of original
	input section.
 	(Arm_input_section<big_endian>::do_write): Use saved contents of
	original input section instead of calling Object::section_contents
	without locking.
	(Arm_exidx_cantunwind::do_fixed_endian_write): Find out text section
	size without calling Object::section_size().
	(Arm_exidx_merged_section::Arm_exidx_merged_section): Add sanity check
	for size.  Allocate a buffer for merged EXIDX entries.
	(Arm_exidx_merged_section::build_contents): New method.
 	(Arm_exidx_merged_section::do_write): Move merge section contents
	building code to Arm_exidx_merged_section::build_contetns.  Write
	out contetns in buffer instead of building it on the fly.
	(Arm_relobj::make_exidx_input_section): Also pass text section size
	to Arm_exidx_input_section constructor.
	(Arm_relobj::do_read_symbols): Fix memory leak.  Fix a formatting issue.
	(Arm_dynobj::do_read_symbols): Fix memory leak.
	* layout.cc (Layout::finalize): Pass TASK to Target::relax().
	* target.h: (class Task): Add forward declaration.
	(Target::relax): Add new parameter TASK and pass it to
	Target::do_relax().
	(Target::do_relax):: New parameter TASK.  Fix a formatting issue.
@
text
@d2559 3
d2644 1
a2644 1
			      int ref_flags,
d7574 119
d8199 1
a8199 1
        if (gsym->needs_dynamic_reloc(Symbol::ABSOLUTE_REF))
d8280 1
a8280 2
	int flags = Symbol::NON_PIC_REF;
	if (gsym->needs_dynamic_reloc(flags))
d8720 1
a8720 1
    int ref_flags,
d8730 2
d8837 1
a8837 1
	  if (gsym->use_plt_offset(reloc_is_non_pic(r_type)))
d8961 1
a8961 2
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
d8966 1
a8966 2
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
d8971 1
a8971 2
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
d8976 1
a8976 2
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
				    output_section))
d8982 1
a8982 2
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
				    output_section))
d8989 1
a8989 2
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
d8996 1
a8996 2
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
d9001 1
a9001 2
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
d9007 1
a9007 2
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
d9050 1
a9050 2
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
d9080 1
a9080 5
      {
	if (!should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				      output_section))
	  break;

a9081 1
      }
d10935 1
a10935 1
      if (gsym->use_plt_offset(Relocate::reloc_is_non_pic(r_type)))
@


1.126
log
@2010-10-29  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_outout_section::fix_exidx_coverage): Adjust call to
	Output_section::add_relaxed_input_section.
	* output.cc (Output_section::add_relaxed_input_section): Add new
	arguments LAYOUT and NAME.  Set section order index.
	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Copy section order index.
	* output.h (Output_section::add_relaxed_input_section): Add new
	arguments LAYOUT and NAME.
@
text
@d1107 4
d1135 4
d1149 2
a1150 1
      original_addralign_(1), original_size_(0), stub_table_(NULL)
d1154 1
a1154 1
  { }
d1240 4
d1263 6
a1268 5
  // Process an EXIDX section for entry merging.  Return  number of bytes to
  // be deleted in output.  If parts of the input EXIDX section are merged
  // a heap allocated Arm_exidx_section_offset_map is store in the located
  // PSECTION_OFFSET_MAP.  The caller owns the map and is reponsible for
  // releasing it.
d1272 2
d1358 1
a1358 1
  group_sections(section_size_type, bool, Target_arm<big_endian>*);
d1377 2
a1378 1
		     bool merge_exidx_entries);
d1394 2
a1395 1
			 std::vector<Output_relaxed_input_section*>*);
d1407 2
a1408 1
			  unsigned int link, uint32_t size, uint32_t addralign)
d1410 1
a1410 1
      addralign_(addralign), has_errors_(false)
d1438 1
a1438 1
  // Reutnr address alignment of EXIDX input section.
d1443 5
d1469 2
d2528 1
a2528 1
  do_relax(int, const Input_objects*, Symbol_table*, Layout*);
d2831 1
a2831 1
  group_sections(Layout*, section_size_type, bool);
d2856 2
a2857 1
		     Arm_output_section<big_endian>*, Symbol_table*);
d5116 2
a5117 2
  // Cache these to speed up size and alignment queries.  It is too slow
  // to call section_addraglin and section_size every time.
d5120 6
d5129 4
d5150 3
a5152 4
  section_size_type section_size;
  const unsigned char* section_contents =
    this->relobj()->section_contents(this->shndx(), &section_size, false); 
  of->write(this->offset(), section_contents, section_size); 
d5223 3
d5227 8
a5234 1
    section_start = os->address() + output_offset;
d5242 1
d5246 1
a5246 2
  Arm_address output_address =
    section_start + this->relobj_->section_size(this->shndx_);
d5278 5
d5284 2
a5285 1
  this->set_data_size(exidx_input_section.size() - deleted_bytes);
d5287 44
a5388 5
  // If we retain or discard the whole EXIDX input section,  we would
  // not be here.
  gold_assert(this->data_size() != this->exidx_input_section_.size()
	      && this->data_size() != 0);

d5396 1
a5396 32
  // Get contents of EXIDX input section.
  section_size_type section_size;
  const unsigned char* section_contents =
    this->relobj()->section_contents(this->shndx(), &section_size, false); 
  gold_assert(section_size == this->exidx_input_section_.size());

  // Go over spans of input offsets and write only those that are not
  // discarded.
  section_offset_type in_start = 0;
  section_offset_type out_start = 0;
  for(Arm_exidx_section_offset_map::const_iterator p =
        this->section_offset_map_.begin();
      p != this->section_offset_map_.end();
      ++p)
    {
      section_offset_type in_end = p->first;
      gold_assert(in_end >= in_start);
      section_offset_type out_end = p->second;
      size_t in_chunk_size = convert_types<size_t>(in_end - in_start + 1);
      if (out_end != -1)
	{
	  size_t out_chunk_size =
	    convert_types<size_t>(out_end - out_start + 1);
	  gold_assert(out_chunk_size == in_chunk_size);
	  memcpy(oview + out_start, section_contents + in_start,
		 out_chunk_size);
	  out_start += out_chunk_size;
	}
      in_start += in_chunk_size;
    }

  gold_assert(convert_to_section_size_type(out_start) == oview_size);
d5477 5
a5481 3
// bytes deleted.  If some entries are merged, also store a pointer to a newly
// created Arm_exidx_section_offset_map object in *PSECTION_OFFSET_MAP.  The
// caller owns the map and is responsible for releasing it after use.
d5487 2
a5492 3
  section_size_type section_size;
  const unsigned char* section_contents =
    relobj->section_contents(shndx, &section_size, false);
d5572 2
a5573 1
  std::vector<Output_relaxed_input_section*>* new_relaxed_sections)
d5596 3
a5598 1
      // Create a new relaxed input section.
d5643 2
a5644 1
    Target_arm<big_endian>* target)
d5701 2
a5702 1
					  target, &new_relaxed_sections);
d5724 1
a5724 1
				     target, &new_relaxed_sections);
d5734 2
a5735 1
      // a new one.  Skip any empty sections.
d5737 1
a5737 1
	  && (p->relobj()->section_size(p->shndx()) != 0))
d5762 1
a5762 1
			       target, &new_relaxed_sections);
d5810 2
a5811 1
    bool merge_exidx_entries)
d5894 7
d5905 2
d5924 1
d5928 2
d6624 2
a6625 1
				shdr.get_sh_addralign());
d6731 2
a6732 2
	  File_view* view = this->get_lasting_view(section_offset,
						   section_size, true, false);
d6734 1
a6734 1
	    new Attributes_section_data(view->data(), section_size);
d6809 1
a6809 1
      for(unsigned int i = 0; i < deferred_exidx_sections.size(); ++i)
d6993 2
a6994 2
	  File_view* view = this->get_lasting_view(section_offset,
						   section_size, true, false);
d6996 1
a6996 1
	    new Attributes_section_data(view->data(), section_size);
d11244 2
a11245 1
    bool stubs_always_after_branch)
d11257 1
a11257 1
				     this);
d11269 2
a11270 1
    Layout* layout)
d11319 1
a11319 1
      group_sections(layout, stub_group_size, stubs_always_after_branch);
d11343 1
a11343 1
				   symtab);
d11392 3
d11425 1
a11425 1
  for(Layout::Section_list::const_iterator p = layout->section_list().begin();
d11457 5
a11461 1
	    arm_relobj->update_output_local_symbol_count();
d11803 2
a11804 1
    Symbol_table* symtab)
d11845 1
a11845 1
  for(typename Sorted_output_section_list::iterator p =
d11856 1
a11856 1
				    merge_exidx_entries());
@


1.125
log
@2010-10-20  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::do_read_symbols): Warn about ARM EXIDX sections
	without SHF_LINK_ORDER flags.
	* layout.cc (Layout::choose_output_section): Do not filter
	SHF_LINK_ORDER flag in a relocatable link.
@
text
@d5850 2
a5851 1
	  this->add_relaxed_input_section(merged_section);
@


1.124
log
@2010-10-17  Doug Kwan  <dougkwan@@google.com>

	* gold/arm.cc (Target_arm::got_section): Use correct order and set
	GOT output section to be writable.
@
text
@d6665 4
@


1.123
log
@	* arm.cc (Target_arm::Scan::local): Report the unsupported reloc
	error for the deprecated relocations.
	(Target_arm::Scan::global): Likewise.
	(Target_arm::Relocate::relocate): Likewise.
@
text
@d4186 2
a4187 3
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_WRITE),
				      this->got_, ORDER_RELRO, true);
d4195 1
a4195 2
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_WRITE),
@


1.122
log
@2010-09-17  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::Relocate::relocate): Ignore symbol type and
	defintion if relocation uses GOT entries of the symbol.
	* testsuite/icf_safe_test.sh: Fix test.
	* testsuite/icf_safe_so_test.sh: Fix test.
@
text
@a7635 1
    case elfcpp::R_ARM_PC24:
a7645 3
    case elfcpp::R_ARM_LDR_SBREL_11_0_NC:
    case elfcpp::R_ARM_ALU_SBREL_19_12_NC:
    case elfcpp::R_ARM_ALU_SBREL_27_20_CK:
d7849 4
a8030 3
    case elfcpp::R_ARM_LDR_SBREL_11_0_NC:
    case elfcpp::R_ARM_ALU_SBREL_19_12_NC:
    case elfcpp::R_ARM_ALU_SBREL_27_20_CK:
a8092 1
    case elfcpp::R_ARM_PC24:
d8261 4
d9043 5
d9049 3
a9051 1
      gold_unreachable();
@


1.121
log
@2010-09-08  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_exidx_cantunwind::do_print_to_mapfile): New method.
	(Arm_relobj::do_relocate_sections): Add new parameter for output
	file to match the parent.
	(Target_arm::scan_reloc_section_for_stubs): Use would-be final values
	of local symbols instead of input values.  Update code to track
	changes in gold::relocate_section.
	* object.cc (Sized_relobj::compute_final_local_value): New methods.
	(Sized_relobj::compute_final_local_value_internal): New methods.
	(Sized_relobj::do_finalize_local_symbols): Move code from loop
	body into private version of Sized_relobj::compute_final_local_value.
	Call the inline method.
	* object.h (Symbol_value::Symbol_value): Define destructor.  Free
	merged symbol value if there is one.
	(Symbol_value::has_output_value): New method defintiion.
	(Sized_relobj::Compute_final_local_value_status): New enum type.
	(Sized_relobj::compute_final_local_value): New methods.
	(Sized_relobj::compute_final_local_value_internal): New methods.
	* Makefile.am (check_SCRIPTS): Add arm_branch_out_of_range.sh
	and arm_cortex_a8.sh.
	(thumb_bl_out_of_range_local, arm_cortex_a8_b_cond, arm_cortex_a8_bl,
	arm_cortex_a8_blx, arm_cortex_a8_local, arm_corte_a8_local_reloc):
	New tests.
	* Makefile.in: Regenerate.
	* testsuite/arm_bl_out_of_range.s: Update test.
	* testsuite/thumb_bl_out_of_range.s: Ditto.
	* testsuite/thumb_blx_out_of_range.s: Ditto.
	* testsuite/arm_branch_out_of_range.sh: New file.
	* testsuite/arm_cortex_a8.sh: Ditto.
	* testsuite/arm_cortex_a8_b.s: Ditto.
	* testsuite/arm_cortex_a8_b_cond.s: Ditto.
	* testsuite/arm_cortex_a8_b_local.s: Ditto.
	* testsuite/arm_cortex_a8_bl.s: Ditto.
	* testsuite/arm_cortex_a8_blx.s: Ditto.
	* testsuite/arm_cortex_a8_local.s: Ditto.
	* testsuite/arm_cortex_a8_local_reloc.s: Ditto.
	* testsuite/thumb_bl_out_of_range_local.s: Ditto.
@
text
@d8585 40
a8624 1
  if (relnum != Target_arm<big_endian>::fake_relnum_for_stubs)
a8692 30
  // Get the GOT offset if needed.
  // The GOT pointer points to the end of the GOT section.
  // We need to subtract the size of the GOT section to get
  // the actual offset to use in the relocation.
  bool have_got_offset = false;
  unsigned int got_offset = 0;
  switch (r_type)
    {
    case elfcpp::R_ARM_GOT_BREL:
    case elfcpp::R_ARM_GOT_PREL:
      if (gsym != NULL)
	{
	  gold_assert(gsym->has_got_offset(GOT_TYPE_STANDARD));
	  got_offset = (gsym->got_offset(GOT_TYPE_STANDARD)
			- target->got_size());
	}
      else
	{
	  unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
	  gold_assert(object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD));
	  got_offset = (object->local_got_offset(r_sym, GOT_TYPE_STANDARD)
			- target->got_size());
	}
      have_got_offset = true;
      break;

    default:
      break;
    }

@


1.120
log
@2010-09-08  Rafael Espindola  <espindola@@google.com>

	* arm.cc (do_finalize_sections): Create the __exidx_start and
	__exdix_end symbols even when the section is missing.
@
text
@d1067 5
d1644 1
a1644 1
		       const unsigned char* pshdrs,
d6359 1
d6364 1
a6364 1
						     pviews); 
d10953 2
d10966 30
a10995 22
	  unsigned int shndx = psymval->input_shndx(&is_ordinary);
	  if (is_ordinary
	      && shndx != elfcpp::SHN_UNDEF
	      && !arm_object->is_section_included(shndx) 
              && !(relinfo->symtab->is_section_folded(arm_object, shndx)))
	    {
	      if (comdat_behavior == CB_UNDETERMINED)
	        {
	          std::string name =
		    arm_object->section_name(relinfo->data_shndx);
	          comdat_behavior = get_comdat_behavior(name.c_str());
	        }
	      if (comdat_behavior == CB_PRETEND)
	        {
                  bool found;
	          typename elfcpp::Elf_types<32>::Elf_Addr value =
	            arm_object->map_to_kept_section(shndx, &found);
	          if (found)
	            symval.set_output_value(value + psymval->input_value());
                  else
                    symval.set_output_value(0);
	        }
d10997 4
a11000 5
	        {
                  symval.set_output_value(0);
	        }
	      symval.set_no_output_symtab_entry();
	      psymval = &symval;
d11005 2
a11006 1
	  const Symbol* gsym = arm_object->global_symbol(r_sym);
d11012 1
a11012 1
	  if (sym->has_symtab_index())
d11029 1
d11031 4
a11034 1
	  symval.set_output_value(value);
d11036 40
@


1.119
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d8429 44
a8472 27
  if (exidx_section != NULL
      && exidx_section->type() == elfcpp::SHT_ARM_EXIDX
      && !parameters->options().relocatable())
    {
      // Create __exidx_start and __exdix_end symbols.
      symtab->define_in_output_data("__exidx_start", NULL,
				    Symbol_table::PREDEFINED,
				    exidx_section, 0, 0, elfcpp::STT_OBJECT,
				    elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN, 0,
				    false, true);
      symtab->define_in_output_data("__exidx_end", NULL,
				    Symbol_table::PREDEFINED,
				    exidx_section, 0, 0, elfcpp::STT_OBJECT,
				    elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN, 0,
				    true, true);

      // For the ARM target, we need to add a PT_ARM_EXIDX segment for
      // the .ARM.exidx section.
      if (!layout->script_options()->saw_phdrs_clause())
	{
	  gold_assert(layout->find_output_segment(elfcpp::PT_ARM_EXIDX, 0, 0)
		      == NULL);
	  Output_segment*  exidx_segment =
	    layout->make_output_segment(elfcpp::PT_ARM_EXIDX, elfcpp::PF_R);
	  exidx_segment->add_output_section_to_nonload(exidx_section,
						       elfcpp::PF_R);
	}
@


1.118
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_GOT_PLT.

gold/ChangeLog:

	* arm.cc (Target_arm::got_size): Add const.
	(Target_arm::got_entry_count): New function.
	(Target_arm::plt_entry_count): New function.
	(Target_arm::first_plt_entry_offset): New function.
	(Target_arm::plt_entry_size): New function.
	(Output_data_plt_arm::entry_count): New function.
	(Output_data_plt_arm::first_plt_entry_offset): New function.
	(Output_data_plt_arm::get_plt_entry_size): New function.
	* i386.cc (Target_i386::got_size): Add const.
	(Target_i386::got_entry_count): New function.
	(Target_i386::plt_entry_count): New function.
	(Target_i386::first_plt_entry_offset): New function.
	(Target_i386::plt_entry_size): New function.
	(Output_data_plt_i386::entry_count): New function.
	(Output_data_plt_i386::first_plt_entry_offset): New function.
	(Output_data_plt_i386::get_plt_entry_size): New function.
	* incremental-dump.cc (dump_incremental_inputs): Adjust call to
	find_incremental_inputs_sections.  Dump incremental_got_plt section.
	* incremental.cc: Include target.h.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Add
	parameter.  Adjust all callers.  Find incremental_got_plt section.
	(Incremental_inputs::create_data_sections): Create incremental_got_plt
	section.
	(Output_section_incremental_inputs::set_final_data_size): Calculate
	size of incremental_got_plt section.
	(Output_section_incremental_inputs::do_write): Write the
	incremental_got_plt section.
	(Got_plt_view_info): New struct.
	(Local_got_offset_visitor): New class.
	(Global_got_offset_visitor): New class.
	(Global_symbol_visitor_got_plt): New class.
	(Output_section_incremental_inputs::write_got_plt): New function.
	* incremental.h (Incremental_binary::find_incremental_inputs_sections):
	Add parameter.  Adjust all callers.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Incremental_inputs::got_plt_section): New function.
	(Incremental_inputs::got_plt_section_): New data member.
	(Incremental_got_plt_reader): New class.
	* layout.cc (Layout::create_incremental_info_sections): Add the
	incremental_got_plt section.
	* object.h (Got_offset_list::get_list): New function.
	(Got offset_list::for_all_got_offsets): New function.
	(Sized_relobj::local_got_offset_list): New function.
	* powerpc.cc (Target_powerpc::got_size): Add const.
	(Target_powerpc::got_entry_count): New function.
	(Target_powerpc::plt_entry_count): New function.
	(Target_powerpc::first_plt_entry_offset): New function.
	(Target_powerpc::plt_entry_size): New function.
	(Output_data_plt_powerpc::entry_count): New function.
	(Output_data_plt_powerpc::first_plt_entry_offset): New function.
	(Output_data_plt_powerpc::get_plt_entry_size): New function.
	* sparc.cc (Target_sparc::got_size): Add const.
	(Target_sparc::got_entry_count): New function.
	(Target_sparc::plt_entry_count): New function.
	(Target_sparc::first_plt_entry_offset): New function.
	(Target_sparc::plt_entry_size): New function.
	(Output_data_plt_sparc::entry_count): New function.
	(Output_data_plt_sparc::first_plt_entry_offset): New function.
	(Output_data_plt_sparc::get_plt_entry_size): New function.
	* symtab.h (Symbol::got_offset_list): New function.
	(Symbol_table::for_all_symbols): New function.
	* target.h (Sized_target::got_entry_count): New function.
	(Sized_target::plt_entry_count): New function.
	(Sized_target::plt_entry_size): New function.
	* x86_64.cc (Target_x86_64::got_size): Add const.
	(Target_x86_64::got_entry_count): New function.
	(Target_x86_64::plt_entry_count): New function.
	(Target_x86_64::first_plt_entry_offset): New function.
	(Target_x86_64::plt_entry_size): New function.
	(Output_data_plt_x86_64::entry_count): New function.
	(Output_data_plt_x86_64::first_plt_entry_offset): New function.
	(Output_data_plt_x86_64::get_plt_entry_size): New function.
@
text
@d129 1
a129 1
Arm_reloc_property_table *arm_reloc_property_table = NULL;
d1656 1
a1656 1
				    const Symbol_table *, const unsigned char*);
d1661 1
a1661 1
		       const Output_section*, const Symbol_table *);
d1667 1
a1667 1
					const Symbol_table *);
d2374 1
a2374 1
  get_real_reloc_type (unsigned int r_type);
d2629 1
a2629 1
    reloc_is_non_pic (unsigned int r_type)
d3076 1
a3076 1
		    unsigned char *, const Sized_symbol<32>*,
d3083 1
a3083 1
		      unsigned char *, const Sized_symbol<32>*,
d3171 1
a3171 1
  abs8(unsigned char *view,
d3193 1
a3193 1
  thm_abs5(unsigned char *view,
d3215 1
a3215 1
  abs12(unsigned char *view,
d3234 1
a3234 1
  abs16(unsigned char *view,
d3253 1
a3253 1
  abs32(unsigned char *view,
d3268 1
a3268 1
  rel32(unsigned char *view,
d3284 1
a3284 1
  thm_jump19(unsigned char *view, const Arm_relobj<big_endian>* object,
d3290 1
a3290 1
  thm_jump6(unsigned char *view,
d3312 1
a3312 1
  thm_jump8(unsigned char *view,
d3331 1
a3331 1
  thm_jump11(unsigned char *view,
d3378 1
a3378 1
  got_prel(unsigned char *view,
d3388 1
a3388 1
  prel31(unsigned char *view,
d3455 1
a3455 1
  thm_movw(unsigned char *view,
d3612 1
a3612 1
       unsigned char *view,
d3839 1
a3839 1
    unsigned char *view,
d3967 1
a3967 1
    unsigned char *view,
d4131 1
a4131 1
    unsigned char *view,
d5945 1
a5945 1
    const Symbol_table *symtab)
d5980 1
a5980 1
    const Symbol_table *symtab,
d6617 1
a6617 1
  const unsigned char *ps = pshdrs + shdr_size;
d6893 1
a6893 1
  const unsigned char *ps =
d8529 1
a8529 1
    Output_section *output_section,
d9633 1
a9633 1
Target_arm<big_endian>::get_real_reloc_type (unsigned int r_type)
d9785 1
a9785 1
  const Object_attribute *known_attributes =
d9811 1
a9811 1
  Object_attribute *known_attributes =
d9950 1
a9950 1
  static const int *comb[] =
d10018 1
a10018 1
  static const char *aeabi_enum_names[] =
d10039 1
a10039 1
  static const char *name_table[] = {
d11647 1
a11647 1
	      Output_section *os = arm_relobj->output_section(text_shndx);
@


1.117
log
@Index: gold/arm.cc
===================================================================
RCS file: /cvs/src/src/gold/arm.cc,v
retrieving revision 1.116
diff -u -u -p -r1.116 arm.cc
--- gold/arm.cc	3 Aug 2010 14:07:12 -0000	1.116
+++ gold/arm.cc	6 Aug 2010 07:59:30 -0000
@@@@ -10290,11 +10290,11 @@@@ Target_arm<big_endian>::merge_object_att
 	    out_attr[i].set_int_value(in_attr[i].int_value());
 	  break;
 	case elfcpp::Tag_ABI_PCS_wchar_t:
-	  // FIXME: Make it possible to turn off this warning.
 	  if (out_attr[i].int_value()
 	      && in_attr[i].int_value()
 	      && out_attr[i].int_value() != in_attr[i].int_value()
-	      && parameters->options().warn_mismatch())
+	      && parameters->options().warn_mismatch()
+	      && parameters->options().wchar_size_warning())
 	    {
 	      gold_warning(_("%s uses %u-byte wchar_t yet the output is to "
 			     "use %u-byte wchar_t; use of wchar_t values "
@@@@ -10315,10 +10315,10 @@@@ Target_arm<big_endian>::merge_object_att
 		  // Use whatever requirements the new object has.
 		  out_attr[i].set_int_value(in_attr[i].int_value());
 		}
-	      // FIXME: Make it possible to turn off this warning.
 	      else if (in_attr[i].int_value() != elfcpp::AEABI_enum_forced_wide
 		       && out_attr[i].int_value() != in_attr[i].int_value()
-		       && parameters->options().warn_mismatch())
+		       && parameters->options().warn_mismatch()
+		       && parameters->options().enum_size_warning())
 		{
 		  unsigned int in_value = in_attr[i].int_value();
 		  unsigned int out_value = out_attr[i].int_value();
Index: gold/options.h
===================================================================
RCS file: /cvs/src/src/gold/options.h,v
retrieving revision 1.147
diff -u -u -p -r1.147 options.h
--- gold/options.h	1 Jun 2010 23:37:57 -0000	1.147
+++ gold/options.h	6 Aug 2010 07:59:30 -0000
@@@@ -722,6 +722,10 @@@@ class General_options
   DEFINE_special(EL, options::ONE_DASH, '\0',
 		 N_("Link little-endian objects."), NULL);

+  DEFINE_bool(enum_size_warning, options::TWO_DASHES, '\0', true, NULL,
+	      N_("(ARM only) Do not warn about objects with incompatible "
+		 "enum sizes"));
+
   DEFINE_bool(fatal_warnings, options::TWO_DASHES, '\0', false,
 	      N_("Treat warnings as errors"),
 	      N_("Do not treat warnings as errors"));
@@@@ -1038,6 +1042,10 @@@@ class General_options
 		    N_("Report unresolved symbols as errors"),
 		    NULL, true);

+  DEFINE_bool(wchar_size_warning, options::TWO_DASHES, '\0', true, NULL,
+	      N_("(ARM only) Do not warn about objects with incompatible "
+		 "wchar_t sizes"));
+
   DEFINE_bool(whole_archive, options::TWO_DASHES, '\0', false,
               N_("Include all archive contents"),
               N_("Include only needed archive contents"));
@
text
@d2345 1
a2345 1
  got_size()
d2351 21
d2840 3
d7138 15
d7368 29
@


1.116
log
@2010-08-03  Ian Lance Taylor  <iant@@google.com>

	PR 11805
	* layout.h (enum Output_section_order): Define.
	(class Layout): Update declarations.
	* layout.cc (Layout::get_output_section): Add order parameter.
	Remove is_interp, is_dynamic_linker_section, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.  Set order.
	(Layout::default_section_order): New function.
	(Layout::layout_eh_frame): Call add_output_section_to_nonload.
	* output.cc (Output_section::Output_section): Initialize order_.
	Don't initialize deleted fields.
	(Output_segment::Output_segment): Don't initialize deleted
	fields.
	(Output_segment::add_output_section_to_load): New function
	replacing add_output_section.  Change all callers to call this or
	add_output_section_to_nonload.
	(Output_segment::add_output_section_to_nonload): New function.
	(Output_segment::remove_output_section): Rewrite.
	(Output_segment::add_initial_output_data): Likewise.
	(Output_segment::has_any_data_sections): Likewise.
	(Output_segment::is_first_section_relro): Likewise.
	(Output_segment::maximum_alignment): Likewise.
	(Output_segment::has_dynamic_reloc): New function replacing
	dynamic_reloc_count.  Change all callers.
	(Output_segment::has_dynamic_reloc_list): New function replacing
	dynamic_reloc_count_list.  Change all callers.
	(Output_segment::set_section_addresses): Rewrite.
	(Output_segment::set_offset): Rewrite.
	(Output_segment::find_first_and_last_list): Remove.
	(Output_segment::set_tls_offsets): Rewrite.
	(Output_segment::first_section_load_address): Likewise.
	(Output_segment::output_section_count): Likewise.
	(Output_segment::section_with_lowest_load_address): Likewise.
	(Output_segment::write_section_headers): Likewise.
	(Output_segment::print_sections_to_map): Likewise.
	* output.h (class Output_data): Remove dynamic_reloc_count_
	field.  Add has_dynamic_reloc_ field.  Make bools into bitfields.
	(Output_data::add_dynamic_reloc): Rewrite.
	(Output_data::has_dynamic_reloc): New function.
	(Output_data::dynamic_reloc_count): Remove.
	(class Output_section): Add order_ field.  Remvoe is_relro_local_,
	is_last_relro_, is_first_non_relro_, is_interp_,
	is_dynamic_linker_section_ fields.  Add order and set_order
	functions.  Remove is_relro_local, set_is_relro_local,
	is_last_relro, set_is_last_relro, is_first_non_relro,
	set_is_first_non_relro functions, is_interp, set_is_interp,
	is_dynamic_linker_section, and set_is_dynamic_linker_section
	functions.
	(class Output_segment): Change Output_data_list from std::list to
	std:;vector.  Add output_lists_ field.  Remove output_data_ and
	output_bss_ fields.  Update declarations.
@
text
@a10292 1
	  // FIXME: Make it possible to turn off this warning.
d10296 2
a10297 1
	      && parameters->options().warn_mismatch())
a10317 1
	      // FIXME: Make it possible to turn off this warning.
d10320 2
a10321 1
		       && parameters->options().warn_mismatch())
@


1.115
log
@	* arm.cc (Target_arm::gc_process_relocs): Use typename.
	* powerpc.cc (Target_powerpc::gc_process_relocs): Likewise.
	* sparc.cc (Target_sparc::gc_process_relocs): Likewise.
@
text
@d4159 2
a4160 1
				      this->got_, false, false, false, true);
d4169 1
a4169 2
				      this->got_plt_, false, false, false,
				      false);
d4197 2
a4198 2
				      elfcpp::SHF_ALLOC, this->rel_dyn_, true,
				      false, false, false);
d7161 2
a7162 2
				  elfcpp::SHF_ALLOC, this->rel_, true, false,
				  false, false);
d7324 1
a7324 1
				      this->plt_, false, false, false, false);
d8385 2
a8386 2
	  exidx_segment->add_output_section(exidx_section, elfcpp::PF_R,
					    false);
d8398 1
a8398 1
				      attributes_section, false, false, false,
@


1.114
log
@	* arm.cc (Target_arm<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* i386.cc (Target_i386<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* x86_64.cc (Target_x86_64<big_endian>::gc_process_relocs): Add template
	parameter to the call to gold::gc_process_relocs.
	* powerpc.cc (Target_powerpc<big_endian>::gc_process_relocs): Add
	template parameter to the call to gold::gc_process_relocs.
	* sparc.cc (Target_sparc<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* gc.h (get_embedded_addend_size): New function.
	(gc_process_relocs): Save the size of the reloc for use by ICF.
	* icf.cc (get_section_contents): Get the addend from the text section
	for SHT_REL relocation sections.
	* icf.h (Icf::Reloc_addend_size_info): New typedef.
	(Icf::Reloc_info): Add new member reloc_addend_size_info.
	* int_encoding.h (read_from_pointer): New overloaded function.
	* testsuite/Makefile.am (icf_sht_rel_addend_test): New test.
	* testsuite/icf_sht_rel_addend_test.sh: New file.
	* testsuite/icf_sht_rel_addend_test_1.cc: New file.
	* testsuite/icf_sht_rel_addend_test_2.cc: New file.
@
text
@d8217 1
a8217 1
			  Target_arm::Relocatable_size_for_reloc>(
@


1.113
log
@2010-07-13  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section::Arm_input_section): For a
	SHT_ARM_EXIDX section, always keeps the input sections.
	(Arm_input_section::set_exidx_section_link): New method.
	(Arm_exidx_input_section::Arm_exidx_input_section): Initialize
	has_errors_ to false.
	(Arm_exidx_input_section::has_errors,
	Arm_exidx_input_section::set_has_errors): New methods.
	(Arm_exidx_input_section::has_errors_): New data member.
	(Arm_relobj::get_exidx_shndx_list): New method.
	(Arm_output_section::append_text_sections_to_list): Do not skip
	section without SHF_EXECINSTR.
	(Arm_output_section::fix_exidx_coverage): Skip input sections with
	errors.
 	(Arm_relobj::make_exidx_input_section): Add new parameter for text
	section header.  Make error messages more verbose.  Check for
	a non-executable section linked to an EXIDX section.
	(Arm_relobj::do_read_symbols): Remove error checking, which has been
	moved to Arm_relobj::make_exidx_input_section.  Add an assertion to
	check that there is no deferred EXIDX section if we exit early.
	Instead of not making an EXIDX section in case of an error, make one
	and set the has_errors flag of it.
	(Target_arm::do_finalize_sections): Fix up links of EXIDX sections
	in a relocatable link.
	(Target_arm::do_relax): Look for the EXIDX output section instead of
	assuming that it is called .ARM.exidx.
 	(Target_arm::fix_exidx_coverage): Add a new parameter for input
	section list.  Do not check for SHF_EXECINSTR section flags but
	skip any input section with errors.
	* output.cc (Output_section::Output_section): Initialize
	always_keeps_input_sections_ to false.
	(Output_section::add_input_section): Check for
	always_keeps_input_sections_.
	*  output.h (Output_section::always_keeps_input_sections,
	Output_section::set_always_keeps_input_sections): New methods.
	(Output_section::always_keeps_input_sections): New data member.
@
text
@d8216 2
a8217 1
  gold::gc_process_relocs<32, big_endian, Arm, elfcpp::SHT_REL, Scan>(
@


1.112
log
@	* output.h (Output_section_lookup_maps::add_merge_section):
	Correct check of whether value was inserted.
	(Output_section_lookup_maps::add_merge_input_section): Likewise.
	(Output_section_lookup_maps::add_relaxed_input_section):
	Likewise.
	* arm.cc (Target_arm::got_section): Remove used local os.
	* i386.cc (Target_i386::got_section): Likewise.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* sparc.cc (Target_sparc::got_section): Likewise.
	(Target_sparc::relocate): Remove unused local have_got_offset.
	* powerpc.cc (Target_powerpc::relocate): Likewise.
@
text
@d1327 4
a1330 1
  { }
d1358 4
d1386 1
a1386 1
      addralign_(addralign)
d1419 10
d1440 2
d1603 16
d1691 2
a1692 1
			   unsigned int text_shndx);
d2803 2
a2804 1
  fix_exidx_coverage(Layout*, Arm_output_section<big_endian>*, Symbol_table*);
a5694 4
  // We only care about text sections.
  if ((this->flags() & elfcpp::SHF_EXECINSTR) == 0)
    return;

d5767 4
a5770 3
      // If this text section has no EXIDX section, force an EXIDX_CANTUNWIND
      // entry pointing to the end of the last seen EXIDX section.
      if (exidx_input_section == NULL)
d5854 4
a5857 2
	  // We only discard a known EXIDX section because its linked
	  // text section has been folded by ICF.
d5863 5
a5867 2
	  unsigned int text_shndx = exidx_input_section->link();
	  gold_assert(symtab->is_section_folded(p->relobj(), text_shndx));
d5886 22
d6509 2
a6510 1
    unsigned int text_shndx)
a6511 11
  // Issue an error and ignore this EXIDX section if it points to a text
  // section already has an EXIDX section.
  if (this->exidx_section_map_[text_shndx] != NULL)
    {
      gold_error(_("EXIDX sections %u and %u both link to text section %u "
		   "in %s"),
		 shndx, this->exidx_section_map_[text_shndx]->shndx(),
		 text_shndx, this->name().c_str());
      return;
    }

a6515 1
  this->exidx_section_map_[text_shndx] = exidx_input_section;
a6516 1
  // Also map the EXIDX section index to this.
d6519 41
d6629 1
a6629 4
	  if (text_shndx >= this->shnum())
	    gold_error(_("EXIDX section %u linked to invalid section %u"),
		       i, text_shndx);
	  else if (text_shndx == elfcpp::SHN_UNDEF)
d6632 5
a6636 1
	    this->make_exidx_input_section(i, shdr, text_shndx);
d6643 1
d6699 1
a6699 1
	  unsigned int text_shndx;
d6701 6
a6706 7
	  if (it != reloc_map.end()
	      && find_linked_text_section(pshdrs + it->second * shdr_size,
					  psyms, &text_shndx))
	    this->make_exidx_input_section(shndx, shdr, text_shndx);
	  else
	    gold_error(_("EXIDX section %u has no linked text section."),
		       shndx);
d8400 11
d11074 19
a11092 2
      Output_section* os = layout->find_output_section(".ARM.exidx");
      if (os != NULL && os->type() == elfcpp::SHT_ARM_EXIDX)
d11094 2
a11095 3
	  Arm_output_section<big_endian>* exidx_output_section =
	    Arm_output_section<big_endian>::as_arm_output_section(os);
	  this->fix_exidx_coverage(layout, exidx_output_section, symtab);
d11546 1
d11559 5
a11563 4
  Layout::Section_list section_list;
  layout->get_allocated_sections(&section_list);
  for (Layout::Section_list::const_iterator p = section_list.begin();
       p != section_list.end();
d11566 17
a11582 3
      // We only care about output sections that contain executable code.
      if (((*p)->flags() & elfcpp::SHF_EXECINSTR) != 0)
	sorted_output_sections.insert(*p);
@


1.111
log
@2010-06-29  Doug Kwan  <dougkwan@@google.com>

	* arm-reloc-property.cc (Arm_reloc_property::Arm_reloc_property):
	Initialize USE_SYMBOL_.
	* arm-reloc-property.h (Arm_reloc_property::uses_symbol): New method
	definition.
	(Arm_reloc_property::uses_symbol_): New data member declaration.
	* arm.cc (Target_arm::Relocate::relocate): Exit early if relocation
	uses symbol value and symbol is undefined but not weakly undefined.
@
text
@d4119 4
a4122 6
      Output_section* os;
      os = layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
					   (elfcpp::SHF_ALLOC
					    | elfcpp::SHF_WRITE),
					   this->got_, false, false, false,
					   true);
d4128 5
a4132 5
      os = layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
					   (elfcpp::SHF_ALLOC
					    | elfcpp::SHF_WRITE),
					   this->got_plt_, false, false,
					   false, false);
@


1.110
log
@2010-06-25  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::can_check_for_functions_pointers): Return true.
	(Target_arm::section_may_have_icf_unsafe_pointers): New method
	definition.
	(Target_arm::Scan::local_reloc_may_be_function_pointer,
	Target_arm::Scan::global_reloc_may_be_function_pointer): Implement
	target hook to detect function points.
	(Target_arm::Scan::possible_function_pointer_reloc): New method.
	* icf.h (Icf::check_section_for_function_pointers): Change type of
	parameter SECTION_NAME to const reference to std::string.  Use
	target hook to determine if section may have unsafe pointers.
	* target.h (Target::section_may_have_icf_unsafe_pointers): New
	method definition.
@
text
@d8413 7
@


1.109
log
@2010-06-16  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_finalize_sections): Do not emit an
	.ARM.attributes section if we have not merged any input
	attributes sections.
@
text
@d2112 17
d2494 1
a2494 2
 	          			const elfcpp::Sym<32, big_endian>&)
    { return false; }
d2502 1
a2502 2
					 unsigned int , Symbol*)
    { return false; }
d2533 3
d7709 66
@


1.108
log
@2010-06-15  Viktor Kutuzov  <vkutuzov@@accesssoftek.com>

        * arm.cc: Allow combining objects with no EABI version
        information.
@
text
@d8104 1
d8119 1
d8134 1
d8216 3
a8218 3
  // Create an .ARM.attributes section unless we have no regular input
  // object.  In that case the output will be empty.
  if (input_objects->number_of_relobjs() != 0)
@


1.107
log
@2010-06-07  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_relax): Reserve more space for stubs.
	Restrict stub-group size to be within long conditional branch
	range when working around cortex-A8 erratum.
@
text
@d9397 2
a9398 1
  if ((v1 == elfcpp::EF_ARM_EABI_VER4 && v2 == elfcpp::EF_ARM_EABI_VER5)
@


1.106
log
@2010-05-26  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_scan_relocatable_relocs): New class.
	(Target_arm::relocate_special_relocatable): New method.
	(Arm_relocate_functions::arm_branch_common): Handle relocatable link.
	(Arm_relocate_functions::thumb_branch_common): Same.
	(Target_arm::scan_relocatable_relocs): Use Arm_scan_relocatable_relocs
	instead of Default_scan_relocatable_relocs.
	* target-reloc.h (relocate_for_relocatable): Let target handle
	relocation strategy Relocatable_relocs::RELOC_SPECIAL.
	* target.h (Sized_target::relocate_special_relocatable): New method.
@
text
@a10846 6
      // The Cortex-A8 erratum fix depends on stubs not being in the same 4K
      // page as the first half of a 32-bit branch straddling two 4K pages.
      // This is a crude way of enforcing that.
      if (this->fix_cortex_a8_)
	stubs_always_after_branch = true;

d10856 1
a10856 1
	  // This value is 24K less than that, which allows for 2025
d10860 14
a10873 4
	  if (this->fix_cortex_a8_)
	    stub_group_size = 1024276;
	  else
	    stub_group_size = 4170000;
@


1.105
log
@2010-05-23  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section::do_output_offset): Use convert_types
	instead of a cast.
	(Target_arm::apply_cortex_a8_workaround): Rewrite a conditional branch
	with a direct branch, not a conditional branch, to a stub.
	* merge.cc (Output_merge_base::record_input_section): New method
	defintion.
	(Output_merge_data::do_add_input_section): Record input section if
	keeps-input-sections flag is set.
	(Output_merge_string::do_add_input_section): Ditto.
	* merge.h (Output_merge_base::Output_merge_base): Initialize new data
	members KEEPS_INPUT_SECTIONS_, FIRST_RELOBJ_, FIRST_SHNDX_ and
	INPUT_SECTIONS_.
	(Output_merge_base::keeps_input_sections,
	Output_merge_base::set_keeps_input_sections,
	Output_merge_base::first_relobj, Output_merge_base::first_shndx): New
	method definitions.
	(Output_merge_base::Input_sections): New type declaration.
	(Output_merge_base::input_sections_begin,
	Output_merge_base::input_sections_end,
	Output_merge_base::do_set_keeps_input_sections): New method definitions.
	(Output_merge_base::bool keeps_input_sections_,
	Output_merge_base::first_relobj_, Output_merge_base::first_shndx_,
	Output_merge_base::input_sections_): New data members.
	(Output_merge_data::do_set_keeps_input_sections): New method
	defintion.
	(Output_merge_string::do_set_keeps_input_sections): Ditto.
	* output.cc (Output_section::Input_section::relobj): Move method
	defintion from class declaration to here and handle merge sections.
	(Output_section::Input_section::shndx): Ditto.
	(Output_section::Output_section): Remove initializations of removed
	data members and initialize new data member LOOKUP_MAPS_.
	(Output_section::add_input_section): Set keeps-input-sections flag
	for a newly created merge output section as appropriate.  Adjust code
	to use Output_section_lookup_maps class.
	(Output_section::add_relaxed_input_section): Adjst code for lookup
	maps code refactoring.
 	(Output_section::add_merge_input_section): Add a new parameter
	KEEPS_INPUT_SECTION.  Adjust code to use Output_section_lookup_maps
	class.  If adding input section to a newly created merge output
	section fails, remove the new merge section.
	(Output_section::convert_input_sections_in_list_to_relaxed_input_sections):
	Adjust code for use of the Output_section_lookup_maps class.
 	(Output_section::find_merge_section): Ditto.
	(Output_section::build_lookup_maps): New method defintion.
 	(Output_section::find_relaxed_input_section): Adjust code to use
	Output_section_lookup_maps class.
	(Output_section::get_input_sections): Export merge sections.  Adjust
	code to use Output_section_lookup_maps class.
	(Output_section:::add_script_input_section): Adjust code to use
	Output_section_lookup_maps class.  Update lookup maps for merge
	sections also.
	(Output_section::discard_states): Use Output_section_lookup_maps.
	(Output_section::restore_states): Same.
	* output.h (Merge_section_properties): Move class defintion out of
	Output_section.
	(Output_section_lookup_maps): New class.
	(Output_section::Input_section::is_merge_section): New method
	defintion.
	(Output_section::Input_section::relobj): Move defintion out of class
	defintion.  Declare method only.
	(Output_section::Input_section::shndx): Ditto.
	(Output_section::Input_section::output_merge_base): New method defintion.
     	(Output_section::Input_section::u2_.pomb): New union field.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Ouptut_relaxed_input_section_by_input_section_map):
	Remove types.
   	(Output_section::add_merge_input_section): Add new parameter
	KEEPS_INPUT_SECTIONS.
	(Output_section::build_lookup_maps): New method declaration.
	(Output_section::merge_section_map_,
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_): Remove data
	members.
	(Output_section::lookup_maps_): New data member.
@
text
@d1959 73
d2265 15
d3816 1
d3834 5
a3838 2
  if (utils::has_overflow<26>(branch_offset)
      || ((thumb_bit != 0) && !(may_use_blx && r_type == elfcpp::R_ARM_CALL)))
d3945 1
d3972 6
a3977 5
  if ((!thumb2 && utils::has_overflow<23>(branch_offset))
      || (thumb2 && utils::has_overflow<25>(branch_offset))
      || ((thumb_bit == 0)
          && (((r_type == elfcpp::R_ARM_THM_CALL) && !may_use_blx)
	      || r_type == elfcpp::R_ARM_THM_JUMP24)))
d9016 1
a9016 1
  typedef gold::Default_scan_relocatable_relocs<elfcpp::SHT_REL,
d9068 285
@


1.104
log
@Add a cast to avoid a compilation error.

2010-05-21  Doug Kwan  <dougkwan@@google.com>

	PR gold/11619
	* arm.cc (Arm_input_section::do_output_offset): Add a cast to
	avoid a compilation error.
@
text
@d1205 2
a1206 1
	&& (offset <= static_cast<section_offset_type>(this->original_size_)))
d10902 5
a10906 7
      gold_assert(!utils::has_overflow<21>(branch_offset));
      upper_insn = RelocFuncs::thumb32_cond_branch_upper(upper_insn,
							 branch_offset);
      lower_insn = RelocFuncs::thumb32_cond_branch_lower(lower_insn,
							 branch_offset);
      break;

@


1.103
log
@2010-05-14  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section::original_size): New method.
	(Arm_input_section::do_addralign): Add a cast.
	(Arm_input_section::do_output_offset): Remove static cast.
	(Arm_input_section::original_addralign,
	 Arm_input_section::original_size_): Change type to uint32_t.
	(Arm_input_section::init): Add safe casts for section alignment
	and size.
	(Arm_input_section::set_final_data_size): Do not set address and
	offset of stub table.
	(Arm_output_section::fix_exidx_coverage): Change use of of
	Output_section::Simple_input_section to that of
	Output_section::Input_section.
	(Target_arm::do_relax): Set addresses and file offsets of Stub_tables
	except for the first pass.
	* output.cc (Output_section::get_input_sections): Change type of
	input_sections to std::list<Input_section>.
	(Output_section::add_script_input_section): Rename from
	Output_section::add_simple_input_section.  Change type of SIS
	parameter from Simple_input_section to Input_section.
	* output.h (Output_section::Simple_input_section): Remove class.
	(Output_section::Input_section): Change class visibility to public.
	(Output_section::Input_section::addralign): Use stored alignments
	for special input sections if set.
	(Output_section::Input_section::set_addralign): New method.
	(Output_section::get_input_sections): Change parameter type from
	list of Simple_input_section to list of Input_section.
	(Output_section::add_script_input_section): Rename from
	Output_section::add_simple_input_section. Change first parameter's
	type from Simple_input_section to Input_section and remove the
	second and third parameters.
	* script-sections.cc (Input_section::Input_section_list): Change
	type to list of Output_section::Input_section/
	(Input_section_info::Input_section_info): Change parameter type of
	INPUT_SECTION to Output_section::Input_section.
	(Input_section_info::input_section): Change return type.
	(Input_section_info::input_section_): Change type to
	Output_section::Input_section.
	(Output_section_element_input::set_section_addresses): Adjust code
	to use Output_section::Input_section instead of
	Output_section::Simple_input_section.  Adjust code for renaming
	of Output_section::add_simple_input_section.
	(Orphan_output_section::set_section_addresses): Ditto.
@
text
@d1205 1
a1205 1
	&& (offset <= this->original_size_))
@


1.102
log
@2010-05-12  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog

	* arm.h (Tag_FP_arch, Tag_ABI_align_needed, Tag_ABI_align_preserved,
	Tag_FP_HP_extension, Tag_MPextension_use_legacy): Rename from
	existing tags.
	(Tag_undefined40, Tag_undefined41, Tag_MPextension_use,
	Tag_undefined43): New tags.
	(Targ_VFP_arch, Tag_ABI_align8_needed, TAG_ABI_align8_preserved,
	Tag_VFP_HP_extension): Define aliases for backward compatiblity.

gold/ChangeLog

	* arm.cc (Target_arm::do_finalize_sections): Create an empty
	attributes section only if there no attributes section after merging.
	(Target_arm::merge_object_attributes): Move value of
	Tag_MPextension_use_legacy to that of Tag_MPextension_use.
	Handle Tag_DIV_use and Tag_MPextension_use_legacy.
	* testsuite/Makefile.am (check_SCRIPTS): Add arm_attr_merge.sh
	(check_DATA): Add arm_attr_merge_6.stdout, arm_attr_merge_6r_stdout
	and arm_attr_merge_7.stdout.
	(arm_attr_merge_6.stdout, arm_attr_merge_6 arm_attr_merge_6a.o
	arm_attr_merge_6b.o, arm_attr_merge_6r.stdout, arm_attr_merge_6r,
	arm_attr_merge_7.stdout, arm_attr_merge_7, arm_attr_merge_7a.o,
	arm_attr_merge_7b.o): New rules.
	(MOSTLYCLEANFILES): Add arm_attr_merge_6, arm_attr_merge_6r and
	arm_attr_merge_7
	* testsuite/Makefile.in: Regenerate.
	* testsuite/arm_attr_merge.sh: New file.
	* testsuite/arm_attr_merge_[67][ab].s: Same.
@
text
@d1167 5
d1183 1
a1183 1
		      this->original_addralign_);
d1205 1
a1205 2
	&& (convert_types<uint64_t, section_offset_type>(offset)
	    <= this->original_size_))
d1220 1
a1220 1
  uint64_t original_addralign_;
d1222 1
a1222 1
  uint64_t original_size_;
d4916 4
a4919 2
  this->original_addralign_ = relobj->section_addralign(shndx);
  this->original_size_ = relobj->section_size(shndx);
d4958 1
a4958 1
      // The stub table comes after the original section contents.
a4959 2
      this->stub_table_->set_address_and_file_offset(this->address() + off,
						     this->offset() + off);
d5583 2
a5584 2
  typedef std::list<Simple_input_section> Simple_input_section_list;
  Simple_input_section_list input_sections;
d5593 4
a5596 2
  Section_id_set known_input_sections;
  for (Simple_input_section_list::const_iterator p = input_sections.begin();
d5603 1
a5603 1
      known_input_sections.insert(Section_id(p->relobj(), p->shndx()));
d5609 1
d5634 2
a5635 1
      if (known_input_sections.find(sid) == known_input_sections.end())
d5690 3
a5692 3
	  Output_section::Simple_input_section sis(exidx_relobj, exidx_shndx);
	  this->add_simple_input_section(sis, exidx_input_section->size(),
					 exidx_input_section->addralign());
d5702 1
a5702 1
  for (Simple_input_section_list::const_iterator p = input_sections.begin();
d10455 1
d10504 15
a10524 1
  typedef typename Stub_table_list::iterator Stub_table_iterator;
@


1.101
log
@2010-04-15  Andrew Haley  <aph@@redhat.com>

	* emultempl/armelf.em (merge_exidx_entries): New variable.
	(OPTION_NO_MERGE_EXIDX_ENTRIES): New definition.
	("no-merge-exidx-entries"): New option.
	* ld.texinfo (merge-exidx-entries): Document this option.

2010-04-15  Andrew Haley  <aph@@redhat.com>

	* bfd-in.h (elf32_arm_fix_exidx_coverage): Add new flag:
	merge_exidx_entries.
	* bfd-in2.h: Likewise.
	* elf32-arm.c (elf32_arm_fix_exidx_coverage): Likewise.  Use it to
	control merging of exidx entries.

2010-04-15  Andrew Haley  <aph@@redhat.com>

	* options.h (merge_exidx_entries): New option.
	* arm.cc (class Arm_exidx_fixup): Add new arg, merge_exidx_entries.
	(class Arm_exidx_fixup::merge_exidx_entries_): New member.
	(Output_section::fix_exidx_coverage): Add new arg, merge_exidx_entries.
	(Target_arm::merge_exidx_entries): New function.
	(process_exidx_entry): Don't merge if merge_exidx_entries_ is false.
	(Arm_output_section::fix_exidx_coverage): Pass merge_exidx_entries
	to Arm_exidx_fixup constructor.
	Add new arg, merge_exidx_entries.
	(Target_arm::fix_exidx_coverage): pass merge_exidx_entries to
	Arm_output_section::fix_exidx_coverage.
@
text
@a8000 5
  // Create an empty uninitialized attribute section if we still don't have it
  // at this moment.
  if (this->attributes_section_data_ == NULL)
    this->attributes_section_data_ = new Attributes_section_data(NULL, 0);

d8031 6
d9431 1
d9435 22
a9459 1
  const int vendor = Object_attribute::OBJ_ATTR_PROC;
d9785 45
@


1.100
log
@2010-04-14  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_output_section::fix_exidx_coverage): Mark object
	for local symbol recounting if we remove a section due to ICF.
	* gold.cc (queue_middle_gc_tasks): Create a dummy blocker if
	there are no regular objects in input.
@
text
@d1229 2
a1230 1
  Arm_exidx_fixup(Output_section* exidx_output_section)
d1233 2
a1234 1
      section_offset_map_(NULL), first_output_text_section_(NULL)
d1306 2
d1347 2
a1348 1
		     Symbol_table* symtab);
d2269 5
d5199 2
a5200 1
      delete_entry = (this->last_unwind_type_ == UT_INLINED_ENTRY
d5567 2
a5568 1
    Symbol_table* symtab)
d5600 1
a5600 1
  Arm_exidx_fixup exidx_fixup(this);
d10899 2
a10900 1
  exidx_section->fix_exidx_coverage(layout, sorted_text_sections, symtab);
@


1.99
log
@2010-04-13  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section::set_final_data_size): Compute
	accurate final data size instead of using current data size.
@
text
@d5699 2
a5700 1
	  // Remove this from link.
d5702 1
@


1.98
log
@2010-04-07  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::scan_section_for_cortex_a8_erratum): Warn
	if section is marked as containing instructions but has no mapping
	symbols.
	(Arm_relobj::do_count_local_symbols): Call adjust_sym_shndx to get
	correct section index.
	(Arm_relobj::find_linked_text_section): Ditto.
@
text
@d4938 2
a4939 1
  // If this owns a stub table, finalize its data size as well.
a4941 2
      uint64_t address = this->address();

d4943 4
a4946 6
      address += this->original_size_;
      address = align_address(address, this->stub_table_->addralign());
      off_t offset = this->offset() + (address - this->address());
      this->stub_table_->set_address_and_file_offset(address, offset);
      address += this->stub_table_->data_size();
      gold_assert(address == this->address() + this->current_data_size());
d4948 1
a4948 2

  this->set_data_size(this->current_data_size());
@


1.97
log
@2010-04-07  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Replace "endianity" with "endianness" in comments.
	(Arm_exidx_cantunwind): Ditto.
	(Arm_relobj::Arm_relobj): Initialize merge_flags_and_attribures.
	(Arm_relobj::merge_flags_and_attributes): New method.
	(Arm_relobj::merge_flags_and_attributes_): New data member.
	(Arm_exidx_cantunwind::do_fixed_endian_write): Fix formatting.
	(Arm_relobj::scan_sections_for_stubs): Ditto.
	(Arm_relobj::do_read_symbols): Check to see if we really want to
	merge processor-specific flags and attributes.  Exit early if
	an object is empty except for section names and the undefined symbol.
	(Target_arm::do_finalize_sections): Move check for ELF format to
	Arm_relobj::do_read_symbols.  Merge processor specific flags and
	attributes from a regular object only when we have determined that
	it is aapropriate.  Do not create an .ARM.attributes section in
	output if there is no regular input object.
	(Target_arm::merge_processor_specific_flags): Check
	--warn-mismatch before printing any error.
	(Target_arm::merge_object_attributes): Ditto.
	* gold.cc (queue_middle_tasks): Handle the case in which there is
	no regular object in input.
	* options.cc (General_options::parse_EB): New method.
	(General_options::parse_EL): Same.
	(General_options::General_options): Initialize endianness_.
	* options.h (-EB, -EL, -no-pipeline-knowledge, -p, --warn-mismatch):
	New options.
	(General_options::Endianness): New enum.
	(General_options::endianness): New method.
	(General_options::endianness_): New data member.
	* parameters.cc (Parameters::set_options): Check target endianness.
	(Parameters::set_target_once): Ditto.
	(Parameters::check_target_endianness): New method.
	(parameters_force_valid_target): If either -EL or -EB is specified,
	use it to define endianness of default target.
	* parameters.h (Parameters::check_target_endianness): New method
	declaration.
	* target.h (class Target): Change "endianity" to "endianness"
	in comments.
@
text
@d5869 2
a5870 1
  // section.
d5872 7
a5878 1
    return;
d6111 4
a6114 1
	  unsigned int input_shndx = sym.get_st_shndx();  
d6297 4
a6300 1
	  *pshndx = this->adjust_shndx(sym.get_st_shndx());
@


1.96
log
@2010-03-30  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::using_thumb_only): Handle v6-M
@
text
@d605 1
a605 1
    // as most of the stub machinery is endianity-neutral.  However, it
d1068 1
a1068 1
  // Implement do_write for a given endianity.
d1429 2
a1430 1
      output_local_symbol_count_needs_update_(false)
d1569 5
d1674 3
d4136 1
a4136 1
// Template to implement do_write for a specific target endianity.
d4981 1
a4981 1
// Write this to Output file OF for a fixed endianity.
d5002 1
a5002 1
  if(output_offset != Arm_relobj<big_endian>::invalid_address)
d5958 1
a5958 1
	  if(output_offset != invalid_address)
d6339 10
d6362 1
d6366 17
d6407 7
d7988 3
a7990 4
      // If this input file is a binary file, it has no processor
      // specific flags and attributes section.
      Input_file::Format format = (*p)->input_file()->format();
      if (format != Input_file::FORMAT_ELF)
d7992 5
a7996 2
	  gold_assert(format == Input_file::FORMAT_BINARY);
	  continue;
a7997 9

      Arm_relobj<big_endian>* arm_relobj =
	Arm_relobj<big_endian>::as_arm_relobj(*p);
      this->merge_processor_specific_flags(
	  arm_relobj->name(),
	  arm_relobj->processor_specific_flags());
      this->merge_object_attributes(arm_relobj->name().c_str(),
				    arm_relobj->attributes_section_data());

d8086 11
a8096 7
  // Create an .ARM.attributes section if there is not one already.
  Output_attributes_section_data* attributes_section =
    new Output_attributes_section_data(*this->attributes_section_data_);
  layout->add_output_section_data(".ARM.attributes",
				  elfcpp::SHT_ARM_ATTRIBUTES, 0,
				  attributes_section, false, false, false,
				  false);
d9014 2
a9015 1
      if (!this->are_eabi_versions_compatible(version1, version2))
d9426 2
a9427 1
      else if (in_attr[elfcpp::Tag_ABI_FP_number_model].int_value() != 0)
d9571 1
a9571 1
	      else
d9626 3
a9628 1
	  else if (in_attr[i].int_value() != 0 && out_attr[i].int_value() != 0)
d9638 2
a9639 1
	      && in_attr[i].int_value() != elfcpp::AEABI_R9_unused)
d9651 2
a9652 1
		  != elfcpp::AEABI_R9_unused))
d9656 1
a9656 1
			 name);
d9666 2
a9667 1
	      && out_attr[i].int_value() != in_attr[i].int_value())
d9690 2
a9691 1
		       && out_attr[i].int_value() != in_attr[i].int_value())
d9708 2
a9709 1
	  if (in_attr[i].int_value() != out_attr[i].int_value())
d9730 2
a9731 1
	      if (in_attr[i].int_value() != out_attr[i].int_value())
d9768 2
a9769 1
	    if (err_object != NULL)
d9861 1
a9861 1
      if (err_object)
@


1.95
log
@2010-03-25  Doug Kwan  <dougkwan@@google.com>

	* gold/arm.cc (Arm_exidx_fixup::update_offset_map): Rearrange code
	to avoid a conversion warning on a 32-bit host.
@
text
@d2056 4
@


1.94
log
@2010-03-22  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relocate_functions::abs8,
	Arm_relocate_functions::abs16): Use correct check for overflow
	specified in the ARM ELF specs.
	(Arm_relocate_functions): thumb_branch_common.  Handle bit 1 of branch
	target of a BLX instruction specially.
	(Reloc_stub::stub_type_for_reloc): Ditto.
	(Relocate::relocate): Use symbolic names instead of numeric relocation
	codes to report error.
	(Target_arm::do_relox): Reduce default stub-group size for Cortex-A8
	workaround.
	* testsuite/Makefile.am (check_DATA): add thumb_blx_in_range.stdout,
	thumb_blx_out_of_range.stdout, thumb2_blx_in_range.stdout and
	thumb2_blx_out_of_range.stdout
	(thumb_bl_out_of_range, thumb_bl_out_of_range.o,
	thumb2_bl_out_of_range, thumb2_bl_out_of_range.o): Fix dependenices.
	(thumb_blx_in_range.stdout, thumb_blx_in_range, thumb_blx_in_range.o,
	thumb_blx_out_of_range.stdout, thumb_blx_out_of_range,
	thumb_blx_out_of_range.o, thumb2_blx_in_range.stdout,
	thumb2_blx_in_range, thumb2_blx_in_range.o,
	thumb2_blx_out_of_range.stdout, thumb2_blx_out_of_range,
	thumb2_blx_out_of_range.o): New rules.
 	(MOSTLYCLEANFILES): Add thumb_blx_in_range, thumb_blx_out_of_range,
	thumb2_blx_in_range and	thumb2_blx_out_of_range.
	* testsuite/Makefile.in: Regenerate.
	* arm_branch_in_range.sh: Add tests for THUMB BLX.
	* testsuite/thumb_blx_in_range.s: New file.
	* testsuite/thumb_blx_out_of_range.s: New file.
@
text
@d5209 5
a5213 4
  section_offset_type output_offset =
    (delete_entry
     ? Arm_exidx_input_section::invalid_offset
     : input_offset - deleted_bytes);
@


1.93
log
@2010-03-19  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Stub_table::Stub_table): Initialize new data members
	Stub_table::reloc_stubs_size_ and Stub_table::reloc_stubs_addralign_.
	(Stub_table::add_reloc_stub): Assign stub offset and update
	Stub_table::reloc_stubs_size_ and Stub_table::reloc_stubs_addralign_.
	(Stub_table::reloc_stubs_size_, Stub_table::reloc_stubs_addralign_):
	New data members.
 	(Stub_table::update_data_size_and_addralign): Use
	Stub_table::reloc_stubs_size_ and Stub_table::reloc_stubs_addralign_
	instead of going over all reloc stubs.
 	(Stub_table::finalize_stubs): Do not assign reloc stub offsets.
	* stringpool.cc (Stringpool_template::Stringpool_template): Initialize
	Stringpool_template::offset_ to size of Stringpool_char.
 	(Stringpool_template::new_key_offset): Remove code to initialize
	Stringpool_template::offset_.
	* stringpool.h (Stringpool_template::set_no_zero_null): Set
	Stringpool_template::offset_ to zero.
@
text
@d2988 4
a2991 1
    return (utils::has_signed_unsigned_overflow<8>(x)
d3010 4
a3013 1
    return (utils::has_overflow<5>(x)
d3840 6
a3849 1
  bool may_use_blx = arm_target->may_use_blx();
d3875 2
d3897 4
d3902 1
a3902 5
    // For a BLX instruction, make sure that the relocation is rounded up
    // to a word boundary.  This follows the semantics of the instruction
    // which specifies that bit 1 of the target address will come from bit
    // 1 of the base address.
    branch_offset = (branch_offset + 2) & ~3;
d3913 2
d4243 1
a4243 2
  int64_t branch_offset = (int64_t)destination - location;

d4246 6
d4332 1
d8586 2
a8587 2
			     _("relocation overflow in relocation %u"),
			     r_type);
d8594 2
a8595 2
	_("unexpected opcode while processing relocation %u"),
	r_type);
d10321 3
a10323 1
	  // code, so the worst case has to be taken into account).
d10329 4
a10332 1
	  stub_group_size = 4170000;
@


1.92
log
@2010-03-08  Doug Kwan  <dougkwan@@google.com>

	* gold/arm.cc (Arm_exidx_fixup::update_offset_map): Fix build breakage
	due to a conversion warning.
	(Arm_relobj::update_output_local_symbol_count): Check for local
	symbol with unset output index.
@
text
@d871 3
a873 2
    : Output_data(), owner_(owner), reloc_stubs_(), cortex_a8_stubs_(),
      arm_v4bx_stubs_(0xf), prev_data_size_(0), prev_addralign_(1)
d906 9
d1023 4
a4736 3
  off_t size = 0;
  unsigned addralign = 1;

d4738 2
a4739 10
  
  for (typename Reloc_stub_map::const_iterator p = this->reloc_stubs_.begin();
      p != this->reloc_stubs_.end();
      ++p)
    {
      const Stub_template* stub_template = p->second->stub_template();
      addralign = std::max(addralign, stub_template->alignment());
      size = (align_address(size, stub_template->alignment())
	      + stub_template->size());
    }
d4784 1
a4784 13
  off_t off = 0;
  for (typename Reloc_stub_map::const_iterator p = this->reloc_stubs_.begin();
      p != this->reloc_stubs_.end();
      ++p)
    {
      Reloc_stub* stub = p->second;
      const Stub_template* stub_template = stub->stub_template();
      uint64_t stub_addralign = stub_template->alignment();
      off = align_address(off, stub_addralign);
      stub->set_offset(off);
      off += stub_template->size();
    }

@


1.91
log
@	* target-reloc.h (relocate_section): Check the symbol table index
	for -1U before setting the local symbol index.
	(scan_relocatable_relocs): If copying the relocation, record that
	the local symbol is required.
	* object.h (Symbol_value::is_output_symtab_index_set): New
	function.
	(Symbol_value::may_be_discarded_from_output_symtab): New
	function.
	(Symbol_value::has_output_symtab_entry): New function.
	(Symbol_value::needs_output_symtab_entry): Remove.
	(Symbol_value::output_symtab_index): Make sure the symbol index is
	set.
	(Symbol_value::set_output_symtab_index): Make sure the symbol
	index is not set.  Make sure the new index is valid.
	(Symbol_value::set_must_have_output_symtab_entry): New function.
	(Symbol_value::has_output_dynsym_entry): New function.
	(Symbol_value::set_output_dynsym_index): Make sure the new index
	is valid.
	(Sized_relobj::set_must_have_output_symtab_entry): New function.
	* object.cc (Sized_relobj::do_count_local_symbols): Only discard a
	local symbol if permitted.
	(Sized_relobj::do_finalize_local_symbols): Call
	is_output_symtab_index_set rather than needs_output_symtab_entry.
	(Sized_relobj::write_local_symbols): Call has_output_symtab_entry
	rather than needs_output_symtab_entry.  Call
	has_output_dynsym_entry rather than needs_output_dynsym_entry.
	* arm.cc (Arm_relobj::update_output_local_symbol_count): Call
	is_output_symtab_index_set rather than needs_output_symtab_entry.
	* testsuite/discard_locals_relocatable_test.c: New file.
	* testsuite/discard_locals_test.sh: Test -r.
	* testsuite/Makefile.am (check_DATA): Add
	discard_locals_relocatable_test1.syms,
	discard_local_relocatable_test2.syms.
	(MOSTLYCLEANFILES): Likewise.  Also add
	discard_locals_relocatable_test1.lout and
	discard_locals_relocatable_test2.out.
	(discard_locals_relocatable_test1.syms): New target.
	(discard_locals_relocatable_test.o): New target.
	(discard_locals_relocatable_test1.out): New target.
	(discard_locals_relocatable_test2.syms): New target.
	(discard_locals_relocatable_test2.out): New target.
	(various): Add missing ../ld-new dependencies.
	* testsuite/Makefile.in: Rebuild.
@
text
@d5197 4
a5200 3
  section_offset_type output_offset = (delete_entry
				       ? -1
				       : input_offset - deleted_bytes);
d6510 1
a6510 1
      if (!lv.is_output_symtab_index_set())
@


1.90
log
@2010-02-26  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::Relocate::reloc_is_non_pic): Treat
	R_ARM_PREL31 and R_ARM_SBREL31 as position independent.
	* testsuite/debug_msg.sh: Avoid matching source line number for
	use of global variable undef_int.
@
text
@d6509 1
a6509 1
      if (!lv.needs_output_symtab_entry())
@


1.89
log
@2010-02-26  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::scan_reloc_for_stub): Move code handling
	R_ARM_V4BX to Target_arm::scan_reloc_section_for_stubs.
	(Target_arm::scan_reloc_section_for_stubs): Instead of calling
	scan_reloc_for_stub, do all processing of R_ARM_V4BX here.
	* options.cc (General_options::General_options): Initialize member
	fix_v4bx_.
	* testsuite/Makefile.am (check_SCRIPTS): Add arm_fix_v4bx.sh
	(check_DATA): Add arm_fix_v4bx.stdout, arm_fix_v4bx_interworking.stdout
	and rm_no_fix_v4bx.stdout
	(arm_fix_v4bx.stdout, arm_fix_v4bx, arm_fix_v4bx.o,
	arm_fix_v4bx_interworking.stdout, arm_fix_v4bx_interworking,
	arm_no_fix_v4bx.stdout, arm_no_fix_v4bx): New make rules.
	(MOSTLYCLEANFILES): Add arm_fix_v4bx, arm_fix_v4bx_interworking
	and arm_no_fix_v4bx.
	* Makefile.in: Regenerate.
	* testsuite/arm_fix_v4bx.s: New file.
	* testsuite/arm_fix_v4bx.sh: Ditto.
@
text
@d2447 2
@


1.88
log
@2010-02-24  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::got_section): Make the .got section the first
	non RELRO section in the data segment.
	* testsuite/script_test_5.sh: Fix match patterns to avoid matching
	suffixes of section names.
@
text
@a9882 24
  if (r_type == elfcpp::R_ARM_V4BX)
    {
      const uint32_t reg = (addend & 0xf);
      if (this->fix_v4bx() == General_options::FIX_V4BX_INTERWORKING
	  && reg < 0xf)
	{
	  // Try looking up an existing stub from a stub table.
	  Stub_table<big_endian>* stub_table =
	    arm_relobj->stub_table(relinfo->data_shndx);
	  gold_assert(stub_table != NULL);

	  if (stub_table->find_arm_v4bx_stub(reg) == NULL)
	    {
	      // create a new stub and add it to stub table.
	      Arm_v4bx_stub* stub =
		this->stub_factory().make_arm_v4bx_stub(reg);
	      gold_assert(stub != NULL);
	      stub_table->add_arm_v4bx_stub(stub);
	    }
	}

      return;
    }

d10073 1
d10076 27
a10102 7
	  // Get the BX instruction.
	  typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
	  const Valtype* wv = reinterpret_cast<const Valtype*>(view + offset);
	  elfcpp::Elf_types<32>::Elf_Swxword insn =
	      elfcpp::Swap<32, big_endian>::readval(wv);
	  this->scan_reloc_for_stub(relinfo, r_type, NULL, 0, NULL,
				    insn, NULL);
@


1.87
log
@2010-02-24  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_finalize_sections): Skip processor specific
	flags and attributes merging if an input file is a binary file.
	* fileread.cc (Input_file::open): Record format of original file.
	* fileread.h (Input_file::Format): New enum type.
   	(Input_file::Input_file): Initialize data member format_.
	(Input_file::format): New method definition.
	(Input_file::format_):: New data member.
@
text
@d3952 2
a3953 3
					   this->got_, false, true, true,
					   false);

d3963 1
a3963 1
					   false, true);
@


1.86
log
@2010-02-24  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_output_data_got): New class.
	(ARM_TCB_SIZE): New constant
	(Target_arm): Use Arm_output_data_got instead of Output_data_got.
	(Arm_output_section::fix_exidx_coverage): Add a parameter for layout.
	If user uses a script with a SECTIONS clause, issue only a warning
	for a misplaced EXIDX input section.  Otherwise, issue an error.
 	(Arm_relobj::do_gc_process_relocs): Exit early if we are not doing
	garbage collection.
	(Target_arm::got_mode_index_entry): Handle static linking.
	(Target_arm::Scan::local): Ditto.
	(Target_arm::Scan::global): Ditto.
	(Target_arm::Relocate::relocate_tls): Handle static linking.  Fix
	all incorrectly implemented relocations.
	(Target_arm::fix_exidx_coverage): Pass layout to
	Arm_output_section::fix_exidx_coverage.
	* layout.cc (Layout::section_name_mapping): Remove trailing dots
	from ".ARM.exidx." and ".ARM.extab.".
@
text
@d7925 9
@


1.85
log
@	* arm.cc (Target_arm::do_finalize_sections): Create attribute
	section if it does not already exist.
	* attributes.cc	(Attributes_section_data::Attributes_section_data):
	Don't crash if size is zero.
@
text
@d87 3
d103 3
d1327 2
a1328 1
  fix_exidx_coverage(const Text_section_list& sorted_text_section,
d1788 138
d2480 1
a2480 1
  Output_data_got<32, big_endian>*
d2654 1
a2654 1
  Output_data_got<32, big_endian>* got_;
d3939 1
a3939 1
Output_data_got<32, big_endian>*
d3946 1
a3946 1
      this->got_ = new Output_data_got<32, big_endian>();
d5530 1
d5594 12
a5605 3
	  // We cannot do fix-up.
	  gold_error(_("EXIDX section %u of %s is not in EXIDX output section"),
		     exidx_shndx, exidx_relobj->name().c_str());
d6431 5
d6642 156
d7083 16
a7098 5
      Reloc_section* rel_dyn = this->rel_dyn_section(layout);
      Output_data_got<32, big_endian>* got = this->got_section(symtab, layout);
      unsigned int got_offset = got->add_constant(0);
      rel_dyn->add_local(object, 0, elfcpp::R_ARM_TLS_DTPMOD32, got,
                         got_offset);
d7340 1
a7340 1
	Output_data_got<32, big_endian>* got =
d7393 1
a7393 1
                Output_data_got<32, big_endian>* got
d7400 7
a7406 3
		  object->error(_("local symbol %u has bad shndx %u"),
			      r_sym, shndx);
                else
d7411 3
d7438 19
a7456 7
	        // Create a GOT entry for the tp-relative offset.
                Output_data_got<32, big_endian>* got
                    = target->got_section(symtab, layout);
                unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
		got->add_local_with_rel(object, r_sym, GOT_TYPE_TLS_OFFSET,
					target->rel_dyn_section(layout),
					elfcpp::R_ARM_TLS_TPOFF32);
d7700 1
a7700 1
	Output_data_got<32, big_endian>* got =
d7757 1
a7757 1
                Output_data_got<32, big_endian>* got
d7759 7
a7765 4
                got->add_global_pair_with_rel(gsym, GOT_TYPE_TLS_PAIR,
					      target->rel_dyn_section(layout),
					      elfcpp::R_ARM_TLS_DTPMOD32,
					      elfcpp::R_ARM_TLS_DTPOFF32);
d7790 15
a7804 6
	        // Create a GOT entry for the tp-relative offset.
                Output_data_got<32, big_endian>* got
                    = target->got_section(symtab, layout);
                got->add_global_with_rel(gsym, GOT_TYPE_TLS_OFFSET,
                                         target->rel_dyn_section(layout),
                                         elfcpp::R_ARM_TLS_TPOFF32);
d8594 1
a8594 1
    elfcpp::Elf_types<32>::Elf_Addr,
d8598 1
d8630 6
a8635 3
              // Relocate the field with the offset of the pair of GOT
              // entries.
              Relocate_functions<32, big_endian>::rel32(view, got_offset);
d8649 6
a8654 1
          Relocate_functions<32, big_endian>::rel32(view, got_offset);
d8660 1
a8660 1
      Relocate_functions<32, big_endian>::rel32(view, value);
d8681 1
d8684 6
a8689 1
          Relocate_functions<32, big_endian>::rel32(view, got_offset);
d8700 7
a8706 2
          value = tls_segment->memsz() - value;
          Relocate_functions<32, false>::rel32(view, value);
d10794 1
a10794 1
  exidx_section->fix_exidx_coverage(sorted_text_sections, symtab);
@


1.84
log
@2010-02-21  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relocate_functions::arm_branch_common): Fix bug in
	handling of the maximum backward branch offset.
     	(Arm_relocate_functions::thumb_branch_common): Ditto.
	* testsuite/Makefile.am (check_SCRIPTS): Add arm_branch_in_range.sh.
	(check_DATA): Add arm_bl_in_range.stdout, arm_bl_out_of_range.stdout
	thumb_bl_in_range.stdout, thumb_bl_out_of_range.stdout,
	thumb2_bl_in_range.stdout and thumb2_bl_out_of_range.stdout.
	(arm_bl_in_range.stdout, arm_bl_in_range, arm_bl_in_range.o,
	arm_bl_out_of_range.stdout, arm_bl_out_of_range,
	arm_bl_out_of_range.o, thumb_bl_in_range.stdout, thumb_bl_in_range,
	thumb_bl_in_range.o, thumb_bl_out_of_range.stdout,
	thumb_bl_out_of_range thumb_bl_out_of_range.o,
	thumb2_bl_in_range.stdout, thumb2_bl_in_range, thumb2_bl_in_range.o
	thumb2_bl_out_of_range.stdout, thumb2_bl_out_of_range,
	thumb2_bl_out_of_range.o): New rules.
	(MOSTLYCLEANFILES): Add arm_bl_in_range, arm_bl_out_of_range,
	thumb_bl_in_range, thumb_bl_out_of_range, thumb2_bl_in_range and
	thumb2_bl_out_of_range
	* testsuite/Makefile.in: Regenerate.
	* testsuite/arm_bl_in_range.s: New file.
	* testsuite/arm_bl_out_of_range.s: Ditto.
	* testsuite/arm_branch_in_range.sh: Ditto.
	* testsuite/arm_branch_range.t: Ditto.
	* testsuite/thumb2_branch_range.t: Ditto.
	* testsuite/thumb_bl_in_range.s: Ditto.
	* testsuite/thumb_bl_out_of_range.s: Ditto.
	* testsuite/thumb_branch_range.t: Ditto.
@
text
@d7557 5
@


1.83
log
@2010-02-18  Doug Kwan  <dougkwan@@google.com>

	* arm-reloc.def: Mark R_ARM_TLS_GD32, R_ARM_TLS_LDM32,
	R_ARM_TLS_LDO32, R_ARM_TLS_IE32 and R_ARM_TLS_LE32 are implemented.
	* arm.cc (Arm_relocation_functions): New forward declaration.
	(Target_arm::Target_arm): Initialize new data members
	got_mod_index_offset_ and tls_base_symbol_defined_.
	(Target_arm::Relocate::relocate_tls): New method.
	(Target_arm::optimize_tls_reloc, Target_arm::define_tls_base_symbol,
	 Target_arm::got_mod_index_entry, Target_arm::rel_tls_desc_section):
	New methods.
   	(Target_arm::Got_type): Add GOT_TYPE_TLS_NOFFSET, GOT_TYPE_OFFSET,
	GOT_TYPE_TLS_PAIR and GOT_TYPE_TLS_DESC.
	(Target_arm::got_mod_index_offset_,
	Target_arm::tls_base_symbol_defined_): New data members.
	(Target_arm::Scan::local, Target::Scan::global,
	Target_arm::Relocate::relocate): Handle 32-bit initial TLS
	relocations.
@
text
@d3550 1
a3550 2
  if ((branch_offset > ARM_MAX_FWD_BRANCH_OFFSET)
      || (branch_offset < ARM_MAX_BWD_BRANCH_OFFSET)
d3553 2
d3556 2
a3557 1
	Reloc_stub::stub_type_for_reloc(r_type, address, branch_target,
d3571 1
a3571 2
	  gold_assert((branch_offset <= ARM_MAX_FWD_BRANCH_OFFSET)
		      && (branch_offset >= ARM_MAX_BWD_BRANCH_OFFSET));
d3679 2
a3680 6
  if ((!thumb2
       && (branch_offset > THM_MAX_FWD_BRANCH_OFFSET
	   || (branch_offset < THM_MAX_BWD_BRANCH_OFFSET)))
      || (thumb2
	  && (branch_offset > THM2_MAX_FWD_BRANCH_OFFSET
	      || (branch_offset < THM2_MAX_BWD_BRANCH_OFFSET)))
d3685 2
d3688 2
a3689 1
	Reloc_stub::stub_type_for_reloc(r_type, address, branch_target,
d3691 1
@


1.82
log
@2010-02-18  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::find_linked_text_section): New method.
	(Arm_relobj::make_exidx_input_section): Pass section index of linked
	text section as a parameter becuase some broken tools may not set
	the link in section header.
	(Target_arm::has_got_section): New method.
	(Target_arm::scan_section_for_cortex_a8_stubs): Treat an input section
	without any mapping symbol as data only.  Remove warning.
	(Arm_relobj::do_read_synbols): If an EXIDX input section has no
	link in its section header, try to discover the link by inspecting the
	REL31 relocation at the beginning of the section.
	(Target_arm::Scan::check_non_pic): Report name of offending relocation
	in error message.
	(Target_arm::Scan::global): Treat any reference to the symbol
	_GLOBAL_OFFSET_TABLE_ as a GOT access.
@
text
@d84 3
d1853 6
a1858 5
      copy_relocs_(elfcpp::R_ARM_COPY), dynbss_(NULL), stub_tables_(),
      stub_factory_(Stub_factory::get_instance()), may_use_blx_(false),
      should_force_pic_veneer_(false), arm_input_section_map_(),
      attributes_section_data_(NULL), fix_cortex_a8_(false),
      cortex_a8_relocs_info_()
d2308 10
d2329 5
d2350 9
d2371 4
d2489 5
a2493 1
    GOT_TYPE_STANDARD = 0	// GOT entry for a regular symbol
d2520 4
d6716 73
d7045 91
d7392 78
d7721 1
a7721 1
    section_size_type /* view_size */ )
d7869 4
d8176 12
d8217 119
@


1.81
log
@2010-02-12  Sriraman Tallam  <tmsriram@@google.com>

	* arm.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* sparc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* powerpc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* i386.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* x86_64.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	(Scan::possible_function_pointer_reloc): New function.
	(Target_x86_64::can_check_for_function_pointers): New function.
	* gc.h (gc_process_relocs): Scan relocation types to determine if
	function pointers were taken for targets that support it.
	* icf.cc (Icf::find_identical_sections): Include functions for
	folding in safe ICF whose pointer is not taken.
	* icf.h (Secn_fptr_taken_set): New typedef.
	(fptr_section_id_): New member.
	(section_has_function_pointers): New function.
	(set_section_has_function_pointers): New function.
	(check_section_for_function_pointers): New function.
	* options.h: Fix comment for safe ICF option.
	* target.h (can_check_for_function_pointers): New function.
	* testsuite/Makefile.am: Add icf_safe_so_test test case.
	Modify icf_safe_test for X86-64.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/icf_safe_so_test.cc: New file.
	* testsuite/icf_safe_so_test.sh: New file.
	* testsuite/icf_safe_test.cc (kept_func_3): New function.
	(main): Change to take pointer to function kept_func_3.
	* testsuite/icf_safe_test.sh (arch_specific_safe_fold): Check if safe
	folding is done correctly for X86-64.
@
text
@d1600 10
d1611 2
a1612 1
  // index SHNDX and section header SHDR.
d1615 2
a1616 1
			   const elfcpp::Shdr<32, big_endian>& shdr);
d2011 5
d5638 11
a5661 15
  // Look for the first mapping symbol in this section.  It should be
  // at (shndx, 0).
  Mapping_symbol_position section_start(shndx, 0);
  typename Mapping_symbols_info::const_iterator p =
    this->mapping_symbols_info_.lower_bound(section_start);

  if (p == this->mapping_symbols_info_.end()
      || p->first != section_start)
    {
      gold_warning(_("Cortex-A8 erratum scanning failed because there "
		     "is no mapping symbols for section %u of %s"),
		   shndx, this->name().c_str());
      return;
    }
 
d5995 81
a6075 2
// Create a new EXIDX input section object for EXIDX section SHNDX with
// header SHDR.
d6081 2
a6082 1
    const elfcpp::Shdr<32, big_endian>& shdr)
a6083 12
  // Link .text section to its .ARM.exidx section in the same object.
  unsigned int text_shndx = this->adjust_shndx(shdr.get_sh_link());

  // Issue an error and ignore this EXIDX section if it does not point
  // to any text section.
  if (text_shndx == elfcpp::SHN_UNDEF)
    {
      gold_error(_("EXIDX section %u in %s has no linked text section"),
		 shndx, this->name().c_str());
      return;
    }
  
d6124 1
d6126 2
a6127 2
  const unsigned char *ps =
    sd->section_headers->data() + shdr_size;
d6143 73
a6215 1
	this->make_exidx_input_section(i, shdr);
d6719 13
a6731 4
      // This prevents us from issuing more than one error per reloc
      // section.  But we can still wind up issuing more than one
      // error per object file.
      if (this->issued_non_pic_error_)
d6733 1
a6733 4
      object->error(_("requires unsupported dynamic reloc; "
		      "recompile with -fPIC"));
      this->issued_non_pic_error_ = true;
      return;
d6965 7
@


1.80
log
@2010-02-11  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::Scan::local): Fix bugs in relocation handling.
	(Target_arm::Scan::global): Ditto.  Also remove a comment before the
	beginning of function.
	(Target_arm::Relocate::relocate): Remove error messages for MOVW_ABS
	and MOVT_ABS relocations.  Those are non issued in scanning.  Fix
	parameter is_32bit in calls to should_apply_static_reloc.
	* testsuite/Makefile.am (check_SCRIPTS): Add arm_abs_global.sh.
	(check_DATA): Add arm_abs_global.stdout.
	(arm_abs_lib.o, libarm_abs.so, arm_abs_global.o, arm_abs_global,
	arm_abs_global.stdout): New rules.
	(MOSTLLYCLEANFILES): Add arm_abs_global
	* Makefile.in: Regenerate.
	* testsuite/arm_abs_global.s: New file.
	* testsuite/arm_abs_global.sh: Ditto.
	* testsuite/arm_abs_lib.s: Ditto.
@
text
@d2174 19
@


1.79
log
@	* output.h (Output_data_dynamic::add_section_size): New method
	that takes two Output_data objects.
	(Output_data_dynamic::Dynamic_entry): Create storage for secondary
	entry param.  Handle it in initializers.
	* output.cc (Output_data_dynamic::Dynamic_entry::write): For
	DYNAMIC_SECTION_SIZE, add in second object size if non-NULL.
	* layout.h (Layout::add_target_dynamic_tags): Add dynrel_includes_plt
	arg.
	* layout.cc (Layout::add_target_dynamic_tags): If dynrel_includes_plt,
	and .rela.plt exists, set DT_REL{,A}SZ to sum of .rela.dyn and .rela.plt
	* arm.cc (Target_arm::do_finalize_sections): Update to pass false
	for dynrel_includes_plt.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::make_plt_entry): Force .rela.dyn to be output
	before .rela.plt
	(Target_sparc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt.
	* powerpc.cc (Target_powerpc::make_plt_entry): Force .rela.dyn to be
	output before .rela.plt
	(Target_powerpc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt when 32-bit.
@
text
@d6575 1
a6575 1
				    const elfcpp::Sym<32, big_endian>&)
d6581 3
d6606 2
a6607 8
    case elfcpp::R_ARM_REL32:
    case elfcpp::R_ARM_THM_CALL:
    case elfcpp::R_ARM_CALL:
    case elfcpp::R_ARM_PREL31:
    case elfcpp::R_ARM_JUMP24:
    case elfcpp::R_ARM_THM_JUMP24:
    case elfcpp::R_ARM_THM_JUMP19:
    case elfcpp::R_ARM_PLT32:
a6609 2
    case elfcpp::R_ARM_ABS12:
    case elfcpp::R_ARM_ABS16:
d6615 47
d6666 1
a6666 6
    case elfcpp::R_ARM_MOVW_BREL_NC:
    case elfcpp::R_ARM_MOVT_BREL:
    case elfcpp::R_ARM_MOVW_BREL:
    case elfcpp::R_ARM_THM_MOVW_BREL_NC:
    case elfcpp::R_ARM_THM_MOVT_BREL:
    case elfcpp::R_ARM_THM_MOVW_BREL:
d6668 1
a6668 4
    case elfcpp::R_ARM_THM_JUMP8:
    case elfcpp::R_ARM_THM_JUMP11:
    case elfcpp::R_ARM_V4BX:
    case elfcpp::R_ARM_THM_PC8:
d6670 1
a6670 1
    case elfcpp::R_ARM_THM_ALU_PREL_11_0:
d6676 8
a6688 3
    case elfcpp::R_ARM_LDR_PC_G0:
    case elfcpp::R_ARM_LDR_PC_G1:
    case elfcpp::R_ARM_LDR_PC_G2:
a6691 3
    case elfcpp::R_ARM_LDRS_PC_G0:
    case elfcpp::R_ARM_LDRS_PC_G1:
    case elfcpp::R_ARM_LDRS_PC_G2:
a6694 3
    case elfcpp::R_ARM_LDC_PC_G0:
    case elfcpp::R_ARM_LDC_PC_G1:
    case elfcpp::R_ARM_LDC_PC_G2:
d6698 10
d6711 1
a6715 4
    case elfcpp::R_ARM_BASE_PREL:
      // FIXME: What about this?
      break;

d6740 1
a6772 2
// FIXME: This only handles a subset of relocation types used by Android
// on ARM v5te devices.
d6790 3
d6796 9
d6806 1
d6808 36
a6843 26
	// Make a dynamic relocation if necessary.
	if (gsym->needs_dynamic_reloc(Symbol::ABSOLUTE_REF))
	  {
	    if (target->may_need_copy_reloc(gsym))
	      {
		target->copy_reloc(symtab, layout, object,
				   data_shndx, output_section, gsym, reloc);
	      }
	    else if (gsym->can_use_relative_reloc(false))
	      {
   		// If we are to add more other reloc types than R_ARM_ABS32,
   		// we need to add check_non_pic(object, r_type) here.
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		rel_dyn->add_global_relative(gsym, elfcpp::R_ARM_RELATIVE,
					     output_section, object,
					     data_shndx, reloc.get_r_offset());
	      }
	    else
	      {
   		// If we are to add more other reloc types than R_ARM_ABS32,
   		// we need to add check_non_pic(object, r_type) here.
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		rel_dyn->add_global(gsym, r_type, output_section, object,
				    data_shndx, reloc.get_r_offset());
	      }
	  }
d6847 14
a6860 4
    case elfcpp::R_ARM_MOVW_ABS_NC:
    case elfcpp::R_ARM_MOVT_ABS:
    case elfcpp::R_ARM_THM_MOVW_ABS_NC:
    case elfcpp::R_ARM_THM_MOVT_ABS:
d6865 1
a6865 11
    case elfcpp::R_ARM_MOVW_BREL_NC:
    case elfcpp::R_ARM_MOVT_BREL:
    case elfcpp::R_ARM_MOVW_BREL:
    case elfcpp::R_ARM_THM_MOVW_BREL_NC:
    case elfcpp::R_ARM_THM_MOVT_BREL:
    case elfcpp::R_ARM_THM_MOVW_BREL:
    case elfcpp::R_ARM_THM_JUMP6:
    case elfcpp::R_ARM_THM_JUMP8:
    case elfcpp::R_ARM_THM_JUMP11:
    case elfcpp::R_ARM_V4BX:
    case elfcpp::R_ARM_THM_PC8:
d6867 1
a6867 1
    case elfcpp::R_ARM_THM_ALU_PREL_11_0:
d6873 8
a6885 3
    case elfcpp::R_ARM_LDR_PC_G0:
    case elfcpp::R_ARM_LDR_PC_G1:
    case elfcpp::R_ARM_LDR_PC_G2:
a6888 3
    case elfcpp::R_ARM_LDRS_PC_G0:
    case elfcpp::R_ARM_LDRS_PC_G1:
    case elfcpp::R_ARM_LDRS_PC_G2:
a6891 3
    case elfcpp::R_ARM_LDC_PC_G0:
    case elfcpp::R_ARM_LDC_PC_G1:
    case elfcpp::R_ARM_LDC_PC_G2:
d6895 7
a6901 20
      break;

    case elfcpp::R_ARM_THM_ABS5:
    case elfcpp::R_ARM_ABS8:
    case elfcpp::R_ARM_ABS12:
    case elfcpp::R_ARM_ABS16:
    case elfcpp::R_ARM_BASE_ABS:
      {
	// No dynamic relocs of this kinds.
	// Report the error in case of PIC.
	int flags = Symbol::NON_PIC_REF;
	if (gsym->type() == elfcpp::STT_FUNC
	    || gsym->type() == elfcpp::STT_ARM_TFUNC)
	  flags |= Symbol::FUNCTION_CALL;
	if (gsym->needs_dynamic_reloc(flags))
	  check_non_pic(object, r_type);
      }
      break;

    case elfcpp::R_ARM_REL32:
d6923 4
d6929 2
d6932 12
a6943 5
    case elfcpp::R_ARM_CALL:
    case elfcpp::R_ARM_THM_CALL:
    case elfcpp::R_ARM_PLT32:
    case elfcpp::R_ARM_PREL31:
    case elfcpp::R_ARM_PC24:
a6957 9
    case elfcpp::R_ARM_GOTOFF32:
      // We need a GOT section.
      target->got_section(symtab, layout);
      break;

    case elfcpp::R_ARM_BASE_PREL:
      // FIXME: What about this?
      break;
      
d6959 1
d6989 2
a6990 1
      // This should have been mapped to another type already.
d7460 1
a7460 1
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
a7464 3
      else
	gold_error(_("relocation R_ARM_MOVW_ABS_NC cannot be used when making"
		     "a shared object; recompile with -fPIC"));
d7468 1
a7468 1
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
a7470 3
      else
	gold_error(_("relocation R_ARM_MOVT_ABS cannot be used when making"
		     "a shared object; recompile with -fPIC"));
d7474 1
a7474 1
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
a7477 3
      else
	gold_error(_("relocation R_ARM_THM_MOVW_ABS_NC cannot be used when"
		     "making a shared object; recompile with -fPIC"));
d7481 1
a7481 1
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
a7484 3
      else
	gold_error(_("relocation R_ARM_THM_MOVT_ABS cannot be used when"
		     "making a shared object; recompile with -fPIC"));
d7557 1
a7557 1
	if (!should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
@


1.78
log
@2010-02-08  Doug Kwan  <dougkwan@@google.com>

        * arm.cc (Arm_relobj::simple_input_section_output_address): New
        method.
        (Arm_relobj::section_needs_cortex_a8_stub_scanning,
        Arm_relobj::scan_section_for_cortex_a8_stubs,
        Arm_relobj::do_relocation_section): Instead of calling
        Output_section::output_address, use faster
        Arm_relobj::simple_input_section_output_address.
@
text
@d7097 1
a7097 1
				  this->rel_dyn_, true);
@


1.77
log
@2010-02-05  Doug Kwan  <dougkwan@@google.com>

	PR 11247
	* arm.cc (Arm_relobj::section_is_scannable): New method.
	(Arm_relobj::section_needs_reloc_stub_scanning): Use it.
	(Arm_relobj::section_needs_cortex_a8_stub_scanning): Same.
@
text
@d1606 5
d5546 23
a5582 3
  // Find output address of section.
  Arm_address address = os->output_address(this, shndx, 0);

d5585 1
d5602 2
a5603 1
  Arm_address output_address = os->output_address(this, shndx, 0);
d5942 2
a5943 1
	  Arm_address section_address = os->output_address(this, i, 0);
@


1.76
log
@2010-02-03  Doug Kwan  <dougkwan@@google.com>

	* arm-reloc-property.cc
	(Arm_reloc_property_table::reloc_name_in_error_message): New method
	definition.
	* arm-reloc-property.h
	(Arm_reloc_property_table::get_implemented_static_reloc_property):
	New method definition.
	(Arm_reloc_property_table::reloc_name_in_error_message): New method
	declaration.
	* arm-reloc.def (THM_MOVT_ABS, THM_MOVT_PREL, THM_MOVT_BREL): Change
	overflow to N.
	(GOT_PREL): Change implemented to Y.
	* arm.cc (Target_arm::reloc_uses_thumb_bit): Remove method.
	(Target_arm::Relocate::reloc_needs_sym_origin): Remove method.
	(Arm_relocate_functions::movw_abs_nc): Remove method.
	(Arm_relocate_functions::movt_abs): Ditto.
	(Arm_relocate_functions::thm_movw_abs_nc): Ditto.
	(Arm_relocate_functions::thm_movt_abs): Ditto.
	(Arm_relocate_functions::movw_rel_nc): Ditto.
	(Arm_relocate_functions::movw_rel): Ditto.
	(Arm_relocate_functions::movt_rel): Ditto.
	(Arm_relocate_functions:thm_movw_rel_nc): Ditto.
	(Arm_relocate_functions:thm_movw_rel): Ditto.
	(Arm_relocate_functions:thm_movt_rel): Ditto.
	(Arm_relocate_functions::movw, Arm_relocate_functions::movt,
	(Arm_relocate_functions::thm_movw, Arm_relocate_functions::thm_movt):
	New method definitions.
	(Arm_relocation_functions::arm_grp_alu): Add assertion for group index.
	(Arm_relocation_functions::arm_grp_ldr): Ditto.
	(Arm_relocation_functions::arm_grp_ldrs): Ditto.
	(Arm_relocation_functions::arm_grp_ldc): Ditto.
	(Target_arm::Relocate::relocate): Check for non-static or
	unimplemented relocation code and exit early.  Change calls to
	Target_arm::reloc_uses_thumb_bit and
	Target_arm::Reloc::reloc_needs_sym_origin to use relocation property
	instead.  Refactor code to handle similar relocations to increase
	code sharing.  Remove check for unsupported relocation code in switch
	statement.
	(Target_arm::Relocatable_size_for_reloc::get_size_for_reloc): Use
	relocation property table to find out size.  Change error message to
	print out the name of a relocation code instead of the numeric value.
	(Target_arm::scan_reloc_for_stub): Use relocation property table
	instead of calling Target_arm::reloc_uses_thumb_bit().
@
text
@d1583 5
d5455 38
a5512 20
  // Ignore reloc section with bad info.  This error will be
  // reported in the final link.
  unsigned int index = this->adjust_shndx(shdr.get_sh_info());
  if (index >= this->shnum())
    return false;

  // This relocation section is against a section which we
  // discarded or if the section is folded into another
  // section due to ICF.
  if (out_sections[index] == NULL || symtab->is_section_folded(this, index))
    return false;

  // Check the section to which relocations are applied.  Ignore relocations
  // to unallocated sections or EXIDX sections.
  const unsigned int shdr_size = elfcpp::Elf_sizes<32>::shdr_size;
  const elfcpp::Shdr<32, big_endian> data_shdr(pshdrs + index * shdr_size);
  if ((data_shdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0
      || data_shdr.get_sh_type() == elfcpp::SHT_ARM_EXIDX)
    return false;

d5529 10
a5538 1
  return true;
d5552 1
a5552 3
  // We only scan non-empty code sections.
  if ((shdr.get_sh_flags() & elfcpp::SHF_EXECINSTR) == 0
      || shdr.get_sh_size() == 0)
a5554 4
  // Ignore discarded or ICF'ed sections.
  if (os == NULL || symtab->is_section_folded(this, shndx))
    return false;
  
@


1.75
log
@2010-02-03  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::relocate_section): Do view adjustment for all
	types of relaxed input section.
@
text
@a2045 4
  // Whether relocation type uses LSB to distinguish THUMB addresses.
  static bool
  reloc_uses_thumb_bit(unsigned int r_type);

a2257 41

    // Return whether we need to calculate the addressing origin of
    // the output segment defining the symbol - B(S).
    static bool
    reloc_needs_sym_origin(unsigned int r_type)
    {
      switch (r_type)
	{
	case elfcpp::R_ARM_SBREL32:
	case elfcpp::R_ARM_BASE_PREL:
	case elfcpp::R_ARM_BASE_ABS:
	case elfcpp::R_ARM_LDR_SBREL_11_0_NC:
	case elfcpp::R_ARM_ALU_SBREL_19_12_NC:
	case elfcpp::R_ARM_ALU_SBREL_27_20_CK:
	case elfcpp::R_ARM_SBREL31:
	case elfcpp::R_ARM_ALU_SB_G0_NC:
	case elfcpp::R_ARM_ALU_SB_G0:
	case elfcpp::R_ARM_ALU_SB_G1_NC:
	case elfcpp::R_ARM_ALU_SB_G1:
	case elfcpp::R_ARM_ALU_SB_G2:
	case elfcpp::R_ARM_LDR_SB_G0:
	case elfcpp::R_ARM_LDR_SB_G1:
	case elfcpp::R_ARM_LDR_SB_G2:
	case elfcpp::R_ARM_LDRS_SB_G0:
	case elfcpp::R_ARM_LDRS_SB_G1:
	case elfcpp::R_ARM_LDRS_SB_G2:
	case elfcpp::R_ARM_LDC_SB_G0:
	case elfcpp::R_ARM_LDC_SB_G1:
	case elfcpp::R_ARM_LDC_SB_G2:
	case elfcpp::R_ARM_MOVW_BREL_NC:
	case elfcpp::R_ARM_MOVT_BREL:
	case elfcpp::R_ARM_MOVW_BREL:
	case elfcpp::R_ARM_THM_MOVW_BREL_NC:
	case elfcpp::R_ARM_THM_MOVT_BREL:
	case elfcpp::R_ARM_THM_MOVW_BREL:
	  return true;

	default:
	  return false;
	}
    }
d2957 1
a2957 72
  // R_ARM_MOVW_ABS_NC: (S + A) | T
  static inline typename This::Status 
  movw_abs_nc(unsigned char *view,
	      const Sized_relobj<32, big_endian>* object,
	      const Symbol_value<32>* psymval,
	      Arm_address thumb_bit)
  {
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
    Valtype addend =  This::extract_arm_movw_movt_addend(val);
    Valtype x = psymval->value(object, addend) | thumb_bit;
    val = This::insert_val_arm_movw_movt(val, x);
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
    return This::STATUS_OKAY;
  }

  // R_ARM_MOVT_ABS: S + A
  static inline typename This::Status
  movt_abs(unsigned char *view,
	   const Sized_relobj<32, big_endian>* object,
           const Symbol_value<32>* psymval)
  {
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
    Valtype addend = This::extract_arm_movw_movt_addend(val);
    Valtype x = psymval->value(object, addend) >> 16;
    val = This::insert_val_arm_movw_movt(val, x);
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
    return This::STATUS_OKAY;
  }

  //  R_ARM_THM_MOVW_ABS_NC: S + A | T
  static inline typename This::Status 
  thm_movw_abs_nc(unsigned char *view,
	          const Sized_relobj<32, big_endian>* object,
	          const Symbol_value<32>* psymval,
	          Arm_address thumb_bit)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Reltype val = ((elfcpp::Swap<16, big_endian>::readval(wv) << 16)
		   | elfcpp::Swap<16, big_endian>::readval(wv + 1));
    Reltype addend = extract_thumb_movw_movt_addend(val);
    Reltype x = psymval->value(object, addend) | thumb_bit;
    val = This::insert_val_thumb_movw_movt(val, x);
    elfcpp::Swap<16, big_endian>::writeval(wv, val >> 16);
    elfcpp::Swap<16, big_endian>::writeval(wv + 1, val & 0xffff);
    return This::STATUS_OKAY;
  }

  //  R_ARM_THM_MOVT_ABS: S + A
  static inline typename This::Status 
  thm_movt_abs(unsigned char *view,
	       const Sized_relobj<32, big_endian>* object,
	       const Symbol_value<32>* psymval)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Reltype val = ((elfcpp::Swap<16, big_endian>::readval(wv) << 16)
		   | elfcpp::Swap<16, big_endian>::readval(wv + 1));
    Reltype addend = This::extract_thumb_movw_movt_addend(val);
    Reltype x = psymval->value(object, addend) >> 16;
    val = This::insert_val_thumb_movw_movt(val, x);
    elfcpp::Swap<16, big_endian>::writeval(wv, val >> 16);
    elfcpp::Swap<16, big_endian>::writeval(wv + 1, val & 0xffff);
    return This::STATUS_OKAY;
  }

d2959 2
a2960 1
  // R_ARM_MOVW_BREL_NC: ((S + A) | T)  B(S)
d2962 6
a2967 5
  movw_rel_nc(unsigned char* view,
	      const Sized_relobj<32, big_endian>* object,
	      const Symbol_value<32>* psymval,
	      Arm_address address,
	      Arm_address thumb_bit)
d2973 2
a2974 1
    Valtype x = (psymval->value(object, addend) | thumb_bit) - address;
d2977 3
a2979 20
    return This::STATUS_OKAY;
  }

  // R_ARM_MOVW_BREL: ((S + A) | T)  B(S)
  static inline typename This::Status
  movw_rel(unsigned char* view,
	   const Sized_relobj<32, big_endian>* object,
	   const Symbol_value<32>* psymval,
	   Arm_address address,
	   Arm_address thumb_bit)
  {
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
    Valtype addend = This::extract_arm_movw_movt_addend(val);
    Valtype x = (psymval->value(object, addend) | thumb_bit) - address;
    val = This::insert_val_arm_movw_movt(val, x);
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
    return ((x >= 0x10000) ?
    	    This::STATUS_OVERFLOW : This::STATUS_OKAY);
d2982 1
d2984 1
a2984 1
  // R_ARM_MOVT_BREL: S + A  B(S)
d2986 4
a2989 4
  movt_rel(unsigned char* view,
	   const Sized_relobj<32, big_endian>* object,
	   const Symbol_value<32>* psymval,
           Arm_address address)
d2995 1
a2995 1
    Valtype x = (psymval->value(object, addend) - address) >> 16;
d2998 1
d3002 1
d3004 2
a3005 1
  // R_ARM_THM_MOVW_BREL_NC: ((S + A) | T)  B(S)
d3007 6
a3012 5
  thm_movw_rel_nc(unsigned char *view,
	          const Sized_relobj<32, big_endian>* object,
	          const Symbol_value<32>* psymval,
	          Arm_address address,
	          Arm_address thumb_bit)
d3020 2
a3021 1
    Reltype x = (psymval->value(object, addend) | thumb_bit) - address;
d3025 3
a3027 23
    return This::STATUS_OKAY;
  }

  // R_ARM_THM_MOVW_BREL: ((S + A) | T)  B(S)
  static inline typename This::Status
  thm_movw_rel(unsigned char *view,
	       const Sized_relobj<32, big_endian>* object,
	       const Symbol_value<32>* psymval,
	       Arm_address address,
	       Arm_address thumb_bit)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Reltype val = (elfcpp::Swap<16, big_endian>::readval(wv) << 16)
		  | elfcpp::Swap<16, big_endian>::readval(wv + 1);
    Reltype addend = This::extract_thumb_movw_movt_addend(val);
    Reltype x = (psymval->value(object, addend) | thumb_bit) - address;
    val = This::insert_val_thumb_movw_movt(val, x);
    elfcpp::Swap<16, big_endian>::writeval(wv, val >> 16);
    elfcpp::Swap<16, big_endian>::writeval(wv + 1, val & 0xffff);
    return ((x >= 0x10000) ?
    	    This::STATUS_OVERFLOW : This::STATUS_OKAY);
d3030 1
d3032 1
a3032 1
  // R_ARM_THM_MOVT_BREL: S + A  B(S)
d3034 4
a3037 4
  thm_movt_rel(unsigned char* view,
	       const Sized_relobj<32, big_endian>* object,
	       const Symbol_value<32>* psymval,
	       Arm_address address)
d3045 1
a3045 1
    Reltype x = (psymval->value(object, addend) - address) >> 16;
d3223 1
d3278 1
d3316 1
d3354 1
d7150 11
d7223 1
a7223 1
      && Target_arm<big_endian>::reloc_uses_thumb_bit(r_type) 
d7269 1
a7269 1
  if (Relocate::reloc_needs_sym_origin(r_type))
d7288 22
d7312 1
d7354 3
a7356 3
	reloc_status = Arm_relocate_functions::movw_abs_nc(view, object,
							   psymval,
       						           thumb_bit);
d7365 1
a7365 1
	reloc_status = Arm_relocate_functions::movt_abs(view, object, psymval);
d7374 2
a7375 3
	reloc_status = Arm_relocate_functions::thm_movw_abs_nc(view, object,
							       psymval,
       						               thumb_bit);
d7384 2
a7385 2
	reloc_status = Arm_relocate_functions::thm_movt_abs(view, object,
							    psymval);
a7391 5
      reloc_status = Arm_relocate_functions::movw_rel_nc(view, object,
							 psymval, address,
							 thumb_bit);
      break;

a7392 5
      reloc_status = Arm_relocate_functions::movw_rel_nc(view, object,
							 psymval, sym_origin,
							 thumb_bit);
      break;

d7394 4
a7397 3
      reloc_status = Arm_relocate_functions::movw_rel(view, object,
						      psymval, sym_origin,
						      thumb_bit);
a7400 4
      reloc_status = Arm_relocate_functions::movt_rel(view, object,
                                                      psymval, address);
      break;

d7402 3
a7404 2
      reloc_status = Arm_relocate_functions::movt_rel(view, object,
                                                      psymval, sym_origin);
a7407 5
      reloc_status = Arm_relocate_functions::thm_movw_rel_nc(view, object,
							     psymval, address,
							     thumb_bit);
      break;

a7408 6
      reloc_status = Arm_relocate_functions::thm_movw_rel_nc(view, object,
							     psymval,
							     sym_origin,
							     thumb_bit);
      break;

d7410 4
a7413 3
      reloc_status = Arm_relocate_functions::thm_movw_rel(view, object,
							  psymval, sym_origin,
							  thumb_bit);
d7417 4
a7420 2
      reloc_status = Arm_relocate_functions::thm_movt_rel(view, object,
							  psymval, address);
a7422 5
    case elfcpp::R_ARM_THM_MOVT_BREL:
      reloc_status = Arm_relocate_functions::thm_movt_rel(view, object,
							  psymval, sym_origin);
      break;

a7555 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_alu(view, object, psymval, 0,
					      address, thumb_bit, false);
      break;

a7556 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_alu(view, object, psymval, 0,
					      address, thumb_bit, true);
      break;

a7557 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_alu(view, object, psymval, 1,
					      address, thumb_bit, false);
      break;

a7558 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_alu(view, object, psymval, 1,
					      address, thumb_bit, true);
      break;

a7559 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_alu(view, object, psymval, 2,
					      address, thumb_bit, true);
      break;

a7560 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_alu(view, object, psymval, 0,
					      sym_origin, thumb_bit, false);
      break;

a7561 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_alu(view, object, psymval, 0,
					      sym_origin, thumb_bit, true);
      break;

a7562 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_alu(view, object, psymval, 1,
					      sym_origin, thumb_bit, false);
      break;

a7563 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_alu(view, object, psymval, 1,
					      sym_origin, thumb_bit, true);
      break;

d7566 4
a7569 2
	  Arm_relocate_functions::arm_grp_alu(view, object, psymval, 2,
					      sym_origin, thumb_bit, true);
a7572 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldr(view, object, psymval, 0,
					      address);
      break;

a7573 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldr(view, object, psymval, 1,
					      address);
      break;

a7574 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldr(view, object, psymval, 2,
					      address);
      break;

a7575 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldr(view, object, psymval, 0,
					      sym_origin);
      break;

a7576 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldr(view, object, psymval, 1,
					      sym_origin);
      break;

d7579 3
a7581 2
	  Arm_relocate_functions::arm_grp_ldr(view, object, psymval, 2,
					      sym_origin);
a7584 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldrs(view, object, psymval, 0,
					       address);
      break;

a7585 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldrs(view, object, psymval, 1,
					       address);
      break;

a7586 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldrs(view, object, psymval, 2,
					       address);
      break;

a7587 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldrs(view, object, psymval, 0,
					       sym_origin);
      break;

a7588 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldrs(view, object, psymval, 1,
					       sym_origin);
      break;

d7591 3
a7593 2
	  Arm_relocate_functions::arm_grp_ldrs(view, object, psymval, 2,
					       sym_origin);
a7596 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldc(view, object, psymval, 0,
					      address);
      break;

a7597 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldc(view, object, psymval, 1,
					      address);
      break;

a7598 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldc(view, object, psymval, 2,
					      address);
      break;

a7599 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldc(view, object, psymval, 0,
					      sym_origin);
      break;

a7600 5
      reloc_status =
	  Arm_relocate_functions::arm_grp_ldc(view, object, psymval, 1,
					      sym_origin);
      break;

d7603 3
a7605 16
	  Arm_relocate_functions::arm_grp_ldc(view, object, psymval, 2,
					      sym_origin);
      break;

    case elfcpp::R_ARM_TARGET1:
      // This should have been mapped to another type already.
      // Fall through.
    case elfcpp::R_ARM_COPY:
    case elfcpp::R_ARM_GLOB_DAT:
    case elfcpp::R_ARM_JUMP_SLOT:
    case elfcpp::R_ARM_RELATIVE:
      // These are relocations which should only be seen by the
      // dynamic linker, and should never be seen here.
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			     _("unexpected reloc %u in object file"),
			     r_type);
d7609 1
a7609 4
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			     _("unsupported reloc %u"),
			     r_type);
      break;
d7703 5
a7707 1
  switch (r_type)
d7709 4
a7712 90
    case elfcpp::R_ARM_NONE:
      return 0;

    case elfcpp::R_ARM_ABS8:
      return 1;

    case elfcpp::R_ARM_ABS16:
    case elfcpp::R_ARM_THM_ABS5:
    case elfcpp::R_ARM_THM_JUMP6:
    case elfcpp::R_ARM_THM_JUMP8:
    case elfcpp::R_ARM_THM_JUMP11:
    case elfcpp::R_ARM_THM_PC8:
      return 2;

    case elfcpp::R_ARM_ABS32:
    case elfcpp::R_ARM_ABS32_NOI:
    case elfcpp::R_ARM_ABS12:
    case elfcpp::R_ARM_BASE_ABS:
    case elfcpp::R_ARM_REL32:
    case elfcpp::R_ARM_THM_CALL:
    case elfcpp::R_ARM_GOTOFF32:
    case elfcpp::R_ARM_BASE_PREL:
    case elfcpp::R_ARM_GOT_BREL:
    case elfcpp::R_ARM_GOT_PREL:
    case elfcpp::R_ARM_PLT32:
    case elfcpp::R_ARM_CALL:
    case elfcpp::R_ARM_JUMP24:
    case elfcpp::R_ARM_PREL31:
    case elfcpp::R_ARM_MOVW_ABS_NC:
    case elfcpp::R_ARM_MOVT_ABS:
    case elfcpp::R_ARM_THM_MOVW_ABS_NC:
    case elfcpp::R_ARM_THM_MOVT_ABS:
    case elfcpp::R_ARM_MOVW_PREL_NC:
    case elfcpp::R_ARM_MOVT_PREL:
    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
    case elfcpp::R_ARM_THM_MOVT_PREL:
    case elfcpp::R_ARM_MOVW_BREL_NC:
    case elfcpp::R_ARM_MOVT_BREL:
    case elfcpp::R_ARM_MOVW_BREL:
    case elfcpp::R_ARM_THM_MOVW_BREL_NC:
    case elfcpp::R_ARM_THM_MOVT_BREL:
    case elfcpp::R_ARM_THM_MOVW_BREL:
    case elfcpp::R_ARM_V4BX:
    case elfcpp::R_ARM_THM_PC12:
    case elfcpp::R_ARM_THM_ALU_PREL_11_0:
    case elfcpp::R_ARM_ALU_PC_G0_NC:
    case elfcpp::R_ARM_ALU_PC_G0:
    case elfcpp::R_ARM_ALU_PC_G1_NC:
    case elfcpp::R_ARM_ALU_PC_G1:
    case elfcpp::R_ARM_ALU_PC_G2:
    case elfcpp::R_ARM_ALU_SB_G0_NC:
    case elfcpp::R_ARM_ALU_SB_G0:
    case elfcpp::R_ARM_ALU_SB_G1_NC:
    case elfcpp::R_ARM_ALU_SB_G1:
    case elfcpp::R_ARM_ALU_SB_G2:
    case elfcpp::R_ARM_LDR_PC_G0:
    case elfcpp::R_ARM_LDR_PC_G1:
    case elfcpp::R_ARM_LDR_PC_G2:
    case elfcpp::R_ARM_LDR_SB_G0:
    case elfcpp::R_ARM_LDR_SB_G1:
    case elfcpp::R_ARM_LDR_SB_G2:
    case elfcpp::R_ARM_LDRS_PC_G0:
    case elfcpp::R_ARM_LDRS_PC_G1:
    case elfcpp::R_ARM_LDRS_PC_G2:
    case elfcpp::R_ARM_LDRS_SB_G0:
    case elfcpp::R_ARM_LDRS_SB_G1:
    case elfcpp::R_ARM_LDRS_SB_G2:
    case elfcpp::R_ARM_LDC_PC_G0:
    case elfcpp::R_ARM_LDC_PC_G1:
    case elfcpp::R_ARM_LDC_PC_G2:
    case elfcpp::R_ARM_LDC_SB_G0:
    case elfcpp::R_ARM_LDC_SB_G1:
    case elfcpp::R_ARM_LDC_SB_G2:
      return 4;

    case elfcpp::R_ARM_TARGET1:
      // This should have been mapped to another type already.
      // Fall through.
    case elfcpp::R_ARM_COPY:
    case elfcpp::R_ARM_GLOB_DAT:
    case elfcpp::R_ARM_JUMP_SLOT:
    case elfcpp::R_ARM_RELATIVE:
      // These are relocations which should only be seen by the
      // dynamic linker, and should never be seen here.
      gold_error(_("%s: unexpected reloc %u in object file"),
		 object->name().c_str(), r_type);
      return 0;

    default:
      object->error(_("unsupported reloc %u in object file"), r_type);
a8714 48
// Return whether a relocation type used the LSB to distinguish THUMB
// addresses.
template<bool big_endian>
bool
Target_arm<big_endian>::reloc_uses_thumb_bit(unsigned int r_type)
{
  switch (r_type)
    {
    case elfcpp::R_ARM_PC24:
    case elfcpp::R_ARM_ABS32:
    case elfcpp::R_ARM_REL32:
    case elfcpp::R_ARM_SBREL32:
    case elfcpp::R_ARM_THM_CALL:
    case elfcpp::R_ARM_GLOB_DAT:
    case elfcpp::R_ARM_JUMP_SLOT:
    case elfcpp::R_ARM_GOTOFF32:
    case elfcpp::R_ARM_PLT32:
    case elfcpp::R_ARM_CALL:
    case elfcpp::R_ARM_JUMP24:
    case elfcpp::R_ARM_THM_JUMP24:
    case elfcpp::R_ARM_SBREL31:
    case elfcpp::R_ARM_PREL31:
    case elfcpp::R_ARM_MOVW_ABS_NC:
    case elfcpp::R_ARM_MOVW_PREL_NC:
    case elfcpp::R_ARM_THM_MOVW_ABS_NC:
    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
    case elfcpp::R_ARM_THM_JUMP19:
    case elfcpp::R_ARM_THM_ALU_PREL_11_0:
    case elfcpp::R_ARM_ALU_PC_G0_NC:
    case elfcpp::R_ARM_ALU_PC_G0:
    case elfcpp::R_ARM_ALU_PC_G1_NC:
    case elfcpp::R_ARM_ALU_PC_G1:
    case elfcpp::R_ARM_ALU_PC_G2:
    case elfcpp::R_ARM_ALU_SB_G0_NC:
    case elfcpp::R_ARM_ALU_SB_G0:
    case elfcpp::R_ARM_ALU_SB_G1_NC:
    case elfcpp::R_ARM_ALU_SB_G1:
    case elfcpp::R_ARM_ALU_SB_G2:
    case elfcpp::R_ARM_MOVW_BREL_NC:
    case elfcpp::R_ARM_MOVW_BREL:
    case elfcpp::R_ARM_THM_MOVW_BREL_NC:
    case elfcpp::R_ARM_THM_MOVW_BREL:
      return true;
    default:
      return false;
    }
}

d8849 3
d8853 1
a8853 1
      && Target_arm<big_endian>::reloc_uses_thumb_bit(r_type)
@


1.74
log
@2010-02-02  Doug Kwan  <dougkwan@@google.com>

	* Makefile.am (HFILES): Add arm-reloc-property.h.
	(DEFFILES): New.
 	(TARGETSOURCES): Add arm-reloc-property.cc
 	(ALL_TARGETOBJS): Add arm-reloc-property.$(OBJEXT)
	(libgold_a_SOURCES): $(DEFFILES)
	* Makefile.in: Regenerate.
	* arm-reloc-property.cc: New file.
	* arm-reloc-property.h: New file.
	* arm-reloc.def: New file.
	* arm.cc: Update comments.
	(arm-reloc-property.h): New included header.
	(arm_reloc_property_table): New global variable.
	(Target_arm::do_select_as_default_target): New method definition.
	* configure.tgt (armeb*-*-*,armbe*-*-*,arm*-*-*): Add
	arm-reloc-property to targ_extra_obj.
	* parameters.cc (set_parameters_target): Call
	Target::select_as_default_target().
	* target.h (Target::select_as_default_target): New method definition.
	(Target::do_select_as_default_target): Same.
@
text
@d7919 11
a7929 2
  Arm_input_section<big_endian>* arm_input_section =
    this->find_arm_input_section(relinfo->object, relinfo->data_shndx);
d7931 9
a7939 17
  // This is an ARM input section and the view covers the whole output
  // section.
  if (arm_input_section != NULL)
    {
      gold_assert(needs_special_offset_handling);
      Arm_address section_address = arm_input_section->address();
      section_size_type section_size = arm_input_section->data_size();

      gold_assert((arm_input_section->address() >= address)
		  && ((arm_input_section->address()
		       + arm_input_section->data_size())
		      <= (address + view_size)));

      off_t offset = section_address - address;
      view += offset;
      address += offset;
      view_size = section_size;
@


1.73
log
@2010-02-01  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_exidx_fixup::Arm_exidx_fixup): Initialize
	first_output_text_section_.
	(Arm_exidx_fixup::first_output_text_section): New method definition.
	(Arm_exidx_fixup::first_output_text_section_): New data member.
	(Arm_exidx_fixup::process_exidx_section): Record the first text
	output section seen.
	(Arm_output_section::fix_exidx_coverage): Set correct linked section
	and entsize in output section header.
@
text
@d53 1
d103 1
a103 20
// - Support the following relocation types as needed:
//	R_ARM_SBREL32
//	R_ARM_LDR_SBREL_11_0_NC
//	R_ARM_ALU_SBREL_19_12_NC
//	R_ARM_ALU_SBREL_27_20_CK
//	R_ARM_SBREL31
//	R_ARM_REL32_NOI
//	R_ARM_PLT32_ABS
//	R_ARM_GOT_ABS
//	R_ARM_GOT_BREL12
//	R_ARM_GOTOFF12
//	R_ARM_TLS_GD32
//	R_ARM_TLS_LDM32
//	R_ARM_TLS_LDO32
//	R_ARM_TLS_IE32
//	R_ARM_TLS_LE32
//	R_ARM_TLS_LDO12
//	R_ARM_TLS_LE12
//	R_ARM_TLS_IE12GP
//
d108 14
d2132 11
@


1.72
log
@2010-01-29  Viktor Kutuzov  <vkutuzov@@accesssoftek.com>

	* gold/arm.cc: Added support for the ARM relocations: R_ARM_THM_PC8,
	R_ARM_THM_PC12, R_ARM_THM_ALU_PREL_11_0.
	(Arm_relocate_functions::thm_alu11): New Method.
	(Arm_relocate_functions::thm_pc8): New Method.
	(Arm_relocate_functions::thm_pc12): New Method.
	(Target_arm::Scan::local): Handle the relocations.
	(Target_arm::Scan::global): Likewise.
	(Target_arm::Relocate::relocate): Likewise.
	(Target_arm:Relocatable_size_for_reloc::get_size_for_reloc): Likewise.
@
text
@d1213 1
a1213 1
      section_offset_map_(NULL)
d1234 6
d1282 3
d5171 11
d5570 5
@


1.71
log
@2010-01-29  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::Scan::global): General PLTs for the same set
	of relocation types as ld.
@
text
@a103 1
//	R_ARM_THM_PC8
a107 2
//	R_ARM_THM_ALU_PREL_11_0
//	R_ARM_THM_PC12
d3179 109
d6687 3
d6856 3
d7638 16
d7946 1
d7978 2
@


1.70
log
@2010-01-29  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relocate_functions::arm_branch_common) Change visibility
	to public.
	(Arm_relocate_functions::thumb_branch_common): Ditto.
	(Arm_relocate_functions::thm_call, Arm_relocate_functions::thm_jump24,
	Arm_relocate_functions::thm_xpc22, Arm_relocate_functions::plt32,
	Arm_relocate_functions::xpc25, Arm_relocate_functions::call,
	Arm_relocate_functions::jump24): Remove.
	(Target_arm::Relocate::relocate): Adjust code to call
	Arm_relocation_functions::arm_branch_common and
	Arm_relocation_functions::thumb_branch_common instead of their removed
	wrappers.  Merge switch-cases together to reduce source code size.
@
text
@a6794 3
      break;

    case elfcpp::R_ARM_PREL31:
a6820 19

      if (Target_arm<big_endian>::Scan::symbol_needs_plt_entry(gsym))
	target->make_plt_entry(symtab, layout, gsym);
      else
	{
	   // Check to see if this is a function that would need a PLT
	   // but does not get one because the function symbol is untyped.
	   // This happens in assembly code missing a proper .type directive.
	  if ((!gsym->is_undefined() || parameters->options().shared())
	      && !parameters->doing_static_link()
	      && gsym->type() == elfcpp::STT_NOTYPE
	      && (gsym->is_from_dynobj()
		  || gsym->is_undefined()
		  || gsym->is_preemptible()))
	    gold_error(_("%s is not a function."),
		       gsym->demangled_name().c_str());
	}
      break;

d6822 2
@


1.69
log
@2010-01-29  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::Arm_relobj): Initialize new data member
	output_local_symbol_count_needs_update_.
	(Arm_relobj::output_local_symbol_count_needs_update,
	 Arm_relobj::set_output_local_symbol_count_needs_update,
	 Arm_relobj::update_output_local_symbol_count): New methods.
	(Arm_relobj::output_local_symbol_count_needs_update_): New data
	member.
	(Arm_exidx_cantunwind::do_fixed_endian_write): Write address
	of pointed function as in a R_ARM_PREL31 relocation.
	(Arm_output_section<big_endian>::fix_exidx_coverage): Mark objects
	for output local symbol count updating.
	(Target_arm::do_relax): Update output local symbol counts in objects
	if necessary.
	* object.h (Sized_relobj::set_output_local_symbol_count): New method.
@
text
@d2662 1
a2676 1
 public:
a2865 26
  // R_ARM_THM_CALL: (S + A) | T - P
  static inline typename This::Status
  thm_call(const Relocate_info<32, big_endian>* relinfo, unsigned char *view,
	   const Sized_symbol<32>* gsym, const Arm_relobj<big_endian>* object,
	   unsigned int r_sym, const Symbol_value<32>* psymval,
	   Arm_address address, Arm_address thumb_bit,
	   bool is_weakly_undefined_without_plt)
  {
    return thumb_branch_common(elfcpp::R_ARM_THM_CALL, relinfo, view, gsym,
			       object, r_sym, psymval, address, thumb_bit,
			       is_weakly_undefined_without_plt);
  }

  // R_ARM_THM_JUMP24: (S + A) | T - P
  static inline typename This::Status
  thm_jump24(const Relocate_info<32, big_endian>* relinfo, unsigned char *view,
	     const Sized_symbol<32>* gsym, const Arm_relobj<big_endian>* object,
	     unsigned int r_sym, const Symbol_value<32>* psymval,
	     Arm_address address, Arm_address thumb_bit,
	     bool is_weakly_undefined_without_plt)
  {
    return thumb_branch_common(elfcpp::R_ARM_THM_JUMP24, relinfo, view, gsym,
			       object, r_sym, psymval, address, thumb_bit,
			       is_weakly_undefined_without_plt);
  }

a2871 13
  // R_ARM_THM_XPC22: (S + A) | T - P
  static inline typename This::Status
  thm_xpc22(const Relocate_info<32, big_endian>* relinfo, unsigned char *view,
	    const Sized_symbol<32>* gsym, const Arm_relobj<big_endian>* object,
	    unsigned int r_sym, const Symbol_value<32>* psymval,
	    Arm_address address, Arm_address thumb_bit,
	    bool is_weakly_undefined_without_plt)
  {
    return thumb_branch_common(elfcpp::R_ARM_THM_XPC22, relinfo, view, gsym,
			       object, r_sym, psymval, address, thumb_bit,
			       is_weakly_undefined_without_plt);
  }

a2969 68
  // R_ARM_PLT32: (S + A) | T - P
  static inline typename This::Status
  plt32(const Relocate_info<32, big_endian>* relinfo,
	unsigned char *view,
	const Sized_symbol<32>* gsym,
	const Arm_relobj<big_endian>* object,
	unsigned int r_sym,
	const Symbol_value<32>* psymval,
	Arm_address address,
	Arm_address thumb_bit,
	bool is_weakly_undefined_without_plt)
  {
    return arm_branch_common(elfcpp::R_ARM_PLT32, relinfo, view, gsym,
			     object, r_sym, psymval, address, thumb_bit,
			     is_weakly_undefined_without_plt);
  }

  // R_ARM_XPC25: (S + A) | T - P
  static inline typename This::Status
  xpc25(const Relocate_info<32, big_endian>* relinfo,
	unsigned char *view,
	const Sized_symbol<32>* gsym,
	const Arm_relobj<big_endian>* object,
	unsigned int r_sym,
	const Symbol_value<32>* psymval,
	Arm_address address,
	Arm_address thumb_bit,
	bool is_weakly_undefined_without_plt)
  {
    return arm_branch_common(elfcpp::R_ARM_XPC25, relinfo, view, gsym,
			     object, r_sym, psymval, address, thumb_bit,
			     is_weakly_undefined_without_plt);
  }

  // R_ARM_CALL: (S + A) | T - P
  static inline typename This::Status
  call(const Relocate_info<32, big_endian>* relinfo,
       unsigned char *view,
       const Sized_symbol<32>* gsym,
       const Arm_relobj<big_endian>* object,
       unsigned int r_sym,
       const Symbol_value<32>* psymval,
       Arm_address address,
       Arm_address thumb_bit,
       bool is_weakly_undefined_without_plt)
  {
    return arm_branch_common(elfcpp::R_ARM_CALL, relinfo, view, gsym,
			     object, r_sym, psymval, address, thumb_bit,
			     is_weakly_undefined_without_plt);
  }

  // R_ARM_JUMP24: (S + A) | T - P
  static inline typename This::Status
  jump24(const Relocate_info<32, big_endian>* relinfo,
	 unsigned char *view,
	 const Sized_symbol<32>* gsym,
	 const Arm_relobj<big_endian>* object,
	 unsigned int r_sym,
	 const Symbol_value<32>* psymval,
	 Arm_address address,
	 Arm_address thumb_bit,
	 bool is_weakly_undefined_without_plt)
  {
    return arm_branch_common(elfcpp::R_ARM_JUMP24, relinfo, view, gsym,
			     object, r_sym, psymval, address, thumb_bit,
			     is_weakly_undefined_without_plt);
  }

d7441 1
a7442 13
      reloc_status =
	Arm_relocate_functions::thm_call(relinfo, view, gsym, object, r_sym,
					 psymval, address, thumb_bit,
					 is_weakly_undefined_without_plt);
      break;

    case elfcpp::R_ARM_XPC25:
      reloc_status =
	Arm_relocate_functions::xpc25(relinfo, view, gsym, object, r_sym,
				      psymval, address, thumb_bit,
				      is_weakly_undefined_without_plt);
      break;

d7444 1
d7446 3
a7448 3
	Arm_relocate_functions::thm_xpc22(relinfo, view, gsym, object, r_sym,
					  psymval, address, thumb_bit,
					  is_weakly_undefined_without_plt);
d7494 3
d7504 3
a7506 24
	Arm_relocate_functions::plt32(relinfo, view, gsym, object, r_sym,
				      psymval, address, thumb_bit,
				      is_weakly_undefined_without_plt);
      break;

    case elfcpp::R_ARM_CALL:
      reloc_status =
	Arm_relocate_functions::call(relinfo, view, gsym, object, r_sym,
				     psymval, address, thumb_bit,
				     is_weakly_undefined_without_plt);
      break;

    case elfcpp::R_ARM_JUMP24:
      reloc_status =
	Arm_relocate_functions::jump24(relinfo, view, gsym, object, r_sym,
				       psymval, address, thumb_bit,
				       is_weakly_undefined_without_plt);
      break;

    case elfcpp::R_ARM_THM_JUMP24:
      reloc_status =
	Arm_relocate_functions::thm_jump24(relinfo, view, gsym, object, r_sym,
					   psymval, address, thumb_bit,
					   is_weakly_undefined_without_plt);
@


1.68
log
@	* arm.cc: Added support for the ARM relocations:
	R_ARM_MOVW_BREL_NC, R_ARM_MOVT_BREL, R_ARM_MOVW_BREL,
	R_ARM_THM_MOVW_BREL_NC, R_ARM_THM_MOVT_BREL, R_ARM_THM_MOVW_BREL.
	(Arm_relocate_functions::movw_rel_nc): Renamed (was
	movw_prel_nc).
	(Arm_relocate_functions::movw_rel): New method.
	(Arm_relocate_functions::movt_rel): Renamed (was movt_prel).
	(Arm_relocate_functions::thm_movw_rel_nc): Renamed (was
	thm_movw_prel_nc).
	(Arm_relocate_functions::thm_movw_rel): New method.
	(Arm_relocate_functions::thm_movt_rel): Renamed (was
	thm_movt_prel).
	(Target_arm::Scan::local): Handle MOVW_BREL/MOVT_BREL
	relocations.
	(Target_arm::Scan::global): Likewise.
	(Target_arm::Relocate::relocate): Likewise.
	(Target_arm::Relocatable_size_for_reloc::get_size_for_reloc):
	Likewise.
@
text
@d1402 2
a1403 1
      section_has_cortex_a8_workaround_(NULL), exidx_section_map_()
d1528 14
d1618 2
d4886 4
a4889 1
  elfcpp::Swap<32, big_endian>::writeval(wv, output_address);
d5492 4
d5507 5
d6138 93
d6902 2
d9696 21
a9716 4
    for (Stub_table_iterator sp = this->stub_tables_.begin();
	 (sp != this->stub_tables_.end()) && !any_stub_table_changed;
	 ++sp)
      (*sp)->finalize_stubs();
@


1.67
log
@	* arm.cc: Added support for ARM group relocations.
	(Target_arm::reloc_needs_sym_origin): New method.
	(Arm_relocate_functions::calc_grp_kn): New method.
	(Arm_relocate_functions::calc_grp_residual): New method.
	(Arm_relocate_functions::calc_grp_gn): New method.
	(Arm_relocate_functions::arm_grp_alu): New Method.
	(Arm_relocate_functions::arm_grp_ldr): New Method.
	(Arm_relocate_functions::arm_grp_ldrs): New Method.
	(Arm_relocate_functions::arm_grp_ldc): New Method.
	(Target_arm::Scan::local): Handle the ARM group relocations.
	(Target_arm::Scan::global): Likewise.
	(Target_arm::Relocate::relocate): Likewise.
	(Target_arm::Relocatable_size_for_reloc::get_size_for_reloc):
	Likewise.
@
text
@a111 6
//	R_ARM_MOVW_BREL_NC
//	R_ARM_MOVT_BREL
//	R_ARM_MOVW_BREL
//	R_ARM_THM_MOVW_BREL_NC
//	R_ARM_THM_MOVT_BREL
//	R_ARM_THM_MOVW_BREL
d3152 1
d3154 5
a3158 5
  movw_prel_nc(unsigned char *view,
	       const Sized_relobj<32, big_endian>* object,
	       const Symbol_value<32>* psymval,
	       Arm_address address,
	       Arm_address thumb_bit)
d3170 19
d3190 1
d3192 4
a3195 4
  movt_prel(unsigned char *view,
	    const Sized_relobj<32, big_endian>* object,
	    const Symbol_value<32>* psymval,
            Arm_address address)
d3208 1
d3210 5
a3214 5
  thm_movw_prel_nc(unsigned char *view,
	           const Sized_relobj<32, big_endian>* object,
	           const Symbol_value<32>* psymval,
	           Arm_address address,
	           Arm_address thumb_bit)
d3229 22
d3252 1
d3254 4
a3257 4
  thm_movt_prel(unsigned char *view,
	        const Sized_relobj<32, big_endian>* object,
	        const Symbol_value<32>* psymval,
	        Arm_address address)
d6556 6
d6722 6
d7357 15
a7371 3
      reloc_status = Arm_relocate_functions::movw_prel_nc(view, object,
							  psymval, address,
							  thumb_bit);
d7375 7
a7381 2
      reloc_status = Arm_relocate_functions::movt_prel(view, object,
                                                       psymval, address);
d7385 16
a7400 3
      reloc_status = Arm_relocate_functions::thm_movw_prel_nc(view, object,
							      psymval, address,
							      thumb_bit);
d7404 2
a7405 2
      reloc_status = Arm_relocate_functions::thm_movt_prel(view, object,
							   psymval, address);
d7408 5
d7874 6
@


1.66
log
@2010-01-26  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (set): Include.
	(class Arm_exidx_fixup): Change type of last_input_section_ to const
	pointer type.
 	(Arm_output_section::Text_section_list): New type.
	(Arm_output_section::append_text_sections_to_list): New method.
	(Arm_output_section::fix_exidx_coverage): Ditto.
	(Arm_relobj::Arm_relobj): Initialize exidx_section_map_.
   	(Arm_relobj::convert_input_section_to_relaxed_section): Use
	Relobj::set_section_offset() instead of
	Sized_relobj::invalidate_section_offset().
   	(Arm_relobj::section_needs_reloc_stub_scanning): Add an extra
	parameter for section headers. Ignore relocation sections for
	unallocated sections and EXIDX sections.
	(Target_arm::fix_exidx_coverage): New method.
	(Target_arm::output_section_address_less_than): New type.
	(Arm_exidx_fixup::add_exidx_cantunwind_as_needed): Use index of the
	linked text section instead of the EXIDX section.
	(Arm_output_section::create_stub_group): Add an assertion to check
	that this is not an EXIDX output section.
	(Arm_output_section::append_text_sections_to_list): New method.
	(Arm_output_section::fix_exidx_coverage): Ditto.
	(Arm_relobj::scan_sections_for_stubs): Adjust call to
   	Arm_relobj::section_needs_reloc_stub_scanning.
	(Target_arm::do_relax): Fix EXIDX output section coverage in the
	first pass.
	(Target_arm::fix_exidx_coverage): New method.
	* object.h (Relobj::set_output_section): New method.
	(Sized_relobj::invalidate_section_offset): Remove method.
	(Sized_relobj::do_invalidate_section_offset): Remove method.
	(Sized_relobj::do_set_section_offset): Handle offset value -1.
@
text
@d3 1
a3 1
// Copyright 2009 Free Software Foundation, Inc.
d99 1
a99 39
// supporting Android only for the time being.  Only these relocation types
// are supported.
//
// R_ARM_NONE
// R_ARM_ABS32
// R_ARM_ABS32_NOI
// R_ARM_ABS16
// R_ARM_ABS12
// R_ARM_ABS8
// R_ARM_THM_ABS5
// R_ARM_BASE_ABS
// R_ARM_REL32
// R_ARM_THM_CALL
// R_ARM_COPY
// R_ARM_GLOB_DAT
// R_ARM_BASE_PREL
// R_ARM_JUMP_SLOT
// R_ARM_RELATIVE
// R_ARM_GOTOFF32
// R_ARM_GOT_BREL
// R_ARM_GOT_PREL
// R_ARM_PLT32
// R_ARM_CALL
// R_ARM_JUMP24
// R_ARM_TARGET1
// R_ARM_PREL31
// R_ARM_ABS8
// R_ARM_MOVW_ABS_NC
// R_ARM_MOVT_ABS
// R_ARM_THM_MOVW_ABS_NC
// R_ARM_THM_MOVT_ABS
// R_ARM_MOVW_PREL_NC
// R_ARM_MOVT_PREL
// R_ARM_THM_MOVW_PREL_NC
// R_ARM_THM_MOVT_PREL
// R_ARM_V4BX
// R_ARM_THM_JUMP6
// R_ARM_THM_JUMP8
// R_ARM_THM_JUMP11
d102 29
a130 1
// - Support more relocation types as needed. 
d2238 41
d2591 60
d3275 171
d6521 28
d6681 28
d7202 22
d7369 3
a7371 17
      {
	uint32_t origin;
	// Get the addressing origin of the output segment defining the 
	// symbol gsym (AAELF 4.6.1.2 Relocation types)
	gold_assert(gsym != NULL); 
	if (gsym->source() == Symbol::IN_OUTPUT_SEGMENT)
	  origin = gsym->output_segment()->vaddr();
	else if (gsym->source () == Symbol::IN_OUTPUT_DATA)
	  origin = gsym->output_data()->address();
	else
	  {
            gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
				   _("cannot find origin of R_ARM_BASE_PREL"));
	    return true;
	  }
	reloc_status = Arm_relocate_functions::base_prel(view, origin, address);
      }
d7380 1
a7380 20
	uint32_t origin;
	// Get the addressing origin of the output segment defining
	// the symbol gsym (AAELF 4.6.1.2 Relocation types).
	if (gsym == NULL)
	  // R_ARM_BASE_ABS with the NULL symbol will give the
	  // absolute address of the GOT origin (GOT_ORG) (see ARM IHI
	  // 0044C (AAELF): 4.6.1.8 Proxy generating relocations).
	  origin = target->got_plt_section()->address();
	else if (gsym->source() == Symbol::IN_OUTPUT_SEGMENT)
	  origin = gsym->output_segment()->vaddr();
	else if (gsym->source () == Symbol::IN_OUTPUT_DATA)
	  origin = gsym->output_data()->address();
	else
	  {
            gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
				   _("cannot find origin of R_ARM_BASE_ABS"));
	    return true;
	  }

	reloc_status = Arm_relocate_functions::base_abs(view, origin);
d7472 168
d7789 28
@


1.65
log
@2010-01-25  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_exidx_merged_section::do_output_offset):
	Fix warning due to signed and unsigned comparison on a 32-bit host.
@
text
@d35 1
d1292 1
a1292 1
  Arm_exidx_input_section* last_input_section_;
d1304 2
d1324 11
d1418 1
a1418 1
      section_has_cortex_a8_workaround_(NULL)
d1460 1
a1460 1
    this->invalidate_section_offset(shndx);
d1580 1
a1580 1
				    const Symbol_table *);
d2382 12
d4713 1
a4713 1
      unsigned int shndx = this->last_input_section_->shndx();
d4715 1
a4715 1
	new Arm_exidx_cantunwind(relobj, shndx);
d4859 6
d5060 166
d5236 2
a5237 1
    const Symbol_table *symtab)
d5260 8
d5421 2
a5422 1
      if (this->section_needs_reloc_stub_scanning(shdr, out_sections, symtab))
d8858 1
d8891 10
d8972 3
d8976 1
a8976 1
  if (!any_stub_table_changed)
d8982 1
a8982 1
  return any_stub_table_changed;
d9314 46
@


1.64
log
@2010-01-22  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_relax): Record an output section for section
	offset adjustment it contains any stub table that has changed.
	* layout.cc (Layout::clean_up_after_relaxation): Adjust section
	offsets in an output section if necessary.
	* output.cc (Output_section::Output_section): Initialize
	section_offsets_need_adjustments_.
	(Output_section::add_input_section_for_script): Renamed to
	Output_section::add_simple_input_section.
	(Output_section::save_states): Add a comment.
	(Output_section::discard_states): New method defintion.
	(Output_section::adjust_section_offsets): Same.
	* output.h (Output_section::add_input_section_for_script): Renamed to
	Output_section::add_simple_input_section.
	(Output_section::discard_states): New method declaration.
	(Output_section::adjust_section_offsets): Same.
	(Output_section::section_offsets_need_adjustment,
	Output_section::set_section_offsets_need_adjustment): New method
	definitions.
	(Output_section::section_offsets_need_adjustment_): New data member.
	* script-sections.cc
	(Output_section_element_input::set_section_address): Adjust code for
	renaming of Output_section::add_input_section_for_script.
	(Orphan_output_section::set_section_address): Same.
@
text
@d4590 3
a4592 1
  if (offset < 0 || offset >= this->exidx_input_section_.size())
@


1.63
log
@2010-01-22  Viktor Kutuzov  <vkutuzov@@accesssoftek.com>

	* gold/arm.cc (Target_arm): Updated fix_v4bx method and usage of
	Fix_v4bx enum values .
	* gold/options.h (General_options): New option definitions.
	(General_options::fix_v4bx): New method.
	(General_options::Fix_v4bx): New enum.
	* gold/options.cc (General_options::parse_fix_v4bx): New method.
	(General_options::parse_fix_v4bx_interworking): New method.
@
text
@d8719 1
d8725 24
a8748 1
	any_stub_table_changed = true;
@


1.62
log
@2010-01-22  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_exidx_fixup): New class.
@
text
@d1815 1
a1815 1
      cortex_a8_relocs_info_(), fix_v4bx_(0)
d2052 1
a2052 1
  int
d2054 1
a2054 1
  { return this->fix_v4bx_; }
a2417 2
  // Whether we need to fix code for V4BX relocations.
  int fix_v4bx_;
d6452 2
a6453 1
  if (this->fix_v4bx() == 2 && !this->may_use_blx())
d6945 8
a6952 4
      if (target->fix_v4bx() > 0)
	reloc_status =
	  Arm_relocate_functions::v4bx(relinfo, view, object, address,
				       (target->fix_v4bx() == 2));
d8251 2
a8252 1
      if (this->fix_v4bx() == 2 && reg < 0xf)
@


1.61
log
@2010-01-21  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:

	* arm.h (EXIDX_CANTUNWIND): New enum.

gold/ChangeLog:

	* arm.cc (Arm_exidx_cantunwind, Arm_exidx_merged_section): New
	classes.
	(Arm_exidx_section_offset_map): New type.
@
text
@d71 2
d1222 74
d4674 145
@


1.60
log
@2010-01-21  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_exidx_input_section): New class.
	(Arm_relobj::exidx_input_section_by_link,
	Arm_relobj::exidx_input_section_by_shndx,
	Arm_relobj::make_exidx_input_section): New methods.
	(read_arm_attributes_section): Remove.
	(Arm_relobj::do_read_symbols): Look for ARM.exidx sections and record
	information about them.
	(Arm_dynobj::do_read_symbols): Move code in read_arm_attributes_section
	to here.
@
text
@d67 4
d1034 91
d4427 171
@


1.59
log
@2010-01-20  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::Arm_input_section_map): Change key type from
	Input_section_specifier to Section_id.
	(Target_arm::new_arm_input_section: Adjust code for change of key
	type.
	(Target_arm::find_arm_input_section): Ditto.
	* gc.h (object.h): Include for Section_id nand Section_id_hash.
	(Section_id): Remove.
	(Garbage_collection::Section_id_hash): Remove.
	* icf.h (object.h): Include for Section_id nand Section_id_hash.
	(Section_id): Remove.
	(Icf::Section_id_hash): Remove.
	* object.h (Section_id, Const_section_id, Section_id_hash,
	Const_section_id_hash): New type definitions.
	* output.cc (Output_section::add_relaxed_input_section): Change to
	use Const_section_id instead of Input_section_specifier as key type.
	(Output_section::add_merge_input_section): Ditto.
	(Output_section::build_relaxation_map): Change to use Section_id
	instead of Input_section_specifier as key type.
 	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Ditto.
	(Output_section::convert_input_sections_to_relaxed_sections): Change
	to use Const_section_id instead of Input_section_specifier as key type.
 	(Output_section::find_merge_section): Ditto.
	(Output_section::find_relaxed_input_section): Ditto.
	* output.h (Input_section_specifier): Remove class.
	(Output_section::Output_section_data_by_input_section_map): Change
	key type to Const_section_id.
	(Output_section::Output_relaxed_input_section_by_input_section_map):
	Ditto.
	(Output_section::Relaxation_map): Change key type to Section_id.
@
text
@d70 2
d1163 57
d1335 23
d1409 10
a1419 1
  typedef std::vector<Stub_table<big_endian>*> Stub_table_list;
d1432 2
d4992 2
a4993 2
// Helper functions for both Arm_relobj and Arm_dynobj to read ARM
// ABI information.
d4996 4
a4999 4
Attributes_section_data*
read_arm_attributes_section(
    Object* object,
    Read_symbols_data *sd)
d5001 6
a5006 7
  // Read the attributes section if there is one.
  // We read from the end because gas seems to put it near the end of
  // the section headers.
  const size_t shdr_size = elfcpp::Elf_sizes<32>::shdr_size;
  const unsigned char *ps =
    sd->section_headers->data() + shdr_size * (object->shnum() - 1);
  for (unsigned int i = object->shnum(); i > 0; --i, ps -= shdr_size)
d5008 14
a5021 10
      elfcpp::Shdr<32, big_endian> shdr(ps);
      if (shdr.get_sh_type() == elfcpp::SHT_ARM_ATTRIBUTES)
	{
	  section_offset_type section_offset = shdr.get_sh_offset();
	  section_size_type section_size =
	    convert_to_section_size_type(shdr.get_sh_size());
	  File_view* view = object->get_lasting_view(section_offset,
						     section_size, true, false);
	  return new Attributes_section_data(view->data(), section_size);
	}
d5023 10
a5032 1
  return NULL;
d5050 23
a5072 2
  this->attributes_section_data_ =
    read_arm_attributes_section<big_endian>(this, sd); 
d5130 22
a5151 2
  this->attributes_section_data_ =
    read_arm_attributes_section<big_endian>(this, sd); 
@


1.58
log
@	* gold/arm.cc: Added support for R_ARM_V4BX relocation
	(class Arm_v4bx_stub): New class.
	(DEF_STUBS): Updated definition to support v4_veneer_bx.
	(Stub_factory::make_arm_v4bx_stub): New method.
	(Stub_factory::elf32_arm_stub_v4_veneer_bx): New veneer template.
	(Stub_table::empty): Handle v4bx stubs.
	(Stub_table::add_arm_v4bx_stub): New method.
	(Stub_table::find_arm_v4bx_stub): New method.
	(Arm_relocate_functions::v4bx): New method.
	(Target_arm::fix_v4bx): New method.
	(Target_arm::Target_arm): Handle R_ARM_V4BX.
	(Stub_table::relocate_stubs): Likewise.
	(Stub_table::do_write): Likewise.
	(Stub_table::update_data_size_and_addralign): Likewise.
	(Stub_table::finalize_stubs):  Likewise.
	(Target_arm::Scan::local): Likewise.
	(Target_arm::Scan::global): Likewise.
	(Target_arm::do_finalize_sections): Likewise.
	(Target_arm::Relocate::relocate): Likewise.
	(Target_arm::Relocatable_size_for_reloc::get_size_for_reloc):
	Likewise.
	(Target_arm::scan_reloc_for_stub): Likewise.
	(Target_arm::scan_reloc_section_for_stubs): Likewise.
@
text
@d2117 1
a2117 1
  typedef Unordered_map<Input_section_specifier,
d2119 1
a2119 2
			Input_section_specifier::hash,
			Input_section_specifier::equal_to>
d7545 1
a7545 1
  Input_section_specifier iss(relobj, shndx);
d7553 1
a7553 1
    this->arm_input_section_map_.insert(std::make_pair(iss, arm_input_section));
d7571 1
a7571 1
  Input_section_specifier iss(relobj, shndx);
d7573 1
a7573 1
    this->arm_input_section_map_.find(iss);
@


1.57
log
@	* arm.cc (Arm_relocate_functions::thm_jump6): New function.
	(Arm_relocate_functions::thm_jump8): New function.
	(Arm_relocate_functions::thm_jump11): New function.
	(Target_arm::Scan::local): Handle R_ARM_THM_JUMP6, R_ARM_THM_JUMP8,
	R_ARM_THM_JUMP11.
	(Target_arm::Scan::global): Likewise.
	(Target_arm::Relocate::relocate): Likewise.
	(Target_arm::Relocatable_size_for_reloc::get_size_for_reloc):
	Likewise.
@
text
@d125 1
d258 2
a259 1
  DEF_STUB(a8_veneer_blx)
d280 1
a280 1
    arm_stub_type_last = arm_stub_a8_veneer_blx
d753 58
d845 10
d877 1
a877 1
      prev_data_size_(0), prev_addralign_(1)
d891 5
a895 1
  { return this->reloc_stubs_.empty() && this->cortex_a8_stubs_.empty(); }
d922 9
d943 9
d1011 2
d1020 2
d1551 1
a1551 1
      cortex_a8_relocs_info_()
d1784 8
d2155 2
d2854 43
d3828 9
d3931 10
d3982 16
d4034 13
d4098 14
d5418 1
d5550 1
d5819 7
d6313 7
d6468 1
d7613 23
d7807 2
a7808 1
         && (r_type != elfcpp::R_ARM_THM_JUMP19))
d7823 12
@


1.56
log
@2010-01-14  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (map, utility): Include headers.
	(Target_arm::apply_cortex_a8_workaround): New method.
	(Arm_relobj::do_relocate_sections): Apply any Cortex-A8 workaround.
	(Target_arm::Scan::local): Handle R_ARM_THM_JUMP24, R_ARM_THM_JUMP19.
	(Target_arm::Scan::global): R_ARM_THM_JUMP19.
	(Target_arm::do_finalize_sections): Set fix_cortex_a8_ according to
	the --[no-]fix-cortex-a8 command line options.
	(Target_arm::Relocate::relocate): Handle R_ARM_JUMP19.
	(Target_arm::relocate_stub): Use addend in instruction template.
	* options.h (DEFINE_bool): Set the user-set flag.
	(General_options): Add --[no-]-fix-cortex options.
	* output.cc (Output_section::convert_input_sections_to_relaxed_sections)
	: Update fast look-up map after conversion.
@
text
@d125 3
d2416 60
d5204 3
d5335 3
d6073 15
d6214 3
@


1.55
log
@2010-01-13  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::section_needs_reloc_stub_scanning,
	Arm_relobj::scan_sections_for_stubs): Rearrange code to avoid an
	apparent compiler problem of not folding static constant integral
	data members of elfcpp::Elf_sizes<32>.
@
text
@d33 2
d1691 5
d4564 30
a4593 4
      if (arm_input_section == NULL
	  || !arm_input_section->is_stub_table_owner()
	  || arm_input_section->stub_table()->empty())
	continue;
d4595 28
a4622 25
      // We cannot discard a section if it owns a stub table.
      Output_section* os = this->output_section(i);
      gold_assert(os != NULL);

      relinfo.reloc_shndx = elfcpp::SHN_UNDEF;
      relinfo.reloc_shdr = NULL;
      relinfo.data_shndx = i;
      relinfo.data_shdr = pshdrs + i * elfcpp::Elf_sizes<32>::shdr_size;

      gold_assert((*pviews)[i].view != NULL);

      // We are passed the output section view.  Adjust it to cover the
      // stub table only.
      Stub_table<big_endian>* stub_table = arm_input_section->stub_table();
      gold_assert((stub_table->address() >= (*pviews)[i].address)
		  && ((stub_table->address() + stub_table->data_size())
		      <= (*pviews)[i].address + (*pviews)[i].view_size));

      off_t offset = stub_table->address() - (*pviews)[i].address;
      unsigned char* view = (*pviews)[i].view + offset;
      Arm_address address = stub_table->address();
      section_size_type view_size = stub_table->data_size();
 
      stub_table->relocate_stubs(&relinfo, arm_target, os, view, address,
				 view_size);
d5125 2
d5313 1
d5516 1
a5516 1
  Object_attribute* attr =
d5518 1
a5518 1
  if (attr->int_value() > elfcpp::TAG_CPU_ARCH_V4)
d5521 16
d5998 6
d7775 1
a7775 1
      Arm_address target = stub->reloc_target(i);
d8013 52
@


1.54
log
@2010-01-13  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::section_needs_reloc_stub_scanning,
	Arm_relobj::section_needs_cortex_a8_stub_scanning,
	Arm_relobj::scan_section_for_cortex_a8_erratum,
	Arm_relobj::scan_span_for_cortex_a8_erratum): New methods.
	(Arm_relobj::scan_sections_for_stubs): Move code deciding what
	sections to scan for relocation stubs into a new method
	Arm_relobj::section_needs_reloc_stub_scanning.  Handle both
	relocation and Cortex-A8 stub scanning.
	(Target_arm::do_relax): Force stubs to be after stubbed sections
	if fixing the Cortex-A8 erratum.  Remove all Cortex-A8 stubs at
	the beginning of a new relaxation pass.  Update a comment.
	(Target_arm::scan_span_for_cortex_a8_erratum): New method definition.
@
text
@d4206 5
a4210 3
  const unsigned int reloc_size = (sh_type == elfcpp::SHT_REL
				   ? elfcpp::Elf_sizes<32>::rel_size
				   : elfcpp::Elf_sizes<32>::rela_size);
d4385 5
a4389 3
	  const unsigned int reloc_size = (sh_type == elfcpp::SHT_REL
					   ? elfcpp::Elf_sizes<32>::rel_size
					   : elfcpp::Elf_sizes<32>::rela_size);
@


1.53
log
@2010-01-12  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Cortex_a8_reloc): New class.
	(Target_arm::Target_arm): Initialize new data members fix_cortex_a8_
	and cortex_a8_relocs_info_.
	(Target_arm::fix_cortex_a8): New method definition.
	(Target_arm::Cortex_a8_relocs_info): New type.
	(Target_arm::fix_cortex_a8_, Target_arm::cortex_a8_relocs_info_):
	New data member declarations.
	(Target_arm::scan_reloc_for_stub): Record information about
	relocations for THUMB branches that might be exempted from the
	Cortex-A8 workaround.
	(Target_arm::do_relax): Clear all Cortex-A8 relocation information
	at the beginning of a relaxation pass.
@
text
@d1207 19
d1683 6
d4170 149
d4347 1
d4351 2
a4352 12
      typename elfcpp::Shdr<32, big_endian> shdr(p);

      unsigned int sh_type = shdr.get_sh_type();
      if (sh_type != elfcpp::SHT_REL && sh_type != elfcpp::SHT_RELA)
	continue;

      off_t sh_size = shdr.get_sh_size();
      if (sh_size == 0)
	continue;

      unsigned int index = this->adjust_shndx(shdr.get_sh_info());
      if (index >= this->shnum())
d4354 13
a4366 4
	  // Ignore reloc section with bad info.  This error will be
	  // reported in the final link.
	  continue;
	}
d4368 26
a4393 32
      Output_section* os = out_sections[index];
      if (os == NULL
	  || symtab->is_section_folded(this, index))
	{
	  // This relocation section is against a section which we
	  // discarded or if the section is folded into another
	  // section due to ICF.
	  continue;
	}
      Arm_address output_offset = this->get_output_section_offset(index);

      if (this->adjust_shndx(shdr.get_sh_link()) != this->symtab_shndx())
	{
	  // Ignore reloc section with unexpected symbol table.  The
	  // error will be reported in the final link.
	  continue;
	}

      const unsigned char* prelocs = this->get_view(shdr.get_sh_offset(),
						    sh_size, true, false);

      unsigned int reloc_size;
      if (sh_type == elfcpp::SHT_REL)
	reloc_size = elfcpp::Elf_sizes<32>::rel_size;
      else
	reloc_size = elfcpp::Elf_sizes<32>::rela_size;

      if (reloc_size != shdr.get_sh_entsize())
	{
	  // Ignore reloc section with unexpected entsize.  The error
	  // will be reported in the final link.
	  continue;
d4395 1
d4397 16
a4412 6
      size_t reloc_count = sh_size / reloc_size;
      if (static_cast<off_t>(reloc_count * reloc_size) != sh_size)
	{
	  // Ignore reloc section with uneven size.  The error will be
	  // reported in the final link.
	  continue;
a4413 19

      gold_assert(output_offset != invalid_address
		  || this->relocs_must_follow_section_writes());

      // Get the section contents.  This does work for the case in which
      // we modify the contents of an input section.  We need to pass the
      // output view under such circumstances.
      section_size_type input_view_size = 0;
      const unsigned char* input_view =
	this->section_contents(index, &input_view_size, false);

      relinfo.reloc_shndx = i;
      relinfo.data_shndx = index;
      arm_target->scan_section_for_stubs(&relinfo, sh_type, prelocs,
					 reloc_count, os,
					 output_offset == invalid_address,
					 input_view,
					 os->address(),
					 input_view_size);
d7607 6
d7630 5
d7645 6
d7653 1
a7653 1
  // scan relocs for stubs
d7778 170
@


1.52
log
@2010-01-12  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::mapping_symbols_info_): New data member.
	(Arm_relobj::Mapping_symbol_position,
	 Arm_reloj::Mapping_symbol_position_less,
	 Arm_relobj::Mapping_symbols_info): New types.
	(Target_arm::is_mapping_symbol_name): New method definition.
	(Arm_relobj::do_count_local_symbols): Save information about mapping
	symbols.
@
text
@d1312 43
d1430 2
a1431 1
      attributes_section_data_(NULL)
d1659 5
d1984 4
d2012 4
d7141 1
d7145 9
d7155 8
a7162 11
  // This reloc does not need a stub.
  if (stub_type == arm_stub_none)
    return;

  // Try looking up an existing stub from a stub table.
  Stub_table<big_endian>* stub_table = 
    arm_relobj->stub_table(relinfo->data_shndx);
  gold_assert(stub_table != NULL);
   
  // Locate stub by destination.
  Reloc_stub::Key stub_key(stub_type, gsym, arm_relobj, r_sym, addend);
d7164 19
a7182 7
  // Create a stub if there is not one already
  Reloc_stub* stub = stub_table->find_reloc_stub(stub_key);
  if (stub == NULL)
    {
      // create a new stub and add it to stub table.
      stub = this->stub_factory().make_reloc_stub(stub_type);
      stub_table->add_reloc_stub(stub, stub_key);
a7183 4

  // Record the destination address.
  stub->set_destination_address(destination
				| (target_is_thumb ? 1 : 0));
d7465 11
a7475 1

@


1.51
log
@2010-01-11  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relocate_functions::thumb32_branch_offset,
	Arm_relocate_functions::thumb32_branch_upper,
	Arm_relocate_functions::thumb32_branch_lower,
	Arm_relocate_functions::thumb32_cond_branch_offset,
	Arm_relocate_functions::thumb32_cond_branch_upper,
	Arm_relocate_functions::thumb32_cond_branch_lower,
	Arm_relocate_functions::thm_jump19): New methods to handle THUMB
	branch offset encoding.
	(Arm_relocate_functions::thumb_branch_common): Use new branch
	offset encoding methods to avoid code duplication.
	(Stub_template::Stub_template) Handle THUMB16_SPECIAL_TYPE.
	(Stub_addend_reader::operator()): Use new branch encoding method
	to avoid code duplication.
@
text
@d1072 2
a1073 1
      attributes_section_data_(NULL), section_has_cortex_a8_workaround_(NULL)
d1137 20
d1217 2
d1605 10
d4245 21
d4280 11
@


1.50
log
@2010-01-11  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::do_gc_process_relocs): New method.
	(Target_arm::do_finalize_sections): Define special EXIDX section
	symbols only if referenced.
	* gc.h (Garbage_collection::add_reference): New method.
	(gc_process_relocs): Use Garbage_collection::add_reference to avoid
	code duplication.
@
text
@d2058 81
d2272 6
d2769 1
a2769 14
  // Fetch the addend.  We use the Thumb-2 encoding (backwards compatible
  // with Thumb-1) involving the J1 and J2 bits.
  uint32_t s = (upper_insn & (1 << 10)) >> 10;
  uint32_t upper = upper_insn & 0x3ff;
  uint32_t lower = lower_insn & 0x7ff;
  uint32_t j1 = (lower_insn & (1 << 13)) >> 13;
  uint32_t j2 = (lower_insn & (1 << 11)) >> 11;
  uint32_t i1 = j1 ^ s ? 0 : 1;
  uint32_t i2 = j2 ^ s ? 0 : 1;
 
  int32_t addend = (i1 << 23) | (i2 << 22) | (upper << 12) | (lower << 1);
  // Sign extend.
  addend = (addend | ((s ? 0 : 1) << 24)) - (1 << 24);

a2820 3
  uint32_t reloc_sign = (branch_offset < 0) ? 1 : 0;
  uint32_t relocation = static_cast<uint32_t>(branch_offset);

d2826 1
a2826 1
    relocation = (relocation + 2U) & ~3U;
d2831 2
a2832 7
  upper_insn = (upper_insn & ~0x7ffU)
                | ((relocation >> 12) & 0x3ffU)
                | (reloc_sign << 10);
  lower_insn = (lower_insn & ~0x2fffU)
                | (((!((relocation >> 23) & 1U)) ^ reloc_sign) << 13)
                | (((!((relocation >> 22) & 1U)) ^ reloc_sign) << 11)
                | ((relocation >> 1) & 0x7ffU);
d2838 47
a2884 2
	   ? utils::has_overflow<25>(relocation)
	   : utils::has_overflow<23>(relocation))
d3011 1
d4424 2
a4441 2
	// Fetch the addend.  We use the Thumb-2 encoding (backwards
	// compatible with Thumb-1) involving the J1 and J2 bits.
d4446 1
a4446 11

	uint32_t s = (upper_insn & (1 << 10)) >> 10;
	uint32_t upper = upper_insn & 0x3ff;
	uint32_t lower = lower_insn & 0x7ff;
	uint32_t j1 = (lower_insn & (1 << 13)) >> 13;
	uint32_t j2 = (lower_insn & (1 << 11)) >> 11;
	uint32_t i1 = j1 ^ s ? 0 : 1;
	uint32_t i2 = j2 ^ s ? 0 : 1;

	return utils::sign_extend<25>((s << 24) | (i1 << 23) | (i2 << 22)
				      | (upper << 12) | (lower << 1));
d4455 1
a4455 10

	// Reconstruct the top three bits and squish the two 11 bit pieces
	// together.
	uint32_t S = (upper_insn & 0x0400) >> 10;
	uint32_t J1 = (lower_insn & 0x2000) >> 13;
	uint32_t J2 = (lower_insn & 0x0800) >> 11;
	uint32_t upper =
	  (S << 8) | (J2 << 7) | (J1 << 6) | (upper_insn & 0x003f);
	uint32_t lower = (lower_insn & 0x07ff);
	return utils::sign_extend<23>((upper << 12) | (lower << 1));
@


1.49
log
@2010-01-08  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Stub_table::Stub_table): Initalize cortex_a8_stubs_,
	  prev_data_size_ and prev_addralign_.  Remove initializer for
	  deleted data member has_been_changed_.
	  (Stub_table::empty): Look at both reloc_stubs_ and cortex_a8_stubs_
	  to determine if the table is empty.
	  (Stub_table::has_been_changed, Stub_table_set_has_been_changed):
	  Remove.
	  (Stub_table::add_reloc_stub): Define method in class definition
	  instead of just declaring it there.
	  (Stub_table::add_cortex_a8_stub): New method definition.
	  (Stub_table::update_data_size_and_addralign): Ditto.
	  (Stub_table::finalize_stubs): Ditto.
	  (Stub_table::apply_cortex_a8_workaround_to_address_range): Ditto.
	  (Stub_table::do_addralign_): Return address alignment in the
	  (Stub_table::do_reset_address_and_file_offset): Define method in
	  class definition instead of declaring it there.  Set current data
	  size to be the data size of the previous pass.
	  (Stub_table::set_final_data_size): Use current data size as the
	  final data size.
	  (Stub_table::relocate_stub): Change parameter type of stub from
	  Reloc_stub pointer to Stub pointer.
	  (Stub_table::addralign_, Stub_table::has_been_changed_): Remove.
	  (Stub_table::Cortex_a8_stub_list): New typedef.
	  (Stub_table::cortex_a8_stubs_, Stub_table::prev_data_size_,
	   Stub_table::prev_addralign_): New data member.
	  (Arm_relobj::Arm_relobj): Initialize data member
	  section_has_cortex_a8_workaround_.
	  (Arm_relobj::section_has_cortex_a8_workaround,
	   Arm_relobj::mark_section_for_cortex_a8_workaround): New method
	   definitions.
	  (Arm_relobj::section_has_cortex_a8_workaround_): New data member
	  declarations.
	  (Target_arm::relocate_stub): Change parameter type of stub from
	  Reloc_stub pointer to Stub pointer.
	  (Insn_template::size, Insn_template::alignment): Handle
	  THUMB16_SPECIAL_TYPE.
	  (Stub_table::remove_all_cortex_a8_stubs, Stub_table::finalize_stubs,
	   Stub_table::update_data_size_and_addralign,
	   Stub_table::apply_cortex_a8_workaround_to_address_range): New method
	  definitions.
 	  (Stub_table::relocate_stubs): Handle Cortex-A8 stubs.
	  (Stub_table::do_write): Ditto.
	  (Target_arm::do_relax): Adjust code for changes in Stub_table.
@
text
@d1181 4
d4242 38
d5126 1
a5126 1
				    false, false);
d5131 1
a5131 1
				    true, false);
@


1.48
log
@	* output.h (class Output_data): Add const version of
	output_section and do_output_section.
	(class Output_section_data): Add const version of
	do_output_section.
	(class Output_section): Likewise.
	* layout.cc (Layout::add_target_dynamic_tags): New function.
	* layout.h (class Layout): Update declarations.
	* arm.cc (Target_arm::do_finalize_sections): Use
	add_target_dynamic_tags.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d801 2
a802 2
    : Output_data(), addralign_(1), owner_(owner), has_been_changed_(false),
      reloc_stubs_()
d816 1
a816 11
  { return this->reloc_stubs_.empty(); }

  // Whether this has been changed.
  bool
  has_been_changed() const
  { return this->has_been_changed_; }

  // Set the has-been-changed flag.
  void
  set_has_been_changed(bool value)
  { this->has_been_changed_ = value; }
d826 20
a845 1
  add_reloc_stub(Reloc_stub* stub, const Reloc_stub::Key& key);
d861 17
d886 1
a886 1
  { return this->addralign_; }
d888 6
a893 1
  // Finalize data size.
d896 4
a899 3
  { this->set_data_size(this->current_data_size_for_child()); }

  // Reset address and file offset.
d901 3
a903 1
  do_reset_address_and_file_offset();
d905 1
a905 2
 private:
  // Unordered map of stubs.
d911 4
a914 2
  // Address alignment
  uint64_t addralign_;
a916 3
  // This is set to true during relaxiong if the size of the stub table
  // has been changed.
  bool has_been_changed_;
d919 6
d1072 1
a1072 1
      attributes_section_data_(NULL)
d1136 18
d1192 2
d1560 1
a1560 1
  relocate_stub(Reloc_stub*, const Relocate_info<32, big_endian>*,
d2846 1
d2865 1
d3402 1
a3402 2
// Add a STUB with using KEY.  Caller is reponsible for avoid adding
// if already a STUB with the same key has been added. 
d3406 21
a3426 3
Stub_table<big_endian>::add_reloc_stub(
    Reloc_stub* stub,
    const Reloc_stub::Key& key)
d3429 10
a3438 5
  gold_assert(stub_template->type() == key.stub_type());
  this->reloc_stubs_[key] = stub;
  if (this->addralign_ < stub_template->alignment())
    this->addralign_ = stub_template->alignment();
  this->has_been_changed_ = true;
d3441 2
d3459 27
d3491 56
a3546 12
      const Stub_template* stub_template = stub->stub_template();
      if (stub_template->reloc_count() != 0)
	{
	  // Adjust view to cover the stub only.
	  section_size_type offset = stub->offset();
	  section_size_type stub_size = stub_template->size();
	  gold_assert(offset + stub_size <= view_size);

	  arm_target->relocate_stub(stub, relinfo, output_section,
				    view + offset, address + offset,
				    stub_size);
	}
d3548 12
d3562 2
a3563 1
// Reset address and file offset.
d3567 1
a3567 1
Stub_table<big_endian>::do_reset_address_and_file_offset()
a3569 1
  uint64_t max_addralign = 1;
a3576 1
      max_addralign = std::max(max_addralign, stub_addralign);
a3578 1
      stub->reset_destination_address();
d3582 19
a3600 2
  this->addralign_ = max_addralign;
  this->set_current_data_size_for_child(off);
d3603 3
a3605 1
// Write out the stubs to file.
d3609 5
a3613 1
Stub_table<big_endian>::do_write(Output_file* of)
d3615 17
a3631 4
  off_t offset = this->offset();
  const section_size_type oview_size =
    convert_to_section_size_type(this->data_size());
  unsigned char* const oview = of->get_output_view(offset, oview_size);
d3633 3
a3635 13
  for (typename Reloc_stub_map::const_iterator p = this->reloc_stubs_.begin();
      p != this->reloc_stubs_.end();
      ++p)
    {
      Reloc_stub* stub = p->second;
      Arm_address address = this->address() + stub->offset();
      gold_assert(address
		  == align_address(address,
				   stub->stub_template()->alignment()));
      stub->write(oview + stub->offset(), stub->stub_template()->size(),
		  big_endian);
    } 
  of->write_output_view(this->offset(), oview_size, oview);
a7191 1
  // clear changed flags for all stub_tables
a7192 4
  for (Stub_table_iterator sp = this->stub_tables_.begin();
       sp != this->stub_tables_.end();
       ++sp)
    (*sp)->set_has_been_changed(false);
d7204 3
d7212 1
a7212 1
      if ((*sp)->has_been_changed())
d7216 7
d7231 1
a7231 1
    Reloc_stub* stub,
@


1.47
log
@2010-01-07  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Insn_template::Type): New enum value THUMB16_SPECIAL_TYPE.
	(Insn_template::thumb16_bcond_insn): New method declaration.
	(Insn_template): Fix spelling.
	(Stub::thumb16_special): New method declaration.
	(Stub::do_write): Define virtual method which was previously pure
	virtual.
	(Stub::do_thumb16_special): New method declaration.
	(Stub::do_fixed_endian_write): New template member.
	(Reloc_stub::do_write): Remove.
	(Reloc_stub::do_fixed_endian_write): Remove.
	(Cortex_a8_stub): New class definition.
	(Stub_factory::make_cortex_a8_stub): New method definition.
	(Stub_factory::Stub_factory): Add missing static storage class
	qualifier for elf32_arm_stub_a8_veneer_blx.
@
text
@d4871 5
a4875 33
  Output_data_dynamic* const odyn = layout->dynamic_data();
  if (odyn != NULL)
    {
      if (this->got_plt_ != NULL
	  && this->got_plt_->output_section() != NULL)
	odyn->add_section_address(elfcpp::DT_PLTGOT, this->got_plt_);

      if (this->plt_ != NULL
	  && this->plt_->output_section() != NULL)
	{
	  const Output_data* od = this->plt_->rel_plt();
	  odyn->add_section_size(elfcpp::DT_PLTRELSZ, od);
	  odyn->add_section_address(elfcpp::DT_JMPREL, od);
	  odyn->add_constant(elfcpp::DT_PLTREL, elfcpp::DT_REL);
	}

      if (this->rel_dyn_ != NULL
	  && this->rel_dyn_->output_section() != NULL)
	{
	  const Output_data* od = this->rel_dyn_;
	  odyn->add_section_address(elfcpp::DT_REL, od);
	  odyn->add_section_size(elfcpp::DT_RELSZ, od);
	  odyn->add_constant(elfcpp::DT_RELENT,
			     elfcpp::Elf_sizes<32>::rel_size);
	}

      if (!parameters->options().shared())
	{
	  // The value of the DT_DEBUG tag is filled in by the dynamic
	  // linker at run time, and used by the debugger.
	  odyn->add_constant(elfcpp::DT_DEBUG, 0);
	}
    }
@


1.46
log
@	* layout.cc (Layout::Layout): Initialize increase_relro_.
	(Layout::get_output_section): Add is_relro, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::set_segment_offsets): Clear increase_relro when using a
	linker script.
	* layout.h (class Layout): Add increase_relro method.  Add
	increase_relro_ field.  Update declarations.
	* output.cc (Output_section::Output_section): Initialize
	is_last_relro_ and is_first_non_relro_.
	(Output_segment::add_output_section): Group relro sections is
	do_sort is true.  Handle is_last_relro and is_first_non_relro.
	(Output_segment::maximum_alignment): Remove relro handling.
	(Output_segment::set_section_addresses): Add increase_relro
	parameter.  Change all callers.  Add initial alignment to align
	relro sections on separate page.  Remove old relro handling.
	(Output_segment::set_section_list_addresses): Remove in_relro
	parameter.  Change all callers.
	(Output_segment::set_offset): Add increase parameter.  Change all
	callers.  Remove old relro handling.
	* output.h (class Output_section): Add new methods: is_last_relro,
	set_is_last_relro, is_first_non_relro, set_is_first_non_relro.
	Add is_last_relro_ and is_first_non_relro_ fields.
	* i386.cc (Target_i386::got_section): Don't call set_is_relro.
	Create separate .got.plt section.  Call increase_relro.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/relro_script_test.t: Add .got.plt.
@
text
@d140 5
d150 1
a150 1
  // Factory methods to create instrunction templates in different formats.
d156 2
a157 2
  // A bit of a hack.  A Thumb conditional branch, in which the proper
  // condition is inserted when we build the stub.
d160 1
a160 1
  { return Insn_template(data, THUMB16_TYPE, elfcpp::R_ARM_NONE, 1); } 
d206 1
a206 1
  // Return size of instrunction template in bytes.
d210 1
a210 1
  // Return byte-alignment of instrunction template.
d418 6
d429 1
a429 1
  // This must be defined in the child class.
d431 7
a437 1
  do_write(unsigned char*, section_size_type, bool) = 0;
d439 6
d446 5
a624 1
 private:
d635 92
a726 4
  // A template to implement do_write below.
  template<bool big_endian>
  void inline
  do_fixed_endian_write(unsigned char*, section_size_type);
d728 3
a730 3
  // Write a stub.
  void
  do_write(unsigned char* view, section_size_type view_size, bool big_endian);
d732 8
a739 1
  // Address of destination.
d741 3
d768 12
d2868 45
d3119 1
a3119 40
// Template to implement do_write for a specific target endianity.

template<bool big_endian>
void inline
Reloc_stub::do_fixed_endian_write(unsigned char* view,
				  section_size_type view_size)
{
  const Stub_template* stub_template = this->stub_template();
  const Insn_template* insns = stub_template->insns();

  // FIXME:  We do not handle BE8 encoding yet.
  unsigned char* pov = view;
  for (size_t i = 0; i < stub_template->insn_count(); i++)
    {
      switch (insns[i].type())
	{
	case Insn_template::THUMB16_TYPE:
	  // Non-zero reloc addends are only used in Cortex-A8 stubs. 
	  gold_assert(insns[i].reloc_addend() == 0);
	  elfcpp::Swap<16, big_endian>::writeval(pov, insns[i].data() & 0xffff);
	  break;
	case Insn_template::THUMB32_TYPE:
	  {
	    uint32_t hi = (insns[i].data() >> 16) & 0xffff;
	    uint32_t lo = insns[i].data() & 0xffff;
	    elfcpp::Swap<16, big_endian>::writeval(pov, hi);
	    elfcpp::Swap<16, big_endian>::writeval(pov + 2, lo);
	  }
          break;
	case Insn_template::ARM_TYPE:
	case Insn_template::DATA_TYPE:
	  elfcpp::Swap<32, big_endian>::writeval(pov, insns[i].data());
	  break;
	default:
	  gold_unreachable();
	}
      pov += insns[i].size();
    }
  gold_assert(static_cast<section_size_type>(pov - view) == view_size);
} 
d3121 2
a3122 1
// Write a reloc stub to VIEW with endianity specified by BIG_ENDIAN.
d3124 2
a3125 3
void
Reloc_stub::do_write(unsigned char* view, section_size_type view_size,
		     bool big_endian)
d3127 9
a3135 4
  if (big_endian)
    this->do_fixed_endian_write<true>(view, view_size);
  else
    this->do_fixed_endian_write<false>(view, view_size);
d3313 1
a3313 1
  const Insn_template elf32_arm_stub_a8_veneer_blx[] =
@


1.45
log
@	* symtab.h (class Symbol_table): Add enum Defined.
	* resolve.cc (Symbol_table::should_override): Add defined
	parameter.  Change all callers.  Test whether object is NULL
	before calling a method on it.
	(Symbol_table::report_resolve_problem): Add defined parameter.
	Change all callers.
	(Symbol_table::should_override_with_special): Likewise.
	* symtab.cc (Symbol_table::define_in_output_data): Add defined
	parameter.  Change all callers.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::define_in_output_segment): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::define_as_constant): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* script.h (class Symbol_assignment): Add is_defsym parameter to
	constructor; change all callers.
	* script.cc (Script_options::add_symbol_assignment): Add is_defsym
	parameter.  Change all callers.  Add is_defsym_ field.
	(class Parser_closure): Add parsing_defsym parameter to
	constructor; change all callers.  Add parsing_defsym accessor
	function.  Add parsing_defsym_ field.
@
text
@d2595 2
a2596 2
					   this->got_, false);
      os->set_is_relro();
d2606 2
a2607 2
					   this->got_plt_, false);
      os->set_is_relro();
d2635 2
a2636 1
				      elfcpp::SHF_ALLOC, this->rel_dyn_, true);
d4056 2
a4057 1
				  elfcpp::SHF_ALLOC, this->rel_, true);
d4219 1
a4219 1
				      this->plt_, false);
d4798 2
a4799 1
				  attributes_section, false);
@


1.44
log
@2009-12-16  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::scan_sections_for_stubs): Exclude ICF-eliminated
	sections.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Handle
	relaxed input sections.
	* output.cc (Output_section::find_relaxed_input_section): Change
	return type to Output_relaxed_input_section pointer.  Adjust code
	for new type of relaxed_input_section_map_.
	* output.h (Output_section::find_relaxed_input_section): Change
	return type to Output_relaxed_input_section pointer.
	(Output_section::Output_relaxed_input_section_by_input_section_map):
	New type.
	(Output_section::relaxed_input_section_map_): Change type to
	Output_section::Output_relaxed_input_section_by_input_section_map.
	* symtab.cc (Symbol_table::compute_final_value): Handle relaxed
	input section.
@
text
@d2614 1
d4767 3
a4769 2
      symtab->define_in_output_data("__exidx_start", NULL, exidx_section,
				    0, 0, elfcpp::STT_OBJECT,
d4772 3
a4774 2
      symtab->define_in_output_data("__exidx_end", NULL, exidx_section,
				    0, 0, elfcpp::STT_OBJECT,
@


1.43
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d3648 2
a3649 1
      if (os == NULL)
d3652 2
a3653 1
	  // discarded.
@


1.42
log
@2009-12-11  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_finalize_sections): Fix build breakage
	due to -Wshadow.
	* attributes.cc (Object_attribute::size): Ditto.
	(Attributes_section_data::size): Ditto.
	(Attributes_section_data::Attributes_section_data): Ditto.
	(Output_attributes_section_data::do_write): Ditto.
	* attributes.h (Object_attribute::set_type): Ditto.
	* testsuite/tls_test_main.cc (safe_lock, safe_unlock): Ditto.
@
text
@d213 2
a214 2
  Insn_template(unsigned adata, Type atype, unsigned int rtype, int relocaddend)
    : data_(adata), type_(atype), r_type_(rtype), reloc_addend_(relocaddend)
d376 2
a377 2
  Stub(const Stub_template* stubtemplate)
    : stub_template_(stubtemplate), offset_(invalid_offset)
d399 2
a400 2
  set_offset(section_offset_type off)
  { this->offset_ = off; }
d478 3
a480 3
    Key(Stub_type stubtype, const Symbol* sym, const Relobj* rel_obj,
	unsigned int rsym, int32_t addend)
      : stub_type_(stubtype), addend_(addend)
d482 1
a482 1
      if (sym != NULL)
d485 1
a485 1
	  this->u_.symbol = sym;
d489 3
a491 3
	  gold_assert(rel_obj != NULL && rsym != invalid_index);
	  this->r_sym_ = rsym;
	  this->u_.relobj = rel_obj;
d588 2
a589 2
  Reloc_stub(const Stub_template* stubtemplate)
    : Stub(stubtemplate), destination_address_(invalid_address)
d663 2
a664 2
  Stub_table(Arm_input_section<big_endian>* own)
    : Output_data(), addralign_(1), owner_(own), has_been_changed_(false),
d758 2
a759 2
  Arm_input_section(Relobj* rel_obj, unsigned int sec_shndx)
    : Output_relaxed_input_section(rel_obj, sec_shndx, 1),
d782 2
a783 2
  set_stub_table(Stub_table<big_endian>* stubtable)
  { this->stub_table_ = stubtable; }
d817 2
a818 2
  do_output_offset(const Relobj* object, unsigned int sec_shndx,
		   section_offset_type off,
d822 3
a824 3
	&& (sec_shndx == this->shndx())
	&& (off >= 0)
	&& (convert_types<uint64_t, section_offset_type>(off)
d827 1
a827 1
	*poutput = off;
d854 3
a856 3
  Arm_output_section(const char* aname, elfcpp::Elf_Word atype,
		     elfcpp::Elf_Xword xflags)
    : Output_section(aname, atype, xflags)
d893 1
a893 1
  Arm_relobj(const std::string& aname, Input_file* inputfile, off_t off,
d895 1
a895 1
    : Sized_relobj<32, big_endian>(aname, inputfile, off, ehdr),
d905 1
a905 1
  stub_table(unsigned int sec_shndx) const
d907 2
a908 2
    gold_assert(sec_shndx < this->stub_tables_.size());
    return this->stub_tables_[sec_shndx];
d913 1
a913 1
  set_stub_table(unsigned int sec_shndx, Stub_table<big_endian>* stubtable)
d915 2
a916 2
    gold_assert(sec_shndx < this->stub_tables_.size());
    this->stub_tables_[sec_shndx] = stubtable;
d935 1
a935 1
  convert_input_section_to_relaxed_section(unsigned sec_shndx)
d939 1
a939 1
    this->invalidate_section_offset(sec_shndx);
d946 2
a947 2
  as_arm_relobj(Relobj* rel_obj)
  { return static_cast<Arm_relobj<big_endian>*>(rel_obj); }
d1007 1
a1007 1
  Arm_dynobj(const std::string& aname, Input_file* inputfile, off_t off,
d1009 2
a1010 2
    : Sized_dynobj<32, big_endian>(aname, inputfile, off, ehdr),
      processor_specific_flags_(0)
d1350 1
a1350 1
  find_arm_input_section(Relobj* rel_obj, unsigned int sec_shndx) const;
d1603 1
a1603 1
	     unsigned int sec_shndx, Output_section* output_section,
d1608 1
a1608 1
				  object, sec_shndx, output_section, reloc,
d2372 1
a2372 1
	  Stub_table<big_endian>* stubtable =
d2374 1
a2374 1
	  gold_assert(stubtable != NULL);
d2377 1
a2377 1
	  stub = stubtable->find_reloc_stub(stub_key);
d2380 1
a2380 1
	  branch_target = stubtable->address() + stub->offset() + addend;
d2519 1
a2519 1
	  Stub_table<big_endian>* stubtable =
d2521 1
a2521 1
	  gold_assert(stubtable != NULL);
d2524 1
a2524 1
	  Reloc_stub* stub = stubtable->find_reloc_stub(stub_key);
d2527 1
a2527 1
	  branch_target = stubtable->address() + stub->offset() + addend;
d2680 3
a2682 3
    Stub_type atype, const Insn_template* iinsns,
     size_t insncount)
  : type_(atype), insns_(iinsns), insn_count_(insncount), alignment_(1),
d2685 1
a2685 1
  off_t off = 0;
d2688 1
a2688 1
  for (size_t i = 0; i < insncount; i++)
d2690 3
a2692 3
      unsigned insn_alignment = iinsns[i].alignment();
      size_t insn_size = iinsns[i].size();
      gold_assert((off & (insn_alignment - 1)) == 0);
d2694 1
a2694 1
      switch (iinsns[i].type())
d2702 2
a2703 2
          if (iinsns[i].r_type() != elfcpp::R_ARM_NONE)
	    this->relocs_.push_back(Reloc(i, off));
d2711 2
a2712 2
	  if (iinsns[i].r_type() == elfcpp::R_ARM_JUMP24)
	    this->relocs_.push_back(Reloc(i, off));
d2718 1
a2718 1
	  this->relocs_.push_back(Reloc(i, off));
d2724 1
a2724 1
      off += insn_size; 
d2726 1
a2726 1
  this->size_ = off;
d2942 2
a2943 2
  const Stub_template* stubtemplate = this->stub_template();
  const Insn_template* insns = stubtemplate->insns();
d2947 1
a2947 1
  for (size_t i = 0; i < stubtemplate->insn_count(); i++)
d3201 2
a3202 2
  const Stub_template* stubtemplate = stub->stub_template();
  gold_assert(stubtemplate->type() == key.stub_type());
d3204 2
a3205 2
  if (this->addralign_ < stubtemplate->alignment())
    this->addralign_ = stubtemplate->alignment();
d3214 1
a3214 1
    Output_section* out_section,
d3216 1
a3216 1
    Arm_address addr,
d3221 1
a3221 1
  gold_assert(addr == this->address()
d3230 2
a3231 2
      const Stub_template* stubtemplate = stub->stub_template();
      if (stubtemplate->reloc_count() != 0)
d3234 3
a3236 3
	  section_size_type off = stub->offset();
	  section_size_type stub_size = stubtemplate->size();
	  gold_assert(off + stub_size <= view_size);
d3238 2
a3239 2
	  arm_target->relocate_stub(stub, relinfo, out_section,
				    view + off, addr + off,
d3258 2
a3259 2
      const Stub_template* stubtemplate = stub->stub_template();
      uint64_t stub_addralign = stubtemplate->alignment();
d3264 1
a3264 1
      off += stubtemplate->size();
d3277 1
a3277 1
  off_t off = this->offset();
d3280 1
a3280 1
  unsigned char* const oview = of->get_output_view(off, oview_size);
d3287 3
a3289 3
      Arm_address addr = this->address() + stub->offset();
      gold_assert(addr
		  == align_address(addr,
d3305 2
a3306 2
  Relobj* rel_obj = this->relobj();
  unsigned int sec_shndx = this->shndx();
d3310 2
a3311 2
  this->original_addralign_ = rel_obj->section_addralign(sec_shndx);
  this->original_size_ = rel_obj->section_size(sec_shndx);
d3315 5
a3319 5
  Output_section* os = rel_obj->output_section(sec_shndx);
  off_t off = rel_obj->output_section_offset(sec_shndx);
  gold_assert(os != NULL && !rel_obj->is_output_section_offset_invalid(sec_shndx));
  this->set_address(os->address() + off);
  this->set_file_offset(os->offset() + off);
d3349 1
a3349 1
      uint64_t addr = this->address();
d3352 6
a3357 6
      addr += this->original_size_;
      addr = align_address(addr, this->stub_table_->addralign());
      off_t off = this->offset() + (addr - this->address());
      this->stub_table_->set_address_and_file_offset(addr, off);
      addr += this->stub_table_->data_size();
      gold_assert(addr == this->address() + this->current_data_size());
d3375 1
a3375 1
      Stub_table<big_endian>* stubtable = this->stub_table_;
d3381 1
a3381 1
      off += stubtable->current_data_size();
d3423 1
a3423 1
  Stub_table<big_endian>* stubtable =
d3426 1
a3426 1
  arm_input_section->set_stub_table(stubtable);
d3440 1
a3440 1
	  arm_relobj->set_stub_table(p->shndx(), stubtable);
d3492 1
a3492 1
  Input_section_list::const_iterator stubtable =
d3527 1
a3527 1
		  stubtable = group_end;
d3539 1
a3539 1
	     this->create_stub_group(group_begin, group_end, stubtable,
d3576 1
a3576 1
			       : stubtable),
d3590 1
a3590 1
      unsigned int sec_shndx = new_relaxed_sections[i]->shndx();
d3592 1
a3592 1
      arm_relobj->convert_input_section_to_relaxed_section(sec_shndx);
d3605 1
a3605 1
    const Layout* alayout)
d3607 2
a3608 2
  unsigned int sec_shnum = this->shnum();
  const unsigned int shdrsize = elfcpp::Elf_sizes<32>::shdr_size;
d3612 1
a3612 1
					       sec_shnum * shdrsize,
d3623 1
a3623 1
  relinfo.layout = alayout;
d3626 2
a3627 2
  const unsigned char* p = pshdrs + shdrsize;
  for (unsigned int i = 1; i < sec_shnum; ++i, p += shdrsize)
d3741 1
a3741 1
  const unsigned int sym_tab_shndx = this->symtab_shndx();
d3743 1
a3743 1
      symtabshdr(this, this->elf_file()->section_header(sym_tab_shndx));
d3747 1
a3747 1
  const int symsize =elfcpp::Elf_sizes<32>::sym_size;
d3749 1
a3749 1
  off_t locsize = loccount * symsize;
d3757 1
a3757 1
  psyms += symsize;
d3760 1
a3760 1
  for (unsigned int i = 1; i < loccount; ++i, psyms += symsize)
d3784 1
a3784 1
    const Layout* alayout,
d3789 1
a3789 1
  Sized_relobj<32, big_endian>::do_relocate_sections(symtab, alayout, pshdrs,
d3797 1
a3797 1
  unsigned int sec_shnum = this->shnum();
d3804 1
a3804 1
  relinfo.layout = alayout;
d3807 1
a3807 1
  for (unsigned int i = 1; i < sec_shnum; ++i)
d3830 3
a3832 3
      Stub_table<big_endian>* stubtable = arm_input_section->stub_table();
      gold_assert((stubtable->address() >= (*pviews)[i].address)
		  && ((stubtable->address() + stubtable->data_size())
d3835 4
a3838 4
      off_t off = stubtable->address() - (*pviews)[i].address;
      unsigned char* pview = (*pviews)[i].view + off;
      Arm_address address = stubtable->address();
      section_size_type view_size = stubtable->data_size();
d3840 2
a3841 2
      stubtable->relocate_stubs(&relinfo, arm_target, os, pview, address,
				view_size);
d4046 1
a4046 1
Output_data_plt_arm<big_endian>::Output_data_plt_arm(Layout* alayout,
d4051 2
a4052 2
  alayout->add_output_section_data(".rel.plt", elfcpp::SHT_REL,
				   elfcpp::SHF_ALLOC, this->rel_, true);
d4128 1
a4128 1
  const off_t off = this->offset();
d4131 1
a4131 1
  unsigned char* const oview = of->get_output_view(off, oview_size);
d4173 2
a4174 2
      int32_t offst = ((got_address + got_offset)
		       - (plt_address + plt_offset + 8));
d4176 2
a4177 2
      gold_assert(offst >= 0 && offst < 0x0fffffff);
      uint32_t plt_insn0 = plt_entry[0] | ((offst >> 20) & 0xff);
d4179 1
a4179 1
      uint32_t plt_insn1 = plt_entry[1] | ((offst >> 12) & 0xff);
d4181 1
a4181 1
      uint32_t plt_insn2 = plt_entry[2] | (offst & 0xfff);
d4191 1
a4191 1
  of->write_output_view(off, oview_size, oview);
d4199 1
a4199 1
Target_arm<big_endian>::make_plt_entry(Symbol_table* symtab, Layout* alayout,
d4208 1
a4208 1
      this->got_section(symtab, alayout);
d4210 5
a4214 5
      this->plt_ = new Output_data_plt_arm<big_endian>(alayout, this->got_plt_);
      alayout->add_output_section_data(".plt", elfcpp::SHT_PROGBITS,
				       (elfcpp::SHF_ALLOC
					| elfcpp::SHF_EXECINSTR),
				       this->plt_, false);
d4284 1
a4284 1
				    Layout* alayout,
d4309 1
a4309 1
	  Reloc_section* rel_dyn = target->rel_dyn_section(alayout);
d4342 1
a4342 1
      target->got_section(symtab, alayout);
d4354 1
a4354 1
	  target->got_section(symtab, alayout);
d4362 2
a4363 2
		Reloc_section* rel_dyn = target->rel_dyn_section(alayout);
		unsigned int rsym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
d4365 2
a4366 2
		    object, rsym, elfcpp::R_ARM_RELATIVE, got,
		    object->local_got_offset(rsym, GOT_TYPE_STANDARD));
d4411 1
a4411 1
				     Layout* alayout,
d4434 1
a4434 1
		target->copy_reloc(symtab, alayout, object,
d4441 1
a4441 1
		Reloc_section* rel_dyn = target->rel_dyn_section(alayout);
d4450 1
a4450 1
		Reloc_section* rel_dyn = target->rel_dyn_section(alayout);
d4494 1
a4494 1
		target->copy_reloc(symtab, alayout, object,
d4500 1
a4500 1
		Reloc_section* rel_dyn = target->rel_dyn_section(alayout);
d4514 1
a4514 1
	target->make_plt_entry(symtab, alayout, gsym);
d4543 1
a4543 1
      target->make_plt_entry(symtab, alayout, gsym);
d4548 1
a4548 1
      target->got_section(symtab, alayout);
d4560 1
a4560 1
	  target->got_section(symtab, alayout);
d4567 1
a4567 1
	    Reloc_section* rel_dyn = target->rel_dyn_section(alayout);
d4608 1
a4608 1
					  Layout* alayout,
d4620 1
a4620 1
  typedef typename Target_arm<big_endian>::Scan scan;
d4622 1
a4622 1
  gold::gc_process_relocs<32, big_endian, Arm, elfcpp::SHT_REL, scan>(
d4624 1
a4624 1
    alayout,
d4641 1
a4641 1
				    Layout* alayout,
d4652 1
a4652 1
  typedef typename Target_arm<big_endian>::Scan scan;
d4660 1
a4660 1
  gold::scan_relocs<32, big_endian, Target_arm, elfcpp::SHT_REL, scan>(
d4662 1
a4662 1
    alayout,
d4679 1
a4679 1
    Layout* alayout,
d4718 1
a4718 1
  Output_data_dynamic* const odyn = alayout->dynamic_data();
d4755 1
a4755 1
    this->copy_relocs_.emit(this->rel_dyn_section(alayout));
d4758 1
a4758 1
  Output_section* exidx_section = alayout->find_output_section(".ARM.exidx");
d4775 1
a4775 1
      if (!alayout->script_options()->saw_phdrs_clause())
d4777 1
a4777 1
	  gold_assert(alayout->find_output_segment(elfcpp::PT_ARM_EXIDX, 0, 0)
d4780 1
a4780 1
	    alayout->make_output_segment(elfcpp::PT_ARM_EXIDX, elfcpp::PF_R);
d4787 1
a4787 1
  Output_attributes_section_data* as =
d4789 3
a4791 2
  alayout->add_output_section_data(".ARM.attributes",
				   elfcpp::SHT_ARM_ATTRIBUTES, 0, as, false);
d5289 3
a5291 3
      off_t off = section_address - address;
      view += off;
      address += off;
d5380 1
a5380 1
    Layout* alayout,
d5400 1
a5400 1
    alayout,
d5579 1
a5579 1
    off_t off, const elfcpp::Ehdr<32, big_endian>& ehdr)
d5585 1
a5585 1
        new Arm_relobj<big_endian>(name, input_file, off, ehdr);
d5592 1
a5592 1
        new Arm_dynobj<big_endian>(name, input_file, off, ehdr);
d6427 2
a6428 2
    Relobj* rel_obj,
    unsigned int sec_shndx)
d6430 1
a6430 1
  Input_section_specifier iss(rel_obj, sec_shndx);
d6433 1
a6433 1
    new Arm_input_section<big_endian>(rel_obj, sec_shndx);
d6453 2
a6454 2
    Relobj* rel_obj,
    unsigned int sec_shndx) const
d6456 1
a6456 1
  Input_section_specifier iss(rel_obj, sec_shndx);
d6468 1
a6468 1
  Stub_table<big_endian>* stubtable =
d6470 1
a6470 1
  this->stub_tables_.push_back(stubtable);
d6472 3
a6474 3
  stubtable->set_address(owner->address() + owner->data_size());
  stubtable->set_file_offset(owner->offset() + owner->data_size());
  stubtable->finalize_data_size();
d6476 1
a6476 1
  return stubtable;
d6492 1
a6492 1
  typedef typename Target_arm<big_endian>::Relocate relocate;
d6503 1
a6503 1
      if (gsym->use_plt_offset(relocate::reloc_is_non_pic(r_type)))
d6574 1
a6574 1
  Stub_table<big_endian>* stubtable = 
d6576 1
a6576 1
  gold_assert(stubtable != NULL);
d6582 1
a6582 1
  Reloc_stub* stub = stubtable->find_reloc_stub(stub_key);
d6587 1
a6587 1
      stubtable->add_reloc_stub(stub, stub_key);
d6656 1
a6656 1
      section_offset_type off =
d6661 4
a6664 4
	  off = output_section->output_offset(relinfo->object,
					      relinfo->data_shndx,
					      off);
	  if (off == -1)
d6671 1
a6671 1
	stub_addend_reader(r_type, view + off, reloc);
d6688 1
a6688 1
	  unsigned int sec_shndx = psymval->input_shndx(&is_ordinary);
d6690 3
a6692 3
	      && sec_shndx != elfcpp::SHN_UNDEF
	      && !arm_object->is_section_included(sec_shndx) 
              && !(relinfo->symtab->is_section_folded(arm_object, sec_shndx)))
d6704 1
a6704 1
	            arm_object->map_to_kept_section(sec_shndx, &found);
d6754 1
a6754 1
				addend, view_address + off);
d6812 1
a6812 1
    Layout* alayout,
d6818 1
a6818 1
  alayout->get_allocated_sections(&section_list);
d6838 1
a6838 1
    Layout* alayout)
d6870 1
a6870 1
      group_sections(alayout, stub_group_size, stubs_always_after_branch);
d6887 1
a6887 1
      arm_relobj->scan_sections_for_stubs(this, symtab, alayout);
d6915 2
a6916 2
  const Stub_template* stubtemplate = stub->stub_template();
  for (size_t i = 0; i < stubtemplate->reloc_count(); i++)
d6918 2
a6919 2
      size_t reloc_insn_index = stubtemplate->reloc_insn_index(i);
      const Insn_template* insn = &stubtemplate->insns()[reloc_insn_index];
d6922 1
a6922 1
      section_size_type reloc_offset = stubtemplate->reloc_offset(i);
@


1.41
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d4787 1
a4787 1
  Output_attributes_section_data* attributes_section =
d4789 2
a4790 3
  layout->add_output_section_data(".ARM.attributes",
				  elfcpp::SHT_ARM_ATTRIBUTES, 0,
				  attributes_section, false);
@


1.40
log
@2009-12-10  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog
	* arm.h: New enums for EABI object attribute tags and values.

gold/ChangeLog
	* arm.cc (attributes.h): New include.
	(Arm_relobj::Arm_relobj): Initialize attributes_section_data_.
	(Arm_relobj::~Arm_relobj): Delete object pointed by
	attributes_section_data_.
	(Arm_relobj::attributes_section_data): New method definition.
	(Arm_relobj::attributes_section_data_): New data member declaration.
	(Arm_dynobj::Arm_dynobj): Initialize attributes_section_data_.
	(Arm_dynobj::~Arm_dynobj): Delete object pointed by
	attributes_section_data_.
	(Arm_dynobj::attributes_section_data): New method definition.
	(Arm_dynobj::attributes_section_data_): New data member declaration.
	(Target_arm::Target_arm): Initialize attributes_section_data_.  Change
	initialization value of may_use_blx_ to false.
   	(Target_arm::using_thumb2, Target_arm::using_thumb_only,
	Target_arm::may_use_arm_nop, Target_arm::may_use_thumb2_nop): Use
	object attributes to compute results instead of hard-coding.
	(Target_arm::do_attribute_arg_type, Target_arm::do_attributes_order,
	Target_arm::get_secondary_compatible_arch,
	Target_arm::set_secondary_compatible_arch
	Target_arm::tag_cpu_arch_combine, Target_arm::aeabi_enum_name,
	Target_arm::tag_cpu_name_value, Target_arm::merge_object_attributes):
	New method declarations.
	(Target_arm::get_aeabi_object_attribute): New method definition.
	(Target_arm::attributes_section_data_): New data member declaration.
	(read_arm_attributes_section): New template definition.
	(Arm_relobj::do_read_symbols): Read attributes section if it exists.
	(Arm_dynobj::do_read_symbols): Ditto.
	(Target_arm::do_finalize_sections): Merge attributes sections from
	input.  Check for BLX use after attributes section merging.
	Fix __exidx_start and __exidx_end visibility.  Create an
	.ARM.attributes section if necessary.
	(Target_arm::get_secondary_compatible_arch,
	Target_arm::set_secondary_compatible_arch,
	Target_arm::tag_cpu_arch_combine, Target_arm::aeabi_enum_name,
	Target_arm::tag_cpu_name_value, Target_arm::merge_object_attributes,
	Target_arm::do_attribute_arg_type, Target_arm::do_attributes_order):
	New method definitions.
@
text
@d213 2
a214 2
  Insn_template(unsigned data, Type type, unsigned int r_type, int reloc_addend)
    : data_(data), type_(type), r_type_(r_type), reloc_addend_(reloc_addend)
d376 2
a377 2
  Stub(const Stub_template* stub_template)
    : stub_template_(stub_template), offset_(invalid_offset)
d399 2
a400 2
  set_offset(section_offset_type offset)
  { this->offset_ = offset; }
d478 3
a480 3
    Key(Stub_type stub_type, const Symbol* symbol, const Relobj* relobj,
	unsigned int r_sym, int32_t addend)
      : stub_type_(stub_type), addend_(addend)
d482 1
a482 1
      if (symbol != NULL)
d485 1
a485 1
	  this->u_.symbol = symbol;
d489 3
a491 3
	  gold_assert(relobj != NULL && r_sym != invalid_index);
	  this->r_sym_ = r_sym;
	  this->u_.relobj = relobj;
d588 2
a589 2
  Reloc_stub(const Stub_template* stub_template)
    : Stub(stub_template), destination_address_(invalid_address)
d663 2
a664 2
  Stub_table(Arm_input_section<big_endian>* owner)
    : Output_data(), addralign_(1), owner_(owner), has_been_changed_(false),
d758 2
a759 2
  Arm_input_section(Relobj* relobj, unsigned int shndx)
    : Output_relaxed_input_section(relobj, shndx, 1),
d782 2
a783 2
  set_stub_table(Stub_table<big_endian>* stub_table)
  { this->stub_table_ = stub_table; }
d817 2
a818 2
  do_output_offset(const Relobj* object, unsigned int shndx,
		   section_offset_type offset,
d822 3
a824 3
	&& (shndx == this->shndx())
	&& (offset >= 0)
	&& (convert_types<uint64_t, section_offset_type>(offset)
d827 1
a827 1
	*poutput = offset;
d854 3
a856 3
  Arm_output_section(const char* name, elfcpp::Elf_Word type,
		     elfcpp::Elf_Xword flags)
    : Output_section(name, type, flags)
d893 1
a893 1
  Arm_relobj(const std::string& name, Input_file* input_file, off_t offset,
d895 1
a895 1
    : Sized_relobj<32, big_endian>(name, input_file, offset, ehdr),
d905 1
a905 1
  stub_table(unsigned int shndx) const
d907 2
a908 2
    gold_assert(shndx < this->stub_tables_.size());
    return this->stub_tables_[shndx];
d913 1
a913 1
  set_stub_table(unsigned int shndx, Stub_table<big_endian>* stub_table)
d915 2
a916 2
    gold_assert(shndx < this->stub_tables_.size());
    this->stub_tables_[shndx] = stub_table;
d935 1
a935 1
  convert_input_section_to_relaxed_section(unsigned shndx)
d939 1
a939 1
    this->invalidate_section_offset(shndx);
d946 2
a947 2
  as_arm_relobj(Relobj* relobj)
  { return static_cast<Arm_relobj<big_endian>*>(relobj); }
d1007 1
a1007 1
  Arm_dynobj(const std::string& name, Input_file* input_file, off_t offset,
d1009 2
a1010 2
    : Sized_dynobj<32, big_endian>(name, input_file, offset, ehdr),
      processor_specific_flags_(0), attributes_section_data_(NULL)
d1350 1
a1350 1
  find_arm_input_section(Relobj* relobj, unsigned int shndx) const;
d1603 1
a1603 1
	     unsigned int shndx, Output_section* output_section,
d1608 1
a1608 1
				  object, shndx, output_section, reloc,
d2372 1
a2372 1
	  Stub_table<big_endian>* stub_table =
d2374 1
a2374 1
	  gold_assert(stub_table != NULL);
d2377 1
a2377 1
	  stub = stub_table->find_reloc_stub(stub_key);
d2380 1
a2380 1
	  branch_target = stub_table->address() + stub->offset() + addend;
d2519 1
a2519 1
	  Stub_table<big_endian>* stub_table =
d2521 1
a2521 1
	  gold_assert(stub_table != NULL);
d2524 1
a2524 1
	  Reloc_stub* stub = stub_table->find_reloc_stub(stub_key);
d2527 1
a2527 1
	  branch_target = stub_table->address() + stub->offset() + addend;
d2680 3
a2682 3
    Stub_type type, const Insn_template* insns,
     size_t insn_count)
  : type_(type), insns_(insns), insn_count_(insn_count), alignment_(1),
d2685 1
a2685 1
  off_t offset = 0;
d2688 1
a2688 1
  for (size_t i = 0; i < insn_count; i++)
d2690 3
a2692 3
      unsigned insn_alignment = insns[i].alignment();
      size_t insn_size = insns[i].size();
      gold_assert((offset & (insn_alignment - 1)) == 0);
d2694 1
a2694 1
      switch (insns[i].type())
d2702 2
a2703 2
          if (insns[i].r_type() != elfcpp::R_ARM_NONE)
	    this->relocs_.push_back(Reloc(i, offset));
d2711 2
a2712 2
	  if (insns[i].r_type() == elfcpp::R_ARM_JUMP24)
	    this->relocs_.push_back(Reloc(i, offset));
d2718 1
a2718 1
	  this->relocs_.push_back(Reloc(i, offset));
d2724 1
a2724 1
      offset += insn_size; 
d2726 1
a2726 1
  this->size_ = offset;
d2942 2
a2943 2
  const Stub_template* stub_template = this->stub_template();
  const Insn_template* insns = stub_template->insns();
d2947 1
a2947 1
  for (size_t i = 0; i < stub_template->insn_count(); i++)
d3201 2
a3202 2
  const Stub_template* stub_template = stub->stub_template();
  gold_assert(stub_template->type() == key.stub_type());
d3204 2
a3205 2
  if (this->addralign_ < stub_template->alignment())
    this->addralign_ = stub_template->alignment();
d3214 1
a3214 1
    Output_section* output_section,
d3216 1
a3216 1
    Arm_address address,
d3221 1
a3221 1
  gold_assert(address == this->address()
d3230 2
a3231 2
      const Stub_template* stub_template = stub->stub_template();
      if (stub_template->reloc_count() != 0)
d3234 3
a3236 3
	  section_size_type offset = stub->offset();
	  section_size_type stub_size = stub_template->size();
	  gold_assert(offset + stub_size <= view_size);
d3238 2
a3239 2
	  arm_target->relocate_stub(stub, relinfo, output_section,
				    view + offset, address + offset,
d3258 2
a3259 2
      const Stub_template* stub_template = stub->stub_template();
      uint64_t stub_addralign = stub_template->alignment();
d3264 1
a3264 1
      off += stub_template->size();
d3277 1
a3277 1
  off_t offset = this->offset();
d3280 1
a3280 1
  unsigned char* const oview = of->get_output_view(offset, oview_size);
d3287 3
a3289 3
      Arm_address address = this->address() + stub->offset();
      gold_assert(address
		  == align_address(address,
d3305 2
a3306 2
  Relobj* relobj = this->relobj();
  unsigned int shndx = this->shndx();
d3310 2
a3311 2
  this->original_addralign_ = relobj->section_addralign(shndx);
  this->original_size_ = relobj->section_size(shndx);
d3315 5
a3319 5
  Output_section* os = relobj->output_section(shndx);
  off_t offset = relobj->output_section_offset(shndx);
  gold_assert(os != NULL && !relobj->is_output_section_offset_invalid(shndx));
  this->set_address(os->address() + offset);
  this->set_file_offset(os->offset() + offset);
d3349 1
a3349 1
      uint64_t address = this->address();
d3352 6
a3357 6
      address += this->original_size_;
      address = align_address(address, this->stub_table_->addralign());
      off_t offset = this->offset() + (address - this->address());
      this->stub_table_->set_address_and_file_offset(address, offset);
      address += this->stub_table_->data_size();
      gold_assert(address == this->address() + this->current_data_size());
d3375 1
a3375 1
      Stub_table<big_endian>* stub_table = this->stub_table_;
d3381 1
a3381 1
      off += stub_table->current_data_size();
d3423 1
a3423 1
  Stub_table<big_endian>* stub_table =
d3426 1
a3426 1
  arm_input_section->set_stub_table(stub_table);
d3440 1
a3440 1
	  arm_relobj->set_stub_table(p->shndx(), stub_table);
d3492 1
a3492 1
  Input_section_list::const_iterator stub_table =
d3527 1
a3527 1
		  stub_table = group_end;
d3539 1
a3539 1
	     this->create_stub_group(group_begin, group_end, stub_table,
d3576 1
a3576 1
			       : stub_table),
d3590 1
a3590 1
      unsigned int shndx = new_relaxed_sections[i]->shndx();
d3592 1
a3592 1
      arm_relobj->convert_input_section_to_relaxed_section(shndx);
d3605 1
a3605 1
    const Layout* layout)
d3607 2
a3608 2
  unsigned int shnum = this->shnum();
  const unsigned int shdr_size = elfcpp::Elf_sizes<32>::shdr_size;
d3612 1
a3612 1
					       shnum * shdr_size,
d3623 1
a3623 1
  relinfo.layout = layout;
d3626 2
a3627 2
  const unsigned char* p = pshdrs + shdr_size;
  for (unsigned int i = 1; i < shnum; ++i, p += shdr_size)
d3741 1
a3741 1
  const unsigned int symtab_shndx = this->symtab_shndx();
d3743 1
a3743 1
      symtabshdr(this, this->elf_file()->section_header(symtab_shndx));
d3747 1
a3747 1
  const int sym_size =elfcpp::Elf_sizes<32>::sym_size;
d3749 1
a3749 1
  off_t locsize = loccount * sym_size;
d3757 1
a3757 1
  psyms += sym_size;
d3760 1
a3760 1
  for (unsigned int i = 1; i < loccount; ++i, psyms += sym_size)
d3784 1
a3784 1
    const Layout* layout,
d3789 1
a3789 1
  Sized_relobj<32, big_endian>::do_relocate_sections(symtab, layout, pshdrs,
d3797 1
a3797 1
  unsigned int shnum = this->shnum();
d3804 1
a3804 1
  relinfo.layout = layout;
d3807 1
a3807 1
  for (unsigned int i = 1; i < shnum; ++i)
d3830 3
a3832 3
      Stub_table<big_endian>* stub_table = arm_input_section->stub_table();
      gold_assert((stub_table->address() >= (*pviews)[i].address)
		  && ((stub_table->address() + stub_table->data_size())
d3835 4
a3838 4
      off_t offset = stub_table->address() - (*pviews)[i].address;
      unsigned char* view = (*pviews)[i].view + offset;
      Arm_address address = stub_table->address();
      section_size_type view_size = stub_table->data_size();
d3840 2
a3841 2
      stub_table->relocate_stubs(&relinfo, arm_target, os, view, address,
				 view_size);
d4046 1
a4046 1
Output_data_plt_arm<big_endian>::Output_data_plt_arm(Layout* layout,
d4051 2
a4052 2
  layout->add_output_section_data(".rel.plt", elfcpp::SHT_REL,
				  elfcpp::SHF_ALLOC, this->rel_, true);
d4128 1
a4128 1
  const off_t offset = this->offset();
d4131 1
a4131 1
  unsigned char* const oview = of->get_output_view(offset, oview_size);
d4173 2
a4174 2
      int32_t offset = ((got_address + got_offset)
			 - (plt_address + plt_offset + 8));
d4176 2
a4177 2
      gold_assert(offset >= 0 && offset < 0x0fffffff);
      uint32_t plt_insn0 = plt_entry[0] | ((offset >> 20) & 0xff);
d4179 1
a4179 1
      uint32_t plt_insn1 = plt_entry[1] | ((offset >> 12) & 0xff);
d4181 1
a4181 1
      uint32_t plt_insn2 = plt_entry[2] | (offset & 0xfff);
d4191 1
a4191 1
  of->write_output_view(offset, oview_size, oview);
d4199 1
a4199 1
Target_arm<big_endian>::make_plt_entry(Symbol_table* symtab, Layout* layout,
d4208 1
a4208 1
      this->got_section(symtab, layout);
d4210 5
a4214 5
      this->plt_ = new Output_data_plt_arm<big_endian>(layout, this->got_plt_);
      layout->add_output_section_data(".plt", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_EXECINSTR),
				      this->plt_, false);
d4284 1
a4284 1
				    Layout* layout,
d4309 1
a4309 1
	  Reloc_section* rel_dyn = target->rel_dyn_section(layout);
d4342 1
a4342 1
      target->got_section(symtab, layout);
d4354 1
a4354 1
	  target->got_section(symtab, layout);
d4362 2
a4363 2
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
d4365 2
a4366 2
		    object, r_sym, elfcpp::R_ARM_RELATIVE, got,
		    object->local_got_offset(r_sym, GOT_TYPE_STANDARD));
d4411 1
a4411 1
				     Layout* layout,
d4434 1
a4434 1
		target->copy_reloc(symtab, layout, object,
d4441 1
a4441 1
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
d4450 1
a4450 1
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
d4494 1
a4494 1
		target->copy_reloc(symtab, layout, object,
d4500 1
a4500 1
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
d4514 1
a4514 1
	target->make_plt_entry(symtab, layout, gsym);
d4543 1
a4543 1
      target->make_plt_entry(symtab, layout, gsym);
d4548 1
a4548 1
      target->got_section(symtab, layout);
d4560 1
a4560 1
	  target->got_section(symtab, layout);
d4567 1
a4567 1
	    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
d4608 1
a4608 1
					  Layout* layout,
d4620 1
a4620 1
  typedef typename Target_arm<big_endian>::Scan Scan;
d4622 1
a4622 1
  gold::gc_process_relocs<32, big_endian, Arm, elfcpp::SHT_REL, Scan>(
d4624 1
a4624 1
    layout,
d4641 1
a4641 1
				    Layout* layout,
d4652 1
a4652 1
  typedef typename Target_arm<big_endian>::Scan Scan;
d4660 1
a4660 1
  gold::scan_relocs<32, big_endian, Target_arm, elfcpp::SHT_REL, Scan>(
d4662 1
a4662 1
    layout,
d4679 1
a4679 1
    Layout* layout,
d4718 1
a4718 1
  Output_data_dynamic* const odyn = layout->dynamic_data();
d4755 1
a4755 1
    this->copy_relocs_.emit(this->rel_dyn_section(layout));
d4758 1
a4758 1
  Output_section* exidx_section = layout->find_output_section(".ARM.exidx");
d4775 1
a4775 1
      if (!layout->script_options()->saw_phdrs_clause())
d4777 1
a4777 1
	  gold_assert(layout->find_output_segment(elfcpp::PT_ARM_EXIDX, 0, 0)
d4780 1
a4780 1
	    layout->make_output_segment(elfcpp::PT_ARM_EXIDX, elfcpp::PF_R);
d5289 3
a5291 3
      off_t offset = section_address - address;
      view += offset;
      address += offset;
d5380 1
a5380 1
    Layout* layout,
d5400 1
a5400 1
    layout,
d5579 1
a5579 1
    off_t offset, const elfcpp::Ehdr<32, big_endian>& ehdr)
d5585 1
a5585 1
        new Arm_relobj<big_endian>(name, input_file, offset, ehdr);
d5592 1
a5592 1
        new Arm_dynobj<big_endian>(name, input_file, offset, ehdr);
d6427 2
a6428 2
    Relobj* relobj,
    unsigned int shndx)
d6430 1
a6430 1
  Input_section_specifier iss(relobj, shndx);
d6433 1
a6433 1
    new Arm_input_section<big_endian>(relobj, shndx);
d6453 2
a6454 2
    Relobj* relobj,
    unsigned int shndx) const
d6456 1
a6456 1
  Input_section_specifier iss(relobj, shndx);
d6468 1
a6468 1
  Stub_table<big_endian>* stub_table =
d6470 1
a6470 1
  this->stub_tables_.push_back(stub_table);
d6472 3
a6474 3
  stub_table->set_address(owner->address() + owner->data_size());
  stub_table->set_file_offset(owner->offset() + owner->data_size());
  stub_table->finalize_data_size();
d6476 1
a6476 1
  return stub_table;
d6492 1
a6492 1
  typedef typename Target_arm<big_endian>::Relocate Relocate;
d6503 1
a6503 1
      if (gsym->use_plt_offset(Relocate::reloc_is_non_pic(r_type)))
d6574 1
a6574 1
  Stub_table<big_endian>* stub_table = 
d6576 1
a6576 1
  gold_assert(stub_table != NULL);
d6582 1
a6582 1
  Reloc_stub* stub = stub_table->find_reloc_stub(stub_key);
d6587 1
a6587 1
      stub_table->add_reloc_stub(stub, stub_key);
d6656 1
a6656 1
      section_offset_type offset =
d6661 4
a6664 4
	  offset = output_section->output_offset(relinfo->object,
						 relinfo->data_shndx,
						 offset);
	  if (offset == -1)
d6671 1
a6671 1
	stub_addend_reader(r_type, view + offset, reloc);
d6688 1
a6688 1
	  unsigned int shndx = psymval->input_shndx(&is_ordinary);
d6690 3
a6692 3
	      && shndx != elfcpp::SHN_UNDEF
	      && !arm_object->is_section_included(shndx) 
              && !(relinfo->symtab->is_section_folded(arm_object, shndx)))
d6704 1
a6704 1
	            arm_object->map_to_kept_section(shndx, &found);
d6754 1
a6754 1
				addend, view_address + offset);
d6812 1
a6812 1
    Layout* layout,
d6818 1
a6818 1
  layout->get_allocated_sections(&section_list);
d6838 1
a6838 1
    Layout* layout)
d6870 1
a6870 1
      group_sections(layout, stub_group_size, stubs_always_after_branch);
d6887 1
a6887 1
      arm_relobj->scan_sections_for_stubs(this, symtab, layout);
d6915 2
a6916 2
  const Stub_template* stub_template = stub->stub_template();
  for (size_t i = 0; i < stub_template->reloc_count(); i++)
d6918 2
a6919 2
      size_t reloc_insn_index = stub_template->reloc_insn_index(i);
      const Insn_template* insn = &stub_template->insns()[reloc_insn_index];
d6922 1
a6922 1
      section_size_type reloc_offset = stub_template->reloc_offset(i);
@


1.39
log
@2009-12-05  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:

	* arm.h: Define enums for Tag_CPU_arch EABI attribute.

gold/ChangeLog:
	* arm.cc (Target_arm::arm_info): Initialize new fields
	attributes_section and attributes_vendor.
	* i386.cc (Target_i386::i386_info): Same.
	* object.cc (Sized_relobj::do_layout): Skip attribute section.
	* gold/powerpc.cc (Target_powerpc::powerpc_info): Initialize new
	fields attributes_section and attributes_vendor.
 	* sparc.cc (Target_sparc::sparc_info): Same.
	* target.h (Target::attributes_section, Target::attributes_vendor,
	Target::is_attributes_section, Target::attribute_arg_type,
	Target::attributes_order): New method definitions.
	(Target::Target_info::attributes_section,
	Target::Target_info::attributes_vendor): New fields.
	(Target::do_attribute_arg_type, Target::do_attributes_order): New
	virtual method definitions.
	* x86_64.cc (Target_x86_64::x86_64_info): Initialize new fields
	attributes_section and attributes_vendor.
	* testsuite/testfile.cc (Target_test::test_target_info): Same.
@
text
@d49 1
d896 2
a897 1
      stub_tables_(), local_symbol_is_thumb_function_()
d901 1
a901 1
  { }
d955 6
d997 2
d1010 1
a1010 1
      processor_specific_flags_(0)
d1014 1
a1014 1
  { }
d1028 5
d1041 2
d1163 3
a1165 3
      stub_factory_(Stub_factory::get_instance()),
      may_use_blx_(true), should_force_pic_veneer_(false),
      arm_input_section_map_()
d1192 4
a1195 2
    // FIXME:  This should not hard-coded.
    return false;
d1202 7
a1208 2
    // FIXME:  This should not hard-coded.
    return false;
d1215 7
a1221 2
    // FIXME:  This should not hard-coded.
    return false;
d1228 6
a1233 2
    // FIXME:  This should not hard-coded.
    return false;
d1422 9
d1621 35
d1725 2
d3845 31
d3891 2
d3912 2
d4693 3
d4707 2
d4711 6
d4766 1
a4766 1
				    elfcpp::STB_LOCAL, elfcpp::STV_HIDDEN, 0,
d4770 1
a4770 1
				    elfcpp::STB_LOCAL, elfcpp::STV_HIDDEN, 0,
d4785 7
d5604 768
d6947 47
a6993 1
// The selector for arm object files.
@


1.38
log
@2009-12-05  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Update comments about interworking and stub generation.
	(Target_arm::Relocate::reloc_is_non_pic): Update list of relocations
	considered as non-PIC.
	(Arm_relocate_functions::base_abs): Fix formatting.
	(Arm_relocate_functions::got_prel): Fix comment.  Change interface
	of function to use GOT entry address instead of offset.
	(Target_arm::Scan::global): Issue an error if a symbol would need a
	PLT does not get one because it is untyped.  Remove code to create
	dynamic symbols for relative branches.
	(Target_arm::Relocate::relocate: Use 0 instead of false since function
	takes unsigned integer instead of boolean.
@
text
@d1668 3
a1670 1
  0			// large_common_section_flags
@


1.37
log
@2009-12-03  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Remove comment about missing .ARM.exidx section symbols.
	(Target_arm::do_finalize_sections): Add parameter for symbol table
	pointer.  Add __exidx_start and __exidx_end symbols as appropriate.
	* i386.cc (Target_i386::do_finalize_sections): Add an additional
	parameter for symbol table pointer.
	* layout.cc (Layout::finalize): Call Target::finalize_sections with
	an additional parameter for a pointer to symbol table.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add an additional
	parameter for a symbol table pointer.
	* sparc.cc (Target_sparc::do_finalize_sections): Ditto.
	* target.h (Target::finalize_sections, Target::do_finalize_sections):
	Ditto.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add an additional
	parameter for a symbol table pointer.
@
text
@a123 2
// - Generate various branch stubs.
// - Support interworking.
d1476 2
a1477 1
    // reloc.
d1483 13
a1495 1
	case elfcpp::R_ARM_REL32:
a1496 1
	case elfcpp::R_ARM_CALL:
d1498 7
a1504 6
	case elfcpp::R_ARM_PREL31:
	case elfcpp::R_ARM_THM_ABS5:
	case elfcpp::R_ARM_ABS8:
	case elfcpp::R_ARM_ABS12:
	case elfcpp::R_ARM_ABS16:
	case elfcpp::R_ARM_BASE_ABS:
a1505 2
	default:
	  return false;
d1937 1
a1937 1
	    Arm_address origin)
d1952 1
a1952 1
  // R_ARM_GOT_PREL: GOT(S) + A  P
d1954 2
a1955 2
  got_prel(unsigned char* view,
	   typename elfcpp::Swap<32, big_endian>::Valtype got_offset,
d1958 1
a1958 1
    Base::rel32(view, got_offset - address);
d4393 2
d4396 17
a4412 26
    case elfcpp::R_ARM_CALL:
      {
	if (Target_arm<big_endian>::Scan::symbol_needs_plt_entry(gsym))
	  target->make_plt_entry(symtab, layout, gsym);
	// Make a dynamic relocation if necessary.
	int flags = Symbol::NON_PIC_REF;
	if (gsym->type() == elfcpp::STT_FUNC
	    || gsym->type() == elfcpp::STT_ARM_TFUNC)
	  flags |= Symbol::FUNCTION_CALL;
	if (gsym->needs_dynamic_reloc(flags))
	  {
	    if (target->may_need_copy_reloc(gsym))
	      {
		target->copy_reloc(symtab, layout, object,
				   data_shndx, output_section, gsym,
				   reloc);
	      }
	    else
	      {
		check_non_pic(object, r_type);
		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
		rel_dyn->add_global(gsym, r_type, output_section, object,
				    data_shndx, reloc.get_r_offset());
	      }
	  }
      }
d4862 1
a4862 1
						     false);
@


1.36
log
@2009-11-25  Doug Kwan  <dougkwan@@google.com>

	Revert:

	2009-11-25  Doug Kwan  <dougkwan@@google.com>

		* arm.cc (Target_arm::Target_arm): Move method definition
		outside of class definition.  Add code to handle
		--target1-rel, --target1-abs and --target2= options.
		(Target_arm::get_reloc_reloc_type): Change method to be
		non-static and const.
		(Target_arm::target1_is_rel_, Target_arm::target2_reloc_):
		New data member declaration.
		(Target_arm::Scan::local, Target_arm::Scan::global,
		Target_arm::Relocate::relocate,
		Target_arm::Relocatable_size_for_reloc::get_size_for_reloc):
		Adjust call to Target_arm::get_real_reloc_type.
		(Target_arm::get_real_reloc_type): Use command line options
		to determine real types of R_ARM_TARGET1 and R_ARM_TARGET2.
		* options.h (--target1-rel, --target1-abs, --target2): New
		ARM-only options.
@
text
@a125 1
// - Define section symbols __exidx_start and __exidx_stop.
d1236 1
a1236 1
  do_finalize_sections(Layout*, const Input_objects*);
d4562 2
a4563 1
    const Input_objects* input_objects)
d4628 4
a4631 3
  // For the ARM target, we need to add a PT_ARM_EXIDX segment for
  // the .ARM.exidx section.
  if (!layout->script_options()->saw_phdrs_clause()
d4634 9
a4642 2
      Output_section* exidx_section =
	layout->find_output_section(".ARM.exidx");
d4644 3
a4646 2
      if (exidx_section != NULL
	  && exidx_section->type() == elfcpp::SHT_ARM_EXIDX)
@


1.35
log
@2009-11-25  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::Target_arm): Move method definition outside of
	class definition.  Add code to handle --target1-rel, --target1-abs
	and --target2= options.
	(Target_arm::get_reloc_reloc_type): Change method to be non-static
	and const.
	(Target_arm::target1_is_rel_, Target_arm::target2_reloc_): New data
	member declaration.
	(Target_arm::Scan::local, Target_arm::Scan::global,
	Target_arm::Relocate::relocate,
	Target_arm::Relocatable_size_for_reloc::get_size_for_reloc): Adjust
	call to Target_arm::get_real_reloc_type.
	(Target_arm::get_real_reloc_type): Use command line options to
	determine real types of R_ARM_TARGET1 and R_ARM_TARGET2.
	* options.h (--target1-rel, --target1-abs, --target2): New ARM-only
	options.
@
text
@d1145 8
a1152 1
  Target_arm();
d1301 2
a1302 2
  unsigned int
  get_real_reloc_type (unsigned int r_type) const;
a1633 5
  // Whether R_ARM_TARGET1 maps to R_ARM_REL32 or R_ARM_ABS32.
  bool target1_is_rel_;
  // What R_ARM_TARGET2 maps to.  It should be one of R_ARM_REL32, R_ARM_ABS32
  // and R_ARM_GOT_PREL.
  unsigned int target2_reloc_;
a2312 45
template<bool big_endian>
Target_arm<big_endian>::Target_arm()
  : Sized_target<32, big_endian>(&arm_info),
    got_(NULL), plt_(NULL), got_plt_(NULL), rel_dyn_(NULL),
    copy_relocs_(elfcpp::R_ARM_COPY), dynbss_(NULL), stub_tables_(),
    stub_factory_(Stub_factory::get_instance()), target1_is_rel_(false),
    may_use_blx_(true), should_force_pic_veneer_(false),
    arm_input_section_map_()
{
  // FIXME: This is not strictly compatible with ld, which allows both
  // --target1-abs and --target-rel to be given.
  if (parameters->options().user_set_target1_abs()
      && parameters->options().user_set_target1_rel())
    {
      gold_error(_("Cannot use both --target1-abs and --target1-rel."));
    }
  else if (parameters->options().user_set_target1_rel())
    this->target1_is_rel_ = true;
  else if (parameters->options().user_set_target1_abs())
    this->target1_is_rel_ = false;

  if (parameters->options().user_set_target2())
    {
      if (strcmp(parameters->options().target2(), "rel") == 0)
	this->target2_reloc_ = elfcpp::R_ARM_REL32;
      else if (strcmp(parameters->options().target2(), "abs") == 0)
	this->target2_reloc_ = elfcpp::R_ARM_ABS32;
      else if (strcmp(parameters->options().target2(), "got-rel") == 0)
	this->target2_reloc_ = elfcpp::R_ARM_GOT_PREL;
      else
	gold_unreachable();
    }
  else
    {
      // Default values for R_ARM_TARGET2:
      //  
      // R_ARM_REL32 (arm*-*-elf, arm*-*-eabi)
      // R_ARM_ABS32 (arm*-*-symbianelf)
      // R_ARM_GOT_PREL (arm*-*-linux, arm*-*-*bsd)

      // This is the default value for EABI.
      this->target2_reloc_ = elfcpp::R_ARM_REL32;
    }
}

d4169 1
a4169 1
  r_type = target->get_real_reloc_type(r_type);
d4296 1
a4296 1
  r_type = target->get_real_reloc_type(r_type);
d4708 1
a4708 1
  r_type = target->get_real_reloc_type(r_type);
d5173 1
a5173 3
  const Target_arm<big_endian>* arm_target =
    Target_arm<big_endian>::default_target();
  r_type = arm_target->get_real_reloc_type(r_type);
d5318 1
a5318 1
Target_arm<big_endian>::get_real_reloc_type (unsigned int r_type) const
d5323 2
a5324 1
      return this->target1_is_rel_? elfcpp::R_ARM_REL32 : elfcpp::R_ARM_ABS32;
d5327 2
a5328 1
      return this->target2_reloc_;
@


1.34
log
@2009-11-25  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::Target_arm): Move method definition outside of
	class definition.  Add code to handle --target1-rel, --target1-abs
	and --target2= options.
	(Target_arm::get_reloc_reloc_type): Change method to be non-static
	and const.
	(Target_arm::target1_is_rel_, Target_arm::target2_reloc_): New data
	member declaration.
	(Target_arm::Scan::local, Target_arm::Scan::global,
	Target_arm::Relocate::relocate,
	Target_arm::Relocatable_size_for_reloc::get_size_for_reloc): Adjust
	call to Target_arm::get_real_reloc_type.
	(Target_arm::get_real_reloc_type): Use command line options to
	determine real types of R_ARM_TARGET1 and R_ARM_TARGET2.
	* options.h (--target1-rel, --target1-abs, --target2): New ARM-only
	options.
@
text
@d1145 1
a1145 8
  Target_arm()
    : Sized_target<32, big_endian>(&arm_info),
      got_(NULL), plt_(NULL), got_plt_(NULL), rel_dyn_(NULL),
      copy_relocs_(elfcpp::R_ARM_COPY), dynbss_(NULL), stub_tables_(),
      stub_factory_(Stub_factory::get_instance()),
      may_use_blx_(true), should_force_pic_veneer_(false),
      arm_input_section_map_()
  { }
d1294 2
a1295 2
  static unsigned int
  get_real_reloc_type (unsigned int r_type);
d1627 5
d2311 45
d4212 1
a4212 1
  r_type = get_real_reloc_type(r_type);
d4339 1
a4339 1
  r_type = get_real_reloc_type(r_type);
d4751 1
a4751 1
  r_type = get_real_reloc_type(r_type);
d5216 3
a5218 1
  r_type = get_real_reloc_type(r_type);
d5363 1
a5363 1
Target_arm<big_endian>::get_real_reloc_type (unsigned int r_type)
d5368 1
a5368 2
      // This is either R_ARM_ABS32 or R_ARM_REL32;
      return elfcpp::R_ARM_ABS32;
d5371 1
a5371 2
      // This can be any reloc type but ususally is R_ARM_GOT_PREL
      return elfcpp::R_ARM_GOT_PREL;
@


1.33
log
@2009-11-15  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::may_use_arm_nop): New method definition.
	(Arm_relocate_functions::arm_branch_common): Change method defintion
	in class definition to a method declaration and update list of formal
	parameters.
	(Arm_relocate_functions::plt32, Arm_relocate_functions::call,
	Arm_relocation_functions::jump24): Adjust call to
	Arm_relocate_functions::arm_branch_common.  Update list of formal
	parameters.
	(Arm_relocate_functions::xpc25): New method definition.
	(Arm_relocate_functions::arm_branch_common): Move method defintion
	out from class definition.  Use stubs for mode-switching and extending
	branch ranges.
	(Target_arm::Relocate::relocate): Handle weakly-undefined symbols
	specially.  Change code to enable use of stubs in ARM branches.
@
text
@d1198 8
d1761 7
d1811 2
a1812 2
       const Sized_relobj<32, big_endian>* object,
       const Symbol_value<32>* psymval)
d1830 2
a1831 2
       const Sized_relobj<32, big_endian>* object,
       const Symbol_value<32>* psymval)
d1879 23
a1901 17
  thm_call(unsigned char *view,
	   const Sized_relobj<32, big_endian>* object,
	   const Symbol_value<32>* psymval,
	   Arm_address address,
	   Arm_address thumb_bit)
  {
    // A thumb call consists of two instructions.
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype hi = elfcpp::Swap<16, big_endian>::readval(wv);
    Valtype lo = elfcpp::Swap<16, big_endian>::readval(wv + 1);
    // Must be a BL instruction. lo == 11111xxxxxxxxxxx.
    gold_assert((lo & 0xf800) == 0xf800);
    Reltype addend = utils::sign_extend<23>(((hi & 0x7ff) << 12)
					   | ((lo & 0x7ff) << 1));
    Reltype x = (psymval->value(object, addend) | thumb_bit) - address;
d1903 11
a1913 14
    // If target has no thumb bit set, we need to either turn the BL
    // into a BLX (for ARMv5 or above) or generate a stub.
    if ((x & 1) == 0)
      {
	// This only works for ARMv5 and above with interworking enabled.
	lo &= 0xefff;
      }
    hi = utils::bit_select(hi, (x >> 12), 0x7ffU);
    lo = utils::bit_select(lo, (x >> 1), 0x7ffU);
    elfcpp::Swap<16, big_endian>::writeval(wv, hi);
    elfcpp::Swap<16, big_endian>::writeval(wv + 1, lo);
    return (utils::has_overflow<23>(x)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
d2313 177
d2741 2
a2742 1
		  stub_type = (parameters->options().shared() | should_force_pic_veneer)
d2762 2
a2763 1
		  stub_type = (parameters->options().shared() | should_force_pic_veneer)
d4929 4
a4932 2
      reloc_status = Arm_relocate_functions::thm_call(view, object, psymval,
						      address, thumb_bit);
d4942 7
d5051 7
@


1.32
log
@2009-11-10  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::do_relocate_sections): Remove options parameter
	in method declaration.
	(Target_arm::relocate_stub): New method declaration.
	(Target_arm::default_target): Change to return a pointer instead of
	a const reference.
	(Reloc_stub::stub_type_for_reloc): Adjust for the change in
	Target_arm::default_target.
	(Arm_Relobj::do_relocate_sections): Remove options paramater in
	method definition.
	(Target_arm::relocate_section): Adjust view.
	(Target_arm::relocate_stub): New method definition.
@
text
@d1190 8
d1746 6
a1751 61
  // FIXME: This probably only works for Android on ARM v5te. We should
  // following GNU ld for the general case.
  template<unsigned r_type>
  static inline typename This::Status
  arm_branch_common(unsigned char *view,
		    const Sized_relobj<32, big_endian>* object,
		    const Symbol_value<32>* psymval,
		    Arm_address address,
		    Arm_address thumb_bit)
  {
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
     
    bool insn_is_b = (((val >> 28) & 0xf) <= 0xe)
		      && ((val & 0x0f000000UL) == 0x0a000000UL);
    bool insn_is_uncond_bl = (val & 0xff000000UL) == 0xeb000000UL;
    bool insn_is_cond_bl = (((val >> 28) & 0xf) < 0xe)
			    && ((val & 0x0f000000UL) == 0x0b000000UL);
    bool insn_is_blx = (val & 0xfe000000UL) == 0xfa000000UL;
    bool insn_is_any_branch = (val & 0x0e000000UL) == 0x0a000000UL;

    if (r_type == elfcpp::R_ARM_CALL)
      {
	if (!insn_is_uncond_bl && !insn_is_blx)
	  return This::STATUS_BAD_RELOC;
      }
    else if (r_type == elfcpp::R_ARM_JUMP24)
      {
	if (!insn_is_b && !insn_is_cond_bl)
	  return This::STATUS_BAD_RELOC;
      }
    else if (r_type == elfcpp::R_ARM_PLT32)
      {
	if (!insn_is_any_branch)
	  return This::STATUS_BAD_RELOC;
      }
    else
      gold_unreachable();

    Valtype addend = utils::sign_extend<26>(val << 2);
    Valtype x = (psymval->value(object, addend) | thumb_bit) - address;

    // If target has thumb bit set, we need to either turn the BL
    // into a BLX (for ARMv5 or above) or generate a stub.
    if (x & 1)
      {
	// Turn BL to BLX.
	if (insn_is_uncond_bl)
	  val = (val & 0xffffff) | 0xfa000000 | ((x & 2) << 23);
	else
	  return This::STATUS_BAD_RELOC;
      }
    else
      gold_assert(!insn_is_blx);

    val = utils::bit_select(val, (x >> 2), 0xffffffUL);
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
    return (utils::has_overflow<26>(x)
	    ? This::STATUS_OVERFLOW : This::STATUS_OKAY);
  }
d1938 22
a1959 2
  plt32(unsigned char *view,
	const Sized_relobj<32, big_endian>* object,
d1962 2
a1963 1
	Arm_address thumb_bit)
d1965 3
a1967 2
    return arm_branch_common<elfcpp::R_ARM_PLT32>(view, object, psymval,
						  address, thumb_bit);
d1972 5
a1976 2
  call(unsigned char *view,
       const Sized_relobj<32, big_endian>* object,
d1979 2
a1980 1
       Arm_address thumb_bit)
d1982 3
a1984 2
    return arm_branch_common<elfcpp::R_ARM_CALL>(view, object, psymval,
						 address, thumb_bit);
d1989 5
a1993 2
  jump24(unsigned char *view,
	 const Sized_relobj<32, big_endian>* object,
d1996 2
a1997 1
	 Arm_address thumb_bit)
d1999 3
a2001 2
    return arm_branch_common<elfcpp::R_ARM_JUMP24>(view, object, psymval,
						   address, thumb_bit);
d2172 123
d4520 1
d4534 7
d4613 4
d4736 7
d4825 4
a4828 2
      reloc_status = Arm_relocate_functions::plt32(view, object, psymval,
						   address, thumb_bit);
d4832 4
a4835 2
      reloc_status = Arm_relocate_functions::call(view, object, psymval,
						  address, thumb_bit);
d4839 4
a4842 2
      reloc_status = Arm_relocate_functions::jump24(view, object, psymval,
						    address, thumb_bit);
@


1.31
log
@2009-11-09  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::fake_relnum_for_stubs): New constant.
	(arm_symbol_value): Remove.
	(Arm_relocate_functions::arm_branch_common,
	Arm_relocate_functions::abs8, Arm_relocate_functions::thm_abs5,
	Arm_relocate_functions::abs12, Arm_relocate_functions::abs16,
	Arm_relocate_functions::abs32, Arm_relocate_functions::rel32,
	Arm_relocate_functions::thm_call, Arm_relocate_functions::plt32,
	Arm_relocate_functions::call, Arm_relocate_functions::jump24,
	Arm_relocate_functions::prel31, Arm_relocate_functions::mov_abs_nc,
	Arm_relocate_functions::movt_abs, Arm_relocate_functions::movw_abs_nc,
	Arm_relocate_functions::thm_mobw_abs_nc,
	Arm_relocate_functions::thm_mov_abs,
	Arm_relocate_functions::movw_prel_nc,
	Arm_relocate_functions::thm_movt_abs,
	Arm_relocate_functions::movt_prel,
	Arm_relocate_functions::thm_movw_prel_nc,
	Arm_relocate_functions::thm_movt_prel): Adjust callers of the above.
	(Target_arm::Relocate::relocate): Only decompose address into two
	parts if relocation type uses the thumb-bit and pass the actual
	bit instead of a flag indicating that the thumb-bit is used.  Adjust
	calls to methods in Arm_relocate_functions for this change.
@
text
@d975 1
a975 2
  do_relocate_sections(const General_options& options,
		       const Symbol_table* symtab, const Layout* layout,
d1317 6
d1324 1
a1324 1
  static const Target_arm<big_endian>&
d1329 2
a1330 1
    return static_cast<const Target_arm<big_endian>&>(parameters->target());
d2397 1
a2397 1
      const Target_arm<true>& big_endian_target =
d2399 4
a2402 4
      may_use_blx = big_endian_target.may_use_blx();
      should_force_pic_veneer = big_endian_target.should_force_pic_veneer();
      thumb2 = big_endian_target.using_thumb2();
      thumb_only = big_endian_target.using_thumb_only();
d2406 1
a2406 1
      const Target_arm<false>& little_endian_target =
d2408 4
a2411 4
      may_use_blx = little_endian_target.may_use_blx();
      should_force_pic_veneer = little_endian_target.should_force_pic_veneer();
      thumb2 = little_endian_target.using_thumb2();
      thumb_only = little_endian_target.using_thumb_only();
a3388 1
    const General_options& options,
d3395 2
a3396 2
  Sized_relobj<32, big_endian>::do_relocate_sections(options, symtab, layout,
						     pshdrs, pviews); 
a3408 1
  relinfo.options = &options;
d4782 22
d5643 45
@


1.30
log
@2009-11-06  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (class Reloc_stub): Correct a comment.
	(Target_arm::Target_arm): Initialize arm_input_section_map_.
	(Target_arm::scan_section_for_stubs): New method declaration.
	(Target_arm::do_make_elf_object, Target_arm::do_make_output_section):
	Change methods from private to protected.
	(Target_arm::do_may_relax): New method definition.
	(Target_arm::do_relax, Target_arm::group_sections,
	Target_arm::scan_reloc_for_stub,
	Target_arm::scan_reloc_section_for_stubs): New method declarations.
	(Target_arm::arm_input_section_map_): New data member declaration.
	(Target_arm::scan_reloc_for_stub,
	Target_arm::scan_reloc_section_for_stubs,
	Target_arm::scan_section_for_stubs, Target_arm::group_sections,
	Target_arm::do_relax): New method definitions.
@
text
@d1143 3
a1658 21
  // Get an symbol value of *PSYMVAL with an ADDEND.  This is a wrapper
  // to Symbol_value::value().  If HAS_THUMB_BIT is true, that LSB is used
  // to distinguish ARM and THUMB functions and it is treated specially.
  static inline Symbol_value<32>::Value
  arm_symbol_value (const Sized_relobj<32, big_endian> *object,
		    const Symbol_value<32>* psymval,
		    Symbol_value<32>::Value addend,
		    bool has_thumb_bit)
  {
    typedef Symbol_value<32>::Value Valtype;

    if (has_thumb_bit)
      {
	Valtype raw = psymval->value(object, 0);
	Valtype thumb_bit = raw & 1;
	return ((raw & ~((Valtype) 1)) + addend) | thumb_bit;
      }
    else
      return psymval->value(object, addend);
  }

d1740 1
a1740 1
		    bool has_thumb_bit)
d1773 1
a1773 2
    Valtype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit)
		 - address);
d1807 1
a1807 1
    Reltype x = This::arm_symbol_value(object, psymval, addend, false);
d1826 1
a1826 1
    Reltype x = This::arm_symbol_value(object, psymval, addend, false);
d1845 1
a1845 1
    Reltype x = This::arm_symbol_value(object, psymval, addend, false);
d1864 1
a1864 1
    Reltype x = This::arm_symbol_value(object, psymval, addend, false);
d1877 1
a1877 1
	bool has_thumb_bit)
d1882 1
a1882 1
    Valtype x = This::arm_symbol_value(object, psymval, addend, has_thumb_bit);
d1893 1
a1893 1
	bool has_thumb_bit)
d1898 1
a1898 2
    Valtype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit) 
		 - address);
d1909 1
a1909 1
	   bool has_thumb_bit)
d1921 1
a1921 2
    Reltype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit)
		 - address);
d1983 1
a1983 1
	bool has_thumb_bit)
d1986 1
a1986 1
						  address, has_thumb_bit);
d1995 1
a1995 1
       bool has_thumb_bit)
d1998 1
a1998 1
						 address, has_thumb_bit);
d2007 1
a2007 1
	 bool has_thumb_bit)
d2010 1
a2010 1
						   address, has_thumb_bit);
d2019 1
a2019 1
	 bool has_thumb_bit)
d2025 1
a2025 2
    Valtype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit)
		 - address);
d2037 1
a2037 1
	      bool has_thumb_bit)
d2043 1
a2043 1
    Valtype x = This::arm_symbol_value(object, psymval, addend, has_thumb_bit);
d2059 1
a2059 1
    Valtype x = This::arm_symbol_value(object, psymval, addend, 0) >> 16;
d2070 1
a2070 1
	          bool has_thumb_bit)
d2078 1
a2078 1
    Reltype x = This::arm_symbol_value(object, psymval, addend, has_thumb_bit);
d2097 1
a2097 1
    Reltype x = This::arm_symbol_value(object, psymval, addend, 0) >> 16;
d2110 1
a2110 1
	       bool has_thumb_bit)
d2116 1
a2116 2
    Valtype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit)
                 - address);
d2133 1
a2133 2
    Valtype x = (This::arm_symbol_value(object, psymval, addend, 0)
                 - address) >> 16;
d2145 1
a2145 1
	           bool has_thumb_bit)
d2153 1
a2153 2
    Reltype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit)
                 - address);
d2173 1
a2173 2
    Reltype x = (This::arm_symbol_value(object, psymval, addend, 0)
                 - address) >> 16;
d4401 2
a4402 4
  // If this the symbol may be a Thumb function, set thumb bit to 1.
  bool has_thumb_bit = ((gsym != NULL)
			&& (gsym->type() == elfcpp::STT_FUNC
			    || gsym->type() == elfcpp::STT_ARM_TFUNC));
d4404 3
a4406 1
  // Pick the value to use for symbols defined in shared objects.
d4408 37
a4444 2
  if (gsym != NULL
      && gsym->use_plt_offset(reloc_is_non_pic(r_type)))
d4446 14
a4459 2
      symval.set_output_value(target->plt_section()->address()
			      + gsym->plt_offset());
d4461 1
a4461 2
      has_thumb_bit = 0;
    }
a4462 2
  const Sized_relobj<32, big_endian>* object = relinfo->object;
  
d4522 1
a4522 1
						     has_thumb_bit);
d4538 1
a4538 1
       						           has_thumb_bit);
d4558 1
a4558 1
       						               has_thumb_bit);
d4577 1
a4577 1
							  has_thumb_bit);
d4588 1
a4588 1
							      has_thumb_bit);
d4598 1
a4598 1
						   address, has_thumb_bit);
d4609 1
a4609 1
						      address, has_thumb_bit);
d4617 1
a4617 1
						     got_origin, has_thumb_bit);
d4695 1
a4695 1
						   address, has_thumb_bit);
d4700 1
a4700 1
						  address, has_thumb_bit);
d4705 1
a4705 1
						    address, has_thumb_bit);
d4710 1
a4710 1
						    address, has_thumb_bit);
@


1.29
log
@	PR 10887
	* arm.cc (Target_arm::do_finalize_sections): Don't add dynamic
	tags if data is discarded by linker script.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d575 1
a575 1
    // independent Symbol and Relobj classes instead of Arm_symbol and  
d1148 2
a1149 1
      may_use_blx_(true), should_force_pic_veneer_(false)
d1308 7
d1329 26
d1358 9
d1546 3
a1548 3
  Object*
  do_make_elf_object(const std::string&, Input_file*, off_t,
		     const elfcpp::Ehdr<32, big_endian>& ehdr);
d1550 3
a1552 4
  Object*
  do_make_elf_object(const std::string&, Input_file*, off_t,
		     const elfcpp::Ehdr<32, !big_endian>&)
  { gold_unreachable(); }
d1554 6
a1559 4
  Object*
  do_make_elf_object(const std::string&, Input_file*, off_t,
		      const elfcpp::Ehdr<64, false>&)
  { gold_unreachable(); }
d1561 12
a1572 4
  Object*
  do_make_elf_object(const std::string&, Input_file*, off_t,
		     const elfcpp::Ehdr<64, true>&)
  { gold_unreachable(); }
d1613 2
d5176 423
@


1.28
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d4255 2
a4256 1
      if (this->got_plt_ != NULL)
d4259 2
a4260 1
      if (this->plt_ != NULL)
d4268 2
a4269 1
      if (this->rel_dyn_ != NULL)
@


1.27
log
@2009-11-03  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::Target_arm): Initialize stub_tables_ and
	stub_factory_.
	(Target_arm::stub_factory): New method definition.
	(Target_arm::new_arm_input_section,
	Target_arm::find_arm_input_section, Target_arm::new_stub_table,
	Target_arm::reloc_uses_thumb_bit): New method declarations.
	(Target_arm::Stub_table_list, Target_arm::Arm_input_section_map):
	New type definitions.
	(Target_arm::stub_tables_, Target_arm::stub_factory_): New data
	member declarations.
	(Target_arm::reloc_uses_thumb_bit, Target_arm::new_arm_input_section,
	Target_arm::find_arm_input_section, Target_arm::new_stub_table):
	New method definitions.
@
text
@d2169 1
a2169 1
					   this->got_);
d2180 1
a2180 1
					   this->got_plt_);
d2208 1
a2208 1
				      elfcpp::SHF_ALLOC, this->rel_dyn_);
d3591 1
a3591 1
				  elfcpp::SHF_ALLOC, this->rel_);
d3753 1
a3753 1
				      this->plt_);
d4303 2
a4304 1
	  exidx_segment->add_output_section(exidx_section, elfcpp::PF_R);
@


1.26
log
@2009-10-30  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Stub_addend_reader): Fix bug in previouls check-in.
@
text
@d1146 2
a1147 1
      copy_relocs_(elfcpp::R_ARM_COPY), dynbss_(NULL),
d1285 22
d1316 4
d1532 9
d1553 4
d5011 107
@


1.25
log
@2009-10-30  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Stub_addend_reader): New struct template definition
	and partial specializations.
	(Stub_addend_reader::operator()): New method definition for a
	partially specialized template.
@
text
@d1045 1
a1045 2
			       32, big_endian>::Reloc& /* reloc */) const
  { gold_unreachable(); }
d1073 2
a1074 1
			       big_endian>::Reloc& reloc) const;
@


1.24
log
@2009-10-30  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:
	* arm.h (EF_ARM_BE8, EF_ARM_EABIMASK, EF_ARM_EABI_UNKNOWN,
	EF_ARM_EABI_VER1, EF_ARM_EABI_VER2, EF_ARM_EABI_VER3,
	EF_ARM_EABI_VER4, EF_ARM_EABI_VER5): New enums for processor-specific
	flags.
	(arm_eabi_version): New inline function.
	* elfcpp.h: Add a comment about DT_ENCODING.

gold/ChangeLog:
	* arm.cc (Arm_relobj::processor_specific_flags): New method
	definition.
	(Arm_relobj::do_read_symbols): New method declaration.
	(Arm_relobj::processor_specific_flags_): New data member declaration.
	(Arm_dynobj): New class definition.
	(Target_arm::do_finalize_sections): Add input_objects parameter.
	(Target_arm::do_adjust_elf_header): New method declaration.
	(Target_arm::are_eabi_versions_compatible,
	(Target_arm::merge_processor_specific_flags): New method declaration.
	(Target_arm::do_make_elf_object): New overloaded method definitions
	and declaration.
	(Arm_relobj::do_read_symbols): New method definition.
	(Arm_dynobj::do_read_symbols): Ditto.
	(Target_arm::do_finalize_sections): Add input_objects parameters.
	Merge processor-specific flags from all input objects.
	(Target_arm::are_eabi_versions_compatible,
	Target_arm::merge_processor_specific_flags,
	Target_arm::do_adjust_elf_header, Target_arm::do_make_elf_object):
	New method definitions.
	* i386.cc (Target_i386::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* layout.cc (Layout::finalize): Pass input objects to target's.
	finalize_sections function.
	* output.cc (Output_file_header::do_sized_write): Set ELF file
	header's processor-specific flags.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* sparc.cc (Target_sparc::do_finalize_sections): Same.
	* target.h (Input_objects): New forward class declaration.
	(Target::processor_specific_flags,
	Target::are_processor_specific_flags_sect): New method definitions.
	(Target::finalize_sections): Add input_objects parameter.
	(Target::Target): Initialize processor_specific_flags_ and
	are_processor_specific_flags_set_.
	(Target::do_finalize_sections): Add unnamed Input_objects pointer type
	parameter.
	(Target::set_processor_specific_flags): New method definition.
	(Target::processor_specific_flags_,
	Target::are_processor_specific_flags_set_): New data member
	declarations.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
@
text
@d1032 45
d3037 1
a3037 1
      switch(state)
d3415 69
@


1.23
log
@2009-10-30  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Use Arm_address instead of elfcpp::Elf_types<32>::Elf_Addr.
@
text
@d950 6
d980 4
d991 39
d1172 1
a1172 1
  do_finalize_sections(Layout*);
d1248 4
d1422 28
d3334 36
d4070 3
a4072 1
Target_arm<big_endian>::do_finalize_sections(Layout* layout)
d4074 23
d4733 124
@


1.22
log
@	* object.h (class Relobj): Drop options parameter from
	gc_process_relocs, scan_relocs, relocate, do_gc_process_relocs,
	do_scan_relocs, do_relocate.  Change all callers.
	(class Sized_relobj): Drop options parameters from
	do_gc_process_relocs, do_scan_relocs, do_relocate,
	do_relocate_sections, relocate_sections, emit_relocs_scan,
	emit_relocs_scan_reltype.  Change all callers.
	(struct Relocate_info): Remove options field and all references to
	it.
	* reloc.h (class Read_relocs): Remove options constructor
	parameter and options_ field.  Change all callers.
	(class Gc_process_relocs, class Scan_relocs): Likewise.
	(class Relocate_task): Likewise.
	* target-reloc.h (scan_relocs): Remove options parameter.  Change
	all callers.
	(scan_relocatable_relocs): Likewise.
	* target.h (class Sized_target): Remove options parameter from
	gc_process_relocs, scan_relocs, scan_relocatable_relocs.  Change
	all callers.
	* gc.h (gc_process_relocs): Remove options parameter.  Change all
	callers.
	* arm.cc: Update functions to remove options parameters.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* testsuite/testfile.cc: Likewise.
@
text
@d1139 1
a1139 1
		   elfcpp::Elf_types<32>::Elf_Addr view_address,
d1168 1
a1168 1
			   elfcpp::Elf_types<32>::Elf_Addr view_address,
d1282 1
a1282 1
	     unsigned char*, elfcpp::Elf_types<32>::Elf_Addr,
d1537 1
a1537 1
		    elfcpp::Elf_types<32>::Elf_Addr address,
d1691 1
a1691 1
	elfcpp::Elf_types<32>::Elf_Addr address,
d1708 1
a1708 1
	   elfcpp::Elf_types<32>::Elf_Addr address,
d1743 2
a1744 2
	    elfcpp::Elf_types<32>::Elf_Addr origin,
	    elfcpp::Elf_types<32>::Elf_Addr address)
d1753 1
a1753 1
	    elfcpp::Elf_types<32>::Elf_Addr origin)
d1772 1
a1772 1
	   elfcpp::Elf_types<32>::Elf_Addr address)
d1783 1
a1783 1
	elfcpp::Elf_types<32>::Elf_Addr address,
d1795 1
a1795 1
       elfcpp::Elf_types<32>::Elf_Addr address,
d1807 1
a1807 1
	 elfcpp::Elf_types<32>::Elf_Addr address,
d1819 1
a1819 1
	 elfcpp::Elf_types<32>::Elf_Addr address,
d1911 1
a1911 1
	       elfcpp::Elf_types<32>::Elf_Addr address,
d1930 1
a1930 1
            elfcpp::Elf_types<32>::Elf_Addr address)
d1948 1
a1948 1
	           elfcpp::Elf_types<32>::Elf_Addr address,
d1970 1
a1970 1
	        elfcpp::Elf_types<32>::Elf_Addr address)
d3408 2
a3409 2
  elfcpp::Elf_types<32>::Elf_Addr plt_address = this->address();
  elfcpp::Elf_types<32>::Elf_Addr got_address = this->got_plt_->address();
d4066 1
a4066 1
    elfcpp::Elf_types<32>::Elf_Addr address,
d4242 1
a4242 1
	elfcpp::Elf_types<32>::Elf_Addr got_origin;
d4308 1
a4308 1
      elfcpp::Elf_types<32>::Elf_Addr got_origin;
d4399 1
a4399 1
    elfcpp::Elf_types<32>::Elf_Addr address,
d4536 1
a4536 1
    elfcpp::Elf_types<32>::Elf_Addr view_address,
@


1.21
log
@2009-10-28  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj): New class definition.
	(Arm_relobj::scan_sections_for_stubs,
	Arm_relobj::do_count_local_symbols, Arm_relobj::do_relocate_sections):
	New method definitions.
@
text
@d1095 1
a1095 2
  gc_process_relocs(const General_options& options,
		    Symbol_table* symtab,
d1109 1
a1109 2
  scan_relocs(const General_options& options,
	      Symbol_table* symtab,
d1145 1
a1145 2
  scan_relocatable_relocs(const General_options& options,
			  Symbol_table* symtab,
d1209 1
a1209 2
    local(const General_options& options, Symbol_table* symtab,
	  Layout* layout, Target_arm* target,
d1217 1
a1217 2
    global(const General_options& options, Symbol_table* symtab,
	   Layout* layout, Target_arm* target,
a3027 1
  relinfo.options = &parameters->options();
d3551 1
a3551 2
Target_arm<big_endian>::Scan::local(const General_options&,
				    Symbol_table* symtab,
d3678 1
a3678 2
Target_arm<big_endian>::Scan::global(const General_options&,
				     Symbol_table* symtab,
d3882 1
a3882 2
Target_arm<big_endian>::gc_process_relocs(const General_options& options,
					  Symbol_table* symtab,
a3897 1
    options,
d3915 1
a3915 2
Target_arm<big_endian>::scan_relocs(const General_options& options,
				    Symbol_table* symtab,
a3935 1
    options,
a4489 1
    const General_options& options,
a4509 1
    options,
@


1.20
log
@2009-10-24  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_output_section, Arm_relobj): Forward class declarations.
	(Arm_input_section::as_arm_input_section): New method.
	(Arm_output_section): New class definition.
	(Arm_output_section::create_stub_group,
	Arm_output_section::group_sections): New method definitions.
@
text
@d887 96
d3007 252
@


1.19
log
@2009-10-22  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section): New class definition.
	(Arm_input_section::init, Arm_input_section:do_write,
	Arm_input_section::set_final_data_size,
	Arm_input_section::do_reset_address_and_file_offset): New method
	definitions.
@
text
@d65 6
d787 6
d849 38
d2702 209
@


1.18
log
@2009-10-21  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Stub_table, Arm_input_section): New forward class
	declarations.
	(Stub_table): New class defintion.
	(Stub_table::add_reloc_stub, Stub_table::relocate_stubs
	Stub_table::do_reset_address_and_file_offset, Stub_table::do_write):
	New method definition.
@
text
@d748 89
d2562 90
@


1.17
log
@2009-10-21  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Update copyright comments.
	(Target_arm): New forward class template declaration.
	(Arm_address): New type.
	(ARM_MAX_FWD_BRANCH_OFFSET, ARM_MAX_BWD_BRANCH_OFFSET,
	THM_MAX_FWD_BRANCH_OFFSET, THM_MAX_BWD_BRANCH_OFFSET,
	THM2_MAX_FWD_BRANCH_OFFSET, THM2_MAX_BWD_BRANCH_OFFSET): New
	constants.
	(Insn_template): Same.
	(DEF_STUBS): New macro.
	(Stub_type): New enum type.
	(Stub_template): New class definition.
	(Stub): Same.
	(Reloc_stub): Same.
	(Stub_factory): Same.
	(Target_arm::Target_arm): Initialize may_use_blx_ and
	should_force_pic_veneer_.
	(Target_arm::may_use_blx, Target_arm::set_may_use_blx,
	Target_arm::should_force_pic_veneer,
	Target_arm::set_should_force_pic_veneer, Target_arm::using_thumb2,
	Target_arm::using_thumb_only, Target_arm:;default_target): New
	method defintions.
	(Target_arm::may_use_blx_, Target_arm::should_force_pic_veneer_):
	New data member declarations.
	(Insn_template::size, Insn_template::alignment): New method defintions.
	(Stub_template::Stub_template): New method definition.
	(Reloc_stub::Key::name, Reloc_stub::stub_type_for_reloc,
	Reloc_stub::do_fixed_endian_write, Reloc_stub::do_write): Same.
	(Stub_factory::Stub_factory): New method definition.
	* gold.h (string_hash): New template.
	* output.h (Input_section_specifier::hash_value): Use
	gold::string_hash.
	(Input_section_specifier::string_hash): Remove.
	* stringpool.cc (Stringpool_template::string_hash): Use
	gold::string_hash.
@
text
@d32 1
d59 6
d653 95
d2366 107
@


1.16
log
@	* symtab.h: Check for GOLD_SYMTAB_H before header includes. Remove
	includes to gc.h and icf.h.
	* arm.cc: Include gc.h.
	* gold.cc: Likewise.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* gc.h: Include icf.h.
@
text
@d6 2
d57 14
d119 527
d715 2
a716 1
      copy_relocs_(elfcpp::R_ARM_COPY), dynbss_(NULL)
d719 36
d856 9
d1059 4
d1715 549
@


1.15
log
@	* arm.cc (Target_arm::relocate::reloc_is_non_pic): Return true for
	R_ARM_THM_ABS5, R_ARM_ABS8, R_ARM_ABS12, R_ARM_ABS16,
	R_ARM_BASE_ABS.
	(Arm_relocate_functions::abs8): Remove has_thumb_bit parameter.
	(Arm_relocate_functions::thm_abs5): New function.
	(Arm_relocate_functions::abs12): New function.
	(Arm_relocate_functions::abs16): New function.
	(Arm_relocate_functions::base_abs): New function.
	(Scan::check_non_pic): Handle R_ARM_ABS32_NOI.
	(Scan::local): Remove special handling of R_ARM_ABS8.  Handle
	R_ARM_ABS32_NOI, R_ARM_THM_ABS5, R_ARM_ABS12, R_ARM_ABS16, and
	R_ARM_BASE_ABS.
	(Scan::global): Likewise.
	(Relocate::relocate): Handle R_ARM_ABS12, R_ARM_ABS16,
	R_ARM_ABS32_NOI, R_ARM_THM_ABS5, and R_ARM_BASE_ABS.
	(Relocatable_size_for_reloc::get_size_for_reloc): Handle
	R_ARM_ABS16, R_ARM_THM_ABS5, R_ARM_ABS32_NOI, R_ARM_ABS12, and
	R_ARM_BASE_ABS.
@
text
@d45 1
@


1.14
log
@	* arm.cc (Arm_relocate_functions::movw_prel_nc): New function.
	(Arm_relocate_functions::movt_prel): New function.
	(Arm_relocate_functions::thm_movw_prel_nc): New function.
	(Arm_relocate_functions::thm_movt_prel): New function.
	(Scan::local): Handle R_ARM_MOVW_PREL_NC, R_ARM_MOVT_PREL,
	R_ARM_THM_MOVW_PREL_NC, and R_ARM_THM_MOVT_PREL.
	(Scan::global, Relocate::relocate): Likewise.
	(Relocatable_size_for_reloc::get_size_for_reloc): Likewise.
@
text
@d62 6
d375 5
d673 1
a673 1
       const Symbol_value<32>* psymval, bool has_thumb_bit)
d680 1
a680 1
    Reltype x = This::arm_symbol_value(object, psymval, addend, has_thumb_bit);
d688 57
d824 9
d1388 1
a1435 9
    case elfcpp::R_ARM_ABS8:
      if (parameters->options().output_is_position_independent())
	{
	  // FIXME: Create a dynamic relocation for this location.
	  gold_error(_("%s: gold bug: need dynamic ABS8 reloc"),
		     object->name().c_str());
	}
      break;

d1437 1
d1462 5
a1563 10
    case elfcpp::R_ARM_ABS8:
      // Make a dynamic relocation if necessary.
      if (gsym->needs_dynamic_reloc(Symbol::ABSOLUTE_REF))
	{
	  // FIXME: Create a dynamic relocation for this location.
	  gold_error(_("%s: gold bug: need dynamic ABS8 reloc for %s"),
		     object->name().c_str(), gsym->demangled_name().c_str());
	}
      break;

d1565 1
d1606 17
d2005 13
a2017 2
	reloc_status = Arm_relocate_functions::abs8(view, object, psymval,
						    has_thumb_bit);
d2027 8
d2103 6
d2143 29
d2312 4
d2317 3
@


1.13
log
@	* arm.cc (Arm_relocate_functions::extract_arm_movw_movt_addend):
	New function.
	(Arm_relocate_functions::insert_val_arm_movw_movt): New function.
	(Arm_relocate_functions::extract_thumb_movw_movt_addend): New
	function.
	(Arm_relocate_functions::insert_val_thumb_movw_movt): New
	function.
	(Arm_relocate_functions::movw_abs_nc): New function.
	(Arm_relocate_functions::movt_abs): New function.
	(Arm_relocate_functions::thm_movw_abs_nc): New function.
	(Arm_relocate_functions::thm_movt_abs): New function.
	(Scan::local): Handle R_ARM_MOVW_ABS_NC, R_ARM_MOVT_ABS,
	R_ARM_THM_MOVW_ABS_NC, R_ARM_THM_MOVT_ABS.
	(Scan::global): Likewise.
	(Relocate::relocate): Likewise.
	(Relocatable_size_for_reloc::get_size_for_reloc): Likewise.
@
text
@d81 5
a85 1
// R_ARM_THM_MOVT_ABS 
d903 79
d1396 4
d1534 4
d1974 22
d2190 4
@


1.12
log
@	* arm.cc (Arm_relocate_functions::got_prel) New function.
	(Scan::local, Scan::global): Handle R_ARM_GOT_PREL.
	(Relocate::relocate): Likewise.
	(Relocatable_size_for_reloc::get_size_for_reloc): Likewise.
@
text
@d78 4
d516 73
d826 73
d1309 4
d1443 6
d1842 41
d2073 4
@


1.11
log
@	* options.h (class General_options): Define
	split_stack_adjust_size parameter.
	* object.h (class Object): Add uses_split_stack_ and
	has_no_split_stack_ fields.  Add uses_split_stack and
	has_no_split_stack accessor functions.  Declare
	handle_split_stack_section.
	(class Reloc_symbol_changes): Define.
	(class Sized_relobj): Define Function_offsets.  Declare
	split_stack_adjust, split_stack_adjust_reltype, and
	find_functions.
	* object.cc (Object::handle_split_stack_section): New function.
	(Sized_relobj::do_layout): Call handle_split_stack_section.
	* dynobj.cc (Sized_dynobj::do_layout): Call
	handle_split_stack_section.
	* reloc.cc (Sized_relobj::relocate_sections): Call
	split_stack_adjust for executable sections in split_stack
	objects.  Pass reloc_map to relocate_section.
	(Sized_relobj::split_stack_adjust): New function.
	(Sized_relobj::split_stack_adjust_reltype): New function.
	(Sized_relobj::find_functions): New function.
	* target-reloc.h: Include "object.h".
	(relocate_section): Add reloc_symbol_changes parameter.  Change
	all callers.
	* target.h (class Target): Add calls_non_split method.  Declare
	do_calls_non_split virtual method.  Declare match_view and
	set_view_to_nop.
	* target.cc: Include "elfcpp.h".
	(Target::do_calls_non_split): New function.
	(Target::match_view): New function.
	(Target::set_view_to_nop): New function.
	* gold.cc (queue_middle_tasks): Give an error if mixing
	split-stack and non-split-stack objects with -r.
	* i386.cc (Target_i386::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_i386::do_calls_non_split): New function.
	* x86_64.cc (Target_x86_64::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_x86_64::do_calls_non_split): New function.
	* arm.cc (Target_arm::relocate_section): Add reloc_symbol_changes
	parameter.
	* powerpc.cc (Target_powerpc::relocate_section): Add
	reloc_symbol_changes parameter.
	* sparc.cc (Target_sparc::relocate_section): Add
	reloc_symbol_changes parameter.
	* configure.ac: Call AM_CONDITIONAL for the default target.
	* configure: Rebuild.
	* testsuite/Makefile.am (TEST_AS): New variable.
	(check_SCRIPTS): Add split_i386.sh and split_x86_64.sh.
	(check_DATA): Add split_i386 and split_x86_64 files.
	(SPLIT_DEFSYMS): Define.
	(split_i386_[1234n].o): New targets.
	(split_i386_[124]): New targets.
	(split_i386_[1234r].stdout): New targets.
	(split_x86_64_[1234n].o): New targets.
	(split_x86_64_[124]): New targets.
	(split_x86_64_[1234r].stdout): New targets.
	(MOSTLYCLEANFILES): Add new executables.
	* testsuite/split_i386.sh: New file.
	* testsuite/split_x86_64.sh: New file.
	* testsuite/split_i386_1.s: New file.
	* testsuite/split_i386_2.s: New file.
	* testsuite/split_i386_3.s: New file.
	* testsuite/split_i386_4.s: New file.
	* testsuite/split_i386_n.s: New file.
	* testsuite/split_x86_64_1.s: New file.
	* testsuite/split_x86_64_2.s: New file.
	* testsuite/split_x86_64_3.s: New file.
	* testsuite/split_x86_64_4.s: New file.
	* testsuite/split_x86_64_n.s: New file.
	* testsuite/testfile.cc (Target_test): Update relocation_section
	function.
	* testsuite/Makefile.in: Rebuild.
@
text
@d71 1
d77 1
d684 10
d1171 1
d1367 1
d1640 1
d1726 12
d1867 1
@


1.10
log
@2009-09-30  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::may_need_copy_reloc): Check for THUMB function
	symbol and call Symbol::may_need_copy_reloc to determine if
	a copy reloc is needed.
	* copy-relocs.cc (Copy_relocs::need_copy_reloc): Return false if -z
	nocopyreloc is given in command line.
	(Copy_relocs::emit_copy_reloc): Assert that -z nocopyreloc is not
	given in command line.
	* i386.cc (Target_i386::may_need_copy_reloc): Remove.
	(Target_i386::Scan::global): Use Symbol::may_need_copy_reloc instead
	of the removed Target_i386::may_need_copy_reloc.
	* options.h (copyreloc): New option with default value false.
	* powerpc.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_powerpc::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_powerpc::may_need_copy_reloc.
	* sparc.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_sparc::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_sparc::may_need_copy_reloc.
	* symtab.h (Symbol::may_need_copy_reloc): New method definition.
	* x86_64.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_x86_64::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_x86_64::may_need_copy_reloc.
@
text
@d208 2
a209 1
		   section_size_type view_size);
d1796 2
a1797 1
    section_size_type view_size)
d1812 2
a1813 1
    view_size);
@


1.9
log
@	* arm.cc (has_signed_unsigned_overflow): New function.
	(Arm_relocate_functions::abs8): New function.
	(Target_arm::Scan::local): Handle R_ARM_ABS8.
	(Target_arm::Scan::global): Likewise.
	(Target_arm::relocate::relocate): Likewise.
	(Target_arm::Relocatable_size_for_reloc::get_size_for_reloc):
	Likewise.
@
text
@d408 2
a409 4
    return (!parameters->options().shared()
	    && gsym->is_from_dynobj()
	    && gsym->type() != elfcpp::STT_FUNC
	    && gsym->type() != elfcpp::STT_ARM_TFUNC);
@


1.8
log
@2009-08-11  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Update comments.
	(Target_arm::do_finalize_sections): Add a special PT_ARM_EXIDX
	segment to locate the .ARM.exidx section if present.
@
text
@d120 17
d575 20
d1114 9
d1236 10
d1654 7
d1830 3
@


1.8.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a44 1
#include "gc.h"
a61 6
// R_ARM_ABS32_NOI
// R_ARM_ABS16
// R_ARM_ABS12
// R_ARM_ABS8
// R_ARM_THM_ABS5
// R_ARM_BASE_ABS
a70 1
// R_ARM_GOT_PREL
a75 9
// R_ARM_ABS8
// R_ARM_MOVW_ABS_NC
// R_ARM_MOVT_ABS
// R_ARM_THM_MOVW_ABS_NC
// R_ARM_THM_MOVT_ABS
// R_ARM_MOVW_PREL_NC
// R_ARM_MOVT_PREL
// R_ARM_THM_MOVW_PREL_NC
// R_ARM_THM_MOVT_PREL
a119 17
  // Detects overflow of an NO_BITS integer stored in a uint32_t when it
  // fits in the given number of bits as either a signed or unsigned value.
  // For example, has_signed_unsigned_overflow<8> would check
  // -128 <= bits <= 255
  template<int no_bits>
  static inline bool
  has_signed_unsigned_overflow(uint32_t bits)
  {
    gold_assert(no_bits >= 2 && no_bits <= 32);
    if (no_bits == 32)
      return false;
    int32_t max = static_cast<int32_t>((1U << no_bits) - 1);
    int32_t min = -(1 << (no_bits - 1));
    int32_t as_signed = static_cast<int32_t>(bits);
    return as_signed > max || as_signed < min;
  }

d191 1
a191 2
		   section_size_type view_size,
		   const Reloc_symbol_changes*);
a340 5
	case elfcpp::R_ARM_THM_ABS5:
	case elfcpp::R_ARM_ABS8:
	case elfcpp::R_ARM_ABS12:
	case elfcpp::R_ARM_ABS16:
	case elfcpp::R_ARM_BASE_ABS:
d391 4
a394 2
    return (gsym->type() != elfcpp::STT_ARM_TFUNC
	    && gsym->may_need_copy_reloc());
a493 73
  // Encoding of imm16 argument for movt and movw ARM instructions
  // from ARM ARM:
  //     
  //     imm16 := imm4 | imm12
  //
  //  f e d c b a 9 8 7 6 5 4 3 2 1 0 f e d c b a 9 8 7 6 5 4 3 2 1 0 
  // +-------+---------------+-------+-------+-----------------------+
  // |       |               |imm4   |       |imm12                  |
  // +-------+---------------+-------+-------+-----------------------+

  // Extract the relocation addend from VAL based on the ARM
  // instruction encoding described above.
  static inline typename elfcpp::Swap<32, big_endian>::Valtype
  extract_arm_movw_movt_addend(
      typename elfcpp::Swap<32, big_endian>::Valtype val)
  {
    // According to the Elf ABI for ARM Architecture the immediate
    // field is sign-extended to form the addend.
    return utils::sign_extend<16>(((val >> 4) & 0xf000) | (val & 0xfff));
  }

  // Insert X into VAL based on the ARM instruction encoding described
  // above.
  static inline typename elfcpp::Swap<32, big_endian>::Valtype
  insert_val_arm_movw_movt(
      typename elfcpp::Swap<32, big_endian>::Valtype val,
      typename elfcpp::Swap<32, big_endian>::Valtype x)
  {
    val &= 0xfff0f000;
    val |= x & 0x0fff;
    val |= (x & 0xf000) << 4;
    return val;
  }

  // Encoding of imm16 argument for movt and movw Thumb2 instructions
  // from ARM ARM:
  //     
  //     imm16 := imm4 | i | imm3 | imm8
  //
  //  f e d c b a 9 8 7 6 5 4 3 2 1 0  f e d c b a 9 8 7 6 5 4 3 2 1 0 
  // +---------+-+-----------+-------++-+-----+-------+---------------+
  // |         |i|           |imm4   || |imm3 |       |imm8           |
  // +---------+-+-----------+-------++-+-----+-------+---------------+

  // Extract the relocation addend from VAL based on the Thumb2
  // instruction encoding described above.
  static inline typename elfcpp::Swap<32, big_endian>::Valtype
  extract_thumb_movw_movt_addend(
      typename elfcpp::Swap<32, big_endian>::Valtype val)
  {
    // According to the Elf ABI for ARM Architecture the immediate
    // field is sign-extended to form the addend.
    return utils::sign_extend<16>(((val >> 4) & 0xf000)
				  | ((val >> 15) & 0x0800)
				  | ((val >> 4) & 0x0700)
				  | (val & 0x00ff));
  }

  // Insert X into VAL based on the Thumb2 instruction encoding
  // described above.
  static inline typename elfcpp::Swap<32, big_endian>::Valtype
  insert_val_thumb_movw_movt(
      typename elfcpp::Swap<32, big_endian>::Valtype val,
      typename elfcpp::Swap<32, big_endian>::Valtype x)
  {
    val &= 0xfbf08f00;
    val |= (x & 0xf000) << 4;
    val |= (x & 0x0800) << 15;
    val |= (x & 0x0700) << 4;
    val |= (x & 0x00ff);
    return val;
  }

a557 77

  // R_ARM_ABS8: S + A
  static inline typename This::Status
  abs8(unsigned char *view,
       const Sized_relobj<32, big_endian>* object,
       const Symbol_value<32>* psymval)
  {
    typedef typename elfcpp::Swap<8, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<8, big_endian>::readval(wv);
    Reltype addend = utils::sign_extend<8>(val);
    Reltype x = This::arm_symbol_value(object, psymval, addend, false);
    val = utils::bit_select(val, x, 0xffU);
    elfcpp::Swap<8, big_endian>::writeval(wv, val);
    return (utils::has_signed_unsigned_overflow<8>(x)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_THM_ABS5: S + A
  static inline typename This::Status
  thm_abs5(unsigned char *view,
       const Sized_relobj<32, big_endian>* object,
       const Symbol_value<32>* psymval)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<16, big_endian>::readval(wv);
    Reltype addend = (val & 0x7e0U) >> 6;
    Reltype x = This::arm_symbol_value(object, psymval, addend, false);
    val = utils::bit_select(val, x << 6, 0x7e0U);
    elfcpp::Swap<16, big_endian>::writeval(wv, val);
    return (utils::has_overflow<5>(x)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_ABS12: S + A
  static inline typename This::Status
  abs12(unsigned char *view,
       const Sized_relobj<32, big_endian>* object,
       const Symbol_value<32>* psymval)
  {
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
    Reltype addend = val & 0x0fffU;
    Reltype x = This::arm_symbol_value(object, psymval, addend, false);
    val = utils::bit_select(val, x, 0x0fffU);
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
    return (utils::has_overflow<12>(x)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

  // R_ARM_ABS16: S + A
  static inline typename This::Status
  abs16(unsigned char *view,
       const Sized_relobj<32, big_endian>* object,
       const Symbol_value<32>* psymval)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<16, big_endian>::readval(wv);
    Reltype addend = utils::sign_extend<16>(val);
    Reltype x = This::arm_symbol_value(object, psymval, addend, false);
    val = utils::bit_select(val, x, 0xffffU);
    elfcpp::Swap<16, big_endian>::writeval(wv, val);
    return (utils::has_signed_unsigned_overflow<16>(x)
	    ? This::STATUS_OVERFLOW
	    : This::STATUS_OKAY);
  }

a636 9
  // R_ARM_BASE_ABS: B(S) + A
  static inline typename This::Status
  base_abs(unsigned char* view,
	    elfcpp::Elf_types<32>::Elf_Addr origin)
  {
    Base::rel32(view, origin);
    return STATUS_OKAY;
  }

a645 10
  // R_ARM_GOT_PREL: GOT(S) + A  P
  static inline typename This::Status
  got_prel(unsigned char* view,
	   typename elfcpp::Swap<32, big_endian>::Valtype got_offset,
	   elfcpp::Elf_types<32>::Elf_Addr address)
  {
    Base::rel32(view, got_offset - address);
    return This::STATUS_OKAY;
  }

a700 152

  // R_ARM_MOVW_ABS_NC: (S + A) | T
  static inline typename This::Status 
  movw_abs_nc(unsigned char *view,
	      const Sized_relobj<32, big_endian>* object,
	      const Symbol_value<32>* psymval,
	      bool has_thumb_bit)
  {
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
    Valtype addend =  This::extract_arm_movw_movt_addend(val);
    Valtype x = This::arm_symbol_value(object, psymval, addend, has_thumb_bit);
    val = This::insert_val_arm_movw_movt(val, x);
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
    return This::STATUS_OKAY;
  }

  // R_ARM_MOVT_ABS: S + A
  static inline typename This::Status
  movt_abs(unsigned char *view,
	   const Sized_relobj<32, big_endian>* object,
           const Symbol_value<32>* psymval)
  {
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
    Valtype addend = This::extract_arm_movw_movt_addend(val);
    Valtype x = This::arm_symbol_value(object, psymval, addend, 0) >> 16;
    val = This::insert_val_arm_movw_movt(val, x);
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
    return This::STATUS_OKAY;
  }

  //  R_ARM_THM_MOVW_ABS_NC: S + A | T
  static inline typename This::Status 
  thm_movw_abs_nc(unsigned char *view,
	          const Sized_relobj<32, big_endian>* object,
	          const Symbol_value<32>* psymval,
	          bool has_thumb_bit)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Reltype val = ((elfcpp::Swap<16, big_endian>::readval(wv) << 16)
		   | elfcpp::Swap<16, big_endian>::readval(wv + 1));
    Reltype addend = extract_thumb_movw_movt_addend(val);
    Reltype x = This::arm_symbol_value(object, psymval, addend, has_thumb_bit);
    val = This::insert_val_thumb_movw_movt(val, x);
    elfcpp::Swap<16, big_endian>::writeval(wv, val >> 16);
    elfcpp::Swap<16, big_endian>::writeval(wv + 1, val & 0xffff);
    return This::STATUS_OKAY;
  }

  //  R_ARM_THM_MOVT_ABS: S + A
  static inline typename This::Status 
  thm_movt_abs(unsigned char *view,
	       const Sized_relobj<32, big_endian>* object,
	       const Symbol_value<32>* psymval)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Reltype val = ((elfcpp::Swap<16, big_endian>::readval(wv) << 16)
		   | elfcpp::Swap<16, big_endian>::readval(wv + 1));
    Reltype addend = This::extract_thumb_movw_movt_addend(val);
    Reltype x = This::arm_symbol_value(object, psymval, addend, 0) >> 16;
    val = This::insert_val_thumb_movw_movt(val, x);
    elfcpp::Swap<16, big_endian>::writeval(wv, val >> 16);
    elfcpp::Swap<16, big_endian>::writeval(wv + 1, val & 0xffff);
    return This::STATUS_OKAY;
  }

  // R_ARM_MOVW_PREL_NC: (S + A) | T - P
  static inline typename This::Status
  movw_prel_nc(unsigned char *view,
	       const Sized_relobj<32, big_endian>* object,
	       const Symbol_value<32>* psymval,
	       elfcpp::Elf_types<32>::Elf_Addr address,
	       bool has_thumb_bit)
  {
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
    Valtype addend = This::extract_arm_movw_movt_addend(val);
    Valtype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit)
                 - address);
    val = This::insert_val_arm_movw_movt(val, x);
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
    return This::STATUS_OKAY;
  }

  // R_ARM_MOVT_PREL: S + A - P
  static inline typename This::Status
  movt_prel(unsigned char *view,
	    const Sized_relobj<32, big_endian>* object,
	    const Symbol_value<32>* psymval,
            elfcpp::Elf_types<32>::Elf_Addr address)
  {
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
    Valtype addend = This::extract_arm_movw_movt_addend(val);
    Valtype x = (This::arm_symbol_value(object, psymval, addend, 0)
                 - address) >> 16;
    val = This::insert_val_arm_movw_movt(val, x);
    elfcpp::Swap<32, big_endian>::writeval(wv, val);
    return This::STATUS_OKAY;
  }

  // R_ARM_THM_MOVW_PREL_NC: (S + A) | T - P
  static inline typename This::Status
  thm_movw_prel_nc(unsigned char *view,
	           const Sized_relobj<32, big_endian>* object,
	           const Symbol_value<32>* psymval,
	           elfcpp::Elf_types<32>::Elf_Addr address,
	           bool has_thumb_bit)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Reltype val = (elfcpp::Swap<16, big_endian>::readval(wv) << 16)
		  | elfcpp::Swap<16, big_endian>::readval(wv + 1);
    Reltype addend = This::extract_thumb_movw_movt_addend(val);
    Reltype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit)
                 - address);
    val = This::insert_val_thumb_movw_movt(val, x);
    elfcpp::Swap<16, big_endian>::writeval(wv, val >> 16);
    elfcpp::Swap<16, big_endian>::writeval(wv + 1, val & 0xffff);
    return This::STATUS_OKAY;
  }

  // R_ARM_THM_MOVT_PREL: S + A - P
  static inline typename This::Status
  thm_movt_prel(unsigned char *view,
	        const Sized_relobj<32, big_endian>* object,
	        const Symbol_value<32>* psymval,
	        elfcpp::Elf_types<32>::Elf_Addr address)
  {
    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Reltype val = (elfcpp::Swap<16, big_endian>::readval(wv) << 16)
		  | elfcpp::Swap<16, big_endian>::readval(wv + 1);
    Reltype addend = This::extract_thumb_movw_movt_addend(val);
    Reltype x = (This::arm_symbol_value(object, psymval, addend, 0)
                 - address) >> 16;
    val = This::insert_val_thumb_movw_movt(val, x);
    elfcpp::Swap<16, big_endian>::writeval(wv, val >> 16);
    elfcpp::Swap<16, big_endian>::writeval(wv + 1, val & 0xffff);
    return This::STATUS_OKAY;
  }
a1029 1
    case elfcpp::R_ARM_ABS32_NOI:
a1077 1
    case elfcpp::R_ARM_ABS32_NOI:
a1101 13
    case elfcpp::R_ARM_THM_ABS5:
    case elfcpp::R_ARM_ABS8:
    case elfcpp::R_ARM_ABS12:
    case elfcpp::R_ARM_ABS16:
    case elfcpp::R_ARM_BASE_ABS:
    case elfcpp::R_ARM_MOVW_ABS_NC:
    case elfcpp::R_ARM_MOVT_ABS:
    case elfcpp::R_ARM_THM_MOVW_ABS_NC:
    case elfcpp::R_ARM_THM_MOVT_ABS:
    case elfcpp::R_ARM_MOVW_PREL_NC:
    case elfcpp::R_ARM_MOVT_PREL:
    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
    case elfcpp::R_ARM_THM_MOVT_PREL:
a1113 1
    case elfcpp::R_ARM_GOT_PREL:
a1190 1
    case elfcpp::R_ARM_ABS32_NOI:
a1220 27
    case elfcpp::R_ARM_MOVW_ABS_NC:
    case elfcpp::R_ARM_MOVT_ABS:
    case elfcpp::R_ARM_THM_MOVW_ABS_NC:
    case elfcpp::R_ARM_THM_MOVT_ABS:
    case elfcpp::R_ARM_MOVW_PREL_NC:
    case elfcpp::R_ARM_MOVT_PREL:
    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
    case elfcpp::R_ARM_THM_MOVT_PREL:
      break;

    case elfcpp::R_ARM_THM_ABS5:
    case elfcpp::R_ARM_ABS8:
    case elfcpp::R_ARM_ABS12:
    case elfcpp::R_ARM_ABS16:
    case elfcpp::R_ARM_BASE_ABS:
      {
	// No dynamic relocs of this kinds.
	// Report the error in case of PIC.
	int flags = Symbol::NON_PIC_REF;
	if (gsym->type() == elfcpp::STT_FUNC
	    || gsym->type() == elfcpp::STT_ARM_TFUNC)
	  flags |= Symbol::FUNCTION_CALL;
	if (gsym->needs_dynamic_reloc(flags))
	  check_non_pic(object, r_type);
      }
      break;

a1298 1
    case elfcpp::R_ARM_GOT_PREL:
a1570 1
    case elfcpp::R_ARM_GOT_PREL:
a1597 18
    case elfcpp::R_ARM_ABS8:
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
	reloc_status = Arm_relocate_functions::abs8(view, object, psymval);
      break;

    case elfcpp::R_ARM_ABS12:
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
	reloc_status = Arm_relocate_functions::abs12(view, object, psymval);
      break;

    case elfcpp::R_ARM_ABS16:
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
	reloc_status = Arm_relocate_functions::abs16(view, object, psymval);
      break;

a1604 71
    case elfcpp::R_ARM_ABS32_NOI:
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
				    output_section))
	// No thumb bit for this relocation: (S + A)
	reloc_status = Arm_relocate_functions::abs32(view, object, psymval,
						     false);
      break;

    case elfcpp::R_ARM_MOVW_ABS_NC:
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
				    output_section))
	reloc_status = Arm_relocate_functions::movw_abs_nc(view, object,
							   psymval,
       						           has_thumb_bit);
      else
	gold_error(_("relocation R_ARM_MOVW_ABS_NC cannot be used when making"
		     "a shared object; recompile with -fPIC"));
      break;

    case elfcpp::R_ARM_MOVT_ABS:
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
				    output_section))
	reloc_status = Arm_relocate_functions::movt_abs(view, object, psymval);
      else
	gold_error(_("relocation R_ARM_MOVT_ABS cannot be used when making"
		     "a shared object; recompile with -fPIC"));
      break;

    case elfcpp::R_ARM_THM_MOVW_ABS_NC:
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
				    output_section))
	reloc_status = Arm_relocate_functions::thm_movw_abs_nc(view, object,
							       psymval,
       						               has_thumb_bit);
      else
	gold_error(_("relocation R_ARM_THM_MOVW_ABS_NC cannot be used when"
		     "making a shared object; recompile with -fPIC"));
      break;

    case elfcpp::R_ARM_THM_MOVT_ABS:
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
				    output_section))
	reloc_status = Arm_relocate_functions::thm_movt_abs(view, object,
							    psymval);
      else
	gold_error(_("relocation R_ARM_THM_MOVT_ABS cannot be used when"
		     "making a shared object; recompile with -fPIC"));
      break;

    case elfcpp::R_ARM_MOVW_PREL_NC:
      reloc_status = Arm_relocate_functions::movw_prel_nc(view, object,
							  psymval, address,
							  has_thumb_bit);
      break;

    case elfcpp::R_ARM_MOVT_PREL:
      reloc_status = Arm_relocate_functions::movt_prel(view, object,
                                                       psymval, address);
      break;

    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
      reloc_status = Arm_relocate_functions::thm_movw_prel_nc(view, object,
							      psymval, address,
							      has_thumb_bit);
      break;

    case elfcpp::R_ARM_THM_MOVT_PREL:
      reloc_status = Arm_relocate_functions::thm_movt_prel(view, object,
							   psymval, address);
      break;
	
a1609 6
    case elfcpp::R_ARM_THM_ABS5:
      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
				    output_section))
	reloc_status = Arm_relocate_functions::thm_abs5(view, object, psymval);
      break;

a1643 29
    case elfcpp::R_ARM_BASE_ABS:
      {
	if (!should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
				      output_section))
	  break;

	uint32_t origin;
	// Get the addressing origin of the output segment defining
	// the symbol gsym (AAELF 4.6.1.2 Relocation types).
	if (gsym == NULL)
	  // R_ARM_BASE_ABS with the NULL symbol will give the
	  // absolute address of the GOT origin (GOT_ORG) (see ARM IHI
	  // 0044C (AAELF): 4.6.1.8 Proxy generating relocations).
	  origin = target->got_plt_section()->address();
	else if (gsym->source() == Symbol::IN_OUTPUT_SEGMENT)
	  origin = gsym->output_segment()->vaddr();
	else if (gsym->source () == Symbol::IN_OUTPUT_DATA)
	  origin = gsym->output_data()->address();
	else
	  {
            gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
				   _("cannot find origin of R_ARM_BASE_ABS"));
	    return true;
	  }

	reloc_status = Arm_relocate_functions::base_abs(view, origin);
      }
      break;

a1648 12
    case elfcpp::R_ARM_GOT_PREL:
      gold_assert(have_got_offset);
      // Get the address origin for GOT PLT, which is allocated right
      // after the GOT section, to calculate an absolute address of
      // the symbol GOT entry (got_origin + got_offset).
      elfcpp::Elf_types<32>::Elf_Addr got_origin;
      got_origin = target->got_plt_section()->address();
      reloc_status = Arm_relocate_functions::got_prel(view,
						      got_origin + got_offset,
						      address);
      break;

d1734 1
a1734 2
    section_size_type view_size,
    const Reloc_symbol_changes* reloc_symbol_changes)
d1749 1
a1749 2
    view_size,
    reloc_symbol_changes);
a1766 7
    case elfcpp::R_ARM_ABS8:
      return 1;

    case elfcpp::R_ARM_ABS16:
    case elfcpp::R_ARM_THM_ABS5:
      return 2;

a1767 3
    case elfcpp::R_ARM_ABS32_NOI:
    case elfcpp::R_ARM_ABS12:
    case elfcpp::R_ARM_BASE_ABS:
a1772 1
    case elfcpp::R_ARM_GOT_PREL:
a1776 8
    case elfcpp::R_ARM_MOVW_ABS_NC:
    case elfcpp::R_ARM_MOVT_ABS:
    case elfcpp::R_ARM_THM_MOVW_ABS_NC:
    case elfcpp::R_ARM_THM_MOVT_ABS:
    case elfcpp::R_ARM_MOVW_PREL_NC:
    case elfcpp::R_ARM_MOVT_PREL:
    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
    case elfcpp::R_ARM_THM_MOVT_PREL:
@


1.8.2.2
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d1078 1
a1078 1
					   this->got_, false);
d1089 1
a1089 1
					   this->got_plt_, false);
d1117 1
a1117 1
				      elfcpp::SHF_ALLOC, this->rel_dyn_, true);
d1189 1
a1189 1
				  elfcpp::SHF_ALLOC, this->rel_, true);
d1351 1
a1351 1
				      this->plt_, false);
d1882 1
a1882 2
	  exidx_segment->add_output_section(exidx_section, elfcpp::PF_R,
					    false);
@


1.8.2.3
log
@	PR 10887
	* arm.cc (Target_arm::do_finalize_sections): Don't add dynamic
	tags if data is discarded by linker script.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d1834 1
a1834 2
      if (this->got_plt_ != NULL
	  && this->got_plt_->output_section() != NULL)
d1837 1
a1837 2
      if (this->plt_ != NULL
	  && this->plt_->output_section() != NULL)
d1845 1
a1845 2
      if (this->rel_dyn_ != NULL
	  && this->rel_dyn_->output_section() != NULL)
@


1.7
log
@	* layout.cc (Layout::make_output_section): Call
	Target::new_output_section.
	(Layout::attach_allocated_section_to_segment): Put large section
	sections in a separate load segment with the large segment flag
	set.
	(Layout::segment_precedes): Sort large data segments after other
	load segments.
	(align_file_offset): New static function.
	(Layout::set_segment_offsets): Use align_file_offset.
	* output.h (class Output_section): Add is_small_section_ and
	is_large_section_ fields.
	(Output_section::is_small_section): New function.
	(Output_section::set_is_small_section):  New function.
	(Output_section::is_large_section): New function.
	(Output_section::set_is_large_section): New function.
	(Output_section::is_large_data_section): New function.
	(class Output_segment): Add is_large_data_segment_ field.
	(Output_segment::is_large_data_segment): New function.
	(Output_segment::set_is_large_data_segment): New function.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_segment::Output_segment): Likewise.
	(Output_segment::add_output_section): Add assertion that large
	data sections always go in large data segments.  Force small data
	sections to the end of the list of data sections.  Force small BSS
	sections to the start of the list of BSS sections.  For large BSS
	sections to the end of the list of BSS sections.
	* symtab.h (class Symbol): Declare is_common_shndx.
	(Symbol::is_defined): Check Symbol::is_common_shndx.
	(Symbol::is_common): Likewise.
	(class Symbol_table): Define enum Commons_section_type.  Update
	declarations.  Add small_commons_ and large_commons_ fields.
	* symtab.cc (Symbol::is_common_shndx): New function.
	(Symbol_table::Symbol_table): Initialize new fields.
	(Symbol_table::add_from_object): Put small and large common
	symbols in the right list.
	(Symbol_table::sized_finalized_symbol): Check
	Symbol::is_common_shndx.
	(Symbol_table::sized_write_globals): Likewise.
	* common.cc (Symbol_table::do_allocate_commons): Allocate new
	common symbol lists.  Don't call do_allocate_commons_list if the
	list is empty.
	(Symbol_table::do_allocate_commons_list): Remove is_tls
	parameter.  Add comons_section_type parameter.  Change all
	callers.  Handle small and large common symbols.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Check
	Symbol::is_common_shndx.
	* resolve.cc (symbol_to_bits): Likewise.
	* target.h (Target::small_common_shndx): New function.
	(Target::small_common_section_flags): New function.
	(Target::large_common_shndx): New function.
	(Target::large_common_section_flags): New function.
	(Target::new_output_section): New function.
	(Target::Target_info): Add small_common_shndx, large_common_shndx,
	small_common_section_flags, and large_common_section_flags
	fields.
	(Target::do_new_output_section): New virtual function.
	* arm.cc (Target_arm::arm_info): Initialize new fields.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Likewise.
	* sparc.c (Target_sparc::sparc_info) [all versions]: Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	(Target_x86_64::do_new_output_section): New function.
	* configure.ac: Define conditional MCMODEL_MEDIUM.
	* testsuite/Makefile.am (check_PROGRAMS): Add large.
	(large_SOURCES, large_CFLAGS, large_DEPENDENCIES): Define.
	(large_LDFLAGS): Define.
	* testsuite/large.c: New file.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Initialize new fields.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d77 2
a78 2
// Coming soon (pending patches):
// - Defining section symbols __exidx_start and __exidx_stop.
d80 1
a80 6
// - Mergeing all .ARM.xxx.yyy sections into .ARM.xxx.  Currently, they
//   are incorrectly merged into an .ARM section.
//
// TODOs:
// - Create a PT_ARM_EXIDX program header for a shared object that
//   might throw an exception.
d84 1
d1462 19
@


1.6
log
@2009-06-03  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (utils::sign_extend): Reverse test in gold_assert.
	(utils::has_overflow): Same.
@
text
@d452 5
a456 1
  0x1000		// common_pagesize (overridable by -z common-page-size)
@


1.5
log
@2009-06-03  Doug Kwan  <dougkwan@@google.com>

	* gold/arm.cc (namespace utils): New.
	(Target_arm::reloc_is_non_pic): Define new method.
	(class Arm_relocate_functions): New.
	(Target_arm::Relocate::relocate): Handle relocation types used by
	Android.
@
text
@d100 1
a100 1
    gold_assert(no_bits < 1 || no_bits > 32);
d115 1
a115 1
    gold_assert(no_bits < 1 || no_bits > 32);
@


1.4
log
@	* arm.cc (Target_arm::scan::global): Use || instead of |.
@
text
@a77 1
// - Relocation
d90 42
d332 18
d455 248
d1509 5
a1513 5
    const Relocate_info<32, big_endian>* /* relinfo */,
    Target_arm* /* target */,
    Output_section* /* output_section */,
    size_t /* relnum */,
    const elfcpp::Rel<32, big_endian>& /* rel */,
d1515 4
a1518 4
    const Sized_symbol<32>* /* gsym */,
    const Symbol_value<32>* /* psymval */,
    unsigned char* /* view */,
    elfcpp::Elf_types<32>::Elf_Addr /* address */,
d1521 53
d1579 116
@


1.3
log
@2009-06-02  Doug Kwan  <dougkwan@@google.com>

	* gold/arm.cc (Target_arm::Scan::Scan):  Initialize
	issued_non_pic_error_.
	(class Target_arm::Scan): Declare new method check_non_pic.
	Define new method symbol_needs_plt_entry.
	Declare new data member issued_non_pic_error_.
	(class Target_arm::Relocate): Declare new method
	should_apply_static_reloc.
	(Target_arm::may_need_copy_reloc): Handle STT_ARM_TFUNC.
	(Target_arm::Scan::check_non_pic): Define new method.
	(Target_arm::Scan::local): Handle a small subset of reloc types used
	by Android.
	(Target_arm::Scan::local): Same.
	(Target_arm::Relocate::should_apply_statci_reloc): Define new method.
@
text
@d946 1
a946 1
	    | gsym->type() == elfcpp::STT_ARM_TFUNC)
@


1.2
log
@2009-05-29  Doug Kwan  <dougkwan@@google.com>

	* gold/arm.cc (Output_data_plt_arm): Forward declaration for new
	template class.
	(class Target_arm): Update comment.
	(Target_arm::Target_arm): Initialize new data members GOT_,
	PLT_, GOT_PLT_, REL_DYN_, COPY_RELOCS_ and DYNBSS_.
	Declare new methods Target_arm::got_section, Target_arm::make_plt_entry
	and Target_arm::rel_dyn_section.
	Declare new_enum Target_arm::Got_type.
	Declare new data members GOT_, PLT_, GOT_PLT_, REL_DYN_, COPY_RELOCS_
	and DYNBSS_.
	Update commments for member do_dynsym_value.
	(Target_arm::got_size, Target_arm::plt_section,
	Target_arm::may_need_copy_reloc and Target_arm::copy_reloc): Define
	new methods inside class defintion.
	(Target_arm::got_section): Define new method.
	(Target_arm::rel_dyn_section): Same.
	(Output_data_plt_arm): New template class.
	(Output_data_plt_arm::Output_data_plt_arm): Define constructor.
	(Output_data_plt_arm:do_adjust_output_section): Define new method.
	(Output_data_plt_arm::add_entry): Same.
	(Output_data_plt_arm::first_plt_entry): Define new
	static data member for PLT instruction template.
	(Output_data_plt_arm::plt_entry): Same.
	(Output_data_plt_arm::do_write): Define new method.
	(Target_arm::make_plt_entry): Same.
	(Target_arm::do_finalize_sections): Same.
	(Target_arm::do_dynsym_value): Same.
@
text
@a77 2
// - Local scanner
// - Global scanner
d210 1
d239 23
d274 7
d338 2
a339 1
	    && gsym->type() != elfcpp::STT_FUNC);
d702 45
d748 2
d754 3
a756 3
				    Symbol_table* /* symtab */,
				    Layout* /* layout */,
				    Target_arm* /* target */,
d758 3
a760 3
				    unsigned int /* data_shndx */,
				    Output_section* /* output_section */,
				    const elfcpp::Rel<32, big_endian>& /* reloc */,
d770 71
d861 2
d867 3
a869 3
				     Symbol_table* /* symtab */,
				     Layout* /* layout */,
				     Target_arm* /* target */,
d871 3
a873 3
				     unsigned int /* data_shndx */,
				     Output_section* /* output_section */,
				     const elfcpp::Rel<32, big_endian>& /* reloc */,
d883 149
d1157 40
@


1.1
log
@2009-05-28  Doug Kwan  <dougkwan@@google.com>

        * configure.ac: Support gold for target arm*-*-*.
        * configure: Regenerate.
        * gold/Makefile.am (TARGETSOURCES): Add arm.cc.
        (ALL_TARGETOBJECTS): Add arm.$(OBJEXT)
        * gold/Makefile.in: Regenerate.
        * gold/arm.cc: New file.
        * gold/configure.tgt: Add armbe*-*-*, armeb*-*-* and arm*-*-* targets.
@
text
@d51 3
a77 1
// - Support for dynamic symbols (GOT, PLT and etc).
d90 2
d101 3
a103 1
    : Sized_target<32, big_endian>(&arm_info)
d141 1
a141 1
  // Return the value to use for a dynamic which requires special
d194 8
d273 52
d328 19
d366 294
d818 1
a818 1
Target_arm<big_endian>::do_finalize_sections(Layout* /* layout */)
d820 36
a855 1
  gold_unreachable ();
d1038 5
d1045 1
a1045 1
Target_arm<big_endian>::do_dynsym_value(const Symbol* /*gsym*/) const
d1047 2
a1048 2
  gold_unreachable ();
  return 0;
@

