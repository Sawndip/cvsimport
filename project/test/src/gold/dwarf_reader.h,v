head	1.31;
access;
symbols
	binutils-2_24-branch:1.30.0.2
	binutils-2_24-branchpoint:1.30
	binutils-2_21_1:1.17
	binutils-2_23_2:1.23
	binutils-2_23_1:1.23
	binutils-2_23:1.23
	binutils-2_23-branch:1.23.0.2
	binutils-2_23-branchpoint:1.23
	binutils-2_22_branch:1.20.0.4
	binutils-2_22:1.20
	binutils-2_22-branch:1.20.0.2
	binutils-2_22-branchpoint:1.20
	binutils-2_21:1.17
	binutils-2_21-branch:1.17.0.2
	binutils-2_21-branchpoint:1.17
	binutils-2_20_1:1.15.8.1
	binutils-2_20:1.15.8.1
	binutils-arc-20081103-branch:1.15.0.10
	binutils-arc-20081103-branchpoint:1.15
	binutils-2_20-branch:1.15.0.8
	binutils-2_20-branchpoint:1.15
	dje-cgen-play1-branch:1.15.0.6
	dje-cgen-play1-branchpoint:1.15
	arc-20081103-branch:1.15.0.4
	arc-20081103-branchpoint:1.15
	binutils-2_19_1:1.15
	binutils-2_19:1.15
	binutils-2_19-branch:1.15.0.2
	binutils-2_19-branchpoint:1.15
	binutils_latest_snapshot:1.31
	added-to-binutils:1.12;
locks; strict;
comment	@ * @;


1.31
date	2013.10.11.21.11.49;	author roland;	state Exp;
branches;
next	1.30;

1.30
date	2013.08.07.17.11.24;	author ccoutant;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2013.07.29.18.29.12;	author sterling;	state Exp;
branches;
next	1.28;

1.28
date	2013.07.01.20.12.11;	author ccoutant;	state Exp;
branches;
next	1.27;

1.27
date	2013.03.01.23.05.27;	author ccoutant;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.01.22.53.02;	author ccoutant;	state Exp;
branches;
next	1.25;

1.25
date	2012.10.23.21.41.37;	author ccoutant;	state Exp;
branches;
next	1.24;

1.24
date	2012.10.23.21.37.26;	author ccoutant;	state Exp;
branches;
next	1.23;

1.23
date	2012.05.01.19.12.21;	author mark;	state Exp;
branches;
next	1.22;

1.22
date	2012.03.21.19.02.21;	author ccoutant;	state Exp;
branches;
next	1.21;

1.21
date	2012.02.29.21.22.29;	author ccoutant;	state Exp;
branches;
next	1.20;

1.20
date	2011.03.10.01.31.32;	author ian;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.20.18.37.36;	author ian;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.01.19.49.22;	author ian;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.09.03.02.28;	author dougkwan;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.09.23.05.21;	author ian;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.28.20.48.16;	author ian;	state Exp;
branches
	1.15.8.1;
next	1.14;

1.14
date	2008.05.01.00.25.33;	author csilvers;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2007.12.11.18.17.31;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.28.18.01.06;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.14.18.33.47;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.14.01.03.01;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.13.01.26.27;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.12.20.55.53;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.12.19.56.20;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.09.23.16.54;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.07.00.49.56;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.02.23.02.44;	author iant;	state Exp;
branches;
next	;

1.30.2.1
date	2013.10.11.21.23.42;	author roland;	state Exp;
branches;
next	;

1.15.8.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	;


desc
@@


1.31
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@// dwarf_reader.h -- parse dwarf2/3 debug information for gold  -*- C++ -*-

// Copyright 2007, 2008, 2009, 2010, 2011, 2012, 2013
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#ifndef GOLD_DWARF_READER_H
#define GOLD_DWARF_READER_H

#include <vector>
#include <map>
#include <limits.h>
#include <sys/types.h>

#include "elfcpp.h"
#include "elfcpp_swap.h"
#include "dwarf.h"
#include "reloc.h"

namespace gold
{

class Dwarf_info_reader;
struct LineStateMachine;

// This class is used to extract the section index and offset of
// the target of a relocation for a given offset within the section.

class Elf_reloc_mapper
{
 public:
  Elf_reloc_mapper()
  { }

  virtual
  ~Elf_reloc_mapper()
  { }

  // Initialize the relocation tracker for section RELOC_SHNDX.
  bool
  initialize(unsigned int reloc_shndx, unsigned int reloc_type)
  { return this->do_initialize(reloc_shndx, reloc_type); }

  // Return the next reloc_offset.
  off_t
  next_offset()
  { return this->do_next_offset(); }

  // Advance to the next relocation past OFFSET.
  void
  advance(off_t offset)
  { this->do_advance(offset); }

  // Return the section index and offset within the section of the target
  // of the relocation for RELOC_OFFSET in the referring section.
  unsigned int
  get_reloc_target(off_t reloc_offset, off_t* target_offset)
  { return this->do_get_reloc_target(reloc_offset, target_offset); }

  // Checkpoint the current position in the reloc section.
  uint64_t
  checkpoint() const
  { return this->do_checkpoint(); }

  // Reset the current position to the CHECKPOINT.
  void
  reset(uint64_t checkpoint)
  { this->do_reset(checkpoint); }

 protected:
  virtual bool
  do_initialize(unsigned int, unsigned int) = 0;

  // Return the next reloc_offset.
  virtual off_t
  do_next_offset() = 0;

  // Advance to the next relocation past OFFSET.
  virtual void
  do_advance(off_t offset) = 0;

  virtual unsigned int
  do_get_reloc_target(off_t reloc_offset, off_t* target_offset) = 0;

  // Checkpoint the current position in the reloc section.
  virtual uint64_t
  do_checkpoint() const = 0;

  // Reset the current position to the CHECKPOINT.
  virtual void
  do_reset(uint64_t checkpoint) = 0;
};

template<int size, bool big_endian>
class Sized_elf_reloc_mapper : public Elf_reloc_mapper
{
 public:
  Sized_elf_reloc_mapper(Object* object, const unsigned char* symtab,
			 off_t symtab_size)
    : object_(object), symtab_(symtab), symtab_size_(symtab_size),
      reloc_type_(0), track_relocs_()
  { }

 protected:
  bool
  do_initialize(unsigned int reloc_shndx, unsigned int reloc_type);

  // Return the next reloc_offset.
  virtual off_t
  do_next_offset()
  { return this->track_relocs_.next_offset(); }

  // Advance to the next relocation past OFFSET.
  virtual void
  do_advance(off_t offset)
  { this->track_relocs_.advance(offset); }

  unsigned int
  do_get_reloc_target(off_t reloc_offset, off_t* target_offset);

  // Checkpoint the current position in the reloc section.
  uint64_t
  do_checkpoint() const
  { return this->track_relocs_.checkpoint(); }

  // Reset the current position to the CHECKPOINT.
  void
  do_reset(uint64_t checkpoint)
  { this->track_relocs_.reset(checkpoint); }

 private:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;

  // Return the section index of symbol SYMNDX, and copy its value to *VALUE.
  // Set *IS_ORDINARY true if the section index is an ordinary section index.
  unsigned int
  symbol_section(unsigned int symndx, Address* value, bool* is_ordinary);

  // The object file.
  Object* object_;
  // The ELF symbol table.
  const unsigned char* symtab_;
  // The size of the ELF symbol table.
  off_t symtab_size_;
  // Type of the relocation section (SHT_REL or SHT_RELA).
  unsigned int reloc_type_;
  // Relocations for the referring section.
  Track_relocs<size, big_endian> track_relocs_;
};

// This class is used to read the abbreviations table from the
// .debug_abbrev section of the object file.

class Dwarf_abbrev_table
{
 public:
  // An attribute list entry.
  struct Attribute
  {
    Attribute(unsigned int a, unsigned int f)
      : attr(a), form(f)
    { }
    unsigned int attr;
    unsigned int form;
  };

  // An abbrev code entry.
  struct Abbrev_code
  {
    Abbrev_code(unsigned int t, bool hc)
      : tag(t), has_children(hc), has_sibling_attribute(false), attributes()
    {
      this->attributes.reserve(10);
    }

    void
    add_attribute(unsigned int attr, unsigned int form)
    {
      this->attributes.push_back(Attribute(attr, form));
    }

    // The DWARF tag.
    unsigned int tag;
    // True if the DIE has children.
    bool has_children : 1;
    // True if the DIE has a sibling attribute.
    bool has_sibling_attribute : 1;
    // The list of attributes and forms.
    std::vector<Attribute> attributes;
  };

  Dwarf_abbrev_table()
    : abbrev_shndx_(0), abbrev_offset_(0), buffer_(NULL), buffer_end_(NULL),
      owns_buffer_(false), buffer_pos_(NULL), high_abbrev_codes_()
  {
    memset(this->low_abbrev_codes_, 0, sizeof(this->low_abbrev_codes_));
  }

  ~Dwarf_abbrev_table()
  {
    if (this->owns_buffer_ && this->buffer_ != NULL)
      delete[] this->buffer_;
    this->clear_abbrev_codes();
  }

  // Read the abbrev table from an object file.
  bool
  read_abbrevs(Relobj* object,
	       unsigned int abbrev_shndx,
	       off_t abbrev_offset)
  {
    // If we've already read this abbrev table, return immediately.
    if (this->abbrev_shndx_ > 0
	&& this->abbrev_shndx_ == abbrev_shndx
	&& this->abbrev_offset_ == abbrev_offset)
      return true;
    return this->do_read_abbrevs(object, abbrev_shndx, abbrev_offset);
  }

  // Return the abbrev code entry for CODE.  This is a fast path for
  // abbrev codes that are in the direct lookup table.  If not found
  // there, we call do_get_abbrev() to do the hard work.
  const Abbrev_code*
  get_abbrev(unsigned int code)
  {
    if (code < this->low_abbrev_code_max_
	&& this->low_abbrev_codes_[code] != NULL)
      return this->low_abbrev_codes_[code];
    return this->do_get_abbrev(code);
  }

 private:
  // Read the abbrev table from an object file.
  bool
  do_read_abbrevs(Relobj* object,
		  unsigned int abbrev_shndx,
		  off_t abbrev_offset);

  // Lookup the abbrev code entry for CODE.
  const Abbrev_code*
  do_get_abbrev(unsigned int code);

  // Store an abbrev code entry for CODE.
  void
  store_abbrev(unsigned int code, const Abbrev_code* entry)
  {
    if (code < this->low_abbrev_code_max_)
      this->low_abbrev_codes_[code] = entry;
    else
      this->high_abbrev_codes_[code] = entry;
  }

  // Clear the abbrev code table and release the memory it uses.
  void
  clear_abbrev_codes();

  typedef Unordered_map<unsigned int, const Abbrev_code*> Abbrev_code_table;

  // The section index of the current abbrev table.
  unsigned int abbrev_shndx_;
  // The offset within the section of the current abbrev table.
  off_t abbrev_offset_;
  // The buffer containing the .debug_abbrev section.
  const unsigned char* buffer_;
  const unsigned char* buffer_end_;
  // True if this object owns the buffer and needs to delete it.
  bool owns_buffer_;
  // Pointer to the current position in the buffer.
  const unsigned char* buffer_pos_;
  // The table of abbrev codes.
  // We use a direct-lookup array for low abbrev codes,
  // and store the rest in a hash table.
  static const unsigned int low_abbrev_code_max_ = 256;
  const Abbrev_code* low_abbrev_codes_[low_abbrev_code_max_];
  Abbrev_code_table high_abbrev_codes_;
};

// A DWARF range list.  The start and end offsets are relative
// to the input section SHNDX.  Each range must lie entirely
// within a single section.

class Dwarf_range_list
{
 public:
  struct Range
  {
    Range(unsigned int a_shndx, off_t a_start, off_t a_end)
      : shndx(a_shndx), start(a_start), end(a_end)
    { }

    unsigned int shndx;
    off_t start;
    off_t end;
  };

  Dwarf_range_list()
    : range_list_()
  { }

  void
  add(unsigned int shndx, off_t start, off_t end)
  { this->range_list_.push_back(Range(shndx, start, end)); }

  size_t
  size() const
  { return this->range_list_.size(); }

  const Range&
  operator[](off_t i) const
  { return this->range_list_[i]; }

 private:
  std::vector<Range> range_list_;
};

// This class is used to read the ranges table from the
// .debug_ranges section of the object file.

class Dwarf_ranges_table
{
 public:
  Dwarf_ranges_table(Dwarf_info_reader* dwinfo)
    : dwinfo_(dwinfo), ranges_shndx_(0), ranges_buffer_(NULL),
      ranges_buffer_end_(NULL), owns_ranges_buffer_(false),
      ranges_reloc_mapper_(NULL), reloc_type_(0), output_section_offset_(0)
  { }

  ~Dwarf_ranges_table()
  {
    if (this->owns_ranges_buffer_ && this->ranges_buffer_ != NULL)
      delete[] this->ranges_buffer_;
    if (this->ranges_reloc_mapper_ != NULL)
      delete this->ranges_reloc_mapper_;
  }

  // Read the ranges table from an object file.
  bool
  read_ranges_table(Relobj* object,
		    const unsigned char* symtab,
		    off_t symtab_size,
		    unsigned int ranges_shndx);

  // Read the range table from an object file.
  Dwarf_range_list*
  read_range_list(Relobj* object,
		  const unsigned char* symtab,
		  off_t symtab_size,
		  unsigned int address_size,
		  unsigned int ranges_shndx,
		  off_t ranges_offset);

  // Look for a relocation at offset OFF in the range table,
  // and return the section index and offset of the target.
  unsigned int
  lookup_reloc(off_t off, off_t* target_off);

 private:
  // The Dwarf_info_reader, for reading data.
  Dwarf_info_reader* dwinfo_;
  // The section index of the ranges table.
  unsigned int ranges_shndx_;
  // The buffer containing the .debug_ranges section.
  const unsigned char* ranges_buffer_;
  const unsigned char* ranges_buffer_end_;
  // True if this object owns the buffer and needs to delete it.
  bool owns_ranges_buffer_;
  // Relocation mapper for the .debug_ranges section.
  Elf_reloc_mapper* ranges_reloc_mapper_;
  // Type of the relocation section (SHT_REL or SHT_RELA).
  unsigned int reloc_type_;
  // For incremental update links, this will hold the offset of the
  // input section within the output section.  Offsets read from
  // relocated data will be relative to the output section, and need
  // to be corrected before reading data from the input section.
  uint64_t output_section_offset_;
};

// This class is used to read the pubnames and pubtypes tables from the
// .debug_pubnames and .debug_pubtypes sections of the object file.

class Dwarf_pubnames_table
{
 public:
  Dwarf_pubnames_table(Dwarf_info_reader* dwinfo, bool is_pubtypes)
    : dwinfo_(dwinfo), buffer_(NULL), buffer_end_(NULL), owns_buffer_(false),
      offset_size_(0), pinfo_(NULL), is_pubtypes_(is_pubtypes),
      output_section_offset_(0), unit_length_(0), cu_offset_(0)
  { }

  ~Dwarf_pubnames_table()
  {
    if (this->owns_buffer_ && this->buffer_ != NULL)
      delete[] this->buffer_;
  }

  // Read the pubnames section from the object file, using the symbol
  // table for relocating it.
  bool
  read_section(Relobj* object, const unsigned char* symbol_table,
               off_t symtab_size);

  // Read the header for the set at OFFSET.
  bool
  read_header(off_t offset);

  // Return the offset to the cu within the info or types section.
  off_t
  cu_offset()
  { return this->cu_offset_; }

  // Return the size of this subsection of the table.  The unit length
  // doesn't include the size of its own field.
  off_t
  subsection_size()
  { return this->unit_length_; }

  // Read the next name from the set.
  const char*
  next_name();

 private:
  // The Dwarf_info_reader, for reading data.
  Dwarf_info_reader* dwinfo_;
  // The buffer containing the .debug_ranges section.
  const unsigned char* buffer_;
  const unsigned char* buffer_end_;
  // True if this object owns the buffer and needs to delete it.
  bool owns_buffer_;
  // The size of a DWARF offset for the current set.
  unsigned int offset_size_;
  // The current position within the buffer.
  const unsigned char* pinfo_;
  // TRUE if this is a .debug_pubtypes section.
  bool is_pubtypes_;
  // For incremental update links, this will hold the offset of the
  // input section within the output section.  Offsets read from
  // relocated data will be relative to the output section, and need
  // to be corrected before reading data from the input section.
  uint64_t output_section_offset_;
  // Fields read from the header.
  uint64_t unit_length_;
  off_t cu_offset_;

  // Track relocations for this table so we can find the CUs that
  // correspond to the subsections.
  Elf_reloc_mapper* reloc_mapper_;
  // Type of the relocation section (SHT_REL or SHT_RELA).
  unsigned int reloc_type_;
};

// This class represents a DWARF Debug Info Entry (DIE).

class Dwarf_die
{
 public:
  // An attribute value.
  struct Attribute_value
  {
    unsigned int attr;
    unsigned int form;
    union
    {
      int64_t intval;
      uint64_t uintval;
      const char* stringval;
      const unsigned char* blockval;
      off_t refval;
    } val;
    union
    {
      // Section index for reference forms.
      unsigned int shndx;
      // Block length for block forms.
      unsigned int blocklen;
      // Attribute offset for DW_FORM_strp.
      unsigned int attr_off;
    } aux;
  };

  // A list of attribute values.
  typedef std::vector<Attribute_value> Attributes;

  Dwarf_die(Dwarf_info_reader* dwinfo,
	    off_t die_offset,
	    Dwarf_die* parent);

  // Return the DWARF tag for this DIE.
  unsigned int
  tag() const
  {
    if (this->abbrev_code_ == NULL)
      return 0;
    return this->abbrev_code_->tag;
  }

  // Return true if this DIE has children.
  bool
  has_children() const
  {
    gold_assert(this->abbrev_code_ != NULL);
    return this->abbrev_code_->has_children;
  }

  // Return true if this DIE has a sibling attribute.
  bool
  has_sibling_attribute() const
  {
    gold_assert(this->abbrev_code_ != NULL);
    return this->abbrev_code_->has_sibling_attribute;
  }

  // Return the value of attribute ATTR.
  const Attribute_value*
  attribute(unsigned int attr);

  // Return the value of the DW_AT_name attribute.
  const char*
  name()
  {
    if (this->name_ == NULL)
      this->set_name();
    return this->name_;
  }

  // Return the value of the DW_AT_linkage_name
  // or DW_AT_MIPS_linkage_name attribute.
  const char*
  linkage_name()
  {
    if (this->linkage_name_ == NULL)
      this->set_linkage_name();
    return this->linkage_name_;
  }

  // Return the value of the DW_AT_specification attribute.
  off_t
  specification()
  {
    if (!this->attributes_read_)
      this->read_attributes();
    return this->specification_;
  }

  // Return the value of the DW_AT_abstract_origin attribute.
  off_t
  abstract_origin()
  {
    if (!this->attributes_read_)
      this->read_attributes();
    return this->abstract_origin_;
  }

  // Return the value of attribute ATTR as a string.
  const char*
  string_attribute(unsigned int attr);

  // Return the value of attribute ATTR as an integer.
  int64_t
  int_attribute(unsigned int attr);

  // Return the value of attribute ATTR as an unsigned integer.
  uint64_t
  uint_attribute(unsigned int attr);

  // Return the value of attribute ATTR as a reference.
  off_t
  ref_attribute(unsigned int attr, unsigned int* shndx);

  // Return the value of attribute ATTR as a address.
  off_t
  address_attribute(unsigned int attr, unsigned int* shndx);

  // Return the value of attribute ATTR as a flag.
  bool
  flag_attribute(unsigned int attr)
  { return this->int_attribute(attr) != 0; }

  // Return true if this DIE is a declaration.
  bool
  is_declaration()
  { return this->flag_attribute(elfcpp::DW_AT_declaration); }

  // Return the parent of this DIE.
  Dwarf_die*
  parent() const
  { return this->parent_; }

  // Return the offset of this DIE.
  off_t
  offset() const
  { return this->die_offset_; }

  // Return the offset of this DIE's first child.
  off_t
  child_offset();

  // Set the offset of this DIE's next sibling.
  void
  set_sibling_offset(off_t sibling_offset)
  { this->sibling_offset_ = sibling_offset; }

  // Return the offset of this DIE's next sibling.
  off_t
  sibling_offset();

 private:
  typedef Dwarf_abbrev_table::Abbrev_code Abbrev_code;

  // Read all the attributes of the DIE.
  bool
  read_attributes();

  // Set the name of the DIE if present.
  void
  set_name();

  // Set the linkage name if present.
  void
  set_linkage_name();

  // Skip all the attributes of the DIE and return the offset
  // of the next DIE.
  off_t
  skip_attributes();

  // The Dwarf_info_reader, for reading attributes.
  Dwarf_info_reader* dwinfo_;
  // The parent of this DIE.
  Dwarf_die* parent_;
  // Offset of this DIE within its compilation unit.
  off_t die_offset_;
  // Offset of the first attribute, relative to the beginning of the DIE.
  off_t attr_offset_;
  // Offset of the first child, relative to the compilation unit.
  off_t child_offset_;
  // Offset of the next sibling, relative to the compilation unit.
  off_t sibling_offset_;
  // The abbreviation table entry.
  const Abbrev_code* abbrev_code_;
  // The list of attributes.
  Attributes attributes_;
  // True if the attributes have been read.
  bool attributes_read_;
  // The following fields hold common attributes to avoid a linear
  // search through the attribute list.
  // The DIE name (DW_AT_name).
  const char* name_;
  // Offset of the name in the string table (for DW_FORM_strp).
  off_t name_off_;
  // The linkage name (DW_AT_linkage_name or DW_AT_MIPS_linkage_name).
  const char* linkage_name_;
  // Offset of the linkage name in the string table (for DW_FORM_strp).
  off_t linkage_name_off_;
  // Section index of the string table (for DW_FORM_strp).
  unsigned int string_shndx_;
  // The value of a DW_AT_specification attribute.
  off_t specification_;
  // The value of a DW_AT_abstract_origin attribute.
  off_t abstract_origin_;
};

// This class is used to read the debug info from the .debug_info
// or .debug_types sections.  This is a base class that implements
// the generic parsing of the compilation unit header and DIE
// structure.  The parse() method parses the entire section, and
// calls the various visit_xxx() methods for each header.  Clients
// should derive a new class from this one and implement the
// visit_compilation_unit() and visit_type_unit() functions.

class Dwarf_info_reader
{
 public:
  Dwarf_info_reader(bool is_type_unit,
		    Relobj* object,
		    const unsigned char* symtab,
		    off_t symtab_size,
		    unsigned int shndx,
		    unsigned int reloc_shndx,
		    unsigned int reloc_type)
    : is_type_unit_(is_type_unit), object_(object), symtab_(symtab),
      symtab_size_(symtab_size), shndx_(shndx), reloc_shndx_(reloc_shndx),
      reloc_type_(reloc_type), abbrev_shndx_(0), string_shndx_(0),
      buffer_(NULL), buffer_end_(NULL), cu_offset_(0), cu_length_(0),
      offset_size_(0), address_size_(0), cu_version_(0),
      abbrev_table_(), ranges_table_(this),
      reloc_mapper_(NULL), string_buffer_(NULL), string_buffer_end_(NULL),
      owns_string_buffer_(false), string_output_section_offset_(0)
  { }

  virtual
  ~Dwarf_info_reader()
  {
    if (this->reloc_mapper_ != NULL)
      delete this->reloc_mapper_;
    if (this->owns_string_buffer_ && this->string_buffer_ != NULL)
      delete[] this->string_buffer_;
  }

  // Begin parsing the debug info.  This calls visit_compilation_unit()
  // or visit_type_unit() for each compilation or type unit found in the
  // section, and visit_die() for each top-level DIE.
  void
  parse();

  // Return the abbrev code entry for a CODE.
  const Dwarf_abbrev_table::Abbrev_code*
  get_abbrev(unsigned int code)
  { return this->abbrev_table_.get_abbrev(code); }

  // Return a pointer to the DWARF info buffer at OFFSET.
  const unsigned char*
  buffer_at_offset(off_t offset) const
  {
    const unsigned char* p = this->buffer_ + this->cu_offset_ + offset;
    if (this->check_buffer(p + 1))
      return p;
    return NULL;
  }

  // Read a possibly unaligned integer of SIZE.
  template <int valsize>
  inline typename elfcpp::Valtype_base<valsize>::Valtype
  read_from_pointer(const unsigned char* source);

  // Read a possibly unaligned integer of SIZE.  Update SOURCE after read.
  template <int valsize>
  inline typename elfcpp::Valtype_base<valsize>::Valtype
  read_from_pointer(const unsigned char** source);

  // Look for a relocation at offset ATTR_OFF in the dwarf info,
  // and return the section index and offset of the target.
  unsigned int
  lookup_reloc(off_t attr_off, off_t* target_off);

  // Return a string from the DWARF string table.
  const char*
  get_string(off_t str_off, unsigned int string_shndx);

  // Return the size of a DWARF offset.
  unsigned int
  offset_size() const
  { return this->offset_size_; }

  // Return the size of an address.
  unsigned int
  address_size() const
  { return this->address_size_; }

  // Set the section index of the .debug_abbrev section.
  // We use this if there are no relocations for the .debug_info section.
  // If not set, the code parse() routine will search for the section by name.
  void
  set_abbrev_shndx(unsigned int abbrev_shndx)
  { this->abbrev_shndx_ = abbrev_shndx; }

  // Return a pointer to the object file's ELF symbol table.
  const unsigned char*
  symtab() const
  { return this->symtab_; }

  // Return the size of the object file's ELF symbol table.
  off_t
  symtab_size() const
  { return this->symtab_size_; }

  // Return the offset of the current compilation unit.
  off_t
  cu_offset() const
  { return this->cu_offset_; }

 protected:
  // Begin parsing the debug info.  This calls visit_compilation_unit()
  // or visit_type_unit() for each compilation or type unit found in the
  // section, and visit_die() for each top-level DIE.
  template<bool big_endian>
  void
  do_parse();

  // The following methods are hooks that are meant to be implemented
  // by a derived class.  A default, do-nothing, implementation of
  // each is provided for this base class.

  // Visit a compilation unit.
  virtual void
  visit_compilation_unit(off_t cu_offset, off_t cu_length, Dwarf_die* root_die);

  // Visit a type unit.
  virtual void
  visit_type_unit(off_t tu_offset, off_t type_offset, uint64_t signature,
		  Dwarf_die* root_die);

  // Read the range table.
  Dwarf_range_list*
  read_range_list(unsigned int ranges_shndx, off_t ranges_offset)
  {
    return this->ranges_table_.read_range_list(this->object_,
					       this->symtab_,
					       this->symtab_size_,
					       this->address_size_,
					       ranges_shndx,
					       ranges_offset);
  }

  // Return the object.
  Relobj*
  object() const
  { return this->object_; }

  // Checkpoint the relocation tracker.
  uint64_t
  get_reloc_checkpoint() const
  { return this->reloc_mapper_->checkpoint(); }

  // Reset the relocation tracker to the CHECKPOINT.
  void
  reset_relocs(uint64_t checkpoint)
  { this->reloc_mapper_->reset(checkpoint); }

 private:
  // Print a warning about a corrupt debug section.
  void
  warn_corrupt_debug_section() const;

  // Check that P is within the bounds of the current section.
  bool
  check_buffer(const unsigned char* p) const
  {
    if (p > this->buffer_ + this->cu_offset_ + this->cu_length_)
      {
	this->warn_corrupt_debug_section();
	return false;
      }
    return true;
  }

  // Read the DWARF string table.
  bool
  read_string_table(unsigned int string_shndx)
  {
    // If we've already read this string table, return immediately.
    if (this->string_shndx_ > 0 && this->string_shndx_ == string_shndx)
      return true;
    if (string_shndx == 0 && this->string_shndx_ > 0)
      return true;
    return this->do_read_string_table(string_shndx);
  }

  bool
  do_read_string_table(unsigned int string_shndx);

  // True if this is a type unit; false for a compilation unit.
  bool is_type_unit_;
  // The object containing the .debug_info or .debug_types input section.
  Relobj* object_;
  // The ELF symbol table.
  const unsigned char* symtab_;
  // The size of the ELF symbol table.
  off_t symtab_size_;
  // Index of the .debug_info or .debug_types section.
  unsigned int shndx_;
  // Index of the relocation section.
  unsigned int reloc_shndx_;
  // Type of the relocation section (SHT_REL or SHT_RELA).
  unsigned int reloc_type_;
  // Index of the .debug_abbrev section (0 if not known).
  unsigned int abbrev_shndx_;
  // Index of the .debug_str section.
  unsigned int string_shndx_;
  // The buffer for the debug info.
  const unsigned char* buffer_;
  const unsigned char* buffer_end_;
  // Offset of the current compilation unit.
  off_t cu_offset_;
  // Length of the current compilation unit.
  off_t cu_length_;
  // Size of a DWARF offset for the current compilation unit.
  unsigned int offset_size_;
  // Size of an address for the target architecture.
  unsigned int address_size_;
  // Compilation unit version number.
  unsigned int cu_version_;
  // Abbreviations table for current compilation unit.
  Dwarf_abbrev_table abbrev_table_;
  // Ranges table for the current compilation unit.
  Dwarf_ranges_table ranges_table_;
  // Relocation mapper for the section.
  Elf_reloc_mapper* reloc_mapper_;
  // The buffer for the debug string table.
  const char* string_buffer_;
  const char* string_buffer_end_;
  // True if this object owns the buffer and needs to delete it.
  bool owns_string_buffer_;
  // For incremental update links, this will hold the offset of the
  // input .debug_str section within the output section.  Offsets read
  // from relocated data will be relative to the output section, and need
  // to be corrected before reading data from the input section.
  uint64_t string_output_section_offset_;
};

// We can't do better than to keep the offsets in a sorted vector.
// Here, offset is the key, and file_num/line_num is the value.
struct Offset_to_lineno_entry
{
  off_t offset;
  int header_num;  // which file-list to use (i.e. which .o file are we in)
  // A pointer into files_.
  unsigned int file_num : sizeof(int) * CHAR_BIT - 1;
  // True if this was the last entry for the current offset, meaning
  // it's the line that actually applies.
  unsigned int last_line_for_offset : 1;
  // The line number in the source file.  -1 to indicate end-of-function.
  int line_num;

  // This sorts by offsets first, and then puts the correct line to
  // report for a given offset at the beginning of the run of equal
  // offsets (so that asking for 1 line gives the best answer).  This
  // is not a total ordering.
  bool operator<(const Offset_to_lineno_entry& that) const
  {
    if (this->offset != that.offset)
      return this->offset < that.offset;
    // Note the '>' which makes this sort 'true' first.
    return this->last_line_for_offset > that.last_line_for_offset;
  }
};

// This class is used to read the line information from the debugging
// section of an object file.

class Dwarf_line_info
{
 public:
  Dwarf_line_info()
  { }

  virtual
  ~Dwarf_line_info()
  { }

  // Given a section number and an offset, returns the associated
  // file and line-number, as a string: "file:lineno".  If unable
  // to do the mapping, returns the empty string.  You must call
  // read_line_mappings() before calling this function.  If
  // 'other_lines' is non-NULL, fills that in with other line
  // numbers assigned to the same offset.
  std::string
  addr2line(unsigned int shndx, off_t offset,
            std::vector<std::string>* other_lines)
  { return this->do_addr2line(shndx, offset, other_lines); }

  // A helper function for a single addr2line lookup.  It also keeps a
  // cache of the last CACHE_SIZE Dwarf_line_info objects it created;
  // set to 0 not to cache at all.  The larger CACHE_SIZE is, the more
  // chance this routine won't have to re-create a Dwarf_line_info
  // object for its addr2line computation; such creations are slow.
  // NOTE: Not thread-safe, so only call from one thread at a time.
  static std::string
  one_addr2line(Object* object, unsigned int shndx, off_t offset,
                size_t cache_size, std::vector<std::string>* other_lines);

  // This reclaims all the memory that one_addr2line may have cached.
  // Use this when you know you will not be calling one_addr2line again.
  static void
  clear_addr2line_cache();

 private:
  virtual std::string
  do_addr2line(unsigned int shndx, off_t offset,
               std::vector<std::string>* other_lines) = 0;
};

template<int size, bool big_endian>
class Sized_dwarf_line_info : public Dwarf_line_info
{
 public:
  // Initializes a .debug_line reader for a given object file.
  // If SHNDX is specified and non-negative, only read the debug
  // information that pertains to the specified section.
  Sized_dwarf_line_info(Object* object, unsigned int read_shndx = -1U);

  virtual
  ~Sized_dwarf_line_info()
  {
    if (this->buffer_start_ != NULL)
      delete[] this->buffer_start_;
  }

 private:
  std::string
  do_addr2line(unsigned int shndx, off_t offset,
               std::vector<std::string>* other_lines);

  // Formats a file and line number to a string like "dirname/filename:lineno".
  std::string
  format_file_lineno(const Offset_to_lineno_entry& lineno) const;

  // Start processing line info, and populates the offset_map_.
  // If SHNDX is non-negative, only store debug information that
  // pertains to the specified section.
  void
  read_line_mappings(unsigned int shndx);

  // Reads the relocation section associated with .debug_line and
  // stores relocation information in reloc_map_.
  void
  read_relocs();

  // Reads the DWARF2/3 header for this line info.  Each takes as input
  // a starting buffer position, and returns the ending position.
  const unsigned char*
  read_header_prolog(const unsigned char* lineptr);

  const unsigned char*
  read_header_tables(const unsigned char* lineptr);

  // Reads the DWARF2/3 line information.  If shndx is non-negative,
  // discard all line information that doesn't pertain to the given
  // section.
  const unsigned char*
  read_lines(const unsigned char* lineptr, unsigned int shndx);

  // Process a single line info opcode at START using the state
  // machine at LSM.  Return true if we should define a line using the
  // current state of the line state machine.  Place the length of the
  // opcode in LEN.
  bool
  process_one_opcode(const unsigned char* start,
                     struct LineStateMachine* lsm, size_t* len);

  // Some parts of processing differ depending on whether the input
  // was a .o file or not.
  bool input_is_relobj();

  // If we saw anything amiss while parsing, we set this to false.
  // Then addr2line will always fail (rather than return possibly-
  // corrupt data).
  bool data_valid_;

  // A DWARF2/3 line info header.  This is not the same size as in the
  // actual file, as the one in the file may have a 32 bit or 64 bit
  // lengths.

  struct Dwarf_line_infoHeader
  {
    off_t total_length;
    int version;
    off_t prologue_length;
    int min_insn_length; // insn stands for instructin
    bool default_is_stmt; // stmt stands for statement
    signed char line_base;
    int line_range;
    unsigned char opcode_base;
    std::vector<unsigned char> std_opcode_lengths;
    int offset_size;
  } header_;

  // buffer is the buffer for our line info, starting at exactly where
  // the line info to read is.
  const unsigned char* buffer_;
  const unsigned char* buffer_end_;
  // If the buffer was allocated temporarily, and therefore must be
  // deallocated in the dtor, this contains a pointer to the start
  // of the buffer.
  const unsigned char* buffer_start_;

  // This has relocations that point into buffer.
  Sized_elf_reloc_mapper<size, big_endian>* reloc_mapper_;
  // The type of the reloc section in track_relocs_--SHT_REL or SHT_RELA.
  unsigned int track_relocs_type_;

  // This is used to figure out what section to apply a relocation to.
  const unsigned char* symtab_buffer_;
  section_size_type symtab_buffer_size_;

  // Holds the directories and files as we see them.  We have an array
  // of directory-lists, one for each .o file we're reading (usually
  // there will just be one, but there may be more if input is a .so).
  std::vector<std::vector<std::string> > directories_;
  // The first part is an index into directories_, the second the filename.
  std::vector<std::vector< std::pair<int, std::string> > > files_;

  // An index into the current directories_ and files_ vectors.
  int current_header_index_;

  // A sorted map from offset of the relocation target to the shndx
  // and addend for the relocation.
  typedef std::map<off_t, std::pair<unsigned int, off_t> >
  Reloc_map;
  Reloc_map reloc_map_;

  // We have a vector of offset->lineno entries for every input section.
  typedef Unordered_map<unsigned int, std::vector<Offset_to_lineno_entry> >
  Lineno_map;

  Lineno_map line_number_map_;
};

} // End namespace gold.

#endif // !defined(GOLD_DWARF_READER_H)
@


1.30
log
@gold/
	Revert support for v2 DWP files:

	2013-03-01  Cary Coutant  <ccoutant@@google.com>

	    Add dwp support for v2 DWARF package file format.
	    * dwarf_reader.cc (Dwarf_info_reader::visit_type_unit): Add
	    tu_length parameter.  Adjust all callers.
	    * dwarf_reader.h (Dwarf_info_reader::visit_type_unit): Likewise.
	    * dwp.cc: Include dwarf.h.
	    (Section_bounds): New struct type.
	    (Unit_set): New struct type.
	    (Dwo_file::Dwo_file): Initialize new data member.
	    (Dwo_file::read_compunit_index, Dwo_file::read_typeunit_index):
	    Combine and rename to...
	    (Dwo_file::read_unit_index): ...this.
	    (Dwo_file::sized_read_compunit_index)
	    (Dwo_file::sized_read_typeunit_index): Combine and rename to...
	    (Dwo_file::sized_read_unit_index): ...this.
	    (Dwo_file::copy_section): Remove section_name, is_str_offsets
	    parameters; add section_id parameter.
	    (Dwo_file::add_cu_set, Dwo_file::add_tu_set): Combine and rename to...
	    (Dwo_file::add_unit_set): ...this.
	    (Dwo_file::shndx_map_): Remove.
	    (Dwo_file::sect_offsets_): New data member.
	    (Dwp_output_file::Dwp_output_file): Initialize new data members.
	    (Dwp_output_file::add_section): Rename to...
	    (Dwp_output_file::add_contribution): ...this.
	    (Dwp_output_file::add_cu_set): Combine parameters into a struct.
	    (Dwp_output_file::add_tu_set): Likewise.
	    (Dwp_output_file::Contribution): New type.
	    (Dwp_output_file::Section::contributions): New data member.
	    (Dwp_output_file::Cu_or_tu_set): Remove.
	    (Dwp_output_file::Section::Section): New ctor.
	    (Dwp_output_file::Dwp_index::Shndx_pool): Remove.
	    (Dwp_output_file::Dwp_index::Section_table): New type.
	    (Dwp_output_file::Dwp_index::Dwp_index): Initialize new data members.
	    (Dwp_output_file::Dwp_index::enter_set): Change type of "set"
	    parameter.
	    (Dwp_output_file::Dwp_index::shndx_pool): Remove.
	    (Dwp_output_file::Dwp_index::shndx_pool_end): Remove.
	    (Dwp_output_file::Dwp_index::section_table): New member function.
	    (Dwp_output_file::Dwp_index::section_table_end): New member function.
	    (Dwp_output_file::Dwp_index::shndx_pool_size): Remove.
	    (Dwp_output_file::Dwp_index::section_table_rows): New member function.
	    (Dwp_output_file::Dwp_index::section_table_cols): New member function.
	    (Dwp_output_file::Dwp_index::shndx_pool_): Remove.
	    (Dwp_output_file::Dwp_index::section_table_): New data member.
	    (Dwp_output_file::Dwp_index::section_mask_): New data member.
	    (Dwp_output_file::add_output_section): New member function.
	    (Dwp_output_file::write_new_section): New member function.
	    (Dwp_output_file::write_contributions): New member function.
	    (Dwp_output_file::section_id_map_): New data member.
	    (class Dwo_id_info_reader): Remove.
	    (class Unit_reader): New class.
	    (get_dwarf_section_name): New function.
	    (Dwo_file::read_executable): Adjust initializations of class data.
	    (Dwo_file::read): Add support for v2 package file format.
	    (Dwo_file::read_unit_index): Likewise.
	    (Dwo_file::sized_read_unit_index): Likewise.
	    (Dwo_file::copy_section): Likewise.
	    (Dwo_file::add_unit_set): Likewise.
	    (Dwp_output_file::add_output_section): Likewise.
	    (Dwp_output_file::add_contribution): Likewise.
	    (Dwp_output_file::Dwp_index::find_or_add): Use row index to check
	    for empty slot.
	    (Dwp_output_file::Dwp_index::enter_set): Add support for v2 package
	    file format.
	    (Dwp_output_file::Dwp_index::grow): Use row index to check for empty
	    slot.
	    (Dwp_output_file::initialize): Remove unused function.
	    (Dwp_output_file::finalize): Add support for v2 package file format.
	    (Dwp_output_file::write_index): Likewise.
	    * gdb-index.cc (Gdb_index_info_reader::visit_type_unit): Adjust
	    function prototype.
@
text
@d3 2
a4 1
// Copyright 2007, 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
d701 2
a702 2
      offset_size_(0), address_size_(0), cu_version_(0), type_signature_(0),
      type_offset_(0), abbrev_table_(), ranges_table_(this),
a898 4
  // Type signature (for a type unit).
  uint64_t type_signature_;
  // Offset from the type unit header to the type DIE (for a type unit).
  off_t type_offset_;
@


1.30.2.1
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@d3 1
a3 2
// Copyright 2007, 2008, 2009, 2010, 2011, 2012, 2013
// Free Software Foundation, Inc.
d700 2
a701 2
      offset_size_(0), address_size_(0), cu_version_(0),
      abbrev_table_(), ranges_table_(this),
d898 4
@


1.29
log
@2013-07-22  Sterling Augustine  <saugustine@@google.com>

	* dwarf_reader.cc (Dwarf_pubnames_table::read_section):
	Convert parameter shndx to local variable. Add parameters symtab
	and symtab_size.  Scan over section names.  Find relocation
	section corresponding to current section.  Create and initialize
	reloc_mapper_ and reloc_type_.
	(Dwarf_pubnames_table::read_header):  Add assertion.  Change
	unit_length to off_t.  Initialize member unit_length_.  Fill in field
	cu_offset_.
	* dwarf_reader.h (Dwarf_pubnames_table::Dwarf_pubnames_table):
	Initialize new fields unit_length_ and cu_offset_.
	(Dwarf_pubnames_table::read_section): Update prototype.
	(Dwarf_pubnames_table::cu_offset): New member function.
	(Dwarf_pubnames_table::subsection_size): Likewise.
	(Dwarf_pubnames_table::cu_offset_, Dwarf_pubnames_table::unit_length):
	New fields.
	(Dwarf_info_reader::symtab, Dwarf_info_reader::symtab_size): Make
	member functions public.
	* gdb_index.cc (Gdb_index_info_reader::read_pubnames_and_pubtypes):
	Update comment.  Rework logic.  Move repeated parts to...
	(Gdb_index_info_reader::read_pubtable): ...here. New function.
	(Gdb_index::Gdb_index): Initialize new fields, pubnames_table_,
	pubtypes_table_, and stmt_list_offset.
	(Gdb_index::map_pubtable_to_dies, Gdb_index::find_pubname_offset,
	Gdb_index::find_pubtype_offset,
	Gdb_index::map_pubnames_and_types_to_dies): Define new functions.
	(Gdb_index::pubnames_read): Update prototype and rework logic.
	* gdb_index.h (Gdb_index_info_reader, Dwarf_pubnames_table):
	Forward declare.
	(Gdb_index::map_pubtable_to_dies, Gdb_index::find_pubname_offset,
	Gdb_index::find_pubtype_offset, Gdb_index::pubnames_table)
	Gdb_index::pubtypes_table, Gdb_index::map_pubnames_and_types_to_dies,
	Gdb_index::map_pubtable_to_dies):
	Declare functions.
	(Gdb_index::pubnames_read): Update declaration.
	(Gdb_index::Pubname_offset_map): New type.
	(Gdb_index::cu_pubname_map_, Gdb_index::cu_pubtype_map_,
	Gdb_index::pubnames_table_, Gdb_index::pubtypes_table_,
	Gdb_index::stmt_list_offset): Declare.
	(Gdb_index::pubnames_shndx_, Gdb_index::pubnames_offet_,
	Gdb_index::pubtypes_object_, Gdb_index::pubtypes_shndx_)
	Gdb_index::pubtypes_offset_): Remove.
@
text
@d805 2
a806 2
  visit_type_unit(off_t tu_offset, off_t tu_length, off_t type_offset,
		  uint64_t signature, Dwarf_die* root_die);
@


1.28
log
@gold/
	* dwarf_reader.cc (Dwarf_ranges_table::read_ranges_table): Save
	reloc_type_.
	(Dwarf_ranges_table::read_range_list): Call lookup_reloc.
	(Dwarf_ranges_table::lookup_reloc): New function.
	* dwarf_reader.h (Dwarf_ranges_table::Dwarf_ranges_table): Initialize
	reloc_type_.
	(Dwarf_ranges_table::lookup_reloc): New function.
	(Dwarf_ranges_table::reloc_type_): New data member.
@
text
@d403 1
a403 1
      output_section_offset_(0)
d412 2
a413 1
  // Read the pubnames section SHNDX from the object file.
d415 2
a416 1
  read_section(Relobj* object, unsigned int shndx);
d422 11
d456 9
d772 15
a824 10
  // Return a pointer to the object file's ELF symbol table.
  const unsigned char*
  symtab() const
  { return this->symtab_; }

  // Return the size of the object file's ELF symbol table.
  off_t
  symtab_size() const
  { return this->symtab_size_; }

@


1.27
log
@Add dwp support for v2 DWARF package file format.

gold/
	* dwarf_reader.cc (Dwarf_info_reader::visit_type_unit): Add
	tu_length parameter.  Adjust all callers.
	* dwarf_reader.h (Dwarf_info_reader::visit_type_unit): Likewise.
	* dwp.cc: Include dwarf.h.
	(Section_bounds): New struct type.
	(Unit_set): New struct type.
	(Dwo_file::Dwo_file): Initialize new data member.
	(Dwo_file::read_compunit_index, Dwo_file::read_typeunit_index):
	Combine and rename to...
	(Dwo_file::read_unit_index): ...this.
	(Dwo_file::sized_read_compunit_index)
	(Dwo_file::sized_read_typeunit_index): Combine and rename to...
	(Dwo_file::sized_read_unit_index): ...this.
	(Dwo_file::copy_section): Remove section_name, is_str_offsets
	parameters; add section_id parameter.
	(Dwo_file::add_cu_set, Dwo_file::add_tu_set): Combine and rename to...
	(Dwo_file::add_unit_set): ...this.
	(Dwo_file::shndx_map_): Remove.
	(Dwo_file::sect_offsets_): New data member.
	(Dwp_output_file::Dwp_output_file): Initialize new data members.
	(Dwp_output_file::add_section): Rename to...
	(Dwp_output_file::add_contribution): ...this.
	(Dwp_output_file::add_cu_set): Combine parameters into a struct.
	(Dwp_output_file::add_tu_set): Likewise.
	(Dwp_output_file::Contribution): New type.
	(Dwp_output_file::Section::contributions): New data member.
	(Dwp_output_file::Cu_or_tu_set): Remove.
	(Dwp_output_file::Section::Section): New ctor.
	(Dwp_output_file::Dwp_index::Shndx_pool): Remove.
	(Dwp_output_file::Dwp_index::Section_table): New type.
	(Dwp_output_file::Dwp_index::Dwp_index): Initialize new data members.
	(Dwp_output_file::Dwp_index::enter_set): Change type of "set"
	parameter.
	(Dwp_output_file::Dwp_index::shndx_pool): Remove.
	(Dwp_output_file::Dwp_index::shndx_pool_end): Remove.
	(Dwp_output_file::Dwp_index::section_table): New member function.
	(Dwp_output_file::Dwp_index::section_table_end): New member function.
	(Dwp_output_file::Dwp_index::shndx_pool_size): Remove.
	(Dwp_output_file::Dwp_index::section_table_rows): New member function.
	(Dwp_output_file::Dwp_index::section_table_cols): New member function.
	(Dwp_output_file::Dwp_index::shndx_pool_): Remove.
	(Dwp_output_file::Dwp_index::section_table_): New data member.
	(Dwp_output_file::Dwp_index::section_mask_): New data member.
	(Dwp_output_file::add_output_section): New member function.
	(Dwp_output_file::write_new_section): New member function.
	(Dwp_output_file::write_contributions): New member function.
	(Dwp_output_file::section_id_map_): New data member.
	(class Dwo_id_info_reader): Remove.
	(class Unit_reader): New class.
	(get_dwarf_section_name): New function.
	(Dwo_file::read_executable): Adjust initializations of class data.
	(Dwo_file::read): Add support for v2 package file format.
	(Dwo_file::read_unit_index): Likewise.
	(Dwo_file::sized_read_unit_index): Likewise.
	(Dwo_file::copy_section): Likewise.
	(Dwo_file::add_unit_set): Likewise.
	(Dwp_output_file::add_output_section): Likewise.
	(Dwp_output_file::add_contribution): Likewise.
	(Dwp_output_file::Dwp_index::find_or_add): Use row index to check
	for empty slot.
	(Dwp_output_file::Dwp_index::enter_set): Add support for v2 package
	file format.
	(Dwp_output_file::Dwp_index::grow): Use row index to check for empty
	slot.
	(Dwp_output_file::initialize): Remove unused function.
	(Dwp_output_file::finalize): Add support for v2 package file format.
	(Dwp_output_file::write_index): Likewise.
	* gdb-index.cc (Gdb_index_info_reader::visit_type_unit): Adjust
	function prototype.
@
text
@d341 1
a341 1
      ranges_reloc_mapper_(NULL), output_section_offset_(0)
d368 5
d385 2
@


1.26
log
@gold/
	* dwarf_reader.cc (Dwarf_info_reader::check_buffer): Move
	function into class definition in header file.
	(Dwarf_info_reader::warn_corrupt_debug_section): New function.
	* dwarf_reader.h (Dwarf_info_reader::warn_corrupt_debug_section):
	New function.
	(Dwarf_info_reader::check_buffer): Move here from .cc file.
@
text
@d761 2
a762 2
  visit_type_unit(off_t tu_offset, off_t type_offset, uint64_t signature,
		  Dwarf_die* root_die);
@


1.25
log
@gold/
	* dwarf_reader.cc (Dwarf_ranges_table::read_range_list): Call
	Dwarf_info_reader::read_from_pointer.
	(Dwarf_pubnames_table::read_header): Likewise.
	(Dwarf_pubnames_table::next_name): Likewise.
	(Dwarf_die::read_attributes): Likewise.
	(Dwarf_die::skip_attributes): Likewise.
	(Dwarf_info_reader::read_from_pointer): New function template.
	* dwarf_reader.h (Dwarf_ranges_table): Add dwinfo_.
	(Dwarf_pubnames_table): Likewise.
	(Dwarf_info_reader::read_from_pointer): New function template.
	* gdb-index.cc (Gdb_index_info_reader): Adjust call to
	Dwarf_pubnames_table ctor.
@
text
@d802 4
d808 9
a816 1
  check_buffer(const unsigned char* p) const;
@


1.24
log
@gold/
	* dwarf_reader.cc (Dwarf_info_reader::do_parse): Use stored
	abbrev_shndx.
	* dwarf_reader.h (Dwarf_info_reader::Dwarf_info_reader): Initialize
	abbrev_shndx_.
	(Dwarf_info_reader::set_abbrev_shndx): New method.
	(Dwarf_info_reader::abbrev_shndx_): New data member.
@
text
@d338 4
a341 4
  Dwarf_ranges_table()
    : ranges_shndx_(0), ranges_buffer_(NULL), ranges_buffer_end_(NULL),
      owns_ranges_buffer_(false), ranges_reloc_mapper_(NULL),
      output_section_offset_(0)
d369 2
d393 2
a394 2
  Dwarf_pubnames_table(bool is_pubtypes)
    : buffer_(NULL), buffer_end_(NULL), owns_buffer_(false),
d418 2
d672 2
a673 2
      type_offset_(0), abbrev_table_(), reloc_mapper_(NULL),
      string_buffer_(NULL), string_buffer_end_(NULL),
d707 10
@


1.23
log
@gold: Handle DW_AT_high_pc as offset from DW_AT_low_pc in gdb-index.cc.

        * dwarf_reader.cc (Dwarf_die::address_attribute): New function.
        * dwarf_reader.h (Dwarf_die::address_attribute): Likewise.
        * gdb-index.cc (Gdb_index_info_reader::record_cu_ranges): Handle
        DW_AT_high_pc as offset from DW_AT_low_pc.

        * testsuite/Makefile.am (gdb_index_test_3.sh): New test case.
        * testsuite/Makefile.in: Regenerate.
        * testsuite/gdb_index_test_3.c: New test source file.
        * testsuite/gdb_index_test_3.sh: New test source file.
@
text
@d665 6
a670 6
      reloc_type_(reloc_type), string_shndx_(0), buffer_(NULL),
      buffer_end_(NULL), cu_offset_(0), cu_length_(0), offset_size_(0),
      address_size_(0), cu_version_(0), type_signature_(0), type_offset_(0),
      abbrev_table_(), reloc_mapper_(NULL), string_buffer_(NULL),
      string_buffer_end_(NULL), owns_string_buffer_(false),
      string_output_section_offset_(0)
d722 7
d821 2
@


1.22
log
@2012-03-21  Cary Coutant  <ccoutant@@google.com>

	* Makefile.am: Add gdb-index.cc, gdb-index.h.
	* Makefile.in: Regenerate.
	* dwarf_reader.cc (Sized_elf_reloc_mapper::do_initialize): New function.
	(Sized_elf_reloc_mapper::symbol_section): New function.
	(Sized_elf_reloc_mapper::do_get_reloc_target): New function.
	(make_elf_reloc_mapper): New function.
	(Dwarf_abbrev_table::clear_abbrev_codes): New function.
	(Dwarf_abbrev_table::do_read_abbrevs): New function.
	(Dwarf_abbrev_table::do_get_abbrev): New function.
	(Dwarf_ranges_table::read_ranges_table): New function.
	(Dwarf_ranges_table::read_range_list): New function.
	(Dwarf_pubnames_table::read_section): New function.
	(Dwarf_pubnames_table::read_header): New function.
	(Dwarf_pubnames_table::next_name): New function.
	(Dwarf_die::Dwarf_die): New function.
	(Dwarf_die::read_attributes): New function.
	(Dwarf_die::skip_attributes): New function.
	(Dwarf_die::set_name): New function.
	(Dwarf_die::set_linkage_name): New function.
	(Dwarf_die::attribute): New function.
	(Dwarf_die::string_attribute): New function.
	(Dwarf_die::int_attribute): New function.
	(Dwarf_die::uint_attribute): New function.
	(Dwarf_die::ref_attribute): New function.
	(Dwarf_die::child_offset): New function.
	(Dwarf_die::sibling_offset): New function.
	(Dwarf_info_reader::check_buffer): New function.
	(Dwarf_info_reader::parse): New function.
	(Dwarf_info_reader::do_parse): New function.
	(Dwarf_info_reader::do_read_string_table): New function.
	(Dwarf_info_reader::lookup_reloc): New function.
	(Dwarf_info_reader::get_string): New function.
	(Dwarf_info_reader::visit_compilation_unit): New function.
	(Dwarf_info_reader::visit_type_unit): New function.
	(Sized_dwarf_line_info::Sized_dwarf_line_info): Use
	Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::symbol_section): Remove function.
	(Sized_dwarf_line_info::read_relocs): Use Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::read_line_mappings): Remove object
	parameter, adjust callers.
	(Sized_dwarf_line_info::format_file_lineno): Fix type of cast.
	* dwarf_reader.h: Include <sys/types.h>.
	(class Track_relocs): Remove forward declaration.
	(class Elf_reloc_mapper): New class.
	(class Sized_elf_reloc_mapper): New class.
	(class Dwarf_abbrev_table): New class.
	(class Dwarf_range_list): New class.
	(class Dwarf_ranges_table): New class.
	(class Dwarf_pubnames_table): New class.
	(class Dwarf_die): New class.
	(class Dwarf_info_reader): New class.
	(Sized_dwarf_line_info::read_line_mappings): Remove object parameter.
	(Sized_dwarf_line_info::symbol_section): Remove member function.
	* dynobj.h (Sized_dynobj::do_section_contents): Refactor code from
	base class.
	* gdb-index.cc: New source file.
	* gdb-index.h: New source file.
	* incremental.cc (Sized_relobj_incr::do_layout): Track .debug_info
	and .debug_types sections, call Layout::add_to_gdb_index.
	(Sized_relobj_incr::do_section_name): Implement.
	(Sized_relobj_incr::do_section_contents): Adjust parameter list and
	return type; Implement.
	(Sized_incr_dynobj::do_section_contents): Adjust parameter list and
	return type.
	* incremental.h (Sized_relobj_incr::do_section_contents): Adjust
	parameter list and return type.
	(Sized_incr_dynobj::do_section_contents): Likewise.
	* layout.cc: Include gdb-index.h.
	(Layout::Layout): Initialize gdb_index_data_.
	(Layout::init_fixed_output_section): Check for .gdb_index section.
	(Layout::add_to_gdb_index): New function. Instantiate.
	* layout.h: Add forward declaration for class Gdb_index.
	(Layout::add_to_gdb_index): New member function.
	(Layout::gdb_index_data_): New data member.
	* main.cc: Include gdb-index.h.
	(main): Print statistics for gdb index.
	* object.cc (Object::section_contents): Move code into
	do_section_contents.
	(need_decompressed_section): Check for sections needed when building
	gdb index.
	(build_compressed_section_map): Likewise.
	(Sized_relobj_file::do_read_symbols): Need local symbols when building
	gdb index.
	(Sized_relobj_file::do_layout): Track .debug_info and .debug_types
	sections; call Layout::add_to_gdb_index.
	(Sized_relobj_file::do_decompressed_section_contents): Call
	do_section_contents directly.
	* object.h (Object::do_section_contents): Adjust parameter list and
	return type.
	(Object::do_decompressed_section_contents): Call do_section_contents
	directly.
	(Sized_relobj_file::do_section_contents): Adjust parameter list and
	return type.
	* options.h (class General_options): Add --gdb-index option.
	* plugin.cc (Sized_pluginobj::do_section_contents): Adjust parameter
	list and return type.
	* plugin.h (Sized_pluginobj::do_section_contents): Likewise.
	* reloc.h (Track_relocs::checkpoint): New function.
	(Track_relocs::reset): New function.

	* testsuite/Makefile.am (gdb_index_test_1.sh, gdb_index_test_2.sh):
	New test cases.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/gdb_index_test.cc: New test source file.
	* testsuite/gdb_index_test_1.sh: New test source file.
	* testsuite/gdb_index_test_2.sh: New test source file.
@
text
@d550 5
a554 2
  ref_attribute(unsigned int attr,
		unsigned int* shndx);
@


1.21
log
@	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Call Object::decompressed_section_contents.
	* dwarf_reader.h (Sized_dwarf_line_info::~Sized_dwarf_line_info):
	New dtor.
	(Sized_dwarf_line_info::buffer_start_): New data member.
	* merge.cc (Output_merge_data::do_add_input_section): Call
	Object::decompressed_section_contents.
	(Output_merge_string::do_add_input_section): Likewise.
	* object.cc (need_decompressed_section): New function.
	(build_compressed_section_map): Decompress sections needed later.
	(Sized_relobj_file::do_decompressed_section_contents): New function.
	(Sized_relobj_file::do_discard_decompressed_sections): New function.
	* object.h (Object::decompressed_section_contents): New function.
	(Object::discard_decompressed_sections): New function.
	(Object::do_decompressed_section_contents): New function.
	(Object::do_discard_decompressed_sections): New function.
	(Compressed_section_info): New type.
	(Compressed_section_map): Include decompressed section contents.
	(Sized_relobj_file::do_decompressed_section_contents): New function.
	(Sized_relobj_file::do_discard_decompressed_sections): New function.
@
text
@d3 1
a3 1
// Copyright 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d29 1
d39 71
d111 736
a846 2
class Track_relocs;
struct LineStateMachine;
d949 1
a949 1
  read_line_mappings(Object*, unsigned int shndx);
d954 1
a954 7
  read_relocs(Object*);

  // Looks in the symtab to see what section a symbol is in.
  unsigned int
  symbol_section(Object*, unsigned int sym,
                 typename elfcpp::Elf_types<size>::Elf_Addr* value,
		 bool* is_ordinary);
d1015 1
a1015 1
  Track_relocs<size, big_endian> track_relocs_;
d1035 1
a1035 3
  typedef std::map<typename elfcpp::Elf_types<size>::Elf_Addr,
                   std::pair<unsigned int,
                             typename elfcpp::Elf_types<size>::Elf_Swxword> >
@


1.20
log
@	* dwarf_reader.cc (Sized_dwarf_line_info): Include all lines,
	but mark earlier ones as non-canonical
	(offset_to_iterator): Update search target and example
	(do_addr2line): Return extra lines in a vector*
	(format_file_lineno): Extract from do_addr2line
	(one_addr2line): Add vector* out-param
	* dwarf_reader.h (Offset_to_lineno_entry): New field recording
	when a lineno entry appeared last for its instruction
	(Dwarf_line_info): Add vector* out-param
	* object.cc (Relocate_info): Pass NULL for the vector* out-param
	* symtab.cc (Odr_violation_compare): Include the lineno in the
	comparison again.
	(linenos_from_loc): New. Combine the canonical line for an
	address with its other lines.
	(True_if_intersect): New. Helper functor to make
	std::set_intersection a query.
	(detect_odr_violations): Compare sets of lines instead of just
	one line for each function. This became less deterministic, but
	has fewer false positives.
	* symtab.h: Declarations.
	* testsuite/Makefile.am (odr_violation2.o): Compile with -O2 to
	mix an optimized and non-optimized object in the same binary
	(odr_violation2.so): Same.
	* testsuite/Makefile.in: Regenerate from Makefile.am.
	* testsuite/debug_msg.cc (main): Make OdrDerived classes.
	* testsuite/debug_msg.sh: Update line numbers and add
	assertions.
	* testsuite/odr_violation1.cc: Use OdrDerived, in a
	non-optimized context.
	* testsuite/odr_violation2.cc: Make sure Ordering::operator()
	isn't inlined, and use OdrDerived in an optimized context.
	* testsuite/odr_header1.h: Defines OdrDerived, where
	optimization will change the
	first-instruction-in-the-destructor's file and line number.
	* testsuite/odr_header2.h: Defines OdrBase.
@
text
@d123 7
d209 4
@


1.19
log
@	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Only keep
	second of two consecutive entries with same offset.
@
text
@d28 1
d48 12
a59 6
  int file_num;    // a pointer into files_
  int line_num;    // the line number in the source file

  // When we add entries to the table, we always use the last entry
  // with a given offset.  Given proper DWARF info, this should ensure
  // that the offset is a sufficient sort key.
d61 6
a66 1
  { return this->offset < that.offset; }
d85 3
a87 1
  // read_line_mappings() before calling this function.
d89 3
a91 2
  addr2line(unsigned int shndx, off_t offset)
  { return do_addr2line(shndx, offset); }
d101 1
a101 1
                size_t cache_size);
d110 2
a111 1
  do_addr2line(unsigned int shndx, off_t offset) = 0;
d125 6
a130 1
  do_addr2line(unsigned int shndx, off_t offset);
@


1.18
log
@	* dwarf_reader.h (class Sized_dwarf_line_info): Add
	track_relocs_type_ field.
	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Set track_relocs_type_.
	(Sized_dwarf_line_info::process_one_opcode): Ignore the section
	contents when using RELA relocs.
	(Sized_dwarf_line_info::read_relocs): Add the reloc addend to
	reloc_map_.
	* reloc.cc (Track_relocs::next_addend): New function.
	* reloc.h (class Track_relocs): Declare next_addend.
@
text
@d49 4
a52 1
  // Offsets are unique within a section, so that's a sufficient sort key.
@


1.17
log
@2009-12-08  Doug Kwan  <dougkwan@@google.com>

	* Makefile.am (CCFILES): Add attributes.cc and int_encoding.cc.
	(HFILES): Add attributes.h and int_encoding.h.
	* Makefile.in: Regenerate.
	* dwarf_reader.cc (read_unsigned_LEB_128, read_signed_LEB_128): Move
	function definitions to int_encoding.cc
	* dwarf_reader.h (read_unsigned_LEB_128, read_signed_LEB_128): Move
	prototypes to int_encoding.h
	* reduced_debug_output.cc (int_encoding.h): New include.
	(write_unsigned_LEB_128, get_length_as_unsigned_LEB_128): Move
	function definitions to int_encoding.cc
	(insert_into_vector, read_from_pointer): Move template definitions to
	int_encoding.h
	* attributes.cc: New file.
	* attributes.h: New file.
	* int_encoding.cc: New file.
	* int_encoding.h: New file.
@
text
@d3 1
a3 1
// Copyright 2007, 2008, 2009 Free Software Foundation, Inc.
d181 2
@


1.16
log
@	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Change read_shndx type to unsigned int.
	(Sized_dwarf_line_info::read_lines): Change shndx type to unsigned
	int.
	(Sized_dwarf_line_info::read_line_mappings): Likewise.
	* dwarf_reader.h (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Change read_shndx type to unsigned int.
	(Sized_dwarf_line_info::read_lines): Change shndx type to unsigned
	int.
	(Sized_dwarf_line_info::read_line_mappings): Likewise.
	* layout.cc (Layout::create_symtab_sections): Cast the result of
	local_symcount * symsize to off_t in the gold_assert.
@
text
@a40 6
uint64_t
read_unsigned_LEB_128(const unsigned char* buffer, size_t* len);

int64_t
read_signed_LEB_128(const unsigned char* buffer, size_t* len);

@


1.15
log
@elfcpp/:
	* dwarf.h (enum DW_FORM): Define.
gold/:
	* reduced_debug_output.cc: New file.
	* reduced_debug_output.h: New file.
	* options.h (class General_optoins): Add --strip-debug-non-line.
	* options.cc (General_options::finalize): Add strip_debug_non_line
	to the strip heirarchy.
	* layout.h (class Layout): Add debug_abbrev_ and debug_info_
	fields.
	* layout.cc: Include "reduced_debug_output.h".
	(Layout::Layout): Initialize new fields.
	(line_only_debug_sections): New static array.
	(is_lines_only_debug_sections): New static inline function.
	(Layout::include_section): Handle --strip-debug-non-line.
	(Layout::make_output_section): If --strip-debug-non-line, build
	new output sections for .debug_abbrev and .debug_info.
	* dwarf_reader.cc (read_unsigned_LEB_128): Move to namespace
	gold.  Warn about possible overflow.
	(read_signed_LEB_128): Likewise.
	* dwarf_reader.h: (read_unsigned_LEB_128): Declare.
	(read_signed_LEB_128): Declare.
	* Makefile.am (CCFILES): Add reduced_debug_output.cc.
	(HFILES): Add reduced_debug_output.h.
	* Makefile.in: Rebuild.
@
text
@d3 1
a3 1
// Copyright 2007, 2008 Free Software Foundation, Inc.
d108 1
a108 1
  Sized_dwarf_line_info(Object* object, off_t read_shndx = -1U);
d118 1
a118 1
  read_line_mappings(Object*, off_t shndx);
d143 1
a143 1
  read_lines(const unsigned char* lineptr, off_t shndx);
@


1.15.8.1
log
@Merge elfcpp and gold from trunk.
@
text
@d3 1
a3 1
// Copyright 2007, 2008, 2009 Free Software Foundation, Inc.
d108 1
a108 1
  Sized_dwarf_line_info(Object* object, unsigned int read_shndx = -1U);
d118 1
a118 1
  read_line_mappings(Object*, unsigned int shndx);
d143 1
a143 1
  read_lines(const unsigned char* lineptr, unsigned int shndx);
@


1.14
log
@	* dwarf_reader.cc (next_generation_count): New static var.
	(Addr2line_cache_entry): New struct.
	(addr2line_cache): New static var.
	(Dwarf_line_info::one_addr2line): Added caching.
	(Dwarf_line_info::clear_addr2line_cache): New function.
	* dwarf_reader.h (Dwarf_line_info::one_addr2line): Add
	cache-size parameter.
	(Dwarf_line_info::one_addr2line_cache): New function.
	* symtab.cc (Symbol_table::detect_odr_violations): Pass
	new cache-size argument to one_addr2line(), and clear cache.
@
text
@d41 6
@


1.13
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d75 6
a80 4
  // A helper function for a single addr2line lookup.  It uses
  // parameters() to figure out the size and endianness.  This is less
  // efficient than using the templatized size and endianness, so only
  // call this from an un-templatized context.
d82 7
a88 1
  one_addr2line(Object* object, unsigned int shndx, off_t offset);
@


1.12
log
@Update copyright years.  Update language files.
@
text
@d104 1
a104 1
  read_line_mappings(off_t shndx);
d109 1
a109 1
  read_relocs();
d113 3
a115 2
  symbol_section(unsigned int sym,
                 typename elfcpp::Elf_types<size>::Elf_Addr* value);
@


1.11
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d3 1
a3 1
// Copyright 2007 Free Software Foundation, Inc.
@


1.10
log
@From Craig Silverstein: Speed up ODR violation reporting.
@
text
@d175 1
a175 1
  off_t symtab_buffer_size_;
@


1.9
log
@From Craig Silverstein: Better handling of ODR violations which are
not in a function.
@
text
@d92 3
a94 1
  Sized_dwarf_line_info(Object* object);
d101 2
d104 1
a104 1
  read_line_mappings();
d124 3
a126 1
  // Reads the DWARF2/3 line information.
d128 1
a128 1
  read_lines(const unsigned char* lineptr);
@


1.8
log
@From Craig Silverstein: Clean up DWARF line reader code.
@
text
@d41 13
a188 12
  // We can't do better than to keep the offsets in a sorted vector.
  // Here, offset is the key, and file_num/line_num is the value.
  struct Offset_to_lineno_entry
  {
    off_t offset;
    int header_num;  // which file-list to use (i.e. which .o file are we in)
    int file_num;    // a pointer into files_
    int line_num;    // the line number in the source file
    // Offsets are unique within a section, so that's a sufficient sort key.
    bool operator<(const Offset_to_lineno_entry& that) const
    { return this->offset < that.offset; }
  };
@


1.7
log
@From Craig Silverstein: Rework debug info code a bit, add option for
ODR violations, add test case.
@
text
@d75 1
a75 1
class Sized_dwarf_line_info
a79 4

  std::string
  addr2line(unsigned int shndx, off_t offset)
  { return do_addr2line(shndx, offset); }
@


1.6
log
@From Craig Silverstein: Support debug info for shared libraries.
@
text
@a43 1
template<int size, bool big_endian>
d47 6
a52 2
  // Initializes a .debug_line reader for a given object file.
  Dwarf_line_info(Object* object);
d59 9
a67 1
  addr2line(unsigned int shndx, off_t offset);
d70 19
@


1.5
log
@From Craig Silverstein: Dwarf_line_info can work with Object rather
than Sized_relobj.
@
text
@d93 4
d130 1
a130 1
  const unsigned char* symtab_buffer_end_;
d132 4
a135 2
  // Holds the directories and files as we see them.
  std::vector<std::string> directories_;
d137 4
a140 1
  std::vector< std::pair<int, std::string> > files_;
d142 2
a143 2
  // A map from offset of the relocation target to the shndx and
  // addend for the relocation.
d155 1
d157 1
a157 1
    int line_num;
@


1.4
log
@From Craig Silverstein: rework DWARF reader code a bit.
@
text
@d49 1
a49 1
  Dwarf_line_info(Sized_relobj<size, big_endian>* object);
@


1.3
log
@From Craig Silverstein: Use relocations in reporting error message
locations.
@
text
@d32 1
d48 2
a49 19
  // Initializes a .debug_line reader. Buffer and buffer length point
  // to the beginning and length of the line information to read.
  // Reader is a ByteReader class that has the endianness set
  // properly.
  Dwarf_line_info(const unsigned char* buffer, off_t buffer_length,
		  Track_relocs<size, big_endian>* track_relocs,
                  const unsigned char* symtab_buffer,
                  off_t symtab_buffer_length)
    : data_valid_(true),
      buffer_(buffer), buffer_end_(buffer + buffer_length),
      track_relocs_(track_relocs),
      symtab_buffer_(symtab_buffer),
      symtab_buffer_end_(symtab_buffer + symtab_buffer_length),
      directories_(1), files_(1)
  { }

  // Start processing line info, and populates the offset_map_.
  void
  read_line_mappings();
d59 4
d119 1
a119 1
  const unsigned char* const buffer_end_;
d122 1
a122 1
  Track_relocs<size, big_endian>* track_relocs_;
d125 2
a126 2
  const unsigned char* const symtab_buffer_;
  const unsigned char* const symtab_buffer_end_;
@


1.2
log
@From Craig Silverstein: Templatize the Dwarf reader.
@
text
@d27 1
d29 1
d36 2
d51 9
a59 2
  Dwarf_line_info(const unsigned char* buffer, off_t buffer_length)
    : buffer_(buffer), buffer_end_(buffer + buffer_length),
d75 10
d105 5
d133 7
d144 8
@


1.1
log
@From Craig Silverstein: Add first version of generating error messages
with file name and line number.
@
text
@d39 1
a52 1
  template<int size, bool big_endian>
d54 1
a54 12
  read_line_mappings()
  {
    while (buffer_ < buffer_end_)
      {
        const unsigned char* lineptr = buffer_;
        lineptr = this->read_header_prolog<size, big_endian>(lineptr);
        lineptr = this->read_header_tables(lineptr);
        lineptr = this->read_lines(size, big_endian, lineptr);
        buffer_ = lineptr;
      }
    finalize_line_number_map();
  }
a65 1
  template<int size, bool big_endian>
d74 1
a74 1
  read_lines(int size, bool big_endian, const unsigned char* lineptr);
d81 1
a81 2
  process_one_opcode(int size, bool big_endian,
                     const unsigned char* start,
a82 5

  // Called after all line number have been read, to ready
  // line_number_map_ for calls to addr2line().
  void
  finalize_line_number_map();
@

