head	1.76;
access;
symbols
	binutils-2_24-branch:1.75.0.2
	binutils-2_24-branchpoint:1.75
	binutils-2_21_1:1.52
	binutils-2_23_2:1.66.2.1
	binutils-2_23_1:1.66.2.1
	binutils-2_23:1.66
	binutils-2_23-branch:1.66.0.2
	binutils-2_23-branchpoint:1.66
	binutils-2_22_branch:1.62.0.4
	binutils-2_22:1.62
	binutils-2_22-branch:1.62.0.2
	binutils-2_22-branchpoint:1.62
	binutils-2_21:1.52
	binutils-2_21-branch:1.52.0.2
	binutils-2_21-branchpoint:1.52
	binutils-2_20_1:1.35.2.1
	binutils-2_20:1.35.2.1
	binutils-arc-20081103-branch:1.30.0.4
	binutils-arc-20081103-branchpoint:1.30
	binutils-2_20-branch:1.35.0.2
	binutils-2_20-branchpoint:1.35
	dje-cgen-play1-branch:1.34.0.2
	dje-cgen-play1-branchpoint:1.34
	arc-20081103-branch:1.30.0.2
	arc-20081103-branchpoint:1.30
	binutils-2_19_1:1.29
	binutils-2_19:1.29
	binutils-2_19-branch:1.29.0.2
	binutils-2_19-branchpoint:1.29
	binutils_latest_snapshot:1.76
	added-to-binutils:1.28;
locks; strict;
comment	@ * @;


1.76
date	2013.10.11.22.02.21;	author roland;	state Exp;
branches;
next	1.75;

1.75
date	2013.07.30.21.26.53;	author ccoutant;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2013.03.10.23.08.18;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2013.02.27.23.11.56;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2012.11.01.23.27.00;	author roland;	state Exp;
branches;
next	1.71;

1.71
date	2012.10.05.00.45.54;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2012.09.10.23.05.54;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2012.09.09.03.43.51;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2012.09.05.00.34.20;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2012.08.14.03.39.03;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2012.05.02.21.37.23;	author roland;	state Exp;
branches
	1.66.2.1;
next	1.65;

1.65
date	2012.04.26.00.07.21;	author ian;	state Exp;
branches;
next	1.64;

1.64
date	2012.03.19.23.54.07;	author dougkwan;	state Exp;
branches;
next	1.63;

1.63
date	2012.01.04.00.18.23;	author ccoutant;	state Exp;
branches;
next	1.62;

1.62
date	2011.07.08.22.48.08;	author ian;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.02.00.03.25;	author ian;	state Exp;
branches;
next	1.60;

1.60
date	2011.06.28.22.25.14;	author ian;	state Exp;
branches;
next	1.59;

1.59
date	2011.06.28.21.15.42;	author ian;	state Exp;
branches;
next	1.58;

1.58
date	2011.06.08.03.50.11;	author ccoutant;	state Exp;
branches;
next	1.57;

1.57
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.56;

1.56
date	2011.05.23.23.27.10;	author ccoutant;	state Exp;
branches;
next	1.55;

1.55
date	2011.04.22.22.39.55;	author ccoutant;	state Exp;
branches;
next	1.54;

1.54
date	2010.12.14.19.03.30;	author rwild;	state Exp;
branches;
next	1.53;

1.53
date	2010.11.09.07.56.10;	author dougkwan;	state Exp;
branches;
next	1.52;

1.52
date	2010.09.28.17.14.15;	author tmsriram;	state Exp;
branches;
next	1.51;

1.51
date	2010.08.19.22.50.15;	author ian;	state Exp;
branches;
next	1.50;

1.50
date	2010.08.12.22.15.00;	author ccoutant;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.25.00.37.40;	author dougkwan;	state Exp;
branches;
next	1.48;

1.48
date	2010.05.26.03.33.59;	author dougkwan;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.07.21.42.22;	author dougkwan;	state Exp;
branches;
next	1.46;

1.46
date	2010.03.11.01.10.53;	author ian;	state Exp;
branches;
next	1.45;

1.45
date	2010.02.13.02.04.21;	author tmsriram;	state Exp;
branches;
next	1.44;

1.44
date	2010.02.03.05.36.55;	author dougkwan;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.08.19.33.18;	author ian;	state Exp;
branches;
next	1.42;

1.42
date	2009.12.06.02.49.46;	author dougkwan;	state Exp;
branches;
next	1.41;

1.41
date	2009.12.03.23.13.55;	author dougkwan;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.30.18.49.59;	author dougkwan;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.29.05.16.23;	author ian;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.09.23.18.19;	author dougkwan;	state Exp;
branches;
next	1.37;

1.37
date	2009.10.06.22.58.27;	author ian;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.18.01.10.38;	author dougkwan;	state Exp;
branches;
next	1.35;

1.35
date	2009.08.18.23.49.29;	author dougkwan;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2009.06.22.06.51.53;	author ian;	state Exp;
branches;
next	1.33;

1.33
date	2009.06.05.21.32.56;	author dougkwan;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.24.00.31.29;	author ian;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	1.30;

1.30
date	2008.09.16.17.23.37;	author ian;	state Exp;
branches;
next	1.29;

1.29
date	2008.04.09.00.48.13;	author ian;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2008.02.26.22.10.32;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2008.02.06.08.13.50;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.20.21.21.24;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.14.16.53.25;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.14.08.03.41;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.14.07.52.21;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.23.05.05.48;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.16.22.38.35;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.23.05.31.48;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.21.07.20.01;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.21.05.31.19;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.06.00.02.36;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.01.16.51.25;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.30.23.52.50;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.03.18.26.11;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.20.20.40.49;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.29.19.58.17;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.27.22.53.42;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.26.21.50.25;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.18.22.29.20;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.04.23.10.59;	author iant;	state Exp;
branches;
next	;

1.75.2.1
date	2013.10.11.22.02.58;	author roland;	state Exp;
branches;
next	;

1.66.2.1
date	2012.11.07.17.34.23;	author roland;	state Exp;
branches;
next	;

1.35.2.1
date	2009.10.16.05.51.18;	author ian;	state Exp;
branches;
next	;


desc
@@


1.76
log
@gold/
	* target.h (Target::adjust_elf_header, Target::do_adjust_elf_header):
	Remove const from declaration.
	* target.cc (Sized_target::do_adjust_elf_header): Update definition.
	* sparc.cc (Target_sparc::do_adjust_elf_header): Likewise.
	* output.h (Output_file_header): Remove const from member target_
	and corresponding constructor argument.
	* output.cc (Output_file_header::Output_file_header): Update prototype.
	(Output_file_header::do_sized_write): Use this->target_ in place
	of parameters()->target().
@
text
@// target.h -- target support for gold   -*- C++ -*-

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

// The abstract class Target is the interface for target specific
// support.  It defines abstract methods which each target must
// implement.  Typically there will be one target per processor, but
// in some cases it may be necessary to have subclasses.

// For speed and consistency we want to use inline functions to handle
// relocation processing.  So besides implementations of the abstract
// methods, each target is expected to define a template
// specialization of the relocation functions.

#ifndef GOLD_TARGET_H
#define GOLD_TARGET_H

#include "elfcpp.h"
#include "options.h"
#include "parameters.h"
#include "debug.h"

namespace gold
{

class Object;
class Relobj;
template<int size, bool big_endian>
class Sized_relobj;
template<int size, bool big_endian>
class Sized_relobj_file;
class Relocatable_relocs;
template<int size, bool big_endian>
struct Relocate_info;
class Reloc_symbol_changes;
class Symbol;
template<int size>
class Sized_symbol;
class Symbol_table;
class Output_data;
class Output_data_got_base;
class Output_section;
class Input_objects;
class Task;
struct Symbol_location;

// The abstract class for target specific handling.

class Target
{
 public:
  virtual ~Target()
  { }

  // Return the bit size that this target implements.  This should
  // return 32 or 64.
  int
  get_size() const
  { return this->pti_->size; }

  // Return whether this target is big-endian.
  bool
  is_big_endian() const
  { return this->pti_->is_big_endian; }

  // Machine code to store in e_machine field of ELF header.
  elfcpp::EM
  machine_code() const
  { return this->pti_->machine_code; }

  // Processor specific flags to store in e_flags field of ELF header.
  elfcpp::Elf_Word
  processor_specific_flags() const
  { return this->processor_specific_flags_; }

  // Whether processor specific flags are set at least once.
  bool
  are_processor_specific_flags_set() const
  { return this->are_processor_specific_flags_set_; }

  // Whether this target has a specific make_symbol function.
  bool
  has_make_symbol() const
  { return this->pti_->has_make_symbol; }

  // Whether this target has a specific resolve function.
  bool
  has_resolve() const
  { return this->pti_->has_resolve; }

  // Whether this target has a specific code fill function.
  bool
  has_code_fill() const
  { return this->pti_->has_code_fill; }

  // Return the default name of the dynamic linker.
  const char*
  dynamic_linker() const
  { return this->pti_->dynamic_linker; }

  // Return the default address to use for the text segment.
  uint64_t
  default_text_segment_address() const
  { return this->pti_->default_text_segment_address; }

  // Return the ABI specified page size.
  uint64_t
  abi_pagesize() const
  {
    if (parameters->options().max_page_size() > 0)
      return parameters->options().max_page_size();
    else
      return this->pti_->abi_pagesize;
  }

  // Return the common page size used on actual systems.
  uint64_t
  common_pagesize() const
  {
    if (parameters->options().common_page_size() > 0)
      return std::min(parameters->options().common_page_size(),
		      this->abi_pagesize());
    else
      return std::min(this->pti_->common_pagesize,
		      this->abi_pagesize());
  }

  // Return whether PF_X segments must contain nothing but the contents of
  // SHF_EXECINSTR sections (no non-executable data, no headers).
  bool
  isolate_execinstr() const
  { return this->pti_->isolate_execinstr; }

  uint64_t
  rosegment_gap() const
  { return this->pti_->rosegment_gap; }

  // If we see some object files with .note.GNU-stack sections, and
  // some objects files without them, this returns whether we should
  // consider the object files without them to imply that the stack
  // should be executable.
  bool
  is_default_stack_executable() const
  { return this->pti_->is_default_stack_executable; }

  // Return a character which may appear as a prefix for a wrap
  // symbol.  If this character appears, we strip it when checking for
  // wrapping and add it back when forming the final symbol name.
  // This should be '\0' if not special prefix is required, which is
  // the normal case.
  char
  wrap_char() const
  { return this->pti_->wrap_char; }

  // Return the special section index which indicates a small common
  // symbol.  This will return SHN_UNDEF if there are no small common
  // symbols.
  elfcpp::Elf_Half
  small_common_shndx() const
  { return this->pti_->small_common_shndx; }

  // Return values to add to the section flags for the section holding
  // small common symbols.
  elfcpp::Elf_Xword
  small_common_section_flags() const
  {
    gold_assert(this->pti_->small_common_shndx != elfcpp::SHN_UNDEF);
    return this->pti_->small_common_section_flags;
  }

  // Return the special section index which indicates a large common
  // symbol.  This will return SHN_UNDEF if there are no large common
  // symbols.
  elfcpp::Elf_Half
  large_common_shndx() const
  { return this->pti_->large_common_shndx; }

  // Return values to add to the section flags for the section holding
  // large common symbols.
  elfcpp::Elf_Xword
  large_common_section_flags() const
  {
    gold_assert(this->pti_->large_common_shndx != elfcpp::SHN_UNDEF);
    return this->pti_->large_common_section_flags;
  }

  // This hook is called when an output section is created.
  void
  new_output_section(Output_section* os) const
  { this->do_new_output_section(os); }

  // This is called to tell the target to complete any sections it is
  // handling.  After this all sections must have their final size.
  void
  finalize_sections(Layout* layout, const Input_objects* input_objects,
		    Symbol_table* symtab)
  { return this->do_finalize_sections(layout, input_objects, symtab); }

  // Return the value to use for a global symbol which needs a special
  // value in the dynamic symbol table.  This will only be called if
  // the backend first calls symbol->set_needs_dynsym_value().
  uint64_t
  dynsym_value(const Symbol* sym) const
  { return this->do_dynsym_value(sym); }

  // Return a string to use to fill out a code section.  This is
  // basically one or more NOPS which must fill out the specified
  // length in bytes.
  std::string
  code_fill(section_size_type length) const
  { return this->do_code_fill(length); }

  // Return whether SYM is known to be defined by the ABI.  This is
  // used to avoid inappropriate warnings about undefined symbols.
  bool
  is_defined_by_abi(const Symbol* sym) const
  { return this->do_is_defined_by_abi(sym); }

  // Adjust the output file header before it is written out.  VIEW
  // points to the header in external form.  LEN is the length.
  void
  adjust_elf_header(unsigned char* view, int len)
  { return this->do_adjust_elf_header(view, len); }

  // Return address and size to plug into eh_frame FDEs associated with a PLT.
  void
  plt_fde_location(const Output_data* plt, unsigned char* oview,
		   uint64_t* address, off_t* len) const
  { return this->do_plt_fde_location(plt, oview, address, len); }

  // Return whether NAME is a local label name.  This is used to implement the
  // --discard-locals options.
  bool
  is_local_label_name(const char* name) const
  { return this->do_is_local_label_name(name); }

  // Get the symbol index to use for a target specific reloc.
  unsigned int
  reloc_symbol_index(void* arg, unsigned int type) const
  { return this->do_reloc_symbol_index(arg, type); }

  // Get the addend to use for a target specific reloc.
  uint64_t
  reloc_addend(void* arg, unsigned int type, uint64_t addend) const
  { return this->do_reloc_addend(arg, type, addend); }

  // Return the PLT address to use for a global symbol.
  uint64_t
  plt_address_for_global(const Symbol* sym) const
  { return this->do_plt_address_for_global(sym); }

  // Return the PLT address to use for a local symbol.
  uint64_t
  plt_address_for_local(const Relobj* object, unsigned int symndx) const
  { return this->do_plt_address_for_local(object, symndx); }

  // Return the offset to use for the GOT_INDX'th got entry which is
  // for a local tls symbol specified by OBJECT, SYMNDX.
  int64_t
  tls_offset_for_local(const Relobj* object,
		       unsigned int symndx,
		       unsigned int got_indx) const
  { return do_tls_offset_for_local(object, symndx, got_indx); }

  // Return the offset to use for the GOT_INDX'th got entry which is
  // for global tls symbol GSYM.
  int64_t
  tls_offset_for_global(Symbol* gsym, unsigned int got_indx) const
  { return do_tls_offset_for_global(gsym, got_indx); }

  // For targets that use function descriptors, if LOC is the location
  // of a function, modify it to point at the function entry location.
  void
  function_location(Symbol_location* loc) const
  { return do_function_location(loc); }

  // Return whether this target can use relocation types to determine
  // if a function's address is taken.
  bool
  can_check_for_function_pointers() const
  { return this->do_can_check_for_function_pointers(); }

  // Return whether a relocation to a merged section can be processed
  // to retrieve the contents.
  bool
  can_icf_inline_merge_sections () const
  { return this->pti_->can_icf_inline_merge_sections; }

  // Whether a section called SECTION_NAME may have function pointers to
  // sections not eligible for safe ICF folding.
  virtual bool
  section_may_have_icf_unsafe_pointers(const char* section_name) const
  { return this->do_section_may_have_icf_unsafe_pointers(section_name); }

  // Return the base to use for the PC value in an FDE when it is
  // encoded using DW_EH_PE_datarel.  This does not appear to be
  // documented anywhere, but it is target specific.  Any use of
  // DW_EH_PE_datarel in gcc requires defining a special macro
  // (ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX) to output the value.
  uint64_t
  ehframe_datarel_base() const
  { return this->do_ehframe_datarel_base(); }

  // Return true if a reference to SYM from a reloc of type R_TYPE
  // means that the current function may call an object compiled
  // without -fsplit-stack.  SYM is known to be defined in an object
  // compiled without -fsplit-stack.
  bool
  is_call_to_non_split(const Symbol* sym, unsigned int r_type) const
  { return this->do_is_call_to_non_split(sym, r_type); }

  // A function starts at OFFSET in section SHNDX in OBJECT.  That
  // function was compiled with -fsplit-stack, but it refers to a
  // function which was compiled without -fsplit-stack.  VIEW is a
  // modifiable view of the section; VIEW_SIZE is the size of the
  // view.  The target has to adjust the function so that it allocates
  // enough stack.
  void
  calls_non_split(Relobj* object, unsigned int shndx,
		  section_offset_type fnoffset, section_size_type fnsize,
		  unsigned char* view, section_size_type view_size,
		  std::string* from, std::string* to) const
  {
    this->do_calls_non_split(object, shndx, fnoffset, fnsize, view, view_size,
			     from, to);
  }

  // Make an ELF object.
  template<int size, bool big_endian>
  Object*
  make_elf_object(const std::string& name, Input_file* input_file,
		  off_t offset, const elfcpp::Ehdr<size, big_endian>& ehdr)
  { return this->do_make_elf_object(name, input_file, offset, ehdr); }

  // Make an output section.
  Output_section*
  make_output_section(const char* name, elfcpp::Elf_Word type,
		      elfcpp::Elf_Xword flags)
  { return this->do_make_output_section(name, type, flags); }

  // Return true if target wants to perform relaxation.
  bool
  may_relax() const
  {
    // Run the dummy relaxation pass twice if relaxation debugging is enabled.
    if (is_debugging_enabled(DEBUG_RELAXATION))
      return true;

     return this->do_may_relax();
  }

  // Perform a relaxation pass.  Return true if layout may be changed.
  bool
  relax(int pass, const Input_objects* input_objects, Symbol_table* symtab,
	Layout* layout, const Task* task)
  {
    // Run the dummy relaxation pass twice if relaxation debugging is enabled.
    if (is_debugging_enabled(DEBUG_RELAXATION))
      return pass < 2;

    return this->do_relax(pass, input_objects, symtab, layout, task);
  }

  // Return the target-specific name of attributes section.  This is
  // NULL if a target does not use attributes section or if it uses
  // the default section name ".gnu.attributes".
  const char*
  attributes_section() const
  { return this->pti_->attributes_section; }

  // Return the vendor name of vendor attributes.
  const char*
  attributes_vendor() const
  { return this->pti_->attributes_vendor; }

  // Whether a section called NAME is an attribute section.
  bool
  is_attributes_section(const char* name) const
  {
    return ((this->pti_->attributes_section != NULL
	     && strcmp(name, this->pti_->attributes_section) == 0)
	    || strcmp(name, ".gnu.attributes") == 0);
  }

  // Return a bit mask of argument types for attribute with TAG.
  int
  attribute_arg_type(int tag) const
  { return this->do_attribute_arg_type(tag); }

  // Return the attribute tag of the position NUM in the list of fixed
  // attributes.  Normally there is no reordering and
  // attributes_order(NUM) == NUM.
  int
  attributes_order(int num) const
  { return this->do_attributes_order(num); }

  // When a target is selected as the default target, we call this method,
  // which may be used for expensive, target-specific initialization.
  void
  select_as_default_target()
  { this->do_select_as_default_target(); }

  // Return the value to store in the EI_OSABI field in the ELF
  // header.
  elfcpp::ELFOSABI
  osabi() const
  { return this->osabi_; }

  // Set the value to store in the EI_OSABI field in the ELF header.
  void
  set_osabi(elfcpp::ELFOSABI osabi)
  { this->osabi_ = osabi; }

  // Define target-specific standard symbols.
  void
  define_standard_symbols(Symbol_table* symtab, Layout* layout)
  { this->do_define_standard_symbols(symtab, layout); }

  // Return the output section name to use given an input section
  // name, or NULL if no target specific name mapping is required.
  // Set *PLEN to the length of the name if returning non-NULL.
  const char*
  output_section_name(const Relobj* relobj,
		      const char* name,
		      size_t* plen) const
  { return this->do_output_section_name(relobj, name, plen); }

  // Add any special sections for this symbol to the gc work list.
  void
  gc_mark_symbol(Symbol_table* symtab, Symbol* sym) const
  { this->do_gc_mark_symbol(symtab, sym); }

  // Return the name of the entry point symbol.
  const char*
  entry_symbol_name() const
  { return this->pti_->entry_symbol_name; }

 protected:
  // This struct holds the constant information for a child class.  We
  // use a struct to avoid the overhead of virtual function calls for
  // simple information.
  struct Target_info
  {
    // Address size (32 or 64).
    int size;
    // Whether the target is big endian.
    bool is_big_endian;
    // The code to store in the e_machine field of the ELF header.
    elfcpp::EM machine_code;
    // Whether this target has a specific make_symbol function.
    bool has_make_symbol;
    // Whether this target has a specific resolve function.
    bool has_resolve;
    // Whether this target has a specific code fill function.
    bool has_code_fill;
    // Whether an object file with no .note.GNU-stack sections implies
    // that the stack should be executable.
    bool is_default_stack_executable;
    // Whether a relocation to a merged section can be processed to
    // retrieve the contents.
    bool can_icf_inline_merge_sections;
    // Prefix character to strip when checking for wrapping.
    char wrap_char;
    // The default dynamic linker name.
    const char* dynamic_linker;
    // The default text segment address.
    uint64_t default_text_segment_address;
    // The ABI specified page size.
    uint64_t abi_pagesize;
    // The common page size used by actual implementations.
    uint64_t common_pagesize;
    // Whether PF_X segments must contain nothing but the contents of
    // SHF_EXECINSTR sections (no non-executable data, no headers).
    bool isolate_execinstr;
    // If nonzero, distance from the text segment to the read-only segment.
    uint64_t rosegment_gap;
    // The special section index for small common symbols; SHN_UNDEF
    // if none.
    elfcpp::Elf_Half small_common_shndx;
    // The special section index for large common symbols; SHN_UNDEF
    // if none.
    elfcpp::Elf_Half large_common_shndx;
    // Section flags for small common section.
    elfcpp::Elf_Xword small_common_section_flags;
    // Section flags for large common section.
    elfcpp::Elf_Xword large_common_section_flags;
    // Name of attributes section if it is not ".gnu.attributes".
    const char* attributes_section;
    // Vendor name of vendor attributes.
    const char* attributes_vendor;
    // Name of the main entry point to the program.
    const char* entry_symbol_name;
  };

  Target(const Target_info* pti)
    : pti_(pti), processor_specific_flags_(0),
      are_processor_specific_flags_set_(false), osabi_(elfcpp::ELFOSABI_NONE)
  { }

  // Virtual function which may be implemented by the child class.
  virtual void
  do_new_output_section(Output_section*) const
  { }

  // Virtual function which may be implemented by the child class.
  virtual void
  do_finalize_sections(Layout*, const Input_objects*, Symbol_table*)
  { }

  // Virtual function which may be implemented by the child class.
  virtual uint64_t
  do_dynsym_value(const Symbol*) const
  { gold_unreachable(); }

  // Virtual function which must be implemented by the child class if
  // needed.
  virtual std::string
  do_code_fill(section_size_type) const
  { gold_unreachable(); }

  // Virtual function which may be implemented by the child class.
  virtual bool
  do_is_defined_by_abi(const Symbol*) const
  { return false; }

  // Adjust the output file header before it is written out.  VIEW
  // points to the header in external form.  LEN is the length, and
  // will be one of the values of elfcpp::Elf_sizes<size>::ehdr_size.
  // By default, we set the EI_OSABI field if requested (in
  // Sized_target).
  virtual void
  do_adjust_elf_header(unsigned char*, int) = 0;

  // Return address and size to plug into eh_frame FDEs associated with a PLT.
  virtual void
  do_plt_fde_location(const Output_data* plt, unsigned char* oview,
		      uint64_t* address, off_t* len) const;

  // Virtual function which may be overridden by the child class.
  virtual bool
  do_is_local_label_name(const char*) const;

  // Virtual function that must be overridden by a target which uses
  // target specific relocations.
  virtual unsigned int
  do_reloc_symbol_index(void*, unsigned int) const
  { gold_unreachable(); }

  // Virtual function that must be overridden by a target which uses
  // target specific relocations.
  virtual uint64_t
  do_reloc_addend(void*, unsigned int, uint64_t) const
  { gold_unreachable(); }

  // Virtual functions that must be overridden by a target that uses
  // STT_GNU_IFUNC symbols.
  virtual uint64_t
  do_plt_address_for_global(const Symbol*) const
  { gold_unreachable(); }

  virtual uint64_t
  do_plt_address_for_local(const Relobj*, unsigned int) const
  { gold_unreachable(); }

  virtual int64_t
  do_tls_offset_for_local(const Relobj*, unsigned int, unsigned int) const
  { gold_unreachable(); }

  virtual int64_t
  do_tls_offset_for_global(Symbol*, unsigned int) const
  { gold_unreachable(); }

  virtual void
  do_function_location(Symbol_location*) const = 0;

  // Virtual function which may be overriden by the child class.
  virtual bool
  do_can_check_for_function_pointers() const
  { return false; }

  // Virtual function which may be overridden by the child class.  We
  // recognize some default sections for which we don't care whether
  // they have function pointers.
  virtual bool
  do_section_may_have_icf_unsafe_pointers(const char* section_name) const
  {
    // We recognize sections for normal vtables, construction vtables and
    // EH frames.
    return (!is_prefix_of(".rodata._ZTV", section_name)
	    && !is_prefix_of(".data.rel.ro._ZTV", section_name)
	    && !is_prefix_of(".rodata._ZTC", section_name)
	    && !is_prefix_of(".data.rel.ro._ZTC", section_name)
	    && !is_prefix_of(".eh_frame", section_name));
  }

  virtual uint64_t
  do_ehframe_datarel_base() const
  { gold_unreachable(); }

  // Virtual function which may be overridden by the child class.  The
  // default implementation is that any function not defined by the
  // ABI is a call to a non-split function.
  virtual bool
  do_is_call_to_non_split(const Symbol* sym, unsigned int) const;

  // Virtual function which may be overridden by the child class.
  virtual void
  do_calls_non_split(Relobj* object, unsigned int, section_offset_type,
		     section_size_type, unsigned char*, section_size_type,
		     std::string*, std::string*) const;

  // make_elf_object hooks.  There are four versions of these for
  // different address sizes and endianness.

  // Set processor specific flags.
  void
  set_processor_specific_flags(elfcpp::Elf_Word flags)
  {
    this->processor_specific_flags_ = flags;
    this->are_processor_specific_flags_set_ = true;
  }

#ifdef HAVE_TARGET_32_LITTLE
  // Virtual functions which may be overridden by the child class.
  virtual Object*
  do_make_elf_object(const std::string&, Input_file*, off_t,
		     const elfcpp::Ehdr<32, false>&);
#endif

#ifdef HAVE_TARGET_32_BIG
  // Virtual functions which may be overridden by the child class.
  virtual Object*
  do_make_elf_object(const std::string&, Input_file*, off_t,
		     const elfcpp::Ehdr<32, true>&);
#endif

#ifdef HAVE_TARGET_64_LITTLE
  // Virtual functions which may be overridden by the child class.
  virtual Object*
  do_make_elf_object(const std::string&, Input_file*, off_t,
		     const elfcpp::Ehdr<64, false>& ehdr);
#endif

#ifdef HAVE_TARGET_64_BIG
  // Virtual functions which may be overridden by the child class.
  virtual Object*
  do_make_elf_object(const std::string& name, Input_file* input_file,
		     off_t offset, const elfcpp::Ehdr<64, true>& ehdr);
#endif

  // Virtual functions which may be overridden by the child class.
  virtual Output_section*
  do_make_output_section(const char* name, elfcpp::Elf_Word type,
			 elfcpp::Elf_Xword flags);

  // Virtual function which may be overridden by the child class.
  virtual bool
  do_may_relax() const
  { return parameters->options().relax(); }

  // Virtual function which may be overridden by the child class.
  virtual bool
  do_relax(int, const Input_objects*, Symbol_table*, Layout*, const Task*)
  { return false; }

  // A function for targets to call.  Return whether BYTES/LEN matches
  // VIEW/VIEW_SIZE at OFFSET.
  bool
  match_view(const unsigned char* view, section_size_type view_size,
	     section_offset_type offset, const char* bytes, size_t len) const;

  // Set the contents of a VIEW/VIEW_SIZE to nops starting at OFFSET
  // for LEN bytes.
  void
  set_view_to_nop(unsigned char* view, section_size_type view_size,
		  section_offset_type offset, size_t len) const;

  // This must be overridden by the child class if it has target-specific
  // attributes subsection in the attribute section.
  virtual int
  do_attribute_arg_type(int) const
  { gold_unreachable(); }

  // This may be overridden by the child class.
  virtual int
  do_attributes_order(int num) const
  { return num; }

  // This may be overridden by the child class.
  virtual void
  do_select_as_default_target()
  { }

  // This may be overridden by the child class.
  virtual void
  do_define_standard_symbols(Symbol_table*, Layout*)
  { }

  // This may be overridden by the child class.
  virtual const char*
  do_output_section_name(const Relobj*, const char*, size_t*) const
  { return NULL; }

  // This may be overridden by the child class.
  virtual void
  do_gc_mark_symbol(Symbol_table*, Symbol*) const
  { }

 private:
  // The implementations of the four do_make_elf_object virtual functions are
  // almost identical except for their sizes and endianness.  We use a template.
  // for their implementations.
  template<int size, bool big_endian>
  inline Object*
  do_make_elf_object_implementation(const std::string&, Input_file*, off_t,
				    const elfcpp::Ehdr<size, big_endian>&);

  Target(const Target&);
  Target& operator=(const Target&);

  // The target information.
  const Target_info* pti_;
  // Processor-specific flags.
  elfcpp::Elf_Word processor_specific_flags_;
  // Whether the processor-specific flags are set at least once.
  bool are_processor_specific_flags_set_;
  // If not ELFOSABI_NONE, the value to put in the EI_OSABI field of
  // the ELF header.  This is handled at this level because it is
  // OS-specific rather than processor-specific.
  elfcpp::ELFOSABI osabi_;
};

// The abstract class for a specific size and endianness of target.
// Each actual target implementation class should derive from an
// instantiation of Sized_target.

template<int size, bool big_endian>
class Sized_target : public Target
{
 public:
  // Make a new symbol table entry for the target.  This should be
  // overridden by a target which needs additional information in the
  // symbol table.  This will only be called if has_make_symbol()
  // returns true.
  virtual Sized_symbol<size>*
  make_symbol() const
  { gold_unreachable(); }

  // Resolve a symbol for the target.  This should be overridden by a
  // target which needs to take special action.  TO is the
  // pre-existing symbol.  SYM is the new symbol, seen in OBJECT.
  // VERSION is the version of SYM.  This will only be called if
  // has_resolve() returns true.
  virtual void
  resolve(Symbol*, const elfcpp::Sym<size, big_endian>&, Object*,
	  const char*)
  { gold_unreachable(); }

  // Process the relocs for a section, and record information of the
  // mapping from source to destination sections. This mapping is later
  // used to determine unreferenced garbage sections. This procedure is
  // only called during garbage collection.
  virtual void
  gc_process_relocs(Symbol_table* symtab,
		    Layout* layout,
		    Sized_relobj_file<size, big_endian>* object,
		    unsigned int data_shndx,
		    unsigned int sh_type,
		    const unsigned char* prelocs,
		    size_t reloc_count,
		    Output_section* output_section,
		    bool needs_special_offset_handling,
		    size_t local_symbol_count,
		    const unsigned char* plocal_symbols) = 0;

  // Scan the relocs for a section, and record any information
  // required for the symbol.  SYMTAB is the symbol table.  OBJECT is
  // the object in which the section appears.  DATA_SHNDX is the
  // section index that these relocs apply to.  SH_TYPE is the type of
  // the relocation section, SHT_REL or SHT_RELA.  PRELOCS points to
  // the relocation data.  RELOC_COUNT is the number of relocs.
  // LOCAL_SYMBOL_COUNT is the number of local symbols.
  // OUTPUT_SECTION is the output section.
  // NEEDS_SPECIAL_OFFSET_HANDLING is true if offsets to the output
  // sections are not mapped as usual.  PLOCAL_SYMBOLS points to the
  // local symbol data from OBJECT.  GLOBAL_SYMBOLS is the array of
  // pointers to the global symbol table from OBJECT.
  virtual void
  scan_relocs(Symbol_table* symtab,
	      Layout* layout,
	      Sized_relobj_file<size, big_endian>* object,
	      unsigned int data_shndx,
	      unsigned int sh_type,
	      const unsigned char* prelocs,
	      size_t reloc_count,
	      Output_section* output_section,
	      bool needs_special_offset_handling,
	      size_t local_symbol_count,
	      const unsigned char* plocal_symbols) = 0;

  // Relocate section data.  SH_TYPE is the type of the relocation
  // section, SHT_REL or SHT_RELA.  PRELOCS points to the relocation
  // information.  RELOC_COUNT is the number of relocs.
  // OUTPUT_SECTION is the output section.
  // NEEDS_SPECIAL_OFFSET_HANDLING is true if offsets must be mapped
  // to correspond to the output section.  VIEW is a view into the
  // output file holding the section contents, VIEW_ADDRESS is the
  // virtual address of the view, and VIEW_SIZE is the size of the
  // view.  If NEEDS_SPECIAL_OFFSET_HANDLING is true, the VIEW_xx
  // parameters refer to the complete output section data, not just
  // the input section data.
  virtual void
  relocate_section(const Relocate_info<size, big_endian>*,
		   unsigned int sh_type,
		   const unsigned char* prelocs,
		   size_t reloc_count,
		   Output_section* output_section,
		   bool needs_special_offset_handling,
		   unsigned char* view,
		   typename elfcpp::Elf_types<size>::Elf_Addr view_address,
		   section_size_type view_size,
		   const Reloc_symbol_changes*) = 0;

  // Scan the relocs during a relocatable link.  The parameters are
  // like scan_relocs, with an additional Relocatable_relocs
  // parameter, used to record the disposition of the relocs.
  virtual void
  scan_relocatable_relocs(Symbol_table* symtab,
			  Layout* layout,
			  Sized_relobj_file<size, big_endian>* object,
			  unsigned int data_shndx,
			  unsigned int sh_type,
			  const unsigned char* prelocs,
			  size_t reloc_count,
			  Output_section* output_section,
			  bool needs_special_offset_handling,
			  size_t local_symbol_count,
			  const unsigned char* plocal_symbols,
			  Relocatable_relocs*) = 0;

  // Emit relocations for a section during a relocatable link, and for
  // --emit-relocs.  The parameters are like relocate_section, with
  // additional parameters for the view of the output reloc section.
  virtual void
  relocate_relocs(const Relocate_info<size, big_endian>*,
		  unsigned int sh_type,
		  const unsigned char* prelocs,
		  size_t reloc_count,
		  Output_section* output_section,
		  typename elfcpp::Elf_types<size>::Elf_Off
                    offset_in_output_section,
		  const Relocatable_relocs*,
		  unsigned char* view,
		  typename elfcpp::Elf_types<size>::Elf_Addr view_address,
		  section_size_type view_size,
		  unsigned char* reloc_view,
		  section_size_type reloc_view_size) = 0;

  // Perform target-specific processing in a relocatable link.  This is
  // only used if we use the relocation strategy RELOC_SPECIAL.
  // RELINFO points to a Relocation_info structure. SH_TYPE is the relocation
  // section type. PRELOC_IN points to the original relocation.  RELNUM is
  // the index number of the relocation in the relocation section.
  // OUTPUT_SECTION is the output section to which the relocation is applied.
  // OFFSET_IN_OUTPUT_SECTION is the offset of the relocation input section
  // within the output section.  VIEW points to the output view of the
  // output section.  VIEW_ADDRESS is output address of the view.  VIEW_SIZE
  // is the size of the output view and PRELOC_OUT points to the new
  // relocation in the output object.
  //
  // A target only needs to override this if the generic code in
  // target-reloc.h cannot handle some relocation types.

  virtual void
  relocate_special_relocatable(const Relocate_info<size, big_endian>*
				/*relinfo */,
			       unsigned int /* sh_type */,
			       const unsigned char* /* preloc_in */,
			       size_t /* relnum */,
			       Output_section* /* output_section */,
			       typename elfcpp::Elf_types<size>::Elf_Off
                                 /* offset_in_output_section */,
			       unsigned char* /* view */,
			       typename elfcpp::Elf_types<size>::Elf_Addr
				 /* view_address */,
			       section_size_type /* view_size */,
			       unsigned char* /* preloc_out*/)
  { gold_unreachable(); }

  // Return the number of entries in the GOT.  This is only used for
  // laying out the incremental link info sections.  A target needs
  // to implement this to support incremental linking.

  virtual unsigned int
  got_entry_count() const
  { gold_unreachable(); }

  // Return the number of entries in the PLT.  This is only used for
  // laying out the incremental link info sections.  A target needs
  // to implement this to support incremental linking.

  virtual unsigned int
  plt_entry_count() const
  { gold_unreachable(); }

  // Return the offset of the first non-reserved PLT entry.  This is
  // only used for laying out the incremental link info sections.
  // A target needs to implement this to support incremental linking.

  virtual unsigned int
  first_plt_entry_offset() const
  { gold_unreachable(); }

  // Return the size of each PLT entry.  This is only used for
  // laying out the incremental link info sections.  A target needs
  // to implement this to support incremental linking.

  virtual unsigned int
  plt_entry_size() const
  { gold_unreachable(); }

  // Create the GOT and PLT sections for an incremental update.
  // A target needs to implement this to support incremental linking.

  virtual Output_data_got_base*
  init_got_plt_for_update(Symbol_table*,
			  Layout*,
			  unsigned int /* got_count */,
			  unsigned int /* plt_count */)
  { gold_unreachable(); }

  // Reserve a GOT entry for a local symbol, and regenerate any
  // necessary dynamic relocations.
  virtual void
  reserve_local_got_entry(unsigned int /* got_index */,
			  Sized_relobj<size, big_endian>* /* obj */,
			  unsigned int /* r_sym */,
			  unsigned int /* got_type */)
  { gold_unreachable(); }

  // Reserve a GOT entry for a global symbol, and regenerate any
  // necessary dynamic relocations.
  virtual void
  reserve_global_got_entry(unsigned int /* got_index */, Symbol* /* gsym */,
			   unsigned int /* got_type */)
  { gold_unreachable(); }

  // Register an existing PLT entry for a global symbol.
  // A target needs to implement this to support incremental linking.

  virtual void
  register_global_plt_entry(Symbol_table*, Layout*,
			    unsigned int /* plt_index */,
			    Symbol*)
  { gold_unreachable(); }

  // Force a COPY relocation for a given symbol.
  // A target needs to implement this to support incremental linking.

  virtual void
  emit_copy_reloc(Symbol_table*, Symbol*, Output_section*, off_t)
  { gold_unreachable(); }

  // Apply an incremental relocation.

  virtual void
  apply_relocation(const Relocate_info<size, big_endian>* /* relinfo */,
		   typename elfcpp::Elf_types<size>::Elf_Addr /* r_offset */,
		   unsigned int /* r_type */,
		   typename elfcpp::Elf_types<size>::Elf_Swxword /* r_addend */,
		   const Symbol* /* gsym */,
		   unsigned char* /* view */,
		   typename elfcpp::Elf_types<size>::Elf_Addr /* address */,
		   section_size_type /* view_size */)
  { gold_unreachable(); }

  // Handle target specific gc actions when adding a gc reference from
  // SRC_OBJ, SRC_SHNDX to a location specified by DST_OBJ, DST_SHNDX
  // and DST_OFF.
  void
  gc_add_reference(Symbol_table* symtab,
		   Object* src_obj,
		   unsigned int src_shndx,
		   Object* dst_obj,
		   unsigned int dst_shndx,
		   typename elfcpp::Elf_types<size>::Elf_Addr dst_off) const
  {
    this->do_gc_add_reference(symtab, src_obj, src_shndx,
			      dst_obj, dst_shndx, dst_off);
  }

 protected:
  Sized_target(const Target::Target_info* pti)
    : Target(pti)
  {
    gold_assert(pti->size == size);
    gold_assert(pti->is_big_endian ? big_endian : !big_endian);
  }

  // Set the EI_OSABI field if requested.
  virtual void
  do_adjust_elf_header(unsigned char*, int);

  // Handle target specific gc actions when adding a gc reference.
  virtual void
  do_gc_add_reference(Symbol_table*, Object*, unsigned int,
		      Object*, unsigned int,
		      typename elfcpp::Elf_types<size>::Elf_Addr) const
  { }

  virtual void
  do_function_location(Symbol_location*) const
  { }
};

} // End namespace gold.

#endif // !defined(GOLD_TARGET_H)
@


1.75
log
@    gold/
    	* parameters.cc (Parameters::entry): Return target-specific entry
    	symbol name.
    	* target.h (Target::entry_symbol_name): New function.
    	(Target_info::entry_symbol_name): New data member.

    	* arm.cc (Target_arm::arm_info): Add entry_symbol_name.
    	(Target_arm_nacl::arm_nacl_info): Likewise.
    	* i386.cc (Target_i386::i386_info): Likewise.
    	(Target_i386_nacl::i386_nacl_info): Likewise.
    	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
    	* sparc.cc (Target_sparc::sparc_info): Likewise.
    	* tilegx.cc (Target_tilegx::tilegx_info): Likewise.
    	* x86_64.cc: (Target_x86_64::x86_64_info) Likewise.
    	(Target_x86_64_nacl::x86_64_nacl_info) Likewise.
    	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
d241 1
a241 1
  adjust_elf_header(unsigned char* view, int len) const
d551 1
a551 1
  do_adjust_elf_header(unsigned char*, int) const = 0;
d1021 1
a1021 1
  do_adjust_elf_header(unsigned char*, int) const;
@


1.75.2.1
log
@gold/
	* target.h (Target::adjust_elf_header, Target::do_adjust_elf_header):
	Remove const from declaration.
	* target.cc (Sized_target::do_adjust_elf_header): Update definition.
	* sparc.cc (Target_sparc::do_adjust_elf_header): Likewise.
	* output.h (Output_file_header): Remove const from member target_
	and corresponding constructor argument.
	* output.cc (Output_file_header::Output_file_header): Update prototype.
	(Output_file_header::do_sized_write): Use this->target_ in place
	of parameters()->target().
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
d241 1
a241 1
  adjust_elf_header(unsigned char* view, int len)
d551 1
a551 1
  do_adjust_elf_header(unsigned char*, int) = 0;
d1021 1
a1021 1
  do_adjust_elf_header(unsigned char*, int);
@


1.74
log
@	* gold.cc (queue_middle_tasks): Move detect_odr_violations..
	* layout.cc (Layout_task_runner::run): ..to here.
	* symtab.h (struct Symbol_location): Extract from..
	(class Symbol_table): ..here.
	* symtab.cc (Symbol_table::linenos_from_loc): Invoke function_location.
	* target.h (class Target): Add function_location and
	do_function_location functions.
	(class Sized_target): Add do_function_location.
	* object.h (class Sized_relobj_file): Move find_shdr..
	(class Object): ..to here.
	* object.cc: Likewise.  Update to suit.  Instantiate.
	(Sized_relobj_file::find_eh_frame): Update find_shdr call.
	* powerpc.cc (class Powerpc_dynobj): New.
	(Target_powerpc::do_function_location): New function.
	(Powerpc_relobj::do_find_special_sections): Update find_shdr call.
	(Powerpc_dynobj::do_read_symbols): New function.
	(Target_powerpc::do_make_elf_object): Make a Powerpc_dynobj.
@
text
@d452 5
d510 2
@


1.73
log
@	* target.h (Target::plt_fde_location, do_plt_fde_location): Declare.
	* target.cc (Target::do_plt_fde_location): New function.
	* ehframe.h (class FDE): Add post_map field to u_.from_linker,
	accessor function, and constructor param.
	(struct Post_fde, Post_fdes): Declare.
	(Cie::write): Add post_fdes param.
	* ehframe.cc (Fde::write): Use plt_fde_location.
	(struct Post_fde): Define.
	(Cie::write): Stash FDEs added post merge mapping.
	(Eh_frame::add_ehframe_for_plt): Assert no new CIEs after mapping.
	Adjust Fde constructor call.  Bump final_data_size_ for post map FDEs.
	(Eh_frame::do_sized_write): Arrange to write post map FDES after
	other FDEs.
	* powerpc.cc (Target_powerpc::do_plt_fde_location): New function.
	(Target_powerpc::has_glink): New function.
	(Target_powerpc::do_relax): Add eh_frame info for stubs.
	(struct Eh_cie, eh_frame_cie, glink_eh_frame_fde_64,
	glink_eh_frame_fde_32, default_fde): New data.
	(Stub_table::eh_frame_added_): New var.
	(Stub_table::find_long_branch_entry, stub_address, stub_offset):
	Make const.
	(Stub_table::add_eh_frame): New function.
	(Output_data_glink::add_eh_frame): New function.
	(Target_powerpc::make_glink_section): Call add_eh_frame.
@
text
@d64 1
d290 6
d585 3
d1022 4
@


1.72
log
@gold/
	* target.h (Sized_target::relocate_relocs): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_relocs): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_relocs): Likewise.
	* powerpc.cc (Target_powerpc::relocate_relocs): Likewise.
	* sparc.cc (Target_sparc::relocate_relocs): Likewise.
	* target-reloc.h (relocate_relocs): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_relocs): Likewise.
	* x86_64.cc (Target_x86_64::relocate_relocs): Likewise.
@
text
@d243 6
d539 5
@


1.71
log
@	* i386.cc (Output_data_plt_i386::address_for_global,
	address_for_local): Add plt offset to returned value.  Adjust uses.
	* sparc.cc (Output_data_plt_sparc::address_for_global,
	address_for_local): Likewise.
	* tilegx.cc (Output_data_plt_tilegx::address_for_global,
	address_for_local): Likewise.
	* x86_64.cc (Output_data_plt_x86_64::address_for_global,
	address_for_local): Likewise.
	* target.h (Target::plt_address_for_global, plt_address_for_local):
	Update comment.
	* output.cc (Output_reloc::symbol_value): Don't add plt offset here.
	(Output_data_got::Got_entry::write): Nor here.
	* output.h: Comment fix.
@
text
@d841 2
a842 1
		  off_t offset_in_output_section,
d872 2
a873 1
			       off_t /* offset_in_output_section */,
@


1.70
log
@	* output.h (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::add_local_pair_with_rel): Remove second
	reloc param.  Expand comment.
	(Output_data_got::Got_entry): Rename use_plt_offset_ to
	use_plt_or_tls_offset_, similarly for constructor param.
	(Output_data_got::Got_entry::write): Add got_index param.
	* output.cc (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::Got_entry::write): Handle tls symbols
	with use_plt_or_tls_offset_ set specially.
	(Output_data_got::add_local_pair_with_rel): Only one reloc.
	(Output_data_got::do_write): Replace iterator with index, pass
	index to entry write function.
	* target.h (Target::tls_offset_for_local, tls_offset_for_global,
	do_tls_offset_for_local, do_tls_offset_for_global): New functions.
	* arm.cc (Target_arm::Scan::local): Update add_local_pair_with_rel
	call.
	* i386.cc (Target_i386::Scan::local): Likewise.
	* sparc.cc (Target_sparc::Scan::local): Likewise.
	* x86_64.cc (Target_x86_64::Scan::local): Likewise.
	* powerpc.cc (Target_powerpc::do_tls_offset_for_local,
	do_tls_offset_for_global): New functions.
	(Target_powerpc::Scan::local): Correct TLS relocations and got
	entry values.
	(Target_powerpc::Scan::global): Don't emit unnecessary
	dynamic relocations on TLS GOT entries.
@
text
@d259 1
a259 3
  // Return the PLT address to use for a global symbol.  This is used
  // for STT_GNU_IFUNC symbols.  The symbol's plt_offset is relative
  // to this PLT address.
d264 1
a264 3
  // Return the PLT address to use for a local symbol.  This is used
  // for STT_GNU_IFUNC symbols.  The symbol's plt_offset is relative
  // to this PLT address.
@


1.69
log
@	* target.h (Target::gc_mark_symbol, do_gc_mark_symbol): New functions.
	(Sized_target::gc_add_reference, do_gc_add_reference): New functions.
	* gc.h (gc_process_relocs): Call target gc_add_reference.
	* gold.cc (queue_middle_tasks): Use gc_mark_symbol on start sym.
	* symtab.cc (Symbol_table::gc_mark_undef_symbols): Use gc_mark_symbol.
	(Symbol_table::gc_mark_symbol): Call target gc_mark_symbol. Remove
	unnecessary cast.
	* powerpc.cc (Powerpc_relobj::get_opd_ent): Rearrange parameters
	to cater for when we don't need code offset.  Update use.
	(Powerpc_relobj::access_from_map_, opd_valid_): New vars.
	(Powerpc_relobj::access_from_map, add_reference, opd_valid,
	set_opd_valid): New functions.
	(Target_powerpc::do_gc_add_reference): New function.
	(Target_powerpc::gc_process_relocs): Call gc()->add_reference on
	stashed refs.
	(Target_powerpc::do_gc_mark_symbol): New function.
@
text
@d273 14
d563 8
@


1.68
log
@	* object.h (Sized_relobj_file::emit_relocs): Delete.
	(Sized_relobj_file::emit_relocs_reltype): Delete.
	* reloc.cc (Sized_relobj_file::do_relocate_sections): Call target
	relocate_relocs for --emit-relocs.
	(Sized_relobj_file::emit_relocs, emit_relocs_reltype): Delete.
	* output.h: Update comment.
	(Output_segment::first_section): New function.
	(Output_segment::first_section_load_address): Use first_section.
	* output.cc (Output_segment::first_section): New function extracted..
	(Output_segment::first_section_load_address): ..from here.  Delete.
	* target-reloc.h (relocate_for_relocatable): Rename to relocate_relocs.
	* target.h (Sized_target::relocate_for_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise, and
	adjust call to target.h function.
	* i386.cc (Target_i386): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	(Target_powerpc::Scan::local, global): Handle R_POWERPC_TLS.  Ensure
	first tls section has section symbol for optimised local dynamic
	output relocs.
	(Target_powerpc::Relocate::relocate): Correct local dynamic value.
	(Target_powerpc::relocate_relocs): Adjust relocs emitted for
	optimised tls code.
	* testsuite/testfile.cc (Target_test::relocate_for_relocatable):
	Rename to relocate_relocs.  Update error message.
@
text
@d424 5
d677 5
d948 15
d974 7
@


1.67
log
@	* target.h (Target::output_section_name): New function.
	(Target::do_output_section_name): New function.
	* layout.cc (Layout::choose_output_section): Call the above.
	* powerpc.cc (Target_powerpc::do_output_section_name): New function.
@
text
@d804 16
a819 17
  // Relocate a section during a relocatable link.  The parameters are
  // like relocate_section, with additional parameters for the view of
  // the output reloc section.
  virtual void
  relocate_for_relocatable(const Relocate_info<size, big_endian>*,
			   unsigned int sh_type,
			   const unsigned char* prelocs,
			   size_t reloc_count,
			   Output_section* output_section,
			   off_t offset_in_output_section,
			   const Relocatable_relocs*,
			   unsigned char* view,
			   typename elfcpp::Elf_types<size>::Elf_Addr
			     view_address,
			   section_size_type view_size,
			   unsigned char* reloc_view,
			   section_size_type reloc_view_size) = 0;
@


1.66
log
@	* configure.ac (ENABLE_GOLD): Consider *-*-nacl* targets ELF.
	* configure: Regenerate.

gold/
	* nacl.cc: New file.
	* nacl.h: New file.
	* Makefile.am (CCFILES, HFILES): Add them.
	* Makefile.in: Regenerate.
	* i386.cc (Output_data_plt_i386_nacl): New class.
	(Output_data_plt_i386_nacl_exec): New class.
	(Output_data_plt_i386_nacl_dyn): New class.
	(Target_i386_nacl): New class.
	(Target_selector_i386_nacl): New class.
	(target_selector_i386): Use it instead of Target_selector_i386.
	* x86_64.cc (Output_data_plt_x86_64_nacl): New class.
	(Target_x86_64_nacl): New class.
	(Target_selector_x86_64_nacl): New class.
	(target_selector_x86_64, target_selector_x32): Use it instead of
	Target_selector_x86_64.
	* arm.cc (Output_data_plt_arm_nacl): New class.
	(Target_arm_nacl): New class.
	(Target_selector_arm_nacl): New class.
	(target_selector_arm, target_selector_armbe): Use it instead of
	Target_selector_arm.

	* target-select.cc (select_target): Take new Input_file* and off_t
	arguments, pass them on to recognize method of selector.
	* object.cc (make_elf_sized_object): Update caller.
	* parameters.cc (parameters_force_valid_target): Likewise.
	* incremental.cc (make_sized_incremental_binary): Likewise.
	* target-select.h: Update decl.
	(Target_selector::recognize): Take new Input_file* argument,
	pass it on to do_recognize.
	(Target_selector::do_recognize): Take new Input_file* argument.
	* freebsd.h (Target_selector_freebsd::do_recognize): Likewise.
	* powerpc.cc (Target_selector_powerpc::do_recognize): Likewise.
	* sparc.cc (Target_selector_sparc::do_recognize): Likewise.
	* testsuite/testfile.cc (Target_selector::do_recognize): Likewise.

	* target.h (Target::Target_info): New members isolate_execinstr
	and rosegment_gap.
	(Target::isolate_execinstr, Target::rosegment_gap): New methods.
	* arm.cc (Target_arm::arm_info): Update initializer.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
	* sparc.cc (Target_sparc::sparc_info): Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
	* layout.cc (Layout::attach_allocated_section_to_segment):
	Take new const Target* argument.  If target->isolate_execinstr(), act
	like --rosegment.
	(Layout::find_first_load_seg): Take new const Target* argument;
	if target->isolate_execinstr(), reject PF_X segments.
	(Layout::relaxation_loop_body): Update caller.
	(Layout::set_segment_offsets): If target->isolate_execinstr(),
	reset file offset to zero when we hit LOAD_SEG, and then do a second
	loop over the segments before LOAD_SEG to reassign offsets after
	addresses have been determined.  Handle target->rosegment_gap().
	(Layout::attach_section_to_segment): Take new const Target* argument;
	pass it to attach_allocated_section_to_segment.
	(Layout::make_output_section): Update caller.
	(Layout::attach_sections_to_segments): Take new const Target* argument;
	pass it to attach_section_to_segment.
	* gold.cc (queue_middle_tasks): Update caller.
	* layout.h (Layout): Update method decls with new arguments.

	* arm.cc (Target_arm::Target_arm): Take optional argument for the
	Target_info pointer to use.
	(Target_arm::do_make_data_plt): New virtual method.
	(Target_arm::make_data_plt): New method that calls it.
	(Target_arm::make_plt_entry): Use it.
	(Output_data_plt_arm::Output_data_plt_arm): Take additional argument
	for the section alignment.
	(Output_data_plt_arm::do_first_plt_entry_offset): New abstract virtual
	method.
	(Output_data_plt_arm::first_plt_entry_offset): Call it.
	(Output_data_plt_arm::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_arm::get_plt_entry_size): Call it.
	(Output_data_plt_arm::do_fill_plt_entry): New abstract virtual method.
	(Output_data_plt_arm::fill_plt_entry): New method that calls it.
	(Output_data_plt_arm::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_arm::fill_first_plt_entry): New method that calls it.
	(Output_data_plt_arm::set_final_data_size): Use get_plt_entry_size
	method instead of sizeof(plt_entry).
	(Output_data_plt_arm::add_entry): Likewise.
	Use first_plt_entry_offset method instead of sizeof(first_plt_entry).
	(Target_arm::first_plt_entry_offset): Call method on this->plt_ rather
	than static method.
	(Target_arm::plt_entry_size): Likewise.
	(Output_data_plt_arm::first_plt_entry, Output_data_plt_arm::plt_entry):
	Move to ...
	(Output_data_plt_arm_standard): ... here, new class.
	(Output_data_plt_arm::do_write): Move guts of PLT filling to...
	(Output_data_plt_arm_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_arm_standard::do_fill_plt_entry): ... and here.

	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Take additional argument for the PLT entry size.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset):
	Use get_plt_entry_size method rather than plt_entry_size variable.
	(Output_data_plt_x86_64::reserve_slot): Likewise.
	(Output_data_plt_x86_64::do_adjust_output_section): Likewise.
	(Output_data_plt_x86_64::add_entry): Likewise.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Likewise.
	(Output_data_plt_x86_64::address_for_global): Likewise.
	(Output_data_plt_x86_64::address_for_local): Likewise.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::first_plt_entry_offset): Likewise.
	Make method non-static.
	(Output_data_plt_x86_64::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_x86_64::get_plt_entry_size): Just call that.
	(Output_data_plt_x86_64::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_x86_64::add_eh_frame): New method to call it.
	(Output_data_plt_x86_64::do_fill_first_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_first_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_tlsdesc_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_tlsdesc_entry): New method to call it.
	(Output_data_plt_x86_64::plt_entry_size)
	(Output_data_plt_x86_64::first_plt_entry)
	(Output_data_plt_x86_64::plt_entry)
	(Output_data_plt_x86_64::tlsdesc_plt_entry)
	(Output_data_plt_x86_64::plt_eh_frame_fde_size)
	(Output_data_plt_x86_64::plt_eh_frame_fde): Move to ...
	(Output_data_plt_x86_64_standard): ... here, new class.
	(Target_x86_64::Target_x86_64): Take optional argument for the
	Target_info pointer to use.
	(Target_x86_64::do_make_data_plt): New virtual method.
	(Target_x86_64::make_data_plt): New method to call it.
	(Target_x86_64::init_got_plt_for_update): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_x86_64::init):	Don't do add_eh_frame_for_plt here.
	(Target_x86_64::first_plt_entry_offset): Call method on this->plt_
	rather than static method.
	(Target_x86_64::plt_entry_size): Likewise.
	(Output_data_plt_x86_64::do_write): Use get_plt_entry_size method
	rather than plt_entry_size variable.  Move guts of PLT filling to...
	(Output_data_plt_x86_64_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_x86_64_standard::do_fill_plt_entry): ... and here ...
	(Output_data_plt_x86_64_standard::do_fill_tlsdesc_entry): ... and here.

	* i386.cc (Output_data_plt_i386::Output_data_plt_i386): Take
	additional argument for the section alignment.
	Don't do add_eh_frame_for_plt here.
	(Output_data_plt_i386::first_plt_entry_offset): Make the method
	non-static.  Use get_plt_entry_size method rather than plt_entry_size
	variable.
	(Output_data_plt_i386::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_i386::get_plt_entry_size): Call it.
	(Output_data_plt_i386::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_i386::add_eh_frame): New method to call it.
	(Output_data_plt_i386::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_first_plt_entry): New method to call it.
	(Output_data_plt_i386::do_fill_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_plt_entry): New method to call it.
	(Output_data_plt_i386::set_final_data_size): Use get_plt_entry_size
	method instead of plt_entry_size.
	(Output_data_plt_i386::plt_entry_size)
	(Output_data_plt_i386::plt_eh_frame_fde_size)
	(Output_data_plt_i386::plt_eh_frame_fde): Move to ...
	(Output_data_plt_i386_standard): ... here, new class.
	(Output_data_plt_i386_exec): New class.
	(Output_data_plt_i386::exec_first_plt_entry): Move to ...
	(Output_data_plt_i386_exec::first_plt_entry): ... here.
	(Output_data_plt_i386::exec_plt_entry): Move to ...
	(Output_data_plt_i386_exec::plt_entry): ... here.
	(Output_data_plt_i386_dyn): New class.
	(Output_data_plt_i386::first_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::first_plt_entry): ... here.
	(Output_data_plt_i386::dyn_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::plt_entry): ... here.
	(Target_i386::Target_i386): Take optional argument for the Target_info
	pointer to use.
	(Target_i386::do_make_data_plt): New virtual method.
	(Target_i386::make_data_plt): New method to call it.
	(Target_i386::make_plt_section): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_i386::add_entry): Use get_plt_entry_size method
	rather than plt_entry_size variable.
	(Output_data_plt_i386::add_local_ifunc_entry): Likewise.
	(Output_data_plt_i386::address_for_local): Likewise.
	(Output_data_plt_i386::do_write): Likewise.
	Move guts of PLT filling to...
	(Output_data_plt_i386_exec::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_i386_exec::do_fill_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_first_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_plt_entry): ... and here.

Change-Id: Id24b95600489835ff5e860a39c147203d4380c2b
@
text
@d415 9
d667 5
@


1.66.2.1
log
@gold/
	* target.h (Sized_target::relocate_for_relocatable): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_for_relocatable): Likewise.
	* powerpc.cc (Target_powerpc::relocate_for_relocatable): Likewise.
	* sparc.cc (Target_sparc::relocate_for_relocatable): Likewise.
	* target-reloc.h (relocate_for_relocatable): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_for_relocatable): Likewise.
	* x86_64.cc (Target_x86_64::relocate_for_relocatable): Likewise.
@
text
@d799 1
a799 2
			   typename elfcpp::Elf_types<size>::Elf_Off
                             offset_in_output_section,
d830 1
a830 2
			       typename elfcpp::Elf_types<size>::Elf_Off
                                 /* offset_in_output_section */,
@


1.65
log
@	* arm.cc (Target_arm::do_is_defined_by_abi): Make sym a const
	pointer.
	(Stub_addend_reader::operator()): Declare Arm_relocate_functions
	as a class, not a struct.
	(Target_arm::scan_span_for_cortex_a8_erratum): Likewise.
	(Target_arm::apply_cortex_a8_workaround): Likewise.
	* gc.h: Declare Reloc_types as a struct, not a class.
	* object.h: Declare Symbols_data as a struct.
	* reloc.h: Declare Read_relocs_data as a struct.
	* target.h: Declare Relocate_info as a struct.
@
text
@d146 10
d358 1
a358 1
  } 
d378 1
a378 1
	    || strcmp(name, ".gnu.attributes") == 0); 
d397 1
a397 1
  { this->do_select_as_default_target(); } 
d449 5
d581 1
a581 1
  
d638 1
a638 1
  // attributes subsection in the attribute section. 
d807 1
a807 1
 
d837 1
a837 1
 
@


1.64
log
@2012-03-19  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_define_standard_symbols): New method.
 	(Target_arm::do_finalize_sections): Remove code which defines
	__exidx_start and __exidx_end.  Make symbol table parameter
	anonymous as it is not used.
	* gold.cc (queue_middle_tasks): Call target hook to define any
	target-specific symbols.
	* target.h (Target::define_standard_symbols): New method.
	(Target::do_define_standard_symbols): Same.
	* testsuite/Makefile.am (arm_exidx_test): Dump relocations also.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/arm_exidx.s: Generate data relocations for __exidx_start
	and __exidx_end.
	* testsuite/arm_exidx_test.sh: Check that no unused dynamic
	relocations are generated for __exidx_start and __exidx_end.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d53 1
a53 1
class Relocate_info;
@


1.63
log
@	* gold/incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Use abstract base class for GOT.
	* gold/output.h (class Output_data_got_base): New abstract base class.
	(class Output_data_got): Derive from new base class, adjust ctors.
	(Output_data_got::reserve_slot): Make virtual; rename to
	do_reserve_slot; Adjust callers.
	* gold/target.h (Sized_target::init_got_plt_for_update): Return
	pointer to abstract base class.
	* gold/x86_64.cc (Target_x86_64::init_got_plt_for_update): Likewise.
@
text
@d399 5
d637 5
@


1.62
log
@	PR gold/12372
	* target.h (Target::plt_address_for_global): New function.
	(Target::plt_address_for_local): New function.
	(Target::plt_section_for_global): Remove.
	(Target::plt_section_for_local): Remove.
	(Target::do_plt_address_for_global): New virtual function.
	(Target::do_plt_address_for_local): New virtual function.
	(Target::do_plt_section_for_global): Remove.
	(Target::do_plt_section_for_local): Remove.
	(Target::register_global_plt_entry): Add Symbol_table and Layout
	parameters.
	* output.cc (Output_data_got::Got_entry::write): Use
	plt_address_for_global and plt_address_for_local.
	* layout.cc (Layout::add_target_dynamic_tags): Use size and
	address of output section.
	* i386.cc (class Output_data_plt_i386): Add irelative_rel_,
	got_irelative_, and irelative_count_ fields.  Update
	declarations.
	(Output_data_plt_i386::has_irelative_section): New function.
	(Output_data_plt_i386::entry_count): Add irelative_count_.
	(Output_data_plt_i386::set_final_data_size): Likewise.
	(class Target_i386): Add got_irelative_ and rel_irelative_
	fields.  Update declarations.
	(Target_i386::Target_i386): Initialize new fields.
	(Target_i386::do_plt_address_for_global): New function replacing
	do_plt_section_for_global.
	(Target_i386::do_plt_address_for_local): New function replacing
	do_plt_section_for_local.
	(Target_i386::got_section): Create got_irelative_.
	(Target_i386::rel_irelative_section): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize new
	fields.  Don't define __rel_iplt_{start,end}.
	(Output_data_plt_i386::add_entry): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): Add symtab and
	layout parameters.  Change all callers.  Use different PLT and
	GOT.
	(Output_data_plt_i386::rel_tls_desc): Fix formatting.
	(Output_data_plt_i386::rel_irelative): New function.
	(Output_data_plt_i386::address_for_global): New function.
	(Output_data_plt_i386::address_for_local): New function.
	(Output_data_plt_i386::do_write): Write out IRELATIVE area.  Use
	IRELATIVE GOT when changing IFUNC GOT entries.
	(Target_i386::Scan::global): Use IRELATIVE GOT for IRELATIVE
	reloc.
	(Target_i386::do_finalize_sections): Create the __rel_iplt symbols
	if we didn't create an IRELATIVE GOT.
	(Target_i386::Relocate::relocate): Use plt_address_for_global and
	plt_address_for_local.
	(Target_i386::do_dynsym_value): Use plt_address_for_global.
	* x86_64.cc (class Output_data_plt_x86_64): Add irelative_rel_,
	got_irelative_, and irelative_count_ fields.  Update
	declarations.
	(Output_data_plt_x86_64::Output_data_plt_x86_64) [both versions]:
	Initialize new fields.  Remove symtab parameter.  Change all
	callers.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset): Add
	irelative_count_.
	(Output_data_plt_x86_64::has_irelative_section): New function.
	(Output_data_plt_x86_64::entry_count): Add irelative_count_.
	(class Target_x86_64): Add got_irelative_ and rel_irelative_
	fields.  Update declarations.
	(Target_x86_64::Target_x86_64): Initialize new fields.
	(Target_x86_64::do_plt_address_for_global): New function replacing
	do_plt_section_for_global.
	(Target_x86_64::do_plt_address_for_local): New function replacing
	do_plt_section_for_local.
	(Target_x86_64::got_section): Create got_irelative_.
	(Target_x86_64::rela_irelative_section): New function.
	(Output_data_plt_x86_64::init): Remove symtab parameter.  Change
	all callers.  Don't create __rel_iplt_{start,end}.
	(Output_data_plt_x86_64::add_entry): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Add symtab and
	layout parameters.  Change all callers.  Use different PLT and
	GOT.
	(Output_data_plt_x86_64::add_relocation): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_x86_64::rela_tlsdesc): Fix formatting.
	(Output_data_plt_x86_64::rela_irelative): New function.
	(Output_data_plt_x86_64::address_for_global): New function.
	(Output_data_plt_x86_64::address_for_local): New function.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::do_write): Write out IRELATIVE area.
	(Target_x86_64::init_got_plt_for_update): Create got_irelative_.
	(Target_x86_64::register_global_plt_entry): Add symtab and layout
	parameters.
	(Target_x86_64::Scan::global): Use IRELATIVE GOT for IRELATIVE
	reloc.
	(Target_x86_64::do_finalize_sections): Create the __rela_iplt
	symbols if we didn't create an IRELATIVE GOT.
	(Target_x86_64::Relocate::relocate): Use plt_address_for_global and
	plt_address_for_local.
	(Target_x86_64::do_dynsym_value): Use plt_address_for_global.
	* testsuite/ifuncvar1.c: New test file.
	* testsuite/ifuncvar2.c: New test file.
	* testsuite/ifuncvar3.c: New test file.
	* testsuite/Makefile.am (check_PROGRAMS): Add ifuncvar.
	(ifuncvar1_pic.o, ifuncvar2_pic.o, ifuncvar.so): New targets.
	(ifuncvar_SOURCES, ifuncvar_DEPENDENCIES): New variables.
	(ifuncvar_LDFLAGS, ifuncvar_LDADD): New variables.
	* testsuite/Makefile.in: Rebuild.
@
text
@d59 1
a59 2
template<int size, bool big_endian>
class Output_data_got;
d847 1
a847 1
  virtual Output_data_got<size, big_endian>*
@


1.61
log
@	PR gold/12525
	* ehframe.cc (Eh_frame_hdr::get_fde_pc): Handle DW_EH_PE_datarel.
	Assert if we see DW_EH_PE_indirect.
	* target.h (Target::ehframe_datarel_base): New function.
	(Target::do_ehframe_datarel_base): New target function.
	* i386.cc (Target_i386::do_ehframe_datarel_base): New function.
	* x86_64.cc (Target_x86_64::do_ehframe_datarel_base): New
	function.
@
text
@d249 13
a261 11
  // Return the PLT section to use for a global symbol.  This is used
  // for STT_GNU_IFUNC symbols.
  Output_data*
  plt_section_for_global(const Symbol* sym) const
  { return this->do_plt_section_for_global(sym); }

  // Return the PLT section to use for a local symbol.  This is used
  // for STT_GNU_IFUNC symbols.
  Output_data*
  plt_section_for_local(const Relobj* object, unsigned int symndx) const
  { return this->do_plt_section_for_local(object, symndx); }
d507 2
a508 2
  virtual Output_data*
  do_plt_section_for_global(const Symbol*) const
d511 2
a512 2
  virtual Output_data*
  do_plt_section_for_local(const Relobj*, unsigned int) const
d875 2
a876 1
  register_global_plt_entry(unsigned int /* plt_index */,
@


1.60
log
@	* target.h (class Target): Add osabi_ field.
	(Target::osabi): New function.
	(Target::set_osabi): New function.
	(Target::Target): Initialize osabi_.
	(Target::do_adjust_elf_header): Make pure virtual.
	(Sized_target::do_adjust_elf_header): Declare.
	* target.cc (Sized_target::do_adjust_elf_header): New function.
	(class Sized_target): Instantiate all versions.
	* freebsd.h (class Target_freebsd): Remove.
	(Target_selector_freebsd::do_recognize): Call set_osabi on
	Target.
	(Target_selector_freebsd::do_recognize_by_name): Likewise.
	(Target_selector_freebsd::set_osabi): Remove.
	* i386.cc (class Target_i386): Inherit from Sized_target rather
	than Target_freebsd.
	* x86_64.cc (class Target_x86_64): Likewise.
@
text
@d279 9
d533 4
@


1.59
log
@	* target.h (Target::can_check_for_function_pointers): Rewrite.
	Make non-virtual.
	(Target::can_icf_inline_merge_sections): Likewise.
	(Target::section_may_have_icf_unsafe_poineters): Likewise.
	(Target::Target_info): Add can_icf_inline_merge_sections field.
	(Target::do_can_check_for_function_pointers): New virtual
	function.
	(Target::do_section_may_have_icf_unsafe_pointers): Likewise.
	* arm.cc (Target_arm::do_can_check_for_function_pointers): Rename
	from can_check_for_function_pointers, move in file.
	(Target_arm::do_section_may_have_icf_unsafe_pointers): Rename from
	section_may_have_icf_unsafe_poineters, move in file.
	(Target_arm::arm_info): Initialize can_icf_inline_merge_sections.
	* i386.cc (Target_i386::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_i386::can_icf_inline_merge_sections): Remove.
	(Target_i386::i386_info): Initialize
	can_icf_inline_merge_sections.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Initialize can_icf_inline_merge_sections.
	* sparc.cc (Target_sparc::sparc_info) [both version]: Likewise.
	* x86_64.cc (Target_x86_64::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_x86_64::can_icf_inline_merge_sections): Remove.
	(Target_x86_64::x86_64_info): Initialize
	can_icf_inline_merge_sections.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Likewise.
	* icf.cc (get_section_contents): Correct formatting.
@
text
@d378 11
d441 1
a441 1
      are_processor_specific_flags_set_(false)
d473 2
a474 1
  // By default, we do nothing.
d476 1
a476 2
  do_adjust_elf_header(unsigned char*, int) const
  { }
d636 4
d891 4
@


1.58
log
@	* copy-relocs.cc (Copy_relocs::copy_reloc): Call make_copy_reloc
	instead of emit_copy_reloc.
	(Copy_relocs::emit_copy_reloc): Refactor.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* copy-relocs.h (Copy_relocs::emit_copy_reloc): Move to public
	section.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* gold.cc (queue_middle_tasks): Emit old COPY relocations from
	unchanged input files.
	* incremental-dump.cc (dump_incremental_inputs): Print "COPY" flag.
	* incremental.cc (Sized_incremental_binary::do_reserve_layout):
	Reserve BSS space for COPY relocations.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Output_section_incremental_inputs::write_info_blocks): Record
	whether a symbol is copied from a shared object.
	(Sized_incr_dynobj::do_add_symbols): Record COPY relocations.
	* incremental.h (enum Incremental_shlib_symbol_flags): New type.
	(INCREMENTAL_SHLIB_SYM_FLAGS_SHIFT): New constant.
	(Incremental_input_entry_reader::get_output_symbol_index): Add
	is_copy parameter.
	(Incremental_binary::emit_copy_relocs): New function.
	(Incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data member.
	(Sized_incremental_binary::add_copy_reloc): New function.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Copy_reloc): New struct.
	(Sized_incremental_binary::Copy_relocs): New typedef.
	(Sized_incremental_binary::copy_relocs_): New data member.
	* symtab.cc (Symbol_table::add_from_incrobj): Change return type.
	* symtab.h (Symbol_table::add_from_incrobj): Change return type.
	* target.h (Sized_target::emit_copy_reloc): New function.
	* x86_64.cc (Target_x86_64::emit_copy_reloc): New function.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
a72 28
  // Virtual function which is set to return true by a target if
  // it can use relocation types to determine if a function's
  // pointer is taken.
  virtual bool
  can_check_for_function_pointers() const
  { return false; }

  // This function is used in ICF (icf.cc).  This is set to true by
  // the target if a relocation to a merged section can be processed
  // to retrieve the contents of the merged section.
  virtual bool
  can_icf_inline_merge_sections () const
  { return false; }

  // Whether a section called SECTION_NAME may have function pointers to
  // sections not eligible for safe ICF folding.
  virtual bool
  section_may_have_icf_unsafe_pointers(const char* section_name) const
  {
    // We recognize sections for normal vtables, construction vtables and
    // EH frames.
    return (!is_prefix_of(".rodata._ZTV", section_name)
	    && !is_prefix_of(".data.rel.ro._ZTV", section_name)
	    && !is_prefix_of(".rodata._ZTC", section_name)
	    && !is_prefix_of(".data.rel.ro._ZTC", section_name)
	    && !is_prefix_of(".eh_frame", section_name));
  }

d261 18
d399 3
d493 20
@


1.57
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d836 7
@


1.56
log
@	* gold.cc (queue_middle_tasks): Process existing GOT/PLT entries.
	* incremental-dump.cc (dump_incremental_inputs): Mask high-order
	bit when checking got_type.
	* incremental.cc (Sized_incremental_binary::setup_readers):
	Store symbol table and string table locations; initialize bit vector
	of file status flags.
	(Sized_incremental_binary::do_reserve_layout): Set bit flag for
	unchanged files.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::get_symtab_view): Use stored locations.
	(Output_section_incremental_inputs::set_final_data_size): Record
	file index for each input file.
	(Output_section_incremental_inputs::write_got_plt): Store file index
	instead of input entry offset for each GOT entry.
	* incremental.h
	(Incremental_input_entry::Incremental_input_entry): Initialize new
	data member.
	(Incremental_input_entry::set_offset): Store file index.
	(Incremental_input_entry::get_file_index): New function.
	(Incremental_input_entry::file_index_): New data member.
	(Incremental_binary::process_got_plt): New function.
	(Incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data members.
	(Sized_incremental_binary::~Sized_incremental_binary): New destructor.
	(Sized_incremental_binary::set_file_is_unchanged): New function.
	(Sized_incremental_binary::file_is_unchanged): New function.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::file_status_): New data member.
	(Sized_incremental_binary::main_symtab_loc_): New data member.
	(Sized_incremental_binary::main_strtab_loc_): New data member.
	* output.cc (Output_data_got::Got_entry::write): Add case
	RESERVED_CODE.
	(Output_data_got::add_global): Call add_got_entry.
	(Output_data_got::add_global_plt): Likewise.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_global_pair_with_rela): Likewise.
	(Output_data_got::add_local): Call add_got_entry.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_local_pair_with_rela): Likewise.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_section::add_output_section_data): Edit FIXME.
	* output.h
	(Output_section_data_build::Output_section_data_build): New
	constructor with size parameter.
	(Output_data_space::Output_data_space): Likewise.
	(Output_data_got::Output_data_got): Initialize new data member; new
	constructor with size parameter.
	(Output_data_got::add_constant): Call add_got_entry.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(class Output_data_got::Got_entry): Add RESERVED_CODE.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_data_got::free_list_): New data member.
	* target.h (Sized_target::init_got_plt_for_update): New function.
	(Sized_target::register_global_plt_entry): New function.
	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Initialize new data member; call init; add constructor with PLT count.
	(Output_data_plt_x86_64::init): New function.
	(Output_data_plt_x86_64::add_relocation): New function.
	(Output_data_plt_x86_64::reserve_slot): New function.
	(Output_data_plt_x86_64::free_list_): New data member.
	(Target_x86_64::init_got_plt_for_update): New function.
	(Target_x86_64::register_global_plt_entry): New function.
	(Output_data_plt_x86_64::add_entry): Allocate from free list for
	incremental updates.
	(Output_data_plt_x86_64::add_relocation): New function.
	* testsuite/object_unittest.cc (Object_test): Set default options.
@
text
@d48 2
d647 1
a647 1
		    Sized_relobj<size, big_endian>* object,
d672 1
a672 1
	      Sized_relobj<size, big_endian>* object,
d711 1
a711 1
			  Sized_relobj<size, big_endian>* object,
d812 16
@


1.55
log
@	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	global symbol map.
	(Sized_incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incr_relobj::do_add_symbols): Add symbols to global symbol map.
	(Sized_incr_relobj::do_relocate): Remap section indices in incremental
	relocations.
	(Sized_incr_dynobj::do_add_symbols): Add symbols to global symbol map.
	(Sized_incr_dynobj::do_for_all_global_symbols): Remove FIXME.
	(Sized_incr_dynobj::do_for_all_local_got_entries): Likewise.
	* incremental.h
	(Incremental_inputs_reader::global_symbol_reader_at_offset): New
	function.
	(Incremental_binary::apply_incremental_relocs): New function.
	(Incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data member.
	(Sized_incremental_binary::add_global_symbol): New function.
	(Sized_incremental_binary::global_symbol): New function.
	(Sized_incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incremental_binary::symbol_map_): New data member.
	* layout.cc (Layout_task_runner::run): Apply incremental relocations.
	* target.h (Sized_target::apply_relocation): New function.
	* target-reloc.h (apply_relocation): New function.
	* x86_64.cc (Target_x86_64::apply_relocation): New function.
@
text
@d57 2
d800 18
@


1.54
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d798 13
@


1.53
log
@2010-11-08  Doug Kwan  <dougkwan@@google.com>
	    Cary Coutant  <ccoutant@@google.com>

	* arm.cc (Arm_exidx_merge_section::build_contents): New method.
	(Arm_exidx_merge_section::section_contents_): New data member.
	(Arm_input_section::Arm_input_section): Initialize original_contents_.
	(Arm_input_section::~Arm_input_section): De-allocate memory.
	(Arm_input_section::original_contents_): New data member.
	(Arm_exidx_fixup::process_exidx_section): Pass EXIDX section contents
	in parameters instead of calling Object::section_contents without
	locking.
	(Arm_output_section::group_section): New parameter TASK.  Pass it
	to callees that need locking objects.
	(Arm_output_section::fix_exidx_coverage): New parameter TASK.  Use it
	to lock EXIDX input sections.  Fix a formatting issue.  Call
	Arm_exidx_merged_section::build_contents to create merged section
	contents.
	(Arm_output_section::create_stub_group): New parameter TASK.  Use it
	to lock object of stub table owner.
	(Arm_exidx_input_section::Arm_exidx_input_section): Add new parameter
	TEXT_SIZE to initialize data member TEXT_SIZE_.
	(Arm_exidx_input_section::addralign): Fix typo in comment.
	(Arm_exidx_input_section::text_size): New method.
	(Target_arm::do_relax): New parameter TASK.  Pass it to callees
	that require locking objects.  Lock objects before scanning for stubs
	and updating local symbols.
	(Arm_input_section<big_endian>::init): Copy contents of original
	input section.
 	(Arm_input_section<big_endian>::do_write): Use saved contents of
	original input section instead of calling Object::section_contents
	without locking.
	(Arm_exidx_cantunwind::do_fixed_endian_write): Find out text section
	size without calling Object::section_size().
	(Arm_exidx_merged_section::Arm_exidx_merged_section): Add sanity check
	for size.  Allocate a buffer for merged EXIDX entries.
	(Arm_exidx_merged_section::build_contents): New method.
 	(Arm_exidx_merged_section::do_write): Move merge section contents
	building code to Arm_exidx_merged_section::build_contetns.  Write
	out contetns in buffer instead of building it on the fly.
	(Arm_relobj::make_exidx_input_section): Also pass text section size
	to Arm_exidx_input_section constructor.
	(Arm_relobj::do_read_symbols): Fix memory leak.  Fix a formatting issue.
	(Arm_dynobj::do_read_symbols): Fix memory leak.
	* layout.cc (Layout::finalize): Pass TASK to Target::relax().
	* target.h: (class Task): Add forward declaration.
	(Target::relax): Add new parameter TASK and pass it to
	Target::do_relax().
	(Target::do_relax):: New parameter TASK.  Fix a formatting issue.
@
text
@d470 1
a470 1
  // Virtual function which may be overriden by the child class.
d480 1
a480 1
  // Virtual function that must be overidden by a target which uses
d520 1
a520 1
  // Virtual functions which may be overriden by the child class.
d527 1
a527 1
  // Virtual functions which may be overriden by the child class.
d534 1
a534 1
  // Virtual functions which may be overriden by the child class.
d541 1
a541 1
  // Virtual functions which may be overriden by the child class.
d547 1
a547 1
  // Virtual functions which may be overriden by the child class.
d552 1
a552 1
  // Virtual function which may be overriden by the child class.
d557 1
a557 1
  // Virtual function which may be overriden by the child class.
d574 1
a574 1
  // This must be overriden by the child class if it has target-specific
@


1.52
log
@2010-09-28  Sriraman Tallam  <tmsriram@@google.com>

	* target.h (Target::can_icf_inline_merge_sections): New virtual
	function.
	* x86_64.cc (Target__x86_64::can_icf_inline_merge_sections): New
	virtual function.
	* i386.cc (Target_i386::can_icf_inline_merge_sections): New
	virtual function.
	* icf.cc (get_section_contents): Inline merge sections only when
	target allows it.
@
text
@d59 1
d336 1
a336 1
	Layout* layout)
d342 1
a342 1
    return this->do_relax(pass, input_objects, symtab, layout);
d559 1
a559 1
  do_relax(int, const Input_objects*, Symbol_table*, Layout*)
@


1.51
log
@	PR 10893
	* i386.cc (class Output_data_plt_i386): Update declarations.
	Define Global_ifunc and Local_ifunc types.  Add global_ifuncs_ and
	local_ifuncs_ fields.
	(Target_i386::do_plt_section_for_global): New function.
	(Target_i386::do_plt_section_for_local): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Add symtab
	parameter; change all callers.  Initialize global_ifuncs_ and
	local_ifuncs_.  If doing a static link define __rel_iplt_start and
	__rel_iplt_end.
	(Output_data_plt_i386::add_entry): Handle IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): New function.
	(Output_data_plt_i386::do_write): Fix GOT entries for IFUNC
	symbols.
	(Target_i386::make_plt_section): New function, broken out of
	make_plt_entry.  Set sh_info field of .rel.plt to point to .plt.
	(Target_i386::make_plt_entry): Call make_plt_section.
	(Target_i386::make_local_ifunc_plt_entry): New function.
	(Target_i386::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_i386::Scan::local): Handle IFUNC symbols.  Add
	R_386_IRELATIVE to switch.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocatable_size_for_reloc): Add R_386_IRELATIVE to
	switch.
	* x86_64.cc (class Output_data_plt_x86_64): Update declarations.
	(Target_x86_64::do_plt_section_for_global): New function.
	(Target_x86_64::do_plt_section_for_local): New function.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Add symtab
	parameter; change all callers.  If doing a static link define
	__rela_iplt_start and __rela_iplt_end.
	(Output_data_plt_x86_64::add_entry): Handle IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): New function.
	(Target_x86_64::make_plt_section): Set sh_info field of .rel.plt
	to point to .plt.
	(Target_x86_64::make_local_ifunc_plt_entry): New function.
	(Target_x86_64::Scan::check_non_pic): Add R_X86_64_IRELATIVE to
	switch.
	(Target_x86_64::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_x86_64::Scan::local): Handle IFUNC symbols.  Add
	R_X86_64_IRELATIVE to switch.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocatable_size_for_reloc): Add R_X86_64_IRELATIVE to
	switch.
	* target.h (class Target): Add plt_section_for_global and
	plt_section_for_local functions.  Add do_plt_section_for_global
	and do_plt_section_for_local virtual functions.
	* symtab.h (Symbol::needs_plt_entry): Handle IFUNC symbol.  Add
	clarifying comments.
	(Symbol::use_plt_offset): Handle IFUNC symbol.
	* object.cc (Sized_relobj::Sized_relobj): Initialize
	local_plt_offsets_.
	(Sized_relobj::local_has_plt_offset): New function.
	(Sized_relobj::local_plt_offset): New function.
	(Sized_relobj::set_local_plt_offset): New function.
	(Sized_relobj::do_count): Handle IFUNC symbol.
	* object.h (class Symbol_value): Add is_ifunc_symbol_ field.  Take
	a bit away from input_shndx_ field.  Add set_is_func_symbol and
	is_ifunc_symbol functions.
	(class Sized_relobj): Update declarations.  Remove Tls_got_entry
	and Local_tls_got_offsets.  Define Local_plt_offsets.  Add
	local_plt_offsets_ field.
	(Sized_relobj::clear_local_symbols): Clear local_plt_offsets_.
	* output.h (class Output_section_data): Add non-const
	output_section function.
	(class Output_data_got): Update declarations.
	(class Output_data_got::Got_entry): Add use_plt_offset_ field.
	Add use_plt_offset parameter to global and local constructors.
	Change all callers.  Change local_sym_index_ field to 31 bits.
	Change GSYM_CODE and CONSTANT_CODE accordingly.
	* output.cc (Output_data_reloc_base::do_adjust_output_section): If
	doing a static link don't set sh_link field.
	(Output_data_got::Got_entry::write): Use PLT offset if
	appropriate.
	(Output_data_got::add_global_plt): New function.
	(Output_data_got::add_local_plt): New function.
	* target-reloc.h (relocate_section): Handle IFUNC symbol.
	* defstd.cc (in_section): Remove entries for __rel_iplt_start,
	__rel_iplt_end, __rela_iplt_start, and __rela_iplt_end.
	* configure.ac: Set IFUNC automake conditional for glibc >= 2.11.
	* testsuite/Makefile.am: Add a bunch of IFUNC tests, all within
	IFUNC conditional.
	* testsuite/ifunc-sel.h: New file.
	* testsuite/ifuncmain1.c: New file.
	* testsuite/ifuncmain1vis.c: New file.
	* testsuite/ifuncmod1.c: New file.
	* testsuite/ifuncdep2.c: New file.
	* testsuite/ifuncmain2.c: New file.
	* testsuite/ifuncmain3.c: New file.
	* testsuite/ifuncmod3.c: New file.
	* testsuite/ifuncmain4.c: New file.
	* testsuite/ifuncmain5.c: New file.
	* testsuite/ifuncmod5.c: New file.
	* testsuite/ifuncmain6pie.c: New file.
	* testsuite/ifuncmod6.c: New file.
	* testsuite/ifuncmain7.c: New file.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d75 7
@


1.50
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_GOT_PLT.

gold/ChangeLog:

	* arm.cc (Target_arm::got_size): Add const.
	(Target_arm::got_entry_count): New function.
	(Target_arm::plt_entry_count): New function.
	(Target_arm::first_plt_entry_offset): New function.
	(Target_arm::plt_entry_size): New function.
	(Output_data_plt_arm::entry_count): New function.
	(Output_data_plt_arm::first_plt_entry_offset): New function.
	(Output_data_plt_arm::get_plt_entry_size): New function.
	* i386.cc (Target_i386::got_size): Add const.
	(Target_i386::got_entry_count): New function.
	(Target_i386::plt_entry_count): New function.
	(Target_i386::first_plt_entry_offset): New function.
	(Target_i386::plt_entry_size): New function.
	(Output_data_plt_i386::entry_count): New function.
	(Output_data_plt_i386::first_plt_entry_offset): New function.
	(Output_data_plt_i386::get_plt_entry_size): New function.
	* incremental-dump.cc (dump_incremental_inputs): Adjust call to
	find_incremental_inputs_sections.  Dump incremental_got_plt section.
	* incremental.cc: Include target.h.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Add
	parameter.  Adjust all callers.  Find incremental_got_plt section.
	(Incremental_inputs::create_data_sections): Create incremental_got_plt
	section.
	(Output_section_incremental_inputs::set_final_data_size): Calculate
	size of incremental_got_plt section.
	(Output_section_incremental_inputs::do_write): Write the
	incremental_got_plt section.
	(Got_plt_view_info): New struct.
	(Local_got_offset_visitor): New class.
	(Global_got_offset_visitor): New class.
	(Global_symbol_visitor_got_plt): New class.
	(Output_section_incremental_inputs::write_got_plt): New function.
	* incremental.h (Incremental_binary::find_incremental_inputs_sections):
	Add parameter.  Adjust all callers.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Incremental_inputs::got_plt_section): New function.
	(Incremental_inputs::got_plt_section_): New data member.
	(Incremental_got_plt_reader): New class.
	* layout.cc (Layout::create_incremental_info_sections): Add the
	incremental_got_plt section.
	* object.h (Got_offset_list::get_list): New function.
	(Got offset_list::for_all_got_offsets): New function.
	(Sized_relobj::local_got_offset_list): New function.
	* powerpc.cc (Target_powerpc::got_size): Add const.
	(Target_powerpc::got_entry_count): New function.
	(Target_powerpc::plt_entry_count): New function.
	(Target_powerpc::first_plt_entry_offset): New function.
	(Target_powerpc::plt_entry_size): New function.
	(Output_data_plt_powerpc::entry_count): New function.
	(Output_data_plt_powerpc::first_plt_entry_offset): New function.
	(Output_data_plt_powerpc::get_plt_entry_size): New function.
	* sparc.cc (Target_sparc::got_size): Add const.
	(Target_sparc::got_entry_count): New function.
	(Target_sparc::plt_entry_count): New function.
	(Target_sparc::first_plt_entry_offset): New function.
	(Target_sparc::plt_entry_size): New function.
	(Output_data_plt_sparc::entry_count): New function.
	(Output_data_plt_sparc::first_plt_entry_offset): New function.
	(Output_data_plt_sparc::get_plt_entry_size): New function.
	* symtab.h (Symbol::got_offset_list): New function.
	(Symbol_table::for_all_symbols): New function.
	* target.h (Sized_target::got_entry_count): New function.
	(Sized_target::plt_entry_count): New function.
	(Sized_target::plt_entry_size): New function.
	* x86_64.cc (Target_x86_64::got_size): Add const.
	(Target_x86_64::got_entry_count): New function.
	(Target_x86_64::plt_entry_count): New function.
	(Target_x86_64::first_plt_entry_offset): New function.
	(Target_x86_64::plt_entry_size): New function.
	(Output_data_plt_x86_64::entry_count): New function.
	(Output_data_plt_x86_64::first_plt_entry_offset): New function.
	(Output_data_plt_x86_64::get_plt_entry_size): New function.
@
text
@d56 1
d265 12
d478 10
@


1.49
log
@2010-06-25  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::can_check_for_functions_pointers): Return true.
	(Target_arm::section_may_have_icf_unsafe_pointers): New method
	definition.
	(Target_arm::Scan::local_reloc_may_be_function_pointer,
	Target_arm::Scan::global_reloc_may_be_function_pointer): Implement
	target hook to detect function points.
	(Target_arm::Scan::possible_function_pointer_reloc): New method.
	* icf.h (Icf::check_section_for_function_pointers): Change type of
	parameter SECTION_NAME to const reference to std::string.  Use
	target hook to determine if section may have unsafe pointers.
	* target.h (Target::section_may_have_icf_unsafe_pointers): New
	method definition.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d735 32
@


1.48
log
@2010-05-26  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_scan_relocatable_relocs): New class.
	(Target_arm::relocate_special_relocatable): New method.
	(Arm_relocate_functions::arm_branch_common): Handle relocatable link.
	(Arm_relocate_functions::thumb_branch_common): Same.
	(Target_arm::scan_relocatable_relocs): Use Arm_scan_relocatable_relocs
	instead of Default_scan_relocatable_relocs.
	* target-reloc.h (relocate_for_relocatable): Let target handle
	relocation strategy Relocatable_relocs::RELOC_SPECIAL.
	* target.h (Sized_target::relocate_special_relocatable): New method.
@
text
@d74 14
@


1.47
log
@2010-04-07  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Replace "endianity" with "endianness" in comments.
	(Arm_exidx_cantunwind): Ditto.
	(Arm_relobj::Arm_relobj): Initialize merge_flags_and_attribures.
	(Arm_relobj::merge_flags_and_attributes): New method.
	(Arm_relobj::merge_flags_and_attributes_): New data member.
	(Arm_exidx_cantunwind::do_fixed_endian_write): Fix formatting.
	(Arm_relobj::scan_sections_for_stubs): Ditto.
	(Arm_relobj::do_read_symbols): Check to see if we really want to
	merge processor-specific flags and attributes.  Exit early if
	an object is empty except for section names and the undefined symbol.
	(Target_arm::do_finalize_sections): Move check for ELF format to
	Arm_relobj::do_read_symbols.  Merge processor specific flags and
	attributes from a regular object only when we have determined that
	it is aapropriate.  Do not create an .ARM.attributes section in
	output if there is no regular input object.
	(Target_arm::merge_processor_specific_flags): Check
	--warn-mismatch before printing any error.
	(Target_arm::merge_object_attributes): Ditto.
	* gold.cc (queue_middle_tasks): Handle the case in which there is
	no regular object in input.
	* options.cc (General_options::parse_EB): New method.
	(General_options::parse_EL): Same.
	(General_options::General_options): Initialize endianness_.
	* options.h (-EB, -EL, -no-pipeline-knowledge, -p, --warn-mismatch):
	New options.
	(General_options::Endianness): New enum.
	(General_options::endianness): New method.
	(General_options::endianness_): New data member.
	* parameters.cc (Parameters::set_options): Check target endianness.
	(Parameters::set_target_once): Ditto.
	(Parameters::check_target_endianness): New method.
	(parameters_force_valid_target): If either -EL or -EB is specified,
	use it to define endianness of default target.
	* parameters.h (Parameters::check_target_endianness): New method
	declaration.
	* target.h (class Target): Change "endianity" to "endianness"
	in comments.
@
text
@d690 15
d706 15
@


1.46
log
@	* reloc.cc (Sized_relobj::split_stack_adjust_reltype): Call the
	target to ask whether a reference to a symbol requires a stack
	split.
	* target.h (Target::is_call_to_non_split): New function.
	(Target::do_is_call_to_non_split): Declare virtual function.
	* target.cc: Include "symtab.h".
	(Target::do_is_call_to_non_split): New function.
	* i386.cc (Target_i386::do_is_call_to_non_split): New function.
@
text
@d464 1
a464 1
  // different address sizes and endianities.
d547 1
a547 1
  // almost identical except for their sizes and endianity.  We use a template.
@


1.45
log
@2010-02-12  Sriraman Tallam  <tmsriram@@google.com>

	* arm.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* sparc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* powerpc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* i386.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* x86_64.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	(Scan::possible_function_pointer_reloc): New function.
	(Target_x86_64::can_check_for_function_pointers): New function.
	* gc.h (gc_process_relocs): Scan relocation types to determine if
	function pointers were taken for targets that support it.
	* icf.cc (Icf::find_identical_sections): Include functions for
	folding in safe ICF whose pointer is not taken.
	* icf.h (Secn_fptr_taken_set): New typedef.
	(fptr_section_id_): New member.
	(section_has_function_pointers): New function.
	(set_section_has_function_pointers): New function.
	(check_section_for_function_pointers): New function.
	* options.h: Fix comment for safe ICF option.
	* target.h (can_check_for_function_pointers): New function.
	* testsuite/Makefile.am: Add icf_safe_so_test test case.
	Modify icf_safe_test for X86-64.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/icf_safe_so_test.cc: New file.
	* testsuite/icf_safe_so_test.sh: New file.
	* testsuite/icf_safe_test.cc (kept_func_3): New function.
	(main): Change to take pointer to function kept_func_3.
	* testsuite/icf_safe_test.sh (arch_specific_safe_fold): Check if safe
	folding is done correctly for X86-64.
@
text
@d250 8
d451 6
@


1.44
log
@2010-02-02  Doug Kwan  <dougkwan@@google.com>

	* Makefile.am (HFILES): Add arm-reloc-property.h.
	(DEFFILES): New.
 	(TARGETSOURCES): Add arm-reloc-property.cc
 	(ALL_TARGETOBJS): Add arm-reloc-property.$(OBJEXT)
	(libgold_a_SOURCES): $(DEFFILES)
	* Makefile.in: Regenerate.
	* arm-reloc-property.cc: New file.
	* arm-reloc-property.h: New file.
	* arm-reloc.def: New file.
	* arm.cc: Update comments.
	(arm-reloc-property.h): New included header.
	(arm_reloc_property_table): New global variable.
	(Target_arm::do_select_as_default_target): New method definition.
	* configure.tgt (armeb*-*-*,armbe*-*-*,arm*-*-*): Add
	arm-reloc-property to targ_extra_obj.
	* parameters.cc (set_parameters_target): Call
	Target::select_as_default_target().
	* target.h (Target::select_as_default_target): New method definition.
	(Target::do_select_as_default_target): Same.
@
text
@d67 7
@


1.43
log
@	PR 10287
	PR 11063
	* i386.cc (class Target_i386): Change return type of plt_section
	to be non-const.
	(class Output_data_plt_i386): Add tls_desc_rel_ field.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize
	tls_desc_rel_ field.
	(Output_data_plt_i386::rel_tls_desc): New function.
	(Target_i386::rel_tls_desc_section): New function.
	(Target_i386::Scan::local): Rewrite R_386_TLS_GOTDESC handling.
	(Target_i386::Scan::global): For R_386_TLS_GOTDESC put
	R_386_TLS_DESC reloc in rel_tls_desc_section.
	* x86_64.cc (class Target_x86_64): Add tlsdesc_reloc_info_ field.
	Define struct Tlsdesc_info.
	(Target_x86_64::Target_x86_64): Initialize tlsdesc_reloc_info_.
	(Target_x86_64::do_reloc_symbol_index): New function.
	(Target_x86_64::add_tlsdesc_info): New function.
	(class Output_data_plt_x86_64): Add tlsdesc_rel_ field.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Initialize
	tlsdesc_rel_ field.
	(Output_data_plt_x86_64::rela_plt): Rename from rel_plt.  Change
	all callers.
	(Output_data_plt_x86_64::rela_tlsdesc): New function.
	(Target_x86_64::rela_tlsdesc_section): New function.
	(Target_x86_64::Scan::local): Rewrite R_X86_64_GOTPC32_TLSDESC
	handling.
	(Target_x86_64::Scan::global): For R_X86_64_GOTPC32_TLSDESC put
	(Target_x86_64::do_reloc_addend): New function.
	R_X86_64_TLSDESC reloc in rela_tlsdesc_section.
	* output.h (class Output_reloc) [SHT_REL]: Add new constructor
	declarations.  Define TARGET_CODE.  Add arg field to u1_ union.
	(Output_reloc::type): New function.
	(Output_reloc::is_local_section_symbol): Check for TARGET_CODE.
	(Output_reloc::is_target_specific): New function.
	(Output_reloc::target_arg): New function.
	(class Output_reloc) [SHT_RELA]: Add four new constructors for
	absolute relocs and target specific relocs.
	(class Output_data_reloc) [SHT_REL]: Add add_absolute and
	add_target_specific.
	(class Output_data_reloc) [SHT_RELA]: Likewise.
	* output.cc (Output_reloc::Output_reloc): Add four new versions
	for absolute relocs and target specific relocs.
	(Output_reloc::set_needs_dynsym_index): Add TARGET_CODE case.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Check that local_sym_index_
	is not TARGET_CODE or 0.
	(Output_reloc::symbol_value): Likewise.
	(Output_reloc::write) [SHT_RELA]: Call target for target specific
	reloc.
	* target.h (class Target): Add reloc_symbol_index and reloc_addend
	functions.  Add do_reloc_symbol_index and do_reloc_addend virtual
	functions.
	* layout.cc (add_target_dynamic_tags): Use output section for
	DT_PLTRELSZ and DT_JMPREL.
@
text
@d328 6
d519 5
@


1.42
log
@2009-12-05  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:

	* arm.h: Define enums for Tag_CPU_arch EABI attribute.

gold/ChangeLog:
	* arm.cc (Target_arm::arm_info): Initialize new fields
	attributes_section and attributes_vendor.
	* i386.cc (Target_i386::i386_info): Same.
	* object.cc (Sized_relobj::do_layout): Skip attribute section.
	* gold/powerpc.cc (Target_powerpc::powerpc_info): Initialize new
	fields attributes_section and attributes_vendor.
 	* sparc.cc (Target_sparc::sparc_info): Same.
	* target.h (Target::attributes_section, Target::attributes_vendor,
	Target::is_attributes_section, Target::attribute_arg_type,
	Target::attributes_order): New method definitions.
	(Target::Target_info::attributes_section,
	Target::Target_info::attributes_vendor): New fields.
	(Target::do_attribute_arg_type, Target::do_attributes_order): New
	virtual method definitions.
	* x86_64.cc (Target_x86_64::x86_64_info): Initialize new fields
	attributes_section and attributes_vendor.
	* testsuite/testfile.cc (Target_test::test_target_info): Same.
@
text
@d233 10
d418 12
@


1.41
log
@2009-12-03  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Remove comment about missing .ARM.exidx section symbols.
	(Target_arm::do_finalize_sections): Add parameter for symbol table
	pointer.  Add __exidx_start and __exidx_end symbols as appropriate.
	* i386.cc (Target_i386::do_finalize_sections): Add an additional
	parameter for symbol table pointer.
	* layout.cc (Layout::finalize): Call Target::finalize_sections with
	an additional parameter for a pointer to symbol table.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add an additional
	parameter for a symbol table pointer.
	* sparc.cc (Target_sparc::do_finalize_sections): Ditto.
	* target.h (Target::finalize_sections, Target::do_finalize_sections):
	Ditto.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add an additional
	parameter for a symbol table pointer.
@
text
@d285 33
d359 4
d480 11
@


1.40
log
@2009-10-30  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:
	* arm.h (EF_ARM_BE8, EF_ARM_EABIMASK, EF_ARM_EABI_UNKNOWN,
	EF_ARM_EABI_VER1, EF_ARM_EABI_VER2, EF_ARM_EABI_VER3,
	EF_ARM_EABI_VER4, EF_ARM_EABI_VER5): New enums for processor-specific
	flags.
	(arm_eabi_version): New inline function.
	* elfcpp.h: Add a comment about DT_ENCODING.

gold/ChangeLog:
	* arm.cc (Arm_relobj::processor_specific_flags): New method
	definition.
	(Arm_relobj::do_read_symbols): New method declaration.
	(Arm_relobj::processor_specific_flags_): New data member declaration.
	(Arm_dynobj): New class definition.
	(Target_arm::do_finalize_sections): Add input_objects parameter.
	(Target_arm::do_adjust_elf_header): New method declaration.
	(Target_arm::are_eabi_versions_compatible,
	(Target_arm::merge_processor_specific_flags): New method declaration.
	(Target_arm::do_make_elf_object): New overloaded method definitions
	and declaration.
	(Arm_relobj::do_read_symbols): New method definition.
	(Arm_dynobj::do_read_symbols): Ditto.
	(Target_arm::do_finalize_sections): Add input_objects parameters.
	Merge processor-specific flags from all input objects.
	(Target_arm::are_eabi_versions_compatible,
	Target_arm::merge_processor_specific_flags,
	Target_arm::do_adjust_elf_header, Target_arm::do_make_elf_object):
	New method definitions.
	* i386.cc (Target_i386::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* layout.cc (Layout::finalize): Pass input objects to target's.
	finalize_sections function.
	* output.cc (Output_file_header::do_sized_write): Set ELF file
	header's processor-specific flags.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* sparc.cc (Target_sparc::do_finalize_sections): Same.
	* target.h (Input_objects): New forward class declaration.
	(Target::processor_specific_flags,
	Target::are_processor_specific_flags_sect): New method definitions.
	(Target::finalize_sections): Add input_objects parameter.
	(Target::Target): Initialize processor_specific_flags_ and
	are_processor_specific_flags_set_.
	(Target::do_finalize_sections): Add unnamed Input_objects pointer type
	parameter.
	(Target::set_processor_specific_flags): New method definition.
	(Target::processor_specific_flags_,
	Target::are_processor_specific_flags_set_): New data member
	declarations.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
@
text
@d197 3
a199 2
  finalize_sections(Layout* layout, const Input_objects* input_objects)
  { return this->do_finalize_sections(layout, input_objects); }
d340 1
a340 1
  do_finalize_sections(Layout*, const Input_objects*)
@


1.39
log
@	* object.h (class Relobj): Drop options parameter from
	gc_process_relocs, scan_relocs, relocate, do_gc_process_relocs,
	do_scan_relocs, do_relocate.  Change all callers.
	(class Sized_relobj): Drop options parameters from
	do_gc_process_relocs, do_scan_relocs, do_relocate,
	do_relocate_sections, relocate_sections, emit_relocs_scan,
	emit_relocs_scan_reltype.  Change all callers.
	(struct Relocate_info): Remove options field and all references to
	it.
	* reloc.h (class Read_relocs): Remove options constructor
	parameter and options_ field.  Change all callers.
	(class Gc_process_relocs, class Scan_relocs): Likewise.
	(class Relocate_task): Likewise.
	* target-reloc.h (scan_relocs): Remove options parameter.  Change
	all callers.
	(scan_relocatable_relocs): Likewise.
	* target.h (class Sized_target): Remove options parameter from
	gc_process_relocs, scan_relocs, scan_relocatable_relocs.  Change
	all callers.
	* gc.h (gc_process_relocs): Remove options parameter.  Change all
	callers.
	* arm.cc: Update functions to remove options parameters.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* testsuite/testfile.cc: Likewise.
@
text
@d57 1
d83 10
d197 2
a198 2
  finalize_sections(Layout* layout)
  { return this->do_finalize_sections(layout); }
d328 2
a329 1
    : pti_(pti)
d339 1
a339 1
  do_finalize_sections(Layout*)
d379 8
d456 4
@


1.38
log
@2009-10-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::make_output_section): Call target hook to make
	ordinary output section.
	(Layout::finalize): Adjust parameter list of call the
	Target::may_relax().
	* layout.h (class Layout::section_list): New method.
	* merge.h (Output_merge_base::entsize): Change visibility to public.
	(Output_merge_base::is_string, Output_merge_base::do_is_string):
	New methods.
	(Output_merge_string::do_is_string): New method.
	* object.cc (Sized_relobj::do_setup): renamed from
	Sized_relobj::set_up.
	* object.h (Sized_relobj::adjust_shndx,
	Sized_relobj::initializ_input_to_output_maps,
	Sized_relobj::free_input_to_output_maps): Change visibilities to
	protected.
	(Sized_relobj::setup): Virtualize.
	(Sized_relobj::do_setup): New method declaration.
	(Sized_relobj::invalidate_section_offset,
	Sized_relobj::do_invalidate_section_offset): New method decfinitions.
	(Sized_relobj::elf_file, Sized_relobj::local_values): New methods.
	* options.cc (parse_int): New function.
	* options.h (parse_int): New declaration.
	(DEFINE_int): New macro.
	(stub_group_size): New option.
	* output.cc (Output_section::Output_section): Initialize memebers
	merge_section_map_, merge_section_by_properties_map_,
	relaxed_input_section_map_, is_relaxed_input_section_map_valid_.
	(Output_section::add_input_section): Handled deferred code-fill
	generation and remove an old comment.
	(Output_section::add_relaxed_input_section): New method definition.
	(Output_section::add_merge_input_section): Use merge section by
	properties map to speed to search.  Update merge section maps
	as appropriate.
	(Output_section::build_relaxation_map): New method definition.
	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Same.
	(Output_section::relax_input_section): Renamed to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of pointers to relaxed sections.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section): New method definitions.
	(Output_section::is_input_address_mapped,
	Output_section::output_offset, Output_section::output_address):
	Use output section data maps to speed up searching.
	(Output_section::find_starting_output_address): Add comments.
	(Output_section::do_write,
	Output_section::write_to_postprocessing_buffer): Do code-fill
	generation as appropriate.
	(Output_section::get_input_sections): Invalidate relaxed input section
	map.
	(Output_section::restore_states): Adjust type of checkpoint .
	Invalidate relaxed input section map.
	* output.h (Output_merge_base): New class declaration.
	(Input_section_specifier): New class defintion.
	(class Output_relaxed_input_section) Change base class to
	Output_section_data_build.
	(Output_relaxed_input_section::Output_relaxed_input_section): Adjust
	base class initializer.
	(Output_section::add_relaxed_input_section): New method declaration.
	(Output_section::Input_section): Change visibility to protected.
     	(Output_section::Input_section::relobj,
	Output_section::Input_section::shndx): Handle relaxed input sections.
	Output_section::input_sections) Change visibility to protected.  Also
	define overload to return a non-const pointer.
	(Output_section::Merge_section_properties): New class defintion.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Relaxation_map): New types.
	(Output_section::relax_input_section): Rename method to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of relaxed section pointers.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section,
	Output_section::build_relaxation_map,
	Output_section::convert_input_sections_in_list_to_relaxed_sections):
	New method declarations.
	(Output_section::merge_section_map_
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_,
	Output_section::generate_code_fills_at_write_): New data members.
	* script-sections.cc
	(Output_section_element_input::set_section_addresses): Call
	current_data_size and addralign methods of relaxed input sections.
	(Orphan_output_section::set_section_addresses): Call current_data_size
	and addralign methods of relaxed input sections.
	* symtab.cc (Symbol_table::compute_final_value): Extract template
	from the body of Symbol_table::sized_finalize_symbol.
	(Symbol_table::sized_finalized_symbol): Call
	Symbol_table::compute_final_value.
	* symtab.h (Symbol_table::Compute_final_value_status): New enum type.
	(Symbol_table::compute_final_value): New templated method declaration.
	* target.cc (Target::do_make_output_section): New method defintion.
	* target.h (Target::make_output_section): New method declaration.
	(Target::relax): Add more parameters for input objects, symbol table
	and layout.  Adjust call to do_relax.
	(Target::do_make_output_section): New method declaration.
	(Target::do_relax): Add parameters for input objects, symbol table
	and layout.
@
text
@a43 1
class General_options;
d469 11
a479 12
  gc_process_relocs(const General_options& options,
	      Symbol_table* symtab,
	      Layout* layout,
	      Sized_relobj<size, big_endian>* object,
	      unsigned int data_shndx,
	      unsigned int sh_type,
	      const unsigned char* prelocs,
	      size_t reloc_count,
	      Output_section* output_section,
	      bool needs_special_offset_handling,
	      size_t local_symbol_count,
	      const unsigned char* plocal_symbols) = 0;
d482 7
a488 7
  // required for the symbol.  OPTIONS is the command line options.
  // SYMTAB is the symbol table.  OBJECT is the object in which the
  // section appears.  DATA_SHNDX is the section index that these
  // relocs apply to.  SH_TYPE is the type of the relocation section,
  // SHT_REL or SHT_RELA.  PRELOCS points to the relocation data.
  // RELOC_COUNT is the number of relocs.  LOCAL_SYMBOL_COUNT is the
  // number of local symbols.  OUTPUT_SECTION is the output section.
d494 1
a494 2
  scan_relocs(const General_options& options,
	      Symbol_table* symtab,
d533 1
a533 2
  scan_relocatable_relocs(const General_options& options,
			  Symbol_table* symtab,
@


1.37
log
@	* options.h (class General_options): Define
	split_stack_adjust_size parameter.
	* object.h (class Object): Add uses_split_stack_ and
	has_no_split_stack_ fields.  Add uses_split_stack and
	has_no_split_stack accessor functions.  Declare
	handle_split_stack_section.
	(class Reloc_symbol_changes): Define.
	(class Sized_relobj): Define Function_offsets.  Declare
	split_stack_adjust, split_stack_adjust_reltype, and
	find_functions.
	* object.cc (Object::handle_split_stack_section): New function.
	(Sized_relobj::do_layout): Call handle_split_stack_section.
	* dynobj.cc (Sized_dynobj::do_layout): Call
	handle_split_stack_section.
	* reloc.cc (Sized_relobj::relocate_sections): Call
	split_stack_adjust for executable sections in split_stack
	objects.  Pass reloc_map to relocate_section.
	(Sized_relobj::split_stack_adjust): New function.
	(Sized_relobj::split_stack_adjust_reltype): New function.
	(Sized_relobj::find_functions): New function.
	* target-reloc.h: Include "object.h".
	(relocate_section): Add reloc_symbol_changes parameter.  Change
	all callers.
	* target.h (class Target): Add calls_non_split method.  Declare
	do_calls_non_split virtual method.  Declare match_view and
	set_view_to_nop.
	* target.cc: Include "elfcpp.h".
	(Target::do_calls_non_split): New function.
	(Target::match_view): New function.
	(Target::set_view_to_nop): New function.
	* gold.cc (queue_middle_tasks): Give an error if mixing
	split-stack and non-split-stack objects with -r.
	* i386.cc (Target_i386::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_i386::do_calls_non_split): New function.
	* x86_64.cc (Target_x86_64::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_x86_64::do_calls_non_split): New function.
	* arm.cc (Target_arm::relocate_section): Add reloc_symbol_changes
	parameter.
	* powerpc.cc (Target_powerpc::relocate_section): Add
	reloc_symbol_changes parameter.
	* sparc.cc (Target_sparc::relocate_section): Add
	reloc_symbol_changes parameter.
	* configure.ac: Call AM_CONDITIONAL for the default target.
	* configure: Rebuild.
	* testsuite/Makefile.am (TEST_AS): New variable.
	(check_SCRIPTS): Add split_i386.sh and split_x86_64.sh.
	(check_DATA): Add split_i386 and split_x86_64 files.
	(SPLIT_DEFSYMS): Define.
	(split_i386_[1234n].o): New targets.
	(split_i386_[124]): New targets.
	(split_i386_[1234r].stdout): New targets.
	(split_x86_64_[1234n].o): New targets.
	(split_x86_64_[124]): New targets.
	(split_x86_64_[1234r].stdout): New targets.
	(MOSTLYCLEANFILES): Add new executables.
	* testsuite/split_i386.sh: New file.
	* testsuite/split_x86_64.sh: New file.
	* testsuite/split_i386_1.s: New file.
	* testsuite/split_i386_2.s: New file.
	* testsuite/split_i386_3.s: New file.
	* testsuite/split_i386_4.s: New file.
	* testsuite/split_i386_n.s: New file.
	* testsuite/split_x86_64_1.s: New file.
	* testsuite/split_x86_64_2.s: New file.
	* testsuite/split_x86_64_3.s: New file.
	* testsuite/split_x86_64_4.s: New file.
	* testsuite/split_x86_64_n.s: New file.
	* testsuite/testfile.cc (Target_test): Update relocation_section
	function.
	* testsuite/Makefile.in: Rebuild.
@
text
@d245 6
d264 2
a265 1
  relax(int pass)
d271 2
a272 2
    return this->do_relax(pass);
  }
d396 5
d408 1
a408 1
  do_relax(int)
@


1.36
log
@2009-09-17  Doug Kwan  <dougkwan@@google.com>

	* debug.h (DEBUG_RELAXATION): New constant.
	(DEBUG_ALL): Add DEBUG_RELAXATION.
	(debug_string_to_enum): Add relaxation debug option.
	* layout.cc
	(Layout::Relaxation_debug_check::check_output_data_for_reset_values,
	Layout::Relaxation_debug_check::read_sections,
	Layout::Relaxation_debug_check::read_sections): New method definitions.
	(Layout::Layout): Initialize data members
	record_output_section_data_from_scrips_,
	script_output_section_data_list_ and relaxation_debug_check_.
	(Layout::save_segments, Layout::restore_segments,
	Layout::clean_up_after_relaxation, Layout::prepare_for_relaxation,
	Layout::relaxation_loop_body): New method definitions.
	(Layout::finalize): Support relaxation.  Move section layout code to
	Layout::relaxation_loop_body.
	(Layout::set_asection_address_from_script): Move code for orphan
	section placement out.
	(Layout::place_orphan_sections_in_script): New method definition.
	* layout.h (Output_segment_headers, Output_file_header):
	New forward class declarations.
	(Layout::~Layout): Define.
	(Layout::new_output_section_data_from_script): New method definition.
	(Layout::place_orphan_sections_in_script): New method declaration.
	(Layout::Segment_states): New type declaration.
	(Layout::save_segments, Layout::restore_segments,
	Layout::clean_up_after_relaxation, Layout::prepare_for_relaxation,
	Layout::relaxation_loop_body): New method declarations.
	(Layout::Output_section_data_list): New type declaration.
	(Layout::Relaxation_debug_check): New class definition.
	(Layout::record_output_section_data_from_script_,
	Layout::script_output_section_data_list_, Layout::segment_states_,
	Layout::relaxation_debug_check_): New data members.
	* output.cc: (Output_section_headers::do_size): New method definition.
	(Output_section_headers::Output_section_headers): Move size
	computation to Output_section_headers::do_size.
	(Output_segment_headers::do_size): New method definition.
	(Output_file_header::Output_file_header): Move size computation to
	Output_file_header::do_size and call it.
	(Output_file_header::do_size): New method definition.
	(Output_data_group::Output_data_group): Adjust call to
	Output_section_data.
	(Output_data_dynamic::set_final_data_size): Add DT_NULL tag only once.
	(Output_symtab_xindex::do_write): Add array bound check.
 	(Output_section::Input_section::print_to_mapfile): Handle
	RELAXED_INPUT_SECTION_CODE.
	(Output_section::Output_section): Initialize data member checkpoint_.
	(Output_section::~Output_section): Delete checkpoint object pointed
	by checkpoint_.
	(Output_section::add_input_section): Always add an Input_section if
	relaxing.
	(Output_section::add_merge_input_section): Add assert.
	(Output_section::relax_input_section): New method definition.
	(Output_section::set_final_data_size): Set load address to zero for
	an unallocated section.
	(Output_section::do_address_and_file_offset_have_reset_values):
	New method definition.
	(Output_section::Input_section_sort_enty::Input_section_sort_enty):
	Handle relaxed input section.
	(Output_section::sort_attached_input_sections): Checkpoint input
	section list lazily.
	(Output_section::get_input_sections): Change type of input_sections to
	list of Simple_input_section pointers.  Checkpoint input section list
	lazily.  Also handle relaxed input sections.
	(Output_section::add_input_section_for_script): Take a reference to
	a Simple_input_section object instead of Relobj pointer and section
	index as parameter.  Handle relaxed input sections.
	(Output_section::save_states, Output_section::restore_states): New
	method definitions.
	* output.h (Output_data::Output_data): Initialize is_data_size_fixed_.
	(Output_data::is_data_size_fixed): New method definition.
	(Output_data::reset_addresss_and_file_offset): Do not reset data size
	if it is fixed.
	(Output_data::address_and_file_offset_have_reset_values): New method
	definition.
	(Output_data::do_address_and_file_offset_have_reset_values): New method
	definition.
	(Output_data::set_data_size): Check that data size is not fixed.
	(Output_data::fix_data_size): New method definition.
	(Output_data::is_data_size_fixed_): New data member.
	(Output_section_headers::set_final_data_size): New method definition.
	(Output_section_headers::do_size): New method declaration.
	(Output_segment_headers::set_final_data_size): New method definition.
	(Output_segment_headers::do_size): New method declaration.
	(Output_file_header::set_final_data_size)::New method definition.
	(Output_file_header::do_size)::New method declaration.
	(Output_section_data::Output_section_data): Add new parameter
	is_data_size_fixed and use it to fix data size.
	(Output_data_const::Output_data_const): Adjust call to base class
	constructor and fix data size.
	(Output_data_const_buffer::Output_data_const_buffer): Adjust call to
	base class constructor and fix data size.
	(Output_data_fixed_space::Output_data_fixed_space): Adjust call to
	base class constructor and fix data size.
	(Output_data_zero_fill::Output_data_zero_fill): Adjust call to base
	class constructor and fix data size.
	(Output_data_group::set_final_data_size): New method definition.
	(Output_data_dynamic::Dynamic_entry::tag): New method definition.
	(Output_symtab_xindex::Output_symtab_xindex): Adjust call to base
	class constructor and fix data size.
	(Output_relaxed_input_section): New class definition.
	(Output_section::Simple_input_section): New class definition.
	(Output_section::get_input_sections): Adjust parameter list.
	(Output_section::add_input_section_for_script): Same.
	(Output_section::save_states, Output_section::restore_states,
	Output_section::do_address_and_file_offset_have_reset_values,
	(Output_section::Input_section::Input_section): Handle
	RELAXED_INPUT_SECTION_CODE.  Add new overload for
	Output_relaxed_input_section.
	(Output_section::Input_section::is_input_section,
	Output_section::Input_section::set_output_section): Handle relaxed
	input section.
	(Output_section::Input_section::is_relaxed_input_section,
	Output_section::Input_section::output_section_data,
	Output_section::Input_section::relaxed_input_section): New method
	definitions.
	(Output_section::Input_section::RELAXED_INPUT_SECTION_CODE): New enum
	value.
	(Output_section::Input_section::u1_): Update comments.
	(Output_section::Input_section::u2_): Add new union member poris.
	(Output_section::Checkpoint_output_section): New classs definition.
	(Output_section::relax_input_section): New method declaration.
	(Output_section::checkpoint_): New data member.
	(Output_segment): Update comments.
	(Output_segment::Output_segment): Un-privatize copy constructor.
	(Output_segment::operator=): Un-privatize.
	* script-sections.cc (Output_section_element::Input_section_list):
	Change element type to Output_section::Simple_input_section.
	(Output_section_element_dot_assignment::set_section_addresses):
	Register output section data for relaxation clean up.
	(Output_data_exression::Output_data_expression): Adjust call to base
	constructor to fix data size.
	(Output_section_element_data::set_section_addresses): Register
	Output_data_expression object for relaxation clean up.
	(struct Input_section_info): Replace Relobj pointer and section index
	pair with Output_section::Simple_input_section and Convert struct to a
	class.
	(Input_section_sorter::operator()): Adjust access to
	Input_section_info data member to use accessors.
	(Output_section_element_input::set_section_addresses): Use layout
	parameter.  Adjust code to use Output_section::Simple_input_section
	and Input_secction_info classes.  Register filler for relaxation
	clean up.
	(Orphan_output_section::set_section_addresses): Replace Relobj pointer
	and section index pair with Output_section::Simple_input_section
	class.  Adjust code accordingly.
	(Phdrs_element::release_segment): New method definition.
	(Script_sections::attach_sections_using_phdrs_clause): Do not modify
	segment list.
	(Script_sections::release_segments): New method definition.
	* gold/script-sections.h (Script_sections::release_segments): New
	method declaration.
	* gold/target.h (Target::may_relax, Target::relax,
	Target::do_may_relax, Target::do_relax): New method definitions.
@
text
@d46 1
d52 1
d222 16
d265 1
a265 1
  } 
d352 6
d360 1
a360 1
  
d399 12
d517 2
a518 1
		   section_size_type view_size) = 0;
@


1.35
log
@2009-08-18  Doug Kwan  <dougkwan@@google.com>

	* dynobj.cc (Sized_dynobj::setup): Take a Target object instead of
	an elcpp::Ehdr as parameter.  Adjust call to set_target.
	* dynobj.h (Sized_dynobj::setup): Take a Target object instead of
	an elfcpp::Ehdr as parameter.
	* object.cc (Object::set_target): Remove the version that looks up
	a target and sets it.
	(Sized_relobj::setup): Take a Target object instead of
	an elfcpp::Ehdr as parameter.  Adjust call to set_target.
	(make_elf_sized_object): Find target and ask target to
	make an ELF object.
	* object.h: (Object::set_target): Remove the version that looks up
	a target and sets it.
	(Sized_relobj::setup): Take a Target object instead of
	an elfcpp:Ehdr as parameter.
	* target.cc: Include dynobj.h.
	(Target::do_make_elf_object_implementation): New.
 	(Target::do_make_elf_object): New.
	* target.h (Target::make_elf_object): New template declaration.
	(Target::do_make_elf_object): New method declarations.
	(Target::do_make_elf_object_implementation): New template declaration.
@
text
@d39 1
d227 22
d365 10
@


1.35.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a38 1
#include "debug.h"
a44 1
class Relobj;
a49 1
class Reloc_symbol_changes;
a218 16
  // A function starts at OFFSET in section SHNDX in OBJECT.  That
  // function was compiled with -fsplit-stack, but it refers to a
  // function which was compiled without -fsplit-stack.  VIEW is a
  // modifiable view of the section; VIEW_SIZE is the size of the
  // view.  The target has to adjust the function so that it allocates
  // enough stack.
  void
  calls_non_split(Relobj* object, unsigned int shndx,
		  section_offset_type fnoffset, section_size_type fnsize,
		  unsigned char* view, section_size_type view_size,
		  std::string* from, std::string* to) const
  {
    this->do_calls_non_split(object, shndx, fnoffset, fnsize, view, view_size,
			     from, to);
  }

a225 29
  // Make an output section.
  Output_section*
  make_output_section(const char* name, elfcpp::Elf_Word type,
		      elfcpp::Elf_Xword flags)
  { return this->do_make_output_section(name, type, flags); }

  // Return true if target wants to perform relaxation.
  bool
  may_relax() const
  {
    // Run the dummy relaxation pass twice if relaxation debugging is enabled.
    if (is_debugging_enabled(DEBUG_RELAXATION))
      return true;

     return this->do_may_relax();
  }

  // Perform a relaxation pass.  Return true if layout may be changed.
  bool
  relax(int pass, const Input_objects* input_objects, Symbol_table* symtab,
	Layout* layout)
  {
    // Run the dummy relaxation pass twice if relaxation debugging is enabled.
    if (is_debugging_enabled(DEBUG_RELAXATION))
      return pass < 2;

    return this->do_relax(pass, input_objects, symtab, layout);
  } 

a310 6
  // Virtual function which may be overridden by the child class.
  virtual void
  do_calls_non_split(Relobj* object, unsigned int, section_offset_type,
		     section_size_type, unsigned char*, section_size_type,
		     std::string*, std::string*) const;

d313 1
a313 1

a341 27
  // Virtual functions which may be overriden by the child class.
  virtual Output_section*
  do_make_output_section(const char* name, elfcpp::Elf_Word type,
			 elfcpp::Elf_Xword flags);

  // Virtual function which may be overriden by the child class.
  virtual bool
  do_may_relax() const
  { return parameters->options().relax(); }

  // Virtual function which may be overriden by the child class.
  virtual bool
  do_relax(int, const Input_objects*, Symbol_table*, Layout*)
  { return false; }

  // A function for targets to call.  Return whether BYTES/LEN matches
  // VIEW/VIEW_SIZE at OFFSET.
  bool
  match_view(const unsigned char* view, section_size_type view_size,
	     section_offset_type offset, const char* bytes, size_t len) const;

  // Set the contents of a VIEW/VIEW_SIZE to nops starting at OFFSET
  // for LEN bytes.
  void
  set_view_to_nop(unsigned char* view, section_size_type view_size,
		  section_offset_type offset, size_t len) const;

d448 1
a448 2
		   section_size_type view_size,
		   const Reloc_symbol_changes*) = 0;
@


1.34
log
@	* layout.cc (Layout::make_output_section): Call
	Target::new_output_section.
	(Layout::attach_allocated_section_to_segment): Put large section
	sections in a separate load segment with the large segment flag
	set.
	(Layout::segment_precedes): Sort large data segments after other
	load segments.
	(align_file_offset): New static function.
	(Layout::set_segment_offsets): Use align_file_offset.
	* output.h (class Output_section): Add is_small_section_ and
	is_large_section_ fields.
	(Output_section::is_small_section): New function.
	(Output_section::set_is_small_section):  New function.
	(Output_section::is_large_section): New function.
	(Output_section::set_is_large_section): New function.
	(Output_section::is_large_data_section): New function.
	(class Output_segment): Add is_large_data_segment_ field.
	(Output_segment::is_large_data_segment): New function.
	(Output_segment::set_is_large_data_segment): New function.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_segment::Output_segment): Likewise.
	(Output_segment::add_output_section): Add assertion that large
	data sections always go in large data segments.  Force small data
	sections to the end of the list of data sections.  Force small BSS
	sections to the start of the list of BSS sections.  For large BSS
	sections to the end of the list of BSS sections.
	* symtab.h (class Symbol): Declare is_common_shndx.
	(Symbol::is_defined): Check Symbol::is_common_shndx.
	(Symbol::is_common): Likewise.
	(class Symbol_table): Define enum Commons_section_type.  Update
	declarations.  Add small_commons_ and large_commons_ fields.
	* symtab.cc (Symbol::is_common_shndx): New function.
	(Symbol_table::Symbol_table): Initialize new fields.
	(Symbol_table::add_from_object): Put small and large common
	symbols in the right list.
	(Symbol_table::sized_finalized_symbol): Check
	Symbol::is_common_shndx.
	(Symbol_table::sized_write_globals): Likewise.
	* common.cc (Symbol_table::do_allocate_commons): Allocate new
	common symbol lists.  Don't call do_allocate_commons_list if the
	list is empty.
	(Symbol_table::do_allocate_commons_list): Remove is_tls
	parameter.  Add comons_section_type parameter.  Change all
	callers.  Handle small and large common symbols.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Check
	Symbol::is_common_shndx.
	* resolve.cc (symbol_to_bits): Likewise.
	* target.h (Target::small_common_shndx): New function.
	(Target::small_common_section_flags): New function.
	(Target::large_common_shndx): New function.
	(Target::large_common_section_flags): New function.
	(Target::new_output_section): New function.
	(Target::Target_info): Add small_common_shndx, large_common_shndx,
	small_common_section_flags, and large_common_section_flags
	fields.
	(Target::do_new_output_section): New virtual function.
	* arm.cc (Target_arm::arm_info): Initialize new fields.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Likewise.
	* sparc.c (Target_sparc::sparc_info) [all versions]: Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	(Target_x86_64::do_new_output_section): New function.
	* configure.ac: Define conditional MCMODEL_MEDIUM.
	* testsuite/Makefile.am (check_PROGRAMS): Add large.
	(large_SOURCES, large_CFLAGS, large_DEPENDENCIES): Define.
	(large_LDFLAGS): Define.
	* testsuite/large.c: New file.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Initialize new fields.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d219 7
d311 31
d343 8
@


1.33
log
@2009-06-05  Doug Kwan  <dougkwan@@google.com>

	* Makefile.am (CCFILES): Add target.cc.
	* Makefile.in: Regenerate.
	* i386.cc (class Target_i386): Define new virtual method to
	override do_is_local_label_name in parent.
	* object.cc (Sized_relobj::do_count_local_symbols): Discard
	local symbols if --discard-locals or -X is given.
	* options.h (class General_options): Declare new options
	'--discard-locals' and '-X' for discarding locals.
	* target.h (class Target): Define new methods is_local_label_name.
	Declare new virtual method do_is_local_label_name.
	* target.cc: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add discard_locals_test.
	(check_SCRIPTS): Add discard_locals_test.sh.
	(check_DATA): Add discard_local_tests.syms.
	(discard_locals_test_SOURCES, discard_locals_test_LDFLAGS): Define.
	(discard_local_tests.syms, discard_locals_test.o): New make rules.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/discard_locals_test.c: New file.
	* testsuite/discard_locals_test.sh: Same.
@
text
@d144 37
d250 10
d268 5
@


1.32
log
@2009-03-23  Ian Lance Taylor  <iant@@google.com>

	* freebsd.h: New file.
	* i386.cc: Include "freebsd.h".
	(Target_i386): Derive from Target_freebsd rather than
	Sized_target.
	(Target_selector_i386): Derive from Target_selector_freebsd rather
	than Target_selector.
	* x86_64.cc: Include "freebsd.h".
	(Target_x86_64): Derive from Target_freebsd rather than
	Sized_target.
	(Target_selector_x86_64): Derive from Target_selector_freebsd
	rather than Target_selector.
	* target.h (class Target): Add adjust_elf_header and
	do_adjust_elf_header.
	* output.cc (Output_file_header:: do_sized_write): Call target
	adjust_elf_header routine.
	* configure.tgt: Set targ_osabi.
	* configure.ac: Define GOLD_DEFAULT_OSABI.
	* parameters.cc (Parameters::default_target): Pass
	GOLD_DEFAULT_OSABI to select_target.
	* target-select.h (class Target_selector): Make instantiate_target
	protected rather than private.
	* Makefile.am (HFILES): Add freebsd.h.
	* configure, Makefile.in, config.in: Rebuild.
@
text
@d176 6
d248 4
@


1.31
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d170 6
d234 8
@


1.30
log
@	* target-reloc.h (relocate_section): Check whether a symbol is
	defined by the ABI before reporting an undefined symbol error.
	* target.h (Target::is_defined_by_abi): Make parameter const.
	(Target::do_is_defined_by_abi): Likewise.
	* i386.cc (Target_i386::do_is_defined_by_abi): Likewise.
	* powerpc.cc (Target_powerpc::do_is_defined_by_abi): Likewise.
	* sparc.cc (Target_sparc::do_is_defined_by_abi): Likewise.
	* x86_64.cc (Target_x86_64::do_is_defined_by_abi): Likewise.
	* testsuite/Makefile.am (tls_test_shared.so): Add -Wl,-z,defs.
	* testsuite/Makefile.in: Rebuild.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d262 18
@


1.29
log
@	* options.h (class General_options): Define --wrap as a special
	option.  Add wrap_symbols_ field.
	(General_options::any_wrap_symbols): New function.
	(General_options::is_wrap_symbol): New function.
	* options.cc (General_options::parse_wrap): New function.
	(General_options::General_options): Initialize wrap_symbols_.
	* symtab.cc (Symbol_table::wrap_symbol): New function.
	(Symbol_table::add_from_object): Handle --wrap.
	* symtab.h (class Symbol_table): Declare wrap_symbol.
	* target.h (Target::wrap_char): New function.
	(Target::Target_info): Add wrap_char field.
	* i386.cc (Target_i386::i386_info): Initialize wrap_char.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Likewise.
@
text
@d167 1
a167 1
  is_defined_by_abi(Symbol* sym) const
d225 1
a225 1
  do_is_defined_by_abi(Symbol*) const
@


1.28
log
@Update copyright years.  Update language files.
@
text
@d135 9
d191 2
@


1.27
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.26
log
@From Craig Silverstein: implement -z max-page-size and -z
common-page-size.
@
text
@d37 1
d109 2
a110 2
    if (parameters->max_page_size() > 0)
      return parameters->max_page_size();
d119 2
a120 2
    if (parameters->common_page_size() > 0)
      return std::min(parameters->common_page_size(),
d152 1
a152 1
  code_fill(section_size_type length)
d209 1
a209 1
  do_code_fill(section_size_type)
@


1.25
log
@Initial -r support.
@
text
@d37 1
d107 6
a112 1
  { return this->pti_->abi_pagesize; }
d117 8
a124 1
  { return this->pti_->common_pagesize; }
@


1.24
log
@Convert more instances of off_t to be 32-bit types.
@
text
@d45 1
d284 36
@


1.23
log
@Add heuristics for undefined symbol warnings.
@
text
@d137 1
a137 1
  code_fill(off_t length)
d194 1
a194 1
  do_code_fill(off_t)
d282 1
a282 1
		   off_t view_size) = 0;
@


1.22
log
@Revert last patch.
@
text
@d140 6
d196 5
@


1.21
log
@Support special always-defined symbols for targets.
@
text
@a139 7
  // Return whether SYM is a special symbol which is known to be
  // defined.  This is used to avoid inappropriate warnings about
  // undefined symbols.
  bool
  is_always_defined(Symbol* sym) const
  { return this->do_is_always_defined(sym); }

a189 6

  // Virtual function which may be implemented by the child class if
  // needed.
  virtual bool
  do_is_always_defined(Symbol*) const
  { return false; }
@


1.20
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d140 7
d197 6
@


1.19
log
@Add support for PT_GNU_STACK.
@
text
@d46 1
a46 1
struct Relocate_info;
d51 1
d232 5
a236 3
  // number of local symbols.  PLOCAL_SYMBOLS points to the local
  // symbol data from OBJECT.  GLOBAL_SYMBOLS is the array of pointers
  // to the global symbol table from OBJECT.
d246 2
d249 1
a249 2
	      const unsigned char* plocal_symbols,
	      Symbol** global_symbols) = 0;
d253 9
a261 4
  // information.  RELOC_COUNT is the number of relocs.  VIEW is a
  // view into the output file holding the section contents,
  // VIEW_ADDRESS is the virtual address of the view, and VIEW_SIZE is
  // the size of the view.
d267 2
@


1.18
log
@From Craig Silverstein: implement -Ttext.
@
text
@d111 8
d157 3
@


1.17
log
@Use special value when we refer a function symbol in some way other
than calling it.
@
text
@d98 2
a99 2
  text_segment_address() const
  { return this->pti_->text_segment_address; }
d152 1
a152 1
    uint64_t text_segment_address;
@


1.16
log
@Add licensing text to every source file.
@
text
@d117 7
d167 5
@


1.15
log
@Add global parameters.
@
text
@d3 20
@


1.14
log
@Use nops when doing alignment padding between code sections.
@
text
@d94 2
a95 2
  finalize_sections(const General_options* options, Layout* layout)
  { return this->do_finalize_sections(options, layout); }
d138 1
a138 1
  do_finalize_sections(const General_options*, Layout*)
@


1.13
log
@Generate version information.
@
text
@d66 5
d97 7
d120 2
d140 6
@


1.12
log
@Can now dynamically link hello, world.
@
text
@d148 1
a148 1
  make_symbol()
d154 2
a155 1
  // This will only be called if has_resolve() returns true.
d157 2
a158 1
  resolve(Symbol*, const elfcpp::Sym<size, big_endian>&, Object*)
@


1.11
log
@Added a testsuite.  More support for COPY relocations.
@
text
@d89 2
a90 2
  finalize_sections(Layout* layout)
  { return this->do_finalize_sections(layout); }
d124 1
a124 1
  do_finalize_sections(Layout*)
@


1.10
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d86 6
d120 5
@


1.9
log
@More dynamic object support, initial scripting support.
@
text
@a15 2
#include <cassert>

d138 1
a138 1
  { abort(); }
d146 1
a146 1
  { abort(); }
d151 2
a152 1
  // section appears.  SH_TYPE is the type of the relocation section,
d163 1
d190 2
a191 2
    assert(pti->size == size);
    assert(pti->is_big_endian ? big_endian : !big_endian);
@


1.8
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@d68 5
d104 2
@


1.7
log
@Can now do a full static link of hello, world in C or C++
@
text
@a18 1
#include "symtab.h"
d26 1
a26 1
class Sized_object;
d29 4
d156 1
a156 1
	      Sized_object<size, big_endian>* object,
@


1.6
log
@Framework for relocation scanning.  Implement simple static TLS
relocations.
@
text
@d152 1
@


1.5
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d24 1
d28 2
d135 1
d140 26
a165 9
  // Relocate section data.  SYMTAB is the symbol table.  OBJECT is
  // the object in which the section appears.  SH_TYPE is the type of
  // the relocation section, SHT_REL or SHT_RELA.  PRELOCS points to
  // the relocation information.  RELOC_COUNT is the number of relocs.
  // LOCAL_COUNT is the number of local symbols.  The VALUES and
  // GLOBAL_SYMS have symbol table information.  VIEW is a view into
  // the output file holding the section contents, VIEW_ADDRESS is the
  // virtual address of the view, and VIEW_SIZE is the size of the
  // view.
d167 7
a173 12
  relocate_section(const Symbol_table*, // symtab
		   Sized_object<size, big_endian>*, // object
		   unsigned int, // sh_type
		   const unsigned char*, // prelocs
		   size_t, // reloc_count
		   unsigned int, // local_count
		   const typename elfcpp::Elf_types<size>::Elf_Addr*, // values
		   Symbol**, // global_syms
		   unsigned char*, // view
		   typename elfcpp::Elf_types<size>::Elf_Addr, // view_address
		   off_t) // view_size
  { abort(); }
@


1.4
log
@Finished layout code.
@
text
@d18 1
a19 1
#include "elfcpp.h"
d25 2
d47 5
d87 2
d134 23
@


1.3
log
@g++ 3.2.2 portability fixes.
@
text
@d16 2
d38 1
a38 1
  { return this->size_; }
d43 1
a43 1
  { return this->is_big_endian_; }
d48 1
a48 1
  { return this->has_make_symbol_; }
d53 16
a68 1
  { return this->has_resolve_; }
d71 23
a93 5
  Target(int size, bool is_big_endian, bool has_make_symbol, bool has_resolve)
    : size_(size),
      is_big_endian_(is_big_endian),
      has_make_symbol_(has_make_symbol),
      has_resolve_(has_resolve)
d100 2
a101 8
  // The target size.
  int size_;
  // Whether this target is big endian.
  bool is_big_endian_;
  // Whether this target has a special make_symbol function.
  bool has_make_symbol_;
  // Whether this target has a special resolve function.
  bool has_resolve_;
d128 6
a133 3
  Sized_target(bool has_make_symbol, bool has_resolve)
    : Target(size, big_endian, has_make_symbol, has_resolve)
  { }
@


1.2
log
@Another snapshot of the current state of the sources.  Gets to the
point of symbol resolution and can now issue a multiple definition
error.  Also added target selection infrastructure.
@
text
@a52 10
  // Resolve a symbol.  This is called when we see a symbol with a
  // target specific binding (STB_LOOS through STB_HIOS or STB_LOPROC
  // through STB_HIPROC).  TO is a pre-existing symbol.  SYM is the
  // new symbol, seen in OBJECT.  This returns true on success, false
  // if the symbol can not be resolved.
  template<int size, bool big_endian>
  bool
  resolve(Sized_symbol<size>* to, const elfcpp::Sym<size, big_endian>& sym,
	  Object* object);

@


1.1
log
@Initial CVS checkin of gold
@
text
@d1 1
a1 1
// target.h -- target support for gold
d16 3
d22 4
d29 54
d85 28
a112 2
extern Target* select_target(int machine, int size, bool big_endian,
			     int osabi, int abiversion);
@

