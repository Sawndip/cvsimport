head	1.171;
access;
symbols
	binutils-2_24-branch:1.171.0.2
	binutils-2_24-branchpoint:1.171
	binutils-2_21_1:1.145.2.2
	binutils-2_23_2:1.166
	binutils-2_23_1:1.166
	binutils-2_23:1.166
	binutils-2_23-branch:1.166.0.2
	binutils-2_23-branchpoint:1.166
	binutils-2_22_branch:1.159.2.1.0.2
	binutils-2_22:1.159.2.1
	binutils-2_22-branch:1.159.0.2
	binutils-2_22-branchpoint:1.159
	binutils-2_21:1.145
	binutils-2_21-branch:1.145.0.2
	binutils-2_21-branchpoint:1.145
	binutils-2_20_1:1.121.2.2
	binutils-2_20:1.121.2.1
	binutils-arc-20081103-branch:1.111.0.4
	binutils-arc-20081103-branchpoint:1.111
	binutils-2_20-branch:1.121.0.2
	binutils-2_20-branchpoint:1.121
	dje-cgen-play1-branch:1.120.0.2
	dje-cgen-play1-branchpoint:1.120
	arc-20081103-branch:1.111.0.2
	arc-20081103-branchpoint:1.111
	binutils-2_19_1:1.109
	binutils-2_19:1.109
	binutils-2_19-branch:1.109.0.2
	binutils-2_19-branchpoint:1.109
	binutils_latest_snapshot:1.171
	added-to-binutils:1.80;
locks; strict;
comment	@// @;


1.171
date	2013.04.15.16.34.12;	author ccoutant;	state Exp;
branches;
next	1.170;

1.170
date	2013.03.20.00.25.28;	author amodra;	state Exp;
branches;
next	1.169;

1.169
date	2013.03.10.23.08.18;	author amodra;	state Exp;
branches;
next	1.168;

1.168
date	2012.09.09.03.43.51;	author amodra;	state Exp;
branches;
next	1.167;

1.167
date	2012.08.21.21.41.04;	author ccoutant;	state Exp;
branches;
next	1.166;

1.166
date	2012.05.25.22.53.52;	author tmsriram;	state Exp;
branches;
next	1.165;

1.165
date	2012.05.22.23.50.52;	author ccoutant;	state Exp;
branches;
next	1.164;

1.164
date	2012.04.17.00.28.41;	author ccoutant;	state Exp;
branches;
next	1.163;

1.163
date	2011.10.31.22.43.49;	author ccoutant;	state Exp;
branches;
next	1.162;

1.162
date	2011.10.31.21.36.54;	author tmsriram;	state Exp;
branches;
next	1.161;

1.161
date	2011.09.29.17.04.36;	author ccoutant;	state Exp;
branches;
next	1.160;

1.160
date	2011.09.28.00.55.35;	author ian;	state Exp;
branches;
next	1.159;

1.159
date	2011.08.01.18.25.21;	author ccoutant;	state Exp;
branches
	1.159.2.1;
next	1.158;

1.158
date	2011.07.22.22.38.42;	author tmsriram;	state Exp;
branches;
next	1.157;

1.157
date	2011.07.08.23.49.11;	author ian;	state Exp;
branches;
next	1.156;

1.156
date	2011.06.29.14.43.08;	author ian;	state Exp;
branches;
next	1.155;

1.155
date	2011.06.28.05.39.45;	author ian;	state Exp;
branches;
next	1.154;

1.154
date	2011.06.16.17.55.48;	author ian;	state Exp;
branches;
next	1.153;

1.153
date	2011.06.08.04.05.25;	author ccoutant;	state Exp;
branches;
next	1.152;

1.152
date	2011.06.08.03.50.11;	author ccoutant;	state Exp;
branches;
next	1.151;

1.151
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.150;

1.150
date	2011.04.12.00.44.48;	author ccoutant;	state Exp;
branches;
next	1.149;

1.149
date	2011.03.10.01.31.32;	author ian;	state Exp;
branches;
next	1.148;

1.148
date	2011.02.18.14.55.33;	author espindola;	state Exp;
branches;
next	1.147;

1.147
date	2011.02.05.01.52.40;	author ian;	state Exp;
branches;
next	1.146;

1.146
date	2011.01.24.21.48.40;	author ian;	state Exp;
branches;
next	1.145;

1.145
date	2010.10.02.09.35.19;	author dougkwan;	state Exp;
branches
	1.145.2.1;
next	1.144;

1.144
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.143;

1.143
date	2010.08.13.00.18.18;	author dougkwan;	state Exp;
branches;
next	1.142;

1.142
date	2010.08.02.13.34.33;	author ian;	state Exp;
branches;
next	1.141;

1.141
date	2010.07.09.01.34.31;	author ccoutant;	state Exp;
branches;
next	1.140;

1.140
date	2010.06.27.06.17.36;	author ian;	state Exp;
branches;
next	1.139;

1.139
date	2010.04.20.21.13.30;	author tmsriram;	state Exp;
branches;
next	1.138;

1.138
date	2010.01.12.06.41.36;	author ian;	state Exp;
branches;
next	1.137;

1.137
date	2010.01.09.00.13.48;	author ian;	state Exp;
branches;
next	1.136;

1.136
date	2010.01.05.19.29.15;	author ian;	state Exp;
branches;
next	1.135;

1.135
date	2009.12.31.01.14.34;	author ian;	state Exp;
branches;
next	1.134;

1.134
date	2009.12.29.00.31.48;	author ian;	state Exp;
branches;
next	1.133;

1.133
date	2009.12.17.00.00.26;	author dougkwan;	state Exp;
branches;
next	1.132;

1.132
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.131;

1.131
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.130;

1.130
date	2009.12.07.17.14.55;	author hjl;	state Exp;
branches;
next	1.129;

1.129
date	2009.12.05.07.28.45;	author hjl;	state Exp;
branches;
next	1.128;

1.128
date	2009.11.05.06.24.39;	author ian;	state Exp;
branches;
next	1.127;

1.127
date	2009.10.28.00.32.11;	author ccoutant;	state Exp;
branches;
next	1.126;

1.126
date	2009.10.14.05.25.02;	author ian;	state Exp;
branches;
next	1.125;

1.125
date	2009.10.13.21.17.43;	author tmsriram;	state Exp;
branches;
next	1.124;

1.124
date	2009.10.09.23.18.19;	author dougkwan;	state Exp;
branches;
next	1.123;

1.123
date	2009.09.30.22.21.13;	author ian;	state Exp;
branches;
next	1.122;

1.122
date	2009.09.18.20.02.21;	author csilvers;	state Exp;
branches;
next	1.121;

1.121
date	2009.08.05.20.51.56;	author tmsriram;	state Exp;
branches
	1.121.2.1;
next	1.120;

1.120
date	2009.06.22.06.51.53;	author ian;	state Exp;
branches;
next	1.119;

1.119
date	2009.05.19.22.14.17;	author ccoutant;	state Exp;
branches;
next	1.118;

1.118
date	2009.03.17.07.07.21;	author ian;	state Exp;
branches;
next	1.117;

1.117
date	2009.02.28.17.53.16;	author ian;	state Exp;
branches;
next	1.116;

1.116
date	2009.02.28.04.39.57;	author ian;	state Exp;
branches;
next	1.115;

1.115
date	2009.02.27.19.57.46;	author ian;	state Exp;
branches;
next	1.114;

1.114
date	2009.02.06.19.20.09;	author cgd;	state Exp;
branches;
next	1.113;

1.113
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	1.112;

1.112
date	2008.11.06.07.23.31;	author csilvers;	state Exp;
branches;
next	1.111;

1.111
date	2008.09.29.21.10.26;	author ccoutant;	state Exp;
branches;
next	1.110;

1.110
date	2008.09.19.22.54.57;	author ccoutant;	state Exp;
branches;
next	1.109;

1.109
date	2008.09.06.01.13.00;	author ccoutant;	state Exp;
branches;
next	1.108;

1.108
date	2008.08.28.14.51.04;	author kvanhees;	state Exp;
branches;
next	1.107;

1.107
date	2008.07.23.23.44.02;	author ian;	state Exp;
branches;
next	1.106;

1.106
date	2008.07.23.16.19.59;	author cgd;	state Exp;
branches;
next	1.105;

1.105
date	2008.07.23.14.36.09;	author ian;	state Exp;
branches;
next	1.104;

1.104
date	2008.07.22.22.08.43;	author ian;	state Exp;
branches;
next	1.103;

1.103
date	2008.07.22.21.02.44;	author cgd;	state Exp;
branches;
next	1.102;

1.102
date	2008.07.21.23.36.29;	author csilvers;	state Exp;
branches;
next	1.101;

1.101
date	2008.07.18.07.03.27;	author ian;	state Exp;
branches;
next	1.100;

1.100
date	2008.07.10.23.01.20;	author ian;	state Exp;
branches;
next	1.99;

1.99
date	2008.06.30.18.16.31;	author ian;	state Exp;
branches;
next	1.98;

1.98
date	2008.05.08.18.44.33;	author ian;	state Exp;
branches;
next	1.97;

1.97
date	2008.05.07.06.08.01;	author ian;	state Exp;
branches;
next	1.96;

1.96
date	2008.05.06.22.24.26;	author ian;	state Exp;
branches;
next	1.95;

1.95
date	2008.05.01.00.25.33;	author csilvers;	state Exp;
branches;
next	1.94;

1.94
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.93;

1.93
date	2008.04.17.22.45.47;	author ccoutant;	state Exp;
branches;
next	1.92;

1.92
date	2008.04.17.07.12.00;	author ian;	state Exp;
branches;
next	1.91;

1.91
date	2008.04.17.02.00.54;	author ccoutant;	state Exp;
branches;
next	1.90;

1.90
date	2008.04.10.00.58.58;	author ian;	state Exp;
branches;
next	1.89;

1.89
date	2008.04.09.22.45.08;	author ian;	state Exp;
branches;
next	1.88;

1.88
date	2008.04.09.00.48.13;	author ian;	state Exp;
branches;
next	1.87;

1.87
date	2008.03.29.08.39.26;	author ian;	state Exp;
branches;
next	1.86;

1.86
date	2008.03.29.07.19.02;	author ian;	state Exp;
branches;
next	1.85;

1.85
date	2008.03.27.18.19.09;	author ian;	state Exp;
branches;
next	1.84;

1.84
date	2008.03.27.06.11.57;	author ian;	state Exp;
branches;
next	1.83;

1.83
date	2008.03.26.23.36.46;	author ian;	state Exp;
branches;
next	1.82;

1.82
date	2008.03.25.18.37.16;	author ccoutant;	state Exp;
branches;
next	1.81;

1.81
date	2008.03.24.03.48.29;	author ian;	state Exp;
branches;
next	1.80;

1.80
date	2008.03.14.05.57.19;	author iant;	state Exp;
branches;
next	1.79;

1.79
date	2008.02.29.19.19.17;	author iant;	state Exp;
branches;
next	1.78;

1.78
date	2008.02.28.20.35.39;	author iant;	state Exp;
branches;
next	1.77;

1.77
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.76;

1.76
date	2008.02.13.01.20.38;	author iant;	state Exp;
branches;
next	1.75;

1.75
date	2008.02.09.01.22.17;	author iant;	state Exp;
branches;
next	1.74;

1.74
date	2008.02.07.04.35.41;	author iant;	state Exp;
branches;
next	1.73;

1.73
date	2008.02.07.01.51.25;	author iant;	state Exp;
branches;
next	1.72;

1.72
date	2008.02.06.20.32.10;	author iant;	state Exp;
branches;
next	1.71;

1.71
date	2008.02.04.05.41.40;	author iant;	state Exp;
branches;
next	1.70;

1.70
date	2008.02.01.00.42.24;	author iant;	state Exp;
branches;
next	1.69;

1.69
date	2008.01.26.01.17.45;	author iant;	state Exp;
branches;
next	1.68;

1.68
date	2008.01.24.00.15.00;	author iant;	state Exp;
branches;
next	1.67;

1.67
date	2008.01.15.23.41.28;	author iant;	state Exp;
branches;
next	1.66;

1.66
date	2008.01.09.19.57.45;	author iant;	state Exp;
branches;
next	1.65;

1.65
date	2008.01.02.23.48.49;	author iant;	state Exp;
branches;
next	1.64;

1.64
date	2007.12.21.23.31.19;	author iant;	state Exp;
branches;
next	1.63;

1.63
date	2007.12.20.21.21.24;	author iant;	state Exp;
branches;
next	1.62;

1.62
date	2007.12.19.00.29.28;	author iant;	state Exp;
branches;
next	1.61;

1.61
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.60;

1.60
date	2007.12.14.19.00.21;	author iant;	state Exp;
branches;
next	1.59;

1.59
date	2007.12.14.05.24.17;	author iant;	state Exp;
branches;
next	1.58;

1.58
date	2007.12.07.19.32.59;	author iant;	state Exp;
branches;
next	1.57;

1.57
date	2007.12.06.05.55.50;	author iant;	state Exp;
branches;
next	1.56;

1.56
date	2007.12.05.00.48.49;	author iant;	state Exp;
branches;
next	1.55;

1.55
date	2007.12.04.23.11.34;	author iant;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.22.00.05.51;	author iant;	state Exp;
branches;
next	1.53;

1.53
date	2007.11.17.02.49.22;	author iant;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.16.16.54.19;	author iant;	state Exp;
branches;
next	1.51;

1.51
date	2007.11.15.20.41.19;	author iant;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.15.01.12.55;	author iant;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.14.18.44.58;	author iant;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.14.16.53.24;	author iant;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.14.08.03.41;	author iant;	state Exp;
branches;
next	1.46;

1.46
date	2007.11.14.07.52.21;	author iant;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.14.07.34.53;	author iant;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.14.01.03.01;	author iant;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.13.20.02.32;	author iant;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.09.19.45.08;	author iant;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.23.05.05.48;	author iant;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.22.23.08.22;	author iant;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.16.23.23.08;	author iant;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.14.15.35.27;	author iant;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.14.06.49.14;	author iant;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.12.06.06.34;	author iant;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.10.19.02.56;	author iant;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.28.06.36.25;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.26.07.01.35;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.25.17.50.26;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.23.05.31.48;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.22.20.08.16;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.22.04.40.13;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.19.06.02.29;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.04.20.00.53;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.04.17.59.53;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.29.03.42.51;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.28.04.11.50;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.08.22.05.06.38;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2006.12.06.06.28.56;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2006.12.06.00.02.36;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.01.16.58.12;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.01.16.51.25;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.16.00.38.25;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.07.18.51.39;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.07.04.40.46;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.03.18.38.43;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.03.18.26.11;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.10.10.18.54.06;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.09.29.22.34.01;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.29.19.58.17;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.27.22.53.42;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.26.21.50.25;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.26.21.00.34;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.07.21.21.41;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.18.22.29.20;	author iant;	state Exp;
branches;
next	;

1.159.2.1
date	2011.09.28.00.55.46;	author ian;	state Exp;
branches;
next	1.159.2.2;

1.159.2.2
date	2011.12.19.21.14.40;	author ian;	state Exp;
branches;
next	;

1.145.2.1
date	2011.01.24.21.54.56;	author ian;	state Exp;
branches;
next	1.145.2.2;

1.145.2.2
date	2011.02.05.01.55.18;	author ian;	state Exp;
branches;
next	;

1.121.2.1
date	2009.10.16.05.51.18;	author ian;	state Exp;
branches;
next	1.121.2.2;

1.121.2.2
date	2009.11.05.06.25.01;	author ian;	state Exp;
branches;
next	;


desc
@@


1.171
log
@gold/
    	* symtab.cc (Symbol_table::sized_write_globals): Subtract
    	section starting address for relocatable link.
    	* testsuite/Makefile.am (script_test_11): New test.
    	* testsuite/Makefile.in: Regenerate.
    	* testsuite/script_test_11.c: New source file.
    	* testsuite/script_test_11.t: New linker script.
@
text
@// symtab.cc -- the gold symbol table

// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cstring>
#include <stdint.h>
#include <algorithm>
#include <set>
#include <string>
#include <utility>
#include "demangle.h"

#include "gc.h"
#include "object.h"
#include "dwarf_reader.h"
#include "dynobj.h"
#include "output.h"
#include "target.h"
#include "workqueue.h"
#include "symtab.h"
#include "script.h"
#include "plugin.h"
#include "incremental.h"

namespace gold
{

// Class Symbol.

// Initialize fields in Symbol.  This initializes everything except u_
// and source_.

void
Symbol::init_fields(const char* name, const char* version,
		    elfcpp::STT type, elfcpp::STB binding,
		    elfcpp::STV visibility, unsigned char nonvis)
{
  this->name_ = name;
  this->version_ = version;
  this->symtab_index_ = 0;
  this->dynsym_index_ = 0;
  this->got_offsets_.init();
  this->plt_offset_ = -1U;
  this->type_ = type;
  this->binding_ = binding;
  this->visibility_ = visibility;
  this->nonvis_ = nonvis;
  this->is_def_ = false;
  this->is_forwarder_ = false;
  this->has_alias_ = false;
  this->needs_dynsym_entry_ = false;
  this->in_reg_ = false;
  this->in_dyn_ = false;
  this->has_warning_ = false;
  this->is_copied_from_dynobj_ = false;
  this->is_forced_local_ = false;
  this->is_ordinary_shndx_ = false;
  this->in_real_elf_ = false;
  this->is_defined_in_discarded_section_ = false;
  this->undef_binding_set_ = false;
  this->undef_binding_weak_ = false;
  this->is_predefined_ = false;
}

// Return the demangled version of the symbol's name, but only
// if the --demangle flag was set.

static std::string
demangle(const char* name)
{
  if (!parameters->options().do_demangle())
    return name;

  // cplus_demangle allocates memory for the result it returns,
  // and returns NULL if the name is already demangled.
  char* demangled_name = cplus_demangle(name, DMGL_ANSI | DMGL_PARAMS);
  if (demangled_name == NULL)
    return name;

  std::string retval(demangled_name);
  free(demangled_name);
  return retval;
}

std::string
Symbol::demangled_name() const
{
  return demangle(this->name());
}

// Initialize the fields in the base class Symbol for SYM in OBJECT.

template<int size, bool big_endian>
void
Symbol::init_base_object(const char* name, const char* version, Object* object,
			 const elfcpp::Sym<size, big_endian>& sym,
			 unsigned int st_shndx, bool is_ordinary)
{
  this->init_fields(name, version, sym.get_st_type(), sym.get_st_bind(),
		    sym.get_st_visibility(), sym.get_st_nonvis());
  this->u_.from_object.object = object;
  this->u_.from_object.shndx = st_shndx;
  this->is_ordinary_shndx_ = is_ordinary;
  this->source_ = FROM_OBJECT;
  this->in_reg_ = !object->is_dynamic();
  this->in_dyn_ = object->is_dynamic();
  this->in_real_elf_ = object->pluginobj() == NULL;
}

// Initialize the fields in the base class Symbol for a symbol defined
// in an Output_data.

void
Symbol::init_base_output_data(const char* name, const char* version,
			      Output_data* od, elfcpp::STT type,
			      elfcpp::STB binding, elfcpp::STV visibility,
			      unsigned char nonvis, bool offset_is_from_end,
			      bool is_predefined)
{
  this->init_fields(name, version, type, binding, visibility, nonvis);
  this->u_.in_output_data.output_data = od;
  this->u_.in_output_data.offset_is_from_end = offset_is_from_end;
  this->source_ = IN_OUTPUT_DATA;
  this->in_reg_ = true;
  this->in_real_elf_ = true;
  this->is_predefined_ = is_predefined;
}

// Initialize the fields in the base class Symbol for a symbol defined
// in an Output_segment.

void
Symbol::init_base_output_segment(const char* name, const char* version,
				 Output_segment* os, elfcpp::STT type,
				 elfcpp::STB binding, elfcpp::STV visibility,
				 unsigned char nonvis,
				 Segment_offset_base offset_base,
				 bool is_predefined)
{
  this->init_fields(name, version, type, binding, visibility, nonvis);
  this->u_.in_output_segment.output_segment = os;
  this->u_.in_output_segment.offset_base = offset_base;
  this->source_ = IN_OUTPUT_SEGMENT;
  this->in_reg_ = true;
  this->in_real_elf_ = true;
  this->is_predefined_ = is_predefined;
}

// Initialize the fields in the base class Symbol for a symbol defined
// as a constant.

void
Symbol::init_base_constant(const char* name, const char* version,
			   elfcpp::STT type, elfcpp::STB binding,
			   elfcpp::STV visibility, unsigned char nonvis,
			   bool is_predefined)
{
  this->init_fields(name, version, type, binding, visibility, nonvis);
  this->source_ = IS_CONSTANT;
  this->in_reg_ = true;
  this->in_real_elf_ = true;
  this->is_predefined_ = is_predefined;
}

// Initialize the fields in the base class Symbol for an undefined
// symbol.

void
Symbol::init_base_undefined(const char* name, const char* version,
			    elfcpp::STT type, elfcpp::STB binding,
			    elfcpp::STV visibility, unsigned char nonvis)
{
  this->init_fields(name, version, type, binding, visibility, nonvis);
  this->dynsym_index_ = -1U;
  this->source_ = IS_UNDEFINED;
  this->in_reg_ = true;
  this->in_real_elf_ = true;
}

// Allocate a common symbol in the base.

void
Symbol::allocate_base_common(Output_data* od)
{
  gold_assert(this->is_common());
  this->source_ = IN_OUTPUT_DATA;
  this->u_.in_output_data.output_data = od;
  this->u_.in_output_data.offset_is_from_end = false;
}

// Initialize the fields in Sized_symbol for SYM in OBJECT.

template<int size>
template<bool big_endian>
void
Sized_symbol<size>::init_object(const char* name, const char* version,
				Object* object,
				const elfcpp::Sym<size, big_endian>& sym,
				unsigned int st_shndx, bool is_ordinary)
{
  this->init_base_object(name, version, object, sym, st_shndx, is_ordinary);
  this->value_ = sym.get_st_value();
  this->symsize_ = sym.get_st_size();
}

// Initialize the fields in Sized_symbol for a symbol defined in an
// Output_data.

template<int size>
void
Sized_symbol<size>::init_output_data(const char* name, const char* version,
				     Output_data* od, Value_type value,
				     Size_type symsize, elfcpp::STT type,
				     elfcpp::STB binding,
				     elfcpp::STV visibility,
				     unsigned char nonvis,
				     bool offset_is_from_end,
				     bool is_predefined)
{
  this->init_base_output_data(name, version, od, type, binding, visibility,
			      nonvis, offset_is_from_end, is_predefined);
  this->value_ = value;
  this->symsize_ = symsize;
}

// Initialize the fields in Sized_symbol for a symbol defined in an
// Output_segment.

template<int size>
void
Sized_symbol<size>::init_output_segment(const char* name, const char* version,
					Output_segment* os, Value_type value,
					Size_type symsize, elfcpp::STT type,
					elfcpp::STB binding,
					elfcpp::STV visibility,
					unsigned char nonvis,
					Segment_offset_base offset_base,
					bool is_predefined)
{
  this->init_base_output_segment(name, version, os, type, binding, visibility,
				 nonvis, offset_base, is_predefined);
  this->value_ = value;
  this->symsize_ = symsize;
}

// Initialize the fields in Sized_symbol for a symbol defined as a
// constant.

template<int size>
void
Sized_symbol<size>::init_constant(const char* name, const char* version,
				  Value_type value, Size_type symsize,
				  elfcpp::STT type, elfcpp::STB binding,
				  elfcpp::STV visibility, unsigned char nonvis,
				  bool is_predefined)
{
  this->init_base_constant(name, version, type, binding, visibility, nonvis,
			   is_predefined);
  this->value_ = value;
  this->symsize_ = symsize;
}

// Initialize the fields in Sized_symbol for an undefined symbol.

template<int size>
void
Sized_symbol<size>::init_undefined(const char* name, const char* version,
				   elfcpp::STT type, elfcpp::STB binding,
				   elfcpp::STV visibility, unsigned char nonvis)
{
  this->init_base_undefined(name, version, type, binding, visibility, nonvis);
  this->value_ = 0;
  this->symsize_ = 0;
}

// Return an allocated string holding the symbol's name as
// name@@version.  This is used for relocatable links.

std::string
Symbol::versioned_name() const
{
  gold_assert(this->version_ != NULL);
  std::string ret = this->name_;
  ret.push_back('@@');
  if (this->is_def_)
    ret.push_back('@@');
  ret += this->version_;
  return ret;
}

// Return true if SHNDX represents a common symbol.

bool
Symbol::is_common_shndx(unsigned int shndx)
{
  return (shndx == elfcpp::SHN_COMMON
	  || shndx == parameters->target().small_common_shndx()
	  || shndx == parameters->target().large_common_shndx());
}

// Allocate a common symbol.

template<int size>
void
Sized_symbol<size>::allocate_common(Output_data* od, Value_type value)
{
  this->allocate_base_common(od);
  this->value_ = value;
}

// The ""'s around str ensure str is a string literal, so sizeof works.
#define strprefix(var, str)   (strncmp(var, str, sizeof("" str "") - 1) == 0)

// Return true if this symbol should be added to the dynamic symbol
// table.

inline bool
Symbol::should_add_dynsym_entry(Symbol_table* symtab) const
{
  // If the symbol is only present on plugin files, the plugin decided we
  // don't need it.
  if (!this->in_real_elf())
    return false;

  // If the symbol is used by a dynamic relocation, we need to add it.
  if (this->needs_dynsym_entry())
    return true;

  // If this symbol's section is not added, the symbol need not be added. 
  // The section may have been GCed.  Note that export_dynamic is being 
  // overridden here.  This should not be done for shared objects.
  if (parameters->options().gc_sections() 
      && !parameters->options().shared()
      && this->source() == Symbol::FROM_OBJECT
      && !this->object()->is_dynamic())
    {
      Relobj* relobj = static_cast<Relobj*>(this->object());
      bool is_ordinary;
      unsigned int shndx = this->shndx(&is_ordinary);
      if (is_ordinary && shndx != elfcpp::SHN_UNDEF
          && !relobj->is_section_included(shndx)
          && !symtab->is_section_folded(relobj, shndx))
        return false;
    }

  // If the symbol was forced dynamic in a --dynamic-list file
  // or an --export-dynamic-symbol option, add it.
  if (!this->is_from_dynobj()
      && (parameters->options().in_dynamic_list(this->name())
	  || parameters->options().is_export_dynamic_symbol(this->name())))
    {
      if (!this->is_forced_local())
        return true;
      gold_warning(_("Cannot export local symbol '%s'"),
		   this->demangled_name().c_str());
      return false;
    }

  // If the symbol was forced local in a version script, do not add it.
  if (this->is_forced_local())
    return false;

  // If dynamic-list-data was specified, add any STT_OBJECT.
  if (parameters->options().dynamic_list_data()
      && !this->is_from_dynobj()
      && this->type() == elfcpp::STT_OBJECT)
    return true;

  // If --dynamic-list-cpp-new was specified, add any new/delete symbol.
  // If --dynamic-list-cpp-typeinfo was specified, add any typeinfo symbols.
  if ((parameters->options().dynamic_list_cpp_new()
       || parameters->options().dynamic_list_cpp_typeinfo())
      && !this->is_from_dynobj())
    {
      // TODO(csilvers): We could probably figure out if we're an operator
      //                 new/delete or typeinfo without the need to demangle.
      char* demangled_name = cplus_demangle(this->name(),
                                            DMGL_ANSI | DMGL_PARAMS);
      if (demangled_name == NULL)
        {
          // Not a C++ symbol, so it can't satisfy these flags
        }
      else if (parameters->options().dynamic_list_cpp_new()
               && (strprefix(demangled_name, "operator new")
                   || strprefix(demangled_name, "operator delete")))
        {
          free(demangled_name);
          return true;
        }
      else if (parameters->options().dynamic_list_cpp_typeinfo()
               && (strprefix(demangled_name, "typeinfo name for")
                   || strprefix(demangled_name, "typeinfo for")))
        {
          free(demangled_name);
          return true;
        }
      else
        free(demangled_name);
    }

  // If exporting all symbols or building a shared library,
  // and the symbol is defined in a regular object and is
  // externally visible, we need to add it.
  if ((parameters->options().export_dynamic() || parameters->options().shared())
      && !this->is_from_dynobj()
      && !this->is_undefined()
      && this->is_externally_visible())
    return true;

  return false;
}

// Return true if the final value of this symbol is known at link
// time.

bool
Symbol::final_value_is_known() const
{
  // If we are not generating an executable, then no final values are
  // known, since they will change at runtime.
  if (parameters->options().output_is_position_independent()
      || parameters->options().relocatable())
    return false;

  // If the symbol is not from an object file, and is not undefined,
  // then it is defined, and known.
  if (this->source_ != FROM_OBJECT)
    {
      if (this->source_ != IS_UNDEFINED)
	return true;
    }
  else
    {
      // If the symbol is from a dynamic object, then the final value
      // is not known.
      if (this->object()->is_dynamic())
	return false;

      // If the symbol is not undefined (it is defined or common),
      // then the final value is known.
      if (!this->is_undefined())
	return true;
    }

  // If the symbol is undefined, then whether the final value is known
  // depends on whether we are doing a static link.  If we are doing a
  // dynamic link, then the final value could be filled in at runtime.
  // This could reasonably be the case for a weak undefined symbol.
  return parameters->doing_static_link();
}

// Return the output section where this symbol is defined.

Output_section*
Symbol::output_section() const
{
  switch (this->source_)
    {
    case FROM_OBJECT:
      {
	unsigned int shndx = this->u_.from_object.shndx;
	if (shndx != elfcpp::SHN_UNDEF && this->is_ordinary_shndx_)
	  {
	    gold_assert(!this->u_.from_object.object->is_dynamic());
	    gold_assert(this->u_.from_object.object->pluginobj() == NULL);
	    Relobj* relobj = static_cast<Relobj*>(this->u_.from_object.object);
	    return relobj->output_section(shndx);
	  }
	return NULL;
      }

    case IN_OUTPUT_DATA:
      return this->u_.in_output_data.output_data->output_section();

    case IN_OUTPUT_SEGMENT:
    case IS_CONSTANT:
    case IS_UNDEFINED:
      return NULL;

    default:
      gold_unreachable();
    }
}

// Set the symbol's output section.  This is used for symbols defined
// in scripts.  This should only be called after the symbol table has
// been finalized.

void
Symbol::set_output_section(Output_section* os)
{
  switch (this->source_)
    {
    case FROM_OBJECT:
    case IN_OUTPUT_DATA:
      gold_assert(this->output_section() == os);
      break;
    case IS_CONSTANT:
      this->source_ = IN_OUTPUT_DATA;
      this->u_.in_output_data.output_data = os;
      this->u_.in_output_data.offset_is_from_end = false;
      break;
    case IN_OUTPUT_SEGMENT:
    case IS_UNDEFINED:
    default:
      gold_unreachable();
    }
}

// Class Symbol_table.

Symbol_table::Symbol_table(unsigned int count,
                           const Version_script_info& version_script)
  : saw_undefined_(0), offset_(0), table_(count), namepool_(),
    forwarders_(), commons_(), tls_commons_(), small_commons_(),
    large_commons_(), forced_locals_(), warnings_(),
    version_script_(version_script), gc_(NULL), icf_(NULL)
{
  namepool_.reserve(count);
}

Symbol_table::~Symbol_table()
{
}

// The symbol table key equality function.  This is called with
// Stringpool keys.

inline bool
Symbol_table::Symbol_table_eq::operator()(const Symbol_table_key& k1,
					  const Symbol_table_key& k2) const
{
  return k1.first == k2.first && k1.second == k2.second;
}

bool
Symbol_table::is_section_folded(Object* obj, unsigned int shndx) const
{
  return (parameters->options().icf_enabled()
          && this->icf_->is_section_folded(obj, shndx));
}

// For symbols that have been listed with a -u or --export-dynamic-symbol
// option, add them to the work list to avoid gc'ing them.

void 
Symbol_table::gc_mark_undef_symbols(Layout* layout)
{
  for (options::String_set::const_iterator p =
	 parameters->options().undefined_begin();
       p != parameters->options().undefined_end();
       ++p)
    {
      const char* name = p->c_str();
      Symbol* sym = this->lookup(name);
      gold_assert(sym != NULL);
      if (sym->source() == Symbol::FROM_OBJECT 
          && !sym->object()->is_dynamic())
        {
	  this->gc_mark_symbol(sym);
        }
    }

  for (options::String_set::const_iterator p =
	 parameters->options().export_dynamic_symbol_begin();
       p != parameters->options().export_dynamic_symbol_end();
       ++p)
    {
      const char* name = p->c_str();
      Symbol* sym = this->lookup(name);
      // It's not an error if a symbol named by --export-dynamic-symbol
      // is undefined.
      if (sym != NULL
	  && sym->source() == Symbol::FROM_OBJECT 
          && !sym->object()->is_dynamic())
        {
	  this->gc_mark_symbol(sym);
        }
    }

  for (Script_options::referenced_const_iterator p =
	 layout->script_options()->referenced_begin();
       p != layout->script_options()->referenced_end();
       ++p)
    {
      Symbol* sym = this->lookup(p->c_str());
      gold_assert(sym != NULL);
      if (sym->source() == Symbol::FROM_OBJECT
	  && !sym->object()->is_dynamic())
	{
	  this->gc_mark_symbol(sym);
	}
    }
}

void
Symbol_table::gc_mark_symbol(Symbol* sym)
{
  // Add the object and section to the work list.
  bool is_ordinary;
  unsigned int shndx = sym->shndx(&is_ordinary);
  if (is_ordinary && shndx != elfcpp::SHN_UNDEF)
    {
      gold_assert(this->gc_!= NULL);
      this->gc_->worklist().push(Section_id(sym->object(), shndx));
    }
  parameters->target().gc_mark_symbol(this, sym);
}

// When doing garbage collection, keep symbols that have been seen in
// dynamic objects.
inline void 
Symbol_table::gc_mark_dyn_syms(Symbol* sym)
{
  if (sym->in_dyn() && sym->source() == Symbol::FROM_OBJECT
      && !sym->object()->is_dynamic())
    this->gc_mark_symbol(sym);
}

// Make TO a symbol which forwards to FROM.

void
Symbol_table::make_forwarder(Symbol* from, Symbol* to)
{
  gold_assert(from != to);
  gold_assert(!from->is_forwarder() && !to->is_forwarder());
  this->forwarders_[from] = to;
  from->set_forwarder();
}

// Resolve the forwards from FROM, returning the real symbol.

Symbol*
Symbol_table::resolve_forwards(const Symbol* from) const
{
  gold_assert(from->is_forwarder());
  Unordered_map<const Symbol*, Symbol*>::const_iterator p =
    this->forwarders_.find(from);
  gold_assert(p != this->forwarders_.end());
  return p->second;
}

// Look up a symbol by name.

Symbol*
Symbol_table::lookup(const char* name, const char* version) const
{
  Stringpool::Key name_key;
  name = this->namepool_.find(name, &name_key);
  if (name == NULL)
    return NULL;

  Stringpool::Key version_key = 0;
  if (version != NULL)
    {
      version = this->namepool_.find(version, &version_key);
      if (version == NULL)
	return NULL;
    }

  Symbol_table_key key(name_key, version_key);
  Symbol_table::Symbol_table_type::const_iterator p = this->table_.find(key);
  if (p == this->table_.end())
    return NULL;
  return p->second;
}

// Resolve a Symbol with another Symbol.  This is only used in the
// unusual case where there are references to both an unversioned
// symbol and a symbol with a version, and we then discover that that
// version is the default version.  Because this is unusual, we do
// this the slow way, by converting back to an ELF symbol.

template<int size, bool big_endian>
void
Symbol_table::resolve(Sized_symbol<size>* to, const Sized_symbol<size>* from)
{
  unsigned char buf[elfcpp::Elf_sizes<size>::sym_size];
  elfcpp::Sym_write<size, big_endian> esym(buf);
  // We don't bother to set the st_name or the st_shndx field.
  esym.put_st_value(from->value());
  esym.put_st_size(from->symsize());
  esym.put_st_info(from->binding(), from->type());
  esym.put_st_other(from->visibility(), from->nonvis());
  bool is_ordinary;
  unsigned int shndx = from->shndx(&is_ordinary);
  this->resolve(to, esym.sym(), shndx, is_ordinary, shndx, from->object(),
		from->version());
  if (from->in_reg())
    to->set_in_reg();
  if (from->in_dyn())
    to->set_in_dyn();
  if (parameters->options().gc_sections())
    this->gc_mark_dyn_syms(to);
}

// Record that a symbol is forced to be local by a version script or
// by visibility.

void
Symbol_table::force_local(Symbol* sym)
{
  if (!sym->is_defined() && !sym->is_common())
    return;
  if (sym->is_forced_local())
    {
      // We already got this one.
      return;
    }
  sym->set_is_forced_local();
  this->forced_locals_.push_back(sym);
}

// Adjust NAME for wrapping, and update *NAME_KEY if necessary.  This
// is only called for undefined symbols, when at least one --wrap
// option was used.

const char*
Symbol_table::wrap_symbol(const char* name, Stringpool::Key* name_key)
{
  // For some targets, we need to ignore a specific character when
  // wrapping, and add it back later.
  char prefix = '\0';
  if (name[0] == parameters->target().wrap_char())
    {
      prefix = name[0];
      ++name;
    }

  if (parameters->options().is_wrap(name))
    {
      // Turn NAME into __wrap_NAME.
      std::string s;
      if (prefix != '\0')
	s += prefix;
      s += "__wrap_";
      s += name;

      // This will give us both the old and new name in NAMEPOOL_, but
      // that is OK.  Only the versions we need will wind up in the
      // real string table in the output file.
      return this->namepool_.add(s.c_str(), true, name_key);
    }

  const char* const real_prefix = "__real_";
  const size_t real_prefix_length = strlen(real_prefix);
  if (strncmp(name, real_prefix, real_prefix_length) == 0
      && parameters->options().is_wrap(name + real_prefix_length))
    {
      // Turn __real_NAME into NAME.
      std::string s;
      if (prefix != '\0')
	s += prefix;
      s += name + real_prefix_length;
      return this->namepool_.add(s.c_str(), true, name_key);
    }

  return name;
}

// This is called when we see a symbol NAME/VERSION, and the symbol
// already exists in the symbol table, and VERSION is marked as being
// the default version.  SYM is the NAME/VERSION symbol we just added.
// DEFAULT_IS_NEW is true if this is the first time we have seen the
// symbol NAME/NULL.  PDEF points to the entry for NAME/NULL.

template<int size, bool big_endian>
void
Symbol_table::define_default_version(Sized_symbol<size>* sym,
				     bool default_is_new,
				     Symbol_table_type::iterator pdef)
{
  if (default_is_new)
    {
      // This is the first time we have seen NAME/NULL.  Make
      // NAME/NULL point to NAME/VERSION, and mark SYM as the default
      // version.
      pdef->second = sym;
      sym->set_is_default();
    }
  else if (pdef->second == sym)
    {
      // NAME/NULL already points to NAME/VERSION.  Don't mark the
      // symbol as the default if it is not already the default.
    }
  else
    {
      // This is the unfortunate case where we already have entries
      // for both NAME/VERSION and NAME/NULL.  We now see a symbol
      // NAME/VERSION where VERSION is the default version.  We have
      // already resolved this new symbol with the existing
      // NAME/VERSION symbol.

      // It's possible that NAME/NULL and NAME/VERSION are both
      // defined in regular objects.  This can only happen if one
      // object file defines foo and another defines foo@@@@ver.  This
      // is somewhat obscure, but we call it a multiple definition
      // error.

      // It's possible that NAME/NULL actually has a version, in which
      // case it won't be the same as VERSION.  This happens with
      // ver_test_7.so in the testsuite for the symbol t2_2.  We see
      // t2_2@@@@VER2, so we define both t2_2/VER2 and t2_2/NULL.  We
      // then see an unadorned t2_2 in an object file and give it
      // version VER1 from the version script.  This looks like a
      // default definition for VER1, so it looks like we should merge
      // t2_2/NULL with t2_2/VER1.  That doesn't make sense, but it's
      // not obvious that this is an error, either.  So we just punt.

      // If one of the symbols has non-default visibility, and the
      // other is defined in a shared object, then they are different
      // symbols.

      // Otherwise, we just resolve the symbols as though they were
      // the same.

      if (pdef->second->version() != NULL)
	gold_assert(pdef->second->version() != sym->version());
      else if (sym->visibility() != elfcpp::STV_DEFAULT
	       && pdef->second->is_from_dynobj())
	;
      else if (pdef->second->visibility() != elfcpp::STV_DEFAULT
	       && sym->is_from_dynobj())
	;
      else
	{
	  const Sized_symbol<size>* symdef;
	  symdef = this->get_sized_symbol<size>(pdef->second);
	  Symbol_table::resolve<size, big_endian>(sym, symdef);
	  this->make_forwarder(pdef->second, sym);
	  pdef->second = sym;
	  sym->set_is_default();
	}
    }
}

// Add one symbol from OBJECT to the symbol table.  NAME is symbol
// name and VERSION is the version; both are canonicalized.  DEF is
// whether this is the default version.  ST_SHNDX is the symbol's
// section index; IS_ORDINARY is whether this is a normal section
// rather than a special code.

// If IS_DEFAULT_VERSION is true, then this is the definition of a
// default version of a symbol.  That means that any lookup of
// NAME/NULL and any lookup of NAME/VERSION should always return the
// same symbol.  This is obvious for references, but in particular we
// want to do this for definitions: overriding NAME/NULL should also
// override NAME/VERSION.  If we don't do that, it would be very hard
// to override functions in a shared library which uses versioning.

// We implement this by simply making both entries in the hash table
// point to the same Symbol structure.  That is easy enough if this is
// the first time we see NAME/NULL or NAME/VERSION, but it is possible
// that we have seen both already, in which case they will both have
// independent entries in the symbol table.  We can't simply change
// the symbol table entry, because we have pointers to the entries
// attached to the object files.  So we mark the entry attached to the
// object file as a forwarder, and record it in the forwarders_ map.
// Note that entries in the hash table will never be marked as
// forwarders.
//
// ORIG_ST_SHNDX and ST_SHNDX are almost always the same.
// ORIG_ST_SHNDX is the section index in the input file, or SHN_UNDEF
// for a special section code.  ST_SHNDX may be modified if the symbol
// is defined in a section being discarded.

template<int size, bool big_endian>
Sized_symbol<size>*
Symbol_table::add_from_object(Object* object,
			      const char* name,
			      Stringpool::Key name_key,
			      const char* version,
			      Stringpool::Key version_key,
			      bool is_default_version,
			      const elfcpp::Sym<size, big_endian>& sym,
			      unsigned int st_shndx,
			      bool is_ordinary,
			      unsigned int orig_st_shndx)
{
  // Print a message if this symbol is being traced.
  if (parameters->options().is_trace_symbol(name))
    {
      if (orig_st_shndx == elfcpp::SHN_UNDEF)
        gold_info(_("%s: reference to %s"), object->name().c_str(), name);
      else
        gold_info(_("%s: definition of %s"), object->name().c_str(), name);
    }

  // For an undefined symbol, we may need to adjust the name using
  // --wrap.
  if (orig_st_shndx == elfcpp::SHN_UNDEF
      && parameters->options().any_wrap())
    {
      const char* wrap_name = this->wrap_symbol(name, &name_key);
      if (wrap_name != name)
	{
	  // If we see a reference to malloc with version GLIBC_2.0,
	  // and we turn it into a reference to __wrap_malloc, then we
	  // discard the version number.  Otherwise the user would be
	  // required to specify the correct version for
	  // __wrap_malloc.
	  version = NULL;
	  version_key = 0;
	  name = wrap_name;
	}
    }

  Symbol* const snull = NULL;
  std::pair<typename Symbol_table_type::iterator, bool> ins =
    this->table_.insert(std::make_pair(std::make_pair(name_key, version_key),
				       snull));

  std::pair<typename Symbol_table_type::iterator, bool> insdefault =
    std::make_pair(this->table_.end(), false);
  if (is_default_version)
    {
      const Stringpool::Key vnull_key = 0;
      insdefault = this->table_.insert(std::make_pair(std::make_pair(name_key,
								     vnull_key),
						      snull));
    }

  // ins.first: an iterator, which is a pointer to a pair.
  // ins.first->first: the key (a pair of name and version).
  // ins.first->second: the value (Symbol*).
  // ins.second: true if new entry was inserted, false if not.

  Sized_symbol<size>* ret;
  bool was_undefined;
  bool was_common;
  if (!ins.second)
    {
      // We already have an entry for NAME/VERSION.
      ret = this->get_sized_symbol<size>(ins.first->second);
      gold_assert(ret != NULL);

      was_undefined = ret->is_undefined();
      was_common = ret->is_common();

      this->resolve(ret, sym, st_shndx, is_ordinary, orig_st_shndx, object,
		    version);
      if (parameters->options().gc_sections())
        this->gc_mark_dyn_syms(ret);

      if (is_default_version)
	this->define_default_version<size, big_endian>(ret, insdefault.second,
						       insdefault.first);
    }
  else
    {
      // This is the first time we have seen NAME/VERSION.
      gold_assert(ins.first->second == NULL);

      if (is_default_version && !insdefault.second)
	{
	  // We already have an entry for NAME/NULL.  If we override
	  // it, then change it to NAME/VERSION.
	  ret = this->get_sized_symbol<size>(insdefault.first->second);

	  was_undefined = ret->is_undefined();
	  was_common = ret->is_common();

	  this->resolve(ret, sym, st_shndx, is_ordinary, orig_st_shndx, object,
			version);
          if (parameters->options().gc_sections())
            this->gc_mark_dyn_syms(ret);
	  ins.first->second = ret;
	}
      else
	{
	  was_undefined = false;
	  was_common = false;

	  Sized_target<size, big_endian>* target =
	    parameters->sized_target<size, big_endian>();
	  if (!target->has_make_symbol())
	    ret = new Sized_symbol<size>();
	  else
	    {
	      ret = target->make_symbol();
	      if (ret == NULL)
		{
		  // This means that we don't want a symbol table
		  // entry after all.
		  if (!is_default_version)
		    this->table_.erase(ins.first);
		  else
		    {
		      this->table_.erase(insdefault.first);
		      // Inserting INSDEFAULT invalidated INS.
		      this->table_.erase(std::make_pair(name_key,
							version_key));
		    }
		  return NULL;
		}
	    }

	  ret->init_object(name, version, object, sym, st_shndx, is_ordinary);

	  ins.first->second = ret;
	  if (is_default_version)
	    {
	      // This is the first time we have seen NAME/NULL.  Point
	      // it at the new entry for NAME/VERSION.
	      gold_assert(insdefault.second);
	      insdefault.first->second = ret;
	    }
	}

      if (is_default_version)
	ret->set_is_default();
    }

  // Record every time we see a new undefined symbol, to speed up
  // archive groups.
  if (!was_undefined && ret->is_undefined())
    {
      ++this->saw_undefined_;
      if (parameters->options().has_plugins())
	parameters->options().plugins()->new_undefined_symbol(ret);
    }

  // Keep track of common symbols, to speed up common symbol
  // allocation.
  if (!was_common && ret->is_common())
    {
      if (ret->type() == elfcpp::STT_TLS)
	this->tls_commons_.push_back(ret);
      else if (!is_ordinary
	       && st_shndx == parameters->target().small_common_shndx())
	this->small_commons_.push_back(ret);
      else if (!is_ordinary
	       && st_shndx == parameters->target().large_common_shndx())
	this->large_commons_.push_back(ret);
      else
	this->commons_.push_back(ret);
    }

  // If we're not doing a relocatable link, then any symbol with
  // hidden or internal visibility is local.
  if ((ret->visibility() == elfcpp::STV_HIDDEN
       || ret->visibility() == elfcpp::STV_INTERNAL)
      && (ret->binding() == elfcpp::STB_GLOBAL
	  || ret->binding() == elfcpp::STB_GNU_UNIQUE
	  || ret->binding() == elfcpp::STB_WEAK)
      && !parameters->options().relocatable())
    this->force_local(ret);

  return ret;
}

// Add all the symbols in a relocatable object to the hash table.

template<int size, bool big_endian>
void
Symbol_table::add_from_relobj(
    Sized_relobj_file<size, big_endian>* relobj,
    const unsigned char* syms,
    size_t count,
    size_t symndx_offset,
    const char* sym_names,
    size_t sym_name_size,
    typename Sized_relobj_file<size, big_endian>::Symbols* sympointers,
    size_t* defined)
{
  *defined = 0;

  gold_assert(size == parameters->target().get_size());

  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;

  const bool just_symbols = relobj->just_symbols();

  const unsigned char* p = syms;
  for (size_t i = 0; i < count; ++i, p += sym_size)
    {
      (*sympointers)[i] = NULL;

      elfcpp::Sym<size, big_endian> sym(p);

      unsigned int st_name = sym.get_st_name();
      if (st_name >= sym_name_size)
	{
	  relobj->error(_("bad global symbol name offset %u at %zu"),
			st_name, i);
	  continue;
	}

      const char* name = sym_names + st_name;

      bool is_ordinary;
      unsigned int st_shndx = relobj->adjust_sym_shndx(i + symndx_offset,
						       sym.get_st_shndx(),
						       &is_ordinary);
      unsigned int orig_st_shndx = st_shndx;
      if (!is_ordinary)
	orig_st_shndx = elfcpp::SHN_UNDEF;

      if (st_shndx != elfcpp::SHN_UNDEF)
	++*defined;

      // A symbol defined in a section which we are not including must
      // be treated as an undefined symbol.
      bool is_defined_in_discarded_section = false;
      if (st_shndx != elfcpp::SHN_UNDEF
	  && is_ordinary
	  && !relobj->is_section_included(st_shndx)
          && !this->is_section_folded(relobj, st_shndx))
	{
	  st_shndx = elfcpp::SHN_UNDEF;
	  is_defined_in_discarded_section = true;
	}

      // In an object file, an '@@' in the name separates the symbol
      // name from the version name.  If there are two '@@' characters,
      // this is the default version.
      const char* ver = strchr(name, '@@');
      Stringpool::Key ver_key = 0;
      int namelen = 0;
      // IS_DEFAULT_VERSION: is the version default?
      // IS_FORCED_LOCAL: is the symbol forced local?
      bool is_default_version = false;
      bool is_forced_local = false;

      // FIXME: For incremental links, we don't store version information,
      // so we need to ignore version symbols for now.
      if (parameters->incremental_update() && ver != NULL)
	{
	  namelen = ver - name;
	  ver = NULL;
	}

      if (ver != NULL)
        {
          // The symbol name is of the form foo@@VERSION or foo@@@@VERSION
          namelen = ver - name;
          ++ver;
	  if (*ver == '@@')
	    {
	      is_default_version = true;
	      ++ver;
	    }
	  ver = this->namepool_.add(ver, true, &ver_key);
        }
      // We don't want to assign a version to an undefined symbol,
      // even if it is listed in the version script.  FIXME: What
      // about a common symbol?
      else
	{
	  namelen = strlen(name);
	  if (!this->version_script_.empty()
	      && st_shndx != elfcpp::SHN_UNDEF)
	    {
	      // The symbol name did not have a version, but the
	      // version script may assign a version anyway.
	      std::string version;
	      bool is_global;
	      if (this->version_script_.get_symbol_version(name, &version,
							   &is_global))
		{
		  if (!is_global)
		    is_forced_local = true;
		  else if (!version.empty())
		    {
		      ver = this->namepool_.add_with_length(version.c_str(),
							    version.length(),
							    true,
							    &ver_key);
		      is_default_version = true;
		    }
		}
	    }
	}

      elfcpp::Sym<size, big_endian>* psym = &sym;
      unsigned char symbuf[sym_size];
      elfcpp::Sym<size, big_endian> sym2(symbuf);
      if (just_symbols)
	{
	  memcpy(symbuf, p, sym_size);
	  elfcpp::Sym_write<size, big_endian> sw(symbuf);
	  if (orig_st_shndx != elfcpp::SHN_UNDEF
	      && is_ordinary
	      && relobj->e_type() == elfcpp::ET_REL)
	    {
	      // Symbol values in relocatable object files are section
	      // relative.  This is normally what we want, but since here
	      // we are converting the symbol to absolute we need to add
	      // the section address.  The section address in an object
	      // file is normally zero, but people can use a linker
	      // script to change it.
	      sw.put_st_value(sym.get_st_value()
			      + relobj->section_address(orig_st_shndx));
	    }
	  st_shndx = elfcpp::SHN_ABS;
	  is_ordinary = false;
	  psym = &sym2;
	}

      // Fix up visibility if object has no-export set.
      if (relobj->no_export()
	  && (orig_st_shndx != elfcpp::SHN_UNDEF || !is_ordinary))
        {
	  // We may have copied symbol already above.
	  if (psym != &sym2)
	    {
	      memcpy(symbuf, p, sym_size);
	      psym = &sym2;
	    }

	  elfcpp::STV visibility = sym2.get_st_visibility();
	  if (visibility == elfcpp::STV_DEFAULT
	      || visibility == elfcpp::STV_PROTECTED)
	    {
	      elfcpp::Sym_write<size, big_endian> sw(symbuf);
	      unsigned char nonvis = sym2.get_st_nonvis();
	      sw.put_st_other(elfcpp::STV_HIDDEN, nonvis);
	    }
        }

      Stringpool::Key name_key;
      name = this->namepool_.add_with_length(name, namelen, true,
					     &name_key);

      Sized_symbol<size>* res;
      res = this->add_from_object(relobj, name, name_key, ver, ver_key,
				  is_default_version, *psym, st_shndx,
				  is_ordinary, orig_st_shndx);
      
      if (is_forced_local)
	this->force_local(res);

      // Do not treat this symbol as garbage if this symbol will be
      // exported to the dynamic symbol table.  This is true when
      // building a shared library or using --export-dynamic and
      // the symbol is externally visible.
      if (parameters->options().gc_sections()
	  && res->is_externally_visible()
	  && !res->is_from_dynobj()
          && (parameters->options().shared()
	      || parameters->options().export_dynamic()))
        this->gc_mark_symbol(res);

      if (is_defined_in_discarded_section)
	res->set_is_defined_in_discarded_section();

      (*sympointers)[i] = res;
    }
}

// Add a symbol from a plugin-claimed file.

template<int size, bool big_endian>
Symbol*
Symbol_table::add_from_pluginobj(
    Sized_pluginobj<size, big_endian>* obj,
    const char* name,
    const char* ver,
    elfcpp::Sym<size, big_endian>* sym)
{
  unsigned int st_shndx = sym->get_st_shndx();
  bool is_ordinary = st_shndx < elfcpp::SHN_LORESERVE;

  Stringpool::Key ver_key = 0;
  bool is_default_version = false;
  bool is_forced_local = false;

  if (ver != NULL)
    {
      ver = this->namepool_.add(ver, true, &ver_key);
    }
  // We don't want to assign a version to an undefined symbol,
  // even if it is listed in the version script.  FIXME: What
  // about a common symbol?
  else
    {
      if (!this->version_script_.empty()
          && st_shndx != elfcpp::SHN_UNDEF)
        {
          // The symbol name did not have a version, but the
          // version script may assign a version anyway.
          std::string version;
	  bool is_global;
          if (this->version_script_.get_symbol_version(name, &version,
						       &is_global))
            {
	      if (!is_global)
		is_forced_local = true;
	      else if (!version.empty())
                {
                  ver = this->namepool_.add_with_length(version.c_str(),
                                                        version.length(),
                                                        true,
                                                        &ver_key);
                  is_default_version = true;
                }
            }
        }
    }

  Stringpool::Key name_key;
  name = this->namepool_.add(name, true, &name_key);

  Sized_symbol<size>* res;
  res = this->add_from_object(obj, name, name_key, ver, ver_key,
		              is_default_version, *sym, st_shndx,
			      is_ordinary, st_shndx);

  if (is_forced_local)
    this->force_local(res);

  return res;
}

// Add all the symbols in a dynamic object to the hash table.

template<int size, bool big_endian>
void
Symbol_table::add_from_dynobj(
    Sized_dynobj<size, big_endian>* dynobj,
    const unsigned char* syms,
    size_t count,
    const char* sym_names,
    size_t sym_name_size,
    const unsigned char* versym,
    size_t versym_size,
    const std::vector<const char*>* version_map,
    typename Sized_relobj_file<size, big_endian>::Symbols* sympointers,
    size_t* defined)
{
  *defined = 0;

  gold_assert(size == parameters->target().get_size());

  if (dynobj->just_symbols())
    {
      gold_error(_("--just-symbols does not make sense with a shared object"));
      return;
    }

  // FIXME: For incremental links, we don't store version information,
  // so we need to ignore version symbols for now.
  if (parameters->incremental_update())
    versym = NULL;

  if (versym != NULL && versym_size / 2 < count)
    {
      dynobj->error(_("too few symbol versions"));
      return;
    }

  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;

  // We keep a list of all STT_OBJECT symbols, so that we can resolve
  // weak aliases.  This is necessary because if the dynamic object
  // provides the same variable under two names, one of which is a
  // weak definition, and the regular object refers to the weak
  // definition, we have to put both the weak definition and the
  // strong definition into the dynamic symbol table.  Given a weak
  // definition, the only way that we can find the corresponding
  // strong definition, if any, is to search the symbol table.
  std::vector<Sized_symbol<size>*> object_symbols;

  const unsigned char* p = syms;
  const unsigned char* vs = versym;
  for (size_t i = 0; i < count; ++i, p += sym_size, vs += 2)
    {
      elfcpp::Sym<size, big_endian> sym(p);

      if (sympointers != NULL)
	(*sympointers)[i] = NULL;

      // Ignore symbols with local binding or that have
      // internal or hidden visibility.
      if (sym.get_st_bind() == elfcpp::STB_LOCAL
          || sym.get_st_visibility() == elfcpp::STV_INTERNAL
          || sym.get_st_visibility() == elfcpp::STV_HIDDEN)
	continue;

      // A protected symbol in a shared library must be treated as a
      // normal symbol when viewed from outside the shared library.
      // Implement this by overriding the visibility here.
      elfcpp::Sym<size, big_endian>* psym = &sym;
      unsigned char symbuf[sym_size];
      elfcpp::Sym<size, big_endian> sym2(symbuf);
      if (sym.get_st_visibility() == elfcpp::STV_PROTECTED)
	{
	  memcpy(symbuf, p, sym_size);
	  elfcpp::Sym_write<size, big_endian> sw(symbuf);
	  sw.put_st_other(elfcpp::STV_DEFAULT, sym.get_st_nonvis());
	  psym = &sym2;
	}

      unsigned int st_name = psym->get_st_name();
      if (st_name >= sym_name_size)
	{
	  dynobj->error(_("bad symbol name offset %u at %zu"),
			st_name, i);
	  continue;
	}

      const char* name = sym_names + st_name;

      bool is_ordinary;
      unsigned int st_shndx = dynobj->adjust_sym_shndx(i, psym->get_st_shndx(),
						       &is_ordinary);

      if (st_shndx != elfcpp::SHN_UNDEF)
	++*defined;

      Sized_symbol<size>* res;

      if (versym == NULL)
	{
	  Stringpool::Key name_key;
	  name = this->namepool_.add(name, true, &name_key);
	  res = this->add_from_object(dynobj, name, name_key, NULL, 0,
				      false, *psym, st_shndx, is_ordinary,
				      st_shndx);
	}
      else
	{
	  // Read the version information.

	  unsigned int v = elfcpp::Swap<16, big_endian>::readval(vs);

	  bool hidden = (v & elfcpp::VERSYM_HIDDEN) != 0;
	  v &= elfcpp::VERSYM_VERSION;

	  // The Sun documentation says that V can be VER_NDX_LOCAL,
	  // or VER_NDX_GLOBAL, or a version index.  The meaning of
	  // VER_NDX_LOCAL is defined as "Symbol has local scope."
	  // The old GNU linker will happily generate VER_NDX_LOCAL
	  // for an undefined symbol.  I don't know what the Sun
	  // linker will generate.

	  if (v == static_cast<unsigned int>(elfcpp::VER_NDX_LOCAL)
	      && st_shndx != elfcpp::SHN_UNDEF)
	    {
	      // This symbol should not be visible outside the object.
	      continue;
	    }

	  // At this point we are definitely going to add this symbol.
	  Stringpool::Key name_key;
	  name = this->namepool_.add(name, true, &name_key);

	  if (v == static_cast<unsigned int>(elfcpp::VER_NDX_LOCAL)
	      || v == static_cast<unsigned int>(elfcpp::VER_NDX_GLOBAL))
	    {
	      // This symbol does not have a version.
	      res = this->add_from_object(dynobj, name, name_key, NULL, 0,
					  false, *psym, st_shndx, is_ordinary,
					  st_shndx);
	    }
	  else
	    {
	      if (v >= version_map->size())
		{
		  dynobj->error(_("versym for symbol %zu out of range: %u"),
				i, v);
		  continue;
		}

	      const char* version = (*version_map)[v];
	      if (version == NULL)
		{
		  dynobj->error(_("versym for symbol %zu has no name: %u"),
				i, v);
		  continue;
		}

	      Stringpool::Key version_key;
	      version = this->namepool_.add(version, true, &version_key);

	      // If this is an absolute symbol, and the version name
	      // and symbol name are the same, then this is the
	      // version definition symbol.  These symbols exist to
	      // support using -u to pull in particular versions.  We
	      // do not want to record a version for them.
	      if (st_shndx == elfcpp::SHN_ABS
		  && !is_ordinary
		  && name_key == version_key)
		res = this->add_from_object(dynobj, name, name_key, NULL, 0,
					    false, *psym, st_shndx, is_ordinary,
					    st_shndx);
	      else
		{
		  const bool is_default_version =
		    !hidden && st_shndx != elfcpp::SHN_UNDEF;
		  res = this->add_from_object(dynobj, name, name_key, version,
					      version_key, is_default_version,
					      *psym, st_shndx,
					      is_ordinary, st_shndx);
		}
	    }
	}

      // Note that it is possible that RES was overridden by an
      // earlier object, in which case it can't be aliased here.
      if (st_shndx != elfcpp::SHN_UNDEF
	  && is_ordinary
	  && psym->get_st_type() == elfcpp::STT_OBJECT
	  && res->source() == Symbol::FROM_OBJECT
	  && res->object() == dynobj)
	object_symbols.push_back(res);

      if (sympointers != NULL)
	(*sympointers)[i] = res;
    }

  this->record_weak_aliases(&object_symbols);
}

// Add a symbol from a incremental object file.

template<int size, bool big_endian>
Sized_symbol<size>*
Symbol_table::add_from_incrobj(
    Object* obj,
    const char* name,
    const char* ver,
    elfcpp::Sym<size, big_endian>* sym)
{
  unsigned int st_shndx = sym->get_st_shndx();
  bool is_ordinary = st_shndx < elfcpp::SHN_LORESERVE;

  Stringpool::Key ver_key = 0;
  bool is_default_version = false;
  bool is_forced_local = false;

  Stringpool::Key name_key;
  name = this->namepool_.add(name, true, &name_key);

  Sized_symbol<size>* res;
  res = this->add_from_object(obj, name, name_key, ver, ver_key,
		              is_default_version, *sym, st_shndx,
			      is_ordinary, st_shndx);

  if (is_forced_local)
    this->force_local(res);

  return res;
}

// This is used to sort weak aliases.  We sort them first by section
// index, then by offset, then by weak ahead of strong.

template<int size>
class Weak_alias_sorter
{
 public:
  bool operator()(const Sized_symbol<size>*, const Sized_symbol<size>*) const;
};

template<int size>
bool
Weak_alias_sorter<size>::operator()(const Sized_symbol<size>* s1,
				    const Sized_symbol<size>* s2) const
{
  bool is_ordinary;
  unsigned int s1_shndx = s1->shndx(&is_ordinary);
  gold_assert(is_ordinary);
  unsigned int s2_shndx = s2->shndx(&is_ordinary);
  gold_assert(is_ordinary);
  if (s1_shndx != s2_shndx)
    return s1_shndx < s2_shndx;

  if (s1->value() != s2->value())
    return s1->value() < s2->value();
  if (s1->binding() != s2->binding())
    {
      if (s1->binding() == elfcpp::STB_WEAK)
	return true;
      if (s2->binding() == elfcpp::STB_WEAK)
	return false;
    }
  return std::string(s1->name()) < std::string(s2->name());
}

// SYMBOLS is a list of object symbols from a dynamic object.  Look
// for any weak aliases, and record them so that if we add the weak
// alias to the dynamic symbol table, we also add the corresponding
// strong symbol.

template<int size>
void
Symbol_table::record_weak_aliases(std::vector<Sized_symbol<size>*>* symbols)
{
  // Sort the vector by section index, then by offset, then by weak
  // ahead of strong.
  std::sort(symbols->begin(), symbols->end(), Weak_alias_sorter<size>());

  // Walk through the vector.  For each weak definition, record
  // aliases.
  for (typename std::vector<Sized_symbol<size>*>::const_iterator p =
	 symbols->begin();
       p != symbols->end();
       ++p)
    {
      if ((*p)->binding() != elfcpp::STB_WEAK)
	continue;

      // Build a circular list of weak aliases.  Each symbol points to
      // the next one in the circular list.

      Sized_symbol<size>* from_sym = *p;
      typename std::vector<Sized_symbol<size>*>::const_iterator q;
      for (q = p + 1; q != symbols->end(); ++q)
	{
	  bool dummy;
	  if ((*q)->shndx(&dummy) != from_sym->shndx(&dummy)
	      || (*q)->value() != from_sym->value())
	    break;

	  this->weak_aliases_[from_sym] = *q;
	  from_sym->set_has_alias();
	  from_sym = *q;
	}

      if (from_sym != *p)
	{
	  this->weak_aliases_[from_sym] = *p;
	  from_sym->set_has_alias();
	}

      p = q - 1;
    }
}

// Create and return a specially defined symbol.  If ONLY_IF_REF is
// true, then only create the symbol if there is a reference to it.
// If this does not return NULL, it sets *POLDSYM to the existing
// symbol if there is one.  This sets *RESOLVE_OLDSYM if we should
// resolve the newly created symbol to the old one.  This
// canonicalizes *PNAME and *PVERSION.

template<int size, bool big_endian>
Sized_symbol<size>*
Symbol_table::define_special_symbol(const char** pname, const char** pversion,
				    bool only_if_ref,
                                    Sized_symbol<size>** poldsym,
				    bool* resolve_oldsym)
{
  *resolve_oldsym = false;
  *poldsym = NULL;

  // If the caller didn't give us a version, see if we get one from
  // the version script.
  std::string v;
  bool is_default_version = false;
  if (*pversion == NULL)
    {
      bool is_global;
      if (this->version_script_.get_symbol_version(*pname, &v, &is_global))
	{
	  if (is_global && !v.empty())
	    {
	      *pversion = v.c_str();
	      // If we get the version from a version script, then we
	      // are also the default version.
	      is_default_version = true;
	    }
	}
    }

  Symbol* oldsym;
  Sized_symbol<size>* sym;

  bool add_to_table = false;
  typename Symbol_table_type::iterator add_loc = this->table_.end();
  bool add_def_to_table = false;
  typename Symbol_table_type::iterator add_def_loc = this->table_.end();

  if (only_if_ref)
    {
      oldsym = this->lookup(*pname, *pversion);
      if (oldsym == NULL && is_default_version)
	oldsym = this->lookup(*pname, NULL);
      if (oldsym == NULL || !oldsym->is_undefined())
	return NULL;

      *pname = oldsym->name();
      if (is_default_version)
	*pversion = this->namepool_.add(*pversion, true, NULL);
      else
	*pversion = oldsym->version();
    }
  else
    {
      // Canonicalize NAME and VERSION.
      Stringpool::Key name_key;
      *pname = this->namepool_.add(*pname, true, &name_key);

      Stringpool::Key version_key = 0;
      if (*pversion != NULL)
	*pversion = this->namepool_.add(*pversion, true, &version_key);

      Symbol* const snull = NULL;
      std::pair<typename Symbol_table_type::iterator, bool> ins =
	this->table_.insert(std::make_pair(std::make_pair(name_key,
							  version_key),
					   snull));

      std::pair<typename Symbol_table_type::iterator, bool> insdefault =
	std::make_pair(this->table_.end(), false);
      if (is_default_version)
	{
	  const Stringpool::Key vnull = 0;
	  insdefault =
	    this->table_.insert(std::make_pair(std::make_pair(name_key,
							      vnull),
					       snull));
	}

      if (!ins.second)
	{
	  // We already have a symbol table entry for NAME/VERSION.
	  oldsym = ins.first->second;
	  gold_assert(oldsym != NULL);

	  if (is_default_version)
	    {
	      Sized_symbol<size>* soldsym =
		this->get_sized_symbol<size>(oldsym);
	      this->define_default_version<size, big_endian>(soldsym,
							     insdefault.second,
							     insdefault.first);
	    }
	}
      else
	{
	  // We haven't seen this symbol before.
	  gold_assert(ins.first->second == NULL);

	  add_to_table = true;
	  add_loc = ins.first;

	  if (is_default_version && !insdefault.second)
	    {
	      // We are adding NAME/VERSION, and it is the default
	      // version.  We already have an entry for NAME/NULL.
	      oldsym = insdefault.first->second;
	      *resolve_oldsym = true;
	    }
	  else
	    {
	      oldsym = NULL;

	      if (is_default_version)
		{
		  add_def_to_table = true;
		  add_def_loc = insdefault.first;
		}
	    }
	}
    }

  const Target& target = parameters->target();
  if (!target.has_make_symbol())
    sym = new Sized_symbol<size>();
  else
    {
      Sized_target<size, big_endian>* sized_target =
	parameters->sized_target<size, big_endian>();
      sym = sized_target->make_symbol();
      if (sym == NULL)
        return NULL;
    }

  if (add_to_table)
    add_loc->second = sym;
  else
    gold_assert(oldsym != NULL);

  if (add_def_to_table)
    add_def_loc->second = sym;

  *poldsym = this->get_sized_symbol<size>(oldsym);

  return sym;
}

// Define a symbol based on an Output_data.

Symbol*
Symbol_table::define_in_output_data(const char* name,
				    const char* version,
				    Defined defined,
				    Output_data* od,
				    uint64_t value,
				    uint64_t symsize,
				    elfcpp::STT type,
				    elfcpp::STB binding,
				    elfcpp::STV visibility,
				    unsigned char nonvis,
				    bool offset_is_from_end,
				    bool only_if_ref)
{
  if (parameters->target().get_size() == 32)
    {
#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
      return this->do_define_in_output_data<32>(name, version, defined, od,
                                                value, symsize, type, binding,
                                                visibility, nonvis,
                                                offset_is_from_end,
                                                only_if_ref);
#else
      gold_unreachable();
#endif
    }
  else if (parameters->target().get_size() == 64)
    {
#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
      return this->do_define_in_output_data<64>(name, version, defined, od,
                                                value, symsize, type, binding,
                                                visibility, nonvis,
                                                offset_is_from_end,
                                                only_if_ref);
#else
      gold_unreachable();
#endif
    }
  else
    gold_unreachable();
}

// Define a symbol in an Output_data, sized version.

template<int size>
Sized_symbol<size>*
Symbol_table::do_define_in_output_data(
    const char* name,
    const char* version,
    Defined defined,
    Output_data* od,
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    typename elfcpp::Elf_types<size>::Elf_WXword symsize,
    elfcpp::STT type,
    elfcpp::STB binding,
    elfcpp::STV visibility,
    unsigned char nonvis,
    bool offset_is_from_end,
    bool only_if_ref)
{
  Sized_symbol<size>* sym;
  Sized_symbol<size>* oldsym;
  bool resolve_oldsym;

  if (parameters->target().is_big_endian())
    {
#if defined(HAVE_TARGET_32_BIG) || defined(HAVE_TARGET_64_BIG)
      sym = this->define_special_symbol<size, true>(&name, &version,
						    only_if_ref, &oldsym,
						    &resolve_oldsym);
#else
      gold_unreachable();
#endif
    }
  else
    {
#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_64_LITTLE)
      sym = this->define_special_symbol<size, false>(&name, &version,
						     only_if_ref, &oldsym,
						     &resolve_oldsym);
#else
      gold_unreachable();
#endif
    }

  if (sym == NULL)
    return NULL;

  sym->init_output_data(name, version, od, value, symsize, type, binding,
			visibility, nonvis, offset_is_from_end,
			defined == PREDEFINED);

  if (oldsym == NULL)
    {
      if (binding == elfcpp::STB_LOCAL
	  || this->version_script_.symbol_is_local(name))
	this->force_local(sym);
      else if (version != NULL)
	sym->set_is_default();
      return sym;
    }

  if (Symbol_table::should_override_with_special(oldsym, type, defined))
    this->override_with_special(oldsym, sym);

  if (resolve_oldsym)
    return sym;
  else
    {
      delete sym;
      return oldsym;
    }
}

// Define a symbol based on an Output_segment.

Symbol*
Symbol_table::define_in_output_segment(const char* name,
				       const char* version,
				       Defined defined,
				       Output_segment* os,
				       uint64_t value,
				       uint64_t symsize,
				       elfcpp::STT type,
				       elfcpp::STB binding,
				       elfcpp::STV visibility,
				       unsigned char nonvis,
				       Symbol::Segment_offset_base offset_base,
				       bool only_if_ref)
{
  if (parameters->target().get_size() == 32)
    {
#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
      return this->do_define_in_output_segment<32>(name, version, defined, os,
                                                   value, symsize, type,
                                                   binding, visibility, nonvis,
                                                   offset_base, only_if_ref);
#else
      gold_unreachable();
#endif
    }
  else if (parameters->target().get_size() == 64)
    {
#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
      return this->do_define_in_output_segment<64>(name, version, defined, os,
                                                   value, symsize, type,
                                                   binding, visibility, nonvis,
                                                   offset_base, only_if_ref);
#else
      gold_unreachable();
#endif
    }
  else
    gold_unreachable();
}

// Define a symbol in an Output_segment, sized version.

template<int size>
Sized_symbol<size>*
Symbol_table::do_define_in_output_segment(
    const char* name,
    const char* version,
    Defined defined,
    Output_segment* os,
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    typename elfcpp::Elf_types<size>::Elf_WXword symsize,
    elfcpp::STT type,
    elfcpp::STB binding,
    elfcpp::STV visibility,
    unsigned char nonvis,
    Symbol::Segment_offset_base offset_base,
    bool only_if_ref)
{
  Sized_symbol<size>* sym;
  Sized_symbol<size>* oldsym;
  bool resolve_oldsym;

  if (parameters->target().is_big_endian())
    {
#if defined(HAVE_TARGET_32_BIG) || defined(HAVE_TARGET_64_BIG)
      sym = this->define_special_symbol<size, true>(&name, &version,
						    only_if_ref, &oldsym,
						    &resolve_oldsym);
#else
      gold_unreachable();
#endif
    }
  else
    {
#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_64_LITTLE)
      sym = this->define_special_symbol<size, false>(&name, &version,
						     only_if_ref, &oldsym,
						     &resolve_oldsym);
#else
      gold_unreachable();
#endif
    }

  if (sym == NULL)
    return NULL;

  sym->init_output_segment(name, version, os, value, symsize, type, binding,
			   visibility, nonvis, offset_base,
			   defined == PREDEFINED);

  if (oldsym == NULL)
    {
      if (binding == elfcpp::STB_LOCAL
	  || this->version_script_.symbol_is_local(name))
	this->force_local(sym);
      else if (version != NULL)
	sym->set_is_default();
      return sym;
    }

  if (Symbol_table::should_override_with_special(oldsym, type, defined))
    this->override_with_special(oldsym, sym);

  if (resolve_oldsym)
    return sym;
  else
    {
      delete sym;
      return oldsym;
    }
}

// Define a special symbol with a constant value.  It is a multiple
// definition error if this symbol is already defined.

Symbol*
Symbol_table::define_as_constant(const char* name,
				 const char* version,
				 Defined defined,
				 uint64_t value,
				 uint64_t symsize,
				 elfcpp::STT type,
				 elfcpp::STB binding,
				 elfcpp::STV visibility,
				 unsigned char nonvis,
				 bool only_if_ref,
                                 bool force_override)
{
  if (parameters->target().get_size() == 32)
    {
#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
      return this->do_define_as_constant<32>(name, version, defined, value,
                                             symsize, type, binding,
                                             visibility, nonvis, only_if_ref,
                                             force_override);
#else
      gold_unreachable();
#endif
    }
  else if (parameters->target().get_size() == 64)
    {
#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
      return this->do_define_as_constant<64>(name, version, defined, value,
                                             symsize, type, binding,
                                             visibility, nonvis, only_if_ref,
                                             force_override);
#else
      gold_unreachable();
#endif
    }
  else
    gold_unreachable();
}

// Define a symbol as a constant, sized version.

template<int size>
Sized_symbol<size>*
Symbol_table::do_define_as_constant(
    const char* name,
    const char* version,
    Defined defined,
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    typename elfcpp::Elf_types<size>::Elf_WXword symsize,
    elfcpp::STT type,
    elfcpp::STB binding,
    elfcpp::STV visibility,
    unsigned char nonvis,
    bool only_if_ref,
    bool force_override)
{
  Sized_symbol<size>* sym;
  Sized_symbol<size>* oldsym;
  bool resolve_oldsym;

  if (parameters->target().is_big_endian())
    {
#if defined(HAVE_TARGET_32_BIG) || defined(HAVE_TARGET_64_BIG)
      sym = this->define_special_symbol<size, true>(&name, &version,
						    only_if_ref, &oldsym,
						    &resolve_oldsym);
#else
      gold_unreachable();
#endif
    }
  else
    {
#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_64_LITTLE)
      sym = this->define_special_symbol<size, false>(&name, &version,
						     only_if_ref, &oldsym,
						     &resolve_oldsym);
#else
      gold_unreachable();
#endif
    }

  if (sym == NULL)
    return NULL;

  sym->init_constant(name, version, value, symsize, type, binding, visibility,
		     nonvis, defined == PREDEFINED);

  if (oldsym == NULL)
    {
      // Version symbols are absolute symbols with name == version.
      // We don't want to force them to be local.
      if ((version == NULL
	   || name != version
	   || value != 0)
	  && (binding == elfcpp::STB_LOCAL
	      || this->version_script_.symbol_is_local(name)))
	this->force_local(sym);
      else if (version != NULL
	       && (name != version || value != 0))
	sym->set_is_default();
      return sym;
    }

  if (force_override
      || Symbol_table::should_override_with_special(oldsym, type, defined))
    this->override_with_special(oldsym, sym);

  if (resolve_oldsym)
    return sym;
  else
    {
      delete sym;
      return oldsym;
    }
}

// Define a set of symbols in output sections.

void
Symbol_table::define_symbols(const Layout* layout, int count,
			     const Define_symbol_in_section* p,
			     bool only_if_ref)
{
  for (int i = 0; i < count; ++i, ++p)
    {
      Output_section* os = layout->find_output_section(p->output_section);
      if (os != NULL)
	this->define_in_output_data(p->name, NULL, PREDEFINED, os, p->value,
				    p->size, p->type, p->binding,
				    p->visibility, p->nonvis,
				    p->offset_is_from_end,
				    only_if_ref || p->only_if_ref);
      else
	this->define_as_constant(p->name, NULL, PREDEFINED, 0, p->size,
				 p->type, p->binding, p->visibility, p->nonvis,
				 only_if_ref || p->only_if_ref,
                                 false);
    }
}

// Define a set of symbols in output segments.

void
Symbol_table::define_symbols(const Layout* layout, int count,
			     const Define_symbol_in_segment* p,
			     bool only_if_ref)
{
  for (int i = 0; i < count; ++i, ++p)
    {
      Output_segment* os = layout->find_output_segment(p->segment_type,
						       p->segment_flags_set,
						       p->segment_flags_clear);
      if (os != NULL)
	this->define_in_output_segment(p->name, NULL, PREDEFINED, os, p->value,
				       p->size, p->type, p->binding,
				       p->visibility, p->nonvis,
				       p->offset_base,
				       only_if_ref || p->only_if_ref);
      else
	this->define_as_constant(p->name, NULL, PREDEFINED, 0, p->size,
				 p->type, p->binding, p->visibility, p->nonvis,
				 only_if_ref || p->only_if_ref,
                                 false);
    }
}

// Define CSYM using a COPY reloc.  POSD is the Output_data where the
// symbol should be defined--typically a .dyn.bss section.  VALUE is
// the offset within POSD.

template<int size>
void
Symbol_table::define_with_copy_reloc(
    Sized_symbol<size>* csym,
    Output_data* posd,
    typename elfcpp::Elf_types<size>::Elf_Addr value)
{
  gold_assert(csym->is_from_dynobj());
  gold_assert(!csym->is_copied_from_dynobj());
  Object* object = csym->object();
  gold_assert(object->is_dynamic());
  Dynobj* dynobj = static_cast<Dynobj*>(object);

  // Our copied variable has to override any variable in a shared
  // library.
  elfcpp::STB binding = csym->binding();
  if (binding == elfcpp::STB_WEAK)
    binding = elfcpp::STB_GLOBAL;

  this->define_in_output_data(csym->name(), csym->version(), COPY,
			      posd, value, csym->symsize(),
			      csym->type(), binding,
			      csym->visibility(), csym->nonvis(),
			      false, false);

  csym->set_is_copied_from_dynobj();
  csym->set_needs_dynsym_entry();

  this->copied_symbol_dynobjs_[csym] = dynobj;

  // We have now defined all aliases, but we have not entered them all
  // in the copied_symbol_dynobjs_ map.
  if (csym->has_alias())
    {
      Symbol* sym = csym;
      while (true)
	{
	  sym = this->weak_aliases_[sym];
	  if (sym == csym)
	    break;
	  gold_assert(sym->output_data() == posd);

	  sym->set_is_copied_from_dynobj();
	  this->copied_symbol_dynobjs_[sym] = dynobj;
	}
    }
}

// SYM is defined using a COPY reloc.  Return the dynamic object where
// the original definition was found.

Dynobj*
Symbol_table::get_copy_source(const Symbol* sym) const
{
  gold_assert(sym->is_copied_from_dynobj());
  Copied_symbol_dynobjs::const_iterator p =
    this->copied_symbol_dynobjs_.find(sym);
  gold_assert(p != this->copied_symbol_dynobjs_.end());
  return p->second;
}

// Add any undefined symbols named on the command line.

void
Symbol_table::add_undefined_symbols_from_command_line(Layout* layout)
{
  if (parameters->options().any_undefined()
      || layout->script_options()->any_unreferenced())
    {
      if (parameters->target().get_size() == 32)
	{
#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
	  this->do_add_undefined_symbols_from_command_line<32>(layout);
#else
	  gold_unreachable();
#endif
	}
      else if (parameters->target().get_size() == 64)
	{
#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
	  this->do_add_undefined_symbols_from_command_line<64>(layout);
#else
	  gold_unreachable();
#endif
	}
      else
	gold_unreachable();
    }
}

template<int size>
void
Symbol_table::do_add_undefined_symbols_from_command_line(Layout* layout)
{
  for (options::String_set::const_iterator p =
	 parameters->options().undefined_begin();
       p != parameters->options().undefined_end();
       ++p)
    this->add_undefined_symbol_from_command_line<size>(p->c_str());

  for (options::String_set::const_iterator p =
	 parameters->options().export_dynamic_symbol_begin();
       p != parameters->options().export_dynamic_symbol_end();
       ++p)
    this->add_undefined_symbol_from_command_line<size>(p->c_str());

  for (Script_options::referenced_const_iterator p =
	 layout->script_options()->referenced_begin();
       p != layout->script_options()->referenced_end();
       ++p)
    this->add_undefined_symbol_from_command_line<size>(p->c_str());
}

template<int size>
void
Symbol_table::add_undefined_symbol_from_command_line(const char* name)
{
  if (this->lookup(name) != NULL)
    return;

  const char* version = NULL;

  Sized_symbol<size>* sym;
  Sized_symbol<size>* oldsym;
  bool resolve_oldsym;
  if (parameters->target().is_big_endian())
    {
#if defined(HAVE_TARGET_32_BIG) || defined(HAVE_TARGET_64_BIG)
      sym = this->define_special_symbol<size, true>(&name, &version,
						    false, &oldsym,
						    &resolve_oldsym);
#else
      gold_unreachable();
#endif
    }
  else
    {
#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_64_LITTLE)
      sym = this->define_special_symbol<size, false>(&name, &version,
						     false, &oldsym,
						     &resolve_oldsym);
#else
      gold_unreachable();
#endif
    }

  gold_assert(oldsym == NULL);

  sym->init_undefined(name, version, elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
		      elfcpp::STV_DEFAULT, 0);
  ++this->saw_undefined_;
}

// Set the dynamic symbol indexes.  INDEX is the index of the first
// global dynamic symbol.  Pointers to the symbols are stored into the
// vector SYMS.  The names are added to DYNPOOL.  This returns an
// updated dynamic symbol index.

unsigned int
Symbol_table::set_dynsym_indexes(unsigned int index,
				 std::vector<Symbol*>* syms,
				 Stringpool* dynpool,
				 Versions* versions)
{
  std::vector<Symbol*> as_needed_sym;

  for (Symbol_table_type::iterator p = this->table_.begin();
       p != this->table_.end();
       ++p)
    {
      Symbol* sym = p->second;

      // Note that SYM may already have a dynamic symbol index, since
      // some symbols appear more than once in the symbol table, with
      // and without a version.

      if (!sym->should_add_dynsym_entry(this))
	sym->set_dynsym_index(-1U);
      else if (!sym->has_dynsym_index())
	{
	  sym->set_dynsym_index(index);
	  ++index;
	  syms->push_back(sym);
	  dynpool->add(sym->name(), false, NULL);

	  // If the symbol is defined in a dynamic object and is
	  // referenced strongly in a regular object, then mark the
	  // dynamic object as needed.  This is used to implement
	  // --as-needed.
	  if (sym->is_from_dynobj()
	      && sym->in_reg()
	      && !sym->is_undef_binding_weak())
	    sym->object()->set_is_needed();

	  // Record any version information, except those from
	  // as-needed libraries not seen to be needed.  Note that the
	  // is_needed state for such libraries can change in this loop.
	  if (sym->version() != NULL)
	    {
	      if (!sym->is_from_dynobj()
		  || !sym->object()->as_needed()
		  || sym->object()->is_needed())
		versions->record_version(this, dynpool, sym);
	      else
		as_needed_sym.push_back(sym);
	    }
	}
    }

  // Process version information for symbols from as-needed libraries.
  for (std::vector<Symbol*>::iterator p = as_needed_sym.begin();
       p != as_needed_sym.end();
       ++p)
    {
      Symbol* sym = *p;

      if (sym->object()->is_needed())
	versions->record_version(this, dynpool, sym);
      else
	sym->clear_version();
    }

  // Finish up the versions.  In some cases this may add new dynamic
  // symbols.
  index = versions->finalize(this, index, syms);

  return index;
}

// Set the final values for all the symbols.  The index of the first
// global symbol in the output file is *PLOCAL_SYMCOUNT.  Record the
// file offset OFF.  Add their names to POOL.  Return the new file
// offset.  Update *PLOCAL_SYMCOUNT if necessary.

off_t
Symbol_table::finalize(off_t off, off_t dynoff, size_t dyn_global_index,
		       size_t dyncount, Stringpool* pool,
		       unsigned int* plocal_symcount)
{
  off_t ret;

  gold_assert(*plocal_symcount != 0);
  this->first_global_index_ = *plocal_symcount;

  this->dynamic_offset_ = dynoff;
  this->first_dynamic_global_index_ = dyn_global_index;
  this->dynamic_count_ = dyncount;

  if (parameters->target().get_size() == 32)
    {
#if defined(HAVE_TARGET_32_BIG) || defined(HAVE_TARGET_32_LITTLE)
      ret = this->sized_finalize<32>(off, pool, plocal_symcount);
#else
      gold_unreachable();
#endif
    }
  else if (parameters->target().get_size() == 64)
    {
#if defined(HAVE_TARGET_64_BIG) || defined(HAVE_TARGET_64_LITTLE)
      ret = this->sized_finalize<64>(off, pool, plocal_symcount);
#else
      gold_unreachable();
#endif
    }
  else
    gold_unreachable();

  // Now that we have the final symbol table, we can reliably note
  // which symbols should get warnings.
  this->warnings_.note_warnings(this);

  return ret;
}

// SYM is going into the symbol table at *PINDEX.  Add the name to
// POOL, update *PINDEX and *POFF.

template<int size>
void
Symbol_table::add_to_final_symtab(Symbol* sym, Stringpool* pool,
				  unsigned int* pindex, off_t* poff)
{
  sym->set_symtab_index(*pindex);
  if (sym->version() == NULL || !parameters->options().relocatable())
    pool->add(sym->name(), false, NULL);
  else
    pool->add(sym->versioned_name(), true, NULL);
  ++*pindex;
  *poff += elfcpp::Elf_sizes<size>::sym_size;
}

// Set the final value for all the symbols.  This is called after
// Layout::finalize, so all the output sections have their final
// address.

template<int size>
off_t
Symbol_table::sized_finalize(off_t off, Stringpool* pool,
			     unsigned int* plocal_symcount)
{
  off = align_address(off, size >> 3);
  this->offset_ = off;

  unsigned int index = *plocal_symcount;
  const unsigned int orig_index = index;

  // First do all the symbols which have been forced to be local, as
  // they must appear before all global symbols.
  for (Forced_locals::iterator p = this->forced_locals_.begin();
       p != this->forced_locals_.end();
       ++p)
    {
      Symbol* sym = *p;
      gold_assert(sym->is_forced_local());
      if (this->sized_finalize_symbol<size>(sym))
	{
	  this->add_to_final_symtab<size>(sym, pool, &index, &off);
	  ++*plocal_symcount;
	}
    }

  // Now do all the remaining symbols.
  for (Symbol_table_type::iterator p = this->table_.begin();
       p != this->table_.end();
       ++p)
    {
      Symbol* sym = p->second;
      if (this->sized_finalize_symbol<size>(sym))
	this->add_to_final_symtab<size>(sym, pool, &index, &off);
    }

  this->output_count_ = index - orig_index;

  return off;
}

// Compute the final value of SYM and store status in location PSTATUS.
// During relaxation, this may be called multiple times for a symbol to
// compute its would-be final value in each relaxation pass.

template<int size>
typename Sized_symbol<size>::Value_type
Symbol_table::compute_final_value(
    const Sized_symbol<size>* sym,
    Compute_final_value_status* pstatus) const
{
  typedef typename Sized_symbol<size>::Value_type Value_type;
  Value_type value;

  switch (sym->source())
    {
    case Symbol::FROM_OBJECT:
      {
	bool is_ordinary;
	unsigned int shndx = sym->shndx(&is_ordinary);

	if (!is_ordinary
	    && shndx != elfcpp::SHN_ABS
	    && !Symbol::is_common_shndx(shndx))
	  {
	    *pstatus = CFVS_UNSUPPORTED_SYMBOL_SECTION;
	    return 0;
	  }

	Object* symobj = sym->object();
	if (symobj->is_dynamic())
	  {
	    value = 0;
	    shndx = elfcpp::SHN_UNDEF;
	  }
	else if (symobj->pluginobj() != NULL)
	  {
	    value = 0;
	    shndx = elfcpp::SHN_UNDEF;
	  }
	else if (shndx == elfcpp::SHN_UNDEF)
	  value = 0;
	else if (!is_ordinary
		 && (shndx == elfcpp::SHN_ABS
		     || Symbol::is_common_shndx(shndx)))
	  value = sym->value();
	else
	  {
	    Relobj* relobj = static_cast<Relobj*>(symobj);
	    Output_section* os = relobj->output_section(shndx);

            if (this->is_section_folded(relobj, shndx))
              {
                gold_assert(os == NULL);
                // Get the os of the section it is folded onto.
                Section_id folded = this->icf_->get_folded_section(relobj,
                                                                   shndx);
                gold_assert(folded.first != NULL);
                Relobj* folded_obj = reinterpret_cast<Relobj*>(folded.first);
		unsigned folded_shndx = folded.second;

                os = folded_obj->output_section(folded_shndx);  
                gold_assert(os != NULL);

		// Replace (relobj, shndx) with canonical ICF input section.
		shndx = folded_shndx;
		relobj = folded_obj;
              }

            uint64_t secoff64 = relobj->output_section_offset(shndx);
 	    if (os == NULL)
	      {
                bool static_or_reloc = (parameters->doing_static_link() ||
                                        parameters->options().relocatable());
                gold_assert(static_or_reloc || sym->dynsym_index() == -1U);

		*pstatus = CFVS_NO_OUTPUT_SECTION;
		return 0;
	      }

            if (secoff64 == -1ULL)
              {
                // The section needs special handling (e.g., a merge section).

	        value = os->output_address(relobj, shndx, sym->value());
	      }
            else
              {
                Value_type secoff =
                  convert_types<Value_type, uint64_t>(secoff64);
	        if (sym->type() == elfcpp::STT_TLS)
	          value = sym->value() + os->tls_offset() + secoff;
	        else
	          value = sym->value() + os->address() + secoff;
	      }
	  }
      }
      break;

    case Symbol::IN_OUTPUT_DATA:
      {
	Output_data* od = sym->output_data();
	value = sym->value();
	if (sym->type() != elfcpp::STT_TLS)
	  value += od->address();
	else
	  {
	    Output_section* os = od->output_section();
	    gold_assert(os != NULL);
	    value += os->tls_offset() + (od->address() - os->address());
	  }
	if (sym->offset_is_from_end())
	  value += od->data_size();
      }
      break;

    case Symbol::IN_OUTPUT_SEGMENT:
      {
	Output_segment* os = sym->output_segment();
	value = sym->value();
        if (sym->type() != elfcpp::STT_TLS)
	  value += os->vaddr();
	switch (sym->offset_base())
	  {
	  case Symbol::SEGMENT_START:
	    break;
	  case Symbol::SEGMENT_END:
	    value += os->memsz();
	    break;
	  case Symbol::SEGMENT_BSS:
	    value += os->filesz();
	    break;
	  default:
	    gold_unreachable();
	  }
      }
      break;

    case Symbol::IS_CONSTANT:
      value = sym->value();
      break;

    case Symbol::IS_UNDEFINED:
      value = 0;
      break;

    default:
      gold_unreachable();
    }

  *pstatus = CFVS_OK;
  return value;
}

// Finalize the symbol SYM.  This returns true if the symbol should be
// added to the symbol table, false otherwise.

template<int size>
bool
Symbol_table::sized_finalize_symbol(Symbol* unsized_sym)
{
  typedef typename Sized_symbol<size>::Value_type Value_type;

  Sized_symbol<size>* sym = static_cast<Sized_symbol<size>*>(unsized_sym);

  // The default version of a symbol may appear twice in the symbol
  // table.  We only need to finalize it once.
  if (sym->has_symtab_index())
    return false;

  if (!sym->in_reg())
    {
      gold_assert(!sym->has_symtab_index());
      sym->set_symtab_index(-1U);
      gold_assert(sym->dynsym_index() == -1U);
      return false;
    }

  // If the symbol is only present on plugin files, the plugin decided we
  // don't need it.
  if (!sym->in_real_elf())
    {
      gold_assert(!sym->has_symtab_index());
      sym->set_symtab_index(-1U);
      return false;
    }

  // Compute final symbol value.
  Compute_final_value_status status;
  Value_type value = this->compute_final_value(sym, &status);

  switch (status)
    {
    case CFVS_OK:
      break;
    case CFVS_UNSUPPORTED_SYMBOL_SECTION:
      {
	bool is_ordinary;
	unsigned int shndx = sym->shndx(&is_ordinary);
	gold_error(_("%s: unsupported symbol section 0x%x"),
		   sym->demangled_name().c_str(), shndx);
      }
      break;
    case CFVS_NO_OUTPUT_SECTION:
      sym->set_symtab_index(-1U);
      return false;
    default:
      gold_unreachable();
    }

  sym->set_value(value);

  if (parameters->options().strip_all()
      || !parameters->options().should_retain_symbol(sym->name()))
    {
      sym->set_symtab_index(-1U);
      return false;
    }

  return true;
}

// Write out the global symbols.

void
Symbol_table::write_globals(const Stringpool* sympool,
			    const Stringpool* dynpool,
			    Output_symtab_xindex* symtab_xindex,
			    Output_symtab_xindex* dynsym_xindex,
			    Output_file* of) const
{
  switch (parameters->size_and_endianness())
    {
#ifdef HAVE_TARGET_32_LITTLE
    case Parameters::TARGET_32_LITTLE:
      this->sized_write_globals<32, false>(sympool, dynpool, symtab_xindex,
					   dynsym_xindex, of);
      break;
#endif
#ifdef HAVE_TARGET_32_BIG
    case Parameters::TARGET_32_BIG:
      this->sized_write_globals<32, true>(sympool, dynpool, symtab_xindex,
					  dynsym_xindex, of);
      break;
#endif
#ifdef HAVE_TARGET_64_LITTLE
    case Parameters::TARGET_64_LITTLE:
      this->sized_write_globals<64, false>(sympool, dynpool, symtab_xindex,
					   dynsym_xindex, of);
      break;
#endif
#ifdef HAVE_TARGET_64_BIG
    case Parameters::TARGET_64_BIG:
      this->sized_write_globals<64, true>(sympool, dynpool, symtab_xindex,
					  dynsym_xindex, of);
      break;
#endif
    default:
      gold_unreachable();
    }
}

// Write out the global symbols.

template<int size, bool big_endian>
void
Symbol_table::sized_write_globals(const Stringpool* sympool,
				  const Stringpool* dynpool,
				  Output_symtab_xindex* symtab_xindex,
				  Output_symtab_xindex* dynsym_xindex,
				  Output_file* of) const
{
  const Target& target = parameters->target();

  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;

  const unsigned int output_count = this->output_count_;
  const section_size_type oview_size = output_count * sym_size;
  const unsigned int first_global_index = this->first_global_index_;
  unsigned char* psyms;
  if (this->offset_ == 0 || output_count == 0)
    psyms = NULL;
  else
    psyms = of->get_output_view(this->offset_, oview_size);

  const unsigned int dynamic_count = this->dynamic_count_;
  const section_size_type dynamic_size = dynamic_count * sym_size;
  const unsigned int first_dynamic_global_index =
    this->first_dynamic_global_index_;
  unsigned char* dynamic_view;
  if (this->dynamic_offset_ == 0 || dynamic_count == 0)
    dynamic_view = NULL;
  else
    dynamic_view = of->get_output_view(this->dynamic_offset_, dynamic_size);

  for (Symbol_table_type::const_iterator p = this->table_.begin();
       p != this->table_.end();
       ++p)
    {
      Sized_symbol<size>* sym = static_cast<Sized_symbol<size>*>(p->second);

      // Possibly warn about unresolved symbols in shared libraries.
      this->warn_about_undefined_dynobj_symbol(sym);

      unsigned int sym_index = sym->symtab_index();
      unsigned int dynsym_index;
      if (dynamic_view == NULL)
	dynsym_index = -1U;
      else
	dynsym_index = sym->dynsym_index();

      if (sym_index == -1U && dynsym_index == -1U)
	{
	  // This symbol is not included in the output file.
	  continue;
	}

      unsigned int shndx;
      typename elfcpp::Elf_types<size>::Elf_Addr sym_value = sym->value();
      typename elfcpp::Elf_types<size>::Elf_Addr dynsym_value = sym_value;
      elfcpp::STB binding = sym->binding();

      // If --no-gnu-unique is set, change STB_GNU_UNIQUE to STB_GLOBAL.
      if (binding == elfcpp::STB_GNU_UNIQUE
	  && !parameters->options().gnu_unique())
	binding = elfcpp::STB_GLOBAL;

      switch (sym->source())
	{
	case Symbol::FROM_OBJECT:
	  {
	    bool is_ordinary;
	    unsigned int in_shndx = sym->shndx(&is_ordinary);

	    if (!is_ordinary
		&& in_shndx != elfcpp::SHN_ABS
		&& !Symbol::is_common_shndx(in_shndx))
	      {
		gold_error(_("%s: unsupported symbol section 0x%x"),
			   sym->demangled_name().c_str(), in_shndx);
		shndx = in_shndx;
	      }
	    else
	      {
		Object* symobj = sym->object();
		if (symobj->is_dynamic())
		  {
		    if (sym->needs_dynsym_value())
		      dynsym_value = target.dynsym_value(sym);
		    shndx = elfcpp::SHN_UNDEF;
		    if (sym->is_undef_binding_weak())
		      binding = elfcpp::STB_WEAK;
		    else
		      binding = elfcpp::STB_GLOBAL;
		  }
		else if (symobj->pluginobj() != NULL)
		  shndx = elfcpp::SHN_UNDEF;
		else if (in_shndx == elfcpp::SHN_UNDEF
			 || (!is_ordinary
			     && (in_shndx == elfcpp::SHN_ABS
				 || Symbol::is_common_shndx(in_shndx))))
		  shndx = in_shndx;
		else
		  {
		    Relobj* relobj = static_cast<Relobj*>(symobj);
		    Output_section* os = relobj->output_section(in_shndx);
                    if (this->is_section_folded(relobj, in_shndx))
                      {
                        // This global symbol must be written out even though
                        // it is folded.
                        // Get the os of the section it is folded onto.
                        Section_id folded =
                             this->icf_->get_folded_section(relobj, in_shndx);
                        gold_assert(folded.first !=NULL);
                        Relobj* folded_obj = 
                          reinterpret_cast<Relobj*>(folded.first);
                        os = folded_obj->output_section(folded.second);  
                        gold_assert(os != NULL);
                      }
		    gold_assert(os != NULL);
		    shndx = os->out_shndx();

		    if (shndx >= elfcpp::SHN_LORESERVE)
		      {
			if (sym_index != -1U)
			  symtab_xindex->add(sym_index, shndx);
			if (dynsym_index != -1U)
			  dynsym_xindex->add(dynsym_index, shndx);
			shndx = elfcpp::SHN_XINDEX;
		      }

		    // In object files symbol values are section
		    // relative.
		    if (parameters->options().relocatable())
		      sym_value -= os->address();
		  }
	      }
	  }
	  break;

	case Symbol::IN_OUTPUT_DATA:
	  {
	    Output_data* od = sym->output_data();

	    shndx = od->out_shndx();
	    if (shndx >= elfcpp::SHN_LORESERVE)
	      {
		if (sym_index != -1U)
		  symtab_xindex->add(sym_index, shndx);
		if (dynsym_index != -1U)
		  dynsym_xindex->add(dynsym_index, shndx);
		shndx = elfcpp::SHN_XINDEX;
	      }

	    // In object files symbol values are section
	    // relative.
	    if (parameters->options().relocatable())
	      sym_value -= od->address();
	  }
	  break;

	case Symbol::IN_OUTPUT_SEGMENT:
	  shndx = elfcpp::SHN_ABS;
	  break;

	case Symbol::IS_CONSTANT:
	  shndx = elfcpp::SHN_ABS;
	  break;

	case Symbol::IS_UNDEFINED:
	  shndx = elfcpp::SHN_UNDEF;
	  break;

	default:
	  gold_unreachable();
	}

      if (sym_index != -1U)
	{
	  sym_index -= first_global_index;
	  gold_assert(sym_index < output_count);
	  unsigned char* ps = psyms + (sym_index * sym_size);
	  this->sized_write_symbol<size, big_endian>(sym, sym_value, shndx,
						     binding, sympool, ps);
	}

      if (dynsym_index != -1U)
	{
	  dynsym_index -= first_dynamic_global_index;
	  gold_assert(dynsym_index < dynamic_count);
	  unsigned char* pd = dynamic_view + (dynsym_index * sym_size);
	  this->sized_write_symbol<size, big_endian>(sym, dynsym_value, shndx,
						     binding, dynpool, pd);
	}
    }

  of->write_output_view(this->offset_, oview_size, psyms);
  if (dynamic_view != NULL)
    of->write_output_view(this->dynamic_offset_, dynamic_size, dynamic_view);
}

// Write out the symbol SYM, in section SHNDX, to P.  POOL is the
// strtab holding the name.

template<int size, bool big_endian>
void
Symbol_table::sized_write_symbol(
    Sized_symbol<size>* sym,
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    unsigned int shndx,
    elfcpp::STB binding,
    const Stringpool* pool,
    unsigned char* p) const
{
  elfcpp::Sym_write<size, big_endian> osym(p);
  if (sym->version() == NULL || !parameters->options().relocatable())
    osym.put_st_name(pool->get_offset(sym->name()));
  else
    osym.put_st_name(pool->get_offset(sym->versioned_name()));
  osym.put_st_value(value);
  // Use a symbol size of zero for undefined symbols from shared libraries.
  if (shndx == elfcpp::SHN_UNDEF && sym->is_from_dynobj())
    osym.put_st_size(0);
  else
    osym.put_st_size(sym->symsize());
  elfcpp::STT type = sym->type();
  // Turn IFUNC symbols from shared libraries into normal FUNC symbols.
  if (type == elfcpp::STT_GNU_IFUNC
      && sym->is_from_dynobj())
    type = elfcpp::STT_FUNC;
  // A version script may have overridden the default binding.
  if (sym->is_forced_local())
    osym.put_st_info(elfcpp::elf_st_info(elfcpp::STB_LOCAL, type));
  else
    osym.put_st_info(elfcpp::elf_st_info(binding, type));
  osym.put_st_other(elfcpp::elf_st_other(sym->visibility(), sym->nonvis()));
  osym.put_st_shndx(shndx);
}

// Check for unresolved symbols in shared libraries.  This is
// controlled by the --allow-shlib-undefined option.

// We only warn about libraries for which we have seen all the
// DT_NEEDED entries.  We don't try to track down DT_NEEDED entries
// which were not seen in this link.  If we didn't see a DT_NEEDED
// entry, we aren't going to be able to reliably report whether the
// symbol is undefined.

// We also don't warn about libraries found in a system library
// directory (e.g., /lib or /usr/lib); we assume that those libraries
// are OK.  This heuristic avoids problems on GNU/Linux, in which -ldl
// can have undefined references satisfied by ld-linux.so.

inline void
Symbol_table::warn_about_undefined_dynobj_symbol(Symbol* sym) const
{
  bool dummy;
  if (sym->source() == Symbol::FROM_OBJECT
      && sym->object()->is_dynamic()
      && sym->shndx(&dummy) == elfcpp::SHN_UNDEF
      && sym->binding() != elfcpp::STB_WEAK
      && !parameters->options().allow_shlib_undefined()
      && !parameters->target().is_defined_by_abi(sym)
      && !sym->object()->is_in_system_directory())
    {
      // A very ugly cast.
      Dynobj* dynobj = static_cast<Dynobj*>(sym->object());
      if (!dynobj->has_unknown_needed_entries())
        gold_undefined_symbol(sym);
    }
}

// Write out a section symbol.  Return the update offset.

void
Symbol_table::write_section_symbol(const Output_section* os,
				   Output_symtab_xindex* symtab_xindex,
				   Output_file* of,
				   off_t offset) const
{
  switch (parameters->size_and_endianness())
    {
#ifdef HAVE_TARGET_32_LITTLE
    case Parameters::TARGET_32_LITTLE:
      this->sized_write_section_symbol<32, false>(os, symtab_xindex, of,
						  offset);
      break;
#endif
#ifdef HAVE_TARGET_32_BIG
    case Parameters::TARGET_32_BIG:
      this->sized_write_section_symbol<32, true>(os, symtab_xindex, of,
						 offset);
      break;
#endif
#ifdef HAVE_TARGET_64_LITTLE
    case Parameters::TARGET_64_LITTLE:
      this->sized_write_section_symbol<64, false>(os, symtab_xindex, of,
						  offset);
      break;
#endif
#ifdef HAVE_TARGET_64_BIG
    case Parameters::TARGET_64_BIG:
      this->sized_write_section_symbol<64, true>(os, symtab_xindex, of,
						 offset);
      break;
#endif
    default:
      gold_unreachable();
    }
}

// Write out a section symbol, specialized for size and endianness.

template<int size, bool big_endian>
void
Symbol_table::sized_write_section_symbol(const Output_section* os,
					 Output_symtab_xindex* symtab_xindex,
					 Output_file* of,
					 off_t offset) const
{
  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;

  unsigned char* pov = of->get_output_view(offset, sym_size);

  elfcpp::Sym_write<size, big_endian> osym(pov);
  osym.put_st_name(0);
  if (parameters->options().relocatable())
    osym.put_st_value(0);
  else
    osym.put_st_value(os->address());
  osym.put_st_size(0);
  osym.put_st_info(elfcpp::elf_st_info(elfcpp::STB_LOCAL,
				       elfcpp::STT_SECTION));
  osym.put_st_other(elfcpp::elf_st_other(elfcpp::STV_DEFAULT, 0));

  unsigned int shndx = os->out_shndx();
  if (shndx >= elfcpp::SHN_LORESERVE)
    {
      symtab_xindex->add(os->symtab_index(), shndx);
      shndx = elfcpp::SHN_XINDEX;
    }
  osym.put_st_shndx(shndx);

  of->write_output_view(offset, sym_size, pov);
}

// Print statistical information to stderr.  This is used for --stats.

void
Symbol_table::print_stats() const
{
#if defined(HAVE_TR1_UNORDERED_MAP) || defined(HAVE_EXT_HASH_MAP)
  fprintf(stderr, _("%s: symbol table entries: %zu; buckets: %zu\n"),
	  program_name, this->table_.size(), this->table_.bucket_count());
#else
  fprintf(stderr, _("%s: symbol table entries: %zu\n"),
	  program_name, this->table_.size());
#endif
  this->namepool_.print_stats("symbol table stringpool");
}

// We check for ODR violations by looking for symbols with the same
// name for which the debugging information reports that they were
// defined in disjoint source locations.  When comparing the source
// location, we consider instances with the same base filename to be
// the same.  This is because different object files/shared libraries
// can include the same header file using different paths, and
// different optimization settings can make the line number appear to
// be a couple lines off, and we don't want to report an ODR violation
// in those cases.

// This struct is used to compare line information, as returned by
// Dwarf_line_info::one_addr2line.  It implements a < comparison
// operator used with std::sort.

struct Odr_violation_compare
{
  bool
  operator()(const std::string& s1, const std::string& s2) const
  {
    // Inputs should be of the form "dirname/filename:linenum" where
    // "dirname/" is optional.  We want to compare just the filename:linenum.

    // Find the last '/' in each string.
    std::string::size_type s1begin = s1.rfind('/');
    std::string::size_type s2begin = s2.rfind('/');
    // If there was no '/' in a string, start at the beginning.
    if (s1begin == std::string::npos)
      s1begin = 0;
    if (s2begin == std::string::npos)
      s2begin = 0;
    return s1.compare(s1begin, std::string::npos,
		      s2, s2begin, std::string::npos) < 0;
  }
};

// Returns all of the lines attached to LOC, not just the one the
// instruction actually came from.
std::vector<std::string>
Symbol_table::linenos_from_loc(const Task* task,
                               const Symbol_location& loc)
{
  // We need to lock the object in order to read it.  This
  // means that we have to run in a singleton Task.  If we
  // want to run this in a general Task for better
  // performance, we will need one Task for object, plus
  // appropriate locking to ensure that we don't conflict with
  // other uses of the object.  Also note, one_addr2line is not
  // currently thread-safe.
  Task_lock_obj<Object> tl(task, loc.object);

  std::vector<std::string> result;
  Symbol_location code_loc = loc;
  parameters->target().function_location(&code_loc);
  // 16 is the size of the object-cache that one_addr2line should use.
  std::string canonical_result = Dwarf_line_info::one_addr2line(
      code_loc.object, code_loc.shndx, code_loc.offset, 16, &result);
  if (!canonical_result.empty())
    result.push_back(canonical_result);
  return result;
}

// OutputIterator that records if it was ever assigned to.  This
// allows it to be used with std::set_intersection() to check for
// intersection rather than computing the intersection.
struct Check_intersection
{
  Check_intersection()
    : value_(false)
  {}

  bool had_intersection() const
  { return this->value_; }

  Check_intersection& operator++()
  { return *this; }

  Check_intersection& operator*()
  { return *this; }

  template<typename T>
  Check_intersection& operator=(const T&)
  {
    this->value_ = true;
    return *this;
  }

 private:
  bool value_;
};

// Check candidate_odr_violations_ to find symbols with the same name
// but apparently different definitions (different source-file/line-no
// for each line assigned to the first instruction).

void
Symbol_table::detect_odr_violations(const Task* task,
				    const char* output_file_name) const
{
  for (Odr_map::const_iterator it = candidate_odr_violations_.begin();
       it != candidate_odr_violations_.end();
       ++it)
    {
      const char* const symbol_name = it->first;

      std::string first_object_name;
      std::vector<std::string> first_object_linenos;

      Unordered_set<Symbol_location, Symbol_location_hash>::const_iterator
          locs = it->second.begin();
      const Unordered_set<Symbol_location, Symbol_location_hash>::const_iterator
          locs_end = it->second.end();
      for (; locs != locs_end && first_object_linenos.empty(); ++locs)
        {
          // Save the line numbers from the first definition to
          // compare to the other definitions.  Ideally, we'd compare
          // every definition to every other, but we don't want to
          // take O(N^2) time to do this.  This shortcut may cause
          // false negatives that appear or disappear depending on the
          // link order, but it won't cause false positives.
          first_object_name = locs->object->name();
          first_object_linenos = this->linenos_from_loc(task, *locs);
        }

      // Sort by Odr_violation_compare to make std::set_intersection work.
      std::sort(first_object_linenos.begin(), first_object_linenos.end(),
                Odr_violation_compare());

      for (; locs != locs_end; ++locs)
        {
          std::vector<std::string> linenos =
              this->linenos_from_loc(task, *locs);
          // linenos will be empty if we couldn't parse the debug info.
          if (linenos.empty())
            continue;
          // Sort by Odr_violation_compare to make std::set_intersection work.
          std::sort(linenos.begin(), linenos.end(), Odr_violation_compare());

          Check_intersection intersection_result =
              std::set_intersection(first_object_linenos.begin(),
                                    first_object_linenos.end(),
                                    linenos.begin(),
                                    linenos.end(),
                                    Check_intersection(),
                                    Odr_violation_compare());
          if (!intersection_result.had_intersection())
            {
              gold_warning(_("while linking %s: symbol '%s' defined in "
                             "multiple places (possible ODR violation):"),
                           output_file_name, demangle(symbol_name).c_str());
              // This only prints one location from each definition,
              // which may not be the location we expect to intersect
              // with another definition.  We could print the whole
              // set of locations, but that seems too verbose.
              gold_assert(!first_object_linenos.empty());
              gold_assert(!linenos.empty());
              fprintf(stderr, _("  %s from %s\n"),
                      first_object_linenos[0].c_str(),
                      first_object_name.c_str());
              fprintf(stderr, _("  %s from %s\n"),
                      linenos[0].c_str(),
                      locs->object->name().c_str());
              // Only print one broken pair, to avoid needing to
              // compare against a list of the disjoint definition
              // locations we've found so far.  (If we kept comparing
              // against just the first one, we'd get a lot of
              // redundant complaints about the second definition
              // location.)
              break;
            }
        }
    }
  // We only call one_addr2line() in this function, so we can clear its cache.
  Dwarf_line_info::clear_addr2line_cache();
}

// Warnings functions.

// Add a new warning.

void
Warnings::add_warning(Symbol_table* symtab, const char* name, Object* obj,
		      const std::string& warning)
{
  name = symtab->canonicalize_name(name);
  this->warnings_[name].set(obj, warning);
}

// Look through the warnings and mark the symbols for which we should
// warn.  This is called during Layout::finalize when we know the
// sources for all the symbols.

void
Warnings::note_warnings(Symbol_table* symtab)
{
  for (Warning_table::iterator p = this->warnings_.begin();
       p != this->warnings_.end();
       ++p)
    {
      Symbol* sym = symtab->lookup(p->first, NULL);
      if (sym != NULL
	  && sym->source() == Symbol::FROM_OBJECT
	  && sym->object() == p->second.object)
	sym->set_has_warning();
    }
}

// Issue a warning.  This is called when we see a relocation against a
// symbol for which has a warning.

template<int size, bool big_endian>
void
Warnings::issue_warning(const Symbol* sym,
			const Relocate_info<size, big_endian>* relinfo,
			size_t relnum, off_t reloffset) const
{
  gold_assert(sym->has_warning());

  // We don't want to issue a warning for a relocation against the
  // symbol in the same object file in which the symbol is defined.
  if (sym->object() == relinfo->object)
    return;

  Warning_table::const_iterator p = this->warnings_.find(sym->name());
  gold_assert(p != this->warnings_.end());
  gold_warning_at_location(relinfo, relnum, reloffset,
			   "%s", p->second.text.c_str());
}

// Instantiate the templates we need.  We could use the configure
// script to restrict this to only the ones needed for implemented
// targets.

#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
template
void
Sized_symbol<32>::allocate_common(Output_data*, Value_type);
#endif

#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
template
void
Sized_symbol<64>::allocate_common(Output_data*, Value_type);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Symbol_table::add_from_relobj<32, false>(
    Sized_relobj_file<32, false>* relobj,
    const unsigned char* syms,
    size_t count,
    size_t symndx_offset,
    const char* sym_names,
    size_t sym_name_size,
    Sized_relobj_file<32, false>::Symbols* sympointers,
    size_t* defined);
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Symbol_table::add_from_relobj<32, true>(
    Sized_relobj_file<32, true>* relobj,
    const unsigned char* syms,
    size_t count,
    size_t symndx_offset,
    const char* sym_names,
    size_t sym_name_size,
    Sized_relobj_file<32, true>::Symbols* sympointers,
    size_t* defined);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Symbol_table::add_from_relobj<64, false>(
    Sized_relobj_file<64, false>* relobj,
    const unsigned char* syms,
    size_t count,
    size_t symndx_offset,
    const char* sym_names,
    size_t sym_name_size,
    Sized_relobj_file<64, false>::Symbols* sympointers,
    size_t* defined);
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Symbol_table::add_from_relobj<64, true>(
    Sized_relobj_file<64, true>* relobj,
    const unsigned char* syms,
    size_t count,
    size_t symndx_offset,
    const char* sym_names,
    size_t sym_name_size,
    Sized_relobj_file<64, true>::Symbols* sympointers,
    size_t* defined);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
Symbol*
Symbol_table::add_from_pluginobj<32, false>(
    Sized_pluginobj<32, false>* obj,
    const char* name,
    const char* ver,
    elfcpp::Sym<32, false>* sym);
#endif

#ifdef HAVE_TARGET_32_BIG
template
Symbol*
Symbol_table::add_from_pluginobj<32, true>(
    Sized_pluginobj<32, true>* obj,
    const char* name,
    const char* ver,
    elfcpp::Sym<32, true>* sym);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
Symbol*
Symbol_table::add_from_pluginobj<64, false>(
    Sized_pluginobj<64, false>* obj,
    const char* name,
    const char* ver,
    elfcpp::Sym<64, false>* sym);
#endif

#ifdef HAVE_TARGET_64_BIG
template
Symbol*
Symbol_table::add_from_pluginobj<64, true>(
    Sized_pluginobj<64, true>* obj,
    const char* name,
    const char* ver,
    elfcpp::Sym<64, true>* sym);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Symbol_table::add_from_dynobj<32, false>(
    Sized_dynobj<32, false>* dynobj,
    const unsigned char* syms,
    size_t count,
    const char* sym_names,
    size_t sym_name_size,
    const unsigned char* versym,
    size_t versym_size,
    const std::vector<const char*>* version_map,
    Sized_relobj_file<32, false>::Symbols* sympointers,
    size_t* defined);
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Symbol_table::add_from_dynobj<32, true>(
    Sized_dynobj<32, true>* dynobj,
    const unsigned char* syms,
    size_t count,
    const char* sym_names,
    size_t sym_name_size,
    const unsigned char* versym,
    size_t versym_size,
    const std::vector<const char*>* version_map,
    Sized_relobj_file<32, true>::Symbols* sympointers,
    size_t* defined);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Symbol_table::add_from_dynobj<64, false>(
    Sized_dynobj<64, false>* dynobj,
    const unsigned char* syms,
    size_t count,
    const char* sym_names,
    size_t sym_name_size,
    const unsigned char* versym,
    size_t versym_size,
    const std::vector<const char*>* version_map,
    Sized_relobj_file<64, false>::Symbols* sympointers,
    size_t* defined);
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Symbol_table::add_from_dynobj<64, true>(
    Sized_dynobj<64, true>* dynobj,
    const unsigned char* syms,
    size_t count,
    const char* sym_names,
    size_t sym_name_size,
    const unsigned char* versym,
    size_t versym_size,
    const std::vector<const char*>* version_map,
    Sized_relobj_file<64, true>::Symbols* sympointers,
    size_t* defined);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
Sized_symbol<32>*
Symbol_table::add_from_incrobj(
    Object* obj,
    const char* name,
    const char* ver,
    elfcpp::Sym<32, false>* sym);
#endif

#ifdef HAVE_TARGET_32_BIG
template
Sized_symbol<32>*
Symbol_table::add_from_incrobj(
    Object* obj,
    const char* name,
    const char* ver,
    elfcpp::Sym<32, true>* sym);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
Sized_symbol<64>*
Symbol_table::add_from_incrobj(
    Object* obj,
    const char* name,
    const char* ver,
    elfcpp::Sym<64, false>* sym);
#endif

#ifdef HAVE_TARGET_64_BIG
template
Sized_symbol<64>*
Symbol_table::add_from_incrobj(
    Object* obj,
    const char* name,
    const char* ver,
    elfcpp::Sym<64, true>* sym);
#endif

#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
template
void
Symbol_table::define_with_copy_reloc<32>(
    Sized_symbol<32>* sym,
    Output_data* posd,
    elfcpp::Elf_types<32>::Elf_Addr value);
#endif

#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
template
void
Symbol_table::define_with_copy_reloc<64>(
    Sized_symbol<64>* sym,
    Output_data* posd,
    elfcpp::Elf_types<64>::Elf_Addr value);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Warnings::issue_warning<32, false>(const Symbol* sym,
				   const Relocate_info<32, false>* relinfo,
				   size_t relnum, off_t reloffset) const;
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Warnings::issue_warning<32, true>(const Symbol* sym,
				  const Relocate_info<32, true>* relinfo,
				  size_t relnum, off_t reloffset) const;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Warnings::issue_warning<64, false>(const Symbol* sym,
				   const Relocate_info<64, false>* relinfo,
				   size_t relnum, off_t reloffset) const;
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Warnings::issue_warning<64, true>(const Symbol* sym,
				  const Relocate_info<64, true>* relinfo,
				  size_t relnum, off_t reloffset) const;
#endif

} // End namespace gold.
@


1.170
log
@	* symtab.h (Symbol::clear_version): New function.
	* symtab.cc (Symbol_table::set_dynsym_indexes): Don't set object
	is_needed by weak references.  Clear version for symbols defined
	in as-needed objects that are not needed.
@
text
@d2943 18
a2960 9
	  shndx = sym->output_data()->out_shndx();
	  if (shndx >= elfcpp::SHN_LORESERVE)
	    {
	      if (sym_index != -1U)
		symtab_xindex->add(sym_index, shndx);
	      if (dynsym_index != -1U)
		dynsym_xindex->add(dynsym_index, shndx);
	      shndx = elfcpp::SHN_XINDEX;
	    }
@


1.169
log
@	* gold.cc (queue_middle_tasks): Move detect_odr_violations..
	* layout.cc (Layout_task_runner::run): ..to here.
	* symtab.h (struct Symbol_location): Extract from..
	(class Symbol_table): ..here.
	* symtab.cc (Symbol_table::linenos_from_loc): Invoke function_location.
	* target.h (class Target): Add function_location and
	do_function_location functions.
	(class Sized_target): Add do_function_location.
	* object.h (class Sized_relobj_file): Move find_shdr..
	(class Object): ..to here.
	* object.cc: Likewise.  Update to suit.  Instantiate.
	(Sized_relobj_file::find_eh_frame): Update find_shdr call.
	* powerpc.cc (class Powerpc_dynobj): New.
	(Target_powerpc::do_function_location): New function.
	(Powerpc_relobj::do_find_special_sections): Update find_shdr call.
	(Powerpc_dynobj::do_read_symbols): New function.
	(Target_powerpc::do_make_elf_object): Make a Powerpc_dynobj.
@
text
@d2371 2
a2391 4
	  // Record any version information.
          if (sym->version() != NULL)
            versions->record_version(this, dynpool, sym);

d2393 6
a2398 3
	  // referenced in a regular object, then mark the dynamic
	  // object as needed.  This is used to implement --as-needed.
	  if (sym->is_from_dynobj() && sym->in_reg())
d2400 13
d2416 13
@


1.168
log
@	* target.h (Target::gc_mark_symbol, do_gc_mark_symbol): New functions.
	(Sized_target::gc_add_reference, do_gc_add_reference): New functions.
	* gc.h (gc_process_relocs): Call target gc_add_reference.
	* gold.cc (queue_middle_tasks): Use gc_mark_symbol on start sym.
	* symtab.cc (Symbol_table::gc_mark_undef_symbols): Use gc_mark_symbol.
	(Symbol_table::gc_mark_symbol): Call target gc_mark_symbol. Remove
	unnecessary cast.
	* powerpc.cc (Powerpc_relobj::get_opd_ent): Rearrange parameters
	to cater for when we don't need code offset.  Update use.
	(Powerpc_relobj::access_from_map_, opd_valid_): New vars.
	(Powerpc_relobj::access_from_map, add_reference, opd_valid,
	set_opd_valid): New functions.
	(Target_powerpc::do_gc_add_reference): New function.
	(Target_powerpc::gc_process_relocs): Call gc()->add_reference on
	stashed refs.
	(Target_powerpc::do_gc_mark_symbol): New function.
@
text
@d3178 2
d3182 1
a3182 1
      loc.object, loc.shndx, loc.offset, 16, &result);
@


1.167
log
@2012-08-21  Cary Coutant  <ccoutant@@google.com>

gold/
	* symtab.cc (Symbol_table::gc_mark_undef_symbols): Don't assert
	if --export-dynamic-symbol names an undef symbol.
@
text
@d580 1
a580 8
          Relobj* obj = static_cast<Relobj*>(sym->object());
          bool is_ordinary;
          unsigned int shndx = sym->shndx(&is_ordinary);
          if (is_ordinary)
            {
              gold_assert(this->gc_ != NULL);
              this->gc_->worklist().push(Section_id(obj, shndx));
            }
d597 1
a597 8
          Relobj* obj = static_cast<Relobj*>(sym->object());
          bool is_ordinary;
          unsigned int shndx = sym->shndx(&is_ordinary);
          if (is_ordinary)
            {
              gold_assert(this->gc_ != NULL);
              this->gc_->worklist().push(Section_id(obj, shndx));
            }
d611 1
a611 8
	  Relobj* obj = static_cast<Relobj*>(sym->object());
	  bool is_ordinary;
	  unsigned int shndx = sym->shndx(&is_ordinary);
	  if (is_ordinary)
	    {
	      gold_assert(this->gc_ != NULL);
	      this->gc_->worklist().push(Section_id(obj, shndx));
	    }
a619 1
  Relobj* obj = static_cast<Relobj*>(sym->object());
d625 1
a625 1
      this->gc_->worklist().push(Section_id(obj, shndx));
d627 1
@


1.166
log
@2012-05-25  Sriraman Tallam  <tmsriram@@google.com>

	* symtab.cc (Symbol_table::define_special_symbol):
	Initialize *poldsym to prevent uninitialized variable errors.
@
text
@d598 4
a601 2
      gold_assert(sym != NULL);
      if (sym->source() == Symbol::FROM_OBJECT 
@


1.165
log
@gold/

	* symtab.cc (Symbol::should_add_dynsym_entry): Check for relocatable
	object before exporting symbol.
@
text
@d1685 1
@


1.164
log
@	* archive.cc (Library_base::should_include_member): Check for
	--export-dynamic-symbol.
	* options.h (class General_options): Add --export-dynamic-symbol.
	* symtab.cc (Symbol::should_add_dynsym_entry): Check for
	--export-dynamic-symbol.
	(Symbol_table::gc_mark_undef_symbols): Likewise.
	(Symbol_table::do_add_undefined_symbols_from_command_line): Likewise.
@
text
@d368 3
a370 2
  if (parameters->options().in_dynamic_list(this->name())
      || parameters->options().is_export_dynamic_symbol(this->name()))
@


1.163
log
@	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.
@
text
@d366 12
a381 4
  // If the symbol was forced dynamic in a --dynamic-list file, add it.
  if (parameters->options().in_dynamic_list(this->name()))
    return true;

d562 2
a563 2
// For symbols that have been listed with -u option, add them to the
// work list to avoid gc'ing them.
d590 22
d2324 6
@


1.162
log
@2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.
@
text
@d2817 6
@


1.161
log
@	* gold/incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* gold/symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.
@
text
@d605 1
a605 1
Symbol_table::gc_mark_symbol_for_shlib(Symbol* sym)
d607 5
a611 2
  if (!sym->is_from_dynobj() 
      && sym->is_externally_visible())
d613 2
a614 9
      //Add the object and section to the work list.
      Relobj* obj = static_cast<Relobj*>(sym->object());
      bool is_ordinary;
      unsigned int shndx = sym->shndx(&is_ordinary);
      if (is_ordinary && shndx != elfcpp::SHN_UNDEF)
        {
          gold_assert(this->gc_!= NULL);
          this->gc_->worklist().push(Section_id(obj, shndx));
        }
d625 1
a625 10
    {
      Relobj* obj = static_cast<Relobj*>(sym->object()); 
      bool is_ordinary;
      unsigned int shndx = sym->shndx(&is_ordinary);
      if (is_ordinary && shndx != elfcpp::SHN_UNDEF)
        {
          gold_assert(this->gc_ != NULL);
          this->gc_->worklist().push(Section_id(obj, shndx));
        }
    }
d1241 10
a1250 5
      // If building a shared library using garbage collection, do not 
      // treat externally visible symbols as garbage.
      if (parameters->options().gc_sections() 
          && parameters->options().shared())
        this->gc_mark_symbol_for_shlib(res);
@


1.160
log
@	* symtab.cc (Symbol_table::define_special_symbol): Always
	canonicalize version string.
@
text
@d1146 8
d1357 5
@


1.159
log
@	* layout.cc (Layout::set_segment_offsets): Don't realign text
	segment if -Ttext was specified.
	* object.cc (Sized_relobj_file::Sized_relobj_file): Store the ELF
	file type.
	* object.h (Sized_relobj_file::e_type): New function.
	(Sized_relobj_file::e_type_): New data member.
	* symtab.cc (Symbol_table::add_from_relobj): Don't add section
	base address for ET_EXEC files.
	* target.cc (Target::do_make_elf_object_implementation): Allow
	ET_EXEC files with --just-symbols option.
@
text
@d1686 3
a1688 1
      if (!is_default_version)
@


1.159.2.1
log
@	* symtab.cc (Symbol_table::define_special_symbol): Always
	canonicalize version string.
@
text
@d1686 1
a1686 3
      if (is_default_version)
	*pversion = this->namepool_.add(*pversion, true, NULL);
      else
@


1.159.2.2
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d605 1
a605 1
Symbol_table::gc_mark_symbol(Symbol* sym)
d607 2
a608 5
  // Add the object and section to the work list.
  Relobj* obj = static_cast<Relobj*>(sym->object());
  bool is_ordinary;
  unsigned int shndx = sym->shndx(&is_ordinary);
  if (is_ordinary && shndx != elfcpp::SHN_UNDEF)
d610 9
a618 2
      gold_assert(this->gc_!= NULL);
      this->gc_->worklist().push(Section_id(obj, shndx));
d629 10
a638 1
    this->gc_mark_symbol(sym);
a1145 8
      // FIXME: For incremental links, we don't store version information,
      // so we need to ignore version symbols for now.
      if (parameters->incremental_update() && ver != NULL)
	{
	  namelen = ver - name;
	  ver = NULL;
	}

d1246 5
a1250 10
      // Do not treat this symbol as garbage if this symbol will be
      // exported to the dynamic symbol table.  This is true when
      // building a shared library or using --export-dynamic and
      // the symbol is externally visible.
      if (parameters->options().gc_sections()
	  && res->is_externally_visible()
	  && !res->is_from_dynobj()
          && (parameters->options().shared()
	      || parameters->options().export_dynamic()))
        this->gc_mark_symbol(res);
a1348 5
  // FIXME: For incremental links, we don't store version information,
  // so we need to ignore version symbols for now.
  if (parameters->incremental_update())
    versym = NULL;

a2811 6

      // If --no-gnu-unique is set, change STB_GNU_UNIQUE to STB_GLOBAL.
      if (binding == elfcpp::STB_GNU_UNIQUE
	  && !parameters->options().gnu_unique())
	binding = elfcpp::STB_GLOBAL;

@


1.158
log
@2011-07-22  Sriraman Tallam  <tmsriram@@google.com>

	* symtab.cc (Symbol_table::add_from_relobj): Mark symbol as referenced
	only after checking if it cannot be forced local.
	* symtab.h (is_externally_visible): Check if the symbol is not forced
	local.
@
text
@d1195 3
a1197 1
	  if (orig_st_shndx != elfcpp::SHN_UNDEF && is_ordinary)
d1199 4
a1202 4
	      // Symbol values in object files are section relative.
	      // This is normally what we want, but since here we are
	      // converting the symbol to absolute we need to add the
	      // section address.  The section address in an object
@


1.157
log
@	PR gold/12279
	* resolve.cc (Symbol_table::should_override): Add fromtype
	parameter.  Change all callers.  Give error when linking together
	TLS and non-TLS symbol.
	(Symbol_table::should_override_with_special): Add fromtype
	parameter.  Change all callers.
	* i386.cc (Target_i386::Relocate::relocate_tls): Don't crash if
	there is no TLS segment if we have reported some errors.
	* x86_64.cc (Target_x86_64::relocate_tls): Likewise.
@
text
@d1241 3
a1249 3
      if (is_forced_local)
	this->force_local(res);

@


1.156
log
@	PR gold/12818
	* symtab.cc (Symbol::should_add_dynsym_entry): Don't add undefined
	symbols which are not used in a relocation.
@
text
@d1886 1
a1886 1
  if (Symbol_table::should_override_with_special(oldsym, defined))
d2000 1
a2000 1
  if (Symbol_table::should_override_with_special(oldsym, defined))
d2119 1
a2119 1
      || Symbol_table::should_override_with_special(oldsym, defined))
@


1.155
log
@	* symtab.cc (Symbol::versioned_name): New function.
	(Symbol_table::add_to_final_symtab): Use versioned_name when
	appropriate.
	(Symbol_table::sized_write_symbol): Likewise.
	* symtab.h (class Symbol): Declare versioned_name.
	* stringpool.h (class Stringpool_template): Add variant of add
	which takes a std::basic_string.
	* testsuite/Makefile.am (check_PROGRAMS): Add ver_test_12.
	(ver_test_12_SOURCES, ver_test_12_DEPENDENCIES): New variables.
	(ver_test_12_LDFLAGS, ver_test_12_LDADD): New variables.
	(ver_test_12.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d417 1
@


1.154
log
@	* symtab.cc (Warnings::issue_warning): Don't warn if relocation
	occurs in same object.
@
text
@d296 15
d2434 4
a2437 1
  pool->add(sym->name(), false, NULL);
d2946 4
a2949 1
  osym.put_st_name(pool->get_offset(sym->name()));
@


1.153
log
@	* common.cc (Symbol_table::do_allocate_commons_list): For incremental
	update, allocate common from bss section's free list.
	* incremental-dump.cc (dump_incremental_inputs): Print flag for
	linker-defined symbols.
	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Skip GOT and PLT entries that are no longer referenced.
	(Output_section_incremental_inputs::write_info_blocks): Mark
	linker-defined symbols.
	(Sized_incr_relobj::do_add_symbols): Process linker-defined symbols.
	* output.cc (Output_section::allocate): New function.
	* output.h (Output_section::allocate): New function.
	* resolve.cc (Symbol_table::report_resolve_problem): Add case for
	linker-defined symbols.
	(Symbol::override_base_with_special): Copy is_predefined_ flag.
	* symtab.cc (Symbol::init_fields): Initialize is_predefined_ flag.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* symtab.h (Symbol::is_predefined): New function.
	(Symbol::init_base_output_data): Add is_predefined parameter.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::is_predefined_): New data member.
	(Sized_symbol::init_output_data): Add is_predefined parameter.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(enum Symbol_table::Defined): Add INCREMENTAL_BASE.
@
text
@d3285 6
@


1.152
log
@	* copy-relocs.cc (Copy_relocs::copy_reloc): Call make_copy_reloc
	instead of emit_copy_reloc.
	(Copy_relocs::emit_copy_reloc): Refactor.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* copy-relocs.h (Copy_relocs::emit_copy_reloc): Move to public
	section.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* gold.cc (queue_middle_tasks): Emit old COPY relocations from
	unchanged input files.
	* incremental-dump.cc (dump_incremental_inputs): Print "COPY" flag.
	* incremental.cc (Sized_incremental_binary::do_reserve_layout):
	Reserve BSS space for COPY relocations.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Output_section_incremental_inputs::write_info_blocks): Record
	whether a symbol is copied from a shared object.
	(Sized_incr_dynobj::do_add_symbols): Record COPY relocations.
	* incremental.h (enum Incremental_shlib_symbol_flags): New type.
	(INCREMENTAL_SHLIB_SYM_FLAGS_SHIFT): New constant.
	(Incremental_input_entry_reader::get_output_symbol_index): Add
	is_copy parameter.
	(Incremental_binary::emit_copy_relocs): New function.
	(Incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data member.
	(Sized_incremental_binary::add_copy_reloc): New function.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Copy_reloc): New struct.
	(Sized_incremental_binary::Copy_relocs): New typedef.
	(Sized_incremental_binary::copy_relocs_): New data member.
	* symtab.cc (Symbol_table::add_from_incrobj): Change return type.
	* symtab.h (Symbol_table::add_from_incrobj): Change return type.
	* target.h (Sized_target::emit_copy_reloc): New function.
	* x86_64.cc (Target_x86_64::emit_copy_reloc): New function.
@
text
@d82 1
d137 2
a138 1
			      unsigned char nonvis, bool offset_is_from_end)
d146 1
d157 2
a158 1
				 Segment_offset_base offset_base)
d166 1
d175 2
a176 1
			   elfcpp::STV visibility, unsigned char nonvis)
d182 1
d237 2
a238 1
				     bool offset_is_from_end)
d241 1
a241 1
			      nonvis, offset_is_from_end);
d257 2
a258 1
					Segment_offset_base offset_base)
d261 1
a261 1
				 nonvis, offset_base);
d274 2
a275 1
				  elfcpp::STV visibility, unsigned char nonvis)
d277 2
a278 1
  this->init_base_constant(name, version, type, binding, visibility, nonvis);
d1857 2
a1858 1
			visibility, nonvis, offset_is_from_end);
d1971 2
a1972 1
			   visibility, nonvis, offset_base);
d2084 1
a2084 1
		     nonvis);
@


1.151
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d1492 1
a1492 1
Symbol*
d3456 1
a3456 1
Symbol*
d3466 1
a3466 1
Symbol*
d3476 1
a3476 1
Symbol*
d3486 1
a3486 1
Symbol*
@


1.150
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d1051 1
a1051 1
    Sized_relobj<size, big_endian>* relobj,
d1057 1
a1057 1
    typename Sized_relobj<size, big_endian>::Symbols* sympointers,
d1307 1
a1307 1
    typename Sized_relobj<size, big_endian>::Symbols* sympointers,
d3298 1
a3298 1
    Sized_relobj<32, false>* relobj,
d3304 1
a3304 1
    Sized_relobj<32, false>::Symbols* sympointers,
d3312 1
a3312 1
    Sized_relobj<32, true>* relobj,
d3318 1
a3318 1
    Sized_relobj<32, true>::Symbols* sympointers,
d3326 1
a3326 1
    Sized_relobj<64, false>* relobj,
d3332 1
a3332 1
    Sized_relobj<64, false>::Symbols* sympointers,
d3340 1
a3340 1
    Sized_relobj<64, true>* relobj,
d3346 1
a3346 1
    Sized_relobj<64, true>::Symbols* sympointers,
d3402 1
a3402 1
    Sized_relobj<32, false>::Symbols* sympointers,
d3418 1
a3418 1
    Sized_relobj<32, true>::Symbols* sympointers,
d3434 1
a3434 1
    Sized_relobj<64, false>::Symbols* sympointers,
d3450 1
a3450 1
    Sized_relobj<64, true>::Symbols* sympointers,
@


1.149
log
@	* dwarf_reader.cc (Sized_dwarf_line_info): Include all lines,
	but mark earlier ones as non-canonical
	(offset_to_iterator): Update search target and example
	(do_addr2line): Return extra lines in a vector*
	(format_file_lineno): Extract from do_addr2line
	(one_addr2line): Add vector* out-param
	* dwarf_reader.h (Offset_to_lineno_entry): New field recording
	when a lineno entry appeared last for its instruction
	(Dwarf_line_info): Add vector* out-param
	* object.cc (Relocate_info): Pass NULL for the vector* out-param
	* symtab.cc (Odr_violation_compare): Include the lineno in the
	comparison again.
	(linenos_from_loc): New. Combine the canonical line for an
	address with its other lines.
	(True_if_intersect): New. Helper functor to make
	std::set_intersection a query.
	(detect_odr_violations): Compare sets of lines instead of just
	one line for each function. This became less deterministic, but
	has fewer false positives.
	* symtab.h: Declarations.
	* testsuite/Makefile.am (odr_violation2.o): Compile with -O2 to
	mix an optimized and non-optimized object in the same binary
	(odr_violation2.so): Same.
	* testsuite/Makefile.in: Regenerate from Makefile.am.
	* testsuite/debug_msg.cc (main): Make OdrDerived classes.
	* testsuite/debug_msg.sh: Update line numbers and add
	assertions.
	* testsuite/odr_violation1.cc: Use OdrDerived, in a
	non-optimized context.
	* testsuite/odr_violation2.cc: Make sure Ordering::operator()
	isn't inlined, and use OdrDerived in an optimized context.
	* testsuite/odr_header1.h: Defines OdrDerived, where
	optimization will change the
	first-instruction-in-the-destructor's file and line number.
	* testsuite/odr_header2.h: Defines OdrBase.
@
text
@d43 1
d1489 31
d3454 40
@


1.148
log
@2010-02-18  Rafael Ávila de Espíndola <respindola@@mozilla.com>

	* symtab.cc (Symbol::should_add_dynsym_entry) Return false for
	plugin only symbols.
	(Symbol_table::sized_finalize_symbol) Mark symbol only present
	in plugin files as not needed in the symbol table.
@
text
@d3028 1
a3028 1
// defined in different source locations.  When comparing the source
d3038 1
a3038 1
// operator used with std::set.
d3046 1
a3046 1
    // "dirname/" is optional.  We want to compare just the filename.
d3048 1
a3048 1
    // Find the last '/' and ':' in each string.
a3050 2
    std::string::size_type s1end = s1.rfind(':');
    std::string::size_type s2end = s2.rfind(':');
d3056 2
a3057 9
    // If the ':' appeared in the directory name, compare to the end
    // of the string.
    if (s1end < s1begin)
      s1end = s1.size();
    if (s2end < s2begin)
      s2end = s2.size();
    // Compare takes lengths, not end indices.
    return s1.compare(s1begin, s1end - s1begin,
		      s2, s2begin, s2end - s2begin) < 0;
d3061 53
d3115 2
a3116 1
// but apparently different definitions (different source-file/line-no).
d3126 10
a3135 11
      const char* symbol_name = it->first;
      // Maps from symbol location to a sample object file we found
      // that location in.  We use a sorted map so the location order
      // is deterministic, but we only store an arbitrary object file
      // to avoid copying lots of names.
      std::map<std::string, std::string, Odr_violation_compare> line_nums;

      for (Unordered_set<Symbol_location, Symbol_location_hash>::const_iterator
               locs = it->second.begin();
           locs != it->second.end();
           ++locs)
d3137 8
a3144 17
	  // We need to lock the object in order to read it.  This
	  // means that we have to run in a singleton Task.  If we
	  // want to run this in a general Task for better
	  // performance, we will need one Task for object, plus
	  // appropriate locking to ensure that we don't conflict with
	  // other uses of the object.  Also note, one_addr2line is not
          // currently thread-safe.
	  Task_lock_obj<Object> tl(task, locs->object);
          // 16 is the size of the object-cache that one_addr2line should use.
          std::string lineno = Dwarf_line_info::one_addr2line(
              locs->object, locs->shndx, locs->offset, 16);
          if (!lineno.empty())
            {
              std::string& sample_object = line_nums[lineno];
              if (sample_object.empty())
                sample_object = locs->object->name();
            }
d3147 5
a3151 1
      if (line_nums.size() > 1)
d3153 40
a3192 9
          gold_warning(_("while linking %s: symbol '%s' defined in multiple "
                         "places (possible ODR violation):"),
                       output_file_name, demangle(symbol_name).c_str());
          for (std::map<std::string, std::string>::const_iterator it2 =
		 line_nums.begin();
	       it2 != line_nums.end();
	       ++it2)
            fprintf(stderr, _("  %s from %s\n"),
                    it2->first.c_str(), it2->second.c_str());
@


1.147
log
@	* symtab.cc (Odr_violation_compare::operator()): Sort by just the
	filename.
@
text
@d313 5
d2601 9
@


1.146
log
@	* plugin.cc (class Plugin_rescan): Define new class.
	(Plugin_manager::claim_file): Set any_claimed_.
	(Plugin_manager::save_archive): New function.
	(Plugin_manager::save_input_group): New function.
	(Plugin_manager::all_symbols_read): Create Plugin_rescan task if
	necessary.
	(Plugin_manager::new_undefined_symbol): New function.
	(Plugin_manager::rescan): New function.
	(Plugin_manager::rescannable_defines): New function.
	(Plugin_manager::add_input_file): Set any_added_.
	* plugin.h (class Plugin_manager): define new fields rescannable_,
	undefined_symbols_, any_claimed_, and any_added_.  Declare
	Plugin_rescan as friend.  Declare new functions.
	(Plugin_manager::Rescannable): Define type.
	(Plugin_manager::Rescannable_list): Define type.
	(Plugin_manager::Undefined_symbol_list): Define type.
	(Plugin_manager::Plugin_manager): Initialize new fields.
	* archive.cc (Archive::defines_symbol): New function.
	(Add_archive_symbols::run): Pass archive to plugins if any.
	* archive.h (class Archive): Declare defines_symbol.
	* readsyms.cc (Input_group::~Input_group): New function.
	(Finish_group::run): Pass input_group to plugins if any.
	* readsyms.h (class Input_group): Declare destructor.
	* symtab.cc (add_from_object): Pass undefined symbol to plugins if
	any.
@
text
@d3015 6
a3020 5
// location, we consider instances with the same base filename and
// line number to be the same.  This is because different object
// files/shared libraries can include the same header file using
// different paths, and we don't want to report an ODR violation in
// that case.
d3031 22
a3052 7
    std::string::size_type pos1 = s1.rfind('/');
    std::string::size_type pos2 = s2.rfind('/');
    if (pos1 == std::string::npos
	|| pos2 == std::string::npos)
      return s1 < s2;
    return s1.compare(pos1, std::string::npos,
		      s2, pos2, std::string::npos) < 0;
@


1.145
log
@2010-10-02  Doug Kwan  <dougkwan@@google.com>

	* symtab.cc (Symbol_table::Symbol_table_hash::operator()): Move
	defintion to symtab.h
	* symtab.h (Symbol_table::Symbol_table_hash::operator()): Change
	declaration to defintion.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d1005 5
a1009 1
    ++this->saw_undefined_;
@


1.145.2.1
log
@	* plugin.cc (class Plugin_rescan): Define new class.
	(Plugin_manager::claim_file): Set any_claimed_.
	(Plugin_manager::save_archive): New function.
	(Plugin_manager::save_input_group): New function.
	(Plugin_manager::all_symbols_read): Create Plugin_rescan task if
	necessary.
	(Plugin_manager::new_undefined_symbol): New function.
	(Plugin_manager::rescan): New function.
	(Plugin_manager::rescannable_defines): New function.
	(Plugin_manager::add_input_file): Set any_added_.
	* plugin.h (class Plugin_manager): define new fields rescannable_,
	undefined_symbols_, any_claimed_, and any_added_.  Declare
	Plugin_rescan as friend.  Declare new functions.
	(Plugin_manager::Rescannable): Define type.
	(Plugin_manager::Rescannable_list): Define type.
	(Plugin_manager::Undefined_symbol_list): Define type.
	(Plugin_manager::Plugin_manager): Initialize new fields.
	* archive.cc (Archive::defines_symbol): New function.
	(Add_archive_symbols::run): Pass archive to plugins if any.
	* archive.h (class Archive): Declare defines_symbol.
	* readsyms.cc (Input_group::~Input_group): New function.
	(Finish_group::run): Pass input_group to plugins if any.
	* readsyms.h (class Input_group): Declare destructor.
	* symtab.cc (add_from_object): Pass undefined symbol to plugins if
	any.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d1005 1
a1005 5
    {
      ++this->saw_undefined_;
      if (parameters->options().has_plugins())
	parameters->options().plugins()->new_undefined_symbol(ret);
    }
@


1.145.2.2
log
@	* symtab.cc (Odr_violation_compare::operator()): Sort by just the
	filename.
@
text
@d3015 5
a3019 6
// location, we consider instances with the same base filename to be
// the same.  This is because different object files/shared libraries
// can include the same header file using different paths, and
// different optimization settings can make the line number appear to
// be a couple lines off, and we don't want to report an ODR violation
// in those cases.
d3030 7
a3036 22
    // Inputs should be of the form "dirname/filename:linenum" where
    // "dirname/" is optional.  We want to compare just the filename.

    // Find the last '/' and ':' in each string.
    std::string::size_type s1begin = s1.rfind('/');
    std::string::size_type s2begin = s2.rfind('/');
    std::string::size_type s1end = s1.rfind(':');
    std::string::size_type s2end = s2.rfind(':');
    // If there was no '/' in a string, start at the beginning.
    if (s1begin == std::string::npos)
      s1begin = 0;
    if (s2begin == std::string::npos)
      s2begin = 0;
    // If the ':' appeared in the directory name, compare to the end
    // of the string.
    if (s1end < s1begin)
      s1end = s1.size();
    if (s2end < s2begin)
      s2end = s2.size();
    // Compare takes lengths, not end indices.
    return s1.compare(s1begin, s1end - s1begin,
		      s2, s2begin, s2end - s2begin) < 0;
@


1.144
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@a503 8
// The hash function.  The key values are Stringpool keys.

inline size_t
Symbol_table::Symbol_table_hash::operator()(const Symbol_table_key& key) const
{
  return key.first ^ key.second;
}

@


1.143
log
@2010-08-12  Cary Coutant  <ccoutant@@google.com>
	    Doug Kwan  <dougkwan@@google.com>

	* resolve.cc (Symbol_table::should_override): When a weak dynamic
	defintion overrides non-weak undef, remember that the original undef
	is not weak.
	* symtab.cc (Symbol_table::sized_write_global): For undef without
	an original weak binding, set binding to global in output.
	* testsuite/Makefile.am: Add new test strong_ref_weak_def.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/strong_ref_weak_def.sh: New file.
	* testsuite/strong_ref_weak_def_1.c: Ditto.
	* testsuite/strong_ref_weak_def_2.c: Ditto.
@
text
@d542 1
a542 1
      gold_assert (sym != NULL);
d605 1
a605 1
      Relobj *obj = static_cast<Relobj*>(sym->object()); 
d866 1
a866 1
			      const char *name,
d868 1
a868 1
			      const char *version,
d1056 1
a1056 1
    size_t *defined)
d1584 1
a1584 1
				    bool *resolve_oldsym)
d2327 1
a2327 1
		       unsigned int *plocal_symcount)
d2930 1
a2930 1
Symbol_table::write_section_symbol(const Output_section *os,
@


1.142
log
@	PR 11855
	* script.cc (Script_options::Script_options): Initialize
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_assignment): Update
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_reference): New function.
	(script_symbol): New function.
	* script.h (class Script_options): Add symbol_definitions_ and
	symbol_references_ fields.
	(Script_options::referenced_const_iterator): New type.
	(Script_options::referenced_begin): New function.
	(Script_options::referenced_end): New function.
	(Script_options::is_referenced): New function.
	(Script_options::any_unreferenced): New function.
	* script-c.h (script_symbol): Declare.
	* yyscript.y (exp): Call script_symbol.
	* symtab.cc: Include "script.h".
	(Symbol_table::gc_mark_undef_symbols): Add layout parameter.
	Change all callers.  Check symbols referenced by scripts.
	(Symbol_table::add_undefined_symbols_from_command_line): Add
	layout parameter.  Change all callers.
	(Symbol_table::do_add_undefined_symbols_from_command_line):
	Likewise.  Break out loop body.  Check symbols referenced by
	scripts.
	(Symbol_table::add_undefined_symbol_from_command_line): New
	function broken out of
	do_add_undefined_symbols_from_command_line.
	* symtab.h (class Symbol_table): Update declarations.
	* archive.cc: Include "layout.h".
	(Archive::should_include_member): Add layout parameter.  Change
	all callers.  Check for symbol mentioned in expression.
	* archive.h (class Archive): Update declaration.
	* object.cc (Sized_relobj::do_should_include_member): Add layout
	parameter.
	* object.h (Object::should_include_member): Add layout parameter.
	Change all callers.
	(Object::do_should_include_member): Add layout parameter.
	(class Sized_relobj): Update declaration.
	* dynobj.cc (Sized_dynobj::do_should_include_member): Add layout
	parameter.
	* dynobj.h (class Sized_dynobj): Update declaration.
	* plugin.cc (Sized_pluginobj::do_should_include_member): Add
	layout parameter.
	* plugin.h (class Sized_pluginobj): Update declaration.
@
text
@d2759 2
@


1.141
log
@	* resolve.cc (Symbol_table::resolve): Remember whether undef was
	weak when resolving to a dynamic def.
	(Symbol_table::should_override): Add adjust_dyndef flag; set it
	for weak undef/dynamic def cases. Adjust callers.
	* symtab.cc (Symbol::init_fields): Initialize undef_binding_set_ and
	undef_binding_weak_.
	(Symbol_table::sized_write_globals): Adjust symbol binding.
	(Symbol_table::sized_write_symbol): Add binding parameter.
	* symtab.h (Symbol::set_undef_binding): New method.
	(Symbol::is_undef_binding_weak): New method.
	(Symbol::undef_binding_set_, Symbol::undef_binding_weak_): New members.
	(Symbol_table::should_override): Add new parameter.
	(Symbol_table::sized_write_symbol): Add new parameter.

	* testsuite/weak_undef_file1.cc: Add new test case.
	* testsuite/weak_undef_file2.cc: Fix header comment.
	* testsuite/weak_undef_test.cc: Add new test case.
@
text
@d41 1
a41 1
#include "demangle.h"   // needed for --dynamic-list-cpp-new
d533 1
a533 1
Symbol_table::gc_mark_undef_symbols()
d556 21
d2187 1
a2187 1
Symbol_table::add_undefined_symbols_from_command_line()
d2189 2
a2190 1
  if (parameters->options().any_undefined())
d2195 1
a2195 1
	  this->do_add_undefined_symbols_from_command_line<32>();
d2203 1
a2203 1
	  this->do_add_undefined_symbols_from_command_line<64>();
d2215 1
a2215 1
Symbol_table::do_add_undefined_symbols_from_command_line()
d2221 8
a2228 2
    {
      const char* name = p->c_str();
d2230 6
a2235 2
      if (this->lookup(name) != NULL)
	continue;
d2237 1
a2237 1
      const char* version = NULL;
d2239 5
a2243 5
      Sized_symbol<size>* sym;
      Sized_symbol<size>* oldsym;
      bool resolve_oldsym;
      if (parameters->target().is_big_endian())
	{
d2245 3
a2247 3
	  sym = this->define_special_symbol<size, true>(&name, &version,
							false, &oldsym,
							&resolve_oldsym);
d2249 1
a2249 1
	  gold_unreachable();
d2251 3
a2253 3
	}
      else
	{
d2255 3
a2257 3
	  sym = this->define_special_symbol<size, false>(&name, &version,
							 false, &oldsym,
							 &resolve_oldsym);
d2259 1
a2259 1
	  gold_unreachable();
d2261 1
a2261 1
	}
d2263 1
a2263 1
      gold_assert(oldsym == NULL);
d2265 3
a2267 4
      sym->init_undefined(name, version, elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
			  elfcpp::STV_DEFAULT, 0);
      ++this->saw_undefined_;
    }
@


1.140
log
@	* symtab.cc (detect_odr_violations): When reporting an ODR
	violation, report an object where the symbol is defined.
@
text
@d79 2
d2702 1
d2726 2
d2808 1
a2808 1
						     sympool, ps);
d2817 1
a2817 1
						     dynpool, pd);
d2835 1
d2856 1
a2856 1
    osym.put_st_info(elfcpp::elf_st_info(sym->binding(), type));
@


1.139
log
@2010-04-18  Sriraman Tallam  <tmsriram@@google.com>

	* icf.cc (get_section_contents): Check for preemptible functions.
	Ignore addend when appropriate.
	* symtab.cc (should_add_dynsym_entry): Add new parameter.  Check for
	section folded.
	(add_from_relobj): Check for section folded.
	(set_dynsym_indexes): Fix call to should_add_dynsym_entry.
	* symtab.h (should_add_dynsym_entry): Add new parameter.
	* target-reloc.h (scan_relocs): Check for section folded.
	* x86_64.cc (Target_x86_64::Scan::possible_function_pointer_reloc):
	Check reloc types for function pointers in shared objects.
	* testsuite/Makefile.am (icf_virtual_function_folding_test): New test
	case.
	(icf_preemptible_functions_test): New test case.
	(icf_string_merge_test): New test case.
	* testsuite.Makefile.in: Regenerate.
	* testsuite/icf_safe_so_test.sh: Change to not fold foo_glob and
	bar_glob.  Refactor code.
	* testsuite/icf_preemptible_functions_test.cc: New file.
	* testsuite/icf_preemptible_functions_test.sh: New file.
	* testsuite/icf_string_merge_test.cc: New file.
	* testsuite/icf_string_merge_test.sh: New file.
	* testsuite/icf_virtual_function_folding_test.cc: New file.
	* testsuite/icf_virtual_function_folding_test.sh: New file.
@
text
@d3017 5
a3021 2
      // We use a sorted set so the output is deterministic.
      std::set<std::string, Odr_violation_compare> line_nums;
d3040 5
a3044 1
            line_nums.insert(lineno);
d3052 6
a3057 4
          for (std::set<std::string>::const_iterator it2 = line_nums.begin();
               it2 != line_nums.end();
               ++it2)
            fprintf(stderr, "  %s\n", it2->c_str());
@


1.138
log
@	* script.cc (class Lazy_demangler): Recreate--revert part of patch
	of 2009-12-30.
	(Version_script_info::Version_script_info): Initialize globs_,
	default_version_, default_is_global_, and exact_.  Don't
	initialize globals_ or locals_.
	(Version_script_info::build_lookup_tables): Build local symbols
	first.
	(Version_script_info::unquote): New function.
	(Version_script_info::add_exact_match): New function.
	(Version_script_info::build_expression_list_lookup): Remove lookup
	parameter.  Add is_global parameter.  Change all callers.  Handle
	wildcard pattern specially.  Unquote pattern.  Call
	add_exact_match.
	(Version_script_info::get_name_to_match): New function.
	(Version_script_info::get_symbol_version): New function.
	(Version_script_info::get_symbol_version_helper): Remove.
	(Version_script_info::check_unmatched_names): Call unquote.
	* script.h (class Version_script_info): Change get_symbol_version
	to be non-inline and add is_global parameter; change all callers.
	Rewrite symbol_is_local.  Update declarations.  Define struct
	Version_tree_match, Exact, Globs.  Don't define struct Lookup.
	Remove globals_ and locals_ members.  Add exact_, globs_,
	default_version_, is_global_.
	(Version_script_info::Glob): Remove pattern, add expression and
	is_global.  Update constructor.  Change all callers.
	* dynobj.cc (Versions::finalize): Mark the version symbol as the
	default version.
	(Versions::symbol_section_contents): If a symbol is undefined, or
	defined in a dynamic object, set the version index to
	VER_NDX_LOCAL.
	* symtab.cc (Symbol_table::add_from_relobj): Don't call
	symbol_is_local.
	(Symbol_table::add_from_pluginobj): Likewise.
	* testsuite/ver_matching_test.sh: blaza1 and blaza go into V2.
@
text
@d309 1
a309 1
Symbol::should_add_dynsym_entry() const
d327 2
a328 1
          && !relobj->is_section_included(shndx))
d1076 2
a1077 1
	  && !relobj->is_section_included(st_shndx))
d2258 1
a2258 1
      if (!sym->should_add_dynsym_entry())
@


1.137
log
@	PR 11108
	* symtab.h (class Symbol): Remove fields is_target_special_ and
	has_plt_offset_.  Add field is_defined_in_discarded_section_.
	(Symbol::is_defined_in_discarded_section): New function.
	(Symbol::set_is_defined_in_discarded_section): New function.
	(Symbol::has_plt_offset): Rewrite.
	(Symbol::set_plt_offset): Verify that new offset is not -1U.
	* symtab.cc (Symbol::init_fields): Initialize plt_offset_ to -1U.
	Don't initialize is_target_special_ or has_plt_offset_.
	Initialize is_defined_in_discarded_section_.
	(Symbol_table::add_from_relobj): If appropriate, set
	is_defined_in_discarded_section.
	* resolve.cc (Symbol::override_base_with_special): Don't test
	is_target_special_.  Change has_plt_offset_ to has_plt_offset().
	* target-reloc.h (relocate_section): Do special handling for
	symbols defined in discarded sections for global symbols as well
	as local symbols.
@
text
@d1116 3
a1118 1
	      if (this->version_script_.get_symbol_version(name, &version))
d1120 3
a1122 3
		  // The version can be empty if the version script is
		  // only used to force some symbols to be local.
		  if (!version.empty())
a1130 2
	      else if (this->version_script_.symbol_is_local(name))
		is_forced_local = true;
d1235 3
a1237 1
          if (this->version_script_.get_symbol_version(name, &version))
d1239 3
a1241 3
              // The version can be empty if the version script is
              // only used to force some symbols to be local.
              if (!version.empty())
a1249 2
          else if (this->version_script_.symbol_is_local(name))
            is_forced_local = true;
d1569 2
a1570 1
      if (this->version_script_.get_symbol_version(*pname, &v))
d1572 7
a1578 6
	  if (!v.empty())
	    *pversion = v.c_str();

	  // If we get the version from a version script, then we are
	  // also the default version.
	  is_default_version = true;
@


1.136
log
@	* symtab.cc (Symbol_table::add_from_object): Rename def parameter
	to is_default_version.  Rename insdef to insdefault.
	(Symbol_table::add_from_relobj): Rename def to is_default_version
	and local to is_forced_local.
	(Symbol_table::add_from_pluginobj): Likewise.
	(Symbol_table::add_from_dynobj): Likewise.
	(Symbol_table::define_special_symbol): Rename insdef to
	insdefault.
@
text
@d62 1
a62 1
  this->plt_offset_ = 0;
a66 1
  this->is_target_special_ = false;
a72 1
  this->has_plt_offset_ = false;
d78 1
d1072 1
d1076 4
a1079 1
	st_shndx = elfcpp::SHN_UNDEF;
d1196 3
@


1.135
log
@	PR 10916
	* symtab.cc (Symbol_table::add_from_relobj): When not exporting
	symbols from this object, don't change the visibility of an
	undefined symbol.
	* testsuite/exclude_libs_test_1.c (lib1_ref): New function.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d816 7
a822 7
// If DEF is true, then this is the definition of a default version of
// a symbol.  That means that any lookup of NAME/NULL and any lookup
// of NAME/VERSION should always return the same symbol.  This is
// obvious for references, but in particular we want to do this for
// definitions: overriding NAME/NULL should also override
// NAME/VERSION.  If we don't do that, it would be very hard to
// override functions in a shared library which uses versioning.
d847 1
a847 1
			      bool def,
d886 1
a886 1
  std::pair<typename Symbol_table_type::iterator, bool> insdef =
d888 1
a888 1
  if (def)
d891 3
a893 3
      insdef = this->table_.insert(std::make_pair(std::make_pair(name_key,
								 vnull_key),
						  snull));
d918 3
a920 3
      if (def)
	this->define_default_version<size, big_endian>(ret, insdef.second,
						       insdef.first);
d927 1
a927 1
      if (def && !insdef.second)
d931 1
a931 1
	  ret = this->get_sized_symbol<size>(insdef.first->second);
d958 1
a958 1
		  if (!def)
d962 2
a963 2
		      this->table_.erase(insdef.first);
		      // Inserting insdef invalidated ins.
d974 1
a974 1
	  if (def)
d978 2
a979 2
	      gold_assert(insdef.second);
	      insdef.first->second = ret;
d983 1
a983 1
      if (def)
d1084 4
a1087 3
      // DEF: is the version default?  LOCAL: is the symbol forced local?
      bool def = false;
      bool local = false;
d1096 1
a1096 1
	      def = true;
d1123 1
a1123 1
		      def = true;
d1127 1
a1127 1
		local = true;
d1181 2
a1182 2
				  def, *psym, st_shndx, is_ordinary,
				  orig_st_shndx);
d1190 1
a1190 1
      if (local)
d1211 2
a1212 2
  bool def = false;
  bool local = false;
d1239 1
a1239 1
                  def = true;
d1243 1
a1243 1
            local = true;
d1252 2
a1253 1
		              def, *sym, st_shndx, is_ordinary, st_shndx);
d1255 1
a1255 1
  if (local)
d1430 2
a1431 2
		  const bool def = (!hidden
				    && st_shndx != elfcpp::SHN_UNDEF);
d1433 2
a1434 1
					      version_key, def, *psym, st_shndx,
d1610 1
a1610 1
      std::pair<typename Symbol_table_type::iterator, bool> insdef =
d1615 4
a1618 3
	  insdef = this->table_.insert(std::make_pair(std::make_pair(name_key,
								     vnull),
						      snull));
d1632 2
a1633 2
							     insdef.second,
							     insdef.first);
d1644 1
a1644 1
	  if (is_default_version && !insdef.second)
d1648 1
a1648 1
	      oldsym = insdef.first->second;
d1658 1
a1658 1
		  add_def_loc = insdef.first;
@


1.134
log
@	* symtab.h (class Symbol_table): Add enum Defined.
	* resolve.cc (Symbol_table::should_override): Add defined
	parameter.  Change all callers.  Test whether object is NULL
	before calling a method on it.
	(Symbol_table::report_resolve_problem): Add defined parameter.
	Change all callers.
	(Symbol_table::should_override_with_special): Likewise.
	* symtab.cc (Symbol_table::define_in_output_data): Add defined
	parameter.  Change all callers.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::define_in_output_segment): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::define_as_constant): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* script.h (class Symbol_assignment): Add is_defsym parameter to
	constructor; change all callers.
	* script.cc (Script_options::add_symbol_assignment): Add is_defsym
	parameter.  Change all callers.  Add is_defsym_ field.
	(class Parser_closure): Add parsing_defsym parameter to
	constructor; change all callers.  Add parsing_defsym accessor
	function.  Add parsing_defsym_ field.
@
text
@d1154 2
a1155 1
      if (relobj->no_export())
@


1.133
log
@2009-12-16  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::scan_sections_for_stubs): Exclude ICF-eliminated
	sections.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Handle
	relaxed input sections.
	* output.cc (Output_section::find_relaxed_input_section): Change
	return type to Output_relaxed_input_section pointer.  Adjust code
	for new type of relaxed_input_section_map_.
	* output.h (Output_section::find_relaxed_input_section): Change
	return type to Output_relaxed_input_section pointer.
	(Output_section::Output_relaxed_input_section_by_input_section_map):
	New type.
	(Output_section::relaxed_input_section_map_): Change type to
	Output_section::Output_relaxed_input_section_by_input_section_map.
	* symtab.cc (Symbol_table::compute_final_value): Handle relaxed
	input section.
@
text
@d1689 1
d1703 1
a1703 1
      return this->do_define_in_output_data<32>(name, version, od,
d1715 1
a1715 1
      return this->do_define_in_output_data<64>(name, version, od,
d1735 1
d1787 1
a1787 1
  if (Symbol_table::should_override_with_special(oldsym))
d1803 3
a1805 1
				       const char* version, Output_segment* os,
d1818 1
a1818 1
      return this->do_define_in_output_segment<32>(name, version, os,
d1829 1
a1829 1
      return this->do_define_in_output_segment<64>(name, version, os,
d1848 1
d1900 1
a1900 1
  if (Symbol_table::should_override_with_special(oldsym))
d1918 1
d1931 1
a1931 1
      return this->do_define_as_constant<32>(name, version, value,
d1942 1
a1942 1
      return this->do_define_as_constant<64>(name, version, value,
d1961 1
d2018 2
a2019 1
  if (force_override || Symbol_table::should_override_with_special(oldsym))
d2042 1
a2042 1
	this->define_in_output_data(p->name, NULL, os, p->value,
d2048 2
a2049 2
	this->define_as_constant(p->name, NULL, 0, p->size, p->type,
				 p->binding, p->visibility, p->nonvis,
d2068 1
a2068 1
	this->define_in_output_segment(p->name, NULL, os, p->value,
d2074 2
a2075 2
	this->define_as_constant(p->name, NULL, 0, p->size, p->type,
				 p->binding, p->visibility, p->nonvis,
d2104 1
a2104 1
  this->define_in_output_data(csym->name(), csym->version(),
@


1.132
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@a2415 1
            uint64_t secoff64 = relobj->output_section_offset(shndx);
d2425 3
a2427 1
                os = folded_obj->output_section(folded.second);  
d2429 4
a2432 1
                secoff64 = folded_obj->output_section_offset(folded.second);
d2435 1
@


1.131
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d53 3
a55 3
Symbol::init_fields(const char* aname, const char* aversion,
		    elfcpp::STT atype, elfcpp::STB abinding,
		    elfcpp::STV avisibility, unsigned char non_vis)
d57 2
a58 2
  this->name_ = aname;
  this->version_ = aversion;
d63 4
a66 4
  this->type_ = atype;
  this->binding_ = abinding;
  this->visibility_ = avisibility;
  this->nonvis_ = non_vis;
d86 1
a86 1
demangle(const char* aname)
d89 1
a89 1
    return aname;
d93 1
a93 1
  char* demangled_name = cplus_demangle(aname, DMGL_ANSI | DMGL_PARAMS);
d95 1
a95 1
    return aname;
d112 1
a112 1
Symbol::init_base_object(const char* aname, const char* aversion, Object* aobject,
d116 1
a116 1
  this->init_fields(aname, aversion, sym.get_st_type(), sym.get_st_bind(),
d118 1
a118 1
  this->u_.from_object.object = aobject;
d122 3
a124 3
  this->in_reg_ = !aobject->is_dynamic();
  this->in_dyn_ = aobject->is_dynamic();
  this->in_real_elf_ = aobject->pluginobj() == NULL;
d131 4
a134 4
Symbol::init_base_output_data(const char* aname, const char* aversion,
			      Output_data* od, elfcpp::STT atype,
			      elfcpp::STB abinding, elfcpp::STV avisibility,
			      unsigned char non_vis, bool offset_is_from_the_end)
d136 1
a136 1
  this->init_fields(aname, aversion, atype, abinding, avisibility, non_vis);
d138 1
a138 1
  this->u_.in_output_data.offset_is_from_end = offset_is_from_the_end;
d148 5
a152 5
Symbol::init_base_output_segment(const char* aname, const char* aversion,
				 Output_segment* os, elfcpp::STT atype,
				 elfcpp::STB abinding, elfcpp::STV avisibility,
				 unsigned char non_vis,
				 Segment_offset_base offsetbase)
d154 1
a154 1
  this->init_fields(aname, aversion, atype, abinding, avisibility, non_vis);
d156 1
a156 1
  this->u_.in_output_segment.offset_base = offsetbase;
d166 3
a168 3
Symbol::init_base_constant(const char* aname, const char* aversion,
			   elfcpp::STT atype, elfcpp::STB abinding,
			   elfcpp::STV avisibility, unsigned char non_vis)
d170 1
a170 1
  this->init_fields(aname, aversion, atype, abinding, avisibility, non_vis);
d180 3
a182 3
Symbol::init_base_undefined(const char* aname, const char* aversion,
			    elfcpp::STT atype, elfcpp::STB abinding,
			    elfcpp::STV avisibility, unsigned char non_vis)
d184 1
a184 1
  this->init_fields(aname, aversion, atype, abinding, avisibility, non_vis);
d207 2
a208 2
Sized_symbol<size>::init_object(const char* aname, const char* aversion,
				Object* aobject,
d212 1
a212 1
  this->init_base_object(aname, aversion, aobject, sym, st_shndx, is_ordinary);
d222 12
a233 12
Sized_symbol<size>::init_output_data(const char* aname, const char* aversion,
				     Output_data* od, Value_type avalue,
				     Size_type sym_size, elfcpp::STT atype,
				     elfcpp::STB abinding,
				     elfcpp::STV avisibility,
				     unsigned char non_vis,
				     bool offset_is_from_the_end)
{
  this->init_base_output_data(aname, aversion, od, atype, abinding, avisibility,
			      non_vis, offset_is_from_the_end);
  this->value_ = avalue;
  this->symsize_ = sym_size;
d241 12
a252 12
Sized_symbol<size>::init_output_segment(const char* aname, const char* aversion,
					Output_segment* os, Value_type avalue,
					Size_type sym_size, elfcpp::STT atype,
					elfcpp::STB abinding,
					elfcpp::STV avisibility,
					unsigned char non_vis,
					Segment_offset_base offsetbase)
{
  this->init_base_output_segment(aname, aversion, os, atype, abinding, avisibility,
				 non_vis, offsetbase);
  this->value_ = avalue;
  this->symsize_ = sym_size;
d260 8
a267 8
Sized_symbol<size>::init_constant(const char* aname, const char* aversion,
				  Value_type avalue, Size_type sym_size,
				  elfcpp::STT atype, elfcpp::STB abinding,
				  elfcpp::STV avisibility, unsigned char non_vis)
{
  this->init_base_constant(aname, aversion, atype, abinding, avisibility, non_vis);
  this->value_ = avalue;
  this->symsize_ = sym_size;
d274 3
a276 3
Sized_symbol<size>::init_undefined(const char* aname, const char* aversion,
				   elfcpp::STT atype, elfcpp::STB abinding,
				   elfcpp::STV avisibility, unsigned char non_vis)
d278 1
a278 1
  this->init_base_undefined(aname, aversion, atype, abinding, avisibility, non_vis);
d286 1
a286 1
Symbol::is_common_shndx(unsigned int sec_shndx)
d288 3
a290 3
  return (sec_shndx == elfcpp::SHN_COMMON
	  || sec_shndx == parameters->target().small_common_shndx()
	  || sec_shndx == parameters->target().large_common_shndx());
d297 1
a297 1
Sized_symbol<size>::allocate_common(Output_data* od, Value_type avalue)
d300 1
a300 1
  this->value_ = avalue;
d326 3
a328 3
      unsigned int sec_shndx = this->shndx(&is_ordinary);
      if (is_ordinary && sec_shndx != elfcpp::SHN_UNDEF
          && !relobj->is_section_included(sec_shndx))
d354 3
a356 3
      char* ademangled_name = cplus_demangle(this->name(),
					     DMGL_ANSI | DMGL_PARAMS);
      if (ademangled_name == NULL)
d361 2
a362 2
               && (strprefix(ademangled_name, "operator new")
                   || strprefix(ademangled_name, "operator delete")))
d364 1
a364 1
          free(ademangled_name);
d368 2
a369 2
               && (strprefix(ademangled_name, "typeinfo name for")
                   || strprefix(ademangled_name, "typeinfo for")))
d371 1
a371 1
          free(ademangled_name);
d375 1
a375 1
        free(ademangled_name);
d437 2
a438 2
	unsigned int sec_shndx = this->u_.from_object.shndx;
	if (sec_shndx != elfcpp::SHN_UNDEF && this->is_ordinary_shndx_)
d443 1
a443 1
	    return relobj->output_section(sec_shndx);
d489 1
a489 1
                           const Version_script_info& aversion_script)
d493 1
a493 1
    version_script_(aversion_script), gc_(NULL), icf_(NULL)
d521 1
a521 1
Symbol_table::is_section_folded(Object* obj, unsigned int sec_shndx) const
d524 1
a524 1
          && this->icf_->is_section_folded(obj, sec_shndx));
d538 2
a539 2
      const char* aname = p->c_str();
      Symbol* sym = this->lookup(aname);
d546 1
a546 1
          unsigned int sec_shndx = sym->shndx(&is_ordinary);
d550 1
a550 1
              this->gc_->worklist().push(Section_id(obj, sec_shndx));
d565 2
a566 2
      unsigned int sec_shndx = sym->shndx(&is_ordinary);
      if (is_ordinary && sec_shndx != elfcpp::SHN_UNDEF)
d569 1
a569 1
          this->gc_->worklist().push(Section_id(obj, sec_shndx));
d584 2
a585 2
      unsigned int sec_shndx = sym->shndx(&is_ordinary);
      if (is_ordinary && sec_shndx != elfcpp::SHN_UNDEF)
d588 1
a588 1
          this->gc_->worklist().push(Section_id(obj, sec_shndx));
d619 1
a619 1
Symbol_table::lookup(const char* aname, const char* aversion) const
d622 2
a623 2
  aname = this->namepool_.find(aname, &name_key);
  if (aname == NULL)
d627 1
a627 1
  if (aversion != NULL)
d629 2
a630 2
      aversion = this->namepool_.find(aversion, &version_key);
      if (aversion == NULL)
d659 2
a660 2
  unsigned int sec_shndx = from->shndx(&is_ordinary);
  this->resolve(to, esym.sym(), sec_shndx, is_ordinary, sec_shndx, from->object(),
d692 1
a692 1
Symbol_table::wrap_symbol(const char* aname, Stringpool::Key* name_key)
d697 1
a697 1
  if (aname[0] == parameters->target().wrap_char())
d699 2
a700 2
      prefix = aname[0];
      ++aname;
d703 1
a703 1
  if (parameters->options().is_wrap(aname))
d710 1
a710 1
      s += aname;
d720 2
a721 2
  if (strncmp(aname, real_prefix, real_prefix_length) == 0
      && parameters->options().is_wrap(aname + real_prefix_length))
d727 1
a727 1
      s += aname + real_prefix_length;
d731 1
a731 1
  return aname;
d842 2
a843 2
Symbol_table::add_from_object(Object* aobject,
			      const char *aname,
d845 1
a845 1
			      const char *aversion,
d854 1
a854 1
  if (parameters->options().is_trace_symbol(aname))
d857 1
a857 1
        gold_info(_("%s: reference to %s"), aobject->name().c_str(), aname);
d859 1
a859 1
        gold_info(_("%s: definition of %s"), aobject->name().c_str(), aname);
d867 2
a868 2
      const char* wrap_name = this->wrap_symbol(aname, &name_key);
      if (wrap_name != aname)
d875 1
a875 1
	  aversion = NULL;
d877 1
a877 1
	  aname = wrap_name;
d913 2
a914 2
      this->resolve(ret, sym, st_shndx, is_ordinary, orig_st_shndx, aobject,
		    aversion);
d936 2
a937 2
	  this->resolve(ret, sym, st_shndx, is_ordinary, orig_st_shndx, aobject,
			aversion);
d971 1
a971 1
	  ret->init_object(aname, aversion, aobject, sym, st_shndx, is_ordinary);
d1058 1
a1058 1
      const char* aname = sym_names + st_name;
d1081 1
a1081 1
      const char* ver = strchr(aname, '@@');
d1091 1
a1091 1
          namelen = ver - aname;
d1105 1
a1105 1
	  namelen = strlen(aname);
d1111 2
a1112 2
	      std::string aversion;
	      if (this->version_script_.get_symbol_version(aname, &aversion))
d1116 1
a1116 1
		  if (!aversion.empty())
d1118 2
a1119 2
		      ver = this->namepool_.add_with_length(aversion.c_str(),
							    aversion.length(),
d1125 1
a1125 1
	      else if (this->version_script_.symbol_is_local(aname))
d1174 1
a1174 1
      aname = this->namepool_.add_with_length(aname, namelen, true,
d1178 1
a1178 1
      res = this->add_from_object(relobj, aname, name_key, ver, ver_key,
d1201 1
a1201 1
    const char* aname,
d1226 2
a1227 2
          std::string aversion;
          if (this->version_script_.get_symbol_version(aname, &aversion))
d1231 1
a1231 1
              if (!aversion.empty())
d1233 2
a1234 2
                  ver = this->namepool_.add_with_length(aversion.c_str(),
                                                        aversion.length(),
d1240 1
a1240 1
          else if (this->version_script_.symbol_is_local(aname))
d1246 1
a1246 1
  aname = this->namepool_.add(aname, true, &name_key);
d1249 1
a1249 1
  res = this->add_from_object(obj, aname, name_key, ver, ver_key,
d1340 1
a1340 1
      const char* aname = sym_names + st_name;
d1354 2
a1355 2
	  aname = this->namepool_.add(aname, true, &name_key);
	  res = this->add_from_object(dynobj, aname, name_key, NULL, 0,
d1384 1
a1384 1
	  aname = this->namepool_.add(aname, true, &name_key);
d1390 1
a1390 1
	      res = this->add_from_object(dynobj, aname, name_key, NULL, 0,
d1403 2
a1404 2
	      const char* aversion = (*version_map)[v];
	      if (aversion == NULL)
d1412 1
a1412 1
	      aversion = this->namepool_.add(aversion, true, &version_key);
d1422 1
a1422 1
		res = this->add_from_object(dynobj, aname, name_key, NULL, 0,
d1429 1
a1429 1
		  res = this->add_from_object(dynobj, aname, name_key, aversion,
d1687 2
a1688 2
Symbol_table::define_in_output_data(const char* aname,
				    const char* aversion,
d1690 2
a1691 2
				    uint64_t avalue,
				    uint64_t sym_size,
d1696 1
a1696 1
				    bool offset_is_from_the_end,
d1702 2
a1703 2
      return this->do_define_in_output_data<32>(aname, aversion, od,
                                                avalue, sym_size, type, binding,
d1705 1
a1705 1
                                                offset_is_from_the_end,
d1714 2
a1715 2
      return this->do_define_in_output_data<64>(aname, aversion, od,
                                                avalue, sym_size, type, binding,
d1717 1
a1717 1
                                                offset_is_from_the_end,
d1732 2
a1733 2
    const char* aname,
    const char* aversion,
d1735 2
a1736 2
    typename elfcpp::Elf_types<size>::Elf_Addr avalue,
    typename elfcpp::Elf_types<size>::Elf_WXword sym_size,
d1741 1
a1741 1
    bool offset_is_from_the_end,
d1751 1
a1751 1
      sym = this->define_special_symbol<size, true>(&aname, &aversion,
d1761 1
a1761 1
      sym = this->define_special_symbol<size, false>(&aname, &aversion,
d1772 2
a1773 2
  sym->init_output_data(aname, aversion, od, avalue, sym_size, type, binding,
			visibility, nonvis, offset_is_from_the_end);
d1778 1
a1778 1
	  || this->version_script_.symbol_is_local(aname))
d1780 1
a1780 1
      else if (aversion != NULL)
d1800 4
a1803 4
Symbol_table::define_in_output_segment(const char* aname,
				       const char* aversion, Output_segment* os,
				       uint64_t avalue,
				       uint64_t sym_size,
d1808 1
a1808 1
				       Symbol::Segment_offset_base offsetbase,
d1814 2
a1815 2
      return this->do_define_in_output_segment<32>(aname, aversion, os,
                                                   avalue, sym_size, type,
d1817 1
a1817 1
                                                   offsetbase, only_if_ref);
d1825 2
a1826 2
      return this->do_define_in_output_segment<64>(aname, aversion, os,
                                                   avalue, sym_size, type,
d1828 1
a1828 1
                                                   offsetbase, only_if_ref);
d1842 2
a1843 2
    const char* aname,
    const char* aversion,
d1845 2
a1846 2
    typename elfcpp::Elf_types<size>::Elf_Addr avalue,
    typename elfcpp::Elf_types<size>::Elf_WXword sym_size,
d1851 1
a1851 1
    Symbol::Segment_offset_base offsetbase,
d1861 1
a1861 1
      sym = this->define_special_symbol<size, true>(&aname, &aversion,
d1871 1
a1871 1
      sym = this->define_special_symbol<size, false>(&aname, &aversion,
d1882 2
a1883 2
  sym->init_output_segment(aname, aversion, os, avalue, sym_size, type, binding,
			   visibility, nonvis, offsetbase);
d1888 1
a1888 1
	  || this->version_script_.symbol_is_local(aname))
d1890 1
a1890 1
      else if (aversion != NULL)
d1911 4
a1914 4
Symbol_table::define_as_constant(const char* aname,
				 const char* aversion,
				 uint64_t avalue,
				 uint64_t sym_size,
d1925 2
a1926 2
      return this->do_define_as_constant<32>(aname, aversion, avalue,
                                             sym_size, type, binding,
d1936 2
a1937 2
      return this->do_define_as_constant<64>(aname, aversion, avalue,
                                             sym_size, type, binding,
d1953 4
a1956 4
    const char* aname,
    const char* aversion,
    typename elfcpp::Elf_types<size>::Elf_Addr avalue,
    typename elfcpp::Elf_types<size>::Elf_WXword sym_size,
d1971 1
a1971 1
      sym = this->define_special_symbol<size, true>(&aname, &aversion,
d1981 1
a1981 1
      sym = this->define_special_symbol<size, false>(&aname, &aversion,
d1992 1
a1992 1
  sym->init_constant(aname, aversion, avalue, sym_size, type, binding, visibility,
d1999 3
a2001 3
      if ((aversion == NULL
	   || aname != aversion
	   || avalue != 0)
d2003 1
a2003 1
	      || this->version_script_.symbol_is_local(aname)))
d2005 2
a2006 2
      else if (aversion != NULL
	       && (aname != aversion || avalue != 0))
d2082 1
a2082 1
    typename elfcpp::Elf_types<size>::Elf_Addr avalue)
d2086 3
a2088 3
  Object* aobject = csym->object();
  gold_assert(aobject->is_dynamic());
  Dynobj* dynobj = static_cast<Dynobj*>(aobject);
d2097 1
a2097 1
			      posd, avalue, csym->symsize(),
d2175 1
a2175 1
      const char* aname = p->c_str();
d2177 1
a2177 1
      if (this->lookup(aname) != NULL)
d2180 1
a2180 1
      const char* aversion = NULL;
d2188 1
a2188 1
	  sym = this->define_special_symbol<size, true>(&aname, &aversion,
d2198 1
a2198 1
	  sym = this->define_special_symbol<size, false>(&aname, &aversion,
d2208 1
a2208 1
      sym->init_undefined(aname, aversion, elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
d2378 1
a2378 1
  Value_type avalue;
d2385 1
a2385 1
	unsigned int sec_shndx = sym->shndx(&is_ordinary);
d2388 2
a2389 2
	    && sec_shndx != elfcpp::SHN_ABS
	    && !Symbol::is_common_shndx(sec_shndx))
d2398 2
a2399 2
	    avalue = 0;
	    sec_shndx = elfcpp::SHN_UNDEF;
d2403 2
a2404 2
	    avalue = 0;
	    sec_shndx = elfcpp::SHN_UNDEF;
d2406 2
a2407 2
	else if (sec_shndx == elfcpp::SHN_UNDEF)
	  avalue = 0;
d2409 3
a2411 3
		 && (sec_shndx == elfcpp::SHN_ABS
		     || Symbol::is_common_shndx(sec_shndx)))
	  avalue = sym->value();
d2415 2
a2416 2
	    Output_section* os = relobj->output_section(sec_shndx);
            uint64_t secoff64 = relobj->output_section_offset(sec_shndx);
d2418 1
a2418 1
            if (this->is_section_folded(relobj, sec_shndx))
d2423 1
a2423 1
                                                                   sec_shndx);
d2445 1
a2445 1
	        avalue = os->output_address(relobj, sec_shndx, sym->value());
d2452 1
a2452 1
	          avalue = sym->value() + os->tls_offset() + secoff;
d2454 1
a2454 1
	          avalue = sym->value() + os->address() + secoff;
d2463 1
a2463 1
	avalue = sym->value();
d2465 1
a2465 1
	  avalue += od->address();
d2470 1
a2470 1
	    avalue += os->tls_offset() + (od->address() - os->address());
d2473 1
a2473 1
	  avalue += od->data_size();
d2480 1
a2480 1
	avalue = sym->value();
d2482 1
a2482 1
	  avalue += os->vaddr();
d2488 1
a2488 1
	    avalue += os->memsz();
d2491 1
a2491 1
	    avalue += os->filesz();
d2500 1
a2500 1
      avalue = sym->value();
d2504 1
a2504 1
      avalue = 0;
d2512 1
a2512 1
  return avalue;
d2541 1
a2541 1
  Value_type avalue = this->compute_final_value(sym, &status);
d2550 1
a2550 1
	unsigned int sec_shndx = sym->shndx(&is_ordinary);
d2552 1
a2552 1
		   sym->demangled_name().c_str(), sec_shndx);
d2562 1
a2562 1
  sym->set_value(avalue);
d2669 1
a2669 1
      unsigned int sec_shndx;
d2685 1
a2685 1
		sec_shndx = in_shndx;
d2694 1
a2694 1
		    sec_shndx = elfcpp::SHN_UNDEF;
d2697 1
a2697 1
		  sec_shndx = elfcpp::SHN_UNDEF;
d2702 1
a2702 1
		  sec_shndx = in_shndx;
d2721 1
a2721 1
		    sec_shndx = os->out_shndx();
d2723 1
a2723 1
		    if (sec_shndx >= elfcpp::SHN_LORESERVE)
d2726 1
a2726 1
			  symtab_xindex->add(sym_index, sec_shndx);
d2728 2
a2729 2
			  dynsym_xindex->add(dynsym_index, sec_shndx);
			sec_shndx = elfcpp::SHN_XINDEX;
d2742 2
a2743 2
	  sec_shndx = sym->output_data()->out_shndx();
	  if (sec_shndx >= elfcpp::SHN_LORESERVE)
d2746 1
a2746 1
		symtab_xindex->add(sym_index, sec_shndx);
d2748 2
a2749 2
		dynsym_xindex->add(dynsym_index, sec_shndx);
	      sec_shndx = elfcpp::SHN_XINDEX;
d2754 1
a2754 1
	  sec_shndx = elfcpp::SHN_ABS;
d2758 1
a2758 1
	  sec_shndx = elfcpp::SHN_ABS;
d2762 1
a2762 1
	  sec_shndx = elfcpp::SHN_UNDEF;
d2774 1
a2774 1
	  this->sized_write_symbol<size, big_endian>(sym, sym_value, sec_shndx,
d2783 1
a2783 1
	  this->sized_write_symbol<size, big_endian>(sym, dynsym_value, sec_shndx,
d2800 2
a2801 2
    typename elfcpp::Elf_types<size>::Elf_Addr avalue,
    unsigned int sec_shndx,
d2807 1
a2807 1
  osym.put_st_value(avalue);
d2809 1
a2809 1
  if (sec_shndx == elfcpp::SHN_UNDEF && sym->is_from_dynobj())
d2824 1
a2824 1
  osym.put_st_shndx(sec_shndx);
d2923 2
a2924 2
  unsigned int sec_shndx = os->out_shndx();
  if (sec_shndx >= elfcpp::SHN_LORESERVE)
d2926 2
a2927 2
      symtab_xindex->add(os->symtab_index(), sec_shndx);
      sec_shndx = elfcpp::SHN_XINDEX;
d2929 1
a2929 1
  osym.put_st_shndx(sec_shndx);
d3032 1
a3032 1
Warnings::add_warning(Symbol_table* symtab, const char* aname, Object* obj,
d3035 2
a3036 2
  aname = symtab->canonicalize_name(aname);
  this->warnings_[aname].set(obj, warning);
d3256 1
a3256 1
    elfcpp::Elf_types<32>::Elf_Addr avalue);
d3265 1
a3265 1
    elfcpp::Elf_types<64>::Elf_Addr avalue);
@


1.130
log
@2009-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gold/10893
	* i386.cc (Target_i386::Scan::globa): Use is_func instead of
	checking elfcpp::STT_FUNC.
	(Target_i386::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Scan::global): Likewise.

	* symtab.cc (Symbol_table::sized_write_symbol): Turn IFUNC
	symbols from shared libraries into normal FUNC symbols.

	* symtab.h (Symbol): Add is_func and use it.
@
text
@d53 3
a55 3
Symbol::init_fields(const char* name, const char* version,
		    elfcpp::STT type, elfcpp::STB binding,
		    elfcpp::STV visibility, unsigned char nonvis)
d57 2
a58 2
  this->name_ = name;
  this->version_ = version;
d63 4
a66 4
  this->type_ = type;
  this->binding_ = binding;
  this->visibility_ = visibility;
  this->nonvis_ = nonvis;
d86 1
a86 1
demangle(const char* name)
d89 1
a89 1
    return name;
d93 1
a93 1
  char* demangled_name = cplus_demangle(name, DMGL_ANSI | DMGL_PARAMS);
d95 1
a95 1
    return name;
d112 1
a112 1
Symbol::init_base_object(const char* name, const char* version, Object* object,
d116 1
a116 1
  this->init_fields(name, version, sym.get_st_type(), sym.get_st_bind(),
d118 1
a118 1
  this->u_.from_object.object = object;
d122 3
a124 3
  this->in_reg_ = !object->is_dynamic();
  this->in_dyn_ = object->is_dynamic();
  this->in_real_elf_ = object->pluginobj() == NULL;
d131 4
a134 4
Symbol::init_base_output_data(const char* name, const char* version,
			      Output_data* od, elfcpp::STT type,
			      elfcpp::STB binding, elfcpp::STV visibility,
			      unsigned char nonvis, bool offset_is_from_end)
d136 1
a136 1
  this->init_fields(name, version, type, binding, visibility, nonvis);
d138 1
a138 1
  this->u_.in_output_data.offset_is_from_end = offset_is_from_end;
d148 5
a152 5
Symbol::init_base_output_segment(const char* name, const char* version,
				 Output_segment* os, elfcpp::STT type,
				 elfcpp::STB binding, elfcpp::STV visibility,
				 unsigned char nonvis,
				 Segment_offset_base offset_base)
d154 1
a154 1
  this->init_fields(name, version, type, binding, visibility, nonvis);
d156 1
a156 1
  this->u_.in_output_segment.offset_base = offset_base;
d166 3
a168 3
Symbol::init_base_constant(const char* name, const char* version,
			   elfcpp::STT type, elfcpp::STB binding,
			   elfcpp::STV visibility, unsigned char nonvis)
d170 1
a170 1
  this->init_fields(name, version, type, binding, visibility, nonvis);
d180 3
a182 3
Symbol::init_base_undefined(const char* name, const char* version,
			    elfcpp::STT type, elfcpp::STB binding,
			    elfcpp::STV visibility, unsigned char nonvis)
d184 1
a184 1
  this->init_fields(name, version, type, binding, visibility, nonvis);
d207 2
a208 2
Sized_symbol<size>::init_object(const char* name, const char* version,
				Object* object,
d212 1
a212 1
  this->init_base_object(name, version, object, sym, st_shndx, is_ordinary);
d222 12
a233 12
Sized_symbol<size>::init_output_data(const char* name, const char* version,
				     Output_data* od, Value_type value,
				     Size_type symsize, elfcpp::STT type,
				     elfcpp::STB binding,
				     elfcpp::STV visibility,
				     unsigned char nonvis,
				     bool offset_is_from_end)
{
  this->init_base_output_data(name, version, od, type, binding, visibility,
			      nonvis, offset_is_from_end);
  this->value_ = value;
  this->symsize_ = symsize;
d241 12
a252 12
Sized_symbol<size>::init_output_segment(const char* name, const char* version,
					Output_segment* os, Value_type value,
					Size_type symsize, elfcpp::STT type,
					elfcpp::STB binding,
					elfcpp::STV visibility,
					unsigned char nonvis,
					Segment_offset_base offset_base)
{
  this->init_base_output_segment(name, version, os, type, binding, visibility,
				 nonvis, offset_base);
  this->value_ = value;
  this->symsize_ = symsize;
d260 8
a267 8
Sized_symbol<size>::init_constant(const char* name, const char* version,
				  Value_type value, Size_type symsize,
				  elfcpp::STT type, elfcpp::STB binding,
				  elfcpp::STV visibility, unsigned char nonvis)
{
  this->init_base_constant(name, version, type, binding, visibility, nonvis);
  this->value_ = value;
  this->symsize_ = symsize;
d274 3
a276 3
Sized_symbol<size>::init_undefined(const char* name, const char* version,
				   elfcpp::STT type, elfcpp::STB binding,
				   elfcpp::STV visibility, unsigned char nonvis)
d278 1
a278 1
  this->init_base_undefined(name, version, type, binding, visibility, nonvis);
d286 1
a286 1
Symbol::is_common_shndx(unsigned int shndx)
d288 3
a290 3
  return (shndx == elfcpp::SHN_COMMON
	  || shndx == parameters->target().small_common_shndx()
	  || shndx == parameters->target().large_common_shndx());
d297 1
a297 1
Sized_symbol<size>::allocate_common(Output_data* od, Value_type value)
d300 1
a300 1
  this->value_ = value;
d326 3
a328 3
      unsigned int shndx = this->shndx(&is_ordinary);
      if (is_ordinary && shndx != elfcpp::SHN_UNDEF
          && !relobj->is_section_included(shndx))
d354 3
a356 3
      char* demangled_name = cplus_demangle(this->name(),
                                            DMGL_ANSI | DMGL_PARAMS);
      if (demangled_name == NULL)
d361 2
a362 2
               && (strprefix(demangled_name, "operator new")
                   || strprefix(demangled_name, "operator delete")))
d364 1
a364 1
          free(demangled_name);
d368 2
a369 2
               && (strprefix(demangled_name, "typeinfo name for")
                   || strprefix(demangled_name, "typeinfo for")))
d371 1
a371 1
          free(demangled_name);
d375 1
a375 1
        free(demangled_name);
d437 2
a438 2
	unsigned int shndx = this->u_.from_object.shndx;
	if (shndx != elfcpp::SHN_UNDEF && this->is_ordinary_shndx_)
d443 1
a443 1
	    return relobj->output_section(shndx);
d489 1
a489 1
                           const Version_script_info& version_script)
d493 1
a493 1
    version_script_(version_script), gc_(NULL), icf_(NULL)
d521 1
a521 1
Symbol_table::is_section_folded(Object* obj, unsigned int shndx) const
d524 1
a524 1
          && this->icf_->is_section_folded(obj, shndx));
d538 2
a539 2
      const char* name = p->c_str();
      Symbol* sym = this->lookup(name);
d546 1
a546 1
          unsigned int shndx = sym->shndx(&is_ordinary);
d550 1
a550 1
              this->gc_->worklist().push(Section_id(obj, shndx));
d565 2
a566 2
      unsigned int shndx = sym->shndx(&is_ordinary);
      if (is_ordinary && shndx != elfcpp::SHN_UNDEF)
d569 1
a569 1
          this->gc_->worklist().push(Section_id(obj, shndx));
d584 2
a585 2
      unsigned int shndx = sym->shndx(&is_ordinary);
      if (is_ordinary && shndx != elfcpp::SHN_UNDEF)
d588 1
a588 1
          this->gc_->worklist().push(Section_id(obj, shndx));
d619 1
a619 1
Symbol_table::lookup(const char* name, const char* version) const
d622 2
a623 2
  name = this->namepool_.find(name, &name_key);
  if (name == NULL)
d627 1
a627 1
  if (version != NULL)
d629 2
a630 2
      version = this->namepool_.find(version, &version_key);
      if (version == NULL)
d659 2
a660 2
  unsigned int shndx = from->shndx(&is_ordinary);
  this->resolve(to, esym.sym(), shndx, is_ordinary, shndx, from->object(),
d692 1
a692 1
Symbol_table::wrap_symbol(const char* name, Stringpool::Key* name_key)
d697 1
a697 1
  if (name[0] == parameters->target().wrap_char())
d699 2
a700 2
      prefix = name[0];
      ++name;
d703 1
a703 1
  if (parameters->options().is_wrap(name))
d710 1
a710 1
      s += name;
d720 2
a721 2
  if (strncmp(name, real_prefix, real_prefix_length) == 0
      && parameters->options().is_wrap(name + real_prefix_length))
d727 1
a727 1
      s += name + real_prefix_length;
d731 1
a731 1
  return name;
d842 2
a843 2
Symbol_table::add_from_object(Object* object,
			      const char *name,
d845 1
a845 1
			      const char *version,
d854 1
a854 1
  if (parameters->options().is_trace_symbol(name))
d857 1
a857 1
        gold_info(_("%s: reference to %s"), object->name().c_str(), name);
d859 1
a859 1
        gold_info(_("%s: definition of %s"), object->name().c_str(), name);
d867 2
a868 2
      const char* wrap_name = this->wrap_symbol(name, &name_key);
      if (wrap_name != name)
d875 1
a875 1
	  version = NULL;
d877 1
a877 1
	  name = wrap_name;
d913 2
a914 2
      this->resolve(ret, sym, st_shndx, is_ordinary, orig_st_shndx, object,
		    version);
d936 2
a937 2
	  this->resolve(ret, sym, st_shndx, is_ordinary, orig_st_shndx, object,
			version);
d971 1
a971 1
	  ret->init_object(name, version, object, sym, st_shndx, is_ordinary);
d1058 1
a1058 1
      const char* name = sym_names + st_name;
d1081 1
a1081 1
      const char* ver = strchr(name, '@@');
d1091 1
a1091 1
          namelen = ver - name;
d1105 1
a1105 1
	  namelen = strlen(name);
d1111 2
a1112 2
	      std::string version;
	      if (this->version_script_.get_symbol_version(name, &version))
d1116 1
a1116 1
		  if (!version.empty())
d1118 2
a1119 2
		      ver = this->namepool_.add_with_length(version.c_str(),
							    version.length(),
d1125 1
a1125 1
	      else if (this->version_script_.symbol_is_local(name))
d1174 1
a1174 1
      name = this->namepool_.add_with_length(name, namelen, true,
d1178 1
a1178 1
      res = this->add_from_object(relobj, name, name_key, ver, ver_key,
d1201 1
a1201 1
    const char* name,
d1226 2
a1227 2
          std::string version;
          if (this->version_script_.get_symbol_version(name, &version))
d1231 1
a1231 1
              if (!version.empty())
d1233 2
a1234 2
                  ver = this->namepool_.add_with_length(version.c_str(),
                                                        version.length(),
d1240 1
a1240 1
          else if (this->version_script_.symbol_is_local(name))
d1246 1
a1246 1
  name = this->namepool_.add(name, true, &name_key);
d1249 1
a1249 1
  res = this->add_from_object(obj, name, name_key, ver, ver_key,
d1340 1
a1340 1
      const char* name = sym_names + st_name;
d1354 2
a1355 2
	  name = this->namepool_.add(name, true, &name_key);
	  res = this->add_from_object(dynobj, name, name_key, NULL, 0,
d1384 1
a1384 1
	  name = this->namepool_.add(name, true, &name_key);
d1390 1
a1390 1
	      res = this->add_from_object(dynobj, name, name_key, NULL, 0,
d1403 2
a1404 2
	      const char* version = (*version_map)[v];
	      if (version == NULL)
d1412 1
a1412 1
	      version = this->namepool_.add(version, true, &version_key);
d1422 1
a1422 1
		res = this->add_from_object(dynobj, name, name_key, NULL, 0,
d1429 1
a1429 1
		  res = this->add_from_object(dynobj, name, name_key, version,
d1687 2
a1688 2
Symbol_table::define_in_output_data(const char* name,
				    const char* version,
d1690 2
a1691 2
				    uint64_t value,
				    uint64_t symsize,
d1696 1
a1696 1
				    bool offset_is_from_end,
d1702 2
a1703 2
      return this->do_define_in_output_data<32>(name, version, od,
                                                value, symsize, type, binding,
d1705 1
a1705 1
                                                offset_is_from_end,
d1714 2
a1715 2
      return this->do_define_in_output_data<64>(name, version, od,
                                                value, symsize, type, binding,
d1717 1
a1717 1
                                                offset_is_from_end,
d1732 2
a1733 2
    const char* name,
    const char* version,
d1735 2
a1736 2
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    typename elfcpp::Elf_types<size>::Elf_WXword symsize,
d1741 1
a1741 1
    bool offset_is_from_end,
d1751 1
a1751 1
      sym = this->define_special_symbol<size, true>(&name, &version,
d1761 1
a1761 1
      sym = this->define_special_symbol<size, false>(&name, &version,
d1772 2
a1773 2
  sym->init_output_data(name, version, od, value, symsize, type, binding,
			visibility, nonvis, offset_is_from_end);
d1778 1
a1778 1
	  || this->version_script_.symbol_is_local(name))
d1780 1
a1780 1
      else if (version != NULL)
d1800 4
a1803 4
Symbol_table::define_in_output_segment(const char* name,
				       const char* version, Output_segment* os,
				       uint64_t value,
				       uint64_t symsize,
d1808 1
a1808 1
				       Symbol::Segment_offset_base offset_base,
d1814 2
a1815 2
      return this->do_define_in_output_segment<32>(name, version, os,
                                                   value, symsize, type,
d1817 1
a1817 1
                                                   offset_base, only_if_ref);
d1825 2
a1826 2
      return this->do_define_in_output_segment<64>(name, version, os,
                                                   value, symsize, type,
d1828 1
a1828 1
                                                   offset_base, only_if_ref);
d1842 2
a1843 2
    const char* name,
    const char* version,
d1845 2
a1846 2
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    typename elfcpp::Elf_types<size>::Elf_WXword symsize,
d1851 1
a1851 1
    Symbol::Segment_offset_base offset_base,
d1861 1
a1861 1
      sym = this->define_special_symbol<size, true>(&name, &version,
d1871 1
a1871 1
      sym = this->define_special_symbol<size, false>(&name, &version,
d1882 2
a1883 2
  sym->init_output_segment(name, version, os, value, symsize, type, binding,
			   visibility, nonvis, offset_base);
d1888 1
a1888 1
	  || this->version_script_.symbol_is_local(name))
d1890 1
a1890 1
      else if (version != NULL)
d1911 4
a1914 4
Symbol_table::define_as_constant(const char* name,
				 const char* version,
				 uint64_t value,
				 uint64_t symsize,
d1925 2
a1926 2
      return this->do_define_as_constant<32>(name, version, value,
                                             symsize, type, binding,
d1936 2
a1937 2
      return this->do_define_as_constant<64>(name, version, value,
                                             symsize, type, binding,
d1953 4
a1956 4
    const char* name,
    const char* version,
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    typename elfcpp::Elf_types<size>::Elf_WXword symsize,
d1971 1
a1971 1
      sym = this->define_special_symbol<size, true>(&name, &version,
d1981 1
a1981 1
      sym = this->define_special_symbol<size, false>(&name, &version,
d1992 1
a1992 1
  sym->init_constant(name, version, value, symsize, type, binding, visibility,
d1999 3
a2001 3
      if ((version == NULL
	   || name != version
	   || value != 0)
d2003 1
a2003 1
	      || this->version_script_.symbol_is_local(name)))
d2005 2
a2006 2
      else if (version != NULL
	       && (name != version || value != 0))
d2082 1
a2082 1
    typename elfcpp::Elf_types<size>::Elf_Addr value)
d2086 3
a2088 3
  Object* object = csym->object();
  gold_assert(object->is_dynamic());
  Dynobj* dynobj = static_cast<Dynobj*>(object);
d2097 1
a2097 1
			      posd, value, csym->symsize(),
d2175 1
a2175 1
      const char* name = p->c_str();
d2177 1
a2177 1
      if (this->lookup(name) != NULL)
d2180 1
a2180 1
      const char* version = NULL;
d2188 1
a2188 1
	  sym = this->define_special_symbol<size, true>(&name, &version,
d2198 1
a2198 1
	  sym = this->define_special_symbol<size, false>(&name, &version,
d2208 1
a2208 1
      sym->init_undefined(name, version, elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
d2378 1
a2378 1
  Value_type value;
d2385 1
a2385 1
	unsigned int shndx = sym->shndx(&is_ordinary);
d2388 2
a2389 2
	    && shndx != elfcpp::SHN_ABS
	    && !Symbol::is_common_shndx(shndx))
d2398 2
a2399 2
	    value = 0;
	    shndx = elfcpp::SHN_UNDEF;
d2403 2
a2404 2
	    value = 0;
	    shndx = elfcpp::SHN_UNDEF;
d2406 2
a2407 2
	else if (shndx == elfcpp::SHN_UNDEF)
	  value = 0;
d2409 3
a2411 3
		 && (shndx == elfcpp::SHN_ABS
		     || Symbol::is_common_shndx(shndx)))
	  value = sym->value();
d2415 2
a2416 2
	    Output_section* os = relobj->output_section(shndx);
            uint64_t secoff64 = relobj->output_section_offset(shndx);
d2418 1
a2418 1
            if (this->is_section_folded(relobj, shndx))
d2423 1
a2423 1
                                                                   shndx);
d2445 1
a2445 1
	        value = os->output_address(relobj, shndx, sym->value());
d2452 1
a2452 1
	          value = sym->value() + os->tls_offset() + secoff;
d2454 1
a2454 1
	          value = sym->value() + os->address() + secoff;
d2463 1
a2463 1
	value = sym->value();
d2465 1
a2465 1
	  value += od->address();
d2470 1
a2470 1
	    value += os->tls_offset() + (od->address() - os->address());
d2473 1
a2473 1
	  value += od->data_size();
d2480 1
a2480 1
	value = sym->value();
d2482 1
a2482 1
	  value += os->vaddr();
d2488 1
a2488 1
	    value += os->memsz();
d2491 1
a2491 1
	    value += os->filesz();
d2500 1
a2500 1
      value = sym->value();
d2504 1
a2504 1
      value = 0;
d2512 1
a2512 1
  return value;
d2541 1
a2541 1
  Value_type value = this->compute_final_value(sym, &status);
d2550 1
a2550 1
	unsigned int shndx = sym->shndx(&is_ordinary);
d2552 1
a2552 1
		   sym->demangled_name().c_str(), shndx);
d2562 1
a2562 1
  sym->set_value(value);
d2669 1
a2669 1
      unsigned int shndx;
d2685 1
a2685 1
		shndx = in_shndx;
d2694 1
a2694 1
		    shndx = elfcpp::SHN_UNDEF;
d2697 1
a2697 1
		  shndx = elfcpp::SHN_UNDEF;
d2702 1
a2702 1
		  shndx = in_shndx;
d2721 1
a2721 1
		    shndx = os->out_shndx();
d2723 1
a2723 1
		    if (shndx >= elfcpp::SHN_LORESERVE)
d2726 1
a2726 1
			  symtab_xindex->add(sym_index, shndx);
d2728 2
a2729 2
			  dynsym_xindex->add(dynsym_index, shndx);
			shndx = elfcpp::SHN_XINDEX;
d2742 2
a2743 2
	  shndx = sym->output_data()->out_shndx();
	  if (shndx >= elfcpp::SHN_LORESERVE)
d2746 1
a2746 1
		symtab_xindex->add(sym_index, shndx);
d2748 2
a2749 2
		dynsym_xindex->add(dynsym_index, shndx);
	      shndx = elfcpp::SHN_XINDEX;
d2754 1
a2754 1
	  shndx = elfcpp::SHN_ABS;
d2758 1
a2758 1
	  shndx = elfcpp::SHN_ABS;
d2762 1
a2762 1
	  shndx = elfcpp::SHN_UNDEF;
d2774 1
a2774 1
	  this->sized_write_symbol<size, big_endian>(sym, sym_value, shndx,
d2783 1
a2783 1
	  this->sized_write_symbol<size, big_endian>(sym, dynsym_value, shndx,
d2800 2
a2801 2
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    unsigned int shndx,
d2807 1
a2807 1
  osym.put_st_value(value);
d2809 1
a2809 1
  if (shndx == elfcpp::SHN_UNDEF && sym->is_from_dynobj())
d2824 1
a2824 1
  osym.put_st_shndx(shndx);
d2923 2
a2924 2
  unsigned int shndx = os->out_shndx();
  if (shndx >= elfcpp::SHN_LORESERVE)
d2926 2
a2927 2
      symtab_xindex->add(os->symtab_index(), shndx);
      shndx = elfcpp::SHN_XINDEX;
d2929 1
a2929 1
  osym.put_st_shndx(shndx);
d3032 1
a3032 1
Warnings::add_warning(Symbol_table* symtab, const char* name, Object* obj,
d3035 2
a3036 2
  name = symtab->canonicalize_name(name);
  this->warnings_[name].set(obj, warning);
d3256 1
a3256 1
    elfcpp::Elf_types<32>::Elf_Addr value);
d3265 1
a3265 1
    elfcpp::Elf_types<64>::Elf_Addr value);
@


1.129
log
@2009-12-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* resolve.cc (symbol_to_bits): Treat STB_GNU_UNIQUE as STB_GLOBAL.
	(Symbol_table::override_with_special): Likewise.
	(Symbol_table::add_from_object): Likewise.
@
text
@d2813 5
d2820 1
a2820 1
    osym.put_st_info(elfcpp::elf_st_info(elfcpp::STB_LOCAL, sym->type()));
d2822 1
a2822 1
    osym.put_st_info(elfcpp::elf_st_info(sym->binding(), sym->type()));
@


1.128
log
@	PR 10880
	* object.h (class Object): Add is_needed and set_is_needed
	methods.  Add is_needed_ field.  Make bool fields into bitfields.
	* symtab.cc (Symbol_table::set_dynsym_indexes): If a symbol is
	defined in a dynamic object and referenced by a regular object,
	set is_needed for the dynamic object.
	* layout.cc (Layout::finish_dynamic_section): Don't add DT_NEEDED
	if the file is marked with as_needed and it is not needed.
@
text
@d1013 1
@


1.127
log
@	* symtab.cc (add_from_pluginobj): Pass correct value for is_ordinary.
	* testsuite/Makefile.am (plugin_test_5): New test case.
	* testsuite/Makefile.in: Regenerate.
@
text
@d2246 6
@


1.126
log
@	Add support for -pie.
	* options.h (class General_options): Add -pie and
	--pic-executable.
	(General_options::output_is_position_independent): Test -pie.
	(General_options::output_is_executable): Return true if not shared
	and not relocatable.
	(General_options::output_is_pie): Remove.
	* options.cc (General_options::finalize): Reject incompatible uses
	of -pie.
	* gold.cc (queue_middle_tasks): A -pie link is not static.
	* symtab.h (Symbol::needs_plt_entry): Return false if -pie.
	* symtab.cc (Symbol::final_value_is_known): Return false if
	output_is_position_independent.
	* layout.cc (Layout::set_segment_offsets): Start at address 0 if
	output_is_position_independent.
	* output.cc (Output_file_header::do_sized_write): Use ET_DYN if
	output_is_position_independent.
	* i386.cc (Output_data_plt_i386::do_write): Use the PIC PLT if
	output_is_position_independent.
	* testsuite/Makefile.am (check_PROGRAMS): Add basic_pie_test and
	two_file_pie_test.
	(basic_pie_test.o, basic_pie_test): New targets.
	(two_file_test_1_pie.o, two_file_test_1b_pie.o): New targets.
	(two_file_test_2_pie.o, two_file_test_main_pie.o): New targets.
	(two_file_pie_test): New target.
	* testsuite/Makefile.in: Rebuild.
	* README: Remove note saying that -pie is not supported.
@
text
@d1205 1
d1249 1
a1249 1
		              def, *sym, st_shndx, true, st_shndx);
@


1.125
log
@	* gc.h (gc_process_relocs): Check if icf is enabled using new
	function.
	* gold.cc (queue_initial_tasks): Likewise.
	(queue_middle_tasks): Likewise.
	* object.cc (do_layout): Likewise.
	* symtab.cc (is_section_folded): Likewise.
	* main.cc (main): Likewise.
	* reloc.cc (Read_relocs::run): Likewise.
	(Sized_relobj::do_scan_relocs): Likewise.
	* icf.cc (is_function_ctor_or_dtor): New function.
	(Icf::find_identical_sections): Check if function is ctor or dtor when
	safe icf is chosen.
	* options.h (General_options::icf): Change option to be an enum.
	(Icf_status): New enum.
	(icf_enabled): New method.
	(icf_safe_folding): New method.
	(set_icf_status): New method.
	(icf_status_): New variable.
	* (options.cc) (General_options::finalize): Set icf_status_.
	* testsuite/Makefile.am: Add commands to build icf_safe_test. Modify
	icf_test and icf_keep_unique_test to use the --icf enum flag.
	* testsuite/icf_safe_test.sh: New file.
	* testsuite/icf_safe_test.cc: New file.
@
text
@d397 2
a398 1
  if (parameters->options().shared() || parameters->options().relocatable())
@


1.124
log
@2009-10-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::make_output_section): Call target hook to make
	ordinary output section.
	(Layout::finalize): Adjust parameter list of call the
	Target::may_relax().
	* layout.h (class Layout::section_list): New method.
	* merge.h (Output_merge_base::entsize): Change visibility to public.
	(Output_merge_base::is_string, Output_merge_base::do_is_string):
	New methods.
	(Output_merge_string::do_is_string): New method.
	* object.cc (Sized_relobj::do_setup): renamed from
	Sized_relobj::set_up.
	* object.h (Sized_relobj::adjust_shndx,
	Sized_relobj::initializ_input_to_output_maps,
	Sized_relobj::free_input_to_output_maps): Change visibilities to
	protected.
	(Sized_relobj::setup): Virtualize.
	(Sized_relobj::do_setup): New method declaration.
	(Sized_relobj::invalidate_section_offset,
	Sized_relobj::do_invalidate_section_offset): New method decfinitions.
	(Sized_relobj::elf_file, Sized_relobj::local_values): New methods.
	* options.cc (parse_int): New function.
	* options.h (parse_int): New declaration.
	(DEFINE_int): New macro.
	(stub_group_size): New option.
	* output.cc (Output_section::Output_section): Initialize memebers
	merge_section_map_, merge_section_by_properties_map_,
	relaxed_input_section_map_, is_relaxed_input_section_map_valid_.
	(Output_section::add_input_section): Handled deferred code-fill
	generation and remove an old comment.
	(Output_section::add_relaxed_input_section): New method definition.
	(Output_section::add_merge_input_section): Use merge section by
	properties map to speed to search.  Update merge section maps
	as appropriate.
	(Output_section::build_relaxation_map): New method definition.
	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Same.
	(Output_section::relax_input_section): Renamed to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of pointers to relaxed sections.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section): New method definitions.
	(Output_section::is_input_address_mapped,
	Output_section::output_offset, Output_section::output_address):
	Use output section data maps to speed up searching.
	(Output_section::find_starting_output_address): Add comments.
	(Output_section::do_write,
	Output_section::write_to_postprocessing_buffer): Do code-fill
	generation as appropriate.
	(Output_section::get_input_sections): Invalidate relaxed input section
	map.
	(Output_section::restore_states): Adjust type of checkpoint .
	Invalidate relaxed input section map.
	* output.h (Output_merge_base): New class declaration.
	(Input_section_specifier): New class defintion.
	(class Output_relaxed_input_section) Change base class to
	Output_section_data_build.
	(Output_relaxed_input_section::Output_relaxed_input_section): Adjust
	base class initializer.
	(Output_section::add_relaxed_input_section): New method declaration.
	(Output_section::Input_section): Change visibility to protected.
     	(Output_section::Input_section::relobj,
	Output_section::Input_section::shndx): Handle relaxed input sections.
	Output_section::input_sections) Change visibility to protected.  Also
	define overload to return a non-const pointer.
	(Output_section::Merge_section_properties): New class defintion.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Relaxation_map): New types.
	(Output_section::relax_input_section): Rename method to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of relaxed section pointers.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section,
	Output_section::build_relaxation_map,
	Output_section::convert_input_sections_in_list_to_relaxed_sections):
	New method declarations.
	(Output_section::merge_section_map_
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_,
	Output_section::generate_code_fills_at_write_): New data members.
	* script-sections.cc
	(Output_section_element_input::set_section_addresses): Call
	current_data_size and addralign methods of relaxed input sections.
	(Orphan_output_section::set_section_addresses): Call current_data_size
	and addralign methods of relaxed input sections.
	* symtab.cc (Symbol_table::compute_final_value): Extract template
	from the body of Symbol_table::sized_finalize_symbol.
	(Symbol_table::sized_finalized_symbol): Call
	Symbol_table::compute_final_value.
	* symtab.h (Symbol_table::Compute_final_value_status): New enum type.
	(Symbol_table::compute_final_value): New templated method declaration.
	* target.cc (Target::do_make_output_section): New method defintion.
	* target.h (Target::make_output_section): New method declaration.
	(Target::relax): Add more parameters for input objects, symbol table
	and layout.  Adjust call to do_relax.
	(Target::do_make_output_section): New method declaration.
	(Target::do_relax): Add parameters for input objects, symbol table
	and layout.
@
text
@d522 1
a522 1
  return (parameters->options().icf()
@


1.123
log
@	* object.h (class Object): Remove target_ field, and target,
	sized_target, and set_target methods.
	(Object::sized_target): Remove.
	(class Sized_relobj): Update declarations.  Remove sized_target.
	* object.cc (Sized_relobj::setup): Remove target parameter.
	Change all callers.
	(Input_objects::add_object): Don't do anything with the target.
	(make_elf_sized_object): Add punconfigured parameter.  Change all
	callers.  Set or test parameter target.
	* dynobj.cc (Sized_dynobj::target): Remove target parameter.
	Change all callers.
	* parameters.cc (Parameters::set_target): Change parameter type to
	be non-const.
	(Parameters::default_target): Remove.
	(set_parameters_target): Change parameter type to be non-const.
	(parameters_force_valid_target): New function.
	(parameters_clear_target): New function.
	* parameters.h (class Parameters): Update declarations.  Remove
	default_target method.  Add sized_target and clear_target
	methods.  Change target_ to be non-const.
	(set_parameters_target): Update declaration.
	(parameters_force_valid_target): Declare.
	(parameters_clear_target): Declare.
	* readsyms.cc (Read_symbols::do_read_symbols): Pass punconfigured
	as NULL if we aren't searching.
	(Add_symbols::run): Don't check for compatible target.
	* fileread.cc (Input_file::open_binary): Call
	parameters_force_valid_target.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (make_sized_plugin_object): Likewise.  Don't call
	set_target on object.
	* dynobj.h (class Sized_dynobj): Update declarations.
	* archive.cc (Archive::get_elf_object_for_member): Return NULL if
	make_elf_object returns NULL.
	(Archive::include_member): Don't check whether object target is
	compatible.
	* output.cc (Output_section::add_input_section): Get target from
	parameters.
	(Output_section::relax_input_section): Likewise.
	* reloc.cc (Sized_relobj::do_gc_process_relocs): Get target from
	parameters.
	(Sized_relobj::do_scan_relocs): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* symtab.cc (Symbol_table::wrap_symbol): Likewise.  Remove object
	parameter.  Change all callers.
	(Symbol_table::add_from_object): Get target from parameters.
	(Symbol_table::add_from_relobj): Don't check object target.
	(Symbol_table::add_from_dynobj): Likewise.
	(Symbol_table::define_special_symbol): Get target from
	parameters.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/binary_unittest.cc (gold_testsuite): Remove target
	parameter.  Change all callers.  Clear parameter target.
	(Binary_test): Test target here.
	* testsuite/object_unittest.cc (gold_testsuite): Remove
	target_test_pointer parameter.  Change all callers.
	(Object_test): Test target here.
@
text
@d2358 3
a2360 2
// Finalize the symbol SYM.  This returns true if the symbol should be
// added to the symbol table, false otherwise.
d2363 4
a2366 2
bool
Symbol_table::sized_finalize_symbol(Symbol* unsized_sym)
a2368 16

  Sized_symbol<size>* sym = static_cast<Sized_symbol<size>*>(unsized_sym);

  // The default version of a symbol may appear twice in the symbol
  // table.  We only need to finalize it once.
  if (sym->has_symtab_index())
    return false;

  if (!sym->in_reg())
    {
      gold_assert(!sym->has_symtab_index());
      sym->set_symtab_index(-1U);
      gold_assert(sym->dynsym_index() == -1U);
      return false;
    }

d2382 2
a2383 3
	    gold_error(_("%s: unsupported symbol section 0x%x"),
		       sym->demangled_name().c_str(), shndx);
	    shndx = elfcpp::SHN_UNDEF;
a2423 1
		sym->set_symtab_index(-1U);
d2428 2
a2429 1
		return false;
d2502 51
@


1.122
log
@	* object.cc (Sized_relobj::do_count): Test should_retain_symbol map.
	* options.cc: Include <cerrno> and <fstream>.
	(General_options::finalize): Parse -retain-symbols-file tag.
	* options.h: New flag.
	(General_options): New method should_retain_symbol, new
	variable symbols_to_retain.
	* symtab.cc (Symbol_table::sized_finalize_symbol): Test
	should_retain_symbol map.
	* testsuite/Makefile.am (retain_symbols_file_test): New test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/retain_symbols_file_test.sh: New file.
@
text
@d691 1
a691 2
Symbol_table::wrap_symbol(Object* object, const char* name,
			  Stringpool::Key* name_key)
d696 1
a696 1
  if (name[0] == object->target()->wrap_char())
d866 1
a866 1
      const char* wrap_name = this->wrap_symbol(object, name, &name_key);
d947 1
a947 1
	    object->sized_target<size, big_endian>();
a1034 1
  gold_assert(size == relobj->target()->get_size());
a1272 1
  gold_assert(size == dynobj->target()->get_size());
d1661 2
a1662 5
      gold_assert(target.get_size() == size);
      gold_assert(target.is_big_endian() ? big_endian : !big_endian);
      typedef Sized_target<size, big_endian> My_target;
      const My_target* sized_target =
          static_cast<const My_target*>(&target);
@


1.121
log
@*** empty log message ***
@
text
@d2524 2
a2525 1
  if (parameters->options().strip_all())
@


1.121.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@d397 1
a397 2
  if (parameters->options().output_is_position_independent()
      || parameters->options().relocatable())
d522 1
a522 1
  return (parameters->options().icf_enabled()
d691 2
a692 1
Symbol_table::wrap_symbol(const char* name, Stringpool::Key* name_key)
d697 1
a697 1
  if (name[0] == parameters->target().wrap_char())
d867 1
a867 1
      const char* wrap_name = this->wrap_symbol(name, &name_key);
d948 1
a948 1
	    parameters->sized_target<size, big_endian>();
d1036 1
d1275 1
d1664 5
a1668 2
      Sized_target<size, big_endian>* sized_target =
	parameters->sized_target<size, big_endian>();
d2364 2
a2365 3
// Compute the final value of SYM and store status in location PSTATUS.
// During relaxation, this may be called multiple times for a symbol to
// compute its would-be final value in each relaxation pass.
d2368 2
a2369 4
typename Sized_symbol<size>::Value_type
Symbol_table::compute_final_value(
    const Sized_symbol<size>* sym,
    Compute_final_value_status* pstatus) const
d2372 16
d2401 3
a2403 2
	    *pstatus = CFVS_UNSUPPORTED_SYMBOL_SECTION;
	    return 0;
d2444 1
d2449 1
a2449 2
		*pstatus = CFVS_NO_OUTPUT_SECTION;
		return 0;
a2521 51
  *pstatus = CFVS_OK;
  return value;
}

// Finalize the symbol SYM.  This returns true if the symbol should be
// added to the symbol table, false otherwise.

template<int size>
bool
Symbol_table::sized_finalize_symbol(Symbol* unsized_sym)
{
  typedef typename Sized_symbol<size>::Value_type Value_type;

  Sized_symbol<size>* sym = static_cast<Sized_symbol<size>*>(unsized_sym);

  // The default version of a symbol may appear twice in the symbol
  // table.  We only need to finalize it once.
  if (sym->has_symtab_index())
    return false;

  if (!sym->in_reg())
    {
      gold_assert(!sym->has_symtab_index());
      sym->set_symtab_index(-1U);
      gold_assert(sym->dynsym_index() == -1U);
      return false;
    }

  // Compute final symbol value.
  Compute_final_value_status status;
  Value_type value = this->compute_final_value(sym, &status);

  switch (status)
    {
    case CFVS_OK:
      break;
    case CFVS_UNSUPPORTED_SYMBOL_SECTION:
      {
	bool is_ordinary;
	unsigned int shndx = sym->shndx(&is_ordinary);
	gold_error(_("%s: unsupported symbol section 0x%x"),
		   sym->demangled_name().c_str(), shndx);
      }
      break;
    case CFVS_NO_OUTPUT_SECTION:
      sym->set_symtab_index(-1U);
      return false;
    default:
      gold_unreachable();
    }

d2524 1
a2524 2
  if (parameters->options().strip_all()
      || !parameters->options().should_retain_symbol(sym->name()))
@


1.121.2.2
log
@	PR 10880
	* object.h (class Object): Add is_needed and set_is_needed
	methods.  Add is_needed_ field.  Make bool fields into bitfields.
	* symtab.cc (Symbol_table::set_dynsym_indexes): If a symbol is
	defined in a dynamic object and referenced by a regular object,
	set is_needed for the dynamic object.
	* layout.cc (Layout::finish_dynamic_section): Don't add DT_NEEDED
	if the file is marked with as_needed and it is not needed.
@
text
@a2244 6

	  // If the symbol is defined in a dynamic object and is
	  // referenced in a regular object, then mark the dynamic
	  // object as needed.  This is used to implement --as-needed.
	  if (sym->is_from_dynobj() && sym->in_reg())
	    sym->object()->set_is_needed();
@


1.120
log
@	* layout.cc (Layout::make_output_section): Call
	Target::new_output_section.
	(Layout::attach_allocated_section_to_segment): Put large section
	sections in a separate load segment with the large segment flag
	set.
	(Layout::segment_precedes): Sort large data segments after other
	load segments.
	(align_file_offset): New static function.
	(Layout::set_segment_offsets): Use align_file_offset.
	* output.h (class Output_section): Add is_small_section_ and
	is_large_section_ fields.
	(Output_section::is_small_section): New function.
	(Output_section::set_is_small_section):  New function.
	(Output_section::is_large_section): New function.
	(Output_section::set_is_large_section): New function.
	(Output_section::is_large_data_section): New function.
	(class Output_segment): Add is_large_data_segment_ field.
	(Output_segment::is_large_data_segment): New function.
	(Output_segment::set_is_large_data_segment): New function.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_segment::Output_segment): Likewise.
	(Output_segment::add_output_section): Add assertion that large
	data sections always go in large data segments.  Force small data
	sections to the end of the list of data sections.  Force small BSS
	sections to the start of the list of BSS sections.  For large BSS
	sections to the end of the list of BSS sections.
	* symtab.h (class Symbol): Declare is_common_shndx.
	(Symbol::is_defined): Check Symbol::is_common_shndx.
	(Symbol::is_common): Likewise.
	(class Symbol_table): Define enum Commons_section_type.  Update
	declarations.  Add small_commons_ and large_commons_ fields.
	* symtab.cc (Symbol::is_common_shndx): New function.
	(Symbol_table::Symbol_table): Initialize new fields.
	(Symbol_table::add_from_object): Put small and large common
	symbols in the right list.
	(Symbol_table::sized_finalized_symbol): Check
	Symbol::is_common_shndx.
	(Symbol_table::sized_write_globals): Likewise.
	* common.cc (Symbol_table::do_allocate_commons): Allocate new
	common symbol lists.  Don't call do_allocate_commons_list if the
	list is empty.
	(Symbol_table::do_allocate_commons_list): Remove is_tls
	parameter.  Add comons_section_type parameter.  Change all
	callers.  Handle small and large common symbols.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Check
	Symbol::is_common_shndx.
	* resolve.cc (symbol_to_bits): Likewise.
	* target.h (Target::small_common_shndx): New function.
	(Target::small_common_section_flags): New function.
	(Target::large_common_shndx): New function.
	(Target::large_common_section_flags): New function.
	(Target::new_output_section): New function.
	(Target::Target_info): Add small_common_shndx, large_common_shndx,
	small_common_section_flags, and large_common_section_flags
	fields.
	(Target::do_new_output_section): New virtual function.
	* arm.cc (Target_arm::arm_info): Initialize new fields.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Likewise.
	* sparc.c (Target_sparc::sparc_info) [all versions]: Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	(Target_x86_64::do_new_output_section): New function.
	* configure.ac: Define conditional MCMODEL_MEDIUM.
	* testsuite/Makefile.am (check_PROGRAMS): Add large.
	(large_SOURCES, large_CFLAGS, large_DEPENDENCIES): Define.
	(large_LDFLAGS): Define.
	* testsuite/large.c: New file.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Initialize new fields.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d492 1
a492 1
    version_script_(version_script), gc_(NULL)
d519 7
d2427 1
d2429 14
a2442 1
	    if (os == NULL)
a2451 1
            uint64_t secoff64 = relobj->output_section_offset(shndx);
d2455 1
d2666 13
@


1.119
log
@2009-05-19  Doug Kwan  <dougkwan@@google.com>

	* archive.cc (Archive::Archive): Move constructor from archive.h
	to here.  Initialize no_export_.
	(Archive::get_elf_object_for_member): Set no_export flag of object.
	* archive.h (Archive::Archive): Move constructor body to
	archive.cc.
	(Archive::no_export): New method.
	(Archive::no_export_): New field.
	* object.h (Object::Object): Initialize no_export_ to false.
	(Object::no_export, Object::set_no_export): New methods.
	(Object::no_export_): New field.
	* options.cc (General_options::parse_exclude_libs): New method.
	(General_options::check_excluded_libs) Same.
	* options.h (exclude_libs): New option.
	(General_options::check_excluded_libs): New method declaration.
	(General_options::excluded_libs_): New field.
	* symtab.cc (Symbol_table::add_from_relobj): Hide symbols with
	default or protected visibility if an object has no-export flag set.
	testsuite/Makefile.am (check_PROGRAMS): Add exclude_libs_test.
	(check_SCRIPTS): Add exclude_libs_test.sh.
	(check_DATA): Add exclude_libs_test.syms.
	(MOSTLYCLEANFILES): Add exclude_libs_test.syms,
	libexclude_libs_test_1.a and libexclude_libs_test_2.a.
	(exclude_libs_test_SOURCES, exclude_libs_test_DEPENDENCIES,
	exclude_libs_test_LDFLAGS and exclude_libs_test_LDADD): Define.
	(exclude_libs_test.syms, libexclude_libs_test_1.a,
	libexclude_libs_test_2.a): New rules.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/exclude_libs_test.c: New file.
	* testsuite/exclude_libs_test.sh: Ditto.
	* testsuite/exclude_libs_test_1.c: Ditto.
	* testsuite/exclude_libs_test_2.c: Ditto.
@
text
@d283 10
d490 2
a491 1
    forwarders_(), commons_(), tls_commons_(), forced_locals_(), warnings_(),
d989 9
a997 1
      if (ret->type() != elfcpp::STT_TLS)
a998 2
      else
	this->tls_commons_.push_back(ret);
a2389 1
	// FIXME: We need some target specific support here.
d2392 1
a2392 1
	    && shndx != elfcpp::SHN_COMMON)
d2413 2
a2414 1
		 && (shndx == elfcpp::SHN_ABS || shndx == elfcpp::SHN_COMMON))
a2616 1
	    // FIXME: We need some target specific support here.
d2619 1
a2619 1
		&& in_shndx != elfcpp::SHN_COMMON)
d2639 1
a2639 1
				 || in_shndx == elfcpp::SHN_COMMON)))
@


1.118
log
@	* symtab.cc (Symbol_table::define_default_version): New function,
	broken out of add_from_object.
	(Symbol_table::add_from_object): Call define_default_version.
	(Symbol_table::define_special_symbol): Add resolve_oldsym
	parameter.  Change all callers.  If the version for a symbol comes
	from a version script, resolve it with the symbol with the same
	name with no version.  Also add the symbol without a version if
	appropriate.
	(do_define_in_output_data): If resolving with oldsym, don't delete
	sym.
	(do_define_in_output_segment): Likewise.
	(do_define_as_constant): Likewise.
	* symtab.h (class Symbol_table): Update declarations.
@
text
@d1129 20
@


1.117
log
@	PR 6992
	* symtab.cc (Symbol_table::sized_write_section_symbol): In a
	relocatable link set the value of the section symbol to zero.
	* object.cc (Sized_relobj::do_finalize_local_symbols): In a
	relocatable link don't include the section address in the local
	symbol value.
@
text
@d716 76
d901 2
a902 63
	{
	  if (insdef.second)
	    {
	      // This is the first time we have seen NAME/NULL.  Make
	      // NAME/NULL point to NAME/VERSION.
	      insdef.first->second = ret;
	    }
	  else if (insdef.first->second != ret)
	    {
	      // This is the unfortunate case where we already have
	      // entries for both NAME/VERSION and NAME/NULL.  We now
	      // see a symbol NAME/VERSION where VERSION is the
	      // default version.  We have already resolved this new
	      // symbol with the existing NAME/VERSION symbol.

	      // It's possible that NAME/NULL and NAME/VERSION are
	      // both defined in regular objects.  This can only
	      // happen if one object file defines foo and another
	      // defines foo@@@@ver.  This is somewhat obscure, but we
	      // call it a multiple definition error.

	      // It's possible that NAME/NULL actually has a version,
	      // in which case it won't be the same as VERSION.  This
	      // happens with ver_test_7.so in the testsuite for the
	      // symbol t2_2.  We see t2_2@@@@VER2, so we define both
	      // t2_2/VER2 and t2_2/NULL.  We then see an unadorned
	      // t2_2 in an object file and give it version VER1 from
	      // the version script.  This looks like a default
	      // definition for VER1, so it looks like we should merge
	      // t2_2/NULL with t2_2/VER1.  That doesn't make sense,
	      // but it's not obvious that this is an error, either.
	      // So we just punt.

	      // If one of the symbols has non-default visibility, and
	      // the other is defined in a shared object, then they
	      // are different symbols.

	      // Otherwise, we just resolve the symbols as though they
	      // were the same.

	      if (insdef.first->second->version() != NULL)
		{
		  gold_assert(insdef.first->second->version() != version);
		  def = false;
		}
	      else if (ret->visibility() != elfcpp::STV_DEFAULT
		  && insdef.first->second->is_from_dynobj())
		def = false;
	      else if (insdef.first->second->visibility() != elfcpp::STV_DEFAULT
		       && ret->is_from_dynobj())
		def = false;
	      else
		{
		  const Sized_symbol<size>* sym2;
		  sym2 = this->get_sized_symbol<size>(insdef.first->second);
		  Symbol_table::resolve<size, big_endian>(ret, sym2);
		  this->make_forwarder(insdef.first->second, ret);
		  insdef.first->second = ret;
		}
	    }
	  else
	    def = false;
	}
d964 3
a992 2
  if (def)
    ret->set_is_default();
d1496 3
a1498 1
// symbol if there is one.  This canonicalizes *PNAME and *PVERSION.
d1504 2
a1505 1
                                    Sized_symbol<size>** poldsym)
d1507 1
a1507 4
  Symbol* oldsym;
  Sized_symbol<size>* sym;
  bool add_to_table = false;
  typename Symbol_table_type::iterator add_loc = this->table_.end();
d1512 1
d1519 4
d1526 8
d1537 2
d1543 2
a1544 1
      *pversion = oldsym->version();
d1562 10
d1577 9
d1591 21
a1611 3
          add_to_table = true;
          add_loc = ins.first;
	  oldsym = NULL;
d1635 3
d1705 1
d1711 2
a1712 1
						    only_if_ref, &oldsym);
d1721 2
a1722 1
						     only_if_ref, &oldsym);
d1746 8
a1753 2
  delete sym;
  return oldsym;
d1815 1
d1821 2
a1822 1
						    only_if_ref, &oldsym);
d1831 2
a1832 1
						     only_if_ref, &oldsym);
d1856 8
a1863 2
  delete sym;
  return oldsym;
d1925 1
d1931 2
a1932 1
						    only_if_ref, &oldsym);
d1941 2
a1942 1
						     only_if_ref, &oldsym);
d1972 8
a1979 2
  delete sym;
  return oldsym;
d2143 1
d2148 2
a2149 1
							false, &oldsym);
d2158 2
a2159 1
							 false, &oldsym);
@


1.116
log
@	PR 6811
	* options.h (class Search_directory): Add is_system_directory.
	(class General_options): Declare is_in_system_directory.
	* options.cc (get_relative_sysroot): Make static.
	(get_default_sysroot): Make static.
	(General_optoins::is_in_system_directory): New function.
	* fileread.cc (Input_file::is_in_system_directory): New function.
	* fileread.h (class Input_file): Declare is_in_system_directory.
	* object.h (class Object): Add is_in_system_directory.
	(class Input_objects): Remove system_library_directory_ field.
	* object.cc (Input_objects::add_object): Don't set
	system_library_directory_.
	(input_objects::found_in_system_library_directory): Remove.
	* symtab.cc (Symbol_table::write_globals): Remove input_objects
	parameter.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::warn_about_undefined_dynobj_symbol): Likewise.
	Call Object::is_in_system_directory.
	* symtab.h (class Symbol_table): Update declarations.
@
text
@d2696 4
a2699 1
  osym.put_st_value(os->address());
@


1.115
log
@	PR 9836
	* symtab.cc (Symbol_table::add_from_object): If the visibility is
	hidden or internal, force the symbol to be local.
	* resolve.cc (Symbol::override_visibility): Define.
	(Symbol::override_base): Use override_visibility.
	(Symbol_table::resolve): Likewise.
	(Symbol::override_base_with_special): Likewise.
	(Symbol_table::override_with_special): If the visibility is hidden
	or internal, force the symbol to be local.
	* symtab.h (class Symbol): Add set_visibility and
	override_visibility.
	* testsuite/ver_test_1.sh: New file.
	* testsuite/Makefile.am (check_SCRIPTS): Add ver_test_1.sh.
	(check_DATA): Add ver_test_1.syms.
	(ver_test_1.syms): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d2376 1
a2376 2
Symbol_table::write_globals(const Input_objects* input_objects,
			    const Stringpool* sympool,
d2386 1
a2386 2
      this->sized_write_globals<32, false>(input_objects, sympool,
                                           dynpool, symtab_xindex,
d2392 1
a2392 2
      this->sized_write_globals<32, true>(input_objects, sympool,
                                          dynpool, symtab_xindex,
d2398 1
a2398 2
      this->sized_write_globals<64, false>(input_objects, sympool,
                                           dynpool, symtab_xindex,
d2404 1
a2404 2
      this->sized_write_globals<64, true>(input_objects, sympool,
                                          dynpool, symtab_xindex,
d2417 1
a2417 2
Symbol_table::sized_write_globals(const Input_objects* input_objects,
				  const Stringpool* sympool,
d2453 1
a2453 1
      this->warn_about_undefined_dynobj_symbol(input_objects, sym);
d2618 4
a2621 5
// We also don't warn about libraries found in the system library
// directory (the directory were we find libc.so); we assume that
// those libraries are OK.  This heuristic avoids problems in
// GNU/Linux, in which -ldl can have undefined references satisfied by
// ld-linux.so.
d2624 1
a2624 3
Symbol_table::warn_about_undefined_dynobj_symbol(
    const Input_objects* input_objects,
    Symbol* sym) const
d2633 1
a2633 1
      && !input_objects->found_in_system_library_directory(sym->object()))
@


1.114
log
@2009-02-06  Chris Demetriou  <cgd@@google.com>

	* gold.h (gold_undefined_symbol): Change to take only a Symbol
	pointer and to report location as the file name associated with
	the symbol.
	(gold_undefined_symbol_at_location): New function to replace the
	old gold_undefined_symbol functionality.
	* target-reloc.h (relocate_section): Update to use
	gold_undefined_symbol_at_location.
	* symtab.cc (Symbol_table::warn_about_undefined_dynobj_symbol):
	Call gold_undefined_symbol function rather than gold_error.
	* errors.h (Errors::undefined_symbol): Take location as a
	string, rather than calculating it from a relocation.
	* errors.cc (Errors::fatal): Print "fatal error:" before the
	formatted message.
	(Errors::error, Errors::error_at_location): Print "error: "
	before the formatted message.
	(Errors::undefined_symbol): Take location as a string, rather
	than calculating it from a relocation.
	(gold_undefined_symbol_at_location): New function akin to
	old gold_undefined_symbol, calculates location from relocation.
	(gold_undefined_symbol): Change to take only a Symbol pointer
	and to report location as the file name associated with the symbol.
	* testsuite/debug_msg.sh: Update for changed error messages.
	* testsuite/undef_symbol.sh: Likewise.
@
text
@d651 2
a652 1
// Record that a symbol is forced to be local by a version script.
d966 9
d1192 1
a1192 1
	this->force_local(res);
@


1.113
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d2637 1
a2637 11
        {
          if (sym->version())
            gold_error(_("%s: undefined reference to '%s', version '%s'"),
                       sym->object()->name().c_str(),
                       sym->demangled_name().c_str(),
                       sym->version());
          else
            gold_error(_("%s: undefined reference to '%s'"),
                       sym->object()->name().c_str(),
                       sym->demangled_name().c_str());
        }
@


1.112
log
@	* options.cc (General_options::parse_dynamic_list): New function.
	* options.h (General_options): New flags dynamic_list,
	dynamic_list_data, dynamic_list_cpp_new, and
	dynamic_list_cpp_typeinfo.  New variable dynamic_list_.
	(General_options::in_dynamic_list): New function.
	* script.cc (Lex::Mode): New enum DYNAMIC_LIST.
	(Lex::can_start_name): Add support for DYNAMIC_LIST mode.
	(Lex::can_continue_name): Likewise.
	(yylex): Likewise.
	(read_script_file): New parameter script_options.
	(read_dynamic_list): New function.
	(Script_options::define_dynamic_list): New function.
	(dynamic_list_keyword_parsecodes): New variable.
	(dynamic_list_keywords): New variable.
	* script.h (Script_options::define_dynamic_list): New function
	prototype.
	(read_dynamic_list): New function prototype.
	* symtab.cc (strprefix): New macro.
	(Symbol::should_add_dynsym_entry): Support dynamic_list,
	dynamic_list_data, dynamic_list_cpp_new, and
	dynamic_list_cpp_typeinfo.
	* yyscript.y (PARSING_DYNAMIC_LIST): New token.
	(dynamic_list_expr): New rule.
	(dynamic_list_nodes): Likewise.
	(dynamic_list_node): Likewise.
	* testsuite/Makefile.am (dynamic_list): New test.
	* testsuite/Makefile.in: Regenerated.
	* testsuite/dynamic_list.t: New file.
	* testsuite/dynamic_list.sh: New file.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d33 1
d306 16
d481 1
a481 1
    version_script_(version_script)
d508 66
d647 2
d820 2
d904 2
d1111 6
d2275 4
a2278 1
		gold_assert(sym->dynsym_index() == -1U);
@


1.111
log
@	* mapfile.cc (Mapfile::print_input_section): Change -1U to -1ULL.
	* object.cc (Sized_relobj::do_layout): Use constant invalid_address
	instead of -1U.
	(Sized_relobj::do_finalize_local_symbols): Likewise.
	(Sized_relobj::map_to_kept_section): Likewise.
	* object.h (Sized_relobj::invalid_address): New constant.
	(Sized_relobj::do_output_section_offset): Check for invalid_address
	and return -1ULL.
	* output.cc (Output_reloc::local_section_offset): Use constant
	invalid_address instead of -1U.
	(Output_reloc::get_address): Likewise.
	(Output_section::output_address): Change -1U to -1ULL.
	* output.h (Output_reloc::invalid_address): New constant.
	* reloc.cc (Sized_relobj::write_sections): Use constant
	invalid_address instead of -1U.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (Symbol_table::sized_finalize_symbol): Handle symbol
	values for merge sections.
	* target-reloc.h (relocate_for_relocatable): Use constant
	invalid_address instead of -1U.
@
text
@d40 1
d292 3
d309 42
@


1.110
log
@Add plugin functionality for link-time optimization (LTO).

include/:
	* plugin-api.h: New file.

gold/:
	* configure.ac (plugins): Add --enable-plugins option.
	* configure: Regenerate.
	* config.in: Regenerate.
	* Makefile.am (LIBDL): New variable.
	(CCFILES): Add plugin.cc.
	(HFILES): Add plugin.h.
	(ldadd_var): Add LIBDL.
	* Makefile.in: Regenerate.

	* archive.cc: Include "plugin.h".
	(Archive::setup): Don't preread archive symbols when using a plugin.
	(Archive::get_file_and_offset): Add memsize parameter.  Change callers.
	(Archive::get_elf_object_for_member): Call plugin hooks for claiming
	files.
	(Archive::include_member): Add symbols from plugin objects.
	* archive.h (Archive::get_file_and_offset): Add memsize parameter.
	* descriptors.cc (Descriptors::open): Check for file descriptors
	abandoned by plugins.
	(Descriptors::claim_for_plugin): New function.
	* descriptors.h (Descriptors::claim_for_plugin): New function.
	(Open_descriptor::is_claimed): New field.
	(claim_descriptor_for_plugin): New function.
	* fileread.cc (File_read::claim_for_plugin): New function.
	* fileread.h (File_read::claim_for_plugin): New function.
	(File_read::descriptor): New function.
	* gold.cc: Include "plugin.h".
	(queue_initial_tasks): Add task to call plugin hooks for generating
	new object files.
	* main.cc: Include "plugin.h".
	(main): Load plugin libraries.
	* object.h (Pluginobj): Declare.
	(Object::pluginobj): New function.
	(Object::do_pluginobj): New function.
	(Object::set_target): New function.
	* options.cc: Include "plugin.h".
	(General_options::parse_plugin): New function.
	(General_options::General_options): Initialize plugins_ field.
	(General_options::add_plugin): New function.
	* options.h (Plugin_manager): Declare.
	(General_options): Add --plugin option.
	(General_options::has_plugins): New function.
	(General_options::plugins): New function.
	(General_options::add_plugin): New function.
	(General_options::plugins_): New field.
	* plugin.cc: New file.
	* plugin.h: New file.
	* readsyms.cc: Include "plugin.h".
	(Read_symbols::do_read_symbols): Check for archive before checking
	for ELF file.  Call plugin hooks to claim files.
	* resolve.cc (Symbol_table::resolve): Record when symbol is referenced
	from a real object file; force override when processing replacement
	files.
	* symtab.cc (Symbol::init_fields): Initialize in_real_elf_ field.
	(Symbol::init_base_object): Likewise.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): Likewise.
	(Symbol::output_section): Assert that object is not a plugin.
	(Symbol_table::add_from_pluginobj): New function.
	(Symbol_table::sized_finalize_symbol): Treat symbols from plugins as
	undefined.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::add_from_pluginobj): Instantiate template.
	* symtab.h (Sized_pluginobj): Declare.
	(Symbol::in_real_elf): New function.
	(Symbol::set_in_real_elf): New function.
	(Symbol::in_real_elf_): New field.
	(Symbol_table::add_from_pluginobj): New function.

	* testsuite/Makefile.am (AM_CFLAGS): New variable.
	(LIBDL): New variable.
	(LDADD): Add LIBDL.
	(check_PROGRAMS): Add plugin_test_1 and plugin_test_2.
	(check_SCRIPTS): Add plugin_test_1.sh and plugin_test_2.sh.
	(check_DATA): Add plugin_test_1.err and plugin_test_2.err.
	(MOSTLYCLEANFILES): Likewise.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_test.c: New file.
	* testsuite/plugin_test_1.sh: New file.
	* testsuite/plugin_test_2.sh: New file.
@
text
@d2139 14
a2152 5
            Value_type secoff = convert_types<Value_type, uint64_t>(secoff64);
	    if (sym->type() == elfcpp::STT_TLS)
	      value = sym->value() + os->tls_offset() + secoff;
	    else
	      value = sym->value() + os->address() + secoff;
@


1.109
log
@2008-09-05  Cary Coutant  <ccoutant@@google.com>

	* symtab.cc (Symbol_table::add_from_dynobj): Fix typos in
	explicit instantiations.
@
text
@d40 1
d77 1
d122 1
d139 1
d157 1
d171 1
d186 1
d367 1
d984 62
d2116 5
d2339 2
d2783 40
@


1.108
log
@2008-08-28  Kris Van Hees  <kris.van.hees@@oracle.com>

        PR gold/6858
        * options.cc (General_options::finalize): Allow undefined symbols
        in shlibs if linking -shared.

        PR gold/6859
        * symtab.cc (Symbol::init_base_undefined): Mark explicitly undefined
        symbols as not needing a dynsym entry.
@
text
@d2658 1
a2658 1
    Sized_relobj<32, true>::Symbols* sympointers,
d2672 1
a2672 1
    Sized_relobj<32, false>::Symbols* sympointers,
d2686 1
a2686 1
    Sized_relobj<64, true>::Symbols* sympointers,
d2700 1
a2700 1
    Sized_relobj<64, false>::Symbols* sympointers,
@


1.107
log
@	PR 6647
	* script.cc (Version_script_info::get_versions): Don't add empty
	version tag to return value.
	(Version_script_info::get_symbol_version_helper): Change return
	type to bool.  Add pversion parameter.  Change all callers.
	(script_register_vers_node): Don't require a non-NULL tag.
	* script.h (class Version_script_info): Update declarations.
	(Version_script_info::get_symbol_version): Change return type to
	bool.  Add version parameter.  Change all callers.
	* symtab.cc (Sized_symbol::add_from_relobj): Rework version
	handling.  Handle an empty version from a version script.
	(Symbol_table::define_special_symbol): Likewise.
	* testsuite/ver_test_10.script: New file.
	* testsuite/ver_test_10.sh: New file.
	* testsuite/Makefile.am (check_SCRIPTS): Add ver_test_10.sh.
	(check_DATA): Add ver_test_10.syms.
	(ver_test_10.syms, ver_test_10.so): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d177 1
@


1.106
log
@2008-07-23  Simon Baldwin  <simonb@@google.com>

        * symtab.cc (Symbol_table::sized_write_symbol): Only set st_size
        to zero for undefined symbols from dynamic libraries.
@
text
@d888 1
d904 1
d909 26
a934 16
      else if (!version_script_.empty()
	       && st_shndx != elfcpp::SHN_UNDEF)
        {
          // The symbol name did not have a version, but
          // the version script may assign a version anyway.
          namelen = strlen(name);
          def = true;
          // Check the global: entries from the version script.
          const std::string& version =
              version_script_.get_symbol_version(name);
          if (!version.empty())
            ver = version.c_str();
          // Check the local: entries from the version script
          if (version_script_.symbol_is_local(name))
            local = true;
        }
d959 4
d964 3
a966 17
      if (ver == NULL)
	{
	  Stringpool::Key name_key;
	  name = this->namepool_.add(name, true, &name_key);
	  res = this->add_from_object(relobj, name, name_key, NULL, 0,
				      false, *psym, st_shndx, is_ordinary,
				      orig_st_shndx);
          if (local)
	    this->force_local(res);
	}
      else
	{
	  Stringpool::Key name_key;
	  name = this->namepool_.add_with_length(name, namelen, true,
						 &name_key);
	  Stringpool::Key ver_key;
	  ver = this->namepool_.add(ver, true, &ver_key);
d968 2
a969 4
	  res = this->add_from_object(relobj, name, name_key, ver, ver_key,
				      def, *psym, st_shndx, is_ordinary,
				      orig_st_shndx);
	}
d1273 1
d1276 5
a1280 3
      const std::string& v(this->version_script_.get_symbol_version(*pname));
      if (!v.empty())
	*pversion = v.c_str();
@


1.105
log
@	* symtab.cc (Symbol_table::resolve): Remove version parameter.
	Change all callers.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/ver_test_9.cc: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add ver_test_9.
	(ver_test_9_SOURCES, ver_test_9_DEPENDENCIES): Define.
	(ver_test_9_LDFLAGS, ver_test_9_LDADD): Define.
	(ver_test_9.so, ver_test_9.o): New targets.
	* testsuite/Makefile.in: Rebuild.
@
text
@d2357 5
a2361 2
  // Use a symbol size of zero for undefined symbols.
  osym.put_st_size(shndx == elfcpp::SHN_UNDEF ? 0 : sym->symsize());
@


1.104
log
@	* cref.cc: New file.
	* cref.h: New file.
	* options.h (class General_options): Add --print-symbol-counts.
	* main.cc (main): Issue defined symbol report if requested.
	* archive.cc (Archive::interpret_header): Make into a const member
	function.
	(Archive::add_symbols): Call Input_objects::archive_start and
	archive_stop.
	(Archive::const_iterator): Define new class.
	(Archive::begin, Archive::end): New functions.
	(Archive::include_all_members): Rewrite to use iterator.
	(Archive::count_members): New function.
	* archive.h (class Archive): Update declarations.
	(Archive::filename): New function.
	* object.cc: Include "cref.h".
	(Sized_relobj::Sized_relobj): Initialize defined_count_.
	(Sized_relobj::do_get_global_symbol_counts): New function.
	(Input_objects::add_object): Add object to cross-referencer.
	(Input_objects::archive_start): New function.
	(Input_objects::archive_stop): New function.
	(Input_objects::print_symbol_counts): New function.
	* object.h: Declare Cref and Archive.
	(Object::get_global_symbol_counts): New function.
	(Object::do_get_global_symbol_counts): New pure virtual function.
	(class Sized_relobj): Add defined_count_ field.  Update
	declarations.
	(class Input_objects): Add cref_ field.  Update constructor.
	Update declarations.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize symbols_ and
	defined_count_.
	(Sized_dynobj::do_add_symbols): Allocate symbols_ if printing
	symbol counts.
	(Sized_dynobj::do_get_global_symbol_counts): New function.
	* dynobj.h (class Sized_dynobj): Add fields symbols_ and
	defined_count_.  Update declarations.  Define Symbols typedef.
	* symtab.cc (Symbol_table::add_from_relobj): Add defined
	parameter.  Change all callers.
	(Symbol_table::add_from_dynobj): Add sympointers and defined
	parameters.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* Makefile.am (CCFILES): Add cref.cc.
	(HFILES): Add cref.h.
	* Makefile.in: Rebuild.
@
text
@d492 1
a492 2
Symbol_table::resolve(Sized_symbol<size>* to, const Sized_symbol<size>* from,
		      const char* version)
d504 1
a504 1
		version);
d737 1
a737 1
		  Symbol_table::resolve<size, big_endian>(ret, sym2, version);
@


1.103
log
@2008-07-22  Simon Baldwin  <simonb@@google.com>

        * symtab.cc (Symbol_table::sized_write_symbol): Set symbol size
        to zero when writing undefined symbols.
@
text
@d838 2
a839 1
    typename Sized_relobj<size, big_endian>::Symbols* sympointers)
d841 2
d853 2
d875 3
d988 3
a990 1
    const std::vector<const char*>* version_map)
d992 2
d1027 3
d1065 3
d1163 3
d2652 2
a2653 1
    Sized_relobj<32, true>::Symbols* sympointers);
d2666 2
a2667 1
    Sized_relobj<32, false>::Symbols* sympointers);
d2680 2
a2681 1
    Sized_relobj<64, true>::Symbols* sympointers);
d2694 2
a2695 1
    Sized_relobj<64, false>::Symbols* sympointers);
d2709 3
a2711 1
    const std::vector<const char*>* version_map);
d2725 3
a2727 1
    const std::vector<const char*>* version_map);
d2741 3
a2743 1
    const std::vector<const char*>* version_map);
d2757 3
a2759 1
    const std::vector<const char*>* version_map);
@


1.102
log
@2008-07-21  Craig Silverstein  <csilvers@@google.com>

	* symtab.cc (Symbol_table::warn_about_undefined_dynobj_symbol):
	Include symbol version in error message.
@
text
@d2337 2
a2338 1
  osym.put_st_size(sym->symsize());
@


1.101
log
@	* symtab.cc (Symbol_table::add_from_object): Rewrite the case
	where we see NAME/NULL and NAME/VERSION  as separate symbols.
	* testsuite/ver_test_main.cc (main): Call t4.
	(t4, t4_2a): Define.
	* testsuite/ver_test_2.cc (t4_2): Define.
	* testsuite/ver_test_2.script: Put t4_2a in VER2.
	* testsuite/ver_test_4.cc (t4_2a): Define.
	* testsuite/ver_test_4.script: Put t4_2a in VER2.
	* testsuite/ver_test.h (t4, t4_2, t4_2a): Declare.
@
text
@d2379 11
a2389 3
	gold_error(_("%s: undefined reference to '%s'"),
		   sym->object()->name().c_str(),
                   sym->demangled_name().c_str());
@


1.100
log
@	Handle output sections with more than 0x7fffffff bytes.
	* object.h (class Relobj): Change map_to_output_ to
	output_sections_, and just keep a section pointer.  Change all
	uses.  Move comdat group support to Sized_relobj.
	(Relobj::is_section_specially_mapped): Remove.
	(Relobj::output_section): Remove poff parameter.  Change all
	callers.
	(Relobj::output_section_offset): New function.
	(Relobj::set_section_offset): Rewrite.
	(Relobj::map_to_output): Remove.
	(Relobj::output_sections): New function.
	(Relobj::do_output_section_offset): New pure virtual function.
	(Relobj::do_set_section_offset): Likewise.
	(class Sized_relobj): Add section_offsets_ field.  Add comdat
	group support from Relobj.  Update declarations.
	(Sized_relobj::get_output_section_offset): New function.
	(Sized_relobj::do_output_section_offset): New function.
	(Sized_relobj::do_set_section_offset): New function.
	* object.cc (Relobj::output_section_address): Remove.
	(Sized_relobj::Sized_relobj): Initialize new fields.
	(Sized_relobj::include_section_group): Cast find_kept_object to
	Sized_relobj.
	(Sized_relobj::include_linkonce_section): Likewise.
	(Sized_relobj::do_layout): Use separate arrays for output section
	and output offset.
	(Sized_relobj::do_count_local_symbols): Change map_to_output to
	output_sections.
	(Sized_relobj::do_finalize_local_symbols): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_local_symbols): Likewise.
	(map_to_kept_section): Compute output address directly.
	* reloc.cc (Sized_relobj::do_read_relocs): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_sections): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (sized_finalize_symbol): Use output_section_offset.
	* output.h (class Output_reloc): Update declarations.  Change
	u2_.relobj to Sized_relobj*.
	(class Output_data_reloc): Change add functions to use
	Sized_relobj*.
	* output.cc (Output_reloc::Output_reloc): Change relobj to
	Sized_relobj*.
	(Output_reloc::local_section_offset): Change return type to
	Elf_Addr.  Use get_output_section_offset.
	(Output_reloc::get_address): Likewise.
	(Output_section::is_input_address_mapped): Don't call
	is_section_specially_mapped.
	(Output_section::output_offset): Likewise.
	(Output_section::output_address): Likewise.
	(Output_section::starting_output_address): Likewise.
	* copy-relocs.cc (Copy_relocs::copy_reloc): Change object
	parameter to Sized_relobj*.
	(Copy_relocs::need_copy_reloc): Likewise.
	(Copy_relocs::save): Likewise.
	* copy-relocs.h (class Copy_relocs): Update declarations.
	(class Copy_relocs::Copy_reloc_entry): Change constructor to use
	Sized_relobj*.  Change relobj_ field to Sized_relobj*.
	* target-reloc.h (relocate_for_relocatable): Change
	offset_in_output_section type to Elf_Addr.  Change code that uses
	it as well.
	* layout.cc (Layout::layout): Always set *off.
	* mapfile.cc (Mapfile::print_input_section): Use
	output_section_offset.
	* i386.cc (Target_i386::copy_reloc): Change object parameter to
	Sized_relobj*.
	* powerpc.cc (Target_powerpc::copy_reloc): Likewise.
	* sparc.cc (Target_sparc::copy_reloc): Likewise.
	* x86_64.cc (Target_x86_64::copy_reloc): Likewise.
@
text
@d690 1
a690 2
	  else if (insdef.first->second != ret
	           && insdef.first->second->is_undefined())
d693 49
a741 13
	      // entries for both NAME/VERSION and NAME/NULL.  Note
	      // that we don't want to combine them if the existing
	      // symbol is going to override the new one.  FIXME: We
	      // currently just test is_undefined, but this may not do
	      // the right thing if the existing symbol is from a
	      // shared library and the new one is from a regular
	      // object.

	      const Sized_symbol<size>* sym2;
	      sym2 = this->get_sized_symbol<size>(insdef.first->second);
	      Symbol_table::resolve<size, big_endian>(ret, sym2, version);
	      this->make_forwarder(insdef.first->second, ret);
	      insdef.first->second = ret;
@


1.99
log
@	PR 6585
	* symtab.cc (Symbol_table::add_undefined_symbols_from_command_line):
	Correct typo.
@
text
@d360 1
a360 2
	    section_offset_type dummy;
	    return relobj->output_section(shndx, &dummy);
d1945 2
d1962 1
a1962 1
  typename Sized_symbol<size>::Value_type value;
d1995 1
a1995 2
	    section_offset_type secoff;
	    Output_section* os = relobj->output_section(shndx, &secoff);
d2004 2
d2213 1
a2213 3
		    section_offset_type secoff;
		    Output_section* os = relobj->output_section(in_shndx,
								&secoff);
@


1.98
log
@	* symtab.c (Symbol::init_base_output_data): Add version
	parameter.  Change all callers.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): Likewise.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Sized_symbol::init_undefined): Likewise.
	(Symbol_table::do_define_in_output_data): If the new symbol has a
	version, mark it as the default.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* symtab.h (class Symbol): Update declarations.
	(class Sized_symbol): Likewise.
	* resolve.cc (Symbol::override_version): New function.
	(Symbol::override_base: Call override_version.
	(Symbol::override_base_with_special): Likewise.
	* testsuite/ver_script_8.script: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add ver_test_8.
	(ver_test_8_SOURCES, ver_test_8_DEPENDENCIES): Define.
	(ver_test_8_LDFLAGS, ver_test_8_LDADD): Define.
	(ver_test_8_1.so, ver_test_8_2.so): New targets.
@
text
@d1728 1
a1728 1
#if defined(HAVE_TARGET_32_LITTL) || defined(HAVE_TARGET_32_BIG)
@


1.97
log
@	PR 6049
	* options.h (DEFINE_set): Add VARNAME_begin and VARNAME_end
	functions.
	(class General_options): Remove existing --undefined, and add
	--no-undefined instead.  Add new --undefined as synonym for -u.
	* archive.cc (Archive::add_symbols): Check whether symbol was
	named with -u.
	* gold.cc (queue_middle_tasks): Add -u symbols to symbol table.
	* symtab.h (class Symbol): Rename CONSTANT to IS_CONSTANT; change
	all uses.  Add IS_UNDEFINED.  Update declarations to split
	different versions of init_base.  Declare init_base_undefined.
	(Symbol::is_defined): Handle IS_UNDEFINED.
	(Symbol::is_undefined): Likewise.
	(Symbol::is_weak_undefined): Call is_undefined.
	(Symbol::is_absolute): Handle IS_CONSTANT.
	(class Sized_symbol): Update declarations to split different
	versions of init.  Declare init_undefined.
	(class Symbol_table): Declare new functions.
	* symtab.cc (Symbol::init_base_object): Rename from init_base.
	Change all callers.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): New function.
	(Sized_symbol::init_object): Rename from init.  Change all
	callers.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Sized_symbol::init_undefined): New function.
	(Symbol_table::add_undefined_symbols_from_command_line): New
	function.
	(Symbol_table::do_add_undefined_symbols_from_command_line): New
	function.
	(Symbol::final_value_is_known): Handle IS_UNDEFINED.
	(Symbol::output_section): Likewise.
	(Symbol::set_output_section): Likewise.
	(Symbol_table::sized_finalize_symbol): Likewise.
	(Symbol_table::sized_write_globals): Likewise.
	* resolve.cc (Symbol_table::should_override): Likewise.
	(Symbol::override_base_with_special): Likewise.
@
text
@d126 4
a129 4
Symbol::init_base_output_data(const char* name, Output_data* od,
			      elfcpp::STT type, elfcpp::STB binding,
			      elfcpp::STV visibility, unsigned char nonvis,
			      bool offset_is_from_end)
d131 1
a131 1
  this->init_fields(name, NULL, type, binding, visibility, nonvis);
d142 4
a145 3
Symbol::init_base_output_segment(const char* name, Output_segment* os,
				 elfcpp::STT type, elfcpp::STB binding,
				 elfcpp::STV visibility, unsigned char nonvis,
d148 1
a148 1
  this->init_fields(name, NULL, type, binding, visibility, nonvis);
d159 3
a161 3
Symbol::init_base_constant(const char* name, elfcpp::STT type,
			   elfcpp::STB binding, elfcpp::STV visibility,
			   unsigned char nonvis)
d163 1
a163 1
  this->init_fields(name, NULL, type, binding, visibility, nonvis);
d172 3
a174 3
Symbol::init_base_undefined(const char* name, elfcpp::STT type,
			    elfcpp::STB binding, elfcpp::STV visibility,
			    unsigned char nonvis)
d176 1
a176 1
  this->init_fields(name, NULL, type, binding, visibility, nonvis);
d212 4
a215 3
Sized_symbol<size>::init_output_data(const char* name, Output_data* od,
				     Value_type value, Size_type symsize,
				     elfcpp::STT type, elfcpp::STB binding,
d220 2
a221 2
  this->init_base_output_data(name, od, type, binding, visibility, nonvis,
			      offset_is_from_end);
d231 4
a234 3
Sized_symbol<size>::init_output_segment(const char* name, Output_segment* os,
					Value_type value, Size_type symsize,
					elfcpp::STT type, elfcpp::STB binding,
d239 2
a240 2
  this->init_base_output_segment(name, os, type, binding, visibility, nonvis,
				 offset_base);
d250 4
a253 4
Sized_symbol<size>::init_constant(const char* name, Value_type value,
				  Size_type symsize, elfcpp::STT type,
				  elfcpp::STB binding, elfcpp::STV visibility,
				  unsigned char nonvis)
d255 1
a255 1
  this->init_base_constant(name, type, binding, visibility, nonvis);
d264 3
a266 3
Sized_symbol<size>::init_undefined(const char* name, elfcpp::STT type,
				   elfcpp::STB binding, elfcpp::STV visibility,
				   unsigned char nonvis)
d268 1
a268 1
  this->init_base_undefined(name, type, binding, visibility, nonvis);
d1377 2
a1378 3
  gold_assert(version == NULL || oldsym != NULL);
  sym->init_output_data(name, od, value, symsize, type, binding, visibility,
			nonvis, offset_is_from_end);
d1385 2
d1478 1
a1478 2
  gold_assert(version == NULL || oldsym != NULL);
  sym->init_output_segment(name, os, value, symsize, type, binding,
d1486 2
d1579 2
a1580 2
  gold_assert(version == NULL || version == name || oldsym != NULL);
  sym->init_constant(name, value, symsize, type, binding, visibility, nonvis);
d1592 3
d1786 1
a1786 1
      sym->init_undefined(name, elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
@


1.96
log
@	* symtab.cc (Symbol_table::add_from_dynobj): If we see a protected
	symbol, change it to have default visibility.
	* testsuite/protected_1.cc: New file.
	* testsuite/protected_2.cc: New file.
	* testsuite/protected_3.cc: New file.
	* testsuite/protected_main_1.cc: New file.
	* testsuite/protected_main_2.cc: New file.
	* testsuite/protected_main_3.cc: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add protected_1.
	(protected_1_SOURCES, protected_1_DEPENDENCIES): Define.
	(protected_1_LDFLAGS, protected_1_LDADD): Define.
	(protected_1.so): New target.
	(protected_1_pic.o, protected_2_pic.o): New targets.
	(protected_3_pic.o): New target.
	(check_PROGRAMS): Add protected_2.
	(protected_2_SOURCES, protected_2_DEPENDENCIES): Define.
	(protected_2_LDFLAGS, protected_2_LDADD): Define.
	* testsuite/Makefile.in: Rebuild.
@
text
@d108 3
a110 3
Symbol::init_base(const char* name, const char* version, Object* object,
		  const elfcpp::Sym<size, big_endian>& sym,
		  unsigned int st_shndx, bool is_ordinary)
d126 4
a129 3
Symbol::init_base(const char* name, Output_data* od, elfcpp::STT type,
		  elfcpp::STB binding, elfcpp::STV visibility,
		  unsigned char nonvis, bool offset_is_from_end)
d142 4
a145 3
Symbol::init_base(const char* name, Output_segment* os, elfcpp::STT type,
		  elfcpp::STB binding, elfcpp::STV visibility,
		  unsigned char nonvis, Segment_offset_base offset_base)
d158 16
a173 3
Symbol::init_base(const char* name, elfcpp::STT type,
		  elfcpp::STB binding, elfcpp::STV visibility,
		  unsigned char nonvis)
d176 1
a176 1
  this->source_ = CONSTANT;
d196 4
a199 3
Sized_symbol<size>::init(const char* name, const char* version, Object* object,
			 const elfcpp::Sym<size, big_endian>& sym,
			 unsigned int st_shndx, bool is_ordinary)
d201 1
a201 1
  this->init_base(name, version, object, sym, st_shndx, is_ordinary);
d211 6
a216 5
Sized_symbol<size>::init(const char* name, Output_data* od,
			 Value_type value, Size_type symsize,
			 elfcpp::STT type, elfcpp::STB binding,
			 elfcpp::STV visibility, unsigned char nonvis,
			 bool offset_is_from_end)
d218 2
a219 2
  this->init_base(name, od, type, binding, visibility, nonvis,
		  offset_is_from_end);
d229 6
a234 5
Sized_symbol<size>::init(const char* name, Output_segment* os,
			 Value_type value, Size_type symsize,
			 elfcpp::STT type, elfcpp::STB binding,
			 elfcpp::STV visibility, unsigned char nonvis,
			 Segment_offset_base offset_base)
d236 2
a237 1
  this->init_base(name, os, type, binding, visibility, nonvis, offset_base);
d247 4
a250 3
Sized_symbol<size>::init(const char* name, Value_type value, Size_type symsize,
			 elfcpp::STT type, elfcpp::STB binding,
			 elfcpp::STV visibility, unsigned char nonvis)
d252 1
a252 1
  this->init_base(name, type, binding, visibility, nonvis);
d257 13
d316 2
a317 2
  // If the symbol is not from an object file, then it is defined, and
  // known.
d319 10
a328 1
    return true;
d330 5
a334 9
  // If the symbol is from a dynamic object, then the final value is
  // not known.
  if (this->object()->is_dynamic())
    return false;

  // If the symbol is not undefined (it is defined or common), then
  // the final value is known.
  if (!this->is_undefined())
    return true;
d367 2
a368 1
    case CONSTANT:
d389 1
a389 1
    case CONSTANT:
d395 1
d757 1
a757 1
	  ret->init(name, version, object, sym, st_shndx, is_ordinary);
d1375 2
a1376 2
  sym->init(name, od, value, symsize, type, binding, visibility, nonvis,
	    offset_is_from_end);
d1475 2
a1476 2
  sym->init(name, os, value, symsize, type, binding, visibility, nonvis,
	    offset_base);
d1575 1
a1575 1
  sym->init(name, value, symsize, type, binding, visibility, nonvis);
d1711 73
d2043 1
a2043 1
    case Symbol::CONSTANT:
d2047 4
d2243 1
a2243 1
	case Symbol::CONSTANT:
d2247 4
@


1.95
log
@	* dwarf_reader.cc (next_generation_count): New static var.
	(Addr2line_cache_entry): New struct.
	(addr2line_cache): New static var.
	(Dwarf_line_info::one_addr2line): Added caching.
	(Dwarf_line_info::clear_addr2line_cache): New function.
	* dwarf_reader.h (Dwarf_line_info::one_addr2line): Add
	cache-size parameter.
	(Dwarf_line_info::one_addr2line_cache): New function.
	* symtab.cc (Symbol_table::detect_odr_violations): Pass
	new cache-size argument to one_addr2line(), and clear cache.
@
text
@d945 15
a959 1
      unsigned int st_name = sym.get_st_name();
d970 1
a970 1
      unsigned int st_shndx = dynobj->adjust_sym_shndx(i, sym.get_st_shndx(),
d980 1
a980 1
				      false, sym, st_shndx, is_ordinary,
d1015 1
a1015 1
					  false, sym, st_shndx, is_ordinary,
d1047 1
a1047 1
					    false, sym, st_shndx, is_ordinary,
d1054 1
a1054 1
					      version_key, def, sym, st_shndx,
d1064 1
a1064 1
	  && sym.get_st_type() == elfcpp::STT_OBJECT
@


1.94
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d2346 2
a2347 1
	  // other uses of the object.
d2349 1
d2351 1
a2351 1
              locs->object, locs->shndx, locs->offset);
d2367 2
@


1.93
log
@	* errors.cc (Errors::info): New function.
	(gold_info): New function.
	* errors.h (Errors::info): New function.
	* gold.h (gold_info): New function.
	* object.cc (Input_objects::add_object): Print trace output.
	* options.cc (options::parse_set): New function.
	(General_options::parse_wrap): Deleted.
	(General_options::General_options): Deleted initializer.
	* options.h (options::String_set): New typedef.
	(options::parse_set): New function.
	(DEFINE_set): New macro.
	(General_options::wrap): Changed to use DEFINE_set. Changed
	callers of any_wrap_symbols and is_wrap_symbol.
	(General_options::trace, General_options::trace_symbol):
	New options.
	(General_options::any_wrap_symbols, General_options::is_wrap_symbol)
	(General_options::wrap_symbols_): Deleted.
	* symtab.cc (Symbol_table::add_from_object): Print trace output.
@
text
@d75 1
d109 2
a110 1
		  const elfcpp::Sym<size, big_endian>& sym)
d115 2
a116 2
  // FIXME: Handle SHN_XINDEX.
  this->u_.from_object.shndx = sym.get_st_shndx();
d182 2
a183 1
			 const elfcpp::Sym<size, big_endian>& sym)
d185 1
a185 1
  this->init_base(name, version, object, sym);
d315 1
a315 1
	if (shndx != elfcpp::SHN_UNDEF && shndx < elfcpp::SHN_LORESERVE)
d455 1
a455 1
  // We don't bother to set the st_name field.
d460 4
a463 2
  esym.put_st_shndx(from->shndx());
  this->resolve(to, esym.sym(), esym.sym(), from->object(), version);
d536 3
a538 1
// whether this is the default version.
d559 4
a562 4
// SYM and ORIG_SYM are almost always the same.  ORIG_SYM is the
// symbol exactly as it existed in the input file.  SYM is usually
// that as well, but can be modified, for instance if we determine
// it's in a to-be-discarded section.
d573 3
a575 1
			      const elfcpp::Sym<size, big_endian>& orig_sym)
d580 1
a580 1
      if (orig_sym.get_st_shndx() == elfcpp::SHN_UNDEF)
d588 1
a588 1
  if (orig_sym.get_st_shndx() == elfcpp::SHN_UNDEF
d637 2
a638 1
      this->resolve(ret, sym, orig_sym, object, version);
d684 2
a685 1
	  this->resolve(ret, sym, orig_sym, object, version);
d717 1
a717 1
	  ret->init(name, version, object, sym);
d758 1
a773 1
      elfcpp::Sym<size, big_endian>* psym = &sym;
d775 1
a775 1
      unsigned int st_name = psym->get_st_name();
d785 8
a794 3
      unsigned char symbuf[sym_size];
      elfcpp::Sym<size, big_endian> sym2(symbuf);
      unsigned int st_shndx = psym->get_st_shndx();
d796 1
a796 1
	  && st_shndx < elfcpp::SHN_LORESERVE
d798 1
a798 6
	{
	  memcpy(symbuf, p, sym_size);
	  elfcpp::Sym_write<size, big_endian> sw(symbuf);
	  sw.put_st_shndx(elfcpp::SHN_UNDEF);
	  psym = &sym2;
	}
d824 1
a824 1
	       && psym->get_st_shndx() != elfcpp::SHN_UNDEF)
d840 3
d845 1
a845 2
	  if (psym != &sym2)
	    memcpy(symbuf, p, sym_size);
d847 1
a847 3
	  sw.put_st_shndx(elfcpp::SHN_ABS);
	  if (st_shndx != elfcpp::SHN_UNDEF
	      && st_shndx < elfcpp::SHN_LORESERVE)
d855 2
a856 2
	      sw.put_st_value(sym2.get_st_value()
			      + relobj->section_address(st_shndx));
d858 2
d869 2
a870 1
				      false, *psym, sym);
d883 2
a884 1
				      def, *psym, sym);
d955 4
d966 2
a967 1
				      false, sym, sym);
d986 1
a986 1
	      && sym.get_st_shndx() != elfcpp::SHN_UNDEF)
d1001 2
a1002 1
					  false, sym, sym);
d1029 2
a1030 1
	      if (sym.get_st_shndx() == elfcpp::SHN_ABS
d1033 2
a1034 1
					    false, sym, sym);
d1038 1
a1038 2
				    && (sym.get_st_shndx()
					!= elfcpp::SHN_UNDEF));
d1040 2
a1041 1
					      version_key, def, sym, sym);
d1048 2
a1049 1
      if (sym.get_st_shndx() != elfcpp::SHN_UNDEF
d1074 8
a1081 2
  if (s1->shndx() != s2->shndx())
    return s1->shndx() < s2->shndx();
d1124 2
a1125 1
	  if ((*q)->shndx() != from_sym->shndx()
d1832 2
a1833 1
	unsigned int shndx = sym->shndx();
d1836 1
a1836 1
	if (shndx >= elfcpp::SHN_LORESERVE
d1853 2
a1854 1
	else if (shndx == elfcpp::SHN_ABS || shndx == elfcpp::SHN_COMMON)
d1940 4
a1943 1
			    const Stringpool* dynpool, Output_file* of) const
d1950 2
a1951 1
                                           dynpool, of);
d1957 2
a1958 1
                                          dynpool, of);
d1964 2
a1965 1
                                           dynpool, of);
d1971 2
a1972 1
                                          dynpool, of);
d1987 2
d2043 2
a2044 1
	    unsigned int in_shndx = sym->shndx();
d2047 1
a2047 1
	    if (in_shndx >= elfcpp::SHN_LORESERVE
d2065 3
a2067 2
			 || in_shndx == elfcpp::SHN_ABS
			 || in_shndx == elfcpp::SHN_COMMON)
d2078 9
d2098 8
d2189 1
d2192 1
a2192 1
      && sym->shndx() == elfcpp::SHN_UNDEF
d2211 1
d2219 2
a2220 1
      this->sized_write_section_symbol<32, false>(os, of, offset);
d2225 2
a2226 1
      this->sized_write_section_symbol<32, true>(os, of, offset);
d2231 2
a2232 1
      this->sized_write_section_symbol<64, false>(os, of, offset);
d2237 2
a2238 1
      this->sized_write_section_symbol<64, true>(os, of, offset);
d2251 1
d2266 8
a2273 1
  osym.put_st_shndx(os->out_shndx());
d2437 1
d2450 1
d2463 1
d2476 1
@


1.92
log
@	* common.cc (Symbol_table::allocate_commons): Remove options
	parameter.  Change caller.
	(Symbol_table::do_allocate_commons): Remove options parameter.
	Change caller.  Just call do_allocate_commons_list twice.
	(Symbol_table::do_allocate_commons_list): New function, broken out
	of do_allocate_commons.
	* common.h (class Allocate_commons_task): Remove options_ field.
	Update constructor.
	* symtab.cc (Symbol_table::Symbol_table): Initialize
	tls_commons_.
	(Symbol_table::add_from_object): Put TLS common symbols on
	tls_commons_ list.
	(Symbol_table::sized_finalize_symbol): Handle STT_TLS symbols
	which are IN_OUTPUT_DATA.
	* symtab.h (class Symbol_table): Add tls_commons_ field.  Update
	allocate_commons and do_allocate_commons declarations.  Declare
	do_allocate_commons_list.
	* gold.cc (queue_middle_tasks): Update creation of
	Allocate_commons_task to not pass options.
	* testsuite/Makefile.am (INCLUDES): Add -I.. .
	(TLS_TEST_C_FLAGS): New variable.
	(tls_test_c_pic.o): New target.
	(tls_test_shared.so): Link in tls_test_c_pic.o.
	(tls_test_c_pic_ie.o): New target.
	(tls_test_ie_shared.so): Link in tls_test_c_pic_ie.o.
	(tls_test_DEPENDENCIES, tls_test_LDADD): Add tls_test_c.o.
	(tls_test_c.o): New target.
	(tls_pic_test_DEPENDENCIES): Add tls_test_c_pic.o.
	(tls_pic_test_LDADD): Likewise.
	(tls_shared_gd_to_ie_test_DEPENDENCIES): Add tls_test_c_pic.o.
	(tls_shared_gd_to_ie_test_LDADD): Likewise.
	(tls_test_c_gnu2.o): New target.
	(tls_shared_gnu2_gd_to_ie_test_DEPENDENCIES): Add
	tls_test_c_gnu2.o.
	(tls_shared_gnu2_gd_to_ie_test_LDADD): Likewise.
	(tls_test_gnu2_shared.so): Link in tls_test_c_gnu2.o.
	(tls_test_shared_nonpic.so): Link in tls_test_c.o.
	* testsuite/tls_test.cc: Include "config.h".
	(t_last): Call t11_last.
	* testsuite/tls_test.h (t11, t11_last): Declare.
	* testsuite/tls_test_c.c: New file.
	* testsuite/tls_test_main.cc (thread_routine): Call t11.
	* configure.ac: Check for OpenMP support.
	* configure, config.in, Makefile.in: Rebuild.
	* testsuite/Makefile.in: Rebuild.
@
text
@d498 1
a498 1
  if (parameters->options().is_wrap_symbol(name))
d516 1
a516 1
      && parameters->options().is_wrap_symbol(name + real_prefix_length))
d568 9
d580 1
a580 1
      && parameters->options().any_wrap_symbols())
@


1.91
log
@	* i386.cc (Target_i386::define_tls_base_symbol): New function.
	(Target_i386::tls_base_symbol_defined_): New field.
	(Target_i386::Scan::local): Define _TLS_MODULE_BASE_ symbol.
	(Target_i386::Scan::global): Likewise.
	* symtab.cc (sized_finalize_symbol): Add check for TLS symbol.
	* x86_64.cc (Target_x86_64::define_tls_base_symbol): New function.
	(Target_x86_64::tls_base_symbol_defined_): New field.
	(Target_x86_64::Scan::local): Define _TLS_MODULE_BASE_ symbol.
	(Target_x86_64::Scan::global): Likewise.
@
text
@d363 1
a363 1
    forwarders_(), commons_(), forced_locals_(), warnings_(),
d718 6
a723 1
    this->commons_.push_back(ret);
d1838 9
a1846 1
	value = sym->value() + od->address();
@


1.90
log
@Fix typo in comment in last commit.
@
text
@d1842 3
a1844 1
	value = sym->value() + os->vaddr();
@


1.89
log
@	* symtab.cc (Symbol_table::add_from_dynobj): Only look for weak
	aliases for symbols defined in the same object.
	* testsuite/Makefile.am (check_PROGRAMS): Add weak_alias_test.
	(weak_alias_test_SOURCES): New variable.
	(weak_alias_test_DEPENDENCIES): New variable.
	(weak_alias_test_LDFLAGS): New variable.
	(weak_alias_test_LDADD): New variable.
	(weak_alias_test_1_pic.o, weak_alias_test_1.so): New targets.
	(weak_alias_test_2_pic.o, weak_alias_test_2.so): New targets.
	(weak_alias_test_3.o): New target.
	(weak_alias_test_4_pic.o, weak_alias_test_4.so): New targets.
	* testsuite/weak_alias_test_main.cc: New file.
	* testsuite/weak_alias_test_1.cc: New file.
	* testsuite/weak_alias_test_2.cc: New file.
	* testsuite/weak_alias_test_3.cc: New file.
@
text
@d1010 1
a1010 1
      // earlier object, in which case it can be aliased here.
@


1.88
log
@	* options.h (class General_options): Define --wrap as a special
	option.  Add wrap_symbols_ field.
	(General_options::any_wrap_symbols): New function.
	(General_options::is_wrap_symbol): New function.
	* options.cc (General_options::parse_wrap): New function.
	(General_options::General_options): Initialize wrap_symbols_.
	* symtab.cc (Symbol_table::wrap_symbol): New function.
	(Symbol_table::add_from_object): Handle --wrap.
	* symtab.h (class Symbol_table): Declare wrap_symbol.
	* target.h (Target::wrap_char): New function.
	(Target::Target_info): Add wrap_char field.
	* i386.cc (Target_i386::i386_info): Initialize wrap_char.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Likewise.
@
text
@d1009 2
d1012 3
a1014 1
	  && sym.get_st_type() == elfcpp::STT_OBJECT)
@


1.87
log
@	* symtab.cc (Symbol_table::do_define_as_constant): Don't force a
	version symbol to be local.
	* testsuite/ver_test_4.sh: New file.
	* testsuite/Makefile.am (check_SCRIPTS): Add ver_test_4.sh.
	(check_DATA): Add ver_test_4.syms.
	(ver_test_4.syms): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d481 48
d568 19
@


1.86
log
@	* symtab.cc (Symbol_table::add_from_object): If we don't use the
	new symbol when resolving, don't call set_is_default.
	* testsuite/ver_test_7.cc: New file.
	* testsuite/ver_test_7.sh: New file.
	* testsuite/Makefile.am (ver_test_7.so): New target.
	(ver_test_7.o): New target.
	(check_SCRIPTS): Add ver_test_7.sh.
	(check_DATA): Add ver_test_7.syms.
	(ver_test_7.syms): New target.
@
text
@d1409 7
a1415 2
      if (binding == elfcpp::STB_LOCAL
	  || this->version_script_.symbol_is_local(name))
@


1.85
log
@	* symtab.cc (Symbol_table::add_from_object): Handle saw_undefined_
	and commons_ correctly when NAME/VERSION does not override
	NAME/NULL.
	* testsuite/ver_test_6.c: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add ver_test_6
	(ver_test_6_SOURCES, ver_test_6_DEPENDENCIES): New variables.
	(ver_test_6_LDFLAGS, ver_test_6_LDADD): New variables.
@
text
@d580 2
@


1.84
log
@	* symtab.cc (Symbol_table::add_from_relobj): Don't set the version
	of an undefined symbol from a version script.
	* testsuite/Makefile.am (ver_test_5.so): New target.
	(ver_test_5.o): New target.
	(check_SCRIPTS): Add ver_test_5.sh.
	(check_DATA): Add ver_test_5.syms.
	(ver_test_5.syms): New target.
	* testsuite/ver_test_5.cc: New file.
	* testsuite/ver_test_5.script: New file.
	* testsuite/ver_test_5.sh: New file.
	* Makefile.in, testsuite/Makefile.in: Rebuild.
@
text
@a586 3
      was_undefined = false;
      was_common = false;

d592 4
d601 3
@


1.83
log
@	PR gold/5986
	Fix problems building gold with gcc 4.3.0.
	* gold.h (TEMPLATE_ATTRIBUTE_PRINTF_4): Define.
	(gold_error_at_location, gold_warning_at_location): Use it.
	* configure.ac: Check whether we can compile and use a template
	function with a printf attribute.
	* x86_64.cc (Target_x86_64::do_code_fill): Swap out a 32-bit value
	when jumping over bytes.
	* object.cc: Instantiate Object::read_section_data.
	* debug.h: Include <cstring>
	* dwarf_reader.cc: Include <algorithm>
	* main.cc: Include <cstring>.
	* options.cc: Include <cstring>.
	* output.cc: Include <cstring>.
	* script.cc: Include <cstring>.
	* script.h: Include <string>.
	* symtab.cc: Include <cstring> and <algorithm>.
	* target-select.cc: Include <cstring>.
	* version.cc: Include <string>.
	* testsuite/testmain.cc: Include <cstdlib>.
	* configure, config.in: Rebuild.
@
text
@d722 5
a726 1
      else if (!version_script_.empty())
@


1.82
log
@	* i386.cc (Target_i386::Got_type): New enum declaration.
	(Target_i386::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocate::relocate_tls): Likewise.
	* object.h (Got_offset_list): New class.
	(Sized_relobj::local_has_got_offset): Added got_type parameter.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::local_has_tls_got_offset): Removed.
	(Sized_relobj::local_tls_got_offset): Removed.
	(Sized_relobj::set_local_tls_got_offset): Removed.
	(Sized_relobj::Local_got_offsets): Changed to store a list of offsets.
	* output.cc (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* output.h (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* resolve.cc (Symbol::override_base_with_special): Removed
	reference to has_got_offset_ field.
	* symtab.cc (Symbol::init_fields): Replaced initialization
	of got_offset_ with got_offsets_.  Removed initialization
	of has_got_offset_
	*symtab.h (Symbol::has_got_offset): Aded got_type parameter.
	(Symbol::got_offset): Likewise.
	(Symbol::set_got_offset): Likewise.
	(Symbol::has_tls_got_offset): Removed.
	(Symbol::tls_got_offset): Removed.
	(Symbol::set_tls_got_offset): Removed.
	(Symbol::got_offset_): Removed.
	(Symbol::tls_mod_got_offset_): Removed.
	(Symbol::tls_pair_got_offset_): Removed.
	(Symbol::got_offsets_): New field.
	(Symbol::has_got_offset): Removed.
	(Symbol::has_tls_mod_got_offset): Removed.
	(Symbol::has_tls_pair_got_offset): Removed.
	* x86_64.cc (Target_x86_64::Got_type): New enum declaration.
	(Target_x86_64::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocate::relocate_tls): Likewise.
@
text
@d25 1
d27 1
@


1.81
log
@	* options.cc: Include "demangle.h".
	(parse_optional_string): New function.
	(parse_long_option): Handle takes_optional_argument.
	(parse_short_option): Update dash_z initializer.  Handle
	takes_optional_argument.
	(General_options::General_options): Initialize do_demangle_.
	(General_options::finalize): Set do_demangle_.  Handle demangling
	style.
	* options.h (parse_optional_string): Declare.
	(struct One_option): Add optional_arg field.  Update constructor.
	Update call constructor calls.  Add takes_optional_argument
	function.
	(DEFINE_var): Add optional_arg__ parameter.  Change all callers.
	(DEFINE_optional_string): Define.
	(General_options::demangle): Change from DEFINE_bool to
	DEFINE_optional_string.
	(General_options::no_demangle): New function.
	(General_options::do_demangle): New function.
	(General_options::set_do_demangle): New function.
	(General_options::execstack_status_): Move definition to end of
	class definition.
	(General_options::static_): Likewise.
	(General_options::do_demangle_): New field.
	* object.cc (big_endian>::get_symbol_location_info): Call
	Options::do_demangle, not Options::demangle.
	* symtab.cc (demangle): Likewise.
@
text
@d56 1
a56 1
  this->got_offset_ = 0;
a68 1
  this->has_got_offset_ = false;
@


1.80
log
@Don't get confused about whether a symbol is the default version if we
see a later reference to it.  Add tests for this case.
@
text
@d82 1
a82 1
  if (!parameters->options().demangle())
@


1.79
log
@Remove gcc 3.2 compatibility hacks.
@
text
@d646 2
a647 1
  ret->set_is_default(def);
@


1.78
log
@Support -d/--define-common.
@
text
@d447 1
a447 1
		      const char* version ACCEPT_SIZE_ENDIAN)
d545 1
a545 2
      ret = this->get_sized_symbol SELECT_SIZE_NAME(size) (ins.first->second
                                                           SELECT_SIZE(size));
d574 2
a575 5
	      sym2 = this->get_sized_symbol SELECT_SIZE_NAME(size) (
		insdef.first->second
                SELECT_SIZE(size));
	      Symbol_table::resolve SELECT_SIZE_ENDIAN_NAME(size, big_endian) (
		ret, sym2, version SELECT_SIZE_ENDIAN(size, big_endian));
d593 1
a593 3
	  ret = this->get_sized_symbol SELECT_SIZE_NAME(size) (
              insdef.first->second
              SELECT_SIZE(size));
d600 1
a600 2
	    object->sized_target SELECT_SIZE_ENDIAN_NAME(size, big_endian) (
		SELECT_SIZE_ENDIAN_ONLY(size, big_endian));
d1025 1
a1025 2
                                    Sized_symbol<size>** poldsym
                                    ACCEPT_SIZE_ENDIAN)
d1102 1
a1102 2
  *poldsym = this->get_sized_symbol SELECT_SIZE_NAME(size) (oldsym
                                                            SELECT_SIZE(size));
d1173 2
a1174 3
      sym = this->define_special_symbol SELECT_SIZE_ENDIAN_NAME(size, true) (
          &name, &version, only_if_ref, &oldsym
          SELECT_SIZE_ENDIAN(size, true));
d1182 2
a1183 3
      sym = this->define_special_symbol SELECT_SIZE_ENDIAN_NAME(size, false) (
          &name, &version, only_if_ref, &oldsym
          SELECT_SIZE_ENDIAN(size, false));
d1273 2
a1274 3
      sym = this->define_special_symbol SELECT_SIZE_ENDIAN_NAME(size, true) (
          &name, &version, only_if_ref, &oldsym
          SELECT_SIZE_ENDIAN(size, true));
d1282 2
a1283 3
      sym = this->define_special_symbol SELECT_SIZE_ENDIAN_NAME(size, false) (
          &name, &version, only_if_ref, &oldsym
          SELECT_SIZE_ENDIAN(size, false));
d1373 2
a1374 3
      sym = this->define_special_symbol SELECT_SIZE_ENDIAN_NAME(size, true) (
          &name, &version, only_if_ref, &oldsym
          SELECT_SIZE_ENDIAN(size, true));
d1382 2
a1383 3
      sym = this->define_special_symbol SELECT_SIZE_ENDIAN_NAME(size, false) (
          &name, &version, only_if_ref, &oldsym
          SELECT_SIZE_ENDIAN(size, false));
d1952 2
a1953 3
	  this->sized_write_symbol SELECT_SIZE_ENDIAN_NAME(size, big_endian) (
	      sym, sym_value, shndx, sympool, ps
              SELECT_SIZE_ENDIAN(size, big_endian));
d1961 2
a1962 3
	  this->sized_write_symbol SELECT_SIZE_ENDIAN_NAME(size, big_endian) (
	      sym, dynsym_value, shndx, dynpool, pd
              SELECT_SIZE_ENDIAN(size, big_endian));
d1981 1
a1981 2
    unsigned char* p
    ACCEPT_SIZE_ENDIAN) const
@


1.77
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d1718 2
a1719 1
	    && shndx != elfcpp::SHN_ABS)
d1734 1
a1734 1
	else if (shndx == elfcpp::SHN_ABS)
d1908 2
a1909 1
		&& in_shndx != elfcpp::SHN_ABS)
d1925 2
a1926 1
			 || in_shndx == elfcpp::SHN_ABS)
@


1.76
log
@Assignments in linker scripts override definitions from object files.
@
text
@d82 1
a82 1
  if (!parameters->demangle())
d260 1
a260 1
  if ((parameters->export_dynamic() || parameters->output_is_shared())
d276 1
a276 1
  if (!parameters->output_is_executable())
d670 1
a670 1
  gold_assert(size == parameters->get_size());
d805 1
a805 1
  gold_assert(size == parameters->get_size());
d1090 2
a1091 2
  const Target* target = parameters->target();
  if (!target->has_make_symbol())
d1095 2
a1096 2
      gold_assert(target->get_size() == size);
      gold_assert(target->is_big_endian() ? big_endian : !big_endian);
d1099 1
a1099 1
          static_cast<const My_target*>(target);
d1131 1
a1131 1
  if (parameters->get_size() == 32)
d1143 1
a1143 1
  else if (parameters->get_size() == 64)
d1179 1
a1179 1
  if (parameters->is_big_endian())
d1235 1
a1235 1
  if (parameters->get_size() == 32)
d1246 1
a1246 1
  else if (parameters->get_size() == 64)
d1281 1
a1281 1
  if (parameters->is_big_endian())
d1338 1
a1338 1
  if (parameters->get_size() == 32)
d1349 1
a1349 1
  else if (parameters->get_size() == 64)
d1383 1
a1383 1
  if (parameters->is_big_endian())
d1601 1
a1601 1
  if (parameters->get_size() == 32)
d1609 1
a1609 1
  else if (parameters->get_size() == 64)
d1795 1
a1795 1
  if (parameters->strip_all())
d1811 1
a1811 1
  if (parameters->get_size() == 32)
d1813 6
a1818 2
      if (parameters->is_big_endian())
	{
d1820 4
a1823 4
	  this->sized_write_globals<32, true>(input_objects, sympool,
					      dynpool, of);
#else
	  gold_unreachable();
d1825 5
a1829 8
	}
      else
	{
#ifdef HAVE_TARGET_32_LITTLE
	  this->sized_write_globals<32, false>(input_objects, sympool,
					       dynpool, of);
#else
	  gold_unreachable();
a1830 6
	}
    }
  else if (parameters->get_size() == 64)
    {
      if (parameters->is_big_endian())
	{
d1832 4
a1835 4
	  this->sized_write_globals<64, true>(input_objects, sympool,
					      dynpool, of);
#else
	  gold_unreachable();
d1837 2
a1838 10
	}
      else
	{
#ifdef HAVE_TARGET_64_LITTLE
	  this->sized_write_globals<64, false>(input_objects, sympool,
					       dynpool, of);
#else
	  gold_unreachable();
#endif
	}
a1839 2
  else
    gold_unreachable();
d1851 1
a1851 1
  const Target* const target = parameters->target();
d1919 1
a1919 1
		      dynsym_value = target->dynsym_value(sym);
d1936 1
a1936 1
		    if (parameters->output_is_object())
d2035 2
a2036 2
      && !parameters->allow_shlib_undefined()
      && !parameters->target()->is_defined_by_abi(sym)
d2055 1
a2055 1
  if (parameters->get_size() == 32)
d2057 5
a2061 2
      if (parameters->is_big_endian())
	{
d2063 3
a2065 3
	  this->sized_write_section_symbol<32, true>(os, of, offset);
#else
	  gold_unreachable();
d2067 4
a2070 7
	}
      else
	{
#ifdef HAVE_TARGET_32_LITTLE
	  this->sized_write_section_symbol<32, false>(os, of, offset);
#else
	  gold_unreachable();
a2071 6
	}
    }
  else if (parameters->get_size() == 64)
    {
      if (parameters->is_big_endian())
	{
d2073 3
a2075 3
	  this->sized_write_section_symbol<64, true>(os, of, offset);
#else
	  gold_unreachable();
d2077 2
a2078 9
	}
      else
	{
#ifdef HAVE_TARGET_64_LITTLE
	  this->sized_write_section_symbol<64, false>(os, of, offset);
#else
	  gold_unreachable();
#endif
	}
a2079 2
  else
    gold_unreachable();
@


1.75
log
@Track sections for expressions.
@
text
@d1335 2
a1336 1
				 bool only_if_ref)
d1343 2
a1344 1
                                             visibility, nonvis, only_if_ref);
d1354 2
a1355 1
                                             visibility, nonvis, only_if_ref);
d1377 2
a1378 1
    bool only_if_ref)
d1418 1
a1418 1
  if (Symbol_table::should_override_with_special(oldsym))
d1443 2
a1444 1
				 only_if_ref || p->only_if_ref);
d1469 2
a1470 1
				 only_if_ref || p->only_if_ref);
@


1.74
log
@Even when stripping all symbols, we need to write out the dynamic
symbol table.
@
text
@d301 1
a301 1
// Return whether the symbol has an absolute value.
d303 2
a304 2
bool
Symbol::value_is_absolute() const
d309 12
a320 1
      return this->u_.from_object.shndx == elfcpp::SHN_ABS;
d322 2
a324 1
      return false;
d326 26
a351 1
      return true;
@


1.73
log
@Implement --just-symbols, including -R FILE.  Fix symbol values when
doing a relocatable link.
@
text
@d1830 5
a1834 1
  unsigned char* const psyms = of->get_output_view(this->offset_, oview_size);
d1841 1
a1841 1
  if (this->dynamic_offset_ == 0)
@


1.72
log
@Support creating empty output when there are no input objects.
@
text
@d637 2
d706 21
d770 6
d1865 2
a1866 1
      typename elfcpp::Elf_types<32>::Elf_Addr value = sym->value();
d1887 1
a1887 1
		      value = target->dynsym_value(sym);
d1901 5
d1933 1
a1933 1
	      sym, sym->value(), shndx, sympool, ps
d1943 1
a1943 1
	      sym, value, shndx, dynpool, pd
@


1.71
log
@Fully implement the SECTIONS clause.
@
text
@d1794 1
a1794 1
  const Target* const target = input_objects->target();
d1969 1
a1969 1
      && !input_objects->target()->is_defined_by_abi(sym)
@


1.70
log
@From Cary Coutant: Ignore hidden symbols in a dynamic object.
@
text
@d301 19
d1358 2
a1359 1
			     const Define_symbol_in_section* p)
d1368 2
a1369 1
				    p->offset_is_from_end, p->only_if_ref);
d1373 1
a1373 1
				 p->only_if_ref);
d1381 2
a1382 1
			     const Define_symbol_in_segment* p)
d1393 2
a1394 1
				       p->offset_base, p->only_if_ref);
d1398 1
a1398 1
				 p->only_if_ref);
@


1.69
log
@Don't pass around the target in order to define symbols; get it from
the parameters instead.
@
text
@d752 5
a756 2
      // Ignore symbols with local binding.
      if (sym.get_st_bind() == elfcpp::STB_LOCAL)
@


1.68
log
@Originally from Craig Silverstein, with changes: support using a
version script to force symbols to be local.
@
text
@d942 2
a943 2
Symbol_table::define_special_symbol(const Target* target, const char** pname,
				    const char** pversion, bool only_if_ref,
d1002 1
d1031 7
a1037 4
Symbol_table::define_in_output_data(const Target* target, const char* name,
				    const char* version, Output_data* od,
				    uint64_t value, uint64_t symsize,
				    elfcpp::STT type, elfcpp::STB binding,
d1046 1
a1046 1
      return this->do_define_in_output_data<32>(target, name, version, od,
d1058 1
a1058 1
      return this->do_define_in_output_data<64>(target, name, version, od,
a1075 1
    const Target* target,
d1095 1
a1095 1
          target, &name, &version, only_if_ref, &oldsym
d1105 1
a1105 1
          target, &name, &version, only_if_ref, &oldsym
d1136 1
a1136 1
Symbol_table::define_in_output_segment(const Target* target, const char* name,
d1138 4
a1141 2
				       uint64_t value, uint64_t symsize,
				       elfcpp::STT type, elfcpp::STB binding,
d1150 1
a1150 1
      return this->do_define_in_output_segment<32>(target, name, version, os,
d1161 1
a1161 1
      return this->do_define_in_output_segment<64>(target, name, version, os,
a1177 1
    const Target* target,
d1197 1
a1197 1
          target, &name, &version, only_if_ref, &oldsym
d1207 1
a1207 1
          target, &name, &version, only_if_ref, &oldsym
d1239 9
a1247 5
Symbol_table::define_as_constant(const Target* target, const char* name,
				 const char* version, uint64_t value,
				 uint64_t symsize, elfcpp::STT type,
				 elfcpp::STB binding, elfcpp::STV visibility,
				 unsigned char nonvis, bool only_if_ref)
d1252 1
a1252 1
      return this->do_define_as_constant<32>(target, name, version, value,
d1262 1
a1262 1
      return this->do_define_as_constant<64>(target, name, version, value,
a1277 1
    const Target* target,
d1295 1
a1295 1
          target, &name, &version, only_if_ref, &oldsym
d1305 1
a1305 1
          target, &name, &version, only_if_ref, &oldsym
d1335 2
a1336 2
Symbol_table::define_symbols(const Layout* layout, const Target* target,
			     int count, const Define_symbol_in_section* p)
d1342 1
a1342 1
	this->define_in_output_data(target, p->name, NULL, os, p->value,
d1347 1
a1347 1
	this->define_as_constant(target, p->name, NULL, 0, p->size, p->type,
d1356 2
a1357 2
Symbol_table::define_symbols(const Layout* layout, const Target* target,
			     int count, const Define_symbol_in_segment* p)
d1365 1
a1365 1
	this->define_in_output_segment(target, p->name, NULL, os, p->value,
d1370 1
a1370 1
	this->define_as_constant(target, p->name, NULL, 0, p->size, p->type,
a1382 1
    const Target* target,
d1399 1
a1399 1
  this->define_in_output_data(target, csym->name(), csym->version(),
d1447 1
a1447 2
Symbol_table::set_dynsym_indexes(const Target* target,
				 unsigned int index,
d1479 1
a1479 1
  index = versions->finalize(target, this, index, syms);
a2287 1
    const Target* target,
a2296 1
    const Target* target,
@


1.67
log
@From Andrew Chatham and Craig Silverstein: Add support for version
scripts.
@
text
@d73 1
d253 4
d306 2
a307 1
    forwarders_(), commons_(), warnings_(), version_script_(version_script)
d408 16
d654 1
d656 1
d675 1
d680 3
d692 2
d952 9
d1117 6
a1122 1
    return sym;
d1218 6
a1223 1
    return sym;
d1312 6
a1317 1
    return sym;
d1480 3
a1482 2
// global symbol in the output file is INDEX.  Record the file offset
// OFF.  Add their names to POOL.  Return the new file offset.
d1485 3
a1487 3
Symbol_table::finalize(unsigned int index, off_t off, off_t dynoff,
		       size_t dyn_global_index, size_t dyncount,
		       Stringpool* pool)
d1491 2
a1492 2
  gold_assert(index != 0);
  this->first_global_index_ = index;
d1501 1
a1501 1
      ret = this->sized_finalize<32>(index, off, pool);
d1509 1
a1509 1
      ret = this->sized_finalize<64>(index, off, pool);
d1524 14
d1544 2
a1545 1
Symbol_table::sized_finalize(unsigned index, off_t off, Stringpool* pool)
d1550 2
a1551 1
  size_t orig_index = index;
d1553 16
a1568 1
  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;
d1573 4
a1576 1
      Sized_symbol<size>* sym = static_cast<Sized_symbol<size>*>(p->second);
d1578 1
a1578 2
      // FIXME: Here we need to decide which symbols should go into
      // the output file, based on --strip.
d1580 2
a1581 4
      // The default version of a symbol may appear twice in the
      // symbol table.  We only need to finalize it once.
      if (sym->has_symtab_index())
	continue;
d1583 2
a1584 7
      if (!sym->in_reg())
	{
	  gold_assert(!sym->has_symtab_index());
	  sym->set_symtab_index(-1U);
	  gold_assert(sym->dynsym_index() == -1U);
	  continue;
	}
d1586 5
a1590 1
      typename Sized_symbol<size>::Value_type value;
d1592 4
a1595 5
      switch (sym->source())
	{
	case Symbol::FROM_OBJECT:
	  {
	    unsigned int shndx = sym->shndx();
d1597 7
a1603 8
	    // FIXME: We need some target specific support here.
	    if (shndx >= elfcpp::SHN_LORESERVE
		&& shndx != elfcpp::SHN_ABS)
	      {
		gold_error(_("%s: unsupported symbol section 0x%x"),
			   sym->demangled_name().c_str(), shndx);
		shndx = elfcpp::SHN_UNDEF;
	      }
d1605 1
a1605 15
	    Object* symobj = sym->object();
	    if (symobj->is_dynamic())
	      {
		value = 0;
		shndx = elfcpp::SHN_UNDEF;
	      }
	    else if (shndx == elfcpp::SHN_UNDEF)
	      value = 0;
	    else if (shndx == elfcpp::SHN_ABS)
	      value = sym->value();
	    else
	      {
		Relobj* relobj = static_cast<Relobj*>(symobj);
		section_offset_type secoff;
		Output_section* os = relobj->output_section(shndx, &secoff);
d1607 5
a1611 6
		if (os == NULL)
		  {
		    sym->set_symtab_index(-1U);
		    gold_assert(sym->dynsym_index() == -1U);
		    continue;
		  }
d1613 7
a1619 5
                if (sym->type() == elfcpp::STT_TLS)
                  value = sym->value() + os->tls_offset() + secoff;
                else
		  value = sym->value() + os->address() + secoff;
	      }
a1620 1
	  break;
d1622 2
a1623 1
	case Symbol::IN_OUTPUT_DATA:
d1625 2
a1626 4
	    Output_data* od = sym->output_data();
	    value = sym->value() + od->address();
	    if (sym->offset_is_from_end())
	      value += od->data_size();
d1628 9
a1636 1
	  break;
d1638 1
a1638 5
	case Symbol::IN_OUTPUT_SEGMENT:
	  {
	    Output_segment* os = sym->output_segment();
	    value = sym->value() + os->vaddr();
	    switch (sym->offset_base())
d1640 3
a1642 10
	      case Symbol::SEGMENT_START:
		break;
	      case Symbol::SEGMENT_END:
		value += os->memsz();
		break;
	      case Symbol::SEGMENT_BSS:
		value += os->filesz();
		break;
	      default:
		gold_unreachable();
d1644 34
d1679 2
a1680 1
	  break;
d1682 3
a1684 3
	case Symbol::CONSTANT:
	  value = sym->value();
	  break;
d1686 3
a1688 3
	default:
	  gold_unreachable();
	}
d1690 1
a1690 1
      sym->set_value(value);
d1692 4
a1695 9
      if (parameters->strip_all())
	sym->set_symtab_index(-1U);
      else
	{
	  sym->set_symtab_index(index);
	  pool->add(sym->name(), false, NULL);
	  ++index;
	  off += sym_size;
	}
d1698 1
a1698 3
  this->output_count_ = index - orig_index;

  return off;
d1766 4
a1769 2
  unsigned int index = this->first_global_index_;
  const off_t oview_size = this->output_count_ * sym_size;
d1772 4
a1775 3
  unsigned int dynamic_count = this->dynamic_count_;
  off_t dynamic_size = dynamic_count * sym_size;
  unsigned int first_dynamic_global_index = this->first_dynamic_global_index_;
a1781 1
  unsigned char* ps = psyms;
a1803 12
      if (sym_index == index)
	++index;
      else if (sym_index != -1U)
	{
	  // We have already seen this symbol, because it has a
	  // default version.
	  gold_assert(sym_index < index);
	  if (dynsym_index == -1U)
	    continue;
	  sym_index = -1U;
	}

d1863 3
a1868 1
	  ps += sym_size;
a1881 2
  gold_assert(ps - psyms == oview_size);

d1904 5
a1908 1
  osym.put_st_info(elfcpp::elf_st_info(sym->binding(), sym->type()));
@


1.66
log
@Support assignments and expressions in linker scripts.
@
text
@d298 2
a299 1
Symbol_table::Symbol_table(unsigned int count)
d301 1
a301 1
    forwarders_(), commons_(), warnings_()
d575 1
d631 25
d668 1
a668 1
	  name = this->namepool_.add_with_length(name, ver - name, true,
a669 9

	  bool def = false;
	  ++ver;
	  if (*ver == '@@')
	    {
	      def = true;
	      ++ver;
	    }

d1259 1
a1259 1
  gold_assert(version == NULL || oldsym != NULL);
d1413 2
a1414 2
	  if (sym->version() != NULL)
	    versions->record_version(this, dynpool, sym);
@


1.65
log
@Reduce the number of system calls.  Use readv instead of pread.  Do
better handling of cached views.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
d1059 4
a1062 2
  if (oldsym != NULL
      && Symbol_table::should_override_with_special(oldsym))
d1064 2
a1065 2

  return sym;
d1155 4
a1158 2
  if (oldsym != NULL
      && Symbol_table::should_override_with_special(oldsym))
d1160 2
a1161 2

  return sym;
d1244 4
a1247 2
  if (oldsym != NULL
      && Symbol_table::should_override_with_special(oldsym))
d1249 2
a1250 2

  return sym;
@


1.64
log
@From Cary Coutant: Fix handling of versioned symbols, add some tests.
@
text
@d1406 2
a1407 2
Symbol_table::finalize(const Task* task, unsigned int index, off_t off,
		       off_t dynoff, size_t dyn_global_index, size_t dyncount,
d1440 1
a1440 1
  this->warnings_.note_warnings(this, task);
d2007 1
a2007 1
		      unsigned int shndx)
d2010 1
a2010 1
  this->warnings_[name].set(obj, shndx);
d2018 1
a2018 1
Warnings::note_warnings(Symbol_table* symtab, const Task* task)
d2028 1
a2028 18
	{
	  sym->set_has_warning();

	  // Read the section contents to get the warning text.  It
	  // would be nicer if we only did this if we have to actually
	  // issue a warning.  Unfortunately, warnings are issued as
	  // we relocate sections.  That means that we can not lock
	  // the object then, as we might try to issue the same
	  // warning multiple times simultaneously.
	  {
	    Task_lock_obj<Object> tl(task, p->second.object);
	    const unsigned char* c;
	    section_size_type len;
	    c = p->second.object->section_contents(p->second.shndx, &len,
						   false);
	    p->second.set_text(reinterpret_cast<const char*>(c), len);
	  }
	}
@


1.63
log
@Convert more instances of off_t to be 32-bit types.
@
text
@d483 2
a484 1
	  else if (insdef.first->second != ret)
d487 8
a494 1
	      // entries for both NAME/VERSION and NAME/NULL.
@


1.62
log
@Use string length when available when calling Stringpool.  Compare
pointers first when looking up Stringpool entries.
@
text
@d1289 5
a1293 3
Symbol_table::define_with_copy_reloc(const Target* target,
				     Sized_symbol<size>* csym,
				     Output_data* posd, uint64_t value)
d2180 5
a2184 3
Symbol_table::define_with_copy_reloc<32>(const Target* target,
					 Sized_symbol<32>* sym,
					 Output_data* posd, uint64_t value);
d2190 5
a2194 3
Symbol_table::define_with_copy_reloc<64>(const Target* target,
					 Sized_symbol<64>* sym,
					 Output_data* posd, uint64_t value);
@


1.61
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d633 2
a634 1
	  name = this->namepool_.add_prefix(name, ver - name, &name_key);
@


1.60
log
@Rewrite workqueue.  This version eliminates the master thread, and
reduces the amount of locking required to find a new thread to run.
@
text
@d1500 1
a1500 1
		off_t secoff;
d1717 1
a1717 1
		    off_t secoff;
d2029 1
a2029 1
	    off_t len;
@


1.59
log
@From Craig Silverstein: size hash tables to avoid resizing.
@
text
@d1395 2
a1396 2
Symbol_table::finalize(unsigned int index, off_t off, off_t dynoff,
		       size_t dyn_global_index, size_t dyncount,
d1429 1
a1429 1
  this->warnings_.note_warnings(this);
d1948 2
a1949 1
Symbol_table::detect_odr_violations(const char* output_file_name) const
d1965 6
a1970 5
	  // means that we can not run inside a Task.  If we want to
	  // run this in a Task for better performance, we will need
	  // one Task for object, plus appropriate locking to ensure
	  // that we don't conflict with other uses of the object.
          locs->object->lock();
a1972 1
          locs->object->unlock();
d2007 1
a2007 1
Warnings::note_warnings(Symbol_table* symtab)
d2027 1
a2027 1
	    Task_locker_obj<Object> tl(*p->second.object);
@


1.58
log
@From Cary Coutant: Fix handling of RELATIVE RELA relocs.
@
text
@d298 2
a299 2
Symbol_table::Symbol_table()
  : saw_undefined_(0), offset_(0), table_(), namepool_(),
d302 1
@


1.57
log
@From Cary Coutant: More support for generating shared libraries.
@
text
@a72 1
  this->needs_value_in_got_ = false;
@


1.56
log
@Stringpool stats.  Also make Symbol_table support functions inline.
@
text
@d1510 4
a1513 1
		value = sym->value() + os->address() + secoff;
d1926 1
a1926 1
// Dwarf_line_info::one_addr2line.  It imlements a < comparison
@


1.55
log
@Print symbol table statistics with --stats.
@
text
@d309 1
a309 2
// The hash function.  The key is always canonicalized, so we use a
// simple combination of the pointers.
d311 1
a311 1
size_t
d317 2
a318 3
// The symbol table key equality function.  This is only called with
// canonicalized name and version strings, so we can use pointer
// comparison.
d320 1
a320 1
bool
d1910 1
@


1.54
log
@Add threading support.
@
text
@d1900 14
@


1.53
log
@From Craig Silverstein: Quote the symbol name in the ODR violation
message to avoid a gcc collect2 demangling bug.
@
text
@d162 11
d233 10
d2040 12
@


1.52
log
@When looking for ODR violations, only check the file base name.  Also,
never demangle if --no-demangle was used.
@
text
@d308 1
a308 1
// Make TO a symbol which forwards to FROM.  
d1941 1
a1941 1
          gold_warning(_("while linking %s: symbol %s defined in multiple "
@


1.51
log
@Workaround bug in gcc 4.0.3 STL.
@
text
@d82 3
d99 1
a99 4
  if (parameters->demangle())
    return demangle(name());
  else
    return name();
d1879 28
d1919 1
a1919 1
      std::set<std::string> line_nums;
@


1.50
log
@From Craig Silverstein: Add support for --demangle.
@
text
@d1893 4
a1896 3
      Unordered_set<Symbol_location, Symbol_location_hash>::const_iterator
	locs;
      for (locs = it->second.begin(); locs != it->second.end(); ++locs)
@


1.49
log
@From Craig Silverstein: Report output file name with ODR violation
warning message.
@
text
@d29 1
d76 26
d1464 1
a1464 1
			   sym->name(), shndx);
d1677 1
a1677 1
			   sym->name(), in_shndx);
d1801 2
a1802 1
		   sym->object()->name().c_str(), sym->name());
d1914 1
a1914 1
                       output_file_name, symbol_name);
@


1.48
log
@Add heuristics for undefined symbol warnings.
@
text
@d1855 1
a1855 1
Symbol_table::detect_odr_violations() const
d1884 3
a1886 2
          gold_warning(_("symbol %s defined in multiple places "
			 "(possible ODR violation):"), symbol_name);
@


1.47
log
@Revert last patch.
@
text
@d1527 2
a1528 1
Symbol_table::write_globals(const Target* target, const Stringpool* sympool,
d1536 2
a1537 1
	  this->sized_write_globals<32, true>(target, sympool, dynpool, of);
d1545 2
a1546 1
	  this->sized_write_globals<32, false>(target, sympool, dynpool, of);
d1557 2
a1558 1
	  this->sized_write_globals<64, true>(target, sympool, dynpool, of);
d1566 2
a1567 1
	  this->sized_write_globals<64, false>(target, sympool, dynpool, of);
d1581 1
a1581 1
Symbol_table::sized_write_globals(const Target* target,
d1586 2
d1609 2
a1610 19
      // Optionally check for unresolved symbols in shared libraries.
      // This is controlled by the --allow-shlib-undefined option.  We
      // only warn about libraries for which we have seen all the
      // DT_NEEDED entries.  We don't try to track down DT_NEEDED
      // entries which were not seen in this link.  If we didn't see a
      // DT_NEEDED entry, we aren't going to be able to reliably
      // report whether the symbol is undefined.
      if (sym->source() == Symbol::FROM_OBJECT
          && sym->object()->is_dynamic()
          && sym->shndx() == elfcpp::SHN_UNDEF
	  && sym->binding() != elfcpp::STB_WEAK
	  && !parameters->allow_shlib_undefined())
	{
	  // A very ugly cast.
	  Dynobj* dynobj = static_cast<Dynobj*>(sym->object());
	  if (!dynobj->has_unknown_needed_entries())
	    gold_error(_("%s: undefined reference to '%s'"),
		       sym->object()->name().c_str(), sym->name());
	}
d1740 36
@


1.46
log
@Support special always-defined symbols for targets.
@
text
@d1613 1
a1613 2
	  && !parameters->allow_shlib_undefined()
	  && !target->is_always_defined(sym))
@


1.45
log
@Warn about undefined references in shared libraries if we have seen
all the DT_NEEDED entries for that library.
@
text
@d1613 2
a1614 1
	  && !parameters->allow_shlib_undefined())
@


1.44
log
@From Craig Silverstein: Rework debug info code a bit, add option for
ODR violations, add test case.
@
text
@d1602 20
@


1.43
log
@From Craig Silverstein: First cut at detecting ODR violations.
@
text
@a1810 48
  if (parameters->get_size() == 32)
    {
      if (!parameters->is_big_endian())
	{
#ifdef HAVE_TARGET_32_LITTLE
	  this->sized_detect_odr_violations<32, false>();
#else
	  gold_unreachable();
#endif
	}
      else
	{
#ifdef HAVE_TARGET_32_BIG
	  this->sized_detect_odr_violations<32, true>();
#else
	  gold_unreachable();
#endif
	}
    }
  else if (parameters->get_size() == 64)
    {
      if (!parameters->is_big_endian())
	{
#ifdef HAVE_TARGET_64_LITTLE
	  this->sized_detect_odr_violations<64, false>();
#else
	  gold_unreachable();
#endif
	}
      else
	{
#ifdef HAVE_TARGET_64_BIG
	  this->sized_detect_odr_violations<64, true>();
#else
	  gold_unreachable();
#endif
	}
    }
  else
    gold_unreachable();
}

// Implement detect_odr_violations.

template<int size, bool big_endian>
void
Symbol_table::sized_detect_odr_violations() const
{
d1829 2
a1830 1
          Dwarf_line_info<size, big_endian> line_info(locs->object);
a1831 1
          std::string lineno = line_info.addr2line(locs->shndx, locs->offset);
@


1.42
log
@From Cary Coutant: More shared library support, some refactorization.
@
text
@d26 1
d31 1
d348 1
a348 1
  this->resolve(to, esym.sym(), from->object(), version);
d377 5
d391 2
a392 1
			      const elfcpp::Sym<size, big_endian>& sym)
d427 1
a427 1
      this->resolve(ret, sym, object, version);
d467 1
a467 1
	  this->resolve(ret, sym, object, version);
d582 1
a582 1
				      false, *psym);
d601 1
a601 1
				      def, *psym);
d670 1
a670 1
				      false, sym);
d704 1
a704 1
					  false, sym);
d734 1
a734 1
					    false, sym);
d741 1
a741 1
					      version_key, def, sym);
d1803 91
@


1.41
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d70 1
@


1.40
log
@Add support for PT_GNU_STACK.
@
text
@d524 1
a524 1
    Symbol** sympointers)
d595 1
a595 1
      *sympointers++ = res;
d1873 1
a1873 1
    Symbol** sympointers);
d1885 1
a1885 1
    Symbol** sympointers);
d1897 1
a1897 1
    Symbol** sympointers);
d1909 1
a1909 1
    Symbol** sympointers);
@


1.39
log
@Fix versions of copied symbols.
@
text
@d1297 1
a1297 2
Symbol_table::set_dynsym_indexes(const General_options* options,
				 const Target* target,
d1324 1
a1324 1
	    versions->record_version(options, this, dynpool, sym);
@


1.38
log
@From Cary Coutant: preliminary shared library support.
@
text
@d69 1
d1227 64
d1325 1
a1325 1
	    versions->record_version(options, dynpool, sym);
d1969 16
a2015 1

@


1.37
log
@Keep track of weak aliases, so that overriding environ works.
@
text
@d191 21
d1249 1
a1249 4
      if (!sym->needs_dynsym_entry()
          && (!options->export_dynamic()
              || !sym->in_reg()
              || !sym->is_externally_visible()))
@


1.36
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d62 1
d323 1
a323 1
  Symbol_table::resolve(to, esym.sym(), from->object(), version);
d354 1
a354 1
Symbol*
d396 1
a396 1
      Symbol_table::resolve(ret, sym, object, version);
d436 1
a436 1
	  Symbol_table::resolve(ret, sym, object, version);
d545 1
a545 1
      Symbol* res;
d602 10
d632 2
d638 2
a639 3
	  this->add_from_object(dynobj, name, name_key, NULL, 0,
				false, sym);
	  continue;
d641 3
d645 22
a666 1
      // Read the version information.
d668 15
a682 1
      unsigned int v = elfcpp::Swap<16, big_endian>::readval(vs);
d684 7
a690 2
      bool hidden = (v & elfcpp::VERSYM_HIDDEN) != 0;
      v &= elfcpp::VERSYM_VERSION;
d692 2
a693 6
      // The Sun documentation says that V can be VER_NDX_LOCAL, or
      // VER_NDX_GLOBAL, or a version index.  The meaning of
      // VER_NDX_LOCAL is defined as "Symbol has local scope."  The
      // old GNU linker will happily generate VER_NDX_LOCAL for an
      // undefined symbol.  I don't know what the Sun linker will
      // generate.
d695 18
a712 5
      if (v == static_cast<unsigned int>(elfcpp::VER_NDX_LOCAL)
          && sym.get_st_shndx() != elfcpp::SHN_UNDEF)
	{
	  // This symbol should not be visible outside the object.
	  continue;
d715 41
a755 3
      // At this point we are definitely going to add this symbol.
      Stringpool::Key name_key;
      name = this->namepool_.add(name, true, &name_key);
d757 17
a773 7
      if (v == static_cast<unsigned int>(elfcpp::VER_NDX_LOCAL)
          || v == static_cast<unsigned int>(elfcpp::VER_NDX_GLOBAL))
	{
	  // This symbol does not have a version.
	  this->add_from_object(dynobj, name, name_key, NULL, 0, false, sym);
	  continue;
	}
d775 2
a776 5
      if (v >= version_map->size())
	{
	  dynobj->error(_("versym for symbol %zu out of range: %u"), i, v);
	  continue;
	}
d778 3
a780 2
      const char* version = (*version_map)[v];
      if (version == NULL)
d782 7
a788 2
	  dynobj->error(_("versym for symbol %zu has no name: %u"), i, v);
	  continue;
d791 1
a791 9
      Stringpool::Key version_key;
      version = this->namepool_.add(version, true, &version_key);

      // If this is an absolute symbol, and the version name and
      // symbol name are the same, then this is the version definition
      // symbol.  These symbols exist to support using -u to pull in
      // particular versions.  We do not want to record a version for
      // them.
      if (sym.get_st_shndx() == elfcpp::SHN_ABS && name_key == version_key)
d793 2
a794 2
	  this->add_from_object(dynobj, name, name_key, NULL, 0, false, sym);
	  continue;
d797 1
a797 4
      const bool def = !hidden && sym.get_st_shndx() != elfcpp::SHN_UNDEF;

      this->add_from_object(dynobj, name, name_key, version, version_key,
			    def, sym);
d975 1
a975 1
    oldsym->override_with_special(sym);
d1069 1
a1069 1
    oldsym->override_with_special(sym);
d1156 1
a1156 1
    oldsym->override_with_special(sym);
@


1.35
log
@Add an option for Stringpools to not copy strings.
@
text
@d517 3
a519 5
	  fprintf(stderr,
		  _("%s: %s: bad global symbol name offset %u at %lu\n"),
		  program_name, relobj->name().c_str(), st_name,
		  static_cast<unsigned long>(i));
	  gold_exit(false);
d595 2
a596 3
      fprintf(stderr, _("%s: %s: too few symbol versions\n"),
	      program_name, dynobj->name().c_str());
      gold_exit(false);
d614 3
a616 4
	  fprintf(stderr, _("%s: %s: bad symbol name offset %u at %lu\n"),
		  program_name, dynobj->name().c_str(), st_name,
		  static_cast<unsigned long>(i));
	  gold_exit(false);
d665 2
a666 4
	  fprintf(stderr,
		  _("%s: %s: versym for symbol %zu out of range: %u\n"),
		  program_name, dynobj->name().c_str(), i, v);
	  gold_exit(false);
d672 2
a673 3
	  fprintf(stderr, _("%s: %s: versym for symbol %zu has no name: %u\n"),
		  program_name, dynobj->name().c_str(), i, v);
	  gold_exit(false);
d1241 3
a1243 3
		fprintf(stderr, _("%s: %s: unsupported symbol section 0x%x\n"),
			program_name, sym->name(), shndx);
		gold_exit(false);
d1444 3
a1446 11
		fprintf(stderr, _("%s: %s: unsupported symbol section 0x%x\n"),
			program_name, sym->name(), in_shndx);
		gold_exit(false);
	      }

	    Object* symobj = sym->object();
	    if (symobj->is_dynamic())
	      {
		if (sym->needs_dynsym_value())
		  value = target->dynsym_value(sym);
		shndx = elfcpp::SHN_UNDEF;
a1447 3
	    else if (in_shndx == elfcpp::SHN_UNDEF
		     || in_shndx == elfcpp::SHN_ABS)
	      shndx = in_shndx;
d1450 19
a1468 5
		Relobj* relobj = static_cast<Relobj*>(symobj);
		off_t secoff;
		Output_section* os = relobj->output_section(in_shndx, &secoff);
		gold_assert(os != NULL);
		shndx = os->out_shndx();
d1661 1
d1663 3
a1665 1
Warnings::issue_warning(const Symbol* sym, const std::string& location) const
d1670 2
a1671 2
  fprintf(stderr, _("%s: %s: warning: %s\n"), program_name, location.c_str(),
	  p->second.text.c_str());
d1781 33
@


1.34
log
@Implement -s and -S options which strip symbols.
@
text
@d550 1
a550 1
	  name = this->namepool_.add(name, &name_key);
d557 1
a557 1
	  name = this->namepool_.add(name, ver - name, &name_key);
d568 1
a568 1
	  ver = this->namepool_.add(ver, &ver_key);
d628 1
a628 1
	  name = this->namepool_.add(name, &name_key);
d657 1
a657 1
      name = this->namepool_.add(name, &name_key);
d684 1
a684 1
      version = this->namepool_.add(version, &version_key);
d734 1
a734 1
      *pname = this->namepool_.add(*pname, &name_key);
d738 1
a738 1
	*pversion = this->namepool_.add(*pversion, &version_key);
d1141 1
a1141 1
	  dynpool->add(sym->name(), NULL);
d1325 1
a1325 1
	  pool->add(sym->name(), NULL);
@


1.33
log
@Use parameters to track whether we are doing a static link.  Fix up
final_value_is_known for weak undefined symbols.  Pointed out by Cary
Coutant.
@
text
@d1319 10
a1328 4
      sym->set_symtab_index(index);
      pool->add(sym->name(), NULL);
      ++index;
      off += sym_size;
@


1.32
log
@Put size and endianness in parameters.
@
text
@d190 33
@


1.31
log
@Add cache parameter to get_view.  Discard uncached views on unlock.
Fix bug this exposed in archive armap symbol name handling.
@
text
@d193 1
a193 1
  : size_(0), saw_undefined_(0), offset_(0), table_(), namepool_(),
d470 2
a471 10
  // We take the size from the first object we see.
  if (this->get_size() == 0)
    this->set_size(size);

  if (size != this->get_size() || size != relobj->target()->get_size())
    {
      fprintf(stderr, _("%s: %s: mixing 32-bit and 64-bit ELF objects\n"),
	      program_name, relobj->name().c_str());
      gold_exit(false);
    }
d559 2
a560 10
  // We take the size from the first object we see.
  if (this->get_size() == 0)
    this->set_size(size);

  if (size != this->get_size() || size != dynobj->target()->get_size())
    {
      fprintf(stderr, _("%s: %s: mixing 32-bit and 64-bit ELF objects\n"),
	      program_name, dynobj->name().c_str());
      gold_exit(false);
    }
a682 2
  gold_assert(this->size_ == size);

d766 1
a766 2
  gold_assert(target->get_size() == this->size_);
  if (this->size_ == 32)
d778 1
a778 1
  else if (this->size_ == 64)
d815 1
a815 1
  if (target->is_big_endian())
d862 1
a862 2
  gold_assert(target->get_size() == this->size_);
  if (this->size_ == 32)
d873 1
a873 1
  else if (this->size_ == 64)
d909 10
a918 4
  if (target->is_big_endian())
    sym = this->define_special_symbol SELECT_SIZE_ENDIAN_NAME(size, true) (
        target, &name, &version, only_if_ref, &oldsym
        SELECT_SIZE_ENDIAN(size, true));
d920 9
a928 3
    sym = this->define_special_symbol SELECT_SIZE_ENDIAN_NAME(size, false) (
        target, &name, &version, only_if_ref, &oldsym
        SELECT_SIZE_ENDIAN(size, false));
d954 1
a954 2
  gold_assert(target->get_size() == this->size_);
  if (this->size_ == 32)
d964 1
a964 1
  else if (this->size_ == 64)
d997 10
a1006 4
  if (target->is_big_endian())
    sym = this->define_special_symbol SELECT_SIZE_ENDIAN_NAME(size, true) (
        target, &name, &version, only_if_ref, &oldsym
        SELECT_SIZE_ENDIAN(size, true));
d1008 9
a1016 3
    sym = this->define_special_symbol SELECT_SIZE_ENDIAN_NAME(size, false) (
        target, &name, &version, only_if_ref, &oldsym
        SELECT_SIZE_ENDIAN(size, false));
d1141 16
a1156 4
  if (this->size_ == 32)
    ret = this->sized_finalize<32>(index, off, pool);
  else if (this->size_ == 64)
    ret = this->sized_finalize<64>(index, off, pool);
d1303 1
a1303 1
  if (this->size_ == 32)
d1305 8
a1312 2
      if (target->is_big_endian())
	this->sized_write_globals<32, true>(target, sympool, dynpool, of);
d1314 7
a1320 1
	this->sized_write_globals<32, false>(target, sympool, dynpool, of);
d1322 1
a1322 1
  else if (this->size_ == 64)
d1324 8
a1331 2
      if (target->is_big_endian())
	this->sized_write_globals<64, true>(target, sympool, dynpool, of);
d1333 7
a1339 1
	this->sized_write_globals<64, false>(target, sympool, dynpool, of);
d1505 1
a1505 2
Symbol_table::write_section_symbol(const Target* target,
				   const Output_section *os,
d1509 1
a1509 1
  if (this->size_ == 32)
d1511 8
a1518 2
      if (target->is_big_endian())
	this->sized_write_section_symbol<32, true>(os, of, offset);
d1520 7
a1526 1
	this->sized_write_section_symbol<32, false>(os, of, offset);
d1528 1
a1528 1
  else if (this->size_ == 64)
d1530 8
a1537 2
      if (target->is_big_endian())
	this->sized_write_section_symbol<64, true>(os, of, offset);
d1539 7
a1545 1
	this->sized_write_section_symbol<64, false>(os, of, offset);
@


1.30
log
@Use special value when we refer a function symbol in some way other
than calling it.
@
text
@d1553 2
a1554 1
	    c = p->second.object->section_contents(p->second.shndx, &len);
@


1.29
log
@Add licensing text to every source file.
@
text
@d1310 1
a1310 1
Symbol_table::sized_write_globals(const Target*,
d1362 1
d1381 2
a1382 1
		// FIXME.
d1418 1
a1418 1
              sym, shndx, sympool, ps
d1429 1
a1429 1
              sym, shndx, dynpool, pd
d1446 7
a1452 5
Symbol_table::sized_write_symbol(Sized_symbol<size>* sym,
				 unsigned int shndx,
				 const Stringpool* pool,
				 unsigned char* p
                                 ACCEPT_SIZE_ENDIAN) const
d1456 1
a1456 1
  osym.put_st_value(sym->value());
@


1.28
log
@It's OK to have a version if we have an existing symbol.
@
text
@d3 20
@


1.27
log
@Canonicalize name and version when working with special symbols.
@
text
@d838 1
a838 1
  gold_assert(version == NULL);
d921 1
a921 1
  gold_assert(version == NULL);
d998 1
a998 1
  gold_assert(version == NULL);
@


1.26
log
@Let special symbols override existing symbols rather than
reinitializing them.
@
text
@d670 1
a670 1
// symbol if there is one.
d674 2
a675 2
Symbol_table::define_special_symbol(const Target* target, const char* name,
				    const char* version, bool only_if_ref,
d688 1
a688 1
      oldsym = this->lookup(name, version);
d691 3
d699 1
a699 1
      name = this->namepool_.add(name, &name_key);
d702 2
a703 2
      if (version != NULL)
	version = this->namepool_.add(version, &version_key);
d818 1
a818 1
          target, name, version, only_if_ref, &oldsym
d828 1
a828 1
          target, name, version, only_if_ref, &oldsym
d838 1
d911 1
a911 1
        target, name, version, only_if_ref, &oldsym
d915 1
a915 1
        target, name, version, only_if_ref, &oldsym
d921 1
d988 1
a988 1
        target, name, version, only_if_ref, &oldsym
d992 1
a992 1
        target, name, version, only_if_ref, &oldsym
d998 1
@


1.25
log
@Add support for --enable-target to control which template
specializations we generate.
@
text
@d669 2
d675 2
a676 1
				    const char* version, bool only_if_ref
d683 2
a690 5
      sym = NULL;

      // Canonicalize NAME and VERSION.
      name = oldsym->name();
      version = oldsym->version();
a712 1
	  sym = NULL;
d718 2
a719 16

	  if (!target->has_make_symbol())
	    sym = new Sized_symbol<size>();
	  else
	    {
	      gold_assert(target->get_size() == size);
	      gold_assert(target->is_big_endian() ? big_endian : !big_endian);
	      typedef Sized_target<size, big_endian> My_target;
	      const My_target* sized_target =
		static_cast<const My_target*>(target);
	      sym = sized_target->make_symbol();
	      if (sym == NULL)
		return NULL;
	    }

	  ins.first->second = sym;
d724 3
a726 1
  if (oldsym != NULL)
d728 9
a736 1
      gold_assert(sym == NULL);
d738 4
a741 14
      sym = this->get_sized_symbol SELECT_SIZE_NAME(size) (oldsym
                                                           SELECT_SIZE(size));
      gold_assert(sym->source() == Symbol::FROM_OBJECT);
      const int old_shndx = sym->shndx();
      if (old_shndx != elfcpp::SHN_UNDEF
	  && old_shndx != elfcpp::SHN_COMMON
	  && !sym->object()->is_dynamic())
	{
	  fprintf(stderr, "%s: linker defined: multiple definition of %s\n",
		  program_name, name);
	  // FIXME: Report old location.  Record that we have seen an
	  // error.
	  return NULL;
	}
d743 2
a744 2
      // Our new definition is going to override the old reference.
    }
d763 11
a773 4
    return this->do_define_in_output_data<32>(target, name, version, od, value,
					      symsize, type, binding,
					      visibility, nonvis,
					      offset_is_from_end, only_if_ref);
d775 11
a785 4
    return this->do_define_in_output_data<64>(target, name, version, od, value,
					      symsize, type, binding,
					      visibility, nonvis,
					      offset_is_from_end, only_if_ref);
d809 1
d815 1
a815 1
          target, name, version, only_if_ref
d825 1
a825 1
          target, name, version, only_if_ref
d838 4
d859 10
a868 4
    return this->do_define_in_output_segment<32>(target, name, version, os,
						 value, symsize, type, binding,
						 visibility, nonvis,
						 offset_base, only_if_ref);
d870 10
a879 4
    return this->do_define_in_output_segment<64>(target, name, version, os,
						 value, symsize, type, binding,
						 visibility, nonvis,
						 offset_base, only_if_ref);
d903 1
d907 1
a907 1
        target, name, version, only_if_ref
d911 1
a911 1
        target, name, version, only_if_ref
d920 4
d939 9
a947 3
    return this->do_define_as_constant<32>(target, name, version, value,
					   symsize, type, binding, visibility,
					   nonvis, only_if_ref);
d949 9
a957 3
    return this->do_define_as_constant<64>(target, name, version, value,
					   symsize, type, binding, visibility,
					   nonvis, only_if_ref);
d979 1
d983 1
a983 1
        target, name, version, only_if_ref
d987 1
a987 1
        target, name, version, only_if_ref
d994 4
@


1.24
log
@Ignore VER_NDX_LOCAL for an undefined symbol.
@
text
@d812 9
a820 3
    sym = this->define_special_symbol SELECT_SIZE_ENDIAN_NAME(size, true) (
	target, name, version, only_if_ref
        SELECT_SIZE_ENDIAN(size, true));
d822 9
a830 3
    sym = this->define_special_symbol SELECT_SIZE_ENDIAN_NAME(size, false) (
        target, name, version, only_if_ref
        SELECT_SIZE_ENDIAN(size, false));
d1509 1
d1512 2
a1513 2
Symbol_table::add_from_relobj<32, true>(
    Sized_relobj<32, true>* relobj,
d1519 1
d1521 1
d1524 2
a1525 2
Symbol_table::add_from_relobj<32, false>(
    Sized_relobj<32, false>* relobj,
d1531 1
d1533 1
d1536 2
a1537 2
Symbol_table::add_from_relobj<64, true>(
    Sized_relobj<64, true>* relobj,
d1543 1
d1545 1
d1548 2
a1549 2
Symbol_table::add_from_relobj<64, false>(
    Sized_relobj<64, false>* relobj,
d1555 1
d1557 1
d1560 2
a1561 2
Symbol_table::add_from_dynobj<32, true>(
    Sized_dynobj<32, true>* dynobj,
d1569 1
d1571 1
d1574 2
a1575 2
Symbol_table::add_from_dynobj<32, false>(
    Sized_dynobj<32, false>* dynobj,
d1583 1
d1585 1
d1588 2
a1589 2
Symbol_table::add_from_dynobj<64, true>(
    Sized_dynobj<64, true>* dynobj,
d1597 1
d1599 1
d1602 2
a1603 2
Symbol_table::add_from_dynobj<64, false>(
    Sized_dynobj<64, false>* dynobj,
d1611 1
@


1.23
log
@Copy in_reg and in_dyn when resolving NAME/VERSION with NAME/NULL.
@
text
@d604 9
a612 1
      if (v == static_cast<unsigned int>(elfcpp::VER_NDX_LOCAL))
d622 2
a623 1
      if (v == static_cast<unsigned int>(elfcpp::VER_NDX_GLOBAL))
@


1.22
log
@Initialize plt_offset_ and has_plt_offset_ in a Symbol.
@
text
@d270 4
@


1.21
log
@Add support for -E/--export-dynamic.  Also clean up --help output a bit.
@
text
@d34 1
d46 1
@


1.20
log
@Don't emit symbols seen only in dynamic object, don't read duplicate
dynamic object.
@
text
@d1004 4
a1007 1
      if (!sym->needs_dynsym_entry())
@


1.19
log
@Generate version information.
@
text
@d42 1
d61 1
d77 1
d92 1
d105 1
d1085 8
@


1.18
log
@gcc 3.2.2 portability hacks.
@
text
@d251 2
a252 2
Symbol_table::resolve(Sized_symbol<size>* to, const Sized_symbol<size>* from
                      ACCEPT_SIZE_ENDIAN)
d262 1
a262 1
  Symbol_table::resolve(to, esym.sym(), from->object());
d331 1
a331 1
      Symbol_table::resolve(ret, sym, object);
d350 1
a350 1
		ret, sym2 SELECT_SIZE_ENDIAN(size, big_endian));
d366 2
a367 2
	  // We already have an entry for NAME/NULL.  Make
	  // NAME/VERSION point to it.
d371 1
a371 1
	  Symbol_table::resolve(ret, sym, object);
d652 2
a653 2
Symbol_table::define_special_symbol(Target* target, const char* name,
				    bool only_if_ref
d663 1
a663 1
      oldsym = this->lookup(name, NULL);
d668 1
a668 1
      // Canonicalize NAME.
d670 1
d674 1
a674 1
      // Canonicalize NAME.
d678 4
a682 1
      const Stringpool::Key ver_key = 0;
d684 2
a685 1
	this->table_.insert(std::make_pair(std::make_pair(name_key, ver_key),
d690 1
a690 1
	  // We already have a symbol table entry for NAME.
d707 2
a708 1
	      My_target* sized_target = static_cast<My_target*>(target);
d746 3
a748 3
void
Symbol_table::define_in_output_data(Target* target, const char* name,
				    Output_data* od,
d758 4
a761 3
    this->do_define_in_output_data<32>(target, name, od, value, symsize,
				       type, binding, visibility, nonvis,
				       offset_is_from_end, only_if_ref);
d763 4
a766 3
    this->do_define_in_output_data<64>(target, name, od, value, symsize,
				       type, binding, visibility, nonvis,
				       offset_is_from_end, only_if_ref);
d774 1
a774 1
void
d776 1
a776 1
    Target* target,
d778 1
d793 1
a793 1
        target, name, only_if_ref
d797 1
a797 1
        target, name, only_if_ref
d801 1
a801 1
    return;
d805 2
d811 3
a813 3
void
Symbol_table::define_in_output_segment(Target* target, const char* name,
				       Output_segment* os,
d823 4
a826 3
    this->do_define_in_output_segment<32>(target, name, os, value, symsize,
					  type, binding, visibility, nonvis,
					  offset_base, only_if_ref);
d828 4
a831 3
    this->do_define_in_output_segment<64>(target, name, os, value, symsize,
					  type, binding, visibility, nonvis,
					  offset_base, only_if_ref);
d839 1
a839 1
void
d841 1
a841 1
    Target* target,
d843 1
d858 1
a858 1
        target, name, only_if_ref
d862 1
a862 1
        target, name, only_if_ref
d866 1
a866 1
    return;
d870 2
d877 6
a882 6
void
Symbol_table::define_as_constant(Target* target, const char* name,
				 uint64_t value, uint64_t symsize,
				 elfcpp::STT type, elfcpp::STB binding,
				 elfcpp::STV visibility, unsigned char nonvis,
				 bool only_if_ref)
d886 3
a888 3
    this->do_define_as_constant<32>(target, name, value, symsize,
				    type, binding, visibility, nonvis,
				    only_if_ref);
d890 3
a892 3
    this->do_define_as_constant<64>(target, name, value, symsize,
				    type, binding, visibility, nonvis,
				    only_if_ref);
d900 1
a900 1
void
d902 1
a902 1
    Target* target,
d904 1
d917 1
a917 1
        target, name, only_if_ref
d921 1
a921 1
        target, name, only_if_ref
d925 1
a925 1
    return;
d928 2
d935 2
a936 2
Symbol_table::define_symbols(const Layout* layout, Target* target, int count,
			     const Define_symbol_in_section* p)
d942 4
a945 4
	this->define_in_output_data(target, p->name, os, p->value, p->size,
				    p->type, p->binding, p->visibility,
				    p->nonvis, p->offset_is_from_end,
				    p->only_if_ref);
d947 1
a947 1
	this->define_as_constant(target, p->name, 0, p->size, p->type,
d956 2
a957 2
Symbol_table::define_symbols(const Layout* layout, Target* target, int count,
			     const Define_symbol_in_segment* p)
d965 4
a968 4
	this->define_in_output_segment(target, p->name, os, p->value, p->size,
				       p->type, p->binding, p->visibility,
				       p->nonvis, p->offset_base,
				       p->only_if_ref);
d970 1
a970 1
	this->define_as_constant(target, p->name, 0, p->size, p->type,
d982 3
a984 1
Symbol_table::set_dynsym_indexes(unsigned int index,
d986 2
a987 1
				 Stringpool* dynpool)
d1007 4
d1013 4
@


1.17
log
@Can now dynamically link hello, world.
@
text
@d1278 3
a1280 1
	  this->sized_write_symbol<size, big_endian>(sym, shndx, sympool, ps);
d1289 3
a1291 1
	  this->sized_write_symbol<size, big_endian>(sym, shndx, dynpool, pd);
d1310 2
a1311 1
				 unsigned char* p) const
@


1.16
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d58 1
a58 1
  this->u_.from_object.shnum = sym.get_st_shndx();
d261 1
a261 1
  esym.put_st_shndx(from->shnum());
d720 3
a722 3
      const int old_shnum = sym->shnum();
      if (old_shnum != elfcpp::SHN_UNDEF
	  && old_shnum != elfcpp::SHN_COMMON
d972 8
a979 1
      if (sym->needs_dynsym_entry())
d996 3
a998 1
Symbol_table::finalize(unsigned int index, off_t off, Stringpool* pool)
d1005 4
d1057 1
a1057 1
	    unsigned int shnum = sym->shnum();
d1060 2
a1061 2
	    if (shnum >= elfcpp::SHN_LORESERVE
		&& shnum != elfcpp::SHN_ABS)
d1064 1
a1064 1
			program_name, sym->name(), shnum);
d1072 1
a1072 1
		shnum = elfcpp::SHN_UNDEF;
d1074 1
a1074 1
	    else if (shnum == elfcpp::SHN_UNDEF)
d1076 1
a1076 1
	    else if (shnum == elfcpp::SHN_ABS)
d1082 1
a1082 1
		Output_section* os = relobj->output_section(shnum, &secoff);
d1087 1
d1149 1
a1149 1
			    Output_file* of) const
d1154 1
a1154 1
	this->sized_write_globals<32, true>(target, sympool, of);
d1156 1
a1156 1
	this->sized_write_globals<32, false>(target, sympool, of);
d1161 1
a1161 1
	this->sized_write_globals<64, true>(target, sympool, of);
d1163 1
a1163 1
	this->sized_write_globals<64, false>(target, sympool, of);
d1175 1
d1181 10
a1190 1
  unsigned char* psyms = of->get_output_view(this->offset_, oview_size);
d1200 7
a1206 1
      if (sym_index == -1U)
d1211 4
a1214 1
      if (sym_index != index)
d1219 3
a1221 1
	  continue;
a1222 1
      ++index;
d1229 1
a1229 1
	    unsigned int shnum = sym->shnum();
d1232 2
a1233 2
	    if (shnum >= elfcpp::SHN_LORESERVE
		&& shnum != elfcpp::SHN_ABS)
d1236 1
a1236 1
			program_name, sym->name(), sym->shnum());
d1246 3
a1248 2
	    else if (shnum == elfcpp::SHN_UNDEF || shnum == elfcpp::SHN_ABS)
	      shndx = shnum;
d1253 1
a1253 1
		Output_section* os = relobj->output_section(shnum, &secoff);
d1276 5
a1280 8
      elfcpp::Sym_write<size, big_endian> osym(ps);
      osym.put_st_name(sympool->get_offset(sym->name()));
      osym.put_st_value(sym->value());
      osym.put_st_size(sym->symsize());
      osym.put_st_info(elfcpp::elf_st_info(sym->binding(), sym->type()));
      osym.put_st_other(elfcpp::elf_st_other(sym->visibility(),
					     sym->nonvis()));
      osym.put_st_shndx(shndx);
d1282 7
a1288 1
      ps += sym_size;
d1294 21
@


1.15
log
@Snapshot.  Includes first cut at output relocation sections.
@
text
@a4 1
#include <cassert>
d200 2
a201 2
  assert(from != to);
  assert(!from->is_forwarder() && !to->is_forwarder());
d211 1
a211 1
  assert(from->is_forwarder());
d214 1
a214 1
  assert(p != this->forwarders_.end());
d326 1
a326 1
      assert(ret != NULL);
d359 1
a359 1
      assert(ins.first->second == NULL);
d408 1
a408 1
	      assert(insdef.second);
d656 1
a656 1
  assert(this->size_ == size);
d687 1
a687 1
	  assert(oldsym != NULL);
d693 1
a693 1
	  assert(ins.first->second == NULL);
d699 2
a700 2
	      assert(target->get_size() == size);
	      assert(target->is_big_endian() ? big_endian : !big_endian);
d715 1
a715 1
      assert(sym == NULL);
d719 1
a719 1
      assert(sym->source() == Symbol::FROM_OBJECT);
d750 1
a750 1
  assert(target->get_size() == this->size_);
d760 1
a760 1
    abort();
d810 1
a810 1
  assert(target->get_size() == this->size_);
d820 1
a820 1
    abort();
d868 1
a868 1
  assert(target->get_size() == this->size_);
d878 1
a878 1
    abort();
d957 27
d993 1
a993 1
  assert(index != 0);
d1001 1
a1001 1
    abort();
d1031 6
a1036 1
      // the output file.
d1106 1
a1106 1
		abort();
d1116 1
a1116 1
	  abort();
d1152 1
a1152 1
    abort();
d1175 14
a1188 2
      if (sym->symtab_index() == -1U)
	continue;
d1219 1
a1219 1
		assert(os != NULL);
d1238 1
a1238 1
	  abort();
a1240 3
      assert(sym->symtab_index() == index);
      ++index;

d1253 1
a1253 1
  assert(ps - psyms == oview_size);
d1258 50
d1361 1
a1361 1
  assert(sym->has_warning());
d1363 1
a1363 1
  assert(p != this->warnings_.end());
@


1.14
log
@More dynamic object support, initial scripting support.
@
text
@d32 2
d42 1
d210 1
a210 1
Symbol_table::resolve_forwards(Symbol* from) const
d213 1
a213 1
  Unordered_map<Symbol*, Symbol*>::const_iterator p =
d958 2
a959 1
// Set the final values for all the symbols.  Record the file offset
d963 1
a963 1
Symbol_table::finalize(off_t off, Stringpool* pool)
d967 3
d971 1
a971 1
    ret = this->sized_finalize<32>(off, pool);
d973 1
a973 1
    ret = this->sized_finalize<64>(off, pool);
d990 1
a990 1
Symbol_table::sized_finalize(off_t off, Stringpool* pool)
d995 2
d998 3
a1000 3
  Symbol_table_type::iterator p = this->table_.begin();
  size_t count = 0;
  while (p != this->table_.end())
d1042 1
a1042 6
		    // We should be able to erase this symbol from the
		    // symbol table, but at least with gcc 4.0.2
		    // std::unordered_map::erase doesn't appear to return
		    // the new iterator.
		    // p = this->table_.erase(p);
		    ++p;
d1089 1
d1091 1
a1091 1
      ++count;
a1092 1
      ++p;
d1095 1
a1095 1
  this->output_count_ = count;
d1133 4
a1136 2
  unsigned char* psyms = of->get_output_view(this->offset_,
					     this->output_count_ * sym_size);
d1144 3
d1176 1
a1176 3
		if (os == NULL)
		  continue;

d1198 3
d1213 3
a1215 1
  of->write_output_view(this->offset_, this->output_count_ * sym_size, psyms);
d1269 1
a1269 1
Warnings::issue_warning(Symbol* sym, const std::string& location) const
@


1.13
log
@Add Elf_file interface which can be used by both Sized_relobj and
Sized_dynobj.
@
text
@d11 1
d198 1
d339 1
a339 1
	  else
d429 2
a430 2
Symbol_table::add_from_object(
    Relobj* object,
d441 1
a441 1
  if (size != this->get_size() || size != object->target()->get_size())
d444 1
a444 1
	      program_name, object->name().c_str());
d461 1
a461 1
		  program_name, object->name().c_str(), st_name,
d466 2
d475 1
a475 1
	  && !object->is_section_included(st_shndx))
a482 2
      const char* name = sym_names + st_name;

d493 1
a493 1
	  res = this->add_from_object(object, name, name_key, NULL, 0,
d512 1
a512 1
	  res = this->add_from_object(object, name, name_key, ver, ver_key,
d520 125
d1272 2
a1273 2
Symbol_table::add_from_object<32, true>(
    Relobj* object,
d1282 2
a1283 2
Symbol_table::add_from_object<32, false>(
    Relobj* object,
d1292 2
a1293 2
Symbol_table::add_from_object<64, true>(
    Relobj* object,
d1302 2
a1303 2
Symbol_table::add_from_object<64, false>(
    Relobj* object,
d1309 48
@


1.12
log
@Rework stringpool and hash tables so that we always generate the same
output regardless of randomize_va_space.
@
text
@d13 1
d1115 7
a1121 4
	  const unsigned char* c;
	  off_t len;
	  c = p->second.object->section_contents(p->second.shndx, &len);
	  p->second.set_text(reinterpret_cast<const char*>(c), len);
@


1.11
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@d177 1
a177 2
  return (reinterpret_cast<size_t>(key.first)
	  ^ reinterpret_cast<size_t>(key.second));
d218 2
a219 1
  name = this->namepool_.find(name);
d222 2
d226 1
a226 1
      version = this->namepool_.find(version);
d231 1
a231 1
  Symbol_table_key key(name, version);
d287 4
a290 1
			      const char *version, bool def,
d295 2
a296 1
    this->table_.insert(std::make_pair(std::make_pair(name, version), snull));
d302 3
a304 2
      const char* const vnull = NULL;
      insdef = this->table_.insert(std::make_pair(std::make_pair(name, vnull),
d389 2
a390 1
		      this->table_.erase(std::make_pair(name, version));
d488 4
a491 2
	  name = this->namepool_.add(name);
	  res = this->add_from_object(object, name, NULL, false, *psym);
d495 3
a497 1
	  name = this->namepool_.add(name, ver - name);
d505 6
a510 2
	  ver = this->namepool_.add(ver);
	  res = this->add_from_object(object, name, ver, def, *psym);
d544 2
a545 1
      name = this->namepool_.add(name);
d548 1
a548 1
      const char* const vnull = NULL;
d550 1
a550 1
	this->table_.insert(std::make_pair(std::make_pair(name, vnull),
d957 1
a957 1
      pool->add(sym->name());
@


1.10
log
@gcc 3.2.2 portability hacks.
@
text
@d40 1
d163 1
a163 1
    forwarders_(), commons_()
d283 1
a283 1
Symbol_table::add_from_object(Sized_object<size, big_endian>* object,
d364 3
a366 1
	  Sized_target<size, big_endian>* target = object->sized_target();
d414 1
a414 1
// Add all the symbols in an object to the hash table.
d419 2
a420 2
    Sized_object<size, big_endian>* object,
    const elfcpp::Sym<size, big_endian>* syms,
d439 1
a439 1
  const unsigned char* p = reinterpret_cast<const unsigned char*>(syms);
d518 1
a518 1
      if (oldsym == NULL)
d816 2
d819 1
a819 1
    return this->sized_finalize<32>(off, pool);
d821 1
a821 1
    return this->sized_finalize<64>(off, pool);
d824 6
d870 7
a876 1
	    if (shnum == elfcpp::SHN_UNDEF)
d882 1
d884 1
a884 2
		Output_section* os = sym->object()->output_section(shnum,
								   &secoff);
a992 2
      // FIXME: This repeats sized_finalize().

d1009 7
a1015 1
	    if (shnum == elfcpp::SHN_UNDEF || shnum == elfcpp::SHN_ABS)
d1019 1
d1021 1
a1021 2
		Output_section* os = sym->object()->output_section(shnum,
								   &secoff);
d1061 57
d1125 2
a1126 2
    Sized_object<32, true>* object,
    const elfcpp::Sym<32, true>* syms,
d1135 2
a1136 2
    Sized_object<32, false>* object,
    const elfcpp::Sym<32, false>* syms,
d1145 2
a1146 2
    Sized_object<64, true>* object,
    const elfcpp::Sym<64, true>* syms,
d1155 2
a1156 2
    Sized_object<64, false>* object,
    const elfcpp::Sym<64, false>* syms,
@


1.9
log
@Can now do a full static link of hello, world in C or C++
@
text
@d311 2
a312 2
      ret = this->get_sized_symbol SELECT_SIZE_NAME (ins.first->second
                                                     SELECT_SIZE(size));
d333 1
a333 1
	      sym2 = this->get_sized_symbol SELECT_SIZE_NAME (
d336 1
a336 1
	      Symbol_table::resolve SELECT_SIZE_ENDIAN_NAME (
d355 3
a357 2
	  ret = this->get_sized_symbol SELECT_SIZE_NAME (insdef.first->second
                                                         SELECT_SIZE(size));
d504 2
a505 1
				    bool only_if_ref)
d567 2
a568 2
      sym = this->get_sized_symbol SELECT_SIZE_NAME (oldsym
						     SELECT_SIZE(size));
d633 3
a635 1
    sym = this->define_special_symbol<size, true>(target, name, only_if_ref);
d637 3
a639 1
    sym = this->define_special_symbol<size, false>(target, name, only_if_ref);
d693 3
a695 1
    sym = this->define_special_symbol<size, true>(target, name, only_if_ref);
d697 3
a699 1
    sym = this->define_special_symbol<size, false>(target, name, only_if_ref);
d749 3
a751 1
    sym = this->define_special_symbol<size, true>(target, name, only_if_ref);
d753 3
a755 1
    sym = this->define_special_symbol<size, false>(target, name, only_if_ref);
@


1.8
log
@Avoid multiple definition errors from linkonce sections.
@
text
@d20 2
a21 1
// Initialize the fields in the base class Symbol.
a22 1
template<int size, bool big_endian>
d24 3
a26 2
Symbol::init_base(const char* name, const char* version, Object* object,
		  const elfcpp::Sym<size, big_endian>& sym)
d30 6
a35 7
  this->object_ = object;
  this->shnum_ = sym.get_st_shndx(); // FIXME: Handle SHN_XINDEX.
  this->type_ = sym.get_st_type();
  this->binding_ = sym.get_st_bind();
  this->visibility_ = sym.get_st_visibility();
  this->other_ = sym.get_st_nonvis();
  this->is_special_ = false;
d38 17
d58 41
a98 1
// Initialize the fields in Sized_symbol.
d108 48
a155 1
  this->size_ = sym.get_st_size();
d161 2
a162 1
  : size_(0), offset_(0), table_(), namepool_(), forwarders_()
d252 1
a252 1
  esym.put_st_other(from->visibility(), from->other());
d306 2
d314 4
d347 4
d397 10
d497 296
d807 3
a809 1
// Set the final value for all the symbols.
d815 1
a815 1
  off = (off + (size >> 3) - 1) & ~ ((size >> 3) - 1);
d828 3
a830 2
      // FIXME: This is wrong.
      if (sym->shnum() >= elfcpp::SHN_LORESERVE)
d832 74
a905 2
	  ++p;
	  continue;
d908 5
a912 21
      off_t secoff;
      Output_section* os = sym->object()->output_section(sym->shnum(),
							 &secoff);

      if (os == NULL)
	{
	  // We should be able to erase this symbol from the symbol
	  // table, but at least with gcc 4.0.2
	  // std::unordered_map::erase doesn't appear to return the
	  // new iterator.
	  // p = this->table_.erase(p);
	  ++p;
	}
      else
	{
	  sym->set_value(sym->value() + os->address() + secoff);
	  pool->add(sym->name());
	  ++p;
	  ++count;
	  off += sym_size;
	}
d964 46
a1009 9
      // FIXME: This is wrong.
      if (sym->shnum() >= elfcpp::SHN_LORESERVE)
	continue;

      off_t secoff;
      Output_section* os = sym->object()->output_section(sym->shnum(),
							 &secoff);
      if (os == NULL)
	continue;
d1016 3
a1018 2
      osym.put_st_other(elfcpp::elf_st_other(sym->visibility(), sym->other()));
      osym.put_st_shndx(os->shndx());
@


1.7
log
@Clean up HAVE_MEMBER_TEMPLATE_SPECIFICATIONS somewhat.
@
text
@d308 2
d311 1
a311 1
  for (size_t i = 0; i < count; ++i)
d314 1
d316 1
a316 1
      unsigned int st_name = sym.get_st_name();
d326 15
d352 1
a352 1
	  res = this->add_from_object(object, name, NULL, false, sym);
d365 1
a365 1
	  res = this->add_from_object(object, name, ver, def, sym);
a368 2

      p += elfcpp::Elf_sizes<size>::sym_size;
d412 3
a414 2
      const Object::Map_to_output* mo =
	sym->object()->section_output_info(sym->shnum());
d416 1
a416 1
      if (mo->output_section == NULL)
d427 1
a427 3
	  sym->set_value(sym->value()
			 + mo->output_section->address()
			 + mo->offset);
d488 4
a491 4
      const Object::Map_to_output* mo =
	sym->object()->section_output_info(sym->shnum());

      if (mo->output_section == NULL)
d500 1
a500 1
      osym.put_st_shndx(mo->output_section->shndx());
@


1.6
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@a135 2
#ifdef HAVE_MEMBER_TEMPLATE_SPECIFICATIONS

d138 2
a139 1
Symbol_table::resolve(Sized_symbol<size>* to, const Sized_symbol<size>* from)
a151 34
#else

template<int size>
void
Symbol_table::resolve(Sized_symbol<size>* to, const Sized_symbol<size>* from,
                      bool big_endian)
{
  unsigned char buf[elfcpp::Elf_sizes<size>::sym_size];
  if (big_endian)
    {
      elfcpp::Sym_write<size, true> esym(buf);
      // We don't bother to set the st_name field.
      esym.put_st_value(from->value());
      esym.put_st_size(from->symsize());
      esym.put_st_info(from->binding(), from->type());
      esym.put_st_other(from->visibility(), from->other());
      esym.put_st_shndx(from->shnum());
      Symbol_table::resolve(to, esym.sym(), from->object());
    }
  else
    {
      elfcpp::Sym_write<size, false> esym(buf);
      // We don't bother to set the st_name field.
      esym.put_st_value(from->value());
      esym.put_st_size(from->symsize());
      esym.put_st_info(from->binding(), from->type());
      esym.put_st_other(from->visibility(), from->other());
      esym.put_st_shndx(from->shnum());
      Symbol_table::resolve(to, esym.sym(), from->object());
    }
}

#endif

d204 2
a205 6
#ifdef HAVE_MEMBER_TEMPLATE_SPECIFICATIONS
      ret = this->get_sized_symbol<size>(ins.first->second);
#else
      assert(size == this->get_size());
      ret = static_cast<Sized_symbol<size>*>(ins.first->second);
#endif
d222 5
a226 7
#ifdef HAVE_MEMBER_TEMPLATE_SPECIFICATIONS
	      sym2 = this->get_sized_symbol<size>(insdef.first->second);
	      Symbol_table::resolve<size, big_endian>(ret, sym2);
#else
	      sym2 = static_cast<Sized_symbol<size>*>(insdef.first->second);
	      Symbol_table::resolve(ret, sym2, big_endian);
#endif
d240 2
a241 5
#ifdef HAVE_MEMBER_TEMPLATE_SPECIFICATIONS
	  ret = this->get_sized_symbol<size>(insdef.first->second);
#else
          ret = static_cast<Sized_symbol<size>*>(insdef.first->second);
#endif
@


1.5
log
@Finished layout code.
@
text
@d12 1
d96 2
d108 22
d408 2
d411 1
a411 1
    return this->sized_finalize<64>(off, pool);
d420 1
a420 1
  off = (off + size - 1) & ~ (size - 1);
d425 1
d433 7
d454 3
a456 1
	  sym->set_value(mo->output_section->address() + mo->offset);
d459 1
d464 2
d467 68
@


1.4
log
@g++ 3.2.2 portability fixes.
@
text
@d11 1
d56 1
a56 1
  : size_(0), table_(), namepool_(), output_pool_(), forwarders_()
d375 2
a376 1
// Record the names of the local symbols for an object.
d378 14
a391 6
template<int size, bool big_endian>
void
Symbol_table::add_local_symbol_names(Sized_object<size, big_endian>* object,
				     const elfcpp::Sym<size, big_endian>* syms,
				     size_t count, const char* sym_names,
				     size_t sym_name_size)
d393 6
a398 2
  const unsigned char* p = reinterpret_cast<const unsigned char*>(syms);
  for (size_t i = 0; i < count; ++i)
d400 7
a406 1
      elfcpp::Sym<size, big_endian> sym(p);
d408 10
a417 2
      unsigned int st_name = sym.get_st_name();
      if (st_name >= sym_name_size)
d419 4
a422 5
	  fprintf(stderr,
		  _("%s: %s: bad local symbol name offset %u at %lu\n"),
		  program_name, object->name().c_str(), st_name,
		  static_cast<unsigned long>(i));
	  gold_exit(false);
d424 1
d426 1
a426 2
      this->output_pool_.add(sym_names + st_name);
    }
a471 36

template
void
Symbol_table::add_local_symbol_names<32, true>(
    Sized_object<32, true>* object,
    const elfcpp::Sym<32, true>* syms,
    size_t count,
    const char* sym_names,
    size_t sym_name_size);

template
void
Symbol_table::add_local_symbol_names<32, false>(
    Sized_object<32, false>* object,
    const elfcpp::Sym<32, false>* syms,
    size_t count,
    const char* sym_names,
    size_t sym_name_size);

template
void
Symbol_table::add_local_symbol_names<64, true>(
    Sized_object<64, true>* object,
    const elfcpp::Sym<64, true>* syms,
    size_t count,
    const char* sym_names,
    size_t sym_name_size);

template
void
Symbol_table::add_local_symbol_names<64, false>(
    Sized_object<64, false>* object,
    const elfcpp::Sym<64, false>* syms,
    size_t count,
    const char* sym_names,
    size_t sym_name_size);
@


1.3
log
@More section layout code.
@
text
@d110 2
d127 34
d213 1
d215 4
d234 3
a236 2
	      const Sized_symbol<size>* sym2 =
		this->get_sized_symbol<size>(insdef.first->second);
d238 4
d255 1
d257 3
@


1.2
log
@More symbol resolution code.
@
text
@d55 1
a55 1
  : size_(0), table_(), namepool_(), forwarders_()
d284 2
a285 1
	  fprintf(stderr, _("%s: %s: bad symbol name offset %u at %lu\n"),
d324 28
d395 36
@


1.1
log
@Another snapshot of the current state of the sources.  Gets to the
point of symbol resolution and can now issue a multiple definition
error.  Also added target selection infrastructure.
@
text
@a17 4
Symbol::~Symbol()
{
}

d33 4
a36 3
  this->special_ = false;
  this->def_ = false;
  this->forwarder_ = false;
d107 2
a108 1
// version is the default version.
d110 1
d112 1
a112 1
Symbol_table::resolve(Symbol*, const Symbol*)
d114 9
d173 1
a173 1
  Symbol* ret;
d177 1
a177 1
      ret = ins.first->second;
d193 3
a195 1
	      Symbol_table::resolve(ret, insdef.first->second);
d209 1
a209 1
	  ret = insdef.first->second;
a214 1
	  Sized_symbol<size>* rs;
d216 3
a218 1
	  if (target->has_make_symbol())
d220 2
a221 2
	      rs = target->make_symbol();
	      if (rs == NULL)
a235 3
	  else
	    rs = new Sized_symbol<size>();
	  rs->init(name, version, object, sym);
d237 2
a238 1
	  ret = rs;
@

