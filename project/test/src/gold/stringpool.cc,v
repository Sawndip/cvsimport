head	1.36;
access;
symbols
	binutils-2_24-branch:1.36.0.2
	binutils-2_24-branchpoint:1.36
	binutils-2_21_1:1.34
	binutils-2_23_2:1.34
	binutils-2_23_1:1.34
	binutils-2_23:1.34
	binutils-2_23-branch:1.34.0.8
	binutils-2_23-branchpoint:1.34
	binutils-2_22_branch:1.34.0.6
	binutils-2_22:1.34
	binutils-2_22-branch:1.34.0.4
	binutils-2_22-branchpoint:1.34
	binutils-2_21:1.34
	binutils-2_21-branch:1.34.0.2
	binutils-2_21-branchpoint:1.34
	binutils-2_20_1:1.29
	binutils-2_20:1.29
	binutils-arc-20081103-branch:1.28.0.6
	binutils-arc-20081103-branchpoint:1.28
	binutils-2_20-branch:1.29.0.4
	binutils-2_20-branchpoint:1.29
	dje-cgen-play1-branch:1.29.0.2
	dje-cgen-play1-branchpoint:1.29
	arc-20081103-branch:1.28.0.4
	arc-20081103-branchpoint:1.28
	binutils-2_19_1:1.28
	binutils-2_19:1.28
	binutils-2_19-branch:1.28.0.2
	binutils-2_19-branchpoint:1.28
	binutils_latest_snapshot:1.36
	added-to-binutils:1.27;
locks; strict;
comment	@// @;


1.36
date	2013.05.01.17.37.14;	author ccoutant;	state Exp;
branches;
next	1.35;

1.35
date	2013.04.29.17.15.08;	author ccoutant;	state Exp;
branches;
next	1.34;

1.34
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2010.08.03.20.38.09;	author ccoutant;	state Exp;
branches;
next	1.32;

1.32
date	2010.03.19.19.11.21;	author dougkwan;	state Exp;
branches;
next	1.31;

1.31
date	2010.03.16.01.26.15;	author dougkwan;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.21.08.08.41;	author dougkwan;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.23.07.04.10;	author ian;	state Exp;
branches;
next	1.28;

1.28
date	2008.07.24.07.23.20;	author ian;	state Exp;
branches;
next	1.27;

1.27
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2008.02.26.21.45.30;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.22.01.53.39;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.12.19.01.23.46;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.19.00.29.28;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.12.14.05.24.17;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.05.22.56.51;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.05.00.48.49;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.01.06.45.21;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.12.01.06.34.12;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.30.00.35.27;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.12.06.06.34;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.05.17.36.31;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.21.15.54.07;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.21.06.12.32;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.18.05.16.39;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.16.17.42.48;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.07.04.40.46;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.29.19.58.17;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.26.21.53.18;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.21.22.13.18;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.18.22.29.20;	author iant;	state Exp;
branches;
next	;


desc
@@


1.36
log
@gold/
	* stringpool.cc (Stringpool_template::new_key_offset): Fix
	uninitialized warning.
@
text
@// stringpool.cc -- a string pool for gold

// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cstring>
#include <algorithm>
#include <vector>

#include "output.h"
#include "parameters.h"
#include "stringpool.h"

namespace gold
{

template<typename Stringpool_char>
Stringpool_template<Stringpool_char>::Stringpool_template(uint64_t addralign)
  : string_set_(), key_to_offset_(), strings_(), strtab_size_(0),
    zero_null_(true), optimize_(false), offset_(sizeof(Stringpool_char)),
    addralign_(addralign)
{
  if (parameters->options_valid() && parameters->options().optimize() >= 2)
    this->optimize_ = true;
}

template<typename Stringpool_char>
void
Stringpool_template<Stringpool_char>::clear()
{
  for (typename std::list<Stringdata*>::iterator p = this->strings_.begin();
       p != this->strings_.end();
       ++p)
    delete[] reinterpret_cast<char*>(*p);
  this->strings_.clear();
  this->key_to_offset_.clear();
  this->string_set_.clear();
}

template<typename Stringpool_char>
Stringpool_template<Stringpool_char>::~Stringpool_template()
{
  this->clear();
}

// Resize the internal hashtable with the expectation we'll get n new
// elements.  Note that the hashtable constructor takes a "number of
// buckets you'd like," rather than "number of elements you'd like,"
// but that's the best we can do.

template<typename Stringpool_char>
void
Stringpool_template<Stringpool_char>::reserve(unsigned int n)
{
  this->key_to_offset_.reserve(n);

#if defined(HAVE_TR1_UNORDERED_MAP)
  // rehash() implementation is broken in gcc 4.0.3's stl
  //this->string_set_.rehash(this->string_set_.size() + n);
  //return;
#elif defined(HAVE_EXT_HASH_MAP)
  this->string_set_.resize(this->string_set_.size() + n);
  return;
#endif

  // This is the generic "reserve" code, if no #ifdef above triggers.
  String_set_type new_string_set(this->string_set_.size() + n);
  new_string_set.insert(this->string_set_.begin(), this->string_set_.end());
  this->string_set_.swap(new_string_set);
}

// Compare two strings of arbitrary character type for equality.

template<typename Stringpool_char>
bool
Stringpool_template<Stringpool_char>::string_equal(const Stringpool_char* s1,
						   const Stringpool_char* s2)
{
  while (*s1 != 0)
    if (*s1++ != *s2++)
      return false;
  return *s2 == 0;
}

// Specialize string_equal for char.

template<>
inline bool
Stringpool_template<char>::string_equal(const char* s1, const char* s2)
{
  return strcmp(s1, s2) == 0;
}

// Equality comparison function for the hash table.

template<typename Stringpool_char>
inline bool
Stringpool_template<Stringpool_char>::Stringpool_eq::operator()(
    const Hashkey& h1,
    const Hashkey& h2) const
{
  return (h1.hash_code == h2.hash_code
	  && h1.length == h2.length
	  && (h1.string == h2.string
	      || memcmp(h1.string, h2.string,
			h1.length * sizeof(Stringpool_char)) == 0));
}

// Hash function.  The length is in characters, not bytes.

template<typename Stringpool_char>
size_t
Stringpool_template<Stringpool_char>::string_hash(const Stringpool_char* s,
						  size_t length)
{
  return gold::string_hash<Stringpool_char>(s, length);
}

// Add the string S to the list of canonical strings.  Return a
// pointer to the canonical string.  If PKEY is not NULL, set *PKEY to
// the key.  LENGTH is the length of S in characters.  Note that S may
// not be NUL terminated.

template<typename Stringpool_char>
const Stringpool_char*
Stringpool_template<Stringpool_char>::add_string(const Stringpool_char* s,
						 size_t len)
{
  // We are in trouble if we've already computed the string offsets.
  gold_assert(this->strtab_size_ == 0);

  // The size we allocate for a new Stringdata.
  const size_t buffer_size = 1000;
  // The amount we multiply the Stringdata index when calculating the
  // key.
  const size_t key_mult = 1024;
  gold_assert(key_mult >= buffer_size);

  // Convert len to the number of bytes we need to allocate, including
  // the null character.
  len = (len + 1) * sizeof(Stringpool_char);

  size_t alc;
  bool front = true;
  if (len > buffer_size)
    {
      alc = sizeof(Stringdata) + len;
      front = false;
    }
  else if (this->strings_.empty())
    alc = sizeof(Stringdata) + buffer_size;
  else
    {
      Stringdata* psd = this->strings_.front();
      if (len > psd->alc - psd->len)
	alc = sizeof(Stringdata) + buffer_size;
      else
	{
	  char* ret = psd->data + psd->len;
	  memcpy(ret, s, len - sizeof(Stringpool_char));
	  memset(ret + len - sizeof(Stringpool_char), 0,
		 sizeof(Stringpool_char));

	  psd->len += len;

	  return reinterpret_cast<const Stringpool_char*>(ret);
	}
    }

  Stringdata* psd = reinterpret_cast<Stringdata*>(new char[alc]);
  psd->alc = alc - sizeof(Stringdata);
  memcpy(psd->data, s, len - sizeof(Stringpool_char));
  memset(psd->data + len - sizeof(Stringpool_char), 0,
	 sizeof(Stringpool_char));
  psd->len = len;

  if (front)
    this->strings_.push_front(psd);
  else
    this->strings_.push_back(psd);

  return reinterpret_cast<const Stringpool_char*>(psd->data);
}

// Add a string to a string pool.

template<typename Stringpool_char>
const Stringpool_char*
Stringpool_template<Stringpool_char>::add(const Stringpool_char* s, bool copy,
                                          Key* pkey)
{
  return this->add_with_length(s, string_length(s), copy, pkey);
}

// Add a new key offset entry.

template<typename Stringpool_char>
void
Stringpool_template<Stringpool_char>::new_key_offset(size_t length)
{
  section_offset_type offset;
  if (this->zero_null_ && length == 0)
    offset = 0;
  else
    {
      offset = this->offset_;
      // Align non-zero length strings.
      if (length != 0)
	offset = align_address(offset, this->addralign_);
      this->offset_ = offset + (length + 1) * sizeof(Stringpool_char);
    }
  this->key_to_offset_.push_back(offset);
}

template<typename Stringpool_char>
const Stringpool_char*
Stringpool_template<Stringpool_char>::add_with_length(const Stringpool_char* s,
						      size_t length,
						      bool copy,
						      Key* pkey)
{
  typedef std::pair<typename String_set_type::iterator, bool> Insert_type;

  // We add 1 so that 0 is always invalid.
  const Key k = this->key_to_offset_.size() + 1;

  if (!copy)
    {
      // When we don't need to copy the string, we can call insert
      // directly.

      std::pair<Hashkey, Hashval> element(Hashkey(s, length), k);

      Insert_type ins = this->string_set_.insert(element);

      typename String_set_type::const_iterator p = ins.first;

      if (ins.second)
	{
	  // We just added the string.  The key value has now been
	  // used.
	  this->new_key_offset(length);
	}
      else
	{
	  gold_assert(k != p->second);
	}

      if (pkey != NULL)
	*pkey = p->second;
      return p->first.string;
    }

  // When we have to copy the string, we look it up twice in the hash
  // table.  The problem is that we can't insert S before we
  // canonicalize it by copying it into the canonical list. The hash
  // code will only be computed once.

  Hashkey hk(s, length);
  typename String_set_type::const_iterator p = this->string_set_.find(hk);
  if (p != this->string_set_.end())
    {
      if (pkey != NULL)
	*pkey = p->second;
      return p->first.string;
    }

  this->new_key_offset(length);

  hk.string = this->add_string(s, length);
  // The contents of the string stay the same, so we don't need to
  // adjust hk.hash_code or hk.length.

  std::pair<Hashkey, Hashval> element(hk, k);

  Insert_type ins = this->string_set_.insert(element);
  gold_assert(ins.second);

  if (pkey != NULL)
    *pkey = k;
  return hk.string;
}

template<typename Stringpool_char>
const Stringpool_char*
Stringpool_template<Stringpool_char>::find(const Stringpool_char* s,
					   Key* pkey) const
{
  Hashkey hk(s);
  typename String_set_type::const_iterator p = this->string_set_.find(hk);
  if (p == this->string_set_.end())
    return NULL;

  if (pkey != NULL)
    *pkey = p->second;

  return p->first.string;
}

// Comparison routine used when sorting into an ELF strtab.  We want
// to sort this so that when one string is a suffix of another, we
// always see the shorter string immediately after the longer string.
// For example, we want to see these strings in this order:
//   abcd
//   cd
//   d
// When strings are not suffixes, we don't care what order they are
// in, but we need to ensure that suffixes wind up next to each other.
// So we do a reversed lexicographic sort on the reversed string.

template<typename Stringpool_char>
bool
Stringpool_template<Stringpool_char>::Stringpool_sort_comparison::operator()(
  const Stringpool_sort_info& sort_info1,
  const Stringpool_sort_info& sort_info2) const
{
  const Hashkey& h1(sort_info1->first);
  const Hashkey& h2(sort_info2->first);
  const Stringpool_char* s1 = h1.string;
  const Stringpool_char* s2 = h2.string;
  const size_t len1 = h1.length;
  const size_t len2 = h2.length;
  const size_t minlen = len1 < len2 ? len1 : len2;
  const Stringpool_char* p1 = s1 + len1 - 1;
  const Stringpool_char* p2 = s2 + len2 - 1;
  for (size_t i = minlen; i > 0; --i, --p1, --p2)
    {
      if (*p1 != *p2)
	return *p1 > *p2;
    }
  return len1 > len2;
}

// Return whether s1 is a suffix of s2.

template<typename Stringpool_char>
bool
Stringpool_template<Stringpool_char>::is_suffix(const Stringpool_char* s1,
                                                size_t len1,
						const Stringpool_char* s2,
                                                size_t len2)
{
  if (len1 > len2)
    return false;
  return memcmp(s1, s2 + len2 - len1, len1 * sizeof(Stringpool_char)) == 0;
}

// Turn the stringpool into an ELF strtab: determine the offsets of
// each string in the table.

template<typename Stringpool_char>
void
Stringpool_template<Stringpool_char>::set_string_offsets()
{
  if (this->strtab_size_ != 0)
    {
      // We've already computed the offsets.
      return;
    }

  const size_t charsize = sizeof(Stringpool_char);

  // Offset 0 may be reserved for the empty string.
  section_offset_type offset = this->zero_null_ ? charsize : 0;

  // Sorting to find suffixes can take over 25% of the total CPU time
  // used by the linker.  Since it's merely an optimization to reduce
  // the strtab size, and gives a relatively small benefit (it's
  // typically rare for a symbol to be a suffix of another), we only
  // take the time to sort when the user asks for heavy optimization.
  if (!this->optimize_)
    {
      // If we are not optimizing, the offsets are already assigned.
      offset = this->offset_;
    }
  else
    {
      size_t count = this->string_set_.size();

      std::vector<Stringpool_sort_info> v;
      v.reserve(count);

      for (typename String_set_type::iterator p = this->string_set_.begin();
           p != this->string_set_.end();
           ++p)
        v.push_back(Stringpool_sort_info(p));

      std::sort(v.begin(), v.end(), Stringpool_sort_comparison());

      section_offset_type last_offset = -1;
      for (typename std::vector<Stringpool_sort_info>::iterator last = v.end(),
             curr = v.begin();
           curr != v.end();
           last = curr++)
        {
	  section_offset_type this_offset;
          if (this->zero_null_ && (*curr)->first.string[0] == 0)
            this_offset = 0;
          else if (last != v.end()
                   && is_suffix((*curr)->first.string,
				(*curr)->first.length,
                                (*last)->first.string,
				(*last)->first.length))
            this_offset = (last_offset
			   + (((*last)->first.length - (*curr)->first.length)
			      * charsize));
          else
            {
              this_offset = align_address(offset, this->addralign_);
              offset = this_offset + ((*curr)->first.length + 1) * charsize;
            }
	  this->key_to_offset_[(*curr)->second - 1] = this_offset;
	  last_offset = this_offset;
        }
    }

  this->strtab_size_ = offset;
}

// Get the offset of a string in the ELF strtab.  The string must
// exist.

template<typename Stringpool_char>
section_offset_type
Stringpool_template<Stringpool_char>::get_offset(const Stringpool_char* s)
  const
{
  return this->get_offset_with_length(s, string_length(s));
}

template<typename Stringpool_char>
section_offset_type
Stringpool_template<Stringpool_char>::get_offset_with_length(
    const Stringpool_char* s,
    size_t length) const
{
  gold_assert(this->strtab_size_ != 0);
  Hashkey hk(s, length);
  typename String_set_type::const_iterator p = this->string_set_.find(hk);
  if (p != this->string_set_.end())
    return this->key_to_offset_[p->second - 1];
  gold_unreachable();
}

// Write the ELF strtab into the buffer.

template<typename Stringpool_char>
void
Stringpool_template<Stringpool_char>::write_to_buffer(
    unsigned char* buffer,
    section_size_type bufsize)
{
  gold_assert(this->strtab_size_ != 0);
  gold_assert(bufsize >= this->strtab_size_);
  if (this->zero_null_)
    buffer[0] = '\0';
  for (typename String_set_type::const_iterator p = this->string_set_.begin();
       p != this->string_set_.end();
       ++p)
    {
      const int len = (p->first.length + 1) * sizeof(Stringpool_char);
      const section_offset_type offset = this->key_to_offset_[p->second - 1];
      gold_assert(static_cast<section_size_type>(offset) + len
		  <= this->strtab_size_);
      memcpy(buffer + offset, p->first.string, len);
    }
}

// Write the ELF strtab into the output file at the specified offset.

template<typename Stringpool_char>
void
Stringpool_template<Stringpool_char>::write(Output_file* of, off_t offset)
{
  gold_assert(this->strtab_size_ != 0);
  unsigned char* view = of->get_output_view(offset, this->strtab_size_);
  this->write_to_buffer(view, this->strtab_size_);
  of->write_output_view(offset, this->strtab_size_, view);
}

// Print statistical information to stderr.  This is used for --stats.

template<typename Stringpool_char>
void
Stringpool_template<Stringpool_char>::print_stats(const char* name) const
{
#if defined(HAVE_TR1_UNORDERED_MAP) || defined(HAVE_EXT_HASH_MAP)
  fprintf(stderr, _("%s: %s entries: %zu; buckets: %zu\n"),
	  program_name, name, this->string_set_.size(),
	  this->string_set_.bucket_count());
#else
  fprintf(stderr, _("%s: %s entries: %zu\n"),
	  program_name, name, this->table_.size());
#endif
  fprintf(stderr, _("%s: %s Stringdata structures: %zu\n"),
	  program_name, name, this->strings_.size());
}

// Instantiate the templates we need.

template
class Stringpool_template<char>;

template
class Stringpool_template<uint16_t>;

template
class Stringpool_template<uint32_t>;

} // End namespace gold.
@


1.35
log
@2013-04-29  Alexander Ivchenko  <alexander.ivchenko@@intel.com>

gold/
	* output.cc (Output_section::add_merge_input_section): Allow
	to merge sections if the alignment is more than character size.
	* merge.h (Output_merge_string::Output_merge_string): Remove
	assert.
	* merge.cc (Output_merge_string<Char_type>::do_add_input_section): Count
	only not-null strings. Check the alignment of strings.
	* stringpool.h
	(Stringpool_template<Stringpool_char>::Stringpool_template): Add
	alignment as the argument.
	(Stringpool_template<Stringpool_char>::addralign_): New class member.
	* stringpool.cc (Stringpool_template<Stringpool_char>::new_key_offset):
	Align non-zero length strings according to the addralign_.
	(Stringpool_template<Stringpool_char>::set_string_offsets):
	Updating offsets according to the given alignment.
	* testsuite/Makefile.am (text_section_grouping): Test if string
	literals are getting merged.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/merge_string_literals_1.c: New file.
	* testsuite/merge_string_literals_2.c: Ditto.
	* testsuite/merge_string_literals.sh: Ditto.
@
text
@d225 1
d228 1
a228 1
	offset = align_address(this->offset_, this->addralign_);
@


1.34
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d37 1
a37 1
Stringpool_template<Stringpool_char>::Stringpool_template()
d39 2
a40 1
    zero_null_(true), optimize_(false), offset_(sizeof(Stringpool_char))
d225 4
a228 2
      offset = this->offset_;
      this->offset_ += (length + 1) * sizeof(Stringpool_char);
d427 2
a428 2
              this_offset = offset;
              offset += ((*curr)->first.length + 1) * charsize;
@


1.33
log
@	* merge.cc (Output_merge_string::do_add_input_section): Count strings
	to reserve space in merged_strings vector. Keep total input size
	for stats.
	(Output_merge_string::do_print_merge_stats): Print total input size.
	* merge.h (Output_merge_string): Add input_size_ field.
	* stringpool.cc (Stringpool_template::string_length): Move
	implementations out of Stringpool_template class and place in
	stringpool.h.
	* stringpool.h (string_length): Move out of Stringpool_template.
@
text
@d172 1
a172 1
      Stringdata *psd = this->strings_.front();
d188 1
a188 1
  Stringdata *psd = reinterpret_cast<Stringdata*>(new char[alc]);
@


1.32
log
@2010-03-19  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Stub_table::Stub_table): Initialize new data members
	Stub_table::reloc_stubs_size_ and Stub_table::reloc_stubs_addralign_.
	(Stub_table::add_reloc_stub): Assign stub offset and update
	Stub_table::reloc_stubs_size_ and Stub_table::reloc_stubs_addralign_.
	(Stub_table::reloc_stubs_size_, Stub_table::reloc_stubs_addralign_):
	New data members.
 	(Stub_table::update_data_size_and_addralign): Use
	Stub_table::reloc_stubs_size_ and Stub_table::reloc_stubs_addralign_
	instead of going over all reloc stubs.
 	(Stub_table::finalize_stubs): Do not assign reloc stub offsets.
	* stringpool.cc (Stringpool_template::Stringpool_template): Initialize
	Stringpool_template::offset_ to size of Stringpool_char.
 	(Stringpool_template::new_key_offset): Remove code to initialize
	Stringpool_template::offset_.
	* stringpool.h (Stringpool_template::set_no_zero_null): Set
	Stringpool_template::offset_ to zero.
@
text
@a89 22
// Return the length of a string of arbitrary character type.

template<typename Stringpool_char>
size_t
Stringpool_template<Stringpool_char>::string_length(const Stringpool_char* p)
{
  size_t len = 0;
  for (; *p != 0; ++p)
    ++len;
  return len;
}

// Specialize string_length for char.  Maybe we could just use
// std::char_traits<>::length?

template<>
inline size_t
Stringpool_template<char>::string_length(const char* p)
{
  return strlen(p);
}

@


1.31
log
@2010-03-15  Doug Kwan  <dougkwan@@google.com>

	* stringpool.cc (Stringpool_template::Stringpool_template): Initialize
	offset_.
	(Stringpool_template::new_key_offset): New method.
	(Stringpool_template::add_string): Assign offsets when adding new
	strings.
	(Stringpool_template::set_string_offsets): Do not set string offsets
	when not optimizing.
	* stringpool.h (Chunked_vector::Chunked_vector): Initialize data
	member size_.
   	(Chunked_vector::clear): Clear size_.
   	(Chunked_vector::reserve): Call reserve method of all Element_vectors.
   	(Chunked_vector::size): Return size_.
   	(Chunked_vector::push_back): Use size_ to find insert position.
	(Chunked_vector::size_): New data member.
	(Stringpool_template::set_no_zero_null): Assert string set is empty.
	(Stringpool_template::new_key_offset): New method declaration.
	(Stringpool_template::offset_): New data member.
@
text
@d39 1
a39 1
    zero_null_(true), optimize_(false), offset_(0)
a240 3
  if (this->key_to_offset_.size() == 0)
    this->offset_ = this->zero_null_ ? sizeof(Stringpool_char) : 0;
    
@


1.30
log
@2009-10-21  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Update copyright comments.
	(Target_arm): New forward class template declaration.
	(Arm_address): New type.
	(ARM_MAX_FWD_BRANCH_OFFSET, ARM_MAX_BWD_BRANCH_OFFSET,
	THM_MAX_FWD_BRANCH_OFFSET, THM_MAX_BWD_BRANCH_OFFSET,
	THM2_MAX_FWD_BRANCH_OFFSET, THM2_MAX_BWD_BRANCH_OFFSET): New
	constants.
	(Insn_template): Same.
	(DEF_STUBS): New macro.
	(Stub_type): New enum type.
	(Stub_template): New class definition.
	(Stub): Same.
	(Reloc_stub): Same.
	(Stub_factory): Same.
	(Target_arm::Target_arm): Initialize may_use_blx_ and
	should_force_pic_veneer_.
	(Target_arm::may_use_blx, Target_arm::set_may_use_blx,
	Target_arm::should_force_pic_veneer,
	Target_arm::set_should_force_pic_veneer, Target_arm::using_thumb2,
	Target_arm::using_thumb_only, Target_arm:;default_target): New
	method defintions.
	(Target_arm::may_use_blx_, Target_arm::should_force_pic_veneer_):
	New data member declarations.
	(Insn_template::size, Insn_template::alignment): New method defintions.
	(Stub_template::Stub_template): New method definition.
	(Reloc_stub::Key::name, Reloc_stub::stub_type_for_reloc,
	Reloc_stub::do_fixed_endian_write, Reloc_stub::do_write): Same.
	(Stub_factory::Stub_factory): New method definition.
	* gold.h (string_hash): New template.
	* output.h (Input_section_specifier::hash_value): Use
	gold::string_hash.
	(Input_section_specifier::string_hash): Remove.
	* stringpool.cc (Stringpool_template::string_hash): Use
	gold::string_hash.
@
text
@d39 1
a39 1
    zero_null_(true), optimize_(false)
d235 20
d282 1
a282 1
	  this->key_to_offset_.push_back(0);
d308 1
a308 1
  this->key_to_offset_.push_back(0);
d413 2
a414 13
      for (typename String_set_type::iterator curr = this->string_set_.begin();
           curr != this->string_set_.end();
           curr++)
        {
	  section_offset_type* poff = &this->key_to_offset_[curr->second - 1];
          if (this->zero_null_ && curr->first.string[0] == 0)
            *poff = 0;
          else
            {
              *poff = offset;
              offset += (curr->first.length + 1) * charsize;
            }
        }
@


1.29
log
@	PR 10133
	* stringpool.h (class Stringpool_template): Add optimize_ field.
	(Stringpool_template::set_optimize): New function.
	* stringpool.cc (Stringpool_template::Stringpool_template):
	Initialize optimize_ field.
	(Stringpool_template::set_string_offsets): Test local optimize
	fild rather than parameter.
	* layout.cc (Layout::Layout): Call set_optimize on the section
	name stringpool.
@
text
@d156 1
a156 10
  // This is the hash function used by the dynamic linker for
  // DT_GNU_HASH entries.  I compared this to a Fowler/Noll/Vo hash
  // for a C++ program with 385,775 global symbols.  This hash
  // function was very slightly worse.  However, it is much faster to
  // compute.  Overall wall clock time was a win.
  const unsigned char* p = reinterpret_cast<const unsigned char*>(s);
  size_t h = 5381;
  for (size_t i = 0; i < length * sizeof(Stringpool_char); ++i)
    h = h * 33 + *p++;
  return h;
@


1.28
log
@	* stringpool.cc (Stringpool_template::add_with_length): Set key to
	array size plus one.
	(Stringpool_template::set_string_offsets): Subtract one from key
	before using it as an array index.
	(Stringpool_template::get_offset_with_length): Likewise.
	(Stringpool_template::write_to_buffer): Likewise.
	* stringpool.h (Stringpool_template::get_offset_from_key):
	Likewise.
@
text
@d39 1
a39 1
    zero_null_(true)
d41 2
d400 1
a400 1
  if (parameters->options().optimize() < 2)
@


1.27
log
@Update copyright years.  Update language files.
@
text
@d251 2
a252 1
  const Key k = this->key_to_offset_.size();
d404 1
a404 1
	  section_offset_type* poff = &this->key_to_offset_[curr->second];
d450 1
a450 1
	  this->key_to_offset_[(*curr)->second] = this_offset;
d479 1
a479 1
    return this->key_to_offset_[p->second];
d500 1
a500 1
      const section_offset_type offset = this->key_to_offset_[p->second];
@


1.26
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.25
log
@From Craig Silverstein: rename option functions for future option
handling rewrite.
@
text
@d397 1
a397 1
  if (parameters->optimize() < 2)
@


1.24
log
@Use a simpler hash function.
@
text
@d397 1
a397 1
  if (parameters->optimization_level() < 2)
@


1.23
log
@Move Stringpool offsets into a chunked_vector indexed by keys.
@
text
@d154 5
a158 1
  // Fowler/Noll/Vo (FNV) hash (type FNV-1a).
d160 4
a163 20
  if (sizeof(size_t) > 4)
    {
      size_t result = static_cast<size_t>(14695981039346656037ULL);
      for (size_t i = 0; i < length * sizeof(Stringpool_char); ++i)
	{
	  result ^= static_cast<size_t>(*p++);
	  result *= 1099511628211ULL;
	}
      return result;
    }
  else
    {
      size_t result = 2166136261UL;
      for (size_t i = 0; i < length * sizeof(Stringpool_char); ++i)
	{
	  result ^= static_cast<size_t>(*p++);
	  result *= 16777619UL;
	}
      return result;
    }
@


1.22
log
@Use string length when available when calling Stringpool.  Compare
pointers first when looking up Stringpool entries.
@
text
@d38 2
a39 2
  : string_set_(), strings_(), strtab_size_(0), next_index_(1),
    next_uncopied_key_(-1), zero_null_(true)
d52 1
d71 2
d186 1
a186 2
						 size_t len,
						 Key* pkey)
a222 3
	  if (pkey != NULL)
	    *pkey = psd->index * key_mult + psd->len;

a234 9
  psd->index = this->next_index_;
  ++this->next_index_;

  if (pkey != NULL)
    {
      *pkey = psd->index * key_mult;
      // Ensure there was no overflow.
      gold_assert(*pkey / key_mult == psd->index);
    }
d263 2
d270 1
a270 4
      const Key k = this->next_uncopied_key_;
      const section_offset_type ozero = 0;
      std::pair<Hashkey, Hashval> element(Hashkey(s, length),
					  std::make_pair(k, ozero));
d280 1
a280 1
	  --this->next_uncopied_key_;
d284 1
a284 1
	  gold_assert(k != p->second.first);
d288 1
a288 1
	*pkey = p->second.first;
d302 1
a302 1
	*pkey = p->second.first;
d306 3
a308 2
  Key k;
  hk.string = this->add_string(s, length, &k);
d312 1
a312 2
  const section_offset_type ozero = 0;
  std::pair<Hashkey, Hashval> element(hk, std::make_pair(k, ozero));
d333 1
a333 1
    *pkey = p->second.first;
d415 1
d417 1
a417 1
            curr->second.second = 0;
d420 1
a420 1
              curr->second.second = offset;
d439 1
d445 1
d447 1
a447 1
            (*curr)->second.second = 0;
d453 3
a455 4
            (*curr)->second.second = ((*last)->second.second
				      + (((*last)->first.length
					  - (*curr)->first.length)
					 * charsize));
d458 1
a458 1
              (*curr)->second.second = offset;
d461 2
d490 1
a490 1
    return p->second.second;
d511 2
a512 1
      gold_assert(static_cast<section_size_type>(p->second.second) + len
d514 1
a514 1
      memcpy(buffer + p->second.second, p->first.string, len);
@


1.21
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d139 3
a141 2
	  && memcmp(h1.string, h2.string,
		    h1.length * sizeof(Stringpool_char)) == 0);
d261 10
d280 1
a280 1
      std::pair<Hashkey, Hashval> element(Hashkey(s),
d303 1
a303 12
  return this->add_prefix(s, string_length(s), pkey);
}

// Add a prefix of a string to a string pool.

template<typename Stringpool_char>
const Stringpool_char*
Stringpool_template<Stringpool_char>::add_prefix(const Stringpool_char* s,
                                                 size_t len,
                                                 Key* pkey)
{
  // When adding an entry, this will look it up twice in the hash
d306 1
a306 2
  // code will only be computed once, so this isn't all that
  // expensive.
d308 1
a308 1
  Hashkey hk(s, len);
d318 1
a318 1
  hk.string = this->add_string(s, len, &k);
a324 1
  typedef std::pair<typename String_set_type::iterator, bool> Insert_type;
d484 9
d494 2
a495 1
  typename String_set_type::const_iterator p = this->string_set_.find(s);
@


1.20
log
@From Craig Silverstein: size hash tables to avoid resizing.
@
text
@d268 1
a268 1
      const off_t ozero = 0;
d323 1
a323 1
  const off_t ozero = 0;
d415 1
a415 1
  off_t offset = this->zero_null_ ? charsize : 0;
d482 1
a482 1
off_t
d497 3
a499 2
Stringpool_template<Stringpool_char>::write_to_buffer(unsigned char* buffer,
                                                      size_t bufsize)
d502 1
a502 3
   // Quiet the compiler in opt mode.
  if (bufsize < static_cast<size_t>(this->strtab_size_))
    gold_assert(bufsize >= static_cast<size_t>(this->strtab_size_));
d510 2
a511 1
      gold_assert(p->second.second + len <= this->strtab_size_);
@


1.19
log
@Rework Stringpool to not compute the hash code twice when adding a new
string.
@
text
@d61 24
d239 5
a243 1
    *pkey = psd->index * key_mult;
@


1.18
log
@Stringpool stats.  Also make Symbol_table support functions inline.
@
text
@d83 1
a83 1
// Equality comparison function.
d87 2
a88 3
Stringpool_template<Stringpool_char>::Stringpool_eq::operator()(
    const Stringpool_char* s1,
    const Stringpool_char* s2) const
d96 1
a96 1
// Specialize equality comparison for char.
d99 2
a100 3
bool
Stringpool_template<char>::Stringpool_eq::operator()(const char* s1,
						     const char* s2) const
d105 15
a119 1
// Hash function.
d123 2
a124 2
Stringpool_template<Stringpool_char>::Stringpool_hash::operator()(
    const Stringpool_char* s) const
d127 1
d131 1
a131 1
      while (*s != 0)
d133 2
a134 7
	  const char* p = reinterpret_cast<const char*>(s);
	  for (size_t i = 0; i < sizeof(Stringpool_char); ++i)
	    {
	      result ^= (size_t) *p++;
	      result *= 1099511628211ULL;
	    }
	  ++s;
d141 1
a141 1
      while (*s != 0)
d143 2
a144 7
	  const char* p = reinterpret_cast<const char*>(s);
	  for (size_t i = 0; i < sizeof(Stringpool_char); ++i)
	    {
	      result ^= (size_t) *p++;
	      result *= 16777619UL;
	    }
	  ++s;
d150 4
a153 2
// Add a string to the list of canonical strings.  Return a pointer to
// the canonical string.  If PKEY is not NULL, set *PKEY to the key.
d158 1
d171 3
a173 1
  size_t len = (string_length(s) + 1) * sizeof(Stringpool_char);
d192 3
a194 1
	  memcpy(ret, s, len);
d207 3
a209 1
  memcpy(psd->data, s, len);
d232 1
a232 5
  // FIXME: This will look up the entry twice in the hash table.  The
  // problem is that we can't insert S before we canonicalize it.  I
  // don't think there is a way to handle this correctly with
  // unordered_map, so this should be replaced with custom code to do
  // what we need, which is to return the empty slot.
d234 1
a234 2
  typename String_set_type::const_iterator p = this->string_set_.find(s);
  if (p != this->string_set_.end())
d236 23
d261 1
a261 1
      return p->first;
d264 1
a264 22
  Key k;
  const Stringpool_char* ret;
  if (copy)
    ret = this->add_string(s, &k);
  else
    {
      ret = s;
      k = this->next_uncopied_key_;
      --this->next_uncopied_key_;
    }

  const off_t ozero = 0;
  std::pair<const Stringpool_char*, Val> element(ret,
						 std::make_pair(k, ozero));
  std::pair<typename String_set_type::iterator, bool> ins =
    this->string_set_.insert(element);
  gold_assert(ins.second);

  if (pkey != NULL)
    *pkey = k;

  return ret;
d275 30
a304 4
  // FIXME: This implementation should be rewritten when we rewrite
  // the hash table to avoid copying.
  std::basic_string<Stringpool_char> st(s, len);
  return this->add(st.c_str(), true, pkey);
d312 2
a313 1
  typename String_set_type::const_iterator p = this->string_set_.find(s);
d320 1
a320 1
  return p->first;
d340 6
a345 4
  const Stringpool_char* s1 = sort_info1.it->first;
  const Stringpool_char* s2 = sort_info2.it->first;
  const size_t len1 = sort_info1.string_length;
  const size_t len2 = sort_info2.string_length;
d400 1
a400 1
          if (this->zero_null_ && curr->first[0] == 0)
d405 1
a405 1
              offset += (string_length(curr->first) + 1) * charsize;
d419 1
a419 1
        v.push_back(Stringpool_sort_info(p, string_length(p->first)));
d428 2
a429 2
          if (this->zero_null_ && curr->it->first[0] == 0)
            curr->it->second.second = 0;
d431 8
a438 6
                   && is_suffix(curr->it->first, curr->string_length,
                                last->it->first, last->string_length))
            curr->it->second.second = (last->it->second.second
                                       + ((last->string_length
                                           - curr->string_length)
                                          * charsize));
d441 2
a442 2
              curr->it->second.second = offset;
              offset += (curr->string_length + 1) * charsize;
d482 1
a482 1
      const int len = (string_length(p->first) + 1) * sizeof(Stringpool_char);
d484 1
a484 1
      memcpy(buffer + p->second.second, p->first, len);
@


1.17
log
@Add casts to avoid warnings.
@
text
@d460 18
@


1.16
log
@Compress all debug sections.
@
text
@d433 3
a435 2
  if (bufsize < this->strtab_size_)   // Quiet the compiler in opt mode.
    gold_assert(bufsize >= this->strtab_size_);
@


1.15
log
@From Craig Silverstein: Add support for compressing .debug_str section.
@
text
@d429 1
a429 1
Stringpool_template<Stringpool_char>::write_to_buffer(char* buffer,
d455 1
a455 1
  this->write_to_buffer(reinterpret_cast<char*>(view), this->strtab_size_);
@


1.14
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d44 2
a45 1
Stringpool_template<Stringpool_char>::~Stringpool_template()
d51 8
d425 1
a425 1
// Write the ELF strtab into the output file at the specified offset.
d429 2
a430 1
Stringpool_template<Stringpool_char>::write(Output_file* of, off_t offset)
d433 2
a434 2
  unsigned char* viewu = of->get_output_view(offset, this->strtab_size_);
  char* view = reinterpret_cast<char*>(viewu);
d436 1
a436 1
    view[0] = '\0';
d440 17
a456 3
    memcpy(view + p->second.second, p->first,
	   (string_length(p->first) + 1) * sizeof(Stringpool_char));
  of->write_output_view(offset, this->strtab_size_, viewu);
@


1.13
log
@Add an option for Stringpools to not copy strings.
@
text
@d106 1
a106 1
  if (sizeof(size_t) == 8)
@


1.12
log
@From Andrew Chatham: fix bug in 64-bit hash.
@
text
@d39 1
a39 1
    zero_null_(true)
d208 2
a209 1
Stringpool_template<Stringpool_char>::add(const Stringpool_char* s, Key* pkey)
d226 9
a234 1
  const Stringpool_char* ret = this->add_string(s, &k);
d253 3
a255 2
Stringpool_template<Stringpool_char>::add(const Stringpool_char* s, size_t len,
				 Key* pkey)
d260 1
a260 1
  return this->add(st, pkey);
@


1.11
log
@Add licensing text to every source file.
@
text
@d114 1
a114 1
	      result &= (size_t) *p++;
@


1.10
log
@From Craig Silverstein: Only sort for suffixes with -O2.
@
text
@d3 20
@


1.9
log
@Set Stringpool zero_null option via a call, not a default constructor
argument.
@
text
@d10 1
a306 12
  size_t count = this->string_set_.size();

  std::vector<Stringpool_sort_info> v;
  v.reserve(count);

  for (typename String_set_type::iterator p = this->string_set_.begin();
       p != this->string_set_.end();
       ++p)
    v.push_back(Stringpool_sort_info(p, string_length(p->first)));

  std::sort(v.begin(), v.end(), Stringpool_sort_comparison());

d312 6
a317 4
  for (typename std::vector<Stringpool_sort_info>::iterator last = v.end(),
         curr = v.begin();
       curr != v.end();
       last = curr++)
d319 47
a365 14
      if (this->zero_null_ && curr->it->first[0] == 0)
	curr->it->second.second = 0;
      else if (last != v.end()
               && is_suffix(curr->it->first, curr->string_length,
                            last->it->first, last->string_length))
	curr->it->second.second = (last->it->second.second
                                   + ((last->string_length
                                       - curr->string_length)
                                      * charsize));
      else
	{
	  curr->it->second.second = offset;
	  offset += (curr->string_length + 1) * charsize;
	}
@


1.8
log
@Compute string lengths before sorting.  From Craig Silverstein.
@
text
@d16 1
a16 1
Stringpool_template<Stringpool_char>::Stringpool_template(bool zero_null)
d18 1
a18 1
    zero_null_(zero_null)
@


1.7
log
@Add support for SHF_MERGE sections.
@
text
@d261 2
a262 2
  typename String_set_type::iterator it1,
  typename String_set_type::iterator it2) const
d264 5
a268 5
  const Stringpool_char* s1 = it1->first;
  const Stringpool_char* s2 = it2->first;
  size_t len1 = string_length(s1);
  size_t len2 = string_length(s2);
  size_t minlen = len1 < len2 ? len1 : len2;
d284 3
a286 1
						const Stringpool_char* s2)
a287 2
  size_t len1 = string_length(s1);
  size_t len2 = string_length(s2);
d308 1
a308 1
  std::vector<typename String_set_type::iterator> v;
d314 1
a314 1
    v.push_back(p);
d322 5
a326 1
  for (size_t i = 0; i < count; ++i)
d328 9
a336 7
      if (this->zero_null_ && v[i]->first[0] == 0)
	v[i]->second.second = 0;
      else if (i > 0 && is_suffix(v[i]->first, v[i - 1]->first))
	v[i]->second.second = (v[i - 1]->second.second
			       + ((string_length(v[i - 1]->first)
				   - string_length(v[i]->first))
				  * charsize));
d339 2
a340 2
	  v[i]->second.second = offset;
	  offset += (string_length(v[i]->first) + 1) * charsize;
@


1.6
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d15 4
a18 2
Stringpool::Stringpool()
  : string_set_(), strings_(), strtab_size_(0), next_index_(1)
d22 2
a23 1
Stringpool::~Stringpool()
d25 1
a25 1
  for (std::list<Stringdata*>::iterator p = this->strings_.begin();
d31 46
d79 1
d81 2
a82 1
Stringpool::Stringpool_hash::operator()(const char* s) const
d88 1
a88 1
      while (*s != '\0')
d90 7
a96 2
	  result &= (size_t) *s++;
	  result *= 1099511628211ULL;
d103 1
a103 1
      while (*s != '\0')
d105 7
a111 2
	  result ^= (size_t) *s++;
	  result *= 16777619UL;
d120 4
a123 2
const char*
Stringpool::add_string(const char* s, Key* pkey)
d135 1
a135 1
  size_t len = strlen(s);
d139 1
a139 1
  if (len >= buffer_size)
d149 1
a149 1
      if (len >= psd->alc - psd->len)
d154 1
a154 1
	  memcpy(ret, s, len + 1);
d159 1
a159 1
	  psd->len += len + 1;
d161 1
a161 1
	  return ret;
d167 2
a168 2
  memcpy(psd->data, s, len + 1);
  psd->len = len + 1;
d180 1
a180 1
  return psd->data;
d185 3
a187 2
const char*
Stringpool::add(const char* s, Key* pkey)
d195 1
a195 1
  String_set_type::const_iterator p = this->string_set_.find(s);
d204 1
a204 1
  const char* ret = this->add_string(s, &k);
d207 3
a209 2
  std::pair<const char*, Val> element(ret, std::make_pair(k, ozero));
  std::pair<String_set_type::iterator, bool> ins =
d221 4
a224 2
const char*
Stringpool::add(const char* s, size_t len, Key* pkey)
d228 1
a228 1
  std::string st(s, len);
d232 4
a235 2
const char*
Stringpool::find(const char* s, Key* pkey) const
d237 1
a237 1
  String_set_type::const_iterator p = this->string_set_.find(s);
d258 1
d260 12
a271 12
Stringpool::Stringpool_sort_comparison::operator()(
  String_set_type::iterator it1,
  String_set_type::iterator it2) const
{
  const char* s1 = it1->first;
  const char* s2 = it2->first;
  int len1 = strlen(s1);
  int len2 = strlen(s2);
  int minlen = len1 < len2 ? len1 : len2;
  const char* p1 = s1 + len1 - 1;
  const char* p2 = s2 + len2 - 1;
  for (int i = minlen - 1; i >= 0; --i, --p1, --p2)
d281 1
d283 2
a284 1
Stringpool::is_suffix(const char* s1, const char* s2)
d286 2
a287 2
  size_t len1 = strlen(s1);
  size_t len2 = strlen(s2);
d290 1
a290 1
  return strcmp(s1, s2 + len2 - len1) == 0;
d296 1
d298 1
a298 1
Stringpool::set_string_offsets()
d308 1
a308 1
  std::vector<String_set_type::iterator> v;
d311 1
a311 1
  for (String_set_type::iterator p = this->string_set_.begin();
d318 4
a321 2
  // Offset 0 is reserved for the empty string.
  off_t offset = 1;
d324 1
a324 1
      if (v[i]->first[0] == '\0')
d326 1
a326 1
      else if (i > 0 && Stringpool::is_suffix(v[i]->first, v[i - 1]->first))
d328 3
a330 2
			       + strlen(v[i - 1]->first)
			       - strlen(v[i]->first));
d334 1
a334 1
	  offset += strlen(v[i]->first) + 1;
d344 1
d346 2
a347 1
Stringpool::get_offset(const char* s) const
d350 1
a350 1
  String_set_type::const_iterator p = this->string_set_.find(s);
d358 1
d360 1
a360 1
Stringpool::write(Output_file* of, off_t offset)
d365 3
a367 2
  view[0] = '\0';
  for (String_set_type::const_iterator p = this->string_set_.begin();
d370 2
a371 1
    strcpy(view + p->second.second, p->first);
d374 11
@


1.5
log
@Rework stringpool and hash tables so that we always generate the same
output regardless of randomize_va_space.
@
text
@a4 1
#include <cassert>
d62 3
d70 1
a70 1
  assert(key_mult >= buffer_size);
d146 1
a146 1
  assert(ins.second);
d227 6
d271 1
d275 1
a275 1
  abort();
d283 1
@


1.4
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d17 1
a17 1
  : string_set_(), strings_(), strtab_size_(0)
d58 1
a58 1
// the canonical string.
d61 1
a61 1
Stringpool::add_string(const char* s)
d63 1
d65 5
d90 4
d95 1
d104 6
d114 1
d121 1
a121 1
Stringpool::add(const char* s)
d131 5
a135 1
    return p->first;
d137 5
a141 2
  const char* ret = this->add_string(s);
  std::pair<const char*, off_t> val(ret, 0);
d143 1
a143 1
    this->string_set_.insert(val);
d145 4
d155 1
a155 1
Stringpool::add(const char* s, size_t len)
d160 1
a160 1
  return this->add(st);
d164 1
a164 1
Stringpool::find(const char* s) const
d169 4
d242 1
a242 1
	v[i]->second = 0;
d244 3
a246 3
	v[i]->second = (v[i - 1]->second
			+ strlen(v[i - 1]->first)
			- strlen(v[i]->first));
d249 1
a249 1
	  v[i]->second = offset;
d265 1
a265 1
    return p->second;
d280 1
a280 1
    strcpy(view + p->second, p->first);
@


1.3
log
@gcc 4.1.0 portability fixes.
@
text
@d7 2
d10 1
d17 1
a17 1
  : string_set_(), strings_()
d23 1
a23 1
  for (std::list<stringdata*>::iterator p = this->strings_.begin();
d70 1
a70 1
      alc = sizeof(stringdata) + len;
d74 1
a74 1
    alc = sizeof(stringdata) + buffer_size;
d77 1
a77 1
      stringdata *psd = this->strings_.front();
d79 1
a79 1
	alc = sizeof(stringdata) + buffer_size;
d89 2
a90 2
  stringdata *psd = reinterpret_cast<stringdata*>(new char[alc]);
  psd->alc = alc;
d108 1
a108 1
  // unordered_set, so this should be replaced with custom code to do
d113 1
a113 1
    return *p;
d116 1
d118 1
a118 1
    this->string_set_.insert(ret);
d132 117
@


1.2
log
@New drop, with first cut of section layout code.
@
text
@d34 1
a34 1
      size_t result = 14695981039346656037ULL;
@


1.1
log
@Another snapshot of the current state of the sources.  Gets to the
point of symbol resolution and can now issue a multiple definition
error.  Also added target selection infrastructure.
@
text
@d104 1
a104 1
  // don't think there is a way to handle this correct with
@

