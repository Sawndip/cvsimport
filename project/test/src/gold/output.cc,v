head	1.185;
access;
symbols
	binutils-2_24-branch:1.184.0.2
	binutils-2_24-branchpoint:1.184
	binutils-2_21_1:1.137.2.1
	binutils-2_23_2:1.167.2.1
	binutils-2_23_1:1.167.2.1
	binutils-2_23:1.167
	binutils-2_23-branch:1.167.0.2
	binutils-2_23-branchpoint:1.167
	binutils-2_22_branch:1.159.0.4
	binutils-2_22:1.159
	binutils-2_22-branch:1.159.0.2
	binutils-2_22-branchpoint:1.159
	binutils-2_21:1.137.2.1
	binutils-2_21-branch:1.137.0.2
	binutils-2_21-branchpoint:1.137
	binutils-2_20_1:1.94.2.4
	binutils-2_20:1.94.2.1
	binutils-arc-20081103-branch:1.84.0.4
	binutils-arc-20081103-branchpoint:1.84
	binutils-2_20-branch:1.94.0.2
	binutils-2_20-branchpoint:1.94
	dje-cgen-play1-branch:1.92.0.2
	dje-cgen-play1-branchpoint:1.92
	arc-20081103-branch:1.84.0.2
	arc-20081103-branchpoint:1.84
	binutils-2_19_1:1.83
	binutils-2_19:1.83
	binutils-2_19-branch:1.83.0.2
	binutils-2_19-branchpoint:1.83
	binutils_latest_snapshot:1.185
	added-to-binutils:1.64;
locks; strict;
comment	@// @;


1.185
date	2013.10.11.22.02.21;	author roland;	state Exp;
branches;
next	1.184;

1.184
date	2013.08.27.21.49.48;	author roland;	state Exp;
branches
	1.184.2.1;
next	1.183;

1.183
date	2013.05.30.23.01.11;	author ccoutant;	state Exp;
branches;
next	1.182;

1.182
date	2013.04.29.17.15.08;	author ccoutant;	state Exp;
branches;
next	1.181;

1.181
date	2013.01.24.18.49.54;	author tmsriram;	state Exp;
branches;
next	1.180;

1.180
date	2013.01.07.21.36.56;	author ccoutant;	state Exp;
branches;
next	1.179;

1.179
date	2012.12.21.06.24.31;	author ian;	state Exp;
branches;
next	1.178;

1.178
date	2012.12.19.02.55.15;	author tmsriram;	state Exp;
branches;
next	1.177;

1.177
date	2012.12.03.05.30.59;	author amodra;	state Exp;
branches;
next	1.176;

1.176
date	2012.11.01.22.35.06;	author roland;	state Exp;
branches;
next	1.175;

1.175
date	2012.10.05.00.45.54;	author amodra;	state Exp;
branches;
next	1.174;

1.174
date	2012.09.12.18.29.18;	author ian;	state Exp;
branches;
next	1.173;

1.173
date	2012.09.10.23.10.41;	author amodra;	state Exp;
branches;
next	1.172;

1.172
date	2012.09.10.23.05.54;	author amodra;	state Exp;
branches;
next	1.171;

1.171
date	2012.09.05.00.34.20;	author amodra;	state Exp;
branches;
next	1.170;

1.170
date	2012.08.30.05.54.59;	author amodra;	state Exp;
branches;
next	1.169;

1.169
date	2012.08.24.18.35.34;	author tmsriram;	state Exp;
branches;
next	1.168;

1.168
date	2012.08.11.04.41.28;	author amodra;	state Exp;
branches;
next	1.167;

1.167
date	2012.06.06.22.12.47;	author ccoutant;	state Exp;
branches
	1.167.2.1;
next	1.166;

1.166
date	2012.04.17.01.50.39;	author davem;	state Exp;
branches;
next	1.165;

1.165
date	2012.01.04.00.18.23;	author ccoutant;	state Exp;
branches;
next	1.164;

1.164
date	2011.12.19.21.07.16;	author ian;	state Exp;
branches;
next	1.163;

1.163
date	2011.10.18.21.36.29;	author ccoutant;	state Exp;
branches;
next	1.162;

1.162
date	2011.10.13.05.06.45;	author ccoutant;	state Exp;
branches;
next	1.161;

1.161
date	2011.10.10.17.29.52;	author ccoutant;	state Exp;
branches;
next	1.160;

1.160
date	2011.09.29.23.45.57;	author tmsriram;	state Exp;
branches;
next	1.159;

1.159
date	2011.09.10.05.15.43;	author davem;	state Exp;
branches
	1.159.2.1;
next	1.158;

1.158
date	2011.08.29.18.22.30;	author ccoutant;	state Exp;
branches;
next	1.157;

1.157
date	2011.08.27.01.28.17;	author ccoutant;	state Exp;
branches;
next	1.156;

1.156
date	2011.07.14.00.55.18;	author tmsriram;	state Exp;
branches;
next	1.155;

1.155
date	2011.07.08.22.48.08;	author ian;	state Exp;
branches;
next	1.154;

1.154
date	2011.07.06.21.19.32;	author ccoutant;	state Exp;
branches;
next	1.153;

1.153
date	2011.06.29.21.26.40;	author ian;	state Exp;
branches;
next	1.152;

1.152
date	2011.06.23.00.46.13;	author ian;	state Exp;
branches;
next	1.151;

1.151
date	2011.06.08.04.43.28;	author ccoutant;	state Exp;
branches;
next	1.150;

1.150
date	2011.06.08.04.34.22;	author ccoutant;	state Exp;
branches;
next	1.149;

1.149
date	2011.06.08.04.05.24;	author ccoutant;	state Exp;
branches;
next	1.148;

1.148
date	2011.06.02.13.43.21;	author nickc;	state Exp;
branches;
next	1.147;

1.147
date	2011.05.25.00.17.47;	author ian;	state Exp;
branches;
next	1.146;

1.146
date	2011.05.24.23.31.07;	author ccoutant;	state Exp;
branches;
next	1.145;

1.145
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.144;

1.144
date	2011.05.23.23.27.10;	author ccoutant;	state Exp;
branches;
next	1.143;

1.143
date	2011.04.22.23.20.28;	author ian;	state Exp;
branches;
next	1.142;

1.142
date	2011.04.12.18.06.16;	author ian;	state Exp;
branches;
next	1.141;

1.141
date	2011.04.12.00.44.48;	author ccoutant;	state Exp;
branches;
next	1.140;

1.140
date	2011.02.12.03.19.24;	author tmsriram;	state Exp;
branches;
next	1.139;

1.139
date	2010.11.16.19.18.31;	author ccoutant;	state Exp;
branches;
next	1.138;

1.138
date	2010.11.16.18.38.29;	author ccoutant;	state Exp;
branches;
next	1.137;

1.137
date	2010.10.29.20.49.20;	author dougkwan;	state Exp;
branches
	1.137.2.1;
next	1.136;

1.136
date	2010.10.18.05.39.23;	author ccoutant;	state Exp;
branches;
next	1.135;

1.135
date	2010.10.16.00.37.24;	author ccoutant;	state Exp;
branches;
next	1.134;

1.134
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.133;

1.133
date	2010.08.19.22.50.15;	author ian;	state Exp;
branches;
next	1.132;

1.132
date	2010.08.03.14.07.13;	author ian;	state Exp;
branches;
next	1.131;

1.131
date	2010.08.02.11.59.10;	author ian;	state Exp;
branches;
next	1.130;

1.130
date	2010.07.13.20.07.08;	author dougkwan;	state Exp;
branches;
next	1.129;

1.129
date	2010.07.12.17.59.58;	author ccoutant;	state Exp;
branches;
next	1.128;

1.128
date	2010.06.03.18.01.19;	author tmsriram;	state Exp;
branches;
next	1.127;

1.127
date	2010.06.01.23.37.57;	author tmsriram;	state Exp;
branches;
next	1.126;

1.126
date	2010.05.23.07.43.39;	author dougkwan;	state Exp;
branches;
next	1.125;

1.125
date	2010.05.19.07.09.36;	author dougkwan;	state Exp;
branches;
next	1.124;

1.124
date	2010.04.09.17.32.58;	author dougkwan;	state Exp;
branches;
next	1.123;

1.123
date	2010.04.09.00.04.30;	author dougkwan;	state Exp;
branches;
next	1.122;

1.122
date	2010.03.06.02.34.13;	author ian;	state Exp;
branches;
next	1.121;

1.121
date	2010.03.01.21.43.49;	author dougkwan;	state Exp;
branches;
next	1.120;

1.120
date	2010.02.13.00.01.20;	author davem;	state Exp;
branches;
next	1.119;

1.119
date	2010.02.09.20.29.44;	author davem;	state Exp;
branches;
next	1.118;

1.118
date	2010.01.23.01.07.59;	author dougkwan;	state Exp;
branches;
next	1.117;

1.117
date	2010.01.20.17.29.52;	author dougkwan;	state Exp;
branches;
next	1.116;

1.116
date	2010.01.19.17.55.48;	author ian;	state Exp;
branches;
next	1.115;

1.115
date	2010.01.15.04.58.34;	author dougkwan;	state Exp;
branches;
next	1.114;

1.114
date	2010.01.08.19.33.18;	author ian;	state Exp;
branches;
next	1.113;

1.113
date	2010.01.07.21.09.31;	author ian;	state Exp;
branches;
next	1.112;

1.112
date	2010.01.06.22.37.18;	author ian;	state Exp;
branches;
next	1.111;

1.111
date	2009.12.30.19.29.20;	author ian;	state Exp;
branches;
next	1.110;

1.110
date	2009.12.30.06.57.17;	author ian;	state Exp;
branches;
next	1.109;

1.109
date	2009.12.30.04.00.21;	author ian;	state Exp;
branches;
next	1.108;

1.108
date	2009.12.17.00.00.26;	author dougkwan;	state Exp;
branches;
next	1.107;

1.107
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.106;

1.106
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.105;

1.105
date	2009.11.05.19.56.41;	author ian;	state Exp;
branches;
next	1.104;

1.104
date	2009.11.05.19.54.30;	author ian;	state Exp;
branches;
next	1.103;

1.103
date	2009.11.04.15.56.03;	author ian;	state Exp;
branches;
next	1.102;

1.102
date	2009.10.30.18.49.59;	author dougkwan;	state Exp;
branches;
next	1.101;

1.101
date	2009.10.16.18.34.53;	author dougkwan;	state Exp;
branches;
next	1.100;

1.100
date	2009.10.16.05.00.29;	author ian;	state Exp;
branches;
next	1.99;

1.99
date	2009.10.14.05.25.02;	author ian;	state Exp;
branches;
next	1.98;

1.98
date	2009.10.09.23.18.19;	author dougkwan;	state Exp;
branches;
next	1.97;

1.97
date	2009.09.30.22.21.13;	author ian;	state Exp;
branches;
next	1.96;

1.96
date	2009.09.18.01.10.38;	author dougkwan;	state Exp;
branches;
next	1.95;

1.95
date	2009.09.08.22.32.50;	author ccoutant;	state Exp;
branches;
next	1.94;

1.94
date	2009.09.02.16.39.06;	author ian;	state Exp;
branches
	1.94.2.1;
next	1.93;

1.93
date	2009.09.01.17.32.20;	author ian;	state Exp;
branches;
next	1.92;

1.92
date	2009.06.24.19.48.51;	author ian;	state Exp;
branches;
next	1.91;

1.91
date	2009.06.22.06.51.53;	author ian;	state Exp;
branches;
next	1.90;

1.90
date	2009.04.24.19.48.21;	author cgd;	state Exp;
branches;
next	1.89;

1.89
date	2009.03.24.18.04.25;	author ian;	state Exp;
branches;
next	1.88;

1.88
date	2009.03.24.00.31.28;	author ian;	state Exp;
branches;
next	1.87;

1.87
date	2009.03.17.22.25.30;	author ian;	state Exp;
branches;
next	1.86;

1.86
date	2009.02.28.00.12.26;	author ian;	state Exp;
branches;
next	1.85;

1.85
date	2009.01.15.02.18.11;	author ccoutant;	state Exp;
branches;
next	1.84;

1.84
date	2008.09.29.21.10.26;	author ccoutant;	state Exp;
branches;
next	1.83;

1.83
date	2008.08.13.07.37.46;	author ian;	state Exp;
branches;
next	1.82;

1.82
date	2008.07.25.04.25.49;	author ian;	state Exp;
branches;
next	1.81;

1.81
date	2008.07.22.08.09.48;	author ian;	state Exp;
branches;
next	1.80;

1.80
date	2008.07.10.23.01.19;	author ian;	state Exp;
branches;
next	1.79;

1.79
date	2008.05.21.21.37.44;	author ian;	state Exp;
branches;
next	1.78;

1.78
date	2008.05.20.04.00.46;	author ian;	state Exp;
branches;
next	1.77;

1.77
date	2008.05.16.22.29.04;	author ian;	state Exp;
branches;
next	1.76;

1.76
date	2008.05.16.15.27.49;	author ian;	state Exp;
branches;
next	1.75;

1.75
date	2008.05.06.05.03.15;	author ian;	state Exp;
branches;
next	1.74;

1.74
date	2008.05.05.19.16.43;	author ian;	state Exp;
branches;
next	1.73;

1.73
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.72;

1.72
date	2008.04.15.04.06.41;	author ian;	state Exp;
branches;
next	1.71;

1.71
date	2008.04.11.22.55.13;	author ian;	state Exp;
branches;
next	1.70;

1.70
date	2008.04.11.21.24.29;	author ccoutant;	state Exp;
branches;
next	1.69;

1.69
date	2008.04.07.22.46.16;	author ian;	state Exp;
branches;
next	1.68;

1.68
date	2008.03.29.08.09.55;	author ian;	state Exp;
branches;
next	1.67;

1.67
date	2008.03.28.22.42.34;	author ian;	state Exp;
branches;
next	1.66;

1.66
date	2008.03.26.23.36.46;	author ian;	state Exp;
branches;
next	1.65;

1.65
date	2008.03.25.18.37.16;	author ccoutant;	state Exp;
branches;
next	1.64;

1.64
date	2008.03.19.21.41.38;	author iant;	state Exp;
branches;
next	1.63;

1.63
date	2008.03.16.23.51.19;	author iant;	state Exp;
branches;
next	1.62;

1.62
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.61;

1.61
date	2008.03.12.04.38.42;	author iant;	state Exp;
branches;
next	1.60;

1.60
date	2008.02.29.19.19.17;	author iant;	state Exp;
branches;
next	1.59;

1.59
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.58;

1.58
date	2008.02.12.00.28.48;	author iant;	state Exp;
branches;
next	1.57;

1.57
date	2008.02.07.07.33.46;	author iant;	state Exp;
branches;
next	1.56;

1.56
date	2008.02.06.19.32.32;	author iant;	state Exp;
branches;
next	1.55;

1.55
date	2008.02.06.08.13.50;	author iant;	state Exp;
branches;
next	1.54;

1.54
date	2008.02.04.22.54.31;	author iant;	state Exp;
branches;
next	1.53;

1.53
date	2008.02.04.06.45.50;	author iant;	state Exp;
branches;
next	1.52;

1.52
date	2008.02.04.05.41.40;	author iant;	state Exp;
branches;
next	1.51;

1.51
date	2008.01.18.23.26.48;	author iant;	state Exp;
branches;
next	1.50;

1.50
date	2008.01.06.00.47.10;	author iant;	state Exp;
branches;
next	1.49;

1.49
date	2008.01.04.05.04.56;	author iant;	state Exp;
branches;
next	1.48;

1.48
date	2007.12.21.23.08.25;	author iant;	state Exp;
branches;
next	1.47;

1.47
date	2007.12.21.21.19.45;	author iant;	state Exp;
branches;
next	1.46;

1.46
date	2007.12.20.16.27.30;	author iant;	state Exp;
branches;
next	1.45;

1.45
date	2007.12.20.01.29.04;	author iant;	state Exp;
branches;
next	1.44;

1.44
date	2007.12.18.21.24.08;	author iant;	state Exp;
branches;
next	1.43;

1.43
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.42;

1.42
date	2007.12.07.19.32.59;	author iant;	state Exp;
branches;
next	1.41;

1.41
date	2007.12.06.05.55.50;	author iant;	state Exp;
branches;
next	1.40;

1.40
date	2007.12.05.01.13.28;	author iant;	state Exp;
branches;
next	1.39;

1.39
date	2007.12.04.23.42.27;	author iant;	state Exp;
branches;
next	1.38;

1.38
date	2007.12.01.06.34.12;	author iant;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.30.00.35.27;	author iant;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.29.20.10.17;	author iant;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.20.04.26.15;	author iant;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.19.22.49.38;	author iant;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.15.23.46.46;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.14.22.31.02;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.09.19.45.08;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.07.18.29.34;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.18.17.46.23;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.16.23.23.08;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.15.03.35.35;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.14.06.57.58;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.14.06.49.14;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.10.06.29.10;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.08.07.22.21;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.26.07.01.34;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.23.03.17.38;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.21.07.20.01;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.21.05.31.19;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.04.20.00.53;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.16.17.42.48;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.01.16.51.25;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.01.00.10.37;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.30.23.52.50;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.16.00.38.25;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.03.18.38.43;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.03.18.26.10;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.29.22.34.01;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.29.19.58.17;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.27.22.53.42;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.26.21.00.34;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.21.22.13.18;	author iant;	state Exp;
branches;
next	;

1.184.2.1
date	2013.10.11.22.02.58;	author roland;	state Exp;
branches;
next	;

1.167.2.1
date	2012.11.07.17.31.30;	author roland;	state Exp;
branches;
next	1.167.2.2;

1.167.2.2
date	2013.08.27.21.50.25;	author roland;	state Exp;
branches;
next	;

1.159.2.1
date	2011.12.19.21.14.39;	author ian;	state Exp;
branches;
next	;

1.137.2.1
date	2010.11.18.08.25.00;	author gingold;	state Exp;
branches;
next	;

1.94.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	1.94.2.2;

1.94.2.2
date	2009.10.16.20.17.56;	author ian;	state Exp;
branches;
next	1.94.2.3;

1.94.2.3
date	2009.11.04.15.56.34;	author ian;	state Exp;
branches;
next	1.94.2.4;

1.94.2.4
date	2009.11.05.19.58.28;	author ian;	state Exp;
branches;
next	;


desc
@@


1.185
log
@gold/
	* target.h (Target::adjust_elf_header, Target::do_adjust_elf_header):
	Remove const from declaration.
	* target.cc (Sized_target::do_adjust_elf_header): Update definition.
	* sparc.cc (Target_sparc::do_adjust_elf_header): Likewise.
	* output.h (Output_file_header): Remove const from member target_
	and corresponding constructor argument.
	* output.cc (Output_file_header::Output_file_header): Update prototype.
	(Output_file_header::do_sized_write): Use this->target_ in place
	of parameters()->target().
@
text
@// output.cc -- manage the output file for gold

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cstdlib>
#include <cstring>
#include <cerrno>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <algorithm>

#ifdef HAVE_SYS_MMAN_H
#include <sys/mman.h>
#endif

#include "libiberty.h"

#include "dwarf.h"
#include "parameters.h"
#include "object.h"
#include "symtab.h"
#include "reloc.h"
#include "merge.h"
#include "descriptors.h"
#include "layout.h"
#include "output.h"

// For systems without mmap support.
#ifndef HAVE_MMAP
# define mmap gold_mmap
# define munmap gold_munmap
# define mremap gold_mremap
# ifndef MAP_FAILED
#  define MAP_FAILED (reinterpret_cast<void*>(-1))
# endif
# ifndef PROT_READ
#  define PROT_READ 0
# endif
# ifndef PROT_WRITE
#  define PROT_WRITE 0
# endif
# ifndef MAP_PRIVATE
#  define MAP_PRIVATE 0
# endif
# ifndef MAP_ANONYMOUS
#  define MAP_ANONYMOUS 0
# endif
# ifndef MAP_SHARED
#  define MAP_SHARED 0
# endif

# ifndef ENOSYS
#  define ENOSYS EINVAL
# endif

static void *
gold_mmap(void *, size_t, int, int, int, off_t)
{
  errno = ENOSYS;
  return MAP_FAILED;
}

static int
gold_munmap(void *, size_t)
{
  errno = ENOSYS;
  return -1;
}

static void *
gold_mremap(void *, size_t, size_t, int)
{
  errno = ENOSYS;
  return MAP_FAILED;
}

#endif

#if defined(HAVE_MMAP) && !defined(HAVE_MREMAP)
# define mremap gold_mremap
extern "C" void *gold_mremap(void *, size_t, size_t, int);
#endif

// Some BSD systems still use MAP_ANON instead of MAP_ANONYMOUS
#ifndef MAP_ANONYMOUS
# define MAP_ANONYMOUS  MAP_ANON
#endif

#ifndef MREMAP_MAYMOVE
# define MREMAP_MAYMOVE 1
#endif

// Mingw does not have S_ISLNK.
#ifndef S_ISLNK
# define S_ISLNK(mode) 0
#endif

namespace gold
{

// A wrapper around posix_fallocate.  If we don't have posix_fallocate,
// or the --no-posix-fallocate option is set, we try the fallocate
// system call directly.  If that fails, we use ftruncate to set
// the file size and hope that there is enough disk space.

static int
gold_fallocate(int o, off_t offset, off_t len)
{
#ifdef HAVE_POSIX_FALLOCATE
  if (parameters->options().posix_fallocate())
    return ::posix_fallocate(o, offset, len);
#endif // defined(HAVE_POSIX_FALLOCATE)
#ifdef HAVE_FALLOCATE
  if (::fallocate(o, 0, offset, len) == 0)
    return 0;
#endif // defined(HAVE_FALLOCATE)
  if (::ftruncate(o, offset + len) < 0)
    return errno;
  return 0;
}

// Output_data variables.

bool Output_data::allocated_sizes_are_fixed;

// Output_data methods.

Output_data::~Output_data()
{
}

// Return the default alignment for the target size.

uint64_t
Output_data::default_alignment()
{
  return Output_data::default_alignment_for_size(
      parameters->target().get_size());
}

// Return the default alignment for a size--32 or 64.

uint64_t
Output_data::default_alignment_for_size(int size)
{
  if (size == 32)
    return 4;
  else if (size == 64)
    return 8;
  else
    gold_unreachable();
}

// Output_section_header methods.  This currently assumes that the
// segment and section lists are complete at construction time.

Output_section_headers::Output_section_headers(
    const Layout* layout,
    const Layout::Segment_list* segment_list,
    const Layout::Section_list* section_list,
    const Layout::Section_list* unattached_section_list,
    const Stringpool* secnamepool,
    const Output_section* shstrtab_section)
  : layout_(layout),
    segment_list_(segment_list),
    section_list_(section_list),
    unattached_section_list_(unattached_section_list),
    secnamepool_(secnamepool),
    shstrtab_section_(shstrtab_section)
{
}

// Compute the current data size.

off_t
Output_section_headers::do_size() const
{
  // Count all the sections.  Start with 1 for the null section.
  off_t count = 1;
  if (!parameters->options().relocatable())
    {
      for (Layout::Segment_list::const_iterator p =
	     this->segment_list_->begin();
	   p != this->segment_list_->end();
	   ++p)
	if ((*p)->type() == elfcpp::PT_LOAD)
	  count += (*p)->output_section_count();
    }
  else
    {
      for (Layout::Section_list::const_iterator p =
	     this->section_list_->begin();
	   p != this->section_list_->end();
	   ++p)
	if (((*p)->flags() & elfcpp::SHF_ALLOC) != 0)
	  ++count;
    }
  count += this->unattached_section_list_->size();

  const int size = parameters->target().get_size();
  int shdr_size;
  if (size == 32)
    shdr_size = elfcpp::Elf_sizes<32>::shdr_size;
  else if (size == 64)
    shdr_size = elfcpp::Elf_sizes<64>::shdr_size;
  else
    gold_unreachable();

  return count * shdr_size;
}

// Write out the section headers.

void
Output_section_headers::do_write(Output_file* of)
{
  switch (parameters->size_and_endianness())
    {
#ifdef HAVE_TARGET_32_LITTLE
    case Parameters::TARGET_32_LITTLE:
      this->do_sized_write<32, false>(of);
      break;
#endif
#ifdef HAVE_TARGET_32_BIG
    case Parameters::TARGET_32_BIG:
      this->do_sized_write<32, true>(of);
      break;
#endif
#ifdef HAVE_TARGET_64_LITTLE
    case Parameters::TARGET_64_LITTLE:
      this->do_sized_write<64, false>(of);
      break;
#endif
#ifdef HAVE_TARGET_64_BIG
    case Parameters::TARGET_64_BIG:
      this->do_sized_write<64, true>(of);
      break;
#endif
    default:
      gold_unreachable();
    }
}

template<int size, bool big_endian>
void
Output_section_headers::do_sized_write(Output_file* of)
{
  off_t all_shdrs_size = this->data_size();
  unsigned char* view = of->get_output_view(this->offset(), all_shdrs_size);

  const int shdr_size = elfcpp::Elf_sizes<size>::shdr_size;
  unsigned char* v = view;

  {
    typename elfcpp::Shdr_write<size, big_endian> oshdr(v);
    oshdr.put_sh_name(0);
    oshdr.put_sh_type(elfcpp::SHT_NULL);
    oshdr.put_sh_flags(0);
    oshdr.put_sh_addr(0);
    oshdr.put_sh_offset(0);

    size_t section_count = (this->data_size()
			    / elfcpp::Elf_sizes<size>::shdr_size);
    if (section_count < elfcpp::SHN_LORESERVE)
      oshdr.put_sh_size(0);
    else
      oshdr.put_sh_size(section_count);

    unsigned int shstrndx = this->shstrtab_section_->out_shndx();
    if (shstrndx < elfcpp::SHN_LORESERVE)
      oshdr.put_sh_link(0);
    else
      oshdr.put_sh_link(shstrndx);

    size_t segment_count = this->segment_list_->size();
    oshdr.put_sh_info(segment_count >= elfcpp::PN_XNUM ? segment_count : 0);

    oshdr.put_sh_addralign(0);
    oshdr.put_sh_entsize(0);
  }

  v += shdr_size;

  unsigned int shndx = 1;
  if (!parameters->options().relocatable())
    {
      for (Layout::Segment_list::const_iterator p =
	     this->segment_list_->begin();
	   p != this->segment_list_->end();
	   ++p)
	v = (*p)->write_section_headers<size, big_endian>(this->layout_,
							  this->secnamepool_,
							  v,
							  &shndx);
    }
  else
    {
      for (Layout::Section_list::const_iterator p =
	     this->section_list_->begin();
	   p != this->section_list_->end();
	   ++p)
	{
	  // We do unallocated sections below, except that group
	  // sections have to come first.
	  if (((*p)->flags() & elfcpp::SHF_ALLOC) == 0
	      && (*p)->type() != elfcpp::SHT_GROUP)
	    continue;
	  gold_assert(shndx == (*p)->out_shndx());
	  elfcpp::Shdr_write<size, big_endian> oshdr(v);
	  (*p)->write_header(this->layout_, this->secnamepool_, &oshdr);
	  v += shdr_size;
	  ++shndx;
	}
    }

  for (Layout::Section_list::const_iterator p =
	 this->unattached_section_list_->begin();
       p != this->unattached_section_list_->end();
       ++p)
    {
      // For a relocatable link, we did unallocated group sections
      // above, since they have to come first.
      if ((*p)->type() == elfcpp::SHT_GROUP
	  && parameters->options().relocatable())
	continue;
      gold_assert(shndx == (*p)->out_shndx());
      elfcpp::Shdr_write<size, big_endian> oshdr(v);
      (*p)->write_header(this->layout_, this->secnamepool_, &oshdr);
      v += shdr_size;
      ++shndx;
    }

  of->write_output_view(this->offset(), all_shdrs_size, view);
}

// Output_segment_header methods.

Output_segment_headers::Output_segment_headers(
    const Layout::Segment_list& segment_list)
  : segment_list_(segment_list)
{
  this->set_current_data_size_for_child(this->do_size());
}

void
Output_segment_headers::do_write(Output_file* of)
{
  switch (parameters->size_and_endianness())
    {
#ifdef HAVE_TARGET_32_LITTLE
    case Parameters::TARGET_32_LITTLE:
      this->do_sized_write<32, false>(of);
      break;
#endif
#ifdef HAVE_TARGET_32_BIG
    case Parameters::TARGET_32_BIG:
      this->do_sized_write<32, true>(of);
      break;
#endif
#ifdef HAVE_TARGET_64_LITTLE
    case Parameters::TARGET_64_LITTLE:
      this->do_sized_write<64, false>(of);
      break;
#endif
#ifdef HAVE_TARGET_64_BIG
    case Parameters::TARGET_64_BIG:
      this->do_sized_write<64, true>(of);
      break;
#endif
    default:
      gold_unreachable();
    }
}

template<int size, bool big_endian>
void
Output_segment_headers::do_sized_write(Output_file* of)
{
  const int phdr_size = elfcpp::Elf_sizes<size>::phdr_size;
  off_t all_phdrs_size = this->segment_list_.size() * phdr_size;
  gold_assert(all_phdrs_size == this->data_size());
  unsigned char* view = of->get_output_view(this->offset(),
					    all_phdrs_size);
  unsigned char* v = view;
  for (Layout::Segment_list::const_iterator p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
    {
      elfcpp::Phdr_write<size, big_endian> ophdr(v);
      (*p)->write_header(&ophdr);
      v += phdr_size;
    }

  gold_assert(v - view == all_phdrs_size);

  of->write_output_view(this->offset(), all_phdrs_size, view);
}

off_t
Output_segment_headers::do_size() const
{
  const int size = parameters->target().get_size();
  int phdr_size;
  if (size == 32)
    phdr_size = elfcpp::Elf_sizes<32>::phdr_size;
  else if (size == 64)
    phdr_size = elfcpp::Elf_sizes<64>::phdr_size;
  else
    gold_unreachable();

  return this->segment_list_.size() * phdr_size;
}

// Output_file_header methods.

Output_file_header::Output_file_header(Target* target,
				       const Symbol_table* symtab,
				       const Output_segment_headers* osh)
  : target_(target),
    symtab_(symtab),
    segment_header_(osh),
    section_header_(NULL),
    shstrtab_(NULL)
{
  this->set_data_size(this->do_size());
}

// Set the section table information for a file header.

void
Output_file_header::set_section_info(const Output_section_headers* shdrs,
				     const Output_section* shstrtab)
{
  this->section_header_ = shdrs;
  this->shstrtab_ = shstrtab;
}

// Write out the file header.

void
Output_file_header::do_write(Output_file* of)
{
  gold_assert(this->offset() == 0);

  switch (parameters->size_and_endianness())
    {
#ifdef HAVE_TARGET_32_LITTLE
    case Parameters::TARGET_32_LITTLE:
      this->do_sized_write<32, false>(of);
      break;
#endif
#ifdef HAVE_TARGET_32_BIG
    case Parameters::TARGET_32_BIG:
      this->do_sized_write<32, true>(of);
      break;
#endif
#ifdef HAVE_TARGET_64_LITTLE
    case Parameters::TARGET_64_LITTLE:
      this->do_sized_write<64, false>(of);
      break;
#endif
#ifdef HAVE_TARGET_64_BIG
    case Parameters::TARGET_64_BIG:
      this->do_sized_write<64, true>(of);
      break;
#endif
    default:
      gold_unreachable();
    }
}

// Write out the file header with appropriate size and endianness.

template<int size, bool big_endian>
void
Output_file_header::do_sized_write(Output_file* of)
{
  gold_assert(this->offset() == 0);

  int ehdr_size = elfcpp::Elf_sizes<size>::ehdr_size;
  unsigned char* view = of->get_output_view(0, ehdr_size);
  elfcpp::Ehdr_write<size, big_endian> oehdr(view);

  unsigned char e_ident[elfcpp::EI_NIDENT];
  memset(e_ident, 0, elfcpp::EI_NIDENT);
  e_ident[elfcpp::EI_MAG0] = elfcpp::ELFMAG0;
  e_ident[elfcpp::EI_MAG1] = elfcpp::ELFMAG1;
  e_ident[elfcpp::EI_MAG2] = elfcpp::ELFMAG2;
  e_ident[elfcpp::EI_MAG3] = elfcpp::ELFMAG3;
  if (size == 32)
    e_ident[elfcpp::EI_CLASS] = elfcpp::ELFCLASS32;
  else if (size == 64)
    e_ident[elfcpp::EI_CLASS] = elfcpp::ELFCLASS64;
  else
    gold_unreachable();
  e_ident[elfcpp::EI_DATA] = (big_endian
			      ? elfcpp::ELFDATA2MSB
			      : elfcpp::ELFDATA2LSB);
  e_ident[elfcpp::EI_VERSION] = elfcpp::EV_CURRENT;
  oehdr.put_e_ident(e_ident);

  elfcpp::ET e_type;
  if (parameters->options().relocatable())
    e_type = elfcpp::ET_REL;
  else if (parameters->options().output_is_position_independent())
    e_type = elfcpp::ET_DYN;
  else
    e_type = elfcpp::ET_EXEC;
  oehdr.put_e_type(e_type);

  oehdr.put_e_machine(this->target_->machine_code());
  oehdr.put_e_version(elfcpp::EV_CURRENT);

  oehdr.put_e_entry(this->entry<size>());

  if (this->segment_header_ == NULL)
    oehdr.put_e_phoff(0);
  else
    oehdr.put_e_phoff(this->segment_header_->offset());

  oehdr.put_e_shoff(this->section_header_->offset());
  oehdr.put_e_flags(this->target_->processor_specific_flags());
  oehdr.put_e_ehsize(elfcpp::Elf_sizes<size>::ehdr_size);

  if (this->segment_header_ == NULL)
    {
      oehdr.put_e_phentsize(0);
      oehdr.put_e_phnum(0);
    }
  else
    {
      oehdr.put_e_phentsize(elfcpp::Elf_sizes<size>::phdr_size);
      size_t phnum = (this->segment_header_->data_size()
		      / elfcpp::Elf_sizes<size>::phdr_size);
      if (phnum > elfcpp::PN_XNUM)
	phnum = elfcpp::PN_XNUM;
      oehdr.put_e_phnum(phnum);
    }

  oehdr.put_e_shentsize(elfcpp::Elf_sizes<size>::shdr_size);
  size_t section_count = (this->section_header_->data_size()
			  / elfcpp::Elf_sizes<size>::shdr_size);

  if (section_count < elfcpp::SHN_LORESERVE)
    oehdr.put_e_shnum(this->section_header_->data_size()
		      / elfcpp::Elf_sizes<size>::shdr_size);
  else
    oehdr.put_e_shnum(0);

  unsigned int shstrndx = this->shstrtab_->out_shndx();
  if (shstrndx < elfcpp::SHN_LORESERVE)
    oehdr.put_e_shstrndx(this->shstrtab_->out_shndx());
  else
    oehdr.put_e_shstrndx(elfcpp::SHN_XINDEX);

  // Let the target adjust the ELF header, e.g., to set EI_OSABI in
  // the e_ident field.
  this->target_->adjust_elf_header(view, ehdr_size);

  of->write_output_view(0, ehdr_size, view);
}

// Return the value to use for the entry address.

template<int size>
typename elfcpp::Elf_types<size>::Elf_Addr
Output_file_header::entry()
{
  const bool should_issue_warning = (parameters->options().entry() != NULL
				     && !parameters->options().relocatable()
				     && !parameters->options().shared());
  const char* entry = parameters->entry();
  Symbol* sym = this->symtab_->lookup(entry);

  typename Sized_symbol<size>::Value_type v;
  if (sym != NULL)
    {
      Sized_symbol<size>* ssym;
      ssym = this->symtab_->get_sized_symbol<size>(sym);
      if (!ssym->is_defined() && should_issue_warning)
	gold_warning("entry symbol '%s' exists but is not defined", entry);
      v = ssym->value();
    }
  else
    {
      // We couldn't find the entry symbol.  See if we can parse it as
      // a number.  This supports, e.g., -e 0x1000.
      char* endptr;
      v = strtoull(entry, &endptr, 0);
      if (*endptr != '\0')
	{
	  if (should_issue_warning)
	    gold_warning("cannot find entry symbol '%s'", entry);
	  v = 0;
	}
    }

  return v;
}

// Compute the current data size.

off_t
Output_file_header::do_size() const
{
  const int size = parameters->target().get_size();
  if (size == 32)
    return elfcpp::Elf_sizes<32>::ehdr_size;
  else if (size == 64)
    return elfcpp::Elf_sizes<64>::ehdr_size;
  else
    gold_unreachable();
}

// Output_data_const methods.

void
Output_data_const::do_write(Output_file* of)
{
  of->write(this->offset(), this->data_.data(), this->data_.size());
}

// Output_data_const_buffer methods.

void
Output_data_const_buffer::do_write(Output_file* of)
{
  of->write(this->offset(), this->p_, this->data_size());
}

// Output_section_data methods.

// Record the output section, and set the entry size and such.

void
Output_section_data::set_output_section(Output_section* os)
{
  gold_assert(this->output_section_ == NULL);
  this->output_section_ = os;
  this->do_adjust_output_section(os);
}

// Return the section index of the output section.

unsigned int
Output_section_data::do_out_shndx() const
{
  gold_assert(this->output_section_ != NULL);
  return this->output_section_->out_shndx();
}

// Set the alignment, which means we may need to update the alignment
// of the output section.

void
Output_section_data::set_addralign(uint64_t addralign)
{
  this->addralign_ = addralign;
  if (this->output_section_ != NULL
      && this->output_section_->addralign() < addralign)
    this->output_section_->set_addralign(addralign);
}

// Output_data_strtab methods.

// Set the final data size.

void
Output_data_strtab::set_final_data_size()
{
  this->strtab_->set_string_offsets();
  this->set_data_size(this->strtab_->get_strtab_size());
}

// Write out a string table.

void
Output_data_strtab::do_write(Output_file* of)
{
  this->strtab_->write(of, this->offset());
}

// Output_reloc methods.

// A reloc against a global symbol.

template<bool dynamic, int size, bool big_endian>
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
    Symbol* gsym,
    unsigned int type,
    Output_data* od,
    Address address,
    bool is_relative,
    bool is_symbolless,
    bool use_plt_offset)
  : address_(address), local_sym_index_(GSYM_CODE), type_(type),
    is_relative_(is_relative), is_symbolless_(is_symbolless),
    is_section_symbol_(false), use_plt_offset_(use_plt_offset), shndx_(INVALID_CODE)
{
  // this->type_ is a bitfield; make sure TYPE fits.
  gold_assert(this->type_ == type);
  this->u1_.gsym = gsym;
  this->u2_.od = od;
  if (dynamic)
    this->set_needs_dynsym_index();
}

template<bool dynamic, int size, bool big_endian>
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
    Symbol* gsym,
    unsigned int type,
    Sized_relobj<size, big_endian>* relobj,
    unsigned int shndx,
    Address address,
    bool is_relative,
    bool is_symbolless,
    bool use_plt_offset)
  : address_(address), local_sym_index_(GSYM_CODE), type_(type),
    is_relative_(is_relative), is_symbolless_(is_symbolless),
    is_section_symbol_(false), use_plt_offset_(use_plt_offset), shndx_(shndx)
{
  gold_assert(shndx != INVALID_CODE);
  // this->type_ is a bitfield; make sure TYPE fits.
  gold_assert(this->type_ == type);
  this->u1_.gsym = gsym;
  this->u2_.relobj = relobj;
  if (dynamic)
    this->set_needs_dynsym_index();
}

// A reloc against a local symbol.

template<bool dynamic, int size, bool big_endian>
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
    Sized_relobj<size, big_endian>* relobj,
    unsigned int local_sym_index,
    unsigned int type,
    Output_data* od,
    Address address,
    bool is_relative,
    bool is_symbolless,
    bool is_section_symbol,
    bool use_plt_offset)
  : address_(address), local_sym_index_(local_sym_index), type_(type),
    is_relative_(is_relative), is_symbolless_(is_symbolless),
    is_section_symbol_(is_section_symbol), use_plt_offset_(use_plt_offset),
    shndx_(INVALID_CODE)
{
  gold_assert(local_sym_index != GSYM_CODE
	      && local_sym_index != INVALID_CODE);
  // this->type_ is a bitfield; make sure TYPE fits.
  gold_assert(this->type_ == type);
  this->u1_.relobj = relobj;
  this->u2_.od = od;
  if (dynamic)
    this->set_needs_dynsym_index();
}

template<bool dynamic, int size, bool big_endian>
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
    Sized_relobj<size, big_endian>* relobj,
    unsigned int local_sym_index,
    unsigned int type,
    unsigned int shndx,
    Address address,
    bool is_relative,
    bool is_symbolless,
    bool is_section_symbol,
    bool use_plt_offset)
  : address_(address), local_sym_index_(local_sym_index), type_(type),
    is_relative_(is_relative), is_symbolless_(is_symbolless),
    is_section_symbol_(is_section_symbol), use_plt_offset_(use_plt_offset),
    shndx_(shndx)
{
  gold_assert(local_sym_index != GSYM_CODE
	      && local_sym_index != INVALID_CODE);
  gold_assert(shndx != INVALID_CODE);
  // this->type_ is a bitfield; make sure TYPE fits.
  gold_assert(this->type_ == type);
  this->u1_.relobj = relobj;
  this->u2_.relobj = relobj;
  if (dynamic)
    this->set_needs_dynsym_index();
}

// A reloc against the STT_SECTION symbol of an output section.

template<bool dynamic, int size, bool big_endian>
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
    Output_section* os,
    unsigned int type,
    Output_data* od,
    Address address,
    bool is_relative)
  : address_(address), local_sym_index_(SECTION_CODE), type_(type),
    is_relative_(is_relative), is_symbolless_(is_relative),
    is_section_symbol_(true), use_plt_offset_(false), shndx_(INVALID_CODE)
{
  // this->type_ is a bitfield; make sure TYPE fits.
  gold_assert(this->type_ == type);
  this->u1_.os = os;
  this->u2_.od = od;
  if (dynamic)
    this->set_needs_dynsym_index();
  else
    os->set_needs_symtab_index();
}

template<bool dynamic, int size, bool big_endian>
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
    Output_section* os,
    unsigned int type,
    Sized_relobj<size, big_endian>* relobj,
    unsigned int shndx,
    Address address,
    bool is_relative)
  : address_(address), local_sym_index_(SECTION_CODE), type_(type),
    is_relative_(is_relative), is_symbolless_(is_relative),
    is_section_symbol_(true), use_plt_offset_(false), shndx_(shndx)
{
  gold_assert(shndx != INVALID_CODE);
  // this->type_ is a bitfield; make sure TYPE fits.
  gold_assert(this->type_ == type);
  this->u1_.os = os;
  this->u2_.relobj = relobj;
  if (dynamic)
    this->set_needs_dynsym_index();
  else
    os->set_needs_symtab_index();
}

// An absolute or relative relocation.

template<bool dynamic, int size, bool big_endian>
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
    unsigned int type,
    Output_data* od,
    Address address,
    bool is_relative)
  : address_(address), local_sym_index_(0), type_(type),
    is_relative_(is_relative), is_symbolless_(false),
    is_section_symbol_(false), use_plt_offset_(false), shndx_(INVALID_CODE)
{
  // this->type_ is a bitfield; make sure TYPE fits.
  gold_assert(this->type_ == type);
  this->u1_.relobj = NULL;
  this->u2_.od = od;
}

template<bool dynamic, int size, bool big_endian>
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
    unsigned int type,
    Sized_relobj<size, big_endian>* relobj,
    unsigned int shndx,
    Address address,
    bool is_relative)
  : address_(address), local_sym_index_(0), type_(type),
    is_relative_(is_relative), is_symbolless_(false),
    is_section_symbol_(false), use_plt_offset_(false), shndx_(shndx)
{
  gold_assert(shndx != INVALID_CODE);
  // this->type_ is a bitfield; make sure TYPE fits.
  gold_assert(this->type_ == type);
  this->u1_.relobj = NULL;
  this->u2_.relobj = relobj;
}

// A target specific relocation.

template<bool dynamic, int size, bool big_endian>
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
    unsigned int type,
    void* arg,
    Output_data* od,
    Address address)
  : address_(address), local_sym_index_(TARGET_CODE), type_(type),
    is_relative_(false), is_symbolless_(false),
    is_section_symbol_(false), use_plt_offset_(false), shndx_(INVALID_CODE)
{
  // this->type_ is a bitfield; make sure TYPE fits.
  gold_assert(this->type_ == type);
  this->u1_.arg = arg;
  this->u2_.od = od;
}

template<bool dynamic, int size, bool big_endian>
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
    unsigned int type,
    void* arg,
    Sized_relobj<size, big_endian>* relobj,
    unsigned int shndx,
    Address address)
  : address_(address), local_sym_index_(TARGET_CODE), type_(type),
    is_relative_(false), is_symbolless_(false),
    is_section_symbol_(false), use_plt_offset_(false), shndx_(shndx)
{
  gold_assert(shndx != INVALID_CODE);
  // this->type_ is a bitfield; make sure TYPE fits.
  gold_assert(this->type_ == type);
  this->u1_.arg = arg;
  this->u2_.relobj = relobj;
}

// Record that we need a dynamic symbol index for this relocation.

template<bool dynamic, int size, bool big_endian>
void
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::
set_needs_dynsym_index()
{
  if (this->is_symbolless_)
    return;
  switch (this->local_sym_index_)
    {
    case INVALID_CODE:
      gold_unreachable();

    case GSYM_CODE:
      this->u1_.gsym->set_needs_dynsym_entry();
      break;

    case SECTION_CODE:
      this->u1_.os->set_needs_dynsym_index();
      break;

    case TARGET_CODE:
      // The target must take care of this if necessary.
      break;

    case 0:
      break;

    default:
      {
	const unsigned int lsi = this->local_sym_index_;
	Sized_relobj_file<size, big_endian>* relobj =
	    this->u1_.relobj->sized_relobj();
	gold_assert(relobj != NULL);
	if (!this->is_section_symbol_)
	  relobj->set_needs_output_dynsym_entry(lsi);
	else
	  relobj->output_section(lsi)->set_needs_dynsym_index();
      }
      break;
    }
}

// Get the symbol index of a relocation.

template<bool dynamic, int size, bool big_endian>
unsigned int
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::get_symbol_index()
  const
{
  unsigned int index;
  if (this->is_symbolless_)
    return 0;
  switch (this->local_sym_index_)
    {
    case INVALID_CODE:
      gold_unreachable();

    case GSYM_CODE:
      if (this->u1_.gsym == NULL)
	index = 0;
      else if (dynamic)
	index = this->u1_.gsym->dynsym_index();
      else
	index = this->u1_.gsym->symtab_index();
      break;

    case SECTION_CODE:
      if (dynamic)
	index = this->u1_.os->dynsym_index();
      else
	index = this->u1_.os->symtab_index();
      break;

    case TARGET_CODE:
      index = parameters->target().reloc_symbol_index(this->u1_.arg,
						      this->type_);
      break;

    case 0:
      // Relocations without symbols use a symbol index of 0.
      index = 0;
      break;

    default:
      {
	const unsigned int lsi = this->local_sym_index_;
	Sized_relobj_file<size, big_endian>* relobj =
	    this->u1_.relobj->sized_relobj();
	gold_assert(relobj != NULL);
	if (!this->is_section_symbol_)
	  {
	    if (dynamic)
	      index = relobj->dynsym_index(lsi);
	    else
	      index = relobj->symtab_index(lsi);
	  }
	else
	  {
	    Output_section* os = relobj->output_section(lsi);
	    gold_assert(os != NULL);
	    if (dynamic)
	      index = os->dynsym_index();
	    else
	      index = os->symtab_index();
	  }
      }
      break;
    }
  gold_assert(index != -1U);
  return index;
}

// For a local section symbol, get the address of the offset ADDEND
// within the input section.

template<bool dynamic, int size, bool big_endian>
typename elfcpp::Elf_types<size>::Elf_Addr
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::
  local_section_offset(Addend addend) const
{
  gold_assert(this->local_sym_index_ != GSYM_CODE
	      && this->local_sym_index_ != SECTION_CODE
	      && this->local_sym_index_ != TARGET_CODE
	      && this->local_sym_index_ != INVALID_CODE
	      && this->local_sym_index_ != 0
	      && this->is_section_symbol_);
  const unsigned int lsi = this->local_sym_index_;
  Output_section* os = this->u1_.relobj->output_section(lsi);
  gold_assert(os != NULL);
  Address offset = this->u1_.relobj->get_output_section_offset(lsi);
  if (offset != invalid_address)
    return offset + addend;
  // This is a merge section.
  Sized_relobj_file<size, big_endian>* relobj =
      this->u1_.relobj->sized_relobj();
  gold_assert(relobj != NULL);
  offset = os->output_address(relobj, lsi, addend);
  gold_assert(offset != invalid_address);
  return offset;
}

// Get the output address of a relocation.

template<bool dynamic, int size, bool big_endian>
typename elfcpp::Elf_types<size>::Elf_Addr
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::get_address() const
{
  Address address = this->address_;
  if (this->shndx_ != INVALID_CODE)
    {
      Output_section* os = this->u2_.relobj->output_section(this->shndx_);
      gold_assert(os != NULL);
      Address off = this->u2_.relobj->get_output_section_offset(this->shndx_);
      if (off != invalid_address)
	address += os->address() + off;
      else
	{
	  Sized_relobj_file<size, big_endian>* relobj =
	      this->u2_.relobj->sized_relobj();
	  gold_assert(relobj != NULL);
	  address = os->output_address(relobj, this->shndx_, address);
	  gold_assert(address != invalid_address);
	}
    }
  else if (this->u2_.od != NULL)
    address += this->u2_.od->address();
  return address;
}

// Write out the offset and info fields of a Rel or Rela relocation
// entry.

template<bool dynamic, int size, bool big_endian>
template<typename Write_rel>
void
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::write_rel(
    Write_rel* wr) const
{
  wr->put_r_offset(this->get_address());
  unsigned int sym_index = this->get_symbol_index();
  wr->put_r_info(elfcpp::elf_r_info<size>(sym_index, this->type_));
}

// Write out a Rel relocation.

template<bool dynamic, int size, bool big_endian>
void
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::write(
    unsigned char* pov) const
{
  elfcpp::Rel_write<size, big_endian> orel(pov);
  this->write_rel(&orel);
}

// Get the value of the symbol referred to by a Rel relocation.

template<bool dynamic, int size, bool big_endian>
typename elfcpp::Elf_types<size>::Elf_Addr
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::symbol_value(
    Addend addend) const
{
  if (this->local_sym_index_ == GSYM_CODE)
    {
      const Sized_symbol<size>* sym;
      sym = static_cast<const Sized_symbol<size>*>(this->u1_.gsym);
      if (this->use_plt_offset_ && sym->has_plt_offset())
	return parameters->target().plt_address_for_global(sym);
      else
	return sym->value() + addend;
    }
  if (this->local_sym_index_ == SECTION_CODE)
    {
      gold_assert(!this->use_plt_offset_);
      return this->u1_.os->address() + addend;
    }
  gold_assert(this->local_sym_index_ != TARGET_CODE
	      && this->local_sym_index_ != INVALID_CODE
	      && this->local_sym_index_ != 0
	      && !this->is_section_symbol_);
  const unsigned int lsi = this->local_sym_index_;
  Sized_relobj_file<size, big_endian>* relobj =
      this->u1_.relobj->sized_relobj();
  gold_assert(relobj != NULL);
  if (this->use_plt_offset_)
    return parameters->target().plt_address_for_local(relobj, lsi);
  const Symbol_value<size>* symval = relobj->local_symbol(lsi);
  return symval->value(relobj, addend);
}

// Reloc comparison.  This function sorts the dynamic relocs for the
// benefit of the dynamic linker.  First we sort all relative relocs
// to the front.  Among relative relocs, we sort by output address.
// Among non-relative relocs, we sort by symbol index, then by output
// address.

template<bool dynamic, int size, bool big_endian>
int
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::
  compare(const Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>& r2)
    const
{
  if (this->is_relative_)
    {
      if (!r2.is_relative_)
	return -1;
      // Otherwise sort by reloc address below.
    }
  else if (r2.is_relative_)
    return 1;
  else
    {
      unsigned int sym1 = this->get_symbol_index();
      unsigned int sym2 = r2.get_symbol_index();
      if (sym1 < sym2)
	return -1;
      else if (sym1 > sym2)
	return 1;
      // Otherwise sort by reloc address.
    }

  section_offset_type addr1 = this->get_address();
  section_offset_type addr2 = r2.get_address();
  if (addr1 < addr2)
    return -1;
  else if (addr1 > addr2)
    return 1;

  // Final tie breaker, in order to generate the same output on any
  // host: reloc type.
  unsigned int type1 = this->type_;
  unsigned int type2 = r2.type_;
  if (type1 < type2)
    return -1;
  else if (type1 > type2)
    return 1;

  // These relocs appear to be exactly the same.
  return 0;
}

// Write out a Rela relocation.

template<bool dynamic, int size, bool big_endian>
void
Output_reloc<elfcpp::SHT_RELA, dynamic, size, big_endian>::write(
    unsigned char* pov) const
{
  elfcpp::Rela_write<size, big_endian> orel(pov);
  this->rel_.write_rel(&orel);
  Addend addend = this->addend_;
  if (this->rel_.is_target_specific())
    addend = parameters->target().reloc_addend(this->rel_.target_arg(),
					       this->rel_.type(), addend);
  else if (this->rel_.is_symbolless())
    addend = this->rel_.symbol_value(addend);
  else if (this->rel_.is_local_section_symbol())
    addend = this->rel_.local_section_offset(addend);
  orel.put_r_addend(addend);
}

// Output_data_reloc_base methods.

// Adjust the output section.

template<int sh_type, bool dynamic, int size, bool big_endian>
void
Output_data_reloc_base<sh_type, dynamic, size, big_endian>
    ::do_adjust_output_section(Output_section* os)
{
  if (sh_type == elfcpp::SHT_REL)
    os->set_entsize(elfcpp::Elf_sizes<size>::rel_size);
  else if (sh_type == elfcpp::SHT_RELA)
    os->set_entsize(elfcpp::Elf_sizes<size>::rela_size);
  else
    gold_unreachable();

  // A STT_GNU_IFUNC symbol may require a IRELATIVE reloc when doing a
  // static link.  The backends will generate a dynamic reloc section
  // to hold this.  In that case we don't want to link to the dynsym
  // section, because there isn't one.
  if (!dynamic)
    os->set_should_link_to_symtab();
  else if (parameters->doing_static_link())
    ;
  else
    os->set_should_link_to_dynsym();
}

// Write out relocation data.

template<int sh_type, bool dynamic, int size, bool big_endian>
void
Output_data_reloc_base<sh_type, dynamic, size, big_endian>::do_write(
    Output_file* of)
{
  const off_t off = this->offset();
  const off_t oview_size = this->data_size();
  unsigned char* const oview = of->get_output_view(off, oview_size);

  if (this->sort_relocs())
    {
      gold_assert(dynamic);
      std::sort(this->relocs_.begin(), this->relocs_.end(),
		Sort_relocs_comparison());
    }

  unsigned char* pov = oview;
  for (typename Relocs::const_iterator p = this->relocs_.begin();
       p != this->relocs_.end();
       ++p)
    {
      p->write(pov);
      pov += reloc_size;
    }

  gold_assert(pov - oview == oview_size);

  of->write_output_view(off, oview_size, oview);

  // We no longer need the relocation entries.
  this->relocs_.clear();
}

// Class Output_relocatable_relocs.

template<int sh_type, int size, bool big_endian>
void
Output_relocatable_relocs<sh_type, size, big_endian>::set_final_data_size()
{
  this->set_data_size(this->rr_->output_reloc_count()
		      * Reloc_types<sh_type, size, big_endian>::reloc_size);
}

// class Output_data_group.

template<int size, bool big_endian>
Output_data_group<size, big_endian>::Output_data_group(
    Sized_relobj_file<size, big_endian>* relobj,
    section_size_type entry_count,
    elfcpp::Elf_Word flags,
    std::vector<unsigned int>* input_shndxes)
  : Output_section_data(entry_count * 4, 4, false),
    relobj_(relobj),
    flags_(flags)
{
  this->input_shndxes_.swap(*input_shndxes);
}

// Write out the section group, which means translating the section
// indexes to apply to the output file.

template<int size, bool big_endian>
void
Output_data_group<size, big_endian>::do_write(Output_file* of)
{
  const off_t off = this->offset();
  const section_size_type oview_size =
    convert_to_section_size_type(this->data_size());
  unsigned char* const oview = of->get_output_view(off, oview_size);

  elfcpp::Elf_Word* contents = reinterpret_cast<elfcpp::Elf_Word*>(oview);
  elfcpp::Swap<32, big_endian>::writeval(contents, this->flags_);
  ++contents;

  for (std::vector<unsigned int>::const_iterator p =
	 this->input_shndxes_.begin();
       p != this->input_shndxes_.end();
       ++p, ++contents)
    {
      Output_section* os = this->relobj_->output_section(*p);

      unsigned int output_shndx;
      if (os != NULL)
	output_shndx = os->out_shndx();
      else
	{
	  this->relobj_->error(_("section group retained but "
				 "group element discarded"));
	  output_shndx = 0;
	}

      elfcpp::Swap<32, big_endian>::writeval(contents, output_shndx);
    }

  size_t wrote = reinterpret_cast<unsigned char*>(contents) - oview;
  gold_assert(wrote == oview_size);

  of->write_output_view(off, oview_size, oview);

  // We no longer need this information.
  this->input_shndxes_.clear();
}

// Output_data_got::Got_entry methods.

// Write out the entry.

template<int got_size, bool big_endian>
void
Output_data_got<got_size, big_endian>::Got_entry::write(
    unsigned int got_indx,
    unsigned char* pov) const
{
  Valtype val = 0;

  switch (this->local_sym_index_)
    {
    case GSYM_CODE:
      {
	// If the symbol is resolved locally, we need to write out the
	// link-time value, which will be relocated dynamically by a
	// RELATIVE relocation.
	Symbol* gsym = this->u_.gsym;
	if (this->use_plt_or_tls_offset_ && gsym->has_plt_offset())
	  val = parameters->target().plt_address_for_global(gsym);
	else
	  {
	    switch (parameters->size_and_endianness())
	      {
#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
	      case Parameters::TARGET_32_LITTLE:
	      case Parameters::TARGET_32_BIG:
		{
		  // This cast is ugly.  We don't want to put a
		  // virtual method in Symbol, because we want Symbol
		  // to be as small as possible.
		  Sized_symbol<32>::Value_type v;
		  v = static_cast<Sized_symbol<32>*>(gsym)->value();
		  val = convert_types<Valtype, Sized_symbol<32>::Value_type>(v);
		}
		break;
#endif
#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
	      case Parameters::TARGET_64_LITTLE:
	      case Parameters::TARGET_64_BIG:
		{
		  Sized_symbol<64>::Value_type v;
		  v = static_cast<Sized_symbol<64>*>(gsym)->value();
		  val = convert_types<Valtype, Sized_symbol<64>::Value_type>(v);
		}
		break;
#endif
	      default:
		gold_unreachable();
	      }
	    if (this->use_plt_or_tls_offset_
		&& gsym->type() == elfcpp::STT_TLS)
	      val += parameters->target().tls_offset_for_global(gsym,
								got_indx);
	  }
      }
      break;

    case CONSTANT_CODE:
      val = this->u_.constant;
      break;

    case RESERVED_CODE:
      // If we're doing an incremental update, don't touch this GOT entry.
      if (parameters->incremental_update())
	return;
      val = this->u_.constant;
      break;

    default:
      {
	const Relobj* object = this->u_.object;
	const unsigned int lsi = this->local_sym_index_;
	bool is_tls = object->local_is_tls(lsi);
	if (this->use_plt_or_tls_offset_ && !is_tls)
	  val = parameters->target().plt_address_for_local(object, lsi);
	else
	  {
	    uint64_t lval = object->local_symbol_value(lsi, 0);
	    val = convert_types<Valtype, uint64_t>(lval);
	    if (this->use_plt_or_tls_offset_ && is_tls)
	      val += parameters->target().tls_offset_for_local(object, lsi,
							       got_indx);
	  }
      }
      break;
    }

  elfcpp::Swap<got_size, big_endian>::writeval(pov, val);
}

// Output_data_got methods.

// Add an entry for a global symbol to the GOT.  This returns true if
// this is a new GOT entry, false if the symbol already had a GOT
// entry.

template<int got_size, bool big_endian>
bool
Output_data_got<got_size, big_endian>::add_global(
    Symbol* gsym,
    unsigned int got_type)
{
  if (gsym->has_got_offset(got_type))
    return false;

  unsigned int got_offset = this->add_got_entry(Got_entry(gsym, false));
  gsym->set_got_offset(got_type, got_offset);
  return true;
}

// Like add_global, but use the PLT offset.

template<int got_size, bool big_endian>
bool
Output_data_got<got_size, big_endian>::add_global_plt(Symbol* gsym,
						      unsigned int got_type)
{
  if (gsym->has_got_offset(got_type))
    return false;

  unsigned int got_offset = this->add_got_entry(Got_entry(gsym, true));
  gsym->set_got_offset(got_type, got_offset);
  return true;
}

// Add an entry for a global symbol to the GOT, and add a dynamic
// relocation of type R_TYPE for the GOT entry.

template<int got_size, bool big_endian>
void
Output_data_got<got_size, big_endian>::add_global_with_rel(
    Symbol* gsym,
    unsigned int got_type,
    Output_data_reloc_generic* rel_dyn,
    unsigned int r_type)
{
  if (gsym->has_got_offset(got_type))
    return;

  unsigned int got_offset = this->add_got_entry(Got_entry());
  gsym->set_got_offset(got_type, got_offset);
  rel_dyn->add_global_generic(gsym, r_type, this, got_offset, 0);
}

// Add a pair of entries for a global symbol to the GOT, and add
// dynamic relocations of type R_TYPE_1 and R_TYPE_2, respectively.
// If R_TYPE_2 == 0, add the second entry with no relocation.
template<int got_size, bool big_endian>
void
Output_data_got<got_size, big_endian>::add_global_pair_with_rel(
    Symbol* gsym,
    unsigned int got_type,
    Output_data_reloc_generic* rel_dyn,
    unsigned int r_type_1,
    unsigned int r_type_2)
{
  if (gsym->has_got_offset(got_type))
    return;

  unsigned int got_offset = this->add_got_entry_pair(Got_entry(), Got_entry());
  gsym->set_got_offset(got_type, got_offset);
  rel_dyn->add_global_generic(gsym, r_type_1, this, got_offset, 0);

  if (r_type_2 != 0)
    rel_dyn->add_global_generic(gsym, r_type_2, this,
				got_offset + got_size / 8, 0);
}

// Add an entry for a local symbol to the GOT.  This returns true if
// this is a new GOT entry, false if the symbol already has a GOT
// entry.

template<int got_size, bool big_endian>
bool
Output_data_got<got_size, big_endian>::add_local(
    Relobj* object,
    unsigned int symndx,
    unsigned int got_type)
{
  if (object->local_has_got_offset(symndx, got_type))
    return false;

  unsigned int got_offset = this->add_got_entry(Got_entry(object, symndx,
							  false));
  object->set_local_got_offset(symndx, got_type, got_offset);
  return true;
}

// Like add_local, but use the PLT offset.

template<int got_size, bool big_endian>
bool
Output_data_got<got_size, big_endian>::add_local_plt(
    Relobj* object,
    unsigned int symndx,
    unsigned int got_type)
{
  if (object->local_has_got_offset(symndx, got_type))
    return false;

  unsigned int got_offset = this->add_got_entry(Got_entry(object, symndx,
							  true));
  object->set_local_got_offset(symndx, got_type, got_offset);
  return true;
}

// Add an entry for a local symbol to the GOT, and add a dynamic
// relocation of type R_TYPE for the GOT entry.

template<int got_size, bool big_endian>
void
Output_data_got<got_size, big_endian>::add_local_with_rel(
    Relobj* object,
    unsigned int symndx,
    unsigned int got_type,
    Output_data_reloc_generic* rel_dyn,
    unsigned int r_type)
{
  if (object->local_has_got_offset(symndx, got_type))
    return;

  unsigned int got_offset = this->add_got_entry(Got_entry());
  object->set_local_got_offset(symndx, got_type, got_offset);
  rel_dyn->add_local_generic(object, symndx, r_type, this, got_offset, 0);
}

// Add a pair of entries for a local symbol to the GOT, and add
// a dynamic relocation of type R_TYPE using the section symbol of
// the output section to which input section SHNDX maps, on the first.
// The first got entry will have a value of zero, the second the
// value of the local symbol.
template<int got_size, bool big_endian>
void
Output_data_got<got_size, big_endian>::add_local_pair_with_rel(
    Relobj* object,
    unsigned int symndx,
    unsigned int shndx,
    unsigned int got_type,
    Output_data_reloc_generic* rel_dyn,
    unsigned int r_type)
{
  if (object->local_has_got_offset(symndx, got_type))
    return;

  unsigned int got_offset =
      this->add_got_entry_pair(Got_entry(),
			       Got_entry(object, symndx, false));
  object->set_local_got_offset(symndx, got_type, got_offset);
  Output_section* os = object->output_section(shndx);
  rel_dyn->add_output_section_generic(os, r_type, this, got_offset, 0);
}

// Add a pair of entries for a local symbol to the GOT, and add
// a dynamic relocation of type R_TYPE using STN_UNDEF on the first.
// The first got entry will have a value of zero, the second the
// value of the local symbol offset by Target::tls_offset_for_local.
template<int got_size, bool big_endian>
void
Output_data_got<got_size, big_endian>::add_local_tls_pair(
    Relobj* object,
    unsigned int symndx,
    unsigned int got_type,
    Output_data_reloc_generic* rel_dyn,
    unsigned int r_type)
{
  if (object->local_has_got_offset(symndx, got_type))
    return;

  unsigned int got_offset
    = this->add_got_entry_pair(Got_entry(),
			       Got_entry(object, symndx, true));
  object->set_local_got_offset(symndx, got_type, got_offset);
  rel_dyn->add_local_generic(object, 0, r_type, this, got_offset, 0);
}

// Reserve a slot in the GOT for a local symbol or the second slot of a pair.

template<int got_size, bool big_endian>
void
Output_data_got<got_size, big_endian>::reserve_local(
    unsigned int i,
    Relobj* object,
    unsigned int sym_index,
    unsigned int got_type)
{
  this->do_reserve_slot(i);
  object->set_local_got_offset(sym_index, got_type, this->got_offset(i));
}

// Reserve a slot in the GOT for a global symbol.

template<int got_size, bool big_endian>
void
Output_data_got<got_size, big_endian>::reserve_global(
    unsigned int i,
    Symbol* gsym,
    unsigned int got_type)
{
  this->do_reserve_slot(i);
  gsym->set_got_offset(got_type, this->got_offset(i));
}

// Write out the GOT.

template<int got_size, bool big_endian>
void
Output_data_got<got_size, big_endian>::do_write(Output_file* of)
{
  const int add = got_size / 8;

  const off_t off = this->offset();
  const off_t oview_size = this->data_size();
  unsigned char* const oview = of->get_output_view(off, oview_size);

  unsigned char* pov = oview;
  for (unsigned int i = 0; i < this->entries_.size(); ++i)
    {
      this->entries_[i].write(i, pov);
      pov += add;
    }

  gold_assert(pov - oview == oview_size);

  of->write_output_view(off, oview_size, oview);

  // We no longer need the GOT entries.
  this->entries_.clear();
}

// Create a new GOT entry and return its offset.

template<int got_size, bool big_endian>
unsigned int
Output_data_got<got_size, big_endian>::add_got_entry(Got_entry got_entry)
{
  if (!this->is_data_size_valid())
    {
      this->entries_.push_back(got_entry);
      this->set_got_size();
      return this->last_got_offset();
    }
  else
    {
      // For an incremental update, find an available slot.
      off_t got_offset = this->free_list_.allocate(got_size / 8,
						   got_size / 8, 0);
      if (got_offset == -1)
	gold_fallback(_("out of patch space (GOT);"
			" relink with --incremental-full"));
      unsigned int got_index = got_offset / (got_size / 8);
      gold_assert(got_index < this->entries_.size());
      this->entries_[got_index] = got_entry;
      return static_cast<unsigned int>(got_offset);
    }
}

// Create a pair of new GOT entries and return the offset of the first.

template<int got_size, bool big_endian>
unsigned int
Output_data_got<got_size, big_endian>::add_got_entry_pair(
    Got_entry got_entry_1,
    Got_entry got_entry_2)
{
  if (!this->is_data_size_valid())
    {
      unsigned int got_offset;
      this->entries_.push_back(got_entry_1);
      got_offset = this->last_got_offset();
      this->entries_.push_back(got_entry_2);
      this->set_got_size();
      return got_offset;
    }
  else
    {
      // For an incremental update, find an available pair of slots.
      off_t got_offset = this->free_list_.allocate(2 * got_size / 8,
						   got_size / 8, 0);
      if (got_offset == -1)
	gold_fallback(_("out of patch space (GOT);"
			" relink with --incremental-full"));
      unsigned int got_index = got_offset / (got_size / 8);
      gold_assert(got_index < this->entries_.size());
      this->entries_[got_index] = got_entry_1;
      this->entries_[got_index + 1] = got_entry_2;
      return static_cast<unsigned int>(got_offset);
    }
}

// Replace GOT entry I with a new value.

template<int got_size, bool big_endian>
void
Output_data_got<got_size, big_endian>::replace_got_entry(
    unsigned int i,
    Got_entry got_entry)
{
  gold_assert(i < this->entries_.size());
  this->entries_[i] = got_entry;
}

// Output_data_dynamic::Dynamic_entry methods.

// Write out the entry.

template<int size, bool big_endian>
void
Output_data_dynamic::Dynamic_entry::write(
    unsigned char* pov,
    const Stringpool* pool) const
{
  typename elfcpp::Elf_types<size>::Elf_WXword val;
  switch (this->offset_)
    {
    case DYNAMIC_NUMBER:
      val = this->u_.val;
      break;

    case DYNAMIC_SECTION_SIZE:
      val = this->u_.od->data_size();
      if (this->od2 != NULL)
	val += this->od2->data_size();
      break;

    case DYNAMIC_SYMBOL:
      {
	const Sized_symbol<size>* s =
	  static_cast<const Sized_symbol<size>*>(this->u_.sym);
	val = s->value();
      }
      break;

    case DYNAMIC_STRING:
      val = pool->get_offset(this->u_.str);
      break;

    default:
      val = this->u_.od->address() + this->offset_;
      break;
    }

  elfcpp::Dyn_write<size, big_endian> dw(pov);
  dw.put_d_tag(this->tag_);
  dw.put_d_val(val);
}

// Output_data_dynamic methods.

// Adjust the output section to set the entry size.

void
Output_data_dynamic::do_adjust_output_section(Output_section* os)
{
  if (parameters->target().get_size() == 32)
    os->set_entsize(elfcpp::Elf_sizes<32>::dyn_size);
  else if (parameters->target().get_size() == 64)
    os->set_entsize(elfcpp::Elf_sizes<64>::dyn_size);
  else
    gold_unreachable();
}

// Set the final data size.

void
Output_data_dynamic::set_final_data_size()
{
  // Add the terminating entry if it hasn't been added.
  // Because of relaxation, we can run this multiple times.
  if (this->entries_.empty() || this->entries_.back().tag() != elfcpp::DT_NULL)
    {
      int extra = parameters->options().spare_dynamic_tags();
      for (int i = 0; i < extra; ++i)
	this->add_constant(elfcpp::DT_NULL, 0);
      this->add_constant(elfcpp::DT_NULL, 0);
    }

  int dyn_size;
  if (parameters->target().get_size() == 32)
    dyn_size = elfcpp::Elf_sizes<32>::dyn_size;
  else if (parameters->target().get_size() == 64)
    dyn_size = elfcpp::Elf_sizes<64>::dyn_size;
  else
    gold_unreachable();
  this->set_data_size(this->entries_.size() * dyn_size);
}

// Write out the dynamic entries.

void
Output_data_dynamic::do_write(Output_file* of)
{
  switch (parameters->size_and_endianness())
    {
#ifdef HAVE_TARGET_32_LITTLE
    case Parameters::TARGET_32_LITTLE:
      this->sized_write<32, false>(of);
      break;
#endif
#ifdef HAVE_TARGET_32_BIG
    case Parameters::TARGET_32_BIG:
      this->sized_write<32, true>(of);
      break;
#endif
#ifdef HAVE_TARGET_64_LITTLE
    case Parameters::TARGET_64_LITTLE:
      this->sized_write<64, false>(of);
      break;
#endif
#ifdef HAVE_TARGET_64_BIG
    case Parameters::TARGET_64_BIG:
      this->sized_write<64, true>(of);
      break;
#endif
    default:
      gold_unreachable();
    }
}

template<int size, bool big_endian>
void
Output_data_dynamic::sized_write(Output_file* of)
{
  const int dyn_size = elfcpp::Elf_sizes<size>::dyn_size;

  const off_t offset = this->offset();
  const off_t oview_size = this->data_size();
  unsigned char* const oview = of->get_output_view(offset, oview_size);

  unsigned char* pov = oview;
  for (typename Dynamic_entries::const_iterator p = this->entries_.begin();
       p != this->entries_.end();
       ++p)
    {
      p->write<size, big_endian>(pov, this->pool_);
      pov += dyn_size;
    }

  gold_assert(pov - oview == oview_size);

  of->write_output_view(offset, oview_size, oview);

  // We no longer need the dynamic entries.
  this->entries_.clear();
}

// Class Output_symtab_xindex.

void
Output_symtab_xindex::do_write(Output_file* of)
{
  const off_t offset = this->offset();
  const off_t oview_size = this->data_size();
  unsigned char* const oview = of->get_output_view(offset, oview_size);

  memset(oview, 0, oview_size);

  if (parameters->target().is_big_endian())
    this->endian_do_write<true>(oview);
  else
    this->endian_do_write<false>(oview);

  of->write_output_view(offset, oview_size, oview);

  // We no longer need the data.
  this->entries_.clear();
}

template<bool big_endian>
void
Output_symtab_xindex::endian_do_write(unsigned char* const oview)
{
  for (Xindex_entries::const_iterator p = this->entries_.begin();
       p != this->entries_.end();
       ++p)
    {
      unsigned int symndx = p->first;
      gold_assert(static_cast<off_t>(symndx) * 4 < this->data_size());
      elfcpp::Swap<32, big_endian>::writeval(oview + symndx * 4, p->second);
    }
}

// Output_fill_debug_info methods.

// Return the minimum size needed for a dummy compilation unit header.

size_t
Output_fill_debug_info::do_minimum_hole_size() const
{
  // Compile unit header fields: unit_length, version, debug_abbrev_offset,
  // address_size.
  const size_t len = 4 + 2 + 4 + 1;
  // For type units, add type_signature, type_offset.
  if (this->is_debug_types_)
    return len + 8 + 4;
  return len;
}

// Write a dummy compilation unit header to fill a hole in the
// .debug_info or .debug_types section.

void
Output_fill_debug_info::do_write(Output_file* of, off_t off, size_t len) const
{
  gold_debug(DEBUG_INCREMENTAL, "fill_debug_info(%08lx, %08lx)",
	     static_cast<long>(off), static_cast<long>(len));

  gold_assert(len >= this->do_minimum_hole_size());

  unsigned char* const oview = of->get_output_view(off, len);
  unsigned char* pov = oview;

  // Write header fields: unit_length, version, debug_abbrev_offset,
  // address_size.
  if (this->is_big_endian())
    {
      elfcpp::Swap_unaligned<32, true>::writeval(pov, len - 4);
      elfcpp::Swap_unaligned<16, true>::writeval(pov + 4, this->version);
      elfcpp::Swap_unaligned<32, true>::writeval(pov + 6, 0);
    }
  else
    {
      elfcpp::Swap_unaligned<32, false>::writeval(pov, len - 4);
      elfcpp::Swap_unaligned<16, false>::writeval(pov + 4, this->version);
      elfcpp::Swap_unaligned<32, false>::writeval(pov + 6, 0);
    }
  pov += 4 + 2 + 4;
  *pov++ = 4;

  // For type units, the additional header fields -- type_signature,
  // type_offset -- can be filled with zeroes.

  // Fill the remainder of the free space with zeroes.  The first
  // zero should tell the consumer there are no DIEs to read in this
  // compilation unit.
  if (pov < oview + len)
    memset(pov, 0, oview + len - pov);

  of->write_output_view(off, len, oview);
}

// Output_fill_debug_line methods.

// Return the minimum size needed for a dummy line number program header.

size_t
Output_fill_debug_line::do_minimum_hole_size() const
{
  // Line number program header fields: unit_length, version, header_length,
  // minimum_instruction_length, default_is_stmt, line_base, line_range,
  // opcode_base, standard_opcode_lengths[], include_directories, filenames.
  const size_t len = 4 + 2 + 4 + this->header_length;
  return len;
}

// Write a dummy line number program header to fill a hole in the
// .debug_line section.

void
Output_fill_debug_line::do_write(Output_file* of, off_t off, size_t len) const
{
  gold_debug(DEBUG_INCREMENTAL, "fill_debug_line(%08lx, %08lx)",
	     static_cast<long>(off), static_cast<long>(len));

  gold_assert(len >= this->do_minimum_hole_size());

  unsigned char* const oview = of->get_output_view(off, len);
  unsigned char* pov = oview;

  // Write header fields: unit_length, version, header_length,
  // minimum_instruction_length, default_is_stmt, line_base, line_range,
  // opcode_base, standard_opcode_lengths[], include_directories, filenames.
  // We set the header_length field to cover the entire hole, so the
  // line number program is empty.
  if (this->is_big_endian())
    {
      elfcpp::Swap_unaligned<32, true>::writeval(pov, len - 4);
      elfcpp::Swap_unaligned<16, true>::writeval(pov + 4, this->version);
      elfcpp::Swap_unaligned<32, true>::writeval(pov + 6, len - (4 + 2 + 4));
    }
  else
    {
      elfcpp::Swap_unaligned<32, false>::writeval(pov, len - 4);
      elfcpp::Swap_unaligned<16, false>::writeval(pov + 4, this->version);
      elfcpp::Swap_unaligned<32, false>::writeval(pov + 6, len - (4 + 2 + 4));
    }
  pov += 4 + 2 + 4;
  *pov++ = 1;	// minimum_instruction_length
  *pov++ = 0;	// default_is_stmt
  *pov++ = 0;	// line_base
  *pov++ = 5;	// line_range
  *pov++ = 13;	// opcode_base
  *pov++ = 0;	// standard_opcode_lengths[1]
  *pov++ = 1;	// standard_opcode_lengths[2]
  *pov++ = 1;	// standard_opcode_lengths[3]
  *pov++ = 1;	// standard_opcode_lengths[4]
  *pov++ = 1;	// standard_opcode_lengths[5]
  *pov++ = 0;	// standard_opcode_lengths[6]
  *pov++ = 0;	// standard_opcode_lengths[7]
  *pov++ = 0;	// standard_opcode_lengths[8]
  *pov++ = 1;	// standard_opcode_lengths[9]
  *pov++ = 0;	// standard_opcode_lengths[10]
  *pov++ = 0;	// standard_opcode_lengths[11]
  *pov++ = 1;	// standard_opcode_lengths[12]
  *pov++ = 0;	// include_directories (empty)
  *pov++ = 0;	// filenames (empty)

  // Some consumers don't check the header_length field, and simply
  // start reading the line number program immediately following the
  // header.  For those consumers, we fill the remainder of the free
  // space with DW_LNS_set_basic_block opcodes.  These are effectively
  // no-ops: the resulting line table program will not create any rows.
  if (pov < oview + len)
    memset(pov, elfcpp::DW_LNS_set_basic_block, oview + len - pov);

  of->write_output_view(off, len, oview);
}

// Output_section::Input_section methods.

// Return the current data size.  For an input section we store the size here.
// For an Output_section_data, we have to ask it for the size.

off_t
Output_section::Input_section::current_data_size() const
{
  if (this->is_input_section())
    return this->u1_.data_size;
  else
    {
      this->u2_.posd->pre_finalize_data_size();
      return this->u2_.posd->current_data_size();
    }
}

// Return the data size.  For an input section we store the size here.
// For an Output_section_data, we have to ask it for the size.

off_t
Output_section::Input_section::data_size() const
{
  if (this->is_input_section())
    return this->u1_.data_size;
  else
    return this->u2_.posd->data_size();
}

// Return the object for an input section.

Relobj*
Output_section::Input_section::relobj() const
{
  if (this->is_input_section())
    return this->u2_.object;
  else if (this->is_merge_section())
    {
      gold_assert(this->u2_.pomb->first_relobj() != NULL);
      return this->u2_.pomb->first_relobj();
    }
  else if (this->is_relaxed_input_section())
    return this->u2_.poris->relobj();
  else
    gold_unreachable();
}

// Return the input section index for an input section.

unsigned int
Output_section::Input_section::shndx() const
{
  if (this->is_input_section())
    return this->shndx_;
  else if (this->is_merge_section())
    {
      gold_assert(this->u2_.pomb->first_relobj() != NULL);
      return this->u2_.pomb->first_shndx();
    }
  else if (this->is_relaxed_input_section())
    return this->u2_.poris->shndx();
  else
    gold_unreachable();
}

// Set the address and file offset.

void
Output_section::Input_section::set_address_and_file_offset(
    uint64_t address,
    off_t file_offset,
    off_t section_file_offset)
{
  if (this->is_input_section())
    this->u2_.object->set_section_offset(this->shndx_,
					 file_offset - section_file_offset);
  else
    this->u2_.posd->set_address_and_file_offset(address, file_offset);
}

// Reset the address and file offset.

void
Output_section::Input_section::reset_address_and_file_offset()
{
  if (!this->is_input_section())
    this->u2_.posd->reset_address_and_file_offset();
}

// Finalize the data size.

void
Output_section::Input_section::finalize_data_size()
{
  if (!this->is_input_section())
    this->u2_.posd->finalize_data_size();
}

// Try to turn an input offset into an output offset.  We want to
// return the output offset relative to the start of this
// Input_section in the output section.

inline bool
Output_section::Input_section::output_offset(
    const Relobj* object,
    unsigned int shndx,
    section_offset_type offset,
    section_offset_type* poutput) const
{
  if (!this->is_input_section())
    return this->u2_.posd->output_offset(object, shndx, offset, poutput);
  else
    {
      if (this->shndx_ != shndx || this->u2_.object != object)
	return false;
      *poutput = offset;
      return true;
    }
}

// Return whether this is the merge section for the input section
// SHNDX in OBJECT.

inline bool
Output_section::Input_section::is_merge_section_for(const Relobj* object,
						    unsigned int shndx) const
{
  if (this->is_input_section())
    return false;
  return this->u2_.posd->is_merge_section_for(object, shndx);
}

// Write out the data.  We don't have to do anything for an input
// section--they are handled via Object::relocate--but this is where
// we write out the data for an Output_section_data.

void
Output_section::Input_section::write(Output_file* of)
{
  if (!this->is_input_section())
    this->u2_.posd->write(of);
}

// Write the data to a buffer.  As for write(), we don't have to do
// anything for an input section.

void
Output_section::Input_section::write_to_buffer(unsigned char* buffer)
{
  if (!this->is_input_section())
    this->u2_.posd->write_to_buffer(buffer);
}

// Print to a map file.

void
Output_section::Input_section::print_to_mapfile(Mapfile* mapfile) const
{
  switch (this->shndx_)
    {
    case OUTPUT_SECTION_CODE:
    case MERGE_DATA_SECTION_CODE:
    case MERGE_STRING_SECTION_CODE:
      this->u2_.posd->print_to_mapfile(mapfile);
      break;

    case RELAXED_INPUT_SECTION_CODE:
      {
	Output_relaxed_input_section* relaxed_section =
	  this->relaxed_input_section();
	mapfile->print_input_section(relaxed_section->relobj(),
				     relaxed_section->shndx());
      }
      break;
    default:
      mapfile->print_input_section(this->u2_.object, this->shndx_);
      break;
    }
}

// Output_section methods.

// Construct an Output_section.  NAME will point into a Stringpool.

Output_section::Output_section(const char* name, elfcpp::Elf_Word type,
			       elfcpp::Elf_Xword flags)
  : name_(name),
    addralign_(0),
    entsize_(0),
    load_address_(0),
    link_section_(NULL),
    link_(0),
    info_section_(NULL),
    info_symndx_(NULL),
    info_(0),
    type_(type),
    flags_(flags),
    order_(ORDER_INVALID),
    out_shndx_(-1U),
    symtab_index_(0),
    dynsym_index_(0),
    input_sections_(),
    first_input_offset_(0),
    fills_(),
    postprocessing_buffer_(NULL),
    needs_symtab_index_(false),
    needs_dynsym_index_(false),
    should_link_to_symtab_(false),
    should_link_to_dynsym_(false),
    after_input_sections_(false),
    requires_postprocessing_(false),
    found_in_sections_clause_(false),
    has_load_address_(false),
    info_uses_section_index_(false),
    input_section_order_specified_(false),
    may_sort_attached_input_sections_(false),
    must_sort_attached_input_sections_(false),
    attached_input_sections_are_sorted_(false),
    is_relro_(false),
    is_small_section_(false),
    is_large_section_(false),
    generate_code_fills_at_write_(false),
    is_entsize_zero_(false),
    section_offsets_need_adjustment_(false),
    is_noload_(false),
    always_keeps_input_sections_(false),
    has_fixed_layout_(false),
    is_patch_space_allowed_(false),
    is_unique_segment_(false),
    tls_offset_(0),
    extra_segment_flags_(0),
    segment_alignment_(0),
    checkpoint_(NULL),
    lookup_maps_(new Output_section_lookup_maps),
    free_list_(),
    free_space_fill_(NULL),
    patch_space_(0)
{
  // An unallocated section has no address.  Forcing this means that
  // we don't need special treatment for symbols defined in debug
  // sections.
  if ((flags & elfcpp::SHF_ALLOC) == 0)
    this->set_address(0);
}

Output_section::~Output_section()
{
  delete this->checkpoint_;
}

// Set the entry size.

void
Output_section::set_entsize(uint64_t v)
{
  if (this->is_entsize_zero_)
    ;
  else if (this->entsize_ == 0)
    this->entsize_ = v;
  else if (this->entsize_ != v)
    {
      this->entsize_ = 0;
      this->is_entsize_zero_ = 1;
    }
}

// Add the input section SHNDX, with header SHDR, named SECNAME, in
// OBJECT, to the Output_section.  RELOC_SHNDX is the index of a
// relocation section which applies to this section, or 0 if none, or
// -1U if more than one.  Return the offset of the input section
// within the output section.  Return -1 if the input section will
// receive special handling.  In the normal case we don't always keep
// track of input sections for an Output_section.  Instead, each
// Object keeps track of the Output_section for each of its input
// sections.  However, if HAVE_SECTIONS_SCRIPT is true, we do keep
// track of input sections here; this is used when SECTIONS appears in
// a linker script.

template<int size, bool big_endian>
off_t
Output_section::add_input_section(Layout* layout,
				  Sized_relobj_file<size, big_endian>* object,
				  unsigned int shndx,
				  const char* secname,
				  const elfcpp::Shdr<size, big_endian>& shdr,
				  unsigned int reloc_shndx,
				  bool have_sections_script)
{
  elfcpp::Elf_Xword addralign = shdr.get_sh_addralign();
  if ((addralign & (addralign - 1)) != 0)
    {
      object->error(_("invalid alignment %lu for section \"%s\""),
		    static_cast<unsigned long>(addralign), secname);
      addralign = 1;
    }

  if (addralign > this->addralign_)
    this->addralign_ = addralign;

  typename elfcpp::Elf_types<size>::Elf_WXword sh_flags = shdr.get_sh_flags();
  uint64_t entsize = shdr.get_sh_entsize();

  // .debug_str is a mergeable string section, but is not always so
  // marked by compilers.  Mark manually here so we can optimize.
  if (strcmp(secname, ".debug_str") == 0)
    {
      sh_flags |= (elfcpp::SHF_MERGE | elfcpp::SHF_STRINGS);
      entsize = 1;
    }

  this->update_flags_for_input_section(sh_flags);
  this->set_entsize(entsize);

  // If this is a SHF_MERGE section, we pass all the input sections to
  // a Output_data_merge.  We don't try to handle relocations for such
  // a section.  We don't try to handle empty merge sections--they
  // mess up the mappings, and are useless anyhow.
  // FIXME: Need to handle merge sections during incremental update.
  if ((sh_flags & elfcpp::SHF_MERGE) != 0
      && reloc_shndx == 0
      && shdr.get_sh_size() > 0
      && !parameters->incremental())
    {
      // Keep information about merged input sections for rebuilding fast
      // lookup maps if we have sections-script or we do relaxation.
      bool keeps_input_sections = (this->always_keeps_input_sections_
				   || have_sections_script
				   || parameters->target().may_relax());

      if (this->add_merge_input_section(object, shndx, sh_flags, entsize,
					addralign, keeps_input_sections))
	{
	  // Tell the relocation routines that they need to call the
	  // output_offset method to determine the final address.
	  return -1;
	}
    }

  section_size_type input_section_size = shdr.get_sh_size();
  section_size_type uncompressed_size;
  if (object->section_is_compressed(shndx, &uncompressed_size))
    input_section_size = uncompressed_size;

  off_t offset_in_section;

  if (this->has_fixed_layout())
    {
      // For incremental updates, find a chunk of unused space in the section.
      offset_in_section = this->free_list_.allocate(input_section_size,
						    addralign, 0);
      if (offset_in_section == -1)
	gold_fallback(_("out of patch space in section %s; "
			"relink with --incremental-full"),
		      this->name());
      return offset_in_section;
    }

  offset_in_section = this->current_data_size_for_child();
  off_t aligned_offset_in_section = align_address(offset_in_section,
						  addralign);
  this->set_current_data_size_for_child(aligned_offset_in_section
					+ input_section_size);

  // Determine if we want to delay code-fill generation until the output
  // section is written.  When the target is relaxing, we want to delay fill
  // generating to avoid adjusting them during relaxation.  Also, if we are
  // sorting input sections we must delay fill generation.
  if (!this->generate_code_fills_at_write_
      && !have_sections_script
      && (sh_flags & elfcpp::SHF_EXECINSTR) != 0
      && parameters->target().has_code_fill()
      && (parameters->target().may_relax()
	  || layout->is_section_ordering_specified()))
    {
      gold_assert(this->fills_.empty());
      this->generate_code_fills_at_write_ = true;
    }

  if (aligned_offset_in_section > offset_in_section
      && !this->generate_code_fills_at_write_
      && !have_sections_script
      && (sh_flags & elfcpp::SHF_EXECINSTR) != 0
      && parameters->target().has_code_fill())
    {
      // We need to add some fill data.  Using fill_list_ when
      // possible is an optimization, since we will often have fill
      // sections without input sections.
      off_t fill_len = aligned_offset_in_section - offset_in_section;
      if (this->input_sections_.empty())
	this->fills_.push_back(Fill(offset_in_section, fill_len));
      else
	{
	  std::string fill_data(parameters->target().code_fill(fill_len));
	  Output_data_const* odc = new Output_data_const(fill_data, 1);
	  this->input_sections_.push_back(Input_section(odc));
	}
    }

  // We need to keep track of this section if we are already keeping
  // track of sections, or if we are relaxing.  Also, if this is a
  // section which requires sorting, or which may require sorting in
  // the future, we keep track of the sections.  If the
  // --section-ordering-file option is used to specify the order of
  // sections, we need to keep track of sections.
  if (this->always_keeps_input_sections_
      || have_sections_script
      || !this->input_sections_.empty()
      || this->may_sort_attached_input_sections()
      || this->must_sort_attached_input_sections()
      || parameters->options().user_set_Map()
      || parameters->target().may_relax()
      || layout->is_section_ordering_specified())
    {
      Input_section isecn(object, shndx, input_section_size, addralign);
      /* If section ordering is requested by specifying a ordering file,
	 using --section-ordering-file, match the section name with
	 a pattern.  */
      if (parameters->options().section_ordering_file())
	{
	  unsigned int section_order_index =
	    layout->find_section_order_index(std::string(secname));
	  if (section_order_index != 0)
	    {
	      isecn.set_section_order_index(section_order_index);
	      this->set_input_section_order_specified();
	    }
	}
      this->input_sections_.push_back(isecn);
    }

  return aligned_offset_in_section;
}

// Add arbitrary data to an output section.

void
Output_section::add_output_section_data(Output_section_data* posd)
{
  Input_section inp(posd);
  this->add_output_section_data(&inp);

  if (posd->is_data_size_valid())
    {
      off_t offset_in_section;
      if (this->has_fixed_layout())
	{
	  // For incremental updates, find a chunk of unused space.
	  offset_in_section = this->free_list_.allocate(posd->data_size(),
							posd->addralign(), 0);
	  if (offset_in_section == -1)
	    gold_fallback(_("out of patch space in section %s; "
			    "relink with --incremental-full"),
			  this->name());
	  // Finalize the address and offset now.
	  uint64_t addr = this->address();
	  off_t offset = this->offset();
	  posd->set_address_and_file_offset(addr + offset_in_section,
					    offset + offset_in_section);
	}
      else
	{
	  offset_in_section = this->current_data_size_for_child();
	  off_t aligned_offset_in_section = align_address(offset_in_section,
							  posd->addralign());
	  this->set_current_data_size_for_child(aligned_offset_in_section
						+ posd->data_size());
	}
    }
  else if (this->has_fixed_layout())
    {
      // For incremental updates, arrange for the data to have a fixed layout.
      // This will mean that additions to the data must be allocated from
      // free space within the containing output section.
      uint64_t addr = this->address();
      posd->set_address(addr);
      posd->set_file_offset(0);
      // FIXME: This should eventually be unreachable.
      // gold_unreachable();
    }
}

// Add a relaxed input section.

void
Output_section::add_relaxed_input_section(Layout* layout,
					  Output_relaxed_input_section* poris,
					  const std::string& name)
{
  Input_section inp(poris);

  // If the --section-ordering-file option is used to specify the order of
  // sections, we need to keep track of sections.
  if (layout->is_section_ordering_specified())
    {
      unsigned int section_order_index =
	layout->find_section_order_index(name);
      if (section_order_index != 0)
	{
	  inp.set_section_order_index(section_order_index);
	  this->set_input_section_order_specified();
	}
    }

  this->add_output_section_data(&inp);
  if (this->lookup_maps_->is_valid())
    this->lookup_maps_->add_relaxed_input_section(poris->relobj(),
						  poris->shndx(), poris);

  // For a relaxed section, we use the current data size.  Linker scripts
  // get all the input sections, including relaxed one from an output
  // section and add them back to the same output section to compute the
  // output section size.  If we do not account for sizes of relaxed input
  // sections, an output section would be incorrectly sized.
  off_t offset_in_section = this->current_data_size_for_child();
  off_t aligned_offset_in_section = align_address(offset_in_section,
						  poris->addralign());
  this->set_current_data_size_for_child(aligned_offset_in_section
					+ poris->current_data_size());
}

// Add arbitrary data to an output section by Input_section.

void
Output_section::add_output_section_data(Input_section* inp)
{
  if (this->input_sections_.empty())
    this->first_input_offset_ = this->current_data_size_for_child();

  this->input_sections_.push_back(*inp);

  uint64_t addralign = inp->addralign();
  if (addralign > this->addralign_)
    this->addralign_ = addralign;

  inp->set_output_section(this);
}

// Add a merge section to an output section.

void
Output_section::add_output_merge_section(Output_section_data* posd,
					 bool is_string, uint64_t entsize)
{
  Input_section inp(posd, is_string, entsize);
  this->add_output_section_data(&inp);
}

// Add an input section to a SHF_MERGE section.

bool
Output_section::add_merge_input_section(Relobj* object, unsigned int shndx,
					uint64_t flags, uint64_t entsize,
					uint64_t addralign,
					bool keeps_input_sections)
{
  bool is_string = (flags & elfcpp::SHF_STRINGS) != 0;

  // We cannot restore merged input section states.
  gold_assert(this->checkpoint_ == NULL);

  // Look up merge sections by required properties.
  // Currently, we only invalidate the lookup maps in script processing
  // and relaxation.  We should not have done either when we reach here.
  // So we assume that the lookup maps are valid to simply code.
  gold_assert(this->lookup_maps_->is_valid());
  Merge_section_properties msp(is_string, entsize, addralign);
  Output_merge_base* pomb = this->lookup_maps_->find_merge_section(msp);
  bool is_new = false;
  if (pomb != NULL)
    {
      gold_assert(pomb->is_string() == is_string
		  && pomb->entsize() == entsize
		  && pomb->addralign() == addralign);
    }
  else
    {
      // Create a new Output_merge_data or Output_merge_string_data.
      if (!is_string)
	pomb = new Output_merge_data(entsize, addralign);
      else
	{
	  switch (entsize)
	    {
	    case 1:
	      pomb = new Output_merge_string<char>(addralign);
	      break;
	    case 2:
	      pomb = new Output_merge_string<uint16_t>(addralign);
	      break;
	    case 4:
	      pomb = new Output_merge_string<uint32_t>(addralign);
	      break;
	    default:
	      return false;
	    }
	}
      // If we need to do script processing or relaxation, we need to keep
      // the original input sections to rebuild the fast lookup maps.
      if (keeps_input_sections)
	pomb->set_keeps_input_sections();
      is_new = true;
    }

  if (pomb->add_input_section(object, shndx))
    {
      // Add new merge section to this output section and link merge
      // section properties to new merge section in map.
      if (is_new)
	{
	  this->add_output_merge_section(pomb, is_string, entsize);
	  this->lookup_maps_->add_merge_section(msp, pomb);
	}

      // Add input section to new merge section and link input section to new
      // merge section in map.
      this->lookup_maps_->add_merge_input_section(object, shndx, pomb);
      return true;
    }
  else
    {
      // If add_input_section failed, delete new merge section to avoid
      // exporting empty merge sections in Output_section::get_input_section.
      if (is_new)
	delete pomb;
      return false;
    }
}

// Build a relaxation map to speed up relaxation of existing input sections.
// Look up to the first LIMIT elements in INPUT_SECTIONS.

void
Output_section::build_relaxation_map(
  const Input_section_list& input_sections,
  size_t limit,
  Relaxation_map* relaxation_map) const
{
  for (size_t i = 0; i < limit; ++i)
    {
      const Input_section& is(input_sections[i]);
      if (is.is_input_section() || is.is_relaxed_input_section())
	{
	  Section_id sid(is.relobj(), is.shndx());
	  (*relaxation_map)[sid] = i;
	}
    }
}

// Convert regular input sections in INPUT_SECTIONS into relaxed input
// sections in RELAXED_SECTIONS.  MAP is a prebuilt map from section id
// indices of INPUT_SECTIONS.

void
Output_section::convert_input_sections_in_list_to_relaxed_sections(
  const std::vector<Output_relaxed_input_section*>& relaxed_sections,
  const Relaxation_map& map,
  Input_section_list* input_sections)
{
  for (size_t i = 0; i < relaxed_sections.size(); ++i)
    {
      Output_relaxed_input_section* poris = relaxed_sections[i];
      Section_id sid(poris->relobj(), poris->shndx());
      Relaxation_map::const_iterator p = map.find(sid);
      gold_assert(p != map.end());
      gold_assert((*input_sections)[p->second].is_input_section());

      // Remember section order index of original input section
      // if it is set.  Copy it to the relaxed input section.
      unsigned int soi =
	(*input_sections)[p->second].section_order_index();
      (*input_sections)[p->second] = Input_section(poris);
      (*input_sections)[p->second].set_section_order_index(soi);
    }
}

// Convert regular input sections into relaxed input sections. RELAXED_SECTIONS
// is a vector of pointers to Output_relaxed_input_section or its derived
// classes.  The relaxed sections must correspond to existing input sections.

void
Output_section::convert_input_sections_to_relaxed_sections(
  const std::vector<Output_relaxed_input_section*>& relaxed_sections)
{
  gold_assert(parameters->target().may_relax());

  // We want to make sure that restore_states does not undo the effect of
  // this.  If there is no checkpoint active, just search the current
  // input section list and replace the sections there.  If there is
  // a checkpoint, also replace the sections there.

  // By default, we look at the whole list.
  size_t limit = this->input_sections_.size();

  if (this->checkpoint_ != NULL)
    {
      // Replace input sections with relaxed input section in the saved
      // copy of the input section list.
      if (this->checkpoint_->input_sections_saved())
	{
	  Relaxation_map map;
	  this->build_relaxation_map(
		    *(this->checkpoint_->input_sections()),
		    this->checkpoint_->input_sections()->size(),
		    &map);
	  this->convert_input_sections_in_list_to_relaxed_sections(
		    relaxed_sections,
		    map,
		    this->checkpoint_->input_sections());
	}
      else
	{
	  // We have not copied the input section list yet.  Instead, just
	  // look at the portion that would be saved.
	  limit = this->checkpoint_->input_sections_size();
	}
    }

  // Convert input sections in input_section_list.
  Relaxation_map map;
  this->build_relaxation_map(this->input_sections_, limit, &map);
  this->convert_input_sections_in_list_to_relaxed_sections(
	    relaxed_sections,
	    map,
	    &this->input_sections_);

  // Update fast look-up map.
  if (this->lookup_maps_->is_valid())
    for (size_t i = 0; i < relaxed_sections.size(); ++i)
      {
	Output_relaxed_input_section* poris = relaxed_sections[i];
	this->lookup_maps_->add_relaxed_input_section(poris->relobj(),
						      poris->shndx(), poris);
      }
}

// Update the output section flags based on input section flags.

void
Output_section::update_flags_for_input_section(elfcpp::Elf_Xword flags)
{
  // If we created the section with SHF_ALLOC clear, we set the
  // address.  If we are now setting the SHF_ALLOC flag, we need to
  // undo that.
  if ((this->flags_ & elfcpp::SHF_ALLOC) == 0
      && (flags & elfcpp::SHF_ALLOC) != 0)
    this->mark_address_invalid();

  this->flags_ |= (flags
		   & (elfcpp::SHF_WRITE
		      | elfcpp::SHF_ALLOC
		      | elfcpp::SHF_EXECINSTR));

  if ((flags & elfcpp::SHF_MERGE) == 0)
    this->flags_ &=~ elfcpp::SHF_MERGE;
  else
    {
      if (this->current_data_size_for_child() == 0)
	this->flags_ |= elfcpp::SHF_MERGE;
    }

  if ((flags & elfcpp::SHF_STRINGS) == 0)
    this->flags_ &=~ elfcpp::SHF_STRINGS;
  else
    {
      if (this->current_data_size_for_child() == 0)
	this->flags_ |= elfcpp::SHF_STRINGS;
    }
}

// Find the merge section into which an input section with index SHNDX in
// OBJECT has been added.  Return NULL if none found.

Output_section_data*
Output_section::find_merge_section(const Relobj* object,
				   unsigned int shndx) const
{
  if (!this->lookup_maps_->is_valid())
    this->build_lookup_maps();
  return this->lookup_maps_->find_merge_section(object, shndx);
}

// Build the lookup maps for merge and relaxed sections.  This is needs
// to be declared as a const methods so that it is callable with a const
// Output_section pointer.  The method only updates states of the maps.

void
Output_section::build_lookup_maps() const
{
  this->lookup_maps_->clear();
  for (Input_section_list::const_iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    {
      if (p->is_merge_section())
	{
	  Output_merge_base* pomb = p->output_merge_base();
	  Merge_section_properties msp(pomb->is_string(), pomb->entsize(),
				       pomb->addralign());
	  this->lookup_maps_->add_merge_section(msp, pomb);
	  for (Output_merge_base::Input_sections::const_iterator is =
		 pomb->input_sections_begin();
	       is != pomb->input_sections_end();
	       ++is)
	    {
	      const Const_section_id& csid = *is;
	    this->lookup_maps_->add_merge_input_section(csid.first,
							csid.second, pomb);
	    }

	}
      else if (p->is_relaxed_input_section())
	{
	  Output_relaxed_input_section* poris = p->relaxed_input_section();
	  this->lookup_maps_->add_relaxed_input_section(poris->relobj(),
							poris->shndx(), poris);
	}
    }
}

// Find an relaxed input section corresponding to an input section
// in OBJECT with index SHNDX.

const Output_relaxed_input_section*
Output_section::find_relaxed_input_section(const Relobj* object,
					   unsigned int shndx) const
{
  if (!this->lookup_maps_->is_valid())
    this->build_lookup_maps();
  return this->lookup_maps_->find_relaxed_input_section(object, shndx);
}

// Given an address OFFSET relative to the start of input section
// SHNDX in OBJECT, return whether this address is being included in
// the final link.  This should only be called if SHNDX in OBJECT has
// a special mapping.

bool
Output_section::is_input_address_mapped(const Relobj* object,
					unsigned int shndx,
					off_t offset) const
{
  // Look at the Output_section_data_maps first.
  const Output_section_data* posd = this->find_merge_section(object, shndx);
  if (posd == NULL)
    posd = this->find_relaxed_input_section(object, shndx);

  if (posd != NULL)
    {
      section_offset_type output_offset;
      bool found = posd->output_offset(object, shndx, offset, &output_offset);
      gold_assert(found);
      return output_offset != -1;
    }

  // Fall back to the slow look-up.
  for (Input_section_list::const_iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    {
      section_offset_type output_offset;
      if (p->output_offset(object, shndx, offset, &output_offset))
	return output_offset != -1;
    }

  // By default we assume that the address is mapped.  This should
  // only be called after we have passed all sections to Layout.  At
  // that point we should know what we are discarding.
  return true;
}

// Given an address OFFSET relative to the start of input section
// SHNDX in object OBJECT, return the output offset relative to the
// start of the input section in the output section.  This should only
// be called if SHNDX in OBJECT has a special mapping.

section_offset_type
Output_section::output_offset(const Relobj* object, unsigned int shndx,
			      section_offset_type offset) const
{
  // This can only be called meaningfully when we know the data size
  // of this.
  gold_assert(this->is_data_size_valid());

  // Look at the Output_section_data_maps first.
  const Output_section_data* posd = this->find_merge_section(object, shndx);
  if (posd == NULL)
    posd = this->find_relaxed_input_section(object, shndx);
  if (posd != NULL)
    {
      section_offset_type output_offset;
      bool found = posd->output_offset(object, shndx, offset, &output_offset);
      gold_assert(found);
      return output_offset;
    }

  // Fall back to the slow look-up.
  for (Input_section_list::const_iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    {
      section_offset_type output_offset;
      if (p->output_offset(object, shndx, offset, &output_offset))
	return output_offset;
    }
  gold_unreachable();
}

// Return the output virtual address of OFFSET relative to the start
// of input section SHNDX in object OBJECT.

uint64_t
Output_section::output_address(const Relobj* object, unsigned int shndx,
			       off_t offset) const
{
  uint64_t addr = this->address() + this->first_input_offset_;

  // Look at the Output_section_data_maps first.
  const Output_section_data* posd = this->find_merge_section(object, shndx);
  if (posd == NULL)
    posd = this->find_relaxed_input_section(object, shndx);
  if (posd != NULL && posd->is_address_valid())
    {
      section_offset_type output_offset;
      bool found = posd->output_offset(object, shndx, offset, &output_offset);
      gold_assert(found);
      return posd->address() + output_offset;
    }

  // Fall back to the slow look-up.
  for (Input_section_list::const_iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    {
      addr = align_address(addr, p->addralign());
      section_offset_type output_offset;
      if (p->output_offset(object, shndx, offset, &output_offset))
	{
	  if (output_offset == -1)
	    return -1ULL;
	  return addr + output_offset;
	}
      addr += p->data_size();
    }

  // If we get here, it means that we don't know the mapping for this
  // input section.  This might happen in principle if
  // add_input_section were called before add_output_section_data.
  // But it should never actually happen.

  gold_unreachable();
}

// Find the output address of the start of the merged section for
// input section SHNDX in object OBJECT.

bool
Output_section::find_starting_output_address(const Relobj* object,
					     unsigned int shndx,
					     uint64_t* paddr) const
{
  // FIXME: This becomes a bottle-neck if we have many relaxed sections.
  // Looking up the merge section map does not always work as we sometimes
  // find a merge section without its address set.
  uint64_t addr = this->address() + this->first_input_offset_;
  for (Input_section_list::const_iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    {
      addr = align_address(addr, p->addralign());

      // It would be nice if we could use the existing output_offset
      // method to get the output offset of input offset 0.
      // Unfortunately we don't know for sure that input offset 0 is
      // mapped at all.
      if (p->is_merge_section_for(object, shndx))
	{
	  *paddr = addr;
	  return true;
	}

      addr += p->data_size();
    }

  // We couldn't find a merge output section for this input section.
  return false;
}

// Update the data size of an Output_section.

void
Output_section::update_data_size()
{
  if (this->input_sections_.empty())
      return;

  if (this->must_sort_attached_input_sections()
      || this->input_section_order_specified())
    this->sort_attached_input_sections();

  off_t off = this->first_input_offset_;
  for (Input_section_list::iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    {
      off = align_address(off, p->addralign());
      off += p->current_data_size();
    }

  this->set_current_data_size_for_child(off);
}

// Set the data size of an Output_section.  This is where we handle
// setting the addresses of any Output_section_data objects.

void
Output_section::set_final_data_size()
{
  off_t data_size;

  if (this->input_sections_.empty())
    data_size = this->current_data_size_for_child();
  else
    {
      if (this->must_sort_attached_input_sections()
	  || this->input_section_order_specified())
	this->sort_attached_input_sections();

      uint64_t address = this->address();
      off_t startoff = this->offset();
      off_t off = startoff + this->first_input_offset_;
      for (Input_section_list::iterator p = this->input_sections_.begin();
	   p != this->input_sections_.end();
	   ++p)
	{
	  off = align_address(off, p->addralign());
	  p->set_address_and_file_offset(address + (off - startoff), off,
					 startoff);
	  off += p->data_size();
	}
      data_size = off - startoff;
    }

  // For full incremental links, we want to allocate some patch space
  // in most sections for subsequent incremental updates.
  if (this->is_patch_space_allowed_ && parameters->incremental_full())
    {
      double pct = parameters->options().incremental_patch();
      size_t extra = static_cast<size_t>(data_size * pct);
      if (this->free_space_fill_ != NULL
	  && this->free_space_fill_->minimum_hole_size() > extra)
	extra = this->free_space_fill_->minimum_hole_size();
      off_t new_size = align_address(data_size + extra, this->addralign());
      this->patch_space_ = new_size - data_size;
      gold_debug(DEBUG_INCREMENTAL,
		 "set_final_data_size: %08lx + %08lx: section %s",
		 static_cast<long>(data_size),
		 static_cast<long>(this->patch_space_),
		 this->name());
      data_size = new_size;
    }

  this->set_data_size(data_size);
}

// Reset the address and file offset.

void
Output_section::do_reset_address_and_file_offset()
{
  // An unallocated section has no address.  Forcing this means that
  // we don't need special treatment for symbols defined in debug
  // sections.  We do the same in the constructor.  This does not
  // apply to NOLOAD sections though.
  if (((this->flags_ & elfcpp::SHF_ALLOC) == 0) && !this->is_noload_)
     this->set_address(0);

  for (Input_section_list::iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    p->reset_address_and_file_offset();

  // Remove any patch space that was added in set_final_data_size.
  if (this->patch_space_ > 0)
    {
      this->set_current_data_size_for_child(this->current_data_size_for_child()
					    - this->patch_space_);
      this->patch_space_ = 0;
    }
}

// Return true if address and file offset have the values after reset.

bool
Output_section::do_address_and_file_offset_have_reset_values() const
{
  if (this->is_offset_valid())
    return false;

  // An unallocated section has address 0 after its construction or a reset.
  if ((this->flags_ & elfcpp::SHF_ALLOC) == 0)
    return this->is_address_valid() && this->address() == 0;
  else
    return !this->is_address_valid();
}

// Set the TLS offset.  Called only for SHT_TLS sections.

void
Output_section::do_set_tls_offset(uint64_t tls_base)
{
  this->tls_offset_ = this->address() - tls_base;
}

// In a few cases we need to sort the input sections attached to an
// output section.  This is used to implement the type of constructor
// priority ordering implemented by the GNU linker, in which the
// priority becomes part of the section name and the sections are
// sorted by name.  We only do this for an output section if we see an
// attached input section matching ".ctors.*", ".dtors.*",
// ".init_array.*" or ".fini_array.*".

class Output_section::Input_section_sort_entry
{
 public:
  Input_section_sort_entry()
    : input_section_(), index_(-1U), section_has_name_(false),
      section_name_()
  { }

  Input_section_sort_entry(const Input_section& input_section,
			   unsigned int index,
			   bool must_sort_attached_input_sections)
    : input_section_(input_section), index_(index),
      section_has_name_(input_section.is_input_section()
			|| input_section.is_relaxed_input_section())
  {
    if (this->section_has_name_
	&& must_sort_attached_input_sections)
      {
	// This is only called single-threaded from Layout::finalize,
	// so it is OK to lock.  Unfortunately we have no way to pass
	// in a Task token.
	const Task* dummy_task = reinterpret_cast<const Task*>(-1);
	Object* obj = (input_section.is_input_section()
		       ? input_section.relobj()
		       : input_section.relaxed_input_section()->relobj());
	Task_lock_obj<Object> tl(dummy_task, obj);

	// This is a slow operation, which should be cached in
	// Layout::layout if this becomes a speed problem.
	this->section_name_ = obj->section_name(input_section.shndx());
      }
  }

  // Return the Input_section.
  const Input_section&
  input_section() const
  {
    gold_assert(this->index_ != -1U);
    return this->input_section_;
  }

  // The index of this entry in the original list.  This is used to
  // make the sort stable.
  unsigned int
  index() const
  {
    gold_assert(this->index_ != -1U);
    return this->index_;
  }

  // Whether there is a section name.
  bool
  section_has_name() const
  { return this->section_has_name_; }

  // The section name.
  const std::string&
  section_name() const
  {
    gold_assert(this->section_has_name_);
    return this->section_name_;
  }

  // Return true if the section name has a priority.  This is assumed
  // to be true if it has a dot after the initial dot.
  bool
  has_priority() const
  {
    gold_assert(this->section_has_name_);
    return this->section_name_.find('.', 1) != std::string::npos;
  }

  // Return the priority.  Believe it or not, gcc encodes the priority
  // differently for .ctors/.dtors and .init_array/.fini_array
  // sections.
  unsigned int
  get_priority() const
  {
    gold_assert(this->section_has_name_);
    bool is_ctors;
    if (is_prefix_of(".ctors.", this->section_name_.c_str())
	|| is_prefix_of(".dtors.", this->section_name_.c_str()))
      is_ctors = true;
    else if (is_prefix_of(".init_array.", this->section_name_.c_str())
	     || is_prefix_of(".fini_array.", this->section_name_.c_str()))
      is_ctors = false;
    else
      return 0;
    char* end;
    unsigned long prio = strtoul((this->section_name_.c_str()
				  + (is_ctors ? 7 : 12)),
				 &end, 10);
    if (*end != '\0')
      return 0;
    else if (is_ctors)
      return 65535 - prio;
    else
      return prio;
  }

  // Return true if this an input file whose base name matches
  // FILE_NAME.  The base name must have an extension of ".o", and
  // must be exactly FILE_NAME.o or FILE_NAME, one character, ".o".
  // This is to match crtbegin.o as well as crtbeginS.o without
  // getting confused by other possibilities.  Overall matching the
  // file name this way is a dreadful hack, but the GNU linker does it
  // in order to better support gcc, and we need to be compatible.
  bool
  match_file_name(const char* file_name) const
  {
    if (this->input_section_.is_output_section_data())
      return false;
    return Layout::match_file_name(this->input_section_.relobj(), file_name);
  }

  // Returns 1 if THIS should appear before S in section order, -1 if S
  // appears before THIS and 0 if they are not comparable.
  int
  compare_section_ordering(const Input_section_sort_entry& s) const
  {
    unsigned int this_secn_index = this->input_section_.section_order_index();
    unsigned int s_secn_index = s.input_section().section_order_index();
    if (this_secn_index > 0 && s_secn_index > 0)
      {
	if (this_secn_index < s_secn_index)
	  return 1;
	else if (this_secn_index > s_secn_index)
	  return -1;
      }
    return 0;
  }

 private:
  // The Input_section we are sorting.
  Input_section input_section_;
  // The index of this Input_section in the original list.
  unsigned int index_;
  // Whether this Input_section has a section name--it won't if this
  // is some random Output_section_data.
  bool section_has_name_;
  // The section name if there is one.
  std::string section_name_;
};

// Return true if S1 should come before S2 in the output section.

bool
Output_section::Input_section_sort_compare::operator()(
    const Output_section::Input_section_sort_entry& s1,
    const Output_section::Input_section_sort_entry& s2) const
{
  // crtbegin.o must come first.
  bool s1_begin = s1.match_file_name("crtbegin");
  bool s2_begin = s2.match_file_name("crtbegin");
  if (s1_begin || s2_begin)
    {
      if (!s1_begin)
	return false;
      if (!s2_begin)
	return true;
      return s1.index() < s2.index();
    }

  // crtend.o must come last.
  bool s1_end = s1.match_file_name("crtend");
  bool s2_end = s2.match_file_name("crtend");
  if (s1_end || s2_end)
    {
      if (!s1_end)
	return true;
      if (!s2_end)
	return false;
      return s1.index() < s2.index();
    }

  // We sort all the sections with no names to the end.
  if (!s1.section_has_name() || !s2.section_has_name())
    {
      if (s1.section_has_name())
	return true;
      if (s2.section_has_name())
	return false;
      return s1.index() < s2.index();
    }

  // A section with a priority follows a section without a priority.
  bool s1_has_priority = s1.has_priority();
  bool s2_has_priority = s2.has_priority();
  if (s1_has_priority && !s2_has_priority)
    return false;
  if (!s1_has_priority && s2_has_priority)
    return true;

  // Check if a section order exists for these sections through a section
  // ordering file.  If sequence_num is 0, an order does not exist.
  int sequence_num = s1.compare_section_ordering(s2);
  if (sequence_num != 0)
    return sequence_num == 1;

  // Otherwise we sort by name.
  int compare = s1.section_name().compare(s2.section_name());
  if (compare != 0)
    return compare < 0;

  // Otherwise we keep the input order.
  return s1.index() < s2.index();
}

// Return true if S1 should come before S2 in an .init_array or .fini_array
// output section.

bool
Output_section::Input_section_sort_init_fini_compare::operator()(
    const Output_section::Input_section_sort_entry& s1,
    const Output_section::Input_section_sort_entry& s2) const
{
  // We sort all the sections with no names to the end.
  if (!s1.section_has_name() || !s2.section_has_name())
    {
      if (s1.section_has_name())
	return true;
      if (s2.section_has_name())
	return false;
      return s1.index() < s2.index();
    }

  // A section without a priority follows a section with a priority.
  // This is the reverse of .ctors and .dtors sections.
  bool s1_has_priority = s1.has_priority();
  bool s2_has_priority = s2.has_priority();
  if (s1_has_priority && !s2_has_priority)
    return true;
  if (!s1_has_priority && s2_has_priority)
    return false;

  // .ctors and .dtors sections without priority come after
  // .init_array and .fini_array sections without priority.
  if (!s1_has_priority
      && (s1.section_name() == ".ctors" || s1.section_name() == ".dtors")
      && s1.section_name() != s2.section_name())
    return false;
  if (!s2_has_priority
      && (s2.section_name() == ".ctors" || s2.section_name() == ".dtors")
      && s2.section_name() != s1.section_name())
    return true;

  // Sort by priority if we can.
  if (s1_has_priority)
    {
      unsigned int s1_prio = s1.get_priority();
      unsigned int s2_prio = s2.get_priority();
      if (s1_prio < s2_prio)
	return true;
      else if (s1_prio > s2_prio)
	return false;
    }

  // Check if a section order exists for these sections through a section
  // ordering file.  If sequence_num is 0, an order does not exist.
  int sequence_num = s1.compare_section_ordering(s2);
  if (sequence_num != 0)
    return sequence_num == 1;

  // Otherwise we sort by name.
  int compare = s1.section_name().compare(s2.section_name());
  if (compare != 0)
    return compare < 0;

  // Otherwise we keep the input order.
  return s1.index() < s2.index();
}

// Return true if S1 should come before S2.  Sections that do not match
// any pattern in the section ordering file are placed ahead of the sections
// that match some pattern.

bool
Output_section::Input_section_sort_section_order_index_compare::operator()(
    const Output_section::Input_section_sort_entry& s1,
    const Output_section::Input_section_sort_entry& s2) const
{
  unsigned int s1_secn_index = s1.input_section().section_order_index();
  unsigned int s2_secn_index = s2.input_section().section_order_index();

  // Keep input order if section ordering cannot determine order.
  if (s1_secn_index == s2_secn_index)
    return s1.index() < s2.index();

  return s1_secn_index < s2_secn_index;
}

// Return true if S1 should come before S2.  This is the sort comparison
// function for .text to sort sections with prefixes
// .text.{unlikely,exit,startup,hot} before other sections.

bool
Output_section::Input_section_sort_section_prefix_special_ordering_compare
  ::operator()(
    const Output_section::Input_section_sort_entry& s1,
    const Output_section::Input_section_sort_entry& s2) const
{
  // We sort all the sections with no names to the end.
  if (!s1.section_has_name() || !s2.section_has_name())
    {
      if (s1.section_has_name())
	return true;
      if (s2.section_has_name())
	return false;
      return s1.index() < s2.index();
    }

  // Some input section names have special ordering requirements.
  int o1 = Layout::special_ordering_of_input_section(s1.section_name().c_str());
  int o2 = Layout::special_ordering_of_input_section(s2.section_name().c_str());
  if (o1 != o2)
    {
      if (o1 < 0)
	return false;
      else if (o2 < 0)
	return true;
      else
	return o1 < o2;
    }

  // Keep input order otherwise.
  return s1.index() < s2.index();
}

// Return true if S1 should come before S2.  This is the sort comparison
// function for sections to sort them by name.

bool
Output_section::Input_section_sort_section_name_compare
  ::operator()(
    const Output_section::Input_section_sort_entry& s1,
    const Output_section::Input_section_sort_entry& s2) const
{
  // We sort all the sections with no names to the end.
  if (!s1.section_has_name() || !s2.section_has_name())
    {
      if (s1.section_has_name())
	return true;
      if (s2.section_has_name())
	return false;
      return s1.index() < s2.index();
    }

  // We sort by name.
  int compare = s1.section_name().compare(s2.section_name());
  if (compare != 0)
    return compare < 0;

  // Keep input order otherwise.
  return s1.index() < s2.index();
}

// This updates the section order index of input sections according to the
// the order specified in the mapping from Section id to order index.

void
Output_section::update_section_layout(
  const Section_layout_order* order_map)
{
  for (Input_section_list::iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    {
      if (p->is_input_section()
	  || p->is_relaxed_input_section())
	{
	  Object* obj = (p->is_input_section()
			 ? p->relobj()
			 : p->relaxed_input_section()->relobj());
	  unsigned int shndx = p->shndx();
	  Section_layout_order::const_iterator it
	    = order_map->find(Section_id(obj, shndx));
	  if (it == order_map->end())
	    continue;
	  unsigned int section_order_index = it->second;
	  if (section_order_index != 0)
	    {
	      p->set_section_order_index(section_order_index);
	      this->set_input_section_order_specified();
	    }
	}
    }
}

// Sort the input sections attached to an output section.

void
Output_section::sort_attached_input_sections()
{
  if (this->attached_input_sections_are_sorted_)
    return;

  if (this->checkpoint_ != NULL
      && !this->checkpoint_->input_sections_saved())
    this->checkpoint_->save_input_sections();

  // The only thing we know about an input section is the object and
  // the section index.  We need the section name.  Recomputing this
  // is slow but this is an unusual case.  If this becomes a speed
  // problem we can cache the names as required in Layout::layout.

  // We start by building a larger vector holding a copy of each
  // Input_section, plus its current index in the list and its name.
  std::vector<Input_section_sort_entry> sort_list;

  unsigned int i = 0;
  for (Input_section_list::iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p, ++i)
      sort_list.push_back(Input_section_sort_entry(*p, i,
			    this->must_sort_attached_input_sections()));

  // Sort the input sections.
  if (this->must_sort_attached_input_sections())
    {
      if (this->type() == elfcpp::SHT_PREINIT_ARRAY
	  || this->type() == elfcpp::SHT_INIT_ARRAY
	  || this->type() == elfcpp::SHT_FINI_ARRAY)
	std::sort(sort_list.begin(), sort_list.end(),
		  Input_section_sort_init_fini_compare());
      else if (strcmp(parameters->options().sort_section(), "name") == 0)
	std::sort(sort_list.begin(), sort_list.end(),
		  Input_section_sort_section_name_compare());
      else if (strcmp(this->name(), ".text") == 0)
	std::sort(sort_list.begin(), sort_list.end(),
		  Input_section_sort_section_prefix_special_ordering_compare());
      else
	std::sort(sort_list.begin(), sort_list.end(),
		  Input_section_sort_compare());
    }
  else
    {
      gold_assert(this->input_section_order_specified());
      std::sort(sort_list.begin(), sort_list.end(),
		Input_section_sort_section_order_index_compare());
    }

  // Copy the sorted input sections back to our list.
  this->input_sections_.clear();
  for (std::vector<Input_section_sort_entry>::iterator p = sort_list.begin();
       p != sort_list.end();
       ++p)
    this->input_sections_.push_back(p->input_section());
  sort_list.clear();

  // Remember that we sorted the input sections, since we might get
  // called again.
  this->attached_input_sections_are_sorted_ = true;
}

// Write the section header to *OSHDR.

template<int size, bool big_endian>
void
Output_section::write_header(const Layout* layout,
			     const Stringpool* secnamepool,
			     elfcpp::Shdr_write<size, big_endian>* oshdr) const
{
  oshdr->put_sh_name(secnamepool->get_offset(this->name_));
  oshdr->put_sh_type(this->type_);

  elfcpp::Elf_Xword flags = this->flags_;
  if (this->info_section_ != NULL && this->info_uses_section_index_)
    flags |= elfcpp::SHF_INFO_LINK;
  oshdr->put_sh_flags(flags);

  oshdr->put_sh_addr(this->address());
  oshdr->put_sh_offset(this->offset());
  oshdr->put_sh_size(this->data_size());
  if (this->link_section_ != NULL)
    oshdr->put_sh_link(this->link_section_->out_shndx());
  else if (this->should_link_to_symtab_)
    oshdr->put_sh_link(layout->symtab_section_shndx());
  else if (this->should_link_to_dynsym_)
    oshdr->put_sh_link(layout->dynsym_section()->out_shndx());
  else
    oshdr->put_sh_link(this->link_);

  elfcpp::Elf_Word info;
  if (this->info_section_ != NULL)
    {
      if (this->info_uses_section_index_)
	info = this->info_section_->out_shndx();
      else
	info = this->info_section_->symtab_index();
    }
  else if (this->info_symndx_ != NULL)
    info = this->info_symndx_->symtab_index();
  else
    info = this->info_;
  oshdr->put_sh_info(info);

  oshdr->put_sh_addralign(this->addralign_);
  oshdr->put_sh_entsize(this->entsize_);
}

// Write out the data.  For input sections the data is written out by
// Object::relocate, but we have to handle Output_section_data objects
// here.

void
Output_section::do_write(Output_file* of)
{
  gold_assert(!this->requires_postprocessing());

  // If the target performs relaxation, we delay filler generation until now.
  gold_assert(!this->generate_code_fills_at_write_ || this->fills_.empty());

  off_t output_section_file_offset = this->offset();
  for (Fill_list::iterator p = this->fills_.begin();
       p != this->fills_.end();
       ++p)
    {
      std::string fill_data(parameters->target().code_fill(p->length()));
      of->write(output_section_file_offset + p->section_offset(),
		fill_data.data(), fill_data.size());
    }

  off_t off = this->offset() + this->first_input_offset_;
  for (Input_section_list::iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    {
      off_t aligned_off = align_address(off, p->addralign());
      if (this->generate_code_fills_at_write_ && (off != aligned_off))
	{
	  size_t fill_len = aligned_off - off;
	  std::string fill_data(parameters->target().code_fill(fill_len));
	  of->write(off, fill_data.data(), fill_data.size());
	}

      p->write(of);
      off = aligned_off + p->data_size();
    }

  // For incremental links, fill in unused chunks in debug sections
  // with dummy compilation unit headers.
  if (this->free_space_fill_ != NULL)
    {
      for (Free_list::Const_iterator p = this->free_list_.begin();
	   p != this->free_list_.end();
	   ++p)
	{
	  off_t off = p->start_;
	  size_t len = p->end_ - off;
	  this->free_space_fill_->write(of, this->offset() + off, len);
	}
      if (this->patch_space_ > 0)
	{
	  off_t off = this->current_data_size_for_child() - this->patch_space_;
	  this->free_space_fill_->write(of, this->offset() + off,
					this->patch_space_);
	}
    }
}

// If a section requires postprocessing, create the buffer to use.

void
Output_section::create_postprocessing_buffer()
{
  gold_assert(this->requires_postprocessing());

  if (this->postprocessing_buffer_ != NULL)
    return;

  if (!this->input_sections_.empty())
    {
      off_t off = this->first_input_offset_;
      for (Input_section_list::iterator p = this->input_sections_.begin();
	   p != this->input_sections_.end();
	   ++p)
	{
	  off = align_address(off, p->addralign());
	  p->finalize_data_size();
	  off += p->data_size();
	}
      this->set_current_data_size_for_child(off);
    }

  off_t buffer_size = this->current_data_size_for_child();
  this->postprocessing_buffer_ = new unsigned char[buffer_size];
}

// Write all the data of an Output_section into the postprocessing
// buffer.  This is used for sections which require postprocessing,
// such as compression.  Input sections are handled by
// Object::Relocate.

void
Output_section::write_to_postprocessing_buffer()
{
  gold_assert(this->requires_postprocessing());

  // If the target performs relaxation, we delay filler generation until now.
  gold_assert(!this->generate_code_fills_at_write_ || this->fills_.empty());

  unsigned char* buffer = this->postprocessing_buffer();
  for (Fill_list::iterator p = this->fills_.begin();
       p != this->fills_.end();
       ++p)
    {
      std::string fill_data(parameters->target().code_fill(p->length()));
      memcpy(buffer + p->section_offset(), fill_data.data(),
	     fill_data.size());
    }

  off_t off = this->first_input_offset_;
  for (Input_section_list::iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    {
      off_t aligned_off = align_address(off, p->addralign());
      if (this->generate_code_fills_at_write_ && (off != aligned_off))
	{
	  size_t fill_len = aligned_off - off;
	  std::string fill_data(parameters->target().code_fill(fill_len));
	  memcpy(buffer + off, fill_data.data(), fill_data.size());
	}

      p->write_to_buffer(buffer + aligned_off);
      off = aligned_off + p->data_size();
    }
}

// Get the input sections for linker script processing.  We leave
// behind the Output_section_data entries.  Note that this may be
// slightly incorrect for merge sections.  We will leave them behind,
// but it is possible that the script says that they should follow
// some other input sections, as in:
//    .rodata { *(.rodata) *(.rodata.cst*) }
// For that matter, we don't handle this correctly:
//    .rodata { foo.o(.rodata.cst*) *(.rodata.cst*) }
// With luck this will never matter.

uint64_t
Output_section::get_input_sections(
    uint64_t address,
    const std::string& fill,
    std::list<Input_section>* input_sections)
{
  if (this->checkpoint_ != NULL
      && !this->checkpoint_->input_sections_saved())
    this->checkpoint_->save_input_sections();

  // Invalidate fast look-up maps.
  this->lookup_maps_->invalidate();

  uint64_t orig_address = address;

  address = align_address(address, this->addralign());

  Input_section_list remaining;
  for (Input_section_list::iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    {
      if (p->is_input_section()
	  || p->is_relaxed_input_section()
	  || p->is_merge_section())
	input_sections->push_back(*p);
      else
	{
	  uint64_t aligned_address = align_address(address, p->addralign());
	  if (aligned_address != address && !fill.empty())
	    {
	      section_size_type length =
		convert_to_section_size_type(aligned_address - address);
	      std::string this_fill;
	      this_fill.reserve(length);
	      while (this_fill.length() + fill.length() <= length)
		this_fill += fill;
	      if (this_fill.length() < length)
		this_fill.append(fill, 0, length - this_fill.length());

	      Output_section_data* posd = new Output_data_const(this_fill, 0);
	      remaining.push_back(Input_section(posd));
	    }
	  address = aligned_address;

	  remaining.push_back(*p);

	  p->finalize_data_size();
	  address += p->data_size();
	}
    }

  this->input_sections_.swap(remaining);
  this->first_input_offset_ = 0;

  uint64_t data_size = address - orig_address;
  this->set_current_data_size_for_child(data_size);
  return data_size;
}

// Add a script input section.  SIS is an Output_section::Input_section,
// which can be either a plain input section or a special input section like
// a relaxed input section.  For a special input section, its size must be
// finalized.

void
Output_section::add_script_input_section(const Input_section& sis)
{
  uint64_t data_size = sis.data_size();
  uint64_t addralign = sis.addralign();
  if (addralign > this->addralign_)
    this->addralign_ = addralign;

  off_t offset_in_section = this->current_data_size_for_child();
  off_t aligned_offset_in_section = align_address(offset_in_section,
						  addralign);

  this->set_current_data_size_for_child(aligned_offset_in_section
					+ data_size);

  this->input_sections_.push_back(sis);

  // Update fast lookup maps if necessary.
  if (this->lookup_maps_->is_valid())
    {
      if (sis.is_merge_section())
	{
	  Output_merge_base* pomb = sis.output_merge_base();
	  Merge_section_properties msp(pomb->is_string(), pomb->entsize(),
				       pomb->addralign());
	  this->lookup_maps_->add_merge_section(msp, pomb);
	  for (Output_merge_base::Input_sections::const_iterator p =
		 pomb->input_sections_begin();
	       p != pomb->input_sections_end();
	       ++p)
	    this->lookup_maps_->add_merge_input_section(p->first, p->second,
							pomb);
	}
      else if (sis.is_relaxed_input_section())
	{
	  Output_relaxed_input_section* poris = sis.relaxed_input_section();
	  this->lookup_maps_->add_relaxed_input_section(poris->relobj(),
							poris->shndx(), poris);
	}
    }
}

// Save states for relaxation.

void
Output_section::save_states()
{
  gold_assert(this->checkpoint_ == NULL);
  Checkpoint_output_section* checkpoint =
    new Checkpoint_output_section(this->addralign_, this->flags_,
				  this->input_sections_,
				  this->first_input_offset_,
				  this->attached_input_sections_are_sorted_);
  this->checkpoint_ = checkpoint;
  gold_assert(this->fills_.empty());
}

void
Output_section::discard_states()
{
  gold_assert(this->checkpoint_ != NULL);
  delete this->checkpoint_;
  this->checkpoint_ = NULL;
  gold_assert(this->fills_.empty());

  // Simply invalidate the fast lookup maps since we do not keep
  // track of them.
  this->lookup_maps_->invalidate();
}

void
Output_section::restore_states()
{
  gold_assert(this->checkpoint_ != NULL);
  Checkpoint_output_section* checkpoint = this->checkpoint_;

  this->addralign_ = checkpoint->addralign();
  this->flags_ = checkpoint->flags();
  this->first_input_offset_ = checkpoint->first_input_offset();

  if (!checkpoint->input_sections_saved())
    {
      // If we have not copied the input sections, just resize it.
      size_t old_size = checkpoint->input_sections_size();
      gold_assert(this->input_sections_.size() >= old_size);
      this->input_sections_.resize(old_size);
    }
  else
    {
      // We need to copy the whole list.  This is not efficient for
      // extremely large output with hundreads of thousands of input
      // objects.  We may need to re-think how we should pass sections
      // to scripts.
      this->input_sections_ = *checkpoint->input_sections();
    }

  this->attached_input_sections_are_sorted_ =
    checkpoint->attached_input_sections_are_sorted();

  // Simply invalidate the fast lookup maps since we do not keep
  // track of them.
  this->lookup_maps_->invalidate();
}

// Update the section offsets of input sections in this.  This is required if
// relaxation causes some input sections to change sizes.

void
Output_section::adjust_section_offsets()
{
  if (!this->section_offsets_need_adjustment_)
    return;

  off_t off = 0;
  for (Input_section_list::iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    {
      off = align_address(off, p->addralign());
      if (p->is_input_section())
	p->relobj()->set_section_offset(p->shndx(), off);
      off += p->data_size();
    }

  this->section_offsets_need_adjustment_ = false;
}

// Print to the map file.

void
Output_section::do_print_to_mapfile(Mapfile* mapfile) const
{
  mapfile->print_output_section(this);

  for (Input_section_list::const_iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    p->print_to_mapfile(mapfile);
}

// Print stats for merge sections to stderr.

void
Output_section::print_merge_stats()
{
  Input_section_list::iterator p;
  for (p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    p->print_merge_stats(this->name_);
}

// Set a fixed layout for the section.  Used for incremental update links.

void
Output_section::set_fixed_layout(uint64_t sh_addr, off_t sh_offset,
				 off_t sh_size, uint64_t sh_addralign)
{
  this->addralign_ = sh_addralign;
  this->set_current_data_size(sh_size);
  if ((this->flags_ & elfcpp::SHF_ALLOC) != 0)
    this->set_address(sh_addr);
  this->set_file_offset(sh_offset);
  this->finalize_data_size();
  this->free_list_.init(sh_size, false);
  this->has_fixed_layout_ = true;
}

// Reserve space within the fixed layout for the section.  Used for
// incremental update links.

void
Output_section::reserve(uint64_t sh_offset, uint64_t sh_size)
{
  this->free_list_.remove(sh_offset, sh_offset + sh_size);
}

// Allocate space from the free list for the section.  Used for
// incremental update links.

off_t
Output_section::allocate(off_t len, uint64_t addralign)
{
  return this->free_list_.allocate(len, addralign, 0);
}

// Output segment methods.

Output_segment::Output_segment(elfcpp::Elf_Word type, elfcpp::Elf_Word flags)
  : vaddr_(0),
    paddr_(0),
    memsz_(0),
    max_align_(0),
    min_p_align_(0),
    offset_(0),
    filesz_(0),
    type_(type),
    flags_(flags),
    is_max_align_known_(false),
    are_addresses_set_(false),
    is_large_data_segment_(false),
    is_unique_segment_(false)
{
  // The ELF ABI specifies that a PT_TLS segment always has PF_R as
  // the flags.
  if (type == elfcpp::PT_TLS)
    this->flags_ = elfcpp::PF_R;
}

// Add an Output_section to a PT_LOAD Output_segment.

void
Output_segment::add_output_section_to_load(Layout* layout,
					   Output_section* os,
					   elfcpp::Elf_Word seg_flags)
{
  gold_assert(this->type() == elfcpp::PT_LOAD);
  gold_assert((os->flags() & elfcpp::SHF_ALLOC) != 0);
  gold_assert(!this->is_max_align_known_);
  gold_assert(os->is_large_data_section() == this->is_large_data_segment());

  this->update_flags_for_output_section(seg_flags);

  // We don't want to change the ordering if we have a linker script
  // with a SECTIONS clause.
  Output_section_order order = os->order();
  if (layout->script_options()->saw_sections_clause())
    order = static_cast<Output_section_order>(0);
  else
    gold_assert(order != ORDER_INVALID);

  this->output_lists_[order].push_back(os);
}

// Add an Output_section to a non-PT_LOAD Output_segment.

void
Output_segment::add_output_section_to_nonload(Output_section* os,
					      elfcpp::Elf_Word seg_flags)
{
  gold_assert(this->type() != elfcpp::PT_LOAD);
  gold_assert((os->flags() & elfcpp::SHF_ALLOC) != 0);
  gold_assert(!this->is_max_align_known_);

  this->update_flags_for_output_section(seg_flags);

  this->output_lists_[0].push_back(os);
}

// Remove an Output_section from this segment.  It is an error if it
// is not present.

void
Output_segment::remove_output_section(Output_section* os)
{
  for (int i = 0; i < static_cast<int>(ORDER_MAX); ++i)
    {
      Output_data_list* pdl = &this->output_lists_[i];
      for (Output_data_list::iterator p = pdl->begin(); p != pdl->end(); ++p)
	{
	  if (*p == os)
	    {
	      pdl->erase(p);
	      return;
	    }
	}
    }
  gold_unreachable();
}

// Add an Output_data (which need not be an Output_section) to the
// start of a segment.

void
Output_segment::add_initial_output_data(Output_data* od)
{
  gold_assert(!this->is_max_align_known_);
  Output_data_list::iterator p = this->output_lists_[0].begin();
  this->output_lists_[0].insert(p, od);
}

// Return true if this segment has any sections which hold actual
// data, rather than being a BSS section.

bool
Output_segment::has_any_data_sections() const
{
  for (int i = 0; i < static_cast<int>(ORDER_MAX); ++i)
    {
      const Output_data_list* pdl = &this->output_lists_[i];
      for (Output_data_list::const_iterator p = pdl->begin();
	   p != pdl->end();
	   ++p)
	{
	  if (!(*p)->is_section())
	    return true;
	  if ((*p)->output_section()->type() != elfcpp::SHT_NOBITS)
	    return true;
	}
    }
  return false;
}

// Return whether the first data section (not counting TLS sections)
// is a relro section.

bool
Output_segment::is_first_section_relro() const
{
  for (int i = 0; i < static_cast<int>(ORDER_MAX); ++i)
    {
      if (i == static_cast<int>(ORDER_TLS_DATA)
	  || i == static_cast<int>(ORDER_TLS_BSS))
	continue;
      const Output_data_list* pdl = &this->output_lists_[i];
      if (!pdl->empty())
	{
	  Output_data* p = pdl->front();
	  return p->is_section() && p->output_section()->is_relro();
	}
    }
  return false;
}

// Return the maximum alignment of the Output_data in Output_segment.

uint64_t
Output_segment::maximum_alignment()
{
  if (!this->is_max_align_known_)
    {
      for (int i = 0; i < static_cast<int>(ORDER_MAX); ++i)
	{
	  const Output_data_list* pdl = &this->output_lists_[i];
	  uint64_t addralign = Output_segment::maximum_alignment_list(pdl);
	  if (addralign > this->max_align_)
	    this->max_align_ = addralign;
	}
      this->is_max_align_known_ = true;
    }

  return this->max_align_;
}

// Return the maximum alignment of a list of Output_data.

uint64_t
Output_segment::maximum_alignment_list(const Output_data_list* pdl)
{
  uint64_t ret = 0;
  for (Output_data_list::const_iterator p = pdl->begin();
       p != pdl->end();
       ++p)
    {
      uint64_t addralign = (*p)->addralign();
      if (addralign > ret)
	ret = addralign;
    }
  return ret;
}

// Return whether this segment has any dynamic relocs.

bool
Output_segment::has_dynamic_reloc() const
{
  for (int i = 0; i < static_cast<int>(ORDER_MAX); ++i)
    if (this->has_dynamic_reloc_list(&this->output_lists_[i]))
      return true;
  return false;
}

// Return whether this Output_data_list has any dynamic relocs.

bool
Output_segment::has_dynamic_reloc_list(const Output_data_list* pdl) const
{
  for (Output_data_list::const_iterator p = pdl->begin();
       p != pdl->end();
       ++p)
    if ((*p)->has_dynamic_reloc())
      return true;
  return false;
}

// Set the section addresses for an Output_segment.  If RESET is true,
// reset the addresses first.  ADDR is the address and *POFF is the
// file offset.  Set the section indexes starting with *PSHNDX.
// INCREASE_RELRO is the size of the portion of the first non-relro
// section that should be included in the PT_GNU_RELRO segment.
// If this segment has relro sections, and has been aligned for
// that purpose, set *HAS_RELRO to TRUE.  Return the address of
// the immediately following segment.  Update *HAS_RELRO, *POFF,
// and *PSHNDX.

uint64_t
Output_segment::set_section_addresses(const Target* target,
				      Layout* layout, bool reset,
				      uint64_t addr,
				      unsigned int* increase_relro,
				      bool* has_relro,
				      off_t* poff,
				      unsigned int* pshndx)
{
  gold_assert(this->type_ == elfcpp::PT_LOAD);

  uint64_t last_relro_pad = 0;
  off_t orig_off = *poff;

  bool in_tls = false;

  // If we have relro sections, we need to pad forward now so that the
  // relro sections plus INCREASE_RELRO end on an abi page boundary.
  if (parameters->options().relro()
      && this->is_first_section_relro()
      && (!this->are_addresses_set_ || reset))
    {
      uint64_t relro_size = 0;
      off_t off = *poff;
      uint64_t max_align = 0;
      for (int i = 0; i <= static_cast<int>(ORDER_RELRO_LAST); ++i)
	{
	  Output_data_list* pdl = &this->output_lists_[i];
	  Output_data_list::iterator p;
	  for (p = pdl->begin(); p != pdl->end(); ++p)
	    {
	      if (!(*p)->is_section())
		break;
	      uint64_t align = (*p)->addralign();
	      if (align > max_align)
		max_align = align;
	      if ((*p)->is_section_flag_set(elfcpp::SHF_TLS))
		in_tls = true;
	      else if (in_tls)
		{
		  // Align the first non-TLS section to the alignment
		  // of the TLS segment.
		  align = max_align;
		  in_tls = false;
		}
	      relro_size = align_address(relro_size, align);
	      // Ignore the size of the .tbss section.
	      if ((*p)->is_section_flag_set(elfcpp::SHF_TLS)
		  && (*p)->is_section_type(elfcpp::SHT_NOBITS))
		continue;
	      if ((*p)->is_address_valid())
		relro_size += (*p)->data_size();
	      else
		{
		  // FIXME: This could be faster.
		  (*p)->set_address_and_file_offset(addr + relro_size,
						    off + relro_size);
		  relro_size += (*p)->data_size();
		  (*p)->reset_address_and_file_offset();
		}
	    }
	  if (p != pdl->end())
	    break;
	}
      relro_size += *increase_relro;
      // Pad the total relro size to a multiple of the maximum
      // section alignment seen.
      uint64_t aligned_size = align_address(relro_size, max_align);
      // Note the amount of padding added after the last relro section.
      last_relro_pad = aligned_size - relro_size;
      *has_relro = true;

      uint64_t page_align = parameters->target().abi_pagesize();

      // Align to offset N such that (N + RELRO_SIZE) % PAGE_ALIGN == 0.
      uint64_t desired_align = page_align - (aligned_size % page_align);
      if (desired_align < *poff % page_align)
	*poff += page_align - *poff % page_align;
      *poff += desired_align - *poff % page_align;
      addr += *poff - orig_off;
      orig_off = *poff;
    }

  if (!reset && this->are_addresses_set_)
    {
      gold_assert(this->paddr_ == addr);
      addr = this->vaddr_;
    }
  else
    {
      this->vaddr_ = addr;
      this->paddr_ = addr;
      this->are_addresses_set_ = true;
    }

  in_tls = false;

  this->offset_ = orig_off;

  off_t off = 0;
  uint64_t ret;
  for (int i = 0; i < static_cast<int>(ORDER_MAX); ++i)
    {
      if (i == static_cast<int>(ORDER_RELRO_LAST))
	{
	  *poff += last_relro_pad;
	  addr += last_relro_pad;
	  if (this->output_lists_[i].empty())
	    {
	      // If there is nothing in the ORDER_RELRO_LAST list,
	      // the padding will occur at the end of the relro
	      // segment, and we need to add it to *INCREASE_RELRO.
	      *increase_relro += last_relro_pad;
	    }
	}
      addr = this->set_section_list_addresses(layout, reset,
					      &this->output_lists_[i],
					      addr, poff, pshndx, &in_tls);
      if (i < static_cast<int>(ORDER_SMALL_BSS))
	{
	  this->filesz_ = *poff - orig_off;
	  off = *poff;
	}

      ret = addr;
    }

  // If the last section was a TLS section, align upward to the
  // alignment of the TLS segment, so that the overall size of the TLS
  // segment is aligned.
  if (in_tls)
    {
      uint64_t segment_align = layout->tls_segment()->maximum_alignment();
      *poff = align_address(*poff, segment_align);
    }

  this->memsz_ = *poff - orig_off;

  // Ignore the file offset adjustments made by the BSS Output_data
  // objects.
  *poff = off;

  // If code segments must contain only code, and this code segment is
  // page-aligned in the file, then fill it out to a whole page with
  // code fill (the tail of the segment will not be within any section).
  // Thus the entire code segment can be mapped from the file as whole
  // pages and that mapping will contain only valid instructions.
  if (target->isolate_execinstr() && (this->flags() & elfcpp::PF_X) != 0)
    {
      uint64_t abi_pagesize = target->abi_pagesize();
      if (orig_off % abi_pagesize == 0 && off % abi_pagesize != 0)
	{
	  size_t fill_size = abi_pagesize - (off % abi_pagesize);

	  std::string fill_data;
	  if (target->has_code_fill())
	    fill_data = target->code_fill(fill_size);
	  else
	    fill_data.resize(fill_size); // Zero fill.

	  Output_data_const* fill = new Output_data_const(fill_data, 0);
	  fill->set_address(this->vaddr_ + this->memsz_);
	  fill->set_file_offset(off);
	  layout->add_relax_output(fill);

	  off += fill_size;
	  gold_assert(off % abi_pagesize == 0);
	  ret += fill_size;
	  gold_assert(ret % abi_pagesize == 0);

	  gold_assert((uint64_t) this->filesz_ == this->memsz_);
	  this->memsz_ = this->filesz_ += fill_size;

	  *poff = off;
	}
    }

  return ret;
}

// Set the addresses and file offsets in a list of Output_data
// structures.

uint64_t
Output_segment::set_section_list_addresses(Layout* layout, bool reset,
					   Output_data_list* pdl,
					   uint64_t addr, off_t* poff,
					   unsigned int* pshndx,
					   bool* in_tls)
{
  off_t startoff = *poff;
  // For incremental updates, we may allocate non-fixed sections from
  // free space in the file.  This keeps track of the high-water mark.
  off_t maxoff = startoff;

  off_t off = startoff;
  for (Output_data_list::iterator p = pdl->begin();
       p != pdl->end();
       ++p)
    {
      if (reset)
	(*p)->reset_address_and_file_offset();

      // When doing an incremental update or when using a linker script,
      // the section will most likely already have an address.
      if (!(*p)->is_address_valid())
	{
	  uint64_t align = (*p)->addralign();

	  if ((*p)->is_section_flag_set(elfcpp::SHF_TLS))
	    {
	      // Give the first TLS section the alignment of the
	      // entire TLS segment.  Otherwise the TLS segment as a
	      // whole may be misaligned.
	      if (!*in_tls)
		{
		  Output_segment* tls_segment = layout->tls_segment();
		  gold_assert(tls_segment != NULL);
		  uint64_t segment_align = tls_segment->maximum_alignment();
		  gold_assert(segment_align >= align);
		  align = segment_align;

		  *in_tls = true;
		}
	    }
	  else
	    {
	      // If this is the first section after the TLS segment,
	      // align it to at least the alignment of the TLS
	      // segment, so that the size of the overall TLS segment
	      // is aligned.
	      if (*in_tls)
		{
		  uint64_t segment_align =
		      layout->tls_segment()->maximum_alignment();
		  if (segment_align > align)
		    align = segment_align;

		  *in_tls = false;
		}
	    }

	  if (!parameters->incremental_update())
	    {
	      off = align_address(off, align);
	      (*p)->set_address_and_file_offset(addr + (off - startoff), off);
	    }
	  else
	    {
	      // Incremental update: allocate file space from free list.
	      (*p)->pre_finalize_data_size();
	      off_t current_size = (*p)->current_data_size();
	      off = layout->allocate(current_size, align, startoff);
	      if (off == -1)
		{
		  gold_assert((*p)->output_section() != NULL);
		  gold_fallback(_("out of patch space for section %s; "
				  "relink with --incremental-full"),
				(*p)->output_section()->name());
		}
	      (*p)->set_address_and_file_offset(addr + (off - startoff), off);
	      if ((*p)->data_size() > current_size)
		{
		  gold_assert((*p)->output_section() != NULL);
		  gold_fallback(_("%s: section changed size; "
				  "relink with --incremental-full"),
				(*p)->output_section()->name());
		}
	    }
	}
      else if (parameters->incremental_update())
	{
	  // For incremental updates, use the fixed offset for the
	  // high-water mark computation.
	  off = (*p)->offset();
	}
      else
	{
	  // The script may have inserted a skip forward, but it
	  // better not have moved backward.
	  if ((*p)->address() >= addr + (off - startoff))
	    off += (*p)->address() - (addr + (off - startoff));
	  else
	    {
	      if (!layout->script_options()->saw_sections_clause())
		gold_unreachable();
	      else
		{
		  Output_section* os = (*p)->output_section();

		  // Cast to unsigned long long to avoid format warnings.
		  unsigned long long previous_dot =
		    static_cast<unsigned long long>(addr + (off - startoff));
		  unsigned long long dot =
		    static_cast<unsigned long long>((*p)->address());

		  if (os == NULL)
		    gold_error(_("dot moves backward in linker script "
				 "from 0x%llx to 0x%llx"), previous_dot, dot);
		  else
		    gold_error(_("address of section '%s' moves backward "
				 "from 0x%llx to 0x%llx"),
			       os->name(), previous_dot, dot);
		}
	    }
	  (*p)->set_file_offset(off);
	  (*p)->finalize_data_size();
	}

      if (parameters->incremental_update())
	gold_debug(DEBUG_INCREMENTAL,
		   "set_section_list_addresses: %08lx %08lx %s",
		   static_cast<long>(off),
		   static_cast<long>((*p)->data_size()),
		   ((*p)->output_section() != NULL
		    ? (*p)->output_section()->name() : "(special)"));

      // We want to ignore the size of a SHF_TLS SHT_NOBITS
      // section.  Such a section does not affect the size of a
      // PT_LOAD segment.
      if (!(*p)->is_section_flag_set(elfcpp::SHF_TLS)
	  || !(*p)->is_section_type(elfcpp::SHT_NOBITS))
	off += (*p)->data_size();

      if (off > maxoff)
	maxoff = off;

      if ((*p)->is_section())
	{
	  (*p)->set_out_shndx(*pshndx);
	  ++*pshndx;
	}
    }

  *poff = maxoff;
  return addr + (maxoff - startoff);
}

// For a non-PT_LOAD segment, set the offset from the sections, if
// any.  Add INCREASE to the file size and the memory size.

void
Output_segment::set_offset(unsigned int increase)
{
  gold_assert(this->type_ != elfcpp::PT_LOAD);

  gold_assert(!this->are_addresses_set_);

  // A non-load section only uses output_lists_[0].

  Output_data_list* pdl = &this->output_lists_[0];

  if (pdl->empty())
    {
      gold_assert(increase == 0);
      this->vaddr_ = 0;
      this->paddr_ = 0;
      this->are_addresses_set_ = true;
      this->memsz_ = 0;
      this->min_p_align_ = 0;
      this->offset_ = 0;
      this->filesz_ = 0;
      return;
    }

  // Find the first and last section by address.
  const Output_data* first = NULL;
  const Output_data* last_data = NULL;
  const Output_data* last_bss = NULL;
  for (Output_data_list::const_iterator p = pdl->begin();
       p != pdl->end();
       ++p)
    {
      if (first == NULL
	  || (*p)->address() < first->address()
	  || ((*p)->address() == first->address()
	      && (*p)->data_size() < first->data_size()))
	first = *p;
      const Output_data** plast;
      if ((*p)->is_section()
	  && (*p)->output_section()->type() == elfcpp::SHT_NOBITS)
	plast = &last_bss;
      else
	plast = &last_data;
      if (*plast == NULL
	  || (*p)->address() > (*plast)->address()
	  || ((*p)->address() == (*plast)->address()
	      && (*p)->data_size() > (*plast)->data_size()))
	*plast = *p;
    }

  this->vaddr_ = first->address();
  this->paddr_ = (first->has_load_address()
		  ? first->load_address()
		  : this->vaddr_);
  this->are_addresses_set_ = true;
  this->offset_ = first->offset();

  if (last_data == NULL)
    this->filesz_ = 0;
  else
    this->filesz_ = (last_data->address()
		     + last_data->data_size()
		     - this->vaddr_);

  const Output_data* last = last_bss != NULL ? last_bss : last_data;
  this->memsz_ = (last->address()
		  + last->data_size()
		  - this->vaddr_);

  this->filesz_ += increase;
  this->memsz_ += increase;

  // If this is a RELRO segment, verify that the segment ends at a
  // page boundary.
  if (this->type_ == elfcpp::PT_GNU_RELRO)
    {
      uint64_t page_align = parameters->target().abi_pagesize();
      uint64_t segment_end = this->vaddr_ + this->memsz_;
      if (parameters->incremental_update())
	{
	  // The INCREASE_RELRO calculation is bypassed for an incremental
	  // update, so we need to adjust the segment size manually here.
	  segment_end = align_address(segment_end, page_align);
	  this->memsz_ = segment_end - this->vaddr_;
	}
      else
	gold_assert(segment_end == align_address(segment_end, page_align));
    }

  // If this is a TLS segment, align the memory size.  The code in
  // set_section_list ensures that the section after the TLS segment
  // is aligned to give us room.
  if (this->type_ == elfcpp::PT_TLS)
    {
      uint64_t segment_align = this->maximum_alignment();
      gold_assert(this->vaddr_ == align_address(this->vaddr_, segment_align));
      this->memsz_ = align_address(this->memsz_, segment_align);
    }
}

// Set the TLS offsets of the sections in the PT_TLS segment.

void
Output_segment::set_tls_offsets()
{
  gold_assert(this->type_ == elfcpp::PT_TLS);

  for (Output_data_list::iterator p = this->output_lists_[0].begin();
       p != this->output_lists_[0].end();
       ++p)
    (*p)->set_tls_offset(this->vaddr_);
}

// Return the first section.

Output_section*
Output_segment::first_section() const
{
  for (int i = 0; i < static_cast<int>(ORDER_MAX); ++i)
    {
      const Output_data_list* pdl = &this->output_lists_[i];
      for (Output_data_list::const_iterator p = pdl->begin();
	   p != pdl->end();
	   ++p)
	{
	  if ((*p)->is_section())
	    return (*p)->output_section();
	}
    }
  gold_unreachable();
}

// Return the number of Output_sections in an Output_segment.

unsigned int
Output_segment::output_section_count() const
{
  unsigned int ret = 0;
  for (int i = 0; i < static_cast<int>(ORDER_MAX); ++i)
    ret += this->output_section_count_list(&this->output_lists_[i]);
  return ret;
}

// Return the number of Output_sections in an Output_data_list.

unsigned int
Output_segment::output_section_count_list(const Output_data_list* pdl) const
{
  unsigned int count = 0;
  for (Output_data_list::const_iterator p = pdl->begin();
       p != pdl->end();
       ++p)
    {
      if ((*p)->is_section())
	++count;
    }
  return count;
}

// Return the section attached to the list segment with the lowest
// load address.  This is used when handling a PHDRS clause in a
// linker script.

Output_section*
Output_segment::section_with_lowest_load_address() const
{
  Output_section* found = NULL;
  uint64_t found_lma = 0;
  for (int i = 0; i < static_cast<int>(ORDER_MAX); ++i)
    this->lowest_load_address_in_list(&this->output_lists_[i], &found,
				      &found_lma);
  return found;
}

// Look through a list for a section with a lower load address.

void
Output_segment::lowest_load_address_in_list(const Output_data_list* pdl,
					    Output_section** found,
					    uint64_t* found_lma) const
{
  for (Output_data_list::const_iterator p = pdl->begin();
       p != pdl->end();
       ++p)
    {
      if (!(*p)->is_section())
	continue;
      Output_section* os = static_cast<Output_section*>(*p);
      uint64_t lma = (os->has_load_address()
		      ? os->load_address()
		      : os->address());
      if (*found == NULL || lma < *found_lma)
	{
	  *found = os;
	  *found_lma = lma;
	}
    }
}

// Write the segment data into *OPHDR.

template<int size, bool big_endian>
void
Output_segment::write_header(elfcpp::Phdr_write<size, big_endian>* ophdr)
{
  ophdr->put_p_type(this->type_);
  ophdr->put_p_offset(this->offset_);
  ophdr->put_p_vaddr(this->vaddr_);
  ophdr->put_p_paddr(this->paddr_);
  ophdr->put_p_filesz(this->filesz_);
  ophdr->put_p_memsz(this->memsz_);
  ophdr->put_p_flags(this->flags_);
  ophdr->put_p_align(std::max(this->min_p_align_, this->maximum_alignment()));
}

// Write the section headers into V.

template<int size, bool big_endian>
unsigned char*
Output_segment::write_section_headers(const Layout* layout,
				      const Stringpool* secnamepool,
				      unsigned char* v,
				      unsigned int* pshndx) const
{
  // Every section that is attached to a segment must be attached to a
  // PT_LOAD segment, so we only write out section headers for PT_LOAD
  // segments.
  if (this->type_ != elfcpp::PT_LOAD)
    return v;

  for (int i = 0; i < static_cast<int>(ORDER_MAX); ++i)
    {
      const Output_data_list* pdl = &this->output_lists_[i];
      v = this->write_section_headers_list<size, big_endian>(layout,
							     secnamepool,
							     pdl,
							     v, pshndx);
    }

  return v;
}

template<int size, bool big_endian>
unsigned char*
Output_segment::write_section_headers_list(const Layout* layout,
					   const Stringpool* secnamepool,
					   const Output_data_list* pdl,
					   unsigned char* v,
					   unsigned int* pshndx) const
{
  const int shdr_size = elfcpp::Elf_sizes<size>::shdr_size;
  for (Output_data_list::const_iterator p = pdl->begin();
       p != pdl->end();
       ++p)
    {
      if ((*p)->is_section())
	{
	  const Output_section* ps = static_cast<const Output_section*>(*p);
	  gold_assert(*pshndx == ps->out_shndx());
	  elfcpp::Shdr_write<size, big_endian> oshdr(v);
	  ps->write_header(layout, secnamepool, &oshdr);
	  v += shdr_size;
	  ++*pshndx;
	}
    }
  return v;
}

// Print the output sections to the map file.

void
Output_segment::print_sections_to_mapfile(Mapfile* mapfile) const
{
  if (this->type() != elfcpp::PT_LOAD)
    return;
  for (int i = 0; i < static_cast<int>(ORDER_MAX); ++i)
    this->print_section_list_to_mapfile(mapfile, &this->output_lists_[i]);
}

// Print an output section list to the map file.

void
Output_segment::print_section_list_to_mapfile(Mapfile* mapfile,
					      const Output_data_list* pdl) const
{
  for (Output_data_list::const_iterator p = pdl->begin();
       p != pdl->end();
       ++p)
    (*p)->print_to_mapfile(mapfile);
}

// Output_file methods.

Output_file::Output_file(const char* name)
  : name_(name),
    o_(-1),
    file_size_(0),
    base_(NULL),
    map_is_anonymous_(false),
    map_is_allocated_(false),
    is_temporary_(false)
{
}

// Try to open an existing file.  Returns false if the file doesn't
// exist, has a size of 0 or can't be mmapped.  If BASE_NAME is not
// NULL, open that file as the base for incremental linking, and
// copy its contents to the new output file.  This routine can
// be called for incremental updates, in which case WRITABLE should
// be true, or by the incremental-dump utility, in which case
// WRITABLE should be false.

bool
Output_file::open_base_file(const char* base_name, bool writable)
{
  // The name "-" means "stdout".
  if (strcmp(this->name_, "-") == 0)
    return false;

  bool use_base_file = base_name != NULL;
  if (!use_base_file)
    base_name = this->name_;
  else if (strcmp(base_name, this->name_) == 0)
    gold_fatal(_("%s: incremental base and output file name are the same"),
	       base_name);

  // Don't bother opening files with a size of zero.
  struct stat s;
  if (::stat(base_name, &s) != 0)
    {
      gold_info(_("%s: stat: %s"), base_name, strerror(errno));
      return false;
    }
  if (s.st_size == 0)
    {
      gold_info(_("%s: incremental base file is empty"), base_name);
      return false;
    }

  // If we're using a base file, we want to open it read-only.
  if (use_base_file)
    writable = false;

  int oflags = writable ? O_RDWR : O_RDONLY;
  int o = open_descriptor(-1, base_name, oflags, 0);
  if (o < 0)
    {
      gold_info(_("%s: open: %s"), base_name, strerror(errno));
      return false;
    }

  // If the base file and the output file are different, open a
  // new output file and read the contents from the base file into
  // the newly-mapped region.
  if (use_base_file)
    {
      this->open(s.st_size);
      ssize_t bytes_to_read = s.st_size;
      unsigned char* p = this->base_;
      while (bytes_to_read > 0)
	{
	  ssize_t len = ::read(o, p, bytes_to_read);
	  if (len < 0)
	    {
	      gold_info(_("%s: read failed: %s"), base_name, strerror(errno));
	      return false;
	    }
	  if (len == 0)
	    {
	      gold_info(_("%s: file too short: read only %lld of %lld bytes"),
			base_name,
			static_cast<long long>(s.st_size - bytes_to_read),
			static_cast<long long>(s.st_size));
	      return false;
	    }
	  p += len;
	  bytes_to_read -= len;
	}
      ::close(o);
      return true;
    }

  this->o_ = o;
  this->file_size_ = s.st_size;

  if (!this->map_no_anonymous(writable))
    {
      release_descriptor(o, true);
      this->o_ = -1;
      this->file_size_ = 0;
      return false;
    }

  return true;
}

// Open the output file.

void
Output_file::open(off_t file_size)
{
  this->file_size_ = file_size;

  // Unlink the file first; otherwise the open() may fail if the file
  // is busy (e.g. it's an executable that's currently being executed).
  //
  // However, the linker may be part of a system where a zero-length
  // file is created for it to write to, with tight permissions (gcc
  // 2.95 did something like this).  Unlinking the file would work
  // around those permission controls, so we only unlink if the file
  // has a non-zero size.  We also unlink only regular files to avoid
  // trouble with directories/etc.
  //
  // If we fail, continue; this command is merely a best-effort attempt
  // to improve the odds for open().

  // We let the name "-" mean "stdout"
  if (!this->is_temporary_)
    {
      if (strcmp(this->name_, "-") == 0)
	this->o_ = STDOUT_FILENO;
      else
	{
	  struct stat s;
	  if (::stat(this->name_, &s) == 0
	      && (S_ISREG (s.st_mode) || S_ISLNK (s.st_mode)))
	    {
	      if (s.st_size != 0)
		::unlink(this->name_);
	      else if (!parameters->options().relocatable())
		{
		  // If we don't unlink the existing file, add execute
		  // permission where read permissions already exist
		  // and where the umask permits.
		  int mask = ::umask(0);
		  ::umask(mask);
		  s.st_mode |= (s.st_mode & 0444) >> 2;
		  ::chmod(this->name_, s.st_mode & ~mask);
		}
	    }

	  int mode = parameters->options().relocatable() ? 0666 : 0777;
	  int o = open_descriptor(-1, this->name_, O_RDWR | O_CREAT | O_TRUNC,
				  mode);
	  if (o < 0)
	    gold_fatal(_("%s: open: %s"), this->name_, strerror(errno));
	  this->o_ = o;
	}
    }

  this->map();
}

// Resize the output file.

void
Output_file::resize(off_t file_size)
{
  // If the mmap is mapping an anonymous memory buffer, this is easy:
  // just mremap to the new size.  If it's mapping to a file, we want
  // to unmap to flush to the file, then remap after growing the file.
  if (this->map_is_anonymous_)
    {
      void* base;
      if (!this->map_is_allocated_)
	{
	  base = ::mremap(this->base_, this->file_size_, file_size,
			  MREMAP_MAYMOVE);
	  if (base == MAP_FAILED)
	    gold_fatal(_("%s: mremap: %s"), this->name_, strerror(errno));
	}
      else
	{
	  base = realloc(this->base_, file_size);
	  if (base == NULL)
	    gold_nomem();
	  if (file_size > this->file_size_)
	    memset(static_cast<char*>(base) + this->file_size_, 0,
		   file_size - this->file_size_);
	}
      this->base_ = static_cast<unsigned char*>(base);
      this->file_size_ = file_size;
    }
  else
    {
      this->unmap();
      this->file_size_ = file_size;
      if (!this->map_no_anonymous(true))
	gold_fatal(_("%s: mmap: %s"), this->name_, strerror(errno));
    }
}

// Map an anonymous block of memory which will later be written to the
// file.  Return whether the map succeeded.

bool
Output_file::map_anonymous()
{
  void* base = ::mmap(NULL, this->file_size_, PROT_READ | PROT_WRITE,
		      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (base == MAP_FAILED)
    {
      base = malloc(this->file_size_);
      if (base == NULL)
	return false;
      memset(base, 0, this->file_size_);
      this->map_is_allocated_ = true;
    }
  this->base_ = static_cast<unsigned char*>(base);
  this->map_is_anonymous_ = true;
  return true;
}

// Map the file into memory.  Return whether the mapping succeeded.
// If WRITABLE is true, map with write access.

bool
Output_file::map_no_anonymous(bool writable)
{
  const int o = this->o_;

  // If the output file is not a regular file, don't try to mmap it;
  // instead, we'll mmap a block of memory (an anonymous buffer), and
  // then later write the buffer to the file.
  void* base;
  struct stat statbuf;
  if (o == STDOUT_FILENO || o == STDERR_FILENO
      || ::fstat(o, &statbuf) != 0
      || !S_ISREG(statbuf.st_mode)
      || this->is_temporary_)
    return false;

  // Ensure that we have disk space available for the file.  If we
  // don't do this, it is possible that we will call munmap, close,
  // and exit with dirty buffers still in the cache with no assigned
  // disk blocks.  If the disk is out of space at that point, the
  // output file will wind up incomplete, but we will have already
  // exited.  The alternative to fallocate would be to use fdatasync,
  // but that would be a more significant performance hit.
  if (writable)
    {
      int err = gold_fallocate(o, 0, this->file_size_);
      if (err != 0)
       gold_fatal(_("%s: %s"), this->name_, strerror(err));
    }

  // Map the file into memory.
  int prot = PROT_READ;
  if (writable)
    prot |= PROT_WRITE;
  base = ::mmap(NULL, this->file_size_, prot, MAP_SHARED, o, 0);

  // The mmap call might fail because of file system issues: the file
  // system might not support mmap at all, or it might not support
  // mmap with PROT_WRITE.
  if (base == MAP_FAILED)
    return false;

  this->map_is_anonymous_ = false;
  this->base_ = static_cast<unsigned char*>(base);
  return true;
}

// Map the file into memory.

void
Output_file::map()
{
  if (parameters->options().mmap_output_file()
      && this->map_no_anonymous(true))
    return;

  // The mmap call might fail because of file system issues: the file
  // system might not support mmap at all, or it might not support
  // mmap with PROT_WRITE.  I'm not sure which errno values we will
  // see in all cases, so if the mmap fails for any reason and we
  // don't care about file contents, try for an anonymous map.
  if (this->map_anonymous())
    return;

  gold_fatal(_("%s: mmap: failed to allocate %lu bytes for output file: %s"),
	     this->name_, static_cast<unsigned long>(this->file_size_),
	     strerror(errno));
}

// Unmap the file from memory.

void
Output_file::unmap()
{
  if (this->map_is_anonymous_)
    {
      // We've already written out the data, so there is no reason to
      // waste time unmapping or freeing the memory.
    }
  else
    {
      if (::munmap(this->base_, this->file_size_) < 0)
	gold_error(_("%s: munmap: %s"), this->name_, strerror(errno));
    }
  this->base_ = NULL;
}

// Close the output file.

void
Output_file::close()
{
  // If the map isn't file-backed, we need to write it now.
  if (this->map_is_anonymous_ && !this->is_temporary_)
    {
      size_t bytes_to_write = this->file_size_;
      size_t offset = 0;
      while (bytes_to_write > 0)
	{
	  ssize_t bytes_written = ::write(this->o_, this->base_ + offset,
					  bytes_to_write);
	  if (bytes_written == 0)
	    gold_error(_("%s: write: unexpected 0 return-value"), this->name_);
	  else if (bytes_written < 0)
	    gold_error(_("%s: write: %s"), this->name_, strerror(errno));
	  else
	    {
	      bytes_to_write -= bytes_written;
	      offset += bytes_written;
	    }
	}
    }
  this->unmap();

  // We don't close stdout or stderr
  if (this->o_ != STDOUT_FILENO
      && this->o_ != STDERR_FILENO
      && !this->is_temporary_)
    if (::close(this->o_) < 0)
      gold_error(_("%s: close: %s"), this->name_, strerror(errno));
  this->o_ = -1;
}

// Instantiate the templates we need.  We could use the configure
// script to restrict this to only the ones for implemented targets.

#ifdef HAVE_TARGET_32_LITTLE
template
off_t
Output_section::add_input_section<32, false>(
    Layout* layout,
    Sized_relobj_file<32, false>* object,
    unsigned int shndx,
    const char* secname,
    const elfcpp::Shdr<32, false>& shdr,
    unsigned int reloc_shndx,
    bool have_sections_script);
#endif

#ifdef HAVE_TARGET_32_BIG
template
off_t
Output_section::add_input_section<32, true>(
    Layout* layout,
    Sized_relobj_file<32, true>* object,
    unsigned int shndx,
    const char* secname,
    const elfcpp::Shdr<32, true>& shdr,
    unsigned int reloc_shndx,
    bool have_sections_script);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
off_t
Output_section::add_input_section<64, false>(
    Layout* layout,
    Sized_relobj_file<64, false>* object,
    unsigned int shndx,
    const char* secname,
    const elfcpp::Shdr<64, false>& shdr,
    unsigned int reloc_shndx,
    bool have_sections_script);
#endif

#ifdef HAVE_TARGET_64_BIG
template
off_t
Output_section::add_input_section<64, true>(
    Layout* layout,
    Sized_relobj_file<64, true>* object,
    unsigned int shndx,
    const char* secname,
    const elfcpp::Shdr<64, true>& shdr,
    unsigned int reloc_shndx,
    bool have_sections_script);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
class Output_reloc<elfcpp::SHT_REL, false, 32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Output_reloc<elfcpp::SHT_REL, false, 32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Output_reloc<elfcpp::SHT_REL, false, 64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Output_reloc<elfcpp::SHT_REL, false, 64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
class Output_reloc<elfcpp::SHT_REL, true, 32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Output_reloc<elfcpp::SHT_REL, true, 32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Output_reloc<elfcpp::SHT_REL, true, 64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Output_reloc<elfcpp::SHT_REL, true, 64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
class Output_reloc<elfcpp::SHT_RELA, false, 32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Output_reloc<elfcpp::SHT_RELA, false, 32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Output_reloc<elfcpp::SHT_RELA, false, 64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Output_reloc<elfcpp::SHT_RELA, false, 64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
class Output_reloc<elfcpp::SHT_RELA, true, 32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Output_reloc<elfcpp::SHT_RELA, true, 32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Output_reloc<elfcpp::SHT_RELA, true, 64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Output_reloc<elfcpp::SHT_RELA, true, 64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
class Output_data_reloc<elfcpp::SHT_REL, false, 32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Output_data_reloc<elfcpp::SHT_REL, false, 32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Output_data_reloc<elfcpp::SHT_REL, false, 64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Output_data_reloc<elfcpp::SHT_REL, false, 64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
class Output_data_reloc<elfcpp::SHT_REL, true, 32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Output_data_reloc<elfcpp::SHT_REL, true, 32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Output_data_reloc<elfcpp::SHT_REL, true, 64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Output_data_reloc<elfcpp::SHT_REL, true, 64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
class Output_data_reloc<elfcpp::SHT_RELA, false, 32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Output_data_reloc<elfcpp::SHT_RELA, false, 32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Output_data_reloc<elfcpp::SHT_RELA, false, 64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Output_data_reloc<elfcpp::SHT_RELA, false, 64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
class Output_data_reloc<elfcpp::SHT_RELA, true, 32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Output_data_reloc<elfcpp::SHT_RELA, true, 32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Output_data_reloc<elfcpp::SHT_RELA, true, 64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Output_data_reloc<elfcpp::SHT_RELA, true, 64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
class Output_relocatable_relocs<elfcpp::SHT_REL, 32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Output_relocatable_relocs<elfcpp::SHT_REL, 32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Output_relocatable_relocs<elfcpp::SHT_REL, 64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Output_relocatable_relocs<elfcpp::SHT_REL, 64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
class Output_relocatable_relocs<elfcpp::SHT_RELA, 32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Output_relocatable_relocs<elfcpp::SHT_RELA, 32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Output_relocatable_relocs<elfcpp::SHT_RELA, 64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Output_relocatable_relocs<elfcpp::SHT_RELA, 64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
class Output_data_group<32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Output_data_group<32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Output_data_group<64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Output_data_group<64, true>;
#endif

template
class Output_data_got<32, false>;

template
class Output_data_got<32, true>;

template
class Output_data_got<64, false>;

template
class Output_data_got<64, true>;

} // End namespace gold.
@


1.184
log
@gold/
	* output.cc (Output_segment::set_section_addresses): Take new
	Target* argument.  If target->isolate_execinstr() and the segment
	is executable and starts at a target->abi_pagesize() boundary,
	pad its end out to a target->abi_pagesize() boundary with code fill.
	* output.h (Output_segment::set_section_addresses): Update decl.
	* layout.h (Layout::check_output_data_for_reset_values): Take new
	argument RELAX_OUTPUTS.
	(Layout): New member relax_output_list_.
	(Layout::add_relax_output): New method.
	* layout.cc (Layout::Layout): Update constructor.
	(Layout::reset_relax_output): New method.
	(Layout::clean_up_after_relaxation): Call it.
	(Layout::prepare_for_relaxation): Update caller.
	(Layout::set_segment_offsets): Update callers of set_section_addresses.
	Call reset_relax_output before re-processing segments for
	isolate_execinstr case.
	(Layout::write_data): Handle relax_output_list_.
	(Layout::Relaxation_debug_check::check_output_data_for_reset_values):
	Take new argument RELAX_OUTPUTS.  Assert it's an empty collection.
@
text
@d438 1
a438 1
Output_file_header::Output_file_header(const Target* target,
d580 1
a580 1
  parameters->target().adjust_elf_header(view, ehdr_size);
@


1.184.2.1
log
@gold/
	* target.h (Target::adjust_elf_header, Target::do_adjust_elf_header):
	Remove const from declaration.
	* target.cc (Sized_target::do_adjust_elf_header): Update definition.
	* sparc.cc (Target_sparc::do_adjust_elf_header): Likewise.
	* output.h (Output_file_header): Remove const from member target_
	and corresponding constructor argument.
	* output.cc (Output_file_header::Output_file_header): Update prototype.
	(Output_file_header::do_sized_write): Use this->target_ in place
	of parameters()->target().
@
text
@d438 1
a438 1
Output_file_header::Output_file_header(Target* target,
d580 1
a580 1
  this->target_->adjust_elf_header(view, ehdr_size);
@


1.183
log
@2013-05-30  Alexander Ivchenko  <alexander.ivchenko@@intel.com>
	    Sriraman Tallam  <tmsriram@@google.com>

	* options.h (sort_section): New option.
	* output.h (Input_section_sort_section_prefix_special_ordering_compare):
	Rename from Input_section_sort_section_name_special_ordering_compare.
	(Input_section_sort_section_name_compare): New struct.
	* output.cc (Output_section::Input_section_sort_section_name_compare::
	operator()): New function.
	(Output_section::sort_attached_input_sections): Use new sort function
	for .text if --sort-section=name is specified.
	* layout.cc (Layout::make_output_section):
	Add sorting by name when --sort-section=name is specified.
	* testsuite/Makefile.am (text_section_grouping): Test option
	--sort-section=name.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/section_sorting_name.cc: New file.
	* testsuite/section_sorting_name.sh: New file.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
d593 1
a593 1
                                     && !parameters->options().shared());
d772 1
a772 1
              && local_sym_index != INVALID_CODE);
d798 1
a798 1
              && local_sym_index != INVALID_CODE);
d957 1
a957 1
        const unsigned int lsi = this->local_sym_index_;
d961 4
a964 4
        if (!this->is_section_symbol_)
          relobj->set_needs_output_dynsym_entry(lsi);
        else
          relobj->output_section(lsi)->set_needs_dynsym_index();
d1013 1
a1013 1
        const unsigned int lsi = this->local_sym_index_;
d1017 16
a1032 16
        if (!this->is_section_symbol_)
          {
            if (dynamic)
              index = relobj->dynsym_index(lsi);
            else
              index = relobj->symtab_index(lsi);
          }
        else
          {
            Output_section* os = relobj->output_section(lsi);
            gold_assert(os != NULL);
            if (dynamic)
              index = os->dynsym_index();
            else
              index = os->symtab_index();
          }
d1049 1
a1049 1
              && this->local_sym_index_ != SECTION_CODE
d1051 1
a1051 1
              && this->local_sym_index_ != INVALID_CODE
d1053 1
a1053 1
              && this->is_section_symbol_);
d1144 1
a1144 1
              && this->local_sym_index_ != INVALID_CODE
d1146 1
a1146 1
              && !this->is_section_symbol_);
d1428 1
a1428 1
        return;
d1435 1
a1435 1
        const unsigned int lsi = this->local_sym_index_;
d2249 1
a2249 1
        Output_relaxed_input_section* relaxed_section =
d2251 1
a2251 1
        mapfile->print_input_section(relaxed_section->relobj(),
d2432 1
a2432 1
        gold_fallback(_("out of patch space in section %s; "
d2453 1
a2453 1
          || layout->is_section_ordering_specified()))
d2470 1
a2470 1
        this->fills_.push_back(Fill(offset_in_section, fill_len));
d2472 5
a2476 5
        {
          std::string fill_data(parameters->target().code_fill(fill_len));
          Output_data_const* odc = new Output_data_const(fill_data, 1);
          this->input_sections_.push_back(Input_section(odc));
        }
d2499 3
a2501 3
        {
          unsigned int section_order_index =
            layout->find_section_order_index(std::string(secname));
d2503 5
a2507 5
            {
              isecn.set_section_order_index(section_order_index);
              this->set_input_section_order_specified();
            }
        }
d2576 1
a2576 1
        layout->find_section_order_index(name);
d2578 4
a2581 4
        {
          inp.set_section_order_index(section_order_index);
          this->set_input_section_order_specified();
        }
d3130 1
a3130 1
          && this->free_space_fill_->minimum_hole_size() > extra)
d3218 1
a3218 1
        && must_sort_attached_input_sections)
d3326 4
a3329 4
        if (this_secn_index < s_secn_index)
          return 1;
        else if (this_secn_index > s_secn_index)
          return -1;
d3571 1
a3571 1
        {
d3574 1
a3574 1
		         : p->relaxed_input_section()->relobj());
d3582 3
a3584 3
            {
              p->set_section_order_index(section_order_index);
              this->set_input_section_order_specified();
d3586 1
a3586 1
        }
d3616 1
a3616 1
                            this->must_sort_attached_input_sections()));
d3622 4
a3625 4
          || this->type() == elfcpp::SHT_INIT_ARRAY
          || this->type() == elfcpp::SHT_FINI_ARRAY)
        std::sort(sort_list.begin(), sort_list.end(),
	          Input_section_sort_init_fini_compare());
d3633 2
a3634 2
        std::sort(sort_list.begin(), sort_list.end(),
	          Input_section_sort_compare());
d3640 1
a3640 1
	        Input_section_sort_section_order_index_compare());
d4302 3
a4304 2
Output_segment::set_section_addresses(Layout* layout, bool reset,
                                      uint64_t addr,
d4443 35
d4486 1
a4486 1
                                           Output_data_list* pdl,
d4489 1
a4489 1
                                           bool* in_tls)
d4508 30
a4537 1
          uint64_t align = (*p)->addralign();
d4539 3
a4541 32
          if ((*p)->is_section_flag_set(elfcpp::SHF_TLS))
            {
              // Give the first TLS section the alignment of the
              // entire TLS segment.  Otherwise the TLS segment as a
              // whole may be misaligned.
              if (!*in_tls)
                {
                  Output_segment* tls_segment = layout->tls_segment();
                  gold_assert(tls_segment != NULL);
                  uint64_t segment_align = tls_segment->maximum_alignment();
                  gold_assert(segment_align >= align);
                  align = segment_align;

                  *in_tls = true;
                }
            }
          else
            {
              // If this is the first section after the TLS segment,
              // align it to at least the alignment of the TLS
              // segment, so that the size of the overall TLS segment
              // is aligned.
              if (*in_tls)
                {
                  uint64_t segment_align =
                      layout->tls_segment()->maximum_alignment();
                  if (segment_align > align)
                    align = segment_align;

                  *in_tls = false;
                }
            }
d4555 1
a4555 1
	        {
d4560 1
a4560 1
	        }
d4572 5
a4576 5
        {
          // For incremental updates, use the fixed offset for the
          // high-water mark computation.
          off = (*p)->offset();
        }
d4626 1
a4626 1
        maxoff = off;
d5223 2
a5224 2
             this->name_, static_cast<unsigned long>(this->file_size_),
             strerror(errno));
d5256 13
a5268 13
        {
          ssize_t bytes_written = ::write(this->o_, this->base_ + offset,
                                          bytes_to_write);
          if (bytes_written == 0)
            gold_error(_("%s: write: unexpected 0 return-value"), this->name_);
          else if (bytes_written < 0)
            gold_error(_("%s: write: %s"), this->name_, strerror(errno));
          else
            {
              bytes_to_write -= bytes_written;
              offset += bytes_written;
            }
        }
@


1.182
log
@2013-04-29  Alexander Ivchenko  <alexander.ivchenko@@intel.com>

gold/
	* output.cc (Output_section::add_merge_input_section): Allow
	to merge sections if the alignment is more than character size.
	* merge.h (Output_merge_string::Output_merge_string): Remove
	assert.
	* merge.cc (Output_merge_string<Char_type>::do_add_input_section): Count
	only not-null strings. Check the alignment of strings.
	* stringpool.h
	(Stringpool_template<Stringpool_char>::Stringpool_template): Add
	alignment as the argument.
	(Stringpool_template<Stringpool_char>::addralign_): New class member.
	* stringpool.cc (Stringpool_template<Stringpool_char>::new_key_offset):
	Align non-zero length strings according to the addralign_.
	(Stringpool_template<Stringpool_char>::set_string_offsets):
	Updating offsets according to the given alignment.
	* testsuite/Makefile.am (text_section_grouping): Test if string
	literals are getting merged.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/merge_string_literals_1.c: New file.
	* testsuite/merge_string_literals_2.c: Ditto.
	* testsuite/merge_string_literals.sh: Ditto.
@
text
@d3496 1
d3498 1
a3498 1
Output_section::Input_section_sort_section_name_special_ordering_compare
d3512 1
a3512 1
 
d3527 29
a3555 1
  return s1.index() < s2.index();  
d3626 3
d3630 2
a3631 2
        std::sort(sort_list.begin(), sort_list.end(),
	          Input_section_sort_section_name_special_ordering_compare());
@


1.181
log
@Default text reordering fix with a flag to turn it off.

2013-01-24  Sriraman Tallam  <tmsriram@@google.com>

	* layout.cc (Layout::layout): Check for option text_reorder.
	(Layout::make_output_section): Ditto.
	* options.h (text_reorder): New option.
	* output.cc (Input_section_sort_compare): Remove special ordering
	of section names.
	(Output_section::
	 Input_section_sort_section_name_special_ordering_compare::
	 operator()): New function.
	(Output_section::sort_attached_input_sections): Use new sort function
	for .text.
	* output.h (Input_section_sort_section_name_special_ordering_compare):
	New struct.
	* testsuite/Makefile.am (text_section_grouping): Test option
	--no-text-reorder
	* testsuite/Makefile.in: Regenerate.
	* testsuite/text_section_grouping.sh: Check order of functions without
	default text reordering.
@
text
@a2637 5
  // We only merge strings if the alignment is not more than the
  // character size.  This could be handled, but it's unusual.
  if (is_string && addralign > entsize)
    return false;

@


1.180
log
@gold/
	PR gold/14993
	* output.cc (Output_section::add_input_section): For incremental
	updates, don't track input sections that are allocated from patch
	space.
@
text
@a3391 13
  // Some input section names have special ordering requirements.
  int o1 = Layout::special_ordering_of_input_section(s1.section_name().c_str());
  int o2 = Layout::special_ordering_of_input_section(s2.section_name().c_str());
  if (o1 != o2)
    {
      if (o1 < 0)
	return false;
      else if (o2 < 0)
	return true;
      else
	return o1 < o2;
    }

d3498 36
d3602 3
@


1.179
log
@	* layout.cc (Layout::special_ordering_of_input_section): New
	function.
	(Layout::layout): If input section requires special ordering, must
	sort input sections.
	(Layout::make_output_section): May sort .text input sections.
	(Layout::is_section_name_prefix_grouped): Remove.
	* layout.h (class Layout): Declare
	special_ordering_of_input_section.  Don't declare
	is_section_name_prefix_grouped.
	* output.cc (Output_section::add_input_section): Revert last
	change.
	(Output_section::Input_section_sort::match_file_name): Don't crash
	if called on output section data.
	(Output_section::Input_section_sort_compare): Sort based on
	special ordering.
	(Output_section::Input_section_sort_section_order_index_compare):
	Revert last patch.
	(Output_section::sort_attached_input_sections): Likewise.
@
text
@d2425 1
a2425 1
  off_t aligned_offset_in_section;
d2435 1
a2435 9
      aligned_offset_in_section = offset_in_section;
    }
  else
    {
      offset_in_section = this->current_data_size_for_child();
      aligned_offset_in_section = align_address(offset_in_section,
						addralign);
      this->set_current_data_size_for_child(aligned_offset_in_section
					    + input_section_size);
d2437 6
a2507 8
      if (this->has_fixed_layout())
	{
	  // For incremental updates, finalize the address and offset now.
	  uint64_t addr = this->address();
	  isecn.set_address_and_file_offset(addr + aligned_offset_in_section,
					    aligned_offset_in_section,
					    this->offset());
	}
@


1.178
log
@Group text sections with prefixes .text.unlikely,.text.hot and .text.startup
by default.


2012-12-18  Sriraman Tallam  <tmsriram@@google.com>

	* layout.cc (Layout::is_section_name_prefix_grouped): New function.
	* layout.h (Layout::is_section_name_prefix_grouped): New function.
	* output.cc (Output_section::add_input_section): Check if section
	name contains special prefix.  Keep input sections to sort such
	sections.
	(Output_section::Input_section_sort_section_order_index_compare
	 ::operator()): Group sections according to prefixes.
	* (Output_section::sort_attached_input_sections): Add condition
	to Input_section_entry constructor call.
	* testsuite/Makefile.am (text_section_grouping): New test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/text_section_grouping.cc: New file.
	* testsuite/text_section_grouping.sh: New file.
@
text
@a2480 13
  // The GNU linker groups input sections whose names match .text.unlikely.*.
  // This is used to get better code layout.  We are compatible.
  // Additionally, it could also be beneficial to group .text.hot.*,
  // .text.startup.* prefixed input sections.  Function
  // "is_section_name_prefix_grouped" in layout.cc determines the input
  // section prefixes that must be grouped.
  if (!have_sections_script
      && !parameters->options().relocatable()
      && !this->input_section_order_specified()
      && !this->must_sort_attached_input_sections()
      && layout->is_section_name_prefix_grouped(secname))
    this->set_input_section_order_specified();

d2494 1
a2494 2
      || layout->is_section_ordering_specified()
      || this->input_section_order_specified())
d3326 5
a3330 1
  { return Layout::match_file_name(this->input_section_.relobj(), file_name); }
d3402 13
d3504 1
a3504 3
// that match some pattern.  This function is also used to group text according
// to their prefix.  The following prefixes are recognized: ".text.startup",
// ".text.hot", and ".text.unlikely".
d3514 3
a3516 3
  // If section ordering is specified, it takes precedence.
  if (s1_secn_index != s2_secn_index)
    return s1_secn_index < s2_secn_index;
d3518 1
a3518 49
  // Sort all the sections with no names to the end.
  if (!s1.section_has_name() || !s2.section_has_name())
    {
      if (s1.section_has_name())
	return true;
      if (s2.section_has_name())
	return false;
      return s1.index() < s2.index();
    }

  // If it is a text section use the following order:
  // .text.unlikely, .text.startup, .text.hot. The prefixes
  // must match those in function is_section_name_prefix_grouped
  // in layout.cc
  const char* section_prefix [] = 
  {
    ".text.unlikely",
    ".text.startup",
    ".text.hot"
  };

  const unsigned int num_prefixes
    = sizeof(section_prefix) / sizeof(const char*);

  unsigned int s1_group_index = num_prefixes;
  unsigned int s2_group_index = num_prefixes;

  unsigned int flag_done = 0;
  for (unsigned int i = 0; i < num_prefixes && flag_done < 2; i++)
    {
      if (s1_group_index == num_prefixes
	  && is_prefix_of(section_prefix[i], s1.section_name().c_str()))
	{
          s1_group_index = i;
	  flag_done++;
	}

      if (s2_group_index == num_prefixes
	  && is_prefix_of(section_prefix[i], s2.section_name().c_str()))
	{
          s2_group_index = i;
	  flag_done++;
	}
    }

  if (s1_group_index == s2_group_index)
    return s1.index() < s2.index();
  else
    return s1_group_index < s2_group_index;
d3579 1
a3579 2
                            (this->must_sort_attached_input_sections()
			     || this->input_section_order_specified())));
@


1.177
log
@	* layout.h (Layout::get_executable_sections): Declare.
	* layout.cc (Layout::get_executable_sections): New function.
	* arm.cc (Target_arm::group_sections): Use it.
	(Arm_output_section::group_sections): Delete now redundant test.
	* output.cc (Output_reloc::Output_reloc): Add is_relative.
	param to handle relative relocs.
	* output.h (Output_reloc::Output_reloc <absolute reloc>): Likewise.
	(Output_data_reloc::add_absolute): Adjust.
	(Output_data_reloc::add_relative): New function.
	(Output_data::reset_data_size): New function.
	(Output_relaxed_input_section::set_relobj, set_shndx): New functions.
	(Output_section::set_addralign): New function.
	(Output_section::checkpoint_set_addralign): New function.
	(Output_section::clear_section_offsets_need_adjustment): New function.
	(Output_section::input_sections): Make public.
	* powerpc.cc (class Output_data_brlt_powerpc): New.
	(class Stub_table, class Stub_control): New.
	(Powerpc_relobj::has14_, set_has_14bit_branch, has_14bit_branch,
	stub_table_, set_stub_table, stub_table): New vectors and accessor
	functions.
	(Target_powerpc::do_may_relax, do_relax, push_branch,
	new_stub_table, stub_tables, brlt_section, group_sections,
	add_branch_lookup_table, find_branch_lookup_table,
	write_branch_lookup_table, make_brlt_section): New functions.
	(Target_powerpc::struct Sort_sections, class Branch_info): New.
	(Target_powerpc::brlt_section_, stub_tables_, branch_lookup_table_,
	branch_info_): New vars.
	(Target_powerpc::make_plt_entry, make_local_ifunc_plt_entry): Don't
	make call stubs here.
	(Output_data_glink): Remove all call stub handling from this class.
	(Target_powerpc::Scan::local, global): Save interesting branch
	relocs and relocs for ifunc.  Adjust calls to plt entry functions.
	(Target_powerpc::do_finalize_sections): Only make reg save/restore
	functions on final link.
	(Target_powerpc::Relocate::relocate): Adjust lookup of call stubs.
	Handle long branch destinations too.
	(Target_powerpc::do_dynsym_value, do_plt_address_for_global,
	do_plt_address_for_local): Adjust lookup of plt call stubs.
@
text
@d2481 13
d2507 2
a2508 1
      || layout->is_section_ordering_specified())
d3501 3
a3503 1
// that match some pattern.
d3513 50
a3562 2
  // Keep input order if section ordering cannot determine order.
  if (s1_secn_index == s2_secn_index)
d3564 2
a3565 2

  return s1_secn_index < s2_secn_index;
d3626 2
a3627 1
                            this->must_sort_attached_input_sections()));
@


1.176
log
@gold/
	* dwarf_reader.cc (Sized_elf_reloc_mapper::symbol_section): Cast
	SYMNDX to off_t before comparing it to this->data_size().
	* output.cc (Output_symtab_xindex::endian_do_write): Likewise.
	* incremental.cc (Output_section_incremental_inputs::do_write):
	Cast GLOBAL_SYM_COUNT to off_t before comparing it to SYMTAB_SIZE.
@
text
@d854 1
a854 1
// An absolute relocation.
d860 2
a861 1
    Address address)
d863 1
a863 1
    is_relative_(false), is_symbolless_(false),
d877 2
a878 1
    Address address)
d880 1
a880 1
    is_relative_(false), is_symbolless_(false),
@


1.175
log
@	* i386.cc (Output_data_plt_i386::address_for_global,
	address_for_local): Add plt offset to returned value.  Adjust uses.
	* sparc.cc (Output_data_plt_sparc::address_for_global,
	address_for_local): Likewise.
	* tilegx.cc (Output_data_plt_tilegx::address_for_global,
	address_for_local): Likewise.
	* x86_64.cc (Output_data_plt_x86_64::address_for_global,
	address_for_local): Likewise.
	* target.h (Target::plt_address_for_global, plt_address_for_local):
	Update comment.
	* output.cc (Output_reloc::symbol_value): Don't add plt offset here.
	(Output_data_got::Got_entry::write): Nor here.
	* output.h: Comment fix.
@
text
@d1938 1
a1938 1
      gold_assert(symndx * 4 < this->data_size());
d2768 1
a2768 1
  
d2783 1
a2783 1
  
d2896 1
a2896 1
	       ++is) 
d2902 1
a2902 1
	    
d2944 1
a2944 1
      gold_assert(found);   
d2979 1
a2979 1
  if (posd == NULL) 
d2985 1
a2985 1
      gold_assert(found);   
d3012 1
a3012 1
  if (posd == NULL) 
d3498 1
a3498 1
  
d3861 1
a3861 1
  // Update fast lookup maps if necessary. 
d4176 1
a4176 1
	{	
@


1.174
log
@	PR gold/14570
	* output.cc: Rename Output_data_got template parameter from size
	to got_size for all functions.  Compile all variants of
	Output_data_got.
	(Output_data_got::Got_entry::write): Correct use of size for
	symbol value.  Use local_is_tls rather than casting to
	Sized_relobj_file.
	* object.h (class Object): Add local_is_tls and do_local_is_tls.
	(class Sized_relobj_file): Add do_local_is_tls.
	* incremental.h (class Sized_relobj_incr): Add do_local_is_tls.
@
text
@d1132 1
a1132 5
	{
	  uint64_t plt_address =
	    parameters->target().plt_address_for_global(sym);
	  return plt_address + sym->plt_offset();
	}
d1150 1
a1150 5
    {
      uint64_t plt_address =
	  parameters->target().plt_address_for_local(relobj, lsi);
      return plt_address + relobj->local_plt_offset(lsi);
    }
d1380 1
a1380 2
	  val = (parameters->target().plt_address_for_global(gsym)
		 + gsym->plt_offset());
d1436 1
a1436 5
	  {
	    uint64_t plt_address =
	      parameters->target().plt_address_for_local(object, lsi);
	    val = plt_address + object->local_plt_offset(lsi);
	  }
d2599 1
a2599 1
  // section and add them back to them same output section to compute the
d2601 1
a2601 1
  // sections,  an output section would be incorrectly sized.
@


1.173
log
@	PR gold/14566
	* layout.cc (Layout::set_segment_offsets): When using
	common-page-size alignment, ensure we are on a new max-page-size
	page.
	* output.cc (Output_segment::set_section_addresses): Use
	abi_pagesize, not common_pagesize for relro boundary.
	(Output_segment::set_offset): Likewise.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d1371 1
a1371 1
template<int size, bool big_endian>
d1373 1
a1373 1
Output_data_got<size, big_endian>::Got_entry::write(
d1392 30
a1421 7
	    Sized_symbol<size>* sgsym;
	    // This cast is a bit ugly.  We don't want to put a
	    // virtual method in Symbol, because we want Symbol to be
	    // as small as possible.
	    sgsym = static_cast<Sized_symbol<size>*>(gsym);
	    val = sgsym->value();
	    if (this->use_plt_or_tls_offset_ && gsym->type() == elfcpp::STT_TLS)
d1441 1
a1441 2
	const Sized_relobj_file<size, big_endian>* object
	  = static_cast<Sized_relobj_file<size, big_endian>*>(this->u_.object);
d1443 1
a1443 1
	bool is_tls = object->local_symbol(lsi)->is_tls_symbol();
d1462 1
a1462 1
  elfcpp::Swap<size, big_endian>::writeval(pov, val);
d1471 1
a1471 1
template<int size, bool big_endian>
d1473 1
a1473 1
Output_data_got<size, big_endian>::add_global(
d1487 1
a1487 1
template<int size, bool big_endian>
d1489 2
a1490 2
Output_data_got<size, big_endian>::add_global_plt(Symbol* gsym,
						  unsigned int got_type)
d1503 1
a1503 1
template<int size, bool big_endian>
d1505 1
a1505 1
Output_data_got<size, big_endian>::add_global_with_rel(
d1522 1
a1522 1
template<int size, bool big_endian>
d1524 1
a1524 1
Output_data_got<size, big_endian>::add_global_pair_with_rel(
d1540 1
a1540 1
				got_offset + size / 8, 0);
d1547 1
a1547 1
template<int size, bool big_endian>
d1549 1
a1549 1
Output_data_got<size, big_endian>::add_local(
d1565 1
a1565 1
template<int size, bool big_endian>
d1567 1
a1567 1
Output_data_got<size, big_endian>::add_local_plt(
d1584 1
a1584 1
template<int size, bool big_endian>
d1586 1
a1586 1
Output_data_got<size, big_endian>::add_local_with_rel(
d1606 1
a1606 1
template<int size, bool big_endian>
d1608 1
a1608 1
Output_data_got<size, big_endian>::add_local_pair_with_rel(
d1631 1
a1631 1
template<int size, bool big_endian>
d1633 1
a1633 1
Output_data_got<size, big_endian>::add_local_tls_pair(
d1652 1
a1652 1
template<int size, bool big_endian>
d1654 1
a1654 1
Output_data_got<size, big_endian>::reserve_local(
d1666 1
a1666 1
template<int size, bool big_endian>
d1668 1
a1668 1
Output_data_got<size, big_endian>::reserve_global(
d1679 1
a1679 1
template<int size, bool big_endian>
d1681 1
a1681 1
Output_data_got<size, big_endian>::do_write(Output_file* of)
d1683 1
a1683 1
  const int add = size / 8;
d1706 1
a1706 1
template<int size, bool big_endian>
d1708 1
a1708 1
Output_data_got<size, big_endian>::add_got_entry(Got_entry got_entry)
d1719 2
a1720 1
      off_t got_offset = this->free_list_.allocate(size / 8, size / 8, 0);
d1724 1
a1724 1
      unsigned int got_index = got_offset / (size / 8);
d1733 1
a1733 1
template<int size, bool big_endian>
d1735 3
a1737 2
Output_data_got<size, big_endian>::add_got_entry_pair(Got_entry got_entry_1,
						      Got_entry got_entry_2)
d1751 2
a1752 1
      off_t got_offset = this->free_list_.allocate(2 * size / 8, size / 8, 0);
d1756 1
a1756 1
      unsigned int got_index = got_offset / (size / 8);
d1766 1
a1766 1
template<int size, bool big_endian>
d1768 1
a1768 1
Output_data_got<size, big_endian>::replace_got_entry(
a5470 1
#ifdef HAVE_TARGET_32_LITTLE
a5472 1
#endif
a5473 1
#ifdef HAVE_TARGET_32_BIG
a5475 1
#endif
a5476 1
#ifdef HAVE_TARGET_64_LITTLE
a5478 1
#endif
a5479 1
#ifdef HAVE_TARGET_64_BIG
a5481 1
#endif
@


1.172
log
@	* output.h (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::add_local_pair_with_rel): Remove second
	reloc param.  Expand comment.
	(Output_data_got::Got_entry): Rename use_plt_offset_ to
	use_plt_or_tls_offset_, similarly for constructor param.
	(Output_data_got::Got_entry::write): Add got_index param.
	* output.cc (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::Got_entry::write): Handle tls symbols
	with use_plt_or_tls_offset_ set specially.
	(Output_data_got::add_local_pair_with_rel): Only one reloc.
	(Output_data_got::do_write): Replace iterator with index, pass
	index to entry write function.
	* target.h (Target::tls_offset_for_local, tls_offset_for_global,
	do_tls_offset_for_local, do_tls_offset_for_global): New functions.
	* arm.cc (Target_arm::Scan::local): Update add_local_pair_with_rel
	call.
	* i386.cc (Target_i386::Scan::local): Likewise.
	* sparc.cc (Target_sparc::Scan::local): Likewise.
	* x86_64.cc (Target_x86_64::Scan::local): Likewise.
	* powerpc.cc (Target_powerpc::do_tls_offset_for_local,
	do_tls_offset_for_global): New functions.
	(Target_powerpc::Scan::local): Correct TLS relocations and got
	entry values.
	(Target_powerpc::Scan::global): Don't emit unnecessary
	dynamic relocations on TLS GOT entries.
@
text
@d4242 1
a4242 1
  // relro sections plus INCREASE_RELRO end on a common page boundary.
d4297 1
a4297 1
      uint64_t page_align = parameters->target().common_pagesize();
d4607 1
a4607 1
      uint64_t page_align = parameters->target().common_pagesize();
@


1.171
log
@	* object.h (Sized_relobj_file::emit_relocs): Delete.
	(Sized_relobj_file::emit_relocs_reltype): Delete.
	* reloc.cc (Sized_relobj_file::do_relocate_sections): Call target
	relocate_relocs for --emit-relocs.
	(Sized_relobj_file::emit_relocs, emit_relocs_reltype): Delete.
	* output.h: Update comment.
	(Output_segment::first_section): New function.
	(Output_segment::first_section_load_address): Use first_section.
	* output.cc (Output_segment::first_section): New function extracted..
	(Output_segment::first_section_load_address): ..from here.  Delete.
	* target-reloc.h (relocate_for_relocatable): Rename to relocate_relocs.
	* target.h (Sized_target::relocate_for_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise, and
	adjust call to target.h function.
	* i386.cc (Target_i386): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	(Target_powerpc::Scan::local, global): Handle R_POWERPC_TLS.  Ensure
	first tls section has section symbol for optimised local dynamic
	output relocs.
	(Target_powerpc::Relocate::relocate): Correct local dynamic value.
	(Target_powerpc::relocate_relocs): Adjust relocs emitted for
	optimised tls code.
	* testsuite/testfile.cc (Target_test::relocate_for_relocatable):
	Rename to relocate_relocs.  Update error message.
@
text
@d1372 3
a1374 1
Output_data_got<size, big_endian>::Got_entry::write(unsigned char* pov) const
d1386 1
a1386 1
	if (this->use_plt_offset_ && gsym->has_plt_offset())
d1397 3
d1417 2
a1418 1
	const Relobj* object = this->u_.object;
d1420 2
a1421 1
	if (!this->use_plt_offset_)
d1423 3
a1425 2
	    uint64_t lval = object->local_symbol_value(lsi, 0);
	    val = convert_types<Valtype, uint64_t>(lval);
d1429 5
a1433 3
	    uint64_t plt_address =
	      parameters->target().plt_address_for_local(object, lsi);
	    val = plt_address + object->local_plt_offset(lsi);
d1579 4
a1582 2
// dynamic relocations of type R_TYPE_1 and R_TYPE_2, respectively.
// If R_TYPE_2 == 0, add the second entry with no relocation.
d1591 1
a1591 2
    unsigned int r_type_1,
    unsigned int r_type_2)
d1601 2
a1602 1
  rel_dyn->add_output_section_generic(os, r_type_1, this, got_offset, 0);
d1604 21
a1624 3
  if (r_type_2 != 0)
    rel_dyn->add_output_section_generic(os, r_type_2, this,
					got_offset + size / 8, 0);
d1667 1
a1667 3
  for (typename Got_entries::const_iterator p = this->entries_.begin();
       p != this->entries_.end();
       ++p)
d1669 1
a1669 1
      p->write(pov);
@


1.170
log
@	* output.h (Output_reloc::Output_reloc <output section>): Add
	is_relative param.  Adjust calls.
	(Output_reloc::add_output_section_relative): New functions.
	* output.cc (Output_reloc::Output_reloc <output section>): Handle
	is_relative.
	(Output_reloc::symbol_value): Handle SECTION_CODE.
@
text
@d4616 1
a4616 1
// Return the load address of the first section.
d4618 2
a4619 2
uint64_t
Output_segment::first_section_load_address() const
d4629 1
a4629 3
	    return ((*p)->has_load_address()
		    ? (*p)->load_address()
		    : (*p)->address());
@


1.169
log
@Patch adds support to allow plugins to map selected subset of sections to unique
segments.


2012-08-24  Sriraman Tallam  <tmsriram@@google.com>

	* gold.cc (queue_middle_tasks): Call layout again when unique
	segments for sections is desired.
	* layout.cc (Layout::Layout): Initialize new members.
	(Layout::get_output_section_flags): New function.
	(Layout::choose_output_section): Call get_output_section_flags.
	(Layout::layout): Make output section for mapping to a unique segment.
	(Layout::insert_section_segment_map): New function.
	(Layout::attach_allocated_section_to_segment): Make unique segment for
	output sections marked so.
	(Layout::segment_precedes): Check for unique segments when sorting.
	* layout.h (Layout::Unique_segment_info): New struct.
	(Layout::Section_segment_map): New typedef.
	(Layout::insert_section_segment_map): New function.
	(Layout::get_output_section_flags): New function.
	(Layout::is_unique_segment_for_sections_specified): New function.
	(Layout::set_unique_segment_for_sections_specified): New function.
	(Layout::unique_segment_for_sections_specified_): New member.
	(Layout::section_segment_map_): New member.
	* object.cc (Sized_relobj_file<size, big_endian>::do_layout):
	Rename is_gc_pass_one to is_pass_one.
	Rename is_gc_pass_two to is_pass_two.
	Rename is_gc_or_icf to is_two_pass.
	Check for which pass based on whether symbols data is present.
	Make it two pass when unique segments for sections is desired.
	* output.cc (Output_section::Output_section): Initialize new
	members.
	* output.h (Output_section::is_unique_segment): New function.
	(Output_section::set_is_unique_segment): New function.
	(Output_section::is_unique_segment_): New member.
	(Output_section::extra_segment_flags): New function.
	(Output_section::set_extra_segment_flags): New function.
	(Output_section::extra_segment_flags_): New member.
	(Output_section::segment_alignment): New function.
	(Output_section::set_segment_alignment): New function.
	(Output_section::segment_alignment_): New member.
	(Output_segment::Output_segment): Initialize is_unique_segment_.
	(Output_segment::is_unique_segment): New function.
	(Output_segment::set_is_unique_segment): New function.
	(Output_segment::is_unique_segment_): New member.
	* plugin.cc (allow_unique_segment_for_sections): New function.
	(unique_segment_for_sections): New function.
	(Plugin::load): Add new functions to transfer vector.
	* Makefile.am (plugin_final_layout.readelf.stdout): Add readelf output.
	* Makefile.in: Regenerate.
	* testsuite/plugin_final_layout.sh: Check if unique segment
	functionality works.
	* testsuite/plugin_section_order.c (onload): Check if new interfaces
	are available.
	(allow_unique_segment_for_sections): New global.
	(unique_segment_for_sections): New global.
	(claim_file_hook): Call allow_unique_segment_for_sections.
	(all_symbols_read_hook): Call unique_segment_for_sections.


2012-08-24  Sriraman Tallam  <tmsriram@@google.com>

	* plugin-api.h (ld_plugin_allow_unique_segment_for_sections):
	New interface.
	(ld_plugin_unique_segment_for_sections): New interface.
	(LDPT_ALLOW_UNIQUE_SEGMENT_FOR_SECTIONS): New enum val.
	(LDPT_UNIQUE_SEGMENT_FOR_SECTIONS): New enum val.
	(tv_allow_unique_segment_for_sections): New member.
	(tv_unique_segment_for_sections): New member.
@
text
@d814 2
a815 1
    Address address)
d817 1
a817 1
    is_relative_(false), is_symbolless_(false),
d836 2
a837 1
    Address address)
d839 1
a839 1
    is_relative_(false), is_symbolless_(false),
d1139 6
a1144 2
  gold_assert(this->local_sym_index_ != SECTION_CODE
	      && this->local_sym_index_ != TARGET_CODE
@


1.168
log
@	* object.h (Sized_relobj_file::find_shdr): New function.
	(Sized_relobj_file::find_special_sections): New function.
	* object.cc (Sized_relobj_file::find_shdr): New function.
	(Sized_relobj_file::find_eh_frame): Use find_shdr.
	(Sized_relobj_file::find_special_sections): New function, split out..
	(Sized_relobj_file::do_read_symbols): ..from here.
	* output.h (Output_data_got::replace_constant): New function.
	(Output_data_got::num_entries): New function.
	(Output_data_got::last_got_offset,set_got_size): Use num_entries.
	(Output_data_got::got_offset): Protected rather than private.
	(Output_data_got::replace_got_entry): New function.
	* output.cc (Output_data_got::replace_got_entry): New function.
	* powerpc.cc (class Powerpc_relobj): New.
	(class Powerpc_relocate_functions): Delete all psymval variants or
	convert to value,addend type.  Delete pcrela, pcrela_unaligned.
	Implement _ha functions using corresponding _hi function.
	(Powerpc_relobj::find_special_sections): New function.
	(Target_powerpc::do_make_elf_object): New function.
	(class Output_data_got_powerpc): New.
	(class Output_data_glink): New.
	(class Powerpc_scan_relocatable_reloc): New.
	Many more changes througout file.
@
text
@d2260 1
d2262 2
d3997 2
a3998 1
    is_large_data_segment_(false)
@


1.167
log
@gold/
	* configure.ac: Add check for fallocate.
	* configure: Regenerate.
	* config.in: Regenerate.

	* options.h (class General_options): Add --mmap-output-file and
	--posix-fallocate options.
	* output.cc: (posix_fallocate): Remove; replace with...
	(gold_fallocate): New function.
	(Output_file::map_no_anonymous): Call gold_fallocate.
	(Output_file::map): Check --mmap-output-file option.
@
text
@d1704 12
@


1.167.2.1
log
@gold/
	* dwarf_reader.cc (Sized_elf_reloc_mapper::symbol_section): Cast
	SYMNDX to off_t before comparing it to this->data_size().
	* output.cc (Output_symtab_xindex::endian_do_write): Likewise.
	* incremental.cc (Output_section_incremental_inputs::do_write):
	Cast GLOBAL_SYM_COUNT to off_t before comparing it to SYMTAB_SIZE.
@
text
@d1879 1
a1879 1
      gold_assert(static_cast<off_t>(symndx) * 4 < this->data_size());
d2706 1
a2706 1

d2721 1
a2721 1

d2834 1
a2834 1
	       ++is)
d2840 1
a2840 1

d2882 1
a2882 1
      gold_assert(found);
d2917 1
a2917 1
  if (posd == NULL)
d2923 1
a2923 1
      gold_assert(found);
d2950 1
a2950 1
  if (posd == NULL)
d3436 1
a3436 1

d3799 1
a3799 1
  // Update fast lookup maps if necessary.
d4113 1
a4113 1
	{
@


1.167.2.2
log
@gold/
	* output.cc (Output_segment::set_section_addresses): Take new
	Target* argument.  If target->isolate_execinstr() and the segment
	is executable and starts at a target->abi_pagesize() boundary,
	pad its end out to a target->abi_pagesize() boundary with code fill.
	* output.h (Output_segment::set_section_addresses): Update decl.
	* layout.h (Layout::check_output_data_for_reset_values): Take new
	argument RELAX_OUTPUTS.
	(Layout): New member relax_output_list_.
	(Layout::add_relax_output): New method.
	* layout.cc (Layout::Layout): Update constructor.
	(Layout::reset_relax_output): New method.
	(Layout::clean_up_after_relaxation): Call it.
	(Layout::prepare_for_relaxation): Update caller.
	(Layout::set_segment_offsets): Update callers of set_section_addresses.
	Call reset_relax_output before re-processing segments for
	isolate_execinstr case.
	(Layout::write_data): Handle relax_output_list_.
	(Layout::Relaxation_debug_check::check_output_data_for_reset_values):
	Take new argument RELAX_OUTPUTS.  Assert it's an empty collection.
@
text
@d3 1
a3 2
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
// Free Software Foundation, Inc.
d592 1
a592 1
				     && !parameters->options().shared());
d771 1
a771 1
	      && local_sym_index != INVALID_CODE);
d797 1
a797 1
	      && local_sym_index != INVALID_CODE);
d952 1
a952 1
	const unsigned int lsi = this->local_sym_index_;
d956 4
a959 4
	if (!this->is_section_symbol_)
	  relobj->set_needs_output_dynsym_entry(lsi);
	else
	  relobj->output_section(lsi)->set_needs_dynsym_index();
d1008 1
a1008 1
	const unsigned int lsi = this->local_sym_index_;
d1012 16
a1027 16
	if (!this->is_section_symbol_)
	  {
	    if (dynamic)
	      index = relobj->dynsym_index(lsi);
	    else
	      index = relobj->symtab_index(lsi);
	  }
	else
	  {
	    Output_section* os = relobj->output_section(lsi);
	    gold_assert(os != NULL);
	    if (dynamic)
	      index = os->dynsym_index();
	    else
	      index = os->symtab_index();
	  }
d1044 1
a1044 1
	      && this->local_sym_index_ != SECTION_CODE
d1046 1
a1046 1
	      && this->local_sym_index_ != INVALID_CODE
d1048 1
a1048 1
	      && this->is_section_symbol_);
d1139 1
a1139 1
	      && this->local_sym_index_ != INVALID_CODE
d1141 1
a1141 1
	      && !this->is_section_symbol_);
d1400 1
a1400 1
	return;
d1407 1
a1407 1
	const unsigned int lsi = this->local_sym_index_;
d2188 1
a2188 1
	Output_relaxed_input_section* relaxed_section =
d2190 1
a2190 1
	mapfile->print_input_section(relaxed_section->relobj(),
d2368 1
a2368 1
	gold_fallback(_("out of patch space in section %s; "
d2391 1
a2391 1
	  || layout->is_section_ordering_specified()))
d2408 1
a2408 1
	this->fills_.push_back(Fill(offset_in_section, fill_len));
d2410 5
a2414 5
	{
	  std::string fill_data(parameters->target().code_fill(fill_len));
	  Output_data_const* odc = new Output_data_const(fill_data, 1);
	  this->input_sections_.push_back(Input_section(odc));
	}
d2437 3
a2439 3
	{
	  unsigned int section_order_index =
	    layout->find_section_order_index(std::string(secname));
d2441 5
a2445 5
	    {
	      isecn.set_section_order_index(section_order_index);
	      this->set_input_section_order_specified();
	    }
	}
d2522 1
a2522 1
	layout->find_section_order_index(name);
d2524 4
a2527 4
	{
	  inp.set_section_order_index(section_order_index);
	  this->set_input_section_order_specified();
	}
d3081 1
a3081 1
	  && this->free_space_fill_->minimum_hole_size() > extra)
d3169 1
a3169 1
	&& must_sort_attached_input_sections)
d3273 4
a3276 4
	if (this_secn_index < s_secn_index)
	  return 1;
	else if (this_secn_index > s_secn_index)
	  return -1;
d3453 1
a3453 1
	{
d3456 1
a3456 1
			 : p->relaxed_input_section()->relobj());
d3464 3
a3466 3
	    {
	      p->set_section_order_index(section_order_index);
	      this->set_input_section_order_specified();
d3468 1
a3468 1
	}
d3498 1
a3498 1
			    this->must_sort_attached_input_sections()));
d3504 4
a3507 4
	  || this->type() == elfcpp::SHT_INIT_ARRAY
	  || this->type() == elfcpp::SHT_FINI_ARRAY)
	std::sort(sort_list.begin(), sort_list.end(),
		  Input_section_sort_init_fini_compare());
d3509 2
a3510 2
	std::sort(sort_list.begin(), sort_list.end(),
		  Input_section_sort_compare());
d3516 1
a3516 1
		Input_section_sort_section_order_index_compare());
d4177 2
a4178 3
Output_segment::set_section_addresses(const Target* target,
				      Layout* layout, bool reset,
				      uint64_t addr,
a4316 35
  // If code segments must contain only code, and this code segment is
  // page-aligned in the file, then fill it out to a whole page with
  // code fill (the tail of the segment will not be within any section).
  // Thus the entire code segment can be mapped from the file as whole
  // pages and that mapping will contain only valid instructions.
  if (target->isolate_execinstr() && (this->flags() & elfcpp::PF_X) != 0)
    {
      uint64_t abi_pagesize = target->abi_pagesize();
      if (orig_off % abi_pagesize == 0 && off % abi_pagesize != 0)
	{
	  size_t fill_size = abi_pagesize - (off % abi_pagesize);

	  std::string fill_data;
	  if (target->has_code_fill())
	    fill_data = target->code_fill(fill_size);
	  else
	    fill_data.resize(fill_size); // Zero fill.

	  Output_data_const* fill = new Output_data_const(fill_data, 0);
	  fill->set_address(this->vaddr_ + this->memsz_);
	  fill->set_file_offset(off);
	  layout->add_relax_output(fill);

	  off += fill_size;
	  gold_assert(off % abi_pagesize == 0);
	  ret += fill_size;
	  gold_assert(ret % abi_pagesize == 0);

	  gold_assert((uint64_t) this->filesz_ == this->memsz_);
	  this->memsz_ = this->filesz_ += fill_size;

	  *poff = off;
	}
    }

d4325 1
a4325 1
					   Output_data_list* pdl,
d4328 1
a4328 1
					   bool* in_tls)
d4347 1
a4347 14
	  uint64_t align = (*p)->addralign();

	  if ((*p)->is_section_flag_set(elfcpp::SHF_TLS))
	    {
	      // Give the first TLS section the alignment of the
	      // entire TLS segment.  Otherwise the TLS segment as a
	      // whole may be misaligned.
	      if (!*in_tls)
		{
		  Output_segment* tls_segment = layout->tls_segment();
		  gold_assert(tls_segment != NULL);
		  uint64_t segment_align = tls_segment->maximum_alignment();
		  gold_assert(segment_align >= align);
		  align = segment_align;
d4349 32
a4380 19
		  *in_tls = true;
		}
	    }
	  else
	    {
	      // If this is the first section after the TLS segment,
	      // align it to at least the alignment of the TLS
	      // segment, so that the size of the overall TLS segment
	      // is aligned.
	      if (*in_tls)
		{
		  uint64_t segment_align =
		      layout->tls_segment()->maximum_alignment();
		  if (segment_align > align)
		    align = segment_align;

		  *in_tls = false;
		}
	    }
d4394 1
a4394 1
		{
d4399 1
a4399 1
		}
d4411 5
a4415 5
	{
	  // For incremental updates, use the fixed offset for the
	  // high-water mark computation.
	  off = (*p)->offset();
	}
d4465 1
a4465 1
	maxoff = off;
d5064 2
a5065 2
	     this->name_, static_cast<unsigned long>(this->file_size_),
	     strerror(errno));
d5097 13
a5109 13
	{
	  ssize_t bytes_written = ::write(this->o_, this->base_ + offset,
					  bytes_to_write);
	  if (bytes_written == 0)
	    gold_error(_("%s: write: unexpected 0 return-value"), this->name_);
	  else if (bytes_written < 0)
	    gold_error(_("%s: write: %s"), this->name_, strerror(errno));
	  else
	    {
	      bytes_to_write -= bytes_written;
	      offset += bytes_written;
	    }
	}
@


1.166
log
@gold: Allow use_plt_offset to be specified for global relocations.

gold/

	* output.h (Output_reloc): Allow use_plt_offset for global relocs too.
	(class Output_data_reloc): Adjust calls to Output_reloc_type.
	(Output_data_reloc::add_global_relative): (RELA only) Add use_plt_offset.
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag for
	global relocs too.
	(Output_reloc::symbol_value): Respect use_plt_offset_ for global symbols.
	* powerpc.cc (Target_powerpc::Scan::global): Adjust add_global_relative
	calls.
	* sparc.cc (Target_sparc::Scan::global): Likewise.
	* x86_64.cc (Target_x86_64::Scan::global): Likewise.
@
text
@a113 14
#ifndef HAVE_POSIX_FALLOCATE
// A dummy, non general, version of posix_fallocate.  Here we just set
// the file size and hope that there is enough disk space.  FIXME: We
// could allocate disk space by walking block by block and writing a
// zero byte into each block.
static int
posix_fallocate(int o, off_t offset, off_t len)
{
  if (ftruncate(o, offset + len) < 0)
    return errno;
  return 0;
}
#endif // !defined(HAVE_POSIX_FALLOCATE)

d122 21
d5024 1
a5024 1
      int err = ::posix_fallocate(o, 0, this->file_size_);
d5051 2
a5052 1
  if (this->map_no_anonymous(true))
@


1.165
log
@	* gold/incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Use abstract base class for GOT.
	* gold/output.h (class Output_data_got_base): New abstract base class.
	(class Output_data_got): Derive from new base class, adjust ctors.
	(Output_data_got::reserve_slot): Make virtual; rename to
	do_reserve_slot; Adjust callers.
	* gold/target.h (Sized_target::init_got_plt_for_update): Return
	pointer to abstract base class.
	* gold/x86_64.cc (Target_x86_64::init_got_plt_for_update): Likewise.
@
text
@d708 2
a709 1
    bool is_symbolless)
d712 1
a712 1
    is_section_symbol_(false), use_plt_offset_(false), shndx_(INVALID_CODE)
d730 2
a731 1
    bool is_symbolless)
d734 1
a734 1
    is_section_symbol_(false), use_plt_offset_(false), shndx_(shndx)
d1121 8
a1128 1
      return sym->value() + addend;
@


1.164
log
@	* object.h (Relobj::local_symbol_value): New function.
	(Relobj::local_plt_offset): New function.
	(Relobj::local_has_got_offset): New function.
	(Relobj::local_got_offset): New function.
	(Relobj::set_local_got_offset): New function.
	(Relobj::do_local_symbol_value): New pure virtual function.
	(Relobj::do_local_plt_offset): Likewise.
	(Relobj::do_local_has_got_offset): Likewise.
	(Relobj::do_local_got_offset): Likewise.
	(Relobj::do_set_local_got_offset): Likewise.
	(Sized_relobj::do_local_has_got_offset): Rename from
	local_has_got_offset.
	(Sized_relobj::do_local_got_offset): Rename from local_got_offset.
	(Sized_relobj::do_set_local_got_offset): Rename from
	set_local_got_offset.
	(Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	(Sized_relobj_file::do_local_symbol_value): New function.
	* object.cc (Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	* output.cc (Output_data_got::Got_entry::write): Change object to
	Relobj.  Use local_symbol_value.
	(Output_data_got::add_global_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_with_rela): Remove.  Change all
	callers to use add_global_with_rel.
	(Output_data_got::add_global_pair_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_pair_with_rela): Remove.  Change all
	callers to use add_global_pair_with_rel.
	(Output_data_got::add_local): Change object to Relobj*.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Change object to Relobj*,
	change rel_dyn to Output_data_reloc_generic*.  Use
	add_local_generic.
	(Output_data_got::add_local_with_rela): Remove.  Change all
	callers to use all_local_with_rel.
	(Output_data_got::add_local_pair_with_rel): Change object to
	Relobj*, change rel_dyn to Output_data_reloc_generic*.  Use
	add_output_section_generic.
	(Output_data_got::add_local_pair_with_rela): Remove.  Change all
	callers to use add_local_pair_with_rel.
	(Output_data_got::reserve_local): Change object to Relobj*.
	* output.h: (class Output_data_reloc_generic): Add pure virtual
	declarations for add_global_generic, add_local_generic,
	add_output_section_generic.
	(class Output_data_reloc) [SHT_REL, SHT_RELA]: Implement new
	functions for Output_data_reloc_generic.  Update declarations for
	changes listed in output.cc.
	(class Output_data_got): Change template parameter to got_size.
	Don't define Rel_dyn or Rela_dyn.  Update declarations per above.
	* incremental.h (Sized_relobj_incr::do_local_symbol_value): New
	function.
	(Sized_relobj_incr::do_local_plt_offset): New function.
	* copy-relocs.cc (Copy_relocs::Copy_reloc_entry::emit): Call
	add_global_generic.
@
text
@d1585 1
a1585 1
  this->reserve_slot(i);
d1598 1
a1598 1
  this->reserve_slot(i);
@


1.163
log
@	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.
@
text
@d1390 1
a1390 1
	const Sized_relobj_file<size, big_endian>* object = this->u_.object;
a1391 1
        const Symbol_value<size>* symval = object->local_symbol(lsi);
d1393 4
a1396 1
	  val = symval->value(this->u_.object, 0);
d1453 1
a1453 17
    Rel_dyn* rel_dyn,
    unsigned int r_type)
{
  if (gsym->has_got_offset(got_type))
    return;

  unsigned int got_offset = this->add_got_entry(Got_entry());
  gsym->set_got_offset(got_type, got_offset);
  rel_dyn->add_global(gsym, r_type, this, got_offset);
}

template<int size, bool big_endian>
void
Output_data_got<size, big_endian>::add_global_with_rela(
    Symbol* gsym,
    unsigned int got_type,
    Rela_dyn* rela_dyn,
d1461 1
a1461 1
  rela_dyn->add_global(gsym, r_type, this, got_offset, 0);
d1472 1
a1472 21
    Rel_dyn* rel_dyn,
    unsigned int r_type_1,
    unsigned int r_type_2)
{
  if (gsym->has_got_offset(got_type))
    return;

  unsigned int got_offset = this->add_got_entry_pair(Got_entry(), Got_entry());
  gsym->set_got_offset(got_type, got_offset);
  rel_dyn->add_global(gsym, r_type_1, this, got_offset);

  if (r_type_2 != 0)
    rel_dyn->add_global(gsym, r_type_2, this, got_offset + size / 8);
}

template<int size, bool big_endian>
void
Output_data_got<size, big_endian>::add_global_pair_with_rela(
    Symbol* gsym,
    unsigned int got_type,
    Rela_dyn* rela_dyn,
d1481 1
a1481 1
  rela_dyn->add_global(gsym, r_type_1, this, got_offset, 0);
d1484 2
a1485 1
    rela_dyn->add_global(gsym, r_type_2, this, got_offset + size / 8, 0);
d1495 1
a1495 1
    Sized_relobj_file<size, big_endian>* object,
d1513 1
a1513 1
    Sized_relobj_file<size, big_endian>* object,
d1532 1
a1532 18
    Sized_relobj_file<size, big_endian>* object,
    unsigned int symndx,
    unsigned int got_type,
    Rel_dyn* rel_dyn,
    unsigned int r_type)
{
  if (object->local_has_got_offset(symndx, got_type))
    return;

  unsigned int got_offset = this->add_got_entry(Got_entry());
  object->set_local_got_offset(symndx, got_type, got_offset);
  rel_dyn->add_local(object, symndx, r_type, this, got_offset);
}

template<int size, bool big_endian>
void
Output_data_got<size, big_endian>::add_local_with_rela(
    Sized_relobj_file<size, big_endian>* object,
d1535 1
a1535 1
    Rela_dyn* rela_dyn,
d1543 1
a1543 1
  rela_dyn->add_local(object, symndx, r_type, this, got_offset, 0);
d1552 1
a1552 26
    Sized_relobj_file<size, big_endian>* object,
    unsigned int symndx,
    unsigned int shndx,
    unsigned int got_type,
    Rel_dyn* rel_dyn,
    unsigned int r_type_1,
    unsigned int r_type_2)
{
  if (object->local_has_got_offset(symndx, got_type))
    return;

  unsigned int got_offset =
      this->add_got_entry_pair(Got_entry(),
			       Got_entry(object, symndx, false));
  object->set_local_got_offset(symndx, got_type, got_offset);
  Output_section* os = object->output_section(shndx);
  rel_dyn->add_output_section(os, r_type_1, this, got_offset);

  if (r_type_2 != 0)
    rel_dyn->add_output_section(os, r_type_2, this, got_offset + size / 8);
}

template<int size, bool big_endian>
void
Output_data_got<size, big_endian>::add_local_pair_with_rela(
    Sized_relobj_file<size, big_endian>* object,
d1556 1
a1556 1
    Rela_dyn* rela_dyn,
d1568 1
a1568 1
  rela_dyn->add_output_section(os, r_type_1, this, got_offset, 0);
d1571 2
a1572 1
    rela_dyn->add_output_section(os, r_type_2, this, got_offset + size / 8, 0);
d1581 1
a1581 1
    Sized_relobj<size, big_endian>* object,
@


1.162
log
@	* gold/output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.
@
text
@d122 3
a124 1
  return ftruncate(o, offset + len);
d5080 6
a5085 2
  if (writable && ::posix_fallocate(o, 0, this->file_size_) < 0)
    gold_fatal(_("%s: %s"), this->name_, strerror(errno));
@


1.161
log
@	PR gold/13249
	* gold/output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* gold/output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* gold/x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.
@
text
@d4896 21
a4916 11
      ssize_t len = ::read(o, this->base_, s.st_size);
      if (len < 0)
        {
	  gold_info(_("%s: read failed: %s"), base_name, strerror(errno));
	  return false;
        }
      if (len < s.st_size)
        {
	  gold_info(_("%s: file too short"), base_name);
	  return false;
        }
@


1.160
log
@
2011-09-29 Sriraman Tallam  <tmsriram@@google.com>

	* layout.h (section_order_map_): New member.
	(get_section_order_map): New member function.
	* output.cc (Output_section::add_input_section): Check for patterns
	only when --section-ordering-file is specified.
	* gold.cc (queue_middle_tasks): Delay updating order of sections till
	output_sections have been formed.
	* layout.cc (Layout_Layout): Initialize section_order_map_.
	* plugin.cc (update_section_order): Store order in order_map. Do not
	update the order.
	* testsuite/Makefile.am: Add test case for plugin_final_layout.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_section_order.c: New file.
	* testsuite/plugin_final_layout.cc: New file.
	* testsuite/plugin_final_layout.sh: New file.
@
text
@d709 1
a709 1
    is_section_symbol_(false), shndx_(INVALID_CODE)
d730 1
a730 1
    is_section_symbol_(false), shndx_(shndx)
d752 2
a753 1
    bool is_section_symbol)
d756 2
a757 1
    is_section_symbol_(is_section_symbol), shndx_(INVALID_CODE)
d778 2
a779 1
    bool is_section_symbol)
d782 2
a783 1
    is_section_symbol_(is_section_symbol), shndx_(shndx)
d806 1
a806 1
    is_section_symbol_(true), shndx_(INVALID_CODE)
d827 1
a827 1
    is_section_symbol_(true), shndx_(shndx)
d849 1
a849 1
    is_section_symbol_(false), shndx_(INVALID_CODE)
d865 1
a865 1
    is_section_symbol_(false), shndx_(shndx)
d884 1
a884 1
    is_section_symbol_(false), shndx_(INVALID_CODE)
d901 1
a901 1
    is_section_symbol_(false), shndx_(shndx)
d1128 6
@


1.159
log
@	* output.cc (Output_fill_debug_info::do_write): Use Swap_unaligned.
	(Output_fill_debug_line::do_write): Likewise.
@
text
@d2479 4
a2482 1
      if (layout->is_section_ordering_specified())
d3491 1
a3491 1
  const Section_layout_order& order_map)
d3505 2
a3506 2
	    = order_map.find(Section_id(obj, shndx));
	  if (it == order_map.end())
@


1.159.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d122 1
a122 3
  if (ftruncate(o, offset + len) < 0)
    return errno;
  return 0;
d709 1
a709 1
    is_section_symbol_(false), use_plt_offset_(false), shndx_(INVALID_CODE)
d730 1
a730 1
    is_section_symbol_(false), use_plt_offset_(false), shndx_(shndx)
d752 1
a752 2
    bool is_section_symbol,
    bool use_plt_offset)
d755 1
a755 2
    is_section_symbol_(is_section_symbol), use_plt_offset_(use_plt_offset),
    shndx_(INVALID_CODE)
d776 1
a776 2
    bool is_section_symbol,
    bool use_plt_offset)
d779 1
a779 2
    is_section_symbol_(is_section_symbol), use_plt_offset_(use_plt_offset),
    shndx_(shndx)
d802 1
a802 1
    is_section_symbol_(true), use_plt_offset_(false), shndx_(INVALID_CODE)
d823 1
a823 1
    is_section_symbol_(true), use_plt_offset_(false), shndx_(shndx)
d845 1
a845 1
    is_section_symbol_(false), use_plt_offset_(false), shndx_(INVALID_CODE)
d861 1
a861 1
    is_section_symbol_(false), use_plt_offset_(false), shndx_(shndx)
d880 1
a880 1
    is_section_symbol_(false), use_plt_offset_(false), shndx_(INVALID_CODE)
d897 1
a897 1
    is_section_symbol_(false), use_plt_offset_(false), shndx_(shndx)
a1123 6
  if (this->use_plt_offset_)
    {
      uint64_t plt_address =
	  parameters->target().plt_address_for_local(relobj, lsi);
      return plt_address + relobj->local_plt_offset(lsi);
    }
d4883 11
a4893 21
      ssize_t bytes_to_read = s.st_size;
      unsigned char* p = this->base_;
      while (bytes_to_read > 0)
	{
	  ssize_t len = ::read(o, p, bytes_to_read);
	  if (len < 0)
	    {
	      gold_info(_("%s: read failed: %s"), base_name, strerror(errno));
	      return false;
	    }
	  if (len == 0)
	    {
	      gold_info(_("%s: file too short: read only %lld of %lld bytes"),
			base_name,
			static_cast<long long>(s.st_size - bytes_to_read),
			static_cast<long long>(s.st_size));
	      return false;
	    }
	  p += len;
	  bytes_to_read -= len;
	}
d5055 2
a5056 6
  if (writable)
    {
      int err = ::posix_fallocate(o, 0, this->file_size_);
      if (err != 0)
       gold_fatal(_("%s: %s"), this->name_, strerror(err));
    }
@


1.158
log
@	* output.cc: (Output_fill_debug_info::do_minimum_hole_size): Add
	casts to match formatting specs.
	(Output_fill_debug_line::do_minimum_hole_size): Likewise.
@
text
@d1964 3
a1966 3
      elfcpp::Swap<32, true>::writeval(pov, len - 4);
      elfcpp::Swap<16, true>::writeval(pov + 4, this->version);
      elfcpp::Swap<32, true>::writeval(pov + 6, 0);
d1970 3
a1972 3
      elfcpp::Swap<32, false>::writeval(pov, len - 4);
      elfcpp::Swap<16, false>::writeval(pov + 4, this->version);
      elfcpp::Swap<32, false>::writeval(pov + 6, 0);
d2024 3
a2026 3
      elfcpp::Swap<32, true>::writeval(pov, len - 4);
      elfcpp::Swap<16, true>::writeval(pov + 4, this->version);
      elfcpp::Swap<32, true>::writeval(pov + 6, len - (4 + 2 + 4));
d2030 3
a2032 3
      elfcpp::Swap<32, false>::writeval(pov, len - 4);
      elfcpp::Swap<16, false>::writeval(pov + 4, this->version);
      elfcpp::Swap<32, false>::writeval(pov + 6, len - (4 + 2 + 4));
@


1.157
log
@	* layout.cc (Free_list::allocate): Provide guarantee of minimum
	remaining hole size when allocating.
	(Layout::make_output_section): Set fill methods for debug sections.
	* layout.h (Free_list::Free_list_node): Move from private to
	public.
	(Free_list::set_min_hole_size): New function.
	(Free_list::begin, Free_list::end): New functions.
	(Free_list::min_hole_): New data member.
	* output.cc: Include dwarf.h.
	(Output_fill_debug_info::do_minimum_hole_size): New function.
	(Output_fill_debug_info::do_write): New function.
	(Output_fill_debug_line::do_minimum_hole_size): New function.
	(Output_fill_debug_line::do_write): New function.
	(Output_section::Output_section): Initialize new data member.
	(Output_section::set_final_data_size): Ensure patch space is larger
	than minimum hole size.
	(Output_section::do_write): Fill holes in debug sections.
	* output.h (Output_fill): New class.
	(Output_fill_debug_info): New class.
	(Output_fill_debug_line): New class.
	(Output_section::set_free_space_fill): New function.
	(Output_section::free_space_fill_): New data member.
	* testsuite/Makefile.am (incremental_test_3): Add
	--incremental-patch option.
	(incremental_test_4): Likewise.
	(incremental_test_5): Likewise.
	(incremental_test_6): Likewise.
	(incremental_copy_test): Likewise.
	(incremental_common_test_1): Likewise.
	* testsuite/Makefile.in: Regenerate.
@
text
@d1952 2
a1953 1
  gold_debug(DEBUG_INCREMENTAL, "fill_debug_info(%08lx, %08lx)", off, len);
d2009 2
a2010 1
  gold_debug(DEBUG_INCREMENTAL, "fill_debug_line(%08lx, %08lx)", off, len);
@


1.156
log
@2011-07-13  Sriraman Tallam  <tmsriram@@google.com>

	* plugin-api.h
	(ld_plugin_section): New struct.
	(ld_plugin_get_section_count): New typedef.
	(ld_plugin_get_section_type): New typedef.
	(ld_plugin_get_section_name): New typedef.
	(ld_plugin_get_section_contents): New typedef.
	(ld_plugin_update_section_order): New typedef.
	(ld_plugin_allow_section_ordering): New typedef.
	(LDPT_GET_SECTION_COUNT): New enum value.
	(LDPT_GET_SECTION_TYPE): New enum value.
	(LDPT_GET_SECTION_NAME): New enum value.
	(LDPT_GET_SECTION_CONTENTS): New enum value.
	(LDPT_UPDATE_SECTION_ORDER): New enum value.
	(LDPT_ALLOW_SECTION_ORDERING): New enum value.
	(tv_get_section_count): New struct members.
	(tv_get_section_type): New struct members.
	(tv_get_section_name): New struct members.
	(tv_get_section_contents): New struct members.
	(tv_update_section_order): New struct members.
	(tv_allow_section_ordering): New struct members.
	* archive.cc (Archive::get_elf_object_for_member): Add extra parameter
	to claim_file call.
	* layout.cc (Layout::Layout): Initialize section_ordering_specified_,
	input_section_position_, and input_section_glob_.
	(read_layout_from_file): Call function section_ordering_specified.
	* layout.h (is_section_ordering_specified): New function.
	(section_ordering_specified): New function.
	(section_ordering_specified_): New boolean member.
	* main.cc(main): Call load_plugins after layout object is defined.
	* output.cc (Output_section::add_input_section): Use
	function section_ordering_specified to check if section ordering is
	needed.
	* output.cc (Output_section::add_relaxed_input_section): Use
	function section_ordering_specified to check if section ordering is
	needed.
	(Output_section::update_section_layout): New function.
	(Output_section::sort_attached_input_sections): Check if input section
	must be reordered.
	* output.h (Output_section::update_section_layout): New function.
	* plugin.cc (get_section_count): New function.
	(get_section_type): New function.
	(get_section_name): New function.
	(get_section_contents): New function.
	(update_section_order): New function.
	(allow_section_ordering): New function.
	(Plugin::load): Add the new interfaces to the transfer vector.
	(Plugin_manager::load_plugins): New parameter.
	(Plugin_manager::all_symbols_read): New parameter.
	(Plugin_manager::claim_file): New parameter. Save the elf object for
	unclaimed objects.
	(Plugin_manager::get_elf_object): New function.
	(Plugin_manager::get_view): Change to directly use the bool to check
	if get_view is called from claim_file_hook.
	* plugin.h (input_objects): New function
	(Plugin__manager::load_plugins): New parameter.
	(Plugin_manager::claim_file): New parameter.
	(Plugin_manager::get_elf_object): New function.
	(Plugin_manager::in_claim_file_handler): New function.
	(Plugin_manager::in_claim_file_handler_): New member.
	(layout): New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Call the claim_file
	handler with an extra parameter. Make the elf object before calling
	claim_file handler.
	* testsuite/plugin_test.c (get_section_count): New function pointer.
	(get_section_type): New function pointer.
	(get_section_name): New function pointer.
	(get_section_contents): New function pointer.
	(update_section_order): New function pointer.
	(allow_section_ordering): New function pointer.
	(onload): Check if the new interfaces exist.
@
text
@d39 1
d1930 134
d2296 1
d3120 4
a3123 1
      off_t extra = static_cast<off_t>(data_size * pct);
d3657 20
@


1.155
log
@	PR gold/12372
	* target.h (Target::plt_address_for_global): New function.
	(Target::plt_address_for_local): New function.
	(Target::plt_section_for_global): Remove.
	(Target::plt_section_for_local): Remove.
	(Target::do_plt_address_for_global): New virtual function.
	(Target::do_plt_address_for_local): New virtual function.
	(Target::do_plt_section_for_global): Remove.
	(Target::do_plt_section_for_local): Remove.
	(Target::register_global_plt_entry): Add Symbol_table and Layout
	parameters.
	* output.cc (Output_data_got::Got_entry::write): Use
	plt_address_for_global and plt_address_for_local.
	* layout.cc (Layout::add_target_dynamic_tags): Use size and
	address of output section.
	* i386.cc (class Output_data_plt_i386): Add irelative_rel_,
	got_irelative_, and irelative_count_ fields.  Update
	declarations.
	(Output_data_plt_i386::has_irelative_section): New function.
	(Output_data_plt_i386::entry_count): Add irelative_count_.
	(Output_data_plt_i386::set_final_data_size): Likewise.
	(class Target_i386): Add got_irelative_ and rel_irelative_
	fields.  Update declarations.
	(Target_i386::Target_i386): Initialize new fields.
	(Target_i386::do_plt_address_for_global): New function replacing
	do_plt_section_for_global.
	(Target_i386::do_plt_address_for_local): New function replacing
	do_plt_section_for_local.
	(Target_i386::got_section): Create got_irelative_.
	(Target_i386::rel_irelative_section): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize new
	fields.  Don't define __rel_iplt_{start,end}.
	(Output_data_plt_i386::add_entry): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): Add symtab and
	layout parameters.  Change all callers.  Use different PLT and
	GOT.
	(Output_data_plt_i386::rel_tls_desc): Fix formatting.
	(Output_data_plt_i386::rel_irelative): New function.
	(Output_data_plt_i386::address_for_global): New function.
	(Output_data_plt_i386::address_for_local): New function.
	(Output_data_plt_i386::do_write): Write out IRELATIVE area.  Use
	IRELATIVE GOT when changing IFUNC GOT entries.
	(Target_i386::Scan::global): Use IRELATIVE GOT for IRELATIVE
	reloc.
	(Target_i386::do_finalize_sections): Create the __rel_iplt symbols
	if we didn't create an IRELATIVE GOT.
	(Target_i386::Relocate::relocate): Use plt_address_for_global and
	plt_address_for_local.
	(Target_i386::do_dynsym_value): Use plt_address_for_global.
	* x86_64.cc (class Output_data_plt_x86_64): Add irelative_rel_,
	got_irelative_, and irelative_count_ fields.  Update
	declarations.
	(Output_data_plt_x86_64::Output_data_plt_x86_64) [both versions]:
	Initialize new fields.  Remove symtab parameter.  Change all
	callers.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset): Add
	irelative_count_.
	(Output_data_plt_x86_64::has_irelative_section): New function.
	(Output_data_plt_x86_64::entry_count): Add irelative_count_.
	(class Target_x86_64): Add got_irelative_ and rel_irelative_
	fields.  Update declarations.
	(Target_x86_64::Target_x86_64): Initialize new fields.
	(Target_x86_64::do_plt_address_for_global): New function replacing
	do_plt_section_for_global.
	(Target_x86_64::do_plt_address_for_local): New function replacing
	do_plt_section_for_local.
	(Target_x86_64::got_section): Create got_irelative_.
	(Target_x86_64::rela_irelative_section): New function.
	(Output_data_plt_x86_64::init): Remove symtab parameter.  Change
	all callers.  Don't create __rel_iplt_{start,end}.
	(Output_data_plt_x86_64::add_entry): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Add symtab and
	layout parameters.  Change all callers.  Use different PLT and
	GOT.
	(Output_data_plt_x86_64::add_relocation): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_x86_64::rela_tlsdesc): Fix formatting.
	(Output_data_plt_x86_64::rela_irelative): New function.
	(Output_data_plt_x86_64::address_for_global): New function.
	(Output_data_plt_x86_64::address_for_local): New function.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::do_write): Write out IRELATIVE area.
	(Target_x86_64::init_got_plt_for_update): Create got_irelative_.
	(Target_x86_64::register_global_plt_entry): Add symtab and layout
	parameters.
	(Target_x86_64::Scan::global): Use IRELATIVE GOT for IRELATIVE
	reloc.
	(Target_x86_64::do_finalize_sections): Create the __rela_iplt
	symbols if we didn't create an IRELATIVE GOT.
	(Target_x86_64::Relocate::relocate): Use plt_address_for_global and
	plt_address_for_local.
	(Target_x86_64::do_dynsym_value): Use plt_address_for_global.
	* testsuite/ifuncvar1.c: New test file.
	* testsuite/ifuncvar2.c: New test file.
	* testsuite/ifuncvar3.c: New test file.
	* testsuite/Makefile.am (check_PROGRAMS): Add ifuncvar.
	(ifuncvar1_pic.o, ifuncvar2_pic.o, ifuncvar.so): New targets.
	(ifuncvar_SOURCES, ifuncvar_DEPENDENCIES): New variables.
	(ifuncvar_LDFLAGS, ifuncvar_LDADD): New variables.
	* testsuite/Makefile.in: Rebuild.
@
text
@d2299 1
a2299 1
          || parameters->options().section_ordering_file()))
d2338 1
a2338 1
      || parameters->options().section_ordering_file())
d2341 1
a2341 1
      if (parameters->options().section_ordering_file())
d2424 1
a2424 1
  if (parameters->options().section_ordering_file())
d3342 32
d3416 1
a3416 1
      gold_assert(parameters->options().section_ordering_file());
@


1.154
log
@	* incremental.cc (Incremental_inputs::report_command_line): Ignore
	--incremental-patch option.
	* layout.cc (Free_list::allocate): Extend allocation beyond original
	end if enabled.
	(Layout::make_output_section): Mark sections that should get
	patch space.
	* options.cc (parse_percent): New function.
	* options.h (parse_percent): New function.
	(DEFINE_percent): New macro.
	(General_options): Add --incremental-patch option.
	* output.cc (Output_section::Output_section): Initialize new data
	members.
	(Output_section::add_input_section): Print section name when out
	of patch space.
	(Output_section::add_output_section_data): Likewise.
	(Output_section::set_final_data_size): Add patch space when
	doing --incremental-full.
	(Output_section::do_reset_address_and_file_offset): Remove patch
	space.
	(Output_segment::set_section_list_addresses): Print debug output
	only if --incremental-update.
	* output.h (Output_section::set_is_patch_space_allowed): New function.
	(Output_section::is_patch_space_allowed_): New data member.
	(Output_section::patch_space_): New data member.
	* parameters.cc (Parameters::incremental_full): New function.
	* parameters.h (Parameters::incremental_full): New function
	* testsuite/Makefile.am (incremental_test_2): Add test for
	--incremental-patch option.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/two_file_test_1_v1.cc (t1, t2, t3): Add comments.
	(t18): Remove function body.
@
text
@d1350 1
a1350 1
	  val = (parameters->target().plt_section_for_global(gsym)->address()
d1384 3
a1386 3
	    const Output_data* plt =
	      parameters->target().plt_section_for_local(object, lsi);
	    val = plt->address() + object->local_plt_offset(lsi);
@


1.153
log
@	PR gold/12695
	* layout.cc (Layout::symtab_section_shndx): New function.
	* layout.h (class Layout): Declare symtab_section_shndx.
	* output.cc (Output_section::write_header): Call it.
@
text
@d2156 1
d2160 2
a2161 1
    free_list_()
d2276 3
a2278 1
        gold_fallback(_("out of patch space; relink with --incremental-full"));
d2382 3
a2384 2
	    gold_fallback(_("out of patch space; "
			    "relink with --incremental-full"));
d2954 2
d2957 2
d2960 17
a2976 2
      this->set_data_size(this->current_data_size_for_child());
      return;
d2979 3
a2981 10
  if (this->must_sort_attached_input_sections()
      || this->input_section_order_specified())
    this->sort_attached_input_sections();

  uint64_t address = this->address();
  off_t startoff = this->offset();
  off_t off = startoff + this->first_input_offset_;
  for (Input_section_list::iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
d2983 10
a2992 4
      off = align_address(off, p->addralign());
      p->set_address_and_file_offset(address + (off - startoff), off,
				     startoff);
      off += p->data_size();
d2995 1
a2995 1
  this->set_data_size(off - startoff);
d3014 8
d3023 1
a3023 1
  
d4299 7
a4305 6
      gold_debug(DEBUG_INCREMENTAL,
		 "set_section_list_addresses: %08lx %08lx %s",
		 static_cast<long>(off),
		 static_cast<long>((*p)->data_size()),
		 ((*p)->output_section() != NULL
		  ? (*p)->output_section()->name() : "(special)"));
d4307 1
a4307 1
      // We want to ignore the size of a SHF_TLS or SHT_NOBITS
@


1.152
log
@	PR gold/12910
	* options.h (class General_options): Add --ctors-in-init-array.
	* layout.cc (Layout::get_output_section): Treat SHT_INIT_ARRAY and
	friends as SHT_PROGBITS for merging sections.
	(Layout::layout): Remove special handling of .init_array and
	friends.  Don't sort if doing relocatable link.  Sort for .ctors
	and .dtors if ctors_in_init_array.
	(Layout::make_output_section): Force correct section types for
	.init_array and friends.  Don't sort if doing relocatable link,
	Don't sort .ctors and .dtors if ctors_in_init_array.
	(Layout::section_name_mapping): Remove .ctors. and .dtorso.
	(Layout::output_section_name): Add relobj parameter.  Change all
	callers.  Handle .ctors. and .dtors. in code rather than table.
	Handle .ctors and .dtors if ctors_in_init_array.
	(Layout::match_file_name): New function, moved from output.cc.
	* layout.h (class Layout): Update declarations.
	* output.cc: Include "layout.h".
	(Input_section_sort_entry::get_priority): New function.
	(Input_section_sort_entry::match_file_name): Just call
	Layout::match_file_name.
	(Output_section::Input_section_sort_init_fini_compare::operator()):
	Handle .ctors and .dtors.  Sort by explicit priority rather than
	by name.
	* configure.ac: Remove CONSTRUCTOR_PRIORITY test and conditional.
	* testsuite/initpri2.c: New test.
	* testsuite/Makefile.am: Don't test CONSTRUCTOR_PRIORITY.
	(check_PROGRAMS): Add initpri2.
	(initpri2_SOURCES, initpri2_DEPENDENCIES): New variables.
	(initpri2_LDFLAGS, initpri2_LDADD): New variables.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d3393 1
a3393 1
    oshdr->put_sh_link(layout->symtab_section()->out_shndx());
@


1.151
log
@	* common.cc (Symbol_table::do_allocate_commons_list): Call
	gold_fallback.
	* errors.cc (Errors::fatal): Adjust call to gold_exit.
	(Errors::fallback): New function.
	(gold_fallback): New function.
	* errors.h (Errors::fallback): New function.
	* gold.cc (gold_exit): Change status parameter to enum; adjust
	all callers.
	(queue_initial_tasks): Call gold_fallback.
	* gold.h: Include cstdlib.
	(Exit_status): New enum type.
	(gold_exit): Change status parameter to enum.
	(gold_fallback): New function.
	* layout.cc (Layout::set_section_offsets): Call gold_fallback.
	(Layout::create_symtab_sections): Likewise.
	(Layout::create_shdrs): Likewise.
	* main.cc (main): Adjust call to gold_exit.
	* output.cc (Output_data_got::add_got_entry): Call gold_fallback.
	(Output_data_got::add_got_entry_pair): Likewise.
	(Output_section::add_input_section): Likewise.
	(Output_section::add_output_section_data): Likewise.
	(Output_segment::set_section_list_addresses): Likewise.
	* x86_64.cc (Output_data_plt_x86_64::add_entry): Likewise.
@
text
@d45 1
d3021 1
a3021 1
// attached input section matching ".ctor.*", ".dtor.*",
d3096 28
d3132 2
a3133 12
  match_file_name(const char* match_file_name) const
  {
    const std::string& file_name(this->input_section_.relobj()->name());
    const char* base_name = lbasename(file_name.c_str());
    size_t match_len = strlen(match_file_name);
    if (strncmp(base_name, match_file_name, match_len) != 0)
      return false;
    size_t base_len = strlen(base_name);
    if (base_len != match_len + 2 && base_len != match_len + 3)
      return false;
    return memcmp(base_name + base_len - 2, ".o", 2) == 0;
  }
d3255 22
@


1.150
log
@	* layout.cc (Layout::set_segment_offsets): Don't adjust layout
	for incremental links.
	* output.cc (Output_segment::set_section_list_addresses): Remove
	FIXME and test for TLS or BSS.
@
text
@d1708 2
a1709 2
	gold_fatal(_("out of patch space (GOT);"
		     " relink with --incremental-full"));
d1738 2
a1739 2
	gold_fatal(_("out of patch space (GOT);"
		     " relink with --incremental-full"));
d2273 1
a2273 1
        gold_fatal(_("out of patch space; relink with --incremental-full"));
d2377 2
a2378 1
	    gold_fatal(_("out of patch space; relink with --incremental-full"));
d4174 3
a4176 3
		  gold_fatal(_("out of patch space for section %s; "
			       "relink with --incremental-full"),
			     (*p)->output_section()->name());
d4182 3
a4184 3
		  gold_fatal(_("%s: section changed size; "
			       "relink with --incremental-full"),
			     (*p)->output_section()->name());
@


1.149
log
@	* common.cc (Symbol_table::do_allocate_commons_list): For incremental
	update, allocate common from bss section's free list.
	* incremental-dump.cc (dump_incremental_inputs): Print flag for
	linker-defined symbols.
	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Skip GOT and PLT entries that are no longer referenced.
	(Output_section_incremental_inputs::write_info_blocks): Mark
	linker-defined symbols.
	(Sized_incr_relobj::do_add_symbols): Process linker-defined symbols.
	* output.cc (Output_section::allocate): New function.
	* output.h (Output_section::allocate): New function.
	* resolve.cc (Symbol_table::report_resolve_problem): Add case for
	linker-defined symbols.
	(Symbol::override_base_with_special): Copy is_predefined_ flag.
	* symtab.cc (Symbol::init_fields): Initialize is_predefined_ flag.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* symtab.h (Symbol::is_predefined): New function.
	(Symbol::init_base_output_data): Add is_predefined parameter.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::is_predefined_): New data member.
	(Sized_symbol::init_output_data): Add is_predefined parameter.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(enum Symbol_table::Defined): Add INCREMENTAL_BASE.
@
text
@d4159 1
a4159 4
	  // FIXME: Need to handle TLS and .bss with incremental update.
	  if (!parameters->incremental_update()
	      || (*p)->is_section_flag_set(elfcpp::SHF_TLS)
	      || (*p)->is_section_type(elfcpp::SHT_NOBITS))
@


1.148
log
@Fix spelling mistakes.
@
text
@d3729 1
d3736 9
@


1.147
log
@	* archive.cc (Library_base::should_include_member): Pull in object
	from archive if it defines the entry symbol.
	* parameters.cc (Parameters::entry): New function.
	* parameters.h (class Parameters): Declare entry.
	* output.h (class Output_file_header): Remove entry_ field.
	* output.cc (Output_file_header::Output_file_header): Remove entry
	parameter.  Change all callers.
	(Output_file_header::entry): Use parameters->entry.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (Plugin_hook::run): Likewise.
@
text
@d482 1
a482 1
// Write out the file header with appropriate size and endianess.
@


1.146
log
@	* gold.cc (queue_initial_tasks): Pass incremental base filename
	to Output_file::open_base_file; don't print error message.
	* incremental-dump.cc (main): Adjust call to
	Output_file::open_for_modification.
	* incremental-dump.cc (main): Likewise.
	* incremental.cc (Incremental_inputs::report_command_line):
	Ignore --incremental-base option when comparing command lines.
	Ignore parameter when given as separate argument.
	* options.h (class General_options): Add --incremental-base.
	* output.cc (Output_file::Output_file):
	(Output_file::open_base_file): Add base_name and writable parameters;
	read base file into new file; print error message here.
	(Output_file::map_no_anonymous): Add writable parameter; adjust all
	callers.
	* output.h (Output_file::open_for_modification): Rename to...
	(Output_file::open_base_file): ...this; add base_name and
	writable parameters; adjust all callers.
	(Output_file::map_no_anonymous): Add writable parameter; adjust all
	callers.
	* testsuite/Makefile.am (incremental_test_4): Test
	--incremental-base.
	* testsuite/Makefile.in: Regenerate.
@
text
@d428 1
a428 2
				       const Output_segment_headers* osh,
				       const char* entry)
d433 1
a433 2
    shstrtab_(NULL),
    entry_(entry)
d573 1
a573 2
// Return the value to use for the entry address.  THIS->ENTRY_ is the
// symbol specified on the command line, if any.
d579 1
a579 1
  const bool should_issue_warning = (this->entry_ != NULL
d582 1
a582 6

  // FIXME: Need to support target specific entry symbol.
  const char* entry = this->entry_;
  if (entry == NULL)
    entry = "_start";

@


1.145
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d4565 6
a4570 1
// exist, has a size of 0 or can't be mmapped.
d4573 1
a4573 1
Output_file::open_for_modification()
d4579 7
d4588 14
a4601 2
  if (::stat(this->name_, &s) != 0 || s.st_size == 0)
    return false;
d4603 2
a4604 1
  int o = open_descriptor(-1, this->name_, O_RDWR, 0);
d4606 26
a4631 1
    gold_fatal(_("%s: open: %s"), this->name_, strerror(errno));
d4635 1
a4635 5
  // If the file can't be mmapped, copying the content to an anonymous
  // map will probably negate the performance benefits of incremental
  // linking.  This could be helped by using views and loading only
  // the necessary parts, but this is not supported as of now.
  if (!this->map_no_anonymous())
d4737 1
a4737 1
      if (!this->map_no_anonymous())
d4764 1
d4767 1
a4767 1
Output_file::map_no_anonymous()
d4789 1
a4789 1
  if (::posix_fallocate(o, 0, this->file_size_) < 0)
d4793 4
a4796 2
  base = ::mmap(NULL, this->file_size_, PROT_READ | PROT_WRITE,
		MAP_SHARED, o, 0);
d4814 1
a4814 1
  if (this->map_no_anonymous())
@


1.144
log
@	* gold.cc (queue_middle_tasks): Process existing GOT/PLT entries.
	* incremental-dump.cc (dump_incremental_inputs): Mask high-order
	bit when checking got_type.
	* incremental.cc (Sized_incremental_binary::setup_readers):
	Store symbol table and string table locations; initialize bit vector
	of file status flags.
	(Sized_incremental_binary::do_reserve_layout): Set bit flag for
	unchanged files.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::get_symtab_view): Use stored locations.
	(Output_section_incremental_inputs::set_final_data_size): Record
	file index for each input file.
	(Output_section_incremental_inputs::write_got_plt): Store file index
	instead of input entry offset for each GOT entry.
	* incremental.h
	(Incremental_input_entry::Incremental_input_entry): Initialize new
	data member.
	(Incremental_input_entry::set_offset): Store file index.
	(Incremental_input_entry::get_file_index): New function.
	(Incremental_input_entry::file_index_): New data member.
	(Incremental_binary::process_got_plt): New function.
	(Incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data members.
	(Sized_incremental_binary::~Sized_incremental_binary): New destructor.
	(Sized_incremental_binary::set_file_is_unchanged): New function.
	(Sized_incremental_binary::file_is_unchanged): New function.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::file_status_): New data member.
	(Sized_incremental_binary::main_symtab_loc_): New data member.
	(Sized_incremental_binary::main_strtab_loc_): New data member.
	* output.cc (Output_data_got::Got_entry::write): Add case
	RESERVED_CODE.
	(Output_data_got::add_global): Call add_got_entry.
	(Output_data_got::add_global_plt): Likewise.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_global_pair_with_rela): Likewise.
	(Output_data_got::add_local): Call add_got_entry.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_local_pair_with_rela): Likewise.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_section::add_output_section_data): Edit FIXME.
	* output.h
	(Output_section_data_build::Output_section_data_build): New
	constructor with size parameter.
	(Output_data_space::Output_data_space): Likewise.
	(Output_data_got::Output_data_got): Initialize new data member; new
	constructor with size parameter.
	(Output_data_got::add_constant): Call add_got_entry.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(class Output_data_got::Got_entry): Add RESERVED_CODE.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_data_got::free_list_): New data member.
	* target.h (Sized_target::init_got_plt_for_update): New function.
	(Sized_target::register_global_plt_entry): New function.
	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Initialize new data member; call init; add constructor with PLT count.
	(Output_data_plt_x86_64::init): New function.
	(Output_data_plt_x86_64::add_relocation): New function.
	(Output_data_plt_x86_64::reserve_slot): New function.
	(Output_data_plt_x86_64::free_list_): New data member.
	(Target_x86_64::init_got_plt_for_update): New function.
	(Target_x86_64::register_global_plt_entry): New function.
	(Output_data_plt_x86_64::add_entry): Allocate from free list for
	incremental updates.
	(Output_data_plt_x86_64::add_relocation): New function.
	* testsuite/object_unittest.cc (Object_test): Set default options.
@
text
@d944 3
d948 1
a948 1
          this->u1_.relobj->set_needs_output_dynsym_entry(lsi);
d950 1
a950 1
          this->u1_.relobj->output_section(lsi)->set_needs_dynsym_index();
d1000 3
d1006 1
a1006 1
              index = this->u1_.relobj->dynsym_index(lsi);
d1008 1
a1008 1
              index = this->u1_.relobj->symtab_index(lsi);
d1012 1
a1012 1
            Output_section* os = this->u1_.relobj->output_section(lsi);
d1047 4
a1050 1
  offset = os->output_address(this->u1_.relobj, lsi, addend);
d1071 4
a1074 2
	  address = os->output_address(this->u2_.relobj, this->shndx_,
				       address);
d1127 5
a1131 2
  const Symbol_value<size>* symval = this->u1_.relobj->local_symbol(lsi);
  return symval->value(this->u1_.relobj, addend);
d1282 1
a1282 1
    Sized_relobj<size, big_endian>* relobj,
d1384 1
a1384 1
	const Sized_relobj<size, big_endian>* object = this->u_.object;
d1522 1
a1522 1
    Sized_relobj<size, big_endian>* object,
d1540 1
a1540 1
    Sized_relobj<size, big_endian>* object,
d1559 1
a1559 1
    Sized_relobj<size, big_endian>* object,
d1576 1
a1576 1
    Sized_relobj<size, big_endian>* object,
d1596 1
a1596 1
    Sized_relobj<size, big_endian>* object,
d1621 1
a1621 1
    Sized_relobj<size, big_endian>* object,
d1647 5
a1651 1
Output_data_got<size, big_endian>::reserve_slot(unsigned int i)
d1653 2
a1654 1
  this->free_list_.remove(i * size / 8, (i + 1) * size / 8);
d1661 1
a1661 1
Output_data_got<size, big_endian>::reserve_slot_for_global(
d1666 1
a1666 1
  this->free_list_.remove(i * size / 8, (i + 1) * size / 8);
d2211 1
a2211 1
				  Sized_relobj<size, big_endian>* object,
d4843 1
a4843 1
    Sized_relobj<32, false>* object,
d4856 1
a4856 1
    Sized_relobj<32, true>* object,
d4869 1
a4869 1
    Sized_relobj<64, false>* object,
d4882 1
a4882 1
    Sized_relobj<64, true>* object,
@


1.143
log
@	* descriptors.cc (set_close_on_exec): New function.
	(Descriptors::open): Use set_close_on_exec.
	* output.cc (S_ISLNK): Define if not defined.
@
text
@d1361 7
d1403 2
a1404 3
  this->entries_.push_back(Got_entry(gsym, false));
  this->set_got_size();
  gsym->set_got_offset(got_type, this->last_got_offset());
d1418 2
a1419 3
  this->entries_.push_back(Got_entry(gsym, true));
  this->set_got_size();
  gsym->set_got_offset(got_type, this->last_got_offset());
d1437 1
a1437 3
  this->entries_.push_back(Got_entry());
  this->set_got_size();
  unsigned int got_offset = this->last_got_offset();
d1453 1
a1453 3
  this->entries_.push_back(Got_entry());
  this->set_got_size();
  unsigned int got_offset = this->last_got_offset();
d1473 1
a1473 2
  this->entries_.push_back(Got_entry());
  unsigned int got_offset = this->last_got_offset();
a1476 1
  this->entries_.push_back(Got_entry());
d1478 1
a1478 6
    {
      got_offset = this->last_got_offset();
      rel_dyn->add_global(gsym, r_type_2, this, got_offset);
    }

  this->set_got_size();
d1493 1
a1493 2
  this->entries_.push_back(Got_entry());
  unsigned int got_offset = this->last_got_offset();
a1496 1
  this->entries_.push_back(Got_entry());
d1498 1
a1498 6
    {
      got_offset = this->last_got_offset();
      rela_dyn->add_global(gsym, r_type_2, this, got_offset, 0);
    }

  this->set_got_size();
d1515 3
a1517 3
  this->entries_.push_back(Got_entry(object, symndx, false));
  this->set_got_size();
  object->set_local_got_offset(symndx, got_type, this->last_got_offset());
d1533 3
a1535 3
  this->entries_.push_back(Got_entry(object, symndx, true));
  this->set_got_size();
  object->set_local_got_offset(symndx, got_type, this->last_got_offset());
d1554 1
a1554 3
  this->entries_.push_back(Got_entry());
  this->set_got_size();
  unsigned int got_offset = this->last_got_offset();
d1571 1
a1571 3
  this->entries_.push_back(Got_entry());
  this->set_got_size();
  unsigned int got_offset = this->last_got_offset();
d1593 3
a1595 2
  this->entries_.push_back(Got_entry());
  unsigned int got_offset = this->last_got_offset();
a1599 1
  this->entries_.push_back(Got_entry(object, symndx, false));
d1601 1
a1601 6
    {
      got_offset = this->last_got_offset();
      rel_dyn->add_output_section(os, r_type_2, this, got_offset);
    }

  this->set_got_size();
d1618 3
a1620 2
  this->entries_.push_back(Got_entry());
  unsigned int got_offset = this->last_got_offset();
a1624 1
  this->entries_.push_back(Got_entry(object, symndx, false));
d1626 13
a1638 4
    {
      got_offset = this->last_got_offset();
      rela_dyn->add_output_section(os, r_type_2, this, got_offset, 0);
    }
d1640 9
a1648 1
  this->set_got_size();
d1680 57
d2390 2
a2391 1
      // FIXME: Mark *POSD as part of a fixed-layout section.
@


1.142
log
@	* configure.ac: Check for sys/mman.h and mmap.  Check for mremap
	with MREMAP_MAYMOVE.
	* output.h (class Output_file): Add map_is_allocated_ field.
	* output.cc: Only #include <sys/mman.h> if it exists.  If mmap is
	not available, provide stubs.  If mremap is not available, #define
	it to gold_mremap.
	(MREMAP_MAYMOVE): Define if not defined.
	(Output_file::Output_file): Initialize map_is_allocated_.
	(Output_file::resize): Check map_is_allocated_.
	(Output_file::map_anonymous): If mmap fails, use malloc.
	(Output_file::unmap): Don't do anything for an anonymous map.
	* fileread.cc: Only #include <sys/mman.h> if it exists.  If mmap
	is not available, provide stubs.
	(File_read::View::~View): Use free rather than delete[].
	(File_read::make_view): Use malloc rather than new[].  If mmap
	fails, use malloc.
	(File_read::find_or_make_view): Use malloc rather than new[].
	* gold.h: Remove HAVE_REMAP code.
	* mremap.c: #include <errno.h>.  Only #include <sys/mman.h> if it
	exists.  Rename mremap to gold_mremap.  If mmap is not available
	don't do anything.
	* configure, config.in: Rebuild.
@
text
@d124 5
@


1.141
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
a29 1
#include <sys/mman.h>
d32 5
d47 56
d108 4
d4482 1
d4590 17
a4606 4
      void* base = ::mremap(this->base_, this->file_size_, file_size,
                            MREMAP_MAYMOVE);
      if (base == MAP_FAILED)
        gold_fatal(_("%s: mremap: %s"), this->name_, strerror(errno));
d4627 1
a4627 1
  if (base != MAP_FAILED)
d4629 5
a4633 3
      this->map_is_anonymous_ = true;
      this->base_ = static_cast<unsigned char*>(base);
      return true;
d4635 3
a4637 1
  return false;
d4709 10
a4718 2
  if (::munmap(this->base_, this->file_size_) < 0)
    gold_error(_("%s: munmap: %s"), this->name_, strerror(errno));
@


1.140
log
@2011-02-11  Sriraman Tallam  <tmsriram@@google.com>

	* output.cc (Output_section::add_input_section): Delay fill
	generation for section ordering.
@
text
@d283 1
d1798 15
d2022 1
d2025 2
a2026 1
    lookup_maps_(new Output_section_lookup_maps)
d2107 1
d2110 2
a2111 1
      && shdr.get_sh_size() > 0)
d2128 24
a2151 3
  off_t offset_in_section = this->current_data_size_for_child();
  off_t aligned_offset_in_section = align_address(offset_in_section,
                                                  addralign);
a2187 8
  section_size_type input_section_size = shdr.get_sh_size();
  section_size_type uncompressed_size;
  if (object->section_is_compressed(shndx, &uncompressed_size))
    input_section_size = uncompressed_size;

  this->set_current_data_size_for_child(aligned_offset_in_section
					+ input_section_size);

d2214 8
d2238 32
a2269 5
      off_t offset_in_section = this->current_data_size_for_child();
      off_t aligned_offset_in_section = align_address(offset_in_section,
						      posd->addralign());
      this->set_current_data_size_for_child(aligned_offset_in_section
					    + posd->data_size());
d2784 24
d3578 24
d3811 1
a3811 1
Output_segment::set_section_addresses(const Layout* layout, bool reset,
d3958 1
a3958 1
Output_segment::set_section_list_addresses(const Layout* layout, bool reset,
d3965 3
d3977 2
a3978 2
      // When using a linker script the section will most likely
      // already have an address.
d4016 30
a4045 2
	  off = align_address(off, align);
	  (*p)->set_address_and_file_offset(addr + (off - startoff), off);
d4047 6
d4086 7
d4100 3
d4110 2
a4111 2
  *poff = off;
  return addr + (off - startoff);
d4195 9
a4203 1
      gold_assert(segment_end == align_address(segment_end, page_align));
@


1.139
log
@	* output.h (Output_segment::set_section_addresses): Pass increase_relro
	by reference; adjust all callers.
	* output.cc (Output_segment::set_section_addresses): Adjust references
	to increase_relro. Add padding to *increase_relro when ORDER_RELRO_LAST
	list is empty.
	(Output_segment::set_offset): Assert if PT_GNU_RELRO segment does not
	end at page boundary.
@
text
@d2114 2
a2115 1
  // generating to avoid adjusting them during relaxation.
d2120 2
a2121 1
      && parameters->target().may_relax())
@


1.138
log
@	PR gold/12220
	* layout.cc (Layout::choose_output_section): Transform names of
	compressed sections even when using a script with a SECTIONS clause.
	(Layout::output_section_name): Remove code to transform
	compressed debug section names.
	* output.cc (Output_section::add_input_section): Use uncompressed
	section size when tracking input sections.
@
text
@d3695 1
a3695 1
				      unsigned int increase_relro,
d3755 1
a3755 1
      relro_size += increase_relro;
d3798 7
d4024 9
@


1.137
log
@2010-10-29  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_outout_section::fix_exidx_coverage): Adjust call to
	Output_section::add_relaxed_input_section.
	* output.cc (Output_section::add_relaxed_input_section): Add new
	arguments LAYOUT and NAME.  Set section order index.
	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Copy section order index.
	* output.h (Output_section::add_relaxed_input_section): Add new
	arguments LAYOUT and NAME.
@
text
@d2168 1
a2168 1
      Input_section isecn(object, shndx, shdr.get_sh_size(), addralign);
@


1.137.2.1
log
@Merge from trunk:

Changes by:	ccoutant@@sourceware.org	2010-11-16 19:18:31

Modified files:
	gold           : ChangeLog layout.cc output.cc output.h

Log message:
	* output.h (Output_segment::set_section_addresses): Pass increase_relro
	by reference; adjust all callers.
	* output.cc (Output_segment::set_section_addresses): Adjust references
	to increase_relro. Add padding to *increase_relro when ORDER_RELRO_LAST
	list is empty.
	(Output_segment::set_offset): Assert if PT_GNU_RELRO segment does not
	end at page boundary.
@
text
@d3695 1
a3695 1
				      unsigned int* increase_relro,
d3755 1
a3755 1
      relro_size += *increase_relro;
a3797 7
	  if (this->output_lists_[i].empty())
	    {
	      // If there is nothing in the ORDER_RELRO_LAST list,
	      // the padding will occur at the end of the relro
	      // segment, and we need to add it to *INCREASE_RELRO.
	      *increase_relro += last_relro_pad;
	    }
a4016 9
  // If this is a RELRO segment, verify that the segment ends at a
  // page boundary.
  if (this->type_ == elfcpp::PT_GNU_RELRO)
    {
      uint64_t page_align = parameters->target().common_pagesize();
      uint64_t segment_end = this->vaddr_ + this->memsz_;
      gold_assert(segment_end == align_address(segment_end, page_align));
    }

@


1.136
log
@	* output.h (Output_segment::set_section_addresses): Change function
	signature.  Update all callers.
	* output.cc (Output_segment::is_first_section_relro): Ignore TLS
	sections.
	(Output_segment::set_section_addresses): Align after last TLS
	section.  Add padding before last relro section instead of after.
@
text
@d2206 3
a2208 1
Output_section::add_relaxed_input_section(Output_relaxed_input_section* poris)
d2211 14
d2392 5
d2398 1
@


1.135
log
@	* layout.cc (Layout::set_segment_offsets): Don't try to realign data
	segment that has been aligned for relro.
	* output.cc (Output_segment::set_section_addresses): Change signature;
	adjust all callers.  Account for alignment when totalling
	size of relro sections.
	* output.h (Output_segment::set_section_addresses): Change signature.
	* testsuite/Makefile.am (relro_test.sh, relro_test.stdout): New
	targets.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/relro_test.cc: Add alignment attributes to test proper
	alignment of relro sections when padding is necessary.
	* testsuite/relro_test.sh: New script.
@
text
@d3578 2
a3579 1
// Return whether the first data section is a relro section.
d3586 3
d3663 6
a3668 8
// *PINCREASE_RELRO is the size of the portion of the first non-relro
// section that should be included in the PT_GNU_RELRO segment; if
// there is alignment padding between the last relro section and the
// next section, we add that padding to that size and return the
// updated value.  If this segment has relro sections, and has been
// aligned for that purpose, set *HAS_RELRO to TRUE.
// Return the address of the immediately following segment.  Update
// *PINCREASE_RELRO, *HAS_RELRO, *POFF, and *PSHNDX.
d3673 1
a3673 1
				      unsigned int* pincrease_relro,
d3683 2
d3694 1
a3694 1
      for (int i = 0; i < static_cast<int>(ORDER_MAX); ++i)
a3701 3
	      Output_section* pos = (*p)->output_section();
	      if (!pos->is_relro())
		break;
d3705 9
d3715 4
d3733 1
a3733 1
      relro_size += *pincrease_relro;
a3738 2
      // Adjust *PINCREASE_RELRO to include the padding.
      *pincrease_relro += last_relro_pad;
d3764 1
a3764 1
  bool in_tls = false;
a3771 3
      addr = this->set_section_list_addresses(layout, reset,
					      &this->output_lists_[i],
					      addr, poff, pshndx, &in_tls);
d3777 3
@


1.134
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d3659 6
d3666 1
a3666 1
// *POFF and *PSHNDX.
d3671 2
a3672 1
				      unsigned int increase_relro,
d3678 1
d3689 1
d3701 4
d3719 9
a3727 1
      relro_size += increase_relro;
d3732 1
a3732 1
      uint64_t desired_align = page_align - (relro_size % page_align);
d3763 5
@


1.133
log
@	PR 10893
	* i386.cc (class Output_data_plt_i386): Update declarations.
	Define Global_ifunc and Local_ifunc types.  Add global_ifuncs_ and
	local_ifuncs_ fields.
	(Target_i386::do_plt_section_for_global): New function.
	(Target_i386::do_plt_section_for_local): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Add symtab
	parameter; change all callers.  Initialize global_ifuncs_ and
	local_ifuncs_.  If doing a static link define __rel_iplt_start and
	__rel_iplt_end.
	(Output_data_plt_i386::add_entry): Handle IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): New function.
	(Output_data_plt_i386::do_write): Fix GOT entries for IFUNC
	symbols.
	(Target_i386::make_plt_section): New function, broken out of
	make_plt_entry.  Set sh_info field of .rel.plt to point to .plt.
	(Target_i386::make_plt_entry): Call make_plt_section.
	(Target_i386::make_local_ifunc_plt_entry): New function.
	(Target_i386::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_i386::Scan::local): Handle IFUNC symbols.  Add
	R_386_IRELATIVE to switch.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocatable_size_for_reloc): Add R_386_IRELATIVE to
	switch.
	* x86_64.cc (class Output_data_plt_x86_64): Update declarations.
	(Target_x86_64::do_plt_section_for_global): New function.
	(Target_x86_64::do_plt_section_for_local): New function.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Add symtab
	parameter; change all callers.  If doing a static link define
	__rela_iplt_start and __rela_iplt_end.
	(Output_data_plt_x86_64::add_entry): Handle IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): New function.
	(Target_x86_64::make_plt_section): Set sh_info field of .rel.plt
	to point to .plt.
	(Target_x86_64::make_local_ifunc_plt_entry): New function.
	(Target_x86_64::Scan::check_non_pic): Add R_X86_64_IRELATIVE to
	switch.
	(Target_x86_64::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_x86_64::Scan::local): Handle IFUNC symbols.  Add
	R_X86_64_IRELATIVE to switch.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocatable_size_for_reloc): Add R_X86_64_IRELATIVE to
	switch.
	* target.h (class Target): Add plt_section_for_global and
	plt_section_for_local functions.  Add do_plt_section_for_global
	and do_plt_section_for_local virtual functions.
	* symtab.h (Symbol::needs_plt_entry): Handle IFUNC symbol.  Add
	clarifying comments.
	(Symbol::use_plt_offset): Handle IFUNC symbol.
	* object.cc (Sized_relobj::Sized_relobj): Initialize
	local_plt_offsets_.
	(Sized_relobj::local_has_plt_offset): New function.
	(Sized_relobj::local_plt_offset): New function.
	(Sized_relobj::set_local_plt_offset): New function.
	(Sized_relobj::do_count): Handle IFUNC symbol.
	* object.h (class Symbol_value): Add is_ifunc_symbol_ field.  Take
	a bit away from input_shndx_ field.  Add set_is_func_symbol and
	is_ifunc_symbol functions.
	(class Sized_relobj): Update declarations.  Remove Tls_got_entry
	and Local_tls_got_offsets.  Define Local_plt_offsets.  Add
	local_plt_offsets_ field.
	(Sized_relobj::clear_local_symbols): Clear local_plt_offsets_.
	* output.h (class Output_section_data): Add non-const
	output_section function.
	(class Output_data_got): Update declarations.
	(class Output_data_got::Got_entry): Add use_plt_offset_ field.
	Add use_plt_offset parameter to global and local constructors.
	Change all callers.  Change local_sym_index_ field to 31 bits.
	Change GSYM_CODE and CONSTANT_CODE accordingly.
	* output.cc (Output_data_reloc_base::do_adjust_output_section): If
	doing a static link don't set sh_link field.
	(Output_data_got::Got_entry::write): Use PLT offset if
	appropriate.
	(Output_data_got::add_global_plt): New function.
	(Output_data_got::add_local_plt): New function.
	* target-reloc.h (relocate_section): Handle IFUNC symbol.
	* defstd.cc (in_section): Remove entries for __rel_iplt_start,
	__rel_iplt_end, __rela_iplt_start, and __rela_iplt_end.
	* configure.ac: Set IFUNC automake conditional for glibc >= 2.11.
	* testsuite/Makefile.am: Add a bunch of IFUNC tests, all within
	IFUNC conditional.
	* testsuite/ifunc-sel.h: New file.
	* testsuite/ifuncmain1.c: New file.
	* testsuite/ifuncmain1vis.c: New file.
	* testsuite/ifuncmod1.c: New file.
	* testsuite/ifuncdep2.c: New file.
	* testsuite/ifuncmain2.c: New file.
	* testsuite/ifuncmain3.c: New file.
	* testsuite/ifuncmod3.c: New file.
	* testsuite/ifuncmain4.c: New file.
	* testsuite/ifuncmain5.c: New file.
	* testsuite/ifuncmod5.c: New file.
	* testsuite/ifuncmain6pie.c: New file.
	* testsuite/ifuncmod6.c: New file.
	* testsuite/ifuncmain7.c: New file.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d1887 1
a1887 1
    section_offset_type *poutput) const
d4092 1
a4092 1
				      unsigned int *pshndx) const
@


1.132
log
@2010-08-03  Ian Lance Taylor  <iant@@google.com>

	PR 11805
	* layout.h (enum Output_section_order): Define.
	(class Layout): Update declarations.
	* layout.cc (Layout::get_output_section): Add order parameter.
	Remove is_interp, is_dynamic_linker_section, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.  Set order.
	(Layout::default_section_order): New function.
	(Layout::layout_eh_frame): Call add_output_section_to_nonload.
	* output.cc (Output_section::Output_section): Initialize order_.
	Don't initialize deleted fields.
	(Output_segment::Output_segment): Don't initialize deleted
	fields.
	(Output_segment::add_output_section_to_load): New function
	replacing add_output_section.  Change all callers to call this or
	add_output_section_to_nonload.
	(Output_segment::add_output_section_to_nonload): New function.
	(Output_segment::remove_output_section): Rewrite.
	(Output_segment::add_initial_output_data): Likewise.
	(Output_segment::has_any_data_sections): Likewise.
	(Output_segment::is_first_section_relro): Likewise.
	(Output_segment::maximum_alignment): Likewise.
	(Output_segment::has_dynamic_reloc): New function replacing
	dynamic_reloc_count.  Change all callers.
	(Output_segment::has_dynamic_reloc_list): New function replacing
	dynamic_reloc_count_list.  Change all callers.
	(Output_segment::set_section_addresses): Rewrite.
	(Output_segment::set_offset): Rewrite.
	(Output_segment::find_first_and_last_list): Remove.
	(Output_segment::set_tls_offsets): Rewrite.
	(Output_segment::first_section_load_address): Likewise.
	(Output_segment::output_section_count): Likewise.
	(Output_segment::section_with_lowest_load_address): Likewise.
	(Output_segment::write_section_headers): Likewise.
	(Output_segment::print_sections_to_map): Likewise.
	* output.h (class Output_data): Remove dynamic_reloc_count_
	field.  Add has_dynamic_reloc_ field.  Make bools into bitfields.
	(Output_data::add_dynamic_reloc): Rewrite.
	(Output_data::has_dynamic_reloc): New function.
	(Output_data::dynamic_reloc_count): Remove.
	(class Output_section): Add order_ field.  Remvoe is_relro_local_,
	is_last_relro_, is_first_non_relro_, is_interp_,
	is_dynamic_linker_section_ fields.  Add order and set_order
	functions.  Remove is_relro_local, set_is_relro_local,
	is_last_relro, set_is_last_relro, is_first_non_relro,
	set_is_first_non_relro functions, is_interp, set_is_interp,
	is_dynamic_linker_section, and set_is_dynamic_linker_section
	functions.
	(class Output_segment): Change Output_data_list from std::list to
	std:;vector.  Add output_lists_ field.  Remove output_data_ and
	output_bss_ fields.  Update declarations.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d1136 10
a1145 1
  if (dynamic)
a1146 2
  else
    os->set_should_link_to_symtab();
d1272 12
a1283 6
	Sized_symbol<size>* sgsym;
	// This cast is a bit ugly.  We don't want to put a
	// virtual method in Symbol, because we want Symbol to be
	// as small as possible.
	sgsym = static_cast<Sized_symbol<size>*>(gsym);
	val = sgsym->value();
d1293 1
d1295 9
a1303 2
        const Symbol_value<size>* symval = this->u_.object->local_symbol(lsi);
        val = symval->value(this->u_.object, 0);
d1326 17
a1342 1
  this->entries_.push_back(Got_entry(gsym));
d1350 1
d1458 19
a1476 1
  this->entries_.push_back(Got_entry(object, symndx));
d1484 1
d1546 1
a1546 1
  this->entries_.push_back(Got_entry(object, symndx));
d1576 1
a1576 1
  this->entries_.push_back(Got_entry(object, symndx));
@


1.131
log
@	PR 11866
	* output.cc (Output_segment::set_offset): Search for the first and
	last sections rather than assuming that the list is in order.
	(Output_segment::find_first_and_last_list): New function.
	* output.h (class Output_segment): Update declarations.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_strip_test.
	(relro_strip_test_SOURCES): New variable.
	(relro_strip_test_DEPENDENCIES): New variable.
	(relro_strip_test_LDFLAGS): New variable.
	(relro_strip_test_LDADD): New variable.
	(relro_strip_test.so): New target.
@
text
@d1920 1
a1941 3
    is_relro_local_(false),
    is_last_relro_(false),
    is_first_non_relro_(false),
a1943 2
    is_interp_(false),
    is_dynamic_linker_section_(false),
d3408 1
a3408 3
  : output_data_(),
    output_bss_(),
    vaddr_(0),
d3427 1
a3427 1
// Add an Output_section to an Output_segment.
d3430 3
a3432 3
Output_segment::add_output_section(Output_section* os,
				   elfcpp::Elf_Word seg_flags,
				   bool do_sort)
d3434 1
a3437 1
  gold_assert(this->type() == elfcpp::PT_LOAD || !do_sort);
d3441 5
a3445 3
  Output_segment::Output_data_list* pdl;
  if (os->type() == elfcpp::SHT_NOBITS)
    pdl = &this->output_bss_;
d3447 1
a3447 1
    pdl = &this->output_data_;
d3449 2
a3450 3
  // Note that while there may be many input sections in an output
  // section, there are normally only a few output sections in an
  // output segment.  The loops below are expected to be fast.
d3452 1
a3452 17
  // So that PT_NOTE segments will work correctly, we need to ensure
  // that all SHT_NOTE sections are adjacent.
  if (os->type() == elfcpp::SHT_NOTE && !pdl->empty())
    {
      Output_segment::Output_data_list::iterator p = pdl->end();
      do
	{
	  --p;
	  if ((*p)->is_section_type(elfcpp::SHT_NOTE))
	    {
	      ++p;
	      pdl->insert(p, os);
	      return;
	    }
	}
      while (p != pdl->begin());
    }
d3454 7
a3460 36
  // Similarly, so that PT_TLS segments will work, we need to group
  // SHF_TLS sections.  An SHF_TLS/SHT_NOBITS section is a special
  // case: we group the SHF_TLS/SHT_NOBITS sections right after the
  // SHF_TLS/SHT_PROGBITS sections.  This lets us set up PT_TLS
  // correctly.  SHF_TLS sections get added to both a PT_LOAD segment
  // and the PT_TLS segment; we do this grouping only for the PT_LOAD
  // segment.
  if (this->type_ != elfcpp::PT_TLS
      && (os->flags() & elfcpp::SHF_TLS) != 0)
    {
      pdl = &this->output_data_;
      if (!pdl->empty())
	{
	  bool nobits = os->type() == elfcpp::SHT_NOBITS;
	  bool sawtls = false;
	  Output_segment::Output_data_list::iterator p = pdl->end();
	  gold_assert(p != pdl->begin());
	  do
	    {
	      --p;
	      bool insert;
	      if ((*p)->is_section_flag_set(elfcpp::SHF_TLS))
		{
		  sawtls = true;
		  // Put a NOBITS section after the first TLS section.
		  // Put a PROGBITS section after the first
		  // TLS/PROGBITS section.
		  insert = nobits || !(*p)->is_section_type(elfcpp::SHT_NOBITS);
		}
	      else
		{
		  // If we've gone past the TLS sections, but we've
		  // seen a TLS section, then we need to insert this
		  // section now.
		  insert = sawtls;
		}
d3462 1
a3462 9
	      if (insert)
		{
		  ++p;
		  pdl->insert(p, os);
		  return;
		}
	    }
	  while (p != pdl->begin());
	}
d3464 2
a3465 3
      // There are no TLS sections yet; put this one at the requested
      // location in the section list.
    }
d3467 2
a3468 15
  if (do_sort)
    {
      // For the PT_GNU_RELRO segment, we need to group relro
      // sections, and we need to put them before any non-relro
      // sections.  Any relro local sections go before relro non-local
      // sections.  One section may be marked as the last relro
      // section.
      if (os->is_relro())
	{
	  gold_assert(pdl == &this->output_data_);
	  Output_segment::Output_data_list::iterator p;
	  for (p = pdl->begin(); p != pdl->end(); ++p)
	    {
	      if (!(*p)->is_section())
		break;
d3470 4
a3473 40
	      Output_section* pos = (*p)->output_section();
	      if (!pos->is_relro()
		  || (os->is_relro_local() && !pos->is_relro_local())
		  || (!os->is_last_relro() && pos->is_last_relro()))
		break;
	    }

	  pdl->insert(p, os);
	  return;
	}

      // One section may be marked as the first section which follows
      // the relro sections.
      if (os->is_first_non_relro())
	{
	  gold_assert(pdl == &this->output_data_);
	  Output_segment::Output_data_list::iterator p;
	  for (p = pdl->begin(); p != pdl->end(); ++p)
	    {
	      if (!(*p)->is_section())
		break;

	      Output_section* pos = (*p)->output_section();
	      if (!pos->is_relro())
		break;
	    }

	  pdl->insert(p, os);
	  return;
	}
    }

  // Small data sections go at the end of the list of data sections.
  // If OS is not small, and there are small sections, we have to
  // insert it before the first small section.
  if (os->type() != elfcpp::SHT_NOBITS
      && !os->is_small_section()
      && !pdl->empty()
      && pdl->back()->is_section()
      && pdl->back()->output_section()->is_small_section())
d3475 2
a3476 3
      for (Output_segment::Output_data_list::iterator p = pdl->begin();
	   p != pdl->end();
	   ++p)
d3478 1
a3478 2
	  if ((*p)->is_section()
	      && (*p)->output_section()->is_small_section())
d3480 1
a3480 1
	      pdl->insert(p, os);
a3483 1
      gold_unreachable();
a3484 124

  // A small BSS section goes at the start of the BSS sections, after
  // other small BSS sections.
  if (os->type() == elfcpp::SHT_NOBITS && os->is_small_section())
    {
      for (Output_segment::Output_data_list::iterator p = pdl->begin();
	   p != pdl->end();
	   ++p)
	{
	  if (!(*p)->is_section()
	      || !(*p)->output_section()->is_small_section())
	    {
	      pdl->insert(p, os);
	      return;
	    }
	}
    }

  // A large BSS section goes at the end of the BSS sections, which
  // means that one that is not large must come before the first large
  // one.
  if (os->type() == elfcpp::SHT_NOBITS
      && !os->is_large_section()
      && !pdl->empty()
      && pdl->back()->is_section()
      && pdl->back()->output_section()->is_large_section())
    {
      for (Output_segment::Output_data_list::iterator p = pdl->begin();
	   p != pdl->end();
	   ++p)
	{
	  if ((*p)->is_section()
	      && (*p)->output_section()->is_large_section())
	    {
	      pdl->insert(p, os);
	      return;
	    }
	}
      gold_unreachable();
    }

  // We do some further output section sorting in order to make the
  // generated program run more efficiently.  We should only do this
  // when not using a linker script, so it is controled by the DO_SORT
  // parameter.
  if (do_sort)
    {
      // FreeBSD requires the .interp section to be in the first page
      // of the executable.  That is a more efficient location anyhow
      // for any OS, since it means that the kernel will have the data
      // handy after it reads the program headers.
      if (os->is_interp() && !pdl->empty())
	{
	  pdl->insert(pdl->begin(), os);
	  return;
	}

      // Put loadable non-writable notes immediately after the .interp
      // sections, so that the PT_NOTE segment is on the first page of
      // the executable.
      if (os->type() == elfcpp::SHT_NOTE
	  && (os->flags() & elfcpp::SHF_WRITE) == 0
	  && !pdl->empty())
	{
	  Output_segment::Output_data_list::iterator p = pdl->begin();
	  if ((*p)->is_section() && (*p)->output_section()->is_interp())
	    ++p;
	  pdl->insert(p, os);
	  return;
	}

      // If this section is used by the dynamic linker, and it is not
      // writable, then put it first, after the .interp section and
      // any loadable notes.  This makes it more likely that the
      // dynamic linker will have to read less data from the disk.
      if (os->is_dynamic_linker_section()
	  && !pdl->empty()
	  && (os->flags() & elfcpp::SHF_WRITE) == 0)
	{
	  bool is_reloc = (os->type() == elfcpp::SHT_REL
			   || os->type() == elfcpp::SHT_RELA);
	  Output_segment::Output_data_list::iterator p = pdl->begin();
	  while (p != pdl->end()
		 && (*p)->is_section()
		 && ((*p)->output_section()->is_dynamic_linker_section()
		     || (*p)->output_section()->type() == elfcpp::SHT_NOTE))
	    {
	      // Put reloc sections after the other ones.  Putting the
	      // dynamic reloc sections first confuses BFD, notably
	      // objcopy and strip.
	      if (!is_reloc
		  && ((*p)->output_section()->type() == elfcpp::SHT_REL
		      || (*p)->output_section()->type() == elfcpp::SHT_RELA))
		break;
	      ++p;
	    }
	  pdl->insert(p, os);
	  return;
	}
    }

  // If there were no constraints on the output section, just add it
  // to the end of the list.
  pdl->push_back(os);
}

// Remove an Output_section from this segment.  It is an error if it
// is not present.

void
Output_segment::remove_output_section(Output_section* os)
{
  // We only need this for SHT_PROGBITS.
  gold_assert(os->type() == elfcpp::SHT_PROGBITS);
  for (Output_data_list::iterator p = this->output_data_.begin();
       p != this->output_data_.end();
       ++p)
   {
     if (*p == os)
       {
         this->output_data_.erase(p);
         return;
       }
   }
d3495 24
a3518 1
  this->output_data_.push_front(od);
d3526 10
a3535 3
  return (!this->output_data_.empty()
	  && this->output_data_.front()->is_section()
	  && this->output_data_.front()->output_section()->is_relro());
d3545 7
a3551 10
      uint64_t addralign;

      addralign = Output_segment::maximum_alignment_list(&this->output_data_);
      if (addralign > this->max_align_)
	this->max_align_ = addralign;

      addralign = Output_segment::maximum_alignment_list(&this->output_bss_);
      if (addralign > this->max_align_)
	this->max_align_ = addralign;

d3575 1
a3575 1
// Return the number of dynamic relocs applied to this segment.
d3577 2
a3578 2
unsigned int
Output_segment::dynamic_reloc_count() const
d3580 4
a3583 2
  return (this->dynamic_reloc_count_list(&this->output_data_)
	  + this->dynamic_reloc_count_list(&this->output_bss_));
d3586 1
a3586 1
// Return the number of dynamic relocs applied to an Output_data_list.
d3588 2
a3589 2
unsigned int
Output_segment::dynamic_reloc_count_list(const Output_data_list* pdl) const
a3590 1
  unsigned int count = 0;
d3594 3
a3596 2
    count += (*p)->dynamic_reloc_count();
  return count;
d3624 1
a3624 3
      for (Output_data_list::iterator p = this->output_data_.begin();
	   p != this->output_data_.end();
	   ++p)
d3626 3
a3628 9
	  if (!(*p)->is_section())
	    break;
	  Output_section* pos = (*p)->output_section();
	  if (!pos->is_relro())
	    break;
	  gold_assert(!(*p)->is_section_flag_set(elfcpp::SHF_TLS));
	  if ((*p)->is_address_valid())
	    relro_size += (*p)->data_size();
	  else
d3630 15
a3644 5
	      // FIXME: This could be faster.
	      (*p)->set_address_and_file_offset(addr + relro_size,
						off + relro_size);
	      relro_size += (*p)->data_size();
	      (*p)->reset_address_and_file_offset();
d3646 2
d3678 15
a3692 10
  addr = this->set_section_list_addresses(layout, reset, &this->output_data_,
					  addr, poff, pshndx, &in_tls);
  this->filesz_ = *poff - orig_off;

  off_t off = *poff;

  uint64_t ret = this->set_section_list_addresses(layout, reset,
                                                  &this->output_bss_,
						  addr, poff, pshndx,
                                                  &in_tls);
d3835 5
a3839 1
  if (this->output_data_.empty() && this->output_bss_.empty())
d3852 1
a3852 2
  // Find the first and last section by address.  The sections may
  // have been sorted for the PT_LOAD segment.
d3856 21
a3876 2
  this->find_first_and_last_list(&this->output_data_, &first, &last_data);
  this->find_first_and_last_list(&this->output_bss_, &first, &last_bss);
d3885 1
a3885 1
  if (this->output_data_.empty())
a3910 31
// Look through a list of Output_data objects and find the first and
// last by address.

void
Output_segment::find_first_and_last_list(const Output_data_list* pdl,
					 const Output_data** pfirst,
					 const Output_data** plast) const
{
  const Output_data* first = *pfirst;
  const Output_data* last = *plast;
  for (Output_data_list::const_iterator p = pdl->begin(); p != pdl->end(); ++p)
    {
      if (first == NULL
	  || (*p)->address() < first->address()
	  || ((*p)->address() == first->address()
	      && (*p)->data_size() < first->data_size()))
	{
	  first = *p;
	  *pfirst = first;
	}
      if (last == NULL
	  || (*p)->address() > last->address()
	  || ((*p)->address() == last->address()
	      && (*p)->data_size() > last->data_size()))
	{
	  last = *p;
	  *plast = last;
	}
    }
}

d3918 2
a3919 7
  for (Output_data_list::iterator p = this->output_data_.begin();
       p != this->output_data_.end();
       ++p)
    (*p)->set_tls_offset(this->vaddr_);

  for (Output_data_list::iterator p = this->output_bss_.begin();
       p != this->output_bss_.end();
d3924 1
a3924 1
// Return the address of the first section.
d3929 13
a3941 12
  for (Output_data_list::const_iterator p = this->output_data_.begin();
       p != this->output_data_.end();
       ++p)
    if ((*p)->is_section())
      return (*p)->has_load_address() ? (*p)->load_address() : (*p)->address();

  for (Output_data_list::const_iterator p = this->output_bss_.begin();
       p != this->output_bss_.end();
       ++p)
    if ((*p)->is_section())
      return (*p)->has_load_address() ? (*p)->load_address() : (*p)->address();

d3950 4
a3953 2
  return (this->output_section_count_list(&this->output_data_)
	  + this->output_section_count_list(&this->output_bss_));
d3981 3
a3983 12
  this->lowest_load_address_in_list(&this->output_data_, &found, &found_lma);

  Output_section* found_data = found;
  this->lowest_load_address_in_list(&this->output_bss_, &found, &found_lma);
  if (found != found_data && found_data != NULL)
    {
      gold_error(_("nobits section %s may not precede progbits section %s "
		   "in same segment"),
		 found->name(), found_data->name());
      return NULL;
    }

d4043 9
a4051 6
  v = this->write_section_headers_list<size, big_endian>(layout, secnamepool,
							 &this->output_data_,
							 v, pshndx);
  v = this->write_section_headers_list<size, big_endian>(layout, secnamepool,
							 &this->output_bss_,
							 v, pshndx);
d4088 2
a4089 2
  this->print_section_list_to_mapfile(mapfile, &this->output_data_);
  this->print_section_list_to_mapfile(mapfile, &this->output_bss_);
@


1.130
log
@2010-07-13  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section::Arm_input_section): For a
	SHT_ARM_EXIDX section, always keeps the input sections.
	(Arm_input_section::set_exidx_section_link): New method.
	(Arm_exidx_input_section::Arm_exidx_input_section): Initialize
	has_errors_ to false.
	(Arm_exidx_input_section::has_errors,
	Arm_exidx_input_section::set_has_errors): New methods.
	(Arm_exidx_input_section::has_errors_): New data member.
	(Arm_relobj::get_exidx_shndx_list): New method.
	(Arm_output_section::append_text_sections_to_list): Do not skip
	section without SHF_EXECINSTR.
	(Arm_output_section::fix_exidx_coverage): Skip input sections with
	errors.
 	(Arm_relobj::make_exidx_input_section): Add new parameter for text
	section header.  Make error messages more verbose.  Check for
	a non-executable section linked to an EXIDX section.
	(Arm_relobj::do_read_symbols): Remove error checking, which has been
	moved to Arm_relobj::make_exidx_input_section.  Add an assertion to
	check that there is no deferred EXIDX section if we exit early.
	Instead of not making an EXIDX section in case of an error, make one
	and set the has_errors flag of it.
	(Target_arm::do_finalize_sections): Fix up links of EXIDX sections
	in a relocatable link.
	(Target_arm::do_relax): Look for the EXIDX output section instead of
	assuming that it is called .ARM.exidx.
 	(Target_arm::fix_exidx_coverage): Add a new parameter for input
	section list.  Do not check for SHF_EXECINSTR section flags but
	skip any input section with errors.
	* output.cc (Output_section::Output_section): Initialize
	always_keeps_input_sections_ to false.
	(Output_section::add_input_section): Check for
	always_keeps_input_sections_.
	*  output.h (Output_section::always_keeps_input_sections,
	Output_section::set_always_keeps_input_sections): New methods.
	(Output_section::always_keeps_input_sections): New data member.
@
text
@d4045 8
a4052 5
  const Output_data* first;
  if (this->output_data_.empty())
    first = this->output_bss_.front();
  else
    first = this->output_data_.front();
d4063 3
a4065 6
    {
      const Output_data* last_data = this->output_data_.back();
      this->filesz_ = (last_data->address()
		       + last_data->data_size()
		       - this->vaddr_);
    }
d4067 1
a4067 5
  const Output_data* last;
  if (this->output_bss_.empty())
    last = this->output_data_.back();
  else
    last = this->output_bss_.back();
d4086 31
@


1.129
log
@	* compressed_output.cc (zlib_decompress): New function.
	(get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* compressed_output.h (get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info)
	Handle compressed debug sections.
	* layout.cc (is_compressed_debug_section): New function.
	(Layout::output_section_name): Map compressed section names to
	canonical names.
	* layout.h (is_compressed_debug_section): New function.
	(is_debug_info_section): Recognize compressed debug sections.
	* merge.cc: Include compressed_output.h.
	(Output_merge_data::do_add_input_section): Handle compressed
	debug sections.
	(Output_merge_string::do_add_input_section): Handle compressed
	debug sections.
	* object.cc: Include compressed_output.h.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(build_compressed_section_map): New function.
	(Sized_relobj::do_read_symbols): Handle compressed debug sections.
	* object.h (Object::section_is_compressed): New method.
	(Object::do_section_is_compressed): New method.
	(Sized_relobj::Compressed_section_map): New type.
	(Sized_relobj::do_section_is_compressed): New method.
	(Sized_relobj::compressed_sections_): New data member.
	* output.cc (Output_section::add_input_section): Handle compressed
	debug sections.
	* reloc.cc: Include compressed_output.h.
	(Sized_relobj::write_sections): Handle compressed debug sections.
@
text
@d1952 1
d2042 4
a2045 2
      bool keeps_input_sections =
	have_sections_script || parameters->target().may_relax();
d2106 2
a2107 1
  if (have_sections_script
@


1.128
log
@	PR gold/11658
	* output.cc
	(Output_section::Input_section_sort_entry::compare_section_ordering):
	Change to return non-zero correctly.
	(Output_section::Input_section_sort_section_order_index_compare
	::operator()): Change to fix ambiguity in comparisons.
@
text
@d2089 5
d2095 1
a2095 1
					+ shdr.get_sh_size());
@


1.127
log
@	* gold.h (is_wildcard_string): New function.
	* layout.cc (Layout::layout): Pass this pointer to add_input_section.
	(Layout::layout_eh_frame): Ditto.
	(Layout::find_section_order_index): New method.
	(Layout::read_layout_from_file): New method.
	* layout.h (Layout::find_section_order_index): New method.
	(Layout::read_layout_from_file): New method.
	(Layout::input_section_position_): New private member.
	(Layout::input_section_glob_): New private member.
	* main.cc (main): Call read_layout_from_file here.
	* options.h (--section-ordering-file): New option.
	* output.cc (Output_section::input_section_order_specified_): New
	member.
	(Output_section::Output_section): Initialize new member.
	(Output_section::add_input_section): Add new parameter.
	Keep input sections when --section-ordering-file is used.
	(Output_section::set_final_data_size): Sort input sections when
	section ordering file is specified.
	(Output_section::Input_section_sort_entry): Add new parameter.
	Check sorting type.
	(Output_section::Input_section_sort_entry::compare_section_ordering):
	New method.
	(Output_section::Input_section_sort_compare::operator()): Change to
	consider section_order_index.
	(Output_section::Input_section_sort_init_fini_compare::operator()):
	Change to consider section_order_index.
	(Output_section::Input_section_sort_section_order_index_compare
	::operator()): New method.
	(Output_section::sort_attached_input_sections): Change to sort
	according to section order when specified.
	(Output_section::add_input_section<32, true>): Add new parameter.
	(Output_section::add_input_section<64, true>): Add new parameter.
	(Output_section::add_input_section<32, false>): Add new parameter.
	(Output_section::add_input_section<64, false>): Add new parameter.
	* output.h (Output_section::add_input_section): Add new parameter.
	(Output_section::input_section_order_specified): New
	method.
	(Output_section::set_input_section_order_specified): New method.
	(Input_section::Input_section): Initialize section_order_index_.
	(Input_section::section_order_index): New method.
	(Input_section::set_section_order_index): New method.
	(Input_section::section_order_index_): New member.
	(Input_section::Input_section_sort_section_order_index_compare): New
	struct.
	(Output_section::input_section_order_specified_): New member.
	* script-sections.cc (is_wildcard_string): Delete and move modified
	method to gold.h.
	(Output_section_element_input::Output_section_element_input): Modify
	call to is_wildcard_string.
	(Output_section_element_input::Input_section_pattern
	::Input_section_pattern): Ditto.
	(Output_section_element_input::Output_section_element_input): Ditto.
	* testsuite/Makefile.am (final_layout): New test case.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/final_layout.cc: New file.
	* testsuite/final_layout.sh: New file.
@
text
@d2804 2
a2805 2
  // Returns 0 if sections are not comparable. Returns 1 if THIS is the
  // first section in order, returns -1 for S.
d2809 10
a2818 9
    gold_assert(this->index_ != -1U);
    if (this->input_section_.section_order_index() == 0
        || s.input_section().section_order_index() == 0)
      return 0;
    if (this->input_section_.section_order_index()
        < s.input_section().section_order_index())
      return 1;
    else
      return -1;
d2939 4
a2942 1
// Return true if S1 should come before S2.
d2948 2
a2949 5
  // Check if a section order exists for these sections through a section
  // ordering file.  If sequence_num is 0, an order does not exist.
  int sequence_num = s1.compare_section_ordering(s2);
  if (sequence_num != 0)
    return sequence_num == 1;
d2951 5
a2955 2
  // Otherwise we keep the input order.
  return s1.index() < s2.index();
@


1.126
log
@2010-05-23  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section::do_output_offset): Use convert_types
	instead of a cast.
	(Target_arm::apply_cortex_a8_workaround): Rewrite a conditional branch
	with a direct branch, not a conditional branch, to a stub.
	* merge.cc (Output_merge_base::record_input_section): New method
	defintion.
	(Output_merge_data::do_add_input_section): Record input section if
	keeps-input-sections flag is set.
	(Output_merge_string::do_add_input_section): Ditto.
	* merge.h (Output_merge_base::Output_merge_base): Initialize new data
	members KEEPS_INPUT_SECTIONS_, FIRST_RELOBJ_, FIRST_SHNDX_ and
	INPUT_SECTIONS_.
	(Output_merge_base::keeps_input_sections,
	Output_merge_base::set_keeps_input_sections,
	Output_merge_base::first_relobj, Output_merge_base::first_shndx): New
	method definitions.
	(Output_merge_base::Input_sections): New type declaration.
	(Output_merge_base::input_sections_begin,
	Output_merge_base::input_sections_end,
	Output_merge_base::do_set_keeps_input_sections): New method definitions.
	(Output_merge_base::bool keeps_input_sections_,
	Output_merge_base::first_relobj_, Output_merge_base::first_shndx_,
	Output_merge_base::input_sections_): New data members.
	(Output_merge_data::do_set_keeps_input_sections): New method
	defintion.
	(Output_merge_string::do_set_keeps_input_sections): Ditto.
	* output.cc (Output_section::Input_section::relobj): Move method
	defintion from class declaration to here and handle merge sections.
	(Output_section::Input_section::shndx): Ditto.
	(Output_section::Output_section): Remove initializations of removed
	data members and initialize new data member LOOKUP_MAPS_.
	(Output_section::add_input_section): Set keeps-input-sections flag
	for a newly created merge output section as appropriate.  Adjust code
	to use Output_section_lookup_maps class.
	(Output_section::add_relaxed_input_section): Adjst code for lookup
	maps code refactoring.
 	(Output_section::add_merge_input_section): Add a new parameter
	KEEPS_INPUT_SECTION.  Adjust code to use Output_section_lookup_maps
	class.  If adding input section to a newly created merge output
	section fails, remove the new merge section.
	(Output_section::convert_input_sections_in_list_to_relaxed_input_sections):
	Adjust code for use of the Output_section_lookup_maps class.
 	(Output_section::find_merge_section): Ditto.
	(Output_section::build_lookup_maps): New method defintion.
 	(Output_section::find_relaxed_input_section): Adjust code to use
	Output_section_lookup_maps class.
	(Output_section::get_input_sections): Export merge sections.  Adjust
	code to use Output_section_lookup_maps class.
	(Output_section:::add_script_input_section): Adjust code to use
	Output_section_lookup_maps class.  Update lookup maps for merge
	sections also.
	(Output_section::discard_states): Use Output_section_lookup_maps.
	(Output_section::restore_states): Same.
	* output.h (Merge_section_properties): Move class defintion out of
	Output_section.
	(Output_section_lookup_maps): New class.
	(Output_section::Input_section::is_merge_section): New method
	defintion.
	(Output_section::Input_section::relobj): Move defintion out of class
	defintion.  Declare method only.
	(Output_section::Input_section::shndx): Ditto.
	(Output_section::Input_section::output_merge_base): New method defintion.
     	(Output_section::Input_section::u2_.pomb): New union field.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Ouptut_relaxed_input_section_by_input_section_map):
	Remove types.
   	(Output_section::add_merge_input_section): Add new parameter
	KEEPS_INPUT_SECTIONS.
	(Output_section::build_lookup_maps): New method declaration.
	(Output_section::merge_section_map_,
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_): Remove data
	members.
	(Output_section::lookup_maps_): New data member.
@
text
@d1936 1
d1998 2
a1999 1
Output_section::add_input_section(Sized_relobj<size, big_endian>* object,
d2095 3
a2097 1
  // the future, we keep track of the sections.
d2103 16
a2118 4
      || parameters->target().may_relax())
    this->input_sections_.push_back(Input_section(object, shndx,
						  shdr.get_sh_size(),
						  addralign));
d2642 2
a2643 1
  if (this->must_sort_attached_input_sections())
d2720 2
a2721 1
			   unsigned int index)
d2726 2
a2727 1
    if (this->section_has_name_)
d2804 16
d2881 6
d2923 6
d2938 16
d2979 2
a2980 1
    sort_list.push_back(Input_section_sort_entry(*p, i));
d2983 11
a2993 5
  if (this->type() == elfcpp::SHT_PREINIT_ARRAY
      || this->type() == elfcpp::SHT_INIT_ARRAY
      || this->type() == elfcpp::SHT_FINI_ARRAY)
    std::sort(sort_list.begin(), sort_list.end(),
	      Input_section_sort_init_fini_compare());
d2995 5
a2999 2
    std::sort(sort_list.begin(), sort_list.end(),
	      Input_section_sort_compare());
d3007 1
d4543 1
d4556 1
d4569 1
d4582 1
@


1.125
log
@2010-05-14  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section::original_size): New method.
	(Arm_input_section::do_addralign): Add a cast.
	(Arm_input_section::do_output_offset): Remove static cast.
	(Arm_input_section::original_addralign,
	 Arm_input_section::original_size_): Change type to uint32_t.
	(Arm_input_section::init): Add safe casts for section alignment
	and size.
	(Arm_input_section::set_final_data_size): Do not set address and
	offset of stub table.
	(Arm_output_section::fix_exidx_coverage): Change use of of
	Output_section::Simple_input_section to that of
	Output_section::Input_section.
	(Target_arm::do_relax): Set addresses and file offsets of Stub_tables
	except for the first pass.
	* output.cc (Output_section::get_input_sections): Change type of
	input_sections to std::list<Input_section>.
	(Output_section::add_script_input_section): Rename from
	Output_section::add_simple_input_section.  Change type of SIS
	parameter from Simple_input_section to Input_section.
	* output.h (Output_section::Simple_input_section): Remove class.
	(Output_section::Input_section): Change class visibility to public.
	(Output_section::Input_section::addralign): Use stored alignments
	for special input sections if set.
	(Output_section::Input_section::set_addralign): New method.
	(Output_section::get_input_sections): Change parameter type from
	list of Simple_input_section to list of Input_section.
	(Output_section::add_script_input_section): Rename from
	Output_section::add_simple_input_section. Change first parameter's
	type from Simple_input_section to Input_section and remove the
	second and third parameters.
	* script-sections.cc (Input_section::Input_section_list): Change
	type to list of Output_section::Input_section/
	(Input_section_info::Input_section_info): Change parameter type of
	INPUT_SECTION to Output_section::Input_section.
	(Input_section_info::input_section): Change return type.
	(Input_section_info::input_section_): Change type to
	Output_section::Input_section.
	(Output_section_element_input::set_section_addresses): Adjust code
	to use Output_section::Input_section instead of
	Output_section::Simple_input_section.  Adjust code for renaming
	of Output_section::add_simple_input_section.
	(Orphan_output_section::set_section_addresses): Ditto.
@
text
@d1752 36
d1953 1
a1953 4
    merge_section_map_(),
    merge_section_by_properties_map_(),
    relaxed_input_section_map_(),
    is_relaxed_input_section_map_valid_(true)
d2037 6
a2042 2
      if (this->add_merge_input_section(object, shndx, sh_flags,
					entsize, addralign))
d2132 3
a2134 5
  if (this->is_relaxed_input_section_map_valid_)
    {
      Const_section_id csid(poris->relobj(), poris->shndx());
      this->relaxed_input_section_map_[csid] = poris;
    }
d2180 2
a2181 1
					uint64_t addralign)
d2194 4
a2197 1
  Output_merge_base* pomb;
d2199 3
a2201 3
  Merge_section_by_properties_map::const_iterator p =
    this->merge_section_by_properties_map_.find(msp);
  if (p != this->merge_section_by_properties_map_.end())
a2202 1
      pomb = p->second;
d2229 5
a2233 4
      // Add new merge section to this output section and link merge
      // section properties to new merge section in map.
      this->add_output_merge_section(pomb, is_string, entsize);
      this->merge_section_by_properties_map_[msp] = pomb;
d2238 8
d2248 1
a2248 2
      Const_section_id csid(object, shndx);
      this->merge_section_map_[csid] = pomb;
d2252 7
a2258 1
    return false;
d2353 1
a2353 1
  if (this->is_relaxed_input_section_map_valid_)
d2357 2
a2358 2
	Const_section_id csid(poris->relobj(), poris->shndx());
	this->relaxed_input_section_map_[csid] = poris;
d2403 40
a2442 8
  Const_section_id csid(object, shndx);
  Output_section_data_by_input_section_map::const_iterator p =
    this->merge_section_map_.find(csid);
  if (p != this->merge_section_map_.end())
    {
      Output_section_data* posd = p->second;
      gold_assert(posd->is_merge_section_for(object, shndx));
      return posd;
a2443 2
  else
    return NULL;
d2453 3
a2455 25
  // Be careful that the map may not be valid due to input section export
  // to scripts or a check-point restore.
  if (!this->is_relaxed_input_section_map_valid_)
    {
      // Rebuild the map as needed.
      this->relaxed_input_section_map_.clear();
      for (Input_section_list::const_iterator p = this->input_sections_.begin();
	   p != this->input_sections_.end();
	   ++p)
	if (p->is_relaxed_input_section())
	  {
	    Const_section_id csid(p->relobj(), p->shndx());
	    this->relaxed_input_section_map_[csid] =
	      p->relaxed_input_section();
	  }
      this->is_relaxed_input_section_map_valid_ = true;
    }

  Const_section_id csid(object, shndx);
  Output_relaxed_input_section_by_input_section_map::const_iterator p =
    this->relaxed_input_section_map_.find(csid);
  if (p != this->relaxed_input_section_map_.end())
    return p->second;
  else
    return NULL;
d3115 2
a3116 2
  // Invalidate the relaxed input section map.
  this->is_relaxed_input_section_map_valid_ = false;
d3127 3
a3129 1
      if (p->is_input_section() || p->is_relaxed_input_section())
d3186 24
d3235 3
a3237 3
  // Simply invalidate the relaxed input section map since we do not keep
  // track of it.
  this->is_relaxed_input_section_map_valid_ = false;
d3269 3
a3271 3
  // Simply invalidate the relaxed input section map since we do not keep
  // track of it.
  this->is_relaxed_input_section_map_valid_ = false;
@


1.124
log
@2010-04-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::choose_output_section): Handle script section
	types.
	(Layout::make_output_section_for_script): Add section type parameter.
	Handle script section types.
	* layout.h (Layout::make_output_section_for_script): Add section
	type parameter.
	* output.cc (Output_section::Output_section): Initialize data member
	is_noload_.
	(Output_section::do_reset_address_and_file_offset): Do not set address
	to 0 if section is a NOLOAD section.
	* output.h (Output_section::is_noload): New method.
	(Output_section::set_is_noload): Ditto.
	(Output_section::is_noload_): New data member.
	* script-c.h (Script_section_type): New enum type.
	(struct Parser_output_section_header): Add new file section_type.
	* script-sections.cc (Sections_element::output_section_name): Add
	parameter for returning script section type.
	(Output_section_definition::output_section_name): Ditto.
	(Output_section_definition::section_type)P; New method.
	(Output_section_definiton::script_section_type_name): Ditto.
	(Output_section_definition::script_section_type_): New data member.
	(Output_section_definition::Output_section_definition): Initialize
	data member Output_section_definition::script_section_type_.
	(Output_section_definition::create_sections): Pass script section type
	to Layout::make_output_section_for_script.
	(Output_section_definition::output_section_name): Return script
	section type to caller.
	(Output_section_definition::set_section_address): Do not advance
	dot value and load address if section type is NOLOAD.  Set address
	of NOLOAD sections regardless of section flags.
	(Output_section_definition::print): Print section type if it is
	not SCRIPT_SECTION_TYPE_NONE.
	(Output_section_definition::section_type): New method.
	(Output_section_definition::script_section_type_name): Ditto.
	(Script_sections::output_section_name): Add new parameter
	PSECTION_TYPE for returning script section type.  Pass it to
	section elements.  Handle discard sections.
	(Sort_output_sections::operator()): Handle NOLOAD sections.
	* script-sections.h (Script_sections::Section_type): New enum type.
   	(Script_sections::output_section_name): Add a new parameter for
	returning script section type.
	* script.cc (script_keyword_parsecodes): Add keywords COPY, DSECT,
	INFO and NOLOAD.
	* yyscript.y (union): Add new field SECTION_TYPE.
	(COPY, DSECT, INFO, NOLOAD): New tokens.
	(opt_address_and_section_type): Change type to output_section_header.
	(section_type): New non-terminal
	(section_header): Handle section type.
 	(opt_address_and_section_type): Return section type value.
@
text
@d3049 1
a3049 1
    std::list<Simple_input_section>* input_sections)
d3067 2
a3068 6
      if (p->is_input_section())
	input_sections->push_back(Simple_input_section(p->relobj(),
						       p->shndx()));
      else if (p->is_relaxed_input_section())
	input_sections->push_back(
	    Simple_input_section(p->relaxed_input_section()));
d3103 4
a3106 1
// Add an simple input section.
d3109 1
a3109 3
Output_section::add_simple_input_section(const Simple_input_section& sis,
					 off_t data_size,
					 uint64_t addralign)
d3111 2
d3123 1
a3123 5
  Input_section is =
    (sis.is_relaxed_input_section()
     ? Input_section(sis.relaxed_input_section())
     : Input_section(sis.relobj(), sis.shndx(), data_size, addralign));
  this->input_sections_.push_back(is);
@


1.123
log
@2010-04-08  Doug Kwan  <dougkwan@@google.com>

	* merge.cc (Output_merge_data::set_final_data_size): Handle empty
	Output_merge_data.
	* output.cc (Output_section::add_merge_input_section): Simplify
	code and return status of Output_merge_base::add_input_section.
	Update merge section map only if Output_merge_base::add_input_section
	returns true.
@
text
@d1914 1
d2592 3
a2594 2
  // sections.  We do the same in the constructor.
  if ((this->flags_ & elfcpp::SHF_ALLOC) == 0)
@


1.122
log
@	* options.h (class General_options): Add --spare-dynamic-tags.
	* output.cc (Output_data_dynamic::set_final_data_size): Implement
	--spare-dynamic-tags.
@
text
@d2157 1
d2163 4
a2166 10
      Output_merge_base* merge_section = p->second;
      merge_section->add_input_section(object, shndx);
      gold_assert(merge_section->is_string() == is_string
		  && merge_section->entsize() == entsize
		  && merge_section->addralign() == addralign);

      // Link input section to found merge section.
      Const_section_id csid(object, shndx);
      this->merge_section_map_[csid] = merge_section;
      return true;
a2167 6

  // We handle the actual constant merging in Output_merge_data or
  // Output_merge_string_data.
  Output_merge_base* pomb;
  if (!is_string)
    pomb = new Output_merge_data(entsize, addralign);
d2170 4
a2173 1
      switch (entsize)
d2175 14
a2188 11
        case 1:
	  pomb = new Output_merge_string<char>(addralign);
	  break;
        case 2:
	  pomb = new Output_merge_string<uint16_t>(addralign);
	  break;
        case 4:
	  pomb = new Output_merge_string<uint32_t>(addralign);
	  break;
        default:
	  return false;
d2190 4
d2196 10
a2205 12
  // Add new merge section to this output section and link merge section
  // properties to new merge section in map.
  this->add_output_merge_section(pomb, is_string, entsize);
  this->merge_section_by_properties_map_[msp] = pomb;

  // Add input section to new merge section and link input section to new
  // merge section in map.
  pomb->add_input_section(object, shndx);
  Const_section_id csid(object, shndx);
  this->merge_section_map_[csid] = pomb;

  return true;
@


1.121
log
@2010-03-01  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::Layout): Force section types of .init_array*,
	.preinit_array* and .fini_array* sections.
	* output.cc (Output_section::Input_section_sort_entry::has_priority):
	Fix check of return value of std::string::find.().
	(Output_section::Input_section_sort_compare::operator()): Remove
	comment about .init_array.
	(Output_section::Input_section_sort_init_fini_compare::operator()):
	New method.
	(Output_section::sort_attached_input_sections): Handle .init_array
	and .fini_array specially.
	* output.h (Output_section::Inut_section_sort_compare): Update
	comment.
	(Output_section::Input_section_sort_init_fini_compare): New struct.
@
text
@d1625 7
a1631 3
  if (this->entries_.empty()
      || this->entries_.rbegin()->tag() != elfcpp::DT_NULL)
    this->add_constant(elfcpp::DT_NULL, 0);
@


1.120
log
@	* output.h (Output_reloc<SHT_REL>::Output_reloc): Add
	is_symbolless parameter.
	(Output_reloc<SHT_REL>::is_symbolless): New.
	(Output_reloc<SHT_REL>::is_symbolless_): New.
	(Output_reloc<SHT_REL>::type_): Decrease to 29 bits.
	(Output_reloc<SHT_RELA>::Output_reloc): Add is_symbolless parameter.
	(Output_reloc<SHT_RELA>::is_symbolless): New.
	(Output_data_reloc::add_global): Handle is_symbolless.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): New.
	(Output_data_reloc::add_symbolless_local_addend): New.
	* output.cc (Output_reloc<SHT_REL>::Output_reloc): Handle
	is_symbolless.
	(Output_reloc::set_needs_dynsym_index): Test ->is_symbolless_
	instead of ->is_relative_
	(Output_reloc::write): Likewise.
	(Output_reloc::get_symbol_index): Return 0 when ->is_symbolless_
	(Output_reloc::write_rel): Simplify.

	* sparc.cc (Target_sparc::Scan::local): Use
	->add_symbolless_local_addend as needed.
	(Target_sparc::Scan::global): Use ->add_symbolless_global_addend as
	needed.  Also, emit appropriate unaligned vs. aligned dynamic reloc
	based upon relocation offset.
@
text
@d2698 1
a2698 1
    return this->section_name_.find('.', 1);
a2775 2
  // The GNU linker does this for all but .init_array sections; until
  // further notice we'll assume that that is an mistake.
d2792 36
d2856 8
a2863 1
  std::sort(sort_list.begin(), sort_list.end(), Input_section_sort_compare());
@


1.119
log
@	* output.h (Output_data_dynamic::add_section_size): New method
	that takes two Output_data objects.
	(Output_data_dynamic::Dynamic_entry): Create storage for secondary
	entry param.  Handle it in initializers.
	* output.cc (Output_data_dynamic::Dynamic_entry::write): For
	DYNAMIC_SECTION_SIZE, add in second object size if non-NULL.
	* layout.h (Layout::add_target_dynamic_tags): Add dynrel_includes_plt
	arg.
	* layout.cc (Layout::add_target_dynamic_tags): If dynrel_includes_plt,
	and .rela.plt exists, set DT_REL{,A}SZ to sum of .rela.dyn and .rela.plt
	* arm.cc (Target_arm::do_finalize_sections): Update to pass false
	for dynrel_includes_plt.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::make_plt_entry): Force .rela.dyn to be output
	before .rela.plt
	(Target_sparc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt.
	* powerpc.cc (Target_powerpc::make_plt_entry): Force .rela.dyn to be
	output before .rela.plt
	(Target_powerpc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt when 32-bit.
@
text
@d641 2
a642 1
    bool is_relative)
d644 2
a645 1
    is_relative_(is_relative), is_section_symbol_(false), shndx_(INVALID_CODE)
d662 2
a663 1
    bool is_relative)
d665 2
a666 1
    is_relative_(is_relative), is_section_symbol_(false), shndx_(shndx)
d687 1
d690 2
a691 2
    is_relative_(is_relative), is_section_symbol_(is_section_symbol),
    shndx_(INVALID_CODE)
d711 1
d714 2
a715 2
    is_relative_(is_relative), is_section_symbol_(is_section_symbol),
    shndx_(shndx)
d737 2
a738 1
    is_relative_(false), is_section_symbol_(true), shndx_(INVALID_CODE)
d758 2
a759 1
    is_relative_(false), is_section_symbol_(true), shndx_(shndx)
d780 2
a781 1
    is_relative_(false), is_section_symbol_(false), shndx_(INVALID_CODE)
d796 2
a797 1
    is_relative_(false), is_section_symbol_(false), shndx_(shndx)
d815 2
a816 1
    is_relative_(false), is_section_symbol_(false), shndx_(INVALID_CODE)
d832 2
a833 1
    is_relative_(false), is_section_symbol_(false), shndx_(shndx)
d849 1
a849 1
  if (this->is_relative_)
d891 2
d1012 1
a1012 1
  unsigned int sym_index = this->is_relative_ ? 0 : this->get_symbol_index();
d1114 1
a1114 1
  else if (this->rel_.is_relative())
@


1.118
log
@2010-01-22  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_relax): Record an output section for section
	offset adjustment it contains any stub table that has changed.
	* layout.cc (Layout::clean_up_after_relaxation): Adjust section
	offsets in an output section if necessary.
	* output.cc (Output_section::Output_section): Initialize
	section_offsets_need_adjustments_.
	(Output_section::add_input_section_for_script): Renamed to
	Output_section::add_simple_input_section.
	(Output_section::save_states): Add a comment.
	(Output_section::discard_states): New method defintion.
	(Output_section::adjust_section_offsets): Same.
	* output.h (Output_section::add_input_section_for_script): Renamed to
	Output_section::add_simple_input_section.
	(Output_section::discard_states): New method declaration.
	(Output_section::adjust_section_offsets): Same.
	(Output_section::section_offsets_need_adjustment,
	Output_section::set_section_offsets_need_adjustment): New method
	definitions.
	(Output_section::section_offsets_need_adjustment_): New data member.
	* script-sections.cc
	(Output_section_element_input::set_section_address): Adjust code for
	renaming of Output_section::add_input_section_for_script.
	(Orphan_output_section::set_section_address): Same.
@
text
@d1563 2
@


1.117
log
@2010-01-20  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::Arm_input_section_map): Change key type from
	Input_section_specifier to Section_id.
	(Target_arm::new_arm_input_section: Adjust code for change of key
	type.
	(Target_arm::find_arm_input_section): Ditto.
	* gc.h (object.h): Include for Section_id nand Section_id_hash.
	(Section_id): Remove.
	(Garbage_collection::Section_id_hash): Remove.
	* icf.h (object.h): Include for Section_id nand Section_id_hash.
	(Section_id): Remove.
	(Icf::Section_id_hash): Remove.
	* object.h (Section_id, Const_section_id, Section_id_hash,
	Const_section_id_hash): New type definitions.
	* output.cc (Output_section::add_relaxed_input_section): Change to
	use Const_section_id instead of Input_section_specifier as key type.
	(Output_section::add_merge_input_section): Ditto.
	(Output_section::build_relaxation_map): Change to use Section_id
	instead of Input_section_specifier as key type.
 	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Ditto.
	(Output_section::convert_input_sections_to_relaxed_sections): Change
	to use Const_section_id instead of Input_section_specifier as key type.
 	(Output_section::find_merge_section): Ditto.
	(Output_section::find_relaxed_input_section): Ditto.
	* output.h (Input_section_specifier): Remove class.
	(Output_section::Output_section_data_by_input_section_map): Change
	key type to Const_section_id.
	(Output_section::Output_relaxed_input_section_by_input_section_map):
	Ditto.
	(Output_section::Relaxation_map): Change key type to Section_id.
@
text
@d1893 1
d3047 1
a3047 1
// Add an input section from a script.
d3050 3
a3052 3
Output_section::add_input_section_for_script(const Simple_input_section& sis,
					     off_t data_size,
					     uint64_t addralign)
d3071 1
a3071 1
//
d3087 13
d3133 23
@


1.116
log
@elfcpp/:
	* elfcpp.h (PN_XNUM): Define.
gold/:
	* output.cc (Output_section_headers::do_sized_write): Write large
	segment count to sh_info field.
	(Output_file_header::do_sized_write): For large segment count,
	write PN_XNUM to e_phnum field.
@
text
@d2075 2
a2076 2
      Input_section_specifier iss(poris->relobj(), poris->shndx());
      this->relaxed_input_section_map_[iss] = poris;
d2148 2
a2149 2
      Input_section_specifier iss(object, shndx);
      this->merge_section_map_[iss] = merge_section;
d2184 2
a2185 2
  Input_section_specifier iss(object, shndx);
  this->merge_section_map_[iss] = pomb;
d2204 2
a2205 2
	  Input_section_specifier iss(is.relobj(), is.shndx());
	  (*relaxation_map)[iss] = i;
d2211 2
a2212 2
// sections in RELAXED_SECTIONS.  MAP is a prebuilt map from input section
// specifier to indices of INPUT_SECTIONS.
d2223 2
a2224 2
      Input_section_specifier iss(poris->relobj(), poris->shndx());
      Relaxation_map::const_iterator p = map.find(iss);
d2286 2
a2287 2
	Input_section_specifier iss(poris->relobj(), poris->shndx());
	this->relaxed_input_section_map_[iss] = poris;
d2332 1
a2332 1
  Input_section_specifier iss(object, shndx);
d2334 1
a2334 1
    this->merge_section_map_.find(iss);
d2363 2
a2364 2
	    Input_section_specifier iss(p->relobj(), p->shndx());
	    this->relaxed_input_section_map_[iss] =
d2370 1
a2370 1
  Input_section_specifier iss(object, shndx);
d2372 1
a2372 1
    this->relaxed_input_section_map_.find(iss);
@


1.115
log
@2010-01-14  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (map, utility): Include headers.
	(Target_arm::apply_cortex_a8_workaround): New method.
	(Arm_relobj::do_relocate_sections): Apply any Cortex-A8 workaround.
	(Target_arm::Scan::local): Handle R_ARM_THM_JUMP24, R_ARM_THM_JUMP19.
	(Target_arm::Scan::global): R_ARM_THM_JUMP19.
	(Target_arm::do_finalize_sections): Set fix_cortex_a8_ according to
	the --[no-]fix-cortex-a8 command line options.
	(Target_arm::Relocate::relocate): Handle R_ARM_JUMP19.
	(Target_arm::relocate_stub): Use addend in instruction template.
	* options.h (DEFINE_bool): Set the user-set flag.
	(General_options): Add --[no-]-fix-cortex options.
	* output.cc (Output_section::convert_input_sections_to_relaxed_sections)
	: Update fast look-up map after conversion.
@
text
@d216 3
a218 1
    oshdr.put_sh_info(0);
d475 5
a479 2
      oehdr.put_e_phnum(this->segment_header_->data_size()
			/ elfcpp::Elf_sizes<size>::phdr_size);
@


1.114
log
@	PR 10287
	PR 11063
	* i386.cc (class Target_i386): Change return type of plt_section
	to be non-const.
	(class Output_data_plt_i386): Add tls_desc_rel_ field.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize
	tls_desc_rel_ field.
	(Output_data_plt_i386::rel_tls_desc): New function.
	(Target_i386::rel_tls_desc_section): New function.
	(Target_i386::Scan::local): Rewrite R_386_TLS_GOTDESC handling.
	(Target_i386::Scan::global): For R_386_TLS_GOTDESC put
	R_386_TLS_DESC reloc in rel_tls_desc_section.
	* x86_64.cc (class Target_x86_64): Add tlsdesc_reloc_info_ field.
	Define struct Tlsdesc_info.
	(Target_x86_64::Target_x86_64): Initialize tlsdesc_reloc_info_.
	(Target_x86_64::do_reloc_symbol_index): New function.
	(Target_x86_64::add_tlsdesc_info): New function.
	(class Output_data_plt_x86_64): Add tlsdesc_rel_ field.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Initialize
	tlsdesc_rel_ field.
	(Output_data_plt_x86_64::rela_plt): Rename from rel_plt.  Change
	all callers.
	(Output_data_plt_x86_64::rela_tlsdesc): New function.
	(Target_x86_64::rela_tlsdesc_section): New function.
	(Target_x86_64::Scan::local): Rewrite R_X86_64_GOTPC32_TLSDESC
	handling.
	(Target_x86_64::Scan::global): For R_X86_64_GOTPC32_TLSDESC put
	(Target_x86_64::do_reloc_addend): New function.
	R_X86_64_TLSDESC reloc in rela_tlsdesc_section.
	* output.h (class Output_reloc) [SHT_REL]: Add new constructor
	declarations.  Define TARGET_CODE.  Add arg field to u1_ union.
	(Output_reloc::type): New function.
	(Output_reloc::is_local_section_symbol): Check for TARGET_CODE.
	(Output_reloc::is_target_specific): New function.
	(Output_reloc::target_arg): New function.
	(class Output_reloc) [SHT_RELA]: Add four new constructors for
	absolute relocs and target specific relocs.
	(class Output_data_reloc) [SHT_REL]: Add add_absolute and
	add_target_specific.
	(class Output_data_reloc) [SHT_RELA]: Likewise.
	* output.cc (Output_reloc::Output_reloc): Add four new versions
	for absolute relocs and target specific relocs.
	(Output_reloc::set_needs_dynsym_index): Add TARGET_CODE case.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Check that local_sym_index_
	is not TARGET_CODE or 0.
	(Output_reloc::symbol_value): Likewise.
	(Output_reloc::write) [SHT_RELA]: Call target for target specific
	reloc.
	* target.h (class Target): Add reloc_symbol_index and reloc_addend
	functions.  Add do_reloc_symbol_index and do_reloc_addend virtual
	functions.
	* layout.cc (add_target_dynamic_tags): Use output section for
	DT_PLTRELSZ and DT_JMPREL.
@
text
@d2275 9
@


1.113
log
@	PR 11061
	* output.h (class Output_reloc) [SHT_RELA]: Add is_relative
	function.
	(class Output_data_reloc_generic): Define.
	(class Output_data_reloc_base): Change base class to
	Output_data_reloc_generic.  Change add() method to call
	bump_relative_reloc_count for a relative reloc.  Remove
	sort_relocs_ field.
	* output.cc (Output_data_reloc_base::do_write): Change sort_reloc_
	to sort_relocs().
	* layout.cc (Layout::add_target_dynamic_tags): Change dyn_rel to
	Output_data_reloc_generic*.  Add DT_RELCOUNT/DT_RELACOUNT tag if
	appropriate.
	* layout.h (class Layout): Update declaration.
@
text
@d759 66
d847 4
d895 5
d941 1
d943 1
d1022 1
d1024 1
d1092 4
a1095 1
  if (this->rel_.is_relative())
@


1.112
log
@	PR 10980
	* options.cc (General_options::parse_section_start): New function.
	(General_options::section_start): New function.
	(General_options::General_options): Initialize all members.
	* options.h: Include <map>
	(class General_options): Add --section-start.  Add section_starts_
	member.
	* layout.cc (Layout::attach_allocated_section_to_segment): If
	--section-start was used, set the address of the segment.  Remove
	local sort_sections.
	(Layout::relaxation_loop_body): If the address of the load segment
	has been set by --section-start, don't use it.
	* output.h (Output_segment::update_flags_for_output_section): New
	function.
	* output.cc (Output_segment::add_output_section): Call
	update_flags_for_output_section.
@
text
@d1052 1
a1052 1
  if (this->sort_relocs_)
@


1.111
log
@	PR 10450
	* output.cc (Output_segment::Output_segment): If PT_TLS, set the
	flags to PF_R.
	(Output_segment::add_output_section): Don't change the flags if
	the type is PT_TLS.
@
text
@d3084 1
a3084 5
  // Update the segment flags.  The ELF ABI specifies that a PT_TLS
  // segment should always have PF_R as the flags, regardless of the
  // associated sections.
  if (this->type() != elfcpp::PT_TLS)
    this->flags_ |= seg_flags;
d3362 2
a3363 2
// Add an Output_data (which is not an Output_section) to the start of
// a segment.
@


1.110
log
@	* layout.cc (Layout::Layout): Initialize increase_relro_.
	(Layout::get_output_section): Add is_relro, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::set_segment_offsets): Clear increase_relro when using a
	linker script.
	* layout.h (class Layout): Add increase_relro method.  Add
	increase_relro_ field.  Update declarations.
	* output.cc (Output_section::Output_section): Initialize
	is_last_relro_ and is_first_non_relro_.
	(Output_segment::add_output_section): Group relro sections is
	do_sort is true.  Handle is_last_relro and is_first_non_relro.
	(Output_segment::maximum_alignment): Remove relro handling.
	(Output_segment::set_section_addresses): Add increase_relro
	parameter.  Change all callers.  Add initial alignment to align
	relro sections on separate page.  Remove old relro handling.
	(Output_segment::set_section_list_addresses): Remove in_relro
	parameter.  Change all callers.
	(Output_segment::set_offset): Add increase parameter.  Change all
	callers.  Remove old relro handling.
	* output.h (class Output_section): Add new methods: is_last_relro,
	set_is_last_relro, is_first_non_relro, set_is_first_non_relro.
	Add is_last_relro_ and is_first_non_relro_ fields.
	* i386.cc (Target_i386::got_section): Don't call set_is_relro.
	Create separate .got.plt section.  Call increase_relro.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/relro_script_test.t: Add .got.plt.
@
text
@d3066 4
d3084 5
a3088 2
  // Update the segment flags.
  this->flags_ |= seg_flags;
@


1.109
log
@	PR 10450
	* output.h (class Output_section): Add is_entsize_zero_ field.
	* output.cc (Output_section::Output_section): Initialize
	is_entsize_zero_.
	(Output_section::set_entsize): If two different entsizes are
	requested, force it to zero.
	(Output_section::add_input_section): Set flags for .debug_str
	before updating section flags.  Set entsize.
	(Output_section::update_flags_for_input_section): Set SHF_MERGE
	and SHF_STRING if all input sections have those flags.
@
text
@d1798 2
d3162 22
a3183 11
  // For the PT_GNU_RELRO segment, we need to group relro sections,
  // and we need to put them before any non-relro sections.  Also,
  // relro local sections go before relro non-local sections.
  if (parameters->options().relro() && os->is_relro())
    {
      gold_assert(pdl == &this->output_data_);
      Output_segment::Output_data_list::iterator p;
      for (p = pdl->begin(); p != pdl->end(); ++p)
	{
	  if (!(*p)->is_section())
	    break;
d3185 2
a3186 4
	  Output_section* pos = (*p)->output_section();
	  if (!pos->is_relro()
	      || (os->is_relro_local() && !pos->is_relro_local()))
	    break;
d3189 19
a3207 2
      pdl->insert(p, os);
      return;
a3395 13
      // If -z relro is in effect, and the first section in this
      // segment is a relro section, then the segment must be aligned
      // to at least the common page size.  This ensures that the
      // PT_GNU_RELRO segment will start at a page boundary.
      if (this->type_ == elfcpp::PT_LOAD
	  && parameters->options().relro()
	  && this->is_first_section_relro())
	{
	  addralign = parameters->target().common_pagesize();
	  if (addralign > this->max_align_)
	    this->max_align_ = addralign;
	}

d3449 3
a3451 1
                                      uint64_t addr, off_t* poff,
d3456 44
a3513 4
  bool in_relro = (parameters->options().relro()
		   && this->is_first_section_relro());

  off_t orig_off = *poff;
d3517 1
a3517 2
					  addr, poff, pshndx, &in_tls,
					  &in_relro);
d3525 1
a3525 1
                                                  &in_tls, &in_relro);
a3535 8
  // If all the sections were relro sections, align upward to the
  // common page size.
  if (in_relro)
    {
      uint64_t page_align = parameters->target().common_pagesize();
      *poff = align_address(*poff, page_align);
    }

d3553 1
a3553 1
                                           bool* in_tls, bool* in_relro)
a3603 13
	  // If this is a non-relro section after a relro section,
	  // align it to a common page boundary so that the dynamic
	  // linker has a page to mark as read-only.
	  if (*in_relro
	      && (!(*p)->is_section()
		  || !(*p)->output_section()->is_relro()))
	    {
	      uint64_t page_align = parameters->target().common_pagesize();
	      if (page_align > align)
		align = page_align;
	      *in_relro = false;
	    }

d3659 1
a3659 1
// any.
d3662 1
a3662 1
Output_segment::set_offset()
d3670 1
d3712 3
a3723 10

  // If this is a RELRO segment, align the memory size.  The code in
  // set_section_list ensures that the section after the RELRO segment
  // is aligned to give us room.
  if (this->type_ == elfcpp::PT_GNU_RELRO)
    {
      uint64_t page_align = parameters->target().common_pagesize();
      gold_assert(this->vaddr_ == align_address(this->vaddr_, page_align));
      this->memsz_ = align_address(this->memsz_, page_align);
    }
@


1.108
log
@2009-12-16  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::scan_sections_for_stubs): Exclude ICF-eliminated
	sections.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Handle
	relaxed input sections.
	* output.cc (Output_section::find_relaxed_input_section): Change
	return type to Output_relaxed_input_section pointer.  Adjust code
	for new type of relaxed_input_section_map_.
	* output.h (Output_section::find_relaxed_input_section): Change
	return type to Output_relaxed_input_section pointer.
	(Output_section::Output_relaxed_input_section_by_input_section_map):
	New type.
	(Output_section::relaxed_input_section_map_): Change type to
	Output_section::Output_relaxed_input_section_by_input_section_map.
	* symtab.cc (Symbol_table::compute_final_value): Handle relaxed
	input section.
@
text
@d1803 1
d1828 3
a1830 1
  if (this->entsize_ == 0)
d1832 5
a1836 2
  else
    gold_assert(this->entsize_ == v);
a1871 2
  this->update_flags_for_input_section(sh_flags);

d1882 3
d2209 16
@


1.107
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d2227 1
a2227 1
const Output_section_data*
d2250 1
a2250 1
  Output_section_data_by_input_section_map::const_iterator p =
@


1.106
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d357 1
a357 1
				       const char* aentry)
d363 1
a363 1
    entry_(aentry)
d512 3
a514 3
  const char* entry_sym = this->entry_;
  if (entry_sym == NULL)
    entry_sym = "_start";
d516 1
a516 1
  Symbol* sym = this->symtab_->lookup(entry_sym);
d524 1
a524 1
	gold_warning("entry symbol '%s' exists but is not defined", entry_sym);
d532 1
a532 1
      v = strtoull(entry_sym, &endptr, 0);
d536 1
a536 1
	    gold_warning("cannot find entry symbol '%s'", entry_sym);
d599 1
a599 1
Output_section_data::set_addralign(uint64_t addr_align)
d601 1
a601 1
  this->addralign_ = addr_align;
d603 2
a604 2
      && this->output_section_->addralign() < addr_align)
    this->output_section_->set_addralign(addr_align);
d636 1
a636 1
    bool is_rel)
d638 1
a638 1
    is_relative_(is_rel), is_section_symbol_(false), shndx_(INVALID_CODE)
d655 1
a655 1
    bool is_rel)
d657 1
a657 1
    is_relative_(is_rel), is_section_symbol_(false), shndx_(shndx)
d677 1
a677 1
    bool is_rel,
d680 1
a680 1
    is_relative_(is_rel), is_section_symbol_(is_section_symbol),
d700 1
a700 1
    bool is_rel,
d703 1
a703 1
    is_relative_(is_rel), is_section_symbol_(is_section_symbol),
d1225 3
a1227 3
  unsigned int g_offset = this->last_got_offset();
  gsym->set_got_offset(got_type, g_offset);
  rel_dyn->add_global(gsym, r_type, this, g_offset);
d1243 3
a1245 3
  unsigned int g_offset = this->last_got_offset();
  gsym->set_got_offset(got_type, g_offset);
  rela_dyn->add_global(gsym, r_type, this, g_offset, 0);
d1264 3
a1266 3
  unsigned int g_offset = this->last_got_offset();
  gsym->set_got_offset(got_type, g_offset);
  rel_dyn->add_global(gsym, r_type_1, this, g_offset);
d1271 2
a1272 2
      g_offset = this->last_got_offset();
      rel_dyn->add_global(gsym, r_type_2, this, g_offset);
d1291 3
a1293 3
  unsigned int g_offset = this->last_got_offset();
  gsym->set_got_offset(got_type, g_offset);
  rela_dyn->add_global(gsym, r_type_1, this, g_offset, 0);
d1298 2
a1299 2
      g_offset = this->last_got_offset();
      rela_dyn->add_global(gsym, r_type_2, this, g_offset, 0);
d1341 3
a1343 3
  unsigned int g_offset = this->last_got_offset();
  object->set_local_got_offset(symndx, got_type, g_offset);
  rel_dyn->add_local(object, symndx, r_type, this, g_offset);
d1360 3
a1362 3
  unsigned int g_offset = this->last_got_offset();
  object->set_local_got_offset(symndx, got_type, g_offset);
  rela_dyn->add_local(object, symndx, r_type, this, g_offset, 0);
d1383 2
a1384 2
  unsigned int g_offset = this->last_got_offset();
  object->set_local_got_offset(symndx, got_type, g_offset);
d1386 1
a1386 1
  rel_dyn->add_output_section(os, r_type_1, this, g_offset);
d1391 2
a1392 2
      g_offset = this->last_got_offset();
      rel_dyn->add_output_section(os, r_type_2, this, g_offset);
d1413 2
a1414 2
  unsigned int g_offset = this->last_got_offset();
  object->set_local_got_offset(symndx, got_type, g_offset);
d1416 1
a1416 1
  rela_dyn->add_output_section(os, r_type_1, this, g_offset, 0);
d1421 2
a1422 2
      g_offset = this->last_got_offset();
      rela_dyn->add_output_section(os, r_type_2, this, g_offset, 0);
d1574 1
a1574 1
  const off_t off = this->offset();
d1576 1
a1576 1
  unsigned char* const oview = of->get_output_view(off, oview_size);
d1589 1
a1589 1
  of->write_output_view(off, oview_size, oview);
d1600 1
a1600 1
  const off_t off = this->offset();
d1602 1
a1602 1
  unsigned char* const oview = of->get_output_view(off, oview_size);
d1611 1
a1611 1
  of->write_output_view(off, oview_size, oview);
d1685 2
a1686 2
    unsigned int sec_shndx,
    section_offset_type off,
d1690 1
a1690 1
    return this->u2_.posd->output_offset(object, sec_shndx, off, poutput);
d1693 1
a1693 1
      if (this->shndx_ != sec_shndx || this->u2_.object != object)
d1695 1
a1695 1
      *poutput = off;
d1705 1
a1705 1
						    unsigned int sec_shndx) const
d1709 1
a1709 1
  return this->u2_.posd->is_merge_section_for(object, sec_shndx);
d1764 3
a1766 3
Output_section::Output_section(const char* aname, elfcpp::Elf_Word atype,
			       elfcpp::Elf_Xword aflags)
  : name_(aname),
d1775 2
a1776 2
    type_(atype),
    flags_(aflags),
d1813 1
a1813 1
  if ((aflags & elfcpp::SHF_ALLOC) == 0)
d1848 1
a1848 1
				  unsigned int sec_shndx,
d1854 2
a1855 2
  elfcpp::Elf_Xword addr_align = shdr.get_sh_addralign();
  if ((addr_align & (addr_align - 1)) != 0)
d1858 2
a1859 2
		    static_cast<unsigned long>(addr_align), secname);
      addr_align = 1;
d1862 2
a1863 2
  if (addr_align > this->addralign_)
    this->addralign_ = addr_align;
d1868 1
a1868 1
  uint64_t ent_size = shdr.get_sh_entsize();
d1875 1
a1875 1
      ent_size = 1;
d1886 2
a1887 2
      if (this->add_merge_input_section(object, sec_shndx, sh_flags,
					ent_size, addr_align))
d1897 1
a1897 1
                                                  addr_align);
d1945 1
a1945 1
    this->input_sections_.push_back(Input_section(object, sec_shndx,
d1947 1
a1947 1
						  addr_align));
d2005 3
a2007 3
  uint64_t addr_align = inp->addralign();
  if (addr_align > this->addralign_)
    this->addralign_ = addr_align;
d2016 1
a2016 1
					 bool is_string, uint64_t ent_size)
d2018 1
a2018 1
  Input_section inp(posd, is_string, ent_size);
d2025 3
a2027 3
Output_section::add_merge_input_section(Relobj* object, unsigned int sec_shndx,
					uint64_t aflags, uint64_t ent_size,
					uint64_t addr_align)
d2029 1
a2029 1
  bool is_string = (aflags & elfcpp::SHF_STRINGS) != 0;
d2033 1
a2033 1
  if (is_string && addr_align > ent_size)
d2040 1
a2040 1
  Merge_section_properties msp(is_string, ent_size, addr_align);
d2046 1
a2046 1
      merge_section->add_input_section(object, sec_shndx);
d2048 2
a2049 2
		  && merge_section->entsize() == ent_size
		  && merge_section->addralign() == addr_align);
d2052 1
a2052 1
      Input_section_specifier iss(object, sec_shndx);
d2061 1
a2061 1
    pomb = new Output_merge_data(ent_size, addr_align);
d2064 1
a2064 1
      switch (ent_size)
d2067 1
a2067 1
	  pomb = new Output_merge_string<char>(addr_align);
d2070 1
a2070 1
	  pomb = new Output_merge_string<uint16_t>(addr_align);
d2073 1
a2073 1
	  pomb = new Output_merge_string<uint32_t>(addr_align);
d2082 1
a2082 1
  this->add_output_merge_section(pomb, is_string, ent_size);
d2087 2
a2088 2
  pomb->add_input_section(object, sec_shndx);
  Input_section_specifier iss(object, sec_shndx);
d2095 1
a2095 1
// Look up to the first LIMIT elements in INPUTSECTIONS.
d2099 1
a2099 1
  const Input_section_list& inputsections,
d2105 1
a2105 1
      const Input_section& is(inputsections[i]);
d2116 1
a2116 1
// specifier to indices of INPUTSECTIONS.
d2122 1
a2122 1
  Input_section_list* inputsections)
d2130 2
a2131 2
      gold_assert((*inputsections)[p->second].is_input_section());
      (*inputsections)[p->second] = Input_section(poris);
d2189 1
a2189 1
Output_section::update_flags_for_input_section(elfcpp::Elf_Xword aflags)
d2195 1
a2195 1
      && (aflags & elfcpp::SHF_ALLOC) != 0)
d2198 1
a2198 1
  this->flags_ |= (aflags
d2204 1
a2204 1
// Find the merge section into which an input section with index SEC_SHNDX in
d2209 1
a2209 1
				   unsigned int sec_shndx) const
d2211 1
a2211 1
  Input_section_specifier iss(object, sec_shndx);
d2217 1
a2217 1
      gold_assert(posd->is_merge_section_for(object, sec_shndx));
d2225 1
a2225 1
// in OBJECT with index SEC_SHNDX.
d2229 1
a2229 1
					   unsigned int sec_shndx) const
d2249 1
a2249 1
  Input_section_specifier iss(object, sec_shndx);
d2258 3
a2260 3
// Given an address OFF relative to the start of input section
// SEC_SHNDX in OBJECT, return whether this address is being included in
// the final link.  This should only be called if SEC_SHNDX in OBJECT has
d2265 2
a2266 2
					unsigned int sec_shndx,
					off_t off) const
d2269 1
a2269 1
  const Output_section_data* posd = this->find_merge_section(object, sec_shndx);
d2271 1
a2271 1
    posd = this->find_relaxed_input_section(object, sec_shndx);
d2275 2
a2276 2
      section_offset_type outputoffset;
      bool found = posd->output_offset(object, sec_shndx, off, &outputoffset);
d2278 1
a2278 1
      return outputoffset != -1;
d2286 3
a2288 3
      section_offset_type outputoffset;
      if (p->output_offset(object, sec_shndx, off, &outputoffset))
	return outputoffset != -1;
d2297 2
a2298 2
// Given an address OFF relative to the start of input section
// SEC_SHNDX in object OBJECT, return the output offset relative to the
d2300 1
a2300 1
// be called if SEC_SHNDX in OBJECT has a special mapping.
d2303 2
a2304 2
Output_section::output_offset(const Relobj* object, unsigned int sec_shndx,
			      section_offset_type off) const
d2311 1
a2311 1
  const Output_section_data* posd = this->find_merge_section(object, sec_shndx);
d2313 1
a2313 1
    posd = this->find_relaxed_input_section(object, sec_shndx);
d2316 2
a2317 2
      section_offset_type outputoffset;
      bool found = posd->output_offset(object, sec_shndx, off, &outputoffset);
d2319 1
a2319 1
      return outputoffset;
d2327 3
a2329 3
      section_offset_type outputoffset;
      if (p->output_offset(object, sec_shndx, off, &outputoffset))
	return outputoffset;
d2334 2
a2335 2
// Return the output virtual address of OFF relative to the start
// of input section SEC_SHNDX in object OBJECT.
d2338 2
a2339 2
Output_section::output_address(const Relobj* object, unsigned int sec_shndx,
			       off_t off) const
d2344 1
a2344 1
  const Output_section_data* posd = this->find_merge_section(object, sec_shndx);
d2346 1
a2346 1
    posd = this->find_relaxed_input_section(object, sec_shndx);
d2349 2
a2350 2
      section_offset_type outputoffset;
      bool found = posd->output_offset(object, sec_shndx, off, &outputoffset);
d2352 1
a2352 1
      return posd->address() + outputoffset;
d2361 2
a2362 2
      section_offset_type outputoffset;
      if (p->output_offset(object, sec_shndx, off, &outputoffset))
d2364 1
a2364 1
	  if (outputoffset == -1)
d2366 1
a2366 1
	  return addr + outputoffset;
d2380 1
a2380 1
// input section SEC_SHNDX in object OBJECT.
d2384 1
a2384 1
					     unsigned int sec_shndx,
d2401 1
a2401 1
      if (p->is_merge_section_for(object, sec_shndx))
d2429 1
a2429 1
  uint64_t addr = this->address();
d2437 1
a2437 1
      p->set_address_and_file_offset(addr + (off - startoff), off,
d2501 5
a2505 5
  Input_section_sort_entry(const Input_section& inputsection,
			   unsigned int indx)
    : input_section_(inputsection), index_(indx),
      section_has_name_(inputsection.is_input_section()
			|| inputsection.is_relaxed_input_section())
d2513 3
a2515 3
	Object* obj = (inputsection.is_input_section()
		       ? inputsection.relobj()
		       : inputsection.relaxed_input_section()->relobj());
d2520 1
a2520 1
	this->section_name_ = obj->section_name(inputsection.shndx());
d2571 1
a2571 1
  match_file_name(const char* match_filename) const
d2575 2
a2576 2
    size_t match_len = strlen(match_filename);
    if (strncmp(base_name, match_filename, match_len) != 0)
d2709 1
a2709 1
  elfcpp::Elf_Xword xflags = this->flags_;
d2711 2
a2712 2
    xflags |= elfcpp::SHF_INFO_LINK;
  oshdr->put_sh_flags(xflags);
d2726 1
a2726 1
  elfcpp::Elf_Word inf;
d2730 1
a2730 1
	inf = this->info_section_->out_shndx();
d2732 1
a2732 1
	inf = this->info_section_->symtab_index();
d2735 1
a2735 1
    inf = this->info_symndx_->symtab_index();
d2737 2
a2738 2
    inf = this->info_;
  oshdr->put_sh_info(inf);
d2865 1
a2865 1
    uint64_t addr,
d2867 1
a2867 1
    std::list<Simple_input_section>* inputsections)
d2876 1
a2876 1
  uint64_t orig_address = addr;
d2878 1
a2878 1
  addr = align_address(addr, this->addralign());
d2886 1
a2886 1
	inputsections->push_back(Simple_input_section(p->relobj(),
d2889 1
a2889 1
	inputsections->push_back(
d2893 2
a2894 2
	  uint64_t aligned_address = align_address(addr, p->addralign());
	  if (aligned_address != addr && !fill.empty())
d2897 1
a2897 1
		convert_to_section_size_type(aligned_address - addr);
d2908 1
a2908 1
	  addr = aligned_address;
d2913 1
a2913 1
	  addr += p->data_size();
d2920 3
a2922 3
  uint64_t datasize = addr - orig_address;
  this->set_current_data_size_for_child(datasize);
  return datasize;
d2929 2
a2930 2
					     off_t datasize,
					     uint64_t addr_align)
d2932 2
a2933 2
  if (addr_align > this->addralign_)
    this->addralign_ = addr_align;
d2937 1
a2937 1
						  addr_align);
d2940 1
a2940 1
					+ datasize);
d2945 1
a2945 1
     : Input_section(sis.relobj(), sis.shndx(), datasize, addr_align));
d3025 1
a3025 1
Output_segment::Output_segment(elfcpp::Elf_Word atype, elfcpp::Elf_Word aflags)
d3035 2
a3036 2
    type_(atype),
    flags_(aflags),
d3335 1
a3335 1
      uint64_t addr_align;
d3337 7
a3343 7
      addr_align = Output_segment::maximum_alignment_list(&this->output_data_);
      if (addr_align > this->max_align_)
	this->max_align_ = addr_align;

      addr_align = Output_segment::maximum_alignment_list(&this->output_bss_);
      if (addr_align > this->max_align_)
	this->max_align_ = addr_align;
d3353 3
a3355 3
	  addr_align = parameters->target().common_pagesize();
	  if (addr_align > this->max_align_)
	    this->max_align_ = addr_align;
d3374 3
a3376 3
      uint64_t addr_align = (*p)->addralign();
      if (addr_align > ret)
	ret = addr_align;
d4141 1
a4141 1
    unsigned int sec_shndx,
d4153 1
a4153 1
    unsigned int sec_shndx,
d4165 1
a4165 1
    unsigned int sec_shndx,
d4177 1
a4177 1
    unsigned int sec_shndx,
@


1.105
log
@Remove debugging code accidentally included in last commit.
@
text
@d357 1
a357 1
				       const char* entry)
d363 1
a363 1
    entry_(entry)
d512 3
a514 3
  const char* entry = this->entry_;
  if (entry == NULL)
    entry = "_start";
d516 1
a516 1
  Symbol* sym = this->symtab_->lookup(entry);
d524 1
a524 1
	gold_warning("entry symbol '%s' exists but is not defined", entry);
d532 1
a532 1
      v = strtoull(entry, &endptr, 0);
d536 1
a536 1
	    gold_warning("cannot find entry symbol '%s'", entry);
d599 1
a599 1
Output_section_data::set_addralign(uint64_t addralign)
d601 1
a601 1
  this->addralign_ = addralign;
d603 2
a604 2
      && this->output_section_->addralign() < addralign)
    this->output_section_->set_addralign(addralign);
d636 1
a636 1
    bool is_relative)
d638 1
a638 1
    is_relative_(is_relative), is_section_symbol_(false), shndx_(INVALID_CODE)
d655 1
a655 1
    bool is_relative)
d657 1
a657 1
    is_relative_(is_relative), is_section_symbol_(false), shndx_(shndx)
d677 1
a677 1
    bool is_relative,
d680 1
a680 1
    is_relative_(is_relative), is_section_symbol_(is_section_symbol),
d700 1
a700 1
    bool is_relative,
d703 1
a703 1
    is_relative_(is_relative), is_section_symbol_(is_section_symbol),
d1225 3
a1227 3
  unsigned int got_offset = this->last_got_offset();
  gsym->set_got_offset(got_type, got_offset);
  rel_dyn->add_global(gsym, r_type, this, got_offset);
d1243 3
a1245 3
  unsigned int got_offset = this->last_got_offset();
  gsym->set_got_offset(got_type, got_offset);
  rela_dyn->add_global(gsym, r_type, this, got_offset, 0);
d1264 3
a1266 3
  unsigned int got_offset = this->last_got_offset();
  gsym->set_got_offset(got_type, got_offset);
  rel_dyn->add_global(gsym, r_type_1, this, got_offset);
d1271 2
a1272 2
      got_offset = this->last_got_offset();
      rel_dyn->add_global(gsym, r_type_2, this, got_offset);
d1291 3
a1293 3
  unsigned int got_offset = this->last_got_offset();
  gsym->set_got_offset(got_type, got_offset);
  rela_dyn->add_global(gsym, r_type_1, this, got_offset, 0);
d1298 2
a1299 2
      got_offset = this->last_got_offset();
      rela_dyn->add_global(gsym, r_type_2, this, got_offset, 0);
d1341 3
a1343 3
  unsigned int got_offset = this->last_got_offset();
  object->set_local_got_offset(symndx, got_type, got_offset);
  rel_dyn->add_local(object, symndx, r_type, this, got_offset);
d1360 3
a1362 3
  unsigned int got_offset = this->last_got_offset();
  object->set_local_got_offset(symndx, got_type, got_offset);
  rela_dyn->add_local(object, symndx, r_type, this, got_offset, 0);
d1383 2
a1384 2
  unsigned int got_offset = this->last_got_offset();
  object->set_local_got_offset(symndx, got_type, got_offset);
d1386 1
a1386 1
  rel_dyn->add_output_section(os, r_type_1, this, got_offset);
d1391 2
a1392 2
      got_offset = this->last_got_offset();
      rel_dyn->add_output_section(os, r_type_2, this, got_offset);
d1413 2
a1414 2
  unsigned int got_offset = this->last_got_offset();
  object->set_local_got_offset(symndx, got_type, got_offset);
d1416 1
a1416 1
  rela_dyn->add_output_section(os, r_type_1, this, got_offset, 0);
d1421 2
a1422 2
      got_offset = this->last_got_offset();
      rela_dyn->add_output_section(os, r_type_2, this, got_offset, 0);
d1574 1
a1574 1
  const off_t offset = this->offset();
d1576 1
a1576 1
  unsigned char* const oview = of->get_output_view(offset, oview_size);
d1589 1
a1589 1
  of->write_output_view(offset, oview_size, oview);
d1600 1
a1600 1
  const off_t offset = this->offset();
d1602 1
a1602 1
  unsigned char* const oview = of->get_output_view(offset, oview_size);
d1611 1
a1611 1
  of->write_output_view(offset, oview_size, oview);
d1685 2
a1686 2
    unsigned int shndx,
    section_offset_type offset,
d1690 1
a1690 1
    return this->u2_.posd->output_offset(object, shndx, offset, poutput);
d1693 1
a1693 1
      if (this->shndx_ != shndx || this->u2_.object != object)
d1695 1
a1695 1
      *poutput = offset;
d1705 1
a1705 1
						    unsigned int shndx) const
d1709 1
a1709 1
  return this->u2_.posd->is_merge_section_for(object, shndx);
d1764 3
a1766 3
Output_section::Output_section(const char* name, elfcpp::Elf_Word type,
			       elfcpp::Elf_Xword flags)
  : name_(name),
d1775 2
a1776 2
    type_(type),
    flags_(flags),
d1813 1
a1813 1
  if ((flags & elfcpp::SHF_ALLOC) == 0)
d1848 1
a1848 1
				  unsigned int shndx,
d1854 2
a1855 2
  elfcpp::Elf_Xword addralign = shdr.get_sh_addralign();
  if ((addralign & (addralign - 1)) != 0)
d1858 2
a1859 2
		    static_cast<unsigned long>(addralign), secname);
      addralign = 1;
d1862 2
a1863 2
  if (addralign > this->addralign_)
    this->addralign_ = addralign;
d1868 1
a1868 1
  uint64_t entsize = shdr.get_sh_entsize();
d1875 1
a1875 1
      entsize = 1;
d1886 2
a1887 2
      if (this->add_merge_input_section(object, shndx, sh_flags,
					entsize, addralign))
d1897 1
a1897 1
                                                  addralign);
d1945 1
a1945 1
    this->input_sections_.push_back(Input_section(object, shndx,
d1947 1
a1947 1
						  addralign));
d2005 3
a2007 3
  uint64_t addralign = inp->addralign();
  if (addralign > this->addralign_)
    this->addralign_ = addralign;
d2016 1
a2016 1
					 bool is_string, uint64_t entsize)
d2018 1
a2018 1
  Input_section inp(posd, is_string, entsize);
d2025 3
a2027 3
Output_section::add_merge_input_section(Relobj* object, unsigned int shndx,
					uint64_t flags, uint64_t entsize,
					uint64_t addralign)
d2029 1
a2029 1
  bool is_string = (flags & elfcpp::SHF_STRINGS) != 0;
d2033 1
a2033 1
  if (is_string && addralign > entsize)
d2040 1
a2040 1
  Merge_section_properties msp(is_string, entsize, addralign);
d2046 1
a2046 1
      merge_section->add_input_section(object, shndx);
d2048 2
a2049 2
		  && merge_section->entsize() == entsize
		  && merge_section->addralign() == addralign);
d2052 1
a2052 1
      Input_section_specifier iss(object, shndx);
d2061 1
a2061 1
    pomb = new Output_merge_data(entsize, addralign);
d2064 1
a2064 1
      switch (entsize)
d2067 1
a2067 1
	  pomb = new Output_merge_string<char>(addralign);
d2070 1
a2070 1
	  pomb = new Output_merge_string<uint16_t>(addralign);
d2073 1
a2073 1
	  pomb = new Output_merge_string<uint32_t>(addralign);
d2082 1
a2082 1
  this->add_output_merge_section(pomb, is_string, entsize);
d2087 2
a2088 2
  pomb->add_input_section(object, shndx);
  Input_section_specifier iss(object, shndx);
d2095 1
a2095 1
// Look up to the first LIMIT elements in INPUT_SECTIONS.
d2099 1
a2099 1
  const Input_section_list& input_sections,
d2105 1
a2105 1
      const Input_section& is(input_sections[i]);
d2116 1
a2116 1
// specifier to indices of INPUT_SECTIONS.
d2122 1
a2122 1
  Input_section_list* input_sections)
d2130 2
a2131 2
      gold_assert((*input_sections)[p->second].is_input_section());
      (*input_sections)[p->second] = Input_section(poris);
d2189 1
a2189 1
Output_section::update_flags_for_input_section(elfcpp::Elf_Xword flags)
d2195 1
a2195 1
      && (flags & elfcpp::SHF_ALLOC) != 0)
d2198 1
a2198 1
  this->flags_ |= (flags
d2204 1
a2204 1
// Find the merge section into which an input section with index SHNDX in
d2209 1
a2209 1
				   unsigned int shndx) const
d2211 1
a2211 1
  Input_section_specifier iss(object, shndx);
d2217 1
a2217 1
      gold_assert(posd->is_merge_section_for(object, shndx));
d2225 1
a2225 1
// in OBJECT with index SHNDX.
d2229 1
a2229 1
					   unsigned int shndx) const
d2249 1
a2249 1
  Input_section_specifier iss(object, shndx);
d2258 3
a2260 3
// Given an address OFFSET relative to the start of input section
// SHNDX in OBJECT, return whether this address is being included in
// the final link.  This should only be called if SHNDX in OBJECT has
d2265 2
a2266 2
					unsigned int shndx,
					off_t offset) const
d2269 1
a2269 1
  const Output_section_data* posd = this->find_merge_section(object, shndx);
d2271 1
a2271 1
    posd = this->find_relaxed_input_section(object, shndx);
d2275 2
a2276 2
      section_offset_type output_offset;
      bool found = posd->output_offset(object, shndx, offset, &output_offset);
d2278 1
a2278 1
      return output_offset != -1;
d2286 3
a2288 3
      section_offset_type output_offset;
      if (p->output_offset(object, shndx, offset, &output_offset))
	return output_offset != -1;
d2297 2
a2298 2
// Given an address OFFSET relative to the start of input section
// SHNDX in object OBJECT, return the output offset relative to the
d2300 1
a2300 1
// be called if SHNDX in OBJECT has a special mapping.
d2303 2
a2304 2
Output_section::output_offset(const Relobj* object, unsigned int shndx,
			      section_offset_type offset) const
d2311 1
a2311 1
  const Output_section_data* posd = this->find_merge_section(object, shndx);
d2313 1
a2313 1
    posd = this->find_relaxed_input_section(object, shndx);
d2316 2
a2317 2
      section_offset_type output_offset;
      bool found = posd->output_offset(object, shndx, offset, &output_offset);
d2319 1
a2319 1
      return output_offset;
d2327 3
a2329 3
      section_offset_type output_offset;
      if (p->output_offset(object, shndx, offset, &output_offset))
	return output_offset;
d2334 2
a2335 2
// Return the output virtual address of OFFSET relative to the start
// of input section SHNDX in object OBJECT.
d2338 2
a2339 2
Output_section::output_address(const Relobj* object, unsigned int shndx,
			       off_t offset) const
d2344 1
a2344 1
  const Output_section_data* posd = this->find_merge_section(object, shndx);
d2346 1
a2346 1
    posd = this->find_relaxed_input_section(object, shndx);
d2349 2
a2350 2
      section_offset_type output_offset;
      bool found = posd->output_offset(object, shndx, offset, &output_offset);
d2352 1
a2352 1
      return posd->address() + output_offset;
d2361 2
a2362 2
      section_offset_type output_offset;
      if (p->output_offset(object, shndx, offset, &output_offset))
d2364 1
a2364 1
	  if (output_offset == -1)
d2366 1
a2366 1
	  return addr + output_offset;
d2380 1
a2380 1
// input section SHNDX in object OBJECT.
d2384 1
a2384 1
					     unsigned int shndx,
d2401 1
a2401 1
      if (p->is_merge_section_for(object, shndx))
d2429 1
a2429 1
  uint64_t address = this->address();
d2437 1
a2437 1
      p->set_address_and_file_offset(address + (off - startoff), off,
d2501 5
a2505 5
  Input_section_sort_entry(const Input_section& input_section,
			   unsigned int index)
    : input_section_(input_section), index_(index),
      section_has_name_(input_section.is_input_section()
			|| input_section.is_relaxed_input_section())
d2513 3
a2515 3
	Object* obj = (input_section.is_input_section()
		       ? input_section.relobj()
		       : input_section.relaxed_input_section()->relobj());
d2520 1
a2520 1
	this->section_name_ = obj->section_name(input_section.shndx());
d2571 1
a2571 1
  match_file_name(const char* match_file_name) const
d2575 2
a2576 2
    size_t match_len = strlen(match_file_name);
    if (strncmp(base_name, match_file_name, match_len) != 0)
d2709 1
a2709 1
  elfcpp::Elf_Xword flags = this->flags_;
d2711 2
a2712 2
    flags |= elfcpp::SHF_INFO_LINK;
  oshdr->put_sh_flags(flags);
d2726 1
a2726 1
  elfcpp::Elf_Word info;
d2730 1
a2730 1
	info = this->info_section_->out_shndx();
d2732 1
a2732 1
	info = this->info_section_->symtab_index();
d2735 1
a2735 1
    info = this->info_symndx_->symtab_index();
d2737 2
a2738 2
    info = this->info_;
  oshdr->put_sh_info(info);
d2865 1
a2865 1
    uint64_t address,
d2867 1
a2867 1
    std::list<Simple_input_section>* input_sections)
d2876 1
a2876 1
  uint64_t orig_address = address;
d2878 1
a2878 1
  address = align_address(address, this->addralign());
d2886 1
a2886 1
	input_sections->push_back(Simple_input_section(p->relobj(),
d2889 1
a2889 1
	input_sections->push_back(
d2893 2
a2894 2
	  uint64_t aligned_address = align_address(address, p->addralign());
	  if (aligned_address != address && !fill.empty())
d2897 1
a2897 1
		convert_to_section_size_type(aligned_address - address);
d2908 1
a2908 1
	  address = aligned_address;
d2913 1
a2913 1
	  address += p->data_size();
d2920 3
a2922 3
  uint64_t data_size = address - orig_address;
  this->set_current_data_size_for_child(data_size);
  return data_size;
d2929 2
a2930 2
					     off_t data_size,
					     uint64_t addralign)
d2932 2
a2933 2
  if (addralign > this->addralign_)
    this->addralign_ = addralign;
d2937 1
a2937 1
						  addralign);
d2940 1
a2940 1
					+ data_size);
d2945 1
a2945 1
     : Input_section(sis.relobj(), sis.shndx(), data_size, addralign));
d3025 1
a3025 1
Output_segment::Output_segment(elfcpp::Elf_Word type, elfcpp::Elf_Word flags)
d3035 2
a3036 2
    type_(type),
    flags_(flags),
d3335 1
a3335 1
      uint64_t addralign;
d3337 7
a3343 7
      addralign = Output_segment::maximum_alignment_list(&this->output_data_);
      if (addralign > this->max_align_)
	this->max_align_ = addralign;

      addralign = Output_segment::maximum_alignment_list(&this->output_bss_);
      if (addralign > this->max_align_)
	this->max_align_ = addralign;
d3353 3
a3355 3
	  addralign = parameters->target().common_pagesize();
	  if (addralign > this->max_align_)
	    this->max_align_ = addralign;
d3374 3
a3376 3
      uint64_t addralign = (*p)->addralign();
      if (addralign > ret)
	ret = addralign;
d4141 1
a4141 1
    unsigned int shndx,
d4153 1
a4153 1
    unsigned int shndx,
d4165 1
a4165 1
    unsigned int shndx,
d4177 1
a4177 1
    unsigned int shndx,
@


1.104
log
@	PR 10910
	* output.cc (Output_segment::add_output_section): Add missing
	return statement.
@
text
@a3556 1
#if 0
a3559 1
#endif
@


1.103
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d3053 1
d3069 1
a3069 7
  // that all SHT_NOTE sections are adjacent.  This will normally
  // happen automatically, because all the SHT_NOTE input sections
  // will wind up in the same output section.  However, it is possible
  // for multiple SHT_NOTE input sections to have different section
  // flags, and thus be in different output sections, but for the
  // different section flags to map into the same segment flags and
  // thus the same output segment.
d3249 1
d3557 1
d3561 1
@


1.102
log
@2009-10-30  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:
	* arm.h (EF_ARM_BE8, EF_ARM_EABIMASK, EF_ARM_EABI_UNKNOWN,
	EF_ARM_EABI_VER1, EF_ARM_EABI_VER2, EF_ARM_EABI_VER3,
	EF_ARM_EABI_VER4, EF_ARM_EABI_VER5): New enums for processor-specific
	flags.
	(arm_eabi_version): New inline function.
	* elfcpp.h: Add a comment about DT_ENCODING.

gold/ChangeLog:
	* arm.cc (Arm_relobj::processor_specific_flags): New method
	definition.
	(Arm_relobj::do_read_symbols): New method declaration.
	(Arm_relobj::processor_specific_flags_): New data member declaration.
	(Arm_dynobj): New class definition.
	(Target_arm::do_finalize_sections): Add input_objects parameter.
	(Target_arm::do_adjust_elf_header): New method declaration.
	(Target_arm::are_eabi_versions_compatible,
	(Target_arm::merge_processor_specific_flags): New method declaration.
	(Target_arm::do_make_elf_object): New overloaded method definitions
	and declaration.
	(Arm_relobj::do_read_symbols): New method definition.
	(Arm_dynobj::do_read_symbols): Ditto.
	(Target_arm::do_finalize_sections): Add input_objects parameters.
	Merge processor-specific flags from all input objects.
	(Target_arm::are_eabi_versions_compatible,
	Target_arm::merge_processor_specific_flags,
	Target_arm::do_adjust_elf_header, Target_arm::do_make_elf_object):
	New method definitions.
	* i386.cc (Target_i386::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* layout.cc (Layout::finalize): Pass input objects to target's.
	finalize_sections function.
	* output.cc (Output_file_header::do_sized_write): Set ELF file
	header's processor-specific flags.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* sparc.cc (Target_sparc::do_finalize_sections): Same.
	* target.h (Input_objects): New forward class declaration.
	(Target::processor_specific_flags,
	Target::are_processor_specific_flags_sect): New method definitions.
	(Target::finalize_sections): Add input_objects parameter.
	(Target::Target): Initialize processor_specific_flags_ and
	are_processor_specific_flags_set_.
	(Target::do_finalize_sections): Add unnamed Input_objects pointer type
	parameter.
	(Target::set_processor_specific_flags): New method definition.
	(Target::processor_specific_flags_,
	Target::are_processor_specific_flags_set_): New data member
	declarations.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
@
text
@d1800 3
d1808 1
a1808 2
    is_relaxed_input_section_map_valid_(true),
    generate_code_fills_at_write_(false)
d3047 2
a3048 1
				   elfcpp::Elf_Word seg_flags)
d3063 4
a3074 5

  // Note that while there may be many input sections in an output
  // section, there are normally only a few output sections in an
  // output segment.  This loop is expected to be fast.

d3096 2
a3097 2
  // and the PT_TLS segment -- we do this grouping only for the
  // PT_LOAD segment.
d3227 61
@


1.101
log
@2009-10-16  Doug Kwan  <dougkwan@@google.com>

	* output.cc (Output_segment::set_section_list_address): Cast
	expressions to unsigned long long type to avoid format warnings.
@
text
@d462 1
a462 4

  // FIXME: The target needs to set the flags.
  oehdr.put_e_flags(0);

@


1.100
log
@	* layout.cc (Layout::set_segment_offsets): Align the file offset
	to the segment aligment for -N or -n with no load segment.
	* output.cc (Output_segment::add_output_section): Don't crash if
	the first section is a TLS section.
	(Output_segment::set_section_list_addresses): Print an error
	message if the address moves backward in a linker script.
	* script-sections.cc
	(Output_section_element_input::set_section_addresses): Don't
	increase *dot_value for a SHF_TLS/SHT_NOBITS section.
	(Orphan_output_section::set_section_addresses): Likewise.
@
text
@d3506 7
d3515 1
a3515 2
				 "from 0x%llx to 0x%llx"),
			       addr + (off - startoff), (*p)->address());
d3519 1
a3519 2
			       os->name(), addr + (off - startoff),
			       (*p)->address());
@


1.99
log
@	Add support for -pie.
	* options.h (class General_options): Add -pie and
	--pic-executable.
	(General_options::output_is_position_independent): Test -pie.
	(General_options::output_is_executable): Return true if not shared
	and not relocatable.
	(General_options::output_is_pie): Remove.
	* options.cc (General_options::finalize): Reject incompatible uses
	of -pie.
	* gold.cc (queue_middle_tasks): A -pie link is not static.
	* symtab.h (Symbol::needs_plt_entry): Return false if -pie.
	* symtab.cc (Symbol::final_value_is_known): Return false if
	output_is_position_independent.
	* layout.cc (Layout::set_segment_offsets): Start at address 0 if
	output_is_position_independent.
	* output.cc (Output_file_header::do_sized_write): Use ET_DYN if
	output_is_position_independent.
	* i386.cc (Output_data_plt_i386::do_write): Use the PIC PLT if
	output_is_position_independent.
	* testsuite/Makefile.am (check_PROGRAMS): Add basic_pie_test and
	two_file_pie_test.
	(basic_pie_test.o, basic_pie_test): New targets.
	(two_file_test_1_pie.o, two_file_test_1b_pie.o): New targets.
	(two_file_test_2_pie.o, two_file_test_main_pie.o): New targets.
	(two_file_pie_test): New target.
	* testsuite/Makefile.in: Rebuild.
	* README: Remove note saying that -pie is not supported.
@
text
@d3103 1
a3103 4
      bool nobits = os->type() == elfcpp::SHT_NOBITS;
      bool sawtls = false;
      Output_segment::Output_data_list::iterator p = pdl->end();
      do
d3105 5
a3109 3
	  --p;
	  bool insert;
	  if ((*p)->is_section_flag_set(elfcpp::SHF_TLS))
d3111 17
a3127 12
	      sawtls = true;
	      // Put a NOBITS section after the first TLS section.
	      // Put a PROGBITS section after the first TLS/PROGBITS
	      // section.
	      insert = nobits || !(*p)->is_section_type(elfcpp::SHT_NOBITS);
	    }
	  else
	    {
	      // If we've gone past the TLS sections, but we've seen a
	      // TLS section, then we need to insert this section now.
	      insert = sawtls;
	    }
d3129 6
a3134 5
	  if (insert)
	    {
	      ++p;
	      pdl->insert(p, os);
	      return;
d3136 1
a3137 1
      while (p != pdl->begin());
d3497 20
a3516 2
	  gold_assert((*p)->address() >= addr + (off - startoff));
	  off += (*p)->address() - (addr + (off - startoff));
@


1.98
log
@2009-10-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::make_output_section): Call target hook to make
	ordinary output section.
	(Layout::finalize): Adjust parameter list of call the
	Target::may_relax().
	* layout.h (class Layout::section_list): New method.
	* merge.h (Output_merge_base::entsize): Change visibility to public.
	(Output_merge_base::is_string, Output_merge_base::do_is_string):
	New methods.
	(Output_merge_string::do_is_string): New method.
	* object.cc (Sized_relobj::do_setup): renamed from
	Sized_relobj::set_up.
	* object.h (Sized_relobj::adjust_shndx,
	Sized_relobj::initializ_input_to_output_maps,
	Sized_relobj::free_input_to_output_maps): Change visibilities to
	protected.
	(Sized_relobj::setup): Virtualize.
	(Sized_relobj::do_setup): New method declaration.
	(Sized_relobj::invalidate_section_offset,
	Sized_relobj::do_invalidate_section_offset): New method decfinitions.
	(Sized_relobj::elf_file, Sized_relobj::local_values): New methods.
	* options.cc (parse_int): New function.
	* options.h (parse_int): New declaration.
	(DEFINE_int): New macro.
	(stub_group_size): New option.
	* output.cc (Output_section::Output_section): Initialize memebers
	merge_section_map_, merge_section_by_properties_map_,
	relaxed_input_section_map_, is_relaxed_input_section_map_valid_.
	(Output_section::add_input_section): Handled deferred code-fill
	generation and remove an old comment.
	(Output_section::add_relaxed_input_section): New method definition.
	(Output_section::add_merge_input_section): Use merge section by
	properties map to speed to search.  Update merge section maps
	as appropriate.
	(Output_section::build_relaxation_map): New method definition.
	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Same.
	(Output_section::relax_input_section): Renamed to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of pointers to relaxed sections.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section): New method definitions.
	(Output_section::is_input_address_mapped,
	Output_section::output_offset, Output_section::output_address):
	Use output section data maps to speed up searching.
	(Output_section::find_starting_output_address): Add comments.
	(Output_section::do_write,
	Output_section::write_to_postprocessing_buffer): Do code-fill
	generation as appropriate.
	(Output_section::get_input_sections): Invalidate relaxed input section
	map.
	(Output_section::restore_states): Adjust type of checkpoint .
	Invalidate relaxed input section map.
	* output.h (Output_merge_base): New class declaration.
	(Input_section_specifier): New class defintion.
	(class Output_relaxed_input_section) Change base class to
	Output_section_data_build.
	(Output_relaxed_input_section::Output_relaxed_input_section): Adjust
	base class initializer.
	(Output_section::add_relaxed_input_section): New method declaration.
	(Output_section::Input_section): Change visibility to protected.
     	(Output_section::Input_section::relobj,
	Output_section::Input_section::shndx): Handle relaxed input sections.
	Output_section::input_sections) Change visibility to protected.  Also
	define overload to return a non-const pointer.
	(Output_section::Merge_section_properties): New class defintion.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Relaxation_map): New types.
	(Output_section::relax_input_section): Rename method to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of relaxed section pointers.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section,
	Output_section::build_relaxation_map,
	Output_section::convert_input_sections_in_list_to_relaxed_sections):
	New method declarations.
	(Output_section::merge_section_map_
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_,
	Output_section::generate_code_fills_at_write_): New data members.
	* script-sections.cc
	(Output_section_element_input::set_section_addresses): Call
	current_data_size and addralign methods of relaxed input sections.
	(Orphan_output_section::set_section_addresses): Call current_data_size
	and addralign methods of relaxed input sections.
	* symtab.cc (Symbol_table::compute_final_value): Extract template
	from the body of Symbol_table::sized_finalize_symbol.
	(Symbol_table::sized_finalized_symbol): Call
	Symbol_table::compute_final_value.
	* symtab.h (Symbol_table::Compute_final_value_status): New enum type.
	(Symbol_table::compute_final_value): New templated method declaration.
	* target.cc (Target::do_make_output_section): New method defintion.
	* target.h (Target::make_output_section): New method declaration.
	(Target::relax): Add more parameters for input objects, symbol table
	and layout.  Adjust call to do_relax.
	(Target::do_make_output_section): New method declaration.
	(Target::do_relax): Add parameters for input objects, symbol table
	and layout.
@
text
@d445 1
a445 1
  else if (parameters->options().shared())
@


1.97
log
@	* object.h (class Object): Remove target_ field, and target,
	sized_target, and set_target methods.
	(Object::sized_target): Remove.
	(class Sized_relobj): Update declarations.  Remove sized_target.
	* object.cc (Sized_relobj::setup): Remove target parameter.
	Change all callers.
	(Input_objects::add_object): Don't do anything with the target.
	(make_elf_sized_object): Add punconfigured parameter.  Change all
	callers.  Set or test parameter target.
	* dynobj.cc (Sized_dynobj::target): Remove target parameter.
	Change all callers.
	* parameters.cc (Parameters::set_target): Change parameter type to
	be non-const.
	(Parameters::default_target): Remove.
	(set_parameters_target): Change parameter type to be non-const.
	(parameters_force_valid_target): New function.
	(parameters_clear_target): New function.
	* parameters.h (class Parameters): Update declarations.  Remove
	default_target method.  Add sized_target and clear_target
	methods.  Change target_ to be non-const.
	(set_parameters_target): Update declaration.
	(parameters_force_valid_target): Declare.
	(parameters_clear_target): Declare.
	* readsyms.cc (Read_symbols::do_read_symbols): Pass punconfigured
	as NULL if we aren't searching.
	(Add_symbols::run): Don't check for compatible target.
	* fileread.cc (Input_file::open_binary): Call
	parameters_force_valid_target.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (make_sized_plugin_object): Likewise.  Don't call
	set_target on object.
	* dynobj.h (class Sized_dynobj): Update declarations.
	* archive.cc (Archive::get_elf_object_for_member): Return NULL if
	make_elf_object returns NULL.
	(Archive::include_member): Don't check whether object target is
	compatible.
	* output.cc (Output_section::add_input_section): Get target from
	parameters.
	(Output_section::relax_input_section): Likewise.
	* reloc.cc (Sized_relobj::do_gc_process_relocs): Get target from
	parameters.
	(Sized_relobj::do_scan_relocs): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* symtab.cc (Symbol_table::wrap_symbol): Likewise.  Remove object
	parameter.  Change all callers.
	(Symbol_table::add_from_object): Get target from parameters.
	(Symbol_table::add_from_relobj): Don't check object target.
	(Symbol_table::add_from_dynobj): Likewise.
	(Symbol_table::define_special_symbol): Get target from
	parameters.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/binary_unittest.cc (gold_testsuite): Remove target
	parameter.  Change all callers.  Clear parameter target.
	(Binary_test): Test target here.
	* testsuite/object_unittest.cc (gold_testsuite): Remove
	target_test_pointer parameter.  Change all callers.
	(Object_test): Test target here.
@
text
@d1804 6
a1809 1
    checkpoint_(NULL)
d1900 13
d1914 1
a1926 2
          // FIXME: When relaxing, the size needs to adjust to
          // maintain a constant alignment.
d1971 25
d2040 17
a2056 9
  Input_section_list::iterator p;
  for (p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
    if (p->is_merge_section(is_string, entsize, addralign))
      {
        p->add_input_section(object, shndx);
        return true;
      }
d2060 1
a2060 1
  Output_section_data* posd;
d2062 1
a2062 1
    posd = new Output_merge_data(entsize, addralign);
d2068 1
a2068 1
	  posd = new Output_merge_string<char>(addralign);
d2071 1
a2071 1
	  posd = new Output_merge_string<uint16_t>(addralign);
d2074 1
a2074 1
	  posd = new Output_merge_string<uint32_t>(addralign);
d2081 10
a2090 2
  this->add_output_merge_section(posd, is_string, entsize);
  posd->add_input_section(object, shndx);
d2095 3
a2097 1
// Relax an existing input section.
d2099 4
a2102 1
Output_section::relax_input_section(Output_relaxed_input_section *psection)
d2104 35
a2138 2
  Relobj* relobj = psection->relobj();
  unsigned int shndx = psection->shndx();
d2140 4
d2146 9
a2154 5
  // This is not very efficient if we a going to relax a number of sections
  // in an Output_section with lot of Input_sections.
  for (Input_section_list::iterator p = this->input_sections_.begin();
       p != this->input_sections_.end();
       ++p)
d2156 15
a2170 1
      if (p->is_input_section())
d2172 3
a2174 6
	  if (p->relobj() == relobj && p->shndx() == shndx)
	    {
	      gold_assert(p->addralign() == psection->addralign());
	      *p = Input_section(psection);
	      return;
	    }
d2176 1
a2176 2
      else if (p->is_relaxed_input_section())
	gold_assert(p->relobj() != relobj || p->shndx() != shndx);
d2178 7
a2184 1
    }
d2205 54
d2269 14
d2307 15
a2321 2
  // This can only be called meaningfully when layout is complete.
  gold_assert(Output_data::is_layout_complete());
d2323 1
d2343 14
d2388 3
d2754 3
d2767 1
d2771 12
a2782 1
    p->write(of);
d2823 3
d2841 10
a2850 3
      off = align_address(off, p->addralign());
      p->write_to_buffer(buffer + off);
      off += p->data_size();
d2874 3
d2988 1
a2988 1
      this->input_sections_ = checkpoint->input_sections();
d2993 4
@


1.96
log
@2009-09-17  Doug Kwan  <dougkwan@@google.com>

	* debug.h (DEBUG_RELAXATION): New constant.
	(DEBUG_ALL): Add DEBUG_RELAXATION.
	(debug_string_to_enum): Add relaxation debug option.
	* layout.cc
	(Layout::Relaxation_debug_check::check_output_data_for_reset_values,
	Layout::Relaxation_debug_check::read_sections,
	Layout::Relaxation_debug_check::read_sections): New method definitions.
	(Layout::Layout): Initialize data members
	record_output_section_data_from_scrips_,
	script_output_section_data_list_ and relaxation_debug_check_.
	(Layout::save_segments, Layout::restore_segments,
	Layout::clean_up_after_relaxation, Layout::prepare_for_relaxation,
	Layout::relaxation_loop_body): New method definitions.
	(Layout::finalize): Support relaxation.  Move section layout code to
	Layout::relaxation_loop_body.
	(Layout::set_asection_address_from_script): Move code for orphan
	section placement out.
	(Layout::place_orphan_sections_in_script): New method definition.
	* layout.h (Output_segment_headers, Output_file_header):
	New forward class declarations.
	(Layout::~Layout): Define.
	(Layout::new_output_section_data_from_script): New method definition.
	(Layout::place_orphan_sections_in_script): New method declaration.
	(Layout::Segment_states): New type declaration.
	(Layout::save_segments, Layout::restore_segments,
	Layout::clean_up_after_relaxation, Layout::prepare_for_relaxation,
	Layout::relaxation_loop_body): New method declarations.
	(Layout::Output_section_data_list): New type declaration.
	(Layout::Relaxation_debug_check): New class definition.
	(Layout::record_output_section_data_from_script_,
	Layout::script_output_section_data_list_, Layout::segment_states_,
	Layout::relaxation_debug_check_): New data members.
	* output.cc: (Output_section_headers::do_size): New method definition.
	(Output_section_headers::Output_section_headers): Move size
	computation to Output_section_headers::do_size.
	(Output_segment_headers::do_size): New method definition.
	(Output_file_header::Output_file_header): Move size computation to
	Output_file_header::do_size and call it.
	(Output_file_header::do_size): New method definition.
	(Output_data_group::Output_data_group): Adjust call to
	Output_section_data.
	(Output_data_dynamic::set_final_data_size): Add DT_NULL tag only once.
	(Output_symtab_xindex::do_write): Add array bound check.
 	(Output_section::Input_section::print_to_mapfile): Handle
	RELAXED_INPUT_SECTION_CODE.
	(Output_section::Output_section): Initialize data member checkpoint_.
	(Output_section::~Output_section): Delete checkpoint object pointed
	by checkpoint_.
	(Output_section::add_input_section): Always add an Input_section if
	relaxing.
	(Output_section::add_merge_input_section): Add assert.
	(Output_section::relax_input_section): New method definition.
	(Output_section::set_final_data_size): Set load address to zero for
	an unallocated section.
	(Output_section::do_address_and_file_offset_have_reset_values):
	New method definition.
	(Output_section::Input_section_sort_enty::Input_section_sort_enty):
	Handle relaxed input section.
	(Output_section::sort_attached_input_sections): Checkpoint input
	section list lazily.
	(Output_section::get_input_sections): Change type of input_sections to
	list of Simple_input_section pointers.  Checkpoint input section list
	lazily.  Also handle relaxed input sections.
	(Output_section::add_input_section_for_script): Take a reference to
	a Simple_input_section object instead of Relobj pointer and section
	index as parameter.  Handle relaxed input sections.
	(Output_section::save_states, Output_section::restore_states): New
	method definitions.
	* output.h (Output_data::Output_data): Initialize is_data_size_fixed_.
	(Output_data::is_data_size_fixed): New method definition.
	(Output_data::reset_addresss_and_file_offset): Do not reset data size
	if it is fixed.
	(Output_data::address_and_file_offset_have_reset_values): New method
	definition.
	(Output_data::do_address_and_file_offset_have_reset_values): New method
	definition.
	(Output_data::set_data_size): Check that data size is not fixed.
	(Output_data::fix_data_size): New method definition.
	(Output_data::is_data_size_fixed_): New data member.
	(Output_section_headers::set_final_data_size): New method definition.
	(Output_section_headers::do_size): New method declaration.
	(Output_segment_headers::set_final_data_size): New method definition.
	(Output_segment_headers::do_size): New method declaration.
	(Output_file_header::set_final_data_size)::New method definition.
	(Output_file_header::do_size)::New method declaration.
	(Output_section_data::Output_section_data): Add new parameter
	is_data_size_fixed and use it to fix data size.
	(Output_data_const::Output_data_const): Adjust call to base class
	constructor and fix data size.
	(Output_data_const_buffer::Output_data_const_buffer): Adjust call to
	base class constructor and fix data size.
	(Output_data_fixed_space::Output_data_fixed_space): Adjust call to
	base class constructor and fix data size.
	(Output_data_zero_fill::Output_data_zero_fill): Adjust call to base
	class constructor and fix data size.
	(Output_data_group::set_final_data_size): New method definition.
	(Output_data_dynamic::Dynamic_entry::tag): New method definition.
	(Output_symtab_xindex::Output_symtab_xindex): Adjust call to base
	class constructor and fix data size.
	(Output_relaxed_input_section): New class definition.
	(Output_section::Simple_input_section): New class definition.
	(Output_section::get_input_sections): Adjust parameter list.
	(Output_section::add_input_section_for_script): Same.
	(Output_section::save_states, Output_section::restore_states,
	Output_section::do_address_and_file_offset_have_reset_values,
	(Output_section::Input_section::Input_section): Handle
	RELAXED_INPUT_SECTION_CODE.  Add new overload for
	Output_relaxed_input_section.
	(Output_section::Input_section::is_input_section,
	Output_section::Input_section::set_output_section): Handle relaxed
	input section.
	(Output_section::Input_section::is_relaxed_input_section,
	Output_section::Input_section::output_section_data,
	Output_section::Input_section::relaxed_input_section): New method
	definitions.
	(Output_section::Input_section::RELAXED_INPUT_SECTION_CODE): New enum
	value.
	(Output_section::Input_section::u1_): Update comments.
	(Output_section::Input_section::u2_): Add new union member poris.
	(Output_section::Checkpoint_output_section): New classs definition.
	(Output_section::relax_input_section): New method declaration.
	(Output_section::checkpoint_): New data member.
	(Output_segment): Update comments.
	(Output_segment::Output_segment): Un-privatize copy constructor.
	(Output_segment::operator=): Un-privatize.
	* script-sections.cc (Output_section_element::Input_section_list):
	Change element type to Output_section::Simple_input_section.
	(Output_section_element_dot_assignment::set_section_addresses):
	Register output section data for relaxation clean up.
	(Output_data_exression::Output_data_expression): Adjust call to base
	constructor to fix data size.
	(Output_section_element_data::set_section_addresses): Register
	Output_data_expression object for relaxation clean up.
	(struct Input_section_info): Replace Relobj pointer and section index
	pair with Output_section::Simple_input_section and Convert struct to a
	class.
	(Input_section_sorter::operator()): Adjust access to
	Input_section_info data member to use accessors.
	(Output_section_element_input::set_section_addresses): Use layout
	parameter.  Adjust code to use Output_section::Simple_input_section
	and Input_secction_info classes.  Register filler for relaxation
	clean up.
	(Orphan_output_section::set_section_addresses): Replace Relobj pointer
	and section index pair with Output_section::Simple_input_section
	class.  Adjust code accordingly.
	(Phdrs_element::release_segment): New method definition.
	(Script_sections::attach_sections_using_phdrs_clause): Do not modify
	segment list.
	(Script_sections::release_segments): New method definition.
	* gold/script-sections.h (Script_sections::release_segments): New
	method declaration.
	* gold/target.h (Target::may_relax, Target::relax,
	Target::do_may_relax, Target::do_relax): New method definitions.
@
text
@d1898 1
a1898 1
      && object->target()->has_code_fill())
d1910 1
a1910 1
          std::string fill_data(object->target()->code_fill(fill_len));
d1928 1
a1928 1
      || object->target()->may_relax())
d2044 1
a2044 1
  gold_assert(relobj->target()->may_relax());
@


1.95
log
@	* output.cc (Output_file::open): Add execute permission to empty file.
	* testsuite/Makefile.am (permission_test): New test.
	* testsuite/Makefile.in: Regenerate.
@
text
@d112 7
d123 3
a125 2
      for (Layout::Segment_list::const_iterator p = segment_list->begin();
	   p != segment_list->end();
d132 3
a134 2
      for (Layout::Section_list::const_iterator p = section_list->begin();
	   p != section_list->end();
d139 1
a139 1
  count += unattached_section_list->size();
d150 1
a150 1
  this->set_data_size(count * shdr_size);
a280 10
  const int size = parameters->target().get_size();
  int phdr_size;
  if (size == 32)
    phdr_size = elfcpp::Elf_sizes<32>::phdr_size;
  else if (size == 64)
    phdr_size = elfcpp::Elf_sizes<64>::phdr_size;
  else
    gold_unreachable();

  this->set_data_size(segment_list.size() * phdr_size);
d337 15
d365 1
a365 10
  const int size = parameters->target().get_size();
  int ehdr_size;
  if (size == 32)
    ehdr_size = elfcpp::Elf_sizes<32>::ehdr_size;
  else if (size == 64)
    ehdr_size = elfcpp::Elf_sizes<64>::ehdr_size;
  else
    gold_unreachable();

  this->set_data_size(ehdr_size);
d547 14
d1097 1
a1097 1
  : Output_section_data(entry_count * 4, 4),
d1523 5
a1527 2
  // Add the terminating entry.
  this->add_constant(elfcpp::DT_NULL, 0);
d1627 5
a1631 1
    elfcpp::Swap<32, big_endian>::writeval(oview + p->first * 4, p->second);
d1749 8
d1803 2
a1804 1
    tls_offset_(0)
d1815 1
d1922 1
a1922 2
  // the future, we keep track of the sections.  FIXME: Add test for
  // relaxing.
d1927 2
a1928 1
      || parameters->options().user_set_Map())
d1995 3
d2037 30
d2232 6
d2243 15
d2286 2
a2287 1
      section_has_name_(input_section.is_input_section())
d2295 3
a2297 1
	Object* obj = input_section.relobj();
d2446 4
d2624 1
a2624 1
    std::list<std::pair<Relobj*, unsigned int> >* input_sections)
d2626 4
d2640 5
a2644 1
	input_sections->push_back(std::make_pair(p->relobj(), p->shndx()));
d2682 1
a2682 2
Output_section::add_input_section_for_script(Relobj* object,
					     unsigned int shndx,
d2696 50
a2745 2
  this->input_sections_.push_back(Input_section(object, shndx,
						data_size, addralign));
@


1.94
log
@	* output.cc (Output_file::resize): Call map_no_anonymous rather
	than map.
@
text
@d33 1
a33 1
#include "libiberty.h"   // for unlink_if_ordinary()
d3464 16
a3479 2
	  if (::stat(this->name_, &s) == 0 && s.st_size != 0)
	    unlink_if_ordinary(this->name_);
@


1.94.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@d33 1
a33 1
#include "libiberty.h"
a111 7
}

// Compute the current data size.

off_t
Output_section_headers::do_size() const
{
d116 2
a117 3
      for (Layout::Segment_list::const_iterator p =
	     this->segment_list_->begin();
	   p != this->segment_list_->end();
d124 2
a125 3
      for (Layout::Section_list::const_iterator p =
	     this->section_list_->begin();
	   p != this->section_list_->end();
d130 1
a130 1
  count += this->unattached_section_list_->size();
d141 1
a141 1
  return count * shdr_size;
d272 10
a337 15
off_t
Output_segment_headers::do_size() const
{
  const int size = parameters->target().get_size();
  int phdr_size;
  if (size == 32)
    phdr_size = elfcpp::Elf_sizes<32>::phdr_size;
  else if (size == 64)
    phdr_size = elfcpp::Elf_sizes<64>::phdr_size;
  else
    gold_unreachable();

  return this->segment_list_.size() * phdr_size;
}

d351 10
a360 1
  this->set_data_size(this->do_size());
d440 1
a440 1
  else if (parameters->options().output_is_position_independent())
a541 14
// Compute the current data size.

off_t
Output_file_header::do_size() const
{
  const int size = parameters->target().get_size();
  if (size == 32)
    return elfcpp::Elf_sizes<32>::ehdr_size;
  else if (size == 64)
    return elfcpp::Elf_sizes<64>::ehdr_size;
  else
    gold_unreachable();
}

d1078 1
a1078 1
  : Output_section_data(entry_count * 4, 4, false),
d1504 2
a1505 5
  // Add the terminating entry if it hasn't been added.
  // Because of relaxation, we can run this multiple times.
  if (this->entries_.empty()
      || this->entries_.rbegin()->tag() != elfcpp::DT_NULL)
    this->add_constant(elfcpp::DT_NULL, 0);
d1605 1
a1605 5
    {
      unsigned int symndx = p->first;
      gold_assert(symndx * 4 < this->data_size());
      elfcpp::Swap<32, big_endian>::writeval(oview + symndx * 4, p->second);
    }
a1722 8
    case RELAXED_INPUT_SECTION_CODE:
      {
        Output_relaxed_input_section* relaxed_section =
	  this->relaxed_input_section();
        mapfile->print_input_section(relaxed_section->relobj(),
				     relaxed_section->shndx());
      }
      break;
d1769 1
a1769 7
    tls_offset_(0),
    checkpoint_(NULL),
    merge_section_map_(),
    merge_section_by_properties_map_(),
    relaxed_input_section_map_(),
    is_relaxed_input_section_map_valid_(true),
    generate_code_fills_at_write_(false)
a1779 1
  delete this->checkpoint_;
a1858 13
  // Determine if we want to delay code-fill generation until the output
  // section is written.  When the target is relaxing, we want to delay fill
  // generating to avoid adjusting them during relaxation.
  if (!this->generate_code_fills_at_write_
      && !have_sections_script
      && (sh_flags & elfcpp::SHF_EXECINSTR) != 0
      && parameters->target().has_code_fill()
      && parameters->target().may_relax())
    {
      gold_assert(this->fills_.empty());
      this->generate_code_fills_at_write_ = true;
    }

a1859 1
      && !this->generate_code_fills_at_write_
d1862 1
a1862 1
      && parameters->target().has_code_fill())
d1872 3
a1874 1
          std::string fill_data(parameters->target().code_fill(fill_len));
d1886 2
a1887 1
  // the future, we keep track of the sections.
d1892 1
a1892 2
      || parameters->options().user_set_Map()
      || parameters->target().may_relax())
a1917 25
// Add a relaxed input section.

void
Output_section::add_relaxed_input_section(Output_relaxed_input_section* poris)
{
  Input_section inp(poris);
  this->add_output_section_data(&inp);
  if (this->is_relaxed_input_section_map_valid_)
    {
      Input_section_specifier iss(poris->relobj(), poris->shndx());
      this->relaxed_input_section_map_[iss] = poris;
    }

  // For a relaxed section, we use the current data size.  Linker scripts
  // get all the input sections, including relaxed one from an output
  // section and add them back to them same output section to compute the
  // output section size.  If we do not account for sizes of relaxed input
  // sections,  an output section would be incorrectly sized.
  off_t offset_in_section = this->current_data_size_for_child();
  off_t aligned_offset_in_section = align_address(offset_in_section,
						  poris->addralign());
  this->set_current_data_size_for_child(aligned_offset_in_section
					+ poris->current_data_size());
}

d1959 9
a1967 20
  // We cannot restore merged input section states.
  gold_assert(this->checkpoint_ == NULL);

  // Look up merge sections by required properties.
  Merge_section_properties msp(is_string, entsize, addralign);
  Merge_section_by_properties_map::const_iterator p =
    this->merge_section_by_properties_map_.find(msp);
  if (p != this->merge_section_by_properties_map_.end())
    {
      Output_merge_base* merge_section = p->second;
      merge_section->add_input_section(object, shndx);
      gold_assert(merge_section->is_string() == is_string
		  && merge_section->entsize() == entsize
		  && merge_section->addralign() == addralign);

      // Link input section to found merge section.
      Input_section_specifier iss(object, shndx);
      this->merge_section_map_[iss] = merge_section;
      return true;
    }
d1971 1
a1971 1
  Output_merge_base* pomb;
d1973 1
a1973 1
    pomb = new Output_merge_data(entsize, addralign);
d1979 1
a1979 1
	  pomb = new Output_merge_string<char>(addralign);
d1982 1
a1982 1
	  pomb = new Output_merge_string<uint16_t>(addralign);
d1985 1
a1985 1
	  pomb = new Output_merge_string<uint32_t>(addralign);
d1992 2
a1993 10
  // Add new merge section to this output section and link merge section
  // properties to new merge section in map.
  this->add_output_merge_section(pomb, is_string, entsize);
  this->merge_section_by_properties_map_[msp] = pomb;

  // Add input section to new merge section and link input section to new
  // merge section in map.
  pomb->add_input_section(object, shndx);
  Input_section_specifier iss(object, shndx);
  this->merge_section_map_[iss] = pomb;
a1997 92
// Build a relaxation map to speed up relaxation of existing input sections.
// Look up to the first LIMIT elements in INPUT_SECTIONS.

void
Output_section::build_relaxation_map(
  const Input_section_list& input_sections,
  size_t limit,
  Relaxation_map* relaxation_map) const
{
  for (size_t i = 0; i < limit; ++i)
    {
      const Input_section& is(input_sections[i]);
      if (is.is_input_section() || is.is_relaxed_input_section())
	{
	  Input_section_specifier iss(is.relobj(), is.shndx());
	  (*relaxation_map)[iss] = i;
	}
    }
}

// Convert regular input sections in INPUT_SECTIONS into relaxed input
// sections in RELAXED_SECTIONS.  MAP is a prebuilt map from input section
// specifier to indices of INPUT_SECTIONS.

void
Output_section::convert_input_sections_in_list_to_relaxed_sections(
  const std::vector<Output_relaxed_input_section*>& relaxed_sections,
  const Relaxation_map& map,
  Input_section_list* input_sections)
{
  for (size_t i = 0; i < relaxed_sections.size(); ++i)
    {
      Output_relaxed_input_section* poris = relaxed_sections[i];
      Input_section_specifier iss(poris->relobj(), poris->shndx());
      Relaxation_map::const_iterator p = map.find(iss);
      gold_assert(p != map.end());
      gold_assert((*input_sections)[p->second].is_input_section());
      (*input_sections)[p->second] = Input_section(poris);
    }
}
  
// Convert regular input sections into relaxed input sections. RELAXED_SECTIONS
// is a vector of pointers to Output_relaxed_input_section or its derived
// classes.  The relaxed sections must correspond to existing input sections.

void
Output_section::convert_input_sections_to_relaxed_sections(
  const std::vector<Output_relaxed_input_section*>& relaxed_sections)
{
  gold_assert(parameters->target().may_relax());

  // We want to make sure that restore_states does not undo the effect of
  // this.  If there is no checkpoint active, just search the current
  // input section list and replace the sections there.  If there is
  // a checkpoint, also replace the sections there.
  
  // By default, we look at the whole list.
  size_t limit = this->input_sections_.size();

  if (this->checkpoint_ != NULL)
    {
      // Replace input sections with relaxed input section in the saved
      // copy of the input section list.
      if (this->checkpoint_->input_sections_saved())
	{
	  Relaxation_map map;
	  this->build_relaxation_map(
		    *(this->checkpoint_->input_sections()),
		    this->checkpoint_->input_sections()->size(),
		    &map);
	  this->convert_input_sections_in_list_to_relaxed_sections(
		    relaxed_sections,
		    map,
		    this->checkpoint_->input_sections());
	}
      else
	{
	  // We have not copied the input section list yet.  Instead, just
	  // look at the portion that would be saved.
	  limit = this->checkpoint_->input_sections_size();
	}
    }

  // Convert input sections in input_section_list.
  Relaxation_map map;
  this->build_relaxation_map(this->input_sections_, limit, &map);
  this->convert_input_sections_in_list_to_relaxed_sections(
	    relaxed_sections,
	    map,
	    &this->input_sections_);
}

a2015 54
// Find the merge section into which an input section with index SHNDX in
// OBJECT has been added.  Return NULL if none found.

Output_section_data*
Output_section::find_merge_section(const Relobj* object,
				   unsigned int shndx) const
{
  Input_section_specifier iss(object, shndx);
  Output_section_data_by_input_section_map::const_iterator p =
    this->merge_section_map_.find(iss);
  if (p != this->merge_section_map_.end())
    {
      Output_section_data* posd = p->second;
      gold_assert(posd->is_merge_section_for(object, shndx));
      return posd;
    }
  else
    return NULL;
}

// Find an relaxed input section corresponding to an input section
// in OBJECT with index SHNDX.

const Output_section_data*
Output_section::find_relaxed_input_section(const Relobj* object,
					   unsigned int shndx) const
{
  // Be careful that the map may not be valid due to input section export
  // to scripts or a check-point restore.
  if (!this->is_relaxed_input_section_map_valid_)
    {
      // Rebuild the map as needed.
      this->relaxed_input_section_map_.clear();
      for (Input_section_list::const_iterator p = this->input_sections_.begin();
	   p != this->input_sections_.end();
	   ++p)
	if (p->is_relaxed_input_section())
	  {
	    Input_section_specifier iss(p->relobj(), p->shndx());
	    this->relaxed_input_section_map_[iss] =
	      p->relaxed_input_section();
	  }
      this->is_relaxed_input_section_map_valid_ = true;
    }

  Input_section_specifier iss(object, shndx);
  Output_section_data_by_input_section_map::const_iterator p =
    this->relaxed_input_section_map_.find(iss);
  if (p != this->relaxed_input_section_map_.end())
    return p->second;
  else
    return NULL;
}

a2025 14
  // Look at the Output_section_data_maps first.
  const Output_section_data* posd = this->find_merge_section(object, shndx);
  if (posd == NULL)
    posd = this->find_relaxed_input_section(object, shndx);

  if (posd != NULL)
    {
      section_offset_type output_offset;
      bool found = posd->output_offset(object, shndx, offset, &output_offset);
      gold_assert(found);   
      return output_offset != -1;
    }

  // Fall back to the slow look-up.
d2050 2
a2051 15
  // This can only be called meaningfully when we know the data size
  // of this.
  gold_assert(this->is_data_size_valid());

  // Look at the Output_section_data_maps first.
  const Output_section_data* posd = this->find_merge_section(object, shndx);
  if (posd == NULL) 
    posd = this->find_relaxed_input_section(object, shndx);
  if (posd != NULL)
    {
      section_offset_type output_offset;
      bool found = posd->output_offset(object, shndx, offset, &output_offset);
      gold_assert(found);   
      return output_offset;
    }
a2052 1
  // Fall back to the slow look-up.
a2071 14

  // Look at the Output_section_data_maps first.
  const Output_section_data* posd = this->find_merge_section(object, shndx);
  if (posd == NULL) 
    posd = this->find_relaxed_input_section(object, shndx);
  if (posd != NULL && posd->is_address_valid())
    {
      section_offset_type output_offset;
      bool found = posd->output_offset(object, shndx, offset, &output_offset);
      gold_assert(found);
      return posd->address() + output_offset;
    }

  // Fall back to the slow look-up.
a2102 3
  // FIXME: This becomes a bottle-neck if we have many relaxed sections.
  // Looking up the merge section map does not always work as we sometimes
  // find a merge section without its address set.
a2162 6
  // An unallocated section has no address.  Forcing this means that
  // we don't need special treatment for symbols defined in debug
  // sections.  We do the same in the constructor.
  if ((this->flags_ & elfcpp::SHF_ALLOC) == 0)
     this->set_address(0);

a2167 15
  
// Return true if address and file offset have the values after reset.

bool
Output_section::do_address_and_file_offset_have_reset_values() const
{
  if (this->is_offset_valid())
    return false;

  // An unallocated section has address 0 after its construction or a reset.
  if ((this->flags_ & elfcpp::SHF_ALLOC) == 0)
    return this->is_address_valid() && this->address() == 0;
  else
    return !this->is_address_valid();
}
d2196 1
a2196 2
      section_has_name_(input_section.is_input_section()
			|| input_section.is_relaxed_input_section())
d2204 1
a2204 3
	Object* obj = (input_section.is_input_section()
		       ? input_section.relobj()
		       : input_section.relaxed_input_section()->relobj());
a2352 4
  if (this->checkpoint_ != NULL
      && !this->checkpoint_->input_sections_saved())
    this->checkpoint_->save_input_sections();

a2437 3
  // If the target performs relaxation, we delay filler generation until now.
  gold_assert(!this->generate_code_fills_at_write_ || this->fills_.empty());

a2447 1
  off_t off = this->offset() + this->first_input_offset_;
d2451 1
a2451 12
    {
      off_t aligned_off = align_address(off, p->addralign());
      if (this->generate_code_fills_at_write_ && (off != aligned_off))
	{
	  size_t fill_len = aligned_off - off;
	  std::string fill_data(parameters->target().code_fill(fill_len));
	  of->write(off, fill_data.data(), fill_data.size());
	}

      p->write(of);
      off = aligned_off + p->data_size();
    }
a2491 3
  // If the target performs relaxation, we delay filler generation until now.
  gold_assert(!this->generate_code_fills_at_write_ || this->fills_.empty());

d2507 3
a2509 10
      off_t aligned_off = align_address(off, p->addralign());
      if (this->generate_code_fills_at_write_ && (off != aligned_off))
	{
	  size_t fill_len = aligned_off - off;
	  std::string fill_data(parameters->target().code_fill(fill_len));
	  memcpy(buffer + off, fill_data.data(), fill_data.size());
	}

      p->write_to_buffer(buffer + aligned_off);
      off = aligned_off + p->data_size();
d2527 1
a2527 1
    std::list<Simple_input_section>* input_sections)
a2528 7
  if (this->checkpoint_ != NULL
      && !this->checkpoint_->input_sections_saved())
    this->checkpoint_->save_input_sections();

  // Invalidate the relaxed input section map.
  this->is_relaxed_input_section_map_valid_ = false;

d2539 1
a2539 5
	input_sections->push_back(Simple_input_section(p->relobj(),
						       p->shndx()));
      else if (p->is_relaxed_input_section())
	input_sections->push_back(
	    Simple_input_section(p->relaxed_input_section()));
d2577 2
a2578 1
Output_section::add_input_section_for_script(const Simple_input_section& sis,
d2592 2
a2593 54
  Input_section is =
    (sis.is_relaxed_input_section()
     ? Input_section(sis.relaxed_input_section())
     : Input_section(sis.relobj(), sis.shndx(), data_size, addralign));
  this->input_sections_.push_back(is);
}

//

void
Output_section::save_states()
{
  gold_assert(this->checkpoint_ == NULL);
  Checkpoint_output_section* checkpoint =
    new Checkpoint_output_section(this->addralign_, this->flags_,
				  this->input_sections_,
				  this->first_input_offset_,
				  this->attached_input_sections_are_sorted_);
  this->checkpoint_ = checkpoint;
  gold_assert(this->fills_.empty());
}

void
Output_section::restore_states()
{
  gold_assert(this->checkpoint_ != NULL);
  Checkpoint_output_section* checkpoint = this->checkpoint_;

  this->addralign_ = checkpoint->addralign();
  this->flags_ = checkpoint->flags();
  this->first_input_offset_ = checkpoint->first_input_offset();

  if (!checkpoint->input_sections_saved())
    {
      // If we have not copied the input sections, just resize it.
      size_t old_size = checkpoint->input_sections_size();
      gold_assert(this->input_sections_.size() >= old_size);
      this->input_sections_.resize(old_size);
    }
  else
    {
      // We need to copy the whole list.  This is not efficient for
      // extremely large output with hundreads of thousands of input
      // objects.  We may need to re-think how we should pass sections
      // to scripts.
      this->input_sections_ = *checkpoint->input_sections();
    }

  this->attached_input_sections_are_sorted_ =
    checkpoint->attached_input_sections_are_sorted();

  // Simply invalidate the relaxed input section map since we do not keep
  // track of it.
  this->is_relaxed_input_section_map_valid_ = false;
d2700 4
a2703 1
      if (!pdl->empty())
d2705 11
a2715 5
	  bool nobits = os->type() == elfcpp::SHT_NOBITS;
	  bool sawtls = false;
	  Output_segment::Output_data_list::iterator p = pdl->end();
	  gold_assert(p != pdl->begin());
	  do
d2717 10
a2726 24
	      --p;
	      bool insert;
	      if ((*p)->is_section_flag_set(elfcpp::SHF_TLS))
		{
		  sawtls = true;
		  // Put a NOBITS section after the first TLS section.
		  // Put a PROGBITS section after the first
		  // TLS/PROGBITS section.
		  insert = nobits || !(*p)->is_section_type(elfcpp::SHT_NOBITS);
		}
	      else
		{
		  // If we've gone past the TLS sections, but we've
		  // seen a TLS section, then we need to insert this
		  // section now.
		  insert = sawtls;
		}

	      if (insert)
		{
		  ++p;
		  pdl->insert(p, os);
		  return;
		}
a2727 1
	  while (p != pdl->begin());
d2729 1
d3089 2
a3090 20
	  if ((*p)->address() >= addr + (off - startoff))
	    off += (*p)->address() - (addr + (off - startoff));
	  else
	    {
	      if (!layout->script_options()->saw_sections_clause())
		gold_unreachable();
	      else
		{
		  Output_section* os = (*p)->output_section();
		  if (os == NULL)
		    gold_error(_("dot moves backward in linker script "
				 "from 0x%llx to 0x%llx"),
			       addr + (off - startoff), (*p)->address());
		  else
		    gold_error(_("address of section '%s' moves backward "
				 "from 0x%llx to 0x%llx"),
			       os->name(), addr + (off - startoff),
			       (*p)->address());
		}
	    }
d3464 2
a3465 16
	  if (::stat(this->name_, &s) == 0
	      && (S_ISREG (s.st_mode) || S_ISLNK (s.st_mode)))
	    {
	      if (s.st_size != 0)
		::unlink(this->name_);
	      else if (!parameters->options().relocatable())
		{
		  // If we don't unlink the existing file, add execute
		  // permission where read permissions already exist
		  // and where the umask permits.
		  int mask = ::umask(0);
		  ::umask(mask);
		  s.st_mode |= (s.st_mode & 0444) >> 2;
		  ::chmod(this->name_, s.st_mode & ~mask);
		}
	    }
@


1.94.2.2
log
@	* output.cc (Output_segment::set_section_list_address): Cast
	expressions to unsigned long long type to avoid format warnings.
@
text
@a3505 7

		  // Cast to unsigned long long to avoid format warnings.
		  unsigned long long previous_dot =
		    static_cast<unsigned long long>(addr + (off - startoff));
		  unsigned long long dot =
		    static_cast<unsigned long long>((*p)->address());

d3508 2
a3509 1
				 "from 0x%llx to 0x%llx"), previous_dot, dot);
d3513 2
a3514 1
			       os->name(), previous_dot, dot);
@


1.94.2.3
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@a1802 3
    is_interp_(false),
    is_dynamic_linker_section_(false),
    generate_code_fills_at_write_(false),
d1808 2
a1809 1
    is_relaxed_input_section_map_valid_(true)
d3048 1
a3048 2
				   elfcpp::Elf_Word seg_flags,
				   bool do_sort)
a3062 4
  // Note that while there may be many input sections in an output
  // section, there are normally only a few output sections in an
  // output segment.  The loops below are expected to be fast.

d3071 5
d3097 2
a3098 2
  // and the PT_TLS segment; we do this grouping only for the PT_LOAD
  // segment.
a3227 61
  // We do some further output section sorting in order to make the
  // generated program run more efficiently.  We should only do this
  // when not using a linker script, so it is controled by the DO_SORT
  // parameter.
  if (do_sort)
    {
      // FreeBSD requires the .interp section to be in the first page
      // of the executable.  That is a more efficient location anyhow
      // for any OS, since it means that the kernel will have the data
      // handy after it reads the program headers.
      if (os->is_interp() && !pdl->empty())
	{
	  pdl->insert(pdl->begin(), os);
	  return;
	}

      // Put loadable non-writable notes immediately after the .interp
      // sections, so that the PT_NOTE segment is on the first page of
      // the executable.
      if (os->type() == elfcpp::SHT_NOTE
	  && (os->flags() & elfcpp::SHF_WRITE) == 0
	  && !pdl->empty())
	{
	  Output_segment::Output_data_list::iterator p = pdl->begin();
	  if ((*p)->is_section() && (*p)->output_section()->is_interp())
	    ++p;
	  pdl->insert(p, os);
	}

      // If this section is used by the dynamic linker, and it is not
      // writable, then put it first, after the .interp section and
      // any loadable notes.  This makes it more likely that the
      // dynamic linker will have to read less data from the disk.
      if (os->is_dynamic_linker_section()
	  && !pdl->empty()
	  && (os->flags() & elfcpp::SHF_WRITE) == 0)
	{
	  bool is_reloc = (os->type() == elfcpp::SHT_REL
			   || os->type() == elfcpp::SHT_RELA);
	  Output_segment::Output_data_list::iterator p = pdl->begin();
	  while (p != pdl->end()
		 && (*p)->is_section()
		 && ((*p)->output_section()->is_dynamic_linker_section()
		     || (*p)->output_section()->type() == elfcpp::SHT_NOTE))
	    {
	      // Put reloc sections after the other ones.  Putting the
	      // dynamic reloc sections first confuses BFD, notably
	      // objcopy and strip.
	      if (!is_reloc
		  && ((*p)->output_section()->type() == elfcpp::SHT_REL
		      || (*p)->output_section()->type() == elfcpp::SHT_RELA))
		break;
	      ++p;
	    }
	  pdl->insert(p, os);
	  return;
	}
    }

  // If there were no constraints on the output section, just add it
  // to the end of the list.
@


1.94.2.4
log
@	PR 10910
	* output.cc (Output_segment::add_output_section): Add missing
	return statement.
@
text
@a3055 1
  gold_assert(this->type() == elfcpp::PT_LOAD || !do_sort);
d3071 7
a3077 1
  // that all SHT_NOTE sections are adjacent.
a3256 1
	  return;
@


1.93
log
@	* output.cc (Output_file::open_for_modification): New method.
	(Output_file::map_anonymous): Changed return type to bool.  Record
	map in base_ field.
	(Output_file::map_no_anonymous): New method, broken out of map.
	(Output_file::map): Use map_no_anonymous and map_anonymous.
	* output.h (class Output_file): Update declarations.
@
text
@d3500 2
a3501 1
      this->map();
@


1.92
log
@	PR 10156
	* layout.cc (Layout::choose_output_section): If we find an
	existing section, update the flags.
	(Layout::create_notes): New function, broken out of
	Layout::finalize.
	(Layout::finalize): Don't create note sections.
	(Layout::create_note): Don't crash if linker script discards
	section.
	(Layout::create_gold_note): Likewise.
	(Layout::create_build_id): Likewise.  Don't set
	after_input_sections on the section.
	(Layout::create_executable_stack_info): Remove target parameter.
	Change caller.
	* layout.h (class Layout): Declare create_notes.  Update
	declaration of create_executable_stack_info.
	* gold.cc (queue_middle_tasks): Call create_notes.
	* output.cc (Output_section::update_flags_for_input_section): Move
	here from output.h.  If SHF_ALLOC flag is newly set, mark address
	invalid.
	* output.h (Output_data::mark_address_invalid): New function.
	(class Output_section): Only declare, not define,
	update_flags_for_input_section.  Remove set_flags.
@
text
@d3400 36
d3504 2
a3505 2
// Map a block of memory which will later be written to the file.
// Return a pointer to the memory.
d3507 1
a3507 1
void*
d3510 9
a3518 3
  this->map_is_anonymous_ = true;
  return ::mmap(NULL, this->file_size_, PROT_READ | PROT_WRITE,
		MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
d3521 1
a3521 1
// Map the file into memory.
d3523 2
a3524 2
void
Output_file::map()
d3537 19
a3555 27
    base = this->map_anonymous();
  else
    {
      // Ensure that we have disk space available for the file.  If we
      // don't do this, it is possible that we will call munmap,
      // close, and exit with dirty buffers still in the cache with no
      // assigned disk blocks.  If the disk is out of space at that
      // point, the output file will wind up incomplete, but we will
      // have already exited.  The alternative to fallocate would be
      // to use fdatasync, but that would be a more significant
      // performance hit.
      if (::posix_fallocate(o, 0, this->file_size_) < 0)
	gold_fatal(_("%s: %s"), this->name_, strerror(errno));

      // Map the file into memory.
      this->map_is_anonymous_ = false;
      base = ::mmap(NULL, this->file_size_, PROT_READ | PROT_WRITE,
                    MAP_SHARED, o, 0);

      // The mmap call might fail because of file system issues: the
      // file system might not support mmap at all, or it might not
      // support mmap with PROT_WRITE.  I'm not sure which errno
      // values we will see in all cases, so if the mmap fails for any
      // reason try for an anonymous map.
      if (base == MAP_FAILED)
	base = this->map_anonymous();
    }
d3557 3
a3559 3
    gold_fatal(_("%s: mmap: failed to allocate %lu bytes for output file: %s"),
	       this->name_, static_cast<unsigned long>(this->file_size_),
	       strerror(errno));
d3561 22
@


1.91
log
@	* layout.cc (Layout::make_output_section): Call
	Target::new_output_section.
	(Layout::attach_allocated_section_to_segment): Put large section
	sections in a separate load segment with the large segment flag
	set.
	(Layout::segment_precedes): Sort large data segments after other
	load segments.
	(align_file_offset): New static function.
	(Layout::set_segment_offsets): Use align_file_offset.
	* output.h (class Output_section): Add is_small_section_ and
	is_large_section_ fields.
	(Output_section::is_small_section): New function.
	(Output_section::set_is_small_section):  New function.
	(Output_section::is_large_section): New function.
	(Output_section::set_is_large_section): New function.
	(Output_section::is_large_data_section): New function.
	(class Output_segment): Add is_large_data_segment_ field.
	(Output_segment::is_large_data_segment): New function.
	(Output_segment::set_is_large_data_segment): New function.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_segment::Output_segment): Likewise.
	(Output_segment::add_output_section): Add assertion that large
	data sections always go in large data segments.  Force small data
	sections to the end of the list of data sections.  Force small BSS
	sections to the start of the list of BSS sections.  For large BSS
	sections to the end of the list of BSS sections.
	* symtab.h (class Symbol): Declare is_common_shndx.
	(Symbol::is_defined): Check Symbol::is_common_shndx.
	(Symbol::is_common): Likewise.
	(class Symbol_table): Define enum Commons_section_type.  Update
	declarations.  Add small_commons_ and large_commons_ fields.
	* symtab.cc (Symbol::is_common_shndx): New function.
	(Symbol_table::Symbol_table): Initialize new fields.
	(Symbol_table::add_from_object): Put small and large common
	symbols in the right list.
	(Symbol_table::sized_finalized_symbol): Check
	Symbol::is_common_shndx.
	(Symbol_table::sized_write_globals): Likewise.
	* common.cc (Symbol_table::do_allocate_commons): Allocate new
	common symbol lists.  Don't call do_allocate_commons_list if the
	list is empty.
	(Symbol_table::do_allocate_commons_list): Remove is_tls
	parameter.  Add comons_section_type parameter.  Change all
	callers.  Handle small and large common symbols.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Check
	Symbol::is_common_shndx.
	* resolve.cc (symbol_to_bits): Likewise.
	* target.h (Target::small_common_shndx): New function.
	(Target::small_common_section_flags): New function.
	(Target::large_common_shndx): New function.
	(Target::large_common_section_flags): New function.
	(Target::new_output_section): New function.
	(Target::Target_info): Add small_common_shndx, large_common_shndx,
	small_common_section_flags, and large_common_section_flags
	fields.
	(Target::do_new_output_section): New virtual function.
	* arm.cc (Target_arm::arm_info): Initialize new fields.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Likewise.
	* sparc.c (Target_sparc::sparc_info) [all versions]: Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	(Target_x86_64::do_new_output_section): New function.
	* configure.ac: Define conditional MCMODEL_MEDIUM.
	* testsuite/Makefile.am (check_PROGRAMS): Add large.
	(large_SOURCES, large_CFLAGS, large_DEPENDENCIES): Define.
	(large_LDFLAGS): Define.
	* testsuite/large.c: New file.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Initialize new fields.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d1998 18
@


1.90
log
@2008-04-23  Elliott Hughes  <enh@@google.com>

        * output.cc (Output_file::close): After short writes, continue
        writing from the correct offset in the buffer being written.
@
text
@d1767 2
d2618 2
a2619 1
    are_addresses_set_(false)
d2631 1
d2739 63
@


1.89
log
@	* output.cc (Output_file::map_anonymous): Define.
	(Output_file::map): Use map_anonymous.  If the regular mmap fails,
	try an anonymous one.  Report the size if the mmap fails.
	* output.h (class Output_file): Declare map_anonymous.
@
text
@d3463 1
d3466 2
a3467 1
          ssize_t bytes_written = ::write(this->o_, this->base_, bytes_to_write);
d3473 4
a3476 1
            bytes_to_write -= bytes_written;
@


1.88
log
@2009-03-23  Ian Lance Taylor  <iant@@google.com>

	* freebsd.h: New file.
	* i386.cc: Include "freebsd.h".
	(Target_i386): Derive from Target_freebsd rather than
	Sized_target.
	(Target_selector_i386): Derive from Target_selector_freebsd rather
	than Target_selector.
	* x86_64.cc: Include "freebsd.h".
	(Target_x86_64): Derive from Target_freebsd rather than
	Sized_target.
	(Target_selector_x86_64): Derive from Target_selector_freebsd
	rather than Target_selector.
	* target.h (class Target): Add adjust_elf_header and
	do_adjust_elf_header.
	* output.cc (Output_file_header:: do_sized_write): Call target
	adjust_elf_header routine.
	* configure.tgt: Set targ_osabi.
	* configure.ac: Define GOLD_DEFAULT_OSABI.
	* parameters.cc (Parameters::default_target): Pass
	GOLD_DEFAULT_OSABI to select_target.
	* target-select.h (class Target_selector): Make instantiate_target
	protected rather than private.
	* Makefile.am (HFILES): Add freebsd.h.
	* configure, Makefile.in, config.in: Rebuild.
@
text
@d3383 11
d3410 1
a3410 5
    {
      this->map_is_anonymous_ = true;
      base = ::mmap(NULL, this->file_size_, PROT_READ | PROT_WRITE,
                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    }
d3428 8
d3438 3
a3440 1
    gold_fatal(_("%s: mmap: %s"), this->name_, strerror(errno));
@


1.87
log
@	* configure.ac: Check for chsize and posix_fallocate.  Replace
	ftruncate.
	* ftruncate.c: New file, from gnulib.
	* output.cc (posix_fallocate): Define dummy version if not
	HAVE_POSIX_FALLOCATE.
	(Output_file::map): Call posix_fallocate rather than lseek and
	write.
	* gold.h (ftruncate): Declare if not HAVE_FTRUNCATE.
	* configure, Makefile.in, config.in: Rebuild.
@
text
@a434 1
  // FIXME: Some targets may need to set EI_OSABI and EI_ABIVERSION.
d491 4
@


1.86
log
@	PR 7091
	* output.cc (Output_section::find_starting_output_address): Rename
	from starting_output_address; add PADDR parameter; change return
	type.
	* output.h (class Output_section): Declare
	find_starting_output_address instead of starting_output_address.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Handle a
	section symbol for which we can't find a merge section.
@
text
@d48 12
d3403 10
a3412 6
      // Write out one byte to make the file the right size.
      if (::lseek(o, this->file_size_ - 1, SEEK_SET) < 0)
        gold_fatal(_("%s: lseek: %s"), this->name_, strerror(errno));
      char b = 0;
      if (::write(o, &b, 1) != 1)
        gold_fatal(_("%s: write: %s"), this->name_, strerror(errno));
@


1.85
log
@	* output.cc  (Output_reloc): Add explicit instantiations.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d2060 1
a2060 1
// Return the output address of the start of the merged section for
d2063 4
a2066 3
uint64_t
Output_section::starting_output_address(const Relobj* object,
					unsigned int shndx) const
d2080 4
a2083 1
	return addr;
d2087 3
a2089 1
  gold_unreachable();
@


1.84
log
@	* mapfile.cc (Mapfile::print_input_section): Change -1U to -1ULL.
	* object.cc (Sized_relobj::do_layout): Use constant invalid_address
	instead of -1U.
	(Sized_relobj::do_finalize_local_symbols): Likewise.
	(Sized_relobj::map_to_kept_section): Likewise.
	* object.h (Sized_relobj::invalid_address): New constant.
	(Sized_relobj::do_output_section_offset): Check for invalid_address
	and return -1ULL.
	* output.cc (Output_reloc::local_section_offset): Use constant
	invalid_address instead of -1U.
	(Output_reloc::get_address): Likewise.
	(Output_section::output_address): Change -1U to -1ULL.
	* output.h (Output_reloc::invalid_address): New constant.
	* reloc.cc (Sized_relobj::write_sections): Use constant
	invalid_address instead of -1U.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (Symbol_table::sized_finalize_symbol): Handle symbol
	values for merge sections.
	* target-reloc.h (relocate_for_relocatable): Use constant
	invalid_address instead of -1U.
@
text
@d3496 80
@


1.83
log
@	* layout.cc (Layout::attach_allocated_section_to_segment): Don't
	set tls_segment_ or relro_segment_.
	(Layout::make_output_segment): Set tls_segment_ and relro_segment_
	when appropriate.
	* output.h (Output_section::clear_is_relro): New function.
	* output.cc (Output_segment::add_output_section): Handle SHF_TLS
	sections specially even when output_data_ is empty.
	(Output_segment::maximum_alignment): When first section is relro,
	only force alignment for PT_LOAD segments.
	* script.cc (script_data_segment_align): New function.
	(script_data_segment_relro_end): New function.
	* script-c.h (script_data_segment_align): Declare.
	(script_data_segment_relro_end): Declare.
	* script-sections.h (class Script_sections): Declare
	data_segment_align and data_segment_relro_end.  Add fields
	segment_align_index_ and saw_relro_end_.
	* script-sections.cc (class Sections_element): Add set_is_relro
	virtual function.  Add new bool* parameter to place_orphan_here.
	Add get_output_section virtual function.
	(class Output_section_definition): Add set_is_relro.  Add new
	bool* parameter to place_orphan_here.  Add get_output_section.
	Add is_relro_ field.
	(Output_section_definition::Output_section_definition): Initialize
	evaluated_address_, evaluated_load_address, evaluated_addralign_,
	and is_relro_ fields.
	(Output_section_definition::place_orphan_here): Add is_relro
	parameter.
	(Output_section_definition::set_section_addresses): Set relro for
	output section.
	(Output_section_definition::alternate_constraint): Likewise.
	(class Orphan_output_section): Add new bool* parameter to
	place_orphan_here.  Add get_output_section.
	(Orphan_output_section::place_orphan_here): Add is_relro
	parameter.
	(Script_sections::Script_sections): Initialize
	data_segment_align_index_ and saw_relro_end_.
	(Script_sections::data_segment_align): New function.
	(Script_sections::data_segment_relro_end): New function.
	(Script_sections::place_orphan): Set or clear is_relro.
	(Script_sections::set_section_addresses): Force alignment of first
	TLS section.
	* yyscript.y (exp): Call script_data_segment_align and
	script_data_segment_relro_end.
	* testsuite/relro_script_test.t: New file.
	* testsuite/relro_test.cc (using_script): Declare.
	(t1, t2): Test using_script.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_script_test.
	(relro_script_test_SOURCES): Define.
	(relro_script_test_DEPENDENCIES): Define.
	(relro_script_test_LDFLAGS): Define.
	(relro_script_test_LDADD): Define.
	(relro_script_test.so): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d841 1
a841 1
  if (offset != -1U)
d845 1
a845 1
  gold_assert(offset != -1U);
d861 1
a861 1
      if (off != -1U)
d867 1
a867 1
	  gold_assert(address != -1U);
d2046 1
a2046 1
	    return -1U;
@


1.82
log
@	PR 5990
	* descriptors.cc: New file.
	* descriptors.h: New file.
	* gold-threads.h (class Hold_optional_lock): New class.
	* fileread.cc: Include "descriptors.h".
	(File_read::~File_read): Release descriptor rather than closing
	it.
	(File_read::open) [file]: Call open_descriptor rather than open.
	Set is_descriptor_opened_.
	(File_read::open) [memory]: Assert that descriptor is not open.
	(File_read::reopen_descriptor): New function.
	(File_read::release): Release descriptor.
	(File_read::do_read): Make non-const.  Reopen descriptor.
	(File_read::read): Make non-const.
	(File_read::make_view): Reopen descriptor.
	(File_read::do_readv): Likewise.
	* fileread.h (class File_read): Add is_descriptor_opened_ field.
	Update declarations.
	* layout.cc: Include "descriptors.h".
	(Layout::create_build_id): Use open_descriptor rather than open.
	* output.cc: Include "descriptors.h".
	(Output_file::open): Use open_descriptor rather than open.
	* archive.cc (Archive::const_iterator): Change Archive to be
	non-const.
	(Archive::begin, Archive::end): Make non-const.
	(Archive::count_members): Likewise.
	* archive.h (class Archive): Update declarations.
	* object.h (Object::read): Make non-const.
	* Makefile.am (CCFILES): Add descriptors.cc.
	(HFILES): Add descriptors.h.
	* Makefile.in: Rebuild.
@
text
@d2654 1
a2654 2
      && (os->flags() & elfcpp::SHF_TLS) != 0
      && !this->output_data_.empty())
d2779 3
a2781 1
      if (parameters->options().relro() && this->is_first_section_relro())
@


1.81
log
@	* output.cc (Output_section::add_input_section): Don't try to
	merge empty merge sections.
@
text
@d40 1
d3325 2
a3326 1
	  int o = ::open(this->name_, O_RDWR | O_CREAT | O_TRUNC, mode);
@


1.80
log
@	Handle output sections with more than 0x7fffffff bytes.
	* object.h (class Relobj): Change map_to_output_ to
	output_sections_, and just keep a section pointer.  Change all
	uses.  Move comdat group support to Sized_relobj.
	(Relobj::is_section_specially_mapped): Remove.
	(Relobj::output_section): Remove poff parameter.  Change all
	callers.
	(Relobj::output_section_offset): New function.
	(Relobj::set_section_offset): Rewrite.
	(Relobj::map_to_output): Remove.
	(Relobj::output_sections): New function.
	(Relobj::do_output_section_offset): New pure virtual function.
	(Relobj::do_set_section_offset): Likewise.
	(class Sized_relobj): Add section_offsets_ field.  Add comdat
	group support from Relobj.  Update declarations.
	(Sized_relobj::get_output_section_offset): New function.
	(Sized_relobj::do_output_section_offset): New function.
	(Sized_relobj::do_set_section_offset): New function.
	* object.cc (Relobj::output_section_address): Remove.
	(Sized_relobj::Sized_relobj): Initialize new fields.
	(Sized_relobj::include_section_group): Cast find_kept_object to
	Sized_relobj.
	(Sized_relobj::include_linkonce_section): Likewise.
	(Sized_relobj::do_layout): Use separate arrays for output section
	and output offset.
	(Sized_relobj::do_count_local_symbols): Change map_to_output to
	output_sections.
	(Sized_relobj::do_finalize_local_symbols): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_local_symbols): Likewise.
	(map_to_kept_section): Compute output address directly.
	* reloc.cc (Sized_relobj::do_read_relocs): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_sections): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (sized_finalize_symbol): Use output_section_offset.
	* output.h (class Output_reloc): Update declarations.  Change
	u2_.relobj to Sized_relobj*.
	(class Output_data_reloc): Change add functions to use
	Sized_relobj*.
	* output.cc (Output_reloc::Output_reloc): Change relobj to
	Sized_relobj*.
	(Output_reloc::local_section_offset): Change return type to
	Elf_Addr.  Use get_output_section_offset.
	(Output_reloc::get_address): Likewise.
	(Output_section::is_input_address_mapped): Don't call
	is_section_specially_mapped.
	(Output_section::output_offset): Likewise.
	(Output_section::output_address): Likewise.
	(Output_section::starting_output_address): Likewise.
	* copy-relocs.cc (Copy_relocs::copy_reloc): Change object
	parameter to Sized_relobj*.
	(Copy_relocs::need_copy_reloc): Likewise.
	(Copy_relocs::save): Likewise.
	* copy-relocs.h (class Copy_relocs): Update declarations.
	(class Copy_relocs::Copy_reloc_entry): Change constructor to use
	Sized_relobj*.  Change relobj_ field to Sized_relobj*.
	* target-reloc.h (relocate_for_relocatable): Change
	offset_in_output_section type to Elf_Addr.  Change code that uses
	it as well.
	* layout.cc (Layout::layout): Always set *off.
	* mapfile.cc (Mapfile::print_input_section): Use
	output_section_offset.
	* i386.cc (Target_i386::copy_reloc): Change object parameter to
	Sized_relobj*.
	* powerpc.cc (Target_powerpc::copy_reloc): Likewise.
	* sparc.cc (Target_sparc::copy_reloc): Likewise.
	* x86_64.cc (Target_x86_64::copy_reloc): Likewise.
@
text
@d1822 2
a1823 1
  // a section.
d1825 2
a1826 1
      && reloc_shndx == 0)
@


1.79
log
@	* mapfile.cc: New file.
	* mapfile.h: New file.
	* options.h (class General_options): Add -M/--print-map and -Map.
	* options.cc (General_options::finalize): Make -M equivalent to
	-Map -.
	* main.cc: Include <cstdio> and "mapfile.h".
	(main): Open mapfile if requested.
	* gold.cc (class Middle_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(queue_initial_tasks): Add mapfile parameter.  Change caller.
	(queue_middle_tasks): Likewise.
	* gold.h (queue_initial_tasks, queue_middle_tasks): Update
	declarations.
	* archive.cc: Include "mapfile.h".
	(Archive::add_symbols): Add mapfile parameter.  Change all
	callers.  Pass mapfile, symbol, and reason to include_member.
	(Archive::include_all_members): Add mapfile parameter.  Change all
	callers.
	(Archive::include_member): Add mapfile, sym, and why parameters.
	Change all callers.  Report inclusion to map file.
	* archive.h: Include "fileread.h".
	(class Archive): Update declarations.
	(Archive::file): New const method.
	(class Add_archive_symbols): Add mapfile_ field.  Update
	constructor.  Change all callers.
	* readsyms.h (class Read_symbols): Likewise.
	(class Finish_group): Likewise.
	(class Read_script): Likewise.
	* common.cc: Include "mapfile.h".
	(Symbol_table::allocate_commons): Add mapfile parameter.  Change
	all callers.
	(Symbol_table::do_allocate_commons): Likewise.
	(Symbol_table::do_allocate_commons_list): Likewise.  Report common
	symbol allocation to mapfile.
	* common.h (class Allocate_commons_task): Add mapfile_ field.
	Update constructor.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* layout.cc: Include "mapfile.h".
	(Layout_task_runner::run): Print information to mapfile.
	(Layout::create_gold_note): Change Output_data_fixed_space to
	Output_data_zero_fill.
	(Layout::create_build_id): Likewise.
	(Layout::print_to_mapfile): New function.
	* layout.h (class Layout_task_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(class Layout): Declare print_to_mapfile.
	* output.cc (Output_section::Input_section::print_to_mapfile): New
	function.
	(Output_section::add_input_section): If producing a map, always
	add to input_sections_ list.
	(Output_section::do_print_to_mapfile): New function.
	(Output_segment::print_sections_to_mapfile): New function.
	(Output_segment::print_section_list_to_mapfile): New function.
	* output.h: Include "mapfile.h".
	(Output_data::print_to_mapfile): New function.
	(Output_data::do_print_to_mapfile): New virtual function.
	(Output_segment_headers::do_print_to_mapfile): New function.
	(Output_file_header::do_print_to_mapfile): New function.
	(Output_data_const::do_print_to_mapfile): New function.
	(class Output_data_const_buffer): Add map_name_ field.  Update
	constructor.  Change all callers.  Add do_print_to_mapfile
	function.
	(class Output_data_fixed_space): Likewise.
	(class Output_data_space): Likewise.
	(class Output_data_zero_fill): New class.
	(Output_data_strtab::do_print_to_mapfile): New function.
	(Output_data_reloc_base::do_print_to_mapfile): New function.
	(Output_relocatable_relocs::do_print_to_mapfile): New function.
	(Output_data_group::do_print_to_mapfile): New function.
	(Output_data_got::do_print_to_mapfile): New function.
	(Output_data_dynamic::do_print_to_mapfile): New function.
	(Output_symtab_xindex::do_print_to_mapfile): New function.
	(class Output_section): Declare do_print_to_mapflie.  Declare
	print_to_mapfile in Input_section.
	(class Output_segment): Declare new functions.
	* object.h (Sized_relobj::symbol_count): New function.
	* script-sections.cc
	(Output_section_element_dot_assignment::set_section_addresses):
	Change Output_data_fixed_space to Output_data_zero_fill.
	(Output_data_expression::do_print_to_mapfile): New function.
	* script.cc (read_input_script): Add mapfile parameter.  Change
	all callers.
	* script.h (read_input_script): Update declaration.
	* ehframe.h (Eh_frame_hdr::do_print_to_mapfile): New function.
	(Eh_frame::do_print_to_mapfile): New function.
	* merge.h (Output_merge_data::do_print_to_mapfile): New function.
	(Output_merge_string::do_print_to_mapfile): New function.
	* i386.cc (Output_data_plt_i386::do_print_to_mapfile): New
	function.
	* sparc.cc (Output_data_plt_sparc::do_print_to_mapfile): New
	function.
	* x86_64.cc (Output_data_plt_x86_64::do_print_to_mapfile): New
	function.
	* Makefile.am (CCFILES): Add mapfile.cc.
	(HFILES): Add mapfile.h.
	* Makefile.in: Rebuild.
@
text
@d620 1
a620 1
    Relobj* relobj,
d710 1
a710 1
    Relobj* relobj,
d758 1
a758 6
          {
            section_offset_type dummy;
            Output_section* os = this->u1_.relobj->output_section(lsi, &dummy);
            gold_assert(os != NULL);
            os->set_needs_dynsym_index();
          }
d810 1
a810 2
            section_offset_type dummy;
            Output_section* os = this->u1_.relobj->output_section(lsi, &dummy);
d828 1
a828 1
section_offset_type
d837 1
a837 2
  section_offset_type offset;
  Output_section* os = this->u1_.relobj->output_section(lsi, &offset);
d839 2
a840 1
  if (offset != -1)
d844 1
a844 1
  gold_assert(offset != -1);
d857 1
a857 3
      section_offset_type off;
      Output_section* os = this->u2_.relobj->output_section(this->shndx_,
							    &off);
d859 2
a860 1
      if (off != -1)
d1090 1
a1090 2
      section_offset_type dummy;
      Output_section* os = this->relobj_->output_section(*p, &dummy);
d1353 1
a1353 2
  section_offset_type off;
  Output_section* os = object->output_section(shndx, &off);
d1383 1
a1383 2
  section_offset_type off;
  Output_section* os = object->output_section(shndx, &off);
a1987 2
  gold_assert(object->is_section_specially_mapped(shndx));

a2011 1
  gold_assert(object->is_section_specially_mapped(shndx));
a2032 2
  gold_assert(object->is_section_specially_mapped(shndx));

a2063 2
  gold_assert(object->is_section_specially_mapped(shndx));

@


1.78
log
@	* options.h (class General_options): Add -z relro.
	* layout.cc (Layout::Layout): Initialize relro_segment_.
	(Layout::add_output_section_data): Return the output section.
	(Layout::make_output_section): Rcognize relro sections and mark
	them appropriately.
	(Layout::attach_allocated_section_to_segment): Put relro sections
	in a PT_GNU_RELRO segment.
	(Layout::create_initial_dynamic_sections): Mark the .dynamic
	section as relro.
	(Layout::segment_precedes): Sort PT_GNU_RELRO segments after
	PT_TLS segments.
	(Layout::linkonce_mapping): Map d.rel.ro.local to
	.data.rel.ro.local.
	(Layout::output_section_name): Us .data.rel.ro.local for any
	section which begins with that.
	* layout.h (class Layout): Update add_output_section_data
	declaration.  Add relro_segment_ field.
	* output.cc (Output_section::Output_section): Initialize is_relro_
	and is_relro_local_ fields.
	(Output_segment::add_output_section): Group relro sections.
	(Output_segment::is_first_section_relro): New function.
	(Output_segment::maximum_alignment): If there is a relro section,
	align the segment to the common page size.
	(Output_segment::set_section_addresses): Track whether we are
	looking at relro sections.  If the last section is a relro
	section, align to the common page size.
	(Output_segment::set_section_list_addresses): Add in_relro
	parameter.  Change all callers.  Align to the page size when
	moving from relro to non-relro section.
	(Output_segment::set_offset): Align memsz of a PT_GNU_RELRO
	segment.
	* output.h (class Output_section): Add is_relro_ and
	is_relro_local_ fields.
	(Output_section::is_relro): New function.
	(Output_section::set_is_relro): New function.
	(Output_section::is_relro_local): New function.
	(Output_section::set_is_relro_local): New function.
	(class Output_segment): Update declarations.
	* i386.cc (Target_i386::got_section): Mark .got section as relro.
	* sparc.cc (Target_sparc::got_section): Likewise.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/relro_test_main.cc: New file.
	* testsuite/relro_test.cc: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_test.
	(relro_test_SOURCES, relro_test_DEPENDENCIES): New variables.
	(relro_test_LDFLAGS, relro_test_LDADD): New variables.
	(relro_test.so, relro_test_pic.o): New targets.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1704 19
d1881 2
a1882 1
      || this->must_sort_attached_input_sections())
d2569 13
d3272 23
@


1.77
log
@	* output.cc (Output_segment::add_output_section): Remove front
	parameter.
	* output.h (class Output_segment): Remove
	add_initial_output_section and overloaded add_output_section.
	Update declaration of remaining add_output_section.
	* layout.cc (Layout::create_interp): Call add_output_section
	rather than add_initial_output_section.
	(Layout::finish_dynamic_section): Likewise.
@
text
@d1740 2
d2650 1
a2650 1
	      // But a PROGBITS section after the first TLS/PROGBITS
d2674 22
d2730 10
d2757 11
d2840 3
d2847 2
a2848 1
					  addr, poff, pshndx, &in_tls);
d2856 1
a2856 1
                                                  &in_tls);
d2867 8
d2892 1
a2892 1
                                           bool* in_tls)
d2943 13
d3049 10
@


1.76
log
@	* output.cc (Output_reloc::get_address): Change return type to
	Elf_Addr.
	* output.h (class Output_reloc): Update get_address declaration.
	* x86_64.cc (Output_data_plt_x86_64::do_write): Use 64-bit types
	for section addresses.
@
text
@d2582 1
a2582 2
				   elfcpp::Elf_Word seg_flags,
				   bool front)
a2616 1
	      // We don't worry about the FRONT parameter.
a2660 1
	      // We don't worry about the FRONT parameter.
d2672 1
a2672 4
  if (front)
    pdl->push_front(os);
  else
    pdl->push_back(os);
@


1.75
log
@2008-05-05  Ian Lance Taylor  <iant@@google.com>

	* options.h (DEFINE_bool): For DASH_Z, create the negative option
	as noVARNAME rather than no-VARNAME.
	(class General_options): Add option -z combreloc.
	* output.h (class Output_reloc) [SHT_REL]: Declare compare and
	get_address.
	(Output_reloc::sort_before) [SHT_REL]: New function.
	(Output_reloc::sort_before) [SHT_RELA]: New function.
	(class Output_data_reloc_base): Add sort_relocs_ field.  Define
	Sort_relocs_comparison.
	(Output_data_reloc_base::Output_data_reloc_base): Add sort_relocs
	parameter.  Change all callers.
	(Output_data_reloc::Output_data_reloc) [both versions]: Add
	sort_relocs parameter.  Change all callers.
	* output.cc (Output_reloc::get_address): New function, broken out
	of write_rel.
	(Output_reloc::write_rel): Call it.
	(Output_reloc::compare): New function.
	(Output_data_reloc_base::do_write): Optionally sort relocs.
@
text
@d857 1
a857 1
section_offset_type
@


1.74
log
@	* object.cc (Sized_relobj::include_section_group): Adjust section
	indexes read from group data.  Build vector to pass to
	layout_group.
	* layout.cc (Layout::layout_group): Add flags and shndxes
	parameters.  Remove contents parameter.  Change caller.  Update
	explicit instantiations.
	* layout.h (class Layout): Update layout_group declaration.
	* output.cc (Output_data_group::Output_data_group): Add flags and
	input_shndxes parameters.  Remove contents parameter.  Change
	caller.
	(Output_data_group::do_write): Change input_sections_ to
	input_shndxes_.
	* output.h (class Output_data_group): Update constructor
	declaration.  Rename input_sections_ to input_shndxes_.
	* testsuite/many_sections_test.cc: Add template.
@
text
@d854 1
a854 2
// Write out the offset and info fields of a Rel or Rela relocation
// entry.
d857 2
a858 4
template<typename Write_rel>
void
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::write_rel(
    Write_rel* wr) const
d878 13
a890 1
  wr->put_r_offset(address);
d927 51
d1027 7
@


1.73
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1000 2
a1001 1
    const elfcpp::Elf_Word* contents)
d1003 2
a1004 1
    relobj_(relobj)
d1006 1
a1006 6
  this->flags_ = elfcpp::Swap<32, big_endian>::readval(contents);
  for (section_size_type i = 1; i < entry_count; ++i)
    {
      unsigned int shndx = elfcpp::Swap<32, big_endian>::readval(contents + i);
      this->input_sections_.push_back(shndx);
    }
d1026 2
a1027 2
	 this->input_sections_.begin();
       p != this->input_sections_.end();
d1052 1
a1052 1
  this->input_sections_.clear();
@


1.72
log
@	* layout.cc (Layout::Layout): Initialize sections_are_attached_.
	(Layout::get_output_section): Ignore SHF_WRITE and SHF_EXECINSTR
	in the name/type/flags to section mapping.  Don't call
	allocate_output_section.
	(Layout::choose_output_section): Change parameter from adjust_name
	to is_input_section.  Don't permit input sections after sections
	are attached to segments.  Don't call allocate_output_section.
	(Layout::layout_eh_frame): Call update_flags_for_input_section,
	not write_enable_output_section.
	(Layout::make_output_section): Don't push to
	unattached_section_list_ nor call attach_to_segment.  Call
	attach_section_to_segment if sections are attached.
	(Layout::attach_sections_to_segments): New function.
	(Layout::attach_section_to_segment): New function.
	(Layout::attach_allocated_section_to_segment): Rename from
	attach_to_segment.  Remove flags parameter.
	(Layout::allocate_output_section): Remove function.
	(Layout::write_enable_output_section): Remove function.
	* layout.h (class Layout): Update for above changes.  Add new
	field sections_are_attached_.
	* output.h (Output_section::update_flags_for_input_section): New
	function.
	* output.cc (Output_section::add_input_section): Call
	update_flags_for_input_section.
	* gold.cc (queue_middle_tasks): Call attach_sections_to_segments.
@
text
@d90 2
a91 1
    const Stringpool* secnamepool)
d96 2
a97 1
    secnamepool_(secnamepool)
d180 14
a193 2
    oshdr.put_sh_size(0);
    oshdr.put_sh_link(0);
d464 14
a477 3
  oehdr.put_e_shnum(this->section_header_->data_size()
		     / elfcpp::Elf_sizes<size>::shdr_size);
  oehdr.put_e_shstrndx(this->shstrtab_->out_shndx());
d1506 32
@


1.71
log
@	* output.h (class Output_section_data): Remove inline definition
	of set_addralign.
	* output.cc (Output_section_data::set_addralign): New function.
@
text
@d1676 1
a1676 4
  this->flags_ |= (sh_flags
		   & (elfcpp::SHF_WRITE
		      | elfcpp::SHF_ALLOC
		      | elfcpp::SHF_EXECINSTR));
@


1.70
log
@2008-04-11  Cary Coutant  <ccoutant@@google.com>

	Add support for TLS descriptors for i386 and x86_64.
	* i386.cc (Target_i386::Relocate::tls_desc_gd_to_ie): New function.
	(Target_i386::Relocate::tls_desc_gd_to_le): New function.
	(Target_i386::Got_type): Add GOT_TYPE_TLS_NOFFSET and
	GOT_TYPE_TLS_DESC.
	(Target_i386::got_mod_index_entry): Remove unnecessary code.
	(Target_i386::Scan::local): Implement R_386_TLS_GOTDESC and
	R_386_TLS_DESC_CALL relocations.  Fix problem with initial-exec
	relocations.
	(Target_i386::Scan::global): Fix problem with GD-to-IE relaxation.
	Implement R_386_TLS_GOTDESC and R_386_TLS_DESC_CALL relocations;
	Fix problem with initial-exec relocations.
	(Target_i386::Relocate::relocate_tls): Likewise.
	(Target_i386::Relocate::tls_gd_to_ie): Fix problem with GD-to-IE
	relaxation.
	* output.cc (Output_data_dynamic::Dynamic_entry::write): Add
	support for section-plus-offset dynamic table entries.
	* output.h (Output_data_dynamic::add_section_plus_offset): New function.
	(Output_data_dynamic::Dynamic_entry): Add support for
	section-plus-offset dynamic table entries.
	(Output_data_dynamic::Classification): Likewise.
	(Output_data_dynamic::classification_): Renamed offset_.
	* x86_64.cc (Target_x86_64::Relocate::tls_desc_gd_to_ie): New function.
	(Target_x86_64::Relocate::tls_desc_gd_to_le): New function.
	(Target_x86_64::make_plt_section): New function.
	(Target_x86_64::reserve_tlsdesc_entries): New function.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Add new parameter.
	(Output_data_plt_x86_64::reserve_tlsdesc_entry): New function.
	(Output_data_plt_x86_64::has_tlsdesc_entry): New function.
	(Output_data_plt_x86_64::get_tlsdesc_got_offset): New function.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset): New function.
	(Output_data_plt_x86_64::tlsdesc_plt_entry): New field.
	(Output_data_plt_x86_64::set_final_data_size): Move out of line;
	add extra PLT entry for TLS descriptors.
	(Output_data_plt_x86_64::got_): New field.
	(Output_data_plt_x86_64::tlsdesc_got_offset_): New field.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Initialize new
	fields.
	(Output_data_plt_x86_64::do_write): Write extra PLT entry for TLS
	descriptors.
	(Target_x86_64::make_plt_entry): Factor out make_plt_section.
	(Target_x86_64::got_mod_index_entry): Remove unnecessary code.
	(Target_x86_64::Scan::local): Implement R_386_TLS_GOTDESC and
	R_386_TLS_DESC_CALL relocations.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::do_finalize_sections): Add dynamic table entries
	for TLS descriptors.
	(Relocate::relocate_tls): Fix problem with GD-to-IE relaxation.
	Implement R_386_TLS_GOTDESC and R_386_TLS_DESC_CALL relocations.
	(Target_x86_64::Relocate::tls_gd_to_ie): Fix problem with
	GD-to-IE relaxation.
	* configure.ac: Export new conditional variables TLS_GNU2_DIALECT
	and TLS_DESCRIPTORS.
	* Makefile.in: Rebuild.
	* configure: Rebuild.
	* testsuite/Makefile.am (tls_shared_gd_to_ie_test): New target.
	(tls_test_shared2.so): New target.
	(tls_shared_gd_to_ie_test_SOURCES): New variable.
	(tls_shared_gd_to_ie_test_DEPENDENCIES): New variable.
	(tls_shared_gd_to_ie_test_LDFLAGS): New variable.
	(tls_shared_gd_to_ie_test_LDADD): New variable.
	(tls_shared_gnu2_gd_to_ie_test): New target.
	(tls_test_gnu2.o, tls_test_file2_gnu2.o, tls_test_gnu2_shared2.so):
	New targets.
	(tls_shared_gnu2_gd_to_ie_test_SOURCES): New variable.
	(ls_shared_gnu2_gd_to_ie_test_DEPENDENCIES): New variable.
	(tls_shared_gnu2_gd_to_ie_test_LDFLAGS): New variable.
	(tls_shared_gnu2_gd_to_ie_test_LDADD): New variable.
	(tls_shared_gnu2_test): New target.
	(tls_test_gnu2_shared.so): New target.
	(tls_shared_gnu2_test_SOURCES): New variable.
	(tls_shared_gnu2_test_DEPENDENCIES): New variable.
	(tls_shared_gnu2_test_LDFLAGS): New variable.
	(tls_shared_gnu2_test_LDADD): New variable.
	* testsuite/Makefile.in: Rebuild.
	* testsuite/Makefile.
@
text
@d538 12
@


1.69
log
@	* output.cc (Output_reloc<SHT_REL>::local_section_offset): Add
	addend parameter.  Change caller.  Handle merge sections.
	(Output_reloc<SHT_REL>::symbol_value): Change parameter type from
	Address to Addend.  Don't add in the result of
	local_section_offset, pass down the addend and use the returned
	value.
	* output.h (class Output_reloc<SHT_REL>): Add Addend typedef.
	Update declarations of local_section_offset and symbol_value.
	* testsuite/two_file_test_1.cc (t18): New function.
	* testsuite/two_file_test_2.cc (f18): New function.
	* testsuite/two_file_test_main.cc (main): Call t18.
	* testsuite/two_file_test.h (t18, f18): Declare.
@
text
@d1345 1
a1345 1
  switch (this->classification_)
a1350 4
    case DYNAMIC_SECTION_ADDRESS:
      val = this->u_.od->address();
      break;

d1368 2
a1369 1
      gold_unreachable();
@


1.68
log
@	* output.cc
	(Output_section::Input_section_sort_entry::has_priority): New
	function.
	(Output_section::Input_section_sort_entry::match_file_name): New
	function.
	(Output_section::Input_section_sort_entry::match_section_name):
	Remove.
	(Output_section::Input_section_sort_entry::match_section_name_prefix):
	Remove.
	(Output_section::Input_section_sort_entry::match_section_file):
	Remove.
	(Output_section::Input_section_sort_compare::operator()): Rewrite
	using new Input_section_sort_entry functions.  Sort crtbegin and
	crtend first.  Sort sections with no priority before sections with
	a priority.
	* testsuite/initpri1.c (d3): Check j != 4.
	(cd5): New constructor/destructor function.
	(main): Check j != 2.
@
text
@d793 2
a794 2
// For a local section symbol, get the section offset of the input
// section within the output section.
d799 1
a799 1
  local_section_offset() const
d801 4
d808 6
a813 1
  gold_assert(os != NULL && offset != -1);
d865 1
a865 1
    Address addend) const
d894 1
a894 1
    addend += this->rel_.local_section_offset();
@


1.67
log
@	* layout.cc (Layout::layout): If we see an input section with a
	name that needs sorting, set the must_sort flag for the output
	section.
	(Layout::make_output_section): If the name of the output section
	indicates that it might	require sorting, set the may_sort flag.
	* output.h (Output_section::may_sort_attached_input_sections): New
	function.
	(Output_section::set_may_sort_attached_input_sections): New
	function.
	(Output_section::must_sort_attached_input_sections): New
	function.
	(Output_section::set_must_sort_attached_input_sections): New
	function.
	(class Output_section): Declare Input_section_sort_entry.  Define
	Input_section_sort_compare.  Declare
	sort_attached_input_sections.  Add new fields:
	may_sort_attached_input_sections_,
	must_sort_attached_input_sections_,
	attached_input_sections_are_sorted_.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_section::add_input_section): Add an entry to
	input_sections_ if may_sort or must_sort are true.
	(Output_section::set_final_data_size): Call
	sort_attached_input_sections if necessary.
	(Output_section::Input_section_sort_entry): Define new class.
	(Output_section::Input_section_sort_compare::operator()): New
	function.
	(Output_section::sort_attached_input_sections): New function.
	* configure.ac: Check whether the compiler supports constructor
	priorities.  Define a CONSTRUCTOR_PRIORITY automake conditional.
	* testsuite/initpri1.c: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add initpri1 if
	CONSTRUCTOR_PRIORITY.
	(initpri1_SOURCES, initpri1_DEPENDENCIES): New variables.
	(initpri1_LDFLAGS): New variable.
	* configure, Makefile.in, testsuite/Makefile.in: Rebuild.
@
text
@d2058 2
a2059 2
  // Return true if the section name is either SECTION_NAME1 or
  // SECTION_NAME2.
d2061 1
a2061 1
  match_section_name(const char* section_name1, const char* section_name2) const
d2064 1
a2064 2
    return (this->section_name_ == section_name1
	    || this->section_name_ == section_name2);
d2067 7
a2073 2
  // Return true if PREFIX1 or PREFIX2 is a prefix of the section
  // name.
d2075 1
a2075 1
  match_section_name_prefix(const char* prefix1, const char* prefix2) const
a2076 21
    gold_assert(this->section_has_name_);
    return (this->section_name_.compare(0, strlen(prefix1), prefix1) == 0
	    || this->section_name_.compare(0, strlen(prefix2), prefix2) == 0);
  }

  // Return true if this is for a section named SECTION_NAME1 or
  // SECTION_NAME2 in an input file whose base name matches FILE_NAME.
  // The base name must have an extension of ".o", and must be exactly
  // FILE_NAME.o or FILE_NAME, one character, ".o".  This is to match
  // crtbegin.o as well as crtbeginS.o without getting confused by
  // other possibilities.  Overall matching the file name this way is
  // a dreadful hack, but the GNU linker does it in order to better
  // support gcc, and we need to be compatible.
  bool
  match_section_file(const char* section_name1, const char* section_name2,
		     const char* match_file_name) const
  {
    gold_assert(this->section_has_name_);
    if (this->section_name_ != section_name1
	&& this->section_name_ != section_name2)
      return false;
d2107 3
a2109 14
  // We sort all the sections with no names to the end.
  if (!s1.section_has_name() || !s2.section_has_name())
    {
      if (s1.section_has_name())
	return true;
      if (s2.section_has_name())
	return false;
      return s1.index() < s2.index();
    }

  // A .ctors or .dtors section from crtbegin.o must come before any
  // other .ctors* or .dtors* section.
  bool s1_begin = s1.match_section_file(".ctors", ".dtors", "crtbegin");
  bool s2_begin = s2.match_section_file(".ctors", ".dtors", "crtbegin");
d2119 3
a2121 4
  // A .ctors or .dtors section from crtend.o must come after any
  // other .ctors* or .dtors* section.
  bool s1_end = s1.match_section_file(".ctors", ".dtors", "crtend");
  bool s2_end = s2.match_section_file(".ctors", ".dtors", "crtend");
d2131 9
a2139 8
  // A .ctors or .init_array section with a priority precedes a .ctors
  // or .init_array section without a priority.
  if (s1.match_section_name_prefix(".ctors.", ".init_array.")
      && s2.match_section_name(".ctors", ".init_array"))
    return true;
  if (s2.match_section_name_prefix(".ctors.", ".init_array.")
      && s1.match_section_name(".ctors", ".init_array"))
    return false;
d2141 6
a2146 4
  // A .dtors or .fini_array section with a priority follows a .dtors
  // or .fini_array section without a priority.
  if (s1.match_section_name_prefix(".dtors.", ".fini_array.")
      && s2.match_section_name(".dtors", ".fini_array"))
d2148 1
a2148 2
  if (s2.match_section_name_prefix(".dtors.", ".fini_array.")
      && s1.match_section_name(".dtors", ".fini_array"))
@


1.66
log
@	PR gold/5986
	Fix problems building gold with gcc 4.3.0.
	* gold.h (TEMPLATE_ATTRIBUTE_PRINTF_4): Define.
	(gold_error_at_location, gold_warning_at_location): Use it.
	* configure.ac: Check whether we can compile and use a template
	function with a printf attribute.
	* x86_64.cc (Target_x86_64::do_code_fill): Swap out a 32-bit value
	when jumping over bytes.
	* object.cc: Instantiate Object::read_section_data.
	* debug.h: Include <cstring>
	* dwarf_reader.cc: Include <algorithm>
	* main.cc: Include <cstring>.
	* options.cc: Include <cstring>.
	* output.cc: Include <cstring>.
	* script.cc: Include <cstring>.
	* script.h: Include <string>.
	* symtab.cc: Include <cstring> and <algorithm>.
	* target-select.cc: Include <cstring>.
	* version.cc: Include <string>.
	* testsuite/testmain.cc: Include <cstdlib>.
	* configure, config.in: Rebuild.
@
text
@d1598 3
d1717 3
a1719 1
  // track of sections, or if we are relaxing.  FIXME: Add test for
d1721 4
a1724 1
  if (have_sections_script || !this->input_sections_.empty())
d1954 3
d1992 233
@


1.65
log
@	* i386.cc (Target_i386::Got_type): New enum declaration.
	(Target_i386::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocate::relocate_tls): Likewise.
	* object.h (Got_offset_list): New class.
	(Sized_relobj::local_has_got_offset): Added got_type parameter.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::local_has_tls_got_offset): Removed.
	(Sized_relobj::local_tls_got_offset): Removed.
	(Sized_relobj::set_local_tls_got_offset): Removed.
	(Sized_relobj::Local_got_offsets): Changed to store a list of offsets.
	* output.cc (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* output.h (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* resolve.cc (Symbol::override_base_with_special): Removed
	reference to has_got_offset_ field.
	* symtab.cc (Symbol::init_fields): Replaced initialization
	of got_offset_ with got_offsets_.  Removed initialization
	of has_got_offset_
	*symtab.h (Symbol::has_got_offset): Aded got_type parameter.
	(Symbol::got_offset): Likewise.
	(Symbol::set_got_offset): Likewise.
	(Symbol::has_tls_got_offset): Removed.
	(Symbol::tls_got_offset): Removed.
	(Symbol::set_tls_got_offset): Removed.
	(Symbol::got_offset_): Removed.
	(Symbol::tls_mod_got_offset_): Removed.
	(Symbol::tls_pair_got_offset_): Removed.
	(Symbol::got_offsets_): New field.
	(Symbol::has_got_offset): Removed.
	(Symbol::has_tls_mod_got_offset): Removed.
	(Symbol::has_tls_pair_got_offset): Removed.
	* x86_64.cc (Target_x86_64::Got_type): New enum declaration.
	(Target_x86_64::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocate::relocate_tls): Likewise.
@
text
@d26 1
@


1.64
log
@Make sure the start and size of the TLS segment are aligned.
@
text
@d1062 3
a1064 1
Output_data_got<size, big_endian>::add_global(Symbol* gsym)
d1066 1
a1066 1
  if (gsym->has_got_offset())
d1071 1
a1071 1
  gsym->set_got_offset(this->last_got_offset());
d1081 1
d1085 1
a1085 1
  if (gsym->has_got_offset())
d1091 1
a1091 1
  gsym->set_got_offset(got_offset);
d1099 1
d1103 1
a1103 1
  if (gsym->has_got_offset())
d1109 1
a1109 1
  gsym->set_got_offset(got_offset);
d1113 3
a1115 21
// Add an entry for a local symbol to the GOT.  This returns true if
// this is a new GOT entry, false if the symbol already has a GOT
// entry.

template<int size, bool big_endian>
bool
Output_data_got<size, big_endian>::add_local(
    Sized_relobj<size, big_endian>* object,
    unsigned int symndx)
{
  if (object->local_has_got_offset(symndx))
    return false;

  this->entries_.push_back(Got_entry(object, symndx));
  this->set_got_size();
  object->set_local_got_offset(symndx, this->last_got_offset());
  return true;
}

// Add an entry for a local symbol to the GOT, and add a dynamic
// relocation of type R_TYPE for the GOT entry.
d1118 3
a1120 3
Output_data_got<size, big_endian>::add_local_with_rel(
    Sized_relobj<size, big_endian>* object,
    unsigned int symndx,
d1122 2
a1123 1
    unsigned int r_type)
d1125 1
a1125 1
  if (object->local_has_got_offset(symndx))
d1129 11
a1140 3
  unsigned int got_offset = this->last_got_offset();
  object->set_local_got_offset(symndx, got_offset);
  rel_dyn->add_local(object, symndx, r_type, this, got_offset);
d1145 3
a1147 3
Output_data_got<size, big_endian>::add_local_with_rela(
    Sized_relobj<size, big_endian>* object,
    unsigned int symndx,
d1149 2
a1150 1
    unsigned int r_type)
d1152 1
a1152 1
  if (object->local_has_got_offset(symndx))
d1156 11
a1167 3
  unsigned int got_offset = this->last_got_offset();
  object->set_local_got_offset(symndx, got_offset);
  rela_dyn->add_local(object, symndx, r_type, this, got_offset, 0);
d1170 3
a1172 5
// Add an entry (or a pair of entries) for a global TLS symbol to the GOT.
// In a pair of entries, the first value in the pair will be used for the
// module index, and the second value will be used for the dtv-relative
// offset. This returns true if this is a new GOT entry, false if the symbol
// already has a GOT entry.
d1176 4
a1179 1
Output_data_got<size, big_endian>::add_global_tls(Symbol* gsym, bool need_pair)
d1181 1
a1181 1
  if (gsym->has_tls_got_offset(need_pair))
d1184 1
a1184 4
  this->entries_.push_back(Got_entry(gsym));
  gsym->set_tls_got_offset(this->last_got_offset(), need_pair);
  if (need_pair)
    this->entries_.push_back(Got_entry(gsym));
d1186 1
d1190 2
a1191 2
// Add an entry for a global TLS symbol to the GOT, and add a dynamic
// relocation of type R_TYPE.
d1194 4
a1197 2
Output_data_got<size, big_endian>::add_global_tls_with_rel(
    Symbol* gsym,
d1201 1
a1201 1
  if (gsym->has_tls_got_offset(false))
d1207 2
a1208 2
  gsym->set_tls_got_offset(got_offset, false);
  rel_dyn->add_global(gsym, r_type, this, got_offset);
d1213 4
a1216 2
Output_data_got<size, big_endian>::add_global_tls_with_rela(
    Symbol* gsym,
d1220 1
a1220 1
  if (gsym->has_tls_got_offset(false))
d1226 2
a1227 48
  gsym->set_tls_got_offset(got_offset, false);
  rela_dyn->add_global(gsym, r_type, this, got_offset, 0);
}

// Add a pair of entries for a global TLS symbol to the GOT, and add
// dynamic relocations of type MOD_R_TYPE and DTV_R_TYPE, respectively.
template<int size, bool big_endian>
void
Output_data_got<size, big_endian>::add_global_tls_with_rel(
    Symbol* gsym,
    Rel_dyn* rel_dyn,
    unsigned int mod_r_type,
    unsigned int dtv_r_type)
{
  if (gsym->has_tls_got_offset(true))
    return;

  this->entries_.push_back(Got_entry());
  unsigned int got_offset = this->last_got_offset();
  gsym->set_tls_got_offset(got_offset, true);
  rel_dyn->add_global(gsym, mod_r_type, this, got_offset);

  this->entries_.push_back(Got_entry());
  this->set_got_size();
  got_offset = this->last_got_offset();
  rel_dyn->add_global(gsym, dtv_r_type, this, got_offset);
}

template<int size, bool big_endian>
void
Output_data_got<size, big_endian>::add_global_tls_with_rela(
    Symbol* gsym,
    Rela_dyn* rela_dyn,
    unsigned int mod_r_type,
    unsigned int dtv_r_type)
{
  if (gsym->has_tls_got_offset(true))
    return;

  this->entries_.push_back(Got_entry());
  unsigned int got_offset = this->last_got_offset();
  gsym->set_tls_got_offset(got_offset, true);
  rela_dyn->add_global(gsym, mod_r_type, this, got_offset, 0);

  this->entries_.push_back(Got_entry());
  this->set_got_size();
  got_offset = this->last_got_offset();
  rela_dyn->add_global(gsym, dtv_r_type, this, got_offset, 0);
d1230 3
a1232 29
// Add an entry (or a pair of entries) for a local TLS symbol to the GOT.
// In a pair of entries, the first value in the pair will be used for the
// module index, and the second value will be used for the dtv-relative
// offset. This returns true if this is a new GOT entry, false if the symbol
// already has a GOT entry.

template<int size, bool big_endian>
bool
Output_data_got<size, big_endian>::add_local_tls(
    Sized_relobj<size, big_endian>* object,
    unsigned int symndx,
    bool need_pair)
{
  if (object->local_has_tls_got_offset(symndx, need_pair))
    return false;

  this->entries_.push_back(Got_entry(object, symndx));
  object->set_local_tls_got_offset(symndx, this->last_got_offset(), need_pair);
  if (need_pair)
    this->entries_.push_back(Got_entry(object, symndx));
  this->set_got_size();
  return true;
}

// Add an entry (or pair of entries) for a local TLS symbol to the GOT,
// and add a dynamic relocation of type R_TYPE for the first GOT entry.
// Because this is a local symbol, the first GOT entry can be relocated
// relative to a section symbol, and the second GOT entry will have an
// dtv-relative value that can be computed at link time.
d1235 1
a1235 1
Output_data_got<size, big_endian>::add_local_tls_with_rel(
d1239 1
a1239 1
    bool need_pair,
d1241 2
a1242 1
    unsigned int r_type)
d1244 1
a1244 1
  if (object->local_has_tls_got_offset(symndx, need_pair))
d1249 1
a1249 1
  object->set_local_tls_got_offset(symndx, got_offset, need_pair);
d1252 1
a1252 1
  rel_dyn->add_output_section(os, r_type, this, got_offset);
d1254 6
a1259 4
  // The second entry of the pair will be statically initialized
  // with the TLS offset of the symbol.
  if (need_pair)
    this->entries_.push_back(Got_entry(object, symndx));
d1266 1
a1266 1
Output_data_got<size, big_endian>::add_local_tls_with_rela(
d1270 1
a1270 1
    bool need_pair,
d1272 2
a1273 1
    unsigned int r_type)
d1275 1
a1275 1
  if (object->local_has_tls_got_offset(symndx, need_pair))
d1280 1
a1280 1
  object->set_local_tls_got_offset(symndx, got_offset, need_pair);
d1283 1
a1283 1
  rela_dyn->add_output_section(os, r_type, this, got_offset, 0);
d1285 6
a1290 4
  // The second entry of the pair will be statically initialized
  // with the TLS offset of the symbol.
  if (need_pair)
    this->entries_.push_back(Got_entry(object, symndx));
@


1.63
log
@Fix handling of RELA relative relocs against local symbols in merge
sections.
@
text
@d2486 2
a2487 1
Output_segment::set_section_addresses(bool reset, uint64_t addr, off_t* poff,
d2504 2
d2509 2
a2510 2
  addr = this->set_section_list_addresses(reset, &this->output_data_,
					  addr, poff, pshndx);
d2515 14
a2528 2
  uint64_t ret = this->set_section_list_addresses(reset, &this->output_bss_,
						  addr, poff, pshndx);
d2542 2
a2543 1
Output_segment::set_section_list_addresses(bool reset, Output_data_list* pdl,
d2545 2
a2546 1
					   unsigned int* pshndx)
d2562 36
a2597 1
	  off = align_address(off, (*p)->addralign());
d2610 4
a2613 5
      // Unless this is a PT_TLS segment, we want to ignore the size
      // of a SHF_TLS/SHT_NOBITS section.  Such a section does not
      // affect the size of a PT_LOAD segment.
      if (this->type_ == elfcpp::PT_TLS
	  || !(*p)->is_section_flag_set(elfcpp::SHF_TLS)
d2680 10
@


1.62
log
@Update copyright years.  Update language files.
@
text
@d803 1
a803 1
  gold_assert(os != NULL);
d854 2
a855 1
Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::symbol_value() const
d861 1
a861 1
      return sym->value();
d864 5
a868 3
              && this->local_sym_index_ != INVALID_CODE);
  const Sized_relobj<size, big_endian>* relobj = this->u1_.relobj;
  return relobj->local_symbol_value(this->local_sym_index_);
d882 2
a883 2
    addend += this->rel_.symbol_value();
  if (this->rel_.is_local_section_symbol())
d1043 5
a1047 1
      val = this->u_.object->local_symbol_value(this->local_sym_index_);
@


1.61
log
@Combine read-only .eh_frame sections with read-write .eh_frame
sections.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.60
log
@Remove gcc 3.2 compatibility hacks.
@
text
@d2379 21
@


1.59
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d1384 1
a1384 2
    const Stringpool* pool
    ACCEPT_SIZE_ENDIAN) const
d1502 1
a1502 2
      p->write SELECT_SIZE_ENDIAN_NAME(size, big_endian)(
          pov, this->pool_ SELECT_SIZE_ENDIAN(size, big_endian));
d2738 1
a2738 2
				      unsigned int *pshndx
                                      ACCEPT_SIZE_ENDIAN) const
d2746 6
a2751 8
  v = this->write_section_headers_list
      SELECT_SIZE_ENDIAN_NAME(size, big_endian) (
	  layout, secnamepool, &this->output_data_, v, pshndx
          SELECT_SIZE_ENDIAN(size, big_endian));
  v = this->write_section_headers_list
      SELECT_SIZE_ENDIAN_NAME(size, big_endian) (
          layout, secnamepool, &this->output_bss_, v, pshndx
          SELECT_SIZE_ENDIAN(size, big_endian));
d2761 1
a2761 2
					   unsigned int* pshndx
                                           ACCEPT_SIZE_ENDIAN) const
@


1.58
log
@Support dynamic relocations against local section symbols.
@
text
@d64 2
a65 1
  return Output_data::default_alignment_for_size(parameters->get_size());
d98 1
a98 1
  if (!parameters->output_is_object())
d116 1
a116 1
  const int size = parameters->get_size();
d133 1
a133 1
  if (parameters->get_size() == 32)
d135 5
a139 2
      if (parameters->is_big_endian())
	{
d141 3
a143 3
	  this->do_sized_write<32, true>(of);
#else
	  gold_unreachable();
d145 4
a148 7
	}
      else
	{
#ifdef HAVE_TARGET_32_LITTLE
	  this->do_sized_write<32, false>(of);
#else
	  gold_unreachable();
a149 6
	}
    }
  else if (parameters->get_size() == 64)
    {
      if (parameters->is_big_endian())
	{
d151 3
a153 3
	  this->do_sized_write<64, true>(of);
#else
	  gold_unreachable();
d155 2
a156 9
	}
      else
	{
#ifdef HAVE_TARGET_64_LITTLE
	  this->do_sized_write<64, false>(of);
#else
	  gold_unreachable();
#endif
	}
a157 2
  else
    gold_unreachable();
d187 1
a187 1
  if (!parameters->output_is_object())
d226 1
a226 1
	  && parameters->output_is_object())
d244 1
a244 1
  const int size = parameters->get_size();
d259 1
a259 1
  if (parameters->get_size() == 32)
d261 5
a265 2
      if (parameters->is_big_endian())
	{
d267 3
a269 3
	  this->do_sized_write<32, true>(of);
#else
	  gold_unreachable();
d271 4
a274 7
	}
      else
	{
#ifdef HAVE_TARGET_32_LITTLE
	this->do_sized_write<32, false>(of);
#else
	gold_unreachable();
a275 6
	}
    }
  else if (parameters->get_size() == 64)
    {
      if (parameters->is_big_endian())
	{
d277 3
a279 3
	  this->do_sized_write<64, true>(of);
#else
	  gold_unreachable();
d281 2
a282 9
	}
      else
	{
#ifdef HAVE_TARGET_64_LITTLE
	  this->do_sized_write<64, false>(of);
#else
	  gold_unreachable();
#endif
	}
a283 2
  else
    gold_unreachable();
d323 1
a323 1
  const int size = parameters->get_size();
d352 1
a352 1
  if (parameters->get_size() == 32)
d354 5
a358 2
      if (parameters->is_big_endian())
	{
d360 3
a362 3
	  this->do_sized_write<32, true>(of);
#else
	  gold_unreachable();
d364 4
a367 7
	}
      else
	{
#ifdef HAVE_TARGET_32_LITTLE
	  this->do_sized_write<32, false>(of);
#else
	  gold_unreachable();
a368 6
	}
    }
  else if (parameters->get_size() == 64)
    {
      if (parameters->is_big_endian())
	{
d370 3
a372 3
	  this->do_sized_write<64, true>(of);
#else
	  gold_unreachable();
d374 2
a375 9
	}
      else
	{
#ifdef HAVE_TARGET_64_LITTLE
	  this->do_sized_write<64, false>(of);
#else
	  gold_unreachable();
#endif
	}
a376 2
  else
    gold_unreachable();
d411 1
a411 1
  if (parameters->output_is_object())
d413 1
a413 1
  else if (parameters->output_is_shared())
d464 2
a465 1
				     && parameters->output_is_executable());
d1430 1
a1430 1
  if (parameters->get_size() == 32)
d1432 1
a1432 1
  else if (parameters->get_size() == 64)
d1447 1
a1447 1
  if (parameters->get_size() == 32)
d1449 1
a1449 1
  else if (parameters->get_size() == 64)
d1461 1
a1461 1
  if (parameters->get_size() == 32)
d1463 5
a1467 2
      if (parameters->is_big_endian())
	{
d1469 3
a1471 3
	  this->sized_write<32, true>(of);
#else
	  gold_unreachable();
d1473 4
a1476 7
	}
      else
	{
#ifdef HAVE_TARGET_32_LITTLE
	  this->sized_write<32, false>(of);
#else
	  gold_unreachable();
a1477 6
	}
    }
  else if (parameters->get_size() == 64)
    {
      if (parameters->is_big_endian())
	{
d1479 3
a1481 3
	  this->sized_write<64, true>(of);
#else
	  gold_unreachable();
d1483 2
a1484 9
	}
      else
	{
#ifdef HAVE_TARGET_64_LITTLE
	  this->sized_write<64, false>(of);
#else
	  gold_unreachable();
#endif
	}
a1485 2
  else
    gold_unreachable();
d2094 1
a2094 1
      std::string fill_data(parameters->target()->code_fill(p->length()));
a2142 1
  Target* target = parameters->target();
d2148 1
a2148 1
      std::string fill_data(target->code_fill(p->length()));
d2830 1
a2830 1
	  int mode = parameters->output_is_object() ? 0666 : 0777;
@


1.57
log
@Support --oformat binary.
@
text
@d611 1
a611 1
    is_relative_(is_relative), shndx_(INVALID_CODE)
d613 2
d617 2
a618 2
  if (dynamic && !is_relative)
    gsym->set_needs_dynsym_entry();
d630 1
a630 1
    is_relative_(is_relative), shndx_(shndx)
d633 2
d637 2
a638 2
  if (dynamic && !is_relative)
    gsym->set_needs_dynsym_entry();
d650 2
a651 1
    bool is_relative)
d653 2
a654 1
    is_relative_(is_relative), shndx_(INVALID_CODE)
d658 2
d662 2
a663 2
  if (dynamic && !is_relative)
    relobj->set_needs_output_dynsym_entry(local_sym_index);
d673 2
a674 1
    bool is_relative)
d676 2
a677 1
    is_relative_(is_relative), shndx_(shndx)
d682 2
d686 2
a687 2
  if (dynamic && !is_relative)
    relobj->set_needs_output_dynsym_entry(local_sym_index);
d699 1
a699 1
    is_relative_(false), shndx_(INVALID_CODE)
d701 2
d706 3
a708 1
    os->set_needs_dynsym_index();
d719 1
a719 1
    is_relative_(false), shndx_(shndx)
d722 2
d727 45
a771 1
    os->set_needs_dynsym_index();
d809 20
a828 4
      if (dynamic)
        index = this->u1_.relobj->dynsym_index(this->local_sym_index_);
      else
	index = this->u1_.relobj->symtab_index(this->local_sym_index_);
d835 15
d921 4
a924 2
  if (rel_.is_relative())
    addend += rel_.symbol_value();
@


1.56
log
@Fix group signature handling for relocatable link, add bootstrap
relocatable test.
@
text
@d2758 2
a2759 1
    map_is_anonymous_(false)
d2784 1
a2784 3
  if (strcmp(this->name_, "-") == 0)
    this->o_ = STDOUT_FILENO;
  else
d2786 14
a2799 9
      struct stat s;
      if (::stat(this->name_, &s) == 0 && s.st_size != 0)
        unlink_if_ordinary(this->name_);

      int mode = parameters->output_is_object() ? 0666 : 0777;
      int o = ::open(this->name_, O_RDWR | O_CREAT | O_TRUNC, mode);
      if (o < 0)
        gold_fatal(_("%s: open: %s"), this->name_, strerror(errno));
      this->o_ = o;
d2844 2
a2845 1
      || !S_ISREG(statbuf.st_mode))
d2886 1
a2886 1
  if (this->map_is_anonymous_)
d2903 3
a2905 1
  if (this->o_ != STDOUT_FILENO && this->o_ != STDERR_FILENO)
@


1.55
log
@Initial -r support.
@
text
@d1613 1
d2009 1
a2009 1
  if (this->info_section_ != NULL)
d2024 2
d2027 6
a2032 1
    oshdr->put_sh_info(this->info_section_->out_shndx());
d2034 1
a2034 1
    oshdr->put_sh_info(this->info_symndx_->symtab_index());
d2036 3
a2038 1
    oshdr->put_sh_info(this->info_);
@


1.54
log
@Implement PHDRS.
@
text
@d86 1
d91 1
d97 16
a112 5
  for (Layout::Segment_list::const_iterator p = segment_list->begin();
       p != segment_list->end();
       ++p)
    if ((*p)->type() == elfcpp::PT_LOAD)
      count += (*p)->output_section_count();
d200 32
a231 7
  unsigned shndx = 1;
  for (Layout::Segment_list::const_iterator p = this->segment_list_->begin();
       p != this->segment_list_->end();
       ++p)
    v = (*p)->write_section_headers SELECT_SIZE_ENDIAN_NAME(size, big_endian) (
	    this->layout_, this->secnamepool_, v, &shndx
	    SELECT_SIZE_ENDIAN(size, big_endian));
d237 5
d468 5
a472 1
  oehdr.put_e_phoff(this->segment_header_->offset());
d479 13
a491 3
  oehdr.put_e_phentsize(elfcpp::Elf_sizes<size>::phdr_size);
  oehdr.put_e_phnum(this->segment_header_->data_size()
		     / elfcpp::Elf_sizes<size>::phdr_size);
d882 74
d1594 1
d2006 6
a2011 1
  oshdr->put_sh_flags(this->flags_);
d2025 2
d3023 60
@


1.53
log
@Implement SIZEOF_HEADERS, section constraints, other minor linker
script items.
@
text
@d2483 49
@


1.52
log
@Fully implement the SECTIONS clause.
@
text
@a2326 2
      off = align_address(off, (*p)->addralign());

d2333 4
a2336 1
	(*p)->set_address_and_file_offset(addr + (off - startoff), off);
d2341 2
a2342 2
	  gold_assert((*p)->address() >= addr);
	  off = startoff + ((*p)->address() - addr);
@


1.51
log
@Don't include options.h in fileread.h.  Remove General_options
reference from Output_file class.
@
text
@d278 1
d291 2
d1377 9
d1459 1
d1479 2
d1513 3
a1515 1
// sections.
d1523 2
a1524 1
				  unsigned int reloc_shndx)
d1538 5
d1573 1
d1599 1
a1599 1
  if (!this->input_sections_.empty())
d1614 9
d1845 11
d1910 1
a1910 1
                fill_data.data(), fill_data.size());
d1964 2
a1965 1
      memcpy(buffer + p->section_offset(), fill_data.data(), fill_data.size());
d1979 83
d2082 2
a2083 1
    align_(0),
d2088 2
a2089 1
    is_align_known_(false)
d2101 1
a2101 1
  gold_assert(!this->is_align_known_);
d2202 1
a2202 1
  gold_assert(!this->is_align_known_);
a2206 1
// Once we compute this, we prohibit new sections from being added.
d2209 1
a2209 1
Output_segment::addralign()
d2211 1
a2211 1
  if (!this->is_align_known_)
d2215 3
a2217 3
      addralign = Output_segment::maximum_alignment(&this->output_data_);
      if (addralign > this->align_)
	this->align_ = addralign;
d2219 3
a2221 3
      addralign = Output_segment::maximum_alignment(&this->output_bss_);
      if (addralign > this->align_)
	this->align_ = addralign;
d2223 1
a2223 1
      this->is_align_known_ = true;
d2226 1
a2226 1
  return this->align_;
d2232 1
a2232 1
Output_segment::maximum_alignment(const Output_data_list* pdl)
d2268 5
a2272 4
// Set the section addresses for an Output_segment.  ADDR is the
// address and *POFF is the file offset.  Set the section indexes
// starting with *PSHNDX.  Return the address of the immediately
// following segment.  Update *POFF and *PSHNDX.
d2275 1
a2275 1
Output_segment::set_section_addresses(uint64_t addr, off_t* poff,
d2280 11
a2290 2
  this->vaddr_ = addr;
  this->paddr_ = addr;
d2295 2
a2296 4
  *poff = align_address(*poff, this->addralign());

  addr = this->set_section_list_addresses(&this->output_data_, addr, poff,
					  pshndx);
d2301 2
a2302 2
  uint64_t ret = this->set_section_list_addresses(&this->output_bss_, addr,
						  poff, pshndx);
d2316 1
a2316 1
Output_segment::set_section_list_addresses(Output_data_list* pdl,
d2328 17
a2344 1
      (*p)->set_address_and_file_offset(addr + (off - startoff), off);
d2373 2
d2379 1
d2381 1
a2381 1
      this->align_ = 0;
d2393 4
a2396 1
  this->paddr_ = this->vaddr_;
d2437 20
d2495 1
a2495 1
  ophdr->put_p_align(this->addralign());
d2716 2
a2717 1
    unsigned int reloc_shndx);
d2728 2
a2729 1
    unsigned int reloc_shndx);
d2740 2
a2741 1
    unsigned int reloc_shndx);
d2752 2
a2753 1
    unsigned int reloc_shndx);
@


1.50
log
@Add support for -e and for ENTRY in linker scripts.
@
text
@d1864 1
a1864 1
      std::string fill_data(of->target()->code_fill(p->length()));
d2375 2
a2376 4
Output_file::Output_file(const General_options& options, Target* target)
  : options_(options),
    target_(target),
    name_(options.output_file_name()),
@


1.49
log
@Don't create the postprocessing buffer if it already exists.
@
text
@d297 2
a298 1
				       const Output_segment_headers* osh)
d303 2
a304 1
    shstrtab_(NULL)
d420 1
a420 13
  // FIXME: Need to support -e, and target specific entry symbol.
  Symbol* sym = this->symtab_->lookup("_start");
  typename Sized_symbol<size>::Value_type v;
  if (sym == NULL)
    v = 0;
  else
    {
      Sized_symbol<size>* ssym;
      ssym = this->symtab_->get_sized_symbol SELECT_SIZE_NAME(size) (
        sym SELECT_SIZE(size));
      v = ssym->value();
    }
  oehdr.put_e_entry(v);
d438 43
@


1.48
log
@Correct handling of non-section symbol in merged section.  Avoid some
64-bit signed/unsigned warnings.
@
text
@d1848 3
a1850 1
  gold_assert(this->postprocessing_buffer_ == NULL);
@


1.47
log
@Speed up relocations against local symbols in merged sections.
@
text
@a1697 2
  // This can only be called meaningfully when layout is complete.
  gold_assert(Output_data::is_layout_complete());
@


1.46
log
@Update comments about output offsets and merged input sections.
@
text
@d1372 12
d1722 28
@


1.45
log
@Make functions on hot path inline.  Remove a mistaken virtual
declaration.
@
text
@d1350 3
a1352 1
// Try to turn an input offset into an output offset.
d1367 1
a1367 5
      section_offset_type output_offset;
      Output_section* os = object->output_section(shndx, &output_offset);
      gold_assert(os != NULL);
      gold_assert(output_offset != -1);
      *poutput = output_offset + offset;
d1656 2
a1657 2
// start of the section.  This should only be called if SHNDX in
// OBJECT has a special mapping.
@


1.44
log
@Print statistics about merge sections with --stats.
@
text
@d1352 1
a1352 1
bool
@


1.43
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d1863 12
@


1.42
log
@From Cary Coutant: Fix handling of RELATIVE RELA relocs.
@
text
@d676 1
a676 1
      off_t off;
d1088 1
a1088 1
  off_t off;
d1116 1
a1116 1
  off_t off;
d1353 5
a1357 4
Output_section::Input_section::output_offset(const Relobj* object,
					     unsigned int shndx,
					     off_t offset,
					     off_t *poutput) const
d1365 1
a1365 1
      off_t output_offset;
d1645 1
a1645 1
      off_t output_offset;
d1661 1
a1661 1
off_t
d1663 1
a1663 1
			      off_t offset) const
d1673 1
a1673 1
      off_t output_offset;
d1697 1
a1697 1
      off_t output_offset;
@


1.41
log
@From Cary Coutant: More support for generating shared libraries.
@
text
@d515 2
a516 1
    Address address)
d518 1
a518 1
    shndx_(INVALID_CODE)
d522 1
a522 1
  if (dynamic)
d532 2
a533 1
    Address address)
d535 1
a535 1
    shndx_(shndx)
d540 1
a540 1
  if (dynamic)
d552 2
a553 1
    Address address)
d555 1
a555 1
    shndx_(INVALID_CODE)
d561 1
a561 1
  if (dynamic && local_sym_index > 0)
d571 2
a572 1
    Address address)
d574 1
a574 1
    shndx_(shndx)
d581 1
a581 1
  if (dynamic && local_sym_index > 0)
d594 1
a594 1
    shndx_(INVALID_CODE)
d610 1
a610 1
    shndx_(shndx)
d692 2
a693 2
  wr->put_r_info(elfcpp::elf_r_info<size>(this->get_symbol_index(),
					  this->type_));
d707 18
d734 4
a737 1
  orel.put_r_addend(this->addend_);
d803 3
d807 6
a812 17

	// If the symbol is resolved locally, we need to write out its
	// value.  Otherwise we just write zero.  The target code is
	// responsible for creating a relocation entry to fill in the
	// value at runtime. For non-preemptible symbols in a shared
	// library, the target will need to record whether or not the
	// value should be written (e.g., it may use a RELATIVE
	// relocation type).
	if (gsym->final_value_is_known() || gsym->needs_value_in_got())
	  {
	    Sized_symbol<size>* sgsym;
	    // This cast is a bit ugly.  We don't want to put a
	    // virtual method in Symbol, because we want Symbol to be
	    // as small as possible.
	    sgsym = static_cast<Sized_symbol<size>*>(gsym);
	    val = sgsym->value();
	  }
@


1.40
log
@From Craig Silverstein: Support -o -.
@
text
@d508 107
d651 1
a651 6
	{
	  // FIXME: It seems that some targets may need to generate
	  // dynamic relocations against local symbols for some
	  // reasons.  This will have to be addressed at some point.
	  gold_unreachable();
	}
d830 36
d885 38
d931 1
a931 2
Output_data_got<size, big_endian>::add_global_tls(Symbol* gsym,
						  bool need_pair)
d944 82
d1050 61
d1404 2
a1405 1
    requires_postprocessing_(false)
d1725 8
d2157 18
@


1.39
log
@From Craig Silverstein: Support irregular output files.
@
text
@d1960 15
a1974 9
  struct stat s;
  if (::stat(this->name_, &s) == 0 && s.st_size != 0)
    unlink_if_ordinary(this->name_);

  int mode = parameters->output_is_object() ? 0666 : 0777;
  int o = ::open(this->name_, O_RDWR | O_CREAT | O_TRUNC, mode);
  if (o < 0)
    gold_fatal(_("%s: open: %s"), this->name_, strerror(errno));
  this->o_ = o;
d2016 2
a2017 1
  if (::fstat(o, &statbuf) != 0
d2075 4
a2078 2
  if (::close(this->o_) < 0)
    gold_error(_("%s: close: %s"), this->name_, strerror(errno));
@


1.38
log
@Compress all debug sections.
@
text
@d41 5
d1935 2
a1936 1
    base_(NULL)
d1978 18
a1995 4
  if (::munmap(this->base_, this->file_size_) < 0)
    gold_error(_("%s: munmap: %s"), this->name_, strerror(errno));
  this->file_size_ = file_size;
  this->map();
d2003 1
a2003 1
  int o = this->o_;
d2005 26
a2030 10
  // Write out one byte to make the file the right size.
  if (::lseek(o, this->file_size_ - 1, SEEK_SET) < 0)
    gold_fatal(_("%s: lseek: %s"), this->name_, strerror(errno));
  char b = 0;
  if (::write(o, &b, 1) != 1)
    gold_fatal(_("%s: write: %s"), this->name_, strerror(errno));

  // Map the file into memory.
  void* base = ::mmap(NULL, this->file_size_, PROT_READ | PROT_WRITE,
		      MAP_SHARED, o, 0);
d2036 1
a2036 1
// Close the output file.
d2039 1
a2039 1
Output_file::close()
d2044 23
@


1.37
log
@From Craig Silverstein: Add support for compressing .debug_str section.
@
text
@a34 1
#include "compressed_output.h"
d989 4
a992 2
Output_section::Input_section::set_address(uint64_t addr, off_t off,
					   off_t secoff)
d995 2
a996 1
    this->u2_.object->set_section_offset(this->shndx_, off - secoff);
d998 10
a1007 1
    this->u2_.posd->set_address_and_file_offset(addr, off);
d1044 10
d1058 1
a1058 2
Output_section::Output_section(const General_options& options,
                               const char* name, elfcpp::Elf_Word type,
d1060 1
a1060 2
  : options_(options),
    name_(name),
d1075 1
a1104 16
// Sometimes we compress sections.  This is typically done for
// sections that are not part of normal program execution (such as
// .debug_* sections), and where the readers of these sections know
// how to deal with compressed sections.  (To make it easier for them,
// we will rename the ouput section in such cases from .foo to
// .foo.zlib.nnnn, where nnnn is the uncompressed size.)  This routine
// doesn't say for certain whether we'll compress -- it depends on
// commandline options as well -- just whether this section is a
// candidate for compression.

static bool
is_compressible_section(const char* secname)
{
  return (strncmp(secname, ".debug", sizeof(".debug") - 1) == 0);
}

d1152 1
a1152 2
					entsize, addralign,
                                        is_compressible_section(secname)))
d1239 1
a1239 2
					uint64_t addralign,
                                        bool is_compressible_section)
a1262 19
  else if (is_compressible_section && options_.compress_debug_sections())
    {
      switch (entsize)
	{
        case 1:
	  posd = new Output_compressed_string<char>(addralign, this->options_);
	  break;
        case 2:
	  posd = new Output_compressed_string<uint16_t>(addralign,
							this->options_);
	  break;
        case 4:
	  posd = new Output_compressed_string<uint32_t>(addralign,
							this->options_);
	  break;
        default:
	  return false;
	}
    }
d1393 2
a1394 1
      p->set_address(address + (off - startoff), off, startoff);
a1400 23
// Ask each output_section_data member if it wants to change the name
// of the output section.  If any of them says yes, use this to set
// the new name.  This should be called after all processing of this
// output section is done, but before the name is finally committed to
// the output-section's header.

bool
Output_section::maybe_modify_output_section_name()
{
  for (Input_section_list::const_iterator it = input_sections_.begin();
       it != input_sections_.end();
       ++it)
    {
      const char* newname = it->modified_output_section_name(this->name());
      if (newname != NULL)
        {
          this->set_name(newname);
          return true;
        }
    }
  return false;
}

d1438 2
d1454 57
@


1.36
log
@Clean up setting address and section offset.
@
text
@d35 1
d1037 2
a1038 1
Output_section::Output_section(const char* name, elfcpp::Elf_Word type,
d1040 2
a1041 1
  : name_(name),
d1085 16
d1148 2
a1149 1
					entsize, addralign))
d1236 2
a1237 1
					uint64_t addralign)
d1251 4
a1254 1
      break;
d1258 22
a1279 2
  if (p != this->input_sections_.end())
    p->add_input_section(object, shndx);
d1282 15
a1296 11
      Output_section_data* posd;
      if (!is_string)
	posd = new Output_merge_data(entsize, addralign);
      else if (entsize == 1)
	posd = new Output_merge_string<char>(addralign);
      else if (entsize == 2)
	posd = new Output_merge_string<uint16_t>(addralign);
      else if (entsize == 4)
	posd = new Output_merge_string<uint32_t>(addralign);
      else
	return false;
d1298 2
a1299 3
      this->add_output_merge_section(posd, is_string, entsize);
      posd->add_input_section(object, shndx);
    }
d1415 23
@


1.35
log
@From Craig Silverstein: Also set entsize for .debug_str sections.
@
text
@d46 1
a46 1
bool Output_data::sizes_are_fixed;
a53 12
// Set the address and offset.

void
Output_data::set_address(uint64_t addr, off_t off)
{
  this->address_ = addr;
  this->offset_ = off;

  // Let the child class know.
  this->do_set_address(addr, off);
}

d326 2
d484 1
a484 2
// Set the address.  We don't actually care about the address, but we
// do set our final size.
d487 1
a487 1
Output_data_strtab::do_set_address(uint64_t, off_t)
d882 1
a882 1
Output_data_dynamic::do_set_address(uint64_t, off_t)
d995 1
a995 1
    this->u2_.posd->set_address(addr, off);
d1057 2
a1058 1
    after_input_sections_(false)
d1060 5
d1137 1
a1137 1
  off_t offset_in_section = this->data_size();
d1161 2
a1162 1
  this->set_data_size(aligned_offset_in_section + shdr.get_sh_size());
d1190 1
a1190 1
    this->first_input_offset_ = this->data_size();
d1343 1
a1343 1
// Set the address of an Output_section.  This is where we handle
d1347 1
a1347 1
Output_section::do_set_address(uint64_t address, off_t startoff)
d1350 4
a1353 1
    return;
d1355 2
d1668 1
a1668 1
      (*p)->set_address(addr + (off - startoff), off);
d1874 21
d1896 1
a1896 1
  if (::lseek(o, file_size - 1, SEEK_SET) < 0)
d1903 1
a1903 1
  void* base = ::mmap(NULL, file_size, PROT_READ | PROT_WRITE,
@


1.34
log
@From Craig Silverstein: Force .debug_str sections to be SHF_MERGE and
SHF_STRINGS.
@
text
@d1117 1
d1122 4
a1125 1
    sh_flags |= (elfcpp::SHF_MERGE | elfcpp::SHF_STRINGS);
d1134 1
a1134 2
					shdr.get_sh_entsize(),
					addralign))
@


1.33
log
@From Cary Coutant: Count textrel with output sections rather than
setting a flag as we add each reloc in the target code.
@
text
@d1116 7
d1126 1
a1126 1
  if ((shdr.get_sh_flags() & elfcpp::SHF_MERGE) != 0
d1129 1
a1129 1
      if (this->add_merge_input_section(object, shndx, shdr.get_sh_flags(),
d1144 1
a1144 1
      && (shdr.get_sh_flags() & elfcpp::SHF_EXECINSTR) != 0
@


1.32
log
@From Cary Coutant: Improve i386 shared library TLS support.
@
text
@d1583 22
@


1.31
log
@From Cary Coutant: More shared library support, some refactorization.
@
text
@d746 1
d753 46
d1482 6
a1487 2
  // correctly.
  if ((os->flags() & elfcpp::SHF_TLS) != 0 && !this->output_data_.empty())
@


1.30
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d687 5
a691 2
	// value at runtime.
	if (gsym->final_value_is_known())
@


1.29
log
@Check that we don't set the output section index twice.
@
text
@d66 8
d77 1
a77 1
Output_data::default_alignment(int size)
d580 8
a587 1
      address += os->address() + off;
d959 1
a959 1
// Try to turn an input address into an output address.
d962 4
a965 5
Output_section::Input_section::output_address(const Relobj* object,
					      unsigned int shndx,
					      off_t offset,
					      uint64_t output_section_address,
					      uint64_t *poutput) const
d968 1
a968 2
    return this->u2_.posd->output_address(object, shndx, offset,
					  output_section_address, poutput);
d971 1
a971 2
      if (this->shndx_ != shndx
	  || this->u2_.object != object)
d976 2
a977 1
      *poutput = output_section_address + output_offset + offset;
d1017 2
a1018 1
    should_link_to_dynsym_(false)
d1038 8
a1045 4
// OBJECT, to the Output_section.  Return the offset of the input
// section within the output section.  We don't always keep track of
// input sections for an Output_section.  Instead, each Object keeps
// track of the Output_section for each of its input sections.
d1049 2
a1050 1
Output_section::add_input_section(Relobj* object, unsigned int shndx,
d1052 2
a1053 1
				  const elfcpp::Shdr<size, big_endian>& shdr)
d1067 4
a1070 2
  // a Output_data_merge.
  if ((shdr.get_sh_flags() & elfcpp::SHF_MERGE) != 0)
d1077 1
a1077 1
	  // output_address method to determine the final address.
d1201 51
d1259 4
d1269 7
a1275 3
      uint64_t output;
      if (p->output_address(object, shndx, offset, addr, &output))
	return output;
d1823 1
a1823 1
    Relobj* object,
d1826 2
a1827 1
    const elfcpp::Shdr<32, false>& shdr);
d1834 1
a1834 1
    Relobj* object,
d1837 2
a1838 1
    const elfcpp::Shdr<32, true>& shdr);
d1845 1
a1845 1
    Relobj* object,
d1848 2
a1849 1
    const elfcpp::Shdr<64, false>& shdr);
d1856 1
a1856 1
    Relobj* object,
d1859 2
a1860 1
    const elfcpp::Shdr<64, true>& shdr);
@


1.28
log
@Correctly handle alignment in merge sections.
@
text
@d995 1
a995 1
    out_shndx_(0),
@


1.27
log
@From Cary Coutant: preliminary shared library support.
@
text
@d1140 5
a1144 3
  // We only merge constants if the alignment is not more than the
  // entry size.  This could be handled, but it's unusual.
  if (addralign > entsize)
a1146 1
  bool is_string = (flags & elfcpp::SHF_STRINGS) != 0;
d1151 1
a1151 1
    if (p->is_merge_section(is_string, entsize))
d1162 1
a1162 1
	posd = new Output_merge_data(entsize);
d1164 1
a1164 1
	posd = new Output_merge_string<char>();
d1166 1
a1166 1
	posd = new Output_merge_string<uint16_t>();
d1168 1
a1168 1
	posd = new Output_merge_string<uint32_t>();
@


1.26
log
@From Craig Silverstein: call unlink_if_ordinary.
@
text
@a403 1
  // FIXME: ET_DYN.
d406 2
d533 5
@


1.25
log
@Remove extraneous newlines.
@
text
@d32 1
a1688 2
  // FIXME: unlink the file if it's a symlink, even a symlink to a dir.
  //        Or do we want to follow the symlink and unlink its target? 
d1690 2
a1691 2
  if (::stat(this->name_, &s) == 0 && s.st_size != 0 && S_ISREG(s.st_mode))
    ::unlink(this->name_);
@


1.24
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d1721 1
a1721 1
    gold_error(_("%s: munmap: %s\n"), this->name_, strerror(errno));
@


1.23
log
@From Craig Silverstein: delete the output file first if it exists and
is non-empty.
@
text
@d1031 3
a1033 4
      fprintf(stderr, _("%s: %s: invalid alignment %lu for section \"%s\"\n"),
	      program_name, object->name().c_str(),
	      static_cast<unsigned long>(addralign), secname);
      gold_exit(false);
d1697 1
a1697 5
    {
      fprintf(stderr, _("%s: %s: open: %s\n"),
	      program_name, this->name_, strerror(errno));
      gold_exit(false);
    }
d1702 1
a1702 5
    {
      fprintf(stderr, _("%s: %s: lseek: %s\n"),
	      program_name, this->name_, strerror(errno));
      gold_exit(false);
    }
d1705 1
a1705 5
    {
      fprintf(stderr, _("%s: %s: write: %s\n"),
	      program_name, this->name_, strerror(errno));
      gold_exit(false);
    }
d1711 1
a1711 5
    {
      fprintf(stderr, _("%s: %s: mmap: %s\n"),
	      program_name, this->name_, strerror(errno));
      gold_exit(false);
    }
d1721 1
a1721 5
    {
      fprintf(stderr, _("%s: %s: munmap: %s\n"),
	      program_name, this->name_, strerror(errno));
      gold_exit(false);
    }
d1725 1
a1725 5
    {
      fprintf(stderr, _("%s: %s: close: %s\n"),
	      program_name, this->name_, strerror(errno));
      gold_exit(false);
    }
@


1.22
log
@Add support for local GOT offsets.
@
text
@d30 1
d1675 19
@


1.21
log
@Put size and endianness in parameters.
@
text
@d682 2
a683 1
      gold_unreachable();
d705 18
@


1.20
log
@Check section index as well as object when looking for input section.
@
text
@a80 2
    int size,
    bool big_endian,
d85 1
a85 3
  : size_(size),
    big_endian_(big_endian),
    layout_(layout),
d99 1
d116 1
a116 1
  if (this->size_ == 32)
d118 8
a125 2
      if (this->big_endian_)
	this->do_sized_write<32, true>(of);
d127 7
a133 1
	this->do_sized_write<32, false>(of);
d135 1
a135 1
  else if (this->size_ == 64)
d137 8
a144 2
      if (this->big_endian_)
	this->do_sized_write<64, true>(of);
d146 7
a152 1
	this->do_sized_write<64, false>(of);
a208 2
    int size,
    bool big_endian,
d210 1
a210 1
  : size_(size), big_endian_(big_endian), segment_list_(segment_list)
d212 1
d227 1
a227 1
  if (this->size_ == 32)
d229 8
a236 2
      if (this->big_endian_)
	this->do_sized_write<32, true>(of);
d238 2
d241 4
d246 1
a246 1
  else if (this->size_ == 64)
d248 8
a255 2
      if (this->big_endian_)
	this->do_sized_write<64, true>(of);
d257 7
a263 1
	this->do_sized_write<64, false>(of);
d292 1
a292 3
Output_file_header::Output_file_header(int size,
				       bool big_endian,
				       const Target* target,
d295 1
a295 3
  : size_(size),
    big_endian_(big_endian),
    target_(target),
d301 1
d328 1
a328 1
  if (this->size_ == 32)
d330 8
a337 2
      if (this->big_endian_)
	this->do_sized_write<32, true>(of);
d339 7
a345 1
	this->do_sized_write<32, false>(of);
d347 1
a347 1
  else if (this->size_ == 64)
d349 8
a356 2
      if (this->big_endian_)
	this->do_sized_write<64, true>(of);
d358 7
a364 1
	this->do_sized_write<64, false>(of);
d790 1
a790 1
  if (this->target_->get_size() == 32)
d792 1
a792 1
  else if (this->target_->get_size() == 64)
d807 1
a807 1
  if (this->target_->get_size() == 32)
d809 1
a809 1
  else if (this->target_->get_size() == 64)
d821 1
a821 1
  if (this->target_->get_size() == 32)
d823 8
a830 2
      if (this->target_->is_big_endian())
	this->sized_write<32, true>(of);
d832 7
a838 1
	this->sized_write<32, false>(of);
d840 1
a840 1
  else if (this->target_->get_size() == 64)
d842 8
a849 2
      if (this->target_->is_big_endian())
	this->sized_write<64, true>(of);
d851 7
a857 1
	this->sized_write<64, false>(of);
@


1.19
log
@Add licensing text to every source file.
@
text
@d842 2
a843 1
      if (this->u2_.object != object)
@


1.18
log
@Add global parameters.
@
text
@d3 20
@


1.17
log
@Use nops when doing alignment padding between code sections.
@
text
@d12 1
a229 1
				       const General_options& options,
a234 1
    options_(options),
d318 1
a318 1
  if (this->options_.is_relocatable())
d566 1
a566 3
Output_data_got<size, big_endian>::Got_entry::write(
    const General_options* options,
    unsigned char* pov) const
d580 1
a580 1
	if (gsym->final_value_is_known(options))
d639 1
a639 1
      p->write(this->options_, pov);
d1546 1
a1546 1
  int mode = this->options_.is_relocatable() ? 0666 : 0777;
@


1.16
log
@Add support for --enable-target to control which template
specializations we generate.
@
text
@d866 1
d927 25
a951 3
  off_t ssize = this->data_size();
  ssize = align_address(ssize, addralign);
  this->set_data_size(ssize + shdr.get_sh_size());
d956 1
a956 1
  if (! this->input_sections_.empty())
d961 1
a961 1
  return ssize;
d1131 10
d1532 1
a1532 1
Output_file::Output_file(const General_options& options)
d1534 1
@


1.15
log
@Add support for SHF_MERGE sections.
@
text
@d1577 1
d1585 1
d1587 1
d1595 1
d1597 1
d1605 1
d1607 1
d1615 1
d1617 1
d1620 1
d1622 1
d1625 1
d1627 1
d1630 1
d1632 1
d1635 1
d1637 1
d1640 1
d1642 1
d1645 1
d1647 1
d1650 1
d1652 1
d1655 1
d1657 1
d1660 1
d1662 1
d1665 1
d1667 1
d1670 1
d1672 1
d1675 1
d1677 1
d1680 1
d1682 1
d1685 1
d1687 1
d1690 1
d1692 1
d1695 1
d1697 1
d1700 1
d1702 1
d1705 1
d1707 1
d1710 1
d1712 1
d1715 1
a1717 1

@


1.14
log
@Can now dynamically link hello, world.
@
text
@d15 1
d794 1
a794 1
    return this->data_size_;
d796 1
a796 1
    return this->u_.posd->data_size();
d806 1
a806 1
    this->u_.object->set_section_offset(this->shndx_, off - secoff);
d808 25
a832 1
    this->u_.posd->set_address(addr, off);
d843 1
a843 1
    this->u_.posd->write(of);
d851 1
a851 1
			       elfcpp::Elf_Xword flags, bool may_add_data)
a865 1
    may_add_data_(may_add_data),
a899 2
  gold_assert(this->may_add_data_);

d912 14
d946 3
a948 1
  gold_assert(this->may_add_data_);
d950 5
d958 1
a958 1
  this->input_sections_.push_back(Input_section(posd));
d960 1
a960 1
  uint64_t addralign = posd->addralign();
d964 83
a1046 1
  posd->set_output_section(this);
d1317 2
a1318 1
// Set the addresses in a list of Output_data structures.
d1670 1
@


1.13
log
@gcc 3.2.2 portability hacks.
@
text
@d61 3
a63 2
    const Layout::Segment_list& segment_list,
    const Layout::Section_list& unattached_section_list,
d67 1
d74 2
a75 2
  for (Layout::Segment_list::const_iterator p = segment_list.begin();
       p != segment_list.end();
d79 1
a79 1
  count += unattached_section_list.size();
d142 2
a143 2
  for (Layout::Segment_list::const_iterator p = this->segment_list_.begin();
       p != this->segment_list_.end();
d146 1
a146 1
	    this->secnamepool_, v, &shndx
d149 2
a150 2
	 this->unattached_section_list_.begin();
       p != this->unattached_section_list_.end();
d155 1
a155 1
      (*p)->write_header(this->secnamepool_, &oshdr);
d377 12
d513 19
d672 1
a672 1
      val = this->u_.os->address();
d676 1
a676 1
      val = this->u_.os->data_size();
d681 2
a682 1
	Sized_symbol<size>* s = static_cast<Sized_symbol<size>*>(this->u_.sym);
d702 13
d830 1
d832 1
d843 3
a845 1
    needs_dynsym_index_(false)
d853 11
d950 2
a951 1
Output_section::write_header(const Stringpool* secnamepool,
d960 12
a971 2
  oshdr->put_sh_link(this->link_);
  oshdr->put_sh_info(this->info_);
d1321 2
a1322 1
Output_segment::write_section_headers(const Stringpool* secnamepool,
d1335 1
a1335 1
          secnamepool, &this->output_data_, v, pshndx
d1339 1
a1339 1
          secnamepool, &this->output_bss_, v, pshndx
d1346 2
a1347 1
Output_segment::write_section_headers_list(const Stringpool* secnamepool,
d1363 1
a1363 1
	  ps->write_header(secnamepool, &oshdr);
@


1.12
log
@Added a testsuite.  More support for COPY relocations.
@
text
@d628 2
a629 1
    const Stringpool* pool) const
d724 2
a725 1
      p->write<size, big_endian>(pov, this->pool_);
@


1.11
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d418 1
a418 1
      if (this->u_.gsym == NULL)
d421 1
a421 1
	index = this->u_.gsym->dynsym_index();
d423 1
a423 1
	index = this->u_.gsym->symtab_index();
d428 1
a428 1
	index = this->u_.os->dynsym_index();
d430 1
a430 1
	index = this->u_.os->symtab_index();
d442 1
a442 1
	index = this->u_.object->symtab_index(this->local_sym_index_);
d459 10
a468 2
  if (this->od_ != NULL)
    address += this->od_->address();
@


1.10
log
@Snapshot.  Includes first cut at output relocation sections.
@
text
@d20 4
d52 1
a52 1
    abort();
d62 1
a62 1
    const Layout::Section_list& section_list,
d67 1
a67 1
    section_list_(section_list),
d77 1
a77 1
  count += section_list.size();
d85 1
a85 1
    abort();
d110 1
a110 1
    abort();
d146 3
a148 2
  for (Layout::Section_list::const_iterator p = this->section_list_.begin();
       p != this->section_list_.end();
d151 1
a151 1
      assert(shndx == (*p)->out_shndx());
d175 1
a175 1
    abort();
d198 1
a198 1
    abort();
d245 1
a245 1
    abort();
d280 1
a280 1
    abort();
d289 1
a289 1
  assert(this->offset() == 0);
d306 1
a306 1
    abort();
d360 9
a368 1
Output_data_const::do_write(Output_file* output)
d370 1
a370 1
  output->write(this->offset(), data_.data(), data_.size());
d378 1
a378 1
  assert(this->output_section_ != NULL);
d382 20
d415 1
a415 1
      abort();
d439 1
a439 1
	  abort();
d445 1
a445 1
  assert(index != -1U);
d458 4
a461 1
  wr->put_r_offset(this->address_);
d511 1
a511 1
  assert(pov - oview == oview_size);
d525 3
a527 2
Output_data_got<size, big_endian>::Got_entry::write(unsigned char* pov)
    const
d541 1
a541 1
	if (gsym->is_resolved_locally())
d558 1
a558 1
      abort();
d561 1
a561 2
  Valtype* povv = reinterpret_cast<Valtype*>(pov);
  elfcpp::Swap<size, big_endian>::writeval(povv, val);
d600 1
a600 1
      p->write(pov);
d604 1
a604 1
  assert(pov - oview == oview_size);
d612 115
d782 3
a784 1
    may_add_data_(may_add_data)
d804 1
a804 1
  assert(this->may_add_data_);
d838 1
a838 1
  assert(this->may_add_data_);
a905 16
// Output_section_strtab methods.

Output_section_strtab::Output_section_strtab(const char* name,
					     Stringpool* contents)
  : Output_section(name, elfcpp::SHT_STRTAB, 0, false),
    contents_(contents)
{
  this->set_data_size(contents->get_strtab_size());
}

void
Output_section_strtab::do_write(Output_file* of)
{
  this->contents_->write(of, this->offset());
}

d930 2
a931 2
  assert((os->flags() & elfcpp::SHF_ALLOC) != 0);
  assert(!this->is_align_known_);
d957 1
a957 1
      Layout::Data_list::iterator p = pdl->end();
d982 1
a982 1
      Layout::Data_list::iterator p = pdl->end();
d1028 1
a1028 1
  assert(!this->is_align_known_);
d1082 1
a1082 1
  assert(this->type_ == elfcpp::PT_LOAD);
d1151 1
a1151 1
  assert(this->type_ != elfcpp::PT_LOAD);
d1276 1
a1276 1
	  assert(*pshndx == ps->out_shndx());
@


1.9
log
@More dynamic object support, initial scripting support.
@
text
@d369 114
d556 1
a556 1
  const off_t oview_size = this->entries_.size() * add;
d568 2
d627 2
d685 2
d689 1
d691 1
d695 1
a752 8
// Output_section_symtab methods.

Output_section_symtab::Output_section_symtab(const char* name, off_t size)
  : Output_section(name, elfcpp::SHT_SYMTAB, 0, false)
{
  this->set_data_size(size);
}

d1260 48
@


1.8
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@a50 8
// Output_data_const methods.

void
Output_data_const::do_write(Output_file* output)
{
  output->write(this->offset(), data_.data(), data_.size());
}

d352 18
a369 1
// Output_section_got::Got_entry methods.
d375 1
a375 1
Output_section_got<size, big_endian>::Got_entry::write(unsigned char* pov)
d414 5
a418 1
// Output_section_data methods.
d420 3
a422 2
unsigned int
Output_section_data::do_out_shndx() const
d424 7
a430 2
  assert(this->output_section_ != NULL);
  return this->output_section_->out_shndx();
a432 2
// Output_section_got methods.

d437 1
a437 1
Output_section_got<size, big_endian>::do_write(Output_file* of)
d675 2
a676 1
				   elfcpp::Elf_Word seg_flags)
d711 1
d752 1
d760 2
a761 2
      // There are no TLS sections yet; put this one at the end of the
      // section list.
d764 4
a767 1
  pdl->push_back(os);
d1147 1
a1147 2
void
Output_section_got<32, false>::do_write(Output_file* of);
d1150 1
a1150 2
void
Output_section_got<32, true>::do_write(Output_file* of);
d1153 1
a1153 2
void
Output_section_got<64, false>::do_write(Output_file* of);
d1156 1
a1156 2
void
Output_section_got<64, true>::do_write(Output_file* of);
@


1.7
log
@gcc 3.2.2 portability hacks.
@
text
@d402 1
a402 1
  Swap<size, big_endian>::writeval(povv, val);
d512 1
a512 1
Output_section::add_input_section(Object* object, unsigned int shndx,
d1094 1
a1094 1
    Object* object,
d1102 1
a1102 1
    Object* object,
d1110 1
a1110 1
    Object* object,
d1118 1
a1118 1
    Object* object,
@


1.6
log
@Can now do a full static link of hello, world in C or C++
@
text
@d147 1
a147 1
    v = (*p)->write_section_headers SELECT_SIZE_ENDIAN_NAME (
d336 1
a336 1
      ssym = this->symtab_->get_sized_symbol SELECT_SIZE_NAME (
d974 8
a981 6
  v = this->write_section_headers_list SELECT_SIZE_ENDIAN_NAME (
	secnamepool, &this->output_data_, v, pshndx
	SELECT_SIZE_ENDIAN(size, big_endian));
  v = this->write_section_headers_list SELECT_SIZE_ENDIAN_NAME (
	secnamepool, &this->output_bss_, v, pshndx
	SELECT_SIZE_ENDIAN(size, big_endian));
@


1.5
log
@Clean up HAVE_MEMBER_TEMPLATE_SPECIFICATIONS somewhat.
@
text
@d13 2
d79 2
a80 1
    count += (*p)->output_section_count();
d143 1
d148 2
a149 1
      this->secnamepool_, v SELECT_SIZE_ENDIAN(size, big_endian));
d154 1
d158 1
d328 1
d355 1
a355 1
  oehdr.put_e_shstrndx(this->shstrtab_->shndx());
d360 120
d485 1
a485 1
			       elfcpp::Elf_Xword flags, unsigned int shndx)
d493 4
a496 1
    shndx_(shndx)
d504 3
a506 1
// Add an input section to an Output_section.  We don't keep track of
d512 2
a513 1
Output_section::add_input_section(Object* object, const char* secname,
d516 2
d531 2
a532 1
  ssize = (ssize + addralign - 1) &~ (addralign - 1);
d534 7
a540 7
  // SHF_TLS/SHT_NOBITS sections are handled specially: they are
  // treated as having no size and taking up no space.  We only use
  // the real size when setting the pt_memsz field of the PT_TLS
  // segment.
  if ((this->flags_ & elfcpp::SHF_TLS) == 0
      || this->type_ != elfcpp::SHT_NOBITS)
    this->set_data_size(ssize + shdr.get_sh_size());
d545 36
d600 13
d615 2
a616 3
Output_section_symtab::Output_section_symtab(const char* name, off_t size,
					     unsigned int shndx)
  : Output_section(name, elfcpp::SHT_SYMTAB, 0, shndx)
d624 2
a625 3
					     Stringpool* contents,
					     unsigned int shndx)
  : Output_section(name, elfcpp::SHT_STRTAB, 0, shndx),
d649 2
a650 1
    flags_(flags)
d661 1
d663 1
a663 1
  // Update the segment flags and alignment.
a664 3
  uint64_t addralign = os->addralign();
  if (addralign > this->align_)
    this->align_ = addralign;
d710 1
d715 17
a731 2
	  if ((*p)->is_section_flag_set(elfcpp::SHF_TLS)
	      && (nobits || !(*p)->is_section_type(elfcpp::SHT_NOBITS)))
d739 3
d753 1
a753 4
  uint64_t addralign = od->addralign();
  if (addralign > this->align_)
    this->align_ = addralign;

d758 1
a758 1
// We keep this up to date as we add Output_sections and Output_data.
d761 1
a761 1
Output_segment::max_data_align() const
d763 15
d781 17
d799 3
a801 2
// address and *POFF is the file offset.  Return the address of the
// immediately following segment.  Update *POFF.
d804 2
a805 1
Output_segment::set_section_addresses(uint64_t addr, off_t* poff)
d815 4
a818 1
  addr = this->set_section_list_addresses(&this->output_data_, addr, poff);
d824 1
a824 1
						  poff);
d838 2
a839 1
					   uint64_t addr, off_t* poff)
d841 1
a841 1
  off_t off = *poff;
d843 1
d848 16
a863 8
      uint64_t addralign = (*p)->addralign();
      addr = (addr + addralign - 1) & ~ (addralign - 1);
      off = (off + addralign - 1) & ~ (addralign - 1);
      (*p)->set_address(addr, off);

      uint64_t size = (*p)->data_size();
      addr += size;
      off += size;
d867 1
a867 1
  return addr;
a915 2

  // this->align_ was set as we added items.
d947 1
a947 1
Output_segment::write_header(elfcpp::Phdr_write<size, big_endian>* ophdr) const
d956 1
a956 1
  ophdr->put_p_align(this->align_);
d964 2
a965 1
				      unsigned char* v
d968 6
d975 2
a976 1
    secnamepool, &this->output_data_, v SELECT_SIZE_ENDIAN(size, big_endian));
d978 2
a979 1
    secnamepool, &this->output_bss_, v SELECT_SIZE_ENDIAN(size, big_endian));
d987 2
a988 1
					   unsigned char* v
d999 1
d1003 1
d1093 1
d1101 1
d1109 1
d1117 1
d1120 16
@


1.4
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d143 2
a144 1
    v = (*p)->write_section_headers<size, big_endian>(this->secnamepool_, v);
d328 2
a329 1
      ssym = this->symtab_->get_sized_symbol<size>(sym);
d720 2
a721 1
				      unsigned char* v) const
d723 4
a726 6
  v = this->write_section_headers_list<size, big_endian>(secnamepool,
							 &this->output_data_,
							 v);
  v = this->write_section_headers_list<size, big_endian>(secnamepool,
							 &this->output_bss_,
							 v);
d734 2
a735 1
					   unsigned char* v) const
d744 1
a744 1
	  Output_section* ps = static_cast<const Output_section*>(*p);
@


1.3
log
@Finished layout code.
@
text
@d6 4
d62 1
d64 2
a65 1
    const Layout::Section_list& section_list)
d67 1
d69 2
a70 1
    section_list_(section_list)
d72 2
a73 2
  // Count all the sections.
  off_t count = 0;
d91 2
d94 1
a94 1
Output_section_headers::do_write(Output_file*)
d96 58
a153 2
  // FIXME: Unimplemented.
  abort();
d158 17
d176 1
a176 1
Output_segment_headers::do_write(Output_file*)
d178 37
a214 2
  // FIXME: Unimplemented.
  abort();
d220 1
d226 1
d230 1
a230 1
    program_header_(osh),
d234 9
d258 25
a282 1
Output_file_header::do_write(Output_file*)
d284 64
a347 2
  // FIXME: Unimplemented.
  abort();
d355 1
a355 1
			       elfcpp::Elf_Xword flags)
d362 2
a363 1
    flags_(flags)
d403 20
a422 1
  return size;
d427 3
a429 2
Output_section_symtab::Output_section_symtab(const char* name, off_t size)
  : Output_section(name, elfcpp::SHT_SYMTAB, 0)
d437 3
a439 2
					     Stringpool* contents)
  : Output_section(name, elfcpp::SHT_STRTAB, 0),
d442 1
d446 1
a446 1
Output_section_strtab::do_write(Output_file*)
d448 1
a448 2
  // FIXME: Unimplemented.
  abort();
d500 1
a500 1
  if (os->type() == elfcpp::SHT_NOTE)
d521 1
a521 1
  if ((os->flags() & elfcpp::SHF_TLS) != 0)
d585 2
a586 1
  return this->set_section_list_addresses(&this->output_bss_, addr, poff);
d592 2
d697 54
d753 55
d809 1
a809 1
Output_file::write(off_t, const void*, off_t)
d811 15
a825 1
  abort();
@


1.2
log
@More section layout code.
@
text
@d6 1
d20 25
d48 37
a84 1
Output_data_const::write(Output_file* output, off_t off)
d86 2
a87 1
  output->write(off, data_.data(), data_.size());
d93 37
a129 1
Output_segment_headers::write(Output_file*, off_t)
a141 1
    addr_(0),
a143 1
    offset_(0),
d176 1
a176 1
  off_t ssize = this->get_size();
d179 7
a185 1
  this->set_size(ssize + shdr.get_sh_size());
d190 24
d218 1
d233 2
a234 1
Output_segment::add_output_section(Output_section* os)
d236 13
a248 2
  // Update the segment flags.
  this->flags_ |= os->flags() & (elfcpp::PF_R | elfcpp::PF_W | elfcpp::PF_X);
d265 2
a266 3
      for (Layout::Data_list::iterator p = this->output_data_.begin();
	   p != this->output_data_.end();
	   ++p)
d268 1
d272 1
a272 1
	      this->output_data_.insert(p, os);
d276 1
d280 4
a283 1
  // SHF_TLS sections.
d286 4
a289 3
      for (Layout::Data_list::iterator p = this->output_data_.begin();
	   p != this->output_data_.end();
	   ++p)
d291 3
a293 1
	  if ((*p)->is_section_flag_set(elfcpp::SHF_TLS))
d296 1
a296 1
	      this->output_data_.insert(p, os);
d300 118
d420 35
a454 1
  this->output_data_.push_back(os);
@


1.1
log
@New drop, with first cut of section layout code.
@
text
@d27 9
a46 1
    size_(0),
d54 4
a74 1
  this->size_ = (this->size_ + addralign - 1) &~ (addralign - 1);
d79 4
a82 2
  off_t ret = this->size_;
  this->size_ += shdr.get_sh_size();
d84 1
a84 1
  return ret;
d90 1
a90 1
  : output_sections_(),
d107 3
d118 5
d125 19
a143 2
      for (Section_list::iterator p = this->output_sections_.begin();
	   p != this->output_sections_.end();
d146 1
a146 1
	  if ((*p)->type() == elfcpp::SHT_NOTE)
d149 1
a149 1
	      this->output_sections_.insert(p, os);
d155 1
a155 1
  this->output_sections_.push_back(os);
@

