head	1.77;
access;
symbols
	binutils-2_24-branch:1.77.0.2
	binutils-2_24-branchpoint:1.77
	binutils-2_21_1:1.68.2.1
	binutils-2_23_2:1.75
	binutils-2_23_1:1.75
	binutils-2_23:1.75
	binutils-2_23-branch:1.75.0.2
	binutils-2_23-branchpoint:1.75
	binutils-2_22_branch:1.74.0.4
	binutils-2_22:1.74
	binutils-2_22-branch:1.74.0.2
	binutils-2_22-branchpoint:1.74
	binutils-2_21:1.68
	binutils-2_21-branch:1.68.0.2
	binutils-2_21-branchpoint:1.68
	binutils-2_20_1:1.52.2.1
	binutils-2_20:1.52.2.1
	binutils-arc-20081103-branch:1.46.0.4
	binutils-arc-20081103-branchpoint:1.46
	binutils-2_20-branch:1.52.0.2
	binutils-2_20-branchpoint:1.52
	dje-cgen-play1-branch:1.51.0.2
	dje-cgen-play1-branchpoint:1.51
	arc-20081103-branch:1.46.0.2
	arc-20081103-branchpoint:1.46
	binutils-2_19_1:1.43
	binutils-2_19:1.43
	binutils-2_19-branch:1.43.0.2
	binutils-2_19-branchpoint:1.43
	binutils_latest_snapshot:1.77
	added-to-binutils:1.39;
locks; strict;
comment	@// @;


1.77
date	2012.12.10.17.38.42;	author roland;	state Exp;
branches;
next	1.76;

1.76
date	2012.10.23.21.29.20;	author ccoutant;	state Exp;
branches;
next	1.75;

1.75
date	2011.10.17.23.36.43;	author ccoutant;	state Exp;
branches;
next	1.74;

1.74
date	2011.05.25.06.15.28;	author ian;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2011.04.12.18.06.16;	author ian;	state Exp;
branches;
next	1.72;

1.72
date	2011.04.12.00.44.47;	author ccoutant;	state Exp;
branches;
next	1.71;

1.71
date	2011.03.10.01.10.19;	author ian;	state Exp;
branches;
next	1.70;

1.70
date	2011.03.09.01.50.33;	author ian;	state Exp;
branches;
next	1.69;

1.69
date	2010.12.14.21.33.26;	author rwild;	state Exp;
branches;
next	1.68;

1.68
date	2010.10.12.15.30.24;	author rsandifo;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2010.07.13.14.59.02;	author espindola;	state Exp;
branches;
next	1.65;

1.65
date	2010.06.21.21.21.24;	author espindola;	state Exp;
branches;
next	1.64;

1.64
date	2010.06.15.16.54.26;	author ian;	state Exp;
branches;
next	1.63;

1.63
date	2010.03.24.01.27.57;	author ccoutant;	state Exp;
branches;
next	1.62;

1.62
date	2010.03.10.17.37.11;	author ccoutant;	state Exp;
branches;
next	1.61;

1.61
date	2010.02.24.20.50.59;	author dougkwan;	state Exp;
branches;
next	1.60;

1.60
date	2010.02.12.03.23.25;	author ian;	state Exp;
branches;
next	1.59;

1.59
date	2009.12.14.19.53.04;	author ian;	state Exp;
branches;
next	1.58;

1.58
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2009.11.06.15.47.06;	author ian;	state Exp;
branches;
next	1.56;

1.56
date	2009.10.28.00.42.34;	author ian;	state Exp;
branches;
next	1.55;

1.55
date	2009.10.10.07.39.04;	author cgd;	state Exp;
branches;
next	1.54;

1.54
date	2009.10.09.23.20.44;	author ian;	state Exp;
branches;
next	1.53;

1.53
date	2009.09.30.22.21.13;	author ian;	state Exp;
branches;
next	1.52;

1.52
date	2009.07.06.23.11.21;	author ian;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2009.06.23.18.10.41;	author dougkwan;	state Exp;
branches;
next	1.50;

1.50
date	2009.03.14.05.56.46;	author ian;	state Exp;
branches;
next	1.49;

1.49
date	2009.03.13.21.30.06;	author ian;	state Exp;
branches;
next	1.48;

1.48
date	2009.02.28.04.39.57;	author ian;	state Exp;
branches;
next	1.47;

1.47
date	2009.01.15.01.29.25;	author ccoutant;	state Exp;
branches;
next	1.46;

1.46
date	2008.09.19.22.54.57;	author ccoutant;	state Exp;
branches;
next	1.45;

1.45
date	2008.09.16.17.17.22;	author ian;	state Exp;
branches;
next	1.44;

1.44
date	2008.09.10.17.56.02;	author ccoutant;	state Exp;
branches;
next	1.43;

1.43
date	2008.08.21.00.30.13;	author csilvers;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.25.04.25.49;	author ian;	state Exp;
branches;
next	1.41;

1.41
date	2008.06.25.17.10.08;	author ccoutant;	state Exp;
branches;
next	1.40;

1.40
date	2008.04.02.20.58.21;	author ian;	state Exp;
branches;
next	1.39;

1.39
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.38;

1.38
date	2008.03.13.01.46.17;	author iant;	state Exp;
branches;
next	1.37;

1.37
date	2008.03.04.18.21.43;	author iant;	state Exp;
branches;
next	1.36;

1.36
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.35;

1.35
date	2008.02.26.21.45.30;	author iant;	state Exp;
branches;
next	1.34;

1.34
date	2008.02.13.02.44.50;	author iant;	state Exp;
branches;
next	1.33;

1.33
date	2008.02.08.07.06.57;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2008.02.07.01.51.25;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2008.01.18.23.26.48;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2008.01.02.23.55.37;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2008.01.02.23.48.49;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2007.12.21.23.08.25;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2007.12.20.21.26.17;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.12.20.21.21.24;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.12.19.01.18.41;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.12.14.19.00.21;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.14.18.50.01;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.12.14.18.22.06;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.12.10.22.55.31;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.22.18.04.43;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.14.06.57.58;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.14.06.49.13;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.12.05.51.25;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.09.17.46.14;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.04.05.49.04;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.02.21.24.41;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.25.23.08.30;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.25.17.50.26;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.25.06.43.17;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.25.05.16.35;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.25.00.27.29;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.30.23.52.50;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.03.18.26.10;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.29.19.58.16;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.04.23.10.59;	author iant;	state Exp;
branches;
next	;

1.74.2.1
date	2011.12.19.21.14.39;	author ian;	state Exp;
branches;
next	;

1.68.2.1
date	2011.03.09.01.54.55;	author ian;	state Exp;
branches;
next	;

1.52.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	;


desc
@@


1.77
log
@gold/
	* testsuite/binary_unittest.cc (read_all): New function.
	(Sized_binary_test): Use it instead of ::read.
	* fileread.cc (do_read): Don't assume pread always reads the whole
	amount in a single call.
@
text
@// fileread.cc -- read files for gold

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cstring>
#include <cerrno>
#include <climits>
#include <fcntl.h>
#include <unistd.h>

#ifdef HAVE_SYS_MMAN_H
#include <sys/mman.h>
#endif

#ifdef HAVE_READV
#include <sys/uio.h>
#endif

#include <sys/stat.h>
#include "filenames.h"

#include "debug.h"
#include "parameters.h"
#include "options.h"
#include "dirsearch.h"
#include "target.h"
#include "binary.h"
#include "descriptors.h"
#include "gold-threads.h"
#include "fileread.h"

// For systems without mmap support.
#ifndef HAVE_MMAP
# define mmap gold_mmap
# define munmap gold_munmap
# ifndef MAP_FAILED
#  define MAP_FAILED (reinterpret_cast<void*>(-1))
# endif
# ifndef PROT_READ
#  define PROT_READ 0
# endif
# ifndef MAP_PRIVATE
#  define MAP_PRIVATE 0
# endif

# ifndef ENOSYS
#  define ENOSYS EINVAL
# endif

static void *
gold_mmap(void *, size_t, int, int, int, off_t)
{
  errno = ENOSYS;
  return MAP_FAILED;
}

static int
gold_munmap(void *, size_t)
{
  errno = ENOSYS;
  return -1;
}

#endif

#ifndef HAVE_READV
struct iovec { void* iov_base; size_t iov_len; };
ssize_t
readv(int, const iovec*, int)
{
  gold_unreachable();
}
#endif

namespace gold
{

// Get the last modified time of an unopened file.

bool
get_mtime(const char* filename, Timespec* mtime)
{
  struct stat file_stat;

  if (stat(filename, &file_stat) < 0)
    return false;
#ifdef HAVE_STAT_ST_MTIM
  mtime->seconds = file_stat.st_mtim.tv_sec;
  mtime->nanoseconds = file_stat.st_mtim.tv_nsec;
#else
  mtime->seconds = file_stat.st_mtime;
  mtime->nanoseconds = 0;
#endif
  return true;
}

// Class File_read.

// A lock for the File_read static variables.
static Lock* file_counts_lock = NULL;
static Initialize_lock file_counts_initialize_lock(&file_counts_lock);

// The File_read static variables.
unsigned long long File_read::total_mapped_bytes;
unsigned long long File_read::current_mapped_bytes;
unsigned long long File_read::maximum_mapped_bytes;

// Class File_read::View.

File_read::View::~View()
{
  gold_assert(!this->is_locked());
  switch (this->data_ownership_)
    {
    case DATA_ALLOCATED_ARRAY:
      free(const_cast<unsigned char*>(this->data_));
      break;
    case DATA_MMAPPED:
      if (::munmap(const_cast<unsigned char*>(this->data_), this->size_) != 0)
	gold_warning(_("munmap failed: %s"), strerror(errno));
      if (!parameters->options_valid() || parameters->options().stats())
	{
	  file_counts_initialize_lock.initialize();
	  Hold_optional_lock hl(file_counts_lock);
	  File_read::current_mapped_bytes -= this->size_;
	}
      break;
    case DATA_NOT_OWNED:
      break;
    default:
      gold_unreachable();
    }
}

void
File_read::View::lock()
{
  ++this->lock_count_;
}

void
File_read::View::unlock()
{
  gold_assert(this->lock_count_ > 0);
  --this->lock_count_;
}

bool
File_read::View::is_locked()
{
  return this->lock_count_ > 0;
}

// Class File_read.

File_read::~File_read()
{
  gold_assert(this->token_.is_writable());
  if (this->is_descriptor_opened_)
    {
      release_descriptor(this->descriptor_, true);
      this->descriptor_ = -1;
      this->is_descriptor_opened_ = false;
    }
  this->name_.clear();
  this->clear_views(CLEAR_VIEWS_ALL);
}

// Open the file.

bool
File_read::open(const Task* task, const std::string& name)
{
  gold_assert(this->token_.is_writable()
	      && this->descriptor_ < 0
	      && !this->is_descriptor_opened_
	      && this->name_.empty());
  this->name_ = name;

  this->descriptor_ = open_descriptor(-1, this->name_.c_str(),
				      O_RDONLY);

  if (this->descriptor_ >= 0)
    {
      this->is_descriptor_opened_ = true;
      struct stat s;
      if (::fstat(this->descriptor_, &s) < 0)
	gold_error(_("%s: fstat failed: %s"),
		   this->name_.c_str(), strerror(errno));
      this->size_ = s.st_size;
      gold_debug(DEBUG_FILES, "Attempt to open %s succeeded",
		 this->name_.c_str());
      this->token_.add_writer(task);
    }

  return this->descriptor_ >= 0;
}

// Open the file with the contents in memory.

bool
File_read::open(const Task* task, const std::string& name,
		const unsigned char* contents, off_t size)
{
  gold_assert(this->token_.is_writable()
	      && this->descriptor_ < 0
	      && !this->is_descriptor_opened_
	      && this->name_.empty());
  this->name_ = name;
  this->whole_file_view_ = new View(0, size, contents, 0, false,
				    View::DATA_NOT_OWNED);
  this->add_view(this->whole_file_view_);
  this->size_ = size;
  this->token_.add_writer(task);
  return true;
}

// Reopen a descriptor if necessary.

void
File_read::reopen_descriptor()
{
  if (!this->is_descriptor_opened_)
    {
      this->descriptor_ = open_descriptor(this->descriptor_,
					  this->name_.c_str(),
					  O_RDONLY);
      if (this->descriptor_ < 0)
	gold_fatal(_("could not reopen file %s"), this->name_.c_str());
      this->is_descriptor_opened_ = true;
    }
}

// Release the file.  This is called when we are done with the file in
// a Task.

void
File_read::release()
{
  gold_assert(this->is_locked());

  if (!parameters->options_valid() || parameters->options().stats())
    {
      file_counts_initialize_lock.initialize();
      Hold_optional_lock hl(file_counts_lock);
      File_read::total_mapped_bytes += this->mapped_bytes_;
      File_read::current_mapped_bytes += this->mapped_bytes_;
      if (File_read::current_mapped_bytes > File_read::maximum_mapped_bytes)
	File_read::maximum_mapped_bytes = File_read::current_mapped_bytes;
    }

  this->mapped_bytes_ = 0;

  // Only clear views if there is only one attached object.  Otherwise
  // we waste time trying to clear cached archive views.  Similarly
  // for releasing the descriptor.
  if (this->object_count_ <= 1)
    {
      this->clear_views(CLEAR_VIEWS_NORMAL);
      if (this->is_descriptor_opened_)
	{
	  release_descriptor(this->descriptor_, false);
	  this->is_descriptor_opened_ = false;
	}
    }

  this->released_ = true;
}

// Lock the file.

void
File_read::lock(const Task* task)
{
  gold_assert(this->released_);
  this->token_.add_writer(task);
  this->released_ = false;
}

// Unlock the file.

void
File_read::unlock(const Task* task)
{
  this->release();
  this->token_.remove_writer(task);
}

// Return whether the file is locked.

bool
File_read::is_locked() const
{
  if (!this->token_.is_writable())
    return true;
  // The file is not locked, so it should have been released.
  gold_assert(this->released_);
  return false;
}

// See if we have a view which covers the file starting at START for
// SIZE bytes.  Return a pointer to the View if found, NULL if not.
// If BYTESHIFT is not -1U, the returned View must have the specified
// byte shift; otherwise, it may have any byte shift.  If VSHIFTED is
// not NULL, this sets *VSHIFTED to a view which would have worked if
// not for the requested BYTESHIFT.

inline File_read::View*
File_read::find_view(off_t start, section_size_type size,
		     unsigned int byteshift, File_read::View** vshifted) const
{
  gold_assert(start <= this->size_
	      && (static_cast<unsigned long long>(size)
		  <= static_cast<unsigned long long>(this->size_ - start)));

  if (vshifted != NULL)
    *vshifted = NULL;

  // If we have the whole file mmapped, and the alignment is right,
  // we can return it.
  if (this->whole_file_view_)
    if (byteshift == -1U || byteshift == 0)
      return this->whole_file_view_;

  off_t page = File_read::page_offset(start);

  unsigned int bszero = 0;
  Views::const_iterator p = this->views_.upper_bound(std::make_pair(page - 1,
								    bszero));

  while (p != this->views_.end() && p->first.first <= page)
    {
      if (p->second->start() <= start
	  && (p->second->start() + static_cast<off_t>(p->second->size())
	      >= start + static_cast<off_t>(size)))
	{
	  if (byteshift == -1U || byteshift == p->second->byteshift())
	    {
	      p->second->set_accessed();
	      return p->second;
	    }

	  if (vshifted != NULL && *vshifted == NULL)
	    *vshifted = p->second;
	}

      ++p;
    }

  return NULL;
}

// Read SIZE bytes from the file starting at offset START.  Read into
// the buffer at P.

void
File_read::do_read(off_t start, section_size_type size, void* p)
{
  ssize_t bytes;
  if (this->whole_file_view_ != NULL)
    {
      bytes = this->size_ - start;
      if (static_cast<section_size_type>(bytes) >= size)
	{
	  memcpy(p, this->whole_file_view_->data() + start, size);
	  return;
	}
    }
  else
    {
      this->reopen_descriptor();

      char *read_ptr = static_cast<char *>(p);
      off_t read_pos = start;
      size_t to_read = size;
      do
	{
	  bytes = ::pread(this->descriptor_, read_ptr, to_read, read_pos);
	  if (bytes < 0)
	    gold_fatal(_("%s: pread failed: %s"),
		       this->filename().c_str(), strerror(errno));

	  read_pos += bytes;
	  read_ptr += bytes;
	  to_read -= bytes;
	  if (to_read == 0)
	    return;
	}
      while (bytes > 0);

      bytes = size - to_read;
    }

  gold_fatal(_("%s: file too short: read only %lld of %lld bytes at %lld"),
	     this->filename().c_str(),
	     static_cast<long long>(bytes),
	     static_cast<long long>(size),
	     static_cast<long long>(start));
}

// Read data from the file.

void
File_read::read(off_t start, section_size_type size, void* p)
{
  const File_read::View* pv = this->find_view(start, size, -1U, NULL);
  if (pv != NULL)
    {
      memcpy(p, pv->data() + (start - pv->start() + pv->byteshift()), size);
      return;
    }

  this->do_read(start, size, p);
}

// Add a new view.  There may already be an existing view at this
// offset.  If there is, the new view will be larger, and should
// replace the old view.

void
File_read::add_view(File_read::View* v)
{
  std::pair<Views::iterator, bool> ins =
    this->views_.insert(std::make_pair(std::make_pair(v->start(),
						      v->byteshift()),
				       v));
  if (ins.second)
    return;

  // There was an existing view at this offset.  It must not be large
  // enough.  We can't delete it here, since something might be using
  // it; we put it on a list to be deleted when the file is unlocked.
  File_read::View* vold = ins.first->second;
  gold_assert(vold->size() < v->size());
  if (vold->should_cache())
    {
      v->set_cache();
      vold->clear_cache();
    }
  this->saved_views_.push_back(vold);

  ins.first->second = v;
}

// Make a new view with a specified byteshift, reading the data from
// the file.

File_read::View*
File_read::make_view(off_t start, section_size_type size,
		     unsigned int byteshift, bool cache)
{
  gold_assert(size > 0);
  gold_assert(start <= this->size_
	      && (static_cast<unsigned long long>(size)
		  <= static_cast<unsigned long long>(this->size_ - start)));

  off_t poff = File_read::page_offset(start);

  section_size_type psize = File_read::pages(size + (start - poff));

  if (poff + static_cast<off_t>(psize) >= this->size_)
    {
      psize = this->size_ - poff;
      gold_assert(psize >= size);
    }

  void* p;
  View::Data_ownership ownership;
  if (byteshift != 0)
    {
      p = malloc(psize + byteshift);
      if (p == NULL)
	gold_nomem();
      memset(p, 0, byteshift);
      this->do_read(poff, psize, static_cast<unsigned char*>(p) + byteshift);
      ownership = View::DATA_ALLOCATED_ARRAY;
    }
  else
    {
      this->reopen_descriptor();
      p = ::mmap(NULL, psize, PROT_READ, MAP_PRIVATE, this->descriptor_, poff);
      if (p != MAP_FAILED)
	{
	  ownership = View::DATA_MMAPPED;
	  this->mapped_bytes_ += psize;
	}
      else
	{
	  p = malloc(psize);
	  if (p == NULL)
	    gold_nomem();
	  this->do_read(poff, psize, p);
	  ownership = View::DATA_ALLOCATED_ARRAY;
	}
    }

  const unsigned char* pbytes = static_cast<const unsigned char*>(p);
  File_read::View* v = new File_read::View(poff, psize, pbytes, byteshift,
					   cache, ownership);

  this->add_view(v);

  return v;
}

// Find a View or make a new one, shifted as required by the file
// offset OFFSET and ALIGNED.

File_read::View*
File_read::find_or_make_view(off_t offset, off_t start,
			     section_size_type size, bool aligned, bool cache)
{
  // Check that start and end of the view are within the file.
  if (start > this->size_
      || (static_cast<unsigned long long>(size)
	  > static_cast<unsigned long long>(this->size_ - start)))
    gold_fatal(_("%s: attempt to map %lld bytes at offset %lld exceeds "
		 "size of file; the file may be corrupt"),
		   this->filename().c_str(),
		   static_cast<long long>(size),
		   static_cast<long long>(start));

  unsigned int byteshift;
  if (offset == 0)
    byteshift = 0;
  else
    {
      unsigned int target_size = (!parameters->target_valid()
				  ? 64
				  : parameters->target().get_size());
      byteshift = offset & ((target_size / 8) - 1);

      // Set BYTESHIFT to the number of dummy bytes which must be
      // inserted before the data in order for this data to be
      // aligned.
      if (byteshift != 0)
	byteshift = (target_size / 8) - byteshift;
    }

  // If --map-whole-files is set, make sure we have a
  // whole file view.  Options may not yet be ready, e.g.,
  // when reading a version script.  We then default to
  // --no-map-whole-files.
  if (this->whole_file_view_ == NULL
      && parameters->options_valid()
      && parameters->options().map_whole_files())
    this->whole_file_view_ = this->make_view(0, this->size_, 0, cache);

  // Try to find a View with the required BYTESHIFT.
  File_read::View* vshifted;
  File_read::View* v = this->find_view(offset + start, size,
				       aligned ? byteshift : -1U,
				       &vshifted);
  if (v != NULL)
    {
      if (cache)
	v->set_cache();
      return v;
    }

  // If VSHIFTED is not NULL, then it has the data we need, but with
  // the wrong byteshift.
  v = vshifted;
  if (v != NULL)
    {
      gold_assert(aligned);

      unsigned char* pbytes;
      pbytes = static_cast<unsigned char*>(malloc(v->size() + byteshift));
      if (pbytes == NULL)
	gold_nomem();
      memset(pbytes, 0, byteshift);
      memcpy(pbytes + byteshift, v->data() + v->byteshift(), v->size());

      File_read::View* shifted_view =
	  new File_read::View(v->start(), v->size(), pbytes, byteshift,
			      cache, View::DATA_ALLOCATED_ARRAY);

      this->add_view(shifted_view);
      return shifted_view;
    }

  // Make a new view.  If we don't need an aligned view, use a
  // byteshift of 0, so that we can use mmap.
  return this->make_view(offset + start, size,
			 aligned ? byteshift : 0,
			 cache);
}

// Get a view into the file.

const unsigned char*
File_read::get_view(off_t offset, off_t start, section_size_type size,
		    bool aligned, bool cache)
{
  File_read::View* pv = this->find_or_make_view(offset, start, size,
						aligned, cache);
  return pv->data() + (offset + start - pv->start() + pv->byteshift());
}

File_view*
File_read::get_lasting_view(off_t offset, off_t start, section_size_type size,
			    bool aligned, bool cache)
{
  File_read::View* pv = this->find_or_make_view(offset, start, size,
						aligned, cache);
  pv->lock();
  return new File_view(*this, pv,
		       (pv->data()
			+ (offset + start - pv->start() + pv->byteshift())));
}

// Use readv to read COUNT entries from RM starting at START.  BASE
// must be added to all file offsets in RM.

void
File_read::do_readv(off_t base, const Read_multiple& rm, size_t start,
		    size_t count)
{
  unsigned char discard[File_read::page_size];
  iovec iov[File_read::max_readv_entries * 2];
  size_t iov_index = 0;

  off_t first_offset = rm[start].file_offset;
  off_t last_offset = first_offset;
  ssize_t want = 0;
  for (size_t i = 0; i < count; ++i)
    {
      const Read_multiple_entry& i_entry(rm[start + i]);

      if (i_entry.file_offset > last_offset)
	{
	  size_t skip = i_entry.file_offset - last_offset;
	  gold_assert(skip <= sizeof discard);

	  iov[iov_index].iov_base = discard;
	  iov[iov_index].iov_len = skip;
	  ++iov_index;

	  want += skip;
	}

      iov[iov_index].iov_base = i_entry.buffer;
      iov[iov_index].iov_len = i_entry.size;
      ++iov_index;

      want += i_entry.size;

      last_offset = i_entry.file_offset + i_entry.size;
    }

  this->reopen_descriptor();

  gold_assert(iov_index < sizeof iov / sizeof iov[0]);

  if (::lseek(this->descriptor_, base + first_offset, SEEK_SET) < 0)
    gold_fatal(_("%s: lseek failed: %s"),
	       this->filename().c_str(), strerror(errno));

  ssize_t got = ::readv(this->descriptor_, iov, iov_index);

  if (got < 0)
    gold_fatal(_("%s: readv failed: %s"),
	       this->filename().c_str(), strerror(errno));
  if (got != want)
    gold_fatal(_("%s: file too short: read only %zd of %zd bytes at %lld"),
	       this->filename().c_str(),
	       got, want, static_cast<long long>(base + first_offset));
}

// Portable IOV_MAX.

#if !defined(HAVE_READV)
#define GOLD_IOV_MAX 1
#elif defined(IOV_MAX)
#define GOLD_IOV_MAX IOV_MAX
#else
#define GOLD_IOV_MAX (File_read::max_readv_entries * 2)
#endif

// Read several pieces of data from the file.

void
File_read::read_multiple(off_t base, const Read_multiple& rm)
{
  static size_t iov_max = GOLD_IOV_MAX;
  size_t count = rm.size();
  size_t i = 0;
  while (i < count)
    {
      // Find up to MAX_READV_ENTRIES consecutive entries which are
      // less than one page apart.
      const Read_multiple_entry& i_entry(rm[i]);
      off_t i_off = i_entry.file_offset;
      off_t end_off = i_off + i_entry.size;
      size_t j;
      for (j = i + 1; j < count; ++j)
	{
	  if (j - i >= File_read::max_readv_entries || j - i >= iov_max / 2)
	    break;
	  const Read_multiple_entry& j_entry(rm[j]);
	  off_t j_off = j_entry.file_offset;
	  gold_assert(j_off >= end_off);
	  off_t j_end_off = j_off + j_entry.size;
	  if (j_end_off - end_off >= File_read::page_size)
	    break;
	  end_off = j_end_off;
	}

      if (j == i + 1)
	this->read(base + i_off, i_entry.size, i_entry.buffer);
      else
	{
	  File_read::View* view = this->find_view(base + i_off,
						  end_off - i_off,
						  -1U, NULL);
	  if (view == NULL)
	    this->do_readv(base, rm, i, j - i);
	  else
	    {
	      const unsigned char* v = (view->data()
					+ (base + i_off - view->start()
					   + view->byteshift()));
	      for (size_t k = i; k < j; ++k)
		{
		  const Read_multiple_entry& k_entry(rm[k]);
		  gold_assert((convert_to_section_size_type(k_entry.file_offset
							   - i_off)
			       + k_entry.size)
			      <= convert_to_section_size_type(end_off
							      - i_off));
		  memcpy(k_entry.buffer,
			 v + (k_entry.file_offset - i_off),
			 k_entry.size);
		}
	    }
	}

      i = j;
    }
}

// Mark all views as no longer cached.

void
File_read::clear_view_cache_marks()
{
  // Just ignore this if there are multiple objects associated with
  // the file.  Otherwise we will wind up uncaching and freeing some
  // views for other objects.
  if (this->object_count_ > 1)
    return;

  for (Views::iterator p = this->views_.begin();
       p != this->views_.end();
       ++p)
    p->second->clear_cache();
  for (Saved_views::iterator p = this->saved_views_.begin();
       p != this->saved_views_.end();
       ++p)
    (*p)->clear_cache();
}

// Remove all the file views.  For a file which has multiple
// associated objects (i.e., an archive), we keep accessed views
// around until next time, in the hopes that they will be useful for
// the next object.

void
File_read::clear_views(Clear_views_mode mode)
{
  bool keep_files_mapped = (parameters->options_valid()
			    && parameters->options().keep_files_mapped());
  Views::iterator p = this->views_.begin();
  while (p != this->views_.end())
    {
      bool should_delete;
      if (p->second->is_locked() || p->second->is_permanent_view())
	should_delete = false;
      else if (mode == CLEAR_VIEWS_ALL)
	should_delete = true;
      else if ((p->second->should_cache()
		|| p->second == this->whole_file_view_)
	       && keep_files_mapped)
	should_delete = false;
      else if (this->object_count_ > 1
	       && p->second->accessed()
	       && mode != CLEAR_VIEWS_ARCHIVE)
	should_delete = false;
      else
	should_delete = true;

      if (should_delete)
	{
	  if (p->second == this->whole_file_view_)
	    this->whole_file_view_ = NULL;
	  delete p->second;

	  // map::erase invalidates only the iterator to the deleted
	  // element.
	  Views::iterator pe = p;
	  ++p;
	  this->views_.erase(pe);
	}
      else
	{
	  p->second->clear_accessed();
	  ++p;
	}
    }

  Saved_views::iterator q = this->saved_views_.begin();
  while (q != this->saved_views_.end())
    {
      if (!(*q)->is_locked())
	{
	  delete *q;
	  q = this->saved_views_.erase(q);
	}
      else
	{
	  gold_assert(mode != CLEAR_VIEWS_ALL);
	  ++q;
	}
    }
}

// Print statistical information to stderr.  This is used for --stats.

void
File_read::print_stats()
{
  fprintf(stderr, _("%s: total bytes mapped for read: %llu\n"),
	  program_name, File_read::total_mapped_bytes);
  fprintf(stderr, _("%s: maximum bytes mapped for read at one time: %llu\n"),
	  program_name, File_read::maximum_mapped_bytes);
}

// Class File_view.

File_view::~File_view()
{
  gold_assert(this->file_.is_locked());
  this->view_->unlock();
}

// Class Input_file.

// Create a file given just the filename.

Input_file::Input_file(const char* name)
  : found_name_(), file_(), is_in_sysroot_(false), format_(FORMAT_NONE)
{
  this->input_argument_ =
    new Input_file_argument(name, Input_file_argument::INPUT_FILE_TYPE_FILE,
			    "", false, Position_dependent_options());
}

// Create a file for testing.

Input_file::Input_file(const Task* task, const char* name,
		       const unsigned char* contents, off_t size)
  : file_()
{
  this->input_argument_ =
    new Input_file_argument(name, Input_file_argument::INPUT_FILE_TYPE_FILE,
			    "", false, Position_dependent_options());
  bool ok = this->file_.open(task, name, contents, size);
  gold_assert(ok);
}

// Return the position dependent options in force for this file.

const Position_dependent_options&
Input_file::options() const
{
  return this->input_argument_->options();
}

// Return the name given by the user.  For -lc this will return "c".

const char*
Input_file::name() const
{
  return this->input_argument_->name();
}

// Return whether this file is in a system directory.

bool
Input_file::is_in_system_directory() const
{
  if (this->is_in_sysroot())
    return true;
  return parameters->options().is_in_system_directory(this->filename());
}

// Return whether we are only reading symbols.

bool
Input_file::just_symbols() const
{
  return this->input_argument_->just_symbols();
}

// Return whether this is a file that we will search for in the list
// of directories.

bool
Input_file::will_search_for() const
{
  return (!IS_ABSOLUTE_PATH(this->input_argument_->name())
	  && (this->input_argument_->is_lib()
	      || this->input_argument_->is_searched_file()
	      || this->input_argument_->extra_search_path() != NULL));
}

// Return the file last modification time.  Calls gold_fatal if the stat
// system call failed.

Timespec
File_read::get_mtime()
{
  struct stat file_stat;
  this->reopen_descriptor();

  if (fstat(this->descriptor_, &file_stat) < 0)
    gold_fatal(_("%s: stat failed: %s"), this->name_.c_str(),
	       strerror(errno));
#ifdef HAVE_STAT_ST_MTIM
  return Timespec(file_stat.st_mtim.tv_sec, file_stat.st_mtim.tv_nsec);
#else
  return Timespec(file_stat.st_mtime, 0);
#endif
}

// Try to find a file in the extra search dirs.  Returns true on success.

bool
Input_file::try_extra_search_path(int* pindex,
				  const Input_file_argument* input_argument,
				  std::string filename, std::string* found_name,
				  std::string* namep)
{
  if (input_argument->extra_search_path() == NULL)
    return false;

  std::string name = input_argument->extra_search_path();
  if (!IS_DIR_SEPARATOR(name[name.length() - 1]))
    name += '/';
  name += filename;

  struct stat dummy_stat;
  if (*pindex > 0 || ::stat(name.c_str(), &dummy_stat) < 0)
    return false;

  *found_name = filename;
  *namep = name;
  return true;
}

// Find the actual file.
// If the filename is not absolute, we assume it is in the current
// directory *except* when:
//    A) input_argument_->is_lib() is true;
//    B) input_argument_->is_searched_file() is true; or
//    C) input_argument_->extra_search_path() is not empty.
// In each, we look in extra_search_path + library_path to find
// the file location, rather than the current directory.

bool
Input_file::find_file(const Dirsearch& dirpath, int* pindex,
		      const Input_file_argument* input_argument,
		      bool* is_in_sysroot,
		      std::string* found_name, std::string* namep)
{
  std::string name;

  // Case 1: name is an absolute file, just try to open it
  // Case 2: name is relative but is_lib is false, is_searched_file is false,
  //         and extra_search_path is empty
  if (IS_ABSOLUTE_PATH(input_argument->name())
      || (!input_argument->is_lib()
	  && !input_argument->is_searched_file()
	  && input_argument->extra_search_path() == NULL))
    {
      name = input_argument->name();
      *found_name = name;
      *namep = name;
      return true;
    }
  // Case 3: is_lib is true or is_searched_file is true
  else if (input_argument->is_lib()
	   || input_argument->is_searched_file())
    {
      std::vector<std::string> names;
      names.reserve(2);
      if (input_argument->is_lib())
	{
	  std::string prefix = "lib";
	  prefix += input_argument->name();
	  if (parameters->options().is_static()
	      || !input_argument->options().Bdynamic())
	    names.push_back(prefix + ".a");
	  else
	    {
	      names.push_back(prefix + ".so");
	      names.push_back(prefix + ".a");
	    }
	}
      else
	names.push_back(input_argument->name());

      for (std::vector<std::string>::const_iterator n = names.begin();
	   n != names.end();
	   ++n)
	if (Input_file::try_extra_search_path(pindex, input_argument, *n,
					      found_name, namep))
	  return true;

      // It is not in the extra_search_path.
      name = dirpath.find(names, is_in_sysroot, pindex, found_name);
      if (name.empty())
	{
	  gold_error(_("cannot find %s%s"),
		     input_argument->is_lib() ? "-l" : "",
		     input_argument->name());
	  return false;
	}
      *namep = name;
      return true;
    }
  // Case 4: extra_search_path is not empty
  else
    {
      gold_assert(input_argument->extra_search_path() != NULL);

      if (try_extra_search_path(pindex, input_argument, input_argument->name(),
				found_name, namep))
	return true;

      // extra_search_path failed, so check the normal search-path.
      int index = *pindex;
      if (index > 0)
	--index;
      name = dirpath.find(std::vector<std::string>(1, input_argument->name()),
			  is_in_sysroot, &index, found_name);
      if (name.empty())
	{
	  gold_error(_("cannot find %s"),
		     input_argument->name());
	  return false;
	}
      *namep = name;
      *pindex = index + 1;
      return true;
    }
}

// Open the file.

bool
Input_file::open(const Dirsearch& dirpath, const Task* task, int* pindex)
{
  std::string name;
  if (!Input_file::find_file(dirpath, pindex, this->input_argument_,
			     &this->is_in_sysroot_, &this->found_name_, &name))
    return false;

  // Now that we've figured out where the file lives, try to open it.

  General_options::Object_format format =
    this->input_argument_->options().format_enum();
  bool ok;
  if (format == General_options::OBJECT_FORMAT_ELF)
    {
      ok = this->file_.open(task, name);
      this->format_ = FORMAT_ELF;
    }
  else
    {
      gold_assert(format == General_options::OBJECT_FORMAT_BINARY);
      ok = this->open_binary(task, name);
      this->format_ = FORMAT_BINARY;
    }

  if (!ok)
    {
      gold_error(_("cannot open %s: %s"),
		 name.c_str(), strerror(errno));
      this->format_ = FORMAT_NONE;
      return false;
    }

  return true;
}

// Open a file for --format binary.

bool
Input_file::open_binary(const Task* task, const std::string& name)
{
  // In order to open a binary file, we need machine code, size, and
  // endianness.  We may not have a valid target at this point, in
  // which case we use the default target.
  parameters_force_valid_target();
  const Target& target(parameters->target());

  Binary_to_elf binary_to_elf(target.machine_code(),
			      target.get_size(),
			      target.is_big_endian(),
			      name);
  if (!binary_to_elf.convert(task))
    return false;
  return this->file_.open(task, name, binary_to_elf.converted_data_leak(),
			  binary_to_elf.converted_size());
}

} // End namespace gold.
@


1.76
log
@gold/
	* fileread.cc (Input_file::Input_file): New constructor.
	* fileread.h (class Input_file): Add new constructor.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d141 1
a141 1
        gold_warning(_("munmap failed: %s"), strerror(errno));
d213 1
a213 1
                 this->name_.c_str());
d232 1
a232 1
                                    View::DATA_NOT_OWNED);
a392 3
      bytes = ::pread(this->descriptor_, p, size, start);
      if (static_cast<section_size_type>(bytes) == size)
	return;
d394 4
a397 1
      if (bytes < 0)
d399 10
a408 3
	  gold_fatal(_("%s: pread failed: %s"),
		     this->filename().c_str(), strerror(errno));
	  return;
d410 3
d537 1
a537 1
          > static_cast<unsigned long long>(this->size_ - start)))
d539 1
a539 1
                 "size of file; the file may be corrupt"),
d597 1
a597 1
          new File_read::View(v->start(), v->size(), pbytes, byteshift,
d749 2
a750 2
                                                           - i_off)
                               + k_entry.size)
d752 1
a752 1
                                                              - i_off));
d808 2
a809 2
      	       && p->second->accessed()
      	       && mode != CLEAR_VIEWS_ARCHIVE)
d877 1
a877 1
                            "", false, Position_dependent_options());
d888 1
a888 1
                            "", false, Position_dependent_options());
@


1.75
log
@	PR gold/13288
	* gold/fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.
@
text
@d859 10
@


1.74
log
@	* dirsearch.cc (Dirsearch::find): Replace n1 and n2 parameters
	with name parameter.  Add found_name parameter.
	* fileread.cc (Input_file::find_file): Adjust code accordingly.
	* dirsearch.h (class Dirsearch): Update declaration.
@
text
@d332 4
d463 3
a465 10

  // Check that start and end of the view are within the file.
  if (start > this->size_
      || (static_cast<unsigned long long>(size)
          > static_cast<unsigned long long>(this->size_ - start)))
    gold_fatal(_("%s: attempt to map %lld bytes at offset %lld exceeds "
                 "size of file; the file may be corrupt"),
		   this->filename().c_str(),
		   static_cast<long long>(size),
		   static_cast<long long>(start));
d523 10
@


1.74.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@a331 4
  gold_assert(start <= this->size_
	      && (static_cast<unsigned long long>(size)
		  <= static_cast<unsigned long long>(this->size_ - start)));

d459 10
a468 3
  gold_assert(start <= this->size_
	      && (static_cast<unsigned long long>(size)
		  <= static_cast<unsigned long long>(this->size_ - start)));
a525 10
  // Check that start and end of the view are within the file.
  if (start > this->size_
      || (static_cast<unsigned long long>(size)
          > static_cast<unsigned long long>(this->size_ - start)))
    gold_fatal(_("%s: attempt to map %lld bytes at offset %lld exceeds "
                 "size of file; the file may be corrupt"),
		   this->filename().c_str(),
		   static_cast<long long>(size),
		   static_cast<long long>(start));

@


1.73
log
@	* configure.ac: Check for sys/mman.h and mmap.  Check for mremap
	with MREMAP_MAYMOVE.
	* output.h (class Output_file): Add map_is_allocated_ field.
	* output.cc: Only #include <sys/mman.h> if it exists.  If mmap is
	not available, provide stubs.  If mremap is not available, #define
	it to gold_mremap.
	(MREMAP_MAYMOVE): Define if not defined.
	(Output_file::Output_file): Initialize map_is_allocated_.
	(Output_file::resize): Check map_is_allocated_.
	(Output_file::map_anonymous): If mmap fails, use malloc.
	(Output_file::unmap): Don't do anything for an anonymous map.
	* fileread.cc: Only #include <sys/mman.h> if it exists.  If mmap
	is not available, provide stubs.
	(File_read::View::~View): Use free rather than delete[].
	(File_read::make_view): Use malloc rather than new[].  If mmap
	fails, use malloc.
	(File_read::find_or_make_view): Use malloc rather than new[].
	* gold.h: Remove HAVE_REMAP code.
	* mremap.c: #include <errno.h>.  Only #include <sys/mman.h> if it
	exists.  Rename mremap to gold_mremap.  If mmap is not available
	don't do anything.
	* configure, config.in: Rebuild.
@
text
@d989 2
a990 1
      std::string n1, n2;
d993 2
a994 2
	  n1 = "lib";
	  n1 += input_argument->name();
d997 1
a997 1
	    n1 += ".a";
d1000 2
a1001 2
	      n2 = n1 + ".a";
	      n1 += ".so";
d1005 1
a1005 1
	n1 = input_argument->name();
d1007 6
a1012 8
      if (Input_file::try_extra_search_path(pindex, input_argument, n1,
					    found_name, namep))
        return true;

      if (!n2.empty() && Input_file::try_extra_search_path(pindex,
							   input_argument, n2,
							   found_name, namep))
        return true;
d1015 1
a1015 1
      name = dirpath.find(n1, n2, is_in_sysroot, pindex);
d1019 1
a1019 1
	             input_argument->is_lib() ? "-l" : "",
a1022 4
      if (n2.empty() || name[name.length() - 1] == 'o')
	*found_name = n1;
      else
	*found_name = n2;
d1032 2
a1033 2
                                found_name, namep))
        return true;
d1038 3
a1040 3
        --index;
      name = dirpath.find(input_argument->name(), "",
                          is_in_sysroot, &index);
d1042 5
a1046 6
        {
          gold_error(_("cannot find %s"),
                     input_argument->name());
          return false;
        }
      *found_name = input_argument->name();
@


1.72
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d30 2
d33 1
d52 34
d136 1
a136 1
      delete[] this->data_;
d480 2
a481 1
  File_read::View* v;
d484 3
a486 1
      unsigned char* p = new unsigned char[psize + byteshift];
d488 2
a489 3
      this->do_read(poff, psize, p + byteshift);
      v = new File_read::View(poff, psize, p, byteshift, cache,
                              View::DATA_ALLOCATED_ARRAY);
d494 14
a507 14
      void* p = ::mmap(NULL, psize, PROT_READ, MAP_PRIVATE,
                       this->descriptor_, poff);
      if (p == MAP_FAILED)
	gold_fatal(_("%s: mmap offset %lld size %lld failed: %s"),
		   this->filename().c_str(),
		   static_cast<long long>(poff),
		   static_cast<long long>(psize),
		   strerror(errno));

      this->mapped_bytes_ += psize;

      const unsigned char* pbytes = static_cast<const unsigned char*>(p);
      v = new File_read::View(poff, psize, pbytes, 0, cache,
                              View::DATA_MMAPPED);
d510 4
d571 4
a574 1
      unsigned char* pbytes = new unsigned char[v->size() + byteshift];
@


1.71
log
@	* fileread.cc (File_read::clear_views): Don't delete the whole
	file view.
@
text
@d61 19
d873 1
a873 1
  
@


1.70
log
@	PR gold/12525
	* fileread.cc: #include <climits>.
	(GOLD_IOV_MAX): Define.
	(File_read::read_multiple): Limit number of entries by iov_max.
	* fileread.h (class File_read): Always set max_readv_entries to
	128.
@
text
@d720 3
a722 1
      else if (p->second->should_cache() && keep_files_mapped)
@


1.69
log
@gold: fix race in FileRead::~View.

gold/:
	* fileread.cc (file_counts_lock, file_counts_initialize_lock)
	(total_mapped_bytes, current_mapped_bytes, maximum_mapped_bytes):
	Move definition before File_read::View member definitions.
	(File_read::View::~View): Initialize and hold lock before
	updating current_mapped_bytes.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d27 1
d609 10
d624 1
d637 1
a637 1
	  if (j - i >= File_read::max_readv_entries)
@


1.68
log
@gold/
	* fileread.cc (Input_file::find_file): Initialize *found_name
	and *namep when using the fallback search for case 4.
@
text
@d60 11
d84 6
a89 1
      File_read::current_mapped_bytes -= this->size_;
a118 9
// A lock for the File_read static variables.
static Lock* file_counts_lock = NULL;
static Initialize_lock file_counts_initialize_lock(&file_counts_lock);

// The File_read static variables.
unsigned long long File_read::total_mapped_bytes;
unsigned long long File_read::current_mapped_bytes;
unsigned long long File_read::maximum_mapped_bytes;

@


1.68.2.1
log
@	PR gold/12525
	* fileread.cc: #include <climits>.
	(GOLD_IOV_MAX): Define.
	(File_read::read_multiple): Limit number of entries by iov_max.
	* fileread.h (class File_read): Always set max_readv_entries to
	128.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
a26 1
#include <climits>
a600 10
// Portable IOV_MAX.

#if !defined(HAVE_READV)
#define GOLD_IOV_MAX 1
#elif defined(IOV_MAX)
#define GOLD_IOV_MAX IOV_MAX
#else
#define GOLD_IOV_MAX (File_read::max_readv_entries * 2)
#endif

a605 1
  static size_t iov_max = GOLD_IOV_MAX;
d618 1
a618 1
	  if (j - i >= File_read::max_readv_entries || j - i >= iov_max / 2)
@


1.67
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d966 2
@


1.66
log
@2010-07-13  Rafael Espindola  <espindola@@google.com>

	* fileread.cc (try_extra_search_path, find_file): Move to Input_file.
	* fileread.h (Input_file): Add try_extra_search_path and find_file.
@
text
@d974 1
a974 1
Input_file::open(const Dirsearch& dirpath, const Task* task, int *pindex)
@


1.65
log
@2010-06-21  Rafael Espindola  <espindola@@google.com>

	* fileread.cc (Input_file::find_fie): New
	(Input_file::open): Use Input_file::find_fie.
	* fileread.h (Input_file::find_fie): New
	* plugin.cc (set_extra_library_path): New.
	(Plugin::load): Add set_extra_library_path to the transfer vector.
	(Plugin_manager::set_extra_library_path): New.
	(Plugin_manager::add_input_file): Use the extra search path if set.
	(set_extra_library_path(): New.
	* plugin.h (Plugin_manager): Add set_extra_library_path and
	extra_search_path_.
2010-06-21  Rafael Espindola  <espindola@@google.com>

	* plugin-api.h (ld_plugin_set_extra_library_path): New.
	(ld_plugin_tag): Add LDPT_SET_EXTRA_LIBRARY_PATH.
	(ld_plugin_tv): Add tv_set_extra_library_path.
@
text
@d844 1
a844 1
// Try to find a file in the extra search dirs. Returns true on success.
d846 6
a851 4
static bool
try_extra_search_path(int* pindex, const Input_file_argument* input_argument,
                      std::string filename, std::string* found_name,
                      std::string* namep) {
d856 1
a856 1
  if (!IS_DIR_SEPARATOR (name[name.length() - 1]))
d878 5
a882 4
static bool
find_file(const Dirsearch& dirpath, int* pindex,
          const Input_file_argument* input_argument, bool* is_in_sysroot,
          std::string* found_name, std::string* namep)
d920 2
a921 1
      if (try_extra_search_path(pindex, input_argument, n1, found_name, namep))
d924 3
a926 2
      if (!n2.empty() && try_extra_search_path(pindex, input_argument, n2,
                                               found_name, namep))
d977 2
a978 2
  if (!find_file(dirpath, pindex, this->input_argument_, &this->is_in_sysroot_,
                 &this->found_name_, &name))
@


1.64
log
@	* fileread.cc: Only #include <sys/uio.h> if HAVE_READV.
	(struct iovec): Correct !HAVE_READV definition.
@
text
@d844 22
a865 1
// Open the file.
d867 1
d876 4
a879 2
bool
Input_file::open(const Dirsearch& dirpath, const Task* task, int *pindex)
d886 9
a894 7
  if (IS_ABSOLUTE_PATH(this->input_argument_->name())
      || (!this->input_argument_->is_lib()
	  && !this->input_argument_->is_searched_file()
	  && this->input_argument_->extra_search_path() == NULL))
    {
      name = this->input_argument_->name();
      this->found_name_ = name;
d897 2
a898 2
  else if (this->input_argument_->is_lib()
	   || this->input_argument_->is_searched_file())
a899 2
      // We don't yet support extra_search_path with -l.
      gold_assert(this->input_argument_->extra_search_path() == NULL);
d901 1
a901 1
      if (this->input_argument_->is_lib())
d904 1
a904 1
	  n1 += this->input_argument_->name();
d906 1
a906 1
	      || !this->input_argument_->options().Bdynamic())
d915 11
a925 2
	n1 = this->input_argument_->name();
      name = dirpath.find(n1, n2, &this->is_in_sysroot_, pindex);
d929 2
a930 2
	             this->input_argument_->is_lib() ? "-l" : "",
		     this->input_argument_->name());
d934 1
a934 1
	this->found_name_ = n1;
d936 3
a938 1
	this->found_name_ = n2;
d943 1
a943 1
      gold_assert(this->input_argument_->extra_search_path() != NULL);
d945 11
a955 7
      // First, check extra_search_path.
      name = this->input_argument_->extra_search_path();
      if (!IS_DIR_SEPARATOR (name[name.length() - 1]))
        name += '/';
      name += this->input_argument_->name();
      struct stat dummy_stat;
      if (*pindex > 0 || ::stat(name.c_str(), &dummy_stat) < 0)
d957 3
a959 13
          // extra_search_path failed, so check the normal search-path.
	  int index = *pindex;
	  if (index > 0)
	    --index;
          name = dirpath.find(this->input_argument_->name(), "",
			      &this->is_in_sysroot_, &index);
          if (name.empty())
            {
              gold_error(_("cannot find %s"),
			 this->input_argument_->name());
	      return false;
            }
	  *pindex = index + 1;
d961 2
a962 1
      this->found_name_ = this->input_argument_->name();
d964 11
@


1.63
log
@	* fileread.cc (find_or_make_view): Fix comment.
@
text
@d30 2
d33 2
d49 1
a49 1
struct iovec { void* iov_base; size_t iov_len };
@


1.62
log
@	* fileread.cc (File_read::~File_read): Don't delete whole_file_view_.
	(File_read::open[1]): Remove initial mapping of whole_file_view_.
	(File_read::open[2]): Add whole_file_view_ to list of views.
	(File_read::make_view): Remove test of whole_file_view_.
	(File_read::find_or_make_view): Create whole_file_view_ if
	necessary.
	(File_read::clear_views): Replace bool parameter with enum;
	adjust all callers.  Don't delete views with permanent data;
	do delete cached views and views from archives if
	--no-keep-files-mapped is set.  Set whole_file_view_ to NULL
	if clearing the corresponding view.
	* fileread.h (File_read::Clear_views_mode): New enum.
	(File_read::View::is_permanent_view): New method.
	(File_read::clear_views): Replace bool parameter
	with enum; adjust all callers.
	* options.h (General_options): Change keep_files_mapped option;
	add map_whole_files.
	* readsyms.cc (Add_symbols::run): Delete sd_ object before
	releasing the file.
	* reloc.cc (Scan_relocs::run): Delete rd_ object before releasing
	the file.
@
text
@d472 1
a472 1
  // --no-keep-files-mapped.
@


1.61
log
@2010-02-24  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_finalize_sections): Skip processor specific
	flags and attributes merging if an input file is a binary file.
	* fileread.cc (Input_file::open): Record format of original file.
	* fileread.h (Input_file::Format): New enum type.
   	(Input_file::Input_file): Initialize data member format_.
	(Input_file::format): New method definition.
	(Input_file::format_):: New data member.
@
text
@d118 1
a118 3
  this->clear_views(true);
  if (this->whole_file_view_)
    delete this->whole_file_view_;
a144 17

      // Options may not yet be ready e.g. when reading a version
      // script.  We then default to --no-keep-files-mapped.
      if (parameters->options_valid()
	  && parameters->options().keep_files_mapped())
        {
          const unsigned char* contents = static_cast<const unsigned char*>(
              ::mmap(NULL, this->size_, PROT_READ, MAP_PRIVATE,
                     this->descriptor_, 0));
          if (contents == MAP_FAILED)
            gold_fatal(_("%s: mmap failed: %s"), this->filename().c_str(),
                       strerror(errno));
          this->whole_file_view_ = new View(0, this->size_, contents, 0, false,
                                            View::DATA_MMAPPED);
          this->mapped_bytes_ += this->size_;
        }

d164 1
d211 1
a211 1
      this->clear_views(false);
d413 1
a413 1
  if (this->whole_file_view_ != NULL || byteshift != 0)
d469 9
d685 1
a685 1
File_read::clear_views(bool destroying)
d687 2
d693 1
a693 1
      if (p->second->is_locked())
d695 1
a695 1
      else if (destroying)
d697 1
a697 1
      else if (p->second->should_cache())
d699 3
a701 1
      else if (this->object_count_ > 1 && p->second->accessed())
d708 2
a719 1
	  gold_assert(!destroying);
d735 1
a735 1
	  gold_assert(!destroying);
@


1.60
log
@	* gold-threads.h (class Once): Define.
	(class Initialize_lock): Rewrite as child of Once.
	* gold-threads.cc (class Once_initialize): Define.
	(once_pointer_control): New static variable.
	(once_pointer, once_arg): New static variables.
	(c_run_once): New static function.
	(Once::Once, Once::run_once, Once::internal_run): New functions.
	(class Initialize_lock_once): Remove.
	(initialize_lock_control): Remove.
	(initialize_lock_pointer): Remove.
	(initialize_lock_once): Remove.
	(Initialize_lock::Initialize_lock): Move to gold-threads.h.
	(Initialize_lock::initialize): Rewrite.
	(Initialize_lock::do_run_once): New function.
	* archive.cc (Archive::interpret_header): Only clear name if it is
	not already empty.
	* fileread.cc: Include "gold-threads.h"
	(file_counts_lock): New static variable.
	(file_counts_initialize_lock): Likewise.
	(File_read::release): Only increment counts when using --stats.
	Use a lock around the increment.
	* parameters.cc (class Set_parameters_target_once): Define.
	(set_parameters_target_once): New static variable.
	(Parameters::Parameters): Move here from parameters.h.
	(Parameters::set_target): Rewrite.
	(Parameters::set_target_once): New function.
	(Parameters::clear_target): Move here and rewrite.
	* parameters.h (class Parameters): Update declarations.  Add
	set_parameters_target_once_ field.
	(Parameters::Parameters): Move to parameters.cc.
	(Parameters::clear_target): Likewise.
	* readsyms.cc (Read_symbols::do_group): Create a Start_group
	task.
	(Start_group::~Start_group): New function.
	(Start_group::is_runnable): New function.
	(Start_group::locks, Start_group::run): New functions.
	(Finish_group::run): Change saw_undefined to size_t.
	* readsyms.h (class Start_group): Define.
	(class Finish_group): Change saw_undefined_ field to size_t.
	(Finish_group::Finish_group): Remove saw_undefined and
	this_blocker parameters.  Change all callers.
	(Finish_group::set_saw_undefined): New function.
	(Finish_group::set_blocker): New function.
	* symtab.h (class Symbol_table): Change saw_undefined to return
	size_t.  Change saw_undefined_ field to size_t.
	* target-select.cc (Set_target_once::do_run_once): New function.
	(Target_selector::Target_selector): Initialize set_target_once_
	field.  Don't initialize lock_ and initialize_lock_ fields.
	(Target_selector::instantiate_target): Rewrite.
	(Target_selector::set_target): New function.
	* target-select.h (class Set_target_once): Define.
	(class Target_selector): Update declarations.  Make
	Set_target_once a friend.  Remove lock_ and initialize_lock_
	fields.  Add set_target_once_ field.
@
text
@d941 4
a944 1
    ok = this->file_.open(task, name);
d949 1
d956 1
@


1.59
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d41 1
d99 4
d212 10
a221 2
  File_read::total_mapped_bytes += this->mapped_bytes_;
  File_read::current_mapped_bytes += this->mapped_bytes_;
a222 2
  if (File_read::current_mapped_bytes > File_read::maximum_mapped_bytes)
    File_read::maximum_mapped_bytes = File_read::current_mapped_bytes;
@


1.58
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d757 1
a757 1
Input_file::Input_file(const Task* task, const char* iname,
d762 1
a762 1
    new Input_file_argument(iname, Input_file_argument::INPUT_FILE_TYPE_FILE,
d764 1
a764 1
  bool ok = this->file_.open(task, iname, contents, size);
d846 1
a846 1
  std::string iname;
d856 2
a857 2
      iname = this->input_argument_->name();
      this->found_name_ = iname;
d881 2
a882 2
      iname = dirpath.find(n1, n2, &this->is_in_sysroot_, pindex);
      if (iname.empty())
d889 1
a889 1
      if (n2.empty() || iname[iname.length() - 1] == 'o')
d900 4
a903 4
      iname = this->input_argument_->extra_search_path();
      if (!IS_DIR_SEPARATOR (iname[iname.length() - 1]))
        iname += '/';
      iname += this->input_argument_->name();
d905 1
a905 1
      if (*pindex > 0 || ::stat(iname.c_str(), &dummy_stat) < 0)
d911 3
a913 3
          iname = dirpath.find(this->input_argument_->name(), "",
			       &this->is_in_sysroot_, &index);
          if (iname.empty())
d930 1
a930 1
    ok = this->file_.open(task, iname);
d934 1
a934 1
      ok = this->open_binary(task, iname);
d940 1
a940 1
		 iname.c_str(), strerror(errno));
d950 1
a950 1
Input_file::open_binary(const Task* task, const std::string& iname)
d961 1
a961 1
			      iname);
d964 1
a964 1
  return this->file_.open(task, iname, binary_to_elf.converted_data_leak(),
@


1.57
log
@	* configure.ac: Check for (struct stat)::st_mtim
	* fileread.cc (File_read::get_mtime): Use st_mtim if available.
	* config.in: Regenerate.
	* configure: Regenerate.
@
text
@d757 1
a757 1
Input_file::Input_file(const Task* task, const char* name,
d762 1
a762 1
    new Input_file_argument(name, Input_file_argument::INPUT_FILE_TYPE_FILE,
d764 1
a764 1
  bool ok = this->file_.open(task, name, contents, size);
d846 1
a846 1
  std::string name;
d856 2
a857 2
      name = this->input_argument_->name();
      this->found_name_ = name;
d881 2
a882 2
      name = dirpath.find(n1, n2, &this->is_in_sysroot_, pindex);
      if (name.empty())
d889 1
a889 1
      if (n2.empty() || name[name.length() - 1] == 'o')
d900 4
a903 4
      name = this->input_argument_->extra_search_path();
      if (!IS_DIR_SEPARATOR (name[name.length() - 1]))
        name += '/';
      name += this->input_argument_->name();
d905 1
a905 1
      if (*pindex > 0 || ::stat(name.c_str(), &dummy_stat) < 0)
d911 3
a913 3
          name = dirpath.find(this->input_argument_->name(), "",
			      &this->is_in_sysroot_, &index);
          if (name.empty())
d930 1
a930 1
    ok = this->file_.open(task, name);
d934 1
a934 1
      ok = this->open_binary(task, name);
d940 1
a940 1
		 name.c_str(), strerror(errno));
d950 1
a950 1
Input_file::open_binary(const Task* task, const std::string& name)
d961 1
a961 1
			      name);
d964 1
a964 1
  return this->file_.open(task, name, binary_to_elf.converted_data_leak(),
@


1.56
log
@	* fileread.cc: (File_read::View::~View): Use the new
	data_ownership_ filed.
	(File_read::~File_read): Dispose the new whole_file_view_.
	(File_read::open): Mmap the whole file if needed.
	(File_read::open): Use whole_file_view_ instead of contents_.
	(File_read::find_view): Use whole_file_view_ if applicable.
	(File_read::do_read): Use whole_file_view_ instead of contents_.
	(File_read::make_view): Use whole_file_view_ instead of contents_,
	update File_read::View::View call.
	(File_read::find_or_make_view): Update File_read::View::View
	call.
	* fileread.h: (File_read::File_read): Initialize whole_file_view_,
	remove contents_
	(File_read::View::Data_ownership): New enum.
	(File_read::View::View): Replace bool mapped_ with Data_ownership
	argument.
	(File_read::View::mapped_): Remove (replaced by data_ownership_).
	(File_read::View::data_ownership_): New field.
	(File_read::contents_): Remove (replaced by whole_file_view_).
	(File_read::whole_file_view_): New field.
	* options.h (class General_options): Add --keep-files-mapped.
@
text
@d826 3
a828 2
  // TODO: do a configure check if st_mtim is present and get the
  // nanoseconds part if it is.
d830 1
@


1.55
log
@2009-10-10  Chris Demetriou  <cgd@@google.com>

	* options.h (Input_file_argument::Input_file_type): New enum.
	(Input_file_argument::is_lib_): Replace with...
	(Input_file_argument::type_): New member.
	(Input_file_argument::Input_file_argument): Take Input_file_type
	'type' rather than boolean 'is_lib' as second argument.
	(Input_file_argument::is_lib): Use type_.
	(Input_file_argument::is_searched_file): New function.
	(Input_file_argument::may_need_search): Handle is_searched_file.
	* options.cc (General_options::parse_library): Support -l:filename.
	(General_options::parse_just_symbols): Update for Input_file_argument
	changes.
	(Command_line::process): Likewise.
	* archive.cc (Archive::get_file_and_offset): Likewise.
	* plugin.cc (Plugin_manager::release_input_file): Likewise.
	* script.cc (read_script_file, script_add_file): Likewise.
	* fileread.cc (Input_file::Input_file): Likewise.
	(Input_file::will_search_for): Handle is_searched_file.
	(Input_file::open): Likewise.
	* readsyms.cc (Read_symbols::get_name): Likewise.
	* testsuite/Makefile.am (searched_file_test): New test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/searched_file_test.cc: New file.
	* testsuite/searched_file_test_lib.cc: New file.
@
text
@d60 1
a60 3
  if (!this->mapped_)
    delete[] this->data_;
  else
d62 4
a67 1

d69 5
d114 2
d143 16
d176 2
a177 1
  this->contents_ = contents;
d274 6
d315 1
a315 1
  if (this->contents_ != NULL)
d320 1
a320 1
	  memcpy(p, this->contents_ + start, size);
d420 1
a420 1
  if (this->contents_ != NULL || byteshift != 0)
d425 2
a426 1
      v = new File_read::View(poff, psize, p, byteshift, cache, false);
d443 2
a444 1
      v = new File_read::View(poff, psize, pbytes, 0, cache, true);
d499 3
a501 3
      File_read::View* shifted_view = new File_read::View(v->start(), v->size(),
							  pbytes, byteshift,
							  cache, false);
@


1.54
log
@	* configure.ac: Check for readv function also.
	* fileread.cc (readv): Define if not HAVE_READV.
	* fileread.h (File_read:: max_readv_entries): Set to 1 if readv
	does not exist.
	* config.in: Regenerate.
	* configure: Regenerate.
@
text
@d729 2
a730 2
    new Input_file_argument(name, false, "", false,
			    Position_dependent_options());
d777 1
d802 4
a805 3
//    A) input_argument_->is_lib() is true; or
//    B) input_argument_->extra_search_path() is not empty.
// In both cases, we look in extra_search_path + library_path to find
d814 2
a815 2
  // Case 2: name is relative but is_lib is false and extra_search_path
  //         is empty
d818 1
d824 3
a826 2
  // Case 3: is_lib is true
  else if (this->input_argument_->is_lib())
d830 2
a831 7
      std::string n1("lib");
      n1 += this->input_argument_->name();
      std::string n2;
      if (parameters->options().is_static()
	  || !this->input_argument_->options().Bdynamic())
	n1 += ".a";
      else
d833 10
a842 2
	  n2 = n1 + ".a";
	  n1 += ".so";
d844 2
d849 2
a850 1
	  gold_error(_("cannot find -l%s"),
@


1.53
log
@	* object.h (class Object): Remove target_ field, and target,
	sized_target, and set_target methods.
	(Object::sized_target): Remove.
	(class Sized_relobj): Update declarations.  Remove sized_target.
	* object.cc (Sized_relobj::setup): Remove target parameter.
	Change all callers.
	(Input_objects::add_object): Don't do anything with the target.
	(make_elf_sized_object): Add punconfigured parameter.  Change all
	callers.  Set or test parameter target.
	* dynobj.cc (Sized_dynobj::target): Remove target parameter.
	Change all callers.
	* parameters.cc (Parameters::set_target): Change parameter type to
	be non-const.
	(Parameters::default_target): Remove.
	(set_parameters_target): Change parameter type to be non-const.
	(parameters_force_valid_target): New function.
	(parameters_clear_target): New function.
	* parameters.h (class Parameters): Update declarations.  Remove
	default_target method.  Add sized_target and clear_target
	methods.  Change target_ to be non-const.
	(set_parameters_target): Update declaration.
	(parameters_force_valid_target): Declare.
	(parameters_clear_target): Declare.
	* readsyms.cc (Read_symbols::do_read_symbols): Pass punconfigured
	as NULL if we aren't searching.
	(Add_symbols::run): Don't check for compatible target.
	* fileread.cc (Input_file::open_binary): Call
	parameters_force_valid_target.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (make_sized_plugin_object): Likewise.  Don't call
	set_target on object.
	* dynobj.h (class Sized_dynobj): Update declarations.
	* archive.cc (Archive::get_elf_object_for_member): Return NULL if
	make_elf_object returns NULL.
	(Archive::include_member): Don't check whether object target is
	compatible.
	* output.cc (Output_section::add_input_section): Get target from
	parameters.
	(Output_section::relax_input_section): Likewise.
	* reloc.cc (Sized_relobj::do_gc_process_relocs): Get target from
	parameters.
	(Sized_relobj::do_scan_relocs): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* symtab.cc (Symbol_table::wrap_symbol): Likewise.  Remove object
	parameter.  Change all callers.
	(Symbol_table::add_from_object): Get target from parameters.
	(Symbol_table::add_from_relobj): Don't check object target.
	(Symbol_table::add_from_dynobj): Likewise.
	(Symbol_table::define_special_symbol): Get target from
	parameters.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/binary_unittest.cc (gold_testsuite): Remove target
	parameter.  Change all callers.  Clear parameter target.
	(Binary_test): Test target here.
	* testsuite/object_unittest.cc (gold_testsuite): Remove
	target_test_pointer parameter.  Change all callers.
	(Object_test): Test target here.
@
text
@d43 9
@


1.52
log
@	* fileread.cc (File_read::get_mtime): New method.
	* fileread.h (Timespec): New structure.
	(File_read::get_mtime): New method.
	* incremental.cc (Incremental_inputs_entry_data::timestamp_usec):
	Renamed from timestamp_nsec.
	(Incremental_inputs_entry_write::timestamp_sec): Fix argument to
	Elf_Xword.
	(Incremental_inputs_entry_write::timestamp_usec): Renamed from
	timestamp_nsec.
	(Incremental_inputs::report_archive): Save mtime; style fix.
	(Incremental_inputs::report_obejct): Save mtime; style fix.
	(Incremental_inputs::report_script): Save mtime; style fix.
	(Incremental_inputs::finalize_inputs): Style fix.
	(Incremental_inputs::finalize): Style fix.
	(Incremental_inputs::create_input_section_data): Store inputs
	mtime.
	* incremental.h (Incremental_inputs::report_script): Add mtime
	argument.
	(Incremental_inputs::Input_info::Input_info): Intialize only one
	union member.
	(Incremental_inputs::Input_info::archive): Move to nameless
	union.
	(Incremental_inputs::Input_info::obejct): Move to nameless union.
	(Incremental_inputs::Input_info::script): Move to nameless union.
	(Incremental_inputs::mtime): New field.
	* script.cc (read_input_script): Pass file mtime to
	Incremental_input.
	* script.h (Script_info::inputs): Style fix.
@
text
@d901 2
a902 5
  const Target* target;
  if (parameters->target_valid())
    target = &parameters->target();
  else
    target = &parameters->default_target();
d904 3
a906 3
  Binary_to_elf binary_to_elf(target->machine_code(),
			      target->get_size(),
			      target->is_big_endian(),
@


1.52.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a42 9
#ifndef HAVE_READV
struct iovec { void* iov_base; size_t iov_len };
ssize_t
readv(int, const iovec*, int)
{
  gold_unreachable();
}
#endif

d720 2
a721 2
    new Input_file_argument(name, Input_file_argument::INPUT_FILE_TYPE_FILE,
                            "", false, Position_dependent_options());
a767 1
	      || this->input_argument_->is_searched_file()
d792 3
a794 4
//    A) input_argument_->is_lib() is true;
//    B) input_argument_->is_searched_file() is true; or
//    C) input_argument_->extra_search_path() is not empty.
// In each, we look in extra_search_path + library_path to find
d803 2
a804 2
  // Case 2: name is relative but is_lib is false, is_searched_file is false,
  //         and extra_search_path is empty
a806 1
	  && !this->input_argument_->is_searched_file()
d812 2
a813 3
  // Case 3: is_lib is true or is_searched_file is true
  else if (this->input_argument_->is_lib()
	   || this->input_argument_->is_searched_file())
d817 7
a823 2
      std::string n1, n2;
      if (this->input_argument_->is_lib())
d825 2
a826 10
	  n1 = "lib";
	  n1 += this->input_argument_->name();
	  if (parameters->options().is_static()
	      || !this->input_argument_->options().Bdynamic())
	    n1 += ".a";
	  else
	    {
	      n2 = n1 + ".a";
	      n1 += ".so";
	    }
a827 2
      else
	n1 = this->input_argument_->name();
d831 1
a831 2
	  gold_error(_("cannot find %s%s"),
	             this->input_argument_->is_lib() ? "-l" : "",
d901 5
a905 2
  parameters_force_valid_target();
  const Target& target(parameters->target());
d907 3
a909 3
  Binary_to_elf binary_to_elf(target.machine_code(),
			      target.get_size(),
			      target.is_big_endian(),
@


1.51
log
@2009-06-23  Doug Kwan  <dougkwan@@google.com>

	* Makefile.am (libgold_a_LIBADD): New.
	(ld_new_DEPENDENCIES, ld_new_LDADD): Remove LIBOBJS
 	* Makefile.in: Regenerate.
	* config.in (HAVE_DECL_MEMMEM, HAVE_DECL_STRNDUP): New.
	* configure: Regenerate.
	* configure.ac (AC_CHECK_DECLS): Add strndup and memmem.
	* fileread.cc: Include sys/state.h
	* gold.h: Declare memmem and strndup if found missing.
	* gold_reloc.h: Include byteswap.h if HAVE_BYTESWAP_H is defined.
@
text
@d771 17
@


1.50
log
@	* readsyms.cc (Read_symbols::incompatible_warning): New function.
	(Read_symbols::requeue): New function.
	(Read_symbols::do_read_symbols): If make_elf_object fails because
	the target type is not configured, and the file was searched for,
	issue a warning and retry with the next directory.
	(Add_symbols::run): If the file has an incompatible format, and
	it was searched for, requeue the Read_symbols task.  On error,
	release the object.
	* readsyms.h (class Read_symbols): Add dirindex_ field.  Add
	dirindex parameter to constructor.  Change all callers.  Declare
	incompatible_warning and requeue.
	(class Add_symbols): Add dirpath_, dirindex_, mapfile_,
	input_argument_ and input_group_ fields.  Add them to
	constructor.  Change all callers.
	(class Read_script): Add dirindex_ field.  Add it to constructor.
	Change all callers.
	* archive.cc (Archive::setup): Remove input_objects parameter.
	Change all callers.
	(Archive::get_file_and_offset): Likewise.
	(Archive::read_all_symbols): Likewise.
	(Archive::read_symbols): Likewise.
	(Archive::get_elf_object_for_member): Remove input_objects
	parameter.  Add punconfigured parameter.  Change all callers.
	(Archive::add_symbols): Change return type to bool.  Check return
	value of include_member.
	(Archive::include_all_members): Likewise.
	(Archive::include_member): Change return type to bool.  Return
	false if first included object has incompatible target.  Set
	included_member_ field.
	(Add_archive_symbols::run): If add_symbols returns false, requeue
	Read_symbols task.
	* archive.h (class Archive): Add included_member_ field.
	Initialize it in constructor.  Add input_file and searched_for
	methods.  Update declarations.
	(class Add_archive_symbols): Add dirpath_, dirindex_, and
	input_argument_ fields.  Add them to constructor.  Change all
	callers.
	* script.cc: Include "target-select.h".
	(class Parser_closure): Add skip_on_incompatible_target_ and
	found_incompatible_target_ fields.  Add
	skip_on_incompatible_target parameter to constructor.  Change all
	callers.  Add methods skip_on_incompatible_target,
	clear_skip_on_incompatible_target, found_incompatible_target, and
	set_found_incompatible_target.
	(read_input_script): Add dirindex parameter.  Change all callers.
	If parser finds an incompatible target, requeue Read_symbols
	task.
	(script_set_symbol): Clear skip_on_incompatible_target in
	closure.
	(script_add_assertion, script_parse_option): Likewise.
	(script_start_sections, script_add_phdr): Likewise.
	(script_check_output_format): New function.
	* script.h (read_input_script): Update declaration.
	* script-c.h (script_check_output_format): Declare.
	* yyscript.y (file_cmd): Handle OUTPUT_FORMAT.
	(ignore_cmd): Remove OUTPUT_FORMAT.
	* fileread.cc (Input_file::Input_file): Add explicit this.
	(Input_file::will_search_for): New function.
	(Input_file::open): Add pindex parameter.  Change all callers.
	* fileread.h (class Input_file): Add input_file_argument method.
	Declare will_search_for.  Update declarations.
	* object.cc (make_elf_object): Add punconfigured parameter.
	Change all callers.
	* object.h (class Object): Make input_file public.  Add
	searched_for method.
	(make_elf_object): Update declaration.
	* dirsearch.cc (Dirsearch::find): Add pindex parameter.  Use it to
	restart search.
	* dirsearch.h (class Dirsearch): Update declaration.
	* options.h (class General_options): Add --warn-search-mismatch.
	* parameters.cc (Parameters::is_compatible_target): New function.
	* parameters.h (class Parameters): Declare is_compatible_target.
	* workqueue.cc (Workqueue::add_blocker): New function.
	* workqueue.h (class Workqueue): Declare add_blocker.
@
text
@d31 1
@


1.49
log
@	* fileread.cc (Input_file::open): Remove options parameter.
	Change all callers.
	(Input_file::open_binary): Likewise.
	* script.cc (read_input_script): Likewise.
	* readsyms.h (class Read_symbols): Remove options_ field.  Remove
	options parameter from constructor.  Change all callers.
	(class Read_script): Likewise.
	* fileread.h (class Input_file): Update declarations.
	* script.h (read_input_script): Update declaration.
@
text
@d721 1
a721 1
  bool ok = file_.open(task, name, contents, size);
d759 11
d780 1
a780 1
Input_file::open(const Dirsearch& dirpath, const Task* task)
d787 1
a787 1
  if (IS_ABSOLUTE_PATH (this->input_argument_->name())
d810 1
a810 1
      name = dirpath.find(n1, n2, &this->is_in_sysroot_);
d833 1
a833 1
      if (::stat(name.c_str(), &dummy_stat) < 0)
d836 3
d840 1
a840 1
			      &this->is_in_sysroot_);
d847 1
@


1.48
log
@	PR 6811
	* options.h (class Search_directory): Add is_system_directory.
	(class General_options): Declare is_in_system_directory.
	* options.cc (get_relative_sysroot): Make static.
	(get_default_sysroot): Make static.
	(General_optoins::is_in_system_directory): New function.
	* fileread.cc (Input_file::is_in_system_directory): New function.
	* fileread.h (class Input_file): Declare is_in_system_directory.
	* object.h (class Object): Add is_in_system_directory.
	(class Input_objects): Remove system_library_directory_ field.
	* object.cc (Input_objects::add_object): Don't set
	system_library_directory_.
	(input_objects::found_in_system_library_directory): Remove.
	* symtab.cc (Symbol_table::write_globals): Remove input_objects
	parameter.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::warn_about_undefined_dynobj_symbol): Likewise.
	Call Object::is_in_system_directory.
	* symtab.h (class Symbol_table): Update declarations.
@
text
@d769 1
a769 2
Input_file::open(const General_options& options, const Dirsearch& dirpath,
		 const Task* task)
d791 1
a791 1
      if (options.is_static()
d847 1
a847 1
      ok = this->open_binary(options, task, name);
d863 1
a863 2
Input_file::open_binary(const General_options&,
			const Task* task, const std::string& name)
@


1.47
log
@	* archive.cc (Archive::get_elf_object_for_member): Remove call
	to File_read::claim_for_plugin.
	* descriptors.cc (Descriptors::open): Remove reference to
	is_claimed.
	(Descriptors::claim_for_plugin): Remove.
	* descriptors.h (Descriptors::claim_for_plugin): Remove.
	(Descriptors::is_claimed): Remove.
	(claim_descriptor_for_plugin): Remove.
	* fileread.cc (File_read::claim_for_plugin): Remove.
	* fileread.h (File_read::claim_for_plugin): Remove.
	(File_read::descriptor): Reopen descriptor if necessary.
	* plugin.cc  (Plugin::load): Add two new APIs to transfer vector.
	(Plugin_manager::all_symbols_read): Add task parameter. Change
	all callers.
	(Plugin_manager::get_input_file): New function.
	(Plugin_manager::release_input_file): New function.
	(Pluginobj::Pluginobj): Add filesize parameter and initialize
	corresponding data member.
	(Sized_pluginobj::Sized_pluginobj): Add filesize parameter
	and pass to base constructor. Change all callers.
	(get_input_file, release_input_file): New functions.
	(make_sized_plugin_object): Add filesize parameter. Change all callers.
	* plugin.h (Plugin_manager::Plugin_manager): Initialize task_ member.
	(Plugin_manager::all_symbols_read): Add task parameter.
	(Plugin_manager::get_input_file): New function.
	(Plugin_manager::release_input_file): New function.
	(Plugin_manager::task_): New data member.
	(Pluginobj::Pluginobj): Add filesize parameter.
	(Pluginobj::filename): New function.
	(Pluginobj::descriptor): New function.
	(Pluginobj::filesize): New function.
	(Pluginobj::filesize_): New data member.
	(Sized_pluginobj::Sized_pluginobj): Add filesize parameter.
	* readsyms.cc (Read_symbols::do_read_symbols): Remove call to
	File_read::claim_for_plugin; use Object::unlock to unlock the file.

	* testsuite/Makefile.am (plugin_test_4): New test case for plugins
	with archive libraries.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_test.c (struct sym_info): New type.
	(get_input_file, release_input_file): New static variables.
	(onload): Capture new transfer vector entries.
	(claim_file_hook): Stop reading at end of file according to filesize.
	Factor out parsing of readelf output into separate function.
	(all_symbols_read_hook): Exercise get_input_file and release_input_file
	APIs and get the source file name from the symbol table.  Convert
	source file name to corresponding object file name.  Print info
	message when adding new input files.
	(parse_readelf_line): New function.
	* testsuite/plugin_test_1.sh: Add checks for new info messages.
	* testsuite/plugin_test_2.sh: Likewise.
	* testsuite/plugin_test_3.sh: Likewise.
	* testsuite/plugin_test_4.sh: New test case.
@
text
@d741 10
@


1.46
log
@Add plugin functionality for link-time optimization (LTO).

include/:
	* plugin-api.h: New file.

gold/:
	* configure.ac (plugins): Add --enable-plugins option.
	* configure: Regenerate.
	* config.in: Regenerate.
	* Makefile.am (LIBDL): New variable.
	(CCFILES): Add plugin.cc.
	(HFILES): Add plugin.h.
	(ldadd_var): Add LIBDL.
	* Makefile.in: Regenerate.

	* archive.cc: Include "plugin.h".
	(Archive::setup): Don't preread archive symbols when using a plugin.
	(Archive::get_file_and_offset): Add memsize parameter.  Change callers.
	(Archive::get_elf_object_for_member): Call plugin hooks for claiming
	files.
	(Archive::include_member): Add symbols from plugin objects.
	* archive.h (Archive::get_file_and_offset): Add memsize parameter.
	* descriptors.cc (Descriptors::open): Check for file descriptors
	abandoned by plugins.
	(Descriptors::claim_for_plugin): New function.
	* descriptors.h (Descriptors::claim_for_plugin): New function.
	(Open_descriptor::is_claimed): New field.
	(claim_descriptor_for_plugin): New function.
	* fileread.cc (File_read::claim_for_plugin): New function.
	* fileread.h (File_read::claim_for_plugin): New function.
	(File_read::descriptor): New function.
	* gold.cc: Include "plugin.h".
	(queue_initial_tasks): Add task to call plugin hooks for generating
	new object files.
	* main.cc: Include "plugin.h".
	(main): Load plugin libraries.
	* object.h (Pluginobj): Declare.
	(Object::pluginobj): New function.
	(Object::do_pluginobj): New function.
	(Object::set_target): New function.
	* options.cc: Include "plugin.h".
	(General_options::parse_plugin): New function.
	(General_options::General_options): Initialize plugins_ field.
	(General_options::add_plugin): New function.
	* options.h (Plugin_manager): Declare.
	(General_options): Add --plugin option.
	(General_options::has_plugins): New function.
	(General_options::plugins): New function.
	(General_options::add_plugin): New function.
	(General_options::plugins_): New field.
	* plugin.cc: New file.
	* plugin.h: New file.
	* readsyms.cc: Include "plugin.h".
	(Read_symbols::do_read_symbols): Check for archive before checking
	for ELF file.  Call plugin hooks to claim files.
	* resolve.cc (Symbol_table::resolve): Record when symbol is referenced
	from a real object file; force override when processing replacement
	files.
	* symtab.cc (Symbol::init_fields): Initialize in_real_elf_ field.
	(Symbol::init_base_object): Likewise.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): Likewise.
	(Symbol::output_section): Assert that object is not a plugin.
	(Symbol_table::add_from_pluginobj): New function.
	(Symbol_table::sized_finalize_symbol): Treat symbols from plugins as
	undefined.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::add_from_pluginobj): Instantiate template.
	* symtab.h (Sized_pluginobj): Declare.
	(Symbol::in_real_elf): New function.
	(Symbol::set_in_real_elf): New function.
	(Symbol::in_real_elf_): New field.
	(Symbol_table::add_from_pluginobj): New function.

	* testsuite/Makefile.am (AM_CFLAGS): New variable.
	(LIBDL): New variable.
	(LDADD): Add LIBDL.
	(check_PROGRAMS): Add plugin_test_1 and plugin_test_2.
	(check_SCRIPTS): Add plugin_test_1.sh and plugin_test_2.sh.
	(check_DATA): Add plugin_test_1.err and plugin_test_2.err.
	(MOSTLYCLEANFILES): Likewise.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_test.c: New file.
	* testsuite/plugin_test_1.sh: New file.
	* testsuite/plugin_test_2.sh: New file.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
a193 13
// Claim the file for a plugin.  This effectively releases the file without
// closing it; the plugin will assume responsibility for closing it.

void
File_read::claim_for_plugin()
{
  gold_assert(this->is_locked());
  claim_descriptor_for_plugin(this->descriptor_);
  this->descriptor_ = -1;
  this->is_descriptor_opened_ = false;
  this->released_ = true;
}

@


1.45
log
@	* fileread.cc (make_view): Add casts to avoid warning.
@
text
@d194 13
@


1.44
log
@2008-09-05  Cary Coutant  <ccoutant@@google.com>

	* fileread.cc (File_read::make_view): Add check for attempt to map
	beyond end of file.
@
text
@d359 3
a361 1
  if (start > this->size_ || size > this->size_ - start)
@


1.43
log
@2008-08-20  Craig Silverstein  <csilvers@@google.com>

	* fileread.cc (File_read::open): Do not lock the file unless it
	was successfully opened.
@
text
@d358 8
@


1.42
log
@	PR 5990
	* descriptors.cc: New file.
	* descriptors.h: New file.
	* gold-threads.h (class Hold_optional_lock): New class.
	* fileread.cc: Include "descriptors.h".
	(File_read::~File_read): Release descriptor rather than closing
	it.
	(File_read::open) [file]: Call open_descriptor rather than open.
	Set is_descriptor_opened_.
	(File_read::open) [memory]: Assert that descriptor is not open.
	(File_read::reopen_descriptor): New function.
	(File_read::release): Release descriptor.
	(File_read::do_read): Make non-const.  Reopen descriptor.
	(File_read::read): Make non-const.
	(File_read::make_view): Reopen descriptor.
	(File_read::do_readv): Likewise.
	* fileread.h (class File_read): Add is_descriptor_opened_ field.
	Update declarations.
	* layout.cc: Include "descriptors.h".
	(Layout::create_build_id): Use open_descriptor rather than open.
	* output.cc: Include "descriptors.h".
	(Output_file::open): Use open_descriptor rather than open.
	* archive.cc (Archive::const_iterator): Change Archive to be
	non-const.
	(Archive::begin, Archive::end): Make non-const.
	(Archive::count_members): Likewise.
	* archive.h (class Archive): Update declarations.
	* object.h (Object::read): Make non-const.
	* Makefile.am (CCFILES): Add descriptors.cc.
	(HFILES): Add descriptors.h.
	* Makefile.in: Rebuild.
@
text
@d124 2
a127 2
  this->token_.add_writer(task);

@


1.41
log
@2008-06-25  Cary Coutant  <ccoutant@@google.com>

	* fileread.cc (File_read::make_view): Assert on zero-length view.
	* object.cc (Sized_relobj::do_read_symbols): Don't try to read
	symbol table when there are no symbols to read.
@
text
@d39 1
a86 3
// The File_read class is designed to support file descriptor caching,
// but this is not currently implemented.

d90 1
a90 1
  if (this->descriptor_ >= 0)
d92 1
a92 3
      if (close(this->descriptor_) < 0)
	gold_warning(_("close of %s failed: %s"),
		     this->name_.c_str(), strerror(errno));
d94 1
d107 1
d111 2
a112 1
  this->descriptor_ = ::open(this->name_.c_str(), O_RDONLY);
d116 1
d139 1
d148 16
d179 2
a180 1
  // we waste time trying to clear cached archive views.
d182 8
a189 1
    this->clear_views(false);
d271 1
a271 1
File_read::do_read(off_t start, section_size_type size, void* p) const
d285 1
d308 1
a308 1
File_read::read(off_t start, section_size_type size, void* p) const
d378 1
d523 2
@


1.40
log
@	* fileread.cc (File_read::find_view): Add byteshift and vshifted
	parameters.  Update for new key type to views_.  Change all
	callers.
	(File_read::read): Adjust for byteshift in returned view.
	(File_read::add_view): New function, broken out of
	find_and_make_view.
	(File_read::make_view): New function, broken out of
	find_and_make_view.
	(File_read::find_or_make_view): Add offset and aligned
	parameters.  Rewrite accordingly.  Change all callers.
	(File_read::get_view): Add offset and aligned parameters.  Adjust
	for byteshift in return value.
	(File_read::get_lasting_view): Likewise.
	* fileread.h (class File_read): Update declarations.
	(class File_read::View): Add byteshift_ field.  Add byteshift to
	constructor.  Add byteshift method.
	* archive.h (Archive::clear_uncached_views): New function.
	(Archive::get_view): Add aligned parameter.  Change all callers.
	* object.h (Object::get_view): Add aligned parameter.  Change all
	callers.
	(Object::get_lasting_view): Likewise.

	* fileread.cc (File_read::release): Don't call clear_views if
	there are multiple objects.
	* fileread.h (File_read::clear_uncached_views): New function.
	* archive.cc (Add_archive_symbols::run): Call clear_uncached_views
	on the archive.
@
text
@d330 2
@


1.39
log
@Update copyright years.  Update language files.
@
text
@d161 4
a164 1
  this->clear_views(false);
d202 4
d208 2
a209 1
File_read::find_view(off_t start, section_size_type size) const
d211 3
d216 5
a220 2
  Views::const_iterator p = this->views_.lower_bound(page);
  if (p == this->views_.end() || p->first > page)
d222 9
a230 4
      if (p == this->views_.begin())
	return NULL;
      --p;
    }
d232 3
a234 3
  if (p->second->start() + static_cast<off_t>(p->second->size())
      < start + static_cast<off_t>(size))
    return NULL;
d236 2
a237 1
  p->second->set_accessed();
d239 1
a239 1
  return p->second;
d284 1
a284 1
  const File_read::View* pv = this->find_view(start, size);
d287 1
a287 1
      memcpy(p, pv->data() + (start - pv->start()), size);
d294 3
a296 1
// Find an existing view or make a new one.
d298 2
a299 2
File_read::View*
File_read::find_or_make_view(off_t start, section_size_type size, bool cache)
d301 6
a306 2
  gold_assert(!this->token_.is_writable());
  this->released_ = false;
d308 6
a313 2
  File_read::View* v = this->find_view(start, size);
  if (v != NULL)
d315 2
a316 3
      if (cache)
	v->set_cache();
      return v;
d318 1
d320 2
a321 1
  off_t poff = File_read::page_offset(start);
d323 2
a324 3
  File_read::View* const vnull = NULL;
  std::pair<Views::iterator, bool> ins =
    this->views_.insert(std::make_pair(poff, vnull));
d326 5
a330 15
  if (!ins.second)
    {
      // There was an existing view at this offset.  It must not be
      // large enough.  We can't delete it here, since something might
      // be using it; put it on a list to be deleted when the file is
      // unlocked.
      v = ins.first->second;
      gold_assert(v->size() - (start - v->start()) < size);
      if (v->should_cache())
	cache = true;
      v->clear_cache();
      this->saved_views_.push_back(v);
    }

  // We need to map data from the file.
d340 2
a341 1
  if (this->contents_ != NULL)
d343 4
a346 3
      unsigned char* p = new unsigned char[psize];
      this->do_read(poff, psize, p);
      v = new File_read::View(poff, psize, p, cache, false);
d362 1
a362 1
      v = new File_read::View(poff, psize, pbytes, cache, true);
d365 2
a366 1
  ins.first->second = v;
d370 62
d435 2
a436 1
File_read::get_view(off_t start, section_size_type size, bool cache)
d438 3
a440 2
  File_read::View* pv = this->find_or_make_view(start, size, cache);
  return pv->data() + (start - pv->start());
d444 2
a445 1
File_read::get_lasting_view(off_t start, section_size_type size, bool cache)
d447 2
a448 1
  File_read::View* pv = this->find_or_make_view(start, size, cache);
d450 3
a452 1
  return new File_view(*this, pv, pv->data() + (start - pv->start()));
d544 2
a545 1
						  end_off - i_off);
d551 2
a552 1
					+ (base + i_off - view->start()));
@


1.38
log
@From Craig Silverstein: Implement --debug=files to track file opens,
and implement --verbose as a synonym.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.37
log
@From Craig Silverstein: rename some option functions in preparation
for reworking option handling.
@
text
@d33 1
d122 2
@


1.36
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d646 1
a646 1
	  || this->input_argument_->options().Bstatic())
d694 1
a694 1
    this->input_argument_->options().format();
@


1.35
log
@From Craig Silverstein: rename option functions for future option
handling rewrite.
@
text
@d717 1
a717 1
Input_file::open_binary(const General_options& options,
d723 3
a725 3
  Target* target;
  if (parameters->is_target_valid())
    target = parameters->target();
d727 1
a727 1
    target = options.default_target();
@


1.34
log
@Support selecting target by name.
@
text
@d646 1
a646 1
	  || this->input_argument_->options().do_static_search())
d694 1
a694 1
    this->input_argument_->options().input_format();
@


1.33
log
@Add support for --format binary for input files.
@
text
@d701 1
a701 1
      ok = this->open_binary(task, name);
d717 2
a718 1
Input_file::open_binary(const Task* task, const std::string& name)
d721 3
a723 5
  // endianness.  If we have a target already, use it, otherwise use
  // the defaults.
  elfcpp::EM machine;
  int size;
  bool big_endian;
d725 1
a725 6
    {
      Target* target = parameters->target();
      machine = target->machine_code();
      size = target->get_size();
      big_endian = target->is_big_endian();
    }
d727 1
a727 5
    {
      machine = elfcpp::GOLD_DEFAULT_MACHINE;
      size = GOLD_DEFAULT_SIZE;
      big_endian = GOLD_DEFAULT_BIG_ENDIAN;
    }
d729 4
a732 1
  Binary_to_elf binary_to_elf(machine, size, big_endian, name);
@


1.32
log
@Implement --just-symbols, including -R FILE.  Fix symbol values when
doing a relocatable link.
@
text
@d33 1
d36 2
d128 1
a128 1
// Open the file for testing purposes.
d692 13
a704 1
  if (!this->file_.open(task, name))
d712 32
@


1.31
log
@Don't include options.h in fileread.h.  Remove General_options
reference from Output_file class.
@
text
@d579 2
a580 1
    new Input_file_argument(name, false, "", Position_dependent_options());
d597 11
a607 1
{ return this->input_argument_->name(); }
@


1.30
log
@Add cast to avoid signed/unsigned warning.
@
text
@d584 14
@


1.29
log
@Reduce the number of system calls.  Use readv instead of pread.  Do
better handling of cached views.
@
text
@d457 5
a461 2
		  gold_assert(k_entry.file_offset - i_off + k_entry.size
			      <= end_off - i_off);
@


1.28
log
@Correct handling of non-section symbol in merged section.  Avoid some
64-bit signed/unsigned warnings.
@
text
@d30 1
d198 11
a208 4
  Views::const_iterator p = this->views_.find(page);
  if (p == this->views_.end())
    return NULL;
  if (p->second->size() - (start - page) < size)
d210 3
d258 1
a258 1
  File_read::View* pv = this->find_view(start, size);
d276 8
d292 9
a300 10
      // There was an existing view at this offset.
      File_read::View* v = ins.first->second;
      if (v->size() - (start - v->start()) >= size)
	{
	  if (cache)
	    v->set_cache();
	  return v;
	}

      // This view is not large enough.
d304 1
a304 2
  // We need to read data from the file.  We read full pages for
  // greater efficiency on small files.
a313 2
  File_read::View* v;

d322 1
a322 1
      void* p = ::mmap(NULL, psize, PROT_READ, MAP_SHARED,
d358 137
a494 1
// Remove all the file views.
d502 13
a514 2
      if (!p->second->is_locked()
	  && (destroying || !p->second->should_cache()))
d527 1
d535 1
a535 2
      if (!(*q)->is_locked()
	  && (destroying || !(*q)->should_cache()))
@


1.27
log
@Fix buglet in last patch.
@
text
@d291 1
a291 1
  if (poff + psize >= this->size_)
@


1.26
log
@Convert more instances of off_t to be 32-bit types.
@
text
@d211 1
a211 1
  section_size_type bytes;
d215 1
a215 1
      if (bytes >= size)
d223 5
a227 2
      ssize_t got = ::pread(this->descriptor_, p, size, start);
      if (got < 0)
a232 3

      if (static_cast<section_size_type>(got) == size)
	return;
@


1.25
log
@Avoid some warnings which showed up in 64-bit mode.
@
text
@d209 1
a209 1
File_read::do_read(off_t start, off_t size, void* p) const
d211 1
a211 1
  off_t bytes;
d223 2
a224 5
      bytes = ::pread(this->descriptor_, p, size, start);
      if (bytes == size)
	return;

      if (bytes < 0)
d230 3
d245 1
a245 1
File_read::read(off_t start, off_t size, void* p) const
d289 1
a289 1
  off_t psize = File_read::pages(size + (start - poff));
d294 1
a294 1
      gold_assert(psize >= static_cast<off_t>(size));
@


1.24
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d294 1
a294 1
      gold_assert(psize >= size);
@


1.23
log
@Rewrite workqueue.  This version eliminates the master thread, and
reduces the amount of locking required to find a new thread to run.
@
text
@d194 1
a194 1
File_read::find_view(off_t start, off_t size) const
d260 1
a260 1
File_read::find_or_make_view(off_t start, off_t size, bool cache)
d329 1
a329 1
File_read::get_view(off_t start, off_t size, bool cache)
d336 1
a336 1
File_read::get_lasting_view(off_t start, off_t size, bool cache)
@


1.22
log
@Add const to Object::read and Object::sized_target.
@
text
@d86 1
a86 1
  gold_assert(this->lock_count_ == 0);
d101 1
a101 1
File_read::open(const std::string& name)
d103 1
a103 1
  gold_assert(this->lock_count_ == 0
d119 1
a119 1
  ++this->lock_count_;
d127 2
a128 2
File_read::open(const std::string& name, const unsigned char* contents,
		off_t size)
d130 1
a130 1
  gold_assert(this->lock_count_ == 0
d136 1
a136 1
  ++this->lock_count_;
d140 3
d144 1
a144 1
File_read::lock()
d146 11
a156 1
  ++this->lock_count_;
d159 2
d162 1
a162 1
File_read::unlock()
d164 4
a167 9
  gold_assert(this->lock_count_ > 0);
  --this->lock_count_;
  if (this->lock_count_ == 0)
    {
      File_read::total_mapped_bytes += this->mapped_bytes_;
      File_read::current_mapped_bytes += this->mapped_bytes_;
      this->mapped_bytes_ = 0;
      if (File_read::current_mapped_bytes > File_read::maximum_mapped_bytes)
	File_read::maximum_mapped_bytes = File_read::current_mapped_bytes;
d169 7
a175 2
      this->clear_views(false);
    }
d178 2
d183 5
a187 1
  return this->lock_count_ > 0;
d262 2
a263 1
  gold_assert(this->lock_count_ > 0);
d326 1
a326 3
// This implementation of get_view just reads into a memory buffer,
// which we store on view_list_.  At some point we should support
// mmap.
a330 1
  gold_assert(this->lock_count_ > 0);
a337 1
  gold_assert(this->lock_count_ > 0);
d409 2
a410 2
Input_file::Input_file(const char* name, const unsigned char* contents,
		       off_t size)
d415 1
a415 1
  bool ok = file_.open(name, contents, size);
d429 2
a430 1
Input_file::open(const General_options& options, const Dirsearch& dirpath)
d499 1
a499 1
  if (!this->file_.open(name))
@


1.21
log
@Make some File_read methods const.
@
text
@d164 1
a164 1
File_read::is_locked()
a225 2
  gold_assert(this->lock_count_ > 0);

@


1.20
log
@Keep views on views_ list so that they can be found again.
@
text
@d173 1
a173 1
File_read::find_view(off_t start, off_t size)
d176 1
a176 1
  Views::iterator p = this->views_.find(page);
d188 1
a188 1
File_read::do_read(off_t start, off_t size, void* p)
a189 2
  gold_assert(this->lock_count_ > 0);

d224 1
a224 1
File_read::read(off_t start, off_t size, void* p)
@


1.19
log
@Implement -Bstatic/-Bdynamic.
@
text
@d334 2
a335 3
  for (Views::iterator p = this->views_.begin();
       p != this->views_.end();
       ++p)
d339 9
a347 1
	delete p->second;
d351 1
a351 1
	  this->saved_views_.push_back(p->second);
a353 1
  this->views_.clear();
d355 2
a356 2
  Saved_views::iterator p = this->saved_views_.begin();
  while (p != this->saved_views_.end())
d358 2
a359 2
      if (!(*p)->is_locked()
	  && (destroying || !(*p)->should_cache()))
d361 2
a362 2
	  delete *p;
	  p = this->saved_views_.erase(p);
d367 1
a367 1
	  ++p;
@


1.18
log
@Remove extraneous newlines.
@
text
@d431 2
a432 1
      if (options.is_static())
@


1.17
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d441 1
a441 1
	  gold_error(_("cannot find -l%s\n"),
d468 1
a468 1
              gold_error(_("cannot find %s\n"),
d479 1
a479 1
      gold_error(_("cannot open %s: %s\n"),
@


1.16
log
@Add --stats option to print runtime and memory usage statistics.
@
text
@d49 1
a49 2
        fprintf(stderr, _("%s: munmap failed: %s\n"),
                program_name, strerror(errno));
d90 2
a91 2
	fprintf(stderr, _("%s: warning: close(%s) failed: %s"),
		program_name, this->name_.c_str(), strerror(errno));
d114 2
a115 5
	{
	  fprintf(stderr, _("%s: %s: fstat failed: %s"), program_name,
		  this->name_.c_str(), strerror(errno));
	  gold_exit(false);
	}
d210 3
a212 3
	  fprintf(stderr, _("%s: %s: pread failed: %s\n"),
		  program_name, this->filename().c_str(), strerror(errno));
	  gold_exit(false);
d216 5
a220 7
  fprintf(stderr,
	  _("%s: %s: file too short: read only %lld of %lld bytes at %lld\n"),
	  program_name, this->filename().c_str(),
	  static_cast<long long>(bytes),
	  static_cast<long long>(size),
	  static_cast<long long>(start));
  gold_exit(false);
d292 5
a296 8
        {
          fprintf(stderr, _("%s: %s: mmap offset %lld size %lld failed: %s\n"),
                  program_name, this->filename().c_str(),
                  static_cast<long long>(poff),
                  static_cast<long long>(psize),
                  strerror(errno));
          gold_exit(false);
        }
d408 1
a408 1
void
d441 3
a443 3
	  fprintf(stderr, _("%s: cannot find -l%s\n"), program_name,
		  this->input_argument_->name());
	  gold_exit(false);
d468 3
a470 3
              fprintf(stderr, _("%s: cannot find %s\n"), program_name,
                      this->input_argument_->name());
              gold_exit(false);
d479 3
a481 3
      fprintf(stderr, _("%s: cannot open %s: %s\n"), program_name,
	      name.c_str(), strerror(errno));
      gold_exit(false);
d483 2
@


1.15
log
@Fix soname for library found in search path.
@
text
@d51 2
d77 5
d156 9
a164 1
    this->clear_views(false);
d307 2
d373 11
@


1.14
log
@Full support for --sysroot.
@
text
@d400 4
a403 2
    name = this->input_argument_->name();

d426 4
a430 1

d454 1
@


1.13
log
@From Craig Silverstein: add support for searching for input files
named in linker scripts.
@
text
@d417 1
a417 1
      name = dirpath.find(n1, n2);
d420 1
a420 1
	  fprintf(stderr, _("%s: cannot find %s\n"), program_name,
d440 2
a441 1
          name = dirpath.find(this->input_argument_->name(), "");
@


1.12
log
@Use mmap to read from input files.
@
text
@d30 1
d375 1
a375 1
    new Input_file_argument(name, false, Position_dependent_options());
d382 7
d393 7
a399 1
  if (!this->input_argument_->is_lib())
d401 3
a403 1
  else
d405 2
d426 25
@


1.11
log
@Add cache parameter to get_view.  Discard uncached views on unlock.
Fix bug this exposed in archive armap symbol name handling.
@
text
@d29 1
d43 8
a50 1
  delete[] this->data_;
d269 21
a289 1
  unsigned char* p = new unsigned char[psize];
d291 3
a293 1
  this->do_read(poff, psize, p);
a294 1
  File_read::View* v = new File_read::View(poff, psize, p, cache);
@


1.10
log
@Rework File_read interface.  Get file size.  Use pread when
available.
@
text
@d139 2
d165 1
a165 2
// the buffer at P.  Return the number of bytes read, which should
// always be at least SIZE except at the end of the file.
d167 1
a167 1
off_t
d172 1
d175 6
a180 7
      off_t bytes = this->size_ - start;
      if (bytes < 0)
	bytes = 0;
      else if (bytes > size)
	bytes = size;
      memcpy(p, this->contents_ + start, bytes);
      return bytes;
d182 5
d188 6
a193 6
  off_t bytes = ::pread(this->descriptor_, p, size, start);
  if (bytes < 0)
    {
      fprintf(stderr, _("%s: %s: pread failed: %s\n"),
	      program_name, this->filename().c_str(), strerror(errno));
      gold_exit(false);
d196 7
a202 21
  return bytes;
}

// Read exactly SIZE bytes from the file starting at offset START.
// Read into the buffer at P.

void
File_read::do_read_exact(off_t start, off_t size, void* p)
{
  off_t bytes = this->do_read(start, size, p);
  if (bytes != size)
    {
      fprintf(stderr,
	      _("%s: %s: file too short: read only %lld of %lld "
		"bytes at %lld\n"),
	      program_name, this->filename().c_str(),
	      static_cast<long long>(bytes),
	      static_cast<long long>(size),
	      static_cast<long long>(start));
      gold_exit(false);
    }
d219 1
a219 1
  this->do_read_exact(start, size, p);
d225 1
a225 1
File_read::find_or_make_view(off_t start, off_t size)
d240 5
a244 1
	return v;
d263 1
a263 1
  this->do_read_exact(poff, psize, p);
d265 1
a265 1
  File_read::View* v = new File_read::View(poff, psize, p);
d275 1
a275 1
File_read::get_view(off_t start, off_t size)
d278 1
a278 1
  File_read::View* pv = this->find_or_make_view(start, size);
d283 1
a283 1
File_read::get_lasting_view(off_t start, off_t size)
d286 1
a286 1
  File_read::View* pv = this->find_or_make_view(start, size);
d300 2
a301 1
      if (!p->second->is_locked())
d314 2
a315 1
      if (!(*p)->is_locked())
@


1.9
log
@Remove get_view_and_size.
@
text
@d92 1
d94 13
d108 1
d116 1
a116 1
		off_t contents_size)
d123 1
a123 1
  this->contents_size_ = contents_size;
d162 3
a164 3
// Read data from the file.  Return the number of bytes read.  If
// PBYTES is not NULL, store the number of bytes in *PBYTES, otherwise
// require that we read exactly the number of bytes requested.
d167 1
a167 1
File_read::do_read(off_t start, off_t size, void* p, off_t* pbytes)
d171 1
a171 23
  off_t bytes;
  if (this->contents_ == NULL)
    {
      int o = this->descriptor_;

      if (lseek(o, start, SEEK_SET) < 0)
	{
	  fprintf(stderr, _("%s: %s: lseek to %lld failed: %s"),
		  program_name, this->filename().c_str(),
		  static_cast<long long>(start),
		  strerror(errno));
	  gold_exit(false);
	}

      bytes = ::read(o, p, size);
      if (bytes < 0)
	{
	  fprintf(stderr, _("%s: %s: read failed: %s\n"),
		  program_name, this->filename().c_str(), strerror(errno));
	  gold_exit(false);
	}
    }
  else
d173 1
a173 1
      bytes = this->contents_size_ - start;
d179 1
d182 19
a200 3
  if (pbytes != NULL)
    *pbytes = bytes;
  else if (bytes != size)
a210 2

  return bytes;
d227 1
a227 18
  this->do_read(start, size, p, NULL);
}

void
File_read::read_up_to(off_t start, off_t size, void* p, off_t* pbytes)
{
  gold_assert(this->lock_count_ > 0);

  File_read::View* pv = this->find_view(start, size);
  if (pv != NULL)
    {
      memcpy(p, pv->data() + (start - pv->start()), size);
      if (pbytes != NULL)
	*pbytes = size;
      return;
    }

  this->do_read(start, size, p, pbytes);
d254 2
a255 1
  // We need to read data from the file.
d258 7
d267 1
a267 4
  off_t got_bytes;
  off_t bytes = this->do_read(poff, psize, p, &got_bytes);

  File_read::View* v = new File_read::View(poff, bytes, p);
d269 1
d271 1
a271 11

  if (bytes - (start - poff) >= size)
    return v;

  fprintf(stderr,
	  _("%s: %s: file too short: read only %lld of %lld bytes at %lld\n"),
	  program_name, this->filename().c_str(),
	  static_cast<long long>(bytes - (start - poff)),
	  static_cast<long long>(size),
	  static_cast<long long>(start));
  gold_exit(false);
@


1.8
log
@Break out default pbytes argument to read and get_view routines,
adding new routines.
@
text
@d242 1
a242 1
File_read::find_or_make_view(off_t start, off_t size, off_t* pbytes)
d257 1
a257 5
	{
	  if (pbytes != NULL)
	    *pbytes = size;
	  return v;
	}
d276 1
a276 11
    {
      if (pbytes != NULL)
	*pbytes = size;
      return v;
    }

  if (pbytes != NULL)
    {
      *pbytes = bytes - (start - poff);
      return v;
    }
d295 1
a295 9
  File_read::View* pv = this->find_or_make_view(start, size, NULL);
  return pv->data() + (start - pv->start());
}

const unsigned char*
File_read::get_view_and_size(off_t start, off_t size, off_t* pbytes)
{
  gold_assert(this->lock_count_ > 0);
  File_read::View* pv = this->find_or_make_view(start, size, pbytes);
d303 1
a303 1
  File_read::View* pv = this->find_or_make_view(start, size, NULL);
@


1.7
log
@Add licensing text to every source file.
@
text
@d205 2
d208 16
a223 1
File_read::read(off_t start, off_t size, void* p, off_t* pbytes)
d306 9
a314 1
File_read::get_view(off_t start, off_t size, off_t* pbytes)
d322 1
a322 1
File_read::get_lasting_view(off_t start, off_t size, off_t* pbytes)
d325 1
a325 1
  File_read::View* pv = this->find_or_make_view(start, size, pbytes);
@


1.6
log
@Added a testsuite.  More support for COPY relocations.
@
text
@d3 20
@


1.5
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d63 2
d77 5
a81 2
int
File_read::get_descriptor()
d83 8
a90 2
  gold_assert(this->lock_count_ > 0);
  return this->descriptor_;
a134 1
  int o = this->descriptor_;
d136 2
a137 1
  if (lseek(o, start, SEEK_SET) < 0)
d139 18
a156 5
      fprintf(stderr, _("%s: %s: lseek to %lld failed: %s"),
	      program_name, this->filename().c_str(),
	      static_cast<long long>(start),
	      strerror(errno));
      gold_exit(false);
d158 1
a158 3

  off_t bytes = ::read(o, p, size);
  if (bytes < 0)
d160 6
a165 3
      fprintf(stderr, _("%s: %s: read failed: %s\n"),
	      program_name, this->filename().c_str(), strerror(errno));
      gold_exit(false);
d330 14
d348 2
a349 2
  if (!this->input_argument_.is_lib())
    name = this->input_argument_.name();
d353 1
a353 1
      n1 += this->input_argument_.name();
d366 1
a366 1
		  this->input_argument_.name());
@


1.4
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@a4 1
#include <cassert>
d21 1
a21 1
  assert(!this->is_locked());
d34 1
a34 1
  assert(this->lock_count_ > 0);
d51 1
a51 1
  assert(this->lock_count_ == 0);
d66 3
a68 3
  assert(this->lock_count_ == 0
	 && this->descriptor_ < 0
	 && this->name_.empty());
d78 1
a78 1
  assert(this->lock_count_ > 0);
d91 1
a91 1
  assert(this->lock_count_ > 0);
d123 1
a123 1
  assert(this->lock_count_ > 0);
d163 1
a163 1
  assert(this->lock_count_ > 0);
d182 1
a182 1
  assert(this->lock_count_ > 0);
d246 1
a246 1
  assert(this->lock_count_ > 0);
d254 1
a254 1
  assert(this->lock_count_ > 0);
d273 1
a273 1
	  assert(!destroying);
d289 1
a289 1
	  assert(!destroying);
d299 1
a299 1
  assert(this->file_.is_locked());
@


1.3
log
@Can now do a full static link of hello, world in C or C++
@
text
@d317 7
a323 3
      if (!options.is_static())
	n2 = n1 + ".so";
      n1 += ".a";
@


1.2
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d105 1
a105 1
File_read::View*
d108 7
a114 9
  for (std::list<File_read::View*>::iterator p = this->view_list_.begin();
       p != this->view_list_.end();
       ++p)
    {
      if ((*p)->start() <= start
	  && (*p)->start() + (*p)->size() >= start + size)
	return *p;
    }
  return NULL;
d185 45
a229 3
  File_read::View* pv = this->find_view(start, size);
  if (pv != NULL)
    return pv;
d231 7
a237 5
  unsigned char* p = new unsigned char[size];
  off_t bytes = this->do_read(start, size, p, pbytes);
  pv = new File_read::View(start, bytes, p);
  this->view_list_.push_back(pv);
  return pv;
d266 3
a268 2
  std::list<File_read::View*>::iterator p = this->view_list_.begin();
  while (p != this->view_list_.end())
d270 3
a272 1
      if ((*p)->is_locked())
d275 12
a286 1
	  ++p;
d290 2
a291 2
	  delete *p;
	  p = this->view_list_.erase(p);
@


1.1
log
@Initial CVS checkin of gold
@
text
@d259 1
a259 1
      n1 += this->input_argument_.lib_basename();
d261 1
a261 1
      if (options.is_static())
d267 1
a267 1
	  fprintf(stderr, _("%s: cannot find %s"), program_name,
d275 2
a276 2
      fprintf(stderr, _("%s: cannot open %s: %s"), program_name, name.c_str(),
	      strerror(errno));
@

