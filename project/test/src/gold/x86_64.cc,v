head	1.166;
access;
symbols
	binutils-2_24-branch:1.165.0.2
	binutils-2_24-branchpoint:1.165
	binutils-2_21_1:1.118
	binutils-2_23_2:1.153.2.2
	binutils-2_23_1:1.153.2.1
	binutils-2_23:1.153
	binutils-2_23-branch:1.153.0.2
	binutils-2_23-branchpoint:1.153
	binutils-2_22_branch:1.139.0.4
	binutils-2_22:1.139
	binutils-2_22-branch:1.139.0.2
	binutils-2_22-branchpoint:1.139
	binutils-2_21:1.118
	binutils-2_21-branch:1.118.0.2
	binutils-2_21-branchpoint:1.118
	binutils-2_20_1:1.85.2.3
	binutils-2_20:1.85.2.1
	binutils-arc-20081103-branch:1.76.0.4
	binutils-arc-20081103-branchpoint:1.76
	binutils-2_20-branch:1.85.0.2
	binutils-2_20-branchpoint:1.85
	dje-cgen-play1-branch:1.83.0.2
	dje-cgen-play1-branchpoint:1.83
	arc-20081103-branch:1.76.0.2
	arc-20081103-branchpoint:1.76
	binutils-2_19_1:1.73
	binutils-2_19:1.73
	binutils-2_19-branch:1.73.0.2
	binutils-2_19-branchpoint:1.73
	binutils_latest_snapshot:1.166
	added-to-binutils:1.54;
locks; strict;
comment	@// @;


1.166
date	2013.10.11.21.11.49;	author roland;	state Exp;
branches;
next	1.165;

1.165
date	2013.09.03.17.38.57;	author hjl;	state Exp;
branches
	1.165.2.1;
next	1.164;

1.164
date	2013.08.16.18.12.05;	author roland;	state Exp;
branches;
next	1.163;

1.163
date	2013.07.30.21.26.53;	author ccoutant;	state Exp;
branches;
next	1.162;

1.162
date	2013.04.27.00.53.16;	author ian;	state Exp;
branches;
next	1.161;

1.161
date	2012.11.20.05.56.06;	author hjl;	state Exp;
branches;
next	1.160;

1.160
date	2012.11.01.23.27.00;	author roland;	state Exp;
branches;
next	1.159;

1.159
date	2012.10.18.04.18.18;	author amodra;	state Exp;
branches;
next	1.158;

1.158
date	2012.10.05.00.45.54;	author amodra;	state Exp;
branches;
next	1.157;

1.157
date	2012.09.12.22.43.54;	author amodra;	state Exp;
branches;
next	1.156;

1.156
date	2012.09.10.23.05.54;	author amodra;	state Exp;
branches;
next	1.155;

1.155
date	2012.09.05.00.34.20;	author amodra;	state Exp;
branches;
next	1.154;

1.154
date	2012.08.15.04.03.54;	author ian;	state Exp;
branches;
next	1.153;

1.153
date	2012.05.11.11.10.19;	author hjl;	state Exp;
branches
	1.153.2.1;
next	1.152;

1.152
date	2012.05.02.21.37.23;	author roland;	state Exp;
branches;
next	1.151;

1.151
date	2012.04.17.01.50.39;	author davem;	state Exp;
branches;
next	1.150;

1.150
date	2012.01.27.23.29.54;	author hjl;	state Exp;
branches;
next	1.149;

1.149
date	2012.01.27.23.26.55;	author hjl;	state Exp;
branches;
next	1.148;

1.148
date	2012.01.24.06.21.11;	author ian;	state Exp;
branches;
next	1.147;

1.147
date	2012.01.20.00.43.57;	author hjl;	state Exp;
branches;
next	1.146;

1.146
date	2012.01.10.20.58.36;	author hjl;	state Exp;
branches;
next	1.145;

1.145
date	2012.01.09.17.42.34;	author hjl;	state Exp;
branches;
next	1.144;

1.144
date	2012.01.04.00.18.23;	author ccoutant;	state Exp;
branches;
next	1.143;

1.143
date	2011.12.19.21.07.16;	author ian;	state Exp;
branches;
next	1.142;

1.142
date	2011.12.17.22.39.52;	author ccoutant;	state Exp;
branches;
next	1.141;

1.141
date	2011.10.31.22.33.04;	author ccoutant;	state Exp;
branches;
next	1.140;

1.140
date	2011.10.10.17.29.52;	author ccoutant;	state Exp;
branches;
next	1.139;

1.139
date	2011.07.15.15.31.54;	author ian;	state Exp;
branches
	1.139.2.1;
next	1.138;

1.138
date	2011.07.13.22.47.07;	author ian;	state Exp;
branches;
next	1.137;

1.137
date	2011.07.12.22.29.09;	author ian;	state Exp;
branches;
next	1.136;

1.136
date	2011.07.09.00.47.12;	author ian;	state Exp;
branches;
next	1.135;

1.135
date	2011.07.08.23.49.11;	author ian;	state Exp;
branches;
next	1.134;

1.134
date	2011.07.08.22.48.08;	author ian;	state Exp;
branches;
next	1.133;

1.133
date	2011.07.06.05.12.03;	author ian;	state Exp;
branches;
next	1.132;

1.132
date	2011.07.02.00.03.25;	author ian;	state Exp;
branches;
next	1.131;

1.131
date	2011.07.01.22.05.01;	author ian;	state Exp;
branches;
next	1.130;

1.130
date	2011.06.28.23.12.31;	author ian;	state Exp;
branches;
next	1.129;

1.129
date	2011.06.28.22.25.14;	author ian;	state Exp;
branches;
next	1.128;

1.128
date	2011.06.28.21.15.42;	author ian;	state Exp;
branches;
next	1.127;

1.127
date	2011.06.17.11.15.34;	author ian;	state Exp;
branches;
next	1.126;

1.126
date	2011.06.08.04.43.28;	author ccoutant;	state Exp;
branches;
next	1.125;

1.125
date	2011.06.08.03.50.12;	author ccoutant;	state Exp;
branches;
next	1.124;

1.124
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.123;

1.123
date	2011.05.23.23.27.10;	author ccoutant;	state Exp;
branches;
next	1.122;

1.122
date	2011.04.22.22.39.55;	author ccoutant;	state Exp;
branches;
next	1.121;

1.121
date	2010.12.15.15.35.27;	author ian;	state Exp;
branches;
next	1.120;

1.120
date	2010.12.14.19.03.30;	author rwild;	state Exp;
branches;
next	1.119;

1.119
date	2010.11.11.10.43.30;	author rsandifo;	state Exp;
branches;
next	1.118;

1.118
date	2010.09.28.17.14.15;	author tmsriram;	state Exp;
branches;
next	1.117;

1.117
date	2010.09.14.21.44.21;	author ccoutant;	state Exp;
branches;
next	1.116;

1.116
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.115;

1.115
date	2010.08.19.22.50.15;	author ian;	state Exp;
branches;
next	1.114;

1.114
date	2010.08.12.22.15.00;	author ccoutant;	state Exp;
branches;
next	1.113;

1.113
date	2010.08.04.09.53.37;	author ian;	state Exp;
branches;
next	1.112;

1.112
date	2010.08.03.14.07.13;	author ian;	state Exp;
branches;
next	1.111;

1.111
date	2010.08.02.10.07.03;	author ian;	state Exp;
branches;
next	1.110;

1.110
date	2010.07.29.18.57.28;	author tmsriram;	state Exp;
branches;
next	1.109;

1.109
date	2010.07.13.12.04.03;	author ian;	state Exp;
branches;
next	1.108;

1.108
date	2010.04.20.21.13.30;	author tmsriram;	state Exp;
branches;
next	1.107;

1.107
date	2010.02.13.02.04.21;	author tmsriram;	state Exp;
branches;
next	1.106;

1.106
date	2010.02.10.23.00.29;	author ian;	state Exp;
branches;
next	1.105;

1.105
date	2010.02.09.20.29.44;	author davem;	state Exp;
branches;
next	1.104;

1.104
date	2010.01.08.19.33.18;	author ian;	state Exp;
branches;
next	1.103;

1.103
date	2010.01.07.20.43.35;	author ian;	state Exp;
branches;
next	1.102;

1.102
date	2009.12.30.07.22.06;	author ian;	state Exp;
branches;
next	1.101;

1.101
date	2009.12.30.06.57.17;	author ian;	state Exp;
branches;
next	1.100;

1.100
date	2009.12.29.00.31.48;	author ian;	state Exp;
branches;
next	1.99;

1.99
date	2009.12.24.07.48.14;	author ian;	state Exp;
branches;
next	1.98;

1.98
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.97;

1.97
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	2009.12.07.17.14.55;	author hjl;	state Exp;
branches;
next	1.95;

1.95
date	2009.12.06.02.49.46;	author dougkwan;	state Exp;
branches;
next	1.94;

1.94
date	2009.12.03.23.13.55;	author dougkwan;	state Exp;
branches;
next	1.93;

1.93
date	2009.11.09.23.07.30;	author dougkwan;	state Exp;
branches;
next	1.92;

1.92
date	2009.11.04.16.35.51;	author ian;	state Exp;
branches;
next	1.91;

1.91
date	2009.11.04.15.56.03;	author ian;	state Exp;
branches;
next	1.90;

1.90
date	2009.10.30.18.49.59;	author dougkwan;	state Exp;
branches;
next	1.89;

1.89
date	2009.10.29.05.16.23;	author ian;	state Exp;
branches;
next	1.88;

1.88
date	2009.10.13.00.39.31;	author tmsriram;	state Exp;
branches;
next	1.87;

1.87
date	2009.10.06.22.58.27;	author ian;	state Exp;
branches;
next	1.86;

1.86
date	2009.10.01.00.58.38;	author dougkwan;	state Exp;
branches;
next	1.85;

1.85
date	2009.08.07.18.29.53;	author tmsriram;	state Exp;
branches
	1.85.2.1;
next	1.84;

1.84
date	2009.07.21.05.22.54;	author ian;	state Exp;
branches;
next	1.83;

1.83
date	2009.06.22.06.51.53;	author ian;	state Exp;
branches;
next	1.82;

1.82
date	2009.04.27.16.23.57;	author ian;	state Exp;
branches;
next	1.81;

1.81
date	2009.03.27.18.19.09;	author ccoutant;	state Exp;
branches;
next	1.80;

1.80
date	2009.03.24.00.31.29;	author ian;	state Exp;
branches;
next	1.79;

1.79
date	2009.03.04.06.46.27;	author ian;	state Exp;
branches;
next	1.78;

1.78
date	2009.01.30.00.21.46;	author ccoutant;	state Exp;
branches;
next	1.77;

1.77
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	1.76;

1.76
date	2008.09.16.17.23.37;	author ian;	state Exp;
branches;
next	1.75;

1.75
date	2008.09.16.04.31.25;	author aoliva;	state Exp;
branches;
next	1.74;

1.74
date	2008.09.16.04.23.29;	author aoliva;	state Exp;
branches;
next	1.73;

1.73
date	2008.08.15.04.57.46;	author ccoutant;	state Exp;
branches;
next	1.72;

1.72
date	2008.08.04.22.22.13;	author ian;	state Exp;
branches;
next	1.71;

1.71
date	2008.07.10.23.01.20;	author ian;	state Exp;
branches;
next	1.70;

1.70
date	2008.05.21.21.37.44;	author ian;	state Exp;
branches;
next	1.69;

1.69
date	2008.05.20.04.00.46;	author ian;	state Exp;
branches;
next	1.68;

1.68
date	2008.05.16.20.44.22;	author ian;	state Exp;
branches;
next	1.67;

1.67
date	2008.05.16.15.27.49;	author ian;	state Exp;
branches;
next	1.66;

1.66
date	2008.05.06.05.03.15;	author ian;	state Exp;
branches;
next	1.65;

1.65
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.64;

1.64
date	2008.04.17.02.00.54;	author ccoutant;	state Exp;
branches;
next	1.63;

1.63
date	2008.04.16.22.54.29;	author ian;	state Exp;
branches;
next	1.62;

1.62
date	2008.04.11.23.37.24;	author ccoutant;	state Exp;
branches;
next	1.61;

1.61
date	2008.04.11.21.24.30;	author ccoutant;	state Exp;
branches;
next	1.60;

1.60
date	2008.04.09.00.48.13;	author ian;	state Exp;
branches;
next	1.59;

1.59
date	2008.04.08.04.09.59;	author ian;	state Exp;
branches;
next	1.58;

1.58
date	2008.03.26.23.36.46;	author ian;	state Exp;
branches;
next	1.57;

1.57
date	2008.03.25.21.39.01;	author ian;	state Exp;
branches;
next	1.56;

1.56
date	2008.03.25.18.37.16;	author ccoutant;	state Exp;
branches;
next	1.55;

1.55
date	2008.03.24.21.42.22;	author ian;	state Exp;
branches;
next	1.54;

1.54
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.53;

1.53
date	2008.02.29.19.19.17;	author iant;	state Exp;
branches;
next	1.52;

1.52
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.51;

1.51
date	2008.02.27.22.38.18;	author iant;	state Exp;
branches;
next	1.50;

1.50
date	2008.02.26.22.10.32;	author iant;	state Exp;
branches;
next	1.49;

1.49
date	2008.02.13.02.44.50;	author iant;	state Exp;
branches;
next	1.48;

1.48
date	2008.02.12.00.28.48;	author iant;	state Exp;
branches;
next	1.47;

1.47
date	2008.02.08.22.49.22;	author iant;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.06.08.13.50;	author iant;	state Exp;
branches;
next	1.45;

1.45
date	2008.02.01.00.39.09;	author iant;	state Exp;
branches;
next	1.44;

1.44
date	2008.01.26.01.17.45;	author iant;	state Exp;
branches;
next	1.43;

1.43
date	2008.01.23.07.15.59;	author iant;	state Exp;
branches;
next	1.42;

1.42
date	2007.12.21.23.31.19;	author iant;	state Exp;
branches;
next	1.41;

1.41
date	2007.12.20.21.21.24;	author iant;	state Exp;
branches;
next	1.40;

1.40
date	2007.12.11.23.30.52;	author iant;	state Exp;
branches;
next	1.39;

1.39
date	2007.12.11.21.21.14;	author iant;	state Exp;
branches;
next	1.38;

1.38
date	2007.12.07.23.26.51;	author iant;	state Exp;
branches;
next	1.37;

1.37
date	2007.12.07.19.32.59;	author iant;	state Exp;
branches;
next	1.36;

1.36
date	2007.12.07.00.59.31;	author iant;	state Exp;
branches;
next	1.35;

1.35
date	2007.12.06.05.55.50;	author iant;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.29.20.10.17;	author iant;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.15.23.46.46;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.15.01.12.55;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.14.22.31.02;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.14.16.53.25;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.14.08.03.41;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.14.07.52.21;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.12.17.51.55;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.09.19.45.08;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.11.02.04.08.52;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.01.00.19.30;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.30.04.23.19;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.30.01.21.51;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.29.23.36.39;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.29.20.09.35;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.23.05.05.48;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.22.23.08.22;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.20.04.33.21;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.16.22.38.35;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.16.00.42.36;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.15.03.39.16;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.14.06.57.58;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.14.06.49.14;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.13.00.15.07;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.12.06.00.55;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.11.19.13.02;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.04.22.28.36;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.03.20.50.53;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.03.05.40.11;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.02.22.10.10;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.01.23.42.58;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.01.22.21.58;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.01.21.30.59;	author iant;	state Exp;
branches;
next	;

1.165.2.1
date	2013.10.11.21.23.43;	author roland;	state Exp;
branches;
next	;

1.153.2.1
date	2012.11.07.17.34.23;	author roland;	state Exp;
branches;
next	1.153.2.2;

1.153.2.2
date	2012.11.20.05.57.53;	author hjl;	state Exp;
branches;
next	1.153.2.3;

1.153.2.3
date	2013.08.16.18.12.30;	author roland;	state Exp;
branches;
next	;

1.139.2.1
date	2011.12.19.21.14.40;	author ian;	state Exp;
branches;
next	;

1.85.2.1
date	2009.10.16.05.51.18;	author ian;	state Exp;
branches;
next	1.85.2.2;

1.85.2.2
date	2009.11.04.15.56.34;	author ian;	state Exp;
branches;
next	1.85.2.3;

1.85.2.3
date	2009.11.04.16.36.08;	author ian;	state Exp;
branches;
next	;


desc
@@


1.166
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@// x86_64.cc -- x86_64 target support for gold.

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cstring>

#include "elfcpp.h"
#include "dwarf.h"
#include "parameters.h"
#include "reloc.h"
#include "x86_64.h"
#include "object.h"
#include "symtab.h"
#include "layout.h"
#include "output.h"
#include "copy-relocs.h"
#include "target.h"
#include "target-reloc.h"
#include "target-select.h"
#include "tls.h"
#include "freebsd.h"
#include "nacl.h"
#include "gc.h"
#include "icf.h"

namespace
{

using namespace gold;

// A class to handle the PLT data.
// This is an abstract base class that handles most of the linker details
// but does not know the actual contents of PLT entries.  The derived
// classes below fill in those details.

template<int size>
class Output_data_plt_x86_64 : public Output_section_data
{
 public:
  typedef Output_data_reloc<elfcpp::SHT_RELA, true, size, false> Reloc_section;

  Output_data_plt_x86_64(Layout* layout, uint64_t addralign,
			 Output_data_got<64, false>* got,
			 Output_data_space* got_plt,
			 Output_data_space* got_irelative)
    : Output_section_data(addralign), layout_(layout), tlsdesc_rel_(NULL),
      irelative_rel_(NULL), got_(got), got_plt_(got_plt),
      got_irelative_(got_irelative), count_(0), irelative_count_(0),
      tlsdesc_got_offset_(-1U), free_list_()
  { this->init(layout); }

  Output_data_plt_x86_64(Layout* layout, uint64_t plt_entry_size,
			 Output_data_got<64, false>* got,
			 Output_data_space* got_plt,
			 Output_data_space* got_irelative,
			 unsigned int plt_count)
    : Output_section_data((plt_count + 1) * plt_entry_size,
			  plt_entry_size, false),
      layout_(layout), tlsdesc_rel_(NULL), irelative_rel_(NULL), got_(got),
      got_plt_(got_plt), got_irelative_(got_irelative), count_(plt_count),
      irelative_count_(0), tlsdesc_got_offset_(-1U), free_list_()
  {
    this->init(layout);

    // Initialize the free list and reserve the first entry.
    this->free_list_.init((plt_count + 1) * plt_entry_size, false);
    this->free_list_.remove(0, plt_entry_size);
  }

  // Initialize the PLT section.
  void
  init(Layout* layout);

  // Add an entry to the PLT.
  void
  add_entry(Symbol_table*, Layout*, Symbol* gsym);

  // Add an entry to the PLT for a local STT_GNU_IFUNC symbol.
  unsigned int
  add_local_ifunc_entry(Symbol_table* symtab, Layout*,
			Sized_relobj_file<size, false>* relobj,
			unsigned int local_sym_index);

  // Add the relocation for a PLT entry.
  void
  add_relocation(Symbol_table*, Layout*, Symbol* gsym,
		 unsigned int got_offset);

  // Add the reserved TLSDESC_PLT entry to the PLT.
  void
  reserve_tlsdesc_entry(unsigned int got_offset)
  { this->tlsdesc_got_offset_ = got_offset; }

  // Return true if a TLSDESC_PLT entry has been reserved.
  bool
  has_tlsdesc_entry() const
  { return this->tlsdesc_got_offset_ != -1U; }

  // Return the GOT offset for the reserved TLSDESC_PLT entry.
  unsigned int
  get_tlsdesc_got_offset() const
  { return this->tlsdesc_got_offset_; }

  // Return the offset of the reserved TLSDESC_PLT entry.
  unsigned int
  get_tlsdesc_plt_offset() const
  {
    return ((this->count_ + this->irelative_count_ + 1)
	    * this->get_plt_entry_size());
  }

  // Return the .rela.plt section data.
  Reloc_section*
  rela_plt()
  { return this->rel_; }

  // Return where the TLSDESC relocations should go.
  Reloc_section*
  rela_tlsdesc(Layout*);

  // Return where the IRELATIVE relocations should go in the PLT
  // relocations.
  Reloc_section*
  rela_irelative(Symbol_table*, Layout*);

  // Return whether we created a section for IRELATIVE relocations.
  bool
  has_irelative_section() const
  { return this->irelative_rel_ != NULL; }

  // Return the number of PLT entries.
  unsigned int
  entry_count() const
  { return this->count_ + this->irelative_count_; }

  // Return the offset of the first non-reserved PLT entry.
  unsigned int
  first_plt_entry_offset()
  { return this->get_plt_entry_size(); }

  // Return the size of a PLT entry.
  unsigned int
  get_plt_entry_size() const
  { return this->do_get_plt_entry_size(); }

  // Reserve a slot in the PLT for an existing symbol in an incremental update.
  void
  reserve_slot(unsigned int plt_index)
  {
    this->free_list_.remove((plt_index + 1) * this->get_plt_entry_size(),
			    (plt_index + 2) * this->get_plt_entry_size());
  }

  // Return the PLT address to use for a global symbol.
  uint64_t
  address_for_global(const Symbol*);

  // Return the PLT address to use for a local symbol.
  uint64_t
  address_for_local(const Relobj*, unsigned int symndx);

  // Add .eh_frame information for the PLT.
  void
  add_eh_frame(Layout* layout)
  { this->do_add_eh_frame(layout); }

 protected:
  // Fill in the first PLT entry.
  void
  fill_first_plt_entry(unsigned char* pov,
		       typename elfcpp::Elf_types<size>::Elf_Addr got_address,
		       typename elfcpp::Elf_types<size>::Elf_Addr plt_address)
  { this->do_fill_first_plt_entry(pov, got_address, plt_address); }

  // Fill in a normal PLT entry.  Returns the offset into the entry that
  // should be the initial GOT slot value.
  unsigned int
  fill_plt_entry(unsigned char* pov,
		 typename elfcpp::Elf_types<size>::Elf_Addr got_address,
		 typename elfcpp::Elf_types<size>::Elf_Addr plt_address,
		 unsigned int got_offset,
		 unsigned int plt_offset,
		 unsigned int plt_index)
  {
    return this->do_fill_plt_entry(pov, got_address, plt_address,
				   got_offset, plt_offset, plt_index);
  }

  // Fill in the reserved TLSDESC PLT entry.
  void
  fill_tlsdesc_entry(unsigned char* pov,
		     typename elfcpp::Elf_types<size>::Elf_Addr got_address,
		     typename elfcpp::Elf_types<size>::Elf_Addr plt_address,
		     typename elfcpp::Elf_types<size>::Elf_Addr got_base,
		     unsigned int tlsdesc_got_offset,
		     unsigned int plt_offset)
  {
    this->do_fill_tlsdesc_entry(pov, got_address, plt_address, got_base,
				tlsdesc_got_offset, plt_offset);
  }

  virtual unsigned int
  do_get_plt_entry_size() const = 0;

  virtual void
  do_fill_first_plt_entry(unsigned char* pov,
			  typename elfcpp::Elf_types<size>::Elf_Addr got_addr,
			  typename elfcpp::Elf_types<size>::Elf_Addr plt_addr)
    = 0;

  virtual unsigned int
  do_fill_plt_entry(unsigned char* pov,
		    typename elfcpp::Elf_types<size>::Elf_Addr got_address,
		    typename elfcpp::Elf_types<size>::Elf_Addr plt_address,
		    unsigned int got_offset,
		    unsigned int plt_offset,
		    unsigned int plt_index) = 0;

  virtual void
  do_fill_tlsdesc_entry(unsigned char* pov,
			typename elfcpp::Elf_types<size>::Elf_Addr got_address,
			typename elfcpp::Elf_types<size>::Elf_Addr plt_address,
			typename elfcpp::Elf_types<size>::Elf_Addr got_base,
			unsigned int tlsdesc_got_offset,
			unsigned int plt_offset) = 0;

  virtual void
  do_add_eh_frame(Layout* layout) = 0;

  void
  do_adjust_output_section(Output_section* os);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** PLT")); }

  // The CIE of the .eh_frame unwind information for the PLT.
  static const int plt_eh_frame_cie_size = 16;
  static const unsigned char plt_eh_frame_cie[plt_eh_frame_cie_size];

 private:
  // Set the final size.
  void
  set_final_data_size();

  // Write out the PLT data.
  void
  do_write(Output_file*);

  // A pointer to the Layout class, so that we can find the .dynamic
  // section when we write out the GOT PLT section.
  Layout* layout_;
  // The reloc section.
  Reloc_section* rel_;
  // The TLSDESC relocs, if necessary.  These must follow the regular
  // PLT relocs.
  Reloc_section* tlsdesc_rel_;
  // The IRELATIVE relocs, if necessary.  These must follow the
  // regular PLT relocations and the TLSDESC relocations.
  Reloc_section* irelative_rel_;
  // The .got section.
  Output_data_got<64, false>* got_;
  // The .got.plt section.
  Output_data_space* got_plt_;
  // The part of the .got.plt section used for IRELATIVE relocs.
  Output_data_space* got_irelative_;
  // The number of PLT entries.
  unsigned int count_;
  // Number of PLT entries with R_X86_64_IRELATIVE relocs.  These
  // follow the regular PLT entries.
  unsigned int irelative_count_;
  // Offset of the reserved TLSDESC_GOT entry when needed.
  unsigned int tlsdesc_got_offset_;
  // List of available regions within the section, for incremental
  // update links.
  Free_list free_list_;
};

template<int size>
class Output_data_plt_x86_64_standard : public Output_data_plt_x86_64<size>
{
 public:
  Output_data_plt_x86_64_standard(Layout* layout,
				  Output_data_got<64, false>* got,
				  Output_data_space* got_plt,
				  Output_data_space* got_irelative)
    : Output_data_plt_x86_64<size>(layout, plt_entry_size,
				   got, got_plt, got_irelative)
  { }

  Output_data_plt_x86_64_standard(Layout* layout,
				  Output_data_got<64, false>* got,
				  Output_data_space* got_plt,
				  Output_data_space* got_irelative,
				  unsigned int plt_count)
    : Output_data_plt_x86_64<size>(layout, plt_entry_size,
				   got, got_plt, got_irelative,
				   plt_count)
  { }

 protected:
  virtual unsigned int
  do_get_plt_entry_size() const
  { return plt_entry_size; }

  virtual void
  do_add_eh_frame(Layout* layout)
  {
    layout->add_eh_frame_for_plt(this,
				 this->plt_eh_frame_cie,
				 this->plt_eh_frame_cie_size,
				 plt_eh_frame_fde,
				 plt_eh_frame_fde_size);
  }

  virtual void
  do_fill_first_plt_entry(unsigned char* pov,
			  typename elfcpp::Elf_types<size>::Elf_Addr got_addr,
			  typename elfcpp::Elf_types<size>::Elf_Addr plt_addr);

  virtual unsigned int
  do_fill_plt_entry(unsigned char* pov,
		    typename elfcpp::Elf_types<size>::Elf_Addr got_address,
		    typename elfcpp::Elf_types<size>::Elf_Addr plt_address,
		    unsigned int got_offset,
		    unsigned int plt_offset,
		    unsigned int plt_index);

  virtual void
  do_fill_tlsdesc_entry(unsigned char* pov,
			typename elfcpp::Elf_types<size>::Elf_Addr got_address,
			typename elfcpp::Elf_types<size>::Elf_Addr plt_address,
			typename elfcpp::Elf_types<size>::Elf_Addr got_base,
			unsigned int tlsdesc_got_offset,
			unsigned int plt_offset);

 private:
  // The size of an entry in the PLT.
  static const int plt_entry_size = 16;

  // The first entry in the PLT.
  // From the AMD64 ABI: "Unlike Intel386 ABI, this ABI uses the same
  // procedure linkage table for both programs and shared objects."
  static const unsigned char first_plt_entry[plt_entry_size];

  // Other entries in the PLT for an executable.
  static const unsigned char plt_entry[plt_entry_size];

  // The reserved TLSDESC entry in the PLT for an executable.
  static const unsigned char tlsdesc_plt_entry[plt_entry_size];

  // The .eh_frame unwind information for the PLT.
  static const int plt_eh_frame_fde_size = 32;
  static const unsigned char plt_eh_frame_fde[plt_eh_frame_fde_size];
};

// The x86_64 target class.
// See the ABI at
//   http://www.x86-64.org/documentation/abi.pdf
// TLS info comes from
//   http://people.redhat.com/drepper/tls.pdf
//   http://www.lsd.ic.unicamp.br/~oliva/writeups/TLS/RFC-TLSDESC-x86.txt

template<int size>
class Target_x86_64 : public Sized_target<size, false>
{
 public:
  // In the x86_64 ABI (p 68), it says "The AMD64 ABI architectures
  // uses only Elf64_Rela relocation entries with explicit addends."
  typedef Output_data_reloc<elfcpp::SHT_RELA, true, size, false> Reloc_section;

  Target_x86_64(const Target::Target_info* info = &x86_64_info)
    : Sized_target<size, false>(info),
      got_(NULL), plt_(NULL), got_plt_(NULL), got_irelative_(NULL),
      got_tlsdesc_(NULL), global_offset_table_(NULL), rela_dyn_(NULL),
      rela_irelative_(NULL), copy_relocs_(elfcpp::R_X86_64_COPY),
      got_mod_index_offset_(-1U), tlsdesc_reloc_info_(),
      tls_base_symbol_defined_(false)
  { }

  // Hook for a new output section.
  void
  do_new_output_section(Output_section*) const;

  // Scan the relocations to look for symbol adjustments.
  void
  gc_process_relocs(Symbol_table* symtab,
		    Layout* layout,
		    Sized_relobj_file<size, false>* object,
		    unsigned int data_shndx,
		    unsigned int sh_type,
		    const unsigned char* prelocs,
		    size_t reloc_count,
		    Output_section* output_section,
		    bool needs_special_offset_handling,
		    size_t local_symbol_count,
		    const unsigned char* plocal_symbols);

  // Scan the relocations to look for symbol adjustments.
  void
  scan_relocs(Symbol_table* symtab,
	      Layout* layout,
	      Sized_relobj_file<size, false>* object,
	      unsigned int data_shndx,
	      unsigned int sh_type,
	      const unsigned char* prelocs,
	      size_t reloc_count,
	      Output_section* output_section,
	      bool needs_special_offset_handling,
	      size_t local_symbol_count,
	      const unsigned char* plocal_symbols);

  // Finalize the sections.
  void
  do_finalize_sections(Layout*, const Input_objects*, Symbol_table*);

  // Return the value to use for a dynamic which requires special
  // treatment.
  uint64_t
  do_dynsym_value(const Symbol*) const;

  // Relocate a section.
  void
  relocate_section(const Relocate_info<size, false>*,
		   unsigned int sh_type,
		   const unsigned char* prelocs,
		   size_t reloc_count,
		   Output_section* output_section,
		   bool needs_special_offset_handling,
		   unsigned char* view,
		   typename elfcpp::Elf_types<size>::Elf_Addr view_address,
		   section_size_type view_size,
		   const Reloc_symbol_changes*);

  // Scan the relocs during a relocatable link.
  void
  scan_relocatable_relocs(Symbol_table* symtab,
			  Layout* layout,
			  Sized_relobj_file<size, false>* object,
			  unsigned int data_shndx,
			  unsigned int sh_type,
			  const unsigned char* prelocs,
			  size_t reloc_count,
			  Output_section* output_section,
			  bool needs_special_offset_handling,
			  size_t local_symbol_count,
			  const unsigned char* plocal_symbols,
			  Relocatable_relocs*);

  // Emit relocations for a section.
  void
  relocate_relocs(
      const Relocate_info<size, false>*,
      unsigned int sh_type,
      const unsigned char* prelocs,
      size_t reloc_count,
      Output_section* output_section,
      typename elfcpp::Elf_types<size>::Elf_Off offset_in_output_section,
      const Relocatable_relocs*,
      unsigned char* view,
      typename elfcpp::Elf_types<size>::Elf_Addr view_address,
      section_size_type view_size,
      unsigned char* reloc_view,
      section_size_type reloc_view_size);

  // Return a string used to fill a code section with nops.
  std::string
  do_code_fill(section_size_type length) const;

  // Return whether SYM is defined by the ABI.
  bool
  do_is_defined_by_abi(const Symbol* sym) const
  { return strcmp(sym->name(), "__tls_get_addr") == 0; }

  // Return the symbol index to use for a target specific relocation.
  // The only target specific relocation is R_X86_64_TLSDESC for a
  // local symbol, which is an absolute reloc.
  unsigned int
  do_reloc_symbol_index(void*, unsigned int r_type) const
  {
    gold_assert(r_type == elfcpp::R_X86_64_TLSDESC);
    return 0;
  }

  // Return the addend to use for a target specific relocation.
  uint64_t
  do_reloc_addend(void* arg, unsigned int r_type, uint64_t addend) const;

  // Return the PLT section.
  uint64_t
  do_plt_address_for_global(const Symbol* gsym) const
  { return this->plt_section()->address_for_global(gsym); }

  uint64_t
  do_plt_address_for_local(const Relobj* relobj, unsigned int symndx) const
  { return this->plt_section()->address_for_local(relobj, symndx); }

  // This function should be defined in targets that can use relocation
  // types to determine (implemented in local_reloc_may_be_function_pointer
  // and global_reloc_may_be_function_pointer)
  // if a function's pointer is taken.  ICF uses this in safe mode to only
  // fold those functions whose pointer is defintely not taken.  For x86_64
  // pie binaries, safe ICF cannot be done by looking at relocation types.
  bool
  do_can_check_for_function_pointers() const
  { return !parameters->options().pie(); }

  // Return the base for a DW_EH_PE_datarel encoding.
  uint64_t
  do_ehframe_datarel_base() const;

  // Adjust -fsplit-stack code which calls non-split-stack code.
  void
  do_calls_non_split(Relobj* object, unsigned int shndx,
		     section_offset_type fnoffset, section_size_type fnsize,
		     unsigned char* view, section_size_type view_size,
		     std::string* from, std::string* to) const;

  // Return the size of the GOT section.
  section_size_type
  got_size() const
  {
    gold_assert(this->got_ != NULL);
    return this->got_->data_size();
  }

  // Return the number of entries in the GOT.
  unsigned int
  got_entry_count() const
  {
    if (this->got_ == NULL)
      return 0;
    return this->got_size() / 8;
  }

  // Return the number of entries in the PLT.
  unsigned int
  plt_entry_count() const;

  // Return the offset of the first non-reserved PLT entry.
  unsigned int
  first_plt_entry_offset() const;

  // Return the size of each PLT entry.
  unsigned int
  plt_entry_size() const;

  // Create the GOT section for an incremental update.
  Output_data_got_base*
  init_got_plt_for_update(Symbol_table* symtab,
			  Layout* layout,
			  unsigned int got_count,
			  unsigned int plt_count);

  // Reserve a GOT entry for a local symbol, and regenerate any
  // necessary dynamic relocations.
  void
  reserve_local_got_entry(unsigned int got_index,
			  Sized_relobj<size, false>* obj,
			  unsigned int r_sym,
			  unsigned int got_type);

  // Reserve a GOT entry for a global symbol, and regenerate any
  // necessary dynamic relocations.
  void
  reserve_global_got_entry(unsigned int got_index, Symbol* gsym,
			   unsigned int got_type);

  // Register an existing PLT entry for a global symbol.
  void
  register_global_plt_entry(Symbol_table*, Layout*, unsigned int plt_index,
			    Symbol* gsym);

  // Force a COPY relocation for a given symbol.
  void
  emit_copy_reloc(Symbol_table*, Symbol*, Output_section*, off_t);

  // Apply an incremental relocation.
  void
  apply_relocation(const Relocate_info<size, false>* relinfo,
		   typename elfcpp::Elf_types<size>::Elf_Addr r_offset,
		   unsigned int r_type,
		   typename elfcpp::Elf_types<size>::Elf_Swxword r_addend,
		   const Symbol* gsym,
		   unsigned char* view,
		   typename elfcpp::Elf_types<size>::Elf_Addr address,
		   section_size_type view_size);

  // Add a new reloc argument, returning the index in the vector.
  size_t
  add_tlsdesc_info(Sized_relobj_file<size, false>* object, unsigned int r_sym)
  {
    this->tlsdesc_reloc_info_.push_back(Tlsdesc_info(object, r_sym));
    return this->tlsdesc_reloc_info_.size() - 1;
  }

  Output_data_plt_x86_64<size>*
  make_data_plt(Layout* layout,
		Output_data_got<64, false>* got,
		Output_data_space* got_plt,
		Output_data_space* got_irelative)
  {
    return this->do_make_data_plt(layout, got, got_plt, got_irelative);
  }

  Output_data_plt_x86_64<size>*
  make_data_plt(Layout* layout,
		Output_data_got<64, false>* got,
		Output_data_space* got_plt,
		Output_data_space* got_irelative,
		unsigned int plt_count)
  {
    return this->do_make_data_plt(layout, got, got_plt, got_irelative,
				  plt_count);
  }

  virtual Output_data_plt_x86_64<size>*
  do_make_data_plt(Layout* layout,
		   Output_data_got<64, false>* got,
		   Output_data_space* got_plt,
		   Output_data_space* got_irelative)
  {
    return new Output_data_plt_x86_64_standard<size>(layout, got, got_plt,
						     got_irelative);
  }

  virtual Output_data_plt_x86_64<size>*
  do_make_data_plt(Layout* layout,
		   Output_data_got<64, false>* got,
		   Output_data_space* got_plt,
		   Output_data_space* got_irelative,
		   unsigned int plt_count)
  {
    return new Output_data_plt_x86_64_standard<size>(layout, got, got_plt,
						     got_irelative,
						     plt_count);
  }

 private:
  // The class which scans relocations.
  class Scan
  {
  public:
    Scan()
      : issued_non_pic_error_(false)
    { }

    static inline int
    get_reference_flags(unsigned int r_type);

    inline void
    local(Symbol_table* symtab, Layout* layout, Target_x86_64* target,
	  Sized_relobj_file<size, false>* object,
	  unsigned int data_shndx,
	  Output_section* output_section,
	  const elfcpp::Rela<size, false>& reloc, unsigned int r_type,
	  const elfcpp::Sym<size, false>& lsym,
	  bool is_discarded);

    inline void
    global(Symbol_table* symtab, Layout* layout, Target_x86_64* target,
	   Sized_relobj_file<size, false>* object,
	   unsigned int data_shndx,
	   Output_section* output_section,
	   const elfcpp::Rela<size, false>& reloc, unsigned int r_type,
	   Symbol* gsym);

    inline bool
    local_reloc_may_be_function_pointer(Symbol_table* symtab, Layout* layout,
					Target_x86_64* target,
					Sized_relobj_file<size, false>* object,
					unsigned int data_shndx,
					Output_section* output_section,
					const elfcpp::Rela<size, false>& reloc,
					unsigned int r_type,
					const elfcpp::Sym<size, false>& lsym);

    inline bool
    global_reloc_may_be_function_pointer(Symbol_table* symtab, Layout* layout,
					 Target_x86_64* target,
					 Sized_relobj_file<size, false>* object,
					 unsigned int data_shndx,
					 Output_section* output_section,
					 const elfcpp::Rela<size, false>& reloc,
					 unsigned int r_type,
					 Symbol* gsym);

  private:
    static void
    unsupported_reloc_local(Sized_relobj_file<size, false>*,
			    unsigned int r_type);

    static void
    unsupported_reloc_global(Sized_relobj_file<size, false>*,
			     unsigned int r_type, Symbol*);

    void
    check_non_pic(Relobj*, unsigned int r_type, Symbol*);

    inline bool
    possible_function_pointer_reloc(unsigned int r_type);

    bool
    reloc_needs_plt_for_ifunc(Sized_relobj_file<size, false>*,
			      unsigned int r_type);

    // Whether we have issued an error about a non-PIC compilation.
    bool issued_non_pic_error_;
  };

  // The class which implements relocation.
  class Relocate
  {
   public:
    Relocate()
      : skip_call_tls_get_addr_(false)
    { }

    ~Relocate()
    {
      if (this->skip_call_tls_get_addr_)
	{
	  // FIXME: This needs to specify the location somehow.
	  gold_error(_("missing expected TLS relocation"));
	}
    }

    // Do a relocation.  Return false if the caller should not issue
    // any warnings about this relocation.
    inline bool
    relocate(const Relocate_info<size, false>*, Target_x86_64*,
	     Output_section*,
	     size_t relnum, const elfcpp::Rela<size, false>&,
	     unsigned int r_type, const Sized_symbol<size>*,
	     const Symbol_value<size>*,
	     unsigned char*, typename elfcpp::Elf_types<size>::Elf_Addr,
	     section_size_type);

   private:
    // Do a TLS relocation.
    inline void
    relocate_tls(const Relocate_info<size, false>*, Target_x86_64*,
		 size_t relnum, const elfcpp::Rela<size, false>&,
		 unsigned int r_type, const Sized_symbol<size>*,
		 const Symbol_value<size>*,
		 unsigned char*, typename elfcpp::Elf_types<size>::Elf_Addr,
		 section_size_type);

    // Do a TLS General-Dynamic to Initial-Exec transition.
    inline void
    tls_gd_to_ie(const Relocate_info<size, false>*, size_t relnum,
		 Output_segment* tls_segment,
		 const elfcpp::Rela<size, false>&, unsigned int r_type,
		 typename elfcpp::Elf_types<size>::Elf_Addr value,
		 unsigned char* view,
		 typename elfcpp::Elf_types<size>::Elf_Addr,
		 section_size_type view_size);

    // Do a TLS General-Dynamic to Local-Exec transition.
    inline void
    tls_gd_to_le(const Relocate_info<size, false>*, size_t relnum,
		 Output_segment* tls_segment,
		 const elfcpp::Rela<size, false>&, unsigned int r_type,
		 typename elfcpp::Elf_types<size>::Elf_Addr value,
		 unsigned char* view,
		 section_size_type view_size);

    // Do a TLSDESC-style General-Dynamic to Initial-Exec transition.
    inline void
    tls_desc_gd_to_ie(const Relocate_info<size, false>*, size_t relnum,
		      Output_segment* tls_segment,
		      const elfcpp::Rela<size, false>&, unsigned int r_type,
		      typename elfcpp::Elf_types<size>::Elf_Addr value,
		      unsigned char* view,
		      typename elfcpp::Elf_types<size>::Elf_Addr,
		      section_size_type view_size);

    // Do a TLSDESC-style General-Dynamic to Local-Exec transition.
    inline void
    tls_desc_gd_to_le(const Relocate_info<size, false>*, size_t relnum,
		      Output_segment* tls_segment,
		      const elfcpp::Rela<size, false>&, unsigned int r_type,
		      typename elfcpp::Elf_types<size>::Elf_Addr value,
		      unsigned char* view,
		      section_size_type view_size);

    // Do a TLS Local-Dynamic to Local-Exec transition.
    inline void
    tls_ld_to_le(const Relocate_info<size, false>*, size_t relnum,
		 Output_segment* tls_segment,
		 const elfcpp::Rela<size, false>&, unsigned int r_type,
		 typename elfcpp::Elf_types<size>::Elf_Addr value,
		 unsigned char* view,
		 section_size_type view_size);

    // Do a TLS Initial-Exec to Local-Exec transition.
    static inline void
    tls_ie_to_le(const Relocate_info<size, false>*, size_t relnum,
		 Output_segment* tls_segment,
		 const elfcpp::Rela<size, false>&, unsigned int r_type,
		 typename elfcpp::Elf_types<size>::Elf_Addr value,
		 unsigned char* view,
		 section_size_type view_size);

    // This is set if we should skip the next reloc, which should be a
    // PLT32 reloc against ___tls_get_addr.
    bool skip_call_tls_get_addr_;
  };

  // A class which returns the size required for a relocation type,
  // used while scanning relocs during a relocatable link.
  class Relocatable_size_for_reloc
  {
   public:
    unsigned int
    get_size_for_reloc(unsigned int, Relobj*);
  };

  // Adjust TLS relocation type based on the options and whether this
  // is a local symbol.
  static tls::Tls_optimization
  optimize_tls_reloc(bool is_final, int r_type);

  // Get the GOT section, creating it if necessary.
  Output_data_got<64, false>*
  got_section(Symbol_table*, Layout*);

  // Get the GOT PLT section.
  Output_data_space*
  got_plt_section() const
  {
    gold_assert(this->got_plt_ != NULL);
    return this->got_plt_;
  }

  // Get the GOT section for TLSDESC entries.
  Output_data_got<64, false>*
  got_tlsdesc_section() const
  {
    gold_assert(this->got_tlsdesc_ != NULL);
    return this->got_tlsdesc_;
  }

  // Create the PLT section.
  void
  make_plt_section(Symbol_table* symtab, Layout* layout);

  // Create a PLT entry for a global symbol.
  void
  make_plt_entry(Symbol_table*, Layout*, Symbol*);

  // Create a PLT entry for a local STT_GNU_IFUNC symbol.
  void
  make_local_ifunc_plt_entry(Symbol_table*, Layout*,
			     Sized_relobj_file<size, false>* relobj,
			     unsigned int local_sym_index);

  // Define the _TLS_MODULE_BASE_ symbol in the TLS segment.
  void
  define_tls_base_symbol(Symbol_table*, Layout*);

  // Create the reserved PLT and GOT entries for the TLS descriptor resolver.
  void
  reserve_tlsdesc_entries(Symbol_table* symtab, Layout* layout);

  // Create a GOT entry for the TLS module index.
  unsigned int
  got_mod_index_entry(Symbol_table* symtab, Layout* layout,
		      Sized_relobj_file<size, false>* object);

  // Get the PLT section.
  Output_data_plt_x86_64<size>*
  plt_section() const
  {
    gold_assert(this->plt_ != NULL);
    return this->plt_;
  }

  // Get the dynamic reloc section, creating it if necessary.
  Reloc_section*
  rela_dyn_section(Layout*);

  // Get the section to use for TLSDESC relocations.
  Reloc_section*
  rela_tlsdesc_section(Layout*) const;

  // Get the section to use for IRELATIVE relocations.
  Reloc_section*
  rela_irelative_section(Layout*);

  // Add a potential copy relocation.
  void
  copy_reloc(Symbol_table* symtab, Layout* layout,
	     Sized_relobj_file<size, false>* object,
	     unsigned int shndx, Output_section* output_section,
	     Symbol* sym, const elfcpp::Rela<size, false>& reloc)
  {
    this->copy_relocs_.copy_reloc(symtab, layout,
				  symtab->get_sized_symbol<size>(sym),
				  object, shndx, output_section,
				  reloc, this->rela_dyn_section(layout));
  }

  // Information about this specific target which we pass to the
  // general Target structure.
  static const Target::Target_info x86_64_info;

  // The types of GOT entries needed for this platform.
  // These values are exposed to the ABI in an incremental link.
  // Do not renumber existing values without changing the version
  // number of the .gnu_incremental_inputs section.
  enum Got_type
  {
    GOT_TYPE_STANDARD = 0,      // GOT entry for a regular symbol
    GOT_TYPE_TLS_OFFSET = 1,    // GOT entry for TLS offset
    GOT_TYPE_TLS_PAIR = 2,      // GOT entry for TLS module/offset pair
    GOT_TYPE_TLS_DESC = 3       // GOT entry for TLS_DESC pair
  };

  // This type is used as the argument to the target specific
  // relocation routines.  The only target specific reloc is
  // R_X86_64_TLSDESC against a local symbol.
  struct Tlsdesc_info
  {
    Tlsdesc_info(Sized_relobj_file<size, false>* a_object, unsigned int a_r_sym)
      : object(a_object), r_sym(a_r_sym)
    { }

    // The object in which the local symbol is defined.
    Sized_relobj_file<size, false>* object;
    // The local symbol index in the object.
    unsigned int r_sym;
  };

  // The GOT section.
  Output_data_got<64, false>* got_;
  // The PLT section.
  Output_data_plt_x86_64<size>* plt_;
  // The GOT PLT section.
  Output_data_space* got_plt_;
  // The GOT section for IRELATIVE relocations.
  Output_data_space* got_irelative_;
  // The GOT section for TLSDESC relocations.
  Output_data_got<64, false>* got_tlsdesc_;
  // The _GLOBAL_OFFSET_TABLE_ symbol.
  Symbol* global_offset_table_;
  // The dynamic reloc section.
  Reloc_section* rela_dyn_;
  // The section to use for IRELATIVE relocs.
  Reloc_section* rela_irelative_;
  // Relocs saved to avoid a COPY reloc.
  Copy_relocs<elfcpp::SHT_RELA, size, false> copy_relocs_;
  // Offset of the GOT entry for the TLS module index.
  unsigned int got_mod_index_offset_;
  // We handle R_X86_64_TLSDESC against a local symbol as a target
  // specific relocation.  Here we store the object and local symbol
  // index for the relocation.
  std::vector<Tlsdesc_info> tlsdesc_reloc_info_;
  // True if the _TLS_MODULE_BASE_ symbol has been defined.
  bool tls_base_symbol_defined_;
};

template<>
const Target::Target_info Target_x86_64<64>::x86_64_info =
{
  64,			// size
  false,		// is_big_endian
  elfcpp::EM_X86_64,	// machine_code
  false,		// has_make_symbol
  false,		// has_resolve
  true,			// has_code_fill
  true,			// is_default_stack_executable
  true,			// can_icf_inline_merge_sections
  '\0',			// wrap_char
  "/lib/ld64.so.1",     // program interpreter
  0x400000,		// default_text_segment_address
  0x1000,		// abi_pagesize (overridable by -z max-page-size)
  0x1000,		// common_pagesize (overridable by -z common-page-size)
  false,                // isolate_execinstr
  0,                    // rosegment_gap
  elfcpp::SHN_UNDEF,	// small_common_shndx
  elfcpp::SHN_X86_64_LCOMMON,	// large_common_shndx
  0,			// small_common_section_flags
  elfcpp::SHF_X86_64_LARGE,	// large_common_section_flags
  NULL,			// attributes_section
  NULL,			// attributes_vendor
  "_start"		// entry_symbol_name
};

template<>
const Target::Target_info Target_x86_64<32>::x86_64_info =
{
  32,			// size
  false,		// is_big_endian
  elfcpp::EM_X86_64,	// machine_code
  false,		// has_make_symbol
  false,		// has_resolve
  true,			// has_code_fill
  true,			// is_default_stack_executable
  true,			// can_icf_inline_merge_sections
  '\0',			// wrap_char
  "/libx32/ldx32.so.1", // program interpreter
  0x400000,		// default_text_segment_address
  0x1000,		// abi_pagesize (overridable by -z max-page-size)
  0x1000,		// common_pagesize (overridable by -z common-page-size)
  false,                // isolate_execinstr
  0,                    // rosegment_gap
  elfcpp::SHN_UNDEF,	// small_common_shndx
  elfcpp::SHN_X86_64_LCOMMON,	// large_common_shndx
  0,			// small_common_section_flags
  elfcpp::SHF_X86_64_LARGE,	// large_common_section_flags
  NULL,			// attributes_section
  NULL,			// attributes_vendor
  "_start"		// entry_symbol_name
};

// This is called when a new output section is created.  This is where
// we handle the SHF_X86_64_LARGE.

template<int size>
void
Target_x86_64<size>::do_new_output_section(Output_section* os) const
{
  if ((os->flags() & elfcpp::SHF_X86_64_LARGE) != 0)
    os->set_is_large_section();
}

// Get the GOT section, creating it if necessary.

template<int size>
Output_data_got<64, false>*
Target_x86_64<size>::got_section(Symbol_table* symtab, Layout* layout)
{
  if (this->got_ == NULL)
    {
      gold_assert(symtab != NULL && layout != NULL);

      // When using -z now, we can treat .got.plt as a relro section.
      // Without -z now, it is modified after program startup by lazy
      // PLT relocations.
      bool is_got_plt_relro = parameters->options().now();
      Output_section_order got_order = (is_got_plt_relro
					? ORDER_RELRO
					: ORDER_RELRO_LAST);
      Output_section_order got_plt_order = (is_got_plt_relro
					    ? ORDER_RELRO
					    : ORDER_NON_RELRO_FIRST);

      this->got_ = new Output_data_got<64, false>();

      layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_WRITE),
				      this->got_, got_order, true);

      this->got_plt_ = new Output_data_space(8, "** GOT PLT");
      layout->add_output_section_data(".got.plt", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_WRITE),
				      this->got_plt_, got_plt_order,
				      is_got_plt_relro);

      // The first three entries are reserved.
      this->got_plt_->set_current_data_size(3 * 8);

      if (!is_got_plt_relro)
	{
	  // Those bytes can go into the relro segment.
	  layout->increase_relro(3 * 8);
	}

      // Define _GLOBAL_OFFSET_TABLE_ at the start of the PLT.
      this->global_offset_table_ =
	symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
				      Symbol_table::PREDEFINED,
				      this->got_plt_,
				      0, 0, elfcpp::STT_OBJECT,
				      elfcpp::STB_LOCAL,
				      elfcpp::STV_HIDDEN, 0,
				      false, false);

      // If there are any IRELATIVE relocations, they get GOT entries
      // in .got.plt after the jump slot entries.
      this->got_irelative_ = new Output_data_space(8, "** GOT IRELATIVE PLT");
      layout->add_output_section_data(".got.plt", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_WRITE),
				      this->got_irelative_,
				      got_plt_order, is_got_plt_relro);

      // If there are any TLSDESC relocations, they get GOT entries in
      // .got.plt after the jump slot and IRELATIVE entries.
      this->got_tlsdesc_ = new Output_data_got<64, false>();
      layout->add_output_section_data(".got.plt", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_WRITE),
				      this->got_tlsdesc_,
				      got_plt_order, is_got_plt_relro);
    }

  return this->got_;
}

// Get the dynamic reloc section, creating it if necessary.

template<int size>
typename Target_x86_64<size>::Reloc_section*
Target_x86_64<size>::rela_dyn_section(Layout* layout)
{
  if (this->rela_dyn_ == NULL)
    {
      gold_assert(layout != NULL);
      this->rela_dyn_ = new Reloc_section(parameters->options().combreloc());
      layout->add_output_section_data(".rela.dyn", elfcpp::SHT_RELA,
				      elfcpp::SHF_ALLOC, this->rela_dyn_,
				      ORDER_DYNAMIC_RELOCS, false);
    }
  return this->rela_dyn_;
}

// Get the section to use for IRELATIVE relocs, creating it if
// necessary.  These go in .rela.dyn, but only after all other dynamic
// relocations.  They need to follow the other dynamic relocations so
// that they can refer to global variables initialized by those
// relocs.

template<int size>
typename Target_x86_64<size>::Reloc_section*
Target_x86_64<size>::rela_irelative_section(Layout* layout)
{
  if (this->rela_irelative_ == NULL)
    {
      // Make sure we have already created the dynamic reloc section.
      this->rela_dyn_section(layout);
      this->rela_irelative_ = new Reloc_section(false);
      layout->add_output_section_data(".rela.dyn", elfcpp::SHT_RELA,
				      elfcpp::SHF_ALLOC, this->rela_irelative_,
				      ORDER_DYNAMIC_RELOCS, false);
      gold_assert(this->rela_dyn_->output_section()
		  == this->rela_irelative_->output_section());
    }
  return this->rela_irelative_;
}

// Initialize the PLT section.

template<int size>
void
Output_data_plt_x86_64<size>::init(Layout* layout)
{
  this->rel_ = new Reloc_section(false);
  layout->add_output_section_data(".rela.plt", elfcpp::SHT_RELA,
				  elfcpp::SHF_ALLOC, this->rel_,
				  ORDER_DYNAMIC_PLT_RELOCS, false);
}

template<int size>
void
Output_data_plt_x86_64<size>::do_adjust_output_section(Output_section* os)
{
  os->set_entsize(this->get_plt_entry_size());
}

// Add an entry to the PLT.

template<int size>
void
Output_data_plt_x86_64<size>::add_entry(Symbol_table* symtab, Layout* layout,
					Symbol* gsym)
{
  gold_assert(!gsym->has_plt_offset());

  unsigned int plt_index;
  off_t plt_offset;
  section_offset_type got_offset;

  unsigned int* pcount;
  unsigned int offset;
  unsigned int reserved;
  Output_data_space* got;
  if (gsym->type() == elfcpp::STT_GNU_IFUNC
      && gsym->can_use_relative_reloc(false))
    {
      pcount = &this->irelative_count_;
      offset = 0;
      reserved = 0;
      got = this->got_irelative_;
    }
  else
    {
      pcount = &this->count_;
      offset = 1;
      reserved = 3;
      got = this->got_plt_;
    }

  if (!this->is_data_size_valid())
    {
      // Note that when setting the PLT offset for a non-IRELATIVE
      // entry we skip the initial reserved PLT entry.
      plt_index = *pcount + offset;
      plt_offset = plt_index * this->get_plt_entry_size();

      ++*pcount;

      got_offset = (plt_index - offset + reserved) * 8;
      gold_assert(got_offset == got->current_data_size());

      // Every PLT entry needs a GOT entry which points back to the PLT
      // entry (this will be changed by the dynamic linker, normally
      // lazily when the function is called).
      got->set_current_data_size(got_offset + 8);
    }
  else
    {
      // FIXME: This is probably not correct for IRELATIVE relocs.

      // For incremental updates, find an available slot.
      plt_offset = this->free_list_.allocate(this->get_plt_entry_size(),
					     this->get_plt_entry_size(), 0);
      if (plt_offset == -1)
	gold_fallback(_("out of patch space (PLT);"
			" relink with --incremental-full"));

      // The GOT and PLT entries have a 1-1 correspondance, so the GOT offset
      // can be calculated from the PLT index, adjusting for the three
      // reserved entries at the beginning of the GOT.
      plt_index = plt_offset / this->get_plt_entry_size() - 1;
      got_offset = (plt_index - offset + reserved) * 8;
    }

  gsym->set_plt_offset(plt_offset);

  // Every PLT entry needs a reloc.
  this->add_relocation(symtab, layout, gsym, got_offset);

  // Note that we don't need to save the symbol.  The contents of the
  // PLT are independent of which symbols are used.  The symbols only
  // appear in the relocations.
}

// Add an entry to the PLT for a local STT_GNU_IFUNC symbol.  Return
// the PLT offset.

template<int size>
unsigned int
Output_data_plt_x86_64<size>::add_local_ifunc_entry(
    Symbol_table* symtab,
    Layout* layout,
    Sized_relobj_file<size, false>* relobj,
    unsigned int local_sym_index)
{
  unsigned int plt_offset = this->irelative_count_ * this->get_plt_entry_size();
  ++this->irelative_count_;

  section_offset_type got_offset = this->got_irelative_->current_data_size();

  // Every PLT entry needs a GOT entry which points back to the PLT
  // entry.
  this->got_irelative_->set_current_data_size(got_offset + 8);

  // Every PLT entry needs a reloc.
  Reloc_section* rela = this->rela_irelative(symtab, layout);
  rela->add_symbolless_local_addend(relobj, local_sym_index,
				    elfcpp::R_X86_64_IRELATIVE,
				    this->got_irelative_, got_offset, 0);

  return plt_offset;
}

// Add the relocation for a PLT entry.

template<int size>
void
Output_data_plt_x86_64<size>::add_relocation(Symbol_table* symtab,
					     Layout* layout,
					     Symbol* gsym,
					     unsigned int got_offset)
{
  if (gsym->type() == elfcpp::STT_GNU_IFUNC
      && gsym->can_use_relative_reloc(false))
    {
      Reloc_section* rela = this->rela_irelative(symtab, layout);
      rela->add_symbolless_global_addend(gsym, elfcpp::R_X86_64_IRELATIVE,
					 this->got_irelative_, got_offset, 0);
    }
  else
    {
      gsym->set_needs_dynsym_entry();
      this->rel_->add_global(gsym, elfcpp::R_X86_64_JUMP_SLOT, this->got_plt_,
			     got_offset, 0);
    }
}

// Return where the TLSDESC relocations should go, creating it if
// necessary.  These follow the JUMP_SLOT relocations.

template<int size>
typename Output_data_plt_x86_64<size>::Reloc_section*
Output_data_plt_x86_64<size>::rela_tlsdesc(Layout* layout)
{
  if (this->tlsdesc_rel_ == NULL)
    {
      this->tlsdesc_rel_ = new Reloc_section(false);
      layout->add_output_section_data(".rela.plt", elfcpp::SHT_RELA,
				      elfcpp::SHF_ALLOC, this->tlsdesc_rel_,
				      ORDER_DYNAMIC_PLT_RELOCS, false);
      gold_assert(this->tlsdesc_rel_->output_section()
		  == this->rel_->output_section());
    }
  return this->tlsdesc_rel_;
}

// Return where the IRELATIVE relocations should go in the PLT.  These
// follow the JUMP_SLOT and the TLSDESC relocations.

template<int size>
typename Output_data_plt_x86_64<size>::Reloc_section*
Output_data_plt_x86_64<size>::rela_irelative(Symbol_table* symtab,
					     Layout* layout)
{
  if (this->irelative_rel_ == NULL)
    {
      // Make sure we have a place for the TLSDESC relocations, in
      // case we see any later on.
      this->rela_tlsdesc(layout);
      this->irelative_rel_ = new Reloc_section(false);
      layout->add_output_section_data(".rela.plt", elfcpp::SHT_RELA,
				      elfcpp::SHF_ALLOC, this->irelative_rel_,
				      ORDER_DYNAMIC_PLT_RELOCS, false);
      gold_assert(this->irelative_rel_->output_section()
		  == this->rel_->output_section());

      if (parameters->doing_static_link())
	{
	  // A statically linked executable will only have a .rela.plt
	  // section to hold R_X86_64_IRELATIVE relocs for
	  // STT_GNU_IFUNC symbols.  The library will use these
	  // symbols to locate the IRELATIVE relocs at program startup
	  // time.
	  symtab->define_in_output_data("__rela_iplt_start", NULL,
					Symbol_table::PREDEFINED,
					this->irelative_rel_, 0, 0,
					elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
					elfcpp::STV_HIDDEN, 0, false, true);
	  symtab->define_in_output_data("__rela_iplt_end", NULL,
					Symbol_table::PREDEFINED,
					this->irelative_rel_, 0, 0,
					elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
					elfcpp::STV_HIDDEN, 0, true, true);
	}
    }
  return this->irelative_rel_;
}

// Return the PLT address to use for a global symbol.

template<int size>
uint64_t
Output_data_plt_x86_64<size>::address_for_global(const Symbol* gsym)
{
  uint64_t offset = 0;
  if (gsym->type() == elfcpp::STT_GNU_IFUNC
      && gsym->can_use_relative_reloc(false))
    offset = (this->count_ + 1) * this->get_plt_entry_size();
  return this->address() + offset + gsym->plt_offset();
}

// Return the PLT address to use for a local symbol.  These are always
// IRELATIVE relocs.

template<int size>
uint64_t
Output_data_plt_x86_64<size>::address_for_local(const Relobj* object,
						unsigned int r_sym)
{
  return (this->address()
	  + (this->count_ + 1) * this->get_plt_entry_size()
	  + object->local_plt_offset(r_sym));
}

// Set the final size.
template<int size>
void
Output_data_plt_x86_64<size>::set_final_data_size()
{
  unsigned int count = this->count_ + this->irelative_count_;
  if (this->has_tlsdesc_entry())
    ++count;
  this->set_data_size((count + 1) * this->get_plt_entry_size());
}

// The first entry in the PLT for an executable.

template<int size>
const unsigned char
Output_data_plt_x86_64_standard<size>::first_plt_entry[plt_entry_size] =
{
  // From AMD64 ABI Draft 0.98, page 76
  0xff, 0x35,	// pushq contents of memory address
  0, 0, 0, 0,	// replaced with address of .got + 8
  0xff, 0x25,	// jmp indirect
  0, 0, 0, 0,	// replaced with address of .got + 16
  0x90, 0x90, 0x90, 0x90   // noop (x4)
};

template<int size>
void
Output_data_plt_x86_64_standard<size>::do_fill_first_plt_entry(
    unsigned char* pov,
    typename elfcpp::Elf_types<size>::Elf_Addr got_address,
    typename elfcpp::Elf_types<size>::Elf_Addr plt_address)
{
  memcpy(pov, first_plt_entry, plt_entry_size);
  // We do a jmp relative to the PC at the end of this instruction.
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2,
					      (got_address + 8
					       - (plt_address + 6)));
  elfcpp::Swap<32, false>::writeval(pov + 8,
				    (got_address + 16
				     - (plt_address + 12)));
}

// Subsequent entries in the PLT for an executable.

template<int size>
const unsigned char
Output_data_plt_x86_64_standard<size>::plt_entry[plt_entry_size] =
{
  // From AMD64 ABI Draft 0.98, page 76
  0xff, 0x25,	// jmpq indirect
  0, 0, 0, 0,	// replaced with address of symbol in .got
  0x68,		// pushq immediate
  0, 0, 0, 0,	// replaced with offset into relocation table
  0xe9,		// jmpq relative
  0, 0, 0, 0	// replaced with offset to start of .plt
};

template<int size>
unsigned int
Output_data_plt_x86_64_standard<size>::do_fill_plt_entry(
    unsigned char* pov,
    typename elfcpp::Elf_types<size>::Elf_Addr got_address,
    typename elfcpp::Elf_types<size>::Elf_Addr plt_address,
    unsigned int got_offset,
    unsigned int plt_offset,
    unsigned int plt_index)
{
  memcpy(pov, plt_entry, plt_entry_size);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2,
					      (got_address + got_offset
					       - (plt_address + plt_offset
						  + 6)));

  elfcpp::Swap_unaligned<32, false>::writeval(pov + 7, plt_index);
  elfcpp::Swap<32, false>::writeval(pov + 12,
				    - (plt_offset + plt_entry_size));

  return 6;
}

// The reserved TLSDESC entry in the PLT for an executable.

template<int size>
const unsigned char
Output_data_plt_x86_64_standard<size>::tlsdesc_plt_entry[plt_entry_size] =
{
  // From Alexandre Oliva, "Thread-Local Storage Descriptors for IA32
  // and AMD64/EM64T", Version 0.9.4 (2005-10-10).
  0xff, 0x35,	// pushq x(%rip)
  0, 0, 0, 0,	// replaced with address of linkmap GOT entry (at PLTGOT + 8)
  0xff,	0x25,	// jmpq *y(%rip)
  0, 0, 0, 0,	// replaced with offset of reserved TLSDESC_GOT entry
  0x0f,	0x1f,	// nop
  0x40, 0
};

template<int size>
void
Output_data_plt_x86_64_standard<size>::do_fill_tlsdesc_entry(
    unsigned char* pov,
    typename elfcpp::Elf_types<size>::Elf_Addr got_address,
    typename elfcpp::Elf_types<size>::Elf_Addr plt_address,
    typename elfcpp::Elf_types<size>::Elf_Addr got_base,
    unsigned int tlsdesc_got_offset,
    unsigned int plt_offset)
{
  memcpy(pov, tlsdesc_plt_entry, plt_entry_size);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2,
					      (got_address + 8
					       - (plt_address + plt_offset
						  + 6)));
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 8,
					      (got_base
					       + tlsdesc_got_offset
					       - (plt_address + plt_offset
						  + 12)));
}

// The .eh_frame unwind information for the PLT.

template<int size>
const unsigned char
Output_data_plt_x86_64<size>::plt_eh_frame_cie[plt_eh_frame_cie_size] =
{
  1,				// CIE version.
  'z',				// Augmentation: augmentation size included.
  'R',				// Augmentation: FDE encoding included.
  '\0',				// End of augmentation string.
  1,				// Code alignment factor.
  0x78,				// Data alignment factor.
  16,				// Return address column.
  1,				// Augmentation size.
  (elfcpp::DW_EH_PE_pcrel	// FDE encoding.
   | elfcpp::DW_EH_PE_sdata4),
  elfcpp::DW_CFA_def_cfa, 7, 8,	// DW_CFA_def_cfa: r7 (rsp) ofs 8.
  elfcpp::DW_CFA_offset + 16, 1,// DW_CFA_offset: r16 (rip) at cfa-8.
  elfcpp::DW_CFA_nop,		// Align to 16 bytes.
  elfcpp::DW_CFA_nop
};

template<int size>
const unsigned char
Output_data_plt_x86_64_standard<size>::plt_eh_frame_fde[plt_eh_frame_fde_size] =
{
  0, 0, 0, 0,				// Replaced with offset to .plt.
  0, 0, 0, 0,				// Replaced with size of .plt.
  0,					// Augmentation size.
  elfcpp::DW_CFA_def_cfa_offset, 16,	// DW_CFA_def_cfa_offset: 16.
  elfcpp::DW_CFA_advance_loc + 6,	// Advance 6 to __PLT__ + 6.
  elfcpp::DW_CFA_def_cfa_offset, 24,	// DW_CFA_def_cfa_offset: 24.
  elfcpp::DW_CFA_advance_loc + 10,	// Advance 10 to __PLT__ + 16.
  elfcpp::DW_CFA_def_cfa_expression,	// DW_CFA_def_cfa_expression.
  11,					// Block length.
  elfcpp::DW_OP_breg7, 8,		// Push %rsp + 8.
  elfcpp::DW_OP_breg16, 0,		// Push %rip.
  elfcpp::DW_OP_lit15,			// Push 0xf.
  elfcpp::DW_OP_and,			// & (%rip & 0xf).
  elfcpp::DW_OP_lit11,			// Push 0xb.
  elfcpp::DW_OP_ge,			// >= ((%rip & 0xf) >= 0xb)
  elfcpp::DW_OP_lit3,			// Push 3.
  elfcpp::DW_OP_shl,			// << (((%rip & 0xf) >= 0xb) << 3)
  elfcpp::DW_OP_plus,			// + ((((%rip&0xf)>=0xb)<<3)+%rsp+8
  elfcpp::DW_CFA_nop,			// Align to 32 bytes.
  elfcpp::DW_CFA_nop,
  elfcpp::DW_CFA_nop,
  elfcpp::DW_CFA_nop
};

// Write out the PLT.  This uses the hand-coded instructions above,
// and adjusts them as needed.  This is specified by the AMD64 ABI.

template<int size>
void
Output_data_plt_x86_64<size>::do_write(Output_file* of)
{
  const off_t offset = this->offset();
  const section_size_type oview_size =
    convert_to_section_size_type(this->data_size());
  unsigned char* const oview = of->get_output_view(offset, oview_size);

  const off_t got_file_offset = this->got_plt_->offset();
  gold_assert(parameters->incremental_update()
	      || (got_file_offset + this->got_plt_->data_size()
		  == this->got_irelative_->offset()));
  const section_size_type got_size =
    convert_to_section_size_type(this->got_plt_->data_size()
				 + this->got_irelative_->data_size());
  unsigned char* const got_view = of->get_output_view(got_file_offset,
						      got_size);

  unsigned char* pov = oview;

  // The base address of the .plt section.
  typename elfcpp::Elf_types<size>::Elf_Addr plt_address = this->address();
  // The base address of the .got section.
  typename elfcpp::Elf_types<size>::Elf_Addr got_base = this->got_->address();
  // The base address of the PLT portion of the .got section,
  // which is where the GOT pointer will point, and where the
  // three reserved GOT entries are located.
  typename elfcpp::Elf_types<size>::Elf_Addr got_address
    = this->got_plt_->address();

  this->fill_first_plt_entry(pov, got_address, plt_address);
  pov += this->get_plt_entry_size();

  unsigned char* got_pov = got_view;

  // The first entry in the GOT is the address of the .dynamic section
  // aka the PT_DYNAMIC segment.  The next two entries are reserved.
  // We saved space for them when we created the section in
  // Target_x86_64::got_section.
  Output_section* dynamic = this->layout_->dynamic_section();
  uint32_t dynamic_addr = dynamic == NULL ? 0 : dynamic->address();
  elfcpp::Swap<64, false>::writeval(got_pov, dynamic_addr);
  got_pov += 8;
  memset(got_pov, 0, 16);
  got_pov += 16;

  unsigned int plt_offset = this->get_plt_entry_size();
  unsigned int got_offset = 24;
  const unsigned int count = this->count_ + this->irelative_count_;
  for (unsigned int plt_index = 0;
       plt_index < count;
       ++plt_index,
	 pov += this->get_plt_entry_size(),
	 got_pov += 8,
	 plt_offset += this->get_plt_entry_size(),
	 got_offset += 8)
    {
      // Set and adjust the PLT entry itself.
      unsigned int lazy_offset = this->fill_plt_entry(pov,
						      got_address, plt_address,
						      got_offset, plt_offset,
						      plt_index);

      // Set the entry in the GOT.
      elfcpp::Swap<64, false>::writeval(got_pov,
					plt_address + plt_offset + lazy_offset);
    }

  if (this->has_tlsdesc_entry())
    {
      // Set and adjust the reserved TLSDESC PLT entry.
      unsigned int tlsdesc_got_offset = this->get_tlsdesc_got_offset();
      this->fill_tlsdesc_entry(pov, got_address, plt_address, got_base,
			       tlsdesc_got_offset, plt_offset);
      pov += this->get_plt_entry_size();
    }

  gold_assert(static_cast<section_size_type>(pov - oview) == oview_size);
  gold_assert(static_cast<section_size_type>(got_pov - got_view) == got_size);

  of->write_output_view(offset, oview_size, oview);
  of->write_output_view(got_file_offset, got_size, got_view);
}

// Create the PLT section.

template<int size>
void
Target_x86_64<size>::make_plt_section(Symbol_table* symtab, Layout* layout)
{
  if (this->plt_ == NULL)
    {
      // Create the GOT sections first.
      this->got_section(symtab, layout);

      this->plt_ = this->make_data_plt(layout, this->got_, this->got_plt_,
				       this->got_irelative_);

      // Add unwind information if requested.
      if (parameters->options().ld_generated_unwind_info())
	this->plt_->add_eh_frame(layout);

      layout->add_output_section_data(".plt", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_EXECINSTR),
				      this->plt_, ORDER_PLT, false);

      // Make the sh_info field of .rela.plt point to .plt.
      Output_section* rela_plt_os = this->plt_->rela_plt()->output_section();
      rela_plt_os->set_info_section(this->plt_->output_section());
    }
}

// Return the section for TLSDESC relocations.

template<int size>
typename Target_x86_64<size>::Reloc_section*
Target_x86_64<size>::rela_tlsdesc_section(Layout* layout) const
{
  return this->plt_section()->rela_tlsdesc(layout);
}

// Create a PLT entry for a global symbol.

template<int size>
void
Target_x86_64<size>::make_plt_entry(Symbol_table* symtab, Layout* layout,
				    Symbol* gsym)
{
  if (gsym->has_plt_offset())
    return;

  if (this->plt_ == NULL)
    this->make_plt_section(symtab, layout);

  this->plt_->add_entry(symtab, layout, gsym);
}

// Make a PLT entry for a local STT_GNU_IFUNC symbol.

template<int size>
void
Target_x86_64<size>::make_local_ifunc_plt_entry(
    Symbol_table* symtab, Layout* layout,
    Sized_relobj_file<size, false>* relobj,
    unsigned int local_sym_index)
{
  if (relobj->local_has_plt_offset(local_sym_index))
    return;
  if (this->plt_ == NULL)
    this->make_plt_section(symtab, layout);
  unsigned int plt_offset = this->plt_->add_local_ifunc_entry(symtab, layout,
							      relobj,
							      local_sym_index);
  relobj->set_local_plt_offset(local_sym_index, plt_offset);
}

// Return the number of entries in the PLT.

template<int size>
unsigned int
Target_x86_64<size>::plt_entry_count() const
{
  if (this->plt_ == NULL)
    return 0;
  return this->plt_->entry_count();
}

// Return the offset of the first non-reserved PLT entry.

template<int size>
unsigned int
Target_x86_64<size>::first_plt_entry_offset() const
{
  return this->plt_->first_plt_entry_offset();
}

// Return the size of each PLT entry.

template<int size>
unsigned int
Target_x86_64<size>::plt_entry_size() const
{
  return this->plt_->get_plt_entry_size();
}

// Create the GOT and PLT sections for an incremental update.

template<int size>
Output_data_got_base*
Target_x86_64<size>::init_got_plt_for_update(Symbol_table* symtab,
				       Layout* layout,
				       unsigned int got_count,
				       unsigned int plt_count)
{
  gold_assert(this->got_ == NULL);

  this->got_ = new Output_data_got<64, false>(got_count * 8);
  layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
				  (elfcpp::SHF_ALLOC
				   | elfcpp::SHF_WRITE),
				  this->got_, ORDER_RELRO_LAST,
				  true);

  // Add the three reserved entries.
  this->got_plt_ = new Output_data_space((plt_count + 3) * 8, 8, "** GOT PLT");
  layout->add_output_section_data(".got.plt", elfcpp::SHT_PROGBITS,
				  (elfcpp::SHF_ALLOC
				   | elfcpp::SHF_WRITE),
				  this->got_plt_, ORDER_NON_RELRO_FIRST,
				  false);

  // Define _GLOBAL_OFFSET_TABLE_ at the start of the PLT.
  this->global_offset_table_ =
    symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
				  Symbol_table::PREDEFINED,
				  this->got_plt_,
				  0, 0, elfcpp::STT_OBJECT,
				  elfcpp::STB_LOCAL,
				  elfcpp::STV_HIDDEN, 0,
				  false, false);

  // If there are any TLSDESC relocations, they get GOT entries in
  // .got.plt after the jump slot entries.
  // FIXME: Get the count for TLSDESC entries.
  this->got_tlsdesc_ = new Output_data_got<64, false>(0);
  layout->add_output_section_data(".got.plt", elfcpp::SHT_PROGBITS,
				  elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE,
				  this->got_tlsdesc_,
				  ORDER_NON_RELRO_FIRST, false);

  // If there are any IRELATIVE relocations, they get GOT entries in
  // .got.plt after the jump slot and TLSDESC entries.
  this->got_irelative_ = new Output_data_space(0, 8, "** GOT IRELATIVE PLT");
  layout->add_output_section_data(".got.plt", elfcpp::SHT_PROGBITS,
				  elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE,
				  this->got_irelative_,
				  ORDER_NON_RELRO_FIRST, false);

  // Create the PLT section.
  this->plt_ = this->make_data_plt(layout, this->got_,
				   this->got_plt_,
				   this->got_irelative_,
				   plt_count);

  // Add unwind information if requested.
  if (parameters->options().ld_generated_unwind_info())
    this->plt_->add_eh_frame(layout);

  layout->add_output_section_data(".plt", elfcpp::SHT_PROGBITS,
				  elfcpp::SHF_ALLOC | elfcpp::SHF_EXECINSTR,
				  this->plt_, ORDER_PLT, false);

  // Make the sh_info field of .rela.plt point to .plt.
  Output_section* rela_plt_os = this->plt_->rela_plt()->output_section();
  rela_plt_os->set_info_section(this->plt_->output_section());

  // Create the rela_dyn section.
  this->rela_dyn_section(layout);

  return this->got_;
}

// Reserve a GOT entry for a local symbol, and regenerate any
// necessary dynamic relocations.

template<int size>
void
Target_x86_64<size>::reserve_local_got_entry(
    unsigned int got_index,
    Sized_relobj<size, false>* obj,
    unsigned int r_sym,
    unsigned int got_type)
{
  unsigned int got_offset = got_index * 8;
  Reloc_section* rela_dyn = this->rela_dyn_section(NULL);

  this->got_->reserve_local(got_index, obj, r_sym, got_type);
  switch (got_type)
    {
    case GOT_TYPE_STANDARD:
      if (parameters->options().output_is_position_independent())
	rela_dyn->add_local_relative(obj, r_sym, elfcpp::R_X86_64_RELATIVE,
				     this->got_, got_offset, 0, false);
      break;
    case GOT_TYPE_TLS_OFFSET:
      rela_dyn->add_local(obj, r_sym, elfcpp::R_X86_64_TPOFF64,
			  this->got_, got_offset, 0);
      break;
    case GOT_TYPE_TLS_PAIR:
      this->got_->reserve_slot(got_index + 1);
      rela_dyn->add_local(obj, r_sym, elfcpp::R_X86_64_DTPMOD64,
			  this->got_, got_offset, 0);
      break;
    case GOT_TYPE_TLS_DESC:
      gold_fatal(_("TLS_DESC not yet supported for incremental linking"));
      // this->got_->reserve_slot(got_index + 1);
      // rela_dyn->add_target_specific(elfcpp::R_X86_64_TLSDESC, arg,
      //			       this->got_, got_offset, 0);
      break;
    default:
      gold_unreachable();
    }
}

// Reserve a GOT entry for a global symbol, and regenerate any
// necessary dynamic relocations.

template<int size>
void
Target_x86_64<size>::reserve_global_got_entry(unsigned int got_index,
					      Symbol* gsym,
					      unsigned int got_type)
{
  unsigned int got_offset = got_index * 8;
  Reloc_section* rela_dyn = this->rela_dyn_section(NULL);

  this->got_->reserve_global(got_index, gsym, got_type);
  switch (got_type)
    {
    case GOT_TYPE_STANDARD:
      if (!gsym->final_value_is_known())
	{
	  if (gsym->is_from_dynobj()
	      || gsym->is_undefined()
	      || gsym->is_preemptible()
	      || gsym->type() == elfcpp::STT_GNU_IFUNC)
	    rela_dyn->add_global(gsym, elfcpp::R_X86_64_GLOB_DAT,
				 this->got_, got_offset, 0);
	  else
	    rela_dyn->add_global_relative(gsym, elfcpp::R_X86_64_RELATIVE,
					  this->got_, got_offset, 0, false);
	}
      break;
    case GOT_TYPE_TLS_OFFSET:
      rela_dyn->add_global_relative(gsym, elfcpp::R_X86_64_TPOFF64,
				    this->got_, got_offset, 0, false);
      break;
    case GOT_TYPE_TLS_PAIR:
      this->got_->reserve_slot(got_index + 1);
      rela_dyn->add_global_relative(gsym, elfcpp::R_X86_64_DTPMOD64,
				    this->got_, got_offset, 0, false);
      rela_dyn->add_global_relative(gsym, elfcpp::R_X86_64_DTPOFF64,
				    this->got_, got_offset + 8, 0, false);
      break;
    case GOT_TYPE_TLS_DESC:
      this->got_->reserve_slot(got_index + 1);
      rela_dyn->add_global_relative(gsym, elfcpp::R_X86_64_TLSDESC,
				    this->got_, got_offset, 0, false);
      break;
    default:
      gold_unreachable();
    }
}

// Register an existing PLT entry for a global symbol.

template<int size>
void
Target_x86_64<size>::register_global_plt_entry(Symbol_table* symtab,
					       Layout* layout,
					       unsigned int plt_index,
					       Symbol* gsym)
{
  gold_assert(this->plt_ != NULL);
  gold_assert(!gsym->has_plt_offset());

  this->plt_->reserve_slot(plt_index);

  gsym->set_plt_offset((plt_index + 1) * this->plt_entry_size());

  unsigned int got_offset = (plt_index + 3) * 8;
  this->plt_->add_relocation(symtab, layout, gsym, got_offset);
}

// Force a COPY relocation for a given symbol.

template<int size>
void
Target_x86_64<size>::emit_copy_reloc(
    Symbol_table* symtab, Symbol* sym, Output_section* os, off_t offset)
{
  this->copy_relocs_.emit_copy_reloc(symtab,
				     symtab->get_sized_symbol<size>(sym),
				     os,
				     offset,
				     this->rela_dyn_section(NULL));
}

// Define the _TLS_MODULE_BASE_ symbol in the TLS segment.

template<int size>
void
Target_x86_64<size>::define_tls_base_symbol(Symbol_table* symtab,
					    Layout* layout)
{
  if (this->tls_base_symbol_defined_)
    return;

  Output_segment* tls_segment = layout->tls_segment();
  if (tls_segment != NULL)
    {
      bool is_exec = parameters->options().output_is_executable();
      symtab->define_in_output_segment("_TLS_MODULE_BASE_", NULL,
				       Symbol_table::PREDEFINED,
				       tls_segment, 0, 0,
				       elfcpp::STT_TLS,
				       elfcpp::STB_LOCAL,
				       elfcpp::STV_HIDDEN, 0,
				       (is_exec
					? Symbol::SEGMENT_END
					: Symbol::SEGMENT_START),
				       true);
    }
  this->tls_base_symbol_defined_ = true;
}

// Create the reserved PLT and GOT entries for the TLS descriptor resolver.

template<int size>
void
Target_x86_64<size>::reserve_tlsdesc_entries(Symbol_table* symtab,
					     Layout* layout)
{
  if (this->plt_ == NULL)
    this->make_plt_section(symtab, layout);

  if (!this->plt_->has_tlsdesc_entry())
    {
      // Allocate the TLSDESC_GOT entry.
      Output_data_got<64, false>* got = this->got_section(symtab, layout);
      unsigned int got_offset = got->add_constant(0);

      // Allocate the TLSDESC_PLT entry.
      this->plt_->reserve_tlsdesc_entry(got_offset);
    }
}

// Create a GOT entry for the TLS module index.

template<int size>
unsigned int
Target_x86_64<size>::got_mod_index_entry(Symbol_table* symtab, Layout* layout,
					 Sized_relobj_file<size, false>* object)
{
  if (this->got_mod_index_offset_ == -1U)
    {
      gold_assert(symtab != NULL && layout != NULL && object != NULL);
      Reloc_section* rela_dyn = this->rela_dyn_section(layout);
      Output_data_got<64, false>* got = this->got_section(symtab, layout);
      unsigned int got_offset = got->add_constant(0);
      rela_dyn->add_local(object, 0, elfcpp::R_X86_64_DTPMOD64, got,
			  got_offset, 0);
      got->add_constant(0);
      this->got_mod_index_offset_ = got_offset;
    }
  return this->got_mod_index_offset_;
}

// Optimize the TLS relocation type based on what we know about the
// symbol.  IS_FINAL is true if the final address of this symbol is
// known at link time.

template<int size>
tls::Tls_optimization
Target_x86_64<size>::optimize_tls_reloc(bool is_final, int r_type)
{
  // If we are generating a shared library, then we can't do anything
  // in the linker.
  if (parameters->options().shared())
    return tls::TLSOPT_NONE;

  switch (r_type)
    {
    case elfcpp::R_X86_64_TLSGD:
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:
    case elfcpp::R_X86_64_TLSDESC_CALL:
      // These are General-Dynamic which permits fully general TLS
      // access.  Since we know that we are generating an executable,
      // we can convert this to Initial-Exec.  If we also know that
      // this is a local symbol, we can further switch to Local-Exec.
      if (is_final)
	return tls::TLSOPT_TO_LE;
      return tls::TLSOPT_TO_IE;

    case elfcpp::R_X86_64_TLSLD:
      // This is Local-Dynamic, which refers to a local symbol in the
      // dynamic TLS block.  Since we know that we generating an
      // executable, we can switch to Local-Exec.
      return tls::TLSOPT_TO_LE;

    case elfcpp::R_X86_64_DTPOFF32:
    case elfcpp::R_X86_64_DTPOFF64:
      // Another Local-Dynamic reloc.
      return tls::TLSOPT_TO_LE;

    case elfcpp::R_X86_64_GOTTPOFF:
      // These are Initial-Exec relocs which get the thread offset
      // from the GOT.  If we know that we are linking against the
      // local symbol, we can switch to Local-Exec, which links the
      // thread offset into the instruction.
      if (is_final)
	return tls::TLSOPT_TO_LE;
      return tls::TLSOPT_NONE;

    case elfcpp::R_X86_64_TPOFF32:
      // When we already have Local-Exec, there is nothing further we
      // can do.
      return tls::TLSOPT_NONE;

    default:
      gold_unreachable();
    }
}

// Get the Reference_flags for a particular relocation.

template<int size>
int
Target_x86_64<size>::Scan::get_reference_flags(unsigned int r_type)
{
  switch (r_type)
    {
    case elfcpp::R_X86_64_NONE:
    case elfcpp::R_X86_64_GNU_VTINHERIT:
    case elfcpp::R_X86_64_GNU_VTENTRY:
    case elfcpp::R_X86_64_GOTPC32:
    case elfcpp::R_X86_64_GOTPC64:
      // No symbol reference.
      return 0;

    case elfcpp::R_X86_64_64:
    case elfcpp::R_X86_64_32:
    case elfcpp::R_X86_64_32S:
    case elfcpp::R_X86_64_16:
    case elfcpp::R_X86_64_8:
      return Symbol::ABSOLUTE_REF;

    case elfcpp::R_X86_64_PC64:
    case elfcpp::R_X86_64_PC32:
    case elfcpp::R_X86_64_PC16:
    case elfcpp::R_X86_64_PC8:
    case elfcpp::R_X86_64_GOTOFF64:
      return Symbol::RELATIVE_REF;

    case elfcpp::R_X86_64_PLT32:
    case elfcpp::R_X86_64_PLTOFF64:
      return Symbol::FUNCTION_CALL | Symbol::RELATIVE_REF;

    case elfcpp::R_X86_64_GOT64:
    case elfcpp::R_X86_64_GOT32:
    case elfcpp::R_X86_64_GOTPCREL64:
    case elfcpp::R_X86_64_GOTPCREL:
    case elfcpp::R_X86_64_GOTPLT64:
      // Absolute in GOT.
      return Symbol::ABSOLUTE_REF;

    case elfcpp::R_X86_64_TLSGD:            // Global-dynamic
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // Global-dynamic (from ~oliva url)
    case elfcpp::R_X86_64_TLSDESC_CALL:
    case elfcpp::R_X86_64_TLSLD:            // Local-dynamic
    case elfcpp::R_X86_64_DTPOFF32:
    case elfcpp::R_X86_64_DTPOFF64:
    case elfcpp::R_X86_64_GOTTPOFF:         // Initial-exec
    case elfcpp::R_X86_64_TPOFF32:          // Local-exec
      return Symbol::TLS_REF;

    case elfcpp::R_X86_64_COPY:
    case elfcpp::R_X86_64_GLOB_DAT:
    case elfcpp::R_X86_64_JUMP_SLOT:
    case elfcpp::R_X86_64_RELATIVE:
    case elfcpp::R_X86_64_IRELATIVE:
    case elfcpp::R_X86_64_TPOFF64:
    case elfcpp::R_X86_64_DTPMOD64:
    case elfcpp::R_X86_64_TLSDESC:
    case elfcpp::R_X86_64_SIZE32:
    case elfcpp::R_X86_64_SIZE64:
    default:
      // Not expected.  We will give an error later.
      return 0;
    }
}

// Report an unsupported relocation against a local symbol.

template<int size>
void
Target_x86_64<size>::Scan::unsupported_reloc_local(
     Sized_relobj_file<size, false>* object,
     unsigned int r_type)
{
  gold_error(_("%s: unsupported reloc %u against local symbol"),
	     object->name().c_str(), r_type);
}

// We are about to emit a dynamic relocation of type R_TYPE.  If the
// dynamic linker does not support it, issue an error.  The GNU linker
// only issues a non-PIC error for an allocated read-only section.
// Here we know the section is allocated, but we don't know that it is
// read-only.  But we check for all the relocation types which the
// glibc dynamic linker supports, so it seems appropriate to issue an
// error even if the section is not read-only.  If GSYM is not NULL,
// it is the symbol the relocation is against; if it is NULL, the
// relocation is against a local symbol.

template<int size>
void
Target_x86_64<size>::Scan::check_non_pic(Relobj* object, unsigned int r_type,
					 Symbol* gsym)
{
  switch (r_type)
    {
      // These are the relocation types supported by glibc for x86_64
      // which should always work.
    case elfcpp::R_X86_64_RELATIVE:
    case elfcpp::R_X86_64_IRELATIVE:
    case elfcpp::R_X86_64_GLOB_DAT:
    case elfcpp::R_X86_64_JUMP_SLOT:
    case elfcpp::R_X86_64_DTPMOD64:
    case elfcpp::R_X86_64_DTPOFF64:
    case elfcpp::R_X86_64_TPOFF64:
    case elfcpp::R_X86_64_64:
    case elfcpp::R_X86_64_COPY:
      return;

      // glibc supports these reloc types, but they can overflow.
    case elfcpp::R_X86_64_PC32:
      // A PC relative reference is OK against a local symbol or if
      // the symbol is defined locally.
      if (gsym == NULL
	  || (!gsym->is_from_dynobj()
	      && !gsym->is_undefined()
	      && !gsym->is_preemptible()))
	return;
      /* Fall through.  */
    case elfcpp::R_X86_64_32:
      // R_X86_64_32 is OK for x32.
      if (size == 32 && r_type == elfcpp::R_X86_64_32)
	return;
      if (this->issued_non_pic_error_)
	return;
      gold_assert(parameters->options().output_is_position_independent());
      if (gsym == NULL)
	object->error(_("requires dynamic R_X86_64_32 reloc which may "
			"overflow at runtime; recompile with -fPIC"));
      else
	object->error(_("requires dynamic %s reloc against '%s' which may "
			"overflow at runtime; recompile with -fPIC"),
		      (r_type == elfcpp::R_X86_64_32
		       ? "R_X86_64_32"
		       : "R_X86_64_PC32"),
		      gsym->name());
      this->issued_non_pic_error_ = true;
      return;

    default:
      // This prevents us from issuing more than one error per reloc
      // section.  But we can still wind up issuing more than one
      // error per object file.
      if (this->issued_non_pic_error_)
	return;
      gold_assert(parameters->options().output_is_position_independent());
      object->error(_("requires unsupported dynamic reloc %u; "
		      "recompile with -fPIC"),
		    r_type);
      this->issued_non_pic_error_ = true;
      return;

    case elfcpp::R_X86_64_NONE:
      gold_unreachable();
    }
}

// Return whether we need to make a PLT entry for a relocation of the
// given type against a STT_GNU_IFUNC symbol.

template<int size>
bool
Target_x86_64<size>::Scan::reloc_needs_plt_for_ifunc(
     Sized_relobj_file<size, false>* object,
     unsigned int r_type)
{
  int flags = Scan::get_reference_flags(r_type);
  if (flags & Symbol::TLS_REF)
    gold_error(_("%s: unsupported TLS reloc %u for IFUNC symbol"),
	       object->name().c_str(), r_type);
  return flags != 0;
}

// Scan a relocation for a local symbol.

template<int size>
inline void
Target_x86_64<size>::Scan::local(Symbol_table* symtab,
				 Layout* layout,
				 Target_x86_64<size>* target,
				 Sized_relobj_file<size, false>* object,
				 unsigned int data_shndx,
				 Output_section* output_section,
				 const elfcpp::Rela<size, false>& reloc,
				 unsigned int r_type,
				 const elfcpp::Sym<size, false>& lsym,
				 bool is_discarded)
{
  if (is_discarded)
    return;

  // A local STT_GNU_IFUNC symbol may require a PLT entry.
  bool is_ifunc = lsym.get_st_type() == elfcpp::STT_GNU_IFUNC;
  if (is_ifunc && this->reloc_needs_plt_for_ifunc(object, r_type))
    {
      unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
      target->make_local_ifunc_plt_entry(symtab, layout, object, r_sym);
    }

  switch (r_type)
    {
    case elfcpp::R_X86_64_NONE:
    case elfcpp::R_X86_64_GNU_VTINHERIT:
    case elfcpp::R_X86_64_GNU_VTENTRY:
      break;

    case elfcpp::R_X86_64_64:
      // If building a shared library (or a position-independent
      // executable), we need to create a dynamic relocation for this
      // location.  The relocation applied at link time will apply the
      // link-time value, so we flag the location with an
      // R_X86_64_RELATIVE relocation so the dynamic loader can
      // relocate it easily.
      if (parameters->options().output_is_position_independent())
	{
	  unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
	  Reloc_section* rela_dyn = target->rela_dyn_section(layout);
	  rela_dyn->add_local_relative(object, r_sym,
				       (size == 32
					? elfcpp::R_X86_64_RELATIVE64
					: elfcpp::R_X86_64_RELATIVE),
				       output_section, data_shndx,
				       reloc.get_r_offset(),
				       reloc.get_r_addend(), is_ifunc);
	}
      break;

    case elfcpp::R_X86_64_32:
    case elfcpp::R_X86_64_32S:
    case elfcpp::R_X86_64_16:
    case elfcpp::R_X86_64_8:
      // If building a shared library (or a position-independent
      // executable), we need to create a dynamic relocation for this
      // location.  We can't use an R_X86_64_RELATIVE relocation
      // because that is always a 64-bit relocation.
      if (parameters->options().output_is_position_independent())
	{
	  // Use R_X86_64_RELATIVE relocation for R_X86_64_32 under x32.
	  if (size == 32 && r_type == elfcpp::R_X86_64_32)
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
	      Reloc_section* rela_dyn = target->rela_dyn_section(layout);
	      rela_dyn->add_local_relative(object, r_sym,
					   elfcpp::R_X86_64_RELATIVE,
					   output_section, data_shndx,
					   reloc.get_r_offset(),
					   reloc.get_r_addend(), is_ifunc);
	      break;
	    }

	  this->check_non_pic(object, r_type, NULL);

	  Reloc_section* rela_dyn = target->rela_dyn_section(layout);
	  unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
	  if (lsym.get_st_type() != elfcpp::STT_SECTION)
	    rela_dyn->add_local(object, r_sym, r_type, output_section,
				data_shndx, reloc.get_r_offset(),
				reloc.get_r_addend());
	  else
	    {
	      gold_assert(lsym.get_st_value() == 0);
	      unsigned int shndx = lsym.get_st_shndx();
	      bool is_ordinary;
	      shndx = object->adjust_sym_shndx(r_sym, shndx,
					       &is_ordinary);
	      if (!is_ordinary)
		object->error(_("section symbol %u has bad shndx %u"),
			      r_sym, shndx);
	      else
		rela_dyn->add_local_section(object, shndx,
					    r_type, output_section,
					    data_shndx, reloc.get_r_offset(),
					    reloc.get_r_addend());
	    }
	}
      break;

    case elfcpp::R_X86_64_PC64:
    case elfcpp::R_X86_64_PC32:
    case elfcpp::R_X86_64_PC16:
    case elfcpp::R_X86_64_PC8:
      break;

    case elfcpp::R_X86_64_PLT32:
      // Since we know this is a local symbol, we can handle this as a
      // PC32 reloc.
      break;

    case elfcpp::R_X86_64_GOTPC32:
    case elfcpp::R_X86_64_GOTOFF64:
    case elfcpp::R_X86_64_GOTPC64:
    case elfcpp::R_X86_64_PLTOFF64:
      // We need a GOT section.
      target->got_section(symtab, layout);
      // For PLTOFF64, we'd normally want a PLT section, but since we
      // know this is a local symbol, no PLT is needed.
      break;

    case elfcpp::R_X86_64_GOT64:
    case elfcpp::R_X86_64_GOT32:
    case elfcpp::R_X86_64_GOTPCREL64:
    case elfcpp::R_X86_64_GOTPCREL:
    case elfcpp::R_X86_64_GOTPLT64:
      {
	// The symbol requires a GOT entry.
	Output_data_got<64, false>* got = target->got_section(symtab, layout);
	unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());

	// For a STT_GNU_IFUNC symbol we want the PLT offset.  That
	// lets function pointers compare correctly with shared
	// libraries.  Otherwise we would need an IRELATIVE reloc.
	bool is_new;
	if (is_ifunc)
	  is_new = got->add_local_plt(object, r_sym, GOT_TYPE_STANDARD);
	else
	  is_new = got->add_local(object, r_sym, GOT_TYPE_STANDARD);
	if (is_new)
	  {
	    // If we are generating a shared object, we need to add a
	    // dynamic relocation for this symbol's GOT entry.
	    if (parameters->options().output_is_position_independent())
	      {
		Reloc_section* rela_dyn = target->rela_dyn_section(layout);
		// R_X86_64_RELATIVE assumes a 64-bit relocation.
		if (r_type != elfcpp::R_X86_64_GOT32)
		  {
		    unsigned int got_offset =
		      object->local_got_offset(r_sym, GOT_TYPE_STANDARD);
		    rela_dyn->add_local_relative(object, r_sym,
						 elfcpp::R_X86_64_RELATIVE,
						 got, got_offset, 0, is_ifunc);
		  }
		else
		  {
		    this->check_non_pic(object, r_type, NULL);

		    gold_assert(lsym.get_st_type() != elfcpp::STT_SECTION);
		    rela_dyn->add_local(
			object, r_sym, r_type, got,
			object->local_got_offset(r_sym, GOT_TYPE_STANDARD), 0);
		  }
	      }
	  }
	// For GOTPLT64, we'd normally want a PLT section, but since
	// we know this is a local symbol, no PLT is needed.
      }
      break;

    case elfcpp::R_X86_64_COPY:
    case elfcpp::R_X86_64_GLOB_DAT:
    case elfcpp::R_X86_64_JUMP_SLOT:
    case elfcpp::R_X86_64_RELATIVE:
    case elfcpp::R_X86_64_IRELATIVE:
      // These are outstanding tls relocs, which are unexpected when linking
    case elfcpp::R_X86_64_TPOFF64:
    case elfcpp::R_X86_64_DTPMOD64:
    case elfcpp::R_X86_64_TLSDESC:
      gold_error(_("%s: unexpected reloc %u in object file"),
		 object->name().c_str(), r_type);
      break;

      // These are initial tls relocs, which are expected when linking
    case elfcpp::R_X86_64_TLSGD:            // Global-dynamic
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // Global-dynamic (from ~oliva url)
    case elfcpp::R_X86_64_TLSDESC_CALL:
    case elfcpp::R_X86_64_TLSLD:            // Local-dynamic
    case elfcpp::R_X86_64_DTPOFF32:
    case elfcpp::R_X86_64_DTPOFF64:
    case elfcpp::R_X86_64_GOTTPOFF:         // Initial-exec
    case elfcpp::R_X86_64_TPOFF32:          // Local-exec
      {
	bool output_is_shared = parameters->options().shared();
	const tls::Tls_optimization optimized_type
	    = Target_x86_64<size>::optimize_tls_reloc(!output_is_shared,
						      r_type);
	switch (r_type)
	  {
	  case elfcpp::R_X86_64_TLSGD:       // General-dynamic
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a pair of GOT entries for the module index and
		// dtv-relative offset.
		Output_data_got<64, false>* got
		    = target->got_section(symtab, layout);
		unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
		unsigned int shndx = lsym.get_st_shndx();
		bool is_ordinary;
		shndx = object->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
		if (!is_ordinary)
		  object->error(_("local symbol %u has bad shndx %u"),
			      r_sym, shndx);
		else
		  got->add_local_pair_with_rel(object, r_sym,
					       shndx,
					       GOT_TYPE_TLS_PAIR,
					       target->rela_dyn_section(layout),
					       elfcpp::R_X86_64_DTPMOD64);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_local(object, r_type);
	    break;

	  case elfcpp::R_X86_64_GOTPC32_TLSDESC:
	    target->define_tls_base_symbol(symtab, layout);
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create reserved PLT and GOT entries for the resolver.
		target->reserve_tlsdesc_entries(symtab, layout);

		// Generate a double GOT entry with an
		// R_X86_64_TLSDESC reloc.  The R_X86_64_TLSDESC reloc
		// is resolved lazily, so the GOT entry needs to be in
		// an area in .got.plt, not .got.  Call got_section to
		// make sure the section has been created.
		target->got_section(symtab, layout);
		Output_data_got<64, false>* got = target->got_tlsdesc_section();
		unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
		if (!object->local_has_got_offset(r_sym, GOT_TYPE_TLS_DESC))
		  {
		    unsigned int got_offset = got->add_constant(0);
		    got->add_constant(0);
		    object->set_local_got_offset(r_sym, GOT_TYPE_TLS_DESC,
						 got_offset);
		    Reloc_section* rt = target->rela_tlsdesc_section(layout);
		    // We store the arguments we need in a vector, and
		    // use the index into the vector as the parameter
		    // to pass to the target specific routines.
		    uintptr_t intarg = target->add_tlsdesc_info(object, r_sym);
		    void* arg = reinterpret_cast<void*>(intarg);
		    rt->add_target_specific(elfcpp::R_X86_64_TLSDESC, arg,
					    got, got_offset, 0);
		  }
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_local(object, r_type);
	    break;

	  case elfcpp::R_X86_64_TLSDESC_CALL:
	    break;

	  case elfcpp::R_X86_64_TLSLD:       // Local-dynamic
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a GOT entry for the module index.
		target->got_mod_index_entry(symtab, layout, object);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_local(object, r_type);
	    break;

	  case elfcpp::R_X86_64_DTPOFF32:
	  case elfcpp::R_X86_64_DTPOFF64:
	    break;

	  case elfcpp::R_X86_64_GOTTPOFF:    // Initial-exec
	    layout->set_has_static_tls();
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a GOT entry for the tp-relative offset.
		Output_data_got<64, false>* got
		    = target->got_section(symtab, layout);
		unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
		got->add_local_with_rel(object, r_sym, GOT_TYPE_TLS_OFFSET,
					target->rela_dyn_section(layout),
					elfcpp::R_X86_64_TPOFF64);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_local(object, r_type);
	    break;

	  case elfcpp::R_X86_64_TPOFF32:     // Local-exec
	    layout->set_has_static_tls();
	    if (output_is_shared)
	      unsupported_reloc_local(object, r_type);
	    break;

	  default:
	    gold_unreachable();
	  }
      }
      break;

    case elfcpp::R_X86_64_SIZE32:
    case elfcpp::R_X86_64_SIZE64:
    default:
      gold_error(_("%s: unsupported reloc %u against local symbol"),
		 object->name().c_str(), r_type);
      break;
    }
}


// Report an unsupported relocation against a global symbol.

template<int size>
void
Target_x86_64<size>::Scan::unsupported_reloc_global(
    Sized_relobj_file<size, false>* object,
    unsigned int r_type,
    Symbol* gsym)
{
  gold_error(_("%s: unsupported reloc %u against global symbol %s"),
	     object->name().c_str(), r_type, gsym->demangled_name().c_str());
}

// Returns true if this relocation type could be that of a function pointer.
template<int size>
inline bool
Target_x86_64<size>::Scan::possible_function_pointer_reloc(unsigned int r_type)
{
  switch (r_type)
    {
    case elfcpp::R_X86_64_64:
    case elfcpp::R_X86_64_32:
    case elfcpp::R_X86_64_32S:
    case elfcpp::R_X86_64_16:
    case elfcpp::R_X86_64_8:
    case elfcpp::R_X86_64_GOT64:
    case elfcpp::R_X86_64_GOT32:
    case elfcpp::R_X86_64_GOTPCREL64:
    case elfcpp::R_X86_64_GOTPCREL:
    case elfcpp::R_X86_64_GOTPLT64:
      {
	return true;
      }
    }
  return false;
}

// For safe ICF, scan a relocation for a local symbol to check if it
// corresponds to a function pointer being taken.  In that case mark
// the function whose pointer was taken as not foldable.

template<int size>
inline bool
Target_x86_64<size>::Scan::local_reloc_may_be_function_pointer(
  Symbol_table* ,
  Layout* ,
  Target_x86_64<size>* ,
  Sized_relobj_file<size, false>* ,
  unsigned int ,
  Output_section* ,
  const elfcpp::Rela<size, false>& ,
  unsigned int r_type,
  const elfcpp::Sym<size, false>&)
{
  // When building a shared library, do not fold any local symbols as it is
  // not possible to distinguish pointer taken versus a call by looking at
  // the relocation types.
  return (parameters->options().shared()
	  || possible_function_pointer_reloc(r_type));
}

// For safe ICF, scan a relocation for a global symbol to check if it
// corresponds to a function pointer being taken.  In that case mark
// the function whose pointer was taken as not foldable.

template<int size>
inline bool
Target_x86_64<size>::Scan::global_reloc_may_be_function_pointer(
  Symbol_table*,
  Layout* ,
  Target_x86_64<size>* ,
  Sized_relobj_file<size, false>* ,
  unsigned int ,
  Output_section* ,
  const elfcpp::Rela<size, false>& ,
  unsigned int r_type,
  Symbol* gsym)
{
  // When building a shared library, do not fold symbols whose visibility
  // is hidden, internal or protected.
  return ((parameters->options().shared()
	   && (gsym->visibility() == elfcpp::STV_INTERNAL
	       || gsym->visibility() == elfcpp::STV_PROTECTED
	       || gsym->visibility() == elfcpp::STV_HIDDEN))
	  || possible_function_pointer_reloc(r_type));
}

// Scan a relocation for a global symbol.

template<int size>
inline void
Target_x86_64<size>::Scan::global(Symbol_table* symtab,
			    Layout* layout,
			    Target_x86_64<size>* target,
			    Sized_relobj_file<size, false>* object,
			    unsigned int data_shndx,
			    Output_section* output_section,
			    const elfcpp::Rela<size, false>& reloc,
			    unsigned int r_type,
			    Symbol* gsym)
{
  // A STT_GNU_IFUNC symbol may require a PLT entry.
  if (gsym->type() == elfcpp::STT_GNU_IFUNC
      && this->reloc_needs_plt_for_ifunc(object, r_type))
    target->make_plt_entry(symtab, layout, gsym);

  switch (r_type)
    {
    case elfcpp::R_X86_64_NONE:
    case elfcpp::R_X86_64_GNU_VTINHERIT:
    case elfcpp::R_X86_64_GNU_VTENTRY:
      break;

    case elfcpp::R_X86_64_64:
    case elfcpp::R_X86_64_32:
    case elfcpp::R_X86_64_32S:
    case elfcpp::R_X86_64_16:
    case elfcpp::R_X86_64_8:
      {
	// Make a PLT entry if necessary.
	if (gsym->needs_plt_entry())
	  {
	    target->make_plt_entry(symtab, layout, gsym);
	    // Since this is not a PC-relative relocation, we may be
	    // taking the address of a function. In that case we need to
	    // set the entry in the dynamic symbol table to the address of
	    // the PLT entry.
	    if (gsym->is_from_dynobj() && !parameters->options().shared())
	      gsym->set_needs_dynsym_value();
	  }
	// Make a dynamic relocation if necessary.
	if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
	  {
	    if (gsym->may_need_copy_reloc())
	      {
		target->copy_reloc(symtab, layout, object,
				   data_shndx, output_section, gsym, reloc);
	      }
	    else if (((size == 64 && r_type == elfcpp::R_X86_64_64)
		      || (size == 32 && r_type == elfcpp::R_X86_64_32))
		     && gsym->type() == elfcpp::STT_GNU_IFUNC
		     && gsym->can_use_relative_reloc(false)
		     && !gsym->is_from_dynobj()
		     && !gsym->is_undefined()
		     && !gsym->is_preemptible())
	      {
		// Use an IRELATIVE reloc for a locally defined
		// STT_GNU_IFUNC symbol.  This makes a function
		// address in a PIE executable match the address in a
		// shared library that it links against.
		Reloc_section* rela_dyn =
		  target->rela_irelative_section(layout);
		unsigned int r_type = elfcpp::R_X86_64_IRELATIVE;
		rela_dyn->add_symbolless_global_addend(gsym, r_type,
						       output_section, object,
						       data_shndx,
						       reloc.get_r_offset(),
						       reloc.get_r_addend());
	      }
	    else if (((size == 64 && r_type == elfcpp::R_X86_64_64)
		      || (size == 32 && r_type == elfcpp::R_X86_64_32))
		     && gsym->can_use_relative_reloc(false))
	      {
		Reloc_section* rela_dyn = target->rela_dyn_section(layout);
		rela_dyn->add_global_relative(gsym, elfcpp::R_X86_64_RELATIVE,
					      output_section, object,
					      data_shndx,
					      reloc.get_r_offset(),
					      reloc.get_r_addend(), false);
	      }
	    else
	      {
		this->check_non_pic(object, r_type, gsym);
		Reloc_section* rela_dyn = target->rela_dyn_section(layout);
		rela_dyn->add_global(gsym, r_type, output_section, object,
				     data_shndx, reloc.get_r_offset(),
				     reloc.get_r_addend());
	      }
	  }
      }
      break;

    case elfcpp::R_X86_64_PC64:
    case elfcpp::R_X86_64_PC32:
    case elfcpp::R_X86_64_PC16:
    case elfcpp::R_X86_64_PC8:
      {
	// Make a PLT entry if necessary.
	if (gsym->needs_plt_entry())
	  target->make_plt_entry(symtab, layout, gsym);
	// Make a dynamic relocation if necessary.
	if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
	  {
	    if (gsym->may_need_copy_reloc())
	      {
		target->copy_reloc(symtab, layout, object,
				   data_shndx, output_section, gsym, reloc);
	      }
	    else
	      {
		this->check_non_pic(object, r_type, gsym);
		Reloc_section* rela_dyn = target->rela_dyn_section(layout);
		rela_dyn->add_global(gsym, r_type, output_section, object,
				     data_shndx, reloc.get_r_offset(),
				     reloc.get_r_addend());
	      }
	  }
      }
      break;

    case elfcpp::R_X86_64_GOT64:
    case elfcpp::R_X86_64_GOT32:
    case elfcpp::R_X86_64_GOTPCREL64:
    case elfcpp::R_X86_64_GOTPCREL:
    case elfcpp::R_X86_64_GOTPLT64:
      {
	// The symbol requires a GOT entry.
	Output_data_got<64, false>* got = target->got_section(symtab, layout);
	if (gsym->final_value_is_known())
	  {
	    // For a STT_GNU_IFUNC symbol we want the PLT address.
	    if (gsym->type() == elfcpp::STT_GNU_IFUNC)
	      got->add_global_plt(gsym, GOT_TYPE_STANDARD);
	    else
	      got->add_global(gsym, GOT_TYPE_STANDARD);
	  }
	else
	  {
	    // If this symbol is not fully resolved, we need to add a
	    // dynamic relocation for it.
	    Reloc_section* rela_dyn = target->rela_dyn_section(layout);

	    // Use a GLOB_DAT rather than a RELATIVE reloc if:
	    //
	    // 1) The symbol may be defined in some other module.
	    //
	    // 2) We are building a shared library and this is a
	    // protected symbol; using GLOB_DAT means that the dynamic
	    // linker can use the address of the PLT in the main
	    // executable when appropriate so that function address
	    // comparisons work.
	    //
	    // 3) This is a STT_GNU_IFUNC symbol in position dependent
	    // code, again so that function address comparisons work.
	    if (gsym->is_from_dynobj()
		|| gsym->is_undefined()
		|| gsym->is_preemptible()
		|| (gsym->visibility() == elfcpp::STV_PROTECTED
		    && parameters->options().shared())
		|| (gsym->type() == elfcpp::STT_GNU_IFUNC
		    && parameters->options().output_is_position_independent()))
	      got->add_global_with_rel(gsym, GOT_TYPE_STANDARD, rela_dyn,
				       elfcpp::R_X86_64_GLOB_DAT);
	    else
	      {
		// For a STT_GNU_IFUNC symbol we want to write the PLT
		// offset into the GOT, so that function pointer
		// comparisons work correctly.
		bool is_new;
		if (gsym->type() != elfcpp::STT_GNU_IFUNC)
		  is_new = got->add_global(gsym, GOT_TYPE_STANDARD);
		else
		  {
		    is_new = got->add_global_plt(gsym, GOT_TYPE_STANDARD);
		    // Tell the dynamic linker to use the PLT address
		    // when resolving relocations.
		    if (gsym->is_from_dynobj()
			&& !parameters->options().shared())
		      gsym->set_needs_dynsym_value();
		  }
		if (is_new)
		  {
		    unsigned int got_off = gsym->got_offset(GOT_TYPE_STANDARD);
		    rela_dyn->add_global_relative(gsym,
						  elfcpp::R_X86_64_RELATIVE,
						  got, got_off, 0, false);
		  }
	      }
	  }
	// For GOTPLT64, we also need a PLT entry (but only if the
	// symbol is not fully resolved).
	if (r_type == elfcpp::R_X86_64_GOTPLT64
	    && !gsym->final_value_is_known())
	  target->make_plt_entry(symtab, layout, gsym);
      }
      break;

    case elfcpp::R_X86_64_PLT32:
      // If the symbol is fully resolved, this is just a PC32 reloc.
      // Otherwise we need a PLT entry.
      if (gsym->final_value_is_known())
	break;
      // If building a shared library, we can also skip the PLT entry
      // if the symbol is defined in the output file and is protected
      // or hidden.
      if (gsym->is_defined()
	  && !gsym->is_from_dynobj()
	  && !gsym->is_preemptible())
	break;
      target->make_plt_entry(symtab, layout, gsym);
      break;

    case elfcpp::R_X86_64_GOTPC32:
    case elfcpp::R_X86_64_GOTOFF64:
    case elfcpp::R_X86_64_GOTPC64:
    case elfcpp::R_X86_64_PLTOFF64:
      // We need a GOT section.
      target->got_section(symtab, layout);
      // For PLTOFF64, we also need a PLT entry (but only if the
      // symbol is not fully resolved).
      if (r_type == elfcpp::R_X86_64_PLTOFF64
	  && !gsym->final_value_is_known())
	target->make_plt_entry(symtab, layout, gsym);
      break;

    case elfcpp::R_X86_64_COPY:
    case elfcpp::R_X86_64_GLOB_DAT:
    case elfcpp::R_X86_64_JUMP_SLOT:
    case elfcpp::R_X86_64_RELATIVE:
    case elfcpp::R_X86_64_IRELATIVE:
      // These are outstanding tls relocs, which are unexpected when linking
    case elfcpp::R_X86_64_TPOFF64:
    case elfcpp::R_X86_64_DTPMOD64:
    case elfcpp::R_X86_64_TLSDESC:
      gold_error(_("%s: unexpected reloc %u in object file"),
		 object->name().c_str(), r_type);
      break;

      // These are initial tls relocs, which are expected for global()
    case elfcpp::R_X86_64_TLSGD:            // Global-dynamic
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // Global-dynamic (from ~oliva url)
    case elfcpp::R_X86_64_TLSDESC_CALL:
    case elfcpp::R_X86_64_TLSLD:            // Local-dynamic
    case elfcpp::R_X86_64_DTPOFF32:
    case elfcpp::R_X86_64_DTPOFF64:
    case elfcpp::R_X86_64_GOTTPOFF:         // Initial-exec
    case elfcpp::R_X86_64_TPOFF32:          // Local-exec
      {
	const bool is_final = gsym->final_value_is_known();
	const tls::Tls_optimization optimized_type
	    = Target_x86_64<size>::optimize_tls_reloc(is_final, r_type);
	switch (r_type)
	  {
	  case elfcpp::R_X86_64_TLSGD:       // General-dynamic
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a pair of GOT entries for the module index and
		// dtv-relative offset.
		Output_data_got<64, false>* got
		    = target->got_section(symtab, layout);
		got->add_global_pair_with_rel(gsym, GOT_TYPE_TLS_PAIR,
					      target->rela_dyn_section(layout),
					      elfcpp::R_X86_64_DTPMOD64,
					      elfcpp::R_X86_64_DTPOFF64);
	      }
	    else if (optimized_type == tls::TLSOPT_TO_IE)
	      {
		// Create a GOT entry for the tp-relative offset.
		Output_data_got<64, false>* got
		    = target->got_section(symtab, layout);
		got->add_global_with_rel(gsym, GOT_TYPE_TLS_OFFSET,
					 target->rela_dyn_section(layout),
					 elfcpp::R_X86_64_TPOFF64);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_global(object, r_type, gsym);
	    break;

	  case elfcpp::R_X86_64_GOTPC32_TLSDESC:
	    target->define_tls_base_symbol(symtab, layout);
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create reserved PLT and GOT entries for the resolver.
		target->reserve_tlsdesc_entries(symtab, layout);

		// Create a double GOT entry with an R_X86_64_TLSDESC
		// reloc.  The R_X86_64_TLSDESC reloc is resolved
		// lazily, so the GOT entry needs to be in an area in
		// .got.plt, not .got.  Call got_section to make sure
		// the section has been created.
		target->got_section(symtab, layout);
		Output_data_got<64, false>* got = target->got_tlsdesc_section();
		Reloc_section* rt = target->rela_tlsdesc_section(layout);
		got->add_global_pair_with_rel(gsym, GOT_TYPE_TLS_DESC, rt,
					      elfcpp::R_X86_64_TLSDESC, 0);
	      }
	    else if (optimized_type == tls::TLSOPT_TO_IE)
	      {
		// Create a GOT entry for the tp-relative offset.
		Output_data_got<64, false>* got
		    = target->got_section(symtab, layout);
		got->add_global_with_rel(gsym, GOT_TYPE_TLS_OFFSET,
					 target->rela_dyn_section(layout),
					 elfcpp::R_X86_64_TPOFF64);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_global(object, r_type, gsym);
	    break;

	  case elfcpp::R_X86_64_TLSDESC_CALL:
	    break;

	  case elfcpp::R_X86_64_TLSLD:       // Local-dynamic
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a GOT entry for the module index.
		target->got_mod_index_entry(symtab, layout, object);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_global(object, r_type, gsym);
	    break;

	  case elfcpp::R_X86_64_DTPOFF32:
	  case elfcpp::R_X86_64_DTPOFF64:
	    break;

	  case elfcpp::R_X86_64_GOTTPOFF:    // Initial-exec
	    layout->set_has_static_tls();
	    if (optimized_type == tls::TLSOPT_NONE)
	      {
		// Create a GOT entry for the tp-relative offset.
		Output_data_got<64, false>* got
		    = target->got_section(symtab, layout);
		got->add_global_with_rel(gsym, GOT_TYPE_TLS_OFFSET,
					 target->rela_dyn_section(layout),
					 elfcpp::R_X86_64_TPOFF64);
	      }
	    else if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_global(object, r_type, gsym);
	    break;

	  case elfcpp::R_X86_64_TPOFF32:     // Local-exec
	    layout->set_has_static_tls();
	    if (parameters->options().shared())
	      unsupported_reloc_global(object, r_type, gsym);
	    break;

	  default:
	    gold_unreachable();
	  }
      }
      break;

    case elfcpp::R_X86_64_SIZE32:
    case elfcpp::R_X86_64_SIZE64:
    default:
      gold_error(_("%s: unsupported reloc %u against global symbol %s"),
		 object->name().c_str(), r_type,
		 gsym->demangled_name().c_str());
      break;
    }
}

template<int size>
void
Target_x86_64<size>::gc_process_relocs(Symbol_table* symtab,
				       Layout* layout,
				       Sized_relobj_file<size, false>* object,
				       unsigned int data_shndx,
				       unsigned int sh_type,
				       const unsigned char* prelocs,
				       size_t reloc_count,
				       Output_section* output_section,
				       bool needs_special_offset_handling,
				       size_t local_symbol_count,
				       const unsigned char* plocal_symbols)
{

  if (sh_type == elfcpp::SHT_REL)
    {
      return;
    }

   gold::gc_process_relocs<size, false, Target_x86_64<size>, elfcpp::SHT_RELA,
			   typename Target_x86_64<size>::Scan,
			   typename Target_x86_64<size>::Relocatable_size_for_reloc>(
    symtab,
    layout,
    this,
    object,
    data_shndx,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    local_symbol_count,
    plocal_symbols);

}
// Scan relocations for a section.

template<int size>
void
Target_x86_64<size>::scan_relocs(Symbol_table* symtab,
				 Layout* layout,
				 Sized_relobj_file<size, false>* object,
				 unsigned int data_shndx,
				 unsigned int sh_type,
				 const unsigned char* prelocs,
				 size_t reloc_count,
				 Output_section* output_section,
				 bool needs_special_offset_handling,
				 size_t local_symbol_count,
				 const unsigned char* plocal_symbols)
{
  if (sh_type == elfcpp::SHT_REL)
    {
      gold_error(_("%s: unsupported REL reloc section"),
		 object->name().c_str());
      return;
    }

  gold::scan_relocs<size, false, Target_x86_64<size>, elfcpp::SHT_RELA,
      typename Target_x86_64<size>::Scan>(
    symtab,
    layout,
    this,
    object,
    data_shndx,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    local_symbol_count,
    plocal_symbols);
}

// Finalize the sections.

template<int size>
void
Target_x86_64<size>::do_finalize_sections(
    Layout* layout,
    const Input_objects*,
    Symbol_table* symtab)
{
  const Reloc_section* rel_plt = (this->plt_ == NULL
				  ? NULL
				  : this->plt_->rela_plt());
  layout->add_target_dynamic_tags(false, this->got_plt_, rel_plt,
				  this->rela_dyn_, true, false);

  // Fill in some more dynamic tags.
  Output_data_dynamic* const odyn = layout->dynamic_data();
  if (odyn != NULL)
    {
      if (this->plt_ != NULL
	  && this->plt_->output_section() != NULL
	  && this->plt_->has_tlsdesc_entry())
	{
	  unsigned int plt_offset = this->plt_->get_tlsdesc_plt_offset();
	  unsigned int got_offset = this->plt_->get_tlsdesc_got_offset();
	  this->got_->finalize_data_size();
	  odyn->add_section_plus_offset(elfcpp::DT_TLSDESC_PLT,
					this->plt_, plt_offset);
	  odyn->add_section_plus_offset(elfcpp::DT_TLSDESC_GOT,
					this->got_, got_offset);
	}
    }

  // Emit any relocs we saved in an attempt to avoid generating COPY
  // relocs.
  if (this->copy_relocs_.any_saved_relocs())
    this->copy_relocs_.emit(this->rela_dyn_section(layout));

  // Set the size of the _GLOBAL_OFFSET_TABLE_ symbol to the size of
  // the .got.plt section.
  Symbol* sym = this->global_offset_table_;
  if (sym != NULL)
    {
      uint64_t data_size = this->got_plt_->current_data_size();
      symtab->get_sized_symbol<size>(sym)->set_symsize(data_size);
    }

  if (parameters->doing_static_link()
      && (this->plt_ == NULL || !this->plt_->has_irelative_section()))
    {
      // If linking statically, make sure that the __rela_iplt symbols
      // were defined if necessary, even if we didn't create a PLT.
      static const Define_symbol_in_segment syms[] =
	{
	  {
	    "__rela_iplt_start",	// name
	    elfcpp::PT_LOAD,		// segment_type
	    elfcpp::PF_W,		// segment_flags_set
	    elfcpp::PF(0),		// segment_flags_clear
	    0,				// value
	    0,				// size
	    elfcpp::STT_NOTYPE,		// type
	    elfcpp::STB_GLOBAL,		// binding
	    elfcpp::STV_HIDDEN,		// visibility
	    0,				// nonvis
	    Symbol::SEGMENT_START,	// offset_from_base
	    true			// only_if_ref
	  },
	  {
	    "__rela_iplt_end",		// name
	    elfcpp::PT_LOAD,		// segment_type
	    elfcpp::PF_W,		// segment_flags_set
	    elfcpp::PF(0),		// segment_flags_clear
	    0,				// value
	    0,				// size
	    elfcpp::STT_NOTYPE,		// type
	    elfcpp::STB_GLOBAL,		// binding
	    elfcpp::STV_HIDDEN,		// visibility
	    0,				// nonvis
	    Symbol::SEGMENT_START,	// offset_from_base
	    true			// only_if_ref
	  }
	};

      symtab->define_symbols(layout, 2, syms,
			     layout->script_options()->saw_sections_clause());
    }
}

// Perform a relocation.

template<int size>
inline bool
Target_x86_64<size>::Relocate::relocate(
    const Relocate_info<size, false>* relinfo,
    Target_x86_64<size>* target,
    Output_section*,
    size_t relnum,
    const elfcpp::Rela<size, false>& rela,
    unsigned int r_type,
    const Sized_symbol<size>* gsym,
    const Symbol_value<size>* psymval,
    unsigned char* view,
    typename elfcpp::Elf_types<size>::Elf_Addr address,
    section_size_type view_size)
{
  if (this->skip_call_tls_get_addr_)
    {
      if ((r_type != elfcpp::R_X86_64_PLT32
	   && r_type != elfcpp::R_X86_64_PC32)
	  || gsym == NULL
	  || strcmp(gsym->name(), "__tls_get_addr") != 0)
	{
	  gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
				 _("missing expected TLS relocation"));
	}
      else
	{
	  this->skip_call_tls_get_addr_ = false;
	  return false;
	}
    }

  if (view == NULL)
    return true;

  const Sized_relobj_file<size, false>* object = relinfo->object;

  // Pick the value to use for symbols defined in the PLT.
  Symbol_value<size> symval;
  if (gsym != NULL
      && gsym->use_plt_offset(Scan::get_reference_flags(r_type)))
    {
      symval.set_output_value(target->plt_address_for_global(gsym));
      psymval = &symval;
    }
  else if (gsym == NULL && psymval->is_ifunc_symbol())
    {
      unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
      if (object->local_has_plt_offset(r_sym))
	{
	  symval.set_output_value(target->plt_address_for_local(object, r_sym));
	  psymval = &symval;
	}
    }

  const elfcpp::Elf_Xword addend = rela.get_r_addend();

  // Get the GOT offset if needed.
  // The GOT pointer points to the end of the GOT section.
  // We need to subtract the size of the GOT section to get
  // the actual offset to use in the relocation.
  bool have_got_offset = false;
  unsigned int got_offset = 0;
  switch (r_type)
    {
    case elfcpp::R_X86_64_GOT32:
    case elfcpp::R_X86_64_GOT64:
    case elfcpp::R_X86_64_GOTPLT64:
    case elfcpp::R_X86_64_GOTPCREL:
    case elfcpp::R_X86_64_GOTPCREL64:
      if (gsym != NULL)
	{
	  gold_assert(gsym->has_got_offset(GOT_TYPE_STANDARD));
	  got_offset = gsym->got_offset(GOT_TYPE_STANDARD) - target->got_size();
	}
      else
	{
	  unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
	  gold_assert(object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD));
	  got_offset = (object->local_got_offset(r_sym, GOT_TYPE_STANDARD)
			- target->got_size());
	}
      have_got_offset = true;
      break;

    default:
      break;
    }

  switch (r_type)
    {
    case elfcpp::R_X86_64_NONE:
    case elfcpp::R_X86_64_GNU_VTINHERIT:
    case elfcpp::R_X86_64_GNU_VTENTRY:
      break;

    case elfcpp::R_X86_64_64:
      Relocate_functions<size, false>::rela64(view, object, psymval, addend);
      break;

    case elfcpp::R_X86_64_PC64:
      Relocate_functions<size, false>::pcrela64(view, object, psymval, addend,
					      address);
      break;

    case elfcpp::R_X86_64_32:
      // FIXME: we need to verify that value + addend fits into 32 bits:
      //    uint64_t x = value + addend;
      //    x == static_cast<uint64_t>(static_cast<uint32_t>(x))
      // Likewise for other <=32-bit relocations (but see R_X86_64_32S).
      Relocate_functions<size, false>::rela32(view, object, psymval, addend);
      break;

    case elfcpp::R_X86_64_32S:
      // FIXME: we need to verify that value + addend fits into 32 bits:
      //    int64_t x = value + addend;   // note this quantity is signed!
      //    x == static_cast<int64_t>(static_cast<int32_t>(x))
      Relocate_functions<size, false>::rela32(view, object, psymval, addend);
      break;

    case elfcpp::R_X86_64_PC32:
      Relocate_functions<size, false>::pcrela32(view, object, psymval, addend,
						address);
      break;

    case elfcpp::R_X86_64_16:
      Relocate_functions<size, false>::rela16(view, object, psymval, addend);
      break;

    case elfcpp::R_X86_64_PC16:
      Relocate_functions<size, false>::pcrela16(view, object, psymval, addend,
						address);
      break;

    case elfcpp::R_X86_64_8:
      Relocate_functions<size, false>::rela8(view, object, psymval, addend);
      break;

    case elfcpp::R_X86_64_PC8:
      Relocate_functions<size, false>::pcrela8(view, object, psymval, addend,
					       address);
      break;

    case elfcpp::R_X86_64_PLT32:
      gold_assert(gsym == NULL
		  || gsym->has_plt_offset()
		  || gsym->final_value_is_known()
		  || (gsym->is_defined()
		      && !gsym->is_from_dynobj()
		      && !gsym->is_preemptible()));
      // Note: while this code looks the same as for R_X86_64_PC32, it
      // behaves differently because psymval was set to point to
      // the PLT entry, rather than the symbol, in Scan::global().
      Relocate_functions<size, false>::pcrela32(view, object, psymval, addend,
						address);
      break;

    case elfcpp::R_X86_64_PLTOFF64:
      {
	gold_assert(gsym);
	gold_assert(gsym->has_plt_offset()
		    || gsym->final_value_is_known());
	typename elfcpp::Elf_types<size>::Elf_Addr got_address;
	got_address = target->got_section(NULL, NULL)->address();
	Relocate_functions<size, false>::rela64(view, object, psymval,
						addend - got_address);
      }

    case elfcpp::R_X86_64_GOT32:
      gold_assert(have_got_offset);
      Relocate_functions<size, false>::rela32(view, got_offset, addend);
      break;

    case elfcpp::R_X86_64_GOTPC32:
      {
	gold_assert(gsym);
	typename elfcpp::Elf_types<size>::Elf_Addr value;
	value = target->got_plt_section()->address();
	Relocate_functions<size, false>::pcrela32(view, value, addend, address);
      }
      break;

    case elfcpp::R_X86_64_GOT64:
      // The ABI doc says "Like GOT64, but indicates a PLT entry is needed."
      // Since we always add a PLT entry, this is equivalent.
    case elfcpp::R_X86_64_GOTPLT64:
      gold_assert(have_got_offset);
      Relocate_functions<size, false>::rela64(view, got_offset, addend);
      break;

    case elfcpp::R_X86_64_GOTPC64:
      {
	gold_assert(gsym);
	typename elfcpp::Elf_types<size>::Elf_Addr value;
	value = target->got_plt_section()->address();
	Relocate_functions<size, false>::pcrela64(view, value, addend, address);
      }
      break;

    case elfcpp::R_X86_64_GOTOFF64:
      {
	typename elfcpp::Elf_types<size>::Elf_Addr value;
	value = (psymval->value(object, 0)
		 - target->got_plt_section()->address());
	Relocate_functions<size, false>::rela64(view, value, addend);
      }
      break;

    case elfcpp::R_X86_64_GOTPCREL:
      {
	gold_assert(have_got_offset);
	typename elfcpp::Elf_types<size>::Elf_Addr value;
	value = target->got_plt_section()->address() + got_offset;
	Relocate_functions<size, false>::pcrela32(view, value, addend, address);
      }
      break;

    case elfcpp::R_X86_64_GOTPCREL64:
      {
	gold_assert(have_got_offset);
	typename elfcpp::Elf_types<size>::Elf_Addr value;
	value = target->got_plt_section()->address() + got_offset;
	Relocate_functions<size, false>::pcrela64(view, value, addend, address);
      }
      break;

    case elfcpp::R_X86_64_COPY:
    case elfcpp::R_X86_64_GLOB_DAT:
    case elfcpp::R_X86_64_JUMP_SLOT:
    case elfcpp::R_X86_64_RELATIVE:
    case elfcpp::R_X86_64_IRELATIVE:
      // These are outstanding tls relocs, which are unexpected when linking
    case elfcpp::R_X86_64_TPOFF64:
    case elfcpp::R_X86_64_DTPMOD64:
    case elfcpp::R_X86_64_TLSDESC:
      gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			     _("unexpected reloc %u in object file"),
			     r_type);
      break;

      // These are initial tls relocs, which are expected when linking
    case elfcpp::R_X86_64_TLSGD:            // Global-dynamic
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // Global-dynamic (from ~oliva url)
    case elfcpp::R_X86_64_TLSDESC_CALL:
    case elfcpp::R_X86_64_TLSLD:            // Local-dynamic
    case elfcpp::R_X86_64_DTPOFF32:
    case elfcpp::R_X86_64_DTPOFF64:
    case elfcpp::R_X86_64_GOTTPOFF:         // Initial-exec
    case elfcpp::R_X86_64_TPOFF32:          // Local-exec
      this->relocate_tls(relinfo, target, relnum, rela, r_type, gsym, psymval,
			 view, address, view_size);
      break;

    case elfcpp::R_X86_64_SIZE32:
    case elfcpp::R_X86_64_SIZE64:
    default:
      gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			     _("unsupported reloc %u"),
			     r_type);
      break;
    }

  return true;
}

// Perform a TLS relocation.

template<int size>
inline void
Target_x86_64<size>::Relocate::relocate_tls(
    const Relocate_info<size, false>* relinfo,
    Target_x86_64<size>* target,
    size_t relnum,
    const elfcpp::Rela<size, false>& rela,
    unsigned int r_type,
    const Sized_symbol<size>* gsym,
    const Symbol_value<size>* psymval,
    unsigned char* view,
    typename elfcpp::Elf_types<size>::Elf_Addr address,
    section_size_type view_size)
{
  Output_segment* tls_segment = relinfo->layout->tls_segment();

  const Sized_relobj_file<size, false>* object = relinfo->object;
  const elfcpp::Elf_Xword addend = rela.get_r_addend();
  elfcpp::Shdr<size, false> data_shdr(relinfo->data_shdr);
  bool is_executable = (data_shdr.get_sh_flags() & elfcpp::SHF_EXECINSTR) != 0;

  typename elfcpp::Elf_types<size>::Elf_Addr value = psymval->value(relinfo->object, 0);

  const bool is_final = (gsym == NULL
			 ? !parameters->options().shared()
			 : gsym->final_value_is_known());
  tls::Tls_optimization optimized_type
      = Target_x86_64<size>::optimize_tls_reloc(is_final, r_type);
  switch (r_type)
    {
    case elfcpp::R_X86_64_TLSGD:            // Global-dynamic
      if (!is_executable && optimized_type == tls::TLSOPT_TO_LE)
	{
	  // If this code sequence is used in a non-executable section,
	  // we will not optimize the R_X86_64_DTPOFF32/64 relocation,
	  // on the assumption that it's being used by itself in a debug
	  // section.  Therefore, in the unlikely event that the code
	  // sequence appears in a non-executable section, we simply
	  // leave it unoptimized.
	  optimized_type = tls::TLSOPT_NONE;
	}
      if (optimized_type == tls::TLSOPT_TO_LE)
	{
	  if (tls_segment == NULL)
	    {
	      gold_assert(parameters->errors()->error_count() > 0
			  || issue_undefined_symbol_error(gsym));
	      return;
	    }
	  this->tls_gd_to_le(relinfo, relnum, tls_segment,
			     rela, r_type, value, view,
			     view_size);
	  break;
	}
      else
	{
	  unsigned int got_type = (optimized_type == tls::TLSOPT_TO_IE
				   ? GOT_TYPE_TLS_OFFSET
				   : GOT_TYPE_TLS_PAIR);
	  unsigned int got_offset;
	  if (gsym != NULL)
	    {
	      gold_assert(gsym->has_got_offset(got_type));
	      got_offset = gsym->got_offset(got_type) - target->got_size();
	    }
	  else
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
	      gold_assert(object->local_has_got_offset(r_sym, got_type));
	      got_offset = (object->local_got_offset(r_sym, got_type)
			    - target->got_size());
	    }
	  if (optimized_type == tls::TLSOPT_TO_IE)
	    {
	      value = target->got_plt_section()->address() + got_offset;
	      this->tls_gd_to_ie(relinfo, relnum, tls_segment, rela, r_type,
				 value, view, address, view_size);
	      break;
	    }
	  else if (optimized_type == tls::TLSOPT_NONE)
	    {
	      // Relocate the field with the offset of the pair of GOT
	      // entries.
	      value = target->got_plt_section()->address() + got_offset;
	      Relocate_functions<size, false>::pcrela32(view, value, addend,
							address);
	      break;
	    }
	}
      gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			     _("unsupported reloc %u"), r_type);
      break;

    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // Global-dynamic (from ~oliva url)
    case elfcpp::R_X86_64_TLSDESC_CALL:
      if (!is_executable && optimized_type == tls::TLSOPT_TO_LE)
	{
	  // See above comment for R_X86_64_TLSGD.
	  optimized_type = tls::TLSOPT_NONE;
	}
      if (optimized_type == tls::TLSOPT_TO_LE)
	{
	  if (tls_segment == NULL)
	    {
	      gold_assert(parameters->errors()->error_count() > 0
			  || issue_undefined_symbol_error(gsym));
	      return;
	    }
	  this->tls_desc_gd_to_le(relinfo, relnum, tls_segment,
				  rela, r_type, value, view,
				  view_size);
	  break;
	}
      else
	{
	  unsigned int got_type = (optimized_type == tls::TLSOPT_TO_IE
				   ? GOT_TYPE_TLS_OFFSET
				   : GOT_TYPE_TLS_DESC);
	  unsigned int got_offset = 0;
	  if (r_type == elfcpp::R_X86_64_GOTPC32_TLSDESC
	      && optimized_type == tls::TLSOPT_NONE)
	    {
	      // We created GOT entries in the .got.tlsdesc portion of
	      // the .got.plt section, but the offset stored in the
	      // symbol is the offset within .got.tlsdesc.
	      got_offset = (target->got_size()
			    + target->got_plt_section()->data_size());
	    }
	  if (gsym != NULL)
	    {
	      gold_assert(gsym->has_got_offset(got_type));
	      got_offset += gsym->got_offset(got_type) - target->got_size();
	    }
	  else
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
	      gold_assert(object->local_has_got_offset(r_sym, got_type));
	      got_offset += (object->local_got_offset(r_sym, got_type)
			     - target->got_size());
	    }
	  if (optimized_type == tls::TLSOPT_TO_IE)
	    {
	      if (tls_segment == NULL)
		{
		  gold_assert(parameters->errors()->error_count() > 0
			      || issue_undefined_symbol_error(gsym));
		  return;
		}
	      value = target->got_plt_section()->address() + got_offset;
	      this->tls_desc_gd_to_ie(relinfo, relnum, tls_segment,
				      rela, r_type, value, view, address,
				      view_size);
	      break;
	    }
	  else if (optimized_type == tls::TLSOPT_NONE)
	    {
	      if (r_type == elfcpp::R_X86_64_GOTPC32_TLSDESC)
		{
		  // Relocate the field with the offset of the pair of GOT
		  // entries.
		  value = target->got_plt_section()->address() + got_offset;
		  Relocate_functions<size, false>::pcrela32(view, value, addend,
							    address);
		}
	      break;
	    }
	}
      gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			     _("unsupported reloc %u"), r_type);
      break;

    case elfcpp::R_X86_64_TLSLD:            // Local-dynamic
      if (!is_executable && optimized_type == tls::TLSOPT_TO_LE)
	{
	  // See above comment for R_X86_64_TLSGD.
	  optimized_type = tls::TLSOPT_NONE;
	}
      if (optimized_type == tls::TLSOPT_TO_LE)
	{
	  if (tls_segment == NULL)
	    {
	      gold_assert(parameters->errors()->error_count() > 0
			  || issue_undefined_symbol_error(gsym));
	      return;
	    }
	  this->tls_ld_to_le(relinfo, relnum, tls_segment, rela, r_type,
			     value, view, view_size);
	  break;
	}
      else if (optimized_type == tls::TLSOPT_NONE)
	{
	  // Relocate the field with the offset of the GOT entry for
	  // the module index.
	  unsigned int got_offset;
	  got_offset = (target->got_mod_index_entry(NULL, NULL, NULL)
			- target->got_size());
	  value = target->got_plt_section()->address() + got_offset;
	  Relocate_functions<size, false>::pcrela32(view, value, addend,
						    address);
	  break;
	}
      gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			     _("unsupported reloc %u"), r_type);
      break;

    case elfcpp::R_X86_64_DTPOFF32:
      // This relocation type is used in debugging information.
      // In that case we need to not optimize the value.  If the
      // section is not executable, then we assume we should not
      // optimize this reloc.  See comments above for R_X86_64_TLSGD,
      // R_X86_64_GOTPC32_TLSDESC, R_X86_64_TLSDESC_CALL, and
      // R_X86_64_TLSLD.
      if (optimized_type == tls::TLSOPT_TO_LE && is_executable)
	{
	  if (tls_segment == NULL)
	    {
	      gold_assert(parameters->errors()->error_count() > 0
			  || issue_undefined_symbol_error(gsym));
	      return;
	    }
	  value -= tls_segment->memsz();
	}
      Relocate_functions<size, false>::rela32(view, value, addend);
      break;

    case elfcpp::R_X86_64_DTPOFF64:
      // See R_X86_64_DTPOFF32, just above, for why we check for is_executable.
      if (optimized_type == tls::TLSOPT_TO_LE && is_executable)
	{
	  if (tls_segment == NULL)
	    {
	      gold_assert(parameters->errors()->error_count() > 0
			  || issue_undefined_symbol_error(gsym));
	      return;
	    }
	  value -= tls_segment->memsz();
	}
      Relocate_functions<size, false>::rela64(view, value, addend);
      break;

    case elfcpp::R_X86_64_GOTTPOFF:         // Initial-exec
      if (optimized_type == tls::TLSOPT_TO_LE)
	{
	  if (tls_segment == NULL)
	    {
	      gold_assert(parameters->errors()->error_count() > 0
			  || issue_undefined_symbol_error(gsym));
	      return;
	    }
	  Target_x86_64<size>::Relocate::tls_ie_to_le(relinfo, relnum,
						      tls_segment, rela,
						      r_type, value, view,
						      view_size);
	  break;
	}
      else if (optimized_type == tls::TLSOPT_NONE)
	{
	  // Relocate the field with the offset of the GOT entry for
	  // the tp-relative offset of the symbol.
	  unsigned int got_offset;
	  if (gsym != NULL)
	    {
	      gold_assert(gsym->has_got_offset(GOT_TYPE_TLS_OFFSET));
	      got_offset = (gsym->got_offset(GOT_TYPE_TLS_OFFSET)
			    - target->got_size());
	    }
	  else
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
	      gold_assert(object->local_has_got_offset(r_sym,
						       GOT_TYPE_TLS_OFFSET));
	      got_offset = (object->local_got_offset(r_sym, GOT_TYPE_TLS_OFFSET)
			    - target->got_size());
	    }
	  value = target->got_plt_section()->address() + got_offset;
	  Relocate_functions<size, false>::pcrela32(view, value, addend,
						    address);
	  break;
	}
      gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			     _("unsupported reloc type %u"),
			     r_type);
      break;

    case elfcpp::R_X86_64_TPOFF32:          // Local-exec
      if (tls_segment == NULL)
	{
	  gold_assert(parameters->errors()->error_count() > 0
		      || issue_undefined_symbol_error(gsym));
	  return;
	}
      value -= tls_segment->memsz();
      Relocate_functions<size, false>::rela32(view, value, addend);
      break;
    }
}

// Do a relocation in which we convert a TLS General-Dynamic to an
// Initial-Exec.

template<int size>
inline void
Target_x86_64<size>::Relocate::tls_gd_to_ie(
    const Relocate_info<size, false>* relinfo,
    size_t relnum,
    Output_segment*,
    const elfcpp::Rela<size, false>& rela,
    unsigned int,
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    unsigned char* view,
    typename elfcpp::Elf_types<size>::Elf_Addr address,
    section_size_type view_size)
{
  // For SIZE == 64:
  //	.byte 0x66; leaq foo@@tlsgd(%rip),%rdi;
  //	.word 0x6666; rex64; call __tls_get_addr
  //	==> movq %fs:0,%rax; addq x@@gottpoff(%rip),%rax
  // For SIZE == 32:
  //	leaq foo@@tlsgd(%rip),%rdi;
  //	.word 0x6666; rex64; call __tls_get_addr
  //	==> movl %fs:0,%eax; addq x@@gottpoff(%rip),%rax

  tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, 12);
  tls::check_tls(relinfo, relnum, rela.get_r_offset(),
		 (memcmp(view + 4, "\x66\x66\x48\xe8", 4) == 0));

  if (size == 64)
    {
      tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size,
		       -4);
      tls::check_tls(relinfo, relnum, rela.get_r_offset(),
		     (memcmp(view - 4, "\x66\x48\x8d\x3d", 4) == 0));
      memcpy(view - 4, "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x03\x05\0\0\0\0",
	     16);
    }
  else
    {
      tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size,
		       -3);
      tls::check_tls(relinfo, relnum, rela.get_r_offset(),
		     (memcmp(view - 3, "\x48\x8d\x3d", 3) == 0));
      memcpy(view - 3, "\x64\x8b\x04\x25\0\0\0\0\x48\x03\x05\0\0\0\0",
	     15);
    }

  const elfcpp::Elf_Xword addend = rela.get_r_addend();
  Relocate_functions<size, false>::pcrela32(view + 8, value, addend - 8,
					    address);

  // The next reloc should be a PLT32 reloc against __tls_get_addr.
  // We can skip it.
  this->skip_call_tls_get_addr_ = true;
}

// Do a relocation in which we convert a TLS General-Dynamic to a
// Local-Exec.

template<int size>
inline void
Target_x86_64<size>::Relocate::tls_gd_to_le(
    const Relocate_info<size, false>* relinfo,
    size_t relnum,
    Output_segment* tls_segment,
    const elfcpp::Rela<size, false>& rela,
    unsigned int,
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    unsigned char* view,
    section_size_type view_size)
{
  // For SIZE == 64:
  //	.byte 0x66; leaq foo@@tlsgd(%rip),%rdi;
  //	.word 0x6666; rex64; call __tls_get_addr
  //	==> movq %fs:0,%rax; leaq x@@tpoff(%rax),%rax
  // For SIZE == 32:
  //	leaq foo@@tlsgd(%rip),%rdi;
  //	.word 0x6666; rex64; call __tls_get_addr
  //	==> movl %fs:0,%eax; leaq x@@tpoff(%rax),%rax

  tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, 12);
  tls::check_tls(relinfo, relnum, rela.get_r_offset(),
		 (memcmp(view + 4, "\x66\x66\x48\xe8", 4) == 0));

  if (size == 64)
    {
      tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size,
		       -4);
      tls::check_tls(relinfo, relnum, rela.get_r_offset(),
		     (memcmp(view - 4, "\x66\x48\x8d\x3d", 4) == 0));
      memcpy(view - 4, "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x8d\x80\0\0\0\0",
	     16);
    }
  else
    {
      tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size,
		       -3);
      tls::check_tls(relinfo, relnum, rela.get_r_offset(),
		     (memcmp(view - 3, "\x48\x8d\x3d", 3) == 0));

      memcpy(view - 3, "\x64\x8b\x04\x25\0\0\0\0\x48\x8d\x80\0\0\0\0",
	     15);
    }

  value -= tls_segment->memsz();
  Relocate_functions<size, false>::rela32(view + 8, value, 0);

  // The next reloc should be a PLT32 reloc against __tls_get_addr.
  // We can skip it.
  this->skip_call_tls_get_addr_ = true;
}

// Do a TLSDESC-style General-Dynamic to Initial-Exec transition.

template<int size>
inline void
Target_x86_64<size>::Relocate::tls_desc_gd_to_ie(
    const Relocate_info<size, false>* relinfo,
    size_t relnum,
    Output_segment*,
    const elfcpp::Rela<size, false>& rela,
    unsigned int r_type,
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    unsigned char* view,
    typename elfcpp::Elf_types<size>::Elf_Addr address,
    section_size_type view_size)
{
  if (r_type == elfcpp::R_X86_64_GOTPC32_TLSDESC)
    {
      // leaq foo@@tlsdesc(%rip), %rax
      // ==> movq foo@@gottpoff(%rip), %rax
      tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, -3);
      tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, 4);
      tls::check_tls(relinfo, relnum, rela.get_r_offset(),
		     view[-3] == 0x48 && view[-2] == 0x8d && view[-1] == 0x05);
      view[-2] = 0x8b;
      const elfcpp::Elf_Xword addend = rela.get_r_addend();
      Relocate_functions<size, false>::pcrela32(view, value, addend, address);
    }
  else
    {
      // call *foo@@tlscall(%rax)
      // ==> nop; nop
      gold_assert(r_type == elfcpp::R_X86_64_TLSDESC_CALL);
      tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, 2);
      tls::check_tls(relinfo, relnum, rela.get_r_offset(),
		     view[0] == 0xff && view[1] == 0x10);
      view[0] = 0x66;
      view[1] = 0x90;
    }
}

// Do a TLSDESC-style General-Dynamic to Local-Exec transition.

template<int size>
inline void
Target_x86_64<size>::Relocate::tls_desc_gd_to_le(
    const Relocate_info<size, false>* relinfo,
    size_t relnum,
    Output_segment* tls_segment,
    const elfcpp::Rela<size, false>& rela,
    unsigned int r_type,
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    unsigned char* view,
    section_size_type view_size)
{
  if (r_type == elfcpp::R_X86_64_GOTPC32_TLSDESC)
    {
      // leaq foo@@tlsdesc(%rip), %rax
      // ==> movq foo@@tpoff, %rax
      tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, -3);
      tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, 4);
      tls::check_tls(relinfo, relnum, rela.get_r_offset(),
		     view[-3] == 0x48 && view[-2] == 0x8d && view[-1] == 0x05);
      view[-2] = 0xc7;
      view[-1] = 0xc0;
      value -= tls_segment->memsz();
      Relocate_functions<size, false>::rela32(view, value, 0);
    }
  else
    {
      // call *foo@@tlscall(%rax)
      // ==> nop; nop
      gold_assert(r_type == elfcpp::R_X86_64_TLSDESC_CALL);
      tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, 2);
      tls::check_tls(relinfo, relnum, rela.get_r_offset(),
		     view[0] == 0xff && view[1] == 0x10);
      view[0] = 0x66;
      view[1] = 0x90;
    }
}

template<int size>
inline void
Target_x86_64<size>::Relocate::tls_ld_to_le(
    const Relocate_info<size, false>* relinfo,
    size_t relnum,
    Output_segment*,
    const elfcpp::Rela<size, false>& rela,
    unsigned int,
    typename elfcpp::Elf_types<size>::Elf_Addr,
    unsigned char* view,
    section_size_type view_size)
{
  // leaq foo@@tlsld(%rip),%rdi; call __tls_get_addr@@plt;
  // For SIZE == 64:
  // ... leq foo@@dtpoff(%rax),%reg
  // ==> .word 0x6666; .byte 0x66; movq %fs:0,%rax ... leaq x@@tpoff(%rax),%rdx
  // For SIZE == 32:
  // ... leq foo@@dtpoff(%rax),%reg
  // ==> nopl 0x0(%rax); movl %fs:0,%eax ... leaq x@@tpoff(%rax),%rdx

  tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, -3);
  tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, 9);

  tls::check_tls(relinfo, relnum, rela.get_r_offset(),
		 view[-3] == 0x48 && view[-2] == 0x8d && view[-1] == 0x3d);

  tls::check_tls(relinfo, relnum, rela.get_r_offset(), view[4] == 0xe8);

  if (size == 64)
    memcpy(view - 3, "\x66\x66\x66\x64\x48\x8b\x04\x25\0\0\0\0", 12);
  else
    memcpy(view - 3, "\x0f\x1f\x40\x00\x64\x8b\x04\x25\0\0\0\0", 12);

  // The next reloc should be a PLT32 reloc against __tls_get_addr.
  // We can skip it.
  this->skip_call_tls_get_addr_ = true;
}

// Do a relocation in which we convert a TLS Initial-Exec to a
// Local-Exec.

template<int size>
inline void
Target_x86_64<size>::Relocate::tls_ie_to_le(
    const Relocate_info<size, false>* relinfo,
    size_t relnum,
    Output_segment* tls_segment,
    const elfcpp::Rela<size, false>& rela,
    unsigned int,
    typename elfcpp::Elf_types<size>::Elf_Addr value,
    unsigned char* view,
    section_size_type view_size)
{
  // We need to examine the opcodes to figure out which instruction we
  // are looking at.

  // movq foo@@gottpoff(%rip),%reg  ==>  movq $YY,%reg
  // addq foo@@gottpoff(%rip),%reg  ==>  addq $YY,%reg

  tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, -3);
  tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, 4);

  unsigned char op1 = view[-3];
  unsigned char op2 = view[-2];
  unsigned char op3 = view[-1];
  unsigned char reg = op3 >> 3;

  if (op2 == 0x8b)
    {
      // movq
      if (op1 == 0x4c)
	view[-3] = 0x49;
      view[-2] = 0xc7;
      view[-1] = 0xc0 | reg;
    }
  else if (reg == 4)
    {
      // Special handling for %rsp.
      if (op1 == 0x4c)
	view[-3] = 0x49;
      view[-2] = 0x81;
      view[-1] = 0xc0 | reg;
    }
  else
    {
      // addq
      if (op1 == 0x4c)
	view[-3] = 0x4d;
      view[-2] = 0x8d;
      view[-1] = 0x80 | reg | (reg << 3);
    }

  value -= tls_segment->memsz();
  Relocate_functions<size, false>::rela32(view, value, 0);
}

// Relocate section data.

template<int size>
void
Target_x86_64<size>::relocate_section(
    const Relocate_info<size, false>* relinfo,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    unsigned char* view,
    typename elfcpp::Elf_types<size>::Elf_Addr address,
    section_size_type view_size,
    const Reloc_symbol_changes* reloc_symbol_changes)
{
  gold_assert(sh_type == elfcpp::SHT_RELA);

  gold::relocate_section<size, false, Target_x86_64<size>, elfcpp::SHT_RELA,
			 typename Target_x86_64<size>::Relocate,
			 gold::Default_comdat_behavior>(
    relinfo,
    this,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    view,
    address,
    view_size,
    reloc_symbol_changes);
}

// Apply an incremental relocation.  Incremental relocations always refer
// to global symbols.

template<int size>
void
Target_x86_64<size>::apply_relocation(
    const Relocate_info<size, false>* relinfo,
    typename elfcpp::Elf_types<size>::Elf_Addr r_offset,
    unsigned int r_type,
    typename elfcpp::Elf_types<size>::Elf_Swxword r_addend,
    const Symbol* gsym,
    unsigned char* view,
    typename elfcpp::Elf_types<size>::Elf_Addr address,
    section_size_type view_size)
{
  gold::apply_relocation<size, false, Target_x86_64<size>,
			 typename Target_x86_64<size>::Relocate>(
    relinfo,
    this,
    r_offset,
    r_type,
    r_addend,
    gsym,
    view,
    address,
    view_size);
}

// Return the size of a relocation while scanning during a relocatable
// link.

template<int size>
unsigned int
Target_x86_64<size>::Relocatable_size_for_reloc::get_size_for_reloc(
    unsigned int r_type,
    Relobj* object)
{
  switch (r_type)
    {
    case elfcpp::R_X86_64_NONE:
    case elfcpp::R_X86_64_GNU_VTINHERIT:
    case elfcpp::R_X86_64_GNU_VTENTRY:
    case elfcpp::R_X86_64_TLSGD:            // Global-dynamic
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // Global-dynamic (from ~oliva url)
    case elfcpp::R_X86_64_TLSDESC_CALL:
    case elfcpp::R_X86_64_TLSLD:            // Local-dynamic
    case elfcpp::R_X86_64_DTPOFF32:
    case elfcpp::R_X86_64_DTPOFF64:
    case elfcpp::R_X86_64_GOTTPOFF:         // Initial-exec
    case elfcpp::R_X86_64_TPOFF32:          // Local-exec
      return 0;

    case elfcpp::R_X86_64_64:
    case elfcpp::R_X86_64_PC64:
    case elfcpp::R_X86_64_GOTOFF64:
    case elfcpp::R_X86_64_GOTPC64:
    case elfcpp::R_X86_64_PLTOFF64:
    case elfcpp::R_X86_64_GOT64:
    case elfcpp::R_X86_64_GOTPCREL64:
    case elfcpp::R_X86_64_GOTPCREL:
    case elfcpp::R_X86_64_GOTPLT64:
      return 8;

    case elfcpp::R_X86_64_32:
    case elfcpp::R_X86_64_32S:
    case elfcpp::R_X86_64_PC32:
    case elfcpp::R_X86_64_PLT32:
    case elfcpp::R_X86_64_GOTPC32:
    case elfcpp::R_X86_64_GOT32:
      return 4;

    case elfcpp::R_X86_64_16:
    case elfcpp::R_X86_64_PC16:
      return 2;

    case elfcpp::R_X86_64_8:
    case elfcpp::R_X86_64_PC8:
      return 1;

    case elfcpp::R_X86_64_COPY:
    case elfcpp::R_X86_64_GLOB_DAT:
    case elfcpp::R_X86_64_JUMP_SLOT:
    case elfcpp::R_X86_64_RELATIVE:
    case elfcpp::R_X86_64_IRELATIVE:
      // These are outstanding tls relocs, which are unexpected when linking
    case elfcpp::R_X86_64_TPOFF64:
    case elfcpp::R_X86_64_DTPMOD64:
    case elfcpp::R_X86_64_TLSDESC:
      object->error(_("unexpected reloc %u in object file"), r_type);
      return 0;

    case elfcpp::R_X86_64_SIZE32:
    case elfcpp::R_X86_64_SIZE64:
    default:
      object->error(_("unsupported reloc %u against local symbol"), r_type);
      return 0;
    }
}

// Scan the relocs during a relocatable link.

template<int size>
void
Target_x86_64<size>::scan_relocatable_relocs(
    Symbol_table* symtab,
    Layout* layout,
    Sized_relobj_file<size, false>* object,
    unsigned int data_shndx,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    size_t local_symbol_count,
    const unsigned char* plocal_symbols,
    Relocatable_relocs* rr)
{
  gold_assert(sh_type == elfcpp::SHT_RELA);

  typedef gold::Default_scan_relocatable_relocs<elfcpp::SHT_RELA,
    Relocatable_size_for_reloc> Scan_relocatable_relocs;

  gold::scan_relocatable_relocs<size, false, elfcpp::SHT_RELA,
      Scan_relocatable_relocs>(
    symtab,
    layout,
    object,
    data_shndx,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    local_symbol_count,
    plocal_symbols,
    rr);
}

// Relocate a section during a relocatable link.

template<int size>
void
Target_x86_64<size>::relocate_relocs(
    const Relocate_info<size, false>* relinfo,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    typename elfcpp::Elf_types<size>::Elf_Off offset_in_output_section,
    const Relocatable_relocs* rr,
    unsigned char* view,
    typename elfcpp::Elf_types<size>::Elf_Addr view_address,
    section_size_type view_size,
    unsigned char* reloc_view,
    section_size_type reloc_view_size)
{
  gold_assert(sh_type == elfcpp::SHT_RELA);

  gold::relocate_relocs<size, false, elfcpp::SHT_RELA>(
    relinfo,
    prelocs,
    reloc_count,
    output_section,
    offset_in_output_section,
    rr,
    view,
    view_address,
    view_size,
    reloc_view,
    reloc_view_size);
}

// Return the value to use for a dynamic which requires special
// treatment.  This is how we support equality comparisons of function
// pointers across shared library boundaries, as described in the
// processor specific ABI supplement.

template<int size>
uint64_t
Target_x86_64<size>::do_dynsym_value(const Symbol* gsym) const
{
  gold_assert(gsym->is_from_dynobj() && gsym->has_plt_offset());
  return this->plt_address_for_global(gsym);
}

// Return a string used to fill a code section with nops to take up
// the specified length.

template<int size>
std::string
Target_x86_64<size>::do_code_fill(section_size_type length) const
{
  if (length >= 16)
    {
      // Build a jmpq instruction to skip over the bytes.
      unsigned char jmp[5];
      jmp[0] = 0xe9;
      elfcpp::Swap_unaligned<32, false>::writeval(jmp + 1, length - 5);
      return (std::string(reinterpret_cast<char*>(&jmp[0]), 5)
	      + std::string(length - 5, static_cast<char>(0x90)));
    }

  // Nop sequences of various lengths.
  const char nop1[1] = { '\x90' };                 // nop
  const char nop2[2] = { '\x66', '\x90' };         // xchg %ax %ax
  const char nop3[3] = { '\x0f', '\x1f', '\x00' }; // nop (%rax)
  const char nop4[4] = { '\x0f', '\x1f', '\x40',   // nop 0(%rax)
			 '\x00'};
  const char nop5[5] = { '\x0f', '\x1f', '\x44',   // nop 0(%rax,%rax,1)
			 '\x00', '\x00' };
  const char nop6[6] = { '\x66', '\x0f', '\x1f',   // nopw 0(%rax,%rax,1)
			 '\x44', '\x00', '\x00' };
  const char nop7[7] = { '\x0f', '\x1f', '\x80',   // nopl 0L(%rax)
			 '\x00', '\x00', '\x00',
			 '\x00' };
  const char nop8[8] = { '\x0f', '\x1f', '\x84',   // nopl 0L(%rax,%rax,1)
			 '\x00', '\x00', '\x00',
			 '\x00', '\x00' };
  const char nop9[9] = { '\x66', '\x0f', '\x1f',   // nopw 0L(%rax,%rax,1)
			 '\x84', '\x00', '\x00',
			 '\x00', '\x00', '\x00' };
  const char nop10[10] = { '\x66', '\x2e', '\x0f', // nopw %cs:0L(%rax,%rax,1)
			   '\x1f', '\x84', '\x00',
			   '\x00', '\x00', '\x00',
			   '\x00' };
  const char nop11[11] = { '\x66', '\x66', '\x2e', // data16
			   '\x0f', '\x1f', '\x84', // nopw %cs:0L(%rax,%rax,1)
			   '\x00', '\x00', '\x00',
			   '\x00', '\x00' };
  const char nop12[12] = { '\x66', '\x66', '\x66', // data16; data16
			   '\x2e', '\x0f', '\x1f', // nopw %cs:0L(%rax,%rax,1)
			   '\x84', '\x00', '\x00',
			   '\x00', '\x00', '\x00' };
  const char nop13[13] = { '\x66', '\x66', '\x66', // data16; data16; data16
			   '\x66', '\x2e', '\x0f', // nopw %cs:0L(%rax,%rax,1)
			   '\x1f', '\x84', '\x00',
			   '\x00', '\x00', '\x00',
			   '\x00' };
  const char nop14[14] = { '\x66', '\x66', '\x66', // data16; data16; data16
			   '\x66', '\x66', '\x2e', // data16
			   '\x0f', '\x1f', '\x84', // nopw %cs:0L(%rax,%rax,1)
			   '\x00', '\x00', '\x00',
			   '\x00', '\x00' };
  const char nop15[15] = { '\x66', '\x66', '\x66', // data16; data16; data16
			   '\x66', '\x66', '\x66', // data16; data16
			   '\x2e', '\x0f', '\x1f', // nopw %cs:0L(%rax,%rax,1)
			   '\x84', '\x00', '\x00',
			   '\x00', '\x00', '\x00' };

  const char* nops[16] = {
    NULL,
    nop1, nop2, nop3, nop4, nop5, nop6, nop7,
    nop8, nop9, nop10, nop11, nop12, nop13, nop14, nop15
  };

  return std::string(nops[length], length);
}

// Return the addend to use for a target specific relocation.  The
// only target specific relocation is R_X86_64_TLSDESC for a local
// symbol.  We want to set the addend is the offset of the local
// symbol in the TLS segment.

template<int size>
uint64_t
Target_x86_64<size>::do_reloc_addend(void* arg, unsigned int r_type,
				     uint64_t) const
{
  gold_assert(r_type == elfcpp::R_X86_64_TLSDESC);
  uintptr_t intarg = reinterpret_cast<uintptr_t>(arg);
  gold_assert(intarg < this->tlsdesc_reloc_info_.size());
  const Tlsdesc_info& ti(this->tlsdesc_reloc_info_[intarg]);
  const Symbol_value<size>* psymval = ti.object->local_symbol(ti.r_sym);
  gold_assert(psymval->is_tls_symbol());
  // The value of a TLS symbol is the offset in the TLS segment.
  return psymval->value(ti.object, 0);
}

// Return the value to use for the base of a DW_EH_PE_datarel offset
// in an FDE.  Solaris and SVR4 use DW_EH_PE_datarel because their
// assembler can not write out the difference between two labels in
// different sections, so instead of using a pc-relative value they
// use an offset from the GOT.

template<int size>
uint64_t
Target_x86_64<size>::do_ehframe_datarel_base() const
{
  gold_assert(this->global_offset_table_ != NULL);
  Symbol* sym = this->global_offset_table_;
  Sized_symbol<size>* ssym = static_cast<Sized_symbol<size>*>(sym);
  return ssym->value();
}

// FNOFFSET in section SHNDX in OBJECT is the start of a function
// compiled with -fsplit-stack.  The function calls non-split-stack
// code.  We have to change the function so that it always ensures
// that it has enough stack space to run some random function.

template<int size>
void
Target_x86_64<size>::do_calls_non_split(Relobj* object, unsigned int shndx,
					section_offset_type fnoffset,
					section_size_type fnsize,
					unsigned char* view,
					section_size_type view_size,
					std::string* from,
					std::string* to) const
{
  // The function starts with a comparison of the stack pointer and a
  // field in the TCB.  This is followed by a jump.

  // cmp %fs:NN,%rsp
  if (this->match_view(view, view_size, fnoffset, "\x64\x48\x3b\x24\x25", 5)
      && fnsize > 9)
    {
      // We will call __morestack if the carry flag is set after this
      // comparison.  We turn the comparison into an stc instruction
      // and some nops.
      view[fnoffset] = '\xf9';
      this->set_view_to_nop(view, view_size, fnoffset + 1, 8);
    }
  // lea NN(%rsp),%r10
  // lea NN(%rsp),%r11
  else if ((this->match_view(view, view_size, fnoffset,
			     "\x4c\x8d\x94\x24", 4)
	    || this->match_view(view, view_size, fnoffset,
				"\x4c\x8d\x9c\x24", 4))
	   && fnsize > 8)
    {
      // This is loading an offset from the stack pointer for a
      // comparison.  The offset is negative, so we decrease the
      // offset by the amount of space we need for the stack.  This
      // means we will avoid calling __morestack if there happens to
      // be plenty of space on the stack already.
      unsigned char* pval = view + fnoffset + 4;
      uint32_t val = elfcpp::Swap_unaligned<32, false>::readval(pval);
      val -= parameters->options().split_stack_adjust_size();
      elfcpp::Swap_unaligned<32, false>::writeval(pval, val);
    }
  else
    {
      if (!object->has_no_split_stack())
	object->error(_("failed to match split-stack sequence at "
			"section %u offset %0zx"),
		      shndx, static_cast<size_t>(fnoffset));
      return;
    }

  // We have to change the function so that it calls
  // __morestack_non_split instead of __morestack.  The former will
  // allocate additional stack space.
  *from = "__morestack";
  *to = "__morestack_non_split";
}

// The selector for x86_64 object files.  Note this is never instantiated
// directly.  It's only used in Target_selector_x86_64_nacl, below.

template<int size>
class Target_selector_x86_64 : public Target_selector_freebsd
{
public:
  Target_selector_x86_64()
    : Target_selector_freebsd(elfcpp::EM_X86_64, size, false,
			      (size == 64
			       ? "elf64-x86-64" : "elf32-x86-64"),
			      (size == 64
			       ? "elf64-x86-64-freebsd"
			       : "elf32-x86-64-freebsd"),
			      (size == 64 ? "elf_x86_64" : "elf32_x86_64"))
  { }

  Target*
  do_instantiate_target()
  { return new Target_x86_64<size>(); }

};

// NaCl variant.  It uses different PLT contents.

template<int size>
class Output_data_plt_x86_64_nacl : public Output_data_plt_x86_64<size>
{
 public:
  Output_data_plt_x86_64_nacl(Layout* layout,
			      Output_data_got<64, false>* got,
			      Output_data_space* got_plt,
			      Output_data_space* got_irelative)
    : Output_data_plt_x86_64<size>(layout, plt_entry_size,
				   got, got_plt, got_irelative)
  { }

  Output_data_plt_x86_64_nacl(Layout* layout,
			      Output_data_got<64, false>* got,
			      Output_data_space* got_plt,
			      Output_data_space* got_irelative,
			      unsigned int plt_count)
    : Output_data_plt_x86_64<size>(layout, plt_entry_size,
				   got, got_plt, got_irelative,
				   plt_count)
  { }

 protected:
  virtual unsigned int
  do_get_plt_entry_size() const
  { return plt_entry_size; }

  virtual void
  do_add_eh_frame(Layout* layout)
  {
    layout->add_eh_frame_for_plt(this,
				 this->plt_eh_frame_cie,
				 this->plt_eh_frame_cie_size,
				 plt_eh_frame_fde,
				 plt_eh_frame_fde_size);
  }

  virtual void
  do_fill_first_plt_entry(unsigned char* pov,
			  typename elfcpp::Elf_types<size>::Elf_Addr got_addr,
			  typename elfcpp::Elf_types<size>::Elf_Addr plt_addr);

  virtual unsigned int
  do_fill_plt_entry(unsigned char* pov,
		    typename elfcpp::Elf_types<size>::Elf_Addr got_address,
		    typename elfcpp::Elf_types<size>::Elf_Addr plt_address,
		    unsigned int got_offset,
		    unsigned int plt_offset,
		    unsigned int plt_index);

  virtual void
  do_fill_tlsdesc_entry(unsigned char* pov,
			typename elfcpp::Elf_types<size>::Elf_Addr got_address,
			typename elfcpp::Elf_types<size>::Elf_Addr plt_address,
			typename elfcpp::Elf_types<size>::Elf_Addr got_base,
			unsigned int tlsdesc_got_offset,
			unsigned int plt_offset);

 private:
  // The size of an entry in the PLT.
  static const int plt_entry_size = 64;

  // The first entry in the PLT.
  static const unsigned char first_plt_entry[plt_entry_size];

  // Other entries in the PLT for an executable.
  static const unsigned char plt_entry[plt_entry_size];

  // The reserved TLSDESC entry in the PLT for an executable.
  static const unsigned char tlsdesc_plt_entry[plt_entry_size];

  // The .eh_frame unwind information for the PLT.
  static const int plt_eh_frame_fde_size = 32;
  static const unsigned char plt_eh_frame_fde[plt_eh_frame_fde_size];
};

template<int size>
class Target_x86_64_nacl : public Target_x86_64<size>
{
 public:
  Target_x86_64_nacl()
    : Target_x86_64<size>(&x86_64_nacl_info)
  { }

  virtual Output_data_plt_x86_64<size>*
  do_make_data_plt(Layout* layout,
		   Output_data_got<64, false>* got,
		   Output_data_space* got_plt,
		   Output_data_space* got_irelative)
  {
    return new Output_data_plt_x86_64_nacl<size>(layout, got, got_plt,
						 got_irelative);
  }

  virtual Output_data_plt_x86_64<size>*
  do_make_data_plt(Layout* layout,
		   Output_data_got<64, false>* got,
		   Output_data_space* got_plt,
		   Output_data_space* got_irelative,
		   unsigned int plt_count)
  {
    return new Output_data_plt_x86_64_nacl<size>(layout, got, got_plt,
						 got_irelative,
						 plt_count);
  }

  virtual std::string
  do_code_fill(section_size_type length) const;

 private:
  static const Target::Target_info x86_64_nacl_info;
};

template<>
const Target::Target_info Target_x86_64_nacl<64>::x86_64_nacl_info =
{
  64,			// size
  false,		// is_big_endian
  elfcpp::EM_X86_64,	// machine_code
  false,		// has_make_symbol
  false,		// has_resolve
  true,			// has_code_fill
  true,			// is_default_stack_executable
  true,			// can_icf_inline_merge_sections
  '\0',			// wrap_char
  "/lib64/ld-nacl-x86-64.so.1", // dynamic_linker
  0x20000,		// default_text_segment_address
  0x10000,		// abi_pagesize (overridable by -z max-page-size)
  0x10000,		// common_pagesize (overridable by -z common-page-size)
  true,                 // isolate_execinstr
  0x10000000,           // rosegment_gap
  elfcpp::SHN_UNDEF,	// small_common_shndx
  elfcpp::SHN_X86_64_LCOMMON,	// large_common_shndx
  0,			// small_common_section_flags
  elfcpp::SHF_X86_64_LARGE,	// large_common_section_flags
  NULL,			// attributes_section
  NULL,			// attributes_vendor
  "_start"		// entry_symbol_name
};

template<>
const Target::Target_info Target_x86_64_nacl<32>::x86_64_nacl_info =
{
  32,			// size
  false,		// is_big_endian
  elfcpp::EM_X86_64,	// machine_code
  false,		// has_make_symbol
  false,		// has_resolve
  true,			// has_code_fill
  true,			// is_default_stack_executable
  true,			// can_icf_inline_merge_sections
  '\0',			// wrap_char
  "/lib/ld-nacl-x86-64.so.1", // dynamic_linker
  0x20000,		// default_text_segment_address
  0x10000,		// abi_pagesize (overridable by -z max-page-size)
  0x10000,		// common_pagesize (overridable by -z common-page-size)
  true,                 // isolate_execinstr
  0x10000000,           // rosegment_gap
  elfcpp::SHN_UNDEF,	// small_common_shndx
  elfcpp::SHN_X86_64_LCOMMON,	// large_common_shndx
  0,			// small_common_section_flags
  elfcpp::SHF_X86_64_LARGE,	// large_common_section_flags
  NULL,			// attributes_section
  NULL,			// attributes_vendor
  "_start"		// entry_symbol_name
};

#define	NACLMASK	0xe0            // 32-byte alignment mask.

// The first entry in the PLT.

template<int size>
const unsigned char
Output_data_plt_x86_64_nacl<size>::first_plt_entry[plt_entry_size] =
{
  0xff, 0x35,                         // pushq contents of memory address
  0, 0, 0, 0,                         // replaced with address of .got + 8
  0x4c, 0x8b, 0x1d,                   // mov GOT+16(%rip), %r11
  0, 0, 0, 0,                         // replaced with address of .got + 16
  0x41, 0x83, 0xe3, NACLMASK,         // and $-32, %r11d
  0x4d, 0x01, 0xfb,                   // add %r15, %r11
  0x41, 0xff, 0xe3,                   // jmpq *%r11

  // 9-byte nop sequence to pad out to the next 32-byte boundary.
  0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, // nopl %cs:0x0(%rax,%rax,1)

  // 32 bytes of nop to pad out to the standard size
  0x66, 0x66, 0x66, 0x66, 0x66, 0x66,    // excess data32 prefixes
  0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, // nopw %cs:0x0(%rax,%rax,1)
  0x66, 0x66, 0x66, 0x66, 0x66, 0x66,    // excess data32 prefixes
  0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, // nopw %cs:0x0(%rax,%rax,1)
  0x66,                                  // excess data32 prefix
  0x90                                   // nop
};

template<int size>
void
Output_data_plt_x86_64_nacl<size>::do_fill_first_plt_entry(
    unsigned char* pov,
    typename elfcpp::Elf_types<size>::Elf_Addr got_address,
    typename elfcpp::Elf_types<size>::Elf_Addr plt_address)
{
  memcpy(pov, first_plt_entry, plt_entry_size);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2,
					      (got_address + 8
					       - (plt_address + 2 + 4)));
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 9,
					      (got_address + 16
					       - (plt_address + 9 + 4)));
}

// Subsequent entries in the PLT.

template<int size>
const unsigned char
Output_data_plt_x86_64_nacl<size>::plt_entry[plt_entry_size] =
{
  0x4c, 0x8b, 0x1d,              // mov name@@GOTPCREL(%rip),%r11
  0, 0, 0, 0,                    // replaced with address of symbol in .got
  0x41, 0x83, 0xe3, NACLMASK,    // and $-32, %r11d
  0x4d, 0x01, 0xfb,              // add %r15, %r11
  0x41, 0xff, 0xe3,              // jmpq *%r11

  // 15-byte nop sequence to pad out to the next 32-byte boundary.
  0x66, 0x66, 0x66, 0x66, 0x66, 0x66,    // excess data32 prefixes
  0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, // nopw %cs:0x0(%rax,%rax,1)

  // Lazy GOT entries point here (32-byte aligned).
  0x68,                       // pushq immediate
  0, 0, 0, 0,                 // replaced with index into relocation table
  0xe9,                       // jmp relative
  0, 0, 0, 0,                 // replaced with offset to start of .plt0

  // 22 bytes of nop to pad out to the standard size.
  0x66, 0x66, 0x66, 0x66, 0x66, 0x66,    // excess data32 prefixes
  0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, // nopw %cs:0x0(%rax,%rax,1)
  0x0f, 0x1f, 0x80, 0, 0, 0, 0,          // nopl 0x0(%rax)
};

template<int size>
unsigned int
Output_data_plt_x86_64_nacl<size>::do_fill_plt_entry(
    unsigned char* pov,
    typename elfcpp::Elf_types<size>::Elf_Addr got_address,
    typename elfcpp::Elf_types<size>::Elf_Addr plt_address,
    unsigned int got_offset,
    unsigned int plt_offset,
    unsigned int plt_index)
{
  memcpy(pov, plt_entry, plt_entry_size);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 3,
					      (got_address + got_offset
					       - (plt_address + plt_offset
						  + 3 + 4)));

  elfcpp::Swap_unaligned<32, false>::writeval(pov + 33, plt_index);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 38,
					      - (plt_offset + 38 + 4));

  return 32;
}

// The reserved TLSDESC entry in the PLT.

template<int size>
const unsigned char
Output_data_plt_x86_64_nacl<size>::tlsdesc_plt_entry[plt_entry_size] =
{
  0xff, 0x35,			// pushq x(%rip)
  0, 0, 0, 0,	// replaced with address of linkmap GOT entry (at PLTGOT + 8)
  0x4c, 0x8b, 0x1d,		// mov y(%rip),%r11
  0, 0, 0, 0,	// replaced with offset of reserved TLSDESC_GOT entry
  0x41, 0x83, 0xe3, NACLMASK,	// and $-32, %r11d
  0x4d, 0x01, 0xfb,             // add %r15, %r11
  0x41, 0xff, 0xe3,             // jmpq *%r11

  // 41 bytes of nop to pad out to the standard size.
  0x66, 0x66, 0x66, 0x66, 0x66, 0x66,    // excess data32 prefixes
  0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, // nopw %cs:0x0(%rax,%rax,1)
  0x66, 0x66, 0x66, 0x66, 0x66, 0x66,    // excess data32 prefixes
  0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, // nopw %cs:0x0(%rax,%rax,1)
  0x66, 0x66,                            // excess data32 prefixes
  0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, // nopw %cs:0x0(%rax,%rax,1)
};

template<int size>
void
Output_data_plt_x86_64_nacl<size>::do_fill_tlsdesc_entry(
    unsigned char* pov,
    typename elfcpp::Elf_types<size>::Elf_Addr got_address,
    typename elfcpp::Elf_types<size>::Elf_Addr plt_address,
    typename elfcpp::Elf_types<size>::Elf_Addr got_base,
    unsigned int tlsdesc_got_offset,
    unsigned int plt_offset)
{
  memcpy(pov, tlsdesc_plt_entry, plt_entry_size);
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2,
					      (got_address + 8
					       - (plt_address + plt_offset
						  + 2 + 4)));
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 9,
					      (got_base
					       + tlsdesc_got_offset
					       - (plt_address + plt_offset
						  + 9 + 4)));
}

// The .eh_frame unwind information for the PLT.

template<int size>
const unsigned char
Output_data_plt_x86_64_nacl<size>::plt_eh_frame_fde[plt_eh_frame_fde_size] =
{
  0, 0, 0, 0,				// Replaced with offset to .plt.
  0, 0, 0, 0,				// Replaced with size of .plt.
  0,					// Augmentation size.
  elfcpp::DW_CFA_def_cfa_offset, 16,	// DW_CFA_def_cfa_offset: 16.
  elfcpp::DW_CFA_advance_loc + 6,	// Advance 6 to __PLT__ + 6.
  elfcpp::DW_CFA_def_cfa_offset, 24,	// DW_CFA_def_cfa_offset: 24.
  elfcpp::DW_CFA_advance_loc + 58,	// Advance 58 to __PLT__ + 64.
  elfcpp::DW_CFA_def_cfa_expression,	// DW_CFA_def_cfa_expression.
  13,					// Block length.
  elfcpp::DW_OP_breg7, 8,		// Push %rsp + 8.
  elfcpp::DW_OP_breg16, 0,		// Push %rip.
  elfcpp::DW_OP_const1u, 63,		// Push 0x3f.
  elfcpp::DW_OP_and,			// & (%rip & 0x3f).
  elfcpp::DW_OP_const1u, 37,            // Push 0x25.
  elfcpp::DW_OP_ge,			// >= ((%rip & 0x3f) >= 0x25)
  elfcpp::DW_OP_lit3,			// Push 3.
  elfcpp::DW_OP_shl,			// << (((%rip & 0x3f) >= 0x25) << 3)
  elfcpp::DW_OP_plus,			// + ((((%rip&0x3f)>=0x25)<<3)+%rsp+8
  elfcpp::DW_CFA_nop,			// Align to 32 bytes.
  elfcpp::DW_CFA_nop
};

// Return a string used to fill a code section with nops.
// For NaCl, long NOPs are only valid if they do not cross
// bundle alignment boundaries, so keep it simple with one-byte NOPs.
template<int size>
std::string
Target_x86_64_nacl<size>::do_code_fill(section_size_type length) const
{
  return std::string(length, static_cast<char>(0x90));
}

// The selector for x86_64-nacl object files.

template<int size>
class Target_selector_x86_64_nacl
  : public Target_selector_nacl<Target_selector_x86_64<size>,
				Target_x86_64_nacl<size> >
{
 public:
  Target_selector_x86_64_nacl()
    : Target_selector_nacl<Target_selector_x86_64<size>,
			   Target_x86_64_nacl<size> >("x86-64",
						      size == 64
						      ? "elf64-x86-64-nacl"
						      : "elf32-x86-64-nacl",
						      size == 64
						      ? "elf_x86_64_nacl"
						      : "elf32_x86_64_nacl")
  { }
};

Target_selector_x86_64_nacl<64> target_selector_x86_64;
Target_selector_x86_64_nacl<32> target_selector_x32;

} // End anonymous namespace.
@


1.165
log
@Use relative relocation for R_X86_64_32 on x32

2013-09-03  Pavel Chupin  <pavel.v.chupin@@intel.com>

	PR gold/15927
	* x86_64.cc (Target_x86_64<size>::Scan::global): Use relative
	relocation for R_X86_64_32 on x32.
@
text
@d399 1
a399 1
      dynbss_(NULL), got_mod_index_offset_(-1U), tlsdesc_reloc_info_(),
a974 2
  // Space for variables copied with a COPY reloc.
  Output_data_space* dynbss_;
@


1.165.2.1
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@d399 1
a399 1
      got_mod_index_offset_(-1U), tlsdesc_reloc_info_(),
d975 2
@


1.164
log
@gold/
	* i386.cc (Target_i386_nacl::do_code_fill): New virtual function.
	* x86_64.cc (Target_x86_64_nacl::do_code_fill): New virtual function.
@
text
@d2745 2
a2746 1
	    else if (r_type == elfcpp::R_X86_64_64
@


1.163
log
@    gold/
    	* parameters.cc (Parameters::entry): Return target-specific entry
    	symbol name.
    	* target.h (Target::entry_symbol_name): New function.
    	(Target_info::entry_symbol_name): New data member.

    	* arm.cc (Target_arm::arm_info): Add entry_symbol_name.
    	(Target_arm_nacl::arm_nacl_info): Likewise.
    	* i386.cc (Target_i386::i386_info): Likewise.
    	(Target_i386_nacl::i386_nacl_info): Likewise.
    	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
    	* sparc.cc (Target_sparc::sparc_info): Likewise.
    	* tilegx.cc (Target_tilegx::tilegx_info): Likewise.
    	* x86_64.cc: (Target_x86_64::x86_64_info) Likewise.
    	(Target_x86_64_nacl::x86_64_nacl_info) Likewise.
    	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
@
text
@d4575 3
d4804 10
@


1.162
log
@	* target-reloc.h (relocate_section): If the reloc offset is out of
	range, pass VIEW as NULL to relocate.relocate.
	* arm.cc (Target_arm:Relocate::relocate): Check for a NULL view.
	* i386.cc (Target_i386::Relocate::relocate): Likewise.
	* powerpc.cc (Target_powerpc::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Relocate::relocate): Likewise.
	* tilegx.cc (Target_tilegx::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Relocate::relocate): Likewise.
@
text
@d1010 2
a1011 1
  NULL			// attributes_vendor
d1037 2
a1038 1
  NULL			// attributes_vendor
d4602 2
a4603 1
  NULL			// attributes_vendor
d4629 2
a4630 1
  NULL			// attributes_vendor
@


1.161
log
@Fix TLS to LE optimization for x32

	PR gold/14858
	* x86_64.cc (Relocate::tls_ld_to_le): Support x32.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
d3233 3
@


1.160
log
@gold/
	* target.h (Sized_target::relocate_relocs): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_relocs): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_relocs): Likewise.
	* powerpc.cc (Target_powerpc::relocate_relocs): Likewise.
	* sparc.cc (Target_sparc::relocate_relocs): Likewise.
	* target-reloc.h (relocate_relocs): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_relocs): Likewise.
	* x86_64.cc (Target_x86_64::relocate_relocs): Likewise.
@
text
@d3968 1
d3971 3
d3983 4
a3986 1
  memcpy(view - 3, "\x66\x66\x66\x64\x48\x8b\x04\x25\0\0\0\0", 12);
@


1.159
log
@	* target-reloc.h (class Default_comdat_behavior): New, package up..
	(get_comdat_behaviour): ..this.
	(relocate_section): Add Relocate_comdat_behavior template arg,
	adjust code to suit.
	* arm.cc (Target_arm::relocate_section): Adjust to suit.
	(Target_arm::scan_reloc_section): Likewise.
	* i386.cc (Target_i386::relocate_section): Likewise.
	* sparc.cc (Target_sparc::relocate_section): Likewise.
	* tilegx.cc (Target_tilegx::relocate_section): Likewise.
	* x86_64.cc (Target_x86_64::relocate_section): Likewise.
	* powerpc.cc (class Relocate_comdat_behavior): New.
	(Target_powerpc::relocate_section): Don't zap opd relocs.  Supply
	gold::relocate_section with new template arg.
@
text
@d480 1
a480 1
      off_t offset_in_output_section,
d2310 1
a2310 1
				       (size == 32 
d4224 1
a4224 1
    off_t offset_in_output_section,
@


1.158
log
@	* i386.cc (Output_data_plt_i386::address_for_global,
	address_for_local): Add plt offset to returned value.  Adjust uses.
	* sparc.cc (Output_data_plt_sparc::address_for_global,
	address_for_local): Likewise.
	* tilegx.cc (Output_data_plt_tilegx::address_for_global,
	address_for_local): Likewise.
	* x86_64.cc (Output_data_plt_x86_64::address_for_global,
	address_for_local): Likewise.
	* target.h (Target::plt_address_for_global, plt_address_for_local):
	Update comment.
	* output.cc (Output_reloc::symbol_value): Don't add plt offset here.
	(Output_data_got::Got_entry::write): Nor here.
	* output.h: Comment fix.
@
text
@d4063 2
a4064 1
			 typename Target_x86_64<size>::Relocate>(
@


1.157
log
@	* target-reloc.h (scan_relocs): Call scan.local for relocs
	against symbols in discarded sections.  Pass is_discarded
	param.
	* arm.cc, * i386.cc, * sparc.cc, * x86_64.cc (Target_*::Scan::local):
	Add is_discarded param.
	* powerpc (Target_powerpc::Scan::local): Likewise.  Use
	is_discarded to flag opd entry as discarded.  Don't emit dyn
	relocs on such entries.
	(Target_powerpc::Scan::global): Similarly detect and handle
	such opd entries.
	(Powerpc_relobj): Replace opd_ent_shndx_ and opd_ent_off_ with
	opd_ent_.  Update all uses.
	(Powerpc_relobj::get_opd_discard, set_opd_discard): New functions.
	(Target_powerpc::relocate_section): Zero out discarded opd
	entry relocs.
@
text
@d1388 1
a1388 1
  return this->address() + offset;
d1396 2
a1397 1
Output_data_plt_x86_64<size>::address_for_local(const Relobj*, unsigned int)
d1399 3
a1401 1
  return this->address() + (this->count_ + 1) * this->get_plt_entry_size();
d3240 1
a3240 2
      symval.set_output_value(target->plt_address_for_global(gsym)
			      + gsym->plt_offset());
d3248 1
a3248 2
	  symval.set_output_value(target->plt_address_for_local(object, r_sym)
				  + object->local_plt_offset(r_sym));
d4257 1
a4257 1
  return this->plt_address_for_global(gsym) + gsym->plt_offset();
@


1.156
log
@	* output.h (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::add_local_pair_with_rel): Remove second
	reloc param.  Expand comment.
	(Output_data_got::Got_entry): Rename use_plt_offset_ to
	use_plt_or_tls_offset_, similarly for constructor param.
	(Output_data_got::Got_entry::write): Add got_index param.
	* output.cc (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::Got_entry::write): Handle tls symbols
	with use_plt_or_tls_offset_ set specially.
	(Output_data_got::add_local_pair_with_rel): Only one reloc.
	(Output_data_got::do_write): Replace iterator with index, pass
	index to entry write function.
	* target.h (Target::tls_offset_for_local, tls_offset_for_global,
	do_tls_offset_for_local, do_tls_offset_for_global): New functions.
	* arm.cc (Target_arm::Scan::local): Update add_local_pair_with_rel
	call.
	* i386.cc (Target_i386::Scan::local): Likewise.
	* sparc.cc (Target_sparc::Scan::local): Likewise.
	* x86_64.cc (Target_x86_64::Scan::local): Likewise.
	* powerpc.cc (Target_powerpc::do_tls_offset_for_local,
	do_tls_offset_for_global): New functions.
	(Target_powerpc::Scan::local): Correct TLS relocations and got
	entry values.
	(Target_powerpc::Scan::global): Don't emit unnecessary
	dynamic relocations on TLS GOT entries.
@
text
@d679 2
a680 1
	  const elfcpp::Sym<size, false>& lsym);
d2274 2
a2275 1
				 const elfcpp::Sym<size, false>& lsym)
d2277 3
@


1.155
log
@	* object.h (Sized_relobj_file::emit_relocs): Delete.
	(Sized_relobj_file::emit_relocs_reltype): Delete.
	* reloc.cc (Sized_relobj_file::do_relocate_sections): Call target
	relocate_relocs for --emit-relocs.
	(Sized_relobj_file::emit_relocs, emit_relocs_reltype): Delete.
	* output.h: Update comment.
	(Output_segment::first_section): New function.
	(Output_segment::first_section_load_address): Use first_section.
	* output.cc (Output_segment::first_section): New function extracted..
	(Output_segment::first_section_load_address): ..from here.  Delete.
	* target-reloc.h (relocate_for_relocatable): Rename to relocate_relocs.
	* target.h (Sized_target::relocate_for_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise, and
	adjust call to target.h function.
	* i386.cc (Target_i386): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	(Target_powerpc::Scan::local, global): Handle R_POWERPC_TLS.  Ensure
	first tls section has section symbol for optimised local dynamic
	output relocs.
	(Target_powerpc::Relocate::relocate): Correct local dynamic value.
	(Target_powerpc::relocate_relocs): Adjust relocs emitted for
	optimised tls code.
	* testsuite/testfile.cc (Target_test::relocate_for_relocatable):
	Rename to relocate_relocs.  Update error message.
@
text
@d2480 1
a2480 1
					       elfcpp::R_X86_64_DTPMOD64, 0);
@


1.154
log
@	* x86_64.cc (Target_x86_64::Scan::global): Fix erroneous call to
	unsupported_relocal_local to call unsupported_reloc_global.
@
text
@d472 1
a472 1
  // Relocate a section during a relocatable link.
d474 1
a474 1
  relocate_for_relocatable(
d4211 1
a4211 1
Target_x86_64<size>::relocate_for_relocatable(
d4227 1
a4227 1
  gold::relocate_for_relocatable<size, false, elfcpp::SHT_RELA>(
@


1.153
log
@Handle R_X86_64_64 properly for x32

elfcpp/

	PR gold/14091
	* x86_64.h (R_X86_64_RELATIVE64): New.

gold/

	PR gold/14091
	* x86_64.cc (Target_x86_64::Scan::local): For x32, generate
	R_X86_64_RELATIVE64 instead of R_X86_64_RELATIVE in case of
	R_X86_64_64.
@
text
@d3009 1
a3009 1
	      unsupported_reloc_local(object, r_type);
@


1.153.2.1
log
@gold/
	* target.h (Sized_target::relocate_for_relocatable): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_for_relocatable): Likewise.
	* powerpc.cc (Target_powerpc::relocate_for_relocatable): Likewise.
	* sparc.cc (Target_sparc::relocate_for_relocatable): Likewise.
	* target-reloc.h (relocate_for_relocatable): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_for_relocatable): Likewise.
	* x86_64.cc (Target_x86_64::relocate_for_relocatable): Likewise.
@
text
@d480 1
a480 1
      typename elfcpp::Elf_types<size>::Elf_Off offset_in_output_section,
d2302 1
a2302 1
				       (size == 32
d4217 1
a4217 1
    typename elfcpp::Elf_types<size>::Elf_Off offset_in_output_section,
@


1.153.2.2
log
@Fix TLS LD to LE optimization for x32

	PR gold/14858
	* x86_64.cc (Relocate::tls_ld_to_le): Support x32.
@
text
@a3961 1
  // For SIZE == 64:
a3963 3
  // For SIZE == 32:
  // ... leq foo@@dtpoff(%rax),%reg
  // ==> nopl 0x0(%rax); movl %fs:0,%eax ... leaq x@@tpoff(%rax),%rdx
d3973 1
a3973 4
  if (size == 64)
    memcpy(view - 3, "\x66\x66\x66\x64\x48\x8b\x04\x25\0\0\0\0", 12);
  else
    memcpy(view - 3, "\x0f\x1f\x40\x00\x64\x8b\x04\x25\0\0\0\0", 12);
@


1.153.2.3
log
@gold/
	* i386.cc (Target_i386_nacl::do_code_fill): New virtual function.
	* x86_64.cc (Target_x86_64_nacl::do_code_fill): New virtual function.
@
text
@a4562 3
  virtual std::string
  do_code_fill(section_size_type length) const;

a4786 10
// Return a string used to fill a code section with nops.
// For NaCl, long NOPs are only valid if they do not cross
// bundle alignment boundaries, so keep it simple with one-byte NOPs.
template<int size>
std::string
Target_x86_64_nacl<size>::do_code_fill(section_size_type length) const
{
  return std::string(length, static_cast<char>(0x90));
}

@


1.152
log
@	* configure.ac (ENABLE_GOLD): Consider *-*-nacl* targets ELF.
	* configure: Regenerate.

gold/
	* nacl.cc: New file.
	* nacl.h: New file.
	* Makefile.am (CCFILES, HFILES): Add them.
	* Makefile.in: Regenerate.
	* i386.cc (Output_data_plt_i386_nacl): New class.
	(Output_data_plt_i386_nacl_exec): New class.
	(Output_data_plt_i386_nacl_dyn): New class.
	(Target_i386_nacl): New class.
	(Target_selector_i386_nacl): New class.
	(target_selector_i386): Use it instead of Target_selector_i386.
	* x86_64.cc (Output_data_plt_x86_64_nacl): New class.
	(Target_x86_64_nacl): New class.
	(Target_selector_x86_64_nacl): New class.
	(target_selector_x86_64, target_selector_x32): Use it instead of
	Target_selector_x86_64.
	* arm.cc (Output_data_plt_arm_nacl): New class.
	(Target_arm_nacl): New class.
	(Target_selector_arm_nacl): New class.
	(target_selector_arm, target_selector_armbe): Use it instead of
	Target_selector_arm.

	* target-select.cc (select_target): Take new Input_file* and off_t
	arguments, pass them on to recognize method of selector.
	* object.cc (make_elf_sized_object): Update caller.
	* parameters.cc (parameters_force_valid_target): Likewise.
	* incremental.cc (make_sized_incremental_binary): Likewise.
	* target-select.h: Update decl.
	(Target_selector::recognize): Take new Input_file* argument,
	pass it on to do_recognize.
	(Target_selector::do_recognize): Take new Input_file* argument.
	* freebsd.h (Target_selector_freebsd::do_recognize): Likewise.
	* powerpc.cc (Target_selector_powerpc::do_recognize): Likewise.
	* sparc.cc (Target_selector_sparc::do_recognize): Likewise.
	* testsuite/testfile.cc (Target_selector::do_recognize): Likewise.

	* target.h (Target::Target_info): New members isolate_execinstr
	and rosegment_gap.
	(Target::isolate_execinstr, Target::rosegment_gap): New methods.
	* arm.cc (Target_arm::arm_info): Update initializer.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
	* sparc.cc (Target_sparc::sparc_info): Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
	* layout.cc (Layout::attach_allocated_section_to_segment):
	Take new const Target* argument.  If target->isolate_execinstr(), act
	like --rosegment.
	(Layout::find_first_load_seg): Take new const Target* argument;
	if target->isolate_execinstr(), reject PF_X segments.
	(Layout::relaxation_loop_body): Update caller.
	(Layout::set_segment_offsets): If target->isolate_execinstr(),
	reset file offset to zero when we hit LOAD_SEG, and then do a second
	loop over the segments before LOAD_SEG to reassign offsets after
	addresses have been determined.  Handle target->rosegment_gap().
	(Layout::attach_section_to_segment): Take new const Target* argument;
	pass it to attach_allocated_section_to_segment.
	(Layout::make_output_section): Update caller.
	(Layout::attach_sections_to_segments): Take new const Target* argument;
	pass it to attach_section_to_segment.
	* gold.cc (queue_middle_tasks): Update caller.
	* layout.h (Layout): Update method decls with new arguments.

	* arm.cc (Target_arm::Target_arm): Take optional argument for the
	Target_info pointer to use.
	(Target_arm::do_make_data_plt): New virtual method.
	(Target_arm::make_data_plt): New method that calls it.
	(Target_arm::make_plt_entry): Use it.
	(Output_data_plt_arm::Output_data_plt_arm): Take additional argument
	for the section alignment.
	(Output_data_plt_arm::do_first_plt_entry_offset): New abstract virtual
	method.
	(Output_data_plt_arm::first_plt_entry_offset): Call it.
	(Output_data_plt_arm::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_arm::get_plt_entry_size): Call it.
	(Output_data_plt_arm::do_fill_plt_entry): New abstract virtual method.
	(Output_data_plt_arm::fill_plt_entry): New method that calls it.
	(Output_data_plt_arm::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_arm::fill_first_plt_entry): New method that calls it.
	(Output_data_plt_arm::set_final_data_size): Use get_plt_entry_size
	method instead of sizeof(plt_entry).
	(Output_data_plt_arm::add_entry): Likewise.
	Use first_plt_entry_offset method instead of sizeof(first_plt_entry).
	(Target_arm::first_plt_entry_offset): Call method on this->plt_ rather
	than static method.
	(Target_arm::plt_entry_size): Likewise.
	(Output_data_plt_arm::first_plt_entry, Output_data_plt_arm::plt_entry):
	Move to ...
	(Output_data_plt_arm_standard): ... here, new class.
	(Output_data_plt_arm::do_write): Move guts of PLT filling to...
	(Output_data_plt_arm_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_arm_standard::do_fill_plt_entry): ... and here.

	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Take additional argument for the PLT entry size.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset):
	Use get_plt_entry_size method rather than plt_entry_size variable.
	(Output_data_plt_x86_64::reserve_slot): Likewise.
	(Output_data_plt_x86_64::do_adjust_output_section): Likewise.
	(Output_data_plt_x86_64::add_entry): Likewise.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Likewise.
	(Output_data_plt_x86_64::address_for_global): Likewise.
	(Output_data_plt_x86_64::address_for_local): Likewise.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::first_plt_entry_offset): Likewise.
	Make method non-static.
	(Output_data_plt_x86_64::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_x86_64::get_plt_entry_size): Just call that.
	(Output_data_plt_x86_64::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_x86_64::add_eh_frame): New method to call it.
	(Output_data_plt_x86_64::do_fill_first_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_first_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_tlsdesc_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_tlsdesc_entry): New method to call it.
	(Output_data_plt_x86_64::plt_entry_size)
	(Output_data_plt_x86_64::first_plt_entry)
	(Output_data_plt_x86_64::plt_entry)
	(Output_data_plt_x86_64::tlsdesc_plt_entry)
	(Output_data_plt_x86_64::plt_eh_frame_fde_size)
	(Output_data_plt_x86_64::plt_eh_frame_fde): Move to ...
	(Output_data_plt_x86_64_standard): ... here, new class.
	(Target_x86_64::Target_x86_64): Take optional argument for the
	Target_info pointer to use.
	(Target_x86_64::do_make_data_plt): New virtual method.
	(Target_x86_64::make_data_plt): New method to call it.
	(Target_x86_64::init_got_plt_for_update): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_x86_64::init):	Don't do add_eh_frame_for_plt here.
	(Target_x86_64::first_plt_entry_offset): Call method on this->plt_
	rather than static method.
	(Target_x86_64::plt_entry_size): Likewise.
	(Output_data_plt_x86_64::do_write): Use get_plt_entry_size method
	rather than plt_entry_size variable.  Move guts of PLT filling to...
	(Output_data_plt_x86_64_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_x86_64_standard::do_fill_plt_entry): ... and here ...
	(Output_data_plt_x86_64_standard::do_fill_tlsdesc_entry): ... and here.

	* i386.cc (Output_data_plt_i386::Output_data_plt_i386): Take
	additional argument for the section alignment.
	Don't do add_eh_frame_for_plt here.
	(Output_data_plt_i386::first_plt_entry_offset): Make the method
	non-static.  Use get_plt_entry_size method rather than plt_entry_size
	variable.
	(Output_data_plt_i386::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_i386::get_plt_entry_size): Call it.
	(Output_data_plt_i386::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_i386::add_eh_frame): New method to call it.
	(Output_data_plt_i386::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_first_plt_entry): New method to call it.
	(Output_data_plt_i386::do_fill_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_plt_entry): New method to call it.
	(Output_data_plt_i386::set_final_data_size): Use get_plt_entry_size
	method instead of plt_entry_size.
	(Output_data_plt_i386::plt_entry_size)
	(Output_data_plt_i386::plt_eh_frame_fde_size)
	(Output_data_plt_i386::plt_eh_frame_fde): Move to ...
	(Output_data_plt_i386_standard): ... here, new class.
	(Output_data_plt_i386_exec): New class.
	(Output_data_plt_i386::exec_first_plt_entry): Move to ...
	(Output_data_plt_i386_exec::first_plt_entry): ... here.
	(Output_data_plt_i386::exec_plt_entry): Move to ...
	(Output_data_plt_i386_exec::plt_entry): ... here.
	(Output_data_plt_i386_dyn): New class.
	(Output_data_plt_i386::first_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::first_plt_entry): ... here.
	(Output_data_plt_i386::dyn_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::plt_entry): ... here.
	(Target_i386::Target_i386): Take optional argument for the Target_info
	pointer to use.
	(Target_i386::do_make_data_plt): New virtual method.
	(Target_i386::make_data_plt): New method to call it.
	(Target_i386::make_plt_section): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_i386::add_entry): Use get_plt_entry_size method
	rather than plt_entry_size variable.
	(Output_data_plt_i386::add_local_ifunc_entry): Likewise.
	(Output_data_plt_i386::address_for_local): Likewise.
	(Output_data_plt_i386::do_write): Likewise.
	Move guts of PLT filling to...
	(Output_data_plt_i386_exec::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_i386_exec::do_fill_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_first_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_plt_entry): ... and here.

Change-Id: Id24b95600489835ff5e860a39c147203d4380c2b
@
text
@d2302 3
a2304 1
				       elfcpp::R_X86_64_RELATIVE,
@


1.151
log
@gold: Allow use_plt_offset to be specified for global relocations.

gold/

	* output.h (Output_reloc): Allow use_plt_offset for global relocs too.
	(class Output_data_reloc): Adjust calls to Output_reloc_type.
	(Output_data_reloc::add_global_relative): (RELA only) Add use_plt_offset.
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag for
	global relocs too.
	(Output_reloc::symbol_value): Respect use_plt_offset_ for global symbols.
	* powerpc.cc (Target_powerpc::Scan::global): Adjust add_global_relative
	calls.
	* sparc.cc (Target_sparc::Scan::global): Likewise.
	* x86_64.cc (Target_x86_64::Scan::global): Likewise.
@
text
@d43 1
d53 3
d63 2
a64 1
  Output_data_plt_x86_64(Layout* layout, Output_data_got<64, false>* got,
d67 1
a67 1
    : Output_section_data(16), layout_(layout), tlsdesc_rel_(NULL),
d73 2
a74 1
  Output_data_plt_x86_64(Layout* layout, Output_data_got<64, false>* got,
d78 2
a79 1
    : Output_section_data((plt_count + 1) * plt_entry_size, 16, false),
d128 4
a131 1
  { return (this->count_ + this->irelative_count_ + 1) * plt_entry_size; }
d158 1
a158 1
  static unsigned int
d160 1
a160 1
  { return plt_entry_size; }
d163 3
a165 3
  static unsigned int
  get_plt_entry_size()
  { return plt_entry_size; }
d171 2
a172 2
    this->free_list_.remove((plt_index + 1) * plt_entry_size,
			    (plt_index + 2) * plt_entry_size);
d183 5
d189 62
d259 1
a259 16
 private:
  // The size of an entry in the PLT.
  static const int plt_entry_size = 16;

  // The first entry in the PLT.
  // From the AMD64 ABI: "Unlike Intel386 ABI, this ABI uses the same
  // procedure linkage table for both programs and shared objects."
  static const unsigned char first_plt_entry[plt_entry_size];

  // Other entries in the PLT for an executable.
  static const unsigned char plt_entry[plt_entry_size];

  // The reserved TLSDESC entry in the PLT for an executable.
  static const unsigned char tlsdesc_plt_entry[plt_entry_size];

  // The .eh_frame unwind information for the PLT.
a260 1
  static const int plt_eh_frame_fde_size = 32;
a261 1
  static const unsigned char plt_eh_frame_fde[plt_eh_frame_fde_size];
d263 1
d301 78
d394 2
a395 2
  Target_x86_64()
    : Sized_target<size, false>(&x86_64_info),
d410 10
a419 10
	            Layout* layout,
	            Sized_relobj_file<size, false>* object,
	            unsigned int data_shndx,
	            unsigned int sh_type,
	            const unsigned char* prelocs,
	            size_t reloc_count,
	            Output_section* output_section,
	            bool needs_special_offset_handling,
	            size_t local_symbol_count,
	            const unsigned char* plocal_symbols);
d581 1
a581 1
		          Sized_relobj<size, false>* obj,
d619 42
d692 4
a695 4
			        	Sized_relobj_file<size, false>* object,
		  			unsigned int data_shndx,
		  			Output_section* output_section,
		  			const elfcpp::Rela<size, false>& reloc,
d697 1
a697 1
				  	const elfcpp::Sym<size, false>& lsym);
d701 5
a705 5
 					 Target_x86_64* target,
         	   			 Sized_relobj_file<size, false>* object,
        	   			 unsigned int data_shndx,
		   			 Output_section* output_section,
		   			 const elfcpp::Rela<size, false>& reloc,
d707 1
a707 1
		  			 Symbol* gsym);
d764 1
a764 1
                 size_t relnum, const elfcpp::Rela<size, false>&,
d915 1
a915 1
             Sized_relobj_file<size, false>* object,
d1002 2
d1028 2
a1175 5

  // Add unwind information if requested.
  if (parameters->options().ld_generated_unwind_info())
    layout->add_eh_frame_for_plt(this, plt_eh_frame_cie, plt_eh_frame_cie_size,
				 plt_eh_frame_fde, plt_eh_frame_fde_size);
d1182 1
a1182 1
  os->set_entsize(plt_entry_size);
d1223 1
a1223 1
      plt_offset = plt_index * plt_entry_size;
d1240 2
a1241 1
      plt_offset = this->free_list_.allocate(plt_entry_size, plt_entry_size, 0);
d1249 1
a1249 1
      plt_index = plt_offset / plt_entry_size - 1;
d1274 1
a1274 1
  unsigned int plt_offset = this->irelative_count_ * plt_entry_size;
d1386 1
a1386 1
    offset = (this->count_ + 1) * plt_entry_size;
d1397 1
a1397 1
  return this->address() + (this->count_ + 1) * plt_entry_size;
d1408 1
a1408 1
  this->set_data_size((count + 1) * plt_entry_size);
d1415 1
a1415 1
Output_data_plt_x86_64<size>::first_plt_entry[plt_entry_size] =
d1425 17
d1446 1
a1446 1
Output_data_plt_x86_64<size>::plt_entry[plt_entry_size] =
d1457 23
d1484 1
a1484 1
Output_data_plt_x86_64<size>::tlsdesc_plt_entry[plt_entry_size] =
d1496 22
d1521 1
a1521 1
const unsigned char 
d1542 1
a1542 1
Output_data_plt_x86_64<size>::plt_eh_frame_fde[plt_eh_frame_fde_size] =
d1602 2
a1603 9
  memcpy(pov, first_plt_entry, plt_entry_size);
  // We do a jmp relative to the PC at the end of this instruction.
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2,
					      (got_address + 8
					       - (plt_address + 6)));
  elfcpp::Swap<32, false>::writeval(pov + 8,
				    (got_address + 16
				     - (plt_address + 12)));
  pov += plt_entry_size;
d1618 1
a1618 1
  unsigned int plt_offset = plt_entry_size;
d1624 1
a1624 1
	 pov += plt_entry_size,
d1626 1
a1626 1
	 plt_offset += plt_entry_size,
d1630 4
a1633 9
      memcpy(pov, plt_entry, plt_entry_size);
      elfcpp::Swap_unaligned<32, false>::writeval(pov + 2,
						  (got_address + got_offset
						   - (plt_address + plt_offset
						      + 6)));

      elfcpp::Swap_unaligned<32, false>::writeval(pov + 7, plt_index);
      elfcpp::Swap<32, false>::writeval(pov + 12,
					- (plt_offset + plt_entry_size));
d1636 2
a1637 1
      elfcpp::Swap<64, false>::writeval(got_pov, plt_address + plt_offset + 6);
d1644 3
a1646 11
      memcpy(pov, tlsdesc_plt_entry, plt_entry_size);
      elfcpp::Swap_unaligned<32, false>::writeval(pov + 2,
						  (got_address + 8
						   - (plt_address + plt_offset
						      + 6)));
      elfcpp::Swap_unaligned<32, false>::writeval(pov + 8,
						  (got_base
						   + tlsdesc_got_offset
						   - (plt_address + plt_offset
						      + 12)));
      pov += plt_entry_size;
d1667 7
a1673 3
      this->plt_ = new Output_data_plt_x86_64<size>(layout, this->got_,
						    this->got_plt_,
						    this->got_irelative_);
d1746 1
a1746 1
  return Output_data_plt_x86_64<size>::first_plt_entry_offset();
d1755 1
a1755 1
  return Output_data_plt_x86_64<size>::get_plt_entry_size();
d1812 9
a1820 4
  this->plt_ = new Output_data_plt_x86_64<size>(layout, this->got_,
						this->got_plt_,
						this->got_irelative_,
						plt_count);
d1994 1
a1994 1
                                             Layout* layout)
d2024 1
a2024 1
                          got_offset, 0);
d2232 1
a2232 1
        return;
d2235 1
a2235 1
                      "recompile with -fPIC"),
d2257 1
a2257 1
               object->name().c_str(), r_type);
d2298 3
a2300 3
        {
          unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
          Reloc_section* rela_dyn = target->rela_dyn_section(layout);
d2306 1
a2306 1
        }
d2318 1
a2318 1
        {
d2332 1
a2332 1
          this->check_non_pic(object, r_type, NULL);
d2334 1
a2334 1
          Reloc_section* rela_dyn = target->rela_dyn_section(layout);
d2336 1
a2336 1
          if (lsym.get_st_type() != elfcpp::STT_SECTION)
d2340 3
a2342 3
          else
            {
              gold_assert(lsym.get_st_value() == 0);
d2355 2
a2356 2
            }
        }
d2386 3
a2388 3
        // The symbol requires a GOT entry.
        Output_data_got<64, false>* got = target->got_section(symtab, layout);
        unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
d2398 7
a2404 7
        if (is_new)
          {
            // If we are generating a shared object, we need to add a
            // dynamic relocation for this symbol's GOT entry.
            if (parameters->options().output_is_position_independent())
              {
                Reloc_section* rela_dyn = target->rela_dyn_section(layout);
d2414 13
a2426 13
                else
                  {
                    this->check_non_pic(object, r_type, NULL);

                    gold_assert(lsym.get_st_type() != elfcpp::STT_SECTION);
                    rela_dyn->add_local(
                        object, r_sym, r_type, got,
                        object->local_got_offset(r_sym, GOT_TYPE_STANDARD), 0);
                  }
              }
          }
        // For GOTPLT64, we'd normally want a PLT section, but since
        // we know this is a local symbol, no PLT is needed.
d2455 1
a2455 1
            = Target_x86_64<size>::optimize_tls_reloc(!output_is_shared,
d2459 8
a2466 8
          case elfcpp::R_X86_64_TLSGD:       // General-dynamic
            if (optimized_type == tls::TLSOPT_NONE)
              {
                // Create a pair of GOT entries for the module index and
                // dtv-relative offset.
                Output_data_got<64, false>* got
                    = target->got_section(symtab, layout);
                unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
d2473 1
a2473 1
                else
d2479 2
a2480 2
              }
            else if (optimized_type != tls::TLSOPT_TO_LE)
d2482 1
a2482 1
            break;
d2484 2
a2485 2
          case elfcpp::R_X86_64_GOTPC32_TLSDESC:
            target->define_tls_base_symbol(symtab, layout);
d2488 2
a2489 2
	        // Create reserved PLT and GOT entries for the resolver.
	        target->reserve_tlsdesc_entries(symtab, layout);
d2491 5
a2495 5
	        // Generate a double GOT entry with an
	        // R_X86_64_TLSDESC reloc.  The R_X86_64_TLSDESC reloc
	        // is resolved lazily, so the GOT entry needs to be in
	        // an area in .got.plt, not .got.  Call got_section to
	        // make sure the section has been created.
d2497 2
a2498 2
                Output_data_got<64, false>* got = target->got_tlsdesc_section();
                unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
d2519 1
a2519 1
          case elfcpp::R_X86_64_TLSDESC_CALL:
d2522 1
a2522 1
          case elfcpp::R_X86_64_TLSLD:       // Local-dynamic
d2525 2
a2526 2
	        // Create a GOT entry for the module index.
	        target->got_mod_index_entry(symtab, layout, object);
d2532 2
a2533 2
          case elfcpp::R_X86_64_DTPOFF32:
          case elfcpp::R_X86_64_DTPOFF64:
d2536 1
a2536 1
          case elfcpp::R_X86_64_GOTTPOFF:    // Initial-exec
d2538 7
a2544 7
            if (optimized_type == tls::TLSOPT_NONE)
              {
	        // Create a GOT entry for the tp-relative offset.
	        Output_data_got<64, false>* got
	            = target->got_section(symtab, layout);
	        unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
	        got->add_local_with_rel(object, r_sym, GOT_TYPE_TLS_OFFSET,
d2547 4
a2550 4
              }
            else if (optimized_type != tls::TLSOPT_TO_LE)
              unsupported_reloc_local(object, r_type);
            break;
d2552 1
a2552 1
          case elfcpp::R_X86_64_TPOFF32:     // Local-exec
d2554 2
a2555 2
            if (output_is_shared)
              unsupported_reloc_local(object, r_type);
d2558 2
a2559 2
          default:
            gold_unreachable();
d2605 1
a2605 1
        return true;
d2632 1
a2632 1
          || possible_function_pointer_reloc(r_type));
d2655 1
a2655 1
           && (gsym->visibility() == elfcpp::STV_INTERNAL
d2658 1
a2658 1
          || possible_function_pointer_reloc(r_type));
d2666 8
a2673 8
                            Layout* layout,
                            Target_x86_64<size>* target,
                            Sized_relobj_file<size, false>* object,
                            unsigned int data_shndx,
                            Output_section* output_section,
                            const elfcpp::Rela<size, false>& reloc,
                            unsigned int r_type,
                            Symbol* gsym)
d2693 19
a2711 19
        // Make a PLT entry if necessary.
        if (gsym->needs_plt_entry())
          {
            target->make_plt_entry(symtab, layout, gsym);
            // Since this is not a PC-relative relocation, we may be
            // taking the address of a function. In that case we need to
            // set the entry in the dynamic symbol table to the address of
            // the PLT entry.
            if (gsym->is_from_dynobj() && !parameters->options().shared())
              gsym->set_needs_dynsym_value();
          }
        // Make a dynamic relocation if necessary.
        if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
          {
            if (gsym->may_need_copy_reloc())
              {
                target->copy_reloc(symtab, layout, object,
                                   data_shndx, output_section, gsym, reloc);
              }
d2733 4
a2736 4
            else if (r_type == elfcpp::R_X86_64_64
                     && gsym->can_use_relative_reloc(false))
              {
                Reloc_section* rela_dyn = target->rela_dyn_section(layout);
d2742 10
a2751 10
              }
            else
              {
                this->check_non_pic(object, r_type, gsym);
                Reloc_section* rela_dyn = target->rela_dyn_section(layout);
                rela_dyn->add_global(gsym, r_type, output_section, object,
                                     data_shndx, reloc.get_r_offset(),
                                     reloc.get_r_addend());
              }
          }
d2760 20
a2779 20
        // Make a PLT entry if necessary.
        if (gsym->needs_plt_entry())
          target->make_plt_entry(symtab, layout, gsym);
        // Make a dynamic relocation if necessary.
        if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
          {
            if (gsym->may_need_copy_reloc())
              {
                target->copy_reloc(symtab, layout, object,
                                   data_shndx, output_section, gsym, reloc);
              }
            else
              {
                this->check_non_pic(object, r_type, gsym);
                Reloc_section* rela_dyn = target->rela_dyn_section(layout);
                rela_dyn->add_global(gsym, r_type, output_section, object,
                                     data_shndx, reloc.get_r_offset(),
                                     reloc.get_r_addend());
              }
          }
d2789 3
a2791 3
        // The symbol requires a GOT entry.
        Output_data_got<64, false>* got = target->got_section(symtab, layout);
        if (gsym->final_value_is_known())
d2799 5
a2803 5
        else
          {
            // If this symbol is not fully resolved, we need to add a
            // dynamic relocation for it.
            Reloc_section* rela_dyn = target->rela_dyn_section(layout);
d2824 1
a2824 1
              got->add_global_with_rel(gsym, GOT_TYPE_STANDARD, rela_dyn,
d2826 2
a2827 2
            else
              {
d2843 1
a2843 1
                if (is_new)
d2850 7
a2856 7
              }
          }
        // For GOTPLT64, we also need a PLT entry (but only if the
        // symbol is not fully resolved).
        if (r_type == elfcpp::R_X86_64_GOTPLT64
            && !gsym->final_value_is_known())
          target->make_plt_entry(symtab, layout, gsym);
d2869 2
a2870 2
          && !gsym->is_from_dynobj()
          && !gsym->is_preemptible())
d2913 1
a2913 1
            = Target_x86_64<size>::optimize_tls_reloc(is_final, r_type);
d2916 1
a2916 1
          case elfcpp::R_X86_64_TLSGD:       // General-dynamic
d2919 5
a2923 5
                // Create a pair of GOT entries for the module index and
                // dtv-relative offset.
                Output_data_got<64, false>* got
                    = target->got_section(symtab, layout);
                got->add_global_pair_with_rel(gsym, GOT_TYPE_TLS_PAIR,
d2930 4
a2933 4
                // Create a GOT entry for the tp-relative offset.
                Output_data_got<64, false>* got
                    = target->got_section(symtab, layout);
                got->add_global_with_rel(gsym, GOT_TYPE_TLS_OFFSET,
d2941 2
a2942 2
          case elfcpp::R_X86_64_GOTPC32_TLSDESC:
            target->define_tls_base_symbol(symtab, layout);
d2945 2
a2946 2
	        // Create reserved PLT and GOT entries for the resolver.
	        target->reserve_tlsdesc_entries(symtab, layout);
d2948 5
a2952 5
	        // Create a double GOT entry with an R_X86_64_TLSDESC
	        // reloc.  The R_X86_64_TLSDESC reloc is resolved
	        // lazily, so the GOT entry needs to be in an area in
	        // .got.plt, not .got.  Call got_section to make sure
	        // the section has been created.
d2954 1
a2954 1
                Output_data_got<64, false>* got = target->got_tlsdesc_section();
d2956 1
a2956 1
                got->add_global_pair_with_rel(gsym, GOT_TYPE_TLS_DESC, rt,
d2961 4
a2964 4
	        // Create a GOT entry for the tp-relative offset.
                Output_data_got<64, false>* got
                    = target->got_section(symtab, layout);
                got->add_global_with_rel(gsym, GOT_TYPE_TLS_OFFSET,
d2972 1
a2972 1
          case elfcpp::R_X86_64_TLSDESC_CALL:
d2975 1
a2975 1
          case elfcpp::R_X86_64_TLSLD:       // Local-dynamic
d2978 2
a2979 2
	        // Create a GOT entry for the module index.
	        target->got_mod_index_entry(symtab, layout, object);
d2985 2
a2986 2
          case elfcpp::R_X86_64_DTPOFF32:
          case elfcpp::R_X86_64_DTPOFF64:
d2989 1
a2989 1
          case elfcpp::R_X86_64_GOTTPOFF:    // Initial-exec
d2991 6
a2996 6
            if (optimized_type == tls::TLSOPT_NONE)
              {
	        // Create a GOT entry for the tp-relative offset.
	        Output_data_got<64, false>* got
	            = target->got_section(symtab, layout);
	        got->add_global_with_rel(gsym, GOT_TYPE_TLS_OFFSET,
d2999 4
a3002 4
              }
            else if (optimized_type != tls::TLSOPT_TO_LE)
              unsupported_reloc_global(object, r_type, gsym);
            break;
d3004 1
a3004 1
          case elfcpp::R_X86_64_TPOFF32:     // Local-exec
d3006 2
a3007 2
            if (parameters->options().shared())
              unsupported_reloc_local(object, r_type);
d3010 2
a3011 2
          default:
            gold_unreachable();
d3021 1
a3021 1
                 gsym->demangled_name().c_str());
d3047 1
a3047 1
                           typename Target_x86_64<size>::Scan,
d3060 1
a3060 1
 
d3114 1
a3114 1
				  
d3209 1
a3209 1
           && r_type != elfcpp::R_X86_64_PC32)
d3261 4
a3264 4
        {
          gold_assert(gsym->has_got_offset(GOT_TYPE_STANDARD));
          got_offset = gsym->got_offset(GOT_TYPE_STANDARD) - target->got_size();
        }
d3266 6
a3271 6
        {
          unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
          gold_assert(object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD));
          got_offset = (object->local_got_offset(r_sym, GOT_TYPE_STANDARD)
                        - target->got_size());
        }
d3292 1
a3292 1
                                              address);
d3335 1
a3335 1
                  || gsym->has_plt_offset()
d3349 3
a3351 3
        gold_assert(gsym);
        gold_assert(gsym->has_plt_offset()
                    || gsym->final_value_is_known());
d3365 1
a3365 1
        gold_assert(gsym);
d3382 1
a3382 1
        gold_assert(gsym);
d3400 4
a3403 4
        gold_assert(have_got_offset);
        typename elfcpp::Elf_types<size>::Elf_Addr value;
        value = target->got_plt_section()->address() + got_offset;
        Relocate_functions<size, false>::pcrela32(view, value, addend, address);
d3409 4
a3412 4
        gold_assert(have_got_offset);
        typename elfcpp::Elf_types<size>::Elf_Addr value;
        value = target->got_plt_section()->address() + got_offset;
        Relocate_functions<size, false>::pcrela64(view, value, addend, address);
d3440 1
a3440 1
                         view, address, view_size);
d3512 28
a3539 28
        {
          unsigned int got_type = (optimized_type == tls::TLSOPT_TO_IE
                                   ? GOT_TYPE_TLS_OFFSET
                                   : GOT_TYPE_TLS_PAIR);
          unsigned int got_offset;
          if (gsym != NULL)
            {
              gold_assert(gsym->has_got_offset(got_type));
              got_offset = gsym->got_offset(got_type) - target->got_size();
            }
          else
            {
              unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
              gold_assert(object->local_has_got_offset(r_sym, got_type));
              got_offset = (object->local_got_offset(r_sym, got_type)
                            - target->got_size());
            }
          if (optimized_type == tls::TLSOPT_TO_IE)
            {
              value = target->got_plt_section()->address() + got_offset;
              this->tls_gd_to_ie(relinfo, relnum, tls_segment, rela, r_type,
                                 value, view, address, view_size);
              break;
            }
          else if (optimized_type == tls::TLSOPT_NONE)
            {
              // Relocate the field with the offset of the pair of GOT
              // entries.
d3541 1
a3541 1
              Relocate_functions<size, false>::pcrela32(view, value, addend,
d3543 3
a3545 3
              break;
            }
        }
d3566 2
a3567 2
			          rela, r_type, value, view,
			          view_size);
d3571 5
a3575 5
        {
          unsigned int got_type = (optimized_type == tls::TLSOPT_TO_IE
                                   ? GOT_TYPE_TLS_OFFSET
                                   : GOT_TYPE_TLS_DESC);
          unsigned int got_offset = 0;
d3585 10
a3594 10
          if (gsym != NULL)
            {
              gold_assert(gsym->has_got_offset(got_type));
              got_offset += gsym->got_offset(got_type) - target->got_size();
            }
          else
            {
              unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
              gold_assert(object->local_has_got_offset(r_sym, got_type));
              got_offset += (object->local_got_offset(r_sym, got_type)
d3596 3
a3598 3
            }
          if (optimized_type == tls::TLSOPT_TO_IE)
            {
d3605 14
a3618 14
              value = target->got_plt_section()->address() + got_offset;
              this->tls_desc_gd_to_ie(relinfo, relnum, tls_segment,
                                      rela, r_type, value, view, address,
                                      view_size);
              break;
            }
          else if (optimized_type == tls::TLSOPT_NONE)
            {
              if (r_type == elfcpp::R_X86_64_GOTPC32_TLSDESC)
                {
                  // Relocate the field with the offset of the pair of GOT
                  // entries.
	          value = target->got_plt_section()->address() + got_offset;
                  Relocate_functions<size, false>::pcrela32(view, value, addend,
d3620 4
a3623 4
                }
              break;
            }
        }
d3635 1
a3635 1
        {
d3645 1
a3645 1
        }
d3647 5
a3651 5
        {
          // Relocate the field with the offset of the GOT entry for
          // the module index.
          unsigned int got_offset;
          got_offset = (target->got_mod_index_entry(NULL, NULL, NULL)
d3654 1
a3654 1
          Relocate_functions<size, false>::pcrela32(view, value, addend,
d3656 2
a3657 2
          break;
        }
d3713 18
a3730 18
        {
          // Relocate the field with the offset of the GOT entry for
          // the tp-relative offset of the symbol.
          unsigned int got_offset;
          if (gsym != NULL)
            {
              gold_assert(gsym->has_got_offset(GOT_TYPE_TLS_OFFSET));
              got_offset = (gsym->got_offset(GOT_TYPE_TLS_OFFSET)
                            - target->got_size());
            }
          else
            {
              unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
              gold_assert(object->local_has_got_offset(r_sym,
                                                       GOT_TYPE_TLS_OFFSET));
              got_offset = (object->local_got_offset(r_sym, GOT_TYPE_TLS_OFFSET)
                            - target->got_size());
            }
d3732 1
a3732 1
          Relocate_functions<size, false>::pcrela32(view, value, addend,
d3734 2
a3735 2
          break;
        }
d3781 1
a3781 1
                 (memcmp(view + 4, "\x66\x66\x48\xe8", 4) == 0));
d3889 1
a3889 1
                     view[-3] == 0x48 && view[-2] == 0x8d && view[-1] == 0x05);
d3901 1
a3901 1
                     view[0] == 0xff && view[1] == 0x10);
d3928 1
a3928 1
                     view[-3] == 0x48 && view[-2] == 0x8d && view[-1] == 0x05);
d3941 1
a3941 1
                     view[0] == 0xff && view[1] == 0x10);
d3967 1
a3967 1
                 view[-3] == 0x48 && view[-2] == 0x8d && view[-1] == 0x3d);
d4011 1
a4011 1
        view[-3] = 0x49;
d4019 1
a4019 1
        view[-3] = 0x49;
d4027 1
a4027 1
        view[-3] = 0x4d;
d4266 1
a4266 1
              + std::string(length - 5, static_cast<char>(0x90)));
d4274 1
a4274 1
  			 '\x00'};
d4278 1
a4278 1
  			 '\x44', '\x00', '\x00' };
d4280 1
a4280 1
  			 '\x00', '\x00', '\x00',
d4283 1
a4283 1
  			 '\x00', '\x00', '\x00',
d4286 1
a4286 1
  			 '\x84', '\x00', '\x00',
d4289 1
a4289 1
  			   '\x1f', '\x84', '\x00',
d4293 1
a4293 1
  			   '\x0f', '\x1f', '\x84', // nopw %cs:0L(%rax,%rax,1)
d4297 1
a4297 1
  			   '\x2e', '\x0f', '\x1f', // nopw %cs:0L(%rax,%rax,1)
d4301 1
a4301 1
  			   '\x66', '\x2e', '\x0f', // nopw %cs:0L(%rax,%rax,1)
d4304 1
a4304 1
                           '\x00' };
d4306 1
a4306 1
  			   '\x66', '\x66', '\x2e', // data16
d4309 1
a4309 1
                           '\x00', '\x00' };
d4311 1
a4311 1
  			   '\x66', '\x66', '\x66', // data16; data16
d4314 1
a4314 1
                           '\x00', '\x00', '\x00' };
d4423 2
a4424 1
// The selector for x86_64 object files.
d4432 1
a4432 1
			      (size == 64 
d4434 1
a4434 1
			      (size == 64 
d4446 354
a4799 2
Target_selector_x86_64<64> target_selector_x86_64;
Target_selector_x86_64<32> target_selector_x32;
@


1.150
log
@Support x32 GD->IE and GD->LE optimizations

2012-01-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* x86_64.cc (Relocate::tls_gd_to_ie): Support x32.
	(Relocate::tls_gd_to_le): Likewise.
@
text
@d1670 1
a1670 1
					  this->got_, got_offset, 0);
d1675 1
a1675 1
				    this->got_, got_offset, 0);
d1680 1
a1680 1
				    this->got_, got_offset, 0);
d1682 1
a1682 1
				    this->got_, got_offset + 8, 0);
d1687 1
a1687 1
				    this->got_, got_offset, 0);
d2508 1
a2508 1
					      reloc.get_r_addend());
d2615 1
a2615 1
						  got, got_off, 0);
@


1.149
log
@Support x32 IFUNC function pointer

2012-01-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* x86_64.cc (Scan::global): Support x32 IFUNC function pointer.
@
text
@d3537 8
a3544 3
  // .byte 0x66; leaq foo@@tlsgd(%rip),%rdi;
  // .word 0x6666; rex64; call __tls_get_addr
  // ==> movq %fs:0,%rax; addq x@@gottpoff(%rip),%rax
a3545 1
  tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, -4);
a3546 3

  tls::check_tls(relinfo, relnum, rela.get_r_offset(),
                 (memcmp(view - 4, "\x66\x48\x8d\x3d", 4) == 0));
d3550 18
a3567 1
  memcpy(view - 4, "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x03\x05\0\0\0\0", 16);
d3593 8
a3600 3
  // .byte 0x66; leaq foo@@tlsgd(%rip),%rdi;
  // .word 0x6666; rex64; call __tls_get_addr
  // ==> movq %fs:0,%rax; leaq x@@tpoff(%rax),%rax
a3601 1
  tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, -4);
d3603 2
d3606 15
a3620 4
  tls::check_tls(relinfo, relnum, rela.get_r_offset(),
                 (memcmp(view - 4, "\x66\x48\x8d\x3d", 4) == 0));
  tls::check_tls(relinfo, relnum, rela.get_r_offset(),
                 (memcmp(view + 4, "\x66\x66\x48\xe8", 4) == 0));
d3622 3
a3624 1
  memcpy(view - 4, "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x8d\x80\0\0\0\0", 16);
@


1.148
log
@	PR gold/13617
	* i386.cc (Target_i386::do_code_fill): When using a jmp
	instruction, pad with nop instructions.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.
@
text
@d2479 2
a2480 1
	    else if (r_type == elfcpp::R_X86_64_64
@


1.147
log
@Add typename on types used in template

2012-01-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* x86_64.cc (gc_process_relocs): Add typename on types used in
	template.
	(scan_relocs): Likewise.
	(relocate_section): Likewise.
	(apply_relocation): Likewise.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d3995 1
a3995 1
              + std::string(length - 5, '\0'));
@


1.146
log
@Properly handle R_X86_64_32 for x32

2012-01-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* x86_64.cc (Scan::check_non_pic): Allow R_X86_64_32 for x32.
	(Scan::local): Use R_X86_64_RELATIVE relocation for R_X86_64_32
	under x32.
@
text
@d2812 2
a2813 2
                           Target_x86_64<size>::Scan,
			   Target_x86_64<size>::Relocatable_size_for_reloc>(
d2851 1
a2851 1
      Target_x86_64<size>::Scan>(
d3783 1
a3783 1
			 Target_x86_64<size>::Relocate>(
d3812 1
a3812 1
			 Target_x86_64<size>::Relocate>(
@


1.145
log
@Initial x32 support in gold

2012-01-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* x86_64.cc: Initial support for x32.
@
text
@d1974 3
d2085 13
@


1.144
log
@	* gold/incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Use abstract base class for GOT.
	* gold/output.h (class Output_data_got_base): New abstract base class.
	(class Output_data_got): Derive from new base class, adjust ctors.
	(Output_data_got::reserve_slot): Make virtual; rename to
	do_reserve_slot; Adjust callers.
	* gold/target.h (Sized_target::init_got_plt_for_update): Return
	pointer to abstract base class.
	* gold/x86_64.cc (Target_x86_64::init_got_plt_for_update): Likewise.
@
text
@d52 1
d56 1
a56 1
  typedef Output_data_reloc<elfcpp::SHT_RELA, true, 64, false> Reloc_section;
d94 1
a94 1
			Sized_relobj_file<64, false>* relobj,
d246 2
a247 1
class Target_x86_64 : public Sized_target<64, false>
d252 1
a252 1
  typedef Output_data_reloc<elfcpp::SHT_RELA, true, 64, false> Reloc_section;
d255 1
a255 1
    : Sized_target<64, false>(&x86_64_info),
d271 1
a271 1
	            Sized_relobj_file<64, false>* object,
d285 1
a285 1
	      Sized_relobj_file<64, false>* object,
d306 1
a306 1
  relocate_section(const Relocate_info<64, false>*,
d313 1
a313 1
		   elfcpp::Elf_types<64>::Elf_Addr view_address,
d321 1
a321 1
			  Sized_relobj_file<64, false>* object,
d334 13
a346 12
  relocate_for_relocatable(const Relocate_info<64, false>*,
			   unsigned int sh_type,
			   const unsigned char* prelocs,
			   size_t reloc_count,
			   Output_section* output_section,
			   off_t offset_in_output_section,
			   const Relocatable_relocs*,
			   unsigned char* view,
			   elfcpp::Elf_types<64>::Elf_Addr view_address,
			   section_size_type view_size,
			   unsigned char* reloc_view,
			   section_size_type reloc_view_size);
d441 1
a441 1
		          Sized_relobj<64, false>* obj,
d462 2
a463 2
  apply_relocation(const Relocate_info<64, false>* relinfo,
		   elfcpp::Elf_types<64>::Elf_Addr r_offset,
d465 1
a465 1
		   elfcpp::Elf_types<64>::Elf_Swxword r_addend,
d468 1
a468 1
		   elfcpp::Elf_types<64>::Elf_Addr address,
d473 1
a473 1
  add_tlsdesc_info(Sized_relobj_file<64, false>* object, unsigned int r_sym)
d493 1
a493 1
	  Sized_relobj_file<64, false>* object,
d496 2
a497 2
	  const elfcpp::Rela<64, false>& reloc, unsigned int r_type,
	  const elfcpp::Sym<64, false>& lsym);
d501 1
a501 1
	   Sized_relobj_file<64, false>* object,
d504 1
a504 1
	   const elfcpp::Rela<64, false>& reloc, unsigned int r_type,
d510 1
a510 1
			        	Sized_relobj_file<64, false>* object,
d513 1
a513 1
		  			const elfcpp::Rela<64, false>& reloc,
d515 1
a515 1
				  	const elfcpp::Sym<64, false>& lsym);
d520 1
a520 1
         	   			 Sized_relobj_file<64, false>* object,
d523 1
a523 1
		   			 const elfcpp::Rela<64, false>& reloc,
d529 2
a530 1
    unsupported_reloc_local(Sized_relobj_file<64, false>*, unsigned int r_type);
d533 2
a534 2
    unsupported_reloc_global(Sized_relobj_file<64, false>*, unsigned int r_type,
			     Symbol*);
d543 1
a543 1
    reloc_needs_plt_for_ifunc(Sized_relobj_file<64, false>*,
d570 6
a575 5
    relocate(const Relocate_info<64, false>*, Target_x86_64*, Output_section*,
	     size_t relnum, const elfcpp::Rela<64, false>&,
	     unsigned int r_type, const Sized_symbol<64>*,
	     const Symbol_value<64>*,
	     unsigned char*, elfcpp::Elf_types<64>::Elf_Addr,
d581 5
a585 5
    relocate_tls(const Relocate_info<64, false>*, Target_x86_64*,
                 size_t relnum, const elfcpp::Rela<64, false>&,
		 unsigned int r_type, const Sized_symbol<64>*,
		 const Symbol_value<64>*,
		 unsigned char*, elfcpp::Elf_types<64>::Elf_Addr,
d590 1
a590 1
    tls_gd_to_ie(const Relocate_info<64, false>*, size_t relnum,
d592 2
a593 2
		 const elfcpp::Rela<64, false>&, unsigned int r_type,
		 elfcpp::Elf_types<64>::Elf_Addr value,
d595 1
a595 1
		 elfcpp::Elf_types<64>::Elf_Addr,
d600 1
a600 1
    tls_gd_to_le(const Relocate_info<64, false>*, size_t relnum,
d602 2
a603 2
		 const elfcpp::Rela<64, false>&, unsigned int r_type,
		 elfcpp::Elf_types<64>::Elf_Addr value,
d609 1
a609 1
    tls_desc_gd_to_ie(const Relocate_info<64, false>*, size_t relnum,
d611 2
a612 2
		      const elfcpp::Rela<64, false>&, unsigned int r_type,
		      elfcpp::Elf_types<64>::Elf_Addr value,
d614 1
a614 1
		      elfcpp::Elf_types<64>::Elf_Addr,
d619 1
a619 1
    tls_desc_gd_to_le(const Relocate_info<64, false>*, size_t relnum,
d621 2
a622 2
		      const elfcpp::Rela<64, false>&, unsigned int r_type,
		      elfcpp::Elf_types<64>::Elf_Addr value,
d628 1
a628 1
    tls_ld_to_le(const Relocate_info<64, false>*, size_t relnum,
d630 2
a631 2
		 const elfcpp::Rela<64, false>&, unsigned int r_type,
		 elfcpp::Elf_types<64>::Elf_Addr value,
d637 1
a637 1
    tls_ie_to_le(const Relocate_info<64, false>*, size_t relnum,
d639 2
a640 2
		 const elfcpp::Rela<64, false>&, unsigned int r_type,
		 elfcpp::Elf_types<64>::Elf_Addr value,
d694 1
a694 1
			     Sized_relobj_file<64, false>* relobj,
d708 1
a708 1
		      Sized_relobj_file<64, false>* object);
d711 1
a711 1
  Output_data_plt_x86_64*
d733 1
a733 1
             Sized_relobj_file<64, false>* object,
d735 1
a735 1
	     Symbol* sym, const elfcpp::Rela<64, false>& reloc)
d738 1
a738 1
				  symtab->get_sized_symbol<64>(sym),
d764 1
a764 1
    Tlsdesc_info(Sized_relobj_file<64, false>* a_object, unsigned int a_r_sym)
d769 1
a769 1
    Sized_relobj_file<64, false>* object;
d777 1
a777 1
  Output_data_plt_x86_64* plt_;
d791 1
a791 1
  Copy_relocs<elfcpp::SHT_RELA, 64, false> copy_relocs_;
d804 2
a805 1
const Target::Target_info Target_x86_64::x86_64_info =
d828 24
d855 1
d857 1
a857 1
Target_x86_64::do_new_output_section(Output_section* os) const
d865 1
d867 1
a867 1
Target_x86_64::got_section(Symbol_table* symtab, Layout* layout)
d941 3
a943 2
Target_x86_64::Reloc_section*
Target_x86_64::rela_dyn_section(Layout* layout)
d962 3
a964 2
Target_x86_64::Reloc_section*
Target_x86_64::rela_irelative_section(Layout* layout)
d982 1
d984 1
a984 1
Output_data_plt_x86_64::init(Layout* layout)
d997 1
d999 1
a999 1
Output_data_plt_x86_64::do_adjust_output_section(Output_section* os)
d1006 1
d1008 2
a1009 2
Output_data_plt_x86_64::add_entry(Symbol_table* symtab, Layout* layout,
				  Symbol* gsym)
d1084 1
d1086 1
a1086 1
Output_data_plt_x86_64::add_local_ifunc_entry(
d1089 1
a1089 1
    Sized_relobj_file<64, false>* relobj,
d1112 1
d1114 4
a1117 2
Output_data_plt_x86_64::add_relocation(Symbol_table* symtab, Layout* layout,
				       Symbol* gsym, unsigned int got_offset)
d1137 3
a1139 2
Output_data_plt_x86_64::Reloc_section*
Output_data_plt_x86_64::rela_tlsdesc(Layout* layout)
d1156 4
a1159 2
Output_data_plt_x86_64::Reloc_section*
Output_data_plt_x86_64::rela_irelative(Symbol_table* symtab, Layout* layout)
d1197 1
d1199 1
a1199 1
Output_data_plt_x86_64::address_for_global(const Symbol* gsym)
d1211 1
d1213 1
a1213 1
Output_data_plt_x86_64::address_for_local(const Relobj*, unsigned int)
d1219 1
d1221 1
a1221 1
Output_data_plt_x86_64::set_final_data_size()
d1231 3
a1233 1
const unsigned char Output_data_plt_x86_64::first_plt_entry[plt_entry_size] =
d1245 3
a1247 1
const unsigned char Output_data_plt_x86_64::plt_entry[plt_entry_size] =
d1260 3
a1262 1
const unsigned char Output_data_plt_x86_64::tlsdesc_plt_entry[plt_entry_size] =
d1276 1
d1278 1
a1278 1
Output_data_plt_x86_64::plt_eh_frame_cie[plt_eh_frame_cie_size] =
d1296 1
d1298 1
a1298 1
Output_data_plt_x86_64::plt_eh_frame_fde[plt_eh_frame_fde_size] =
d1327 1
d1329 1
a1329 1
Output_data_plt_x86_64::do_write(Output_file* of)
d1349 1
a1349 1
  elfcpp::Elf_types<64>::Elf_Addr plt_address = this->address();
d1351 1
a1351 1
  elfcpp::Elf_types<64>::Elf_Addr got_base = this->got_->address();
d1355 2
a1356 1
  elfcpp::Elf_types<64>::Elf_Addr got_address = this->got_plt_->address();
d1433 1
d1435 1
a1435 1
Target_x86_64::make_plt_section(Symbol_table* symtab, Layout* layout)
d1442 3
a1444 3
      this->plt_ = new Output_data_plt_x86_64(layout, this->got_,
					      this->got_plt_,
					      this->got_irelative_);
d1458 3
a1460 2
Target_x86_64::Reloc_section*
Target_x86_64::rela_tlsdesc_section(Layout* layout) const
d1467 1
d1469 2
a1470 2
Target_x86_64::make_plt_entry(Symbol_table* symtab, Layout* layout,
                              Symbol* gsym)
d1483 1
d1485 4
a1488 3
Target_x86_64::make_local_ifunc_plt_entry(Symbol_table* symtab, Layout* layout,
					  Sized_relobj_file<64, false>* relobj,
					  unsigned int local_sym_index)
d1502 1
d1504 1
a1504 1
Target_x86_64::plt_entry_count() const
d1513 1
d1515 1
a1515 1
Target_x86_64::first_plt_entry_offset() const
d1517 1
a1517 1
  return Output_data_plt_x86_64::first_plt_entry_offset();
d1522 1
d1524 1
a1524 1
Target_x86_64::plt_entry_size() const
d1526 1
a1526 1
  return Output_data_plt_x86_64::get_plt_entry_size();
d1531 1
d1533 1
a1533 1
Target_x86_64::init_got_plt_for_update(Symbol_table* symtab,
d1583 4
a1586 2
  this->plt_ = new Output_data_plt_x86_64(layout, this->got_, this->got_plt_,
					  this->got_irelative_, plt_count);
d1604 1
d1606 1
a1606 1
Target_x86_64::reserve_local_got_entry(
d1608 1
a1608 1
    Sized_relobj<64, false>* obj,
d1646 1
d1648 3
a1650 2
Target_x86_64::reserve_global_got_entry(unsigned int got_index, Symbol* gsym,
					unsigned int got_type)
d1695 1
d1697 4
a1700 4
Target_x86_64::register_global_plt_entry(Symbol_table* symtab,
					 Layout* layout,
					 unsigned int plt_index,
					 Symbol* gsym)
d1715 1
d1717 1
a1717 1
Target_x86_64::emit_copy_reloc(
d1721 1
a1721 1
				     symtab->get_sized_symbol<64>(sym),
d1729 1
d1731 2
a1732 1
Target_x86_64::define_tls_base_symbol(Symbol_table* symtab, Layout* layout)
d1757 1
d1759 1
a1759 1
Target_x86_64::reserve_tlsdesc_entries(Symbol_table* symtab,
d1778 1
d1780 2
a1781 2
Target_x86_64::got_mod_index_entry(Symbol_table* symtab, Layout* layout,
			           Sized_relobj_file<64, false>* object)
d1801 1
d1803 1
a1803 1
Target_x86_64::optimize_tls_reloc(bool is_final, int r_type)
d1855 1
d1857 1
a1857 1
Target_x86_64::Scan::get_reference_flags(unsigned int r_type)
d1923 1
d1925 2
a1926 2
Target_x86_64::Scan::unsupported_reloc_local(
     Sized_relobj_file<64, false>* object,
d1943 1
d1945 2
a1946 2
Target_x86_64::Scan::check_non_pic(Relobj* object, unsigned int r_type,
				   Symbol* gsym)
d2011 1
d2013 2
a2014 2
Target_x86_64::Scan::reloc_needs_plt_for_ifunc(
     Sized_relobj_file<64, false>* object,
d2026 1
d2028 9
a2036 9
Target_x86_64::Scan::local(Symbol_table* symtab,
                           Layout* layout,
                           Target_x86_64* target,
                           Sized_relobj_file<64, false>* object,
                           unsigned int data_shndx,
                           Output_section* output_section,
                           const elfcpp::Rela<64, false>& reloc,
                           unsigned int r_type,
                           const elfcpp::Sym<64, false>& lsym)
d2042 1
a2042 1
      unsigned int r_sym = elfcpp::elf_r_sym<64>(reloc.get_r_info());
d2062 1
a2062 1
          unsigned int r_sym = elfcpp::elf_r_sym<64>(reloc.get_r_info());
d2085 1
a2085 1
	  unsigned int r_sym = elfcpp::elf_r_sym<64>(reloc.get_r_info());
d2138 1
a2138 1
        unsigned int r_sym = elfcpp::elf_r_sym<64>(reloc.get_r_info());
d2205 2
a2206 1
            = Target_x86_64::optimize_tls_reloc(!output_is_shared, r_type);
d2216 1
a2216 1
                unsigned int r_sym = elfcpp::elf_r_sym<64>(reloc.get_r_info());
d2248 1
a2248 1
                unsigned int r_sym = elfcpp::elf_r_sym<64>(reloc.get_r_info());
d2293 1
a2293 1
	        unsigned int r_sym = elfcpp::elf_r_sym<64>(reloc.get_r_info());
d2326 1
d2328 2
a2329 2
Target_x86_64::Scan::unsupported_reloc_global(
    Sized_relobj_file<64, false>* object,
d2338 1
d2340 1
a2340 1
Target_x86_64::Scan::possible_function_pointer_reloc(unsigned int r_type)
d2365 1
d2367 1
a2367 1
Target_x86_64::Scan::local_reloc_may_be_function_pointer(
d2370 2
a2371 2
  Target_x86_64* ,
  Sized_relobj_file<64, false>* ,
d2374 1
a2374 1
  const elfcpp::Rela<64, false>& ,
d2376 1
a2376 1
  const elfcpp::Sym<64, false>&)
d2389 1
d2391 1
a2391 1
Target_x86_64::Scan::global_reloc_may_be_function_pointer(
d2394 2
a2395 2
  Target_x86_64* ,
  Sized_relobj_file<64, false>* ,
d2398 1
a2398 1
  const elfcpp::Rela<64, false>& ,
d2413 1
d2415 1
a2415 1
Target_x86_64::Scan::global(Symbol_table* symtab,
d2417 2
a2418 2
                            Target_x86_64* target,
                            Sized_relobj_file<64, false>* object,
d2421 1
a2421 1
                            const elfcpp::Rela<64, false>& reloc,
d2662 1
a2662 1
            = Target_x86_64::optimize_tls_reloc(is_final, r_type);
d2775 1
d2777 11
a2787 11
Target_x86_64::gc_process_relocs(Symbol_table* symtab,
                                 Layout* layout,
                                 Sized_relobj_file<64, false>* object,
                                 unsigned int data_shndx,
                                 unsigned int sh_type,
                                 const unsigned char* prelocs,
                                 size_t reloc_count,
			         Output_section* output_section,
			         bool needs_special_offset_handling,
                                 size_t local_symbol_count,
                                 const unsigned char* plocal_symbols)
d2795 3
a2797 3
   gold::gc_process_relocs<64, false, Target_x86_64, elfcpp::SHT_RELA,
                           Target_x86_64::Scan,
			   Target_x86_64::Relocatable_size_for_reloc>(
d2813 1
d2815 11
a2825 11
Target_x86_64::scan_relocs(Symbol_table* symtab,
                           Layout* layout,
                           Sized_relobj_file<64, false>* object,
                           unsigned int data_shndx,
                           unsigned int sh_type,
                           const unsigned char* prelocs,
                           size_t reloc_count,
			   Output_section* output_section,
			   bool needs_special_offset_handling,
                           size_t local_symbol_count,
                           const unsigned char* plocal_symbols)
d2834 2
a2835 2
  gold::scan_relocs<64, false, Target_x86_64, elfcpp::SHT_RELA,
      Target_x86_64::Scan>(
d2851 1
d2853 1
a2853 1
Target_x86_64::do_finalize_sections(
d2893 1
a2893 1
      symtab->get_sized_symbol<64>(sym)->set_symsize(data_size);
d2940 1
d2942 12
a2953 11
Target_x86_64::Relocate::relocate(const Relocate_info<64, false>* relinfo,
                                  Target_x86_64* target,
				  Output_section*,
                                  size_t relnum,
                                  const elfcpp::Rela<64, false>& rela,
                                  unsigned int r_type,
                                  const Sized_symbol<64>* gsym,
                                  const Symbol_value<64>* psymval,
                                  unsigned char* view,
                                  elfcpp::Elf_types<64>::Elf_Addr address,
                                  section_size_type view_size)
d2972 1
a2972 1
  const Sized_relobj_file<64, false>* object = relinfo->object;
d2975 1
a2975 1
  Symbol_value<64> symval;
d2985 1
a2985 1
      unsigned int r_sym = elfcpp::elf_r_sym<64>(rela.get_r_info());
d3016 1
a3016 1
          unsigned int r_sym = elfcpp::elf_r_sym<64>(rela.get_r_info());
d3036 1
a3036 1
      Relocate_functions<64, false>::rela64(view, object, psymval, addend);
d3040 1
a3040 1
      Relocate_functions<64, false>::pcrela64(view, object, psymval, addend,
d3049 1
a3049 1
      Relocate_functions<64, false>::rela32(view, object, psymval, addend);
d3056 1
a3056 1
      Relocate_functions<64, false>::rela32(view, object, psymval, addend);
d3060 2
a3061 2
      Relocate_functions<64, false>::pcrela32(view, object, psymval, addend,
                                              address);
d3065 1
a3065 1
      Relocate_functions<64, false>::rela16(view, object, psymval, addend);
d3069 2
a3070 2
      Relocate_functions<64, false>::pcrela16(view, object, psymval, addend,
                                              address);
d3074 1
a3074 1
      Relocate_functions<64, false>::rela8(view, object, psymval, addend);
d3078 2
a3079 2
      Relocate_functions<64, false>::pcrela8(view, object, psymval, addend,
                                             address);
d3092 2
a3093 2
      Relocate_functions<64, false>::pcrela32(view, object, psymval, addend,
                                              address);
d3101 1
a3101 1
	elfcpp::Elf_types<64>::Elf_Addr got_address;
d3103 2
a3104 2
	Relocate_functions<64, false>::rela64(view, object, psymval,
					      addend - got_address);
d3109 1
a3109 1
      Relocate_functions<64, false>::rela32(view, got_offset, addend);
d3115 1
a3115 1
	elfcpp::Elf_types<64>::Elf_Addr value;
d3117 1
a3117 1
	Relocate_functions<64, false>::pcrela32(view, value, addend, address);
d3126 1
a3126 1
      Relocate_functions<64, false>::rela64(view, got_offset, addend);
d3132 1
a3132 1
	elfcpp::Elf_types<64>::Elf_Addr value;
d3134 1
a3134 1
	Relocate_functions<64, false>::pcrela64(view, value, addend, address);
d3140 1
a3140 1
	elfcpp::Elf_types<64>::Elf_Addr value;
d3143 1
a3143 1
	Relocate_functions<64, false>::rela64(view, value, addend);
d3150 1
a3150 1
        elfcpp::Elf_types<64>::Elf_Addr value;
d3152 1
a3152 1
        Relocate_functions<64, false>::pcrela32(view, value, addend, address);
d3159 1
a3159 1
        elfcpp::Elf_types<64>::Elf_Addr value;
d3161 1
a3161 1
        Relocate_functions<64, false>::pcrela64(view, value, addend, address);
d3206 1
d3208 11
a3218 10
Target_x86_64::Relocate::relocate_tls(const Relocate_info<64, false>* relinfo,
                                      Target_x86_64* target,
                                      size_t relnum,
                                      const elfcpp::Rela<64, false>& rela,
                                      unsigned int r_type,
                                      const Sized_symbol<64>* gsym,
                                      const Symbol_value<64>* psymval,
                                      unsigned char* view,
                                      elfcpp::Elf_types<64>::Elf_Addr address,
                                      section_size_type view_size)
d3222 1
a3222 1
  const Sized_relobj_file<64, false>* object = relinfo->object;
d3224 1
a3224 1
  elfcpp::Shdr<64, false> data_shdr(relinfo->data_shdr);
d3227 1
a3227 1
  elfcpp::Elf_types<64>::Elf_Addr value = psymval->value(relinfo->object, 0);
d3233 1
a3233 1
      = Target_x86_64::optimize_tls_reloc(is_final, r_type);
d3273 1
a3273 1
              unsigned int r_sym = elfcpp::elf_r_sym<64>(rela.get_r_info());
d3290 2
a3291 2
              Relocate_functions<64, false>::pcrela32(view, value, addend,
                                                      address);
d3341 1
a3341 1
              unsigned int r_sym = elfcpp::elf_r_sym<64>(rela.get_r_info());
d3367 2
a3368 2
                  Relocate_functions<64, false>::pcrela32(view, value, addend,
                                                          address);
d3403 2
a3404 2
          Relocate_functions<64, false>::pcrela32(view, value, addend,
                                                  address);
d3428 1
a3428 1
      Relocate_functions<64, false>::rela32(view, value, addend);
d3443 1
a3443 1
      Relocate_functions<64, false>::rela64(view, value, addend);
d3455 4
a3458 3
	  Target_x86_64::Relocate::tls_ie_to_le(relinfo, relnum, tls_segment,
                                                rela, r_type, value, view,
                                                view_size);
d3474 1
a3474 1
              unsigned int r_sym = elfcpp::elf_r_sym<64>(rela.get_r_info());
d3481 2
a3482 1
          Relocate_functions<64, false>::pcrela32(view, value, addend, address);
d3498 1
a3498 1
      Relocate_functions<64, false>::rela32(view, value, addend);
d3506 1
d3508 10
a3517 9
Target_x86_64::Relocate::tls_gd_to_ie(const Relocate_info<64, false>* relinfo,
                                      size_t relnum,
                                      Output_segment*,
                                      const elfcpp::Rela<64, false>& rela,
                                      unsigned int,
                                      elfcpp::Elf_types<64>::Elf_Addr value,
                                      unsigned char* view,
                                      elfcpp::Elf_types<64>::Elf_Addr address,
                                      section_size_type view_size)
d3534 2
a3535 1
  Relocate_functions<64, false>::pcrela32(view + 8, value, addend - 8, address);
d3545 1
d3547 9
a3555 8
Target_x86_64::Relocate::tls_gd_to_le(const Relocate_info<64, false>* relinfo,
                                      size_t relnum,
                                      Output_segment* tls_segment,
                                      const elfcpp::Rela<64, false>& rela,
                                      unsigned int,
                                      elfcpp::Elf_types<64>::Elf_Addr value,
                                      unsigned char* view,
                                      section_size_type view_size)
d3572 1
a3572 1
  Relocate_functions<64, false>::rela32(view + 8, value, 0);
d3581 1
d3583 2
a3584 2
Target_x86_64::Relocate::tls_desc_gd_to_ie(
    const Relocate_info<64, false>* relinfo,
d3587 1
a3587 1
    const elfcpp::Rela<64, false>& rela,
d3589 1
a3589 1
    elfcpp::Elf_types<64>::Elf_Addr value,
d3591 1
a3591 1
    elfcpp::Elf_types<64>::Elf_Addr address,
d3604 1
a3604 1
      Relocate_functions<64, false>::pcrela32(view, value, addend, address);
d3621 1
d3623 2
a3624 2
Target_x86_64::Relocate::tls_desc_gd_to_le(
    const Relocate_info<64, false>* relinfo,
d3627 1
a3627 1
    const elfcpp::Rela<64, false>& rela,
d3629 1
a3629 1
    elfcpp::Elf_types<64>::Elf_Addr value,
d3644 1
a3644 1
      Relocate_functions<64, false>::rela32(view, value, 0);
d3659 1
d3661 9
a3669 8
Target_x86_64::Relocate::tls_ld_to_le(const Relocate_info<64, false>* relinfo,
                                      size_t relnum,
                                      Output_segment*,
                                      const elfcpp::Rela<64, false>& rela,
                                      unsigned int,
                                      elfcpp::Elf_types<64>::Elf_Addr,
                                      unsigned char* view,
                                      section_size_type view_size)
d3693 1
d3695 9
a3703 8
Target_x86_64::Relocate::tls_ie_to_le(const Relocate_info<64, false>* relinfo,
                                      size_t relnum,
                                      Output_segment* tls_segment,
                                      const elfcpp::Rela<64, false>& rela,
                                      unsigned int,
                                      elfcpp::Elf_types<64>::Elf_Addr value,
                                      unsigned char* view,
                                      section_size_type view_size)
d3745 1
a3745 1
  Relocate_functions<64, false>::rela32(view, value, 0);
d3750 1
d3752 2
a3753 2
Target_x86_64::relocate_section(
    const Relocate_info<64, false>* relinfo,
d3760 1
a3760 1
    elfcpp::Elf_types<64>::Elf_Addr address,
d3766 2
a3767 2
  gold::relocate_section<64, false, Target_x86_64, elfcpp::SHT_RELA,
			 Target_x86_64::Relocate>(
d3783 1
d3785 3
a3787 3
Target_x86_64::apply_relocation(
    const Relocate_info<64, false>* relinfo,
    elfcpp::Elf_types<64>::Elf_Addr r_offset,
d3789 1
a3789 1
    elfcpp::Elf_types<64>::Elf_Swxword r_addend,
d3792 1
a3792 1
    elfcpp::Elf_types<64>::Elf_Addr address,
d3795 2
a3796 1
  gold::apply_relocation<64, false, Target_x86_64, Target_x86_64::Relocate>(
d3811 1
d3813 1
a3813 1
Target_x86_64::Relocatable_size_for_reloc::get_size_for_reloc(
d3881 1
d3883 13
a3895 12
Target_x86_64::scan_relocatable_relocs(Symbol_table* symtab,
				       Layout* layout,
				       Sized_relobj_file<64, false>* object,
				       unsigned int data_shndx,
				       unsigned int sh_type,
				       const unsigned char* prelocs,
				       size_t reloc_count,
				       Output_section* output_section,
				       bool needs_special_offset_handling,
				       size_t local_symbol_count,
				       const unsigned char* plocal_symbols,
				       Relocatable_relocs* rr)
d3902 1
a3902 1
  gold::scan_relocatable_relocs<64, false, elfcpp::SHT_RELA,
d3919 1
d3921 2
a3922 2
Target_x86_64::relocate_for_relocatable(
    const Relocate_info<64, false>* relinfo,
d3930 1
a3930 1
    elfcpp::Elf_types<64>::Elf_Addr view_address,
d3937 1
a3937 1
  gold::relocate_for_relocatable<64, false, elfcpp::SHT_RELA>(
d3956 1
d3958 1
a3958 1
Target_x86_64::do_dynsym_value(const Symbol* gsym) const
d3967 1
d3969 1
a3969 1
Target_x86_64::do_code_fill(section_size_type length) const
d4042 1
d4044 2
a4045 2
Target_x86_64::do_reloc_addend(void* arg, unsigned int r_type,
			       uint64_t) const
d4051 1
a4051 1
  const Symbol_value<64>* psymval = ti.object->local_symbol(ti.r_sym);
d4063 1
d4065 1
a4065 1
Target_x86_64::do_ehframe_datarel_base() const
d4069 1
a4069 1
  Sized_symbol<64>* ssym = static_cast<Sized_symbol<64>*>(sym);
d4078 1
d4080 7
a4086 7
Target_x86_64::do_calls_non_split(Relobj* object, unsigned int shndx,
				  section_offset_type fnoffset,
				  section_size_type fnsize,
				  unsigned char* view,
				  section_size_type view_size,
				  std::string* from,
				  std::string* to) const
d4137 1
d4142 7
a4148 2
    : Target_selector_freebsd(elfcpp::EM_X86_64, 64, false, "elf64-x86-64",
			      "elf64-x86-64-freebsd", "elf_x86_64")
d4153 1
a4153 1
  { return new Target_x86_64(); }
d4157 2
a4158 1
Target_selector_x86_64 target_selector_x86_64;
@


1.143
log
@	* object.h (Relobj::local_symbol_value): New function.
	(Relobj::local_plt_offset): New function.
	(Relobj::local_has_got_offset): New function.
	(Relobj::local_got_offset): New function.
	(Relobj::set_local_got_offset): New function.
	(Relobj::do_local_symbol_value): New pure virtual function.
	(Relobj::do_local_plt_offset): Likewise.
	(Relobj::do_local_has_got_offset): Likewise.
	(Relobj::do_local_got_offset): Likewise.
	(Relobj::do_set_local_got_offset): Likewise.
	(Sized_relobj::do_local_has_got_offset): Rename from
	local_has_got_offset.
	(Sized_relobj::do_local_got_offset): Rename from local_got_offset.
	(Sized_relobj::do_set_local_got_offset): Rename from
	set_local_got_offset.
	(Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	(Sized_relobj_file::do_local_symbol_value): New function.
	* object.cc (Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	* output.cc (Output_data_got::Got_entry::write): Change object to
	Relobj.  Use local_symbol_value.
	(Output_data_got::add_global_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_with_rela): Remove.  Change all
	callers to use add_global_with_rel.
	(Output_data_got::add_global_pair_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_pair_with_rela): Remove.  Change all
	callers to use add_global_pair_with_rel.
	(Output_data_got::add_local): Change object to Relobj*.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Change object to Relobj*,
	change rel_dyn to Output_data_reloc_generic*.  Use
	add_local_generic.
	(Output_data_got::add_local_with_rela): Remove.  Change all
	callers to use all_local_with_rel.
	(Output_data_got::add_local_pair_with_rel): Change object to
	Relobj*, change rel_dyn to Output_data_reloc_generic*.  Use
	add_output_section_generic.
	(Output_data_got::add_local_pair_with_rela): Remove.  Change all
	callers to use add_local_pair_with_rel.
	(Output_data_got::reserve_local): Change object to Relobj*.
	* output.h: (class Output_data_reloc_generic): Add pure virtual
	declarations for add_global_generic, add_local_generic,
	add_output_section_generic.
	(class Output_data_reloc) [SHT_REL, SHT_RELA]: Implement new
	functions for Output_data_reloc_generic.  Update declarations for
	changes listed in output.cc.
	(class Output_data_got): Change template parameter to got_size.
	Don't define Rel_dyn or Rela_dyn.  Update declarations per above.
	* incremental.h (Sized_relobj_incr::do_local_symbol_value): New
	function.
	(Sized_relobj_incr::do_local_plt_offset): New function.
	* copy-relocs.cc (Copy_relocs::Copy_reloc_entry::emit): Call
	add_global_generic.
@
text
@d428 1
a428 1
  Output_data_got<64, false>*
d1466 1
a1466 1
Output_data_got<64, false>*
@


1.142
log
@2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.
@
text
@d2140 5
a2144 5
		  got->add_local_pair_with_rela(object, r_sym,
						shndx,
						GOT_TYPE_TLS_PAIR,
						target->rela_dyn_section(layout),
						elfcpp::R_X86_64_DTPMOD64, 0);
d2210 3
a2212 3
	        got->add_local_with_rela(object, r_sym, GOT_TYPE_TLS_OFFSET,
	                                 target->rela_dyn_section(layout),
	                                 elfcpp::R_X86_64_TPOFF64);
d2484 2
a2485 2
              got->add_global_with_rela(gsym, GOT_TYPE_STANDARD, rela_dyn,
                                        elfcpp::R_X86_64_GLOB_DAT);
d2583 4
a2586 4
                got->add_global_pair_with_rela(gsym, GOT_TYPE_TLS_PAIR,
                                               target->rela_dyn_section(layout),
                                               elfcpp::R_X86_64_DTPMOD64,
                                               elfcpp::R_X86_64_DTPOFF64);
d2593 3
a2595 3
                got->add_global_with_rela(gsym, GOT_TYPE_TLS_OFFSET,
                                          target->rela_dyn_section(layout),
                                          elfcpp::R_X86_64_TPOFF64);
d2616 2
a2617 2
                got->add_global_pair_with_rela(gsym, GOT_TYPE_TLS_DESC, rt,
                                               elfcpp::R_X86_64_TLSDESC, 0);
d2624 3
a2626 3
                got->add_global_with_rela(gsym, GOT_TYPE_TLS_OFFSET,
                                          target->rela_dyn_section(layout),
                                          elfcpp::R_X86_64_TPOFF64);
d2656 3
a2658 3
	        got->add_global_with_rela(gsym, GOT_TYPE_TLS_OFFSET,
	                                  target->rela_dyn_section(layout),
	                                  elfcpp::R_X86_64_TPOFF64);
@


1.141
log
@	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.
@
text
@d3864 45
a3908 36
  const char nop1[1] = { 0x90 };                   // nop
  const char nop2[2] = { 0x66, 0x90 };             // xchg %ax %ax
  const char nop3[3] = { 0x0f, 0x1f, 0x00 };       // nop (%rax)
  const char nop4[4] = { 0x0f, 0x1f, 0x40, 0x00};  // nop 0(%rax)
  const char nop5[5] = { 0x0f, 0x1f, 0x44, 0x00,   // nop 0(%rax,%rax,1)
                         0x00 };
  const char nop6[6] = { 0x66, 0x0f, 0x1f, 0x44,   // nopw 0(%rax,%rax,1)
                         0x00, 0x00 };
  const char nop7[7] = { 0x0f, 0x1f, 0x80, 0x00,   // nopl 0L(%rax)
                         0x00, 0x00, 0x00 };
  const char nop8[8] = { 0x0f, 0x1f, 0x84, 0x00,   // nopl 0L(%rax,%rax,1)
                         0x00, 0x00, 0x00, 0x00 };
  const char nop9[9] = { 0x66, 0x0f, 0x1f, 0x84,   // nopw 0L(%rax,%rax,1)
                         0x00, 0x00, 0x00, 0x00,
                         0x00 };
  const char nop10[10] = { 0x66, 0x2e, 0x0f, 0x1f, // nopw %cs:0L(%rax,%rax,1)
                           0x84, 0x00, 0x00, 0x00,
                           0x00, 0x00 };
  const char nop11[11] = { 0x66, 0x66, 0x2e, 0x0f, // data16
                           0x1f, 0x84, 0x00, 0x00, // nopw %cs:0L(%rax,%rax,1)
                           0x00, 0x00, 0x00 };
  const char nop12[12] = { 0x66, 0x66, 0x66, 0x2e, // data16; data16
                           0x0f, 0x1f, 0x84, 0x00, // nopw %cs:0L(%rax,%rax,1)
                           0x00, 0x00, 0x00, 0x00 };
  const char nop13[13] = { 0x66, 0x66, 0x66, 0x66, // data16; data16; data16
                           0x2e, 0x0f, 0x1f, 0x84, // nopw %cs:0L(%rax,%rax,1)
                           0x00, 0x00, 0x00, 0x00,
                           0x00 };
  const char nop14[14] = { 0x66, 0x66, 0x66, 0x66, // data16; data16; data16
                           0x66, 0x2e, 0x0f, 0x1f, // data16
                           0x84, 0x00, 0x00, 0x00, // nopw %cs:0L(%rax,%rax,1)
                           0x00, 0x00 };
  const char nop15[15] = { 0x66, 0x66, 0x66, 0x66, // data16; data16; data16
                           0x66, 0x66, 0x2e, 0x0f, // data16; data16
                           0x1f, 0x84, 0x00, 0x00, // nopw %cs:0L(%rax,%rax,1)
                           0x00, 0x00, 0x00 };
@


1.140
log
@	PR gold/13249
	* gold/output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* gold/output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* gold/x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.
@
text
@a3183 6
	      if (tls_segment == NULL)
		{
		  gold_assert(parameters->errors()->error_count() > 0
			      || issue_undefined_symbol_error(gsym));
		  return;
		}
@


1.139
log
@	* i386.cc (class Output_data_plt_i386): Add layout_ field.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize layout_.
	(Output_data_plt_i386::do_write): Write address of .dynamic
	section to first entry in .got.plt section.
	* x86_64.cc (class Output_data_plt_x86_64): Add layout_ field.
	(Output_data_plt_x86_64::Output_data_plt_x86_64) [both versions]:
	Initialize layout_.
	(Output_data_plt_x86_64::do_write): Write address of .dynamic
	section to first entry in .got.plt section.
	* layout.h (Layout::dynamic_section): New function.
@
text
@d1552 1
a1552 1
				     this->got_, got_offset, 0);
d1956 2
a1957 2
  if (lsym.get_st_type() == elfcpp::STT_GNU_IFUNC
      && this->reloc_needs_plt_for_ifunc(object, r_type))
d1985 1
a1985 1
				       reloc.get_r_addend());
d2061 1
a2061 1
	if (lsym.get_st_type() == elfcpp::STT_GNU_IFUNC)
d2079 1
a2079 1
						 got, got_offset, 0);
@


1.139.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d1552 1
a1552 1
				     this->got_, got_offset, 0, false);
d1956 2
a1957 2
  bool is_ifunc = lsym.get_st_type() == elfcpp::STT_GNU_IFUNC;
  if (is_ifunc && this->reloc_needs_plt_for_ifunc(object, r_type))
d1985 1
a1985 1
				       reloc.get_r_addend(), is_ifunc);
d2061 1
a2061 1
	if (is_ifunc)
d2079 1
a2079 1
						 got, got_offset, 0, is_ifunc);
d3184 6
d3870 36
a3905 45
  const char nop1[1] = { '\x90' };                 // nop
  const char nop2[2] = { '\x66', '\x90' };         // xchg %ax %ax
  const char nop3[3] = { '\x0f', '\x1f', '\x00' }; // nop (%rax)
  const char nop4[4] = { '\x0f', '\x1f', '\x40',   // nop 0(%rax)
  			 '\x00'};
  const char nop5[5] = { '\x0f', '\x1f', '\x44',   // nop 0(%rax,%rax,1)
			 '\x00', '\x00' };
  const char nop6[6] = { '\x66', '\x0f', '\x1f',   // nopw 0(%rax,%rax,1)
  			 '\x44', '\x00', '\x00' };
  const char nop7[7] = { '\x0f', '\x1f', '\x80',   // nopl 0L(%rax)
  			 '\x00', '\x00', '\x00',
			 '\x00' };
  const char nop8[8] = { '\x0f', '\x1f', '\x84',   // nopl 0L(%rax,%rax,1)
  			 '\x00', '\x00', '\x00',
			 '\x00', '\x00' };
  const char nop9[9] = { '\x66', '\x0f', '\x1f',   // nopw 0L(%rax,%rax,1)
  			 '\x84', '\x00', '\x00',
			 '\x00', '\x00', '\x00' };
  const char nop10[10] = { '\x66', '\x2e', '\x0f', // nopw %cs:0L(%rax,%rax,1)
  			   '\x1f', '\x84', '\x00',
			   '\x00', '\x00', '\x00',
			   '\x00' };
  const char nop11[11] = { '\x66', '\x66', '\x2e', // data16
  			   '\x0f', '\x1f', '\x84', // nopw %cs:0L(%rax,%rax,1)
			   '\x00', '\x00', '\x00',
			   '\x00', '\x00' };
  const char nop12[12] = { '\x66', '\x66', '\x66', // data16; data16
  			   '\x2e', '\x0f', '\x1f', // nopw %cs:0L(%rax,%rax,1)
			   '\x84', '\x00', '\x00',
			   '\x00', '\x00', '\x00' };
  const char nop13[13] = { '\x66', '\x66', '\x66', // data16; data16; data16
  			   '\x66', '\x2e', '\x0f', // nopw %cs:0L(%rax,%rax,1)
			   '\x1f', '\x84', '\x00',
			   '\x00', '\x00', '\x00',
                           '\x00' };
  const char nop14[14] = { '\x66', '\x66', '\x66', // data16; data16; data16
  			   '\x66', '\x66', '\x2e', // data16
			   '\x0f', '\x1f', '\x84', // nopw %cs:0L(%rax,%rax,1)
			   '\x00', '\x00', '\x00',
                           '\x00', '\x00' };
  const char nop15[15] = { '\x66', '\x66', '\x66', // data16; data16; data16
  			   '\x66', '\x66', '\x66', // data16; data16
			   '\x2e', '\x0f', '\x1f', // nopw %cs:0L(%rax,%rax,1)
			   '\x84', '\x00', '\x00',
                           '\x00', '\x00', '\x00' };
@


1.138
log
@	* i386.cc (Target_i386::got_section): If -z now, make .got.plt a
	relro section.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_now_test.
	(relro_now_test_SOURCES): New variable.
	(relro_now_test_DEPENDENCIES): New variable.
	(relro_now_test_LDFLAGS): New variable.
	(relro_now_test_LDADD): New variable.
	(relro_now_test.so): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d60 4
a63 3
    : Output_section_data(16), tlsdesc_rel_(NULL), irelative_rel_(NULL),
      got_(got), got_plt_(got_plt), got_irelative_(got_irelative), count_(0),
      irelative_count_(0), tlsdesc_got_offset_(-1U), free_list_()
d71 3
a73 3
      tlsdesc_rel_(NULL), irelative_rel_(NULL), got_(got), got_plt_(got_plt),
      got_irelative_(got_irelative), count_(plt_count), irelative_count_(0),
      tlsdesc_got_offset_(-1U), free_list_()
d209 3
d1313 10
a1322 2
  memset(got_pov, 0, 24);
  got_pov += 24;
@


1.137
log
@	PR gold/12980
	* i386.cc (Target_i386::Scan::global): For a GOT reloc, use a
	GLOB_DAT relocation rather than a RELATIVE relocation for a
	protected symbol when creating a shared library.
	* x86_64.cc (Target_x86_64::Scan::global): Likewise.
	* testsuite/protected_1.cc (f2, get_f2_addr): New functions.
	* testsuite/protected_main_1.cc (main): Test that protected
	function has same address.
@
text
@d837 11
d853 1
a853 2
				      this->got_, ORDER_RELRO_LAST,
				      true);
d859 2
a860 2
				      this->got_plt_, ORDER_NON_RELRO_FIRST,
				      false);
d865 5
a869 2
      // Those bytes can go into the relro segment.
      layout->increase_relro(3 * 8);
d888 1
a888 1
				      ORDER_NON_RELRO_FIRST, false);
d897 1
a897 1
				      ORDER_NON_RELRO_FIRST, false);
@


1.136
log
@	PR gold/11317
	* target-reloc.h (issue_undefined_symbol_error): New inline
	function, broken out of relocate_section.
	(relocate_section): Call issue_undefined_symbol_error.
	* i386.cc (Target_i386::Relocate::relocate_tls): Don't crash if
	there is no TLS segment if we are about to issue an undefined
	symbol error.
	* x86_64.cc (Target_x86_64::relocate_tls): Likewise.
@
text
@d2439 13
d2455 2
@


1.135
log
@	PR gold/12279
	* resolve.cc (Symbol_table::should_override): Add fromtype
	parameter.  Change all callers.  Give error when linking together
	TLS and non-TLS symbol.
	(Symbol_table::should_override_with_special): Add fromtype
	parameter.  Change all callers.
	* i386.cc (Target_i386::Relocate::relocate_tls): Don't crash if
	there is no TLS segment if we have reported some errors.
	* x86_64.cc (Target_x86_64::relocate_tls): Likewise.
@
text
@d3115 2
a3116 1
	      gold_assert(parameters->errors()->error_count() > 0);
d3146 2
a3147 1
		  gold_assert(parameters->errors()->error_count() > 0);
d3180 2
a3181 1
	      gold_assert(parameters->errors()->error_count() > 0);
d3220 2
a3221 1
		  gold_assert(parameters->errors()->error_count() > 0);
d3257 2
a3258 1
	      gold_assert(parameters->errors()->error_count() > 0);
d3292 2
a3293 1
	      gold_assert(parameters->errors()->error_count() > 0);
d3307 2
a3308 1
	      gold_assert(parameters->errors()->error_count() > 0);
d3321 2
a3322 1
	      gold_assert(parameters->errors()->error_count() > 0);
d3361 2
a3362 1
	  gold_assert(parameters->errors()->error_count() > 0);
@


1.134
log
@	PR gold/12372
	* target.h (Target::plt_address_for_global): New function.
	(Target::plt_address_for_local): New function.
	(Target::plt_section_for_global): Remove.
	(Target::plt_section_for_local): Remove.
	(Target::do_plt_address_for_global): New virtual function.
	(Target::do_plt_address_for_local): New virtual function.
	(Target::do_plt_section_for_global): Remove.
	(Target::do_plt_section_for_local): Remove.
	(Target::register_global_plt_entry): Add Symbol_table and Layout
	parameters.
	* output.cc (Output_data_got::Got_entry::write): Use
	plt_address_for_global and plt_address_for_local.
	* layout.cc (Layout::add_target_dynamic_tags): Use size and
	address of output section.
	* i386.cc (class Output_data_plt_i386): Add irelative_rel_,
	got_irelative_, and irelative_count_ fields.  Update
	declarations.
	(Output_data_plt_i386::has_irelative_section): New function.
	(Output_data_plt_i386::entry_count): Add irelative_count_.
	(Output_data_plt_i386::set_final_data_size): Likewise.
	(class Target_i386): Add got_irelative_ and rel_irelative_
	fields.  Update declarations.
	(Target_i386::Target_i386): Initialize new fields.
	(Target_i386::do_plt_address_for_global): New function replacing
	do_plt_section_for_global.
	(Target_i386::do_plt_address_for_local): New function replacing
	do_plt_section_for_local.
	(Target_i386::got_section): Create got_irelative_.
	(Target_i386::rel_irelative_section): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize new
	fields.  Don't define __rel_iplt_{start,end}.
	(Output_data_plt_i386::add_entry): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): Add symtab and
	layout parameters.  Change all callers.  Use different PLT and
	GOT.
	(Output_data_plt_i386::rel_tls_desc): Fix formatting.
	(Output_data_plt_i386::rel_irelative): New function.
	(Output_data_plt_i386::address_for_global): New function.
	(Output_data_plt_i386::address_for_local): New function.
	(Output_data_plt_i386::do_write): Write out IRELATIVE area.  Use
	IRELATIVE GOT when changing IFUNC GOT entries.
	(Target_i386::Scan::global): Use IRELATIVE GOT for IRELATIVE
	reloc.
	(Target_i386::do_finalize_sections): Create the __rel_iplt symbols
	if we didn't create an IRELATIVE GOT.
	(Target_i386::Relocate::relocate): Use plt_address_for_global and
	plt_address_for_local.
	(Target_i386::do_dynsym_value): Use plt_address_for_global.
	* x86_64.cc (class Output_data_plt_x86_64): Add irelative_rel_,
	got_irelative_, and irelative_count_ fields.  Update
	declarations.
	(Output_data_plt_x86_64::Output_data_plt_x86_64) [both versions]:
	Initialize new fields.  Remove symtab parameter.  Change all
	callers.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset): Add
	irelative_count_.
	(Output_data_plt_x86_64::has_irelative_section): New function.
	(Output_data_plt_x86_64::entry_count): Add irelative_count_.
	(class Target_x86_64): Add got_irelative_ and rel_irelative_
	fields.  Update declarations.
	(Target_x86_64::Target_x86_64): Initialize new fields.
	(Target_x86_64::do_plt_address_for_global): New function replacing
	do_plt_section_for_global.
	(Target_x86_64::do_plt_address_for_local): New function replacing
	do_plt_section_for_local.
	(Target_x86_64::got_section): Create got_irelative_.
	(Target_x86_64::rela_irelative_section): New function.
	(Output_data_plt_x86_64::init): Remove symtab parameter.  Change
	all callers.  Don't create __rel_iplt_{start,end}.
	(Output_data_plt_x86_64::add_entry): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Add symtab and
	layout parameters.  Change all callers.  Use different PLT and
	GOT.
	(Output_data_plt_x86_64::add_relocation): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_x86_64::rela_tlsdesc): Fix formatting.
	(Output_data_plt_x86_64::rela_irelative): New function.
	(Output_data_plt_x86_64::address_for_global): New function.
	(Output_data_plt_x86_64::address_for_local): New function.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::do_write): Write out IRELATIVE area.
	(Target_x86_64::init_got_plt_for_update): Create got_irelative_.
	(Target_x86_64::register_global_plt_entry): Add symtab and layout
	parameters.
	(Target_x86_64::Scan::global): Use IRELATIVE GOT for IRELATIVE
	reloc.
	(Target_x86_64::do_finalize_sections): Create the __rela_iplt
	symbols if we didn't create an IRELATIVE GOT.
	(Target_x86_64::Relocate::relocate): Use plt_address_for_global and
	plt_address_for_local.
	(Target_x86_64::do_dynsym_value): Use plt_address_for_global.
	* testsuite/ifuncvar1.c: New test file.
	* testsuite/ifuncvar2.c: New test file.
	* testsuite/ifuncvar3.c: New test file.
	* testsuite/Makefile.am (check_PROGRAMS): Add ifuncvar.
	(ifuncvar1_pic.o, ifuncvar2_pic.o, ifuncvar.so): New targets.
	(ifuncvar_SOURCES, ifuncvar_DEPENDENCIES): New variables.
	(ifuncvar_LDFLAGS, ifuncvar_LDADD): New variables.
	* testsuite/Makefile.in: Rebuild.
@
text
@d3113 5
a3117 1
	  gold_assert(tls_segment != NULL);
d3143 5
a3147 1
              gold_assert(tls_segment != NULL);
d3176 5
a3180 1
	  gold_assert(tls_segment != NULL);
d3215 5
a3219 1
              gold_assert(tls_segment != NULL);
d3251 5
a3255 1
          gold_assert(tls_segment != NULL);
d3285 5
a3289 1
	  gold_assert(tls_segment != NULL);
d3299 5
a3303 1
	  gold_assert(tls_segment != NULL);
d3312 5
a3316 1
          gold_assert(tls_segment != NULL);
d3351 5
@


1.133
log
@	PR gold/12392
	* i386.cc (Target_i386::do_finalize_sections): Define __rel_iplt
	symbols if necessary.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d57 7
a63 6
  Output_data_plt_x86_64(Symbol_table* symtab, Layout* layout,
			 Output_data_got<64, false>* got,
			 Output_data_space* got_plt)
    : Output_section_data(16), tlsdesc_rel_(NULL), got_(got), got_plt_(got_plt),
      count_(0), tlsdesc_got_offset_(-1U), free_list_()
  { this->init(symtab, layout); }
d65 1
a65 2
  Output_data_plt_x86_64(Symbol_table* symtab, Layout* layout,
			 Output_data_got<64, false>* got,
d67 1
d70 3
a72 2
      tlsdesc_rel_(NULL), got_(got), got_plt_(got_plt),
      count_(plt_count), tlsdesc_got_offset_(-1U), free_list_()
d74 1
a74 1
    this->init(symtab, layout);
d83 1
a83 1
  init(Symbol_table* symtab, Layout* layout);
d87 1
a87 1
  add_entry(Symbol* gsym);
d91 2
a92 1
  add_local_ifunc_entry(Sized_relobj_file<64, false>* relobj,
d97 2
a98 1
  add_relocation(Symbol* gsym, unsigned int got_offset);
d118 1
a118 1
  { return (this->count_ + 1) * plt_entry_size; }
d129 10
d142 1
a142 1
  { return this->count_; }
d162 8
d213 3
d220 2
d224 3
d250 4
a253 4
      got_(NULL), plt_(NULL), got_plt_(NULL), got_tlsdesc_(NULL),
      global_offset_table_(NULL), rela_dyn_(NULL),
      copy_relocs_(elfcpp::R_X86_64_COPY), dynbss_(NULL),
      got_mod_index_offset_(-1U), tlsdesc_reloc_info_(),
d365 7
a371 7
  Output_data*
  do_plt_section_for_global(const Symbol*) const
  { return this->plt_section(); }

  Output_data*
  do_plt_section_for_local(const Relobj*, unsigned int) const
  { return this->plt_section(); }
d446 2
a447 1
  register_global_plt_entry(unsigned int plt_index, Symbol* gsym);
d717 4
d771 2
d779 2
d868 9
d878 1
a878 1
      // .got.plt after the jump slot entries.
d906 23
d932 1
a932 1
Output_data_plt_x86_64::init(Symbol_table* symtab, Layout* layout)
a938 18
  if (parameters->doing_static_link())
    {
      // A statically linked executable will only have a .rela.plt
      // section to hold R_X86_64_IRELATIVE relocs for STT_GNU_IFUNC
      // symbols.  The library will use these symbols to locate the
      // IRELATIVE relocs at program startup time.
      symtab->define_in_output_data("__rela_iplt_start", NULL,
				    Symbol_table::PREDEFINED,
				    this->rel_, 0, 0, elfcpp::STT_NOTYPE,
				    elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN,
				    0, false, true);
      symtab->define_in_output_data("__rela_iplt_end", NULL,
				    Symbol_table::PREDEFINED,
				    this->rel_, 0, 0, elfcpp::STT_NOTYPE,
				    elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN,
				    0, true, true);
    }

d954 2
a955 1
Output_data_plt_x86_64::add_entry(Symbol* gsym)
d963 20
d985 3
a987 3
      // Note that when setting the PLT offset we skip the initial
      // reserved PLT entry.
      plt_index = this->count_ + 1;
d990 1
a990 1
      ++this->count_;
d992 2
a993 2
      got_offset = (plt_index - 1 + 3) * 8;
      gold_assert(got_offset == this->got_plt_->current_data_size());
d998 1
a998 1
      this->got_plt_->set_current_data_size(got_offset + 8);
d1002 2
d1014 1
a1014 1
      got_offset = (plt_index - 1 + 3) * 8;
d1020 1
a1020 1
  this->add_relocation(gsym, got_offset);
d1032 2
d1037 2
a1038 2
  unsigned int plt_offset = (this->count_ + 1) * plt_entry_size;
  ++this->count_;
d1040 1
a1040 1
  section_offset_type got_offset = this->got_plt_->current_data_size();
d1044 1
a1044 1
  this->got_plt_->set_current_data_size(got_offset + 8);
d1047 4
a1050 3
  this->rel_->add_symbolless_local_addend(relobj, local_sym_index,
					  elfcpp::R_X86_64_IRELATIVE,
					  this->got_plt_, got_offset, 0);
d1058 2
a1059 1
Output_data_plt_x86_64::add_relocation(Symbol* gsym, unsigned int got_offset)
d1063 5
a1067 2
    this->rel_->add_symbolless_global_addend(gsym, elfcpp::R_X86_64_IRELATIVE,
					     this->got_plt_, got_offset, 0);
d1088 2
a1089 2
      gold_assert(this->tlsdesc_rel_->output_section() ==
		  this->rel_->output_section());
d1094 61
d1159 1
a1159 1
  unsigned int count = this->count_;
d1264 3
d1268 2
a1269 1
    convert_to_section_size_type(this->got_plt_->data_size());
d1301 1
a1301 1
  const unsigned int count = this->count_;
d1359 3
a1361 2
      this->plt_ = new Output_data_plt_x86_64(symtab, layout, this->got_,
                                              this->got_plt_);
d1393 1
a1393 1
  this->plt_->add_entry(gsym);
d1407 2
a1408 1
  unsigned int plt_offset = this->plt_->add_local_ifunc_entry(relobj,
d1483 8
d1492 2
a1493 2
  this->plt_ = new Output_data_plt_x86_64(symtab, layout, this->got_,
					  this->got_plt_, plt_count);
d1600 3
a1602 1
Target_x86_64::register_global_plt_entry(unsigned int plt_index,
d1613 1
a1613 1
  this->plt_->add_relocation(gsym, got_offset);
d2359 2
a2360 1
		Reloc_section* rela_dyn = target->rela_dyn_section(layout);
d2764 2
a2765 1
  if (parameters->doing_static_link() && this->plt_ == NULL)
d2845 1
a2845 1
      symval.set_output_value(target->plt_section()->address()
d2854 1
a2854 1
	  symval.set_output_value(target->plt_section()->address()
d3764 1
a3764 1
  return this->plt_section()->address() + gsym->plt_offset();
@


1.132
log
@	PR gold/12525
	* ehframe.cc (Eh_frame_hdr::get_fde_pc): Handle DW_EH_PE_datarel.
	Assert if we see DW_EH_PE_indirect.
	* target.h (Target::ehframe_datarel_base): New function.
	(Target::do_ehframe_datarel_base): New target function.
	* i386.cc (Target_i386::do_ehframe_datarel_base): New function.
	* x86_64.cc (Target_x86_64::do_ehframe_datarel_base): New
	function.
@
text
@d2602 40
@


1.131
log
@	PR gold/12571
	* options.h (class General_options): Add
	--ld-generated-unwind-info.
	* ehframe.cc (Fde::write): Add address parameter.  Change all
	callers.  If associated with PLT, fill in address and size.
	(Cie::set_output_offset): Only add merge mapping if there is an
	object.
	(Cie::write): Add address parameter.  Change all callers.
	(Eh_frame::add_ehframe_for_plt): New function.
	* ehframe.h (class Fde): Update declarations.  Move shndx_ and
	input_offset_ fields into union u_, with new plt field.
	(Fde::Fde): Adjust for new union field.
	(Fde::Fde) [Output_data version]: New constructor.
	(Fde::add_mapping): Only add merge mapping if there is an object.
	(class Cie): Update declarations.
	(class Eh_frame): Declare add_ehframe_for_plt.
	* layout.cc (Layout::layout_eh_frame): Break out code into
	make_eh_frame_section, and call it.
	(Layout::make_eh_frame_section): New function.
	(Layout::add_eh_frame_for_plt): New function.
	* layout.h (class Layout): Update declarations.
	* merge.cc (Merge_map::add_mapping): Add assertion.
	* i386.cc: Include "dwarf.h".
	(class Output_data_plt_i386): Make first_plt_entry,
	dyn_first_plt_entry, exec_plt_entry, and dyn_plt_entry const.  Add
	plt_eh_frame_cie_size, plt_eh_frame_fde_size, plt_eh_frame_cie,
	and plt_eh_frame_fde.
	(Output_data_plt_i386::Output_data_plt_i386): Align to 16-byte
	boundary.  Call add_eh_frame_for_plt if appropriate.
	* x86_64.cc: Include "dwarf.h".
	(class Output_data_plt_x86_64): Align to 16-byte boundary.  Make
	first_plt_entry, plt_entry and tlsdesc_plt_entry const.  Add
	plt_eh_frame_cie_size, plt_eh_frame_fde_size, plt_eh_frame_cie,
	and plt_eh_frame_fde.
	(Output_data_plt_x86_64::init): Call add_eh_frame_for_plt if
	appropriate.
@
text
@d353 4
d3647 15
@


1.130
log
@	PR gold/12934
	* target-select.cc (Target_selector::Target_selector): Add
	emulation parameter.  Change all callers.
	(select_target_by_bfd_name): Rename from select_target_by_name.
	Change all callers.
	(select_target_by_emulation): New function.
	(supported_emulation_names): New function.
	* target-select.h (class Target_selector): Add emulation_ field.
	Update declarations.
	(Target_selector::recognize_by_bfd_name): Rename from
	recognize_by_name.  Change all callers.
	(Target_selector::supported_bfd_names): Rename from
	supported_names.  Change all callers.
	(Target_selector::recognize_by_emulation): New function.
	(Target_selector::supported_emulations): New function.
	(Target_selector::emulation): New function.
	(Target_selector::do_recognize_by_bfd_name): Rename from
	do_recognize_by_name.  Change all callers.
	(Target_selector::do_supported_bfd_names): Rename from
	do_supported_names.  Change all callers.
	(Target_selector::do_recognize_by_emulation): New function.
	(Target_selector::do_supported_emulations): New function.
	(select_target_by_bfd_name): Change name in declaration.
	(select_target_by_emulation): Declare.
	(supported_emulation_names): Declare.
	* parameters.cc (parameters_force_valid_target): Try to find
	target based on emulation from -m option.
	* options.h (class General_options): Change doc string for -m.
	* options.cc (help): Print emulations.
	(General_options::parse_V): Likewise.
	* freebsd.h (Target_selector_freebsd::Target_selector_freebsd):
	Add emulation parameter.  Change all callers.
@
text
@d28 1
d60 1
a60 1
    : Output_section_data(8), tlsdesc_rel_(NULL), got_(got), got_plt_(got_plt),
d68 1
a68 1
    : Output_section_data((plt_count + 1) * plt_entry_size, 8, false),
d164 1
a164 1
  static unsigned char first_plt_entry[plt_entry_size];
d167 1
a167 1
  static unsigned char plt_entry[plt_entry_size];
d170 7
a176 1
  static unsigned char tlsdesc_plt_entry[plt_entry_size];
d881 5
d1019 1
a1019 1
unsigned char Output_data_plt_x86_64::first_plt_entry[plt_entry_size] =
d1031 1
a1031 1
unsigned char Output_data_plt_x86_64::plt_entry[plt_entry_size] =
d1044 1
a1044 1
unsigned char Output_data_plt_x86_64::tlsdesc_plt_entry[plt_entry_size] =
d1056 48
@


1.129
log
@	* target.h (class Target): Add osabi_ field.
	(Target::osabi): New function.
	(Target::set_osabi): New function.
	(Target::Target): Initialize osabi_.
	(Target::do_adjust_elf_header): Make pure virtual.
	(Sized_target::do_adjust_elf_header): Declare.
	* target.cc (Sized_target::do_adjust_elf_header): New function.
	(class Sized_target): Instantiate all versions.
	* freebsd.h (class Target_freebsd): Remove.
	(Target_selector_freebsd::do_recognize): Call set_osabi on
	Target.
	(Target_selector_freebsd::do_recognize_by_name): Likewise.
	(Target_selector_freebsd::set_osabi): Remove.
	* i386.cc (class Target_i386): Inherit from Sized_target rather
	than Target_freebsd.
	* x86_64.cc (class Target_x86_64): Likewise.
@
text
@d3651 1
a3651 1
			      "elf64-x86-64-freebsd")
@


1.128
log
@	* target.h (Target::can_check_for_function_pointers): Rewrite.
	Make non-virtual.
	(Target::can_icf_inline_merge_sections): Likewise.
	(Target::section_may_have_icf_unsafe_poineters): Likewise.
	(Target::Target_info): Add can_icf_inline_merge_sections field.
	(Target::do_can_check_for_function_pointers): New virtual
	function.
	(Target::do_section_may_have_icf_unsafe_pointers): Likewise.
	* arm.cc (Target_arm::do_can_check_for_function_pointers): Rename
	from can_check_for_function_pointers, move in file.
	(Target_arm::do_section_may_have_icf_unsafe_pointers): Rename from
	section_may_have_icf_unsafe_poineters, move in file.
	(Target_arm::arm_info): Initialize can_icf_inline_merge_sections.
	* i386.cc (Target_i386::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_i386::can_icf_inline_merge_sections): Remove.
	(Target_i386::i386_info): Initialize
	can_icf_inline_merge_sections.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Initialize can_icf_inline_merge_sections.
	* sparc.cc (Target_sparc::sparc_info) [both version]: Likewise.
	* x86_64.cc (Target_x86_64::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_x86_64::can_icf_inline_merge_sections): Remove.
	(Target_x86_64::x86_64_info): Initialize
	can_icf_inline_merge_sections.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Likewise.
	* icf.cc (get_section_contents): Correct formatting.
@
text
@d204 1
a204 1
class Target_x86_64 : public Target_freebsd<64, false>
d212 1
a212 1
    : Target_freebsd<64, false>(&x86_64_info),
@


1.127
log
@	* x86_64.cc (check_non_pic): Add gsym parameter.  Change all
	callers.  Don't issue warning about PC32 against locally defined
	symbol.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
a219 14
  // This function should be defined in targets that can use relocation
  // types to determine (implemented in local_reloc_may_be_function_pointer
  // and global_reloc_may_be_function_pointer)
  // if a function's pointer is taken.  ICF uses this in safe mode to only
  // fold those functions whose pointer is defintely not taken.  For x86_64
  // pie binaries, safe ICF cannot be done by looking at relocation types.
  inline bool
  can_check_for_function_pointers() const
  { return !parameters->options().pie(); }

  virtual bool
  can_icf_inline_merge_sections () const
  { return true; }

d336 10
d754 1
@


1.126
log
@	* common.cc (Symbol_table::do_allocate_commons_list): Call
	gold_fallback.
	* errors.cc (Errors::fatal): Adjust call to gold_exit.
	(Errors::fallback): New function.
	(gold_fallback): New function.
	* errors.h (Errors::fallback): New function.
	* gold.cc (gold_exit): Change status parameter to enum; adjust
	all callers.
	(queue_initial_tasks): Call gold_fallback.
	* gold.h: Include cstdlib.
	(Exit_status): New enum type.
	(gold_exit): Change status parameter to enum.
	(gold_fallback): New function.
	* layout.cc (Layout::set_section_offsets): Call gold_fallback.
	(Layout::create_symtab_sections): Likewise.
	(Layout::create_shdrs): Likewise.
	* main.cc (main): Adjust call to gold_exit.
	* output.cc (Output_data_got::add_got_entry): Call gold_fallback.
	(Output_data_got::add_got_entry_pair): Likewise.
	(Output_section::add_input_section): Likewise.
	(Output_section::add_output_section_data): Likewise.
	(Output_segment::set_section_list_addresses): Likewise.
	* x86_64.cc (Output_data_plt_x86_64::add_entry): Likewise.
@
text
@d491 1
a491 1
    check_non_pic(Relobj*, unsigned int r_type);
d1613 3
a1615 1
// error even if the section is not read-only.
d1618 2
a1619 1
Target_x86_64::Scan::check_non_pic(Relobj* object, unsigned int r_type)
d1637 9
a1646 1
    case elfcpp::R_X86_64_PC32:
d1650 10
a1659 2
      object->error(_("requires dynamic reloc which may overflow at runtime; "
		      "recompile with -fPIC"));
d1670 3
a1672 2
      object->error(_("requires unsupported dynamic reloc; "
                      "recompile with -fPIC"));
d1753 1
a1753 1
          this->check_non_pic(object, r_type);
d1837 1
a1837 1
                    this->check_non_pic(object, r_type);
d2158 1
a2158 1
                this->check_non_pic(object, r_type);
d2186 1
a2186 1
                this->check_non_pic(object, r_type);
@


1.125
log
@	* copy-relocs.cc (Copy_relocs::copy_reloc): Call make_copy_reloc
	instead of emit_copy_reloc.
	(Copy_relocs::emit_copy_reloc): Refactor.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* copy-relocs.h (Copy_relocs::emit_copy_reloc): Move to public
	section.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* gold.cc (queue_middle_tasks): Emit old COPY relocations from
	unchanged input files.
	* incremental-dump.cc (dump_incremental_inputs): Print "COPY" flag.
	* incremental.cc (Sized_incremental_binary::do_reserve_layout):
	Reserve BSS space for COPY relocations.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Output_section_incremental_inputs::write_info_blocks): Record
	whether a symbol is copied from a shared object.
	(Sized_incr_dynobj::do_add_symbols): Record COPY relocations.
	* incremental.h (enum Incremental_shlib_symbol_flags): New type.
	(INCREMENTAL_SHLIB_SYM_FLAGS_SHIFT): New constant.
	(Incremental_input_entry_reader::get_output_symbol_index): Add
	is_copy parameter.
	(Incremental_binary::emit_copy_relocs): New function.
	(Incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data member.
	(Sized_incremental_binary::add_copy_reloc): New function.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Copy_reloc): New struct.
	(Sized_incremental_binary::Copy_relocs): New typedef.
	(Sized_incremental_binary::copy_relocs_): New data member.
	* symtab.cc (Symbol_table::add_from_incrobj): Change return type.
	* symtab.h (Symbol_table::add_from_incrobj): Change return type.
	* target.h (Sized_target::emit_copy_reloc): New function.
	* x86_64.cc (Target_x86_64::emit_copy_reloc): New function.
@
text
@d918 2
a919 2
	gold_fatal(_("out of patch space (PLT);"
		     " relink with --incremental-full"));
@


1.124
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@a407 1
  // A target needs to implement this to support incremental linking.
d411 4
d1395 13
@


1.123
log
@	* gold.cc (queue_middle_tasks): Process existing GOT/PLT entries.
	* incremental-dump.cc (dump_incremental_inputs): Mask high-order
	bit when checking got_type.
	* incremental.cc (Sized_incremental_binary::setup_readers):
	Store symbol table and string table locations; initialize bit vector
	of file status flags.
	(Sized_incremental_binary::do_reserve_layout): Set bit flag for
	unchanged files.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::get_symtab_view): Use stored locations.
	(Output_section_incremental_inputs::set_final_data_size): Record
	file index for each input file.
	(Output_section_incremental_inputs::write_got_plt): Store file index
	instead of input entry offset for each GOT entry.
	* incremental.h
	(Incremental_input_entry::Incremental_input_entry): Initialize new
	data member.
	(Incremental_input_entry::set_offset): Store file index.
	(Incremental_input_entry::get_file_index): New function.
	(Incremental_input_entry::file_index_): New data member.
	(Incremental_binary::process_got_plt): New function.
	(Incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data members.
	(Sized_incremental_binary::~Sized_incremental_binary): New destructor.
	(Sized_incremental_binary::set_file_is_unchanged): New function.
	(Sized_incremental_binary::file_is_unchanged): New function.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::file_status_): New data member.
	(Sized_incremental_binary::main_symtab_loc_): New data member.
	(Sized_incremental_binary::main_strtab_loc_): New data member.
	* output.cc (Output_data_got::Got_entry::write): Add case
	RESERVED_CODE.
	(Output_data_got::add_global): Call add_got_entry.
	(Output_data_got::add_global_plt): Likewise.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_global_pair_with_rela): Likewise.
	(Output_data_got::add_local): Call add_got_entry.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_local_pair_with_rela): Likewise.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_section::add_output_section_data): Edit FIXME.
	* output.h
	(Output_section_data_build::Output_section_data_build): New
	constructor with size parameter.
	(Output_data_space::Output_data_space): Likewise.
	(Output_data_got::Output_data_got): Initialize new data member; new
	constructor with size parameter.
	(Output_data_got::add_constant): Call add_got_entry.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(class Output_data_got::Got_entry): Add RESERVED_CODE.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_data_got::free_list_): New data member.
	* target.h (Sized_target::init_got_plt_for_update): New function.
	(Sized_target::register_global_plt_entry): New function.
	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Initialize new data member; call init; add constructor with PLT count.
	(Output_data_plt_x86_64::init): New function.
	(Output_data_plt_x86_64::add_relocation): New function.
	(Output_data_plt_x86_64::reserve_slot): New function.
	(Output_data_plt_x86_64::free_list_): New data member.
	(Target_x86_64::init_got_plt_for_update): New function.
	(Target_x86_64::register_global_plt_entry): New function.
	(Output_data_plt_x86_64::add_entry): Allocate from free list for
	incremental updates.
	(Output_data_plt_x86_64::add_relocation): New function.
	* testsuite/object_unittest.cc (Object_test): Set default options.
@
text
@d88 1
a88 1
  add_local_ifunc_entry(Sized_relobj<64, false>* relobj,
d242 1
a242 1
	            Sized_relobj<64, false>* object,
d256 1
a256 1
	      Sized_relobj<64, false>* object,
d292 1
a292 1
			  Sized_relobj<64, false>* object,
d393 14
d425 1
a425 1
  add_tlsdesc_info(Sized_relobj<64, false>* object, unsigned int r_sym)
d445 1
a445 1
	  Sized_relobj<64, false>* object,
d453 1
a453 1
	   Sized_relobj<64, false>* object,
d462 1
a462 1
			        	Sized_relobj<64, false>* object,
d472 1
a472 1
         	   			 Sized_relobj<64, false>* object,
d481 1
a481 1
    unsupported_reloc_local(Sized_relobj<64, false>*, unsigned int r_type);
d484 1
a484 1
    unsupported_reloc_global(Sized_relobj<64, false>*, unsigned int r_type,
d494 2
a495 1
    reloc_needs_plt_for_ifunc(Sized_relobj<64, false>*, unsigned int r_type);
d644 1
a644 1
			     Sized_relobj<64, false>* relobj,
d658 1
a658 1
		      Sized_relobj<64, false>* object);
d679 1
a679 1
             Sized_relobj<64, false>* object,
d710 1
a710 1
    Tlsdesc_info(Sized_relobj<64, false>* a_object, unsigned int a_r_sym)
d715 1
a715 1
    Sized_relobj<64, false>* object;
d939 3
a941 2
Output_data_plt_x86_64::add_local_ifunc_entry(Sized_relobj<64, false>* relobj,
					      unsigned int local_sym_index)
d1187 1
a1187 1
					  Sized_relobj<64, false>* relobj,
d1280 3
d1286 89
d1442 1
a1442 1
			           Sized_relobj<64, false>* object)
d1583 3
a1585 2
Target_x86_64::Scan::unsupported_reloc_local(Sized_relobj<64, false>* object,
                                             unsigned int r_type)
d1649 3
a1651 2
Target_x86_64::Scan::reloc_needs_plt_for_ifunc(Sized_relobj<64, false>* object,
					       unsigned int r_type)
d1666 1
a1666 1
                           Sized_relobj<64, false>* object,
d1961 4
a1964 3
Target_x86_64::Scan::unsupported_reloc_global(Sized_relobj<64, false>* object,
                                              unsigned int r_type,
                                              Symbol* gsym)
d2002 1
a2002 1
  Sized_relobj<64, false>* ,
d2025 1
a2025 1
  Sized_relobj<64, false>* ,
d2047 1
a2047 1
                            Sized_relobj<64, false>* object,
d2391 1
a2391 1
                                 Sized_relobj<64, false>* object,
d2428 1
a2428 1
                           Sized_relobj<64, false>* object,
d2539 1
a2539 1
  const Sized_relobj<64, false>* object = relinfo->object;
d2787 1
a2787 1
  const Sized_relobj<64, false>* object = relinfo->object;
d3392 1
a3392 1
				       Sized_relobj<64, false>* object,
@


1.122
log
@	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	global symbol map.
	(Sized_incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incr_relobj::do_add_symbols): Add symbols to global symbol map.
	(Sized_incr_relobj::do_relocate): Remap section indices in incremental
	relocations.
	(Sized_incr_dynobj::do_add_symbols): Add symbols to global symbol map.
	(Sized_incr_dynobj::do_for_all_global_symbols): Remove FIXME.
	(Sized_incr_dynobj::do_for_all_local_got_entries): Likewise.
	* incremental.h
	(Incremental_inputs_reader::global_symbol_reader_at_offset): New
	function.
	(Incremental_binary::apply_incremental_relocs): New function.
	(Incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data member.
	(Sized_incremental_binary::add_global_symbol): New function.
	(Sized_incremental_binary::global_symbol): New function.
	(Sized_incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incremental_binary::symbol_map_): New data member.
	* layout.cc (Layout_task_runner::run): Apply incremental relocations.
	* target.h (Sized_target::apply_relocation): New function.
	* target-reloc.h (apply_relocation): New function.
	* x86_64.cc (Target_x86_64::apply_relocation): New function.
@
text
@d56 25
a80 2
  Output_data_plt_x86_64(Symbol_table*, Layout*, Output_data_got<64, false>*,
                         Output_data_space*);
d91 4
d139 8
d192 3
d386 12
d832 4
a835 10
// Create the PLT section.  The ordinary .got section is an argument,
// since we need to refer to the start.  We also create our own .got
// section just for PLT entries.

Output_data_plt_x86_64::Output_data_plt_x86_64(Symbol_table* symtab,
					       Layout* layout,
                                               Output_data_got<64, false>* got,
                                               Output_data_space* got_plt)
  : Output_section_data(8), tlsdesc_rel_(NULL), got_(got), got_plt_(got_plt),
    count_(0), tlsdesc_got_offset_(-1U)
d874 35
a908 5
  // Note that when setting the PLT offset we skip the initial
  // reserved PLT entry.
  gsym->set_plt_offset((this->count_ + 1) * plt_entry_size);

  ++this->count_;
d910 1
a910 6
  section_offset_type got_offset = this->got_plt_->current_data_size();

  // Every PLT entry needs a GOT entry which points back to the PLT
  // entry (this will be changed by the dynamic linker, normally
  // lazily when the function is called).
  this->got_plt_->set_current_data_size(got_offset + 8);
d913 1
a913 10
  if (gsym->type() == elfcpp::STT_GNU_IFUNC
      && gsym->can_use_relative_reloc(false))
    this->rel_->add_symbolless_global_addend(gsym, elfcpp::R_X86_64_IRELATIVE,
					     this->got_plt_, got_offset, 0);
  else
    {
      gsym->set_needs_dynsym_entry();
      this->rel_->add_global(gsym, elfcpp::R_X86_64_JUMP_SLOT, this->got_plt_,
			     got_offset, 0);
    }
d944 17
d1209 75
@


1.121
log
@	PR gold/12324
	* x86_64.cc (Target_x86_64::Scan::check_non_pic): Give an error
	for R_X86_64_32 and R_X86_64_PC32.
	* testsuite/Makefile.am (ver_matching_def.so): Depend on and use
	ver_matching_def_pic.o.
	(ver_matching_def_pic.o): New target.
@
text
@d348 11
d3028 26
@


1.120
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d1332 2
a1333 1
      // These are the relocation types supported by glibc for x86_64.
d1342 4
d1348 6
a1353 1
    case elfcpp::R_X86_64_COPY:
@


1.119
log
@gold/
	* symtab.h (Symbol::NON_PIC_REF): Remove.
	(Symbol::RELATIVE_REF, Symbol::TLS_REF): New Reference_flags.
	(Symbol::FUNCTION_CALL): Renumber.  Reword comment.
	(Symbol::needs_dynamic_reloc): Don't check NON_PIC_REF.
	(Symbol::use_plt_offset): Take a flags argument and pass it
	directly to needs_dynamic_reloc.  Restrict check for undefined
	weak symbols to function calls.
	* arm.cc (Target_arm::Scan::get_reference_flags): New function.
	(Target_arm::Scan::global): Use it.
	(Target_arm::Scan::scan_reloc_for_stub): Likewise.
	(Target_arm::Relocate::relocate): Likewise.
	(Target_arm::Relocate::should_apply_static_reloc): Replace flags
	parameter with an r_type parameter.  Use get_reference_flags
	to get the flags.
	(Target_arm::Relocate::relocate): Update accordingly.
	* i386.cc (Target_i386::Scan::get_reference_flags): New function.
	(Target_i386::Scan::reloc_needs_plt_for_ifunc): Use it.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocate::should_apply_static_reloc): Replace flags
	parameter with an r_type parameter.  Use get_reference_flags
	to get the flags.
	(Target_i386::Relocate::relocate): Update accordingly.
	* powerpc.cc (Target_powerpc::Scan::get_reference_flags): New function.
	(Target_powerpc::Scan::global): Use it.
	(Target_powerpc::Scan::scan_reloc_for_stub): Likewise.
	(Target_powerpc::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Scan::get_reference_flags): New function.
	(Target_sparc::Scan::global): Use it.
	(Target_sparc::Scan::scan_reloc_for_stub): Likewise.
	(Target_sparc::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Scan::get_reference_flags): New function.
	(Target_x86_64::Scan::reloc_needs_plt_for_ifunc): Use it.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
@
text
@d312 1
a312 1
  // Adjust -fstack-split code which calls non-stack-split code.
d3241 1
a3241 1
// compiled with -fstack-split.  The function calls non-stack-split
@


1.118
log
@2010-09-28  Sriraman Tallam  <tmsriram@@google.com>

	* target.h (Target::can_icf_inline_merge_sections): New virtual
	function.
	* x86_64.cc (Target__x86_64::can_icf_inline_merge_sections): New
	virtual function.
	* i386.cc (Target_i386::can_icf_inline_merge_sections): New
	virtual function.
	* icf.cc (get_section_contents): Inline merge sections only when
	target allows it.
@
text
@d365 3
d1242 67
d1370 5
a1374 57
  switch (r_type)
    {
    case elfcpp::R_X86_64_NONE:
    case elfcpp::R_X86_64_GNU_VTINHERIT:
    case elfcpp::R_X86_64_GNU_VTENTRY:
      return false;

    case elfcpp::R_X86_64_64:
    case elfcpp::R_X86_64_32:
    case elfcpp::R_X86_64_32S:
    case elfcpp::R_X86_64_16:
    case elfcpp::R_X86_64_8:
    case elfcpp::R_X86_64_PC64:
    case elfcpp::R_X86_64_PC32:
    case elfcpp::R_X86_64_PC16:
    case elfcpp::R_X86_64_PC8:
    case elfcpp::R_X86_64_PLT32:
    case elfcpp::R_X86_64_GOTPC32:
    case elfcpp::R_X86_64_GOTOFF64:
    case elfcpp::R_X86_64_GOTPC64:
    case elfcpp::R_X86_64_PLTOFF64:
    case elfcpp::R_X86_64_GOT64:
    case elfcpp::R_X86_64_GOT32:
    case elfcpp::R_X86_64_GOTPCREL64:
    case elfcpp::R_X86_64_GOTPCREL:
    case elfcpp::R_X86_64_GOTPLT64:
      return true;

    case elfcpp::R_X86_64_COPY:
    case elfcpp::R_X86_64_GLOB_DAT:
    case elfcpp::R_X86_64_JUMP_SLOT:
    case elfcpp::R_X86_64_RELATIVE:
    case elfcpp::R_X86_64_IRELATIVE:
    case elfcpp::R_X86_64_TPOFF64:
    case elfcpp::R_X86_64_DTPMOD64:
    case elfcpp::R_X86_64_TLSDESC:
      // We will give an error later.
      return false;

    case elfcpp::R_X86_64_TLSGD:
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:
    case elfcpp::R_X86_64_TLSDESC_CALL:
    case elfcpp::R_X86_64_TLSLD:
    case elfcpp::R_X86_64_DTPOFF32:
    case elfcpp::R_X86_64_DTPOFF64:
    case elfcpp::R_X86_64_GOTTPOFF:
    case elfcpp::R_X86_64_TPOFF32:
      gold_error(_("%s: unsupported TLS reloc %u for IFUNC symbol"),
		 object->name().c_str(), r_type);
      return false;

    case elfcpp::R_X86_64_SIZE32:
    case elfcpp::R_X86_64_SIZE64:
    default:
      // We will give an error later.
      return false;
    }
d1800 1
a1800 1
        if (gsym->needs_dynamic_reloc(Symbol::ABSOLUTE_REF))
d1857 1
a1857 4
        int flags = Symbol::NON_PIC_REF;
        if (gsym->is_func())
          flags |= Symbol::FUNCTION_CALL;
        if (gsym->needs_dynamic_reloc(flags))
d2260 1
a2260 4
      && gsym->use_plt_offset(r_type == elfcpp::R_X86_64_PC64
			      || r_type == elfcpp::R_X86_64_PC32
			      || r_type == elfcpp::R_X86_64_PC16
			      || r_type == elfcpp::R_X86_64_PC8))
@


1.117
log
@	* x86_64.cc (Target_x86_64::saw_tls_block_reloc_): Remove member.
	(Target_x86_64::Relocate::relocate_tls): Replace check for
	saw_tls_block_reloc_ with test for executable section.
@
text
@d192 4
@


1.116
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d423 1
a423 1
      : skip_call_tls_get_addr_(false), saw_tls_block_reloc_(false)
a513 6

    // This is set if we see a relocation which could load the address
    // of the TLS block.  Whether we see such a relocation determines
    // how we handle the R_X86_64_DTPOFF32 relocation, which is used
    // in debugging sections.
    bool saw_tls_block_reloc_;
d2489 2
d2497 1
a2497 1
  const tls::Tls_optimization optimized_type
d2502 10
a2511 1
      this->saw_tls_block_reloc_ = true;
d2562 5
a2566 1
      this->saw_tls_block_reloc_ = true;
d2629 5
a2633 1
      this->saw_tls_block_reloc_ = true;
d2658 11
a2668 12
      if (optimized_type == tls::TLSOPT_TO_LE)
        {
          // This relocation type is used in debugging information.
          // In that case we need to not optimize the value.  If we
          // haven't seen a TLSLD reloc, then we assume we should not
          // optimize this reloc.
          if (this->saw_tls_block_reloc_)
	    {
              gold_assert(tls_segment != NULL);
              value -= tls_segment->memsz();
	    }
        }
d2673 6
a2678 9
      if (optimized_type == tls::TLSOPT_TO_LE)
        {
          // See R_X86_64_DTPOFF32, just above, for why we test this.
          if (this->saw_tls_block_reloc_)
	    {
	      gold_assert(tls_segment != NULL);
	      value -= tls_segment->memsz();
	    }
        }
@


1.115
log
@	PR 10893
	* i386.cc (class Output_data_plt_i386): Update declarations.
	Define Global_ifunc and Local_ifunc types.  Add global_ifuncs_ and
	local_ifuncs_ fields.
	(Target_i386::do_plt_section_for_global): New function.
	(Target_i386::do_plt_section_for_local): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Add symtab
	parameter; change all callers.  Initialize global_ifuncs_ and
	local_ifuncs_.  If doing a static link define __rel_iplt_start and
	__rel_iplt_end.
	(Output_data_plt_i386::add_entry): Handle IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): New function.
	(Output_data_plt_i386::do_write): Fix GOT entries for IFUNC
	symbols.
	(Target_i386::make_plt_section): New function, broken out of
	make_plt_entry.  Set sh_info field of .rel.plt to point to .plt.
	(Target_i386::make_plt_entry): Call make_plt_section.
	(Target_i386::make_local_ifunc_plt_entry): New function.
	(Target_i386::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_i386::Scan::local): Handle IFUNC symbols.  Add
	R_386_IRELATIVE to switch.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocatable_size_for_reloc): Add R_386_IRELATIVE to
	switch.
	* x86_64.cc (class Output_data_plt_x86_64): Update declarations.
	(Target_x86_64::do_plt_section_for_global): New function.
	(Target_x86_64::do_plt_section_for_local): New function.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Add symtab
	parameter; change all callers.  If doing a static link define
	__rela_iplt_start and __rela_iplt_end.
	(Output_data_plt_x86_64::add_entry): Handle IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): New function.
	(Target_x86_64::make_plt_section): Set sh_info field of .rel.plt
	to point to .plt.
	(Target_x86_64::make_local_ifunc_plt_entry): New function.
	(Target_x86_64::Scan::check_non_pic): Add R_X86_64_IRELATIVE to
	switch.
	(Target_x86_64::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_x86_64::Scan::local): Handle IFUNC symbols.  Add
	R_X86_64_IRELATIVE to switch.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocatable_size_for_reloc): Add R_X86_64_IRELATIVE to
	switch.
	* target.h (class Target): Add plt_section_for_global and
	plt_section_for_local functions.  Add do_plt_section_for_global
	and do_plt_section_for_local virtual functions.
	* symtab.h (Symbol::needs_plt_entry): Handle IFUNC symbol.  Add
	clarifying comments.
	(Symbol::use_plt_offset): Handle IFUNC symbol.
	* object.cc (Sized_relobj::Sized_relobj): Initialize
	local_plt_offsets_.
	(Sized_relobj::local_has_plt_offset): New function.
	(Sized_relobj::local_plt_offset): New function.
	(Sized_relobj::set_local_plt_offset): New function.
	(Sized_relobj::do_count): Handle IFUNC symbol.
	* object.h (class Symbol_value): Add is_ifunc_symbol_ field.  Take
	a bit away from input_shndx_ field.  Add set_is_func_symbol and
	is_ifunc_symbol functions.
	(class Sized_relobj): Update declarations.  Remove Tls_got_entry
	and Local_tls_got_offsets.  Define Local_plt_offsets.  Add
	local_plt_offsets_ field.
	(Sized_relobj::clear_local_symbols): Clear local_plt_offsets_.
	* output.h (class Output_section_data): Add non-const
	output_section function.
	(class Output_data_got): Update declarations.
	(class Output_data_got::Got_entry): Add use_plt_offset_ field.
	Add use_plt_offset parameter to global and local constructors.
	Change all callers.  Change local_sym_index_ field to 31 bits.
	Change GSYM_CODE and CONSTANT_CODE accordingly.
	* output.cc (Output_data_reloc_base::do_adjust_output_section): If
	doing a static link don't set sh_link field.
	(Output_data_got::Got_entry::write): Use PLT offset if
	appropriate.
	(Output_data_got::add_global_plt): New function.
	(Output_data_got::add_local_plt): New function.
	* target-reloc.h (relocate_section): Handle IFUNC symbol.
	* defstd.cc (in_section): Remove entries for __rel_iplt_start,
	__rel_iplt_end, __rela_iplt_start, and __rela_iplt_end.
	* configure.ac: Set IFUNC automake conditional for glibc >= 2.11.
	* testsuite/Makefile.am: Add a bunch of IFUNC tests, all within
	IFUNC conditional.
	* testsuite/ifunc-sel.h: New file.
	* testsuite/ifuncmain1.c: New file.
	* testsuite/ifuncmain1vis.c: New file.
	* testsuite/ifuncmod1.c: New file.
	* testsuite/ifuncdep2.c: New file.
	* testsuite/ifuncmain2.c: New file.
	* testsuite/ifuncmain3.c: New file.
	* testsuite/ifuncmod3.c: New file.
	* testsuite/ifuncmain4.c: New file.
	* testsuite/ifuncmain5.c: New file.
	* testsuite/ifuncmod5.c: New file.
	* testsuite/ifuncmain6pie.c: New file.
	* testsuite/ifuncmod6.c: New file.
	* testsuite/ifuncmain7.c: New file.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d695 1
a695 1
Target_x86_64::do_new_output_section(Output_section *os) const
d2020 1
a2020 1
		Reloc_section *rt = target->rela_tlsdesc_section(layout);
@


1.114
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_GOT_PLT.

gold/ChangeLog:

	* arm.cc (Target_arm::got_size): Add const.
	(Target_arm::got_entry_count): New function.
	(Target_arm::plt_entry_count): New function.
	(Target_arm::first_plt_entry_offset): New function.
	(Target_arm::plt_entry_size): New function.
	(Output_data_plt_arm::entry_count): New function.
	(Output_data_plt_arm::first_plt_entry_offset): New function.
	(Output_data_plt_arm::get_plt_entry_size): New function.
	* i386.cc (Target_i386::got_size): Add const.
	(Target_i386::got_entry_count): New function.
	(Target_i386::plt_entry_count): New function.
	(Target_i386::first_plt_entry_offset): New function.
	(Target_i386::plt_entry_size): New function.
	(Output_data_plt_i386::entry_count): New function.
	(Output_data_plt_i386::first_plt_entry_offset): New function.
	(Output_data_plt_i386::get_plt_entry_size): New function.
	* incremental-dump.cc (dump_incremental_inputs): Adjust call to
	find_incremental_inputs_sections.  Dump incremental_got_plt section.
	* incremental.cc: Include target.h.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Add
	parameter.  Adjust all callers.  Find incremental_got_plt section.
	(Incremental_inputs::create_data_sections): Create incremental_got_plt
	section.
	(Output_section_incremental_inputs::set_final_data_size): Calculate
	size of incremental_got_plt section.
	(Output_section_incremental_inputs::do_write): Write the
	incremental_got_plt section.
	(Got_plt_view_info): New struct.
	(Local_got_offset_visitor): New class.
	(Global_got_offset_visitor): New class.
	(Global_symbol_visitor_got_plt): New class.
	(Output_section_incremental_inputs::write_got_plt): New function.
	* incremental.h (Incremental_binary::find_incremental_inputs_sections):
	Add parameter.  Adjust all callers.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Incremental_inputs::got_plt_section): New function.
	(Incremental_inputs::got_plt_section_): New data member.
	(Incremental_got_plt_reader): New class.
	* layout.cc (Layout::create_incremental_info_sections): Add the
	incremental_got_plt section.
	* object.h (Got_offset_list::get_list): New function.
	(Got offset_list::for_all_got_offsets): New function.
	(Sized_relobj::local_got_offset_list): New function.
	* powerpc.cc (Target_powerpc::got_size): Add const.
	(Target_powerpc::got_entry_count): New function.
	(Target_powerpc::plt_entry_count): New function.
	(Target_powerpc::first_plt_entry_offset): New function.
	(Target_powerpc::plt_entry_size): New function.
	(Output_data_plt_powerpc::entry_count): New function.
	(Output_data_plt_powerpc::first_plt_entry_offset): New function.
	(Output_data_plt_powerpc::get_plt_entry_size): New function.
	* sparc.cc (Target_sparc::got_size): Add const.
	(Target_sparc::got_entry_count): New function.
	(Target_sparc::plt_entry_count): New function.
	(Target_sparc::first_plt_entry_offset): New function.
	(Target_sparc::plt_entry_size): New function.
	(Output_data_plt_sparc::entry_count): New function.
	(Output_data_plt_sparc::first_plt_entry_offset): New function.
	(Output_data_plt_sparc::get_plt_entry_size): New function.
	* symtab.h (Symbol::got_offset_list): New function.
	(Symbol_table::for_all_symbols): New function.
	* target.h (Sized_target::got_entry_count): New function.
	(Sized_target::plt_entry_count): New function.
	(Sized_target::plt_entry_size): New function.
	* x86_64.cc (Target_x86_64::got_size): Add const.
	(Target_x86_64::got_entry_count): New function.
	(Target_x86_64::plt_entry_count): New function.
	(Target_x86_64::first_plt_entry_offset): New function.
	(Target_x86_64::plt_entry_size): New function.
	(Output_data_plt_x86_64::entry_count): New function.
	(Output_data_plt_x86_64::first_plt_entry_offset): New function.
	(Output_data_plt_x86_64::get_plt_entry_size): New function.
@
text
@d49 109
a157 1
class Output_data_plt_x86_64;
d299 9
d411 3
d564 6
a769 105
// A class to handle the PLT data.

class Output_data_plt_x86_64 : public Output_section_data
{
 public:
  typedef Output_data_reloc<elfcpp::SHT_RELA, true, 64, false> Reloc_section;

  Output_data_plt_x86_64(Layout*, Output_data_got<64, false>*,
                         Output_data_space*);

  // Add an entry to the PLT.
  void
  add_entry(Symbol* gsym);

  // Add the reserved TLSDESC_PLT entry to the PLT.
  void
  reserve_tlsdesc_entry(unsigned int got_offset)
  { this->tlsdesc_got_offset_ = got_offset; }

  // Return true if a TLSDESC_PLT entry has been reserved.
  bool
  has_tlsdesc_entry() const
  { return this->tlsdesc_got_offset_ != -1U; }

  // Return the GOT offset for the reserved TLSDESC_PLT entry.
  unsigned int
  get_tlsdesc_got_offset() const
  { return this->tlsdesc_got_offset_; }

  // Return the offset of the reserved TLSDESC_PLT entry.
  unsigned int
  get_tlsdesc_plt_offset() const
  { return (this->count_ + 1) * plt_entry_size; }

  // Return the .rela.plt section data.
  const Reloc_section*
  rela_plt() const
  { return this->rel_; }

  // Return where the TLSDESC relocations should go.
  Reloc_section*
  rela_tlsdesc(Layout*);

  // Return the number of PLT entries.
  unsigned int
  entry_count() const
  { return this->count_; }

  // Return the offset of the first non-reserved PLT entry.
  static unsigned int
  first_plt_entry_offset()
  { return plt_entry_size; }

  // Return the size of a PLT entry.
  static unsigned int
  get_plt_entry_size()
  { return plt_entry_size; }

 protected:
  void
  do_adjust_output_section(Output_section* os);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** PLT")); }

 private:
  // The size of an entry in the PLT.
  static const int plt_entry_size = 16;

  // The first entry in the PLT.
  // From the AMD64 ABI: "Unlike Intel386 ABI, this ABI uses the same
  // procedure linkage table for both programs and shared objects."
  static unsigned char first_plt_entry[plt_entry_size];

  // Other entries in the PLT for an executable.
  static unsigned char plt_entry[plt_entry_size];

  // The reserved TLSDESC entry in the PLT for an executable.
  static unsigned char tlsdesc_plt_entry[plt_entry_size];

  // Set the final size.
  void
  set_final_data_size();

  // Write out the PLT data.
  void
  do_write(Output_file*);

  // The reloc section.
  Reloc_section* rel_;
  // The TLSDESC relocs, if necessary.  These must follow the regular
  // PLT relocs.
  Reloc_section* tlsdesc_rel_;
  // The .got section.
  Output_data_got<64, false>* got_;
  // The .got.plt section.
  Output_data_space* got_plt_;
  // The number of PLT entries.
  unsigned int count_;
  // Offset of the reserved TLSDESC_GOT entry when needed.
  unsigned int tlsdesc_got_offset_;
};

d774 2
a775 1
Output_data_plt_x86_64::Output_data_plt_x86_64(Layout* layout,
d785 18
d832 10
a841 3
  gsym->set_needs_dynsym_entry();
  this->rel_->add_global(gsym, elfcpp::R_X86_64_JUMP_SLOT, this->got_plt_,
			 got_offset, 0);
d848 24
d1042 1
a1042 1
      this->plt_ = new Output_data_plt_x86_64(layout, this->got_,
d1048 4
d1078 16
d1266 1
d1295 66
d1374 8
d1400 5
a1404 5
          rela_dyn->add_local_relative(object, r_sym,
                                       elfcpp::R_X86_64_RELATIVE,
                                       output_section, data_shndx,
                                       reloc.get_r_offset(),
                                       reloc.get_r_addend());
d1475 10
a1484 1
        if (got->add_local(object, r_sym, GOT_TYPE_STANDARD))
d1493 7
a1499 3
                  rela_dyn->add_local_relative(
                      object, r_sym, elfcpp::R_X86_64_RELATIVE, got,
                      object->local_got_offset(r_sym, GOT_TYPE_STANDARD), 0);
d1520 1
d1754 5
d1791 19
d1814 5
a1818 4
                rela_dyn->add_global_relative(gsym, elfcpp::R_X86_64_RELATIVE,
                                              output_section, object,
                                              data_shndx, reloc.get_r_offset(),
                                              reloc.get_r_addend());
d1872 7
a1878 1
          got->add_global(gsym, GOT_TYPE_STANDARD);
d1884 5
a1888 3
            if (gsym->is_from_dynobj()
                || gsym->is_undefined()
                || gsym->is_preemptible())
d1893 22
a1914 4
                if (got->add_global(gsym, GOT_TYPE_STANDARD))
                  rela_dyn->add_global_relative(
                      gsym, elfcpp::R_X86_64_RELATIVE, got,
                      gsym->got_offset(GOT_TYPE_STANDARD), 0);
d1957 1
d2242 3
a2244 1
  // Pick the value to use for symbols defined in shared objects.
d2256 10
a2266 1
  const Sized_relobj<64, false>* object = relinfo->object;
d2442 1
d3036 1
@


1.113
log
@elfcpp:/
	* i386.h (R_386_IRELATIVE): Define.
	* powerpc.h (R_POWERPC_IRELATIVE): Define.
	(R_PPC_RELAX32, R_PPC_RELAX32PC): Don't define.
	(R_PPC_RELAX32_PLT, R_PPC_RELAX32PC_PLT): Don't define.
	* sparc.h (R_SPARC_IRELATIVE): Define.
	* x86_64.h (R_X86_64_IRELATIVE): Define.
	(R_X86_64_GNU_VTINHERIT): Rename from R_386_GNU_VTINHERIT.
	(R_X86_64_GNU_VTENTRY): Rename from R_386_GNU_VTENTRY.
gold:/
	* x86_64.cc (Target_x86_64::Scan::local): Use
	R_X86_64_GNU_VTINHERIT instead of R_386_GNU_VTINHERIT and
	R_X86_64_GNU_VTENTRY instead of R_386_GNU_VTENTRY.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocatable_size_for_reloc::get_size_for_reloc):
	Likewise.
@
text
@d200 1
a200 1
  got_size()
d206 21
d490 4
d687 15
d1003 26
@


1.112
log
@2010-08-03  Ian Lance Taylor  <iant@@google.com>

	PR 11805
	* layout.h (enum Output_section_order): Define.
	(class Layout): Update declarations.
	* layout.cc (Layout::get_output_section): Add order parameter.
	Remove is_interp, is_dynamic_linker_section, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.  Set order.
	(Layout::default_section_order): New function.
	(Layout::layout_eh_frame): Call add_output_section_to_nonload.
	* output.cc (Output_section::Output_section): Initialize order_.
	Don't initialize deleted fields.
	(Output_segment::Output_segment): Don't initialize deleted
	fields.
	(Output_segment::add_output_section_to_load): New function
	replacing add_output_section.  Change all callers to call this or
	add_output_section_to_nonload.
	(Output_segment::add_output_section_to_nonload): New function.
	(Output_segment::remove_output_section): Rewrite.
	(Output_segment::add_initial_output_data): Likewise.
	(Output_segment::has_any_data_sections): Likewise.
	(Output_segment::is_first_section_relro): Likewise.
	(Output_segment::maximum_alignment): Likewise.
	(Output_segment::has_dynamic_reloc): New function replacing
	dynamic_reloc_count.  Change all callers.
	(Output_segment::has_dynamic_reloc_list): New function replacing
	dynamic_reloc_count_list.  Change all callers.
	(Output_segment::set_section_addresses): Rewrite.
	(Output_segment::set_offset): Rewrite.
	(Output_segment::find_first_and_last_list): Remove.
	(Output_segment::set_tls_offsets): Rewrite.
	(Output_segment::first_section_load_address): Likewise.
	(Output_segment::output_section_count): Likewise.
	(Output_segment::section_with_lowest_load_address): Likewise.
	(Output_segment::write_section_headers): Likewise.
	(Output_segment::print_sections_to_map): Likewise.
	* output.h (class Output_data): Remove dynamic_reloc_count_
	field.  Add has_dynamic_reloc_ field.  Make bools into bitfields.
	(Output_data::add_dynamic_reloc): Rewrite.
	(Output_data::has_dynamic_reloc): New function.
	(Output_data::dynamic_reloc_count): Remove.
	(class Output_section): Add order_ field.  Remvoe is_relro_local_,
	is_last_relro_, is_first_non_relro_, is_interp_,
	is_dynamic_linker_section_ fields.  Add order and set_order
	functions.  Remove is_relro_local, set_is_relro_local,
	is_last_relro, set_is_last_relro, is_first_non_relro,
	set_is_first_non_relro functions, is_interp, set_is_interp,
	is_dynamic_linker_section, and set_is_dynamic_linker_section
	functions.
	(class Output_segment): Change Output_data_list from std::list to
	std:;vector.  Add output_lists_ field.  Remove output_data_ and
	output_bss_ fields.  Update declarations.
@
text
@d1153 2
a1154 2
    case elfcpp::R_386_GNU_VTINHERIT:
    case elfcpp::R_386_GNU_VTENTRY:
d1511 2
a1512 2
    case elfcpp::R_386_GNU_VTINHERIT:
    case elfcpp::R_386_GNU_VTENTRY:
d1995 2
a1996 2
    case elfcpp::R_386_GNU_VTINHERIT:
    case elfcpp::R_386_GNU_VTENTRY:
d2683 2
a2684 2
    case elfcpp::R_386_GNU_VTINHERIT:
    case elfcpp::R_386_GNU_VTENTRY:
@


1.111
log
@	* i386.cc (class Target_i386): Add got_tlsdesc_ field.
	(Target_i386::Target_i386):: Initialize got_tlsdesc_.
	(Target_i386::got_tlsdesc_section): New function.
	(Target_i386::got_section): Create space for GOT entries for
	TLSDESC relocations.
	(Target_i386::Scan::local): Use TLSDESC GOT for unoptimized
	R_386_TLS_GOTDESC.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate_tls): Adjust GOT offset when
	using TLSDESC GOT.
	* x86_64.cc (class Target_x86_64): Add got_tlsdesc_ field.
	(Target_x86_64::Target_x86_64):: Initialize got_tlsdesc_.
	(Target_x86_64::got_tlsdesc_section): New function.
	(Target_x86_64::got_section): Create space for GOT entries for
	TLSDESC relocations.
	(Target_x86_64::Scan::local): Use TLSDESC GOT for unoptimized
	R_386_TLS_GOTDESC.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate_tls): Adjust GOT offset when
	using TLSDESC GOT.
@
text
@d564 2
a565 1
				      this->got_, false, true, true, false);
d571 2
a572 2
				      this->got_plt_, false, false, false,
				      true);
d596 2
a597 2
				      this->got_tlsdesc_, false, false, false,
				      true);
d613 2
a614 2
				      elfcpp::SHF_ALLOC, this->rela_dyn_, true,
				      false, false, false);
d721 2
a722 2
				  elfcpp::SHF_ALLOC, this->rel_, true,
				  false, false, false);
d772 1
a772 1
				      true, false, false, false);
d936 1
a936 1
				      this->plt_, false, false, false, false);
@


1.110
log
@	* arm.cc (Target_arm<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* i386.cc (Target_i386<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* x86_64.cc (Target_x86_64<big_endian>::gc_process_relocs): Add template
	parameter to the call to gold::gc_process_relocs.
	* powerpc.cc (Target_powerpc<big_endian>::gc_process_relocs): Add
	template parameter to the call to gold::gc_process_relocs.
	* sparc.cc (Target_sparc<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* gc.h (get_embedded_addend_size): New function.
	(gc_process_relocs): Save the size of the reloc for use by ICF.
	* icf.cc (get_section_contents): Get the addend from the text section
	for SHT_REL relocation sections.
	* icf.h (Icf::Reloc_addend_size_info): New typedef.
	(Icf::Reloc_info): Add new member reloc_addend_size_info.
	* int_encoding.h (read_from_pointer): New overloaded function.
	* testsuite/Makefile.am (icf_sht_rel_addend_test): New test.
	* testsuite/icf_sht_rel_addend_test.sh: New file.
	* testsuite/icf_sht_rel_addend_test_1.cc: New file.
	* testsuite/icf_sht_rel_addend_test_2.cc: New file.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d67 3
a69 2
      got_(NULL), plt_(NULL), got_plt_(NULL), global_offset_table_(NULL),
      rela_dyn_(NULL), copy_relocs_(elfcpp::R_X86_64_COPY), dynbss_(NULL),
d407 8
d498 2
d588 9
d1329 7
a1335 3
	        // Generate a double GOT entry with an R_X86_64_TLSDESC reloc.
                Output_data_got<64, false>* got
                    = target->got_section(symtab, layout);
d1714 7
a1720 3
	        // Create a double GOT entry with an R_X86_64_TLSDESC reloc.
                Output_data_got<64, false>* got
                    = target->got_section(symtab, layout);
d2260 10
a2269 1
          unsigned int got_offset;
d2273 1
a2273 1
              got_offset = gsym->got_offset(got_type) - target->got_size();
d2279 2
a2280 2
              got_offset = (object->local_got_offset(r_sym, got_type)
                            - target->got_size());
@


1.109
log
@	* output.h (Output_section_lookup_maps::add_merge_section):
	Correct check of whether value was inserted.
	(Output_section_lookup_maps::add_merge_input_section): Likewise.
	(Output_section_lookup_maps::add_relaxed_input_section):
	Likewise.
	* arm.cc (Target_arm::got_section): Remove used local os.
	* i386.cc (Target_i386::got_section): Likewise.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* sparc.cc (Target_sparc::got_section): Likewise.
	(Target_sparc::relocate): Remove unused local have_got_offset.
	* powerpc.cc (Target_powerpc::relocate): Likewise.
@
text
@d1784 2
a1785 1
                           Target_x86_64::Scan>(
@


1.108
log
@2010-04-18  Sriraman Tallam  <tmsriram@@google.com>

	* icf.cc (get_section_contents): Check for preemptible functions.
	Ignore addend when appropriate.
	* symtab.cc (should_add_dynsym_entry): Add new parameter.  Check for
	section folded.
	(add_from_relobj): Check for section folded.
	(set_dynsym_indexes): Fix call to should_add_dynsym_entry.
	* symtab.h (should_add_dynsym_entry): Add new parameter.
	* target-reloc.h (scan_relocs): Check for section folded.
	* x86_64.cc (Target_x86_64::Scan::possible_function_pointer_reloc):
	Check reloc types for function pointers in shared objects.
	* testsuite/Makefile.am (icf_virtual_function_folding_test): New test
	case.
	(icf_preemptible_functions_test): New test case.
	(icf_string_merge_test): New test case.
	* testsuite.Makefile.in: Regenerate.
	* testsuite/icf_safe_so_test.sh: Change to not fold foo_glob and
	bar_glob.  Refactor code.
	* testsuite/icf_preemptible_functions_test.cc: New file.
	* testsuite/icf_preemptible_functions_test.sh: New file.
	* testsuite/icf_string_merge_test.cc: New file.
	* testsuite/icf_string_merge_test.sh: New file.
	* testsuite/icf_virtual_function_folding_test.cc: New file.
	* testsuite/icf_virtual_function_folding_test.sh: New file.
@
text
@d550 4
a553 6
      Output_section* os;
      os = layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
					   (elfcpp::SHF_ALLOC
					    | elfcpp::SHF_WRITE),
					   this->got_, false, true, true,
					   false);
d556 5
a560 5
      os = layout->add_output_section_data(".got.plt", elfcpp::SHT_PROGBITS,
					   (elfcpp::SHF_ALLOC
					    | elfcpp::SHF_WRITE),
					   this->got_plt_, false, false,
					   false, true);
@


1.107
log
@2010-02-12  Sriraman Tallam  <tmsriram@@google.com>

	* arm.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* sparc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* powerpc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* i386.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* x86_64.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	(Scan::possible_function_pointer_reloc): New function.
	(Target_x86_64::can_check_for_function_pointers): New function.
	* gc.h (gc_process_relocs): Scan relocation types to determine if
	function pointers were taken for targets that support it.
	* icf.cc (Icf::find_identical_sections): Include functions for
	folding in safe ICF whose pointer is not taken.
	* icf.h (Secn_fptr_taken_set): New typedef.
	(fptr_section_id_): New member.
	(section_has_function_pointers): New function.
	(set_section_has_function_pointers): New function.
	(check_section_for_function_pointers): New function.
	* options.h: Fix comment for safe ICF option.
	* target.h (can_check_for_function_pointers): New function.
	* testsuite/Makefile.am: Add icf_safe_so_test test case.
	Modify icf_safe_test for X86-64.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/icf_safe_so_test.cc: New file.
	* testsuite/icf_safe_so_test.sh: New file.
	* testsuite/icf_safe_test.cc (kept_func_3): New function.
	(main): Change to take pointer to function kept_func_3.
	* testsuite/icf_safe_test.sh (arch_specific_safe_fold): Check if safe
	folding is done correctly for X86-64.
@
text
@d1401 1
a1401 2
// Returns true if this relocation type could be that of a function pointer
// only if the target is not position-independent code.
a1404 3
  if (parameters->options().shared())
    return false;

d1412 5
@


1.106
log
@	* i386.cc (Relocate::relocate_tls): A local symbol is final if not
	shared, not if not position independent.
	* x86_64.cc (Relocate::relocate_tls): Likewise.
	* testsuite/Makefile.am (check_PROGRAMS): Add tls_pie_pic_test.
	(tls_pie_pic_test): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d42 1
d73 10
d238 20
d269 3
d1401 70
@


1.105
log
@	* output.h (Output_data_dynamic::add_section_size): New method
	that takes two Output_data objects.
	(Output_data_dynamic::Dynamic_entry): Create storage for secondary
	entry param.  Handle it in initializers.
	* output.cc (Output_data_dynamic::Dynamic_entry::write): For
	DYNAMIC_SECTION_SIZE, add in second object size if non-NULL.
	* layout.h (Layout::add_target_dynamic_tags): Add dynrel_includes_plt
	arg.
	* layout.cc (Layout::add_target_dynamic_tags): If dynrel_includes_plt,
	and .rela.plt exists, set DT_REL{,A}SZ to sum of .rela.dyn and .rela.plt
	* arm.cc (Target_arm::do_finalize_sections): Update to pass false
	for dynrel_includes_plt.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::make_plt_entry): Force .rela.dyn to be output
	before .rela.plt
	(Target_sparc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt.
	* powerpc.cc (Target_powerpc::make_plt_entry): Force .rela.dyn to be
	output before .rela.plt
	(Target_powerpc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt when 32-bit.
@
text
@d2056 1
a2056 1
			 ? !parameters->options().output_is_position_independent()
@


1.104
log
@	PR 10287
	PR 11063
	* i386.cc (class Target_i386): Change return type of plt_section
	to be non-const.
	(class Output_data_plt_i386): Add tls_desc_rel_ field.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize
	tls_desc_rel_ field.
	(Output_data_plt_i386::rel_tls_desc): New function.
	(Target_i386::rel_tls_desc_section): New function.
	(Target_i386::Scan::local): Rewrite R_386_TLS_GOTDESC handling.
	(Target_i386::Scan::global): For R_386_TLS_GOTDESC put
	R_386_TLS_DESC reloc in rel_tls_desc_section.
	* x86_64.cc (class Target_x86_64): Add tlsdesc_reloc_info_ field.
	Define struct Tlsdesc_info.
	(Target_x86_64::Target_x86_64): Initialize tlsdesc_reloc_info_.
	(Target_x86_64::do_reloc_symbol_index): New function.
	(Target_x86_64::add_tlsdesc_info): New function.
	(class Output_data_plt_x86_64): Add tlsdesc_rel_ field.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Initialize
	tlsdesc_rel_ field.
	(Output_data_plt_x86_64::rela_plt): Rename from rel_plt.  Change
	all callers.
	(Output_data_plt_x86_64::rela_tlsdesc): New function.
	(Target_x86_64::rela_tlsdesc_section): New function.
	(Target_x86_64::Scan::local): Rewrite R_X86_64_GOTPC32_TLSDESC
	handling.
	(Target_x86_64::Scan::global): For R_X86_64_GOTPC32_TLSDESC put
	(Target_x86_64::do_reloc_addend): New function.
	R_X86_64_TLSDESC reloc in rela_tlsdesc_section.
	* output.h (class Output_reloc) [SHT_REL]: Add new constructor
	declarations.  Define TARGET_CODE.  Add arg field to u1_ union.
	(Output_reloc::type): New function.
	(Output_reloc::is_local_section_symbol): Check for TARGET_CODE.
	(Output_reloc::is_target_specific): New function.
	(Output_reloc::target_arg): New function.
	(class Output_reloc) [SHT_RELA]: Add four new constructors for
	absolute relocs and target specific relocs.
	(class Output_data_reloc) [SHT_REL]: Add add_absolute and
	add_target_specific.
	(class Output_data_reloc) [SHT_RELA]: Likewise.
	* output.cc (Output_reloc::Output_reloc): Add four new versions
	for absolute relocs and target specific relocs.
	(Output_reloc::set_needs_dynsym_index): Add TARGET_CODE case.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Check that local_sym_index_
	is not TARGET_CODE or 0.
	(Output_reloc::symbol_value): Likewise.
	(Output_reloc::write) [SHT_RELA]: Call target for target specific
	reloc.
	* target.h (class Target): Add reloc_symbol_index and reloc_addend
	functions.  Add do_reloc_symbol_index and do_reloc_addend virtual
	functions.
	* layout.cc (add_target_dynamic_tags): Use output section for
	DT_PLTRELSZ and DT_JMPREL.
@
text
@d1744 1
a1744 1
				  this->rela_dyn_, true);
@


1.103
log
@	* output.h (class Output_data): Add const version of
	output_section and do_output_section.
	(class Output_section_data): Add const version of
	do_output_section.
	(class Output_section): Likewise.
	* layout.cc (Layout::add_target_dynamic_tags): New function.
	* layout.h (class Layout): Update declarations.
	* arm.cc (Target_arm::do_finalize_sections): Use
	add_target_dynamic_tags.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d68 2
a69 1
      got_mod_index_offset_(-1U), tls_base_symbol_defined_(false)
d165 14
d194 8
d405 4
d434 15
d465 4
d600 1
a600 1
  // Return the .rel.plt section data.
d602 1
a602 1
  rel_plt() const
d605 4
d643 3
d663 2
a664 2
  : Output_section_data(8), got_(got), got_plt_(got_plt), count_(0),
    tlsdesc_got_offset_(-1U)
d708 18
d887 8
d1281 15
a1295 12
		unsigned int shndx = lsym.get_st_shndx();
		bool is_ordinary;
		shndx = object->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
		if (!is_ordinary)
		  object->error(_("local symbol %u has bad shndx %u"),
			      r_sym, shndx);
                else
		  got->add_local_pair_with_rela(object, r_sym,
						shndx,
						GOT_TYPE_TLS_DESC,
						target->rela_dyn_section(layout),
						elfcpp::R_X86_64_TLSDESC, 0);
d1590 2
a1591 2
                got->add_global_pair_with_rela(gsym, GOT_TYPE_TLS_DESC,
                                               target->rela_dyn_section(layout),
d1742 1
a1742 1
				  : this->plt_->rel_plt());
d2743 19
@


1.102
log
@	PR 10450
	* i386.cc (class Target_i386): Initialize global_offset_table_ in
	constructor.  Add global_offset_table_ field.
	(Target_i386::got_section): Set global_offset_table_.
	(Target_i386::do_finalize_sections): Set global_offset_table_
	size.
	* x86_64.cc (class Target_x86_64): Initialize global_offset_table_
	in constructor.  Add global_offset_table_ field.
	(Target_x86_64::got_section): Set global_offset_table_.
	(Target_x86_64::do_finalize_sections): Set global_offset_table_
	size.
@
text
@d1658 6
a1667 4
      if (this->got_plt_ != NULL
	  && this->got_plt_->output_section() != NULL)
	odyn->add_section_address(elfcpp::DT_PLTGOT, this->got_plt_);

d1669 2
a1670 29
	  && this->plt_->output_section() != NULL)
	{
	  const Output_data* od = this->plt_->rel_plt();
	  odyn->add_section_size(elfcpp::DT_PLTRELSZ, od);
	  odyn->add_section_address(elfcpp::DT_JMPREL, od);
	  odyn->add_constant(elfcpp::DT_PLTREL, elfcpp::DT_RELA);
	  if (this->plt_->has_tlsdesc_entry())
	    {
              unsigned int plt_offset = this->plt_->get_tlsdesc_plt_offset();
              unsigned int got_offset = this->plt_->get_tlsdesc_got_offset();
              this->got_->finalize_data_size();
              odyn->add_section_plus_offset(elfcpp::DT_TLSDESC_PLT,
                                            this->plt_, plt_offset);
              odyn->add_section_plus_offset(elfcpp::DT_TLSDESC_GOT,
                                            this->got_, got_offset);
	    }
	}

      if (this->rela_dyn_ != NULL
	  && this->rela_dyn_->output_section() != NULL)
	{
	  const Output_data* od = this->rela_dyn_;
	  odyn->add_section_address(elfcpp::DT_RELA, od);
	  odyn->add_section_size(elfcpp::DT_RELASZ, od);
	  odyn->add_constant(elfcpp::DT_RELAENT,
			     elfcpp::Elf_sizes<64>::rela_size);
	}

      if (!parameters->options().shared())
d1672 7
a1678 3
	  // The value of the DT_DEBUG tag is filled in by the dynamic
	  // linker at run time, and used by the debugger.
	  odyn->add_constant(elfcpp::DT_DEBUG, 0);
@


1.101
log
@	* layout.cc (Layout::Layout): Initialize increase_relro_.
	(Layout::get_output_section): Add is_relro, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::set_segment_offsets): Clear increase_relro when using a
	linker script.
	* layout.h (class Layout): Add increase_relro method.  Add
	increase_relro_ field.  Update declarations.
	* output.cc (Output_section::Output_section): Initialize
	is_last_relro_ and is_first_non_relro_.
	(Output_segment::add_output_section): Group relro sections is
	do_sort is true.  Handle is_last_relro and is_first_non_relro.
	(Output_segment::maximum_alignment): Remove relro handling.
	(Output_segment::set_section_addresses): Add increase_relro
	parameter.  Change all callers.  Add initial alignment to align
	relro sections on separate page.  Remove old relro handling.
	(Output_segment::set_section_list_addresses): Remove in_relro
	parameter.  Change all callers.
	(Output_segment::set_offset): Add increase parameter.  Change all
	callers.  Remove old relro handling.
	* output.h (class Output_section): Add new methods: is_last_relro,
	set_is_last_relro, is_first_non_relro, set_is_first_non_relro.
	Add is_last_relro_ and is_first_non_relro_ fields.
	* i386.cc (Target_i386::got_section): Don't call set_is_relro.
	Create separate .got.plt section.  Call increase_relro.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/relro_script_test.t: Add .got.plt.
@
text
@d66 2
a67 2
      got_(NULL), plt_(NULL), got_plt_(NULL), rela_dyn_(NULL),
      copy_relocs_(elfcpp::R_X86_64_COPY), dynbss_(NULL),
d413 2
d491 8
a498 7
      symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
				    Symbol_table::PREDEFINED,
				    this->got_plt_,
				    0, 0, elfcpp::STT_OBJECT,
				    elfcpp::STB_LOCAL,
				    elfcpp::STV_HIDDEN, 0,
				    false, false);
d1656 1
a1656 1
    Symbol_table*)
d1707 9
@


1.100
log
@	* symtab.h (class Symbol_table): Add enum Defined.
	* resolve.cc (Symbol_table::should_override): Add defined
	parameter.  Change all callers.  Test whether object is NULL
	before calling a method on it.
	(Symbol_table::report_resolve_problem): Add defined parameter.
	Change all callers.
	(Symbol_table::should_override_with_special): Likewise.
	* symtab.cc (Symbol_table::define_in_output_data): Add defined
	parameter.  Change all callers.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::define_in_output_segment): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::define_as_constant): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* script.h (class Symbol_assignment): Add is_defsym parameter to
	constructor; change all callers.
	* script.cc (Script_options::add_symbol_assignment): Add is_defsym
	parameter.  Change all callers.  Add is_defsym_ field.
	(class Parser_closure): Add parsing_defsym parameter to
	constructor; change all callers.  Add parsing_defsym accessor
	function.  Add parsing_defsym_ field.
@
text
@d472 2
a473 2
					   this->got_, false);
      os->set_is_relro();
a474 4
      // The old GNU linker creates a .got.plt section.  We just
      // create another set of data in the .got section.  Note that we
      // always create a PLT if we create a GOT, although the PLT
      // might be empty.
d476 1
a476 1
      os = layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
d479 2
a480 2
					   this->got_plt_, false);
      os->set_is_relro();
d485 3
d511 2
a512 1
				      elfcpp::SHF_ALLOC, this->rela_dyn_, true);
d612 2
a613 1
				  elfcpp::SHF_ALLOC, this->rel_, true);
d809 1
a809 1
				      this->plt_, false);
@


1.99
log
@	* x86_64.cc (Target_x86_64::do_calls_non_split): Recognize
	-fsplit-stack prologue when using %r11.
@
text
@d491 1
d840 1
@


1.98
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d2695 5
a2699 1
  else if (this->match_view(view, view_size, fnoffset, "\x4c\x8d\x94\x24", 4)
@


1.97
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d705 1
a705 1
  const off_t off = this->offset();
d708 1
a708 1
  unsigned char* const oview = of->get_output_view(off, oview_size);
d788 1
a788 1
  of->write_output_view(off, oview_size, oview);
@


1.96
log
@2009-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gold/10893
	* i386.cc (Target_i386::Scan::globa): Use is_func instead of
	checking elfcpp::STT_FUNC.
	(Target_i386::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Scan::global): Likewise.

	* symtab.cc (Symbol_table::sized_write_symbol): Turn IFUNC
	symbols from shared libraries into normal FUNC symbols.

	* symtab.h (Symbol): Add is_func and use it.
@
text
@d705 1
a705 1
  const off_t offset = this->offset();
d708 1
a708 1
  unsigned char* const oview = of->get_output_view(offset, oview_size);
d788 1
a788 1
  of->write_output_view(offset, oview_size, oview);
@


1.95
log
@2009-12-05  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:

	* arm.h: Define enums for Tag_CPU_arch EABI attribute.

gold/ChangeLog:
	* arm.cc (Target_arm::arm_info): Initialize new fields
	attributes_section and attributes_vendor.
	* i386.cc (Target_i386::i386_info): Same.
	* object.cc (Sized_relobj::do_layout): Skip attribute section.
	* gold/powerpc.cc (Target_powerpc::powerpc_info): Initialize new
	fields attributes_section and attributes_vendor.
 	* sparc.cc (Target_sparc::sparc_info): Same.
	* target.h (Target::attributes_section, Target::attributes_vendor,
	Target::is_attributes_section, Target::attribute_arg_type,
	Target::attributes_order): New method definitions.
	(Target::Target_info::attributes_section,
	Target::Target_info::attributes_vendor): New fields.
	(Target::do_attribute_arg_type, Target::do_attributes_order): New
	virtual method definitions.
	* x86_64.cc (Target_x86_64::x86_64_info): Initialize new fields
	attributes_section and attributes_vendor.
	* testsuite/testfile.cc (Target_test::test_target_info): Same.
@
text
@d1355 1
a1355 1
        if (gsym->type() == elfcpp::STT_FUNC)
@


1.94
log
@2009-12-03  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Remove comment about missing .ARM.exidx section symbols.
	(Target_arm::do_finalize_sections): Add parameter for symbol table
	pointer.  Add __exidx_start and __exidx_end symbols as appropriate.
	* i386.cc (Target_i386::do_finalize_sections): Add an additional
	parameter for symbol table pointer.
	* layout.cc (Layout::finalize): Call Target::finalize_sections with
	an additional parameter for a pointer to symbol table.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add an additional
	parameter for a symbol table pointer.
	* sparc.cc (Target_sparc::do_finalize_sections): Ditto.
	* target.h (Target::finalize_sections, Target::do_finalize_sections):
	Ditto.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add an additional
	parameter for a symbol table pointer.
@
text
@d442 3
a444 1
  elfcpp::SHF_X86_64_LARGE	// large_common_section_flags
@


1.93
log
@2009-11-10  Doug Kwan  <dougkwan@@google.com>

	* i386.cc (Target_i386::do_calls_non_split): Add a cast to avoid
	a format warning.
	* incremental.cc (open_incremental_binary): Initialized local
	variables to avoid warnings.
	* object.cc (make_elf_object): Ditto.
	* x86_64.cc (Target_x86_64::do_calls_non_split): Add a cast to avoid
	a format warning.
@
text
@d105 1
a105 1
  do_finalize_sections(Layout*, const Input_objects*);
d1645 4
a1648 1
Target_x86_64::do_finalize_sections(Layout* layout, const Input_objects*)
@


1.92
log
@	PR 10887
	* arm.cc (Target_arm::do_finalize_sections): Don't add dynamic
	tags if data is discarded by linker script.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d2708 1
a2708 1
		      shndx, fnoffset);
@


1.91
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d1651 2
a1652 1
      if (this->got_plt_ != NULL)
d1655 2
a1656 1
      if (this->plt_ != NULL)
d1674 2
a1675 1
      if (this->rela_dyn_ != NULL)
@


1.90
log
@2009-10-30  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:
	* arm.h (EF_ARM_BE8, EF_ARM_EABIMASK, EF_ARM_EABI_UNKNOWN,
	EF_ARM_EABI_VER1, EF_ARM_EABI_VER2, EF_ARM_EABI_VER3,
	EF_ARM_EABI_VER4, EF_ARM_EABI_VER5): New enums for processor-specific
	flags.
	(arm_eabi_version): New inline function.
	* elfcpp.h: Add a comment about DT_ENCODING.

gold/ChangeLog:
	* arm.cc (Arm_relobj::processor_specific_flags): New method
	definition.
	(Arm_relobj::do_read_symbols): New method declaration.
	(Arm_relobj::processor_specific_flags_): New data member declaration.
	(Arm_dynobj): New class definition.
	(Target_arm::do_finalize_sections): Add input_objects parameter.
	(Target_arm::do_adjust_elf_header): New method declaration.
	(Target_arm::are_eabi_versions_compatible,
	(Target_arm::merge_processor_specific_flags): New method declaration.
	(Target_arm::do_make_elf_object): New overloaded method definitions
	and declaration.
	(Arm_relobj::do_read_symbols): New method definition.
	(Arm_dynobj::do_read_symbols): Ditto.
	(Target_arm::do_finalize_sections): Add input_objects parameters.
	Merge processor-specific flags from all input objects.
	(Target_arm::are_eabi_versions_compatible,
	Target_arm::merge_processor_specific_flags,
	Target_arm::do_adjust_elf_header, Target_arm::do_make_elf_object):
	New method definitions.
	* i386.cc (Target_i386::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* layout.cc (Layout::finalize): Pass input objects to target's.
	finalize_sections function.
	* output.cc (Output_file_header::do_sized_write): Set ELF file
	header's processor-specific flags.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* sparc.cc (Target_sparc::do_finalize_sections): Same.
	* target.h (Input_objects): New forward class declaration.
	(Target::processor_specific_flags,
	Target::are_processor_specific_flags_sect): New method definitions.
	(Target::finalize_sections): Add input_objects parameter.
	(Target::Target): Initialize processor_specific_flags_ and
	are_processor_specific_flags_set_.
	(Target::do_finalize_sections): Add unnamed Input_objects pointer type
	parameter.
	(Target::set_processor_specific_flags): New method definition.
	(Target::processor_specific_flags_,
	Target::are_processor_specific_flags_set_): New data member
	declarations.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
@
text
@d470 1
a470 1
					   this->got_);
d481 1
a481 1
					   this->got_plt_);
d509 1
a509 1
				      elfcpp::SHF_ALLOC, this->rela_dyn_);
d609 1
a609 1
				  elfcpp::SHF_ALLOC, this->rel_);
d805 1
a805 1
				      this->plt_);
@


1.89
log
@	* object.h (class Relobj): Drop options parameter from
	gc_process_relocs, scan_relocs, relocate, do_gc_process_relocs,
	do_scan_relocs, do_relocate.  Change all callers.
	(class Sized_relobj): Drop options parameters from
	do_gc_process_relocs, do_scan_relocs, do_relocate,
	do_relocate_sections, relocate_sections, emit_relocs_scan,
	emit_relocs_scan_reltype.  Change all callers.
	(struct Relocate_info): Remove options field and all references to
	it.
	* reloc.h (class Read_relocs): Remove options constructor
	parameter and options_ field.  Change all callers.
	(class Gc_process_relocs, class Scan_relocs): Likewise.
	(class Relocate_task): Likewise.
	* target-reloc.h (scan_relocs): Remove options parameter.  Change
	all callers.
	(scan_relocatable_relocs): Likewise.
	* target.h (class Sized_target): Remove options parameter from
	gc_process_relocs, scan_relocs, scan_relocatable_relocs.  Change
	all callers.
	* gc.h (gc_process_relocs): Remove options parameter.  Change all
	callers.
	* arm.cc: Update functions to remove options parameters.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* testsuite/testfile.cc: Likewise.
@
text
@d105 1
a105 1
  do_finalize_sections(Layout*);
d1645 1
a1645 1
Target_x86_64::do_finalize_sections(Layout* layout)
@


1.88
log
@	* symtab.h: Check for GOLD_SYMTAB_H before header includes. Remove
	includes to gc.h and icf.h.
	* arm.cc: Include gc.h.
	* gold.cc: Likewise.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* gc.h: Include icf.h.
@
text
@d77 1
a77 2
  gc_process_relocs(const General_options& options,
	            Symbol_table* symtab,
d91 1
a91 2
  scan_relocs(const General_options& options,
	      Symbol_table* symtab,
d127 1
a127 2
  scan_relocatable_relocs(const General_options& options,
			  Symbol_table* symtab,
d189 1
a189 2
    local(const General_options& options, Symbol_table* symtab,
	  Layout* layout, Target_x86_64* target,
d197 1
a197 2
    global(const General_options& options, Symbol_table* symtab,
	   Layout* layout, Target_x86_64* target,
d1000 1
a1000 2
Target_x86_64::Scan::local(const General_options&,
                           Symbol_table* symtab,
d1280 1
a1280 2
Target_x86_64::Scan::global(const General_options&,
                            Symbol_table* symtab,
d1572 1
a1572 2
Target_x86_64::gc_process_relocs(const General_options& options,
                                 Symbol_table* symtab,
a1591 1
    options,
d1608 1
a1608 2
Target_x86_64::scan_relocs(const General_options& options,
                           Symbol_table* symtab,
a1628 1
    options,
d2518 1
a2518 2
Target_x86_64::scan_relocatable_relocs(const General_options& options,
				       Symbol_table* symtab,
a2537 1
    options,
@


1.87
log
@	* options.h (class General_options): Define
	split_stack_adjust_size parameter.
	* object.h (class Object): Add uses_split_stack_ and
	has_no_split_stack_ fields.  Add uses_split_stack and
	has_no_split_stack accessor functions.  Declare
	handle_split_stack_section.
	(class Reloc_symbol_changes): Define.
	(class Sized_relobj): Define Function_offsets.  Declare
	split_stack_adjust, split_stack_adjust_reltype, and
	find_functions.
	* object.cc (Object::handle_split_stack_section): New function.
	(Sized_relobj::do_layout): Call handle_split_stack_section.
	* dynobj.cc (Sized_dynobj::do_layout): Call
	handle_split_stack_section.
	* reloc.cc (Sized_relobj::relocate_sections): Call
	split_stack_adjust for executable sections in split_stack
	objects.  Pass reloc_map to relocate_section.
	(Sized_relobj::split_stack_adjust): New function.
	(Sized_relobj::split_stack_adjust_reltype): New function.
	(Sized_relobj::find_functions): New function.
	* target-reloc.h: Include "object.h".
	(relocate_section): Add reloc_symbol_changes parameter.  Change
	all callers.
	* target.h (class Target): Add calls_non_split method.  Declare
	do_calls_non_split virtual method.  Declare match_view and
	set_view_to_nop.
	* target.cc: Include "elfcpp.h".
	(Target::do_calls_non_split): New function.
	(Target::match_view): New function.
	(Target::set_view_to_nop): New function.
	* gold.cc (queue_middle_tasks): Give an error if mixing
	split-stack and non-split-stack objects with -r.
	* i386.cc (Target_i386::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_i386::do_calls_non_split): New function.
	* x86_64.cc (Target_x86_64::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_x86_64::do_calls_non_split): New function.
	* arm.cc (Target_arm::relocate_section): Add reloc_symbol_changes
	parameter.
	* powerpc.cc (Target_powerpc::relocate_section): Add
	reloc_symbol_changes parameter.
	* sparc.cc (Target_sparc::relocate_section): Add
	reloc_symbol_changes parameter.
	* configure.ac: Call AM_CONDITIONAL for the default target.
	* configure: Rebuild.
	* testsuite/Makefile.am (TEST_AS): New variable.
	(check_SCRIPTS): Add split_i386.sh and split_x86_64.sh.
	(check_DATA): Add split_i386 and split_x86_64 files.
	(SPLIT_DEFSYMS): Define.
	(split_i386_[1234n].o): New targets.
	(split_i386_[124]): New targets.
	(split_i386_[1234r].stdout): New targets.
	(split_x86_64_[1234n].o): New targets.
	(split_x86_64_[124]): New targets.
	(split_x86_64_[1234r].stdout): New targets.
	(MOSTLYCLEANFILES): Add new executables.
	* testsuite/split_i386.sh: New file.
	* testsuite/split_x86_64.sh: New file.
	* testsuite/split_i386_1.s: New file.
	* testsuite/split_i386_2.s: New file.
	* testsuite/split_i386_3.s: New file.
	* testsuite/split_i386_4.s: New file.
	* testsuite/split_i386_n.s: New file.
	* testsuite/split_x86_64_1.s: New file.
	* testsuite/split_x86_64_2.s: New file.
	* testsuite/split_x86_64_3.s: New file.
	* testsuite/split_x86_64_4.s: New file.
	* testsuite/split_x86_64_n.s: New file.
	* testsuite/testfile.cc (Target_test): Update relocation_section
	function.
	* testsuite/Makefile.in: Rebuild.
@
text
@d41 1
@


1.86
log
@2009-09-30  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::may_need_copy_reloc): Check for THUMB function
	symbol and call Symbol::may_need_copy_reloc to determine if
	a copy reloc is needed.
	* copy-relocs.cc (Copy_relocs::need_copy_reloc): Return false if -z
	nocopyreloc is given in command line.
	(Copy_relocs::emit_copy_reloc): Assert that -z nocopyreloc is not
	given in command line.
	* i386.cc (Target_i386::may_need_copy_reloc): Remove.
	(Target_i386::Scan::global): Use Symbol::may_need_copy_reloc instead
	of the removed Target_i386::may_need_copy_reloc.
	* options.h (copyreloc): New option with default value false.
	* powerpc.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_powerpc::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_powerpc::may_need_copy_reloc.
	* sparc.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_sparc::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_sparc::may_need_copy_reloc.
	* symtab.h (Symbol::may_need_copy_reloc): New method definition.
	* x86_64.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_x86_64::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_x86_64::may_need_copy_reloc.
@
text
@d123 2
a124 1
		   section_size_type view_size);
d166 7
d2428 11
a2438 9
Target_x86_64::relocate_section(const Relocate_info<64, false>* relinfo,
                                unsigned int sh_type,
                                const unsigned char* prelocs,
                                size_t reloc_count,
				Output_section* output_section,
				bool needs_special_offset_handling,
                                unsigned char* view,
                                elfcpp::Elf_types<64>::Elf_Addr address,
                                section_size_type view_size)
d2452 2
a2453 1
    view_size);
d2671 57
@


1.85
log
@*** empty log message ***
@
text
@a377 11
  // Return true if the symbol may need a COPY relocation.
  // References from an executable object to non-function symbols
  // defined in a dynamic object may need a COPY relocation.
  bool
  may_need_copy_reloc(Symbol* gsym)
  {
    return (!parameters->options().shared()
            && gsym->is_from_dynobj()
            && gsym->type() != elfcpp::STT_FUNC);
  }

d1315 1
a1315 1
            if (target->may_need_copy_reloc(gsym))
d1355 1
a1355 1
            if (target->may_need_copy_reloc(gsym))
@


1.85.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a40 1
#include "gc.h"
d123 1
a123 2
		   section_size_type view_size,
		   const Reloc_symbol_changes*);
a164 7
  // Adjust -fstack-split code which calls non-stack-split code.
  void
  do_calls_non_split(Relobj* object, unsigned int shndx,
		     section_offset_type fnoffset, section_size_type fnsize,
		     unsigned char* view, section_size_type view_size,
		     std::string* from, std::string* to) const;

d378 11
d1326 1
a1326 1
            if (gsym->may_need_copy_reloc())
d1366 1
a1366 1
            if (gsym->may_need_copy_reloc())
d2431 9
a2439 11
Target_x86_64::relocate_section(
    const Relocate_info<64, false>* relinfo,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    unsigned char* view,
    elfcpp::Elf_types<64>::Elf_Addr address,
    section_size_type view_size,
    const Reloc_symbol_changes* reloc_symbol_changes)
d2453 1
a2453 2
    view_size,
    reloc_symbol_changes);
a2670 57
// FNOFFSET in section SHNDX in OBJECT is the start of a function
// compiled with -fstack-split.  The function calls non-stack-split
// code.  We have to change the function so that it always ensures
// that it has enough stack space to run some random function.

void
Target_x86_64::do_calls_non_split(Relobj* object, unsigned int shndx,
				  section_offset_type fnoffset,
				  section_size_type fnsize,
				  unsigned char* view,
				  section_size_type view_size,
				  std::string* from,
				  std::string* to) const
{
  // The function starts with a comparison of the stack pointer and a
  // field in the TCB.  This is followed by a jump.

  // cmp %fs:NN,%rsp
  if (this->match_view(view, view_size, fnoffset, "\x64\x48\x3b\x24\x25", 5)
      && fnsize > 9)
    {
      // We will call __morestack if the carry flag is set after this
      // comparison.  We turn the comparison into an stc instruction
      // and some nops.
      view[fnoffset] = '\xf9';
      this->set_view_to_nop(view, view_size, fnoffset + 1, 8);
    }
  // lea NN(%rsp),%r10
  else if (this->match_view(view, view_size, fnoffset, "\x4c\x8d\x94\x24", 4)
	   && fnsize > 8)
    {
      // This is loading an offset from the stack pointer for a
      // comparison.  The offset is negative, so we decrease the
      // offset by the amount of space we need for the stack.  This
      // means we will avoid calling __morestack if there happens to
      // be plenty of space on the stack already.
      unsigned char* pval = view + fnoffset + 4;
      uint32_t val = elfcpp::Swap_unaligned<32, false>::readval(pval);
      val -= parameters->options().split_stack_adjust_size();
      elfcpp::Swap_unaligned<32, false>::writeval(pval, val);
    }
  else
    {
      if (!object->has_no_split_stack())
	object->error(_("failed to match split-stack sequence at "
			"section %u offset %0zx"),
		      shndx, fnoffset);
      return;
    }

  // We have to change the function so that it calls
  // __morestack_non_split instead of __morestack.  The former will
  // allocate additional stack space.
  *from = "__morestack";
  *to = "__morestack_non_split";
}

@


1.85.2.2
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d475 1
a475 1
					   this->got_, false);
d486 1
a486 1
					   this->got_plt_, false);
d514 1
a514 1
				      elfcpp::SHF_ALLOC, this->rela_dyn_, true);
d614 1
a614 1
				  elfcpp::SHF_ALLOC, this->rel_, true);
d810 1
a810 1
				      this->plt_, false);
@


1.85.2.3
log
@	PR 10887
	* arm.cc (Target_arm::do_finalize_sections): Don't add dynamic
	tags if data is discarded by linker script.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d1662 1
a1662 2
      if (this->got_plt_ != NULL
	  && this->got_plt_->output_section() != NULL)
d1665 1
a1665 2
      if (this->plt_ != NULL
	  && this->plt_->output_section() != NULL)
d1683 1
a1683 2
      if (this->rela_dyn_ != NULL
	  && this->rela_dyn_->output_section() != NULL)
@


1.84
log
@	PR 10419
	* x86_64.cc (Target_x86_64::do_code_fill): Correct nop sequences.
@
text
@a2121 1
      gold_assert(tls_segment != NULL);
d2129 4
a2132 1
            value -= tls_segment->memsz();
a2137 1
      gold_assert(tls_segment != NULL);
d2142 4
a2145 1
            value -= tls_segment->memsz();
@


1.83
log
@	* layout.cc (Layout::make_output_section): Call
	Target::new_output_section.
	(Layout::attach_allocated_section_to_segment): Put large section
	sections in a separate load segment with the large segment flag
	set.
	(Layout::segment_precedes): Sort large data segments after other
	load segments.
	(align_file_offset): New static function.
	(Layout::set_segment_offsets): Use align_file_offset.
	* output.h (class Output_section): Add is_small_section_ and
	is_large_section_ fields.
	(Output_section::is_small_section): New function.
	(Output_section::set_is_small_section):  New function.
	(Output_section::is_large_section): New function.
	(Output_section::set_is_large_section): New function.
	(Output_section::is_large_data_section): New function.
	(class Output_segment): Add is_large_data_segment_ field.
	(Output_segment::is_large_data_segment): New function.
	(Output_segment::set_is_large_data_segment): New function.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_segment::Output_segment): Likewise.
	(Output_segment::add_output_section): Add assertion that large
	data sections always go in large data segments.  Force small data
	sections to the end of the list of data sections.  Force small BSS
	sections to the start of the list of BSS sections.  For large BSS
	sections to the end of the list of BSS sections.
	* symtab.h (class Symbol): Declare is_common_shndx.
	(Symbol::is_defined): Check Symbol::is_common_shndx.
	(Symbol::is_common): Likewise.
	(class Symbol_table): Define enum Commons_section_type.  Update
	declarations.  Add small_commons_ and large_commons_ fields.
	* symtab.cc (Symbol::is_common_shndx): New function.
	(Symbol_table::Symbol_table): Initialize new fields.
	(Symbol_table::add_from_object): Put small and large common
	symbols in the right list.
	(Symbol_table::sized_finalized_symbol): Check
	Symbol::is_common_shndx.
	(Symbol_table::sized_write_globals): Likewise.
	* common.cc (Symbol_table::do_allocate_commons): Allocate new
	common symbol lists.  Don't call do_allocate_commons_list if the
	list is empty.
	(Symbol_table::do_allocate_commons_list): Remove is_tls
	parameter.  Add comons_section_type parameter.  Change all
	callers.  Handle small and large common symbols.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Check
	Symbol::is_common_shndx.
	* resolve.cc (symbol_to_bits): Likewise.
	* target.h (Target::small_common_shndx): New function.
	(Target::small_common_section_flags): New function.
	(Target::large_common_shndx): New function.
	(Target::large_common_section_flags): New function.
	(Target::new_output_section): New function.
	(Target::Target_info): Add small_common_shndx, large_common_shndx,
	small_common_section_flags, and large_common_section_flags
	fields.
	(Target::do_new_output_section): New virtual function.
	* arm.cc (Target_arm::arm_info): Initialize new fields.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Likewise.
	* sparc.c (Target_sparc::sparc_info) [all versions]: Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	(Target_x86_64::do_new_output_section): New function.
	* configure.ac: Define conditional MCMODEL_MEDIUM.
	* testsuite/Makefile.am (check_PROGRAMS): Add large.
	(large_SOURCES, large_CFLAGS, large_DEPENDENCIES): Define.
	(large_LDFLAGS): Define.
	* testsuite/large.c: New file.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Initialize new fields.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d2623 5
a2627 5
  const char nop3[3] = { 0x8d, 0x76, 0x00 };       // leal 0(%esi),%esi
  const char nop4[4] = { 0x8d, 0x74, 0x26, 0x00};  // leal 0(%esi,1),%esi
  const char nop5[5] = { 0x90, 0x8d, 0x74, 0x26,   // nop
                         0x00 };                   // leal 0(%esi,1),%esi
  const char nop6[6] = { 0x8d, 0xb6, 0x00, 0x00,   // leal 0L(%esi),%esi
d2629 1
a2629 1
  const char nop7[7] = { 0x8d, 0xb4, 0x26, 0x00,   // leal 0L(%esi,1),%esi
d2631 4
a2634 4
  const char nop8[8] = { 0x90, 0x8d, 0xb4, 0x26,   // nop
                         0x00, 0x00, 0x00, 0x00 }; // leal 0L(%esi,1),%esi
  const char nop9[9] = { 0x89, 0xf6, 0x8d, 0xbc,   // movl %esi,%esi
                         0x27, 0x00, 0x00, 0x00,   // leal 0L(%edi,1),%edi
d2636 2
a2637 2
  const char nop10[10] = { 0x8d, 0x76, 0x00, 0x8d, // leal 0(%esi),%esi
                           0xbc, 0x27, 0x00, 0x00, // leal 0L(%edi,1),%edi
d2639 2
a2640 2
  const char nop11[11] = { 0x8d, 0x74, 0x26, 0x00, // leal 0(%esi,1),%esi
                           0x8d, 0xbc, 0x27, 0x00, // leal 0L(%edi,1),%edi
d2642 2
a2643 2
  const char nop12[12] = { 0x8d, 0xb6, 0x00, 0x00, // leal 0L(%esi),%esi
                           0x00, 0x00, 0x8d, 0xbf, // leal 0L(%edi),%edi
d2645 3
a2647 3
  const char nop13[13] = { 0x8d, 0xb6, 0x00, 0x00, // leal 0L(%esi),%esi
                           0x00, 0x00, 0x8d, 0xbc, // leal 0L(%edi,1),%edi
                           0x27, 0x00, 0x00, 0x00,
d2649 3
a2651 3
  const char nop14[14] = { 0x8d, 0xb4, 0x26, 0x00, // leal 0L(%esi,1),%esi
                           0x00, 0x00, 0x00, 0x8d, // leal 0L(%edi,1),%edi
                           0xbc, 0x27, 0x00, 0x00,
d2653 4
a2656 4
  const char nop15[15] = { 0xeb, 0x0d, 0x90, 0x90, // jmp .+15
                           0x90, 0x90, 0x90, 0x90, // nop,nop,nop,...
                           0x90, 0x90, 0x90, 0x90,
                           0x90, 0x90, 0x90 };
@


1.82
log
@	* x86_64.cc (do_adjust_output_section): Set entsize to
	plt_entry_size.
@
text
@d70 4
d445 5
a449 1
  0x1000		// common_pagesize (overridable by -z common-page-size)
d452 10
@


1.81
log
@	* powerpc.cc (Target_powerpc::check_non_pic): Assert that output is
	position independent.
	* sparc.cc (Target_sparc::check_non_pic): Likewise.
	* x86_64.cc (Target_x86_64::check_non_pic): Likewise.
@
text
@d604 1
a604 3
  // UnixWare sets the entsize of .plt to 4, and so does the old GNU
  // linker, and so do we.
  os->set_entsize(4);
@


1.80
log
@2009-03-23  Ian Lance Taylor  <iant@@google.com>

	* freebsd.h: New file.
	* i386.cc: Include "freebsd.h".
	(Target_i386): Derive from Target_freebsd rather than
	Sized_target.
	(Target_selector_i386): Derive from Target_selector_freebsd rather
	than Target_selector.
	* x86_64.cc: Include "freebsd.h".
	(Target_x86_64): Derive from Target_freebsd rather than
	Sized_target.
	(Target_selector_x86_64): Derive from Target_selector_freebsd
	rather than Target_selector.
	* target.h (class Target): Add adjust_elf_header and
	do_adjust_elf_header.
	* output.cc (Output_file_header:: do_sized_write): Call target
	adjust_elf_header routine.
	* configure.tgt: Set targ_osabi.
	* configure.ac: Define GOLD_DEFAULT_OSABI.
	* parameters.cc (Parameters::default_target): Pass
	GOLD_DEFAULT_OSABI to select_target.
	* target-select.h (class Target_selector): Make instantiate_target
	protected rather than private.
	* Makefile.am (HFILES): Add freebsd.h.
	* configure, Makefile.in, config.in: Rebuild.
@
text
@d977 1
@


1.79
log
@	PR 9918
	* target-reloc.h (relocate_section): Pass output_section to
	relocate.
	* i386.cc (Target_i386::should_apply_static_reloc): Add
	output_section parameter.  Change all callers.
	(Target_i386::Relocate::relocate): Add output_section parameter.
	* x86_64.cc (Target_x86_64::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Relocate::relocate): Likewise.
	* powerpc.cc (Target_powerpc::Relocate::relocate): Likewise.
	* testsuite/two_file_shared.sh: New script.
	* testsuite/Makefile.am (check_SCRIPTS): Add two_file_shared.sh.
	(check_DATA): Add two_file_shared.dbg.
	(two_file_shared.dbg): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d40 1
d56 1
a56 1
class Target_x86_64 : public Sized_target<64, false>
d64 1
a64 1
    : Sized_target<64, false>(&x86_64_info),
d2652 1
a2652 1
class Target_selector_x86_64 : public Target_selector
d2656 2
a2657 1
    : Target_selector(elfcpp::EM_X86_64, 64, false, "elf64-x86-64")
d2663 1
@


1.78
log
@	* i386.cc (Target_i386::Relocate::relocate): Recognize non-PIC calls
	to __tls_get_addr.
	* x86_64.cc (Target_x86_64::Relocate::relocate): Likewise.

	* ChangeLog: Fixed typo in previous ChangeLog entry (version 1.9).
@
text
@d230 2
a231 2
    relocate(const Relocate_info<64, false>*, Target_x86_64*, size_t relnum,
	     const elfcpp::Rela<64, false>&,
d1695 1
@


1.77
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d1706 2
a1707 1
      if (r_type != elfcpp::R_X86_64_PLT32
@


1.76
log
@	* target-reloc.h (relocate_section): Check whether a symbol is
	defined by the ABI before reporting an undefined symbol error.
	* target.h (Target::is_defined_by_abi): Make parameter const.
	(Target::do_is_defined_by_abi): Likewise.
	* i386.cc (Target_i386::do_is_defined_by_abi): Likewise.
	* powerpc.cc (Target_powerpc::do_is_defined_by_abi): Likewise.
	* sparc.cc (Target_sparc::do_is_defined_by_abi): Likewise.
	* x86_64.cc (Target_x86_64::do_is_defined_by_abi): Likewise.
	* testsuite/Makefile.am (tls_test_shared.so): Add -Wl,-z,defs.
	* testsuite/Makefile.in: Rebuild.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d71 15
d1562 36
@


1.75
log
@* i386.cc (Target_i386::define_tls_base_symbol): Update comments.
* x86_64.cc (Target_x86_64::define_tls_base_symbol): Likewise.
@
text
@d142 1
a142 1
  do_is_defined_by_abi(Symbol* sym) const
@


1.74
log
@* options.h (General_options::output_is_executable): New.
(General_options::output_is_pie): New.
* i386.cc (Target_i386::define_tls_base_symbol): Use SEGMENT_START
for shared libraries.
* x86_64.cc (Target_x86_64::define_tls_base_symbol): Likewise.
@
text
@d333 1
a333 1
  // Define the _TLS_MODULE_BASE_ symbol at the end of the TLS segment.
d799 1
a799 1
// Define the _TLS_MODULE_BASE_ symbol at the end of the TLS segment.
@


1.73
log
@2008-08-14  Cary Coutant  <ccoutant@@google.com>

	* x86_64.cc (Target_x86_64::Relocate::relocat_tls):
	Use addend for DTPOFF32, DTPOFF64, and TPOFF32 relocs.
	* testsuite/tls_test.cc (struct int128): 128-bit struct
	for testing TLS relocs with non-zero addend.
	(v12): New TLS variable.
	(t12): New test.
	(t_last): Add check for v12.
	* testsuite/tls_test.h (t12): New function.
	* testsuite/tls_test_main.cc (thread_routine): Call new test.
@
text
@d810 1
d816 4
a819 1
				       Symbol::SEGMENT_END, true);
@


1.72
log
@	* symtab.h (Symbol::use_plt_offset): New function.
	* i386.cc (Relocate::relocate): Call Symbol::use_plt_offset.
	* powerpc.cc (Relocate::relocate): Likewise.
	* sparc.cc (Relocate::relocate): Likewise.
	* x86_64.cc (Relocate::relocate): Likewise.
	* testsuite/weak_plt.sh: New test.
	* testsuite/weak_plt_main.cc: New test.
	* testsuite/weak_plt_shared.cc: New test.
	* testsuite/Makefile.am (check_SCRIPTS): Add weak_plt.sh.
	(check_PROGRAMS): Add weak_plt.
	(check_DATA): Add weak_plt_shared.so.
	(weak_plt_main_pic.o, weak_plt): New targets.
	(weak_plt_shared_pic.o, weak_plt_shared.so): New targets.
	* testsuite/Makefile.in: Rebuild.

	* testsuite/Makefile.am (weak_alias_test_1.so): Depend upon
	gcctestdir/ld.
	(weak_alias_test_2.so, weak_alias_test_4.so): Likewise.
	* testsuite/Makefile.in: Rebuild.
@
text
@d2057 1
a2057 1
      Relocate_functions<64, false>::rela32(view, value, 0);
d2068 1
a2068 1
      Relocate_functions<64, false>::rela64(view, value, 0);
d2110 1
a2110 1
      Relocate_functions<64, false>::rela32(view, value, 0);
@


1.71
log
@	Handle output sections with more than 0x7fffffff bytes.
	* object.h (class Relobj): Change map_to_output_ to
	output_sections_, and just keep a section pointer.  Change all
	uses.  Move comdat group support to Sized_relobj.
	(Relobj::is_section_specially_mapped): Remove.
	(Relobj::output_section): Remove poff parameter.  Change all
	callers.
	(Relobj::output_section_offset): New function.
	(Relobj::set_section_offset): Rewrite.
	(Relobj::map_to_output): Remove.
	(Relobj::output_sections): New function.
	(Relobj::do_output_section_offset): New pure virtual function.
	(Relobj::do_set_section_offset): Likewise.
	(class Sized_relobj): Add section_offsets_ field.  Add comdat
	group support from Relobj.  Update declarations.
	(Sized_relobj::get_output_section_offset): New function.
	(Sized_relobj::do_output_section_offset): New function.
	(Sized_relobj::do_set_section_offset): New function.
	* object.cc (Relobj::output_section_address): Remove.
	(Sized_relobj::Sized_relobj): Initialize new fields.
	(Sized_relobj::include_section_group): Cast find_kept_object to
	Sized_relobj.
	(Sized_relobj::include_linkonce_section): Likewise.
	(Sized_relobj::do_layout): Use separate arrays for output section
	and output offset.
	(Sized_relobj::do_count_local_symbols): Change map_to_output to
	output_sections.
	(Sized_relobj::do_finalize_local_symbols): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_local_symbols): Likewise.
	(map_to_kept_section): Compute output address directly.
	* reloc.cc (Sized_relobj::do_read_relocs): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_sections): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (sized_finalize_symbol): Use output_section_offset.
	* output.h (class Output_reloc): Update declarations.  Change
	u2_.relobj to Sized_relobj*.
	(class Output_data_reloc): Change add functions to use
	Sized_relobj*.
	* output.cc (Output_reloc::Output_reloc): Change relobj to
	Sized_relobj*.
	(Output_reloc::local_section_offset): Change return type to
	Elf_Addr.  Use get_output_section_offset.
	(Output_reloc::get_address): Likewise.
	(Output_section::is_input_address_mapped): Don't call
	is_section_specially_mapped.
	(Output_section::output_offset): Likewise.
	(Output_section::output_address): Likewise.
	(Output_section::starting_output_address): Likewise.
	* copy-relocs.cc (Copy_relocs::copy_reloc): Change object
	parameter to Sized_relobj*.
	(Copy_relocs::need_copy_reloc): Likewise.
	(Copy_relocs::save): Likewise.
	* copy-relocs.h (class Copy_relocs): Update declarations.
	(class Copy_relocs::Copy_reloc_entry): Change constructor to use
	Sized_relobj*.  Change relobj_ field to Sized_relobj*.
	* target-reloc.h (relocate_for_relocatable): Change
	offset_in_output_section type to Elf_Addr.  Change code that uses
	it as well.
	* layout.cc (Layout::layout): Always set *off.
	* mapfile.cc (Mapfile::print_input_section): Use
	output_section_offset.
	* i386.cc (Target_i386::copy_reloc): Change object parameter to
	Sized_relobj*.
	* powerpc.cc (Target_powerpc::copy_reloc): Likewise.
	* sparc.cc (Target_sparc::copy_reloc): Likewise.
	* x86_64.cc (Target_x86_64::copy_reloc): Likewise.
@
text
@d1668 4
a1671 4
      && (gsym->is_from_dynobj()
          || (parameters->options().shared()
              && (gsym->is_undefined() || gsym->is_preemptible())))
      && gsym->has_plt_offset())
@


1.70
log
@	* mapfile.cc: New file.
	* mapfile.h: New file.
	* options.h (class General_options): Add -M/--print-map and -Map.
	* options.cc (General_options::finalize): Make -M equivalent to
	-Map -.
	* main.cc: Include <cstdio> and "mapfile.h".
	(main): Open mapfile if requested.
	* gold.cc (class Middle_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(queue_initial_tasks): Add mapfile parameter.  Change caller.
	(queue_middle_tasks): Likewise.
	* gold.h (queue_initial_tasks, queue_middle_tasks): Update
	declarations.
	* archive.cc: Include "mapfile.h".
	(Archive::add_symbols): Add mapfile parameter.  Change all
	callers.  Pass mapfile, symbol, and reason to include_member.
	(Archive::include_all_members): Add mapfile parameter.  Change all
	callers.
	(Archive::include_member): Add mapfile, sym, and why parameters.
	Change all callers.  Report inclusion to map file.
	* archive.h: Include "fileread.h".
	(class Archive): Update declarations.
	(Archive::file): New const method.
	(class Add_archive_symbols): Add mapfile_ field.  Update
	constructor.  Change all callers.
	* readsyms.h (class Read_symbols): Likewise.
	(class Finish_group): Likewise.
	(class Read_script): Likewise.
	* common.cc: Include "mapfile.h".
	(Symbol_table::allocate_commons): Add mapfile parameter.  Change
	all callers.
	(Symbol_table::do_allocate_commons): Likewise.
	(Symbol_table::do_allocate_commons_list): Likewise.  Report common
	symbol allocation to mapfile.
	* common.h (class Allocate_commons_task): Add mapfile_ field.
	Update constructor.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* layout.cc: Include "mapfile.h".
	(Layout_task_runner::run): Print information to mapfile.
	(Layout::create_gold_note): Change Output_data_fixed_space to
	Output_data_zero_fill.
	(Layout::create_build_id): Likewise.
	(Layout::print_to_mapfile): New function.
	* layout.h (class Layout_task_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(class Layout): Declare print_to_mapfile.
	* output.cc (Output_section::Input_section::print_to_mapfile): New
	function.
	(Output_section::add_input_section): If producing a map, always
	add to input_sections_ list.
	(Output_section::do_print_to_mapfile): New function.
	(Output_segment::print_sections_to_mapfile): New function.
	(Output_segment::print_section_list_to_mapfile): New function.
	* output.h: Include "mapfile.h".
	(Output_data::print_to_mapfile): New function.
	(Output_data::do_print_to_mapfile): New virtual function.
	(Output_segment_headers::do_print_to_mapfile): New function.
	(Output_file_header::do_print_to_mapfile): New function.
	(Output_data_const::do_print_to_mapfile): New function.
	(class Output_data_const_buffer): Add map_name_ field.  Update
	constructor.  Change all callers.  Add do_print_to_mapfile
	function.
	(class Output_data_fixed_space): Likewise.
	(class Output_data_space): Likewise.
	(class Output_data_zero_fill): New class.
	(Output_data_strtab::do_print_to_mapfile): New function.
	(Output_data_reloc_base::do_print_to_mapfile): New function.
	(Output_relocatable_relocs::do_print_to_mapfile): New function.
	(Output_data_group::do_print_to_mapfile): New function.
	(Output_data_got::do_print_to_mapfile): New function.
	(Output_data_dynamic::do_print_to_mapfile): New function.
	(Output_symtab_xindex::do_print_to_mapfile): New function.
	(class Output_section): Declare do_print_to_mapflie.  Declare
	print_to_mapfile in Input_section.
	(class Output_segment): Declare new functions.
	* object.h (Sized_relobj::symbol_count): New function.
	* script-sections.cc
	(Output_section_element_dot_assignment::set_section_addresses):
	Change Output_data_fixed_space to Output_data_zero_fill.
	(Output_data_expression::do_print_to_mapfile): New function.
	* script.cc (read_input_script): Add mapfile parameter.  Change
	all callers.
	* script.h (read_input_script): Update declaration.
	* ehframe.h (Eh_frame_hdr::do_print_to_mapfile): New function.
	(Eh_frame::do_print_to_mapfile): New function.
	* merge.h (Output_merge_data::do_print_to_mapfile): New function.
	(Output_merge_string::do_print_to_mapfile): New function.
	* i386.cc (Output_data_plt_i386::do_print_to_mapfile): New
	function.
	* sparc.cc (Output_data_plt_sparc::do_print_to_mapfile): New
	function.
	* x86_64.cc (Output_data_plt_x86_64::do_print_to_mapfile): New
	function.
	* Makefile.am (CCFILES): Add mapfile.cc.
	(HFILES): Add mapfile.h.
	* Makefile.in: Rebuild.
@
text
@d371 2
a372 1
  copy_reloc(Symbol_table* symtab, Layout* layout, Relobj* object,
@


1.69
log
@	* options.h (class General_options): Add -z relro.
	* layout.cc (Layout::Layout): Initialize relro_segment_.
	(Layout::add_output_section_data): Return the output section.
	(Layout::make_output_section): Rcognize relro sections and mark
	them appropriately.
	(Layout::attach_allocated_section_to_segment): Put relro sections
	in a PT_GNU_RELRO segment.
	(Layout::create_initial_dynamic_sections): Mark the .dynamic
	section as relro.
	(Layout::segment_precedes): Sort PT_GNU_RELRO segments after
	PT_TLS segments.
	(Layout::linkonce_mapping): Map d.rel.ro.local to
	.data.rel.ro.local.
	(Layout::output_section_name): Us .data.rel.ro.local for any
	section which begins with that.
	* layout.h (class Layout): Update add_output_section_data
	declaration.  Add relro_segment_ field.
	* output.cc (Output_section::Output_section): Initialize is_relro_
	and is_relro_local_ fields.
	(Output_segment::add_output_section): Group relro sections.
	(Output_segment::is_first_section_relro): New function.
	(Output_segment::maximum_alignment): If there is a relro section,
	align the segment to the common page size.
	(Output_segment::set_section_addresses): Track whether we are
	looking at relro sections.  If the last section is a relro
	section, align to the common page size.
	(Output_segment::set_section_list_addresses): Add in_relro
	parameter.  Change all callers.  Align to the page size when
	moving from relro to non-relro section.
	(Output_segment::set_offset): Align memsz of a PT_GNU_RELRO
	segment.
	* output.h (class Output_section): Add is_relro_ and
	is_relro_local_ fields.
	(Output_section::is_relro): New function.
	(Output_section::set_is_relro): New function.
	(Output_section::is_relro_local): New function.
	(Output_section::set_is_relro_local): New function.
	(class Output_segment): Update declarations.
	* i386.cc (Target_i386::got_section): Mark .got section as relro.
	* sparc.cc (Target_sparc::got_section): Likewise.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/relro_test_main.cc: New file.
	* testsuite/relro_test.cc: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_test.
	(relro_test_SOURCES, relro_test_DEPENDENCIES): New variables.
	(relro_test_LDFLAGS, relro_test_LDADD): New variables.
	(relro_test.so, relro_test_pic.o): New targets.
	* testsuite/Makefile.in: Rebuild.
@
text
@d449 1
a449 1
      this->got_plt_ = new Output_data_space(8);
d529 5
@


1.68
log
@	* i386.cc (Target_i386::Relocate::relocate_tls): Set dynamic type
	for TLS_GOTDESC and TLS_DESC_CALL.  Only optimize TLS_LDO_32 if we
	know the dynamic type.
	* x86_64.cc (Target_x86_64::Relocate): Add saw_tls_block_reloc_
	field.  Initialize it in constructor.
	(Target_x86_64::Relocate::relocate_tls): Record that we saw a TLS
	block reloc for TLSGD, GOTPC32_TLSDESC, TLSDESC_CALL, and TLSLD.
	Only optimize DTPOFF32 and DTPOFF64 if we have seen a TLS block
	reloc.
@
text
@d438 6
a443 3
      layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
				      elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE,
				      this->got_);
d450 5
a454 3
      layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
				      elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE,
				      this->got_plt_);
@


1.67
log
@	* output.cc (Output_reloc::get_address): Change return type to
	Elf_Addr.
	* output.h (class Output_reloc): Update get_address declaration.
	* x86_64.cc (Output_data_plt_x86_64::do_write): Use 64-bit types
	for section addresses.
@
text
@d200 1
a200 1
      : skip_call_tls_get_addr_(false)
d291 6
d1906 1
d1957 1
d2011 1
d2038 8
a2045 1
        value -= tls_segment->memsz();
d2052 5
a2056 1
        value -= tls_segment->memsz();
@


1.66
log
@2008-05-05  Ian Lance Taylor  <iant@@google.com>

	* options.h (DEFINE_bool): For DASH_Z, create the negative option
	as noVARNAME rather than no-VARNAME.
	(class General_options): Add option -z combreloc.
	* output.h (class Output_reloc) [SHT_REL]: Declare compare and
	get_address.
	(Output_reloc::sort_before) [SHT_REL]: New function.
	(Output_reloc::sort_before) [SHT_RELA]: New function.
	(class Output_data_reloc_base): Add sort_relocs_ field.  Define
	Sort_relocs_comparison.
	(Output_data_reloc_base::Output_data_reloc_base): Add sort_relocs
	parameter.  Change all callers.
	(Output_data_reloc::Output_data_reloc) [both versions]: Add
	sort_relocs parameter.  Change all callers.
	* output.cc (Output_reloc::get_address): New function, broken out
	of write_rel.
	(Output_reloc::write_rel): Call it.
	(Output_reloc::compare): New function.
	(Output_data_reloc_base::do_write): Optionally sort relocs.
@
text
@d675 1
a675 1
  elfcpp::Elf_types<32>::Elf_Addr plt_address = this->address();
d677 1
a677 1
  elfcpp::Elf_types<32>::Elf_Addr got_base = this->got_->address();
d681 1
a681 1
  elfcpp::Elf_types<32>::Elf_Addr got_address = this->got_plt_->address();
d685 6
a690 4
  elfcpp::Swap_unaligned<32, false>::writeval(pov + 2, got_address + 8
					      - (plt_address + 6));
  elfcpp::Swap<32, false>::writeval(pov + 8, got_address + 16
				    - (plt_address + 12));
@


1.65
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d468 1
a468 1
      this->rela_dyn_ = new Reloc_section();
d563 1
a563 1
  this->rel_ = new Reloc_section();
@


1.64
log
@	* i386.cc (Target_i386::define_tls_base_symbol): New function.
	(Target_i386::tls_base_symbol_defined_): New field.
	(Target_i386::Scan::local): Define _TLS_MODULE_BASE_ symbol.
	(Target_i386::Scan::global): Likewise.
	* symtab.cc (sized_finalize_symbol): Add check for TLS symbol.
	* x86_64.cc (Target_x86_64::define_tls_base_symbol): New function.
	(Target_x86_64::tls_base_symbol_defined_): New field.
	(Target_x86_64::Scan::local): Define _TLS_MODULE_BASE_ symbol.
	(Target_x86_64::Scan::global): Likewise.
@
text
@d1001 1
d1003 3
a1005 6
            {
              unsigned int r_sym = elfcpp::elf_r_sym<64>(reloc.get_r_info());
              rela_dyn->add_local(object, r_sym, r_type, output_section,
                                  data_shndx, reloc.get_r_offset(),
                                  reloc.get_r_addend());
            }
d1009 12
a1020 4
              rela_dyn->add_local_section(object, lsym.get_st_shndx(),
                                          r_type, output_section,
                                          data_shndx, reloc.get_r_offset(),
                                          reloc.get_r_addend());
d1118 12
a1129 5
                got->add_local_pair_with_rela(object, r_sym,
                                              lsym.get_st_shndx(),
                                              GOT_TYPE_TLS_PAIR,
                                              target->rela_dyn_section(layout),
                                              elfcpp::R_X86_64_DTPMOD64, 0);
d1146 12
a1157 5
                got->add_local_pair_with_rela(object, r_sym,
                                              lsym.get_st_shndx(),
                                              GOT_TYPE_TLS_DESC,
                                              target->rela_dyn_section(layout),
                                              elfcpp::R_X86_64_TLSDESC, 0);
@


1.63
log
@	* copy-relocs.cc: New file.
	* copy-relocs.h: New file.
	* reloc.cc: Remove Copy_relocs code.
	* reloc.h: Likewise.
	* reloc-types.h (struct Reloc_types) [both versions]: Add
	get_reloc_addend_noerror.
	* output.h (class Output_data_reloc<elfcpp::SHT_REL>): Add
	variants of add_global which take an addend which must be zero.
	* i386.cc: Include "copy-relocs.h".
	(class Target_i386): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_i386::copy_reloc): Rewrite to pass to Copy_relocs class.
	Change all callers.
	(Target_i386::do_finalize_sections): Change handling of
	copy_relocs_.
	* sparc.cc: Include "copy-relocs.h".
	(class Target_sparc): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_sparc::copy_reloc): Rewrite to pass to Copy_relocs class.
	Change all callers.
	(Target_sparc::do_finalize_sections): Change handling of
	copy_relocs_.
	* x86_64.cc: Include "copy-relocs.h".
	(class Target_x86_64): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_x86_64::copy_reloc): Rewrite to pass to Copy_relocs
	class.  Change all callers.
	(Target_x86_64::do_finalize_sections): Change handling of
	copy_relocs_.
	* Makefile.am (CCFILES): Add copy-relocs.cc.
	(HFILES): Add copy-relocs.h.
@
text
@d66 1
a66 1
      got_mod_index_offset_(-1U)
d327 4
d401 2
d780 21
d1123 1
d1424 1
@


1.62
log
@	* i386.cc (Target_i386::got_mod_index_entry): Restore code previously
	thought unnecessary.
	* x86_64.cc (Target_x86_64::got_mod_index_entry): Likewise.
@
text
@d35 1
d65 2
a66 1
      copy_relocs_(NULL), dynbss_(NULL), got_mod_index_offset_(-1U)
d359 1
a359 1
  // Copy a relocation against a global symbol.
d361 9
a369 3
  copy_reloc(const General_options*, Symbol_table*, Layout*,
	     Sized_relobj<64, false>*, unsigned int,
	     Output_section*, Symbol*, const elfcpp::Rela<64, false>&);
d392 1
a392 1
  Copy_relocs<64, false>* copy_relocs_;
a813 81
// Handle a relocation against a non-function symbol defined in a
// dynamic object.  The traditional way to handle this is to generate
// a COPY relocation to copy the variable at runtime from the shared
// object into the executable's data segment.  However, this is
// undesirable in general, as if the size of the object changes in the
// dynamic object, the executable will no longer work correctly.  If
// this relocation is in a writable section, then we can create a
// dynamic reloc and the dynamic linker will resolve it to the correct
// address at runtime.  However, we do not want do that if the
// relocation is in a read-only section, as it would prevent the
// readonly segment from being shared.  And if we have to eventually
// generate a COPY reloc, then any dynamic relocations will be
// useless.  So this means that if this is a writable section, we need
// to save the relocation until we see whether we have to create a
// COPY relocation for this symbol for any other relocation.

void
Target_x86_64::copy_reloc(const General_options* options,
                          Symbol_table* symtab,
                          Layout* layout,
                          Sized_relobj<64, false>* object,
                          unsigned int data_shndx,
                          Output_section* output_section,
                          Symbol* gsym,
                          const elfcpp::Rela<64, false>& rela)
{
  Sized_symbol<64>* ssym = symtab->get_sized_symbol<64>(gsym);

  if (!Copy_relocs<64, false>::need_copy_reloc(options, object,
					       data_shndx, ssym))
    {
      // So far we do not need a COPY reloc.  Save this relocation.
      // If it turns out that we never need a COPY reloc for this
      // symbol, then we will emit the relocation.
      if (this->copy_relocs_ == NULL)
	this->copy_relocs_ = new Copy_relocs<64, false>();
      this->copy_relocs_->save(ssym, object, data_shndx, output_section, rela);
    }
  else
    {
      // Allocate space for this symbol in the .bss section.

      elfcpp::Elf_types<64>::Elf_WXword symsize = ssym->symsize();

      // There is no defined way to determine the required alignment
      // of the symbol.  We pick the alignment based on the size.  We
      // set an arbitrary maximum of 256.
      unsigned int align;
      for (align = 1; align < 512; align <<= 1)
	if ((symsize & align) != 0)
	  break;

      if (this->dynbss_ == NULL)
	{
	  this->dynbss_ = new Output_data_space(align);
	  layout->add_output_section_data(".bss",
					  elfcpp::SHT_NOBITS,
					  (elfcpp::SHF_ALLOC
					   | elfcpp::SHF_WRITE),
					  this->dynbss_);
	}

      Output_data_space* dynbss = this->dynbss_;

      if (align > dynbss->addralign())
	dynbss->set_space_alignment(align);

      section_size_type dynbss_size = dynbss->current_data_size();
      dynbss_size = align_address(dynbss_size, align);
      section_size_type offset = dynbss_size;
      dynbss->set_current_data_size(dynbss_size + symsize);

      symtab->define_with_copy_reloc(ssym, dynbss, offset);

      // Add the COPY reloc.
      Reloc_section* rela_dyn = this->rela_dyn_section(layout);
      rela_dyn->add_global(ssym, elfcpp::R_X86_64_COPY, dynbss, offset, 0);
    }
}


d1184 1
a1184 1
Target_x86_64::Scan::global(const General_options& options,
d1224 1
a1224 1
                target->copy_reloc(&options, symtab, layout, object,
d1264 1
a1264 1
                target->copy_reloc(&options, symtab, layout, object,
d1563 2
a1564 9
  if (this->copy_relocs_ == NULL)
    return;
  if (this->copy_relocs_->any_to_emit())
    {
      Reloc_section* rela_dyn = this->rela_dyn_section(layout);
      this->copy_relocs_->emit(rela_dyn);
    }
  delete this->copy_relocs_;
  this->copy_relocs_ = NULL;
@


1.61
log
@2008-04-11  Cary Coutant  <ccoutant@@google.com>

	Add support for TLS descriptors for i386 and x86_64.
	* i386.cc (Target_i386::Relocate::tls_desc_gd_to_ie): New function.
	(Target_i386::Relocate::tls_desc_gd_to_le): New function.
	(Target_i386::Got_type): Add GOT_TYPE_TLS_NOFFSET and
	GOT_TYPE_TLS_DESC.
	(Target_i386::got_mod_index_entry): Remove unnecessary code.
	(Target_i386::Scan::local): Implement R_386_TLS_GOTDESC and
	R_386_TLS_DESC_CALL relocations.  Fix problem with initial-exec
	relocations.
	(Target_i386::Scan::global): Fix problem with GD-to-IE relaxation.
	Implement R_386_TLS_GOTDESC and R_386_TLS_DESC_CALL relocations;
	Fix problem with initial-exec relocations.
	(Target_i386::Relocate::relocate_tls): Likewise.
	(Target_i386::Relocate::tls_gd_to_ie): Fix problem with GD-to-IE
	relaxation.
	* output.cc (Output_data_dynamic::Dynamic_entry::write): Add
	support for section-plus-offset dynamic table entries.
	* output.h (Output_data_dynamic::add_section_plus_offset): New function.
	(Output_data_dynamic::Dynamic_entry): Add support for
	section-plus-offset dynamic table entries.
	(Output_data_dynamic::Classification): Likewise.
	(Output_data_dynamic::classification_): Renamed offset_.
	* x86_64.cc (Target_x86_64::Relocate::tls_desc_gd_to_ie): New function.
	(Target_x86_64::Relocate::tls_desc_gd_to_le): New function.
	(Target_x86_64::make_plt_section): New function.
	(Target_x86_64::reserve_tlsdesc_entries): New function.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Add new parameter.
	(Output_data_plt_x86_64::reserve_tlsdesc_entry): New function.
	(Output_data_plt_x86_64::has_tlsdesc_entry): New function.
	(Output_data_plt_x86_64::get_tlsdesc_got_offset): New function.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset): New function.
	(Output_data_plt_x86_64::tlsdesc_plt_entry): New field.
	(Output_data_plt_x86_64::set_final_data_size): Move out of line;
	add extra PLT entry for TLS descriptors.
	(Output_data_plt_x86_64::got_): New field.
	(Output_data_plt_x86_64::tlsdesc_got_offset_): New field.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Initialize new
	fields.
	(Output_data_plt_x86_64::do_write): Write extra PLT entry for TLS
	descriptors.
	(Target_x86_64::make_plt_entry): Factor out make_plt_section.
	(Target_x86_64::got_mod_index_entry): Remove unnecessary code.
	(Target_x86_64::Scan::local): Implement R_386_TLS_GOTDESC and
	R_386_TLS_DESC_CALL relocations.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::do_finalize_sections): Add dynamic table entries
	for TLS descriptors.
	(Relocate::relocate_tls): Fix problem with GD-to-IE relaxation.
	Implement R_386_TLS_GOTDESC and R_386_TLS_DESC_CALL relocations.
	(Target_x86_64::Relocate::tls_gd_to_ie): Fix problem with
	GD-to-IE relaxation.
	* configure.ac: Export new conditional variables TLS_GNU2_DIALECT
	and TLS_DESCRIPTORS.
	* Makefile.in: Rebuild.
	* configure: Rebuild.
	* testsuite/Makefile.am (tls_shared_gd_to_ie_test): New target.
	(tls_test_shared2.so): New target.
	(tls_shared_gd_to_ie_test_SOURCES): New variable.
	(tls_shared_gd_to_ie_test_DEPENDENCIES): New variable.
	(tls_shared_gd_to_ie_test_LDFLAGS): New variable.
	(tls_shared_gd_to_ie_test_LDADD): New variable.
	(tls_shared_gnu2_gd_to_ie_test): New target.
	(tls_test_gnu2.o, tls_test_file2_gnu2.o, tls_test_gnu2_shared2.so):
	New targets.
	(tls_shared_gnu2_gd_to_ie_test_SOURCES): New variable.
	(ls_shared_gnu2_gd_to_ie_test_DEPENDENCIES): New variable.
	(tls_shared_gnu2_gd_to_ie_test_LDFLAGS): New variable.
	(tls_shared_gnu2_gd_to_ie_test_LDADD): New variable.
	(tls_shared_gnu2_test): New target.
	(tls_test_gnu2_shared.so): New target.
	(tls_shared_gnu2_test_SOURCES): New variable.
	(tls_shared_gnu2_test_DEPENDENCIES): New variable.
	(tls_shared_gnu2_test_LDFLAGS): New variable.
	(tls_shared_gnu2_test_LDADD): New variable.
	* testsuite/Makefile.in: Rebuild.
	* testsuite/Makefile.
@
text
@d800 1
@


1.60
log
@	* options.h (class General_options): Define --wrap as a special
	option.  Add wrap_symbols_ field.
	(General_options::any_wrap_symbols): New function.
	(General_options::is_wrap_symbol): New function.
	* options.cc (General_options::parse_wrap): New function.
	(General_options::General_options): Initialize wrap_symbols_.
	* symtab.cc (Symbol_table::wrap_symbol): New function.
	(Symbol_table::add_from_object): Handle --wrap.
	* symtab.h (class Symbol_table): Declare wrap_symbol.
	* target.h (Target::wrap_char): New function.
	(Target::Target_info): Add wrap_char field.
	* i386.cc (Target_i386::i386_info): Initialize wrap_char.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Likewise.
@
text
@d230 1
a230 1
    // Do a TLS General-Dynamic to Local-Exec transition.
d237 1
d249 19
d317 4
d325 4
d387 1
a387 1
  // Offset of the GOT entry for the TLS module index;
d468 2
a469 1
  Output_data_plt_x86_64(Layout*, Output_data_space*);
d475 20
d516 3
d521 1
a521 2
  set_final_data_size()
  { this->set_data_size((this->count_ + 1) * plt_entry_size); }
d529 2
d535 2
d544 1
d546 2
a547 1
  : Output_section_data(8), got_plt_(got_plt), count_(0)
d592 10
d627 14
d660 1
d662 5
d708 17
d732 1
a732 1
// Create a PLT entry for a global symbol.
d735 1
a735 2
Target_x86_64::make_plt_entry(Symbol_table* symtab, Layout* layout,
                              Symbol* gsym)
a736 3
  if (gsym->has_plt_offset())
    return;

d742 2
a743 1
      this->plt_ = new Output_data_plt_x86_64(layout, this->got_plt_);
d749 13
d766 20
a799 1
      got->add_constant(0);
d1168 19
a1187 4
	    // FIXME: If not relaxing to LE, we need to generate
	    // a GOT entry with a R_x86_64_TLSDESC reloc.
	    if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_local(object, r_type);
d1468 25
a1493 4
	    // FIXME: If not relaxing to LE, we need to generate
	    // DTPMOD64 and DTPOFF64, or TLSDESC, relocs.
	    if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_global(object, r_type, gsym);
d1604 10
a1927 2
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // Global-dynamic (from ~oliva url)
    case elfcpp::R_X86_64_TLSDESC_CALL:
d1938 3
d1944 2
a1945 3
              gold_assert(gsym->has_got_offset(GOT_TYPE_TLS_PAIR));
              got_offset = (gsym->got_offset(GOT_TYPE_TLS_PAIR)
                            - target->got_size());
d1950 2
a1951 3
              gold_assert(object->local_has_got_offset(r_sym,
                          GOT_TYPE_TLS_PAIR));
              got_offset = (object->local_got_offset(r_sym, GOT_TYPE_TLS_PAIR)
d1957 1
d1959 1
a1959 1
                                 got_offset, view, view_size);
d1976 54
d2118 1
a2118 1
                                      Output_segment* tls_segment,
d2123 1
d2140 2
a2141 2
  value -= tls_segment->memsz();
  Relocate_functions<64, false>::rela32(view + 8, value, 0);
d2183 78
@


1.59
log
@	* x86_64.cc (Target_x86_64::Scan): Change from struct to class.
	Add issued_non_pic_error_ field.  Declare check_non_pic.
	(Target_x86_64::Scan::check_non_pic): New function.
	(Target_x86_64::Scan::local): Call check_non_pic as appropriate.
	(Target_x86_64::Scan::global): Likewise.
@
text
@d372 1
@


1.58
log
@	PR gold/5986
	Fix problems building gold with gcc 4.3.0.
	* gold.h (TEMPLATE_ATTRIBUTE_PRINTF_4): Define.
	(gold_error_at_location, gold_warning_at_location): Use it.
	* configure.ac: Check whether we can compile and use a template
	function with a printf attribute.
	* x86_64.cc (Target_x86_64::do_code_fill): Swap out a 32-bit value
	when jumping over bytes.
	* object.cc: Instantiate Object::read_section_data.
	* debug.h: Include <cstring>
	* dwarf_reader.cc: Include <algorithm>
	* main.cc: Include <cstring>.
	* options.cc: Include <cstring>.
	* output.cc: Include <cstring>.
	* script.cc: Include <cstring>.
	* script.h: Include <string>.
	* symtab.cc: Include <cstring> and <algorithm>.
	* target-select.cc: Include <cstring>.
	* version.cc: Include <string>.
	* testsuite/testmain.cc: Include <cstdlib>.
	* configure, config.in: Rebuild.
@
text
@d153 1
a153 1
  struct Scan
d155 5
d178 1
d185 6
d817 42
d909 2
d974 2
d1161 1
d1192 1
@


1.57
log
@	* options.cc (options::help): Print list of supported targets.
	* target-select.h: Include <vector>.
	(class Target_selector): Make machine_, size_, and is_big_endian_
	fields const.  Add bfd_name_ and instantiated_target_ fields.
	(Target_selector::Target_selector): Add bfd_name parameter.
	(Target_selector::recognize): Make non-virtual, call
	do_recognize.
	(Target_selector::recognize_by_name): Make non-virtual, call
	do_recognize_by_name.
	(Target_selector::supported_names): New function.
	(Target_selector::bfd_name): New function.
	(Target_selector::do_instantiate_target): New pure virtual
	function.
	(Target_selector::do_recognize): New virtual function.
	(Target_selector::do_recognize_by_name): New virtual function.
	(Target_selector::instantiate_target): New private function.
	(supported_target_names): Declare.
	* target-select.cc (Target_selector::Target_selector): Update for
	new parameter and fields.
	(select_target_by_name): Check that the name matches before
	calling recognize_by_name.
	(supported_target_names): New function.
	* i386.cc (class Target_selector_i386): Update Target_selector
	constructor call.  Remove recognize and recognize_by_name.  Add
	do_instantiate_target.
	* x86_64.cc (class Target_selector_x86_64): Likewise.
	* testsuite/testfile.cc (class Target_selector_test): Update for
	changes to Target_selector.
@
text
@d2164 1
a2164 1
      elfcpp::Swap_unaligned<64, false>::writeval(jmp + 1, length - 5);
@


1.56
log
@	* i386.cc (Target_i386::Got_type): New enum declaration.
	(Target_i386::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocate::relocate_tls): Likewise.
	* object.h (Got_offset_list): New class.
	(Sized_relobj::local_has_got_offset): Added got_type parameter.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::local_has_tls_got_offset): Removed.
	(Sized_relobj::local_tls_got_offset): Removed.
	(Sized_relobj::set_local_tls_got_offset): Removed.
	(Sized_relobj::Local_got_offsets): Changed to store a list of offsets.
	* output.cc (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* output.h (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* resolve.cc (Symbol::override_base_with_special): Removed
	reference to has_got_offset_ field.
	* symtab.cc (Symbol::init_fields): Replaced initialization
	of got_offset_ with got_offsets_.  Removed initialization
	of has_got_offset_
	*symtab.h (Symbol::has_got_offset): Aded got_type parameter.
	(Symbol::got_offset): Likewise.
	(Symbol::set_got_offset): Likewise.
	(Symbol::has_tls_got_offset): Removed.
	(Symbol::tls_got_offset): Removed.
	(Symbol::set_tls_got_offset): Removed.
	(Symbol::got_offset_): Removed.
	(Symbol::tls_mod_got_offset_): Removed.
	(Symbol::tls_pair_got_offset_): Removed.
	(Symbol::got_offsets_): New field.
	(Symbol::has_got_offset): Removed.
	(Symbol::has_tls_mod_got_offset): Removed.
	(Symbol::has_tls_pair_got_offset): Removed.
	* x86_64.cc (Target_x86_64::Got_type): New enum declaration.
	(Target_x86_64::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocate::relocate_tls): Likewise.
@
text
@d2222 1
a2222 1
    : Target_selector(elfcpp::EM_X86_64, 64, false)
d2226 2
a2227 7
  recognize(int machine, int osabi, int abiversion);

  Target*
  recognize_by_name(const char*);

 private:
  Target_x86_64* target_;
a2229 21
// Recognize an x86_64 object file when we already know that the machine
// number is EM_X86_64.

Target*
Target_selector_x86_64::recognize(int, int, int)
{
  if (this->target_ == NULL)
    this->target_ = new Target_x86_64();
  return this->target_;
}

Target*
Target_selector_x86_64::recognize_by_name(const char* name)
{
  if (strcmp(name, "elf64-x86-64") != 0)
    return NULL;
  if (this->target_ == NULL)
    this->target_ = new Target_x86_64();
  return this->target_;
}

@


1.55
log
@	* x86_64.cc: Correct license to GPLv3.
@
text
@d327 8
d904 1
a904 1
        if (got->add_local(object, r_sym))
d913 3
a915 4
                  rela_dyn->add_local_relative(object, r_sym,
                                               elfcpp::R_X86_64_RELATIVE, got,
                                               object->local_got_offset(r_sym),
                                               0);
d919 3
a921 3
                    rela_dyn->add_local(object, r_sym, r_type,
                                        got, object->local_got_offset(r_sym),
                                        0);
d965 5
a969 4
                got->add_local_tls_with_rela(object, r_sym,
                                             lsym.get_st_shndx(), true,
                                             target->rela_dyn_section(layout),
                                             elfcpp::R_X86_64_DTPMOD64);
d1005 1
a1005 1
	        got->add_local_with_rela(object, r_sym,
d1151 1
a1151 1
          got->add_global(gsym);
d1160 1
a1160 1
              got->add_global_with_rela(gsym, rela_dyn,
d1164 4
a1167 4
                if (got->add_global(gsym))
                  rela_dyn->add_global_relative(gsym,
                                                elfcpp::R_X86_64_RELATIVE,
                                                got, gsym->got_offset(), 0);
d1240 4
a1243 4
                got->add_global_tls_with_rela(gsym,
                                              target->rela_dyn_section(layout),
                                              elfcpp::R_X86_64_DTPMOD64,
                                              elfcpp::R_X86_64_DTPOFF64);
d1250 1
a1250 1
                got->add_global_with_rela(gsym,
d1287 1
a1287 1
	        got->add_global_with_rela(gsym,
d1467 2
a1468 2
          gold_assert(gsym->has_got_offset());
          got_offset = gsym->got_offset() - target->got_size();
d1473 3
a1475 2
          gold_assert(object->local_has_got_offset(r_sym));
          got_offset = object->local_got_offset(r_sym) - target->got_size();
d1703 3
a1705 2
              gold_assert(gsym->has_tls_got_offset(true));
              got_offset = gsym->tls_got_offset(true) - target->got_size();
d1710 3
a1712 2
              gold_assert(object->local_has_tls_got_offset(r_sym, true));
              got_offset = (object->local_tls_got_offset(r_sym, true)
d1790 3
a1792 2
              gold_assert(gsym->has_got_offset());
              got_offset = gsym->got_offset() - target->got_size();
d1797 3
a1799 2
              gold_assert(object->local_has_got_offset(r_sym));
              got_offset = (object->local_got_offset(r_sym)
@


1.54
log
@Update copyright years.  Update language files.
@
text
@d8 3
a10 3
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Library General Public License
// as published by the Free Software Foundation; either version 2, or
d13 9
a21 18
// In addition to the permissions in the GNU Library General Public
// License, the Free Software Foundation gives you unlimited
// permission to link the compiled version of this file into
// combinations with other programs, and to distribute those
// combinations without any restriction coming from the use of this
// file.  (The Library Public License restrictions do apply in other
// respects; for example, they cover modification of the file, and
/// distribution when not linked into a combined executable.)

// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Library General Public License for more details.

// You should have received a copy of the GNU Library General Public
// License along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
// 02110-1301, USA.
@


1.53
log
@Remove gcc 3.2 compatibility hacks.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, Free Software Foundation, Inc.
@


1.52
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d686 1
a686 3
  Sized_symbol<64>* ssym;
  ssym = symtab->get_sized_symbol SELECT_SIZE_NAME(64) (gsym
							SELECT_SIZE(64));
@


1.51
log
@Implement -q/--emit-relocs.
@
text
@d145 1
a145 1
  do_code_fill(section_size_type length);
d321 1
a321 1
    return (!parameters->output_is_shared()
d752 1
a752 1
  if (parameters->output_is_shared())
d836 1
a836 1
      if (parameters->output_is_position_independent())
d856 1
a856 1
      if (parameters->output_is_position_independent())
d911 1
a911 1
            if (parameters->output_is_position_independent())
d956 1
a956 1
	bool output_is_shared = parameters->output_is_shared();
d1084 1
a1084 1
            if (gsym->is_from_dynobj() && !parameters->output_is_shared())
d1300 1
a1300 1
            if (parameters->output_is_shared())
d1388 1
a1388 1
      if (!parameters->output_is_shared())
d1443 1
a1443 1
          || (parameters->output_is_shared()
d1683 1
a1683 1
			 ? !parameters->output_is_position_independent()
d2155 1
a2155 1
Target_x86_64::do_code_fill(section_size_type length)
@


1.50
log
@From Craig Silverstein: implement -z max-page-size and -z
common-page-size.
@
text
@d2090 1
a2090 1
  gold::scan_relocatable_relocs<64, false, Target_x86_64, elfcpp::SHT_RELA,
d2125 1
a2125 1
  gold::relocate_for_relocatable<64, false, Target_x86_64, elfcpp::SHT_RELA>(
@


1.49
log
@Support selecting target by name.
@
text
@d363 2
a364 2
  0x1000,		// abi_pagesize
  0x1000		// common_pagesize
@


1.48
log
@Support dynamic relocations against local section symbols.
@
text
@d2226 3
d2239 10
@


1.47
log
@From Cary Coutant: fix handling of undefined symbols in shared
libraries.
@
text
@d831 4
a834 4
      // executable), we need to create a dynamic relocation for
      // this location. The relocation applied at link time will
      // apply the link-time value, so we flag the location with
      // an R_386_RELATIVE relocation so the dynamic loader can
d853 3
a855 5
      // executable), we need to create a dynamic relocation for
      // this location. The relocation applied at link time will
      // apply the link-time value, so we flag the location with
      // an R_386_RELATIVE relocation so the dynamic loader can
      // relocate it easily.
d859 15
a873 4
          unsigned int r_sym = elfcpp::elf_r_sym<64>(reloc.get_r_info());
          rela_dyn->add_local(object, r_sym, r_type, output_section,
                              data_shndx, reloc.get_r_offset(),
                              reloc.get_r_addend());
d921 6
a926 2
                  rela_dyn->add_local(object, r_sym, r_type,
                                      got, object->local_got_offset(r_sym), 0);
@


1.46
log
@Initial -r support.
@
text
@d1147 3
a1149 1
            if (gsym->is_from_dynobj() || gsym->is_preemptible())
d1431 1
a1431 1
              && gsym->is_preemptible()))
@


1.45
log
@From Cary Coutant: Fix a case in which code takes the address of a
function and also calls it directly.
@
text
@d112 31
d268 9
d1982 140
@


1.44
log
@Don't pass around the target in order to define symbols; get it from
the parameters instead.
@
text
@d1031 1
a1031 1
            if (gsym->is_from_dynobj())
@


1.43
log
@From Cary Coutant: Fix mixing PIC and non-PIC relocs in the same
shared library.
@
text
@d355 1
a355 1
      symtab->define_in_output_data(this, "_GLOBAL_OFFSET_TABLE_", NULL,
d694 1
a694 1
      symtab->define_with_copy_reloc(this, ssym, dynbss, offset);
@


1.42
log
@From Cary Coutant: Fix handling of versioned symbols, add some tests.
@
text
@d1035 1
a1035 1
        if (gsym->needs_dynamic_reloc(true, false))
d1071 4
a1074 2
        bool is_function_call = (gsym->type() == elfcpp::STT_FUNC);
        if (gsym->needs_dynamic_reloc(false, is_function_call))
@


1.41
log
@Convert more instances of off_t to be 32-bit types.
@
text
@d1486 4
a1489 1
		  || gsym->final_value_is_known());
@


1.40
log
@From Cary Coutant: Set DF_STATIC_TLS as appropriate.
@
text
@d110 1
a110 1
		   off_t view_size);
d114 1
a114 1
  do_code_fill(off_t length);
d122 1
a122 1
  off_t
d184 1
a184 1
	     off_t);
d193 2
a194 1
		 unsigned char*, elfcpp::Elf_types<64>::Elf_Addr, off_t);
d203 1
a203 1
		 off_t view_size);
d212 1
a212 1
		 off_t view_size);
d221 1
a221 1
		 off_t view_size);
d230 1
a230 1
		 off_t view_size);
d466 1
a466 1
  off_t got_offset = this->got_plt_->current_data_size();
d515 2
a516 1
  const off_t oview_size = this->data_size();
d520 2
a521 1
  const off_t got_size = this->got_plt_->data_size();
d569 2
a570 2
  gold_assert(pov - oview == oview_size);
  gold_assert(got_pov - got_view == got_size);
d689 1
a689 1
      off_t dynbss_size = dynbss->current_data_size();
d691 1
a691 1
      off_t offset = dynbss_size;
d1364 1
a1364 1
                                  off_t view_size)
d1613 1
a1613 1
                                      off_t view_size)
d1767 1
a1767 1
                                      off_t view_size)
d1802 1
a1802 1
                                      off_t view_size)
d1834 1
a1834 1
                                      off_t view_size)
d1866 1
a1866 1
                                      off_t view_size)
d1922 1
a1922 1
                                off_t view_size)
d1955 1
a1955 1
Target_x86_64::do_code_fill(off_t length)
@


1.39
log
@From Cary Coutant: Fix x86_64 TLS problem.
@
text
@d945 1
d961 1
d1224 1
d1239 1
@


1.38
log
@From Cary Coutant: Fix x86_64 TLS.  Also set DT_TEXTREL as well as
DF_TEXTREL.
@
text
@d73 1
a73 1
      copy_relocs_(NULL), dynbss_(NULL)
d257 5
d307 2
d597 20
d934 1
a934 7
	        Output_data_got<64, false>* got
	            = target->got_section(symtab, layout);
	        unsigned int r_sym = elfcpp::elf_r_sym<64>(reloc.get_r_info());
                got->add_local_tls_with_rela(object, r_sym,
                                             lsym.get_st_shndx(), false,
                                             target->rela_dyn_section(layout),
                                             elfcpp::R_X86_64_DTPMOD64);
d1211 1
a1211 5
	        Output_data_got<64, false>* got
	            = target->got_section(symtab, layout);
                got->add_global_tls_with_rela(gsym,
                                              target->rela_dyn_section(layout),
                                              elfcpp::R_X86_64_DTPMOD64);
d1682 2
a1683 12
          if (gsym != NULL)
            {
              gold_assert(gsym->has_tls_got_offset(false));
              got_offset = gsym->tls_got_offset(false) - target->got_size();
            }
          else
            {
              unsigned int r_sym = elfcpp::elf_r_sym<64>(rela.get_r_info());
              gold_assert(object->local_has_tls_got_offset(r_sym, false));
              got_offset = (object->local_tls_got_offset(r_sym, false)
                            - target->got_size());
            }
@


1.37
log
@From Cary Coutant: Fix handling of RELATIVE RELA relocs.
@
text
@d1588 1
a1588 1
                                      elfcpp::Elf_types<64>::Elf_Addr,
d1594 1
d1642 3
a1644 1
              Relocate_functions<64, false>::rel64(view, got_offset);
d1677 3
a1679 1
          Relocate_functions<64, false>::rel64(view, got_offset);
d1689 2
a1690 4
        value = value - (tls_segment->vaddr() + tls_segment->memsz());
      else
        value = value - tls_segment->vaddr();
      Relocate_functions<64, false>::rel32(view, value);
d1696 2
a1697 4
        value = value - (tls_segment->vaddr() + tls_segment->memsz());
      else
        value = value - tls_segment->vaddr();
      Relocate_functions<64, false>::rel64(view, value);
d1726 2
a1727 1
          Relocate_functions<64, false>::rel64(view, got_offset);
d1736 2
a1737 2
      value = value - (tls_segment->vaddr() + tls_segment->memsz());
      Relocate_functions<64, false>::rel32(view, value);
d1769 1
a1769 1
  value = value - (tls_segment->vaddr() + tls_segment->memsz());
d1804 1
a1804 1
  value = value - (tls_segment->vaddr() + tls_segment->memsz());
d1893 1
a1893 1
  value = value - (tls_segment->vaddr() + tls_segment->memsz());
@


1.36
log
@From Cary Coutant: Some x86_64 shared library fixes.
@
text
@d768 1
d770 5
a774 3
          rela_dyn->add_local(object, 0, elfcpp::R_X86_64_RELATIVE,
                              output_section, data_shndx,
                              reloc.get_r_offset(), 0);
d837 4
a840 2
                  rela_dyn->add_local(object, 0, elfcpp::R_X86_64_RELATIVE,
                                      got, object->local_got_offset(r_sym), 0);
d1020 4
a1023 3
                rela_dyn->add_local(object, 0, elfcpp::R_X86_64_RELATIVE,
                                    output_section, data_shndx,
                                    reloc.get_r_offset(), 0);
d1085 3
a1087 6
                  {
                    rela_dyn->add_local(object, 0, elfcpp::R_X86_64_RELATIVE,
                                        got, gsym->got_offset(), 0);
                    // Make sure we write the link-time value to the GOT.
                    gsym->set_needs_value_in_got();
                  }
@


1.35
log
@From Cary Coutant: More support for generating shared libraries.
@
text
@d481 1
a481 1
  0, 0, 0, 0,	// replaced with address of .got + 4
d483 1
a483 1
  0, 0, 0, 0,	// replaced with address of .got + 8
d521 5
a525 8
  if (!parameters->output_is_shared())
    {
      // We do a jmp relative to the PC at the end of this instruction.
      elfcpp::Swap_unaligned<32, false>::writeval(pov + 2, got_address + 8
                                                  - (plt_address + 6));
      elfcpp::Swap<32, false>::writeval(pov + 8, got_address + 16
                                        - (plt_address + 12));
    }
d546 4
a549 8
      if (parameters->output_is_shared())
        // FIXME(csilvers): what's the right thing to write here?
        elfcpp::Swap_unaligned<32, false>::writeval(pov + 2, got_offset);
      else
        elfcpp::Swap_unaligned<32, false>::writeval(pov + 2,
                                                    (got_address + got_offset
                                                     - (plt_address + plt_offset
                                                        + 6)));
d1040 1
a1040 1
        if (gsym->needs_dynamic_reloc(true, is_function_call))
@


1.34
log
@Clean up setting address and section offset.
@
text
@d189 2
a190 2
    relocate_tls(const Relocate_info<64, false>*, size_t relnum,
		 const elfcpp::Rela<64, false>&,
d197 9
d757 1
a757 1
                           const elfcpp::Sym<64, false>&)
d835 1
a835 1
            // dynamic RELATIVE relocation for this symbol.
a837 3
		// FIXME: R_X86_64_RELATIVE assumes a 64-bit relocation.
		gold_assert(r_type != elfcpp::R_X86_64_GOT32);

d839 7
a845 3
                rela_dyn->add_local(object, 0, elfcpp::R_X86_64_RELATIVE,
                                    output_section, data_shndx,
                                    reloc.get_r_offset(), 0);
d881 16
d900 1
a900 1
	    // DTPMOD64 and DTPOFF64 relocs.
d906 15
a922 4
	    // FIXME: If not relaxing to LE, we need to generate a
	    // DTPMOD64 reloc.
	    if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_local(object, r_type);
d926 11
a936 3
            // FIXME: If not relaxing to LE, we need to generate a
            // TPOFF64 reloc.
            if (optimized_type != tls::TLSOPT_TO_LE)
d941 2
a942 3
	    // FIXME: If generating a shared object, we need to copy
	    // this relocation into the object.
	    gold_assert(!output_is_shared);
d1015 2
a1016 2
                target->copy_reloc(&options, symtab, layout, object, data_shndx,
                                   output_section, gsym, reloc);
d1051 2
a1052 2
                target->copy_reloc(&options, symtab, layout, object, data_shndx,
                                   output_section, gsym, reloc);
d1073 4
a1076 2
        if (got->add_global(gsym))
	  {
d1079 5
a1083 1
            if (!gsym->final_value_is_known())
d1085 1
a1085 6
                Reloc_section* rela_dyn = target->rela_dyn_section(layout);
                if (gsym->is_from_dynobj()
		    || gsym->is_preemptible())
                  rela_dyn->add_global(gsym, elfcpp::R_X86_64_GLOB_DAT, got,
                                       gsym->got_offset(), 0);
                else
d1158 24
d1191 13
a1205 4
	    // FIXME: If not relaxing to LE, we need to generate a
	    // DTPMOD64 reloc.
	    if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_global(object, r_type, gsym);
d1209 10
a1218 3
            // FIXME: If not relaxing to LE, we need to generate a
            // TPOFF64 reloc.
            if (optimized_type != tls::TLSOPT_TO_LE)
d1223 2
a1224 3
	    // FIXME: If generating a shared object, we need to copy
	    // this relocation into the object.
	    gold_assert(is_final);
d1399 1
d1565 2
a1566 2
      this->relocate_tls(relinfo, relnum, rela, r_type, gsym, psymval, view,
			 address, view_size);
d1585 1
d1596 2
a1597 6
  if (tls_segment == NULL)
    {
      gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			     _("TLS reloc but no TLS segment"));
      return;
    }
d1613 1
d1619 30
d1656 1
d1661 20
d1686 1
d1695 1
d1706 1
d1712 20
d1742 35
@


1.33
log
@From Cary Coutant: Count textrel with output sections rather than
setting a flag as we add each reloc in the target code.
@
text
@d335 1
a335 1
      this->got_plt_->set_space_size(3 * 8);
d400 1
a400 1
  do_set_address(uint64_t, off_t)
d449 1
a449 1
  off_t got_offset = this->got_plt_->data_size();
d454 1
a454 1
  this->got_plt_->set_space_size(got_offset + 8);
d657 1
a657 1
      off_t dynbss_size = dynbss->data_size();
d660 1
a660 1
      dynbss->set_space_size(dynbss_size + symsize);
@


1.32
log
@From Craig Silverstein: Add support for --demangle.
@
text
@d275 1
a275 1
	     Symbol*, const elfcpp::Rela<64, false>&);
d609 3
a611 1
                          unsigned int data_shndx, Symbol* gsym,
d626 1
a626 1
      this->copy_relocs_->save(ssym, object, data_shndx, rela);
d745 1
a745 1
                           Output_section*,
d768 2
a769 1
                              data_shndx, reloc.get_r_offset(), 0);
d787 2
a788 2
          rela_dyn->add_local(object, r_sym, r_type, data_shndx,
                              reloc.get_r_offset(),
d834 2
a835 1
                                    data_shndx, reloc.get_r_offset(), 0);
d937 1
a937 1
                            Output_section*,
d972 1
a972 1
                                   gsym, reloc);
d979 1
a979 1
                                    data_shndx,
d985 2
a986 2
                rela_dyn->add_global(gsym, r_type, object, data_shndx, 
                                     reloc.get_r_offset(),
d1008 1
a1008 1
                                   gsym, reloc);
d1013 2
a1014 2
                rela_dyn->add_global(gsym, r_type, object, data_shndx, 
                                     reloc.get_r_offset(),
@


1.31
log
@From Cary Coutant: Improve i386 shared library TLS support.
@
text
@d921 1
a921 1
	     object->name().c_str(), r_type, gsym->name());
d1149 2
a1150 1
		 object->name().c_str(), r_type, gsym->name());
@


1.30
log
@Add heuristics for undefined symbol warnings.
@
text
@d138 1
d147 1
d743 1
d933 1
@


1.29
log
@Revert last patch.
@
text
@d116 5
@


1.28
log
@Support special always-defined symbols for targets.
@
text
@a99 5
  // Return whether SYM is always defined.
  bool
  do_is_always_defined(Symbol* sym) const
  { return strcmp(sym->name(), "__tls_get_addr") == 0; }

@


1.27
log
@Correct handling of GOT references in a regular object.
@
text
@d100 5
@


1.26
log
@From Cary Coutant: More shared library support, some refactorization.
@
text
@d1023 2
a1024 1
                if (gsym->is_preemptible())
@


1.25
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d253 11
d748 14
d775 4
a778 10
          if (r_type == elfcpp::R_X86_64_64)
            rela_dyn->add_local(object, 0, elfcpp::R_X86_64_RELATIVE,
                                data_shndx, reloc.get_r_offset(), 0);
          else
            {
              unsigned int r_sym = elfcpp::elf_r_sym<64>(reloc.get_r_info());
              rela_dyn->add_local(object, r_sym, r_type, data_shndx,
                                  reloc.get_r_offset(),
                                  reloc.get_r_addend());
            }
a936 1
    case elfcpp::R_X86_64_PC64:
a938 1
    case elfcpp::R_X86_64_PC32:
a939 1
    case elfcpp::R_X86_64_PC16:
a940 1
    case elfcpp::R_X86_64_PC8:
d942 29
a970 41
        bool is_pcrel = (r_type == elfcpp::R_X86_64_PC64
		         || r_type == elfcpp::R_X86_64_PC32
		         || r_type == elfcpp::R_X86_64_PC16
		         || r_type == elfcpp::R_X86_64_PC8);

        if (gsym->is_from_dynobj()
            || (parameters->output_is_shared()
                && gsym->is_preemptible()))
	  {
	    // (a) This symbol is defined in a dynamic object.  If it is a
	    // function, we make a PLT entry.  Otherwise we need to
	    // either generate a COPY reloc or copy this reloc.
	    // (b) We are building a shared object and this symbol is
	    // preemptible. If it is a function, we make a PLT entry.
	    // Otherwise, we copy the reloc.
	    if (gsym->type() == elfcpp::STT_FUNC)
	      {
	        target->make_plt_entry(symtab, layout, gsym);

	        // If this is not a PC relative reference, then we may
	        // be taking the address of the function.  In that case
	        // we need to set the entry in the dynamic symbol table
	        // to the address of the PLT entry. We will also need to
	        // create a dynamic relocation.
	        if (!is_pcrel)
		  {
		    if (gsym->is_from_dynobj())
		      gsym->set_needs_dynsym_value();
                    if (parameters->output_is_position_independent())
                      {
                        Reloc_section* rela_dyn =
                          target->rela_dyn_section(layout);
                        rela_dyn->add_global(gsym, r_type, object, data_shndx, 
                                            reloc.get_r_offset(),
                                            reloc.get_r_addend());
                      }
		  }
	      }
	    else if (parameters->output_is_shared())
	      {
	        // We do not make COPY relocs in shared objects.
d975 16
a990 6
	      }
	    else
	      target->copy_reloc(&options, symtab, layout, object, data_shndx,
			         gsym, reloc);
	  }
        else if (!is_pcrel && parameters->output_is_position_independent())
d992 5
a996 8
            // This is not a PC-relative reference, so we need to generate
            // a dynamic relocation. At this point, we know the symbol
            // is not preemptible, so we can use the RELATIVE relocation.
            Reloc_section* rela_dyn = target->rela_dyn_section(layout);
            if (r_type == elfcpp::R_X86_64_64)
              rela_dyn->add_local(object, 0, elfcpp::R_X86_64_RELATIVE,
                                  data_shndx,
                                  reloc.get_r_offset(), 0);
d998 6
a1003 3
              rela_dyn->add_global(gsym, r_type, object, data_shndx, 
                                   reloc.get_r_offset(),
                                   reloc.get_r_addend());
d1005 1
a1005 1
	}
d1023 10
a1032 2
                rela_dyn->add_global(gsym, elfcpp::R_X86_64_GLOB_DAT, got,
                                     gsym->got_offset(), 0);
@


1.24
log
@From Cary Coutant: Correct generation of RELATIVE relocs.
@
text
@d86 2
d89 1
a89 2
	      const unsigned char* plocal_symbols,
	      Symbol** global_symbols);
d106 2
d1134 2
d1137 1
a1137 2
                           const unsigned char* plocal_symbols,
                           Symbol** global_symbols)
d1156 2
d1159 1
a1159 2
    plocal_symbols,
    global_symbols);
d1678 2
d1692 2
@


1.23
log
@From Cary Coutant: More support for -shared, including fixes to GOT
handling.
@
text
@a745 3
	  // FIXME: R_X86_64_RELATIVE assumes a 64-bit relocation.
	  gold_assert(r_type == elfcpp::R_X86_64_64);

d747 10
a756 2
          rela_dyn->add_local(object, 0, elfcpp::R_X86_64_RELATIVE,
                              data_shndx, reloc.get_r_offset(), 0);
a953 4
			// FIXME: R_X86_64_RELATIVE assumes a 64-bit
			// relocation.
			gold_assert(r_type == elfcpp::R_X86_64_64);

d956 3
a958 4
                        rela_dyn->add_local(object, 0,
                                            elfcpp::R_X86_64_RELATIVE,
                                            data_shndx,
                                            reloc.get_r_offset(), 0);
d974 15
@


1.22
log
@Adjust PLTOFF64 calculation.
@
text
@d113 8
d226 8
d738 15
a752 3
      // FIXME: If we are generating a shared object we need to copy
      // this relocation into the object.
      gold_assert(!parameters->output_is_shared());
d789 1
a789 1
            if (parameters->output_is_shared())
d791 3
d918 56
a973 28
      // FIXME: If we are generating a shared object we may need to
      // copy this relocation into the object.  If this symbol is
      // defined in a shared object, we may need to copy this
      // relocation in order to avoid a COPY relocation.
      gold_assert(!parameters->output_is_shared());

      if (gsym->is_from_dynobj())
	{
	  // This symbol is defined in a dynamic object.  If it is a
	  // function, we make a PLT entry.  Otherwise we need to
	  // either generate a COPY reloc or copy this reloc.
	  if (gsym->type() == elfcpp::STT_FUNC)
	    {
	      target->make_plt_entry(symtab, layout, gsym);

	      // If this is not a PC relative reference, then we may
	      // be taking the address of the function.  In that case
	      // we need to set the entry in the dynamic symbol table
	      // to the address of the PLT entry.
	      if (r_type != elfcpp::R_X86_64_PC64
		  && r_type != elfcpp::R_X86_64_PC32
		  && r_type != elfcpp::R_X86_64_PC16
		  && r_type != elfcpp::R_X86_64_PC8)
		gsym->set_needs_dynsym_value();
	    }
	  else
	    target->copy_reloc(&options, symtab, layout, object, data_shndx,
			       gsym, reloc);
a974 1

d1009 7
d1224 5
a1228 1
  if (gsym != NULL && gsym->is_from_dynobj() && gsym->has_plt_offset())
d1239 3
d1254 1
a1254 1
          got_offset = gsym->got_offset();
d1259 1
a1259 1
          got_offset = object->local_got_offset(r_sym);
d1353 1
a1353 1
	value = target->got_section(NULL, NULL)->address();
d1370 1
a1370 1
	value = target->got_section(NULL, NULL)->address();
d1379 1
a1379 1
		 - target->got_section(NULL, NULL)->address());
d1388 1
a1388 1
        value = target->got_section(NULL, NULL)->address() + got_offset;
d1397 1
a1397 1
        value = target->got_section(NULL, NULL)->address() + got_offset;
d1464 1
a1464 1
			 ? !parameters->output_is_shared()
@


1.21
log
@From Craig Silverstein: Implement GOTPLT64 and PLTOFF64.
@
text
@d1268 2
a1269 2
        Relocate_functions<64, false>::pcrela64(view, object, psymval, addend,
                                                - got_address);
@


1.20
log
@From Craig Silverstein: Clean up some unnecessary TODO markers.
@
text
@a291 1
      // TODO(csilvers): do we really need an alignment of 8?
a383 1
    // TODO(csilvers): do we really need an alignment of 8?
d744 2
d752 1
d768 2
a836 1
    case elfcpp::R_X86_64_GOTPLT64:
d938 5
d960 5
d1254 3
d1261 11
a1357 1
    case elfcpp::R_X86_64_PLTOFF64:  // FIXME: implement me!
@


1.19
log
@From Craig Silverstein: better organization for TLS code.
@
text
@d740 1
a740 1
    case elfcpp::R_X86_64_GOTPC32:  // TODO(csilvers): correct?
d742 2
a743 2
    case elfcpp::R_X86_64_GOTPC64:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_PLTOFF64:  // TODO(csilvers): correct?
d835 2
a836 2
    case elfcpp::R_X86_64_SIZE32:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_SIZE64:  // TODO(csilvers): correct?
d947 1
a947 1
    case elfcpp::R_X86_64_GOTPC32:  // TODO(csilvers): correct?
d949 2
a950 2
    case elfcpp::R_X86_64_GOTPC64:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_PLTOFF64:  // TODO(csilvers): correct?
d1018 3
a1020 2
    case elfcpp::R_X86_64_SIZE32:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_SIZE64:  // TODO(csilvers): correct?
d1263 1
a1263 1
    case elfcpp::R_X86_64_GOTPLT64:  // TODO(csilvers): correct?
d1330 3
a1332 3
    case elfcpp::R_X86_64_SIZE32:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_SIZE64:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_PLTOFF64:  // TODO(csilvers): implement me!
@


1.18
log
@Add support for PT_GNU_STACK.
@
text
@d177 3
a179 3
    // Do a TLS Initial-Exec to Local-Exec transition.
    static inline void
    tls_ie_to_le(const Relocate_info<64, false>*, size_t relnum,
d186 1
a186 1
    // Do a TLS General-Dynamic to Local-Exec transition.
d188 1
a188 1
    tls_gd_to_le(const Relocate_info<64, false>*, size_t relnum,
d195 3
a197 3
    // Do a TLS Local-Dynamic to Local-Exec transition.
    inline void
    tls_ld_to_le(const Relocate_info<64, false>*, size_t relnum,
d783 2
a784 2
    case elfcpp::R_X86_64_TLSGD:
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:
d786 1
a786 3
    case elfcpp::R_X86_64_TLSLD:
    case elfcpp::R_X86_64_GOTTPOFF:
    case elfcpp::R_X86_64_TPOFF32:
d789 2
d797 7
a803 4
          case elfcpp::R_X86_64_TPOFF32:     // Local-exec
	    // FIXME: If generating a shared object, we need to copy
	    // this relocation into the object.
	    gold_assert(!output_is_shared);
a805 7
          case elfcpp::R_X86_64_GOTTPOFF:    // Initial-exec
            // FIXME: If not relaxing to LE, we need to generate a
            // TPOFF64 reloc.
            if (optimized_type != tls::TLSOPT_TO_LE)
              unsupported_reloc_local(object, r_type);
            break;

d815 6
d822 4
a825 7
          case elfcpp::R_X86_64_TLSGD:       // General-dynamic
          case elfcpp::R_X86_64_GOTPC32_TLSDESC:
          case elfcpp::R_X86_64_TLSDESC_CALL:
	    // FIXME: If not relaxing to LE, we need to generate
	    // DTPMOD64 and DTPOFF64 relocs.
	    if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_local(object, r_type);
d968 2
a969 5
    case elfcpp::R_X86_64_TLSGD:
    case elfcpp::R_X86_64_TLSLD:
    case elfcpp::R_X86_64_GOTTPOFF:
    case elfcpp::R_X86_64_TPOFF32:
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:
d971 1
d974 2
d982 7
a988 4
          case elfcpp::R_X86_64_TPOFF32:     // Local-exec
	    // FIXME: If generating a shared object, we need to copy
	    // this relocation into the object.
	    gold_assert(is_final);
a990 7
          case elfcpp::R_X86_64_GOTTPOFF:    // Initial-exec
            // FIXME: If not relaxing to LE, we need to generate a
            // TPOFF64 reloc.
            if (optimized_type != tls::TLSOPT_TO_LE)
              unsupported_reloc_global(object, r_type, gsym);
            break;

d1000 6
d1007 4
a1010 7
          case elfcpp::R_X86_64_TLSGD:       // General-dynamic
          case elfcpp::R_X86_64_GOTPC32_TLSDESC:
          case elfcpp::R_X86_64_TLSDESC_CALL:
	    // FIXME: If not relaxing to LE, we need to generate
	    // DTPMOD64 and DTPOFF64, or TLSDESC, relocs.
	    if (optimized_type != tls::TLSOPT_TO_LE)
	      unsupported_reloc_global(object, r_type, gsym);
d1317 2
a1318 5
    case elfcpp::R_X86_64_TLSGD:
    case elfcpp::R_X86_64_TLSLD:
    case elfcpp::R_X86_64_GOTTPOFF:
    case elfcpp::R_X86_64_TPOFF32:
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:
d1320 1
d1323 2
d1372 2
a1373 20
    case elfcpp::R_X86_64_TPOFF32:   // Local-exec reloc
      value = value - (tls_segment->vaddr() + tls_segment->memsz());
      Relocate_functions<64, false>::rel32(view, value);
      break;

    case elfcpp::R_X86_64_GOTTPOFF:  // Initial-exec reloc
      if (optimized_type == tls::TLSOPT_TO_LE)
	{
	  Target_x86_64::Relocate::tls_ie_to_le(relinfo, relnum, tls_segment,
                                                rela, r_type, value, view,
                                                view_size);
	  break;
	}
      gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			     _("unsupported reloc type %u"),
			     r_type);
      break;

    case elfcpp::R_X86_64_TLSGD:
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:
d1386 1
a1386 1
    case elfcpp::R_X86_64_TLSLD:
a1411 2
    }
}
d1413 12
a1424 2
// Do a relocation in which we convert a TLS Initial-Exec to a
// Local-Exec.
d1426 4
a1429 47
inline void
Target_x86_64::Relocate::tls_ie_to_le(const Relocate_info<64, false>* relinfo,
                                      size_t relnum,
                                      Output_segment* tls_segment,
                                      const elfcpp::Rela<64, false>& rela,
                                      unsigned int,
                                      elfcpp::Elf_types<64>::Elf_Addr value,
                                      unsigned char* view,
                                      off_t view_size)
{
  // We need to examine the opcodes to figure out which instruction we
  // are looking at.

  // movq foo@@gottpoff(%rip),%reg  ==>  movq $YY,%reg
  // addq foo@@gottpoff(%rip),%reg  ==>  addq $YY,%reg

  tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, -3);
  tls::check_range(relinfo, relnum, rela.get_r_offset(), view_size, 4);

  unsigned char op1 = view[-3];
  unsigned char op2 = view[-2];
  unsigned char op3 = view[-1];
  unsigned char reg = op3 >> 3;

  if (op2 == 0x8b)
    {
      // movq
      if (op1 == 0x4c)
        view[-3] = 0x49;
      view[-2] = 0xc7;
      view[-1] = 0xc0 | reg;
    }
  else if (reg == 4)
    {
      // Special handling for %rsp.
      if (op1 == 0x4c)
        view[-3] = 0x49;
      view[-2] = 0x81;
      view[-1] = 0xc0 | reg;
    }
  else
    {
      // addq
      if (op1 == 0x4c)
        view[-3] = 0x4d;
      view[-2] = 0x8d;
      view[-1] = 0x80 | reg | (reg << 3);
a1430 3

  value = value - (tls_segment->vaddr() + tls_segment->memsz());
  Relocate_functions<64, false>::rela32(view, value, 0);
d1495 56
@


1.17
log
@Fix versions of copied symbols.
@
text
@d266 1
@


1.16
log
@From Craig Silverstein: handle PLT32 relocs against local symbols for
x86_64.
@
text
@d624 1
a624 5
      // Define the symbol in the .dynbss section.
      symtab->define_in_output_data(this, ssym->name(), ssym->version(),
				    dynbss, offset, symsize, ssym->type(),
				    ssym->binding(), ssym->visibility(),
				    ssym->nonvis(), false, false);
a626 1
      ssym->set_needs_dynsym_entry();
@


1.15
log
@From Craig Silverstein: implement -Ttext.
@
text
@d739 5
a839 1
    case elfcpp::R_X86_64_PLT32:
d1244 2
a1245 1
      gold_assert(gsym->has_plt_offset()
@


1.14
log
@From Craig Silverstein: support local GOT relocs for i386.
@
text
@d267 1
a267 1
  0x400000,		// text_segment_address
@


1.13
log
@From Craig Silverstein: add LD to LE TLS optimizations.
@
text
@a1183 1
  
@


1.12
log
@Remove extraneous newlines.
@
text
@d195 8
a202 9
    // Check the range for a TLS relocation.
    static inline void
    check_range(const Relocate_info<64, false>*, size_t relnum,
		const elfcpp::Rela<64, false>&, off_t, off_t);

    // Check the validity of a TLS relocation.  This is like assert.
    static inline void
    check_tls(const Relocate_info<64, false>*, size_t relnum,
	      const elfcpp::Rela<64, false>&, bool);
d574 1
a574 1
                          const elfcpp::Rela<64, false>& rel)
d588 1
a588 1
      this->copy_relocs_->save(ssym, object, data_shndx, rel);
d1349 1
a1349 1
                                      const elfcpp::Rela<64, false>& rel,
d1360 1
a1360 1
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
d1383 1
a1383 1
                                                rel, r_type, value, view,
d1387 1
a1387 1
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
d1398 1
a1398 1
			     rel, r_type, value, view,
d1402 1
a1402 1
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
d1409 3
a1411 1
          // FIXME: implement ld_to_le
d1413 1
a1413 1
      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
d1442 1
a1442 1
                                      const elfcpp::Rela<64, false>& rel,
d1454 2
a1455 2
  Target_x86_64::Relocate::check_range(relinfo, relnum, rel, view_size, -3);
  Target_x86_64::Relocate::check_range(relinfo, relnum, rel, view_size, 4);
d1498 1
a1498 1
                                      const elfcpp::Rela<64, false>& rel,
d1508 2
a1509 2
  Target_x86_64::Relocate::check_range(relinfo, relnum, rel, view_size, -4);
  Target_x86_64::Relocate::check_range(relinfo, relnum, rel, view_size, 12);
d1511 4
a1514 6
  Target_x86_64::Relocate::check_tls(relinfo, relnum, rel,
                                     (memcmp(view - 4, "\x66\x48\x8d\x3d", 4)
                                      == 0));
  Target_x86_64::Relocate::check_tls(relinfo, relnum, rel,
                                     (memcmp(view + 4, "\x66\x66\x48\xe8", 4)
                                      == 0));
d1526 16
a1541 1
// Check the range for a TLS relocation.
d1543 4
a1546 11
inline void
Target_x86_64::Relocate::check_range(const Relocate_info<64, false>* relinfo,
                                     size_t relnum,
                                     const elfcpp::Rela<64, false>& rel,
                                     off_t view_size, off_t off)
{
  off_t offset = rel.get_r_offset() + off;
  if (offset < 0 || offset > view_size)
    gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			   _("TLS relocation out of range"));
}
d1548 1
a1548 1
// Check the validity of a TLS relocation.  This is like assert.
d1550 3
a1552 9
inline void
Target_x86_64::Relocate::check_tls(const Relocate_info<64, false>* relinfo,
                                   size_t relnum,
                                   const elfcpp::Rela<64, false>& rel,
                                   bool valid)
{
  if (!valid)
    gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
			   _("TLS relocation against invalid instruction"));
@


1.11
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d154 1
a154 1
	  gold_error(_("missing expected TLS relocation\n"));
@


1.10
log
@From Craig Silverstein: use tls.h in x86_64.cc.
@
text
@d154 1
a154 3
	  fprintf(stderr, _("%s: missing expected TLS relocation\n"),
		  program_name);
	  gold_exit(false);
d700 2
a701 2
  fprintf(stderr, _("%s: %s: unsupported reloc %u against local symbol\n"),
	  program_name, object->name().c_str(), r_type);
d778 2
a779 3
      fprintf(stderr, _("%s: %s: unexpected reloc %u in object file\n"),
	      program_name, object->name().c_str(), r_type);
      gold_exit(false);
d840 2
a841 2
      fprintf(stderr, _("%s: %s: unsupported reloc %u against local symbol\n"),
	      program_name, object->name().c_str(), r_type);
d854 2
a855 3
  fprintf(stderr,
	  _("%s: %s: unsupported reloc %u against global symbol %s\n"),
	  program_name, object->name().c_str(), r_type, gsym->name());
d965 2
a966 3
      fprintf(stderr, _("%s: %s: unexpected reloc %u in object file\n"),
	      program_name, object->name().c_str(), r_type);
      gold_exit(false);
d1024 2
a1025 3
      fprintf(stderr,
	      _("%s: %s: unsupported reloc %u against global symbol %s\n"),
	      program_name, object->name().c_str(), r_type, gsym->name());
d1047 3
a1049 3
      fprintf(stderr, _("%s: %s: unsupported REL reloc section\n"),
	      program_name, object->name().c_str());
      gold_exit(false);
d1137 7
a1143 4
	  fprintf(stderr, _("%s: %s: missing expected TLS relocation\n"),
		  program_name,
		  relinfo->location(relnum, rela.get_r_offset()).c_str());
	  gold_exit(false);
a1144 4

      this->skip_call_tls_get_addr_ = false;

      return false;
d1314 3
a1316 5
      fprintf(stderr, _("%s: %s: unexpected reloc %u in object file\n"),
	      program_name,
	      relinfo->location(relnum, rela.get_r_offset()).c_str(),
	      r_type);
      gold_exit(false);
d1336 3
a1338 5
      fprintf(stderr, _("%s: %s: unsupported reloc %u\n"),
	      program_name,
	      relinfo->location(relnum, rela.get_r_offset()).c_str(),
	      r_type);
      gold_exit(false);
d1361 3
a1363 4
      fprintf(stderr, _("%s: %s: TLS reloc but no TLS segment\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str());
      gold_exit(false);
d1388 3
a1390 5
      fprintf(stderr, _("%s: %s: unsupported reloc type %u\n"),
              program_name,
              relinfo->location(relnum, rel.get_r_offset()).c_str(),
              r_type);
      gold_exit(false);
d1403 2
a1404 5
      fprintf(stderr, _("%s: %s: unsupported reloc %u\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str(),
	      r_type);
      gold_exit(false);
d1412 2
a1413 5
      fprintf(stderr, _("%s: %s: unsupported reloc %u\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str(),
	      r_type);
      gold_exit(false);
d1537 2
a1538 6
    {
      fprintf(stderr, _("%s: %s: TLS relocation out of range\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str());
      gold_exit(false);
    }
d1550 2
a1551 7
    {
      fprintf(stderr,
	      _("%s: %s: TLS relocation against invalid instruction\n"),
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str());
      gold_exit(false);
    }
@


1.9
log
@From Craig Silverstein: improve x86_64 TLS support.
@
text
@d47 1
d132 7
d188 1
a188 1
    // Do a TLS Global-Dynamic to Local-Exec transition.
d214 1
a214 1
  static unsigned int
d645 1
a645 1
unsigned int
d651 1
a651 1
    return r_type;
d656 3
a658 3
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_TLSDESC_CALL:  // TODO(csilvers): correct?
      // These are Global-Dynamic which permits fully general TLS
d663 2
a664 2
	return elfcpp::R_X86_64_TPOFF32;
      return elfcpp::R_X86_64_GOTTPOFF;     // used for Initial-exec
d670 1
a670 1
      return elfcpp::R_X86_64_TPOFF32;
a672 3
      // Another Local-Dynamic reloc.
      return elfcpp::R_X86_64_TPOFF32;

d675 1
a675 1
      return elfcpp::R_X86_64_TPOFF64;
d683 2
a684 2
	return elfcpp::R_X86_64_TPOFF32;
      return r_type;
d689 1
a689 1
      return r_type;
d696 10
d786 6
a791 6
    case elfcpp::R_X86_64_TLSGD:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_TLSLD:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_GOTTPOFF:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_TPOFF32:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_TLSDESC_CALL:  // TODO(csilvers): correct?
d796 2
a797 1
	r_type = Target_x86_64::optimize_tls_reloc(!output_is_shared, r_type);
a800 1
          case elfcpp::R_X86_64_TPOFF64:
d806 8
d816 6
a821 1
            break;
d823 1
a823 3
          case elfcpp::R_X86_64_GOTTPOFF:       // Initial-exec
          case elfcpp::R_X86_64_TLSGD:          // General Dynamic
          case elfcpp::R_X86_64_TLSLD:          // Local Dynamic
d826 4
a829 3
	    fprintf(stderr,
		    _("%s: %s: unsupported reloc %u against local symbol\n"),
		    program_name, object->name().c_str(), r_type);
d831 3
d850 12
d975 6
a980 6
    case elfcpp::R_X86_64_TLSGD:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_TLSLD:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_GOTTPOFF:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_TPOFF32:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_TLSDESC_CALL:  // TODO(csilvers): correct?
d985 2
a986 1
	r_type = Target_x86_64::optimize_tls_reloc(is_final, r_type);
a989 1
          case elfcpp::R_X86_64_TPOFF64:
d992 1
a992 1
	    gold_assert(!parameters->output_is_shared());
d995 8
d1005 6
a1010 1
            break;
d1012 1
a1012 3
          case elfcpp::R_X86_64_GOTTPOFF:       // Initial-exec
          case elfcpp::R_X86_64_TLSGD:          // General Dynamic
          case elfcpp::R_X86_64_TLSLD:          // Local Dynamic
d1015 4
a1018 5
	    fprintf(stderr,
		    _("%s: %s: unsupported reloc %u "
		      "against global symbol %s\n"),
		    program_name, object->name().c_str(), r_type,
		    gsym->name());
d1020 3
a1025 1

d1329 6
a1334 6
    case elfcpp::R_X86_64_TLSGD:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_TLSLD:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_GOTTPOFF:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_TPOFF32:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_TLSDESC_CALL:  // TODO(csilvers): correct?
d1383 2
a1384 2
  const unsigned int opt_r_type =
    Target_x86_64::optimize_tls_reloc(is_final, r_type);
d1393 1
a1393 1
      if (opt_r_type == elfcpp::R_X86_64_TPOFF32)
d1408 3
a1410 1
      if (opt_r_type == elfcpp::R_X86_64_TPOFF32)
d1425 4
d1437 1
a1437 1
      if (opt_r_type == elfcpp::R_X86_64_TPOFF32)
d1445 1
a1445 1
      if (opt_r_type == elfcpp::R_X86_64_TPOFF64)
a1455 1
// TODO(csilvers): verify this is right.
d1510 1
a1510 1
// Do a relocation in which we convert a TLS Global-Dynamic to a
a1511 1
// TODO(csilvers): verify this is right.
@


1.8
log
@From Andrew Chatham: exit on relocation error.
@
text
@d60 1
a60 1
//   http://ia32-abi.googlegroups.com/web/RFC-TLSDESC-x86.txt?gda=kWQJPEQAAACEfYQFX0dubPQ2NuO4whhjkR4HAp8tBMb_I0iuUeQslmG1qiJ7UbTIup-M2XPURDRiZJyPR4BqKR2agJ-5jfT5Ley2_-oiOJ4zLNAGCw24Bg
d71 1
a71 1
      got_(NULL), plt_(NULL), got_plt_(NULL), rel_dyn_(NULL),
d227 1
a227 1
  rel_dyn_section(Layout*);
d246 1
a246 1
  Reloc_section* rel_dyn_;
d310 1
a310 1
Target_x86_64::rel_dyn_section(Layout* layout)
d312 1
a312 1
  if (this->rel_dyn_ == NULL)
d315 1
a315 1
      this->rel_dyn_ = new Reloc_section();
d317 1
a317 1
				      elfcpp::SHF_ALLOC, this->rel_dyn_);
d319 1
a319 1
  return this->rel_dyn_;
d627 2
a628 2
      Reloc_section* rel_dyn = this->rel_dyn_section(layout);
      rel_dyn->add_global(ssym, elfcpp::R_X86_64_COPY, dynbss, offset, 0);
d664 8
d699 2
a700 2
                           unsigned int,
                           const elfcpp::Rela<64, false>&,
d735 22
a763 2
    case elfcpp::R_X86_64_DTPOFF64:
    case elfcpp::R_X86_64_DTPOFF32:
d777 2
d785 1
d791 4
d808 1
a808 5
    case elfcpp::R_X86_64_GOT64:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_GOT32:
    case elfcpp::R_X86_64_GOTPCREL64:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_GOTPCREL:
    case elfcpp::R_X86_64_GOTPLT64:  // TODO(csilvers): correct?
d895 3
a897 3
                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
                rel_dyn->add_global(gsym, elfcpp::R_X86_64_GLOB_DAT, got,
                                    gsym->got_offset(), 0);
a925 2
    case elfcpp::R_X86_64_DTPOFF64:
    case elfcpp::R_X86_64_DTPOFF32:
d939 2
d947 1
d953 4
d1039 1
a1039 1
      if (this->rel_dyn_ != NULL)
d1041 1
a1041 1
	  const Output_data* od = this->rel_dyn_;
d1062 2
a1063 2
      Reloc_section* rel_dyn = this->rel_dyn_section(layout);
      this->copy_relocs_->emit(rel_dyn);
d1075 1
a1075 1
                                  const elfcpp::Rela<64, false>& rel,
d1087 1
a1087 1
	  || strcmp(gsym->name(), "___tls_get_addr") != 0)
d1091 1
a1091 1
		  relinfo->location(relnum, rel.get_r_offset()).c_str());
d1110 29
a1138 1
  const elfcpp::Elf_Xword addend = rel.get_r_addend();
d1202 2
a1203 4
      // Local GOT offsets not yet supported.
      gold_assert(gsym);
      gold_assert(gsym->has_got_offset());
      Relocate_functions<64, false>::rela32(view, gsym->got_offset(), addend);
d1219 2
a1220 4
      // Local GOT offsets not yet supported.
      gold_assert(gsym);
      gold_assert(gsym->has_got_offset());
      Relocate_functions<64, false>::rela64(view, gsym->got_offset(), addend);
d1243 4
a1246 7
        // Local GOT offsets not yet supported.
        gold_assert(gsym);
        gold_assert(gsym->has_got_offset());
	elfcpp::Elf_types<64>::Elf_Addr value;
	value = (target->got_section(NULL, NULL)->address()
                 + gsym->got_offset());
	Relocate_functions<64, false>::pcrela32(view, value, addend, address);
d1252 4
a1255 7
        // Local GOT offsets not yet supported.
        gold_assert(gsym);
        gold_assert(gsym->has_got_offset());
	elfcpp::Elf_types<64>::Elf_Addr value;
	value = (target->got_section(NULL, NULL)->address()
                 + gsym->got_offset());
	Relocate_functions<64, false>::pcrela64(view, value, addend, address);
a1265 2
    case elfcpp::R_X86_64_DTPOFF64:
    case elfcpp::R_X86_64_DTPOFF32:
d1269 1
a1269 1
	      relinfo->location(relnum, rel.get_r_offset()).c_str(),
d1281 3
a1283 1
      this->relocate_tls(relinfo, relnum, rel, r_type, gsym, psymval, view,
d1293 1
a1293 1
	      relinfo->location(relnum, rel.get_r_offset()).c_str(),
d1375 16
d1408 1
a1408 2
  // We have to actually change the instructions, which means that we
  // need to examine the opcodes to figure out which instruction we
d1411 4
a1414 4
  // movl %gs:XX,%eax  ==>  movl $YY,%eax
  // movl %gs:XX,%reg  ==>  movl $YY,%reg
  // addl %gs:XX,%reg  ==>  addl $YY,%reg
  Target_x86_64::Relocate::check_range(relinfo, relnum, rel, view_size, -1);
d1417 6
a1422 2
  unsigned char op1 = view[-1];
  if (op1 == 0xa1)
d1424 13
a1436 2
      // movl XX,%eax  ==>  movl $YY,%eax
      view[-1] = 0xb8;
d1440 5
a1444 22
      Target_x86_64::Relocate::check_range(relinfo, relnum, rel,
                                           view_size, -2);

      unsigned char op2 = view[-2];
      if (op2 == 0x8b)
        {
          // movl XX,%reg  ==>  movl $YY,%reg
          Target_x86_64::Relocate::check_tls(relinfo, relnum, rel,
                                             (op1 & 0xc7) == 0x05);
          view[-2] = 0xc7;
          view[-1] = 0xc0 | ((op1 >> 3) & 7);
        }
      else if (op2 == 0x03)
        {
          // addl XX,%reg  ==>  addl $YY,%reg
          Target_x86_64::Relocate::check_tls(relinfo, relnum, rel,
                                             (op1 & 0xc7) == 0x05);
          view[-2] = 0x81;
          view[-1] = 0xc0 | ((op1 >> 3) & 7);
        }
      else
        Target_x86_64::Relocate::check_tls(relinfo, relnum, rel, 0);
d1448 1
a1448 1
  Relocate_functions<64, false>::rel32(view, value);
d1465 3
a1467 7
  // leal foo(,%reg,1),%eax; call ___tls_get_addr
  //  ==> movl %gs,0,%eax; subl $foo@@tpoff,%eax
  // leal foo(%reg),%eax; call ___tls_get_addr
  //  ==> movl %gs:0,%eax; subl $foo@@tpoff,%eax

  Target_x86_64::Relocate::check_range(relinfo, relnum, rel, view_size, -2);
  Target_x86_64::Relocate::check_range(relinfo, relnum, rel, view_size, 9);
d1469 2
a1470 2
  unsigned char op1 = view[-1];
  unsigned char op2 = view[-2];
d1473 2
a1474 1
                                     op2 == 0x8d || op2 == 0x04);
d1476 2
a1477 1
                                     view[4] == 0xe8);
d1479 1
a1479 1
  int roff = 5;
d1481 2
a1482 30
  if (op2 == 0x04)
    {
      Target_x86_64::Relocate::check_range(relinfo, relnum, rel, view_size, -3);
      Target_x86_64::Relocate::check_tls(relinfo, relnum, rel,
                                         view[-3] == 0x8d);
      Target_x86_64::Relocate::check_tls(relinfo, relnum, rel,
                                         ((op1 & 0xc7) == 0x05
                                          && op1 != (4 << 3)));
      memcpy(view - 3, "\x65\xa1\0\0\0\0\x81\xe8\0\0\0", 12);
    }
  else
    {
      Target_x86_64::Relocate::check_tls(relinfo, relnum, rel,
                                         (op1 & 0xf8) == 0x80 && (op1 & 7) != 4);
      if (static_cast<off_t>(rel.get_r_offset() + 9) < view_size
          && view[9] == 0x90)
	{
	  // There is a trailing nop.  Use the size byte subl.
	  memcpy(view - 2, "\x65\xa1\0\0\0\0\x81\xe8\0\0\0", 12);
	  roff = 6;
	}
      else
	{
	  // Use the five byte subl.
	  memcpy(view - 2, "\x65\xa1\0\0\0\0\x2d\0\0\0", 11);
	}
    }

  value = tls_segment->vaddr() + tls_segment->memsz() - value;
  Relocate_functions<64, false>::rel32(view + roff, value);
@


1.7
log
@From Craig Silverstein: x86_64 TLS support.
@
text
@d1241 1
a1241 1
      // gold_exit(false);
d1296 1
a1296 1
      // gold_exit(false);
d1311 1
a1311 1
      // gold_exit(false);
d1319 1
a1319 1
      // gold_exit(false);
@


1.6
log
@From Craig Silverstein: get all x86_64 tests passing.
@
text
@d56 5
a60 1
// See the ABI at http://www.x86-64.org/documentation/abi.pdf
d565 5
a569 5
			Symbol_table* symtab,
			Layout* layout,
			Sized_relobj<64, false>* object,
			unsigned int data_shndx, Symbol* gsym,
			const elfcpp::Rela<64, false>& rel)
a627 1
      // TODO(csilvers): should last arg here be rel.get_r_addend?
a639 2
  return is_final ? r_type : 0;
#if 0
d648 2
d655 2
a656 2
	return elfcpp::R_X86_64_TLS_LE_64;
      return elfcpp::R_X86_64_TLS_IE_64;
d658 1
a658 1
    case elfcpp::R_X86_64_TLS_LDM:
d662 1
a662 1
      return elfcpp::R_X86_64_TLS_LE_64;
d664 1
a664 7
    case elfcpp::R_X86_64_TLS_LDO_64:
      // Another type of Local-Dynamic relocation.
      return elfcpp::R_X86_64_TLS_LE;

    case elfcpp::R_X86_64_TLS_IE:
    case elfcpp::R_X86_64_TLS_GOTIE:
    case elfcpp::R_X86_64_TLS_IE_64:
d670 1
a670 1
	return elfcpp::R_X86_64_TLS_LE_64;
d673 1
a673 2
    case elfcpp::R_X86_64_TLS_LE:
    case elfcpp::R_X86_64_TLS_LE_64:
a680 1
#endif
d687 8
a694 8
			 Symbol_table* symtab,
			 Layout* layout,
			 Target_x86_64* target,
			 Sized_relobj<64, false>* object,
			 unsigned int,
			 const elfcpp::Rela<64, false>&,
			 unsigned int r_type,
			 const elfcpp::Sym<64, false>&)
d731 1
a732 1
    case elfcpp::R_X86_64_TPOFF32:
a735 1
    case elfcpp::R_X86_64_GOTTPOFF:  // TODO(csilvers): correct?
a736 2
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_TLSDESC_CALL:  // TODO(csilvers): correct?
d742 1
a742 1
#if 0
d745 4
a748 9

    case elfcpp::R_386_TLS_IE:
    case elfcpp::R_386_TLS_GOTIE:
    case elfcpp::R_386_TLS_LE:
    case elfcpp::R_386_TLS_GD:
    case elfcpp::R_386_TLS_LDM:
    case elfcpp::R_386_TLS_LDO_64:
    case elfcpp::R_386_TLS_IE_64:
    case elfcpp::R_386_TLS_LE_64:
d751 1
a751 2
	r_type = Target_x86_64::optimize_tls_reloc(!output_is_shared,
						 r_type);
d754 1
a754 2
	  case elfcpp::R_X86_64_TLS_LE:
	  case elfcpp::R_X86_64_TLS_LE_64:
d760 5
a764 6
	  case elfcpp::R_X86_64_TLS_IE:
	  case elfcpp::R_X86_64_TLS_GOTIE:
	  case elfcpp::R_X86_64_TLS_GD:
	  case elfcpp::R_X86_64_TLS_LDM:
	  case elfcpp::R_X86_64_TLS_LDO_64:
	  case elfcpp::R_X86_64_TLS_IE_64:
a771 1
#endif
a780 10
#if 0
    case elfcpp::R_386_TLS_GD_64:
    case elfcpp::R_386_TLS_GD_PUSH:
    case elfcpp::R_386_TLS_GD_CALL:
    case elfcpp::R_386_TLS_GD_POP:
    case elfcpp::R_386_TLS_LDM_64:
    case elfcpp::R_386_TLS_LDM_PUSH:
    case elfcpp::R_386_TLS_LDM_CALL:
    case elfcpp::R_386_TLS_LDM_POP:
#endif
d793 8
a800 8
			  Symbol_table* symtab,
			  Layout* layout,
			  Target_x86_64* target,
			  Sized_relobj<64, false>* object,
			  unsigned int data_shndx,
			  const elfcpp::Rela<64, false>& reloc,
			  unsigned int r_type,
			  Symbol* gsym)
d892 1
a893 1
    case elfcpp::R_X86_64_TPOFF32:
a896 1
    case elfcpp::R_X86_64_GOTTPOFF:  // TODO(csilvers): correct?
a897 2
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_TLSDESC_CALL:  // TODO(csilvers): correct?
d903 1
a903 1
#if 0
d906 4
a909 9

    case elfcpp::R_386_TLS_IE:
    case elfcpp::R_386_TLS_GOTIE:
    case elfcpp::R_386_TLS_LE:
    case elfcpp::R_386_TLS_GD:
    case elfcpp::R_386_TLS_LDM:
    case elfcpp::R_386_TLS_LDO_64:
    case elfcpp::R_386_TLS_IE_64:
    case elfcpp::R_386_TLS_LE_64:
d915 1
a915 2
	  case elfcpp::R_386_TLS_LE:
	  case elfcpp::R_386_TLS_LE_64:
d921 5
a925 6
	  case elfcpp::R_386_TLS_IE:
	  case elfcpp::R_386_TLS_GOTIE:
	  case elfcpp::R_386_TLS_GD:
	  case elfcpp::R_386_TLS_LDM:
	  case elfcpp::R_386_TLS_LDO_64:
	  case elfcpp::R_386_TLS_IE_64:
a934 1
#endif
a937 10
#if 0
    case elfcpp::R_386_TLS_GD_64:
    case elfcpp::R_386_TLS_GD_PUSH:
    case elfcpp::R_386_TLS_GD_CALL:
    case elfcpp::R_386_TLS_GD_POP:
    case elfcpp::R_386_TLS_LDM_64:
    case elfcpp::R_386_TLS_LDM_PUSH:
    case elfcpp::R_386_TLS_LDM_CALL:
    case elfcpp::R_386_TLS_LDM_POP:
#endif
d950 10
a959 10
			 Symbol_table* symtab,
			 Layout* layout,
			 Sized_relobj<64, false>* object,
			 unsigned int data_shndx,
			 unsigned int sh_type,
			 const unsigned char* prelocs,
			 size_t reloc_count,
			 size_t local_symbol_count,
			 const unsigned char* plocal_symbols,
			 Symbol** global_symbols)
d1209 1
a1210 1
    case elfcpp::R_X86_64_TPOFF32:
a1213 1
    case elfcpp::R_X86_64_GOTTPOFF:  // TODO(csilvers): correct?
a1214 2
    case elfcpp::R_X86_64_GOTPC32_TLSDESC:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_TLSDESC_CALL:  // TODO(csilvers): correct?
d1222 1
a1222 1
#if 0
d1225 4
a1228 9

    case elfcpp::R_386_TLS_IE:
    case elfcpp::R_386_TLS_GOTIE:
    case elfcpp::R_386_TLS_LE:
    case elfcpp::R_386_TLS_GD:
    case elfcpp::R_386_TLS_LDM:
    case elfcpp::R_386_TLS_LDO_64:
    case elfcpp::R_386_TLS_IE_64:
    case elfcpp::R_386_TLS_LE_64:
a1231 3
#else
      view_size++;      // this is to make view_size used
#endif
a1235 10
#if 0
    case elfcpp::R_386_TLS_GD_64:
    case elfcpp::R_386_TLS_GD_PUSH:
    case elfcpp::R_386_TLS_GD_CALL:
    case elfcpp::R_386_TLS_GD_POP:
    case elfcpp::R_386_TLS_LDM_64:
    case elfcpp::R_386_TLS_LDM_PUSH:
    case elfcpp::R_386_TLS_LDM_CALL:
    case elfcpp::R_386_TLS_LDM_POP:
#endif
d1251 7
a1257 7
Target_x86_64::Relocate::relocate_tls(const Relocate_info<64, false>*, // relinfo,
                                      size_t , // relnum,
                                      const elfcpp::Rela<64, false>& , // rel,
                                      unsigned int , // r_type,
                                      const Sized_symbol<64>* , // gsym,
                                      const Symbol_value<64>* , // psymval,
                                      unsigned char* , // view,
d1259 1
a1259 1
                                      off_t)// view_size)
a1260 1
#if 0
d1279 1
a1279 6
    case elfcpp::R_X86_64_TLS_LE_64:
      value = tls_segment->vaddr() + tls_segment->memsz() - value;
      Relocate_functions<64, false>::rel64(view, value);
      break;

    case elfcpp::R_X86_64_TLS_LE:
d1281 1
a1281 1
      Relocate_functions<64, false>::rel64(view, value);
d1284 2
a1285 4
    case elfcpp::R_X86_64_TLS_IE:
    case elfcpp::R_X86_64_TLS_GOTIE:
    case elfcpp::R_X86_64_TLS_IE_64:
      if (opt_r_type == elfcpp::R_X86_64_TLS_LE_64)
d1288 2
a1289 2
					      rel, r_type, value, view,
					      view_size);
d1293 3
a1295 3
	      program_name,
	      relinfo->location(relnum, rel.get_r_offset()).c_str(),
	      r_type);
d1299 2
a1300 2
    case elfcpp::R_X86_64_TLS_GD:
      if (opt_r_type == elfcpp::R_X86_64_TLS_LE_64)
d1314 1
a1314 2
    case elfcpp::R_X86_64_TLS_LDM:
    case elfcpp::R_X86_64_TLS_LDO_64:
a1321 1
#endif
d1326 1
d1329 8
a1336 8
Target_x86_64::Relocate::tls_ie_to_le(const Relocate_info<64, false>* , // relinfo,
				    size_t , // relnum,
				    Output_segment* , // tls_segment,
				    const elfcpp::Rela<64, false>& , // rel,
				    unsigned int , // r_type,
				    elfcpp::Elf_types<64>::Elf_Addr , // value,
				    unsigned char* , // view,
                                      off_t) // view_size)
a1337 1
#if 0
a1340 7
  if (r_type == elfcpp::R_X86_64_TLS_IE)
    {
      // movl %gs:XX,%eax  ==>  movl $YY,%eax
      // movl %gs:XX,%reg  ==>  movl $YY,%reg
      // addl %gs:XX,%reg  ==>  addl $YY,%reg
      Target_x86_64::Relocate::check_range(relinfo, relnum, rel, view_size, -1);
      Target_x86_64::Relocate::check_range(relinfo, relnum, rel, view_size, 4);
d1342 5
a1346 10
      unsigned char op1 = view[-1];
      if (op1 == 0xa1)
	{
	  // movl XX,%eax  ==>  movl $YY,%eax
	  view[-1] = 0xb8;
	}
      else
	{
	  Target_x86_64::Relocate::check_range(relinfo, relnum, rel,
					     view_size, -2);
d1348 5
a1352 20
	  unsigned char op2 = view[-2];
	  if (op2 == 0x8b)
	    {
	      // movl XX,%reg  ==>  movl $YY,%reg
	      Target_x86_64::Relocate::check_tls(relinfo, relnum, rel,
					       (op1 & 0xc7) == 0x05);
	      view[-2] = 0xc7;
	      view[-1] = 0xc0 | ((op1 >> 3) & 7);
	    }
	  else if (op2 == 0x03)
	    {
	      // addl XX,%reg  ==>  addl $YY,%reg
	      Target_x86_64::Relocate::check_tls(relinfo, relnum, rel,
					       (op1 & 0xc7) == 0x05);
	      view[-2] = 0x81;
	      view[-1] = 0xc0 | ((op1 >> 3) & 7);
	    }
	  else
	    Target_x86_64::Relocate::check_tls(relinfo, relnum, rel, 0);
	}
d1356 2
a1357 5
      // subl %gs:XX(%reg1),%reg2  ==>  subl $YY,%reg2
      // movl %gs:XX(%reg1),%reg2  ==>  movl $YY,%reg2
      // addl %gs:XX(%reg1),%reg2  ==>  addl $YY,$reg2
      Target_x86_64::Relocate::check_range(relinfo, relnum, rel, view_size, -2);
      Target_x86_64::Relocate::check_range(relinfo, relnum, rel, view_size, 4);
a1358 1
      unsigned char op1 = view[-1];
a1359 2
      Target_x86_64::Relocate::check_tls(relinfo, relnum, rel,
				       (op1 & 0xc0) == 0x80 && (op1 & 7) != 4);
d1361 7
a1367 11
	{
	  // movl %gs:XX(%reg1),%reg2  ==>  movl $YY,%reg2
	  view[-2] = 0xc7;
	  view[-1] = 0xc0 | ((op1 >> 3) & 7);
	}
      else if (op2 == 0x2b)
	{
	  // subl %gs:XX(%reg1),%reg2  ==>  subl $YY,%reg2
	  view[-2] = 0x81;
	  view[-1] = 0xe8 | ((op1 >> 3) & 7);
	}
d1369 7
a1375 5
	{
	  // addl %gs:XX(%reg1),%reg2  ==>  addl $YY,$reg2
	  view[-2] = 0x81;
	  view[-1] = 0xc0 | ((op1 >> 3) & 7);
	}
d1377 1
a1377 1
	Target_x86_64::Relocate::check_tls(relinfo, relnum, rel, 0);
d1380 2
a1381 6
  value = tls_segment->vaddr() + tls_segment->memsz() - value;
  if (r_type == elfcpp::R_X86_64_TLS_IE || r_type == elfcpp::R_X86_64_TLS_GOTIE)
    value = - value;

  Relocate_functions<64, false>::rel64(view, value);
#endif
d1386 1
d1389 8
a1396 8
Target_x86_64::Relocate::tls_gd_to_le(const Relocate_info<64, false>* , // relinfo,
				    size_t , // relnum,
				    Output_segment* , // tls_segment,
				    const elfcpp::Rela<64, false>& , // rel,
				    unsigned int,
				    elfcpp::Elf_types<64>::Elf_Addr , // value,
				    unsigned char* , // view,
                                      off_t)// view_size)
a1397 1
#if 0
d1410 1
a1410 1
				   op2 == 0x8d || op2 == 0x04);
d1412 1
a1412 1
				   view[4] == 0xe8);
d1420 1
a1420 1
				       view[-3] == 0x8d);
d1422 2
a1423 2
				       ((op1 & 0xc7) == 0x05
					&& op1 != (4 << 3)));
d1429 3
a1431 2
				       (op1 & 0xf8) == 0x80 && (op1 & 7) != 4);
      if (rel.get_r_offset() + 9 < view_size && view[9] == 0x90)
d1445 1
a1445 1
  Relocate_functions<64, false>::rel64(view + roff, value);
a1449 1
#endif
d1456 3
a1458 3
				   size_t relnum,
				   const elfcpp::Rela<64, false>& rel,
				   off_t view_size, off_t off)
d1474 3
a1476 3
				 size_t relnum,
				 const elfcpp::Rela<64, false>& rel,
				 bool valid)
d1492 6
a1497 6
			      unsigned int sh_type,
			      const unsigned char* prelocs,
			      size_t reloc_count,
			      unsigned char* view,
			      elfcpp::Elf_types<64>::Elf_Addr address,
			      off_t view_size)
@


1.5
log
@From Craig Silverstein: set symbol value for function pointer
equality across shared library boundaries.
@
text
@d624 2
a625 2
      rel_dyn->add_global(ssym, elfcpp::R_X86_64_COPY, dynbss, offset,
                          rel.get_r_addend());
a723 1
    case elfcpp::R_X86_64_GOTPCREL:
a724 1
    case elfcpp::R_X86_64_GOT64:  // TODO(csilvers): correct?
a726 2
    case elfcpp::R_X86_64_GOTPCREL64:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_GOTPLT64:  // TODO(csilvers): correct?
d790 1
d792 3
d877 1
d879 3
d893 1
a893 1
                                    gsym->got_offset(), reloc.get_r_addend());
a906 1
    case elfcpp::R_X86_64_GOTPCREL:
a907 1
    case elfcpp::R_X86_64_GOT64:  // TODO(csilvers): correct?
a909 2
    case elfcpp::R_X86_64_GOTPCREL64:  // TODO(csilvers): correct?
    case elfcpp::R_X86_64_GOTPLT64:  // TODO(csilvers): correct?
d1231 1
d1233 1
a1234 1
        // FIXME(csilvers): this is probably totally wrong for G + GOT
d1236 1
a1236 1
                 + (gsym->has_got_offset() ? gsym->got_offset() : 0));
d1243 1
d1245 1
a1246 1
        // FIXME(csilvers): this is probably totally wrong for G + GOT
d1248 1
a1248 1
                 + (gsym->has_got_offset() ? gsym->got_offset() : 0));
@


1.4
log
@From Craig Silverstein: correct x86_64 dynamic tags.
@
text
@d89 5
d857 13
a869 1
	    target->make_plt_entry(symtab, layout, gsym);
d1626 12
@


1.3
log
@Cleanups from Craig Silverstein.
@
text
@d1038 1
a1038 1
	  odyn->add_section_size(elfcpp::DT_RELSZ, od);
d1040 1
a1040 1
			     elfcpp::Elf_sizes<64>::rel_size);
@


1.2
log
@From Craig Silverstein: New version of x86_64.cc.
@
text
@d1124 4
d1132 3
@


1.1
log
@From Craig Silverstein: x86_64 support.
@
text
@d61 2
a62 2
  // In the x86_64 ABI, it says "The AMD64 ABI architectures uses only
  // Elf64_Rela relocation entries with explicit addends."
d699 2
d719 3
d723 4
a726 1
    case elfcpp::R_X86_64_GOTPCREL:
d740 1
d742 2
d750 11
a760 8
    case elfcpp::R_X86_64_TLS_IE:
    case elfcpp::R_X86_64_TLS_GOTIE:
    case elfcpp::R_X86_64_TLS_LE:
    case elfcpp::R_X86_64_TLS_GD:
    case elfcpp::R_X86_64_TLS_LDM:
    case elfcpp::R_X86_64_TLS_LDO_64:
    case elfcpp::R_X86_64_TLS_IE_64:
    case elfcpp::R_X86_64_TLS_LE_64:
a788 1
#if 0
d791 11
a801 8
    case elfcpp::R_X86_64_TLS_GD_64:
    case elfcpp::R_X86_64_TLS_GD_PUSH:
    case elfcpp::R_X86_64_TLS_GD_CALL:
    case elfcpp::R_X86_64_TLS_GD_POP:
    case elfcpp::R_X86_64_TLS_LDM_64:
    case elfcpp::R_X86_64_TLS_LDM_PUSH:
    case elfcpp::R_X86_64_TLS_LDM_CALL:
    case elfcpp::R_X86_64_TLS_LDM_POP:
d827 2
d886 3
d890 4
a893 2
    case elfcpp::R_X86_64_GOTPC32:
    case elfcpp::R_X86_64_GOTPCREL:
a897 1
#if 0
d902 2
a903 1
    case elfcpp::R_X86_64_TLS_TPOFF:
d907 4
a910 2
    case elfcpp::R_X86_64_TLS_TPOFF64:
    case elfcpp::R_X86_64_TLS_DESC:
a914 1
#endif
d917 11
a927 8
    case elfcpp::R_X86_64_TLS_IE:
    case elfcpp::R_X86_64_TLS_GOTIE:
    case elfcpp::R_X86_64_TLS_LE:
    case elfcpp::R_X86_64_TLS_GD:
    case elfcpp::R_X86_64_TLS_LDM:
    case elfcpp::R_X86_64_TLS_LDO_64:
    case elfcpp::R_X86_64_TLS_IE_64:
    case elfcpp::R_X86_64_TLS_LE_64:
d933 2
a934 2
	  case elfcpp::R_X86_64_TLS_LE:
	  case elfcpp::R_X86_64_TLS_LE_64:
d940 6
a945 6
	  case elfcpp::R_X86_64_TLS_IE:
	  case elfcpp::R_X86_64_TLS_GOTIE:
	  case elfcpp::R_X86_64_TLS_GD:
	  case elfcpp::R_X86_64_TLS_LDM:
	  case elfcpp::R_X86_64_TLS_LDO_64:
	  case elfcpp::R_X86_64_TLS_IE_64:
d957 2
d960 8
a967 8
    case elfcpp::R_X86_64_TLS_GD_64:
    case elfcpp::R_X86_64_TLS_GD_PUSH:
    case elfcpp::R_X86_64_TLS_GD_CALL:
    case elfcpp::R_X86_64_TLS_GD_POP:
    case elfcpp::R_X86_64_TLS_LDM_64:
    case elfcpp::R_X86_64_TLS_LDM_PUSH:
    case elfcpp::R_X86_64_TLS_LDM_CALL:
    case elfcpp::R_X86_64_TLS_LDM_POP:
d1110 2
a1123 1
      // FIXME: Needs error checking.
a1127 1
      // FIXME: Needs error checking.
d1168 28
d1216 11
d1236 1
d1238 2
d1248 11
a1258 8
    case elfcpp::R_X86_64_TLS_IE:
    case elfcpp::R_X86_64_TLS_GOTIE:
    case elfcpp::R_X86_64_TLS_LE:
    case elfcpp::R_X86_64_TLS_GD:
    case elfcpp::R_X86_64_TLS_LDM:
    case elfcpp::R_X86_64_TLS_LDO_64:
    case elfcpp::R_X86_64_TLS_IE_64:
    case elfcpp::R_X86_64_TLS_LE_64:
d1266 3
d1270 8
a1277 8
    case elfcpp::R_X86_64_TLS_GD_64:
    case elfcpp::R_X86_64_TLS_GD_PUSH:
    case elfcpp::R_X86_64_TLS_GD_CALL:
    case elfcpp::R_X86_64_TLS_GD_POP:
    case elfcpp::R_X86_64_TLS_LDM_64:
    case elfcpp::R_X86_64_TLS_LDM_PUSH:
    case elfcpp::R_X86_64_TLS_LDM_CALL:
    case elfcpp::R_X86_64_TLS_LDM_POP:
@

