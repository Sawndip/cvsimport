head	1.29;
access;
symbols
	binutils-2_24-branch:1.29.0.2
	binutils-2_24-branchpoint:1.29
	binutils-2_21_1:1.27
	binutils-2_23_2:1.28
	binutils-2_23_1:1.28
	binutils-2_23:1.28
	binutils-2_23-branch:1.28.0.6
	binutils-2_23-branchpoint:1.28
	binutils-2_22_branch:1.28.0.4
	binutils-2_22:1.28
	binutils-2_22-branch:1.28.0.2
	binutils-2_22-branchpoint:1.28
	binutils-2_21:1.27
	binutils-2_21-branch:1.27.0.2
	binutils-2_21-branchpoint:1.27
	binutils-2_20_1:1.20.8.1
	binutils-2_20:1.20.8.1
	binutils-arc-20081103-branch:1.20.0.10
	binutils-arc-20081103-branchpoint:1.20
	binutils-2_20-branch:1.20.0.8
	binutils-2_20-branchpoint:1.20
	dje-cgen-play1-branch:1.20.0.6
	dje-cgen-play1-branchpoint:1.20
	arc-20081103-branch:1.20.0.4
	arc-20081103-branchpoint:1.20
	binutils-2_19_1:1.20
	binutils-2_19:1.20
	binutils-2_19-branch:1.20.0.2
	binutils-2_19-branchpoint:1.20
	binutils_latest_snapshot:1.29
	added-to-binutils:1.18;
locks; strict;
comment	@ * @;


1.29
date	2013.04.29.17.15.08;	author ccoutant;	state Exp;
branches;
next	1.28;

1.28
date	2010.12.14.19.03.30;	author rwild;	state Exp;
branches;
next	1.27;

1.27
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2010.08.03.20.38.09;	author ccoutant;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.21.21.03.54;	author ccoutant;	state Exp;
branches;
next	1.24;

1.24
date	2010.05.23.07.43.39;	author dougkwan;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.22;

1.22
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.09.23.18.19;	author dougkwan;	state Exp;
branches;
next	1.20;

1.20
date	2008.07.10.23.01.19;	author ian;	state Exp;
branches
	1.20.8.1;
next	1.19;

1.19
date	2008.05.21.21.37.44;	author ian;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.21.21.19.45;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.12.20.16.27.30;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.12.19.01.23.46;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.12.18.21.24.08;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.08.03.05.27;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.01.06.34.12;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.30.00.35.27;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.29.20.10.17;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.27.06.13.32;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.22.00.45.46;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.18.17.46.23;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.22.05.38.12;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.21.06.12.32;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.16.17.42.48;	author iant;	state Exp;
branches;
next	;

1.20.8.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	;


desc
@@


1.29
log
@2013-04-29  Alexander Ivchenko  <alexander.ivchenko@@intel.com>

gold/
	* output.cc (Output_section::add_merge_input_section): Allow
	to merge sections if the alignment is more than character size.
	* merge.h (Output_merge_string::Output_merge_string): Remove
	assert.
	* merge.cc (Output_merge_string<Char_type>::do_add_input_section): Count
	only not-null strings. Check the alignment of strings.
	* stringpool.h
	(Stringpool_template<Stringpool_char>::Stringpool_template): Add
	alignment as the argument.
	(Stringpool_template<Stringpool_char>::addralign_): New class member.
	* stringpool.cc (Stringpool_template<Stringpool_char>::new_key_offset):
	Align non-zero length strings according to the addralign_.
	(Stringpool_template<Stringpool_char>::set_string_offsets):
	Updating offsets according to the given alignment.
	* testsuite/Makefile.am (text_section_grouping): Test if string
	literals are getting merged.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/merge_string_literals_1.c: New file.
	* testsuite/merge_string_literals_2.c: Ditto.
	* testsuite/merge_string_literals.sh: Ditto.
@
text
@// merge.h -- handle section merging for gold  -*- C++ -*-

// Copyright 2006, 2007, 2008, 2010 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#ifndef GOLD_MERGE_H
#define GOLD_MERGE_H

#include <climits>
#include <map>
#include <vector>

#include "stringpool.h"
#include "output.h"

namespace gold
{

class Merge_map;

// For each object with merge sections, we store an Object_merge_map.
// This is used to map locations in input sections to a merged output
// section.  The output section itself is not recorded here--it can be
// found in the output_sections_ field of the Object.

class Object_merge_map
{
 public:
  Object_merge_map()
    : first_shnum_(-1U), first_map_(),
      second_shnum_(-1U), second_map_(),
      section_merge_maps_()
  { }

  ~Object_merge_map();

  // Add a mapping for MERGE_MAP, for the bytes from OFFSET to OFFSET
  // + LENGTH in the input section SHNDX to OUTPUT_OFFSET in the
  // output section.  An OUTPUT_OFFSET of -1 means that the bytes are
  // discarded.  OUTPUT_OFFSET is relative to the start of the merged
  // data in the output section.
  void
  add_mapping(const Merge_map*, unsigned int shndx, section_offset_type offset,
	      section_size_type length, section_offset_type output_offset);

  // Get the output offset for an input address.  MERGE_MAP is the map
  // we are looking for, or NULL if we don't care.  The input address
  // is at offset OFFSET in section SHNDX.  This sets *OUTPUT_OFFSET
  // to the offset in the output section; this will be -1 if the bytes
  // are not being copied to the output.  This returns true if the
  // mapping is known, false otherwise.  *OUTPUT_OFFSET is relative to
  // the start of the merged data in the output section.
  bool
  get_output_offset(const Merge_map*, unsigned int shndx,
		    section_offset_type offset,
		    section_offset_type* output_offset);

  // Return whether this is the merge map for section SHNDX.
  bool
  is_merge_section_for(const Merge_map*, unsigned int shndx);

  // Initialize an mapping from input offsets to output addresses for
  // section SHNDX.  STARTING_ADDRESS is the output address of the
  // merged section.
  template<int size>
  void
  initialize_input_to_output_map(
      unsigned int shndx,
      typename elfcpp::Elf_types<size>::Elf_Addr starting_address,
      Unordered_map<section_offset_type,
		    typename elfcpp::Elf_types<size>::Elf_Addr>*);

 private:
  // Map input section offsets to a length and an output section
  // offset.  An output section offset of -1 means that this part of
  // the input section is being discarded.
  struct Input_merge_entry
  {
    // The offset in the input section.
    section_offset_type input_offset;
    // The length.
    section_size_type length;
    // The offset in the output section.
    section_offset_type output_offset;
  };

  // A less-than comparison routine for Input_merge_entry.
  struct Input_merge_compare
  {
    bool
    operator()(const Input_merge_entry& i1, const Input_merge_entry& i2) const
    { return i1.input_offset < i2.input_offset; }
  };

  // A list of entries for a particular input section.
  struct Input_merge_map
  {
    typedef std::vector<Input_merge_entry> Entries;

    // We store these with the Relobj, and we look them up by input
    // section.  It is possible to have two different merge maps
    // associated with a single output section.  For example, this
    // happens routinely with .rodata, when merged string constants
    // and merged fixed size constants are both put into .rodata.  The
    // output offset that we store is not the offset from the start of
    // the output section; it is the offset from the start of the
    // merged data in the output section.  That means that the caller
    // is going to add the offset of the merged data within the output
    // section, which means that the caller needs to know which set of
    // merged data it found the entry in.  So it's not enough to find
    // this data based on the input section and the output section; we
    // also have to find it based on a set of merged data in the
    // output section.  In order to verify that we are looking at the
    // right data, we store a pointer to the Merge_map here, and we
    // pass in a pointer when looking at the data.  If we are asked to
    // look up information for a different Merge_map, we report that
    // we don't have it, rather than trying a lookup and returning an
    // answer which will receive the wrong offset.
    const Merge_map* merge_map;
    // The list of mappings.
    Entries entries;
    // Whether the ENTRIES field is sorted by input_offset.
    bool sorted;

    Input_merge_map()
      : merge_map(NULL), entries(), sorted(true)
    { }
  };

  // Map input section indices to merge maps.
  typedef std::map<unsigned int, Input_merge_map*> Section_merge_maps;

  // Return a pointer to the Input_merge_map to use for the input
  // section SHNDX, or NULL.
  Input_merge_map*
  get_input_merge_map(unsigned int shndx);

  // Get or make the Input_merge_map to use for the section SHNDX
  // with MERGE_MAP.
  Input_merge_map*
  get_or_make_input_merge_map(const Merge_map* merge_map, unsigned int shndx);

  // Any given object file will normally only have a couple of input
  // sections with mergeable contents.  So we keep the first two input
  // section numbers inline, and push any further ones into a map.  A
  // value of -1U in first_shnum_ or second_shnum_ means that we don't
  // have a corresponding entry.
  unsigned int first_shnum_;
  Input_merge_map first_map_;
  unsigned int second_shnum_;
  Input_merge_map second_map_;
  Section_merge_maps section_merge_maps_;
};

// This class manages mappings from input sections to offsets in an
// output section.  This is used where input sections are merged.  The
// actual data is stored in fields in Object.

class Merge_map
{
 public:
  Merge_map()
  { }

  // Add a mapping for the bytes from OFFSET to OFFSET + LENGTH in the
  // input section SHNDX in object OBJECT to OUTPUT_OFFSET in the
  // output section.  An OUTPUT_OFFSET of -1 means that the bytes are
  // discarded.  OUTPUT_OFFSET is not the offset from the start of the
  // output section, it is the offset from the start of the merged
  // data within the output section.
  void
  add_mapping(Relobj* object, unsigned int shndx,
	      section_offset_type offset, section_size_type length,
	      section_offset_type output_offset);

  // Return the output offset for an input address.  The input address
  // is at offset OFFSET in section SHNDX in OBJECT.  This sets
  // *OUTPUT_OFFSET to the offset in the output section; this will be
  // -1 if the bytes are not being copied to the output.  This returns
  // true if the mapping is known, false otherwise.  This returns the
  // value stored by add_mapping, namely the offset from the start of
  // the merged data within the output section.
  bool
  get_output_offset(const Relobj* object, unsigned int shndx,
		    section_offset_type offset,
		    section_offset_type* output_offset) const;

  // Return whether this is the merge mapping for section SHNDX in
  // OBJECT.  This should return true when get_output_offset would
  // return true for some input offset.
  bool
  is_merge_section_for(const Relobj* object, unsigned int shndx) const;
};

// A general class for SHF_MERGE data, to hold functions shared by
// fixed-size constant data and string data.

class Output_merge_base : public Output_section_data
{
 public:
  Output_merge_base(uint64_t entsize, uint64_t addralign)
    : Output_section_data(addralign), merge_map_(), entsize_(entsize),
      keeps_input_sections_(false), first_relobj_(NULL), first_shndx_(-1),
      input_sections_()
  { }

  // Return the entry size.
  uint64_t
  entsize() const
  { return this->entsize_; }

  // Whether this is a merge string section.  This is only true of
  // Output_merge_string.
  bool
  is_string()
  { return this->do_is_string(); }

  // Whether this keeps input sections.
  bool
  keeps_input_sections() const
  { return this->keeps_input_sections_; }

  // Set the keeps-input-sections flag.  This is virtual so that sub-classes
  // can perform additional checks.
  void
  set_keeps_input_sections()
  { this->do_set_keeps_input_sections(); }

  // Return the object of the first merged input section.  This used
  // for script processing.  This is NULL if merge section is empty.
  Relobj*
  first_relobj() const
  { return this->first_relobj_; }

  // Return the section index of the first merged input section.  This
  // is used for script processing.  This is valid only if merge section
  // is not valid.
  unsigned int
  first_shndx() const
  { 
    gold_assert(this->first_relobj_ != NULL);
    return this->first_shndx_;
  }
 
  // Set of merged input sections.
  typedef Unordered_set<Section_id, Section_id_hash> Input_sections;

  // Beginning of merged input sections.
  Input_sections::const_iterator
  input_sections_begin() const
  {
    gold_assert(this->keeps_input_sections_);
    return this->input_sections_.begin();
  }

  // Beginning of merged input sections.
  Input_sections::const_iterator
  input_sections_end() const
  {
    gold_assert(this->keeps_input_sections_);
    return this->input_sections_.end();
  }
 
 protected:
  // Return the output offset for an input offset.
  bool
  do_output_offset(const Relobj* object, unsigned int shndx,
		   section_offset_type offset,
		   section_offset_type* poutput) const;

  // Return whether this is the merge section for an input section.
  bool
  do_is_merge_section_for(const Relobj*, unsigned int shndx) const;

  // Add a mapping from an OFFSET in input section SHNDX in object
  // OBJECT to an OUTPUT_OFFSET in the output section.  OUTPUT_OFFSET
  // is the offset from the start of the merged data in the output
  // section.
  void
  add_mapping(Relobj* object, unsigned int shndx, section_offset_type offset,
	      section_size_type length, section_offset_type output_offset)
  {
    this->merge_map_.add_mapping(object, shndx, offset, length, output_offset);
  }

  // This may be overridden by the child class.
  virtual bool
  do_is_string()
  { return false; }

  // This may be overridden by the child class.
  virtual void
  do_set_keeps_input_sections()
  { this->keeps_input_sections_ = true; }

  // Record the merged input section for script processing.
  void
  record_input_section(Relobj* relobj, unsigned int shndx);

 private:
  // A mapping from input object/section/offset to offset in output
  // section.
  Merge_map merge_map_;
  // The entry size.  For fixed-size constants, this is the size of
  // the constants.  For strings, this is the size of a character.
  uint64_t entsize_;
  // Whether we keep input sections.
  bool keeps_input_sections_;
  // Object of the first merged input section.  We use this for script
  // processing.
  Relobj* first_relobj_;
  // Section index of the first merged input section. 
  unsigned int first_shndx_;
  // Input sections.  We only keep them is keeps_input_sections_ is true.
  Input_sections input_sections_;
};

// Handle SHF_MERGE sections with fixed-size constant data.

class Output_merge_data : public Output_merge_base
{
 public:
  Output_merge_data(uint64_t entsize, uint64_t addralign)
    : Output_merge_base(entsize, addralign), p_(NULL), len_(0), alc_(0),
      input_count_(0),
      hashtable_(128, Merge_data_hash(this), Merge_data_eq(this))
  { }

 protected:
  // Add an input section.
  bool
  do_add_input_section(Relobj* object, unsigned int shndx);

  // Set the final data size.
  void
  set_final_data_size();

  // Write the data to the file.
  void
  do_write(Output_file*);

  // Write the data to a buffer.
  void
  do_write_to_buffer(unsigned char*);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** merge constants")); }

  // Print merge stats to stderr.
  void
  do_print_merge_stats(const char* section_name);

  // Set keeps-input-sections flag.
  void
  do_set_keeps_input_sections()
  {
    gold_assert(this->input_count_ == 0);
    Output_merge_base::do_set_keeps_input_sections();
  }

 private:
  // We build a hash table of the fixed-size constants.  Each constant
  // is stored as a pointer into the section data we are accumulating.

  // A key in the hash table.  This is an offset in the section
  // contents we are building.
  typedef section_offset_type Merge_data_key;

  // Compute the hash code.  To do this we need a pointer back to the
  // object holding the data.
  class Merge_data_hash
  {
   public:
    Merge_data_hash(const Output_merge_data* pomd)
      : pomd_(pomd)
    { }

    size_t
    operator()(Merge_data_key) const;

   private:
    const Output_merge_data* pomd_;
  };

  friend class Merge_data_hash;

  // Compare two entries in the hash table for equality.  To do this
  // we need a pointer back to the object holding the data.  Note that
  // we now have a pointer to the object stored in two places in the
  // hash table.  Fixing this would require specializing the hash
  // table, which would be hard to do portably.
  class Merge_data_eq
  {
   public:
    Merge_data_eq(const Output_merge_data* pomd)
      : pomd_(pomd)
    { }

    bool
    operator()(Merge_data_key k1, Merge_data_key k2) const;

   private:
    const Output_merge_data* pomd_;
  };

  friend class Merge_data_eq;

  // The type of the hash table.
  typedef Unordered_set<Merge_data_key, Merge_data_hash, Merge_data_eq>
    Merge_data_hashtable;

  // Given a hash table key, which is just an offset into the section
  // data, return a pointer to the corresponding constant.
  const unsigned char*
  constant(Merge_data_key k) const
  {
    gold_assert(k >= 0 && k < static_cast<section_offset_type>(this->len_));
    return this->p_ + k;
  }

  // Add a constant to the output.
  void
  add_constant(const unsigned char*);

  // The accumulated data.
  unsigned char* p_;
  // The length of the accumulated data.
  section_size_type len_;
  // The size of the allocated buffer.
  section_size_type alc_;
  // The number of entries seen in input files.
  size_t input_count_;
  // The hash table.
  Merge_data_hashtable hashtable_;
};

// Handle SHF_MERGE sections with string data.  This is a template
// based on the type of the characters in the string.

template<typename Char_type>
class Output_merge_string : public Output_merge_base
{
 public:
  Output_merge_string(uint64_t addralign)
    : Output_merge_base(sizeof(Char_type), addralign), stringpool_(addralign),
      merged_strings_lists_(), input_count_(0), input_size_(0)
  {
    this->stringpool_.set_no_zero_null();
  }

 protected:
  // Add an input section.
  bool
  do_add_input_section(Relobj* object, unsigned int shndx);

  // Do all the final processing after the input sections are read in.
  // Returns the final data size.
  section_size_type
  finalize_merged_data();

  // Set the final data size.
  void
  set_final_data_size();

  // Write the data to the file.
  void
  do_write(Output_file*);

  // Write the data to a buffer.
  void
  do_write_to_buffer(unsigned char*);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** merge strings")); }

  // Print merge stats to stderr.
  void
  do_print_merge_stats(const char* section_name);

  // Writes the stringpool to a buffer.
  void
  stringpool_to_buffer(unsigned char* buffer, section_size_type buffer_size)
  { this->stringpool_.write_to_buffer(buffer, buffer_size); }

  // Clears all the data in the stringpool, to save on memory.
  void
  clear_stringpool()
  { this->stringpool_.clear(); }

  // Whether this is a merge string section.
  virtual bool
  do_is_string()
  { return true; }

  // Set keeps-input-sections flag.
  void
  do_set_keeps_input_sections()
  {
    gold_assert(this->input_count_ == 0);
    Output_merge_base::do_set_keeps_input_sections();
  }

 private:
  // The name of the string type, for stats.
  const char*
  string_name();

  // As we see input sections, we build a mapping from object, section
  // index and offset to strings.
  struct Merged_string
  {
    // The offset in the input section.
    section_offset_type offset;
    // The key in the Stringpool.
    Stringpool::Key stringpool_key;

    Merged_string(section_offset_type offseta, Stringpool::Key stringpool_keya)
      : offset(offseta), stringpool_key(stringpool_keya)
    { }
  };

  typedef std::vector<Merged_string> Merged_strings;

  struct Merged_strings_list
  {
    // The input object where the strings were found.
    Relobj* object;
    // The input section in the input object.
    unsigned int shndx;
    // The list of merged strings.
    Merged_strings merged_strings;

    Merged_strings_list(Relobj* objecta, unsigned int shndxa)
      : object(objecta), shndx(shndxa), merged_strings()
    { }
  };

  typedef std::vector<Merged_strings_list*> Merged_strings_lists;

  // As we see the strings, we add them to a Stringpool.
  Stringpool_template<Char_type> stringpool_;
  // Map from a location in an input object to an entry in the
  // Stringpool.
  Merged_strings_lists merged_strings_lists_;
  // The number of entries seen in input files.
  size_t input_count_;
  // The total size of input sections.
  size_t input_size_;
};

} // End namespace gold.

#endif // !defined(GOLD_MERGE_H)
@


1.28
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d464 1
a464 1
    : Output_merge_base(sizeof(Char_type), addralign), stringpool_(),
a466 1
    gold_assert(addralign <= sizeof(Char_type));
@


1.27
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d155 1
a155 1
  // Get or make the the Input_merge_map to use for the section SHNDX
d303 1
a303 1
  // This may be overriden by the child class.
@


1.26
log
@	* merge.cc (Output_merge_string::do_add_input_section): Count strings
	to reserve space in merged_strings vector. Keep total input size
	for stats.
	(Output_merge_string::do_print_merge_stats): Print total input size.
	* merge.h (Output_merge_string): Add input_size_ field.
	* stringpool.cc (Stringpool_template::string_length): Move
	implementations out of Stringpool_template class and place in
	stringpool.h.
	* stringpool.h (string_length): Move out of Stringpool_template.
@
text
@d73 1
a73 1
		    section_offset_type *output_offset);
d203 1
a203 1
		    section_offset_type *output_offset) const;
@


1.25
log
@	* merge.h (Output_merge_string::Merged_string): Remove object, shndx,
	string, and length fields.
	(Output_merge_string::Merged_strings_list): New type.
	(Output_merge_string::Merged_strings_lists): New typedef.
	(Output_merge_string): Replace merged_strings_ with
	merged_strings_lists_.
	* merge.cc (Output_merge_string::do_add_input_section): Allocate new
	Merged_strings_list per input object and section.  Don't store pointer
	to the string.  Don't store length with each merged string entry.
	(Output_merge_string::finalize_merged_data): Loop over list of merged
	strings lists.  Recompute length of each merged string.
@
text
@d465 1
a465 1
      merged_strings_lists_(), input_count_(0)
d569 2
@


1.24
log
@2010-05-23  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section::do_output_offset): Use convert_types
	instead of a cast.
	(Target_arm::apply_cortex_a8_workaround): Rewrite a conditional branch
	with a direct branch, not a conditional branch, to a stub.
	* merge.cc (Output_merge_base::record_input_section): New method
	defintion.
	(Output_merge_data::do_add_input_section): Record input section if
	keeps-input-sections flag is set.
	(Output_merge_string::do_add_input_section): Ditto.
	* merge.h (Output_merge_base::Output_merge_base): Initialize new data
	members KEEPS_INPUT_SECTIONS_, FIRST_RELOBJ_, FIRST_SHNDX_ and
	INPUT_SECTIONS_.
	(Output_merge_base::keeps_input_sections,
	Output_merge_base::set_keeps_input_sections,
	Output_merge_base::first_relobj, Output_merge_base::first_shndx): New
	method definitions.
	(Output_merge_base::Input_sections): New type declaration.
	(Output_merge_base::input_sections_begin,
	Output_merge_base::input_sections_end,
	Output_merge_base::do_set_keeps_input_sections): New method definitions.
	(Output_merge_base::bool keeps_input_sections_,
	Output_merge_base::first_relobj_, Output_merge_base::first_shndx_,
	Output_merge_base::input_sections_): New data members.
	(Output_merge_data::do_set_keeps_input_sections): New method
	defintion.
	(Output_merge_string::do_set_keeps_input_sections): Ditto.
	* output.cc (Output_section::Input_section::relobj): Move method
	defintion from class declaration to here and handle merge sections.
	(Output_section::Input_section::shndx): Ditto.
	(Output_section::Output_section): Remove initializations of removed
	data members and initialize new data member LOOKUP_MAPS_.
	(Output_section::add_input_section): Set keeps-input-sections flag
	for a newly created merge output section as appropriate.  Adjust code
	to use Output_section_lookup_maps class.
	(Output_section::add_relaxed_input_section): Adjst code for lookup
	maps code refactoring.
 	(Output_section::add_merge_input_section): Add a new parameter
	KEEPS_INPUT_SECTION.  Adjust code to use Output_section_lookup_maps
	class.  If adding input section to a newly created merge output
	section fails, remove the new merge section.
	(Output_section::convert_input_sections_in_list_to_relaxed_input_sections):
	Adjust code for use of the Output_section_lookup_maps class.
 	(Output_section::find_merge_section): Ditto.
	(Output_section::build_lookup_maps): New method defintion.
 	(Output_section::find_relaxed_input_section): Adjust code to use
	Output_section_lookup_maps class.
	(Output_section::get_input_sections): Export merge sections.  Adjust
	code to use Output_section_lookup_maps class.
	(Output_section:::add_script_input_section): Adjust code to use
	Output_section_lookup_maps class.  Update lookup maps for merge
	sections also.
	(Output_section::discard_states): Use Output_section_lookup_maps.
	(Output_section::restore_states): Same.
	* output.h (Merge_section_properties): Move class defintion out of
	Output_section.
	(Output_section_lookup_maps): New class.
	(Output_section::Input_section::is_merge_section): New method
	defintion.
	(Output_section::Input_section::relobj): Move defintion out of class
	defintion.  Declare method only.
	(Output_section::Input_section::shndx): Ditto.
	(Output_section::Input_section::output_merge_base): New method defintion.
     	(Output_section::Input_section::u2_.pomb): New union field.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Ouptut_relaxed_input_section_by_input_section_map):
	Remove types.
   	(Output_section::add_merge_input_section): Add new parameter
	KEEPS_INPUT_SECTIONS.
	(Output_section::build_lookup_maps): New method declaration.
	(Output_section::merge_section_map_,
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_): Remove data
	members.
	(Output_section::lookup_maps_): New data member.
@
text
@d465 1
a465 1
      merged_strings_(), input_count_(0)
a533 4
    // The input object where the string was found.
    Relobj* object;
    // The input section in the input object.
    unsigned int shndx;
a535 4
    // The string itself, a pointer into a Stringpool.
    const Char_type* string;
    // The length of the string in bytes, including the null terminator.
    size_t length;
d539 2
a540 5
    Merged_string(Relobj *objecta, unsigned int shndxa,
		  section_offset_type offseta, const Char_type* stringa,
		  size_t lengtha, Stringpool::Key stringpool_keya)
      : object(objecta), shndx(shndxa), offset(offseta), string(stringa),
	length(lengtha), stringpool_key(stringpool_keya)
d546 16
d566 1
a566 1
  Merged_strings merged_strings_;
@


1.23
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d219 3
a221 1
    : Output_section_data(addralign), merge_map_(), entsize_(entsize)
d235 46
d308 9
d324 9
d372 8
d517 8
@


1.22
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d218 2
a219 2
  Output_merge_base(uint64_t ent_size, uint64_t addr_align)
    : Output_section_data(addr_align), merge_map_(), entsize_(ent_size)
d244 2
a245 2
  // Add a mapping from an IN_OFFSET in input section SHNDX in object
  // OBJECT to an OUT_OFFSET in the output section.  OUT_OFFSET
d249 2
a250 2
  add_mapping(Relobj* object, unsigned int shndx, section_offset_type in_offset,
	      section_size_type length, section_offset_type out_offset)
d252 1
a252 1
    this->merge_map_.add_mapping(object, shndx, in_offset, length, out_offset);
d274 2
a275 2
  Output_merge_data(uint64_t ent_size, uint64_t addr_align)
    : Output_merge_base(ent_size, addr_align), p_(NULL), len_(0), alc_(0),
d389 2
a390 2
  Output_merge_string(uint64_t addr_align)
    : Output_merge_base(sizeof(Char_type), addr_align), stringpool_(),
d393 1
a393 1
    gold_assert(addr_align <= sizeof(Char_type));
@


1.21
log
@2009-10-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::make_output_section): Call target hook to make
	ordinary output section.
	(Layout::finalize): Adjust parameter list of call the
	Target::may_relax().
	* layout.h (class Layout::section_list): New method.
	* merge.h (Output_merge_base::entsize): Change visibility to public.
	(Output_merge_base::is_string, Output_merge_base::do_is_string):
	New methods.
	(Output_merge_string::do_is_string): New method.
	* object.cc (Sized_relobj::do_setup): renamed from
	Sized_relobj::set_up.
	* object.h (Sized_relobj::adjust_shndx,
	Sized_relobj::initializ_input_to_output_maps,
	Sized_relobj::free_input_to_output_maps): Change visibilities to
	protected.
	(Sized_relobj::setup): Virtualize.
	(Sized_relobj::do_setup): New method declaration.
	(Sized_relobj::invalidate_section_offset,
	Sized_relobj::do_invalidate_section_offset): New method decfinitions.
	(Sized_relobj::elf_file, Sized_relobj::local_values): New methods.
	* options.cc (parse_int): New function.
	* options.h (parse_int): New declaration.
	(DEFINE_int): New macro.
	(stub_group_size): New option.
	* output.cc (Output_section::Output_section): Initialize memebers
	merge_section_map_, merge_section_by_properties_map_,
	relaxed_input_section_map_, is_relaxed_input_section_map_valid_.
	(Output_section::add_input_section): Handled deferred code-fill
	generation and remove an old comment.
	(Output_section::add_relaxed_input_section): New method definition.
	(Output_section::add_merge_input_section): Use merge section by
	properties map to speed to search.  Update merge section maps
	as appropriate.
	(Output_section::build_relaxation_map): New method definition.
	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Same.
	(Output_section::relax_input_section): Renamed to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of pointers to relaxed sections.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section): New method definitions.
	(Output_section::is_input_address_mapped,
	Output_section::output_offset, Output_section::output_address):
	Use output section data maps to speed up searching.
	(Output_section::find_starting_output_address): Add comments.
	(Output_section::do_write,
	Output_section::write_to_postprocessing_buffer): Do code-fill
	generation as appropriate.
	(Output_section::get_input_sections): Invalidate relaxed input section
	map.
	(Output_section::restore_states): Adjust type of checkpoint .
	Invalidate relaxed input section map.
	* output.h (Output_merge_base): New class declaration.
	(Input_section_specifier): New class defintion.
	(class Output_relaxed_input_section) Change base class to
	Output_section_data_build.
	(Output_relaxed_input_section::Output_relaxed_input_section): Adjust
	base class initializer.
	(Output_section::add_relaxed_input_section): New method declaration.
	(Output_section::Input_section): Change visibility to protected.
     	(Output_section::Input_section::relobj,
	Output_section::Input_section::shndx): Handle relaxed input sections.
	Output_section::input_sections) Change visibility to protected.  Also
	define overload to return a non-const pointer.
	(Output_section::Merge_section_properties): New class defintion.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Relaxation_map): New types.
	(Output_section::relax_input_section): Rename method to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of relaxed section pointers.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section,
	Output_section::build_relaxation_map,
	Output_section::convert_input_sections_in_list_to_relaxed_sections):
	New method declarations.
	(Output_section::merge_section_map_
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_,
	Output_section::generate_code_fills_at_write_): New data members.
	* script-sections.cc
	(Output_section_element_input::set_section_addresses): Call
	current_data_size and addralign methods of relaxed input sections.
	(Orphan_output_section::set_section_addresses): Call current_data_size
	and addralign methods of relaxed input sections.
	* symtab.cc (Symbol_table::compute_final_value): Extract template
	from the body of Symbol_table::sized_finalize_symbol.
	(Symbol_table::sized_finalized_symbol): Call
	Symbol_table::compute_final_value.
	* symtab.h (Symbol_table::Compute_final_value_status): New enum type.
	(Symbol_table::compute_final_value): New templated method declaration.
	* target.cc (Target::do_make_output_section): New method defintion.
	* target.h (Target::make_output_section): New method declaration.
	(Target::relax): Add more parameters for input objects, symbol table
	and layout.  Adjust call to do_relax.
	(Target::do_make_output_section): New method declaration.
	(Target::do_relax): Add parameters for input objects, symbol table
	and layout.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d218 2
a219 2
  Output_merge_base(uint64_t entsize, uint64_t addralign)
    : Output_section_data(addralign), merge_map_(), entsize_(entsize)
d244 2
a245 2
  // Add a mapping from an OFFSET in input section SHNDX in object
  // OBJECT to an OUTPUT_OFFSET in the output section.  OUTPUT_OFFSET
d249 2
a250 2
  add_mapping(Relobj* object, unsigned int shndx, section_offset_type offset,
	      section_size_type length, section_offset_type output_offset)
d252 1
a252 1
    this->merge_map_.add_mapping(object, shndx, offset, length, output_offset);
d274 2
a275 2
  Output_merge_data(uint64_t entsize, uint64_t addralign)
    : Output_merge_base(entsize, addralign), p_(NULL), len_(0), alc_(0),
d389 2
a390 2
  Output_merge_string(uint64_t addralign)
    : Output_merge_base(sizeof(Char_type), addralign), stringpool_(),
d393 1
a393 1
    gold_assert(addralign <= sizeof(Char_type));
@


1.20
log
@	Handle output sections with more than 0x7fffffff bytes.
	* object.h (class Relobj): Change map_to_output_ to
	output_sections_, and just keep a section pointer.  Change all
	uses.  Move comdat group support to Sized_relobj.
	(Relobj::is_section_specially_mapped): Remove.
	(Relobj::output_section): Remove poff parameter.  Change all
	callers.
	(Relobj::output_section_offset): New function.
	(Relobj::set_section_offset): Rewrite.
	(Relobj::map_to_output): Remove.
	(Relobj::output_sections): New function.
	(Relobj::do_output_section_offset): New pure virtual function.
	(Relobj::do_set_section_offset): Likewise.
	(class Sized_relobj): Add section_offsets_ field.  Add comdat
	group support from Relobj.  Update declarations.
	(Sized_relobj::get_output_section_offset): New function.
	(Sized_relobj::do_output_section_offset): New function.
	(Sized_relobj::do_set_section_offset): New function.
	* object.cc (Relobj::output_section_address): Remove.
	(Sized_relobj::Sized_relobj): Initialize new fields.
	(Sized_relobj::include_section_group): Cast find_kept_object to
	Sized_relobj.
	(Sized_relobj::include_linkonce_section): Likewise.
	(Sized_relobj::do_layout): Use separate arrays for output section
	and output offset.
	(Sized_relobj::do_count_local_symbols): Change map_to_output to
	output_sections.
	(Sized_relobj::do_finalize_local_symbols): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_local_symbols): Likewise.
	(map_to_kept_section): Compute output address directly.
	* reloc.cc (Sized_relobj::do_read_relocs): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_sections): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (sized_finalize_symbol): Use output_section_offset.
	* output.h (class Output_reloc): Update declarations.  Change
	u2_.relobj to Sized_relobj*.
	(class Output_data_reloc): Change add functions to use
	Sized_relobj*.
	* output.cc (Output_reloc::Output_reloc): Change relobj to
	Sized_relobj*.
	(Output_reloc::local_section_offset): Change return type to
	Elf_Addr.  Use get_output_section_offset.
	(Output_reloc::get_address): Likewise.
	(Output_section::is_input_address_mapped): Don't call
	is_section_specially_mapped.
	(Output_section::output_offset): Likewise.
	(Output_section::output_address): Likewise.
	(Output_section::starting_output_address): Likewise.
	* copy-relocs.cc (Copy_relocs::copy_reloc): Change object
	parameter to Sized_relobj*.
	(Copy_relocs::need_copy_reloc): Likewise.
	(Copy_relocs::save): Likewise.
	* copy-relocs.h (class Copy_relocs): Update declarations.
	(class Copy_relocs::Copy_reloc_entry): Change constructor to use
	Sized_relobj*.  Change relobj_ field to Sized_relobj*.
	* target-reloc.h (relocate_for_relocatable): Change
	offset_in_output_section type to Elf_Addr.  Change code that uses
	it as well.
	* layout.cc (Layout::layout): Always set *off.
	* mapfile.cc (Mapfile::print_input_section): Use
	output_section_offset.
	* i386.cc (Target_i386::copy_reloc): Change object parameter to
	Sized_relobj*.
	* powerpc.cc (Target_powerpc::copy_reloc): Likewise.
	* sparc.cc (Target_sparc::copy_reloc): Likewise.
	* x86_64.cc (Target_x86_64::copy_reloc): Likewise.
@
text
@d222 11
a243 5
  // Return the entry size.
  uint64_t
  entsize() const
  { return this->entsize_; }

d255 5
d438 5
@


1.20.8.1
log
@Merge elfcpp and gold from trunk.
@
text
@a221 11
  // Return the entry size.
  uint64_t
  entsize() const
  { return this->entsize_; }

  // Whether this is a merge string section.  This is only true of
  // Output_merge_string.
  bool
  is_string()
  { return this->do_is_string(); }

d233 5
a248 5
  // This may be overriden by the child class.
  virtual bool
  do_is_string()
  { return false; }

a426 5
  // Whether this is a merge string section.
  virtual bool
  do_is_string()
  { return true; }

@


1.19
log
@	* mapfile.cc: New file.
	* mapfile.h: New file.
	* options.h (class General_options): Add -M/--print-map and -Map.
	* options.cc (General_options::finalize): Make -M equivalent to
	-Map -.
	* main.cc: Include <cstdio> and "mapfile.h".
	(main): Open mapfile if requested.
	* gold.cc (class Middle_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(queue_initial_tasks): Add mapfile parameter.  Change caller.
	(queue_middle_tasks): Likewise.
	* gold.h (queue_initial_tasks, queue_middle_tasks): Update
	declarations.
	* archive.cc: Include "mapfile.h".
	(Archive::add_symbols): Add mapfile parameter.  Change all
	callers.  Pass mapfile, symbol, and reason to include_member.
	(Archive::include_all_members): Add mapfile parameter.  Change all
	callers.
	(Archive::include_member): Add mapfile, sym, and why parameters.
	Change all callers.  Report inclusion to map file.
	* archive.h: Include "fileread.h".
	(class Archive): Update declarations.
	(Archive::file): New const method.
	(class Add_archive_symbols): Add mapfile_ field.  Update
	constructor.  Change all callers.
	* readsyms.h (class Read_symbols): Likewise.
	(class Finish_group): Likewise.
	(class Read_script): Likewise.
	* common.cc: Include "mapfile.h".
	(Symbol_table::allocate_commons): Add mapfile parameter.  Change
	all callers.
	(Symbol_table::do_allocate_commons): Likewise.
	(Symbol_table::do_allocate_commons_list): Likewise.  Report common
	symbol allocation to mapfile.
	* common.h (class Allocate_commons_task): Add mapfile_ field.
	Update constructor.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* layout.cc: Include "mapfile.h".
	(Layout_task_runner::run): Print information to mapfile.
	(Layout::create_gold_note): Change Output_data_fixed_space to
	Output_data_zero_fill.
	(Layout::create_build_id): Likewise.
	(Layout::print_to_mapfile): New function.
	* layout.h (class Layout_task_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(class Layout): Declare print_to_mapfile.
	* output.cc (Output_section::Input_section::print_to_mapfile): New
	function.
	(Output_section::add_input_section): If producing a map, always
	add to input_sections_ list.
	(Output_section::do_print_to_mapfile): New function.
	(Output_segment::print_sections_to_mapfile): New function.
	(Output_segment::print_section_list_to_mapfile): New function.
	* output.h: Include "mapfile.h".
	(Output_data::print_to_mapfile): New function.
	(Output_data::do_print_to_mapfile): New virtual function.
	(Output_segment_headers::do_print_to_mapfile): New function.
	(Output_file_header::do_print_to_mapfile): New function.
	(Output_data_const::do_print_to_mapfile): New function.
	(class Output_data_const_buffer): Add map_name_ field.  Update
	constructor.  Change all callers.  Add do_print_to_mapfile
	function.
	(class Output_data_fixed_space): Likewise.
	(class Output_data_space): Likewise.
	(class Output_data_zero_fill): New class.
	(Output_data_strtab::do_print_to_mapfile): New function.
	(Output_data_reloc_base::do_print_to_mapfile): New function.
	(Output_relocatable_relocs::do_print_to_mapfile): New function.
	(Output_data_group::do_print_to_mapfile): New function.
	(Output_data_got::do_print_to_mapfile): New function.
	(Output_data_dynamic::do_print_to_mapfile): New function.
	(Output_symtab_xindex::do_print_to_mapfile): New function.
	(class Output_section): Declare do_print_to_mapflie.  Declare
	print_to_mapfile in Input_section.
	(class Output_segment): Declare new functions.
	* object.h (Sized_relobj::symbol_count): New function.
	* script-sections.cc
	(Output_section_element_dot_assignment::set_section_addresses):
	Change Output_data_fixed_space to Output_data_zero_fill.
	(Output_data_expression::do_print_to_mapfile): New function.
	* script.cc (read_input_script): Add mapfile parameter.  Change
	all callers.
	* script.h (read_input_script): Update declaration.
	* ehframe.h (Eh_frame_hdr::do_print_to_mapfile): New function.
	(Eh_frame::do_print_to_mapfile): New function.
	* merge.h (Output_merge_data::do_print_to_mapfile): New function.
	(Output_merge_string::do_print_to_mapfile): New function.
	* i386.cc (Output_data_plt_i386::do_print_to_mapfile): New
	function.
	* sparc.cc (Output_data_plt_sparc::do_print_to_mapfile): New
	function.
	* x86_64.cc (Output_data_plt_x86_64::do_print_to_mapfile): New
	function.
	* Makefile.am (CCFILES): Add mapfile.cc.
	(HFILES): Add mapfile.h.
	* Makefile.in: Rebuild.
@
text
@d41 1
a41 1
// found in the map_to_output_ field of the Object.
@


1.18
log
@Update copyright years.  Update language files.
@
text
@d286 5
d408 5
@


1.17
log
@Speed up relocations against local symbols in merged sections.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.16
log
@Update comments about output offsets and merged input sections.
@
text
@d27 2
d36 136
d204 6
d222 1
d229 4
a232 1
 protected:
@


1.15
log
@Move Stringpool offsets into a chunked_vector indexed by keys.
@
text
@d47 3
a49 1
  // discarded.
d59 3
a61 1
  // true if the mapping is known, false otherwise.
d91 3
a93 1
  // OBJECT to an OUTPUT_OFFSET in the output section.
@


1.14
log
@Print statistics about merge sections with --stats.
@
text
@d282 2
d287 1
a287 1
		  size_t lengtha)
d289 1
a289 1
	length(lengtha)
@


1.13
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d111 1
d115 1
d132 4
d206 2
d221 1
a221 1
      merged_strings_()
d249 4
d264 4
d298 2
@


1.12
log
@From Craig Silverstein: Fix error message, add this->.
@
text
@d49 3
a51 2
  add_mapping(Relobj* object, unsigned int shndx, off_t offset, off_t length,
	      off_t output_offset);
d59 3
a61 2
  get_output_offset(const Relobj* object, unsigned int shndx, off_t offset,
		    off_t *output_offset) const;
d76 3
a78 2
  do_output_offset(const Relobj* object, unsigned int shndx, off_t offset,
		   off_t* poutput) const;
d89 2
a90 2
  add_mapping(Relobj* object, unsigned int shndx, off_t offset,
	      off_t length, off_t output_offset)
d136 1
a136 1
  typedef off_t Merge_data_key;
d186 1
a186 1
    gold_assert(k >= 0 && k < this->len_);
d197 1
a197 1
  off_t len_;
d199 1
a199 1
  size_t alc_;
d226 1
a226 1
  off_t
d243 1
a243 1
  stringpool_to_buffer(unsigned char* buffer, size_t buffer_size)
d261 1
a261 1
    off_t offset;
d267 3
a269 2
    Merged_string(Relobj *objecta, unsigned int shndxa, off_t offseta,
		  const Char_type* stringa, size_t lengtha)
@


1.11
log
@Compress all debug sections.
@
text
@d246 1
a246 1
  { stringpool_.clear(); }
@


1.10
log
@From Craig Silverstein: Add support for compressing .debug_str section.
@
text
@d123 4
d234 4
d240 1
a240 1
  stringpool_to_buffer(char* buffer, size_t buffer_size)
@


1.9
log
@Clean up setting address and section offset.
@
text
@d212 1
d217 5
d229 10
@


1.8
log
@Rework merge_map for speed.
@
text
@d117 1
a117 1
  do_set_address(uint64_t, off_t);
d218 1
a218 1
  do_set_address(uint64_t, off_t);
@


1.7
log
@Make Merge_key_less operator() inline.
@
text
@d35 2
a36 1
// output section.  This is used where input sections are merged.
a41 1
    : merge_map_()
a59 28

 private:
  // We build a mapping from OBJECT/SHNDX/OFFSET to an offset and
  // length in the output section.
  struct Merge_key
  {
    const Relobj* object;
    unsigned int shndx;
    off_t offset;
  };

  struct Merge_key_less
  {
    inline bool
    operator()(const Merge_key&, const Merge_key&) const;
  };

  struct Merge_value
  {
    off_t length;
    off_t output_offset;
  };

  typedef std::map<Merge_key, Merge_value, Merge_key_less> Merge_mapping;

  // A mapping from input object/section/offset to offset in output
  // section.
  Merge_mapping merge_map_;
@


1.6
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d73 1
a73 1
    bool
@


1.5
log
@Correctly handle alignment in merge sections.
@
text
@d34 56
d100 1
a100 1
  // Return the output address for an input address.
d102 2
a103 2
  do_output_address(const Relobj* object, unsigned int shndx, off_t offset,
		    uint64_t output_section_address, uint64_t* poutput) const;
d115 4
a118 1
	      off_t output_offset);
a120 17
  // We build a mapping from OBJECT/SHNDX/OFFSET to an offset in the
  // output section.
  struct Merge_key
  {
    const Relobj* object;
    unsigned int shndx;
    off_t offset;
  };

  struct Merge_key_less
  {
    bool
    operator()(const Merge_key&, const Merge_key&) const;
  };

  typedef std::map<Merge_key, off_t, Merge_key_less> Merge_map;

a123 1

d265 2
d269 3
a271 2
		  const Char_type* stringa)
      : object(objecta), shndx(shndxa), offset(offseta), string(stringa)
@


1.4
log
@Add licensing text to every source file.
@
text
@d40 2
a41 2
  Output_merge_base(uint64_t entsize)
    : Output_section_data(1), merge_map_(), entsize_(entsize)
d93 2
a94 2
  Output_merge_data(uint64_t entsize)
    : Output_merge_base(entsize), p_(NULL), len_(0), alc_(0),
d191 7
a197 3
  Output_merge_string()
    : Output_merge_base(sizeof(Char_type)), stringpool_(), merged_strings_()
  { this->stringpool_.set_no_zero_null(); }
@


1.3
log
@We don't need a hash table mapping input locations to strings.
@
text
@d3 20
@


1.2
log
@Set Stringpool zero_null option via a call, not a default constructor
argument.
@
text
@d172 1
a172 1
    : Output_merge_base(sizeof(Char_type)), stringpool_(), hashtable_()
d190 1
a190 1
  struct Merge_string_key
d192 1
d194 1
d196 1
d198 2
d201 3
a203 2
    Merge_string_key(Relobj *objecta, unsigned int shndxa, off_t offseta)
      : object(objecta), shndx(shndxa), offset(offseta)
d207 1
a207 15
  struct Merge_string_key_hash
  {
    size_t
    operator()(const Merge_string_key&) const;
  };

  struct Merge_string_key_eq
  {
    bool
    operator()(const Merge_string_key&, const Merge_string_key&) const;
  };

  typedef Unordered_map<Merge_string_key, const Char_type*,
			Merge_string_key_hash, Merge_string_key_eq>
    Merge_string_hashtable;
d213 1
a213 1
  Merge_string_hashtable hashtable_;
@


1.1
log
@Add support for SHF_MERGE sections.
@
text
@d172 2
a173 2
    : Output_merge_base(sizeof(Char_type)), stringpool_(false), hashtable_()
  { }
@

