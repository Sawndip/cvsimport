head	1.58;
access;
symbols
	binutils-2_24-branch:1.58.0.2
	binutils-2_24-branchpoint:1.58
	binutils-2_21_1:1.44
	binutils-2_23_2:1.52.2.1
	binutils-2_23_1:1.52.2.1
	binutils-2_23:1.52
	binutils-2_23-branch:1.52.0.2
	binutils-2_23-branchpoint:1.52
	binutils-2_22_branch:1.50.2.1.0.2
	binutils-2_22:1.50.2.1
	binutils-2_22-branch:1.50.0.2
	binutils-2_22-branchpoint:1.50
	binutils-2_21:1.44
	binutils-2_21-branch:1.44.0.2
	binutils-2_21-branchpoint:1.44
	binutils-2_20_1:1.34.2.1
	binutils-2_20:1.34.2.1
	binutils-arc-20081103-branch:1.29.0.4
	binutils-arc-20081103-branchpoint:1.29
	binutils-2_20-branch:1.34.0.2
	binutils-2_20-branchpoint:1.34
	dje-cgen-play1-branch:1.33.0.2
	dje-cgen-play1-branchpoint:1.33
	arc-20081103-branch:1.29.0.2
	arc-20081103-branchpoint:1.29
	binutils-2_19_1:1.27
	binutils-2_19:1.27
	binutils-2_19-branch:1.27.0.2
	binutils-2_19-branchpoint:1.27
	binutils_latest_snapshot:1.58
	added-to-binutils:1.22;
locks; strict;
comment	@ * @;


1.58
date	2013.05.21.21.14.39;	author ccoutant;	state Exp;
branches;
next	1.57;

1.57
date	2013.04.27.00.53.16;	author ian;	state Exp;
branches;
next	1.56;

1.56
date	2012.11.01.23.27.00;	author roland;	state Exp;
branches;
next	1.55;

1.55
date	2012.10.18.04.18.18;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2012.09.12.22.43.53;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2012.09.05.00.34.20;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2011.12.15.23.29.24;	author hjl;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2011.11.10.00.41.53;	author dougkwan;	state Exp;
branches;
next	1.50;

1.50
date	2011.07.11.16.19.51;	author ian;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2011.07.09.06.11.34;	author ian;	state Exp;
branches;
next	1.48;

1.48
date	2011.07.09.00.47.11;	author ian;	state Exp;
branches;
next	1.47;

1.47
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.46;

1.46
date	2011.04.22.22.39.55;	author ccoutant;	state Exp;
branches;
next	1.45;

1.45
date	2010.12.14.19.03.30;	author rwild;	state Exp;
branches;
next	1.44;

1.44
date	2010.08.19.22.50.15;	author ian;	state Exp;
branches;
next	1.43;

1.43
date	2010.06.10.17.20.27;	author ccoutant;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.26.03.33.59;	author dougkwan;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.20.21.13.30;	author tmsriram;	state Exp;
branches;
next	1.40;

1.40
date	2010.03.03.19.31.54;	author ian;	state Exp;
branches;
next	1.39;

1.39
date	2010.01.12.19.12.40;	author ian;	state Exp;
branches;
next	1.38;

1.38
date	2010.01.09.00.13.48;	author ian;	state Exp;
branches;
next	1.37;

1.37
date	2009.12.30.20.35.52;	author ian;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.29.05.16.23;	author ian;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.06.22.58.27;	author ian;	state Exp;
branches;
next	1.34;

1.34
date	2009.08.05.20.51.56;	author tmsriram;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2009.03.04.06.46.27;	author ian;	state Exp;
branches;
next	1.32;

1.32
date	2009.02.06.19.20.09;	author cgd;	state Exp;
branches;
next	1.31;

1.31
date	2008.12.12.16.33.05;	author ian;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.12.02.41.39;	author ian;	state Exp;
branches;
next	1.29;

1.29
date	2008.09.29.21.10.26;	author ccoutant;	state Exp;
branches;
next	1.28;

1.28
date	2008.09.16.17.23.37;	author ian;	state Exp;
branches;
next	1.27;

1.27
date	2008.07.10.23.01.20;	author ian;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.29.23.51.30;	author ian;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.01.02.01.23;	author ccoutant;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.01.01.23.21;	author ccoutant;	state Exp;
branches;
next	1.23;

1.23
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.22;

1.22
date	2008.03.20.05.22.37;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.06.06.10.44;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.27.22.38.18;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2008.02.06.08.13.50;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.12.20.21.21.24;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.14.22.31.02;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.16.23.23.08;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.14.06.49.14;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.11.19.13.02;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2007.08.21.21.29.12;	author chatham;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.16.17.42.48;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.16.00.38.25;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.03.18.26.11;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.20.20.40.49;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.10.18.54.06;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.29.19.58.17;	author iant;	state Exp;
branches;
next	;

1.52.2.1
date	2012.11.07.17.34.23;	author roland;	state Exp;
branches;
next	;

1.50.2.1
date	2011.11.21.09.32.16;	author gingold;	state Exp;
branches;
next	;

1.34.2.1
date	2009.10.16.05.51.18;	author ian;	state Exp;
branches;
next	;


desc
@@


1.58
log
@gold/
	* symtab.h (Symbol::is_cxx_vtable): New function.
	* target-reloc.h (relocate_section): Check for vtable symbol.
	* testsuite/Makefile.am (missing_key_func.sh): New test case.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/missing_key_func.cc: New test source.
	* testsuite/missing_key_func.sh: New test script.
@
text
@// target-reloc.h -- target specific relocation support  -*- C++ -*-

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#ifndef GOLD_TARGET_RELOC_H
#define GOLD_TARGET_RELOC_H

#include "elfcpp.h"
#include "symtab.h"
#include "object.h"
#include "reloc.h"
#include "reloc-types.h"

namespace gold
{

// This function implements the generic part of reloc scanning.  The
// template parameter Scan must be a class type which provides two
// functions: local() and global().  Those functions implement the
// machine specific part of scanning.  We do it this way to
// avoid making a function call for each relocation, and to avoid
// repeating the generic code for each target.

template<int size, bool big_endian, typename Target_type, int sh_type,
	 typename Scan>
inline void
scan_relocs(
    Symbol_table* symtab,
    Layout* layout,
    Target_type* target,
    Sized_relobj_file<size, big_endian>* object,
    unsigned int data_shndx,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    size_t local_count,
    const unsigned char* plocal_syms)
{
  typedef typename Reloc_types<sh_type, size, big_endian>::Reloc Reltype;
  const int reloc_size = Reloc_types<sh_type, size, big_endian>::reloc_size;
  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;
  Scan scan;

  for (size_t i = 0; i < reloc_count; ++i, prelocs += reloc_size)
    {
      Reltype reloc(prelocs);

      if (needs_special_offset_handling
	  && !output_section->is_input_address_mapped(object, data_shndx,
						      reloc.get_r_offset()))
	continue;

      typename elfcpp::Elf_types<size>::Elf_WXword r_info = reloc.get_r_info();
      unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);
      unsigned int r_type = elfcpp::elf_r_type<size>(r_info);

      if (r_sym < local_count)
	{
	  gold_assert(plocal_syms != NULL);
	  typename elfcpp::Sym<size, big_endian> lsym(plocal_syms
						      + r_sym * sym_size);
	  unsigned int shndx = lsym.get_st_shndx();
	  bool is_ordinary;
	  shndx = object->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
	  // If RELOC is a relocation against a local symbol in a
	  // section we are discarding then we can ignore it.  It will
	  // eventually become a reloc against the value zero.
	  //
	  // FIXME: We should issue a warning if this is an
	  // allocated section; is this the best place to do it?
	  //
	  // FIXME: The old GNU linker would in some cases look
	  // for the linkonce section which caused this section to
	  // be discarded, and, if the other section was the same
	  // size, change the reloc to refer to the other section.
	  // That seems risky and weird to me, and I don't know of
	  // any case where it is actually required.
	  bool is_discarded = (is_ordinary
			       && shndx != elfcpp::SHN_UNDEF
			       && !object->is_section_included(shndx)
			       && !symtab->is_section_folded(object, shndx));
	  scan.local(symtab, layout, target, object, data_shndx,
		     output_section, reloc, r_type, lsym, is_discarded);
	}
      else
	{
	  Symbol* gsym = object->global_symbol(r_sym);
	  gold_assert(gsym != NULL);
	  if (gsym->is_forwarder())
	    gsym = symtab->resolve_forwards(gsym);

	  scan.global(symtab, layout, target, object, data_shndx,
		      output_section, reloc, r_type, gsym);
	}
    }
}

// Behavior for relocations to discarded comdat sections.

enum Comdat_behavior
{
  CB_UNDETERMINED,   // Not yet determined -- need to look at section name.
  CB_PRETEND,        // Attempt to map to the corresponding kept section.
  CB_IGNORE,         // Ignore the relocation.
  CB_WARNING         // Print a warning.
};

class Default_comdat_behavior
{
 public:
  // Decide what the linker should do for relocations that refer to
  // discarded comdat sections.  This decision is based on the name of
  // the section being relocated.

  inline Comdat_behavior
  get(const char* name)
  {
    if (Layout::is_debug_info_section(name))
      return CB_PRETEND;
    if (strcmp(name, ".eh_frame") == 0
	|| strcmp(name, ".gcc_except_table") == 0)
      return CB_IGNORE;
    return CB_WARNING;
  }
};

// Give an error for a symbol with non-default visibility which is not
// defined locally.

inline void
visibility_error(const Symbol* sym)
{
  const char* v;
  switch (sym->visibility())
    {
    case elfcpp::STV_INTERNAL:
      v = _("internal");
      break;
    case elfcpp::STV_HIDDEN:
      v = _("hidden");
      break;
    case elfcpp::STV_PROTECTED:
      v = _("protected");
      break;
    default:
      gold_unreachable();
    }
  gold_error(_("%s symbol '%s' is not defined locally"),
	     v, sym->name());
}

// Return true if we are should issue an error saying that SYM is an
// undefined symbol.  This is called if there is a relocation against
// SYM.

inline bool
issue_undefined_symbol_error(const Symbol* sym)
{
  // We only report global symbols.
  if (sym == NULL)
    return false;

  // We only report undefined symbols.
  if (!sym->is_undefined() && !sym->is_placeholder())
    return false;

  // We don't report weak symbols.
  if (sym->binding() == elfcpp::STB_WEAK)
    return false;

  // We don't report symbols defined in discarded sections.
  if (sym->is_defined_in_discarded_section())
    return false;

  // If the target defines this symbol, don't report it here.
  if (parameters->target().is_defined_by_abi(sym))
    return false;

  // See if we've been told to ignore whether this symbol is
  // undefined.
  const char* const u = parameters->options().unresolved_symbols();
  if (u != NULL)
    {
      if (strcmp(u, "ignore-all") == 0)
	return false;
      if (strcmp(u, "report-all") == 0)
	return true;
      if (strcmp(u, "ignore-in-object-files") == 0 && !sym->in_dyn())
	return false;
      if (strcmp(u, "ignore-in-shared-libs") == 0 && !sym->in_reg())
	return false;
    }

  // When creating a shared library, only report unresolved symbols if
  // -z defs was used.
  if (parameters->options().shared() && !parameters->options().defs())
    return false;

  // Otherwise issue a warning.
  return true;
}

// This function implements the generic part of relocation processing.
// The template parameter Relocate must be a class type which provides
// a single function, relocate(), which implements the machine
// specific part of a relocation.

// The template parameter Relocate_comdat_behavior is a class type
// which provides a single function, get(), which determines what the
// linker should do for relocations that refer to discarded comdat
// sections.

// SIZE is the ELF size: 32 or 64.  BIG_ENDIAN is the endianness of
// the data.  SH_TYPE is the section type: SHT_REL or SHT_RELA.
// RELOCATE implements operator() to do a relocation.

// PRELOCS points to the relocation data.  RELOC_COUNT is the number
// of relocs.  OUTPUT_SECTION is the output section.
// NEEDS_SPECIAL_OFFSET_HANDLING is true if input offsets need to be
// mapped to output offsets.

// VIEW is the section data, VIEW_ADDRESS is its memory address, and
// VIEW_SIZE is the size.  These refer to the input section, unless
// NEEDS_SPECIAL_OFFSET_HANDLING is true, in which case they refer to
// the output section.

// RELOC_SYMBOL_CHANGES is used for -fsplit-stack support.  If it is
// not NULL, it is a vector indexed by relocation index.  If that
// entry is not NULL, it points to a global symbol which used as the
// symbol for the relocation, ignoring the symbol index in the
// relocation.

template<int size, bool big_endian, typename Target_type, int sh_type,
	 typename Relocate,
	 typename Relocate_comdat_behavior>
inline void
relocate_section(
    const Relocate_info<size, big_endian>* relinfo,
    Target_type* target,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    unsigned char* view,
    typename elfcpp::Elf_types<size>::Elf_Addr view_address,
    section_size_type view_size,
    const Reloc_symbol_changes* reloc_symbol_changes)
{
  typedef typename Reloc_types<sh_type, size, big_endian>::Reloc Reltype;
  const int reloc_size = Reloc_types<sh_type, size, big_endian>::reloc_size;
  Relocate relocate;
  Relocate_comdat_behavior relocate_comdat_behavior;

  Sized_relobj_file<size, big_endian>* object = relinfo->object;
  unsigned int local_count = object->local_symbol_count();

  Comdat_behavior comdat_behavior = CB_UNDETERMINED;

  for (size_t i = 0; i < reloc_count; ++i, prelocs += reloc_size)
    {
      Reltype reloc(prelocs);

      section_offset_type offset =
	convert_to_section_size_type(reloc.get_r_offset());

      if (needs_special_offset_handling)
	{
	  offset = output_section->output_offset(relinfo->object,
						 relinfo->data_shndx,
						 offset);
	  if (offset == -1)
	    continue;
	}

      typename elfcpp::Elf_types<size>::Elf_WXword r_info = reloc.get_r_info();
      unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);
      unsigned int r_type = elfcpp::elf_r_type<size>(r_info);

      const Sized_symbol<size>* sym;

      Symbol_value<size> symval;
      const Symbol_value<size> *psymval;
      bool is_defined_in_discarded_section;
      unsigned int shndx;
      if (r_sym < local_count
	  && (reloc_symbol_changes == NULL
	      || (*reloc_symbol_changes)[i] == NULL))
	{
	  sym = NULL;
	  psymval = object->local_symbol(r_sym);

          // If the local symbol belongs to a section we are discarding,
          // and that section is a debug section, try to find the
          // corresponding kept section and map this symbol to its
          // counterpart in the kept section.  The symbol must not
          // correspond to a section we are folding.
	  bool is_ordinary;
	  shndx = psymval->input_shndx(&is_ordinary);
	  is_defined_in_discarded_section =
	    (is_ordinary
	     && shndx != elfcpp::SHN_UNDEF
	     && !object->is_section_included(shndx)
	     && !relinfo->symtab->is_section_folded(object, shndx));
	}
      else
	{
	  const Symbol* gsym;
	  if (reloc_symbol_changes != NULL
	      && (*reloc_symbol_changes)[i] != NULL)
	    gsym = (*reloc_symbol_changes)[i];
	  else
	    {
	      gsym = object->global_symbol(r_sym);
	      gold_assert(gsym != NULL);
	      if (gsym->is_forwarder())
		gsym = relinfo->symtab->resolve_forwards(gsym);
	    }

	  sym = static_cast<const Sized_symbol<size>*>(gsym);
	  if (sym->has_symtab_index() && sym->symtab_index() != -1U)
	    symval.set_output_symtab_index(sym->symtab_index());
	  else
	    symval.set_no_output_symtab_entry();
	  symval.set_output_value(sym->value());
	  if (gsym->type() == elfcpp::STT_TLS)
	    symval.set_is_tls_symbol();
	  else if (gsym->type() == elfcpp::STT_GNU_IFUNC)
	    symval.set_is_ifunc_symbol();
	  psymval = &symval;

	  is_defined_in_discarded_section =
	    (gsym->is_defined_in_discarded_section()
	     && gsym->is_undefined());
	  shndx = 0;
	}

      Symbol_value<size> symval2;
      if (is_defined_in_discarded_section)
	{
	  if (comdat_behavior == CB_UNDETERMINED)
	    {
	      std::string name = object->section_name(relinfo->data_shndx);
	      comdat_behavior = relocate_comdat_behavior.get(name.c_str());
	    }
	  if (comdat_behavior == CB_PRETEND)
	    {
	      // FIXME: This case does not work for global symbols.
	      // We have no place to store the original section index.
	      // Fortunately this does not matter for comdat sections,
	      // only for sections explicitly discarded by a linker
	      // script.
	      bool found;
	      typename elfcpp::Elf_types<size>::Elf_Addr value =
		object->map_to_kept_section(shndx, &found);
	      if (found)
		symval2.set_output_value(value + psymval->input_value());
	      else
		symval2.set_output_value(0);
	    }
	  else
	    {
	      if (comdat_behavior == CB_WARNING)
		gold_warning_at_location(relinfo, i, offset,
					 _("relocation refers to discarded "
					   "section"));
	      symval2.set_output_value(0);
	    }
	  symval2.set_no_output_symtab_entry();
	  psymval = &symval2;
	}

      // If OFFSET is out of range, still let the target decide to
      // ignore the relocation.  Pass in NULL as the VIEW argument so
      // that it can return quickly without trashing an invalid memory
      // address.
      unsigned char *v = view + offset;
      if (offset < 0 || static_cast<section_size_type>(offset) >= view_size)
	v = NULL;

      if (!relocate.relocate(relinfo, target, output_section, i, reloc,
			     r_type, sym, psymval, v, view_address + offset,
			     view_size))
	continue;

      if (v == NULL)
	{
	  gold_error_at_location(relinfo, i, offset,
				 _("reloc has bad offset %zu"),
				 static_cast<size_t>(offset));
	  continue;
	}

      if (issue_undefined_symbol_error(sym))
	{
	  gold_undefined_symbol_at_location(sym, relinfo, i, offset);
	  if (sym->is_cxx_vtable())
	    gold_info(_("%s: the vtable symbol may be undefined because "
			"the class is missing its key function"),
		      program_name);
	}
      else if (sym != NULL
	       && sym->visibility() != elfcpp::STV_DEFAULT
	       && (sym->is_undefined() || sym->is_from_dynobj()))
	visibility_error(sym);

      if (sym != NULL && sym->has_warning())
	relinfo->symtab->issue_warning(sym, relinfo, i, offset);
    }
}

// Apply an incremental relocation.

template<int size, bool big_endian, typename Target_type,
	 typename Relocate>
void
apply_relocation(const Relocate_info<size, big_endian>* relinfo,
		 Target_type* target,
		 typename elfcpp::Elf_types<size>::Elf_Addr r_offset,
		 unsigned int r_type,
		 typename elfcpp::Elf_types<size>::Elf_Swxword r_addend,
		 const Symbol* gsym,
		 unsigned char* view,
		 typename elfcpp::Elf_types<size>::Elf_Addr address,
		 section_size_type view_size)
{
  // Construct the ELF relocation in a temporary buffer.
  const int reloc_size = elfcpp::Elf_sizes<size>::rela_size;
  unsigned char relbuf[reloc_size];
  elfcpp::Rela<size, big_endian> rel(relbuf);
  elfcpp::Rela_write<size, big_endian> orel(relbuf);
  orel.put_r_offset(r_offset);
  orel.put_r_info(elfcpp::elf_r_info<size>(0, r_type));
  orel.put_r_addend(r_addend);

  // Setup a Symbol_value for the global symbol.
  const Sized_symbol<size>* sym = static_cast<const Sized_symbol<size>*>(gsym);
  Symbol_value<size> symval;
  gold_assert(sym->has_symtab_index() && sym->symtab_index() != -1U);
  symval.set_output_symtab_index(sym->symtab_index());
  symval.set_output_value(sym->value());
  if (gsym->type() == elfcpp::STT_TLS)
    symval.set_is_tls_symbol();
  else if (gsym->type() == elfcpp::STT_GNU_IFUNC)
    symval.set_is_ifunc_symbol();

  Relocate relocate;
  relocate.relocate(relinfo, target, NULL, -1U, rel, r_type, sym, &symval,
		    view + r_offset, address + r_offset, view_size);
}

// This class may be used as a typical class for the
// Scan_relocatable_reloc parameter to scan_relocatable_relocs.  The
// template parameter Classify_reloc must be a class type which
// provides a function get_size_for_reloc which returns the number of
// bytes to which a reloc applies.  This class is intended to capture
// the most typical target behaviour, while still permitting targets
// to define their own independent class for Scan_relocatable_reloc.

template<int sh_type, typename Classify_reloc>
class Default_scan_relocatable_relocs
{
 public:
  // Return the strategy to use for a local symbol which is not a
  // section symbol, given the relocation type.
  inline Relocatable_relocs::Reloc_strategy
  local_non_section_strategy(unsigned int r_type, Relobj*, unsigned int r_sym)
  {
    // We assume that relocation type 0 is NONE.  Targets which are
    // different must override.
    if (r_type == 0 && r_sym == 0)
      return Relocatable_relocs::RELOC_DISCARD;
    return Relocatable_relocs::RELOC_COPY;
  }

  // Return the strategy to use for a local symbol which is a section
  // symbol, given the relocation type.
  inline Relocatable_relocs::Reloc_strategy
  local_section_strategy(unsigned int r_type, Relobj* object)
  {
    if (sh_type == elfcpp::SHT_RELA)
      return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_RELA;
    else
      {
	Classify_reloc classify;
	switch (classify.get_size_for_reloc(r_type, object))
	  {
	  case 0:
	    return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_0;
	  case 1:
	    return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_1;
	  case 2:
	    return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_2;
	  case 4:
	    return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_4;
	  case 8:
	    return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_8;
	  default:
	    gold_unreachable();
	  }
      }
  }

  // Return the strategy to use for a global symbol, given the
  // relocation type, the object, and the symbol index.
  inline Relocatable_relocs::Reloc_strategy
  global_strategy(unsigned int, Relobj*, unsigned int)
  { return Relocatable_relocs::RELOC_COPY; }
};

// Scan relocs during a relocatable link.  This is a default
// definition which should work for most targets.
// Scan_relocatable_reloc must name a class type which provides three
// functions which return a Relocatable_relocs::Reloc_strategy code:
// global_strategy, local_non_section_strategy, and
// local_section_strategy.  Most targets should be able to use
// Default_scan_relocatable_relocs as this class.

template<int size, bool big_endian, int sh_type,
	 typename Scan_relocatable_reloc>
void
scan_relocatable_relocs(
    Symbol_table*,
    Layout*,
    Sized_relobj_file<size, big_endian>* object,
    unsigned int data_shndx,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    size_t local_symbol_count,
    const unsigned char* plocal_syms,
    Relocatable_relocs* rr)
{
  typedef typename Reloc_types<sh_type, size, big_endian>::Reloc Reltype;
  const int reloc_size = Reloc_types<sh_type, size, big_endian>::reloc_size;
  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;
  Scan_relocatable_reloc scan;

  for (size_t i = 0; i < reloc_count; ++i, prelocs += reloc_size)
    {
      Reltype reloc(prelocs);

      Relocatable_relocs::Reloc_strategy strategy;

      if (needs_special_offset_handling
	  && !output_section->is_input_address_mapped(object, data_shndx,
						      reloc.get_r_offset()))
	strategy = Relocatable_relocs::RELOC_DISCARD;
      else
	{
	  typename elfcpp::Elf_types<size>::Elf_WXword r_info =
	    reloc.get_r_info();
	  const unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);
	  const unsigned int r_type = elfcpp::elf_r_type<size>(r_info);

	  if (r_sym >= local_symbol_count)
	    strategy = scan.global_strategy(r_type, object, r_sym);
	  else
	    {
	      gold_assert(plocal_syms != NULL);
	      typename elfcpp::Sym<size, big_endian> lsym(plocal_syms
							  + r_sym * sym_size);
	      unsigned int shndx = lsym.get_st_shndx();
	      bool is_ordinary;
	      shndx = object->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
	      if (is_ordinary
		  && shndx != elfcpp::SHN_UNDEF
		  && !object->is_section_included(shndx))
		{
		  // RELOC is a relocation against a local symbol
		  // defined in a section we are discarding.  Discard
		  // the reloc.  FIXME: Should we issue a warning?
		  strategy = Relocatable_relocs::RELOC_DISCARD;
		}
	      else if (lsym.get_st_type() != elfcpp::STT_SECTION)
		strategy = scan.local_non_section_strategy(r_type, object,
							   r_sym);
	      else
		{
		  strategy = scan.local_section_strategy(r_type, object);
		  if (strategy != Relocatable_relocs::RELOC_DISCARD)
                    object->output_section(shndx)->set_needs_symtab_index();
		}

	      if (strategy == Relocatable_relocs::RELOC_COPY)
		object->set_must_have_output_symtab_entry(r_sym);
	    }
	}

      rr->set_next_reloc_strategy(strategy);
    }
}

// Relocate relocs.  Called for a relocatable link, and for --emit-relocs.
// This is a default definition which should work for most targets.

template<int size, bool big_endian, int sh_type>
void
relocate_relocs(
    const Relocate_info<size, big_endian>* relinfo,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    typename elfcpp::Elf_types<size>::Elf_Off offset_in_output_section,
    const Relocatable_relocs* rr,
    unsigned char* view,
    typename elfcpp::Elf_types<size>::Elf_Addr view_address,
    section_size_type view_size,
    unsigned char* reloc_view,
    section_size_type reloc_view_size)
{
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  typedef typename Reloc_types<sh_type, size, big_endian>::Reloc Reltype;
  typedef typename Reloc_types<sh_type, size, big_endian>::Reloc_write
    Reltype_write;
  const int reloc_size = Reloc_types<sh_type, size, big_endian>::reloc_size;
  const Address invalid_address = static_cast<Address>(0) - 1;

  Sized_relobj_file<size, big_endian>* const object = relinfo->object;
  const unsigned int local_count = object->local_symbol_count();

  unsigned char* pwrite = reloc_view;

  for (size_t i = 0; i < reloc_count; ++i, prelocs += reloc_size)
    {
      Relocatable_relocs::Reloc_strategy strategy = rr->strategy(i);
      if (strategy == Relocatable_relocs::RELOC_DISCARD)
	continue;

      if (strategy == Relocatable_relocs::RELOC_SPECIAL)
	{
	  // Target wants to handle this relocation.
	  Sized_target<size, big_endian>* target =
	    parameters->sized_target<size, big_endian>();
	  target->relocate_special_relocatable(relinfo, sh_type, prelocs,
					       i, output_section,
					       offset_in_output_section,
					       view, view_address,
					       view_size, pwrite);
	  pwrite += reloc_size;
	  continue;
	}
      Reltype reloc(prelocs);
      Reltype_write reloc_write(pwrite);

      typename elfcpp::Elf_types<size>::Elf_WXword r_info = reloc.get_r_info();
      const unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);
      const unsigned int r_type = elfcpp::elf_r_type<size>(r_info);

      // Get the new symbol index.

      unsigned int new_symndx;
      if (r_sym < local_count)
	{
	  switch (strategy)
	    {
	    case Relocatable_relocs::RELOC_COPY:
	      if (r_sym == 0)
		new_symndx = 0;
	      else
		{
		  new_symndx = object->symtab_index(r_sym);
		  gold_assert(new_symndx != -1U);
		}
	      break;

	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_RELA:
	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_0:
	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_1:
	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_2:
	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_4:
	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_8:
	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_4_UNALIGNED:
	      {
		// We are adjusting a section symbol.  We need to find
		// the symbol table index of the section symbol for
		// the output section corresponding to input section
		// in which this symbol is defined.
		gold_assert(r_sym < local_count);
		bool is_ordinary;
		unsigned int shndx =
		  object->local_symbol_input_shndx(r_sym, &is_ordinary);
		gold_assert(is_ordinary);
		Output_section* os = object->output_section(shndx);
		gold_assert(os != NULL);
		gold_assert(os->needs_symtab_index());
		new_symndx = os->symtab_index();
	      }
	      break;

	    default:
	      gold_unreachable();
	    }
	}
      else
	{
	  const Symbol* gsym = object->global_symbol(r_sym);
	  gold_assert(gsym != NULL);
	  if (gsym->is_forwarder())
	    gsym = relinfo->symtab->resolve_forwards(gsym);

	  gold_assert(gsym->has_symtab_index());
	  new_symndx = gsym->symtab_index();
	}

      // Get the new offset--the location in the output section where
      // this relocation should be applied.

      Address offset = reloc.get_r_offset();
      Address new_offset;
      if (offset_in_output_section != invalid_address)
	new_offset = offset + offset_in_output_section;
      else
	{
          section_offset_type sot_offset =
              convert_types<section_offset_type, Address>(offset);
	  section_offset_type new_sot_offset =
              output_section->output_offset(object, relinfo->data_shndx,
                                            sot_offset);
	  gold_assert(new_sot_offset != -1);
          new_offset = new_sot_offset;
	}

      // In an object file, r_offset is an offset within the section.
      // In an executable or dynamic object, generated by
      // --emit-relocs, r_offset is an absolute address.
      if (!parameters->options().relocatable())
	{
	  new_offset += view_address;
	  if (offset_in_output_section != invalid_address)
	    new_offset -= offset_in_output_section;
	}

      reloc_write.put_r_offset(new_offset);
      reloc_write.put_r_info(elfcpp::elf_r_info<size>(new_symndx, r_type));

      // Handle the reloc addend based on the strategy.

      if (strategy == Relocatable_relocs::RELOC_COPY)
	{
	  if (sh_type == elfcpp::SHT_RELA)
	    Reloc_types<sh_type, size, big_endian>::
	      copy_reloc_addend(&reloc_write,
				&reloc);
	}
      else
	{
	  // The relocation uses a section symbol in the input file.
	  // We are adjusting it to use a section symbol in the output
	  // file.  The input section symbol refers to some address in
	  // the input section.  We need the relocation in the output
	  // file to refer to that same address.  This adjustment to
	  // the addend is the same calculation we use for a simple
	  // absolute relocation for the input section symbol.

	  const Symbol_value<size>* psymval = object->local_symbol(r_sym);

	  unsigned char* padd = view + offset;
	  switch (strategy)
	    {
	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_RELA:
	      {
		typename elfcpp::Elf_types<size>::Elf_Swxword addend;
		addend = Reloc_types<sh_type, size, big_endian>::
			   get_reloc_addend(&reloc);
		addend = psymval->value(object, addend);
		Reloc_types<sh_type, size, big_endian>::
		  set_reloc_addend(&reloc_write, addend);
	      }
	      break;

	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_0:
	      break;

	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_1:
	      Relocate_functions<size, big_endian>::rel8(padd, object,
							 psymval);
	      break;

	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_2:
	      Relocate_functions<size, big_endian>::rel16(padd, object,
							  psymval);
	      break;

	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_4:
	      Relocate_functions<size, big_endian>::rel32(padd, object,
							  psymval);
	      break;

	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_8:
	      Relocate_functions<size, big_endian>::rel64(padd, object,
							  psymval);
	      break;

	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_4_UNALIGNED:
	      Relocate_functions<size, big_endian>::rel32_unaligned(padd,
								    object,
								    psymval);
	      break;

	    default:
	      gold_unreachable();
	    }
	}

      pwrite += reloc_size;
    }

  gold_assert(static_cast<section_size_type>(pwrite - reloc_view)
	      == reloc_view_size);
}

} // End namespace gold.

#endif // !defined(GOLD_TARGET_RELOC_H)
@


1.57
log
@	* target-reloc.h (relocate_section): If the reloc offset is out of
	range, pass VIEW as NULL to relocate.relocate.
	* arm.cc (Target_arm:Relocate::relocate): Check for a NULL view.
	* i386.cc (Target_i386::Relocate::relocate): Likewise.
	* powerpc.cc (Target_powerpc::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Relocate::relocate): Likewise.
	* tilegx.cc (Target_tilegx::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Relocate::relocate): Likewise.
@
text
@d414 7
a420 1
	gold_undefined_symbol_at_location(sym, relinfo, i, offset);
@


1.56
log
@gold/
	* target.h (Sized_target::relocate_relocs): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_relocs): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_relocs): Likewise.
	* powerpc.cc (Target_powerpc::relocate_relocs): Likewise.
	* sparc.cc (Target_sparc::relocate_relocs): Likewise.
	* target-reloc.h (relocate_relocs): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_relocs): Likewise.
	* x86_64.cc (Target_x86_64::relocate_relocs): Likewise.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
d392 8
d401 2
a402 2
			     r_type, sym, psymval, view + offset,
			     view_address + offset, view_size))
d405 1
a405 1
      if (offset < 0 || static_cast<section_size_type>(offset) >= view_size)
@


1.55
log
@	* target-reloc.h (class Default_comdat_behavior): New, package up..
	(get_comdat_behaviour): ..this.
	(relocate_section): Add Relocate_comdat_behavior template arg,
	adjust code to suit.
	* arm.cc (Target_arm::relocate_section): Adjust to suit.
	(Target_arm::scan_reloc_section): Likewise.
	* i386.cc (Target_i386::relocate_section): Likewise.
	* sparc.cc (Target_sparc::relocate_section): Likewise.
	* tilegx.cc (Target_tilegx::relocate_section): Likewise.
	* x86_64.cc (Target_x86_64::relocate_section): Likewise.
	* powerpc.cc (class Relocate_comdat_behavior): New.
	(Target_powerpc::relocate_section): Don't zap opd relocs.  Supply
	gold::relocate_section with new template arg.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d91 1
a91 1
	  // 
d315 1
a315 1
          // counterpart in the kept section.  The symbol must not 
d610 1
a610 1
    typename elfcpp::Elf_types<size>::Elf_Addr offset_in_output_section,
@


1.54
log
@	* target-reloc.h (scan_relocs): Call scan.local for relocs
	against symbols in discarded sections.  Pass is_discarded
	param.
	* arm.cc, * i386.cc, * sparc.cc, * x86_64.cc (Target_*::Scan::local):
	Add is_discarded param.
	* powerpc (Target_powerpc::Scan::local): Likewise.  Use
	is_discarded to flag opd entry as discarded.  Don't emit dyn
	relocs on such entries.
	(Target_powerpc::Scan::global): Similarly detect and handle
	such opd entries.
	(Powerpc_relobj): Replace opd_ent_shndx_ and opd_ent_off_ with
	opd_ent_.  Update all uses.
	(Powerpc_relobj::get_opd_discard, set_opd_discard): New functions.
	(Target_powerpc::relocate_section): Zero out discarded opd
	entry relocs.
@
text
@d127 6
a132 3
// Decide what the linker should do for relocations that refer to discarded
// comdat sections.  This decision is based on the name of the section being
// relocated.
d134 11
a144 10
inline Comdat_behavior
get_comdat_behavior(const char* name)
{
  if (Layout::is_debug_info_section(name))
    return CB_PRETEND;
  if (strcmp(name, ".eh_frame") == 0
      || strcmp(name, ".gcc_except_table") == 0)
    return CB_IGNORE;
  return CB_WARNING;
}
d227 5
d253 2
a254 1
	 typename Relocate>
d271 1
d362 1
a362 1
	      comdat_behavior = get_comdat_behavior(name.c_str());
@


1.53
log
@	* object.h (Sized_relobj_file::emit_relocs): Delete.
	(Sized_relobj_file::emit_relocs_reltype): Delete.
	* reloc.cc (Sized_relobj_file::do_relocate_sections): Call target
	relocate_relocs for --emit-relocs.
	(Sized_relobj_file::emit_relocs, emit_relocs_reltype): Delete.
	* output.h: Update comment.
	(Output_segment::first_section): New function.
	(Output_segment::first_section_load_address): Use first_section.
	* output.cc (Output_segment::first_section): New function extracted..
	(Output_segment::first_section_load_address): ..from here.  Delete.
	* target-reloc.h (relocate_for_relocatable): Rename to relocate_relocs.
	* target.h (Sized_target::relocate_for_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise, and
	adjust call to target.h function.
	* i386.cc (Target_i386): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	(Target_powerpc::Scan::local, global): Handle R_POWERPC_TLS.  Ensure
	first tls section has section symbol for optimised local dynamic
	output relocs.
	(Target_powerpc::Relocate::relocate): Correct local dynamic value.
	(Target_powerpc::relocate_relocs): Adjust relocs emitted for
	optimised tls code.
	* testsuite/testfile.cc (Target_test::relocate_for_relocatable):
	Rename to relocate_relocs.  Update error message.
@
text
@d84 17
a100 22
	  if (is_ordinary
	      && shndx != elfcpp::SHN_UNDEF
	      && !object->is_section_included(shndx)
              && !symtab->is_section_folded(object, shndx))
	    {
	      // RELOC is a relocation against a local symbol in a
	      // section we are discarding.  We can ignore this
	      // relocation.  It will eventually become a reloc
	      // against the value zero.
	      //
	      // FIXME: We should issue a warning if this is an
	      // allocated section; is this the best place to do it?
	      // 
	      // FIXME: The old GNU linker would in some cases look
	      // for the linkonce section which caused this section to
	      // be discarded, and, if the other section was the same
	      // size, change the reloc to refer to the other section.
	      // That seems risky and weird to me, and I don't know of
	      // any case where it is actually required.

	      continue;
	    }
d102 1
a102 1
		     output_section, reloc, r_type, lsym);
@


1.52
log
@Replace <64, false> with <size, big_endian>

2011-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gold/13505
	* target-reloc.h (apply_relocation): Replace <64, false> with
	<size, big_endian>.
@
text
@d593 2
a594 2
// Relocate relocs during a relocatable link.  This is a default
// definition which should work for most targets.
d598 1
a598 1
relocate_for_relocatable(
@


1.52.2.1
log
@gold/
	* target.h (Sized_target::relocate_for_relocatable): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_for_relocatable): Likewise.
	* powerpc.cc (Target_powerpc::relocate_for_relocatable): Likewise.
	* sparc.cc (Target_sparc::relocate_for_relocatable): Likewise.
	* target-reloc.h (relocate_for_relocatable): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_for_relocatable): Likewise.
	* x86_64.cc (Target_x86_64::relocate_for_relocatable): Likewise.
@
text
@d3 1
a3 2
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
// Free Software Foundation, Inc.
d96 1
a96 1
	      //
d308 1
a308 1
          // counterpart in the kept section.  The symbol must not
d603 1
a603 1
    typename elfcpp::Elf_types<size>::Elf_Off offset_in_output_section,
@


1.51
log
@2011-11-09  Doug Kwan  <dougkwan@@google.com>

	PR gold/13362
	* arm.cc (Arm_scan_relocatable_relocs::Default_scan_relocatable_relocs):
	Use unaligned 4-byte relocs for static 32-bit data as required by EABI.
	* reloc.h (Relocatable_relocs::Reloc_strategy): New enum
	RELOC_ADJUST_FOR_SECTION_4_UNALIGNED.
	(Relocate_functions::rel_unaligned): New.
	(Relocate_functions::rel32_unaligned): New.
	* target-reloc.h (relocate_for_relocatable): Add code to handle
	RELOC_ADJUST_FOR_SECTION_4_UNALIGNED.
	* testsuite/Makefile.am (arm_unaligned_reloc_r.stdout,
	arm_unaligned_reloc_r): New targets.
	* testsuite/Makefile.in: Regenerate.
	* arm_unaligned_reloc.sh: Check unaligned relocs in relocatable
	linking.
@
text
@d426 1
a426 1
  const int reloc_size = elfcpp::Elf_sizes<64>::rela_size;
d428 2
a429 2
  elfcpp::Rela<64, false> rel(relbuf);
  elfcpp::Rela_write<64, false> orel(relbuf);
d431 1
a431 1
  orel.put_r_info(elfcpp::elf_r_info<64>(0, r_type));
d435 2
a436 2
  const Sized_symbol<64>* sym = static_cast<const Sized_symbol<64>*>(gsym);
  Symbol_value<64> symval;
@


1.50
log
@	PR gold/12979
	* options.h (class General_options): Add -Bgroup.
	* options.cc (General_options::finalize): If -Bgroup is set,
	default to --unresolved-symbols=report-all.
	* layout.cc (Layout::finish_dynamic_section): Implement -Bgroup.
	* target-reloc.h (issue_undefined_symbol_error): Handle
	--unresolved-symbols=report-all.
@
text
@d672 1
d794 6
@


1.50.2.1
log
@Merge of
CVSROOT:	/cvs/src
Module name:	src
Changes by:	dougkwan@@sourceware.org	2011-11-10 00:41:53

Modified files:
	gold           : ChangeLog arm.cc reloc.h target-reloc.h
	gold/testsuite : Makefile.am Makefile.in arm_unaligned_reloc.sh

Log message:
	2011-11-09  Doug Kwan  <dougkwan@@google.com>

	PR gold/13362
	* arm.cc (Arm_scan_relocatable_relocs::Default_scan_relocatable_relocs):
	Use unaligned 4-byte relocs for static 32-bit data as required by EABI.
	* reloc.h (Relocatable_relocs::Reloc_strategy): New enum
	RELOC_ADJUST_FOR_SECTION_4_UNALIGNED.
	(Relocate_functions::rel_unaligned): New.
	(Relocate_functions::rel32_unaligned): New.
	* target-reloc.h (relocate_for_relocatable): Add code to handle
	RELOC_ADJUST_FOR_SECTION_4_UNALIGNED.
	* testsuite/Makefile.am (arm_unaligned_reloc_r.stdout,
	arm_unaligned_reloc_r): New targets.
	* testsuite/Makefile.in: Regenerate.
	* arm_unaligned_reloc.sh: Check unaligned relocs in relocatable
	linking.
@
text
@a671 1
	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_4_UNALIGNED:
a792 6
	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_4_UNALIGNED:
	      Relocate_functions<size, big_endian>::rel32_unaligned(padd,
								    object,
								    psymval);
	      break;

@


1.49
log
@	PR gold/12386
	* options.h (class General_options): Add --unresolved-symbols.
	* target-reloc.h (issue_undefined_symbol_error): Check
	--unresolved-symbols.  Add comments.
@
text
@d206 2
@


1.48
log
@	PR gold/11317
	* target-reloc.h (issue_undefined_symbol_error): New inline
	function, broken out of relocate_section.
	(relocate_section): Call issue_undefined_symbol_error.
	* i386.cc (Target_i386::Relocate::relocate_tls): Don't crash if
	there is no TLS segment if we are about to issue an undefined
	symbol error.
	* x86_64.cc (Target_x86_64::relocate_tls): Likewise.
@
text
@d179 40
a218 7
  return (sym != NULL
	  && (sym->is_undefined() || sym->is_placeholder())
	  && sym->binding() != elfcpp::STB_WEAK
	  && !sym->is_defined_in_discarded_section()
	  && !parameters->target().is_defined_by_abi(sym)
	  && (!parameters->options().shared()
	      || parameters->options().defs()));
@


1.47
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d172 16
d363 1
a363 7
      if (sym != NULL
	  && (sym->is_undefined() || sym->is_placeholder())
	  && sym->binding() != elfcpp::STB_WEAK
	  && !is_defined_in_discarded_section
          && !target->is_defined_by_abi(sym)
	  && (!parameters->options().shared()       // -shared
              || parameters->options().defs()))     // -z defs
@


1.46
log
@	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	global symbol map.
	(Sized_incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incr_relobj::do_add_symbols): Add symbols to global symbol map.
	(Sized_incr_relobj::do_relocate): Remap section indices in incremental
	relocations.
	(Sized_incr_dynobj::do_add_symbols): Add symbols to global symbol map.
	(Sized_incr_dynobj::do_for_all_global_symbols): Remove FIXME.
	(Sized_incr_dynobj::do_for_all_local_got_entries): Likewise.
	* incremental.h
	(Incremental_inputs_reader::global_symbol_reader_at_offset): New
	function.
	(Incremental_binary::apply_incremental_relocs): New function.
	(Incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data member.
	(Sized_incremental_binary::add_global_symbol): New function.
	(Sized_incremental_binary::global_symbol): New function.
	(Sized_incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incremental_binary::symbol_map_): New data member.
	* layout.cc (Layout_task_runner::run): Apply incremental relocations.
	* target.h (Sized_target::apply_relocation): New function.
	* target-reloc.h (apply_relocation): New function.
	* x86_64.cc (Target_x86_64::apply_relocation): New function.
@
text
@d49 1
a49 1
    Sized_relobj<size, big_endian>* object,
d216 1
a216 1
  Sized_relobj<size, big_endian>* object = relinfo->object;
d478 1
a478 1
    Sized_relobj<size, big_endian>* object,
d573 1
a573 1
  Sized_relobj<size, big_endian>* const object = relinfo->object;
@


1.45
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d365 40
@


1.44
log
@	PR 10893
	* i386.cc (class Output_data_plt_i386): Update declarations.
	Define Global_ifunc and Local_ifunc types.  Add global_ifuncs_ and
	local_ifuncs_ fields.
	(Target_i386::do_plt_section_for_global): New function.
	(Target_i386::do_plt_section_for_local): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Add symtab
	parameter; change all callers.  Initialize global_ifuncs_ and
	local_ifuncs_.  If doing a static link define __rel_iplt_start and
	__rel_iplt_end.
	(Output_data_plt_i386::add_entry): Handle IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): New function.
	(Output_data_plt_i386::do_write): Fix GOT entries for IFUNC
	symbols.
	(Target_i386::make_plt_section): New function, broken out of
	make_plt_entry.  Set sh_info field of .rel.plt to point to .plt.
	(Target_i386::make_plt_entry): Call make_plt_section.
	(Target_i386::make_local_ifunc_plt_entry): New function.
	(Target_i386::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_i386::Scan::local): Handle IFUNC symbols.  Add
	R_386_IRELATIVE to switch.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocatable_size_for_reloc): Add R_386_IRELATIVE to
	switch.
	* x86_64.cc (class Output_data_plt_x86_64): Update declarations.
	(Target_x86_64::do_plt_section_for_global): New function.
	(Target_x86_64::do_plt_section_for_local): New function.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Add symtab
	parameter; change all callers.  If doing a static link define
	__rela_iplt_start and __rela_iplt_end.
	(Output_data_plt_x86_64::add_entry): Handle IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): New function.
	(Target_x86_64::make_plt_section): Set sh_info field of .rel.plt
	to point to .plt.
	(Target_x86_64::make_local_ifunc_plt_entry): New function.
	(Target_x86_64::Scan::check_non_pic): Add R_X86_64_IRELATIVE to
	switch.
	(Target_x86_64::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_x86_64::Scan::local): Handle IFUNC symbols.  Add
	R_X86_64_IRELATIVE to switch.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocatable_size_for_reloc): Add R_X86_64_IRELATIVE to
	switch.
	* target.h (class Target): Add plt_section_for_global and
	plt_section_for_local functions.  Add do_plt_section_for_global
	and do_plt_section_for_local virtual functions.
	* symtab.h (Symbol::needs_plt_entry): Handle IFUNC symbol.  Add
	clarifying comments.
	(Symbol::use_plt_offset): Handle IFUNC symbol.
	* object.cc (Sized_relobj::Sized_relobj): Initialize
	local_plt_offsets_.
	(Sized_relobj::local_has_plt_offset): New function.
	(Sized_relobj::local_plt_offset): New function.
	(Sized_relobj::set_local_plt_offset): New function.
	(Sized_relobj::do_count): Handle IFUNC symbol.
	* object.h (class Symbol_value): Add is_ifunc_symbol_ field.  Take
	a bit away from input_shndx_ field.  Add set_is_func_symbol and
	is_ifunc_symbol functions.
	(class Sized_relobj): Update declarations.  Remove Tls_got_entry
	and Local_tls_got_offsets.  Define Local_plt_offsets.  Add
	local_plt_offsets_ field.
	(Sized_relobj::clear_local_symbols): Clear local_plt_offsets_.
	* output.h (class Output_section_data): Add non-const
	output_section function.
	(class Output_data_got): Update declarations.
	(class Output_data_got::Got_entry): Add use_plt_offset_ field.
	Add use_plt_offset parameter to global and local constructors.
	Change all callers.  Change local_sym_index_ field to 31 bits.
	Change GSYM_CODE and CONSTANT_CODE accordingly.
	* output.cc (Output_data_reloc_base::do_adjust_output_section): If
	doing a static link don't set sh_link field.
	(Output_data_got::Got_entry::write): Use PLT offset if
	appropriate.
	(Output_data_got::add_global_plt): New function.
	(Output_data_got::add_local_plt): New function.
	* target-reloc.h (relocate_section): Handle IFUNC symbol.
	* defstd.cc (in_section): Remove entries for __rel_iplt_start,
	__rel_iplt_end, __rela_iplt_start, and __rela_iplt_end.
	* configure.ac: Set IFUNC automake conditional for glibc >= 2.11.
	* testsuite/Makefile.am: Add a bunch of IFUNC tests, all within
	IFUNC conditional.
	* testsuite/ifunc-sel.h: New file.
	* testsuite/ifuncmain1.c: New file.
	* testsuite/ifuncmain1vis.c: New file.
	* testsuite/ifuncmod1.c: New file.
	* testsuite/ifuncdep2.c: New file.
	* testsuite/ifuncmain2.c: New file.
	* testsuite/ifuncmain3.c: New file.
	* testsuite/ifuncmod3.c: New file.
	* testsuite/ifuncmain4.c: New file.
	* testsuite/ifuncmain5.c: New file.
	* testsuite/ifuncmod5.c: New file.
	* testsuite/ifuncmain6pie.c: New file.
	* testsuite/ifuncmod6.c: New file.
	* testsuite/ifuncmain7.c: New file.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d39 1
a39 1
// avoidmaking a function call for each relocation, and to avoid
@


1.43
log
@	* object.cc (Sized_relobj::do_layout): Defer layout for reloc sections.
	(Sized_relobj::do_layout_deferred_sections): Do layout for deferred
	reloc sections.
	* object.h (Sized_relobj::deferred_layout_relocs_): New data member.

	PR 11683
	* symtab.h (Symbol::is_placeholder): New member function.
	* target-reloc.h (relocate_section): Check for placeholder symbols.

	* testsuite/Makefile.am (plugin_test_8): New test.
	(plugin_test_9): New test.
	* testsuite/Makefile.in: Regenerate.
@
text
@d287 4
@


1.42
log
@2010-05-26  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_scan_relocatable_relocs): New class.
	(Target_arm::relocate_special_relocatable): New method.
	(Arm_relocate_functions::arm_branch_common): Handle relocatable link.
	(Arm_relocate_functions::thumb_branch_common): Same.
	(Target_arm::scan_relocatable_relocs): Use Arm_scan_relocatable_relocs
	instead of Default_scan_relocatable_relocs.
	* target-reloc.h (relocate_for_relocatable): Let target handle
	relocation strategy Relocatable_relocs::RELOC_SPECIAL.
	* target.h (Sized_target::relocate_special_relocatable): New method.
@
text
@d344 1
a344 1
	  && sym->is_undefined()
@


1.41
log
@2010-04-18  Sriraman Tallam  <tmsriram@@google.com>

	* icf.cc (get_section_contents): Check for preemptible functions.
	Ignore addend when appropriate.
	* symtab.cc (should_add_dynsym_entry): Add new parameter.  Check for
	section folded.
	(add_from_relobj): Check for section folded.
	(set_dynsym_indexes): Fix call to should_add_dynsym_entry.
	* symtab.h (should_add_dynsym_entry): Add new parameter.
	* target-reloc.h (scan_relocs): Check for section folded.
	* x86_64.cc (Target_x86_64::Scan::possible_function_pointer_reloc):
	Check reloc types for function pointers in shared objects.
	* testsuite/Makefile.am (icf_virtual_function_folding_test): New test
	case.
	(icf_preemptible_functions_test): New test case.
	(icf_string_merge_test): New test case.
	* testsuite.Makefile.in: Regenerate.
	* testsuite/icf_safe_so_test.sh: Change to not fold foo_glob and
	bar_glob.  Refactor code.
	* testsuite/icf_preemptible_functions_test.cc: New file.
	* testsuite/icf_preemptible_functions_test.sh: New file.
	* testsuite/icf_string_merge_test.cc: New file.
	* testsuite/icf_string_merge_test.sh: New file.
	* testsuite/icf_virtual_function_folding_test.cc: New file.
	* testsuite/icf_virtual_function_folding_test.sh: New file.
@
text
@d518 1
a518 1
    section_size_type,
d540 13
@


1.40
log
@	* target-reloc.h (relocate_section): Check the symbol table index
	for -1U before setting the local symbol index.
	(scan_relocatable_relocs): If copying the relocation, record that
	the local symbol is required.
	* object.h (Symbol_value::is_output_symtab_index_set): New
	function.
	(Symbol_value::may_be_discarded_from_output_symtab): New
	function.
	(Symbol_value::has_output_symtab_entry): New function.
	(Symbol_value::needs_output_symtab_entry): Remove.
	(Symbol_value::output_symtab_index): Make sure the symbol index is
	set.
	(Symbol_value::set_output_symtab_index): Make sure the symbol
	index is not set.  Make sure the new index is valid.
	(Symbol_value::set_must_have_output_symtab_entry): New function.
	(Symbol_value::has_output_dynsym_entry): New function.
	(Symbol_value::set_output_dynsym_index): Make sure the new index
	is valid.
	(Sized_relobj::set_must_have_output_symtab_entry): New function.
	* object.cc (Sized_relobj::do_count_local_symbols): Only discard a
	local symbol if permitted.
	(Sized_relobj::do_finalize_local_symbols): Call
	is_output_symtab_index_set rather than needs_output_symtab_entry.
	(Sized_relobj::write_local_symbols): Call has_output_symtab_entry
	rather than needs_output_symtab_entry.  Call
	has_output_dynsym_entry rather than needs_output_dynsym_entry.
	* arm.cc (Arm_relobj::update_output_local_symbol_count): Call
	is_output_symtab_index_set rather than needs_output_symtab_entry.
	* testsuite/discard_locals_relocatable_test.c: New file.
	* testsuite/discard_locals_test.sh: Test -r.
	* testsuite/Makefile.am (check_DATA): Add
	discard_locals_relocatable_test1.syms,
	discard_local_relocatable_test2.syms.
	(MOSTLYCLEANFILES): Likewise.  Also add
	discard_locals_relocatable_test1.lout and
	discard_locals_relocatable_test2.out.
	(discard_locals_relocatable_test1.syms): New target.
	(discard_locals_relocatable_test.o): New target.
	(discard_locals_relocatable_test1.out): New target.
	(discard_locals_relocatable_test2.syms): New target.
	(discard_locals_relocatable_test2.out): New target.
	(various): Add missing ../ld-new dependencies.
	* testsuite/Makefile.in: Rebuild.
@
text
@d86 2
a87 1
	      && !object->is_section_included(shndx))
a105 1

@


1.39
log
@	* target-reloc.h (visibility_error): New inline function.
	(relocate_section): Call visibility_error.
	* testsuite/Makefile.am (check_DATA): Add protected_3.err.
	(MOSTLYCLEANFILES): Likewise.
	(protected_4_pic.o, protected_3.err): New targets.
	* testsuite/protected_4.cc: New file.
@
text
@d282 1
a282 1
	  if (sym->has_symtab_index())
d494 3
@


1.38
log
@	PR 11108
	* symtab.h (class Symbol): Remove fields is_target_special_ and
	has_plt_offset_.  Add field is_defined_in_discarded_section_.
	(Symbol::is_defined_in_discarded_section): New function.
	(Symbol::set_is_defined_in_discarded_section): New function.
	(Symbol::has_plt_offset): Rewrite.
	(Symbol::set_plt_offset): Verify that new offset is not -1U.
	* symtab.cc (Symbol::init_fields): Initialize plt_offset_ to -1U.
	Don't initialize is_target_special_ or has_plt_offset_.
	Initialize is_defined_in_discarded_section_.
	(Symbol_table::add_from_relobj): If appropriate, set
	is_defined_in_discarded_section.
	* resolve.cc (Symbol::override_base_with_special): Don't test
	is_target_special_.  Change has_plt_offset_ to has_plt_offset().
	* target-reloc.h (relocate_section): Do special handling for
	symbols defined in discarded sections for global symbols as well
	as local symbols.
@
text
@d147 25
d351 4
@


1.37
log
@	PR 10843
	* target-reloc.h (relocate_for_relocatable): When copying a reloc,
	if the input symbol index is 0, make the output symbol index 0.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d220 2
d235 6
a240 32
	  unsigned int shndx = psymval->input_shndx(&is_ordinary);
	  if (is_ordinary
	      && shndx != elfcpp::SHN_UNDEF
	      && !object->is_section_included(shndx) 
              && !(relinfo->symtab->is_section_folded(object, shndx)))
	    {
	      if (comdat_behavior == CB_UNDETERMINED)
	        {
	          std::string name = object->section_name(relinfo->data_shndx);
	          comdat_behavior = get_comdat_behavior(name.c_str());
	        }
	      if (comdat_behavior == CB_PRETEND)
	        {
                  bool found;
	          typename elfcpp::Elf_types<size>::Elf_Addr value =
	            object->map_to_kept_section(shndx, &found);
	          if (found)
	            symval.set_output_value(value + psymval->input_value());
                  else
                    symval.set_output_value(0);
	        }
	      else
	        {
	          if (comdat_behavior == CB_WARNING)
                    gold_warning_at_location(relinfo, i, offset,
                                             _("relocation refers to discarded "
                                               "comdat section"));
                  symval.set_output_value(0);
	        }
	      symval.set_no_output_symtab_entry();
	      psymval = &symval;
	    }
d263 40
d321 1
@


1.36
log
@	* object.h (class Relobj): Drop options parameter from
	gc_process_relocs, scan_relocs, relocate, do_gc_process_relocs,
	do_scan_relocs, do_relocate.  Change all callers.
	(class Sized_relobj): Drop options parameters from
	do_gc_process_relocs, do_scan_relocs, do_relocate,
	do_relocate_sections, relocate_sections, emit_relocs_scan,
	emit_relocs_scan_reltype.  Change all callers.
	(struct Relocate_info): Remove options field and all references to
	it.
	* reloc.h (class Read_relocs): Remove options constructor
	parameter and options_ field.  Change all callers.
	(class Gc_process_relocs, class Scan_relocs): Likewise.
	(class Relocate_task): Likewise.
	* target-reloc.h (scan_relocs): Remove options parameter.  Change
	all callers.
	(scan_relocatable_relocs): Likewise.
	* target.h (class Sized_target): Remove options parameter from
	gc_process_relocs, scan_relocs, scan_relocatable_relocs.  Change
	all callers.
	* gc.h (gc_process_relocs): Remove options parameter.  Change all
	callers.
	* arm.cc: Update functions to remove options parameters.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* testsuite/testfile.cc: Likewise.
@
text
@d506 7
a512 2
	      new_symndx = object->symtab_index(r_sym);
	      gold_assert(new_symndx != -1U);
@


1.35
log
@	* options.h (class General_options): Define
	split_stack_adjust_size parameter.
	* object.h (class Object): Add uses_split_stack_ and
	has_no_split_stack_ fields.  Add uses_split_stack and
	has_no_split_stack accessor functions.  Declare
	handle_split_stack_section.
	(class Reloc_symbol_changes): Define.
	(class Sized_relobj): Define Function_offsets.  Declare
	split_stack_adjust, split_stack_adjust_reltype, and
	find_functions.
	* object.cc (Object::handle_split_stack_section): New function.
	(Sized_relobj::do_layout): Call handle_split_stack_section.
	* dynobj.cc (Sized_dynobj::do_layout): Call
	handle_split_stack_section.
	* reloc.cc (Sized_relobj::relocate_sections): Call
	split_stack_adjust for executable sections in split_stack
	objects.  Pass reloc_map to relocate_section.
	(Sized_relobj::split_stack_adjust): New function.
	(Sized_relobj::split_stack_adjust_reltype): New function.
	(Sized_relobj::find_functions): New function.
	* target-reloc.h: Include "object.h".
	(relocate_section): Add reloc_symbol_changes parameter.  Change
	all callers.
	* target.h (class Target): Add calls_non_split method.  Declare
	do_calls_non_split virtual method.  Declare match_view and
	set_view_to_nop.
	* target.cc: Include "elfcpp.h".
	(Target::do_calls_non_split): New function.
	(Target::match_view): New function.
	(Target::set_view_to_nop): New function.
	* gold.cc (queue_middle_tasks): Give an error if mixing
	split-stack and non-split-stack objects with -r.
	* i386.cc (Target_i386::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_i386::do_calls_non_split): New function.
	* x86_64.cc (Target_x86_64::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_x86_64::do_calls_non_split): New function.
	* arm.cc (Target_arm::relocate_section): Add reloc_symbol_changes
	parameter.
	* powerpc.cc (Target_powerpc::relocate_section): Add
	reloc_symbol_changes parameter.
	* sparc.cc (Target_sparc::relocate_section): Add
	reloc_symbol_changes parameter.
	* configure.ac: Call AM_CONDITIONAL for the default target.
	* configure: Rebuild.
	* testsuite/Makefile.am (TEST_AS): New variable.
	(check_SCRIPTS): Add split_i386.sh and split_x86_64.sh.
	(check_DATA): Add split_i386 and split_x86_64 files.
	(SPLIT_DEFSYMS): Define.
	(split_i386_[1234n].o): New targets.
	(split_i386_[124]): New targets.
	(split_i386_[1234r].stdout): New targets.
	(split_x86_64_[1234n].o): New targets.
	(split_x86_64_[124]): New targets.
	(split_x86_64_[1234r].stdout): New targets.
	(MOSTLYCLEANFILES): Add new executables.
	* testsuite/split_i386.sh: New file.
	* testsuite/split_x86_64.sh: New file.
	* testsuite/split_i386_1.s: New file.
	* testsuite/split_i386_2.s: New file.
	* testsuite/split_i386_3.s: New file.
	* testsuite/split_i386_4.s: New file.
	* testsuite/split_i386_n.s: New file.
	* testsuite/split_x86_64_1.s: New file.
	* testsuite/split_x86_64_2.s: New file.
	* testsuite/split_x86_64_3.s: New file.
	* testsuite/split_x86_64_4.s: New file.
	* testsuite/split_x86_64_n.s: New file.
	* testsuite/testfile.cc (Target_test): Update relocation_section
	function.
	* testsuite/Makefile.in: Rebuild.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
a45 1
    const General_options& options,
d106 1
a106 1
	  scan.local(options, symtab, layout, target, object, data_shndx,
d116 1
a116 1
	  scan.global(options, symtab, layout, target, object, data_shndx,
a385 1
    const General_options&,
@


1.34
log
@*** empty log message ***
@
text
@d28 1
d167 6
d185 2
a186 1
    section_size_type view_size)
d221 3
a223 1
      if (r_sym < local_count)
d259 1
a259 1
                                             _("Relocation refers to discarded "
d269 11
a279 4
	  const Symbol* gsym = object->global_symbol(r_sym);
	  gold_assert(gsym != NULL);
	  if (gsym->is_forwarder())
	    gsym = relinfo->symtab->resolve_forwards(gsym);
@


1.34.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a27 1
#include "object.h"
a165 6
// RELOC_SYMBOL_CHANGES is used for -fsplit-stack support.  If it is
// not NULL, it is a vector indexed by relocation index.  If that
// entry is not NULL, it points to a global symbol which used as the
// symbol for the relocation, ignoring the symbol index in the
// relocation.

d178 1
a178 2
    section_size_type view_size,
    const Reloc_symbol_changes* reloc_symbol_changes)
d213 1
a213 3
      if (r_sym < local_count
	  && (reloc_symbol_changes == NULL
	      || (*reloc_symbol_changes)[i] == NULL))
d249 1
a249 1
                                             _("relocation refers to discarded "
d259 4
a262 11
	  const Symbol* gsym;
	  if (reloc_symbol_changes != NULL
	      && (*reloc_symbol_changes)[i] != NULL)
	    gsym = (*reloc_symbol_changes)[i];
	  else
	    {
	      gsym = object->global_symbol(r_sym);
	      gold_assert(gsym != NULL);
	      if (gsym->is_forwarder())
		gsym = relinfo->symtab->resolve_forwards(gsym);
	    }
@


1.33
log
@	PR 9918
	* target-reloc.h (relocate_section): Pass output_section to
	relocate.
	* i386.cc (Target_i386::should_apply_static_reloc): Add
	output_section parameter.  Change all callers.
	(Target_i386::Relocate::relocate): Add output_section parameter.
	* x86_64.cc (Target_x86_64::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Relocate::relocate): Likewise.
	* powerpc.cc (Target_powerpc::Relocate::relocate): Likewise.
	* testsuite/two_file_shared.sh: New script.
	* testsuite/Makefile.am (check_SCRIPTS): Add two_file_shared.sh.
	(check_DATA): Add two_file_shared.dbg.
	(two_file_shared.dbg): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d221 2
a222 1
          // counterpart in the kept section.
d227 2
a228 1
	      && !object->is_section_included(shndx))
@


1.32
log
@2009-02-06  Chris Demetriou  <cgd@@google.com>

	* gold.h (gold_undefined_symbol): Change to take only a Symbol
	pointer and to report location as the file name associated with
	the symbol.
	(gold_undefined_symbol_at_location): New function to replace the
	old gold_undefined_symbol functionality.
	* target-reloc.h (relocate_section): Update to use
	gold_undefined_symbol_at_location.
	* symtab.cc (Symbol_table::warn_about_undefined_dynobj_symbol):
	Call gold_undefined_symbol function rather than gold_error.
	* errors.h (Errors::undefined_symbol): Take location as a
	string, rather than calculating it from a relocation.
	* errors.cc (Errors::fatal): Print "fatal error:" before the
	formatted message.
	(Errors::error, Errors::error_at_location): Print "error: "
	before the formatted message.
	(Errors::undefined_symbol): Take location as a string, rather
	than calculating it from a relocation.
	(gold_undefined_symbol_at_location): New function akin to
	old gold_undefined_symbol, calculates location from relocation.
	(gold_undefined_symbol): Change to take only a Symbol pointer
	and to report location as the file name associated with the symbol.
	* testsuite/debug_msg.sh: Update for changed error messages.
	* testsuite/undef_symbol.sh: Likewise.
@
text
@d271 3
a273 2
      if (!relocate.relocate(relinfo, target, i, reloc, r_type, sym, psymval,
			     view + offset, view_address + offset, view_size))
@


1.31
log
@	* target-reloc.h (Default_scan_relocatable_relocs): Only discard
	r_type == 0 for a local symbol with r_sym == 0.
	(scan_relocatable_relocs): Pass r_sym to
	local_non_section_strategy.
	* reloc.cc (Emit_relocs_strategy::local_non_section_strategy): Add
	r_sym parameter.
@
text
@d289 1
a289 1
	gold_undefined_symbol(sym, relinfo, i, offset);
@


1.30
log
@	PR 7091
	* target-reloc.h (Default_scan_relocatable_relocs): For each
	function, map r_type == 0 to RELOC_DISCARD.
@
text
@d311 1
a311 1
  local_non_section_strategy(unsigned int r_type, Relobj*)
d315 1
a315 1
    if (r_type == 0)
a324 4
    // We assume that relocation type 0 is NONE.  Targets which are
    // different must override.
    if (r_type == 0)
      return Relocatable_relocs::RELOC_DISCARD;
d351 2
a352 8
  global_strategy(unsigned int r_type, Relobj*, unsigned int)
  {
    // We assume that relocation type 0 is NONE.  Targets which are
    // different must override.
    if (r_type == 0)
      return Relocatable_relocs::RELOC_DISCARD;
    return Relocatable_relocs::RELOC_COPY;
  }
d422 2
a423 1
		strategy = scan.local_non_section_strategy(r_type, object);
@


1.29
log
@	* mapfile.cc (Mapfile::print_input_section): Change -1U to -1ULL.
	* object.cc (Sized_relobj::do_layout): Use constant invalid_address
	instead of -1U.
	(Sized_relobj::do_finalize_local_symbols): Likewise.
	(Sized_relobj::map_to_kept_section): Likewise.
	* object.h (Sized_relobj::invalid_address): New constant.
	(Sized_relobj::do_output_section_offset): Check for invalid_address
	and return -1ULL.
	* output.cc (Output_reloc::local_section_offset): Use constant
	invalid_address instead of -1U.
	(Output_reloc::get_address): Likewise.
	(Output_section::output_address): Change -1U to -1ULL.
	* output.h (Output_reloc::invalid_address): New constant.
	* reloc.cc (Sized_relobj::write_sections): Use constant
	invalid_address instead of -1U.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (Symbol_table::sized_finalize_symbol): Handle symbol
	values for merge sections.
	* target-reloc.h (relocate_for_relocatable): Use constant
	invalid_address instead of -1U.
@
text
@d311 8
a318 2
  local_non_section_strategy(unsigned int, Relobj*)
  { return Relocatable_relocs::RELOC_COPY; }
d325 4
d355 8
a362 2
  global_strategy(unsigned int, Relobj*, unsigned int)
  { return Relocatable_relocs::RELOC_COPY; }
@


1.28
log
@	* target-reloc.h (relocate_section): Check whether a symbol is
	defined by the ABI before reporting an undefined symbol error.
	* target.h (Target::is_defined_by_abi): Make parameter const.
	(Target::do_is_defined_by_abi): Likewise.
	* i386.cc (Target_i386::do_is_defined_by_abi): Likewise.
	* powerpc.cc (Target_powerpc::do_is_defined_by_abi): Likewise.
	* sparc.cc (Target_sparc::do_is_defined_by_abi): Likewise.
	* x86_64.cc (Target_x86_64::do_is_defined_by_abi): Likewise.
	* testsuite/Makefile.am (tls_test_shared.so): Add -Wl,-z,defs.
	* testsuite/Makefile.in: Rebuild.
@
text
@d453 1
d528 1
a528 1
      if (offset_in_output_section != -1U)
d547 1
a547 1
	  if (offset_in_output_section != -1U)
@


1.27
log
@	Handle output sections with more than 0x7fffffff bytes.
	* object.h (class Relobj): Change map_to_output_ to
	output_sections_, and just keep a section pointer.  Change all
	uses.  Move comdat group support to Sized_relobj.
	(Relobj::is_section_specially_mapped): Remove.
	(Relobj::output_section): Remove poff parameter.  Change all
	callers.
	(Relobj::output_section_offset): New function.
	(Relobj::set_section_offset): Rewrite.
	(Relobj::map_to_output): Remove.
	(Relobj::output_sections): New function.
	(Relobj::do_output_section_offset): New pure virtual function.
	(Relobj::do_set_section_offset): Likewise.
	(class Sized_relobj): Add section_offsets_ field.  Add comdat
	group support from Relobj.  Update declarations.
	(Sized_relobj::get_output_section_offset): New function.
	(Sized_relobj::do_output_section_offset): New function.
	(Sized_relobj::do_set_section_offset): New function.
	* object.cc (Relobj::output_section_address): Remove.
	(Sized_relobj::Sized_relobj): Initialize new fields.
	(Sized_relobj::include_section_group): Cast find_kept_object to
	Sized_relobj.
	(Sized_relobj::include_linkonce_section): Likewise.
	(Sized_relobj::do_layout): Use separate arrays for output section
	and output offset.
	(Sized_relobj::do_count_local_symbols): Change map_to_output to
	output_sections.
	(Sized_relobj::do_finalize_local_symbols): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_local_symbols): Likewise.
	(map_to_kept_section): Compute output address directly.
	* reloc.cc (Sized_relobj::do_read_relocs): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_sections): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (sized_finalize_symbol): Use output_section_offset.
	* output.h (class Output_reloc): Update declarations.  Change
	u2_.relobj to Sized_relobj*.
	(class Output_data_reloc): Change add functions to use
	Sized_relobj*.
	* output.cc (Output_reloc::Output_reloc): Change relobj to
	Sized_relobj*.
	(Output_reloc::local_section_offset): Change return type to
	Elf_Addr.  Use get_output_section_offset.
	(Output_reloc::get_address): Likewise.
	(Output_section::is_input_address_mapped): Don't call
	is_section_specially_mapped.
	(Output_section::output_offset): Likewise.
	(Output_section::output_address): Likewise.
	(Output_section::starting_output_address): Likewise.
	* copy-relocs.cc (Copy_relocs::copy_reloc): Change object
	parameter to Sized_relobj*.
	(Copy_relocs::need_copy_reloc): Likewise.
	(Copy_relocs::save): Likewise.
	* copy-relocs.h (class Copy_relocs): Update declarations.
	(class Copy_relocs::Copy_reloc_entry): Change constructor to use
	Sized_relobj*.  Change relobj_ field to Sized_relobj*.
	* target-reloc.h (relocate_for_relocatable): Change
	offset_in_output_section type to Elf_Addr.  Change code that uses
	it as well.
	* layout.cc (Layout::layout): Always set *off.
	* mapfile.cc (Mapfile::print_input_section): Use
	output_section_offset.
	* i386.cc (Target_i386::copy_reloc): Change object parameter to
	Sized_relobj*.
	* powerpc.cc (Target_powerpc::copy_reloc): Likewise.
	* sparc.cc (Target_sparc::copy_reloc): Likewise.
	* x86_64.cc (Target_x86_64::copy_reloc): Likewise.
@
text
@d286 1
@


1.26
log
@	PR 6407
	* target-reloc.h (relocate_for_relocatable): Fix new_offset
	calculation.
@
text
@d420 1
a420 6
		    {
		      section_offset_type dummy;
		      Output_section* os = object->output_section(shndx,
								  &dummy);
		      os->set_needs_symtab_index();
		    }
d439 1
a439 1
    off_t offset_in_output_section,
d447 1
d499 1
a499 2
		section_offset_type dummy;
		Output_section* os = object->output_section(shndx, &dummy);
d524 3
a526 3
      off_t offset = reloc.get_r_offset();
      off_t new_offset;
      if (offset_in_output_section != -1)
d530 7
a536 4
	  new_offset = output_section->output_offset(object,
						     relinfo->data_shndx,
						     offset);
	  gold_assert(new_offset != -1);
d545 1
a545 1
	  if (offset_in_output_section != -1)
@


1.25
log
@	* target-reloc.h (relocate_section): Fix dead-pointer bug.
@
text
@d545 5
a549 1
	new_offset += view_address;
@


1.24
log
@	* layout.cc (Layout::include_section): Refactored check for debug
	info section.
	(Layout::add_comdat): Add new parameters.  Change type
	of signature parameter.  Add object and shndx to signatures table.
	(Layout::find_kept_object): New function.
	* layout.h: Include <cstring>.
	(Layout::is_debug_info_section): New function.
	(Layout::add_comdat): Add new parameters.
	(Layout::find_kept_object): New function.
	(Layout::Kept_section): New struct.
	(Layout::Signatures): Change type of map range.
	* object.cc (Relobj::output_section_address): New function.
	(Sized_relobj::include_section_group): Add new parameters.  Change
	calls to Layout::add_comdat.  Change to build table of kept comdat
	groups and table mapping discarded sections to kept sections.
	(Sized_relobj::include_linkonce_section): Likewise.  Add new parameter.
	(Sized_relobj::do_layout): Change calls to include_section_group and
	include_linkonce_section.
	(Sized_relobj::do_finalize_local_symbols): Do not set local symbol
	value to zero when section is discarded.
	(Sized_relobj::map_to_kept_section): New function.
	* object.h (Relobj::output_section_address): New function.
	(Relobj::Comdat_group): New type.
	(Relobj::find_comdat_group): New function.
	(Relobj::Comdat_group_table): New type.
	(Relobj::Kept_comdat_section): New type.
	(Relobj::Kept_comdat_section_table): New type.
	(Relobj::add_comdat_group): New function.
	(Relobj::set_kept_comdat_section): New function.
	(Relobj::get_kept_comdat_section): New function.
	(Relobj::comdat_groups_): New field.
	(Relobj::kept_comdat_sections_): New field.
	(Symbol_value::input_value): Update comment.
	(Sized_relobj::map_to_kept_section) New function.
	(Sized_relobj::include_linkonce_section): Add new parameter.
	* target-reloc.h (Comdat_behavior): New type.
	(get_comdat_behavior): New function.
	(relocate_section): Add code to map a discarded section to the
	corresponding kept section when applying a relocation.
@
text
@d230 2
a231 3
	          const char* name =
	            object->section_name(relinfo->data_shndx).c_str();
	          comdat_behavior = get_comdat_behavior(name);
@


1.23
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d122 25
d187 2
d217 38
@


1.22
log
@From Craig Silverstein: implement -z defs.
@
text
@d81 4
a84 2
	  const unsigned int shndx = lsym.get_st_shndx();
	  if (shndx < elfcpp::SHN_LORESERVE
d86 1
a86 1
	      && !object->is_section_included(lsym.get_st_shndx()))
d338 4
a341 2
	      const unsigned int shndx = lsym.get_st_shndx();
	      if (shndx < elfcpp::SHN_LORESERVE
d343 1
a343 1
		  && !object->is_section_included(lsym.get_st_shndx()))
d435 4
a438 1
		unsigned int shndx = object->local_symbol_input_shndx(r_sym);
@


1.21
log
@Update copyright years.  Update language files.
@
text
@d220 2
a221 1
	  && !parameters->options().shared())
@


1.20
log
@Use absolute address for relocations when not doing a relocatable
link.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.19
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d378 1
a378 1
    typename elfcpp::Elf_types<size>::Elf_Addr,
d468 6
@


1.18
log
@Implement -q/--emit-relocs.
@
text
@d220 1
a220 1
	  && !parameters->output_is_shared())
@


1.17
log
@Initial -r support.
@
text
@d259 1
a259 1
	    return Relocatable_relocs::RELOC_COPY;
d289 1
a289 1
template<int size, bool big_endian, typename Target_type, int sh_type,
d368 1
a368 1
template<int size, bool big_endian, typename Target_type, int sh_type>
d419 1
d505 3
@


1.16
log
@Convert more instances of off_t to be 32-bit types.
@
text
@d28 1
d34 6
a39 5
// This function implements the generic part of reloc scanning.  This
// is an inline function which takes a class whose member functions
// local() and global() implement the machine specific part of scanning.
// We do it this way to avoidmaking a function call for each relocation,
// and to avoid repeating the generic code for each target.
d121 3
a123 5
// This is an inline function which take a class whose relocate()
// implements the machine specific part of relocation.  We do it this
// way to avoid making a function call for each relocation, and to
// avoid repeating the generic relocation handling code for each
// target.
d226 310
@


1.15
log
@From Cary Coutant: Improve i386 shared library TLS support.
@
text
@d151 1
a151 1
    off_t view_size)
d164 2
a165 1
      off_t offset = reloc.get_r_offset();
d209 1
a209 1
      if (offset < 0 || offset >= view_size)
@


1.14
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d103 1
a103 1
		     reloc, r_type, lsym);
d113 1
a113 1
		      reloc, r_type, gsym);
@


1.13
log
@From Cary Coutant: preliminary shared library support.
@
text
@a26 1
#include "object.h"
d51 2
d54 1
a54 2
    const unsigned char* plocal_syms,
    Symbol** global_syms)
d65 5
d107 1
a107 1
	  Symbol* gsym = global_syms[r_sym - local_count];
d130 8
a137 2
// of relocs.  VIEW is the section data, VIEW_ADDRESS is its memory
// address, and VIEW_SIZE is the size.
d147 2
d157 2
a158 4
  unsigned int local_count = relinfo->local_symbol_count;
  const typename Sized_relobj<size, big_endian>::Local_values* local_values =
    relinfo->local_values;
  const Symbol* const * global_syms = relinfo->symbols;
d166 9
d186 1
a186 1
	  psymval = &(*local_values)[r_sym];
d190 1
a190 1
	  const Symbol* gsym = global_syms[r_sym - local_count];
@


1.12
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d35 4
a38 4
// is an inline function which takes a class whose operator()
// implements the machine specific part of scanning.  We do it this
// way to avoidmaking a function call for each relocation, and to
// avoid repeating the generic code for each target.
d198 2
a199 1
	  && sym->binding() != elfcpp::STB_WEAK)
@


1.11
log
@From Andrew Chatham: exit on relocation error.
@
text
@d190 4
a193 4
	  fprintf(stderr, _("%s: %s: reloc has bad offset %zu\n"),
		  program_name, relinfo->location(i, offset).c_str(),
		  static_cast<size_t>(offset));
	  gold_exit(false);
d199 1
a199 6
	{
	  fprintf(stderr, _("%s: %s: undefined reference to '%s'\n"),
		  program_name, relinfo->location(i, offset).c_str(),
		  sym->name());
	  gold_exit(false);
	}
d202 1
a202 1
	relinfo->symtab->issue_warning(sym, relinfo->location(i, offset));
@


1.10
log
@Add licensing text to every source file.
@
text
@d203 1
a203 1
	  // gold_exit(false);
@


1.9
log
@Make relative references in linker scripts absolute and update a
comment about relocate() being called.
@
text
@d3 20
@


1.8
log
@Add support for SHF_MERGE sections.
@
text
@d94 1
a94 1
// This is an inline function which take a class whose operator()
@


1.7
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@a139 1
      typename elfcpp::Elf_types<size>::Elf_Addr value;
d141 2
d146 1
a146 1
	  value = (*local_values)[r_sym];
d156 6
a161 1
	  value = sym->value();
d164 1
a164 1
      if (!relocate.relocate(relinfo, target, i, reloc, r_type, sym, value,
@


1.6
log
@Snapshot.  Includes first cut at output relocation sections.
@
text
@d29 1
d51 1
a51 1
	  assert(plocal_syms != NULL);
d77 2
a78 2
	  scan.local(options, symtab, layout, target, object, reloc, r_type,
		     lsym);
d83 1
a83 1
	  assert(gsym != NULL);
d87 2
a88 2
	  scan.global(options, symtab, layout, target, object, reloc, r_type,
		      gsym);
d150 1
a150 1
	  assert(gsym != NULL);
@


1.5
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@d9 1
a13 20
// Pick the ELF relocation accessor class and the size based on
// SH_TYPE, which is either SHT_REL or SHT_RELA.

template<int sh_type, int size, bool big_endian>
struct Reloc_types;

template<int size, bool big_endian>
struct Reloc_types<elfcpp::SHT_REL, size, big_endian>
{
  typedef typename elfcpp::Rel<size, big_endian> Reloc;
  static const int reloc_size = elfcpp::Elf_sizes<size>::rel_size;
};

template<int size, bool big_endian>
struct Reloc_types<elfcpp::SHT_RELA, size, big_endian>
{
  typedef typename elfcpp::Rela<size, big_endian> Reloc;
  static const int reloc_size = elfcpp::Elf_sizes<size>::rela_size;
};

d124 3
a126 2
  typename elfcpp::Elf_types<size>::Elf_Addr *local_values = relinfo->values;
  Symbol** global_syms = relinfo->symbols;
d138 1
a138 1
      Sized_symbol<size>* sym;
d144 1
a144 1
	  value = local_values[r_sym];
d148 1
a148 1
	  Symbol* gsym = global_syms[r_sym - local_count];
d153 1
a153 1
	  sym = static_cast<Sized_symbol<size>*>(gsym);
@


1.4
log
@Can now do a full static link of hello, world in C or C++
@
text
@d47 1
a47 1
    Sized_object<size, big_endian>* object,
d196 3
@


1.3
log
@Framework for relocation scanning.  Implement simple static TLS
relocations.
@
text
@d39 2
a40 1
template<int size, bool big_endian, int sh_type, typename Scan>
d45 2
d74 1
d95 2
a96 1
	  scan.local(options, object, reloc, r_type, lsym);
d105 2
a106 1
	  scan.global(options, object, reloc, r_type, gsym);
d126 2
a127 1
template<int size, bool big_endian, int sh_type, typename Relocate>
d131 1
a150 7
      if (offset < 0 || offset >= view_size)
	{
	  fprintf(stderr, _("%s: %s: reloc has bad offset %zu\n"),
		  program_name, relinfo->location(i, offset).c_str(),
		  static_cast<size_t>(offset));
	  gold_exit(false);
	}
d173 1
d175 10
a184 8
	  if (sym->shnum() == elfcpp::SHN_UNDEF
	      && sym->binding() != elfcpp::STB_WEAK)
	    {
	      fprintf(stderr, _("%s: %s: undefined reference to '%s'\n"),
		      program_name, relinfo->location(i, offset).c_str(),
		      sym->name());
	      // gold_exit(false);
	    }
d187 9
a195 2
      relocate.relocate(relinfo, i, reloc, r_type, sym, value, view + offset,
			view_address + offset, view_size);
@


1.2
log
@Avoid multiple definition errors from linkonce sections.
@
text
@d7 1
d33 73
a105 1
// This function implements the generic part of relocation handling.
d113 2
a114 2
// the data.  SH_TYPE is the section type: SHT_REL or SHT_RELA.  RELOC
// implements operator() to do a relocation.
d116 3
a118 7
// OBJECT is the object for we are processing relocs.  SH_TYPE is the
// type of relocation: SHT_REL or SHT_RELA.  PRELOCS points to the
// relocation data.  RELOC_COUNT is the number of relocs.  LOCAL_COUNT
// is the number of local symbols.  LOCAL_VALUES holds the values of
// the local symbols.  GLOBAL_SYMS points to the global symbols.  VIEW
// is the section data, VIEW_ADDRESS is its memory address, and
// VIEW_SIZE is the size.
d123 1
a123 2
    const Symbol_table* symtab,
    Sized_object<size, big_endian>* object,
a125 3
    size_t local_count,
    const typename elfcpp::Elf_types<size>::Elf_Addr* local_values,
    Symbol** global_syms,
d134 4
d145 3
a147 3
	  fprintf(stderr, _("%s: %s: reloc %zu has bad offset %lu\n"),
		  program_name, object->name().c_str(), i,
		  static_cast<unsigned long>(offset));
d168 1
a168 1
	    gsym = symtab->resolve_forwards(gsym);
d177 2
a178 1
		      program_name, object->name().c_str(), sym->name());
d183 2
a184 2
      relocate(object, reloc, r_type, sym, value, view + offset,
	       view_address + offset);
@


1.1
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d97 1
@

