head	1.64;
access;
symbols
	binutils-2_24-branch:1.64.0.4
	binutils-2_24-branchpoint:1.64
	binutils-2_21_1:1.60
	binutils-2_23_2:1.64
	binutils-2_23_1:1.64
	binutils-2_23:1.64
	binutils-2_23-branch:1.64.0.2
	binutils-2_23-branchpoint:1.64
	binutils-2_22_branch:1.63.0.4
	binutils-2_22:1.63
	binutils-2_22-branch:1.63.0.2
	binutils-2_22-branchpoint:1.63
	binutils-2_21:1.60
	binutils-2_21-branch:1.60.0.2
	binutils-2_21-branchpoint:1.60
	binutils-2_20_1:1.44.2.2
	binutils-2_20:1.44.2.1
	binutils-arc-20081103-branch:1.42.0.6
	binutils-arc-20081103-branchpoint:1.42
	binutils-2_20-branch:1.44.0.2
	binutils-2_20-branchpoint:1.44
	dje-cgen-play1-branch:1.43.0.2
	dje-cgen-play1-branchpoint:1.43
	arc-20081103-branch:1.42.0.4
	arc-20081103-branchpoint:1.42
	binutils-2_19_1:1.42
	binutils-2_19:1.42
	binutils-2_19-branch:1.42.0.2
	binutils-2_19-branchpoint:1.42
	binutils_latest_snapshot:1.64
	added-to-binutils:1.36;
locks; strict;
comment	@// @;


1.64
date	2012.06.04.20.00.31;	author ccoutant;	state Exp;
branches;
next	1.63;

1.63
date	2011.07.02.05.29.59;	author ian;	state Exp;
branches;
next	1.62;

1.62
date	2011.04.12.00.44.47;	author ccoutant;	state Exp;
branches;
next	1.61;

1.61
date	2011.03.30.01.31.57;	author ccoutant;	state Exp;
branches;
next	1.60;

1.60
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2010.08.02.13.34.33;	author ian;	state Exp;
branches;
next	1.58;

1.58
date	2010.03.22.14.18.24;	author espindola;	state Exp;
branches;
next	1.57;

1.57
date	2010.03.05.21.04.58;	author ro;	state Exp;
branches;
next	1.56;

1.56
date	2010.01.12.06.41.36;	author ian;	state Exp;
branches;
next	1.55;

1.55
date	2010.01.08.23.10.58;	author ian;	state Exp;
branches;
next	1.54;

1.54
date	2010.01.08.21.24.44;	author ian;	state Exp;
branches;
next	1.53;

1.53
date	2010.01.05.21.52.51;	author ian;	state Exp;
branches;
next	1.52;

1.52
date	2009.12.30.08.29.37;	author ian;	state Exp;
branches;
next	1.51;

1.51
date	2009.12.29.00.31.48;	author ian;	state Exp;
branches;
next	1.50;

1.50
date	2009.12.14.19.53.04;	author ian;	state Exp;
branches;
next	1.49;

1.49
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2009.12.10.01.10.09;	author ian;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.16.19.11.32;	author dougkwan;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.06.22.58.27;	author ian;	state Exp;
branches;
next	1.45;

1.45
date	2009.09.30.22.21.13;	author ian;	state Exp;
branches;
next	1.44;

1.44
date	2009.08.18.23.49.29;	author dougkwan;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2009.02.13.19.04.44;	author ccoutant;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.24.21.21.38;	author ian;	state Exp;
branches;
next	1.41;

1.41
date	2008.07.24.07.26.27;	author ian;	state Exp;
branches;
next	1.40;

1.40
date	2008.07.22.22.08.43;	author ian;	state Exp;
branches;
next	1.39;

1.39
date	2008.07.18.06.58.04;	author ian;	state Exp;
branches;
next	1.38;

1.38
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.37;

1.37
date	2008.04.02.20.58.21;	author ian;	state Exp;
branches;
next	1.36;

1.36
date	2008.03.07.16.30.59;	author iant;	state Exp;
branches;
next	1.35;

1.35
date	2008.03.07.16.27.33;	author iant;	state Exp;
branches;
next	1.34;

1.34
date	2008.02.29.19.19.17;	author iant;	state Exp;
branches;
next	1.33;

1.33
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2008.02.26.22.48.08;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2008.02.13.01.20.38;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2008.01.26.01.17.45;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2008.01.24.00.15.00;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2008.01.18.23.26.48;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2008.01.15.23.41.28;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2008.01.02.23.48.49;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.12.21.23.31.19;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.19.01.18.41;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.15.01.12.55;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.14.07.34.53;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.07.00.45.05;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.23.05.05.48;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.22.23.08.22;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.14.06.49.13;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.12.06.06.34;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.09.17.46.14;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.02.20.52.18;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.26.07.01.34;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.25.17.50.26;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.21.07.20.01;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.12.00.30.59;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.11.22.57.35;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.04.20.00.53;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.06.06.28.56;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.06.00.28.03;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.06.00.02.36;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	;

1.44.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2009.11.07.02.17.46;	author ian;	state Exp;
branches;
next	;


desc
@@


1.64
log
@	* dynobj.cc (Sized_dynobj::do_get_global_symbol_counts): Call
	has_dynsym_index.
@
text
@// dynobj.cc -- dynamic object support for gold

// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <vector>
#include <cstring>

#include "elfcpp.h"
#include "parameters.h"
#include "script.h"
#include "symtab.h"
#include "dynobj.h"

namespace gold
{

// Class Dynobj.

// Sets up the default soname_ to use, in the (rare) cases we never
// see a DT_SONAME entry.

Dynobj::Dynobj(const std::string& name, Input_file* input_file, off_t offset)
  : Object(name, input_file, true, offset),
    needed_(),
    unknown_needed_(UNKNOWN_NEEDED_UNSET)
{
  // This will be overridden by a DT_SONAME entry, hopefully.  But if
  // we never see a DT_SONAME entry, our rule is to use the dynamic
  // object's filename.  The only exception is when the dynamic object
  // is part of an archive (so the filename is the archive's
  // filename).  In that case, we use just the dynobj's name-in-archive.
  if (input_file == NULL)
    this->soname_ = name;
  else
    {
      this->soname_ = input_file->found_name();
      if (this->offset() != 0)
	{
	  std::string::size_type open_paren = this->name().find('(');
	  std::string::size_type close_paren = this->name().find(')');
	  if (open_paren != std::string::npos
	      && close_paren != std::string::npos)
	    {
	      // It's an archive, and name() is of the form 'foo.a(bar.so)'.
	      open_paren += 1;
	      this->soname_ = this->name().substr(open_paren,
						  close_paren - open_paren);
	    }
	}
    }
}

// Class Sized_dynobj.

template<int size, bool big_endian>
Sized_dynobj<size, big_endian>::Sized_dynobj(
    const std::string& name,
    Input_file* input_file,
    off_t offset,
    const elfcpp::Ehdr<size, big_endian>& ehdr)
  : Dynobj(name, input_file, offset),
    elf_file_(this, ehdr),
    dynsym_shndx_(-1U),
    symbols_(NULL),
    defined_count_(0)
{
}

// Set up the object.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::setup()
{
  const unsigned int shnum = this->elf_file_.shnum();
  this->set_shnum(shnum);
}

// Find the SHT_DYNSYM section and the various version sections, and
// the dynamic section, given the section headers.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::find_dynsym_sections(
    const unsigned char* pshdrs,
    unsigned int* pversym_shndx,
    unsigned int* pverdef_shndx,
    unsigned int* pverneed_shndx,
    unsigned int* pdynamic_shndx)
{
  *pversym_shndx = -1U;
  *pverdef_shndx = -1U;
  *pverneed_shndx = -1U;
  *pdynamic_shndx = -1U;

  unsigned int symtab_shndx = 0;
  unsigned int xindex_shndx = 0;
  unsigned int xindex_link = 0;
  const unsigned int shnum = this->shnum();
  const unsigned char* p = pshdrs;
  for (unsigned int i = 0; i < shnum; ++i, p += This::shdr_size)
    {
      typename This::Shdr shdr(p);

      unsigned int* pi;
      switch (shdr.get_sh_type())
	{
	case elfcpp::SHT_DYNSYM:
	  this->dynsym_shndx_ = i;
	  if (xindex_shndx > 0 && xindex_link == i)
	    {
	      Xindex* xindex = new Xindex(this->elf_file_.large_shndx_offset());
	      xindex->read_symtab_xindex<size, big_endian>(this, xindex_shndx,
							   pshdrs);
	      this->set_xindex(xindex);
	    }
	  pi = NULL;
	  break;
	case elfcpp::SHT_SYMTAB:
	  symtab_shndx = i;
	  pi = NULL;
	  break;
	case elfcpp::SHT_GNU_versym:
	  pi = pversym_shndx;
	  break;
	case elfcpp::SHT_GNU_verdef:
	  pi = pverdef_shndx;
	  break;
	case elfcpp::SHT_GNU_verneed:
	  pi = pverneed_shndx;
	  break;
	case elfcpp::SHT_DYNAMIC:
	  pi = pdynamic_shndx;
	  break;
	case elfcpp::SHT_SYMTAB_SHNDX:
	  xindex_shndx = i;
	  xindex_link = this->adjust_shndx(shdr.get_sh_link());
	  if (xindex_link == this->dynsym_shndx_)
	    {
	      Xindex* xindex = new Xindex(this->elf_file_.large_shndx_offset());
	      xindex->read_symtab_xindex<size, big_endian>(this, xindex_shndx,
							   pshdrs);
	      this->set_xindex(xindex);
	    }
	  pi = NULL;
	  break;
	default:
	  pi = NULL;
	  break;
	}

      if (pi == NULL)
	continue;

      if (*pi != -1U)
	this->error(_("unexpected duplicate type %u section: %u, %u"),
		    shdr.get_sh_type(), *pi, i);

      *pi = i;
    }

  // If there is no dynamic symbol table, use the normal symbol table.
  // On some SVR4 systems, a shared library is stored in an archive.
  // The version stored in the archive only has a normal symbol table.
  // It has an SONAME entry which points to another copy in the file
  // system which has a dynamic symbol table as usual.  This is way of
  // addressing the issues which glibc addresses using GROUP with
  // libc_nonshared.a.
  if (this->dynsym_shndx_ == -1U && symtab_shndx != 0)
    {
      this->dynsym_shndx_ = symtab_shndx;
      if (xindex_shndx > 0 && xindex_link == symtab_shndx)
	{
	  Xindex* xindex = new Xindex(this->elf_file_.large_shndx_offset());
	  xindex->read_symtab_xindex<size, big_endian>(this, xindex_shndx,
						       pshdrs);
	  this->set_xindex(xindex);
	}
    }
}

// Read the contents of section SHNDX.  PSHDRS points to the section
// headers.  TYPE is the expected section type.  LINK is the expected
// section link.  Store the data in *VIEW and *VIEW_SIZE.  The
// section's sh_info field is stored in *VIEW_INFO.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::read_dynsym_section(
    const unsigned char* pshdrs,
    unsigned int shndx,
    elfcpp::SHT type,
    unsigned int link,
    File_view** view,
    section_size_type* view_size,
    unsigned int* view_info)
{
  if (shndx == -1U)
    {
      *view = NULL;
      *view_size = 0;
      *view_info = 0;
      return;
    }

  typename This::Shdr shdr(pshdrs + shndx * This::shdr_size);

  gold_assert(shdr.get_sh_type() == type);

  if (this->adjust_shndx(shdr.get_sh_link()) != link)
    this->error(_("unexpected link in section %u header: %u != %u"),
	        shndx, this->adjust_shndx(shdr.get_sh_link()), link);

  *view = this->get_lasting_view(shdr.get_sh_offset(), shdr.get_sh_size(),
				 true, false);
  *view_size = convert_to_section_size_type(shdr.get_sh_size());
  *view_info = shdr.get_sh_info();
}

// Read the dynamic tags.  Set the soname field if this shared object
// has a DT_SONAME tag.  Record the DT_NEEDED tags.  PSHDRS points to
// the section headers.  DYNAMIC_SHNDX is the section index of the
// SHT_DYNAMIC section.  STRTAB_SHNDX, STRTAB, and STRTAB_SIZE are the
// section index and contents of a string table which may be the one
// associated with the SHT_DYNAMIC section.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::read_dynamic(const unsigned char* pshdrs,
					     unsigned int dynamic_shndx,
					     unsigned int strtab_shndx,
					     const unsigned char* strtabu,
					     off_t strtab_size)
{
  typename This::Shdr dynamicshdr(pshdrs + dynamic_shndx * This::shdr_size);
  gold_assert(dynamicshdr.get_sh_type() == elfcpp::SHT_DYNAMIC);

  const off_t dynamic_size = dynamicshdr.get_sh_size();
  const unsigned char* pdynamic = this->get_view(dynamicshdr.get_sh_offset(),
						 dynamic_size, true, false);

  const unsigned int link = this->adjust_shndx(dynamicshdr.get_sh_link());
  if (link != strtab_shndx)
    {
      if (link >= this->shnum())
	{
	  this->error(_("DYNAMIC section %u link out of range: %u"),
		      dynamic_shndx, link);
	  return;
	}

      typename This::Shdr strtabshdr(pshdrs + link * This::shdr_size);
      if (strtabshdr.get_sh_type() != elfcpp::SHT_STRTAB)
	{
	  this->error(_("DYNAMIC section %u link %u is not a strtab"),
		      dynamic_shndx, link);
	  return;
	}

      strtab_size = strtabshdr.get_sh_size();
      strtabu = this->get_view(strtabshdr.get_sh_offset(), strtab_size, false,
			       false);
    }

  const char* const strtab = reinterpret_cast<const char*>(strtabu);

  for (const unsigned char* p = pdynamic;
       p < pdynamic + dynamic_size;
       p += This::dyn_size)
    {
      typename This::Dyn dyn(p);

      switch (dyn.get_d_tag())
	{
	case elfcpp::DT_NULL:
	  // We should always see DT_NULL at the end of the dynamic
	  // tags.
	  return;

	case elfcpp::DT_SONAME:
	  {
	    off_t val = dyn.get_d_val();
	    if (val >= strtab_size)
	      this->error(_("DT_SONAME value out of range: %lld >= %lld"),
			  static_cast<long long>(val),
			  static_cast<long long>(strtab_size));
	    else
	      this->set_soname_string(strtab + val);
	  }
	  break;

	case elfcpp::DT_NEEDED:
	  {
	    off_t val = dyn.get_d_val();
	    if (val >= strtab_size)
	      this->error(_("DT_NEEDED value out of range: %lld >= %lld"),
			  static_cast<long long>(val),
			  static_cast<long long>(strtab_size));
	    else
	      this->add_needed(strtab + val);
	  }
	  break;

	default:
	  break;
	}
    }

  this->error(_("missing DT_NULL in dynamic segment"));
}

// Read the symbols and sections from a dynamic object.  We read the
// dynamic symbols, not the normal symbols.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::do_read_symbols(Read_symbols_data* sd)
{
  this->read_section_data(&this->elf_file_, sd);

  const unsigned char* const pshdrs = sd->section_headers->data();

  unsigned int versym_shndx;
  unsigned int verdef_shndx;
  unsigned int verneed_shndx;
  unsigned int dynamic_shndx;
  this->find_dynsym_sections(pshdrs, &versym_shndx, &verdef_shndx,
			     &verneed_shndx, &dynamic_shndx);

  unsigned int strtab_shndx = -1U;

  sd->symbols = NULL;
  sd->symbols_size = 0;
  sd->external_symbols_offset = 0;
  sd->symbol_names = NULL;
  sd->symbol_names_size = 0;
  sd->versym = NULL;
  sd->versym_size = 0;
  sd->verdef = NULL;
  sd->verdef_size = 0;
  sd->verdef_info = 0;
  sd->verneed = NULL;
  sd->verneed_size = 0;
  sd->verneed_info = 0;

  if (this->dynsym_shndx_ != -1U)
    {
      // Get the dynamic symbols.
      typename This::Shdr dynsymshdr(pshdrs
				     + this->dynsym_shndx_ * This::shdr_size);

      sd->symbols = this->get_lasting_view(dynsymshdr.get_sh_offset(),
					   dynsymshdr.get_sh_size(), true,
					   false);
      sd->symbols_size =
	convert_to_section_size_type(dynsymshdr.get_sh_size());

      // Get the symbol names.
      strtab_shndx = this->adjust_shndx(dynsymshdr.get_sh_link());
      if (strtab_shndx >= this->shnum())
	{
	  this->error(_("invalid dynamic symbol table name index: %u"),
		      strtab_shndx);
	  return;
	}
      typename This::Shdr strtabshdr(pshdrs + strtab_shndx * This::shdr_size);
      if (strtabshdr.get_sh_type() != elfcpp::SHT_STRTAB)
	{
	  this->error(_("dynamic symbol table name section "
			"has wrong type: %u"),
		      static_cast<unsigned int>(strtabshdr.get_sh_type()));
	  return;
	}

      sd->symbol_names = this->get_lasting_view(strtabshdr.get_sh_offset(),
						strtabshdr.get_sh_size(),
						false, false);
      sd->symbol_names_size =
	convert_to_section_size_type(strtabshdr.get_sh_size());

      // Get the version information.

      unsigned int dummy;
      this->read_dynsym_section(pshdrs, versym_shndx, elfcpp::SHT_GNU_versym,
				this->dynsym_shndx_,
				&sd->versym, &sd->versym_size, &dummy);

      // We require that the version definition and need section link
      // to the same string table as the dynamic symbol table.  This
      // is not a technical requirement, but it always happens in
      // practice.  We could change this if necessary.

      this->read_dynsym_section(pshdrs, verdef_shndx, elfcpp::SHT_GNU_verdef,
				strtab_shndx, &sd->verdef, &sd->verdef_size,
				&sd->verdef_info);

      this->read_dynsym_section(pshdrs, verneed_shndx, elfcpp::SHT_GNU_verneed,
				strtab_shndx, &sd->verneed, &sd->verneed_size,
				&sd->verneed_info);
    }

  // Read the SHT_DYNAMIC section to find whether this shared object
  // has a DT_SONAME tag and to record any DT_NEEDED tags.  This
  // doesn't really have anything to do with reading the symbols, but
  // this is a convenient place to do it.
  if (dynamic_shndx != -1U)
    this->read_dynamic(pshdrs, dynamic_shndx, strtab_shndx,
		       (sd->symbol_names == NULL
			? NULL
			: sd->symbol_names->data()),
		       sd->symbol_names_size);
}

// Return the Xindex structure to use for object with lots of
// sections.

template<int size, bool big_endian>
Xindex*
Sized_dynobj<size, big_endian>::do_initialize_xindex()
{
  gold_assert(this->dynsym_shndx_ != -1U);
  Xindex* xindex = new Xindex(this->elf_file_.large_shndx_offset());
  xindex->initialize_symtab_xindex<size, big_endian>(this, this->dynsym_shndx_);
  return xindex;
}

// Lay out the input sections for a dynamic object.  We don't want to
// include sections from a dynamic object, so all that we actually do
// here is check for .gnu.warning and .note.GNU-split-stack sections.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::do_layout(Symbol_table* symtab,
					  Layout*,
					  Read_symbols_data* sd)
{
  const unsigned int shnum = this->shnum();
  if (shnum == 0)
    return;

  // Get the section headers.
  const unsigned char* pshdrs = sd->section_headers->data();

  // Get the section names.
  const unsigned char* pnamesu = sd->section_names->data();
  const char* pnames = reinterpret_cast<const char*>(pnamesu);

  // Skip the first, dummy, section.
  pshdrs += This::shdr_size;
  for (unsigned int i = 1; i < shnum; ++i, pshdrs += This::shdr_size)
    {
      typename This::Shdr shdr(pshdrs);

      if (shdr.get_sh_name() >= sd->section_names_size)
	{
	  this->error(_("bad section name offset for section %u: %lu"),
		      i, static_cast<unsigned long>(shdr.get_sh_name()));
	  return;
	}

      const char* name = pnames + shdr.get_sh_name();

      this->handle_gnu_warning_section(name, i, symtab);
      this->handle_split_stack_section(name);
    }

  delete sd->section_headers;
  sd->section_headers = NULL;
  delete sd->section_names;
  sd->section_names = NULL;
}

// Add an entry to the vector mapping version numbers to version
// strings.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::set_version_map(
    Version_map* version_map,
    unsigned int ndx,
    const char* name) const
{
  if (ndx >= version_map->size())
    version_map->resize(ndx + 1);
  if ((*version_map)[ndx] != NULL)
    this->error(_("duplicate definition for version %u"), ndx);
  (*version_map)[ndx] = name;
}

// Add mappings for the version definitions to VERSION_MAP.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::make_verdef_map(
    Read_symbols_data* sd,
    Version_map* version_map) const
{
  if (sd->verdef == NULL)
    return;

  const char* names = reinterpret_cast<const char*>(sd->symbol_names->data());
  section_size_type names_size = sd->symbol_names_size;

  const unsigned char* pverdef = sd->verdef->data();
  section_size_type verdef_size = sd->verdef_size;
  const unsigned int count = sd->verdef_info;

  const unsigned char* p = pverdef;
  for (unsigned int i = 0; i < count; ++i)
    {
      elfcpp::Verdef<size, big_endian> verdef(p);

      if (verdef.get_vd_version() != elfcpp::VER_DEF_CURRENT)
	{
	  this->error(_("unexpected verdef version %u"),
		      verdef.get_vd_version());
	  return;
	}

      const section_size_type vd_ndx = verdef.get_vd_ndx();

      // The GNU linker clears the VERSYM_HIDDEN bit.  I'm not
      // sure why.

      // The first Verdaux holds the name of this version.  Subsequent
      // ones are versions that this one depends upon, which we don't
      // care about here.
      const section_size_type vd_cnt = verdef.get_vd_cnt();
      if (vd_cnt < 1)
	{
	  this->error(_("verdef vd_cnt field too small: %u"),
                      static_cast<unsigned int>(vd_cnt));
	  return;
	}

      const section_size_type vd_aux = verdef.get_vd_aux();
      if ((p - pverdef) + vd_aux >= verdef_size)
	{
	  this->error(_("verdef vd_aux field out of range: %u"),
                      static_cast<unsigned int>(vd_aux));
	  return;
	}

      const unsigned char* pvda = p + vd_aux;
      elfcpp::Verdaux<size, big_endian> verdaux(pvda);

      const section_size_type vda_name = verdaux.get_vda_name();
      if (vda_name >= names_size)
	{
	  this->error(_("verdaux vda_name field out of range: %u"),
                      static_cast<unsigned int>(vda_name));
	  return;
	}

      this->set_version_map(version_map, vd_ndx, names + vda_name);

      const section_size_type vd_next = verdef.get_vd_next();
      if ((p - pverdef) + vd_next >= verdef_size)
	{
	  this->error(_("verdef vd_next field out of range: %u"),
                      static_cast<unsigned int>(vd_next));
	  return;
	}

      p += vd_next;
    }
}

// Add mappings for the required versions to VERSION_MAP.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::make_verneed_map(
    Read_symbols_data* sd,
    Version_map* version_map) const
{
  if (sd->verneed == NULL)
    return;

  const char* names = reinterpret_cast<const char*>(sd->symbol_names->data());
  section_size_type names_size = sd->symbol_names_size;

  const unsigned char* pverneed = sd->verneed->data();
  const section_size_type verneed_size = sd->verneed_size;
  const unsigned int count = sd->verneed_info;

  const unsigned char* p = pverneed;
  for (unsigned int i = 0; i < count; ++i)
    {
      elfcpp::Verneed<size, big_endian> verneed(p);

      if (verneed.get_vn_version() != elfcpp::VER_NEED_CURRENT)
	{
	  this->error(_("unexpected verneed version %u"),
		      verneed.get_vn_version());
	  return;
	}

      const section_size_type vn_aux = verneed.get_vn_aux();

      if ((p - pverneed) + vn_aux >= verneed_size)
	{
	  this->error(_("verneed vn_aux field out of range: %u"),
                      static_cast<unsigned int>(vn_aux));
	  return;
	}

      const unsigned int vn_cnt = verneed.get_vn_cnt();
      const unsigned char* pvna = p + vn_aux;
      for (unsigned int j = 0; j < vn_cnt; ++j)
	{
	  elfcpp::Vernaux<size, big_endian> vernaux(pvna);

	  const unsigned int vna_name = vernaux.get_vna_name();
	  if (vna_name >= names_size)
	    {
	      this->error(_("vernaux vna_name field out of range: %u"),
			  static_cast<unsigned int>(vna_name));
	      return;
	    }

	  this->set_version_map(version_map, vernaux.get_vna_other(),
				names + vna_name);

	  const section_size_type vna_next = vernaux.get_vna_next();
	  if ((pvna - pverneed) + vna_next >= verneed_size)
	    {
	      this->error(_("verneed vna_next field out of range: %u"),
			  static_cast<unsigned int>(vna_next));
	      return;
	    }

	  pvna += vna_next;
	}

      const section_size_type vn_next = verneed.get_vn_next();
      if ((p - pverneed) + vn_next >= verneed_size)
	{
	  this->error(_("verneed vn_next field out of range: %u"),
                      static_cast<unsigned int>(vn_next));
	  return;
	}

      p += vn_next;
    }
}

// Create a vector mapping version numbers to version strings.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::make_version_map(
    Read_symbols_data* sd,
    Version_map* version_map) const
{
  if (sd->verdef == NULL && sd->verneed == NULL)
    return;

  // A guess at the maximum version number we will see.  If this is
  // wrong we will be less efficient but still correct.
  version_map->reserve(sd->verdef_info + sd->verneed_info * 10);

  this->make_verdef_map(sd, version_map);
  this->make_verneed_map(sd, version_map);
}

// Add the dynamic symbols to the symbol table.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::do_add_symbols(Symbol_table* symtab,
					       Read_symbols_data* sd,
					       Layout*)
{
  if (sd->symbols == NULL)
    {
      gold_assert(sd->symbol_names == NULL);
      gold_assert(sd->versym == NULL && sd->verdef == NULL
		  && sd->verneed == NULL);
      return;
    }

  const int sym_size = This::sym_size;
  const size_t symcount = sd->symbols_size / sym_size;
  gold_assert(sd->external_symbols_offset == 0);
  if (symcount * sym_size != sd->symbols_size)
    {
      this->error(_("size of dynamic symbols is not multiple of symbol size"));
      return;
    }

  Version_map version_map;
  this->make_version_map(sd, &version_map);

  // If printing symbol counts or a cross reference table or
  // preparing for an incremental link, we want to track symbols.
  if (parameters->options().user_set_print_symbol_counts()
      || parameters->options().cref()
      || parameters->incremental())
    {
      this->symbols_ = new Symbols();
      this->symbols_->resize(symcount);
    }

  const char* sym_names =
    reinterpret_cast<const char*>(sd->symbol_names->data());
  symtab->add_from_dynobj(this, sd->symbols->data(), symcount,
			  sym_names, sd->symbol_names_size,
			  (sd->versym == NULL
			   ? NULL
			   : sd->versym->data()),
			  sd->versym_size,
			  &version_map,
			  this->symbols_,
			  &this->defined_count_);

  delete sd->symbols;
  sd->symbols = NULL;
  delete sd->symbol_names;
  sd->symbol_names = NULL;
  if (sd->versym != NULL)
    {
      delete sd->versym;
      sd->versym = NULL;
    }
  if (sd->verdef != NULL)
    {
      delete sd->verdef;
      sd->verdef = NULL;
    }
  if (sd->verneed != NULL)
    {
      delete sd->verneed;
      sd->verneed = NULL;
    }

  // This is normally the last time we will read any data from this
  // file.
  this->clear_view_cache_marks();
}

template<int size, bool big_endian>
Archive::Should_include
Sized_dynobj<size, big_endian>::do_should_include_member(Symbol_table*,
							 Layout*,
							 Read_symbols_data*,
							 std::string*)
{
  return Archive::SHOULD_INCLUDE_YES;
}

// Iterate over global symbols, calling a visitor class V for each.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::do_for_all_global_symbols(
    Read_symbols_data* sd,
    Library_base::Symbol_visitor_base* v)
{
  const char* sym_names =
      reinterpret_cast<const char*>(sd->symbol_names->data());
  const unsigned char* syms =
      sd->symbols->data() + sd->external_symbols_offset;
  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;
  size_t symcount = ((sd->symbols_size - sd->external_symbols_offset)
                     / sym_size);
  const unsigned char* p = syms;

  for (size_t i = 0; i < symcount; ++i, p += sym_size)
    {
      elfcpp::Sym<size, big_endian> sym(p);
      if (sym.get_st_shndx() != elfcpp::SHN_UNDEF
	  && sym.get_st_bind() != elfcpp::STB_LOCAL)
	v->visit(sym_names + sym.get_st_name());
    }
}

// Iterate over local symbols, calling a visitor class V for each GOT offset
// associated with a local symbol.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::do_for_all_local_got_entries(
    Got_offset_list::Visitor*) const
{
}

// Get symbol counts.

template<int size, bool big_endian>
void
Sized_dynobj<size, big_endian>::do_get_global_symbol_counts(
    const Symbol_table*,
    size_t* defined,
    size_t* used) const
{
  *defined = this->defined_count_;
  size_t count = 0;
  for (typename Symbols::const_iterator p = this->symbols_->begin();
       p != this->symbols_->end();
       ++p)
    if (*p != NULL
	&& (*p)->source() == Symbol::FROM_OBJECT
	&& (*p)->object() == this
	&& (*p)->is_defined()
	&& (*p)->has_dynsym_index())
      ++count;
  *used = count;
}

// Given a vector of hash codes, compute the number of hash buckets to
// use.

unsigned int
Dynobj::compute_bucket_count(const std::vector<uint32_t>& hashcodes,
			     bool for_gnu_hash_table)
{
  // FIXME: Implement optional hash table optimization.

  // Array used to determine the number of hash table buckets to use
  // based on the number of symbols there are.  If there are fewer
  // than 3 symbols we use 1 bucket, fewer than 17 symbols we use 3
  // buckets, fewer than 37 we use 17 buckets, and so forth.  We never
  // use more than 262147 buckets.  This is straight from the old GNU
  // linker.
  static const unsigned int buckets[] =
  {
    1, 3, 17, 37, 67, 97, 131, 197, 263, 521, 1031, 2053, 4099, 8209,
    16411, 32771, 65537, 131101, 262147
  };
  const int buckets_count = sizeof buckets / sizeof buckets[0];

  unsigned int symcount = hashcodes.size();
  unsigned int ret = 1;
  const double full_fraction
    = 1.0 - parameters->options().hash_bucket_empty_fraction();
  for (int i = 0; i < buckets_count; ++i)
    {
      if (symcount < buckets[i] * full_fraction)
	break;
      ret = buckets[i];
    }

  if (for_gnu_hash_table && ret < 2)
    ret = 2;

  return ret;
}

// The standard ELF hash function.  This hash function must not
// change, as the dynamic linker uses it also.

uint32_t
Dynobj::elf_hash(const char* name)
{
  const unsigned char* nameu = reinterpret_cast<const unsigned char*>(name);
  uint32_t h = 0;
  unsigned char c;
  while ((c = *nameu++) != '\0')
    {
      h = (h << 4) + c;
      uint32_t g = h & 0xf0000000;
      if (g != 0)
	{
	  h ^= g >> 24;
	  // The ELF ABI says h &= ~g, but using xor is equivalent in
	  // this case (since g was set from h) and may save one
	  // instruction.
	  h ^= g;
	}
    }
  return h;
}

// Create a standard ELF hash table, setting *PPHASH and *PHASHLEN.
// DYNSYMS is a vector with all the global dynamic symbols.
// LOCAL_DYNSYM_COUNT is the number of local symbols in the dynamic
// symbol table.

void
Dynobj::create_elf_hash_table(const std::vector<Symbol*>& dynsyms,
			      unsigned int local_dynsym_count,
			      unsigned char** pphash,
			      unsigned int* phashlen)
{
  unsigned int dynsym_count = dynsyms.size();

  // Get the hash values for all the symbols.
  std::vector<uint32_t> dynsym_hashvals(dynsym_count);
  for (unsigned int i = 0; i < dynsym_count; ++i)
    dynsym_hashvals[i] = Dynobj::elf_hash(dynsyms[i]->name());

  const unsigned int bucketcount =
    Dynobj::compute_bucket_count(dynsym_hashvals, false);

  std::vector<uint32_t> bucket(bucketcount);
  std::vector<uint32_t> chain(local_dynsym_count + dynsym_count);

  for (unsigned int i = 0; i < dynsym_count; ++i)
    {
      unsigned int dynsym_index = dynsyms[i]->dynsym_index();
      unsigned int bucketpos = dynsym_hashvals[i] % bucketcount;
      chain[dynsym_index] = bucket[bucketpos];
      bucket[bucketpos] = dynsym_index;
    }

  unsigned int hashlen = ((2
			   + bucketcount
			   + local_dynsym_count
			   + dynsym_count)
			  * 4);
  unsigned char* phash = new unsigned char[hashlen];

  if (parameters->target().is_big_endian())
    {
#if defined(HAVE_TARGET_32_BIG) || defined(HAVE_TARGET_64_BIG)
      Dynobj::sized_create_elf_hash_table<true>(bucket, chain, phash,
						hashlen);
#else
      gold_unreachable();
#endif
    }
  else
    {
#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_64_LITTLE)
      Dynobj::sized_create_elf_hash_table<false>(bucket, chain, phash,
						 hashlen);
#else
      gold_unreachable();
#endif
    }

  *pphash = phash;
  *phashlen = hashlen;
}

// Fill in an ELF hash table.

template<bool big_endian>
void
Dynobj::sized_create_elf_hash_table(const std::vector<uint32_t>& bucket,
				    const std::vector<uint32_t>& chain,
				    unsigned char* phash,
				    unsigned int hashlen)
{
  unsigned char* p = phash;

  const unsigned int bucketcount = bucket.size();
  const unsigned int chaincount = chain.size();

  elfcpp::Swap<32, big_endian>::writeval(p, bucketcount);
  p += 4;
  elfcpp::Swap<32, big_endian>::writeval(p, chaincount);
  p += 4;

  for (unsigned int i = 0; i < bucketcount; ++i)
    {
      elfcpp::Swap<32, big_endian>::writeval(p, bucket[i]);
      p += 4;
    }

  for (unsigned int i = 0; i < chaincount; ++i)
    {
      elfcpp::Swap<32, big_endian>::writeval(p, chain[i]);
      p += 4;
    }

  gold_assert(static_cast<unsigned int>(p - phash) == hashlen);
}

// The hash function used for the GNU hash table.  This hash function
// must not change, as the dynamic linker uses it also.

uint32_t
Dynobj::gnu_hash(const char* name)
{
  const unsigned char* nameu = reinterpret_cast<const unsigned char*>(name);
  uint32_t h = 5381;
  unsigned char c;
  while ((c = *nameu++) != '\0')
    h = (h << 5) + h + c;
  return h;
}

// Create a GNU hash table, setting *PPHASH and *PHASHLEN.  GNU hash
// tables are an extension to ELF which are recognized by the GNU
// dynamic linker.  They are referenced using dynamic tag DT_GNU_HASH.
// TARGET is the target.  DYNSYMS is a vector with all the global
// symbols which will be going into the dynamic symbol table.
// LOCAL_DYNSYM_COUNT is the number of local symbols in the dynamic
// symbol table.

void
Dynobj::create_gnu_hash_table(const std::vector<Symbol*>& dynsyms,
			      unsigned int local_dynsym_count,
			      unsigned char** pphash,
			      unsigned int* phashlen)
{
  const unsigned int count = dynsyms.size();

  // Sort the dynamic symbols into two vectors.  Symbols which we do
  // not want to put into the hash table we store into
  // UNHASHED_DYNSYMS.  Symbols which we do want to store we put into
  // HASHED_DYNSYMS.  DYNSYM_HASHVALS is parallel to HASHED_DYNSYMS,
  // and records the hash codes.

  std::vector<Symbol*> unhashed_dynsyms;
  unhashed_dynsyms.reserve(count);

  std::vector<Symbol*> hashed_dynsyms;
  hashed_dynsyms.reserve(count);

  std::vector<uint32_t> dynsym_hashvals;
  dynsym_hashvals.reserve(count);
  
  for (unsigned int i = 0; i < count; ++i)
    {
      Symbol* sym = dynsyms[i];

      if (!sym->needs_dynsym_value()
	  && (sym->is_undefined()
	      || sym->is_from_dynobj()
	      || sym->is_forced_local()))
	unhashed_dynsyms.push_back(sym);
      else
	{
	  hashed_dynsyms.push_back(sym);
	  dynsym_hashvals.push_back(Dynobj::gnu_hash(sym->name()));
	}
    }

  // Put the unhashed symbols at the start of the global portion of
  // the dynamic symbol table.
  const unsigned int unhashed_count = unhashed_dynsyms.size();
  unsigned int unhashed_dynsym_index = local_dynsym_count;
  for (unsigned int i = 0; i < unhashed_count; ++i)
    {
      unhashed_dynsyms[i]->set_dynsym_index(unhashed_dynsym_index);
      ++unhashed_dynsym_index;
    }

  // For the actual data generation we call out to a templatized
  // function.
  int size = parameters->target().get_size();
  bool big_endian = parameters->target().is_big_endian();
  if (size == 32)
    {
      if (big_endian)
	{
#ifdef HAVE_TARGET_32_BIG
	  Dynobj::sized_create_gnu_hash_table<32, true>(hashed_dynsyms,
							dynsym_hashvals,
							unhashed_dynsym_index,
							pphash,
							phashlen);
#else
	  gold_unreachable();
#endif
	}
      else
	{
#ifdef HAVE_TARGET_32_LITTLE
	  Dynobj::sized_create_gnu_hash_table<32, false>(hashed_dynsyms,
							 dynsym_hashvals,
							 unhashed_dynsym_index,
							 pphash,
							 phashlen);
#else
	  gold_unreachable();
#endif
	}
    }
  else if (size == 64)
    {
      if (big_endian)
	{
#ifdef HAVE_TARGET_64_BIG
	  Dynobj::sized_create_gnu_hash_table<64, true>(hashed_dynsyms,
							dynsym_hashvals,
							unhashed_dynsym_index,
							pphash,
							phashlen);
#else
	  gold_unreachable();
#endif
	}
      else
	{
#ifdef HAVE_TARGET_64_LITTLE
	  Dynobj::sized_create_gnu_hash_table<64, false>(hashed_dynsyms,
							 dynsym_hashvals,
							 unhashed_dynsym_index,
							 pphash,
							 phashlen);
#else
	  gold_unreachable();
#endif
	}
    }
  else
    gold_unreachable();
}

// Create the actual data for a GNU hash table.  This is just a copy
// of the code from the old GNU linker.

template<int size, bool big_endian>
void
Dynobj::sized_create_gnu_hash_table(
    const std::vector<Symbol*>& hashed_dynsyms,
    const std::vector<uint32_t>& dynsym_hashvals,
    unsigned int unhashed_dynsym_count,
    unsigned char** pphash,
    unsigned int* phashlen)
{
  if (hashed_dynsyms.empty())
    {
      // Special case for the empty hash table.
      unsigned int hashlen = 5 * 4 + size / 8;
      unsigned char* phash = new unsigned char[hashlen];
      // One empty bucket.
      elfcpp::Swap<32, big_endian>::writeval(phash, 1);
      // Symbol index above unhashed symbols.
      elfcpp::Swap<32, big_endian>::writeval(phash + 4, unhashed_dynsym_count);
      // One word for bitmask.
      elfcpp::Swap<32, big_endian>::writeval(phash + 8, 1);
      // Only bloom filter.
      elfcpp::Swap<32, big_endian>::writeval(phash + 12, 0);
      // No valid hashes.
      elfcpp::Swap<size, big_endian>::writeval(phash + 16, 0);
      // No hashes in only bucket.
      elfcpp::Swap<32, big_endian>::writeval(phash + 16 + size / 8, 0);

      *phashlen = hashlen;
      *pphash = phash;

      return;
    }

  const unsigned int bucketcount =
    Dynobj::compute_bucket_count(dynsym_hashvals, true);

  const unsigned int nsyms = hashed_dynsyms.size();

  uint32_t maskbitslog2 = 1;
  uint32_t x = nsyms >> 1;
  while (x != 0)
    {
      ++maskbitslog2;
      x >>= 1;
    }
  if (maskbitslog2 < 3)
    maskbitslog2 = 5;
  else if (((1U << (maskbitslog2 - 2)) & nsyms) != 0)
    maskbitslog2 += 3;
  else
    maskbitslog2 += 2;

  uint32_t shift1;
  if (size == 32)
    shift1 = 5;
  else
    {
      if (maskbitslog2 == 5)
	maskbitslog2 = 6;
      shift1 = 6;
    }
  uint32_t mask = (1U << shift1) - 1U;
  uint32_t shift2 = maskbitslog2;
  uint32_t maskbits = 1U << maskbitslog2;
  uint32_t maskwords = 1U << (maskbitslog2 - shift1);

  typedef typename elfcpp::Elf_types<size>::Elf_WXword Word;
  std::vector<Word> bitmask(maskwords);
  std::vector<uint32_t> counts(bucketcount);
  std::vector<uint32_t> indx(bucketcount);
  uint32_t symindx = unhashed_dynsym_count;

  // Count the number of times each hash bucket is used.
  for (unsigned int i = 0; i < nsyms; ++i)
    ++counts[dynsym_hashvals[i] % bucketcount];

  unsigned int cnt = symindx;
  for (unsigned int i = 0; i < bucketcount; ++i)
    {
      indx[i] = cnt;
      cnt += counts[i];
    }

  unsigned int hashlen = (4 + bucketcount + nsyms) * 4;
  hashlen += maskbits / 8;
  unsigned char* phash = new unsigned char[hashlen];

  elfcpp::Swap<32, big_endian>::writeval(phash, bucketcount);
  elfcpp::Swap<32, big_endian>::writeval(phash + 4, symindx);
  elfcpp::Swap<32, big_endian>::writeval(phash + 8, maskwords);
  elfcpp::Swap<32, big_endian>::writeval(phash + 12, shift2);

  unsigned char* p = phash + 16 + maskbits / 8;
  for (unsigned int i = 0; i < bucketcount; ++i)
    {
      if (counts[i] == 0)
	elfcpp::Swap<32, big_endian>::writeval(p, 0);
      else
	elfcpp::Swap<32, big_endian>::writeval(p, indx[i]);
      p += 4;
    }

  for (unsigned int i = 0; i < nsyms; ++i)
    {
      Symbol* sym = hashed_dynsyms[i];
      uint32_t hashval = dynsym_hashvals[i];

      unsigned int bucket = hashval % bucketcount;
      unsigned int val = ((hashval >> shift1)
			  & ((maskbits >> shift1) - 1));
      bitmask[val] |= (static_cast<Word>(1U)) << (hashval & mask);
      bitmask[val] |= (static_cast<Word>(1U)) << ((hashval >> shift2) & mask);
      val = hashval & ~ 1U;
      if (counts[bucket] == 1)
	{
	  // Last element terminates the chain.
	  val |= 1;
	}
      elfcpp::Swap<32, big_endian>::writeval(p + (indx[bucket] - symindx) * 4,
					     val);
      --counts[bucket];

      sym->set_dynsym_index(indx[bucket]);
      ++indx[bucket];
    }

  p = phash + 16;
  for (unsigned int i = 0; i < maskwords; ++i)
    {
      elfcpp::Swap<size, big_endian>::writeval(p, bitmask[i]);
      p += size / 8;
    }

  *phashlen = hashlen;
  *pphash = phash;
}

// Verdef methods.

// Write this definition to a buffer for the output section.

template<int size, bool big_endian>
unsigned char*
Verdef::write(const Stringpool* dynpool, bool is_last, unsigned char* pb) const
{
  const int verdef_size = elfcpp::Elf_sizes<size>::verdef_size;
  const int verdaux_size = elfcpp::Elf_sizes<size>::verdaux_size;

  elfcpp::Verdef_write<size, big_endian> vd(pb);
  vd.set_vd_version(elfcpp::VER_DEF_CURRENT);
  vd.set_vd_flags((this->is_base_ ? elfcpp::VER_FLG_BASE : 0)
		  | (this->is_weak_ ? elfcpp::VER_FLG_WEAK : 0)
		  | (this->is_info_ ? elfcpp::VER_FLG_INFO : 0));
  vd.set_vd_ndx(this->index());
  vd.set_vd_cnt(1 + this->deps_.size());
  vd.set_vd_hash(Dynobj::elf_hash(this->name()));
  vd.set_vd_aux(verdef_size);
  vd.set_vd_next(is_last
		 ? 0
		 : verdef_size + (1 + this->deps_.size()) * verdaux_size);
  pb += verdef_size;

  elfcpp::Verdaux_write<size, big_endian> vda(pb);
  vda.set_vda_name(dynpool->get_offset(this->name()));
  vda.set_vda_next(this->deps_.empty() ? 0 : verdaux_size);
  pb += verdaux_size;

  Deps::const_iterator p;
  unsigned int i;
  for (p = this->deps_.begin(), i = 0;
       p != this->deps_.end();
       ++p, ++i)
    {
      elfcpp::Verdaux_write<size, big_endian> vda(pb);
      vda.set_vda_name(dynpool->get_offset(*p));
      vda.set_vda_next(i + 1 >= this->deps_.size() ? 0 : verdaux_size);
      pb += verdaux_size;
    }

  return pb;
}

// Verneed methods.

Verneed::~Verneed()
{
  for (Need_versions::iterator p = this->need_versions_.begin();
       p != this->need_versions_.end();
       ++p)
    delete *p;
}

// Add a new version to this file reference.

Verneed_version*
Verneed::add_name(const char* name)
{
  Verneed_version* vv = new Verneed_version(name);
  this->need_versions_.push_back(vv);
  return vv;
}

// Set the version indexes starting at INDEX.

unsigned int
Verneed::finalize(unsigned int index)
{
  for (Need_versions::iterator p = this->need_versions_.begin();
       p != this->need_versions_.end();
       ++p)
    {
      (*p)->set_index(index);
      ++index;
    }
  return index;
}

// Write this list of referenced versions to a buffer for the output
// section.

template<int size, bool big_endian>
unsigned char*
Verneed::write(const Stringpool* dynpool, bool is_last,
	       unsigned char* pb) const
{
  const int verneed_size = elfcpp::Elf_sizes<size>::verneed_size;
  const int vernaux_size = elfcpp::Elf_sizes<size>::vernaux_size;

  elfcpp::Verneed_write<size, big_endian> vn(pb);
  vn.set_vn_version(elfcpp::VER_NEED_CURRENT);
  vn.set_vn_cnt(this->need_versions_.size());
  vn.set_vn_file(dynpool->get_offset(this->filename()));
  vn.set_vn_aux(verneed_size);
  vn.set_vn_next(is_last
		 ? 0
		 : verneed_size + this->need_versions_.size() * vernaux_size);
  pb += verneed_size;

  Need_versions::const_iterator p;
  unsigned int i;
  for (p = this->need_versions_.begin(), i = 0;
       p != this->need_versions_.end();
       ++p, ++i)
    {
      elfcpp::Vernaux_write<size, big_endian> vna(pb);
      vna.set_vna_hash(Dynobj::elf_hash((*p)->version()));
      // FIXME: We need to sometimes set VER_FLG_WEAK here.
      vna.set_vna_flags(0);
      vna.set_vna_other((*p)->index());
      vna.set_vna_name(dynpool->get_offset((*p)->version()));
      vna.set_vna_next(i + 1 >= this->need_versions_.size()
		       ? 0
		       : vernaux_size);
      pb += vernaux_size;
    }

  return pb;
}

// Versions methods.

Versions::Versions(const Version_script_info& version_script,
                   Stringpool* dynpool)
  : defs_(), needs_(), version_table_(),
    is_finalized_(false), version_script_(version_script),
    needs_base_version_(parameters->options().shared())
{
  if (!this->version_script_.empty())
    {
      // Parse the version script, and insert each declared version into
      // defs_ and version_table_.
      std::vector<std::string> versions = this->version_script_.get_versions();

      if (this->needs_base_version_ && !versions.empty())
	this->define_base_version(dynpool);

      for (size_t k = 0; k < versions.size(); ++k)
        {
          Stringpool::Key version_key;
          const char* version = dynpool->add(versions[k].c_str(),
                                             true, &version_key);
          Verdef* const vd = new Verdef(
              version,
              this->version_script_.get_dependencies(version),
              false, false, false, false);
          this->defs_.push_back(vd);
          Key key(version_key, 0);
          this->version_table_.insert(std::make_pair(key, vd));
        }
    }
}

Versions::~Versions()
{
  for (Defs::iterator p = this->defs_.begin();
       p != this->defs_.end();
       ++p)
    delete *p;

  for (Needs::iterator p = this->needs_.begin();
       p != this->needs_.end();
       ++p)
    delete *p;
}

// Define the base version of a shared library.  The base version definition
// must be the first entry in defs_.  We insert it lazily so that defs_ is
// empty if no symbol versioning is used.  Then layout can just drop the
// version sections.

void
Versions::define_base_version(Stringpool* dynpool)
{
  // If we do any versioning at all,  we always need a base version, so
  // define that first.  Nothing explicitly declares itself as part of base,
  // so it doesn't need to be in version_table_.
  gold_assert(this->defs_.empty());
  const char* name = parameters->options().soname();
  if (name == NULL)
    name = parameters->options().output_file_name();
  name = dynpool->add(name, false, NULL);
  Verdef* vdbase = new Verdef(name, std::vector<std::string>(),
                              true, false, false, true);
  this->defs_.push_back(vdbase);
  this->needs_base_version_ = false;
}

// Return the dynamic object which a symbol refers to.

Dynobj*
Versions::get_dynobj_for_sym(const Symbol_table* symtab,
			     const Symbol* sym) const
{
  if (sym->is_copied_from_dynobj())
    return symtab->get_copy_source(sym);
  else
    {
      Object* object = sym->object();
      gold_assert(object->is_dynamic());
      return static_cast<Dynobj*>(object);
    }
}

// Record version information for a symbol going into the dynamic
// symbol table.

void
Versions::record_version(const Symbol_table* symtab,
			 Stringpool* dynpool, const Symbol* sym)
{
  gold_assert(!this->is_finalized_);
  gold_assert(sym->version() != NULL);

  Stringpool::Key version_key;
  const char* version = dynpool->add(sym->version(), false, &version_key);

  if (!sym->is_from_dynobj() && !sym->is_copied_from_dynobj())
    {
      if (parameters->options().shared())
        this->add_def(dynpool, sym, version, version_key);
    }
  else
    {
      // This is a version reference.
      Dynobj* dynobj = this->get_dynobj_for_sym(symtab, sym);
      this->add_need(dynpool, dynobj->soname(), version, version_key);
    }
}

// We've found a symbol SYM defined in version VERSION.

void
Versions::add_def(Stringpool* dynpool, const Symbol* sym, const char* version,
		  Stringpool::Key version_key)
{
  Key k(version_key, 0);
  Version_base* const vbnull = NULL;
  std::pair<Version_table::iterator, bool> ins =
    this->version_table_.insert(std::make_pair(k, vbnull));

  if (!ins.second)
    {
      // We already have an entry for this version.
      Version_base* vb = ins.first->second;

      // We have now seen a symbol in this version, so it is not
      // weak.
      gold_assert(vb != NULL);
      vb->clear_weak();
    }
  else
    {
      // If we are creating a shared object, it is an error to
      // find a definition of a symbol with a version which is not
      // in the version script.
      if (parameters->options().shared())
	{
	  gold_error(_("symbol %s has undefined version %s"),
		     sym->demangled_name().c_str(), version);
	  if (this->needs_base_version_)
	    this->define_base_version(dynpool);
	}
      else
	// We only insert a base version for shared library.
	gold_assert(!this->needs_base_version_);
	
      // When creating a regular executable, automatically define
      // a new version.
      Verdef* vd = new Verdef(version, std::vector<std::string>(),
                              false, false, false, false);
      this->defs_.push_back(vd);
      ins.first->second = vd;
    }
}

// Add a reference to version NAME in file FILENAME.

void
Versions::add_need(Stringpool* dynpool, const char* filename, const char* name,
		   Stringpool::Key name_key)
{
  Stringpool::Key filename_key;
  filename = dynpool->add(filename, true, &filename_key);

  Key k(name_key, filename_key);
  Version_base* const vbnull = NULL;
  std::pair<Version_table::iterator, bool> ins =
    this->version_table_.insert(std::make_pair(k, vbnull));

  if (!ins.second)
    {
      // We already have an entry for this filename/version.
      return;
    }

  // See whether we already have this filename.  We don't expect many
  // version references, so we just do a linear search.  This could be
  // replaced by a hash table.
  Verneed* vn = NULL;
  for (Needs::iterator p = this->needs_.begin();
       p != this->needs_.end();
       ++p)
    {
      if ((*p)->filename() == filename)
	{
	  vn = *p;
	  break;
	}
    }

  if (vn == NULL)
    {
      // Create base version definition lazily for shared library.
      if (this->needs_base_version_)
	this->define_base_version(dynpool);

      // We have a new filename.
      vn = new Verneed(filename);
      this->needs_.push_back(vn);
    }

  ins.first->second = vn->add_name(name);
}

// Set the version indexes.  Create a new dynamic version symbol for
// each new version definition.

unsigned int
Versions::finalize(Symbol_table* symtab, unsigned int dynsym_index,
		   std::vector<Symbol*>* syms)
{
  gold_assert(!this->is_finalized_);

  unsigned int vi = 1;

  for (Defs::iterator p = this->defs_.begin();
       p != this->defs_.end();
       ++p)
    {
      (*p)->set_index(vi);
      ++vi;

      // Create a version symbol if necessary.
      if (!(*p)->is_symbol_created())
	{
	  Symbol* vsym = symtab->define_as_constant((*p)->name(),
						    (*p)->name(),
						    Symbol_table::PREDEFINED,
						    0, 0,
						    elfcpp::STT_OBJECT,
						    elfcpp::STB_GLOBAL,
						    elfcpp::STV_DEFAULT, 0,
						    false, false);
	  vsym->set_needs_dynsym_entry();
          vsym->set_dynsym_index(dynsym_index);
	  vsym->set_is_default();
	  ++dynsym_index;
	  syms->push_back(vsym);
	  // The name is already in the dynamic pool.
	}
    }

  // Index 1 is used for global symbols.
  if (vi == 1)
    {
      gold_assert(this->defs_.empty());
      vi = 2;
    }

  for (Needs::iterator p = this->needs_.begin();
       p != this->needs_.end();
       ++p)
    vi = (*p)->finalize(vi);

  this->is_finalized_ = true;

  return dynsym_index;
}

// Return the version index to use for a symbol.  This does two hash
// table lookups: one in DYNPOOL and one in this->version_table_.
// Another approach alternative would be store a pointer in SYM, which
// would increase the size of the symbol table.  Or perhaps we could
// use a hash table from dynamic symbol pointer values to Version_base
// pointers.

unsigned int
Versions::version_index(const Symbol_table* symtab, const Stringpool* dynpool,
			const Symbol* sym) const
{
  Stringpool::Key version_key;
  const char* version = dynpool->find(sym->version(), &version_key);
  gold_assert(version != NULL);

  Key k;
  if (!sym->is_from_dynobj() && !sym->is_copied_from_dynobj())
    {
      if (!parameters->options().shared())
        return elfcpp::VER_NDX_GLOBAL;
      k = Key(version_key, 0);
    }
  else
    {
      Dynobj* dynobj = this->get_dynobj_for_sym(symtab, sym);

      Stringpool::Key filename_key;
      const char* filename = dynpool->find(dynobj->soname(), &filename_key);
      gold_assert(filename != NULL);

      k = Key(version_key, filename_key);
    }

  Version_table::const_iterator p = this->version_table_.find(k);
  gold_assert(p != this->version_table_.end());

  return p->second->index();
}

// Return an allocated buffer holding the contents of the symbol
// version section.

template<int size, bool big_endian>
void
Versions::symbol_section_contents(const Symbol_table* symtab,
				  const Stringpool* dynpool,
				  unsigned int local_symcount,
				  const std::vector<Symbol*>& syms,
				  unsigned char** pp,
				  unsigned int* psize) const
{
  gold_assert(this->is_finalized_);

  unsigned int sz = (local_symcount + syms.size()) * 2;
  unsigned char* pbuf = new unsigned char[sz];

  for (unsigned int i = 0; i < local_symcount; ++i)
    elfcpp::Swap<16, big_endian>::writeval(pbuf + i * 2,
					   elfcpp::VER_NDX_LOCAL);

  for (std::vector<Symbol*>::const_iterator p = syms.begin();
       p != syms.end();
       ++p)
    {
      unsigned int version_index;
      const char* version = (*p)->version();
      if (version != NULL)
	version_index = this->version_index(symtab, dynpool, *p);
      else
	{
	  if ((*p)->is_defined() && !(*p)->is_from_dynobj())
	    version_index = elfcpp::VER_NDX_GLOBAL;
	  else
	    version_index = elfcpp::VER_NDX_LOCAL;
	}
      // If the symbol was defined as foo@@V1 instead of foo@@@@V1, add
      // the hidden bit.
      if ((*p)->version() != NULL && !(*p)->is_default())
        version_index |= elfcpp::VERSYM_HIDDEN;
      elfcpp::Swap<16, big_endian>::writeval(pbuf + (*p)->dynsym_index() * 2,
                                             version_index);
    }

  *pp = pbuf;
  *psize = sz;
}

// Return an allocated buffer holding the contents of the version
// definition section.

template<int size, bool big_endian>
void
Versions::def_section_contents(const Stringpool* dynpool,
			       unsigned char** pp, unsigned int* psize,
			       unsigned int* pentries) const
{
  gold_assert(this->is_finalized_);
  gold_assert(!this->defs_.empty());

  const int verdef_size = elfcpp::Elf_sizes<size>::verdef_size;
  const int verdaux_size = elfcpp::Elf_sizes<size>::verdaux_size;

  unsigned int sz = 0;
  for (Defs::const_iterator p = this->defs_.begin();
       p != this->defs_.end();
       ++p)
    {
      sz += verdef_size + verdaux_size;
      sz += (*p)->count_dependencies() * verdaux_size;
    }

  unsigned char* pbuf = new unsigned char[sz];

  unsigned char* pb = pbuf;
  Defs::const_iterator p;
  unsigned int i;
  for (p = this->defs_.begin(), i = 0;
       p != this->defs_.end();
       ++p, ++i)
    pb = (*p)->write<size, big_endian>(dynpool,
				       i + 1 >= this->defs_.size(),
				       pb);

  gold_assert(static_cast<unsigned int>(pb - pbuf) == sz);

  *pp = pbuf;
  *psize = sz;
  *pentries = this->defs_.size();
}

// Return an allocated buffer holding the contents of the version
// reference section.

template<int size, bool big_endian>
void
Versions::need_section_contents(const Stringpool* dynpool,
				unsigned char** pp, unsigned int* psize,
				unsigned int* pentries) const
{
  gold_assert(this->is_finalized_);
  gold_assert(!this->needs_.empty());

  const int verneed_size = elfcpp::Elf_sizes<size>::verneed_size;
  const int vernaux_size = elfcpp::Elf_sizes<size>::vernaux_size;

  unsigned int sz = 0;
  for (Needs::const_iterator p = this->needs_.begin();
       p != this->needs_.end();
       ++p)
    {
      sz += verneed_size;
      sz += (*p)->count_versions() * vernaux_size;
    }

  unsigned char* pbuf = new unsigned char[sz];

  unsigned char* pb = pbuf;
  Needs::const_iterator p;
  unsigned int i;
  for (p = this->needs_.begin(), i = 0;
       p != this->needs_.end();
       ++p, ++i)
    pb = (*p)->write<size, big_endian>(dynpool,
				       i + 1 >= this->needs_.size(),
				       pb);

  gold_assert(static_cast<unsigned int>(pb - pbuf) == sz);

  *pp = pbuf;
  *psize = sz;
  *pentries = this->needs_.size();
}

// Instantiate the templates we need.  We could use the configure
// script to restrict this to only the ones for implemented targets.

#ifdef HAVE_TARGET_32_LITTLE
template
class Sized_dynobj<32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Sized_dynobj<32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Sized_dynobj<64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Sized_dynobj<64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Versions::symbol_section_contents<32, false>(
    const Symbol_table*,
    const Stringpool*,
    unsigned int,
    const std::vector<Symbol*>&,
    unsigned char**,
    unsigned int*) const;
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Versions::symbol_section_contents<32, true>(
    const Symbol_table*,
    const Stringpool*,
    unsigned int,
    const std::vector<Symbol*>&,
    unsigned char**,
    unsigned int*) const;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Versions::symbol_section_contents<64, false>(
    const Symbol_table*,
    const Stringpool*,
    unsigned int,
    const std::vector<Symbol*>&,
    unsigned char**,
    unsigned int*) const;
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Versions::symbol_section_contents<64, true>(
    const Symbol_table*,
    const Stringpool*,
    unsigned int,
    const std::vector<Symbol*>&,
    unsigned char**,
    unsigned int*) const;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Versions::def_section_contents<32, false>(
    const Stringpool*,
    unsigned char**,
    unsigned int*,
    unsigned int*) const;
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Versions::def_section_contents<32, true>(
    const Stringpool*,
    unsigned char**,
    unsigned int*,
    unsigned int*) const;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Versions::def_section_contents<64, false>(
    const Stringpool*,
    unsigned char**,
    unsigned int*,
    unsigned int*) const;
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Versions::def_section_contents<64, true>(
    const Stringpool*,
    unsigned char**,
    unsigned int*,
    unsigned int*) const;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Versions::need_section_contents<32, false>(
    const Stringpool*,
    unsigned char**,
    unsigned int*,
    unsigned int*) const;
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Versions::need_section_contents<32, true>(
    const Stringpool*,
    unsigned char**,
    unsigned int*,
    unsigned int*) const;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Versions::need_section_contents<64, false>(
    const Stringpool*,
    unsigned char**,
    unsigned int*,
    unsigned int*) const;
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Versions::need_section_contents<64, true>(
    const Stringpool*,
    unsigned char**,
    unsigned int*,
    unsigned int*) const;
#endif

} // End namespace gold.
@


1.63
log
@	PR gold/12525
	PR gold/12952
	* resolve.cc (Symbol::override_base_with_special): Don't override
	the version if the overriding symbol has a different name.
	* dynobj.cc (Versions::add_def): Add dynpool parameter.  Change
	all callers.  If we give an error about an undefined version,
	define the base version if necessary.
	* dynobj.h (class Versions): Update declaration.
	* testsuite/weak_alias_test_5.cc: New file.
	* testsuite/weak_alias_test.script: New file.
	* testsuite/weak_alias_test_main.cc: Check that versioned_symbol
	and versioned_alias have the right value, and call t2.
	* testsuite/Makefile.am (weak_alias_test_DEPENDENCIES): Add
	weak_alias_test_5.so.
	(weak_alias_test_LDADD): Likewise.
	(weak_alias_test_5_pic.o, weak_alias_test_5.so): New targets.
	* testsuite/Makefile.in: Rebuild.
@
text
@d826 1
a826 1
	&& (*p)->dynsym_index() != -1U)
@


1.62
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d1486 1
a1486 1
        this->add_def(sym, version, version_key);
d1499 1
a1499 1
Versions::add_def(const Symbol* sym, const char* version,
d1523 6
a1528 2
	gold_error(_("symbol %s has undefined version %s"),
		   sym->demangled_name().c_str(), version);
@


1.61
log
@	* archive.cc (Library_base::should_include_member): Move
	method here from class Archive.
	(Archive::Archive): Initialize base class.
	(Archive::should_include_member): Move to base class.
	(Archive::do_for_all_unused_symbols): New function.
	(Add_archive_symbols::run): Remove redundant access to
	incremental_inputs.
	(Lib_group::Lib_group): Initialize base class.
	(Lib_group::do_filename): New function.
	(Lib_group::include_member): Pass pointer to Lib_group to
	report_object.
	(Lib_group::do_for_all_unused_symbols): New function.
	(Add_lib_group_symbols::run): Report archive information for
	incremental links.
	* archive.h (class Library_base): New base class.
	(class Archive): Derive from Library_base.
	(Archive::filename): Move to base class.
	(Archive::set_incremental_info): Likewise.
	(Archive::incremental_info): Likewise.
	(Archive::Should_include): Likewise.
	(Archive::should_include_member): Likewise.
	(Archive::Armap_entry): Remove.
	(Archive::Unused_symbol_iterator): Remove.
	(Archive::unused_symbols_begin): Remove.
	(Archive::unused_symbols_end): Remove.
	(Archive::do_filename): New function.
	(Archive::do_get_mtime): New function.
	(Archive::do_for_all_unused_symbols): New function.
	(Archive::task_): Move to base class.
	(Archive::incremental_info_): Likewise.
	(class Lib_group): Derive from Library_base.
	(Lib_group::do_filename): New function.
	(Lib_group::do_get_mtime): New function.
	(Lib_group::do_for_all_unused_symbols): New function.
	(Lib_group::task_): Move to base class.
	* dynobj.cc (Sized_dynobj::do_for_all_global_symbols): New
	function.
	* dynobj.h (Sized_dynobj::do_for_all_global_symbols): New
	function.
	* incremental.cc (Incremental_inputs::report_archive_begin):
	Use Library_base; call library's get_mtime; add incremental inputs
	entry before members.
	(class Unused_symbol_visitor): New class.
	(Incremental_inputs::report_archive_end): Use Library_base; use
	visitor class to record unused symbols; don't add incremental inputs
	entry after members.
	(Incremental_inputs::report_object): Use Library_base.
	* incremental.h
	(Incremental_archive_entry::Incremental_archive_entry): Remove
	unused Archive parameter.
	(Incremental_inputs::report_archive_begin): Use Library_base.
	(Incremental_inputs::report_archive_end): Likewise.
	(Incremental_inputs::report_object): Likewise.
	* object.cc (Sized_relobj::do_for_all_global_symbols): New
	function.
	* object.h (Object::for_all_global_symbols): New function.
	(Object::do_for_all_global_symbols): New function.
	(Sized_relobj::do_for_all_global_symbols): New function.
	* plugin.cc (Sized_pluginobj::do_for_all_global_symbols):  New
	function.
	* plugin.h (Sized_pluginobj::do_for_all_global_symbols):  New
	function.
@
text
@d52 3
a54 2
  this->soname_ = this->input_file()->found_name();
  if (this->offset() != 0)
d56 13
a68 7
      std::string::size_type open_paren = this->name().find('(');
      std::string::size_type close_paren = this->name().find(')');
      if (open_paren != std::string::npos && close_paren != std::string::npos)
	{
	  // It's an archive, and name() is of the form 'foo.a(bar.so)'.
	  this->soname_ = this->name().substr(open_paren + 1,
					      close_paren - (open_paren + 1));
d715 2
a716 2
  // If printing symbol counts or a cross reference table, we want to
  // track symbols.
d718 2
a719 1
      || parameters->options().cref())
d798 10
@


1.60
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d764 26
@


1.59
log
@	PR 11855
	* script.cc (Script_options::Script_options): Initialize
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_assignment): Update
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_reference): New function.
	(script_symbol): New function.
	* script.h (class Script_options): Add symbol_definitions_ and
	symbol_references_ fields.
	(Script_options::referenced_const_iterator): New type.
	(Script_options::referenced_begin): New function.
	(Script_options::referenced_end): New function.
	(Script_options::is_referenced): New function.
	(Script_options::any_unreferenced): New function.
	* script-c.h (script_symbol): Declare.
	* yyscript.y (exp): Call script_symbol.
	* symtab.cc: Include "script.h".
	(Symbol_table::gc_mark_undef_symbols): Add layout parameter.
	Change all callers.  Check symbols referenced by scripts.
	(Symbol_table::add_undefined_symbols_from_command_line): Add
	layout parameter.  Change all callers.
	(Symbol_table::do_add_undefined_symbols_from_command_line):
	Likewise.  Break out loop body.  Check symbols referenced by
	scripts.
	(Symbol_table::add_undefined_symbol_from_command_line): New
	function broken out of
	do_add_undefined_symbols_from_command_line.
	* symtab.h (class Symbol_table): Update declarations.
	* archive.cc: Include "layout.h".
	(Archive::should_include_member): Add layout parameter.  Change
	all callers.  Check for symbol mentioned in expression.
	* archive.h (class Archive): Update declaration.
	* object.cc (Sized_relobj::do_should_include_member): Add layout
	parameter.
	* object.h (Object::should_include_member): Add layout parameter.
	Change all callers.
	(Object::do_should_include_member): Add layout parameter.
	(class Sized_relobj): Update declaration.
	* dynobj.cc (Sized_dynobj::do_should_include_member): Add layout
	parameter.
	* dynobj.h (class Sized_dynobj): Update declaration.
	* plugin.cc (Sized_pluginobj::do_should_include_member): Add
	layout parameter.
	* plugin.h (class Sized_pluginobj): Update declaration.
@
text
@d1734 2
a1735 2
				unsigned char** pp, unsigned int *psize,
				unsigned int *pentries) const
@


1.58
log
@2010-03-22  Rafael Espindola  <espindola@@google.com>

	* archive.cc (Should_include): Move to archive.h.
	(should_include_member): Make it a member of Archive.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* archive.h: Include options.h.
	(Archive_member): Moved from Archive.
	(Should_include): Moved from archive.cc.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* dynobj.cc (do_should_include_member): New.
	* dynobj.h (do_should_include_member): New.
	* gold.cc (queue_initial_tasks): Update call to queue.
	* main.cc (main): Print lib group stats.
	* object.cc (do_should_include_member): New.
	* object.h: Include archive.h.
	(Object::should_include_member): New.
	(Object::do_should_include_member): New.
	(Sized_relobj::do_should_include_member): New.
	* options.cc (General_options::parse_start_lib): New.
	(General_options::parse_end_lib): New.
	(Input_arguments::add_file): Handle lib groups.
	(Input_arguments::start_group): Check we are not in a lib.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib): New.
	* options.h (General_options): Add start_lib and end_lib.
	(Input_argument::lib_): New.
	(Input_argument::lib): New.
	(Input_argument::is_lib): New.
	(Input_file_lib): New.
	(Input_arguments::in_lib_): New.
	(Input_arguments::in_lib): New.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib_): New.
	* plugin.cc (Pluginobj::get_symbol_resolution_info): Mark symbols
	in unused members as preempted.
	(Sized_pluginobj::do_should_include_member): New.
	* plugin.h (Sized_pluginobj::do_should_include_member): New.
	* readsyms.cc (Read_symbols::locks): If we are just reading a member,
	return the blocker.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::do_read_symbols): Handle lib groups.
	(Read_symbols::get_name): Handle lib groups.
	* readsyms.h (Read_symbols): Add an archive member pointer.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::member_): New.
	* script.cc (read_input_script): Update call to queue_soon.
@
text
@d756 4
a759 2
Sized_dynobj<size, big_endian>::do_should_include_member(
    Symbol_table*, Read_symbols_data*, std::string*)
@


1.57
log
@	include:
	* elf/common.h (VER_FLG_*): Document.
	(VER_FLG_INFO): Define.

	gold:
	* dynobj.h (Verdef::Verdef): Add is_info arg, is_info member
	function, is_info_ member.
	* dynobj.cc (Verdef::write): Set VER_FLG_INFO if this->is_info_.
	(Versions::Versions): Update caller.
	(Versions::define_base_version): Likewise.
	(Versions::add_def): Likewise.

	elfcpp:
	* elfcpp.h (VER_FLG_INFO): Define.

	binutils:
	* readelf.c (get_ver_flags): Handle VER_FLG_INFO.
@
text
@d754 8
@


1.56
log
@	* script.cc (class Lazy_demangler): Recreate--revert part of patch
	of 2009-12-30.
	(Version_script_info::Version_script_info): Initialize globs_,
	default_version_, default_is_global_, and exact_.  Don't
	initialize globals_ or locals_.
	(Version_script_info::build_lookup_tables): Build local symbols
	first.
	(Version_script_info::unquote): New function.
	(Version_script_info::add_exact_match): New function.
	(Version_script_info::build_expression_list_lookup): Remove lookup
	parameter.  Add is_global parameter.  Change all callers.  Handle
	wildcard pattern specially.  Unquote pattern.  Call
	add_exact_match.
	(Version_script_info::get_name_to_match): New function.
	(Version_script_info::get_symbol_version): New function.
	(Version_script_info::get_symbol_version_helper): Remove.
	(Version_script_info::check_unmatched_names): Call unquote.
	* script.h (class Version_script_info): Change get_symbol_version
	to be non-inline and add is_global parameter; change all callers.
	Rewrite symbol_is_local.  Update declarations.  Define struct
	Version_tree_match, Exact, Globs.  Don't define struct Lookup.
	Remove globals_ and locals_ members.  Add exact_, globs_,
	default_version_, is_global_.
	(Version_script_info::Glob): Remove pattern, add expression and
	is_global.  Update constructor.  Change all callers.
	* dynobj.cc (Versions::finalize): Mark the version symbol as the
	default version.
	(Versions::symbol_section_contents): If a symbol is undefined, or
	defined in a dynamic object, set the version index to
	VER_NDX_LOCAL.
	* symtab.cc (Symbol_table::add_from_relobj): Don't call
	symbol_is_local.
	(Symbol_table::add_from_pluginobj): Likewise.
	* testsuite/ver_matching_test.sh: blaza1 and blaza go into V2.
@
text
@d1224 2
a1225 1
		  | (this->is_weak_ ? elfcpp::VER_FLG_WEAK : 0));
d1357 1
a1357 1
              false, false, false);
d1395 1
a1395 1
                              true, false, true);
d1478 1
a1478 1
                              false, false, false);
@


1.55
log
@	* dynobj.cc (big_endian>::find_dynsym_sections): Set pi to NULL in
	the SHT_SYMTAB case.
@
text
@d1563 1
d1653 1
a1653 3
      if (version == NULL)
	version_index = elfcpp::VER_NDX_GLOBAL;
      else        
d1655 7
@


1.54
log
@	PR 11084
	* dynobj.cc (Sized_dynobj::find_dynsym_sections): If there is no
	dynamic symbol table, use the normal symbol table.
	(Sized_dynobj::do_read_symbols): Remove assertion about type of
	symbol table.
@
text
@d134 1
@


1.53
log
@	PR 10980
	* options.h (class General_options): Add --cref.
	* main.cc (main): Print cref table if --cref.  Don't close mapfile
	until after printing cref table.
	* cref.cc: Include "symtab.h".
	(class Cref_inputs): Define Cref_table_compare and Cref_table.
	(Cref_table_compare::operator()): New function.
	(Cref_inputs::gather_cref): New function.
	(filecol): New static const.
	(Cref_inputs::print_cref): New function.
	(Cref::print_cref): New function.
	* cref.h: Include <cstdio>.
	(class Cref): Update declarations.
	* mapfile.h (Mapfile::file): New function.
	* object.h (class Object): Define Symbols.  Declare virtual
	do_get_global_symbols.
	(Object::get_global_symbols): New function.
	* object.cc (Input_objects::add_object): Pass object to cref_ if
	--cref.
	(Input_objects::archive_start): Likewise.
	(Input_objects::archive_stop): Likewise.
	(Input_objects::print_cref): New function.
	* dynobj.h (Sized_dynobj::do_get_global_symbols): New function.
	* dynobj.cc (big_endian>::do_add_symbols): Create symbols_ if
	--cref.
	* plugin.cc (Sized_pluginobj::do_get_global_symbols): New
	function.
	* plugin.h (class Sized_pluginobj): Update declarations.
@
text
@d109 1
d132 3
d173 19
a362 1
      gold_assert(dynsymshdr.get_sh_type() == elfcpp::SHT_DYNSYM);
@


1.52
log
@	PR 10450
	* dynobj.cc (Dynobj::create_gnu_hash_table): Add symbols to the
	GNU hash table if they need a dynamic value.  Otherwise, don't add
	them if they are defined in a dynamic object or are forced local.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d685 4
a688 3
  // If printing symbol counts, we want to track symbols.
  
  if (parameters->options().user_set_print_symbol_counts())
@


1.51
log
@	* symtab.h (class Symbol_table): Add enum Defined.
	* resolve.cc (Symbol_table::should_override): Add defined
	parameter.  Change all callers.  Test whether object is NULL
	before calling a method on it.
	(Symbol_table::report_resolve_problem): Add defined parameter.
	Change all callers.
	(Symbol_table::should_override_with_special): Likewise.
	* symtab.cc (Symbol_table::define_in_output_data): Add defined
	parameter.  Change all callers.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::define_in_output_segment): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::define_as_constant): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* script.h (class Symbol_assignment): Add is_defsym parameter to
	constructor; change all callers.
	* script.cc (Script_options::add_symbol_assignment): Add is_defsym
	parameter.  Change all callers.  Add is_defsym_ field.
	(class Parser_closure): Add parsing_defsym parameter to
	constructor; change all callers.  Add parsing_defsym accessor
	function.  Add parsing_defsym_ field.
@
text
@d962 4
a965 3
      // FIXME: Should put on unhashed_dynsyms if the symbol is
      // hidden.
      if (sym->is_undefined())
@


1.50
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d1529 3
a1531 1
						    (*p)->name(), 0, 0,
@


1.49
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d42 2
a43 2
Dynobj::Dynobj(const std::string& aname, Input_file* ainput_file, off_t aoffset)
  : Object(aname, ainput_file, true, aoffset),
d70 3
a72 3
    const std::string& aname,
    Input_file* ainput_file,
    off_t aoffset,
d74 1
a74 1
  : Dynobj(aname, ainput_file, aoffset),
d88 2
a89 2
  const unsigned int sec_shnum = this->elf_file_.shnum();
  this->set_shnum(sec_shnum);
d111 1
a111 1
  const unsigned int sec_shnum = this->shnum();
d113 1
a113 1
  for (unsigned int i = 0; i < sec_shnum; ++i, p += This::shdr_size)
d183 1
a183 1
    File_view** aview,
d189 1
a189 1
      *aview = NULL;
d203 2
a204 2
  *aview = this->get_lasting_view(shdr.get_sh_offset(), shdr.get_sh_size(),
				  true, false);
d427 2
a428 2
  const unsigned int sec_shnum = this->shnum();
  if (sec_shnum == 0)
d440 1
a440 1
  for (unsigned int i = 1; i < sec_shnum; ++i, pshdrs += This::shdr_size)
d451 1
a451 1
      const char* aname = pnames + shdr.get_sh_name();
d453 2
a454 2
      this->handle_gnu_warning_section(aname, i, symtab);
      this->handle_split_stack_section(aname);
d471 1
a471 1
    const char* aname) const
d477 1
a477 1
  (*version_map)[ndx] = aname;
d673 2
a674 2
  const int symsize = This::sym_size;
  const size_t symcount = sd->symbols_size / symsize;
d676 1
a676 1
  if (symcount * symsize != sd->symbols_size)
d1220 3
a1222 3
      elfcpp::Verdaux_write<size, big_endian> avda(pb);
      avda.set_vda_name(dynpool->get_offset(*p));
      avda.set_vda_next(i + 1 >= this->deps_.size() ? 0 : verdaux_size);
d1308 1
a1308 1
Versions::Versions(const Version_script_info& vscript,
d1311 1
a1311 1
    is_finalized_(false), version_script_(vscript),
d1623 1
a1623 1
      unsigned int vindex;
d1626 1
a1626 1
	vindex = elfcpp::VER_NDX_GLOBAL;
d1628 1
a1628 1
	vindex = this->version_index(symtab, dynpool, *p);
d1632 1
a1632 1
        vindex |= elfcpp::VERSYM_HIDDEN;
d1634 1
a1634 1
                                             vindex);
@


1.48
log
@	* dynobj.cc (Sized_dynobj::do_read_symbols): Clear version
	information fields.
@
text
@d42 2
a43 2
Dynobj::Dynobj(const std::string& name, Input_file* input_file, off_t offset)
  : Object(name, input_file, true, offset),
d70 3
a72 3
    const std::string& name,
    Input_file* input_file,
    off_t offset,
d74 1
a74 1
  : Dynobj(name, input_file, offset),
d88 2
a89 2
  const unsigned int shnum = this->elf_file_.shnum();
  this->set_shnum(shnum);
d111 1
a111 1
  const unsigned int shnum = this->shnum();
d113 1
a113 1
  for (unsigned int i = 0; i < shnum; ++i, p += This::shdr_size)
d183 1
a183 1
    File_view** view,
d189 1
a189 1
      *view = NULL;
d203 2
a204 2
  *view = this->get_lasting_view(shdr.get_sh_offset(), shdr.get_sh_size(),
				 true, false);
d427 2
a428 2
  const unsigned int shnum = this->shnum();
  if (shnum == 0)
d440 1
a440 1
  for (unsigned int i = 1; i < shnum; ++i, pshdrs += This::shdr_size)
d451 1
a451 1
      const char* name = pnames + shdr.get_sh_name();
d453 2
a454 2
      this->handle_gnu_warning_section(name, i, symtab);
      this->handle_split_stack_section(name);
d471 1
a471 1
    const char* name) const
d477 1
a477 1
  (*version_map)[ndx] = name;
d673 2
a674 2
  const int sym_size = This::sym_size;
  const size_t symcount = sd->symbols_size / sym_size;
d676 1
a676 1
  if (symcount * sym_size != sd->symbols_size)
d1220 3
a1222 3
      elfcpp::Verdaux_write<size, big_endian> vda(pb);
      vda.set_vda_name(dynpool->get_offset(*p));
      vda.set_vda_next(i + 1 >= this->deps_.size() ? 0 : verdaux_size);
d1308 1
a1308 1
Versions::Versions(const Version_script_info& version_script,
d1311 1
a1311 1
    is_finalized_(false), version_script_(version_script),
d1623 1
a1623 1
      unsigned int version_index;
d1626 1
a1626 1
	version_index = elfcpp::VER_NDX_GLOBAL;
d1628 1
a1628 1
	version_index = this->version_index(symtab, dynpool, *p);
d1632 1
a1632 1
        version_index |= elfcpp::VERSYM_HIDDEN;
d1634 1
a1634 1
                                             version_index);
@


1.47
log
@2009-10-16  Doug Kwan  <dougkwan@@google.com>

	* dynobj.cc (Versions::Versions): Initialize version_script_.
	Only insert base version symbol definition for a shared object
	if version script defines any version versions.
	(Versions::define_base_version): New method definition.
	(Versions::add_def): Check that base version is not needed.
	(Versions::add_need): Define base version lazily.
	* dynobj.h (Versions::define_base_version): New method declaration.
	(Versions::needs_base_version_): New data member declaration.
	* testsuite/Makefile.am (check_SCRIPTS): Add no_version_test.sh
	(check_DATA): Add no_version_test.stdout.
	(libno_version_test.so, no_version_test.o no_version_test.stdout):
	New make rules.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/no_version_test.c: New file.
	* testsuite/no_version_test.sh: Ditto.
@
text
@d326 8
@


1.46
log
@	* options.h (class General_options): Define
	split_stack_adjust_size parameter.
	* object.h (class Object): Add uses_split_stack_ and
	has_no_split_stack_ fields.  Add uses_split_stack and
	has_no_split_stack accessor functions.  Declare
	handle_split_stack_section.
	(class Reloc_symbol_changes): Define.
	(class Sized_relobj): Define Function_offsets.  Declare
	split_stack_adjust, split_stack_adjust_reltype, and
	find_functions.
	* object.cc (Object::handle_split_stack_section): New function.
	(Sized_relobj::do_layout): Call handle_split_stack_section.
	* dynobj.cc (Sized_dynobj::do_layout): Call
	handle_split_stack_section.
	* reloc.cc (Sized_relobj::relocate_sections): Call
	split_stack_adjust for executable sections in split_stack
	objects.  Pass reloc_map to relocate_section.
	(Sized_relobj::split_stack_adjust): New function.
	(Sized_relobj::split_stack_adjust_reltype): New function.
	(Sized_relobj::find_functions): New function.
	* target-reloc.h: Include "object.h".
	(relocate_section): Add reloc_symbol_changes parameter.  Change
	all callers.
	* target.h (class Target): Add calls_non_split method.  Declare
	do_calls_non_split virtual method.  Declare match_view and
	set_view_to_nop.
	* target.cc: Include "elfcpp.h".
	(Target::do_calls_non_split): New function.
	(Target::match_view): New function.
	(Target::set_view_to_nop): New function.
	* gold.cc (queue_middle_tasks): Give an error if mixing
	split-stack and non-split-stack objects with -r.
	* i386.cc (Target_i386::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_i386::do_calls_non_split): New function.
	* x86_64.cc (Target_x86_64::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_x86_64::do_calls_non_split): New function.
	* arm.cc (Target_arm::relocate_section): Add reloc_symbol_changes
	parameter.
	* powerpc.cc (Target_powerpc::relocate_section): Add
	reloc_symbol_changes parameter.
	* sparc.cc (Target_sparc::relocate_section): Add
	reloc_symbol_changes parameter.
	* configure.ac: Call AM_CONDITIONAL for the default target.
	* configure: Rebuild.
	* testsuite/Makefile.am (TEST_AS): New variable.
	(check_SCRIPTS): Add split_i386.sh and split_x86_64.sh.
	(check_DATA): Add split_i386 and split_x86_64 files.
	(SPLIT_DEFSYMS): Define.
	(split_i386_[1234n].o): New targets.
	(split_i386_[124]): New targets.
	(split_i386_[1234r].stdout): New targets.
	(split_x86_64_[1234n].o): New targets.
	(split_x86_64_[124]): New targets.
	(split_x86_64_[1234r].stdout): New targets.
	(MOSTLYCLEANFILES): Add new executables.
	* testsuite/split_i386.sh: New file.
	* testsuite/split_x86_64.sh: New file.
	* testsuite/split_i386_1.s: New file.
	* testsuite/split_i386_2.s: New file.
	* testsuite/split_i386_3.s: New file.
	* testsuite/split_i386_4.s: New file.
	* testsuite/split_i386_n.s: New file.
	* testsuite/split_x86_64_1.s: New file.
	* testsuite/split_x86_64_2.s: New file.
	* testsuite/split_x86_64_3.s: New file.
	* testsuite/split_x86_64_4.s: New file.
	* testsuite/split_x86_64_n.s: New file.
	* testsuite/testfile.cc (Target_test): Update relocation_section
	function.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1303 2
a1304 1
    is_finalized_(false), version_script_(version_script)
a1305 14
  // We always need a base version, so define that first.  Nothing
  // explicitly declares itself as part of base, so it doesn't need to
  // be in version_table_.
  if (parameters->options().shared())
    {
      const char* name = parameters->options().soname();
      if (name == NULL)
	name = parameters->options().output_file_name();
      name = dynpool->add(name, false, NULL);
      Verdef* vdbase = new Verdef(name, std::vector<std::string>(),
                                  true, false, true);
      this->defs_.push_back(vdbase);
    }

d1311 4
d1344 22
d1437 4
a1440 1

d1487 4
@


1.45
log
@	* object.h (class Object): Remove target_ field, and target,
	sized_target, and set_target methods.
	(Object::sized_target): Remove.
	(class Sized_relobj): Update declarations.  Remove sized_target.
	* object.cc (Sized_relobj::setup): Remove target parameter.
	Change all callers.
	(Input_objects::add_object): Don't do anything with the target.
	(make_elf_sized_object): Add punconfigured parameter.  Change all
	callers.  Set or test parameter target.
	* dynobj.cc (Sized_dynobj::target): Remove target parameter.
	Change all callers.
	* parameters.cc (Parameters::set_target): Change parameter type to
	be non-const.
	(Parameters::default_target): Remove.
	(set_parameters_target): Change parameter type to be non-const.
	(parameters_force_valid_target): New function.
	(parameters_clear_target): New function.
	* parameters.h (class Parameters): Update declarations.  Remove
	default_target method.  Add sized_target and clear_target
	methods.  Change target_ to be non-const.
	(set_parameters_target): Update declaration.
	(parameters_force_valid_target): Declare.
	(parameters_clear_target): Declare.
	* readsyms.cc (Read_symbols::do_read_symbols): Pass punconfigured
	as NULL if we aren't searching.
	(Add_symbols::run): Don't check for compatible target.
	* fileread.cc (Input_file::open_binary): Call
	parameters_force_valid_target.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (make_sized_plugin_object): Likewise.  Don't call
	set_target on object.
	* dynobj.h (class Sized_dynobj): Update declarations.
	* archive.cc (Archive::get_elf_object_for_member): Return NULL if
	make_elf_object returns NULL.
	(Archive::include_member): Don't check whether object target is
	compatible.
	* output.cc (Output_section::add_input_section): Get target from
	parameters.
	(Output_section::relax_input_section): Likewise.
	* reloc.cc (Sized_relobj::do_gc_process_relocs): Get target from
	parameters.
	(Sized_relobj::do_scan_relocs): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* symtab.cc (Symbol_table::wrap_symbol): Likewise.  Remove object
	parameter.  Change all callers.
	(Symbol_table::add_from_object): Get target from parameters.
	(Symbol_table::add_from_relobj): Don't check object target.
	(Symbol_table::add_from_dynobj): Likewise.
	(Symbol_table::define_special_symbol): Get target from
	parameters.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/binary_unittest.cc (gold_testsuite): Remove target
	parameter.  Change all callers.  Clear parameter target.
	(Binary_test): Test target here.
	* testsuite/object_unittest.cc (gold_testsuite): Remove
	target_test_pointer parameter.  Change all callers.
	(Object_test): Test target here.
@
text
@d411 1
a411 1
// here is check for .gnu.warning sections.
d446 1
@


1.44
log
@2009-08-18  Doug Kwan  <dougkwan@@google.com>

	* dynobj.cc (Sized_dynobj::setup): Take a Target object instead of
	an elcpp::Ehdr as parameter.  Adjust call to set_target.
	* dynobj.h (Sized_dynobj::setup): Take a Target object instead of
	an elfcpp::Ehdr as parameter.
	* object.cc (Object::set_target): Remove the version that looks up
	a target and sets it.
	(Sized_relobj::setup): Take a Target object instead of
	an elfcpp::Ehdr as parameter.  Adjust call to set_target.
	(make_elf_sized_object): Find target and ask target to
	make an ELF object.
	* object.h: (Object::set_target): Remove the version that looks up
	a target and sets it.
	(Sized_relobj::setup): Take a Target object instead of
	an elfcpp:Ehdr as parameter.
	* target.cc: Include dynobj.h.
	(Target::do_make_elf_object_implementation): New.
 	(Target::do_make_elf_object): New.
	* target.h (Target::make_elf_object): New template declaration.
	(Target::do_make_elf_object): New method declarations.
	(Target::do_make_elf_object_implementation): New template declaration.
@
text
@d86 1
a86 1
Sized_dynobj<size, big_endian>::setup(Target *target)
a87 1
  this->set_target(target);
@


1.44.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@d86 1
a86 1
Sized_dynobj<size, big_endian>::setup()
d88 1
d412 1
a412 1
// here is check for .gnu.warning and .note.GNU-split-stack sections.
a446 1
      this->handle_split_stack_section(name);
@


1.44.2.2
log
@	Bring over from mainline:
	2009-10-16  Doug Kwan  <dougkwan@@google.com>

	* dynobj.cc (Versions::Versions): Initialize version_script_.
	Only insert base version symbol definition for a shared object
	if version script defines any version versions.
	(Versions::define_base_version): New method definition.
	(Versions::add_def): Check that base version is not needed.
	(Versions::add_need): Define base version lazily.
	* dynobj.h (Versions::define_base_version): New method declaration.
	(Versions::needs_base_version_): New data member declaration.
@
text
@d1303 1
a1303 2
    is_finalized_(false), version_script_(version_script),
    needs_base_version_(parameters->options().shared())
d1305 14
a1323 4

      if (this->needs_base_version_ && !versions.empty())
	this->define_base_version(dynpool);

a1352 22
// Define the base version of a shared library.  The base version definition
// must be the first entry in defs_.  We insert it lazily so that defs_ is
// empty if no symbol versioning is used.  Then layout can just drop the
// version sections.

void
Versions::define_base_version(Stringpool* dynpool)
{
  // If we do any versioning at all,  we always need a base version, so
  // define that first.  Nothing explicitly declares itself as part of base,
  // so it doesn't need to be in version_table_.
  gold_assert(this->defs_.empty());
  const char* name = parameters->options().soname();
  if (name == NULL)
    name = parameters->options().output_file_name();
  name = dynpool->add(name, false, NULL);
  Verdef* vdbase = new Verdef(name, std::vector<std::string>(),
                              true, false, true);
  this->defs_.push_back(vdbase);
  this->needs_base_version_ = false;
}

d1424 1
a1424 4
      else
	// We only insert a base version for shared library.
	gold_assert(!this->needs_base_version_);
	
a1470 4
      // Create base version definition lazily for shared library.
      if (this->needs_base_version_)
	this->define_base_version(dynpool);

@


1.43
log
@	(From Rafael Espindola)
	* archive.cc (Archive::include_member): Update calls to add_symbols.
	* dynobj.cc (Sized_dynobj<size, big_endian>::make_version_map): Add
	the Layout argument.
	* dynobj.h (do_add_symbols): Add the Layout argument.
	* object.cc (Sized_relobj<size, big_endian>::do_add_symbols): Add the
	Layout argument.
	* object.h (Object::add_symbols): Add the Layout argument.
	(Object::do_add_symbols): Add the Layout argument.
	(Sized_relobj::do_add_symbols): Add the Layout argument.
	* plugin.cc (Sized_pluginobj<size, big_endian>::do_add_symbols):
	Unify the two versions.
	(Add_plugin_symbols): Remove.
	* plugin.h (Pluginobj::add_symbols, Pluginobj::do_add_symbols): Remove.
	(Sized_pluginobj::do_add_symbols): Unify the two versions.
	(Add_plugin_symbols): Remove.
	* readsyms.cc (Read_symbols::do_read_symbols): Update call to
	Add_symbols. Use Add_symbols instead of Add_plugin_symbols.
	(Add_symbols::run): Make it work with Pulginobj.
@
text
@d86 1
a86 2
Sized_dynobj<size, big_endian>::setup(
    const elfcpp::Ehdr<size, big_endian>& ehdr)
d88 1
a88 4
  this->set_target(ehdr.get_e_machine(), size, big_endian,
		   ehdr.get_e_ident()[elfcpp::EI_OSABI],
		   ehdr.get_e_ident()[elfcpp::EI_ABIVERSION]);

@


1.42
log
@	* dynobj.cc (Versions::Versions): Update comment.
@
text
@d658 2
a659 1
					       Read_symbols_data* sd)
@


1.41
log
@	* dynobj.cc (Versions::Versions): If there is an soname, use it as
	the base version name.
@
text
@d1308 1
a1308 1
  // We always need a base version, so define that first. Nothing
a1310 3
  // FIXME: Should use soname here when creating a shared object. Is
  // this fixme still valid? It looks like it's doing the right thing
  // to me.
@


1.40
log
@	* cref.cc: New file.
	* cref.h: New file.
	* options.h (class General_options): Add --print-symbol-counts.
	* main.cc (main): Issue defined symbol report if requested.
	* archive.cc (Archive::interpret_header): Make into a const member
	function.
	(Archive::add_symbols): Call Input_objects::archive_start and
	archive_stop.
	(Archive::const_iterator): Define new class.
	(Archive::begin, Archive::end): New functions.
	(Archive::include_all_members): Rewrite to use iterator.
	(Archive::count_members): New function.
	* archive.h (class Archive): Update declarations.
	(Archive::filename): New function.
	* object.cc: Include "cref.h".
	(Sized_relobj::Sized_relobj): Initialize defined_count_.
	(Sized_relobj::do_get_global_symbol_counts): New function.
	(Input_objects::add_object): Add object to cross-referencer.
	(Input_objects::archive_start): New function.
	(Input_objects::archive_stop): New function.
	(Input_objects::print_symbol_counts): New function.
	* object.h: Declare Cref and Archive.
	(Object::get_global_symbol_counts): New function.
	(Object::do_get_global_symbol_counts): New pure virtual function.
	(class Sized_relobj): Add defined_count_ field.  Update
	declarations.
	(class Input_objects): Add cref_ field.  Update constructor.
	Update declarations.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize symbols_ and
	defined_count_.
	(Sized_dynobj::do_add_symbols): Allocate symbols_ if printing
	symbol counts.
	(Sized_dynobj::do_get_global_symbol_counts): New function.
	* dynobj.h (class Sized_dynobj): Add fields symbols_ and
	defined_count_.  Update declarations.  Define Symbols typedef.
	* symtab.cc (Symbol_table::add_from_relobj): Add defined
	parameter.  Change all callers.
	(Symbol_table::add_from_dynobj): Add sympointers and defined
	parameters.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* Makefile.am (CCFILES): Add cref.cc.
	(HFILES): Add cref.h.
	* Makefile.in: Rebuild.
@
text
@d1316 4
a1319 2
      const char* name = dynpool->add(parameters->options().output_file_name(),
                                      false, NULL);
@


1.39
log
@	* dynobj.cc (Versions::add_def): If we give an error about a
	missing version, go ahead and create the version anyhow.
@
text
@d76 3
a78 1
    dynsym_shndx_(-1U)
d680 8
d696 3
a698 1
			  &version_map);
d725 23
@


1.38
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1391 2
a1392 5
	{
	  gold_error(_("symbol %s has undefined version %s"),
		     sym->demangled_name().c_str(), version);
	  return;
	}
@


1.37
log
@	* fileread.cc (File_read::find_view): Add byteshift and vshifted
	parameters.  Update for new key type to views_.  Change all
	callers.
	(File_read::read): Adjust for byteshift in returned view.
	(File_read::add_view): New function, broken out of
	find_and_make_view.
	(File_read::make_view): New function, broken out of
	find_and_make_view.
	(File_read::find_or_make_view): Add offset and aligned
	parameters.  Rewrite accordingly.  Change all callers.
	(File_read::get_view): Add offset and aligned parameters.  Adjust
	for byteshift in return value.
	(File_read::get_lasting_view): Likewise.
	* fileread.h (class File_read): Update declarations.
	(class File_read::View): Add byteshift_ field.  Add byteshift to
	constructor.  Add byteshift method.
	* archive.h (Archive::clear_uncached_views): New function.
	(Archive::get_view): Add aligned parameter.  Change all callers.
	* object.h (Object::get_view): Add aligned parameter.  Change all
	callers.
	(Object::get_lasting_view): Likewise.

	* fileread.cc (File_read::release): Don't call clear_views if
	there are multiple objects.
	* fileread.h (File_read::clear_uncached_views): New function.
	* archive.cc (Add_archive_symbols::run): Call clear_uncached_views
	on the archive.
@
text
@d75 2
a76 1
    elf_file_(this, ehdr)
a101 1
    unsigned int* pdynsym_shndx,
a106 1
  *pdynsym_shndx = -1U;
d112 2
d124 9
a132 1
	  pi = pdynsym_shndx;
d146 12
d202 1
a202 1
  if (shdr.get_sh_link() != link)
d204 1
a204 1
	        shndx, shdr.get_sh_link(), link);
d234 1
a234 1
  const unsigned int link = dynamicshdr.get_sh_link();
a314 1
  unsigned int dynsym_shndx;
d319 2
a320 2
  this->find_dynsym_sections(pshdrs, &dynsym_shndx, &versym_shndx,
			     &verdef_shndx, &verneed_shndx, &dynamic_shndx);
d330 1
a330 1
  if (dynsym_shndx != -1U)
d333 2
a334 1
      typename This::Shdr dynsymshdr(pshdrs + dynsym_shndx * This::shdr_size);
d344 1
a344 1
      strtab_shndx = dynsymshdr.get_sh_link();
d370 2
a371 2
				dynsym_shndx, &sd->versym, &sd->versym_size,
				&dummy);
d399 13
@


1.36
log
@Increase maximum bucket size for dynamic hash tables.
@
text
@d186 1
a186 1
				 false);
d211 1
a211 1
						 dynamic_size, false);
d232 2
a233 1
      strtabu = this->get_view(strtabshdr.get_sh_offset(), strtab_size, false);
d317 2
a318 1
					   dynsymshdr.get_sh_size(), false);
d341 1
a341 1
						false);
@


1.35
log
@From Craig Silverstein: implement --hash-bucket-empty-fraction for real.
@
text
@d690 1
a690 1
  // use more than 32771 buckets.  This is straight from the old GNU
d695 1
a695 1
    16411, 32771
@


1.34
log
@Remove gcc 3.2 compatibility hacks.
@
text
@d701 2
d705 1
a705 1
      if (symcount < buckets[i])
@


1.33
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d1113 1
a1113 2
Verdef::write(const Stringpool* dynpool, bool is_last, unsigned char* pb
              ACCEPT_SIZE_ENDIAN) const
d1192 1
a1192 1
	       unsigned char* pb ACCEPT_SIZE_ENDIAN) const
d1514 1
a1514 2
				  unsigned int* psize
                                  ACCEPT_SIZE_ENDIAN) const
d1554 1
a1554 2
			       unsigned int* pentries
                               ACCEPT_SIZE_ENDIAN) const
d1579 3
a1581 3
    pb = (*p)->write SELECT_SIZE_ENDIAN_NAME(size, big_endian)(
            dynpool, i + 1 >= this->defs_.size(), pb
            SELECT_SIZE_ENDIAN(size, big_endian));
d1597 1
a1597 2
				unsigned int *pentries
                                ACCEPT_SIZE_ENDIAN) const
d1622 3
a1624 3
    pb = (*p)->write SELECT_SIZE_ENDIAN_NAME(size, big_endian)(
	    dynpool, i + 1 >= this->needs_.size(), pb
            SELECT_SIZE_ENDIAN(size, big_endian));
d1665 1
a1665 2
    unsigned int*
    ACCEPT_SIZE_ENDIAN_EXPLICIT(32, false)) const;
d1677 1
a1677 2
    unsigned int*
    ACCEPT_SIZE_ENDIAN_EXPLICIT(32, true)) const;
d1689 1
a1689 2
    unsigned int*
    ACCEPT_SIZE_ENDIAN_EXPLICIT(64, false)) const;
d1701 1
a1701 2
    unsigned int*
    ACCEPT_SIZE_ENDIAN_EXPLICIT(64, true)) const;
d1711 1
a1711 2
    unsigned int*
    ACCEPT_SIZE_ENDIAN_EXPLICIT(32, false)) const;
d1721 1
a1721 2
    unsigned int*
    ACCEPT_SIZE_ENDIAN_EXPLICIT(32, true)) const;
d1731 1
a1731 2
    unsigned int*
    ACCEPT_SIZE_ENDIAN_EXPLICIT(64, false)) const;
d1741 1
a1741 2
    unsigned int*
    ACCEPT_SIZE_ENDIAN_EXPLICIT(64, true)) const;
d1751 1
a1751 2
    unsigned int*
    ACCEPT_SIZE_ENDIAN_EXPLICIT(32, false)) const;
d1761 1
a1761 2
    unsigned int*
    ACCEPT_SIZE_ENDIAN_EXPLICIT(32, true)) const;
d1771 1
a1771 2
    unsigned int*
    ACCEPT_SIZE_ENDIAN_EXPLICIT(64, false)) const;
d1781 1
a1781 2
    unsigned int*
    ACCEPT_SIZE_ENDIAN_EXPLICIT(64, true)) const;
@


1.32
log
@From Craig Silverstein: rework handling of Script_options.
@
text
@d778 1
a778 1
  if (parameters->is_big_endian())
d907 2
a908 2
  int size = parameters->get_size();
  bool big_endian = parameters->is_big_endian();
d1238 1
a1238 1
  // be in version_table_. 
d1242 1
a1242 1
  if (parameters->output_is_shared())
d1244 1
a1244 1
      const char* name = dynpool->add(parameters->output_file_name(),
d1310 1
a1310 1
  
d1316 1
a1316 1
      if (parameters->output_is_shared())
d1353 1
a1353 1
      if (parameters->output_is_shared())
d1484 1
a1484 1
      if (!parameters->output_is_shared())
@


1.31
log
@Assignments in linker scripts override definitions from object files.
@
text
@a29 1
#include "options.h"
d1231 2
a1232 1
Versions::Versions(const General_options& options, Stringpool* dynpool)
d1234 1
a1234 1
    is_finalized_(false), version_script_(options.version_script())
d1263 1
a1263 1
              options.version_script().get_dependencies(version),
@


1.30
log
@Don't pass around the target in order to define symbols; get it from
the parameters instead.
@
text
@d1440 1
a1440 1
						    false);
@


1.29
log
@Originally from Craig Silverstein, with changes: support using a
version script to force symbols to be local.
@
text
@d1418 2
a1419 2
Versions::finalize(const Target* target, Symbol_table* symtab,
		   unsigned int dynsym_index, std::vector<Symbol*>* syms)
d1435 1
a1435 1
	  Symbol* vsym = symtab->define_as_constant(target, (*p)->name(),
@


1.28
log
@Don't include options.h in fileread.h.  Remove General_options
reference from Output_file class.
@
text
@d1337 1
a1337 1
  
a1346 3

      // FIXME: When we support version scripts, we will need to
      // check whether this symbol should be forced local.
@


1.27
log
@From Andrew Chatham and Craig Silverstein: Add support for version
scripts.
@
text
@d30 2
@


1.26
log
@Reduce the number of system calls.  Use readv instead of pread.  Do
better handling of cached views.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
d1230 40
d1308 1
a1308 1

d1335 1
a1335 1

a1360 7
      // If this is the first version we are defining, first define
      // the base version.  FIXME: Should use soname here when
      // creating a shared object.
      Verdef* vdbase = new Verdef(parameters->output_file_name(), true, false,
				  true);
      this->defs_.push_back(vdbase);

d1363 2
a1364 1
      Verdef* vd = new Verdef(version, false, false, false);
d1536 1
a1536 1
      else
d1538 4
d1543 1
a1543 1
					     version_index);
@


1.25
log
@From Cary Coutant: Fix handling of versioned symbols, add some tests.
@
text
@d338 1
a338 1
						true);
d670 4
@


1.24
log
@Avoid some warnings which showed up in 64-bit mode.
@
text
@d1299 1
@


1.23
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d467 1
a467 1
      const unsigned int vd_ndx = verdef.get_vd_ndx();
d475 1
a475 1
      const unsigned int vd_cnt = verdef.get_vd_cnt();
d478 2
a479 1
	  this->error(_("verdef vd_cnt field too small: %u"), vd_cnt);
d483 1
a483 1
      const unsigned int vd_aux = verdef.get_vd_aux();
d486 2
a487 1
	  this->error(_("verdef vd_aux field out of range: %u"), vd_aux);
d494 1
a494 1
      const unsigned int vda_name = verdaux.get_vda_name();
d497 2
a498 1
	  this->error(_("verdaux vda_name field out of range: %u"), vda_name);
d504 1
a504 1
      const unsigned int vd_next = verdef.get_vd_next();
d507 2
a508 1
	  this->error(_("verdef vd_next field out of range: %u"), vd_next);
d546 1
a546 1
      const unsigned int vn_aux = verneed.get_vn_aux();
d550 2
a551 1
	  this->error(_("verneed vn_aux field out of range: %u"), vn_aux);
d565 1
a565 1
			  vna_name);
d572 1
a572 1
	  const unsigned int vna_next = vernaux.get_vna_next();
d576 1
a576 1
			  vna_next);
d583 1
a583 1
      const unsigned int vn_next = verneed.get_vn_next();
d586 2
a587 1
	  this->error(_("verneed vn_next field out of range: %u"), vn_next);
@


1.22
log
@From Craig Silverstein: Add support for --demangle.
@
text
@d165 1
a165 1
    off_t* view_size,
d186 1
a186 1
  *view_size = shdr.get_sh_size();
d316 2
a317 1
      sd->symbols_size = dynsymshdr.get_sh_size();
d339 2
a340 1
      sd->symbol_names_size = strtabshdr.get_sh_size();
d449 1
a449 1
  off_t names_size = sd->symbol_names_size;
d452 1
a452 1
  off_t verdef_size = sd->verdef_size;
d524 1
a524 1
  off_t names_size = sd->symbol_names_size;
d527 1
a527 1
  const off_t verneed_size = sd->verneed_size;
d626 1
a626 1
  if (static_cast<off_t>(symcount * sym_size) != sd->symbols_size)
@


1.21
log
@Warn about undefined references in shared libraries if we have seen
all the DT_NEEDED entries for that library.
@
text
@d1304 1
a1304 1
		     sym->name(), version);
@


1.20
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d42 3
a44 1
  : Object(name, input_file, true, offset)
a64 8
// Return the string to use in a DT_NEEDED entry.

const char*
Dynobj::soname() const
{
  return this->soname_.c_str();
}

d190 6
a195 5
// Set the soname field if this shared object has a DT_SONAME tag.
// PSHDRS points to the section headers.  DYNAMIC_SHNDX is the section
// index of the SHT_DYNAMIC section.  STRTAB_SHNDX, STRTAB, and
// STRTAB_SIZE are the section index and contents of a string table
// which may be the one associated with the SHT_DYNAMIC section.
d199 5
a203 5
Sized_dynobj<size, big_endian>::set_soname(const unsigned char* pshdrs,
					   unsigned int dynamic_shndx,
					   unsigned int strtab_shndx,
					   const unsigned char* strtabu,
					   off_t strtab_size)
d234 2
d242 1
a242 1
      if (dyn.get_d_tag() == elfcpp::DT_SONAME)
d244 9
a252 3
	  off_t val = dyn.get_d_val();
	  if (val >= strtab_size)
	    {
d254 18
a271 4
			 static_cast<long long>(val),
			 static_cast<long long>(strtab_size));
	      return;
	    }
d273 2
a274 3
	  const char* strtab = reinterpret_cast<const char*>(strtabu);
	  this->set_soname_string(strtab + val);
	  return;
a275 3

      if (dyn.get_d_tag() == elfcpp::DT_NULL)
	return;
d362 3
a364 3
  // has a DT_SONAME tag.  This doesn't really have anything to do
  // with reading the symbols, but this is a convenient place to do
  // it.
d366 5
a370 5
    this->set_soname(pshdrs, dynamic_shndx, strtab_shndx,
		     (sd->symbol_names == NULL
		      ? NULL
		      : sd->symbol_names->data()),
		     sd->symbol_names_size);
@


1.19
log
@From Craig Silverstein: Handle a .so file in a .a file.
@
text
@d291 1
d610 1
@


1.18
log
@Add support for PT_GNU_STACK.
@
text
@d38 25
d68 1
a68 3
  if (!this->soname_.empty())
    return this->soname_.c_str();
  return this->input_file()->found_name().c_str();
@


1.17
log
@Fix versions of copied symbols.
@
text
@d1213 1
a1213 2
Versions::record_version(const General_options* options,
			 const Symbol_table* symtab,
d1225 1
a1225 1
        this->add_def(options, sym, version, version_key);
d1238 2
a1239 2
Versions::add_def(const General_options* options, const Symbol* sym,
		  const char* version, Stringpool::Key version_key)
d1273 1
a1273 1
      Verdef* vdbase = new Verdef(options->output_file_name(), true, false,
@


1.16
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d1193 16
d1214 1
d1223 1
a1223 1
  if (!sym->is_from_dynobj())
d1231 1
a1231 5

      Object* object = sym->object();
      gold_assert(object->is_dynamic());
      Dynobj* dynobj = static_cast<Dynobj*>(object);

d1391 2
a1392 1
Versions::version_index(const Stringpool* dynpool, const Symbol* sym) const
d1399 1
a1399 1
  if (!sym->is_from_dynobj())
d1407 1
a1407 3
      Object* object = sym->object();
      gold_assert(object->is_dynamic());
      Dynobj* dynobj = static_cast<Dynobj*>(object);
d1427 2
a1428 1
Versions::symbol_section_contents(const Stringpool* dynpool,
d1453 1
a1453 1
	version_index = this->version_index(dynpool, *p);
d1577 1
d1590 1
d1603 1
d1616 1
@


1.15
log
@Add an option for Stringpools to not copy strings.
@
text
@d128 2
a129 7
	{
	  fprintf(stderr,
		  _("%s: %s: unexpected duplicate type %u section: %u, %u\n"),
		  program_name, this->name().c_str(), shdr.get_sh_type(),
		  *pi, i);
	  gold_exit(false);
	}
d164 2
a165 7
    {
      fprintf(stderr,
	      _("%s: %s: unexpected link in section %u header: %u != %u\n"),
	      program_name, this->name().c_str(), shndx,
	      shdr.get_sh_link(), link);
      gold_exit(false);
    }
d199 3
a201 5
	  fprintf(stderr,
		  _("%s: %s: DYNAMIC section %u link out of range: %u\n"),
		  program_name, this->name().c_str(),
		  dynamic_shndx, link);
	  gold_exit(false);
d207 3
a209 5
	  fprintf(stderr,
		  _("%s: %s: DYNAMIC section %u link %u is not a strtab\n"),
		  program_name, this->name().c_str(),
		  dynamic_shndx, link);
	  gold_exit(false);
d227 4
a230 7
	      fprintf(stderr,
		      _("%s: %s: DT_SONAME value out of range: "
			"%lld >= %lld\n"),
		      program_name, this->name().c_str(),
		      static_cast<long long>(val),
		      static_cast<long long>(strtab_size));
	      gold_exit(false);
d242 1
a242 3
  fprintf(stderr, _("%s: %s: missing DT_NULL in dynamic segment\n"),
	  program_name, this->name().c_str());
  gold_exit(false);
d266 6
a271 8
  if (dynsym_shndx == -1U)
    {
      sd->symbols = NULL;
      sd->symbols_size = 0;
      sd->symbol_names = NULL;
      sd->symbol_names_size = 0;
    }
  else
d285 3
a287 4
	  fprintf(stderr,
		  _("%s: %s: invalid dynamic symbol table name index: %u\n"),
		  program_name, this->name().c_str(), strtab_shndx);
	  gold_exit(false);
d292 4
a295 6
	  fprintf(stderr,
		  _("%s: %s: dynamic symbol table name section "
		    "has wrong type: %u\n"),
		  program_name, this->name().c_str(),
		  static_cast<unsigned int>(strtabshdr.get_sh_type()));
	  gold_exit(false);
d365 3
a367 5
	  fprintf(stderr,
		  _("%s: %s: bad section name offset for section %u: %lu\n"),
		  program_name, this->name().c_str(), i,
		  static_cast<unsigned long>(shdr.get_sh_name()));
	  gold_exit(false);
d394 1
a394 5
    {
      fprintf(stderr, _("%s: %s: duplicate definition for version %u\n"),
	      program_name, this->name().c_str(), ndx);
      gold_exit(false);
    }
d423 3
a425 3
	  fprintf(stderr, _("%s: %s: unexpected verdef version %u\n"),
		  program_name, this->name().c_str(), verdef.get_vd_version());
	  gold_exit(false);
d439 2
a440 3
	  fprintf(stderr, _("%s: %s: verdef vd_cnt field too small: %u\n"),
		  program_name, this->name().c_str(), vd_cnt);
	  gold_exit(false);
d446 2
a447 4
	  fprintf(stderr,
		  _("%s: %s: verdef vd_aux field out of range: %u\n"),
		  program_name, this->name().c_str(), vd_aux);
	  gold_exit(false);
d456 2
a457 4
	  fprintf(stderr,
		  _("%s: %s: verdaux vda_name field out of range: %u\n"),
		  program_name, this->name().c_str(), vda_name);
	  gold_exit(false);
d465 2
a466 4
	  fprintf(stderr,
		  _("%s: %s: verdef vd_next field out of range: %u\n"),
		  program_name, this->name().c_str(), vd_next);
	  gold_exit(false);
d498 3
a500 4
	  fprintf(stderr, _("%s: %s: unexpected verneed version %u\n"),
		  program_name, this->name().c_str(),
		  verneed.get_vn_version());
	  gold_exit(false);
d507 2
a508 4
	  fprintf(stderr,
		  _("%s: %s: verneed vn_aux field out of range: %u\n"),
		  program_name, this->name().c_str(), vn_aux);
	  gold_exit(false);
d520 3
a522 5
	      fprintf(stderr,
		      _("%s: %s: vernaux vna_name field "
			"out of range: %u\n"),
		      program_name, this->name().c_str(), vna_name);
	      gold_exit(false);
d531 3
a533 5
	      fprintf(stderr,
		      _("%s: %s: verneed vna_next field "
			"out of range: %u\n"),
		      program_name, this->name().c_str(), vna_next);
	      gold_exit(false);
d542 2
a543 4
	  fprintf(stderr,
		  _("%s: %s: verneed vn_next field out of range: %u\n"),
		  program_name, this->name().c_str(), vn_next);
	  gold_exit(false);
d588 2
a589 5
      fprintf(stderr,
	      _("%s: %s: size of dynamic symbols is not "
		"multiple of symbol size\n"),
	      program_name, this->name().c_str());
      gold_exit(false);
d1253 3
a1255 3
	  fprintf(stderr, _("%s: symbol %s has undefined version %s\n"),
		  program_name, sym->name(), version);
	  gold_exit(false);
@


1.14
log
@Fix soname for library found in search path.
@
text
@d1253 1
a1253 1
  const char* version = dynpool->add(sym->version(), &version_key);
d1329 1
a1329 1
  filename = dynpool->add(filename, &filename_key);
@


1.13
log
@From Craig Silverstein: avoid some signed/unsigned warnings from gcc 4.2.
@
text
@d45 1
a45 1
  return this->name().c_str();
@


1.12
log
@Put size and endianness in parameters.
@
text
@d632 1
a632 1
  if (symcount * sym_size != sd->symbols_size)
@


1.11
log
@Add cache parameter to get_view.  Discard uncached views on unlock.
Fix bug this exposed in archive armap symbol name handling.
@
text
@d743 1
a743 2
Dynobj::create_elf_hash_table(const Target* target,
			      const std::vector<Symbol*>& dynsyms,
d776 9
a784 2
  if (target->is_big_endian())
    Dynobj::sized_create_elf_hash_table<true>(bucket, chain, phash, hashlen);
d786 8
a793 1
    Dynobj::sized_create_elf_hash_table<false>(bucket, chain, phash, hashlen);
d856 1
a856 2
Dynobj::create_gnu_hash_table(const Target* target,
			      const std::vector<Symbol*>& dynsyms,
d905 2
a906 2
  int size = target->get_size();
  bool big_endian = target->is_big_endian();
d910 11
a920 5
	Dynobj::sized_create_gnu_hash_table<32, true>(hashed_dynsyms,
						      dynsym_hashvals,
						      unhashed_dynsym_index,
						      pphash,
						      phashlen);
d922 11
a932 5
	Dynobj::sized_create_gnu_hash_table<32, false>(hashed_dynsyms,
						       dynsym_hashvals,
						       unhashed_dynsym_index,
						       pphash,
						       phashlen);
d937 11
a947 5
	Dynobj::sized_create_gnu_hash_table<64, true>(hashed_dynsyms,
						      dynsym_hashvals,
						      unhashed_dynsym_index,
						      pphash,
						      phashlen);
d949 11
a959 5
	Dynobj::sized_create_gnu_hash_table<64, false>(hashed_dynsyms,
						       dynsym_hashvals,
						       unhashed_dynsym_index,
						       pphash,
						       phashlen);
@


1.10
log
@Add licensing text to every source file.
@
text
@d177 2
a178 1
  *view = this->get_lasting_view(shdr.get_sh_offset(), shdr.get_sh_size());
d202 1
a202 1
						 dynamic_size);
d227 1
a227 1
      strtabu = this->get_view(strtabshdr.get_sh_offset(), strtab_size);
d299 1
a299 1
					   dynsymshdr.get_sh_size());
d323 2
a324 1
						strtabshdr.get_sh_size());
@


1.9
log
@Add global parameters.
@
text
@d3 20
@


1.8
log
@Don't try to find version definition index when creating an executable.
@
text
@d9 1
d344 1
a344 2
Sized_dynobj<size, big_endian>::do_layout(const General_options&,
					  Symbol_table* symtab,
d1199 1
a1199 1
      if (options->is_shared())
d1242 1
a1242 1
      if (options->is_shared())
d1369 1
a1369 2
Versions::version_index(const General_options* options,
                        const Stringpool* dynpool, const Symbol* sym) const
d1378 1
a1378 1
      if (!options->is_shared())
d1406 1
a1406 2
Versions::symbol_section_contents(const General_options* options,
                                  const Stringpool* dynpool,
d1431 1
a1431 1
	version_index = this->version_index(options, dynpool, *p);
a1554 1
    const General_options*,
a1566 1
    const General_options*,
a1578 1
    const General_options*,
a1590 1
    const General_options*,
@


1.7
log
@Only create a version definition for a shared library.  Set the
dynamic symbol index for a version definition when finalizing
versions.
@
text
@d1369 2
a1370 1
Versions::version_index(const Stringpool* dynpool, const Symbol* sym) const
d1378 5
a1382 1
    k = Key(version_key, 0);
d1407 2
a1408 1
Versions::symbol_section_contents(const Stringpool* dynpool,
d1433 1
a1433 1
	version_index = this->version_index(dynpool, *p);
d1557 1
d1570 1
d1583 1
d1596 1
@


1.6
log
@Add support for --enable-target to control which template
specializations we generate.
@
text
@d1198 4
a1201 1
    this->add_def(options, sym, version, version_key);
d1337 1
@


1.5
log
@Don't emit symbols seen only in dynamic object, don't read duplicate
dynamic object.
@
text
@d1523 1
d1526 1
d1528 1
d1531 1
d1533 1
d1536 1
d1538 1
d1541 1
d1543 1
d1553 1
d1555 1
d1565 1
d1567 1
d1577 1
d1579 1
d1589 1
d1591 1
d1600 1
d1602 1
d1611 1
d1613 1
d1622 1
d1624 1
d1633 1
d1635 1
d1644 1
d1646 1
d1655 1
d1657 1
d1666 1
d1668 1
d1677 1
@


1.4
log
@gcc 3.2.2 and 4.1.0 portability hacks.
@
text
@d1327 6
a1332 6
	  Symbol* vsym =symtab->define_as_constant(target, (*p)->name(),
						   (*p)->name(), 0, 0,
						   elfcpp::STT_OBJECT,
						   elfcpp::STB_GLOBAL,
						   elfcpp::STV_DEFAULT, 0,
						   false);
@


1.3
log
@Generate version information.
@
text
@d1053 2
a1054 1
Verdef::write(const Stringpool* dynpool, bool is_last, unsigned char* pb) const
d1133 1
a1133 1
	       unsigned char* pb) const
d1371 1
a1371 1
  Version_table::const_iterator p;
d1373 1
a1373 4
    {
      Key k(version_key, 0);
      p = this->version_table_.find(k);
    }
d1384 1
a1384 2
      Key k(version_key, filename_key);
      p = this->version_table_.find(k);
d1387 1
d1402 2
a1403 1
				  unsigned int* psize) const
d1439 2
a1440 1
			       unsigned int* pentries) const
d1465 3
a1467 3
    pb = (*p)->write<size, big_endian>(dynpool,
				       i + 1 >= this->defs_.size(),
				       pb);
d1483 2
a1484 1
				unsigned int *pentries) const
d1509 3
a1511 3
    pb = (*p)->write<size, big_endian>(dynpool,
				       i + 1 >= this->needs_.size(),
				       pb);
d1537 7
a1543 5
Versions::symbol_section_contents<32, false>(const Stringpool*,
					     unsigned int,
					     const std::vector<Symbol*>&,
					     unsigned char**,
					     unsigned int*) const;
d1547 7
a1553 5
Versions::symbol_section_contents<32, true>(const Stringpool*,
					    unsigned int,
					    const std::vector<Symbol*>&,
					    unsigned char**,
					    unsigned int*) const;
d1557 7
a1563 5
Versions::symbol_section_contents<64, false>(const Stringpool*,
					     unsigned int,
					     const std::vector<Symbol*>&,
					     unsigned char**,
					     unsigned int*) const;
d1567 7
a1573 5
Versions::symbol_section_contents<64, true>(const Stringpool*,
					    unsigned int,
					    const std::vector<Symbol*>&,
					    unsigned char**,
					    unsigned int*) const;
d1577 6
a1582 4
Versions::def_section_contents<32, false>(const Stringpool*,
					  unsigned char**,
					  unsigned int*,
					  unsigned int*) const;
d1586 6
a1591 4
Versions::def_section_contents<32, true>(const Stringpool*,
					 unsigned char**,
					 unsigned int*,
					 unsigned int*) const;
d1595 6
a1600 4
Versions::def_section_contents<64, false>(const Stringpool*,
					  unsigned char**,
					  unsigned int*,
					  unsigned int*) const;
d1604 6
a1609 4
Versions::def_section_contents<64, true>(const Stringpool*,
					 unsigned char**,
					 unsigned int*,
					 unsigned int*) const;
d1613 6
a1618 4
Versions::need_section_contents<32, false>(const Stringpool*,
					   unsigned char**,
					   unsigned int*,
					   unsigned int*) const;
d1622 6
a1627 4
Versions::need_section_contents<32, true>(const Stringpool*,
					  unsigned char**,
					  unsigned int*,
					  unsigned int*) const;
d1631 6
a1636 4
Versions::need_section_contents<64, false>(const Stringpool*,
					   unsigned char**,
					   unsigned int*,
					   unsigned int*) const;
d1640 6
a1645 4
Versions::need_section_contents<64, true>(const Stringpool*,
					  unsigned char**,
					  unsigned int*,
					  unsigned int*) const;
@


1.2
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d395 2
a396 1
  gold_assert(ndx < version_map->size());
d406 1
a406 1
// Create a vector mapping version numbers to version strings.
d410 1
a410 1
Sized_dynobj<size, big_endian>::make_version_map(
d414 1
a414 1
  if (sd->verdef == NULL && sd->verneed == NULL)
d417 6
a422 2
  // First find the largest version index.
  unsigned int maxver = 0;
d424 2
a425 1
  if (sd->verdef != NULL)
d427 1
a427 3
      const unsigned char* pverdef = sd->verdef->data();
      off_t verdef_size = sd->verdef_size;
      const unsigned int count = sd->verdef_info;
d429 1
a429 2
      const unsigned char* p = pverdef;
      for (unsigned int i = 0; i < count; ++i)
d431 4
a434 1
	  elfcpp::Verdef<size, big_endian> verdef(p);
d436 1
a436 1
	  const unsigned int vd_ndx = verdef.get_vd_ndx();
d438 2
a439 2
	  // The GNU linker clears the VERSYM_HIDDEN bit.  I'm not
	  // sure why.
d441 10
a450 2
	  if (vd_ndx > maxver)
	    maxver = vd_ndx;
d452 7
a458 10
	  const unsigned int vd_next = verdef.get_vd_next();
	  if ((p - pverdef) + vd_next >= verdef_size)
	    {
	      fprintf(stderr,
		      _("%s: %s: verdef vd_next field out of range: %u\n"),
		      program_name, this->name().c_str(), vd_next);
	      gold_exit(false);
	    }

	  p += vd_next;
a459 1
    }
d461 2
a462 5
  if (sd->verneed != NULL)
    {
      const unsigned char* pverneed = sd->verneed->data();
      off_t verneed_size = sd->verneed_size;
      const unsigned int count = sd->verneed_info;
d464 2
a465 2
      const unsigned char* p = pverneed;
      for (unsigned int i = 0; i < count; ++i)
d467 5
a471 10
	  elfcpp::Verneed<size, big_endian> verneed(p);

	  const unsigned int vn_aux = verneed.get_vn_aux();
	  if ((p - pverneed) + vn_aux >= verneed_size)
	    {
	      fprintf(stderr,
		      _("%s: %s: verneed vn_aux field out of range: %u\n"),
		      program_name, this->name().c_str(), vn_aux);
	      gold_exit(false);
	    }
d473 1
a473 5
	  const unsigned int vn_cnt = verneed.get_vn_cnt();
	  const unsigned char* pvna = p + vn_aux;
	  for (unsigned int j = 0; j < vn_cnt; ++j)
	    {
	      elfcpp::Vernaux<size, big_endian> vernaux(pvna);
d475 8
a482 25
	      const unsigned int vna_other = vernaux.get_vna_other();
	      if (vna_other > maxver)
		maxver = vna_other;

	      const unsigned int vna_next = vernaux.get_vna_next();
	      if ((pvna - pverneed) + vna_next >= verneed_size)
		{
		  fprintf(stderr,
			  _("%s: %s: verneed vna_next field "
			    "out of range: %u\n"),
			  program_name, this->name().c_str(), vna_next);
		  gold_exit(false);
		}

	      pvna += vna_next;
	    }

	  const unsigned int vn_next = verneed.get_vn_next();
	  if ((p - pverneed) + vn_next >= verneed_size)
	    {
	      fprintf(stderr,
		      _("%s: %s: verneed vn_next field out of range: %u\n"),
		      program_name, this->name().c_str(), vn_next);
	      gold_exit(false);
	    }
d484 1
a484 2
	  p += vn_next;
	}
d486 1
d488 1
a488 1
  // Now MAXVER is the largest version index we have seen.
d490 8
a497 1
  version_map->resize(maxver + 1);
d502 6
a507 1
  if (sd->verdef != NULL)
d509 1
a509 3
      const unsigned char* pverdef = sd->verdef->data();
      off_t verdef_size = sd->verdef_size;
      const unsigned int count = sd->verdef_info;
d511 1
a511 2
      const unsigned char* p = pverdef;
      for (unsigned int i = 0; i < count; ++i)
d513 5
a517 1
	  elfcpp::Verdef<size, big_endian> verdef(p);
d519 1
a519 7
	  const unsigned int vd_cnt = verdef.get_vd_cnt();
	  if (vd_cnt < 1)
	    {
	      fprintf(stderr, _("%s: %s: verdef vd_cnt field too small: %u\n"),
		      program_name, this->name().c_str(), vd_cnt);
	      gold_exit(false);
	    }
d521 7
a527 8
	  const unsigned int vd_aux = verdef.get_vd_aux();
	  if ((p - pverdef) + vd_aux >= verdef_size)
	    {
	      fprintf(stderr,
		      _("%s: %s: verdef vd_aux field out of range: %u\n"),
		      program_name, this->name().c_str(), vd_aux);
	      gold_exit(false);
	    }
d529 5
a533 2
	  const unsigned char* pvda = p + vd_aux;
	  elfcpp::Verdaux<size, big_endian> verdaux(pvda);
d535 2
a536 2
	  const unsigned int vda_name = verdaux.get_vda_name();
	  if (vda_name >= names_size)
d539 3
a541 2
		      _("%s: %s: verdaux vda_name field out of range: %u\n"),
		      program_name, this->name().c_str(), vda_name);
d545 2
a546 2
	  this->set_version_map(version_map, verdef.get_vd_ndx(),
				names + vda_name);
d548 2
a549 2
	  const unsigned int vd_next = verdef.get_vd_next();
	  if ((p - pverdef) + vd_next >= verdef_size)
d552 3
a554 2
		      _("%s: %s: verdef vd_next field out of range: %u\n"),
		      program_name, this->name().c_str(), vd_next);
d558 1
a558 1
	  p += vd_next;
a559 6
    }

  if (sd->verneed != NULL)
    {
      const unsigned char* pverneed = sd->verneed->data();
      const unsigned int count = sd->verneed_info;
d561 2
a562 2
      const unsigned char* p = pverneed;
      for (unsigned int i = 0; i < count; ++i)
d564 5
a568 1
	  elfcpp::Verneed<size, big_endian> verneed(p);
d570 3
a572 6
	  const unsigned int vn_aux = verneed.get_vn_aux();
	  const unsigned int vn_cnt = verneed.get_vn_cnt();
	  const unsigned char* pvna = p + vn_aux;
	  for (unsigned int j = 0; j < vn_cnt; ++j)
	    {
	      elfcpp::Vernaux<size, big_endian> vernaux(pvna);
d574 1
a574 9
	      const unsigned int vna_name = vernaux.get_vna_name();
	      if (vna_name >= names_size)
		{
		  fprintf(stderr,
			  _("%s: %s: vernaux vna_name field "
			    "out of range: %u\n"),
			  program_name, this->name().c_str(), vna_name);
		  gold_exit(false);
		}
d576 8
a583 2
	      this->set_version_map(version_map, vernaux.get_vna_other(),
				    names + vna_name);
d585 3
a587 2
	      pvna += vernaux.get_vna_next();
	    }
d589 2
a590 3
	  p += verneed.get_vn_next();
	}
    }
d1047 472
d1533 88
@


1.1
log
@More dynamic object support, initial scripting support.
@
text
@d8 1
d15 12
d36 1
a36 2
    elf_file_(this, ehdr),
    soname_()
d145 1
a145 1
  assert(shdr.get_sh_type() == type);
d161 5
a165 5
// Set soname_ if this shared object has a DT_SONAME tag.  PSHDRS
// points to the section headers.  DYNAMIC_SHNDX is the section index
// of the SHT_DYNAMIC section.  STRTAB_SHNDX, STRTAB, and STRTAB_SIZE
// are the section index and contents of a string table which may be
// the one associated with the SHT_DYNAMIC section.
d176 1
a176 1
  assert(dynamicshdr.get_sh_type() == elfcpp::SHT_DYNAMIC);
d229 1
a229 1
	  this->soname_ = std::string(strtab + val);
d274 1
a274 1
      assert(dynsymshdr.get_sh_type() == elfcpp::SHT_DYNSYM);
d395 1
a395 1
  assert(ndx < version_map->size());
d617 3
a619 2
      assert(sd->symbol_names == NULL);
      assert(sd->versym == NULL && sd->verdef == NULL && sd->verneed == NULL);
d666 394
@

