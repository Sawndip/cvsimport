head	1.100;
access;
symbols
	binutils-2_24-branch:1.97.0.2
	binutils-2_24-branchpoint:1.97
	binutils-2_21_1:1.35
	binutils-2_23_2:1.44.2.1
	binutils-2_23_1:1.44.2.1
	binutils-2_23:1.44
	binutils-2_23-branch:1.44.0.2
	binutils-2_23-branchpoint:1.44
	binutils-2_22_branch:1.39.0.4
	binutils-2_22:1.39
	binutils-2_22-branch:1.39.0.2
	binutils-2_22-branchpoint:1.39
	binutils-2_21:1.35
	binutils-2_21-branch:1.35.0.2
	binutils-2_21-branchpoint:1.35
	binutils-2_20_1:1.13.4.3
	binutils-2_20:1.13.4.1
	binutils-arc-20081103-branch:1.7.0.4
	binutils-arc-20081103-branchpoint:1.7
	binutils-2_20-branch:1.13.0.4
	binutils-2_20-branchpoint:1.13
	dje-cgen-play1-branch:1.13.0.2
	dje-cgen-play1-branchpoint:1.13
	arc-20081103-branch:1.7.0.2
	arc-20081103-branchpoint:1.7
	binutils-2_19_1:1.6
	binutils-2_19:1.6
	binutils-2_19-branch:1.6.0.2
	binutils-2_19-branchpoint:1.6
	binutils_latest_snapshot:1.100;
locks; strict;
comment	@// @;


1.100
date	2013.10.14.02.53.01;	author amodra;	state Exp;
branches;
next	1.99;

1.99
date	2013.10.11.23.06.08;	author roland;	state Exp;
branches;
next	1.98;

1.98
date	2013.10.11.21.11.49;	author roland;	state Exp;
branches;
next	1.97;

1.97
date	2013.07.31.18.47.50;	author ccoutant;	state Exp;
branches
	1.97.2.1;
next	1.96;

1.96
date	2013.07.30.21.26.53;	author ccoutant;	state Exp;
branches;
next	1.95;

1.95
date	2013.07.11.21.30.56;	author ccoutant;	state Exp;
branches;
next	1.94;

1.94
date	2013.07.03.02.22.35;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2013.06.27.23.20.35;	author ccoutant;	state Exp;
branches;
next	1.92;

1.92
date	2013.06.27.03.11.22;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2013.04.27.00.53.16;	author ian;	state Exp;
branches;
next	1.90;

1.90
date	2013.04.13.10.12.30;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2013.04.11.01.28.27;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2013.03.15.08.40.49;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2013.03.12.22.46.19;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2013.03.10.23.08.18;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2013.03.06.12.28.47;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2013.02.27.23.11.56;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2013.02.15.12.59.15;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2013.01.17.23.29.14;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2013.01.15.06.13.25;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2012.12.12.08.09.41;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2012.12.12.03.41.40;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2012.12.10.11.45.18;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2012.12.10.11.30.57;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2012.12.07.04.23.36;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2012.12.07.00.03.18;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2012.12.06.03.13.17;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2012.12.04.03.13.31;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2012.12.03.05.30.59;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2012.11.30.05.01.20;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2012.11.30.04.50.00;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2012.11.30.04.47.08;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2012.11.05.03.29.58;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2012.11.01.23.27.00;	author roland;	state Exp;
branches;
next	1.66;

1.66
date	2012.10.18.04.18.18;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2012.10.17.14.33.41;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2012.10.16.00.23.00;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2012.10.12.09.44.11;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2012.10.12.09.39.19;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2012.10.05.08.18.07;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2012.09.29.10.29.05;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2012.09.25.00.59.25;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2012.09.12.22.43.54;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2012.09.10.23.05.54;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2012.09.09.03.43.51;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2012.09.05.11.27.14;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2012.09.05.02.54.26;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2012.09.05.00.34.20;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2012.09.04.08.04.31;	author schwab;	state Exp;
branches;
next	1.51;

1.51
date	2012.08.31.01.09.52;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2012.08.18.11.12.50;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2012.08.14.03.39.03;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2012.08.14.02.22.32;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2012.08.14.01.07.01;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2012.08.12.03.07.32;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2012.08.11.04.41.28;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2012.07.11.14.18.40;	author ian;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2012.05.02.21.37.23;	author roland;	state Exp;
branches;
next	1.42;

1.42
date	2012.04.17.01.50.39;	author davem;	state Exp;
branches;
next	1.41;

1.41
date	2011.12.19.21.07.16;	author ian;	state Exp;
branches;
next	1.40;

1.40
date	2011.10.10.17.29.52;	author ccoutant;	state Exp;
branches;
next	1.39;

1.39
date	2011.06.28.23.12.31;	author ian;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2011.06.28.21.15.42;	author ian;	state Exp;
branches;
next	1.37;

1.37
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.36;

1.36
date	2010.11.11.10.43.30;	author rsandifo;	state Exp;
branches;
next	1.35;

1.35
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2010.08.12.22.15.00;	author ccoutant;	state Exp;
branches;
next	1.33;

1.33
date	2010.08.03.14.07.13;	author ian;	state Exp;
branches;
next	1.32;

1.32
date	2010.08.02.20.44.31;	author ian;	state Exp;
branches;
next	1.31;

1.31
date	2010.07.29.18.57.28;	author tmsriram;	state Exp;
branches;
next	1.30;

1.30
date	2010.07.13.12.04.03;	author ian;	state Exp;
branches;
next	1.29;

1.29
date	2010.02.13.02.04.20;	author tmsriram;	state Exp;
branches;
next	1.28;

1.28
date	2010.02.09.20.29.44;	author davem;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.07.20.43.35;	author ian;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.30.06.57.17;	author ian;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.29.00.31.48;	author ian;	state Exp;
branches;
next	1.24;

1.24
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2009.12.06.02.49.46;	author dougkwan;	state Exp;
branches;
next	1.21;

1.21
date	2009.12.03.23.13.55;	author dougkwan;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.04.16.35.51;	author ian;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.04.15.56.03;	author ian;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.30.18.49.59;	author dougkwan;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.29.05.16.23;	author ian;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.13.00.39.31;	author tmsriram;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.06.22.58.27;	author ian;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.01.00.58.38;	author dougkwan;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.22.06.51.53;	author ian;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2009.03.27.18.19.09;	author ccoutant;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.24.04.50.32;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.04.06.46.27;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.20.16.12.00;	author schwab;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.16.17.23.37;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.04.22.22.13;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	2008.07.10.23.01.19;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.30.16.36.40;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.18.22.32.37;	author csilvers;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.13.17.15.52;	author dje;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.12.17.02.17;	author dje;	state Exp;
branches;
next	;

1.97.2.1
date	2013.10.11.21.23.43;	author roland;	state Exp;
branches;
next	1.97.2.2;

1.97.2.2
date	2013.10.11.23.06.38;	author roland;	state Exp;
branches;
next	1.97.2.3;

1.97.2.3
date	2013.10.14.02.53.55;	author amodra;	state Exp;
branches;
next	;

1.44.2.1
date	2012.11.07.17.34.23;	author roland;	state Exp;
branches;
next	;

1.39.2.1
date	2011.12.19.21.14.39;	author ian;	state Exp;
branches;
next	;

1.13.4.1
date	2009.10.16.05.51.18;	author ian;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2009.11.04.15.56.34;	author ian;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2009.11.04.16.36.08;	author ian;	state Exp;
branches;
next	;


desc
@@


1.100
log
@	* output.h (Output_data_got::add_constant): Tidy.
	(Output_data_got::add_constant_pair): New function.
	* powerpc.cc (Output_data_got_powerpc): Override all Output_data_got
	methods used so as to first call reserve_ent().
@
text
@// powerpc.cc -- powerpc target support for gold.

// Copyright 2008, 2009, 2010, 2011, 2012, 2013 Free Software Foundation, Inc.
// Written by David S. Miller <davem@@davemloft.net>
//        and David Edelsohn <edelsohn@@gnu.org>

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <set>
#include <algorithm>
#include "elfcpp.h"
#include "dwarf.h"
#include "parameters.h"
#include "reloc.h"
#include "powerpc.h"
#include "object.h"
#include "symtab.h"
#include "layout.h"
#include "output.h"
#include "copy-relocs.h"
#include "target.h"
#include "target-reloc.h"
#include "target-select.h"
#include "tls.h"
#include "errors.h"
#include "gc.h"

namespace
{

using namespace gold;

template<int size, bool big_endian>
class Output_data_plt_powerpc;

template<int size, bool big_endian>
class Output_data_brlt_powerpc;

template<int size, bool big_endian>
class Output_data_got_powerpc;

template<int size, bool big_endian>
class Output_data_glink;

template<int size, bool big_endian>
class Stub_table;

inline bool
is_branch_reloc(unsigned int r_type);

template<int size, bool big_endian>
class Powerpc_relobj : public Sized_relobj_file<size, big_endian>
{
public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  typedef Unordered_set<Section_id, Section_id_hash> Section_refs;
  typedef Unordered_map<Address, Section_refs> Access_from;

  Powerpc_relobj(const std::string& name, Input_file* input_file, off_t offset,
		 const typename elfcpp::Ehdr<size, big_endian>& ehdr)
    : Sized_relobj_file<size, big_endian>(name, input_file, offset, ehdr),
      special_(0), has_small_toc_reloc_(false), opd_valid_(false),
      opd_ent_(), access_from_map_(), has14_(), stub_table_()
  { }

  ~Powerpc_relobj()
  { }

  // The .got2 section shndx.
  unsigned int
  got2_shndx() const
  {
    if (size == 32)
      return this->special_;
    else
      return 0;
  }

  // The .opd section shndx.
  unsigned int
  opd_shndx() const
  {
    if (size == 32)
      return 0;
    else
      return this->special_;
  }

  // Init OPD entry arrays.
  void
  init_opd(size_t opd_size)
  {
    size_t count = this->opd_ent_ndx(opd_size);
    this->opd_ent_.resize(count);
  }

  // Return section and offset of function entry for .opd + R_OFF.
  unsigned int
  get_opd_ent(Address r_off, Address* value = NULL) const
  {
    size_t ndx = this->opd_ent_ndx(r_off);
    gold_assert(ndx < this->opd_ent_.size());
    gold_assert(this->opd_ent_[ndx].shndx != 0);
    if (value != NULL)
      *value = this->opd_ent_[ndx].off;
    return this->opd_ent_[ndx].shndx;
  }

  // Set section and offset of function entry for .opd + R_OFF.
  void
  set_opd_ent(Address r_off, unsigned int shndx, Address value)
  {
    size_t ndx = this->opd_ent_ndx(r_off);
    gold_assert(ndx < this->opd_ent_.size());
    this->opd_ent_[ndx].shndx = shndx;
    this->opd_ent_[ndx].off = value;
  }

  // Return discard flag for .opd + R_OFF.
  bool
  get_opd_discard(Address r_off) const
  {
    size_t ndx = this->opd_ent_ndx(r_off);
    gold_assert(ndx < this->opd_ent_.size());
    return this->opd_ent_[ndx].discard;
  }

  // Set discard flag for .opd + R_OFF.
  void
  set_opd_discard(Address r_off)
  {
    size_t ndx = this->opd_ent_ndx(r_off);
    gold_assert(ndx < this->opd_ent_.size());
    this->opd_ent_[ndx].discard = true;
  }

  bool
  opd_valid() const
  { return this->opd_valid_; }

  void
  set_opd_valid()
  { this->opd_valid_ = true; }

  // Examine .rela.opd to build info about function entry points.
  void
  scan_opd_relocs(size_t reloc_count,
		  const unsigned char* prelocs,
		  const unsigned char* plocal_syms);

  // Perform the Sized_relobj_file method, then set up opd info from
  // .opd relocs.
  void
  do_read_relocs(Read_relocs_data*);

  bool
  do_find_special_sections(Read_symbols_data* sd);

  // Adjust this local symbol value.  Return false if the symbol
  // should be discarded from the output file.
  bool
  do_adjust_local_symbol(Symbol_value<size>* lv) const
  {
    if (size == 64 && this->opd_shndx() != 0)
      {
	bool is_ordinary;
	if (lv->input_shndx(&is_ordinary) != this->opd_shndx())
	  return true;
	if (this->get_opd_discard(lv->input_value()))
	  return false;
      }
    return true;
  }

  Access_from*
  access_from_map()
  { return &this->access_from_map_; }

  // Add a reference from SRC_OBJ, SRC_INDX to this object's .opd
  // section at DST_OFF.
  void
  add_reference(Object* src_obj,
		unsigned int src_indx,
		typename elfcpp::Elf_types<size>::Elf_Addr dst_off)
  {
    Section_id src_id(src_obj, src_indx);
    this->access_from_map_[dst_off].insert(src_id);
  }

  // Add a reference to the code section specified by the .opd entry
  // at DST_OFF
  void
  add_gc_mark(typename elfcpp::Elf_types<size>::Elf_Addr dst_off)
  {
    size_t ndx = this->opd_ent_ndx(dst_off);
    if (ndx >= this->opd_ent_.size())
      this->opd_ent_.resize(ndx + 1);
    this->opd_ent_[ndx].gc_mark = true;
  }

  void
  process_gc_mark(Symbol_table* symtab)
  {
    for (size_t i = 0; i < this->opd_ent_.size(); i++)
      if (this->opd_ent_[i].gc_mark)
	{
	  unsigned int shndx = this->opd_ent_[i].shndx;
	  symtab->gc()->worklist().push(Section_id(this, shndx));
	}
  }

  // Return offset in output GOT section that this object will use
  // as a TOC pointer.  Won't be just a constant with multi-toc support.
  Address
  toc_base_offset() const
  { return 0x8000; }

  void
  set_has_small_toc_reloc()
  { has_small_toc_reloc_ = true; }

  bool
  has_small_toc_reloc() const
  { return has_small_toc_reloc_; }

  void
  set_has_14bit_branch(unsigned int shndx)
  {
    if (shndx >= this->has14_.size())
      this->has14_.resize(shndx + 1);
    this->has14_[shndx] = true;
  }

  bool
  has_14bit_branch(unsigned int shndx) const
  { return shndx < this->has14_.size() && this->has14_[shndx];  }

  void
  set_stub_table(unsigned int shndx, Stub_table<size, big_endian>* stub_table)
  {
    if (shndx >= this->stub_table_.size())
      this->stub_table_.resize(shndx + 1);
    this->stub_table_[shndx] = stub_table;
  }

  Stub_table<size, big_endian>*
  stub_table(unsigned int shndx)
  {
    if (shndx < this->stub_table_.size())
      return this->stub_table_[shndx];
    return NULL;
  }

private:
  struct Opd_ent
  {
    unsigned int shndx;
    bool discard : 1;
    bool gc_mark : 1;
    Address off;
  };

  // Return index into opd_ent_ array for .opd entry at OFF.
  // .opd entries are 24 bytes long, but they can be spaced 16 bytes
  // apart when the language doesn't use the last 8-byte word, the
  // environment pointer.  Thus dividing the entry section offset by
  // 16 will give an index into opd_ent_ that works for either layout
  // of .opd.  (It leaves some elements of the vector unused when .opd
  // entries are spaced 24 bytes apart, but we don't know the spacing
  // until relocations are processed, and in any case it is possible
  // for an object to have some entries spaced 16 bytes apart and
  // others 24 bytes apart.)
  size_t
  opd_ent_ndx(size_t off) const
  { return off >> 4;}

  // For 32-bit the .got2 section shdnx, for 64-bit the .opd section shndx.
  unsigned int special_;

  // For 64-bit, whether this object uses small model relocs to access
  // the toc.
  bool has_small_toc_reloc_;

  // Set at the start of gc_process_relocs, when we know opd_ent_
  // vector is valid.  The flag could be made atomic and set in
  // do_read_relocs with memory_order_release and then tested with
  // memory_order_acquire, potentially resulting in fewer entries in
  // access_from_map_.
  bool opd_valid_;

  // The first 8-byte word of an OPD entry gives the address of the
  // entry point of the function.  Relocatable object files have a
  // relocation on this word.  The following vector records the
  // section and offset specified by these relocations.
  std::vector<Opd_ent> opd_ent_;

  // References made to this object's .opd section when running
  // gc_process_relocs for another object, before the opd_ent_ vector
  // is valid for this object.
  Access_from access_from_map_;

  // Whether input section has a 14-bit branch reloc.
  std::vector<bool> has14_;

  // The stub table to use for a given input section.
  std::vector<Stub_table<size, big_endian>*> stub_table_;
};

template<int size, bool big_endian>
class Powerpc_dynobj : public Sized_dynobj<size, big_endian>
{
public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;

  Powerpc_dynobj(const std::string& name, Input_file* input_file, off_t offset,
		 const typename elfcpp::Ehdr<size, big_endian>& ehdr)
    : Sized_dynobj<size, big_endian>(name, input_file, offset, ehdr),
      opd_shndx_(0), opd_ent_()
  { }

  ~Powerpc_dynobj()
  { }

  // Call Sized_dynobj::do_read_symbols to read the symbols then
  // read .opd from a dynamic object, filling in opd_ent_ vector,
  void
  do_read_symbols(Read_symbols_data*);

  // The .opd section shndx.
  unsigned int
  opd_shndx() const
  {
    return this->opd_shndx_;
  }

  // The .opd section address.
  Address
  opd_address() const
  {
    return this->opd_address_;
  }

  // Init OPD entry arrays.
  void
  init_opd(size_t opd_size)
  {
    size_t count = this->opd_ent_ndx(opd_size);
    this->opd_ent_.resize(count);
  }

  // Return section and offset of function entry for .opd + R_OFF.
  unsigned int
  get_opd_ent(Address r_off, Address* value = NULL) const
  {
    size_t ndx = this->opd_ent_ndx(r_off);
    gold_assert(ndx < this->opd_ent_.size());
    gold_assert(this->opd_ent_[ndx].shndx != 0);
    if (value != NULL)
      *value = this->opd_ent_[ndx].off;
    return this->opd_ent_[ndx].shndx;
  }

  // Set section and offset of function entry for .opd + R_OFF.
  void
  set_opd_ent(Address r_off, unsigned int shndx, Address value)
  {
    size_t ndx = this->opd_ent_ndx(r_off);
    gold_assert(ndx < this->opd_ent_.size());
    this->opd_ent_[ndx].shndx = shndx;
    this->opd_ent_[ndx].off = value;
  }

private:
  // Used to specify extent of executable sections.
  struct Sec_info
  {
    Sec_info(Address start_, Address len_, unsigned int shndx_)
      : start(start_), len(len_), shndx(shndx_)
    { }

    bool
    operator<(const Sec_info& that) const
    { return this->start < that.start; }

    Address start;
    Address len;
    unsigned int shndx;
  };

  struct Opd_ent
  {
    unsigned int shndx;
    Address off;
  };

  // Return index into opd_ent_ array for .opd entry at OFF.
  size_t
  opd_ent_ndx(size_t off) const
  { return off >> 4;}

  // For 64-bit the .opd section shndx and address.
  unsigned int opd_shndx_;
  Address opd_address_;

  // The first 8-byte word of an OPD entry gives the address of the
  // entry point of the function.  Records the section and offset
  // corresponding to the address.  Note that in dynamic objects,
  // offset is *not* relative to the section.
  std::vector<Opd_ent> opd_ent_;
};

template<int size, bool big_endian>
class Target_powerpc : public Sized_target<size, big_endian>
{
 public:
  typedef
    Output_data_reloc<elfcpp::SHT_RELA, true, size, big_endian> Reloc_section;
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  typedef typename elfcpp::Elf_types<size>::Elf_Swxword Signed_address;
  static const Address invalid_address = static_cast<Address>(0) - 1;
  // Offset of tp and dtp pointers from start of TLS block.
  static const Address tp_offset = 0x7000;
  static const Address dtp_offset = 0x8000;

  Target_powerpc()
    : Sized_target<size, big_endian>(&powerpc_info),
      got_(NULL), plt_(NULL), iplt_(NULL), brlt_section_(NULL),
      glink_(NULL), rela_dyn_(NULL), copy_relocs_(elfcpp::R_POWERPC_COPY),
      tlsld_got_offset_(-1U),
      stub_tables_(), branch_lookup_table_(), branch_info_(),
      plt_thread_safe_(false)
  {
  }

  // Process the relocations to determine unreferenced sections for
  // garbage collection.
  void
  gc_process_relocs(Symbol_table* symtab,
		    Layout* layout,
		    Sized_relobj_file<size, big_endian>* object,
		    unsigned int data_shndx,
		    unsigned int sh_type,
		    const unsigned char* prelocs,
		    size_t reloc_count,
		    Output_section* output_section,
		    bool needs_special_offset_handling,
		    size_t local_symbol_count,
		    const unsigned char* plocal_symbols);

  // Scan the relocations to look for symbol adjustments.
  void
  scan_relocs(Symbol_table* symtab,
	      Layout* layout,
	      Sized_relobj_file<size, big_endian>* object,
	      unsigned int data_shndx,
	      unsigned int sh_type,
	      const unsigned char* prelocs,
	      size_t reloc_count,
	      Output_section* output_section,
	      bool needs_special_offset_handling,
	      size_t local_symbol_count,
	      const unsigned char* plocal_symbols);

  // Map input .toc section to output .got section.
  const char*
  do_output_section_name(const Relobj*, const char* name, size_t* plen) const
  {
    if (size == 64 && strcmp(name, ".toc") == 0)
      {
	*plen = 4;
	return ".got";
      }
    return NULL;
  }

  // Provide linker defined save/restore functions.
  void
  define_save_restore_funcs(Layout*, Symbol_table*);

  // No stubs unless a final link.
  bool
  do_may_relax() const
  { return !parameters->options().relocatable(); }

  bool
  do_relax(int, const Input_objects*, Symbol_table*, Layout*, const Task*);

  void
  do_plt_fde_location(const Output_data*, unsigned char*,
		      uint64_t*, off_t*) const;

  // Stash info about branches, for stub generation.
  void
  push_branch(Powerpc_relobj<size, big_endian>* ppc_object,
	      unsigned int data_shndx, Address r_offset,
	      unsigned int r_type, unsigned int r_sym, Address addend)
  {
    Branch_info info(ppc_object, data_shndx, r_offset, r_type, r_sym, addend);
    this->branch_info_.push_back(info);
    if (r_type == elfcpp::R_POWERPC_REL14
	|| r_type == elfcpp::R_POWERPC_REL14_BRTAKEN
	|| r_type == elfcpp::R_POWERPC_REL14_BRNTAKEN)
      ppc_object->set_has_14bit_branch(data_shndx);
  }

  Stub_table<size, big_endian>*
  new_stub_table();

  void
  do_define_standard_symbols(Symbol_table*, Layout*);

  // Finalize the sections.
  void
  do_finalize_sections(Layout*, const Input_objects*, Symbol_table*);

  // Return the value to use for a dynamic which requires special
  // treatment.
  uint64_t
  do_dynsym_value(const Symbol*) const;

  // Return the PLT address to use for a local symbol.
  uint64_t
  do_plt_address_for_local(const Relobj*, unsigned int) const;

  // Return the PLT address to use for a global symbol.
  uint64_t
  do_plt_address_for_global(const Symbol*) const;

  // Return the offset to use for the GOT_INDX'th got entry which is
  // for a local tls symbol specified by OBJECT, SYMNDX.
  int64_t
  do_tls_offset_for_local(const Relobj* object,
			  unsigned int symndx,
			  unsigned int got_indx) const;

  // Return the offset to use for the GOT_INDX'th got entry which is
  // for global tls symbol GSYM.
  int64_t
  do_tls_offset_for_global(Symbol* gsym, unsigned int got_indx) const;

  void
  do_function_location(Symbol_location*) const;

  bool
  do_can_check_for_function_pointers() const
  { return true; }

  // Relocate a section.
  void
  relocate_section(const Relocate_info<size, big_endian>*,
		   unsigned int sh_type,
		   const unsigned char* prelocs,
		   size_t reloc_count,
		   Output_section* output_section,
		   bool needs_special_offset_handling,
		   unsigned char* view,
		   Address view_address,
		   section_size_type view_size,
		   const Reloc_symbol_changes*);

  // Scan the relocs during a relocatable link.
  void
  scan_relocatable_relocs(Symbol_table* symtab,
			  Layout* layout,
			  Sized_relobj_file<size, big_endian>* object,
			  unsigned int data_shndx,
			  unsigned int sh_type,
			  const unsigned char* prelocs,
			  size_t reloc_count,
			  Output_section* output_section,
			  bool needs_special_offset_handling,
			  size_t local_symbol_count,
			  const unsigned char* plocal_symbols,
			  Relocatable_relocs*);

  // Emit relocations for a section.
  void
  relocate_relocs(const Relocate_info<size, big_endian>*,
		  unsigned int sh_type,
		  const unsigned char* prelocs,
		  size_t reloc_count,
		  Output_section* output_section,
		  typename elfcpp::Elf_types<size>::Elf_Off
                    offset_in_output_section,
		  const Relocatable_relocs*,
		  unsigned char*,
		  Address view_address,
		  section_size_type,
		  unsigned char* reloc_view,
		  section_size_type reloc_view_size);

  // Return whether SYM is defined by the ABI.
  bool
  do_is_defined_by_abi(const Symbol* sym) const
  {
    return strcmp(sym->name(), "__tls_get_addr") == 0;
  }

  // Return the size of the GOT section.
  section_size_type
  got_size() const
  {
    gold_assert(this->got_ != NULL);
    return this->got_->data_size();
  }

  // Get the PLT section.
  const Output_data_plt_powerpc<size, big_endian>*
  plt_section() const
  {
    gold_assert(this->plt_ != NULL);
    return this->plt_;
  }

  // Get the IPLT section.
  const Output_data_plt_powerpc<size, big_endian>*
  iplt_section() const
  {
    gold_assert(this->iplt_ != NULL);
    return this->iplt_;
  }

  // Get the .glink section.
  const Output_data_glink<size, big_endian>*
  glink_section() const
  {
    gold_assert(this->glink_ != NULL);
    return this->glink_;
  }

  bool has_glink() const
  { return this->glink_ != NULL; }

  // Get the GOT section.
  const Output_data_got_powerpc<size, big_endian>*
  got_section() const
  {
    gold_assert(this->got_ != NULL);
    return this->got_;
  }

  // Get the GOT section, creating it if necessary.
  Output_data_got_powerpc<size, big_endian>*
  got_section(Symbol_table*, Layout*);

  Object*
  do_make_elf_object(const std::string&, Input_file*, off_t,
		     const elfcpp::Ehdr<size, big_endian>&);

  // Return the number of entries in the GOT.
  unsigned int
  got_entry_count() const
  {
    if (this->got_ == NULL)
      return 0;
    return this->got_size() / (size / 8);
  }

  // Return the number of entries in the PLT.
  unsigned int
  plt_entry_count() const;

  // Return the offset of the first non-reserved PLT entry.
  unsigned int
  first_plt_entry_offset() const;

  // Return the size of each PLT entry.
  unsigned int
  plt_entry_size() const;

  // Add any special sections for this symbol to the gc work list.
  // For powerpc64, this adds the code section of a function
  // descriptor.
  void
  do_gc_mark_symbol(Symbol_table* symtab, Symbol* sym) const;

  // Handle target specific gc actions when adding a gc reference from
  // SRC_OBJ, SRC_SHNDX to a location specified by DST_OBJ, DST_SHNDX
  // and DST_OFF.  For powerpc64, this adds a referenc to the code
  // section of a function descriptor.
  void
  do_gc_add_reference(Symbol_table* symtab,
		      Object* src_obj,
		      unsigned int src_shndx,
		      Object* dst_obj,
		      unsigned int dst_shndx,
		      Address dst_off) const;

  typedef std::vector<Stub_table<size, big_endian>*> Stub_tables;
  const Stub_tables&
  stub_tables() const
  { return this->stub_tables_; }

  const Output_data_brlt_powerpc<size, big_endian>*
  brlt_section() const
  { return this->brlt_section_; }

  void
  add_branch_lookup_table(Address to)
  {
    unsigned int off = this->branch_lookup_table_.size() * (size / 8);
    this->branch_lookup_table_.insert(std::make_pair(to, off));
  }

  Address
  find_branch_lookup_table(Address to)
  {
    typename Branch_lookup_table::const_iterator p
      = this->branch_lookup_table_.find(to);
    return p == this->branch_lookup_table_.end() ? invalid_address : p->second;
  }

  void
  write_branch_lookup_table(unsigned char *oview)
  {
    for (typename Branch_lookup_table::const_iterator p
	   = this->branch_lookup_table_.begin();
	 p != this->branch_lookup_table_.end();
	 ++p)
      {
	elfcpp::Swap<size, big_endian>::writeval(oview + p->second, p->first);
      }
  }

  bool
  plt_thread_safe() const
  { return this->plt_thread_safe_; }

 private:

  class Track_tls
  {
  public:
    enum Tls_get_addr
    {
      NOT_EXPECTED = 0,
      EXPECTED = 1,
      SKIP = 2,
      NORMAL = 3
    };

    Track_tls()
      : tls_get_addr_(NOT_EXPECTED),
	relinfo_(NULL), relnum_(0), r_offset_(0)
    { }

    ~Track_tls()
    {
      if (this->tls_get_addr_ != NOT_EXPECTED)
	this->missing();
    }

    void
    missing(void)
    {
      if (this->relinfo_ != NULL)
	gold_error_at_location(this->relinfo_, this->relnum_, this->r_offset_,
			       _("missing expected __tls_get_addr call"));
    }

    void
    expect_tls_get_addr_call(
	const Relocate_info<size, big_endian>* relinfo,
	size_t relnum,
	Address r_offset)
    {
      this->tls_get_addr_ = EXPECTED;
      this->relinfo_ = relinfo;
      this->relnum_ = relnum;
      this->r_offset_ = r_offset;
    }

    void
    expect_tls_get_addr_call()
    { this->tls_get_addr_ = EXPECTED; }

    void
    skip_next_tls_get_addr_call()
    {this->tls_get_addr_ = SKIP; }

    Tls_get_addr
    maybe_skip_tls_get_addr_call(unsigned int r_type, const Symbol* gsym)
    {
      bool is_tls_call = ((r_type == elfcpp::R_POWERPC_REL24
			   || r_type == elfcpp::R_PPC_PLTREL24)
			  && gsym != NULL
			  && strcmp(gsym->name(), "__tls_get_addr") == 0);
      Tls_get_addr last_tls = this->tls_get_addr_;
      this->tls_get_addr_ = NOT_EXPECTED;
      if (is_tls_call && last_tls != EXPECTED)
	return last_tls;
      else if (!is_tls_call && last_tls != NOT_EXPECTED)
	{
	  this->missing();
	  return EXPECTED;
	}
      return NORMAL;
    }

  private:
    // What we're up to regarding calls to __tls_get_addr.
    // On powerpc, the branch and link insn making a call to
    // __tls_get_addr is marked with a relocation, R_PPC64_TLSGD,
    // R_PPC64_TLSLD, R_PPC_TLSGD or R_PPC_TLSLD, in addition to the
    // usual R_POWERPC_REL24 or R_PPC_PLTREL25 relocation on a call.
    // The marker relocation always comes first, and has the same
    // symbol as the reloc on the insn setting up the __tls_get_addr
    // argument.  This ties the arg setup insn with the call insn,
    // allowing ld to safely optimize away the call.  We check that
    // every call to __tls_get_addr has a marker relocation, and that
    // every marker relocation is on a call to __tls_get_addr.
    Tls_get_addr tls_get_addr_;
    // Info about the last reloc for error message.
    const Relocate_info<size, big_endian>* relinfo_;
    size_t relnum_;
    Address r_offset_;
  };

  // The class which scans relocations.
  class Scan : protected Track_tls
  {
  public:
    typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;

    Scan()
      : Track_tls(), issued_non_pic_error_(false)
    { }

    static inline int
    get_reference_flags(unsigned int r_type);

    inline void
    local(Symbol_table* symtab, Layout* layout, Target_powerpc* target,
	  Sized_relobj_file<size, big_endian>* object,
	  unsigned int data_shndx,
	  Output_section* output_section,
	  const elfcpp::Rela<size, big_endian>& reloc, unsigned int r_type,
	  const elfcpp::Sym<size, big_endian>& lsym,
	  bool is_discarded);

    inline void
    global(Symbol_table* symtab, Layout* layout, Target_powerpc* target,
	   Sized_relobj_file<size, big_endian>* object,
	   unsigned int data_shndx,
	   Output_section* output_section,
	   const elfcpp::Rela<size, big_endian>& reloc, unsigned int r_type,
	   Symbol* gsym);

    inline bool
    local_reloc_may_be_function_pointer(Symbol_table* , Layout* ,
					Target_powerpc* ,
					Sized_relobj_file<size, big_endian>* ,
					unsigned int ,
					Output_section* ,
					const elfcpp::Rela<size, big_endian>& ,
					unsigned int r_type,
					const elfcpp::Sym<size, big_endian>&)
    {
      // PowerPC64 .opd is not folded, so any identical function text
      // may be folded and we'll still keep function addresses distinct.
      // That means no reloc is of concern here.
      if (size == 64)
	return false;
      // For 32-bit, conservatively assume anything but calls to
      // function code might be taking the address of the function.
      return !is_branch_reloc(r_type);
    }

    inline bool
    global_reloc_may_be_function_pointer(Symbol_table* , Layout* ,
					 Target_powerpc* ,
					 Sized_relobj_file<size, big_endian>* ,
					 unsigned int ,
					 Output_section* ,
					 const elfcpp::Rela<size, big_endian>& ,
					 unsigned int r_type,
					 Symbol*)
    {
      // As above.
      if (size == 64)
	return false;
      return !is_branch_reloc(r_type);
    }

    static bool
    reloc_needs_plt_for_ifunc(Sized_relobj_file<size, big_endian>* object,
			      unsigned int r_type, bool report_err);

  private:
    static void
    unsupported_reloc_local(Sized_relobj_file<size, big_endian>*,
			    unsigned int r_type);

    static void
    unsupported_reloc_global(Sized_relobj_file<size, big_endian>*,
			     unsigned int r_type, Symbol*);

    static void
    generate_tls_call(Symbol_table* symtab, Layout* layout,
		      Target_powerpc* target);

    void
    check_non_pic(Relobj*, unsigned int r_type);

    // Whether we have issued an error about a non-PIC compilation.
    bool issued_non_pic_error_;
  };

  Address
  symval_for_branch(const Symbol_table* symtab, Address value,
		    const Sized_symbol<size>* gsym,
		    Powerpc_relobj<size, big_endian>* object,
		    unsigned int *dest_shndx);

  // The class which implements relocation.
  class Relocate : protected Track_tls
  {
   public:
    // Use 'at' branch hints when true, 'y' when false.
    // FIXME maybe: set this with an option.
    static const bool is_isa_v2 = true;

    Relocate()
      : Track_tls()
    { }

    // Do a relocation.  Return false if the caller should not issue
    // any warnings about this relocation.
    inline bool
    relocate(const Relocate_info<size, big_endian>*, Target_powerpc*,
	     Output_section*, size_t relnum,
	     const elfcpp::Rela<size, big_endian>&,
	     unsigned int r_type, const Sized_symbol<size>*,
	     const Symbol_value<size>*,
	     unsigned char*,
	     typename elfcpp::Elf_types<size>::Elf_Addr,
	     section_size_type);
  };

  class Relocate_comdat_behavior
  {
   public:
    // Decide what the linker should do for relocations that refer to
    // discarded comdat sections.
    inline Comdat_behavior
    get(const char* name)
    {
      gold::Default_comdat_behavior default_behavior;
      Comdat_behavior ret = default_behavior.get(name);
      if (ret == CB_WARNING)
	{
	  if (size == 32
	      && (strcmp(name, ".fixup") == 0
		  || strcmp(name, ".got2") == 0))
	    ret = CB_IGNORE;
	  if (size == 64
	      && (strcmp(name, ".opd") == 0
		  || strcmp(name, ".toc") == 0
		  || strcmp(name, ".toc1") == 0))
	    ret = CB_IGNORE;
	}
      return ret;
    }
  };

  // A class which returns the size required for a relocation type,
  // used while scanning relocs during a relocatable link.
  class Relocatable_size_for_reloc
  {
   public:
    unsigned int
    get_size_for_reloc(unsigned int, Relobj*)
    {
      gold_unreachable();
      return 0;
    }
  };

  // Optimize the TLS relocation type based on what we know about the
  // symbol.  IS_FINAL is true if the final address of this symbol is
  // known at link time.

  tls::Tls_optimization
  optimize_tls_gd(bool is_final)
  {
    // If we are generating a shared library, then we can't do anything
    // in the linker.
    if (parameters->options().shared())
      return tls::TLSOPT_NONE;

    if (!is_final)
      return tls::TLSOPT_TO_IE;
    return tls::TLSOPT_TO_LE;
  }

  tls::Tls_optimization
  optimize_tls_ld()
  {
    if (parameters->options().shared())
      return tls::TLSOPT_NONE;

    return tls::TLSOPT_TO_LE;
  }

  tls::Tls_optimization
  optimize_tls_ie(bool is_final)
  {
    if (!is_final || parameters->options().shared())
      return tls::TLSOPT_NONE;

    return tls::TLSOPT_TO_LE;
  }

  // Create glink.
  void
  make_glink_section(Layout*);

  // Create the PLT section.
  void
  make_plt_section(Symbol_table*, Layout*);

  void
  make_iplt_section(Symbol_table*, Layout*);

  void
  make_brlt_section(Layout*);

  // Create a PLT entry for a global symbol.
  void
  make_plt_entry(Symbol_table*, Layout*, Symbol*);

  // Create a PLT entry for a local IFUNC symbol.
  void
  make_local_ifunc_plt_entry(Symbol_table*, Layout*,
			     Sized_relobj_file<size, big_endian>*,
			     unsigned int);


  // Create a GOT entry for local dynamic __tls_get_addr.
  unsigned int
  tlsld_got_offset(Symbol_table* symtab, Layout* layout,
		   Sized_relobj_file<size, big_endian>* object);

  unsigned int
  tlsld_got_offset() const
  {
    return this->tlsld_got_offset_;
  }

  // Get the dynamic reloc section, creating it if necessary.
  Reloc_section*
  rela_dyn_section(Layout*);

  // Similarly, but for ifunc symbols get the one for ifunc.
  Reloc_section*
  rela_dyn_section(Symbol_table*, Layout*, bool for_ifunc);

  // Copy a relocation against a global symbol.
  void
  copy_reloc(Symbol_table* symtab, Layout* layout,
	     Sized_relobj_file<size, big_endian>* object,
	     unsigned int shndx, Output_section* output_section,
	     Symbol* sym, const elfcpp::Rela<size, big_endian>& reloc)
  {
    this->copy_relocs_.copy_reloc(symtab, layout,
				  symtab->get_sized_symbol<size>(sym),
				  object, shndx, output_section,
				  reloc, this->rela_dyn_section(layout));
  }

  // Look over all the input sections, deciding where to place stubs.
  void
  group_sections(Layout*, const Task*);

  // Sort output sections by address.
  struct Sort_sections
  {
    bool
    operator()(const Output_section* sec1, const Output_section* sec2)
    { return sec1->address() < sec2->address(); }
  };

  class Branch_info
  {
   public:
    Branch_info(Powerpc_relobj<size, big_endian>* ppc_object,
		unsigned int data_shndx,
		Address r_offset,
		unsigned int r_type,
		unsigned int r_sym,
		Address addend)
      : object_(ppc_object), shndx_(data_shndx), offset_(r_offset),
	r_type_(r_type), r_sym_(r_sym), addend_(addend)
    { }

    ~Branch_info()
    { }

    // If this branch needs a plt call stub, or a long branch stub, make one.
    void
    make_stub(Stub_table<size, big_endian>*,
	      Stub_table<size, big_endian>*,
	      Symbol_table*) const;

   private:
    // The branch location..
    Powerpc_relobj<size, big_endian>* object_;
    unsigned int shndx_;
    Address offset_;
    // ..and the branch type and destination.
    unsigned int r_type_;
    unsigned int r_sym_;
    Address addend_;
  };

  // Information about this specific target which we pass to the
  // general Target structure.
  static Target::Target_info powerpc_info;

  // The types of GOT entries needed for this platform.
  // These values are exposed to the ABI in an incremental link.
  // Do not renumber existing values without changing the version
  // number of the .gnu_incremental_inputs section.
  enum Got_type
  {
    GOT_TYPE_STANDARD,
    GOT_TYPE_TLSGD,	// double entry for @@got@@tlsgd
    GOT_TYPE_DTPREL,	// entry for @@got@@dtprel
    GOT_TYPE_TPREL	// entry for @@got@@tprel
  };

  // The GOT section.
  Output_data_got_powerpc<size, big_endian>* got_;
  // The PLT section.  This is a container for a table of addresses,
  // and their relocations.  Each address in the PLT has a dynamic
  // relocation (R_*_JMP_SLOT) and each address will have a
  // corresponding entry in .glink for lazy resolution of the PLT.
  // ppc32 initialises the PLT to point at the .glink entry, while
  // ppc64 leaves this to ld.so.  To make a call via the PLT, the
  // linker adds a stub that loads the PLT entry into ctr then
  // branches to ctr.  There may be more than one stub for each PLT
  // entry.  DT_JMPREL points at the first PLT dynamic relocation and
  // DT_PLTRELSZ gives the total size of PLT dynamic relocations.
  Output_data_plt_powerpc<size, big_endian>* plt_;
  // The IPLT section.  Like plt_, this is a container for a table of
  // addresses and their relocations, specifically for STT_GNU_IFUNC
  // functions that resolve locally (STT_GNU_IFUNC functions that
  // don't resolve locally go in PLT).  Unlike plt_, these have no
  // entry in .glink for lazy resolution, and the relocation section
  // does not have a 1-1 correspondence with IPLT addresses.  In fact,
  // the relocation section may contain relocations against
  // STT_GNU_IFUNC symbols at locations outside of IPLT.  The
  // relocation section will appear at the end of other dynamic
  // relocations, so that ld.so applies these relocations after other
  // dynamic relocations.  In a static executable, the relocation
  // section is emitted and marked with __rela_iplt_start and
  // __rela_iplt_end symbols.
  Output_data_plt_powerpc<size, big_endian>* iplt_;
  // Section holding long branch destinations.
  Output_data_brlt_powerpc<size, big_endian>* brlt_section_;
  // The .glink section.
  Output_data_glink<size, big_endian>* glink_;
  // The dynamic reloc section.
  Reloc_section* rela_dyn_;
  // Relocs saved to avoid a COPY reloc.
  Copy_relocs<elfcpp::SHT_RELA, size, big_endian> copy_relocs_;
  // Offset of the GOT entry for local dynamic __tls_get_addr calls.
  unsigned int tlsld_got_offset_;

  Stub_tables stub_tables_;
  typedef Unordered_map<Address, unsigned int> Branch_lookup_table;
  Branch_lookup_table branch_lookup_table_;

  typedef std::vector<Branch_info> Branches;
  Branches branch_info_;

  bool plt_thread_safe_;
};

template<>
Target::Target_info Target_powerpc<32, true>::powerpc_info =
{
  32,			// size
  true,			// is_big_endian
  elfcpp::EM_PPC,	// machine_code
  false,		// has_make_symbol
  false,		// has_resolve
  false,		// has_code_fill
  true,			// is_default_stack_executable
  false,		// can_icf_inline_merge_sections
  '\0',			// wrap_char
  "/usr/lib/ld.so.1",	// dynamic_linker
  0x10000000,		// default_text_segment_address
  64 * 1024,		// abi_pagesize (overridable by -z max-page-size)
  4 * 1024,		// common_pagesize (overridable by -z common-page-size)
  false,		// isolate_execinstr
  0,			// rosegment_gap
  elfcpp::SHN_UNDEF,	// small_common_shndx
  elfcpp::SHN_UNDEF,	// large_common_shndx
  0,			// small_common_section_flags
  0,			// large_common_section_flags
  NULL,			// attributes_section
  NULL,			// attributes_vendor
  "_start"		// entry_symbol_name
};

template<>
Target::Target_info Target_powerpc<32, false>::powerpc_info =
{
  32,			// size
  false,		// is_big_endian
  elfcpp::EM_PPC,	// machine_code
  false,		// has_make_symbol
  false,		// has_resolve
  false,		// has_code_fill
  true,			// is_default_stack_executable
  false,		// can_icf_inline_merge_sections
  '\0',			// wrap_char
  "/usr/lib/ld.so.1",	// dynamic_linker
  0x10000000,		// default_text_segment_address
  64 * 1024,		// abi_pagesize (overridable by -z max-page-size)
  4 * 1024,		// common_pagesize (overridable by -z common-page-size)
  false,		// isolate_execinstr
  0,			// rosegment_gap
  elfcpp::SHN_UNDEF,	// small_common_shndx
  elfcpp::SHN_UNDEF,	// large_common_shndx
  0,			// small_common_section_flags
  0,			// large_common_section_flags
  NULL,			// attributes_section
  NULL,			// attributes_vendor
  "_start"		// entry_symbol_name
};

template<>
Target::Target_info Target_powerpc<64, true>::powerpc_info =
{
  64,			// size
  true,			// is_big_endian
  elfcpp::EM_PPC64,	// machine_code
  false,		// has_make_symbol
  false,		// has_resolve
  false,		// has_code_fill
  true,			// is_default_stack_executable
  false,		// can_icf_inline_merge_sections
  '\0',			// wrap_char
  "/usr/lib/ld.so.1",	// dynamic_linker
  0x10000000,		// default_text_segment_address
  64 * 1024,		// abi_pagesize (overridable by -z max-page-size)
  4 * 1024,		// common_pagesize (overridable by -z common-page-size)
  false,		// isolate_execinstr
  0,			// rosegment_gap
  elfcpp::SHN_UNDEF,	// small_common_shndx
  elfcpp::SHN_UNDEF,	// large_common_shndx
  0,			// small_common_section_flags
  0,			// large_common_section_flags
  NULL,			// attributes_section
  NULL,			// attributes_vendor
  "_start"		// entry_symbol_name
};

template<>
Target::Target_info Target_powerpc<64, false>::powerpc_info =
{
  64,			// size
  false,		// is_big_endian
  elfcpp::EM_PPC64,	// machine_code
  false,		// has_make_symbol
  false,		// has_resolve
  false,		// has_code_fill
  true,			// is_default_stack_executable
  false,		// can_icf_inline_merge_sections
  '\0',			// wrap_char
  "/usr/lib/ld.so.1",	// dynamic_linker
  0x10000000,		// default_text_segment_address
  64 * 1024,		// abi_pagesize (overridable by -z max-page-size)
  4 * 1024,		// common_pagesize (overridable by -z common-page-size)
  false,		// isolate_execinstr
  0,			// rosegment_gap
  elfcpp::SHN_UNDEF,	// small_common_shndx
  elfcpp::SHN_UNDEF,	// large_common_shndx
  0,			// small_common_section_flags
  0,			// large_common_section_flags
  NULL,			// attributes_section
  NULL,			// attributes_vendor
  "_start"		// entry_symbol_name
};

inline bool
is_branch_reloc(unsigned int r_type)
{
  return (r_type == elfcpp::R_POWERPC_REL24
	  || r_type == elfcpp::R_PPC_PLTREL24
	  || r_type == elfcpp::R_PPC_LOCAL24PC
	  || r_type == elfcpp::R_POWERPC_REL14
	  || r_type == elfcpp::R_POWERPC_REL14_BRTAKEN
	  || r_type == elfcpp::R_POWERPC_REL14_BRNTAKEN
	  || r_type == elfcpp::R_POWERPC_ADDR24
	  || r_type == elfcpp::R_POWERPC_ADDR14
	  || r_type == elfcpp::R_POWERPC_ADDR14_BRTAKEN
	  || r_type == elfcpp::R_POWERPC_ADDR14_BRNTAKEN);
}

// If INSN is an opcode that may be used with an @@tls operand, return
// the transformed insn for TLS optimisation, otherwise return 0.  If
// REG is non-zero only match an insn with RB or RA equal to REG.
uint32_t
at_tls_transform(uint32_t insn, unsigned int reg)
{
  if ((insn & (0x3f << 26)) != 31 << 26)
    return 0;

  unsigned int rtra;
  if (reg == 0 || ((insn >> 11) & 0x1f) == reg)
    rtra = insn & ((1 << 26) - (1 << 16));
  else if (((insn >> 16) & 0x1f) == reg)
    rtra = (insn & (0x1f << 21)) | ((insn & (0x1f << 11)) << 5);
  else
    return 0;

  if ((insn & (0x3ff << 1)) == 266 << 1)
    // add -> addi
    insn = 14 << 26;
  else if ((insn & (0x1f << 1)) == 23 << 1
	   && ((insn & (0x1f << 6)) < 14 << 6
	       || ((insn & (0x1f << 6)) >= 16 << 6
		   && (insn & (0x1f << 6)) < 24 << 6)))
    // load and store indexed -> dform
    insn = (32 | ((insn >> 6) & 0x1f)) << 26;
  else if ((insn & (((0x1a << 5) | 0x1f) << 1)) == 21 << 1)
    // ldx, ldux, stdx, stdux -> ld, ldu, std, stdu
    insn = ((58 | ((insn >> 6) & 4)) << 26) | ((insn >> 6) & 1);
  else if ((insn & (((0x1f << 5) | 0x1f) << 1)) == 341 << 1)
    // lwax -> lwa
    insn = (58 << 26) | 2;
  else
    return 0;
  insn |= rtra;
  return insn;
}

// Modified version of symtab.h class Symbol member
// Given a direct absolute or pc-relative static relocation against
// the global symbol, this function returns whether a dynamic relocation
// is needed.

template<int size>
bool
needs_dynamic_reloc(const Symbol* gsym, int flags)
{
  // No dynamic relocations in a static link!
  if (parameters->doing_static_link())
    return false;

  // A reference to an undefined symbol from an executable should be
  // statically resolved to 0, and does not need a dynamic relocation.
  // This matches gnu ld behavior.
  if (gsym->is_undefined() && !parameters->options().shared())
    return false;

  // A reference to an absolute symbol does not need a dynamic relocation.
  if (gsym->is_absolute())
    return false;

  // An absolute reference within a position-independent output file
  // will need a dynamic relocation.
  if ((flags & Symbol::ABSOLUTE_REF)
      && parameters->options().output_is_position_independent())
    return true;

  // A function call that can branch to a local PLT entry does not need
  // a dynamic relocation.
  if ((flags & Symbol::FUNCTION_CALL) && gsym->has_plt_offset())
    return false;

  // A reference to any PLT entry in a non-position-independent executable
  // does not need a dynamic relocation.
  // Except due to having function descriptors on powerpc64 we don't define
  // functions to their plt code in an executable, so this doesn't apply.
  if (size == 32
      && !parameters->options().output_is_position_independent()
      && gsym->has_plt_offset())
    return false;

  // A reference to a symbol defined in a dynamic object or to a
  // symbol that is preemptible will need a dynamic relocation.
  if (gsym->is_from_dynobj()
      || gsym->is_undefined()
      || gsym->is_preemptible())
    return true;

  // For all other cases, return FALSE.
  return false;
}

// Modified version of symtab.h class Symbol member
// Whether we should use the PLT offset associated with a symbol for
// a relocation.  FLAGS is a set of Reference_flags.

template<int size>
bool
use_plt_offset(const Symbol* gsym, int flags)
{
  // If the symbol doesn't have a PLT offset, then naturally we
  // don't want to use it.
  if (!gsym->has_plt_offset())
    return false;

  // For a STT_GNU_IFUNC symbol we always have to use the PLT entry.
  if (gsym->type() == elfcpp::STT_GNU_IFUNC)
    return true;

  // If we are going to generate a dynamic relocation, then we will
  // wind up using that, so no need to use the PLT entry.
  if (needs_dynamic_reloc<size>(gsym, flags))
    return false;

  // If the symbol is from a dynamic object, we need to use the PLT
  // entry.
  if (gsym->is_from_dynobj())
    return true;

  // If we are generating a shared object, and this symbol is
  // undefined or preemptible, we need to use the PLT entry.
  if (parameters->options().shared()
      && (gsym->is_undefined() || gsym->is_preemptible()))
    return true;

  // If this is a call to a weak undefined symbol, we need to use
  // the PLT entry; the symbol may be defined by a library loaded
  // at runtime.
  if ((flags & Symbol::FUNCTION_CALL) && gsym->is_weak_undefined())
    return true;

  // Otherwise we can use the regular definition.
  return false;
}

template<int size, bool big_endian>
class Powerpc_relocate_functions
{
public:
  enum Overflow_check
  {
    CHECK_NONE,
    CHECK_SIGNED,
    CHECK_BITFIELD
  };

  enum Status
  {
    STATUS_OK,
    STATUS_OVERFLOW
  };

private:
  typedef Powerpc_relocate_functions<size, big_endian> This;
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;

  template<int valsize>
  static inline bool
  has_overflow_signed(Address value)
  {
    // limit = 1 << (valsize - 1) without shift count exceeding size of type
    Address limit = static_cast<Address>(1) << ((valsize - 1) >> 1);
    limit <<= ((valsize - 1) >> 1);
    limit <<= ((valsize - 1) - 2 * ((valsize - 1) >> 1));
    return value + limit > (limit << 1) - 1;
  }

  template<int valsize>
  static inline bool
  has_overflow_bitfield(Address value)
  {
    Address limit = static_cast<Address>(1) << ((valsize - 1) >> 1);
    limit <<= ((valsize - 1) >> 1);
    limit <<= ((valsize - 1) - 2 * ((valsize - 1) >> 1));
    return value > (limit << 1) - 1 && value + limit > (limit << 1) - 1;
  }

  template<int valsize>
  static inline Status
  overflowed(Address value, Overflow_check overflow)
  {
    if (overflow == CHECK_SIGNED)
      {
	if (has_overflow_signed<valsize>(value))
	  return STATUS_OVERFLOW;
      }
    else if (overflow == CHECK_BITFIELD)
      {
	if (has_overflow_bitfield<valsize>(value))
	  return STATUS_OVERFLOW;
      }
    return STATUS_OK;
  }

  // Do a simple RELA relocation
  template<int valsize>
  static inline Status
  rela(unsigned char* view, Address value, Overflow_check overflow)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    elfcpp::Swap<valsize, big_endian>::writeval(wv, value);
    return overflowed<valsize>(value, overflow);
  }

  template<int valsize>
  static inline Status
  rela(unsigned char* view,
       unsigned int right_shift,
       typename elfcpp::Valtype_base<valsize>::Valtype dst_mask,
       Address value,
       Overflow_check overflow)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<valsize, big_endian>::readval(wv);
    Valtype reloc = value >> right_shift;
    val &= ~dst_mask;
    reloc &= dst_mask;
    elfcpp::Swap<valsize, big_endian>::writeval(wv, val | reloc);
    return overflowed<valsize>(value >> right_shift, overflow);
  }

  // Do a simple RELA relocation, unaligned.
  template<int valsize>
  static inline Status
  rela_ua(unsigned char* view, Address value, Overflow_check overflow)
  {
    elfcpp::Swap_unaligned<valsize, big_endian>::writeval(view, value);
    return overflowed<valsize>(value, overflow);
  }

  template<int valsize>
  static inline Status
  rela_ua(unsigned char* view,
	  unsigned int right_shift,
	  typename elfcpp::Valtype_base<valsize>::Valtype dst_mask,
	  Address value,
	  Overflow_check overflow)
  {
    typedef typename elfcpp::Swap_unaligned<valsize, big_endian>::Valtype
      Valtype;
    Valtype val = elfcpp::Swap<valsize, big_endian>::readval(view);
    Valtype reloc = value >> right_shift;
    val &= ~dst_mask;
    reloc &= dst_mask;
    elfcpp::Swap_unaligned<valsize, big_endian>::writeval(view, val | reloc);
    return overflowed<valsize>(value >> right_shift, overflow);
  }

public:
  // R_PPC64_ADDR64: (Symbol + Addend)
  static inline void
  addr64(unsigned char* view, Address value)
  { This::template rela<64>(view, value, CHECK_NONE); }

  // R_PPC64_UADDR64: (Symbol + Addend) unaligned
  static inline void
  addr64_u(unsigned char* view, Address value)
  { This::template rela_ua<64>(view, value, CHECK_NONE); }

  // R_POWERPC_ADDR32: (Symbol + Addend)
  static inline Status
  addr32(unsigned char* view, Address value, Overflow_check overflow)
  { return This::template rela<32>(view, value, overflow); }

  // R_POWERPC_UADDR32: (Symbol + Addend) unaligned
  static inline Status
  addr32_u(unsigned char* view, Address value, Overflow_check overflow)
  { return This::template rela_ua<32>(view, value, overflow); }

  // R_POWERPC_ADDR24: (Symbol + Addend) & 0x3fffffc
  static inline Status
  addr24(unsigned char* view, Address value, Overflow_check overflow)
  {
    Status stat = This::template rela<32>(view, 0, 0x03fffffc, value, overflow);
    if (overflow != CHECK_NONE && (value & 3) != 0)
      stat = STATUS_OVERFLOW;
    return stat;
  }

  // R_POWERPC_ADDR16: (Symbol + Addend) & 0xffff
  static inline Status
  addr16(unsigned char* view, Address value, Overflow_check overflow)
  { return This::template rela<16>(view, value, overflow); }

  // R_POWERPC_ADDR16: (Symbol + Addend) & 0xffff, unaligned
  static inline Status
  addr16_u(unsigned char* view, Address value, Overflow_check overflow)
  { return This::template rela_ua<16>(view, value, overflow); }

  // R_POWERPC_ADDR16_DS: (Symbol + Addend) & 0xfffc
  static inline Status
  addr16_ds(unsigned char* view, Address value, Overflow_check overflow)
  {
    Status stat = This::template rela<16>(view, 0, 0xfffc, value, overflow);
    if (overflow != CHECK_NONE && (value & 3) != 0)
      stat = STATUS_OVERFLOW;
    return stat;
  }

  // R_POWERPC_ADDR16_HI: ((Symbol + Addend) >> 16) & 0xffff
  static inline void
  addr16_hi(unsigned char* view, Address value)
  { This::template rela<16>(view, 16, 0xffff, value, CHECK_NONE); }

  // R_POWERPC_ADDR16_HA: ((Symbol + Addend + 0x8000) >> 16) & 0xffff
  static inline void
  addr16_ha(unsigned char* view, Address value)
  { This::addr16_hi(view, value + 0x8000); }

  // R_POWERPC_ADDR16_HIGHER: ((Symbol + Addend) >> 32) & 0xffff
  static inline void
  addr16_hi2(unsigned char* view, Address value)
  { This::template rela<16>(view, 32, 0xffff, value, CHECK_NONE); }

  // R_POWERPC_ADDR16_HIGHERA: ((Symbol + Addend + 0x8000) >> 32) & 0xffff
  static inline void
  addr16_ha2(unsigned char* view, Address value)
  { This::addr16_hi2(view, value + 0x8000); }

  // R_POWERPC_ADDR16_HIGHEST: ((Symbol + Addend) >> 48) & 0xffff
  static inline void
  addr16_hi3(unsigned char* view, Address value)
  { This::template rela<16>(view, 48, 0xffff, value, CHECK_NONE); }

  // R_POWERPC_ADDR16_HIGHESTA: ((Symbol + Addend + 0x8000) >> 48) & 0xffff
  static inline void
  addr16_ha3(unsigned char* view, Address value)
  { This::addr16_hi3(view, value + 0x8000); }

  // R_POWERPC_ADDR14: (Symbol + Addend) & 0xfffc
  static inline Status
  addr14(unsigned char* view, Address value, Overflow_check overflow)
  {
    Status stat = This::template rela<32>(view, 0, 0xfffc, value, overflow);
    if (overflow != CHECK_NONE && (value & 3) != 0)
      stat = STATUS_OVERFLOW;
    return stat;
  }
};

// Stash away the index of .got2 or .opd in a relocatable object, if
// such a section exists.

template<int size, bool big_endian>
bool
Powerpc_relobj<size, big_endian>::do_find_special_sections(
    Read_symbols_data* sd)
{
  const unsigned char* const pshdrs = sd->section_headers->data();
  const unsigned char* namesu = sd->section_names->data();
  const char* names = reinterpret_cast<const char*>(namesu);
  section_size_type names_size = sd->section_names_size;
  const unsigned char* s;

  s = this->template find_shdr<size, big_endian>(pshdrs,
						 size == 32 ? ".got2" : ".opd",
						 names, names_size, NULL);
  if (s != NULL)
    {
      unsigned int ndx = (s - pshdrs) / elfcpp::Elf_sizes<size>::shdr_size;
      this->special_ = ndx;
    }
  return Sized_relobj_file<size, big_endian>::do_find_special_sections(sd);
}

// Examine .rela.opd to build info about function entry points.

template<int size, bool big_endian>
void
Powerpc_relobj<size, big_endian>::scan_opd_relocs(
    size_t reloc_count,
    const unsigned char* prelocs,
    const unsigned char* plocal_syms)
{
  if (size == 64)
    {
      typedef typename Reloc_types<elfcpp::SHT_RELA, size, big_endian>::Reloc
	Reltype;
      const int reloc_size
	= Reloc_types<elfcpp::SHT_RELA, size, big_endian>::reloc_size;
      const int sym_size = elfcpp::Elf_sizes<size>::sym_size;
      Address expected_off = 0;
      bool regular = true;
      unsigned int opd_ent_size = 0;

      for (size_t i = 0; i < reloc_count; ++i, prelocs += reloc_size)
	{
	  Reltype reloc(prelocs);
	  typename elfcpp::Elf_types<size>::Elf_WXword r_info
	    = reloc.get_r_info();
	  unsigned int r_type = elfcpp::elf_r_type<size>(r_info);
	  if (r_type == elfcpp::R_PPC64_ADDR64)
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);
	      typename elfcpp::Elf_types<size>::Elf_Addr value;
	      bool is_ordinary;
	      unsigned int shndx;
	      if (r_sym < this->local_symbol_count())
		{
		  typename elfcpp::Sym<size, big_endian>
		    lsym(plocal_syms + r_sym * sym_size);
		  shndx = lsym.get_st_shndx();
		  shndx = this->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
		  value = lsym.get_st_value();
		}
	      else
		shndx = this->symbol_section_and_value(r_sym, &value,
						       &is_ordinary);
	      this->set_opd_ent(reloc.get_r_offset(), shndx,
				value + reloc.get_r_addend());
	      if (i == 2)
		{
		  expected_off = reloc.get_r_offset();
		  opd_ent_size = expected_off;
		}
	      else if (expected_off != reloc.get_r_offset())
		regular = false;
	      expected_off += opd_ent_size;
	    }
	  else if (r_type == elfcpp::R_PPC64_TOC)
	    {
	      if (expected_off - opd_ent_size + 8 != reloc.get_r_offset())
		regular = false;
	    }
	  else
	    {
	      gold_warning(_("%s: unexpected reloc type %u in .opd section"),
			   this->name().c_str(), r_type);
	      regular = false;
	    }
	}
      if (reloc_count <= 2)
	opd_ent_size = this->section_size(this->opd_shndx());
      if (opd_ent_size != 24 && opd_ent_size != 16)
	regular = false;
      if (!regular)
	{
	  gold_warning(_("%s: .opd is not a regular array of opd entries"),
		       this->name().c_str());
	  opd_ent_size = 0;
	}
    }
}

template<int size, bool big_endian>
void
Powerpc_relobj<size, big_endian>::do_read_relocs(Read_relocs_data* rd)
{
  Sized_relobj_file<size, big_endian>::do_read_relocs(rd);
  if (size == 64)
    {
      for (Read_relocs_data::Relocs_list::iterator p = rd->relocs.begin();
	   p != rd->relocs.end();
	   ++p)
	{
	  if (p->data_shndx == this->opd_shndx())
	    {
	      uint64_t opd_size = this->section_size(this->opd_shndx());
	      gold_assert(opd_size == static_cast<size_t>(opd_size));
	      if (opd_size != 0)
		{
		  this->init_opd(opd_size);
		  this->scan_opd_relocs(p->reloc_count, p->contents->data(),
					rd->local_symbols->data());
		}
	      break;
	    }
	}
    }
}

// Call Sized_dynobj::do_read_symbols to read the symbols then
// read .opd from a dynamic object, filling in opd_ent_ vector,

template<int size, bool big_endian>
void
Powerpc_dynobj<size, big_endian>::do_read_symbols(Read_symbols_data* sd)
{
  Sized_dynobj<size, big_endian>::do_read_symbols(sd);
  if (size == 64)
    {
      const int shdr_size = elfcpp::Elf_sizes<size>::shdr_size;
      const unsigned char* const pshdrs = sd->section_headers->data();
      const unsigned char* namesu = sd->section_names->data();
      const char* names = reinterpret_cast<const char*>(namesu);
      const unsigned char* s = NULL;
      const unsigned char* opd;
      section_size_type opd_size;

      // Find and read .opd section.
      while (1)
	{
	  s = this->template find_shdr<size, big_endian>(pshdrs, ".opd", names,
							 sd->section_names_size,
							 s);
	  if (s == NULL)
	    return;

	  typename elfcpp::Shdr<size, big_endian> shdr(s);
	  if (shdr.get_sh_type() == elfcpp::SHT_PROGBITS
	      && (shdr.get_sh_flags() & elfcpp::SHF_ALLOC) != 0)
	    {
	      this->opd_shndx_ = (s - pshdrs) / shdr_size;
	      this->opd_address_ = shdr.get_sh_addr();
	      opd_size = convert_to_section_size_type(shdr.get_sh_size());
	      opd = this->get_view(shdr.get_sh_offset(), opd_size,
				   true, false);
	      break;
	    }
	}

      // Build set of executable sections.
      // Using a set is probably overkill.  There is likely to be only
      // a few executable sections, typically .init, .text and .fini,
      // and they are generally grouped together.
      typedef std::set<Sec_info> Exec_sections;
      Exec_sections exec_sections;
      s = pshdrs;
      for (unsigned int i = 1; i < this->shnum(); ++i, s += shdr_size)
	{
	  typename elfcpp::Shdr<size, big_endian> shdr(s);
	  if (shdr.get_sh_type() == elfcpp::SHT_PROGBITS
	      && ((shdr.get_sh_flags()
		   & (elfcpp::SHF_ALLOC | elfcpp::SHF_EXECINSTR))
		  == (elfcpp::SHF_ALLOC | elfcpp::SHF_EXECINSTR))
	      && shdr.get_sh_size() != 0)
	    {
	      exec_sections.insert(Sec_info(shdr.get_sh_addr(),
					    shdr.get_sh_size(), i));
	    }
	}
      if (exec_sections.empty())
	return;

      // Look over the OPD entries.  This is complicated by the fact
      // that some binaries will use two-word entries while others
      // will use the standard three-word entries.  In most cases
      // the third word (the environment pointer for languages like
      // Pascal) is unused and will be zero.  If the third word is
      // used it should not be pointing into executable sections,
      // I think.
      this->init_opd(opd_size);
      for (const unsigned char* p = opd; p < opd + opd_size; p += 8)
	{
	  typedef typename elfcpp::Swap<64, big_endian>::Valtype Valtype;
	  const Valtype* valp = reinterpret_cast<const Valtype*>(p);
	  Valtype val = elfcpp::Swap<64, big_endian>::readval(valp);
	  if (val == 0)
	    // Chances are that this is the third word of an OPD entry.
	    continue;
	  typename Exec_sections::const_iterator e
	    = exec_sections.upper_bound(Sec_info(val, 0, 0));
	  if (e != exec_sections.begin())
	    {
	      --e;
	      if (e->start <= val && val < e->start + e->len)
		{
		  // We have an address in an executable section.
		  // VAL ought to be the function entry, set it up.
		  this->set_opd_ent(p - opd, e->shndx, val);
		  // Skip second word of OPD entry, the TOC pointer.
		  p += 8;
		}
	    }
	  // If we didn't match any executable sections, we likely
	  // have a non-zero third word in the OPD entry.
	}
    }
}

// Set up some symbols.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::do_define_standard_symbols(
    Symbol_table* symtab,
    Layout* layout)
{
  if (size == 32)
    {
      // Define _GLOBAL_OFFSET_TABLE_ to ensure it isn't seen as
      // undefined when scanning relocs (and thus requires
      // non-relative dynamic relocs).  The proper value will be
      // updated later.
      Symbol *gotsym = symtab->lookup("_GLOBAL_OFFSET_TABLE_", NULL);
      if (gotsym != NULL && gotsym->is_undefined())
	{
	  Target_powerpc<size, big_endian>* target =
	    static_cast<Target_powerpc<size, big_endian>*>(
		parameters->sized_target<size, big_endian>());
	  Output_data_got_powerpc<size, big_endian>* got
	    = target->got_section(symtab, layout);
	  symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
					Symbol_table::PREDEFINED,
					got, 0, 0,
					elfcpp::STT_OBJECT,
					elfcpp::STB_LOCAL,
					elfcpp::STV_HIDDEN, 0,
					false, false);
	}

      // Define _SDA_BASE_ at the start of the .sdata section + 32768.
      Symbol *sdasym = symtab->lookup("_SDA_BASE_", NULL);
      if (sdasym != NULL && sdasym->is_undefined())
	{
	  Output_data_space* sdata = new Output_data_space(4, "** sdata");
	  Output_section* os
	    = layout->add_output_section_data(".sdata", 0,
					      elfcpp::SHF_ALLOC
					      | elfcpp::SHF_WRITE,
					      sdata, ORDER_SMALL_DATA, false);
	  symtab->define_in_output_data("_SDA_BASE_", NULL,
					Symbol_table::PREDEFINED,
					os, 32768, 0, elfcpp::STT_OBJECT,
					elfcpp::STB_LOCAL, elfcpp::STV_HIDDEN,
					0, false, false);
	}
    }
}

// Set up PowerPC target specific relobj.

template<int size, bool big_endian>
Object*
Target_powerpc<size, big_endian>::do_make_elf_object(
    const std::string& name,
    Input_file* input_file,
    off_t offset, const elfcpp::Ehdr<size, big_endian>& ehdr)
{
  int et = ehdr.get_e_type();
  // ET_EXEC files are valid input for --just-symbols/-R,
  // and we treat them as relocatable objects.
  if (et == elfcpp::ET_REL
      || (et == elfcpp::ET_EXEC && input_file->just_symbols()))
    {
      Powerpc_relobj<size, big_endian>* obj =
	new Powerpc_relobj<size, big_endian>(name, input_file, offset, ehdr);
      obj->setup();
      return obj;
    }
  else if (et == elfcpp::ET_DYN)
    {
      Powerpc_dynobj<size, big_endian>* obj =
	new Powerpc_dynobj<size, big_endian>(name, input_file, offset, ehdr);
      obj->setup();
      return obj;
    }
  else
    {
      gold_error(_("%s: unsupported ELF file type %d"), name.c_str(), et);
      return NULL;
    }
}

template<int size, bool big_endian>
class Output_data_got_powerpc : public Output_data_got<size, big_endian>
{
public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Valtype;
  typedef Output_data_reloc<elfcpp::SHT_RELA, true, size, big_endian> Rela_dyn;

  Output_data_got_powerpc(Symbol_table* symtab, Layout* layout)
    : Output_data_got<size, big_endian>(),
      symtab_(symtab), layout_(layout),
      header_ent_cnt_(size == 32 ? 3 : 1),
      header_index_(size == 32 ? 0x2000 : 0)
  { }

  // Override all the Output_data_got methods we use so as to first call
  // reserve_ent().
  bool
  add_global(Symbol* gsym, unsigned int got_type)
  {
    this->reserve_ent();
    return Output_data_got<size, big_endian>::add_global(gsym, got_type);
  }

  bool
  add_global_plt(Symbol* gsym, unsigned int got_type)
  {
    this->reserve_ent();
    return Output_data_got<size, big_endian>::add_global_plt(gsym, got_type);
  }

  bool
  add_global_tls(Symbol* gsym, unsigned int got_type)
  { return this->add_global_plt(gsym, got_type); }

  void
  add_global_with_rel(Symbol* gsym, unsigned int got_type,
		      Output_data_reloc_generic* rel_dyn, unsigned int r_type)
  {
    this->reserve_ent();
    Output_data_got<size, big_endian>::
      add_global_with_rel(gsym, got_type, rel_dyn, r_type);
  }

  void
  add_global_pair_with_rel(Symbol* gsym, unsigned int got_type,
			   Output_data_reloc_generic* rel_dyn,
			   unsigned int r_type_1, unsigned int r_type_2)
  {
    this->reserve_ent(2);
    Output_data_got<size, big_endian>::
      add_global_pair_with_rel(gsym, got_type, rel_dyn, r_type_1, r_type_2);
  }

  bool
  add_local(Relobj* object, unsigned int sym_index, unsigned int got_type)
  {
    this->reserve_ent();
    return Output_data_got<size, big_endian>::add_local(object, sym_index,
							got_type);
  }

  bool
  add_local_plt(Relobj* object, unsigned int sym_index, unsigned int got_type)
  {
    this->reserve_ent();
    return Output_data_got<size, big_endian>::add_local_plt(object, sym_index,
							    got_type);
  }

  bool
  add_local_tls(Relobj* object, unsigned int sym_index, unsigned int got_type)
  { return this->add_local_plt(object, sym_index, got_type); }

  void
  add_local_tls_pair(Relobj* object, unsigned int sym_index,
		     unsigned int got_type,
		     Output_data_reloc_generic* rel_dyn,
		     unsigned int r_type)
  {
    this->reserve_ent(2);
    Output_data_got<size, big_endian>::
      add_local_tls_pair(object, sym_index, got_type, rel_dyn, r_type);
  }

  unsigned int
  add_constant(Valtype constant)
  {
    this->reserve_ent();
    return Output_data_got<size, big_endian>::add_constant(constant);
  }

  unsigned int
  add_constant_pair(Valtype c1, Valtype c2)
  {
    this->reserve_ent(2);
    return Output_data_got<size, big_endian>::add_constant_pair(c1, c2);
  }

  // Offset of _GLOBAL_OFFSET_TABLE_.
  unsigned int
  g_o_t() const
  {
    return this->got_offset(this->header_index_);
  }

  // Offset of base used to access the GOT/TOC.
  // The got/toc pointer reg will be set to this value.
  Valtype
  got_base_offset(const Powerpc_relobj<size, big_endian>* object) const
  {
    if (size == 32)
      return this->g_o_t();
    else
      return (this->output_section()->address()
	      + object->toc_base_offset()
	      - this->address());
  }

  // Ensure our GOT has a header.
  void
  set_final_data_size()
  {
    if (this->header_ent_cnt_ != 0)
      this->make_header();
    Output_data_got<size, big_endian>::set_final_data_size();
  }

  // First word of GOT header needs some values that are not
  // handled by Output_data_got so poke them in here.
  // For 32-bit, address of .dynamic, for 64-bit, address of TOCbase.
  void
  do_write(Output_file* of)
  {
    Valtype val = 0;
    if (size == 32 && this->layout_->dynamic_data() != NULL)
      val = this->layout_->dynamic_section()->address();
    if (size == 64)
      val = this->output_section()->address() + 0x8000;
    this->replace_constant(this->header_index_, val);
    Output_data_got<size, big_endian>::do_write(of);
  }

private:
  void
  reserve_ent(unsigned int cnt = 1)
  {
    if (this->header_ent_cnt_ == 0)
      return;
    if (this->num_entries() + cnt > this->header_index_)
      this->make_header();
  }

  void
  make_header()
  {
    this->header_ent_cnt_ = 0;
    this->header_index_ = this->num_entries();
    if (size == 32)
      {
	Output_data_got<size, big_endian>::add_constant(0);
	Output_data_got<size, big_endian>::add_constant(0);
	Output_data_got<size, big_endian>::add_constant(0);

	// Define _GLOBAL_OFFSET_TABLE_ at the header
	Symbol *gotsym = this->symtab_->lookup("_GLOBAL_OFFSET_TABLE_", NULL);
	if (gotsym != NULL)
	  {
	    Sized_symbol<size>* sym = static_cast<Sized_symbol<size>*>(gotsym);
	    sym->set_value(this->g_o_t());
	  }
	else
	  this->symtab_->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
					       Symbol_table::PREDEFINED,
					       this, this->g_o_t(), 0,
					       elfcpp::STT_OBJECT,
					       elfcpp::STB_LOCAL,
					       elfcpp::STV_HIDDEN, 0,
					       false, false);
      }
    else
      Output_data_got<size, big_endian>::add_constant(0);
  }

  // Stashed pointers.
  Symbol_table* symtab_;
  Layout* layout_;

  // GOT header size.
  unsigned int header_ent_cnt_;
  // GOT header index.
  unsigned int header_index_;
};

// Get the GOT section, creating it if necessary.

template<int size, bool big_endian>
Output_data_got_powerpc<size, big_endian>*
Target_powerpc<size, big_endian>::got_section(Symbol_table* symtab,
					      Layout* layout)
{
  if (this->got_ == NULL)
    {
      gold_assert(symtab != NULL && layout != NULL);

      this->got_
	= new Output_data_got_powerpc<size, big_endian>(symtab, layout);

      layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
				      elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE,
				      this->got_, ORDER_DATA, false);
    }

  return this->got_;
}

// Get the dynamic reloc section, creating it if necessary.

template<int size, bool big_endian>
typename Target_powerpc<size, big_endian>::Reloc_section*
Target_powerpc<size, big_endian>::rela_dyn_section(Layout* layout)
{
  if (this->rela_dyn_ == NULL)
    {
      gold_assert(layout != NULL);
      this->rela_dyn_ = new Reloc_section(parameters->options().combreloc());
      layout->add_output_section_data(".rela.dyn", elfcpp::SHT_RELA,
				      elfcpp::SHF_ALLOC, this->rela_dyn_,
				      ORDER_DYNAMIC_RELOCS, false);
    }
  return this->rela_dyn_;
}

// Similarly, but for ifunc symbols get the one for ifunc.

template<int size, bool big_endian>
typename Target_powerpc<size, big_endian>::Reloc_section*
Target_powerpc<size, big_endian>::rela_dyn_section(Symbol_table* symtab,
						   Layout* layout,
						   bool for_ifunc)
{
  if (!for_ifunc)
    return this->rela_dyn_section(layout);

  if (this->iplt_ == NULL)
    this->make_iplt_section(symtab, layout);
  return this->iplt_->rel_plt();
}

class Stub_control
{
 public:
  // Determine the stub group size.  The group size is the absolute
  // value of the parameter --stub-group-size.  If --stub-group-size
  // is passed a negative value, we restrict stubs to be always before
  // the stubbed branches.
  Stub_control(int32_t size)
    : state_(NO_GROUP), stub_group_size_(abs(size)),
      stub14_group_size_(abs(size)),
      stubs_always_before_branch_(size < 0), suppress_size_errors_(false),
      group_end_addr_(0), owner_(NULL), output_section_(NULL)
  {
    if (stub_group_size_ == 1)
      {
	// Default values.
	if (stubs_always_before_branch_)
	  {
	    stub_group_size_ = 0x1e00000;
	    stub14_group_size_ = 0x7800;
	  }
	else
	  {
	    stub_group_size_ = 0x1c00000;
	    stub14_group_size_ = 0x7000;
	  }
	suppress_size_errors_ = true;
      }
  }

  // Return true iff input section can be handled by current stub
  // group.
  bool
  can_add_to_stub_group(Output_section* o,
			const Output_section::Input_section* i,
			bool has14);

  const Output_section::Input_section*
  owner()
  { return owner_; }

  Output_section*
  output_section()
  { return output_section_; }

 private:
  typedef enum
  {
    NO_GROUP,
    FINDING_STUB_SECTION,
    HAS_STUB_SECTION
  } State;

  State state_;
  uint32_t stub_group_size_;
  uint32_t stub14_group_size_;
  bool stubs_always_before_branch_;
  bool suppress_size_errors_;
  uint64_t group_end_addr_;
  const Output_section::Input_section* owner_;
  Output_section* output_section_;
};

// Return true iff input section can be handled by current stub
// group.

bool
Stub_control::can_add_to_stub_group(Output_section* o,
				    const Output_section::Input_section* i,
				    bool has14)
{
  uint32_t group_size
    = has14 ? this->stub14_group_size_ : this->stub_group_size_;
  bool whole_sec = o->order() == ORDER_INIT || o->order() == ORDER_FINI;
  uint64_t this_size;
  uint64_t start_addr = o->address();

  if (whole_sec)
    // .init and .fini sections are pasted together to form a single
    // function.  We can't be adding stubs in the middle of the function.
    this_size = o->data_size();
  else
    {
      start_addr += i->relobj()->output_section_offset(i->shndx());
      this_size = i->data_size();
    }
  uint64_t end_addr = start_addr + this_size;
  bool toobig = this_size > group_size;

  if (toobig && !this->suppress_size_errors_)
    gold_warning(_("%s:%s exceeds group size"),
		 i->relobj()->name().c_str(),
		 i->relobj()->section_name(i->shndx()).c_str());

  if (this->state_ != HAS_STUB_SECTION
      && (!whole_sec || this->output_section_ != o)
      && (this->state_ == NO_GROUP
	  || this->group_end_addr_ - end_addr < group_size))
    {
      this->owner_ = i;
      this->output_section_ = o;
    }

  if (this->state_ == NO_GROUP)
    {
      this->state_ = FINDING_STUB_SECTION;
      this->group_end_addr_ = end_addr;
    }
  else if (this->group_end_addr_ - start_addr < group_size)
    ;
  // Adding this section would make the group larger than GROUP_SIZE.
  else if (this->state_ == FINDING_STUB_SECTION
	   && !this->stubs_always_before_branch_
	   && !toobig)
    {
      // But wait, there's more!  Input sections up to GROUP_SIZE
      // bytes before the stub table can be handled by it too.
      this->state_ = HAS_STUB_SECTION;
      this->group_end_addr_ = end_addr;
    }
  else
    {
      this->state_ = NO_GROUP;
      return false;
    }
  return true;
}

// Look over all the input sections, deciding where to place stubs.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::group_sections(Layout* layout,
						 const Task*)
{
  Stub_control stub_control(parameters->options().stub_group_size());

  // Group input sections and insert stub table
  Stub_table<size, big_endian>* stub_table = NULL;
  Layout::Section_list section_list;
  layout->get_executable_sections(&section_list);
  std::stable_sort(section_list.begin(), section_list.end(), Sort_sections());
  for (Layout::Section_list::reverse_iterator o = section_list.rbegin();
       o != section_list.rend();
       ++o)
    {
      typedef Output_section::Input_section_list Input_section_list;
      for (Input_section_list::const_reverse_iterator i
	     = (*o)->input_sections().rbegin();
	   i != (*o)->input_sections().rend();
	   ++i)
	{
	  if (i->is_input_section())
	    {
	      Powerpc_relobj<size, big_endian>* ppcobj = static_cast
		<Powerpc_relobj<size, big_endian>*>(i->relobj());
	      bool has14 = ppcobj->has_14bit_branch(i->shndx());
	      if (!stub_control.can_add_to_stub_group(*o, &*i, has14))
		{
		  stub_table->init(stub_control.owner(),
				   stub_control.output_section());
		  stub_table = NULL;
		}
	      if (stub_table == NULL)
		stub_table = this->new_stub_table();
	      ppcobj->set_stub_table(i->shndx(), stub_table);
	    }
	}
    }
  if (stub_table != NULL)
    {
      const Output_section::Input_section* i = stub_control.owner();
      if (!i->is_input_section())
	{
	  // Corner case.  A new stub group was made for the first
	  // section (last one looked at here) for some reason, but
	  // the first section is already being used as the owner for
	  // a stub table for following sections.  Force it into that
	  // stub group.
	  gold_assert(this->stub_tables_.size() >= 2);
	  this->stub_tables_.pop_back();
	  delete stub_table;
	  Powerpc_relobj<size, big_endian>* ppcobj = static_cast
	    <Powerpc_relobj<size, big_endian>*>(i->relobj());
	  ppcobj->set_stub_table(i->shndx(), this->stub_tables_.back());
	}
      else
	stub_table->init(i, stub_control.output_section());
    }
}

// If this branch needs a plt call stub, or a long branch stub, make one.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::Branch_info::make_stub(
    Stub_table<size, big_endian>* stub_table,
    Stub_table<size, big_endian>* ifunc_stub_table,
    Symbol_table* symtab) const
{
  Symbol* sym = this->object_->global_symbol(this->r_sym_);
  if (sym != NULL && sym->is_forwarder())
    sym = symtab->resolve_forwards(sym);
  const Sized_symbol<size>* gsym = static_cast<const Sized_symbol<size>*>(sym);
  if (gsym != NULL
      ? use_plt_offset<size>(gsym, Scan::get_reference_flags(this->r_type_))
      : this->object_->local_has_plt_offset(this->r_sym_))
    {
      if (stub_table == NULL)
	stub_table = this->object_->stub_table(this->shndx_);
      if (stub_table == NULL)
	{
	  // This is a ref from a data section to an ifunc symbol.
	  stub_table = ifunc_stub_table;
	}
      gold_assert(stub_table != NULL);
      if (gsym != NULL)
	stub_table->add_plt_call_entry(this->object_, gsym,
				       this->r_type_, this->addend_);
      else
	stub_table->add_plt_call_entry(this->object_, this->r_sym_,
				       this->r_type_, this->addend_);
    }
  else
    {
      unsigned int max_branch_offset;
      if (this->r_type_ == elfcpp::R_POWERPC_REL14
	  || this->r_type_ == elfcpp::R_POWERPC_REL14_BRTAKEN
	  || this->r_type_ == elfcpp::R_POWERPC_REL14_BRNTAKEN)
	max_branch_offset = 1 << 15;
      else if (this->r_type_ == elfcpp::R_POWERPC_REL24
	       || this->r_type_ == elfcpp::R_PPC_PLTREL24
	       || this->r_type_ == elfcpp::R_PPC_LOCAL24PC)
	max_branch_offset = 1 << 25;
      else
	return;
      Address from = this->object_->get_output_section_offset(this->shndx_);
      gold_assert(from != invalid_address);
      from += (this->object_->output_section(this->shndx_)->address()
	       + this->offset_);
      Address to;
      if (gsym != NULL)
	{
	  switch (gsym->source())
	    {
	    case Symbol::FROM_OBJECT:
	      {
		Object* symobj = gsym->object();
		if (symobj->is_dynamic()
		    || symobj->pluginobj() != NULL)
		  return;
		bool is_ordinary;
		unsigned int shndx = gsym->shndx(&is_ordinary);
		if (shndx == elfcpp::SHN_UNDEF)
		  return;
	      }
	      break;

	    case Symbol::IS_UNDEFINED:
	      return;

	    default:
	      break;
	    }
	  Symbol_table::Compute_final_value_status status;
	  to = symtab->compute_final_value<size>(gsym, &status);
	  if (status != Symbol_table::CFVS_OK)
	    return;
	}
      else
	{
	  const Symbol_value<size>* psymval
	    = this->object_->local_symbol(this->r_sym_);
	  Symbol_value<size> symval;
	  typedef Sized_relobj_file<size, big_endian> ObjType;
	  typename ObjType::Compute_final_local_value_status status
	    = this->object_->compute_final_local_value(this->r_sym_, psymval,
						       &symval, symtab);
	  if (status != ObjType::CFLV_OK
	      || !symval.has_output_value())
	    return;
	  to = symval.value(this->object_, 0);
	}
      to += this->addend_;
      if (stub_table == NULL)
	stub_table = this->object_->stub_table(this->shndx_);
      if (size == 64 && is_branch_reloc(this->r_type_))
	{
	  unsigned int dest_shndx;
	  Target_powerpc<size, big_endian>* target =
	    static_cast<Target_powerpc<size, big_endian>*>(
		parameters->sized_target<size, big_endian>());
	  to = target->symval_for_branch(symtab, to, gsym,
					 this->object_, &dest_shndx);
	}
      Address delta = to - from;
      if (delta + max_branch_offset >= 2 * max_branch_offset)
	{
	  if (stub_table == NULL)
	    {
	      gold_warning(_("%s:%s: branch in non-executable section,"
			     " no long branch stub for you"),
			   this->object_->name().c_str(),
			   this->object_->section_name(this->shndx_).c_str());
	      return;
	    }
	  stub_table->add_long_branch_entry(this->object_, to);
	}
    }
}

// Relaxation hook.  This is where we do stub generation.

template<int size, bool big_endian>
bool
Target_powerpc<size, big_endian>::do_relax(int pass,
					   const Input_objects*,
					   Symbol_table* symtab,
					   Layout* layout,
					   const Task* task)
{
  unsigned int prev_brlt_size = 0;
  if (pass == 1)
    {
      bool thread_safe = parameters->options().plt_thread_safe();
      if (size == 64 && !parameters->options().user_set_plt_thread_safe())
	{
	  static const char* const thread_starter[] =
	    {
	      "pthread_create",
	      /* libstdc++ */
	      "_ZNSt6thread15_M_start_threadESt10shared_ptrINS_10_Impl_baseEE",
	      /* librt */
	      "aio_init", "aio_read", "aio_write", "aio_fsync", "lio_listio",
	      "mq_notify", "create_timer",
	      /* libanl */
	      "getaddrinfo_a",
	      /* libgomp */
	      "GOMP_parallel_start",
	      "GOMP_parallel_loop_static_start",
	      "GOMP_parallel_loop_dynamic_start",
	      "GOMP_parallel_loop_guided_start",
	      "GOMP_parallel_loop_runtime_start",
	      "GOMP_parallel_sections_start",
	    };

	  if (parameters->options().shared())
	    thread_safe = true;
	  else
	    {
	      for (unsigned int i = 0;
		   i < sizeof(thread_starter) / sizeof(thread_starter[0]);
		   i++)
		{
		  Symbol* sym = symtab->lookup(thread_starter[i], NULL);
		  thread_safe = (sym != NULL
				 && sym->in_reg()
				 && sym->in_real_elf());
		  if (thread_safe)
		    break;
		}
	    }
	}
      this->plt_thread_safe_ = thread_safe;
      this->group_sections(layout, task);
    }

  // We need address of stub tables valid for make_stub.
  for (typename Stub_tables::iterator p = this->stub_tables_.begin();
       p != this->stub_tables_.end();
       ++p)
    {
      const Powerpc_relobj<size, big_endian>* object
	= static_cast<const Powerpc_relobj<size, big_endian>*>((*p)->relobj());
      Address off = object->get_output_section_offset((*p)->shndx());
      gold_assert(off != invalid_address);
      Output_section* os = (*p)->output_section();
      (*p)->set_address_and_size(os, off);
    }

  if (pass != 1)
    {
      // Clear plt call stubs, long branch stubs and branch lookup table.
      prev_brlt_size = this->branch_lookup_table_.size();
      this->branch_lookup_table_.clear();
      for (typename Stub_tables::iterator p = this->stub_tables_.begin();
	   p != this->stub_tables_.end();
	   ++p)
	{
	  (*p)->clear_stubs();
	}
    }

  // Build all the stubs.
  Stub_table<size, big_endian>* ifunc_stub_table
    = this->stub_tables_.size() == 0 ? NULL : this->stub_tables_[0];
  Stub_table<size, big_endian>* one_stub_table
    = this->stub_tables_.size() != 1 ? NULL : ifunc_stub_table;
  for (typename Branches::const_iterator b = this->branch_info_.begin();
       b != this->branch_info_.end();
       b++)
    {
      b->make_stub(one_stub_table, ifunc_stub_table, symtab);
    }

  // Did anything change size?
  unsigned int num_huge_branches = this->branch_lookup_table_.size();
  bool again = num_huge_branches != prev_brlt_size;
  if (size == 64 && num_huge_branches != 0)
    this->make_brlt_section(layout);
  if (size == 64 && again)
    this->brlt_section_->set_current_size(num_huge_branches);

  typedef Unordered_set<Output_section*> Output_sections;
  Output_sections os_need_update;
  for (typename Stub_tables::iterator p = this->stub_tables_.begin();
       p != this->stub_tables_.end();
       ++p)
    {
      if ((*p)->size_update())
	{
	  again = true;
	  (*p)->add_eh_frame(layout);
	  os_need_update.insert((*p)->output_section());
	}
    }

  // Set output section offsets for all input sections in an output
  // section that just changed size.  Anything past the stubs will
  // need updating.
  for (typename Output_sections::iterator p = os_need_update.begin();
       p != os_need_update.end();
       p++)
    {
      Output_section* os = *p;
      Address off = 0;
      typedef Output_section::Input_section_list Input_section_list;
      for (Input_section_list::const_iterator i = os->input_sections().begin();
	   i != os->input_sections().end();
	   ++i)
	{
	  off = align_address(off, i->addralign());
	  if (i->is_input_section() || i->is_relaxed_input_section())
	    i->relobj()->set_section_offset(i->shndx(), off);
	  if (i->is_relaxed_input_section())
	    {
	      Stub_table<size, big_endian>* stub_table
		= static_cast<Stub_table<size, big_endian>*>(
		    i->relaxed_input_section());
	      off += stub_table->set_address_and_size(os, off);
	    }
	  else
	    off += i->data_size();
	}
      // If .branch_lt is part of this output section, then we have
      // just done the offset adjustment.
      os->clear_section_offsets_need_adjustment();
    }

  if (size == 64
      && !again
      && num_huge_branches != 0
      && parameters->options().output_is_position_independent())
    {
      // Fill in the BRLT relocs.
      this->brlt_section_->reset_brlt_sizes();
      for (typename Branch_lookup_table::const_iterator p
	     = this->branch_lookup_table_.begin();
	   p != this->branch_lookup_table_.end();
	   ++p)
	{
	  this->brlt_section_->add_reloc(p->first, p->second);
	}
      this->brlt_section_->finalize_brlt_sizes();
    }
  return again;
}

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::do_plt_fde_location(const Output_data* plt,
						      unsigned char* oview,
						      uint64_t* paddress,
						      off_t* plen) const
{
  uint64_t address = plt->address();
  off_t len = plt->data_size();

  if (plt == this->glink_)
    {
      // See Output_data_glink::do_write() for glink contents.
      if (size == 64)
	{
	  // There is one word before __glink_PLTresolve
	  address += 8;
	  len -= 8;
	}
      else if (parameters->options().output_is_position_independent())
	{
	  // There are two FDEs for a position independent glink.
	  // The first covers the branch table, the second
	  // __glink_PLTresolve at the end of glink.
	  off_t resolve_size = this->glink_->pltresolve_size;
	  if (oview[9] == 0)
	    len -= resolve_size;
	  else
	    {
	      address += len - resolve_size;
	      len = resolve_size;
	    }
	}
    }
  else
    {
      // Must be a stub table.
      const Stub_table<size, big_endian>* stub_table
	= static_cast<const Stub_table<size, big_endian>*>(plt);
      uint64_t stub_address = stub_table->stub_address();
      len -= stub_address - address;
      address = stub_address;
    }

  *paddress = address;
  *plen = len;
}

// A class to handle the PLT data.

template<int size, bool big_endian>
class Output_data_plt_powerpc : public Output_section_data_build
{
 public:
  typedef Output_data_reloc<elfcpp::SHT_RELA, true,
			    size, big_endian> Reloc_section;

  Output_data_plt_powerpc(Target_powerpc<size, big_endian>* targ,
			  Reloc_section* plt_rel,
			  unsigned int reserved_size,
			  const char* name)
    : Output_section_data_build(size == 32 ? 4 : 8),
      rel_(plt_rel),
      targ_(targ),
      initial_plt_entry_size_(reserved_size),
      name_(name)
  { }

  // Add an entry to the PLT.
  void
  add_entry(Symbol*);

  void
  add_ifunc_entry(Symbol*);

  void
  add_local_ifunc_entry(Sized_relobj_file<size, big_endian>*, unsigned int);

  // Return the .rela.plt section data.
  Reloc_section*
  rel_plt() const
  {
    return this->rel_;
  }

  // Return the number of PLT entries.
  unsigned int
  entry_count() const
  {
    if (this->current_data_size() == 0)
      return 0;
    return ((this->current_data_size() - this->initial_plt_entry_size_)
	    / plt_entry_size);
  }

  // Return the offset of the first non-reserved PLT entry.
  unsigned int
  first_plt_entry_offset()
  { return this->initial_plt_entry_size_; }

  // Return the size of a PLT entry.
  static unsigned int
  get_plt_entry_size()
  { return plt_entry_size; }

 protected:
  void
  do_adjust_output_section(Output_section* os)
  {
    os->set_entsize(0);
  }

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, this->name_); }

 private:
  // The size of an entry in the PLT.
  static const int plt_entry_size = size == 32 ? 4 : 24;

  // Write out the PLT data.
  void
  do_write(Output_file*);

  // The reloc section.
  Reloc_section* rel_;
  // Allows access to .glink for do_write.
  Target_powerpc<size, big_endian>* targ_;
  // The size of the first reserved entry.
  int initial_plt_entry_size_;
  // What to report in map file.
  const char *name_;
};

// Add an entry to the PLT.

template<int size, bool big_endian>
void
Output_data_plt_powerpc<size, big_endian>::add_entry(Symbol* gsym)
{
  if (!gsym->has_plt_offset())
    {
      section_size_type off = this->current_data_size();
      if (off == 0)
	off += this->first_plt_entry_offset();
      gsym->set_plt_offset(off);
      gsym->set_needs_dynsym_entry();
      unsigned int dynrel = elfcpp::R_POWERPC_JMP_SLOT;
      this->rel_->add_global(gsym, dynrel, this, off, 0);
      off += plt_entry_size;
      this->set_current_data_size(off);
    }
}

// Add an entry for a global ifunc symbol that resolves locally, to the IPLT.

template<int size, bool big_endian>
void
Output_data_plt_powerpc<size, big_endian>::add_ifunc_entry(Symbol* gsym)
{
  if (!gsym->has_plt_offset())
    {
      section_size_type off = this->current_data_size();
      gsym->set_plt_offset(off);
      unsigned int dynrel = elfcpp::R_POWERPC_IRELATIVE;
      if (size == 64)
	dynrel = elfcpp::R_PPC64_JMP_IREL;
      this->rel_->add_symbolless_global_addend(gsym, dynrel, this, off, 0);
      off += plt_entry_size;
      this->set_current_data_size(off);
    }
}

// Add an entry for a local ifunc symbol to the IPLT.

template<int size, bool big_endian>
void
Output_data_plt_powerpc<size, big_endian>::add_local_ifunc_entry(
    Sized_relobj_file<size, big_endian>* relobj,
    unsigned int local_sym_index)
{
  if (!relobj->local_has_plt_offset(local_sym_index))
    {
      section_size_type off = this->current_data_size();
      relobj->set_local_plt_offset(local_sym_index, off);
      unsigned int dynrel = elfcpp::R_POWERPC_IRELATIVE;
      if (size == 64)
	dynrel = elfcpp::R_PPC64_JMP_IREL;
      this->rel_->add_symbolless_local_addend(relobj, local_sym_index, dynrel,
					      this, off, 0);
      off += plt_entry_size;
      this->set_current_data_size(off);
    }
}

static const uint32_t add_0_11_11	= 0x7c0b5a14;
static const uint32_t add_2_2_11	= 0x7c425a14;
static const uint32_t add_3_3_2		= 0x7c631214;
static const uint32_t add_3_3_13	= 0x7c636a14;
static const uint32_t add_11_0_11	= 0x7d605a14;
static const uint32_t add_12_2_11	= 0x7d825a14;
static const uint32_t add_12_12_11	= 0x7d8c5a14;
static const uint32_t addi_11_11	= 0x396b0000;
static const uint32_t addi_12_12	= 0x398c0000;
static const uint32_t addi_2_2		= 0x38420000;
static const uint32_t addi_3_2		= 0x38620000;
static const uint32_t addi_3_3		= 0x38630000;
static const uint32_t addis_0_2		= 0x3c020000;
static const uint32_t addis_0_13	= 0x3c0d0000;
static const uint32_t addis_11_11	= 0x3d6b0000;
static const uint32_t addis_11_30	= 0x3d7e0000;
static const uint32_t addis_12_12	= 0x3d8c0000;
static const uint32_t addis_12_2	= 0x3d820000;
static const uint32_t addis_3_2		= 0x3c620000;
static const uint32_t addis_3_13	= 0x3c6d0000;
static const uint32_t b			= 0x48000000;
static const uint32_t bcl_20_31		= 0x429f0005;
static const uint32_t bctr		= 0x4e800420;
static const uint32_t blr		= 0x4e800020;
static const uint32_t blrl		= 0x4e800021;
static const uint32_t bnectr_p4		= 0x4ce20420;
static const uint32_t cmpldi_2_0	= 0x28220000;
static const uint32_t cror_15_15_15	= 0x4def7b82;
static const uint32_t cror_31_31_31	= 0x4ffffb82;
static const uint32_t ld_0_1		= 0xe8010000;
static const uint32_t ld_0_12		= 0xe80c0000;
static const uint32_t ld_11_12		= 0xe96c0000;
static const uint32_t ld_11_2		= 0xe9620000;
static const uint32_t ld_2_1		= 0xe8410000;
static const uint32_t ld_2_11		= 0xe84b0000;
static const uint32_t ld_2_12		= 0xe84c0000;
static const uint32_t ld_2_2		= 0xe8420000;
static const uint32_t lfd_0_1		= 0xc8010000;
static const uint32_t li_0_0		= 0x38000000;
static const uint32_t li_12_0		= 0x39800000;
static const uint32_t lis_0_0		= 0x3c000000;
static const uint32_t lis_11		= 0x3d600000;
static const uint32_t lis_12		= 0x3d800000;
static const uint32_t lwz_0_12		= 0x800c0000;
static const uint32_t lwz_11_11		= 0x816b0000;
static const uint32_t lwz_11_30		= 0x817e0000;
static const uint32_t lwz_12_12		= 0x818c0000;
static const uint32_t lwzu_0_12		= 0x840c0000;
static const uint32_t lvx_0_12_0	= 0x7c0c00ce;
static const uint32_t mflr_0		= 0x7c0802a6;
static const uint32_t mflr_11		= 0x7d6802a6;
static const uint32_t mflr_12		= 0x7d8802a6;
static const uint32_t mtctr_0		= 0x7c0903a6;
static const uint32_t mtctr_11		= 0x7d6903a6;
static const uint32_t mtctr_12		= 0x7d8903a6;
static const uint32_t mtlr_0		= 0x7c0803a6;
static const uint32_t mtlr_12		= 0x7d8803a6;
static const uint32_t nop		= 0x60000000;
static const uint32_t ori_0_0_0		= 0x60000000;
static const uint32_t std_0_1		= 0xf8010000;
static const uint32_t std_0_12		= 0xf80c0000;
static const uint32_t std_2_1		= 0xf8410000;
static const uint32_t stfd_0_1		= 0xd8010000;
static const uint32_t stvx_0_12_0	= 0x7c0c01ce;
static const uint32_t sub_11_11_12	= 0x7d6c5850;
static const uint32_t xor_11_11_11	= 0x7d6b5a78;

// Write out the PLT.

template<int size, bool big_endian>
void
Output_data_plt_powerpc<size, big_endian>::do_write(Output_file* of)
{
  if (size == 32 && this->name_[3] != 'I')
    {
      const section_size_type offset = this->offset();
      const section_size_type oview_size
	= convert_to_section_size_type(this->data_size());
      unsigned char* const oview = of->get_output_view(offset, oview_size);
      unsigned char* pov = oview;
      unsigned char* endpov = oview + oview_size;

      // The address of the .glink branch table
      const Output_data_glink<size, big_endian>* glink
	= this->targ_->glink_section();
      elfcpp::Elf_types<32>::Elf_Addr branch_tab = glink->address();

      while (pov < endpov)
	{
	  elfcpp::Swap<32, big_endian>::writeval(pov, branch_tab);
	  pov += 4;
	  branch_tab += 4;
	}

      of->write_output_view(offset, oview_size, oview);
    }
}

// Create the PLT section.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::make_plt_section(Symbol_table* symtab,
						   Layout* layout)
{
  if (this->plt_ == NULL)
    {
      if (this->got_ == NULL)
	this->got_section(symtab, layout);

      if (this->glink_ == NULL)
	make_glink_section(layout);

      // Ensure that .rela.dyn always appears before .rela.plt  This is
      // necessary due to how, on PowerPC and some other targets, .rela.dyn
      // needs to include .rela.plt in its range.
      this->rela_dyn_section(layout);

      Reloc_section* plt_rel = new Reloc_section(false);
      layout->add_output_section_data(".rela.plt", elfcpp::SHT_RELA,
				      elfcpp::SHF_ALLOC, plt_rel,
				      ORDER_DYNAMIC_PLT_RELOCS, false);
      this->plt_
	= new Output_data_plt_powerpc<size, big_endian>(this, plt_rel,
							size == 32 ? 0 : 24,
							"** PLT");
      layout->add_output_section_data(".plt",
				      (size == 32
				       ? elfcpp::SHT_PROGBITS
				       : elfcpp::SHT_NOBITS),
				      elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE,
				      this->plt_,
				      (size == 32
				       ? ORDER_SMALL_DATA
				       : ORDER_SMALL_BSS),
				      false);
    }
}

// Create the IPLT section.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::make_iplt_section(Symbol_table* symtab,
						    Layout* layout)
{
  if (this->iplt_ == NULL)
    {
      this->make_plt_section(symtab, layout);

      Reloc_section* iplt_rel = new Reloc_section(false);
      this->rela_dyn_->output_section()->add_output_section_data(iplt_rel);
      this->iplt_
	= new Output_data_plt_powerpc<size, big_endian>(this, iplt_rel,
							0, "** IPLT");
      this->plt_->output_section()->add_output_section_data(this->iplt_);
    }
}

// A section for huge long branch addresses, similar to plt section.

template<int size, bool big_endian>
class Output_data_brlt_powerpc : public Output_section_data_build
{
 public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  typedef Output_data_reloc<elfcpp::SHT_RELA, true,
			    size, big_endian> Reloc_section;

  Output_data_brlt_powerpc(Target_powerpc<size, big_endian>* targ,
			   Reloc_section* brlt_rel)
    : Output_section_data_build(size == 32 ? 4 : 8),
      rel_(brlt_rel),
      targ_(targ)
  { }

  void
  reset_brlt_sizes()
  {
    this->reset_data_size();
    this->rel_->reset_data_size();
  }

  void
  finalize_brlt_sizes()
  {
    this->finalize_data_size();
    this->rel_->finalize_data_size();
  }

  // Add a reloc for an entry in the BRLT.
  void
  add_reloc(Address to, unsigned int off)
  { this->rel_->add_relative(elfcpp::R_POWERPC_RELATIVE, this, off, to); }

  // Update section and reloc section size.
  void
  set_current_size(unsigned int num_branches)
  {
    this->reset_address_and_file_offset();
    this->set_current_data_size(num_branches * 16);
    this->finalize_data_size();
    Output_section* os = this->output_section();
    os->set_section_offsets_need_adjustment();
    if (this->rel_ != NULL)
      {
	unsigned int reloc_size
	  = Reloc_types<elfcpp::SHT_RELA, size, big_endian>::reloc_size;
	this->rel_->reset_address_and_file_offset();
	this->rel_->set_current_data_size(num_branches * reloc_size);
	this->rel_->finalize_data_size();
	Output_section* os = this->rel_->output_section();
	os->set_section_offsets_need_adjustment();
      }
  }

 protected:
  void
  do_adjust_output_section(Output_section* os)
  {
    os->set_entsize(0);
  }

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, "** BRLT"); }

 private:
  // Write out the BRLT data.
  void
  do_write(Output_file*);

  // The reloc section.
  Reloc_section* rel_;
  Target_powerpc<size, big_endian>* targ_;
};

// Make the branch lookup table section.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::make_brlt_section(Layout* layout)
{
  if (size == 64 && this->brlt_section_ == NULL)
    {
      Reloc_section* brlt_rel = NULL;
      bool is_pic = parameters->options().output_is_position_independent();
      if (is_pic)
	{
	  // When PIC we can't fill in .branch_lt (like .plt it can be
	  // a bss style section) but must initialise at runtime via
	  // dynamic relocats.
	  this->rela_dyn_section(layout);
	  brlt_rel = new Reloc_section(false);
	  this->rela_dyn_->output_section()->add_output_section_data(brlt_rel);
	}
      this->brlt_section_
	= new Output_data_brlt_powerpc<size, big_endian>(this, brlt_rel);
      if (this->plt_ && is_pic)
	this->plt_->output_section()
	  ->add_output_section_data(this->brlt_section_);
      else
	layout->add_output_section_data(".branch_lt",
					(is_pic ? elfcpp::SHT_NOBITS
					 : elfcpp::SHT_PROGBITS),
					elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE,
					this->brlt_section_,
					(is_pic ? ORDER_SMALL_BSS
					 : ORDER_SMALL_DATA),
					false);
    }
}

// Write out .branch_lt when non-PIC.

template<int size, bool big_endian>
void
Output_data_brlt_powerpc<size, big_endian>::do_write(Output_file* of)
{
  if (size == 64 && !parameters->options().output_is_position_independent())
    {
      const section_size_type offset = this->offset();
      const section_size_type oview_size
	= convert_to_section_size_type(this->data_size());
      unsigned char* const oview = of->get_output_view(offset, oview_size);

      this->targ_->write_branch_lookup_table(oview);
      of->write_output_view(offset, oview_size, oview);
    }
}

static inline uint32_t
l(uint32_t a)
{
  return a & 0xffff;
}

static inline uint32_t
hi(uint32_t a)
{
  return l(a >> 16);
}

static inline uint32_t
ha(uint32_t a)
{
  return hi(a + 0x8000);
}

template<int size>
struct Eh_cie
{
  static const unsigned char eh_frame_cie[12];
};

template<int size>
const unsigned char Eh_cie<size>::eh_frame_cie[] =
{
  1,					// CIE version.
  'z', 'R', 0,				// Augmentation string.
  4,					// Code alignment.
  0x80 - size / 8 ,			// Data alignment.
  65,					// RA reg.
  1,					// Augmentation size.
  (elfcpp::DW_EH_PE_pcrel
   | elfcpp::DW_EH_PE_sdata4),		// FDE encoding.
  elfcpp::DW_CFA_def_cfa, 1, 0		// def_cfa: r1 offset 0.
};

// Describe __glink_PLTresolve use of LR, 64-bit version.
static const unsigned char glink_eh_frame_fde_64[] =
{
  0, 0, 0, 0,				// Replaced with offset to .glink.
  0, 0, 0, 0,				// Replaced with size of .glink.
  0,					// Augmentation size.
  elfcpp::DW_CFA_advance_loc + 1,
  elfcpp::DW_CFA_register, 65, 12,
  elfcpp::DW_CFA_advance_loc + 4,
  elfcpp::DW_CFA_restore_extended, 65
};

// Describe __glink_PLTresolve use of LR, 32-bit version.
static const unsigned char glink_eh_frame_fde_32[] =
{
  0, 0, 0, 0,				// Replaced with offset to .glink.
  0, 0, 0, 0,				// Replaced with size of .glink.
  0,					// Augmentation size.
  elfcpp::DW_CFA_advance_loc + 2,
  elfcpp::DW_CFA_register, 65, 0,
  elfcpp::DW_CFA_advance_loc + 4,
  elfcpp::DW_CFA_restore_extended, 65
};

static const unsigned char default_fde[] =
{
  0, 0, 0, 0,				// Replaced with offset to stubs.
  0, 0, 0, 0,				// Replaced with size of stubs.
  0,					// Augmentation size.
  elfcpp::DW_CFA_nop,			// Pad.
  elfcpp::DW_CFA_nop,
  elfcpp::DW_CFA_nop
};

template<bool big_endian>
static inline void
write_insn(unsigned char* p, uint32_t v)
{
  elfcpp::Swap<32, big_endian>::writeval(p, v);
}

// Stub_table holds information about plt and long branch stubs.
// Stubs are built in an area following some input section determined
// by group_sections().  This input section is converted to a relaxed
// input section allowing it to be resized to accommodate the stubs

template<int size, bool big_endian>
class Stub_table : public Output_relaxed_input_section
{
 public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  static const Address invalid_address = static_cast<Address>(0) - 1;

  Stub_table(Target_powerpc<size, big_endian>* targ)
    : Output_relaxed_input_section(NULL, 0, 0),
      targ_(targ), plt_call_stubs_(), long_branch_stubs_(),
      orig_data_size_(0), plt_size_(0), last_plt_size_(0),
      branch_size_(0), last_branch_size_(0), eh_frame_added_(false)
  { }

  // Delayed Output_relaxed_input_section init.
  void
  init(const Output_section::Input_section*, Output_section*);

  // Add a plt call stub.
  void
  add_plt_call_entry(const Sized_relobj_file<size, big_endian>*,
		     const Symbol*,
		     unsigned int,
		     Address);

  void
  add_plt_call_entry(const Sized_relobj_file<size, big_endian>*,
		     unsigned int,
		     unsigned int,
		     Address);

  // Find a given plt call stub.
  Address
  find_plt_call_entry(const Symbol*) const;

  Address
  find_plt_call_entry(const Sized_relobj_file<size, big_endian>*,
		      unsigned int) const;

  Address
  find_plt_call_entry(const Sized_relobj_file<size, big_endian>*,
		      const Symbol*,
		      unsigned int,
		      Address) const;

  Address
  find_plt_call_entry(const Sized_relobj_file<size, big_endian>*,
		      unsigned int,
		      unsigned int,
		      Address) const;

  // Add a long branch stub.
  void
  add_long_branch_entry(const Powerpc_relobj<size, big_endian>*, Address);

  Address
  find_long_branch_entry(const Powerpc_relobj<size, big_endian>*,
			 Address) const;

  void
  clear_stubs()
  {
    this->plt_call_stubs_.clear();
    this->plt_size_ = 0;
    this->long_branch_stubs_.clear();
    this->branch_size_ = 0;
  }

  Address
  set_address_and_size(const Output_section* os, Address off)
  {
    Address start_off = off;
    off += this->orig_data_size_;
    Address my_size = this->plt_size_ + this->branch_size_;
    if (my_size != 0)
      off = align_address(off, this->stub_align());
    // Include original section size and alignment padding in size
    my_size += off - start_off;
    this->reset_address_and_file_offset();
    this->set_current_data_size(my_size);
    this->set_address_and_file_offset(os->address() + start_off,
				      os->offset() + start_off);
    return my_size;
  }

  Address
  stub_address() const
  {
    return align_address(this->address() + this->orig_data_size_,
			 this->stub_align());
  }

  Address
  stub_offset() const
  {
    return align_address(this->offset() + this->orig_data_size_,
			 this->stub_align());
  }

  section_size_type
  plt_size() const
  { return this->plt_size_; }

  bool
  size_update()
  {
    Output_section* os = this->output_section();
    if (os->addralign() < this->stub_align())
      {
	os->set_addralign(this->stub_align());
	// FIXME: get rid of the insane checkpointing.
	// We can't increase alignment of the input section to which
	// stubs are attached;  The input section may be .init which
	// is pasted together with other .init sections to form a
	// function.  Aligning might insert zero padding resulting in
	// sigill.  However we do need to increase alignment of the
	// output section so that the align_address() on offset in
	// set_address_and_size() adds the same padding as the
	// align_address() on address in stub_address().
	// What's more, we need this alignment for the layout done in
	// relaxation_loop_body() so that the output section starts at
	// a suitably aligned address.
	os->checkpoint_set_addralign(this->stub_align());
      }
    if (this->last_plt_size_ != this->plt_size_
	|| this->last_branch_size_ != this->branch_size_)
      {
	this->last_plt_size_ = this->plt_size_;
	this->last_branch_size_ = this->branch_size_;
	return true;
      }
    return false;
  }

  // Add .eh_frame info for this stub section.  Unlike other linker
  // generated .eh_frame this is added late in the link, because we
  // only want the .eh_frame info if this particular stub section is
  // non-empty.
  void
  add_eh_frame(Layout* layout)
  {
    if (!this->eh_frame_added_)
      {
	if (!parameters->options().ld_generated_unwind_info())
	  return;

	// Since we add stub .eh_frame info late, it must be placed
	// after all other linker generated .eh_frame info so that
	// merge mapping need not be updated for input sections.
	// There is no provision to use a different CIE to that used
	// by .glink.
	if (!this->targ_->has_glink())
	  return;

	layout->add_eh_frame_for_plt(this,
				     Eh_cie<size>::eh_frame_cie,
				     sizeof (Eh_cie<size>::eh_frame_cie),
				     default_fde,
				     sizeof (default_fde));
	this->eh_frame_added_ = true;
      }
  }

  Target_powerpc<size, big_endian>*
  targ() const
  { return targ_; }

 private:
  class Plt_stub_ent;
  class Plt_stub_ent_hash;
  typedef Unordered_map<Plt_stub_ent, unsigned int,
			Plt_stub_ent_hash> Plt_stub_entries;

  // Alignment of stub section.
  unsigned int
  stub_align() const
  {
    if (size == 32)
      return 16;
    unsigned int min_align = 32;
    unsigned int user_align = 1 << parameters->options().plt_align();
    return std::max(user_align, min_align);
  }

  // Return the plt offset for the given call stub.
  Address
  plt_off(typename Plt_stub_entries::const_iterator p, bool* is_iplt) const
  {
    const Symbol* gsym = p->first.sym_;
    if (gsym != NULL)
      {
	*is_iplt = (gsym->type() == elfcpp::STT_GNU_IFUNC
		    && gsym->can_use_relative_reloc(false));
	return gsym->plt_offset();
      }
    else
      {
	*is_iplt = true;
	const Sized_relobj_file<size, big_endian>* relobj = p->first.object_;
	unsigned int local_sym_index = p->first.locsym_;
	return relobj->local_plt_offset(local_sym_index);
      }
  }

  // Size of a given plt call stub.
  unsigned int
  plt_call_size(typename Plt_stub_entries::const_iterator p) const
  {
    if (size == 32)
      return 16;

    bool is_iplt;
    Address plt_addr = this->plt_off(p, &is_iplt);
    if (is_iplt)
      plt_addr += this->targ_->iplt_section()->address();
    else
      plt_addr += this->targ_->plt_section()->address();
    Address got_addr = this->targ_->got_section()->output_section()->address();
    const Powerpc_relobj<size, big_endian>* ppcobj = static_cast
      <const Powerpc_relobj<size, big_endian>*>(p->first.object_);
    got_addr += ppcobj->toc_base_offset();
    Address off = plt_addr - got_addr;
    bool static_chain = parameters->options().plt_static_chain();
    bool thread_safe = this->targ_->plt_thread_safe();
    unsigned int bytes = (4 * 5
			  + 4 * static_chain
			  + 8 * thread_safe
			  + 4 * (ha(off) != 0)
			  + 4 * (ha(off + 8 + 8 * static_chain) != ha(off)));
    unsigned int align = 1 << parameters->options().plt_align();
    if (align > 1)
      bytes = (bytes + align - 1) & -align;
    return bytes;
  }

  // Return long branch stub size.
  unsigned int
  branch_stub_size(Address to)
  {
    Address loc
      = this->stub_address() + this->last_plt_size_ + this->branch_size_;
    if (to - loc + (1 << 25) < 2 << 25)
      return 4;
    if (size == 64 || !parameters->options().output_is_position_independent())
      return 16;
    return 32;
  }

  // Write out stubs.
  void
  do_write(Output_file*);

  // Plt call stub keys.
  class Plt_stub_ent
  {
  public:
    Plt_stub_ent(const Symbol* sym)
      : sym_(sym), object_(0), addend_(0), locsym_(0)
    { }

    Plt_stub_ent(const Sized_relobj_file<size, big_endian>* object,
		 unsigned int locsym_index)
      : sym_(NULL), object_(object), addend_(0), locsym_(locsym_index)
    { }

    Plt_stub_ent(const Sized_relobj_file<size, big_endian>* object,
		 const Symbol* sym,
		 unsigned int r_type,
		 Address addend)
      : sym_(sym), object_(0), addend_(0), locsym_(0)
    {
      if (size != 32)
	this->addend_ = addend;
      else if (parameters->options().output_is_position_independent()
	       && r_type == elfcpp::R_PPC_PLTREL24)
	{
	  this->addend_ = addend;
	  if (this->addend_ >= 32768)
	    this->object_ = object;
	}
    }

    Plt_stub_ent(const Sized_relobj_file<size, big_endian>* object,
		 unsigned int locsym_index,
		 unsigned int r_type,
		 Address addend)
      : sym_(NULL), object_(object), addend_(0), locsym_(locsym_index)
    {
      if (size != 32)
	this->addend_ = addend;
      else if (parameters->options().output_is_position_independent()
	       && r_type == elfcpp::R_PPC_PLTREL24)
	this->addend_ = addend;
    }

    bool operator==(const Plt_stub_ent& that) const
    {
      return (this->sym_ == that.sym_
	      && this->object_ == that.object_
	      && this->addend_ == that.addend_
	      && this->locsym_ == that.locsym_);
    }

    const Symbol* sym_;
    const Sized_relobj_file<size, big_endian>* object_;
    typename elfcpp::Elf_types<size>::Elf_Addr addend_;
    unsigned int locsym_;
  };

  class Plt_stub_ent_hash
  {
  public:
    size_t operator()(const Plt_stub_ent& ent) const
    {
      return (reinterpret_cast<uintptr_t>(ent.sym_)
	      ^ reinterpret_cast<uintptr_t>(ent.object_)
	      ^ ent.addend_
	      ^ ent.locsym_);
    }
  };

  // Long branch stub keys.
  class Branch_stub_ent
  {
  public:
    Branch_stub_ent(const Powerpc_relobj<size, big_endian>* obj, Address to)
      : dest_(to), toc_base_off_(0)
    {
      if (size == 64)
	toc_base_off_ = obj->toc_base_offset();
    }

    bool operator==(const Branch_stub_ent& that) const
    {
      return (this->dest_ == that.dest_
	      && (size == 32
		  || this->toc_base_off_ == that.toc_base_off_));
    }

    Address dest_;
    unsigned int toc_base_off_;
  };

  class Branch_stub_ent_hash
  {
  public:
    size_t operator()(const Branch_stub_ent& ent) const
    { return ent.dest_ ^ ent.toc_base_off_; }
  };

  // In a sane world this would be a global.
  Target_powerpc<size, big_endian>* targ_;
  // Map sym/object/addend to stub offset.
  Plt_stub_entries plt_call_stubs_;
  // Map destination address to stub offset.
  typedef Unordered_map<Branch_stub_ent, unsigned int,
			Branch_stub_ent_hash> Branch_stub_entries;
  Branch_stub_entries long_branch_stubs_;
  // size of input section
  section_size_type orig_data_size_;
  // size of stubs
  section_size_type plt_size_, last_plt_size_, branch_size_, last_branch_size_;
  // Whether .eh_frame info has been created for this stub section.
  bool eh_frame_added_;
};

// Make a new stub table, and record.

template<int size, bool big_endian>
Stub_table<size, big_endian>*
Target_powerpc<size, big_endian>::new_stub_table()
{
  Stub_table<size, big_endian>* stub_table
    = new Stub_table<size, big_endian>(this);
  this->stub_tables_.push_back(stub_table);
  return stub_table;
}

// Delayed stub table initialisation, because we create the stub table
// before we know to which section it will be attached.

template<int size, bool big_endian>
void
Stub_table<size, big_endian>::init(
    const Output_section::Input_section* owner,
    Output_section* output_section)
{
  this->set_relobj(owner->relobj());
  this->set_shndx(owner->shndx());
  this->set_addralign(this->relobj()->section_addralign(this->shndx()));
  this->set_output_section(output_section);
  this->orig_data_size_ = owner->current_data_size();

  std::vector<Output_relaxed_input_section*> new_relaxed;
  new_relaxed.push_back(this);
  output_section->convert_input_sections_to_relaxed_sections(new_relaxed);
}

// Add a plt call stub, if we do not already have one for this
// sym/object/addend combo.

template<int size, bool big_endian>
void
Stub_table<size, big_endian>::add_plt_call_entry(
    const Sized_relobj_file<size, big_endian>* object,
    const Symbol* gsym,
    unsigned int r_type,
    Address addend)
{
  Plt_stub_ent ent(object, gsym, r_type, addend);
  Address off = this->plt_size_;
  std::pair<typename Plt_stub_entries::iterator, bool> p
    = this->plt_call_stubs_.insert(std::make_pair(ent, off));
  if (p.second)
    this->plt_size_ = off + this->plt_call_size(p.first);
}

template<int size, bool big_endian>
void
Stub_table<size, big_endian>::add_plt_call_entry(
    const Sized_relobj_file<size, big_endian>* object,
    unsigned int locsym_index,
    unsigned int r_type,
    Address addend)
{
  Plt_stub_ent ent(object, locsym_index, r_type, addend);
  Address off = this->plt_size_;
  std::pair<typename Plt_stub_entries::iterator, bool> p
    = this->plt_call_stubs_.insert(std::make_pair(ent, off));
  if (p.second)
    this->plt_size_ = off + this->plt_call_size(p.first);
}

// Find a plt call stub.

template<int size, bool big_endian>
typename Stub_table<size, big_endian>::Address
Stub_table<size, big_endian>::find_plt_call_entry(
    const Sized_relobj_file<size, big_endian>* object,
    const Symbol* gsym,
    unsigned int r_type,
    Address addend) const
{
  Plt_stub_ent ent(object, gsym, r_type, addend);
  typename Plt_stub_entries::const_iterator p = this->plt_call_stubs_.find(ent);
  return p == this->plt_call_stubs_.end() ? invalid_address : p->second;
}

template<int size, bool big_endian>
typename Stub_table<size, big_endian>::Address
Stub_table<size, big_endian>::find_plt_call_entry(const Symbol* gsym) const
{
  Plt_stub_ent ent(gsym);
  typename Plt_stub_entries::const_iterator p = this->plt_call_stubs_.find(ent);
  return p == this->plt_call_stubs_.end() ? invalid_address : p->second;
}

template<int size, bool big_endian>
typename Stub_table<size, big_endian>::Address
Stub_table<size, big_endian>::find_plt_call_entry(
    const Sized_relobj_file<size, big_endian>* object,
    unsigned int locsym_index,
    unsigned int r_type,
    Address addend) const
{
  Plt_stub_ent ent(object, locsym_index, r_type, addend);
  typename Plt_stub_entries::const_iterator p = this->plt_call_stubs_.find(ent);
  return p == this->plt_call_stubs_.end() ? invalid_address : p->second;
}

template<int size, bool big_endian>
typename Stub_table<size, big_endian>::Address
Stub_table<size, big_endian>::find_plt_call_entry(
    const Sized_relobj_file<size, big_endian>* object,
    unsigned int locsym_index) const
{
  Plt_stub_ent ent(object, locsym_index);
  typename Plt_stub_entries::const_iterator p = this->plt_call_stubs_.find(ent);
  return p == this->plt_call_stubs_.end() ? invalid_address : p->second;
}

// Add a long branch stub if we don't already have one to given
// destination.

template<int size, bool big_endian>
void
Stub_table<size, big_endian>::add_long_branch_entry(
    const Powerpc_relobj<size, big_endian>* object,
    Address to)
{
  Branch_stub_ent ent(object, to);
  Address off = this->branch_size_;
  if (this->long_branch_stubs_.insert(std::make_pair(ent, off)).second)
    {
      unsigned int stub_size = this->branch_stub_size(to);
      this->branch_size_ = off + stub_size;
      if (size == 64 && stub_size != 4)
	this->targ_->add_branch_lookup_table(to);
    }
}

// Find long branch stub.

template<int size, bool big_endian>
typename Stub_table<size, big_endian>::Address
Stub_table<size, big_endian>::find_long_branch_entry(
    const Powerpc_relobj<size, big_endian>* object,
    Address to) const
{
  Branch_stub_ent ent(object, to);
  typename Branch_stub_entries::const_iterator p
    = this->long_branch_stubs_.find(ent);
  return p == this->long_branch_stubs_.end() ? invalid_address : p->second;
}

// A class to handle .glink.

template<int size, bool big_endian>
class Output_data_glink : public Output_section_data
{
 public:
  static const int pltresolve_size = 16*4;

  Output_data_glink(Target_powerpc<size, big_endian>* targ)
    : Output_section_data(16), targ_(targ)
  { }

  void
  add_eh_frame(Layout* layout)
  {
    if (!parameters->options().ld_generated_unwind_info())
      return;

    if (size == 64)
      layout->add_eh_frame_for_plt(this,
				   Eh_cie<64>::eh_frame_cie,
				   sizeof (Eh_cie<64>::eh_frame_cie),
				   glink_eh_frame_fde_64,
				   sizeof (glink_eh_frame_fde_64));
    else
      {
	// 32-bit .glink can use the default since the CIE return
	// address reg, LR, is valid.
	layout->add_eh_frame_for_plt(this,
				     Eh_cie<32>::eh_frame_cie,
				     sizeof (Eh_cie<32>::eh_frame_cie),
				     default_fde,
				     sizeof (default_fde));
	// Except where LR is used in a PIC __glink_PLTresolve.
	if (parameters->options().output_is_position_independent())
	  layout->add_eh_frame_for_plt(this,
				       Eh_cie<32>::eh_frame_cie,
				       sizeof (Eh_cie<32>::eh_frame_cie),
				       glink_eh_frame_fde_32,
				       sizeof (glink_eh_frame_fde_32));
      }
  }

 protected:
  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** glink")); }

 private:
  void
  set_final_data_size();

  // Write out .glink
  void
  do_write(Output_file*);

  // Allows access to .got and .plt for do_write.
  Target_powerpc<size, big_endian>* targ_;
};

template<int size, bool big_endian>
void
Output_data_glink<size, big_endian>::set_final_data_size()
{
  unsigned int count = this->targ_->plt_entry_count();
  section_size_type total = 0;

  if (count != 0)
    {
      if (size == 32)
	{
	  // space for branch table
	  total += 4 * (count - 1);

	  total += -total & 15;
	  total += this->pltresolve_size;
	}
      else
	{
	  total += this->pltresolve_size;

	  // space for branch table
	  total += 8 * count;
	  if (count > 0x8000)
	    total += 4 * (count - 0x8000);
	}
    }

  this->set_data_size(total);
}

// Write out plt and long branch stub code.

template<int size, bool big_endian>
void
Stub_table<size, big_endian>::do_write(Output_file* of)
{
  if (this->plt_call_stubs_.empty()
      && this->long_branch_stubs_.empty())
    return;

  const section_size_type start_off = this->offset();
  const section_size_type off = this->stub_offset();
  const section_size_type oview_size =
    convert_to_section_size_type(this->data_size() - (off - start_off));
  unsigned char* const oview = of->get_output_view(off, oview_size);
  unsigned char* p;

  if (size == 64)
    {
      const Output_data_got_powerpc<size, big_endian>* got
	= this->targ_->got_section();
      Address got_os_addr = got->output_section()->address();

      if (!this->plt_call_stubs_.empty())
	{
	  // The base address of the .plt section.
	  Address plt_base = this->targ_->plt_section()->address();
	  Address iplt_base = invalid_address;

	  // Write out plt call stubs.
	  typename Plt_stub_entries::const_iterator cs;
	  for (cs = this->plt_call_stubs_.begin();
	       cs != this->plt_call_stubs_.end();
	       ++cs)
	    {
	      bool is_iplt;
	      Address pltoff = this->plt_off(cs, &is_iplt);
	      Address plt_addr = pltoff;
	      if (is_iplt)
		{
		  if (iplt_base == invalid_address)
		    iplt_base = this->targ_->iplt_section()->address();
		  plt_addr += iplt_base;
		}
	      else
		plt_addr += plt_base;
	      const Powerpc_relobj<size, big_endian>* ppcobj = static_cast
		<const Powerpc_relobj<size, big_endian>*>(cs->first.object_);
	      Address got_addr = got_os_addr + ppcobj->toc_base_offset();
	      Address off = plt_addr - got_addr;

	      if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)
		gold_error(_("%s: linkage table error against `%s'"),
			   cs->first.object_->name().c_str(),
			   cs->first.sym_->demangled_name().c_str());

	      bool static_chain = parameters->options().plt_static_chain();
	      bool thread_safe = this->targ_->plt_thread_safe();
	      bool use_fake_dep = false;
	      Address cmp_branch_off = 0;
	      if (thread_safe)
		{
		  unsigned int pltindex
		    = ((pltoff - this->targ_->first_plt_entry_offset())
		       / this->targ_->plt_entry_size());
		  Address glinkoff
		    = (this->targ_->glink_section()->pltresolve_size
		       + pltindex * 8);
		  if (pltindex > 32768)
		    glinkoff += (pltindex - 32768) * 4;
		  Address to
		    = this->targ_->glink_section()->address() + glinkoff;
		  Address from
		    = (this->stub_address() + cs->second + 24
		       + 4 * (ha(off) != 0)
		       + 4 * (ha(off + 8 + 8 * static_chain) != ha(off))
		       + 4 * static_chain);
		  cmp_branch_off = to - from;
		  use_fake_dep = cmp_branch_off + (1 << 25) >= (1 << 26);
		}

	      p = oview + cs->second;
	      if (ha(off) != 0)
		{
		  write_insn<big_endian>(p, std_2_1 + 40),		p += 4;
		  write_insn<big_endian>(p, addis_12_2 + ha(off)),	p += 4;
		  write_insn<big_endian>(p, ld_11_12 + l(off)),		p += 4;
		  if (ha(off + 8 + 8 * static_chain) != ha(off))
		    {
		      write_insn<big_endian>(p, addi_12_12 + l(off)),	p += 4;
		      off = 0;
		    }
		  write_insn<big_endian>(p, mtctr_11),			p += 4;
		  if (use_fake_dep)
		    {
		      write_insn<big_endian>(p, xor_11_11_11),		p += 4;
		      write_insn<big_endian>(p, add_12_12_11),		p += 4;
		    }
		  write_insn<big_endian>(p, ld_2_12 + l(off + 8)),	p += 4;
		  if (static_chain)
		    write_insn<big_endian>(p, ld_11_12 + l(off + 16)),	p += 4;
		}
	      else
		{
		  write_insn<big_endian>(p, std_2_1 + 40),		p += 4;
		  write_insn<big_endian>(p, ld_11_2 + l(off)),		p += 4;
		  if (ha(off + 8 + 8 * static_chain) != ha(off))
		    {
		      write_insn<big_endian>(p, addi_2_2 + l(off)),	p += 4;
		      off = 0;
		    }
		  write_insn<big_endian>(p, mtctr_11),			p += 4;
		  if (use_fake_dep)
		    {
		      write_insn<big_endian>(p, xor_11_11_11),		p += 4;
		      write_insn<big_endian>(p, add_2_2_11),		p += 4;
		    }
		  if (static_chain)
		    write_insn<big_endian>(p, ld_11_2 + l(off + 16)),	p += 4;
		  write_insn<big_endian>(p, ld_2_2 + l(off + 8)),	p += 4;
		}
	      if (thread_safe && !use_fake_dep)
		{
		  write_insn<big_endian>(p, cmpldi_2_0),		p += 4;
		  write_insn<big_endian>(p, bnectr_p4),			p += 4;
		  write_insn<big_endian>(p, b | (cmp_branch_off & 0x3fffffc));
		}
	      else
		write_insn<big_endian>(p, bctr);
	    }
	}

      // Write out long branch stubs.
      typename Branch_stub_entries::const_iterator bs;
      for (bs = this->long_branch_stubs_.begin();
	   bs != this->long_branch_stubs_.end();
	   ++bs)
	{
	  p = oview + this->plt_size_ + bs->second;
	  Address loc = this->stub_address() + this->plt_size_ + bs->second;
	  Address delta = bs->first.dest_ - loc;
	  if (delta + (1 << 25) < 2 << 25)
	    write_insn<big_endian>(p, b | (delta & 0x3fffffc));
	  else
	    {
	      Address brlt_addr
		= this->targ_->find_branch_lookup_table(bs->first.dest_);
	      gold_assert(brlt_addr != invalid_address);
	      brlt_addr += this->targ_->brlt_section()->address();
	      Address got_addr = got_os_addr + bs->first.toc_base_off_;
	      Address brltoff = brlt_addr - got_addr;
	      if (ha(brltoff) == 0)
		{
		  write_insn<big_endian>(p, ld_11_2 + l(brltoff)),	p += 4;
		}
	      else
		{
		  write_insn<big_endian>(p, addis_12_2 + ha(brltoff)),	p += 4;
		  write_insn<big_endian>(p, ld_11_12 + l(brltoff)),	p += 4;
		}
	      write_insn<big_endian>(p, mtctr_11),			p += 4;
	      write_insn<big_endian>(p, bctr);
	    }
	}
    }
  else
    {
      if (!this->plt_call_stubs_.empty())
	{
	  // The base address of the .plt section.
	  Address plt_base = this->targ_->plt_section()->address();
	  Address iplt_base = invalid_address;
	  // The address of _GLOBAL_OFFSET_TABLE_.
	  Address g_o_t = invalid_address;

	  // Write out plt call stubs.
	  typename Plt_stub_entries::const_iterator cs;
	  for (cs = this->plt_call_stubs_.begin();
	       cs != this->plt_call_stubs_.end();
	       ++cs)
	    {
	      bool is_iplt;
	      Address plt_addr = this->plt_off(cs, &is_iplt);
	      if (is_iplt)
		{
		  if (iplt_base == invalid_address)
		    iplt_base = this->targ_->iplt_section()->address();
		  plt_addr += iplt_base;
		}
	      else
		plt_addr += plt_base;

	      p = oview + cs->second;
	      if (parameters->options().output_is_position_independent())
		{
		  Address got_addr;
		  const Powerpc_relobj<size, big_endian>* ppcobj
		    = (static_cast<const Powerpc_relobj<size, big_endian>*>
		       (cs->first.object_));
		  if (ppcobj != NULL && cs->first.addend_ >= 32768)
		    {
		      unsigned int got2 = ppcobj->got2_shndx();
		      got_addr = ppcobj->get_output_section_offset(got2);
		      gold_assert(got_addr != invalid_address);
		      got_addr += (ppcobj->output_section(got2)->address()
				   + cs->first.addend_);
		    }
		  else
		    {
		      if (g_o_t == invalid_address)
			{
			  const Output_data_got_powerpc<size, big_endian>* got
			    = this->targ_->got_section();
			  g_o_t = got->address() + got->g_o_t();
			}
		      got_addr = g_o_t;
		    }

		  Address off = plt_addr - got_addr;
		  if (ha(off) == 0)
		    {
		      write_insn<big_endian>(p +  0, lwz_11_30 + l(off));
		      write_insn<big_endian>(p +  4, mtctr_11);
		      write_insn<big_endian>(p +  8, bctr);
		    }
		  else
		    {
		      write_insn<big_endian>(p +  0, addis_11_30 + ha(off));
		      write_insn<big_endian>(p +  4, lwz_11_11 + l(off));
		      write_insn<big_endian>(p +  8, mtctr_11);
		      write_insn<big_endian>(p + 12, bctr);
		    }
		}
	      else
		{
		  write_insn<big_endian>(p +  0, lis_11 + ha(plt_addr));
		  write_insn<big_endian>(p +  4, lwz_11_11 + l(plt_addr));
		  write_insn<big_endian>(p +  8, mtctr_11);
		  write_insn<big_endian>(p + 12, bctr);
		}
	    }
	}

      // Write out long branch stubs.
      typename Branch_stub_entries::const_iterator bs;
      for (bs = this->long_branch_stubs_.begin();
	   bs != this->long_branch_stubs_.end();
	   ++bs)
	{
	  p = oview + this->plt_size_ + bs->second;
	  Address loc = this->stub_address() + this->plt_size_ + bs->second;
	  Address delta = bs->first.dest_ - loc;
	  if (delta + (1 << 25) < 2 << 25)
	    write_insn<big_endian>(p, b | (delta & 0x3fffffc));
	  else if (!parameters->options().output_is_position_independent())
	    {
	      write_insn<big_endian>(p +  0, lis_12 + ha(bs->first.dest_));
	      write_insn<big_endian>(p +  4, addi_12_12 + l(bs->first.dest_));
	      write_insn<big_endian>(p +  8, mtctr_12);
	      write_insn<big_endian>(p + 12, bctr);
	    }
	  else
	    {
	      delta -= 8;
	      write_insn<big_endian>(p +  0, mflr_0);
	      write_insn<big_endian>(p +  4, bcl_20_31);
	      write_insn<big_endian>(p +  8, mflr_12);
	      write_insn<big_endian>(p + 12, addis_12_12 + ha(delta));
	      write_insn<big_endian>(p + 16, addi_12_12 + l(delta));
	      write_insn<big_endian>(p + 20, mtlr_0);
	      write_insn<big_endian>(p + 24, mtctr_12);
	      write_insn<big_endian>(p + 28, bctr);
	    }
	}
    }
}

// Write out .glink.

template<int size, bool big_endian>
void
Output_data_glink<size, big_endian>::do_write(Output_file* of)
{
  const section_size_type off = this->offset();
  const section_size_type oview_size =
    convert_to_section_size_type(this->data_size());
  unsigned char* const oview = of->get_output_view(off, oview_size);
  unsigned char* p;

  // The base address of the .plt section.
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  Address plt_base = this->targ_->plt_section()->address();

  if (size == 64)
    {
      // Write pltresolve stub.
      p = oview;
      Address after_bcl = this->address() + 16;
      Address pltoff = plt_base - after_bcl;

      elfcpp::Swap<64, big_endian>::writeval(p, pltoff),	p += 8;

      write_insn<big_endian>(p, mflr_12),			p += 4;
      write_insn<big_endian>(p, bcl_20_31),			p += 4;
      write_insn<big_endian>(p, mflr_11),			p += 4;
      write_insn<big_endian>(p, ld_2_11 + l(-16)),		p += 4;
      write_insn<big_endian>(p, mtlr_12),			p += 4;
      write_insn<big_endian>(p, add_12_2_11),			p += 4;
      write_insn<big_endian>(p, ld_11_12 + 0),			p += 4;
      write_insn<big_endian>(p, ld_2_12 + 8),			p += 4;
      write_insn<big_endian>(p, mtctr_11),			p += 4;
      write_insn<big_endian>(p, ld_11_12 + 16),			p += 4;
      write_insn<big_endian>(p, bctr),				p += 4;
      while (p < oview + this->pltresolve_size)
	write_insn<big_endian>(p, nop), p += 4;

      // Write lazy link call stubs.
      uint32_t indx = 0;
      while (p < oview + oview_size)
	{
	  if (indx < 0x8000)
	    {
	      write_insn<big_endian>(p, li_0_0 + indx),			p += 4;
	    }
	  else
	    {
	      write_insn<big_endian>(p, lis_0_0 + hi(indx)),		p += 4;
	      write_insn<big_endian>(p, ori_0_0_0 + l(indx)),		p += 4;
	    }
	  uint32_t branch_off = 8 - (p - oview);
	  write_insn<big_endian>(p, b + (branch_off & 0x3fffffc)),	p += 4;
	  indx++;
	}
    }
  else
    {
      const Output_data_got_powerpc<size, big_endian>* got
	= this->targ_->got_section();
      // The address of _GLOBAL_OFFSET_TABLE_.
      Address g_o_t = got->address() + got->g_o_t();

      // Write out pltresolve branch table.
      p = oview;
      unsigned int the_end = oview_size - this->pltresolve_size;
      unsigned char* end_p = oview + the_end;
      while (p < end_p - 8 * 4)
	write_insn<big_endian>(p, b + end_p - p), p += 4;
      while (p < end_p)
	write_insn<big_endian>(p, nop), p += 4;

      // Write out pltresolve call stub.
      if (parameters->options().output_is_position_independent())
	{
	  Address res0_off = 0;
	  Address after_bcl_off = the_end + 12;
	  Address bcl_res0 = after_bcl_off - res0_off;

	  write_insn<big_endian>(p +  0, addis_11_11 + ha(bcl_res0));
	  write_insn<big_endian>(p +  4, mflr_0);
	  write_insn<big_endian>(p +  8, bcl_20_31);
	  write_insn<big_endian>(p + 12, addi_11_11 + l(bcl_res0));
	  write_insn<big_endian>(p + 16, mflr_12);
	  write_insn<big_endian>(p + 20, mtlr_0);
	  write_insn<big_endian>(p + 24, sub_11_11_12);

	  Address got_bcl = g_o_t + 4 - (after_bcl_off + this->address());

	  write_insn<big_endian>(p + 28, addis_12_12 + ha(got_bcl));
	  if (ha(got_bcl) == ha(got_bcl + 4))
	    {
	      write_insn<big_endian>(p + 32, lwz_0_12 + l(got_bcl));
	      write_insn<big_endian>(p + 36, lwz_12_12 + l(got_bcl + 4));
	    }
	  else
	    {
	      write_insn<big_endian>(p + 32, lwzu_0_12 + l(got_bcl));
	      write_insn<big_endian>(p + 36, lwz_12_12 + 4);
	    }
	  write_insn<big_endian>(p + 40, mtctr_0);
	  write_insn<big_endian>(p + 44, add_0_11_11);
	  write_insn<big_endian>(p + 48, add_11_0_11);
	  write_insn<big_endian>(p + 52, bctr);
	  write_insn<big_endian>(p + 56, nop);
	  write_insn<big_endian>(p + 60, nop);
	}
      else
	{
	  Address res0 = this->address();

	  write_insn<big_endian>(p + 0, lis_12 + ha(g_o_t + 4));
	  write_insn<big_endian>(p + 4, addis_11_11 + ha(-res0));
	  if (ha(g_o_t + 4) == ha(g_o_t + 8))
	    write_insn<big_endian>(p + 8, lwz_0_12 + l(g_o_t + 4));
	  else
	    write_insn<big_endian>(p + 8, lwzu_0_12 + l(g_o_t + 4));
	  write_insn<big_endian>(p + 12, addi_11_11 + l(-res0));
	  write_insn<big_endian>(p + 16, mtctr_0);
	  write_insn<big_endian>(p + 20, add_0_11_11);
	  if (ha(g_o_t + 4) == ha(g_o_t + 8))
	    write_insn<big_endian>(p + 24, lwz_12_12 + l(g_o_t + 8));
	  else
	    write_insn<big_endian>(p + 24, lwz_12_12 + 4);
	  write_insn<big_endian>(p + 28, add_11_0_11);
	  write_insn<big_endian>(p + 32, bctr);
	  write_insn<big_endian>(p + 36, nop);
	  write_insn<big_endian>(p + 40, nop);
	  write_insn<big_endian>(p + 44, nop);
	  write_insn<big_endian>(p + 48, nop);
	  write_insn<big_endian>(p + 52, nop);
	  write_insn<big_endian>(p + 56, nop);
	  write_insn<big_endian>(p + 60, nop);
	}
      p += 64;
    }

  of->write_output_view(off, oview_size, oview);
}


// A class to handle linker generated save/restore functions.

template<int size, bool big_endian>
class Output_data_save_res : public Output_section_data_build
{
 public:
  Output_data_save_res(Symbol_table* symtab);

 protected:
  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** save/restore")); }

  void
  do_write(Output_file*);

 private:
  // The maximum size of save/restore contents.
  static const unsigned int savres_max = 218*4;

  void
  savres_define(Symbol_table* symtab,
		const char *name,
		unsigned int lo, unsigned int hi,
		unsigned char* write_ent(unsigned char*, int),
		unsigned char* write_tail(unsigned char*, int));

  unsigned char *contents_;
};

template<bool big_endian>
static unsigned char*
savegpr0(unsigned char* p, int r)
{
  uint32_t insn = std_0_1 + (r << 21) + (1 << 16) - (32 - r) * 8;
  write_insn<big_endian>(p, insn);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
savegpr0_tail(unsigned char* p, int r)
{
  p = savegpr0<big_endian>(p, r);
  uint32_t insn = std_0_1 + 16;
  write_insn<big_endian>(p, insn);
  p = p + 4;
  write_insn<big_endian>(p, blr);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
restgpr0(unsigned char* p, int r)
{
  uint32_t insn = ld_0_1 + (r << 21) + (1 << 16) - (32 - r) * 8;
  write_insn<big_endian>(p, insn);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
restgpr0_tail(unsigned char* p, int r)
{
  uint32_t insn = ld_0_1 + 16;
  write_insn<big_endian>(p, insn);
  p = p + 4;
  p = restgpr0<big_endian>(p, r);
  write_insn<big_endian>(p, mtlr_0);
  p = p + 4;
  if (r == 29)
    {
      p = restgpr0<big_endian>(p, 30);
      p = restgpr0<big_endian>(p, 31);
    }
  write_insn<big_endian>(p, blr);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
savegpr1(unsigned char* p, int r)
{
  uint32_t insn = std_0_12 + (r << 21) + (1 << 16) - (32 - r) * 8;
  write_insn<big_endian>(p, insn);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
savegpr1_tail(unsigned char* p, int r)
{
  p = savegpr1<big_endian>(p, r);
  write_insn<big_endian>(p, blr);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
restgpr1(unsigned char* p, int r)
{
  uint32_t insn = ld_0_12 + (r << 21) + (1 << 16) - (32 - r) * 8;
  write_insn<big_endian>(p, insn);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
restgpr1_tail(unsigned char* p, int r)
{
  p = restgpr1<big_endian>(p, r);
  write_insn<big_endian>(p, blr);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
savefpr(unsigned char* p, int r)
{
  uint32_t insn = stfd_0_1 + (r << 21) + (1 << 16) - (32 - r) * 8;
  write_insn<big_endian>(p, insn);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
savefpr0_tail(unsigned char* p, int r)
{
  p = savefpr<big_endian>(p, r);
  write_insn<big_endian>(p, std_0_1 + 16);
  p = p + 4;
  write_insn<big_endian>(p, blr);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
restfpr(unsigned char* p, int r)
{
  uint32_t insn = lfd_0_1 + (r << 21) + (1 << 16) - (32 - r) * 8;
  write_insn<big_endian>(p, insn);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
restfpr0_tail(unsigned char* p, int r)
{
  write_insn<big_endian>(p, ld_0_1 + 16);
  p = p + 4;
  p = restfpr<big_endian>(p, r);
  write_insn<big_endian>(p, mtlr_0);
  p = p + 4;
  if (r == 29)
    {
      p = restfpr<big_endian>(p, 30);
      p = restfpr<big_endian>(p, 31);
    }
  write_insn<big_endian>(p, blr);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
savefpr1_tail(unsigned char* p, int r)
{
  p = savefpr<big_endian>(p, r);
  write_insn<big_endian>(p, blr);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
restfpr1_tail(unsigned char* p, int r)
{
  p = restfpr<big_endian>(p, r);
  write_insn<big_endian>(p, blr);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
savevr(unsigned char* p, int r)
{
  uint32_t insn = li_12_0 + (1 << 16) - (32 - r) * 16;
  write_insn<big_endian>(p, insn);
  p = p + 4;
  insn = stvx_0_12_0 + (r << 21);
  write_insn<big_endian>(p, insn);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
savevr_tail(unsigned char* p, int r)
{
  p = savevr<big_endian>(p, r);
  write_insn<big_endian>(p, blr);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
restvr(unsigned char* p, int r)
{
  uint32_t insn = li_12_0 + (1 << 16) - (32 - r) * 16;
  write_insn<big_endian>(p, insn);
  p = p + 4;
  insn = lvx_0_12_0 + (r << 21);
  write_insn<big_endian>(p, insn);
  return p + 4;
}

template<bool big_endian>
static unsigned char*
restvr_tail(unsigned char* p, int r)
{
  p = restvr<big_endian>(p, r);
  write_insn<big_endian>(p, blr);
  return p + 4;
}


template<int size, bool big_endian>
Output_data_save_res<size, big_endian>::Output_data_save_res(
    Symbol_table* symtab)
  : Output_section_data_build(4),
    contents_(NULL)
{
  this->savres_define(symtab,
		      "_savegpr0_", 14, 31,
		      savegpr0<big_endian>, savegpr0_tail<big_endian>);
  this->savres_define(symtab,
		      "_restgpr0_", 14, 29,
		      restgpr0<big_endian>, restgpr0_tail<big_endian>);
  this->savres_define(symtab,
		      "_restgpr0_", 30, 31,
		      restgpr0<big_endian>, restgpr0_tail<big_endian>);
  this->savres_define(symtab,
		      "_savegpr1_", 14, 31,
		      savegpr1<big_endian>, savegpr1_tail<big_endian>);
  this->savres_define(symtab,
		      "_restgpr1_", 14, 31,
		      restgpr1<big_endian>, restgpr1_tail<big_endian>);
  this->savres_define(symtab,
		      "_savefpr_", 14, 31,
		      savefpr<big_endian>, savefpr0_tail<big_endian>);
  this->savres_define(symtab,
		      "_restfpr_", 14, 29,
		      restfpr<big_endian>, restfpr0_tail<big_endian>);
  this->savres_define(symtab,
		      "_restfpr_", 30, 31,
		      restfpr<big_endian>, restfpr0_tail<big_endian>);
  this->savres_define(symtab,
		      "._savef", 14, 31,
		      savefpr<big_endian>, savefpr1_tail<big_endian>);
  this->savres_define(symtab,
		      "._restf", 14, 31,
		      restfpr<big_endian>, restfpr1_tail<big_endian>);
  this->savres_define(symtab,
		      "_savevr_", 20, 31,
		      savevr<big_endian>, savevr_tail<big_endian>);
  this->savres_define(symtab,
		      "_restvr_", 20, 31,
		      restvr<big_endian>, restvr_tail<big_endian>);
}

template<int size, bool big_endian>
void
Output_data_save_res<size, big_endian>::savres_define(
    Symbol_table* symtab,
    const char *name,
    unsigned int lo, unsigned int hi,
    unsigned char* write_ent(unsigned char*, int),
    unsigned char* write_tail(unsigned char*, int))
{
  size_t len = strlen(name);
  bool writing = false;
  char sym[16];

  memcpy(sym, name, len);
  sym[len + 2] = 0;

  for (unsigned int i = lo; i <= hi; i++)
    {
      sym[len + 0] = i / 10 + '0';
      sym[len + 1] = i % 10 + '0';
      Symbol* gsym = symtab->lookup(sym);
      bool refd = gsym != NULL && gsym->is_undefined();
      writing = writing || refd;
      if (writing)
	{
	  if (this->contents_ == NULL)
	    this->contents_ = new unsigned char[this->savres_max];

	  section_size_type value = this->current_data_size();
	  unsigned char* p = this->contents_ + value;
	  if (i != hi)
	    p = write_ent(p, i);
	  else
	    p = write_tail(p, i);
	  section_size_type cur_size = p - this->contents_;
	  this->set_current_data_size(cur_size);
	  if (refd)
	    symtab->define_in_output_data(sym, NULL, Symbol_table::PREDEFINED,
					  this, value, cur_size - value,
					  elfcpp::STT_FUNC, elfcpp::STB_GLOBAL,
					  elfcpp::STV_HIDDEN, 0, false, false);
	}
    }
}

// Write out save/restore.

template<int size, bool big_endian>
void
Output_data_save_res<size, big_endian>::do_write(Output_file* of)
{
  const section_size_type off = this->offset();
  const section_size_type oview_size =
    convert_to_section_size_type(this->data_size());
  unsigned char* const oview = of->get_output_view(off, oview_size);
  memcpy(oview, this->contents_, oview_size);
  of->write_output_view(off, oview_size, oview);
}


// Create the glink section.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::make_glink_section(Layout* layout)
{
  if (this->glink_ == NULL)
    {
      this->glink_ = new Output_data_glink<size, big_endian>(this);
      this->glink_->add_eh_frame(layout);
      layout->add_output_section_data(".text", elfcpp::SHT_PROGBITS,
				      elfcpp::SHF_ALLOC | elfcpp::SHF_EXECINSTR,
				      this->glink_, ORDER_TEXT, false);
    }
}

// Create a PLT entry for a global symbol.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::make_plt_entry(Symbol_table* symtab,
						 Layout* layout,
						 Symbol* gsym)
{
  if (gsym->type() == elfcpp::STT_GNU_IFUNC
      && gsym->can_use_relative_reloc(false))
    {
      if (this->iplt_ == NULL)
	this->make_iplt_section(symtab, layout);
      this->iplt_->add_ifunc_entry(gsym);
    }
  else
    {
      if (this->plt_ == NULL)
	this->make_plt_section(symtab, layout);
      this->plt_->add_entry(gsym);
    }
}

// Make a PLT entry for a local STT_GNU_IFUNC symbol.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::make_local_ifunc_plt_entry(
    Symbol_table* symtab,
    Layout* layout,
    Sized_relobj_file<size, big_endian>* relobj,
    unsigned int r_sym)
{
  if (this->iplt_ == NULL)
    this->make_iplt_section(symtab, layout);
  this->iplt_->add_local_ifunc_entry(relobj, r_sym);
}

// Return the number of entries in the PLT.

template<int size, bool big_endian>
unsigned int
Target_powerpc<size, big_endian>::plt_entry_count() const
{
  if (this->plt_ == NULL)
    return 0;
  return this->plt_->entry_count();
}

// Return the offset of the first non-reserved PLT entry.

template<int size, bool big_endian>
unsigned int
Target_powerpc<size, big_endian>::first_plt_entry_offset() const
{
  return this->plt_->first_plt_entry_offset();
}

// Return the size of each PLT entry.

template<int size, bool big_endian>
unsigned int
Target_powerpc<size, big_endian>::plt_entry_size() const
{
  return Output_data_plt_powerpc<size, big_endian>::get_plt_entry_size();
}

// Create a GOT entry for local dynamic __tls_get_addr calls.

template<int size, bool big_endian>
unsigned int
Target_powerpc<size, big_endian>::tlsld_got_offset(
    Symbol_table* symtab,
    Layout* layout,
    Sized_relobj_file<size, big_endian>* object)
{
  if (this->tlsld_got_offset_ == -1U)
    {
      gold_assert(symtab != NULL && layout != NULL && object != NULL);
      Reloc_section* rela_dyn = this->rela_dyn_section(layout);
      Output_data_got_powerpc<size, big_endian>* got
	= this->got_section(symtab, layout);
      unsigned int got_offset = got->add_constant_pair(0, 0);
      rela_dyn->add_local(object, 0, elfcpp::R_POWERPC_DTPMOD, got,
			  got_offset, 0);
      this->tlsld_got_offset_ = got_offset;
    }
  return this->tlsld_got_offset_;
}

// Get the Reference_flags for a particular relocation.

template<int size, bool big_endian>
int
Target_powerpc<size, big_endian>::Scan::get_reference_flags(unsigned int r_type)
{
  switch (r_type)
    {
    case elfcpp::R_POWERPC_NONE:
    case elfcpp::R_POWERPC_GNU_VTINHERIT:
    case elfcpp::R_POWERPC_GNU_VTENTRY:
    case elfcpp::R_PPC64_TOC:
      // No symbol reference.
      return 0;

    case elfcpp::R_PPC64_ADDR64:
    case elfcpp::R_PPC64_UADDR64:
    case elfcpp::R_POWERPC_ADDR32:
    case elfcpp::R_POWERPC_UADDR32:
    case elfcpp::R_POWERPC_ADDR16:
    case elfcpp::R_POWERPC_UADDR16:
    case elfcpp::R_POWERPC_ADDR16_LO:
    case elfcpp::R_POWERPC_ADDR16_HI:
    case elfcpp::R_POWERPC_ADDR16_HA:
      return Symbol::ABSOLUTE_REF;

    case elfcpp::R_POWERPC_ADDR24:
    case elfcpp::R_POWERPC_ADDR14:
    case elfcpp::R_POWERPC_ADDR14_BRTAKEN:
    case elfcpp::R_POWERPC_ADDR14_BRNTAKEN:
      return Symbol::FUNCTION_CALL | Symbol::ABSOLUTE_REF;

    case elfcpp::R_PPC64_REL64:
    case elfcpp::R_POWERPC_REL32:
    case elfcpp::R_PPC_LOCAL24PC:
    case elfcpp::R_POWERPC_REL16:
    case elfcpp::R_POWERPC_REL16_LO:
    case elfcpp::R_POWERPC_REL16_HI:
    case elfcpp::R_POWERPC_REL16_HA:
      return Symbol::RELATIVE_REF;

    case elfcpp::R_POWERPC_REL24:
    case elfcpp::R_PPC_PLTREL24:
    case elfcpp::R_POWERPC_REL14:
    case elfcpp::R_POWERPC_REL14_BRTAKEN:
    case elfcpp::R_POWERPC_REL14_BRNTAKEN:
      return Symbol::FUNCTION_CALL | Symbol::RELATIVE_REF;

    case elfcpp::R_POWERPC_GOT16:
    case elfcpp::R_POWERPC_GOT16_LO:
    case elfcpp::R_POWERPC_GOT16_HI:
    case elfcpp::R_POWERPC_GOT16_HA:
    case elfcpp::R_PPC64_GOT16_DS:
    case elfcpp::R_PPC64_GOT16_LO_DS:
    case elfcpp::R_PPC64_TOC16:
    case elfcpp::R_PPC64_TOC16_LO:
    case elfcpp::R_PPC64_TOC16_HI:
    case elfcpp::R_PPC64_TOC16_HA:
    case elfcpp::R_PPC64_TOC16_DS:
    case elfcpp::R_PPC64_TOC16_LO_DS:
      // Absolute in GOT.
      return Symbol::ABSOLUTE_REF;

    case elfcpp::R_POWERPC_GOT_TPREL16:
    case elfcpp::R_POWERPC_TLS:
      return Symbol::TLS_REF;

    case elfcpp::R_POWERPC_COPY:
    case elfcpp::R_POWERPC_GLOB_DAT:
    case elfcpp::R_POWERPC_JMP_SLOT:
    case elfcpp::R_POWERPC_RELATIVE:
    case elfcpp::R_POWERPC_DTPMOD:
    default:
      // Not expected.  We will give an error later.
      return 0;
    }
}

// Report an unsupported relocation against a local symbol.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::Scan::unsupported_reloc_local(
    Sized_relobj_file<size, big_endian>* object,
    unsigned int r_type)
{
  gold_error(_("%s: unsupported reloc %u against local symbol"),
	     object->name().c_str(), r_type);
}

// We are about to emit a dynamic relocation of type R_TYPE.  If the
// dynamic linker does not support it, issue an error.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::Scan::check_non_pic(Relobj* object,
						      unsigned int r_type)
{
  gold_assert(r_type != elfcpp::R_POWERPC_NONE);

  // These are the relocation types supported by glibc for both 32-bit
  // and 64-bit powerpc.
  switch (r_type)
    {
    case elfcpp::R_POWERPC_NONE:
    case elfcpp::R_POWERPC_RELATIVE:
    case elfcpp::R_POWERPC_GLOB_DAT:
    case elfcpp::R_POWERPC_DTPMOD:
    case elfcpp::R_POWERPC_DTPREL:
    case elfcpp::R_POWERPC_TPREL:
    case elfcpp::R_POWERPC_JMP_SLOT:
    case elfcpp::R_POWERPC_COPY:
    case elfcpp::R_POWERPC_IRELATIVE:
    case elfcpp::R_POWERPC_ADDR32:
    case elfcpp::R_POWERPC_UADDR32:
    case elfcpp::R_POWERPC_ADDR24:
    case elfcpp::R_POWERPC_ADDR16:
    case elfcpp::R_POWERPC_UADDR16:
    case elfcpp::R_POWERPC_ADDR16_LO:
    case elfcpp::R_POWERPC_ADDR16_HI:
    case elfcpp::R_POWERPC_ADDR16_HA:
    case elfcpp::R_POWERPC_ADDR14:
    case elfcpp::R_POWERPC_ADDR14_BRTAKEN:
    case elfcpp::R_POWERPC_ADDR14_BRNTAKEN:
    case elfcpp::R_POWERPC_REL32:
    case elfcpp::R_POWERPC_REL24:
    case elfcpp::R_POWERPC_TPREL16:
    case elfcpp::R_POWERPC_TPREL16_LO:
    case elfcpp::R_POWERPC_TPREL16_HI:
    case elfcpp::R_POWERPC_TPREL16_HA:
      return;

    default:
      break;
    }

  if (size == 64)
    {
      switch (r_type)
	{
	  // These are the relocation types supported only on 64-bit.
	case elfcpp::R_PPC64_ADDR64:
	case elfcpp::R_PPC64_UADDR64:
	case elfcpp::R_PPC64_JMP_IREL:
	case elfcpp::R_PPC64_ADDR16_DS:
	case elfcpp::R_PPC64_ADDR16_LO_DS:
	case elfcpp::R_PPC64_ADDR16_HIGHER:
	case elfcpp::R_PPC64_ADDR16_HIGHEST:
	case elfcpp::R_PPC64_ADDR16_HIGHERA:
	case elfcpp::R_PPC64_ADDR16_HIGHESTA:
	case elfcpp::R_PPC64_REL64:
	case elfcpp::R_POWERPC_ADDR30:
	case elfcpp::R_PPC64_TPREL16_DS:
	case elfcpp::R_PPC64_TPREL16_LO_DS:
	case elfcpp::R_PPC64_TPREL16_HIGHER:
	case elfcpp::R_PPC64_TPREL16_HIGHEST:
	case elfcpp::R_PPC64_TPREL16_HIGHERA:
	case elfcpp::R_PPC64_TPREL16_HIGHESTA:
	  return;

	default:
	  break;
	}
    }
  else
    {
      switch (r_type)
	{
	  // These are the relocation types supported only on 32-bit.
	  // ??? glibc ld.so doesn't need to support these.
	case elfcpp::R_POWERPC_DTPREL16:
	case elfcpp::R_POWERPC_DTPREL16_LO:
	case elfcpp::R_POWERPC_DTPREL16_HI:
	case elfcpp::R_POWERPC_DTPREL16_HA:
	  return;

	default:
	  break;
	}
    }

  // This prevents us from issuing more than one error per reloc
  // section.  But we can still wind up issuing more than one
  // error per object file.
  if (this->issued_non_pic_error_)
    return;
  gold_assert(parameters->options().output_is_position_independent());
  object->error(_("requires unsupported dynamic reloc; "
		  "recompile with -fPIC"));
  this->issued_non_pic_error_ = true;
  return;
}

// Return whether we need to make a PLT entry for a relocation of the
// given type against a STT_GNU_IFUNC symbol.

template<int size, bool big_endian>
bool
Target_powerpc<size, big_endian>::Scan::reloc_needs_plt_for_ifunc(
     Sized_relobj_file<size, big_endian>* object,
     unsigned int r_type,
     bool report_err)
{
  // In non-pic code any reference will resolve to the plt call stub
  // for the ifunc symbol.
  if (size == 32 && !parameters->options().output_is_position_independent())
    return true;

  switch (r_type)
    {
    // Word size refs from data sections are OK, but don't need a PLT entry.
    case elfcpp::R_POWERPC_ADDR32:
    case elfcpp::R_POWERPC_UADDR32:
      if (size == 32)
	return false;
      break;

    case elfcpp::R_PPC64_ADDR64:
    case elfcpp::R_PPC64_UADDR64:
      if (size == 64)
	return false;
      break;

    // GOT refs are good, but also don't need a PLT entry.
    case elfcpp::R_POWERPC_GOT16:
    case elfcpp::R_POWERPC_GOT16_LO:
    case elfcpp::R_POWERPC_GOT16_HI:
    case elfcpp::R_POWERPC_GOT16_HA:
    case elfcpp::R_PPC64_GOT16_DS:
    case elfcpp::R_PPC64_GOT16_LO_DS:
      return false;

    // Function calls are good, and these do need a PLT entry.
    case elfcpp::R_POWERPC_ADDR24:
    case elfcpp::R_POWERPC_ADDR14:
    case elfcpp::R_POWERPC_ADDR14_BRTAKEN:
    case elfcpp::R_POWERPC_ADDR14_BRNTAKEN:
    case elfcpp::R_POWERPC_REL24:
    case elfcpp::R_PPC_PLTREL24:
    case elfcpp::R_POWERPC_REL14:
    case elfcpp::R_POWERPC_REL14_BRTAKEN:
    case elfcpp::R_POWERPC_REL14_BRNTAKEN:
      return true;

    default:
      break;
    }

  // Anything else is a problem.
  // If we are building a static executable, the libc startup function
  // responsible for applying indirect function relocations is going
  // to complain about the reloc type.
  // If we are building a dynamic executable, we will have a text
  // relocation.  The dynamic loader will set the text segment
  // writable and non-executable to apply text relocations.  So we'll
  // segfault when trying to run the indirection function to resolve
  // the reloc.
  if (report_err)
    gold_error(_("%s: unsupported reloc %u for IFUNC symbol"),
	       object->name().c_str(), r_type);
  return false;
}

// Scan a relocation for a local symbol.

template<int size, bool big_endian>
inline void
Target_powerpc<size, big_endian>::Scan::local(
    Symbol_table* symtab,
    Layout* layout,
    Target_powerpc<size, big_endian>* target,
    Sized_relobj_file<size, big_endian>* object,
    unsigned int data_shndx,
    Output_section* output_section,
    const elfcpp::Rela<size, big_endian>& reloc,
    unsigned int r_type,
    const elfcpp::Sym<size, big_endian>& lsym,
    bool is_discarded)
{
  this->maybe_skip_tls_get_addr_call(r_type, NULL);

  if ((size == 64 && r_type == elfcpp::R_PPC64_TLSGD)
      || (size == 32 && r_type == elfcpp::R_PPC_TLSGD))
    {
      this->expect_tls_get_addr_call();
      const tls::Tls_optimization tls_type = target->optimize_tls_gd(true);
      if (tls_type != tls::TLSOPT_NONE)
	this->skip_next_tls_get_addr_call();
    }
  else if ((size == 64 && r_type == elfcpp::R_PPC64_TLSLD)
	   || (size == 32 && r_type == elfcpp::R_PPC_TLSLD))
    {
      this->expect_tls_get_addr_call();
      const tls::Tls_optimization tls_type = target->optimize_tls_ld();
      if (tls_type != tls::TLSOPT_NONE)
	this->skip_next_tls_get_addr_call();
    }

  Powerpc_relobj<size, big_endian>* ppc_object
    = static_cast<Powerpc_relobj<size, big_endian>*>(object);

  if (is_discarded)
    {
      if (size == 64
	  && data_shndx == ppc_object->opd_shndx()
	  && r_type == elfcpp::R_PPC64_ADDR64)
	ppc_object->set_opd_discard(reloc.get_r_offset());
      return;
    }

  // A local STT_GNU_IFUNC symbol may require a PLT entry.
  bool is_ifunc = lsym.get_st_type() == elfcpp::STT_GNU_IFUNC;
  if (is_ifunc && this->reloc_needs_plt_for_ifunc(object, r_type, true))
    {
      unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
      target->push_branch(ppc_object, data_shndx, reloc.get_r_offset(),
			  r_type, r_sym, reloc.get_r_addend());
      target->make_local_ifunc_plt_entry(symtab, layout, object, r_sym);
    }

  switch (r_type)
    {
    case elfcpp::R_POWERPC_NONE:
    case elfcpp::R_POWERPC_GNU_VTINHERIT:
    case elfcpp::R_POWERPC_GNU_VTENTRY:
    case elfcpp::R_PPC64_TOCSAVE:
    case elfcpp::R_PPC_EMB_MRKREF:
    case elfcpp::R_POWERPC_TLS:
      break;

    case elfcpp::R_PPC64_TOC:
      {
	Output_data_got_powerpc<size, big_endian>* got
	  = target->got_section(symtab, layout);
	if (parameters->options().output_is_position_independent())
	  {
	    Address off = reloc.get_r_offset();
	    if (size == 64
		&& data_shndx == ppc_object->opd_shndx()
		&& ppc_object->get_opd_discard(off - 8))
	      break;

	    Reloc_section* rela_dyn = target->rela_dyn_section(layout);
	    Powerpc_relobj<size, big_endian>* symobj = ppc_object;
	    rela_dyn->add_output_section_relative(got->output_section(),
						  elfcpp::R_POWERPC_RELATIVE,
						  output_section,
						  object, data_shndx, off,
						  symobj->toc_base_offset());
	  }
      }
      break;

    case elfcpp::R_PPC64_ADDR64:
    case elfcpp::R_PPC64_UADDR64:
    case elfcpp::R_POWERPC_ADDR32:
    case elfcpp::R_POWERPC_UADDR32:
    case elfcpp::R_POWERPC_ADDR24:
    case elfcpp::R_POWERPC_ADDR16:
    case elfcpp::R_POWERPC_ADDR16_LO:
    case elfcpp::R_POWERPC_ADDR16_HI:
    case elfcpp::R_POWERPC_ADDR16_HA:
    case elfcpp::R_POWERPC_UADDR16:
    case elfcpp::R_PPC64_ADDR16_HIGHER:
    case elfcpp::R_PPC64_ADDR16_HIGHERA:
    case elfcpp::R_PPC64_ADDR16_HIGHEST:
    case elfcpp::R_PPC64_ADDR16_HIGHESTA:
    case elfcpp::R_PPC64_ADDR16_DS:
    case elfcpp::R_PPC64_ADDR16_LO_DS:
    case elfcpp::R_POWERPC_ADDR14:
    case elfcpp::R_POWERPC_ADDR14_BRTAKEN:
    case elfcpp::R_POWERPC_ADDR14_BRNTAKEN:
      // If building a shared library (or a position-independent
      // executable), we need to create a dynamic relocation for
      // this location.
      if (parameters->options().output_is_position_independent()
	  || (size == 64 && is_ifunc))
	{
	  Reloc_section* rela_dyn = target->rela_dyn_section(symtab, layout,
							     is_ifunc);
	  if ((size == 32 && r_type == elfcpp::R_POWERPC_ADDR32)
	      || (size == 64 && r_type == elfcpp::R_PPC64_ADDR64))
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
	      unsigned int dynrel = (is_ifunc ? elfcpp::R_POWERPC_IRELATIVE
				     : elfcpp::R_POWERPC_RELATIVE);
	      rela_dyn->add_local_relative(object, r_sym, dynrel,
					   output_section, data_shndx,
					   reloc.get_r_offset(),
					   reloc.get_r_addend(), false);
	    }
	  else
	    {
	      check_non_pic(object, r_type);
	      unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
	      rela_dyn->add_local(object, r_sym, r_type, output_section,
				  data_shndx, reloc.get_r_offset(),
				  reloc.get_r_addend());
	    }
	}
      break;

    case elfcpp::R_POWERPC_REL24:
    case elfcpp::R_PPC_PLTREL24:
    case elfcpp::R_PPC_LOCAL24PC:
    case elfcpp::R_POWERPC_REL14:
    case elfcpp::R_POWERPC_REL14_BRTAKEN:
    case elfcpp::R_POWERPC_REL14_BRNTAKEN:
      if (!is_ifunc)
	target->push_branch(ppc_object, data_shndx, reloc.get_r_offset(),
			    r_type, elfcpp::elf_r_sym<size>(reloc.get_r_info()),
			    reloc.get_r_addend());
      break;

    case elfcpp::R_PPC64_REL64:
    case elfcpp::R_POWERPC_REL32:
    case elfcpp::R_POWERPC_REL16:
    case elfcpp::R_POWERPC_REL16_LO:
    case elfcpp::R_POWERPC_REL16_HI:
    case elfcpp::R_POWERPC_REL16_HA:
    case elfcpp::R_POWERPC_SECTOFF:
    case elfcpp::R_POWERPC_TPREL16:
    case elfcpp::R_POWERPC_DTPREL16:
    case elfcpp::R_POWERPC_SECTOFF_LO:
    case elfcpp::R_POWERPC_TPREL16_LO:
    case elfcpp::R_POWERPC_DTPREL16_LO:
    case elfcpp::R_POWERPC_SECTOFF_HI:
    case elfcpp::R_POWERPC_TPREL16_HI:
    case elfcpp::R_POWERPC_DTPREL16_HI:
    case elfcpp::R_POWERPC_SECTOFF_HA:
    case elfcpp::R_POWERPC_TPREL16_HA:
    case elfcpp::R_POWERPC_DTPREL16_HA:
    case elfcpp::R_PPC64_DTPREL16_HIGHER:
    case elfcpp::R_PPC64_TPREL16_HIGHER:
    case elfcpp::R_PPC64_DTPREL16_HIGHERA:
    case elfcpp::R_PPC64_TPREL16_HIGHERA:
    case elfcpp::R_PPC64_DTPREL16_HIGHEST:
    case elfcpp::R_PPC64_TPREL16_HIGHEST:
    case elfcpp::R_PPC64_DTPREL16_HIGHESTA:
    case elfcpp::R_PPC64_TPREL16_HIGHESTA:
    case elfcpp::R_PPC64_TPREL16_DS:
    case elfcpp::R_PPC64_TPREL16_LO_DS:
    case elfcpp::R_PPC64_DTPREL16_DS:
    case elfcpp::R_PPC64_DTPREL16_LO_DS:
    case elfcpp::R_PPC64_SECTOFF_DS:
    case elfcpp::R_PPC64_SECTOFF_LO_DS:
    case elfcpp::R_PPC64_TLSGD:
    case elfcpp::R_PPC64_TLSLD:
      break;

    case elfcpp::R_POWERPC_GOT16:
    case elfcpp::R_POWERPC_GOT16_LO:
    case elfcpp::R_POWERPC_GOT16_HI:
    case elfcpp::R_POWERPC_GOT16_HA:
    case elfcpp::R_PPC64_GOT16_DS:
    case elfcpp::R_PPC64_GOT16_LO_DS:
      {
	// The symbol requires a GOT entry.
	Output_data_got_powerpc<size, big_endian>* got
	  = target->got_section(symtab, layout);
	unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());

	if (!parameters->options().output_is_position_independent())
	  {
	    if (size == 32 && is_ifunc)
	      got->add_local_plt(object, r_sym, GOT_TYPE_STANDARD);
	    else
	      got->add_local(object, r_sym, GOT_TYPE_STANDARD);
	  }
	else if (!object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD))
	  {
	    // If we are generating a shared object or a pie, this
	    // symbol's GOT entry will be set by a dynamic relocation.
	    unsigned int off;
	    off = got->add_constant(0);
	    object->set_local_got_offset(r_sym, GOT_TYPE_STANDARD, off);

	    Reloc_section* rela_dyn = target->rela_dyn_section(symtab, layout,
							       is_ifunc);
	    unsigned int dynrel = (is_ifunc ? elfcpp::R_POWERPC_IRELATIVE
				   : elfcpp::R_POWERPC_RELATIVE);
	    rela_dyn->add_local_relative(object, r_sym, dynrel,
					 got, off, 0, false);
	  }
      }
      break;

    case elfcpp::R_PPC64_TOC16:
    case elfcpp::R_PPC64_TOC16_LO:
    case elfcpp::R_PPC64_TOC16_HI:
    case elfcpp::R_PPC64_TOC16_HA:
    case elfcpp::R_PPC64_TOC16_DS:
    case elfcpp::R_PPC64_TOC16_LO_DS:
      // We need a GOT section.
      target->got_section(symtab, layout);
      break;

    case elfcpp::R_POWERPC_GOT_TLSGD16:
    case elfcpp::R_POWERPC_GOT_TLSGD16_LO:
    case elfcpp::R_POWERPC_GOT_TLSGD16_HI:
    case elfcpp::R_POWERPC_GOT_TLSGD16_HA:
      {
	const tls::Tls_optimization tls_type = target->optimize_tls_gd(true);
	if (tls_type == tls::TLSOPT_NONE)
	  {
	    Output_data_got_powerpc<size, big_endian>* got
	      = target->got_section(symtab, layout);
	    unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
	    Reloc_section* rela_dyn = target->rela_dyn_section(layout);
	    got->add_local_tls_pair(object, r_sym, GOT_TYPE_TLSGD,
				    rela_dyn, elfcpp::R_POWERPC_DTPMOD);
	  }
	else if (tls_type == tls::TLSOPT_TO_LE)
	  {
	    // no GOT relocs needed for Local Exec.
	  }
	else
	  gold_unreachable();
      }
      break;

    case elfcpp::R_POWERPC_GOT_TLSLD16:
    case elfcpp::R_POWERPC_GOT_TLSLD16_LO:
    case elfcpp::R_POWERPC_GOT_TLSLD16_HI:
    case elfcpp::R_POWERPC_GOT_TLSLD16_HA:
      {
	const tls::Tls_optimization tls_type = target->optimize_tls_ld();
	if (tls_type == tls::TLSOPT_NONE)
	  target->tlsld_got_offset(symtab, layout, object);
	else if (tls_type == tls::TLSOPT_TO_LE)
	  {
	    // no GOT relocs needed for Local Exec.
	    if (parameters->options().emit_relocs())
	      {
		Output_section* os = layout->tls_segment()->first_section();
		gold_assert(os != NULL);
		os->set_needs_symtab_index();
	      }
	  }
	else
	  gold_unreachable();
      }
      break;

    case elfcpp::R_POWERPC_GOT_DTPREL16:
    case elfcpp::R_POWERPC_GOT_DTPREL16_LO:
    case elfcpp::R_POWERPC_GOT_DTPREL16_HI:
    case elfcpp::R_POWERPC_GOT_DTPREL16_HA:
      {
	Output_data_got_powerpc<size, big_endian>* got
	  = target->got_section(symtab, layout);
	unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
	got->add_local_tls(object, r_sym, GOT_TYPE_DTPREL);
      }
      break;

    case elfcpp::R_POWERPC_GOT_TPREL16:
    case elfcpp::R_POWERPC_GOT_TPREL16_LO:
    case elfcpp::R_POWERPC_GOT_TPREL16_HI:
    case elfcpp::R_POWERPC_GOT_TPREL16_HA:
      {
	const tls::Tls_optimization tls_type = target->optimize_tls_ie(true);
	if (tls_type == tls::TLSOPT_NONE)
	  {
	    unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
	    if (!object->local_has_got_offset(r_sym, GOT_TYPE_TPREL))
	      {
		Output_data_got_powerpc<size, big_endian>* got
		  = target->got_section(symtab, layout);
		unsigned int off = got->add_constant(0);
		object->set_local_got_offset(r_sym, GOT_TYPE_TPREL, off);

		Reloc_section* rela_dyn = target->rela_dyn_section(layout);
		rela_dyn->add_symbolless_local_addend(object, r_sym,
						      elfcpp::R_POWERPC_TPREL,
						      got, off, 0);
	      }
	  }
	else if (tls_type == tls::TLSOPT_TO_LE)
	  {
	    // no GOT relocs needed for Local Exec.
	  }
	else
	  gold_unreachable();
      }
      break;

    default:
      unsupported_reloc_local(object, r_type);
      break;
    }

  switch (r_type)
    {
    case elfcpp::R_POWERPC_GOT_TLSLD16:
    case elfcpp::R_POWERPC_GOT_TLSGD16:
    case elfcpp::R_POWERPC_GOT_TPREL16:
    case elfcpp::R_POWERPC_GOT_DTPREL16:
    case elfcpp::R_POWERPC_GOT16:
    case elfcpp::R_PPC64_GOT16_DS:
    case elfcpp::R_PPC64_TOC16:
    case elfcpp::R_PPC64_TOC16_DS:
      ppc_object->set_has_small_toc_reloc();
    default:
      break;
    }
}

// Report an unsupported relocation against a global symbol.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::Scan::unsupported_reloc_global(
    Sized_relobj_file<size, big_endian>* object,
    unsigned int r_type,
    Symbol* gsym)
{
  gold_error(_("%s: unsupported reloc %u against global symbol %s"),
	     object->name().c_str(), r_type, gsym->demangled_name().c_str());
}

// Scan a relocation for a global symbol.

template<int size, bool big_endian>
inline void
Target_powerpc<size, big_endian>::Scan::global(
    Symbol_table* symtab,
    Layout* layout,
    Target_powerpc<size, big_endian>* target,
    Sized_relobj_file<size, big_endian>* object,
    unsigned int data_shndx,
    Output_section* output_section,
    const elfcpp::Rela<size, big_endian>& reloc,
    unsigned int r_type,
    Symbol* gsym)
{
  if (this->maybe_skip_tls_get_addr_call(r_type, gsym) == Track_tls::SKIP)
    return;

  if ((size == 64 && r_type == elfcpp::R_PPC64_TLSGD)
      || (size == 32 && r_type == elfcpp::R_PPC_TLSGD))
    {
      this->expect_tls_get_addr_call();
      const bool final = gsym->final_value_is_known();
      const tls::Tls_optimization tls_type = target->optimize_tls_gd(final);
      if (tls_type != tls::TLSOPT_NONE)
	this->skip_next_tls_get_addr_call();
    }
  else if ((size == 64 && r_type == elfcpp::R_PPC64_TLSLD)
	   || (size == 32 && r_type == elfcpp::R_PPC_TLSLD))
    {
      this->expect_tls_get_addr_call();
      const tls::Tls_optimization tls_type = target->optimize_tls_ld();
      if (tls_type != tls::TLSOPT_NONE)
	this->skip_next_tls_get_addr_call();
    }

  Powerpc_relobj<size, big_endian>* ppc_object
    = static_cast<Powerpc_relobj<size, big_endian>*>(object);

  // A STT_GNU_IFUNC symbol may require a PLT entry.
  bool is_ifunc = gsym->type() == elfcpp::STT_GNU_IFUNC;
  if (is_ifunc && this->reloc_needs_plt_for_ifunc(object, r_type, true))
    {
      target->push_branch(ppc_object, data_shndx, reloc.get_r_offset(),
			  r_type, elfcpp::elf_r_sym<size>(reloc.get_r_info()),
			  reloc.get_r_addend());
      target->make_plt_entry(symtab, layout, gsym);
    }

  switch (r_type)
    {
    case elfcpp::R_POWERPC_NONE:
    case elfcpp::R_POWERPC_GNU_VTINHERIT:
    case elfcpp::R_POWERPC_GNU_VTENTRY:
    case elfcpp::R_PPC_LOCAL24PC:
    case elfcpp::R_PPC_EMB_MRKREF:
    case elfcpp::R_POWERPC_TLS:
      break;

    case elfcpp::R_PPC64_TOC:
      {
	Output_data_got_powerpc<size, big_endian>* got
	  = target->got_section(symtab, layout);
	if (parameters->options().output_is_position_independent())
	  {
	    Address off = reloc.get_r_offset();
	    if (size == 64
		&& data_shndx == ppc_object->opd_shndx()
		&& ppc_object->get_opd_discard(off - 8))
	      break;

	    Reloc_section* rela_dyn = target->rela_dyn_section(layout);
	    Powerpc_relobj<size, big_endian>* symobj = ppc_object;
	    if (data_shndx != ppc_object->opd_shndx())
	      symobj = static_cast
		<Powerpc_relobj<size, big_endian>*>(gsym->object());
	    rela_dyn->add_output_section_relative(got->output_section(),
						  elfcpp::R_POWERPC_RELATIVE,
						  output_section,
						  object, data_shndx, off,
						  symobj->toc_base_offset());
	  }
      }
      break;

    case elfcpp::R_PPC64_ADDR64:
      if (size == 64
	  && data_shndx == ppc_object->opd_shndx()
	  && (gsym->is_defined_in_discarded_section()
	      || gsym->object() != object))
	{
	  ppc_object->set_opd_discard(reloc.get_r_offset());
	  break;
	}
      // Fall thru
    case elfcpp::R_PPC64_UADDR64:
    case elfcpp::R_POWERPC_ADDR32:
    case elfcpp::R_POWERPC_UADDR32:
    case elfcpp::R_POWERPC_ADDR24:
    case elfcpp::R_POWERPC_ADDR16:
    case elfcpp::R_POWERPC_ADDR16_LO:
    case elfcpp::R_POWERPC_ADDR16_HI:
    case elfcpp::R_POWERPC_ADDR16_HA:
    case elfcpp::R_POWERPC_UADDR16:
    case elfcpp::R_PPC64_ADDR16_HIGHER:
    case elfcpp::R_PPC64_ADDR16_HIGHERA:
    case elfcpp::R_PPC64_ADDR16_HIGHEST:
    case elfcpp::R_PPC64_ADDR16_HIGHESTA:
    case elfcpp::R_PPC64_ADDR16_DS:
    case elfcpp::R_PPC64_ADDR16_LO_DS:
    case elfcpp::R_POWERPC_ADDR14:
    case elfcpp::R_POWERPC_ADDR14_BRTAKEN:
    case elfcpp::R_POWERPC_ADDR14_BRNTAKEN:
      {
	// Make a PLT entry if necessary.
	if (gsym->needs_plt_entry())
	  {
	    if (!is_ifunc)
	      {
		target->push_branch(ppc_object, data_shndx,
				    reloc.get_r_offset(), r_type,
				    elfcpp::elf_r_sym<size>(reloc.get_r_info()),
				    reloc.get_r_addend());
		target->make_plt_entry(symtab, layout, gsym);
	      }
	    // Since this is not a PC-relative relocation, we may be
	    // taking the address of a function. In that case we need to
	    // set the entry in the dynamic symbol table to the address of
	    // the PLT call stub.
	    if (size == 32
		&& gsym->is_from_dynobj()
		&& !parameters->options().output_is_position_independent())
	      gsym->set_needs_dynsym_value();
	  }
	// Make a dynamic relocation if necessary.
	if (needs_dynamic_reloc<size>(gsym, Scan::get_reference_flags(r_type))
	    || (size == 64 && is_ifunc))
	  {
	    if (gsym->may_need_copy_reloc())
	      {
		target->copy_reloc(symtab, layout, object,
				   data_shndx, output_section, gsym, reloc);
	      }
	    else if ((size == 32
		      && r_type == elfcpp::R_POWERPC_ADDR32
		      && gsym->can_use_relative_reloc(false)
		      && !(gsym->visibility() == elfcpp::STV_PROTECTED
			   && parameters->options().shared()))
		     || (size == 64
			 && r_type == elfcpp::R_PPC64_ADDR64
			 && (gsym->can_use_relative_reloc(false)
			     || data_shndx == ppc_object->opd_shndx())))
	      {
		Reloc_section* rela_dyn
		  = target->rela_dyn_section(symtab, layout, is_ifunc);
		unsigned int dynrel = (is_ifunc ? elfcpp::R_POWERPC_IRELATIVE
				       : elfcpp::R_POWERPC_RELATIVE);
		rela_dyn->add_symbolless_global_addend(
		    gsym, dynrel, output_section, object, data_shndx,
		    reloc.get_r_offset(), reloc.get_r_addend());
	      }
	    else
	      {
		Reloc_section* rela_dyn
		  = target->rela_dyn_section(symtab, layout, is_ifunc);
		check_non_pic(object, r_type);
		rela_dyn->add_global(gsym, r_type, output_section,
				     object, data_shndx,
				     reloc.get_r_offset(),
				     reloc.get_r_addend());
	      }
	  }
      }
      break;

    case elfcpp::R_PPC_PLTREL24:
    case elfcpp::R_POWERPC_REL24:
      if (!is_ifunc)
	{
	  target->push_branch(ppc_object, data_shndx, reloc.get_r_offset(),
			      r_type,
			      elfcpp::elf_r_sym<size>(reloc.get_r_info()),
			      reloc.get_r_addend());
	  if (gsym->needs_plt_entry()
	      || (!gsym->final_value_is_known()
		  && (gsym->is_undefined()
		      || gsym->is_from_dynobj()
		      || gsym->is_preemptible())))
	    target->make_plt_entry(symtab, layout, gsym);
	}
      // Fall thru

    case elfcpp::R_PPC64_REL64:
    case elfcpp::R_POWERPC_REL32:
      // Make a dynamic relocation if necessary.
      if (needs_dynamic_reloc<size>(gsym, Scan::get_reference_flags(r_type)))
	{
	  if (gsym->may_need_copy_reloc())
	    {
	      target->copy_reloc(symtab, layout, object,
				 data_shndx, output_section, gsym,
				 reloc);
	    }
	  else
	    {
	      Reloc_section* rela_dyn
		= target->rela_dyn_section(symtab, layout, is_ifunc);
	      check_non_pic(object, r_type);
	      rela_dyn->add_global(gsym, r_type, output_section, object,
				   data_shndx, reloc.get_r_offset(),
				   reloc.get_r_addend());
	    }
	}
      break;

    case elfcpp::R_POWERPC_REL14:
    case elfcpp::R_POWERPC_REL14_BRTAKEN:
    case elfcpp::R_POWERPC_REL14_BRNTAKEN:
      if (!is_ifunc)
	target->push_branch(ppc_object, data_shndx, reloc.get_r_offset(),
			    r_type, elfcpp::elf_r_sym<size>(reloc.get_r_info()),
			    reloc.get_r_addend());
      break;

    case elfcpp::R_POWERPC_REL16:
    case elfcpp::R_POWERPC_REL16_LO:
    case elfcpp::R_POWERPC_REL16_HI:
    case elfcpp::R_POWERPC_REL16_HA:
    case elfcpp::R_POWERPC_SECTOFF:
    case elfcpp::R_POWERPC_TPREL16:
    case elfcpp::R_POWERPC_DTPREL16:
    case elfcpp::R_POWERPC_SECTOFF_LO:
    case elfcpp::R_POWERPC_TPREL16_LO:
    case elfcpp::R_POWERPC_DTPREL16_LO:
    case elfcpp::R_POWERPC_SECTOFF_HI:
    case elfcpp::R_POWERPC_TPREL16_HI:
    case elfcpp::R_POWERPC_DTPREL16_HI:
    case elfcpp::R_POWERPC_SECTOFF_HA:
    case elfcpp::R_POWERPC_TPREL16_HA:
    case elfcpp::R_POWERPC_DTPREL16_HA:
    case elfcpp::R_PPC64_DTPREL16_HIGHER:
    case elfcpp::R_PPC64_TPREL16_HIGHER:
    case elfcpp::R_PPC64_DTPREL16_HIGHERA:
    case elfcpp::R_PPC64_TPREL16_HIGHERA:
    case elfcpp::R_PPC64_DTPREL16_HIGHEST:
    case elfcpp::R_PPC64_TPREL16_HIGHEST:
    case elfcpp::R_PPC64_DTPREL16_HIGHESTA:
    case elfcpp::R_PPC64_TPREL16_HIGHESTA:
    case elfcpp::R_PPC64_TPREL16_DS:
    case elfcpp::R_PPC64_TPREL16_LO_DS:
    case elfcpp::R_PPC64_DTPREL16_DS:
    case elfcpp::R_PPC64_DTPREL16_LO_DS:
    case elfcpp::R_PPC64_SECTOFF_DS:
    case elfcpp::R_PPC64_SECTOFF_LO_DS:
    case elfcpp::R_PPC64_TLSGD:
    case elfcpp::R_PPC64_TLSLD:
      break;

    case elfcpp::R_POWERPC_GOT16:
    case elfcpp::R_POWERPC_GOT16_LO:
    case elfcpp::R_POWERPC_GOT16_HI:
    case elfcpp::R_POWERPC_GOT16_HA:
    case elfcpp::R_PPC64_GOT16_DS:
    case elfcpp::R_PPC64_GOT16_LO_DS:
      {
	// The symbol requires a GOT entry.
	Output_data_got_powerpc<size, big_endian>* got;

	got = target->got_section(symtab, layout);
	if (gsym->final_value_is_known())
	  {
	    if (size == 32 && is_ifunc)
	      got->add_global_plt(gsym, GOT_TYPE_STANDARD);
	    else
	      got->add_global(gsym, GOT_TYPE_STANDARD);
	  }
	else if (!gsym->has_got_offset(GOT_TYPE_STANDARD))
	  {
	    // If we are generating a shared object or a pie, this
	    // symbol's GOT entry will be set by a dynamic relocation.
	    unsigned int off = got->add_constant(0);
	    gsym->set_got_offset(GOT_TYPE_STANDARD, off);

	    Reloc_section* rela_dyn
	      = target->rela_dyn_section(symtab, layout, is_ifunc);

	    if (gsym->can_use_relative_reloc(false)
		&& !(size == 32
		     && gsym->visibility() == elfcpp::STV_PROTECTED
		     && parameters->options().shared()))
	      {
		unsigned int dynrel = (is_ifunc ? elfcpp::R_POWERPC_IRELATIVE
				       : elfcpp::R_POWERPC_RELATIVE);
		rela_dyn->add_global_relative(gsym, dynrel, got, off, 0, false);
	      }
	    else
	      {
		unsigned int dynrel = elfcpp::R_POWERPC_GLOB_DAT;
		rela_dyn->add_global(gsym, dynrel, got, off, 0);
	      }
	  }
      }
      break;

    case elfcpp::R_PPC64_TOC16:
    case elfcpp::R_PPC64_TOC16_LO:
    case elfcpp::R_PPC64_TOC16_HI:
    case elfcpp::R_PPC64_TOC16_HA:
    case elfcpp::R_PPC64_TOC16_DS:
    case elfcpp::R_PPC64_TOC16_LO_DS:
      // We need a GOT section.
      target->got_section(symtab, layout);
      break;

    case elfcpp::R_POWERPC_GOT_TLSGD16:
    case elfcpp::R_POWERPC_GOT_TLSGD16_LO:
    case elfcpp::R_POWERPC_GOT_TLSGD16_HI:
    case elfcpp::R_POWERPC_GOT_TLSGD16_HA:
      {
	const bool final = gsym->final_value_is_known();
	const tls::Tls_optimization tls_type = target->optimize_tls_gd(final);
	if (tls_type == tls::TLSOPT_NONE)
	  {
	    Output_data_got_powerpc<size, big_endian>* got
	      = target->got_section(symtab, layout);
	    Reloc_section* rela_dyn = target->rela_dyn_section(layout);
	    got->add_global_pair_with_rel(gsym, GOT_TYPE_TLSGD, rela_dyn,
					  elfcpp::R_POWERPC_DTPMOD,
					  elfcpp::R_POWERPC_DTPREL);
	  }
	else if (tls_type == tls::TLSOPT_TO_IE)
	  {
	    if (!gsym->has_got_offset(GOT_TYPE_TPREL))
	      {
		Output_data_got_powerpc<size, big_endian>* got
		  = target->got_section(symtab, layout);
		Reloc_section* rela_dyn = target->rela_dyn_section(layout);
		if (gsym->is_undefined()
		    || gsym->is_from_dynobj())
		  {
		    got->add_global_with_rel(gsym, GOT_TYPE_TPREL, rela_dyn,
					     elfcpp::R_POWERPC_TPREL);
		  }
		else
		  {
		    unsigned int off = got->add_constant(0);
		    gsym->set_got_offset(GOT_TYPE_TPREL, off);
		    unsigned int dynrel = elfcpp::R_POWERPC_TPREL;
		    rela_dyn->add_symbolless_global_addend(gsym, dynrel,
							   got, off, 0);
		  }
	      }
	  }
	else if (tls_type == tls::TLSOPT_TO_LE)
	  {
	    // no GOT relocs needed for Local Exec.
	  }
	else
	  gold_unreachable();
      }
      break;

    case elfcpp::R_POWERPC_GOT_TLSLD16:
    case elfcpp::R_POWERPC_GOT_TLSLD16_LO:
    case elfcpp::R_POWERPC_GOT_TLSLD16_HI:
    case elfcpp::R_POWERPC_GOT_TLSLD16_HA:
      {
	const tls::Tls_optimization tls_type = target->optimize_tls_ld();
	if (tls_type == tls::TLSOPT_NONE)
	  target->tlsld_got_offset(symtab, layout, object);
	else if (tls_type == tls::TLSOPT_TO_LE)
	  {
	    // no GOT relocs needed for Local Exec.
	    if (parameters->options().emit_relocs())
	      {
		Output_section* os = layout->tls_segment()->first_section();
		gold_assert(os != NULL);
		os->set_needs_symtab_index();
	      }
	  }
	else
	  gold_unreachable();
      }
      break;

    case elfcpp::R_POWERPC_GOT_DTPREL16:
    case elfcpp::R_POWERPC_GOT_DTPREL16_LO:
    case elfcpp::R_POWERPC_GOT_DTPREL16_HI:
    case elfcpp::R_POWERPC_GOT_DTPREL16_HA:
      {
	Output_data_got_powerpc<size, big_endian>* got
	  = target->got_section(symtab, layout);
	if (!gsym->final_value_is_known()
	    && (gsym->is_from_dynobj()
		|| gsym->is_undefined()
		|| gsym->is_preemptible()))
	  got->add_global_with_rel(gsym, GOT_TYPE_DTPREL,
				   target->rela_dyn_section(layout),
				   elfcpp::R_POWERPC_DTPREL);
	else
	  got->add_global_tls(gsym, GOT_TYPE_DTPREL);
      }
      break;

    case elfcpp::R_POWERPC_GOT_TPREL16:
    case elfcpp::R_POWERPC_GOT_TPREL16_LO:
    case elfcpp::R_POWERPC_GOT_TPREL16_HI:
    case elfcpp::R_POWERPC_GOT_TPREL16_HA:
      {
	const bool final = gsym->final_value_is_known();
	const tls::Tls_optimization tls_type = target->optimize_tls_ie(final);
	if (tls_type == tls::TLSOPT_NONE)
	  {
	    if (!gsym->has_got_offset(GOT_TYPE_TPREL))
	      {
		Output_data_got_powerpc<size, big_endian>* got
		  = target->got_section(symtab, layout);
		Reloc_section* rela_dyn = target->rela_dyn_section(layout);
		if (gsym->is_undefined()
		    || gsym->is_from_dynobj())
		  {
		    got->add_global_with_rel(gsym, GOT_TYPE_TPREL, rela_dyn,
					     elfcpp::R_POWERPC_TPREL);
		  }
		else
		  {
		    unsigned int off = got->add_constant(0);
		    gsym->set_got_offset(GOT_TYPE_TPREL, off);
		    unsigned int dynrel = elfcpp::R_POWERPC_TPREL;
		    rela_dyn->add_symbolless_global_addend(gsym, dynrel,
							   got, off, 0);
		  }
	      }
	  }
	else if (tls_type == tls::TLSOPT_TO_LE)
	  {
	    // no GOT relocs needed for Local Exec.
	  }
	else
	  gold_unreachable();
      }
      break;

    default:
      unsupported_reloc_global(object, r_type, gsym);
      break;
    }

  switch (r_type)
    {
    case elfcpp::R_POWERPC_GOT_TLSLD16:
    case elfcpp::R_POWERPC_GOT_TLSGD16:
    case elfcpp::R_POWERPC_GOT_TPREL16:
    case elfcpp::R_POWERPC_GOT_DTPREL16:
    case elfcpp::R_POWERPC_GOT16:
    case elfcpp::R_PPC64_GOT16_DS:
    case elfcpp::R_PPC64_TOC16:
    case elfcpp::R_PPC64_TOC16_DS:
      ppc_object->set_has_small_toc_reloc();
    default:
      break;
    }
}

// Process relocations for gc.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::gc_process_relocs(
    Symbol_table* symtab,
    Layout* layout,
    Sized_relobj_file<size, big_endian>* object,
    unsigned int data_shndx,
    unsigned int,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    size_t local_symbol_count,
    const unsigned char* plocal_symbols)
{
  typedef Target_powerpc<size, big_endian> Powerpc;
  typedef typename Target_powerpc<size, big_endian>::Scan Scan;
  Powerpc_relobj<size, big_endian>* ppc_object
    = static_cast<Powerpc_relobj<size, big_endian>*>(object);
  if (size == 64)
    ppc_object->set_opd_valid();
  if (size == 64 && data_shndx == ppc_object->opd_shndx())
    {
      typename Powerpc_relobj<size, big_endian>::Access_from::iterator p;
      for (p = ppc_object->access_from_map()->begin();
	   p != ppc_object->access_from_map()->end();
	   ++p)
	{
	  Address dst_off = p->first;
	  unsigned int dst_indx = ppc_object->get_opd_ent(dst_off);
	  typename Powerpc_relobj<size, big_endian>::Section_refs::iterator s;
	  for (s = p->second.begin(); s != p->second.end(); ++s)
	    {
	      Object* src_obj = s->first;
	      unsigned int src_indx = s->second;
	      symtab->gc()->add_reference(src_obj, src_indx,
					  ppc_object, dst_indx);
	    }
	  p->second.clear();
	}
      ppc_object->access_from_map()->clear();
      ppc_object->process_gc_mark(symtab);
      // Don't look at .opd relocs as .opd will reference everything.
      return;
    }

  gold::gc_process_relocs<size, big_endian, Powerpc, elfcpp::SHT_RELA, Scan,
			  typename Target_powerpc::Relocatable_size_for_reloc>(
    symtab,
    layout,
    this,
    object,
    data_shndx,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    local_symbol_count,
    plocal_symbols);
}

// Handle target specific gc actions when adding a gc reference from
// SRC_OBJ, SRC_SHNDX to a location specified by DST_OBJ, DST_SHNDX
// and DST_OFF.  For powerpc64, this adds a referenc to the code
// section of a function descriptor.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::do_gc_add_reference(
    Symbol_table* symtab,
    Object* src_obj,
    unsigned int src_shndx,
    Object* dst_obj,
    unsigned int dst_shndx,
    Address dst_off) const
{
  if (size != 64 || dst_obj->is_dynamic())
    return;

  Powerpc_relobj<size, big_endian>* ppc_object
    = static_cast<Powerpc_relobj<size, big_endian>*>(dst_obj);
  if (dst_shndx != 0 && dst_shndx == ppc_object->opd_shndx())
    {
      if (ppc_object->opd_valid())
	{
	  dst_shndx = ppc_object->get_opd_ent(dst_off);
	  symtab->gc()->add_reference(src_obj, src_shndx, dst_obj, dst_shndx);
	}
      else
	{
	  // If we haven't run scan_opd_relocs, we must delay
	  // processing this function descriptor reference.
	  ppc_object->add_reference(src_obj, src_shndx, dst_off);
	}
    }
}

// Add any special sections for this symbol to the gc work list.
// For powerpc64, this adds the code section of a function
// descriptor.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::do_gc_mark_symbol(
    Symbol_table* symtab,
    Symbol* sym) const
{
  if (size == 64)
    {
      Powerpc_relobj<size, big_endian>* ppc_object
	= static_cast<Powerpc_relobj<size, big_endian>*>(sym->object());
      bool is_ordinary;
      unsigned int shndx = sym->shndx(&is_ordinary);
      if (is_ordinary && shndx != 0 && shndx == ppc_object->opd_shndx())
	{
	  Sized_symbol<size>* gsym = symtab->get_sized_symbol<size>(sym);
	  Address dst_off = gsym->value();
	  if (ppc_object->opd_valid())
	    {
	      unsigned int dst_indx = ppc_object->get_opd_ent(dst_off);
	      symtab->gc()->worklist().push(Section_id(ppc_object, dst_indx));
	    }
	  else
	    ppc_object->add_gc_mark(dst_off);
	}
    }
}

// For a symbol location in .opd, set LOC to the location of the
// function entry.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::do_function_location(
    Symbol_location* loc) const
{
  if (size == 64 && loc->shndx != 0)
    {
      if (loc->object->is_dynamic())
	{
	  Powerpc_dynobj<size, big_endian>* ppc_object
	    = static_cast<Powerpc_dynobj<size, big_endian>*>(loc->object);
	  if (loc->shndx == ppc_object->opd_shndx())
	    {
	      Address dest_off;
	      Address off = loc->offset - ppc_object->opd_address();
	      loc->shndx = ppc_object->get_opd_ent(off, &dest_off);
	      loc->offset = dest_off;
	    }
	}
      else
	{
	  const Powerpc_relobj<size, big_endian>* ppc_object
	    = static_cast<const Powerpc_relobj<size, big_endian>*>(loc->object);
	  if (loc->shndx == ppc_object->opd_shndx())
	    {
	      Address dest_off;
	      loc->shndx = ppc_object->get_opd_ent(loc->offset, &dest_off);
	      loc->offset = dest_off;
	    }
	}
    }
}

// Scan relocations for a section.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::scan_relocs(
    Symbol_table* symtab,
    Layout* layout,
    Sized_relobj_file<size, big_endian>* object,
    unsigned int data_shndx,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    size_t local_symbol_count,
    const unsigned char* plocal_symbols)
{
  typedef Target_powerpc<size, big_endian> Powerpc;
  typedef typename Target_powerpc<size, big_endian>::Scan Scan;

  if (sh_type == elfcpp::SHT_REL)
    {
      gold_error(_("%s: unsupported REL reloc section"),
		 object->name().c_str());
      return;
    }

  gold::scan_relocs<size, big_endian, Powerpc, elfcpp::SHT_RELA, Scan>(
    symtab,
    layout,
    this,
    object,
    data_shndx,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    local_symbol_count,
    plocal_symbols);
}

// Functor class for processing the global symbol table.
// Removes symbols defined on discarded opd entries.

template<bool big_endian>
class Global_symbol_visitor_opd
{
 public:
  Global_symbol_visitor_opd()
  { }

  void
  operator()(Sized_symbol<64>* sym)
  {
    if (sym->has_symtab_index()
	|| sym->source() != Symbol::FROM_OBJECT
	|| !sym->in_real_elf())
      return;

    if (sym->object()->is_dynamic())
      return;

    Powerpc_relobj<64, big_endian>* symobj
      = static_cast<Powerpc_relobj<64, big_endian>*>(sym->object());
    if (symobj->opd_shndx() == 0)
      return;

    bool is_ordinary;
    unsigned int shndx = sym->shndx(&is_ordinary);
    if (shndx == symobj->opd_shndx()
	&& symobj->get_opd_discard(sym->value()))
      sym->set_symtab_index(-1U);
  }
};

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::define_save_restore_funcs(
    Layout* layout,
    Symbol_table* symtab)
{
  if (size == 64)
    {
      Output_data_save_res<64, big_endian>* savres
	= new Output_data_save_res<64, big_endian>(symtab);
      layout->add_output_section_data(".text", elfcpp::SHT_PROGBITS,
				      elfcpp::SHF_ALLOC | elfcpp::SHF_EXECINSTR,
				      savres, ORDER_TEXT, false);
    }
}

// Sort linker created .got section first (for the header), then input
// sections belonging to files using small model code.

template<bool big_endian>
class Sort_toc_sections
{
 public:
  bool
  operator()(const Output_section::Input_section& is1,
	     const Output_section::Input_section& is2) const
  {
    if (!is1.is_input_section() && is2.is_input_section())
      return true;
    bool small1
      = (is1.is_input_section()
	 && (static_cast<const Powerpc_relobj<64, big_endian>*>(is1.relobj())
	     ->has_small_toc_reloc()));
    bool small2
      = (is2.is_input_section()
	 && (static_cast<const Powerpc_relobj<64, big_endian>*>(is2.relobj())
	     ->has_small_toc_reloc()));
    return small1 && !small2;
  }
};

// Finalize the sections.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::do_finalize_sections(
    Layout* layout,
    const Input_objects*,
    Symbol_table* symtab)
{
  if (parameters->doing_static_link())
    {
      // At least some versions of glibc elf-init.o have a strong
      // reference to __rela_iplt marker syms.  A weak ref would be
      // better..
      if (this->iplt_ != NULL)
	{
	  Reloc_section* rel = this->iplt_->rel_plt();
	  symtab->define_in_output_data("__rela_iplt_start", NULL,
					Symbol_table::PREDEFINED, rel, 0, 0,
					elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
					elfcpp::STV_HIDDEN, 0, false, true);
	  symtab->define_in_output_data("__rela_iplt_end", NULL,
					Symbol_table::PREDEFINED, rel, 0, 0,
					elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
					elfcpp::STV_HIDDEN, 0, true, true);
	}
      else
	{
	  symtab->define_as_constant("__rela_iplt_start", NULL,
				     Symbol_table::PREDEFINED, 0, 0,
				     elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
				     elfcpp::STV_HIDDEN, 0, true, false);
	  symtab->define_as_constant("__rela_iplt_end", NULL,
				     Symbol_table::PREDEFINED, 0, 0,
				     elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
				     elfcpp::STV_HIDDEN, 0, true, false);
	}
    }

  if (size == 64)
    {
      typedef Global_symbol_visitor_opd<big_endian> Symbol_visitor;
      symtab->for_all_symbols<64, Symbol_visitor>(Symbol_visitor());

      if (!parameters->options().relocatable())
	{
	  this->define_save_restore_funcs(layout, symtab);

	  // Annoyingly, we need to make these sections now whether or
	  // not we need them.  If we delay until do_relax then we
	  // need to mess with the relaxation machinery checkpointing.
	  this->got_section(symtab, layout);
	  this->make_brlt_section(layout);

	  if (parameters->options().toc_sort())
	    {
	      Output_section* os = this->got_->output_section();
	      if (os != NULL && os->input_sections().size() > 1)
		std::stable_sort(os->input_sections().begin(),
				 os->input_sections().end(),
				 Sort_toc_sections<big_endian>());
	    }
	}
    }

  // Fill in some more dynamic tags.
  Output_data_dynamic* odyn = layout->dynamic_data();
  if (odyn != NULL)
    {
      const Reloc_section* rel_plt = (this->plt_ == NULL
				      ? NULL
				      : this->plt_->rel_plt());
      layout->add_target_dynamic_tags(false, this->plt_, rel_plt,
				      this->rela_dyn_, true, size == 32);

      if (size == 32)
	{
	  if (this->got_ != NULL)
	    {
	      this->got_->finalize_data_size();
	      odyn->add_section_plus_offset(elfcpp::DT_PPC_GOT,
					    this->got_, this->got_->g_o_t());
	    }
	}
      else
	{
	  if (this->glink_ != NULL)
	    {
	      this->glink_->finalize_data_size();
	      odyn->add_section_plus_offset(elfcpp::DT_PPC64_GLINK,
					    this->glink_,
					    (this->glink_->pltresolve_size
					     - 32));
	    }
	}
    }

  // Emit any relocs we saved in an attempt to avoid generating COPY
  // relocs.
  if (this->copy_relocs_.any_saved_relocs())
    this->copy_relocs_.emit(this->rela_dyn_section(layout));
}

// Return TRUE iff INSN is one we expect on a _LO variety toc/got
// reloc.

static bool
ok_lo_toc_insn(uint32_t insn)
{
  return ((insn & (0x3f << 26)) == 14u << 26 /* addi */
	  || (insn & (0x3f << 26)) == 32u << 26 /* lwz */
	  || (insn & (0x3f << 26)) == 34u << 26 /* lbz */
	  || (insn & (0x3f << 26)) == 36u << 26 /* stw */
	  || (insn & (0x3f << 26)) == 38u << 26 /* stb */
	  || (insn & (0x3f << 26)) == 40u << 26 /* lhz */
	  || (insn & (0x3f << 26)) == 42u << 26 /* lha */
	  || (insn & (0x3f << 26)) == 44u << 26 /* sth */
	  || (insn & (0x3f << 26)) == 46u << 26 /* lmw */
	  || (insn & (0x3f << 26)) == 47u << 26 /* stmw */
	  || (insn & (0x3f << 26)) == 48u << 26 /* lfs */
	  || (insn & (0x3f << 26)) == 50u << 26 /* lfd */
	  || (insn & (0x3f << 26)) == 52u << 26 /* stfs */
	  || (insn & (0x3f << 26)) == 54u << 26 /* stfd */
	  || ((insn & (0x3f << 26)) == 58u << 26 /* lwa,ld,lmd */
	      && (insn & 3) != 1)
	  || ((insn & (0x3f << 26)) == 62u << 26 /* std, stmd */
	      && ((insn & 3) == 0 || (insn & 3) == 3))
	  || (insn & (0x3f << 26)) == 12u << 26 /* addic */);
}

// Return the value to use for a branch relocation.

template<int size, bool big_endian>
typename Target_powerpc<size, big_endian>::Address
Target_powerpc<size, big_endian>::symval_for_branch(
    const Symbol_table* symtab,
    Address value,
    const Sized_symbol<size>* gsym,
    Powerpc_relobj<size, big_endian>* object,
    unsigned int *dest_shndx)
{
  *dest_shndx = 0;
  if (size == 32)
    return value;

  // If the symbol is defined in an opd section, ie. is a function
  // descriptor, use the function descriptor code entry address
  Powerpc_relobj<size, big_endian>* symobj = object;
  if (gsym != NULL
      && gsym->source() != Symbol::FROM_OBJECT)
    return value;
  if (gsym != NULL)
    symobj = static_cast<Powerpc_relobj<size, big_endian>*>(gsym->object());
  unsigned int shndx = symobj->opd_shndx();
  if (shndx == 0)
    return value;
  Address opd_addr = symobj->get_output_section_offset(shndx);
  if (opd_addr == invalid_address)
    return value;
  opd_addr += symobj->output_section_address(shndx);
  if (value >= opd_addr && value < opd_addr + symobj->section_size(shndx))
    {
      Address sec_off;
      *dest_shndx = symobj->get_opd_ent(value - opd_addr, &sec_off);
      if (symtab->is_section_folded(symobj, *dest_shndx))
	{
	  Section_id folded
	    = symtab->icf()->get_folded_section(symobj, *dest_shndx);
	  symobj = static_cast<Powerpc_relobj<size, big_endian>*>(folded.first);
	  *dest_shndx = folded.second;
	}
      Address sec_addr = symobj->get_output_section_offset(*dest_shndx);
      gold_assert(sec_addr != invalid_address);
      sec_addr += symobj->output_section(*dest_shndx)->address();
      value = sec_addr + sec_off;
    }
  return value;
}

// Perform a relocation.

template<int size, bool big_endian>
inline bool
Target_powerpc<size, big_endian>::Relocate::relocate(
    const Relocate_info<size, big_endian>* relinfo,
    Target_powerpc* target,
    Output_section* os,
    size_t relnum,
    const elfcpp::Rela<size, big_endian>& rela,
    unsigned int r_type,
    const Sized_symbol<size>* gsym,
    const Symbol_value<size>* psymval,
    unsigned char* view,
    Address address,
    section_size_type view_size)
{
  if (view == NULL)
    return true;

  switch (this->maybe_skip_tls_get_addr_call(r_type, gsym))
    {
    case Track_tls::NOT_EXPECTED:
      gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			     _("__tls_get_addr call lacks marker reloc"));
      break;
    case Track_tls::EXPECTED:
      // We have already complained.
      break;
    case Track_tls::SKIP:
      return true;
    case Track_tls::NORMAL:
      break;
    }

  typedef Powerpc_relocate_functions<size, big_endian> Reloc;
  typedef typename elfcpp::Swap<32, big_endian>::Valtype Insn;
  Powerpc_relobj<size, big_endian>* const object
    = static_cast<Powerpc_relobj<size, big_endian>*>(relinfo->object);
  Address value = 0;
  bool has_plt_value = false;
  unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
  if ((gsym != NULL
       ? use_plt_offset<size>(gsym, Scan::get_reference_flags(r_type))
       : object->local_has_plt_offset(r_sym))
      && (!psymval->is_ifunc_symbol()
	  || Scan::reloc_needs_plt_for_ifunc(object, r_type, false)))
    {
      Stub_table<size, big_endian>* stub_table
	= object->stub_table(relinfo->data_shndx);
      if (stub_table == NULL)
	{
	  // This is a ref from a data section to an ifunc symbol.
	  if (target->stub_tables().size() != 0)
	    stub_table = target->stub_tables()[0];
	}
      gold_assert(stub_table != NULL);
      Address off;
      if (gsym != NULL)
	off = stub_table->find_plt_call_entry(object, gsym, r_type,
					      rela.get_r_addend());
      else
	off = stub_table->find_plt_call_entry(object, r_sym, r_type,
					      rela.get_r_addend());
      gold_assert(off != invalid_address);
      value = stub_table->stub_address() + off;
      has_plt_value = true;
    }

  if (r_type == elfcpp::R_POWERPC_GOT16
      || r_type == elfcpp::R_POWERPC_GOT16_LO
      || r_type == elfcpp::R_POWERPC_GOT16_HI
      || r_type == elfcpp::R_POWERPC_GOT16_HA
      || r_type == elfcpp::R_PPC64_GOT16_DS
      || r_type == elfcpp::R_PPC64_GOT16_LO_DS)
    {
      if (gsym != NULL)
	{
	  gold_assert(gsym->has_got_offset(GOT_TYPE_STANDARD));
	  value = gsym->got_offset(GOT_TYPE_STANDARD);
	}
      else
	{
	  unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
	  gold_assert(object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD));
	  value = object->local_got_offset(r_sym, GOT_TYPE_STANDARD);
	}
      value -= target->got_section()->got_base_offset(object);
    }
  else if (r_type == elfcpp::R_PPC64_TOC)
    {
      value = (target->got_section()->output_section()->address()
	       + object->toc_base_offset());
    }
  else if (gsym != NULL
	   && (r_type == elfcpp::R_POWERPC_REL24
	       || r_type == elfcpp::R_PPC_PLTREL24)
	   && has_plt_value)
    {
      if (size == 64)
	{
	  typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
	  Valtype* wv = reinterpret_cast<Valtype*>(view);
	  bool can_plt_call = false;
	  if (rela.get_r_offset() + 8 <= view_size)
	    {
	      Valtype insn = elfcpp::Swap<32, big_endian>::readval(wv);
	      Valtype insn2 = elfcpp::Swap<32, big_endian>::readval(wv + 1);
	      if ((insn & 1) != 0
		  && (insn2 == nop
		      || insn2 == cror_15_15_15 || insn2 == cror_31_31_31))
		{
		  elfcpp::Swap<32, big_endian>::writeval(wv + 1, ld_2_1 + 40);
		  can_plt_call = true;
		}
	    }
	  if (!can_plt_call)
	    {
	      // If we don't have a branch and link followed by a nop,
	      // we can't go via the plt because there is no place to
	      // put a toc restoring instruction.
	      // Unless we know we won't be returning.
	      if (strcmp(gsym->name(), "__libc_start_main") == 0)
		can_plt_call = true;
	    }
	  if (!can_plt_call)
	    {
	      // g++ as of 20130507 emits self-calls without a
	      // following nop.  This is arguably wrong since we have
	      // conflicting information.  On the one hand a global
	      // symbol and on the other a local call sequence, but
	      // don't error for this special case.
	      // It isn't possible to cheaply verify we have exactly
	      // such a call.  Allow all calls to the same section.
	      bool ok = false;
	      Address code = value;
	      if (gsym->source() == Symbol::FROM_OBJECT
		  && gsym->object() == object)
		{
		  Address addend = rela.get_r_addend();
		  unsigned int dest_shndx;
		  Address opdent = psymval->value(object, addend);
		  code = target->symval_for_branch(relinfo->symtab, opdent,
						   gsym, object, &dest_shndx);
		  bool is_ordinary;
		  if (dest_shndx == 0)
		    dest_shndx = gsym->shndx(&is_ordinary);
		  ok = dest_shndx == relinfo->data_shndx;
		}
	      if (!ok)
		{
		  gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
					 _("call lacks nop, can't restore toc; "
					   "recompile with -fPIC"));
		  value = code;
		}
	    }
	}
    }
  else if (r_type == elfcpp::R_POWERPC_GOT_TLSGD16
	   || r_type == elfcpp::R_POWERPC_GOT_TLSGD16_LO
	   || r_type == elfcpp::R_POWERPC_GOT_TLSGD16_HI
	   || r_type == elfcpp::R_POWERPC_GOT_TLSGD16_HA)
    {
      // First instruction of a global dynamic sequence, arg setup insn.
      const bool final = gsym == NULL || gsym->final_value_is_known();
      const tls::Tls_optimization tls_type = target->optimize_tls_gd(final);
      enum Got_type got_type = GOT_TYPE_STANDARD;
      if (tls_type == tls::TLSOPT_NONE)
	got_type = GOT_TYPE_TLSGD;
      else if (tls_type == tls::TLSOPT_TO_IE)
	got_type = GOT_TYPE_TPREL;
      if (got_type != GOT_TYPE_STANDARD)
	{
	  if (gsym != NULL)
	    {
	      gold_assert(gsym->has_got_offset(got_type));
	      value = gsym->got_offset(got_type);
	    }
	  else
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
	      gold_assert(object->local_has_got_offset(r_sym, got_type));
	      value = object->local_got_offset(r_sym, got_type);
	    }
	  value -= target->got_section()->got_base_offset(object);
	}
      if (tls_type == tls::TLSOPT_TO_IE)
	{
	  if (r_type == elfcpp::R_POWERPC_GOT_TLSGD16
	      || r_type == elfcpp::R_POWERPC_GOT_TLSGD16_LO)
	    {
	      Insn* iview = reinterpret_cast<Insn*>(view - 2 * big_endian);
	      Insn insn = elfcpp::Swap<32, big_endian>::readval(iview);
	      insn &= (1 << 26) - (1 << 16); // extract rt,ra from addi
	      if (size == 32)
		insn |= 32 << 26; // lwz
	      else
		insn |= 58 << 26; // ld
	      elfcpp::Swap<32, big_endian>::writeval(iview, insn);
	    }
	  r_type += (elfcpp::R_POWERPC_GOT_TPREL16
		     - elfcpp::R_POWERPC_GOT_TLSGD16);
	}
      else if (tls_type == tls::TLSOPT_TO_LE)
	{
	  if (r_type == elfcpp::R_POWERPC_GOT_TLSGD16
	      || r_type == elfcpp::R_POWERPC_GOT_TLSGD16_LO)
	    {
	      Insn* iview = reinterpret_cast<Insn*>(view - 2 * big_endian);
	      Insn insn = addis_3_13;
	      if (size == 32)
		insn = addis_3_2;
	      elfcpp::Swap<32, big_endian>::writeval(iview, insn);
	      r_type = elfcpp::R_POWERPC_TPREL16_HA;
	      value = psymval->value(object, rela.get_r_addend());
	    }
	  else
	    {
	      Insn* iview = reinterpret_cast<Insn*>(view - 2 * big_endian);
	      Insn insn = nop;
	      elfcpp::Swap<32, big_endian>::writeval(iview, insn);
	      r_type = elfcpp::R_POWERPC_NONE;
	    }
	}
    }
  else if (r_type == elfcpp::R_POWERPC_GOT_TLSLD16
	   || r_type == elfcpp::R_POWERPC_GOT_TLSLD16_LO
	   || r_type == elfcpp::R_POWERPC_GOT_TLSLD16_HI
	   || r_type == elfcpp::R_POWERPC_GOT_TLSLD16_HA)
    {
      // First instruction of a local dynamic sequence, arg setup insn.
      const tls::Tls_optimization tls_type = target->optimize_tls_ld();
      if (tls_type == tls::TLSOPT_NONE)
	{
	  value = target->tlsld_got_offset();
	  value -= target->got_section()->got_base_offset(object);
	}
      else
	{
	  gold_assert(tls_type == tls::TLSOPT_TO_LE);
	  if (r_type == elfcpp::R_POWERPC_GOT_TLSLD16
	      || r_type == elfcpp::R_POWERPC_GOT_TLSLD16_LO)
	    {
	      Insn* iview = reinterpret_cast<Insn*>(view - 2 * big_endian);
	      Insn insn = addis_3_13;
	      if (size == 32)
		insn = addis_3_2;
	      elfcpp::Swap<32, big_endian>::writeval(iview, insn);
	      r_type = elfcpp::R_POWERPC_TPREL16_HA;
	      value = dtp_offset;
	    }
	  else
	    {
	      Insn* iview = reinterpret_cast<Insn*>(view - 2 * big_endian);
	      Insn insn = nop;
	      elfcpp::Swap<32, big_endian>::writeval(iview, insn);
	      r_type = elfcpp::R_POWERPC_NONE;
	    }
	}
    }
  else if (r_type == elfcpp::R_POWERPC_GOT_DTPREL16
	   || r_type == elfcpp::R_POWERPC_GOT_DTPREL16_LO
	   || r_type == elfcpp::R_POWERPC_GOT_DTPREL16_HI
	   || r_type == elfcpp::R_POWERPC_GOT_DTPREL16_HA)
    {
      // Accesses relative to a local dynamic sequence address,
      // no optimisation here.
      if (gsym != NULL)
	{
	  gold_assert(gsym->has_got_offset(GOT_TYPE_DTPREL));
	  value = gsym->got_offset(GOT_TYPE_DTPREL);
	}
      else
	{
	  unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
	  gold_assert(object->local_has_got_offset(r_sym, GOT_TYPE_DTPREL));
	  value = object->local_got_offset(r_sym, GOT_TYPE_DTPREL);
	}
      value -= target->got_section()->got_base_offset(object);
    }
  else if (r_type == elfcpp::R_POWERPC_GOT_TPREL16
	   || r_type == elfcpp::R_POWERPC_GOT_TPREL16_LO
	   || r_type == elfcpp::R_POWERPC_GOT_TPREL16_HI
	   || r_type == elfcpp::R_POWERPC_GOT_TPREL16_HA)
    {
      // First instruction of initial exec sequence.
      const bool final = gsym == NULL || gsym->final_value_is_known();
      const tls::Tls_optimization tls_type = target->optimize_tls_ie(final);
      if (tls_type == tls::TLSOPT_NONE)
	{
	  if (gsym != NULL)
	    {
	      gold_assert(gsym->has_got_offset(GOT_TYPE_TPREL));
	      value = gsym->got_offset(GOT_TYPE_TPREL);
	    }
	  else
	    {
	      unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
	      gold_assert(object->local_has_got_offset(r_sym, GOT_TYPE_TPREL));
	      value = object->local_got_offset(r_sym, GOT_TYPE_TPREL);
	    }
	  value -= target->got_section()->got_base_offset(object);
	}
      else
	{
	  gold_assert(tls_type == tls::TLSOPT_TO_LE);
	  if (r_type == elfcpp::R_POWERPC_GOT_TPREL16
	      || r_type == elfcpp::R_POWERPC_GOT_TPREL16_LO)
	    {
	      Insn* iview = reinterpret_cast<Insn*>(view - 2 * big_endian);
	      Insn insn = elfcpp::Swap<32, big_endian>::readval(iview);
	      insn &= (1 << 26) - (1 << 21); // extract rt from ld
	      if (size == 32)
		insn |= addis_0_2;
	      else
		insn |= addis_0_13;
	      elfcpp::Swap<32, big_endian>::writeval(iview, insn);
	      r_type = elfcpp::R_POWERPC_TPREL16_HA;
	      value = psymval->value(object, rela.get_r_addend());
	    }
	  else
	    {
	      Insn* iview = reinterpret_cast<Insn*>(view - 2 * big_endian);
	      Insn insn = nop;
	      elfcpp::Swap<32, big_endian>::writeval(iview, insn);
	      r_type = elfcpp::R_POWERPC_NONE;
	    }
	}
    }
  else if ((size == 64 && r_type == elfcpp::R_PPC64_TLSGD)
	   || (size == 32 && r_type == elfcpp::R_PPC_TLSGD))
    {
      // Second instruction of a global dynamic sequence,
      // the __tls_get_addr call
      this->expect_tls_get_addr_call(relinfo, relnum, rela.get_r_offset());
      const bool final = gsym == NULL || gsym->final_value_is_known();
      const tls::Tls_optimization tls_type = target->optimize_tls_gd(final);
      if (tls_type != tls::TLSOPT_NONE)
	{
	  if (tls_type == tls::TLSOPT_TO_IE)
	    {
	      Insn* iview = reinterpret_cast<Insn*>(view);
	      Insn insn = add_3_3_13;
	      if (size == 32)
		insn = add_3_3_2;
	      elfcpp::Swap<32, big_endian>::writeval(iview, insn);
	      r_type = elfcpp::R_POWERPC_NONE;
	    }
	  else
	    {
	      Insn* iview = reinterpret_cast<Insn*>(view);
	      Insn insn = addi_3_3;
	      elfcpp::Swap<32, big_endian>::writeval(iview, insn);
	      r_type = elfcpp::R_POWERPC_TPREL16_LO;
	      view += 2 * big_endian;
	      value = psymval->value(object, rela.get_r_addend());
	    }
	  this->skip_next_tls_get_addr_call();
	}
    }
  else if ((size == 64 && r_type == elfcpp::R_PPC64_TLSLD)
	   || (size == 32 && r_type == elfcpp::R_PPC_TLSLD))
    {
      // Second instruction of a local dynamic sequence,
      // the __tls_get_addr call
      this->expect_tls_get_addr_call(relinfo, relnum, rela.get_r_offset());
      const tls::Tls_optimization tls_type = target->optimize_tls_ld();
      if (tls_type == tls::TLSOPT_TO_LE)
	{
	  Insn* iview = reinterpret_cast<Insn*>(view);
	  Insn insn = addi_3_3;
	  elfcpp::Swap<32, big_endian>::writeval(iview, insn);
	  this->skip_next_tls_get_addr_call();
	  r_type = elfcpp::R_POWERPC_TPREL16_LO;
	  view += 2 * big_endian;
	  value = dtp_offset;
	}
    }
  else if (r_type == elfcpp::R_POWERPC_TLS)
    {
      // Second instruction of an initial exec sequence
      const bool final = gsym == NULL || gsym->final_value_is_known();
      const tls::Tls_optimization tls_type = target->optimize_tls_ie(final);
      if (tls_type == tls::TLSOPT_TO_LE)
	{
	  Insn* iview = reinterpret_cast<Insn*>(view);
	  Insn insn = elfcpp::Swap<32, big_endian>::readval(iview);
	  unsigned int reg = size == 32 ? 2 : 13;
	  insn = at_tls_transform(insn, reg);
	  gold_assert(insn != 0);
	  elfcpp::Swap<32, big_endian>::writeval(iview, insn);
	  r_type = elfcpp::R_POWERPC_TPREL16_LO;
	  view += 2 * big_endian;
	  value = psymval->value(object, rela.get_r_addend());
	}
    }
  else if (!has_plt_value)
    {
      Address addend = 0;
      unsigned int dest_shndx;
      if (r_type != elfcpp::R_PPC_PLTREL24)
	addend = rela.get_r_addend();
      value = psymval->value(object, addend);
      if (size == 64 && is_branch_reloc(r_type))
	value = target->symval_for_branch(relinfo->symtab, value,
					  gsym, object, &dest_shndx);
      unsigned int max_branch_offset = 0;
      if (r_type == elfcpp::R_POWERPC_REL24
	  || r_type == elfcpp::R_PPC_PLTREL24
	  || r_type == elfcpp::R_PPC_LOCAL24PC)
	max_branch_offset = 1 << 25;
      else if (r_type == elfcpp::R_POWERPC_REL14
	       || r_type == elfcpp::R_POWERPC_REL14_BRTAKEN
	       || r_type == elfcpp::R_POWERPC_REL14_BRNTAKEN)
	max_branch_offset = 1 << 15;
      if (max_branch_offset != 0
	  && value - address + max_branch_offset >= 2 * max_branch_offset)
	{
	  Stub_table<size, big_endian>* stub_table
	    = object->stub_table(relinfo->data_shndx);
	  if (stub_table != NULL)
	    {
	      Address off = stub_table->find_long_branch_entry(object, value);
	      if (off != invalid_address)
		value = (stub_table->stub_address() + stub_table->plt_size()
			 + off);
	    }
	}
    }

  switch (r_type)
    {
    case elfcpp::R_PPC64_REL64:
    case elfcpp::R_POWERPC_REL32:
    case elfcpp::R_POWERPC_REL24:
    case elfcpp::R_PPC_PLTREL24:
    case elfcpp::R_PPC_LOCAL24PC:
    case elfcpp::R_POWERPC_REL16:
    case elfcpp::R_POWERPC_REL16_LO:
    case elfcpp::R_POWERPC_REL16_HI:
    case elfcpp::R_POWERPC_REL16_HA:
    case elfcpp::R_POWERPC_REL14:
    case elfcpp::R_POWERPC_REL14_BRTAKEN:
    case elfcpp::R_POWERPC_REL14_BRNTAKEN:
      value -= address;
      break;

    case elfcpp::R_PPC64_TOC16:
    case elfcpp::R_PPC64_TOC16_LO:
    case elfcpp::R_PPC64_TOC16_HI:
    case elfcpp::R_PPC64_TOC16_HA:
    case elfcpp::R_PPC64_TOC16_DS:
    case elfcpp::R_PPC64_TOC16_LO_DS:
      // Subtract the TOC base address.
      value -= (target->got_section()->output_section()->address()
		+ object->toc_base_offset());
      break;

    case elfcpp::R_POWERPC_SECTOFF:
    case elfcpp::R_POWERPC_SECTOFF_LO:
    case elfcpp::R_POWERPC_SECTOFF_HI:
    case elfcpp::R_POWERPC_SECTOFF_HA:
    case elfcpp::R_PPC64_SECTOFF_DS:
    case elfcpp::R_PPC64_SECTOFF_LO_DS:
      if (os != NULL)
	value -= os->address();
      break;

    case elfcpp::R_PPC64_TPREL16_DS:
    case elfcpp::R_PPC64_TPREL16_LO_DS:
      if (size != 64)
	// R_PPC_TLSGD and R_PPC_TLSLD
	break;
    case elfcpp::R_POWERPC_TPREL16:
    case elfcpp::R_POWERPC_TPREL16_LO:
    case elfcpp::R_POWERPC_TPREL16_HI:
    case elfcpp::R_POWERPC_TPREL16_HA:
    case elfcpp::R_POWERPC_TPREL:
    case elfcpp::R_PPC64_TPREL16_HIGHER:
    case elfcpp::R_PPC64_TPREL16_HIGHERA:
    case elfcpp::R_PPC64_TPREL16_HIGHEST:
    case elfcpp::R_PPC64_TPREL16_HIGHESTA:
      // tls symbol values are relative to tls_segment()->vaddr()
      value -= tp_offset;
      break;

    case elfcpp::R_PPC64_DTPREL16_DS:
    case elfcpp::R_PPC64_DTPREL16_LO_DS:
    case elfcpp::R_PPC64_DTPREL16_HIGHER:
    case elfcpp::R_PPC64_DTPREL16_HIGHERA:
    case elfcpp::R_PPC64_DTPREL16_HIGHEST:
    case elfcpp::R_PPC64_DTPREL16_HIGHESTA:
      if (size != 64)
	// R_PPC_EMB_NADDR32, R_PPC_EMB_NADDR16, R_PPC_EMB_NADDR16_LO
	// R_PPC_EMB_NADDR16_HI, R_PPC_EMB_NADDR16_HA, R_PPC_EMB_SDAI16
	break;
    case elfcpp::R_POWERPC_DTPREL16:
    case elfcpp::R_POWERPC_DTPREL16_LO:
    case elfcpp::R_POWERPC_DTPREL16_HI:
    case elfcpp::R_POWERPC_DTPREL16_HA:
    case elfcpp::R_POWERPC_DTPREL:
      // tls symbol values are relative to tls_segment()->vaddr()
      value -= dtp_offset;
      break;

    default:
      break;
    }

  Insn branch_bit = 0;
  switch (r_type)
    {
    case elfcpp::R_POWERPC_ADDR14_BRTAKEN:
    case elfcpp::R_POWERPC_REL14_BRTAKEN:
      branch_bit = 1 << 21;
    case elfcpp::R_POWERPC_ADDR14_BRNTAKEN:
    case elfcpp::R_POWERPC_REL14_BRNTAKEN:
      {
	Insn* iview = reinterpret_cast<Insn*>(view);
	Insn insn = elfcpp::Swap<32, big_endian>::readval(iview);
	insn &= ~(1 << 21);
	insn |= branch_bit;
	if (this->is_isa_v2)
	  {
	    // Set 'a' bit.  This is 0b00010 in BO field for branch
	    // on CR(BI) insns (BO == 001at or 011at), and 0b01000
	    // for branch on CTR insns (BO == 1a00t or 1a01t).
	    if ((insn & (0x14 << 21)) == (0x04 << 21))
	      insn |= 0x02 << 21;
	    else if ((insn & (0x14 << 21)) == (0x10 << 21))
	      insn |= 0x08 << 21;
	    else
	      break;
	  }
	else
	  {
	    // Invert 'y' bit if not the default.
	    if (static_cast<Signed_address>(value) < 0)
	      insn ^= 1 << 21;
	  }
	elfcpp::Swap<32, big_endian>::writeval(iview, insn);
      }
      break;

    default:
      break;
    }

  if (size == 64)
    {
      // Multi-instruction sequences that access the TOC can be
      // optimized, eg. addis ra,r2,0; addi rb,ra,x;
      // to             nop;           addi rb,r2,x;
      switch (r_type)
	{
	default:
	  break;

	case elfcpp::R_POWERPC_GOT_TLSLD16_HA:
	case elfcpp::R_POWERPC_GOT_TLSGD16_HA:
	case elfcpp::R_POWERPC_GOT_TPREL16_HA:
	case elfcpp::R_POWERPC_GOT_DTPREL16_HA:
	case elfcpp::R_POWERPC_GOT16_HA:
	case elfcpp::R_PPC64_TOC16_HA:
	  if (parameters->options().toc_optimize())
	    {
	      Insn* iview = reinterpret_cast<Insn*>(view - 2 * big_endian);
	      Insn insn = elfcpp::Swap<32, big_endian>::readval(iview);
	      if ((insn & ((0x3f << 26) | 0x1f << 16))
		  != ((15u << 26) | (2 << 16)) /* addis rt,2,imm */)
		gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
				       _("toc optimization is not supported "
					 "for %#08x instruction"), insn);
	      else if (value + 0x8000 < 0x10000)
		{
		  elfcpp::Swap<32, big_endian>::writeval(iview, nop);
		  return true;
		}
	    }
	  break;

	case elfcpp::R_POWERPC_GOT_TLSLD16_LO:
	case elfcpp::R_POWERPC_GOT_TLSGD16_LO:
	case elfcpp::R_POWERPC_GOT_TPREL16_LO:
	case elfcpp::R_POWERPC_GOT_DTPREL16_LO:
	case elfcpp::R_POWERPC_GOT16_LO:
	case elfcpp::R_PPC64_GOT16_LO_DS:
	case elfcpp::R_PPC64_TOC16_LO:
	case elfcpp::R_PPC64_TOC16_LO_DS:
	  if (parameters->options().toc_optimize())
	    {
	      Insn* iview = reinterpret_cast<Insn*>(view - 2 * big_endian);
	      Insn insn = elfcpp::Swap<32, big_endian>::readval(iview);
	      if (!ok_lo_toc_insn(insn))
		gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
				       _("toc optimization is not supported "
					 "for %#08x instruction"), insn);
	      else if (value + 0x8000 < 0x10000)
		{
		  if ((insn & (0x3f << 26)) == 12u << 26 /* addic */)
		    {
		      // Transform addic to addi when we change reg.
		      insn &= ~((0x3f << 26) | (0x1f << 16));
		      insn |= (14u << 26) | (2 << 16);
		    }
		  else
		    {
		      insn &= ~(0x1f << 16);
		      insn |= 2 << 16;
		    }
		  elfcpp::Swap<32, big_endian>::writeval(iview, insn);
		}
	    }
	  break;
	}
    }

  typename Reloc::Overflow_check overflow = Reloc::CHECK_NONE;
  switch (r_type)
    {
    case elfcpp::R_POWERPC_ADDR32:
    case elfcpp::R_POWERPC_UADDR32:
      if (size == 64)
	overflow = Reloc::CHECK_BITFIELD;
      break;

    case elfcpp::R_POWERPC_REL32:
      if (size == 64)
	overflow = Reloc::CHECK_SIGNED;
      break;

    case elfcpp::R_POWERPC_ADDR24:
    case elfcpp::R_POWERPC_ADDR16:
    case elfcpp::R_POWERPC_UADDR16:
    case elfcpp::R_PPC64_ADDR16_DS:
    case elfcpp::R_POWERPC_ADDR14:
    case elfcpp::R_POWERPC_ADDR14_BRTAKEN:
    case elfcpp::R_POWERPC_ADDR14_BRNTAKEN:
      overflow = Reloc::CHECK_BITFIELD;
      break;

    case elfcpp::R_POWERPC_REL24:
    case elfcpp::R_PPC_PLTREL24:
    case elfcpp::R_PPC_LOCAL24PC:
    case elfcpp::R_POWERPC_REL16:
    case elfcpp::R_PPC64_TOC16:
    case elfcpp::R_POWERPC_GOT16:
    case elfcpp::R_POWERPC_SECTOFF:
    case elfcpp::R_POWERPC_TPREL16:
    case elfcpp::R_POWERPC_DTPREL16:
    case elfcpp::R_PPC64_TPREL16_DS:
    case elfcpp::R_PPC64_DTPREL16_DS:
    case elfcpp::R_PPC64_TOC16_DS:
    case elfcpp::R_PPC64_GOT16_DS:
    case elfcpp::R_PPC64_SECTOFF_DS:
    case elfcpp::R_POWERPC_REL14:
    case elfcpp::R_POWERPC_REL14_BRTAKEN:
    case elfcpp::R_POWERPC_REL14_BRNTAKEN:
    case elfcpp::R_POWERPC_GOT_TLSGD16:
    case elfcpp::R_POWERPC_GOT_TLSLD16:
    case elfcpp::R_POWERPC_GOT_TPREL16:
    case elfcpp::R_POWERPC_GOT_DTPREL16:
      overflow = Reloc::CHECK_SIGNED;
      break;
    }

  typename Powerpc_relocate_functions<size, big_endian>::Status status
    = Powerpc_relocate_functions<size, big_endian>::STATUS_OK;
  switch (r_type)
    {
    case elfcpp::R_POWERPC_NONE:
    case elfcpp::R_POWERPC_TLS:
    case elfcpp::R_POWERPC_GNU_VTINHERIT:
    case elfcpp::R_POWERPC_GNU_VTENTRY:
    case elfcpp::R_PPC_EMB_MRKREF:
      break;

    case elfcpp::R_PPC64_ADDR64:
    case elfcpp::R_PPC64_REL64:
    case elfcpp::R_PPC64_TOC:
      Reloc::addr64(view, value);
      break;

    case elfcpp::R_POWERPC_TPREL:
    case elfcpp::R_POWERPC_DTPREL:
      if (size == 64)
	Reloc::addr64(view, value);
      else
	status = Reloc::addr32(view, value, overflow);
      break;

    case elfcpp::R_PPC64_UADDR64:
      Reloc::addr64_u(view, value);
      break;

    case elfcpp::R_POWERPC_ADDR32:
      status = Reloc::addr32(view, value, overflow);
      break;

    case elfcpp::R_POWERPC_REL32:
    case elfcpp::R_POWERPC_UADDR32:
      status = Reloc::addr32_u(view, value, overflow);
      break;

    case elfcpp::R_POWERPC_ADDR24:
    case elfcpp::R_POWERPC_REL24:
    case elfcpp::R_PPC_PLTREL24:
    case elfcpp::R_PPC_LOCAL24PC:
      status = Reloc::addr24(view, value, overflow);
      break;

    case elfcpp::R_POWERPC_GOT_DTPREL16:
    case elfcpp::R_POWERPC_GOT_DTPREL16_LO:
      if (size == 64)
	{
	  status = Reloc::addr16_ds(view, value, overflow);
	  break;
	}
    case elfcpp::R_POWERPC_ADDR16:
    case elfcpp::R_POWERPC_REL16:
    case elfcpp::R_PPC64_TOC16:
    case elfcpp::R_POWERPC_GOT16:
    case elfcpp::R_POWERPC_SECTOFF:
    case elfcpp::R_POWERPC_TPREL16:
    case elfcpp::R_POWERPC_DTPREL16:
    case elfcpp::R_POWERPC_GOT_TLSGD16:
    case elfcpp::R_POWERPC_GOT_TLSLD16:
    case elfcpp::R_POWERPC_GOT_TPREL16:
    case elfcpp::R_POWERPC_ADDR16_LO:
    case elfcpp::R_POWERPC_REL16_LO:
    case elfcpp::R_PPC64_TOC16_LO:
    case elfcpp::R_POWERPC_GOT16_LO:
    case elfcpp::R_POWERPC_SECTOFF_LO:
    case elfcpp::R_POWERPC_TPREL16_LO:
    case elfcpp::R_POWERPC_DTPREL16_LO:
    case elfcpp::R_POWERPC_GOT_TLSGD16_LO:
    case elfcpp::R_POWERPC_GOT_TLSLD16_LO:
    case elfcpp::R_POWERPC_GOT_TPREL16_LO:
      status = Reloc::addr16(view, value, overflow);
      break;

    case elfcpp::R_POWERPC_UADDR16:
      status = Reloc::addr16_u(view, value, overflow);
      break;

    case elfcpp::R_POWERPC_ADDR16_HI:
    case elfcpp::R_POWERPC_REL16_HI:
    case elfcpp::R_PPC64_TOC16_HI:
    case elfcpp::R_POWERPC_GOT16_HI:
    case elfcpp::R_POWERPC_SECTOFF_HI:
    case elfcpp::R_POWERPC_TPREL16_HI:
    case elfcpp::R_POWERPC_DTPREL16_HI:
    case elfcpp::R_POWERPC_GOT_TLSGD16_HI:
    case elfcpp::R_POWERPC_GOT_TLSLD16_HI:
    case elfcpp::R_POWERPC_GOT_TPREL16_HI:
    case elfcpp::R_POWERPC_GOT_DTPREL16_HI:
      Reloc::addr16_hi(view, value);
      break;

    case elfcpp::R_POWERPC_ADDR16_HA:
    case elfcpp::R_POWERPC_REL16_HA:
    case elfcpp::R_PPC64_TOC16_HA:
    case elfcpp::R_POWERPC_GOT16_HA:
    case elfcpp::R_POWERPC_SECTOFF_HA:
    case elfcpp::R_POWERPC_TPREL16_HA:
    case elfcpp::R_POWERPC_DTPREL16_HA:
    case elfcpp::R_POWERPC_GOT_TLSGD16_HA:
    case elfcpp::R_POWERPC_GOT_TLSLD16_HA:
    case elfcpp::R_POWERPC_GOT_TPREL16_HA:
    case elfcpp::R_POWERPC_GOT_DTPREL16_HA:
      Reloc::addr16_ha(view, value);
      break;

    case elfcpp::R_PPC64_DTPREL16_HIGHER:
      if (size == 32)
	// R_PPC_EMB_NADDR16_LO
	goto unsupp;
    case elfcpp::R_PPC64_ADDR16_HIGHER:
    case elfcpp::R_PPC64_TPREL16_HIGHER:
      Reloc::addr16_hi2(view, value);
      break;

    case elfcpp::R_PPC64_DTPREL16_HIGHERA:
      if (size == 32)
	// R_PPC_EMB_NADDR16_HI
	goto unsupp;
    case elfcpp::R_PPC64_ADDR16_HIGHERA:
    case elfcpp::R_PPC64_TPREL16_HIGHERA:
      Reloc::addr16_ha2(view, value);
      break;

    case elfcpp::R_PPC64_DTPREL16_HIGHEST:
      if (size == 32)
	// R_PPC_EMB_NADDR16_HA
	goto unsupp;
    case elfcpp::R_PPC64_ADDR16_HIGHEST:
    case elfcpp::R_PPC64_TPREL16_HIGHEST:
      Reloc::addr16_hi3(view, value);
      break;

    case elfcpp::R_PPC64_DTPREL16_HIGHESTA:
      if (size == 32)
	// R_PPC_EMB_SDAI16
	goto unsupp;
    case elfcpp::R_PPC64_ADDR16_HIGHESTA:
    case elfcpp::R_PPC64_TPREL16_HIGHESTA:
      Reloc::addr16_ha3(view, value);
      break;

    case elfcpp::R_PPC64_DTPREL16_DS:
    case elfcpp::R_PPC64_DTPREL16_LO_DS:
      if (size == 32)
	// R_PPC_EMB_NADDR32, R_PPC_EMB_NADDR16
	goto unsupp;
    case elfcpp::R_PPC64_TPREL16_DS:
    case elfcpp::R_PPC64_TPREL16_LO_DS:
      if (size == 32)
	// R_PPC_TLSGD, R_PPC_TLSLD
	break;
    case elfcpp::R_PPC64_ADDR16_DS:
    case elfcpp::R_PPC64_ADDR16_LO_DS:
    case elfcpp::R_PPC64_TOC16_DS:
    case elfcpp::R_PPC64_TOC16_LO_DS:
    case elfcpp::R_PPC64_GOT16_DS:
    case elfcpp::R_PPC64_GOT16_LO_DS:
    case elfcpp::R_PPC64_SECTOFF_DS:
    case elfcpp::R_PPC64_SECTOFF_LO_DS:
      status = Reloc::addr16_ds(view, value, overflow);
      break;

    case elfcpp::R_POWERPC_ADDR14:
    case elfcpp::R_POWERPC_ADDR14_BRTAKEN:
    case elfcpp::R_POWERPC_ADDR14_BRNTAKEN:
    case elfcpp::R_POWERPC_REL14:
    case elfcpp::R_POWERPC_REL14_BRTAKEN:
    case elfcpp::R_POWERPC_REL14_BRNTAKEN:
      status = Reloc::addr14(view, value, overflow);
      break;

    case elfcpp::R_POWERPC_COPY:
    case elfcpp::R_POWERPC_GLOB_DAT:
    case elfcpp::R_POWERPC_JMP_SLOT:
    case elfcpp::R_POWERPC_RELATIVE:
    case elfcpp::R_POWERPC_DTPMOD:
    case elfcpp::R_PPC64_JMP_IREL:
    case elfcpp::R_POWERPC_IRELATIVE:
      gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			     _("unexpected reloc %u in object file"),
			     r_type);
      break;

    case elfcpp::R_PPC_EMB_SDA21:
      if (size == 32)
	goto unsupp;
      else
	{
	  // R_PPC64_TOCSAVE.  For the time being this can be ignored.
	}
      break;

    case elfcpp::R_PPC_EMB_SDA2I16:
    case elfcpp::R_PPC_EMB_SDA2REL:
      if (size == 32)
	goto unsupp;
      // R_PPC64_TLSGD, R_PPC64_TLSLD
      break;

    case elfcpp::R_POWERPC_PLT32:
    case elfcpp::R_POWERPC_PLTREL32:
    case elfcpp::R_POWERPC_PLT16_LO:
    case elfcpp::R_POWERPC_PLT16_HI:
    case elfcpp::R_POWERPC_PLT16_HA:
    case elfcpp::R_PPC_SDAREL16:
    case elfcpp::R_POWERPC_ADDR30:
    case elfcpp::R_PPC64_PLT64:
    case elfcpp::R_PPC64_PLTREL64:
    case elfcpp::R_PPC64_PLTGOT16:
    case elfcpp::R_PPC64_PLTGOT16_LO:
    case elfcpp::R_PPC64_PLTGOT16_HI:
    case elfcpp::R_PPC64_PLTGOT16_HA:
    case elfcpp::R_PPC64_PLT16_LO_DS:
    case elfcpp::R_PPC64_PLTGOT16_DS:
    case elfcpp::R_PPC64_PLTGOT16_LO_DS:
    case elfcpp::R_PPC_EMB_RELSEC16:
    case elfcpp::R_PPC_EMB_RELST_LO:
    case elfcpp::R_PPC_EMB_RELST_HI:
    case elfcpp::R_PPC_EMB_RELST_HA:
    case elfcpp::R_PPC_EMB_BIT_FLD:
    case elfcpp::R_PPC_EMB_RELSDA:
    case elfcpp::R_PPC_TOC16:
    default:
    unsupp:
      gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			     _("unsupported reloc %u"),
			     r_type);
      break;
    }
  if (status != Powerpc_relocate_functions<size, big_endian>::STATUS_OK)
    gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			   _("relocation overflow"));

  return true;
}

// Relocate section data.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::relocate_section(
    const Relocate_info<size, big_endian>* relinfo,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    unsigned char* view,
    Address address,
    section_size_type view_size,
    const Reloc_symbol_changes* reloc_symbol_changes)
{
  typedef Target_powerpc<size, big_endian> Powerpc;
  typedef typename Target_powerpc<size, big_endian>::Relocate Powerpc_relocate;
  typedef typename Target_powerpc<size, big_endian>::Relocate_comdat_behavior
    Powerpc_comdat_behavior;

  gold_assert(sh_type == elfcpp::SHT_RELA);

  gold::relocate_section<size, big_endian, Powerpc, elfcpp::SHT_RELA,
			 Powerpc_relocate, Powerpc_comdat_behavior>(
    relinfo,
    this,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    view,
    address,
    view_size,
    reloc_symbol_changes);
}

class Powerpc_scan_relocatable_reloc
{
public:
  // Return the strategy to use for a local symbol which is not a
  // section symbol, given the relocation type.
  inline Relocatable_relocs::Reloc_strategy
  local_non_section_strategy(unsigned int r_type, Relobj*, unsigned int r_sym)
  {
    if (r_type == 0 && r_sym == 0)
      return Relocatable_relocs::RELOC_DISCARD;
    return Relocatable_relocs::RELOC_COPY;
  }

  // Return the strategy to use for a local symbol which is a section
  // symbol, given the relocation type.
  inline Relocatable_relocs::Reloc_strategy
  local_section_strategy(unsigned int, Relobj*)
  {
    return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_RELA;
  }

  // Return the strategy to use for a global symbol, given the
  // relocation type, the object, and the symbol index.
  inline Relocatable_relocs::Reloc_strategy
  global_strategy(unsigned int r_type, Relobj*, unsigned int)
  {
    if (r_type == elfcpp::R_PPC_PLTREL24)
      return Relocatable_relocs::RELOC_SPECIAL;
    return Relocatable_relocs::RELOC_COPY;
  }
};

// Scan the relocs during a relocatable link.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::scan_relocatable_relocs(
    Symbol_table* symtab,
    Layout* layout,
    Sized_relobj_file<size, big_endian>* object,
    unsigned int data_shndx,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    bool needs_special_offset_handling,
    size_t local_symbol_count,
    const unsigned char* plocal_symbols,
    Relocatable_relocs* rr)
{
  gold_assert(sh_type == elfcpp::SHT_RELA);

  gold::scan_relocatable_relocs<size, big_endian, elfcpp::SHT_RELA,
				Powerpc_scan_relocatable_reloc>(
    symtab,
    layout,
    object,
    data_shndx,
    prelocs,
    reloc_count,
    output_section,
    needs_special_offset_handling,
    local_symbol_count,
    plocal_symbols,
    rr);
}

// Emit relocations for a section.
// This is a modified version of the function by the same name in
// target-reloc.h.  Using relocate_special_relocatable for
// R_PPC_PLTREL24 would require duplication of the entire body of the
// loop, so we may as well duplicate the whole thing.

template<int size, bool big_endian>
void
Target_powerpc<size, big_endian>::relocate_relocs(
    const Relocate_info<size, big_endian>* relinfo,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    typename elfcpp::Elf_types<size>::Elf_Off offset_in_output_section,
    const Relocatable_relocs* rr,
    unsigned char*,
    Address view_address,
    section_size_type,
    unsigned char* reloc_view,
    section_size_type reloc_view_size)
{
  gold_assert(sh_type == elfcpp::SHT_RELA);

  typedef typename Reloc_types<elfcpp::SHT_RELA, size, big_endian>::Reloc
    Reltype;
  typedef typename Reloc_types<elfcpp::SHT_RELA, size, big_endian>::Reloc_write
    Reltype_write;
  const int reloc_size
    = Reloc_types<elfcpp::SHT_RELA, size, big_endian>::reloc_size;

  Powerpc_relobj<size, big_endian>* const object
    = static_cast<Powerpc_relobj<size, big_endian>*>(relinfo->object);
  const unsigned int local_count = object->local_symbol_count();
  unsigned int got2_shndx = object->got2_shndx();
  Address got2_addend = 0;
  if (got2_shndx != 0)
    {
      got2_addend = object->get_output_section_offset(got2_shndx);
      gold_assert(got2_addend != invalid_address);
    }

  unsigned char* pwrite = reloc_view;
  bool zap_next = false;
  for (size_t i = 0; i < reloc_count; ++i, prelocs += reloc_size)
    {
      Relocatable_relocs::Reloc_strategy strategy = rr->strategy(i);
      if (strategy == Relocatable_relocs::RELOC_DISCARD)
	continue;

      Reltype reloc(prelocs);
      Reltype_write reloc_write(pwrite);

      Address offset = reloc.get_r_offset();
      typename elfcpp::Elf_types<size>::Elf_WXword r_info = reloc.get_r_info();
      unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);
      unsigned int r_type = elfcpp::elf_r_type<size>(r_info);
      const unsigned int orig_r_sym = r_sym;
      typename elfcpp::Elf_types<size>::Elf_Swxword addend
	= reloc.get_r_addend();
      const Symbol* gsym = NULL;

      if (zap_next)
	{
	  // We could arrange to discard these and other relocs for
	  // tls optimised sequences in the strategy methods, but for
	  // now do as BFD ld does.
	  r_type = elfcpp::R_POWERPC_NONE;
	  zap_next = false;
	}

      // Get the new symbol index.
      if (r_sym < local_count)
	{
	  switch (strategy)
	    {
	    case Relocatable_relocs::RELOC_COPY:
	    case Relocatable_relocs::RELOC_SPECIAL:
	      if (r_sym != 0)
		{
		  r_sym = object->symtab_index(r_sym);
		  gold_assert(r_sym != -1U);
		}
	      break;

	    case Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_RELA:
	      {
		// We are adjusting a section symbol.  We need to find
		// the symbol table index of the section symbol for
		// the output section corresponding to input section
		// in which this symbol is defined.
		gold_assert(r_sym < local_count);
		bool is_ordinary;
		unsigned int shndx =
		  object->local_symbol_input_shndx(r_sym, &is_ordinary);
		gold_assert(is_ordinary);
		Output_section* os = object->output_section(shndx);
		gold_assert(os != NULL);
		gold_assert(os->needs_symtab_index());
		r_sym = os->symtab_index();
	      }
	      break;

	    default:
	      gold_unreachable();
	    }
	}
      else
	{
	  gsym = object->global_symbol(r_sym);
	  gold_assert(gsym != NULL);
	  if (gsym->is_forwarder())
	    gsym = relinfo->symtab->resolve_forwards(gsym);

	  gold_assert(gsym->has_symtab_index());
	  r_sym = gsym->symtab_index();
	}

      // Get the new offset--the location in the output section where
      // this relocation should be applied.
      if (static_cast<Address>(offset_in_output_section) != invalid_address)
	offset += offset_in_output_section;
      else
	{
	  section_offset_type sot_offset =
	    convert_types<section_offset_type, Address>(offset);
	  section_offset_type new_sot_offset =
	    output_section->output_offset(object, relinfo->data_shndx,
					  sot_offset);
	  gold_assert(new_sot_offset != -1);
	  offset = new_sot_offset;
	}

      // In an object file, r_offset is an offset within the section.
      // In an executable or dynamic object, generated by
      // --emit-relocs, r_offset is an absolute address.
      if (!parameters->options().relocatable())
	{
	  offset += view_address;
	  if (static_cast<Address>(offset_in_output_section) != invalid_address)
	    offset -= offset_in_output_section;
	}

      // Handle the reloc addend based on the strategy.
      if (strategy == Relocatable_relocs::RELOC_COPY)
	;
      else if (strategy == Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_RELA)
	{
	  const Symbol_value<size>* psymval = object->local_symbol(orig_r_sym);
	  addend = psymval->value(object, addend);
	}
      else if (strategy == Relocatable_relocs::RELOC_SPECIAL)
	{
	  if (addend >= 32768)
	    addend += got2_addend;
	}
      else
	gold_unreachable();

      if (!parameters->options().relocatable())
	{
	  if (r_type == elfcpp::R_POWERPC_GOT_TLSGD16
	      || r_type == elfcpp::R_POWERPC_GOT_TLSGD16_LO
	      || r_type == elfcpp::R_POWERPC_GOT_TLSGD16_HI
	      || r_type == elfcpp::R_POWERPC_GOT_TLSGD16_HA)
	    {
	      // First instruction of a global dynamic sequence,
	      // arg setup insn.
	      const bool final = gsym == NULL || gsym->final_value_is_known();
	      switch (this->optimize_tls_gd(final))
		{
		case tls::TLSOPT_TO_IE:
		  r_type += (elfcpp::R_POWERPC_GOT_TPREL16
			     - elfcpp::R_POWERPC_GOT_TLSGD16);
		  break;
		case tls::TLSOPT_TO_LE:
		  if (r_type == elfcpp::R_POWERPC_GOT_TLSGD16
		      || r_type == elfcpp::R_POWERPC_GOT_TLSGD16_LO)
		    r_type = elfcpp::R_POWERPC_TPREL16_HA;
		  else
		    {
		      r_type = elfcpp::R_POWERPC_NONE;
		      offset -= 2 * big_endian;
		    }
		  break;
		default:
		  break;
		}
	    }
	  else if (r_type == elfcpp::R_POWERPC_GOT_TLSLD16
		   || r_type == elfcpp::R_POWERPC_GOT_TLSLD16_LO
		   || r_type == elfcpp::R_POWERPC_GOT_TLSLD16_HI
		   || r_type == elfcpp::R_POWERPC_GOT_TLSLD16_HA)
	    {
	      // First instruction of a local dynamic sequence,
	      // arg setup insn.
	      if (this->optimize_tls_ld() == tls::TLSOPT_TO_LE)
		{
		  if (r_type == elfcpp::R_POWERPC_GOT_TLSLD16
		      || r_type == elfcpp::R_POWERPC_GOT_TLSLD16_LO)
		    {
		      r_type = elfcpp::R_POWERPC_TPREL16_HA;
		      const Output_section* os = relinfo->layout->tls_segment()
			->first_section();
		      gold_assert(os != NULL);
		      gold_assert(os->needs_symtab_index());
		      r_sym = os->symtab_index();
		      addend = dtp_offset;
		    }
		  else
		    {
		      r_type = elfcpp::R_POWERPC_NONE;
		      offset -= 2 * big_endian;
		    }
		}
	    }
	  else if (r_type == elfcpp::R_POWERPC_GOT_TPREL16
		   || r_type == elfcpp::R_POWERPC_GOT_TPREL16_LO
		   || r_type == elfcpp::R_POWERPC_GOT_TPREL16_HI
		   || r_type == elfcpp::R_POWERPC_GOT_TPREL16_HA)
	    {
	      // First instruction of initial exec sequence.
	      const bool final = gsym == NULL || gsym->final_value_is_known();
	      if (this->optimize_tls_ie(final) == tls::TLSOPT_TO_LE)
		{
		  if (r_type == elfcpp::R_POWERPC_GOT_TPREL16
		      || r_type == elfcpp::R_POWERPC_GOT_TPREL16_LO)
		    r_type = elfcpp::R_POWERPC_TPREL16_HA;
		  else
		    {
		      r_type = elfcpp::R_POWERPC_NONE;
		      offset -= 2 * big_endian;
		    }
		}
	    }
	  else if ((size == 64 && r_type == elfcpp::R_PPC64_TLSGD)
		   || (size == 32 && r_type == elfcpp::R_PPC_TLSGD))
	    {
	      // Second instruction of a global dynamic sequence,
	      // the __tls_get_addr call
	      const bool final = gsym == NULL || gsym->final_value_is_known();
	      switch (this->optimize_tls_gd(final))
		{
		case tls::TLSOPT_TO_IE:
		  r_type = elfcpp::R_POWERPC_NONE;
		  zap_next = true;
		  break;
		case tls::TLSOPT_TO_LE:
		  r_type = elfcpp::R_POWERPC_TPREL16_LO;
		  offset += 2 * big_endian;
		  zap_next = true;
		  break;
		default:
		  break;
		}
	    }
	  else if ((size == 64 && r_type == elfcpp::R_PPC64_TLSLD)
		   || (size == 32 && r_type == elfcpp::R_PPC_TLSLD))
	    {
	      // Second instruction of a local dynamic sequence,
	      // the __tls_get_addr call
	      if (this->optimize_tls_ld() == tls::TLSOPT_TO_LE)
		{
		  const Output_section* os = relinfo->layout->tls_segment()
		    ->first_section();
		  gold_assert(os != NULL);
		  gold_assert(os->needs_symtab_index());
		  r_sym = os->symtab_index();
		  addend = dtp_offset;
		  r_type = elfcpp::R_POWERPC_TPREL16_LO;
		  offset += 2 * big_endian;
		  zap_next = true;
		}
	    }
	  else if (r_type == elfcpp::R_POWERPC_TLS)
	    {
	      // Second instruction of an initial exec sequence
	      const bool final = gsym == NULL || gsym->final_value_is_known();
	      if (this->optimize_tls_ie(final) == tls::TLSOPT_TO_LE)
		{
		  r_type = elfcpp::R_POWERPC_TPREL16_LO;
		  offset += 2 * big_endian;
		}
	    }
	}

      reloc_write.put_r_offset(offset);
      reloc_write.put_r_info(elfcpp::elf_r_info<size>(r_sym, r_type));
      reloc_write.put_r_addend(addend);

      pwrite += reloc_size;
    }

  gold_assert(static_cast<section_size_type>(pwrite - reloc_view)
	      == reloc_view_size);
}

// Return the value to use for a dynamic symbol which requires special
// treatment.  This is how we support equality comparisons of function
// pointers across shared library boundaries, as described in the
// processor specific ABI supplement.

template<int size, bool big_endian>
uint64_t
Target_powerpc<size, big_endian>::do_dynsym_value(const Symbol* gsym) const
{
  if (size == 32)
    {
      gold_assert(gsym->is_from_dynobj() && gsym->has_plt_offset());
      for (typename Stub_tables::const_iterator p = this->stub_tables_.begin();
	   p != this->stub_tables_.end();
	   ++p)
	{
	  Address off = (*p)->find_plt_call_entry(gsym);
	  if (off != invalid_address)
	    return (*p)->stub_address() + off;
	}
    }
  gold_unreachable();
}

// Return the PLT address to use for a local symbol.
template<int size, bool big_endian>
uint64_t
Target_powerpc<size, big_endian>::do_plt_address_for_local(
    const Relobj* object,
    unsigned int symndx) const
{
  if (size == 32)
    {
      const Sized_relobj<size, big_endian>* relobj
	= static_cast<const Sized_relobj<size, big_endian>*>(object);
      for (typename Stub_tables::const_iterator p = this->stub_tables_.begin();
	   p != this->stub_tables_.end();
	   ++p)
	{
	  Address off = (*p)->find_plt_call_entry(relobj->sized_relobj(),
						  symndx);
	  if (off != invalid_address)
	    return (*p)->stub_address() + off;
	}
    }
  gold_unreachable();
}

// Return the PLT address to use for a global symbol.
template<int size, bool big_endian>
uint64_t
Target_powerpc<size, big_endian>::do_plt_address_for_global(
    const Symbol* gsym) const
{
  if (size == 32)
    {
      for (typename Stub_tables::const_iterator p = this->stub_tables_.begin();
	   p != this->stub_tables_.end();
	   ++p)
	{
	  Address off = (*p)->find_plt_call_entry(gsym);
	  if (off != invalid_address)
	    return (*p)->stub_address() + off;
	}
    }
  gold_unreachable();
}

// Return the offset to use for the GOT_INDX'th got entry which is
// for a local tls symbol specified by OBJECT, SYMNDX.
template<int size, bool big_endian>
int64_t
Target_powerpc<size, big_endian>::do_tls_offset_for_local(
    const Relobj* object,
    unsigned int symndx,
    unsigned int got_indx) const
{
  const Powerpc_relobj<size, big_endian>* ppc_object
    = static_cast<const Powerpc_relobj<size, big_endian>*>(object);
  if (ppc_object->local_symbol(symndx)->is_tls_symbol())
    {
      for (Got_type got_type = GOT_TYPE_TLSGD;
	   got_type <= GOT_TYPE_TPREL;
	   got_type = Got_type(got_type + 1))
	if (ppc_object->local_has_got_offset(symndx, got_type))
	  {
	    unsigned int off = ppc_object->local_got_offset(symndx, got_type);
	    if (got_type == GOT_TYPE_TLSGD)
	      off += size / 8;
	    if (off == got_indx * (size / 8))
	      {
		if (got_type == GOT_TYPE_TPREL)
		  return -tp_offset;
		else
		  return -dtp_offset;
	      }
	  }
    }
  gold_unreachable();
}

// Return the offset to use for the GOT_INDX'th got entry which is
// for global tls symbol GSYM.
template<int size, bool big_endian>
int64_t
Target_powerpc<size, big_endian>::do_tls_offset_for_global(
    Symbol* gsym,
    unsigned int got_indx) const
{
  if (gsym->type() == elfcpp::STT_TLS)
    {
      for (Got_type got_type = GOT_TYPE_TLSGD;
	   got_type <= GOT_TYPE_TPREL;
	   got_type = Got_type(got_type + 1))
	if (gsym->has_got_offset(got_type))
	  {
	    unsigned int off = gsym->got_offset(got_type);
	    if (got_type == GOT_TYPE_TLSGD)
	      off += size / 8;
	    if (off == got_indx * (size / 8))
	      {
		if (got_type == GOT_TYPE_TPREL)
		  return -tp_offset;
		else
		  return -dtp_offset;
	      }
	  }
    }
  gold_unreachable();
}

// The selector for powerpc object files.

template<int size, bool big_endian>
class Target_selector_powerpc : public Target_selector
{
public:
  Target_selector_powerpc()
    : Target_selector(size == 64 ? elfcpp::EM_PPC64 : elfcpp::EM_PPC,
		      size, big_endian,
		      (size == 64
		       ? (big_endian ? "elf64-powerpc" : "elf64-powerpcle")
		       : (big_endian ? "elf32-powerpc" : "elf32-powerpcle")),
		      (size == 64
		       ? (big_endian ? "elf64ppc" : "elf64lppc")
		       : (big_endian ? "elf32ppc" : "elf32lppc")))
  { }

  virtual Target*
  do_instantiate_target()
  { return new Target_powerpc<size, big_endian>(); }
};

Target_selector_powerpc<32, true> target_selector_ppc32;
Target_selector_powerpc<32, false> target_selector_ppc32le;
Target_selector_powerpc<64, true> target_selector_ppc64;
Target_selector_powerpc<64, false> target_selector_ppc64le;

// Instantiate these constants for -O0
template<int size, bool big_endian>
const int Output_data_glink<size, big_endian>::pltresolve_size;
template<int size, bool big_endian>
const typename Stub_table<size, big_endian>::Address
  Stub_table<size, big_endian>::invalid_address;
template<int size, bool big_endian>
const typename Target_powerpc<size, big_endian>::Address
  Target_powerpc<size, big_endian>::invalid_address;

} // End anonymous namespace.
@


1.99
log
@gold/
	* powerpc.cc (Output_data_got_powerpc): Remove unused methods
	add_got_entry and add_got_entry_pair.
@
text
@d1990 77
d2071 1
a2071 3
    unsigned int got_offset = this->add_constant(c1);
    this->add_constant(c2);
    return got_offset;
@


1.98
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@a1989 19
  class Got_entry;

  // Create a new GOT entry and return its offset.
  unsigned int
  add_got_entry(Got_entry got_entry)
  {
    this->reserve_ent();
    return Output_data_got<size, big_endian>::add_got_entry(got_entry);
  }

  // Create a pair of new GOT entries and return the offset of the first.
  unsigned int
  add_got_entry_pair(Got_entry got_entry_1, Got_entry got_entry_2)
  {
    this->reserve_ent(2);
    return Output_data_got<size, big_endian>::add_got_entry_pair(got_entry_1,
								 got_entry_2);
  }

@


1.97
log
@gold/
	* object.cc (Sized_relobj::do_output_section_address): New function.
	(Sized_relobj): Instantiate explicitly.
	* object.h (Object::output_section_address): New function.
	(Object::do_output_section_address): New function.
	(Sized_relobj::do_output_section_address): New function.
	* powerpc.cc (Target_powerpc::symval_for_branch): Use it.
@
text
@d446 1
a446 1
      dynbss_(NULL), tlsld_got_offset_(-1U),
a1183 2
  // Space for variables copied with a COPY reloc.
  Output_data_space* dynbss_;
d2511 1
a2511 1
	      "GOMP_parallel_sections_start", 
@


1.97.2.1
log
@gold/
	* i386.cc (Target_i386): Remove unused member dynbss_.
	* arm.cc (Target_arm): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* tilegx.cc (Target_tilegx): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* dwarf_reader.h (Dwarf_info_reader): Remove unused members
	type_signature_, type_offset_.
	* plugin.h (Plugin_hook): Remove unused member layout_.
	* readsyms.h (Add_symbols): Remove unused members dirpath_, dirindex_,
	mapfile_.
	(Read_member): Remove unused members input_objects_, symtab_,
	mapfile_, layout_.
	(Check_library): Remove unused member symtab_.
	* archive.h (Lib_group): Remove unused member lib_.
	* archive.cc (Lib_group::Lib_group): Update initializer.
	* incremental.h	(Incremental_binary): Remove unused member target_.
	(Incremental_script_entry): Removed unused member script_.
	* layout.h (Write_symbols_task): Remove unused member input_objects_.
	* icf.h (Icf): Remove unused member num_tracked_relocs.
@
text
@d446 1
a446 1
      tlsld_got_offset_(-1U),
d1184 2
d2513 1
a2513 1
	      "GOMP_parallel_sections_start",
@


1.97.2.2
log
@gold/
	* powerpc.cc (Output_data_got_powerpc): Remove unused methods
	add_got_entry and add_got_entry_pair.
@
text
@d1990 19
@


1.97.2.3
log
@	* output.h (Output_data_got::add_constant): Tidy.
	(Output_data_got::add_constant_pair): New function.
	* powerpc.cc (Output_data_got_powerpc): Override all Output_data_got
	methods used so as to first call reserve_ent().
@
text
@a1989 77
  // Override all the Output_data_got methods we use so as to first call
  // reserve_ent().
  bool
  add_global(Symbol* gsym, unsigned int got_type)
  {
    this->reserve_ent();
    return Output_data_got<size, big_endian>::add_global(gsym, got_type);
  }

  bool
  add_global_plt(Symbol* gsym, unsigned int got_type)
  {
    this->reserve_ent();
    return Output_data_got<size, big_endian>::add_global_plt(gsym, got_type);
  }

  bool
  add_global_tls(Symbol* gsym, unsigned int got_type)
  { return this->add_global_plt(gsym, got_type); }

  void
  add_global_with_rel(Symbol* gsym, unsigned int got_type,
		      Output_data_reloc_generic* rel_dyn, unsigned int r_type)
  {
    this->reserve_ent();
    Output_data_got<size, big_endian>::
      add_global_with_rel(gsym, got_type, rel_dyn, r_type);
  }

  void
  add_global_pair_with_rel(Symbol* gsym, unsigned int got_type,
			   Output_data_reloc_generic* rel_dyn,
			   unsigned int r_type_1, unsigned int r_type_2)
  {
    this->reserve_ent(2);
    Output_data_got<size, big_endian>::
      add_global_pair_with_rel(gsym, got_type, rel_dyn, r_type_1, r_type_2);
  }

  bool
  add_local(Relobj* object, unsigned int sym_index, unsigned int got_type)
  {
    this->reserve_ent();
    return Output_data_got<size, big_endian>::add_local(object, sym_index,
							got_type);
  }

  bool
  add_local_plt(Relobj* object, unsigned int sym_index, unsigned int got_type)
  {
    this->reserve_ent();
    return Output_data_got<size, big_endian>::add_local_plt(object, sym_index,
							    got_type);
  }

  bool
  add_local_tls(Relobj* object, unsigned int sym_index, unsigned int got_type)
  { return this->add_local_plt(object, sym_index, got_type); }

  void
  add_local_tls_pair(Relobj* object, unsigned int sym_index,
		     unsigned int got_type,
		     Output_data_reloc_generic* rel_dyn,
		     unsigned int r_type)
  {
    this->reserve_ent(2);
    Output_data_got<size, big_endian>::
      add_local_tls_pair(object, sym_index, got_type, rel_dyn, r_type);
  }

  unsigned int
  add_constant(Valtype constant)
  {
    this->reserve_ent();
    return Output_data_got<size, big_endian>::add_constant(constant);
  }

d1994 3
a1996 1
    return Output_data_got<size, big_endian>::add_constant_pair(c1, c2);
@


1.96
log
@    gold/
    	* parameters.cc (Parameters::entry): Return target-specific entry
    	symbol name.
    	* target.h (Target::entry_symbol_name): New function.
    	(Target_info::entry_symbol_name): New data member.

    	* arm.cc (Target_arm::arm_info): Add entry_symbol_name.
    	(Target_arm_nacl::arm_nacl_info): Likewise.
    	* i386.cc (Target_i386::i386_info): Likewise.
    	(Target_i386_nacl::i386_nacl_info): Likewise.
    	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
    	* sparc.cc (Target_sparc::sparc_info): Likewise.
    	* tilegx.cc (Target_tilegx::tilegx_info): Likewise.
    	* x86_64.cc: (Target_x86_64::x86_64_info) Likewise.
    	(Target_x86_64_nacl::x86_64_nacl_info) Likewise.
    	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
@
text
@d6206 1
a6206 1
  opd_addr += symobj->output_section(shndx)->address();
@


1.95
log
@gold/
	* powerpc.cc (Target_powerpc::write_branch_lookup_table): Use
	correct BRLT entry size.
@
text
@d1222 2
a1223 1
  NULL			// attributes_vendor
d1249 2
a1250 1
  NULL			// attributes_vendor
d1276 2
a1277 1
  NULL			// attributes_vendor
d1303 2
a1304 1
  NULL			// attributes_vendor
@


1.94
log
@bfd/
	* elf64-ppc.c (struct ppc_stub_hash_entry): Delete "addend".
	(ppc64_elf_size_stubs): Don't set "addend".
	(ppc64_elf_relocate_section): Don't allow calls via
	toc-adjusting stubs without a following nop even in an
	executable, except for self-calls and both libc_start_main
	and .libc_start_main.
gold/
	* powerpc.cc (Target_powerpc::Relocate::relocate): Update self-call
	comment.
@
text
@d738 1
a738 1
	elfcpp::Swap<32, big_endian>::writeval(oview + p->second, p->first);
@


1.93
log
@	PR gold/15662
	* powerpc.cc (Output_data_brlt_powerpc::reset_brlt_sizes): New
	function.
	(Output_data_brlt_powerpc::finalize_brlt_sizes): New function.
	(Target_powerpc::do_relax): Call the above.
@
text
@d6349 7
a6355 4
	      // This is not an error in one special case: A self
	      // call.  It isn't possible to cheaply verify we have
	      // such a call so just check for a call to the same
	      // section.
@


1.92
log
@	* powerpc.cc (Target_powerpc::symval_for_branch): Don't assert
	on garbage collected .opd section.

	* powerpc.cc (Target_powerpc::do_gc_add_reference): Test dst_shndx
	is non-zero.
	(Target_powerpc::do_gc_mark_symbols): Likewise for sym->shndx().
	(Target_powerpc::do_function_location): Likewise for loc->shndx.
@
text
@d2631 1
a2631 1
      this->brlt_section_->reset_data_size();
d2639 1
a2639 1
      this->brlt_section_->finalize_data_size();
d3016 14
@


1.91
log
@	* target-reloc.h (relocate_section): If the reloc offset is out of
	range, pass VIEW as NULL to relocate.relocate.
	* arm.cc (Target_arm:Relocate::relocate): Check for a NULL view.
	* i386.cc (Target_i386::Relocate::relocate): Likewise.
	* powerpc.cc (Target_powerpc::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Relocate::relocate): Likewise.
	* tilegx.cc (Target_tilegx::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Relocate::relocate): Likewise.
@
text
@d5830 1
a5830 1
  if (dst_shndx == ppc_object->opd_shndx())
d5862 1
a5862 1
      if (is_ordinary && shndx == ppc_object->opd_shndx())
d5885 1
a5885 1
  if (size == 64)
d6186 2
a6187 1
  gold_assert(opd_addr != invalid_address);
@


1.90
log
@	* powerpc.cc (Stub_control::can_add_to_stub_group): Don't set
	owner when sections are not adjacent and exceed group size.
	(Target_powerpc::group_sections): Handle corner case.
	(Target_powerpc::Branch_info::make_stub): Handle case where
	stub table doesn't exist due to branches in non-exec sections.
	(Target_powerpc::Relocate::relocate): Likewise.
@
text
@d3 1
a3 1
// Copyright 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
d6224 3
@


1.89
log
@	PR gold/15354
	* powerpc.cc (Target_powerpc::make_brlt_section): Name section
	.branch_lt to match bfd ld.  Adjust comments throughout file.
@
text
@d1088 1
a1088 1
  // Look over all the input sections, deciding where to place stub.
d2229 1
a2229 1
// Return true iff input section can be handled by current stub/
d2261 3
a2263 1
      && (!whole_sec || this->output_section_ != o))
d2336 19
a2354 1
    stub_table->init(stub_control.owner(), stub_control.output_section());
a2451 1
      gold_assert(stub_table != NULL);
d2455 5
a2459 3
	  to = stub_table->targ()->symval_for_branch(symtab, to, gsym,
						     this->object_,
						     &dest_shndx);
d2464 8
d6622 7
a6628 4
	  gold_assert(stub_table != NULL);
	  Address off = stub_table->find_long_branch_entry(object, value);
	  if (off != invalid_address)
	    value = stub_table->stub_address() + stub_table->plt_size() + off;
@


1.88
log
@	* powerpc.cc (Target_powerpc::Scan::reloc_needs_plt_for_ifunc): Make
	static and public.  Add report_err param.  Return false for data refs.
	(Target_powerpc::rela_dyn_section): New overloaded function.
	(Target_powerpc::plt_, iplt_): Elucidate.
	(Output_data_plt_powerpc::entry_count): Handle current_data_size()==0.
	(Output_data_plt_powerpc::do_write): Don't write .iplt.
	(Output_data_plt_powerpc::plt_entry_count): Don't add .iplt entries.
	(Target_powerpc::Scan::local, global): Adjust reloc_needs_plt_for_ifunc
	calls.  Put ifunc dynamic relocs in irela_dyn_section.  Only
	push_branch and make_plt_entry for ifunc syms when
	reloc_needs_plt_for_ifunc.
	(Target_powerpc::Relocate::relocate): Don't use plt entry value
	for ifunc unless reloc_needs_plt_for_ifunc.
@
text
@d2591 2
a2592 2
      // If .brlt is part of this output section, then we have just
      // done the offset adjustment.
d3047 2
a3048 2
	  // When PIC we can't fill in .brlt (like .plt it can be a
	  // bss style section) but must initialise at runtime via
d3060 1
a3060 1
	layout->add_output_section_data(".brlt",
d3071 1
a3071 1
// Write out .brlt when non-PIC.
@


1.87
log
@	* powerpc.cc (is_branch_reloc): Forward declare.
	(Target_powerpc::do_can_check_for_function_pointers): New predicate.
	(Target_powerpc::Scan::local_reloc_may_be_function_pointer): Return
	false for 64-bit, true for 32-bit non-branch relocs.
	(Target_powerpc::Scan::global_reloc_may_be_function_pointer): Likewise.
	* testsuite/Makefile.am (icf_test): Use linker map file instead of
	nm output.
	(icf_safe_test): Generate linker map file as well as nm output.
	(icf_safe_so_test): Likewise.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/icf_test.sh: Parse linker map file to determine
	section folding.
	* testsuite/icf_safe_test.sh: Likewise.  Expect folding for PowerPC.
	* testsuite/icf_safe_so_test.sh: Likewise.
	(X86_32_or_ARM_specific_safe_fold): Merge into..
	(arch_specific_safe_fold): ..this.
	(X86_64_specific_safe_fold): Delete unused function.
@
text
@d902 4
a921 4
    bool
    reloc_needs_plt_for_ifunc(Sized_relobj_file<size, big_endian>* object,
			      unsigned int r_type);

d1071 4
d1151 10
a1160 1
  // The PLT section.
d1162 13
a1174 1
  // The IPLT section.
d2150 16
d2704 2
d2884 1
a2884 1
  if (size == 32)
d2926 1
a2926 1
      // needs to include .rela.plt in it's range.
d4589 1
a4589 4
  unsigned int count = this->plt_->entry_count();
  if (this->iplt_ != NULL)
    count += this->iplt_->entry_count();
  return count;
d4833 2
a4834 1
     unsigned int r_type)
d4843 1
a4843 1
    // Word size refs from data sections are OK.
d4847 1
a4847 1
	return true;
d4853 1
a4853 1
	return true;
d4856 1
a4856 1
    // GOT refs are good.
d4863 1
a4863 1
      return true;
d4865 1
a4865 1
    // So are function calls.
d4890 2
a4891 1
  gold_error(_("%s: unsupported reloc %u for IFUNC symbol"),
d4945 1
a4945 1
  if (is_ifunc && this->reloc_needs_plt_for_ifunc(object, r_type))
d5011 2
a5012 2
	  Reloc_section* rela_dyn = target->rela_dyn_section(layout);

d5017 2
a5018 6
	      unsigned int dynrel = elfcpp::R_POWERPC_RELATIVE;
	      if (is_ifunc)
		{
		  rela_dyn = target->iplt_section()->rel_plt();
		  dynrel = elfcpp::R_POWERPC_IRELATIVE;
		}
a5037 5
      target->push_branch(ppc_object, data_shndx, reloc.get_r_offset(),
			  r_type, elfcpp::elf_r_sym<size>(reloc.get_r_info()),
			  reloc.get_r_addend());
      break;

d5041 4
a5044 3
      target->push_branch(ppc_object, data_shndx, reloc.get_r_offset(),
			  r_type, elfcpp::elf_r_sym<size>(reloc.get_r_info()),
			  reloc.get_r_addend());
d5110 4
a5113 7
	    Reloc_section* rela_dyn = target->rela_dyn_section(layout);
	    unsigned int dynrel = elfcpp::R_POWERPC_RELATIVE;
	    if (is_ifunc)
	      {
		rela_dyn = target->iplt_section()->rel_plt();
		dynrel = elfcpp::R_POWERPC_IRELATIVE;
	      }
d5294 2
a5295 2
  if (gsym->type() == elfcpp::STT_GNU_IFUNC
      && this->reloc_needs_plt_for_ifunc(object, r_type))
d5371 8
a5378 5
	    target->push_branch(ppc_object, data_shndx, reloc.get_r_offset(),
				r_type,
				elfcpp::elf_r_sym<size>(reloc.get_r_info()),
				reloc.get_r_addend());
	    target->make_plt_entry(symtab, layout, gsym);
d5390 1
a5390 1
	    || (size == 64 && gsym->type() == elfcpp::STT_GNU_IFUNC))
d5407 4
a5410 7
		Reloc_section* rela_dyn = target->rela_dyn_section(layout);
		unsigned int dynrel = elfcpp::R_POWERPC_RELATIVE;
		if (gsym->type() == elfcpp::STT_GNU_IFUNC)
		  {
		    rela_dyn = target->iplt_section()->rel_plt();
		    dynrel = elfcpp::R_POWERPC_IRELATIVE;
		  }
d5417 2
a5418 1
		Reloc_section* rela_dyn = target->rela_dyn_section(layout);
d5431 13
a5443 9
      target->push_branch(ppc_object, data_shndx, reloc.get_r_offset(),
			  r_type, elfcpp::elf_r_sym<size>(reloc.get_r_info()),
			  reloc.get_r_addend());
      if (gsym->needs_plt_entry()
	  || (!gsym->final_value_is_known()
	      && (gsym->is_undefined()
		  || gsym->is_from_dynobj()
		  || gsym->is_preemptible())))
	target->make_plt_entry(symtab, layout, gsym);
d5459 2
a5460 1
	      Reloc_section* rela_dyn = target->rela_dyn_section(layout);
d5472 4
a5475 3
      target->push_branch(ppc_object, data_shndx, reloc.get_r_offset(),
			  r_type, elfcpp::elf_r_sym<size>(reloc.get_r_info()),
			  reloc.get_r_addend());
d5525 1
a5525 1
	    if (size == 32 && gsym->type() == elfcpp::STT_GNU_IFUNC)
d5537 3
a5539 1
	    Reloc_section* rela_dyn = target->rela_dyn_section(layout);
d5545 2
a5546 6
		unsigned int dynrel = elfcpp::R_POWERPC_RELATIVE;
		if (gsym->type() == elfcpp::STT_GNU_IFUNC)
		  {
		    rela_dyn = target->iplt_section()->rel_plt();
		    dynrel = elfcpp::R_POWERPC_IRELATIVE;
		  }
d5579 2
a5580 2
	    got->add_global_pair_with_rel(gsym, GOT_TYPE_TLSGD,
					  target->rela_dyn_section(layout),
d6217 5
a6221 3
  if (gsym != NULL
      ? use_plt_offset<size>(gsym, Scan::get_reference_flags(r_type))
      : object->local_has_plt_offset(r_sym))
@


1.86
log
@	* gold.cc (queue_middle_tasks): Move detect_odr_violations..
	* layout.cc (Layout_task_runner::run): ..to here.
	* symtab.h (struct Symbol_location): Extract from..
	(class Symbol_table): ..here.
	* symtab.cc (Symbol_table::linenos_from_loc): Invoke function_location.
	* target.h (class Target): Add function_location and
	do_function_location functions.
	(class Sized_target): Add do_function_location.
	* object.h (class Sized_relobj_file): Move find_shdr..
	(class Object): ..to here.
	* object.cc: Likewise.  Update to suit.  Instantiate.
	(Sized_relobj_file::find_eh_frame): Update find_shdr call.
	* powerpc.cc (class Powerpc_dynobj): New.
	(Target_powerpc::do_function_location): New function.
	(Powerpc_relobj::do_find_special_sections): Update find_shdr call.
	(Powerpc_dynobj::do_read_symbols): New function.
	(Target_powerpc::do_make_elf_object): Make a Powerpc_dynobj.
@
text
@d65 3
d561 4
d873 1
a873 1
					unsigned int ,
d875 10
a884 1
    { return false; }
d892 9
a900 4
					 const elfcpp::Rela<size,
							    big_endian>& ,
					 unsigned int , Symbol*)
    { return false; }
@


1.85
log
@	* powerpc.cc (class Powerpc_relobj): Move some member functions.
	(Target_powerpc::symval_for_branch):  Add symtab param.  Update
	all callers.  Handle folded sections.
	(Target_powerpc::do_gc_add_reference): Don't cast dynamic object
	to Powerpc_relobj.
	(Global_symbol_visitor_opd::operator()): Likewise.
@
text
@d26 1
d324 103
d555 3
d1628 3
a1630 2
  s = this->find_shdr(pshdrs, size == 32 ? ".got2" : ".opd",
		      names, names_size, NULL);
d1745 99
d1916 2
a1917 2
      Sized_dynobj<size, big_endian>* obj =
	new Sized_dynobj<size, big_endian>(name, input_file, offset, ehdr);
d5791 36
@


1.84
log
@	* target.h (Target::plt_fde_location, do_plt_fde_location): Declare.
	* target.cc (Target::do_plt_fde_location): New function.
	* ehframe.h (class FDE): Add post_map field to u_.from_linker,
	accessor function, and constructor param.
	(struct Post_fde, Post_fdes): Declare.
	(Cie::write): Add post_fdes param.
	* ehframe.cc (Fde::write): Use plt_fde_location.
	(struct Post_fde): Define.
	(Cie::write): Stash FDEs added post merge mapping.
	(Eh_frame::add_ehframe_for_plt): Assert no new CIEs after mapping.
	Adjust Fde constructor call.  Bump final_data_size_ for post map FDEs.
	(Eh_frame::do_sized_write): Arrange to write post map FDES after
	other FDEs.
	* powerpc.cc (Target_powerpc::do_plt_fde_location): New function.
	(Target_powerpc::has_glink): New function.
	(Target_powerpc::do_relax): Add eh_frame info for stubs.
	(struct Eh_cie, eh_frame_cie, glink_eh_frame_fde_64,
	glink_eh_frame_fde_32, default_fde): New data.
	(Stub_table::eh_frame_added_): New var.
	(Stub_table::find_long_branch_entry, stub_address, stub_offset):
	Make const.
	(Stub_table::add_eh_frame): New function.
	(Output_data_glink::add_eh_frame): New function.
	(Target_powerpc::make_glink_section): Call add_eh_frame.
@
text
@a149 37
  Access_from*
  access_from_map()
  { return &this->access_from_map_; }

  // Add a reference from SRC_OBJ, SRC_INDX to this object's .opd
  // section at DST_OFF.
  void
  add_reference(Object* src_obj,
		unsigned int src_indx,
		typename elfcpp::Elf_types<size>::Elf_Addr dst_off)
  {
    Section_id src_id(src_obj, src_indx);
    this->access_from_map_[dst_off].insert(src_id);
  }

  // Add a reference to the code section specified by the .opd entry
  // at DST_OFF
  void
  add_gc_mark(typename elfcpp::Elf_types<size>::Elf_Addr dst_off)
  {
    size_t ndx = this->opd_ent_ndx(dst_off);
    if (ndx >= this->opd_ent_.size())
      this->opd_ent_.resize(ndx + 1);
    this->opd_ent_[ndx].gc_mark = true;
  }

  void
  process_gc_mark(Symbol_table* symtab)
  {
    for (size_t i = 0; i < this->opd_ent_.size(); i++)
      if (this->opd_ent_[i].gc_mark)
	{
	  unsigned int shndx = this->opd_ent_[i].shndx;
	  symtab->gc()->worklist().push(Section_id(this, shndx));
	}
  }

d188 37
d799 2
a800 1
  symval_for_branch(Address value, const Sized_symbol<size>* gsym,
d2167 2
a2168 1
	  to = stub_table->targ()->symval_for_branch(to, gsym, this->object_,
d5532 3
d5537 1
a5537 3
  if (size == 64
      && !ppc_object->is_dynamic()
      && dst_shndx == ppc_object->opd_shndx())
d5643 3
d5648 1
a5648 2
    if (symobj->is_dynamic()
	|| symobj->opd_shndx() == 0)
d5835 1
d5863 7
d6012 2
a6013 2
		  code = target->symval_for_branch(opdent, gsym, object,
						   &dest_shndx);
d6275 2
a6276 1
	value = target->symval_for_branch(value, gsym, object, &dest_shndx);
@


1.83
log
@	* powerpc.cc (Stub_table::plt_off): New function, extracted from..
	(Stub_table::do_write): ..here, two places.
	(Stub_table::plt_call_size): Use it here too.
@
text
@d28 1
d398 4
d534 3
d2288 1
d2344 48
d2834 54
d2911 1
a2911 1
      branch_size_(0), last_branch_size_(0)
d2956 2
a2957 1
  find_long_branch_entry(const Powerpc_relobj<size, big_endian>*, Address);
d2986 1
a2986 1
  stub_address()
d2993 1
a2993 1
  stub_offset()
d3034 29
d3262 2
d3407 1
a3407 1
    Address to)
d3427 31
d4263 1
@


1.82
log
@	* powerpc.cc (Stub_table::find_plt_call_entry): Make types
	used in declaration and definition consistent.
	(Target_powerpc::symval_for_branch): Ditto.
@
text
@d2943 20
d2970 4
a2973 5
    Address pltaddr = p->second;
    if (p->first.sym_ == NULL 
	|| (p->first.sym_->type() == elfcpp::STT_GNU_IFUNC
	    && p->first.sym_->can_use_relative_reloc(false)))
      pltaddr += this->targ_->iplt_section()->address();
d2975 2
a2976 2
      pltaddr += this->targ_->plt_section()->address();
    Address tocbase = this->targ_->got_section()->output_section()->address();
d2979 2
a2980 2
    tocbase += ppcobj->toc_base_offset();
    Address off = pltaddr - tocbase;
d3368 2
a3369 17
	      Address pltoff;
	      bool is_ifunc;
	      const Symbol* gsym = cs->first.sym_;
	      if (gsym != NULL)
		{
		  is_ifunc = (gsym->type() == elfcpp::STT_GNU_IFUNC
			      && gsym->can_use_relative_reloc(false));
		  pltoff = gsym->plt_offset();
		}
	      else
		{
		  is_ifunc = true;
		  const Sized_relobj_file<size, big_endian>* relobj
		    = cs->first.object_;
		  unsigned int local_sym_index = cs->first.locsym_;
		  pltoff = relobj->local_plt_offset(local_sym_index);
		}
d3371 1
a3371 1
	      if (is_ifunc)
d3438 1
a3438 1
		  write_insn<big_endian>(p, ld_11_2 + l(off)),	p += 4;
d3514 3
a3516 18
	      Address plt_addr;
	      bool is_ifunc;
	      const Symbol* gsym = cs->first.sym_;
	      if (gsym != NULL)
		{
		  is_ifunc = (gsym->type() == elfcpp::STT_GNU_IFUNC
			      && gsym->can_use_relative_reloc(false));
		  plt_addr = gsym->plt_offset();
		}
	      else
		{
		  is_ifunc = true;
		  const Sized_relobj_file<size, big_endian>* relobj
		    = cs->first.object_;
		  unsigned int local_sym_index = cs->first.locsym_;
		  plt_addr = relobj->local_plt_offset(local_sym_index);
		}
	      if (is_ifunc)
@


1.81
log
@bfd/
	* elf64-ppc.c (ppc64_elf_size_stubs): Default shared libs to
	plt-thread-safe.
gold/
	* powerpc.cc (Target_powerpc::do_relax): Default shared libs to
	plt-thread-safe.
ld/testsuite/
	* ld-powerpc/tlsso.d: Adjust for plt-thread-safe stubs.
	* ld-powerpc/tlsso.g: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlstocso.d: Likewise.
	* ld-powerpc/tlstocso.g: Likewise.
@
text
@d3174 1
a3174 1
typename elfcpp::Elf_types<size>::Elf_Addr
d3187 1
a3187 1
typename elfcpp::Elf_types<size>::Elf_Addr
d3196 1
a3196 1
typename elfcpp::Elf_types<size>::Elf_Addr
d3209 1
a3209 1
typename elfcpp::Elf_types<size>::Elf_Addr
d3242 1
a3242 1
typename elfcpp::Elf_types<size>::Elf_Addr
d5664 1
a5664 1
typename elfcpp::Elf_types<size>::Elf_Addr
@


1.80
log
@	* powerpc.cc (class Track_tls): New.
	(class Relocate, class Scan): Inherit Track_tls.
	(Target_powerpc::Scan::local, global): Track tls optimization
	and avoid creating plt entry for __tls_get_addr if all uses
	are optimized away.
	(Target_powerpc::Relocate::relocate): Update to use Track_tls.
@
text
@d2185 1
a2185 1
	  const char* const thread_starter[] =
d2204 3
a2206 3
	  for (unsigned int i = 0;
	       i < sizeof(thread_starter) / sizeof(thread_starter[0]);
	       i++)
d2208 11
a2218 4
	      Symbol* sym = symtab->lookup(thread_starter[i], NULL);
	      thread_safe = sym != NULL && sym->in_reg() && sym->in_real_elf();
	      if (thread_safe)
		break;
@


1.79
log
@	* options.h (General_options): Add --toc-sort/--no-toc-sort.
	Replace no_toc_optimize with toc_optimize.
	* output.h (Output_section::input_sections): Provide non-const variant.
	* powerpc.cc (Powerpc_relobj::has_small_toc_reloc_,
	set_has_small_toc_reloc, has_small_toc_reloc): New variable and
	accessors.
	(Target_powerpc::Scan::local, global): Call set_has_small_toc_reloc.
	(class Sort_toc_sections): New.
	(Target_powerpc::do_finalize_sections): Sort toc sections.
	(Target_powerpc::Relocate::relocate): Update toc_optimize test.
@
text
@d626 88
d715 1
a715 1
  class Scan
d721 1
a721 1
      : issued_non_pic_error_(false)
d796 1
a796 1
  class Relocate
a802 7
    enum skip_tls
    {
      CALL_NOT_EXPECTED = 0,
      CALL_EXPECTED = 1,
      CALL_SKIP = 2
    };

d804 1
a804 1
      : call_tls_get_addr_(CALL_NOT_EXPECTED)
a806 9
    ~Relocate()
    {
      if (this->call_tls_get_addr_ != CALL_NOT_EXPECTED)
	{
	  // FIXME: This needs to specify the location somehow.
	  gold_error(_("missing expected __tls_get_addr call"));
	}
    }

a817 4

    // This is set if we should skip the next reloc, which should be a
    // call to __tls_get_addr.
    enum skip_tls call_tls_get_addr_;
d4469 19
d4837 21
d5711 13
a5723 13
  bool is_tls_call = ((r_type == elfcpp::R_POWERPC_REL24
		       || r_type == elfcpp::R_PPC_PLTREL24)
		      && gsym != NULL
		      && strcmp(gsym->name(), "__tls_get_addr") == 0);
  enum skip_tls last_tls = this->call_tls_get_addr_;
  this->call_tls_get_addr_ = CALL_NOT_EXPECTED;
  if (is_tls_call)
    {
      if (last_tls == CALL_NOT_EXPECTED)
	gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			       _("__tls_get_addr call lacks marker reloc"));
      else if (last_tls == CALL_SKIP)
	return false;
a5724 3
  else if (last_tls != CALL_NOT_EXPECTED)
    gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
			   _("missing expected __tls_get_addr call"));
d6021 1
a6021 1
      this->call_tls_get_addr_ = CALL_EXPECTED;
d6044 1
a6044 1
	  this->call_tls_get_addr_ = CALL_SKIP;
d6052 1
a6052 1
      this->call_tls_get_addr_ = CALL_EXPECTED;
d6059 1
a6059 1
	  this->call_tls_get_addr_ = CALL_SKIP;
@


1.78
log
@	* powerpc.cc (Target_selector_powerpc::Target_selector_powerpc):
	Set EM_PPC64 or EM_PPC here.
	(Target_selector_powerpc::do_recognize): Delete.
@
text
@d74 1
a74 1
      special_(0), opd_valid_(false),
d231 8
d292 4
d4705 15
d5156 15
d5391 25
d5469 9
d6142 1
a6142 1
	  if (!parameters->options().no_toc_optimize())
d6167 1
a6167 1
	  if (!parameters->options().no_toc_optimize())
@


1.77
log
@	* powerpc.cc (Powerpc_relobj::Powerpc_relobj): Init has14_ and
	stub_table_.
	(Target_powerpc::Branch_info::make_stub): Don't omit addend.
@
text
@d6945 2
a6946 1
    : Target_selector(elfcpp::EM_NONE, size, big_endian,
a6955 22
  do_recognize(Input_file*, off_t, int machine, int, int)
  {
    switch (size)
      {
      case 64:
	if (machine != elfcpp::EM_PPC64)
	  return NULL;
	break;

      case 32:
	if (machine != elfcpp::EM_PPC)
	  return NULL;
	break;

      default:
	return NULL;
      }

    return this->instantiate_target();
  }

  virtual Target*
@


1.76
log
@	* powerpc.cc (Stub_table::do_write): Delete redundant Address
	typedef and invalid_address constant.
	(Output_data_glink, Stub_table, Target_powerpc): Explicitly
	instantiate constants.
@
text
@d74 2
a75 1
      special_(0), opd_valid_(false), opd_ent_(), access_from_map_()
d2071 1
@


1.75
log
@	* options.h (General_options): Add no_toc_optimize.
	* powerpc.cc (ok_lo_toc_insn): New function.
	(Target_powerpc::Relocate::relocate): Optimize toc access sequences.
@
text
@a3241 3
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  static const Address invalid_address = static_cast<Address>(0) - 1;

d6984 10
@


1.74
log
@	* options.h (General_options): Add plt_align, plt_static_chain,
	plt_thread_safe.  Update stub_group_size help text.
	* powerpc.cc (Target_powerpc::plt_thread_safe): New access function
	for new plt_thread_safe_ var.
	(use_plt_offset): Correct comments.
	(Target_powerpc::do_relax): Look for thread creation symbols to
	determine default plt_thread_safe value.  Clear plt call stubs
	as well as branch stubs each iteration.
	(add_2_2_11, add_12_12_11, bnectr_p4, cmpldi_2_0, xor_11_11_11): New
	insn constants.
	(l, hi, ha, write_insn): Move earlier.
	(Stub_table): Delete prev_size, add last_plt_size and last_branch_size.
	(Stub_table::clear_stubs): Rename from clear_long_branch_stubs, clear
	plt stubs too.
	(Stub_table::update_size): Adjust.
	(Stub_table::prev_size, set_prev_size): Delete.
	(Stub_table::stub_align): Let --plt-align affect result.
	(Stub_table::plt_call_size): Calculate sizes for various stubs.
	(Stub_table::branch_stub_size): Use last_plt_size in address calc.
	(Stub_table::add_plt_call_stub): Pass iterator to plt_call_size.
	(Stub_table::do_write): Support more stub variants.
@
text
@d5444 27
d6051 69
@


1.73
log
@	* powerpc.cc (Powerpc_relobj::do_scan_relocs): Delete.
	(Target_powerpc::do_define_standard_symbols): New function.
@
text
@d326 2
a327 1
      stub_tables_(), branch_lookup_table_(), branch_info_()
d607 4
d952 2
d1194 1
a1194 1
  // If we are generating a shared object, and gsym symbol is
d1200 1
a1200 1
  // If gsym is a call to a weak undefined symbol, we need to use
d1643 1
a1643 1
  {}
a2098 2
    this->group_sections(layout, task);
  else
d2100 2
a2101 5
      prev_brlt_size = this->branch_lookup_table_.size();
      this->branch_lookup_table_.clear();
      for (typename Stub_tables::iterator p = this->stub_tables_.begin();
	   p != this->stub_tables_.end();
	   ++p)
d2103 28
a2130 1
	  (*p)->clear_long_branch_stubs();
d2132 2
d2149 14
d2174 1
d2195 3
d2393 1
d2398 1
d2417 2
d2457 1
d2670 25
d2710 2
a2711 1
      orig_data_size_(0), plt_size_(0), branch_size_(0), prev_size_(0)
d2759 1
a2759 1
  clear_long_branch_stubs()
d2761 2
d2823 2
a2824 1
    if (this->prev_size_ != this->plt_size_ + this->branch_size_)
d2826 2
a2827 1
	this->prev_size_ = this->plt_size_ + this->branch_size_;
a2832 8
  section_size_type
  prev_size() const
  { return this->prev_size_; }

  void
  set_prev_size(section_size_type val)
  { this->prev_size_ = val; }

d2838 6
d2845 8
a2852 2
  stub_align()
  { return size == 32 ? 16 : 32; }
d2854 1
a2854 1
  // We keep plt stubs aligned, so no fancy sizing.
d2856 29
a2884 2
  plt_call_size() const
  { return size == 32 ? 16 : 32; }
d2890 3
a2892 2
    Address loc = this->stub_address() + this->plt_size_ + this->branch_size_;
    if (loc - to + (1 << 25) < 2 << 25)
a3003 2
  typedef Unordered_map<Plt_stub_ent, unsigned int,
			Plt_stub_ent_hash> Plt_stub_entries;
d3012 1
a3012 1
  section_size_type plt_size_, branch_size_, prev_size_;
d3060 4
a3063 2
  if (this->plt_call_stubs_.insert(std::make_pair(ent, off)).second)
    this->plt_size_ = off + this->plt_call_size();
d3076 4
a3079 2
  if (this->plt_call_stubs_.insert(std::make_pair(ent, off)).second)
    this->plt_size_ = off + this->plt_call_size();
a3224 25
static inline uint32_t
l(uint32_t a)
{
  return a & 0xffff;
}

static inline uint32_t
hi(uint32_t a)
{
  return l(a >> 16);
}

static inline uint32_t
ha(uint32_t a)
{
  return hi(a + 0x8000);
}

template<bool big_endian>
static inline void
write_insn(unsigned char* p, uint32_t v)
{
  elfcpp::Swap<32, big_endian>::writeval(p, v);
}

d3263 1
a3263 1
	      Address plt_addr;
d3270 1
a3270 1
		  plt_addr = gsym->plt_offset();
d3278 1
a3278 1
		  plt_addr = relobj->local_plt_offset(local_sym_index);
d3280 1
d3292 1
a3292 1
	      Address pltoff = plt_addr - got_addr;
d3294 1
a3294 1
	      if (pltoff + 0x80008000 > 0xffffffff || (pltoff & 7) != 0)
d3299 25
d3325 1
a3325 1
	      if (ha(pltoff) != 0)
a3326 1
		  write_insn<big_endian>(p, addis_12_2 + ha(pltoff)),	p += 4;
d3328 3
a3330 2
		  write_insn<big_endian>(p, ld_11_12 + l(pltoff)),	p += 4;
		  if (ha(pltoff + 16) != ha(pltoff))
d3332 2
a3333 2
		      write_insn<big_endian>(p, addi_12_12 + l(pltoff)),p += 4;
		      pltoff = 0;
d3336 8
a3343 3
		  write_insn<big_endian>(p, ld_2_12 + l(pltoff + 8)),	p += 4;
		  write_insn<big_endian>(p, ld_11_12 + l(pltoff + 16)),	p += 4;
		  write_insn<big_endian>(p, bctr);
d3348 2
a3349 2
		  write_insn<big_endian>(p, ld_11_2 + l(pltoff)),	p += 4;
		  if (ha(pltoff + 16) != ha(pltoff))
d3351 2
a3352 2
		      write_insn<big_endian>(p, addi_2_2 + l(pltoff)),	p += 4;
		      pltoff = 0;
d3355 8
a3362 3
		  write_insn<big_endian>(p, ld_11_2 + l(pltoff + 16)),	p += 4;
		  write_insn<big_endian>(p, ld_2_2 + l(pltoff + 8)),	p += 4;
		  write_insn<big_endian>(p, bctr);
d3364 8
d3476 2
a3477 2
		  Address pltoff = plt_addr - got_addr;
		  if (ha(pltoff) == 0)
d3479 1
a3479 1
		      write_insn<big_endian>(p +  0, lwz_11_30 + l(pltoff));
d3485 2
a3486 2
		      write_insn<big_endian>(p +  0, addis_11_30 + ha(pltoff));
		      write_insn<big_endian>(p +  4, lwz_11_11 + l(pltoff));
@


1.72
log
@	* layout.h (Layout::get_executable_sections): Declare.
	* layout.cc (Layout::get_executable_sections): New function.
	* arm.cc (Target_arm::group_sections): Use it.
	(Arm_output_section::group_sections): Delete now redundant test.
	* output.cc (Output_reloc::Output_reloc): Add is_relative.
	param to handle relative relocs.
	* output.h (Output_reloc::Output_reloc <absolute reloc>): Likewise.
	(Output_data_reloc::add_absolute): Adjust.
	(Output_data_reloc::add_relative): New function.
	(Output_data::reset_data_size): New function.
	(Output_relaxed_input_section::set_relobj, set_shndx): New functions.
	(Output_section::set_addralign): New function.
	(Output_section::checkpoint_set_addralign): New function.
	(Output_section::clear_section_offsets_need_adjustment): New function.
	(Output_section::input_sections): Make public.
	* powerpc.cc (class Output_data_brlt_powerpc): New.
	(class Stub_table, class Stub_control): New.
	(Powerpc_relobj::has14_, set_has_14bit_branch, has_14bit_branch,
	stub_table_, set_stub_table, stub_table): New vectors and accessor
	functions.
	(Target_powerpc::do_may_relax, do_relax, push_branch,
	new_stub_table, stub_tables, brlt_section, group_sections,
	add_branch_lookup_table, find_branch_lookup_table,
	write_branch_lookup_table, make_brlt_section): New functions.
	(Target_powerpc::struct Sort_sections, class Branch_info): New.
	(Target_powerpc::brlt_section_, stub_tables_, branch_lookup_table_,
	branch_info_): New vars.
	(Target_powerpc::make_plt_entry, make_local_ifunc_plt_entry): Don't
	make call stubs here.
	(Output_data_glink): Remove all call stub handling from this class.
	(Target_powerpc::Scan::local, global): Save interesting branch
	relocs and relocs for ifunc.  Adjust calls to plt entry functions.
	(Target_powerpc::do_finalize_sections): Only make reg save/restore
	functions on final link.
	(Target_powerpc::Relocate::relocate): Adjust lookup of call stubs.
	Handle long branch destinations too.
	(Target_powerpc::do_dynsym_value, do_plt_address_for_global,
	do_plt_address_for_local): Adjust lookup of plt call stubs.
@
text
@a203 6
  // Set up some symbols, then perform Sized_relobj_file method.
  // Occurs after garbage collection, which is why opd info can't be
  // set up here.
  void
  do_scan_relocs(Symbol_table*, Layout*, Read_relocs_data*);

d400 3
d1540 1
a1540 1
// Set up some symbols, then perform Sized_relobj_file method.
d1544 3
a1546 3
Powerpc_relobj<size, big_endian>::do_scan_relocs(Symbol_table* symtab,
						 Layout* layout,
						 Read_relocs_data* rd)
a1587 1
  Sized_relobj_file<size, big_endian>::do_scan_relocs(symtab, layout, rd);
@


1.71
log
@	* powerpc.c (Target_powerpc::Scan::global): Don't emit relative
	relocs against protected symbols when building 32-bit shared libs.
@
text
@d26 1
d52 3
d61 3
d235 28
d306 6
d329 4
a332 3
      got_(NULL), plt_(NULL), iplt_(NULL), glink_(NULL), rela_dyn_(NULL),
      copy_relocs_(elfcpp::R_POWERPC_COPY),
      dynbss_(NULL), tlsld_got_offset_(-1U)
d381 25
d573 36
d822 3
d827 1
a827 3
  make_plt_entry(Symbol_table*, Layout*, Symbol*,
		 const elfcpp::Rela<size, big_endian>&,
		 const Sized_relobj_file<size, big_endian>* object);
d832 3
a834 2
			     const elfcpp::Rela<size, big_endian>&,
			     Sized_relobj_file<size, big_endian>*);
d864 45
d925 1
a925 1
  // The GOT output section.
d927 1
a927 1
  // The PLT output section.
d929 1
a929 1
  // The IPLT output section.
d931 3
a933 1
  // The .glink output section.
d935 1
a935 1
  // The dynamic reloc output section.
d943 7
d1804 397
d2294 1
a2294 1
      off_t off = this->current_data_size();
d2314 1
a2314 1
      off_t off = this->current_data_size();
d2335 1
a2335 1
      off_t off = this->current_data_size();
d2397 1
d2417 1
a2417 1
      const off_t offset = this->offset();
d2427 1
a2427 2
      elfcpp::Elf_types<32>::Elf_Addr branch_tab
	= glink->address() + glink->pltresolve();
d2501 123
a2623 1
// A class to handle .glink.
d2626 1
a2626 1
class Output_data_glink : public Output_section_data
d2629 8
a2636 1
  static const int pltresolve_size = 16*4;
d2638 3
a2640 1
  Output_data_glink(Target_powerpc<size, big_endian>*);
d2642 1
a2642 1
  // Add an entry
d2644 4
a2647 3
  add_entry(const Sized_relobj_file<size, big_endian>*,
	    const Symbol*,
	    const elfcpp::Rela<size, big_endian>&);
d2650 4
a2653 3
  add_entry(const Sized_relobj_file<size, big_endian>*,
	    unsigned int,
	    const elfcpp::Rela<size, big_endian>&);
d2655 26
a2680 2
  unsigned int
  find_entry(const Symbol*) const;
d2682 6
a2687 2
  unsigned int
  find_entry(const Sized_relobj_file<size, big_endian>*, unsigned int) const;
d2689 16
a2704 4
  unsigned int
  find_entry(const Sized_relobj_file<size, big_endian>*,
	     const Symbol*,
	     const elfcpp::Rela<size, big_endian>&) const;
d2706 6
a2711 4
  unsigned int
  find_entry(const Sized_relobj_file<size, big_endian>*,
	     unsigned int,
	     const elfcpp::Rela<size, big_endian>&) const;
d2713 2
a2714 2
  unsigned int
  glink_entry_size() const
d2716 2
a2717 6
    if (size == 32)
      return 4 * 4;
    else
      // FIXME: We should be using multiple glink sections for
      // stubs to support > 33M applications.
      return 8 * 4;
d2720 6
a2725 2
  off_t
  pltresolve() const
d2727 24
a2750 1
    return this->pltresolve_;
d2753 4
a2756 2
 protected:
  // Write to a map file.
d2758 6
a2763 2
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** glink")); }
d2766 20
a2785 2
  void
  set_final_data_size();
d2787 1
a2787 1
  // Write out .glink
d2791 2
a2792 1
  class Glink_sym_ent
d2795 1
a2795 1
    Glink_sym_ent(const Symbol* sym)
d2799 2
a2800 2
    Glink_sym_ent(const Sized_relobj_file<size, big_endian>* object,
		  unsigned int locsym_index)
d2804 4
a2807 3
    Glink_sym_ent(const Sized_relobj_file<size, big_endian>* object,
		  const Symbol* sym,
		  const elfcpp::Rela<size, big_endian>& reloc)
d2811 1
a2811 1
	this->addend_ = reloc.get_r_addend();
d2813 1
a2813 2
	       && (elfcpp::elf_r_type<size>(reloc.get_r_info())
		   == elfcpp::R_PPC_PLTREL24))
d2815 1
a2815 1
	  this->addend_ = reloc.get_r_addend();
d2821 4
a2824 3
    Glink_sym_ent(const Sized_relobj_file<size, big_endian>* object,
		  unsigned int locsym_index,
		  const elfcpp::Rela<size, big_endian>& reloc)
d2828 1
a2828 1
	this->addend_ = reloc.get_r_addend();
d2830 2
a2831 3
	       && (elfcpp::elf_r_type<size>(reloc.get_r_info())
		   == elfcpp::R_PPC_PLTREL24))
	this->addend_ = reloc.get_r_addend();
d2834 1
a2834 1
    bool operator==(const Glink_sym_ent& that) const
d2843 37
a2879 3
    const Sized_relobj_file<size, big_endian>* object_;
    typename elfcpp::Elf_types<size>::Elf_Addr addend_;
    unsigned int locsym_;
d2882 1
a2882 1
  class Glink_sym_ent_hash
d2885 2
a2886 7
    size_t operator()(const Glink_sym_ent& ent) const
    {
      return (reinterpret_cast<uintptr_t>(ent.sym_)
	      ^ reinterpret_cast<uintptr_t>(ent.object_)
	      ^ ent.addend_
	      ^ ent.locsym_);
    }
d2889 1
a2889 9
  // Map sym/object/addend to index.
  typedef Unordered_map<Glink_sym_ent, unsigned int,
			Glink_sym_ent_hash> Glink_entries;
  Glink_entries glink_entries_;

  // Offset of pltresolve stub (actually, branch table for 32-bit)
  off_t pltresolve_;

  // Allows access to .got and .plt for do_write.
d2891 12
d2905 1
a2905 1
// Create the glink section.
d2908 2
a2909 4
Output_data_glink<size, big_endian>::Output_data_glink(
    Target_powerpc<size, big_endian>* targ)
  : Output_section_data(16),
    pltresolve_(0), targ_(targ)
d2911 24
d2937 1
a2937 1
// Add an entry to glink, if we do not already have one for this
d2942 1
a2942 1
Output_data_glink<size, big_endian>::add_entry(
d2945 2
a2946 1
    const elfcpp::Rela<size, big_endian>& reloc)
d2948 4
a2951 3
  Glink_sym_ent ent(object, gsym, reloc);
  unsigned int indx = this->glink_entries_.size();
  this->glink_entries_.insert(std::make_pair(ent, indx));
d2956 1
a2956 1
Output_data_glink<size, big_endian>::add_entry(
d2959 2
a2960 1
    const elfcpp::Rela<size, big_endian>& reloc)
d2962 4
a2965 3
  Glink_sym_ent ent(object, locsym_index, reloc);
  unsigned int indx = this->glink_entries_.size();
  this->glink_entries_.insert(std::make_pair(ent, indx));
d2968 2
d2971 2
a2972 2
unsigned int
Output_data_glink<size, big_endian>::find_entry(
d2975 2
a2976 1
    const elfcpp::Rela<size, big_endian>& reloc) const
d2978 3
a2980 4
  Glink_sym_ent ent(object, gsym, reloc);
  typename Glink_entries::const_iterator p = this->glink_entries_.find(ent);
  gold_assert(p != this->glink_entries_.end());
  return p->second;
d2984 2
a2985 2
unsigned int
Output_data_glink<size, big_endian>::find_entry(const Symbol* gsym) const
d2987 3
a2989 4
  Glink_sym_ent ent(gsym);
  typename Glink_entries::const_iterator p = this->glink_entries_.find(ent);
  gold_assert(p != this->glink_entries_.end());
  return p->second;
d2993 2
a2994 2
unsigned int
Output_data_glink<size, big_endian>::find_entry(
d2997 2
a2998 1
    const elfcpp::Rela<size, big_endian>& reloc) const
d3000 3
a3002 4
  Glink_sym_ent ent(object, locsym_index, reloc);
  typename Glink_entries::const_iterator p = this->glink_entries_.find(ent);
  gold_assert(p != this->glink_entries_.end());
  return p->second;
d3006 2
a3007 2
unsigned int
Output_data_glink<size, big_endian>::find_entry(
d3011 37
a3047 4
  Glink_sym_ent ent(object, locsym_index);
  typename Glink_entries::const_iterator p = this->glink_entries_.find(ent);
  gold_assert(p != this->glink_entries_.end());
  return p->second;
d3050 30
d3084 2
a3085 2
  unsigned int count = this->glink_entries_.size();
  off_t total = count;
a3090 3
	  total *= 16;
	  this->pltresolve_ = total;

a3098 2
	  total *= 32;
	  this->pltresolve_ = total;
d3136 1
a3136 1
// Write out .glink.
d3140 1
a3140 1
Output_data_glink<size, big_endian>::do_write(Output_file* of)
d3142 6
a3147 1
  const off_t off = this->offset();
d3149 1
a3149 1
    convert_to_section_size_type(this->data_size());
a3152 1
  // The base address of the .plt section.
a3154 5
  Address plt_base = this->targ_->plt_section()->address();
  Address iplt_base = invalid_address;

  const Output_data_got_powerpc<size, big_endian>* got
    = this->targ_->got_section();
d3158 2
d3162 77
a3238 14
      // Write out call stubs.
      typename Glink_entries::const_iterator g;
      for (g = this->glink_entries_.begin();
	   g != this->glink_entries_.end();
	   ++g)
	{
	  Address plt_addr;
	  bool is_ifunc;
	  const Symbol* gsym = g->first.sym_;
	  if (gsym != NULL)
	    {
	      is_ifunc = (gsym->type() == elfcpp::STT_GNU_IFUNC
			  && gsym->can_use_relative_reloc(false));
	      plt_addr = gsym->plt_offset();
d3240 13
d3255 17
a3271 11
	      is_ifunc = true;
	      const Sized_relobj_file<size, big_endian>* relobj
		= g->first.object_;
	      unsigned int local_sym_index = g->first.locsym_;
	      plt_addr = relobj->local_plt_offset(local_sym_index);
	    }
	  if (is_ifunc)
	    {
	      if (iplt_base == invalid_address)
		iplt_base = this->targ_->iplt_section()->address();
	      plt_addr += iplt_base;
d3273 86
a3358 19
	  else
	    plt_addr += plt_base;
	  const Powerpc_relobj<size, big_endian>* ppcobj = static_cast
	    <const Powerpc_relobj<size, big_endian>*>(g->first.object_);
	  Address got_addr = got_os_addr + ppcobj->toc_base_offset();
	  Address pltoff = plt_addr - got_addr;

	  if (pltoff + 0x80008000 > 0xffffffff || (pltoff & 7) != 0)
	    gold_error(_("%s: linkage table error against `%s'"),
		       g->first.object_->name().c_str(),
		       g->first.sym_->demangled_name().c_str());

	  p = oview + g->second * this->glink_entry_size();
	  if (ha(pltoff) != 0)
	    {
	      write_insn<big_endian>(p, addis_12_2 + ha(pltoff)),	p += 4;
	      write_insn<big_endian>(p, std_2_1 + 40),			p += 4;
	      write_insn<big_endian>(p, ld_11_12 + l(pltoff)),		p += 4;
	      if (ha(pltoff + 16) != ha(pltoff))
d3360 4
a3363 2
		  write_insn<big_endian>(p, addi_12_12 + l(pltoff)),	p += 4;
		  pltoff = 0;
d3365 20
a3384 4
	      write_insn<big_endian>(p, mtctr_11),			p += 4;
	      write_insn<big_endian>(p, ld_2_12 + l(pltoff + 8)),	p += 4;
	      write_insn<big_endian>(p, ld_11_12 + l(pltoff + 16)),	p += 4;
	      write_insn<big_endian>(p, bctr),				p += 4;
d3388 9
a3396 11
	      write_insn<big_endian>(p, std_2_1 + 40),			p += 4;
	      write_insn<big_endian>(p, ld_11_2 + l(pltoff)),		p += 4;
	      if (ha(pltoff + 16) != ha(pltoff))
		{
		  write_insn<big_endian>(p, addi_2_2 + l(pltoff)),	p += 4;
		  pltoff = 0;
		}
	      write_insn<big_endian>(p, mtctr_11),			p += 4;
	      write_insn<big_endian>(p, ld_11_2 + l(pltoff + 16)),	p += 4;
	      write_insn<big_endian>(p, ld_2_2 + l(pltoff + 8)),	p += 4;
	      write_insn<big_endian>(p, bctr),				p += 4;
d3399 18
d3418 2
d3421 2
a3422 2
      p = oview + this->pltresolve_;
      Address after_bcl = this->address() + this->pltresolve_ + 16;
d3438 1
a3438 1
      while (p < oview + this->pltresolve_ + this->pltresolve_size)
d3454 1
a3454 1
	  uint32_t branch_off = this->pltresolve_ + 8 - (p - oview);
d3461 2
a3465 73
      // Write out call stubs.
      typename Glink_entries::const_iterator g;
      for (g = this->glink_entries_.begin();
	   g != this->glink_entries_.end();
	   ++g)
	{
	  Address plt_addr;
	  bool is_ifunc;
	  const Symbol* gsym = g->first.sym_;
	  if (gsym != NULL)
	    {
	      is_ifunc = (gsym->type() == elfcpp::STT_GNU_IFUNC
			  && gsym->can_use_relative_reloc(false));
	      plt_addr = gsym->plt_offset();
	    }
	  else
	    {
	      is_ifunc = true;
	      const Sized_relobj_file<size, big_endian>* relobj
		= g->first.object_;
	      unsigned int local_sym_index = g->first.locsym_;
	      plt_addr = relobj->local_plt_offset(local_sym_index);
	    }
	  if (is_ifunc)
	    {
	      if (iplt_base == invalid_address)
		iplt_base = this->targ_->iplt_section()->address();
	      plt_addr += iplt_base;
	    }
	  else
	    plt_addr += plt_base;

	  p = oview + g->second * this->glink_entry_size();
	  if (parameters->options().output_is_position_independent())
	    {
	      Address got_addr;
	      const Powerpc_relobj<size, big_endian>* object = static_cast
		<const Powerpc_relobj<size, big_endian>*>(g->first.object_);
	      if (object != NULL && g->first.addend_ >= 32768)
		{
		  unsigned int got2 = object->got2_shndx();
		  got_addr = g->first.object_->get_output_section_offset(got2);
		  gold_assert(got_addr != invalid_address);
		  got_addr += (g->first.object_->output_section(got2)->address()
			       + g->first.addend_);
		}
	      else
		got_addr = g_o_t;

	      Address pltoff = plt_addr - got_addr;
	      if (ha(pltoff) == 0)
		{
		  write_insn<big_endian>(p +  0, lwz_11_30 + l(pltoff));
		  write_insn<big_endian>(p +  4, mtctr_11);
		  write_insn<big_endian>(p +  8, bctr);
		}
	      else
		{
		  write_insn<big_endian>(p +  0, addis_11_30 + ha(pltoff));
		  write_insn<big_endian>(p +  4, lwz_11_11 + l(pltoff));
		  write_insn<big_endian>(p +  8, mtctr_11);
		  write_insn<big_endian>(p + 12, bctr);
		}
	    }
	  else
	    {
	      write_insn<big_endian>(p +  0, lis_11 + ha(plt_addr));
	      write_insn<big_endian>(p +  4, lwz_11_11 + l(plt_addr));
	      write_insn<big_endian>(p +  8, mtctr_11);
	      write_insn<big_endian>(p + 12, bctr);
	    }
	}

d3467 1
a3467 1
      p = oview + this->pltresolve_;
d3478 1
a3478 1
	  Address res0_off = this->pltresolve_;
d3512 1
a3512 1
	  Address res0 = this->pltresolve_ + this->address();
d3840 1
a3840 1
	  off_t value = this->current_data_size();
d3846 1
a3846 1
	  off_t cur_size = p - this->contents_;
d3863 1
a3863 1
  const off_t off = this->offset();
d3891 3
a3893 6
Target_powerpc<size, big_endian>::make_plt_entry(
    Symbol_table* symtab,
    Layout* layout,
    Symbol* gsym,
    const elfcpp::Rela<size, big_endian>& reloc,
    const Sized_relobj_file<size, big_endian>* object)
a3907 1
  this->glink_->add_entry(object, gsym, reloc);
d3917 2
a3918 2
    const elfcpp::Rela<size, big_endian>& reloc,
    Sized_relobj_file<size, big_endian>* relobj)
a3921 1
  unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
a3922 1
  this->glink_->add_entry(relobj, r_sym, reloc);
d4273 4
a4276 1
      target->make_local_ifunc_plt_entry(symtab, layout, reloc, object);
a4364 2
    case elfcpp::R_PPC64_REL64:
    case elfcpp::R_POWERPC_REL32:
d4368 15
a4386 3
    case elfcpp::R_POWERPC_REL14:
    case elfcpp::R_POWERPC_REL14_BRTAKEN:
    case elfcpp::R_POWERPC_REL14_BRNTAKEN:
d4597 6
a4602 1
    target->make_plt_entry(symtab, layout, gsym, reloc, object);
d4672 5
a4676 1
	    target->make_plt_entry(symtab, layout, gsym, reloc, 0);
d4731 3
d4739 1
a4739 1
	target->make_plt_entry(symtab, layout, gsym, reloc, object);
d4764 8
a4775 3
    case elfcpp::R_POWERPC_REL14:
    case elfcpp::R_POWERPC_REL14_BRTAKEN:
    case elfcpp::R_POWERPC_REL14_BRNTAKEN:
d5260 11
a5270 1
      this->define_save_restore_funcs(layout, symtab);
d5299 1
a5299 2
					    (this->glink_->pltresolve()
					     + this->glink_->pltresolve_size
a5367 1

d5397 10
a5406 3
      const Output_data_glink<size, big_endian>* glink
	= target->glink_section();
      unsigned int glink_index;
d5408 2
a5409 1
	glink_index = glink->find_entry(object, gsym, rela);
d5411 4
a5414 2
	glink_index = glink->find_entry(object, r_sym, rela);
      value = glink->address() + glink_index * glink->glink_entry_size();
d5752 19
d6579 1
a6579 1
// Return the value to use for a dynamic which requires special
d6591 8
a6598 3
      const Output_data_glink<size, big_endian>* glink = this->glink_section();
      unsigned int glink_index = glink->find_entry(gsym);
      return glink->address() + glink_index * glink->glink_entry_size();
d6600 1
a6600 2
  else
    gold_unreachable();
d6614 9
a6622 4
      const Output_data_glink<size, big_endian>* glink = this->glink_section();
      unsigned int glink_index = glink->find_entry(relobj->sized_relobj(),
						   symndx);
      return glink->address() + glink_index * glink->glink_entry_size();
d6624 1
a6624 2
  else
    gold_unreachable();
d6635 8
a6642 3
      const Output_data_glink<size, big_endian>* glink = this->glink_section();
      unsigned int glink_index = glink->find_entry(gsym);
      return glink->address() + glink_index * glink->glink_entry_size();
d6644 1
a6644 2
  else
    gold_unreachable();
@


1.70
log
@	* powerpc.cc (Target_powerpc::make_plt_section): Add symtab
	param.  Call got_section() to make .got.  Update all callers
	and their callers and so on.
@
text
@d3667 9
a3675 5
	    else if (((size == 32 && r_type == elfcpp::R_POWERPC_ADDR32)
		      || (size == 64 && r_type == elfcpp::R_PPC64_ADDR64))
		     && (gsym->can_use_relative_reloc(false)
			 || (size == 64
			     && data_shndx == ppc_object->opd_shndx())))
@


1.69
log
@	* powerpc.cc (Powerpc_relobj::do_scan_relocs): Make STB_LOCAL
	_GLOBAL_OFFSET_TABLE_ rather than STB_WEAK.
	(Output_data_got_powerpc::make_header): Update _GLOBAL_OFFSET_TABLE_
	value if it already exists.
@
text
@d714 1
a714 1
  make_plt_section(Layout*);
d717 1
a717 1
  make_iplt_section(Layout*);
d721 1
a721 1
  make_plt_entry(Layout*, Symbol*,
d727 1
a727 1
  make_local_ifunc_plt_entry(Layout*,
d1888 2
a1889 1
Target_powerpc<size, big_endian>::make_plt_section(Layout* layout)
d1893 3
d1929 2
a1930 1
Target_powerpc<size, big_endian>::make_iplt_section(Layout* layout)
d1934 1
a1934 1
      this->make_plt_section(layout);
d2880 1
d2890 1
a2890 1
	this->make_iplt_section(layout);
d2896 1
a2896 1
	this->make_plt_section(layout);
d2907 1
d2913 1
a2913 1
    this->make_iplt_section(layout);
d3266 3
a3268 1
    target->make_local_ifunc_plt_entry(layout, reloc, object);
d3578 1
a3578 1
    target->make_plt_entry(layout, gsym, reloc, object);
d3648 1
a3648 1
	    target->make_plt_entry(layout, gsym, reloc, 0);
d3704 1
a3704 1
	target->make_plt_entry(layout, gsym, reloc, object);
@


1.68
log
@	* powerpc.cc (Powerpc_relobj): Delete "Offset" typedef.
	(struct Opd_ent): Use "Address" rather than "Offset".
	(Output_data_got_powerpc::got_base_offset): Return Valtype.
	(Target_powerpc::got_section): Make public.
	(Target_powerpc::scan_relocs): Move code setting symbols..
	(Powerpc_relobj::do_scan_relocs): ..to here, new function.
	Create _SDA_BASE_ only when referenced.
@
text
@d1394 2
a1395 2
      // Define a weak hidden _GLOBAL_OFFSET_TABLE_ to ensure it isn't
      // seen as undefined when scanning relocs (and thus requires
d1410 1
a1410 1
					elfcpp::STB_WEAK,
d1577 14
a1590 7
	this->symtab_->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
					     Symbol_table::PREDEFINED,
					     this, this->g_o_t(), 0,
					     elfcpp::STT_OBJECT,
					     elfcpp::STB_LOCAL,
					     elfcpp::STV_HIDDEN,
					     0, false, false);
@


1.67
log
@gold/
	* target.h (Sized_target::relocate_relocs): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_relocs): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_relocs): Likewise.
	* powerpc.cc (Target_powerpc::relocate_relocs): Likewise.
	* sparc.cc (Target_sparc::relocate_relocs): Likewise.
	* target-reloc.h (relocate_relocs): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_relocs): Likewise.
	* x86_64.cc (Target_x86_64::relocate_relocs): Likewise.
@
text
@a60 1
  typedef typename elfcpp::Elf_types<size>::Elf_Off Offset;
d192 2
d197 6
d234 1
a234 1
    Offset off;
d459 4
a707 4
  // Get the GOT section, creating it if necessary.
  Output_data_got_powerpc<size, big_endian>*
  got_section(Symbol_table*, Layout*);

d1384 51
d1520 1
a1520 1
  typename elfcpp::Elf_types<size>::Elf_Off
a4098 36
  if (size == 32)
    {
      // Define a weak hidden _GLOBAL_OFFSET_TABLE_ to ensure it isn't
      // seen as undefined when scanning relocs (and thus requires
      // non-relative dynamic relocs).  The proper value will be
      // updated later.
      Symbol *gotsym = symtab->lookup("_GLOBAL_OFFSET_TABLE_", NULL);
      if (gotsym != NULL && gotsym->is_undefined())
	symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
				      Symbol_table::PREDEFINED,
				      this->got_section(symtab, layout), 0, 0,
				      elfcpp::STT_OBJECT,
				      elfcpp::STB_WEAK,
				      elfcpp::STV_HIDDEN, 0,
				      false, false);

      static Output_data_space* sdata;

      // Define _SDA_BASE_ at the start of the .sdata section.
      if (sdata == NULL)
	{
	  // layout->find_output_section(".sdata") == NULL
	  sdata = new Output_data_space(4, "** sdata");
	  Output_section* os
	    = layout->add_output_section_data(".sdata", 0,
					      elfcpp::SHF_ALLOC
					      | elfcpp::SHF_WRITE,
					      sdata, ORDER_SMALL_DATA, false);
	  symtab->define_in_output_data("_SDA_BASE_", NULL,
					Symbol_table::PREDEFINED,
					os, 32768, 0, elfcpp::STT_OBJECT,
					elfcpp::STB_LOCAL, elfcpp::STV_HIDDEN,
					0, false, false);
	}
    }

@


1.66
log
@	* target-reloc.h (class Default_comdat_behavior): New, package up..
	(get_comdat_behaviour): ..this.
	(relocate_section): Add Relocate_comdat_behavior template arg,
	adjust code to suit.
	* arm.cc (Target_arm::relocate_section): Adjust to suit.
	(Target_arm::scan_reloc_section): Likewise.
	* i386.cc (Target_i386::relocate_section): Likewise.
	* sparc.cc (Target_sparc::relocate_section): Likewise.
	* tilegx.cc (Target_tilegx::relocate_section): Likewise.
	* x86_64.cc (Target_x86_64::relocate_section): Likewise.
	* powerpc.cc (class Relocate_comdat_behavior): New.
	(Target_powerpc::relocate_section): Don't zap opd relocs.  Supply
	gold::relocate_section with new template arg.
@
text
@d396 2
a397 1
		  off_t offset_in_output_section,
d2515 1
a2515 1
static unsigned char* 
d2524 1
a2524 1
static unsigned char* 
d2543 1
a2543 1
static unsigned char* 
d2552 1
a2552 1
static unsigned char* 
d2561 1
a2561 1
static unsigned char* 
d2570 1
a2570 1
static unsigned char* 
d2579 1
a2579 1
static unsigned char* 
d2588 1
a2588 1
static unsigned char* 
d2599 1
a2599 1
static unsigned char* 
d2608 1
a2608 1
static unsigned char* 
d2626 1
a2626 1
static unsigned char* 
d2635 1
a2635 1
static unsigned char* 
d2644 1
a2644 1
static unsigned char* 
d2656 1
a2656 1
static unsigned char* 
d2665 1
a2665 1
static unsigned char* 
d2677 1
a2677 1
static unsigned char* 
d5181 1
a5181 1
    off_t offset_in_output_section,
@


1.65
log
@	* powerpc.cc (Target_powerpc::Scan::local, global): Always emit
	dynamic relocs for GOT_TPREL got entries, without symbol if
	resolving locally.
	(Target_powerpc::do_gc_add_reference): Don't add for dynamic objects.
	(Target_powerpc::scan_relocs): Define _GLOBAL_OFFSET_TABLE_ early.
	(Target_powerpc::Relocate:relocate): REL32 reloc may be unaligned.
@
text
@d622 26
d5080 2
a5084 37
  unsigned char *opd_rel = NULL;
  Powerpc_relobj<size, big_endian>* const object
    = static_cast<Powerpc_relobj<size, big_endian>*>(relinfo->object);
  if (size == 64
      && relinfo->data_shndx == object->opd_shndx())
    {
      // Rewrite opd relocs, omitting those for discarded sections
      // to silence gold::relocate_section errors.
      const int reloc_size
	= Reloc_types<elfcpp::SHT_RELA, size, big_endian>::reloc_size;
      opd_rel = new unsigned char[reloc_count * reloc_size];
      const unsigned char* rrel = prelocs;
      unsigned char* wrel = opd_rel;

      for (size_t i = 0;
	   i < reloc_count;
	   ++i, rrel += reloc_size, wrel += reloc_size)
	{
	  typename Reloc_types<elfcpp::SHT_RELA, size, big_endian>::Reloc
	    reloc(rrel);
	  typename elfcpp::Elf_types<size>::Elf_WXword r_info
	    = reloc.get_r_info();
	  unsigned int r_type = elfcpp::elf_r_type<size>(r_info);
	  Address r_off = reloc.get_r_offset();
	  if (r_type == elfcpp::R_PPC64_TOC)
	    r_off -= 8;
	  bool is_discarded = object->get_opd_discard(r_off);

	  // Reloc number is reported in some errors, so keep all relocs.
	  if (is_discarded)
	    memset(wrel, 0, reloc_size);
	  else
	    memcpy(wrel, rrel, reloc_size);
	}
      prelocs = opd_rel;
    }

d5086 1
a5086 1
			 Powerpc_relocate>(
a5096 3

  if (opd_rel != NULL)
    delete[] opd_rel;
@


1.64
log
@	* powerpc.cc (Target_powerpc::define_save_restore_funcs): New func.
	(Target_powerpc::do_finalize_sections): Call it.
	(Output_data_save_res): New class and supporting functions.
	(Target_powerpc::symval_for_branch): Only look up .opd entry for
	normal symbols defined in object files.
@
text
@a3413 2
	    Output_data_got_powerpc<size, big_endian>* got
	      = target->got_section(symtab, layout);
d3415 12
a3426 1
	    got->add_local_tls(object, r_sym, GOT_TYPE_TPREL);
d3741 20
a3760 5
	    Output_data_got_powerpc<size, big_endian>* got
	      = target->got_section(symtab, layout);
	    got->add_global_with_rel(gsym, GOT_TYPE_TPREL,
				     target->rela_dyn_section(layout),
				     elfcpp::R_POWERPC_TPREL);
d3822 20
a3841 11
	    Output_data_got_powerpc<size, big_endian>* got
	      = target->got_section(symtab, layout);
	    if (!gsym->final_value_is_known()
		&& (gsym->is_from_dynobj()
		    || gsym->is_undefined()
		    || gsym->is_preemptible()))
	      got->add_global_with_rel(gsym, GOT_TYPE_TPREL,
				       target->rela_dyn_section(layout),
				       elfcpp::R_POWERPC_TPREL);
	    else
	      got->add_global_tls(gsym, GOT_TYPE_TPREL);
d3938 3
a3940 1
  if (size == 64 && dst_shndx == ppc_object->opd_shndx())
d4016 14
a4827 1
    case elfcpp::R_POWERPC_REL32:
d4831 1
@


1.63
log
@	* powerpc.cc (Powerpc_relobj::add_gc_mark, process_gc_mark): New.
	(struct Opd_ent): Make "discard" a bit field.  Add "gc_mark".
	(Target_powerpc::do_gc_mark_symbol): Delay marking function code
	section if scan_opd_relocs not yet called.
	(Target_powerpc::gc_process_relocs): Call process_gc_mark.
@
text
@d328 4
d1720 1
d1724 2
d1732 1
d1734 1
d1743 1
d1753 2
d1756 2
d2434 329
d4047 16
d4106 1
d4165 3
@


1.62
log
@	* powerpc.cc (Output_data_plt_powerpc::add_entry, add_ifunc_entry,
	add_local_ifunc_entry): Revert last change.
	(Target_powerpc::make_plt_entry, make_local_ifunc_plt_entry): Likewise.
@
text
@d157 22
d225 2
a226 1
    bool discard;
d3525 1
d3598 7
a3604 2
	  unsigned int dst_indx = ppc_object->get_opd_ent(dst_off);
	  symtab->gc()->worklist().push(Section_id(ppc_object, dst_indx));
@


1.61
log
@	* powerpc.cc (Target_powerpc::do_plt_address_for_local,
	do_plt_address_for_global): New functions.
	(Output_data_got_powerpc::do_write): Don't segfault when linking
	statically.
	(Output_data_plt_powerpc::add_entry, add_ifunc_entry,
	add_local_ifunc_entry): Return true on adding entry..
	(Target_powerpc::make_plt_entry): ..use to avoid unnecessary
	glink->add_entry call.  Remove unused symtab param.  Adjust calls.
	(Target_powerpc::make_local_ifunc_plt_entry): Likewise.
	(Target_powerpc::make_iplt_section): Remove symtab param.  Don't
	set up symbols here.
	(Target_powerpc::do_finalize_sections): Instead set up __rela_iplt
	syms here.  Do so even when no .iplt.  Don't segfault when linking
	statically.
	(Output_data_glink::add_entry, find_entry): Rearrange params.  Add
	new variants without reloc param.
	(Glink_sym_ent::Glink_sym_ent): Likewise.
	(Target_powerpc::Scan::reloc_needs_plt_for_ifunc): Accept any
	reloc when refs will resolve to plt call stub.
	(Target_powerpc::Scan::local): Correct ifunc handling.  Allow
	R_PPC_PLTREL24 to resolve locally.
	(Target_powerpc::Scan::global): Correct ifunc handling.
	(Target_powerpc::Relocate::relocate): Correct local sym glink
	lookup.  Don't destroy "value" when we have a plt call stub,
	and when checking plt call validity.
	(Target_powerpc::do_dynsym_value): Simplify.
@
text
@d1547 1
a1547 1
  bool
d1550 1
a1550 1
  bool
d1553 1
a1553 1
  bool
d1614 1
a1614 1
bool
a1627 1
      return true;
a1628 1
  return false;
d1634 1
a1634 1
bool
a1646 1
      return true;
a1647 1
  return false;
d1653 1
a1653 1
bool
a1668 1
      return true;
a1669 1
  return false;
d2427 1
a2427 2
      if (this->iplt_->add_ifunc_entry(gsym))
	this->glink_->add_entry(object, gsym, reloc);
d2433 1
a2433 2
      if (this->plt_->add_entry(gsym))
	this->glink_->add_entry(object, gsym, reloc);
d2435 1
d2450 2
a2451 2
  if (this->iplt_->add_local_ifunc_entry(relobj, r_sym))
    this->glink_->add_entry(relobj, r_sym, reloc);
@


1.60
log
@	* powerpc.cc (Target_powerpc::iplt_): New output section.
	(Target_powerpc::iplt_section, make_iplt_section,
	reloc_needs_plt_for_ifunc, make_local_ifunc_plt_entry): New functions.
	(Target_powerpc::make_plt_entry): Handle ifunc syms.
	Target_powerpc::plt_entry_count): Count iplt entries too.
	(Output_data_plt_powerpc::Output_data_plt_powerpc): Don't create
	reloc section in constructor.  New params.
	(Target_powerpc::make_plt_section): Create reloc section here instead.
	(Output_data_plt_powerpc::add_ifunc_entry, add_local_ifunc_entry): New
	functions.
	(Output_data_plt_powerpc::initial_plt_entry_size_, name_): New vars.
	(Output_data_glink::add_entry, find_entry): New functions to
	deal with local syms.
	(Glink_sym_ent): Add support for local syms.
	(Output_data_glink::do_write): Handle ifunc plt entries.
	(Target_powerpc::Scan::get_reference_flags): Handle more relocs.
	(Target_powerpc::Scan::local, global): Handle ifunc syms.
	(Target_powerpc::Relocate::relocate): Likewise.
	(Target_powerpc::do_dynsym_value): Use glink stub, not plt entry.
@
text
@d314 8
d656 1
a656 1
  make_iplt_section(Layout*, Symbol_table*);
d660 1
a660 1
  make_plt_entry(Layout*, Symbol_table*, Symbol*,
d666 1
a666 1
  make_local_ifunc_plt_entry(Layout*, Symbol_table*,
d1434 6
a1439 5
    this->replace_constant(this->header_index_,
			   (size == 32
			    ? this->layout_->dynamic_section()->address()
			    : this->output_section()->address() + 0x8000));

d1547 1
a1547 1
  void
d1550 1
a1550 1
  void
d1553 1
a1553 1
  void
d1614 1
a1614 1
void
d1628 1
d1630 1
d1636 1
a1636 1
void
d1649 1
d1651 1
d1657 1
a1657 1
void
d1673 1
d1675 1
d1802 1
a1802 2
Target_powerpc<size, big_endian>::make_iplt_section(Layout* layout,
						    Symbol_table* symtab)
a1813 13
      if (parameters->doing_static_link())
	{
	  symtab->define_in_output_data("__rela_iplt_start", NULL,
					Symbol_table::PREDEFINED,
					iplt_rel, 0, 0,
					elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
					elfcpp::STV_HIDDEN, 0, false, true);
	  symtab->define_in_output_data("__rela_iplt_end", NULL,
					Symbol_table::PREDEFINED,
					iplt_rel, 0, 0,
					elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
					elfcpp::STV_HIDDEN, 0, true, true);
	}
d1829 3
a1831 2
  add_entry(const Symbol*, const elfcpp::Rela<size, big_endian>&,
	    const Sized_relobj_file<size, big_endian>*);
d1834 6
a1839 2
  add_entry(unsigned int, const elfcpp::Rela<size, big_endian>&,
	    const Sized_relobj_file<size, big_endian>*);
d1842 1
a1842 2
  find_entry(const Symbol*, const elfcpp::Rela<size, big_endian>&,
	     const Sized_relobj_file<size, big_endian>*) const;
d1845 8
a1852 2
  find_entry(unsigned int, const elfcpp::Rela<size, big_endian>&,
	     const Sized_relobj_file<size, big_endian>*) const;
d1888 12
a1899 3
    Glink_sym_ent(const Symbol* sym,
		  const elfcpp::Rela<size, big_endian>& reloc,
		  const Sized_relobj_file<size, big_endian>* object)
d1914 3
a1916 3
    Glink_sym_ent(unsigned int locsym_index,
		  const elfcpp::Rela<size, big_endian>& reloc,
		  const Sized_relobj_file<size, big_endian>* object)
d1981 1
d1983 1
a1983 2
    const elfcpp::Rela<size, big_endian>& reloc,
    const Sized_relobj_file<size, big_endian>* object)
d1985 1
a1985 1
  Glink_sym_ent ent(gsym, reloc, object);
d1993 1
d1995 1
a1995 2
    const elfcpp::Rela<size, big_endian>& reloc,
    const Sized_relobj_file<size, big_endian>* object)
d1997 1
a1997 1
  Glink_sym_ent ent(locsym_index, reloc, object);
d2005 1
d2007 11
a2017 2
    const elfcpp::Rela<size, big_endian>& reloc,
    const Sized_relobj_file<size, big_endian>* object) const
d2019 1
a2019 1
  Glink_sym_ent ent(gsym, reloc, object);
d2028 1
d2030 13
a2042 2
    const elfcpp::Rela<size, big_endian>& reloc,
    const Sized_relobj_file<size, big_endian>* object) const
d2044 1
a2044 1
  Glink_sym_ent ent(locsym_index, reloc, object);
a2423 1
    Symbol_table* symtab,
d2432 3
a2434 2
	this->make_iplt_section(layout, symtab);
      this->iplt_->add_ifunc_entry(gsym);
d2440 2
a2441 1
      this->plt_->add_entry(gsym);
a2442 1
  this->glink_->add_entry(gsym, reloc, object);
a2450 1
    Symbol_table* symtab,
d2455 1
a2455 1
    this->make_iplt_section(layout, symtab);
d2457 2
a2458 2
  this->iplt_->add_local_ifunc_entry(relobj, r_sym);
  this->glink_->add_entry(r_sym, reloc, relobj);
d2718 5
d2808 1
a2808 1
    target->make_local_ifunc_plt_entry(layout, symtab, reloc, object);
d2865 2
a2866 1
      if (parameters->options().output_is_position_independent())
d2883 1
a2883 1
					   reloc.get_r_addend(), is_ifunc);
d2899 1
d2973 1
a2973 1
					 got, off, 0, is_ifunc);
d3109 1
a3109 1
    target->make_plt_entry(layout, symtab, gsym, reloc, object);
d3179 1
a3179 1
	    target->make_plt_entry(layout, symtab, gsym, reloc, 0);
d3190 2
a3191 1
	if (needs_dynamic_reloc<size>(gsym, Scan::get_reference_flags(r_type)))
d3235 1
a3235 1
	target->make_plt_entry(layout, symtab, gsym, reloc, object);
d3691 30
a3727 6
  const Reloc_section* rel_plt = (this->plt_ == NULL
				  ? NULL
				  : this->plt_->rel_plt());
  layout->add_target_dynamic_tags(false, this->plt_, rel_plt,
				  this->rela_dyn_, true, size == 32);

d3729 1
a3729 1
  if (size == 32)
d3731 7
a3737 1
      if (this->got_ != NULL)
d3739 6
a3744 3
	  this->got_->finalize_data_size();
	  odyn->add_section_plus_offset(elfcpp::DT_PPC_GOT,
					this->got_, this->got_->g_o_t());
d3746 1
a3746 4
    }
  else
    {
      if (this->glink_ != NULL)
d3748 9
a3756 5
	  this->glink_->finalize_data_size();
	  odyn->add_section_plus_offset(elfcpp::DT_PPC64_GLINK,
					this->glink_,
					(this->glink_->pltresolve()
					 + this->glink_->pltresolve_size - 32));
d3852 5
a3856 1
      unsigned int glink_index = glink->find_entry(gsym, rela, object);
d3924 1
d3930 3
a3932 3
		  value = psymval->value(object, addend);
		  value = target->symval_for_branch(value, gsym, object,
						    &dest_shndx);
d3939 6
a3944 3
		gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
				       _("call lacks nop, can't restore toc; "
					 "recompile with -fPIC"));
d4186 1
a4186 1
  else
d4192 1
a4192 2
      if (size == 64 || !has_plt_value)
	value = psymval->value(object, addend);
d5054 37
a5090 3
      static const unsigned char zeros[elfcpp::Elf_sizes<32>::rela_size] = {0};
      const elfcpp::Rela<size, big_endian> zero_reloc(zeros);
      unsigned int glink_index = glink->find_entry(gsym, zero_reloc, NULL);
@


1.59
log
@	* object.h (Sized_relobj_file::adjust_local_symbol,
	do_adjust_local_symbol): New functions.
	* object.cc (Sized_relobj_file::do_count_local_symbols): Use the above.
	* powerpc.cc (Powerpc_relobj::do_adjust_local_symbol): New function.
	(Powerpc_relobj::scan_opd_relocs): Warn on unexpected opd relocs
	and irregular opd entry spacing.
	(Powerpc_relobj::do_read_relocs): Add opd size checks.
	(Global_symbol_visitor_opd): New functor.
	(Target_powerpc::do_finalize_sections): Omit global symbols defined
	on deleted opd entries.
@
text
@d258 1
a258 1
      got_(NULL), plt_(NULL), glink_(NULL), rela_dyn_(NULL),
d392 8
d529 4
d647 3
d652 1
a652 1
  make_plt_entry(Layout*, Symbol*,
d654 7
a660 1
		 const Sized_relobj<size, big_endian>* object);
d710 2
d1526 10
a1535 1
  Output_data_plt_powerpc(Layout*, Target_powerpc<size, big_endian>*);
d1541 6
d1548 1
a1548 1
  const Reloc_section*
d1558 1
a1558 1
    return ((this->current_data_size() - initial_plt_entry_size)
d1563 1
a1563 1
  static unsigned int
d1565 1
a1565 1
  { return initial_plt_entry_size; }
d1582 1
a1582 1
  { mapfile->print_output_data(this, _("** PLT")); }
a1586 2
  // The size of the first reserved entry.
  static const int initial_plt_entry_size = size == 32 ? 0 : 24;
d1596 4
d1602 1
a1602 1
// Create the PLT section.
d1605 2
a1606 5
Output_data_plt_powerpc<size, big_endian>::Output_data_plt_powerpc(
    Layout* layout,
    Target_powerpc<size, big_endian>* targ)
  : Output_section_data_build(size == 32 ? 4 : 8),
    targ_(targ)
d1608 12
a1619 4
  this->rel_ = new Reloc_section(false);
  layout->add_output_section_data(".rela.plt", elfcpp::SHT_RELA,
				  elfcpp::SHF_ALLOC, this->rel_,
				  ORDER_DYNAMIC_PLT_RELOCS, false);
d1622 1
a1622 1
// Add an entry to the PLT.
d1626 1
a1626 1
Output_data_plt_powerpc<size, big_endian>::add_entry(Symbol* gsym)
d1631 11
d1643 15
a1657 5
      if (off == 0)
	off += initial_plt_entry_size;
      gsym->set_plt_offset(off);
      gsym->set_needs_dynsym_entry();
      this->rel_->add_global(gsym, elfcpp::R_POWERPC_JMP_SLOT, this, off, 0);
d1729 1
a1729 1
      // The address the .glink branch table
d1762 8
a1769 1
      this->plt_ = new Output_data_plt_powerpc<size, big_endian>(layout, this);
d1783 33
d1829 5
a1833 1
	    const Sized_relobj<size, big_endian>*);
d1837 5
a1841 1
	     const Sized_relobj<size, big_endian>*) const;
d1879 2
a1880 2
		  const Sized_relobj<size, big_endian>* object)
      : sym_(sym), addend_(0), object_(0)
d1889 1
a1889 1
	  if (this->addend_ != 0)
d1894 13
d1911 2
a1912 1
	      && this->addend_ == that.addend_);
d1916 3
a1918 2
    unsigned int addend_;
    const Sized_relobj<size, big_endian>* object_;
d1928 2
a1929 1
	      ^ ent.addend_);
d1963 1
a1963 1
    const Sized_relobj<size, big_endian>* object)
d1971 12
d1987 1
a1987 1
    const Sized_relobj<size, big_endian>* object) const
d1996 13
d2083 1
d2085 1
d2100 25
a2124 1
	  Address plt_addr = plt_base + g->first.sym_->plt_offset();
d2217 25
a2241 3
	  Address plt_addr = plt_base + g->first.sym_->plt_offset();
	  Address got_addr;
	  const Address invalid_address = static_cast<Address>(-1);
d2246 1
d2249 1
a2249 1
	      if (object != NULL)
d2382 1
d2385 1
a2385 1
    const Sized_relobj<size, big_endian>* object)
d2387 15
a2401 2
  if (this->plt_ == NULL)
    this->make_plt_section(layout);
d2403 1
a2403 1
  this->plt_->add_entry(gsym);
d2405 13
a2417 1
  this->glink_->add_entry(gsym, reloc, object);
d2428 4
a2431 1
  return this->plt_->entry_count();
d2440 1
a2440 1
  return Output_data_plt_powerpc<size, big_endian>::first_plt_entry_offset();
d2507 1
d2527 2
d2668 63
d2744 1
a2744 1
    const elfcpp::Sym<size, big_endian>& /* lsym */,
d2759 5
d2827 7
a2833 2
	      rela_dyn->add_local_relative(object, r_sym,
					   elfcpp::R_POWERPC_RELATIVE,
d2836 1
a2836 1
					   reloc.get_r_addend(), false);
d2902 8
a2909 3
	// If we are generating a shared object, we need to add a
	// dynamic relocation for this symbol's GOT entry.
	if (parameters->options().output_is_position_independent())
d2911 9
a2919 1
	    if (!object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD))
d2921 2
a2922 8
		Reloc_section* rela_dyn = target->rela_dyn_section(layout);
		unsigned int off;

		off = got->add_constant(0);
		object->set_local_got_offset(r_sym, GOT_TYPE_STANDARD, off);
		rela_dyn->add_local_relative(object, r_sym,
					     elfcpp::R_POWERPC_RELATIVE,
					     got, off, 0, false);
d2924 2
a2926 2
	else
	  got->add_local(object, r_sym, GOT_TYPE_STANDARD);
d3058 5
d3131 1
a3131 1
	    target->make_plt_entry(layout, gsym, reloc, 0);
d3135 1
a3135 1
	    // the PLT entry.
d3137 2
a3138 1
		&& gsym->is_from_dynobj() && !parameters->options().shared())
d3152 2
a3153 1
			 || data_shndx == ppc_object->opd_shndx()))
d3156 9
a3164 4
		rela_dyn->add_global_relative(gsym, elfcpp::R_POWERPC_RELATIVE,
					      output_section, object,
					      data_shndx, reloc.get_r_offset(),
					      reloc.get_r_addend(), false);
d3186 1
a3186 1
	target->make_plt_entry(layout, gsym, reloc, object);
a3259 2
	  got->add_global(gsym, GOT_TYPE_STANDARD);
	else
d3261 12
a3272 2
	    // If this symbol is not fully resolved, we need to add a
	    // dynamic relocation for it.
d3274 14
a3287 6
	    if (gsym->is_from_dynobj()
		|| gsym->is_undefined()
		|| gsym->is_preemptible())
	      got->add_global_with_rel(gsym, GOT_TYPE_STANDARD, rela_dyn,
				       elfcpp::R_POWERPC_GLOB_DAT);
	    else if (!gsym->has_got_offset(GOT_TYPE_STANDARD))
d3289 2
a3290 5
		unsigned int off = got->add_constant(0);

		gsym->set_got_offset(GOT_TYPE_STANDARD, off);
		rela_dyn->add_global_relative(gsym, elfcpp::R_POWERPC_RELATIVE,
					      got, off, 0, false);
d3762 1
d3764 2
a3765 1
      && use_plt_offset<size>(gsym, Scan::get_reference_flags(r_type)))
d4963 5
a4967 1
      return this->plt_section()->address() + gsym->plt_offset();
@


1.58
log
@	* target-reloc.h (scan_relocs): Call scan.local for relocs
	against symbols in discarded sections.  Pass is_discarded
	param.
	* arm.cc, * i386.cc, * sparc.cc, * x86_64.cc (Target_*::Scan::local):
	Add is_discarded param.
	* powerpc (Target_powerpc::Scan::local): Likewise.  Use
	is_discarded to flag opd entry as discarded.  Don't emit dyn
	relocs on such entries.
	(Target_powerpc::Scan::global): Similarly detect and handle
	such opd entries.
	(Powerpc_relobj): Replace opd_ent_shndx_ and opd_ent_off_ with
	opd_ent_.  Update all uses.
	(Powerpc_relobj::get_opd_discard, set_opd_discard): New functions.
	(Target_powerpc::relocate_section): Zero out discarded opd
	entry relocs.
@
text
@d177 16
d1202 3
d1231 19
d1252 10
d1278 8
a1285 3
	      this->init_opd(this->section_size(this->opd_shndx()));
	      this->scan_opd_relocs(p->reloc_count, p->contents->data(),
				    rd->local_symbols->data());
d3260 32
d3299 1
a3299 1
    Symbol_table*)
d3301 6
@


1.57
log
@	* output.h (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::add_local_pair_with_rel): Remove second
	reloc param.  Expand comment.
	(Output_data_got::Got_entry): Rename use_plt_offset_ to
	use_plt_or_tls_offset_, similarly for constructor param.
	(Output_data_got::Got_entry::write): Add got_index param.
	* output.cc (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::Got_entry::write): Handle tls symbols
	with use_plt_or_tls_offset_ set specially.
	(Output_data_got::add_local_pair_with_rel): Only one reloc.
	(Output_data_got::do_write): Replace iterator with index, pass
	index to entry write function.
	* target.h (Target::tls_offset_for_local, tls_offset_for_global,
	do_tls_offset_for_local, do_tls_offset_for_global): New functions.
	* arm.cc (Target_arm::Scan::local): Update add_local_pair_with_rel
	call.
	* i386.cc (Target_i386::Scan::local): Likewise.
	* sparc.cc (Target_sparc::Scan::local): Likewise.
	* x86_64.cc (Target_x86_64::Scan::local): Likewise.
	* powerpc.cc (Target_powerpc::do_tls_offset_for_local,
	do_tls_offset_for_global): New functions.
	(Target_powerpc::Scan::local): Correct TLS relocations and got
	entry values.
	(Target_powerpc::Scan::global): Don't emit unnecessary
	dynamic relocations on TLS GOT entries.
@
text
@d68 1
a68 2
      special_(0), opd_ent_shndx_(), opd_ent_off_(), access_from_map_(),
      opd_valid_(false)
d99 1
a99 2
    this->opd_ent_shndx_.resize(count);
    this->opd_ent_off_.reserve(count);
d107 2
a108 2
    gold_assert(ndx < this->opd_ent_shndx_.size());
    gold_assert(this->opd_ent_shndx_[ndx] != 0);
d110 2
a111 2
      *value = this->opd_ent_off_[ndx];
    return this->opd_ent_shndx_[ndx];
d119 21
a139 3
    gold_assert(ndx < this->opd_ent_shndx_.size());
    this->opd_ent_shndx_[ndx] = shndx;
    this->opd_ent_off_[ndx] = value;
d184 17
a200 10
  // Return index into opd_ent_shndx or opd_ent_off array for .opd entry
  // at OFF.  .opd entries are 24 bytes long, but they can be spaced
  // 16 bytes apart when the language doesn't use the last 8-byte
  // word, the environment pointer.  Thus dividing the entry section
  // offset by 16 will give an index into opd_ent_shndx_ and
  // opd_ent_off_ that works for either layout of .opd.  (It leaves
  // some elements of the vectors unused when .opd entries are spaced
  // 24 bytes apart, but we don't know the spacing until relocations
  // are processed, and in any case it is possible for an object to
  // have some entries spaced 16 bytes apart and others 24 bytes apart.)
d207 8
d217 1
a217 1
  // relocation on this word.  The following two vectors record the
d219 2
a220 2
  std::vector<unsigned int> opd_ent_shndx_;
  std::vector<Offset> opd_ent_off_;
d222 2
a223 2
  // gc_process_relocs for another object, before the opd_ent vectors
  // are valid for this object.
a224 6
  // Set at the start of gc_process_relocs, when we know opd_ent
  // vectors are valid.  The flag could be made atomic and set in
  // do_read_relocs with memory_order_release and then tested with
  // memory_order_acquire, potentially resulting in fewer entries in
  // access_from_map_.
  bool opd_valid_;
d441 2
d456 2
a457 1
	  const elfcpp::Sym<size, big_endian>& lsym);
d2392 2
a2393 1
    const elfcpp::Sym<size, big_endian>& /* lsym */)
d2398 9
d2423 6
d2430 1
d2434 2
a2435 3
						  object, data_shndx,
						  reloc.get_r_offset(),
						  ppc_object->toc_base_offset());
d2705 6
d2719 1
a2719 2
						  object, data_shndx,
						  reloc.get_r_offset(),
d2726 9
d4099 37
d4148 3
@


1.56
log
@	* target.h (Target::gc_mark_symbol, do_gc_mark_symbol): New functions.
	(Sized_target::gc_add_reference, do_gc_add_reference): New functions.
	* gc.h (gc_process_relocs): Call target gc_add_reference.
	* gold.cc (queue_middle_tasks): Use gc_mark_symbol on start sym.
	* symtab.cc (Symbol_table::gc_mark_undef_symbols): Use gc_mark_symbol.
	(Symbol_table::gc_mark_symbol): Call target gc_mark_symbol. Remove
	unnecessary cast.
	* powerpc.cc (Powerpc_relobj::get_opd_ent): Rearrange parameters
	to cater for when we don't need code offset.  Update use.
	(Powerpc_relobj::access_from_map_, opd_valid_): New vars.
	(Powerpc_relobj::access_from_map, add_reference, opd_valid,
	set_opd_valid): New functions.
	(Target_powerpc::do_gc_add_reference): New function.
	(Target_powerpc::gc_process_relocs): Call gc()->add_reference on
	stashed refs.
	(Target_powerpc::do_gc_mark_symbol): New function.
@
text
@d273 12
d2364 1
a2364 1
    const elfcpp::Sym<size, big_endian>& lsym)
d2538 3
a2540 10
	    unsigned int shndx = lsym.get_st_shndx();
	    bool is_ordinary;
	    shndx = object->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
	    gold_assert(is_ordinary);
	    got->add_local_pair_with_rel(object, r_sym,
					 shndx,
					 GOT_TYPE_TLSGD,
					 target->rela_dyn_section(layout),
					 elfcpp::R_POWERPC_DTPMOD,
					 elfcpp::R_POWERPC_DTPREL);
d2582 1
a2582 3
	got->add_local_with_rel(object, r_sym, GOT_TYPE_DTPREL,
				target->rela_dyn_section(layout),
				elfcpp::R_POWERPC_DTPREL);
d2597 1
a2597 3
	    got->add_local_with_rel(object, r_sym, GOT_TYPE_TPREL,
				    target->rela_dyn_section(layout),
				    elfcpp::R_POWERPC_TPREL);
d2917 9
a2925 3
	got->add_global_with_rel(gsym, GOT_TYPE_DTPREL,
				 target->rela_dyn_section(layout),
				 elfcpp::R_POWERPC_DTPREL);
d2940 9
a2948 3
	    got->add_global_with_rel(gsym, GOT_TYPE_TPREL,
				     target->rela_dyn_section(layout),
				     elfcpp::R_POWERPC_TPREL);
d4437 63
@


1.55
log
@	* powerpc.cc (Powerpc_relocate_functions): Upcase enum values,
	update all uses and lose "enum" when using type.
@
text
@d62 2
d68 2
a69 1
      special_(0), opd_ent_shndx_(), opd_ent_off_()
d105 2
a106 2
  void
  get_opd_ent(Address r_off, unsigned int* shndx, Address* value) const
d111 3
a113 2
    *shndx = this->opd_ent_shndx_[ndx];
    *value = this->opd_ent_off_[ndx];
d126 23
d190 10
d380 18
d2971 27
d3014 59
d3208 1
a3208 1
      symobj->get_opd_ent(value - opd_addr, dest_shndx, &sec_off);
@


1.54
log
@	* powerpc.cc (Powerpc_relobj::get_opd_ent): Make const.
	(Powerpc_relocate_functions::Status): New typedef.
	(Target_powerpc::Scan::get_reference_flags): Handle more relocs.
	(Target_powerpc::Scan::local): Handle REL64.
	(Target_powerpc::Scan::global): Likewise, and dynamic relocs
	for REL32 and REL64.
	(Target_powerpc::symval_for_branch): New function, extracted from..
	(Target_powerpc::Relocate::relocate): ..here.  Correct plt call
	checks.  Report overflow errors.
@
text
@d848 1
a848 1
  enum overflow_check
d850 3
a852 3
    check_none,
    check_signed,
    check_bitfield
d855 1
a855 1
  typedef enum overflow_status
d857 3
a859 3
    status_ok,
    status_overflow
  } Status;
d887 2
a888 2
  static inline enum overflow_status
  overflowed(Address value, enum overflow_check overflow)
d890 1
a890 1
    if (overflow == check_signed)
d893 1
a893 1
	  return status_overflow;
d895 1
a895 1
    else if (overflow == check_bitfield)
d898 1
a898 1
	  return status_overflow;
d900 1
a900 1
    return status_ok;
d905 2
a906 2
  static inline enum overflow_status
  rela(unsigned char* view, Address value, enum overflow_check overflow)
d915 1
a915 1
  static inline enum overflow_status
d920 1
a920 1
       enum overflow_check overflow)
d934 2
a935 2
  static inline enum overflow_status
  rela_ua(unsigned char* view, Address value, enum overflow_check overflow)
d942 1
a942 1
  static inline enum overflow_status
d947 1
a947 1
	  enum overflow_check overflow)
d963 1
a963 1
  { This::template rela<64>(view, value, check_none); }
d968 1
a968 1
  { This::template rela_ua<64>(view, value, check_none); }
d971 2
a972 2
  static inline enum overflow_status
  addr32(unsigned char* view, Address value, enum overflow_check overflow)
d976 2
a977 2
  static inline enum overflow_status
  addr32_u(unsigned char* view, Address value, enum overflow_check overflow)
d981 2
a982 2
  static inline enum overflow_status
  addr24(unsigned char* view, Address value, enum overflow_check overflow)
d984 3
a986 4
    enum overflow_status stat
      = This::template rela<32>(view, 0, 0x03fffffc, value, overflow);
    if (overflow != check_none && (value & 3) != 0)
      stat = status_overflow;
d991 2
a992 2
  static inline enum overflow_status
  addr16(unsigned char* view, Address value, enum overflow_check overflow)
d996 2
a997 2
  static inline enum overflow_status
  addr16_u(unsigned char* view, Address value, enum overflow_check overflow)
d1001 2
a1002 2
  static inline enum overflow_status
  addr16_ds(unsigned char* view, Address value, enum overflow_check overflow)
d1004 3
a1006 4
    enum overflow_status stat
      = This::template rela<16>(view, 0, 0xfffc, value, overflow);
    if (overflow != check_none && (value & 3) != 0)
      stat = status_overflow;
d1013 1
a1013 1
  { This::template rela<16>(view, 16, 0xffff, value, check_none); }
d1023 1
a1023 1
  { This::template rela<16>(view, 32, 0xffff, value, check_none); }
d1033 1
a1033 1
  { This::template rela<16>(view, 48, 0xffff, value, check_none); }
d1041 2
a1042 2
  static inline enum overflow_status
  addr14(unsigned char* view, Address value, enum overflow_check overflow)
d1044 3
a1046 4
    enum overflow_status stat
      = This::template rela<32>(view, 0, 0xfffc, value, overflow);
    if (overflow != check_none && (value & 3) != 0)
      stat = status_overflow;
d3579 1
a3579 1
  enum Reloc::overflow_check overflow = Reloc::check_none;
d3585 1
a3585 1
	overflow = Reloc::check_bitfield;
d3590 1
a3590 1
	overflow = Reloc::check_signed;
d3600 1
a3600 1
      overflow = Reloc::check_bitfield;
d3624 1
a3624 1
      overflow = Reloc::check_signed;
d3629 1
a3629 1
    = Powerpc_relocate_functions<size, big_endian>::status_ok;
d3859 1
a3859 1
  if (status != Powerpc_relocate_functions<size, big_endian>::status_ok)
@


1.53
log
@	* object.h (Sized_relobj_file::emit_relocs): Delete.
	(Sized_relobj_file::emit_relocs_reltype): Delete.
	* reloc.cc (Sized_relobj_file::do_relocate_sections): Call target
	relocate_relocs for --emit-relocs.
	(Sized_relobj_file::emit_relocs, emit_relocs_reltype): Delete.
	* output.h: Update comment.
	(Output_segment::first_section): New function.
	(Output_segment::first_section_load_address): Use first_section.
	* output.cc (Output_segment::first_section): New function extracted..
	(Output_segment::first_section_load_address): ..from here.  Delete.
	* target-reloc.h (relocate_for_relocatable): Rename to relocate_relocs.
	* target.h (Sized_target::relocate_for_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise, and
	adjust call to target.h function.
	* i386.cc (Target_i386): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	(Target_powerpc::Scan::local, global): Handle R_POWERPC_TLS.  Ensure
	first tls section has section symbol for optimised local dynamic
	output relocs.
	(Target_powerpc::Relocate::relocate): Correct local dynamic value.
	(Target_powerpc::relocate_relocs): Adjust relocs emitted for
	optimised tls code.
	* testsuite/testfile.cc (Target_test::relocate_for_relocatable):
	Rename to relocate_relocs.  Update error message.
@
text
@d103 1
a103 1
  get_opd_ent(Address r_off, unsigned int* shndx, Address* value)
d414 5
d855 1
a855 1
  enum overflow_status
d859 1
a859 1
  };
d2198 1
d2206 1
d2208 1
d2210 9
d2220 4
a2235 15
	case elfcpp::R_PPC64_TPREL16_LO_DS:
	case elfcpp::R_PPC64_TPREL16_DS:
	case elfcpp::R_POWERPC_TPREL16:
	case elfcpp::R_POWERPC_TPREL16_LO:
	case elfcpp::R_POWERPC_TPREL16_HI:
	case elfcpp::R_POWERPC_TPREL16_HA:
	case elfcpp::R_PPC64_TPREL16_HIGHER:
	case elfcpp::R_PPC64_TPREL16_HIGHEST:
	case elfcpp::R_PPC64_TPREL16_HIGHERA:
	case elfcpp::R_PPC64_TPREL16_HIGHESTA:
	case elfcpp::R_PPC64_ADDR16_LO_DS:
	case elfcpp::R_POWERPC_ADDR16_LO:
	case elfcpp::R_POWERPC_ADDR16_HI:
	case elfcpp::R_POWERPC_ADDR16_HA:
	case elfcpp::R_POWERPC_ADDR30:
d2237 1
a2237 3
	case elfcpp::R_POWERPC_UADDR32:
	case elfcpp::R_POWERPC_ADDR16:
	case elfcpp::R_POWERPC_UADDR16:
d2239 1
a2243 3
	case elfcpp::R_POWERPC_ADDR14_BRTAKEN:
	case elfcpp::R_POWERPC_ADDR14_BRNTAKEN:
	case elfcpp::R_POWERPC_REL32:
d2245 7
d2263 6
d2379 1
d2689 28
a2716 26
      {
	if (gsym->needs_plt_entry()
	    || (!gsym->final_value_is_known()
		 && !(gsym->is_defined()
		      && !gsym->is_from_dynobj()
		      && !gsym->is_preemptible())))
	  target->make_plt_entry(layout, gsym, reloc, object);
	// Make a dynamic relocation if necessary.
	if (needs_dynamic_reloc<size>(gsym, Scan::get_reference_flags(r_type)))
	  {
	    if (gsym->may_need_copy_reloc())
	      {
		target->copy_reloc(symtab, layout, object,
				   data_shndx, output_section, gsym,
				   reloc);
	      }
	    else
	      {
		Reloc_section* rela_dyn = target->rela_dyn_section(layout);
		check_non_pic(object, r_type);
		rela_dyn->add_global(gsym, r_type, output_section, object,
				     data_shndx, reloc.get_r_offset(),
				     reloc.get_r_addend());
	      }
	  }
      }
a2718 1
    case elfcpp::R_POWERPC_REL32:
d3042 37
d3117 2
a3118 2
  const Powerpc_relobj<size, big_endian>* const object
    = static_cast<const Powerpc_relobj<size, big_endian>*>(relinfo->object);
d3168 1
d3170 3
a3172 2
	      if (insn2 == nop
		  || insn2 == cror_15_15_15 || insn2 == cror_31_31_31)
d3179 33
a3211 2
	    gold_error_at_location(relinfo, relnum, rela.get_r_offset(),
				   _("call lacks nop, can't restore toc"));
d3455 1
d3461 1
a3461 23
	{
	  // If the symbol is defined in an opd section, ie. is a function
	  // descriptor, use the function descriptor code entry address
	  Powerpc_relobj<size, big_endian>* symobj = const_cast
	    <Powerpc_relobj<size, big_endian>*>(object);
	  if (gsym != NULL)
	    symobj = static_cast
	      <Powerpc_relobj<size, big_endian>*>(gsym->object());
	  unsigned int shndx = symobj->opd_shndx();
	  Address opd_addr = symobj->get_output_section_offset(shndx);
	  gold_assert(opd_addr != invalid_address);
	  opd_addr += symobj->output_section(shndx)->address();
	  if (value >= opd_addr
	      && value < opd_addr + symobj->section_size(shndx))
	    {
	      Address sec_off;
	      symobj->get_opd_ent(value - opd_addr, &shndx, &sec_off);
	      Address sec_addr = symobj->get_output_section_offset(shndx);
	      gold_assert(sec_addr != invalid_address);
	      sec_addr += symobj->output_section(shndx)->address();
	      value = sec_addr + sec_off;
	    }
	}
d3631 2
d3653 1
a3653 1
	Reloc::addr32(view, value, overflow);
d3662 1
a3662 1
      Reloc::addr32(view, value, overflow);
d3666 1
a3666 1
      Reloc::addr32_u(view, value, overflow);
d3673 1
a3673 1
      Reloc::addr24(view, value, overflow);
d3680 1
a3680 1
	  Reloc::addr16_ds(view, value, overflow);
d3703 1
a3703 1
      Reloc::addr16(view, value, overflow);
d3707 1
a3707 1
      Reloc::addr16_u(view, value, overflow);
d3792 1
a3792 1
      Reloc::addr16_ds(view, value, overflow);
d3801 1
a3801 1
      Reloc::addr14(view, value, overflow);
d3862 3
@


1.52
log
@* powerpc.cc (do_make_elf_object): Allow ET_EXEC files with
--just-symbols.
@
text
@d264 1
a264 1
  // Relocate a section during a relocatable link.
d266 12
a277 12
  relocate_for_relocatable(const Relocate_info<size, big_endian>*,
			   unsigned int sh_type,
			   const unsigned char* prelocs,
			   size_t reloc_count,
			   Output_section* output_section,
			   off_t offset_in_output_section,
			   const Relocatable_relocs*,
			   unsigned char*,
			   Address view_address,
			   section_size_type,
			   unsigned char* reloc_view,
			   section_size_type reloc_view_size);
d2297 1
d2489 6
d2583 1
d2828 6
d3218 1
a3218 1
	      value = relinfo->layout->tls_segment()->vaddr() + dtp_offset;
d3344 1
a3344 1
	  value = relinfo->layout->tls_segment()->vaddr() + dtp_offset;
d3900 1
a3900 1
// Relocate a section during a relocatable link.
d3908 1
a3908 1
Target_powerpc<size, big_endian>::relocate_for_relocatable(
d3943 1
a3943 1

d3953 1
d3955 15
a3969 2
      const unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);
      const unsigned int r_type = elfcpp::elf_r_type<size>(r_info);
a3971 2

      unsigned int new_symndx;
d3978 1
a3978 3
	      if (r_sym == 0)
		new_symndx = 0;
	      else
d3980 2
a3981 2
		  new_symndx = object->symtab_index(r_sym);
		  gold_assert(new_symndx != -1U);
d3999 1
a3999 1
		new_symndx = os->symtab_index();
d4009 1
a4009 1
	  const Symbol* gsym = object->global_symbol(r_sym);
d4015 1
a4015 1
	  new_symndx = gsym->symtab_index();
a4019 3

      Address offset = reloc.get_r_offset();
      Address new_offset;
d4021 1
a4021 1
	new_offset = offset + offset_in_output_section;
d4030 1
a4030 1
	  new_offset = new_sot_offset;
d4036 1
a4036 3
      // FIXME: Arrange to call this function for --emit-relocs too,
      // so that we can make emitted relocs match edited TLS code.
      if (0 && !parameters->options().relocatable())
d4038 1
a4038 1
	  new_offset += view_address;
d4040 1
a4040 1
	    new_offset -= offset_in_output_section;
a4042 3
      reloc_write.put_r_offset(new_offset);
      reloc_write.put_r_info(elfcpp::elf_r_info<size>(new_symndx, r_type));

a4043 4
      typename elfcpp::Elf_types<size>::Elf_Swxword addend;
      addend = Reloc_types<elfcpp::SHT_RELA, size, big_endian>::
	get_reloc_addend(&reloc);

d4048 1
a4048 1
	  const Symbol_value<size>* psymval = object->local_symbol(r_sym);
d4059 130
a4188 2
      Reloc_types<elfcpp::SHT_RELA, size, big_endian>::
	set_reloc_addend(&reloc_write, addend);
@


1.51
log
@	* powerpc.cc (Powerpc_relobj): Add and use Address typedef.
	(Powerpc_relobj::toc_base_offset): New stub function.
	(Target_powerpc): Add tp_offset, dtp_offset.  Rename
	got_mod_index_offset to tlsld_got_offset.  Update all refs.
	(Target_powerpc::Relocate::enum skip_tls): New.
	(Target_powerpc::call_tls_get_addr_): New var.
	(Target_powerpc::is_branch_reloc): Move to file scope.
	(Target_powerpc::relocate_tls, optimize_tls_reloc): Delete.
	(Target_powerpc::optimize_tls_gd, optimize_tls_ld, optimize_tls_ie):
	New functions.
	(Target_powerpc::enum Got_type): Delete old values, add new ones.
	(powerpc_info): Correct common_pagesize for ppc64.
	(at_tls_transform, needs_dynamic_reloc, use_plt_offset): New functions.
	(Powerpc_relocate_functions): Add overflow check enums and functions.
	Add non-shift version of rela, rela_ua.  Delete all rel public
	functions.  Delete addr16_lo.  Add addr64, addr64_u, addr32,
	addr32_u, addr24, addr16_u, addr16_hi2, addr16_ha2, addr16_hi3,
	addr16_ha3, addr14 functions.
	(Output_data_got_powerpc::add_constant_pair): New function.
	(Output_data_got_powerpc::got_base_offset): Likewise.
	(Output_data_got_powerpc::do_write): Correct 64-bit got header.
	(instruction constants): Sort, add some more.
	(Output_data_glink::do_write): Add and use Address typedef.  Use
	object->toc_base_offset() stub for 64-bit.
	(Target_powerpc::tlsld_got_offset): Use add_constant_pair.
	(Target_powerpc::Scan::get_reference_flags): Handle more relocs.
	(Target_powerpc::Scan::local, global): Emit relative dynamic reloc
	for R_PPC64_TOC.  Handle more relocs.  Generate got entries for TLS.
	Always treat .opd relocs as against locally defined symbol.
	Correct condition for RELATIVE relocs.
	(Target_powerpc::do_finalize_sections): Test for NULL sections.
	(Target_powerpc::Relocate::relocate): Use plt call stub as value
	for 32-bit syms with a plt entry.  Correct ppc64 toc base
	calculations.  Handle TLS relocs, and more.  Add overflow
	checking and adjust for Powerpc_relocate_functions changes.
	(Target_powerpc::relocate_for_relocatable): Handle zero r_sym.
	Reinstate --emit-relocs code with FIXME.
@
text
@d1152 4
a1155 1
  if (et == elfcpp::ET_REL)
@


1.50
log
@	* powerpc.cc: Formatting and white space.
	(Powerpc_relobj): Rename got2_section_ to special_.
	Add opd_ent_shndx_ and opd_ent_off_ vectors.
	(Powerpc_relobj::opd_shndx, init_opd, get_opd_ent, set_opd_ent,
	scan_opd_relocs, do_read_relocs, opd_ent_ndx): New functions.
	(Target_powerpc): Add Address typedef and invalid_address.  Use
	throughout.
	(Target_powerpc::is_branch_reloc): New function.
	(Powerpc_relocate_functions): Add Address typedef, use throughout.
	(Powerpc_relocate_functions:rela, rela_ua): Correct type used
	for dst_mask, value and addend.
	(Powerpc_relobj::do_find_special_sections): Find .opd for 64-bit.
	(ld_2_1, cror_15_15_15, cror_31_31_31): New insn constants.
	(Output_data_glink::do_write): Correct toc base.  Don't try to use
	uint16_t for 24-bit offset.  Use get_output_section_offset and
	check return.
	(Target_powerpc::Scan::local): Handle more relocs.
	(Target_powerpc::do_finalize_sections): Set up DT_PPC64_GLINK.
	(Target_powerpc::Relocate::relocate): Correct toc base calculation.
	Plug in toc restoring insn after plt calls.  Translate branches
	to function descriptor symbols to corresponding entry point.
	(Target_powerpc::relocate_for_relocatable): Check return from
	get_output_section_offset.
	* symtab.h: Comment typo.
@
text
@d60 1
d103 1
a103 3
  get_opd_ent(typename elfcpp::Elf_types<size>::Elf_Addr r_off,
	      unsigned int* shndx,
	      typename elfcpp::Elf_types<size>::Elf_Addr* value)
d114 1
a114 3
  set_opd_ent(typename elfcpp::Elf_types<size>::Elf_Addr r_off,
	      unsigned int shndx,
	      typename elfcpp::Elf_types<size>::Elf_Addr value)
d134 6
d172 1
d174 3
d182 1
a182 1
      dynbss_(NULL), got_mod_index_offset_(-1U)
d274 1
a274 1
			   Address,
a317 1
 protected:
d418 24
d454 3
a456 24
    inline bool
    is_branch_reloc(unsigned int r_type) const
    {
      return (r_type == elfcpp::R_POWERPC_REL24
	      || r_type == elfcpp::R_POWERPC_REL14
	      || r_type == elfcpp::R_POWERPC_REL14_BRTAKEN
	      || r_type == elfcpp::R_POWERPC_REL14_BRNTAKEN
	      || r_type == elfcpp::R_POWERPC_ADDR24
	      || r_type == elfcpp::R_POWERPC_ADDR14
	      || r_type == elfcpp::R_POWERPC_ADDR14_BRTAKEN
	      || r_type == elfcpp::R_POWERPC_ADDR14_BRNTAKEN);
    }

   private:
    // Do a TLS relocation.
    inline void
    relocate_tls(const Relocate_info<size, big_endian>*,
		 Target_powerpc* target,
		 size_t relnum, const elfcpp::Rela<size, big_endian>&,
		 unsigned int r_type, const Sized_symbol<size>*,
		 const Symbol_value<size>*,
		 unsigned char*,
		 typename elfcpp::Elf_types<size>::Elf_Addr,
		 section_size_type);
d472 34
a505 4
  // Adjust TLS relocation type based on the options and whether this
  // is a local symbol.
  static tls::Tls_optimization
  optimize_tls_reloc(bool is_final, int r_type);
d525 1
a525 1
  // Create a GOT entry for the TLS module index.
d527 8
a534 2
  got_mod_index_entry(Symbol_table* symtab, Layout* layout,
		      Sized_relobj_file<size, big_endian>* object);
d563 4
a566 3
    GOT_TYPE_STANDARD = 0,      // GOT entry for a regular symbol
    GOT_TYPE_TLS_OFFSET = 1,    // GOT entry for TLS offset
    GOT_TYPE_TLS_PAIR = 2,      // GOT entry for TLS module/offset pair
d581 2
a582 2
  // Offset of the GOT entry for the TLS module index;
  unsigned int got_mod_index_offset_;
d652 1
a652 1
  8 * 1024,		// common_pagesize (overridable by -z common-page-size)
d678 1
a678 1
  8 * 1024,		// common_pagesize (overridable by -z common-page-size)
d689 150
d842 14
a857 1
  typedef Relocate_functions<size, big_endian> This_reloc;
d860 38
d900 11
a910 1
  static inline void
d915 1
a915 1
       Address addend)
d920 1
a920 1
    Valtype reloc = (value + addend) >> right_shift;
d924 1
d929 9
a937 1
  static inline void
d942 1
a942 1
	  Address addend)
d946 2
a947 3
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<valsize, big_endian>::readval(wv);
    Valtype reloc = (value + addend) >> right_shift;
d950 2
a951 1
    elfcpp::Swap_unaligned<valsize, big_endian>::writeval(wv, val | reloc);
d955 1
a955 1
  // R_POWERPC_REL32: (Symbol + Addend - Address)
d957 2
a958 2
  rel32(unsigned char* view, Address value, Address addend, Address address)
  { This_reloc::pcrela32(view, value, addend, address); }
d960 1
a960 1
  // R_POWERPC_REL24: (Symbol + Addend - Address) & 0x3fffffc
d962 2
a963 2
  rel24(unsigned char* view, Address value, Address addend, Address address)
  { This::template rela<32>(view, 0, 0x03fffffc, value - address, addend); }
d965 20
a984 4
  // R_POWERPC_REL14: (Symbol + Addend - Address) & 0xfffc
  static inline void
  rel14(unsigned char* view, Address value, Address addend, Address address)
  { This::template rela<32>(view, 0, 0xfffc, value - address, addend); }
d987 8
a994 3
  static inline void
  addr16(unsigned char* view, Address value, Address addend)
  { This_reloc::rela16(view, value, addend); }
d997 9
a1005 8
  static inline void
  addr16_ds(unsigned char* view, Address value, Address addend)
  { This::template rela<16>(view, 0, 0xfffc, value, addend); }

  // R_POWERPC_ADDR16_LO: (Symbol + Addend) & 0xffff
  static inline void
  addr16_lo(unsigned char* view, Address value, Address addend)
  { This_reloc::rela16(view, value, addend); }
d1009 2
a1010 2
  addr16_hi(unsigned char* view, Address value, Address addend)
  { This::template rela<16>(view, 16, 0xffff, value, addend); }
d1014 2
a1015 2
  addr16_ha(unsigned char* view, Address value, Address addend)
  { This::addr16_hi(view, value + 0x8000, addend); }
d1017 1
a1017 1
  // R_POWERPC_REL16: (Symbol + Addend - Address) & 0xffff
d1019 2
a1020 2
  rel16(unsigned char* view, Address value, Address addend, Address address)
  { This_reloc::pcrela16(view, value, addend, address); }
d1022 1
a1022 1
  // R_POWERPC_REL16_LO: (Symbol + Addend - Address) & 0xffff
d1024 2
a1025 2
  rel16_lo(unsigned char* view, Address value, Address addend, Address address)
  { This_reloc::pcrela16(view, value, addend, address); }
d1027 1
a1027 1
  // R_POWERPC_REL16_HI: ((Symbol + Addend - Address) >> 16) & 0xffff
d1029 2
a1030 2
  rel16_hi(unsigned char* view, Address value, Address addend, Address address)
  { This::template rela<16>(view, 16, 0xffff, value - address, addend); }
d1032 1
a1032 1
  // R_POWERPC_REL16_HA: ((Symbol + Addend + 0x8000 - Address) >> 16) & 0xffff
d1034 13
a1046 2
  rel16_ha(unsigned char* view, Address value, Address addend, Address address)
  { This::rel16_hi(view, value + 0x8000, addend, address); }
d1206 10
a1215 1
  // Value of _GLOBAL_OFFSET_TABLE_
d1222 13
d1253 1
a1253 1
			    : this->address() + 0x8000));
d1444 12
d1459 3
a1461 3
static const uint32_t addi_11_11	= 0x396b0000;
static const uint32_t add_0_11_11	= 0x7c0b5a14;
static const uint32_t add_11_0_11	= 0x7d605a14;
d1466 10
a1477 1
static const uint32_t lwzu_0_12		= 0x840c0000;
d1482 1
d1484 1
d1489 1
d1491 2
a1493 18
static const uint32_t addis_12_2	= 0x3d820000;
static const uint32_t std_2_1		= 0xf8410000;
static const uint32_t ld_2_1		= 0xe8410000;
static const uint32_t ld_11_12		= 0xe96c0000;
static const uint32_t ld_2_12		= 0xe84c0000;
static const uint32_t addi_12_12	= 0x398c0000;
static const uint32_t ld_11_2		= 0xe9620000;
static const uint32_t addi_2_2		= 0x38420000;
static const uint32_t ld_2_2		= 0xe8420000;
static const uint32_t mflr_11		= 0x7d6802a6;
static const uint32_t ld_2_11		= 0xe84b0000;
static const uint32_t mtlr_12		= 0x7d8803a6;
static const uint32_t add_12_2_11	= 0x7d825a14;
static const uint32_t li_0_0		= 0x38000000;
static const uint32_t lis_0_0		= 0x3c000000;
static const uint32_t ori_0_0_0		= 0x60000000;
static const uint32_t cror_15_15_15	= 0x4def7b82;
static const uint32_t cror_31_31_31	= 0x4ffffb82;
d1774 2
a1775 1
  uint32_t plt_base = this->targ_->plt_section()->address();
d1777 2
a1778 4
  // The address of _GLOBAL_OFFSET_TABLE_.
  const Output_data_got_powerpc<size, big_endian>* got;
  typename elfcpp::Elf_types<size>::Elf_Addr g_o_t;
  got = this->targ_->got_section();
d1782 1
a1782 2
      const unsigned int toc_base_offset = 0x8000;
      g_o_t = got->output_section()->address() + toc_base_offset;
d1790 5
a1794 3
	  uint64_t plt_addr = plt_base + g->first.sym_->plt_offset();
	  uint64_t got_addr = g_o_t;
	  uint64_t pltoff = plt_addr - got_addr;
d1835 2
a1836 2
      uint64_t after_bcl = this->address() + this->pltresolve_ + 16;
      uint64_t pltoff = plt_base - after_bcl;
d1874 2
a1875 1
      g_o_t = got->address() + got->g_o_t();
d1883 3
a1885 3
	  uint32_t plt_addr = plt_base + g->first.sym_->plt_offset();
	  uint32_t got_addr;
	  const uint32_t invalid_address = static_cast<uint32_t>(-1);
d1903 1
a1903 1
	      uint32_t pltoff = plt_addr - got_addr;
d1939 3
a1941 3
	  uint32_t res0_off = this->pltresolve_;
	  uint32_t after_bcl_off = the_end + 12;
	  uint32_t bcl_res0 = after_bcl_off - res0_off;
d1951 1
a1951 1
	  uint32_t got_bcl = g_o_t + 4 - (after_bcl_off + this->address());
d1973 1
a1973 1
	  uint32_t res0 = this->pltresolve_ + this->address();
d2066 1
a2066 1
// Create a GOT entry for the TLS module index.
d2070 1
a2070 1
Target_powerpc<size, big_endian>::got_mod_index_entry(
d2075 1
a2075 1
  if (this->got_mod_index_offset_ == -1U)
d2079 3
a2081 6
      Output_data_got_powerpc<size, big_endian>* got;
      unsigned int got_offset;

      got = this->got_section(symtab, layout);
      got->reserve_ent(2);
      got_offset = got->add_constant(0);
d2084 1
a2084 2
      got->add_constant(0);
      this->got_mod_index_offset_ = got_offset;
d2086 1
a2086 17
  return this->got_mod_index_offset_;
}

// Optimize the TLS relocation type based on what we know about the
// symbol.  IS_FINAL is true if the final address of this symbol is
// known at link time.

template<int size, bool big_endian>
tls::Tls_optimization
Target_powerpc<size, big_endian>::optimize_tls_reloc(bool, int)
{
  // If we are generating a shared library, then we can't do anything
  // in the linker.
  if (parameters->options().shared())
    return tls::TLSOPT_NONE;
  // FIXME
  return tls::TLSOPT_NONE;
d2104 4
d2109 1
a2112 2
    case elfcpp::R_POWERPC_ADDR32:
    case elfcpp::R_PPC64_ADDR64:
d2115 7
a2121 1
    case elfcpp::R_POWERPC_REL24:
d2129 1
d2131 3
d2284 3
d2293 18
d2314 1
d2316 2
d2322 10
d2339 2
a2340 2
	  check_non_pic(object, r_type);
	  if (lsym.get_st_type() != elfcpp::STT_SECTION)
d2343 5
a2347 3
	      rela_dyn->add_local(object, r_sym, r_type, output_section,
				  data_shndx, reloc.get_r_offset(),
				  reloc.get_r_addend());
d2351 1
d2353 3
a2355 5
	      gold_assert(lsym.get_st_value() == 0);
	      rela_dyn->add_local_relative(object, r_sym, r_type,
					   output_section, data_shndx,
					   reloc.get_r_offset(),
					   reloc.get_r_addend(), false);
d2360 1
d2363 1
a2363 1
    case elfcpp::R_POWERPC_REL32:
d2365 1
d2367 31
d2404 2
d2408 3
a2410 5
	Output_data_got_powerpc<size, big_endian>* got;
	unsigned int r_sym;

	got = target->got_section(symtab, layout);
	r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
a2438 1
    case elfcpp::R_PPC64_TOC:
d2443 84
a2526 9
      // These are relocations which should only be seen by the
      // dynamic linker, and should never be seen here.
    case elfcpp::R_POWERPC_COPY:
    case elfcpp::R_POWERPC_GLOB_DAT:
    case elfcpp::R_POWERPC_JMP_SLOT:
    case elfcpp::R_POWERPC_RELATIVE:
    case elfcpp::R_POWERPC_DTPMOD:
      gold_error(_("%s: unexpected reloc %u in object file"),
		 object->name().c_str(), r_type);
d2563 3
d2572 22
d2597 1
d2599 2
d2605 10
d2629 1
a2629 1
	if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
d2636 4
a2639 3
	    else if ((r_type == elfcpp::R_POWERPC_ADDR32
		      || r_type == elfcpp::R_PPC64_ADDR64)
		     && gsym->can_use_relative_reloc(false))
a2649 1

d2651 4
a2654 13
		if (gsym->is_from_dynobj()
		    || gsym->is_undefined()
		    || gsym->is_preemptible())
		  rela_dyn->add_global(gsym, r_type, output_section,
				       object, data_shndx,
				       reloc.get_r_offset(),
				       reloc.get_r_addend());
		else
		  rela_dyn->add_global_relative(gsym, r_type,
						output_section, object,
						data_shndx,
						reloc.get_r_offset(),
						reloc.get_r_addend(), false);
d2670 1
a2670 1
	if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
d2690 1
d2695 31
d2732 2
a2762 1
    case elfcpp::R_PPC64_TOC:
d2773 61
a2833 3
    case elfcpp::R_POWERPC_GOT_TPREL16:
    case elfcpp::R_POWERPC_TLS:
      // XXX TLS
d2836 22
a2857 9
      // These are relocations which should only be seen by the
      // dynamic linker, and should never be seen here.
    case elfcpp::R_POWERPC_COPY:
    case elfcpp::R_POWERPC_GLOB_DAT:
    case elfcpp::R_POWERPC_JMP_SLOT:
    case elfcpp::R_POWERPC_RELATIVE:
    case elfcpp::R_POWERPC_DTPMOD:
      gold_error(_("%s: unexpected reloc %u in object file"),
		 object->name().c_str(), r_type);
d2983 6
a2988 3
      this->got_->finalize_data_size();
      odyn->add_section_plus_offset(elfcpp::DT_PPC_GOT,
				    this->got_, this->got_->g_o_t());
d2992 8
a2999 5
      this->glink_->finalize_data_size();
      odyn->add_section_plus_offset(elfcpp::DT_PPC64_GLINK,
				    this->glink_,
				    (this->glink_->pltresolve()
				     + this->glink_->pltresolve_size - 32));
d3025 19
a3043 1
  const unsigned int toc_base_offset = 0x8000;
d3045 1
d3048 11
a3058 1
  Address value;
d3078 1
a3078 1
      value -= target->got_section()->g_o_t();
d3083 1
a3083 1
	       + toc_base_offset);
d3088 1
a3088 1
	   && gsym->use_plt_offset(Scan::get_reference_flags(r_type)))
a3089 5
      const Output_data_glink<size, big_endian>* glink;

      glink = target->glink_section();
      unsigned int glink_index = glink->find_entry(gsym, rela, object);
      value = glink->address() + glink_index * glink->glink_entry_size();
d3110 238
d3350 1
a3350 1
      typename elfcpp::Elf_types<size>::Elf_Swxword addend = 0;
d3353 3
a3355 2
      value = psymval->value(object, addend);
      if (size == 64 && this->is_branch_reloc(r_type))
d3357 2
d3383 15
d3406 1
a3406 1
		+ toc_base_offset);
d3419 76
d3499 1
d3502 4
a3505 3
    case elfcpp::R_POWERPC_NONE:
    case elfcpp::R_POWERPC_GNU_VTINHERIT:
    case elfcpp::R_POWERPC_GNU_VTENTRY:
d3509 12
a3520 1
      Reloc::rel32(view, value, 0, address);
d3526 19
a3544 1
      Reloc::rel24(view, value, 0, address);
d3546 1
d3548 7
a3554 2
    case elfcpp::R_POWERPC_REL14:
      Reloc::rel14(view, value, 0, address);
d3558 1
d3560 13
a3572 1
      Relocate_functions<size, big_endian>::rela64(view, value, 0);
d3576 2
a3577 1
      Relocate_functions<size, big_endian>::rela32(view, value, 0);
d3580 18
d3599 1
d3603 5
a3607 3
      Reloc::addr16(view, value, 0);
      break;

d3609 1
d3613 10
a3622 1
      Reloc::addr16_lo(view, value, 0);
d3626 1
d3630 7
a3636 1
      Reloc::addr16_hi(view, value, 0);
d3640 1
d3644 16
a3659 1
      Reloc::addr16_ha(view, value, 0);
d3662 7
a3668 2
    case elfcpp::R_POWERPC_REL16_LO:
      Reloc::rel16_lo(view, value, 0, address);
d3671 7
a3677 2
    case elfcpp::R_POWERPC_REL16_HI:
      Reloc::rel16_hi(view, value, 0, address);
d3680 7
a3686 2
    case elfcpp::R_POWERPC_REL16_HA:
      Reloc::rel16_ha(view, value, 0, address);
d3689 10
d3707 10
a3716 1
      Reloc::addr16_ds(view, value, 0);
a3722 2
      // This is an outstanding tls reloc, which is unexpected when
      // linking.
d3724 2
d3731 14
a3744 2
    case elfcpp::R_PPC64_TOCSAVE:
      // For the time being this can be ignored.
d3747 23
d3771 1
a3780 33
// Perform a TLS relocation.

template<int size, bool big_endian>
inline void
Target_powerpc<size, big_endian>::Relocate::relocate_tls(
    const Relocate_info<size, big_endian>* relinfo,
    Target_powerpc<size, big_endian>* target,
    size_t relnum,
    const elfcpp::Rela<size, big_endian>& rela,
    unsigned int r_type,
    const Sized_symbol<size>* gsym,
    const Symbol_value<size>* psymval,
    unsigned char* view,
    Address address,
    section_size_type)
{
  Output_segment* tls_segment = relinfo->layout->tls_segment();
  const Sized_relobj_file<size, big_endian>* object = relinfo->object;

  const Address addend = rela.get_r_addend();
  Address value = psymval->value(object, 0);

  const bool is_final =
    (gsym == NULL
     ? !parameters->options().output_is_position_independent()
     : gsym->final_value_is_known());

  switch (r_type)
    {
      // XXX
    }
}

d3884 4
d3900 1
a3900 1
    Address,
d3949 7
a3955 2
	      new_symndx = object->symtab_index(r_sym);
	      gold_assert(new_symndx != -1U);
d4009 12
a4033 1

@


1.49
log
@	* target.h (Target::output_section_name): New function.
	(Target::do_output_section_name): New function.
	* layout.cc (Layout::choose_output_section): Call the above.
	* powerpc.cc (Target_powerpc::do_output_section_name): New function.
@
text
@d60 2
d65 1
a65 1
      got2_section_(0)
d71 1
d76 1
a76 1
      return this->got2_section_;
d81 53
d138 22
a159 1
  unsigned int got2_section_;
d168 2
d238 1
a238 1
		   typename elfcpp::Elf_types<size>::Elf_Addr view_address,
d267 1
a267 1
			   typename elfcpp::Elf_types<size>::Elf_Addr,
d424 13
d555 2
a556 2
  false,                // isolate_execinstr
  0,                    // rosegment_gap
d581 2
a582 2
  false,                // isolate_execinstr
  0,                    // rosegment_gap
d607 2
a608 2
  false,                // isolate_execinstr
  0,                    // rosegment_gap
d633 2
a634 2
  false,                // isolate_execinstr
  0,                    // rosegment_gap
d647 4
d656 3
a658 3
       elfcpp::Elf_Xword dst_mask,
       typename elfcpp::Swap<size, big_endian>::Valtype value,
       typename elfcpp::Swap<size, big_endian>::Valtype addend)
a663 1

a665 1

d674 3
a676 3
	  elfcpp::Elf_Xword dst_mask,
	  typename elfcpp::Swap<size, big_endian>::Valtype value,
	  typename elfcpp::Swap<size, big_endian>::Valtype addend)
d678 2
a679 2
    typedef typename elfcpp::Swap_unaligned<valsize,
					    big_endian>::Valtype Valtype;
a682 1

a684 1

a687 2
  typedef Powerpc_relocate_functions<size, big_endian> This;
  typedef Relocate_functions<size, big_endian> This_reloc;
d691 1
a691 4
  rel32(unsigned char* view,
	typename elfcpp::Elf_types<size>::Elf_Addr value,
	typename elfcpp::Elf_types<size>::Elf_Addr addend,
	typename elfcpp::Elf_types<size>::Elf_Addr address)
d696 2
a697 7
  rel24(unsigned char* view,
	typename elfcpp::Elf_types<size>::Elf_Addr value,
	typename elfcpp::Elf_types<size>::Elf_Addr addend,
	typename elfcpp::Elf_types<size>::Elf_Addr address)
  {
    This::template rela<32>(view, 0, 0x03fffffc, value - address, addend);
  }
d701 2
a702 7
  rel14(unsigned char* view,
	typename elfcpp::Elf_types<size>::Elf_Addr value,
	typename elfcpp::Elf_types<size>::Elf_Addr addend,
	typename elfcpp::Elf_types<size>::Elf_Addr address)
  {
    This::template rela<32>(view, 0, 0xfffc, value - address, addend);
  }
d706 1
a706 3
  addr16(unsigned char* view,
	 typename elfcpp::Elf_types<size>::Elf_Addr value,
	 typename elfcpp::Elf_types<size>::Elf_Addr addend)
d711 2
a712 6
  addr16_ds(unsigned char* view,
	    typename elfcpp::Elf_types<size>::Elf_Addr value,
	    typename elfcpp::Elf_types<size>::Elf_Addr addend)
  {
    This::template rela<16>(view, 0, 0xfffc, value, addend);
  }
d716 1
a716 3
  addr16_lo(unsigned char* view,
	 typename elfcpp::Elf_types<size>::Elf_Addr value,
	 typename elfcpp::Elf_types<size>::Elf_Addr addend)
d721 2
a722 6
  addr16_hi(unsigned char* view,
	    typename elfcpp::Elf_types<size>::Elf_Addr value,
	    typename elfcpp::Elf_types<size>::Elf_Addr addend)
  {
    This::template rela<16>(view, 16, 0xffff, value, addend);
  }
d724 1
a724 3
  // R_POWERPC_ADDR16_HA: Same as R_POWERPC_ADDR16_HI except that if the
  //                      final value of the low 16 bits of the
  //                      relocation is negative, add one.
d726 2
a727 6
  addr16_ha(unsigned char* view,
	    typename elfcpp::Elf_types<size>::Elf_Addr value,
	    typename elfcpp::Elf_types<size>::Elf_Addr addend)
  {
    This::addr16_hi(view, value + 0x8000, addend);
  }
d731 1
a731 4
  rel16(unsigned char* view,
	typename elfcpp::Elf_types<size>::Elf_Addr value,
	typename elfcpp::Elf_types<size>::Elf_Addr addend,
	typename elfcpp::Elf_types<size>::Elf_Addr address)
d736 1
a736 4
  rel16_lo(unsigned char* view,
	   typename elfcpp::Elf_types<size>::Elf_Addr value,
	   typename elfcpp::Elf_types<size>::Elf_Addr addend,
	   typename elfcpp::Elf_types<size>::Elf_Addr address)
d741 2
a742 7
  rel16_hi(unsigned char* view,
	   typename elfcpp::Elf_types<size>::Elf_Addr value,
	   typename elfcpp::Elf_types<size>::Elf_Addr addend,
	   typename elfcpp::Elf_types<size>::Elf_Addr address)
  {
    This::template rela<16>(view, 16, 0xffff, value - address, addend);
  }
d744 1
a744 3
  // R_POWERPC_REL16_HA: Same as R_POWERPC_REL16_HI except that if the
  //                 final value of the low 16 bits of the
  //                 relocation is negative, add one.
d746 2
a747 7
  rel16_ha(unsigned char* view,
	   typename elfcpp::Elf_types<size>::Elf_Addr value,
	   typename elfcpp::Elf_types<size>::Elf_Addr addend,
	   typename elfcpp::Elf_types<size>::Elf_Addr address)
  {
    This::rel16_hi(view, value + 0x8000, addend, address);
  }
d750 2
a751 2
// Stash away the index of .got2 in a relocatable object, if such
// a section exists.
d758 26
a783 1
  if (size == 32)
d785 35
a819 5
      const unsigned char* const pshdrs = sd->section_headers->data();
      const unsigned char* namesu = sd->section_names->data();
      const char* names = reinterpret_cast<const char*>(namesu);
      section_size_type names_size = sd->section_names_size;
      const unsigned char* s;
d821 10
a830 2
      s = this->find_shdr(pshdrs, ".got2", names, names_size, NULL);
      if (s != NULL)
d832 7
a838 2
	  unsigned int ndx = (s - pshdrs) / elfcpp::Elf_sizes<size>::shdr_size;
	  this->got2_section_ = ndx;
a840 1
  return Sized_relobj_file<size, big_endian>::do_find_special_sections(sd);
d856 1
a856 1
        new Powerpc_relobj<size, big_endian>(name, input_file, offset, ehdr);
d863 1
a863 1
        new Sized_dynobj<size, big_endian>(name, input_file, offset, ehdr);
d869 1
a869 2
      gold_error(_("%s: unsupported ELF file type %d"),
                 name.c_str(), et);
d1123 42
a1164 39
static const uint32_t addis_11_11       = 0x3d6b0000;
static const uint32_t addis_11_30       = 0x3d7e0000;
static const uint32_t addis_12_12       = 0x3d8c0000;
static const uint32_t addi_11_11        = 0x396b0000;
static const uint32_t add_0_11_11       = 0x7c0b5a14;
static const uint32_t add_11_0_11       = 0x7d605a14;
static const uint32_t b                 = 0x48000000;
static const uint32_t bcl_20_31         = 0x429f0005;
static const uint32_t bctr              = 0x4e800420;
static const uint32_t blrl              = 0x4e800021;
static const uint32_t lis_11            = 0x3d600000;
static const uint32_t lis_12            = 0x3d800000;
static const uint32_t lwzu_0_12         = 0x840c0000;
static const uint32_t lwz_0_12          = 0x800c0000;
static const uint32_t lwz_11_11         = 0x816b0000;
static const uint32_t lwz_11_30         = 0x817e0000;
static const uint32_t lwz_12_12         = 0x818c0000;
static const uint32_t mflr_0            = 0x7c0802a6;
static const uint32_t mflr_12           = 0x7d8802a6;
static const uint32_t mtctr_0           = 0x7c0903a6;
static const uint32_t mtctr_11          = 0x7d6903a6;
static const uint32_t mtlr_0            = 0x7c0803a6;
static const uint32_t nop               = 0x60000000;
static const uint32_t sub_11_11_12      = 0x7d6c5850;
static const uint32_t addis_12_2        = 0x3d820000;
static const uint32_t std_2_1           = 0xf8410000;
static const uint32_t ld_11_12          = 0xe96c0000;
static const uint32_t ld_2_12           = 0xe84c0000;
static const uint32_t addi_12_12        = 0x398c0000;
static const uint32_t ld_11_2           = 0xe9620000;
static const uint32_t addi_2_2          = 0x38420000;
static const uint32_t ld_2_2            = 0xe8420000;
static const uint32_t mflr_11           = 0x7d6802a6;
static const uint32_t ld_2_11           = 0xe84b0000;
static const uint32_t mtlr_12           = 0x7d8803a6;
static const uint32_t add_12_2_11       = 0x7d825a14;
static const uint32_t li_0_0            = 0x38000000;
static const uint32_t lis_0_0           = 0x3c000000;
static const uint32_t ori_0_0_0         = 0x60000000;
d1234 2
a1270 2
  static const int pltresolve_size = 16*4;

d1284 1
a1284 1
      : sym_(sym), object_(0), addend_(0)
a1297 4
    const Symbol* sym_;
    const Sized_relobj<size, big_endian>* object_;
    unsigned int addend_;

d1304 4
d1427 1
a1427 1
write_insn(unsigned char *p, uint32_t v)
d1442 1
a1442 1
  unsigned char *p;
d1448 1
a1448 1
  const Output_data_got_powerpc<size, big_endian> *got;
a1450 1
  g_o_t = got->address() + got->g_o_t();
d1454 3
d1538 1
a1538 1
	  uint16_t branch_off = this->pltresolve_ + 8 - (p - oview);
d1545 2
d1555 1
d1565 4
a1568 3
		  got_addr = (g->first.object_->output_section(got2)->address()
			      + g->first.object_->output_section_offset(got2)
			      + g->first.addend_);
d1600 1
a1600 1
      unsigned char *end_p = oview + the_end;
d1971 3
a1974 1
    case elfcpp::R_POWERPC_ADDR16_LO:
d2014 2
a2015 2
        // The symbol requires a GOT entry.
        Output_data_got_powerpc<size, big_endian>* got;
d2106 2
a2111 2
    case elfcpp::R_POWERPC_ADDR32:
    case elfcpp::R_PPC64_ADDR64:
d2113 3
a2115 3
        // Make a PLT entry if necessary.
        if (gsym->needs_plt_entry())
          {
d2124 10
a2133 10
          }
        // Make a dynamic relocation if necessary.
        if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
          {
            if (gsym->may_need_copy_reloc())
              {
	        target->copy_reloc(symtab, layout, object,
	                           data_shndx, output_section, gsym, reloc);
              }
            else if ((r_type == elfcpp::R_POWERPC_ADDR32
d2207 2
a2208 2
        // The symbol requires a GOT entry.
        Output_data_got_powerpc<size, big_endian>* got;
d2382 1
a2385 1
      Output_data_dynamic* odyn = layout->dynamic_data();
d2389 8
d2418 2
a2419 2
    typename elfcpp::Elf_types<size>::Elf_Addr address,
    section_size_type /* view_size */)
d2425 1
a2425 1
  elfcpp::Elf_Xword value;
d2449 2
a2450 1
      value = target->got_section()->address() + toc_base_offset;
d2462 19
d2484 1
a2484 1
      elfcpp::Elf_Xword addend = 0;
d2488 22
d2521 2
a2522 1
      value -= target->got_section()->address() + toc_base_offset;
d2659 1
a2659 1
    typename elfcpp::Elf_types<size>::Elf_Addr address,
d2665 2
a2666 2
  const elfcpp::Elf_Xword addend = rela.get_r_addend();
  typename elfcpp::Elf_types<size>::Elf_Addr value = psymval->value(object, 0);
d2691 1
a2691 1
    typename elfcpp::Elf_types<size>::Elf_Addr address,
d2794 1
a2794 1
    typename elfcpp::Elf_types<size>::Elf_Addr,
a2800 1
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
a2806 1
  const Address invalid_address = static_cast<Address>(0) - 1;
d2812 1
a2812 1
  typename elfcpp::Elf_types<size>::Elf_Swxword got2_addend = 0;
d2814 4
a2817 1
    got2_addend = object->get_output_section_offset(got2_shndx);
d2889 2
a2890 2
          section_offset_type sot_offset =
              convert_types<section_offset_type, Address>(offset);
d2892 2
a2893 2
              output_section->output_offset(object, relinfo->data_shndx,
                                            sot_offset);
d2895 1
a2895 1
          new_offset = new_sot_offset;
@


1.48
log
@elfcpp/
	* powerpc.h: Add more relocs.
	(R_PPC_REL16*): Rename to R_POWERPC_REL16*.
gold/
	* powerpc.cc: Update for renamed R_PPC_REL16 relocs.
	(Output_data_got_powerpc::do_write): Don't rely on base class lookup
	for replace_constant call.
	(Output_data_plt_powerpc::do_print_to_mapfile): New function.
	(Output_data_glink::do_print_to_mapfile): New function.
	(Target_powerpc::Scan::local): Ignore R_PPC64_TOCSAVE.
	(Target_powerpc::Relocate::relocate): Likewise.
@
text
@d128 13
@


1.47
log
@	* powerpc.cc (Powerpc_relobj::set_got2_shndx): Delete.
	(Powerpc_relobj::do_find_special_sections): Don't use set_got2_shndx.
	(Output_data_glink::add_entry,find_entry): Remove shndx param.
	(class Glink_sym_ent): Rename from struct Glink_sym_ent.  Remove
	all references to shndx_.  Handle special case for R_PPC_PLTREL24
	here.
	(class Glink_sym_ent_hash): Rename from struct Glink_sym_ent_hash.
	(Output_data_glink::do_write): Retrieve got2_shdnx from object.
	(Target_powerpc::make_plt_entry): Don't special case R_PPC_PLTREL24
	here.
	(Target_powerpc::Scan::global): Nor on make_plt_entry call.
	(Target_powerpc::Relocate::relocate): Nor on glink->find_entry call.
@
text
@d657 1
a657 1
  // R_PPC_REL16: (Symbol + Addend - Address) & 0xffff
d665 1
a665 1
  // R_PPC_REL16_LO: (Symbol + Addend - Address) & 0xffff
d673 1
a673 1
  // R_PPC_REL16_HI: ((Symbol + Addend - Address) >> 16) & 0xffff
d683 1
a683 1
  // R_PPC_REL16_HA: Same as R_PPC_REL16_HI except that if the
d809 4
a812 4
    replace_constant(this->header_index_,
		     (size == 32
		      ? this->layout_->dynamic_section()->address()
		      : this->address() + 0x8000));
d947 5
d1139 6
d1675 4
a1678 4
    case elfcpp::R_PPC_REL16:
    case elfcpp::R_PPC_REL16_LO:
    case elfcpp::R_PPC_REL16_HI:
    case elfcpp::R_PPC_REL16_HA:
d1837 1
d1874 2
a1875 2
    case elfcpp::R_PPC_REL16_LO:
    case elfcpp::R_PPC_REL16_HA:
d2065 4
a2068 4
    case elfcpp::R_PPC_REL16:
    case elfcpp::R_PPC_REL16_LO:
    case elfcpp::R_PPC_REL16_HI:
    case elfcpp::R_PPC_REL16_HA:
d2415 1
a2415 1
    case elfcpp::R_PPC_REL16_LO:
d2419 1
a2419 1
    case elfcpp::R_PPC_REL16_HI:
d2423 1
a2423 1
    case elfcpp::R_PPC_REL16_HA:
d2450 4
@


1.46
log
@	* powerpc.cc: Whitespace fixes.  Wrap overly long lines.
	(glink insn constants): Use uint32_t.
	(Output_data_glink::add_entry): Use insert, not [] operator.
@
text
@a77 9
  void
  set_got2_shndx(unsigned int shndx)
  {
    if (size == 32)
      this->got2_section_ = shndx;
    else
      gold_unreachable();
  }

d716 1
a716 1
	  this->set_got2_shndx(ndx);
d1111 1
a1111 1
	    const Sized_relobj<size, big_endian>*, unsigned int);
d1115 1
a1115 1
	     const Sized_relobj<size, big_endian>*, unsigned int) const;
d1144 1
a1144 1
  struct Glink_sym_ent
d1146 2
a1147 1
    Glink_sym_ent(const Symbol *sym,
d1149 2
a1150 3
		  const Sized_relobj<size, big_endian>* object,
		  unsigned int shndx)
      : sym_(sym), object_(0), shndx_(0), addend_(0)
d1154 3
a1156 1
      else if (parameters->options().output_is_position_independent())
d1158 1
a1158 2
	  if (object != NULL && shndx != 0)
	    this->addend_ = reloc.get_r_addend();
d1160 1
a1160 4
	    {
	      this->object_ = object;
	      this->shndx_ = shndx;
	    }
d1164 1
a1164 1
    const Symbol *sym_;
a1165 1
    unsigned int shndx_;
d1172 1
a1172 2
              && this->shndx_ == that.shndx_
              && this->addend_ == that.addend_);
d1176 1
a1176 1
  struct Glink_sym_ent_hash
d1178 1
a1182 1
	      ^ ent.shndx_
d1187 1
a1187 1
  // Set of sym/shndx/addend entries.
d1210 1
a1210 1
// sym/addend/shndx combo.
d1217 1
a1217 2
    const Sized_relobj<size, big_endian>* object,
    unsigned int shndx)
d1219 1
a1219 1
  Glink_sym_ent ent(gsym, reloc, object, shndx);
d1229 1
a1229 2
    const Sized_relobj<size, big_endian>* object,
    unsigned int shndx) const
d1231 1
a1231 1
  Glink_sym_ent ent(gsym, reloc, object, shndx);
d1421 9
a1429 5
	      unsigned int got2 = g->first.shndx_;
	      if (got2)
		got_addr = (g->first.object_->output_section(got2)->address()
			    + g->first.object_->output_section_offset(got2)
			    + g->first.addend_);
d1564 1
a1564 8
  unsigned int got2_shndx = 0;
  if (size == 32 && object != NULL)
    {
      const Powerpc_relobj<size, big_endian>* ppc_obj
	= static_cast<const Powerpc_relobj<size, big_endian>*>(object);
      got2_shndx = ppc_obj->got2_shndx();
    }
  this->glink_->add_entry(gsym, reloc, object, got2_shndx);
d2031 1
a2031 6
	  {
	    if (r_type == elfcpp::R_PPC_PLTREL24)
	      target->make_plt_entry(layout, gsym, reloc, object);
	    else
	      target->make_plt_entry(layout, gsym, reloc, 0);
	  }
d2308 1
a2308 4
      unsigned int shndx = 0;
      if (size == 32 && r_type == elfcpp::R_PPC_PLTREL24)
	shndx = object->got2_shndx();
      unsigned int glink_index = glink->find_entry(gsym, rela, object, shndx);
@


1.45
log
@	* object.h (Sized_relobj_file::find_shdr): New function.
	(Sized_relobj_file::find_special_sections): New function.
	* object.cc (Sized_relobj_file::find_shdr): New function.
	(Sized_relobj_file::find_eh_frame): Use find_shdr.
	(Sized_relobj_file::find_special_sections): New function, split out..
	(Sized_relobj_file::do_read_symbols): ..from here.
	* output.h (Output_data_got::replace_constant): New function.
	(Output_data_got::num_entries): New function.
	(Output_data_got::last_got_offset,set_got_size): Use num_entries.
	(Output_data_got::got_offset): Protected rather than private.
	(Output_data_got::replace_got_entry): New function.
	* output.cc (Output_data_got::replace_got_entry): New function.
	* powerpc.cc (class Powerpc_relobj): New.
	(class Powerpc_relocate_functions): Delete all psymval variants or
	convert to value,addend type.  Delete pcrela, pcrela_unaligned.
	Implement _ha functions using corresponding _hi function.
	(Powerpc_relobj::find_special_sections): New function.
	(Target_powerpc::do_make_elf_object): New function.
	(class Output_data_got_powerpc): New.
	(class Output_data_glink): New.
	(class Powerpc_scan_relocatable_reloc): New.
	Many more changes througout file.
@
text
@d98 2
a99 1
  typedef Output_data_reloc<elfcpp::SHT_RELA, true, size, big_endian> Reloc_section;
d688 1
a688 1
  { 
d700 1
a700 1
  { 
d934 4
a937 1
  { return (this->current_data_size() - initial_plt_entry_size) / plt_entry_size; }
d975 3
a977 2
Output_data_plt_powerpc<size, big_endian>::Output_data_plt_powerpc(Layout* layout,
								   Target_powerpc<size, big_endian>* targ)
d1007 39
a1045 39
static const unsigned int addis_11_11     = 0x3d6b0000;
static const unsigned int addis_11_30     = 0x3d7e0000;
static const unsigned int addis_12_12     = 0x3d8c0000;
static const unsigned int addi_11_11      = 0x396b0000;
static const unsigned int add_0_11_11     = 0x7c0b5a14;
static const unsigned int add_11_0_11     = 0x7d605a14;
static const unsigned int b               = 0x48000000;
static const unsigned int bcl_20_31       = 0x429f0005;
static const unsigned int bctr            = 0x4e800420;
static const unsigned int blrl            = 0x4e800021;
static const unsigned int lis_11          = 0x3d600000;
static const unsigned int lis_12          = 0x3d800000;
static const unsigned int lwzu_0_12       = 0x840c0000;
static const unsigned int lwz_0_12        = 0x800c0000;
static const unsigned int lwz_11_11       = 0x816b0000;
static const unsigned int lwz_11_30       = 0x817e0000;
static const unsigned int lwz_12_12       = 0x818c0000;
static const unsigned int mflr_0          = 0x7c0802a6;
static const unsigned int mflr_12         = 0x7d8802a6;
static const unsigned int mtctr_0         = 0x7c0903a6;
static const unsigned int mtctr_11        = 0x7d6903a6;
static const unsigned int mtlr_0          = 0x7c0803a6;
static const unsigned int nop             = 0x60000000;
static const unsigned int sub_11_11_12    = 0x7d6c5850;
static const unsigned int addis_12_2      = 0x3d820000;
static const unsigned int std_2_1         = 0xf8410000;
static const unsigned int ld_11_12        = 0xe96c0000;
static const unsigned int ld_2_12         = 0xe84c0000;
static const unsigned int addi_12_12      = 0x398c0000;
static const unsigned int ld_11_2         = 0xe9620000;
static const unsigned int addi_2_2        = 0x38420000;
static const unsigned int ld_2_2          = 0xe8420000;
static const unsigned int mflr_11         = 0x7d6802a6;
static const unsigned int ld_2_11         = 0xe84b0000;
static const unsigned int mtlr_12         = 0x7d8803a6;
static const unsigned int add_12_2_11     = 0x7d825a14;
static const unsigned int li_0_0          = 0x38000000;
static const unsigned int lis_0_0         = 0x3c000000;
static const unsigned int ori_0_0_0       = 0x60000000;
d1215 2
a1216 1
Output_data_glink<size, big_endian>::Output_data_glink(Target_powerpc<size, big_endian>* targ)
d1227 5
a1231 5
Output_data_glink<size, big_endian>
::add_entry(const Symbol* gsym,
	    const elfcpp::Rela<size, big_endian>& reloc,
	    const Sized_relobj<size, big_endian>* object,
	    unsigned int shndx)
d1235 1
a1235 1
  this->glink_entries_[ent] = indx;
d1240 5
a1244 5
Output_data_glink<size, big_endian>
::find_entry(const Symbol* gsym,
	     const elfcpp::Rela<size, big_endian>& reloc,
	     const Sized_relobj<size, big_endian>* object,
	     unsigned int shndx) const
d1436 4
a1439 3
	      if (g->first.shndx_)
		got_addr = (g->first.object_->output_section(g->first.shndx_)->address()
			    + g->first.object_->output_section_offset(g->first.shndx_)
d1564 5
a1568 4
Target_powerpc<size, big_endian>::make_plt_entry(Layout* layout,
						 Symbol* gsym,
						 const elfcpp::Rela<size, big_endian>& reloc,
						 const Sized_relobj<size, big_endian>* object)
d1661 1
a1661 2
Target_powerpc<size, big_endian>::Scan::get_reference_flags(
			unsigned int r_type)
d1724 2
a1725 2
			Sized_relobj_file<size, big_endian>* object,
			unsigned int r_type)
d1829 9
a1837 9
			Symbol_table* symtab,
			Layout* layout,
			Target_powerpc<size, big_endian>* target,
			Sized_relobj_file<size, big_endian>* object,
			unsigned int data_shndx,
			Output_section* output_section,
			const elfcpp::Rela<size, big_endian>& reloc,
			unsigned int r_type,
			const elfcpp::Sym<size, big_endian>& lsym)
d1950 3
a1952 3
			Sized_relobj_file<size, big_endian>* object,
			unsigned int r_type,
			Symbol* gsym)
d1963 9
a1971 9
				Symbol_table* symtab,
				Layout* layout,
				Target_powerpc<size, big_endian>* target,
				Sized_relobj_file<size, big_endian>* object,
				unsigned int data_shndx,
				Output_section* output_section,
				const elfcpp::Rela<size, big_endian>& reloc,
				unsigned int r_type,
				Symbol* gsym)
d2153 11
a2163 11
			Symbol_table* symtab,
			Layout* layout,
			Sized_relobj_file<size, big_endian>* object,
			unsigned int data_shndx,
			unsigned int,
			const unsigned char* prelocs,
			size_t reloc_count,
			Output_section* output_section,
			bool needs_special_offset_handling,
			size_t local_symbol_count,
			const unsigned char* plocal_symbols)
d2188 11
a2198 11
			Symbol_table* symtab,
			Layout* layout,
			Sized_relobj_file<size, big_endian>* object,
			unsigned int data_shndx,
			unsigned int sh_type,
			const unsigned char* prelocs,
			size_t reloc_count,
			Output_section* output_section,
			bool needs_special_offset_handling,
			size_t local_symbol_count,
			const unsigned char* plocal_symbols)
d2281 11
a2291 11
			const Relocate_info<size, big_endian>* relinfo,
			Target_powerpc* target,
			Output_section* os,
			size_t relnum,
			const elfcpp::Rela<size, big_endian>& rela,
			unsigned int r_type,
			const Sized_symbol<size>* gsym,
			const Symbol_value<size>* psymval,
			unsigned char* view,
			typename elfcpp::Elf_types<size>::Elf_Addr address,
			section_size_type /* view_size */)
d2479 10
a2488 10
			const Relocate_info<size, big_endian>* relinfo,
			Target_powerpc<size, big_endian>* target,
			size_t relnum,
			const elfcpp::Rela<size, big_endian>& rela,
			unsigned int r_type,
			const Sized_symbol<size>* gsym,
			const Symbol_value<size>* psymval,
			unsigned char* view,
			typename elfcpp::Elf_types<size>::Elf_Addr address,
			section_size_type)
d2512 10
a2521 10
			const Relocate_info<size, big_endian>* relinfo,
			unsigned int sh_type,
			const unsigned char* prelocs,
			size_t reloc_count,
			Output_section* output_section,
			bool needs_special_offset_handling,
			unsigned char* view,
			typename elfcpp::Elf_types<size>::Elf_Addr address,
			section_size_type view_size,
			const Reloc_symbol_changes* reloc_symbol_changes)
d2529 1
a2529 1
    Powerpc_relocate>(
d2579 12
a2590 12
			Symbol_table* symtab,
			Layout* layout,
			Sized_relobj_file<size, big_endian>* object,
			unsigned int data_shndx,
			unsigned int sh_type,
			const unsigned char* prelocs,
			size_t reloc_count,
			Output_section* output_section,
			bool needs_special_offset_handling,
			size_t local_symbol_count,
			const unsigned char* plocal_symbols,
			Relocatable_relocs* rr)
d2595 1
a2595 1
    Powerpc_scan_relocatable_reloc>(
@


1.44
log
@	* arm.cc (Arm_relocate_functions::abs16): Remove unused typedef.
	(Arm_exidx_cantunwind::do_fixed_endian_write): Likewise.
	(Target_arm::scan_reloc_for_stub): Likewise.
	* common.cc (Symbol_table::do_allocate_commons_list): Likewise.
	* dwarf_reader.cc (Dwarf_die::skip_attributes): Likewise.
	* ehframe.cc (Eh_frame::do_add_ehframe_input_section): Likewise.
	* incremental.cc (Sized_incr_dynobj::do_add_symbols): Likewise.
	* powerpc.cc (Target_powerpc::relocate_tls): Likewise.
@
text
@d51 44
d102 1
a102 2
      got_(NULL), got2_(NULL), toc_(NULL),
      plt_(NULL), rela_dyn_(NULL),
d182 3
a184 3
			   unsigned char* view,
			   typename elfcpp::Elf_types<size>::Elf_Addr view_address,
			   section_size_type view_size,
d192 1
a192 1
    return strcmp(sym->name(), "___tls_get_addr") == 0;
d203 29
d359 5
a363 1
    get_size_for_reloc(unsigned int, Relobj*);
d366 5
d372 1
a372 1
  Output_data_got<size, big_endian>*
d375 3
a377 6
  Output_data_space*
  got2_section() const
  {
    gold_assert(this->got2_ != NULL);
    return this->got2_;
  }
d379 3
a381 7
  // Get the TOC section.
  Output_data_space*
  toc_section() const
  {
    gold_assert(this->toc_ != NULL);
    return this->toc_;
  }
d385 3
a387 1
  make_plt_entry(Symbol_table*, Layout*, Symbol*);
a393 8
  // Get the PLT section.
  const Output_data_plt_powerpc<size, big_endian>*
  plt_section() const
  {
    gold_assert(this->plt_ != NULL);
    return this->plt_;
  }

d426 3
a428 7
  // The GOT section.
  Output_data_got<size, big_endian>* got_;
  // The GOT2 section.
  Output_data_space* got2_;
  // The TOC section.
  Output_data_space* toc_;
  // The PLT section.
d430 3
a432 1
  // The dynamic reloc section.
d550 1
a550 1
  // Do a simple relocation with the addend in the relocation.
d562 1
a562 1
    Valtype reloc = ((value + addend) >> right_shift);
d570 1
a570 2
  // Do a simple relocation using a symbol value with the addend in
  // the relocation.
d573 2
a574 23
  rela(unsigned char* view,
       unsigned int right_shift,
       elfcpp::Elf_Xword dst_mask,
       const Sized_relobj_file<size, big_endian>* object,
       const Symbol_value<size>* psymval,
       typename elfcpp::Swap<valsize, big_endian>::Valtype addend)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<valsize, big_endian>::readval(wv);
    Valtype reloc = (psymval->value(object, addend) >> right_shift);

    val &= ~dst_mask;
    reloc &= dst_mask;

    elfcpp::Swap<valsize, big_endian>::writeval(wv, val | reloc);
  }

  // Do a simple relocation using a symbol value with the addend in
  // the relocation, unaligned.
  template<int valsize>
  static inline void
  rela_ua(unsigned char* view, unsigned int right_shift,
d576 1
a576 2
	  const Sized_relobj_file<size, big_endian>* object,
	  const Symbol_value<size>* psymval,
d580 1
a580 23
	    big_endian>::Valtype Valtype;
    unsigned char* wv = view;
    Valtype val = elfcpp::Swap_unaligned<valsize, big_endian>::readval(wv);
    Valtype reloc = (psymval->value(object, addend) >> right_shift);

    val &= ~dst_mask;
    reloc &= dst_mask;

    elfcpp::Swap_unaligned<valsize, big_endian>::writeval(wv, val | reloc);
  }

  // Do a simple PC relative relocation with a Symbol_value with the
  // addend in the relocation.
  template<int valsize>
  static inline void
  pcrela(unsigned char* view, unsigned int right_shift,
	 elfcpp::Elf_Xword dst_mask,
	 const Sized_relobj_file<size, big_endian>* object,
	 const Symbol_value<size>* psymval,
	 typename elfcpp::Swap<size, big_endian>::Valtype addend,
	 typename elfcpp::Elf_types<size>::Elf_Addr address)
  {
    typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
d583 1
a583 2
    Valtype reloc = ((psymval->value(object, addend) - address)
		     >> right_shift);
d588 1
a588 17
    elfcpp::Swap<valsize, big_endian>::writeval(wv, val | reloc);
  }

  template<int valsize>
  static inline void
  pcrela_unaligned(unsigned char* view,
		   const Sized_relobj_file<size, big_endian>* object,
		   const Symbol_value<size>* psymval,
		   typename elfcpp::Swap<size, big_endian>::Valtype addend,
		   typename elfcpp::Elf_types<size>::Elf_Addr address)
  {
    typedef typename elfcpp::Swap_unaligned<valsize,
	    big_endian>::Valtype Valtype;
    unsigned char* wv = view;
    Valtype reloc = (psymval->value(object, addend) - address);

    elfcpp::Swap_unaligned<valsize, big_endian>::writeval(wv, reloc);
d597 1
a597 2
	const Sized_relobj_file<size, big_endian>* object,
	const Symbol_value<size>* psymval,
d600 1
a600 1
  { This_reloc::pcrela32(view, object, psymval, addend, address); }
d605 1
a605 2
	const Sized_relobj_file<size, big_endian>* object,
	const Symbol_value<size>* psymval,
d609 1
a609 2
    This::template pcrela<32>(view, 0, 0x03fffffc, object,
			      psymval, addend, address);
d615 1
a615 2
	const Sized_relobj_file<size, big_endian>* object,
	const Symbol_value<size>* psymval,
d619 1
a619 2
    This::template pcrela<32>(view, 0, 0x0000fffc, object,
			      psymval, addend, address);
a628 7
  static inline void
  addr16(unsigned char* view,
	 const Sized_relobj_file<size, big_endian>* object,
	 const Symbol_value<size>* psymval,
	 typename elfcpp::Elf_types<size>::Elf_Addr addend)
  { This_reloc::rela16(view, object, psymval, addend); }

a644 7
  static inline void
  addr16_lo(unsigned char* view,
	    const Sized_relobj_file<size, big_endian>* object,
	    const Symbol_value<size>* psymval,
	    typename elfcpp::Elf_types<size>::Elf_Addr addend)
  { This_reloc::rela16(view, object, psymval, addend); }

a653 9
  static inline void
  addr16_hi(unsigned char* view,
	    const Sized_relobj_file<size, big_endian>* object,
	    const Symbol_value<size>* psymval,
	    typename elfcpp::Elf_types<size>::Elf_Addr addend)
  {
    This::template rela<16>(view, 16, 0xffff, object, psymval, addend);
  }

d662 1
a662 26
    typename elfcpp::Elf_types<size>::Elf_Addr reloc;

    reloc = value + addend;

    if (reloc & 0x8000)
      reloc += 0x10000;
    reloc >>= 16;

    elfcpp::Swap<16, big_endian>::writeval(view, reloc);
  }

  static inline void
  addr16_ha(unsigned char* view,
	    const Sized_relobj_file<size, big_endian>* object,
	    const Symbol_value<size>* psymval,
	    typename elfcpp::Elf_types<size>::Elf_Addr addend)
  {
    typename elfcpp::Elf_types<size>::Elf_Addr reloc;

    reloc = psymval->value(object, addend);

    if (reloc & 0x8000)
      reloc += 0x10000;
    reloc >>= 16;

    elfcpp::Swap<16, big_endian>::writeval(view, reloc);
d668 1
a668 2
	const Sized_relobj_file<size, big_endian>* object,
	const Symbol_value<size>* psymval,
d671 1
a671 1
  { This_reloc::pcrela16(view, object, psymval, addend, address); }
d676 1
a676 2
	   const Sized_relobj_file<size, big_endian>* object,
	   const Symbol_value<size>* psymval,
d679 1
a679 1
  { This_reloc::pcrela16(view, object, psymval, addend, address); }
d684 1
a684 2
	   const Sized_relobj_file<size, big_endian>* object,
	   const Symbol_value<size>* psymval,
d687 2
a688 3
  {
    This::template pcrela<16>(view, 16, 0xffff, object,
			      psymval, addend, address);
d696 1
a696 2
	   const Sized_relobj_file<size, big_endian>* object,
	   const Symbol_value<size>* psymval,
d699 117
d817 4
a820 1
    typename elfcpp::Elf_types<size>::Elf_Addr reloc;
d822 12
a833 4
    reloc = (psymval->value(object, addend) - address);
    if (reloc & 0x8000)
      reloc += 0x10000;
    reloc >>= 16;
d835 22
a856 1
    elfcpp::Swap<16, big_endian>::writeval(view, reloc);
d858 9
d872 1
a872 1
Output_data_got<size, big_endian>*
d880 2
a881 1
      this->got_ = new Output_data_got<size, big_endian>();
a885 27

      // Create the GOT2 or TOC in the .got section.
      if (size == 32)
	{
	  this->got2_ = new Output_data_space(4, "** GOT2");
	  layout->add_output_section_data(".got2", elfcpp::SHT_PROGBITS,
					  elfcpp::SHF_ALLOC
					  | elfcpp::SHF_WRITE,
					  this->got2_, ORDER_DATA, false);
	}
      else
	{
	  this->toc_ = new Output_data_space(8, "** TOC");
	  layout->add_output_section_data(".toc", elfcpp::SHT_PROGBITS,
					  elfcpp::SHF_ALLOC
					  | elfcpp::SHF_WRITE,
					  this->toc_, ORDER_DATA, false);
	}

      // Define _GLOBAL_OFFSET_TABLE_ at the start of the .got section.
      symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
				    Symbol_table::PREDEFINED,
				    this->got_,
				    0, 0, elfcpp::STT_OBJECT,
				    elfcpp::STB_LOCAL,
				    elfcpp::STV_HIDDEN, 0,
				    false, false);
d911 1
a911 1
class Output_data_plt_powerpc : public Output_section_data
d917 1
a917 1
  Output_data_plt_powerpc(Layout*);
d920 2
a921 1
  void add_entry(Symbol* gsym);
d924 3
a926 2
  const Reloc_section* rel_plt() const
 {
d933 1
a933 1
  { return this->count_; }
d938 1
a938 1
  { return 4 * base_plt_entry_size; }
d943 1
a943 1
  { return base_plt_entry_size; }
d946 5
a950 1
  void do_adjust_output_section(Output_section* os);
d954 3
a956 10
  static const int base_plt_entry_size = (size == 32 ? 16 : 24);

  // Set the final size.
  void
  set_final_data_size()
  {
    unsigned int full_count = this->count_ + 4;

    this->set_data_size(full_count * base_plt_entry_size);
  }
d964 2
a965 2
  // The number of PLT entries.
  unsigned int count_;
d968 1
a968 2
// Create the PLT section.  The ordinary .got section is an argument,
// since we need to refer to the start.
d971 4
a974 2
Output_data_plt_powerpc<size, big_endian>::Output_data_plt_powerpc(Layout* layout)
  : Output_section_data(size == 32 ? 4 : 8), count_(0)
a981 7
template<int size, bool big_endian>
void
Output_data_plt_powerpc<size, big_endian>::do_adjust_output_section(Output_section* os)
{
  os->set_entsize(0);
}

d988 3
a990 3
  gold_assert(!gsym->has_plt_offset());
  unsigned int index = this->count_+ + 4;
  section_offset_type plt_offset;
d992 8
a999 12
  if (index < 8192)
    plt_offset = index * base_plt_entry_size;
  else
    gold_unreachable();

  gsym->set_plt_offset(plt_offset);

  ++this->count_;

  gsym->set_needs_dynsym_entry();
  this->rel_->add_global(gsym, elfcpp::R_POWERPC_JMP_SLOT, this,
			 plt_offset, 0);
d1011 1
d1025 483
a1507 1
static const unsigned int sub_11_11_12    = 0x7d6c5850;
d1509 25
a1533 5
static const unsigned int addis_r12_r2    = 0x3d820000;  /* addis %r12,%r2,xxx@@ha     */
static const unsigned int std_r2_40r1     = 0xf8410028;  /* std   %r2,40(%r1)         */
static const unsigned int ld_r11_0r12     = 0xe96c0000;  /* ld    %r11,xxx+0@@l(%r12)  */
static const unsigned int ld_r2_0r12      = 0xe84c0000;  /* ld    %r2,xxx+8@@l(%r12)   */
							 /* ld    %r11,xxx+16@@l(%r12) */
d1535 2
d1538 1
a1538 1
// Write out the PLT.
d1542 1
a1542 1
Output_data_plt_powerpc<size, big_endian>::do_write(Output_file* of)
d1544 1
a1544 19
  const off_t offset = this->offset();
  const section_size_type oview_size =
    convert_to_section_size_type(this->data_size());
  unsigned char* const oview = of->get_output_view(offset, oview_size);
  unsigned char* pov = oview;

  memset(pov, 0, base_plt_entry_size * 4);
  pov += base_plt_entry_size * 4;

  unsigned int plt_offset = base_plt_entry_size * 4;
  const unsigned int count = this->count_;

  if (size == 64)
    {
      for (unsigned int i = 0; i < count; i++)
	{
	}
    }
  else
d1546 4
a1549 10
      for (unsigned int i = 0; i < count; i++)
	{
	  elfcpp::Swap<32, true>::writeval(pov + 0x00,
					   lwz_11_30 + plt_offset);
	  elfcpp::Swap<32, true>::writeval(pov + 0x04, mtctr_11);
	  elfcpp::Swap<32, true>::writeval(pov + 0x08, bctr);
	  elfcpp::Swap<32, true>::writeval(pov + 0x0c, nop);
	  pov += base_plt_entry_size;
	  plt_offset += base_plt_entry_size;
	}
a1550 4

  gold_assert(static_cast<section_size_type>(pov - oview) == oview_size);

  of->write_output_view(offset, oview_size, oview);
d1557 4
a1560 3
Target_powerpc<size, big_endian>::make_plt_entry(Symbol_table* symtab,
						 Layout* layout,
						 Symbol* gsym)
a1561 3
  if (gsym->has_plt_offset())
    return;

d1563 1
a1563 3
    {
      // Create the GOT section first.
      this->got_section(symtab, layout);
d1565 1
a1565 4
      // Ensure that .rela.dyn always appears before .rela.plt  This is
      // necessary due to how, on PowerPC and some other targets, .rela.dyn
      // needs to include .rela.plt in it's range.
      this->rela_dyn_section(layout);
d1567 6
a1572 15
      this->plt_ = new Output_data_plt_powerpc<size, big_endian>(layout);
      layout->add_output_section_data(".plt", elfcpp::SHT_PROGBITS,
				      (elfcpp::SHF_ALLOC
				       | elfcpp::SHF_EXECINSTR
				       | elfcpp::SHF_WRITE),
				      this->plt_, ORDER_PLT, false);

      // Define _PROCEDURE_LINKAGE_TABLE_ at the start of the .plt section.
      symtab->define_in_output_data("_PROCEDURE_LINKAGE_TABLE_", NULL,
				    Symbol_table::PREDEFINED,
				    this->plt_,
				    0, 0, elfcpp::STT_OBJECT,
				    elfcpp::STB_LOCAL,
				    elfcpp::STV_HIDDEN, 0,
				    false, false);
d1574 1
a1574 2

  this->plt_->add_entry(gsym);
d1619 1
a1619 1
      Output_data_got<size, big_endian>* got;
d1623 1
d1637 3
a1639 2
static tls::Tls_optimization
optimize_tls_reloc(bool /* is_final */, int r_type)
d1645 2
a1646 6
  switch (r_type)
    {
      // XXX
    default:
      gold_unreachable();
    }
a1880 6
    case elfcpp::R_PPC64_TOC16:
    case elfcpp::R_PPC64_TOC16_LO:
    case elfcpp::R_PPC64_TOC16_HI:
    case elfcpp::R_PPC64_TOC16_HA:
    case elfcpp::R_PPC64_TOC16_DS:
    case elfcpp::R_PPC64_TOC16_LO_DS:
d1882 2
a1883 2
	// The symbol requires a GOT entry.
	Output_data_got<size, big_endian>* got;
d1910 6
d1971 1
a1971 15
      break;

    case elfcpp::R_PPC_PLTREL24:
      // If the symbol is fully resolved, this is just a PC32 reloc.
      // Otherwise we need a PLT entry.
      if (gsym->final_value_is_known())
	break;
      // If building a shared library, we can also skip the PLT entry
      // if the symbol is defined in the output file and is protected
      // or hidden.
      if (gsym->is_defined()
	  && !gsym->is_from_dynobj()
	  && !gsym->is_preemptible())
	break;
      target->make_plt_entry(symtab, layout, gsym);
d1981 4
a1984 4
	// Make a PLT entry if necessary.
	if (gsym->needs_plt_entry())
	  {
	    target->make_plt_entry(symtab, layout, gsym);
d1989 2
a1990 1
	    if (gsym->is_from_dynobj() && !parameters->options().shared())
d1992 10
a2001 10
	  }
	// Make a dynamic relocation if necessary.
	if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
	  {
	    if (gsym->may_need_copy_reloc())
	      {
		target->copy_reloc(symtab, layout, object,
				   data_shndx, output_section, gsym, reloc);
	      }
	    else if ((r_type == elfcpp::R_POWERPC_ADDR32
d2034 1
a2035 5
    case elfcpp::R_PPC_LOCAL24PC:
    case elfcpp::R_PPC_REL16:
    case elfcpp::R_PPC_REL16_LO:
    case elfcpp::R_PPC_REL16_HI:
    case elfcpp::R_PPC_REL16_HA:
d2037 11
a2047 2
	if (gsym->needs_plt_entry())
	  target->make_plt_entry(symtab, layout, gsym);
d2069 6
a2078 6
    case elfcpp::R_PPC64_TOC16:
    case elfcpp::R_PPC64_TOC16_LO:
    case elfcpp::R_PPC64_TOC16_HI:
    case elfcpp::R_PPC64_TOC16_HA:
    case elfcpp::R_PPC64_TOC16_DS:
    case elfcpp::R_PPC64_TOC16_LO_DS:
d2080 2
a2081 2
	// The symbol requires a GOT entry.
	Output_data_got<size, big_endian>* got;
d2109 6
a2194 1
  static Output_data_space* sdata;
d2203 21
a2223 20
  // Define _SDA_BASE_ at the start of the .sdata section.
  if (sdata == NULL)
  {
    // layout->find_output_section(".sdata") == NULL
    sdata = new Output_data_space(4, "** sdata");
    Output_section* os = layout->add_output_section_data(".sdata", 0,
							 elfcpp::SHF_ALLOC
							 | elfcpp::SHF_WRITE,
							 sdata,
							 ORDER_SMALL_DATA,
							 false);
    symtab->define_in_output_data("_SDA_BASE_", NULL,
				  Symbol_table::PREDEFINED,
				  os,
				  32768, 0,
				  elfcpp::STT_OBJECT,
				  elfcpp::STB_LOCAL,
				  elfcpp::STV_HIDDEN, 0,
				  false, false);
  }
d2255 8
d2276 1
a2276 1
			Output_section*,
d2288 34
d2323 8
a2330 4
  // Pick the value to use for symbols defined in shared objects.
  Symbol_value<size> symval;
  if (gsym != NULL
      && gsym->use_plt_offset(Scan::get_reference_flags(r_type)))
d2332 4
a2335 7
      elfcpp::Elf_Xword value;

      value = target->plt_section()->address() + gsym->plt_offset();

      symval.set_output_value(value);

      psymval = &symval;
a2337 8
  const Sized_relobj_file<size, big_endian>* object = relinfo->object;
  elfcpp::Elf_Xword addend = rela.get_r_addend();

  // Get the GOT offset if needed.  Unlike i386 and x86_64, our GOT
  // pointer points to the beginning, not the end, of the table.
  // So we just use the plain offset.
  unsigned int got_offset = 0;
  unsigned int got2_offset = 0;
d2346 2
a2347 21
	// Subtract the TOC base address.
	addend -= target->toc_section()->address() + toc_base_offset;
	/* FALLTHRU */

    case elfcpp::R_POWERPC_GOT16:
    case elfcpp::R_POWERPC_GOT16_LO:
    case elfcpp::R_POWERPC_GOT16_HI:
    case elfcpp::R_POWERPC_GOT16_HA:
    case elfcpp::R_PPC64_GOT16_DS:
    case elfcpp::R_PPC64_GOT16_LO_DS:
      if (gsym != NULL)
	{
	  gold_assert(gsym->has_got_offset(GOT_TYPE_STANDARD));
	  got_offset = gsym->got_offset(GOT_TYPE_STANDARD);
	}
      else
	{
	  unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
	  gold_assert(object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD));
	  got_offset = object->local_got_offset(r_sym, GOT_TYPE_STANDARD);
	}
d2350 8
a2357 10
      // R_PPC_PLTREL24 is rather special.  If non-zero,
      // the addend specifies the GOT pointer offset within .got2.
    case elfcpp::R_PPC_PLTREL24:
      if (addend >= 32768)
	{
	  Output_data_space* got2;
	  got2 = target->got2_section();
	  got2_offset = got2->offset();
	  addend += got2_offset;
	}
d2372 1
a2372 1
      Reloc::rel32(view, object, psymval, addend, address);
d2376 3
a2378 1
      Reloc::rel24(view, object, psymval, addend, address);
d2382 1
a2382 1
      Reloc::rel14(view, object, psymval, addend, address);
d2385 3
a2387 2
    case elfcpp::R_PPC_PLTREL24:
      Reloc::rel24(view, object, psymval, addend, address);
d2390 2
a2391 2
    case elfcpp::R_PPC_LOCAL24PC:
      Reloc::rel24(view, object, psymval, addend, address);
d2394 5
a2398 10
    case elfcpp::R_PPC64_ADDR64:
      if (!parameters->options().output_is_position_independent())
	Relocate_functions<size, big_endian>::rela64(view, object,
						     psymval, addend);
      break;

    case elfcpp::R_POWERPC_ADDR32:
      if (!parameters->options().output_is_position_independent())
	Relocate_functions<size, big_endian>::rela32(view, object,
						     psymval, addend);
d2402 4
a2405 1
      Reloc::addr16_lo(view, object, psymval, addend);
d2409 4
a2412 1
      Reloc::addr16_hi(view, object, psymval, addend);
d2416 4
a2419 1
      Reloc::addr16_ha(view, object, psymval, addend);
d2423 1
a2423 1
      Reloc::rel16_lo(view, object, psymval, addend, address);
d2427 1
a2427 1
      Reloc::rel16_lo(view, object, psymval, addend, address);
d2431 1
a2431 33
      Reloc::rel16_ha(view, object, psymval, addend, address);
      break;

    case elfcpp::R_POWERPC_GOT16:
      Reloc::addr16(view, got_offset, addend);
      break;

    case elfcpp::R_POWERPC_GOT16_LO:
      Reloc::addr16_lo(view, got_offset, addend);
      break;

    case elfcpp::R_POWERPC_GOT16_HI:
      Reloc::addr16_hi(view, got_offset, addend);
      break;

    case elfcpp::R_POWERPC_GOT16_HA:
      Reloc::addr16_ha(view, got_offset, addend);
      break;

    case elfcpp::R_PPC64_TOC16:
      Reloc::addr16(view, got_offset, addend);
      break;

    case elfcpp::R_PPC64_TOC16_LO:
      Reloc::addr16_lo(view, got_offset, addend);
      break;

    case elfcpp::R_PPC64_TOC16_HI:
      Reloc::addr16_hi(view, got_offset, addend);
      break;

    case elfcpp::R_PPC64_TOC16_HA:
      Reloc::addr16_ha(view, got_offset, addend);
d2434 2
d2438 5
a2442 9
      Reloc::addr16_ds(view, got_offset, addend);
      break;

    case elfcpp::R_PPC64_TOC:
      {
	elfcpp::Elf_types<64>::Elf_Addr value;
	value = target->toc_section()->address() + toc_base_offset;
	Relocate_functions<64, false>::rela64(view, value, addend);
      }
a2492 2
  const tls::Tls_optimization optimized_type
      = optimize_tls_reloc(is_final, r_type);
d2535 20
a2554 2
// Return the size of a relocation while scanning during a relocatable
// link.
d2556 10
a2565 10
template<int size, bool big_endian>
unsigned int
Target_powerpc<size, big_endian>::Relocatable_size_for_reloc::get_size_for_reloc(
    unsigned int,
    Relobj*)
{
  // We are always SHT_RELA, so we should never get here.
  gold_unreachable();
  return 0;
}
a2586 3
  typedef gold::Default_scan_relocatable_relocs<elfcpp::SHT_RELA,
    Relocatable_size_for_reloc> Scan_relocatable_relocs;

d2588 1
a2588 1
      Scan_relocatable_relocs>(
d2614 3
a2616 3
    unsigned char* view,
    typename elfcpp::Elf_types<size>::Elf_Addr view_address,
    section_size_type view_size,
d2622 128
a2749 12
  gold::relocate_for_relocatable<size, big_endian, elfcpp::SHT_RELA>(
    relinfo,
    prelocs,
    reloc_count,
    output_section,
    offset_in_output_section,
    rr,
    view,
    view_address,
    view_size,
    reloc_view,
    reloc_view_size);
d2761 7
a2767 2
  gold_assert(gsym->is_from_dynobj() && gsym->has_plt_offset());
  return this->plt_section()->address() + gsym->plt_offset();
@


1.44.2.1
log
@gold/
	* target.h (Sized_target::relocate_for_relocatable): Use Elf_Off
	for offset_in_output_section parameter.
	(Sized_target::relocate_special_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise.
	(Target_arm::relocate_special_relocatable): Likewise.
	* i386.cc (Target_i386::relocate_for_relocatable): Likewise.
	* powerpc.cc (Target_powerpc::relocate_for_relocatable): Likewise.
	* sparc.cc (Target_sparc::relocate_for_relocatable): Likewise.
	* target-reloc.h (relocate_for_relocatable): Likewise.
	* testsuite/testfile.cc (Target_test): Likewise.
	* tilegx.cc (Target_tilegx::relocate_for_relocatable): Likewise.
	* x86_64.cc (Target_x86_64::relocate_for_relocatable): Likewise.
@
text
@d137 1
a137 2
			   typename elfcpp::Elf_types<size>::Elf_Off
                             offset_in_output_section,
d2089 1
a2089 1
    typename elfcpp::Elf_types<size>::Elf_Off offset_in_output_section,
@


1.43
log
@	* configure.ac (ENABLE_GOLD): Consider *-*-nacl* targets ELF.
	* configure: Regenerate.

gold/
	* nacl.cc: New file.
	* nacl.h: New file.
	* Makefile.am (CCFILES, HFILES): Add them.
	* Makefile.in: Regenerate.
	* i386.cc (Output_data_plt_i386_nacl): New class.
	(Output_data_plt_i386_nacl_exec): New class.
	(Output_data_plt_i386_nacl_dyn): New class.
	(Target_i386_nacl): New class.
	(Target_selector_i386_nacl): New class.
	(target_selector_i386): Use it instead of Target_selector_i386.
	* x86_64.cc (Output_data_plt_x86_64_nacl): New class.
	(Target_x86_64_nacl): New class.
	(Target_selector_x86_64_nacl): New class.
	(target_selector_x86_64, target_selector_x32): Use it instead of
	Target_selector_x86_64.
	* arm.cc (Output_data_plt_arm_nacl): New class.
	(Target_arm_nacl): New class.
	(Target_selector_arm_nacl): New class.
	(target_selector_arm, target_selector_armbe): Use it instead of
	Target_selector_arm.

	* target-select.cc (select_target): Take new Input_file* and off_t
	arguments, pass them on to recognize method of selector.
	* object.cc (make_elf_sized_object): Update caller.
	* parameters.cc (parameters_force_valid_target): Likewise.
	* incremental.cc (make_sized_incremental_binary): Likewise.
	* target-select.h: Update decl.
	(Target_selector::recognize): Take new Input_file* argument,
	pass it on to do_recognize.
	(Target_selector::do_recognize): Take new Input_file* argument.
	* freebsd.h (Target_selector_freebsd::do_recognize): Likewise.
	* powerpc.cc (Target_selector_powerpc::do_recognize): Likewise.
	* sparc.cc (Target_selector_sparc::do_recognize): Likewise.
	* testsuite/testfile.cc (Target_selector::do_recognize): Likewise.

	* target.h (Target::Target_info): New members isolate_execinstr
	and rosegment_gap.
	(Target::isolate_execinstr, Target::rosegment_gap): New methods.
	* arm.cc (Target_arm::arm_info): Update initializer.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
	* sparc.cc (Target_sparc::sparc_info): Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
	* layout.cc (Layout::attach_allocated_section_to_segment):
	Take new const Target* argument.  If target->isolate_execinstr(), act
	like --rosegment.
	(Layout::find_first_load_seg): Take new const Target* argument;
	if target->isolate_execinstr(), reject PF_X segments.
	(Layout::relaxation_loop_body): Update caller.
	(Layout::set_segment_offsets): If target->isolate_execinstr(),
	reset file offset to zero when we hit LOAD_SEG, and then do a second
	loop over the segments before LOAD_SEG to reassign offsets after
	addresses have been determined.  Handle target->rosegment_gap().
	(Layout::attach_section_to_segment): Take new const Target* argument;
	pass it to attach_allocated_section_to_segment.
	(Layout::make_output_section): Update caller.
	(Layout::attach_sections_to_segments): Take new const Target* argument;
	pass it to attach_section_to_segment.
	* gold.cc (queue_middle_tasks): Update caller.
	* layout.h (Layout): Update method decls with new arguments.

	* arm.cc (Target_arm::Target_arm): Take optional argument for the
	Target_info pointer to use.
	(Target_arm::do_make_data_plt): New virtual method.
	(Target_arm::make_data_plt): New method that calls it.
	(Target_arm::make_plt_entry): Use it.
	(Output_data_plt_arm::Output_data_plt_arm): Take additional argument
	for the section alignment.
	(Output_data_plt_arm::do_first_plt_entry_offset): New abstract virtual
	method.
	(Output_data_plt_arm::first_plt_entry_offset): Call it.
	(Output_data_plt_arm::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_arm::get_plt_entry_size): Call it.
	(Output_data_plt_arm::do_fill_plt_entry): New abstract virtual method.
	(Output_data_plt_arm::fill_plt_entry): New method that calls it.
	(Output_data_plt_arm::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_arm::fill_first_plt_entry): New method that calls it.
	(Output_data_plt_arm::set_final_data_size): Use get_plt_entry_size
	method instead of sizeof(plt_entry).
	(Output_data_plt_arm::add_entry): Likewise.
	Use first_plt_entry_offset method instead of sizeof(first_plt_entry).
	(Target_arm::first_plt_entry_offset): Call method on this->plt_ rather
	than static method.
	(Target_arm::plt_entry_size): Likewise.
	(Output_data_plt_arm::first_plt_entry, Output_data_plt_arm::plt_entry):
	Move to ...
	(Output_data_plt_arm_standard): ... here, new class.
	(Output_data_plt_arm::do_write): Move guts of PLT filling to...
	(Output_data_plt_arm_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_arm_standard::do_fill_plt_entry): ... and here.

	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Take additional argument for the PLT entry size.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset):
	Use get_plt_entry_size method rather than plt_entry_size variable.
	(Output_data_plt_x86_64::reserve_slot): Likewise.
	(Output_data_plt_x86_64::do_adjust_output_section): Likewise.
	(Output_data_plt_x86_64::add_entry): Likewise.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Likewise.
	(Output_data_plt_x86_64::address_for_global): Likewise.
	(Output_data_plt_x86_64::address_for_local): Likewise.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::first_plt_entry_offset): Likewise.
	Make method non-static.
	(Output_data_plt_x86_64::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_x86_64::get_plt_entry_size): Just call that.
	(Output_data_plt_x86_64::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_x86_64::add_eh_frame): New method to call it.
	(Output_data_plt_x86_64::do_fill_first_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_first_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_tlsdesc_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_tlsdesc_entry): New method to call it.
	(Output_data_plt_x86_64::plt_entry_size)
	(Output_data_plt_x86_64::first_plt_entry)
	(Output_data_plt_x86_64::plt_entry)
	(Output_data_plt_x86_64::tlsdesc_plt_entry)
	(Output_data_plt_x86_64::plt_eh_frame_fde_size)
	(Output_data_plt_x86_64::plt_eh_frame_fde): Move to ...
	(Output_data_plt_x86_64_standard): ... here, new class.
	(Target_x86_64::Target_x86_64): Take optional argument for the
	Target_info pointer to use.
	(Target_x86_64::do_make_data_plt): New virtual method.
	(Target_x86_64::make_data_plt): New method to call it.
	(Target_x86_64::init_got_plt_for_update): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_x86_64::init):	Don't do add_eh_frame_for_plt here.
	(Target_x86_64::first_plt_entry_offset): Call method on this->plt_
	rather than static method.
	(Target_x86_64::plt_entry_size): Likewise.
	(Output_data_plt_x86_64::do_write): Use get_plt_entry_size method
	rather than plt_entry_size variable.  Move guts of PLT filling to...
	(Output_data_plt_x86_64_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_x86_64_standard::do_fill_plt_entry): ... and here ...
	(Output_data_plt_x86_64_standard::do_fill_tlsdesc_entry): ... and here.

	* i386.cc (Output_data_plt_i386::Output_data_plt_i386): Take
	additional argument for the section alignment.
	Don't do add_eh_frame_for_plt here.
	(Output_data_plt_i386::first_plt_entry_offset): Make the method
	non-static.  Use get_plt_entry_size method rather than plt_entry_size
	variable.
	(Output_data_plt_i386::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_i386::get_plt_entry_size): Call it.
	(Output_data_plt_i386::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_i386::add_eh_frame): New method to call it.
	(Output_data_plt_i386::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_first_plt_entry): New method to call it.
	(Output_data_plt_i386::do_fill_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_plt_entry): New method to call it.
	(Output_data_plt_i386::set_final_data_size): Use get_plt_entry_size
	method instead of plt_entry_size.
	(Output_data_plt_i386::plt_entry_size)
	(Output_data_plt_i386::plt_eh_frame_fde_size)
	(Output_data_plt_i386::plt_eh_frame_fde): Move to ...
	(Output_data_plt_i386_standard): ... here, new class.
	(Output_data_plt_i386_exec): New class.
	(Output_data_plt_i386::exec_first_plt_entry): Move to ...
	(Output_data_plt_i386_exec::first_plt_entry): ... here.
	(Output_data_plt_i386::exec_plt_entry): Move to ...
	(Output_data_plt_i386_exec::plt_entry): ... here.
	(Output_data_plt_i386_dyn): New class.
	(Output_data_plt_i386::first_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::first_plt_entry): ... here.
	(Output_data_plt_i386::dyn_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::plt_entry): ... here.
	(Target_i386::Target_i386): Take optional argument for the Target_info
	pointer to use.
	(Target_i386::do_make_data_plt): New virtual method.
	(Target_i386::make_data_plt): New method to call it.
	(Target_i386::make_plt_section): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_i386::add_entry): Use get_plt_entry_size method
	rather than plt_entry_size variable.
	(Output_data_plt_i386::add_local_ifunc_entry): Likewise.
	(Output_data_plt_i386::address_for_local): Likewise.
	(Output_data_plt_i386::do_write): Likewise.
	Move guts of PLT filling to...
	(Output_data_plt_i386_exec::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_i386_exec::do_fill_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_first_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_plt_entry): ... and here.

Change-Id: Id24b95600489835ff5e860a39c147203d4380c2b
@
text
@a1973 1
  typedef Powerpc_relocate_functions<size, big_endian> Reloc;
@


1.42
log
@gold: Allow use_plt_offset to be specified for global relocations.

gold/

	* output.h (Output_reloc): Allow use_plt_offset for global relocs too.
	(class Output_data_reloc): Adjust calls to Output_reloc_type.
	(Output_data_reloc::add_global_relative): (RELA only) Add use_plt_offset.
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag for
	global relocs too.
	(Output_reloc::symbol_value): Respect use_plt_offset_ for global symbols.
	* powerpc.cc (Target_powerpc::Scan::global): Adjust add_global_relative
	calls.
	* sparc.cc (Target_sparc::Scan::global): Likewise.
	* x86_64.cc (Target_x86_64::Scan::global): Likewise.
@
text
@d3 1
a3 1
// Copyright 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d65 1
a65 1
  // Process the relocations to determine unreferenced sections for 
d69 10
a78 10
	            Layout* layout,
	            Sized_relobj_file<size, big_endian>* object,
	            unsigned int data_shndx,
	            unsigned int sh_type,
	            const unsigned char* prelocs,
	            size_t reloc_count,
	            Output_section* output_section,
	            bool needs_special_offset_handling,
	            size_t local_symbol_count,
	            const unsigned char* plocal_symbols);
d213 1
a213 4
	          			Sized_relobj_file<size, big_endian>* ,
			                unsigned int ,
	          			Output_section* ,
	          			const elfcpp::Rela<size, big_endian>& ,
d215 4
a218 1
	          			const elfcpp::Sym<size, big_endian>&)
d224 4
a227 4
		   			 Sized_relobj_file<size, big_endian>* ,
		   			 unsigned int ,
		   			 Output_section* ,
		   			 const elfcpp::Rela<size,
d273 1
a273 1
                 size_t relnum, const elfcpp::Rela<size, big_endian>&,
d333 1
a333 1
             Sized_relobj_file<size, big_endian>* object,
d392 2
d418 2
d444 2
d470 2
d963 1
a963 1
                                                         /* ld    %r11,xxx+16@@l(%r12) */
d1322 2
a1323 2
        {
          Reloc_section* rela_dyn = target->rela_dyn_section(layout);
d1326 4
a1329 4
          if (lsym.get_st_type() != elfcpp::STT_SECTION)
            {
              unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());
              rela_dyn->add_local(object, r_sym, r_type, output_section,
d1332 3
a1334 3
            }
          else
            {
d1336 2
a1337 2
              gold_assert(lsym.get_st_value() == 0);
              rela_dyn->add_local_relative(object, r_sym, r_type,
d1341 2
a1342 2
            }
        }
d1363 2
a1364 2
        // The symbol requires a GOT entry.
        Output_data_got<size, big_endian>* got;
d1385 1
a1385 1
          }
d1457 2
a1458 2
          && !gsym->is_from_dynobj()
          && !gsym->is_preemptible())
d1470 20
a1489 20
        // Make a PLT entry if necessary.
        if (gsym->needs_plt_entry())
          {
            target->make_plt_entry(symtab, layout, gsym);
            // Since this is not a PC-relative relocation, we may be
            // taking the address of a function. In that case we need to
            // set the entry in the dynamic symbol table to the address of
            // the PLT entry.
            if (gsym->is_from_dynobj() && !parameters->options().shared())
              gsym->set_needs_dynsym_value();
          }
        // Make a dynamic relocation if necessary.
        if (gsym->needs_dynamic_reloc(Scan::get_reference_flags(r_type)))
          {
            if (gsym->may_need_copy_reloc())
              {
	        target->copy_reloc(symtab, layout, object,
	                           data_shndx, output_section, gsym, reloc);
              }
            else if ((r_type == elfcpp::R_POWERPC_ADDR32
d1491 4
a1494 4
                     && gsym->can_use_relative_reloc(false))
              {
                Reloc_section* rela_dyn = target->rela_dyn_section(layout);
                rela_dyn->add_global_relative(gsym, elfcpp::R_POWERPC_RELATIVE,
d1498 4
a1501 4
              }
            else
              {
                Reloc_section* rela_dyn = target->rela_dyn_section(layout);
d1517 2
a1518 2
              }
          }
d1563 2
a1564 2
        // The symbol requires a GOT entry.
        Output_data_got<size, big_endian>* got;
d1567 11
a1577 11
        if (gsym->final_value_is_known())
          got->add_global(gsym, GOT_TYPE_STANDARD);
        else
          {
            // If this symbol is not fully resolved, we need to add a
            // dynamic relocation for it.
            Reloc_section* rela_dyn = target->rela_dyn_section(layout);
            if (gsym->is_from_dynobj()
                || gsym->is_undefined()
                || gsym->is_preemptible())
              got->add_global_with_rel(gsym, GOT_TYPE_STANDARD, rela_dyn,
d1579 2
a1580 2
            else if (!gsym->has_got_offset(GOT_TYPE_STANDARD))
              {
d1587 1
a1587 1
          }
d1799 4
a1802 4
        {
          gold_assert(gsym->has_got_offset(GOT_TYPE_STANDARD));
          got_offset = gsym->got_offset(GOT_TYPE_STANDARD);
        }
d1804 5
a1808 5
        {
          unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
          gold_assert(object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD));
          got_offset = object->local_got_offset(r_sym, GOT_TYPE_STANDARD);
        }
d1812 1
a1812 1
      // the addend specifies the GOT pointer offset within .got2.  
d2143 2
a2144 1
  Target* do_recognize(int machine, int, int)
d2165 2
a2166 1
  Target* do_instantiate_target()
@


1.41
log
@	* object.h (Relobj::local_symbol_value): New function.
	(Relobj::local_plt_offset): New function.
	(Relobj::local_has_got_offset): New function.
	(Relobj::local_got_offset): New function.
	(Relobj::set_local_got_offset): New function.
	(Relobj::do_local_symbol_value): New pure virtual function.
	(Relobj::do_local_plt_offset): Likewise.
	(Relobj::do_local_has_got_offset): Likewise.
	(Relobj::do_local_got_offset): Likewise.
	(Relobj::do_set_local_got_offset): Likewise.
	(Sized_relobj::do_local_has_got_offset): Rename from
	local_has_got_offset.
	(Sized_relobj::do_local_got_offset): Rename from local_got_offset.
	(Sized_relobj::do_set_local_got_offset): Rename from
	set_local_got_offset.
	(Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	(Sized_relobj_file::do_local_symbol_value): New function.
	* object.cc (Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	* output.cc (Output_data_got::Got_entry::write): Change object to
	Relobj.  Use local_symbol_value.
	(Output_data_got::add_global_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_with_rela): Remove.  Change all
	callers to use add_global_with_rel.
	(Output_data_got::add_global_pair_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_pair_with_rela): Remove.  Change all
	callers to use add_global_pair_with_rel.
	(Output_data_got::add_local): Change object to Relobj*.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Change object to Relobj*,
	change rel_dyn to Output_data_reloc_generic*.  Use
	add_local_generic.
	(Output_data_got::add_local_with_rela): Remove.  Change all
	callers to use all_local_with_rel.
	(Output_data_got::add_local_pair_with_rel): Change object to
	Relobj*, change rel_dyn to Output_data_reloc_generic*.  Use
	add_output_section_generic.
	(Output_data_got::add_local_pair_with_rela): Remove.  Change all
	callers to use add_local_pair_with_rel.
	(Output_data_got::reserve_local): Change object to Relobj*.
	* output.h: (class Output_data_reloc_generic): Add pure virtual
	declarations for add_global_generic, add_local_generic,
	add_output_section_generic.
	(class Output_data_reloc) [SHT_REL, SHT_RELA]: Implement new
	functions for Output_data_reloc_generic.  Update declarations for
	changes listed in output.cc.
	(class Output_data_got): Change template parameter to got_size.
	Don't define Rel_dyn or Rela_dyn.  Update declarations per above.
	* incremental.h (Sized_relobj_incr::do_local_symbol_value): New
	function.
	(Sized_relobj_incr::do_local_plt_offset): New function.
	* copy-relocs.cc (Copy_relocs::Copy_reloc_entry::emit): Call
	add_global_generic.
@
text
@d1489 1
a1489 1
					      reloc.get_r_addend());
d1508 1
a1508 1
						reloc.get_r_addend());
d1577 1
a1577 1
					      got, off, 0);
@


1.40
log
@	PR gold/13249
	* gold/output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* gold/output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* gold/x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.
@
text
@d1569 2
a1570 2
              got->add_global_with_rela(gsym, GOT_TYPE_STANDARD, rela_dyn,
                                        elfcpp::R_POWERPC_GLOB_DAT);
@


1.39
log
@	PR gold/12934
	* target-select.cc (Target_selector::Target_selector): Add
	emulation parameter.  Change all callers.
	(select_target_by_bfd_name): Rename from select_target_by_name.
	Change all callers.
	(select_target_by_emulation): New function.
	(supported_emulation_names): New function.
	* target-select.h (class Target_selector): Add emulation_ field.
	Update declarations.
	(Target_selector::recognize_by_bfd_name): Rename from
	recognize_by_name.  Change all callers.
	(Target_selector::supported_bfd_names): Rename from
	supported_names.  Change all callers.
	(Target_selector::recognize_by_emulation): New function.
	(Target_selector::supported_emulations): New function.
	(Target_selector::emulation): New function.
	(Target_selector::do_recognize_by_bfd_name): Rename from
	do_recognize_by_name.  Change all callers.
	(Target_selector::do_supported_bfd_names): Rename from
	do_supported_names.  Change all callers.
	(Target_selector::do_recognize_by_emulation): New function.
	(Target_selector::do_supported_emulations): New function.
	(select_target_by_bfd_name): Change name in declaration.
	(select_target_by_emulation): Declare.
	(supported_emulation_names): Declare.
	* parameters.cc (parameters_force_valid_target): Try to find
	target based on emulation from -m option.
	* options.h (class General_options): Change doc string for -m.
	* options.cc (help): Print emulations.
	(General_options::parse_V): Likewise.
	* freebsd.h (Target_selector_freebsd::Target_selector_freebsd):
	Add emulation parameter.  Change all callers.
@
text
@d1332 1
a1332 1
					   reloc.get_r_addend());
d1375 1
a1375 1
					     got, off, 0);
@


1.39.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d1332 1
a1332 1
					   reloc.get_r_addend(), false);
d1375 1
a1375 1
					     got, off, 0, false);
@


1.38
log
@	* target.h (Target::can_check_for_function_pointers): Rewrite.
	Make non-virtual.
	(Target::can_icf_inline_merge_sections): Likewise.
	(Target::section_may_have_icf_unsafe_poineters): Likewise.
	(Target::Target_info): Add can_icf_inline_merge_sections field.
	(Target::do_can_check_for_function_pointers): New virtual
	function.
	(Target::do_section_may_have_icf_unsafe_pointers): Likewise.
	* arm.cc (Target_arm::do_can_check_for_function_pointers): Rename
	from can_check_for_function_pointers, move in file.
	(Target_arm::do_section_may_have_icf_unsafe_pointers): Rename from
	section_may_have_icf_unsafe_poineters, move in file.
	(Target_arm::arm_info): Initialize can_icf_inline_merge_sections.
	* i386.cc (Target_i386::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_i386::can_icf_inline_merge_sections): Remove.
	(Target_i386::i386_info): Initialize
	can_icf_inline_merge_sections.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Initialize can_icf_inline_merge_sections.
	* sparc.cc (Target_sparc::sparc_info) [both version]: Likewise.
	* x86_64.cc (Target_x86_64::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_x86_64::can_icf_inline_merge_sections): Remove.
	(Target_x86_64::x86_64_info): Initialize
	can_icf_inline_merge_sections.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Likewise.
	* icf.cc (get_section_contents): Correct formatting.
@
text
@d2127 6
a2132 3
		      (size == 64 ?
		       (big_endian ? "elf64-powerpc" : "elf64-powerpcle") :
		       (big_endian ? "elf32-powerpc" : "elf32-powerpcle")))
@


1.37
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d3 1
a3 1
// Copyright 2008, 2009, 2010 Free Software Foundation, Inc.
d386 1
d410 1
d434 1
d458 1
@


1.36
log
@gold/
	* symtab.h (Symbol::NON_PIC_REF): Remove.
	(Symbol::RELATIVE_REF, Symbol::TLS_REF): New Reference_flags.
	(Symbol::FUNCTION_CALL): Renumber.  Reword comment.
	(Symbol::needs_dynamic_reloc): Don't check NON_PIC_REF.
	(Symbol::use_plt_offset): Take a flags argument and pass it
	directly to needs_dynamic_reloc.  Restrict check for undefined
	weak symbols to function calls.
	* arm.cc (Target_arm::Scan::get_reference_flags): New function.
	(Target_arm::Scan::global): Use it.
	(Target_arm::Scan::scan_reloc_for_stub): Likewise.
	(Target_arm::Relocate::relocate): Likewise.
	(Target_arm::Relocate::should_apply_static_reloc): Replace flags
	parameter with an r_type parameter.  Use get_reference_flags
	to get the flags.
	(Target_arm::Relocate::relocate): Update accordingly.
	* i386.cc (Target_i386::Scan::get_reference_flags): New function.
	(Target_i386::Scan::reloc_needs_plt_for_ifunc): Use it.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocate::should_apply_static_reloc): Replace flags
	parameter with an r_type parameter.  Use get_reference_flags
	to get the flags.
	(Target_i386::Relocate::relocate): Update accordingly.
	* powerpc.cc (Target_powerpc::Scan::get_reference_flags): New function.
	(Target_powerpc::Scan::global): Use it.
	(Target_powerpc::Scan::scan_reloc_for_stub): Likewise.
	(Target_powerpc::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Scan::get_reference_flags): New function.
	(Target_sparc::Scan::global): Use it.
	(Target_sparc::Scan::scan_reloc_for_stub): Likewise.
	(Target_sparc::Relocate::relocate): Likewise.
	* x86_64.cc (Target_x86_64::Scan::get_reference_flags): New function.
	(Target_x86_64::Scan::reloc_needs_plt_for_ifunc): Use it.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
@
text
@d70 1
a70 1
	            Sized_relobj<size, big_endian>* object,
d84 1
a84 1
	      Sized_relobj<size, big_endian>* object,
d119 1
a119 1
			  Sized_relobj<size, big_endian>* object,
d196 1
a196 1
	  Sized_relobj<size, big_endian>* object,
d204 1
a204 1
	   Sized_relobj<size, big_endian>* object,
d213 1
a213 1
	          			Sized_relobj<size, big_endian>* ,
d224 1
a224 1
		   			 Sized_relobj<size, big_endian>* ,
d234 1
a234 1
    unsupported_reloc_local(Sized_relobj<size, big_endian>*,
d238 1
a238 1
    unsupported_reloc_global(Sized_relobj<size, big_endian>*,
d316 1
a316 1
		      Sized_relobj<size, big_endian>* object);
d333 1
a333 1
             Sized_relobj<size, big_endian>* object,
d499 1
a499 1
       const Sized_relobj<size, big_endian>* object,
d520 1
a520 1
	  const Sized_relobj<size, big_endian>* object,
d542 1
a542 1
	 const Sized_relobj<size, big_endian>* object,
d562 1
a562 1
		   const Sized_relobj<size, big_endian>* object,
d581 1
a581 1
	const Sized_relobj<size, big_endian>* object,
d590 1
a590 1
	const Sized_relobj<size, big_endian>* object,
d602 1
a602 1
	const Sized_relobj<size, big_endian>* object,
d620 1
a620 1
	 const Sized_relobj<size, big_endian>* object,
d643 1
a643 1
	    const Sized_relobj<size, big_endian>* object,
d659 1
a659 1
	    const Sized_relobj<size, big_endian>* object,
d687 1
a687 1
	    const Sized_relobj<size, big_endian>* object,
d705 1
a705 1
	const Sized_relobj<size, big_endian>* object,
d714 1
a714 1
	   const Sized_relobj<size, big_endian>* object,
d723 1
a723 1
	   const Sized_relobj<size, big_endian>* object,
d737 1
a737 1
	   const Sized_relobj<size, big_endian>* object,
d1071 4
a1074 3
Target_powerpc<size, big_endian>::got_mod_index_entry(Symbol_table* symtab,
						      Layout* layout,
						      Sized_relobj<size, big_endian>* object)
d1180 1
a1180 1
			Sized_relobj<size, big_endian>* object,
d1288 1
a1288 1
			Sized_relobj<size, big_endian>* object,
d1406 1
a1406 1
			Sized_relobj<size, big_endian>* object,
d1422 1
a1422 1
				Sized_relobj<size, big_endian>* object,
d1613 1
a1613 1
			Sized_relobj<size, big_endian>* object,
d1648 1
a1648 1
			Sized_relobj<size, big_endian>* object,
d1760 1
a1760 1
  const Sized_relobj<size, big_endian>* object = relinfo->object;
d1963 1
a1963 1
  const Sized_relobj<size, big_endian>* object = relinfo->object;
d2037 1
a2037 1
			Sized_relobj<size, big_endian>* object,
@


1.35
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d191 3
d1111 63
d1469 1
a1469 1
        if (gsym->needs_dynamic_reloc(Symbol::ABSOLUTE_REF))
d1519 1
a1519 4
	int flags = Symbol::NON_PIC_REF;
	if (gsym->type() == elfcpp::STT_FUNC)
	  flags |= Symbol::FUNCTION_CALL;
	if (gsym->needs_dynamic_reloc(flags))
d1748 1
a1748 6
      && gsym->use_plt_offset(r_type == elfcpp::R_POWERPC_REL24
			      || r_type == elfcpp::R_PPC_LOCAL24PC
			      || r_type == elfcpp::R_PPC_REL16
			      || r_type == elfcpp::R_PPC_REL16_LO
			      || r_type == elfcpp::R_PPC_REL16_HI
			      || r_type == elfcpp::R_PPC_REL16_HA))
@


1.34
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_GOT_PLT.

gold/ChangeLog:

	* arm.cc (Target_arm::got_size): Add const.
	(Target_arm::got_entry_count): New function.
	(Target_arm::plt_entry_count): New function.
	(Target_arm::first_plt_entry_offset): New function.
	(Target_arm::plt_entry_size): New function.
	(Output_data_plt_arm::entry_count): New function.
	(Output_data_plt_arm::first_plt_entry_offset): New function.
	(Output_data_plt_arm::get_plt_entry_size): New function.
	* i386.cc (Target_i386::got_size): Add const.
	(Target_i386::got_entry_count): New function.
	(Target_i386::plt_entry_count): New function.
	(Target_i386::first_plt_entry_offset): New function.
	(Target_i386::plt_entry_size): New function.
	(Output_data_plt_i386::entry_count): New function.
	(Output_data_plt_i386::first_plt_entry_offset): New function.
	(Output_data_plt_i386::get_plt_entry_size): New function.
	* incremental-dump.cc (dump_incremental_inputs): Adjust call to
	find_incremental_inputs_sections.  Dump incremental_got_plt section.
	* incremental.cc: Include target.h.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Add
	parameter.  Adjust all callers.  Find incremental_got_plt section.
	(Incremental_inputs::create_data_sections): Create incremental_got_plt
	section.
	(Output_section_incremental_inputs::set_final_data_size): Calculate
	size of incremental_got_plt section.
	(Output_section_incremental_inputs::do_write): Write the
	incremental_got_plt section.
	(Got_plt_view_info): New struct.
	(Local_got_offset_visitor): New class.
	(Global_got_offset_visitor): New class.
	(Global_symbol_visitor_got_plt): New class.
	(Output_section_incremental_inputs::write_got_plt): New function.
	* incremental.h (Incremental_binary::find_incremental_inputs_sections):
	Add parameter.  Adjust all callers.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Incremental_inputs::got_plt_section): New function.
	(Incremental_inputs::got_plt_section_): New data member.
	(Incremental_got_plt_reader): New class.
	* layout.cc (Layout::create_incremental_info_sections): Add the
	incremental_got_plt section.
	* object.h (Got_offset_list::get_list): New function.
	(Got offset_list::for_all_got_offsets): New function.
	(Sized_relobj::local_got_offset_list): New function.
	* powerpc.cc (Target_powerpc::got_size): Add const.
	(Target_powerpc::got_entry_count): New function.
	(Target_powerpc::plt_entry_count): New function.
	(Target_powerpc::first_plt_entry_offset): New function.
	(Target_powerpc::plt_entry_size): New function.
	(Output_data_plt_powerpc::entry_count): New function.
	(Output_data_plt_powerpc::first_plt_entry_offset): New function.
	(Output_data_plt_powerpc::get_plt_entry_size): New function.
	* sparc.cc (Target_sparc::got_size): Add const.
	(Target_sparc::got_entry_count): New function.
	(Target_sparc::plt_entry_count): New function.
	(Target_sparc::first_plt_entry_offset): New function.
	(Target_sparc::plt_entry_size): New function.
	(Output_data_plt_sparc::entry_count): New function.
	(Output_data_plt_sparc::first_plt_entry_offset): New function.
	(Output_data_plt_sparc::get_plt_entry_size): New function.
	* symtab.h (Symbol::got_offset_list): New function.
	(Symbol_table::for_all_symbols): New function.
	* target.h (Sized_target::got_entry_count): New function.
	(Sized_target::plt_entry_count): New function.
	(Sized_target::plt_entry_size): New function.
	* x86_64.cc (Target_x86_64::got_size): Add const.
	(Target_x86_64::got_entry_count): New function.
	(Target_x86_64::plt_entry_count): New function.
	(Target_x86_64::first_plt_entry_offset): New function.
	(Target_x86_64::plt_entry_size): New function.
	(Output_data_plt_x86_64::entry_count): New function.
	(Output_data_plt_x86_64::first_plt_entry_offset): New function.
	(Output_data_plt_x86_64::get_plt_entry_size): New function.
@
text
@d294 1
a294 1
    gold_assert (this->got2_ != NULL);
d302 1
a302 1
    gold_assert (this->toc_ != NULL);
@


1.33
log
@2010-08-03  Ian Lance Taylor  <iant@@google.com>

	PR 11805
	* layout.h (enum Output_section_order): Define.
	(class Layout): Update declarations.
	* layout.cc (Layout::get_output_section): Add order parameter.
	Remove is_interp, is_dynamic_linker_section, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.  Set order.
	(Layout::default_section_order): New function.
	(Layout::layout_eh_frame): Call add_output_section_to_nonload.
	* output.cc (Output_section::Output_section): Initialize order_.
	Don't initialize deleted fields.
	(Output_segment::Output_segment): Don't initialize deleted
	fields.
	(Output_segment::add_output_section_to_load): New function
	replacing add_output_section.  Change all callers to call this or
	add_output_section_to_nonload.
	(Output_segment::add_output_section_to_nonload): New function.
	(Output_segment::remove_output_section): Rewrite.
	(Output_segment::add_initial_output_data): Likewise.
	(Output_segment::has_any_data_sections): Likewise.
	(Output_segment::is_first_section_relro): Likewise.
	(Output_segment::maximum_alignment): Likewise.
	(Output_segment::has_dynamic_reloc): New function replacing
	dynamic_reloc_count.  Change all callers.
	(Output_segment::has_dynamic_reloc_list): New function replacing
	dynamic_reloc_count_list.  Change all callers.
	(Output_segment::set_section_addresses): Rewrite.
	(Output_segment::set_offset): Rewrite.
	(Output_segment::find_first_and_last_list): Remove.
	(Output_segment::set_tls_offsets): Rewrite.
	(Output_segment::first_section_load_address): Likewise.
	(Output_segment::output_section_count): Likewise.
	(Output_segment::section_with_lowest_load_address): Likewise.
	(Output_segment::write_section_headers): Likewise.
	(Output_segment::print_sections_to_map): Likewise.
	* output.h (class Output_data): Remove dynamic_reloc_count_
	field.  Add has_dynamic_reloc_ field.  Make bools into bitfields.
	(Output_data::add_dynamic_reloc): Rewrite.
	(Output_data::has_dynamic_reloc): New function.
	(Output_data::dynamic_reloc_count): Remove.
	(class Output_section): Add order_ field.  Remvoe is_relro_local_,
	is_last_relro_, is_first_non_relro_, is_interp_,
	is_dynamic_linker_section_ fields.  Add order and set_order
	functions.  Remove is_relro_local, set_is_relro_local,
	is_last_relro, set_is_last_relro, is_first_non_relro,
	set_is_first_non_relro functions, is_interp, set_is_interp,
	is_dynamic_linker_section, and set_is_dynamic_linker_section
	functions.
	(class Output_segment): Change Output_data_list from std::list to
	std:;vector.  Add output_lists_ field.  Remove output_data_ and
	output_bss_ fields.  Update declarations.
@
text
@d3 1
a3 1
// Copyright 2008, 2009 Free Software Foundation, Inc.
d154 1
a154 1
  got_size()
d160 21
d345 3
d835 15
d1035 29
@


1.32
log
@	* arm.cc (Target_arm::gc_process_relocs): Use typename.
	* powerpc.cc (Target_powerpc::gc_process_relocs): Likewise.
	* sparc.cc (Target_sparc::gc_process_relocs): Likewise.
@
text
@d741 1
a741 1
				      this->got_, false, false, false, false);
d750 1
a750 2
					  this->got2_, false, false, false,
					  false);
d758 1
a758 2
					  this->toc_, false, false, false,
					  false);
d785 2
a786 2
				      elfcpp::SHF_ALLOC, this->rela_dyn_, true,
				      false, false, false);
d846 2
a847 2
				  elfcpp::SHF_ALLOC, this->rel_, true, false,
				  false, false);
d981 1
a981 1
				      this->plt_, false, false, false, false);
d1545 3
a1547 2
							 sdata, false,
							 false, false, false);
@


1.31
log
@	* arm.cc (Target_arm<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* i386.cc (Target_i386<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* x86_64.cc (Target_x86_64<big_endian>::gc_process_relocs): Add template
	parameter to the call to gold::gc_process_relocs.
	* powerpc.cc (Target_powerpc<big_endian>::gc_process_relocs): Add
	template parameter to the call to gold::gc_process_relocs.
	* sparc.cc (Target_sparc<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* gc.h (get_embedded_addend_size): New function.
	(gc_process_relocs): Save the size of the reloc for use by ICF.
	* icf.cc (get_section_contents): Get the addend from the text section
	for SHT_REL relocation sections.
	* icf.h (Icf::Reloc_addend_size_info): New typedef.
	(Icf::Reloc_info): Add new member reloc_addend_size_info.
	* int_encoding.h (read_from_pointer): New overloaded function.
	* testsuite/Makefile.am (icf_sht_rel_addend_test): New test.
	* testsuite/icf_sht_rel_addend_test.sh: New file.
	* testsuite/icf_sht_rel_addend_test_1.cc: New file.
	* testsuite/icf_sht_rel_addend_test_2.cc: New file.
@
text
@d1497 1
a1497 1
			  Target_powerpc::Relocatable_size_for_reloc>(
@


1.30
log
@	* output.h (Output_section_lookup_maps::add_merge_section):
	Correct check of whether value was inserted.
	(Output_section_lookup_maps::add_merge_input_section): Likewise.
	(Output_section_lookup_maps::add_relaxed_input_section):
	Likewise.
	* arm.cc (Target_arm::got_section): Remove used local os.
	* i386.cc (Target_i386::got_section): Likewise.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* sparc.cc (Target_sparc::got_section): Likewise.
	(Target_sparc::relocate): Remove unused local have_got_offset.
	* powerpc.cc (Target_powerpc::relocate): Likewise.
@
text
@d1496 2
a1497 1
  gold::gc_process_relocs<size, big_endian, Powerpc, elfcpp::SHT_RELA, Scan>(
@


1.29
log
@2010-02-12  Sriraman Tallam  <tmsriram@@google.com>

	* arm.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* sparc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* powerpc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* i386.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* x86_64.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	(Scan::possible_function_pointer_reloc): New function.
	(Target_x86_64::can_check_for_function_pointers): New function.
	* gc.h (gc_process_relocs): Scan relocation types to determine if
	function pointers were taken for targets that support it.
	* icf.cc (Icf::find_identical_sections): Include functions for
	folding in safe ICF whose pointer is not taken.
	* icf.h (Secn_fptr_taken_set): New typedef.
	(fptr_section_id_): New member.
	(section_has_function_pointers): New function.
	(set_section_has_function_pointers): New function.
	(check_section_for_function_pointers): New function.
	* options.h: Fix comment for safe ICF option.
	* target.h (can_check_for_function_pointers): New function.
	* testsuite/Makefile.am: Add icf_safe_so_test test case.
	Modify icf_safe_test for X86-64.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/icf_safe_so_test.cc: New file.
	* testsuite/icf_safe_so_test.sh: New file.
	* testsuite/icf_safe_test.cc (kept_func_3): New function.
	(main): Change to take pointer to function kept_func_3.
	* testsuite/icf_safe_test.sh (arch_specific_safe_fold): Check if safe
	folding is done correctly for X86-64.
@
text
@a1638 1
  bool have_got_offset = false;
a1669 1
      have_got_offset = true;
a1681 1
      have_got_offset = true;
@


1.28
log
@	* output.h (Output_data_dynamic::add_section_size): New method
	that takes two Output_data objects.
	(Output_data_dynamic::Dynamic_entry): Create storage for secondary
	entry param.  Handle it in initializers.
	* output.cc (Output_data_dynamic::Dynamic_entry::write): For
	DYNAMIC_SECTION_SIZE, add in second object size if non-NULL.
	* layout.h (Layout::add_target_dynamic_tags): Add dynrel_includes_plt
	arg.
	* layout.cc (Layout::add_target_dynamic_tags): If dynrel_includes_plt,
	and .rela.plt exists, set DT_REL{,A}SZ to sum of .rela.dyn and .rela.plt
	* arm.cc (Target_arm::do_finalize_sections): Update to pass false
	for dynrel_includes_plt.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::make_plt_entry): Force .rela.dyn to be output
	before .rela.plt
	(Target_sparc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt.
	* powerpc.cc (Target_powerpc::make_plt_entry): Force .rela.dyn to be
	output before .rela.plt
	(Target_powerpc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt when 32-bit.
@
text
@d186 22
@


1.27
log
@	* output.h (class Output_data): Add const version of
	output_section and do_output_section.
	(class Output_section_data): Add const version of
	do_output_section.
	(class Output_section): Likewise.
	* layout.cc (Layout::add_target_dynamic_tags): New function.
	* layout.h (class Layout): Update declarations.
	* arm.cc (Target_arm::do_finalize_sections): Use
	add_target_dynamic_tags.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d951 5
d1564 1
a1564 1
				  this->rela_dyn_, true);
@


1.26
log
@	* layout.cc (Layout::Layout): Initialize increase_relro_.
	(Layout::get_output_section): Add is_relro, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::set_segment_offsets): Clear increase_relro when using a
	linker script.
	* layout.h (class Layout): Add increase_relro method.  Add
	increase_relro_ field.  Update declarations.
	* output.cc (Output_section::Output_section): Initialize
	is_last_relro_ and is_first_non_relro_.
	(Output_segment::add_output_section): Group relro sections is
	do_sort is true.  Handle is_last_relro and is_first_non_relro.
	(Output_segment::maximum_alignment): Remove relro handling.
	(Output_segment::set_section_addresses): Add increase_relro
	parameter.  Change all callers.  Add initial alignment to align
	relro sections on separate page.  Remove old relro handling.
	(Output_segment::set_section_list_addresses): Remove in_relro
	parameter.  Change all callers.
	(Output_segment::set_offset): Add increase parameter.  Change all
	callers.  Remove old relro handling.
	* output.h (class Output_section): Add new methods: is_last_relro,
	set_is_last_relro, is_first_non_relro, set_is_first_non_relro.
	Add is_last_relro_ and is_first_non_relro_ fields.
	* i386.cc (Target_i386::got_section): Don't call set_is_relro.
	Create separate .got.plt section.  Call increase_relro.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/relro_script_test.t: Add .got.plt.
@
text
@d1555 5
a1559 31
  Output_data_dynamic* const odyn = layout->dynamic_data();
  if (odyn != NULL)
    {
      if (this->plt_ != NULL
	  && this->plt_->output_section() != NULL)
	{
	  const Output_data* od = this->plt_->rel_plt();
	  odyn->add_section_size(elfcpp::DT_PLTRELSZ, od);
	  odyn->add_section_address(elfcpp::DT_JMPREL, od);
	  odyn->add_constant(elfcpp::DT_PLTREL, elfcpp::DT_RELA);

	  odyn->add_section_address(elfcpp::DT_PLTGOT, this->plt_);
	}

      if (this->rela_dyn_ != NULL
	  && this->rela_dyn_->output_section() != NULL)
	{
	  const Output_data* od = this->rela_dyn_;
	  odyn->add_section_address(elfcpp::DT_RELA, od);
	  odyn->add_section_size(elfcpp::DT_RELASZ, od);
	  odyn->add_constant(elfcpp::DT_RELAENT,
			     elfcpp::Elf_sizes<size>::rela_size);
	}

      if (!parameters->options().shared())
	{
	  // The value of the DT_DEBUG tag is filled in by the dynamic
	  // linker at run time, and used by the debugger.
	  odyn->add_constant(elfcpp::DT_DEBUG, 0);
	}
    }
@


1.25
log
@	* symtab.h (class Symbol_table): Add enum Defined.
	* resolve.cc (Symbol_table::should_override): Add defined
	parameter.  Change all callers.  Test whether object is NULL
	before calling a method on it.
	(Symbol_table::report_resolve_problem): Add defined parameter.
	Change all callers.
	(Symbol_table::should_override_with_special): Likewise.
	* symtab.cc (Symbol_table::define_in_output_data): Add defined
	parameter.  Change all callers.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::define_in_output_segment): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::define_as_constant): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* script.h (class Symbol_assignment): Add is_defsym parameter to
	constructor; change all callers.
	* script.cc (Script_options::add_symbol_assignment): Add is_defsym
	parameter.  Change all callers.  Add is_defsym_ field.
	(class Parser_closure): Add parsing_defsym parameter to
	constructor; change all callers.  Add parsing_defsym accessor
	function.  Add parsing_defsym_ field.
@
text
@d719 1
a719 1
				      this->got_, false);
d728 2
a729 1
					  this->got2_, false);
d737 2
a738 1
					  this->toc_, false);
d765 2
a766 1
				      elfcpp::SHF_ALLOC, this->rela_dyn_, true);
d826 2
a827 1
				  elfcpp::SHF_ALLOC, this->rel_, true);
d956 1
a956 1
				      this->plt_, false);
d1519 2
a1520 1
							 sdata, false);
@


1.24
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d741 1
d956 1
d1517 1
@


1.23
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d893 1
a893 1
  const off_t off = this->offset();
d896 1
a896 1
  unsigned char* const oview = of->get_output_view(off, oview_size);
d927 1
a927 1
  of->write_output_view(off, oview_size, oview);
d1461 1
a1461 1
  typedef typename Target_powerpc<size, big_endian>::Scan scan;
d1463 1
a1463 1
  gold::gc_process_relocs<size, big_endian, Powerpc, elfcpp::SHT_RELA, scan>(
d1495 1
a1495 1
  typedef typename Target_powerpc<size, big_endian>::Scan scan;
d1523 1
a1523 1
  gold::scan_relocs<size, big_endian, Powerpc, elfcpp::SHT_RELA, scan>(
d1995 1
a1995 1
  Target* do_recognize(int amachine, int, int)
d2000 1
a2000 1
	if (amachine != elfcpp::EM_PPC64)
d2005 1
a2005 1
	if (amachine != elfcpp::EM_PPC)
@


1.22
log
@2009-12-05  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:

	* arm.h: Define enums for Tag_CPU_arch EABI attribute.

gold/ChangeLog:
	* arm.cc (Target_arm::arm_info): Initialize new fields
	attributes_section and attributes_vendor.
	* i386.cc (Target_i386::i386_info): Same.
	* object.cc (Sized_relobj::do_layout): Skip attribute section.
	* gold/powerpc.cc (Target_powerpc::powerpc_info): Initialize new
	fields attributes_section and attributes_vendor.
 	* sparc.cc (Target_sparc::sparc_info): Same.
	* target.h (Target::attributes_section, Target::attributes_vendor,
	Target::is_attributes_section, Target::attribute_arg_type,
	Target::attributes_order): New method definitions.
	(Target::Target_info::attributes_section,
	Target::Target_info::attributes_vendor): New fields.
	(Target::do_attribute_arg_type, Target::do_attributes_order): New
	virtual method definitions.
	* x86_64.cc (Target_x86_64::x86_64_info): Initialize new fields
	attributes_section and attributes_vendor.
	* testsuite/testfile.cc (Target_test::test_target_info): Same.
@
text
@d893 1
a893 1
  const off_t offset = this->offset();
d896 1
a896 1
  unsigned char* const oview = of->get_output_view(offset, oview_size);
d927 1
a927 1
  of->write_output_view(offset, oview_size, oview);
d1461 1
a1461 1
  typedef typename Target_powerpc<size, big_endian>::Scan Scan;
d1463 1
a1463 1
  gold::gc_process_relocs<size, big_endian, Powerpc, elfcpp::SHT_RELA, Scan>(
d1495 1
a1495 1
  typedef typename Target_powerpc<size, big_endian>::Scan Scan;
d1523 1
a1523 1
  gold::scan_relocs<size, big_endian, Powerpc, elfcpp::SHT_RELA, Scan>(
d1995 1
a1995 1
  Target* do_recognize(int machine, int, int)
d2000 1
a2000 1
	if (machine != elfcpp::EM_PPC64)
d2005 1
a2005 1
	if (machine != elfcpp::EM_PPC)
@


1.21
log
@2009-12-03  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Remove comment about missing .ARM.exidx section symbols.
	(Target_arm::do_finalize_sections): Add parameter for symbol table
	pointer.  Add __exidx_start and __exidx_end symbols as appropriate.
	* i386.cc (Target_i386::do_finalize_sections): Add an additional
	parameter for symbol table pointer.
	* layout.cc (Layout::finalize): Call Target::finalize_sections with
	an additional parameter for a pointer to symbol table.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add an additional
	parameter for a symbol table pointer.
	* sparc.cc (Target_sparc::do_finalize_sections): Ditto.
	* target.h (Target::finalize_sections, Target::do_finalize_sections):
	Ditto.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add an additional
	parameter for a symbol table pointer.
@
text
@d345 3
a347 1
  0			// large_common_section_flags
d368 3
a370 1
  0			// large_common_section_flags
d391 3
a393 1
  0			// large_common_section_flags
d414 3
a416 1
  0			// large_common_section_flags
@


1.20
log
@	PR 10887
	* arm.cc (Target_arm::do_finalize_sections): Don't add dynamic
	tags if data is discarded by linker script.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d95 1
a95 1
  do_finalize_sections(Layout*, const Input_objects*);
d1535 2
a1536 1
    const Input_objects*)
@


1.19
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d1541 2
a1542 1
      if (this->plt_ != NULL)
d1552 2
a1553 1
      if (this->rela_dyn_ != NULL)
@


1.18
log
@2009-10-30  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:
	* arm.h (EF_ARM_BE8, EF_ARM_EABIMASK, EF_ARM_EABI_UNKNOWN,
	EF_ARM_EABI_VER1, EF_ARM_EABI_VER2, EF_ARM_EABI_VER3,
	EF_ARM_EABI_VER4, EF_ARM_EABI_VER5): New enums for processor-specific
	flags.
	(arm_eabi_version): New inline function.
	* elfcpp.h: Add a comment about DT_ENCODING.

gold/ChangeLog:
	* arm.cc (Arm_relobj::processor_specific_flags): New method
	definition.
	(Arm_relobj::do_read_symbols): New method declaration.
	(Arm_relobj::processor_specific_flags_): New data member declaration.
	(Arm_dynobj): New class definition.
	(Target_arm::do_finalize_sections): Add input_objects parameter.
	(Target_arm::do_adjust_elf_header): New method declaration.
	(Target_arm::are_eabi_versions_compatible,
	(Target_arm::merge_processor_specific_flags): New method declaration.
	(Target_arm::do_make_elf_object): New overloaded method definitions
	and declaration.
	(Arm_relobj::do_read_symbols): New method definition.
	(Arm_dynobj::do_read_symbols): Ditto.
	(Target_arm::do_finalize_sections): Add input_objects parameters.
	Merge processor-specific flags from all input objects.
	(Target_arm::are_eabi_versions_compatible,
	Target_arm::merge_processor_specific_flags,
	Target_arm::do_adjust_elf_header, Target_arm::do_make_elf_object):
	New method definitions.
	* i386.cc (Target_i386::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* layout.cc (Layout::finalize): Pass input objects to target's.
	finalize_sections function.
	* output.cc (Output_file_header::do_sized_write): Set ELF file
	header's processor-specific flags.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* sparc.cc (Target_sparc::do_finalize_sections): Same.
	* target.h (Input_objects): New forward class declaration.
	(Target::processor_specific_flags,
	Target::are_processor_specific_flags_sect): New method definitions.
	(Target::finalize_sections): Add input_objects parameter.
	(Target::Target): Initialize processor_specific_flags_ and
	are_processor_specific_flags_set_.
	(Target::do_finalize_sections): Add unnamed Input_objects pointer type
	parameter.
	(Target::set_processor_specific_flags): New method definition.
	(Target::processor_specific_flags_,
	Target::are_processor_specific_flags_set_): New data member
	declarations.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
@
text
@d711 1
a711 1
				      this->got_);
d720 1
a720 1
					  this->got2_);
d728 1
a728 1
					  this->toc_);
d754 1
a754 1
				      elfcpp::SHF_ALLOC, this->rela_dyn_);
d814 1
a814 1
				  elfcpp::SHF_ALLOC, this->rel_);
d943 1
a943 1
				      this->plt_);
d1505 1
a1505 1
							 sdata);
@


1.17
log
@	* object.h (class Relobj): Drop options parameter from
	gc_process_relocs, scan_relocs, relocate, do_gc_process_relocs,
	do_scan_relocs, do_relocate.  Change all callers.
	(class Sized_relobj): Drop options parameters from
	do_gc_process_relocs, do_scan_relocs, do_relocate,
	do_relocate_sections, relocate_sections, emit_relocs_scan,
	emit_relocs_scan_reltype.  Change all callers.
	(struct Relocate_info): Remove options field and all references to
	it.
	* reloc.h (class Read_relocs): Remove options constructor
	parameter and options_ field.  Change all callers.
	(class Gc_process_relocs, class Scan_relocs): Likewise.
	(class Relocate_task): Likewise.
	* target-reloc.h (scan_relocs): Remove options parameter.  Change
	all callers.
	(scan_relocatable_relocs): Likewise.
	* target.h (class Sized_target): Remove options parameter from
	gc_process_relocs, scan_relocs, scan_relocatable_relocs.  Change
	all callers.
	* gc.h (gc_process_relocs): Remove options parameter.  Change all
	callers.
	* arm.cc: Update functions to remove options parameters.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* testsuite/testfile.cc: Likewise.
@
text
@d95 1
a95 1
  do_finalize_sections(Layout*);
d1533 3
a1535 1
Target_powerpc<size, big_endian>::do_finalize_sections(Layout* layout)
@


1.16
log
@	* symtab.h: Check for GOLD_SYMTAB_H before header includes. Remove
	includes to gc.h and icf.h.
	* arm.cc: Include gc.h.
	* gold.cc: Likewise.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* gc.h: Include icf.h.
@
text
@d68 1
a68 2
  gc_process_relocs(const General_options& options,
	            Symbol_table* symtab,
d82 1
a82 2
  scan_relocs(const General_options& options,
	      Symbol_table* symtab,
d117 1
a117 2
  scan_relocatable_relocs(const General_options& options,
			  Symbol_table* symtab,
d171 1
a171 2
    local(const General_options& options, Symbol_table* symtab,
	  Layout* layout, Target_powerpc* target,
d179 1
a179 2
    global(const General_options& options, Symbol_table* symtab,
	   Layout* layout, Target_powerpc* target,
a1110 1
			const General_options&,
a1244 1
				const General_options&,
a1439 1
			const General_options& options,
a1455 1
    options,
a1473 1
			const General_options& options,
a1515 1
    options,
a1888 1
			const General_options& options,
a1908 1
    options,
@


1.15
log
@	* options.h (class General_options): Define
	split_stack_adjust_size parameter.
	* object.h (class Object): Add uses_split_stack_ and
	has_no_split_stack_ fields.  Add uses_split_stack and
	has_no_split_stack accessor functions.  Declare
	handle_split_stack_section.
	(class Reloc_symbol_changes): Define.
	(class Sized_relobj): Define Function_offsets.  Declare
	split_stack_adjust, split_stack_adjust_reltype, and
	find_functions.
	* object.cc (Object::handle_split_stack_section): New function.
	(Sized_relobj::do_layout): Call handle_split_stack_section.
	* dynobj.cc (Sized_dynobj::do_layout): Call
	handle_split_stack_section.
	* reloc.cc (Sized_relobj::relocate_sections): Call
	split_stack_adjust for executable sections in split_stack
	objects.  Pass reloc_map to relocate_section.
	(Sized_relobj::split_stack_adjust): New function.
	(Sized_relobj::split_stack_adjust_reltype): New function.
	(Sized_relobj::find_functions): New function.
	* target-reloc.h: Include "object.h".
	(relocate_section): Add reloc_symbol_changes parameter.  Change
	all callers.
	* target.h (class Target): Add calls_non_split method.  Declare
	do_calls_non_split virtual method.  Declare match_view and
	set_view_to_nop.
	* target.cc: Include "elfcpp.h".
	(Target::do_calls_non_split): New function.
	(Target::match_view): New function.
	(Target::set_view_to_nop): New function.
	* gold.cc (queue_middle_tasks): Give an error if mixing
	split-stack and non-split-stack objects with -r.
	* i386.cc (Target_i386::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_i386::do_calls_non_split): New function.
	* x86_64.cc (Target_x86_64::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_x86_64::do_calls_non_split): New function.
	* arm.cc (Target_arm::relocate_section): Add reloc_symbol_changes
	parameter.
	* powerpc.cc (Target_powerpc::relocate_section): Add
	reloc_symbol_changes parameter.
	* sparc.cc (Target_sparc::relocate_section): Add
	reloc_symbol_changes parameter.
	* configure.ac: Call AM_CONDITIONAL for the default target.
	* configure: Rebuild.
	* testsuite/Makefile.am (TEST_AS): New variable.
	(check_SCRIPTS): Add split_i386.sh and split_x86_64.sh.
	(check_DATA): Add split_i386 and split_x86_64 files.
	(SPLIT_DEFSYMS): Define.
	(split_i386_[1234n].o): New targets.
	(split_i386_[124]): New targets.
	(split_i386_[1234r].stdout): New targets.
	(split_x86_64_[1234n].o): New targets.
	(split_x86_64_[124]): New targets.
	(split_x86_64_[1234r].stdout): New targets.
	(MOSTLYCLEANFILES): Add new executables.
	* testsuite/split_i386.sh: New file.
	* testsuite/split_x86_64.sh: New file.
	* testsuite/split_i386_1.s: New file.
	* testsuite/split_i386_2.s: New file.
	* testsuite/split_i386_3.s: New file.
	* testsuite/split_i386_4.s: New file.
	* testsuite/split_i386_n.s: New file.
	* testsuite/split_x86_64_1.s: New file.
	* testsuite/split_x86_64_2.s: New file.
	* testsuite/split_x86_64_3.s: New file.
	* testsuite/split_x86_64_4.s: New file.
	* testsuite/split_x86_64_n.s: New file.
	* testsuite/testfile.cc (Target_test): Update relocation_section
	function.
	* testsuite/Makefile.in: Rebuild.
@
text
@d40 1
@


1.14
log
@2009-09-30  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::may_need_copy_reloc): Check for THUMB function
	symbol and call Symbol::may_need_copy_reloc to determine if
	a copy reloc is needed.
	* copy-relocs.cc (Copy_relocs::need_copy_reloc): Return false if -z
	nocopyreloc is given in command line.
	(Copy_relocs::emit_copy_reloc): Assert that -z nocopyreloc is not
	given in command line.
	* i386.cc (Target_i386::may_need_copy_reloc): Remove.
	(Target_i386::Scan::global): Use Symbol::may_need_copy_reloc instead
	of the removed Target_i386::may_need_copy_reloc.
	* options.h (copyreloc): New option with default value false.
	* powerpc.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_powerpc::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_powerpc::may_need_copy_reloc.
	* sparc.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_sparc::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_sparc::may_need_copy_reloc.
	* symtab.h (Symbol::may_need_copy_reloc): New method definition.
	* x86_64.cc (Target_powerpc::may_need_copy_reloc): Remove.
	(Target_x86_64::Scan::global): Use Symbol::may_need_copy_reloc
	instead of the removed Target_x86_64::may_need_copy_reloc.
@
text
@d113 2
a114 1
		   section_size_type view_size);
d1858 2
a1859 1
			section_size_type view_size)
d1876 2
a1877 1
    view_size);
@


1.13
log
@	* layout.cc (Layout::make_output_section): Call
	Target::new_output_section.
	(Layout::attach_allocated_section_to_segment): Put large section
	sections in a separate load segment with the large segment flag
	set.
	(Layout::segment_precedes): Sort large data segments after other
	load segments.
	(align_file_offset): New static function.
	(Layout::set_segment_offsets): Use align_file_offset.
	* output.h (class Output_section): Add is_small_section_ and
	is_large_section_ fields.
	(Output_section::is_small_section): New function.
	(Output_section::set_is_small_section):  New function.
	(Output_section::is_large_section): New function.
	(Output_section::set_is_large_section): New function.
	(Output_section::is_large_data_section): New function.
	(class Output_segment): Add is_large_data_segment_ field.
	(Output_segment::is_large_data_segment): New function.
	(Output_segment::set_is_large_data_segment): New function.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_segment::Output_segment): Likewise.
	(Output_segment::add_output_section): Add assertion that large
	data sections always go in large data segments.  Force small data
	sections to the end of the list of data sections.  Force small BSS
	sections to the start of the list of BSS sections.  For large BSS
	sections to the end of the list of BSS sections.
	* symtab.h (class Symbol): Declare is_common_shndx.
	(Symbol::is_defined): Check Symbol::is_common_shndx.
	(Symbol::is_common): Likewise.
	(class Symbol_table): Define enum Commons_section_type.  Update
	declarations.  Add small_commons_ and large_commons_ fields.
	* symtab.cc (Symbol::is_common_shndx): New function.
	(Symbol_table::Symbol_table): Initialize new fields.
	(Symbol_table::add_from_object): Put small and large common
	symbols in the right list.
	(Symbol_table::sized_finalized_symbol): Check
	Symbol::is_common_shndx.
	(Symbol_table::sized_write_globals): Likewise.
	* common.cc (Symbol_table::do_allocate_commons): Allocate new
	common symbol lists.  Don't call do_allocate_commons_list if the
	list is empty.
	(Symbol_table::do_allocate_commons_list): Remove is_tls
	parameter.  Add comons_section_type parameter.  Change all
	callers.  Handle small and large common symbols.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Check
	Symbol::is_common_shndx.
	* resolve.cc (symbol_to_bits): Likewise.
	* target.h (Target::small_common_shndx): New function.
	(Target::small_common_section_flags): New function.
	(Target::large_common_shndx): New function.
	(Target::large_common_section_flags): New function.
	(Target::new_output_section): New function.
	(Target::Target_info): Add small_common_shndx, large_common_shndx,
	small_common_section_flags, and large_common_section_flags
	fields.
	(Target::do_new_output_section): New virtual function.
	* arm.cc (Target_arm::arm_info): Initialize new fields.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Likewise.
	* sparc.c (Target_sparc::sparc_info) [all versions]: Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	(Target_x86_64::do_new_output_section): New function.
	* configure.ac: Define conditional MCMODEL_MEDIUM.
	* testsuite/Makefile.am (check_PROGRAMS): Add large.
	(large_SOURCES, large_CFLAGS, large_DEPENDENCIES): Define.
	(large_LDFLAGS): Define.
	* testsuite/large.c: New file.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Initialize new fields.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@a286 11
  // Return true if the symbol may need a COPY relocation.
  // References from an executable object to non-function symbols
  // defined in a dynamic object may need a COPY relocation.
  bool
  may_need_copy_reloc(Symbol* gsym)
  {
    return (!parameters->options().shared()
            && gsym->is_from_dynobj()
            && gsym->type() != elfcpp::STT_FUNC);
  }

d1303 1
a1303 1
            if (target->may_need_copy_reloc(gsym))
d1356 1
a1356 1
	    if (target->may_need_copy_reloc(gsym))
@


1.13.4.1
log
@Merge elfcpp and gold from trunk.
@
text
@a39 1
#include "gc.h"
d113 1
a113 2
		   section_size_type view_size,
		   const Reloc_symbol_changes*);
d287 11
d1314 1
a1314 1
            if (gsym->may_need_copy_reloc())
d1367 1
a1367 1
	    if (gsym->may_need_copy_reloc())
d1868 1
a1868 2
			section_size_type view_size,
			const Reloc_symbol_changes* reloc_symbol_changes)
d1885 1
a1885 2
    view_size,
    reloc_symbol_changes);
@


1.13.4.2
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d716 1
a716 1
				      this->got_, false);
d725 1
a725 1
					  this->got2_, false);
d733 1
a733 1
					  this->toc_, false);
d759 1
a759 1
				      elfcpp::SHF_ALLOC, this->rela_dyn_, true);
d819 1
a819 1
				  elfcpp::SHF_ALLOC, this->rel_, true);
d948 1
a948 1
				      this->plt_, false);
d1515 1
a1515 1
							 sdata, false);
@


1.13.4.3
log
@	PR 10887
	* arm.cc (Target_arm::do_finalize_sections): Don't add dynamic
	tags if data is discarded by linker script.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d1550 1
a1550 2
      if (this->plt_ != NULL
	  && this->plt_->output_section() != NULL)
d1560 1
a1560 2
      if (this->rela_dyn_ != NULL
	  && this->rela_dyn_->output_section() != NULL)
@


1.12
log
@	* powerpc.cc (Target_powerpc::check_non_pic): Assert that output is
	position independent.
	* sparc.cc (Target_sparc::check_non_pic): Likewise.
	* x86_64.cc (Target_x86_64::check_non_pic): Likewise.
@
text
@d355 5
a359 1
  4 * 1024		// common_pagesize (overridable by -z common-page-size)
d376 5
a380 1
  4 * 1024		// common_pagesize (overridable by -z common-page-size)
d397 5
a401 1
  8 * 1024		// common_pagesize (overridable by -z common-page-size)
d418 5
a422 1
  8 * 1024		// common_pagesize (overridable by -z common-page-size)
@


1.11
log
@2009-03-23  Ian Lance Taylor  <iant@@google.com>

	* gold-threads.h (class Initialize_lock): Define.
	* gold-threads.cc (class Initialize_lock_once): Define.
	(initialize_lock_control): New static variable.
	(initialize_lock_pointer): New static variable.
	(initialize_lock_once): New static function.
	(Initialize_lock::Initialize_lock): Define.
	(Initialize_lock::initialize): Define.
	* target-select.h: Include "gold-threads.h".
	(class Target_selector): Add lock_ and initialize_lock_ fields.
	Don't define instantiate_target, just declare it.
	* target-select.cc (Target_selector::Target_selector): Initialize
	new fields.
	(Target_selector::instantiate_target): Define.
	* descriptors.h: Include "gold-threads.h".
	(class Descriptors): Add initialize_lock_ field.
	* descriptors.cc (Descriptors::Descriptors): Initialize new
	field.
	(Descriptors::open): Use initialize_lock_ field
	* errors.h (class Errors): Add initialize_lock_ field.
	* errors.cc (Errors::Errors): Initialize new field.
	(Errors::initialize_lock): Use initialize_lock_ field.
	* powerpc.cc (class Target_selector_powerpc): Remove
	instantiated_target_ field.  In do_recognize call
	instantiate_target rather than do_instantiate_target.  In
	do_instantiate_target just allocate a new target.
	* sparc.cc (class Target_selector_sparc): Likewise.
@
text
@d1097 1
@


1.10
log
@	PR 9918
	* target-reloc.h (relocate_section): Pass output_section to
	relocate.
	* i386.cc (Target_i386::should_apply_static_reloc): Add
	output_section parameter.  Change all callers.
	(Target_i386::Relocate::relocate): Add output_section parameter.
	* x86_64.cc (Target_x86_64::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Relocate::relocate): Likewise.
	* powerpc.cc (Target_powerpc::Relocate::relocate): Likewise.
	* testsuite/two_file_shared.sh: New script.
	* testsuite/Makefile.am (check_SCRIPTS): Add two_file_shared.sh.
	(check_DATA): Add two_file_shared.dbg.
	(two_file_shared.dbg): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@a1984 2
  Target* instantiated_target_;

d2003 1
a2003 1
    return do_instantiate_target();
d2007 1
a2007 5
  {
    if (this->instantiated_target_ == NULL)
      this->instantiated_target_ = new Target_powerpc<size, big_endian>();
    return this->instantiated_target_;
  }
@


1.9
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d217 2
a218 1
	     size_t relnum, const elfcpp::Rela<size, big_endian>&,
d1582 1
@


1.8
log
@* powerpc.cc (Powerpc_relocate_functions::rel16_ha): Don't try to
read the value in the contents, since we don't use it.  Use the
template endianness when writing.
(Relocate::relocate): Use it for R_PPC_REL16_HA.
@
text
@d3 1
a3 1
// Copyright 2008 Free Software Foundation, Inc.
d64 16
d1433 36
@


1.7
log
@	* target-reloc.h (relocate_section): Check whether a symbol is
	defined by the ABI before reporting an undefined symbol error.
	* target.h (Target::is_defined_by_abi): Make parameter const.
	(Target::do_is_defined_by_abi): Likewise.
	* i386.cc (Target_i386::do_is_defined_by_abi): Likewise.
	* powerpc.cc (Target_powerpc::do_is_defined_by_abi): Likewise.
	* sparc.cc (Target_sparc::do_is_defined_by_abi): Likewise.
	* x86_64.cc (Target_x86_64::do_is_defined_by_abi): Likewise.
	* testsuite/Makefile.am (tls_test_shared.so): Add -Wl,-z,defs.
	* testsuite/Makefile.in: Rebuild.
@
text
@a665 3
    typedef typename elfcpp::Swap<16, true>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<16, true>::readval(wv);
d673 1
a673 4
    val &= ~static_cast<Valtype>(0xffff);
    reloc &= static_cast<Valtype>(0xffff);

    elfcpp::Swap<16, true>::writeval(wv, val | reloc);
d1678 1
a1678 1
      Reloc::rel16_lo(view, object, psymval, addend, address);
@


1.6
log
@	* symtab.h (Symbol::use_plt_offset): New function.
	* i386.cc (Relocate::relocate): Call Symbol::use_plt_offset.
	* powerpc.cc (Relocate::relocate): Likewise.
	* sparc.cc (Relocate::relocate): Likewise.
	* x86_64.cc (Relocate::relocate): Likewise.
	* testsuite/weak_plt.sh: New test.
	* testsuite/weak_plt_main.cc: New test.
	* testsuite/weak_plt_shared.cc: New test.
	* testsuite/Makefile.am (check_SCRIPTS): Add weak_plt.sh.
	(check_PROGRAMS): Add weak_plt.
	(check_DATA): Add weak_plt_shared.so.
	(weak_plt_main_pic.o, weak_plt): New targets.
	(weak_plt_shared_pic.o, weak_plt_shared.so): New targets.
	* testsuite/Makefile.in: Rebuild.

	* testsuite/Makefile.am (weak_alias_test_1.so): Depend upon
	gcctestdir/ld.
	(weak_alias_test_2.so, weak_alias_test_4.so): Likewise.
	* testsuite/Makefile.in: Rebuild.
@
text
@d132 1
a132 1
  do_is_defined_by_abi(Symbol* sym) const
@


1.5
log
@	Handle output sections with more than 0x7fffffff bytes.
	* object.h (class Relobj): Change map_to_output_ to
	output_sections_, and just keep a section pointer.  Change all
	uses.  Move comdat group support to Sized_relobj.
	(Relobj::is_section_specially_mapped): Remove.
	(Relobj::output_section): Remove poff parameter.  Change all
	callers.
	(Relobj::output_section_offset): New function.
	(Relobj::set_section_offset): Rewrite.
	(Relobj::map_to_output): Remove.
	(Relobj::output_sections): New function.
	(Relobj::do_output_section_offset): New pure virtual function.
	(Relobj::do_set_section_offset): Likewise.
	(class Sized_relobj): Add section_offsets_ field.  Add comdat
	group support from Relobj.  Update declarations.
	(Sized_relobj::get_output_section_offset): New function.
	(Sized_relobj::do_output_section_offset): New function.
	(Sized_relobj::do_set_section_offset): New function.
	* object.cc (Relobj::output_section_address): Remove.
	(Sized_relobj::Sized_relobj): Initialize new fields.
	(Sized_relobj::include_section_group): Cast find_kept_object to
	Sized_relobj.
	(Sized_relobj::include_linkonce_section): Likewise.
	(Sized_relobj::do_layout): Use separate arrays for output section
	and output offset.
	(Sized_relobj::do_count_local_symbols): Change map_to_output to
	output_sections.
	(Sized_relobj::do_finalize_local_symbols): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_local_symbols): Likewise.
	(map_to_kept_section): Compute output address directly.
	* reloc.cc (Sized_relobj::do_read_relocs): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_sections): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (sized_finalize_symbol): Use output_section_offset.
	* output.h (class Output_reloc): Update declarations.  Change
	u2_.relobj to Sized_relobj*.
	(class Output_data_reloc): Change add functions to use
	Sized_relobj*.
	* output.cc (Output_reloc::Output_reloc): Change relobj to
	Sized_relobj*.
	(Output_reloc::local_section_offset): Change return type to
	Elf_Addr.  Use get_output_section_offset.
	(Output_reloc::get_address): Likewise.
	(Output_section::is_input_address_mapped): Don't call
	is_section_specially_mapped.
	(Output_section::output_offset): Likewise.
	(Output_section::output_address): Likewise.
	(Output_section::starting_output_address): Likewise.
	* copy-relocs.cc (Copy_relocs::copy_reloc): Change object
	parameter to Sized_relobj*.
	(Copy_relocs::need_copy_reloc): Likewise.
	(Copy_relocs::save): Likewise.
	* copy-relocs.h (class Copy_relocs): Update declarations.
	(class Copy_relocs::Copy_reloc_entry): Change constructor to use
	Sized_relobj*.  Change relobj_ field to Sized_relobj*.
	* target-reloc.h (relocate_for_relocatable): Change
	offset_in_output_section type to Elf_Addr.  Change code that uses
	it as well.
	* layout.cc (Layout::layout): Always set *off.
	* mapfile.cc (Mapfile::print_input_section): Use
	output_section_offset.
	* i386.cc (Target_i386::copy_reloc): Change object parameter to
	Sized_relobj*.
	* powerpc.cc (Target_powerpc::copy_reloc): Likewise.
	* sparc.cc (Target_sparc::copy_reloc): Likewise.
	* x86_64.cc (Target_x86_64::copy_reloc): Likewise.
@
text
@d1550 6
a1555 4
      && (gsym->is_from_dynobj()
          || (parameters->options().shared()
              && (gsym->is_undefined() || gsym->is_preemptible())))
      && gsym->has_plt_offset())
@


1.4
log
@	PR 6660
	PR 6682
	* powerpc.cc (Powerpc_relocate_functions::addr16_ha) [both
	versions]: Don't try to read the value in the contents, since we
	don't use it.  Use the template endianness when writing.
@
text
@d283 2
a284 1
  copy_reloc(Symbol_table* symtab, Layout* layout, Relobj* object,
@


1.3
log
@2008-06-18  Craig Silverstein  <csilvers@@google.com>

	* powerpc.cc (Powerpc_relocate_functions::addr16_ha): cast
	constant 0xFFFF to type Valtype.
	(Powerpc_relocate_functions::rel16_ha): Likewise.
@
text
@a596 3
    typedef typename elfcpp::Swap<16, true>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<16, true>::readval(wv);
d605 1
a605 4
    val &= ~static_cast<Valtype>(0xffff);
    reloc &= static_cast<Valtype>(0xffff);

    elfcpp::Swap<16, true>::writeval(wv, val | reloc);
a613 3
    typedef typename elfcpp::Swap<16, true>::Valtype Valtype;
    Valtype* wv = reinterpret_cast<Valtype*>(view);
    Valtype val = elfcpp::Swap<16, true>::readval(wv);
d622 1
a622 4
    val &= ~static_cast<Valtype>(0xffff);
    reloc &= static_cast<Valtype>(0xffff);

    elfcpp::Swap<16, true>::writeval(wv, val | reloc);
@


1.2
log
@        * powerpc.cc (Output_data_plt_powerpc::do_write): 8 + 4 = 0xC.
@
text
@d608 2
a609 2
    val &= ~0xffff;
    reloc &= 0xffff;
d631 2
a632 2
    val &= ~0xffff;
    reloc &= 0xffff;
d687 2
a688 2
    val &= ~0xffff;
    reloc &= 0xffff;
@


1.1
log
@2008-06-12  David Edelsohn  <edelsohn@@gnu.org>
            David S. Miller  <davem@@davemloft.net>

        * powerpc.cc: New file.
        * Makefile.am (TARGETSOURCES): Add powerpc.cc
        (ALL_TARGETOBJS): Add powerpc.$(OBJEXT)
        * configure.tgt: Add entries for powerpc-* and powerpc64-*.
        * Makefile.in: Rebuild.
@
text
@d909 1
a909 1
	  elfcpp::Swap<32, true>::writeval(pov + 0x0b, nop);
@

