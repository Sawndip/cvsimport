head	1.150;
access;
symbols
	binutils-2_24-branch:1.148.0.2
	binutils-2_24-branchpoint:1.148
	binutils-2_21_1:1.116.2.2
	binutils-2_23_2:1.135
	binutils-2_23_1:1.135
	binutils-2_23:1.135
	binutils-2_23-branch:1.135.0.2
	binutils-2_23-branchpoint:1.135
	binutils-2_22_branch:1.128.0.4
	binutils-2_22:1.128
	binutils-2_22-branch:1.128.0.2
	binutils-2_22-branchpoint:1.128
	binutils-2_21:1.116.2.1
	binutils-2_21-branch:1.116.0.2
	binutils-2_21-branchpoint:1.116
	binutils-2_20_1:1.81.2.2
	binutils-2_20:1.81.2.1
	binutils-arc-20081103-branch:1.76.0.4
	binutils-arc-20081103-branchpoint:1.76
	binutils-2_20-branch:1.81.0.2
	binutils-2_20-branchpoint:1.81
	dje-cgen-play1-branch:1.80.0.2
	dje-cgen-play1-branchpoint:1.80
	arc-20081103-branch:1.76.0.2
	arc-20081103-branchpoint:1.76
	binutils-2_19_1:1.75
	binutils-2_19:1.75
	binutils-2_19-branch:1.75.0.2
	binutils-2_19-branchpoint:1.75
	binutils_latest_snapshot:1.150
	added-to-binutils:1.57;
locks; strict;
comment	@ * @;


1.150
date	2013.10.14.02.53.01;	author amodra;	state Exp;
branches;
next	1.149;

1.149
date	2013.10.11.22.02.21;	author roland;	state Exp;
branches;
next	1.148;

1.148
date	2013.08.27.21.49.48;	author roland;	state Exp;
branches
	1.148.2.1;
next	1.147;

1.147
date	2013.05.30.23.01.11;	author ccoutant;	state Exp;
branches;
next	1.146;

1.146
date	2013.01.24.18.49.54;	author tmsriram;	state Exp;
branches;
next	1.145;

1.145
date	2013.01.10.00.18.14;	author tmsriram;	state Exp;
branches;
next	1.144;

1.144
date	2012.12.12.03.41.40;	author amodra;	state Exp;
branches;
next	1.143;

1.143
date	2012.12.03.05.48.47;	author amodra;	state Exp;
branches;
next	1.142;

1.142
date	2012.12.03.05.30.59;	author amodra;	state Exp;
branches;
next	1.141;

1.141
date	2012.10.05.00.45.54;	author amodra;	state Exp;
branches;
next	1.140;

1.140
date	2012.09.10.23.05.54;	author amodra;	state Exp;
branches;
next	1.139;

1.139
date	2012.09.05.00.34.20;	author amodra;	state Exp;
branches;
next	1.138;

1.138
date	2012.08.30.05.54.59;	author amodra;	state Exp;
branches;
next	1.137;

1.137
date	2012.08.24.18.35.34;	author tmsriram;	state Exp;
branches;
next	1.136;

1.136
date	2012.08.11.04.41.28;	author amodra;	state Exp;
branches;
next	1.135;

1.135
date	2012.07.10.14.54.29;	author ian;	state Exp;
branches
	1.135.2.1;
next	1.134;

1.134
date	2012.04.17.01.50.39;	author davem;	state Exp;
branches;
next	1.133;

1.133
date	2012.01.04.00.18.23;	author ccoutant;	state Exp;
branches;
next	1.132;

1.132
date	2011.12.19.21.07.16;	author ian;	state Exp;
branches;
next	1.131;

1.131
date	2011.12.16.23.47.03;	author ian;	state Exp;
branches;
next	1.130;

1.130
date	2011.10.10.17.29.52;	author ccoutant;	state Exp;
branches;
next	1.129;

1.129
date	2011.09.29.23.45.57;	author tmsriram;	state Exp;
branches;
next	1.128;

1.128
date	2011.08.27.01.28.18;	author ccoutant;	state Exp;
branches
	1.128.2.1;
next	1.127;

1.127
date	2011.07.14.00.55.18;	author tmsriram;	state Exp;
branches;
next	1.126;

1.126
date	2011.07.06.21.19.32;	author ccoutant;	state Exp;
branches;
next	1.125;

1.125
date	2011.06.08.04.05.25;	author ccoutant;	state Exp;
branches;
next	1.124;

1.124
date	2011.05.25.00.17.46;	author ian;	state Exp;
branches;
next	1.123;

1.123
date	2011.05.24.23.31.07;	author ccoutant;	state Exp;
branches;
next	1.122;

1.122
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.121;

1.121
date	2011.05.23.23.27.10;	author ccoutant;	state Exp;
branches;
next	1.120;

1.120
date	2011.04.12.18.06.16;	author ian;	state Exp;
branches;
next	1.119;

1.119
date	2011.04.12.00.44.48;	author ccoutant;	state Exp;
branches;
next	1.118;

1.118
date	2010.12.23.19.56.14;	author ccoutant;	state Exp;
branches;
next	1.117;

1.117
date	2010.11.16.19.18.31;	author ccoutant;	state Exp;
branches;
next	1.116;

1.116
date	2010.10.29.20.49.20;	author dougkwan;	state Exp;
branches
	1.116.2.1;
next	1.115;

1.115
date	2010.10.18.05.39.23;	author ccoutant;	state Exp;
branches;
next	1.114;

1.114
date	2010.10.16.00.37.25;	author ccoutant;	state Exp;
branches;
next	1.113;

1.113
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.112;

1.112
date	2010.08.19.22.50.15;	author ian;	state Exp;
branches;
next	1.111;

1.111
date	2010.08.03.14.07.13;	author ian;	state Exp;
branches;
next	1.110;

1.110
date	2010.08.02.11.59.11;	author ian;	state Exp;
branches;
next	1.109;

1.109
date	2010.07.13.20.07.08;	author dougkwan;	state Exp;
branches;
next	1.108;

1.108
date	2010.07.13.12.04.03;	author ian;	state Exp;
branches;
next	1.107;

1.107
date	2010.06.01.23.37.58;	author tmsriram;	state Exp;
branches;
next	1.106;

1.106
date	2010.05.23.07.43.39;	author dougkwan;	state Exp;
branches;
next	1.105;

1.105
date	2010.05.19.07.09.36;	author dougkwan;	state Exp;
branches;
next	1.104;

1.104
date	2010.04.23.04.47.32;	author ian;	state Exp;
branches;
next	1.103;

1.103
date	2010.04.09.17.32.58;	author dougkwan;	state Exp;
branches;
next	1.102;

1.102
date	2010.03.01.21.43.50;	author dougkwan;	state Exp;
branches;
next	1.101;

1.101
date	2010.02.13.00.01.20;	author davem;	state Exp;
branches;
next	1.100;

1.100
date	2010.02.09.20.29.44;	author davem;	state Exp;
branches;
next	1.99;

1.99
date	2010.01.23.01.07.59;	author dougkwan;	state Exp;
branches;
next	1.98;

1.98
date	2010.01.20.17.29.52;	author dougkwan;	state Exp;
branches;
next	1.97;

1.97
date	2010.01.08.19.33.18;	author ian;	state Exp;
branches;
next	1.96;

1.96
date	2010.01.07.21.09.31;	author ian;	state Exp;
branches;
next	1.95;

1.95
date	2010.01.07.20.43.35;	author ian;	state Exp;
branches;
next	1.94;

1.94
date	2010.01.06.22.37.18;	author ian;	state Exp;
branches;
next	1.93;

1.93
date	2009.12.30.06.57.17;	author ian;	state Exp;
branches;
next	1.92;

1.92
date	2009.12.30.04.00.21;	author ian;	state Exp;
branches;
next	1.91;

1.91
date	2009.12.17.00.00.26;	author dougkwan;	state Exp;
branches;
next	1.90;

1.90
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.89;

1.89
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2009.12.03.04.26.01;	author espindola;	state Exp;
branches;
next	1.87;

1.87
date	2009.11.04.15.56.03;	author ian;	state Exp;
branches;
next	1.86;

1.86
date	2009.10.21.08.08.41;	author dougkwan;	state Exp;
branches;
next	1.85;

1.85
date	2009.10.21.00.45.52;	author dougkwan;	state Exp;
branches;
next	1.84;

1.84
date	2009.10.09.23.18.19;	author dougkwan;	state Exp;
branches;
next	1.83;

1.83
date	2009.10.09.16.40.51;	author ian;	state Exp;
branches;
next	1.82;

1.82
date	2009.09.18.01.10.38;	author dougkwan;	state Exp;
branches;
next	1.81;

1.81
date	2009.09.01.17.32.20;	author ian;	state Exp;
branches
	1.81.2.1;
next	1.80;

1.80
date	2009.06.24.19.48.51;	author ian;	state Exp;
branches;
next	1.79;

1.79
date	2009.06.22.06.51.53;	author ian;	state Exp;
branches;
next	1.78;

1.78
date	2009.03.24.18.04.26;	author ian;	state Exp;
branches;
next	1.77;

1.77
date	2009.02.28.00.12.26;	author ian;	state Exp;
branches;
next	1.76;

1.76
date	2008.09.29.21.10.26;	author ccoutant;	state Exp;
branches;
next	1.75;

1.75
date	2008.08.13.07.37.46;	author ian;	state Exp;
branches;
next	1.74;

1.74
date	2008.07.10.23.01.19;	author ian;	state Exp;
branches;
next	1.73;

1.73
date	2008.06.18.04.39.41;	author ian;	state Exp;
branches;
next	1.72;

1.72
date	2008.05.21.21.37.44;	author ian;	state Exp;
branches;
next	1.71;

1.71
date	2008.05.20.04.00.46;	author ian;	state Exp;
branches;
next	1.70;

1.70
date	2008.05.16.22.29.04;	author ian;	state Exp;
branches;
next	1.69;

1.69
date	2008.05.16.15.27.49;	author ian;	state Exp;
branches;
next	1.68;

1.68
date	2008.05.06.05.54.21;	author ian;	state Exp;
branches;
next	1.67;

1.67
date	2008.05.06.05.03.15;	author ian;	state Exp;
branches;
next	1.66;

1.66
date	2008.05.05.19.16.43;	author ian;	state Exp;
branches;
next	1.65;

1.65
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.64;

1.64
date	2008.04.16.22.54.29;	author ian;	state Exp;
branches;
next	1.63;

1.63
date	2008.04.15.04.06.41;	author ian;	state Exp;
branches;
next	1.62;

1.62
date	2008.04.11.22.55.13;	author ian;	state Exp;
branches;
next	1.61;

1.61
date	2008.04.11.21.24.29;	author ccoutant;	state Exp;
branches;
next	1.60;

1.60
date	2008.04.07.22.46.16;	author ian;	state Exp;
branches;
next	1.59;

1.59
date	2008.03.28.22.42.34;	author ian;	state Exp;
branches;
next	1.58;

1.58
date	2008.03.25.18.37.16;	author ccoutant;	state Exp;
branches;
next	1.57;

1.57
date	2008.03.19.21.41.38;	author iant;	state Exp;
branches;
next	1.56;

1.56
date	2008.03.16.23.51.19;	author iant;	state Exp;
branches;
next	1.55;

1.55
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.54;

1.54
date	2008.03.12.04.38.42;	author iant;	state Exp;
branches;
next	1.53;

1.53
date	2008.02.29.19.19.17;	author iant;	state Exp;
branches;
next	1.52;

1.52
date	2008.02.13.22.47.28;	author iant;	state Exp;
branches;
next	1.51;

1.51
date	2008.02.12.00.28.48;	author iant;	state Exp;
branches;
next	1.50;

1.50
date	2008.02.09.01.22.17;	author iant;	state Exp;
branches;
next	1.49;

1.49
date	2008.02.07.07.33.46;	author iant;	state Exp;
branches;
next	1.48;

1.48
date	2008.02.06.19.32.32;	author iant;	state Exp;
branches;
next	1.47;

1.47
date	2008.02.06.08.13.50;	author iant;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.04.22.54.31;	author iant;	state Exp;
branches;
next	1.45;

1.45
date	2008.02.04.05.41.40;	author iant;	state Exp;
branches;
next	1.44;

1.44
date	2008.01.18.23.26.48;	author iant;	state Exp;
branches;
next	1.43;

1.43
date	2008.01.06.00.47.10;	author iant;	state Exp;
branches;
next	1.42;

1.42
date	2007.12.21.23.08.25;	author iant;	state Exp;
branches;
next	1.41;

1.41
date	2007.12.21.21.19.45;	author iant;	state Exp;
branches;
next	1.40;

1.40
date	2007.12.20.21.21.24;	author iant;	state Exp;
branches;
next	1.39;

1.39
date	2007.12.20.16.27.34;	author iant;	state Exp;
branches;
next	1.38;

1.38
date	2007.12.20.01.29.04;	author iant;	state Exp;
branches;
next	1.37;

1.37
date	2007.12.18.21.24.10;	author iant;	state Exp;
branches;
next	1.36;

1.36
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.35;

1.35
date	2007.12.07.19.32.59;	author iant;	state Exp;
branches;
next	1.34;

1.34
date	2007.12.06.05.55.50;	author iant;	state Exp;
branches;
next	1.33;

1.33
date	2007.12.04.23.42.28;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2007.12.01.06.34.12;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.30.00.35.27;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.29.20.10.17;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.15.23.46.46;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.14.22.31.02;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.07.18.29.34;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.18.17.46.23;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.12.06.06.34;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.08.07.22.21;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.26.07.01.34;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.21.07.20.01;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.21.05.31.19;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.21.21.03.50;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.08.21.20.37.32;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.16.17.42.48;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.06.00.02.36;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.01.16.51.25;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.01.00.10.37;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.30.23.52.50;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.16.00.38.25;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.03.18.26.10;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.20.20.40.49;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.29.22.34.01;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.29.19.58.17;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.27.22.53.42;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.26.21.00.34;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.21.22.13.18;	author iant;	state Exp;
branches;
next	;

1.148.2.1
date	2013.10.11.22.02.58;	author roland;	state Exp;
branches;
next	1.148.2.2;

1.148.2.2
date	2013.10.14.02.53.54;	author amodra;	state Exp;
branches;
next	;

1.135.2.1
date	2013.08.27.21.50.25;	author roland;	state Exp;
branches;
next	;

1.128.2.1
date	2011.12.19.21.14.39;	author ian;	state Exp;
branches;
next	;

1.116.2.1
date	2010.11.18.08.25.00;	author gingold;	state Exp;
branches;
next	1.116.2.2;

1.116.2.2
date	2010.12.23.23.26.40;	author ian;	state Exp;
branches;
next	;

1.81.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	1.81.2.2;

1.81.2.2
date	2009.11.04.15.56.34;	author ian;	state Exp;
branches;
next	;


desc
@@


1.150
log
@	* output.h (Output_data_got::add_constant): Tidy.
	(Output_data_got::add_constant_pair): New function.
	* powerpc.cc (Output_data_got_powerpc): Override all Output_data_got
	methods used so as to first call reserve_ent().
@
text
@// output.h -- manage the output file for gold   -*- C++ -*-

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2013
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#ifndef GOLD_OUTPUT_H
#define GOLD_OUTPUT_H

#include <list>
#include <vector>

#include "elfcpp.h"
#include "mapfile.h"
#include "layout.h"
#include "reloc-types.h"

namespace gold
{

class General_options;
class Object;
class Symbol;
class Output_file;
class Output_merge_base;
class Output_section;
class Relocatable_relocs;
class Target;
template<int size, bool big_endian>
class Sized_target;
template<int size, bool big_endian>
class Sized_relobj;
template<int size, bool big_endian>
class Sized_relobj_file;

// An abtract class for data which has to go into the output file.

class Output_data
{
 public:
  explicit Output_data()
    : address_(0), data_size_(0), offset_(-1),
      is_address_valid_(false), is_data_size_valid_(false),
      is_offset_valid_(false), is_data_size_fixed_(false),
      has_dynamic_reloc_(false)
  { }

  virtual
  ~Output_data();

  // Return the address.  For allocated sections, this is only valid
  // after Layout::finalize is finished.
  uint64_t
  address() const
  {
    gold_assert(this->is_address_valid_);
    return this->address_;
  }

  // Return the size of the data.  For allocated sections, this must
  // be valid after Layout::finalize calls set_address, but need not
  // be valid before then.
  off_t
  data_size() const
  {
    gold_assert(this->is_data_size_valid_);
    return this->data_size_;
  }

  // Get the current data size.
  off_t
  current_data_size() const
  { return this->current_data_size_for_child(); }

  // Return true if data size is fixed.
  bool
  is_data_size_fixed() const
  { return this->is_data_size_fixed_; }

  // Return the file offset.  This is only valid after
  // Layout::finalize is finished.  For some non-allocated sections,
  // it may not be valid until near the end of the link.
  off_t
  offset() const
  {
    gold_assert(this->is_offset_valid_);
    return this->offset_;
  }

  // Reset the address, file offset and data size.  This essentially
  // disables the sanity testing about duplicate and unknown settings.
  void
  reset_address_and_file_offset()
  {
    this->is_address_valid_ = false;
    this->is_offset_valid_ = false;
    if (!this->is_data_size_fixed_)
      this->is_data_size_valid_ = false;
    this->do_reset_address_and_file_offset();
  }

  // As above, but just for data size.
  void
  reset_data_size()
  {
    if (!this->is_data_size_fixed_)
      this->is_data_size_valid_ = false;
  }

  // Return true if address and file offset already have reset values. In
  // other words, calling reset_address_and_file_offset will not change them.
  bool
  address_and_file_offset_have_reset_values() const
  { return this->do_address_and_file_offset_have_reset_values(); }

  // Return the required alignment.
  uint64_t
  addralign() const
  { return this->do_addralign(); }

  // Return whether this has a load address.
  bool
  has_load_address() const
  { return this->do_has_load_address(); }

  // Return the load address.
  uint64_t
  load_address() const
  { return this->do_load_address(); }

  // Return whether this is an Output_section.
  bool
  is_section() const
  { return this->do_is_section(); }

  // Return whether this is an Output_section of the specified type.
  bool
  is_section_type(elfcpp::Elf_Word stt) const
  { return this->do_is_section_type(stt); }

  // Return whether this is an Output_section with the specified flag
  // set.
  bool
  is_section_flag_set(elfcpp::Elf_Xword shf) const
  { return this->do_is_section_flag_set(shf); }

  // Return the output section that this goes in, if there is one.
  Output_section*
  output_section()
  { return this->do_output_section(); }

  const Output_section*
  output_section() const
  { return this->do_output_section(); }

  // Return the output section index, if there is an output section.
  unsigned int
  out_shndx() const
  { return this->do_out_shndx(); }

  // Set the output section index, if this is an output section.
  void
  set_out_shndx(unsigned int shndx)
  { this->do_set_out_shndx(shndx); }

  // Set the address and file offset of this data, and finalize the
  // size of the data.  This is called during Layout::finalize for
  // allocated sections.
  void
  set_address_and_file_offset(uint64_t addr, off_t off)
  {
    this->set_address(addr);
    this->set_file_offset(off);
    this->finalize_data_size();
  }

  // Set the address.
  void
  set_address(uint64_t addr)
  {
    gold_assert(!this->is_address_valid_);
    this->address_ = addr;
    this->is_address_valid_ = true;
  }

  // Set the file offset.
  void
  set_file_offset(off_t off)
  {
    gold_assert(!this->is_offset_valid_);
    this->offset_ = off;
    this->is_offset_valid_ = true;
  }

  // Update the data size without finalizing it.
  void
  pre_finalize_data_size()
  {
    if (!this->is_data_size_valid_)
      {
	// Tell the child class to update the data size.
	this->update_data_size();
      }
  }

  // Finalize the data size.
  void
  finalize_data_size()
  {
    if (!this->is_data_size_valid_)
      {
	// Tell the child class to set the data size.
	this->set_final_data_size();
	gold_assert(this->is_data_size_valid_);
      }
  }

  // Set the TLS offset.  Called only for SHT_TLS sections.
  void
  set_tls_offset(uint64_t tls_base)
  { this->do_set_tls_offset(tls_base); }

  // Return the TLS offset, relative to the base of the TLS segment.
  // Valid only for SHT_TLS sections.
  uint64_t
  tls_offset() const
  { return this->do_tls_offset(); }

  // Write the data to the output file.  This is called after
  // Layout::finalize is complete.
  void
  write(Output_file* file)
  { this->do_write(file); }

  // This is called by Layout::finalize to note that the sizes of
  // allocated sections must now be fixed.
  static void
  layout_complete()
  { Output_data::allocated_sizes_are_fixed = true; }

  // Used to check that layout has been done.
  static bool
  is_layout_complete()
  { return Output_data::allocated_sizes_are_fixed; }

  // Note that a dynamic reloc has been applied to this data.
  void
  add_dynamic_reloc()
  { this->has_dynamic_reloc_ = true; }

  // Return whether a dynamic reloc has been applied.
  bool
  has_dynamic_reloc() const
  { return this->has_dynamic_reloc_; }

  // Whether the address is valid.
  bool
  is_address_valid() const
  { return this->is_address_valid_; }

  // Whether the file offset is valid.
  bool
  is_offset_valid() const
  { return this->is_offset_valid_; }

  // Whether the data size is valid.
  bool
  is_data_size_valid() const
  { return this->is_data_size_valid_; }

  // Print information to the map file.
  void
  print_to_mapfile(Mapfile* mapfile) const
  { return this->do_print_to_mapfile(mapfile); }

 protected:
  // Functions that child classes may or in some cases must implement.

  // Write the data to the output file.
  virtual void
  do_write(Output_file*) = 0;

  // Return the required alignment.
  virtual uint64_t
  do_addralign() const = 0;

  // Return whether this has a load address.
  virtual bool
  do_has_load_address() const
  { return false; }

  // Return the load address.
  virtual uint64_t
  do_load_address() const
  { gold_unreachable(); }

  // Return whether this is an Output_section.
  virtual bool
  do_is_section() const
  { return false; }

  // Return whether this is an Output_section of the specified type.
  // This only needs to be implement by Output_section.
  virtual bool
  do_is_section_type(elfcpp::Elf_Word) const
  { return false; }

  // Return whether this is an Output_section with the specific flag
  // set.  This only needs to be implemented by Output_section.
  virtual bool
  do_is_section_flag_set(elfcpp::Elf_Xword) const
  { return false; }

  // Return the output section, if there is one.
  virtual Output_section*
  do_output_section()
  { return NULL; }

  virtual const Output_section*
  do_output_section() const
  { return NULL; }

  // Return the output section index, if there is an output section.
  virtual unsigned int
  do_out_shndx() const
  { gold_unreachable(); }

  // Set the output section index, if this is an output section.
  virtual void
  do_set_out_shndx(unsigned int)
  { gold_unreachable(); }

  // This is a hook for derived classes to set the preliminary data size.
  // This is called by pre_finalize_data_size, normally called during
  // Layout::finalize, before the section address is set, and is used
  // during an incremental update, when we need to know the size of a
  // section before allocating space in the output file.  For classes
  // where the current data size is up to date, this default version of
  // the method can be inherited.
  virtual void
  update_data_size()
  { }

  // This is a hook for derived classes to set the data size.  This is
  // called by finalize_data_size, normally called during
  // Layout::finalize, when the section address is set.
  virtual void
  set_final_data_size()
  { gold_unreachable(); }

  // A hook for resetting the address and file offset.
  virtual void
  do_reset_address_and_file_offset()
  { }

  // Return true if address and file offset already have reset values. In
  // other words, calling reset_address_and_file_offset will not change them.
  // A child class overriding do_reset_address_and_file_offset may need to
  // also override this.
  virtual bool
  do_address_and_file_offset_have_reset_values() const
  { return !this->is_address_valid_ && !this->is_offset_valid_; }

  // Set the TLS offset.  Called only for SHT_TLS sections.
  virtual void
  do_set_tls_offset(uint64_t)
  { gold_unreachable(); }

  // Return the TLS offset, relative to the base of the TLS segment.
  // Valid only for SHT_TLS sections.
  virtual uint64_t
  do_tls_offset() const
  { gold_unreachable(); }

  // Print to the map file.  This only needs to be implemented by
  // classes which may appear in a PT_LOAD segment.
  virtual void
  do_print_to_mapfile(Mapfile*) const
  { gold_unreachable(); }

  // Functions that child classes may call.

  // Reset the address.  The Output_section class needs this when an
  // SHF_ALLOC input section is added to an output section which was
  // formerly not SHF_ALLOC.
  void
  mark_address_invalid()
  { this->is_address_valid_ = false; }

  // Set the size of the data.
  void
  set_data_size(off_t data_size)
  {
    gold_assert(!this->is_data_size_valid_
		&& !this->is_data_size_fixed_);
    this->data_size_ = data_size;
    this->is_data_size_valid_ = true;
  }

  // Fix the data size.  Once it is fixed, it cannot be changed
  // and the data size remains always valid.
  void
  fix_data_size()
  {
    gold_assert(this->is_data_size_valid_);
    this->is_data_size_fixed_ = true;
  }

  // Get the current data size--this is for the convenience of
  // sections which build up their size over time.
  off_t
  current_data_size_for_child() const
  { return this->data_size_; }

  // Set the current data size--this is for the convenience of
  // sections which build up their size over time.
  void
  set_current_data_size_for_child(off_t data_size)
  {
    gold_assert(!this->is_data_size_valid_);
    this->data_size_ = data_size;
  }

  // Return default alignment for the target size.
  static uint64_t
  default_alignment();

  // Return default alignment for a specified size--32 or 64.
  static uint64_t
  default_alignment_for_size(int size);

 private:
  Output_data(const Output_data&);
  Output_data& operator=(const Output_data&);

  // This is used for verification, to make sure that we don't try to
  // change any sizes of allocated sections after we set the section
  // addresses.
  static bool allocated_sizes_are_fixed;

  // Memory address in output file.
  uint64_t address_;
  // Size of data in output file.
  off_t data_size_;
  // File offset of contents in output file.
  off_t offset_;
  // Whether address_ is valid.
  bool is_address_valid_ : 1;
  // Whether data_size_ is valid.
  bool is_data_size_valid_ : 1;
  // Whether offset_ is valid.
  bool is_offset_valid_ : 1;
  // Whether data size is fixed.
  bool is_data_size_fixed_ : 1;
  // Whether any dynamic relocs have been applied to this section.
  bool has_dynamic_reloc_ : 1;
};

// Output the section headers.

class Output_section_headers : public Output_data
{
 public:
  Output_section_headers(const Layout*,
			 const Layout::Segment_list*,
			 const Layout::Section_list*,
			 const Layout::Section_list*,
			 const Stringpool*,
			 const Output_section*);

 protected:
  // Write the data to the file.
  void
  do_write(Output_file*);

  // Return the required alignment.
  uint64_t
  do_addralign() const
  { return Output_data::default_alignment(); }

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** section headers")); }

  // Update the data size.
  void
  update_data_size()
  { this->set_data_size(this->do_size()); }

  // Set final data size.
  void
  set_final_data_size()
  { this->set_data_size(this->do_size()); }

 private:
  // Write the data to the file with the right size and endianness.
  template<int size, bool big_endian>
  void
  do_sized_write(Output_file*);

  // Compute data size.
  off_t
  do_size() const;

  const Layout* layout_;
  const Layout::Segment_list* segment_list_;
  const Layout::Section_list* section_list_;
  const Layout::Section_list* unattached_section_list_;
  const Stringpool* secnamepool_;
  const Output_section* shstrtab_section_;
};

// Output the segment headers.

class Output_segment_headers : public Output_data
{
 public:
  Output_segment_headers(const Layout::Segment_list& segment_list);

 protected:
  // Write the data to the file.
  void
  do_write(Output_file*);

  // Return the required alignment.
  uint64_t
  do_addralign() const
  { return Output_data::default_alignment(); }

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** segment headers")); }

  // Set final data size.
  void
  set_final_data_size()
  { this->set_data_size(this->do_size()); }

 private:
  // Write the data to the file with the right size and endianness.
  template<int size, bool big_endian>
  void
  do_sized_write(Output_file*);

  // Compute the current size.
  off_t
  do_size() const;

  const Layout::Segment_list& segment_list_;
};

// Output the ELF file header.

class Output_file_header : public Output_data
{
 public:
  Output_file_header(Target*,
		     const Symbol_table*,
		     const Output_segment_headers*);

  // Add information about the section headers.  We lay out the ELF
  // file header before we create the section headers.
  void set_section_info(const Output_section_headers*,
			const Output_section* shstrtab);

 protected:
  // Write the data to the file.
  void
  do_write(Output_file*);

  // Return the required alignment.
  uint64_t
  do_addralign() const
  { return Output_data::default_alignment(); }

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** file header")); }

  // Set final data size.
  void
  set_final_data_size(void)
  { this->set_data_size(this->do_size()); }

 private:
  // Write the data to the file with the right size and endianness.
  template<int size, bool big_endian>
  void
  do_sized_write(Output_file*);

  // Return the value to use for the entry address.
  template<int size>
  typename elfcpp::Elf_types<size>::Elf_Addr
  entry();

  // Compute the current data size.
  off_t
  do_size() const;

  Target* target_;
  const Symbol_table* symtab_;
  const Output_segment_headers* segment_header_;
  const Output_section_headers* section_header_;
  const Output_section* shstrtab_;
};

// Output sections are mainly comprised of input sections.  However,
// there are cases where we have data to write out which is not in an
// input section.  Output_section_data is used in such cases.  This is
// an abstract base class.

class Output_section_data : public Output_data
{
 public:
  Output_section_data(off_t data_size, uint64_t addralign,
		      bool is_data_size_fixed)
    : Output_data(), output_section_(NULL), addralign_(addralign)
  {
    this->set_data_size(data_size);
    if (is_data_size_fixed)
      this->fix_data_size();
  }

  Output_section_data(uint64_t addralign)
    : Output_data(), output_section_(NULL), addralign_(addralign)
  { }

  // Return the output section.
  Output_section*
  output_section()
  { return this->output_section_; }

  const Output_section*
  output_section() const
  { return this->output_section_; }

  // Record the output section.
  void
  set_output_section(Output_section* os);

  // Add an input section, for SHF_MERGE sections.  This returns true
  // if the section was handled.
  bool
  add_input_section(Relobj* object, unsigned int shndx)
  { return this->do_add_input_section(object, shndx); }

  // Given an input OBJECT, an input section index SHNDX within that
  // object, and an OFFSET relative to the start of that input
  // section, return whether or not the corresponding offset within
  // the output section is known.  If this function returns true, it
  // sets *POUTPUT to the output offset.  The value -1 indicates that
  // this input offset is being discarded.
  bool
  output_offset(const Relobj* object, unsigned int shndx,
		section_offset_type offset,
		section_offset_type* poutput) const
  { return this->do_output_offset(object, shndx, offset, poutput); }

  // Return whether this is the merge section for the input section
  // SHNDX in OBJECT.  This should return true when output_offset
  // would return true for some values of OFFSET.
  bool
  is_merge_section_for(const Relobj* object, unsigned int shndx) const
  { return this->do_is_merge_section_for(object, shndx); }

  // Write the contents to a buffer.  This is used for sections which
  // require postprocessing, such as compression.
  void
  write_to_buffer(unsigned char* buffer)
  { this->do_write_to_buffer(buffer); }

  // Print merge stats to stderr.  This should only be called for
  // SHF_MERGE sections.
  void
  print_merge_stats(const char* section_name)
  { this->do_print_merge_stats(section_name); }

 protected:
  // The child class must implement do_write.

  // The child class may implement specific adjustments to the output
  // section.
  virtual void
  do_adjust_output_section(Output_section*)
  { }

  // May be implemented by child class.  Return true if the section
  // was handled.
  virtual bool
  do_add_input_section(Relobj*, unsigned int)
  { gold_unreachable(); }

  // The child class may implement output_offset.
  virtual bool
  do_output_offset(const Relobj*, unsigned int, section_offset_type,
		   section_offset_type*) const
  { return false; }

  // The child class may implement is_merge_section_for.
  virtual bool
  do_is_merge_section_for(const Relobj*, unsigned int) const
  { return false; }

  // The child class may implement write_to_buffer.  Most child
  // classes can not appear in a compressed section, and they do not
  // implement this.
  virtual void
  do_write_to_buffer(unsigned char*)
  { gold_unreachable(); }

  // Print merge statistics.
  virtual void
  do_print_merge_stats(const char*)
  { gold_unreachable(); }

  // Return the required alignment.
  uint64_t
  do_addralign() const
  { return this->addralign_; }

  // Return the output section.
  Output_section*
  do_output_section()
  { return this->output_section_; }

  const Output_section*
  do_output_section() const
  { return this->output_section_; }

  // Return the section index of the output section.
  unsigned int
  do_out_shndx() const;

  // Set the alignment.
  void
  set_addralign(uint64_t addralign);

 private:
  // The output section for this section.
  Output_section* output_section_;
  // The required alignment.
  uint64_t addralign_;
};

// Some Output_section_data classes build up their data step by step,
// rather than all at once.  This class provides an interface for
// them.

class Output_section_data_build : public Output_section_data
{
 public:
  Output_section_data_build(uint64_t addralign)
    : Output_section_data(addralign)
  { }

  Output_section_data_build(off_t data_size, uint64_t addralign)
    : Output_section_data(data_size, addralign, false)
  { }

  // Set the current data size.
  void
  set_current_data_size(off_t data_size)
  { this->set_current_data_size_for_child(data_size); }

 protected:
  // Set the final data size.
  virtual void
  set_final_data_size()
  { this->set_data_size(this->current_data_size_for_child()); }
};

// A simple case of Output_data in which we have constant data to
// output.

class Output_data_const : public Output_section_data
{
 public:
  Output_data_const(const std::string& data, uint64_t addralign)
    : Output_section_data(data.size(), addralign, true), data_(data)
  { }

  Output_data_const(const char* p, off_t len, uint64_t addralign)
    : Output_section_data(len, addralign, true), data_(p, len)
  { }

  Output_data_const(const unsigned char* p, off_t len, uint64_t addralign)
    : Output_section_data(len, addralign, true),
      data_(reinterpret_cast<const char*>(p), len)
  { }

 protected:
  // Write the data to the output file.
  void
  do_write(Output_file*);

  // Write the data to a buffer.
  void
  do_write_to_buffer(unsigned char* buffer)
  { memcpy(buffer, this->data_.data(), this->data_.size()); }

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** fill")); }

 private:
  std::string data_;
};

// Another version of Output_data with constant data, in which the
// buffer is allocated by the caller.

class Output_data_const_buffer : public Output_section_data
{
 public:
  Output_data_const_buffer(const unsigned char* p, off_t len,
			   uint64_t addralign, const char* map_name)
    : Output_section_data(len, addralign, true),
      p_(p), map_name_(map_name)
  { }

 protected:
  // Write the data the output file.
  void
  do_write(Output_file*);

  // Write the data to a buffer.
  void
  do_write_to_buffer(unsigned char* buffer)
  { memcpy(buffer, this->p_, this->data_size()); }

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _(this->map_name_)); }

 private:
  // The data to output.
  const unsigned char* p_;
  // Name to use in a map file.  Maps are a rarely used feature, but
  // the space usage is minor as aren't very many of these objects.
  const char* map_name_;
};

// A place holder for a fixed amount of data written out via some
// other mechanism.

class Output_data_fixed_space : public Output_section_data
{
 public:
  Output_data_fixed_space(off_t data_size, uint64_t addralign,
			  const char* map_name)
    : Output_section_data(data_size, addralign, true),
      map_name_(map_name)
  { }

 protected:
  // Write out the data--the actual data must be written out
  // elsewhere.
  void
  do_write(Output_file*)
  { }

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _(this->map_name_)); }

 private:
  // Name to use in a map file.  Maps are a rarely used feature, but
  // the space usage is minor as aren't very many of these objects.
  const char* map_name_;
};

// A place holder for variable sized data written out via some other
// mechanism.

class Output_data_space : public Output_section_data_build
{
 public:
  explicit Output_data_space(uint64_t addralign, const char* map_name)
    : Output_section_data_build(addralign),
      map_name_(map_name)
  { }

  explicit Output_data_space(off_t data_size, uint64_t addralign,
			     const char* map_name)
    : Output_section_data_build(data_size, addralign),
      map_name_(map_name)
  { }

  // Set the alignment.
  void
  set_space_alignment(uint64_t align)
  { this->set_addralign(align); }

 protected:
  // Write out the data--the actual data must be written out
  // elsewhere.
  void
  do_write(Output_file*)
  { }

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _(this->map_name_)); }

 private:
  // Name to use in a map file.  Maps are a rarely used feature, but
  // the space usage is minor as aren't very many of these objects.
  const char* map_name_;
};

// Fill fixed space with zeroes.  This is just like
// Output_data_fixed_space, except that the map name is known.

class Output_data_zero_fill : public Output_section_data
{
 public:
  Output_data_zero_fill(off_t data_size, uint64_t addralign)
    : Output_section_data(data_size, addralign, true)
  { }

 protected:
  // There is no data to write out.
  void
  do_write(Output_file*)
  { }

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, "** zero fill"); }
};

// A string table which goes into an output section.

class Output_data_strtab : public Output_section_data
{
 public:
  Output_data_strtab(Stringpool* strtab)
    : Output_section_data(1), strtab_(strtab)
  { }

 protected:
  // This is called to update the section size prior to assigning
  // the address and file offset.
  void
  update_data_size()
  { this->set_final_data_size(); }

  // This is called to set the address and file offset.  Here we make
  // sure that the Stringpool is finalized.
  void
  set_final_data_size();

  // Write out the data.
  void
  do_write(Output_file*);

  // Write the data to a buffer.
  void
  do_write_to_buffer(unsigned char* buffer)
  { this->strtab_->write_to_buffer(buffer, this->data_size()); }

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** string table")); }

 private:
  Stringpool* strtab_;
};

// This POD class is used to represent a single reloc in the output
// file.  This could be a private class within Output_data_reloc, but
// the templatization is complex enough that I broke it out into a
// separate class.  The class is templatized on either elfcpp::SHT_REL
// or elfcpp::SHT_RELA, and also on whether this is a dynamic
// relocation or an ordinary relocation.

// A relocation can be against a global symbol, a local symbol, a
// local section symbol, an output section, or the undefined symbol at
// index 0.  We represent the latter by using a NULL global symbol.

template<int sh_type, bool dynamic, int size, bool big_endian>
class Output_reloc;

template<bool dynamic, int size, bool big_endian>
class Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>
{
 public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Addend;

  static const Address invalid_address = static_cast<Address>(0) - 1;

  // An uninitialized entry.  We need this because we want to put
  // instances of this class into an STL container.
  Output_reloc()
    : local_sym_index_(INVALID_CODE)
  { }

  // We have a bunch of different constructors.  They come in pairs
  // depending on how the address of the relocation is specified.  It
  // can either be an offset in an Output_data or an offset in an
  // input section.

  // A reloc against a global symbol.

  Output_reloc(Symbol* gsym, unsigned int type, Output_data* od,
	       Address address, bool is_relative, bool is_symbolless,
	       bool use_plt_offset);

  Output_reloc(Symbol* gsym, unsigned int type,
	       Sized_relobj<size, big_endian>* relobj,
	       unsigned int shndx, Address address, bool is_relative,
	       bool is_symbolless, bool use_plt_offset);

  // A reloc against a local symbol or local section symbol.

  Output_reloc(Sized_relobj<size, big_endian>* relobj,
	       unsigned int local_sym_index, unsigned int type,
	       Output_data* od, Address address, bool is_relative,
	       bool is_symbolless, bool is_section_symbol,
	       bool use_plt_offset);

  Output_reloc(Sized_relobj<size, big_endian>* relobj,
	       unsigned int local_sym_index, unsigned int type,
	       unsigned int shndx, Address address, bool is_relative,
	       bool is_symbolless, bool is_section_symbol,
	       bool use_plt_offset);

  // A reloc against the STT_SECTION symbol of an output section.

  Output_reloc(Output_section* os, unsigned int type, Output_data* od,
	       Address address, bool is_relative);

  Output_reloc(Output_section* os, unsigned int type,
	       Sized_relobj<size, big_endian>* relobj, unsigned int shndx,
	       Address address, bool is_relative);

  // An absolute or relative relocation with no symbol.

  Output_reloc(unsigned int type, Output_data* od, Address address,
	       bool is_relative);

  Output_reloc(unsigned int type, Sized_relobj<size, big_endian>* relobj,
	       unsigned int shndx, Address address, bool is_relative);

  // A target specific relocation.  The target will be called to get
  // the symbol index, passing ARG.  The type and offset will be set
  // as for other relocation types.

  Output_reloc(unsigned int type, void* arg, Output_data* od,
	       Address address);

  Output_reloc(unsigned int type, void* arg,
	       Sized_relobj<size, big_endian>* relobj,
	       unsigned int shndx, Address address);

  // Return the reloc type.
  unsigned int
  type() const
  { return this->type_; }

  // Return whether this is a RELATIVE relocation.
  bool
  is_relative() const
  { return this->is_relative_; }

  // Return whether this is a relocation which should not use
  // a symbol, but which obtains its addend from a symbol.
  bool
  is_symbolless() const
  { return this->is_symbolless_; }

  // Return whether this is against a local section symbol.
  bool
  is_local_section_symbol() const
  {
    return (this->local_sym_index_ != GSYM_CODE
	    && this->local_sym_index_ != SECTION_CODE
	    && this->local_sym_index_ != INVALID_CODE
	    && this->local_sym_index_ != TARGET_CODE
	    && this->is_section_symbol_);
  }

  // Return whether this is a target specific relocation.
  bool
  is_target_specific() const
  { return this->local_sym_index_ == TARGET_CODE; }

  // Return the argument to pass to the target for a target specific
  // relocation.
  void*
  target_arg() const
  {
    gold_assert(this->local_sym_index_ == TARGET_CODE);
    return this->u1_.arg;
  }

  // For a local section symbol, return the offset of the input
  // section within the output section.  ADDEND is the addend being
  // applied to the input section.
  Address
  local_section_offset(Addend addend) const;

  // Get the value of the symbol referred to by a Rel relocation when
  // we are adding the given ADDEND.
  Address
  symbol_value(Addend addend) const;

  // If this relocation is against an input section, return the
  // relocatable object containing the input section.
  Sized_relobj<size, big_endian>*
  get_relobj() const
  {
    if (this->shndx_ == INVALID_CODE)
      return NULL;
    return this->u2_.relobj;
  }

  // Write the reloc entry to an output view.
  void
  write(unsigned char* pov) const;

  // Write the offset and info fields to Write_rel.
  template<typename Write_rel>
  void write_rel(Write_rel*) const;

  // This is used when sorting dynamic relocs.  Return -1 to sort this
  // reloc before R2, 0 to sort the same as R2, 1 to sort after R2.
  int
  compare(const Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>& r2)
    const;

  // Return whether this reloc should be sorted before the argument
  // when sorting dynamic relocs.
  bool
  sort_before(const Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>&
	      r2) const
  { return this->compare(r2) < 0; }

 private:
  // Record that we need a dynamic symbol index.
  void
  set_needs_dynsym_index();

  // Return the symbol index.
  unsigned int
  get_symbol_index() const;

  // Return the output address.
  Address
  get_address() const;

  // Codes for local_sym_index_.
  enum
  {
    // Global symbol.
    GSYM_CODE = -1U,
    // Output section.
    SECTION_CODE = -2U,
    // Target specific.
    TARGET_CODE = -3U,
    // Invalid uninitialized entry.
    INVALID_CODE = -4U
  };

  union
  {
    // For a local symbol or local section symbol
    // (this->local_sym_index_ >= 0), the object.  We will never
    // generate a relocation against a local symbol in a dynamic
    // object; that doesn't make sense.  And our callers will always
    // be templatized, so we use Sized_relobj here.
    Sized_relobj<size, big_endian>* relobj;
    // For a global symbol (this->local_sym_index_ == GSYM_CODE, the
    // symbol.  If this is NULL, it indicates a relocation against the
    // undefined 0 symbol.
    Symbol* gsym;
    // For a relocation against an output section
    // (this->local_sym_index_ == SECTION_CODE), the output section.
    Output_section* os;
    // For a target specific relocation, an argument to pass to the
    // target.
    void* arg;
  } u1_;
  union
  {
    // If this->shndx_ is not INVALID CODE, the object which holds the
    // input section being used to specify the reloc address.
    Sized_relobj<size, big_endian>* relobj;
    // If this->shndx_ is INVALID_CODE, the output data being used to
    // specify the reloc address.  This may be NULL if the reloc
    // address is absolute.
    Output_data* od;
  } u2_;
  // The address offset within the input section or the Output_data.
  Address address_;
  // This is GSYM_CODE for a global symbol, or SECTION_CODE for a
  // relocation against an output section, or TARGET_CODE for a target
  // specific relocation, or INVALID_CODE for an uninitialized value.
  // Otherwise, for a local symbol (this->is_section_symbol_ is
  // false), the local symbol index.  For a local section symbol
  // (this->is_section_symbol_ is true), the section index in the
  // input file.
  unsigned int local_sym_index_;
  // The reloc type--a processor specific code.
  unsigned int type_ : 28;
  // True if the relocation is a RELATIVE relocation.
  bool is_relative_ : 1;
  // True if the relocation is one which should not use
  // a symbol, but which obtains its addend from a symbol.
  bool is_symbolless_ : 1;
  // True if the relocation is against a section symbol.
  bool is_section_symbol_ : 1;
  // True if the addend should be the PLT offset.
  // (Used only for RELA, but stored here for space.)
  bool use_plt_offset_ : 1;
  // If the reloc address is an input section in an object, the
  // section index.  This is INVALID_CODE if the reloc address is
  // specified in some other way.
  unsigned int shndx_;
};

// The SHT_RELA version of Output_reloc<>.  This is just derived from
// the SHT_REL version of Output_reloc, but it adds an addend.

template<bool dynamic, int size, bool big_endian>
class Output_reloc<elfcpp::SHT_RELA, dynamic, size, big_endian>
{
 public:
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Addend;

  // An uninitialized entry.
  Output_reloc()
    : rel_()
  { }

  // A reloc against a global symbol.

  Output_reloc(Symbol* gsym, unsigned int type, Output_data* od,
	       Address address, Addend addend, bool is_relative,
	       bool is_symbolless, bool use_plt_offset)
    : rel_(gsym, type, od, address, is_relative, is_symbolless,
	   use_plt_offset),
      addend_(addend)
  { }

  Output_reloc(Symbol* gsym, unsigned int type,
	       Sized_relobj<size, big_endian>* relobj,
	       unsigned int shndx, Address address, Addend addend,
	       bool is_relative, bool is_symbolless, bool use_plt_offset)
    : rel_(gsym, type, relobj, shndx, address, is_relative,
	   is_symbolless, use_plt_offset), addend_(addend)
  { }

  // A reloc against a local symbol.

  Output_reloc(Sized_relobj<size, big_endian>* relobj,
	       unsigned int local_sym_index, unsigned int type,
	       Output_data* od, Address address,
	       Addend addend, bool is_relative,
	       bool is_symbolless, bool is_section_symbol,
	       bool use_plt_offset)
    : rel_(relobj, local_sym_index, type, od, address, is_relative,
	   is_symbolless, is_section_symbol, use_plt_offset),
      addend_(addend)
  { }

  Output_reloc(Sized_relobj<size, big_endian>* relobj,
	       unsigned int local_sym_index, unsigned int type,
	       unsigned int shndx, Address address,
	       Addend addend, bool is_relative,
	       bool is_symbolless, bool is_section_symbol,
	       bool use_plt_offset)
    : rel_(relobj, local_sym_index, type, shndx, address, is_relative,
	   is_symbolless, is_section_symbol, use_plt_offset),
      addend_(addend)
  { }

  // A reloc against the STT_SECTION symbol of an output section.

  Output_reloc(Output_section* os, unsigned int type, Output_data* od,
	       Address address, Addend addend, bool is_relative)
    : rel_(os, type, od, address, is_relative), addend_(addend)
  { }

  Output_reloc(Output_section* os, unsigned int type,
	       Sized_relobj<size, big_endian>* relobj,
	       unsigned int shndx, Address address, Addend addend,
	       bool is_relative)
    : rel_(os, type, relobj, shndx, address, is_relative), addend_(addend)
  { }

  // An absolute or relative relocation with no symbol.

  Output_reloc(unsigned int type, Output_data* od, Address address,
	       Addend addend, bool is_relative)
    : rel_(type, od, address, is_relative), addend_(addend)
  { }

  Output_reloc(unsigned int type, Sized_relobj<size, big_endian>* relobj,
	       unsigned int shndx, Address address, Addend addend,
	       bool is_relative)
    : rel_(type, relobj, shndx, address, is_relative), addend_(addend)
  { }

  // A target specific relocation.  The target will be called to get
  // the symbol index and the addend, passing ARG.  The type and
  // offset will be set as for other relocation types.

  Output_reloc(unsigned int type, void* arg, Output_data* od,
	       Address address, Addend addend)
    : rel_(type, arg, od, address), addend_(addend)
  { }

  Output_reloc(unsigned int type, void* arg,
	       Sized_relobj<size, big_endian>* relobj,
	       unsigned int shndx, Address address, Addend addend)
    : rel_(type, arg, relobj, shndx, address), addend_(addend)
  { }

  // Return whether this is a RELATIVE relocation.
  bool
  is_relative() const
  { return this->rel_.is_relative(); }

  // Return whether this is a relocation which should not use
  // a symbol, but which obtains its addend from a symbol.
  bool
  is_symbolless() const
  { return this->rel_.is_symbolless(); }

  // If this relocation is against an input section, return the
  // relocatable object containing the input section.
  Sized_relobj<size, big_endian>*
  get_relobj() const
  { return this->rel_.get_relobj(); }

  // Write the reloc entry to an output view.
  void
  write(unsigned char* pov) const;

  // Return whether this reloc should be sorted before the argument
  // when sorting dynamic relocs.
  bool
  sort_before(const Output_reloc<elfcpp::SHT_RELA, dynamic, size, big_endian>&
	      r2) const
  {
    int i = this->rel_.compare(r2.rel_);
    if (i < 0)
      return true;
    else if (i > 0)
      return false;
    else
      return this->addend_ < r2.addend_;
  }

 private:
  // The basic reloc.
  Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian> rel_;
  // The addend.
  Addend addend_;
};

// Output_data_reloc_generic is a non-template base class for
// Output_data_reloc_base.  This gives the generic code a way to hold
// a pointer to a reloc section.

class Output_data_reloc_generic : public Output_section_data_build
{
 public:
  Output_data_reloc_generic(int size, bool sort_relocs)
    : Output_section_data_build(Output_data::default_alignment_for_size(size)),
      relative_reloc_count_(0), sort_relocs_(sort_relocs)
  { }

  // Return the number of relative relocs in this section.
  size_t
  relative_reloc_count() const
  { return this->relative_reloc_count_; }

  // Whether we should sort the relocs.
  bool
  sort_relocs() const
  { return this->sort_relocs_; }

  // Add a reloc of type TYPE against the global symbol GSYM.  The
  // relocation applies to the data at offset ADDRESS within OD.
  virtual void
  add_global_generic(Symbol* gsym, unsigned int type, Output_data* od,
		     uint64_t address, uint64_t addend) = 0;

  // Add a reloc of type TYPE against the global symbol GSYM.  The
  // relocation applies to data at offset ADDRESS within section SHNDX
  // of object file RELOBJ.  OD is the associated output section.
  virtual void
  add_global_generic(Symbol* gsym, unsigned int type, Output_data* od,
		     Relobj* relobj, unsigned int shndx, uint64_t address,
		     uint64_t addend) = 0;

  // Add a reloc of type TYPE against the local symbol LOCAL_SYM_INDEX
  // in RELOBJ.  The relocation applies to the data at offset ADDRESS
  // within OD.
  virtual void
  add_local_generic(Relobj* relobj, unsigned int local_sym_index,
		    unsigned int type, Output_data* od, uint64_t address,
		    uint64_t addend) = 0;

  // Add a reloc of type TYPE against the local symbol LOCAL_SYM_INDEX
  // in RELOBJ.  The relocation applies to the data at offset ADDRESS
  // within section SHNDX of RELOBJ.  OD is the associated output
  // section.
  virtual void
  add_local_generic(Relobj* relobj, unsigned int local_sym_index,
		    unsigned int type, Output_data* od, unsigned int shndx,
		    uint64_t address, uint64_t addend) = 0;

  // Add a reloc of type TYPE against the STT_SECTION symbol of the
  // output section OS.  The relocation applies to the data at offset
  // ADDRESS within OD.
  virtual void
  add_output_section_generic(Output_section *os, unsigned int type,
			     Output_data* od, uint64_t address,
			     uint64_t addend) = 0;

  // Add a reloc of type TYPE against the STT_SECTION symbol of the
  // output section OS.  The relocation applies to the data at offset
  // ADDRESS within section SHNDX of RELOBJ.  OD is the associated
  // output section.
  virtual void
  add_output_section_generic(Output_section* os, unsigned int type,
			     Output_data* od, Relobj* relobj,
			     unsigned int shndx, uint64_t address,
			     uint64_t addend) = 0;

 protected:
  // Note that we've added another relative reloc.
  void
  bump_relative_reloc_count()
  { ++this->relative_reloc_count_; }

 private:
  // The number of relative relocs added to this section.  This is to
  // support DT_RELCOUNT.
  size_t relative_reloc_count_;
  // Whether to sort the relocations when writing them out, to make
  // the dynamic linker more efficient.
  bool sort_relocs_;
};

// Output_data_reloc is used to manage a section containing relocs.
// SH_TYPE is either elfcpp::SHT_REL or elfcpp::SHT_RELA.  DYNAMIC
// indicates whether this is a dynamic relocation or a normal
// relocation.  Output_data_reloc_base is a base class.
// Output_data_reloc is the real class, which we specialize based on
// the reloc type.

template<int sh_type, bool dynamic, int size, bool big_endian>
class Output_data_reloc_base : public Output_data_reloc_generic
{
 public:
  typedef Output_reloc<sh_type, dynamic, size, big_endian> Output_reloc_type;
  typedef typename Output_reloc_type::Address Address;
  static const int reloc_size =
    Reloc_types<sh_type, size, big_endian>::reloc_size;

  // Construct the section.
  Output_data_reloc_base(bool sort_relocs)
    : Output_data_reloc_generic(size, sort_relocs)
  { }

 protected:
  // Write out the data.
  void
  do_write(Output_file*);

  // Set the entry size and the link.
  void
  do_adjust_output_section(Output_section* os);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  {
    mapfile->print_output_data(this,
			       (dynamic
				? _("** dynamic relocs")
				: _("** relocs")));
  }

  // Add a relocation entry.
  void
  add(Output_data* od, const Output_reloc_type& reloc)
  {
    this->relocs_.push_back(reloc);
    this->set_current_data_size(this->relocs_.size() * reloc_size);
    if (dynamic)
      od->add_dynamic_reloc();
    if (reloc.is_relative())
      this->bump_relative_reloc_count();
    Sized_relobj<size, big_endian>* relobj = reloc.get_relobj();
    if (relobj != NULL)
      relobj->add_dyn_reloc(this->relocs_.size() - 1);
  }

 private:
  typedef std::vector<Output_reloc_type> Relocs;

  // The class used to sort the relocations.
  struct Sort_relocs_comparison
  {
    bool
    operator()(const Output_reloc_type& r1, const Output_reloc_type& r2) const
    { return r1.sort_before(r2); }
  };

  // The relocations in this section.
  Relocs relocs_;
};

// The class which callers actually create.

template<int sh_type, bool dynamic, int size, bool big_endian>
class Output_data_reloc;

// The SHT_REL version of Output_data_reloc.

template<bool dynamic, int size, bool big_endian>
class Output_data_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>
  : public Output_data_reloc_base<elfcpp::SHT_REL, dynamic, size, big_endian>
{
 private:
  typedef Output_data_reloc_base<elfcpp::SHT_REL, dynamic, size,
				 big_endian> Base;

 public:
  typedef typename Base::Output_reloc_type Output_reloc_type;
  typedef typename Output_reloc_type::Address Address;

  Output_data_reloc(bool sr)
    : Output_data_reloc_base<elfcpp::SHT_REL, dynamic, size, big_endian>(sr)
  { }

  // Add a reloc against a global symbol.

  void
  add_global(Symbol* gsym, unsigned int type, Output_data* od, Address address)
  {
    this->add(od, Output_reloc_type(gsym, type, od, address,
				    false, false, false));
  }

  void
  add_global(Symbol* gsym, unsigned int type, Output_data* od,
	     Sized_relobj<size, big_endian>* relobj,
	     unsigned int shndx, Address address)
  {
    this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
				    false, false, false));
  }

  void
  add_global_generic(Symbol* gsym, unsigned int type, Output_data* od,
		     uint64_t address, uint64_t addend)
  {
    gold_assert(addend == 0);
    this->add(od, Output_reloc_type(gsym, type, od,
				    convert_types<Address, uint64_t>(address),
				    false, false, false));
  }

  void
  add_global_generic(Symbol* gsym, unsigned int type, Output_data* od,
		     Relobj* relobj, unsigned int shndx, uint64_t address,
		     uint64_t addend)
  {
    gold_assert(addend == 0);
    Sized_relobj<size, big_endian>* sized_relobj =
      static_cast<Sized_relobj<size, big_endian>*>(relobj);
    this->add(od, Output_reloc_type(gsym, type, sized_relobj, shndx,
				    convert_types<Address, uint64_t>(address),
				    false, false, false));
  }

  // Add a RELATIVE reloc against a global symbol.  The final relocation
  // will not reference the symbol.

  void
  add_global_relative(Symbol* gsym, unsigned int type, Output_data* od,
		      Address address)
  {
    this->add(od, Output_reloc_type(gsym, type, od, address, true, true,
				    false));
  }

  void
  add_global_relative(Symbol* gsym, unsigned int type, Output_data* od,
		      Sized_relobj<size, big_endian>* relobj,
		      unsigned int shndx, Address address)
  {
    this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
				    true, true, false));
  }

  // Add a global relocation which does not use a symbol for the relocation,
  // but which gets its addend from a symbol.

  void
  add_symbolless_global_addend(Symbol* gsym, unsigned int type,
			       Output_data* od, Address address)
  {
    this->add(od, Output_reloc_type(gsym, type, od, address, false, true,
				    false));
  }

  void
  add_symbolless_global_addend(Symbol* gsym, unsigned int type,
			       Output_data* od,
			       Sized_relobj<size, big_endian>* relobj,
			       unsigned int shndx, Address address)
  {
    this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
				    false, true, false));
  }

  // Add a reloc against a local symbol.

  void
  add_local(Sized_relobj<size, big_endian>* relobj,
	    unsigned int local_sym_index, unsigned int type,
	    Output_data* od, Address address)
  {
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, od,
				    address, false, false, false, false));
  }

  void
  add_local(Sized_relobj<size, big_endian>* relobj,
	    unsigned int local_sym_index, unsigned int type,
	    Output_data* od, unsigned int shndx, Address address)
  {
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
				    address, false, false, false, false));
  }

  void
  add_local_generic(Relobj* relobj, unsigned int local_sym_index,
		    unsigned int type, Output_data* od, uint64_t address,
		    uint64_t addend)
  {
    gold_assert(addend == 0);
    Sized_relobj<size, big_endian>* sized_relobj =
      static_cast<Sized_relobj<size, big_endian> *>(relobj);
    this->add(od, Output_reloc_type(sized_relobj, local_sym_index, type, od,
				    convert_types<Address, uint64_t>(address),
				    false, false, false, false));
  }

  void
  add_local_generic(Relobj* relobj, unsigned int local_sym_index,
		    unsigned int type, Output_data* od, unsigned int shndx,
		    uint64_t address, uint64_t addend)
  {
    gold_assert(addend == 0);
    Sized_relobj<size, big_endian>* sized_relobj =
      static_cast<Sized_relobj<size, big_endian>*>(relobj);
    this->add(od, Output_reloc_type(sized_relobj, local_sym_index, type, shndx,
				    convert_types<Address, uint64_t>(address),
				    false, false, false, false));
  }

  // Add a RELATIVE reloc against a local symbol.

  void
  add_local_relative(Sized_relobj<size, big_endian>* relobj,
		     unsigned int local_sym_index, unsigned int type,
		     Output_data* od, Address address)
  {
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, od,
				    address, true, true, false, false));
  }

  void
  add_local_relative(Sized_relobj<size, big_endian>* relobj,
		     unsigned int local_sym_index, unsigned int type,
		     Output_data* od, unsigned int shndx, Address address)
  {
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
				    address, true, true, false, false));
  }

  // Add a local relocation which does not use a symbol for the relocation,
  // but which gets its addend from a symbol.

  void
  add_symbolless_local_addend(Sized_relobj<size, big_endian>* relobj,
			      unsigned int local_sym_index, unsigned int type,
			      Output_data* od, Address address)
  {
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, od,
				    address, false, true, false, false));
  }

  void
  add_symbolless_local_addend(Sized_relobj<size, big_endian>* relobj,
			      unsigned int local_sym_index, unsigned int type,
			      Output_data* od, unsigned int shndx,
			      Address address)
  {
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
				    address, false, true, false, false));
  }

  // Add a reloc against a local section symbol.  This will be
  // converted into a reloc against the STT_SECTION symbol of the
  // output section.

  void
  add_local_section(Sized_relobj<size, big_endian>* relobj,
		    unsigned int input_shndx, unsigned int type,
		    Output_data* od, Address address)
  {
    this->add(od, Output_reloc_type(relobj, input_shndx, type, od,
				    address, false, false, true, false));
  }

  void
  add_local_section(Sized_relobj<size, big_endian>* relobj,
		    unsigned int input_shndx, unsigned int type,
		    Output_data* od, unsigned int shndx, Address address)
  {
    this->add(od, Output_reloc_type(relobj, input_shndx, type, shndx,
				    address, false, false, true, false));
  }

  // A reloc against the STT_SECTION symbol of an output section.
  // OS is the Output_section that the relocation refers to; OD is
  // the Output_data object being relocated.

  void
  add_output_section(Output_section* os, unsigned int type,
		     Output_data* od, Address address)
  { this->add(od, Output_reloc_type(os, type, od, address, false)); }

  void
  add_output_section(Output_section* os, unsigned int type, Output_data* od,
		     Sized_relobj<size, big_endian>* relobj,
		     unsigned int shndx, Address address)
  { this->add(od, Output_reloc_type(os, type, relobj, shndx, address, false)); }

  void
  add_output_section_generic(Output_section* os, unsigned int type,
			     Output_data* od, uint64_t address,
			     uint64_t addend)
  {
    gold_assert(addend == 0);
    this->add(od, Output_reloc_type(os, type, od,
				    convert_types<Address, uint64_t>(address),
				    false));
  }

  void
  add_output_section_generic(Output_section* os, unsigned int type,
			     Output_data* od, Relobj* relobj,
			     unsigned int shndx, uint64_t address,
			     uint64_t addend)
  {
    gold_assert(addend == 0);
    Sized_relobj<size, big_endian>* sized_relobj =
      static_cast<Sized_relobj<size, big_endian>*>(relobj);
    this->add(od, Output_reloc_type(os, type, sized_relobj, shndx,
				    convert_types<Address, uint64_t>(address),
				    false));
  }

  // As above, but the reloc TYPE is relative

  void
  add_output_section_relative(Output_section* os, unsigned int type,
			      Output_data* od, Address address)
  { this->add(od, Output_reloc_type(os, type, od, address, true)); }

  void
  add_output_section_relative(Output_section* os, unsigned int type,
			      Output_data* od,
			      Sized_relobj<size, big_endian>* relobj,
			      unsigned int shndx, Address address)
  { this->add(od, Output_reloc_type(os, type, relobj, shndx, address, true)); }

  // Add an absolute relocation.

  void
  add_absolute(unsigned int type, Output_data* od, Address address)
  { this->add(od, Output_reloc_type(type, od, address, false)); }

  void
  add_absolute(unsigned int type, Output_data* od,
	       Sized_relobj<size, big_endian>* relobj,
	       unsigned int shndx, Address address)
  { this->add(od, Output_reloc_type(type, relobj, shndx, address, false)); }

  // Add a relative relocation

  void
  add_relative(unsigned int type, Output_data* od, Address address)
  { this->add(od, Output_reloc_type(type, od, address, true)); }

  void
  add_relative(unsigned int type, Output_data* od,
	       Sized_relobj<size, big_endian>* relobj,
	       unsigned int shndx, Address address)
  { this->add(od, Output_reloc_type(type, relobj, shndx, address, true)); }

  // Add a target specific relocation.  A target which calls this must
  // define the reloc_symbol_index and reloc_addend virtual functions.

  void
  add_target_specific(unsigned int type, void* arg, Output_data* od,
		      Address address)
  { this->add(od, Output_reloc_type(type, arg, od, address)); }

  void
  add_target_specific(unsigned int type, void* arg, Output_data* od,
		      Sized_relobj<size, big_endian>* relobj,
		      unsigned int shndx, Address address)
  { this->add(od, Output_reloc_type(type, arg, relobj, shndx, address)); }
};

// The SHT_RELA version of Output_data_reloc.

template<bool dynamic, int size, bool big_endian>
class Output_data_reloc<elfcpp::SHT_RELA, dynamic, size, big_endian>
  : public Output_data_reloc_base<elfcpp::SHT_RELA, dynamic, size, big_endian>
{
 private:
  typedef Output_data_reloc_base<elfcpp::SHT_RELA, dynamic, size,
				 big_endian> Base;

 public:
  typedef typename Base::Output_reloc_type Output_reloc_type;
  typedef typename Output_reloc_type::Address Address;
  typedef typename Output_reloc_type::Addend Addend;

  Output_data_reloc(bool sr)
    : Output_data_reloc_base<elfcpp::SHT_RELA, dynamic, size, big_endian>(sr)
  { }

  // Add a reloc against a global symbol.

  void
  add_global(Symbol* gsym, unsigned int type, Output_data* od,
	     Address address, Addend addend)
  {
    this->add(od, Output_reloc_type(gsym, type, od, address, addend,
				    false, false, false));
  }

  void
  add_global(Symbol* gsym, unsigned int type, Output_data* od,
	     Sized_relobj<size, big_endian>* relobj,
	     unsigned int shndx, Address address,
	     Addend addend)
  {
    this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
				    addend, false, false, false));
  }

  void
  add_global_generic(Symbol* gsym, unsigned int type, Output_data* od,
		     uint64_t address, uint64_t addend)
  {
    this->add(od, Output_reloc_type(gsym, type, od,
				    convert_types<Address, uint64_t>(address),
				    convert_types<Addend, uint64_t>(addend),
				    false, false, false));
  }

  void
  add_global_generic(Symbol* gsym, unsigned int type, Output_data* od,
		     Relobj* relobj, unsigned int shndx, uint64_t address,
		     uint64_t addend)
  {
    Sized_relobj<size, big_endian>* sized_relobj =
      static_cast<Sized_relobj<size, big_endian>*>(relobj);
    this->add(od, Output_reloc_type(gsym, type, sized_relobj, shndx,
				    convert_types<Address, uint64_t>(address),
				    convert_types<Addend, uint64_t>(addend),
				    false, false, false));
  }

  // Add a RELATIVE reloc against a global symbol.  The final output
  // relocation will not reference the symbol, but we must keep the symbol
  // information long enough to set the addend of the relocation correctly
  // when it is written.

  void
  add_global_relative(Symbol* gsym, unsigned int type, Output_data* od,
		      Address address, Addend addend, bool use_plt_offset)
  {
    this->add(od, Output_reloc_type(gsym, type, od, address, addend, true,
				    true, use_plt_offset));
  }

  void
  add_global_relative(Symbol* gsym, unsigned int type, Output_data* od,
		      Sized_relobj<size, big_endian>* relobj,
		      unsigned int shndx, Address address, Addend addend,
		      bool use_plt_offset)
  {
    this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
				    addend, true, true, use_plt_offset));
  }

  // Add a global relocation which does not use a symbol for the relocation,
  // but which gets its addend from a symbol.

  void
  add_symbolless_global_addend(Symbol* gsym, unsigned int type, Output_data* od,
			       Address address, Addend addend)
  {
    this->add(od, Output_reloc_type(gsym, type, od, address, addend,
				    false, true, false));
  }

  void
  add_symbolless_global_addend(Symbol* gsym, unsigned int type,
			       Output_data* od,
			       Sized_relobj<size, big_endian>* relobj,
			       unsigned int shndx, Address address,
			       Addend addend)
  {
    this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
				    addend, false, true, false));
  }

  // Add a reloc against a local symbol.

  void
  add_local(Sized_relobj<size, big_endian>* relobj,
	    unsigned int local_sym_index, unsigned int type,
	    Output_data* od, Address address, Addend addend)
  {
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, od, address,
				    addend, false, false, false, false));
  }

  void
  add_local(Sized_relobj<size, big_endian>* relobj,
	    unsigned int local_sym_index, unsigned int type,
	    Output_data* od, unsigned int shndx, Address address,
	    Addend addend)
  {
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
				    address, addend, false, false, false,
				    false));
  }

  void
  add_local_generic(Relobj* relobj, unsigned int local_sym_index,
		    unsigned int type, Output_data* od, uint64_t address,
		    uint64_t addend)
  {
    Sized_relobj<size, big_endian>* sized_relobj =
      static_cast<Sized_relobj<size, big_endian> *>(relobj);
    this->add(od, Output_reloc_type(sized_relobj, local_sym_index, type, od,
				    convert_types<Address, uint64_t>(address),
				    convert_types<Addend, uint64_t>(addend),
				    false, false, false, false));
  }

  void
  add_local_generic(Relobj* relobj, unsigned int local_sym_index,
		    unsigned int type, Output_data* od, unsigned int shndx,
		    uint64_t address, uint64_t addend)
  {
    Sized_relobj<size, big_endian>* sized_relobj =
      static_cast<Sized_relobj<size, big_endian>*>(relobj);
    this->add(od, Output_reloc_type(sized_relobj, local_sym_index, type, shndx,
				    convert_types<Address, uint64_t>(address),
				    convert_types<Addend, uint64_t>(addend),
				    false, false, false, false));
  }

  // Add a RELATIVE reloc against a local symbol.

  void
  add_local_relative(Sized_relobj<size, big_endian>* relobj,
		     unsigned int local_sym_index, unsigned int type,
		     Output_data* od, Address address, Addend addend,
		     bool use_plt_offset)
  {
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, od, address,
				    addend, true, true, false,
				    use_plt_offset));
  }

  void
  add_local_relative(Sized_relobj<size, big_endian>* relobj,
		     unsigned int local_sym_index, unsigned int type,
		     Output_data* od, unsigned int shndx, Address address,
		     Addend addend, bool use_plt_offset)
  {
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
				    address, addend, true, true, false,
				    use_plt_offset));
  }

  // Add a local relocation which does not use a symbol for the relocation,
  // but which gets it's addend from a symbol.

  void
  add_symbolless_local_addend(Sized_relobj<size, big_endian>* relobj,
			      unsigned int local_sym_index, unsigned int type,
			      Output_data* od, Address address, Addend addend)
  {
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, od, address,
				    addend, false, true, false, false));
  }

  void
  add_symbolless_local_addend(Sized_relobj<size, big_endian>* relobj,
			      unsigned int local_sym_index, unsigned int type,
			      Output_data* od, unsigned int shndx,
			      Address address, Addend addend)
  {
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
				    address, addend, false, true, false,
				    false));
  }

  // Add a reloc against a local section symbol.  This will be
  // converted into a reloc against the STT_SECTION symbol of the
  // output section.

  void
  add_local_section(Sized_relobj<size, big_endian>* relobj,
		    unsigned int input_shndx, unsigned int type,
		    Output_data* od, Address address, Addend addend)
  {
    this->add(od, Output_reloc_type(relobj, input_shndx, type, od, address,
				    addend, false, false, true, false));
  }

  void
  add_local_section(Sized_relobj<size, big_endian>* relobj,
		    unsigned int input_shndx, unsigned int type,
		    Output_data* od, unsigned int shndx, Address address,
		    Addend addend)
  {
    this->add(od, Output_reloc_type(relobj, input_shndx, type, shndx,
				    address, addend, false, false, true,
				    false));
  }

  // A reloc against the STT_SECTION symbol of an output section.

  void
  add_output_section(Output_section* os, unsigned int type, Output_data* od,
		     Address address, Addend addend)
  { this->add(od, Output_reloc_type(os, type, od, address, addend, false)); }

  void
  add_output_section(Output_section* os, unsigned int type, Output_data* od,
		     Sized_relobj<size, big_endian>* relobj,
		     unsigned int shndx, Address address, Addend addend)
  {
    this->add(od, Output_reloc_type(os, type, relobj, shndx, address,
				    addend, false));
  }

  void
  add_output_section_generic(Output_section* os, unsigned int type,
			     Output_data* od, uint64_t address,
			     uint64_t addend)
  {
    this->add(od, Output_reloc_type(os, type, od,
				    convert_types<Address, uint64_t>(address),
				    convert_types<Addend, uint64_t>(addend),
				    false));
  }

  void
  add_output_section_generic(Output_section* os, unsigned int type,
			     Output_data* od, Relobj* relobj,
			     unsigned int shndx, uint64_t address,
			     uint64_t addend)
  {
    Sized_relobj<size, big_endian>* sized_relobj =
      static_cast<Sized_relobj<size, big_endian>*>(relobj);
    this->add(od, Output_reloc_type(os, type, sized_relobj, shndx,
				    convert_types<Address, uint64_t>(address),
				    convert_types<Addend, uint64_t>(addend),
				    false));
  }

  // As above, but the reloc TYPE is relative

  void
  add_output_section_relative(Output_section* os, unsigned int type,
			      Output_data* od, Address address, Addend addend)
  { this->add(od, Output_reloc_type(os, type, od, address, addend, true)); }

  void
  add_output_section_relative(Output_section* os, unsigned int type,
			      Output_data* od,
			      Sized_relobj<size, big_endian>* relobj,
			      unsigned int shndx, Address address,
			      Addend addend)
  {
    this->add(od, Output_reloc_type(os, type, relobj, shndx,
				    address, addend, true));
  }

  // Add an absolute relocation.

  void
  add_absolute(unsigned int type, Output_data* od, Address address,
	       Addend addend)
  { this->add(od, Output_reloc_type(type, od, address, addend, false)); }

  void
  add_absolute(unsigned int type, Output_data* od,
	       Sized_relobj<size, big_endian>* relobj,
	       unsigned int shndx, Address address, Addend addend)
  {
    this->add(od, Output_reloc_type(type, relobj, shndx, address, addend,
				    false));
  }

  // Add a relative relocation

  void
  add_relative(unsigned int type, Output_data* od, Address address,
	       Addend addend)
  { this->add(od, Output_reloc_type(type, od, address, addend, true)); }

  void
  add_relative(unsigned int type, Output_data* od,
	       Sized_relobj<size, big_endian>* relobj,
	       unsigned int shndx, Address address, Addend addend)
  {
    this->add(od, Output_reloc_type(type, relobj, shndx, address, addend,
				    true));
  }

  // Add a target specific relocation.  A target which calls this must
  // define the reloc_symbol_index and reloc_addend virtual functions.

  void
  add_target_specific(unsigned int type, void* arg, Output_data* od,
		      Address address, Addend addend)
  { this->add(od, Output_reloc_type(type, arg, od, address, addend)); }

  void
  add_target_specific(unsigned int type, void* arg, Output_data* od,
		      Sized_relobj<size, big_endian>* relobj,
		      unsigned int shndx, Address address, Addend addend)
  {
    this->add(od, Output_reloc_type(type, arg, relobj, shndx, address,
				    addend));
  }
};

// Output_relocatable_relocs represents a relocation section in a
// relocatable link.  The actual data is written out in the target
// hook relocate_relocs.  This just saves space for it.

template<int sh_type, int size, bool big_endian>
class Output_relocatable_relocs : public Output_section_data
{
 public:
  Output_relocatable_relocs(Relocatable_relocs* rr)
    : Output_section_data(Output_data::default_alignment_for_size(size)),
      rr_(rr)
  { }

  void
  set_final_data_size();

  // Write out the data.  There is nothing to do here.
  void
  do_write(Output_file*)
  { }

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** relocs")); }

 private:
  // The relocs associated with this input section.
  Relocatable_relocs* rr_;
};

// Handle a GROUP section.

template<int size, bool big_endian>
class Output_data_group : public Output_section_data
{
 public:
  // The constructor clears *INPUT_SHNDXES.
  Output_data_group(Sized_relobj_file<size, big_endian>* relobj,
		    section_size_type entry_count,
		    elfcpp::Elf_Word flags,
		    std::vector<unsigned int>* input_shndxes);

  void
  do_write(Output_file*);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** group")); }

  // Set final data size.
  void
  set_final_data_size()
  { this->set_data_size((this->input_shndxes_.size() + 1) * 4); }

 private:
  // The input object.
  Sized_relobj_file<size, big_endian>* relobj_;
  // The group flag word.
  elfcpp::Elf_Word flags_;
  // The section indexes of the input sections in this group.
  std::vector<unsigned int> input_shndxes_;
};

// Output_data_got is used to manage a GOT.  Each entry in the GOT is
// for one symbol--either a global symbol or a local symbol in an
// object.  The target specific code adds entries to the GOT as
// needed.  The GOT_SIZE template parameter is the size in bits of a
// GOT entry, typically 32 or 64.

class Output_data_got_base : public Output_section_data_build
{
 public:
  Output_data_got_base(uint64_t align)
    : Output_section_data_build(align)
  { }

  Output_data_got_base(off_t data_size, uint64_t align)
    : Output_section_data_build(data_size, align)
  { }

  // Reserve the slot at index I in the GOT.
  void
  reserve_slot(unsigned int i)
  { this->do_reserve_slot(i); }

 protected:
  // Reserve the slot at index I in the GOT.
  virtual void
  do_reserve_slot(unsigned int i) = 0;
};

template<int got_size, bool big_endian>
class Output_data_got : public Output_data_got_base
{
 public:
  typedef typename elfcpp::Elf_types<got_size>::Elf_Addr Valtype;

  Output_data_got()
    : Output_data_got_base(Output_data::default_alignment_for_size(got_size)),
      entries_(), free_list_()
  { }

  Output_data_got(off_t data_size)
    : Output_data_got_base(data_size,
			   Output_data::default_alignment_for_size(got_size)),
      entries_(), free_list_()
  {
    // For an incremental update, we have an existing GOT section.
    // Initialize the list of entries and the free list.
    this->entries_.resize(data_size / (got_size / 8));
    this->free_list_.init(data_size, false);
  }

  // Add an entry for a global symbol to the GOT.  Return true if this
  // is a new GOT entry, false if the symbol was already in the GOT.
  bool
  add_global(Symbol* gsym, unsigned int got_type);

  // Like add_global, but use the PLT offset of the global symbol if
  // it has one.
  bool
  add_global_plt(Symbol* gsym, unsigned int got_type);

  // Like add_global, but for a TLS symbol where the value will be
  // offset using Target::tls_offset_for_global.
  bool
  add_global_tls(Symbol* gsym, unsigned int got_type)
  { return add_global_plt(gsym, got_type); }

  // Add an entry for a global symbol to the GOT, and add a dynamic
  // relocation of type R_TYPE for the GOT entry.
  void
  add_global_with_rel(Symbol* gsym, unsigned int got_type,
		      Output_data_reloc_generic* rel_dyn, unsigned int r_type);

  // Add a pair of entries for a global symbol to the GOT, and add
  // dynamic relocations of type R_TYPE_1 and R_TYPE_2, respectively.
  void
  add_global_pair_with_rel(Symbol* gsym, unsigned int got_type,
			   Output_data_reloc_generic* rel_dyn,
			   unsigned int r_type_1, unsigned int r_type_2);

  // Add an entry for a local symbol to the GOT.  This returns true if
  // this is a new GOT entry, false if the symbol already has a GOT
  // entry.
  bool
  add_local(Relobj* object, unsigned int sym_index, unsigned int got_type);

  // Like add_local, but use the PLT offset of the local symbol if it
  // has one.
  bool
  add_local_plt(Relobj* object, unsigned int sym_index, unsigned int got_type);

  // Like add_local, but for a TLS symbol where the value will be
  // offset using Target::tls_offset_for_local.
  bool
  add_local_tls(Relobj* object, unsigned int sym_index, unsigned int got_type)
  { return add_local_plt(object, sym_index, got_type); }

  // Add an entry for a local symbol to the GOT, and add a dynamic
  // relocation of type R_TYPE for the GOT entry.
  void
  add_local_with_rel(Relobj* object, unsigned int sym_index,
		     unsigned int got_type, Output_data_reloc_generic* rel_dyn,
		     unsigned int r_type);

  // Add a pair of entries for a local symbol to the GOT, and add
  // a dynamic relocation of type R_TYPE using the section symbol of
  // the output section to which input section SHNDX maps, on the first.
  // The first got entry will have a value of zero, the second the
  // value of the local symbol.
  void
  add_local_pair_with_rel(Relobj* object, unsigned int sym_index,
			  unsigned int shndx, unsigned int got_type,
			  Output_data_reloc_generic* rel_dyn,
			  unsigned int r_type);

  // Add a pair of entries for a local symbol to the GOT, and add
  // a dynamic relocation of type R_TYPE using STN_UNDEF on the first.
  // The first got entry will have a value of zero, the second the
  // value of the local symbol offset by Target::tls_offset_for_local.
  void
  add_local_tls_pair(Relobj* object, unsigned int sym_index,
		     unsigned int got_type,
		     Output_data_reloc_generic* rel_dyn,
		     unsigned int r_type);

  // Add a constant to the GOT.  This returns the offset of the new
  // entry from the start of the GOT.
  unsigned int
  add_constant(Valtype constant)
  { return this->add_got_entry(Got_entry(constant)); }

  // Add a pair of constants to the GOT.  This returns the offset of
  // the new entry from the start of the GOT.
  unsigned int
  add_constant_pair(Valtype c1, Valtype c2)
  { return this->add_got_entry_pair(Got_entry(c1), Got_entry(c2)); }

  // Replace GOT entry I with a new constant.
  void
  replace_constant(unsigned int i, Valtype constant)
  {
    this->replace_got_entry(i, Got_entry(constant));
  }

  // Reserve a slot in the GOT for a local symbol.
  void
  reserve_local(unsigned int i, Relobj* object, unsigned int sym_index,
		unsigned int got_type);

  // Reserve a slot in the GOT for a global symbol.
  void
  reserve_global(unsigned int i, Symbol* gsym, unsigned int got_type);

 protected:
  // Write out the GOT table.
  void
  do_write(Output_file*);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** GOT")); }

  // Reserve the slot at index I in the GOT.
  virtual void
  do_reserve_slot(unsigned int i)
  { this->free_list_.remove(i * got_size / 8, (i + 1) * got_size / 8); }

  // Return the number of words in the GOT.
  unsigned int
  num_entries () const
  { return this->entries_.size(); }

  // Return the offset into the GOT of GOT entry I.
  unsigned int
  got_offset(unsigned int i) const
  { return i * (got_size / 8); }

 private:
  // This POD class holds a single GOT entry.
  class Got_entry
  {
   public:
    // Create a zero entry.
    Got_entry()
      : local_sym_index_(RESERVED_CODE), use_plt_or_tls_offset_(false)
    { this->u_.constant = 0; }

    // Create a global symbol entry.
    Got_entry(Symbol* gsym, bool use_plt_or_tls_offset)
      : local_sym_index_(GSYM_CODE),
	use_plt_or_tls_offset_(use_plt_or_tls_offset)
    { this->u_.gsym = gsym; }

    // Create a local symbol entry.
    Got_entry(Relobj* object, unsigned int local_sym_index,
	      bool use_plt_or_tls_offset)
      : local_sym_index_(local_sym_index),
	use_plt_or_tls_offset_(use_plt_or_tls_offset)
    {
      gold_assert(local_sym_index != GSYM_CODE
		  && local_sym_index != CONSTANT_CODE
		  && local_sym_index != RESERVED_CODE
		  && local_sym_index == this->local_sym_index_);
      this->u_.object = object;
    }

    // Create a constant entry.  The constant is a host value--it will
    // be swapped, if necessary, when it is written out.
    explicit Got_entry(Valtype constant)
      : local_sym_index_(CONSTANT_CODE), use_plt_or_tls_offset_(false)
    { this->u_.constant = constant; }

    // Write the GOT entry to an output view.
    void
    write(unsigned int got_indx, unsigned char* pov) const;

   private:
    enum
    {
      GSYM_CODE = 0x7fffffff,
      CONSTANT_CODE = 0x7ffffffe,
      RESERVED_CODE = 0x7ffffffd
    };

    union
    {
      // For a local symbol, the object.
      Relobj* object;
      // For a global symbol, the symbol.
      Symbol* gsym;
      // For a constant, the constant.
      Valtype constant;
    } u_;
    // For a local symbol, the local symbol index.  This is GSYM_CODE
    // for a global symbol, or CONSTANT_CODE for a constant.
    unsigned int local_sym_index_ : 31;
    // Whether to use the PLT offset of the symbol if it has one.
    // For TLS symbols, whether to offset the symbol value.
    bool use_plt_or_tls_offset_ : 1;
  };

  typedef std::vector<Got_entry> Got_entries;

  // Create a new GOT entry and return its offset.
  unsigned int
  add_got_entry(Got_entry got_entry);

  // Create a pair of new GOT entries and return the offset of the first.
  unsigned int
  add_got_entry_pair(Got_entry got_entry_1, Got_entry got_entry_2);

  // Replace GOT entry I with a new value.
  void
  replace_got_entry(unsigned int i, Got_entry got_entry);

  // Return the offset into the GOT of the last entry added.
  unsigned int
  last_got_offset() const
  { return this->got_offset(this->num_entries() - 1); }

  // Set the size of the section.
  void
  set_got_size()
  { this->set_current_data_size(this->got_offset(this->num_entries())); }

  // The list of GOT entries.
  Got_entries entries_;

  // List of available regions within the section, for incremental
  // update links.
  Free_list free_list_;
};

// Output_data_dynamic is used to hold the data in SHT_DYNAMIC
// section.

class Output_data_dynamic : public Output_section_data
{
 public:
  Output_data_dynamic(Stringpool* pool)
    : Output_section_data(Output_data::default_alignment()),
      entries_(), pool_(pool)
  { }

  // Add a new dynamic entry with a fixed numeric value.
  void
  add_constant(elfcpp::DT tag, unsigned int val)
  { this->add_entry(Dynamic_entry(tag, val)); }

  // Add a new dynamic entry with the address of output data.
  void
  add_section_address(elfcpp::DT tag, const Output_data* od)
  { this->add_entry(Dynamic_entry(tag, od, false)); }

  // Add a new dynamic entry with the address of output data
  // plus a constant offset.
  void
  add_section_plus_offset(elfcpp::DT tag, const Output_data* od,
			  unsigned int offset)
  { this->add_entry(Dynamic_entry(tag, od, offset)); }

  // Add a new dynamic entry with the size of output data.
  void
  add_section_size(elfcpp::DT tag, const Output_data* od)
  { this->add_entry(Dynamic_entry(tag, od, true)); }

  // Add a new dynamic entry with the total size of two output datas.
  void
  add_section_size(elfcpp::DT tag, const Output_data* od,
		   const Output_data* od2)
  { this->add_entry(Dynamic_entry(tag, od, od2)); }

  // Add a new dynamic entry with the address of a symbol.
  void
  add_symbol(elfcpp::DT tag, const Symbol* sym)
  { this->add_entry(Dynamic_entry(tag, sym)); }

  // Add a new dynamic entry with a string.
  void
  add_string(elfcpp::DT tag, const char* str)
  { this->add_entry(Dynamic_entry(tag, this->pool_->add(str, true, NULL))); }

  void
  add_string(elfcpp::DT tag, const std::string& str)
  { this->add_string(tag, str.c_str()); }

 protected:
  // Adjust the output section to set the entry size.
  void
  do_adjust_output_section(Output_section*);

  // Set the final data size.
  void
  set_final_data_size();

  // Write out the dynamic entries.
  void
  do_write(Output_file*);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** dynamic")); }

 private:
  // This POD class holds a single dynamic entry.
  class Dynamic_entry
  {
   public:
    // Create an entry with a fixed numeric value.
    Dynamic_entry(elfcpp::DT tag, unsigned int val)
      : tag_(tag), offset_(DYNAMIC_NUMBER)
    { this->u_.val = val; }

    // Create an entry with the size or address of a section.
    Dynamic_entry(elfcpp::DT tag, const Output_data* od, bool section_size)
      : tag_(tag),
	offset_(section_size
		? DYNAMIC_SECTION_SIZE
		: DYNAMIC_SECTION_ADDRESS)
    {
      this->u_.od = od;
      this->od2 = NULL;
    }

    // Create an entry with the size of two sections.
    Dynamic_entry(elfcpp::DT tag, const Output_data* od, const Output_data* od2)
      : tag_(tag),
	offset_(DYNAMIC_SECTION_SIZE)
    {
      this->u_.od = od;
      this->od2 = od2;
    }

    // Create an entry with the address of a section plus a constant offset.
    Dynamic_entry(elfcpp::DT tag, const Output_data* od, unsigned int offset)
      : tag_(tag),
	offset_(offset)
    { this->u_.od = od; }

    // Create an entry with the address of a symbol.
    Dynamic_entry(elfcpp::DT tag, const Symbol* sym)
      : tag_(tag), offset_(DYNAMIC_SYMBOL)
    { this->u_.sym = sym; }

    // Create an entry with a string.
    Dynamic_entry(elfcpp::DT tag, const char* str)
      : tag_(tag), offset_(DYNAMIC_STRING)
    { this->u_.str = str; }

    // Return the tag of this entry.
    elfcpp::DT
    tag() const
    { return this->tag_; }

    // Write the dynamic entry to an output view.
    template<int size, bool big_endian>
    void
    write(unsigned char* pov, const Stringpool*) const;

   private:
    // Classification is encoded in the OFFSET field.
    enum Classification
    {
      // Section address.
      DYNAMIC_SECTION_ADDRESS = 0,
      // Number.
      DYNAMIC_NUMBER = -1U,
      // Section size.
      DYNAMIC_SECTION_SIZE = -2U,
      // Symbol adress.
      DYNAMIC_SYMBOL = -3U,
      // String.
      DYNAMIC_STRING = -4U
      // Any other value indicates a section address plus OFFSET.
    };

    union
    {
      // For DYNAMIC_NUMBER.
      unsigned int val;
      // For DYNAMIC_SECTION_SIZE and section address plus OFFSET.
      const Output_data* od;
      // For DYNAMIC_SYMBOL.
      const Symbol* sym;
      // For DYNAMIC_STRING.
      const char* str;
    } u_;
    // For DYNAMIC_SYMBOL with two sections.
    const Output_data* od2;
    // The dynamic tag.
    elfcpp::DT tag_;
    // The type of entry (Classification) or offset within a section.
    unsigned int offset_;
  };

  // Add an entry to the list.
  void
  add_entry(const Dynamic_entry& entry)
  { this->entries_.push_back(entry); }

  // Sized version of write function.
  template<int size, bool big_endian>
  void
  sized_write(Output_file* of);

  // The type of the list of entries.
  typedef std::vector<Dynamic_entry> Dynamic_entries;

  // The entries.
  Dynamic_entries entries_;
  // The pool used for strings.
  Stringpool* pool_;
};

// Output_symtab_xindex is used to handle SHT_SYMTAB_SHNDX sections,
// which may be required if the object file has more than
// SHN_LORESERVE sections.

class Output_symtab_xindex : public Output_section_data
{
 public:
  Output_symtab_xindex(size_t symcount)
    : Output_section_data(symcount * 4, 4, true),
      entries_()
  { }

  // Add an entry: symbol number SYMNDX has section SHNDX.
  void
  add(unsigned int symndx, unsigned int shndx)
  { this->entries_.push_back(std::make_pair(symndx, shndx)); }

 protected:
  void
  do_write(Output_file*);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** symtab xindex")); }

 private:
  template<bool big_endian>
  void
  endian_do_write(unsigned char*);

  // It is likely that most symbols will not require entries.  Rather
  // than keep a vector for all symbols, we keep pairs of symbol index
  // and section index.
  typedef std::vector<std::pair<unsigned int, unsigned int> > Xindex_entries;

  // The entries we need.
  Xindex_entries entries_;
};

// A relaxed input section.
class Output_relaxed_input_section : public Output_section_data_build
{
 public:
  // We would like to call relobj->section_addralign(shndx) to get the
  // alignment but we do not want the constructor to fail.  So callers
  // are repsonsible for ensuring that.
  Output_relaxed_input_section(Relobj* relobj, unsigned int shndx,
			       uint64_t addralign)
    : Output_section_data_build(addralign), relobj_(relobj), shndx_(shndx)
  { }

  // Return the Relobj of this relaxed input section.
  Relobj*
  relobj() const
  { return this->relobj_; }

  // Return the section index of this relaxed input section.
  unsigned int
  shndx() const
  { return this->shndx_; }

 protected:
  void
  set_relobj(Relobj* relobj)
  { this->relobj_ = relobj; }

  void
  set_shndx(unsigned int shndx)
  { this->shndx_ = shndx; }

 private:
  Relobj* relobj_;
  unsigned int shndx_;
};

// This class describes properties of merge data sections.  It is used
// as a key type for maps.
class Merge_section_properties
{
 public:
  Merge_section_properties(bool is_string, uint64_t entsize,
			     uint64_t addralign)
    : is_string_(is_string), entsize_(entsize), addralign_(addralign)
  { }

  // Whether this equals to another Merge_section_properties MSP.
  bool
  eq(const Merge_section_properties& msp) const
  {
    return ((this->is_string_ == msp.is_string_)
	    && (this->entsize_ == msp.entsize_)
	    && (this->addralign_ == msp.addralign_));
  }

  // Compute a hash value for this using 64-bit FNV-1a hash.
  size_t
  hash_value() const
  {
    uint64_t h = 14695981039346656037ULL;	// FNV offset basis.
    uint64_t prime = 1099511628211ULL;
    h = (h ^ static_cast<uint64_t>(this->is_string_)) * prime;
    h = (h ^ static_cast<uint64_t>(this->entsize_)) * prime;
    h = (h ^ static_cast<uint64_t>(this->addralign_)) * prime;
    return h;
  }

  // Functors for associative containers.
  struct equal_to
  {
    bool
    operator()(const Merge_section_properties& msp1,
	       const Merge_section_properties& msp2) const
    { return msp1.eq(msp2); }
  };

  struct hash
  {
    size_t
    operator()(const Merge_section_properties& msp) const
    { return msp.hash_value(); }
  };

 private:
  // Whether this merge data section is for strings.
  bool is_string_;
  // Entsize of this merge data section.
  uint64_t entsize_;
  // Address alignment.
  uint64_t addralign_;
};

// This class is used to speed up look up of special input sections in an
// Output_section.

class Output_section_lookup_maps
{
 public:
  Output_section_lookup_maps()
    : is_valid_(true), merge_sections_by_properties_(),
      merge_sections_by_id_(), relaxed_input_sections_by_id_()
  { }

  // Whether the maps are valid.
  bool
  is_valid() const
  { return this->is_valid_; }

  // Invalidate the maps.
  void
  invalidate()
  { this->is_valid_ = false; }

  // Clear the maps.
  void
  clear()
  {
    this->merge_sections_by_properties_.clear();
    this->merge_sections_by_id_.clear();
    this->relaxed_input_sections_by_id_.clear();
    // A cleared map is valid.
    this->is_valid_ = true;
  }

  // Find a merge section by merge section properties.  Return NULL if none
  // is found.
  Output_merge_base*
  find_merge_section(const Merge_section_properties& msp) const
  {
    gold_assert(this->is_valid_);
    Merge_sections_by_properties::const_iterator p =
      this->merge_sections_by_properties_.find(msp);
    return p != this->merge_sections_by_properties_.end() ? p->second : NULL;
  }

  // Find a merge section by section ID of a merge input section.  Return NULL
  // if none is found.
  Output_merge_base*
  find_merge_section(const Object* object, unsigned int shndx) const
  {
    gold_assert(this->is_valid_);
    Merge_sections_by_id::const_iterator p =
      this->merge_sections_by_id_.find(Const_section_id(object, shndx));
    return p != this->merge_sections_by_id_.end() ? p->second : NULL;
  }

  // Add a merge section pointed by POMB with properties MSP.
  void
  add_merge_section(const Merge_section_properties& msp,
		    Output_merge_base* pomb)
  {
    std::pair<Merge_section_properties, Output_merge_base*> value(msp, pomb);
    std::pair<Merge_sections_by_properties::iterator, bool> result =
      this->merge_sections_by_properties_.insert(value);
    gold_assert(result.second);
  }

  // Add a mapping from a merged input section in OBJECT with index SHNDX
  // to a merge output section pointed by POMB.
  void
  add_merge_input_section(const Object* object, unsigned int shndx,
			  Output_merge_base* pomb)
  {
    Const_section_id csid(object, shndx);
    std::pair<Const_section_id, Output_merge_base*> value(csid, pomb);
    std::pair<Merge_sections_by_id::iterator, bool> result =
      this->merge_sections_by_id_.insert(value);
    gold_assert(result.second);
  }

  // Find a relaxed input section of OBJECT with index SHNDX.
  Output_relaxed_input_section*
  find_relaxed_input_section(const Object* object, unsigned int shndx) const
  {
    gold_assert(this->is_valid_);
    Relaxed_input_sections_by_id::const_iterator p =
      this->relaxed_input_sections_by_id_.find(Const_section_id(object, shndx));
    return p != this->relaxed_input_sections_by_id_.end() ? p->second : NULL;
  }

  // Add a relaxed input section pointed by POMB and whose original input
  // section is in OBJECT with index SHNDX.
  void
  add_relaxed_input_section(const Relobj* relobj, unsigned int shndx,
			    Output_relaxed_input_section* poris)
  {
    Const_section_id csid(relobj, shndx);
    std::pair<Const_section_id, Output_relaxed_input_section*>
      value(csid, poris);
    std::pair<Relaxed_input_sections_by_id::iterator, bool> result =
      this->relaxed_input_sections_by_id_.insert(value);
    gold_assert(result.second);
  }

 private:
  typedef Unordered_map<Const_section_id, Output_merge_base*,
			Const_section_id_hash>
    Merge_sections_by_id;

  typedef Unordered_map<Merge_section_properties, Output_merge_base*,
			Merge_section_properties::hash,
			Merge_section_properties::equal_to>
    Merge_sections_by_properties;

  typedef Unordered_map<Const_section_id, Output_relaxed_input_section*,
			Const_section_id_hash>
    Relaxed_input_sections_by_id;

  // Whether this is valid
  bool is_valid_;
  // Merge sections by merge section properties.
  Merge_sections_by_properties merge_sections_by_properties_;
  // Merge sections by section IDs.
  Merge_sections_by_id merge_sections_by_id_;
  // Relaxed sections by section IDs.
  Relaxed_input_sections_by_id relaxed_input_sections_by_id_;
};

// This abstract base class defines the interface for the
// types of methods used to fill free space left in an output
// section during an incremental link.  These methods are used
// to insert dummy compilation units into debug info so that
// debug info consumers can scan the debug info serially.

class Output_fill
{
 public:
  Output_fill()
    : is_big_endian_(parameters->target().is_big_endian())
  { }

  virtual
  ~Output_fill()
  { }

  // Return the smallest size chunk of free space that can be
  // filled with a dummy compilation unit.
  size_t
  minimum_hole_size() const
  { return this->do_minimum_hole_size(); }

  // Write a fill pattern of length LEN at offset OFF in the file.
  void
  write(Output_file* of, off_t off, size_t len) const
  { this->do_write(of, off, len); }

 protected:
  virtual size_t
  do_minimum_hole_size() const = 0;

  virtual void
  do_write(Output_file* of, off_t off, size_t len) const = 0;

  bool
  is_big_endian() const
  { return this->is_big_endian_; }

 private:
  bool is_big_endian_;
};

// Fill method that introduces a dummy compilation unit in
// a .debug_info or .debug_types section.

class Output_fill_debug_info : public Output_fill
{
 public:
  Output_fill_debug_info(bool is_debug_types)
    : is_debug_types_(is_debug_types)
  { }

 protected:
  virtual size_t
  do_minimum_hole_size() const;

  virtual void
  do_write(Output_file* of, off_t off, size_t len) const;

 private:
  // Version of the header.
  static const int version = 4;
  // True if this is a .debug_types section.
  bool is_debug_types_;
};

// Fill method that introduces a dummy compilation unit in
// a .debug_line section.

class Output_fill_debug_line : public Output_fill
{
 public:
  Output_fill_debug_line()
  { }

 protected:
  virtual size_t
  do_minimum_hole_size() const;

  virtual void
  do_write(Output_file* of, off_t off, size_t len) const;

 private:
  // Version of the header.  We write a DWARF-3 header because it's smaller
  // and many tools have not yet been updated to understand the DWARF-4 header.
  static const int version = 3;
  // Length of the portion of the header that follows the header_length
  // field.  This includes the following fields:
  // minimum_instruction_length, default_is_stmt, line_base, line_range,
  // opcode_base, standard_opcode_lengths[], include_directories, filenames.
  // The standard_opcode_lengths array is 12 bytes long, and the
  // include_directories and filenames fields each contain only a single
  // null byte.
  static const size_t header_length = 19;
};

// An output section.  We don't expect to have too many output
// sections, so we don't bother to do a template on the size.

class Output_section : public Output_data
{
 public:
  // Create an output section, giving the name, type, and flags.
  Output_section(const char* name, elfcpp::Elf_Word, elfcpp::Elf_Xword);
  virtual ~Output_section();

  // Add a new input section SHNDX, named NAME, with header SHDR, from
  // object OBJECT.  RELOC_SHNDX is the index of a relocation section
  // which applies to this section, or 0 if none, or -1 if more than
  // one.  HAVE_SECTIONS_SCRIPT is true if we have a SECTIONS clause
  // in a linker script; in that case we need to keep track of input
  // sections associated with an output section.  Return the offset
  // within the output section.
  template<int size, bool big_endian>
  off_t
  add_input_section(Layout* layout, Sized_relobj_file<size, big_endian>* object,
		    unsigned int shndx, const char* name,
		    const elfcpp::Shdr<size, big_endian>& shdr,
		    unsigned int reloc_shndx, bool have_sections_script);

  // Add generated data POSD to this output section.
  void
  add_output_section_data(Output_section_data* posd);

  // Add a relaxed input section PORIS called NAME to this output section
  // with LAYOUT.
  void
  add_relaxed_input_section(Layout* layout,
			    Output_relaxed_input_section* poris,
			    const std::string& name);

  // Return the section name.
  const char*
  name() const
  { return this->name_; }

  // Return the section type.
  elfcpp::Elf_Word
  type() const
  { return this->type_; }

  // Return the section flags.
  elfcpp::Elf_Xword
  flags() const
  { return this->flags_; }

  typedef std::map<Section_id, unsigned int> Section_layout_order;

  void
  update_section_layout(const Section_layout_order* order_map);

  // Update the output section flags based on input section flags.
  void
  update_flags_for_input_section(elfcpp::Elf_Xword flags);

  // Return the entsize field.
  uint64_t
  entsize() const
  { return this->entsize_; }

  // Set the entsize field.
  void
  set_entsize(uint64_t v);

  // Set the load address.
  void
  set_load_address(uint64_t load_address)
  {
    this->load_address_ = load_address;
    this->has_load_address_ = true;
  }

  // Set the link field to the output section index of a section.
  void
  set_link_section(const Output_data* od)
  {
    gold_assert(this->link_ == 0
		&& !this->should_link_to_symtab_
		&& !this->should_link_to_dynsym_);
    this->link_section_ = od;
  }

  // Set the link field to a constant.
  void
  set_link(unsigned int v)
  {
    gold_assert(this->link_section_ == NULL
		&& !this->should_link_to_symtab_
		&& !this->should_link_to_dynsym_);
    this->link_ = v;
  }

  // Record that this section should link to the normal symbol table.
  void
  set_should_link_to_symtab()
  {
    gold_assert(this->link_section_ == NULL
		&& this->link_ == 0
		&& !this->should_link_to_dynsym_);
    this->should_link_to_symtab_ = true;
  }

  // Record that this section should link to the dynamic symbol table.
  void
  set_should_link_to_dynsym()
  {
    gold_assert(this->link_section_ == NULL
		&& this->link_ == 0
		&& !this->should_link_to_symtab_);
    this->should_link_to_dynsym_ = true;
  }

  // Return the info field.
  unsigned int
  info() const
  {
    gold_assert(this->info_section_ == NULL
		&& this->info_symndx_ == NULL);
    return this->info_;
  }

  // Set the info field to the output section index of a section.
  void
  set_info_section(const Output_section* os)
  {
    gold_assert((this->info_section_ == NULL
		 || (this->info_section_ == os
		     && this->info_uses_section_index_))
		&& this->info_symndx_ == NULL
		&& this->info_ == 0);
    this->info_section_ = os;
    this->info_uses_section_index_= true;
  }

  // Set the info field to the symbol table index of a symbol.
  void
  set_info_symndx(const Symbol* sym)
  {
    gold_assert(this->info_section_ == NULL
		&& (this->info_symndx_ == NULL
		    || this->info_symndx_ == sym)
		&& this->info_ == 0);
    this->info_symndx_ = sym;
  }

  // Set the info field to the symbol table index of a section symbol.
  void
  set_info_section_symndx(const Output_section* os)
  {
    gold_assert((this->info_section_ == NULL
		 || (this->info_section_ == os
		     && !this->info_uses_section_index_))
		&& this->info_symndx_ == NULL
		&& this->info_ == 0);
    this->info_section_ = os;
    this->info_uses_section_index_ = false;
  }

  // Set the info field to a constant.
  void
  set_info(unsigned int v)
  {
    gold_assert(this->info_section_ == NULL
		&& this->info_symndx_ == NULL
		&& (this->info_ == 0
		    || this->info_ == v));
    this->info_ = v;
  }

  // Set the addralign field.
  void
  set_addralign(uint64_t v)
  { this->addralign_ = v; }

  void
  checkpoint_set_addralign(uint64_t val)
  {
    if (this->checkpoint_ != NULL)
      this->checkpoint_->set_addralign(val);
  }

  // Whether the output section index has been set.
  bool
  has_out_shndx() const
  { return this->out_shndx_ != -1U; }

  // Indicate that we need a symtab index.
  void
  set_needs_symtab_index()
  { this->needs_symtab_index_ = true; }

  // Return whether we need a symtab index.
  bool
  needs_symtab_index() const
  { return this->needs_symtab_index_; }

  // Get the symtab index.
  unsigned int
  symtab_index() const
  {
    gold_assert(this->symtab_index_ != 0);
    return this->symtab_index_;
  }

  // Set the symtab index.
  void
  set_symtab_index(unsigned int index)
  {
    gold_assert(index != 0);
    this->symtab_index_ = index;
  }

  // Indicate that we need a dynsym index.
  void
  set_needs_dynsym_index()
  { this->needs_dynsym_index_ = true; }

  // Return whether we need a dynsym index.
  bool
  needs_dynsym_index() const
  { return this->needs_dynsym_index_; }

  // Get the dynsym index.
  unsigned int
  dynsym_index() const
  {
    gold_assert(this->dynsym_index_ != 0);
    return this->dynsym_index_;
  }

  // Set the dynsym index.
  void
  set_dynsym_index(unsigned int index)
  {
    gold_assert(index != 0);
    this->dynsym_index_ = index;
  }

  // Sort the attached input sections.
  void
  sort_attached_input_sections();

  // Return whether the input sections sections attachd to this output
  // section may require sorting.  This is used to handle constructor
  // priorities compatibly with GNU ld.
  bool
  may_sort_attached_input_sections() const
  { return this->may_sort_attached_input_sections_; }

  // Record that the input sections attached to this output section
  // may require sorting.
  void
  set_may_sort_attached_input_sections()
  { this->may_sort_attached_input_sections_ = true; }

   // Returns true if input sections must be sorted according to the
  // order in which their name appear in the --section-ordering-file.
  bool
  input_section_order_specified()
  { return this->input_section_order_specified_; }

  // Record that input sections must be sorted as some of their names
  // match the patterns specified through --section-ordering-file.
  void
  set_input_section_order_specified()
  { this->input_section_order_specified_ = true; }

  // Return whether the input sections attached to this output section
  // require sorting.  This is used to handle constructor priorities
  // compatibly with GNU ld.
  bool
  must_sort_attached_input_sections() const
  { return this->must_sort_attached_input_sections_; }

  // Record that the input sections attached to this output section
  // require sorting.
  void
  set_must_sort_attached_input_sections()
  { this->must_sort_attached_input_sections_ = true; }

  // Get the order in which this section appears in the PT_LOAD output
  // segment.
  Output_section_order
  order() const
  { return this->order_; }

  // Set the order for this section.
  void
  set_order(Output_section_order order)
  { this->order_ = order; }

  // Return whether this section holds relro data--data which has
  // dynamic relocations but which may be marked read-only after the
  // dynamic relocations have been completed.
  bool
  is_relro() const
  { return this->is_relro_; }

  // Record that this section holds relro data.
  void
  set_is_relro()
  { this->is_relro_ = true; }

  // Record that this section does not hold relro data.
  void
  clear_is_relro()
  { this->is_relro_ = false; }

  // True if this is a small section: a section which holds small
  // variables.
  bool
  is_small_section() const
  { return this->is_small_section_; }

  // Record that this is a small section.
  void
  set_is_small_section()
  { this->is_small_section_ = true; }

  // True if this is a large section: a section which holds large
  // variables.
  bool
  is_large_section() const
  { return this->is_large_section_; }

  // Record that this is a large section.
  void
  set_is_large_section()
  { this->is_large_section_ = true; }

  // True if this is a large data (not BSS) section.
  bool
  is_large_data_section()
  { return this->is_large_section_ && this->type_ != elfcpp::SHT_NOBITS; }

  // Return whether this section should be written after all the input
  // sections are complete.
  bool
  after_input_sections() const
  { return this->after_input_sections_; }

  // Record that this section should be written after all the input
  // sections are complete.
  void
  set_after_input_sections()
  { this->after_input_sections_ = true; }

  // Return whether this section requires postprocessing after all
  // relocations have been applied.
  bool
  requires_postprocessing() const
  { return this->requires_postprocessing_; }

  bool
  is_unique_segment() const
  { return this->is_unique_segment_; }

  void
  set_is_unique_segment()
  { this->is_unique_segment_ = true; }

  uint64_t extra_segment_flags() const
  { return this->extra_segment_flags_; }

  void
  set_extra_segment_flags(uint64_t flags)
  { this->extra_segment_flags_ = flags; }

  uint64_t segment_alignment() const
  { return this->segment_alignment_; }

  void
  set_segment_alignment(uint64_t align)
  { this->segment_alignment_ = align; }

  // If a section requires postprocessing, return the buffer to use.
  unsigned char*
  postprocessing_buffer() const
  {
    gold_assert(this->postprocessing_buffer_ != NULL);
    return this->postprocessing_buffer_;
  }

  // If a section requires postprocessing, create the buffer to use.
  void
  create_postprocessing_buffer();

  // If a section requires postprocessing, this is the size of the
  // buffer to which relocations should be applied.
  off_t
  postprocessing_buffer_size() const
  { return this->current_data_size_for_child(); }

  // Modify the section name.  This is only permitted for an
  // unallocated section, and only before the size has been finalized.
  // Otherwise the name will not get into Layout::namepool_.
  void
  set_name(const char* newname)
  {
    gold_assert((this->flags_ & elfcpp::SHF_ALLOC) == 0);
    gold_assert(!this->is_data_size_valid());
    this->name_ = newname;
  }

  // Return whether the offset OFFSET in the input section SHNDX in
  // object OBJECT is being included in the link.
  bool
  is_input_address_mapped(const Relobj* object, unsigned int shndx,
			  off_t offset) const;

  // Return the offset within the output section of OFFSET relative to
  // the start of input section SHNDX in object OBJECT.
  section_offset_type
  output_offset(const Relobj* object, unsigned int shndx,
		section_offset_type offset) const;

  // Return the output virtual address of OFFSET relative to the start
  // of input section SHNDX in object OBJECT.
  uint64_t
  output_address(const Relobj* object, unsigned int shndx,
		 off_t offset) const;

  // Look for the merged section for input section SHNDX in object
  // OBJECT.  If found, return true, and set *ADDR to the address of
  // the start of the merged section.  This is not necessary the
  // output offset corresponding to input offset 0 in the section,
  // since the section may be mapped arbitrarily.
  bool
  find_starting_output_address(const Relobj* object, unsigned int shndx,
			       uint64_t* addr) const;

  // Record that this output section was found in the SECTIONS clause
  // of a linker script.
  void
  set_found_in_sections_clause()
  { this->found_in_sections_clause_ = true; }

  // Return whether this output section was found in the SECTIONS
  // clause of a linker script.
  bool
  found_in_sections_clause() const
  { return this->found_in_sections_clause_; }

  // Write the section header into *OPHDR.
  template<int size, bool big_endian>
  void
  write_header(const Layout*, const Stringpool*,
	       elfcpp::Shdr_write<size, big_endian>*) const;

  // The next few calls are for linker script support.

  // In some cases we need to keep a list of the input sections
  // associated with this output section.  We only need the list if we
  // might have to change the offsets of the input section within the
  // output section after we add the input section.  The ordinary
  // input sections will be written out when we process the object
  // file, and as such we don't need to track them here.  We do need
  // to track Output_section_data objects here.  We store instances of
  // this structure in a std::vector, so it must be a POD.  There can
  // be many instances of this structure, so we use a union to save
  // some space.
  class Input_section
  {
   public:
    Input_section()
      : shndx_(0), p2align_(0)
    {
      this->u1_.data_size = 0;
      this->u2_.object = NULL;
    }

    // For an ordinary input section.
    Input_section(Relobj* object, unsigned int shndx, off_t data_size,
		  uint64_t addralign)
      : shndx_(shndx),
	p2align_(ffsll(static_cast<long long>(addralign))),
	section_order_index_(0)
    {
      gold_assert(shndx != OUTPUT_SECTION_CODE
		  && shndx != MERGE_DATA_SECTION_CODE
		  && shndx != MERGE_STRING_SECTION_CODE
		  && shndx != RELAXED_INPUT_SECTION_CODE);
      this->u1_.data_size = data_size;
      this->u2_.object = object;
    }

    // For a non-merge output section.
    Input_section(Output_section_data* posd)
      : shndx_(OUTPUT_SECTION_CODE), p2align_(0),
	section_order_index_(0)
    {
      this->u1_.data_size = 0;
      this->u2_.posd = posd;
    }

    // For a merge section.
    Input_section(Output_section_data* posd, bool is_string, uint64_t entsize)
      : shndx_(is_string
	       ? MERGE_STRING_SECTION_CODE
	       : MERGE_DATA_SECTION_CODE),
	p2align_(0),
	section_order_index_(0)
    {
      this->u1_.entsize = entsize;
      this->u2_.posd = posd;
    }

    // For a relaxed input section.
    Input_section(Output_relaxed_input_section* psection)
      : shndx_(RELAXED_INPUT_SECTION_CODE), p2align_(0),
	section_order_index_(0)
    {
      this->u1_.data_size = 0;
      this->u2_.poris = psection;
    }

    unsigned int
    section_order_index() const
    {
      return this->section_order_index_;
    }

    void
    set_section_order_index(unsigned int number)
    {
      this->section_order_index_ = number;
    }

    // The required alignment.
    uint64_t
    addralign() const
    {
      if (this->p2align_ != 0)
	return static_cast<uint64_t>(1) << (this->p2align_ - 1);
      else if (!this->is_input_section())
	return this->u2_.posd->addralign();
      else
	return 0;
    }

    // Set the required alignment, which must be either 0 or a power of 2.
    // For input sections that are sub-classes of Output_section_data, a
    // alignment of zero means asking the underlying object for alignment.
    void
    set_addralign(uint64_t addralign)
    {
      if (addralign == 0)
	this->p2align_ = 0;
      else
	{
	  gold_assert((addralign & (addralign - 1)) == 0);
	  this->p2align_ = ffsll(static_cast<long long>(addralign));
	}
    }

    // Return the current required size, without finalization.
    off_t
    current_data_size() const;

    // Return the required size.
    off_t
    data_size() const;

    // Whether this is an input section.
    bool
    is_input_section() const
    {
      return (this->shndx_ != OUTPUT_SECTION_CODE
	      && this->shndx_ != MERGE_DATA_SECTION_CODE
	      && this->shndx_ != MERGE_STRING_SECTION_CODE
	      && this->shndx_ != RELAXED_INPUT_SECTION_CODE);
    }

    // Return whether this is a merge section which matches the
    // parameters.
    bool
    is_merge_section(bool is_string, uint64_t entsize,
		     uint64_t addralign) const
    {
      return (this->shndx_ == (is_string
			       ? MERGE_STRING_SECTION_CODE
			       : MERGE_DATA_SECTION_CODE)
	      && this->u1_.entsize == entsize
	      && this->addralign() == addralign);
    }

    // Return whether this is a merge section for some input section.
    bool
    is_merge_section() const
    {
      return (this->shndx_ == MERGE_DATA_SECTION_CODE
	      || this->shndx_ == MERGE_STRING_SECTION_CODE);
    }

    // Return whether this is a relaxed input section.
    bool
    is_relaxed_input_section() const
    { return this->shndx_ == RELAXED_INPUT_SECTION_CODE; }

    // Return whether this is a generic Output_section_data.
    bool
    is_output_section_data() const
    {
      return this->shndx_ == OUTPUT_SECTION_CODE;
    }

    // Return the object for an input section.
    Relobj*
    relobj() const;

    // Return the input section index for an input section.
    unsigned int
    shndx() const;

    // For non-input-sections, return the associated Output_section_data
    // object.
    Output_section_data*
    output_section_data() const
    {
      gold_assert(!this->is_input_section());
      return this->u2_.posd;
    }

    // For a merge section, return the Output_merge_base pointer.
    Output_merge_base*
    output_merge_base() const
    {
      gold_assert(this->is_merge_section());
      return this->u2_.pomb;
    }

    // Return the Output_relaxed_input_section object.
    Output_relaxed_input_section*
    relaxed_input_section() const
    {
      gold_assert(this->is_relaxed_input_section());
      return this->u2_.poris;
    }

    // Set the output section.
    void
    set_output_section(Output_section* os)
    {
      gold_assert(!this->is_input_section());
      Output_section_data* posd =
	this->is_relaxed_input_section() ? this->u2_.poris : this->u2_.posd;
      posd->set_output_section(os);
    }

    // Set the address and file offset.  This is called during
    // Layout::finalize.  SECTION_FILE_OFFSET is the file offset of
    // the enclosing section.
    void
    set_address_and_file_offset(uint64_t address, off_t file_offset,
				off_t section_file_offset);

    // Reset the address and file offset.
    void
    reset_address_and_file_offset();

    // Finalize the data size.
    void
    finalize_data_size();

    // Add an input section, for SHF_MERGE sections.
    bool
    add_input_section(Relobj* object, unsigned int shndx)
    {
      gold_assert(this->shndx_ == MERGE_DATA_SECTION_CODE
		  || this->shndx_ == MERGE_STRING_SECTION_CODE);
      return this->u2_.posd->add_input_section(object, shndx);
    }

    // Given an input OBJECT, an input section index SHNDX within that
    // object, and an OFFSET relative to the start of that input
    // section, return whether or not the output offset is known.  If
    // this function returns true, it sets *POUTPUT to the offset in
    // the output section, relative to the start of the input section
    // in the output section.  *POUTPUT may be different from OFFSET
    // for a merged section.
    bool
    output_offset(const Relobj* object, unsigned int shndx,
		  section_offset_type offset,
		  section_offset_type* poutput) const;

    // Return whether this is the merge section for the input section
    // SHNDX in OBJECT.
    bool
    is_merge_section_for(const Relobj* object, unsigned int shndx) const;

    // Write out the data.  This does nothing for an input section.
    void
    write(Output_file*);

    // Write the data to a buffer.  This does nothing for an input
    // section.
    void
    write_to_buffer(unsigned char*);

    // Print to a map file.
    void
    print_to_mapfile(Mapfile*) const;

    // Print statistics about merge sections to stderr.
    void
    print_merge_stats(const char* section_name)
    {
      if (this->shndx_ == MERGE_DATA_SECTION_CODE
	  || this->shndx_ == MERGE_STRING_SECTION_CODE)
	this->u2_.posd->print_merge_stats(section_name);
    }

   private:
    // Code values which appear in shndx_.  If the value is not one of
    // these codes, it is the input section index in the object file.
    enum
    {
      // An Output_section_data.
      OUTPUT_SECTION_CODE = -1U,
      // An Output_section_data for an SHF_MERGE section with
      // SHF_STRINGS not set.
      MERGE_DATA_SECTION_CODE = -2U,
      // An Output_section_data for an SHF_MERGE section with
      // SHF_STRINGS set.
      MERGE_STRING_SECTION_CODE = -3U,
      // An Output_section_data for a relaxed input section.
      RELAXED_INPUT_SECTION_CODE = -4U
    };

    // For an ordinary input section, this is the section index in the
    // input file.  For an Output_section_data, this is
    // OUTPUT_SECTION_CODE or MERGE_DATA_SECTION_CODE or
    // MERGE_STRING_SECTION_CODE.
    unsigned int shndx_;
    // The required alignment, stored as a power of 2.
    unsigned int p2align_;
    union
    {
      // For an ordinary input section, the section size.
      off_t data_size;
      // For OUTPUT_SECTION_CODE or RELAXED_INPUT_SECTION_CODE, this is not
      // used.  For MERGE_DATA_SECTION_CODE or MERGE_STRING_SECTION_CODE, the
      // entity size.
      uint64_t entsize;
    } u1_;
    union
    {
      // For an ordinary input section, the object which holds the
      // input section.
      Relobj* object;
      // For OUTPUT_SECTION_CODE or MERGE_DATA_SECTION_CODE or
      // MERGE_STRING_SECTION_CODE, the data.
      Output_section_data* posd;
      Output_merge_base* pomb;
      // For RELAXED_INPUT_SECTION_CODE, the data.
      Output_relaxed_input_section* poris;
    } u2_;
    // The line number of the pattern it matches in the --section-ordering-file
    // file.  It is 0 if does not match any pattern.
    unsigned int section_order_index_;
  };

  // Store the list of input sections for this Output_section into the
  // list passed in.  This removes the input sections, leaving only
  // any Output_section_data elements.  This returns the size of those
  // Output_section_data elements.  ADDRESS is the address of this
  // output section.  FILL is the fill value to use, in case there are
  // any spaces between the remaining Output_section_data elements.
  uint64_t
  get_input_sections(uint64_t address, const std::string& fill,
		     std::list<Input_section>*);

  // Add a script input section.  A script input section can either be
  // a plain input section or a sub-class of Output_section_data.
  void
  add_script_input_section(const Input_section& input_section);

  // Set the current size of the output section.
  void
  set_current_data_size(off_t size)
  { this->set_current_data_size_for_child(size); }

  // End of linker script support.

  // Save states before doing section layout.
  // This is used for relaxation.
  void
  save_states();

  // Restore states prior to section layout.
  void
  restore_states();

  // Discard states.
  void
  discard_states();

  // Convert existing input sections to relaxed input sections.
  void
  convert_input_sections_to_relaxed_sections(
      const std::vector<Output_relaxed_input_section*>& sections);

  // Find a relaxed input section to an input section in OBJECT
  // with index SHNDX.  Return NULL if none is found.
  const Output_relaxed_input_section*
  find_relaxed_input_section(const Relobj* object, unsigned int shndx) const;

  // Whether section offsets need adjustment due to relaxation.
  bool
  section_offsets_need_adjustment() const
  { return this->section_offsets_need_adjustment_; }

  // Set section_offsets_need_adjustment to be true.
  void
  set_section_offsets_need_adjustment()
  { this->section_offsets_need_adjustment_ = true; }

  // Set section_offsets_need_adjustment to be false.
  void
  clear_section_offsets_need_adjustment()
  { this->section_offsets_need_adjustment_ = false; }

  // Adjust section offsets of input sections in this.  This is
  // requires if relaxation caused some input sections to change sizes.
  void
  adjust_section_offsets();

  // Whether this is a NOLOAD section.
  bool
  is_noload() const
  { return this->is_noload_; }

  // Set NOLOAD flag.
  void
  set_is_noload()
  { this->is_noload_ = true; }

  // Print merge statistics to stderr.
  void
  print_merge_stats();

  // Set a fixed layout for the section.  Used for incremental update links.
  void
  set_fixed_layout(uint64_t sh_addr, off_t sh_offset, off_t sh_size,
		   uint64_t sh_addralign);

  // Return TRUE if the section has a fixed layout.
  bool
  has_fixed_layout() const
  { return this->has_fixed_layout_; }

  // Set flag to allow patch space for this section.  Used for full
  // incremental links.
  void
  set_is_patch_space_allowed()
  { this->is_patch_space_allowed_ = true; }

  // Set a fill method to use for free space left in the output section
  // during incremental links.
  void
  set_free_space_fill(Output_fill* free_space_fill)
  {
    this->free_space_fill_ = free_space_fill;
    this->free_list_.set_min_hole_size(free_space_fill->minimum_hole_size());
  }

  // Reserve space within the fixed layout for the section.  Used for
  // incremental update links.
  void
  reserve(uint64_t sh_offset, uint64_t sh_size);

  // Allocate space from the free list for the section.  Used for
  // incremental update links.
  off_t
  allocate(off_t len, uint64_t addralign);

  typedef std::vector<Input_section> Input_section_list;

  // Allow access to the input sections.
  const Input_section_list&
  input_sections() const
  { return this->input_sections_; }

  Input_section_list&
  input_sections()
  { return this->input_sections_; }

 protected:
  // Return the output section--i.e., the object itself.
  Output_section*
  do_output_section()
  { return this; }

  const Output_section*
  do_output_section() const
  { return this; }

  // Return the section index in the output file.
  unsigned int
  do_out_shndx() const
  {
    gold_assert(this->out_shndx_ != -1U);
    return this->out_shndx_;
  }

  // Set the output section index.
  void
  do_set_out_shndx(unsigned int shndx)
  {
    gold_assert(this->out_shndx_ == -1U || this->out_shndx_ == shndx);
    this->out_shndx_ = shndx;
  }

  // Update the data size of the Output_section.  For a typical
  // Output_section, there is nothing to do, but if there are any
  // Output_section_data objects we need to do a trial layout
  // here.
  virtual void
  update_data_size();

  // Set the final data size of the Output_section.  For a typical
  // Output_section, there is nothing to do, but if there are any
  // Output_section_data objects we need to set their final addresses
  // here.
  virtual void
  set_final_data_size();

  // Reset the address and file offset.
  void
  do_reset_address_and_file_offset();

  // Return true if address and file offset already have reset values. In
  // other words, calling reset_address_and_file_offset will not change them.
  bool
  do_address_and_file_offset_have_reset_values() const;

  // Write the data to the file.  For a typical Output_section, this
  // does nothing: the data is written out by calling Object::Relocate
  // on each input object.  But if there are any Output_section_data
  // objects we do need to write them out here.
  virtual void
  do_write(Output_file*);

  // Return the address alignment--function required by parent class.
  uint64_t
  do_addralign() const
  { return this->addralign_; }

  // Return whether there is a load address.
  bool
  do_has_load_address() const
  { return this->has_load_address_; }

  // Return the load address.
  uint64_t
  do_load_address() const
  {
    gold_assert(this->has_load_address_);
    return this->load_address_;
  }

  // Return whether this is an Output_section.
  bool
  do_is_section() const
  { return true; }

  // Return whether this is a section of the specified type.
  bool
  do_is_section_type(elfcpp::Elf_Word type) const
  { return this->type_ == type; }

  // Return whether the specified section flag is set.
  bool
  do_is_section_flag_set(elfcpp::Elf_Xword flag) const
  { return (this->flags_ & flag) != 0; }

  // Set the TLS offset.  Called only for SHT_TLS sections.
  void
  do_set_tls_offset(uint64_t tls_base);

  // Return the TLS offset, relative to the base of the TLS segment.
  // Valid only for SHT_TLS sections.
  uint64_t
  do_tls_offset() const
  { return this->tls_offset_; }

  // This may be implemented by a child class.
  virtual void
  do_finalize_name(Layout*)
  { }

  // Print to the map file.
  virtual void
  do_print_to_mapfile(Mapfile*) const;

  // Record that this section requires postprocessing after all
  // relocations have been applied.  This is called by a child class.
  void
  set_requires_postprocessing()
  {
    this->requires_postprocessing_ = true;
    this->after_input_sections_ = true;
  }

  // Write all the data of an Output_section into the postprocessing
  // buffer.
  void
  write_to_postprocessing_buffer();

  // Whether this always keeps an input section list
  bool
  always_keeps_input_sections() const
  { return this->always_keeps_input_sections_; }

  // Always keep an input section list.
  void
  set_always_keeps_input_sections()
  {
    gold_assert(this->current_data_size_for_child() == 0);
    this->always_keeps_input_sections_ = true;
  }

 private:
  // We only save enough information to undo the effects of section layout.
  class Checkpoint_output_section
  {
   public:
    Checkpoint_output_section(uint64_t addralign, elfcpp::Elf_Xword flags,
			      const Input_section_list& input_sections,
			      off_t first_input_offset,
			      bool attached_input_sections_are_sorted)
      : addralign_(addralign), flags_(flags),
	input_sections_(input_sections),
	input_sections_size_(input_sections_.size()),
	input_sections_copy_(), first_input_offset_(first_input_offset),
	attached_input_sections_are_sorted_(attached_input_sections_are_sorted)
    { }

    virtual
    ~Checkpoint_output_section()
    { }

    // Return the address alignment.
    uint64_t
    addralign() const
    { return this->addralign_; }

    void
    set_addralign(uint64_t val)
    { this->addralign_ = val; }

    // Return the section flags.
    elfcpp::Elf_Xword
    flags() const
    { return this->flags_; }

    // Return a reference to the input section list copy.
    Input_section_list*
    input_sections()
    { return &this->input_sections_copy_; }

    // Return the size of input_sections at the time when checkpoint is
    // taken.
    size_t
    input_sections_size() const
    { return this->input_sections_size_; }

    // Whether input sections are copied.
    bool
    input_sections_saved() const
    { return this->input_sections_copy_.size() == this->input_sections_size_; }

    off_t
    first_input_offset() const
    { return this->first_input_offset_; }

    bool
    attached_input_sections_are_sorted() const
    { return this->attached_input_sections_are_sorted_; }

    // Save input sections.
    void
    save_input_sections()
    {
      this->input_sections_copy_.reserve(this->input_sections_size_);
      this->input_sections_copy_.clear();
      Input_section_list::const_iterator p = this->input_sections_.begin();
      gold_assert(this->input_sections_size_ >= this->input_sections_.size());
      for(size_t i = 0; i < this->input_sections_size_ ; i++, ++p)
	this->input_sections_copy_.push_back(*p);
    }

   private:
    // The section alignment.
    uint64_t addralign_;
    // The section flags.
    elfcpp::Elf_Xword flags_;
    // Reference to the input sections to be checkpointed.
    const Input_section_list& input_sections_;
    // Size of the checkpointed portion of input_sections_;
    size_t input_sections_size_;
    // Copy of input sections.
    Input_section_list input_sections_copy_;
    // The offset of the first entry in input_sections_.
    off_t first_input_offset_;
    // True if the input sections attached to this output section have
    // already been sorted.
    bool attached_input_sections_are_sorted_;
  };

  // This class is used to sort the input sections.
  class Input_section_sort_entry;

  // This is the sort comparison function for ctors and dtors.
  struct Input_section_sort_compare
  {
    bool
    operator()(const Input_section_sort_entry&,
	       const Input_section_sort_entry&) const;
  };

  // This is the sort comparison function for .init_array and .fini_array.
  struct Input_section_sort_init_fini_compare
  {
    bool
    operator()(const Input_section_sort_entry&,
	       const Input_section_sort_entry&) const;
  };

  // This is the sort comparison function when a section order is specified
  // from an input file.
  struct Input_section_sort_section_order_index_compare
  {
    bool
    operator()(const Input_section_sort_entry&,
	       const Input_section_sort_entry&) const;
  };

  // This is the sort comparison function for .text to sort sections with
  // prefixes .text.{unlikely,exit,startup,hot} before other sections.
  struct Input_section_sort_section_prefix_special_ordering_compare
  {
    bool
    operator()(const Input_section_sort_entry&,
	       const Input_section_sort_entry&) const;
  };

  // This is the sort comparison function for sorting sections by name.
  struct Input_section_sort_section_name_compare
  {
    bool
    operator()(const Input_section_sort_entry&,
	       const Input_section_sort_entry&) const;
  };

  // Fill data.  This is used to fill in data between input sections.
  // It is also used for data statements (BYTE, WORD, etc.) in linker
  // scripts.  When we have to keep track of the input sections, we
  // can use an Output_data_const, but we don't want to have to keep
  // track of input sections just to implement fills.
  class Fill
  {
   public:
    Fill(off_t section_offset, off_t length)
      : section_offset_(section_offset),
	length_(convert_to_section_size_type(length))
    { }

    // Return section offset.
    off_t
    section_offset() const
    { return this->section_offset_; }

    // Return fill length.
    section_size_type
    length() const
    { return this->length_; }

   private:
    // The offset within the output section.
    off_t section_offset_;
    // The length of the space to fill.
    section_size_type length_;
  };

  typedef std::vector<Fill> Fill_list;

  // Map used during relaxation of existing sections.  This map
  // a section id an input section list index.  We assume that
  // Input_section_list is a vector.
  typedef Unordered_map<Section_id, size_t, Section_id_hash> Relaxation_map;

  // Add a new output section by Input_section.
  void
  add_output_section_data(Input_section*);

  // Add an SHF_MERGE input section.  Returns true if the section was
  // handled.  If KEEPS_INPUT_SECTIONS is true, the output merge section
  // stores information about the merged input sections.
  bool
  add_merge_input_section(Relobj* object, unsigned int shndx, uint64_t flags,
			  uint64_t entsize, uint64_t addralign,
			  bool keeps_input_sections);

  // Add an output SHF_MERGE section POSD to this output section.
  // IS_STRING indicates whether it is a SHF_STRINGS section, and
  // ENTSIZE is the entity size.  This returns the entry added to
  // input_sections_.
  void
  add_output_merge_section(Output_section_data* posd, bool is_string,
			   uint64_t entsize);

  // Find the merge section into which an input section with index SHNDX in
  // OBJECT has been added.  Return NULL if none found.
  Output_section_data*
  find_merge_section(const Relobj* object, unsigned int shndx) const;

  // Build a relaxation map.
  void
  build_relaxation_map(
      const Input_section_list& input_sections,
      size_t limit,
      Relaxation_map* map) const;

  // Convert input sections in an input section list into relaxed sections.
  void
  convert_input_sections_in_list_to_relaxed_sections(
      const std::vector<Output_relaxed_input_section*>& relaxed_sections,
      const Relaxation_map& map,
      Input_section_list* input_sections);

  // Build the lookup maps for merge and relaxed input sections.
  void
  build_lookup_maps() const;

  // Most of these fields are only valid after layout.

  // The name of the section.  This will point into a Stringpool.
  const char* name_;
  // The section address is in the parent class.
  // The section alignment.
  uint64_t addralign_;
  // The section entry size.
  uint64_t entsize_;
  // The load address.  This is only used when using a linker script
  // with a SECTIONS clause.  The has_load_address_ field indicates
  // whether this field is valid.
  uint64_t load_address_;
  // The file offset is in the parent class.
  // Set the section link field to the index of this section.
  const Output_data* link_section_;
  // If link_section_ is NULL, this is the link field.
  unsigned int link_;
  // Set the section info field to the index of this section.
  const Output_section* info_section_;
  // If info_section_ is NULL, set the info field to the symbol table
  // index of this symbol.
  const Symbol* info_symndx_;
  // If info_section_ and info_symndx_ are NULL, this is the section
  // info field.
  unsigned int info_;
  // The section type.
  const elfcpp::Elf_Word type_;
  // The section flags.
  elfcpp::Elf_Xword flags_;
  // The order of this section in the output segment.
  Output_section_order order_;
  // The section index.
  unsigned int out_shndx_;
  // If there is a STT_SECTION for this output section in the normal
  // symbol table, this is the symbol index.  This starts out as zero.
  // It is initialized in Layout::finalize() to be the index, or -1U
  // if there isn't one.
  unsigned int symtab_index_;
  // If there is a STT_SECTION for this output section in the dynamic
  // symbol table, this is the symbol index.  This starts out as zero.
  // It is initialized in Layout::finalize() to be the index, or -1U
  // if there isn't one.
  unsigned int dynsym_index_;
  // The input sections.  This will be empty in cases where we don't
  // need to keep track of them.
  Input_section_list input_sections_;
  // The offset of the first entry in input_sections_.
  off_t first_input_offset_;
  // The fill data.  This is separate from input_sections_ because we
  // often will need fill sections without needing to keep track of
  // input sections.
  Fill_list fills_;
  // If the section requires postprocessing, this buffer holds the
  // section contents during relocation.
  unsigned char* postprocessing_buffer_;
  // Whether this output section needs a STT_SECTION symbol in the
  // normal symbol table.  This will be true if there is a relocation
  // which needs it.
  bool needs_symtab_index_ : 1;
  // Whether this output section needs a STT_SECTION symbol in the
  // dynamic symbol table.  This will be true if there is a dynamic
  // relocation which needs it.
  bool needs_dynsym_index_ : 1;
  // Whether the link field of this output section should point to the
  // normal symbol table.
  bool should_link_to_symtab_ : 1;
  // Whether the link field of this output section should point to the
  // dynamic symbol table.
  bool should_link_to_dynsym_ : 1;
  // Whether this section should be written after all the input
  // sections are complete.
  bool after_input_sections_ : 1;
  // Whether this section requires post processing after all
  // relocations have been applied.
  bool requires_postprocessing_ : 1;
  // Whether an input section was mapped to this output section
  // because of a SECTIONS clause in a linker script.
  bool found_in_sections_clause_ : 1;
  // Whether this section has an explicitly specified load address.
  bool has_load_address_ : 1;
  // True if the info_section_ field means the section index of the
  // section, false if it means the symbol index of the corresponding
  // section symbol.
  bool info_uses_section_index_ : 1;
  // True if input sections attached to this output section have to be
  // sorted according to a specified order.
  bool input_section_order_specified_ : 1;
  // True if the input sections attached to this output section may
  // need sorting.
  bool may_sort_attached_input_sections_ : 1;
  // True if the input sections attached to this output section must
  // be sorted.
  bool must_sort_attached_input_sections_ : 1;
  // True if the input sections attached to this output section have
  // already been sorted.
  bool attached_input_sections_are_sorted_ : 1;
  // True if this section holds relro data.
  bool is_relro_ : 1;
  // True if this is a small section.
  bool is_small_section_ : 1;
  // True if this is a large section.
  bool is_large_section_ : 1;
  // Whether code-fills are generated at write.
  bool generate_code_fills_at_write_ : 1;
  // Whether the entry size field should be zero.
  bool is_entsize_zero_ : 1;
  // Whether section offsets need adjustment due to relaxation.
  bool section_offsets_need_adjustment_ : 1;
  // Whether this is a NOLOAD section.
  bool is_noload_ : 1;
  // Whether this always keeps input section.
  bool always_keeps_input_sections_ : 1;
  // Whether this section has a fixed layout, for incremental update links.
  bool has_fixed_layout_ : 1;
  // True if we can add patch space to this section.
  bool is_patch_space_allowed_ : 1;
  // True if this output section goes into a unique segment.
  bool is_unique_segment_ : 1;
  // For SHT_TLS sections, the offset of this section relative to the base
  // of the TLS segment.
  uint64_t tls_offset_;
  // Additional segment flags, specified via linker plugin, when mapping some
  // input sections to unique segments.
  uint64_t extra_segment_flags_;
  // Segment alignment specified via linker plugin, when mapping some
  // input sections to unique segments.
  uint64_t segment_alignment_;
  // Saved checkpoint.
  Checkpoint_output_section* checkpoint_;
  // Fast lookup maps for merged and relaxed input sections.
  Output_section_lookup_maps* lookup_maps_;
  // List of available regions within the section, for incremental
  // update links.
  Free_list free_list_;
  // Method for filling chunks of free space.
  Output_fill* free_space_fill_;
  // Amount added as patch space for incremental linking.
  off_t patch_space_;
};

// An output segment.  PT_LOAD segments are built from collections of
// output sections.  Other segments typically point within PT_LOAD
// segments, and are built directly as needed.
//
// NOTE: We want to use the copy constructor for this class.  During
// relaxation, we may try built the segments multiple times.  We do
// that by copying the original segment list before lay-out, doing
// a trial lay-out and roll-back to the saved copied if we need to
// to the lay-out again.

class Output_segment
{
 public:
  // Create an output segment, specifying the type and flags.
  Output_segment(elfcpp::Elf_Word, elfcpp::Elf_Word);

  // Return the virtual address.
  uint64_t
  vaddr() const
  { return this->vaddr_; }

  // Return the physical address.
  uint64_t
  paddr() const
  { return this->paddr_; }

  // Return the segment type.
  elfcpp::Elf_Word
  type() const
  { return this->type_; }

  // Return the segment flags.
  elfcpp::Elf_Word
  flags() const
  { return this->flags_; }

  // Return the memory size.
  uint64_t
  memsz() const
  { return this->memsz_; }

  // Return the file size.
  off_t
  filesz() const
  { return this->filesz_; }

  // Return the file offset.
  off_t
  offset() const
  { return this->offset_; }

  // Whether this is a segment created to hold large data sections.
  bool
  is_large_data_segment() const
  { return this->is_large_data_segment_; }

  // Record that this is a segment created to hold large data
  // sections.
  void
  set_is_large_data_segment()
  { this->is_large_data_segment_ = true; }

  bool
  is_unique_segment() const
  { return this->is_unique_segment_; }

  // Mark segment as unique, happens when linker plugins request that
  // certain input sections be mapped to unique segments.
  void
  set_is_unique_segment()
  { this->is_unique_segment_ = true; }

  // Return the maximum alignment of the Output_data.
  uint64_t
  maximum_alignment();

  // Add the Output_section OS to this PT_LOAD segment.  SEG_FLAGS is
  // the segment flags to use.
  void
  add_output_section_to_load(Layout* layout, Output_section* os,
			     elfcpp::Elf_Word seg_flags);

  // Add the Output_section OS to this non-PT_LOAD segment.  SEG_FLAGS
  // is the segment flags to use.
  void
  add_output_section_to_nonload(Output_section* os,
				elfcpp::Elf_Word seg_flags);

  // Remove an Output_section from this segment.  It is an error if it
  // is not present.
  void
  remove_output_section(Output_section* os);

  // Add an Output_data (which need not be an Output_section) to the
  // start of this segment.
  void
  add_initial_output_data(Output_data*);

  // Return true if this segment has any sections which hold actual
  // data, rather than being a BSS section.
  bool
  has_any_data_sections() const;

  // Whether this segment has a dynamic relocs.
  bool
  has_dynamic_reloc() const;

  // Return the first section.
  Output_section*
  first_section() const;

  // Return the address of the first section.
  uint64_t
  first_section_load_address() const
  {
    const Output_section* os = this->first_section();
    return os->has_load_address() ? os->load_address() : os->address();
  }

  // Return whether the addresses have been set already.
  bool
  are_addresses_set() const
  { return this->are_addresses_set_; }

  // Set the addresses.
  void
  set_addresses(uint64_t vaddr, uint64_t paddr)
  {
    this->vaddr_ = vaddr;
    this->paddr_ = paddr;
    this->are_addresses_set_ = true;
  }

  // Update the flags for the flags of an output section added to this
  // segment.
  void
  update_flags_for_output_section(elfcpp::Elf_Xword flags)
  {
    // The ELF ABI specifies that a PT_TLS segment should always have
    // PF_R as the flags.
    if (this->type() != elfcpp::PT_TLS)
      this->flags_ |= flags;
  }

  // Set the segment flags.  This is only used if we have a PHDRS
  // clause which explicitly specifies the flags.
  void
  set_flags(elfcpp::Elf_Word flags)
  { this->flags_ = flags; }

  // Set the address of the segment to ADDR and the offset to *POFF
  // and set the addresses and offsets of all contained output
  // sections accordingly.  Set the section indexes of all contained
  // output sections starting with *PSHNDX.  If RESET is true, first
  // reset the addresses of the contained sections.  Return the
  // address of the immediately following segment.  Update *POFF and
  // *PSHNDX.  This should only be called for a PT_LOAD segment.
  uint64_t
  set_section_addresses(const Target*, Layout*, bool reset, uint64_t addr,
			unsigned int* increase_relro, bool* has_relro,
			off_t* poff, unsigned int* pshndx);

  // Set the minimum alignment of this segment.  This may be adjusted
  // upward based on the section alignments.
  void
  set_minimum_p_align(uint64_t align)
  {
    if (align > this->min_p_align_)
      this->min_p_align_ = align;
  }

  // Set the offset of this segment based on the section.  This should
  // only be called for a non-PT_LOAD segment.
  void
  set_offset(unsigned int increase);

  // Set the TLS offsets of the sections contained in the PT_TLS segment.
  void
  set_tls_offsets();

  // Return the number of output sections.
  unsigned int
  output_section_count() const;

  // Return the section attached to the list segment with the lowest
  // load address.  This is used when handling a PHDRS clause in a
  // linker script.
  Output_section*
  section_with_lowest_load_address() const;

  // Write the segment header into *OPHDR.
  template<int size, bool big_endian>
  void
  write_header(elfcpp::Phdr_write<size, big_endian>*);

  // Write the section headers of associated sections into V.
  template<int size, bool big_endian>
  unsigned char*
  write_section_headers(const Layout*, const Stringpool*, unsigned char* v,
			unsigned int* pshndx) const;

  // Print the output sections in the map file.
  void
  print_sections_to_mapfile(Mapfile*) const;

 private:
  typedef std::vector<Output_data*> Output_data_list;

  // Find the maximum alignment in an Output_data_list.
  static uint64_t
  maximum_alignment_list(const Output_data_list*);

  // Return whether the first data section is a relro section.
  bool
  is_first_section_relro() const;

  // Set the section addresses in an Output_data_list.
  uint64_t
  set_section_list_addresses(Layout*, bool reset, Output_data_list*,
			     uint64_t addr, off_t* poff, unsigned int* pshndx,
			     bool* in_tls);

  // Return the number of Output_sections in an Output_data_list.
  unsigned int
  output_section_count_list(const Output_data_list*) const;

  // Return whether an Output_data_list has a dynamic reloc.
  bool
  has_dynamic_reloc_list(const Output_data_list*) const;

  // Find the section with the lowest load address in an
  // Output_data_list.
  void
  lowest_load_address_in_list(const Output_data_list* pdl,
			      Output_section** found,
			      uint64_t* found_lma) const;

  // Find the first and last entries by address.
  void
  find_first_and_last_list(const Output_data_list* pdl,
			   const Output_data** pfirst,
			   const Output_data** plast) const;

  // Write the section headers in the list into V.
  template<int size, bool big_endian>
  unsigned char*
  write_section_headers_list(const Layout*, const Stringpool*,
			     const Output_data_list*, unsigned char* v,
			     unsigned int* pshdx) const;

  // Print a section list to the mapfile.
  void
  print_section_list_to_mapfile(Mapfile*, const Output_data_list*) const;

  // NOTE: We want to use the copy constructor.  Currently, shallow copy
  // works for us so we do not need to write our own copy constructor.

  // The list of output data attached to this segment.
  Output_data_list output_lists_[ORDER_MAX];
  // The segment virtual address.
  uint64_t vaddr_;
  // The segment physical address.
  uint64_t paddr_;
  // The size of the segment in memory.
  uint64_t memsz_;
  // The maximum section alignment.  The is_max_align_known_ field
  // indicates whether this has been finalized.
  uint64_t max_align_;
  // The required minimum value for the p_align field.  This is used
  // for PT_LOAD segments.  Note that this does not mean that
  // addresses should be aligned to this value; it means the p_paddr
  // and p_vaddr fields must be congruent modulo this value.  For
  // non-PT_LOAD segments, the dynamic linker works more efficiently
  // if the p_align field has the more conventional value, although it
  // can align as needed.
  uint64_t min_p_align_;
  // The offset of the segment data within the file.
  off_t offset_;
  // The size of the segment data in the file.
  off_t filesz_;
  // The segment type;
  elfcpp::Elf_Word type_;
  // The segment flags.
  elfcpp::Elf_Word flags_;
  // Whether we have finalized max_align_.
  bool is_max_align_known_ : 1;
  // Whether vaddr and paddr were set by a linker script.
  bool are_addresses_set_ : 1;
  // Whether this segment holds large data sections.
  bool is_large_data_segment_ : 1;
  // Whether this was marked as a unique segment via a linker plugin.
  bool is_unique_segment_ : 1;
};

// This class represents the output file.

class Output_file
{
 public:
  Output_file(const char* name);

  // Indicate that this is a temporary file which should not be
  // output.
  void
  set_is_temporary()
  { this->is_temporary_ = true; }

  // Try to open an existing file. Returns false if the file doesn't
  // exist, has a size of 0 or can't be mmaped.  This method is
  // thread-unsafe.  If BASE_NAME is not NULL, use the contents of
  // that file as the base for incremental linking.
  bool
  open_base_file(const char* base_name, bool writable);

  // Open the output file.  FILE_SIZE is the final size of the file.
  // If the file already exists, it is deleted/truncated.  This method
  // is thread-unsafe.
  void
  open(off_t file_size);

  // Resize the output file.  This method is thread-unsafe.
  void
  resize(off_t file_size);

  // Close the output file (flushing all buffered data) and make sure
  // there are no errors.  This method is thread-unsafe.
  void
  close();

  // Return the size of this file.
  off_t
  filesize()
  { return this->file_size_; }

  // Return the name of this file.
  const char*
  filename()
  { return this->name_; }

  // We currently always use mmap which makes the view handling quite
  // simple.  In the future we may support other approaches.

  // Write data to the output file.
  void
  write(off_t offset, const void* data, size_t len)
  { memcpy(this->base_ + offset, data, len); }

  // Get a buffer to use to write to the file, given the offset into
  // the file and the size.
  unsigned char*
  get_output_view(off_t start, size_t size)
  {
    gold_assert(start >= 0
		&& start + static_cast<off_t>(size) <= this->file_size_);
    return this->base_ + start;
  }

  // VIEW must have been returned by get_output_view.  Write the
  // buffer to the file, passing in the offset and the size.
  void
  write_output_view(off_t, size_t, unsigned char*)
  { }

  // Get a read/write buffer.  This is used when we want to write part
  // of the file, read it in, and write it again.
  unsigned char*
  get_input_output_view(off_t start, size_t size)
  { return this->get_output_view(start, size); }

  // Write a read/write buffer back to the file.
  void
  write_input_output_view(off_t, size_t, unsigned char*)
  { }

  // Get a read buffer.  This is used when we just want to read part
  // of the file back it in.
  const unsigned char*
  get_input_view(off_t start, size_t size)
  { return this->get_output_view(start, size); }

  // Release a read bfufer.
  void
  free_input_view(off_t, size_t, const unsigned char*)
  { }

 private:
  // Map the file into memory or, if that fails, allocate anonymous
  // memory.
  void
  map();

  // Allocate anonymous memory for the file.
  bool
  map_anonymous();

  // Map the file into memory.
  bool
  map_no_anonymous(bool);

  // Unmap the file from memory (and flush to disk buffers).
  void
  unmap();

  // File name.
  const char* name_;
  // File descriptor.
  int o_;
  // File size.
  off_t file_size_;
  // Base of file mapped into memory.
  unsigned char* base_;
  // True iff base_ points to a memory buffer rather than an output file.
  bool map_is_anonymous_;
  // True if base_ was allocated using new rather than mmap.
  bool map_is_allocated_;
  // True if this is a temporary file which should not be output.
  bool is_temporary_;
};

} // End namespace gold.

#endif // !defined(GOLD_OUTPUT_H)
@


1.149
log
@gold/
	* target.h (Target::adjust_elf_header, Target::do_adjust_elf_header):
	Remove const from declaration.
	* target.cc (Sized_target::do_adjust_elf_header): Update definition.
	* sparc.cc (Target_sparc::do_adjust_elf_header): Likewise.
	* output.h (Output_file_header): Remove const from member target_
	and corresponding constructor argument.
	* output.cc (Output_file_header::Output_file_header): Update prototype.
	(Output_file_header::do_sized_write): Use this->target_ in place
	of parameters()->target().
@
text
@d2383 7
a2389 4
  {
    unsigned int got_offset = this->add_got_entry(Got_entry(constant));
    return got_offset;
  }
@


1.148
log
@gold/
	* output.cc (Output_segment::set_section_addresses): Take new
	Target* argument.  If target->isolate_execinstr() and the segment
	is executable and starts at a target->abi_pagesize() boundary,
	pad its end out to a target->abi_pagesize() boundary with code fill.
	* output.h (Output_segment::set_section_addresses): Update decl.
	* layout.h (Layout::check_output_data_for_reset_values): Take new
	argument RELAX_OUTPUTS.
	(Layout): New member relax_output_list_.
	(Layout::add_relax_output): New method.
	* layout.cc (Layout::Layout): Update constructor.
	(Layout::reset_relax_output): New method.
	(Layout::clean_up_after_relaxation): Call it.
	(Layout::prepare_for_relaxation): Update caller.
	(Layout::set_segment_offsets): Update callers of set_section_addresses.
	Call reset_relax_output before re-processing segments for
	isolate_execinstr case.
	(Layout::write_data): Handle relax_output_list_.
	(Layout::Relaxation_debug_check::check_output_data_for_reset_values):
	Take new argument RELAX_OUTPUTS.  Assert it's an empty collection.
@
text
@d576 1
a576 1
  Output_file_header(const Target*,
d620 1
a620 1
  const Target* target_;
@


1.148.2.1
log
@gold/
	* target.h (Target::adjust_elf_header, Target::do_adjust_elf_header):
	Remove const from declaration.
	* target.cc (Sized_target::do_adjust_elf_header): Update definition.
	* sparc.cc (Target_sparc::do_adjust_elf_header): Likewise.
	* output.h (Output_file_header): Remove const from member target_
	and corresponding constructor argument.
	* output.cc (Output_file_header::Output_file_header): Update prototype.
	(Output_file_header::do_sized_write): Use this->target_ in place
	of parameters()->target().
@
text
@d576 1
a576 1
  Output_file_header(Target*,
d620 1
a620 1
  Target* target_;
@


1.148.2.2
log
@	* output.h (Output_data_got::add_constant): Tidy.
	(Output_data_got::add_constant_pair): New function.
	* powerpc.cc (Output_data_got_powerpc): Override all Output_data_got
	methods used so as to first call reserve_ent().
@
text
@d2383 4
a2386 7
  { return this->add_got_entry(Got_entry(constant)); }

  // Add a pair of constants to the GOT.  This returns the offset of
  // the new entry from the start of the GOT.
  unsigned int
  add_constant_pair(Valtype c1, Valtype c2)
  { return this->add_got_entry_pair(Got_entry(c1), Got_entry(c2)); }
@


1.147
log
@2013-05-30  Alexander Ivchenko  <alexander.ivchenko@@intel.com>
	    Sriraman Tallam  <tmsriram@@google.com>

	* options.h (sort_section): New option.
	* output.h (Input_section_sort_section_prefix_special_ordering_compare):
	Rename from Input_section_sort_section_name_special_ordering_compare.
	(Input_section_sort_section_name_compare): New struct.
	* output.cc (Output_section::Input_section_sort_section_name_compare::
	operator()): New function.
	(Output_section::sort_attached_input_sections): Use new sort function
	for .text if --sort-section=name is specified.
	* layout.cc (Layout::make_output_section):
	Add sorting by name when --sort-section=name is specified.
	* testsuite/Makefile.am (text_section_grouping): Test option
	--sort-section=name.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/section_sorting_name.cc: New file.
	* testsuite/section_sorting_name.sh: New file.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d4600 1
a4600 1
  set_section_addresses(Layout*, bool reset, uint64_t addr,
@


1.146
log
@Default text reordering fix with a flag to turn it off.

2013-01-24  Sriraman Tallam  <tmsriram@@google.com>

	* layout.cc (Layout::layout): Check for option text_reorder.
	(Layout::make_output_section): Ditto.
	* options.h (text_reorder): New option.
	* output.cc (Input_section_sort_compare): Remove special ordering
	of section names.
	(Output_section::
	 Input_section_sort_section_name_special_ordering_compare::
	 operator()): New function.
	(Output_section::sort_attached_input_sections): Use new sort function
	for .text.
	* output.h (Input_section_sort_section_name_special_ordering_compare):
	New struct.
	* testsuite/Makefile.am (text_section_grouping): Test option
	--no-text-reorder
	* testsuite/Makefile.in: Regenerate.
	* testsuite/text_section_grouping.sh: Check order of functions without
	default text reordering.
@
text
@d4205 9
a4213 1
  struct Input_section_sort_section_name_special_ordering_compare
@


1.145
log
@Make linker scripts and section ordering via --section-ordering-file or
linker plugins work. This patch lets linker scripts take precedence.

2013-01-09  Sriraman Tallam  <tmsriram@@google.com>

	* output.h (sort_attached_input_sections): Change to be public.
	* script-sections.cc
	(Output_section_definition::set_section_addresses): Sort
	attached input sections according to section order before linker
	script assigns section addresses.
	(Orphan_output_section::set_section_addresses): Sort
	attached input sections according to section order before linker
	script assigns section addresses.
	* Makefile.am (final_layout.sh): Use a simple linker script to
	check if section ordering still works.
	* Makefile.in: Regenerate.
@
text
@d4203 9
@


1.144
log
@	* options.h (General_options): Add --toc-sort/--no-toc-sort.
	Replace no_toc_optimize with toc_optimize.
	* output.h (Output_section::input_sections): Provide non-const variant.
	* powerpc.cc (Powerpc_relobj::has_small_toc_reloc_,
	set_has_small_toc_reloc, has_small_toc_reloc): New variable and
	accessors.
	(Target_powerpc::Scan::local, global): Call set_has_small_toc_reloc.
	(class Sort_toc_sections): New.
	(Target_powerpc::do_finalize_sections): Sort toc sections.
	(Target_powerpc::Relocate::relocate): Update toc_optimize test.
@
text
@d3303 4
a4259 4
  // Sort the attached input sections.
  void
  sort_attached_input_sections();

@


1.143
log
@	* output.h: Formatting, whitespace.
@
text
@d3944 4
@


1.142
log
@	* layout.h (Layout::get_executable_sections): Declare.
	* layout.cc (Layout::get_executable_sections): New function.
	* arm.cc (Target_arm::group_sections): Use it.
	(Arm_output_section::group_sections): Delete now redundant test.
	* output.cc (Output_reloc::Output_reloc): Add is_relative.
	param to handle relative relocs.
	* output.h (Output_reloc::Output_reloc <absolute reloc>): Likewise.
	(Output_data_reloc::add_absolute): Adjust.
	(Output_data_reloc::add_relative): New function.
	(Output_data::reset_data_size): New function.
	(Output_relaxed_input_section::set_relobj, set_shndx): New functions.
	(Output_section::set_addralign): New function.
	(Output_section::checkpoint_set_addralign): New function.
	(Output_section::clear_section_offsets_need_adjustment): New function.
	(Output_section::input_sections): Make public.
	* powerpc.cc (class Output_data_brlt_powerpc): New.
	(class Stub_table, class Stub_control): New.
	(Powerpc_relobj::has14_, set_has_14bit_branch, has_14bit_branch,
	stub_table_, set_stub_table, stub_table): New vectors and accessor
	functions.
	(Target_powerpc::do_may_relax, do_relax, push_branch,
	new_stub_table, stub_tables, brlt_section, group_sections,
	add_branch_lookup_table, find_branch_lookup_table,
	write_branch_lookup_table, make_brlt_section): New functions.
	(Target_powerpc::struct Sort_sections, class Branch_info): New.
	(Target_powerpc::brlt_section_, stub_tables_, branch_lookup_table_,
	branch_info_): New vars.
	(Target_powerpc::make_plt_entry, make_local_ifunc_plt_entry): Don't
	make call stubs here.
	(Output_data_glink): Remove all call stub handling from this class.
	(Target_powerpc::Scan::local, global): Save interesting branch
	relocs and relocs for ifunc.  Adjust calls to plt entry functions.
	(Target_powerpc::do_finalize_sections): Only make reg save/restore
	functions on final link.
	(Target_powerpc::Relocate::relocate): Adjust lookup of call stubs.
	Handle long branch destinations too.
	(Target_powerpc::do_dynsym_value, do_plt_address_for_global,
	do_plt_address_for_local): Adjust lookup of plt call stubs.
@
text
@d95 1
a95 1
  
d417 1
a417 1
  // and the data size remains always valid. 
d1036 1
a1036 1
               Sized_relobj<size, big_endian>* relobj,
d1045 2
a1046 2
               bool is_symbolless, bool is_section_symbol,
               bool use_plt_offset);
d1051 2
a1052 2
               bool is_symbolless, bool is_section_symbol,
               bool use_plt_offset);
d1103 2
a1104 2
            && this->local_sym_index_ != SECTION_CODE
            && this->local_sym_index_ != INVALID_CODE
d1106 1
a1106 1
            && this->is_section_symbol_);
d1274 1
a1274 1
               Sized_relobj<size, big_endian>* relobj,
d1290 1
a1290 1
           is_symbolless, is_section_symbol, use_plt_offset),
d1301 1
a1301 1
           is_symbolless, is_section_symbol, use_plt_offset),
d1313 1
a1313 1
               Sized_relobj<size, big_endian>* relobj,
d1573 4
a1576 1
  { this->add(od, Output_reloc_type(gsym, type, od, address, false, false, false)); }
d1580 1
a1580 1
             Sized_relobj<size, big_endian>* relobj,
d1582 4
a1585 2
  { this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
                                    false, false, false)); }
d1615 5
a1619 3
                      Address address)
  { this->add(od, Output_reloc_type(gsym, type, od, address, true, true,
				    false)); }
d1623 2
a1624 2
                      Sized_relobj<size, big_endian>* relobj,
                      unsigned int shndx, Address address)
d1627 1
a1627 1
                                    true, true, false));
d1636 4
a1639 2
  { this->add(od, Output_reloc_type(gsym, type, od, address, false, true,
				    false)); }
d1648 1
a1648 1
                                    false, true, false));
d1659 1
a1659 1
                                    address, false, false, false, false));
d1701 2
a1702 2
	             unsigned int local_sym_index, unsigned int type,
	             Output_data* od, Address address)
d1705 1
a1705 1
                                    address, true, true, false, false));
d1710 2
a1711 2
	             unsigned int local_sym_index, unsigned int type,
	             Output_data* od, unsigned int shndx, Address address)
d1726 1
a1726 1
                                    address, false, true, false, false));
d1745 2
a1746 2
                    unsigned int input_shndx, unsigned int type,
                    Output_data* od, Address address)
d1749 1
a1749 1
                                    address, false, false, true, false));
d1754 2
a1755 2
                    unsigned int input_shndx, unsigned int type,
                    Output_data* od, unsigned int shndx, Address address)
d1758 1
a1758 1
                                    address, false, false, true, false));
d1773 1
a1773 1
                     unsigned int shndx, Address address)
d1878 4
a1881 2
  { this->add(od, Output_reloc_type(gsym, type, od, address, addend,
                                    false, false, false)); }
d1885 1
a1885 1
             Sized_relobj<size, big_endian>* relobj,
d1888 4
a1891 2
  { this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
                                    addend, false, false, false)); }
d1923 5
a1927 3
	              Address address, Addend addend, bool use_plt_offset)
  { this->add(od, Output_reloc_type(gsym, type, od, address, addend, true,
				    true, use_plt_offset)); }
d1931 2
a1932 2
                      Sized_relobj<size, big_endian>* relobj,
                      unsigned int shndx, Address address, Addend addend,
d1934 4
a1937 2
  { this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
                                    addend, true, true, use_plt_offset)); }
d1945 4
a1948 2
  { this->add(od, Output_reloc_type(gsym, type, od, address, addend,
				    false, true, false)); }
d1954 6
a1959 3
			       unsigned int shndx, Address address, Addend addend)
  { this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
                                    addend, false, true, false)); }
d1979 2
a1980 2
                                    address, addend, false, false, false,
                                    false));
d2013 3
a2015 3
	             unsigned int local_sym_index, unsigned int type,
	             Output_data* od, Address address, Addend addend,
	             bool use_plt_offset)
d2024 3
a2026 3
	             unsigned int local_sym_index, unsigned int type,
	             Output_data* od, unsigned int shndx, Address address,
	             Addend addend, bool use_plt_offset)
d2029 2
a2030 2
                                    address, addend, true, true, false,
                                    use_plt_offset));
d2052 2
a2053 2
                                    address, addend, false, true, false,
                                    false));
d2062 2
a2063 2
                    unsigned int input_shndx, unsigned int type,
                    Output_data* od, Address address, Addend addend)
d2076 2
a2077 2
                                    address, addend, false, false, true,
                                    false));
d2089 1
a2089 1
                     Sized_relobj<size, big_endian>* relobj,
d2091 4
a2094 2
  { this->add(od, Output_reloc_type(os, type, relobj, shndx, address,
                                    addend, false)); }
d2150 4
a2153 2
  { this->add(od, Output_reloc_type(type, relobj, shndx, address, addend,
				    false)); }
d2166 4
a2169 2
  { this->add(od, Output_reloc_type(type, relobj, shndx, address, addend,
				    true)); }
d2324 1
a2324 1
                      Output_data_reloc_generic* rel_dyn, unsigned int r_type);
d2330 1
a2330 1
                           Output_data_reloc_generic* rel_dyn,
d2366 1
a2366 1
                          unsigned int r_type);
d2549 1
a2549 1
                          unsigned int offset)
d2757 1
a2757 1
 
d2762 1
a2762 1
 
d2812 1
a2812 1
    
d2869 1
a2869 1
  
d2902 1
a2902 1
  
d3081 1
a3081 1
                    unsigned int shndx, const char* name,
d3435 1
a3435 1
  
d3615 1
a3615 1
 
d3638 1
a3638 1
                     uint64_t addralign) const
d3644 1
a3644 1
              && this->addralign() == addralign);
d3683 1
a3683 1
 
d3705 2
a3706 2
      Output_section_data* posd = 
        this->is_relaxed_input_section() ? this->u2_.poris : this->u2_.posd;
d3867 1
a3867 1
  
d4403 1
a4403 1
  uint64_t extra_segment_flags_; 
d4639 2
a4640 2
                             uint64_t addr, off_t* poff, unsigned int* pshndx,
                             bool* in_tls);
d4676 1
a4676 1
  
d4773 1
a4773 1
                && start + static_cast<off_t>(size) <= this->file_size_);
@


1.141
log
@	* i386.cc (Output_data_plt_i386::address_for_global,
	address_for_local): Add plt offset to returned value.  Adjust uses.
	* sparc.cc (Output_data_plt_sparc::address_for_global,
	address_for_local): Likewise.
	* tilegx.cc (Output_data_plt_tilegx::address_for_global,
	address_for_local): Likewise.
	* x86_64.cc (Output_data_plt_x86_64::address_for_global,
	address_for_local): Likewise.
	* target.h (Target::plt_address_for_global, plt_address_for_local):
	Update comment.
	* output.cc (Output_reloc::symbol_value): Don't add plt offset here.
	(Output_data_got::Got_entry::write): Nor here.
	* output.h: Comment fix.
@
text
@d106 2
a107 2
  // Reset the address and file offset.  This essentially disables the
  // sanity testing about duplicate and unknown settings.
d118 8
d1063 1
a1063 1
  // An absolute relocation with no symbol.
d1065 2
a1066 1
  Output_reloc(unsigned int type, Output_data* od, Address address);
d1069 1
a1069 1
	       unsigned int shndx, Address address);
d1319 1
a1319 1
  // An absolute relocation with no symbol.
d1322 2
a1323 2
	       Addend addend)
    : rel_(type, od, address), addend_(addend)
d1327 3
a1329 2
	       unsigned int shndx, Address address, Addend addend)
    : rel_(type, relobj, shndx, address), addend_(addend)
d1810 1
a1810 1
  { this->add(od, Output_reloc_type(type, od, address)); }
d1816 13
a1828 1
  { this->add(od, Output_reloc_type(type, relobj, shndx, address)); }
d2120 1
a2120 1
  { this->add(od, Output_reloc_type(type, od, address, addend)); }
d2126 16
a2141 1
  { this->add(od, Output_reloc_type(type, relobj, shndx, address, addend)); }
d2740 9
d3211 7
d3850 5
d3909 7
a4037 7
  typedef std::vector<Input_section> Input_section_list;

  // Allow a child class to access the input sections.
  const Input_section_list&
  input_sections() const
  { return this->input_sections_; }

d4076 4
@


1.140
log
@	* output.h (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::add_local_pair_with_rel): Remove second
	reloc param.  Expand comment.
	(Output_data_got::Got_entry): Rename use_plt_offset_ to
	use_plt_or_tls_offset_, similarly for constructor param.
	(Output_data_got::Got_entry::write): Add got_index param.
	* output.cc (Output_data_got::add_global_tls, add_local_tls,
	add_local_tls_pair): New functions.
	(Output_data_got::Got_entry::write): Handle tls symbols
	with use_plt_or_tls_offset_ set specially.
	(Output_data_got::add_local_pair_with_rel): Only one reloc.
	(Output_data_got::do_write): Replace iterator with index, pass
	index to entry write function.
	* target.h (Target::tls_offset_for_local, tls_offset_for_global,
	do_tls_offset_for_local, do_tls_offset_for_global): New functions.
	* arm.cc (Target_arm::Scan::local): Update add_local_pair_with_rel
	call.
	* i386.cc (Target_i386::Scan::local): Likewise.
	* sparc.cc (Target_sparc::Scan::local): Likewise.
	* x86_64.cc (Target_x86_64::Scan::local): Likewise.
	* powerpc.cc (Target_powerpc::do_tls_offset_for_local,
	do_tls_offset_for_global): New functions.
	(Target_powerpc::Scan::local): Correct TLS relocations and got
	entry values.
	(Target_powerpc::Scan::global): Don't emit unnecessary
	dynamic relocations on TLS GOT entries.
@
text
@d2250 1
a2250 1
  // offset using Target::tls_offset_for_global
d2280 1
a2280 1
  // offset using Target::tls_offset_for_local
@


1.139
log
@	* object.h (Sized_relobj_file::emit_relocs): Delete.
	(Sized_relobj_file::emit_relocs_reltype): Delete.
	* reloc.cc (Sized_relobj_file::do_relocate_sections): Call target
	relocate_relocs for --emit-relocs.
	(Sized_relobj_file::emit_relocs, emit_relocs_reltype): Delete.
	* output.h: Update comment.
	(Output_segment::first_section): New function.
	(Output_segment::first_section_load_address): Use first_section.
	* output.cc (Output_segment::first_section): New function extracted..
	(Output_segment::first_section_load_address): ..from here.  Delete.
	* target-reloc.h (relocate_for_relocatable): Rename to relocate_relocs.
	* target.h (Sized_target::relocate_for_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise, and
	adjust call to target.h function.
	* i386.cc (Target_i386): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	(Target_powerpc::Scan::local, global): Handle R_POWERPC_TLS.  Ensure
	first tls section has section symbol for optimised local dynamic
	output relocs.
	(Target_powerpc::Relocate::relocate): Correct local dynamic value.
	(Target_powerpc::relocate_relocs): Adjust relocs emitted for
	optimised tls code.
	* testsuite/testfile.cc (Target_test::relocate_for_relocatable):
	Rename to relocate_relocs.  Update error message.
@
text
@d2249 6
d2279 6
d2293 4
a2296 1
  // dynamic relocations of type R_TYPE_1 and R_TYPE_2, respectively.
d2301 11
a2311 1
                          unsigned int r_type_1, unsigned int r_type_2);
d2370 1
a2370 1
      : local_sym_index_(RESERVED_CODE), use_plt_offset_(false)
d2374 3
a2376 2
    Got_entry(Symbol* gsym, bool use_plt_offset)
      : local_sym_index_(GSYM_CODE), use_plt_offset_(use_plt_offset)
d2381 3
a2383 2
	      bool use_plt_offset)
      : local_sym_index_(local_sym_index), use_plt_offset_(use_plt_offset)
d2395 1
a2395 1
      : local_sym_index_(CONSTANT_CODE), use_plt_offset_(false)
d2400 1
a2400 1
    write(unsigned char* pov) const;
d2423 2
a2424 1
    bool use_plt_offset_ : 1;
@


1.138
log
@	* output.h (Output_reloc::Output_reloc <output section>): Add
	is_relative param.  Adjust calls.
	(Output_reloc::add_output_section_relative): New functions.
	* output.cc (Output_reloc::Output_reloc <output section>): Handle
	is_relative.
	(Output_reloc::symbol_value): Handle SECTION_CODE.
@
text
@d2126 1
a2126 1
// hook relocate_for_relocatable.  This just saves space for it.
d4409 4
d4415 5
a4419 1
  first_section_load_address() const;
@


1.137
log
@Patch adds support to allow plugins to map selected subset of sections to unique
segments.


2012-08-24  Sriraman Tallam  <tmsriram@@google.com>

	* gold.cc (queue_middle_tasks): Call layout again when unique
	segments for sections is desired.
	* layout.cc (Layout::Layout): Initialize new members.
	(Layout::get_output_section_flags): New function.
	(Layout::choose_output_section): Call get_output_section_flags.
	(Layout::layout): Make output section for mapping to a unique segment.
	(Layout::insert_section_segment_map): New function.
	(Layout::attach_allocated_section_to_segment): Make unique segment for
	output sections marked so.
	(Layout::segment_precedes): Check for unique segments when sorting.
	* layout.h (Layout::Unique_segment_info): New struct.
	(Layout::Section_segment_map): New typedef.
	(Layout::insert_section_segment_map): New function.
	(Layout::get_output_section_flags): New function.
	(Layout::is_unique_segment_for_sections_specified): New function.
	(Layout::set_unique_segment_for_sections_specified): New function.
	(Layout::unique_segment_for_sections_specified_): New member.
	(Layout::section_segment_map_): New member.
	* object.cc (Sized_relobj_file<size, big_endian>::do_layout):
	Rename is_gc_pass_one to is_pass_one.
	Rename is_gc_pass_two to is_pass_two.
	Rename is_gc_or_icf to is_two_pass.
	Check for which pass based on whether symbols data is present.
	Make it two pass when unique segments for sections is desired.
	* output.cc (Output_section::Output_section): Initialize new
	members.
	* output.h (Output_section::is_unique_segment): New function.
	(Output_section::set_is_unique_segment): New function.
	(Output_section::is_unique_segment_): New member.
	(Output_section::extra_segment_flags): New function.
	(Output_section::set_extra_segment_flags): New function.
	(Output_section::extra_segment_flags_): New member.
	(Output_section::segment_alignment): New function.
	(Output_section::set_segment_alignment): New function.
	(Output_section::segment_alignment_): New member.
	(Output_segment::Output_segment): Initialize is_unique_segment_.
	(Output_segment::is_unique_segment): New function.
	(Output_segment::set_is_unique_segment): New function.
	(Output_segment::is_unique_segment_): New member.
	* plugin.cc (allow_unique_segment_for_sections): New function.
	(unique_segment_for_sections): New function.
	(Plugin::load): Add new functions to transfer vector.
	* Makefile.am (plugin_final_layout.readelf.stdout): Add readelf output.
	* Makefile.in: Regenerate.
	* testsuite/plugin_final_layout.sh: Check if unique segment
	functionality works.
	* testsuite/plugin_section_order.c (onload): Check if new interfaces
	are available.
	(allow_unique_segment_for_sections): New global.
	(unique_segment_for_sections): New global.
	(claim_file_hook): Call allow_unique_segment_for_sections.
	(all_symbols_read_hook): Call unique_segment_for_sections.


2012-08-24  Sriraman Tallam  <tmsriram@@google.com>

	* plugin-api.h (ld_plugin_allow_unique_segment_for_sections):
	New interface.
	(ld_plugin_unique_segment_for_sections): New interface.
	(LDPT_ALLOW_UNIQUE_SEGMENT_FOR_SECTIONS): New enum val.
	(LDPT_UNIQUE_SEGMENT_FOR_SECTIONS): New enum val.
	(tv_allow_unique_segment_for_sections): New member.
	(tv_unique_segment_for_sections): New member.
@
text
@d1049 1
a1049 1
	       Address address);
d1052 2
a1053 2
               Sized_relobj<size, big_endian>* relobj,
	       unsigned int shndx, Address address);
d1299 2
a1300 2
	       Address address, Addend addend)
    : rel_(os, type, od, address), addend_(addend)
d1305 3
a1307 2
	       unsigned int shndx, Address address, Addend addend)
    : rel_(os, type, relobj, shndx, address), addend_(addend)
d1749 1
a1749 1
  { this->add(od, Output_reloc_type(os, type, od, address)); }
d1755 1
a1755 1
  { this->add(od, Output_reloc_type(os, type, relobj, shndx, address)); }
d1764 2
a1765 1
				    convert_types<Address, uint64_t>(address)));
d1778 2
a1779 1
				    convert_types<Address, uint64_t>(address)));
d1782 14
d2041 1
a2041 1
  { this->add(od, Output_reloc_type(os, type, od, address, addend)); }
d2048 1
a2048 1
                                    addend)); }
d2057 2
a2058 1
				    convert_types<Addend, uint64_t>(addend)));
d2071 20
a2090 1
				    convert_types<Addend, uint64_t>(addend)));
@


1.136
log
@	* object.h (Sized_relobj_file::find_shdr): New function.
	(Sized_relobj_file::find_special_sections): New function.
	* object.cc (Sized_relobj_file::find_shdr): New function.
	(Sized_relobj_file::find_eh_frame): Use find_shdr.
	(Sized_relobj_file::find_special_sections): New function, split out..
	(Sized_relobj_file::do_read_symbols): ..from here.
	* output.h (Output_data_got::replace_constant): New function.
	(Output_data_got::num_entries): New function.
	(Output_data_got::last_got_offset,set_got_size): Use num_entries.
	(Output_data_got::got_offset): Protected rather than private.
	(Output_data_got::replace_got_entry): New function.
	* output.cc (Output_data_got::replace_got_entry): New function.
	* powerpc.cc (class Powerpc_relobj): New.
	(class Powerpc_relocate_functions): Delete all psymval variants or
	convert to value,addend type.  Delete pcrela, pcrela_unaligned.
	Implement _ha functions using corresponding _hi function.
	(Powerpc_relobj::find_special_sections): New function.
	(Target_powerpc::do_make_elf_object): New function.
	(class Output_data_got_powerpc): New.
	(class Output_data_glink): New.
	(class Powerpc_scan_relocatable_reloc): New.
	Many more changes througout file.
@
text
@d3268 22
d4241 2
d4246 6
d4327 10
d4547 2
@


1.135
log
@	PR gold/14309
	* configure.ac: Test whether std::tr1::hash<off_t> works.
	* gold.h: Add a specialization for std::tr1::hash<off_t> if
	needed.
	* output.h (class Output_fill): Add virtual destructor.
	* configure, config.in: Rebuild.
@
text
@d2260 7
d2291 10
d2372 3
a2374 4
  // Return the offset into the GOT of GOT entry I.
  unsigned int
  got_offset(unsigned int i) const
  { return i * (got_size / 8); }
d2379 1
a2379 1
  { return this->got_offset(this->entries_.size() - 1); }
d2384 1
a2384 1
  { this->set_current_data_size(this->got_offset(this->entries_.size())); }
@


1.135.2.1
log
@gold/
	* output.cc (Output_segment::set_section_addresses): Take new
	Target* argument.  If target->isolate_execinstr() and the segment
	is executable and starts at a target->abi_pagesize() boundary,
	pad its end out to a target->abi_pagesize() boundary with code fill.
	* output.h (Output_segment::set_section_addresses): Update decl.
	* layout.h (Layout::check_output_data_for_reset_values): Take new
	argument RELAX_OUTPUTS.
	(Layout): New member relax_output_list_.
	(Layout::add_relax_output): New method.
	* layout.cc (Layout::Layout): Update constructor.
	(Layout::reset_relax_output): New method.
	(Layout::clean_up_after_relaxation): Call it.
	(Layout::prepare_for_relaxation): Update caller.
	(Layout::set_segment_offsets): Update callers of set_section_addresses.
	Call reset_relax_output before re-processing segments for
	isolate_execinstr case.
	(Layout::write_data): Handle relax_output_list_.
	(Layout::Relaxation_debug_check::check_output_data_for_reset_values):
	Take new argument RELAX_OUTPUTS.  Assert it's an empty collection.
@
text
@d3 1
a3 2
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2013
// Free Software Foundation, Inc.
d4359 1
a4359 1
  set_section_addresses(const Target*, Layout*, bool reset, uint64_t addr,
@


1.134
log
@gold: Allow use_plt_offset to be specified for global relocations.

gold/

	* output.h (Output_reloc): Allow use_plt_offset for global relocs too.
	(class Output_data_reloc): Adjust calls to Output_reloc_type.
	(Output_data_reloc::add_global_relative): (RELA only) Add use_plt_offset.
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag for
	global relocs too.
	(Output_reloc::symbol_value): Respect use_plt_offset_ for global symbols.
	* powerpc.cc (Target_powerpc::Scan::global): Adjust add_global_relative
	calls.
	* sparc.cc (Target_sparc::Scan::global): Likewise.
	* x86_64.cc (Target_x86_64::Scan::global): Likewise.
@
text
@d2822 4
@


1.133
log
@	* gold/incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Use abstract base class for GOT.
	* gold/output.h (class Output_data_got_base): New abstract base class.
	(class Output_data_got): Derive from new base class, adjust ctors.
	(Output_data_got::reserve_slot): Make virtual; rename to
	do_reserve_slot; Adjust callers.
	* gold/target.h (Sized_target::init_got_plt_for_update): Return
	pointer to abstract base class.
	* gold/x86_64.cc (Target_x86_64::init_got_plt_for_update): Likewise.
@
text
@d1024 2
a1025 1
	       Address address, bool is_relative, bool is_symbolless);
d1030 1
a1030 1
	       bool is_symbolless);
d1230 1
a1230 2
  // True if the addend should be the PLT offset.  This is used only
  // for RELATIVE relocations to local symbols.
d1258 3
a1260 2
	       bool is_symbolless)
    : rel_(gsym, type, od, address, is_relative, is_symbolless),
d1267 1
a1267 1
	       bool is_relative, bool is_symbolless)
d1269 1
a1269 1
	   is_symbolless), addend_(addend)
d1562 1
a1562 1
  { this->add(od, Output_reloc_type(gsym, type, od, address, false, false)); }
d1569 1
a1569 1
                                    false, false)); }
d1578 1
a1578 1
				    false, false));
d1591 1
a1591 1
				    false, false));
d1600 2
a1601 1
  { this->add(od, Output_reloc_type(gsym, type, od, address, true, true)); }
d1609 1
a1609 1
                                    true, true));
d1618 2
a1619 1
  { this->add(od, Output_reloc_type(gsym, type, od, address, false, true)); }
d1628 1
a1628 1
                                    false, true));
d1831 1
a1831 1
                                    false, false)); }
d1839 1
a1839 1
                                    addend, false, false)); }
d1848 1
a1848 1
				    false, false));
d1861 1
a1861 1
				    false, false));
d1871 1
a1871 1
	              Address address, Addend addend)
d1873 1
a1873 1
				    true)); }
d1878 2
a1879 1
                      unsigned int shndx, Address address, Addend addend)
d1881 1
a1881 1
                                    addend, true, true)); }
d1890 1
a1890 1
				    false, true)); }
d1898 1
a1898 1
                                    addend, false, true)); }
@


1.132
log
@	* object.h (Relobj::local_symbol_value): New function.
	(Relobj::local_plt_offset): New function.
	(Relobj::local_has_got_offset): New function.
	(Relobj::local_got_offset): New function.
	(Relobj::set_local_got_offset): New function.
	(Relobj::do_local_symbol_value): New pure virtual function.
	(Relobj::do_local_plt_offset): Likewise.
	(Relobj::do_local_has_got_offset): Likewise.
	(Relobj::do_local_got_offset): Likewise.
	(Relobj::do_set_local_got_offset): Likewise.
	(Sized_relobj::do_local_has_got_offset): Rename from
	local_has_got_offset.
	(Sized_relobj::do_local_got_offset): Rename from local_got_offset.
	(Sized_relobj::do_set_local_got_offset): Rename from
	set_local_got_offset.
	(Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	(Sized_relobj_file::do_local_symbol_value): New function.
	* object.cc (Sized_relobj_file::do_local_plt_offset): Rename from
	local_plt_offset.
	* output.cc (Output_data_got::Got_entry::write): Change object to
	Relobj.  Use local_symbol_value.
	(Output_data_got::add_global_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_with_rela): Remove.  Change all
	callers to use add_global_with_rel.
	(Output_data_got::add_global_pair_with_rel): Change rel_dyn to
	Output_data_reloc_generic*.  Use add_global_generic.
	(Output_data_got::add_global_pair_with_rela): Remove.  Change all
	callers to use add_global_pair_with_rel.
	(Output_data_got::add_local): Change object to Relobj*.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Change object to Relobj*,
	change rel_dyn to Output_data_reloc_generic*.  Use
	add_local_generic.
	(Output_data_got::add_local_with_rela): Remove.  Change all
	callers to use all_local_with_rel.
	(Output_data_got::add_local_pair_with_rel): Change object to
	Relobj*, change rel_dyn to Output_data_reloc_generic*.  Use
	add_output_section_generic.
	(Output_data_got::add_local_pair_with_rela): Remove.  Change all
	callers to use add_local_pair_with_rel.
	(Output_data_got::reserve_local): Change object to Relobj*.
	* output.h: (class Output_data_reloc_generic): Add pure virtual
	declarations for add_global_generic, add_local_generic,
	add_output_section_generic.
	(class Output_data_reloc) [SHT_REL, SHT_RELA]: Implement new
	functions for Output_data_reloc_generic.  Update declarations for
	changes listed in output.cc.
	(class Output_data_got): Change template parameter to got_size.
	Don't define Rel_dyn or Rela_dyn.  Update declarations per above.
	* incremental.h (Sized_relobj_incr::do_local_symbol_value): New
	function.
	(Sized_relobj_incr::do_local_plt_offset): New function.
	* copy-relocs.cc (Copy_relocs::Copy_reloc_entry::emit): Call
	add_global_generic.
@
text
@d2154 22
d2177 1
a2177 1
class Output_data_got : public Output_section_data_build
d2183 1
a2183 1
    : Output_section_data_build(Output_data::default_alignment_for_size(got_size)),
d2188 2
a2189 2
    : Output_section_data_build(data_size,
				Output_data::default_alignment_for_size(got_size)),
a2255 5
  // Reserve a slot in the GOT.
  void
  reserve_slot(unsigned int i)
  { this->free_list_.remove(i * got_size / 8, (i + 1) * got_size / 8); }

d2275 5
@


1.131
log
@	* output.h (Output_data_reloc_generic::add): Only call
	add_dynamic_reloc if this is a dynamic reloc section.
@
text
@d1400 49
a1569 2
  // These are to simplify the Copy_relocs class.

d1571 2
a1572 2
  add_global(Symbol* gsym, unsigned int type, Output_data* od, Address address,
	     Address addend)
d1575 3
a1577 1
    this->add_global(gsym, type, od, address);
d1581 3
a1583 3
  add_global(Symbol* gsym, unsigned int type, Output_data* od,
             Sized_relobj<size, big_endian>* relobj,
	     unsigned int shndx, Address address, Address addend)
d1586 5
a1590 1
    this->add_global(gsym, type, od, relobj, shndx, address);
d1648 26
d1753 23
d1838 23
d1918 26
d2029 23
d2151 2
a2152 1
// needed.
d2154 1
a2154 1
template<int size, bool big_endian>
d2158 1
a2158 3
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Valtype;
  typedef Output_data_reloc<elfcpp::SHT_REL, true, size, big_endian> Rel_dyn;
  typedef Output_data_reloc<elfcpp::SHT_RELA, true, size, big_endian> Rela_dyn;
d2161 1
a2161 1
    : Output_section_data_build(Output_data::default_alignment_for_size(size)),
d2167 1
a2167 1
				Output_data::default_alignment_for_size(size)),
d2172 1
a2172 1
    this->entries_.resize(data_size / (size / 8));
d2190 1
a2190 5
                      Rel_dyn* rel_dyn, unsigned int r_type);

  void
  add_global_with_rela(Symbol* gsym, unsigned int got_type,
                       Rela_dyn* rela_dyn, unsigned int r_type);
d2196 2
a2197 7
                           Rel_dyn* rel_dyn, unsigned int r_type_1,
                           unsigned int r_type_2);

  void
  add_global_pair_with_rela(Symbol* gsym, unsigned int got_type,
                            Rela_dyn* rela_dyn, unsigned int r_type_1,
                            unsigned int r_type_2);
d2203 1
a2203 2
  add_local(Sized_relobj_file<size, big_endian>* object, unsigned int sym_index,
            unsigned int got_type);
d2208 1
a2208 3
  add_local_plt(Sized_relobj_file<size, big_endian>* object,
		unsigned int sym_index,
		unsigned int got_type);
d2213 3
a2215 8
  add_local_with_rel(Sized_relobj_file<size, big_endian>* object,
                     unsigned int sym_index, unsigned int got_type,
                     Rel_dyn* rel_dyn, unsigned int r_type);

  void
  add_local_with_rela(Sized_relobj_file<size, big_endian>* object,
                      unsigned int sym_index, unsigned int got_type,
                      Rela_dyn* rela_dyn, unsigned int r_type);
d2220 3
a2222 9
  add_local_pair_with_rel(Sized_relobj_file<size, big_endian>* object,
                          unsigned int sym_index, unsigned int shndx,
                          unsigned int got_type, Rel_dyn* rel_dyn,
                          unsigned int r_type_1, unsigned int r_type_2);

  void
  add_local_pair_with_rela(Sized_relobj_file<size, big_endian>* object,
                          unsigned int sym_index, unsigned int shndx,
                          unsigned int got_type, Rela_dyn* rela_dyn,
d2237 1
a2237 1
  { this->free_list_.remove(i * size / 8, (i + 1) * size / 8); }
d2241 2
a2242 2
  reserve_local(unsigned int i, Sized_relobj<size, big_endian>* object,
		unsigned int sym_index, unsigned int got_type);
d2274 2
a2275 2
    Got_entry(Sized_relobj_file<size, big_endian>* object,
              unsigned int local_sym_index, bool use_plt_offset)
d2306 1
a2306 1
      Sized_relobj_file<size, big_endian>* object;
d2332 1
a2332 1
  { return i * (size / 8); }
@


1.130
log
@	PR gold/13249
	* gold/output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* gold/output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* gold/x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.
@
text
@d1461 2
a1462 1
    od->add_dynamic_reloc();
@


1.129
log
@
2011-09-29 Sriraman Tallam  <tmsriram@@google.com>

	* layout.h (section_order_map_): New member.
	(get_section_order_map): New member function.
	* output.cc (Output_section::add_input_section): Check for patterns
	only when --section-ordering-file is specified.
	* gold.cc (queue_middle_tasks): Delay updating order of sections till
	output_sections have been formed.
	* layout.cc (Layout_Layout): Initialize section_order_map_.
	* plugin.cc (update_section_order): Store order in order_map. Do not
	update the order.
	* testsuite/Makefile.am: Add test case for plugin_final_layout.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_section_order.c: New file.
	* testsuite/plugin_final_layout.cc: New file.
	* testsuite/plugin_final_layout.sh: New file.
@
text
@d1036 2
a1037 1
               bool is_symbolless, bool is_section_symbol);
d1042 2
a1043 1
               bool is_symbolless, bool is_section_symbol);
d1221 1
a1221 1
  unsigned int type_ : 29;
d1229 4
d1277 2
a1278 1
	       bool is_symbolless, bool is_section_symbol)
d1280 1
a1280 1
           is_symbolless, is_section_symbol),
d1288 2
a1289 1
	       bool is_symbolless, bool is_section_symbol)
d1291 1
a1291 1
           is_symbolless, is_section_symbol),
d1582 1
a1582 1
                                    address, false, false, false));
d1591 1
a1591 1
				    address, false, false, false));
d1602 1
a1602 1
                                    address, true, true, false));
d1611 1
a1611 1
				    address, true, true, false));
d1623 1
a1623 1
                                    address, false, true, false));
d1633 1
a1633 1
				    address, false, true, false));
d1646 1
a1646 1
                                    address, false, false, true));
d1655 1
a1655 1
                                    address, false, false, true));
d1778 1
a1778 1
				    addend, false, false, false));
d1788 2
a1789 1
                                    address, addend, false, false, false));
d1797 2
a1798 1
	             Output_data* od, Address address, Addend addend)
d1801 2
a1802 1
				    addend, true, true, false));
d1809 1
a1809 1
	             Addend addend)
d1812 2
a1813 1
                                    address, addend, true, true, false));
d1825 1
a1825 1
				    addend, false, true, false));
d1835 2
a1836 1
                                    address, addend, false, true, false));
d1849 1
a1849 1
				    addend, false, false, true));
d1859 2
a1860 1
                                    address, addend, false, false, true));
@


1.128
log
@	* layout.cc (Free_list::allocate): Provide guarantee of minimum
	remaining hole size when allocating.
	(Layout::make_output_section): Set fill methods for debug sections.
	* layout.h (Free_list::Free_list_node): Move from private to
	public.
	(Free_list::set_min_hole_size): New function.
	(Free_list::begin, Free_list::end): New functions.
	(Free_list::min_hole_): New data member.
	* output.cc: Include dwarf.h.
	(Output_fill_debug_info::do_minimum_hole_size): New function.
	(Output_fill_debug_info::do_write): New function.
	(Output_fill_debug_line::do_minimum_hole_size): New function.
	(Output_fill_debug_line::do_write): New function.
	(Output_section::Output_section): Initialize new data member.
	(Output_section::set_final_data_size): Ensure patch space is larger
	than minimum hole size.
	(Output_section::do_write): Fill holes in debug sections.
	* output.h (Output_fill): New class.
	(Output_fill_debug_info): New class.
	(Output_fill_debug_line): New class.
	(Output_section::set_free_space_fill): New function.
	(Output_section::free_space_fill_): New data member.
	* testsuite/Makefile.am (incremental_test_3): Add
	--incremental-patch option.
	(incremental_test_4): Likewise.
	(incremental_test_5): Likewise.
	(incremental_test_6): Likewise.
	(incremental_copy_test): Likewise.
	(incremental_common_test_1): Likewise.
	* testsuite/Makefile.in: Regenerate.
@
text
@d2764 1
a2764 1
  update_section_layout(const Section_layout_order& order_map);
@


1.128.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d1036 1
a1036 2
               bool is_symbolless, bool is_section_symbol,
               bool use_plt_offset);
d1041 1
a1041 2
               bool is_symbolless, bool is_section_symbol,
               bool use_plt_offset);
d1219 1
a1219 1
  unsigned int type_ : 28;
a1226 4
  // True if the addend should be the PLT offset.  This is used only
  // for RELATIVE relocations to local symbols.
  // (Used only for RELA, but stored here for space.)
  bool use_plt_offset_ : 1;
d1271 1
a1271 2
	       bool is_symbolless, bool is_section_symbol,
	       bool use_plt_offset)
d1273 1
a1273 1
           is_symbolless, is_section_symbol, use_plt_offset),
d1281 1
a1281 2
	       bool is_symbolless, bool is_section_symbol,
	       bool use_plt_offset)
d1283 1
a1283 1
           is_symbolless, is_section_symbol, use_plt_offset),
d1574 1
a1574 1
                                    address, false, false, false, false));
d1583 1
a1583 1
				    address, false, false, false, false));
d1594 1
a1594 1
                                    address, true, true, false, false));
d1603 1
a1603 1
				    address, true, true, false, false));
d1615 1
a1615 1
                                    address, false, true, false, false));
d1625 1
a1625 1
				    address, false, true, false, false));
d1638 1
a1638 1
                                    address, false, false, true, false));
d1647 1
a1647 1
                                    address, false, false, true, false));
d1770 1
a1770 1
				    addend, false, false, false, false));
d1780 1
a1780 2
                                    address, addend, false, false, false,
                                    false));
d1788 1
a1788 2
	             Output_data* od, Address address, Addend addend,
	             bool use_plt_offset)
d1791 1
a1791 2
				    addend, true, true, false,
				    use_plt_offset));
d1798 1
a1798 1
	             Addend addend, bool use_plt_offset)
d1801 1
a1801 2
                                    address, addend, true, true, false,
                                    use_plt_offset));
d1813 1
a1813 1
				    addend, false, true, false, false));
d1823 1
a1823 2
                                    address, addend, false, true, false,
                                    false));
d1836 1
a1836 1
				    addend, false, false, true, false));
d1846 1
a1846 2
                                    address, addend, false, false, true,
                                    false));
@


1.127
log
@2011-07-13  Sriraman Tallam  <tmsriram@@google.com>

	* plugin-api.h
	(ld_plugin_section): New struct.
	(ld_plugin_get_section_count): New typedef.
	(ld_plugin_get_section_type): New typedef.
	(ld_plugin_get_section_name): New typedef.
	(ld_plugin_get_section_contents): New typedef.
	(ld_plugin_update_section_order): New typedef.
	(ld_plugin_allow_section_ordering): New typedef.
	(LDPT_GET_SECTION_COUNT): New enum value.
	(LDPT_GET_SECTION_TYPE): New enum value.
	(LDPT_GET_SECTION_NAME): New enum value.
	(LDPT_GET_SECTION_CONTENTS): New enum value.
	(LDPT_UPDATE_SECTION_ORDER): New enum value.
	(LDPT_ALLOW_SECTION_ORDERING): New enum value.
	(tv_get_section_count): New struct members.
	(tv_get_section_type): New struct members.
	(tv_get_section_name): New struct members.
	(tv_get_section_contents): New struct members.
	(tv_update_section_order): New struct members.
	(tv_allow_section_ordering): New struct members.
	* archive.cc (Archive::get_elf_object_for_member): Add extra parameter
	to claim_file call.
	* layout.cc (Layout::Layout): Initialize section_ordering_specified_,
	input_section_position_, and input_section_glob_.
	(read_layout_from_file): Call function section_ordering_specified.
	* layout.h (is_section_ordering_specified): New function.
	(section_ordering_specified): New function.
	(section_ordering_specified_): New boolean member.
	* main.cc(main): Call load_plugins after layout object is defined.
	* output.cc (Output_section::add_input_section): Use
	function section_ordering_specified to check if section ordering is
	needed.
	* output.cc (Output_section::add_relaxed_input_section): Use
	function section_ordering_specified to check if section ordering is
	needed.
	(Output_section::update_section_layout): New function.
	(Output_section::sort_attached_input_sections): Check if input section
	must be reordered.
	* output.h (Output_section::update_section_layout): New function.
	* plugin.cc (get_section_count): New function.
	(get_section_type): New function.
	(get_section_name): New function.
	(get_section_contents): New function.
	(update_section_order): New function.
	(allow_section_ordering): New function.
	(Plugin::load): Add the new interfaces to the transfer vector.
	(Plugin_manager::load_plugins): New parameter.
	(Plugin_manager::all_symbols_read): New parameter.
	(Plugin_manager::claim_file): New parameter. Save the elf object for
	unclaimed objects.
	(Plugin_manager::get_elf_object): New function.
	(Plugin_manager::get_view): Change to directly use the bool to check
	if get_view is called from claim_file_hook.
	* plugin.h (input_objects): New function
	(Plugin__manager::load_plugins): New parameter.
	(Plugin_manager::claim_file): New parameter.
	(Plugin_manager::get_elf_object): New function.
	(Plugin_manager::in_claim_file_handler): New function.
	(Plugin_manager::in_claim_file_handler_): New member.
	(layout): New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Call the claim_file
	handler with an extra parameter. Make the elf object before calling
	claim_file handler.
	* testsuite/plugin_test.c (get_section_count): New function pointer.
	(get_section_type): New function pointer.
	(get_section_name): New function pointer.
	(get_section_contents): New function pointer.
	(update_section_order): New function pointer.
	(allow_section_ordering): New function pointer.
	(onload): Check if the new interfaces exist.
@
text
@d2618 93
d3534 9
d4018 2
@


1.126
log
@	* incremental.cc (Incremental_inputs::report_command_line): Ignore
	--incremental-patch option.
	* layout.cc (Free_list::allocate): Extend allocation beyond original
	end if enabled.
	(Layout::make_output_section): Mark sections that should get
	patch space.
	* options.cc (parse_percent): New function.
	* options.h (parse_percent): New function.
	(DEFINE_percent): New macro.
	(General_options): Add --incremental-patch option.
	* output.cc (Output_section::Output_section): Initialize new data
	members.
	(Output_section::add_input_section): Print section name when out
	of patch space.
	(Output_section::add_output_section_data): Likewise.
	(Output_section::set_final_data_size): Add patch space when
	doing --incremental-full.
	(Output_section::do_reset_address_and_file_offset): Remove patch
	space.
	(Output_segment::set_section_list_addresses): Print debug output
	only if --incremental-update.
	* output.h (Output_section::set_is_patch_space_allowed): New function.
	(Output_section::is_patch_space_allowed_): New data member.
	(Output_section::patch_space_): New data member.
	* parameters.cc (Parameters::incremental_full): New function.
	* parameters.h (Parameters::incremental_full): New function
	* testsuite/Makefile.am (incremental_test_2): Add test for
	--incremental-patch option.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/two_file_test_1_v1.cc (t1, t2, t3): Add comments.
	(t18): Remove function body.
@
text
@d2668 5
@


1.125
log
@	* common.cc (Symbol_table::do_allocate_commons_list): For incremental
	update, allocate common from bss section's free list.
	* incremental-dump.cc (dump_incremental_inputs): Print flag for
	linker-defined symbols.
	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Skip GOT and PLT entries that are no longer referenced.
	(Output_section_incremental_inputs::write_info_blocks): Mark
	linker-defined symbols.
	(Sized_incr_relobj::do_add_symbols): Process linker-defined symbols.
	* output.cc (Output_section::allocate): New function.
	* output.h (Output_section::allocate): New function.
	* resolve.cc (Symbol_table::report_resolve_problem): Add case for
	linker-defined symbols.
	(Symbol::override_base_with_special): Copy is_predefined_ flag.
	* symtab.cc (Symbol::init_fields): Initialize is_predefined_ flag.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* symtab.h (Symbol::is_predefined): New function.
	(Symbol::init_base_output_data): Add is_predefined parameter.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::is_predefined_): New data member.
	(Sized_symbol::init_output_data): Add is_predefined parameter.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(enum Symbol_table::Defined): Add INCREMENTAL_BASE.
@
text
@d3430 6
d3899 2
d3911 2
@


1.124
log
@	* archive.cc (Library_base::should_include_member): Pull in object
	from archive if it defines the entry symbol.
	* parameters.cc (Parameters::entry): New function.
	* parameters.h (class Parameters): Declare entry.
	* output.h (class Output_file_header): Remove entry_ field.
	* output.cc (Output_file_header::Output_file_header): Remove entry
	parameter.  Change all callers.
	(Output_file_header::entry): Use parameters->entry.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (Plugin_hook::run): Likewise.
@
text
@d3435 5
@


1.123
log
@	* gold.cc (queue_initial_tasks): Pass incremental base filename
	to Output_file::open_base_file; don't print error message.
	* incremental-dump.cc (main): Adjust call to
	Output_file::open_for_modification.
	* incremental-dump.cc (main): Likewise.
	* incremental.cc (Incremental_inputs::report_command_line):
	Ignore --incremental-base option when comparing command lines.
	Ignore parameter when given as separate argument.
	* options.h (class General_options): Add --incremental-base.
	* output.cc (Output_file::Output_file):
	(Output_file::open_base_file): Add base_name and writable parameters;
	read base file into new file; print error message here.
	(Output_file::map_no_anonymous): Add writable parameter; adjust all
	callers.
	* output.h (Output_file::open_for_modification): Rename to...
	(Output_file::open_base_file): ...this; add base_name and
	writable parameters; adjust all callers.
	(Output_file::map_no_anonymous): Add writable parameter; adjust all
	callers.
	* testsuite/Makefile.am (incremental_test_4): Test
	--incremental-base.
	* testsuite/Makefile.in: Regenerate.
@
text
@d569 1
a569 2
		     const Output_segment_headers*,
		     const char* entry);
a615 1
  const char* entry_;
@


1.122
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d4191 2
a4192 1
  // thread-unsafe.
d4194 1
a4194 1
  open_for_modification();
d4279 1
a4279 1
  map_no_anonymous();
@


1.121
log
@	* gold.cc (queue_middle_tasks): Process existing GOT/PLT entries.
	* incremental-dump.cc (dump_incremental_inputs): Mask high-order
	bit when checking got_type.
	* incremental.cc (Sized_incremental_binary::setup_readers):
	Store symbol table and string table locations; initialize bit vector
	of file status flags.
	(Sized_incremental_binary::do_reserve_layout): Set bit flag for
	unchanged files.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::get_symtab_view): Use stored locations.
	(Output_section_incremental_inputs::set_final_data_size): Record
	file index for each input file.
	(Output_section_incremental_inputs::write_got_plt): Store file index
	instead of input entry offset for each GOT entry.
	* incremental.h
	(Incremental_input_entry::Incremental_input_entry): Initialize new
	data member.
	(Incremental_input_entry::set_offset): Store file index.
	(Incremental_input_entry::get_file_index): New function.
	(Incremental_input_entry::file_index_): New data member.
	(Incremental_binary::process_got_plt): New function.
	(Incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data members.
	(Sized_incremental_binary::~Sized_incremental_binary): New destructor.
	(Sized_incremental_binary::set_file_is_unchanged): New function.
	(Sized_incremental_binary::file_is_unchanged): New function.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::file_status_): New data member.
	(Sized_incremental_binary::main_symtab_loc_): New data member.
	(Sized_incremental_binary::main_strtab_loc_): New data member.
	* output.cc (Output_data_got::Got_entry::write): Add case
	RESERVED_CODE.
	(Output_data_got::add_global): Call add_got_entry.
	(Output_data_got::add_global_plt): Likewise.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_global_pair_with_rela): Likewise.
	(Output_data_got::add_local): Call add_got_entry.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_local_pair_with_rela): Likewise.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_section::add_output_section_data): Edit FIXME.
	* output.h
	(Output_section_data_build::Output_section_data_build): New
	constructor with size parameter.
	(Output_data_space::Output_data_space): Likewise.
	(Output_data_got::Output_data_got): Initialize new data member; new
	constructor with size parameter.
	(Output_data_got::add_constant): Call add_got_entry.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(class Output_data_got::Got_entry): Add RESERVED_CODE.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_data_got::free_list_): New data member.
	* target.h (Sized_target::init_got_plt_for_update): New function.
	(Sized_target::register_global_plt_entry): New function.
	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Initialize new data member; call init; add constructor with PLT count.
	(Output_data_plt_x86_64::init): New function.
	(Output_data_plt_x86_64::add_relocation): New function.
	(Output_data_plt_x86_64::reserve_slot): New function.
	(Output_data_plt_x86_64::free_list_): New data member.
	(Target_x86_64::init_got_plt_for_update): New function.
	(Target_x86_64::register_global_plt_entry): New function.
	(Output_data_plt_x86_64::add_entry): Allocate from free list for
	incremental updates.
	(Output_data_plt_x86_64::add_relocation): New function.
	* testsuite/object_unittest.cc (Object_test): Set default options.
@
text
@d49 2
d1124 10
d1340 6
d1458 3
d1843 3
a1845 3
	             unsigned int input_shndx, unsigned int type,
	             Output_data* od, unsigned int shndx, Address address,
	             Addend addend)
d1934 1
a1934 1
  Output_data_group(Sized_relobj<size, big_endian>* relobj,
d1954 1
a1954 1
  Sized_relobj<size, big_endian>* relobj_;
d2026 1
a2026 1
  add_local(Sized_relobj<size, big_endian>* object, unsigned int sym_index,
d2032 2
a2033 1
  add_local_plt(Sized_relobj<size, big_endian>* object, unsigned int sym_index,
d2039 1
a2039 1
  add_local_with_rel(Sized_relobj<size, big_endian>* object,
d2044 1
a2044 1
  add_local_with_rela(Sized_relobj<size, big_endian>* object,
d2051 1
a2051 1
  add_local_pair_with_rel(Sized_relobj<size, big_endian>* object,
d2057 1
a2057 1
  add_local_pair_with_rela(Sized_relobj<size, big_endian>* object,
d2071 6
a2076 1
  // Reserve a slot in the GOT for a local symbol or the second slot of a pair.
d2078 2
a2079 1
  reserve_slot(unsigned int i);
d2083 1
a2083 1
  reserve_slot_for_global(unsigned int i, Symbol* gsym, unsigned int got_type);
d2111 1
a2111 1
    Got_entry(Sized_relobj<size, big_endian>* object,
d2143 1
a2143 1
      Sized_relobj<size, big_endian>* object;
d2639 1
a2639 1
  add_input_section(Layout* layout, Sized_relobj<size, big_endian>* object,
@


1.120
log
@	* configure.ac: Check for sys/mman.h and mmap.  Check for mremap
	with MREMAP_MAYMOVE.
	* output.h (class Output_file): Add map_is_allocated_ field.
	* output.cc: Only #include <sys/mman.h> if it exists.  If mmap is
	not available, provide stubs.  If mremap is not available, #define
	it to gold_mremap.
	(MREMAP_MAYMOVE): Define if not defined.
	(Output_file::Output_file): Initialize map_is_allocated_.
	(Output_file::resize): Check map_is_allocated_.
	(Output_file::map_anonymous): If mmap fails, use malloc.
	(Output_file::unmap): Don't do anything for an anonymous map.
	* fileread.cc: Only #include <sys/mman.h> if it exists.  If mmap
	is not available, provide stubs.
	(File_read::View::~View): Use free rather than delete[].
	(File_read::make_view): Use malloc rather than new[].  If mmap
	fails, use malloc.
	(File_read::find_or_make_view): Use malloc rather than new[].
	* gold.h: Remove HAVE_REMAP code.
	* mremap.c: #include <errno.h>.  Only #include <sys/mman.h> if it
	exists.  Rename mremap to gold_mremap.  If mmap is not available
	don't do anything.
	* configure, config.in: Rebuild.
@
text
@d767 4
d897 6
d1955 1
a1955 1
      entries_()
d1958 11
d2045 2
a2046 3
    this->entries_.push_back(Got_entry(constant));
    this->set_got_size();
    return this->last_got_offset();
d2049 8
d2074 1
a2074 1
      : local_sym_index_(CONSTANT_CODE), use_plt_offset_(false)
d2089 1
d2108 2
a2109 1
      CONSTANT_CODE = 0x7ffffffe
d2130 8
d2155 4
@


1.119
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d4224 2
@


1.118
log
@	* output.h (Output_data_reloc::add_output_section): Pass OD instead
	of OS to this->add.  Add OD parameter to second form of the function.
@
text
@d84 5
d201 11
d339 11
d492 5
a766 5
  // Get the current data size.
  off_t
  current_data_size() const
  { return this->current_data_size_for_child(); }

d948 6
d3071 4
a3297 5
  // Get the current size of the output section.
  off_t
  current_data_size() const
  { return this->current_data_size_for_child(); }

d3352 15
d3393 7
d3818 2
d3827 3
d3972 1
a3972 1
  set_section_addresses(const Layout*, bool reset, uint64_t addr,
d4032 1
a4032 1
  set_section_list_addresses(const Layout*, bool reset, Output_data_list*,
@


1.117
log
@	* output.h (Output_segment::set_section_addresses): Pass increase_relro
	by reference; adjust all callers.
	* output.cc (Output_segment::set_section_addresses): Adjust references
	to increase_relro. Add padding to *increase_relro when ORDER_RELRO_LAST
	list is empty.
	(Output_segment::set_offset): Assert if PT_GNU_RELRO segment does not
	end at page boundary.
@
text
@d1792 1
a1792 1
  { this->add(os, Output_reloc_type(os, type, od, address, addend)); }
d1795 1
a1795 1
  add_output_section(Output_section* os, unsigned int type,
d1798 1
a1798 1
  { this->add(os, Output_reloc_type(os, type, relobj, shndx, address,
@


1.116
log
@2010-10-29  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_outout_section::fix_exidx_coverage): Adjust call to
	Output_section::add_relaxed_input_section.
	* output.cc (Output_section::add_relaxed_input_section): Add new
	arguments LAYOUT and NAME.  Set section order index.
	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Copy section order index.
	* output.h (Output_section::add_relaxed_input_section): Add new
	arguments LAYOUT and NAME.
@
text
@d3914 1
a3914 1
			unsigned int increase_relro, bool* has_relro,
@


1.116.2.1
log
@Merge from trunk:

Changes by:	ccoutant@@sourceware.org	2010-11-16 19:18:31

Modified files:
	gold           : ChangeLog layout.cc output.cc output.h

Log message:
	* output.h (Output_segment::set_section_addresses): Pass increase_relro
	by reference; adjust all callers.
	* output.cc (Output_segment::set_section_addresses): Adjust references
	to increase_relro. Add padding to *increase_relro when ORDER_RELRO_LAST
	list is empty.
	(Output_segment::set_offset): Assert if PT_GNU_RELRO segment does not
	end at page boundary.
@
text
@d3914 1
a3914 1
			unsigned int* increase_relro, bool* has_relro,
@


1.116.2.2
log
@	* output.h (Output_data_reloc::add_output_section): Pass OD instead
	of OS to this->add.  Add OD parameter to second form of the function.
@
text
@d1792 1
a1792 1
  { this->add(od, Output_reloc_type(os, type, od, address, addend)); }
d1795 1
a1795 1
  add_output_section(Output_section* os, unsigned int type, Output_data* od,
d1798 1
a1798 1
  { this->add(od, Output_reloc_type(os, type, relobj, shndx, address,
@


1.115
log
@	* output.h (Output_segment::set_section_addresses): Change function
	signature.  Update all callers.
	* output.cc (Output_segment::is_first_section_relro): Ignore TLS
	sections.
	(Output_segment::set_section_addresses): Align after last TLS
	section.  Add padding before last relro section instead of after.
@
text
@d2545 2
a2546 1
  // Add a relaxed input section PORIS to this output section.
d2548 3
a2550 1
  add_relaxed_input_section(Output_relaxed_input_section* poris);
@


1.114
log
@	* layout.cc (Layout::set_segment_offsets): Don't try to realign data
	segment that has been aligned for relro.
	* output.cc (Output_segment::set_section_addresses): Change signature;
	adjust all callers.  Account for alignment when totalling
	size of relro sections.
	* output.h (Output_segment::set_section_addresses): Change signature.
	* testsuite/Makefile.am (relro_test.sh, relro_test.stdout): New
	targets.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/relro_test.cc: Add alignment attributes to test proper
	alignment of relro sections when padding is necessary.
	* testsuite/relro_test.sh: New script.
@
text
@d3911 1
a3911 1
			unsigned int* pincrease_relro, bool* has_relro,
@


1.113
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d3911 2
a3912 2
			unsigned int increase_relro, off_t* poff,
			unsigned int* pshndx);
@


1.112
log
@	PR 10893
	* i386.cc (class Output_data_plt_i386): Update declarations.
	Define Global_ifunc and Local_ifunc types.  Add global_ifuncs_ and
	local_ifuncs_ fields.
	(Target_i386::do_plt_section_for_global): New function.
	(Target_i386::do_plt_section_for_local): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Add symtab
	parameter; change all callers.  Initialize global_ifuncs_ and
	local_ifuncs_.  If doing a static link define __rel_iplt_start and
	__rel_iplt_end.
	(Output_data_plt_i386::add_entry): Handle IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): New function.
	(Output_data_plt_i386::do_write): Fix GOT entries for IFUNC
	symbols.
	(Target_i386::make_plt_section): New function, broken out of
	make_plt_entry.  Set sh_info field of .rel.plt to point to .plt.
	(Target_i386::make_plt_entry): Call make_plt_section.
	(Target_i386::make_local_ifunc_plt_entry): New function.
	(Target_i386::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_i386::Scan::local): Handle IFUNC symbols.  Add
	R_386_IRELATIVE to switch.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocatable_size_for_reloc): Add R_386_IRELATIVE to
	switch.
	* x86_64.cc (class Output_data_plt_x86_64): Update declarations.
	(Target_x86_64::do_plt_section_for_global): New function.
	(Target_x86_64::do_plt_section_for_local): New function.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Add symtab
	parameter; change all callers.  If doing a static link define
	__rela_iplt_start and __rela_iplt_end.
	(Output_data_plt_x86_64::add_entry): Handle IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): New function.
	(Target_x86_64::make_plt_section): Set sh_info field of .rel.plt
	to point to .plt.
	(Target_x86_64::make_local_ifunc_plt_entry): New function.
	(Target_x86_64::Scan::check_non_pic): Add R_X86_64_IRELATIVE to
	switch.
	(Target_x86_64::Scan::reloc_needs_iplt_for_ifunc): New function.
	(Target_x86_64::Scan::local): Handle IFUNC symbols.  Add
	R_X86_64_IRELATIVE to switch.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocatable_size_for_reloc): Add R_X86_64_IRELATIVE to
	switch.
	* target.h (class Target): Add plt_section_for_global and
	plt_section_for_local functions.  Add do_plt_section_for_global
	and do_plt_section_for_local virtual functions.
	* symtab.h (Symbol::needs_plt_entry): Handle IFUNC symbol.  Add
	clarifying comments.
	(Symbol::use_plt_offset): Handle IFUNC symbol.
	* object.cc (Sized_relobj::Sized_relobj): Initialize
	local_plt_offsets_.
	(Sized_relobj::local_has_plt_offset): New function.
	(Sized_relobj::local_plt_offset): New function.
	(Sized_relobj::set_local_plt_offset): New function.
	(Sized_relobj::do_count): Handle IFUNC symbol.
	* object.h (class Symbol_value): Add is_ifunc_symbol_ field.  Take
	a bit away from input_shndx_ field.  Add set_is_func_symbol and
	is_ifunc_symbol functions.
	(class Sized_relobj): Update declarations.  Remove Tls_got_entry
	and Local_tls_got_offsets.  Define Local_plt_offsets.  Add
	local_plt_offsets_ field.
	(Sized_relobj::clear_local_symbols): Clear local_plt_offsets_.
	* output.h (class Output_section_data): Add non-const
	output_section function.
	(class Output_data_got): Update declarations.
	(class Output_data_got::Got_entry): Add use_plt_offset_ field.
	Add use_plt_offset parameter to global and local constructors.
	Change all callers.  Change local_sym_index_ field to 31 bits.
	Change GSYM_CODE and CONSTANT_CODE accordingly.
	* output.cc (Output_data_reloc_base::do_adjust_output_section): If
	doing a static link don't set sh_link field.
	(Output_data_got::Got_entry::write): Use PLT offset if
	appropriate.
	(Output_data_got::add_global_plt): New function.
	(Output_data_got::add_local_plt): New function.
	* target-reloc.h (relocate_section): Handle IFUNC symbol.
	* defstd.cc (in_section): Remove entries for __rel_iplt_start,
	__rel_iplt_end, __rela_iplt_start, and __rela_iplt_end.
	* configure.ac: Set IFUNC automake conditional for glibc >= 2.11.
	* testsuite/Makefile.am: Add a bunch of IFUNC tests, all within
	IFUNC conditional.
	* testsuite/ifunc-sel.h: New file.
	* testsuite/ifuncmain1.c: New file.
	* testsuite/ifuncmain1vis.c: New file.
	* testsuite/ifuncmod1.c: New file.
	* testsuite/ifuncdep2.c: New file.
	* testsuite/ifuncmain2.c: New file.
	* testsuite/ifuncmain3.c: New file.
	* testsuite/ifuncmod3.c: New file.
	* testsuite/ifuncmain4.c: New file.
	* testsuite/ifuncmain5.c: New file.
	* testsuite/ifuncmod5.c: New file.
	* testsuite/ifuncmain6pie.c: New file.
	* testsuite/ifuncmod6.c: New file.
	* testsuite/ifuncmain7.c: New file.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d635 1
a635 1
		section_offset_type *poutput) const
d1376 1
a1376 1
  do_adjust_output_section(Output_section *os);
d1390 1
a1390 1
  add(Output_data *od, const Output_reloc_type& reloc)
d2537 1
a2537 1
                    unsigned int shndx, const char *name,
d2988 1
a2988 1
    Input_section(Output_relaxed_input_section *psection)
d3120 1
a3120 1
      Output_section_data *posd = 
d3159 1
a3159 1
		  section_offset_type *poutput) const;
@


1.111
log
@2010-08-03  Ian Lance Taylor  <iant@@google.com>

	PR 11805
	* layout.h (enum Output_section_order): Define.
	(class Layout): Update declarations.
	* layout.cc (Layout::get_output_section): Add order parameter.
	Remove is_interp, is_dynamic_linker_section, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.  Set order.
	(Layout::default_section_order): New function.
	(Layout::layout_eh_frame): Call add_output_section_to_nonload.
	* output.cc (Output_section::Output_section): Initialize order_.
	Don't initialize deleted fields.
	(Output_segment::Output_segment): Don't initialize deleted
	fields.
	(Output_segment::add_output_section_to_load): New function
	replacing add_output_section.  Change all callers to call this or
	add_output_section_to_nonload.
	(Output_segment::add_output_section_to_nonload): New function.
	(Output_segment::remove_output_section): Rewrite.
	(Output_segment::add_initial_output_data): Likewise.
	(Output_segment::has_any_data_sections): Likewise.
	(Output_segment::is_first_section_relro): Likewise.
	(Output_segment::maximum_alignment): Likewise.
	(Output_segment::has_dynamic_reloc): New function replacing
	dynamic_reloc_count.  Change all callers.
	(Output_segment::has_dynamic_reloc_list): New function replacing
	dynamic_reloc_count_list.  Change all callers.
	(Output_segment::set_section_addresses): Rewrite.
	(Output_segment::set_offset): Rewrite.
	(Output_segment::find_first_and_last_list): Remove.
	(Output_segment::set_tls_offsets): Rewrite.
	(Output_segment::first_section_load_address): Likewise.
	(Output_segment::output_section_count): Likewise.
	(Output_segment::section_with_lowest_load_address): Likewise.
	(Output_segment::write_section_headers): Likewise.
	(Output_segment::print_sections_to_map): Likewise.
	* output.h (class Output_data): Remove dynamic_reloc_count_
	field.  Add has_dynamic_reloc_ field.  Make bools into bitfields.
	(Output_data::add_dynamic_reloc): Rewrite.
	(Output_data::has_dynamic_reloc): New function.
	(Output_data::dynamic_reloc_count): Remove.
	(class Output_section): Add order_ field.  Remvoe is_relro_local_,
	is_last_relro_, is_first_non_relro_, is_interp_,
	is_dynamic_linker_section_ fields.  Add order and set_order
	functions.  Remove is_relro_local, set_is_relro_local,
	is_last_relro, set_is_last_relro, is_first_non_relro,
	set_is_first_non_relro functions, is_interp, set_is_interp,
	is_dynamic_linker_section, and set_is_dynamic_linker_section
	functions.
	(class Output_segment): Change Output_data_list from std::list to
	std:;vector.  Add output_lists_ field.  Remove output_data_ and
	output_bss_ fields.  Update declarations.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d608 4
d1920 5
d1954 6
d2013 1
a2013 1
      : local_sym_index_(CONSTANT_CODE)
d2017 2
a2018 2
    explicit Got_entry(Symbol* gsym)
      : local_sym_index_(GSYM_CODE)
d2023 2
a2024 2
              unsigned int local_sym_index)
      : local_sym_index_(local_sym_index)
d2027 2
a2028 1
		  && local_sym_index != CONSTANT_CODE);
d2035 1
a2035 1
      : local_sym_index_(CONSTANT_CODE)
d2045 2
a2046 2
      GSYM_CODE = -1U,
      CONSTANT_CODE = -2U
d2060 3
a2062 1
    unsigned int local_sym_index_;
@


1.110
log
@	PR 11866
	* output.cc (Output_segment::set_offset): Search for the first and
	last sections rather than assuming that the list is in order.
	(Output_segment::find_first_and_last_list): New function.
	* output.h (class Output_segment): Update declarations.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_strip_test.
	(relro_strip_test_SOURCES): New variable.
	(relro_strip_test_DEPENDENCIES): New variable.
	(relro_strip_test_LDFLAGS): New variable.
	(relro_strip_test_LDADD): New variable.
	(relro_strip_test.so): New target.
@
text
@d59 1
a59 1
      dynamic_reloc_count_(0)
d236 1
a236 1
  // Count the number of dynamic relocations applied to this section.
d239 1
a239 1
  { ++this->dynamic_reloc_count_; }
d241 4
a244 4
  // Return the number of dynamic relocations applied to this section.
  unsigned int
  dynamic_reloc_count() const
  { return this->dynamic_reloc_count_; }
d427 1
a427 1
  bool is_address_valid_;
d429 1
a429 1
  bool is_data_size_valid_;
d431 1
a431 1
  bool is_offset_valid_;
d433 3
a435 3
  bool is_data_size_fixed_;
  // Count of dynamic relocations applied to this section.
  unsigned int dynamic_reloc_count_;
d2764 11
a2791 40
  // True if this section holds relro local data--relro data for which
  // the dynamic relocations are all RELATIVE relocations.
  bool
  is_relro_local() const
  { return this->is_relro_local_; }

  // Record that this section holds relro local data.
  void
  set_is_relro_local()
  { this->is_relro_local_ = true; }

  // True if this must be the last relro section.
  bool
  is_last_relro() const
  { return this->is_last_relro_; }

  // Record that this must be the last relro section.
  void
  set_is_last_relro()
  {
    gold_assert(this->is_relro_);
    this->is_last_relro_ = true;
  }

  // True if this must be the first section following the relro sections.
  bool
  is_first_non_relro() const
  {
    gold_assert(!this->is_relro_);
    return this->is_first_non_relro_;
  }

  // Record that this must be the first non-relro section.
  void
  set_is_first_non_relro()
  {
    gold_assert(!this->is_relro_);
    this->is_first_non_relro_ = true;
  }

a2818 21
  // True if this is the .interp section which goes into the PT_INTERP
  // segment.
  bool
  is_interp() const
  { return this->is_interp_; }

  // Record that this is the interp section.
  void
  set_is_interp()
  { this->is_interp_ = true; }

  // True if this is a section used by the dynamic linker.
  bool
  is_dynamic_linker_section() const
  { return this->is_dynamic_linker_section_; }

  // Record that this is a section used by the dynamic linker.
  void
  set_is_dynamic_linker_section()
  { this->is_dynamic_linker_section_ = true; }

d3660 2
a3728 6
  // True if this section holds relro local data.
  bool is_relro_local_ : 1;
  // True if this must be the last relro section.
  bool is_last_relro_ : 1;
  // True if this must be the first section after the relro sections.
  bool is_first_non_relro_ : 1;
a3732 5
  // True if this is the .interp section going into the PT_INTERP
  // segment.
  bool is_interp_ : 1;
  // True if this is section is read by the dynamic linker.
  bool is_dynamic_linker_section_ : 1;
d3818 8
a3825 3
  // Add the Output_section OS to this segment.  SEG_FLAGS is the
  // segment flags to use.  DO_SORT is true if we should sort the
  // placement of the input section for more efficient generated code.
d3827 2
a3828 2
  add_output_section(Output_section* os, elfcpp::Elf_Word seg_flags,
		     bool do_sort);
d3843 1
a3843 2
  has_any_data_sections() const
  { return !this->output_data_.empty(); }
d3845 3
a3847 3
  // Return the number of dynamic relocations applied to this segment.
  unsigned int
  dynamic_reloc_count() const;
d3940 1
a3940 1
  typedef std::list<Output_data*> Output_data_list;
d3960 3
a3962 3
  // Return the number of dynamic relocs in an Output_data_list.
  unsigned int
  dynamic_reloc_count_list(const Output_data_list*) const;
d3991 2
a3992 4
  // The list of output data with contents attached to this segment.
  Output_data_list output_data_;
  // The list of output data without contents attached to this segment.
  Output_data_list output_bss_;
@


1.109
log
@2010-07-13  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section::Arm_input_section): For a
	SHT_ARM_EXIDX section, always keeps the input sections.
	(Arm_input_section::set_exidx_section_link): New method.
	(Arm_exidx_input_section::Arm_exidx_input_section): Initialize
	has_errors_ to false.
	(Arm_exidx_input_section::has_errors,
	Arm_exidx_input_section::set_has_errors): New methods.
	(Arm_exidx_input_section::has_errors_): New data member.
	(Arm_relobj::get_exidx_shndx_list): New method.
	(Arm_output_section::append_text_sections_to_list): Do not skip
	section without SHF_EXECINSTR.
	(Arm_output_section::fix_exidx_coverage): Skip input sections with
	errors.
 	(Arm_relobj::make_exidx_input_section): Add new parameter for text
	section header.  Make error messages more verbose.  Check for
	a non-executable section linked to an EXIDX section.
	(Arm_relobj::do_read_symbols): Remove error checking, which has been
	moved to Arm_relobj::make_exidx_input_section.  Add an assertion to
	check that there is no deferred EXIDX section if we exit early.
	Instead of not making an EXIDX section in case of an error, make one
	and set the has_errors flag of it.
	(Target_arm::do_finalize_sections): Fix up links of EXIDX sections
	in a relocatable link.
	(Target_arm::do_relax): Look for the EXIDX output section instead of
	assuming that it is called .ARM.exidx.
 	(Target_arm::fix_exidx_coverage): Add a new parameter for input
	section list.  Do not check for SHF_EXECINSTR section flags but
	skip any input section with errors.
	* output.cc (Output_section::Output_section): Initialize
	always_keeps_input_sections_ to false.
	(Output_section::add_input_section): Check for
	always_keeps_input_sections_.
	*  output.h (Output_section::always_keeps_input_sections,
	Output_section::set_always_keeps_input_sections): New methods.
	(Output_section::always_keeps_input_sections): New data member.
@
text
@d4026 6
@


1.108
log
@	* output.h (Output_section_lookup_maps::add_merge_section):
	Correct check of whether value was inserted.
	(Output_section_lookup_maps::add_merge_input_section): Likewise.
	(Output_section_lookup_maps::add_relaxed_input_section):
	Likewise.
	* arm.cc (Target_arm::got_section): Remove used local os.
	* i386.cc (Target_i386::got_section): Likewise.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* sparc.cc (Target_sparc::got_section): Likewise.
	(Target_sparc::relocate): Remove unused local have_got_offset.
	* powerpc.cc (Target_powerpc::relocate): Likewise.
@
text
@d3471 13
d3800 2
@


1.107
log
@	* gold.h (is_wildcard_string): New function.
	* layout.cc (Layout::layout): Pass this pointer to add_input_section.
	(Layout::layout_eh_frame): Ditto.
	(Layout::find_section_order_index): New method.
	(Layout::read_layout_from_file): New method.
	* layout.h (Layout::find_section_order_index): New method.
	(Layout::read_layout_from_file): New method.
	(Layout::input_section_position_): New private member.
	(Layout::input_section_glob_): New private member.
	* main.cc (main): Call read_layout_from_file here.
	* options.h (--section-ordering-file): New option.
	* output.cc (Output_section::input_section_order_specified_): New
	member.
	(Output_section::Output_section): Initialize new member.
	(Output_section::add_input_section): Add new parameter.
	Keep input sections when --section-ordering-file is used.
	(Output_section::set_final_data_size): Sort input sections when
	section ordering file is specified.
	(Output_section::Input_section_sort_entry): Add new parameter.
	Check sorting type.
	(Output_section::Input_section_sort_entry::compare_section_ordering):
	New method.
	(Output_section::Input_section_sort_compare::operator()): Change to
	consider section_order_index.
	(Output_section::Input_section_sort_init_fini_compare::operator()):
	Change to consider section_order_index.
	(Output_section::Input_section_sort_section_order_index_compare
	::operator()): New method.
	(Output_section::sort_attached_input_sections): Change to sort
	according to section order when specified.
	(Output_section::add_input_section<32, true>): Add new parameter.
	(Output_section::add_input_section<64, true>): Add new parameter.
	(Output_section::add_input_section<32, false>): Add new parameter.
	(Output_section::add_input_section<64, false>): Add new parameter.
	* output.h (Output_section::add_input_section): Add new parameter.
	(Output_section::input_section_order_specified): New
	method.
	(Output_section::set_input_section_order_specified): New method.
	(Input_section::Input_section): Initialize section_order_index_.
	(Input_section::section_order_index): New method.
	(Input_section::set_section_order_index): New method.
	(Input_section::section_order_index_): New member.
	(Input_section::Input_section_sort_section_order_index_compare): New
	struct.
	(Output_section::input_section_order_specified_): New member.
	* script-sections.cc (is_wildcard_string): Delete and move modified
	method to gold.h.
	(Output_section_element_input::Output_section_element_input): Modify
	call to is_wildcard_string.
	(Output_section_element_input::Input_section_pattern
	::Input_section_pattern): Ditto.
	(Output_section_element_input::Output_section_element_input): Ditto.
	* testsuite/Makefile.am (final_layout): New test case.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/final_layout.cc: New file.
	* testsuite/final_layout.sh: New file.
@
text
@d2435 1
a2435 1
    gold_assert(value.second);
d2448 1
a2448 1
    gold_assert(value.second);
d2472 1
a2472 1
    gold_assert(value.second);
@


1.106
log
@2010-05-23  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section::do_output_offset): Use convert_types
	instead of a cast.
	(Target_arm::apply_cortex_a8_workaround): Rewrite a conditional branch
	with a direct branch, not a conditional branch, to a stub.
	* merge.cc (Output_merge_base::record_input_section): New method
	defintion.
	(Output_merge_data::do_add_input_section): Record input section if
	keeps-input-sections flag is set.
	(Output_merge_string::do_add_input_section): Ditto.
	* merge.h (Output_merge_base::Output_merge_base): Initialize new data
	members KEEPS_INPUT_SECTIONS_, FIRST_RELOBJ_, FIRST_SHNDX_ and
	INPUT_SECTIONS_.
	(Output_merge_base::keeps_input_sections,
	Output_merge_base::set_keeps_input_sections,
	Output_merge_base::first_relobj, Output_merge_base::first_shndx): New
	method definitions.
	(Output_merge_base::Input_sections): New type declaration.
	(Output_merge_base::input_sections_begin,
	Output_merge_base::input_sections_end,
	Output_merge_base::do_set_keeps_input_sections): New method definitions.
	(Output_merge_base::bool keeps_input_sections_,
	Output_merge_base::first_relobj_, Output_merge_base::first_shndx_,
	Output_merge_base::input_sections_): New data members.
	(Output_merge_data::do_set_keeps_input_sections): New method
	defintion.
	(Output_merge_string::do_set_keeps_input_sections): Ditto.
	* output.cc (Output_section::Input_section::relobj): Move method
	defintion from class declaration to here and handle merge sections.
	(Output_section::Input_section::shndx): Ditto.
	(Output_section::Output_section): Remove initializations of removed
	data members and initialize new data member LOOKUP_MAPS_.
	(Output_section::add_input_section): Set keeps-input-sections flag
	for a newly created merge output section as appropriate.  Adjust code
	to use Output_section_lookup_maps class.
	(Output_section::add_relaxed_input_section): Adjst code for lookup
	maps code refactoring.
 	(Output_section::add_merge_input_section): Add a new parameter
	KEEPS_INPUT_SECTION.  Adjust code to use Output_section_lookup_maps
	class.  If adding input section to a newly created merge output
	section fails, remove the new merge section.
	(Output_section::convert_input_sections_in_list_to_relaxed_input_sections):
	Adjust code for use of the Output_section_lookup_maps class.
 	(Output_section::find_merge_section): Ditto.
	(Output_section::build_lookup_maps): New method defintion.
 	(Output_section::find_relaxed_input_section): Adjust code to use
	Output_section_lookup_maps class.
	(Output_section::get_input_sections): Export merge sections.  Adjust
	code to use Output_section_lookup_maps class.
	(Output_section:::add_script_input_section): Adjust code to use
	Output_section_lookup_maps class.  Update lookup maps for merge
	sections also.
	(Output_section::discard_states): Use Output_section_lookup_maps.
	(Output_section::restore_states): Same.
	* output.h (Merge_section_properties): Move class defintion out of
	Output_section.
	(Output_section_lookup_maps): New class.
	(Output_section::Input_section::is_merge_section): New method
	defintion.
	(Output_section::Input_section::relobj): Move defintion out of class
	defintion.  Declare method only.
	(Output_section::Input_section::shndx): Ditto.
	(Output_section::Input_section::output_merge_base): New method defintion.
     	(Output_section::Input_section::u2_.pomb): New union field.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Ouptut_relaxed_input_section_by_input_section_map):
	Remove types.
   	(Output_section::add_merge_input_section): Add new parameter
	KEEPS_INPUT_SECTIONS.
	(Output_section::build_lookup_maps): New method declaration.
	(Output_section::merge_section_map_,
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_): Remove data
	members.
	(Output_section::lookup_maps_): New data member.
@
text
@d2518 2
a2519 2
  add_input_section(Sized_relobj<size, big_endian>* object, unsigned int shndx,
		    const char *name,
d2739 12
d2987 2
a2988 1
	p2align_(ffsll(static_cast<long long>(addralign)))
d3000 2
a3001 1
      : shndx_(OUTPUT_SECTION_CODE), p2align_(0)
d3012 2
a3013 1
	p2align_(0)
d3021 2
a3022 1
      : shndx_(RELAXED_INPUT_SECTION_CODE), p2align_(0)
d3028 12
d3265 3
d3574 9
d3750 3
@


1.105
log
@2010-05-14  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section::original_size): New method.
	(Arm_input_section::do_addralign): Add a cast.
	(Arm_input_section::do_output_offset): Remove static cast.
	(Arm_input_section::original_addralign,
	 Arm_input_section::original_size_): Change type to uint32_t.
	(Arm_input_section::init): Add safe casts for section alignment
	and size.
	(Arm_input_section::set_final_data_size): Do not set address and
	offset of stub table.
	(Arm_output_section::fix_exidx_coverage): Change use of of
	Output_section::Simple_input_section to that of
	Output_section::Input_section.
	(Target_arm::do_relax): Set addresses and file offsets of Stub_tables
	except for the first pass.
	* output.cc (Output_section::get_input_sections): Change type of
	input_sections to std::list<Input_section>.
	(Output_section::add_script_input_section): Rename from
	Output_section::add_simple_input_section.  Change type of SIS
	parameter from Simple_input_section to Input_section.
	* output.h (Output_section::Simple_input_section): Remove class.
	(Output_section::Input_section): Change class visibility to public.
	(Output_section::Input_section::addralign): Use stored alignments
	for special input sections if set.
	(Output_section::Input_section::set_addralign): New method.
	(Output_section::get_input_sections): Change parameter type from
	list of Simple_input_section to list of Input_section.
	(Output_section::add_script_input_section): Rename from
	Output_section::add_simple_input_section. Change first parameter's
	type from Simple_input_section to Input_section and remove the
	second and third parameters.
	* script-sections.cc (Input_section::Input_section_list): Change
	type to list of Output_section::Input_section/
	(Input_section_info::Input_section_info): Change parameter type of
	INPUT_SECTION to Output_section::Input_section.
	(Input_section_info::input_section): Change return type.
	(Input_section_info::input_section_): Change type to
	Output_section::Input_section.
	(Output_section_element_input::set_section_addresses): Adjust code
	to use Output_section::Input_section instead of
	Output_section::Simple_input_section.  Adjust code for renaming
	of Output_section::add_simple_input_section.
	(Orphan_output_section::set_section_addresses): Ditto.
@
text
@d2317 182
d3066 8
d3088 1
a3088 9
    relobj() const
    {
      if (this->is_input_section())
        return this->u2_.object;
      else if (this->is_relaxed_input_section())
	return this->u2_.poris->relobj();
      else
	gold_unreachable();
    }
d3092 1
a3092 9
    shndx() const
    {
      if (this->is_input_section())
        return this->shndx_;
      else if (this->is_relaxed_input_section())
	return this->u2_.poris->shndx();
      else
	gold_unreachable();
    }
d3103 8
d3233 1
a3574 72
  // This class describes properties of merge data sections.  It is used
  // as a key type for maps.
  class Merge_section_properties
  {
   public:
    Merge_section_properties(bool is_string, uint64_t entsize,
			     uint64_t addralign)
      : is_string_(is_string), entsize_(entsize), addralign_(addralign)
    { }

    // Whether this equals to another Merge_section_properties MSP.
    bool
    eq(const Merge_section_properties& msp) const
    {
      return ((this->is_string_ == msp.is_string_)
	      && (this->entsize_ == msp.entsize_)
	      && (this->addralign_ == msp.addralign_));
    }

    // Compute a hash value for this using 64-bit FNV-1a hash.
    size_t
    hash_value() const
    {
      uint64_t h = 14695981039346656037ULL;	// FNV offset basis.
      uint64_t prime = 1099511628211ULL;
      h = (h ^ static_cast<uint64_t>(this->is_string_)) * prime;
      h = (h ^ static_cast<uint64_t>(this->entsize_)) * prime;
      h = (h ^ static_cast<uint64_t>(this->addralign_)) * prime;
      return h;
    }
    
    // Functors for associative containers.
    struct equal_to
    {
      bool
      operator()(const Merge_section_properties& msp1,
		 const Merge_section_properties& msp2) const
      { return msp1.eq(msp2); }
    };

    struct hash
    {
      size_t
      operator()(const Merge_section_properties& msp) const
      { return msp.hash_value(); }
    };

   private:
    // Whether this merge data section is for strings.
    bool is_string_;
    // Entsize of this merge data section.
    uint64_t entsize_;
    // Address alignment.
    uint64_t addralign_;
  };

  // Map that link Merge_section_properties to Output_merge_base.
  typedef Unordered_map<Merge_section_properties, Output_merge_base*,
			Merge_section_properties::hash,
			Merge_section_properties::equal_to>
    Merge_section_by_properties_map;

  // Map that link Const_section_id to Output_section_data.
  typedef Unordered_map<Const_section_id, Output_section_data*,
			Const_section_id_hash>
    Output_section_data_by_input_section_map;

  // Map that link Const_section_id to Output_relaxed_input_section.
  typedef Unordered_map<Const_section_id, Output_relaxed_input_section*,
			Const_section_id_hash>
    Output_relaxed_input_section_by_input_section_map;

d3585 2
a3586 1
  // handled.
d3589 2
a3590 1
			  uint64_t entsize, uint64_t addralign);
d3623 4
d3749 2
a3750 11
  // Map from input sections to merge sections.
  Output_section_data_by_input_section_map merge_section_map_;
  // Map from merge section properties to merge_sections;
  Merge_section_by_properties_map merge_section_by_properties_map_;
  // Map from input sections to relaxed input sections.  This is mutable
  // because it is updated lazily.  We may need to update it in a
  // const qualified method.
  mutable Output_relaxed_input_section_by_input_section_map
    relaxed_input_section_map_;
  // Whether relaxed_input_section_map_ is valid.
  mutable bool is_relaxed_input_section_map_valid_;
@


1.104
log
@	* expression.cc (Expression::Expression_eval_info): Add
	result_alignment_pointer field.
	(Expression::eval_with_dot): Add result_alignment_pointer
	parameter.  Change all callers.
	(Expression::eval_maybe_dot): Likewise.
	(class Binary_expression): Add alignment_pointer parameter to
	left_value and right_value.  Change all callers.
	(BINARY_EXPRESSION): Set result alignment.
	(class Trinary_expression): Add alignment_pointer parameter to
	arg2_value and arg3_value.  Change all callers.
	(Trinary_cond::value): Set result alignment.
	(Max_expression::value, Min_expression::value): Likewise.
	(Align_expression::value): Likewise.
	* script-sections.cc (class Sections_element): Add dot_alignment
	parameter to set_section_addresses virtual function.  Update
	instantiations.
	(class Output_section_element): Likewise.
	(Script_sections::create_segments): Add dot_alignment parameter.
	Change all callers.
	(Script_sections::create_segments_from_phdrs_clause): Likewise.
	(Script_sections::set_phdrs_clause_addresses): Likewise.
	* script-sections.h: Update declarations.
	* script.h: Update declarations.
	* output.h (Output_segment::set_minimum_p_align): Don't decrease
	min_p_align.
	* testsuite/script_test_3.t: Set large alignment.
	* testsuite/script_test_3.sh: Make sure that at least one LOAD
	segment has expected alignment.
@
text
@a2768 257
  // We need to export the input sections to linker scripts.  Previously
  // we export a pair of Relobj pointer and section index.  We now need to
  // handle relaxed input sections as well.  So we use this class.
  class Simple_input_section
  {
   private:
    static const unsigned int invalid_shndx = static_cast<unsigned int>(-1);

   public:
    Simple_input_section(Relobj *relobj, unsigned int shndx)
      : shndx_(shndx)
    {
      gold_assert(shndx != invalid_shndx);
      this->u_.relobj = relobj;
    }
 
    Simple_input_section(Output_relaxed_input_section* section)
      : shndx_(invalid_shndx)
    { this->u_.relaxed_input_section = section; }

    // Whether this is a relaxed section.
    bool
    is_relaxed_input_section() const
    { return this->shndx_ == invalid_shndx; }

    // Return object of an input section.
    Relobj*
    relobj() const
    {
      return ((this->shndx_ != invalid_shndx)
	      ? this->u_.relobj
	      : this->u_.relaxed_input_section->relobj());
    }

    // Return index of an input section.
    unsigned int
    shndx() const
    {
      return ((this->shndx_ != invalid_shndx)
	      ? this->shndx_
	      : this->u_.relaxed_input_section->shndx());
    }

    // Return the Output_relaxed_input_section object of a relaxed section.
    Output_relaxed_input_section*
    relaxed_input_section() const
    {
      gold_assert(this->shndx_ == invalid_shndx);
      return this->u_.relaxed_input_section;
    }

   private:
    // Pointer to either an Relobj or an Output_relaxed_input_section.
    union
    {
      Relobj* relobj;
      Output_relaxed_input_section* relaxed_input_section;
    } u_;
    // Section index for an non-relaxed section or invalid_shndx for
    // a relaxed section.
    unsigned int shndx_;
  };
 
  // Store the list of input sections for this Output_section into the
  // list passed in.  This removes the input sections, leaving only
  // any Output_section_data elements.  This returns the size of those
  // Output_section_data elements.  ADDRESS is the address of this
  // output section.  FILL is the fill value to use, in case there are
  // any spaces between the remaining Output_section_data elements.
  uint64_t
  get_input_sections(uint64_t address, const std::string& fill,
		     std::list<Simple_input_section>*);

  // Add a simple input section.
  void
  add_simple_input_section(const Simple_input_section& input_section,
			   off_t data_size, uint64_t addralign);

  // Set the current size of the output section.
  void
  set_current_data_size(off_t size)
  { this->set_current_data_size_for_child(size); }

  // Get the current size of the output section.
  off_t
  current_data_size() const
  { return this->current_data_size_for_child(); }

  // End of linker script support.

  // Save states before doing section layout.
  // This is used for relaxation.
  void
  save_states();

  // Restore states prior to section layout.
  void
  restore_states();

  // Discard states.
  void
  discard_states();

  // Convert existing input sections to relaxed input sections.
  void
  convert_input_sections_to_relaxed_sections(
      const std::vector<Output_relaxed_input_section*>& sections);

  // Find a relaxed input section to an input section in OBJECT
  // with index SHNDX.  Return NULL if none is found.
  const Output_relaxed_input_section*
  find_relaxed_input_section(const Relobj* object, unsigned int shndx) const;
  
  // Whether section offsets need adjustment due to relaxation.
  bool
  section_offsets_need_adjustment() const
  { return this->section_offsets_need_adjustment_; }

  // Set section_offsets_need_adjustment to be true.
  void
  set_section_offsets_need_adjustment()
  { this->section_offsets_need_adjustment_ = true; }

  // Adjust section offsets of input sections in this.  This is
  // requires if relaxation caused some input sections to change sizes.
  void
  adjust_section_offsets();

  // Whether this is a NOLOAD section.
  bool
  is_noload() const
  { return this->is_noload_; }

  // Set NOLOAD flag.
  void
  set_is_noload()
  { this->is_noload_ = true; }

  // Print merge statistics to stderr.
  void
  print_merge_stats();

 protected:
  // Return the output section--i.e., the object itself.
  Output_section*
  do_output_section()
  { return this; }

  const Output_section*
  do_output_section() const
  { return this; }

  // Return the section index in the output file.
  unsigned int
  do_out_shndx() const
  {
    gold_assert(this->out_shndx_ != -1U);
    return this->out_shndx_;
  }

  // Set the output section index.
  void
  do_set_out_shndx(unsigned int shndx)
  {
    gold_assert(this->out_shndx_ == -1U || this->out_shndx_ == shndx);
    this->out_shndx_ = shndx;
  }

  // Set the final data size of the Output_section.  For a typical
  // Output_section, there is nothing to do, but if there are any
  // Output_section_data objects we need to set their final addresses
  // here.
  virtual void
  set_final_data_size();

  // Reset the address and file offset.
  void
  do_reset_address_and_file_offset();

  // Return true if address and file offset already have reset values. In
  // other words, calling reset_address_and_file_offset will not change them.
  bool
  do_address_and_file_offset_have_reset_values() const;

  // Write the data to the file.  For a typical Output_section, this
  // does nothing: the data is written out by calling Object::Relocate
  // on each input object.  But if there are any Output_section_data
  // objects we do need to write them out here.
  virtual void
  do_write(Output_file*);

  // Return the address alignment--function required by parent class.
  uint64_t
  do_addralign() const
  { return this->addralign_; }

  // Return whether there is a load address.
  bool
  do_has_load_address() const
  { return this->has_load_address_; }

  // Return the load address.
  uint64_t
  do_load_address() const
  {
    gold_assert(this->has_load_address_);
    return this->load_address_;
  }

  // Return whether this is an Output_section.
  bool
  do_is_section() const
  { return true; }

  // Return whether this is a section of the specified type.
  bool
  do_is_section_type(elfcpp::Elf_Word type) const
  { return this->type_ == type; }

  // Return whether the specified section flag is set.
  bool
  do_is_section_flag_set(elfcpp::Elf_Xword flag) const
  { return (this->flags_ & flag) != 0; }

  // Set the TLS offset.  Called only for SHT_TLS sections.
  void
  do_set_tls_offset(uint64_t tls_base);

  // Return the TLS offset, relative to the base of the TLS segment.
  // Valid only for SHT_TLS sections.
  uint64_t
  do_tls_offset() const
  { return this->tls_offset_; }

  // This may be implemented by a child class.
  virtual void
  do_finalize_name(Layout*)
  { }

  // Print to the map file.
  virtual void
  do_print_to_mapfile(Mapfile*) const;

  // Record that this section requires postprocessing after all
  // relocations have been applied.  This is called by a child class.
  void
  set_requires_postprocessing()
  {
    this->requires_postprocessing_ = true;
    this->after_input_sections_ = true;
  }

  // Write all the data of an Output_section into the postprocessing
  // buffer.
  void
  write_to_postprocessing_buffer();

d2834 3
a2836 1
      if (!this->is_input_section())
d2838 2
a2839 3
      return (this->p2align_ == 0
	      ? 0
	      : static_cast<uint64_t>(1) << (this->p2align_ - 1));
d2842 15
d3056 194
@


1.103
log
@2010-04-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::choose_output_section): Handle script section
	types.
	(Layout::make_output_section_for_script): Add section type parameter.
	Handle script section types.
	* layout.h (Layout::make_output_section_for_script): Add section
	type parameter.
	* output.cc (Output_section::Output_section): Initialize data member
	is_noload_.
	(Output_section::do_reset_address_and_file_offset): Do not set address
	to 0 if section is a NOLOAD section.
	* output.h (Output_section::is_noload): New method.
	(Output_section::set_is_noload): Ditto.
	(Output_section::is_noload_): New data member.
	* script-c.h (Script_section_type): New enum type.
	(struct Parser_output_section_header): Add new file section_type.
	* script-sections.cc (Sections_element::output_section_name): Add
	parameter for returning script section type.
	(Output_section_definition::output_section_name): Ditto.
	(Output_section_definition::section_type)P; New method.
	(Output_section_definiton::script_section_type_name): Ditto.
	(Output_section_definition::script_section_type_): New data member.
	(Output_section_definition::Output_section_definition): Initialize
	data member Output_section_definition::script_section_type_.
	(Output_section_definition::create_sections): Pass script section type
	to Layout::make_output_section_for_script.
	(Output_section_definition::output_section_name): Return script
	section type to caller.
	(Output_section_definition::set_section_address): Do not advance
	dot value and load address if section type is NOLOAD.  Set address
	of NOLOAD sections regardless of section flags.
	(Output_section_definition::print): Print section type if it is
	not SCRIPT_SECTION_TYPE_NONE.
	(Output_section_definition::section_type): New method.
	(Output_section_definition::script_section_type_name): Ditto.
	(Script_sections::output_section_name): Add new parameter
	PSECTION_TYPE for returning script section type.  Pass it to
	section elements.  Handle discard sections.
	(Sort_output_sections::operator()): Handle NOLOAD sections.
	* script-sections.h (Script_sections::Section_type): New enum type.
   	(Script_sections::output_section_name): Add a new parameter for
	returning script section type.
	* script.cc (script_keyword_parsecodes): Add keywords COPY, DSECT,
	INFO and NOLOAD.
	* yyscript.y (union): Add new field SECTION_TYPE.
	(COPY, DSECT, INFO, NOLOAD): New tokens.
	(opt_address_and_section_type): Change type to output_section_header.
	(section_type): New non-terminal
	(section_header): Handle section type.
 	(opt_address_and_section_type): Return section type value.
@
text
@d3836 4
a3839 1
  { this->min_p_align_ = align; }
@


1.102
log
@2010-03-01  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::Layout): Force section types of .init_array*,
	.preinit_array* and .fini_array* sections.
	* output.cc (Output_section::Input_section_sort_entry::has_priority):
	Fix check of return value of std::string::find.().
	(Output_section::Input_section_sort_compare::operator()): Remove
	comment about .init_array.
	(Output_section::Input_section_sort_init_fini_compare::operator()):
	New method.
	(Output_section::sort_attached_input_sections): Handle .init_array
	and .fini_array specially.
	* output.h (Output_section::Inut_section_sort_compare): Update
	comment.
	(Output_section::Input_section_sort_init_fini_compare): New struct.
@
text
@d2897 10
d3672 2
@


1.101
log
@	* output.h (Output_reloc<SHT_REL>::Output_reloc): Add
	is_symbolless parameter.
	(Output_reloc<SHT_REL>::is_symbolless): New.
	(Output_reloc<SHT_REL>::is_symbolless_): New.
	(Output_reloc<SHT_REL>::type_): Decrease to 29 bits.
	(Output_reloc<SHT_RELA>::Output_reloc): Add is_symbolless parameter.
	(Output_reloc<SHT_RELA>::is_symbolless): New.
	(Output_data_reloc::add_global): Handle is_symbolless.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): New.
	(Output_data_reloc::add_symbolless_local_addend): New.
	* output.cc (Output_reloc<SHT_REL>::Output_reloc): Handle
	is_symbolless.
	(Output_reloc::set_needs_dynsym_index): Test ->is_symbolless_
	instead of ->is_relative_
	(Output_reloc::write): Likewise.
	(Output_reloc::get_symbol_index): Return 0 when ->is_symbolless_
	(Output_reloc::write_rel): Simplify.

	* sparc.cc (Target_sparc::Scan::local): Use
	->add_symbolless_local_addend as needed.
	(Target_sparc::Scan::global): Use ->add_symbolless_global_addend as
	needed.  Also, emit appropriate unaligned vs. aligned dynamic reloc
	based upon relocation offset.
@
text
@d3381 1
a3381 1
  // This is the sort comparison function.
d3389 8
@


1.100
log
@	* output.h (Output_data_dynamic::add_section_size): New method
	that takes two Output_data objects.
	(Output_data_dynamic::Dynamic_entry): Create storage for secondary
	entry param.  Handle it in initializers.
	* output.cc (Output_data_dynamic::Dynamic_entry::write): For
	DYNAMIC_SECTION_SIZE, add in second object size if non-NULL.
	* layout.h (Layout::add_target_dynamic_tags): Add dynrel_includes_plt
	arg.
	* layout.cc (Layout::add_target_dynamic_tags): If dynrel_includes_plt,
	and .rela.plt exists, set DT_REL{,A}SZ to sum of .rela.dyn and .rela.plt
	* arm.cc (Target_arm::do_finalize_sections): Update to pass false
	for dynrel_includes_plt.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::make_plt_entry): Force .rela.dyn to be output
	before .rela.plt
	(Target_sparc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt.
	* powerpc.cc (Target_powerpc::make_plt_entry): Force .rela.dyn to be
	output before .rela.plt
	(Target_powerpc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt when 32-bit.
@
text
@d977 1
a977 1
	       Address address, bool is_relative);
d981 2
a982 1
	       unsigned int shndx, Address address, bool is_relative);
d989 1
a989 1
               bool is_section_symbol);
d994 1
a994 1
               bool is_section_symbol);
d1033 6
d1162 1
a1162 1
  unsigned int type_ : 30;
d1165 3
d1194 4
a1197 2
	       Address address, Addend addend, bool is_relative)
    : rel_(gsym, type, od, address, is_relative), addend_(addend)
d1203 3
a1205 2
	       bool is_relative)
    : rel_(gsym, type, relobj, shndx, address, is_relative), addend_(addend)
d1213 2
a1214 1
	       Addend addend, bool is_relative, bool is_section_symbol)
d1216 1
a1216 1
           is_section_symbol),
d1223 2
a1224 1
	       Addend addend, bool is_relative, bool is_section_symbol)
d1226 1
a1226 1
           is_section_symbol),
d1275 6
d1437 1
a1437 1
  { this->add(od, Output_reloc_type(gsym, type, od, address, false)); }
d1444 1
a1444 1
                                    false)); }
d1471 1
a1471 1
  { this->add(od, Output_reloc_type(gsym, type, od, address, true)); }
d1479 19
a1497 1
                                    true));
d1508 1
a1508 1
                                    address, false, false));
d1517 1
a1517 1
				    address, false, false));
d1528 1
a1528 1
                                    address, true, false));
d1537 23
a1559 1
				    address, true, false));
d1572 1
a1572 1
                                    address, false, true));
d1581 1
a1581 1
                                    address, false, true));
d1651 1
a1651 1
                                    false)); }
d1659 1
a1659 1
                                    addend, false)); }
d1669 2
a1670 1
  { this->add(od, Output_reloc_type(gsym, type, od, address, addend, true)); }
d1677 18
a1694 1
                                    addend, true)); }
d1704 1
a1704 1
				    addend, false, false));
d1714 1
a1714 1
                                    address, addend, false, false));
d1725 1
a1725 1
				    addend, true, false));
d1735 23
a1757 1
                                    address, addend, true, false));
d1770 1
a1770 1
				    addend, false, true));
d1780 1
a1780 1
                                    address, addend, false, true));
@


1.99
log
@2010-01-22  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_relax): Record an output section for section
	offset adjustment it contains any stub table that has changed.
	* layout.cc (Layout::clean_up_after_relaxation): Adjust section
	offsets in an output section if necessary.
	* output.cc (Output_section::Output_section): Initialize
	section_offsets_need_adjustments_.
	(Output_section::add_input_section_for_script): Renamed to
	Output_section::add_simple_input_section.
	(Output_section::save_states): Add a comment.
	(Output_section::discard_states): New method defintion.
	(Output_section::adjust_section_offsets): Same.
	* output.h (Output_section::add_input_section_for_script): Renamed to
	Output_section::add_simple_input_section.
	(Output_section::discard_states): New method declaration.
	(Output_section::adjust_section_offsets): Same.
	(Output_section::section_offsets_need_adjustment,
	Output_section::set_section_offsets_need_adjustment): New method
	definitions.
	(Output_section::section_offsets_need_adjustment_): New data member.
	* script-sections.cc
	(Output_section_element_input::set_section_address): Adjust code for
	renaming of Output_section::add_input_section_for_script.
	(Orphan_output_section::set_section_address): Same.
@
text
@d2000 6
d2054 13
a2066 1
    { this->u_.od = od; }
d2122 2
@


1.98
log
@2010-01-20  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::Arm_input_section_map): Change key type from
	Input_section_specifier to Section_id.
	(Target_arm::new_arm_input_section: Adjust code for change of key
	type.
	(Target_arm::find_arm_input_section): Ditto.
	* gc.h (object.h): Include for Section_id nand Section_id_hash.
	(Section_id): Remove.
	(Garbage_collection::Section_id_hash): Remove.
	* icf.h (object.h): Include for Section_id nand Section_id_hash.
	(Section_id): Remove.
	(Icf::Section_id_hash): Remove.
	* object.h (Section_id, Const_section_id, Section_id_hash,
	Const_section_id_hash): New type definitions.
	* output.cc (Output_section::add_relaxed_input_section): Change to
	use Const_section_id instead of Input_section_specifier as key type.
	(Output_section::add_merge_input_section): Ditto.
	(Output_section::build_relaxation_map): Change to use Section_id
	instead of Input_section_specifier as key type.
 	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Ditto.
	(Output_section::convert_input_sections_to_relaxed_sections): Change
	to use Const_section_id instead of Input_section_specifier as key type.
 	(Output_section::find_merge_section): Ditto.
	(Output_section::find_relaxed_input_section): Ditto.
	* output.h (Input_section_specifier): Remove class.
	(Output_section::Output_section_data_by_input_section_map): Change
	key type to Const_section_id.
	(Output_section::Output_relaxed_input_section_by_input_section_map):
	Ditto.
	(Output_section::Relaxation_map): Change key type to Section_id.
@
text
@d2721 1
a2721 1
  // Add an input section from a script.
d2723 2
a2724 2
  add_input_section_for_script(const Simple_input_section& input_section,
			       off_t data_size, uint64_t addralign);
d2747 4
d2761 15
d3531 2
@


1.97
log
@	PR 10287
	PR 11063
	* i386.cc (class Target_i386): Change return type of plt_section
	to be non-const.
	(class Output_data_plt_i386): Add tls_desc_rel_ field.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize
	tls_desc_rel_ field.
	(Output_data_plt_i386::rel_tls_desc): New function.
	(Target_i386::rel_tls_desc_section): New function.
	(Target_i386::Scan::local): Rewrite R_386_TLS_GOTDESC handling.
	(Target_i386::Scan::global): For R_386_TLS_GOTDESC put
	R_386_TLS_DESC reloc in rel_tls_desc_section.
	* x86_64.cc (class Target_x86_64): Add tlsdesc_reloc_info_ field.
	Define struct Tlsdesc_info.
	(Target_x86_64::Target_x86_64): Initialize tlsdesc_reloc_info_.
	(Target_x86_64::do_reloc_symbol_index): New function.
	(Target_x86_64::add_tlsdesc_info): New function.
	(class Output_data_plt_x86_64): Add tlsdesc_rel_ field.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Initialize
	tlsdesc_rel_ field.
	(Output_data_plt_x86_64::rela_plt): Rename from rel_plt.  Change
	all callers.
	(Output_data_plt_x86_64::rela_tlsdesc): New function.
	(Target_x86_64::rela_tlsdesc_section): New function.
	(Target_x86_64::Scan::local): Rewrite R_X86_64_GOTPC32_TLSDESC
	handling.
	(Target_x86_64::Scan::global): For R_X86_64_GOTPC32_TLSDESC put
	(Target_x86_64::do_reloc_addend): New function.
	R_X86_64_TLSDESC reloc in rela_tlsdesc_section.
	* output.h (class Output_reloc) [SHT_REL]: Add new constructor
	declarations.  Define TARGET_CODE.  Add arg field to u1_ union.
	(Output_reloc::type): New function.
	(Output_reloc::is_local_section_symbol): Check for TARGET_CODE.
	(Output_reloc::is_target_specific): New function.
	(Output_reloc::target_arg): New function.
	(class Output_reloc) [SHT_RELA]: Add four new constructors for
	absolute relocs and target specific relocs.
	(class Output_data_reloc) [SHT_REL]: Add add_absolute and
	add_target_specific.
	(class Output_data_reloc) [SHT_RELA]: Likewise.
	* output.cc (Output_reloc::Output_reloc): Add four new versions
	for absolute relocs and target specific relocs.
	(Output_reloc::set_needs_dynsym_index): Add TARGET_CODE case.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Check that local_sym_index_
	is not TARGET_CODE or 0.
	(Output_reloc::symbol_value): Likewise.
	(Output_reloc::write) [SHT_RELA]: Call target for target specific
	reloc.
	* target.h (class Target): Add reloc_symbol_index and reloc_addend
	functions.  Add do_reloc_symbol_index and do_reloc_addend virtual
	functions.
	* layout.cc (add_target_dynamic_tags): Use output section for
	DT_PLTRELSZ and DT_JMPREL.
@
text
@a49 56
// This class specifies an input section.  It is used as a key type
// for maps.

class Input_section_specifier
{
 public:
  Input_section_specifier(const Relobj* relobj, unsigned int shndx)
    : relobj_(relobj), shndx_(shndx)
  { }
   
  // Return Relobj of this.
  const Relobj*
  relobj() const
  { return this->relobj_; }

  // Return section index of this.
  unsigned int
  shndx() const
  { return this->shndx_; }

  // Whether this equals to another specifier ISS.
  bool
  eq(const Input_section_specifier& iss) const
  { return this->relobj_ == iss.relobj_ && this->shndx_ == iss.shndx_; }

  // Compute a hash value of this.
  size_t
  hash_value() const
  {
     return (gold::string_hash<char>(this->relobj_->name().c_str())
	     ^ this->shndx_);
   }

  // Functors for containers.
  struct equal_to
  {
    bool
    operator()(const Input_section_specifier& iss1,
	       const Input_section_specifier& iss2) const
    { return iss1.eq(iss2); }
  };
 
  struct hash
  {
    size_t
    operator()(const Input_section_specifier& iss) const
    { return iss.hash_value(); }
  };

 private:
  // An object.
  const Relobj* relobj_;
  // A section index. 
  unsigned int shndx_;
};

d3343 3
a3345 4
  // Map that link Input_section_specifier to Output_section_data.
  typedef Unordered_map<Input_section_specifier, Output_section_data*,
			Input_section_specifier::hash,
			Input_section_specifier::equal_to>
d3348 3
a3350 4
  // Map that link Input_section_specifier to Output_relaxed_input_section.
  typedef Unordered_map<Input_section_specifier, Output_relaxed_input_section*,
			Input_section_specifier::hash,
			Input_section_specifier::equal_to>
d3354 3
a3356 6
  // an input section specifier to an input section list index.
  // We assume that Input_section_list is a vector.
  typedef Unordered_map<Input_section_specifier, size_t,
			Input_section_specifier::hash,
			Input_section_specifier::equal_to>
    Relaxation_map;
@


1.96
log
@	PR 11061
	* output.h (class Output_reloc) [SHT_RELA]: Add is_relative
	function.
	(class Output_data_reloc_generic): Define.
	(class Output_data_reloc_base): Change base class to
	Output_data_reloc_generic.  Change add() method to call
	bump_relative_reloc_count for a relative reloc.  Remove
	sort_relocs_ field.
	* output.cc (Output_data_reloc_base::do_write): Change sort_reloc_
	to sort_relocs().
	* layout.cc (Layout::add_target_dynamic_tags): Change dyn_rel to
	Output_data_reloc_generic*.  Add DT_RELCOUNT/DT_RELACOUNT tag if
	appropriate.
	* layout.h (class Layout): Update declaration.
@
text
@d1060 24
a1083 1
  // Return TRUE if this is a RELATIVE relocation.
d1095 1
d1099 14
d1165 2
d1168 1
a1168 1
    INVALID_CODE = -3U
d1186 3
d1203 6
a1208 5
  // relocation against an output section, or INVALID_CODE for an
  // uninitialized value.  Otherwise, for a local symbol
  // (this->is_section_symbol_ is false), the local symbol index.  For
  // a local section symbol (this->is_section_symbol_ is true), the
  // section index in the input file.
d1284 28
a1311 1
  // Return TRUE if this is a RELATIVE relocation.
d1593 26
d1751 30
@


1.95
log
@	* output.h (class Output_data): Add const version of
	output_section and do_output_section.
	(class Output_section_data): Add const version of
	do_output_section.
	(class Output_section): Likewise.
	* layout.cc (Layout::add_target_dynamic_tags): New function.
	* layout.h (class Layout): Update declarations.
	* arm.cc (Target_arm::do_finalize_sections): Use
	add_target_dynamic_tags.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d1240 5
d1271 37
d1316 1
a1316 1
class Output_data_reloc_base : public Output_section_data_build
d1326 1
a1326 2
    : Output_section_data_build(Output_data::default_alignment_for_size(size)),
      sort_relocs_(sort_relocs)
d1355 2
a1371 3
  // Whether to sort the relocations when writing them out, to make
  // the dynamic linker more efficient.
  bool sort_relocs_;
@


1.94
log
@	PR 10980
	* options.cc (General_options::parse_section_start): New function.
	(General_options::section_start): New function.
	(General_options::General_options): Initialize all members.
	* options.h: Include <map>
	(class General_options): Add --section-start.  Add section_starts_
	member.
	* layout.cc (Layout::attach_allocated_section_to_segment): If
	--section-start was used, set the address of the segment.  Remove
	local sort_sections.
	(Layout::relaxation_loop_body): If the address of the load segment
	has been set by --section-start, don't use it.
	* output.h (Output_segment::update_flags_for_output_section): New
	function.
	* output.cc (Output_segment::add_output_section): Call
	update_flags_for_output_section.
@
text
@d209 4
d365 4
d757 4
d2656 4
@


1.93
log
@	* layout.cc (Layout::Layout): Initialize increase_relro_.
	(Layout::get_output_section): Add is_relro, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::set_segment_offsets): Clear increase_relro when using a
	linker script.
	* layout.h (class Layout): Add increase_relro method.  Add
	increase_relro_ field.  Update declarations.
	* output.cc (Output_section::Output_section): Initialize
	is_last_relro_ and is_first_non_relro_.
	(Output_segment::add_output_section): Group relro sections is
	do_sort is true.  Handle is_last_relro and is_first_non_relro.
	(Output_segment::maximum_alignment): Remove relro handling.
	(Output_segment::set_section_addresses): Add increase_relro
	parameter.  Change all callers.  Add initial alignment to align
	relro sections on separate page.  Remove old relro handling.
	(Output_segment::set_section_list_addresses): Remove in_relro
	parameter.  Change all callers.
	(Output_segment::set_offset): Add increase parameter.  Change all
	callers.  Remove old relro handling.
	* output.h (class Output_section): Add new methods: is_last_relro,
	set_is_last_relro, is_first_non_relro, set_is_first_non_relro.
	Add is_last_relro_ and is_first_non_relro_ fields.
	* i386.cc (Target_i386::got_section): Don't call set_is_relro.
	Create separate .got.plt section.  Call increase_relro.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/relro_script_test.t: Add .got.plt.
@
text
@d3486 2
a3487 2
  // Add an Output_data (which is not an Output_section) to the start
  // of this segment.
d3519 11
@


1.92
log
@	PR 10450
	* output.h (class Output_section): Add is_entsize_zero_ field.
	* output.cc (Output_section::Output_section): Initialize
	is_entsize_zero_.
	(Output_section::set_entsize): If two different entsizes are
	requested, force it to zero.
	(Output_section::add_input_section): Set flags for .debug_str
	before updating section flags.  Set entsize.
	(Output_section::update_flags_for_input_section): Set SHF_MERGE
	and SHF_STRING if all input sections have those flags.
@
text
@d2354 29
d3373 4
d3533 2
a3534 1
  set_section_addresses(const Layout*, bool reset, uint64_t addr, off_t* poff,
d3546 1
a3546 1
  set_offset();
d3592 1
a3592 1
                             bool* in_tls, bool* in_relro);
@


1.91
log
@2009-12-16  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::scan_sections_for_stubs): Exclude ICF-eliminated
	sections.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Handle
	relaxed input sections.
	* output.cc (Output_section::find_relaxed_input_section): Change
	return type to Output_relaxed_input_section pointer.  Adjust code
	for new type of relaxed_input_section_map_.
	* output.h (Output_section::find_relaxed_input_section): Change
	return type to Output_relaxed_input_section pointer.
	(Output_section::Output_relaxed_input_section_by_input_section_map):
	New type.
	(Output_section::relaxed_input_section_map_): Change type to
	Output_section::Output_relaxed_input_section_by_input_section_map.
	* symtab.cc (Symbol_table::compute_final_value): Handle relaxed
	input section.
@
text
@d3355 2
@


1.90
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d2602 1
a2602 1
  const Output_section_data*
d3193 6
d3367 2
a3368 1
  mutable Output_section_data_by_input_section_map relaxed_input_section_map_;
@


1.89
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d56 2
a57 2
  Input_section_specifier(const Relobj* robj, unsigned int sec_shndx)
    : relobj_(robj), shndx_(sec_shndx)
d419 1
a419 1
  set_data_size(off_t datasize)
d423 1
a423 1
    this->data_size_ = datasize;
d445 1
a445 1
  set_current_data_size_for_child(off_t datasize)
d448 1
a448 1
    this->data_size_ = datasize;
d642 3
a644 3
  Output_section_data(off_t datasize, uint64_t addr_align,
		      bool is_datasize_fixed)
    : Output_data(), output_section_(NULL), addralign_(addr_align)
d646 2
a647 2
    this->set_data_size(datasize);
    if (is_datasize_fixed)
d651 2
a652 2
  Output_section_data(uint64_t addr_align)
    : Output_data(), output_section_(NULL), addralign_(addr_align)
d678 1
a678 1
		section_offset_type sec_offset,
d680 1
a680 1
  { return this->do_output_offset(object, shndx, sec_offset, poutput); }
d771 2
a772 2
  Output_section_data_build(uint64_t addr_align)
    : Output_section_data(addr_align)
d782 2
a783 2
  set_current_data_size(off_t datasize)
  { this->set_current_data_size_for_child(datasize); }
d798 2
a799 2
  Output_data_const(const std::string& data, uint64_t addr_align)
    : Output_section_data(data.size(), addr_align, true), data_(data)
d802 2
a803 2
  Output_data_const(const char* p, off_t len, uint64_t addr_align)
    : Output_section_data(len, addr_align, true), data_(p, len)
d806 2
a807 2
  Output_data_const(const unsigned char* p, off_t len, uint64_t addr_align)
    : Output_section_data(len, addr_align, true),
d837 2
a838 2
			   uint64_t addr_align, const char* map_name)
    : Output_section_data(len, addr_align, true),
d871 1
a871 1
  Output_data_fixed_space(off_t datasize, uint64_t addr_align,
d873 1
a873 1
    : Output_section_data(datasize, addr_align, true),
d901 2
a902 2
  explicit Output_data_space(uint64_t addr_align, const char* map_name)
    : Output_section_data_build(addr_align),
d935 2
a936 2
  Output_data_zero_fill(off_t datasize, uint64_t addr_align)
    : Output_section_data(datasize, addr_align, true)
d1184 2
a1185 2
	       Address addr, Addend addend, bool is_relative)
    : rel_(gsym, type, od, addr, is_relative), addend_(addend)
d1190 1
a1190 1
	       unsigned int shndx, Address addr, Addend addend,
d1192 1
a1192 1
    : rel_(gsym, type, relobj, shndx, addr, is_relative), addend_(addend)
d1199 1
a1199 1
	       Output_data* od, Address addr,
d1201 1
a1201 1
    : rel_(relobj, local_sym_index, type, od, addr, is_relative,
d1208 1
a1208 1
	       unsigned int shndx, Address addr,
d1210 1
a1210 1
    : rel_(relobj, local_sym_index, type, shndx, addr, is_relative,
d1218 2
a1219 2
	       Address addr, Addend addend)
    : rel_(os, type, od, addr), addend_(addend)
d1224 2
a1225 2
	       unsigned int shndx, Address addr, Addend addend)
    : rel_(os, type, relobj, shndx, addr), addend_(addend)
d1348 2
a1349 2
  add_global(Symbol* gsym, unsigned int type, Output_data* od, Address addr)
  { this->add(od, Output_reloc_type(gsym, type, od, addr, false)); }
d1354 2
a1355 2
	     unsigned int shndx, Address addr)
  { this->add(od, Output_reloc_type(gsym, type, relobj, shndx, addr,
d1361 1
a1361 1
  add_global(Symbol* gsym, unsigned int type, Output_data* od, Address addr,
d1365 1
a1365 1
    this->add_global(gsym, type, od, addr);
d1371 1
a1371 1
	     unsigned int shndx, Address addr, Address addend)
d1374 1
a1374 1
    this->add_global(gsym, type, od, relobj, shndx, addr);
d1382 2
a1383 2
                      Address addr)
  { this->add(od, Output_reloc_type(gsym, type, od, addr, true)); }
d1388 1
a1388 1
                      unsigned int shndx, Address addr)
d1390 1
a1390 1
    this->add(od, Output_reloc_type(gsym, type, relobj, shndx, addr,
d1399 1
a1399 1
	    Output_data* od, Address addr)
d1402 1
a1402 1
                                    addr, false, false));
d1408 1
a1408 1
	    Output_data* od, unsigned int shndx, Address addr)
d1411 1
a1411 1
				    addr, false, false));
d1419 1
a1419 1
	             Output_data* od, Address addr)
d1422 1
a1422 1
                                    addr, true, false));
d1428 1
a1428 1
	             Output_data* od, unsigned int shndx, Address addr)
d1431 1
a1431 1
				    addr, true, false));
d1441 1
a1441 1
                    Output_data* od, Address addr)
d1444 1
a1444 1
                                    addr, false, true));
d1450 1
a1450 1
                    Output_data* od, unsigned int shndx, Address addr)
d1453 1
a1453 1
                                    addr, false, true));
d1462 2
a1463 2
		     Output_data* od, Address addr)
  { this->add(od, Output_reloc_type(os, type, od, addr)); }
d1468 2
a1469 2
                     unsigned int shndx, Address addr)
  { this->add(od, Output_reloc_type(os, type, relobj, shndx, addr)); }
d1495 2
a1496 2
	     Address addr, Addend addend)
  { this->add(od, Output_reloc_type(gsym, type, od, addr, addend,
d1502 1
a1502 1
	     unsigned int shndx, Address addr,
d1504 1
a1504 1
  { this->add(od, Output_reloc_type(gsym, type, relobj, shndx, addr,
d1514 2
a1515 2
	              Address addr, Addend addend)
  { this->add(od, Output_reloc_type(gsym, type, od, addr, addend, true)); }
d1520 2
a1521 2
                      unsigned int shndx, Address addr, Addend addend)
  { this->add(od, Output_reloc_type(gsym, type, relobj, shndx, addr,
d1529 1
a1529 1
	    Output_data* od, Address addr, Addend addend)
d1531 1
a1531 1
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, od, addr,
d1538 1
a1538 1
	    Output_data* od, unsigned int shndx, Address addr,
d1542 1
a1542 1
                                    addr, addend, false, false));
d1550 1
a1550 1
	             Output_data* od, Address addr, Addend addend)
d1552 1
a1552 1
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, od, addr,
d1559 1
a1559 1
	             Output_data* od, unsigned int shndx, Address addr,
d1563 1
a1563 1
                                    addr, addend, true, false));
d1573 1
a1573 1
                    Output_data* od, Address addr, Addend addend)
d1575 1
a1575 1
    this->add(od, Output_reloc_type(relobj, input_shndx, type, od, addr,
d1582 1
a1582 1
	             Output_data* od, unsigned int shndx, Address addr,
d1586 1
a1586 1
                                    addr, addend, false, true));
d1593 2
a1594 2
		     Address addr, Addend addend)
  { this->add(os, Output_reloc_type(os, type, od, addr, addend)); }
d1599 2
a1600 2
		     unsigned int shndx, Address addr, Addend addend)
  { this->add(os, Output_reloc_type(os, type, relobj, shndx, addr,
d1869 2
a1870 2
                          unsigned int sec_offset)
  { this->add_entry(Dynamic_entry(tag, od, sec_offset)); }
d1915 2
a1916 2
    Dynamic_entry(elfcpp::DT etag, unsigned int val)
      : tag_(etag), offset_(DYNAMIC_NUMBER)
d1920 2
a1921 2
    Dynamic_entry(elfcpp::DT etag, const Output_data* od, bool section_size)
      : tag_(etag),
d1928 2
a1929 2
    Dynamic_entry(elfcpp::DT etag, const Output_data* od, unsigned int offset)
      : tag_(etag),
d1934 2
a1935 2
    Dynamic_entry(elfcpp::DT etag, const Symbol* sym)
      : tag_(etag), offset_(DYNAMIC_SYMBOL)
d1939 2
a1940 2
    Dynamic_entry(elfcpp::DT etag, const char* str)
      : tag_(etag), offset_(DYNAMIC_STRING)
d2053 3
a2055 3
  Output_relaxed_input_section(Relobj* rel_obj, unsigned int sec_shndx,
			       uint64_t addr_align)
    : Output_section_data_build(addr_align), relobj_(rel_obj), shndx_(sec_shndx)
d2135 1
a2135 1
  set_load_address(uint64_t load_addr)
d2137 1
a2137 1
    this->load_address_ = load_addr;
d2505 2
a2506 2
    Simple_input_section(Relobj *rel_obj, unsigned int sec_shndx)
      : shndx_(sec_shndx)
d2508 2
a2509 2
      gold_assert(sec_shndx != invalid_shndx);
      this->u_.relobj = rel_obj;
d2679 2
a2680 2
  do_is_section_type(elfcpp::Elf_Word sec_type) const
  { return this->type_ == sec_type; }
d2741 10
a2750 10
    Input_section(Relobj* object, unsigned int sec_shndx, off_t datasize,
		  uint64_t addr_align)
      : shndx_(sec_shndx),
	p2align_(ffsll(static_cast<long long>(addr_align)))
    {
      gold_assert(sec_shndx != OUTPUT_SECTION_CODE
		  && sec_shndx != MERGE_DATA_SECTION_CODE
		  && sec_shndx != MERGE_STRING_SECTION_CODE
		  && sec_shndx != RELAXED_INPUT_SECTION_CODE);
      this->u1_.data_size = datasize;
d2810 1
a2810 1
                     uint64_t addr_align) const
d2816 1
a2816 1
              && this->addralign() == addr_align);
d2899 1
a2899 1
    add_input_section(Relobj* object, unsigned int sec_shndx)
d2903 1
a2903 1
      return this->u2_.posd->add_input_section(object, sec_shndx);
d3003 6
a3008 6
    Checkpoint_output_section(uint64_t addr_align, elfcpp::Elf_Xword sflags,
			      const Input_section_list& sinput_sections,
			      off_t first_input_off,
			      bool attached_input_sections_sorted)
      : addralign_(addr_align), flags_(sflags),
	input_sections_(sinput_sections),
d3010 2
a3011 2
	input_sections_copy_(), first_input_offset_(first_input_off),
	attached_input_sections_are_sorted_(attached_input_sections_sorted)
d3101 3
a3103 3
    Fill(off_t section_off, off_t len)
      : section_offset_(section_off),
	length_(convert_to_section_size_type(len))
d3470 1
a3470 1
  set_addresses(uint64_t v_addr, uint64_t p_addr)
d3472 2
a3473 2
    this->vaddr_ = v_addr;
    this->paddr_ = p_addr;
d3480 2
a3481 2
  set_flags(elfcpp::Elf_Word seg_flags)
  { this->flags_ = seg_flags; }
@


1.88
log
@2009-12-02  Rafael Avila de Espindola  <espindola@@google.com>

	* incremental.cc (make_sized_incremental_binary): Set the target.
	Error if it is incompatible.
	* output.h (Output_file): Add filename method.
@
text
@d56 2
a57 2
  Input_section_specifier(const Relobj* relobj, unsigned int shndx)
    : relobj_(relobj), shndx_(shndx)
d419 1
a419 1
  set_data_size(off_t data_size)
d423 1
a423 1
    this->data_size_ = data_size;
d445 1
a445 1
  set_current_data_size_for_child(off_t data_size)
d448 1
a448 1
    this->data_size_ = data_size;
d642 3
a644 3
  Output_section_data(off_t data_size, uint64_t addralign,
		      bool is_data_size_fixed)
    : Output_data(), output_section_(NULL), addralign_(addralign)
d646 2
a647 2
    this->set_data_size(data_size);
    if (is_data_size_fixed)
d651 2
a652 2
  Output_section_data(uint64_t addralign)
    : Output_data(), output_section_(NULL), addralign_(addralign)
d678 1
a678 1
		section_offset_type offset,
d680 1
a680 1
  { return this->do_output_offset(object, shndx, offset, poutput); }
d771 2
a772 2
  Output_section_data_build(uint64_t addralign)
    : Output_section_data(addralign)
d782 2
a783 2
  set_current_data_size(off_t data_size)
  { this->set_current_data_size_for_child(data_size); }
d798 2
a799 2
  Output_data_const(const std::string& data, uint64_t addralign)
    : Output_section_data(data.size(), addralign, true), data_(data)
d802 2
a803 2
  Output_data_const(const char* p, off_t len, uint64_t addralign)
    : Output_section_data(len, addralign, true), data_(p, len)
d806 2
a807 2
  Output_data_const(const unsigned char* p, off_t len, uint64_t addralign)
    : Output_section_data(len, addralign, true),
d837 2
a838 2
			   uint64_t addralign, const char* map_name)
    : Output_section_data(len, addralign, true),
d871 1
a871 1
  Output_data_fixed_space(off_t data_size, uint64_t addralign,
d873 1
a873 1
    : Output_section_data(data_size, addralign, true),
d901 2
a902 2
  explicit Output_data_space(uint64_t addralign, const char* map_name)
    : Output_section_data_build(addralign),
d935 2
a936 2
  Output_data_zero_fill(off_t data_size, uint64_t addralign)
    : Output_section_data(data_size, addralign, true)
d1184 2
a1185 2
	       Address address, Addend addend, bool is_relative)
    : rel_(gsym, type, od, address, is_relative), addend_(addend)
d1190 1
a1190 1
	       unsigned int shndx, Address address, Addend addend,
d1192 1
a1192 1
    : rel_(gsym, type, relobj, shndx, address, is_relative), addend_(addend)
d1199 1
a1199 1
	       Output_data* od, Address address,
d1201 1
a1201 1
    : rel_(relobj, local_sym_index, type, od, address, is_relative,
d1208 1
a1208 1
	       unsigned int shndx, Address address,
d1210 1
a1210 1
    : rel_(relobj, local_sym_index, type, shndx, address, is_relative,
d1218 2
a1219 2
	       Address address, Addend addend)
    : rel_(os, type, od, address), addend_(addend)
d1224 2
a1225 2
	       unsigned int shndx, Address address, Addend addend)
    : rel_(os, type, relobj, shndx, address), addend_(addend)
d1348 2
a1349 2
  add_global(Symbol* gsym, unsigned int type, Output_data* od, Address address)
  { this->add(od, Output_reloc_type(gsym, type, od, address, false)); }
d1354 2
a1355 2
	     unsigned int shndx, Address address)
  { this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
d1361 1
a1361 1
  add_global(Symbol* gsym, unsigned int type, Output_data* od, Address address,
d1365 1
a1365 1
    this->add_global(gsym, type, od, address);
d1371 1
a1371 1
	     unsigned int shndx, Address address, Address addend)
d1374 1
a1374 1
    this->add_global(gsym, type, od, relobj, shndx, address);
d1382 2
a1383 2
                      Address address)
  { this->add(od, Output_reloc_type(gsym, type, od, address, true)); }
d1388 1
a1388 1
                      unsigned int shndx, Address address)
d1390 1
a1390 1
    this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
d1399 1
a1399 1
	    Output_data* od, Address address)
d1402 1
a1402 1
                                    address, false, false));
d1408 1
a1408 1
	    Output_data* od, unsigned int shndx, Address address)
d1411 1
a1411 1
				    address, false, false));
d1419 1
a1419 1
	             Output_data* od, Address address)
d1422 1
a1422 1
                                    address, true, false));
d1428 1
a1428 1
	             Output_data* od, unsigned int shndx, Address address)
d1431 1
a1431 1
				    address, true, false));
d1441 1
a1441 1
                    Output_data* od, Address address)
d1444 1
a1444 1
                                    address, false, true));
d1450 1
a1450 1
                    Output_data* od, unsigned int shndx, Address address)
d1453 1
a1453 1
                                    address, false, true));
d1462 2
a1463 2
		     Output_data* od, Address address)
  { this->add(od, Output_reloc_type(os, type, od, address)); }
d1468 2
a1469 2
                     unsigned int shndx, Address address)
  { this->add(od, Output_reloc_type(os, type, relobj, shndx, address)); }
d1495 2
a1496 2
	     Address address, Addend addend)
  { this->add(od, Output_reloc_type(gsym, type, od, address, addend,
d1502 1
a1502 1
	     unsigned int shndx, Address address,
d1504 1
a1504 1
  { this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
d1514 2
a1515 2
	              Address address, Addend addend)
  { this->add(od, Output_reloc_type(gsym, type, od, address, addend, true)); }
d1520 2
a1521 2
                      unsigned int shndx, Address address, Addend addend)
  { this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
d1529 1
a1529 1
	    Output_data* od, Address address, Addend addend)
d1531 1
a1531 1
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, od, address,
d1538 1
a1538 1
	    Output_data* od, unsigned int shndx, Address address,
d1542 1
a1542 1
                                    address, addend, false, false));
d1550 1
a1550 1
	             Output_data* od, Address address, Addend addend)
d1552 1
a1552 1
    this->add(od, Output_reloc_type(relobj, local_sym_index, type, od, address,
d1559 1
a1559 1
	             Output_data* od, unsigned int shndx, Address address,
d1563 1
a1563 1
                                    address, addend, true, false));
d1573 1
a1573 1
                    Output_data* od, Address address, Addend addend)
d1575 1
a1575 1
    this->add(od, Output_reloc_type(relobj, input_shndx, type, od, address,
d1582 1
a1582 1
	             Output_data* od, unsigned int shndx, Address address,
d1586 1
a1586 1
                                    address, addend, false, true));
d1593 2
a1594 2
		     Address address, Addend addend)
  { this->add(os, Output_reloc_type(os, type, od, address, addend)); }
d1599 2
a1600 2
		     unsigned int shndx, Address address, Addend addend)
  { this->add(os, Output_reloc_type(os, type, relobj, shndx, address,
d1869 2
a1870 2
                          unsigned int offset)
  { this->add_entry(Dynamic_entry(tag, od, offset)); }
d1915 2
a1916 2
    Dynamic_entry(elfcpp::DT tag, unsigned int val)
      : tag_(tag), offset_(DYNAMIC_NUMBER)
d1920 2
a1921 2
    Dynamic_entry(elfcpp::DT tag, const Output_data* od, bool section_size)
      : tag_(tag),
d1928 2
a1929 2
    Dynamic_entry(elfcpp::DT tag, const Output_data* od, unsigned int offset)
      : tag_(tag),
d1934 2
a1935 2
    Dynamic_entry(elfcpp::DT tag, const Symbol* sym)
      : tag_(tag), offset_(DYNAMIC_SYMBOL)
d1939 2
a1940 2
    Dynamic_entry(elfcpp::DT tag, const char* str)
      : tag_(tag), offset_(DYNAMIC_STRING)
d2053 3
a2055 3
  Output_relaxed_input_section(Relobj* relobj, unsigned int shndx,
			       uint64_t addralign)
    : Output_section_data_build(addralign), relobj_(relobj), shndx_(shndx)
d2135 1
a2135 1
  set_load_address(uint64_t load_address)
d2137 1
a2137 1
    this->load_address_ = load_address;
d2505 2
a2506 2
    Simple_input_section(Relobj *relobj, unsigned int shndx)
      : shndx_(shndx)
d2508 2
a2509 2
      gold_assert(shndx != invalid_shndx);
      this->u_.relobj = relobj;
d2679 2
a2680 2
  do_is_section_type(elfcpp::Elf_Word type) const
  { return this->type_ == type; }
d2741 10
a2750 10
    Input_section(Relobj* object, unsigned int shndx, off_t data_size,
		  uint64_t addralign)
      : shndx_(shndx),
	p2align_(ffsll(static_cast<long long>(addralign)))
    {
      gold_assert(shndx != OUTPUT_SECTION_CODE
		  && shndx != MERGE_DATA_SECTION_CODE
		  && shndx != MERGE_STRING_SECTION_CODE
		  && shndx != RELAXED_INPUT_SECTION_CODE);
      this->u1_.data_size = data_size;
d2810 1
a2810 1
                     uint64_t addralign) const
d2816 1
a2816 1
              && this->addralign() == addralign);
d2899 1
a2899 1
    add_input_section(Relobj* object, unsigned int shndx)
d2903 1
a2903 1
      return this->u2_.posd->add_input_section(object, shndx);
d3003 6
a3008 6
    Checkpoint_output_section(uint64_t addralign, elfcpp::Elf_Xword flags,
			      const Input_section_list& input_sections,
			      off_t first_input_offset,
			      bool attached_input_sections_are_sorted)
      : addralign_(addralign), flags_(flags),
	input_sections_(input_sections),
d3010 2
a3011 2
	input_sections_copy_(), first_input_offset_(first_input_offset),
	attached_input_sections_are_sorted_(attached_input_sections_are_sorted)
d3101 3
a3103 3
    Fill(off_t section_offset, off_t length)
      : section_offset_(section_offset),
	length_(convert_to_section_size_type(length))
d3470 1
a3470 1
  set_addresses(uint64_t vaddr, uint64_t paddr)
d3472 2
a3473 2
    this->vaddr_ = vaddr;
    this->paddr_ = paddr;
d3480 2
a3481 2
  set_flags(elfcpp::Elf_Word flags)
  { this->flags_ = flags; }
@


1.87
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d3656 5
@


1.86
log
@2009-10-21  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Update copyright comments.
	(Target_arm): New forward class template declaration.
	(Arm_address): New type.
	(ARM_MAX_FWD_BRANCH_OFFSET, ARM_MAX_BWD_BRANCH_OFFSET,
	THM_MAX_FWD_BRANCH_OFFSET, THM_MAX_BWD_BRANCH_OFFSET,
	THM2_MAX_FWD_BRANCH_OFFSET, THM2_MAX_BWD_BRANCH_OFFSET): New
	constants.
	(Insn_template): Same.
	(DEF_STUBS): New macro.
	(Stub_type): New enum type.
	(Stub_template): New class definition.
	(Stub): Same.
	(Reloc_stub): Same.
	(Stub_factory): Same.
	(Target_arm::Target_arm): Initialize may_use_blx_ and
	should_force_pic_veneer_.
	(Target_arm::may_use_blx, Target_arm::set_may_use_blx,
	Target_arm::should_force_pic_veneer,
	Target_arm::set_should_force_pic_veneer, Target_arm::using_thumb2,
	Target_arm::using_thumb_only, Target_arm:;default_target): New
	method defintions.
	(Target_arm::may_use_blx_, Target_arm::should_force_pic_veneer_):
	New data member declarations.
	(Insn_template::size, Insn_template::alignment): New method defintions.
	(Stub_template::Stub_template): New method definition.
	(Reloc_stub::Key::name, Reloc_stub::stub_type_for_reloc,
	Reloc_stub::do_fixed_endian_write, Reloc_stub::do_write): Same.
	(Stub_factory::Stub_factory): New method definition.
	* gold.h (string_hash): New template.
	* output.h (Input_section_specifier::hash_value): Use
	gold::string_hash.
	(Input_section_specifier::string_hash): Remove.
	* stringpool.cc (Stringpool_template::string_hash): Use
	gold::string_hash.
@
text
@d2381 21
d3342 7
d3359 1
a3359 1
  // beacause it is udpated lazily.  We may need to update it in a
a3363 2
  // Whether code-fills are generated at write.
  bool generate_code_fills_at_write_;
d3432 3
a3434 1
  // Add an Output_section to this segment.
d3436 2
a3437 1
  add_output_section(Output_section* os, elfcpp::Elf_Word seg_flags);
@


1.85
log
@2009-10-20  Doug Kwan  <dougkwan@@google.com>

	* object.cc (Sized_relobj::do_finalize_local_symbols): Handle section
	symbols of relaxed input sections.
	* output.h (Output_section::find_relaxed_input_section): Make
	method public.
@
text
@d78 4
a81 1
  { return this->string_hash(this->relobj_->name().c_str()) ^ this->shndx_; }
a99 12
  // For portability, we use our own string hash function instead of assuming
  // __gnu_cxx::hash or std::tr1::hash is available.  This is the same hash
  // function used in Stringpool_template::string_hash.
  static size_t
  string_hash(const char* s)
  {
    size_t h = 5381;
    while (*s != '\0')
      h = h * 33 + *s++;
    return h;
  }

@


1.84
log
@2009-10-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::make_output_section): Call target hook to make
	ordinary output section.
	(Layout::finalize): Adjust parameter list of call the
	Target::may_relax().
	* layout.h (class Layout::section_list): New method.
	* merge.h (Output_merge_base::entsize): Change visibility to public.
	(Output_merge_base::is_string, Output_merge_base::do_is_string):
	New methods.
	(Output_merge_string::do_is_string): New method.
	* object.cc (Sized_relobj::do_setup): renamed from
	Sized_relobj::set_up.
	* object.h (Sized_relobj::adjust_shndx,
	Sized_relobj::initializ_input_to_output_maps,
	Sized_relobj::free_input_to_output_maps): Change visibilities to
	protected.
	(Sized_relobj::setup): Virtualize.
	(Sized_relobj::do_setup): New method declaration.
	(Sized_relobj::invalidate_section_offset,
	Sized_relobj::do_invalidate_section_offset): New method decfinitions.
	(Sized_relobj::elf_file, Sized_relobj::local_values): New methods.
	* options.cc (parse_int): New function.
	* options.h (parse_int): New declaration.
	(DEFINE_int): New macro.
	(stub_group_size): New option.
	* output.cc (Output_section::Output_section): Initialize memebers
	merge_section_map_, merge_section_by_properties_map_,
	relaxed_input_section_map_, is_relaxed_input_section_map_valid_.
	(Output_section::add_input_section): Handled deferred code-fill
	generation and remove an old comment.
	(Output_section::add_relaxed_input_section): New method definition.
	(Output_section::add_merge_input_section): Use merge section by
	properties map to speed to search.  Update merge section maps
	as appropriate.
	(Output_section::build_relaxation_map): New method definition.
	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Same.
	(Output_section::relax_input_section): Renamed to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of pointers to relaxed sections.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section): New method definitions.
	(Output_section::is_input_address_mapped,
	Output_section::output_offset, Output_section::output_address):
	Use output section data maps to speed up searching.
	(Output_section::find_starting_output_address): Add comments.
	(Output_section::do_write,
	Output_section::write_to_postprocessing_buffer): Do code-fill
	generation as appropriate.
	(Output_section::get_input_sections): Invalidate relaxed input section
	map.
	(Output_section::restore_states): Adjust type of checkpoint .
	Invalidate relaxed input section map.
	* output.h (Output_merge_base): New class declaration.
	(Input_section_specifier): New class defintion.
	(class Output_relaxed_input_section) Change base class to
	Output_section_data_build.
	(Output_relaxed_input_section::Output_relaxed_input_section): Adjust
	base class initializer.
	(Output_section::add_relaxed_input_section): New method declaration.
	(Output_section::Input_section): Change visibility to protected.
     	(Output_section::Input_section::relobj,
	Output_section::Input_section::shndx): Handle relaxed input sections.
	Output_section::input_sections) Change visibility to protected.  Also
	define overload to return a non-const pointer.
	(Output_section::Merge_section_properties): New class defintion.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Relaxation_map): New types.
	(Output_section::relax_input_section): Rename method to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of relaxed section pointers.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section,
	Output_section::build_relaxation_map,
	Output_section::convert_input_sections_in_list_to_relaxed_sections):
	New method declarations.
	(Output_section::merge_section_map_
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_,
	Output_section::generate_code_fills_at_write_): New data members.
	* script-sections.cc
	(Output_section_element_input::set_section_addresses): Call
	current_data_size and addralign methods of relaxed input sections.
	(Orphan_output_section::set_section_addresses): Call current_data_size
	and addralign methods of relaxed input sections.
	* symtab.cc (Symbol_table::compute_final_value): Extract template
	from the body of Symbol_table::sized_finalize_symbol.
	(Symbol_table::sized_finalized_symbol): Call
	Symbol_table::compute_final_value.
	* symtab.h (Symbol_table::Compute_final_value_status): New enum type.
	(Symbol_table::compute_final_value): New templated method declaration.
	* target.cc (Target::do_make_output_section): New method defintion.
	* target.h (Target::make_output_section): New method declaration.
	(Target::relax): Add more parameters for input objects, symbol table
	and layout.  Adjust call to do_relax.
	(Target::do_make_output_section): New method declaration.
	(Target::do_relax): Add parameters for input objects, symbol table
	and layout.
@
text
@d2588 5
a3215 5
  // Find a relaxed input section to an input section in OBJECT
  // with index SHNDX.  Return NULL if none is found.
  const Output_section_data*
  find_relaxed_input_section(const Relobj* object, unsigned int shndx) const;
  
@


1.83
log
@elfcpp/:
	* elfcpp_file.h: Fix header guard.  Include <cstdio>.
	(class Elf_recognizer): New class, code from gold/object.cc.
	(Elf_file::find_section_by_type): New method.
gold/:
	* incremental.cc: Include <cstdarg> and "target-select.h".
	(vexplain_no_incremental): New function.
	(explain_no_incremental): New function.
	(Incremental_binary::error): New method.
	(Sized_incremental_binary::do_find_incremental_inputs_section): New
	method.
	(make_sized_incremental_binary): New function.
	(open_incremental_binary): New function.
	(can_incrementally_link_file): Add checks if output is ELF and has
	inputs section.
	* incremental.h: Include "elfcpp_file.h" and "output.h".
	(Incremental_binary): New class.
	(Sized_incremental_binary): New class.
	(open_incremental_binary): Declare.
	* object.cc (is_elf_object): Use
	elfcpp::Elf_recognizer::is_elf_file.
	(make_elf_object): Use elfcpp::Elf_recognizer::is_valid_header.
	* output.h (Output_file::filesize): New method.
@
text
@d41 1
d50 65
d2056 1
a2056 1
class Output_relaxed_input_section : public Output_section_data
d2064 1
a2064 1
    : Output_section_data(addralign), relobj_(relobj), shndx_(shndx)
d2110 4
d2583 5
a2702 1
 private:
d2818 6
a2823 2
      gold_assert(this->is_input_section());
      return this->u2_.object;
d2830 6
a2835 2
      gold_assert(this->is_input_section());
      return this->shndx_;
d2976 6
d3012 3
a3014 3
    const Input_section_list&
    input_sections() const
    { return this->input_sections_copy_; }
a3064 1
 private:
d3108 76
d3202 1
a3202 1
  // Relax an existing input section.
d3204 1
a3204 1
  relax_input_section(Output_relaxed_input_section*);
d3206 11
a3216 1
  // Sort the attached input sections.
d3218 11
a3228 1
  sort_attached_input_sections();
d3335 12
@


1.82
log
@2009-09-17  Doug Kwan  <dougkwan@@google.com>

	* debug.h (DEBUG_RELAXATION): New constant.
	(DEBUG_ALL): Add DEBUG_RELAXATION.
	(debug_string_to_enum): Add relaxation debug option.
	* layout.cc
	(Layout::Relaxation_debug_check::check_output_data_for_reset_values,
	Layout::Relaxation_debug_check::read_sections,
	Layout::Relaxation_debug_check::read_sections): New method definitions.
	(Layout::Layout): Initialize data members
	record_output_section_data_from_scrips_,
	script_output_section_data_list_ and relaxation_debug_check_.
	(Layout::save_segments, Layout::restore_segments,
	Layout::clean_up_after_relaxation, Layout::prepare_for_relaxation,
	Layout::relaxation_loop_body): New method definitions.
	(Layout::finalize): Support relaxation.  Move section layout code to
	Layout::relaxation_loop_body.
	(Layout::set_asection_address_from_script): Move code for orphan
	section placement out.
	(Layout::place_orphan_sections_in_script): New method definition.
	* layout.h (Output_segment_headers, Output_file_header):
	New forward class declarations.
	(Layout::~Layout): Define.
	(Layout::new_output_section_data_from_script): New method definition.
	(Layout::place_orphan_sections_in_script): New method declaration.
	(Layout::Segment_states): New type declaration.
	(Layout::save_segments, Layout::restore_segments,
	Layout::clean_up_after_relaxation, Layout::prepare_for_relaxation,
	Layout::relaxation_loop_body): New method declarations.
	(Layout::Output_section_data_list): New type declaration.
	(Layout::Relaxation_debug_check): New class definition.
	(Layout::record_output_section_data_from_script_,
	Layout::script_output_section_data_list_, Layout::segment_states_,
	Layout::relaxation_debug_check_): New data members.
	* output.cc: (Output_section_headers::do_size): New method definition.
	(Output_section_headers::Output_section_headers): Move size
	computation to Output_section_headers::do_size.
	(Output_segment_headers::do_size): New method definition.
	(Output_file_header::Output_file_header): Move size computation to
	Output_file_header::do_size and call it.
	(Output_file_header::do_size): New method definition.
	(Output_data_group::Output_data_group): Adjust call to
	Output_section_data.
	(Output_data_dynamic::set_final_data_size): Add DT_NULL tag only once.
	(Output_symtab_xindex::do_write): Add array bound check.
 	(Output_section::Input_section::print_to_mapfile): Handle
	RELAXED_INPUT_SECTION_CODE.
	(Output_section::Output_section): Initialize data member checkpoint_.
	(Output_section::~Output_section): Delete checkpoint object pointed
	by checkpoint_.
	(Output_section::add_input_section): Always add an Input_section if
	relaxing.
	(Output_section::add_merge_input_section): Add assert.
	(Output_section::relax_input_section): New method definition.
	(Output_section::set_final_data_size): Set load address to zero for
	an unallocated section.
	(Output_section::do_address_and_file_offset_have_reset_values):
	New method definition.
	(Output_section::Input_section_sort_enty::Input_section_sort_enty):
	Handle relaxed input section.
	(Output_section::sort_attached_input_sections): Checkpoint input
	section list lazily.
	(Output_section::get_input_sections): Change type of input_sections to
	list of Simple_input_section pointers.  Checkpoint input section list
	lazily.  Also handle relaxed input sections.
	(Output_section::add_input_section_for_script): Take a reference to
	a Simple_input_section object instead of Relobj pointer and section
	index as parameter.  Handle relaxed input sections.
	(Output_section::save_states, Output_section::restore_states): New
	method definitions.
	* output.h (Output_data::Output_data): Initialize is_data_size_fixed_.
	(Output_data::is_data_size_fixed): New method definition.
	(Output_data::reset_addresss_and_file_offset): Do not reset data size
	if it is fixed.
	(Output_data::address_and_file_offset_have_reset_values): New method
	definition.
	(Output_data::do_address_and_file_offset_have_reset_values): New method
	definition.
	(Output_data::set_data_size): Check that data size is not fixed.
	(Output_data::fix_data_size): New method definition.
	(Output_data::is_data_size_fixed_): New data member.
	(Output_section_headers::set_final_data_size): New method definition.
	(Output_section_headers::do_size): New method declaration.
	(Output_segment_headers::set_final_data_size): New method definition.
	(Output_segment_headers::do_size): New method declaration.
	(Output_file_header::set_final_data_size)::New method definition.
	(Output_file_header::do_size)::New method declaration.
	(Output_section_data::Output_section_data): Add new parameter
	is_data_size_fixed and use it to fix data size.
	(Output_data_const::Output_data_const): Adjust call to base class
	constructor and fix data size.
	(Output_data_const_buffer::Output_data_const_buffer): Adjust call to
	base class constructor and fix data size.
	(Output_data_fixed_space::Output_data_fixed_space): Adjust call to
	base class constructor and fix data size.
	(Output_data_zero_fill::Output_data_zero_fill): Adjust call to base
	class constructor and fix data size.
	(Output_data_group::set_final_data_size): New method definition.
	(Output_data_dynamic::Dynamic_entry::tag): New method definition.
	(Output_symtab_xindex::Output_symtab_xindex): Adjust call to base
	class constructor and fix data size.
	(Output_relaxed_input_section): New class definition.
	(Output_section::Simple_input_section): New class definition.
	(Output_section::get_input_sections): Adjust parameter list.
	(Output_section::add_input_section_for_script): Same.
	(Output_section::save_states, Output_section::restore_states,
	Output_section::do_address_and_file_offset_have_reset_values,
	(Output_section::Input_section::Input_section): Handle
	RELAXED_INPUT_SECTION_CODE.  Add new overload for
	Output_relaxed_input_section.
	(Output_section::Input_section::is_input_section,
	Output_section::Input_section::set_output_section): Handle relaxed
	input section.
	(Output_section::Input_section::is_relaxed_input_section,
	Output_section::Input_section::output_section_data,
	Output_section::Input_section::relaxed_input_section): New method
	definitions.
	(Output_section::Input_section::RELAXED_INPUT_SECTION_CODE): New enum
	value.
	(Output_section::Input_section::u1_): Update comments.
	(Output_section::Input_section::u2_): Add new union member poris.
	(Output_section::Checkpoint_output_section): New classs definition.
	(Output_section::relax_input_section): New method declaration.
	(Output_section::checkpoint_): New data member.
	(Output_segment): Update comments.
	(Output_segment::Output_segment): Un-privatize copy constructor.
	(Output_segment::operator=): Un-privatize.
	* script-sections.cc (Output_section_element::Input_section_list):
	Change element type to Output_section::Simple_input_section.
	(Output_section_element_dot_assignment::set_section_addresses):
	Register output section data for relaxation clean up.
	(Output_data_exression::Output_data_expression): Adjust call to base
	constructor to fix data size.
	(Output_section_element_data::set_section_addresses): Register
	Output_data_expression object for relaxation clean up.
	(struct Input_section_info): Replace Relobj pointer and section index
	pair with Output_section::Simple_input_section and Convert struct to a
	class.
	(Input_section_sorter::operator()): Adjust access to
	Input_section_info data member to use accessors.
	(Output_section_element_input::set_section_addresses): Use layout
	parameter.  Adjust code to use Output_section::Simple_input_section
	and Input_secction_info classes.  Register filler for relaxation
	clean up.
	(Orphan_output_section::set_section_addresses): Replace Relobj pointer
	and section index pair with Output_section::Simple_input_section
	class.  Adjust code accordingly.
	(Phdrs_element::release_segment): New method definition.
	(Script_sections::attach_sections_using_phdrs_clause): Do not modify
	segment list.
	(Script_sections::release_segments): New method definition.
	* gold/script-sections.h (Script_sections::release_segments): New
	method declaration.
	* gold/target.h (Target::may_relax, Target::relax,
	Target::do_may_relax, Target::do_relax): New method definitions.
@
text
@d3436 5
@


1.81
log
@	* output.cc (Output_file::open_for_modification): New method.
	(Output_file::map_anonymous): Changed return type to bool.  Record
	map in base_ field.
	(Output_file::map_no_anonymous): New method, broken out of map.
	(Output_file::map): Use map_no_anonymous and map_anonymous.
	* output.h (class Output_file): Update declarations.
@
text
@d57 1
a57 1
      is_offset_valid_(false),
d83 5
d105 2
a106 1
    this->is_data_size_valid_ = false;
d110 6
d326 8
d364 2
a365 1
    gold_assert(!this->is_data_size_valid_);
d370 9
d423 2
d456 5
d467 4
d501 5
d512 4
d549 5
d565 4
d585 2
a586 1
  Output_section_data(off_t data_size, uint64_t addralign)
d588 5
a592 1
  { this->set_data_size(data_size); }
d742 1
a742 1
    : Output_section_data(data.size(), addralign), data_(data)
d746 1
a746 1
    : Output_section_data(len, addralign), data_(p, len)
d750 1
a750 1
    : Output_section_data(len, addralign),
d781 1
a781 1
    : Output_section_data(len, addralign),
d816 1
a816 1
    : Output_section_data(data_size, addralign),
d879 1
a879 1
    : Output_section_data(data_size, addralign)
d1598 5
d1886 5
d1957 1
a1957 1
    : Output_section_data(symcount * 4, 4),
d1989 27
d2414 63
d2485 1
a2485 1
		     std::list<std::pair<Relobj*, unsigned int > >*);
d2489 1
a2489 1
  add_input_section_for_script(Relobj* object, unsigned int shndx,
d2504 9
d2550 5
d2657 2
a2658 1
		  && shndx != MERGE_STRING_SECTION_CODE);
d2682 8
d2711 2
a2712 1
	      && this->shndx_ != MERGE_STRING_SECTION_CODE);
d2728 12
d2756 17
d2778 3
a2780 1
      this->u2_.posd->set_output_section(os);
d2858 3
a2860 1
      MERGE_STRING_SECTION_CODE = -3U
d2874 2
a2875 2
      // For OUTPUT_SECTION_CODE, this is not used.  For
      // MERGE_DATA_SECTION_CODE or MERGE_STRING_SECTION_CODE, the
d2887 2
d2894 84
d3039 4
d3150 2
d3157 6
a3319 3
  Output_segment(const Output_segment&);
  Output_segment& operator=(const Output_segment&);

d3362 3
@


1.81.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a40 1
class Output_merge_base;
a48 65
// This class specifies an input section.  It is used as a key type
// for maps.

class Input_section_specifier
{
 public:
  Input_section_specifier(const Relobj* relobj, unsigned int shndx)
    : relobj_(relobj), shndx_(shndx)
  { }
   
  // Return Relobj of this.
  const Relobj*
  relobj() const
  { return this->relobj_; }

  // Return section index of this.
  unsigned int
  shndx() const
  { return this->shndx_; }

  // Whether this equals to another specifier ISS.
  bool
  eq(const Input_section_specifier& iss) const
  { return this->relobj_ == iss.relobj_ && this->shndx_ == iss.shndx_; }

  // Compute a hash value of this.
  size_t
  hash_value() const
  { return this->string_hash(this->relobj_->name().c_str()) ^ this->shndx_; }

  // Functors for containers.
  struct equal_to
  {
    bool
    operator()(const Input_section_specifier& iss1,
	       const Input_section_specifier& iss2) const
    { return iss1.eq(iss2); }
  };
 
  struct hash
  {
    size_t
    operator()(const Input_section_specifier& iss) const
    { return iss.hash_value(); }
  };

 private:
  // For portability, we use our own string hash function instead of assuming
  // __gnu_cxx::hash or std::tr1::hash is available.  This is the same hash
  // function used in Stringpool_template::string_hash.
  static size_t
  string_hash(const char* s)
  {
    size_t h = 5381;
    while (*s != '\0')
      h = h * 33 + *s++;
    return h;
  }

  // An object.
  const Relobj* relobj_;
  // A section index. 
  unsigned int shndx_;
};

d57 1
a57 1
      is_offset_valid_(false), is_data_size_fixed_(false),
a82 5
  // Return true if data size is fixed.
  bool
  is_data_size_fixed() const
  { return this->is_data_size_fixed_; }
  
d100 1
a100 2
    if (!this->is_data_size_fixed_)
      this->is_data_size_valid_ = false;
a103 6
  // Return true if address and file offset already have reset values. In
  // other words, calling reset_address_and_file_offset will not change them.
  bool
  address_and_file_offset_have_reset_values() const
  { return this->do_address_and_file_offset_have_reset_values(); }

a313 8
  // Return true if address and file offset already have reset values. In
  // other words, calling reset_address_and_file_offset will not change them.
  // A child class overriding do_reset_address_and_file_offset may need to
  // also override this.
  virtual bool
  do_address_and_file_offset_have_reset_values() const
  { return !this->is_address_valid_ && !this->is_offset_valid_; }

d344 1
a344 2
    gold_assert(!this->is_data_size_valid_
		&& !this->is_data_size_fixed_);
a348 9
  // Fix the data size.  Once it is fixed, it cannot be changed
  // and the data size remains always valid. 
  void
  fix_data_size()
  {
    gold_assert(this->is_data_size_valid_);
    this->is_data_size_fixed_ = true;
  }

a392 2
  // Whether data size is fixed.
  bool is_data_size_fixed_;
a423 5
  // Set final data size.
  void
  set_final_data_size()
  { this->set_data_size(this->do_size()); }

a429 4
  // Compute data size.
  off_t
  do_size() const;

a459 5
  // Set final data size.
  void
  set_final_data_size()
  { this->set_data_size(this->do_size()); }

a465 4
  // Compute the current size.
  off_t
  do_size() const;

a498 5
  // Set final data size.
  void
  set_final_data_size(void)
  { this->set_data_size(this->do_size()); }

a509 4
  // Compute the current data size.
  off_t
  do_size() const;

d526 1
a526 2
  Output_section_data(off_t data_size, uint64_t addralign,
		      bool is_data_size_fixed)
d528 1
a528 5
  {
    this->set_data_size(data_size);
    if (is_data_size_fixed)
      this->fix_data_size();
  }
d678 1
a678 1
    : Output_section_data(data.size(), addralign, true), data_(data)
d682 1
a682 1
    : Output_section_data(len, addralign, true), data_(p, len)
d686 1
a686 1
    : Output_section_data(len, addralign, true),
d717 1
a717 1
    : Output_section_data(len, addralign, true),
d752 1
a752 1
    : Output_section_data(data_size, addralign, true),
d815 1
a815 1
    : Output_section_data(data_size, addralign, true)
a1533 5
  // Set final data size.
  void
  set_final_data_size()
  { this->set_data_size((this->input_shndxes_.size() + 1) * 4); }

a1816 5
    // Return the tag of this entry.
    elfcpp::DT
    tag() const
    { return this->tag_; }

d1883 1
a1883 1
    : Output_section_data(symcount * 4, 4, true),
a1914 27
// A relaxed input section.
class Output_relaxed_input_section : public Output_section_data_build
{
 public:
  // We would like to call relobj->section_addralign(shndx) to get the
  // alignment but we do not want the constructor to fail.  So callers
  // are repsonsible for ensuring that.
  Output_relaxed_input_section(Relobj* relobj, unsigned int shndx,
			       uint64_t addralign)
    : Output_section_data_build(addralign), relobj_(relobj), shndx_(shndx)
  { }
 
  // Return the Relobj of this relaxed input section.
  Relobj*
  relobj() const
  { return this->relobj_; }
 
  // Return the section index of this relaxed input section.
  unsigned int
  shndx() const
  { return this->shndx_; }

 private:
  Relobj* relobj_;
  unsigned int shndx_;
};

a1942 4
  // Add a relaxed input section PORIS to this output section.
  void
  add_relaxed_input_section(Output_relaxed_input_section* poris);

a2312 63
  // We need to export the input sections to linker scripts.  Previously
  // we export a pair of Relobj pointer and section index.  We now need to
  // handle relaxed input sections as well.  So we use this class.
  class Simple_input_section
  {
   private:
    static const unsigned int invalid_shndx = static_cast<unsigned int>(-1);

   public:
    Simple_input_section(Relobj *relobj, unsigned int shndx)
      : shndx_(shndx)
    {
      gold_assert(shndx != invalid_shndx);
      this->u_.relobj = relobj;
    }
 
    Simple_input_section(Output_relaxed_input_section* section)
      : shndx_(invalid_shndx)
    { this->u_.relaxed_input_section = section; }

    // Whether this is a relaxed section.
    bool
    is_relaxed_input_section() const
    { return this->shndx_ == invalid_shndx; }

    // Return object of an input section.
    Relobj*
    relobj() const
    {
      return ((this->shndx_ != invalid_shndx)
	      ? this->u_.relobj
	      : this->u_.relaxed_input_section->relobj());
    }

    // Return index of an input section.
    unsigned int
    shndx() const
    {
      return ((this->shndx_ != invalid_shndx)
	      ? this->shndx_
	      : this->u_.relaxed_input_section->shndx());
    }

    // Return the Output_relaxed_input_section object of a relaxed section.
    Output_relaxed_input_section*
    relaxed_input_section() const
    {
      gold_assert(this->shndx_ == invalid_shndx);
      return this->u_.relaxed_input_section;
    }

   private:
    // Pointer to either an Relobj or an Output_relaxed_input_section.
    union
    {
      Relobj* relobj;
      Output_relaxed_input_section* relaxed_input_section;
    } u_;
    // Section index for an non-relaxed section or invalid_shndx for
    // a relaxed section.
    unsigned int shndx_;
  };
 
d2321 1
a2321 1
		     std::list<Simple_input_section>*);
d2325 1
a2325 1
  add_input_section_for_script(const Simple_input_section& input_section,
a2339 14
  // Save states before doing section layout.
  // This is used for relaxation.
  void
  save_states();

  // Restore states prior to section layout.
  void
  restore_states();

  // Convert existing input sections to relaxed input sections.
  void
  convert_input_sections_to_relaxed_sections(
      const std::vector<Output_relaxed_input_section*>& sections);

a2376 5
  // Return true if address and file offset already have reset values. In
  // other words, calling reset_address_and_file_offset will not change them.
  bool
  do_address_and_file_offset_have_reset_values() const;

d2450 1
d2479 1
a2479 2
		  && shndx != MERGE_STRING_SECTION_CODE
		  && shndx != RELAXED_INPUT_SECTION_CODE);
a2502 8
    // For a relaxed input section.
    Input_section(Output_relaxed_input_section *psection)
      : shndx_(RELAXED_INPUT_SECTION_CODE), p2align_(0)
    {
      this->u1_.data_size = 0;
      this->u2_.poris = psection;
    }

d2524 1
a2524 2
	      && this->shndx_ != MERGE_STRING_SECTION_CODE
	      && this->shndx_ != RELAXED_INPUT_SECTION_CODE);
a2539 12
    // Return whether this is a relaxed input section.
    bool
    is_relaxed_input_section() const
    { return this->shndx_ == RELAXED_INPUT_SECTION_CODE; }

    // Return whether this is a generic Output_section_data.
    bool
    is_output_section_data() const
    {
      return this->shndx_ == OUTPUT_SECTION_CODE;
    }

d2544 2
a2545 6
      if (this->is_input_section())
        return this->u2_.object;
      else if (this->is_relaxed_input_section())
	return this->u2_.poris->relobj();
      else
	gold_unreachable();
d2552 2
a2553 23
      if (this->is_input_section())
        return this->shndx_;
      else if (this->is_relaxed_input_section())
	return this->u2_.poris->shndx();
      else
	gold_unreachable();
    }

    // For non-input-sections, return the associated Output_section_data
    // object.
    Output_section_data*
    output_section_data() const
    {
      gold_assert(!this->is_input_section());
      return this->u2_.posd;
    }
 
    // Return the Output_relaxed_input_section object.
    Output_relaxed_input_section*
    relaxed_input_section() const
    {
      gold_assert(this->is_relaxed_input_section());
      return this->u2_.poris;
d2561 1
a2561 3
      Output_section_data *posd = 
        this->is_relaxed_input_section() ? this->u2_.poris : this->u2_.posd;
      posd->set_output_section(os);
d2639 1
a2639 3
      MERGE_STRING_SECTION_CODE = -3U,
      // An Output_section_data for a relaxed input section.
      RELAXED_INPUT_SECTION_CODE = -4U
d2653 2
a2654 2
      // For OUTPUT_SECTION_CODE or RELAXED_INPUT_SECTION_CODE, this is not
      // used.  For MERGE_DATA_SECTION_CODE or MERGE_STRING_SECTION_CODE, the
a2665 2
      // For RELAXED_INPUT_SECTION_CODE, the data.
      Output_relaxed_input_section* poris;
a2670 89
  // Allow a child class to access the input sections.
  const Input_section_list&
  input_sections() const
  { return this->input_sections_; }

 private:
  // We only save enough information to undo the effects of section layout.
  class Checkpoint_output_section
  {
   public:
    Checkpoint_output_section(uint64_t addralign, elfcpp::Elf_Xword flags,
			      const Input_section_list& input_sections,
			      off_t first_input_offset,
			      bool attached_input_sections_are_sorted)
      : addralign_(addralign), flags_(flags),
	input_sections_(input_sections),
	input_sections_size_(input_sections_.size()),
	input_sections_copy_(), first_input_offset_(first_input_offset),
	attached_input_sections_are_sorted_(attached_input_sections_are_sorted)
    { }

    virtual
    ~Checkpoint_output_section()
    { }

    // Return the address alignment.
    uint64_t
    addralign() const
    { return this->addralign_; }

    // Return the section flags.
    elfcpp::Elf_Xword
    flags() const
    { return this->flags_; }

    // Return a reference to the input section list copy.
    Input_section_list*
    input_sections()
    { return &this->input_sections_copy_; }

    // Return the size of input_sections at the time when checkpoint is
    // taken.
    size_t
    input_sections_size() const
    { return this->input_sections_size_; }

    // Whether input sections are copied.
    bool
    input_sections_saved() const
    { return this->input_sections_copy_.size() == this->input_sections_size_; }

    off_t
    first_input_offset() const
    { return this->first_input_offset_; }

    bool
    attached_input_sections_are_sorted() const
    { return this->attached_input_sections_are_sorted_; }

    // Save input sections.
    void
    save_input_sections()
    {
      this->input_sections_copy_.reserve(this->input_sections_size_);
      this->input_sections_copy_.clear();
      Input_section_list::const_iterator p = this->input_sections_.begin();
      gold_assert(this->input_sections_size_ >= this->input_sections_.size());
      for(size_t i = 0; i < this->input_sections_size_ ; i++, ++p)
	this->input_sections_copy_.push_back(*p);
    }

   private:
    // The section alignment.
    uint64_t addralign_;
    // The section flags.
    elfcpp::Elf_Xword flags_;
    // Reference to the input sections to be checkpointed.
    const Input_section_list& input_sections_;
    // Size of the checkpointed portion of input_sections_;
    size_t input_sections_size_;
    // Copy of input sections.
    Input_section_list input_sections_copy_;
    // The offset of the first entry in input_sections_.
    off_t first_input_offset_;
    // True if the input sections attached to this output section have
    // already been sorted.
    bool attached_input_sections_are_sorted_;
  };

a2713 76
  // This class describes properties of merge data sections.  It is used
  // as a key type for maps.
  class Merge_section_properties
  {
   public:
    Merge_section_properties(bool is_string, uint64_t entsize,
			     uint64_t addralign)
      : is_string_(is_string), entsize_(entsize), addralign_(addralign)
    { }

    // Whether this equals to another Merge_section_properties MSP.
    bool
    eq(const Merge_section_properties& msp) const
    {
      return ((this->is_string_ == msp.is_string_)
	      && (this->entsize_ == msp.entsize_)
	      && (this->addralign_ == msp.addralign_));
    }

    // Compute a hash value for this using 64-bit FNV-1a hash.
    size_t
    hash_value() const
    {
      uint64_t h = 14695981039346656037ULL;	// FNV offset basis.
      uint64_t prime = 1099511628211ULL;
      h = (h ^ static_cast<uint64_t>(this->is_string_)) * prime;
      h = (h ^ static_cast<uint64_t>(this->entsize_)) * prime;
      h = (h ^ static_cast<uint64_t>(this->addralign_)) * prime;
      return h;
    }
    
    // Functors for associative containers.
    struct equal_to
    {
      bool
      operator()(const Merge_section_properties& msp1,
		 const Merge_section_properties& msp2) const
      { return msp1.eq(msp2); }
    };

    struct hash
    {
      size_t
      operator()(const Merge_section_properties& msp) const
      { return msp.hash_value(); }
    };

   private:
    // Whether this merge data section is for strings.
    bool is_string_;
    // Entsize of this merge data section.
    uint64_t entsize_;
    // Address alignment.
    uint64_t addralign_;
  };

  // Map that link Merge_section_properties to Output_merge_base.
  typedef Unordered_map<Merge_section_properties, Output_merge_base*,
			Merge_section_properties::hash,
			Merge_section_properties::equal_to>
    Merge_section_by_properties_map;

  // Map that link Input_section_specifier to Output_section_data.
  typedef Unordered_map<Input_section_specifier, Output_section_data*,
			Input_section_specifier::hash,
			Input_section_specifier::equal_to>
    Output_section_data_by_input_section_map;

  // Map used during relaxation of existing sections.  This map
  // an input section specifier to an input section list index.
  // We assume that Input_section_list is a vector.
  typedef Unordered_map<Input_section_specifier, size_t,
			Input_section_specifier::hash,
			Input_section_specifier::equal_to>
    Relaxation_map;

a2735 24
  // Find the merge section into which an input section with index SHNDX in
  // OBJECT has been added.  Return NULL if none found.
  Output_section_data*
  find_merge_section(const Relobj* object, unsigned int shndx) const;

  // Find a relaxed input section to an input section in OBJECT
  // with index SHNDX.  Return NULL if none is found.
  const Output_section_data*
  find_relaxed_input_section(const Relobj* object, unsigned int shndx) const;
  
  // Build a relaxation map.
  void
  build_relaxation_map(
      const Input_section_list& input_sections,
      size_t limit,
      Relaxation_map* map) const;

  // Convert input sections in an input section list into relaxed sections.
  void
  convert_input_sections_in_list_to_relaxed_sections(
      const std::vector<Output_relaxed_input_section*>& relaxed_sections,
      const Relaxation_map& map,
      Input_section_list* input_sections);

a2838 14
  // Saved checkpoint.
  Checkpoint_output_section* checkpoint_;
  // Map from input sections to merge sections.
  Output_section_data_by_input_section_map merge_section_map_;
  // Map from merge section properties to merge_sections;
  Merge_section_by_properties_map merge_section_by_properties_map_;
  // Map from input sections to relaxed input sections.  This is mutable
  // beacause it is udpated lazily.  We may need to update it in a
  // const qualified method.
  mutable Output_section_data_by_input_section_map relaxed_input_section_map_;
  // Whether relaxed_input_section_map_ is valid.
  mutable bool is_relaxed_input_section_map_valid_;
  // Whether code-fills are generated at write.
  bool generate_code_fills_at_write_;
a2843 6
//
// NOTE: We want to use the copy constructor for this class.  During
// relaxation, we may try built the segments multiple times.  We do
// that by copying the original segment list before lay-out, doing
// a trial lay-out and roll-back to the saved copied if we need to
// to the lay-out again.
d3001 3
a3045 3
  // NOTE: We want to use the copy constructor.  Currently, shallow copy
  // works for us so we do not need to write our own copy constructor.
  
a3116 5
  // Return the size of this file.
  off_t
  filesize()
  { return this->file_size_; }

@


1.81.2.2
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@a2389 21
  // True if this is the .interp section which goes into the PT_INTERP
  // segment.
  bool
  is_interp() const
  { return this->is_interp_; }

  // Record that this is the interp section.
  void
  set_is_interp()
  { this->is_interp_ = true; }

  // True if this is a section used by the dynamic linker.
  bool
  is_dynamic_linker_section() const
  { return this->is_dynamic_linker_section_; }

  // Record that this is a section used by the dynamic linker.
  void
  set_is_dynamic_linker_section()
  { this->is_dynamic_linker_section_ = true; }

a3329 7
  // True if this is the .interp section going into the PT_INTERP
  // segment.
  bool is_interp_ : 1;
  // True if this is section is read by the dynamic linker.
  bool is_dynamic_linker_section_ : 1;
  // Whether code-fills are generated at write.
  bool generate_code_fills_at_write_ : 1;
d3340 1
a3340 1
  // because it is updated lazily.  We may need to update it in a
d3345 2
d3415 1
a3415 3
  // Add the Output_section OS to this segment.  SEG_FLAGS is the
  // segment flags to use.  DO_SORT is true if we should sort the
  // placement of the input section for more efficient generated code.
d3417 1
a3417 2
  add_output_section(Output_section* os, elfcpp::Elf_Word seg_flags,
		     bool do_sort);
@


1.80
log
@	PR 10156
	* layout.cc (Layout::choose_output_section): If we find an
	existing section, update the flags.
	(Layout::create_notes): New function, broken out of
	Layout::finalize.
	(Layout::finalize): Don't create note sections.
	(Layout::create_note): Don't crash if linker script discards
	section.
	(Layout::create_gold_note): Likewise.
	(Layout::create_build_id): Likewise.  Don't set
	after_input_sections on the section.
	(Layout::create_executable_stack_info): Remove target parameter.
	Change caller.
	* layout.h (class Layout): Declare create_notes.  Update
	declaration of create_executable_stack_info.
	* gold.cc (queue_middle_tasks): Call create_notes.
	* output.cc (Output_section::update_flags_for_input_section): Move
	here from output.h.  If SHF_ALLOC flag is newly set, mark address
	invalid.
	* output.h (Output_data::mark_address_invalid): New function.
	(class Output_section): Only declare, not define,
	update_flags_for_input_section.  Remove set_flags.
@
text
@d3096 6
d3103 2
d3108 1
a3108 1
  // Resize the output file.
d3113 1
a3113 1
  // there are no errors.
d3164 2
a3165 1
  // Map the file into memory.
d3170 1
a3170 1
  void*
d3173 4
@


1.79
log
@	* layout.cc (Layout::make_output_section): Call
	Target::new_output_section.
	(Layout::attach_allocated_section_to_segment): Put large section
	sections in a separate load segment with the large segment flag
	set.
	(Layout::segment_precedes): Sort large data segments after other
	load segments.
	(align_file_offset): New static function.
	(Layout::set_segment_offsets): Use align_file_offset.
	* output.h (class Output_section): Add is_small_section_ and
	is_large_section_ fields.
	(Output_section::is_small_section): New function.
	(Output_section::set_is_small_section):  New function.
	(Output_section::is_large_section): New function.
	(Output_section::set_is_large_section): New function.
	(Output_section::is_large_data_section): New function.
	(class Output_segment): Add is_large_data_segment_ field.
	(Output_segment::is_large_data_segment): New function.
	(Output_segment::set_is_large_data_segment): New function.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_segment::Output_segment): Likewise.
	(Output_segment::add_output_section): Add assertion that large
	data sections always go in large data segments.  Force small data
	sections to the end of the list of data sections.  Force small BSS
	sections to the start of the list of BSS sections.  For large BSS
	sections to the end of the list of BSS sections.
	* symtab.h (class Symbol): Declare is_common_shndx.
	(Symbol::is_defined): Check Symbol::is_common_shndx.
	(Symbol::is_common): Likewise.
	(class Symbol_table): Define enum Commons_section_type.  Update
	declarations.  Add small_commons_ and large_commons_ fields.
	* symtab.cc (Symbol::is_common_shndx): New function.
	(Symbol_table::Symbol_table): Initialize new fields.
	(Symbol_table::add_from_object): Put small and large common
	symbols in the right list.
	(Symbol_table::sized_finalized_symbol): Check
	Symbol::is_common_shndx.
	(Symbol_table::sized_write_globals): Likewise.
	* common.cc (Symbol_table::do_allocate_commons): Allocate new
	common symbol lists.  Don't call do_allocate_commons_list if the
	list is empty.
	(Symbol_table::do_allocate_commons_list): Remove is_tls
	parameter.  Add comons_section_type parameter.  Change all
	callers.  Handle small and large common symbols.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Check
	Symbol::is_common_shndx.
	* resolve.cc (symbol_to_bits): Likewise.
	* target.h (Target::small_common_shndx): New function.
	(Target::small_common_section_flags): New function.
	(Target::large_common_shndx): New function.
	(Target::large_common_section_flags): New function.
	(Target::new_output_section): New function.
	(Target::Target_info): Add small_common_shndx, large_common_shndx,
	small_common_section_flags, and large_common_section_flags
	fields.
	(Target::do_new_output_section): New virtual function.
	* arm.cc (Target_arm::arm_info): Initialize new fields.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Likewise.
	* sparc.c (Target_sparc::sparc_info) [all versions]: Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	(Target_x86_64::do_new_output_section): New function.
	* configure.ac: Define conditional MCMODEL_MEDIUM.
	* testsuite/Makefile.am (check_PROGRAMS): Add large.
	(large_SOURCES, large_CFLAGS, large_DEPENDENCIES): Define.
	(large_LDFLAGS): Define.
	* testsuite/large.c: New file.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Initialize new fields.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d333 7
a1957 7
  // Set the section flags.  This may only be used with the Layout
  // code when it is prepared to move the section to a different
  // segment.
  void
  set_flags(elfcpp::Elf_Xword flags)
  { this->flags_ = flags; }

d1960 1
a1960 7
  update_flags_for_input_section(elfcpp::Elf_Xword flags)
  {
    this->flags_ |= (flags
		     & (elfcpp::SHF_WRITE
			| elfcpp::SHF_ALLOC
			| elfcpp::SHF_EXECINSTR));
  }
@


1.78
log
@	* output.cc (Output_file::map_anonymous): Define.
	(Output_file::map): Use map_anonymous.  If the regular mmap fails,
	try an anonymous one.  Report the size if the mmap fails.
	* output.h (class Output_file): Declare map_anonymous.
@
text
@d2198 27
d2838 4
d2892 11
d3085 2
@


1.77
log
@	PR 7091
	* output.cc (Output_section::find_starting_output_address): Rename
	from starting_output_address; add PADDR parameter; change return
	type.
	* output.h (class Output_section): Declare
	find_starting_output_address instead of starting_output_address.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Handle a
	section symbol for which we can't find a merge section.
@
text
@d3118 1
a3118 1
  // Map the file into memory and return a pointer to the map.
d3122 4
@


1.76
log
@	* mapfile.cc (Mapfile::print_input_section): Change -1U to -1ULL.
	* object.cc (Sized_relobj::do_layout): Use constant invalid_address
	instead of -1U.
	(Sized_relobj::do_finalize_local_symbols): Likewise.
	(Sized_relobj::map_to_kept_section): Likewise.
	* object.h (Sized_relobj::invalid_address): New constant.
	(Sized_relobj::do_output_section_offset): Check for invalid_address
	and return -1ULL.
	* output.cc (Output_reloc::local_section_offset): Use constant
	invalid_address instead of -1U.
	(Output_reloc::get_address): Likewise.
	(Output_section::output_address): Change -1U to -1ULL.
	* output.h (Output_reloc::invalid_address): New constant.
	* reloc.cc (Sized_relobj::write_sections): Use constant
	invalid_address instead of -1U.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (Symbol_table::sized_finalize_symbol): Handle symbol
	values for merge sections.
	* target-reloc.h (relocate_for_relocatable): Use constant
	invalid_address instead of -1U.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d2263 8
a2270 6
  // Return the output address of the start of the merged section for
  // input section SHNDX in object OBJECT.  This is not necessarily
  // the offset corresponding to input offset 0 in the section, since
  // the section may be mapped arbitrarily.
  uint64_t
  starting_output_address(const Relobj* object, unsigned int shndx) const;
@


1.75
log
@	* layout.cc (Layout::attach_allocated_section_to_segment): Don't
	set tls_segment_ or relro_segment_.
	(Layout::make_output_segment): Set tls_segment_ and relro_segment_
	when appropriate.
	* output.h (Output_section::clear_is_relro): New function.
	* output.cc (Output_segment::add_output_section): Handle SHF_TLS
	sections specially even when output_data_ is empty.
	(Output_segment::maximum_alignment): When first section is relro,
	only force alignment for PT_LOAD segments.
	* script.cc (script_data_segment_align): New function.
	(script_data_segment_relro_end): New function.
	* script-c.h (script_data_segment_align): Declare.
	(script_data_segment_relro_end): Declare.
	* script-sections.h (class Script_sections): Declare
	data_segment_align and data_segment_relro_end.  Add fields
	segment_align_index_ and saw_relro_end_.
	* script-sections.cc (class Sections_element): Add set_is_relro
	virtual function.  Add new bool* parameter to place_orphan_here.
	Add get_output_section virtual function.
	(class Output_section_definition): Add set_is_relro.  Add new
	bool* parameter to place_orphan_here.  Add get_output_section.
	Add is_relro_ field.
	(Output_section_definition::Output_section_definition): Initialize
	evaluated_address_, evaluated_load_address, evaluated_addralign_,
	and is_relro_ fields.
	(Output_section_definition::place_orphan_here): Add is_relro
	parameter.
	(Output_section_definition::set_section_addresses): Set relro for
	output section.
	(Output_section_definition::alternate_constraint): Likewise.
	(class Orphan_output_section): Add new bool* parameter to
	place_orphan_here.  Add get_output_section.
	(Orphan_output_section::place_orphan_here): Add is_relro
	parameter.
	(Script_sections::Script_sections): Initialize
	data_segment_align_index_ and saw_relro_end_.
	(Script_sections::data_segment_align): New function.
	(Script_sections::data_segment_relro_end): New function.
	(Script_sections::place_orphan): Set or clear is_relro.
	(Script_sections::set_section_addresses): Force alignment of first
	TLS section.
	* yyscript.y (exp): Call script_data_segment_align and
	script_data_segment_relro_end.
	* testsuite/relro_script_test.t: New file.
	* testsuite/relro_test.cc (using_script): Declare.
	(t1, t2): Test using_script.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_script_test.
	(relro_script_test_SOURCES): Define.
	(relro_script_test_DEPENDENCIES): Define.
	(relro_script_test_LDFLAGS): Define.
	(relro_script_test_LDADD): Define.
	(relro_script_test.so): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d877 2
d1920 1
a1920 1
  // which applies to this section, or 0 if none, or -1U if more than
@


1.74
log
@	Handle output sections with more than 0x7fffffff bytes.
	* object.h (class Relobj): Change map_to_output_ to
	output_sections_, and just keep a section pointer.  Change all
	uses.  Move comdat group support to Sized_relobj.
	(Relobj::is_section_specially_mapped): Remove.
	(Relobj::output_section): Remove poff parameter.  Change all
	callers.
	(Relobj::output_section_offset): New function.
	(Relobj::set_section_offset): Rewrite.
	(Relobj::map_to_output): Remove.
	(Relobj::output_sections): New function.
	(Relobj::do_output_section_offset): New pure virtual function.
	(Relobj::do_set_section_offset): Likewise.
	(class Sized_relobj): Add section_offsets_ field.  Add comdat
	group support from Relobj.  Update declarations.
	(Sized_relobj::get_output_section_offset): New function.
	(Sized_relobj::do_output_section_offset): New function.
	(Sized_relobj::do_set_section_offset): New function.
	* object.cc (Relobj::output_section_address): Remove.
	(Sized_relobj::Sized_relobj): Initialize new fields.
	(Sized_relobj::include_section_group): Cast find_kept_object to
	Sized_relobj.
	(Sized_relobj::include_linkonce_section): Likewise.
	(Sized_relobj::do_layout): Use separate arrays for output section
	and output offset.
	(Sized_relobj::do_count_local_symbols): Change map_to_output to
	output_sections.
	(Sized_relobj::do_finalize_local_symbols): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_local_symbols): Likewise.
	(map_to_kept_section): Compute output address directly.
	* reloc.cc (Sized_relobj::do_read_relocs): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_sections): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (sized_finalize_symbol): Use output_section_offset.
	* output.h (class Output_reloc): Update declarations.  Change
	u2_.relobj to Sized_relobj*.
	(class Output_data_reloc): Change add functions to use
	Sized_relobj*.
	* output.cc (Output_reloc::Output_reloc): Change relobj to
	Sized_relobj*.
	(Output_reloc::local_section_offset): Change return type to
	Elf_Addr.  Use get_output_section_offset.
	(Output_reloc::get_address): Likewise.
	(Output_section::is_input_address_mapped): Don't call
	is_section_specially_mapped.
	(Output_section::output_offset): Likewise.
	(Output_section::output_address): Likewise.
	(Output_section::starting_output_address): Likewise.
	* copy-relocs.cc (Copy_relocs::copy_reloc): Change object
	parameter to Sized_relobj*.
	(Copy_relocs::need_copy_reloc): Likewise.
	(Copy_relocs::save): Likewise.
	* copy-relocs.h (class Copy_relocs): Update declarations.
	(class Copy_relocs::Copy_reloc_entry): Change constructor to use
	Sized_relobj*.  Change relobj_ field to Sized_relobj*.
	* target-reloc.h (relocate_for_relocatable): Change
	offset_in_output_section type to Elf_Addr.  Change code that uses
	it as well.
	* layout.cc (Layout::layout): Always set *off.
	* mapfile.cc (Mapfile::print_input_section): Use
	output_section_offset.
	* i386.cc (Target_i386::copy_reloc): Change object parameter to
	Sized_relobj*.
	* powerpc.cc (Target_powerpc::copy_reloc): Likewise.
	* sparc.cc (Target_sparc::copy_reloc): Likewise.
	* x86_64.cc (Target_x86_64::copy_reloc): Likewise.
@
text
@d2180 5
@


1.73
log
@	* output.h (Output_section::Input_section): Initialize p2align_ to
	zero for Output_section_data constructors.
	(Output_section::Input_section::addralign): If not an input
	section, return the alignment of the Output_section_data.
	* testsuite/copy_test.cc: New file.
	* testsuite/copy_test_1.cc: New file.
	* testsuite/copy_test_2.cc: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add copy_test.
	(copy_test_SOURCES, copy_test_DEPENDENCIES): New variables.
	(copy_test_LDFLAGS, copy_test_LDADD): New variables.
	(copy_test_1_pic.o, copy_test_1.so): New targets.
	(copy_test_2_pic.o, copy_test_2.so): New targets.
	* testsuite/Makefile.in: Rebuild.
@
text
@d893 2
a894 1
  Output_reloc(Symbol* gsym, unsigned int type, Relobj* relobj,
d914 2
a915 1
  Output_reloc(Output_section* os, unsigned int type, Relobj* relobj,
d936 1
a936 1
  section_offset_type
d1009 1
a1009 1
    Relobj* relobj;
d1058 2
a1059 1
  Output_reloc(Symbol* gsym, unsigned int type, Relobj* relobj,
d1092 2
a1093 1
  Output_reloc(Output_section* os, unsigned int type, Relobj* relobj,
d1222 2
a1223 1
  add_global(Symbol* gsym, unsigned int type, Output_data* od, Relobj* relobj,
d1239 2
a1240 1
  add_global(Symbol* gsym, unsigned int type, Output_data* od, Relobj* relobj,
d1257 2
a1258 1
                      Relobj* relobj, unsigned int shndx, Address address)
d1337 2
a1338 1
		     Relobj* relobj, unsigned int shndx, Address address)
d1370 2
a1371 1
  add_global(Symbol* gsym, unsigned int type, Output_data* od, Relobj* relobj,
d1389 2
a1390 2
                      Relobj* relobj, unsigned int shndx, Address address,
	              Addend addend)
d1467 2
a1468 1
  add_output_section(Output_section* os, unsigned int type, Relobj* relobj,
@


1.72
log
@	* mapfile.cc: New file.
	* mapfile.h: New file.
	* options.h (class General_options): Add -M/--print-map and -Map.
	* options.cc (General_options::finalize): Make -M equivalent to
	-Map -.
	* main.cc: Include <cstdio> and "mapfile.h".
	(main): Open mapfile if requested.
	* gold.cc (class Middle_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(queue_initial_tasks): Add mapfile parameter.  Change caller.
	(queue_middle_tasks): Likewise.
	* gold.h (queue_initial_tasks, queue_middle_tasks): Update
	declarations.
	* archive.cc: Include "mapfile.h".
	(Archive::add_symbols): Add mapfile parameter.  Change all
	callers.  Pass mapfile, symbol, and reason to include_member.
	(Archive::include_all_members): Add mapfile parameter.  Change all
	callers.
	(Archive::include_member): Add mapfile, sym, and why parameters.
	Change all callers.  Report inclusion to map file.
	* archive.h: Include "fileread.h".
	(class Archive): Update declarations.
	(Archive::file): New const method.
	(class Add_archive_symbols): Add mapfile_ field.  Update
	constructor.  Change all callers.
	* readsyms.h (class Read_symbols): Likewise.
	(class Finish_group): Likewise.
	(class Read_script): Likewise.
	* common.cc: Include "mapfile.h".
	(Symbol_table::allocate_commons): Add mapfile parameter.  Change
	all callers.
	(Symbol_table::do_allocate_commons): Likewise.
	(Symbol_table::do_allocate_commons_list): Likewise.  Report common
	symbol allocation to mapfile.
	* common.h (class Allocate_commons_task): Add mapfile_ field.
	Update constructor.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* layout.cc: Include "mapfile.h".
	(Layout_task_runner::run): Print information to mapfile.
	(Layout::create_gold_note): Change Output_data_fixed_space to
	Output_data_zero_fill.
	(Layout::create_build_id): Likewise.
	(Layout::print_to_mapfile): New function.
	* layout.h (class Layout_task_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(class Layout): Declare print_to_mapfile.
	* output.cc (Output_section::Input_section::print_to_mapfile): New
	function.
	(Output_section::add_input_section): If producing a map, always
	add to input_sections_ list.
	(Output_section::do_print_to_mapfile): New function.
	(Output_segment::print_sections_to_mapfile): New function.
	(Output_segment::print_section_list_to_mapfile): New function.
	* output.h: Include "mapfile.h".
	(Output_data::print_to_mapfile): New function.
	(Output_data::do_print_to_mapfile): New virtual function.
	(Output_segment_headers::do_print_to_mapfile): New function.
	(Output_file_header::do_print_to_mapfile): New function.
	(Output_data_const::do_print_to_mapfile): New function.
	(class Output_data_const_buffer): Add map_name_ field.  Update
	constructor.  Change all callers.  Add do_print_to_mapfile
	function.
	(class Output_data_fixed_space): Likewise.
	(class Output_data_space): Likewise.
	(class Output_data_zero_fill): New class.
	(Output_data_strtab::do_print_to_mapfile): New function.
	(Output_data_reloc_base::do_print_to_mapfile): New function.
	(Output_relocatable_relocs::do_print_to_mapfile): New function.
	(Output_data_group::do_print_to_mapfile): New function.
	(Output_data_got::do_print_to_mapfile): New function.
	(Output_data_dynamic::do_print_to_mapfile): New function.
	(Output_symtab_xindex::do_print_to_mapfile): New function.
	(class Output_section): Declare do_print_to_mapflie.  Declare
	print_to_mapfile in Input_section.
	(class Output_segment): Declare new functions.
	* object.h (Sized_relobj::symbol_count): New function.
	* script-sections.cc
	(Output_section_element_dot_assignment::set_section_addresses):
	Change Output_data_fixed_space to Output_data_zero_fill.
	(Output_data_expression::do_print_to_mapfile): New function.
	* script.cc (read_input_script): Add mapfile parameter.  Change
	all callers.
	* script.h (read_input_script): Update declaration.
	* ehframe.h (Eh_frame_hdr::do_print_to_mapfile): New function.
	(Eh_frame::do_print_to_mapfile): New function.
	* merge.h (Output_merge_data::do_print_to_mapfile): New function.
	(Output_merge_string::do_print_to_mapfile): New function.
	* i386.cc (Output_data_plt_i386::do_print_to_mapfile): New
	function.
	* sparc.cc (Output_data_plt_sparc::do_print_to_mapfile): New
	function.
	* x86_64.cc (Output_data_plt_x86_64::do_print_to_mapfile): New
	function.
	* Makefile.am (CCFILES): Add mapfile.cc.
	(HFILES): Add mapfile.h.
	* Makefile.in: Rebuild.
@
text
@d2446 1
a2446 2
      : shndx_(OUTPUT_SECTION_CODE),
	p2align_(ffsll(static_cast<long long>(posd->addralign())))
d2457 1
a2457 1
	p2align_(ffsll(static_cast<long long>(posd->addralign())))
d2467 2
@


1.71
log
@	* options.h (class General_options): Add -z relro.
	* layout.cc (Layout::Layout): Initialize relro_segment_.
	(Layout::add_output_section_data): Return the output section.
	(Layout::make_output_section): Rcognize relro sections and mark
	them appropriately.
	(Layout::attach_allocated_section_to_segment): Put relro sections
	in a PT_GNU_RELRO segment.
	(Layout::create_initial_dynamic_sections): Mark the .dynamic
	section as relro.
	(Layout::segment_precedes): Sort PT_GNU_RELRO segments after
	PT_TLS segments.
	(Layout::linkonce_mapping): Map d.rel.ro.local to
	.data.rel.ro.local.
	(Layout::output_section_name): Us .data.rel.ro.local for any
	section which begins with that.
	* layout.h (class Layout): Update add_output_section_data
	declaration.  Add relro_segment_ field.
	* output.cc (Output_section::Output_section): Initialize is_relro_
	and is_relro_local_ fields.
	(Output_segment::add_output_section): Group relro sections.
	(Output_segment::is_first_section_relro): New function.
	(Output_segment::maximum_alignment): If there is a relro section,
	align the segment to the common page size.
	(Output_segment::set_section_addresses): Track whether we are
	looking at relro sections.  If the last section is a relro
	section, align to the common page size.
	(Output_segment::set_section_list_addresses): Add in_relro
	parameter.  Change all callers.  Align to the page size when
	moving from relro to non-relro section.
	(Output_segment::set_offset): Align memsz of a PT_GNU_RELRO
	segment.
	* output.h (class Output_section): Add is_relro_ and
	is_relro_local_ fields.
	(Output_section::is_relro): New function.
	(Output_section::set_is_relro): New function.
	(Output_section::is_relro_local): New function.
	(Output_section::set_is_relro_local): New function.
	(class Output_segment): Update declarations.
	* i386.cc (Target_i386::got_section): Mark .got section as relro.
	* sparc.cc (Target_sparc::got_section): Likewise.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/relro_test_main.cc: New file.
	* testsuite/relro_test.cc: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_test.
	(relro_test_SOURCES, relro_test_DEPENDENCIES): New variables.
	(relro_test_LDFLAGS, relro_test_LDADD): New variables.
	(relro_test.so, relro_test_pic.o): New targets.
	* testsuite/Makefile.in: Rebuild.
@
text
@d30 1
d244 5
d325 6
d412 5
d448 5
d487 5
d693 5
d709 3
a711 2
			   uint64_t addralign)
    : Output_section_data(len, addralign), p_(p)
d724 5
d730 1
d732 3
d743 4
a746 2
  Output_data_fixed_space(off_t data_size, uint64_t addralign)
    : Output_section_data(data_size, addralign)
d755 10
d773 3
a775 2
  explicit Output_data_space(uint64_t addralign)
    : Output_section_data_build(addralign)
d789 32
d847 5
d1151 10
d1485 5
d1510 5
d1617 5
d1759 5
d1877 5
d2392 4
d2573 4
d2940 4
d2986 4
@


1.70
log
@	* output.cc (Output_segment::add_output_section): Remove front
	parameter.
	* output.h (class Output_segment): Remove
	add_initial_output_section and overloaded add_output_section.
	Update declaration of remaining add_output_section.
	* layout.cc (Layout::create_interp): Call add_output_section
	rather than add_initial_output_section.
	(Layout::finish_dynamic_section): Likewise.
@
text
@d2031 23
d2652 4
d2815 4
d2823 1
a2823 1
                             bool* in_tls);
@


1.69
log
@	* output.cc (Output_reloc::get_address): Change return type to
	Elf_Addr.
	* output.h (class Output_reloc): Update get_address declaration.
	* x86_64.cc (Output_data_plt_x86_64::do_write): Use 64-bit types
	for section addresses.
@
text
@d2685 1
a2685 7
  add_output_section(Output_section* os, elfcpp::Elf_Word seg_flags)
  { this->add_output_section(os, seg_flags, false); }

  // Add an Output_section to the start of this segment.
  void
  add_initial_output_section(Output_section* os, elfcpp::Elf_Word seg_flags)
  { this->add_output_section(os, seg_flags, true); }
a2783 5
  // Add an Output_section to this segment, specifying front or back.
  void
  add_output_section(Output_section*, elfcpp::Elf_Word seg_flags,
		     bool front);

@


1.68
log
@Correct last patch.
@
text
@d881 1
a881 1
  section_offset_type
@


1.67
log
@2008-05-05  Ian Lance Taylor  <iant@@google.com>

	* options.h (DEFINE_bool): For DASH_Z, create the negative option
	as noVARNAME rather than no-VARNAME.
	(class General_options): Add option -z combreloc.
	* output.h (class Output_reloc) [SHT_REL]: Declare compare and
	get_address.
	(Output_reloc::sort_before) [SHT_REL]: New function.
	(Output_reloc::sort_before) [SHT_RELA]: New function.
	(class Output_data_reloc_base): Add sort_relocs_ field.  Define
	Sort_relocs_comparison.
	(Output_data_reloc_base::Output_data_reloc_base): Add sort_relocs
	parameter.  Change all callers.
	(Output_data_reloc::Output_data_reloc) [both versions]: Add
	sort_relocs parameter.  Change all callers.
	* output.cc (Output_reloc::get_address): New function, broken out
	of write_rel.
	(Output_reloc::write_rel): Call it.
	(Output_reloc::compare): New function.
	(Output_data_reloc_base::do_write): Optionally sort relocs.
@
text
@d1014 2
a1016 2
    else if (i > 0)
      return true;
@


1.66
log
@	* object.cc (Sized_relobj::include_section_group): Adjust section
	indexes read from group data.  Build vector to pass to
	layout_group.
	* layout.cc (Layout::layout_group): Add flags and shndxes
	parameters.  Remove contents parameter.  Change caller.  Update
	explicit instantiations.
	* layout.h (class Layout): Update layout_group declaration.
	* output.cc (Output_data_group::Output_data_group): Add flags and
	input_shndxes parameters.  Remove contents parameter.  Change
	caller.
	(Output_data_group::do_write): Change input_sections_ to
	input_shndxes_.
	* output.h (class Output_data_group): Update constructor
	declaration.  Rename input_sections_ to input_shndxes_.
	* testsuite/many_sections_test.cc: Add template.
@
text
@d858 13
d880 4
d1006 15
d1045 3
a1047 2
  Output_data_reloc_base()
    : Output_section_data_build(Output_data::default_alignment_for_size(size))
d1071 9
d1081 3
d1105 2
a1106 2
  Output_data_reloc()
    : Output_data_reloc_base<elfcpp::SHT_REL, dynamic, size, big_endian>()
d1247 2
a1248 2
  Output_data_reloc()
    : Output_data_reloc_base<elfcpp::SHT_RELA, dynamic, size, big_endian>()
@


1.65
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1349 1
d1352 2
a1353 1
		    const elfcpp::Elf_Word* contents);
d1364 1
a1364 1
  std::vector<unsigned int> input_sections_;
@


1.64
log
@	* copy-relocs.cc: New file.
	* copy-relocs.h: New file.
	* reloc.cc: Remove Copy_relocs code.
	* reloc.h: Likewise.
	* reloc-types.h (struct Reloc_types) [both versions]: Add
	get_reloc_addend_noerror.
	* output.h (class Output_data_reloc<elfcpp::SHT_REL>): Add
	variants of add_global which take an addend which must be zero.
	* i386.cc: Include "copy-relocs.h".
	(class Target_i386): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_i386::copy_reloc): Rewrite to pass to Copy_relocs class.
	Change all callers.
	(Target_i386::do_finalize_sections): Change handling of
	copy_relocs_.
	* sparc.cc: Include "copy-relocs.h".
	(class Target_sparc): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_sparc::copy_reloc): Rewrite to pass to Copy_relocs class.
	Change all callers.
	(Target_sparc::do_finalize_sections): Change handling of
	copy_relocs_.
	* x86_64.cc: Include "copy-relocs.h".
	(class Target_x86_64): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_x86_64::copy_reloc): Rewrite to pass to Copy_relocs
	class.  Change all callers.
	(Target_x86_64::do_finalize_sections): Change handling of
	copy_relocs_.
	* Makefile.am (CCFILES): Add copy-relocs.cc.
	(HFILES): Add copy-relocs.h.
@
text
@d387 2
a388 1
			 const Stringpool*);
d411 1
d1687 35
d1901 5
@


1.63
log
@	* layout.cc (Layout::Layout): Initialize sections_are_attached_.
	(Layout::get_output_section): Ignore SHF_WRITE and SHF_EXECINSTR
	in the name/type/flags to section mapping.  Don't call
	allocate_output_section.
	(Layout::choose_output_section): Change parameter from adjust_name
	to is_input_section.  Don't permit input sections after sections
	are attached to segments.  Don't call allocate_output_section.
	(Layout::layout_eh_frame): Call update_flags_for_input_section,
	not write_enable_output_section.
	(Layout::make_output_section): Don't push to
	unattached_section_list_ nor call attach_to_segment.  Call
	attach_section_to_segment if sections are attached.
	(Layout::attach_sections_to_segments): New function.
	(Layout::attach_section_to_segment): New function.
	(Layout::attach_allocated_section_to_segment): Rename from
	attach_to_segment.  Remove flags parameter.
	(Layout::allocate_output_section): Remove function.
	(Layout::write_enable_output_section): Remove function.
	* layout.h (class Layout): Update for above changes.  Add new
	field sections_are_attached_.
	* output.h (Output_section::update_flags_for_input_section): New
	function.
	* output.cc (Output_section::add_input_section): Call
	update_flags_for_input_section.
	* gold.cc (queue_middle_tasks): Call attach_sections_to_segments.
@
text
@d1074 18
@


1.62
log
@	* output.h (class Output_section_data): Remove inline definition
	of set_addralign.
	* output.cc (Output_section_data::set_addralign): New function.
@
text
@d1717 10
@


1.61
log
@2008-04-11  Cary Coutant  <ccoutant@@google.com>

	Add support for TLS descriptors for i386 and x86_64.
	* i386.cc (Target_i386::Relocate::tls_desc_gd_to_ie): New function.
	(Target_i386::Relocate::tls_desc_gd_to_le): New function.
	(Target_i386::Got_type): Add GOT_TYPE_TLS_NOFFSET and
	GOT_TYPE_TLS_DESC.
	(Target_i386::got_mod_index_entry): Remove unnecessary code.
	(Target_i386::Scan::local): Implement R_386_TLS_GOTDESC and
	R_386_TLS_DESC_CALL relocations.  Fix problem with initial-exec
	relocations.
	(Target_i386::Scan::global): Fix problem with GD-to-IE relaxation.
	Implement R_386_TLS_GOTDESC and R_386_TLS_DESC_CALL relocations;
	Fix problem with initial-exec relocations.
	(Target_i386::Relocate::relocate_tls): Likewise.
	(Target_i386::Relocate::tls_gd_to_ie): Fix problem with GD-to-IE
	relaxation.
	* output.cc (Output_data_dynamic::Dynamic_entry::write): Add
	support for section-plus-offset dynamic table entries.
	* output.h (Output_data_dynamic::add_section_plus_offset): New function.
	(Output_data_dynamic::Dynamic_entry): Add support for
	section-plus-offset dynamic table entries.
	(Output_data_dynamic::Classification): Likewise.
	(Output_data_dynamic::classification_): Renamed offset_.
	* x86_64.cc (Target_x86_64::Relocate::tls_desc_gd_to_ie): New function.
	(Target_x86_64::Relocate::tls_desc_gd_to_le): New function.
	(Target_x86_64::make_plt_section): New function.
	(Target_x86_64::reserve_tlsdesc_entries): New function.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Add new parameter.
	(Output_data_plt_x86_64::reserve_tlsdesc_entry): New function.
	(Output_data_plt_x86_64::has_tlsdesc_entry): New function.
	(Output_data_plt_x86_64::get_tlsdesc_got_offset): New function.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset): New function.
	(Output_data_plt_x86_64::tlsdesc_plt_entry): New field.
	(Output_data_plt_x86_64::set_final_data_size): Move out of line;
	add extra PLT entry for TLS descriptors.
	(Output_data_plt_x86_64::got_): New field.
	(Output_data_plt_x86_64::tlsdesc_got_offset_): New field.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Initialize new
	fields.
	(Output_data_plt_x86_64::do_write): Write extra PLT entry for TLS
	descriptors.
	(Target_x86_64::make_plt_entry): Factor out make_plt_section.
	(Target_x86_64::got_mod_index_entry): Remove unnecessary code.
	(Target_x86_64::Scan::local): Implement R_386_TLS_GOTDESC and
	R_386_TLS_DESC_CALL relocations.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::do_finalize_sections): Add dynamic table entries
	for TLS descriptors.
	(Relocate::relocate_tls): Fix problem with GD-to-IE relaxation.
	Implement R_386_TLS_GOTDESC and R_386_TLS_DESC_CALL relocations.
	(Target_x86_64::Relocate::tls_gd_to_ie): Fix problem with
	GD-to-IE relaxation.
	* configure.ac: Export new conditional variables TLS_GNU2_DIALECT
	and TLS_DESCRIPTORS.
	* Makefile.in: Rebuild.
	* configure: Rebuild.
	* testsuite/Makefile.am (tls_shared_gd_to_ie_test): New target.
	(tls_test_shared2.so): New target.
	(tls_shared_gd_to_ie_test_SOURCES): New variable.
	(tls_shared_gd_to_ie_test_DEPENDENCIES): New variable.
	(tls_shared_gd_to_ie_test_LDFLAGS): New variable.
	(tls_shared_gd_to_ie_test_LDADD): New variable.
	(tls_shared_gnu2_gd_to_ie_test): New target.
	(tls_test_gnu2.o, tls_test_file2_gnu2.o, tls_test_gnu2_shared2.so):
	New targets.
	(tls_shared_gnu2_gd_to_ie_test_SOURCES): New variable.
	(ls_shared_gnu2_gd_to_ie_test_DEPENDENCIES): New variable.
	(tls_shared_gnu2_gd_to_ie_test_LDFLAGS): New variable.
	(tls_shared_gnu2_gd_to_ie_test_LDADD): New variable.
	(tls_shared_gnu2_test): New target.
	(tls_test_gnu2_shared.so): New target.
	(tls_shared_gnu2_test_SOURCES): New variable.
	(tls_shared_gnu2_test_DEPENDENCIES): New variable.
	(tls_shared_gnu2_test_LDFLAGS): New variable.
	(tls_shared_gnu2_test_LDADD): New variable.
	* testsuite/Makefile.in: Rebuild.
	* testsuite/Makefile.
@
text
@d598 1
a598 2
  set_addralign(uint64_t addralign)
  { this->addralign_ = addralign; }
@


1.60
log
@	* output.cc (Output_reloc<SHT_REL>::local_section_offset): Add
	addend parameter.  Change caller.  Handle merge sections.
	(Output_reloc<SHT_REL>::symbol_value): Change parameter type from
	Address to Addend.  Don't add in the result of
	local_section_offset, pass down the addend and use the returned
	value.
	* output.h (class Output_reloc<SHT_REL>): Add Addend typedef.
	Update declarations of local_section_offset and symbol_value.
	* testsuite/two_file_test_1.cc (t18): New function.
	* testsuite/two_file_test_2.cc (f18): New function.
	* testsuite/two_file_test_main.cc (main): Call t18.
	* testsuite/two_file_test.h (t18, f18): Declare.
@
text
@d1537 7
d1583 1
a1583 1
      : tag_(tag), classification_(DYNAMIC_NUMBER)
d1589 9
a1597 3
	classification_(section_size
			? DYNAMIC_SECTION_SIZE
			: DYNAMIC_SECTION_ADDRESS)
d1602 1
a1602 1
      : tag_(tag), classification_(DYNAMIC_SYMBOL)
d1607 1
a1607 1
      : tag_(tag), classification_(DYNAMIC_STRING)
d1616 1
d1619 2
d1622 1
a1622 3
      DYNAMIC_NUMBER,
      // Section address.
      DYNAMIC_SECTION_ADDRESS,
d1624 1
a1624 1
      DYNAMIC_SECTION_SIZE,
d1626 1
a1626 1
      DYNAMIC_SYMBOL,
d1628 2
a1629 1
      DYNAMIC_STRING
d1636 1
a1636 1
      // For DYNAMIC_SECTION_ADDRESS and DYNAMIC_SECTION_SIZE.
d1645 2
a1646 2
    // The type of entry.
    Classification classification_;
@


1.59
log
@	* layout.cc (Layout::layout): If we see an input section with a
	name that needs sorting, set the must_sort flag for the output
	section.
	(Layout::make_output_section): If the name of the output section
	indicates that it might	require sorting, set the may_sort flag.
	* output.h (Output_section::may_sort_attached_input_sections): New
	function.
	(Output_section::set_may_sort_attached_input_sections): New
	function.
	(Output_section::must_sort_attached_input_sections): New
	function.
	(Output_section::set_must_sort_attached_input_sections): New
	function.
	(class Output_section): Declare Input_section_sort_entry.  Define
	Input_section_sort_compare.  Declare
	sort_attached_input_sections.  Add new fields:
	may_sort_attached_input_sections_,
	must_sort_attached_input_sections_,
	attached_input_sections_are_sorted_.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_section::add_input_section): Add an entry to
	input_sections_ if may_sort or must_sort are true.
	(Output_section::set_final_data_size): Call
	sort_attached_input_sections if necessary.
	(Output_section::Input_section_sort_entry): Define new class.
	(Output_section::Input_section_sort_compare::operator()): New
	function.
	(Output_section::sort_attached_input_sections): New function.
	* configure.ac: Check whether the compiler supports constructor
	priorities.  Define a CONSTRUCTOR_PRIORITY automake conditional.
	* testsuite/initpri1.c: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add initpri1 if
	CONSTRUCTOR_PRIORITY.
	(initpri1_SOURCES, initpri1_DEPENDENCIES): New variables.
	(initpri1_LDFLAGS): New variable.
	* configure, Makefile.in, testsuite/Makefile.in: Rebuild.
@
text
@d782 1
d839 2
a840 1
  // section within the output section.
d842 1
a842 1
  local_section_offset() const;
d847 1
a847 1
  symbol_value(Address addend) const;
@


1.58
log
@	* i386.cc (Target_i386::Got_type): New enum declaration.
	(Target_i386::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocate::relocate_tls): Likewise.
	* object.h (Got_offset_list): New class.
	(Sized_relobj::local_has_got_offset): Added got_type parameter.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::local_has_tls_got_offset): Removed.
	(Sized_relobj::local_tls_got_offset): Removed.
	(Sized_relobj::set_local_tls_got_offset): Removed.
	(Sized_relobj::Local_got_offsets): Changed to store a list of offsets.
	* output.cc (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* output.h (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* resolve.cc (Symbol::override_base_with_special): Removed
	reference to has_got_offset_ field.
	* symtab.cc (Symbol::init_fields): Replaced initialization
	of got_offset_ with got_offsets_.  Removed initialization
	of has_got_offset_
	*symtab.h (Symbol::has_got_offset): Aded got_type parameter.
	(Symbol::got_offset): Likewise.
	(Symbol::set_got_offset): Likewise.
	(Symbol::has_tls_got_offset): Removed.
	(Symbol::tls_got_offset): Removed.
	(Symbol::set_tls_got_offset): Removed.
	(Symbol::got_offset_): Removed.
	(Symbol::tls_mod_got_offset_): Removed.
	(Symbol::tls_pair_got_offset_): Removed.
	(Symbol::got_offsets_): New field.
	(Symbol::has_got_offset): Removed.
	(Symbol::has_tls_mod_got_offset): Removed.
	(Symbol::has_tls_pair_got_offset): Removed.
	* x86_64.cc (Target_x86_64::Got_type): New enum declaration.
	(Target_x86_64::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocate::relocate_tls): Likewise.
@
text
@d1872 26
d2339 11
d2400 4
d2487 9
@


1.57
log
@Make sure the start and size of the TLS segment are aligned.
@
text
@d1365 1
a1365 1
  add_global(Symbol* gsym);
d1370 2
a1371 1
  add_global_with_rel(Symbol* gsym, Rel_dyn* rel_dyn, unsigned int r_type);
d1374 14
a1387 1
  add_global_with_rela(Symbol* gsym, Rela_dyn* rela_dyn, unsigned int r_type);
d1393 2
a1394 1
  add_local(Sized_relobj<size, big_endian>* object, unsigned int sym_index);
d1396 1
a1396 1
  // Add an entry for a global symbol to the GOT, and add a dynamic
d1400 2
a1401 2
                     unsigned int sym_index, Rel_dyn* rel_dyn,
                     unsigned int r_type);
d1405 2
a1406 25
                      unsigned int sym_index, Rela_dyn* rela_dyn,
                      unsigned int r_type);

  // Add an entry (or pair of entries) for a global TLS symbol to the GOT.
  // Return true if this is a new GOT entry, false if the symbol was
  // already in the GOT.
  bool
  add_global_tls(Symbol* gsym, bool need_pair);

  // Add an entry for a global TLS symbol to the GOT, and add a dynamic
  // relocation of type R_TYPE.
  void
  add_global_tls_with_rel(Symbol* gsym, Rel_dyn* rel_dyn,
                          unsigned int r_type);

  void
  add_global_tls_with_rela(Symbol* gsym, Rela_dyn* rela_dyn,
                           unsigned int r_type);

  // Add a pair of entries for a global TLS symbol to the GOT, and add
  // dynamic relocations of type MOD_R_TYPE and DTV_R_TYPE, respectively.
  void
  add_global_tls_with_rel(Symbol* gsym, Rel_dyn* rel_dyn,
                          unsigned int mod_r_type,
                          unsigned int dtv_r_type);
d1408 2
d1411 10
a1420 27
  add_global_tls_with_rela(Symbol* gsym, Rela_dyn* rela_dyn,
                           unsigned int mod_r_type,
                           unsigned int dtv_r_type);

  // Add an entry (or pair of entries) for a local TLS symbol to the GOT.
  // This returns true if this is a new GOT entry, false if the symbol
  // already has a GOT entry.
  bool
  add_local_tls(Sized_relobj<size, big_endian>* object,
		unsigned int sym_index, bool need_pair);

  // Add an entry (or pair of entries) for a local TLS symbol to the GOT,
  // and add a dynamic relocation of type R_TYPE for the first GOT entry.
  // Because this is a local symbol, the first GOT entry can be relocated
  // relative to a section symbol, and the second GOT entry will have an
  // dtv-relative value that can be computed at link time.
  void
  add_local_tls_with_rel(Sized_relobj<size, big_endian>* object,
                         unsigned int sym_index, unsigned int shndx,
                         bool need_pair, Rel_dyn* rel_dyn,
                         unsigned int r_type);

  void
  add_local_tls_with_rela(Sized_relobj<size, big_endian>* object,
                         unsigned int sym_index, unsigned int shndx,
                         bool need_pair, Rela_dyn* rela_dyn,
                         unsigned int r_type);
@


1.56
log
@Fix handling of RELA relative relocs against local symbols in merge
sections.
@
text
@d2585 1
a2585 1
  set_section_addresses(bool reset, uint64_t addr, off_t* poff,
d2641 3
a2643 2
  set_section_list_addresses(bool reset, Output_data_list*, uint64_t addr,
			     off_t* poff, unsigned int* pshndx);
@


1.55
log
@Update copyright years.  Update language files.
@
text
@d842 2
a843 2
  // Get the value of the symbol referred to by a Rel relocation.

d845 1
a845 1
  symbol_value() const;
@


1.54
log
@Combine read-only .eh_frame sections with read-write .eh_frame
sections.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.53
log
@Remove gcc 3.2 compatibility hacks.
@
text
@d1717 7
d2532 5
@


1.52
log
@Implement -Tdata and -Tbss.
@
text
@d1621 1
a1621 1
    write(unsigned char* pov, const Stringpool* ACCEPT_SIZE_ENDIAN) const;
d2610 1
a2610 1
			unsigned int* pshndx ACCEPT_SIZE_ENDIAN) const;
d2652 1
a2652 1
			     unsigned int* pshdx ACCEPT_SIZE_ENDIAN) const;
@


1.51
log
@Support dynamic relocations against local section symbols.
@
text
@d2531 6
@


1.50
log
@Track sections for expressions.
@
text
@d770 3
a772 3
// A relocation can be against a global symbol, a local symbol, an
// output section, or the undefined symbol at index 0.  We represent
// the latter by using a NULL global symbol.
d789 5
d802 1
a802 1
  // A reloc against a local symbol.
d806 2
a807 1
	       Output_data* od, Address address, bool is_relative);
d811 2
a812 1
	       unsigned int shndx, Address address, bool is_relative);
d827 15
d856 5
a860 2
  // Return the symbol index.  We can't do a double template
  // specialization, so we do a secondary template here.
d877 5
a881 4
    // For a local symbol, the object.  We will never generate a
    // relocation against a local symbol in a dynamic object; that
    // doesn't make sense.  And our callers will always be
    // templatized, so we use Sized_relobj here.
d883 3
a885 2
    // For a global symbol, the symbol.  If this is NULL, it indicates
    // a relocation against the undefined 0 symbol.
d887 2
a888 1
    // For a relocation against an output section, the output section.
d893 2
a894 2
    // If shndx_ is not INVALID CODE, the object which holds the input
    // section being used to specify the reloc address.
d896 1
a896 1
    // If shndx_ is INVALID_CODE, the output data being used to
d903 6
a908 2
  // For a local symbol, the local symbol index.  This is GSYM_CODE
  // for a global symbol, or INVALID_CODE for an uninitialized value.
d911 1
a911 1
  unsigned int type_ : 31;
d914 2
d955 3
a957 2
	       Addend addend, bool is_relative)
    : rel_(relobj, local_sym_index, type, od, address, is_relative),
d964 3
a966 2
	       Addend addend, bool is_relative)
    : rel_(relobj, local_sym_index, type, shndx, address, is_relative),
d1049 1
a1049 1
 private: 
d1084 4
a1087 2
  { this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address,
                                    true)); }
d1095 4
a1098 2
  { this->add(od, Output_reloc_type(relobj, local_sym_index, type, od,
                                    address, false)); }
d1104 4
a1107 2
  { this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
				    address, false)); }
d1115 4
a1118 2
  { this->add(od, Output_reloc_type(relobj, local_sym_index, type, od,
                                    address, true)); }
d1124 26
a1149 2
  { this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
				    address, true)); }
d1172 1
a1172 1
 private: 
d1225 1
a1225 1
				    addend, false));
d1235 1
a1235 1
                                    address, addend, false));
d1246 1
a1246 1
				    addend, true));
d1256 24
a1279 1
                                    address, addend, true));
@


1.49
log
@Support --oformat binary.
@
text
@d134 5
d281 5
d587 5
d603 1
a603 1
  const Output_section* output_section_;
d1921 5
@


1.48
log
@Fix group signature handling for relocatable link, add bootstrap
relocatable test.
@
text
@d2396 5
d2579 6
d2663 2
@


1.47
log
@Initial -r support.
@
text
@d1672 2
a1673 1
    gold_assert(this->info_section_ == NULL);
d1679 1
a1679 1
  set_info_section(const Output_data* od)
d1681 7
a1687 2
    gold_assert(this->info_symndx_ == NULL && this->info_ == 0);
    this->info_section_ = od;
d1694 4
a1697 1
    gold_assert(this->info_section_ == NULL && this->info_ == 0);
d1701 13
d1718 4
a1721 1
    gold_assert(this->info_section_ == NULL && this->info_symndx_ == NULL);
d1818 11
a1982 11
  // Modify the section name.  This is only permitted for an
  // unallocated section, and only before the size has been finalized.
  // Otherwise the name will not get into Layout::namepool_.
  void
  set_name(const char* newname)
  {
    gold_assert((this->flags_ & elfcpp::SHF_ALLOC) == 0);
    gold_assert(!this->is_data_size_valid());
    this->name_ = newname;
  }

d2287 1
a2287 1
  const Output_data* info_section_;
d2347 4
@


1.46
log
@Implement PHDRS.
@
text
@d41 1
d376 1
d397 1
d1190 48
d1680 1
a1680 1
    gold_assert(this->info_ == 0);
d1684 8
d1696 1
a1696 1
    gold_assert(this->info_section_ == NULL);
d2263 5
a2267 1
  // If info_section_ is NULL, this is the section info field.
@


1.45
log
@Fully implement the SECTIONS clause.
@
text
@d2345 6
d2381 6
d2425 7
@


1.44
log
@Don't include options.h in fileread.h.  Remove General_options
reference from Output_file class.
@
text
@d91 11
d107 10
d248 10
d292 5
d1530 4
a1533 1
  // one.  Return the offset within the output section.
d1539 1
a1539 1
		    unsigned int reloc_shndx);
d1569 8
d1759 12
d1777 29
d1823 1
a1823 1
    gold_assert(this->out_shndx_ == -1U);
d1834 4
d1850 13
d1985 9
d2007 16
d2038 4
a2104 9
    // Whether this is an input section.
    bool
    is_input_section() const
    {
      return (this->shndx_ != OUTPUT_SECTION_CODE
	      && this->shndx_ != MERGE_DATA_SECTION_CODE
	      && this->shndx_ != MERGE_STRING_SECTION_CODE);
    }

d2135 4
a2138 4
  // When we have to keep track of the input sections, we can use an
  // Output_data_const, but we don't want to have to keep track of
  // input sections just to implement fills.  For a fill we record the
  // offset, and the actual data to be written out.
d2143 2
a2144 1
      : section_offset_(section_offset), length_(length)
d2153 1
a2153 1
    off_t
d2161 1
a2161 1
    off_t length_;
d2193 4
d2209 1
a2209 1
  const elfcpp::Elf_Xword flags_;
d2254 5
d2306 1
a2306 1
  addralign();
d2327 18
d2346 6
a2351 5
  // (aligned if necessary), and set the addresses and offsets of all
  // contained output sections accordingly.  Set the section indexes
  // of all contained output sections starting with *PSHNDX.  Return
  // the address of the immediately following segment.  Update *POFF
  // and *PSHNDX.  This should only be called for a PT_LOAD segment.
d2353 2
a2354 1
  set_section_addresses(uint64_t addr, off_t* poff, unsigned int* pshndx);
d2359 2
a2360 5
  set_minimum_addralign(uint64_t align)
  {
    gold_assert(!this->is_align_known_);
    this->align_ = align;
  }
d2399 1
a2399 1
  maximum_alignment(const Output_data_list*);
d2403 2
a2404 2
  set_section_list_addresses(Output_data_list*, uint64_t addr, off_t* poff,
			     unsigned int* pshndx);
d2431 11
a2441 4
  // The segment alignment.  The is_align_known_ field indicates
  // whether this has been finalized.  It can be set to a minimum
  // value before it is finalized.
  uint64_t align_;
d2450 4
a2453 2
  // Whether we have finalized align_.
  bool is_align_known_;
@


1.43
log
@Add support for -e and for ENTRY in linker scripts.
@
text
@d2300 1
a2300 6
  Output_file(const General_options& options, Target*);

  // Get a pointer to the target.
  Target*
  target() const
  { return this->target_; }
a2369 5

  // General options.
  const General_options& options_;
  // Target.
  Target* target_;
@


1.42
log
@Correct handling of non-section symbol in merged section.  Avoid some
64-bit signed/unsigned warnings.
@
text
@d396 2
a397 1
		     const Output_segment_headers*);
d420 5
d430 1
@


1.41
log
@Speed up relocations against local symbols in merged sections.
@
text
@d2326 2
a2327 1
    gold_assert(start >= 0 && start + size <= this->file_size_);
@


1.40
log
@Convert more instances of off_t to be 32-bit types.
@
text
@d201 15
a273 15
  // Whether the address is valid.
  bool
  is_address_valid() const
  { return this->is_address_valid_; }

  // Whether the file offset is valid.
  bool
  is_offset_valid() const
  { return this->is_offset_valid_; }

  // Whether the data size is valid.
  bool
  is_data_size_valid() const
  { return this->is_data_size_valid_; }

d469 7
d509 5
d1698 7
d1925 5
@


1.39
log
@Update comments about output offsets and merged input sections.
@
text
@d2294 1
a2294 1
  write(off_t offset, const void* data, off_t len)
d2300 1
a2300 1
  get_output_view(off_t start, off_t size)
d2302 1
a2302 1
    gold_assert(start >= 0 && size >= 0 && start + size <= this->file_size_);
d2309 1
a2309 1
  write_output_view(off_t, off_t, unsigned char*)
d2315 1
a2315 1
  get_input_output_view(off_t start, off_t size)
d2320 1
a2320 1
  write_input_output_view(off_t, off_t, unsigned char*)
d2326 1
a2326 1
  get_input_view(off_t start, off_t size)
d2331 1
a2331 1
  free_input_view(off_t, off_t, const unsigned char*)
@


1.38
log
@Make functions on hot path inline.  Remove a mistaken virtual
declaration.
@
text
@d1898 4
a1901 2
    // this function returns true, it sets *POUTPUT to the output
    // offset.
@


1.37
log
@Print statistics about merge sections with --stats.
@
text
@d463 1
a463 1
  virtual bool
@


1.36
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d475 6
d509 5
d1692 4
d1913 9
@


1.35
log
@From Cary Coutant: Fix handling of RELATIVE RELA relocs.
@
text
@d464 3
a466 2
  output_offset(const Relobj* object, unsigned int shndx, off_t offset,
		off_t *poutput) const
d492 2
a493 1
  do_output_offset(const Relobj*, unsigned int, off_t, off_t*) const
d1665 3
a1667 2
  off_t
  output_offset(const Relobj* object, unsigned int shndx, off_t offset) const;
d1886 3
a1888 2
    output_offset(const Relobj* object, unsigned int shndx, off_t offset,
		  off_t *poutput) const;
@


1.34
log
@From Cary Coutant: More support for generating shared libraries.
@
text
@d706 1
a706 1
	       Address address);
d709 1
a709 1
	       unsigned int shndx, Address address);
d715 1
a715 1
	       Output_data* od, Address address);
d719 1
a719 1
	       unsigned int shndx, Address address);
d729 10
d793 3
a795 1
  unsigned int type_;
d820 2
a821 2
	       Address address, Addend addend)
    : rel_(gsym, type, od, address), addend_(addend)
d825 3
a827 2
	       unsigned int shndx, Address address, Addend addend)
    : rel_(gsym, type, relobj, shndx, address), addend_(addend)
d833 5
a837 4
	       unsigned int local_sym_index,
	       unsigned int type, Output_data* od, Address address,
	       Addend addend)
    : rel_(relobj, local_sym_index, type, od, address), addend_(addend)
d841 4
a844 6
	       unsigned int local_sym_index,
	       unsigned int type,
	       unsigned int shndx,
	       Address address,
	       Addend addend)
    : rel_(relobj, local_sym_index, type, shndx, address),
d943 1
a943 1
  { this->add(od, Output_reloc_type(gsym, type, od, address)); }
d948 16
a963 1
  { this->add(od, Output_reloc_type(gsym, type, relobj, shndx, address)); }
d972 1
a972 1
                                    address)); }
d979 3
a981 1
				    address)); }
d983 13
d1036 2
a1037 1
  { this->add(od, Output_reloc_type(gsym, type, od, address, addend)); }
d1044 18
a1061 1
                                    addend)); }
d1071 1
a1071 1
				    addend));
d1081 22
a1102 1
                                    address, addend));
@


1.33
log
@From Craig Silverstein: Support irregular output files.
@
text
@d163 11
d246 11
d706 1
a706 7
	       Address address)
    : address_(address), local_sym_index_(GSYM_CODE), type_(type),
      shndx_(INVALID_CODE)
  {
    this->u1_.gsym = gsym;
    this->u2_.od = od;
  }
d709 1
a709 8
	       unsigned int shndx, Address address)
    : address_(address), local_sym_index_(GSYM_CODE), type_(type),
      shndx_(shndx)
  {
    gold_assert(shndx != INVALID_CODE);
    this->u1_.gsym = gsym;
    this->u2_.relobj = relobj;
  }
d714 2
a715 12
	       unsigned int local_sym_index,
	       unsigned int type,
	       Output_data* od,
	       Address address)
    : address_(address), local_sym_index_(local_sym_index), type_(type),
      shndx_(INVALID_CODE)
  {
    gold_assert(local_sym_index != GSYM_CODE
		&& local_sym_index != INVALID_CODE);
    this->u1_.relobj = relobj;
    this->u2_.od = od;
  }
d718 2
a719 13
	       unsigned int local_sym_index,
	       unsigned int type,
	       unsigned int shndx,
	       Address address)
    : address_(address), local_sym_index_(local_sym_index), type_(type),
      shndx_(shndx)
  {
    gold_assert(local_sym_index != GSYM_CODE
		&& local_sym_index != INVALID_CODE);
    gold_assert(shndx != INVALID_CODE);
    this->u1_.relobj = relobj;
    this->u2_.relobj = relobj;
  }
d724 1
a724 7
	       Address address)
    : address_(address), local_sym_index_(SECTION_CODE), type_(type),
      shndx_(INVALID_CODE)
  {
    this->u1_.os = os;
    this->u2_.od = od;
  }
d727 1
a727 8
	       unsigned int shndx, Address address)
    : address_(address), local_sym_index_(SECTION_CODE), type_(type),
      shndx_(shndx)
  {
    gold_assert(shndx != INVALID_CODE);
    this->u1_.os = os;
    this->u2_.relobj = relobj;
  }
d1048 2
d1061 8
d1075 12
d1093 22
d1122 17
d1648 10
d1982 3
d2072 4
@


1.32
log
@Compress all debug sections.
@
text
@d2120 2
a2121 1
  // Close the output file and make sure there are no error.
d2171 1
a2171 1
  // Map the file into memory.
d2175 5
d2192 2
@


1.31
log
@From Craig Silverstein: Add support for compressing .debug_str section.
@
text
@a434 9
  // This class may change the output section name.  This is called
  // right before shstrtab is written, so after all input-section
  // layout processing is done.  The input is the old name, and the
  // output should be a new name (which will be copied into permanent
  // storage) to change the name, or NULL to keep the name as-is.
  virtual const char*
  do_modified_output_section_name(const char*)
  { return NULL; }

d446 6
d472 7
d552 5
d577 5
d646 5
d1339 1
a1339 2
  Output_section(const General_options& options,
                 const char* name, elfcpp::Elf_Word, elfcpp::Elf_Xword);
a1361 7
  // Modify the section name.  This should be called only after this
  // section is done being constructed.  The input should be a pointer
  // into layout's namepool_.
  void
  set_name(const char* newname)
  { this->name_ = newname; }

d1520 9
a1528 2
  // Record that this section requires postprocessing after all
  // relocations have been applied.
d1530 7
a1536 2
  set_requires_postprocessing()
  { this->requires_postprocessing_ = true; }
a1560 10
  // This class may change the output section name.  This is called
  // right before shstrtab is written, so after all input-section
  // layout processing is done.  This calls
  // do_modified_output_section_name() on all its output_section_data
  // members, and changes the name if any member so suggests.  If
  // several members would suggest, this takes the first, arbitrarily.
  // Return true if the name was modified, false else.
  bool
  maybe_modify_output_section_name();

d1582 1
a1582 1
  void
d1589 1
a1589 1
  void
d1612 30
d1731 2
a1732 2
    // Layout::finalize.  SECOFF is the file offset of the enclosing
    // section.
d1734 2
a1735 1
    set_address(uint64_t addr, off_t off, off_t secoff);
d1737 3
a1739 8
    // Call modified_output_section_name on the output-section-data object.
    const char*
    modified_output_section_name(const char* name) const
    {
      if (this->is_input_section())
        return NULL;
      return this->u2_.posd->do_modified_output_section_name(name);
    }
d1763 5
d1860 1
a1860 2
			  uint64_t entsize, uint64_t addralign,
                          bool can_compress_section);
a1871 2
  // General options.
  const General_options& options_;
d1913 3
@


1.30
log
@Clean up setting address and section offset.
@
text
@d435 9
d1320 2
a1321 1
  Output_section(const char* name, elfcpp::Elf_Word, elfcpp::Elf_Xword);
d1344 7
d1538 10
d1693 9
d1816 2
a1817 1
			  uint64_t entsize, uint64_t addralign);
d1829 2
d1832 1
a1832 1
  const char* const name_;
@


1.29
log
@From Cary Coutant: Count textrel with output sections rather than
setting a flag as we add each reloc in the target code.
@
text
@d52 4
a55 2
  explicit Output_data(off_t data_size = 0)
    : address_(0), data_size_(data_size), offset_(-1),
d62 2
a63 2
  // Return the address.  This is only valid after Layout::finalize is
  // finished.
d66 4
a69 1
  { return this->address_; }
d71 3
a73 3
  // Return the size of the data.  This must be valid after
  // Layout::finalize calls set_address, but need not be valid before
  // then.
d76 4
a79 1
  { return this->data_size_; }
d82 2
a83 1
  // Layout::finalize is finished.
d86 4
a89 1
  { return this->offset_; }
d122 3
a124 2
  // Set the address and file offset of this data.  This is called
  // during Layout::finalize.
d126 36
a161 1
  set_address(uint64_t addr, off_t off);
d169 2
a170 2
  // This is called by Layout::finalize to note that all sizes must
  // now be fixed.
d173 1
a173 1
  { Output_data::sizes_are_fixed = true; }
d178 1
a178 1
  { return Output_data::sizes_are_fixed; }
d228 3
a230 3
  // Set the address and file offset of the data.  This only needs to
  // be implemented if the child needs to know.  The child class can
  // set its size in this call.
d232 2
a233 2
  do_set_address(uint64_t, off_t)
  { }
d237 15
d256 17
a272 1
    gold_assert(!Output_data::sizes_are_fixed);
d289 3
a291 2
  // change any sizes after we set the section addresses.
  static bool sizes_are_fixed;
d293 1
a293 1
  // Memory address in file (not always meaningful).
d295 1
a295 1
  // Size of data in file.
d297 1
a297 1
  // Offset within file.
d299 6
d319 1
d348 1
d381 1
a390 6
  // Set the address and offset--we only implement this for error
  // checking.
  void
  do_set_address(uint64_t, off_t off) const
  { gold_assert(off == 0); }

d413 2
a414 2
    : Output_data(data_size), output_section_(NULL), addralign_(addralign)
  { }
d417 1
a417 1
    : Output_data(0), output_section_(NULL), addralign_(addralign)
d487 28
d534 1
a534 8
  // Add more data.
  void
  add_data(const std::string& add)
  {
    this->data_.append(add);
    this->set_data_size(this->data_.size());
  }

d554 1
d563 2
a564 1
// A place holder for data written out via some other mechanism.
d566 1
a566 1
class Output_data_space : public Output_section_data
d569 1
a569 1
  Output_data_space(off_t data_size, uint64_t addralign)
d573 14
d588 1
a588 1
    : Output_section_data(addralign)
a590 5
  // Set the size.
  void
  set_space_size(off_t space_size)
  { this->set_data_size(space_size); }

d596 3
a598 1
  // Write out the data--this must be handled elsewhere.
d613 1
d617 1
a617 1
  do_set_address(uint64_t, off_t);
d864 1
a864 1
class Output_data_reloc_base : public Output_section_data
d874 1
a874 1
    : Output_section_data(Output_data::default_alignment_for_size(size))
d877 1
a881 1
 protected:
d891 1
a891 1
    this->set_data_size(this->relocs_.size() * reloc_size);
d1041 1
a1041 1
class Output_data_got : public Output_section_data
d1047 1
a1047 1
    : Output_section_data(Output_data::default_alignment_for_size(size)),
d1085 1
d1161 1
a1161 1
  { this->set_data_size(this->got_offset(this->entries_.size())); }
d1207 5
d1214 1
a1214 1
  do_set_address(uint64_t, off_t);
a1219 5
 protected:
  // Adjust the output section to set the entry size.
  void
  do_adjust_output_section(Output_section*);

a1343 16
  // Return the section index in the output file.
  unsigned int
  do_out_shndx() const
  {
    gold_assert(this->out_shndx_ != -1U);
    return this->out_shndx_;
  }

  // Set the output section index.
  void
  do_set_out_shndx(unsigned int shndx)
  {
    gold_assert(this->out_shndx_ == -1U);
    this->out_shndx_ = shndx;
  }

d1486 12
d1515 24
a1538 1
  // Set the address of the Output_section.  For a typical
d1540 1
a1540 1
  // Output_section_data objects we need to set the final addresses
d1543 1
a1543 1
  do_set_address(uint64_t, off_t);
a1571 6
  // Write the section header into *OPHDR.
  template<int size, bool big_endian>
  void
  write_header(const Layout*, const Stringpool*,
	       elfcpp::Shdr_write<size, big_endian>*) const;

d1793 1
a1793 1
  const char* name_;
d1809 1
a1809 1
  elfcpp::Elf_Word type_;
d1811 1
a1811 1
  elfcpp::Elf_Xword flags_;
d1850 3
d2033 4
d2087 4
@


1.28
log
@From Cary Coutant: Improve i386 shared library TLS support.
@
text
@d53 2
a54 1
    : address_(0), data_size_(data_size), offset_(-1)
d132 10
d219 2
d770 1
a770 1
  add(const Output_reloc_type& reloc)
d774 1
d810 1
a810 1
  { this->add(Output_reloc_type(gsym, type, od, address)); }
d813 1
a813 1
  add_global(Symbol* gsym, unsigned int type, Relobj* relobj,
d815 1
a815 1
  { this->add(Output_reloc_type(gsym, type, relobj, shndx, address)); }
d823 2
a824 1
  { this->add(Output_reloc_type(relobj, local_sym_index, type, od, address)); }
d829 3
a831 3
	    unsigned int shndx, Address address)
  { this->add(Output_reloc_type(relobj, local_sym_index, type, shndx,
				address)); }
d835 2
d841 1
a841 1
  { this->add(Output_reloc_type(os, type, od, address)); }
d844 1
a844 1
  add_output_section(Output_section* os, unsigned int type,
d846 1
a846 1
  { this->add(Output_reloc_type(os, type, relobj, shndx, address)); }
d873 1
a873 1
  { this->add(Output_reloc_type(gsym, type, od, address, addend)); }
d876 5
a880 3
  add_global(Symbol* gsym, unsigned int type, Relobj* relobj,
	     unsigned int shndx, Address address, Addend addend)
  { this->add(Output_reloc_type(gsym, type, relobj, shndx, address, addend)); }
d889 2
a890 2
    this->add(Output_reloc_type(relobj, local_sym_index, type, od, address,
				addend));
d896 2
a897 1
	    unsigned int shndx, Address address, Addend addend)
d899 2
a900 2
    this->add(Output_reloc_type(relobj, local_sym_index, type, shndx, address,
				addend));
d908 1
a908 1
  { this->add(Output_reloc_type(os, type, od, address, addend)); }
d913 2
a914 1
  { this->add(Output_reloc_type(os, type, relobj, shndx, address, addend)); }
d1779 4
d1844 4
@


1.27
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d923 13
@


1.26
log
@Check that we don't set the output section index twice.
@
text
@a31 1
#include "parameters.h"
d126 5
d186 5
a190 1
  // Return default alignment for a size--32 or 64.
d192 1
a192 1
  default_alignment(int size);
d227 1
a227 1
  { return Output_data::default_alignment(parameters->get_size()); }
d255 1
a255 1
  { return Output_data::default_alignment(parameters->get_size()); }
d287 1
a287 1
  { return Output_data::default_alignment(parameters->get_size()); }
d341 4
a344 4
  // section, return whether or not the output address is known.
  // OUTPUT_SECTION_ADDRESS is the address of the output section which
  // this is a part of.  If this function returns true, it sets
  // *POUTPUT to the output address.
d346 3
a348 6
  output_address(const Relobj* object, unsigned int shndx, off_t offset,
		 uint64_t output_section_address, uint64_t *poutput) const
  {
    return this->do_output_address(object, shndx, offset,
				   output_section_address, poutput);
  }
d365 1
a365 1
  // The child class may implement output_address.
d367 1
a367 2
  do_output_address(const Relobj*, unsigned int, off_t, uint64_t,
		    uint64_t*) const
d743 1
a743 1
    : Output_section_data(Output_data::default_alignment(size))
d908 2
a909 1
    : Output_section_data(Output_data::default_alignment(size)), entries_()
d1021 1
a1021 2
    : Output_section_data(Output_data::default_alignment(
			   parameters->get_size())),
d1162 3
a1164 1
  // object OBJECT.  Return the offset within the output section.
d1167 4
a1170 2
  add_input_section(Relobj* object, unsigned int shndx, const char *name,
		    const elfcpp::Shdr<size, big_endian>& shdr);
d1337 23
d1511 3
a1513 4
    // section, return whether or not the output address is known.
    // OUTPUT_SECTION_ADDRESS is the address of the output section
    // which this is a part of.  If this function returns true, it
    // sets *POUTPUT to the output address.
d1515 2
a1516 2
    output_address(const Relobj* object, unsigned int shndx, off_t offset,
		   uint64_t output_section_address, uint64_t *poutput) const;
d1681 3
d1881 22
@


1.25
log
@Correctly handle alignment in merge sections.
@
text
@d1186 4
a1189 1
  { return this->out_shndx_; }
d1194 4
a1197 1
  { this->out_shndx_ = shndx; }
@


1.24
log
@Add an option for Stringpools to not copy strings.
@
text
@d1439 2
a1440 1
    is_merge_section(bool is_string, uint64_t entsize) const
d1445 2
a1446 1
	      && this->u1_.entsize == entsize);
@


1.23
log
@Add support for local GOT offsets.
@
text
@d1044 1
a1044 1
  { this->add_entry(Dynamic_entry(tag, this->pool_->add(str, NULL))); }
@


1.22
log
@Put size and endianness in parameters.
@
text
@d912 5
a916 9
  // Add an entry for a local symbol to the GOT.  This returns the
  // offset of the new entry from the start of the GOT.
  unsigned int
  add_local(Object* object, unsigned int sym_index)
  {
    this->entries_.push_back(Got_entry(object, sym_index));
    this->set_got_size();
    return this->last_got_offset();
  }
d948 2
a949 1
    Got_entry(Object* object, unsigned int local_sym_index)
d977 1
a977 1
      Object* object;
@


1.21
log
@Add licensing text to every source file.
@
text
@d32 1
d207 1
a207 3
  Output_section_headers(int size,
			 bool big_endian,
			 const Layout*,
d219 1
a219 1
  { return Output_data::default_alignment(this->size_); }
a226 2
  int size_;
  bool big_endian_;
d238 1
a238 2
  Output_segment_headers(int size, bool big_endian,
			 const Layout::Segment_list& segment_list);
d247 1
a247 1
  { return Output_data::default_alignment(this->size_); }
a254 2
  int size_;
  bool big_endian_;
d263 1
a263 3
  Output_file_header(int size,
		     bool big_endian,
		     const Target*,
d279 1
a279 1
  { return Output_data::default_alignment(this->size_); }
a292 2
  int size_;
  bool big_endian_;
d1018 4
a1021 3
  Output_data_dynamic(const Target* target, Stringpool* pool)
    : Output_section_data(Output_data::default_alignment(target->get_size())),
      target_(target), entries_(), pool_(pool)
a1143 2
  // The target.
  const Target* target_;
@


1.20
log
@Add global parameters.
@
text
@d3 20
@


1.19
log
@Use nops when doing alignment padding between code sections.
@
text
@a250 1
		     const General_options&,
a282 1
  const General_options& options_;
d893 2
a894 3
  Output_data_got(const General_options* options)
    : Output_section_data(Output_data::default_alignment(size)),
      options_(options), entries_()
d958 1
a958 1
    write(const General_options*, unsigned char* pov) const;
a997 2
  // Options.
  const General_options* options_;
@


1.18
log
@Force PT_LOAD segments to be aligned to the page size.
@
text
@d1536 31
d1624 4
d1803 6
a1808 1
  Output_file(const General_options& options);
d1844 2
@


1.17
log
@Add support for -rpath.
@
text
@d1677 9
d1747 3
a1749 1
  // The segment alignment.
d1759 1
a1759 1
  // Whether we have set align_.
@


1.16
log
@Add support for SHF_MERGE sections.
@
text
@d1043 4
@


1.15
log
@Generate version information.
@
text
@d317 20
d346 12
d1149 1
a1149 2
  Output_section(const char* name, elfcpp::Elf_Word, elfcpp::Elf_Xword,
		 bool may_add_data);
d1159 1
a1159 1
  // Add generated data ODATA to this output section.
d1318 6
d1379 5
a1383 2
      : shndx_(0), p2align_(0), data_size_(0)
    { this->u_.object = NULL; }
d1385 1
d1389 1
a1389 2
	p2align_(ffsll(static_cast<long long>(addralign))),
	data_size_(data_size)
d1391 5
a1395 2
      gold_assert(shndx != -1U);
      this->u_.object = object;
d1398 1
d1400 17
a1416 4
      : shndx_(-1U),
	p2align_(ffsll(static_cast<long long>(posd->addralign()))),
	data_size_(0)
    { this->u_.posd = posd; }
d1431 19
d1456 19
d1480 14
d1497 5
a1501 1
    { return this->shndx_ != -1U; }
d1503 4
a1506 2
    // For an ordinary input section, this is the section index in
    // the input file.  For an Output_section_data, this is -1U.
a1509 2
    // For an ordinary input section, the section size.
    off_t data_size_;
d1512 10
a1521 1
      // If shndx_ != -1U, this points to the object which holds the
d1524 2
a1525 1
      // If shndx_ == -1U, this is the data to write out.
d1527 1
a1527 1
    } u_;
d1532 18
a1588 2
  // Whether we permit adding data.
  bool may_add_data_ : 1;
@


1.14
log
@Can now dynamically link hello, world.
@
text
@d1168 1
a1168 1
  set_link_section(Output_data* od)
d1216 1
a1216 1
  set_info_section(Output_data* od)
d1420 1
a1420 1
  Output_data* link_section_;
d1424 1
a1424 1
  Output_data* info_section_;
@


1.13
log
@gcc 3.2.2 portability hacks.
@
text
@d188 3
a190 2
			 const Layout::Segment_list&,
			 const Layout::Section_list&,
d210 3
a212 2
  const Layout::Segment_list& segment_list_;
  const Layout::Section_list& unattached_section_list_;
d308 5
d315 1
a315 5
  set_output_section(Output_section* os)
  {
    gold_assert(this->output_section_ == NULL);
    this->output_section_ = os;
  }
d320 6
d707 4
d991 1
a991 1
  // Add a new dynamic entry with the address of a section.
d993 2
a994 2
  add_section_address(elfcpp::DT tag, Output_section* os)
  { this->add_entry(Dynamic_entry(tag, os, false)); }
d996 1
a996 1
  // Add a new dynamic entry with the size of a section.
d998 2
a999 2
  add_section_size(elfcpp::DT tag, Output_section* os)
  { this->add_entry(Dynamic_entry(tag, os, true)); }
d1003 1
a1003 1
  add_symbol(elfcpp::DT tag, Symbol* sym)
d1019 5
d1035 1
a1035 1
    Dynamic_entry(elfcpp::DT tag, Output_section* os, bool section_size)
d1040 1
a1040 1
    { this->u_.os = os; }
d1043 1
a1043 1
    Dynamic_entry(elfcpp::DT tag, Symbol* sym)
d1077 1
a1077 1
      Output_section* os;
d1079 1
a1079 1
      Symbol* sym;
d1164 1
a1164 2
  set_entsize(uint64_t v)
  { this->entsize_ = v; }
d1166 11
a1176 1
  // Set the link field.
d1179 6
a1184 1
  { this->link_ = v; }
d1186 37
a1222 1
  // Set the info field.
d1225 4
a1228 1
  { this->info_ = v; }
d1324 2
a1325 1
  write_header(const Stringpool*, elfcpp::Shdr_write<size, big_endian>*) const;
d1419 3
a1421 1
  // The section link field.
d1423 3
a1425 1
  // The section info field.
d1458 6
d1551 1
a1551 2
  write_section_headers(const Stringpool*,
                        unsigned char* v,
d1581 2
a1582 2
  write_section_headers_list(const Stringpool*, const Output_data_list*,
			     unsigned char* v,
@


1.12
log
@Added a testsuite.  More support for COPY relocations.
@
text
@d1037 1
a1037 1
    write(unsigned char* pov, const Stringpool*) const;
@


1.11
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d326 5
d410 5
d470 1
d473 16
a488 2
    : local_sym_index_(GSYM_CODE), type_(type), od_(od), address_(address)
  { this->u_.gsym = gsym; }
d491 2
a492 1
  Output_reloc(Sized_relobj<size, big_endian>* object,
d497 2
a498 2
    : local_sym_index_(local_sym_index), type_(type), od_(od),
      address_(address)
d502 17
a518 1
    this->u_.object = object;
d522 1
d525 16
a540 2
    : local_sym_index_(SECTION_CODE), type_(type), od_(od), address_(address)
  { this->u_.os = os; }
d573 1
a573 1
    Sized_relobj<size, big_endian>* object;
d579 13
a591 1
  } u_;
d597 4
a600 6
  // If this is not NULL, then the relocation is against the contents
  // of this output data.
  Output_data* od_;
  // The reloc address--if od_ is not NULL, this is the offset from
  // the start of od_.
  Address address_;
d619 1
d625 5
d631 2
a632 1
  Output_reloc(Sized_relobj<size, big_endian>* object,
d636 11
a646 1
    : rel_(object, local_sym_index, type, od, address), addend_(addend)
d650 1
d656 5
d736 1
d741 5
d747 1
d749 1
a749 1
  add_local(Sized_relobj<size, big_endian>* object,
d752 9
a760 1
  { this->add(Output_reloc_type(object, local_sym_index, type, od, address)); }
d763 1
d768 5
d795 1
d801 5
d807 1
d809 1
a809 1
  add_local(Sized_relobj<size, big_endian>* object,
d813 10
a822 1
    this->add(Output_reloc_type(object, local_sym_index, type, od, address,
d827 1
d832 5
@


1.10
log
@Snapshot.  Includes first cut at output relocation sections.
@
text
@a5 1
#include <cassert>
d18 1
d21 1
d100 6
d137 1
a137 1
  { abort(); }
d142 1
a142 1
  { abort(); }
d145 2
a146 1
  // be implemented if the child needs to know.
d156 4
a159 1
  { this->data_size_ = data_size; }
d169 4
d210 1
a210 1
  const Layout::Section_list& section_list_;
d272 1
a272 1
  { assert(off == 0); }
d310 1
a310 1
    assert(this->output_section_ == NULL);
d352 9
a360 1
  // Write the data to the file.
d362 1
a362 1
  do_write(Output_file* output);
d368 2
a369 2
// Output_data_common is used to handle the common symbols.  This is
// quite simple.
d371 1
a371 1
class Output_data_common : public Output_section_data
d374 23
a396 1
  Output_data_common(uint64_t addralign)
d402 2
a403 2
  set_common_size(off_t common_size)
  { this->set_data_size(common_size); }
d405 1
a405 2
  // Write out the data--there is nothing to do, as common symbols are
  // always zero and are stored in the BSS.
d411 22
d460 3
a462 2
  Output_reloc(Symbol* gsym, unsigned int type, Address address)
    : local_sym_index_(GSYM_CODE), type_(type), address_(address)
d468 5
a472 2
	       unsigned int type, Address address)
    : local_sym_index_(local_sym_index), type_(type), address_(address)
d474 2
a475 1
    assert(local_sym_index != GSYM_CODE && local_sym_index != INVALID_CODE);
d480 3
a482 2
  Output_reloc(Output_section* os, unsigned int type, Address address)
    : local_sym_index_(SECTION_CODE), type_(type), address_(address)
d526 1
d528 5
d552 3
a554 2
  Output_reloc(Symbol* gsym, unsigned int type, Address address, Addend addend)
    : rel_(gsym, type, address), addend_(addend)
d560 3
a562 2
	       unsigned int type, Address address, Addend addend)
    : rel_(object, local_sym_index, type, address), addend_(addend)
d566 3
a568 3
  Output_reloc(Output_section* os, unsigned int type, Address address,
	       Addend addend)
    : rel_(os, type, address), addend_(addend)
d647 2
a648 2
  add_global(Symbol* gsym, unsigned int type, Address address)
  { this->add(Output_reloc_type(gsym, type, address)); }
d653 3
a655 2
	    unsigned int local_sym_index, unsigned int type, Address address)
  { this->add(Output_reloc_type(object, local_sym_index, type, address)); }
d659 3
a661 2
  add_output_section(Output_section* os, unsigned int type, Address address)
  { this->add(Output_reloc_type(os, type, address)); }
d685 3
a687 2
  add_global(Symbol* gsym, unsigned int type, Address address, Addend addend)
  { this->add(Output_reloc_type(gsym, type, address, addend)); }
d693 1
a693 1
	    Address address, Addend addend)
d695 1
a695 1
    this->add(Output_reloc_type(object, local_sym_index, type, address,
d701 3
a703 3
  add_output_section(Output_section* os, unsigned int type, Address address,
		     Addend addend)
  { this->add(Output_reloc_type(os, type, address, addend)); }
d717 1
a717 1
  Output_data_got()
d719 1
a719 1
      entries_()
d762 1
a762 1
    Got_entry(Symbol* gsym)
d770 2
a771 2
      assert(local_sym_index != GSYM_CODE
	     && local_sym_index != CONSTANT_CODE);
d777 1
a777 1
    Got_entry(Valtype constant)
d783 1
a783 1
    write(unsigned char* pov) const;
d823 2
d829 130
d1006 5
d1045 1
a1045 1
    assert(this->symtab_index_ != 0);
d1053 1
a1053 1
    assert(index != 0);
d1071 1
a1071 1
    assert(this->dynsym_index_ != 0);
d1079 1
a1079 1
    assert(index != 0);
d1094 1
a1094 1
  virtual void
d1146 1
a1146 1
      assert(shndx != -1U);
d1159 5
a1163 1
    { return static_cast<uint64_t>(1) << this->p2align_; }
a1250 51
// A special Output_section which represents the symbol table
// (SHT_SYMTAB).  The actual data is written out by
// Symbol_table::write_globals.

class Output_section_symtab : public Output_section
{
 public:
  Output_section_symtab(const char* name, off_t data_size)
    : Output_section(name, elfcpp::SHT_SYMTAB, 0, false)
  { this->set_data_size(data_size); }

  // The data is written out by Symbol_table::write_globals.  We don't
  // do anything here.
  void
  do_write(Output_file*)
  { }
};

// A special Output_section which represents the dynamic symbol table
// (SHT_DYNSYM).  The actual data is written out by
// Symbol_table::write_globals.

class Output_section_dynsym : public Output_section
{
 public:
  Output_section_dynsym(const char* name, off_t data_size)
    : Output_section(name, elfcpp::SHT_DYNSYM, 0, false)
  { this->set_data_size(data_size); }

  // The data is written out by Symbol_table::write_globals.  We don't
  // do anything here.
  void
  do_write(Output_file*)
  { }
};

// A special Output_section which holds a string table.

class Output_section_strtab : public Output_section
{
 public:
  Output_section_strtab(const char* name, Stringpool* contents);

  // Write out the data.
  void
  do_write(Output_file*);

 private:
  Stringpool* contents_;
};

d1423 1
a1423 1
    assert(start >= 0 && size >= 0 && start + size <= this->file_size_);
@


1.9
log
@More dynamic object support, initial scripting support.
@
text
@d12 1
d20 1
a20 1

d23 2
d367 256
d718 2
a719 2
    // For a local symbol, the local symbol index.  This is -1U for a
    // global symbol, or -2U for a constant.
d763 1
a763 1
  virtual void
d811 52
d1000 10
d1016 9
a1024 1
  bool may_add_data_;
d1034 3
a1036 1
  Output_section_symtab(const char* name, off_t size);
d1043 12
d1056 2
a1057 1
  // We don't expect to see any input sections or data here.
d1059 2
a1060 2
  add_output_section_data(Output_section_data*)
  { abort(); }
a1072 5

  // We don't expect to see any input sections or data here.
  void
  add_output_section_data(Output_section_data*)
  { abort(); }
@


1.8
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@a162 28
// A simple case of Output_data in which we have constant data to
// output.

class Output_data_const : public Output_data
{
 public:
  Output_data_const(const std::string& data, uint64_t addralign)
    : Output_data(data.size()), data_(data), addralign_(addralign)
  { }

  Output_data_const(const char* p, off_t len, uint64_t addralign)
    : Output_data(len), data_(p, len), addralign_(addralign)
  { }

  // Write the data to the file.
  void
  do_write(Output_file* output);

  // Return the required alignment.
  uint64_t
  do_addralign() const
  { return this->addralign_; }

 private:
  std::string data_;
  uint64_t addralign_;
};

d315 2
a316 2
// Output_section_common is used to handle the common symbols.  This
// is quite simple.
d318 1
a318 1
class Output_section_common : public Output_section_data
d321 28
a348 1
  Output_section_common(uint64_t addralign)
d364 2
a365 2
// Output_section_got is used to manage a GOT.  Each entry in the GOT
// is for one symbol--either a global symbol or a local symbol in an
d367 1
a367 2
// needed.  The GOT code is then responsible for writing out the data
// and for generating relocs as required.
d370 1
a370 1
class Output_section_got : public Output_section_data
d375 1
a375 1
  Output_section_got()
d380 4
a383 9
  // Add an entry for a global symbol to the GOT.  This returns the
  // offset of the new entry from the start of the GOT.
  unsigned int
  add_global(Symbol* gsym)
  {
    this->entries_.push_back(Got_entry(gsym));
    this->set_got_size();
    return this->last_got_offset();
  }
d785 7
a791 1
  add_output_section(Output_section*, elfcpp::Elf_Word seg_flags);
d833 5
@


1.7
log
@Can now do a full static link of hello, world in C or C++
@
text
@d507 1
a507 1
  add_input_section(Object* object, unsigned int shndx, const char *name,
d616 1
a616 1
    Input_section(Object* object, unsigned int shndx, off_t data_size,
d668 1
a668 1
      Object* object;
@


1.6
log
@Framework for relocation scanning.  Implement simple static TLS
relocations.
@
text
@d8 1
d35 2
a36 1
  // Return the address.
d41 3
a43 1
  // Return the size of the data.
d48 2
a49 1
  // Return the file offset.
d75 12
a86 1
  // Set the address and file offset of this data.
d90 2
a91 1
  // Write the data to the output file.
d124 10
d300 192
d500 1
a500 1
		 unsigned int shndx);
d503 2
a504 2
  // Add a new input section named NAME with header SHDR from object
  // OBJECT.  Return the offset within the output section.
d507 1
a507 1
  add_input_section(Object* object, const char *name,
d510 4
d529 4
a532 4
  // Return the address alignment.
  uint64_t
  addralign() const
  { return this->addralign_; }
d534 4
a537 4
  // Return the section index.
  unsigned int
  shndx() const
  { return this->shndx_; }
d559 7
d567 3
a569 2
  // does nothing.  We write out the data by looping over all the
  // input sections.
d571 1
a571 2
  do_write(Output_file*)
  { }
d599 77
d695 8
a702 1
  unsigned int shndx_;
d706 2
a707 1
// (SHT_SYMTAB).
d712 12
a723 1
  Output_section_symtab(const char* name, off_t size, unsigned int shndx);
d731 1
a731 2
  Output_section_strtab(const char* name, Stringpool* contents,
			unsigned int shndx);
d737 5
d781 5
d788 1
a788 1
  max_data_align() const;
d801 4
a804 3
  // contained output sections accordingly.  Return the address of the
  // immediately following segment.  Update *POFF.  This should only
  // be called for a PT_LOAD segment.
d806 1
a806 1
  set_section_addresses(uint64_t addr, off_t* poff);
d820 1
a820 1
  write_header(elfcpp::Phdr_write<size, big_endian>*) const;
d826 2
a827 1
                        unsigned char* v ACCEPT_SIZE_ENDIAN) const;
d835 4
d841 2
a842 1
  set_section_list_addresses(Output_data_list*, uint64_t addr, off_t* poff);
d852 2
a853 1
			     unsigned char* v ACCEPT_SIZE_ENDIAN) const;
d875 2
@


1.5
log
@Clean up HAVE_MEMBER_TEMPLATE_SPECIFICATIONS somewhat.
@
text
@d446 5
@


1.4
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d484 2
a485 1
  write_section_headers(const Stringpool*, unsigned char* v) const;
d505 1
a505 1
			     unsigned char* v) const;
@


1.3
log
@Finished layout code.
@
text
@d15 1
d28 1
a28 1
    : address_(0), data_size_(data_size), offset_(0)
d170 1
d172 2
a173 1
			 const Layout::Section_list&);
d185 5
d191 1
d194 1
d202 2
a203 3
  Output_segment_headers(int size, const Layout::Segment_list& segment_list)
    : size_(size), segment_list_(segment_list)
  { }
d215 5
d221 1
d231 1
d258 5
d264 1
d268 1
a268 1
  const Output_segment_headers* program_header_;
d280 2
a281 1
  Output_section(const char* name, elfcpp::Elf_Word, elfcpp::Elf_Xword);
d311 25
d363 5
d387 2
d397 1
a397 1
  Output_section_symtab(const char* name, off_t size);
d405 2
a406 1
  Output_section_strtab(const char* name, Stringpool* contents);
d476 10
d500 6
d528 1
a528 3
// This class represents the output file.  The output file is a
// collection of output segments and a collection of output sections
// which are not associated with segments.
d533 12
a544 2
  Output_file();
  ~Output_file();
d548 29
a576 1
  write(off_t off, const void* data, off_t len);
@


1.2
log
@More section layout code.
@
text
@d6 1
d26 2
a27 2
  Output_data(off_t size = 0)
    : size_(size)
d33 6
a38 2
  // Return the size of the data.  This can't be called "size" since
  // that interferes with the widely used template parameter name.
d40 37
a76 2
  get_size()
  { return this->size_; }
d78 4
a81 2
  // Write the data to the output file at the specified offset.  This
  // must be implemented by the real class.
d83 10
a92 1
  write(Output_file*, off_t off) = 0;
d95 1
d97 1
a97 1
  is_section_type(elfcpp::Elf_Word)
d100 2
a101 2
  // Return whether this is an Output_section with the specified flag
  // set.
d103 1
a103 1
  is_section_flag_set(elfcpp::Elf_Xword)
d106 8
a113 1
 protected:
d116 6
a121 2
  set_size(off_t size)
  { this->size_ = size; }
d127 2
d130 3
a132 1
  off_t size_;
d141 2
a142 2
  Output_data_const(const std::string& data)
    : Output_data(data.size()), data_(data)
d145 2
a146 2
  Output_data_const(const char* p, off_t len)
    : Output_data(len), data_(p, len)
d151 6
a156 1
  write(Output_file* output, off_t off);
d160 1
d168 2
a169 1
  Output_section_headers(const Layout::Segment_list&,
d174 6
a179 1
  write(Output_file*, off_t);
d182 1
d192 2
a193 2
  Output_segment_headers(const Layout::Segment_list& segment_list)
    : segment_list_(segment_list)
d198 6
a203 1
  write(Output_file*, off_t);
d206 1
d215 2
a216 1
  Output_file_header(const General_options&,
d219 6
a224 3
		     const Output_segment_headers*,
		     const Output_section_headers*,
		     const Output_section* shstrtab);
d228 12
a239 1
  write(Output_file*, off_t);
d242 1
d283 5
d292 1
a292 1
  write(Output_file*, off_t)
d295 10
d307 1
a307 1
  is_section_type(elfcpp::Elf_Word type)
d312 1
a312 1
  is_section_flag_set(elfcpp::Elf_Xword flag)
d320 1
a320 2
  // The section address.
  uint64_t addr_;
d325 1
a325 2
  // The file offset.
  off_t offset_;
d342 16
a357 2
  Output_section_symtab();
  ~Output_section_symtab();
d390 4
d396 23
a418 1
  add_output_section(Output_section*);
d426 9
a434 2
  // The list of output sections attached to this segment.  This is
  // cleared after layout.
d436 2
@


1.1
log
@New drop, with first cut of section layout code.
@
text
@d9 1
d17 4
a20 2
// An abtract class for data which has to go into the output file
// which is not associated with any input section.
d32 2
a33 1
  // Return the size of the data.
d35 1
a35 1
  size()
d43 11
d68 1
a68 1
// A simple cass of Output_data in which we have constant data to
d82 1
d90 59
d152 1
a152 1
class Output_section
d157 1
a157 1
  ~Output_section();
d181 17
a210 2
  // The section size.
  off_t size_;
d221 10
a264 5
  // Update the segment flags to be compatible with FLAGS.
  void
  update_flags(elfcpp::Elf_Word flags)
  { this->flags_ |= flags & (elfcpp::PF_R | elfcpp::PF_W | elfcpp::PF_X); }

d269 1
a269 1
  typedef std::list<Output_section*> Section_list;
d273 1
a273 1
  Section_list output_sections_;
@

