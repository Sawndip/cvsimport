head	1.257;
access;
symbols
	binutils-2_24-branch:1.257.0.2
	binutils-2_24-branchpoint:1.257
	binutils-2_21_1:1.185.2.3
	binutils-2_23_2:1.231
	binutils-2_23_1:1.231
	binutils-2_23:1.231
	binutils-2_23-branch:1.231.0.2
	binutils-2_23-branchpoint:1.231
	binutils-2_22_branch:1.220.0.4
	binutils-2_22:1.220
	binutils-2_22-branch:1.220.0.2
	binutils-2_22-branchpoint:1.220
	binutils-2_21:1.185.2.1
	binutils-2_21-branch:1.185.0.2
	binutils-2_21-branchpoint:1.185
	binutils-2_20_1:1.134.2.4
	binutils-2_20:1.134.2.1
	binutils-arc-20081103-branch:1.113.0.4
	binutils-arc-20081103-branchpoint:1.113
	binutils-2_20-branch:1.134.0.2
	binutils-2_20-branchpoint:1.134
	dje-cgen-play1-branch:1.131.0.2
	dje-cgen-play1-branchpoint:1.131
	arc-20081103-branch:1.113.0.2
	arc-20081103-branchpoint:1.113
	binutils-2_19_1:1.112
	binutils-2_19:1.112
	binutils-2_19-branch:1.112.0.2
	binutils-2_19-branchpoint:1.112
	binutils_latest_snapshot:1.257
	added-to-binutils:1.94;
locks; strict;
comment	@// @;


1.257
date	2013.08.27.21.49.48;	author roland;	state Exp;
branches;
next	1.256;

1.256
date	2013.07.19.23.07.07;	author roland;	state Exp;
branches;
next	1.255;

1.255
date	2013.06.05.23.52.21;	author ccoutant;	state Exp;
branches;
next	1.254;

1.254
date	2013.05.30.23.01.11;	author ccoutant;	state Exp;
branches;
next	1.253;

1.253
date	2013.05.10.22.33.35;	author roland;	state Exp;
branches;
next	1.252;

1.252
date	2013.05.03.15.19.26;	author macro;	state Exp;
branches;
next	1.251;

1.251
date	2013.04.26.21.38.57;	author ccoutant;	state Exp;
branches;
next	1.250;

1.250
date	2013.04.21.23.21.56;	author amodra;	state Exp;
branches;
next	1.249;

1.249
date	2013.04.15.16.40.59;	author ccoutant;	state Exp;
branches;
next	1.248;

1.248
date	2013.03.21.04.52.55;	author amodra;	state Exp;
branches;
next	1.247;

1.247
date	2013.03.21.02.00.16;	author amodra;	state Exp;
branches;
next	1.246;

1.246
date	2013.03.10.23.08.18;	author amodra;	state Exp;
branches;
next	1.245;

1.245
date	2013.01.24.18.49.54;	author tmsriram;	state Exp;
branches;
next	1.244;

1.244
date	2013.01.18.17.43.57;	author vapier;	state Exp;
branches;
next	1.243;

1.243
date	2013.01.16.22.47.14;	author tmsriram;	state Exp;
branches;
next	1.242;

1.242
date	2012.12.21.06.24.31;	author ian;	state Exp;
branches;
next	1.241;

1.241
date	2012.12.19.02.55.15;	author tmsriram;	state Exp;
branches;
next	1.240;

1.240
date	2012.12.03.05.30.59;	author amodra;	state Exp;
branches;
next	1.239;

1.239
date	2012.10.16.16.50.32;	author tmsriram;	state Exp;
branches;
next	1.238;

1.238
date	2012.09.10.23.10.41;	author amodra;	state Exp;
branches;
next	1.237;

1.237
date	2012.08.30.05.57.05;	author amodra;	state Exp;
branches;
next	1.236;

1.236
date	2012.08.24.18.35.34;	author tmsriram;	state Exp;
branches;
next	1.235;

1.235
date	2012.08.22.18.26.32;	author ccoutant;	state Exp;
branches;
next	1.234;

1.234
date	2012.08.14.08.31.56;	author nickc;	state Exp;
branches;
next	1.233;

1.233
date	2012.08.14.03.39.03;	author amodra;	state Exp;
branches;
next	1.232;

1.232
date	2012.08.07.13.24.47;	author ian;	state Exp;
branches;
next	1.231;

1.231
date	2012.06.22.18.02.24;	author roland;	state Exp;
branches
	1.231.2.1;
next	1.230;

1.230
date	2012.06.07.05.14.43;	author ccoutant;	state Exp;
branches;
next	1.229;

1.229
date	2012.05.24.01.02.15;	author ccoutant;	state Exp;
branches;
next	1.228;

1.228
date	2012.05.23.20.54.37;	author ccoutant;	state Exp;
branches;
next	1.227;

1.227
date	2012.05.14.17.35.42;	author ccoutant;	state Exp;
branches;
next	1.226;

1.226
date	2012.05.08.18.00.02;	author ccoutant;	state Exp;
branches;
next	1.225;

1.225
date	2012.05.02.21.37.23;	author roland;	state Exp;
branches;
next	1.224;

1.224
date	2012.03.21.19.02.21;	author ccoutant;	state Exp;
branches;
next	1.223;

1.223
date	2012.03.15.16.32.22;	author ian;	state Exp;
branches;
next	1.222;

1.222
date	2011.10.19.15.05.58;	author ian;	state Exp;
branches;
next	1.221;

1.221
date	2011.09.29.23.45.57;	author tmsriram;	state Exp;
branches;
next	1.220;

1.220
date	2011.09.18.15.06.28;	author ccoutant;	state Exp;
branches
	1.220.2.1;
next	1.219;

1.219
date	2011.08.27.01.28.17;	author ccoutant;	state Exp;
branches;
next	1.218;

1.218
date	2011.08.01.18.25.21;	author ccoutant;	state Exp;
branches;
next	1.217;

1.217
date	2011.07.25.22.48.42;	author ian;	state Exp;
branches;
next	1.216;

1.216
date	2011.07.14.00.55.17;	author tmsriram;	state Exp;
branches;
next	1.215;

1.215
date	2011.07.11.16.19.50;	author ian;	state Exp;
branches;
next	1.214;

1.214
date	2011.07.09.06.33.59;	author ian;	state Exp;
branches;
next	1.213;

1.213
date	2011.07.08.22.48.08;	author ian;	state Exp;
branches;
next	1.212;

1.212
date	2011.07.06.21.19.31;	author ccoutant;	state Exp;
branches;
next	1.211;

1.211
date	2011.07.03.04.46.56;	author ian;	state Exp;
branches;
next	1.210;

1.210
date	2011.07.01.22.05.01;	author ian;	state Exp;
branches;
next	1.209;

1.209
date	2011.06.29.21.39.19;	author ian;	state Exp;
branches;
next	1.208;

1.208
date	2011.06.29.21.26.40;	author ian;	state Exp;
branches;
next	1.207;

1.207
date	2011.06.29.00.39.54;	author ian;	state Exp;
branches;
next	1.206;

1.206
date	2011.06.25.00.40.56;	author ian;	state Exp;
branches;
next	1.205;

1.205
date	2011.06.23.00.46.13;	author ian;	state Exp;
branches;
next	1.204;

1.204
date	2011.06.19.22.09.17;	author ian;	state Exp;
branches;
next	1.203;

1.203
date	2011.06.18.22.53.23;	author ian;	state Exp;
branches;
next	1.202;

1.202
date	2011.06.18.22.34.24;	author ian;	state Exp;
branches;
next	1.201;

1.201
date	2011.06.18.22.29.14;	author ian;	state Exp;
branches;
next	1.200;

1.200
date	2011.06.17.13.00.01;	author ian;	state Exp;
branches;
next	1.199;

1.199
date	2011.06.08.04.43.28;	author ccoutant;	state Exp;
branches;
next	1.198;

1.198
date	2011.06.08.04.34.22;	author ccoutant;	state Exp;
branches;
next	1.197;

1.197
date	2011.05.25.00.17.46;	author ian;	state Exp;
branches;
next	1.196;

1.196
date	2011.05.24.21.57.28;	author ccoutant;	state Exp;
branches;
next	1.195;

1.195
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.194;

1.194
date	2011.05.06.14.57.58;	author ian;	state Exp;
branches;
next	1.193;

1.193
date	2011.04.22.22.39.55;	author ccoutant;	state Exp;
branches;
next	1.192;

1.192
date	2011.04.14.23.29.41;	author ccoutant;	state Exp;
branches;
next	1.191;

1.191
date	2011.04.12.00.44.47;	author ccoutant;	state Exp;
branches;
next	1.190;

1.190
date	2011.01.10.21.57.31;	author ian;	state Exp;
branches;
next	1.189;

1.189
date	2010.12.09.23.19.50;	author ccoutant;	state Exp;
branches;
next	1.188;

1.188
date	2010.11.16.19.18.31;	author ccoutant;	state Exp;
branches;
next	1.187;

1.187
date	2010.11.16.18.38.29;	author ccoutant;	state Exp;
branches;
next	1.186;

1.186
date	2010.11.09.07.56.10;	author dougkwan;	state Exp;
branches;
next	1.185;

1.185
date	2010.10.20.15.30.54;	author dougkwan;	state Exp;
branches
	1.185.2.1;
next	1.184;

1.184
date	2010.10.18.05.39.22;	author ccoutant;	state Exp;
branches;
next	1.183;

1.183
date	2010.10.16.00.37.24;	author ccoutant;	state Exp;
branches;
next	1.182;

1.182
date	2010.10.14.22.10.22;	author ccoutant;	state Exp;
branches;
next	1.181;

1.181
date	2010.09.09.15.29.00;	author espindola;	state Exp;
branches;
next	1.180;

1.180
date	2010.09.09.00.13.08;	author espindola;	state Exp;
branches;
next	1.179;

1.179
date	2010.09.08.16.10.31;	author nickc;	state Exp;
branches;
next	1.178;

1.178
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.177;

1.177
date	2010.08.24.07.24.10;	author nickc;	state Exp;
branches;
next	1.176;

1.176
date	2010.08.12.22.15.00;	author ccoutant;	state Exp;
branches;
next	1.175;

1.175
date	2010.08.12.22.01.11;	author ccoutant;	state Exp;
branches;
next	1.174;

1.174
date	2010.08.03.15.05.05;	author ian;	state Exp;
branches;
next	1.173;

1.173
date	2010.08.03.14.07.13;	author ian;	state Exp;
branches;
next	1.172;

1.172
date	2010.07.12.17.59.58;	author ccoutant;	state Exp;
branches;
next	1.171;

1.171
date	2010.06.19.21.11.55;	author ccoutant;	state Exp;
branches;
next	1.170;

1.170
date	2010.06.01.23.37.57;	author tmsriram;	state Exp;
branches;
next	1.169;

1.169
date	2010.04.24.14.32.23;	author ian;	state Exp;
branches;
next	1.168;

1.168
date	2010.04.09.17.32.58;	author dougkwan;	state Exp;
branches;
next	1.167;

1.167
date	2010.03.01.21.43.49;	author dougkwan;	state Exp;
branches;
next	1.166;

1.166
date	2010.02.24.20.45.12;	author dougkwan;	state Exp;
branches;
next	1.165;

1.165
date	2010.02.09.20.29.44;	author davem;	state Exp;
branches;
next	1.164;

1.164
date	2010.01.23.01.07.59;	author dougkwan;	state Exp;
branches;
next	1.163;

1.163
date	2010.01.08.21.07.34;	author ian;	state Exp;
branches;
next	1.162;

1.162
date	2010.01.08.19.33.17;	author ian;	state Exp;
branches;
next	1.161;

1.161
date	2010.01.07.21.09.31;	author ian;	state Exp;
branches;
next	1.160;

1.160
date	2010.01.07.20.43.35;	author ian;	state Exp;
branches;
next	1.159;

1.159
date	2010.01.07.18.16.24;	author ian;	state Exp;
branches;
next	1.158;

1.158
date	2010.01.07.07.14.29;	author tmsriram;	state Exp;
branches;
next	1.157;

1.157
date	2010.01.07.06.05.23;	author ian;	state Exp;
branches;
next	1.156;

1.156
date	2010.01.06.22.37.18;	author ian;	state Exp;
branches;
next	1.155;

1.155
date	2009.12.31.05.43.29;	author ian;	state Exp;
branches;
next	1.154;

1.154
date	2009.12.31.03.48.46;	author ian;	state Exp;
branches;
next	1.153;

1.153
date	2009.12.30.07.45.32;	author ian;	state Exp;
branches;
next	1.152;

1.152
date	2009.12.30.06.57.17;	author ian;	state Exp;
branches;
next	1.151;

1.151
date	2009.12.30.04.16.50;	author ian;	state Exp;
branches;
next	1.150;

1.150
date	2009.12.29.00.31.48;	author ian;	state Exp;
branches;
next	1.149;

1.149
date	2009.12.15.22.20.25;	author ian;	state Exp;
branches;
next	1.148;

1.148
date	2009.12.14.19.53.04;	author ian;	state Exp;
branches;
next	1.147;

1.147
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.146;

1.146
date	2009.12.03.23.13.55;	author dougkwan;	state Exp;
branches;
next	1.145;

1.145
date	2009.11.05.06.24.39;	author ian;	state Exp;
branches;
next	1.144;

1.144
date	2009.11.04.15.56.03;	author ian;	state Exp;
branches;
next	1.143;

1.143
date	2009.10.30.18.49.59;	author dougkwan;	state Exp;
branches;
next	1.142;

1.142
date	2009.10.16.05.16.09;	author ian;	state Exp;
branches;
next	1.141;

1.141
date	2009.10.16.05.00.28;	author ian;	state Exp;
branches;
next	1.140;

1.140
date	2009.10.15.18.17.48;	author dougkwan;	state Exp;
branches;
next	1.139;

1.139
date	2009.10.14.05.25.01;	author ian;	state Exp;
branches;
next	1.138;

1.138
date	2009.10.13.21.23.00;	author ian;	state Exp;
branches;
next	1.137;

1.137
date	2009.10.09.23.18.19;	author dougkwan;	state Exp;
branches;
next	1.136;

1.136
date	2009.10.09.23.05.21;	author ian;	state Exp;
branches;
next	1.135;

1.135
date	2009.09.18.01.10.38;	author dougkwan;	state Exp;
branches;
next	1.134;

1.134
date	2009.08.05.20.51.56;	author tmsriram;	state Exp;
branches
	1.134.2.1;
next	1.133;

1.133
date	2009.07.24.23.13.51;	author cgd;	state Exp;
branches;
next	1.132;

1.132
date	2009.07.17.01.07.33;	author ian;	state Exp;
branches;
next	1.131;

1.131
date	2009.06.24.19.48.51;	author ian;	state Exp;
branches;
next	1.130;

1.130
date	2009.06.24.05.09.11;	author ian;	state Exp;
branches;
next	1.129;

1.129
date	2009.06.24.00.38.00;	author ian;	state Exp;
branches;
next	1.128;

1.128
date	2009.06.23.07.04.10;	author ian;	state Exp;
branches;
next	1.127;

1.127
date	2009.06.22.20.23.21;	author ian;	state Exp;
branches;
next	1.126;

1.126
date	2009.06.22.06.51.53;	author ian;	state Exp;
branches;
next	1.125;

1.125
date	2009.06.04.21.14.11;	author dougkwan;	state Exp;
branches;
next	1.124;

1.124
date	2009.06.04.00.43.11;	author ian;	state Exp;
branches;
next	1.123;

1.123
date	2009.04.24.15.44.02;	author ian;	state Exp;
branches;
next	1.122;

1.122
date	2009.04.02.04.19.03;	author ian;	state Exp;
branches;
next	1.121;

1.121
date	2009.03.19.19.39.32;	author ppluzhnikov;	state Exp;
branches;
next	1.120;

1.120
date	2009.03.17.20.36.30;	author ppluzhnikov;	state Exp;
branches;
next	1.119;

1.119
date	2009.03.01.22.22.02;	author ian;	state Exp;
branches;
next	1.118;

1.118
date	2009.02.28.04.39.57;	author ian;	state Exp;
branches;
next	1.117;

1.117
date	2009.02.25.19.05.20;	author ccoutant;	state Exp;
branches;
next	1.116;

1.116
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	1.115;

1.115
date	2008.12.10.19.50.14;	author ccoutant;	state Exp;
branches;
next	1.114;

1.114
date	2008.12.05.21.13.35;	author ccoutant;	state Exp;
branches;
next	1.113;

1.113
date	2008.09.12.05.42.27;	author cgd;	state Exp;
branches;
next	1.112;

1.112
date	2008.08.13.07.37.46;	author ian;	state Exp;
branches;
next	1.111;

1.111
date	2008.07.25.04.25.49;	author ian;	state Exp;
branches;
next	1.110;

1.110
date	2008.07.22.23.55.24;	author ian;	state Exp;
branches;
next	1.109;

1.109
date	2008.07.22.23.01.20;	author ian;	state Exp;
branches;
next	1.108;

1.108
date	2008.07.10.23.01.19;	author ian;	state Exp;
branches;
next	1.107;

1.107
date	2008.07.04.03.34.01;	author ian;	state Exp;
branches;
next	1.106;

1.106
date	2008.05.28.20.48.16;	author ian;	state Exp;
branches;
next	1.105;

1.105
date	2008.05.21.21.37.44;	author ian;	state Exp;
branches;
next	1.104;

1.104
date	2008.05.20.04.00.46;	author ian;	state Exp;
branches;
next	1.103;

1.103
date	2008.05.16.22.29.04;	author ian;	state Exp;
branches;
next	1.102;

1.102
date	2008.05.05.19.16.43;	author ian;	state Exp;
branches;
next	1.101;

1.101
date	2008.05.01.01.23.21;	author ccoutant;	state Exp;
branches;
next	1.100;

1.100
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.99;

1.99
date	2008.04.16.23.21.01;	author davem;	state Exp;
branches;
next	1.98;

1.98
date	2008.04.15.04.06.40;	author ian;	state Exp;
branches;
next	1.97;

1.97
date	2008.04.09.00.26.48;	author ian;	state Exp;
branches;
next	1.96;

1.96
date	2008.03.28.22.42.34;	author ian;	state Exp;
branches;
next	1.95;

1.95
date	2008.03.25.05.11.41;	author ian;	state Exp;
branches;
next	1.94;

1.94
date	2008.03.19.21.41.38;	author iant;	state Exp;
branches;
next	1.93;

1.93
date	2008.03.12.04.38.42;	author iant;	state Exp;
branches;
next	1.92;

1.92
date	2008.03.11.16.50.08;	author iant;	state Exp;
branches;
next	1.91;

1.91
date	2008.03.06.00.15.04;	author iant;	state Exp;
branches;
next	1.90;

1.90
date	2008.03.04.23.10.38;	author iant;	state Exp;
branches;
next	1.89;

1.89
date	2008.03.04.18.21.43;	author iant;	state Exp;
branches;
next	1.88;

1.88
date	2008.02.29.19.19.17;	author iant;	state Exp;
branches;
next	1.87;

1.87
date	2008.02.28.04.45.47;	author iant;	state Exp;
branches;
next	1.86;

1.86
date	2008.02.28.00.51.07;	author iant;	state Exp;
branches;
next	1.85;

1.85
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.84;

1.84
date	2008.02.27.22.38.18;	author iant;	state Exp;
branches;
next	1.83;

1.83
date	2008.02.26.22.48.08;	author iant;	state Exp;
branches;
next	1.82;

1.82
date	2008.02.26.21.45.30;	author iant;	state Exp;
branches;
next	1.81;

1.81
date	2008.02.13.22.47.27;	author iant;	state Exp;
branches;
next	1.80;

1.80
date	2008.02.12.00.24.00;	author iant;	state Exp;
branches;
next	1.79;

1.79
date	2008.02.08.07.06.57;	author iant;	state Exp;
branches;
next	1.78;

1.78
date	2008.02.07.07.33.46;	author iant;	state Exp;
branches;
next	1.77;

1.77
date	2008.02.07.01.51.25;	author iant;	state Exp;
branches;
next	1.76;

1.76
date	2008.02.06.20.32.10;	author iant;	state Exp;
branches;
next	1.75;

1.75
date	2008.02.06.19.32.32;	author iant;	state Exp;
branches;
next	1.74;

1.74
date	2008.02.06.08.13.50;	author iant;	state Exp;
branches;
next	1.73;

1.73
date	2008.02.04.22.54.31;	author iant;	state Exp;
branches;
next	1.72;

1.72
date	2008.02.04.06.45.50;	author iant;	state Exp;
branches;
next	1.71;

1.71
date	2008.02.04.05.41.40;	author iant;	state Exp;
branches;
next	1.70;

1.70
date	2008.01.26.01.17.45;	author iant;	state Exp;
branches;
next	1.69;

1.69
date	2008.01.24.00.15.00;	author iant;	state Exp;
branches;
next	1.68;

1.68
date	2008.01.18.23.26.48;	author iant;	state Exp;
branches;
next	1.67;

1.67
date	2008.01.15.23.41.28;	author iant;	state Exp;
branches;
next	1.66;

1.66
date	2008.01.09.19.57.45;	author iant;	state Exp;
branches;
next	1.65;

1.65
date	2008.01.06.00.47.10;	author iant;	state Exp;
branches;
next	1.64;

1.64
date	2008.01.04.05.35.24;	author iant;	state Exp;
branches;
next	1.63;

1.63
date	2008.01.02.23.48.49;	author iant;	state Exp;
branches;
next	1.62;

1.62
date	2007.12.21.21.19.45;	author iant;	state Exp;
branches;
next	1.61;

1.61
date	2007.12.19.00.29.28;	author iant;	state Exp;
branches;
next	1.60;

1.60
date	2007.12.18.21.45.28;	author iant;	state Exp;
branches;
next	1.59;

1.59
date	2007.12.18.21.24.07;	author iant;	state Exp;
branches;
next	1.58;

1.58
date	2007.12.14.19.00.21;	author iant;	state Exp;
branches;
next	1.57;

1.57
date	2007.12.14.05.24.17;	author iant;	state Exp;
branches;
next	1.56;

1.56
date	2007.12.11.23.30.52;	author iant;	state Exp;
branches;
next	1.55;

1.55
date	2007.12.07.23.26.51;	author iant;	state Exp;
branches;
next	1.54;

1.54
date	2007.12.07.06.44.01;	author iant;	state Exp;
branches;
next	1.53;

1.53
date	2007.12.06.05.55.50;	author iant;	state Exp;
branches;
next	1.52;

1.52
date	2007.12.05.00.48.49;	author iant;	state Exp;
branches;
next	1.51;

1.51
date	2007.12.01.06.34.12;	author iant;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.30.00.35.27;	author iant;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.29.20.10.16;	author iant;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.15.23.46.46;	author iant;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.15.23.03.45;	author iant;	state Exp;
branches;
next	1.46;

1.46
date	2007.11.14.22.31.02;	author iant;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.14.16.53.24;	author iant;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.07.22.33.30;	author iant;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.01.00.19.30;	author iant;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.27.00.36.52;	author iant;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.23.05.05.48;	author iant;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.22.23.08.22;	author iant;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.18.19.56.12;	author iant;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.16.23.23.08;	author iant;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.16.22.38.35;	author iant;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.14.03.12.53;	author iant;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.12.06.06.34;	author iant;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.12.05.51.25;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.10.19.02.56;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.09.21.37.55;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.04.05.49.04;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.02.20.52.18;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.26.07.01.34;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.26.05.44.37;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.23.19.50.33;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.22.04.42.09;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.21.07.20.01;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.21.05.31.19;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.12.00.30.59;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.04.20.00.53;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.21.21.03.50;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.21.20.37.32;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.16.17.42.48;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.06.00.28.03;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.06.00.02.36;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.01.16.51.25;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.30.23.52.50;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.16.00.38.25;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.07.04.40.46;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.03.18.26.10;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.20.20.40.49;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.06.20.40.16;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.29.19.58.16;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.27.22.53.42;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.26.21.00.34;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.21.22.13.18;	author iant;	state Exp;
branches;
next	;

1.231.2.1
date	2013.05.10.22.35.30;	author roland;	state Exp;
branches;
next	1.231.2.2;

1.231.2.2
date	2013.07.19.23.08.00;	author roland;	state Exp;
branches;
next	1.231.2.3;

1.231.2.3
date	2013.08.27.21.50.25;	author roland;	state Exp;
branches;
next	;

1.220.2.1
date	2011.12.19.21.14.39;	author ian;	state Exp;
branches;
next	;

1.185.2.1
date	2010.11.18.08.25.00;	author gingold;	state Exp;
branches;
next	1.185.2.2;

1.185.2.2
date	2011.01.10.21.57.48;	author ian;	state Exp;
branches;
next	1.185.2.3;

1.185.2.3
date	2011.05.06.14.58.17;	author ian;	state Exp;
branches;
next	;

1.134.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	1.134.2.2;

1.134.2.2
date	2009.11.04.15.56.34;	author ian;	state Exp;
branches;
next	1.134.2.3;

1.134.2.3
date	2009.11.05.06.25.01;	author ian;	state Exp;
branches;
next	1.134.2.4;

1.134.2.4
date	2010.01.13.16.01.05;	author ian;	state Exp;
branches;
next	;


desc
@@


1.257
log
@gold/
	* output.cc (Output_segment::set_section_addresses): Take new
	Target* argument.  If target->isolate_execinstr() and the segment
	is executable and starts at a target->abi_pagesize() boundary,
	pad its end out to a target->abi_pagesize() boundary with code fill.
	* output.h (Output_segment::set_section_addresses): Update decl.
	* layout.h (Layout::check_output_data_for_reset_values): Take new
	argument RELAX_OUTPUTS.
	(Layout): New member relax_output_list_.
	(Layout::add_relax_output): New method.
	* layout.cc (Layout::Layout): Update constructor.
	(Layout::reset_relax_output): New method.
	(Layout::clean_up_after_relaxation): Call it.
	(Layout::prepare_for_relaxation): Update caller.
	(Layout::set_segment_offsets): Update callers of set_section_addresses.
	Call reset_relax_output before re-processing segments for
	isolate_execinstr case.
	(Layout::write_data): Handle relax_output_list_.
	(Layout::Relaxation_debug_check::check_output_data_for_reset_values):
	Take new argument RELAX_OUTPUTS.  Assert it's an empty collection.
@
text
@// layout.cc -- lay out output file sections for gold

// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
// Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cerrno>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <utility>
#include <fcntl.h>
#include <fnmatch.h>
#include <unistd.h>
#include "libiberty.h"
#include "md5.h"
#include "sha1.h"

#include "parameters.h"
#include "options.h"
#include "mapfile.h"
#include "script.h"
#include "script-sections.h"
#include "output.h"
#include "symtab.h"
#include "dynobj.h"
#include "ehframe.h"
#include "gdb-index.h"
#include "compressed_output.h"
#include "reduced_debug_output.h"
#include "object.h"
#include "reloc.h"
#include "descriptors.h"
#include "plugin.h"
#include "incremental.h"
#include "layout.h"

namespace gold
{

// Class Free_list.

// The total number of free lists used.
unsigned int Free_list::num_lists = 0;
// The total number of free list nodes used.
unsigned int Free_list::num_nodes = 0;
// The total number of calls to Free_list::remove.
unsigned int Free_list::num_removes = 0;
// The total number of nodes visited during calls to Free_list::remove.
unsigned int Free_list::num_remove_visits = 0;
// The total number of calls to Free_list::allocate.
unsigned int Free_list::num_allocates = 0;
// The total number of nodes visited during calls to Free_list::allocate.
unsigned int Free_list::num_allocate_visits = 0;

// Initialize the free list.  Creates a single free list node that
// describes the entire region of length LEN.  If EXTEND is true,
// allocate() is allowed to extend the region beyond its initial
// length.

void
Free_list::init(off_t len, bool extend)
{
  this->list_.push_front(Free_list_node(0, len));
  this->last_remove_ = this->list_.begin();
  this->extend_ = extend;
  this->length_ = len;
  ++Free_list::num_lists;
  ++Free_list::num_nodes;
}

// Remove a chunk from the free list.  Because we start with a single
// node that covers the entire section, and remove chunks from it one
// at a time, we do not need to coalesce chunks or handle cases that
// span more than one free node.  We expect to remove chunks from the
// free list in order, and we expect to have only a few chunks of free
// space left (corresponding to files that have changed since the last
// incremental link), so a simple linear list should provide sufficient
// performance.

void
Free_list::remove(off_t start, off_t end)
{
  if (start == end)
    return;
  gold_assert(start < end);

  ++Free_list::num_removes;

  Iterator p = this->last_remove_;
  if (p->start_ > start)
    p = this->list_.begin();

  for (; p != this->list_.end(); ++p)
    {
      ++Free_list::num_remove_visits;
      // Find a node that wholly contains the indicated region.
      if (p->start_ <= start && p->end_ >= end)
	{
	  // Case 1: the indicated region spans the whole node.
	  // Add some fuzz to avoid creating tiny free chunks.
	  if (p->start_ + 3 >= start && p->end_ <= end + 3)
	    p = this->list_.erase(p);
	  // Case 2: remove a chunk from the start of the node.
	  else if (p->start_ + 3 >= start)
	    p->start_ = end;
	  // Case 3: remove a chunk from the end of the node.
	  else if (p->end_ <= end + 3)
	    p->end_ = start;
	  // Case 4: remove a chunk from the middle, and split
	  // the node into two.
	  else
	    {
	      Free_list_node newnode(p->start_, start);
	      p->start_ = end;
	      this->list_.insert(p, newnode);
	      ++Free_list::num_nodes;
	    }
	  this->last_remove_ = p;
	  return;
	}
    }

  // Did not find a node containing the given chunk.  This could happen
  // because a small chunk was already removed due to the fuzz.
  gold_debug(DEBUG_INCREMENTAL,
	     "Free_list::remove(%d,%d) not found",
	     static_cast<int>(start), static_cast<int>(end));
}

// Allocate a chunk of size LEN from the free list.  Returns -1ULL
// if a sufficiently large chunk of free space is not found.
// We use a simple first-fit algorithm.

off_t
Free_list::allocate(off_t len, uint64_t align, off_t minoff)
{
  gold_debug(DEBUG_INCREMENTAL,
	     "Free_list::allocate(%08lx, %d, %08lx)",
	     static_cast<long>(len), static_cast<int>(align),
	     static_cast<long>(minoff));
  if (len == 0)
    return align_address(minoff, align);

  ++Free_list::num_allocates;

  // We usually want to drop free chunks smaller than 4 bytes.
  // If we need to guarantee a minimum hole size, though, we need
  // to keep track of all free chunks.
  const int fuzz = this->min_hole_ > 0 ? 0 : 3;

  for (Iterator p = this->list_.begin(); p != this->list_.end(); ++p)
    {
      ++Free_list::num_allocate_visits;
      off_t start = p->start_ > minoff ? p->start_ : minoff;
      start = align_address(start, align);
      off_t end = start + len;
      if (end > p->end_ && p->end_ == this->length_ && this->extend_)
	{
	  this->length_ = end;
	  p->end_ = end;
	}
      if (end == p->end_ || (end <= p->end_ - this->min_hole_))
	{
	  if (p->start_ + fuzz >= start && p->end_ <= end + fuzz)
	    this->list_.erase(p);
	  else if (p->start_ + fuzz >= start)
	    p->start_ = end;
	  else if (p->end_ <= end + fuzz)
	    p->end_ = start;
	  else
	    {
	      Free_list_node newnode(p->start_, start);
	      p->start_ = end;
	      this->list_.insert(p, newnode);
	      ++Free_list::num_nodes;
	    }
	  return start;
	}
    }
  if (this->extend_)
    {
      off_t start = align_address(this->length_, align);
      this->length_ = start + len;
      return start;
    }
  return -1;
}

// Dump the free list (for debugging).
void
Free_list::dump()
{
  gold_info("Free list:\n     start      end   length\n");
  for (Iterator p = this->list_.begin(); p != this->list_.end(); ++p)
    gold_info("  %08lx %08lx %08lx", static_cast<long>(p->start_),
	      static_cast<long>(p->end_),
	      static_cast<long>(p->end_ - p->start_));
}

// Print the statistics for the free lists.
void
Free_list::print_stats()
{
  fprintf(stderr, _("%s: total free lists: %u\n"),
	  program_name, Free_list::num_lists);
  fprintf(stderr, _("%s: total free list nodes: %u\n"),
	  program_name, Free_list::num_nodes);
  fprintf(stderr, _("%s: calls to Free_list::remove: %u\n"),
	  program_name, Free_list::num_removes);
  fprintf(stderr, _("%s: nodes visited: %u\n"),
	  program_name, Free_list::num_remove_visits);
  fprintf(stderr, _("%s: calls to Free_list::allocate: %u\n"),
	  program_name, Free_list::num_allocates);
  fprintf(stderr, _("%s: nodes visited: %u\n"),
	  program_name, Free_list::num_allocate_visits);
}

// A Hash_task computes the MD5 checksum of an array of char.
// It has a blocker on either side (i.e., the task cannot run until
// the first is unblocked, and it unblocks the second after running).

class Hash_task : public Task
{
 public:
  Hash_task(const unsigned char* src,
	    size_t size,
	    unsigned char* dst,
	    Task_token* build_id_blocker,
	    Task_token* final_blocker)
    : src_(src), size_(size), dst_(dst), build_id_blocker_(build_id_blocker),
      final_blocker_(final_blocker)
  { }

  void
  run(Workqueue*)
  { md5_buffer(reinterpret_cast<const char*>(src_), size_, dst_); }

  Task_token*
  is_runnable();

  // Unblock FINAL_BLOCKER_ when done.
  void
  locks(Task_locker* tl)
  { tl->add(this, this->final_blocker_); }

  std::string
  get_name() const
  { return "Hash_task"; }

 private:
  const unsigned char* const src_;
  const size_t size_;
  unsigned char* const dst_;
  Task_token* const build_id_blocker_;
  Task_token* const final_blocker_;
};

Task_token*
Hash_task::is_runnable()
{
  if (this->build_id_blocker_->is_blocked())
    return this->build_id_blocker_;
  return NULL;
}

// Layout::Relaxation_debug_check methods.

// Check that sections and special data are in reset states.
// We do not save states for Output_sections and special Output_data.
// So we check that they have not assigned any addresses or offsets.
// clean_up_after_relaxation simply resets their addresses and offsets.
void
Layout::Relaxation_debug_check::check_output_data_for_reset_values(
    const Layout::Section_list& sections,
    const Layout::Data_list& special_outputs,
    const Layout::Data_list& relax_outputs)
{
  for(Layout::Section_list::const_iterator p = sections.begin();
      p != sections.end();
      ++p)
    gold_assert((*p)->address_and_file_offset_have_reset_values());

  for(Layout::Data_list::const_iterator p = special_outputs.begin();
      p != special_outputs.end();
      ++p)
    gold_assert((*p)->address_and_file_offset_have_reset_values());

  gold_assert(relax_outputs.empty());
}

// Save information of SECTIONS for checking later.

void
Layout::Relaxation_debug_check::read_sections(
    const Layout::Section_list& sections)
{
  for(Layout::Section_list::const_iterator p = sections.begin();
      p != sections.end();
      ++p)
    {
      Output_section* os = *p;
      Section_info info;
      info.output_section = os;
      info.address = os->is_address_valid() ? os->address() : 0;
      info.data_size = os->is_data_size_valid() ? os->data_size() : -1;
      info.offset = os->is_offset_valid()? os->offset() : -1 ;
      this->section_infos_.push_back(info);
    }
}

// Verify SECTIONS using previously recorded information.

void
Layout::Relaxation_debug_check::verify_sections(
    const Layout::Section_list& sections)
{
  size_t i = 0;
  for(Layout::Section_list::const_iterator p = sections.begin();
      p != sections.end();
      ++p, ++i)
    {
      Output_section* os = *p;
      uint64_t address = os->is_address_valid() ? os->address() : 0;
      off_t data_size = os->is_data_size_valid() ? os->data_size() : -1;
      off_t offset = os->is_offset_valid()? os->offset() : -1 ;

      if (i >= this->section_infos_.size())
	{
	  gold_fatal("Section_info of %s missing.\n", os->name());
	}
      const Section_info& info = this->section_infos_[i];
      if (os != info.output_section)
	gold_fatal("Section order changed.  Expecting %s but see %s\n",
		   info.output_section->name(), os->name());
      if (address != info.address
	  || data_size != info.data_size
	  || offset != info.offset)
	gold_fatal("Section %s changed.\n", os->name());
    }
}

// Layout_task_runner methods.

// Lay out the sections.  This is called after all the input objects
// have been read.

void
Layout_task_runner::run(Workqueue* workqueue, const Task* task)
{
  // See if any of the input definitions violate the One Definition Rule.
  // TODO: if this is too slow, do this as a task, rather than inline.
  this->symtab_->detect_odr_violations(task, this->options_.output_file_name());

  Layout* layout = this->layout_;
  off_t file_size = layout->finalize(this->input_objects_,
				     this->symtab_,
				     this->target_,
				     task);

  // Now we know the final size of the output file and we know where
  // each piece of information goes.

  if (this->mapfile_ != NULL)
    {
      this->mapfile_->print_discarded_sections(this->input_objects_);
      layout->print_to_mapfile(this->mapfile_);
    }

  Output_file* of;
  if (layout->incremental_base() == NULL)
    {
      of = new Output_file(parameters->options().output_file_name());
      if (this->options_.oformat_enum() != General_options::OBJECT_FORMAT_ELF)
	of->set_is_temporary();
      of->open(file_size);
    }
  else
    {
      of = layout->incremental_base()->output_file();

      // Apply the incremental relocations for symbols whose values
      // have changed.  We do this before we resize the file and start
      // writing anything else to it, so that we can read the old
      // incremental information from the file before (possibly)
      // overwriting it.
      if (parameters->incremental_update())
	layout->incremental_base()->apply_incremental_relocs(this->symtab_,
							     this->layout_,
							     of);

      of->resize(file_size);
    }

  // Queue up the final set of tasks.
  gold::queue_final_tasks(this->options_, this->input_objects_,
			  this->symtab_, layout, workqueue, of);
}

// Layout methods.

Layout::Layout(int number_of_input_files, Script_options* script_options)
  : number_of_input_files_(number_of_input_files),
    script_options_(script_options),
    namepool_(),
    sympool_(),
    dynpool_(),
    signatures_(),
    section_name_map_(),
    segment_list_(),
    section_list_(),
    unattached_section_list_(),
    special_output_list_(),
    relax_output_list_(),
    section_headers_(NULL),
    tls_segment_(NULL),
    relro_segment_(NULL),
    interp_segment_(NULL),
    increase_relro_(0),
    symtab_section_(NULL),
    symtab_xindex_(NULL),
    dynsym_section_(NULL),
    dynsym_xindex_(NULL),
    dynamic_section_(NULL),
    dynamic_symbol_(NULL),
    dynamic_data_(NULL),
    eh_frame_section_(NULL),
    eh_frame_data_(NULL),
    added_eh_frame_data_(false),
    eh_frame_hdr_section_(NULL),
    gdb_index_data_(NULL),
    build_id_note_(NULL),
    array_of_hashes_(NULL),
    size_of_array_of_hashes_(0),
    input_view_(NULL),
    debug_abbrev_(NULL),
    debug_info_(NULL),
    group_signatures_(),
    output_file_size_(-1),
    have_added_input_section_(false),
    sections_are_attached_(false),
    input_requires_executable_stack_(false),
    input_with_gnu_stack_note_(false),
    input_without_gnu_stack_note_(false),
    has_static_tls_(false),
    any_postprocessing_sections_(false),
    resized_signatures_(false),
    have_stabstr_section_(false),
    section_ordering_specified_(false),
    unique_segment_for_sections_specified_(false),
    incremental_inputs_(NULL),
    record_output_section_data_from_script_(false),
    script_output_section_data_list_(),
    segment_states_(NULL),
    relaxation_debug_check_(NULL),
    section_order_map_(),
    section_segment_map_(),
    input_section_position_(),
    input_section_glob_(),
    incremental_base_(NULL),
    free_list_()
{
  // Make space for more than enough segments for a typical file.
  // This is just for efficiency--it's OK if we wind up needing more.
  this->segment_list_.reserve(12);

  // We expect two unattached Output_data objects: the file header and
  // the segment headers.
  this->special_output_list_.reserve(2);

  // Initialize structure needed for an incremental build.
  if (parameters->incremental())
    this->incremental_inputs_ = new Incremental_inputs;

  // The section name pool is worth optimizing in all cases, because
  // it is small, but there are often overlaps due to .rel sections.
  this->namepool_.set_optimize();
}

// For incremental links, record the base file to be modified.

void
Layout::set_incremental_base(Incremental_binary* base)
{
  this->incremental_base_ = base;
  this->free_list_.init(base->output_file()->filesize(), true);
}

// Hash a key we use to look up an output section mapping.

size_t
Layout::Hash_key::operator()(const Layout::Key& k) const
{
 return k.first + k.second.first + k.second.second;
}

// These are the debug sections that are actually used by gdb.
// Currently, we've checked versions of gdb up to and including 7.4.
// We only check the part of the name that follows ".debug_" or
// ".zdebug_".

static const char* gdb_sections[] =
{
  "abbrev",
  "addr",         // Fission extension
  // "aranges",   // not used by gdb as of 7.4
  "frame",
  "info",
  "types",
  "line",
  "loc",
  "macinfo",
  "macro",
  // "pubnames",  // not used by gdb as of 7.4
  // "pubtypes",  // not used by gdb as of 7.4
  "ranges",
  "str",
};

// This is the minimum set of sections needed for line numbers.

static const char* lines_only_debug_sections[] =
{
  "abbrev",
  // "addr",      // Fission extension
  // "aranges",   // not used by gdb as of 7.4
  // "frame",
  "info",
  // "types",
  "line",
  // "loc",
  // "macinfo",
  // "macro",
  // "pubnames",  // not used by gdb as of 7.4
  // "pubtypes",  // not used by gdb as of 7.4
  // "ranges",
  "str",
};

// These sections are the DWARF fast-lookup tables, and are not needed
// when building a .gdb_index section.

static const char* gdb_fast_lookup_sections[] =
{
  "aranges",
  "pubnames",
  "pubtypes",
};

// Returns whether the given debug section is in the list of
// debug-sections-used-by-some-version-of-gdb.  SUFFIX is the
// portion of the name following ".debug_" or ".zdebug_".

static inline bool
is_gdb_debug_section(const char* suffix)
{
  // We can do this faster: binary search or a hashtable.  But why bother?
  for (size_t i = 0; i < sizeof(gdb_sections)/sizeof(*gdb_sections); ++i)
    if (strcmp(suffix, gdb_sections[i]) == 0)
      return true;
  return false;
}

// Returns whether the given section is needed for lines-only debugging.

static inline bool
is_lines_only_debug_section(const char* suffix)
{
  // We can do this faster: binary search or a hashtable.  But why bother?
  for (size_t i = 0;
       i < sizeof(lines_only_debug_sections)/sizeof(*lines_only_debug_sections);
       ++i)
    if (strcmp(suffix, lines_only_debug_sections[i]) == 0)
      return true;
  return false;
}

// Returns whether the given section is a fast-lookup section that
// will not be needed when building a .gdb_index section.

static inline bool
is_gdb_fast_lookup_section(const char* suffix)
{
  // We can do this faster: binary search or a hashtable.  But why bother?
  for (size_t i = 0;
       i < sizeof(gdb_fast_lookup_sections)/sizeof(*gdb_fast_lookup_sections);
       ++i)
    if (strcmp(suffix, gdb_fast_lookup_sections[i]) == 0)
      return true;
  return false;
}

// Sometimes we compress sections.  This is typically done for
// sections that are not part of normal program execution (such as
// .debug_* sections), and where the readers of these sections know
// how to deal with compressed sections.  This routine doesn't say for
// certain whether we'll compress -- it depends on commandline options
// as well -- just whether this section is a candidate for compression.
// (The Output_compressed_section class decides whether to compress
// a given section, and picks the name of the compressed section.)

static bool
is_compressible_debug_section(const char* secname)
{
  return (is_prefix_of(".debug", secname));
}

// We may see compressed debug sections in input files.  Return TRUE
// if this is the name of a compressed debug section.

bool
is_compressed_debug_section(const char* secname)
{
  return (is_prefix_of(".zdebug", secname));
}

// Whether to include this section in the link.

template<int size, bool big_endian>
bool
Layout::include_section(Sized_relobj_file<size, big_endian>*, const char* name,
			const elfcpp::Shdr<size, big_endian>& shdr)
{
  if (!parameters->options().relocatable()
      && (shdr.get_sh_flags() & elfcpp::SHF_EXCLUDE))
    return false;

  switch (shdr.get_sh_type())
    {
    case elfcpp::SHT_NULL:
    case elfcpp::SHT_SYMTAB:
    case elfcpp::SHT_DYNSYM:
    case elfcpp::SHT_HASH:
    case elfcpp::SHT_DYNAMIC:
    case elfcpp::SHT_SYMTAB_SHNDX:
      return false;

    case elfcpp::SHT_STRTAB:
      // Discard the sections which have special meanings in the ELF
      // ABI.  Keep others (e.g., .stabstr).  We could also do this by
      // checking the sh_link fields of the appropriate sections.
      return (strcmp(name, ".dynstr") != 0
	      && strcmp(name, ".strtab") != 0
	      && strcmp(name, ".shstrtab") != 0);

    case elfcpp::SHT_RELA:
    case elfcpp::SHT_REL:
    case elfcpp::SHT_GROUP:
      // If we are emitting relocations these should be handled
      // elsewhere.
      gold_assert(!parameters->options().relocatable());
      return false;

    case elfcpp::SHT_PROGBITS:
      if (parameters->options().strip_debug()
	  && (shdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0)
	{
	  if (is_debug_info_section(name))
	    return false;
	}
      if (parameters->options().strip_debug_non_line()
	  && (shdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0)
	{
	  // Debugging sections can only be recognized by name.
	  if (is_prefix_of(".debug_", name)
	      && !is_lines_only_debug_section(name + 7))
	    return false;
	  if (is_prefix_of(".zdebug_", name)
	      && !is_lines_only_debug_section(name + 8))
	    return false;
	}
      if (parameters->options().strip_debug_gdb()
	  && (shdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0)
	{
	  // Debugging sections can only be recognized by name.
	  if (is_prefix_of(".debug_", name)
	      && !is_gdb_debug_section(name + 7))
	    return false;
	  if (is_prefix_of(".zdebug_", name)
	      && !is_gdb_debug_section(name + 8))
	    return false;
	}
      if (parameters->options().gdb_index()
	  && (shdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0)
	{
	  // When building .gdb_index, we can strip .debug_pubnames,
	  // .debug_pubtypes, and .debug_aranges sections.
	  if (is_prefix_of(".debug_", name)
	      && is_gdb_fast_lookup_section(name + 7))
	    return false;
	  if (is_prefix_of(".zdebug_", name)
	      && is_gdb_fast_lookup_section(name + 8))
	    return false;
	}
      if (parameters->options().strip_lto_sections()
	  && !parameters->options().relocatable()
	  && (shdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0)
	{
	  // Ignore LTO sections containing intermediate code.
	  if (is_prefix_of(".gnu.lto_", name))
	    return false;
	}
      // The GNU linker strips .gnu_debuglink sections, so we do too.
      // This is a feature used to keep debugging information in
      // separate files.
      if (strcmp(name, ".gnu_debuglink") == 0)
	return false;
      return true;

    default:
      return true;
    }
}

// Return an output section named NAME, or NULL if there is none.

Output_section*
Layout::find_output_section(const char* name) const
{
  for (Section_list::const_iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    if (strcmp((*p)->name(), name) == 0)
      return *p;
  return NULL;
}

// Return an output segment of type TYPE, with segment flags SET set
// and segment flags CLEAR clear.  Return NULL if there is none.

Output_segment*
Layout::find_output_segment(elfcpp::PT type, elfcpp::Elf_Word set,
			    elfcpp::Elf_Word clear) const
{
  for (Segment_list::const_iterator p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
    if (static_cast<elfcpp::PT>((*p)->type()) == type
	&& ((*p)->flags() & set) == set
	&& ((*p)->flags() & clear) == 0)
      return *p;
  return NULL;
}

// When we put a .ctors or .dtors section with more than one word into
// a .init_array or .fini_array section, we need to reverse the words
// in the .ctors/.dtors section.  This is because .init_array executes
// constructors front to back, where .ctors executes them back to
// front, and vice-versa for .fini_array/.dtors.  Although we do want
// to remap .ctors/.dtors into .init_array/.fini_array because it can
// be more efficient, we don't want to change the order in which
// constructors/destructors are run.  This set just keeps track of
// these sections which need to be reversed.  It is only changed by
// Layout::layout.  It should be a private member of Layout, but that
// would require layout.h to #include object.h to get the definition
// of Section_id.
static Unordered_set<Section_id, Section_id_hash> ctors_sections_in_init_array;

// Return whether OBJECT/SHNDX is a .ctors/.dtors section mapped to a
// .init_array/.fini_array section.

bool
Layout::is_ctors_in_init_array(Relobj* relobj, unsigned int shndx) const
{
  return (ctors_sections_in_init_array.find(Section_id(relobj, shndx))
	  != ctors_sections_in_init_array.end());
}

// Return the output section to use for section NAME with type TYPE
// and section flags FLAGS.  NAME must be canonicalized in the string
// pool, and NAME_KEY is the key.  ORDER is where this should appear
// in the output sections.  IS_RELRO is true for a relro section.

Output_section*
Layout::get_output_section(const char* name, Stringpool::Key name_key,
			   elfcpp::Elf_Word type, elfcpp::Elf_Xword flags,
			   Output_section_order order, bool is_relro)
{
  elfcpp::Elf_Word lookup_type = type;

  // For lookup purposes, treat INIT_ARRAY, FINI_ARRAY, and
  // PREINIT_ARRAY like PROGBITS.  This ensures that we combine
  // .init_array, .fini_array, and .preinit_array sections by name
  // whatever their type in the input file.  We do this because the
  // types are not always right in the input files.
  if (lookup_type == elfcpp::SHT_INIT_ARRAY
      || lookup_type == elfcpp::SHT_FINI_ARRAY
      || lookup_type == elfcpp::SHT_PREINIT_ARRAY)
    lookup_type = elfcpp::SHT_PROGBITS;

  elfcpp::Elf_Xword lookup_flags = flags;

  // Ignoring SHF_WRITE and SHF_EXECINSTR here means that we combine
  // read-write with read-only sections.  Some other ELF linkers do
  // not do this.  FIXME: Perhaps there should be an option
  // controlling this.
  lookup_flags &= ~(elfcpp::SHF_WRITE | elfcpp::SHF_EXECINSTR);

  const Key key(name_key, std::make_pair(lookup_type, lookup_flags));
  const std::pair<Key, Output_section*> v(key, NULL);
  std::pair<Section_name_map::iterator, bool> ins(
    this->section_name_map_.insert(v));

  if (!ins.second)
    return ins.first->second;
  else
    {
      // This is the first time we've seen this name/type/flags
      // combination.  For compatibility with the GNU linker, we
      // combine sections with contents and zero flags with sections
      // with non-zero flags.  This is a workaround for cases where
      // assembler code forgets to set section flags.  FIXME: Perhaps
      // there should be an option to control this.
      Output_section* os = NULL;

      if (lookup_type == elfcpp::SHT_PROGBITS)
	{
	  if (flags == 0)
	    {
	      Output_section* same_name = this->find_output_section(name);
	      if (same_name != NULL
		  && (same_name->type() == elfcpp::SHT_PROGBITS
		      || same_name->type() == elfcpp::SHT_INIT_ARRAY
		      || same_name->type() == elfcpp::SHT_FINI_ARRAY
		      || same_name->type() == elfcpp::SHT_PREINIT_ARRAY)
		  && (same_name->flags() & elfcpp::SHF_TLS) == 0)
		os = same_name;
	    }
	  else if ((flags & elfcpp::SHF_TLS) == 0)
	    {
	      elfcpp::Elf_Xword zero_flags = 0;
	      const Key zero_key(name_key, std::make_pair(lookup_type,
							  zero_flags));
	      Section_name_map::iterator p =
		  this->section_name_map_.find(zero_key);
	      if (p != this->section_name_map_.end())
		os = p->second;
	    }
	}

      if (os == NULL)
	os = this->make_output_section(name, type, flags, order, is_relro);

      ins.first->second = os;
      return os;
    }
}

// Returns TRUE iff NAME (an input section from RELOBJ) will
// be mapped to an output section that should be KEPT.

bool
Layout::keep_input_section(const Relobj* relobj, const char* name)
{
  if (! this->script_options_->saw_sections_clause())
    return false;

  Script_sections* ss = this->script_options_->script_sections();
  const char* file_name = relobj == NULL ? NULL : relobj->name().c_str();
  Output_section** output_section_slot;
  Script_sections::Section_type script_section_type;
  bool keep;

  name = ss->output_section_name(file_name, name, &output_section_slot,
				 &script_section_type, &keep);
  return name != NULL && keep;
}

// Clear the input section flags that should not be copied to the
// output section.

elfcpp::Elf_Xword
Layout::get_output_section_flags(elfcpp::Elf_Xword input_section_flags)
{
  // Some flags in the input section should not be automatically
  // copied to the output section.
  input_section_flags &= ~ (elfcpp::SHF_INFO_LINK
			    | elfcpp::SHF_GROUP
			    | elfcpp::SHF_MERGE
			    | elfcpp::SHF_STRINGS);

  // We only clear the SHF_LINK_ORDER flag in for
  // a non-relocatable link.
  if (!parameters->options().relocatable())
    input_section_flags &= ~elfcpp::SHF_LINK_ORDER;

  return input_section_flags;
}

// Pick the output section to use for section NAME, in input file
// RELOBJ, with type TYPE and flags FLAGS.  RELOBJ may be NULL for a
// linker created section.  IS_INPUT_SECTION is true if we are
// choosing an output section for an input section found in a input
// file.  ORDER is where this section should appear in the output
// sections.  IS_RELRO is true for a relro section.  This will return
// NULL if the input section should be discarded.

Output_section*
Layout::choose_output_section(const Relobj* relobj, const char* name,
			      elfcpp::Elf_Word type, elfcpp::Elf_Xword flags,
			      bool is_input_section, Output_section_order order,
			      bool is_relro)
{
  // We should not see any input sections after we have attached
  // sections to segments.
  gold_assert(!is_input_section || !this->sections_are_attached_);

  flags = this->get_output_section_flags(flags);

  if (this->script_options_->saw_sections_clause())
    {
      // We are using a SECTIONS clause, so the output section is
      // chosen based only on the name.

      Script_sections* ss = this->script_options_->script_sections();
      const char* file_name = relobj == NULL ? NULL : relobj->name().c_str();
      Output_section** output_section_slot;
      Script_sections::Section_type script_section_type;
      const char* orig_name = name;
      bool keep;
      name = ss->output_section_name(file_name, name, &output_section_slot,
				     &script_section_type, &keep);

      if (name == NULL)
	{
	  gold_debug(DEBUG_SCRIPT, _("Unable to create output section '%s' "
				     "because it is not allowed by the "
				     "SECTIONS clause of the linker script"),
		     orig_name);
	  // The SECTIONS clause says to discard this input section.
	  return NULL;
	}

      // We can only handle script section types ST_NONE and ST_NOLOAD.
      switch (script_section_type)
	{
	case Script_sections::ST_NONE:
	  break;
	case Script_sections::ST_NOLOAD:
	  flags &= elfcpp::SHF_ALLOC;
	  break;
	default:
	  gold_unreachable();
	}

      // If this is an orphan section--one not mentioned in the linker
      // script--then OUTPUT_SECTION_SLOT will be NULL, and we do the
      // default processing below.

      if (output_section_slot != NULL)
	{
	  if (*output_section_slot != NULL)
	    {
	      (*output_section_slot)->update_flags_for_input_section(flags);
	      return *output_section_slot;
	    }

	  // We don't put sections found in the linker script into
	  // SECTION_NAME_MAP_.  That keeps us from getting confused
	  // if an orphan section is mapped to a section with the same
	  // name as one in the linker script.

	  name = this->namepool_.add(name, false, NULL);

	  Output_section* os = this->make_output_section(name, type, flags,
							 order, is_relro);

	  os->set_found_in_sections_clause();

	  // Special handling for NOLOAD sections.
	  if (script_section_type == Script_sections::ST_NOLOAD)
	    {
	      os->set_is_noload();

	      // The constructor of Output_section sets addresses of non-ALLOC
	      // sections to 0 by default.  We don't want that for NOLOAD
	      // sections even if they have no SHF_ALLOC flag.
	      if ((os->flags() & elfcpp::SHF_ALLOC) == 0
		  && os->is_address_valid())
		{
		  gold_assert(os->address() == 0
			      && !os->is_offset_valid()
			      && !os->is_data_size_valid());
		  os->reset_address_and_file_offset();
		}
	    }

	  *output_section_slot = os;
	  return os;
	}
    }

  // FIXME: Handle SHF_OS_NONCONFORMING somewhere.

  size_t len = strlen(name);
  char* uncompressed_name = NULL;

  // Compressed debug sections should be mapped to the corresponding
  // uncompressed section.
  if (is_compressed_debug_section(name))
    {
      uncompressed_name = new char[len];
      uncompressed_name[0] = '.';
      gold_assert(name[0] == '.' && name[1] == 'z');
      strncpy(&uncompressed_name[1], &name[2], len - 2);
      uncompressed_name[len - 1] = '\0';
      len -= 1;
      name = uncompressed_name;
    }

  // Turn NAME from the name of the input section into the name of the
  // output section.
  if (is_input_section
      && !this->script_options_->saw_sections_clause()
      && !parameters->options().relocatable())
    {
      const char *orig_name = name;
      name = parameters->target().output_section_name(relobj, name, &len);
      if (name == NULL)
	name = Layout::output_section_name(relobj, orig_name, &len);
    }

  Stringpool::Key name_key;
  name = this->namepool_.add_with_length(name, len, true, &name_key);

  if (uncompressed_name != NULL)
    delete[] uncompressed_name;

  // Find or make the output section.  The output section is selected
  // based on the section name, type, and flags.
  return this->get_output_section(name, name_key, type, flags, order, is_relro);
}

// For incremental links, record the initial fixed layout of a section
// from the base file, and return a pointer to the Output_section.

template<int size, bool big_endian>
Output_section*
Layout::init_fixed_output_section(const char* name,
				  elfcpp::Shdr<size, big_endian>& shdr)
{
  unsigned int sh_type = shdr.get_sh_type();

  // We preserve the layout of PROGBITS, NOBITS, INIT_ARRAY, FINI_ARRAY,
  // PRE_INIT_ARRAY, and NOTE sections.
  // All others will be created from scratch and reallocated.
  if (!can_incremental_update(sh_type))
    return NULL;

  // If we're generating a .gdb_index section, we need to regenerate
  // it from scratch.
  if (parameters->options().gdb_index()
      && sh_type == elfcpp::SHT_PROGBITS
      && strcmp(name, ".gdb_index") == 0)
    return NULL;

  typename elfcpp::Elf_types<size>::Elf_Addr sh_addr = shdr.get_sh_addr();
  typename elfcpp::Elf_types<size>::Elf_Off sh_offset = shdr.get_sh_offset();
  typename elfcpp::Elf_types<size>::Elf_WXword sh_size = shdr.get_sh_size();
  typename elfcpp::Elf_types<size>::Elf_WXword sh_flags = shdr.get_sh_flags();
  typename elfcpp::Elf_types<size>::Elf_WXword sh_addralign =
      shdr.get_sh_addralign();

  // Make the output section.
  Stringpool::Key name_key;
  name = this->namepool_.add(name, true, &name_key);
  Output_section* os = this->get_output_section(name, name_key, sh_type,
						sh_flags, ORDER_INVALID, false);
  os->set_fixed_layout(sh_addr, sh_offset, sh_size, sh_addralign);
  if (sh_type != elfcpp::SHT_NOBITS)
    this->free_list_.remove(sh_offset, sh_offset + sh_size);
  return os;
}

// Return the index by which an input section should be ordered.  This
// is used to sort some .text sections, for compatibility with GNU ld.

int
Layout::special_ordering_of_input_section(const char* name)
{
  // The GNU linker has some special handling for some sections that
  // wind up in the .text section.  Sections that start with these
  // prefixes must appear first, and must appear in the order listed
  // here.
  static const char* const text_section_sort[] =
  {
    ".text.unlikely",
    ".text.exit",
    ".text.startup",
    ".text.hot"
  };

  for (size_t i = 0;
       i < sizeof(text_section_sort) / sizeof(text_section_sort[0]);
       i++)
    if (is_prefix_of(text_section_sort[i], name))
      return i;

  return -1;
}

// Return the output section to use for input section SHNDX, with name
// NAME, with header HEADER, from object OBJECT.  RELOC_SHNDX is the
// index of a relocation section which applies to this section, or 0
// if none, or -1U if more than one.  RELOC_TYPE is the type of the
// relocation section if there is one.  Set *OFF to the offset of this
// input section without the output section.  Return NULL if the
// section should be discarded.  Set *OFF to -1 if the section
// contents should not be written directly to the output file, but
// will instead receive special handling.

template<int size, bool big_endian>
Output_section*
Layout::layout(Sized_relobj_file<size, big_endian>* object, unsigned int shndx,
	       const char* name, const elfcpp::Shdr<size, big_endian>& shdr,
	       unsigned int reloc_shndx, unsigned int, off_t* off)
{
  *off = 0;

  if (!this->include_section(object, name, shdr))
    return NULL;

  elfcpp::Elf_Word sh_type = shdr.get_sh_type();

  // In a relocatable link a grouped section must not be combined with
  // any other sections.
  Output_section* os;
  if (parameters->options().relocatable()
      && (shdr.get_sh_flags() & elfcpp::SHF_GROUP) != 0)
    {
      name = this->namepool_.add(name, true, NULL);
      os = this->make_output_section(name, sh_type, shdr.get_sh_flags(),
				     ORDER_INVALID, false);
    }
  else
    {
      // Plugins can choose to place one or more subsets of sections in
      // unique segments and this is done by mapping these section subsets
      // to unique output sections.  Check if this section needs to be
      // remapped to a unique output section.
      Section_segment_map::iterator it
	  = this->section_segment_map_.find(Const_section_id(object, shndx));
      if (it == this->section_segment_map_.end())
	{
	  os = this->choose_output_section(object, name, sh_type,
					   shdr.get_sh_flags(), true,
					   ORDER_INVALID, false);
	}
      else
	{
	  // We know the name of the output section, directly call
	  // get_output_section here by-passing choose_output_section.
	  elfcpp::Elf_Xword flags
	    = this->get_output_section_flags(shdr.get_sh_flags());

	  const char* os_name = it->second->name;
	  Stringpool::Key name_key;
	  os_name = this->namepool_.add(os_name, true, &name_key);
	  os = this->get_output_section(os_name, name_key, sh_type, flags,
					ORDER_INVALID, false);
	  if (!os->is_unique_segment())
	    {
	      os->set_is_unique_segment();
	      os->set_extra_segment_flags(it->second->flags);
	      os->set_segment_alignment(it->second->align);
	    }
	}
      if (os == NULL)
	return NULL;
    }

  // By default the GNU linker sorts input sections whose names match
  // .ctors.*, .dtors.*, .init_array.*, or .fini_array.*.  The
  // sections are sorted by name.  This is used to implement
  // constructor priority ordering.  We are compatible.  When we put
  // .ctor sections in .init_array and .dtor sections in .fini_array,
  // we must also sort plain .ctor and .dtor sections.
  if (!this->script_options_->saw_sections_clause()
      && !parameters->options().relocatable()
      && (is_prefix_of(".ctors.", name)
	  || is_prefix_of(".dtors.", name)
	  || is_prefix_of(".init_array.", name)
	  || is_prefix_of(".fini_array.", name)
	  || (parameters->options().ctors_in_init_array()
	      && (strcmp(name, ".ctors") == 0
		  || strcmp(name, ".dtors") == 0))))
    os->set_must_sort_attached_input_sections();

  // By default the GNU linker sorts some special text sections ahead
  // of others.  We are compatible.
  if (parameters->options().text_reorder()
      && !this->script_options_->saw_sections_clause()
      && !this->is_section_ordering_specified()
      && !parameters->options().relocatable()
      && Layout::special_ordering_of_input_section(name) >= 0)
    os->set_must_sort_attached_input_sections();

  // If this is a .ctors or .ctors.* section being mapped to a
  // .init_array section, or a .dtors or .dtors.* section being mapped
  // to a .fini_array section, we will need to reverse the words if
  // there is more than one.  Record this section for later.  See
  // ctors_sections_in_init_array above.
  if (!this->script_options_->saw_sections_clause()
      && !parameters->options().relocatable()
      && shdr.get_sh_size() > size / 8
      && (((strcmp(name, ".ctors") == 0
	    || is_prefix_of(".ctors.", name))
	   && strcmp(os->name(), ".init_array") == 0)
	  || ((strcmp(name, ".dtors") == 0
	       || is_prefix_of(".dtors.", name))
	      && strcmp(os->name(), ".fini_array") == 0)))
    ctors_sections_in_init_array.insert(Section_id(object, shndx));

  // FIXME: Handle SHF_LINK_ORDER somewhere.

  elfcpp::Elf_Xword orig_flags = os->flags();

  *off = os->add_input_section(this, object, shndx, name, shdr, reloc_shndx,
			       this->script_options_->saw_sections_clause());

  // If the flags changed, we may have to change the order.
  if ((orig_flags & elfcpp::SHF_ALLOC) != 0)
    {
      orig_flags &= (elfcpp::SHF_WRITE | elfcpp::SHF_EXECINSTR);
      elfcpp::Elf_Xword new_flags =
	os->flags() & (elfcpp::SHF_WRITE | elfcpp::SHF_EXECINSTR);
      if (orig_flags != new_flags)
	os->set_order(this->default_section_order(os, false));
    }

  this->have_added_input_section_ = true;

  return os;
}

// Maps section SECN to SEGMENT s.
void
Layout::insert_section_segment_map(Const_section_id secn,
				   Unique_segment_info *s)
{
  gold_assert(this->unique_segment_for_sections_specified_);
  this->section_segment_map_[secn] = s;
}

// Handle a relocation section when doing a relocatable link.

template<int size, bool big_endian>
Output_section*
Layout::layout_reloc(Sized_relobj_file<size, big_endian>* object,
		     unsigned int,
		     const elfcpp::Shdr<size, big_endian>& shdr,
		     Output_section* data_section,
		     Relocatable_relocs* rr)
{
  gold_assert(parameters->options().relocatable()
	      || parameters->options().emit_relocs());

  int sh_type = shdr.get_sh_type();

  std::string name;
  if (sh_type == elfcpp::SHT_REL)
    name = ".rel";
  else if (sh_type == elfcpp::SHT_RELA)
    name = ".rela";
  else
    gold_unreachable();
  name += data_section->name();

  // In a relocatable link relocs for a grouped section must not be
  // combined with other reloc sections.
  Output_section* os;
  if (!parameters->options().relocatable()
      || (data_section->flags() & elfcpp::SHF_GROUP) == 0)
    os = this->choose_output_section(object, name.c_str(), sh_type,
				     shdr.get_sh_flags(), false,
				     ORDER_INVALID, false);
  else
    {
      const char* n = this->namepool_.add(name.c_str(), true, NULL);
      os = this->make_output_section(n, sh_type, shdr.get_sh_flags(),
				     ORDER_INVALID, false);
    }

  os->set_should_link_to_symtab();
  os->set_info_section(data_section);

  Output_section_data* posd;
  if (sh_type == elfcpp::SHT_REL)
    {
      os->set_entsize(elfcpp::Elf_sizes<size>::rel_size);
      posd = new Output_relocatable_relocs<elfcpp::SHT_REL,
					   size,
					   big_endian>(rr);
    }
  else if (sh_type == elfcpp::SHT_RELA)
    {
      os->set_entsize(elfcpp::Elf_sizes<size>::rela_size);
      posd = new Output_relocatable_relocs<elfcpp::SHT_RELA,
					   size,
					   big_endian>(rr);
    }
  else
    gold_unreachable();

  os->add_output_section_data(posd);
  rr->set_output_data(posd);

  return os;
}

// Handle a group section when doing a relocatable link.

template<int size, bool big_endian>
void
Layout::layout_group(Symbol_table* symtab,
		     Sized_relobj_file<size, big_endian>* object,
		     unsigned int,
		     const char* group_section_name,
		     const char* signature,
		     const elfcpp::Shdr<size, big_endian>& shdr,
		     elfcpp::Elf_Word flags,
		     std::vector<unsigned int>* shndxes)
{
  gold_assert(parameters->options().relocatable());
  gold_assert(shdr.get_sh_type() == elfcpp::SHT_GROUP);
  group_section_name = this->namepool_.add(group_section_name, true, NULL);
  Output_section* os = this->make_output_section(group_section_name,
						 elfcpp::SHT_GROUP,
						 shdr.get_sh_flags(),
						 ORDER_INVALID, false);

  // We need to find a symbol with the signature in the symbol table.
  // If we don't find one now, we need to look again later.
  Symbol* sym = symtab->lookup(signature, NULL);
  if (sym != NULL)
    os->set_info_symndx(sym);
  else
    {
      // Reserve some space to minimize reallocations.
      if (this->group_signatures_.empty())
	this->group_signatures_.reserve(this->number_of_input_files_ * 16);

      // We will wind up using a symbol whose name is the signature.
      // So just put the signature in the symbol name pool to save it.
      signature = symtab->canonicalize_name(signature);
      this->group_signatures_.push_back(Group_signature(os, signature));
    }

  os->set_should_link_to_symtab();
  os->set_entsize(4);

  section_size_type entry_count =
    convert_to_section_size_type(shdr.get_sh_size() / 4);
  Output_section_data* posd =
    new Output_data_group<size, big_endian>(object, entry_count, flags,
					    shndxes);
  os->add_output_section_data(posd);
}

// Special GNU handling of sections name .eh_frame.  They will
// normally hold exception frame data as defined by the C++ ABI
// (http://codesourcery.com/cxx-abi/).

template<int size, bool big_endian>
Output_section*
Layout::layout_eh_frame(Sized_relobj_file<size, big_endian>* object,
			const unsigned char* symbols,
			off_t symbols_size,
			const unsigned char* symbol_names,
			off_t symbol_names_size,
			unsigned int shndx,
			const elfcpp::Shdr<size, big_endian>& shdr,
			unsigned int reloc_shndx, unsigned int reloc_type,
			off_t* off)
{
  gold_assert(shdr.get_sh_type() == elfcpp::SHT_PROGBITS
	      || shdr.get_sh_type() == elfcpp::SHT_X86_64_UNWIND);
  gold_assert((shdr.get_sh_flags() & elfcpp::SHF_ALLOC) != 0);

  Output_section* os = this->make_eh_frame_section(object);
  if (os == NULL)
    return NULL;

  gold_assert(this->eh_frame_section_ == os);

  elfcpp::Elf_Xword orig_flags = os->flags();

  if (!parameters->incremental()
      && this->eh_frame_data_->add_ehframe_input_section(object,
							 symbols,
							 symbols_size,
							 symbol_names,
							 symbol_names_size,
							 shndx,
							 reloc_shndx,
							 reloc_type))
    {
      os->update_flags_for_input_section(shdr.get_sh_flags());

      // A writable .eh_frame section is a RELRO section.
      if ((orig_flags & (elfcpp::SHF_WRITE | elfcpp::SHF_EXECINSTR))
	  != (os->flags() & (elfcpp::SHF_WRITE | elfcpp::SHF_EXECINSTR)))
	{
	  os->set_is_relro();
	  os->set_order(ORDER_RELRO);
	}

      // We found a .eh_frame section we are going to optimize, so now
      // we can add the set of optimized sections to the output
      // section.  We need to postpone adding this until we've found a
      // section we can optimize so that the .eh_frame section in
      // crtbegin.o winds up at the start of the output section.
      if (!this->added_eh_frame_data_)
	{
	  os->add_output_section_data(this->eh_frame_data_);
	  this->added_eh_frame_data_ = true;
	}
      *off = -1;
    }
  else
    {
      // We couldn't handle this .eh_frame section for some reason.
      // Add it as a normal section.
      bool saw_sections_clause = this->script_options_->saw_sections_clause();
      *off = os->add_input_section(this, object, shndx, ".eh_frame", shdr,
				   reloc_shndx, saw_sections_clause);
      this->have_added_input_section_ = true;

      if ((orig_flags & (elfcpp::SHF_WRITE | elfcpp::SHF_EXECINSTR))
	  != (os->flags() & (elfcpp::SHF_WRITE | elfcpp::SHF_EXECINSTR)))
	os->set_order(this->default_section_order(os, false));
    }

  return os;
}

// Create and return the magic .eh_frame section.  Create
// .eh_frame_hdr also if appropriate.  OBJECT is the object with the
// input .eh_frame section; it may be NULL.

Output_section*
Layout::make_eh_frame_section(const Relobj* object)
{
  // FIXME: On x86_64, this could use SHT_X86_64_UNWIND rather than
  // SHT_PROGBITS.
  Output_section* os = this->choose_output_section(object, ".eh_frame",
						   elfcpp::SHT_PROGBITS,
						   elfcpp::SHF_ALLOC, false,
						   ORDER_EHFRAME, false);
  if (os == NULL)
    return NULL;

  if (this->eh_frame_section_ == NULL)
    {
      this->eh_frame_section_ = os;
      this->eh_frame_data_ = new Eh_frame();

      // For incremental linking, we do not optimize .eh_frame sections
      // or create a .eh_frame_hdr section.
      if (parameters->options().eh_frame_hdr() && !parameters->incremental())
	{
	  Output_section* hdr_os =
	    this->choose_output_section(NULL, ".eh_frame_hdr",
					elfcpp::SHT_PROGBITS,
					elfcpp::SHF_ALLOC, false,
					ORDER_EHFRAME, false);

	  if (hdr_os != NULL)
	    {
	      Eh_frame_hdr* hdr_posd = new Eh_frame_hdr(os,
							this->eh_frame_data_);
	      hdr_os->add_output_section_data(hdr_posd);

	      hdr_os->set_after_input_sections();

	      if (!this->script_options_->saw_phdrs_clause())
		{
		  Output_segment* hdr_oseg;
		  hdr_oseg = this->make_output_segment(elfcpp::PT_GNU_EH_FRAME,
						       elfcpp::PF_R);
		  hdr_oseg->add_output_section_to_nonload(hdr_os,
							  elfcpp::PF_R);
		}

	      this->eh_frame_data_->set_eh_frame_hdr(hdr_posd);
	    }
	}
    }

  return os;
}

// Add an exception frame for a PLT.  This is called from target code.

void
Layout::add_eh_frame_for_plt(Output_data* plt, const unsigned char* cie_data,
			     size_t cie_length, const unsigned char* fde_data,
			     size_t fde_length)
{
  if (parameters->incremental())
    {
      // FIXME: Maybe this could work some day....
      return;
    }
  Output_section* os = this->make_eh_frame_section(NULL);
  if (os == NULL)
    return;
  this->eh_frame_data_->add_ehframe_for_plt(plt, cie_data, cie_length,
					    fde_data, fde_length);
  if (!this->added_eh_frame_data_)
    {
      os->add_output_section_data(this->eh_frame_data_);
      this->added_eh_frame_data_ = true;
    }
}

// Scan a .debug_info or .debug_types section, and add summary
// information to the .gdb_index section.

template<int size, bool big_endian>
void
Layout::add_to_gdb_index(bool is_type_unit,
			 Sized_relobj<size, big_endian>* object,
			 const unsigned char* symbols,
			 off_t symbols_size,
			 unsigned int shndx,
			 unsigned int reloc_shndx,
			 unsigned int reloc_type)
{
  if (this->gdb_index_data_ == NULL)
    {
      Output_section* os = this->choose_output_section(NULL, ".gdb_index",
						       elfcpp::SHT_PROGBITS, 0,
						       false, ORDER_INVALID,
						       false);
      if (os == NULL)
	return;

      this->gdb_index_data_ = new Gdb_index(os);
      os->add_output_section_data(this->gdb_index_data_);
      os->set_after_input_sections();
    }

  this->gdb_index_data_->scan_debug_info(is_type_unit, object, symbols,
					 symbols_size, shndx, reloc_shndx,
					 reloc_type);
}

// Add POSD to an output section using NAME, TYPE, and FLAGS.  Return
// the output section.

Output_section*
Layout::add_output_section_data(const char* name, elfcpp::Elf_Word type,
				elfcpp::Elf_Xword flags,
				Output_section_data* posd,
				Output_section_order order, bool is_relro)
{
  Output_section* os = this->choose_output_section(NULL, name, type, flags,
						   false, order, is_relro);
  if (os != NULL)
    os->add_output_section_data(posd);
  return os;
}

// Map section flags to segment flags.

elfcpp::Elf_Word
Layout::section_flags_to_segment(elfcpp::Elf_Xword flags)
{
  elfcpp::Elf_Word ret = elfcpp::PF_R;
  if ((flags & elfcpp::SHF_WRITE) != 0)
    ret |= elfcpp::PF_W;
  if ((flags & elfcpp::SHF_EXECINSTR) != 0)
    ret |= elfcpp::PF_X;
  return ret;
}

// Make a new Output_section, and attach it to segments as
// appropriate.  ORDER is the order in which this section should
// appear in the output segment.  IS_RELRO is true if this is a relro
// (read-only after relocations) section.

Output_section*
Layout::make_output_section(const char* name, elfcpp::Elf_Word type,
			    elfcpp::Elf_Xword flags,
			    Output_section_order order, bool is_relro)
{
  Output_section* os;
  if ((flags & elfcpp::SHF_ALLOC) == 0
      && strcmp(parameters->options().compress_debug_sections(), "none") != 0
      && is_compressible_debug_section(name))
    os = new Output_compressed_section(&parameters->options(), name, type,
				       flags);
  else if ((flags & elfcpp::SHF_ALLOC) == 0
	   && parameters->options().strip_debug_non_line()
	   && strcmp(".debug_abbrev", name) == 0)
    {
      os = this->debug_abbrev_ = new Output_reduced_debug_abbrev_section(
	  name, type, flags);
      if (this->debug_info_)
	this->debug_info_->set_abbreviations(this->debug_abbrev_);
    }
  else if ((flags & elfcpp::SHF_ALLOC) == 0
	   && parameters->options().strip_debug_non_line()
	   && strcmp(".debug_info", name) == 0)
    {
      os = this->debug_info_ = new Output_reduced_debug_info_section(
	  name, type, flags);
      if (this->debug_abbrev_)
	this->debug_info_->set_abbreviations(this->debug_abbrev_);
    }
  else
    {
      // Sometimes .init_array*, .preinit_array* and .fini_array* do
      // not have correct section types.  Force them here.
      if (type == elfcpp::SHT_PROGBITS)
	{
	  if (is_prefix_of(".init_array", name))
	    type = elfcpp::SHT_INIT_ARRAY;
	  else if (is_prefix_of(".preinit_array", name))
	    type = elfcpp::SHT_PREINIT_ARRAY;
	  else if (is_prefix_of(".fini_array", name))
	    type = elfcpp::SHT_FINI_ARRAY;
	}

      // FIXME: const_cast is ugly.
      Target* target = const_cast<Target*>(&parameters->target());
      os = target->make_output_section(name, type, flags);
    }

  // With -z relro, we have to recognize the special sections by name.
  // There is no other way.
  bool is_relro_local = false;
  if (!this->script_options_->saw_sections_clause()
      && parameters->options().relro()
      && (flags & elfcpp::SHF_ALLOC) != 0
      && (flags & elfcpp::SHF_WRITE) != 0)
    {
      if (type == elfcpp::SHT_PROGBITS)
	{
	  if ((flags & elfcpp::SHF_TLS) != 0)
	    is_relro = true;
	  else if (strcmp(name, ".data.rel.ro") == 0)
	    is_relro = true;
	  else if (strcmp(name, ".data.rel.ro.local") == 0)
	    {
	      is_relro = true;
	      is_relro_local = true;
	    }
	  else if (strcmp(name, ".ctors") == 0
		   || strcmp(name, ".dtors") == 0
		   || strcmp(name, ".jcr") == 0)
	    is_relro = true;
	}
      else if (type == elfcpp::SHT_INIT_ARRAY
	       || type == elfcpp::SHT_FINI_ARRAY
	       || type == elfcpp::SHT_PREINIT_ARRAY)
	is_relro = true;
    }

  if (is_relro)
    os->set_is_relro();

  if (order == ORDER_INVALID && (flags & elfcpp::SHF_ALLOC) != 0)
    order = this->default_section_order(os, is_relro_local);

  os->set_order(order);

  parameters->target().new_output_section(os);

  this->section_list_.push_back(os);

  // The GNU linker by default sorts some sections by priority, so we
  // do the same.  We need to know that this might happen before we
  // attach any input sections.
  if (!this->script_options_->saw_sections_clause()
      && !parameters->options().relocatable()
      && (strcmp(name, ".init_array") == 0
	  || strcmp(name, ".fini_array") == 0
	  || (!parameters->options().ctors_in_init_array()
	      && (strcmp(name, ".ctors") == 0
		  || strcmp(name, ".dtors") == 0))))
    os->set_may_sort_attached_input_sections();

  // The GNU linker by default sorts .text.{unlikely,exit,startup,hot}
  // sections before other .text sections.  We are compatible.  We
  // need to know that this might happen before we attach any input
  // sections.
  if (parameters->options().text_reorder()
      && !this->script_options_->saw_sections_clause()
      && !this->is_section_ordering_specified()
      && !parameters->options().relocatable()
      && strcmp(name, ".text") == 0)
    os->set_may_sort_attached_input_sections();

  // GNU linker sorts section by name with --sort-section=name.
  if (strcmp(parameters->options().sort_section(), "name") == 0)
      os->set_must_sort_attached_input_sections();

  // Check for .stab*str sections, as .stab* sections need to link to
  // them.
  if (type == elfcpp::SHT_STRTAB
      && !this->have_stabstr_section_
      && strncmp(name, ".stab", 5) == 0
      && strcmp(name + strlen(name) - 3, "str") == 0)
    this->have_stabstr_section_ = true;

  // During a full incremental link, we add patch space to most
  // PROGBITS and NOBITS sections.  Flag those that may be
  // arbitrarily padded.
  if ((type == elfcpp::SHT_PROGBITS || type == elfcpp::SHT_NOBITS)
      && order != ORDER_INTERP
      && order != ORDER_INIT
      && order != ORDER_PLT
      && order != ORDER_FINI
      && order != ORDER_RELRO_LAST
      && order != ORDER_NON_RELRO_FIRST
      && strcmp(name, ".eh_frame") != 0
      && strcmp(name, ".ctors") != 0
      && strcmp(name, ".dtors") != 0
      && strcmp(name, ".jcr") != 0)
    {
      os->set_is_patch_space_allowed();

      // Certain sections require "holes" to be filled with
      // specific fill patterns.  These fill patterns may have
      // a minimum size, so we must prevent allocations from the
      // free list that leave a hole smaller than the minimum.
      if (strcmp(name, ".debug_info") == 0)
	os->set_free_space_fill(new Output_fill_debug_info(false));
      else if (strcmp(name, ".debug_types") == 0)
	os->set_free_space_fill(new Output_fill_debug_info(true));
      else if (strcmp(name, ".debug_line") == 0)
	os->set_free_space_fill(new Output_fill_debug_line());
    }

  // If we have already attached the sections to segments, then we
  // need to attach this one now.  This happens for sections created
  // directly by the linker.
  if (this->sections_are_attached_)
    this->attach_section_to_segment(&parameters->target(), os);

  return os;
}

// Return the default order in which a section should be placed in an
// output segment.  This function captures a lot of the ideas in
// ld/scripttempl/elf.sc in the GNU linker.  Note that the order of a
// linker created section is normally set when the section is created;
// this function is used for input sections.

Output_section_order
Layout::default_section_order(Output_section* os, bool is_relro_local)
{
  gold_assert((os->flags() & elfcpp::SHF_ALLOC) != 0);
  bool is_write = (os->flags() & elfcpp::SHF_WRITE) != 0;
  bool is_execinstr = (os->flags() & elfcpp::SHF_EXECINSTR) != 0;
  bool is_bss = false;

  switch (os->type())
    {
    default:
    case elfcpp::SHT_PROGBITS:
      break;
    case elfcpp::SHT_NOBITS:
      is_bss = true;
      break;
    case elfcpp::SHT_RELA:
    case elfcpp::SHT_REL:
      if (!is_write)
	return ORDER_DYNAMIC_RELOCS;
      break;
    case elfcpp::SHT_HASH:
    case elfcpp::SHT_DYNAMIC:
    case elfcpp::SHT_SHLIB:
    case elfcpp::SHT_DYNSYM:
    case elfcpp::SHT_GNU_HASH:
    case elfcpp::SHT_GNU_verdef:
    case elfcpp::SHT_GNU_verneed:
    case elfcpp::SHT_GNU_versym:
      if (!is_write)
	return ORDER_DYNAMIC_LINKER;
      break;
    case elfcpp::SHT_NOTE:
      return is_write ? ORDER_RW_NOTE : ORDER_RO_NOTE;
    }

  if ((os->flags() & elfcpp::SHF_TLS) != 0)
    return is_bss ? ORDER_TLS_BSS : ORDER_TLS_DATA;

  if (!is_bss && !is_write)
    {
      if (is_execinstr)
	{
	  if (strcmp(os->name(), ".init") == 0)
	    return ORDER_INIT;
	  else if (strcmp(os->name(), ".fini") == 0)
	    return ORDER_FINI;
	}
      return is_execinstr ? ORDER_TEXT : ORDER_READONLY;
    }

  if (os->is_relro())
    return is_relro_local ? ORDER_RELRO_LOCAL : ORDER_RELRO;

  if (os->is_small_section())
    return is_bss ? ORDER_SMALL_BSS : ORDER_SMALL_DATA;
  if (os->is_large_section())
    return is_bss ? ORDER_LARGE_BSS : ORDER_LARGE_DATA;

  return is_bss ? ORDER_BSS : ORDER_DATA;
}

// Attach output sections to segments.  This is called after we have
// seen all the input sections.

void
Layout::attach_sections_to_segments(const Target* target)
{
  for (Section_list::iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    this->attach_section_to_segment(target, *p);

  this->sections_are_attached_ = true;
}

// Attach an output section to a segment.

void
Layout::attach_section_to_segment(const Target* target, Output_section* os)
{
  if ((os->flags() & elfcpp::SHF_ALLOC) == 0)
    this->unattached_section_list_.push_back(os);
  else
    this->attach_allocated_section_to_segment(target, os);
}

// Attach an allocated output section to a segment.

void
Layout::attach_allocated_section_to_segment(const Target* target,
					    Output_section* os)
{
  elfcpp::Elf_Xword flags = os->flags();
  gold_assert((flags & elfcpp::SHF_ALLOC) != 0);

  if (parameters->options().relocatable())
    return;

  // If we have a SECTIONS clause, we can't handle the attachment to
  // segments until after we've seen all the sections.
  if (this->script_options_->saw_sections_clause())
    return;

  gold_assert(!this->script_options_->saw_phdrs_clause());

  // This output section goes into a PT_LOAD segment.

  elfcpp::Elf_Word seg_flags = Layout::section_flags_to_segment(flags);

  // If this output section's segment has extra flags that need to be set,
  // coming from a linker plugin, do that.
  seg_flags |= os->extra_segment_flags();

  // Check for --section-start.
  uint64_t addr;
  bool is_address_set = parameters->options().section_start(os->name(), &addr);

  // In general the only thing we really care about for PT_LOAD
  // segments is whether or not they are writable or executable,
  // so that is how we search for them.
  // Large data sections also go into their own PT_LOAD segment.
  // People who need segments sorted on some other basis will
  // have to use a linker script.

  Segment_list::const_iterator p;
  if (!os->is_unique_segment())
    {
      for (p = this->segment_list_.begin();
	   p != this->segment_list_.end();
	   ++p)
	{
	  if ((*p)->type() != elfcpp::PT_LOAD)
	    continue;
	  if ((*p)->is_unique_segment())
	    continue;
	  if (!parameters->options().omagic()
	      && ((*p)->flags() & elfcpp::PF_W) != (seg_flags & elfcpp::PF_W))
	    continue;
	  if ((target->isolate_execinstr() || parameters->options().rosegment())
	      && ((*p)->flags() & elfcpp::PF_X) != (seg_flags & elfcpp::PF_X))
	    continue;
	  // If -Tbss was specified, we need to separate the data and BSS
	  // segments.
	  if (parameters->options().user_set_Tbss())
	    {
	      if ((os->type() == elfcpp::SHT_NOBITS)
		  == (*p)->has_any_data_sections())
		continue;
	    }
	  if (os->is_large_data_section() && !(*p)->is_large_data_segment())
	    continue;

	  if (is_address_set)
	    {
	      if ((*p)->are_addresses_set())
		continue;

	      (*p)->add_initial_output_data(os);
	      (*p)->update_flags_for_output_section(seg_flags);
	      (*p)->set_addresses(addr, addr);
	      break;
	    }

	  (*p)->add_output_section_to_load(this, os, seg_flags);
	  break;
	}
    }

  if (p == this->segment_list_.end()
      || os->is_unique_segment())
    {
      Output_segment* oseg = this->make_output_segment(elfcpp::PT_LOAD,
						       seg_flags);
      if (os->is_large_data_section())
	oseg->set_is_large_data_segment();
      oseg->add_output_section_to_load(this, os, seg_flags);
      if (is_address_set)
	oseg->set_addresses(addr, addr);
      // Check if segment should be marked unique.  For segments marked
      // unique by linker plugins, set the new alignment if specified.
      if (os->is_unique_segment())
	{
	  oseg->set_is_unique_segment();
	  if (os->segment_alignment() != 0)
	    oseg->set_minimum_p_align(os->segment_alignment());
	}
    }

  // If we see a loadable SHT_NOTE section, we create a PT_NOTE
  // segment.
  if (os->type() == elfcpp::SHT_NOTE)
    {
      // See if we already have an equivalent PT_NOTE segment.
      for (p = this->segment_list_.begin();
	   p != segment_list_.end();
	   ++p)
	{
	  if ((*p)->type() == elfcpp::PT_NOTE
	      && (((*p)->flags() & elfcpp::PF_W)
		  == (seg_flags & elfcpp::PF_W)))
	    {
	      (*p)->add_output_section_to_nonload(os, seg_flags);
	      break;
	    }
	}

      if (p == this->segment_list_.end())
	{
	  Output_segment* oseg = this->make_output_segment(elfcpp::PT_NOTE,
							   seg_flags);
	  oseg->add_output_section_to_nonload(os, seg_flags);
	}
    }

  // If we see a loadable SHF_TLS section, we create a PT_TLS
  // segment.  There can only be one such segment.
  if ((flags & elfcpp::SHF_TLS) != 0)
    {
      if (this->tls_segment_ == NULL)
	this->make_output_segment(elfcpp::PT_TLS, seg_flags);
      this->tls_segment_->add_output_section_to_nonload(os, seg_flags);
    }

  // If -z relro is in effect, and we see a relro section, we create a
  // PT_GNU_RELRO segment.  There can only be one such segment.
  if (os->is_relro() && parameters->options().relro())
    {
      gold_assert(seg_flags == (elfcpp::PF_R | elfcpp::PF_W));
      if (this->relro_segment_ == NULL)
	this->make_output_segment(elfcpp::PT_GNU_RELRO, seg_flags);
      this->relro_segment_->add_output_section_to_nonload(os, seg_flags);
    }

  // If we see a section named .interp, put it into a PT_INTERP
  // segment.  This seems broken to me, but this is what GNU ld does,
  // and glibc expects it.
  if (strcmp(os->name(), ".interp") == 0
      && !this->script_options_->saw_phdrs_clause())
    {
      if (this->interp_segment_ == NULL)
	this->make_output_segment(elfcpp::PT_INTERP, seg_flags);
      else
	gold_warning(_("multiple '.interp' sections in input files "
		       "may cause confusing PT_INTERP segment"));
      this->interp_segment_->add_output_section_to_nonload(os, seg_flags);
    }
}

// Make an output section for a script.

Output_section*
Layout::make_output_section_for_script(
    const char* name,
    Script_sections::Section_type section_type)
{
  name = this->namepool_.add(name, false, NULL);
  elfcpp::Elf_Xword sh_flags = elfcpp::SHF_ALLOC;
  if (section_type == Script_sections::ST_NOLOAD)
    sh_flags = 0;
  Output_section* os = this->make_output_section(name, elfcpp::SHT_PROGBITS,
						 sh_flags, ORDER_INVALID,
						 false);
  os->set_found_in_sections_clause();
  if (section_type == Script_sections::ST_NOLOAD)
    os->set_is_noload();
  return os;
}

// Return the number of segments we expect to see.

size_t
Layout::expected_segment_count() const
{
  size_t ret = this->segment_list_.size();

  // If we didn't see a SECTIONS clause in a linker script, we should
  // already have the complete list of segments.  Otherwise we ask the
  // SECTIONS clause how many segments it expects, and add in the ones
  // we already have (PT_GNU_STACK, PT_GNU_EH_FRAME, etc.)

  if (!this->script_options_->saw_sections_clause())
    return ret;
  else
    {
      const Script_sections* ss = this->script_options_->script_sections();
      return ret + ss->expected_segment_count(this);
    }
}

// Handle the .note.GNU-stack section at layout time.  SEEN_GNU_STACK
// is whether we saw a .note.GNU-stack section in the object file.
// GNU_STACK_FLAGS is the section flags.  The flags give the
// protection required for stack memory.  We record this in an
// executable as a PT_GNU_STACK segment.  If an object file does not
// have a .note.GNU-stack segment, we must assume that it is an old
// object.  On some targets that will force an executable stack.

void
Layout::layout_gnu_stack(bool seen_gnu_stack, uint64_t gnu_stack_flags,
			 const Object* obj)
{
  if (!seen_gnu_stack)
    {
      this->input_without_gnu_stack_note_ = true;
      if (parameters->options().warn_execstack()
	  && parameters->target().is_default_stack_executable())
	gold_warning(_("%s: missing .note.GNU-stack section"
		       " implies executable stack"),
		     obj->name().c_str());
    }
  else
    {
      this->input_with_gnu_stack_note_ = true;
      if ((gnu_stack_flags & elfcpp::SHF_EXECINSTR) != 0)
	{
	  this->input_requires_executable_stack_ = true;
	  if (parameters->options().warn_execstack()
	      || parameters->options().is_stack_executable())
	    gold_warning(_("%s: requires executable stack"),
			 obj->name().c_str());
	}
    }
}

// Create automatic note sections.

void
Layout::create_notes()
{
  this->create_gold_note();
  this->create_executable_stack_info();
  this->create_build_id();
}

// Create the dynamic sections which are needed before we read the
// relocs.

void
Layout::create_initial_dynamic_sections(Symbol_table* symtab)
{
  if (parameters->doing_static_link())
    return;

  this->dynamic_section_ = this->choose_output_section(NULL, ".dynamic",
						       elfcpp::SHT_DYNAMIC,
						       (elfcpp::SHF_ALLOC
							| elfcpp::SHF_WRITE),
						       false, ORDER_RELRO,
						       true);

  // A linker script may discard .dynamic, so check for NULL.
  if (this->dynamic_section_ != NULL)
    {
      this->dynamic_symbol_ =
	symtab->define_in_output_data("_DYNAMIC", NULL,
				      Symbol_table::PREDEFINED,
				      this->dynamic_section_, 0, 0,
				      elfcpp::STT_OBJECT, elfcpp::STB_LOCAL,
				      elfcpp::STV_HIDDEN, 0, false, false);

      this->dynamic_data_ =  new Output_data_dynamic(&this->dynpool_);

      this->dynamic_section_->add_output_section_data(this->dynamic_data_);
    }
}

// For each output section whose name can be represented as C symbol,
// define __start and __stop symbols for the section.  This is a GNU
// extension.

void
Layout::define_section_symbols(Symbol_table* symtab)
{
  for (Section_list::const_iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    {
      const char* const name = (*p)->name();
      if (is_cident(name))
	{
	  const std::string name_string(name);
	  const std::string start_name(cident_section_start_prefix
				       + name_string);
	  const std::string stop_name(cident_section_stop_prefix
				      + name_string);

	  symtab->define_in_output_data(start_name.c_str(),
					NULL, // version
					Symbol_table::PREDEFINED,
					*p,
					0, // value
					0, // symsize
					elfcpp::STT_NOTYPE,
					elfcpp::STB_GLOBAL,
					elfcpp::STV_DEFAULT,
					0, // nonvis
					false, // offset_is_from_end
					true); // only_if_ref

	  symtab->define_in_output_data(stop_name.c_str(),
					NULL, // version
					Symbol_table::PREDEFINED,
					*p,
					0, // value
					0, // symsize
					elfcpp::STT_NOTYPE,
					elfcpp::STB_GLOBAL,
					elfcpp::STV_DEFAULT,
					0, // nonvis
					true, // offset_is_from_end
					true); // only_if_ref
	}
    }
}

// Define symbols for group signatures.

void
Layout::define_group_signatures(Symbol_table* symtab)
{
  for (Group_signatures::iterator p = this->group_signatures_.begin();
       p != this->group_signatures_.end();
       ++p)
    {
      Symbol* sym = symtab->lookup(p->signature, NULL);
      if (sym != NULL)
	p->section->set_info_symndx(sym);
      else
	{
	  // Force the name of the group section to the group
	  // signature, and use the group's section symbol as the
	  // signature symbol.
	  if (strcmp(p->section->name(), p->signature) != 0)
	    {
	      const char* name = this->namepool_.add(p->signature,
						     true, NULL);
	      p->section->set_name(name);
	    }
	  p->section->set_needs_symtab_index();
	  p->section->set_info_section_symndx(p->section);
	}
    }

  this->group_signatures_.clear();
}

// Find the first read-only PT_LOAD segment, creating one if
// necessary.

Output_segment*
Layout::find_first_load_seg(const Target* target)
{
  Output_segment* best = NULL;
  for (Segment_list::const_iterator p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
    {
      if ((*p)->type() == elfcpp::PT_LOAD
	  && ((*p)->flags() & elfcpp::PF_R) != 0
	  && (parameters->options().omagic()
	      || ((*p)->flags() & elfcpp::PF_W) == 0)
	  && (!target->isolate_execinstr()
	      || ((*p)->flags() & elfcpp::PF_X) == 0))
	{
	  if (best == NULL || this->segment_precedes(*p, best))
	    best = *p;
	}
    }
  if (best != NULL)
    return best;

  gold_assert(!this->script_options_->saw_phdrs_clause());

  Output_segment* load_seg = this->make_output_segment(elfcpp::PT_LOAD,
						       elfcpp::PF_R);
  return load_seg;
}

// Save states of all current output segments.  Store saved states
// in SEGMENT_STATES.

void
Layout::save_segments(Segment_states* segment_states)
{
  for (Segment_list::const_iterator p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
    {
      Output_segment* segment = *p;
      // Shallow copy.
      Output_segment* copy = new Output_segment(*segment);
      (*segment_states)[segment] = copy;
    }
}

// Restore states of output segments and delete any segment not found in
// SEGMENT_STATES.

void
Layout::restore_segments(const Segment_states* segment_states)
{
  // Go through the segment list and remove any segment added in the
  // relaxation loop.
  this->tls_segment_ = NULL;
  this->relro_segment_ = NULL;
  Segment_list::iterator list_iter = this->segment_list_.begin();
  while (list_iter != this->segment_list_.end())
    {
      Output_segment* segment = *list_iter;
      Segment_states::const_iterator states_iter =
	  segment_states->find(segment);
      if (states_iter != segment_states->end())
	{
	  const Output_segment* copy = states_iter->second;
	  // Shallow copy to restore states.
	  *segment = *copy;

	  // Also fix up TLS and RELRO segment pointers as appropriate.
	  if (segment->type() == elfcpp::PT_TLS)
	    this->tls_segment_ = segment;
	  else if (segment->type() == elfcpp::PT_GNU_RELRO)
	    this->relro_segment_ = segment;

	  ++list_iter;
	}
      else
	{
	  list_iter = this->segment_list_.erase(list_iter);
	  // This is a segment created during section layout.  It should be
	  // safe to remove it since we should have removed all pointers to it.
	  delete segment;
	}
    }
}

// Clean up after relaxation so that sections can be laid out again.

void
Layout::clean_up_after_relaxation()
{
  // Restore the segments to point state just prior to the relaxation loop.
  Script_sections* script_section = this->script_options_->script_sections();
  script_section->release_segments();
  this->restore_segments(this->segment_states_);

  // Reset section addresses and file offsets
  for (Section_list::iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    {
      (*p)->restore_states();

      // If an input section changes size because of relaxation,
      // we need to adjust the section offsets of all input sections.
      // after such a section.
      if ((*p)->section_offsets_need_adjustment())
	(*p)->adjust_section_offsets();

      (*p)->reset_address_and_file_offset();
    }

  // Reset special output object address and file offsets.
  for (Data_list::iterator p = this->special_output_list_.begin();
       p != this->special_output_list_.end();
       ++p)
    (*p)->reset_address_and_file_offset();

  // A linker script may have created some output section data objects.
  // They are useless now.
  for (Output_section_data_list::const_iterator p =
	 this->script_output_section_data_list_.begin();
       p != this->script_output_section_data_list_.end();
       ++p)
    delete *p;
  this->script_output_section_data_list_.clear();

  // Special-case fill output objects are recreated each time through
  // the relaxation loop.
  this->reset_relax_output();
}

void
Layout::reset_relax_output()
{
  for (Data_list::const_iterator p = this->relax_output_list_.begin();
       p != this->relax_output_list_.end();
       ++p)
    delete *p;
  this->relax_output_list_.clear();
}

// Prepare for relaxation.

void
Layout::prepare_for_relaxation()
{
  // Create an relaxation debug check if in debugging mode.
  if (is_debugging_enabled(DEBUG_RELAXATION))
    this->relaxation_debug_check_ = new Relaxation_debug_check();

  // Save segment states.
  this->segment_states_ = new Segment_states();
  this->save_segments(this->segment_states_);

  for(Section_list::const_iterator p = this->section_list_.begin();
      p != this->section_list_.end();
      ++p)
    (*p)->save_states();

  if (is_debugging_enabled(DEBUG_RELAXATION))
    this->relaxation_debug_check_->check_output_data_for_reset_values(
	this->section_list_, this->special_output_list_,
	this->relax_output_list_);

  // Also enable recording of output section data from scripts.
  this->record_output_section_data_from_script_ = true;
}

// If the user set the address of the text segment, that may not be
// compatible with putting the segment headers and file headers into
// that segment.  For isolate_execinstr() targets, it's the rodata
// segment rather than text where we might put the headers.
static inline bool
load_seg_unusable_for_headers(const Target* target)
{
  const General_options& options = parameters->options();
  if (target->isolate_execinstr())
    return (options.user_set_Trodata_segment()
	    && options.Trodata_segment() % target->abi_pagesize() != 0);
  else
    return (options.user_set_Ttext()
	    && options.Ttext() % target->abi_pagesize() != 0);
}

// Relaxation loop body:  If target has no relaxation, this runs only once
// Otherwise, the target relaxation hook is called at the end of
// each iteration.  If the hook returns true, it means re-layout of
// section is required.
//
// The number of segments created by a linking script without a PHDRS
// clause may be affected by section sizes and alignments.  There is
// a remote chance that relaxation causes different number of PT_LOAD
// segments are created and sections are attached to different segments.
// Therefore, we always throw away all segments created during section
// layout.  In order to be able to restart the section layout, we keep
// a copy of the segment list right before the relaxation loop and use
// that to restore the segments.
//
// PASS is the current relaxation pass number.
// SYMTAB is a symbol table.
// PLOAD_SEG is the address of a pointer for the load segment.
// PHDR_SEG is a pointer to the PHDR segment.
// SEGMENT_HEADERS points to the output segment header.
// FILE_HEADER points to the output file header.
// PSHNDX is the address to store the output section index.

off_t inline
Layout::relaxation_loop_body(
    int pass,
    Target* target,
    Symbol_table* symtab,
    Output_segment** pload_seg,
    Output_segment* phdr_seg,
    Output_segment_headers* segment_headers,
    Output_file_header* file_header,
    unsigned int* pshndx)
{
  // If this is not the first iteration, we need to clean up after
  // relaxation so that we can lay out the sections again.
  if (pass != 0)
    this->clean_up_after_relaxation();

  // If there is a SECTIONS clause, put all the input sections into
  // the required order.
  Output_segment* load_seg;
  if (this->script_options_->saw_sections_clause())
    load_seg = this->set_section_addresses_from_script(symtab);
  else if (parameters->options().relocatable())
    load_seg = NULL;
  else
    load_seg = this->find_first_load_seg(target);

  if (parameters->options().oformat_enum()
      != General_options::OBJECT_FORMAT_ELF)
    load_seg = NULL;

  if (load_seg_unusable_for_headers(target))
    {
      load_seg = NULL;
      phdr_seg = NULL;
    }

  gold_assert(phdr_seg == NULL
	      || load_seg != NULL
	      || this->script_options_->saw_sections_clause());

  // If the address of the load segment we found has been set by
  // --section-start rather than by a script, then adjust the VMA and
  // LMA downward if possible to include the file and section headers.
  uint64_t header_gap = 0;
  if (load_seg != NULL
      && load_seg->are_addresses_set()
      && !this->script_options_->saw_sections_clause()
      && !parameters->options().relocatable())
    {
      file_header->finalize_data_size();
      segment_headers->finalize_data_size();
      size_t sizeof_headers = (file_header->data_size()
			       + segment_headers->data_size());
      const uint64_t abi_pagesize = target->abi_pagesize();
      uint64_t hdr_paddr = load_seg->paddr() - sizeof_headers;
      hdr_paddr &= ~(abi_pagesize - 1);
      uint64_t subtract = load_seg->paddr() - hdr_paddr;
      if (load_seg->paddr() < subtract || load_seg->vaddr() < subtract)
	load_seg = NULL;
      else
	{
	  load_seg->set_addresses(load_seg->vaddr() - subtract,
				  load_seg->paddr() - subtract);
	  header_gap = subtract - sizeof_headers;
	}
    }

  // Lay out the segment headers.
  if (!parameters->options().relocatable())
    {
      gold_assert(segment_headers != NULL);
      if (header_gap != 0 && load_seg != NULL)
	{
	  Output_data_zero_fill* z = new Output_data_zero_fill(header_gap, 1);
	  load_seg->add_initial_output_data(z);
	}
      if (load_seg != NULL)
	load_seg->add_initial_output_data(segment_headers);
      if (phdr_seg != NULL)
	phdr_seg->add_initial_output_data(segment_headers);
    }

  // Lay out the file header.
  if (load_seg != NULL)
    load_seg->add_initial_output_data(file_header);

  if (this->script_options_->saw_phdrs_clause()
      && !parameters->options().relocatable())
    {
      // Support use of FILEHDRS and PHDRS attachments in a PHDRS
      // clause in a linker script.
      Script_sections* ss = this->script_options_->script_sections();
      ss->put_headers_in_phdrs(file_header, segment_headers);
    }

  // We set the output section indexes in set_segment_offsets and
  // set_section_indexes.
  *pshndx = 1;

  // Set the file offsets of all the segments, and all the sections
  // they contain.
  off_t off;
  if (!parameters->options().relocatable())
    off = this->set_segment_offsets(target, load_seg, pshndx);
  else
    off = this->set_relocatable_section_offsets(file_header, pshndx);

   // Verify that the dummy relaxation does not change anything.
  if (is_debugging_enabled(DEBUG_RELAXATION))
    {
      if (pass == 0)
	this->relaxation_debug_check_->read_sections(this->section_list_);
      else
	this->relaxation_debug_check_->verify_sections(this->section_list_);
    }

  *pload_seg = load_seg;
  return off;
}

// Search the list of patterns and find the postion of the given section
// name in the output section.  If the section name matches a glob
// pattern and a non-glob name, then the non-glob position takes
// precedence.  Return 0 if no match is found.

unsigned int
Layout::find_section_order_index(const std::string& section_name)
{
  Unordered_map<std::string, unsigned int>::iterator map_it;
  map_it = this->input_section_position_.find(section_name);
  if (map_it != this->input_section_position_.end())
    return map_it->second;

  // Absolute match failed.  Linear search the glob patterns.
  std::vector<std::string>::iterator it;
  for (it = this->input_section_glob_.begin();
       it != this->input_section_glob_.end();
       ++it)
    {
       if (fnmatch((*it).c_str(), section_name.c_str(), FNM_NOESCAPE) == 0)
	 {
	   map_it = this->input_section_position_.find(*it);
	   gold_assert(map_it != this->input_section_position_.end());
	   return map_it->second;
	 }
    }
  return 0;
}

// Read the sequence of input sections from the file specified with
// option --section-ordering-file.

void
Layout::read_layout_from_file()
{
  const char* filename = parameters->options().section_ordering_file();
  std::ifstream in;
  std::string line;

  in.open(filename);
  if (!in)
    gold_fatal(_("unable to open --section-ordering-file file %s: %s"),
	       filename, strerror(errno));

  std::getline(in, line);   // this chops off the trailing \n, if any
  unsigned int position = 1;
  this->set_section_ordering_specified();

  while (in)
    {
      if (!line.empty() && line[line.length() - 1] == '\r')   // Windows
	line.resize(line.length() - 1);
      // Ignore comments, beginning with '#'
      if (line[0] == '#')
	{
	  std::getline(in, line);
	  continue;
	}
      this->input_section_position_[line] = position;
      // Store all glob patterns in a vector.
      if (is_wildcard_string(line.c_str()))
	this->input_section_glob_.push_back(line);
      position++;
      std::getline(in, line);
    }
}

// Finalize the layout.  When this is called, we have created all the
// output sections and all the output segments which are based on
// input sections.  We have several things to do, and we have to do
// them in the right order, so that we get the right results correctly
// and efficiently.

// 1) Finalize the list of output segments and create the segment
// table header.

// 2) Finalize the dynamic symbol table and associated sections.

// 3) Determine the final file offset of all the output segments.

// 4) Determine the final file offset of all the SHF_ALLOC output
// sections.

// 5) Create the symbol table sections and the section name table
// section.

// 6) Finalize the symbol table: set symbol values to their final
// value and make a final determination of which symbols are going
// into the output symbol table.

// 7) Create the section table header.

// 8) Determine the final file offset of all the output sections which
// are not SHF_ALLOC, including the section table header.

// 9) Finalize the ELF file header.

// This function returns the size of the output file.

off_t
Layout::finalize(const Input_objects* input_objects, Symbol_table* symtab,
		 Target* target, const Task* task)
{
  target->finalize_sections(this, input_objects, symtab);

  this->count_local_symbols(task, input_objects);

  this->link_stabs_sections();

  Output_segment* phdr_seg = NULL;
  if (!parameters->options().relocatable() && !parameters->doing_static_link())
    {
      // There was a dynamic object in the link.  We need to create
      // some information for the dynamic linker.

      // Create the PT_PHDR segment which will hold the program
      // headers.
      if (!this->script_options_->saw_phdrs_clause())
	phdr_seg = this->make_output_segment(elfcpp::PT_PHDR, elfcpp::PF_R);

      // Create the dynamic symbol table, including the hash table.
      Output_section* dynstr;
      std::vector<Symbol*> dynamic_symbols;
      unsigned int local_dynamic_count;
      Versions versions(*this->script_options()->version_script_info(),
			&this->dynpool_);
      this->create_dynamic_symtab(input_objects, symtab, &dynstr,
				  &local_dynamic_count, &dynamic_symbols,
				  &versions);

      // Create the .interp section to hold the name of the
      // interpreter, and put it in a PT_INTERP segment.  Don't do it
      // if we saw a .interp section in an input file.
      if ((!parameters->options().shared()
	   || parameters->options().dynamic_linker() != NULL)
	  && this->interp_segment_ == NULL)
	this->create_interp(target);

      // Finish the .dynamic section to hold the dynamic data, and put
      // it in a PT_DYNAMIC segment.
      this->finish_dynamic_section(input_objects, symtab);

      // We should have added everything we need to the dynamic string
      // table.
      this->dynpool_.set_string_offsets();

      // Create the version sections.  We can't do this until the
      // dynamic string table is complete.
      this->create_version_sections(&versions, symtab, local_dynamic_count,
				    dynamic_symbols, dynstr);

      // Set the size of the _DYNAMIC symbol.  We can't do this until
      // after we call create_version_sections.
      this->set_dynamic_symbol_size(symtab);
    }

  // Create segment headers.
  Output_segment_headers* segment_headers =
    (parameters->options().relocatable()
     ? NULL
     : new Output_segment_headers(this->segment_list_));

  // Lay out the file header.
  Output_file_header* file_header = new Output_file_header(target, symtab,
							   segment_headers);

  this->special_output_list_.push_back(file_header);
  if (segment_headers != NULL)
    this->special_output_list_.push_back(segment_headers);

  // Find approriate places for orphan output sections if we are using
  // a linker script.
  if (this->script_options_->saw_sections_clause())
    this->place_orphan_sections_in_script();

  Output_segment* load_seg;
  off_t off;
  unsigned int shndx;
  int pass = 0;

  // Take a snapshot of the section layout as needed.
  if (target->may_relax())
    this->prepare_for_relaxation();

  // Run the relaxation loop to lay out sections.
  do
    {
      off = this->relaxation_loop_body(pass, target, symtab, &load_seg,
				       phdr_seg, segment_headers, file_header,
				       &shndx);
      pass++;
    }
  while (target->may_relax()
	 && target->relax(pass, input_objects, symtab, this, task));

  // If there is a load segment that contains the file and program headers,
  // provide a symbol __ehdr_start pointing there.
  // A program can use this to examine itself robustly.
  if (load_seg != NULL)
    symtab->define_in_output_segment("__ehdr_start", NULL,
				     Symbol_table::PREDEFINED, load_seg, 0, 0,
				     elfcpp::STT_NOTYPE, elfcpp::STB_GLOBAL,
				     elfcpp::STV_HIDDEN, 0,
				     Symbol::SEGMENT_START, true);

  // Set the file offsets of all the non-data sections we've seen so
  // far which don't have to wait for the input sections.  We need
  // this in order to finalize local symbols in non-allocated
  // sections.
  off = this->set_section_offsets(off, BEFORE_INPUT_SECTIONS_PASS);

  // Set the section indexes of all unallocated sections seen so far,
  // in case any of them are somehow referenced by a symbol.
  shndx = this->set_section_indexes(shndx);

  // Create the symbol table sections.
  this->create_symtab_sections(input_objects, symtab, shndx, &off);
  if (!parameters->doing_static_link())
    this->assign_local_dynsym_offsets(input_objects);

  // Process any symbol assignments from a linker script.  This must
  // be called after the symbol table has been finalized.
  this->script_options_->finalize_symbols(symtab, this);

  // Create the incremental inputs sections.
  if (this->incremental_inputs_)
    {
      this->incremental_inputs_->finalize();
      this->create_incremental_info_sections(symtab);
    }

  // Create the .shstrtab section.
  Output_section* shstrtab_section = this->create_shstrtab();

  // Set the file offsets of the rest of the non-data sections which
  // don't have to wait for the input sections.
  off = this->set_section_offsets(off, BEFORE_INPUT_SECTIONS_PASS);

  // Now that all sections have been created, set the section indexes
  // for any sections which haven't been done yet.
  shndx = this->set_section_indexes(shndx);

  // Create the section table header.
  this->create_shdrs(shstrtab_section, &off);

  // If there are no sections which require postprocessing, we can
  // handle the section names now, and avoid a resize later.
  if (!this->any_postprocessing_sections_)
    {
      off = this->set_section_offsets(off,
				      POSTPROCESSING_SECTIONS_PASS);
      off =
	  this->set_section_offsets(off,
				    STRTAB_AFTER_POSTPROCESSING_SECTIONS_PASS);
    }

  file_header->set_section_info(this->section_headers_, shstrtab_section);

  // Now we know exactly where everything goes in the output file
  // (except for non-allocated sections which require postprocessing).
  Output_data::layout_complete();

  this->output_file_size_ = off;

  return off;
}

// Create a note header following the format defined in the ELF ABI.
// NAME is the name, NOTE_TYPE is the type, SECTION_NAME is the name
// of the section to create, DESCSZ is the size of the descriptor.
// ALLOCATE is true if the section should be allocated in memory.
// This returns the new note section.  It sets *TRAILING_PADDING to
// the number of trailing zero bytes required.

Output_section*
Layout::create_note(const char* name, int note_type,
		    const char* section_name, size_t descsz,
		    bool allocate, size_t* trailing_padding)
{
  // Authorities all agree that the values in a .note field should
  // be aligned on 4-byte boundaries for 32-bit binaries.  However,
  // they differ on what the alignment is for 64-bit binaries.
  // The GABI says unambiguously they take 8-byte alignment:
  //    http://sco.com/developers/gabi/latest/ch5.pheader.html#note_section
  // Other documentation says alignment should always be 4 bytes:
  //    http://www.netbsd.org/docs/kernel/elf-notes.html#note-format
  // GNU ld and GNU readelf both support the latter (at least as of
  // version 2.16.91), and glibc always generates the latter for
  // .note.ABI-tag (as of version 1.6), so that's the one we go with
  // here.
#ifdef GABI_FORMAT_FOR_DOTNOTE_SECTION   // This is not defined by default.
  const int size = parameters->target().get_size();
#else
  const int size = 32;
#endif

  // The contents of the .note section.
  size_t namesz = strlen(name) + 1;
  size_t aligned_namesz = align_address(namesz, size / 8);
  size_t aligned_descsz = align_address(descsz, size / 8);

  size_t notehdrsz = 3 * (size / 8) + aligned_namesz;

  unsigned char* buffer = new unsigned char[notehdrsz];
  memset(buffer, 0, notehdrsz);

  bool is_big_endian = parameters->target().is_big_endian();

  if (size == 32)
    {
      if (!is_big_endian)
	{
	  elfcpp::Swap<32, false>::writeval(buffer, namesz);
	  elfcpp::Swap<32, false>::writeval(buffer + 4, descsz);
	  elfcpp::Swap<32, false>::writeval(buffer + 8, note_type);
	}
      else
	{
	  elfcpp::Swap<32, true>::writeval(buffer, namesz);
	  elfcpp::Swap<32, true>::writeval(buffer + 4, descsz);
	  elfcpp::Swap<32, true>::writeval(buffer + 8, note_type);
	}
    }
  else if (size == 64)
    {
      if (!is_big_endian)
	{
	  elfcpp::Swap<64, false>::writeval(buffer, namesz);
	  elfcpp::Swap<64, false>::writeval(buffer + 8, descsz);
	  elfcpp::Swap<64, false>::writeval(buffer + 16, note_type);
	}
      else
	{
	  elfcpp::Swap<64, true>::writeval(buffer, namesz);
	  elfcpp::Swap<64, true>::writeval(buffer + 8, descsz);
	  elfcpp::Swap<64, true>::writeval(buffer + 16, note_type);
	}
    }
  else
    gold_unreachable();

  memcpy(buffer + 3 * (size / 8), name, namesz);

  elfcpp::Elf_Xword flags = 0;
  Output_section_order order = ORDER_INVALID;
  if (allocate)
    {
      flags = elfcpp::SHF_ALLOC;
      order = ORDER_RO_NOTE;
    }
  Output_section* os = this->choose_output_section(NULL, section_name,
						   elfcpp::SHT_NOTE,
						   flags, false, order, false);
  if (os == NULL)
    return NULL;

  Output_section_data* posd = new Output_data_const_buffer(buffer, notehdrsz,
							   size / 8,
							   "** note header");
  os->add_output_section_data(posd);

  *trailing_padding = aligned_descsz - descsz;

  return os;
}

// For an executable or shared library, create a note to record the
// version of gold used to create the binary.

void
Layout::create_gold_note()
{
  if (parameters->options().relocatable()
      || parameters->incremental_update())
    return;

  std::string desc = std::string("gold ") + gold::get_version_string();

  size_t trailing_padding;
  Output_section* os = this->create_note("GNU", elfcpp::NT_GNU_GOLD_VERSION,
					 ".note.gnu.gold-version", desc.size(),
					 false, &trailing_padding);
  if (os == NULL)
    return;

  Output_section_data* posd = new Output_data_const(desc, 4);
  os->add_output_section_data(posd);

  if (trailing_padding > 0)
    {
      posd = new Output_data_zero_fill(trailing_padding, 0);
      os->add_output_section_data(posd);
    }
}

// Record whether the stack should be executable.  This can be set
// from the command line using the -z execstack or -z noexecstack
// options.  Otherwise, if any input file has a .note.GNU-stack
// section with the SHF_EXECINSTR flag set, the stack should be
// executable.  Otherwise, if at least one input file a
// .note.GNU-stack section, and some input file has no .note.GNU-stack
// section, we use the target default for whether the stack should be
// executable.  Otherwise, we don't generate a stack note.  When
// generating a object file, we create a .note.GNU-stack section with
// the appropriate marking.  When generating an executable or shared
// library, we create a PT_GNU_STACK segment.

void
Layout::create_executable_stack_info()
{
  bool is_stack_executable;
  if (parameters->options().is_execstack_set())
    is_stack_executable = parameters->options().is_stack_executable();
  else if (!this->input_with_gnu_stack_note_)
    return;
  else
    {
      if (this->input_requires_executable_stack_)
	is_stack_executable = true;
      else if (this->input_without_gnu_stack_note_)
	is_stack_executable =
	  parameters->target().is_default_stack_executable();
      else
	is_stack_executable = false;
    }

  if (parameters->options().relocatable())
    {
      const char* name = this->namepool_.add(".note.GNU-stack", false, NULL);
      elfcpp::Elf_Xword flags = 0;
      if (is_stack_executable)
	flags |= elfcpp::SHF_EXECINSTR;
      this->make_output_section(name, elfcpp::SHT_PROGBITS, flags,
				ORDER_INVALID, false);
    }
  else
    {
      if (this->script_options_->saw_phdrs_clause())
	return;
      int flags = elfcpp::PF_R | elfcpp::PF_W;
      if (is_stack_executable)
	flags |= elfcpp::PF_X;
      this->make_output_segment(elfcpp::PT_GNU_STACK, flags);
    }
}

// If --build-id was used, set up the build ID note.

void
Layout::create_build_id()
{
  if (!parameters->options().user_set_build_id())
    return;

  const char* style = parameters->options().build_id();
  if (strcmp(style, "none") == 0)
    return;

  // Set DESCSZ to the size of the note descriptor.  When possible,
  // set DESC to the note descriptor contents.
  size_t descsz;
  std::string desc;
  if (strcmp(style, "md5") == 0)
    descsz = 128 / 8;
  else if ((strcmp(style, "sha1") == 0) || (strcmp(style, "tree") == 0))
    descsz = 160 / 8;
  else if (strcmp(style, "uuid") == 0)
    {
      const size_t uuidsz = 128 / 8;

      char buffer[uuidsz];
      memset(buffer, 0, uuidsz);

      int descriptor = open_descriptor(-1, "/dev/urandom", O_RDONLY);
      if (descriptor < 0)
	gold_error(_("--build-id=uuid failed: could not open /dev/urandom: %s"),
		   strerror(errno));
      else
	{
	  ssize_t got = ::read(descriptor, buffer, uuidsz);
	  release_descriptor(descriptor, true);
	  if (got < 0)
	    gold_error(_("/dev/urandom: read failed: %s"), strerror(errno));
	  else if (static_cast<size_t>(got) != uuidsz)
	    gold_error(_("/dev/urandom: expected %zu bytes, got %zd bytes"),
		       uuidsz, got);
	}

      desc.assign(buffer, uuidsz);
      descsz = uuidsz;
    }
  else if (strncmp(style, "0x", 2) == 0)
    {
      hex_init();
      const char* p = style + 2;
      while (*p != '\0')
	{
	  if (hex_p(p[0]) && hex_p(p[1]))
	    {
	      char c = (hex_value(p[0]) << 4) | hex_value(p[1]);
	      desc += c;
	      p += 2;
	    }
	  else if (*p == '-' || *p == ':')
	    ++p;
	  else
	    gold_fatal(_("--build-id argument '%s' not a valid hex number"),
		       style);
	}
      descsz = desc.size();
    }
  else
    gold_fatal(_("unrecognized --build-id argument '%s'"), style);

  // Create the note.
  size_t trailing_padding;
  Output_section* os = this->create_note("GNU", elfcpp::NT_GNU_BUILD_ID,
					 ".note.gnu.build-id", descsz, true,
					 &trailing_padding);
  if (os == NULL)
    return;

  if (!desc.empty())
    {
      // We know the value already, so we fill it in now.
      gold_assert(desc.size() == descsz);

      Output_section_data* posd = new Output_data_const(desc, 4);
      os->add_output_section_data(posd);

      if (trailing_padding != 0)
	{
	  posd = new Output_data_zero_fill(trailing_padding, 0);
	  os->add_output_section_data(posd);
	}
    }
  else
    {
      // We need to compute a checksum after we have completed the
      // link.
      gold_assert(trailing_padding == 0);
      this->build_id_note_ = new Output_data_zero_fill(descsz, 4);
      os->add_output_section_data(this->build_id_note_);
    }
}

// If we have both .stabXX and .stabXXstr sections, then the sh_link
// field of the former should point to the latter.  I'm not sure who
// started this, but the GNU linker does it, and some tools depend
// upon it.

void
Layout::link_stabs_sections()
{
  if (!this->have_stabstr_section_)
    return;

  for (Section_list::iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    {
      if ((*p)->type() != elfcpp::SHT_STRTAB)
	continue;

      const char* name = (*p)->name();
      if (strncmp(name, ".stab", 5) != 0)
	continue;

      size_t len = strlen(name);
      if (strcmp(name + len - 3, "str") != 0)
	continue;

      std::string stab_name(name, len - 3);
      Output_section* stab_sec;
      stab_sec = this->find_output_section(stab_name.c_str());
      if (stab_sec != NULL)
	stab_sec->set_link_section(*p);
    }
}

// Create .gnu_incremental_inputs and related sections needed
// for the next run of incremental linking to check what has changed.

void
Layout::create_incremental_info_sections(Symbol_table* symtab)
{
  Incremental_inputs* incr = this->incremental_inputs_;

  gold_assert(incr != NULL);

  // Create the .gnu_incremental_inputs, _symtab, and _relocs input sections.
  incr->create_data_sections(symtab);

  // Add the .gnu_incremental_inputs section.
  const char* incremental_inputs_name =
    this->namepool_.add(".gnu_incremental_inputs", false, NULL);
  Output_section* incremental_inputs_os =
    this->make_output_section(incremental_inputs_name,
			      elfcpp::SHT_GNU_INCREMENTAL_INPUTS, 0,
			      ORDER_INVALID, false);
  incremental_inputs_os->add_output_section_data(incr->inputs_section());

  // Add the .gnu_incremental_symtab section.
  const char* incremental_symtab_name =
    this->namepool_.add(".gnu_incremental_symtab", false, NULL);
  Output_section* incremental_symtab_os =
    this->make_output_section(incremental_symtab_name,
			      elfcpp::SHT_GNU_INCREMENTAL_SYMTAB, 0,
			      ORDER_INVALID, false);
  incremental_symtab_os->add_output_section_data(incr->symtab_section());
  incremental_symtab_os->set_entsize(4);

  // Add the .gnu_incremental_relocs section.
  const char* incremental_relocs_name =
    this->namepool_.add(".gnu_incremental_relocs", false, NULL);
  Output_section* incremental_relocs_os =
    this->make_output_section(incremental_relocs_name,
			      elfcpp::SHT_GNU_INCREMENTAL_RELOCS, 0,
			      ORDER_INVALID, false);
  incremental_relocs_os->add_output_section_data(incr->relocs_section());
  incremental_relocs_os->set_entsize(incr->relocs_entsize());

  // Add the .gnu_incremental_got_plt section.
  const char* incremental_got_plt_name =
    this->namepool_.add(".gnu_incremental_got_plt", false, NULL);
  Output_section* incremental_got_plt_os =
    this->make_output_section(incremental_got_plt_name,
			      elfcpp::SHT_GNU_INCREMENTAL_GOT_PLT, 0,
			      ORDER_INVALID, false);
  incremental_got_plt_os->add_output_section_data(incr->got_plt_section());

  // Add the .gnu_incremental_strtab section.
  const char* incremental_strtab_name =
    this->namepool_.add(".gnu_incremental_strtab", false, NULL);
  Output_section* incremental_strtab_os = this->make_output_section(incremental_strtab_name,
							elfcpp::SHT_STRTAB, 0,
							ORDER_INVALID, false);
  Output_data_strtab* strtab_data =
      new Output_data_strtab(incr->get_stringpool());
  incremental_strtab_os->add_output_section_data(strtab_data);

  incremental_inputs_os->set_after_input_sections();
  incremental_symtab_os->set_after_input_sections();
  incremental_relocs_os->set_after_input_sections();
  incremental_got_plt_os->set_after_input_sections();

  incremental_inputs_os->set_link_section(incremental_strtab_os);
  incremental_symtab_os->set_link_section(incremental_inputs_os);
  incremental_relocs_os->set_link_section(incremental_inputs_os);
  incremental_got_plt_os->set_link_section(incremental_inputs_os);
}

// Return whether SEG1 should be before SEG2 in the output file.  This
// is based entirely on the segment type and flags.  When this is
// called the segment addresses have normally not yet been set.

bool
Layout::segment_precedes(const Output_segment* seg1,
			 const Output_segment* seg2)
{
  elfcpp::Elf_Word type1 = seg1->type();
  elfcpp::Elf_Word type2 = seg2->type();

  // The single PT_PHDR segment is required to precede any loadable
  // segment.  We simply make it always first.
  if (type1 == elfcpp::PT_PHDR)
    {
      gold_assert(type2 != elfcpp::PT_PHDR);
      return true;
    }
  if (type2 == elfcpp::PT_PHDR)
    return false;

  // The single PT_INTERP segment is required to precede any loadable
  // segment.  We simply make it always second.
  if (type1 == elfcpp::PT_INTERP)
    {
      gold_assert(type2 != elfcpp::PT_INTERP);
      return true;
    }
  if (type2 == elfcpp::PT_INTERP)
    return false;

  // We then put PT_LOAD segments before any other segments.
  if (type1 == elfcpp::PT_LOAD && type2 != elfcpp::PT_LOAD)
    return true;
  if (type2 == elfcpp::PT_LOAD && type1 != elfcpp::PT_LOAD)
    return false;

  // We put the PT_TLS segment last except for the PT_GNU_RELRO
  // segment, because that is where the dynamic linker expects to find
  // it (this is just for efficiency; other positions would also work
  // correctly).
  if (type1 == elfcpp::PT_TLS
      && type2 != elfcpp::PT_TLS
      && type2 != elfcpp::PT_GNU_RELRO)
    return false;
  if (type2 == elfcpp::PT_TLS
      && type1 != elfcpp::PT_TLS
      && type1 != elfcpp::PT_GNU_RELRO)
    return true;

  // We put the PT_GNU_RELRO segment last, because that is where the
  // dynamic linker expects to find it (as with PT_TLS, this is just
  // for efficiency).
  if (type1 == elfcpp::PT_GNU_RELRO && type2 != elfcpp::PT_GNU_RELRO)
    return false;
  if (type2 == elfcpp::PT_GNU_RELRO && type1 != elfcpp::PT_GNU_RELRO)
    return true;

  const elfcpp::Elf_Word flags1 = seg1->flags();
  const elfcpp::Elf_Word flags2 = seg2->flags();

  // The order of non-PT_LOAD segments is unimportant.  We simply sort
  // by the numeric segment type and flags values.  There should not
  // be more than one segment with the same type and flags, except
  // when a linker script specifies such.
  if (type1 != elfcpp::PT_LOAD)
    {
      if (type1 != type2)
	return type1 < type2;
      gold_assert(flags1 != flags2
		  || this->script_options_->saw_phdrs_clause());
      return flags1 < flags2;
    }

  // If the addresses are set already, sort by load address.
  if (seg1->are_addresses_set())
    {
      if (!seg2->are_addresses_set())
	return true;

      unsigned int section_count1 = seg1->output_section_count();
      unsigned int section_count2 = seg2->output_section_count();
      if (section_count1 == 0 && section_count2 > 0)
	return true;
      if (section_count1 > 0 && section_count2 == 0)
	return false;

      uint64_t paddr1 =	(seg1->are_addresses_set()
			 ? seg1->paddr()
			 : seg1->first_section_load_address());
      uint64_t paddr2 =	(seg2->are_addresses_set()
			 ? seg2->paddr()
			 : seg2->first_section_load_address());

      if (paddr1 != paddr2)
	return paddr1 < paddr2;
    }
  else if (seg2->are_addresses_set())
    return false;

  // A segment which holds large data comes after a segment which does
  // not hold large data.
  if (seg1->is_large_data_segment())
    {
      if (!seg2->is_large_data_segment())
	return false;
    }
  else if (seg2->is_large_data_segment())
    return true;

  // Otherwise, we sort PT_LOAD segments based on the flags.  Readonly
  // segments come before writable segments.  Then writable segments
  // with data come before writable segments without data.  Then
  // executable segments come before non-executable segments.  Then
  // the unlikely case of a non-readable segment comes before the
  // normal case of a readable segment.  If there are multiple
  // segments with the same type and flags, we require that the
  // address be set, and we sort by virtual address and then physical
  // address.
  if ((flags1 & elfcpp::PF_W) != (flags2 & elfcpp::PF_W))
    return (flags1 & elfcpp::PF_W) == 0;
  if ((flags1 & elfcpp::PF_W) != 0
      && seg1->has_any_data_sections() != seg2->has_any_data_sections())
    return seg1->has_any_data_sections();
  if ((flags1 & elfcpp::PF_X) != (flags2 & elfcpp::PF_X))
    return (flags1 & elfcpp::PF_X) != 0;
  if ((flags1 & elfcpp::PF_R) != (flags2 & elfcpp::PF_R))
    return (flags1 & elfcpp::PF_R) == 0;

  // We shouldn't get here--we shouldn't create segments which we
  // can't distinguish.  Unless of course we are using a weird linker
  // script or overlapping --section-start options.  We could also get
  // here if plugins want unique segments for subsets of sections.
  gold_assert(this->script_options_->saw_phdrs_clause()
	      || parameters->options().any_section_start()
	      || this->is_unique_segment_for_sections_specified());
  return false;
}

// Increase OFF so that it is congruent to ADDR modulo ABI_PAGESIZE.

static off_t
align_file_offset(off_t off, uint64_t addr, uint64_t abi_pagesize)
{
  uint64_t unsigned_off = off;
  uint64_t aligned_off = ((unsigned_off & ~(abi_pagesize - 1))
			  | (addr & (abi_pagesize - 1)));
  if (aligned_off < unsigned_off)
    aligned_off += abi_pagesize;
  return aligned_off;
}

// On targets where the text segment contains only executable code,
// a non-executable segment is never the text segment.

static inline bool
is_text_segment(const Target* target, const Output_segment* seg)
{
  elfcpp::Elf_Xword flags = seg->flags();
  if ((flags & elfcpp::PF_W) != 0)
    return false;
  if ((flags & elfcpp::PF_X) == 0)
    return !target->isolate_execinstr();
  return true;
}

// Set the file offsets of all the segments, and all the sections they
// contain.  They have all been created.  LOAD_SEG must be be laid out
// first.  Return the offset of the data to follow.

off_t
Layout::set_segment_offsets(const Target* target, Output_segment* load_seg,
			    unsigned int* pshndx)
{
  // Sort them into the final order.  We use a stable sort so that we
  // don't randomize the order of indistinguishable segments created
  // by linker scripts.
  std::stable_sort(this->segment_list_.begin(), this->segment_list_.end(),
		   Layout::Compare_segments(this));

  // Find the PT_LOAD segments, and set their addresses and offsets
  // and their section's addresses and offsets.
  uint64_t start_addr;
  if (parameters->options().user_set_Ttext())
    start_addr = parameters->options().Ttext();
  else if (parameters->options().output_is_position_independent())
    start_addr = 0;
  else
    start_addr = target->default_text_segment_address();

  uint64_t addr = start_addr;
  off_t off = 0;

  // If LOAD_SEG is NULL, then the file header and segment headers
  // will not be loadable.  But they still need to be at offset 0 in
  // the file.  Set their offsets now.
  if (load_seg == NULL)
    {
      for (Data_list::iterator p = this->special_output_list_.begin();
	   p != this->special_output_list_.end();
	   ++p)
	{
	  off = align_address(off, (*p)->addralign());
	  (*p)->set_address_and_file_offset(0, off);
	  off += (*p)->data_size();
	}
    }

  unsigned int increase_relro = this->increase_relro_;
  if (this->script_options_->saw_sections_clause())
    increase_relro = 0;

  const bool check_sections = parameters->options().check_sections();
  Output_segment* last_load_segment = NULL;

  unsigned int shndx_begin = *pshndx;
  unsigned int shndx_load_seg = *pshndx;

  for (Segment_list::iterator p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
    {
      if ((*p)->type() == elfcpp::PT_LOAD)
	{
	  if (target->isolate_execinstr())
	    {
	      // When we hit the segment that should contain the
	      // file headers, reset the file offset so we place
	      // it and subsequent segments appropriately.
	      // We'll fix up the preceding segments below.
	      if (load_seg == *p)
		{
		  if (off == 0)
		    load_seg = NULL;
		  else
		    {
		      off = 0;
		      shndx_load_seg = *pshndx;
		    }
		}
	    }
	  else
	    {
	      // Verify that the file headers fall into the first segment.
	      if (load_seg != NULL && load_seg != *p)
		gold_unreachable();
	      load_seg = NULL;
	    }

	  bool are_addresses_set = (*p)->are_addresses_set();
	  if (are_addresses_set)
	    {
	      // When it comes to setting file offsets, we care about
	      // the physical address.
	      addr = (*p)->paddr();
	    }
	  else if (parameters->options().user_set_Ttext()
		   && (parameters->options().omagic()
		       || is_text_segment(target, *p)))
	    {
	      are_addresses_set = true;
	    }
	  else if (parameters->options().user_set_Trodata_segment()
		   && ((*p)->flags() & (elfcpp::PF_W | elfcpp::PF_X)) == 0)
	    {
	      addr = parameters->options().Trodata_segment();
	      are_addresses_set = true;
	    }
	  else if (parameters->options().user_set_Tdata()
		   && ((*p)->flags() & elfcpp::PF_W) != 0
		   && (!parameters->options().user_set_Tbss()
		       || (*p)->has_any_data_sections()))
	    {
	      addr = parameters->options().Tdata();
	      are_addresses_set = true;
	    }
	  else if (parameters->options().user_set_Tbss()
		   && ((*p)->flags() & elfcpp::PF_W) != 0
		   && !(*p)->has_any_data_sections())
	    {
	      addr = parameters->options().Tbss();
	      are_addresses_set = true;
	    }

	  uint64_t orig_addr = addr;
	  uint64_t orig_off = off;

	  uint64_t aligned_addr = 0;
	  uint64_t abi_pagesize = target->abi_pagesize();
	  uint64_t common_pagesize = target->common_pagesize();

	  if (!parameters->options().nmagic()
	      && !parameters->options().omagic())
	    (*p)->set_minimum_p_align(abi_pagesize);

	  if (!are_addresses_set)
	    {
	      // Skip the address forward one page, maintaining the same
	      // position within the page.  This lets us store both segments
	      // overlapping on a single page in the file, but the loader will
	      // put them on different pages in memory. We will revisit this
	      // decision once we know the size of the segment.

	      addr = align_address(addr, (*p)->maximum_alignment());
	      aligned_addr = addr;

	      if (load_seg == *p)
		{
		  // This is the segment that will contain the file
		  // headers, so its offset will have to be exactly zero.
		  gold_assert(orig_off == 0);

		  // If the target wants a fixed minimum distance from the
		  // text segment to the read-only segment, move up now.
		  uint64_t min_addr =
		    start_addr + (parameters->options().user_set_rosegment_gap()
				  ? parameters->options().rosegment_gap()
				  : target->rosegment_gap());
		  if (addr < min_addr)
		    addr = min_addr;

		  // But this is not the first segment!  To make its
		  // address congruent with its offset, that address better
		  // be aligned to the ABI-mandated page size.
		  addr = align_address(addr, abi_pagesize);
		  aligned_addr = addr;
		}
	      else
		{
		  if ((addr & (abi_pagesize - 1)) != 0)
		    addr = addr + abi_pagesize;

		  off = orig_off + ((addr - orig_addr) & (abi_pagesize - 1));
		}
	    }

	  if (!parameters->options().nmagic()
	      && !parameters->options().omagic())
	    {
	      // Here we are also taking care of the case when
	      // the maximum segment alignment is larger than the page size.
	      off = align_file_offset(off, addr,
				      std::max(abi_pagesize,
					       (*p)->maximum_alignment()));
	    }
	  else
	    {
	      // This is -N or -n with a section script which prevents
	      // us from using a load segment.  We need to ensure that
	      // the file offset is aligned to the alignment of the
	      // segment.  This is because the linker script
	      // implicitly assumed a zero offset.  If we don't align
	      // here, then the alignment of the sections in the
	      // linker script may not match the alignment of the
	      // sections in the set_section_addresses call below,
	      // causing an error about dot moving backward.
	      off = align_address(off, (*p)->maximum_alignment());
	    }

	  unsigned int shndx_hold = *pshndx;
	  bool has_relro = false;
	  uint64_t new_addr = (*p)->set_section_addresses(target, this,
							  false, addr,
							  &increase_relro,
							  &has_relro,
							  &off, pshndx);

	  // Now that we know the size of this segment, we may be able
	  // to save a page in memory, at the cost of wasting some
	  // file space, by instead aligning to the start of a new
	  // page.  Here we use the real machine page size rather than
	  // the ABI mandated page size.  If the segment has been
	  // aligned so that the relro data ends at a page boundary,
	  // we do not try to realign it.

	  if (!are_addresses_set
	      && !has_relro
	      && aligned_addr != addr
	      && !parameters->incremental())
	    {
	      uint64_t first_off = (common_pagesize
				    - (aligned_addr
				       & (common_pagesize - 1)));
	      uint64_t last_off = new_addr & (common_pagesize - 1);
	      if (first_off > 0
		  && last_off > 0
		  && ((aligned_addr & ~ (common_pagesize - 1))
		      != (new_addr & ~ (common_pagesize - 1)))
		  && first_off + last_off <= common_pagesize)
		{
		  *pshndx = shndx_hold;
		  addr = align_address(aligned_addr, common_pagesize);
		  addr = align_address(addr, (*p)->maximum_alignment());
		  if ((addr & (abi_pagesize - 1)) != 0)
		    addr = addr + abi_pagesize;
		  off = orig_off + ((addr - orig_addr) & (abi_pagesize - 1));
		  off = align_file_offset(off, addr, abi_pagesize);

		  increase_relro = this->increase_relro_;
		  if (this->script_options_->saw_sections_clause())
		    increase_relro = 0;
		  has_relro = false;

		  new_addr = (*p)->set_section_addresses(target, this,
							 true, addr,
							 &increase_relro,
							 &has_relro,
							 &off, pshndx);
		}
	    }

	  addr = new_addr;

	  // Implement --check-sections.  We know that the segments
	  // are sorted by LMA.
	  if (check_sections && last_load_segment != NULL)
	    {
	      gold_assert(last_load_segment->paddr() <= (*p)->paddr());
	      if (last_load_segment->paddr() + last_load_segment->memsz()
		  > (*p)->paddr())
		{
		  unsigned long long lb1 = last_load_segment->paddr();
		  unsigned long long le1 = lb1 + last_load_segment->memsz();
		  unsigned long long lb2 = (*p)->paddr();
		  unsigned long long le2 = lb2 + (*p)->memsz();
		  gold_error(_("load segment overlap [0x%llx -> 0x%llx] and "
			       "[0x%llx -> 0x%llx]"),
			     lb1, le1, lb2, le2);
		}
	    }
	  last_load_segment = *p;
	}
    }

  if (load_seg != NULL && target->isolate_execinstr())
    {
      // Process the early segments again, setting their file offsets
      // so they land after the segments starting at LOAD_SEG.
      off = align_file_offset(off, 0, target->abi_pagesize());

      this->reset_relax_output();

      for (Segment_list::iterator p = this->segment_list_.begin();
	   *p != load_seg;
	   ++p)
	{
	  if ((*p)->type() == elfcpp::PT_LOAD)
	    {
	      // We repeat the whole job of assigning addresses and
	      // offsets, but we really only want to change the offsets and
	      // must ensure that the addresses all come out the same as
	      // they did the first time through.
	      bool has_relro = false;
	      const uint64_t old_addr = (*p)->vaddr();
	      const uint64_t old_end = old_addr + (*p)->memsz();
	      uint64_t new_addr = (*p)->set_section_addresses(target, this,
							      true, old_addr,
							      &increase_relro,
							      &has_relro,
							      &off,
							      &shndx_begin);
	      gold_assert(new_addr == old_end);
	    }
	}

      gold_assert(shndx_begin == shndx_load_seg);
    }

  // Handle the non-PT_LOAD segments, setting their offsets from their
  // section's offsets.
  for (Segment_list::iterator p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
    {
      if ((*p)->type() != elfcpp::PT_LOAD)
	(*p)->set_offset((*p)->type() == elfcpp::PT_GNU_RELRO
			 ? increase_relro
			 : 0);
    }

  // Set the TLS offsets for each section in the PT_TLS segment.
  if (this->tls_segment_ != NULL)
    this->tls_segment_->set_tls_offsets();

  return off;
}

// Set the offsets of all the allocated sections when doing a
// relocatable link.  This does the same jobs as set_segment_offsets,
// only for a relocatable link.

off_t
Layout::set_relocatable_section_offsets(Output_data* file_header,
					unsigned int* pshndx)
{
  off_t off = 0;

  file_header->set_address_and_file_offset(0, 0);
  off += file_header->data_size();

  for (Section_list::iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    {
      // We skip unallocated sections here, except that group sections
      // have to come first.
      if (((*p)->flags() & elfcpp::SHF_ALLOC) == 0
	  && (*p)->type() != elfcpp::SHT_GROUP)
	continue;

      off = align_address(off, (*p)->addralign());

      // The linker script might have set the address.
      if (!(*p)->is_address_valid())
	(*p)->set_address(0);
      (*p)->set_file_offset(off);
      (*p)->finalize_data_size();
      if ((*p)->type() != elfcpp::SHT_NOBITS)
	off += (*p)->data_size();

      (*p)->set_out_shndx(*pshndx);
      ++*pshndx;
    }

  return off;
}

// Set the file offset of all the sections not associated with a
// segment.

off_t
Layout::set_section_offsets(off_t off, Layout::Section_offset_pass pass)
{
  off_t startoff = off;
  off_t maxoff = off;

  for (Section_list::iterator p = this->unattached_section_list_.begin();
       p != this->unattached_section_list_.end();
       ++p)
    {
      // The symtab section is handled in create_symtab_sections.
      if (*p == this->symtab_section_)
	continue;

      // If we've already set the data size, don't set it again.
      if ((*p)->is_offset_valid() && (*p)->is_data_size_valid())
	continue;

      if (pass == BEFORE_INPUT_SECTIONS_PASS
	  && (*p)->requires_postprocessing())
	{
	  (*p)->create_postprocessing_buffer();
	  this->any_postprocessing_sections_ = true;
	}

      if (pass == BEFORE_INPUT_SECTIONS_PASS
	  && (*p)->after_input_sections())
	continue;
      else if (pass == POSTPROCESSING_SECTIONS_PASS
	       && (!(*p)->after_input_sections()
		   || (*p)->type() == elfcpp::SHT_STRTAB))
	continue;
      else if (pass == STRTAB_AFTER_POSTPROCESSING_SECTIONS_PASS
	       && (!(*p)->after_input_sections()
		   || (*p)->type() != elfcpp::SHT_STRTAB))
	continue;

      if (!parameters->incremental_update())
	{
	  off = align_address(off, (*p)->addralign());
	  (*p)->set_file_offset(off);
	  (*p)->finalize_data_size();
	}
      else
	{
	  // Incremental update: allocate file space from free list.
	  (*p)->pre_finalize_data_size();
	  off_t current_size = (*p)->current_data_size();
	  off = this->allocate(current_size, (*p)->addralign(), startoff);
	  if (off == -1)
	    {
	      if (is_debugging_enabled(DEBUG_INCREMENTAL))
		this->free_list_.dump();
	      gold_assert((*p)->output_section() != NULL);
	      gold_fallback(_("out of patch space for section %s; "
			      "relink with --incremental-full"),
			    (*p)->output_section()->name());
	    }
	  (*p)->set_file_offset(off);
	  (*p)->finalize_data_size();
	  if ((*p)->data_size() > current_size)
	    {
	      gold_assert((*p)->output_section() != NULL);
	      gold_fallback(_("%s: section changed size; "
			      "relink with --incremental-full"),
			    (*p)->output_section()->name());
	    }
	  gold_debug(DEBUG_INCREMENTAL,
		     "set_section_offsets: %08lx %08lx %s",
		     static_cast<long>(off),
		     static_cast<long>((*p)->data_size()),
		     ((*p)->output_section() != NULL
		      ? (*p)->output_section()->name() : "(special)"));
	}

      off += (*p)->data_size();
      if (off > maxoff)
	maxoff = off;

      // At this point the name must be set.
      if (pass != STRTAB_AFTER_POSTPROCESSING_SECTIONS_PASS)
	this->namepool_.add((*p)->name(), false, NULL);
    }
  return maxoff;
}

// Set the section indexes of all the sections not associated with a
// segment.

unsigned int
Layout::set_section_indexes(unsigned int shndx)
{
  for (Section_list::iterator p = this->unattached_section_list_.begin();
       p != this->unattached_section_list_.end();
       ++p)
    {
      if (!(*p)->has_out_shndx())
	{
	  (*p)->set_out_shndx(shndx);
	  ++shndx;
	}
    }
  return shndx;
}

// Set the section addresses according to the linker script.  This is
// only called when we see a SECTIONS clause.  This returns the
// program segment which should hold the file header and segment
// headers, if any.  It will return NULL if they should not be in a
// segment.

Output_segment*
Layout::set_section_addresses_from_script(Symbol_table* symtab)
{
  Script_sections* ss = this->script_options_->script_sections();
  gold_assert(ss->saw_sections_clause());
  return this->script_options_->set_section_addresses(symtab, this);
}

// Place the orphan sections in the linker script.

void
Layout::place_orphan_sections_in_script()
{
  Script_sections* ss = this->script_options_->script_sections();
  gold_assert(ss->saw_sections_clause());

  // Place each orphaned output section in the script.
  for (Section_list::iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    {
      if (!(*p)->found_in_sections_clause())
	ss->place_orphan(*p);
    }
}

// Count the local symbols in the regular symbol table and the dynamic
// symbol table, and build the respective string pools.

void
Layout::count_local_symbols(const Task* task,
			    const Input_objects* input_objects)
{
  // First, figure out an upper bound on the number of symbols we'll
  // be inserting into each pool.  This helps us create the pools with
  // the right size, to avoid unnecessary hashtable resizing.
  unsigned int symbol_count = 0;
  for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
       p != input_objects->relobj_end();
       ++p)
    symbol_count += (*p)->local_symbol_count();

  // Go from "upper bound" to "estimate."  We overcount for two
  // reasons: we double-count symbols that occur in more than one
  // object file, and we count symbols that are dropped from the
  // output.  Add it all together and assume we overcount by 100%.
  symbol_count /= 2;

  // We assume all symbols will go into both the sympool and dynpool.
  this->sympool_.reserve(symbol_count);
  this->dynpool_.reserve(symbol_count);

  for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
       p != input_objects->relobj_end();
       ++p)
    {
      Task_lock_obj<Object> tlo(task, *p);
      (*p)->count_local_symbols(&this->sympool_, &this->dynpool_);
    }
}

// Create the symbol table sections.  Here we also set the final
// values of the symbols.  At this point all the loadable sections are
// fully laid out.  SHNUM is the number of sections so far.

void
Layout::create_symtab_sections(const Input_objects* input_objects,
			       Symbol_table* symtab,
			       unsigned int shnum,
			       off_t* poff)
{
  int symsize;
  unsigned int align;
  if (parameters->target().get_size() == 32)
    {
      symsize = elfcpp::Elf_sizes<32>::sym_size;
      align = 4;
    }
  else if (parameters->target().get_size() == 64)
    {
      symsize = elfcpp::Elf_sizes<64>::sym_size;
      align = 8;
    }
  else
    gold_unreachable();

  // Compute file offsets relative to the start of the symtab section.
  off_t off = 0;

  // Save space for the dummy symbol at the start of the section.  We
  // never bother to write this out--it will just be left as zero.
  off += symsize;
  unsigned int local_symbol_index = 1;

  // Add STT_SECTION symbols for each Output section which needs one.
  for (Section_list::iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    {
      if (!(*p)->needs_symtab_index())
	(*p)->set_symtab_index(-1U);
      else
	{
	  (*p)->set_symtab_index(local_symbol_index);
	  ++local_symbol_index;
	  off += symsize;
	}
    }

  for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
       p != input_objects->relobj_end();
       ++p)
    {
      unsigned int index = (*p)->finalize_local_symbols(local_symbol_index,
							off, symtab);
      off += (index - local_symbol_index) * symsize;
      local_symbol_index = index;
    }

  unsigned int local_symcount = local_symbol_index;
  gold_assert(static_cast<off_t>(local_symcount * symsize) == off);

  off_t dynoff;
  size_t dyn_global_index;
  size_t dyncount;
  if (this->dynsym_section_ == NULL)
    {
      dynoff = 0;
      dyn_global_index = 0;
      dyncount = 0;
    }
  else
    {
      dyn_global_index = this->dynsym_section_->info();
      off_t locsize = dyn_global_index * this->dynsym_section_->entsize();
      dynoff = this->dynsym_section_->offset() + locsize;
      dyncount = (this->dynsym_section_->data_size() - locsize) / symsize;
      gold_assert(static_cast<off_t>(dyncount * symsize)
		  == this->dynsym_section_->data_size() - locsize);
    }

  off_t global_off = off;
  off = symtab->finalize(off, dynoff, dyn_global_index, dyncount,
			 &this->sympool_, &local_symcount);

  if (!parameters->options().strip_all())
    {
      this->sympool_.set_string_offsets();

      const char* symtab_name = this->namepool_.add(".symtab", false, NULL);
      Output_section* osymtab = this->make_output_section(symtab_name,
							  elfcpp::SHT_SYMTAB,
							  0, ORDER_INVALID,
							  false);
      this->symtab_section_ = osymtab;

      Output_section_data* pos = new Output_data_fixed_space(off, align,
							     "** symtab");
      osymtab->add_output_section_data(pos);

      // We generate a .symtab_shndx section if we have more than
      // SHN_LORESERVE sections.  Technically it is possible that we
      // don't need one, because it is possible that there are no
      // symbols in any of sections with indexes larger than
      // SHN_LORESERVE.  That is probably unusual, though, and it is
      // easier to always create one than to compute section indexes
      // twice (once here, once when writing out the symbols).
      if (shnum >= elfcpp::SHN_LORESERVE)
	{
	  const char* symtab_xindex_name = this->namepool_.add(".symtab_shndx",
							       false, NULL);
	  Output_section* osymtab_xindex =
	    this->make_output_section(symtab_xindex_name,
				      elfcpp::SHT_SYMTAB_SHNDX, 0,
				      ORDER_INVALID, false);

	  size_t symcount = off / symsize;
	  this->symtab_xindex_ = new Output_symtab_xindex(symcount);

	  osymtab_xindex->add_output_section_data(this->symtab_xindex_);

	  osymtab_xindex->set_link_section(osymtab);
	  osymtab_xindex->set_addralign(4);
	  osymtab_xindex->set_entsize(4);

	  osymtab_xindex->set_after_input_sections();

	  // This tells the driver code to wait until the symbol table
	  // has written out before writing out the postprocessing
	  // sections, including the .symtab_shndx section.
	  this->any_postprocessing_sections_ = true;
	}

      const char* strtab_name = this->namepool_.add(".strtab", false, NULL);
      Output_section* ostrtab = this->make_output_section(strtab_name,
							  elfcpp::SHT_STRTAB,
							  0, ORDER_INVALID,
							  false);

      Output_section_data* pstr = new Output_data_strtab(&this->sympool_);
      ostrtab->add_output_section_data(pstr);

      off_t symtab_off;
      if (!parameters->incremental_update())
	symtab_off = align_address(*poff, align);
      else
	{
	  symtab_off = this->allocate(off, align, *poff);
	  if (off == -1)
	    gold_fallback(_("out of patch space for symbol table; "
			    "relink with --incremental-full"));
	  gold_debug(DEBUG_INCREMENTAL,
		     "create_symtab_sections: %08lx %08lx .symtab",
		     static_cast<long>(symtab_off),
		     static_cast<long>(off));
	}

      symtab->set_file_offset(symtab_off + global_off);
      osymtab->set_file_offset(symtab_off);
      osymtab->finalize_data_size();
      osymtab->set_link_section(ostrtab);
      osymtab->set_info(local_symcount);
      osymtab->set_entsize(symsize);

      if (symtab_off + off > *poff)
	*poff = symtab_off + off;
    }
}

// Create the .shstrtab section, which holds the names of the
// sections.  At the time this is called, we have created all the
// output sections except .shstrtab itself.

Output_section*
Layout::create_shstrtab()
{
  // FIXME: We don't need to create a .shstrtab section if we are
  // stripping everything.

  const char* name = this->namepool_.add(".shstrtab", false, NULL);

  Output_section* os = this->make_output_section(name, elfcpp::SHT_STRTAB, 0,
						 ORDER_INVALID, false);

  if (strcmp(parameters->options().compress_debug_sections(), "none") != 0)
    {
      // We can't write out this section until we've set all the
      // section names, and we don't set the names of compressed
      // output sections until relocations are complete.  FIXME: With
      // the current names we use, this is unnecessary.
      os->set_after_input_sections();
    }

  Output_section_data* posd = new Output_data_strtab(&this->namepool_);
  os->add_output_section_data(posd);

  return os;
}

// Create the section headers.  SIZE is 32 or 64.  OFF is the file
// offset.

void
Layout::create_shdrs(const Output_section* shstrtab_section, off_t* poff)
{
  Output_section_headers* oshdrs;
  oshdrs = new Output_section_headers(this,
				      &this->segment_list_,
				      &this->section_list_,
				      &this->unattached_section_list_,
				      &this->namepool_,
				      shstrtab_section);
  off_t off;
  if (!parameters->incremental_update())
    off = align_address(*poff, oshdrs->addralign());
  else
    {
      oshdrs->pre_finalize_data_size();
      off = this->allocate(oshdrs->data_size(), oshdrs->addralign(), *poff);
      if (off == -1)
	  gold_fallback(_("out of patch space for section header table; "
			  "relink with --incremental-full"));
      gold_debug(DEBUG_INCREMENTAL,
		 "create_shdrs: %08lx %08lx (section header table)",
		 static_cast<long>(off),
		 static_cast<long>(off + oshdrs->data_size()));
    }
  oshdrs->set_address_and_file_offset(0, off);
  off += oshdrs->data_size();
  if (off > *poff)
    *poff = off;
  this->section_headers_ = oshdrs;
}

// Count the allocated sections.

size_t
Layout::allocated_output_section_count() const
{
  size_t section_count = 0;
  for (Segment_list::const_iterator p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
    section_count += (*p)->output_section_count();
  return section_count;
}

// Create the dynamic symbol table.

void
Layout::create_dynamic_symtab(const Input_objects* input_objects,
			      Symbol_table* symtab,
			      Output_section** pdynstr,
			      unsigned int* plocal_dynamic_count,
			      std::vector<Symbol*>* pdynamic_symbols,
			      Versions* pversions)
{
  // Count all the symbols in the dynamic symbol table, and set the
  // dynamic symbol indexes.

  // Skip symbol 0, which is always all zeroes.
  unsigned int index = 1;

  // Add STT_SECTION symbols for each Output section which needs one.
  for (Section_list::iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    {
      if (!(*p)->needs_dynsym_index())
	(*p)->set_dynsym_index(-1U);
      else
	{
	  (*p)->set_dynsym_index(index);
	  ++index;
	}
    }

  // Count the local symbols that need to go in the dynamic symbol table,
  // and set the dynamic symbol indexes.
  for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
       p != input_objects->relobj_end();
       ++p)
    {
      unsigned int new_index = (*p)->set_local_dynsym_indexes(index);
      index = new_index;
    }

  unsigned int local_symcount = index;
  *plocal_dynamic_count = local_symcount;

  index = symtab->set_dynsym_indexes(index, pdynamic_symbols,
				     &this->dynpool_, pversions);

  int symsize;
  unsigned int align;
  const int size = parameters->target().get_size();
  if (size == 32)
    {
      symsize = elfcpp::Elf_sizes<32>::sym_size;
      align = 4;
    }
  else if (size == 64)
    {
      symsize = elfcpp::Elf_sizes<64>::sym_size;
      align = 8;
    }
  else
    gold_unreachable();

  // Create the dynamic symbol table section.

  Output_section* dynsym = this->choose_output_section(NULL, ".dynsym",
						       elfcpp::SHT_DYNSYM,
						       elfcpp::SHF_ALLOC,
						       false,
						       ORDER_DYNAMIC_LINKER,
						       false);

  // Check for NULL as a linker script may discard .dynsym.
  if (dynsym != NULL)
    {
      Output_section_data* odata = new Output_data_fixed_space(index * symsize,
							       align,
							       "** dynsym");
      dynsym->add_output_section_data(odata);

      dynsym->set_info(local_symcount);
      dynsym->set_entsize(symsize);
      dynsym->set_addralign(align);

      this->dynsym_section_ = dynsym;
    }

  Output_data_dynamic* const odyn = this->dynamic_data_;
  if (odyn != NULL)
    {
      odyn->add_section_address(elfcpp::DT_SYMTAB, dynsym);
      odyn->add_constant(elfcpp::DT_SYMENT, symsize);
    }

  // If there are more than SHN_LORESERVE allocated sections, we
  // create a .dynsym_shndx section.  It is possible that we don't
  // need one, because it is possible that there are no dynamic
  // symbols in any of the sections with indexes larger than
  // SHN_LORESERVE.  This is probably unusual, though, and at this
  // time we don't know the actual section indexes so it is
  // inconvenient to check.
  if (this->allocated_output_section_count() >= elfcpp::SHN_LORESERVE)
    {
      Output_section* dynsym_xindex =
	this->choose_output_section(NULL, ".dynsym_shndx",
				    elfcpp::SHT_SYMTAB_SHNDX,
				    elfcpp::SHF_ALLOC,
				    false, ORDER_DYNAMIC_LINKER, false);

      if (dynsym_xindex != NULL)
	{
	  this->dynsym_xindex_ = new Output_symtab_xindex(index);

	  dynsym_xindex->add_output_section_data(this->dynsym_xindex_);

	  dynsym_xindex->set_link_section(dynsym);
	  dynsym_xindex->set_addralign(4);
	  dynsym_xindex->set_entsize(4);

	  dynsym_xindex->set_after_input_sections();

	  // This tells the driver code to wait until the symbol table
	  // has written out before writing out the postprocessing
	  // sections, including the .dynsym_shndx section.
	  this->any_postprocessing_sections_ = true;
	}
    }

  // Create the dynamic string table section.

  Output_section* dynstr = this->choose_output_section(NULL, ".dynstr",
						       elfcpp::SHT_STRTAB,
						       elfcpp::SHF_ALLOC,
						       false,
						       ORDER_DYNAMIC_LINKER,
						       false);
  *pdynstr = dynstr;
  if (dynstr != NULL)
    {
      Output_section_data* strdata = new Output_data_strtab(&this->dynpool_);
      dynstr->add_output_section_data(strdata);

      if (dynsym != NULL)
	dynsym->set_link_section(dynstr);
      if (this->dynamic_section_ != NULL)
	this->dynamic_section_->set_link_section(dynstr);

      if (odyn != NULL)
	{
	  odyn->add_section_address(elfcpp::DT_STRTAB, dynstr);
	  odyn->add_section_size(elfcpp::DT_STRSZ, dynstr);
	}
    }

  // Create the hash tables.

  if (strcmp(parameters->options().hash_style(), "sysv") == 0
      || strcmp(parameters->options().hash_style(), "both") == 0)
    {
      unsigned char* phash;
      unsigned int hashlen;
      Dynobj::create_elf_hash_table(*pdynamic_symbols, local_symcount,
				    &phash, &hashlen);

      Output_section* hashsec =
	this->choose_output_section(NULL, ".hash", elfcpp::SHT_HASH,
				    elfcpp::SHF_ALLOC, false,
				    ORDER_DYNAMIC_LINKER, false);

      Output_section_data* hashdata = new Output_data_const_buffer(phash,
								   hashlen,
								   align,
								   "** hash");
      if (hashsec != NULL && hashdata != NULL)
	hashsec->add_output_section_data(hashdata);

      if (hashsec != NULL)
	{
	  if (dynsym != NULL)
	    hashsec->set_link_section(dynsym);
	  hashsec->set_entsize(4);
	}

      if (odyn != NULL)
	odyn->add_section_address(elfcpp::DT_HASH, hashsec);
    }

  if (strcmp(parameters->options().hash_style(), "gnu") == 0
      || strcmp(parameters->options().hash_style(), "both") == 0)
    {
      unsigned char* phash;
      unsigned int hashlen;
      Dynobj::create_gnu_hash_table(*pdynamic_symbols, local_symcount,
				    &phash, &hashlen);

      Output_section* hashsec =
	this->choose_output_section(NULL, ".gnu.hash", elfcpp::SHT_GNU_HASH,
				    elfcpp::SHF_ALLOC, false,
				    ORDER_DYNAMIC_LINKER, false);

      Output_section_data* hashdata = new Output_data_const_buffer(phash,
								   hashlen,
								   align,
								   "** hash");
      if (hashsec != NULL && hashdata != NULL)
	hashsec->add_output_section_data(hashdata);

      if (hashsec != NULL)
	{
	  if (dynsym != NULL)
	    hashsec->set_link_section(dynsym);

	  // For a 64-bit target, the entries in .gnu.hash do not have
	  // a uniform size, so we only set the entry size for a
	  // 32-bit target.
	  if (parameters->target().get_size() == 32)
	    hashsec->set_entsize(4);

	  if (odyn != NULL)
	    odyn->add_section_address(elfcpp::DT_GNU_HASH, hashsec);
	}
    }
}

// Assign offsets to each local portion of the dynamic symbol table.

void
Layout::assign_local_dynsym_offsets(const Input_objects* input_objects)
{
  Output_section* dynsym = this->dynsym_section_;
  if (dynsym == NULL)
    return;

  off_t off = dynsym->offset();

  // Skip the dummy symbol at the start of the section.
  off += dynsym->entsize();

  for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
       p != input_objects->relobj_end();
       ++p)
    {
      unsigned int count = (*p)->set_local_dynsym_offset(off);
      off += count * dynsym->entsize();
    }
}

// Create the version sections.

void
Layout::create_version_sections(const Versions* versions,
				const Symbol_table* symtab,
				unsigned int local_symcount,
				const std::vector<Symbol*>& dynamic_symbols,
				const Output_section* dynstr)
{
  if (!versions->any_defs() && !versions->any_needs())
    return;

  switch (parameters->size_and_endianness())
    {
#ifdef HAVE_TARGET_32_LITTLE
    case Parameters::TARGET_32_LITTLE:
      this->sized_create_version_sections<32, false>(versions, symtab,
						     local_symcount,
						     dynamic_symbols, dynstr);
      break;
#endif
#ifdef HAVE_TARGET_32_BIG
    case Parameters::TARGET_32_BIG:
      this->sized_create_version_sections<32, true>(versions, symtab,
						    local_symcount,
						    dynamic_symbols, dynstr);
      break;
#endif
#ifdef HAVE_TARGET_64_LITTLE
    case Parameters::TARGET_64_LITTLE:
      this->sized_create_version_sections<64, false>(versions, symtab,
						     local_symcount,
						     dynamic_symbols, dynstr);
      break;
#endif
#ifdef HAVE_TARGET_64_BIG
    case Parameters::TARGET_64_BIG:
      this->sized_create_version_sections<64, true>(versions, symtab,
						    local_symcount,
						    dynamic_symbols, dynstr);
      break;
#endif
    default:
      gold_unreachable();
    }
}

// Create the version sections, sized version.

template<int size, bool big_endian>
void
Layout::sized_create_version_sections(
    const Versions* versions,
    const Symbol_table* symtab,
    unsigned int local_symcount,
    const std::vector<Symbol*>& dynamic_symbols,
    const Output_section* dynstr)
{
  Output_section* vsec = this->choose_output_section(NULL, ".gnu.version",
						     elfcpp::SHT_GNU_versym,
						     elfcpp::SHF_ALLOC,
						     false,
						     ORDER_DYNAMIC_LINKER,
						     false);

  // Check for NULL since a linker script may discard this section.
  if (vsec != NULL)
    {
      unsigned char* vbuf;
      unsigned int vsize;
      versions->symbol_section_contents<size, big_endian>(symtab,
							  &this->dynpool_,
							  local_symcount,
							  dynamic_symbols,
							  &vbuf, &vsize);

      Output_section_data* vdata = new Output_data_const_buffer(vbuf, vsize, 2,
								"** versions");

      vsec->add_output_section_data(vdata);
      vsec->set_entsize(2);
      vsec->set_link_section(this->dynsym_section_);
    }

  Output_data_dynamic* const odyn = this->dynamic_data_;
  if (odyn != NULL && vsec != NULL)
    odyn->add_section_address(elfcpp::DT_VERSYM, vsec);

  if (versions->any_defs())
    {
      Output_section* vdsec;
      vdsec = this->choose_output_section(NULL, ".gnu.version_d",
					  elfcpp::SHT_GNU_verdef,
					  elfcpp::SHF_ALLOC,
					  false, ORDER_DYNAMIC_LINKER, false);

      if (vdsec != NULL)
	{
	  unsigned char* vdbuf;
	  unsigned int vdsize;
	  unsigned int vdentries;
	  versions->def_section_contents<size, big_endian>(&this->dynpool_,
							   &vdbuf, &vdsize,
							   &vdentries);

	  Output_section_data* vddata =
	    new Output_data_const_buffer(vdbuf, vdsize, 4, "** version defs");

	  vdsec->add_output_section_data(vddata);
	  vdsec->set_link_section(dynstr);
	  vdsec->set_info(vdentries);

	  if (odyn != NULL)
	    {
	      odyn->add_section_address(elfcpp::DT_VERDEF, vdsec);
	      odyn->add_constant(elfcpp::DT_VERDEFNUM, vdentries);
	    }
	}
    }

  if (versions->any_needs())
    {
      Output_section* vnsec;
      vnsec = this->choose_output_section(NULL, ".gnu.version_r",
					  elfcpp::SHT_GNU_verneed,
					  elfcpp::SHF_ALLOC,
					  false, ORDER_DYNAMIC_LINKER, false);

      if (vnsec != NULL)
	{
	  unsigned char* vnbuf;
	  unsigned int vnsize;
	  unsigned int vnentries;
	  versions->need_section_contents<size, big_endian>(&this->dynpool_,
							    &vnbuf, &vnsize,
							    &vnentries);

	  Output_section_data* vndata =
	    new Output_data_const_buffer(vnbuf, vnsize, 4, "** version refs");

	  vnsec->add_output_section_data(vndata);
	  vnsec->set_link_section(dynstr);
	  vnsec->set_info(vnentries);

	  if (odyn != NULL)
	    {
	      odyn->add_section_address(elfcpp::DT_VERNEED, vnsec);
	      odyn->add_constant(elfcpp::DT_VERNEEDNUM, vnentries);
	    }
	}
    }
}

// Create the .interp section and PT_INTERP segment.

void
Layout::create_interp(const Target* target)
{
  gold_assert(this->interp_segment_ == NULL);

  const char* interp = parameters->options().dynamic_linker();
  if (interp == NULL)
    {
      interp = target->dynamic_linker();
      gold_assert(interp != NULL);
    }

  size_t len = strlen(interp) + 1;

  Output_section_data* odata = new Output_data_const(interp, len, 1);

  Output_section* osec = this->choose_output_section(NULL, ".interp",
						     elfcpp::SHT_PROGBITS,
						     elfcpp::SHF_ALLOC,
						     false, ORDER_INTERP,
						     false);
  if (osec != NULL)
    osec->add_output_section_data(odata);
}

// Add dynamic tags for the PLT and the dynamic relocs.  This is
// called by the target-specific code.  This does nothing if not doing
// a dynamic link.

// USE_REL is true for REL relocs rather than RELA relocs.

// If PLT_GOT is not NULL, then DT_PLTGOT points to it.

// If PLT_REL is not NULL, it is used for DT_PLTRELSZ, and DT_JMPREL,
// and we also set DT_PLTREL.  We use PLT_REL's output section, since
// some targets have multiple reloc sections in PLT_REL.

// If DYN_REL is not NULL, it is used for DT_REL/DT_RELA,
// DT_RELSZ/DT_RELASZ, DT_RELENT/DT_RELAENT.  Again we use the output
// section.

// If ADD_DEBUG is true, we add a DT_DEBUG entry when generating an
// executable.

void
Layout::add_target_dynamic_tags(bool use_rel, const Output_data* plt_got,
				const Output_data* plt_rel,
				const Output_data_reloc_generic* dyn_rel,
				bool add_debug, bool dynrel_includes_plt)
{
  Output_data_dynamic* odyn = this->dynamic_data_;
  if (odyn == NULL)
    return;

  if (plt_got != NULL && plt_got->output_section() != NULL)
    odyn->add_section_address(elfcpp::DT_PLTGOT, plt_got);

  if (plt_rel != NULL && plt_rel->output_section() != NULL)
    {
      odyn->add_section_size(elfcpp::DT_PLTRELSZ, plt_rel->output_section());
      odyn->add_section_address(elfcpp::DT_JMPREL, plt_rel->output_section());
      odyn->add_constant(elfcpp::DT_PLTREL,
			 use_rel ? elfcpp::DT_REL : elfcpp::DT_RELA);
    }

  if ((dyn_rel != NULL && dyn_rel->output_section() != NULL)
      || (dynrel_includes_plt
	  && plt_rel != NULL
	  && plt_rel->output_section() != NULL))
    {
      bool have_dyn_rel = dyn_rel != NULL && dyn_rel->output_section() != NULL;
      bool have_plt_rel = plt_rel != NULL && plt_rel->output_section() != NULL;
      odyn->add_section_address(use_rel ? elfcpp::DT_REL : elfcpp::DT_RELA,
				(have_dyn_rel
				 ? dyn_rel->output_section()
				 : plt_rel->output_section()));
      elfcpp::DT size_tag = use_rel ? elfcpp::DT_RELSZ : elfcpp::DT_RELASZ;
      if (have_dyn_rel && have_plt_rel && dynrel_includes_plt)
	odyn->add_section_size(size_tag,
			       dyn_rel->output_section(),
			       plt_rel->output_section());
      else if (have_dyn_rel)
	odyn->add_section_size(size_tag, dyn_rel->output_section());
      else
	odyn->add_section_size(size_tag, plt_rel->output_section());
      const int size = parameters->target().get_size();
      elfcpp::DT rel_tag;
      int rel_size;
      if (use_rel)
	{
	  rel_tag = elfcpp::DT_RELENT;
	  if (size == 32)
	    rel_size = Reloc_types<elfcpp::SHT_REL, 32, false>::reloc_size;
	  else if (size == 64)
	    rel_size = Reloc_types<elfcpp::SHT_REL, 64, false>::reloc_size;
	  else
	    gold_unreachable();
	}
      else
	{
	  rel_tag = elfcpp::DT_RELAENT;
	  if (size == 32)
	    rel_size = Reloc_types<elfcpp::SHT_RELA, 32, false>::reloc_size;
	  else if (size == 64)
	    rel_size = Reloc_types<elfcpp::SHT_RELA, 64, false>::reloc_size;
	  else
	    gold_unreachable();
	}
      odyn->add_constant(rel_tag, rel_size);

      if (parameters->options().combreloc() && have_dyn_rel)
	{
	  size_t c = dyn_rel->relative_reloc_count();
	  if (c > 0)
	    odyn->add_constant((use_rel
				? elfcpp::DT_RELCOUNT
				: elfcpp::DT_RELACOUNT),
			       c);
	}
    }

  if (add_debug && !parameters->options().shared())
    {
      // The value of the DT_DEBUG tag is filled in by the dynamic
      // linker at run time, and used by the debugger.
      odyn->add_constant(elfcpp::DT_DEBUG, 0);
    }
}

// Finish the .dynamic section and PT_DYNAMIC segment.

void
Layout::finish_dynamic_section(const Input_objects* input_objects,
			       const Symbol_table* symtab)
{
  if (!this->script_options_->saw_phdrs_clause()
      && this->dynamic_section_ != NULL)
    {
      Output_segment* oseg = this->make_output_segment(elfcpp::PT_DYNAMIC,
						       (elfcpp::PF_R
							| elfcpp::PF_W));
      oseg->add_output_section_to_nonload(this->dynamic_section_,
					  elfcpp::PF_R | elfcpp::PF_W);
    }

  Output_data_dynamic* const odyn = this->dynamic_data_;
  if (odyn == NULL)
    return;

  for (Input_objects::Dynobj_iterator p = input_objects->dynobj_begin();
       p != input_objects->dynobj_end();
       ++p)
    {
      if (!(*p)->is_needed() && (*p)->as_needed())
	{
	  // This dynamic object was linked with --as-needed, but it
	  // is not needed.
	  continue;
	}

      odyn->add_string(elfcpp::DT_NEEDED, (*p)->soname());
    }

  if (parameters->options().shared())
    {
      const char* soname = parameters->options().soname();
      if (soname != NULL)
	odyn->add_string(elfcpp::DT_SONAME, soname);
    }

  Symbol* sym = symtab->lookup(parameters->options().init());
  if (sym != NULL && sym->is_defined() && !sym->is_from_dynobj())
    odyn->add_symbol(elfcpp::DT_INIT, sym);

  sym = symtab->lookup(parameters->options().fini());
  if (sym != NULL && sym->is_defined() && !sym->is_from_dynobj())
    odyn->add_symbol(elfcpp::DT_FINI, sym);

  // Look for .init_array, .preinit_array and .fini_array by checking
  // section types.
  for(Layout::Section_list::const_iterator p = this->section_list_.begin();
      p != this->section_list_.end();
      ++p)
    switch((*p)->type())
      {
      case elfcpp::SHT_FINI_ARRAY:
	odyn->add_section_address(elfcpp::DT_FINI_ARRAY, *p);
	odyn->add_section_size(elfcpp::DT_FINI_ARRAYSZ, *p);
	break;
      case elfcpp::SHT_INIT_ARRAY:
	odyn->add_section_address(elfcpp::DT_INIT_ARRAY, *p);
	odyn->add_section_size(elfcpp::DT_INIT_ARRAYSZ, *p);
	break;
      case elfcpp::SHT_PREINIT_ARRAY:
	odyn->add_section_address(elfcpp::DT_PREINIT_ARRAY, *p);
	odyn->add_section_size(elfcpp::DT_PREINIT_ARRAYSZ, *p);
	break;
      default:
	break;
      }

  // Add a DT_RPATH entry if needed.
  const General_options::Dir_list& rpath(parameters->options().rpath());
  if (!rpath.empty())
    {
      std::string rpath_val;
      for (General_options::Dir_list::const_iterator p = rpath.begin();
	   p != rpath.end();
	   ++p)
	{
	  if (rpath_val.empty())
	    rpath_val = p->name();
	  else
	    {
	      // Eliminate duplicates.
	      General_options::Dir_list::const_iterator q;
	      for (q = rpath.begin(); q != p; ++q)
		if (q->name() == p->name())
		  break;
	      if (q == p)
		{
		  rpath_val += ':';
		  rpath_val += p->name();
		}
	    }
	}

      if (!parameters->options().enable_new_dtags())
	odyn->add_string(elfcpp::DT_RPATH, rpath_val);
      else
	odyn->add_string(elfcpp::DT_RUNPATH, rpath_val);
    }

  // Look for text segments that have dynamic relocations.
  bool have_textrel = false;
  if (!this->script_options_->saw_sections_clause())
    {
      for (Segment_list::const_iterator p = this->segment_list_.begin();
	   p != this->segment_list_.end();
	   ++p)
	{
	  if ((*p)->type() == elfcpp::PT_LOAD
	      && ((*p)->flags() & elfcpp::PF_W) == 0
	      && (*p)->has_dynamic_reloc())
	    {
	      have_textrel = true;
	      break;
	    }
	}
    }
  else
    {
      // We don't know the section -> segment mapping, so we are
      // conservative and just look for readonly sections with
      // relocations.  If those sections wind up in writable segments,
      // then we have created an unnecessary DT_TEXTREL entry.
      for (Section_list::const_iterator p = this->section_list_.begin();
	   p != this->section_list_.end();
	   ++p)
	{
	  if (((*p)->flags() & elfcpp::SHF_ALLOC) != 0
	      && ((*p)->flags() & elfcpp::SHF_WRITE) == 0
	      && (*p)->has_dynamic_reloc())
	    {
	      have_textrel = true;
	      break;
	    }
	}
    }

  if (parameters->options().filter() != NULL)
    odyn->add_string(elfcpp::DT_FILTER, parameters->options().filter());
  if (parameters->options().any_auxiliary())
    {
      for (options::String_set::const_iterator p =
	     parameters->options().auxiliary_begin();
	   p != parameters->options().auxiliary_end();
	   ++p)
	odyn->add_string(elfcpp::DT_AUXILIARY, *p);
    }

  // Add a DT_FLAGS entry if necessary.
  unsigned int flags = 0;
  if (have_textrel)
    {
      // Add a DT_TEXTREL for compatibility with older loaders.
      odyn->add_constant(elfcpp::DT_TEXTREL, 0);
      flags |= elfcpp::DF_TEXTREL;

      if (parameters->options().text())
	gold_error(_("read-only segment has dynamic relocations"));
      else if (parameters->options().warn_shared_textrel()
	       && parameters->options().shared())
	gold_warning(_("shared library text segment is not shareable"));
    }
  if (parameters->options().shared() && this->has_static_tls())
    flags |= elfcpp::DF_STATIC_TLS;
  if (parameters->options().origin())
    flags |= elfcpp::DF_ORIGIN;
  if (parameters->options().Bsymbolic())
    {
      flags |= elfcpp::DF_SYMBOLIC;
      // Add DT_SYMBOLIC for compatibility with older loaders.
      odyn->add_constant(elfcpp::DT_SYMBOLIC, 0);
    }
  if (parameters->options().now())
    flags |= elfcpp::DF_BIND_NOW;
  if (flags != 0)
    odyn->add_constant(elfcpp::DT_FLAGS, flags);

  flags = 0;
  if (parameters->options().initfirst())
    flags |= elfcpp::DF_1_INITFIRST;
  if (parameters->options().interpose())
    flags |= elfcpp::DF_1_INTERPOSE;
  if (parameters->options().loadfltr())
    flags |= elfcpp::DF_1_LOADFLTR;
  if (parameters->options().nodefaultlib())
    flags |= elfcpp::DF_1_NODEFLIB;
  if (parameters->options().nodelete())
    flags |= elfcpp::DF_1_NODELETE;
  if (parameters->options().nodlopen())
    flags |= elfcpp::DF_1_NOOPEN;
  if (parameters->options().nodump())
    flags |= elfcpp::DF_1_NODUMP;
  if (!parameters->options().shared())
    flags &= ~(elfcpp::DF_1_INITFIRST
	       | elfcpp::DF_1_NODELETE
	       | elfcpp::DF_1_NOOPEN);
  if (parameters->options().origin())
    flags |= elfcpp::DF_1_ORIGIN;
  if (parameters->options().now())
    flags |= elfcpp::DF_1_NOW;
  if (parameters->options().Bgroup())
    flags |= elfcpp::DF_1_GROUP;
  if (flags != 0)
    odyn->add_constant(elfcpp::DT_FLAGS_1, flags);
}

// Set the size of the _DYNAMIC symbol table to be the size of the
// dynamic data.

void
Layout::set_dynamic_symbol_size(const Symbol_table* symtab)
{
  Output_data_dynamic* const odyn = this->dynamic_data_;
  if (odyn == NULL)
    return;
  odyn->finalize_data_size();
  if (this->dynamic_symbol_ == NULL)
    return;
  off_t data_size = odyn->data_size();
  const int size = parameters->target().get_size();
  if (size == 32)
    symtab->get_sized_symbol<32>(this->dynamic_symbol_)->set_symsize(data_size);
  else if (size == 64)
    symtab->get_sized_symbol<64>(this->dynamic_symbol_)->set_symsize(data_size);
  else
    gold_unreachable();
}

// The mapping of input section name prefixes to output section names.
// In some cases one prefix is itself a prefix of another prefix; in
// such a case the longer prefix must come first.  These prefixes are
// based on the GNU linker default ELF linker script.

#define MAPPING_INIT(f, t) { f, sizeof(f) - 1, t, sizeof(t) - 1 }
#define MAPPING_INIT_EXACT(f, t) { f, 0, t, sizeof(t) - 1 }
const Layout::Section_name_mapping Layout::section_name_mapping[] =
{
  MAPPING_INIT(".text.", ".text"),
  MAPPING_INIT(".rodata.", ".rodata"),
  MAPPING_INIT(".data.rel.ro.local.", ".data.rel.ro.local"),
  MAPPING_INIT_EXACT(".data.rel.ro.local", ".data.rel.ro.local"),
  MAPPING_INIT(".data.rel.ro.", ".data.rel.ro"),
  MAPPING_INIT_EXACT(".data.rel.ro", ".data.rel.ro"),
  MAPPING_INIT(".data.", ".data"),
  MAPPING_INIT(".bss.", ".bss"),
  MAPPING_INIT(".tdata.", ".tdata"),
  MAPPING_INIT(".tbss.", ".tbss"),
  MAPPING_INIT(".init_array.", ".init_array"),
  MAPPING_INIT(".fini_array.", ".fini_array"),
  MAPPING_INIT(".sdata.", ".sdata"),
  MAPPING_INIT(".sbss.", ".sbss"),
  // FIXME: In the GNU linker, .sbss2 and .sdata2 are handled
  // differently depending on whether it is creating a shared library.
  MAPPING_INIT(".sdata2.", ".sdata"),
  MAPPING_INIT(".sbss2.", ".sbss"),
  MAPPING_INIT(".lrodata.", ".lrodata"),
  MAPPING_INIT(".ldata.", ".ldata"),
  MAPPING_INIT(".lbss.", ".lbss"),
  MAPPING_INIT(".gcc_except_table.", ".gcc_except_table"),
  MAPPING_INIT(".gnu.linkonce.d.rel.ro.local.", ".data.rel.ro.local"),
  MAPPING_INIT(".gnu.linkonce.d.rel.ro.", ".data.rel.ro"),
  MAPPING_INIT(".gnu.linkonce.t.", ".text"),
  MAPPING_INIT(".gnu.linkonce.r.", ".rodata"),
  MAPPING_INIT(".gnu.linkonce.d.", ".data"),
  MAPPING_INIT(".gnu.linkonce.b.", ".bss"),
  MAPPING_INIT(".gnu.linkonce.s.", ".sdata"),
  MAPPING_INIT(".gnu.linkonce.sb.", ".sbss"),
  MAPPING_INIT(".gnu.linkonce.s2.", ".sdata"),
  MAPPING_INIT(".gnu.linkonce.sb2.", ".sbss"),
  MAPPING_INIT(".gnu.linkonce.wi.", ".debug_info"),
  MAPPING_INIT(".gnu.linkonce.td.", ".tdata"),
  MAPPING_INIT(".gnu.linkonce.tb.", ".tbss"),
  MAPPING_INIT(".gnu.linkonce.lr.", ".lrodata"),
  MAPPING_INIT(".gnu.linkonce.l.", ".ldata"),
  MAPPING_INIT(".gnu.linkonce.lb.", ".lbss"),
  MAPPING_INIT(".ARM.extab", ".ARM.extab"),
  MAPPING_INIT(".gnu.linkonce.armextab.", ".ARM.extab"),
  MAPPING_INIT(".ARM.exidx", ".ARM.exidx"),
  MAPPING_INIT(".gnu.linkonce.armexidx.", ".ARM.exidx"),
};
#undef MAPPING_INIT
#undef MAPPING_INIT_EXACT

const int Layout::section_name_mapping_count =
  (sizeof(Layout::section_name_mapping)
   / sizeof(Layout::section_name_mapping[0]));

// Choose the output section name to use given an input section name.
// Set *PLEN to the length of the name.  *PLEN is initialized to the
// length of NAME.

const char*
Layout::output_section_name(const Relobj* relobj, const char* name,
			    size_t* plen)
{
  // gcc 4.3 generates the following sorts of section names when it
  // needs a section name specific to a function:
  //   .text.FN
  //   .rodata.FN
  //   .sdata2.FN
  //   .data.FN
  //   .data.rel.FN
  //   .data.rel.local.FN
  //   .data.rel.ro.FN
  //   .data.rel.ro.local.FN
  //   .sdata.FN
  //   .bss.FN
  //   .sbss.FN
  //   .tdata.FN
  //   .tbss.FN

  // The GNU linker maps all of those to the part before the .FN,
  // except that .data.rel.local.FN is mapped to .data, and
  // .data.rel.ro.local.FN is mapped to .data.rel.ro.  The sections
  // beginning with .data.rel.ro.local are grouped together.

  // For an anonymous namespace, the string FN can contain a '.'.

  // Also of interest: .rodata.strN.N, .rodata.cstN, both of which the
  // GNU linker maps to .rodata.

  // The .data.rel.ro sections are used with -z relro.  The sections
  // are recognized by name.  We use the same names that the GNU
  // linker does for these sections.

  // It is hard to handle this in a principled way, so we don't even
  // try.  We use a table of mappings.  If the input section name is
  // not found in the table, we simply use it as the output section
  // name.

  const Section_name_mapping* psnm = section_name_mapping;
  for (int i = 0; i < section_name_mapping_count; ++i, ++psnm)
    {
      if (psnm->fromlen > 0)
	{
	  if (strncmp(name, psnm->from, psnm->fromlen) == 0)
	    {
	      *plen = psnm->tolen;
	      return psnm->to;
	    }
	}
      else
	{
	  if (strcmp(name, psnm->from) == 0)
	    {
	      *plen = psnm->tolen;
	      return psnm->to;
	    }
	}
    }

  // As an additional complication, .ctors sections are output in
  // either .ctors or .init_array sections, and .dtors sections are
  // output in either .dtors or .fini_array sections.
  if (is_prefix_of(".ctors.", name) || is_prefix_of(".dtors.", name))
    {
      if (parameters->options().ctors_in_init_array())
	{
	  *plen = 11;
	  return name[1] == 'c' ? ".init_array" : ".fini_array";
	}
      else
	{
	  *plen = 6;
	  return name[1] == 'c' ? ".ctors" : ".dtors";
	}
    }
  if (parameters->options().ctors_in_init_array()
      && (strcmp(name, ".ctors") == 0 || strcmp(name, ".dtors") == 0))
    {
      // To make .init_array/.fini_array work with gcc we must exclude
      // .ctors and .dtors sections from the crtbegin and crtend
      // files.
      if (relobj == NULL
	  || (!Layout::match_file_name(relobj, "crtbegin")
	      && !Layout::match_file_name(relobj, "crtend")))
	{
	  *plen = 11;
	  return name[1] == 'c' ? ".init_array" : ".fini_array";
	}
    }

  return name;
}

// Return true if RELOBJ is an input file whose base name matches
// FILE_NAME.  The base name must have an extension of ".o", and must
// be exactly FILE_NAME.o or FILE_NAME, one character, ".o".  This is
// to match crtbegin.o as well as crtbeginS.o without getting confused
// by other possibilities.  Overall matching the file name this way is
// a dreadful hack, but the GNU linker does it in order to better
// support gcc, and we need to be compatible.

bool
Layout::match_file_name(const Relobj* relobj, const char* match)
{
  const std::string& file_name(relobj->name());
  const char* base_name = lbasename(file_name.c_str());
  size_t match_len = strlen(match);
  if (strncmp(base_name, match, match_len) != 0)
    return false;
  size_t base_len = strlen(base_name);
  if (base_len != match_len + 2 && base_len != match_len + 3)
    return false;
  return memcmp(base_name + base_len - 2, ".o", 2) == 0;
}

// Check if a comdat group or .gnu.linkonce section with the given
// NAME is selected for the link.  If there is already a section,
// *KEPT_SECTION is set to point to the existing section and the
// function returns false.  Otherwise, OBJECT, SHNDX, IS_COMDAT, and
// IS_GROUP_NAME are recorded for this NAME in the layout object,
// *KEPT_SECTION is set to the internal copy and the function returns
// true.

bool
Layout::find_or_add_kept_section(const std::string& name,
				 Relobj* object,
				 unsigned int shndx,
				 bool is_comdat,
				 bool is_group_name,
				 Kept_section** kept_section)
{
  // It's normal to see a couple of entries here, for the x86 thunk
  // sections.  If we see more than a few, we're linking a C++
  // program, and we resize to get more space to minimize rehashing.
  if (this->signatures_.size() > 4
      && !this->resized_signatures_)
    {
      reserve_unordered_map(&this->signatures_,
			    this->number_of_input_files_ * 64);
      this->resized_signatures_ = true;
    }

  Kept_section candidate;
  std::pair<Signatures::iterator, bool> ins =
    this->signatures_.insert(std::make_pair(name, candidate));

  if (kept_section != NULL)
    *kept_section = &ins.first->second;
  if (ins.second)
    {
      // This is the first time we've seen this signature.
      ins.first->second.set_object(object);
      ins.first->second.set_shndx(shndx);
      if (is_comdat)
	ins.first->second.set_is_comdat();
      if (is_group_name)
	ins.first->second.set_is_group_name();
      return true;
    }

  // We have already seen this signature.

  if (ins.first->second.is_group_name())
    {
      // We've already seen a real section group with this signature.
      // If the kept group is from a plugin object, and we're in the
      // replacement phase, accept the new one as a replacement.
      if (ins.first->second.object() == NULL
	  && parameters->options().plugins()->in_replacement_phase())
	{
	  ins.first->second.set_object(object);
	  ins.first->second.set_shndx(shndx);
	  return true;
	}
      return false;
    }
  else if (is_group_name)
    {
      // This is a real section group, and we've already seen a
      // linkonce section with this signature.  Record that we've seen
      // a section group, and don't include this section group.
      ins.first->second.set_is_group_name();
      return false;
    }
  else
    {
      // We've already seen a linkonce section and this is a linkonce
      // section.  These don't block each other--this may be the same
      // symbol name with different section types.
      return true;
    }
}

// Store the allocated sections into the section list.

void
Layout::get_allocated_sections(Section_list* section_list) const
{
  for (Section_list::const_iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    if (((*p)->flags() & elfcpp::SHF_ALLOC) != 0)
      section_list->push_back(*p);
}

// Store the executable sections into the section list.

void
Layout::get_executable_sections(Section_list* section_list) const
{
  for (Section_list::const_iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    if (((*p)->flags() & (elfcpp::SHF_ALLOC | elfcpp::SHF_EXECINSTR))
	== (elfcpp::SHF_ALLOC | elfcpp::SHF_EXECINSTR))
      section_list->push_back(*p);
}

// Create an output segment.

Output_segment*
Layout::make_output_segment(elfcpp::Elf_Word type, elfcpp::Elf_Word flags)
{
  gold_assert(!parameters->options().relocatable());
  Output_segment* oseg = new Output_segment(type, flags);
  this->segment_list_.push_back(oseg);

  if (type == elfcpp::PT_TLS)
    this->tls_segment_ = oseg;
  else if (type == elfcpp::PT_GNU_RELRO)
    this->relro_segment_ = oseg;
  else if (type == elfcpp::PT_INTERP)
    this->interp_segment_ = oseg;

  return oseg;
}

// Return the file offset of the normal symbol table.

off_t
Layout::symtab_section_offset() const
{
  if (this->symtab_section_ != NULL)
    return this->symtab_section_->offset();
  return 0;
}

// Return the section index of the normal symbol table.  It may have
// been stripped by the -s/--strip-all option.

unsigned int
Layout::symtab_section_shndx() const
{
  if (this->symtab_section_ != NULL)
    return this->symtab_section_->out_shndx();
  return 0;
}

// Write out the Output_sections.  Most won't have anything to write,
// since most of the data will come from input sections which are
// handled elsewhere.  But some Output_sections do have Output_data.

void
Layout::write_output_sections(Output_file* of) const
{
  for (Section_list::const_iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    {
      if (!(*p)->after_input_sections())
	(*p)->write(of);
    }
}

// Write out data not associated with a section or the symbol table.

void
Layout::write_data(const Symbol_table* symtab, Output_file* of) const
{
  if (!parameters->options().strip_all())
    {
      const Output_section* symtab_section = this->symtab_section_;
      for (Section_list::const_iterator p = this->section_list_.begin();
	   p != this->section_list_.end();
	   ++p)
	{
	  if ((*p)->needs_symtab_index())
	    {
	      gold_assert(symtab_section != NULL);
	      unsigned int index = (*p)->symtab_index();
	      gold_assert(index > 0 && index != -1U);
	      off_t off = (symtab_section->offset()
			   + index * symtab_section->entsize());
	      symtab->write_section_symbol(*p, this->symtab_xindex_, of, off);
	    }
	}
    }

  const Output_section* dynsym_section = this->dynsym_section_;
  for (Section_list::const_iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    {
      if ((*p)->needs_dynsym_index())
	{
	  gold_assert(dynsym_section != NULL);
	  unsigned int index = (*p)->dynsym_index();
	  gold_assert(index > 0 && index != -1U);
	  off_t off = (dynsym_section->offset()
		       + index * dynsym_section->entsize());
	  symtab->write_section_symbol(*p, this->dynsym_xindex_, of, off);
	}
    }

  // Write out the Output_data which are not in an Output_section.
  for (Data_list::const_iterator p = this->special_output_list_.begin();
       p != this->special_output_list_.end();
       ++p)
    (*p)->write(of);

  // Write out the Output_data which are not in an Output_section
  // and are regenerated in each iteration of relaxation.
  for (Data_list::const_iterator p = this->relax_output_list_.begin();
       p != this->relax_output_list_.end();
       ++p)
    (*p)->write(of);
}

// Write out the Output_sections which can only be written after the
// input sections are complete.

void
Layout::write_sections_after_input_sections(Output_file* of)
{
  // Determine the final section offsets, and thus the final output
  // file size.  Note we finalize the .shstrab last, to allow the
  // after_input_section sections to modify their section-names before
  // writing.
  if (this->any_postprocessing_sections_)
    {
      off_t off = this->output_file_size_;
      off = this->set_section_offsets(off, POSTPROCESSING_SECTIONS_PASS);

      // Now that we've finalized the names, we can finalize the shstrab.
      off =
	this->set_section_offsets(off,
				  STRTAB_AFTER_POSTPROCESSING_SECTIONS_PASS);

      if (off > this->output_file_size_)
	{
	  of->resize(off);
	  this->output_file_size_ = off;
	}
    }

  for (Section_list::const_iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    {
      if ((*p)->after_input_sections())
	(*p)->write(of);
    }

  this->section_headers_->write(of);
}

// Build IDs can be computed as a "flat" sha1 or md5 of a string of bytes,
// or as a "tree" where each chunk of the string is hashed and then those
// hashes are put into a (much smaller) string which is hashed with sha1.
// We compute a checksum over the entire file because that is simplest.

Task_token*
Layout::queue_build_id_tasks(Workqueue* workqueue, Task_token* build_id_blocker,
			     Output_file* of)
{
  const size_t filesize = (this->output_file_size() <= 0 ? 0
			   : static_cast<size_t>(this->output_file_size()));
  if (this->build_id_note_ != NULL
      && strcmp(parameters->options().build_id(), "tree") == 0
      && parameters->options().build_id_chunk_size_for_treehash() > 0
      && filesize > 0
      && (filesize >=
	  parameters->options().build_id_min_file_size_for_treehash()))
    {
      static const size_t MD5_OUTPUT_SIZE_IN_BYTES = 16;
      const size_t chunk_size =
	  parameters->options().build_id_chunk_size_for_treehash();
      const size_t num_hashes = ((filesize - 1) / chunk_size) + 1;
      Task_token* post_hash_tasks_blocker = new Task_token(true);
      post_hash_tasks_blocker->add_blockers(num_hashes);
      this->size_of_array_of_hashes_ = num_hashes * MD5_OUTPUT_SIZE_IN_BYTES;
      const unsigned char* src = of->get_input_view(0, filesize);
      this->input_view_ = src;
      unsigned char *dst = new unsigned char[this->size_of_array_of_hashes_];
      this->array_of_hashes_ = dst;
      for (size_t i = 0, src_offset = 0; i < num_hashes;
	   i++, dst += MD5_OUTPUT_SIZE_IN_BYTES, src_offset += chunk_size)
	{
	  size_t size = std::min(chunk_size, filesize - src_offset);
	  workqueue->queue(new Hash_task(src + src_offset,
					 size,
					 dst,
					 build_id_blocker,
					 post_hash_tasks_blocker));
	}
      return post_hash_tasks_blocker;
    }
  return build_id_blocker;
}

// If a tree-style build ID was requested, the parallel part of that computation
// is already done, and the final hash-of-hashes is computed here.  For other
// types of build IDs, all the work is done here.

void
Layout::write_build_id(Output_file* of) const
{
  if (this->build_id_note_ == NULL)
    return;

  unsigned char* ov = of->get_output_view(this->build_id_note_->offset(),
					  this->build_id_note_->data_size());

  if (this->array_of_hashes_ == NULL)
    {
      const size_t output_file_size = this->output_file_size();
      const unsigned char* iv = of->get_input_view(0, output_file_size);
      const char* style = parameters->options().build_id();

      // If we get here with style == "tree" then the output must be
      // too small for chunking, and we use SHA-1 in that case.
      if ((strcmp(style, "sha1") == 0) || (strcmp(style, "tree") == 0))
	sha1_buffer(reinterpret_cast<const char*>(iv), output_file_size, ov);
      else if (strcmp(style, "md5") == 0)
	md5_buffer(reinterpret_cast<const char*>(iv), output_file_size, ov);
      else
	gold_unreachable();

      of->free_input_view(0, output_file_size, iv);
    }
  else
    {
      // Non-overlapping substrings of the output file have been hashed.
      // Compute SHA-1 hash of the hashes.
      sha1_buffer(reinterpret_cast<const char*>(this->array_of_hashes_),
		  this->size_of_array_of_hashes_, ov);
      delete[] this->array_of_hashes_;
      of->free_input_view(0, this->output_file_size(), this->input_view_);
    }

  of->write_output_view(this->build_id_note_->offset(),
			this->build_id_note_->data_size(),
			ov);
}

// Write out a binary file.  This is called after the link is
// complete.  IN is the temporary output file we used to generate the
// ELF code.  We simply walk through the segments, read them from
// their file offset in IN, and write them to their load address in
// the output file.  FIXME: with a bit more work, we could support
// S-records and/or Intel hex format here.

void
Layout::write_binary(Output_file* in) const
{
  gold_assert(parameters->options().oformat_enum()
	      == General_options::OBJECT_FORMAT_BINARY);

  // Get the size of the binary file.
  uint64_t max_load_address = 0;
  for (Segment_list::const_iterator p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
    {
      if ((*p)->type() == elfcpp::PT_LOAD && (*p)->filesz() > 0)
	{
	  uint64_t max_paddr = (*p)->paddr() + (*p)->filesz();
	  if (max_paddr > max_load_address)
	    max_load_address = max_paddr;
	}
    }

  Output_file out(parameters->options().output_file_name());
  out.open(max_load_address);

  for (Segment_list::const_iterator p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
    {
      if ((*p)->type() == elfcpp::PT_LOAD && (*p)->filesz() > 0)
	{
	  const unsigned char* vin = in->get_input_view((*p)->offset(),
							(*p)->filesz());
	  unsigned char* vout = out.get_output_view((*p)->paddr(),
						    (*p)->filesz());
	  memcpy(vout, vin, (*p)->filesz());
	  out.write_output_view((*p)->paddr(), (*p)->filesz(), vout);
	  in->free_input_view((*p)->offset(), (*p)->filesz(), vin);
	}
    }

  out.close();
}

// Print the output sections to the map file.

void
Layout::print_to_mapfile(Mapfile* mapfile) const
{
  for (Segment_list::const_iterator p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
    (*p)->print_sections_to_mapfile(mapfile);
}

// Print statistical information to stderr.  This is used for --stats.

void
Layout::print_stats() const
{
  this->namepool_.print_stats("section name pool");
  this->sympool_.print_stats("output symbol name pool");
  this->dynpool_.print_stats("dynamic name pool");

  for (Section_list::const_iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    (*p)->print_merge_stats();
}

// Write_sections_task methods.

// We can always run this task.

Task_token*
Write_sections_task::is_runnable()
{
  return NULL;
}

// We need to unlock both OUTPUT_SECTIONS_BLOCKER and FINAL_BLOCKER
// when finished.

void
Write_sections_task::locks(Task_locker* tl)
{
  tl->add(this, this->output_sections_blocker_);
  tl->add(this, this->final_blocker_);
}

// Run the task--write out the data.

void
Write_sections_task::run(Workqueue*)
{
  this->layout_->write_output_sections(this->of_);
}

// Write_data_task methods.

// We can always run this task.

Task_token*
Write_data_task::is_runnable()
{
  return NULL;
}

// We need to unlock FINAL_BLOCKER when finished.

void
Write_data_task::locks(Task_locker* tl)
{
  tl->add(this, this->final_blocker_);
}

// Run the task--write out the data.

void
Write_data_task::run(Workqueue*)
{
  this->layout_->write_data(this->symtab_, this->of_);
}

// Write_symbols_task methods.

// We can always run this task.

Task_token*
Write_symbols_task::is_runnable()
{
  return NULL;
}

// We need to unlock FINAL_BLOCKER when finished.

void
Write_symbols_task::locks(Task_locker* tl)
{
  tl->add(this, this->final_blocker_);
}

// Run the task--write out the symbols.

void
Write_symbols_task::run(Workqueue*)
{
  this->symtab_->write_globals(this->sympool_, this->dynpool_,
			       this->layout_->symtab_xindex(),
			       this->layout_->dynsym_xindex(), this->of_);
}

// Write_after_input_sections_task methods.

// We can only run this task after the input sections have completed.

Task_token*
Write_after_input_sections_task::is_runnable()
{
  if (this->input_sections_blocker_->is_blocked())
    return this->input_sections_blocker_;
  return NULL;
}

// We need to unlock FINAL_BLOCKER when finished.

void
Write_after_input_sections_task::locks(Task_locker* tl)
{
  tl->add(this, this->final_blocker_);
}

// Run the task.

void
Write_after_input_sections_task::run(Workqueue*)
{
  this->layout_->write_sections_after_input_sections(this->of_);
}

// Close_task_runner methods.

// Finish up the build ID computation, if necessary, and write a binary file,
// if necessary.  Then close the output file.

void
Close_task_runner::run(Workqueue*, const Task*)
{
  // At this point the multi-threaded part of the build ID computation,
  // if any, is done.  See queue_build_id_tasks().
  this->layout_->write_build_id(this->of_);

  // If we've been asked to create a binary file, we do so here.
  if (this->options_->oformat_enum() != General_options::OBJECT_FORMAT_ELF)
    this->layout_->write_binary(this->of_);

  this->of_->close();
}

// Instantiate the templates we need.  We could use the configure
// script to restrict this to only the ones for implemented targets.

#ifdef HAVE_TARGET_32_LITTLE
template
Output_section*
Layout::init_fixed_output_section<32, false>(
    const char* name,
    elfcpp::Shdr<32, false>& shdr);
#endif

#ifdef HAVE_TARGET_32_BIG
template
Output_section*
Layout::init_fixed_output_section<32, true>(
    const char* name,
    elfcpp::Shdr<32, true>& shdr);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
Output_section*
Layout::init_fixed_output_section<64, false>(
    const char* name,
    elfcpp::Shdr<64, false>& shdr);
#endif

#ifdef HAVE_TARGET_64_BIG
template
Output_section*
Layout::init_fixed_output_section<64, true>(
    const char* name,
    elfcpp::Shdr<64, true>& shdr);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
Output_section*
Layout::layout<32, false>(Sized_relobj_file<32, false>* object,
			  unsigned int shndx,
			  const char* name,
			  const elfcpp::Shdr<32, false>& shdr,
			  unsigned int, unsigned int, off_t*);
#endif

#ifdef HAVE_TARGET_32_BIG
template
Output_section*
Layout::layout<32, true>(Sized_relobj_file<32, true>* object,
			 unsigned int shndx,
			 const char* name,
			 const elfcpp::Shdr<32, true>& shdr,
			 unsigned int, unsigned int, off_t*);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
Output_section*
Layout::layout<64, false>(Sized_relobj_file<64, false>* object,
			  unsigned int shndx,
			  const char* name,
			  const elfcpp::Shdr<64, false>& shdr,
			  unsigned int, unsigned int, off_t*);
#endif

#ifdef HAVE_TARGET_64_BIG
template
Output_section*
Layout::layout<64, true>(Sized_relobj_file<64, true>* object,
			 unsigned int shndx,
			 const char* name,
			 const elfcpp::Shdr<64, true>& shdr,
			 unsigned int, unsigned int, off_t*);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
Output_section*
Layout::layout_reloc<32, false>(Sized_relobj_file<32, false>* object,
				unsigned int reloc_shndx,
				const elfcpp::Shdr<32, false>& shdr,
				Output_section* data_section,
				Relocatable_relocs* rr);
#endif

#ifdef HAVE_TARGET_32_BIG
template
Output_section*
Layout::layout_reloc<32, true>(Sized_relobj_file<32, true>* object,
			       unsigned int reloc_shndx,
			       const elfcpp::Shdr<32, true>& shdr,
			       Output_section* data_section,
			       Relocatable_relocs* rr);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
Output_section*
Layout::layout_reloc<64, false>(Sized_relobj_file<64, false>* object,
				unsigned int reloc_shndx,
				const elfcpp::Shdr<64, false>& shdr,
				Output_section* data_section,
				Relocatable_relocs* rr);
#endif

#ifdef HAVE_TARGET_64_BIG
template
Output_section*
Layout::layout_reloc<64, true>(Sized_relobj_file<64, true>* object,
			       unsigned int reloc_shndx,
			       const elfcpp::Shdr<64, true>& shdr,
			       Output_section* data_section,
			       Relocatable_relocs* rr);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Layout::layout_group<32, false>(Symbol_table* symtab,
				Sized_relobj_file<32, false>* object,
				unsigned int,
				const char* group_section_name,
				const char* signature,
				const elfcpp::Shdr<32, false>& shdr,
				elfcpp::Elf_Word flags,
				std::vector<unsigned int>* shndxes);
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Layout::layout_group<32, true>(Symbol_table* symtab,
			       Sized_relobj_file<32, true>* object,
			       unsigned int,
			       const char* group_section_name,
			       const char* signature,
			       const elfcpp::Shdr<32, true>& shdr,
			       elfcpp::Elf_Word flags,
			       std::vector<unsigned int>* shndxes);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Layout::layout_group<64, false>(Symbol_table* symtab,
				Sized_relobj_file<64, false>* object,
				unsigned int,
				const char* group_section_name,
				const char* signature,
				const elfcpp::Shdr<64, false>& shdr,
				elfcpp::Elf_Word flags,
				std::vector<unsigned int>* shndxes);
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Layout::layout_group<64, true>(Symbol_table* symtab,
			       Sized_relobj_file<64, true>* object,
			       unsigned int,
			       const char* group_section_name,
			       const char* signature,
			       const elfcpp::Shdr<64, true>& shdr,
			       elfcpp::Elf_Word flags,
			       std::vector<unsigned int>* shndxes);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
Output_section*
Layout::layout_eh_frame<32, false>(Sized_relobj_file<32, false>* object,
				   const unsigned char* symbols,
				   off_t symbols_size,
				   const unsigned char* symbol_names,
				   off_t symbol_names_size,
				   unsigned int shndx,
				   const elfcpp::Shdr<32, false>& shdr,
				   unsigned int reloc_shndx,
				   unsigned int reloc_type,
				   off_t* off);
#endif

#ifdef HAVE_TARGET_32_BIG
template
Output_section*
Layout::layout_eh_frame<32, true>(Sized_relobj_file<32, true>* object,
				  const unsigned char* symbols,
				  off_t symbols_size,
				  const unsigned char* symbol_names,
				  off_t symbol_names_size,
				  unsigned int shndx,
				  const elfcpp::Shdr<32, true>& shdr,
				  unsigned int reloc_shndx,
				  unsigned int reloc_type,
				  off_t* off);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
Output_section*
Layout::layout_eh_frame<64, false>(Sized_relobj_file<64, false>* object,
				   const unsigned char* symbols,
				   off_t symbols_size,
				   const unsigned char* symbol_names,
				   off_t symbol_names_size,
				   unsigned int shndx,
				   const elfcpp::Shdr<64, false>& shdr,
				   unsigned int reloc_shndx,
				   unsigned int reloc_type,
				   off_t* off);
#endif

#ifdef HAVE_TARGET_64_BIG
template
Output_section*
Layout::layout_eh_frame<64, true>(Sized_relobj_file<64, true>* object,
				  const unsigned char* symbols,
				  off_t symbols_size,
				  const unsigned char* symbol_names,
				  off_t symbol_names_size,
				  unsigned int shndx,
				  const elfcpp::Shdr<64, true>& shdr,
				  unsigned int reloc_shndx,
				  unsigned int reloc_type,
				  off_t* off);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Layout::add_to_gdb_index(bool is_type_unit,
			 Sized_relobj<32, false>* object,
			 const unsigned char* symbols,
			 off_t symbols_size,
			 unsigned int shndx,
			 unsigned int reloc_shndx,
			 unsigned int reloc_type);
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Layout::add_to_gdb_index(bool is_type_unit,
			 Sized_relobj<32, true>* object,
			 const unsigned char* symbols,
			 off_t symbols_size,
			 unsigned int shndx,
			 unsigned int reloc_shndx,
			 unsigned int reloc_type);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Layout::add_to_gdb_index(bool is_type_unit,
			 Sized_relobj<64, false>* object,
			 const unsigned char* symbols,
			 off_t symbols_size,
			 unsigned int shndx,
			 unsigned int reloc_shndx,
			 unsigned int reloc_type);
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Layout::add_to_gdb_index(bool is_type_unit,
			 Sized_relobj<64, true>* object,
			 const unsigned char* symbols,
			 off_t symbols_size,
			 unsigned int shndx,
			 unsigned int reloc_shndx,
			 unsigned int reloc_type);
#endif

} // End namespace gold.
@


1.256
log
@gold/
	* options.h (General_options): Add -Trodata-segment option.
	* parameters.cc (Parameters::check_rodata_segment): New function.
	(Parameters::set_target_once): Call it.
	* parameters.h (Parameters): Declare it (private member function).
	* layout.cc (load_seg_unusable_for_headers): New function, broken
	out of Layout::relaxation_loop_body.  If TARGET->isolate_execinstr()
	then validate rodata segment rather than text segment.
	(relaxation_loop_body): Call that.
	(is_text_segment): New function.  Don't admit a non-executable
	segment if TARGET->isolate_execinstr().
	(set_segment_offsets): Call it.  Honor -Trodata-segment option.
@
text
@d296 2
a297 1
    const Layout::Data_list& special_outputs)
d308 2
d434 1
d2348 14
d2384 2
a2385 1
	this->section_list_, this->special_output_list_);
d3562 2
a3563 1
	  uint64_t new_addr = (*p)->set_section_addresses(this, false, addr,
d3604 2
a3605 1
		  new_addr = (*p)->set_section_addresses(this, true, addr,
d3641 2
d3656 2
a3657 2
	      uint64_t new_addr = (*p)->set_section_addresses(this, true,
							      old_addr,
d5294 7
@


1.255
log
@2013-06-05  Alexander Ivchenko  <alexander.ivchenko@@intel.com>

gold/
	* layout.cc (Layout::set_segment_offsets): Taking care of the case when
	the maximum segment alignment is larger than the page size.
	* testsuite/Makefile.am (large_symbol_alignment): Test that Gold
	correctly aligns the symbols with large alignemnt.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/large_symbol_alignment.cc: New file.
@
text
@d2372 16
d2440 1
a2440 5
  // If the user set the address of the text segment, that may not be
  // compatible with putting the segment headers and file headers into
  // that segment.
  if (parameters->options().user_set_Ttext()
      && parameters->options().Ttext() % target->abi_pagesize() != 0)
d3334 14
d3440 6
a3445 1
		       || ((*p)->flags() & elfcpp::PF_W) == 0))
d3447 1
@


1.254
log
@2013-05-30  Alexander Ivchenko  <alexander.ivchenko@@intel.com>
	    Sriraman Tallam  <tmsriram@@google.com>

	* options.h (sort_section): New option.
	* output.h (Input_section_sort_section_prefix_special_ordering_compare):
	Rename from Input_section_sort_section_name_special_ordering_compare.
	(Input_section_sort_section_name_compare): New struct.
	* output.cc (Output_section::Input_section_sort_section_name_compare::
	operator()): New function.
	(Output_section::sort_attached_input_sections): Use new sort function
	for .text if --sort-section=name is specified.
	* layout.cc (Layout::make_output_section):
	Add sorting by name when --sort-section=name is specified.
	* testsuite/Makefile.am (text_section_grouping): Test option
	--sort-section=name.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/section_sorting_name.cc: New file.
	* testsuite/section_sorting_name.sh: New file.
@
text
@d3488 7
a3494 1
	    off = align_file_offset(off, addr, abi_pagesize);
@


1.253
log
@gold/
	* options.h (General_options): Add --rosegment-gap option.
	* options.cc (finalize): --rosegment-gap implies --rosegment.
	* layout.cc (set_segment_offsets): Let user option override
	target->rosegment_gap().
@
text
@d1712 4
@


1.252
log
@        gold/
        PR ld/15365
        * layout.cc (Layout::finalize): Make __ehdr_start STV_HIDDEN.

        ld/
        PR ld/15365
        * emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation):
        Restrict __ehdr_start's export class to no less than STV_HIDDEN.

        ld/testsuite/
        PR ld/15365
        * ld-elf/ehdr_start.d: Expect __ehdr_start to be STB_LOCAL.
        * ld-mips-elf/ehdr_start-1.nd: New test.
        * ld-mips-elf/ehdr_start-2.nd: New test.
        * ld-mips-elf/ehdr_start-1.ld: New test linker script.
        * ld-mips-elf/ehdr_start-2.ld: New test linker script.
        * ld-mips-elf/ehdr_start-new.s: New test source.
        * ld-mips-elf/ehdr_start-o32.s: New test source.
        * ld-mips-elf/mips-elf.exp: Run the new tests.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
d247 4
a250 4
            size_t size,
            unsigned char* dst,
            Task_token* build_id_blocker,
            Task_token* final_blocker)
d1101 1
a1101 1
  static const char* const text_section_sort[] = 
d1161 1
a1161 1
          os = this->choose_output_section(object, name, sh_type,
d1257 1
a1257 1
  gold_assert(this->unique_segment_for_sections_specified_); 
d1893 1
a1893 1
 	   p != this->segment_list_.end();
d1896 35
a1930 35
	  if ((*p)->type() != elfcpp::PT_LOAD)                        
	    continue;                        
	  if ((*p)->is_unique_segment())                        
	    continue;                        
	  if (!parameters->options().omagic()                        
	      && ((*p)->flags() & elfcpp::PF_W) != (seg_flags & elfcpp::PF_W))                        
	    continue;                        
	  if ((target->isolate_execinstr() || parameters->options().rosegment())                        
	      && ((*p)->flags() & elfcpp::PF_X) != (seg_flags & elfcpp::PF_X))                        
	    continue;                        
	  // If -Tbss was specified, we need to separate the data and BSS                        
	  // segments.                        
	  if (parameters->options().user_set_Tbss())                        
	    {                        
	      if ((os->type() == elfcpp::SHT_NOBITS)                        
	          == (*p)->has_any_data_sections())                        
	        continue;                        
	    }                        
	  if (os->is_large_data_section() && !(*p)->is_large_data_segment())                        
	    continue;                        
	                    
	  if (is_address_set)                        
	    {                        
	      if ((*p)->are_addresses_set())                        
	        continue;                        
	                    
	      (*p)->add_initial_output_data(os);                        
	      (*p)->update_flags_for_output_section(seg_flags);                        
	      (*p)->set_addresses(addr, addr);                        
	      break;                        
	    }                        
	                    
	  (*p)->add_output_section_to_load(this, os, seg_flags);                        
	  break;                        
	}                        
d3460 4
a3463 1
		  uint64_t min_addr = start_addr + target->rosegment_gap();
d5276 1
a5276 1
                             Output_file* of)
d5279 1
a5279 1
                           : static_cast<size_t>(this->output_file_size()));
d5285 1
a5285 1
          parameters->options().build_id_min_file_size_for_treehash()))
d5289 1
a5289 1
          parameters->options().build_id_chunk_size_for_treehash();
d5299 9
a5307 9
           i++, dst += MD5_OUTPUT_SIZE_IN_BYTES, src_offset += chunk_size)
        {
          size_t size = std::min(chunk_size, filesize - src_offset);
          workqueue->queue(new Hash_task(src + src_offset,
                                         size,
                                         dst,
                                         build_id_blocker,
                                         post_hash_tasks_blocker));
        }
d5324 1
a5324 1
                                          this->build_id_note_->data_size());
d5335 1
a5335 1
        sha1_buffer(reinterpret_cast<const char*>(iv), output_file_size, ov);
d5337 1
a5337 1
        md5_buffer(reinterpret_cast<const char*>(iv), output_file_size, ov);
d5339 1
a5339 1
        gold_unreachable();
d5348 1
a5348 1
                  this->size_of_array_of_hashes_, ov);
@


1.251
log
@2013-04-26  Geoff Pike  <gpike@@chromium.org>

gold/
	* gold.cc (queue_final_tasks): invoke layout->queue_build_id_tasks().
	* layout.cc (Hash_task): New class.
	(Layout::queue_build_id_tasks): New function.
	(Layout::write_build_id): Handle single-thread portion of build ID
	computation.  (In some cases, all of it is single-threaded.)  Replace
	{sha1,md5}_process_bytes with {sha1,md5}_buffer to get the same
	functionality in fewer lines of code.
	* layout.h (Layout::queue_build_id_tasks): New function declaration.
	* options.h (General_options): make "--build-id" default to tree
	rather than sha1.  Add two new options related to --build-id=tree:
	--build-id-chunk-size-for-treehash and
	--build-id-min-file-size-for-treehash.
	* Makefile.am: add testing of --build-id=tree and related new options
	(these tests will be invoked by "make check").
	* Makefile.in: Regenerate.
@
text
@d2716 1
a2716 1
				     elfcpp::STV_DEFAULT, 0,
@


1.250
log
@	PR gold/15355
	* layout.cc (Layout::segment_precedes): Allow more than one
	segment with the same type and flags.
@
text
@d239 48
d449 3
d2978 1
a2978 1
  else if (strcmp(style, "sha1") == 0)
d5266 47
a5312 3
// If the build ID requires computing a checksum, do so here, and
// write it out.  We compute a checksum over the entire file because
// that is simplest.
a5319 2
  const unsigned char* iv = of->get_input_view(0, this->output_file_size_);

d5321 1
a5321 1
					  this->build_id_note_->data_size());
d5323 1
a5323 2
  const char* style = parameters->options().build_id();
  if (strcmp(style, "sha1") == 0)
d5325 14
a5338 11
      sha1_ctx ctx;
      sha1_init_ctx(&ctx);
      sha1_process_bytes(iv, this->output_file_size_, &ctx);
      sha1_finish_ctx(&ctx, ov);
    }
  else if (strcmp(style, "md5") == 0)
    {
      md5_ctx ctx;
      md5_init_ctx(&ctx);
      md5_process_bytes(iv, this->output_file_size_, &ctx);
      md5_finish_ctx(&ctx, ov);
d5341 8
a5348 1
    gold_unreachable();
a5352 2

  of->free_input_view(0, this->output_file_size_, iv);
d5542 2
a5543 1
// Run the task--close the file.
d5548 2
a5549 1
  // If we need to compute a checksum for the BUILD if, we do so here.
@


1.249
log
@gold/
	* layout.cc (Layout::set_relocatable_section_offsets): Don't
	allocate space in file for BSS sections.
@
text
@d3178 2
a3179 1
  // be more than one segment with the same type and flags.
d3184 2
a3185 1
      gold_assert(flags1 != flags2);
@


1.248
log
@	* layout.cc (Layout::set_segment_offsets): Accept writable .text
	segment when omagic.
@
text
@d3597 2
a3598 1
      off += (*p)->data_size();
@


1.247
log
@	* dwp.cc (Dwp_output_file::add_contribution): Avoid signed/unsigned
	comparison warning.
	* layout.cc (Layout::create_dynamic_symtab): Avoid "may be used
	uninitialized" warning.
@
text
@d3356 2
a3357 1
		   && ((*p)->flags() & elfcpp::PF_W) == 0)
@


1.246
log
@	* gold.cc (queue_middle_tasks): Move detect_odr_violations..
	* layout.cc (Layout_task_runner::run): ..to here.
	* symtab.h (struct Symbol_location): Extract from..
	(class Symbol_table): ..here.
	* symtab.cc (Symbol_table::linenos_from_loc): Invoke function_location.
	* target.h (class Target): Add function_location and
	do_function_location functions.
	(class Sized_target): Add do_function_location.
	* object.h (class Sized_relobj_file): Move find_shdr..
	(class Object): ..to here.
	* object.cc: Likewise.  Update to suit.  Instantiate.
	(Sized_relobj_file::find_eh_frame): Update find_shdr call.
	* powerpc.cc (class Powerpc_dynobj): New.
	(Target_powerpc::do_function_location): New function.
	(Powerpc_relobj::do_find_special_sections): Update find_shdr call.
	(Powerpc_dynobj::do_read_symbols): New function.
	(Target_powerpc::do_make_elf_object): Make a Powerpc_dynobj.
@
text
@d4161 1
a4161 1

a4176 2

      *pdynstr = dynstr;
@


1.245
log
@Default text reordering fix with a flag to turn it off.

2013-01-24  Sriraman Tallam  <tmsriram@@google.com>

	* layout.cc (Layout::layout): Check for option text_reorder.
	(Layout::make_output_section): Ditto.
	* options.h (text_reorder): New option.
	* output.cc (Input_section_sort_compare): Remove special ordering
	of section names.
	(Output_section::
	 Input_section_sort_section_name_special_ordering_compare::
	 operator()): New function.
	(Output_section::sort_attached_input_sections): Use new sort function
	for .text.
	* output.h (Input_section_sort_section_name_special_ordering_compare):
	New struct.
	* testsuite/Makefile.am (text_section_grouping): Test option
	--no-text-reorder
	* testsuite/Makefile.in: Regenerate.
	* testsuite/text_section_grouping.sh: Check order of functions without
	default text reordering.
@
text
@d320 4
@


1.244
log
@ld: change --enable-new-dtags to only generate new dtags

The "new" dtags options have been around for 14+ years, so there
shouldn't be a need to generate both new & old tags anymore.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d1152 2
a1153 1
  if (!this->script_options_->saw_sections_clause()
d1650 2
a1651 1
  if (!this->script_options_->saw_sections_clause()
@


1.243
log
@2013-01-16  Sriraman Tallam  <tmsriram@@google.com>

	* layout.cc (Layout::layout): Do not do default sorting for
	text sections when section ordering is specified.
	(make_output_section): Ditto.
	* testsuite/plugin_final_layout.cc: Name the function sections
	to catch reordering issues.
@
text
@d4650 3
a4652 2
      odyn->add_string(elfcpp::DT_RPATH, rpath_val);
      if (parameters->options().enable_new_dtags())
@


1.242
log
@	* layout.cc (Layout::special_ordering_of_input_section): New
	function.
	(Layout::layout): If input section requires special ordering, must
	sort input sections.
	(Layout::make_output_section): May sort .text input sections.
	(Layout::is_section_name_prefix_grouped): Remove.
	* layout.h (class Layout): Declare
	special_ordering_of_input_section.  Don't declare
	is_section_name_prefix_grouped.
	* output.cc (Output_section::add_input_section): Revert last
	change.
	(Output_section::Input_section_sort::match_file_name): Don't crash
	if called on output section data.
	(Output_section::Input_section_sort_compare): Sort based on
	special ordering.
	(Output_section::Input_section_sort_section_order_index_compare):
	Revert last patch.
	(Output_section::sort_attached_input_sections): Likewise.
@
text
@d1153 1
d1650 1
@


1.241
log
@Group text sections with prefixes .text.unlikely,.text.hot and .text.startup
by default.


2012-12-18  Sriraman Tallam  <tmsriram@@google.com>

	* layout.cc (Layout::is_section_name_prefix_grouped): New function.
	* layout.h (Layout::is_section_name_prefix_grouped): New function.
	* output.cc (Output_section::add_input_section): Check if section
	name contains special prefix.  Keep input sections to sort such
	sections.
	(Output_section::Input_section_sort_section_order_index_compare
	 ::operator()): Group sections according to prefixes.
	* (Output_section::sort_attached_input_sections): Add condition
	to Input_section_entry constructor call.
	* testsuite/Makefile.am (text_section_grouping): New test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/text_section_grouping.cc: New file.
	* testsuite/text_section_grouping.sh: New file.
@
text
@d1036 27
d1150 7
d1644 9
a2454 14
// By default, gold groups input sections with certain prefixes.  This 
// function returns true if this section name NAME contains such a prefix.

bool
Layout::is_section_name_prefix_grouped(const char *name)
{
  if (is_prefix_of(".text.unlikely", name)
      || is_prefix_of(".text.startup", name)
      || is_prefix_of(".text.hot", name))
    return true;

  return false;
}

@


1.240
log
@	* layout.h (Layout::get_executable_sections): Declare.
	* layout.cc (Layout::get_executable_sections): New function.
	* arm.cc (Target_arm::group_sections): Use it.
	(Arm_output_section::group_sections): Delete now redundant test.
	* output.cc (Output_reloc::Output_reloc): Add is_relative.
	param to handle relative relocs.
	* output.h (Output_reloc::Output_reloc <absolute reloc>): Likewise.
	(Output_data_reloc::add_absolute): Adjust.
	(Output_data_reloc::add_relative): New function.
	(Output_data::reset_data_size): New function.
	(Output_relaxed_input_section::set_relobj, set_shndx): New functions.
	(Output_section::set_addralign): New function.
	(Output_section::checkpoint_set_addralign): New function.
	(Output_section::clear_section_offsets_need_adjustment): New function.
	(Output_section::input_sections): Make public.
	* powerpc.cc (class Output_data_brlt_powerpc): New.
	(class Stub_table, class Stub_control): New.
	(Powerpc_relobj::has14_, set_has_14bit_branch, has_14bit_branch,
	stub_table_, set_stub_table, stub_table): New vectors and accessor
	functions.
	(Target_powerpc::do_may_relax, do_relax, push_branch,
	new_stub_table, stub_tables, brlt_section, group_sections,
	add_branch_lookup_table, find_branch_lookup_table,
	write_branch_lookup_table, make_brlt_section): New functions.
	(Target_powerpc::struct Sort_sections, class Branch_info): New.
	(Target_powerpc::brlt_section_, stub_tables_, branch_lookup_table_,
	branch_info_): New vars.
	(Target_powerpc::make_plt_entry, make_local_ifunc_plt_entry): Don't
	make call stubs here.
	(Output_data_glink): Remove all call stub handling from this class.
	(Target_powerpc::Scan::local, global): Save interesting branch
	relocs and relocs for ifunc.  Adjust calls to plt entry functions.
	(Target_powerpc::do_finalize_sections): Only make reg save/restore
	functions on final link.
	(Target_powerpc::Relocate::relocate): Adjust lookup of call stubs.
	Handle long branch destinations too.
	(Target_powerpc::do_dynsym_value, do_plt_address_for_global,
	do_plt_address_for_local): Adjust lookup of plt call stubs.
@
text
@d2412 14
@


1.239
log
@2012-10-16  Sriraman Tallam  <tmsriram@@google.com>

	* layout.cc (Layout::include_section): Keep sections marked
	SHF_EXCLUDE when doing relocatable links.
@
text
@d5007 13
@


1.238
log
@	PR gold/14566
	* layout.cc (Layout::set_segment_offsets): When using
	common-page-size alignment, ensure we are on a new max-page-size
	page.
	* output.cc (Output_segment::set_section_addresses): Use
	abi_pagesize, not common_pagesize for relro boundary.
	(Output_segment::set_offset): Likewise.
@
text
@d585 2
a586 1
  if (shdr.get_sh_flags() & elfcpp::SHF_EXCLUDE)
@


1.237
log
@	* layout.cc (Layout::set_segment_offsets): Set p_align to
	abi_pagesize, not common_pagesize.
	(Layout::relaxation_loop_body): Similarly use abi_pagesize
	to determine whether file header can go in segment.
@
text
@d3423 2
@


1.236
log
@Patch adds support to allow plugins to map selected subset of sections to unique
segments.


2012-08-24  Sriraman Tallam  <tmsriram@@google.com>

	* gold.cc (queue_middle_tasks): Call layout again when unique
	segments for sections is desired.
	* layout.cc (Layout::Layout): Initialize new members.
	(Layout::get_output_section_flags): New function.
	(Layout::choose_output_section): Call get_output_section_flags.
	(Layout::layout): Make output section for mapping to a unique segment.
	(Layout::insert_section_segment_map): New function.
	(Layout::attach_allocated_section_to_segment): Make unique segment for
	output sections marked so.
	(Layout::segment_precedes): Check for unique segments when sorting.
	* layout.h (Layout::Unique_segment_info): New struct.
	(Layout::Section_segment_map): New typedef.
	(Layout::insert_section_segment_map): New function.
	(Layout::get_output_section_flags): New function.
	(Layout::is_unique_segment_for_sections_specified): New function.
	(Layout::set_unique_segment_for_sections_specified): New function.
	(Layout::unique_segment_for_sections_specified_): New member.
	(Layout::section_segment_map_): New member.
	* object.cc (Sized_relobj_file<size, big_endian>::do_layout):
	Rename is_gc_pass_one to is_pass_one.
	Rename is_gc_pass_two to is_pass_two.
	Rename is_gc_or_icf to is_two_pass.
	Check for which pass based on whether symbols data is present.
	Make it two pass when unique segments for sections is desired.
	* output.cc (Output_section::Output_section): Initialize new
	members.
	* output.h (Output_section::is_unique_segment): New function.
	(Output_section::set_is_unique_segment): New function.
	(Output_section::is_unique_segment_): New member.
	(Output_section::extra_segment_flags): New function.
	(Output_section::set_extra_segment_flags): New function.
	(Output_section::extra_segment_flags_): New member.
	(Output_section::segment_alignment): New function.
	(Output_section::set_segment_alignment): New function.
	(Output_section::segment_alignment_): New member.
	(Output_segment::Output_segment): Initialize is_unique_segment_.
	(Output_segment::is_unique_segment): New function.
	(Output_segment::set_is_unique_segment): New function.
	(Output_segment::is_unique_segment_): New member.
	* plugin.cc (allow_unique_segment_for_sections): New function.
	(unique_segment_for_sections): New function.
	(Plugin::load): Add new functions to transfer vector.
	* Makefile.am (plugin_final_layout.readelf.stdout): Add readelf output.
	* Makefile.in: Regenerate.
	* testsuite/plugin_final_layout.sh: Check if unique segment
	functionality works.
	* testsuite/plugin_section_order.c (onload): Check if new interfaces
	are available.
	(allow_unique_segment_for_sections): New global.
	(unique_segment_for_sections): New global.
	(claim_file_hook): Call allow_unique_segment_for_sections.
	(all_symbols_read_hook): Call unique_segment_for_sections.


2012-08-24  Sriraman Tallam  <tmsriram@@google.com>

	* plugin-api.h (ld_plugin_allow_unique_segment_for_sections):
	New interface.
	(ld_plugin_unique_segment_for_sections): New interface.
	(LDPT_ALLOW_UNIQUE_SEGMENT_FOR_SECTIONS): New enum val.
	(LDPT_UNIQUE_SEGMENT_FOR_SECTIONS): New enum val.
	(tv_allow_unique_segment_for_sections): New member.
	(tv_unique_segment_for_sections): New member.
@
text
@d2321 1
a2321 1
      && parameters->options().Ttext() % target->common_pagesize() != 0)
d3333 1
a3333 1
	    (*p)->set_minimum_p_align(common_pagesize);
@


1.235
log
@2012-08-22  Cary Coutant  <ccoutant@@google.com>

gold/
	* layout.cc (Layout::include_section): Don't assert on GROUP
	sections with --emit-relocs.
@
text
@d411 1
d418 1
d829 21
d868 1
a868 11
  // Some flags in the input section should not be automatically
  // copied to the output section.
  flags &= ~ (elfcpp::SHF_INFO_LINK
	      | elfcpp::SHF_GROUP
	      | elfcpp::SHF_MERGE
	      | elfcpp::SHF_STRINGS);

  // We only clear the SHF_LINK_ORDER flag in for
  // a non-relocatable link.
  if (!parameters->options().relocatable())
    flags &= ~elfcpp::SHF_LINK_ORDER;
d1070 31
a1100 3
      os = this->choose_output_section(object, name, sh_type,
				       shdr.get_sh_flags(), true,
				       ORDER_INVALID, false);
d1160 9
d1771 4
d1787 1
a1787 3
  for (p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
d1789 3
a1791 20
      if ((*p)->type() != elfcpp::PT_LOAD)
	continue;
      if (!parameters->options().omagic()
	  && ((*p)->flags() & elfcpp::PF_W) != (seg_flags & elfcpp::PF_W))
	continue;
      if ((target->isolate_execinstr() || parameters->options().rosegment())
	  && ((*p)->flags() & elfcpp::PF_X) != (seg_flags & elfcpp::PF_X))
	continue;
      // If -Tbss was specified, we need to separate the data and BSS
      // segments.
      if (parameters->options().user_set_Tbss())
	{
	  if ((os->type() == elfcpp::SHT_NOBITS)
	      == (*p)->has_any_data_sections())
	    continue;
	}
      if (os->is_large_data_section() && !(*p)->is_large_data_segment())
	continue;

      if (is_address_set)
d1793 35
a1827 11
	  if ((*p)->are_addresses_set())
	    continue;

	  (*p)->add_initial_output_data(os);
	  (*p)->update_flags_for_output_section(seg_flags);
	  (*p)->set_addresses(addr, addr);
	  break;
	}

      (*p)->add_output_section_to_load(this, os, seg_flags);
      break;
d1830 2
a1831 1
  if (p == this->segment_list_.end())
d1840 8
d3192 2
a3193 1
  // script or overlapping --section-start options.
d3195 2
a3196 1
	      || parameters->options().any_section_start());
@


1.234
log
@	PR ld/14265
	* script-sections.cc (Sections_element::output_section_name): Add
	keep return parameter.
	(Output_section_element::match_name): Add keep return parameter.
	Return the value of the keep_ member.
	* script-sections.h (class Output_section): Update
	output_section_name prototype.
	* layout.cc (Layout::keep_input_section): New public member
	function.
	(Layout::choose_output_section): Pass keep parameter to
	output_section_name.
	* layout.h (class Layout): Add keep_input_section.
	* object.cc (Sized_relobj_file::do_layout): Check for kept input
	sections.
	* testsuite/Makefile.am: Add a test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/pr14265.c: Source file for the test.
	* testsuite/pr14265.t: Linker script for the test.
	* testsuite/pr14265.sh: Shell script for the test.

	* ld-gc/gc.exp: Add a new test.
	* ld-gc/pr14265.c: Source file for the new test.
	* ld-gc/pr14265.t: Linker script for the new test.
	* ld-gc/pr14265.d: Expected symbol dump.
@
text
@d609 1
a609 2
      gold_assert(!parameters->options().relocatable()
		  && !parameters->options().emit_relocs());
@


1.233
log
@	* target.h (Target::output_section_name): New function.
	(Target::do_output_section_name): New function.
	* layout.cc (Layout::choose_output_section): Call the above.
	* powerpc.cc (Target_powerpc::do_output_section_name): New function.
@
text
@d808 20
d868 1
d870 2
a871 1
				     &script_section_type);
@


1.232
log
@	* layout.cc (Layout::add_target_dynamic_tags): If
	dynrel_includes_plt but no dyn_rel, emit dynamic reloc tags for
	plt_rel.
@
text
@d942 6
a947 1
    name = Layout::output_section_name(relobj, name, &len);
@


1.231
log
@gold/
	* layout.cc (finalize): Define __ehdr_start symbol if applicable.
@
text
@d4344 4
a4347 1
  if (dyn_rel != NULL && dyn_rel->output_section() != NULL)
d4349 2
d4352 6
a4357 5
				dyn_rel->output_section());
      if (plt_rel != NULL
	  && plt_rel->output_section() != NULL
	  && dynrel_includes_plt)
	odyn->add_section_size(use_rel ? elfcpp::DT_RELSZ : elfcpp::DT_RELASZ,
d4360 2
d4363 1
a4363 2
	odyn->add_section_size(use_rel ? elfcpp::DT_RELSZ : elfcpp::DT_RELASZ,
			       dyn_rel->output_section());
d4389 1
a4389 1
      if (parameters->options().combreloc())
@


1.231.2.1
log
@gold/
	* options.h (General_options): Add --rosegment-gap option.
	* options.cc (finalize): --rosegment-gap implies --rosegment.
	* layout.cc (set_segment_offsets): Let user option override
	target->rosegment_gap().
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
d3258 1
a3258 4
		  uint64_t min_addr =
		    start_addr + (parameters->options().user_set_rosegment_gap()
				  ? parameters->options().rosegment_gap()
				  : target->rosegment_gap());
@


1.231.2.2
log
@gold/
	* options.h (General_options): Add -Trodata-segment option.
	* parameters.cc (Parameters::check_rodata_segment): New function.
	(Parameters::set_target_once): Call it.
	* parameters.h (Parameters): Declare it (private member function).
	* layout.cc (load_seg_unusable_for_headers): New function, broken
	out of Layout::relaxation_loop_body.  If TARGET->isolate_execinstr()
	then validate rodata segment rather than text segment.
	(relaxation_loop_body): Call that.
	(is_text_segment): New function.  Don't admit a non-executable
	segment if TARGET->isolate_execinstr().
	(set_segment_offsets): Call it.  Honor -Trodata-segment option.
@
text
@a2170 16
// If the user set the address of the text segment, that may not be
// compatible with putting the segment headers and file headers into
// that segment.  For isolate_execinstr() targets, it's the rodata
// segment rather than text where we might put the headers.
static inline bool
load_seg_unusable_for_headers(const Target* target)
{
  const General_options& options = parameters->options();
  if (target->isolate_execinstr())
    return (options.user_set_Trodata_segment()
	    && options.Trodata_segment() % target->common_pagesize() != 0);
  else
    return (options.user_set_Ttext()
	    && options.Ttext() % target->common_pagesize() != 0);
}

d2223 5
a2227 1
  if (load_seg_unusable_for_headers(target))
a3116 14
// On targets where the text segment contains only executable code,
// a non-executable segment is never the text segment.

static inline bool
is_text_segment(const Target* target, const Output_segment* seg)
{
  elfcpp::Elf_Xword flags = seg->flags();
  if ((flags & elfcpp::PF_W) != 0)
    return false;
  if ((flags & elfcpp::PF_X) == 0)
    return !target->isolate_execinstr();
  return true;
}

d3208 1
a3208 7
		   && (parameters->options().omagic()
		       || is_text_segment(target, *p)))
	    {
	      are_addresses_set = true;
	    }
	  else if (parameters->options().user_set_Trodata_segment()
		   && ((*p)->flags() & (elfcpp::PF_W | elfcpp::PF_X)) == 0)
a3209 1
	      addr = parameters->options().Trodata_segment();
@


1.231.2.3
log
@gold/
	* output.cc (Output_segment::set_section_addresses): Take new
	Target* argument.  If target->isolate_execinstr() and the segment
	is executable and starts at a target->abi_pagesize() boundary,
	pad its end out to a target->abi_pagesize() boundary with code fill.
	* output.h (Output_segment::set_section_addresses): Update decl.
	* layout.h (Layout::check_output_data_for_reset_values): Take new
	argument RELAX_OUTPUTS.
	(Layout): New member relax_output_list_.
	(Layout::add_relax_output): New method.
	* layout.cc (Layout::Layout): Update constructor.
	(Layout::reset_relax_output): New method.
	(Layout::clean_up_after_relaxation): Call it.
	(Layout::prepare_for_relaxation): Update caller.
	(Layout::set_segment_offsets): Update callers of set_section_addresses.
	Call reset_relax_output before re-processing segments for
	isolate_execinstr case.
	(Layout::write_data): Handle relax_output_list_.
	(Layout::Relaxation_debug_check::check_output_data_for_reset_values):
	Take new argument RELAX_OUTPUTS.  Assert it's an empty collection.
@
text
@d248 1
a248 2
    const Layout::Data_list& special_outputs,
    const Layout::Data_list& relax_outputs)
a258 2

  gold_assert(relax_outputs.empty());
a378 1
    relax_output_list_(),
a2142 14

  // Special-case fill output objects are recreated each time through
  // the relaxation loop.
  this->reset_relax_output();
}

void
Layout::reset_relax_output()
{
  for (Data_list::const_iterator p = this->relax_output_list_.begin();
       p != this->relax_output_list_.end();
       ++p)
    delete *p;
  this->relax_output_list_.clear();
d2165 1
a2165 2
	this->section_list_, this->special_output_list_,
	this->relax_output_list_);
d3332 1
a3332 2
	  uint64_t new_addr = (*p)->set_section_addresses(target, this,
							  false, addr,
d3371 1
a3371 2
		  new_addr = (*p)->set_section_addresses(target, this,
							 true, addr,
a3406 2
      this->reset_relax_output();

d3420 2
a3421 2
	      uint64_t new_addr = (*p)->set_section_addresses(target, this,
							      true, old_addr,
a5037 7

  // Write out the Output_data which are not in an Output_section
  // and are regenerated in each iteration of relaxation.
  for (Data_list::const_iterator p = this->relax_output_list_.begin();
       p != this->relax_output_list_.end();
       ++p)
    (*p)->write(of);
@


1.230
log
@gold/
	* layout.cc (gdb_sections): Remove ".debug_" prefixes,
	add .debug_macro.
	(lines_only_debug_sections): Likewise.
	(gdb_fast_lookup_sections): New static array.
	(is_gdb_debug_section): Rename formal parameter.
	(is_lines_only_debug_section): Likewise.
	(is_gdb_fast_lookup_section): New function.
	(Layout::include_section): Check for ".zdebug_" prefix; pass
	section name suffix to is_gdb_debug_section, et al.; check for
	fast-lookup sections when building .gdb_index.
	* options.h (--strip-debug-gdb): Update GDB version number.
@
text
@d2512 10
@


1.229
log
@gold/
	* layout.cc (Layout::section_name_mapping): Add rules to handle
	exact match on .data.rel.ro.local or .data.rel.ro.
	(Layout::output_section_name): Check for exact matches.
@
text
@d456 4
a459 3
// Returns whether the given section is in the list of
// debug-sections-used-by-some-version-of-gdb.  Currently,
// we've checked versions of gdb up to and including 7.4.
d462 15
a476 13
{ ".debug_abbrev",
  ".debug_addr",         // Fission extension
  // ".debug_aranges",   // not used by gdb as of 7.4
  ".debug_frame",
  ".debug_info",
  ".debug_types",
  ".debug_line",
  ".debug_loc",
  ".debug_macinfo",
  // ".debug_pubnames",  // not used by gdb as of 7.4
  // ".debug_pubtypes",  // not used by gdb as of 7.4
  ".debug_ranges",
  ".debug_str",
d479 2
d482 25
a506 13
{ ".debug_abbrev",
  // ".debug_addr",      // Fission extension
  // ".debug_aranges",   // not used by gdb as of 7.4
  // ".debug_frame",
  ".debug_info",
  // ".debug_types",
  ".debug_line",
  // ".debug_loc",
  // ".debug_macinfo",
  // ".debug_pubnames",  // not used by gdb as of 7.4
  // ".debug_pubtypes",  // not used by gdb as of 7.4
  // ".debug_ranges",
  ".debug_str",
d509 4
d514 1
a514 1
is_gdb_debug_section(const char* str)
d518 1
a518 1
    if (strcmp(str, gdb_sections[i]) == 0)
d523 2
d526 1
a526 1
is_lines_only_debug_section(const char* str)
d532 16
a547 1
    if (strcmp(str, lines_only_debug_sections[i]) == 0)
d624 5
a628 2
	  if (is_prefix_of(".debug", name)
	      && !is_lines_only_debug_section(name))
d635 17
a651 2
	  if (is_prefix_of(".debug", name)
	      && !is_gdb_debug_section(name))
@


1.228
log
@gold/
	* layout.cc (Layout::section_name_mapping): Match .data.rel.ro.*
	more carefully.
@
text
@d4572 1
d4578 1
d4580 1
d4619 1
d4671 1
a4671 1
      if (strncmp(name, psnm->from, psnm->fromlen) == 0)
d4673 13
a4685 2
	  *plen = psnm->tolen;
	  return psnm->to;
@


1.227
log
@gold/

	* layout.cc (Layout::make_output_section): Mark .tdata section
	as RELRO.
	* testsuite/relro_test.cc: Add a TLS variable.
@
text
@d4576 2
a4577 2
  MAPPING_INIT(".data.rel.ro.local", ".data.rel.ro.local"),
  MAPPING_INIT(".data.rel.ro", ".data.rel.ro"),
@


1.226
log
@gold/

	* layout.cc (gdb_sections): Update GDB version, add .debug_addr.
	(lines_only_debug_sections): Likewise.
@
text
@d1433 3
a1435 1
	  if (strcmp(name, ".data.rel.ro") == 0)
@


1.225
log
@	* configure.ac (ENABLE_GOLD): Consider *-*-nacl* targets ELF.
	* configure: Regenerate.

gold/
	* nacl.cc: New file.
	* nacl.h: New file.
	* Makefile.am (CCFILES, HFILES): Add them.
	* Makefile.in: Regenerate.
	* i386.cc (Output_data_plt_i386_nacl): New class.
	(Output_data_plt_i386_nacl_exec): New class.
	(Output_data_plt_i386_nacl_dyn): New class.
	(Target_i386_nacl): New class.
	(Target_selector_i386_nacl): New class.
	(target_selector_i386): Use it instead of Target_selector_i386.
	* x86_64.cc (Output_data_plt_x86_64_nacl): New class.
	(Target_x86_64_nacl): New class.
	(Target_selector_x86_64_nacl): New class.
	(target_selector_x86_64, target_selector_x32): Use it instead of
	Target_selector_x86_64.
	* arm.cc (Output_data_plt_arm_nacl): New class.
	(Target_arm_nacl): New class.
	(Target_selector_arm_nacl): New class.
	(target_selector_arm, target_selector_armbe): Use it instead of
	Target_selector_arm.

	* target-select.cc (select_target): Take new Input_file* and off_t
	arguments, pass them on to recognize method of selector.
	* object.cc (make_elf_sized_object): Update caller.
	* parameters.cc (parameters_force_valid_target): Likewise.
	* incremental.cc (make_sized_incremental_binary): Likewise.
	* target-select.h: Update decl.
	(Target_selector::recognize): Take new Input_file* argument,
	pass it on to do_recognize.
	(Target_selector::do_recognize): Take new Input_file* argument.
	* freebsd.h (Target_selector_freebsd::do_recognize): Likewise.
	* powerpc.cc (Target_selector_powerpc::do_recognize): Likewise.
	* sparc.cc (Target_selector_sparc::do_recognize): Likewise.
	* testsuite/testfile.cc (Target_selector::do_recognize): Likewise.

	* target.h (Target::Target_info): New members isolate_execinstr
	and rosegment_gap.
	(Target::isolate_execinstr, Target::rosegment_gap): New methods.
	* arm.cc (Target_arm::arm_info): Update initializer.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
	* sparc.cc (Target_sparc::sparc_info): Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
	* layout.cc (Layout::attach_allocated_section_to_segment):
	Take new const Target* argument.  If target->isolate_execinstr(), act
	like --rosegment.
	(Layout::find_first_load_seg): Take new const Target* argument;
	if target->isolate_execinstr(), reject PF_X segments.
	(Layout::relaxation_loop_body): Update caller.
	(Layout::set_segment_offsets): If target->isolate_execinstr(),
	reset file offset to zero when we hit LOAD_SEG, and then do a second
	loop over the segments before LOAD_SEG to reassign offsets after
	addresses have been determined.  Handle target->rosegment_gap().
	(Layout::attach_section_to_segment): Take new const Target* argument;
	pass it to attach_allocated_section_to_segment.
	(Layout::make_output_section): Update caller.
	(Layout::attach_sections_to_segments): Take new const Target* argument;
	pass it to attach_section_to_segment.
	* gold.cc (queue_middle_tasks): Update caller.
	* layout.h (Layout): Update method decls with new arguments.

	* arm.cc (Target_arm::Target_arm): Take optional argument for the
	Target_info pointer to use.
	(Target_arm::do_make_data_plt): New virtual method.
	(Target_arm::make_data_plt): New method that calls it.
	(Target_arm::make_plt_entry): Use it.
	(Output_data_plt_arm::Output_data_plt_arm): Take additional argument
	for the section alignment.
	(Output_data_plt_arm::do_first_plt_entry_offset): New abstract virtual
	method.
	(Output_data_plt_arm::first_plt_entry_offset): Call it.
	(Output_data_plt_arm::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_arm::get_plt_entry_size): Call it.
	(Output_data_plt_arm::do_fill_plt_entry): New abstract virtual method.
	(Output_data_plt_arm::fill_plt_entry): New method that calls it.
	(Output_data_plt_arm::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_arm::fill_first_plt_entry): New method that calls it.
	(Output_data_plt_arm::set_final_data_size): Use get_plt_entry_size
	method instead of sizeof(plt_entry).
	(Output_data_plt_arm::add_entry): Likewise.
	Use first_plt_entry_offset method instead of sizeof(first_plt_entry).
	(Target_arm::first_plt_entry_offset): Call method on this->plt_ rather
	than static method.
	(Target_arm::plt_entry_size): Likewise.
	(Output_data_plt_arm::first_plt_entry, Output_data_plt_arm::plt_entry):
	Move to ...
	(Output_data_plt_arm_standard): ... here, new class.
	(Output_data_plt_arm::do_write): Move guts of PLT filling to...
	(Output_data_plt_arm_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_arm_standard::do_fill_plt_entry): ... and here.

	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Take additional argument for the PLT entry size.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset):
	Use get_plt_entry_size method rather than plt_entry_size variable.
	(Output_data_plt_x86_64::reserve_slot): Likewise.
	(Output_data_plt_x86_64::do_adjust_output_section): Likewise.
	(Output_data_plt_x86_64::add_entry): Likewise.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Likewise.
	(Output_data_plt_x86_64::address_for_global): Likewise.
	(Output_data_plt_x86_64::address_for_local): Likewise.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::first_plt_entry_offset): Likewise.
	Make method non-static.
	(Output_data_plt_x86_64::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_x86_64::get_plt_entry_size): Just call that.
	(Output_data_plt_x86_64::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_x86_64::add_eh_frame): New method to call it.
	(Output_data_plt_x86_64::do_fill_first_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_first_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_tlsdesc_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_tlsdesc_entry): New method to call it.
	(Output_data_plt_x86_64::plt_entry_size)
	(Output_data_plt_x86_64::first_plt_entry)
	(Output_data_plt_x86_64::plt_entry)
	(Output_data_plt_x86_64::tlsdesc_plt_entry)
	(Output_data_plt_x86_64::plt_eh_frame_fde_size)
	(Output_data_plt_x86_64::plt_eh_frame_fde): Move to ...
	(Output_data_plt_x86_64_standard): ... here, new class.
	(Target_x86_64::Target_x86_64): Take optional argument for the
	Target_info pointer to use.
	(Target_x86_64::do_make_data_plt): New virtual method.
	(Target_x86_64::make_data_plt): New method to call it.
	(Target_x86_64::init_got_plt_for_update): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_x86_64::init):	Don't do add_eh_frame_for_plt here.
	(Target_x86_64::first_plt_entry_offset): Call method on this->plt_
	rather than static method.
	(Target_x86_64::plt_entry_size): Likewise.
	(Output_data_plt_x86_64::do_write): Use get_plt_entry_size method
	rather than plt_entry_size variable.  Move guts of PLT filling to...
	(Output_data_plt_x86_64_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_x86_64_standard::do_fill_plt_entry): ... and here ...
	(Output_data_plt_x86_64_standard::do_fill_tlsdesc_entry): ... and here.

	* i386.cc (Output_data_plt_i386::Output_data_plt_i386): Take
	additional argument for the section alignment.
	Don't do add_eh_frame_for_plt here.
	(Output_data_plt_i386::first_plt_entry_offset): Make the method
	non-static.  Use get_plt_entry_size method rather than plt_entry_size
	variable.
	(Output_data_plt_i386::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_i386::get_plt_entry_size): Call it.
	(Output_data_plt_i386::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_i386::add_eh_frame): New method to call it.
	(Output_data_plt_i386::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_first_plt_entry): New method to call it.
	(Output_data_plt_i386::do_fill_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_plt_entry): New method to call it.
	(Output_data_plt_i386::set_final_data_size): Use get_plt_entry_size
	method instead of plt_entry_size.
	(Output_data_plt_i386::plt_entry_size)
	(Output_data_plt_i386::plt_eh_frame_fde_size)
	(Output_data_plt_i386::plt_eh_frame_fde): Move to ...
	(Output_data_plt_i386_standard): ... here, new class.
	(Output_data_plt_i386_exec): New class.
	(Output_data_plt_i386::exec_first_plt_entry): Move to ...
	(Output_data_plt_i386_exec::first_plt_entry): ... here.
	(Output_data_plt_i386::exec_plt_entry): Move to ...
	(Output_data_plt_i386_exec::plt_entry): ... here.
	(Output_data_plt_i386_dyn): New class.
	(Output_data_plt_i386::first_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::first_plt_entry): ... here.
	(Output_data_plt_i386::dyn_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::plt_entry): ... here.
	(Target_i386::Target_i386): Take optional argument for the Target_info
	pointer to use.
	(Target_i386::do_make_data_plt): New virtual method.
	(Target_i386::make_data_plt): New method to call it.
	(Target_i386::make_plt_section): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_i386::add_entry): Use get_plt_entry_size method
	rather than plt_entry_size variable.
	(Output_data_plt_i386::add_local_ifunc_entry): Likewise.
	(Output_data_plt_i386::address_for_local): Likewise.
	(Output_data_plt_i386::do_write): Likewise.
	Move guts of PLT filling to...
	(Output_data_plt_i386_exec::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_i386_exec::do_fill_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_first_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_plt_entry): ... and here.

Change-Id: Id24b95600489835ff5e860a39c147203d4380c2b
@
text
@d458 1
a458 1
// we've checked versions of gdb up to and including 6.7.1.
d462 2
a463 1
  // ".debug_aranges",   // not used by gdb as of 6.7.1
d470 2
a471 1
  // ".debug_pubnames",  // not used by gdb as of 6.7.1
d478 2
a479 1
  // ".debug_aranges",   // not used by gdb as of 6.7.1
d486 2
a487 1
  // ".debug_pubnames",  // not used by gdb as of 6.7.1
@


1.224
log
@2012-03-21  Cary Coutant  <ccoutant@@google.com>

	* Makefile.am: Add gdb-index.cc, gdb-index.h.
	* Makefile.in: Regenerate.
	* dwarf_reader.cc (Sized_elf_reloc_mapper::do_initialize): New function.
	(Sized_elf_reloc_mapper::symbol_section): New function.
	(Sized_elf_reloc_mapper::do_get_reloc_target): New function.
	(make_elf_reloc_mapper): New function.
	(Dwarf_abbrev_table::clear_abbrev_codes): New function.
	(Dwarf_abbrev_table::do_read_abbrevs): New function.
	(Dwarf_abbrev_table::do_get_abbrev): New function.
	(Dwarf_ranges_table::read_ranges_table): New function.
	(Dwarf_ranges_table::read_range_list): New function.
	(Dwarf_pubnames_table::read_section): New function.
	(Dwarf_pubnames_table::read_header): New function.
	(Dwarf_pubnames_table::next_name): New function.
	(Dwarf_die::Dwarf_die): New function.
	(Dwarf_die::read_attributes): New function.
	(Dwarf_die::skip_attributes): New function.
	(Dwarf_die::set_name): New function.
	(Dwarf_die::set_linkage_name): New function.
	(Dwarf_die::attribute): New function.
	(Dwarf_die::string_attribute): New function.
	(Dwarf_die::int_attribute): New function.
	(Dwarf_die::uint_attribute): New function.
	(Dwarf_die::ref_attribute): New function.
	(Dwarf_die::child_offset): New function.
	(Dwarf_die::sibling_offset): New function.
	(Dwarf_info_reader::check_buffer): New function.
	(Dwarf_info_reader::parse): New function.
	(Dwarf_info_reader::do_parse): New function.
	(Dwarf_info_reader::do_read_string_table): New function.
	(Dwarf_info_reader::lookup_reloc): New function.
	(Dwarf_info_reader::get_string): New function.
	(Dwarf_info_reader::visit_compilation_unit): New function.
	(Dwarf_info_reader::visit_type_unit): New function.
	(Sized_dwarf_line_info::Sized_dwarf_line_info): Use
	Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::symbol_section): Remove function.
	(Sized_dwarf_line_info::read_relocs): Use Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::read_line_mappings): Remove object
	parameter, adjust callers.
	(Sized_dwarf_line_info::format_file_lineno): Fix type of cast.
	* dwarf_reader.h: Include <sys/types.h>.
	(class Track_relocs): Remove forward declaration.
	(class Elf_reloc_mapper): New class.
	(class Sized_elf_reloc_mapper): New class.
	(class Dwarf_abbrev_table): New class.
	(class Dwarf_range_list): New class.
	(class Dwarf_ranges_table): New class.
	(class Dwarf_pubnames_table): New class.
	(class Dwarf_die): New class.
	(class Dwarf_info_reader): New class.
	(Sized_dwarf_line_info::read_line_mappings): Remove object parameter.
	(Sized_dwarf_line_info::symbol_section): Remove member function.
	* dynobj.h (Sized_dynobj::do_section_contents): Refactor code from
	base class.
	* gdb-index.cc: New source file.
	* gdb-index.h: New source file.
	* incremental.cc (Sized_relobj_incr::do_layout): Track .debug_info
	and .debug_types sections, call Layout::add_to_gdb_index.
	(Sized_relobj_incr::do_section_name): Implement.
	(Sized_relobj_incr::do_section_contents): Adjust parameter list and
	return type; Implement.
	(Sized_incr_dynobj::do_section_contents): Adjust parameter list and
	return type.
	* incremental.h (Sized_relobj_incr::do_section_contents): Adjust
	parameter list and return type.
	(Sized_incr_dynobj::do_section_contents): Likewise.
	* layout.cc: Include gdb-index.h.
	(Layout::Layout): Initialize gdb_index_data_.
	(Layout::init_fixed_output_section): Check for .gdb_index section.
	(Layout::add_to_gdb_index): New function. Instantiate.
	* layout.h: Add forward declaration for class Gdb_index.
	(Layout::add_to_gdb_index): New member function.
	(Layout::gdb_index_data_): New data member.
	* main.cc: Include gdb-index.h.
	(main): Print statistics for gdb index.
	* object.cc (Object::section_contents): Move code into
	do_section_contents.
	(need_decompressed_section): Check for sections needed when building
	gdb index.
	(build_compressed_section_map): Likewise.
	(Sized_relobj_file::do_read_symbols): Need local symbols when building
	gdb index.
	(Sized_relobj_file::do_layout): Track .debug_info and .debug_types
	sections; call Layout::add_to_gdb_index.
	(Sized_relobj_file::do_decompressed_section_contents): Call
	do_section_contents directly.
	* object.h (Object::do_section_contents): Adjust parameter list and
	return type.
	(Object::do_decompressed_section_contents): Call do_section_contents
	directly.
	(Sized_relobj_file::do_section_contents): Adjust parameter list and
	return type.
	* options.h (class General_options): Add --gdb-index option.
	* plugin.cc (Sized_pluginobj::do_section_contents): Adjust parameter
	list and return type.
	* plugin.h (Sized_pluginobj::do_section_contents): Likewise.
	* reloc.h (Track_relocs::checkpoint): New function.
	(Track_relocs::reset): New function.

	* testsuite/Makefile.am (gdb_index_test_1.sh, gdb_index_test_2.sh):
	New test cases.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/gdb_index_test.cc: New test source file.
	* testsuite/gdb_index_test_1.sh: New test source file.
	* testsuite/gdb_index_test_2.sh: New test source file.
@
text
@d3 2
a4 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d159 3
a161 3
  	     "Free_list::allocate(%08lx, %d, %08lx)",
  	     static_cast<long>(len), static_cast<int>(align),
  	     static_cast<long>(minoff));
d226 1
a226 1
          program_name, Free_list::num_lists);
d228 1
a228 1
          program_name, Free_list::num_nodes);
d230 1
a230 1
          program_name, Free_list::num_removes);
d232 1
a232 1
          program_name, Free_list::num_remove_visits);
d234 1
a234 1
          program_name, Free_list::num_allocates);
d236 1
a236 1
          program_name, Free_list::num_allocate_visits);
d260 1
a260 1
  
d323 1
a323 1
                                     this->target_,
d353 2
a354 2
        layout->incremental_base()->apply_incremental_relocs(this->symtab_,
        						     this->layout_,
d583 1
a583 1
              && !is_lines_only_debug_section(name))
d591 1
a591 1
              && !is_gdb_debug_section(name))
d595 7
a601 7
          && !parameters->options().relocatable()
          && (shdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0)
        {
          // Ignore LTO sections containing intermediate code.
          if (is_prefix_of(".gnu.lto_", name))
            return false;
        }
d717 5
a721 5
          if (flags == 0)
            {
              Output_section* same_name = this->find_output_section(name);
              if (same_name != NULL
                  && (same_name->type() == elfcpp::SHT_PROGBITS
d725 7
a731 7
                  && (same_name->flags() & elfcpp::SHF_TLS) == 0)
                os = same_name;
            }
          else if ((flags & elfcpp::SHF_TLS) == 0)
            {
              elfcpp::Elf_Xword zero_flags = 0;
              const Key zero_key(name_key, std::make_pair(lookup_type,
d733 3
a735 3
              Section_name_map::iterator p =
                  this->section_name_map_.find(zero_key);
              if (p != this->section_name_map_.end())
d737 1
a737 1
            }
d929 1
a929 1
  						sh_flags, ORDER_INVALID, false);
d1325 1
a1325 1
        return;
d1383 2
a1384 2
           && parameters->options().strip_debug_non_line()
           && strcmp(".debug_abbrev", name) == 0)
d1387 1
a1387 1
          name, type, flags);
d1389 1
a1389 1
        this->debug_info_->set_abbreviations(this->debug_abbrev_);
d1392 2
a1393 2
           && parameters->options().strip_debug_non_line()
           && strcmp(".debug_info", name) == 0)
d1396 1
a1396 1
          name, type, flags);
d1398 1
a1398 1
        this->debug_info_->set_abbreviations(this->debug_abbrev_);
d1501 1
a1501 1
        os->set_free_space_fill(new Output_fill_debug_info(false));
d1503 1
a1503 1
        os->set_free_space_fill(new Output_fill_debug_info(true));
d1505 1
a1505 1
        os->set_free_space_fill(new Output_fill_debug_line());
d1512 1
a1512 1
    this->attach_section_to_segment(os);
d1589 1
a1589 1
Layout::attach_sections_to_segments()
d1594 1
a1594 1
    this->attach_section_to_segment(*p);
d1602 1
a1602 1
Layout::attach_section_to_segment(Output_section* os)
d1607 1
a1607 1
    this->attach_allocated_section_to_segment(os);
d1613 2
a1614 1
Layout::attach_allocated_section_to_segment(Output_section* os)
d1654 3
a1656 3
      if (parameters->options().rosegment()
          && ((*p)->flags() & elfcpp::PF_X) != (seg_flags & elfcpp::PF_X))
        continue;
d1686 1
a1686 1
                                                       seg_flags);
d1700 11
a1710 11
           p != segment_list_.end();
           ++p)
        {
          if ((*p)->type() == elfcpp::PT_NOTE
              && (((*p)->flags() & elfcpp::PF_W)
                  == (seg_flags & elfcpp::PF_W)))
            {
              (*p)->add_output_section_to_nonload(os, seg_flags);
              break;
            }
        }
d1713 5
a1717 5
        {
          Output_segment* oseg = this->make_output_segment(elfcpp::PT_NOTE,
                                                           seg_flags);
          oseg->add_output_section_to_nonload(os, seg_flags);
        }
d1888 1
a1888 1
                                       + name_string);
d1890 1
a1890 1
                                      + name_string);
d1956 1
a1956 1
Layout::find_first_load_seg()
d1966 7
a1972 5
	      || ((*p)->flags() & elfcpp::PF_W) == 0))
        {
          if (best == NULL || this->segment_precedes(*p, best))
            best = *p;
        }
d2030 1
a2030 1
	} 
d2033 1
a2033 1
	  list_iter = this->segment_list_.erase(list_iter); 
d2066 1
a2066 1
  
d2080 1
a2080 1
  this->script_output_section_data_list_.clear(); 
d2103 1
a2103 1
        this->section_list_, this->special_output_list_);
d2112 1
a2112 1
// section is required.  
d2122 2
a2123 2
// 
// PASS is the current relaxation pass number. 
d2155 1
a2155 1
    load_seg = this->find_first_load_seg();
d2212 1
a2212 1
        load_seg->add_initial_output_data(segment_headers);
d2214 1
a2214 1
        phdr_seg->add_initial_output_data(segment_headers);
d2275 5
a2279 5
         {
           map_it = this->input_section_position_.find(*it);
           gold_assert(map_it != this->input_section_position_.end());
           return map_it->second;
         }
d2297 1
a2297 1
               filename, strerror(errno));
d2306 1
a2306 1
        line.resize(line.length() - 1);
d2309 4
a2312 4
        {
          std::getline(in, line);
          continue;
        }
d2316 1
a2316 1
        this->input_section_glob_.push_back(line);
d2380 1
a2380 1
                        &this->dynpool_);
d2391 1
a2391 1
        this->create_interp(target);
d2410 1
a2410 1
  
d2429 1
a2429 1
  
d2438 1
a2438 1
  
d2880 2
a2881 2
                                                        elfcpp::SHT_STRTAB, 0,
                                                        ORDER_INVALID, false);
d3061 1
a3061 1
  uint64_t addr;
d3063 1
a3063 1
    addr = parameters->options().Ttext();
d3065 1
a3065 1
    addr = 0;
d3067 3
a3069 1
    addr = target->default_text_segment_address();
d3094 3
d3103 24
a3126 3
	  if (load_seg != NULL && load_seg != *p)
	    gold_unreachable();
	  load_seg = NULL;
d3178 22
a3199 2
	      if ((addr & (abi_pagesize - 1)) != 0)
                addr = addr + abi_pagesize;
d3201 2
a3202 1
	      off = orig_off + ((addr - orig_addr) & (abi_pagesize - 1));
d3208 1
a3208 1
	  else if (load_seg == NULL)
d3227 1
a3227 1
                                                          &off, pshndx);
d3266 1
a3266 1
                                                         &off, pshndx);
d3293 32
d3412 2
a3413 2
          && (*p)->after_input_sections())
        continue;
d3415 3
a3417 3
               && (!(*p)->after_input_sections()
                   || (*p)->type() == elfcpp::SHT_STRTAB))
        continue;
d3419 3
a3421 3
               && (!(*p)->after_input_sections()
                   || (*p)->type() != elfcpp::SHT_STRTAB))
        continue;
d3438 1
a3438 1
	        this->free_list_.dump();
d3463 1
a3463 1
        maxoff = off;
d3611 1
a3611 1
                                                        off, symtab);
d3705 1
a3705 1
          if (off == -1)
d3808 1
a3808 1
                              Symbol_table* symtab,
d4387 1
a4387 1
	odyn->add_section_size(elfcpp::DT_FINI_ARRAYSZ, *p); 
d4391 1
a4391 1
	odyn->add_section_size(elfcpp::DT_INIT_ARRAYSZ, *p); 
d4395 1
a4395 1
	odyn->add_section_size(elfcpp::DT_PREINIT_ARRAYSZ, *p); 
d4400 1
a4400 1
  
d4407 10
a4416 10
           p != rpath.end();
           ++p)
        {
          if (rpath_val.empty())
            rpath_val = p->name();
          else
            {
              // Eliminate duplicates.
              General_options::Dir_list::const_iterator q;
              for (q = rpath.begin(); q != p; ++q)
d4418 8
a4425 8
                  break;
              if (q == p)
                {
                  rpath_val += ':';
                  rpath_val += p->name();
                }
            }
        }
d4437 4
a4440 4
           p != this->segment_list_.end();
           ++p)
        {
          if ((*p)->type() == elfcpp::PT_LOAD
d4442 6
a4447 6
              && (*p)->has_dynamic_reloc())
            {
              have_textrel = true;
              break;
            }
        }
d4456 11
a4466 11
           p != this->section_list_.end();
           ++p)
        {
          if (((*p)->flags() & elfcpp::SHF_ALLOC) != 0
              && ((*p)->flags() & elfcpp::SHF_WRITE) == 0
              && (*p)->has_dynamic_reloc())
            {
              have_textrel = true;
              break;
            }
        }
d4738 1
a4738 1
                                 Kept_section** kept_section)
d4777 2
a4778 2
          && parameters->options().plugins()->in_replacement_phase())
        {
d4781 2
a4782 2
          return true;
        }
@


1.223
log
@	PR gold/13850
	* layout.cc (Layout::make_output_section): Correctly mark
	SHT_INIT_ARRAY, et. al., as relro.
@
text
@d47 1
d394 1
d910 7
d1304 32
d5341 48
@


1.222
log
@	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.
@
text
@a1381 1
      && type == elfcpp::SHT_PROGBITS
d1385 1
a1385 3
      if (strcmp(name, ".data.rel.ro") == 0)
	is_relro = true;
      else if (strcmp(name, ".data.rel.ro.local") == 0)
d1387 11
a1397 2
	  is_relro = true;
	  is_relro_local = true;
a1402 4
      else if (strcmp(name, ".ctors") == 0
	       || strcmp(name, ".dtors") == 0
	       || strcmp(name, ".jcr") == 0)
	is_relro = true;
@


1.221
log
@
2011-09-29 Sriraman Tallam  <tmsriram@@google.com>

	* layout.h (section_order_map_): New member.
	(get_section_order_map): New member function.
	* output.cc (Output_section::add_input_section): Check for patterns
	only when --section-ordering-file is specified.
	* gold.cc (queue_middle_tasks): Delay updating order of sections till
	output_sections have been formed.
	* layout.cc (Layout_Layout): Initialize section_order_map_.
	* plugin.cc (update_section_order): Store order in order_map. Do not
	update the order.
	* testsuite/Makefile.am: Add test case for plugin_final_layout.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_section_order.c: New file.
	* testsuite/plugin_final_layout.cc: New file.
	* testsuite/plugin_final_layout.sh: New file.
@
text
@d2979 3
a2981 2
  // script.
  gold_assert(this->script_options_->saw_phdrs_clause());
@


1.220
log
@	* incremental.cc (can_incremental_update): New function.
	* incremental.h (can_incremental_update): New function.
	* layout.cc (Layout::init_fixed_output_section): Call it.
	(Layout::make_output_section): Don't allow patch space in .eh_frame.
	* object.cc (Sized_relobj_file::do_layout): Call
	can_incremental_update.
@
text
@d413 1
@


1.220.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d2978 2
a2979 3
  // script or overlapping --section-start options.
  gold_assert(this->script_options_->saw_phdrs_clause()
	      || parameters->options().any_section_start());
@


1.219
log
@	* layout.cc (Free_list::allocate): Provide guarantee of minimum
	remaining hole size when allocating.
	(Layout::make_output_section): Set fill methods for debug sections.
	* layout.h (Free_list::Free_list_node): Move from private to
	public.
	(Free_list::set_min_hole_size): New function.
	(Free_list::begin, Free_list::end): New functions.
	(Free_list::min_hole_): New data member.
	* output.cc: Include dwarf.h.
	(Output_fill_debug_info::do_minimum_hole_size): New function.
	(Output_fill_debug_info::do_write): New function.
	(Output_fill_debug_line::do_minimum_hole_size): New function.
	(Output_fill_debug_line::do_write): New function.
	(Output_section::Output_section): Initialize new data member.
	(Output_section::set_final_data_size): Ensure patch space is larger
	than minimum hole size.
	(Output_section::do_write): Fill holes in debug sections.
	* output.h (Output_fill): New class.
	(Output_fill_debug_info): New class.
	(Output_fill_debug_line): New class.
	(Output_section::set_free_space_fill): New function.
	(Output_section::free_space_fill_): New data member.
	* testsuite/Makefile.am (incremental_test_3): Add
	--incremental-patch option.
	(incremental_test_4): Likewise.
	(incremental_test_5): Likewise.
	(incremental_test_6): Likewise.
	(incremental_copy_test): Likewise.
	(incremental_common_test_1): Likewise.
	* testsuite/Makefile.in: Regenerate.
@
text
@d901 2
a902 1
  // We preserve the layout of PROGBITS, NOBITS, and NOTE sections.
d904 1
a904 3
  if (sh_type != elfcpp::SHT_PROGBITS
      && sh_type != elfcpp::SHT_NOBITS
      && sh_type != elfcpp::SHT_NOTE)
d1444 1
@


1.218
log
@	* layout.cc (Layout::set_segment_offsets): Don't realign text
	segment if -Ttext was specified.
	* object.cc (Sized_relobj_file::Sized_relobj_file): Store the ELF
	file type.
	* object.h (Sized_relobj_file::e_type): New function.
	(Sized_relobj_file::e_type_): New data member.
	* symtab.cc (Symbol_table::add_from_relobj): Don't add section
	base address for ET_EXEC files.
	* target.cc (Target::do_make_elf_object_implementation): Allow
	ET_EXEC files with --just-symbols option.
@
text
@d165 5
d181 1
a181 1
      if (end <= p->end_)
d183 1
a183 1
	  if (p->start_ + 3 >= start && p->end_ <= end + 3)
d185 1
a185 1
	  else if (p->start_ + 3 >= start)
d187 1
a187 1
	  else if (p->end_ <= end + 3)
d1448 14
a1461 1
    os->set_is_patch_space_allowed();
@


1.217
log
@	* layout.cc (Layout::relaxation_loop_body): Only clear load_seg if
	the -Ttext option is not 0 modulo the page size.  If we clear
	load_seg, clear phdr_seg too.
	* testsuite/Makefile.am (check_PROGRAMS): Add flagstest_o_ttext_1.
	(flagstest_o_ttext_1): New target.
	(check_DATA): Add flagstest_o_ttext_2.
	(flagstest_o_ttext_2): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d3042 5
@


1.216
log
@2011-07-13  Sriraman Tallam  <tmsriram@@google.com>

	* plugin-api.h
	(ld_plugin_section): New struct.
	(ld_plugin_get_section_count): New typedef.
	(ld_plugin_get_section_type): New typedef.
	(ld_plugin_get_section_name): New typedef.
	(ld_plugin_get_section_contents): New typedef.
	(ld_plugin_update_section_order): New typedef.
	(ld_plugin_allow_section_ordering): New typedef.
	(LDPT_GET_SECTION_COUNT): New enum value.
	(LDPT_GET_SECTION_TYPE): New enum value.
	(LDPT_GET_SECTION_NAME): New enum value.
	(LDPT_GET_SECTION_CONTENTS): New enum value.
	(LDPT_UPDATE_SECTION_ORDER): New enum value.
	(LDPT_ALLOW_SECTION_ORDERING): New enum value.
	(tv_get_section_count): New struct members.
	(tv_get_section_type): New struct members.
	(tv_get_section_name): New struct members.
	(tv_get_section_contents): New struct members.
	(tv_update_section_order): New struct members.
	(tv_allow_section_ordering): New struct members.
	* archive.cc (Archive::get_elf_object_for_member): Add extra parameter
	to claim_file call.
	* layout.cc (Layout::Layout): Initialize section_ordering_specified_,
	input_section_position_, and input_section_glob_.
	(read_layout_from_file): Call function section_ordering_specified.
	* layout.h (is_section_ordering_specified): New function.
	(section_ordering_specified): New function.
	(section_ordering_specified_): New boolean member.
	* main.cc(main): Call load_plugins after layout object is defined.
	* output.cc (Output_section::add_input_section): Use
	function section_ordering_specified to check if section ordering is
	needed.
	* output.cc (Output_section::add_relaxed_input_section): Use
	function section_ordering_specified to check if section ordering is
	needed.
	(Output_section::update_section_layout): New function.
	(Output_section::sort_attached_input_sections): Check if input section
	must be reordered.
	* output.h (Output_section::update_section_layout): New function.
	* plugin.cc (get_section_count): New function.
	(get_section_type): New function.
	(get_section_name): New function.
	(get_section_contents): New function.
	(update_section_order): New function.
	(allow_section_ordering): New function.
	(Plugin::load): Add the new interfaces to the transfer vector.
	(Plugin_manager::load_plugins): New parameter.
	(Plugin_manager::all_symbols_read): New parameter.
	(Plugin_manager::claim_file): New parameter. Save the elf object for
	unclaimed objects.
	(Plugin_manager::get_elf_object): New function.
	(Plugin_manager::get_view): Change to directly use the bool to check
	if get_view is called from claim_file_hook.
	* plugin.h (input_objects): New function
	(Plugin__manager::load_plugins): New parameter.
	(Plugin_manager::claim_file): New parameter.
	(Plugin_manager::get_elf_object): New function.
	(Plugin_manager::in_claim_file_handler): New function.
	(Plugin_manager::in_claim_file_handler_): New member.
	(layout): New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Call the claim_file
	handler with an extra parameter. Make the elf object before calling
	claim_file handler.
	* testsuite/plugin_test.c (get_section_count): New function pointer.
	(get_section_type): New function pointer.
	(get_section_name): New function pointer.
	(get_section_contents): New function pointer.
	(update_section_order): New function pointer.
	(allow_section_ordering): New function pointer.
	(onload): Check if the new interfaces exist.
@
text
@d2098 6
a2103 2
  if (parameters->options().user_set_Ttext())
    load_seg = NULL;
@


1.215
log
@	PR gold/12979
	* options.h (class General_options): Add -Bgroup.
	* options.cc (General_options::finalize): If -Bgroup is set,
	default to --unresolved-symbols=report-all.
	* layout.cc (Layout::finish_dynamic_section): Implement -Bgroup.
	* target-reloc.h (issue_undefined_symbol_error): Handle
	--unresolved-symbols=report-all.
@
text
@d402 1
d408 2
d2215 1
a2215 1
// --section-ordering-file.
d2231 1
@


1.214
log
@	PR gold/11985
	* layout.cc (Layout::create_initial_dynamic_sections): Don't crash
	if linker script discards key sections.
	(Layout::create_dynamic_symtab): Likewise.
	(Layout::assign_local_dynsym_offsets): Likewise.
	(Layout::sized_create_version_sections): Likewise.
	(Layout::create_interp): Likewise.
	(Layout::finish_dynamic_section): Likewise.
	(Layout::set_dynamic_symbol_size): Likewise.
@
text
@d4373 2
@


1.213
log
@	PR gold/12372
	* target.h (Target::plt_address_for_global): New function.
	(Target::plt_address_for_local): New function.
	(Target::plt_section_for_global): Remove.
	(Target::plt_section_for_local): Remove.
	(Target::do_plt_address_for_global): New virtual function.
	(Target::do_plt_address_for_local): New virtual function.
	(Target::do_plt_section_for_global): Remove.
	(Target::do_plt_section_for_local): Remove.
	(Target::register_global_plt_entry): Add Symbol_table and Layout
	parameters.
	* output.cc (Output_data_got::Got_entry::write): Use
	plt_address_for_global and plt_address_for_local.
	* layout.cc (Layout::add_target_dynamic_tags): Use size and
	address of output section.
	* i386.cc (class Output_data_plt_i386): Add irelative_rel_,
	got_irelative_, and irelative_count_ fields.  Update
	declarations.
	(Output_data_plt_i386::has_irelative_section): New function.
	(Output_data_plt_i386::entry_count): Add irelative_count_.
	(Output_data_plt_i386::set_final_data_size): Likewise.
	(class Target_i386): Add got_irelative_ and rel_irelative_
	fields.  Update declarations.
	(Target_i386::Target_i386): Initialize new fields.
	(Target_i386::do_plt_address_for_global): New function replacing
	do_plt_section_for_global.
	(Target_i386::do_plt_address_for_local): New function replacing
	do_plt_section_for_local.
	(Target_i386::got_section): Create got_irelative_.
	(Target_i386::rel_irelative_section): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize new
	fields.  Don't define __rel_iplt_{start,end}.
	(Output_data_plt_i386::add_entry): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): Add symtab and
	layout parameters.  Change all callers.  Use different PLT and
	GOT.
	(Output_data_plt_i386::rel_tls_desc): Fix formatting.
	(Output_data_plt_i386::rel_irelative): New function.
	(Output_data_plt_i386::address_for_global): New function.
	(Output_data_plt_i386::address_for_local): New function.
	(Output_data_plt_i386::do_write): Write out IRELATIVE area.  Use
	IRELATIVE GOT when changing IFUNC GOT entries.
	(Target_i386::Scan::global): Use IRELATIVE GOT for IRELATIVE
	reloc.
	(Target_i386::do_finalize_sections): Create the __rel_iplt symbols
	if we didn't create an IRELATIVE GOT.
	(Target_i386::Relocate::relocate): Use plt_address_for_global and
	plt_address_for_local.
	(Target_i386::do_dynsym_value): Use plt_address_for_global.
	* x86_64.cc (class Output_data_plt_x86_64): Add irelative_rel_,
	got_irelative_, and irelative_count_ fields.  Update
	declarations.
	(Output_data_plt_x86_64::Output_data_plt_x86_64) [both versions]:
	Initialize new fields.  Remove symtab parameter.  Change all
	callers.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset): Add
	irelative_count_.
	(Output_data_plt_x86_64::has_irelative_section): New function.
	(Output_data_plt_x86_64::entry_count): Add irelative_count_.
	(class Target_x86_64): Add got_irelative_ and rel_irelative_
	fields.  Update declarations.
	(Target_x86_64::Target_x86_64): Initialize new fields.
	(Target_x86_64::do_plt_address_for_global): New function replacing
	do_plt_section_for_global.
	(Target_x86_64::do_plt_address_for_local): New function replacing
	do_plt_section_for_local.
	(Target_x86_64::got_section): Create got_irelative_.
	(Target_x86_64::rela_irelative_section): New function.
	(Output_data_plt_x86_64::init): Remove symtab parameter.  Change
	all callers.  Don't create __rel_iplt_{start,end}.
	(Output_data_plt_x86_64::add_entry): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Add symtab and
	layout parameters.  Change all callers.  Use different PLT and
	GOT.
	(Output_data_plt_x86_64::add_relocation): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_x86_64::rela_tlsdesc): Fix formatting.
	(Output_data_plt_x86_64::rela_irelative): New function.
	(Output_data_plt_x86_64::address_for_global): New function.
	(Output_data_plt_x86_64::address_for_local): New function.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::do_write): Write out IRELATIVE area.
	(Target_x86_64::init_got_plt_for_update): Create got_irelative_.
	(Target_x86_64::register_global_plt_entry): Add symtab and layout
	parameters.
	(Target_x86_64::Scan::global): Use IRELATIVE GOT for IRELATIVE
	reloc.
	(Target_x86_64::do_finalize_sections): Create the __rela_iplt
	symbols if we didn't create an IRELATIVE GOT.
	(Target_x86_64::Relocate::relocate): Use plt_address_for_global and
	plt_address_for_local.
	(Target_x86_64::do_dynsym_value): Use plt_address_for_global.
	* testsuite/ifuncvar1.c: New test file.
	* testsuite/ifuncvar2.c: New test file.
	* testsuite/ifuncvar3.c: New test file.
	* testsuite/Makefile.am (check_PROGRAMS): Add ifuncvar.
	(ifuncvar1_pic.o, ifuncvar2_pic.o, ifuncvar.so): New targets.
	(ifuncvar_SOURCES, ifuncvar_DEPENDENCIES): New variables.
	(ifuncvar_LDFLAGS, ifuncvar_LDADD): New variables.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1789 9
a1797 5
  this->dynamic_symbol_ =
    symtab->define_in_output_data("_DYNAMIC", NULL, Symbol_table::PREDEFINED,
				  this->dynamic_section_, 0, 0,
				  elfcpp::STT_OBJECT, elfcpp::STB_LOCAL,
				  elfcpp::STV_HIDDEN, 0, false, false);
d1799 1
a1799 1
  this->dynamic_data_ =  new Output_data_dynamic(&this->dynpool_);
d1801 2
a1802 1
  this->dynamic_section_->add_output_section_data(this->dynamic_data_);
d3716 11
a3726 8
  Output_section_data* odata = new Output_data_fixed_space(index * symsize,
							   align,
							   "** dynsym");
  dynsym->add_output_section_data(odata);

  dynsym->set_info(local_symcount);
  dynsym->set_entsize(symsize);
  dynsym->set_addralign(align);
d3728 2
a3729 1
  this->dynsym_section_ = dynsym;
d3732 5
a3736 2
  odyn->add_section_address(elfcpp::DT_SYMTAB, dynsym);
  odyn->add_constant(elfcpp::DT_SYMENT, symsize);
d3753 3
a3755 1
      this->dynsym_xindex_ = new Output_symtab_xindex(index);
d3757 1
a3757 1
      dynsym_xindex->add_output_section_data(this->dynsym_xindex_);
d3759 3
a3761 3
      dynsym_xindex->set_link_section(dynsym);
      dynsym_xindex->set_addralign(4);
      dynsym_xindex->set_entsize(4);
d3763 1
a3763 1
      dynsym_xindex->set_after_input_sections();
d3765 5
a3769 4
      // This tells the driver code to wait until the symbol table has
      // written out before writing out the postprocessing sections,
      // including the .dynsym_shndx section.
      this->any_postprocessing_sections_ = true;
d3781 4
a3784 2
  Output_section_data* strdata = new Output_data_strtab(&this->dynpool_);
  dynstr->add_output_section_data(strdata);
d3786 4
a3789 2
  dynsym->set_link_section(dynstr);
  this->dynamic_section_->set_link_section(dynstr);
d3791 5
a3795 2
  odyn->add_section_address(elfcpp::DT_STRTAB, dynstr);
  odyn->add_section_size(elfcpp::DT_STRSZ, dynstr);
d3797 2
a3798 1
  *pdynstr = dynstr;
d3819 2
a3820 1
      hashsec->add_output_section_data(hashdata);
d3822 6
a3827 2
      hashsec->set_link_section(dynsym);
      hashsec->set_entsize(4);
d3829 2
a3830 1
      odyn->add_section_address(elfcpp::DT_HASH, hashsec);
d3850 2
a3851 1
      hashsec->add_output_section_data(hashdata);
d3853 4
a3856 1
      hashsec->set_link_section(dynsym);
d3858 5
a3862 5
      // For a 64-bit target, the entries in .gnu.hash do not have a
      // uniform size, so we only set the entry size for a 32-bit
      // target.
      if (parameters->target().get_size() == 32)
	hashsec->set_entsize(4);
d3864 3
a3866 1
      odyn->add_section_address(elfcpp::DT_GNU_HASH, hashsec);
d3876 2
a3877 1
  gold_assert(dynsym != NULL);
d3958 18
a3975 13
  unsigned char* vbuf;
  unsigned int vsize;
  versions->symbol_section_contents<size, big_endian>(symtab, &this->dynpool_,
						      local_symcount,
						      dynamic_symbols,
						      &vbuf, &vsize);

  Output_section_data* vdata = new Output_data_const_buffer(vbuf, vsize, 2,
							    "** versions");

  vsec->add_output_section_data(vdata);
  vsec->set_entsize(2);
  vsec->set_link_section(this->dynsym_section_);
d3978 2
a3979 1
  odyn->add_section_address(elfcpp::DT_VERSYM, vsec);
d3984 4
a3987 17
      vdsec= this->choose_output_section(NULL, ".gnu.version_d",
					 elfcpp::SHT_GNU_verdef,
					 elfcpp::SHF_ALLOC,
					 false, ORDER_DYNAMIC_LINKER, false);

      unsigned char* vdbuf;
      unsigned int vdsize;
      unsigned int vdentries;
      versions->def_section_contents<size, big_endian>(&this->dynpool_, &vdbuf,
						       &vdsize, &vdentries);

      Output_section_data* vddata =
	new Output_data_const_buffer(vdbuf, vdsize, 4, "** version defs");

      vdsec->add_output_section_data(vddata);
      vdsec->set_link_section(dynstr);
      vdsec->set_info(vdentries);
d3989 22
a4010 2
      odyn->add_section_address(elfcpp::DT_VERDEF, vdsec);
      odyn->add_constant(elfcpp::DT_VERDEFNUM, vdentries);
d4021 15
a4035 13
      unsigned char* vnbuf;
      unsigned int vnsize;
      unsigned int vnentries;
      versions->need_section_contents<size, big_endian>(&this->dynpool_,
							&vnbuf, &vnsize,
							&vnentries);

      Output_section_data* vndata =
	new Output_data_const_buffer(vnbuf, vnsize, 4, "** version refs");

      vnsec->add_output_section_data(vndata);
      vnsec->set_link_section(dynstr);
      vnsec->set_info(vnentries);
d4037 6
a4042 2
      odyn->add_section_address(elfcpp::DT_VERNEED, vnsec);
      odyn->add_constant(elfcpp::DT_VERNEEDNUM, vnentries);
d4069 2
a4070 1
  osec->add_output_section_data(odata);
d4176 2
a4177 1
  if (!this->script_options_->saw_phdrs_clause())
d4187 2
d4384 2
d4387 2
@


1.212
log
@	* incremental.cc (Incremental_inputs::report_command_line): Ignore
	--incremental-patch option.
	* layout.cc (Free_list::allocate): Extend allocation beyond original
	end if enabled.
	(Layout::make_output_section): Mark sections that should get
	patch space.
	* options.cc (parse_percent): New function.
	* options.h (parse_percent): New function.
	(DEFINE_percent): New macro.
	(General_options): Add --incremental-patch option.
	* output.cc (Output_section::Output_section): Initialize new data
	members.
	(Output_section::add_input_section): Print section name when out
	of patch space.
	(Output_section::add_output_section_data): Likewise.
	(Output_section::set_final_data_size): Add patch space when
	doing --incremental-full.
	(Output_section::do_reset_address_and_file_offset): Remove patch
	space.
	(Output_segment::set_section_list_addresses): Print debug output
	only if --incremental-update.
	* output.h (Output_section::set_is_patch_space_allowed): New function.
	(Output_section::is_patch_space_allowed_): New data member.
	(Output_section::patch_space_): New data member.
	* parameters.cc (Parameters::incremental_full): New function.
	* parameters.h (Parameters::incremental_full): New function
	* testsuite/Makefile.am (incremental_test_2): Add test for
	--incremental-patch option.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/two_file_test_1_v1.cc (t1, t2, t3): Add comments.
	(t18): Remove function body.
@
text
@d4030 2
a4031 1
// DT_RELSZ/DT_RELASZ, DT_RELENT/DT_RELAENT.
d4060 4
a4063 2
				dyn_rel);
      if (plt_rel != NULL && dynrel_includes_plt)
d4065 2
a4066 1
			       dyn_rel, plt_rel);
d4069 1
a4069 1
			       dyn_rel);
@


1.211
log
@	PR gold/12957
	* options.h (class General_options): Add -f and -F.
	* options.cc (General_options::finalize): Fatal error if -f/-F
	are used without -shared.
	* layout.cc (Layout::finish_dynamic_section): Implement -f/-F.
@
text
@d171 5
d194 6
d1427 15
@


1.210
log
@	PR gold/12571
	* options.h (class General_options): Add
	--ld-generated-unwind-info.
	* ehframe.cc (Fde::write): Add address parameter.  Change all
	callers.  If associated with PLT, fill in address and size.
	(Cie::set_output_offset): Only add merge mapping if there is an
	object.
	(Cie::write): Add address parameter.  Change all callers.
	(Eh_frame::add_ehframe_for_plt): New function.
	* ehframe.h (class Fde): Update declarations.  Move shndx_ and
	input_offset_ fields into union u_, with new plt field.
	(Fde::Fde): Adjust for new union field.
	(Fde::Fde) [Output_data version]: New constructor.
	(Fde::add_mapping): Only add merge mapping if there is an object.
	(class Cie): Update declarations.
	(class Eh_frame): Declare add_ehframe_for_plt.
	* layout.cc (Layout::layout_eh_frame): Break out code into
	make_eh_frame_section, and call it.
	(Layout::make_eh_frame_section): New function.
	(Layout::add_eh_frame_for_plt): New function.
	* layout.h (class Layout): Update declarations.
	* merge.cc (Merge_map::add_mapping): Add assertion.
	* i386.cc: Include "dwarf.h".
	(class Output_data_plt_i386): Make first_plt_entry,
	dyn_first_plt_entry, exec_plt_entry, and dyn_plt_entry const.  Add
	plt_eh_frame_cie_size, plt_eh_frame_fde_size, plt_eh_frame_cie,
	and plt_eh_frame_fde.
	(Output_data_plt_i386::Output_data_plt_i386): Align to 16-byte
	boundary.  Call add_eh_frame_for_plt if appropriate.
	* x86_64.cc: Include "dwarf.h".
	(class Output_data_plt_x86_64): Align to 16-byte boundary.  Make
	first_plt_entry, plt_entry and tlsdesc_plt_entry const.  Add
	plt_eh_frame_cie_size, plt_eh_frame_fde_size, plt_eh_frame_cie,
	and plt_eh_frame_fde.
	(Output_data_plt_x86_64::init): Call add_eh_frame_for_plt if
	appropriate.
@
text
@d4221 12
a4232 2
  // Add a DT_FLAGS entry. We add it even if no flags are set so that
  // post-link tools can easily modify these flags if desired.
@


1.209
log
@	PR gold/12675
	* object.cc (Sized_relobj_file::check_eh_frame_flags): Check for
	SHT_X86_64_UNWIND.
	* layout.cc (Layout::layout_eh_frame): Likewise.
@
text
@d1139 1
a1139 5
  const char* const name = ".eh_frame";
  Output_section* os = this->choose_output_section(object, name,
						   elfcpp::SHT_PROGBITS,
						   elfcpp::SHF_ALLOC, false,
						   ORDER_EHFRAME, false);
a1142 37
  if (this->eh_frame_section_ == NULL)
    {
      this->eh_frame_section_ = os;
      this->eh_frame_data_ = new Eh_frame();

      // For incremental linking, we do not optimize .eh_frame sections
      // or create a .eh_frame_hdr section.
      if (parameters->options().eh_frame_hdr() && !parameters->incremental())
	{
	  Output_section* hdr_os =
	    this->choose_output_section(NULL, ".eh_frame_hdr",
					elfcpp::SHT_PROGBITS,
					elfcpp::SHF_ALLOC, false,
					ORDER_EHFRAME, false);

	  if (hdr_os != NULL)
	    {
	      Eh_frame_hdr* hdr_posd = new Eh_frame_hdr(os,
							this->eh_frame_data_);
	      hdr_os->add_output_section_data(hdr_posd);

	      hdr_os->set_after_input_sections();

	      if (!this->script_options_->saw_phdrs_clause())
		{
		  Output_segment* hdr_oseg;
		  hdr_oseg = this->make_output_segment(elfcpp::PT_GNU_EH_FRAME,
						       elfcpp::PF_R);
		  hdr_oseg->add_output_section_to_nonload(hdr_os,
							  elfcpp::PF_R);
		}

	      this->eh_frame_data_->set_eh_frame_hdr(hdr_posd);
	    }
	}
    }

d1184 2
a1185 2
      *off = os->add_input_section(this, object, shndx, name, shdr, reloc_shndx,
				   saw_sections_clause);
d1196 80
@


1.208
log
@	PR gold/12695
	* layout.cc (Layout::symtab_section_shndx): New function.
	* layout.h (class Layout): Declare symtab_section_shndx.
	* output.cc (Output_section::write_header): Call it.
@
text
@d1135 2
a1136 1
  gold_assert(shdr.get_sh_type() == elfcpp::SHT_PROGBITS);
@


1.207
log
@	PR gold/12898
	* layout.cc (Layout::segment_precedes): Don't crash if a linker
	script create indistinguishable segments.
	(Layout::set_segment_offsets): Use stable_sort when sorting
	segments.  Pass this to Compare_segments constructor.
	* layout.h (class Layout): Make segment_precedes non-static.
	(class Compare_segments): Change from struct to class.  Add
	layout_ field.  Add constructor.
	* script-sections.cc
	(Script_sections::attach_sections_using_phdrs_clause): Rename
	local orphan to is_orphan.  Don't report failure to put empty
	section in segment.  On attachment failure, report name of
	section, and attach to first PT_LOAD segment.
@
text
@d4539 11
@


1.206
log
@	* layout.cc: Include "object.h".
	(ctors_sections_in_init_array): New static variable.
	(Layout::is_ctors_in_init_array): New function.
	(Layout::layout): Add entry to ctors_sections_in_init_array if
	appropriate.
	* layout.h (class Layout): Declare is_ctors_in_init_array.
	* reloc.cc (Sized_relobj_file::do_relocate): Call reverse_words if
	is_ctors_reverse_view is set.
	(Sized_relobj_file::write_sections): Add layout parameter.  Change
	all callers.  Set is_ctors_reverse_view field of View_size.
	(Sized_relobj_file::reverse_words): New function.
	* object.h (Sized_relobj_file::View_size): Add
	is_ctors_reverse_view field.
	(class Sized_relobj_file): Update declarations.
	* testsuite/initpri3.c: New test.
	* testsuite/Makefile.am: (check_PROGRAMS): Add initpri3a and
	initpri3b.
	(initpri3a_SOURCES, initpri3a_DEPENDENCIES): New variables.
	(initpri3a_LDFLAGS, initpri3a_LDADD): New variables.
	(initpri3b_SOURCES, initpri3b_DEPENDENCIES): New variables.
	(initpri3b_LDFLAGS, initpri3b_LDADD): New variables.
	* testsuite/Makefile.in: Rebuild.
@
text
@d2754 1
a2754 1
// called the segment addresses has normally not yet been set.
d2880 4
a2883 2
  // can't distinguish.
  gold_unreachable();
d2907 5
a2911 3
  // Sort them into the final order.
  std::sort(this->segment_list_.begin(), this->segment_list_.end(),
	    Layout::Compare_segments());
@


1.205
log
@	PR gold/12910
	* options.h (class General_options): Add --ctors-in-init-array.
	* layout.cc (Layout::get_output_section): Treat SHT_INIT_ARRAY and
	friends as SHT_PROGBITS for merging sections.
	(Layout::layout): Remove special handling of .init_array and
	friends.  Don't sort if doing relocatable link.  Sort for .ctors
	and .dtors if ctors_in_init_array.
	(Layout::make_output_section): Force correct section types for
	.init_array and friends.  Don't sort if doing relocatable link,
	Don't sort .ctors and .dtors if ctors_in_init_array.
	(Layout::section_name_mapping): Remove .ctors. and .dtorso.
	(Layout::output_section_name): Add relobj parameter.  Change all
	callers.  Handle .ctors. and .dtors. in code rather than table.
	Handle .ctors and .dtors if ctors_in_init_array.
	(Layout::match_file_name): New function, moved from output.cc.
	* layout.h (class Layout): Update declarations.
	* output.cc: Include "layout.h".
	(Input_section_sort_entry::get_priority): New function.
	(Input_section_sort_entry::match_file_name): Just call
	Layout::match_file_name.
	(Output_section::Input_section_sort_init_fini_compare::operator()):
	Handle .ctors and .dtors.  Sort by explicit priority rather than
	by name.
	* configure.ac: Remove CONSTRUCTOR_PRIORITY test and conditional.
	* testsuite/initpri2.c: New test.
	* testsuite/Makefile.am: Don't test CONSTRUCTOR_PRIORITY.
	(check_PROGRAMS): Add initpri2.
	(initpri2_SOURCES, initpri2_DEPENDENCIES): New variables.
	(initpri2_LDFLAGS, initpri2_LDADD): New variables.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d49 1
d621 24
d950 5
a954 5
  // .ctor.*, .dtor.*, .init_array.*, or .fini_array.*.  The sections
  // are sorted by name.  This is used to implement constructor
  // priority ordering.  We are compatible.  When we put .ctor
  // sections in .init_array and .dtor sections in .fini_array, we
  // must also sort plain .ctor and .dtor sections.
d966 16
@


1.204
log
@	PR gold/12880
	* layout.cc (Layout::attach_allocated_section_to_segment): Add a
	.interp section to a PT_INTERP segment even if we have seen a
	--dynamic-linker option.  Don't do it if we have seen a PHDRS
	clause in a linker script.
	(Layout::finalize): Don't create a .interp section if we've
	already create a PT_INTERP segment.
	(Layout::create_interp): Always call choose_output_section (revert
	patch of 2011-06-17).  Don't create PT_INTERP segment.
	* script-sections.cc
	(Script_sections::create_note_and_tls_segments): Add a .interp
	section to a PT_INTERP segment even if we have seen a
	--dynamic-linker option.
@
text
@d630 12
d650 1
a650 1
  const Key key(name_key, std::make_pair(type, lookup_flags));
d667 1
a667 1
      if (type == elfcpp::SHT_PROGBITS)
d673 4
a676 1
                  && same_name->type() == elfcpp::SHT_PROGBITS
d683 2
a684 1
              const Key zero_key(name_key, std::make_pair(type, zero_flags));
d834 1
a834 1
    name = Layout::output_section_name(name, &len);
a902 4
  Output_section* os;

  // Sometimes .init_array*, .preinit_array* and .fini_array* do not have
  // correct section types.  Force them here.
a903 18
  if (sh_type == elfcpp::SHT_PROGBITS)
    {
      static const char init_array_prefix[] = ".init_array";
      static const char preinit_array_prefix[] = ".preinit_array";
      static const char fini_array_prefix[] = ".fini_array";
      static size_t init_array_prefix_size = sizeof(init_array_prefix) - 1;
      static size_t preinit_array_prefix_size =
	sizeof(preinit_array_prefix) - 1;
      static size_t fini_array_prefix_size = sizeof(fini_array_prefix) - 1;

      if (strncmp(name, init_array_prefix, init_array_prefix_size) == 0)
	sh_type = elfcpp::SHT_INIT_ARRAY;
      else if (strncmp(name, preinit_array_prefix, preinit_array_prefix_size)
	       == 0)
	sh_type = elfcpp::SHT_PREINIT_ARRAY;
      else if (strncmp(name, fini_array_prefix, fini_array_prefix_size) == 0)
	sh_type = elfcpp::SHT_FINI_ARRAY;
    }
d907 1
d927 3
a929 1
  // priority ordering.  We are compatible.
d931 1
d935 4
a938 1
	  || is_prefix_of(".fini_array.", name)))
d1260 12
d1319 6
a1324 4
      && (strcmp(name, ".ctors") == 0
	  || strcmp(name, ".dtors") == 0
	  || strcmp(name, ".init_array") == 0
	  || strcmp(name, ".fini_array") == 0))
a4219 2
  MAPPING_INIT(".ctors.", ".ctors"),
  MAPPING_INIT(".dtors.", ".dtors"),
d4271 2
a4272 1
Layout::output_section_name(const char* name, size_t* plen)
d4319 31
d4353 22
@


1.203
log
@	* layout.cc (Layout::finish_dynamic_section): Don't set DT_TEXTREL
	merely because a non-PT_LOAD segment has a dynamic reloc.
@
text
@d1550 3
a1552 6
  // If we are making a shared library, and we see a section named
  // .interp, and the -dynamic-linker option was not used, then put
  // the .interp section into a PT_INTERP segment.  This is for GNU ld
  // compatibility.  If making an executable, or if the
  // -dynamic-linker option was used, we will create the section and
  // segment in Layout::create_interp.
d1554 1
a1554 2
      && parameters->options().shared()
      && parameters->options().dynamic_linker() == NULL)
d1558 3
d2185 5
a2189 3
      // interpreter, and put it in a PT_INTERP segment.
      if (!parameters->options().shared()
	  || parameters->options().dynamic_linker() != NULL)
d3883 5
a3887 17
  Output_section* osec;

  // If we are using a SECTIONS clause, let it decide where the
  // .interp section should go.  Otherwise always create a new section
  // so that this .interp section does not get confused with any
  // section of the same name in the program.
  if (this->script_options_->saw_sections_clause())
    osec = this->choose_output_section(NULL, ".interp", elfcpp::SHT_PROGBITS,
				       elfcpp::SHF_ALLOC, false, ORDER_INTERP,
				       false);
  else
    {
      const char* n = this->namepool_.add("interp", false, NULL);
      osec = this->make_output_section(n, elfcpp::SHT_PROGBITS,
				       elfcpp::SHF_ALLOC, ORDER_INTERP, false);
    }

a3888 7

  if (!this->script_options_->saw_phdrs_clause())
    {
      Output_segment* oseg = this->make_output_segment(elfcpp::PT_INTERP,
						       elfcpp::PF_R);
      oseg->add_output_section_to_nonload(osec, elfcpp::PF_R);
    }
@


1.202
log
@	* layout.cc (Layout::finish_dynamic_section): Don't create
	DT_FLAGS entry if not needed.
@
text
@d4110 2
a4111 1
          if (((*p)->flags() & elfcpp::PF_W) == 0
d4131 1
a4131 1
              && ((*p)->has_dynamic_reloc()))
@


1.201
log
@	PR gold/12745
	* layout.cc (Layout::layout_eh_frame): Correct handling of
	writable .eh_frame section.
@
text
@d4165 2
a4166 1
  odyn->add_constant(elfcpp::DT_FLAGS, flags);
d4191 1
a4191 1
  if (flags)
@


1.200
log
@	PR gold/12880
	* layout.h (class Layout): Add interp_segment_ field.
	* layout.cc (Layout::Layout): Initialize interp_segment_ field.
	(Layout::attach_allocated_section_to_segment): If making shared
	library, put .interp section in PT_INTERP segment.
	(Layout::finalize): Also call create_interp if -dynamic-linker
	option was used.
	(Layout::create_interp): Assert that there is no PT_INTERP
	segment.  If not using a SECTIONS clause, use make_output_section.
	(Layout::make_output_segment): Set interp_segment_ if PT_INTERP.
	* script-sections.cc
	(Script_sections::create_note_and_tls_segments): If making shared
	library, put .interp section in PT_INTERP segment.
@
text
@d1143 2
d1158 6
a1163 2
      if ((shdr.get_sh_flags() & elfcpp::SHF_WRITE) != 0)
	os->set_is_relro();
d1185 4
@


1.199
log
@	* common.cc (Symbol_table::do_allocate_commons_list): Call
	gold_fallback.
	* errors.cc (Errors::fatal): Adjust call to gold_exit.
	(Errors::fallback): New function.
	(gold_fallback): New function.
	* errors.h (Errors::fallback): New function.
	* gold.cc (gold_exit): Change status parameter to enum; adjust
	all callers.
	(queue_initial_tasks): Call gold_fallback.
	* gold.h: Include cstdlib.
	(Exit_status): New enum type.
	(gold_exit): Change status parameter to enum.
	(gold_fallback): New function.
	* layout.cc (Layout::set_section_offsets): Call gold_fallback.
	(Layout::create_symtab_sections): Likewise.
	(Layout::create_shdrs): Likewise.
	* main.cc (main): Adjust call to gold_exit.
	* output.cc (Output_data_got::add_got_entry): Call gold_fallback.
	(Output_data_got::add_got_entry_pair): Likewise.
	(Output_section::add_input_section): Likewise.
	(Output_section::add_output_section_data): Likewise.
	(Output_segment::set_section_list_addresses): Likewise.
	* x86_64.cc (Output_data_plt_x86_64::add_entry): Likewise.
@
text
@d363 1
d622 2
a623 5
// pool, and NAME_KEY is the key.  IS_INTERP is true if this is the
// .interp section.  IS_DYNAMIC_LINKER_SECTION is true if this section
// is used by the dynamic linker.  IS_RELRO is true for a relro
// section.  IS_LAST_RELRO is true for the last relro section.
// IS_FIRST_NON_RELRO is true for the first non-relro section.
d688 3
a690 6
// file.  IS_INTERP is true if this is the .interp section.
// IS_DYNAMIC_LINKER_SECTION is true if this section is used by the
// dynamic linker.  IS_RELRO is true for a relro section.
// IS_LAST_RELRO is true for the last relro section.
// IS_FIRST_NON_RELRO is true for the first non-relro section.  This
// will return NULL if the input section should be discarded.
d1539 15
d2177 2
a2178 1
      if (!parameters->options().shared())
d3859 2
d3872 17
a3888 5
  Output_section* osec = this->choose_output_section(NULL, ".interp",
						     elfcpp::SHT_PROGBITS,
						     elfcpp::SHF_ALLOC,
						     false, ORDER_INTERP,
						     false);
d4417 2
@


1.198
log
@	* layout.cc (Layout::set_segment_offsets): Don't adjust layout
	for incremental links.
	* output.cc (Output_segment::set_section_list_addresses): Remove
	FIXME and test for TLS or BSS.
@
text
@d3128 3
a3130 3
	      gold_fatal(_("out of patch space for section %s; "
			   "relink with --incremental-full"),
			 (*p)->output_section()->name());
d3137 3
a3139 3
	      gold_fatal(_("%s: section changed size; "
			   "relink with --incremental-full"),
			 (*p)->output_section()->name());
d3394 2
a3395 2
	    gold_fatal(_("out of patch space for symbol table; "
		         "relink with --incremental-full"));
d3465 2
a3466 2
	  gold_fatal(_("out of patch space for section header table; "
		       "relink with --incremental-full"));
@


1.197
log
@	* archive.cc (Library_base::should_include_member): Pull in object
	from archive if it defines the entry symbol.
	* parameters.cc (Parameters::entry): New function.
	* parameters.h (class Parameters): Declare entry.
	* output.h (class Output_file_header): Remove entry_ field.
	* output.cc (Output_file_header::Output_file_header): Remove entry
	parameter.  Change all callers.
	(Output_file_header::entry): Use parameters->entry.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (Plugin_hook::run): Likewise.
@
text
@d2960 1
a2960 1
	      && !parameters->incremental_update())
@


1.196
log
@	* dynobj.h (Dynobj::do_dynobj): New function.
	* incremental-dump.cc (dump_incremental_inputs): Print as_needed
	flag and soname for shared objects.
	* incremental.cc (Incremental_inputs::report_object): Make
	either Incremental_object_entry or Incremental_dynobj_entry; add
	soname to string table.
	(Incremental_inputs::report_input_section): Add assertion.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	type of input file entry for shared libraries; adjust size of
	shared library info entry.
	(Output_section_incremental_inputs::write_input_files): Write
	as_needed flag for shared libraries.
	(Output_section_incremental_inputs::write_info_blocks): Adjust type
	of input file entry for shared libraries; write soname.
	(Sized_incr_dynobj::Sized_incr_dynobj): Read as_needed flag and
	soname from incremental info.
	* incremental.h (enum Incremental_input_flags): Add
	INCREMENTAL_INPUT_AS_NEEDED.
	(Incremental_input_entry::Incremental_input_entry): Initialize new
	data member.
	(Incremental_input_entry::set_as_needed): New function.
	(Incremental_input_entry::as_needed): New function.
	(Incremental_input_entry::do_dynobj_entry): New function.
	(Incremental_input_entry::as_needed_): New data member.
	(Incremental_object_entry::Incremental_object_entry): Don't check
	for shared library.
	(Incremental_object_entry::do_type): Likewise.
	(class Incremental_dynobj_entry): New class.
	(Incremental_input_entry_reader::as_needed): New function.
	(Incremental_input_entry_reader::get_soname): New function.
	(Incremental_input_entry_reader::get_global_symbol_count): Rewrite.
	(Incremental_input_entry_reader::get_output_symbol_index): Adjust
	size of shared library info entry.
	* layout.cc (Layout::finish_dynamic_section): Don't test for
	incremental link when adding DT_NEEDED entries.
	* object.h (Object::Object): Initialize new data member.
	(Object::dynobj): New function.
	(Object::set_as_needed): New function.
	(Object::as_needed): New function.
	(Object::do_dynobj): New function.
	(Object::as_needed_): New data member.
@
text
@d2195 2
a2196 3
  Output_file_header* file_header
    = new Output_file_header(target, symtab, segment_headers,
			     parameters->options().entry());
@


1.195
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d3989 1
a3989 3
      if (!(*p)->is_needed()
	  && !(*p)->is_incremental()
	  && (*p)->input_file()->options().as_needed())
@


1.194
log
@	* layout.cc (Layout::layout): If the output section flags change,
	update the ordering.
@
text
@d513 1
a513 1
Layout::include_section(Sized_relobj<size, big_endian>*, const char* name,
d883 1
a883 1
Layout::layout(Sized_relobj<size, big_endian>* object, unsigned int shndx,
d971 1
a971 1
Layout::layout_reloc(Sized_relobj<size, big_endian>* object,
d1038 1
a1038 1
		     Sized_relobj<size, big_endian>* object,
d1088 1
a1088 1
Layout::layout_eh_frame(Sized_relobj<size, big_endian>* object,
d4790 2
a4791 1
Layout::layout<32, false>(Sized_relobj<32, false>* object, unsigned int shndx,
d4800 2
a4801 1
Layout::layout<32, true>(Sized_relobj<32, true>* object, unsigned int shndx,
d4810 2
a4811 1
Layout::layout<64, false>(Sized_relobj<64, false>* object, unsigned int shndx,
d4820 2
a4821 1
Layout::layout<64, true>(Sized_relobj<64, true>* object, unsigned int shndx,
d4830 1
a4830 1
Layout::layout_reloc<32, false>(Sized_relobj<32, false>* object,
d4840 1
a4840 1
Layout::layout_reloc<32, true>(Sized_relobj<32, true>* object,
d4850 1
a4850 1
Layout::layout_reloc<64, false>(Sized_relobj<64, false>* object,
d4860 1
a4860 1
Layout::layout_reloc<64, true>(Sized_relobj<64, true>* object,
d4871 1
a4871 1
				Sized_relobj<32, false>* object,
d4884 1
a4884 1
			       Sized_relobj<32, true>* object,
d4897 1
a4897 1
				Sized_relobj<64, false>* object,
d4910 1
a4910 1
			       Sized_relobj<64, true>* object,
d4922 1
a4922 1
Layout::layout_eh_frame<32, false>(Sized_relobj<32, false>* object,
d4937 3
a4939 3
Layout::layout_eh_frame<32, true>(Sized_relobj<32, true>* object,
				   const unsigned char* symbols,
				   off_t symbols_size,
d4952 1
a4952 1
Layout::layout_eh_frame<64, false>(Sized_relobj<64, false>* object,
d4967 3
a4969 3
Layout::layout_eh_frame<64, true>(Sized_relobj<64, true>* object,
				   const unsigned char* symbols,
				   off_t symbols_size,
@


1.193
log
@	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	global symbol map.
	(Sized_incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incr_relobj::do_add_symbols): Add symbols to global symbol map.
	(Sized_incr_relobj::do_relocate): Remap section indices in incremental
	relocations.
	(Sized_incr_dynobj::do_add_symbols): Add symbols to global symbol map.
	(Sized_incr_dynobj::do_for_all_global_symbols): Remove FIXME.
	(Sized_incr_dynobj::do_for_all_local_got_entries): Likewise.
	* incremental.h
	(Incremental_inputs_reader::global_symbol_reader_at_offset): New
	function.
	(Incremental_binary::apply_incremental_relocs): New function.
	(Incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data member.
	(Sized_incremental_binary::add_global_symbol): New function.
	(Sized_incremental_binary::global_symbol): New function.
	(Sized_incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incremental_binary::symbol_map_): New data member.
	* layout.cc (Layout_task_runner::run): Apply incremental relocations.
	* target.h (Sized_target::apply_relocation): New function.
	* target-reloc.h (apply_relocation): New function.
	* x86_64.cc (Target_x86_64::apply_relocation): New function.
@
text
@d947 2
d951 11
@


1.192
log
@	* gold/layout.cc (Layout::symtab_section_offset): New function.
	* gold/layout.h (Layout::symtab_section_offset): New function.
	* gold/reloc.cc (Sized_relobj::do_relocate): Call it.
@
text
@d301 5
a305 4
  off_t file_size = this->layout_->finalize(this->input_objects_,
					    this->symtab_,
                                            this->target_,
					    task);
d313 1
a313 1
      this->layout_->print_to_mapfile(this->mapfile_);
d317 1
a317 1
  if (this->layout_->incremental_base() == NULL)
d326 12
a337 1
      of = this->layout_->incremental_base()->output_file();
d343 1
a343 1
			  this->symtab_, this->layout_, workqueue, of);
@


1.191
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d4374 10
@


1.190
log
@	* layout.cc (Layout::layout_eh_frame): Mark a writable .eh_frame
	section as relro.
	(Layout::set_segment_offsets): Reset increase_relro before calling
	set_section_addresses a second time.
@
text
@d58 162
d315 13
a327 4
  Output_file* of = new Output_file(parameters->options().output_file_name());
  if (this->options_.oformat_enum() != General_options::OBJECT_FORMAT_ELF)
    of->set_is_temporary();
  of->open(file_size);
d381 3
a383 1
    relaxation_debug_check_(NULL)
d402 9
d824 35
d1089 3
a1091 1
      if (parameters->options().eh_frame_hdr())
d1123 9
a1131 8
  if (this->eh_frame_data_->add_ehframe_input_section(object,
						      symbols,
						      symbols_size,
						      symbol_names,
						      symbol_names_size,
						      shndx,
						      reloc_shndx,
						      reloc_type))
d2370 2
a2371 1
  if (parameters->options().relocatable())
d2933 4
a2936 1
	  if (!are_addresses_set && !has_relro && aligned_addr != addr)
d3053 3
d3087 38
a3124 3
      off = align_address(off, (*p)->addralign());
      (*p)->set_file_offset(off);
      (*p)->finalize_data_size();
d3126 2
d3133 1
a3133 1
  return off;
d3247 2
a3248 3
  off_t off = *poff;
  off = align_address(off, align);
  off_t startoff = off;
d3281 1
a3281 1
  gold_assert(static_cast<off_t>(local_symcount * symsize) == off - startoff);
d3302 1
d3317 1
a3317 2
      Output_section_data* pos = new Output_data_fixed_space(off - startoff,
							     align,
d3337 1
a3337 1
	  size_t symcount = (off - startoff) / symsize;
d3363 17
a3379 1
      osymtab->set_file_offset(startoff);
d3385 2
a3386 1
      *poff = off;
d3433 15
a3447 1
  off_t off = align_address(*poff, oshdrs->addralign());
d3450 2
a3451 1
  *poff = off;
d3965 1
d4723 32
@


1.189
log
@	* layout.cc (Layout::layout_gnu_stack): Add warnings for executable
	stack.
	* layout.h (Layout::layout_gnu_stack): Add pointer to Object
	parameter; change all callers.
	* object.cc (Sized_relobj::do_layout): Adjust call to layout_gnu_stack.
	* options.h (warn_execstack): New option.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d915 4
d2729 6
@


1.188
log
@	* output.h (Output_segment::set_section_addresses): Pass increase_relro
	by reference; adjust all callers.
	* output.cc (Output_segment::set_section_addresses): Adjust references
	to increase_relro. Add padding to *increase_relro when ORDER_RELRO_LAST
	list is empty.
	(Output_segment::set_offset): Assert if PT_GNU_RELRO segment does not
	end at page boundary.
@
text
@d1347 2
a1348 1
Layout::layout_gnu_stack(bool seen_gnu_stack, uint64_t gnu_stack_flags)
d1351 8
a1358 1
    this->input_without_gnu_stack_note_ = true;
d1363 7
a1369 1
	this->input_requires_executable_stack_ = true;
@


1.187
log
@	PR gold/12220
	* layout.cc (Layout::choose_output_section): Transform names of
	compressed sections even when using a script with a SECTIONS clause.
	(Layout::output_section_name): Remove code to transform
	compressed debug section names.
	* output.cc (Output_section::add_input_section): Use uncompressed
	section size when tracking input sections.
@
text
@d2682 1
a2682 1
							  increase_relro,
d2712 1
a2712 1
							 increase_relro,
@


1.186
log
@2010-11-08  Doug Kwan  <dougkwan@@google.com>
	    Cary Coutant  <ccoutant@@google.com>

	* arm.cc (Arm_exidx_merge_section::build_contents): New method.
	(Arm_exidx_merge_section::section_contents_): New data member.
	(Arm_input_section::Arm_input_section): Initialize original_contents_.
	(Arm_input_section::~Arm_input_section): De-allocate memory.
	(Arm_input_section::original_contents_): New data member.
	(Arm_exidx_fixup::process_exidx_section): Pass EXIDX section contents
	in parameters instead of calling Object::section_contents without
	locking.
	(Arm_output_section::group_section): New parameter TASK.  Pass it
	to callees that need locking objects.
	(Arm_output_section::fix_exidx_coverage): New parameter TASK.  Use it
	to lock EXIDX input sections.  Fix a formatting issue.  Call
	Arm_exidx_merged_section::build_contents to create merged section
	contents.
	(Arm_output_section::create_stub_group): New parameter TASK.  Use it
	to lock object of stub table owner.
	(Arm_exidx_input_section::Arm_exidx_input_section): Add new parameter
	TEXT_SIZE to initialize data member TEXT_SIZE_.
	(Arm_exidx_input_section::addralign): Fix typo in comment.
	(Arm_exidx_input_section::text_size): New method.
	(Target_arm::do_relax): New parameter TASK.  Pass it to callees
	that require locking objects.  Lock objects before scanning for stubs
	and updating local symbols.
	(Arm_input_section<big_endian>::init): Copy contents of original
	input section.
 	(Arm_input_section<big_endian>::do_write): Use saved contents of
	original input section instead of calling Object::section_contents
	without locking.
	(Arm_exidx_cantunwind::do_fixed_endian_write): Find out text section
	size without calling Object::section_size().
	(Arm_exidx_merged_section::Arm_exidx_merged_section): Add sanity check
	for size.  Allocate a buffer for merged EXIDX entries.
	(Arm_exidx_merged_section::build_contents): New method.
 	(Arm_exidx_merged_section::do_write): Move merge section contents
	building code to Arm_exidx_merged_section::build_contetns.  Write
	out contetns in buffer instead of building it on the fly.
	(Arm_relobj::make_exidx_input_section): Also pass text section size
	to Arm_exidx_input_section constructor.
	(Arm_relobj::do_read_symbols): Fix memory leak.  Fix a formatting issue.
	(Arm_dynobj::do_read_symbols): Fix memory leak.
	* layout.cc (Layout::finalize): Pass TASK to Target::relax().
	* target.h: (class Task): Add forward declaration.
	(Target::relax): Add new parameter TASK and pass it to
	Target::do_relax().
	(Target::do_relax):: New parameter TASK.  Fix a formatting issue.
@
text
@d291 24
d608 16
a625 2

  size_t len = strlen(name);
d634 3
a968 24
// Sometimes we compress sections.  This is typically done for
// sections that are not part of normal program execution (such as
// .debug_* sections), and where the readers of these sections know
// how to deal with compressed sections.  This routine doesn't say for
// certain whether we'll compress -- it depends on commandline options
// as well -- just whether this section is a candidate for compression.
// (The Output_compressed_section class decides whether to compress
// a given section, and picks the name of the compressed section.)

static bool
is_compressible_debug_section(const char* secname)
{
  return (is_prefix_of(".debug", secname));
}

// We may see compressed debug sections in input files.  Return TRUE
// if this is the name of a compressed debug section.

bool
is_compressed_debug_section(const char* secname)
{
  return (is_prefix_of(".zdebug", secname));
}

a3943 14
  // Compressed debug sections should be mapped to the corresponding
  // uncompressed section.
  if (is_compressed_debug_section(name))
    {
      size_t len = strlen(name);
      char* uncompressed_name = new char[len];
      uncompressed_name[0] = '.';
      gold_assert(name[0] == '.' && name[1] == 'z');
      strncpy(&uncompressed_name[1], &name[2], len - 2);
      uncompressed_name[len - 1] = '\0';
      *plen = len - 1;
      return uncompressed_name;
    }

@


1.185
log
@2010-10-20  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_relobj::do_read_symbols): Warn about ARM EXIDX sections
	without SHF_LINK_ORDER flags.
	* layout.cc (Layout::choose_output_section): Do not filter
	SHF_LINK_ORDER flag in a relocatable link.
@
text
@d1946 1
a1946 1
	 && target->relax(pass, input_objects, symtab, this));
@


1.185.2.1
log
@Merge from trunk:

Changes by:	ccoutant@@sourceware.org	2010-11-16 19:18:31

Modified files:
	gold           : ChangeLog layout.cc output.cc output.h

Log message:
	* output.h (Output_segment::set_section_addresses): Pass increase_relro
	by reference; adjust all callers.
	* output.cc (Output_segment::set_section_addresses): Adjust references
	to increase_relro. Add padding to *increase_relro when ORDER_RELRO_LAST
	list is empty.
	(Output_segment::set_offset): Assert if PT_GNU_RELRO segment does not
	end at page boundary.
@
text
@d2665 1
a2665 1
							  &increase_relro,
d2695 1
a2695 1
							 &increase_relro,
@


1.185.2.2
log
@	* layout.cc (Layout::layout_eh_frame): Mark a writable .eh_frame
	section as relro.
	(Layout::set_segment_offsets): Reset increase_relro before calling
	set_section_addresses a second time.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
a873 4
      // A writable .eh_frame section is a RELRO section.
      if ((shdr.get_sh_flags() & elfcpp::SHF_WRITE) != 0)
	os->set_is_relro();

a2693 6

		  increase_relro = this->increase_relro_;
		  if (this->script_options_->saw_sections_clause())
		    increase_relro = 0;
		  has_relro = false;

@


1.185.2.3
log
@	* layout.cc (Layout::layout): If the output section flags change,
	update the ordering.
@
text
@a676 2
  elfcpp::Elf_Xword orig_flags = os->flags();

a678 11

  // If the flags changed, we may have to change the order.
  if ((orig_flags & elfcpp::SHF_ALLOC) != 0)
    {
      orig_flags &= (elfcpp::SHF_WRITE | elfcpp::SHF_EXECINSTR);
      elfcpp::Elf_Xword new_flags =
	os->flags() & (elfcpp::SHF_WRITE | elfcpp::SHF_EXECINSTR);
      if (orig_flags != new_flags)
	os->set_order(this->default_section_order(os, false));
    }

@


1.184
log
@	* output.h (Output_segment::set_section_addresses): Change function
	signature.  Update all callers.
	* output.cc (Output_segment::is_first_section_relro): Ignore TLS
	sections.
	(Output_segment::set_section_addresses): Align after last TLS
	section.  Add padding before last relro section instead of after.
@
text
@a491 1
	      | elfcpp::SHF_LINK_ORDER
d496 5
@


1.183
log
@	* layout.cc (Layout::set_segment_offsets): Don't try to realign data
	segment that has been aligned for relro.
	* output.cc (Output_segment::set_section_addresses): Change signature;
	adjust all callers.  Account for alignment when totalling
	size of relro sections.
	* output.h (Output_segment::set_section_addresses): Change signature.
	* testsuite/Makefile.am (relro_test.sh, relro_test.stdout): New
	targets.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/relro_test.cc: Add alignment attributes to test proper
	alignment of relro sections when padding is necessary.
	* testsuite/relro_test.sh: New script.
@
text
@d2661 1
a2661 1
							  &increase_relro,
d2691 1
a2691 1
							 &increase_relro,
@


1.182
log
@	* debug.h (DEBUG_INCREMENTAL): New flag.
	(debug_string_to_enum): Add DEBUG_INCREMENTAL).
	* gold.cc (queue_initial_tasks): Check parameters for incremental link
	mode.
	* incremental.cc (report_command_line): Ignore all forms of
	--incremental.
	* layout.cc (Layout::Layout): Check parameters for incremental link
	mode.
	* options.cc (General_options::parse_incremental): New function.
	(General_options::parse_no_incremental): New function.
	(General_options::parse_incremental_full): New function.
	(General_options::parse_incremental_update): New function.
	(General_options::incremental_mode_): New data member.
	(General_options::finalize): Check incremental_mode_.
	* options.h (General_options): Update help text for --incremental.
	Add --no-incremental, --incremental-full, --incremental-update.
	(General_options::Incremental_mode): New enum type.
	(General_options::incremental_mode): New function.
	(General_options::incremental_mode_): New data member.
	* parameters.cc (Parameters::incremental_mode_): New data member.
	(Parameters::set_options): Set incremental_mode_.
	(Parameters::set_incremental_full): New function.
	(Parameters::incremental): New function.
	(Parameters::incremental_update): New function.
	(set_parameters_incremental_full): New function.
	* parameters.h (Parameters::set_incremental_full): New function.
	(Parameters::incremental): New function.
	(Parameters::incremental_update): New function.
	(Parameters::incremental_mode_): New data member.
	(set_parameters_incremental_full): New function.
	* plugin.cc (Plugin_manager::add_input_file): Check parameters for
	incremental link mode.
	* reloc.cc (Sized_relobj::do_read_relocs): Likewise.
	(Sized_relobj::do_relocate_sections): Likewise.
	* testsuite/Makefile.am (incremental_test): Use --incremental-full
	option.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/incremental_test.sh: Filter all forms of --incremental.
@
text
@d2659 1
d2661 2
a2662 1
							  increase_relro,
d2669 3
a2671 1
	  // the ABI mandated page size.
d2673 1
a2673 1
	  if (!are_addresses_set && aligned_addr != addr)
d2691 2
a2692 1
							 increase_relro,
@


1.181
log
@2010-09-09  Rafael Espindola  <espindola@@google.com>

	* layout.cc (Layout::attach_allocated_section_to_segment): Don't put
	sections with different PF_X flags in the same segment.
	(Layout::find_first_load_seg): Search all segments to find the first
	one.
	* options.h (rosegment): New.
@
text
@d221 1
a221 1
  if (parameters->options().incremental())
@


1.180
log
@2010-09-03  Rafael Espindola  <espindola@@google.com>

      * layout.cc (Layout::set_segment_offsets): Always advance to a new page.
@
text
@d1174 5
a1178 4
  // segments is whether or not they are writable, so that is how we
  // search for them.  Large data sections also go into their own
  // PT_LOAD segment.  People who need segments sorted on some other
  // basis will have to use a linker script.
d1190 3
d1461 1
d1470 4
a1473 1
	return *p;
d1475 2
@


1.179
log
@        * README: Remove claim that MEMORY is not supported.
        * expression.cc (script_exp_function_origin)
        (script_exp_function_length): Move from here to ...
        * script.cc: ... here.
        (script_set_section_region, script_add_memory)
        (script_parse_memory_attr, script_include_directive): New
        functions.
        * script-sections.cc
        (class Memory_region): New class.
        (class Output_section_definition): Add set_memory_region,
        set_section_vma, set_section_lma and get_section_name methods.
        (class Script_Sections): Add add_memory_region,
        find_memory_region, find_memory_region_origin,
        find_memory_region_length and set_memory_region methods.
        Have set_section_addresses method walk the list of set memory
        regions.
        Extend the print methos to display memory regions.
        * script-sections.h: Add prototypes for new methods.
        Add enum for MEMORY region attributes.
        * yyscript.y: Add support for parsing MEMORY regions.
        * script-c.h: Add prototypes for new functions.
        * testsuite/Makefile.am: Add test of MEMORY region functionality.
        * testsuite/Makefile.in: Regenerate.
        * testsuite/memory_test.sh: New script.
        * testsuite/memory_test.s: New assembler source file.
        * testsuite/memory_test.t: New linker script.
@
text
@a2569 1
  bool was_readonly = false;
d2616 5
a2620 6
	      // If the last segment was readonly, and this one is
	      // not, then skip the address forward one page,
	      // maintaining the same position within the page.  This
	      // lets us store both segments overlapping on a single
	      // page in the file, but the loader will put them on
	      // different pages in memory.
d2625 2
a2626 5
	      if (was_readonly && ((*p)->flags() & elfcpp::PF_W) != 0)
		{
		  if ((addr & (abi_pagesize - 1)) != 0)
		    addr = addr + abi_pagesize;
		}
a2683 3
	  if (((*p)->flags() & elfcpp::PF_W) == 0)
	    was_readonly = true;

@


1.178
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d506 1
d511 4
@


1.177
log
@        PR 11899
        * layout.cc (segment_precedes): Sort segments by their physical
        addresses, if they have been set.
@
text
@d2102 1
a2102 1
  Output_section *os = this->create_note("GNU", elfcpp::NT_GNU_GOLD_VERSION,
d2317 1
a2317 1
  const char *incremental_inputs_name =
d2326 1
a2326 1
  const char *incremental_symtab_name =
d2336 1
a2336 1
  const char *incremental_relocs_name =
d2346 1
a2346 1
  const char *incremental_got_plt_name =
d2355 1
a2355 1
  const char *incremental_strtab_name =
d2526 1
a2526 1
			    unsigned int *pshndx)
d2733 1
a2733 1
					unsigned int *pshndx)
d3121 1
a3121 1
			      Output_section **pdynstr,
d3916 1
a3916 1
      char *uncompressed_name = new char[len];
@


1.176
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_GOT_PLT.

gold/ChangeLog:

	* arm.cc (Target_arm::got_size): Add const.
	(Target_arm::got_entry_count): New function.
	(Target_arm::plt_entry_count): New function.
	(Target_arm::first_plt_entry_offset): New function.
	(Target_arm::plt_entry_size): New function.
	(Output_data_plt_arm::entry_count): New function.
	(Output_data_plt_arm::first_plt_entry_offset): New function.
	(Output_data_plt_arm::get_plt_entry_size): New function.
	* i386.cc (Target_i386::got_size): Add const.
	(Target_i386::got_entry_count): New function.
	(Target_i386::plt_entry_count): New function.
	(Target_i386::first_plt_entry_offset): New function.
	(Target_i386::plt_entry_size): New function.
	(Output_data_plt_i386::entry_count): New function.
	(Output_data_plt_i386::first_plt_entry_offset): New function.
	(Output_data_plt_i386::get_plt_entry_size): New function.
	* incremental-dump.cc (dump_incremental_inputs): Adjust call to
	find_incremental_inputs_sections.  Dump incremental_got_plt section.
	* incremental.cc: Include target.h.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Add
	parameter.  Adjust all callers.  Find incremental_got_plt section.
	(Incremental_inputs::create_data_sections): Create incremental_got_plt
	section.
	(Output_section_incremental_inputs::set_final_data_size): Calculate
	size of incremental_got_plt section.
	(Output_section_incremental_inputs::do_write): Write the
	incremental_got_plt section.
	(Got_plt_view_info): New struct.
	(Local_got_offset_visitor): New class.
	(Global_got_offset_visitor): New class.
	(Global_symbol_visitor_got_plt): New class.
	(Output_section_incremental_inputs::write_got_plt): New function.
	* incremental.h (Incremental_binary::find_incremental_inputs_sections):
	Add parameter.  Adjust all callers.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Incremental_inputs::got_plt_section): New function.
	(Incremental_inputs::got_plt_section_): New data member.
	(Incremental_got_plt_reader): New class.
	* layout.cc (Layout::create_incremental_info_sections): Add the
	incremental_got_plt section.
	* object.h (Got_offset_list::get_list): New function.
	(Got offset_list::for_all_got_offsets): New function.
	(Sized_relobj::local_got_offset_list): New function.
	* powerpc.cc (Target_powerpc::got_size): Add const.
	(Target_powerpc::got_entry_count): New function.
	(Target_powerpc::plt_entry_count): New function.
	(Target_powerpc::first_plt_entry_offset): New function.
	(Target_powerpc::plt_entry_size): New function.
	(Output_data_plt_powerpc::entry_count): New function.
	(Output_data_plt_powerpc::first_plt_entry_offset): New function.
	(Output_data_plt_powerpc::get_plt_entry_size): New function.
	* sparc.cc (Target_sparc::got_size): Add const.
	(Target_sparc::got_entry_count): New function.
	(Target_sparc::plt_entry_count): New function.
	(Target_sparc::first_plt_entry_offset): New function.
	(Target_sparc::plt_entry_size): New function.
	(Output_data_plt_sparc::entry_count): New function.
	(Output_data_plt_sparc::first_plt_entry_offset): New function.
	(Output_data_plt_sparc::get_plt_entry_size): New function.
	* symtab.h (Symbol::got_offset_list): New function.
	(Symbol_table::for_all_symbols): New function.
	* target.h (Sized_target::got_entry_count): New function.
	(Sized_target::plt_entry_count): New function.
	(Sized_target::plt_entry_size): New function.
	* x86_64.cc (Target_x86_64::got_size): Add const.
	(Target_x86_64::got_entry_count): New function.
	(Target_x86_64::plt_entry_count): New function.
	(Target_x86_64::first_plt_entry_offset): New function.
	(Target_x86_64::plt_entry_size): New function.
	(Output_data_plt_x86_64::entry_count): New function.
	(Output_data_plt_x86_64::first_plt_entry_offset): New function.
	(Output_data_plt_x86_64::get_plt_entry_size): New function.
@
text
@d2460 7
a2466 2
      uint64_t paddr1 = seg1->first_section_load_address();
      uint64_t paddr2 = seg2->first_section_load_address();
@


1.175
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_SYMTAB,
	SHT_GNU_INCREMENTAL_RELOCS.

gold/ChangeLog:

	* archive.cc: Include incremental.h.
	(Archive::Archive): Initialize incremental_info_.
	(Archive::include_member): Record archive members in incremental info.
	(Add_archive_symbols::run): Record begin and end of an archive in
	incremental info.
	(Lib_group::include_member): Record objects in incremental info.
	* archive.h (Incremental_archive_entry): Forward declaration.
	(Archive::set_incremental_info): New member function.
	(Archive::incremental_info): New member function.
	(Archive::Unused_symbol_iterator): New class.
	(Archive::unused_symbols_begin): New member function.
	(Archive::unused_symbols_end): New member function.
	(Archive::incremental_info_): New data member.
	* incremental-dump.cc (find_input_containing_global): New function.
	(dump_incremental_inputs): Dump new incremental info sections.
	* incremental.cc: Include symtab.h.
	(Output_section_incremental_inputs): New class.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Support
	new incremental info sections.
	(Sized_incremental_binary::do_check_inputs): Likewise.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): New function.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Rewrite.
	(Incremental_inputs::finalize): Do nothing but finalize string table.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Output_section_incremental_inputs::set_final_data_size): New function.
	(Output_section_incremental_inputs::do_write): New function.
	(Output_section_incremental_inputs::write_header): New function.
	(Output_section_incremental_inputs::write_input_files): New function.
	(Output_section_incremental_inputs::write_info_blocks): New function.
	(Output_section_incremental_inputs::write_symtab): New function.
	* incremental.h (Incremental_script_entry): Forward declaration.
	(Incremental_object_entry): Forward declaration.
	(Incremental_archive_entry): Forward declaration.
	(Incremental_inputs): Forward declaration.
	(Incremental_inputs_header_data): Remove.
	(Incremental_inputs_header): Remove.
	(Incremental_inputs_header_write): Remove.
	(Incremental_inputs_entry_data): Remove.
	(Incremental_inputs_entry): Remove.
	(Incremental_inputs_entry_write): Remove.
	(enum Incremental_input_type): Add INCREMENTAL_INPUT_ARCHIVE_MEMBER.
	(Incremental_binary::find_incremental_inputs_sections): Add parameters.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Sized_ncremental_binary::do_find_incremental_inputs_sections):
	Likewise.
	(Incremental_input_entry): New class.
	(Incremental_script_entry): New class.
	(Incremental_object_entry): New class.
	(Incremental_archive_entry): New class.
	(Incremental_inputs::Incremental_inputs): Initialize new data members.
	(Incremental_inputs::report_inputs): Remove.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): Change prototype.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Change prototype.
	(Incremental_inputs::get_reloc_count): New function.
	(Incremental_inputs::set_reloc_count): New function.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::inputs_section): New function.
	(Incremental_inputs::symtab_section): New function.
	(Incremental_inputs::relocs_section): New function.
	(Incremental_inputs::get_stringpool): Add const.
	(Incremental_inputs::command_line): Add const.
	(Incremental_inputs::inputs): Remove.
	(Incremental_inputs::command_line_key): New function.
	(Incremental_inputs::input_file_count): New function.
	(Incremental_inputs::input_files): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::Input_info): Remove.
	(Incremental_inputs::lock_): Remove.
	(Incremental_inputs::inputs_): Change type.
	(Incremental_inputs::inputs_map_): Remove.
	(Incremental_inputs::current_object_entry_): New data member.
	(Incremental_inputs::inputs_section_): New data member.
	(Incremental_inputs::symtab_section_): New data member.
	(Incremental_inputs::relocs_section_): New data member.
	(Incremental_inputs::reloc_count_): New data member.
	(Incremental_inputs_reader): New class.
	(Incremental_symtab_reader): New class.
	(Incremental_relocs_reader): New class.
	* layout.cc (Layout::finalize): Move finalization of incremental info
	and creation of incremental info sections to follow finalization of
	symbol table.  Set offsets for postprocessing sections.
	(Layout::create_incremental_info_sections): Call
	Incremental_inputs::create_data_sections.  Add incremental symtab
	and relocs sections.  Set sh_entsize and sh_link fields.  Arrange for
	sections to layout after input sections.
	* layout.h (struct Timespec): Forward declaration.
	(Layout::incremental_inputs): Add const.
	(Layout::create_incremental_info_sections): Add parameter.
	* main.cc (main): Remove call to Incremental_inputs::report_inputs.
	* object.cc: Include incremental.h.
	(Relobj::finalize_incremental_relocs): New function.
	(Sized_relobj::do_layout): Record input sections in incremental info.
	* object.h (Object::output_section): New function.
	(Object::output_section_offset): Moved from Relobj.
	(Object::get_incremental_reloc_base): New function.
	(Object::get_incremental_reloc_count): New function.
	(Object::do_output_section): New function.
	(Object::do_output_section_offset): Moved from Relobj.
	(Object::do_get_incremental_reloc_base): New function.
	(Object::do_get_incremental_reloc_count): New function.
	(Object::Object): Initialize new data members.
	(Relobj::output_section): Renamed do_output_section and moved to
	protected.
	(Relobj::output_section_offset): Moved to Object.
	(Relobj::do_get_incremental_reloc_base): New function.
	(Relobj::do_get_incremental_reloc_count): New function.
	(Relobj::allocate_incremental_reloc_counts): New function.
	(Relobj::count_incremental_reloc): New function.
	(Relobj::finalize_incremental_relocs): New function.
	(Relobj::next_incremental_reloc_index): New function.
	(Relobj::reloc_counts_): New data member.
	(Relobj::reloc_bases_): New data member.
	(Sized_relobj::do_relocate_sections): Add parameter.  Change caller.
	(Sized_relobj::relocate_sections): Add parameter.  Change all callers.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* plugin.cc (Plugin_manager::add_input_file): Rewrite test for
	incremental link.
	* readsyms.cc (Read_symbols::do_read_symbols): Move reporting of
	archives and object files elsewhere.
	(Add_symbols::run): Report object files here.
	(Finish_group::run): Report end of archive at end of group.
	* reloc.cc: Include layout.h, incremental.h.
	(Sized_relobj::do_read_relocs): Need relocations for incremental link.
	(Sized_relobj::do_scan_relocs): Record relocations for incremental link.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::do_relocate_sections): Write incremental relocations.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* script.cc (read_input_script): Rewrite test for incremental link.
	Change call to Incremental_inputs::report_script.
	* symtab.h (Symbol_table::first_global_index): New function.
	(Symbol_table::output_count): New function.
@
text
@d2345 9
d2367 1
d2372 1
@


1.174
log
@	PR 11712
	* layout.cc (relaxation_loop_body): If address of load segment is
	set, adjust address to include headers if possible.
@
text
@d977 1
a977 1
 else
a1888 6
  if (this->incremental_inputs_)
    {
      this->incremental_inputs_->finalize();
      this->create_incremental_info_sections();
    }

d1948 7
d1972 5
a1976 1
    off = this->set_section_offsets(off,
d1978 1
d2303 1
a2303 1
// Create .gnu_incremental_inputs and .gnu_incremental_strtab sections needed
d2307 1
a2307 1
Layout::create_incremental_info_sections()
d2309 6
a2314 1
  gold_assert(this->incremental_inputs_ != NULL);
d2319 1
a2319 1
  Output_section* inputs_os =
d2323 22
a2344 4
  Output_section_data* posd =
      this->incremental_inputs_->create_incremental_inputs_section_data();
  inputs_os->add_output_section_data(posd);
  
d2348 3
a2350 4
  Output_section* strtab_os = this->make_output_section(incremental_strtab_name,
                                                        elfcpp::SHT_STRTAB,
                                                        0, ORDER_INVALID,
							false);
d2352 10
a2361 4
    new Output_data_strtab(this->incremental_inputs_->get_stringpool());
  strtab_os->add_output_section_data(strtab_data);
  
  inputs_os->set_link_section(strtab_data);
@


1.173
log
@2010-08-03  Ian Lance Taylor  <iant@@google.com>

	PR 11805
	* layout.h (enum Output_section_order): Define.
	(class Layout): Update declarations.
	* layout.cc (Layout::get_output_section): Add order parameter.
	Remove is_interp, is_dynamic_linker_section, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.  Set order.
	(Layout::default_section_order): New function.
	(Layout::layout_eh_frame): Call add_output_section_to_nonload.
	* output.cc (Output_section::Output_section): Initialize order_.
	Don't initialize deleted fields.
	(Output_segment::Output_segment): Don't initialize deleted
	fields.
	(Output_segment::add_output_section_to_load): New function
	replacing add_output_section.  Change all callers to call this or
	add_output_section_to_nonload.
	(Output_segment::add_output_section_to_nonload): New function.
	(Output_segment::remove_output_section): Rewrite.
	(Output_segment::add_initial_output_data): Likewise.
	(Output_segment::has_any_data_sections): Likewise.
	(Output_segment::is_first_section_relro): Likewise.
	(Output_segment::maximum_alignment): Likewise.
	(Output_segment::has_dynamic_reloc): New function replacing
	dynamic_reloc_count.  Change all callers.
	(Output_segment::has_dynamic_reloc_list): New function replacing
	dynamic_reloc_count_list.  Change all callers.
	(Output_segment::set_section_addresses): Rewrite.
	(Output_segment::set_offset): Rewrite.
	(Output_segment::find_first_and_last_list): Remove.
	(Output_segment::set_tls_offsets): Rewrite.
	(Output_segment::first_section_load_address): Likewise.
	(Output_segment::output_section_count): Likewise.
	(Output_segment::section_with_lowest_load_address): Likewise.
	(Output_segment::write_section_headers): Likewise.
	(Output_segment::print_sections_to_map): Likewise.
	* output.h (class Output_data): Remove dynamic_reloc_count_
	field.  Add has_dynamic_reloc_ field.  Make bools into bitfields.
	(Output_data::add_dynamic_reloc): Rewrite.
	(Output_data::has_dynamic_reloc): New function.
	(Output_data::dynamic_reloc_count): Remove.
	(class Output_section): Add order_ field.  Remvoe is_relro_local_,
	is_last_relro_, is_first_non_relro_, is_interp_,
	is_dynamic_linker_section_ fields.  Add order and set_order
	functions.  Remove is_relro_local, set_is_relro_local,
	is_last_relro, set_is_last_relro, is_first_non_relro,
	set_is_first_non_relro functions, is_interp, set_is_interp,
	is_dynamic_linker_section, and set_is_dynamic_linker_section
	functions.
	(class Output_segment): Change Output_data_list from std::list to
	std:;vector.  Add output_lists_ field.  Remove output_data_ and
	output_bss_ fields.  Update declarations.
@
text
@d1658 3
a1660 2
  // --section-start rather than by a script, then we don't want to
  // use it for the file and segment headers.
d1663 20
a1682 2
      && !this->script_options_->saw_sections_clause())
    load_seg = NULL;
d1688 5
@


1.172
log
@	* compressed_output.cc (zlib_decompress): New function.
	(get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* compressed_output.h (get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info)
	Handle compressed debug sections.
	* layout.cc (is_compressed_debug_section): New function.
	(Layout::output_section_name): Map compressed section names to
	canonical names.
	* layout.h (is_compressed_debug_section): New function.
	(is_debug_info_section): Recognize compressed debug sections.
	* merge.cc: Include compressed_output.h.
	(Output_merge_data::do_add_input_section): Handle compressed
	debug sections.
	(Output_merge_string::do_add_input_section): Handle compressed
	debug sections.
	* object.cc: Include compressed_output.h.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(build_compressed_section_map): New function.
	(Sized_relobj::do_read_symbols): Handle compressed debug sections.
	* object.h (Object::section_is_compressed): New method.
	(Object::do_section_is_compressed): New method.
	(Sized_relobj::Compressed_section_map): New type.
	(Sized_relobj::do_section_is_compressed): New method.
	(Sized_relobj::compressed_sections_): New data member.
	* output.cc (Output_section::add_input_section): Handle compressed
	debug sections.
	* reloc.cc: Include compressed_output.h.
	(Sized_relobj::write_sections): Handle compressed debug sections.
@
text
@d412 1
a412 3
			   bool is_interp, bool is_dynamic_linker_section,
			   bool is_relro, bool is_last_relro,
			   bool is_first_non_relro)
d461 2
a462 3
	os = this->make_output_section(name, type, flags, is_interp,
				       is_dynamic_linker_section, is_relro,
				       is_last_relro, is_first_non_relro);
d482 2
a483 3
			      bool is_input_section, bool is_interp,
			      bool is_dynamic_linker_section, bool is_relro,
			      bool is_last_relro, bool is_first_non_relro)
d545 3
a547 4
	  Output_section* os =
	    this->make_output_section(name, type, flags, is_interp,
				      is_dynamic_linker_section, is_relro,
				      is_last_relro, is_first_non_relro);
d589 1
a589 3
  return this->get_output_section(name, name_key, type, flags, is_interp,
				  is_dynamic_linker_section, is_relro,
				  is_last_relro, is_first_non_relro);
d643 2
a644 2
      os = this->make_output_section(name, sh_type, shdr.get_sh_flags(), false,
				     false, false, false, false);
d649 2
a650 2
				       shdr.get_sh_flags(), true, false,
				       false, false, false, false);
d705 2
a706 2
				     shdr.get_sh_flags(), false, false,
				     false, false, false, false);
d711 1
a711 1
				     false, false, false, false, false);
d760 1
a760 2
						 false, false, false,
						 false, false);
d810 1
a810 2
  Output_section* os = this->choose_output_section(object,
						   name,
d812 2
a813 3
						   elfcpp::SHF_ALLOC,
						   false, false, false,
						   false, false, false);
d825 1
a825 2
	    this->choose_output_section(NULL,
					".eh_frame_hdr",
d827 2
a828 3
					elfcpp::SHF_ALLOC,
					false, false, false,
					false, false, false);
d843 2
a844 1
		  hdr_oseg->add_output_section(hdr_os, elfcpp::PF_R, false);
d897 1
a897 3
				bool is_dynamic_linker_section,
				bool is_relro, bool is_last_relro,
				bool is_first_non_relro)
d900 1
a900 4
						   false, false,
						   is_dynamic_linker_section,
						   is_relro, is_last_relro,
						   is_first_non_relro);
d944 3
a946 5
// appropriate.  IS_INTERP is true if this is the .interp section.
// IS_DYNAMIC_LINKER_SECTION is true if this section is used by the
// dynamic linker.  IS_RELRO is true if this is a relro section.
// IS_LAST_RELRO is true if this is the last relro section.
// IS_FIRST_NON_RELRO is true if this is the first non relro section.
d950 2
a951 3
			    elfcpp::Elf_Xword flags, bool is_interp,
			    bool is_dynamic_linker_section, bool is_relro,
			    bool is_last_relro, bool is_first_non_relro)
d984 26
a1009 4
  if (is_interp)
    os->set_is_interp();
  if (is_dynamic_linker_section)
    os->set_is_dynamic_linker_section();
d1012 5
a1016 4
  if (is_last_relro)
    os->set_is_last_relro();
  if (is_first_non_relro)
    os->set_is_first_non_relro();
a1031 17
  // With -z relro, we have to recognize the special sections by name.
  // There is no other way.
  if (!this->script_options_->saw_sections_clause()
      && parameters->options().relro()
      && type == elfcpp::SHT_PROGBITS
      && (flags & elfcpp::SHF_ALLOC) != 0
      && (flags & elfcpp::SHF_WRITE) != 0)
    {
      if (strcmp(name, ".data.rel.ro") == 0)
	os->set_is_relro();
      else if (strcmp(name, ".data.rel.ro.local") == 0)
	{
	  os->set_is_relro();
	  os->set_is_relro_local();
	}
    }

d1049 68
d1206 1
a1206 1
      (*p)->add_output_section(os, seg_flags, true);
d1216 1
a1216 1
      oseg->add_output_section(os, seg_flags, true);
d1234 1
a1234 1
              (*p)->add_output_section(os, seg_flags, false);
d1243 1
a1243 1
          oseg->add_output_section(os, seg_flags, false);
d1253 1
a1253 1
      this->tls_segment_->add_output_section(os, seg_flags, false);
d1263 1
a1263 1
      this->relro_segment_->add_output_section(os, seg_flags, false);
d1279 2
a1280 2
						 sh_flags, false,
						 false, false, false, false);
d1352 2
a1353 2
						       false, false, true,
						       true, false, false);
d2038 1
d2040 4
a2043 1
    flags = elfcpp::SHF_ALLOC;
d2046 1
a2046 2
						   flags, false, false,
						   false, false, false, false);
d2125 2
a2126 2
      this->make_output_section(name, elfcpp::SHT_PROGBITS, flags, false,
				false, false, false, false);
d2287 1
a2287 1
			      false, false, false, false, false);
d2297 2
a2298 2
                                                        0, false, false,
							false, false, false);
d2918 2
a2919 2
							  0, false, false,
							  false, false, false);
d2940 2
a2941 2
				      elfcpp::SHT_SYMTAB_SHNDX, 0, false,
				      false, false, false, false);
d2963 2
a2964 2
							  0, false, false,
							  false, false, false);
d2992 1
a2992 2
						 false, false, false, false,
						 false);
d3109 3
a3111 2
						       false, false, true,
						       false, false, false);
d3141 1
a3141 1
				    false, false, true, false, false, false);
d3164 3
a3166 2
						       false, false, true,
						       false, false, false);
d3189 4
a3192 6
      Output_section* hashsec = this->choose_output_section(NULL, ".hash",
							    elfcpp::SHT_HASH,
							    elfcpp::SHF_ALLOC,
							    false, false, true,
							    false, false,
							    false);
d3214 4
a3217 6
      Output_section* hashsec = this->choose_output_section(NULL, ".gnu.hash",
							    elfcpp::SHT_GNU_HASH,
							    elfcpp::SHF_ALLOC,
							    false, false, true,
							    false, false,
							    false);
d3320 3
a3322 2
						     false, false, true,
						     false, false, false);
d3347 1
a3347 2
					 false, false, true, false, false,
					 false);
d3372 1
a3372 2
					  false, false, true, false, false,
					  false);
d3412 2
a3413 2
						     false, true, true,
						     false, false, false);
d3420 1
a3420 1
      oseg->add_output_section(osec, elfcpp::PF_R, false);
d3528 2
a3529 3
      oseg->add_output_section(this->dynamic_section_,
			       elfcpp::PF_R | elfcpp::PF_W,
			       false);
d3627 1
a3627 1
              && (*p)->dynamic_reloc_count() > 0)
d3646 1
a3646 1
              && ((*p)->dynamic_reloc_count() > 0))
@


1.171
log
@	* layout.cc (gdb_sections): Add .debug_types.
	(lines_only_debug_sections): Likewise.
@
text
@d947 10
a956 1
  return (strncmp(secname, ".debug", sizeof(".debug") - 1) == 0);
d3784 14
@


1.170
log
@	* gold.h (is_wildcard_string): New function.
	* layout.cc (Layout::layout): Pass this pointer to add_input_section.
	(Layout::layout_eh_frame): Ditto.
	(Layout::find_section_order_index): New method.
	(Layout::read_layout_from_file): New method.
	* layout.h (Layout::find_section_order_index): New method.
	(Layout::read_layout_from_file): New method.
	(Layout::input_section_position_): New private member.
	(Layout::input_section_glob_): New private member.
	* main.cc (main): Call read_layout_from_file here.
	* options.h (--section-ordering-file): New option.
	* output.cc (Output_section::input_section_order_specified_): New
	member.
	(Output_section::Output_section): Initialize new member.
	(Output_section::add_input_section): Add new parameter.
	Keep input sections when --section-ordering-file is used.
	(Output_section::set_final_data_size): Sort input sections when
	section ordering file is specified.
	(Output_section::Input_section_sort_entry): Add new parameter.
	Check sorting type.
	(Output_section::Input_section_sort_entry::compare_section_ordering):
	New method.
	(Output_section::Input_section_sort_compare::operator()): Change to
	consider section_order_index.
	(Output_section::Input_section_sort_init_fini_compare::operator()):
	Change to consider section_order_index.
	(Output_section::Input_section_sort_section_order_index_compare
	::operator()): New method.
	(Output_section::sort_attached_input_sections): Change to sort
	according to section order when specified.
	(Output_section::add_input_section<32, true>): Add new parameter.
	(Output_section::add_input_section<64, true>): Add new parameter.
	(Output_section::add_input_section<32, false>): Add new parameter.
	(Output_section::add_input_section<64, false>): Add new parameter.
	* output.h (Output_section::add_input_section): Add new parameter.
	(Output_section::input_section_order_specified): New
	method.
	(Output_section::set_input_section_order_specified): New method.
	(Input_section::Input_section): Initialize section_order_index_.
	(Input_section::section_order_index): New method.
	(Input_section::set_section_order_index): New method.
	(Input_section::section_order_index_): New member.
	(Input_section::Input_section_sort_section_order_index_compare): New
	struct.
	(Output_section::input_section_order_specified_): New member.
	* script-sections.cc (is_wildcard_string): Delete and move modified
	method to gold.h.
	(Output_section_element_input::Output_section_element_input): Modify
	call to is_wildcard_string.
	(Output_section_element_input::Input_section_pattern
	::Input_section_pattern): Ditto.
	(Output_section_element_input::Output_section_element_input): Ditto.
	* testsuite/Makefile.am (final_layout): New test case.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/final_layout.cc: New file.
	* testsuite/final_layout.sh: New file.
@
text
@d246 1
d260 1
@


1.169
log
@	* layout.cc (Layout::layout_reloc): In relocatable link don't
	combine reloc sections for grouped sections.
@
text
@d29 1
d32 1
d673 1
a673 1
  *off = os->add_input_section(object, shndx, name, shdr, reloc_shndx,
d891 1
a891 1
      *off = os->add_input_section(object, shndx, name, shdr, reloc_shndx,
d1647 66
@


1.168
log
@2010-04-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::choose_output_section): Handle script section
	types.
	(Layout::make_output_section_for_script): Add section type parameter.
	Handle script section types.
	* layout.h (Layout::make_output_section_for_script): Add section
	type parameter.
	* output.cc (Output_section::Output_section): Initialize data member
	is_noload_.
	(Output_section::do_reset_address_and_file_offset): Do not set address
	to 0 if section is a NOLOAD section.
	* output.h (Output_section::is_noload): New method.
	(Output_section::set_is_noload): Ditto.
	(Output_section::is_noload_): New data member.
	* script-c.h (Script_section_type): New enum type.
	(struct Parser_output_section_header): Add new file section_type.
	* script-sections.cc (Sections_element::output_section_name): Add
	parameter for returning script section type.
	(Output_section_definition::output_section_name): Ditto.
	(Output_section_definition::section_type)P; New method.
	(Output_section_definiton::script_section_type_name): Ditto.
	(Output_section_definition::script_section_type_): New data member.
	(Output_section_definition::Output_section_definition): Initialize
	data member Output_section_definition::script_section_type_.
	(Output_section_definition::create_sections): Pass script section type
	to Layout::make_output_section_for_script.
	(Output_section_definition::output_section_name): Return script
	section type to caller.
	(Output_section_definition::set_section_address): Do not advance
	dot value and load address if section type is NOLOAD.  Set address
	of NOLOAD sections regardless of section flags.
	(Output_section_definition::print): Print section type if it is
	not SCRIPT_SECTION_TYPE_NONE.
	(Output_section_definition::section_type): New method.
	(Output_section_definition::script_section_type_name): Ditto.
	(Script_sections::output_section_name): Add new parameter
	PSECTION_TYPE for returning script section type.  Pass it to
	section elements.  Handle discard sections.
	(Sort_output_sections::operator()): Handle NOLOAD sections.
	* script-sections.h (Script_sections::Section_type): New enum type.
   	(Script_sections::output_section_name): Add a new parameter for
	returning script section type.
	* script.cc (script_keyword_parsecodes): Add keywords COPY, DSECT,
	INFO and NOLOAD.
	* yyscript.y (union): Add new field SECTION_TYPE.
	(COPY, DSECT, INFO, NOLOAD): New tokens.
	(opt_address_and_section_type): Change type to output_section_header.
	(section_type): New non-terminal
	(section_header): Handle section type.
 	(opt_address_and_section_type): Return section type value.
@
text
@d702 14
a715 5
  Output_section* os = this->choose_output_section(object, name.c_str(),
						   sh_type,
						   shdr.get_sh_flags(),
						   false, false, false,
						   false, false, false);
@


1.167
log
@2010-03-01  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::Layout): Force section types of .init_array*,
	.preinit_array* and .fini_array* sections.
	* output.cc (Output_section::Input_section_sort_entry::has_priority):
	Fix check of return value of std::string::find.().
	(Output_section::Input_section_sort_compare::operator()): Remove
	comment about .init_array.
	(Output_section::Input_section_sort_init_fini_compare::operator()):
	New method.
	(Output_section::sort_attached_input_sections): Handle .init_array
	and .fini_array specially.
	* output.h (Output_section::Inut_section_sort_compare): Update
	comment.
	(Output_section::Input_section_sort_init_fini_compare): New struct.
@
text
@d505 3
a507 1
      name = ss->output_section_name(file_name, name, &output_section_slot);
d514 12
d550 19
d1193 3
a1195 1
Layout::make_output_section_for_script(const char* name)
d1198 3
d1202 1
a1202 1
						 elfcpp::SHF_ALLOC, false,
d1205 2
@


1.166
log
@2010-02-24  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_output_data_got): New class.
	(ARM_TCB_SIZE): New constant
	(Target_arm): Use Arm_output_data_got instead of Output_data_got.
	(Arm_output_section::fix_exidx_coverage): Add a parameter for layout.
	If user uses a script with a SECTIONS clause, issue only a warning
	for a misplaced EXIDX input section.  Otherwise, issue an error.
 	(Arm_relobj::do_gc_process_relocs): Exit early if we are not doing
	garbage collection.
	(Target_arm::got_mode_index_entry): Handle static linking.
	(Target_arm::Scan::local): Ditto.
	(Target_arm::Scan::global): Ditto.
	(Target_arm::Relocate::relocate_tls): Handle static linking.  Fix
	all incorrectly implemented relocations.
	(Target_arm::fix_exidx_coverage): Pass layout to
	Arm_output_section::fix_exidx_coverage.
	* layout.cc (Layout::section_name_mapping): Remove trailing dots
	from ".ARM.exidx." and ".ARM.extab.".
@
text
@d585 22
d613 2
a614 3
      os = this->make_output_section(name, shdr.get_sh_type(),
				     shdr.get_sh_flags(), false, false,
				     false, false, false);
d618 1
a618 1
      os = this->choose_output_section(object, name, shdr.get_sh_type(),
@


1.165
log
@	* output.h (Output_data_dynamic::add_section_size): New method
	that takes two Output_data objects.
	(Output_data_dynamic::Dynamic_entry): Create storage for secondary
	entry param.  Handle it in initializers.
	* output.cc (Output_data_dynamic::Dynamic_entry::write): For
	DYNAMIC_SECTION_SIZE, add in second object size if non-NULL.
	* layout.h (Layout::add_target_dynamic_tags): Add dynrel_includes_plt
	arg.
	* layout.cc (Layout::add_target_dynamic_tags): If dynrel_includes_plt,
	and .rela.plt exists, set DT_REL{,A}SZ to sum of .rela.dyn and .rela.plt
	* arm.cc (Target_arm::do_finalize_sections): Update to pass false
	for dynrel_includes_plt.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::make_plt_entry): Force .rela.dyn to be output
	before .rela.plt
	(Target_sparc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt.
	* powerpc.cc (Target_powerpc::make_plt_entry): Force .rela.dyn to be
	output before .rela.plt
	(Target_powerpc::do_finalize_sections): Update to pass true for
	dynrel_includes_plt when 32-bit.
@
text
@d3572 1
a3572 1
  MAPPING_INIT(".ARM.extab.", ".ARM.extab"),
d3574 1
a3574 1
  MAPPING_INIT(".ARM.exidx.", ".ARM.exidx"),
@


1.164
log
@2010-01-22  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Target_arm::do_relax): Record an output section for section
	offset adjustment it contains any stub table that has changed.
	* layout.cc (Layout::clean_up_after_relaxation): Adjust section
	offsets in an output section if necessary.
	* output.cc (Output_section::Output_section): Initialize
	section_offsets_need_adjustments_.
	(Output_section::add_input_section_for_script): Renamed to
	Output_section::add_simple_input_section.
	(Output_section::save_states): Add a comment.
	(Output_section::discard_states): New method defintion.
	(Output_section::adjust_section_offsets): Same.
	* output.h (Output_section::add_input_section_for_script): Renamed to
	Output_section::add_simple_input_section.
	(Output_section::discard_states): New method declaration.
	(Output_section::adjust_section_offsets): Same.
	(Output_section::section_offsets_need_adjustment,
	Output_section::set_section_offsets_need_adjustment): New method
	definitions.
	(Output_section::section_offsets_need_adjustment_): New data member.
	* script-sections.cc
	(Output_section_element_input::set_section_address): Adjust code for
	renaming of Output_section::add_input_section_for_script.
	(Orphan_output_section::set_section_address): Same.
@
text
@d3243 1
a3243 1
				bool add_debug)
d3264 6
a3269 2
      odyn->add_section_size(use_rel ? elfcpp::DT_RELSZ : elfcpp::DT_RELASZ,
			     dyn_rel);
@


1.163
log
@	PR 11072
	* layout.cc (Layout::include_section): Remove .gnu_debuglink
	sections.
@
text
@d1404 8
a1412 1
      (*p)->restore_states();
@


1.162
log
@	PR 10287
	PR 11063
	* i386.cc (class Target_i386): Change return type of plt_section
	to be non-const.
	(class Output_data_plt_i386): Add tls_desc_rel_ field.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize
	tls_desc_rel_ field.
	(Output_data_plt_i386::rel_tls_desc): New function.
	(Target_i386::rel_tls_desc_section): New function.
	(Target_i386::Scan::local): Rewrite R_386_TLS_GOTDESC handling.
	(Target_i386::Scan::global): For R_386_TLS_GOTDESC put
	R_386_TLS_DESC reloc in rel_tls_desc_section.
	* x86_64.cc (class Target_x86_64): Add tlsdesc_reloc_info_ field.
	Define struct Tlsdesc_info.
	(Target_x86_64::Target_x86_64): Initialize tlsdesc_reloc_info_.
	(Target_x86_64::do_reloc_symbol_index): New function.
	(Target_x86_64::add_tlsdesc_info): New function.
	(class Output_data_plt_x86_64): Add tlsdesc_rel_ field.
	(Output_data_plt_x86_64::Output_data_plt_x86_64): Initialize
	tlsdesc_rel_ field.
	(Output_data_plt_x86_64::rela_plt): Rename from rel_plt.  Change
	all callers.
	(Output_data_plt_x86_64::rela_tlsdesc): New function.
	(Target_x86_64::rela_tlsdesc_section): New function.
	(Target_x86_64::Scan::local): Rewrite R_X86_64_GOTPC32_TLSDESC
	handling.
	(Target_x86_64::Scan::global): For R_X86_64_GOTPC32_TLSDESC put
	(Target_x86_64::do_reloc_addend): New function.
	R_X86_64_TLSDESC reloc in rela_tlsdesc_section.
	* output.h (class Output_reloc) [SHT_REL]: Add new constructor
	declarations.  Define TARGET_CODE.  Add arg field to u1_ union.
	(Output_reloc::type): New function.
	(Output_reloc::is_local_section_symbol): Check for TARGET_CODE.
	(Output_reloc::is_target_specific): New function.
	(Output_reloc::target_arg): New function.
	(class Output_reloc) [SHT_RELA]: Add four new constructors for
	absolute relocs and target specific relocs.
	(class Output_data_reloc) [SHT_REL]: Add add_absolute and
	add_target_specific.
	(class Output_data_reloc) [SHT_RELA]: Likewise.
	* output.cc (Output_reloc::Output_reloc): Add four new versions
	for absolute relocs and target specific relocs.
	(Output_reloc::set_needs_dynsym_index): Add TARGET_CODE case.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Check that local_sym_index_
	is not TARGET_CODE or 0.
	(Output_reloc::symbol_value): Likewise.
	(Output_reloc::write) [SHT_RELA]: Call target for target specific
	reloc.
	* target.h (class Target): Add reloc_symbol_index and reloc_addend
	functions.  Add do_reloc_symbol_index and do_reloc_addend virtual
	functions.
	* layout.cc (add_target_dynamic_tags): Use output section for
	DT_PLTRELSZ and DT_JMPREL.
@
text
@d355 5
@


1.161
log
@	PR 11061
	* output.h (class Output_reloc) [SHT_RELA]: Add is_relative
	function.
	(class Output_data_reloc_generic): Define.
	(class Output_data_reloc_base): Change base class to
	Output_data_reloc_generic.  Change add() method to call
	bump_relative_reloc_count for a relative reloc.  Remove
	sort_relocs_ field.
	* output.cc (Output_data_reloc_base::do_write): Change sort_reloc_
	to sort_relocs().
	* layout.cc (Layout::add_target_dynamic_tags): Change dyn_rel to
	Output_data_reloc_generic*.  Add DT_RELCOUNT/DT_RELACOUNT tag if
	appropriate.
	* layout.h (class Layout): Update declaration.
@
text
@d3218 2
a3219 1
// and we also set DT_PLTREL.
d3242 2
a3243 2
      odyn->add_section_size(elfcpp::DT_PLTRELSZ, plt_rel);
      odyn->add_section_address(elfcpp::DT_JMPREL, plt_rel);
@


1.160
log
@	* output.h (class Output_data): Add const version of
	output_section and do_output_section.
	(class Output_section_data): Add const version of
	do_output_section.
	(class Output_section): Likewise.
	* layout.cc (Layout::add_target_dynamic_tags): New function.
	* layout.h (class Layout): Update declarations.
	* arm.cc (Target_arm::do_finalize_sections): Use
	add_target_dynamic_tags.
	* i386.cc (Target_i386::do_finalize_sections): Likewise.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Likewise.
	* sparc.cc (Target_sparc::do_finalize_sections): Likewise.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Likewise.
@
text
@d3229 2
a3230 1
				const Output_data* dyn_rel, bool add_debug)
d3277 10
@


1.159
log
@	* options.h (class General_options): Add -z text and -z textoff.
	* layout.cc (Layout::finish_dynamic_section): Implement -z text.
@
text
@d3209 77
@


1.158
log
@	* gc.h (Garbage_collection::Cident_section_map): New typedef.
	(Garbage_collection::cident_sections): New function.
	(Garbage_collection::add_cident_section): New function.
	(Garbage_collection::cident_sections_): New member.
	(gc_process_relocs): Add references to sections whose names are C
	identifiers.
	* gold.h (cident_section_start_prefix): New constant.
	(cident_section_stop_prefix): New constant.
	(is_cident): New function.
	* layout.cc (Layout::define_section_symbols): Replace string constants
	with the newly defined constants.
	* object.cc (Sized_relobj::do_layout): Track sections whose names are
	C identifiers.
	* testsuite/Makefile.am: Add gc_orphan_section_test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/gc_orphan_section_test.cc: New file.
	* testsuite/gc_orphan_section_test.sh: New file.
@
text
@d3356 4
a3359 2
      if (parameters->options().warn_shared_textrel()
	  && parameters->options().shared())
@


1.157
log
@	PR 10980
	* options.h (class General_options): Add --warn-shared-textrel.
	* layout.cc (Layout::finish_dynamic_section): Implement
	--warn-shared-textrel.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d1235 1
a1235 6
      if (name[strspn(name,
		      ("0123456789"
		       "ABCDEFGHIJKLMNOPWRSTUVWXYZ"
		       "abcdefghijklmnopqrstuvwxyz"
		       "_"))]
	  == '\0')
d1238 4
a1241 2
	  const std::string start_name("__start_" + name_string);
	  const std::string stop_name("__stop_" + name_string);
@


1.156
log
@	PR 10980
	* options.cc (General_options::parse_section_start): New function.
	(General_options::section_start): New function.
	(General_options::General_options): Initialize all members.
	* options.h: Include <map>
	(class General_options): Add --section-start.  Add section_starts_
	member.
	* layout.cc (Layout::attach_allocated_section_to_segment): If
	--section-start was used, set the address of the segment.  Remove
	local sort_sections.
	(Layout::relaxation_loop_body): If the address of the load segment
	has been set by --section-start, don't use it.
	* output.h (Output_segment::update_flags_for_output_section): New
	function.
	* output.cc (Output_segment::add_output_section): Call
	update_flags_for_output_section.
@
text
@d3358 4
@


1.155
log
@	PR 10979
	* layout.cc (Layout::relaxation_loop_body): If -Ttext was used,
	don't put the file header and segment headers in the text
	segment.
@
text
@d1028 3
a1030 1
  bool sort_sections = !this->script_options_->saw_sections_clause();
d1059 12
a1070 1
      (*p)->add_output_section(os, seg_flags, sort_sections);
d1080 3
a1082 1
      oseg->add_output_section(os, seg_flags, sort_sections);
d1510 8
@


1.154
log
@	PR 10979
	* script.cc (read_input_script): If we see a new SECTIONS clause,
	and we have added an input section, give an error.
	* layout.h (class Layout): Add have_added_input_section function.
	Add have_added_input_section_ field.
	* layout.cc (Layout::Layout): Initialize
	have_added_input_section_.
	(Layout::layout): Set have_added_input_section_.
	(Layout::layout_eh_frame): Likewise.
@
text
@d1485 6
@


1.153
log
@	PR 10450
	* layout.cc (Layout::create_dynamic_symtab): Only set entsize of
	.gnu.hash table for a 32-bit target.
@
text
@d195 1
d614 1
d823 1
@


1.152
log
@	* layout.cc (Layout::Layout): Initialize increase_relro_.
	(Layout::get_output_section): Add is_relro, is_last_relro, and
	is_first_non_relro parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::add_output_section_data): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::set_segment_offsets): Clear increase_relro when using a
	linker script.
	* layout.h (class Layout): Add increase_relro method.  Add
	increase_relro_ field.  Update declarations.
	* output.cc (Output_section::Output_section): Initialize
	is_last_relro_ and is_first_non_relro_.
	(Output_segment::add_output_section): Group relro sections is
	do_sort is true.  Handle is_last_relro and is_first_non_relro.
	(Output_segment::maximum_alignment): Remove relro handling.
	(Output_segment::set_section_addresses): Add increase_relro
	parameter.  Change all callers.  Add initial alignment to align
	relro sections on separate page.  Remove old relro handling.
	(Output_segment::set_section_list_addresses): Remove in_relro
	parameter.  Change all callers.
	(Output_segment::set_offset): Add increase parameter.  Change all
	callers.  Remove old relro handling.
	* output.h (class Output_section): Add new methods: is_last_relro,
	set_is_last_relro, is_first_non_relro, set_is_first_non_relro.
	Add is_last_relro_ and is_first_non_relro_ fields.
	* i386.cc (Target_i386::got_section): Don't call set_is_relro.
	Create separate .got.plt section.  Call increase_relro.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/relro_script_test.t: Add .got.plt.
@
text
@d2981 6
a2986 1
      hashsec->set_entsize(4);
@


1.151
log
@	PR 10450
	* layout.cc (Layout::Layout): Initialize dynamic_symbol_ field.
	(Layout::create_initial_dynamic_sections): Set dynamic_symbol_.
	(Layout::finalize): Call set_dynamic_symbol_size.
	(Layout::set_dynamic_symbol_size): New function.
	* layout.h (class Layout): Add dynamic_symbol_ field.  Declare
	set_dynamic_symbol_size.
@
text
@d178 1
d395 3
a397 1
// is used by the dynamic linker.
d402 3
a404 1
			   bool is_interp, bool is_dynamic_linker_section)
d454 2
a455 1
				       is_dynamic_linker_section);
d467 4
a470 2
// dynamic linker.  This will return NULL if the input section should
// be discarded.
d476 2
a477 1
			      bool is_dynamic_linker_section)
d527 2
a528 1
				      is_dynamic_linker_section);
d552 2
a553 1
				  is_dynamic_linker_section);
d586 2
a587 1
				     shdr.get_sh_flags(), false, false);
d593 1
a593 1
				       false);
d644 1
d693 1
d748 1
d765 1
d833 3
a835 1
				bool is_dynamic_linker_section)
d839 3
a841 1
						   is_dynamic_linker_section);
d878 3
a880 1
// dynamic linker.
d885 2
a886 1
			    bool is_dynamic_linker_section)
d923 6
d1121 1
a1121 1
						 false);
d1191 2
a1192 2
						       false, false, true);
  this->dynamic_section_->set_is_relro();
d1798 1
a1798 1
						   false);
d1878 1
a1878 1
				false);
d2039 1
a2039 1
			      false, false);
d2049 2
a2050 1
                                                        0, false, false);
d2236 4
d2328 1
d2355 1
d2393 3
a2395 1
	(*p)->set_offset();
d2670 2
a2671 1
							  0, false, false);
d2693 1
a2693 1
				      false);
d2715 2
a2716 1
							  0, false, false);
d2744 2
a2745 1
						 false, false);
d2862 2
a2863 1
						       false, false, true);
d2893 1
a2893 1
				    false, false, true);
d2916 2
a2917 1
						       false, false, true);
d2943 3
a2945 1
							    false, false, true);
d2970 3
a2972 1
							    false, false, true);
d3070 2
a3071 1
						     false, false, true);
d3096 2
a3097 1
					 false, false, true);
d3122 2
a3123 1
					  false, false, true);
d3163 2
a3164 1
						     false, true, true);
@


1.150
log
@	* symtab.h (class Symbol_table): Add enum Defined.
	* resolve.cc (Symbol_table::should_override): Add defined
	parameter.  Change all callers.  Test whether object is NULL
	before calling a method on it.
	(Symbol_table::report_resolve_problem): Add defined parameter.
	Change all callers.
	(Symbol_table::should_override_with_special): Likewise.
	* symtab.cc (Symbol_table::define_in_output_data): Add defined
	parameter.  Change all callers.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::define_in_output_segment): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::define_as_constant): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* script.h (class Symbol_assignment): Add is_defsym parameter to
	constructor; change all callers.
	* script.cc (Script_options::add_symbol_assignment): Add is_defsym
	parameter.  Change all callers.  Add is_defsym_ field.
	(class Parser_closure): Add parsing_defsym parameter to
	constructor; change all callers.  Add parsing_defsym accessor
	function.  Add parsing_defsym_ field.
@
text
@d183 1
d1165 5
a1169 4
  symtab->define_in_output_data("_DYNAMIC", NULL, Symbol_table::PREDEFINED,
				this->dynamic_section_, 0, 0,
				elfcpp::STT_OBJECT, elfcpp::STB_LOCAL,
				elfcpp::STV_HIDDEN, 0, false, false);
d1585 4
d3312 18
@


1.149
log
@	* layout.cc (Layout::create_shstrtab): Only write out after input
	sections if we are compressing debug sections.
@
text
@d1164 2
a1165 1
  symtab->define_in_output_data("_DYNAMIC", NULL, this->dynamic_section_, 0, 0,
d1199 1
d1212 1
@


1.148
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d2697 8
a2704 4
  // We can't write out this section until we've set all the section
  // names, and we don't set the names of compressed output sections
  // until relocations are complete.
  os->set_after_input_sections();
@


1.147
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d163 1
a163 1
Layout::Layout(int number_of_input_files, Script_options* script_opts)
d165 1
a165 1
    script_options_(script_opts),
d2834 1
a2834 1
      Output_section* dyn_sym_xindex =
d2842 1
a2842 1
      dyn_sym_xindex->add_output_section_data(this->dynsym_xindex_);
d2844 3
a2846 3
      dyn_sym_xindex->set_link_section(dynsym);
      dyn_sym_xindex->set_addralign(4);
      dyn_sym_xindex->set_entsize(4);
d2848 1
a2848 1
      dyn_sym_xindex->set_after_input_sections();
d3492 1
a3492 1
Layout::get_allocated_sections(Section_list* sec_list) const
d3498 1
a3498 1
      sec_list->push_back(*p);
d3541 1
a3541 1
      const Output_section* sym_tab_section = this->symtab_section_;
d3548 1
a3548 1
	      gold_assert(sym_tab_section != NULL);
d3551 2
a3552 2
	      off_t off = (sym_tab_section->offset()
			   + index * sym_tab_section->entsize());
d3558 1
a3558 1
  const Output_section* dyn_sym_section = this->dynsym_section_;
d3565 1
a3565 1
	  gold_assert(dyn_sym_section != NULL);
d3568 2
a3569 2
	  off_t off = (dyn_sym_section->offset()
		       + index * dyn_sym_section->entsize());
@


1.146
log
@2009-12-03  Doug Kwan  <dougkwan@@google.com>

	* arm.cc: Remove comment about missing .ARM.exidx section symbols.
	(Target_arm::do_finalize_sections): Add parameter for symbol table
	pointer.  Add __exidx_start and __exidx_end symbols as appropriate.
	* i386.cc (Target_i386::do_finalize_sections): Add an additional
	parameter for symbol table pointer.
	* layout.cc (Layout::finalize): Call Target::finalize_sections with
	an additional parameter for a pointer to symbol table.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add an additional
	parameter for a symbol table pointer.
	* sparc.cc (Target_sparc::do_finalize_sections): Ditto.
	* target.h (Target::finalize_sections, Target::do_finalize_sections):
	Ditto.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add an additional
	parameter for a symbol table pointer.
@
text
@d163 1
a163 1
Layout::Layout(int number_of_input_files, Script_options* script_options)
d165 1
a165 1
    script_options_(script_options),
d2834 1
a2834 1
      Output_section* dynsym_xindex =
d2842 1
a2842 1
      dynsym_xindex->add_output_section_data(this->dynsym_xindex_);
d2844 3
a2846 3
      dynsym_xindex->set_link_section(dynsym);
      dynsym_xindex->set_addralign(4);
      dynsym_xindex->set_entsize(4);
d2848 1
a2848 1
      dynsym_xindex->set_after_input_sections();
d3492 1
a3492 1
Layout::get_allocated_sections(Section_list* section_list) const
d3498 1
a3498 1
      section_list->push_back(*p);
d3541 1
a3541 1
      const Output_section* symtab_section = this->symtab_section_;
d3548 1
a3548 1
	      gold_assert(symtab_section != NULL);
d3551 2
a3552 2
	      off_t off = (symtab_section->offset()
			   + index * symtab_section->entsize());
d3558 1
a3558 1
  const Output_section* dynsym_section = this->dynsym_section_;
d3565 1
a3565 1
	  gold_assert(dynsym_section != NULL);
d3568 2
a3569 2
	  off_t off = (dynsym_section->offset()
		       + index * dynsym_section->entsize());
@


1.145
log
@	PR 10880
	* object.h (class Object): Add is_needed and set_is_needed
	methods.  Add is_needed_ field.  Make bool fields into bitfields.
	* symtab.cc (Symbol_table::set_dynsym_indexes): If a symbol is
	defined in a dynamic object and referenced by a regular object,
	set is_needed for the dynamic object.
	* layout.cc (Layout::finish_dynamic_section): Don't add DT_NEEDED
	if the file is marked with as_needed and it is not needed.
@
text
@d1536 1
a1536 1
  target->finalize_sections(this, input_objects);
@


1.144
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d3133 8
a3140 1
      // FIXME: Handle --as-needed.
@


1.143
log
@2009-10-30  Doug Kwan  <dougkwan@@google.com>

elfcpp/ChangeLog:
	* arm.h (EF_ARM_BE8, EF_ARM_EABIMASK, EF_ARM_EABI_UNKNOWN,
	EF_ARM_EABI_VER1, EF_ARM_EABI_VER2, EF_ARM_EABI_VER3,
	EF_ARM_EABI_VER4, EF_ARM_EABI_VER5): New enums for processor-specific
	flags.
	(arm_eabi_version): New inline function.
	* elfcpp.h: Add a comment about DT_ENCODING.

gold/ChangeLog:
	* arm.cc (Arm_relobj::processor_specific_flags): New method
	definition.
	(Arm_relobj::do_read_symbols): New method declaration.
	(Arm_relobj::processor_specific_flags_): New data member declaration.
	(Arm_dynobj): New class definition.
	(Target_arm::do_finalize_sections): Add input_objects parameter.
	(Target_arm::do_adjust_elf_header): New method declaration.
	(Target_arm::are_eabi_versions_compatible,
	(Target_arm::merge_processor_specific_flags): New method declaration.
	(Target_arm::do_make_elf_object): New overloaded method definitions
	and declaration.
	(Arm_relobj::do_read_symbols): New method definition.
	(Arm_dynobj::do_read_symbols): Ditto.
	(Target_arm::do_finalize_sections): Add input_objects parameters.
	Merge processor-specific flags from all input objects.
	(Target_arm::are_eabi_versions_compatible,
	Target_arm::merge_processor_specific_flags,
	Target_arm::do_adjust_elf_header, Target_arm::do_make_elf_object):
	New method definitions.
	* i386.cc (Target_i386::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* layout.cc (Layout::finalize): Pass input objects to target's.
	finalize_sections function.
	* output.cc (Output_file_header::do_sized_write): Set ELF file
	header's processor-specific flags.
	* powerpc.cc (Target_powerpc::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
	* sparc.cc (Target_sparc::do_finalize_sections): Same.
	* target.h (Input_objects): New forward class declaration.
	(Target::processor_specific_flags,
	Target::are_processor_specific_flags_sect): New method definitions.
	(Target::finalize_sections): Add input_objects parameter.
	(Target::Target): Initialize processor_specific_flags_ and
	are_processor_specific_flags_set_.
	(Target::do_finalize_sections): Add unnamed Input_objects pointer type
	parameter.
	(Target::set_processor_specific_flags): New method definition.
	(Target::processor_specific_flags_,
	Target::are_processor_specific_flags_set_): New data member
	declarations.
	* x86_64.cc (Target_x86_64::do_finalize_sections): Add unnamed
	Input_objects pointer type parameter.
@
text
@d391 3
a393 1
// pool, and NAME_KEY is the key.
d397 2
a398 1
			   elfcpp::Elf_Word type, elfcpp::Elf_Xword flags)
d447 2
a448 1
	os = this->make_output_section(name, type, flags);
d458 4
a461 2
// file.  This will return NULL if the input section should be
// discarded.
d466 2
a467 1
			      bool is_input_section)
d515 3
a517 1
	  Output_section* os = this->make_output_section(name, type, flags);
d540 2
a541 1
  return this->get_output_section(name, name_key, type, flags);
d574 1
a574 1
				     shdr.get_sh_flags());
d579 2
a580 1
				       shdr.get_sh_flags(), true);
d631 1
a631 1
						   false);
d678 2
a679 1
						 shdr.get_sh_flags());
d733 1
a733 1
						   false);
d749 1
a749 1
					false);
d764 1
a764 1
		  hdr_oseg->add_output_section(hdr_os, elfcpp::PF_R);
d815 2
a816 1
				Output_section_data* posd)
d819 2
a820 1
						   false);
d855 3
a857 1
// appropriate.
d861 2
a862 1
			    elfcpp::Elf_Xword flags)
a869 1

d895 5
d995 2
d1024 1
a1024 1
      (*p)->add_output_section(os, seg_flags);
d1034 1
a1034 1
      oseg->add_output_section(os, seg_flags);
d1050 1
a1050 1
              (*p)->add_output_section(os, seg_flags);
d1059 1
a1059 1
          oseg->add_output_section(os, seg_flags);
d1069 1
a1069 1
      this->tls_segment_->add_output_section(os, seg_flags);
d1079 1
a1079 1
      this->relro_segment_->add_output_section(os, seg_flags);
d1090 2
a1091 1
						 elfcpp::SHF_ALLOC);
d1161 1
a1161 1
						       false);
d1759 2
a1760 1
						   flags, false);
d1839 2
a1840 1
      this->make_output_section(name, elfcpp::SHT_PROGBITS, flags);
d2000 2
a2001 1
			      elfcpp::SHT_GNU_INCREMENTAL_INPUTS, 0);
d2011 1
a2011 1
                                                        0);
d2623 1
a2623 1
							  0);
d2644 2
a2645 1
				      elfcpp::SHT_SYMTAB_SHNDX, 0);
d2667 1
a2667 1
							  0);
d2694 2
a2695 1
  Output_section* os = this->make_output_section(name, elfcpp::SHT_STRTAB, 0);
d2808 1
a2808 1
						       false);
d2838 1
a2838 1
				    false);
d2861 1
a2861 1
						       false);
d2887 1
a2887 1
							    false);
d2912 1
a2912 1
							    false);
d3010 1
a3010 1
						     false);
d3035 1
a3035 1
					 false);
d3060 1
a3060 1
					  false);
d3100 1
a3100 1
						     false);
d3107 1
a3107 1
      oseg->add_output_section(osec, elfcpp::PF_R);
d3123 2
a3124 1
			       elfcpp::PF_R | elfcpp::PF_W);
@


1.142
log
@	* layout.cc (Layout::relaxation_loop_body): Don't crash if we see
	program headers with no load segment if there is a linker script.
@
text
@d1512 1
a1512 1
  target->finalize_sections(this);
@


1.141
log
@	* layout.cc (Layout::set_segment_offsets): Align the file offset
	to the segment aligment for -N or -n with no load segment.
	* output.cc (Output_segment::add_output_section): Don't crash if
	the first section is a TLS section.
	(Output_segment::set_section_list_addresses): Print an error
	message if the address moves backward in a linker script.
	* script-sections.cc
	(Output_section_element_input::set_section_addresses): Don't
	increase *dot_value for a SHF_TLS/SHT_NOBITS section.
	(Orphan_output_section::set_section_addresses): Likewise.
@
text
@d1424 3
a1426 1
  gold_assert(phdr_seg == NULL || load_seg != NULL);
@


1.140
log
@2009-10-15  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::finish_dynamic_section): Generate tags
	DT_FINI_ARRAY, DT_FINI_ARRAYSZ, DT_INIT_ARRAY, DT_INIT_ARRAYSZ,
	DT_PREINIT_ARRAY, DT_PREINIT_ARRAYSZ as needed. If -Bsymbolic is
	used, add DT_SYMBOLIC and set DF_SYMBOLIC in DT_FLAGS.
@
text
@d2240 13
@


1.139
log
@	Add support for -pie.
	* options.h (class General_options): Add -pie and
	--pic-executable.
	(General_options::output_is_position_independent): Test -pie.
	(General_options::output_is_executable): Return true if not shared
	and not relocatable.
	(General_options::output_is_pie): Remove.
	* options.cc (General_options::finalize): Reject incompatible uses
	of -pie.
	* gold.cc (queue_middle_tasks): A -pie link is not static.
	* symtab.h (Symbol::needs_plt_entry): Return false if -pie.
	* symtab.cc (Symbol::final_value_is_known): Return false if
	output_is_position_independent.
	* layout.cc (Layout::set_segment_offsets): Start at address 0 if
	output_is_position_independent.
	* output.cc (Output_file_header::do_sized_write): Use ET_DYN if
	output_is_position_independent.
	* i386.cc (Output_data_plt_i386::do_write): Use the PIC PLT if
	output_is_position_independent.
	* testsuite/Makefile.am (check_PROGRAMS): Add basic_pie_test and
	two_file_pie_test.
	(basic_pie_test.o, basic_pie_test): New targets.
	(two_file_test_1_pie.o, two_file_test_1b_pie.o): New targets.
	(two_file_test_2_pie.o, two_file_test_main_pie.o): New targets.
	(two_file_pie_test): New target.
	* testsuite/Makefile.in: Rebuild.
	* README: Remove note saying that -pie is not supported.
@
text
@d3107 23
a3129 2
  // FIXME: Support DT_INIT_ARRAY and DT_FINI_ARRAY.

d3210 6
@


1.138
log
@	* options.h (class General_options): Add -init and -fini.
	* layout.cc (Layout::finish_dynamic_section): Emit
	given init and fini functions.
@
text
@d2147 1
a2147 1
  else if (parameters->options().shared())
@


1.137
log
@2009-10-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::make_output_section): Call target hook to make
	ordinary output section.
	(Layout::finalize): Adjust parameter list of call the
	Target::may_relax().
	* layout.h (class Layout::section_list): New method.
	* merge.h (Output_merge_base::entsize): Change visibility to public.
	(Output_merge_base::is_string, Output_merge_base::do_is_string):
	New methods.
	(Output_merge_string::do_is_string): New method.
	* object.cc (Sized_relobj::do_setup): renamed from
	Sized_relobj::set_up.
	* object.h (Sized_relobj::adjust_shndx,
	Sized_relobj::initializ_input_to_output_maps,
	Sized_relobj::free_input_to_output_maps): Change visibilities to
	protected.
	(Sized_relobj::setup): Virtualize.
	(Sized_relobj::do_setup): New method declaration.
	(Sized_relobj::invalidate_section_offset,
	Sized_relobj::do_invalidate_section_offset): New method decfinitions.
	(Sized_relobj::elf_file, Sized_relobj::local_values): New methods.
	* options.cc (parse_int): New function.
	* options.h (parse_int): New declaration.
	(DEFINE_int): New macro.
	(stub_group_size): New option.
	* output.cc (Output_section::Output_section): Initialize memebers
	merge_section_map_, merge_section_by_properties_map_,
	relaxed_input_section_map_, is_relaxed_input_section_map_valid_.
	(Output_section::add_input_section): Handled deferred code-fill
	generation and remove an old comment.
	(Output_section::add_relaxed_input_section): New method definition.
	(Output_section::add_merge_input_section): Use merge section by
	properties map to speed to search.  Update merge section maps
	as appropriate.
	(Output_section::build_relaxation_map): New method definition.
	(Output_section::convert_input_sections_in_list_to_relaxed_sections):
	Same.
	(Output_section::relax_input_section): Renamed to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of pointers to relaxed sections.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section): New method definitions.
	(Output_section::is_input_address_mapped,
	Output_section::output_offset, Output_section::output_address):
	Use output section data maps to speed up searching.
	(Output_section::find_starting_output_address): Add comments.
	(Output_section::do_write,
	Output_section::write_to_postprocessing_buffer): Do code-fill
	generation as appropriate.
	(Output_section::get_input_sections): Invalidate relaxed input section
	map.
	(Output_section::restore_states): Adjust type of checkpoint .
	Invalidate relaxed input section map.
	* output.h (Output_merge_base): New class declaration.
	(Input_section_specifier): New class defintion.
	(class Output_relaxed_input_section) Change base class to
	Output_section_data_build.
	(Output_relaxed_input_section::Output_relaxed_input_section): Adjust
	base class initializer.
	(Output_section::add_relaxed_input_section): New method declaration.
	(Output_section::Input_section): Change visibility to protected.
     	(Output_section::Input_section::relobj,
	Output_section::Input_section::shndx): Handle relaxed input sections.
	Output_section::input_sections) Change visibility to protected.  Also
	define overload to return a non-const pointer.
	(Output_section::Merge_section_properties): New class defintion.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Relaxation_map): New types.
	(Output_section::relax_input_section): Rename method to
	Output_section::convert_input_sections_to_relaxed_sections and change
	interface to take a vector of relaxed section pointers.
	(Output_section::find_merge_section,
	Output_section::find_relaxed_input_section,
	Output_section::build_relaxation_map,
	Output_section::convert_input_sections_in_list_to_relaxed_sections):
	New method declarations.
	(Output_section::merge_section_map_
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_,
	Output_section::generate_code_fills_at_write_): New data members.
	* script-sections.cc
	(Output_section_element_input::set_section_addresses): Call
	current_data_size and addralign methods of relaxed input sections.
	(Orphan_output_section::set_section_addresses): Call current_data_size
	and addralign methods of relaxed input sections.
	* symtab.cc (Symbol_table::compute_final_value): Extract template
	from the body of Symbol_table::sized_finalize_symbol.
	(Symbol_table::sized_finalized_symbol): Call
	Symbol_table::compute_final_value.
	* symtab.h (Symbol_table::Compute_final_value_status): New enum type.
	(Symbol_table::compute_final_value): New templated method declaration.
	* target.cc (Target::do_make_output_section): New method defintion.
	* target.h (Target::make_output_section): New method declaration.
	(Target::relax): Add more parameters for input objects, symbol table
	and layout.  Adjust call to do_relax.
	(Target::do_make_output_section): New method declaration.
	(Target::do_relax): Add parameters for input objects, symbol table
	and layout.
@
text
@d3099 1
a3099 2
  // FIXME: Support --init and --fini.
  Symbol* sym = symtab->lookup("_init");
d3103 1
a3103 1
  sym = symtab->lookup("_fini");
@


1.136
log
@	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Change read_shndx type to unsigned int.
	(Sized_dwarf_line_info::read_lines): Change shndx type to unsigned
	int.
	(Sized_dwarf_line_info::read_line_mappings): Likewise.
	* dwarf_reader.h (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Change read_shndx type to unsigned int.
	(Sized_dwarf_line_info::read_lines): Change shndx type to unsigned
	int.
	(Sized_dwarf_line_info::read_line_mappings): Likewise.
	* layout.cc (Layout::create_symtab_sections): Cast the result of
	local_symcount * symsize to off_t in the gold_assert.
@
text
@d873 5
a877 1
    os = new Output_section(name, type, flags);
d1599 2
a1600 1
  while (target->may_relax() && target->relax(pass));
@


1.135
log
@2009-09-17  Doug Kwan  <dougkwan@@google.com>

	* debug.h (DEBUG_RELAXATION): New constant.
	(DEBUG_ALL): Add DEBUG_RELAXATION.
	(debug_string_to_enum): Add relaxation debug option.
	* layout.cc
	(Layout::Relaxation_debug_check::check_output_data_for_reset_values,
	Layout::Relaxation_debug_check::read_sections,
	Layout::Relaxation_debug_check::read_sections): New method definitions.
	(Layout::Layout): Initialize data members
	record_output_section_data_from_scrips_,
	script_output_section_data_list_ and relaxation_debug_check_.
	(Layout::save_segments, Layout::restore_segments,
	Layout::clean_up_after_relaxation, Layout::prepare_for_relaxation,
	Layout::relaxation_loop_body): New method definitions.
	(Layout::finalize): Support relaxation.  Move section layout code to
	Layout::relaxation_loop_body.
	(Layout::set_asection_address_from_script): Move code for orphan
	section placement out.
	(Layout::place_orphan_sections_in_script): New method definition.
	* layout.h (Output_segment_headers, Output_file_header):
	New forward class declarations.
	(Layout::~Layout): Define.
	(Layout::new_output_section_data_from_script): New method definition.
	(Layout::place_orphan_sections_in_script): New method declaration.
	(Layout::Segment_states): New type declaration.
	(Layout::save_segments, Layout::restore_segments,
	Layout::clean_up_after_relaxation, Layout::prepare_for_relaxation,
	Layout::relaxation_loop_body): New method declarations.
	(Layout::Output_section_data_list): New type declaration.
	(Layout::Relaxation_debug_check): New class definition.
	(Layout::record_output_section_data_from_script_,
	Layout::script_output_section_data_list_, Layout::segment_states_,
	Layout::relaxation_debug_check_): New data members.
	* output.cc: (Output_section_headers::do_size): New method definition.
	(Output_section_headers::Output_section_headers): Move size
	computation to Output_section_headers::do_size.
	(Output_segment_headers::do_size): New method definition.
	(Output_file_header::Output_file_header): Move size computation to
	Output_file_header::do_size and call it.
	(Output_file_header::do_size): New method definition.
	(Output_data_group::Output_data_group): Adjust call to
	Output_section_data.
	(Output_data_dynamic::set_final_data_size): Add DT_NULL tag only once.
	(Output_symtab_xindex::do_write): Add array bound check.
 	(Output_section::Input_section::print_to_mapfile): Handle
	RELAXED_INPUT_SECTION_CODE.
	(Output_section::Output_section): Initialize data member checkpoint_.
	(Output_section::~Output_section): Delete checkpoint object pointed
	by checkpoint_.
	(Output_section::add_input_section): Always add an Input_section if
	relaxing.
	(Output_section::add_merge_input_section): Add assert.
	(Output_section::relax_input_section): New method definition.
	(Output_section::set_final_data_size): Set load address to zero for
	an unallocated section.
	(Output_section::do_address_and_file_offset_have_reset_values):
	New method definition.
	(Output_section::Input_section_sort_enty::Input_section_sort_enty):
	Handle relaxed input section.
	(Output_section::sort_attached_input_sections): Checkpoint input
	section list lazily.
	(Output_section::get_input_sections): Change type of input_sections to
	list of Simple_input_section pointers.  Checkpoint input section list
	lazily.  Also handle relaxed input sections.
	(Output_section::add_input_section_for_script): Take a reference to
	a Simple_input_section object instead of Relobj pointer and section
	index as parameter.  Handle relaxed input sections.
	(Output_section::save_states, Output_section::restore_states): New
	method definitions.
	* output.h (Output_data::Output_data): Initialize is_data_size_fixed_.
	(Output_data::is_data_size_fixed): New method definition.
	(Output_data::reset_addresss_and_file_offset): Do not reset data size
	if it is fixed.
	(Output_data::address_and_file_offset_have_reset_values): New method
	definition.
	(Output_data::do_address_and_file_offset_have_reset_values): New method
	definition.
	(Output_data::set_data_size): Check that data size is not fixed.
	(Output_data::fix_data_size): New method definition.
	(Output_data::is_data_size_fixed_): New data member.
	(Output_section_headers::set_final_data_size): New method definition.
	(Output_section_headers::do_size): New method declaration.
	(Output_segment_headers::set_final_data_size): New method definition.
	(Output_segment_headers::do_size): New method declaration.
	(Output_file_header::set_final_data_size)::New method definition.
	(Output_file_header::do_size)::New method declaration.
	(Output_section_data::Output_section_data): Add new parameter
	is_data_size_fixed and use it to fix data size.
	(Output_data_const::Output_data_const): Adjust call to base class
	constructor and fix data size.
	(Output_data_const_buffer::Output_data_const_buffer): Adjust call to
	base class constructor and fix data size.
	(Output_data_fixed_space::Output_data_fixed_space): Adjust call to
	base class constructor and fix data size.
	(Output_data_zero_fill::Output_data_zero_fill): Adjust call to base
	class constructor and fix data size.
	(Output_data_group::set_final_data_size): New method definition.
	(Output_data_dynamic::Dynamic_entry::tag): New method definition.
	(Output_symtab_xindex::Output_symtab_xindex): Adjust call to base
	class constructor and fix data size.
	(Output_relaxed_input_section): New class definition.
	(Output_section::Simple_input_section): New class definition.
	(Output_section::get_input_sections): Adjust parameter list.
	(Output_section::add_input_section_for_script): Same.
	(Output_section::save_states, Output_section::restore_states,
	Output_section::do_address_and_file_offset_have_reset_values,
	(Output_section::Input_section::Input_section): Handle
	RELAXED_INPUT_SECTION_CODE.  Add new overload for
	Output_relaxed_input_section.
	(Output_section::Input_section::is_input_section,
	Output_section::Input_section::set_output_section): Handle relaxed
	input section.
	(Output_section::Input_section::is_relaxed_input_section,
	Output_section::Input_section::output_section_data,
	Output_section::Input_section::relaxed_input_section): New method
	definitions.
	(Output_section::Input_section::RELAXED_INPUT_SECTION_CODE): New enum
	value.
	(Output_section::Input_section::u1_): Update comments.
	(Output_section::Input_section::u2_): Add new union member poris.
	(Output_section::Checkpoint_output_section): New classs definition.
	(Output_section::relax_input_section): New method declaration.
	(Output_section::checkpoint_): New data member.
	(Output_segment): Update comments.
	(Output_segment::Output_segment): Un-privatize copy constructor.
	(Output_segment::operator=): Un-privatize.
	* script-sections.cc (Output_section_element::Input_section_list):
	Change element type to Output_section::Simple_input_section.
	(Output_section_element_dot_assignment::set_section_addresses):
	Register output section data for relaxation clean up.
	(Output_data_exression::Output_data_expression): Adjust call to base
	constructor to fix data size.
	(Output_section_element_data::set_section_addresses): Register
	Output_data_expression object for relaxation clean up.
	(struct Input_section_info): Replace Relobj pointer and section index
	pair with Output_section::Simple_input_section and Convert struct to a
	class.
	(Input_section_sorter::operator()): Adjust access to
	Input_section_info data member to use accessors.
	(Output_section_element_input::set_section_addresses): Use layout
	parameter.  Adjust code to use Output_section::Simple_input_section
	and Input_secction_info classes.  Register filler for relaxation
	clean up.
	(Orphan_output_section::set_section_addresses): Replace Relobj pointer
	and section index pair with Output_section::Simple_input_section
	class.  Adjust code accordingly.
	(Phdrs_element::release_segment): New method definition.
	(Script_sections::attach_sections_using_phdrs_clause): Do not modify
	segment list.
	(Script_sections::release_segments): New method definition.
	* gold/script-sections.h (Script_sections::release_segments): New
	method declaration.
	* gold/target.h (Target::may_relax, Target::relax,
	Target::do_may_relax, Target::do_relax): New method definitions.
@
text
@d2545 1
a2545 1
  gold_assert(local_symcount * symsize == off - startoff);
@


1.134
log
@*** empty log message ***
@
text
@d56 73
d201 5
a205 1
    incremental_inputs_(NULL)
d1250 220
d1558 5
a1562 28
  // If there is a SECTIONS clause, put all the input sections into
  // the required order.
  Output_segment* load_seg;
  if (this->script_options_->saw_sections_clause())
    load_seg = this->set_section_addresses_from_script(symtab);
  else if (parameters->options().relocatable())
    load_seg = NULL;
  else
    load_seg = this->find_first_load_seg();

  if (parameters->options().oformat_enum()
      != General_options::OBJECT_FORMAT_ELF)
    load_seg = NULL;

  gold_assert(phdr_seg == NULL || load_seg != NULL);

  // Lay out the segment headers.
  Output_segment_headers* segment_headers;
  if (parameters->options().relocatable())
    segment_headers = NULL;
  else
    {
      segment_headers = new Output_segment_headers(this->segment_list_);
      if (load_seg != NULL)
	load_seg->add_initial_output_data(segment_headers);
      if (phdr_seg != NULL)
	phdr_seg->add_initial_output_data(segment_headers);
    }
d1565 3
a1567 5
  Output_file_header* file_header;
  file_header = new Output_file_header(target, symtab, segment_headers,
				       parameters->options().entry());
  if (load_seg != NULL)
    load_seg->add_initial_output_data(file_header);
d1573 16
a1588 2
  if (this->script_options_->saw_phdrs_clause()
      && !parameters->options().relocatable())
d1590 4
a1593 4
      // Support use of FILEHDRS and PHDRS attachments in a PHDRS
      // clause in a linker script.
      Script_sections* ss = this->script_options_->script_sections();
      ss->put_headers_in_phdrs(file_header, segment_headers);
d1595 1
a1595 12

  // We set the output section indexes in set_segment_offsets and
  // set_section_indexes.
  unsigned int shndx = 1;

  // Set the file offsets of all the segments, and all the sections
  // they contain.
  off_t off;
  if (!parameters->options().relocatable())
    off = this->set_segment_offsets(target, load_seg, &shndx);
  else
    off = this->set_relocatable_section_offsets(file_header, &shndx);
d2429 10
a2447 2

  return this->script_options_->set_section_addresses(symtab, this);
@


1.134.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a55 73
// Layout::Relaxation_debug_check methods.

// Check that sections and special data are in reset states.
// We do not save states for Output_sections and special Output_data.
// So we check that they have not assigned any addresses or offsets.
// clean_up_after_relaxation simply resets their addresses and offsets.
void
Layout::Relaxation_debug_check::check_output_data_for_reset_values(
    const Layout::Section_list& sections,
    const Layout::Data_list& special_outputs)
{
  for(Layout::Section_list::const_iterator p = sections.begin();
      p != sections.end();
      ++p)
    gold_assert((*p)->address_and_file_offset_have_reset_values());

  for(Layout::Data_list::const_iterator p = special_outputs.begin();
      p != special_outputs.end();
      ++p)
    gold_assert((*p)->address_and_file_offset_have_reset_values());
}
  
// Save information of SECTIONS for checking later.

void
Layout::Relaxation_debug_check::read_sections(
    const Layout::Section_list& sections)
{
  for(Layout::Section_list::const_iterator p = sections.begin();
      p != sections.end();
      ++p)
    {
      Output_section* os = *p;
      Section_info info;
      info.output_section = os;
      info.address = os->is_address_valid() ? os->address() : 0;
      info.data_size = os->is_data_size_valid() ? os->data_size() : -1;
      info.offset = os->is_offset_valid()? os->offset() : -1 ;
      this->section_infos_.push_back(info);
    }
}

// Verify SECTIONS using previously recorded information.

void
Layout::Relaxation_debug_check::verify_sections(
    const Layout::Section_list& sections)
{
  size_t i = 0;
  for(Layout::Section_list::const_iterator p = sections.begin();
      p != sections.end();
      ++p, ++i)
    {
      Output_section* os = *p;
      uint64_t address = os->is_address_valid() ? os->address() : 0;
      off_t data_size = os->is_data_size_valid() ? os->data_size() : -1;
      off_t offset = os->is_offset_valid()? os->offset() : -1 ;

      if (i >= this->section_infos_.size())
	{
	  gold_fatal("Section_info of %s missing.\n", os->name());
	}
      const Section_info& info = this->section_infos_[i];
      if (os != info.output_section)
	gold_fatal("Section order changed.  Expecting %s but see %s\n",
		   info.output_section->name(), os->name());
      if (address != info.address
	  || data_size != info.data_size
	  || offset != info.offset)
	gold_fatal("Section %s changed.\n", os->name());
    }
}

d128 1
a128 5
    incremental_inputs_(NULL),
    record_output_section_data_from_script_(false),
    script_output_section_data_list_(),
    segment_states_(NULL),
    relaxation_debug_check_(NULL)
d796 1
a796 5
    {
      // FIXME: const_cast is ugly.
      Target* target = const_cast<Target*>(&parameters->target());
      os = target->make_output_section(name, type, flags);
    }
a1172 222
// Save states of all current output segments.  Store saved states
// in SEGMENT_STATES.

void
Layout::save_segments(Segment_states* segment_states)
{
  for (Segment_list::const_iterator p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
    {
      Output_segment* segment = *p;
      // Shallow copy.
      Output_segment* copy = new Output_segment(*segment);
      (*segment_states)[segment] = copy;
    }
}

// Restore states of output segments and delete any segment not found in
// SEGMENT_STATES.

void
Layout::restore_segments(const Segment_states* segment_states)
{
  // Go through the segment list and remove any segment added in the
  // relaxation loop.
  this->tls_segment_ = NULL;
  this->relro_segment_ = NULL;
  Segment_list::iterator list_iter = this->segment_list_.begin();
  while (list_iter != this->segment_list_.end())
    {
      Output_segment* segment = *list_iter;
      Segment_states::const_iterator states_iter =
	  segment_states->find(segment);
      if (states_iter != segment_states->end())
	{
	  const Output_segment* copy = states_iter->second;
	  // Shallow copy to restore states.
	  *segment = *copy;

	  // Also fix up TLS and RELRO segment pointers as appropriate.
	  if (segment->type() == elfcpp::PT_TLS)
	    this->tls_segment_ = segment;
	  else if (segment->type() == elfcpp::PT_GNU_RELRO)
	    this->relro_segment_ = segment;

	  ++list_iter;
	} 
      else
	{
	  list_iter = this->segment_list_.erase(list_iter); 
	  // This is a segment created during section layout.  It should be
	  // safe to remove it since we should have removed all pointers to it.
	  delete segment;
	}
    }
}

// Clean up after relaxation so that sections can be laid out again.

void
Layout::clean_up_after_relaxation()
{
  // Restore the segments to point state just prior to the relaxation loop.
  Script_sections* script_section = this->script_options_->script_sections();
  script_section->release_segments();
  this->restore_segments(this->segment_states_);

  // Reset section addresses and file offsets
  for (Section_list::iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    {
      (*p)->reset_address_and_file_offset();
      (*p)->restore_states();
    }
  
  // Reset special output object address and file offsets.
  for (Data_list::iterator p = this->special_output_list_.begin();
       p != this->special_output_list_.end();
       ++p)
    (*p)->reset_address_and_file_offset();

  // A linker script may have created some output section data objects.
  // They are useless now.
  for (Output_section_data_list::const_iterator p =
	 this->script_output_section_data_list_.begin();
       p != this->script_output_section_data_list_.end();
       ++p)
    delete *p;
  this->script_output_section_data_list_.clear(); 
}

// Prepare for relaxation.

void
Layout::prepare_for_relaxation()
{
  // Create an relaxation debug check if in debugging mode.
  if (is_debugging_enabled(DEBUG_RELAXATION))
    this->relaxation_debug_check_ = new Relaxation_debug_check();

  // Save segment states.
  this->segment_states_ = new Segment_states();
  this->save_segments(this->segment_states_);

  for(Section_list::const_iterator p = this->section_list_.begin();
      p != this->section_list_.end();
      ++p)
    (*p)->save_states();

  if (is_debugging_enabled(DEBUG_RELAXATION))
    this->relaxation_debug_check_->check_output_data_for_reset_values(
        this->section_list_, this->special_output_list_);

  // Also enable recording of output section data from scripts.
  this->record_output_section_data_from_script_ = true;
}

// Relaxation loop body:  If target has no relaxation, this runs only once
// Otherwise, the target relaxation hook is called at the end of
// each iteration.  If the hook returns true, it means re-layout of
// section is required.  
//
// The number of segments created by a linking script without a PHDRS
// clause may be affected by section sizes and alignments.  There is
// a remote chance that relaxation causes different number of PT_LOAD
// segments are created and sections are attached to different segments.
// Therefore, we always throw away all segments created during section
// layout.  In order to be able to restart the section layout, we keep
// a copy of the segment list right before the relaxation loop and use
// that to restore the segments.
// 
// PASS is the current relaxation pass number. 
// SYMTAB is a symbol table.
// PLOAD_SEG is the address of a pointer for the load segment.
// PHDR_SEG is a pointer to the PHDR segment.
// SEGMENT_HEADERS points to the output segment header.
// FILE_HEADER points to the output file header.
// PSHNDX is the address to store the output section index.

off_t inline
Layout::relaxation_loop_body(
    int pass,
    Target* target,
    Symbol_table* symtab,
    Output_segment** pload_seg,
    Output_segment* phdr_seg,
    Output_segment_headers* segment_headers,
    Output_file_header* file_header,
    unsigned int* pshndx)
{
  // If this is not the first iteration, we need to clean up after
  // relaxation so that we can lay out the sections again.
  if (pass != 0)
    this->clean_up_after_relaxation();

  // If there is a SECTIONS clause, put all the input sections into
  // the required order.
  Output_segment* load_seg;
  if (this->script_options_->saw_sections_clause())
    load_seg = this->set_section_addresses_from_script(symtab);
  else if (parameters->options().relocatable())
    load_seg = NULL;
  else
    load_seg = this->find_first_load_seg();

  if (parameters->options().oformat_enum()
      != General_options::OBJECT_FORMAT_ELF)
    load_seg = NULL;

  gold_assert(phdr_seg == NULL
	      || load_seg != NULL
	      || this->script_options_->saw_sections_clause());

  // Lay out the segment headers.
  if (!parameters->options().relocatable())
    {
      gold_assert(segment_headers != NULL);
      if (load_seg != NULL)
        load_seg->add_initial_output_data(segment_headers);
      if (phdr_seg != NULL)
        phdr_seg->add_initial_output_data(segment_headers);
    }

  // Lay out the file header.
  if (load_seg != NULL)
    load_seg->add_initial_output_data(file_header);

  if (this->script_options_->saw_phdrs_clause()
      && !parameters->options().relocatable())
    {
      // Support use of FILEHDRS and PHDRS attachments in a PHDRS
      // clause in a linker script.
      Script_sections* ss = this->script_options_->script_sections();
      ss->put_headers_in_phdrs(file_header, segment_headers);
    }

  // We set the output section indexes in set_segment_offsets and
  // set_section_indexes.
  *pshndx = 1;

  // Set the file offsets of all the segments, and all the sections
  // they contain.
  off_t off;
  if (!parameters->options().relocatable())
    off = this->set_segment_offsets(target, load_seg, pshndx);
  else
    off = this->set_relocatable_section_offsets(file_header, pshndx);

   // Verify that the dummy relaxation does not change anything.
  if (is_debugging_enabled(DEBUG_RELAXATION))
    {
      if (pass == 0)
	this->relaxation_debug_check_->read_sections(this->section_list_);
      else
	this->relaxation_debug_check_->verify_sections(this->section_list_);
    }

  *pload_seg = load_seg;
  return off;
}

d1261 28
a1288 5
  // Create segment headers.
  Output_segment_headers* segment_headers =
    (parameters->options().relocatable()
     ? NULL
     : new Output_segment_headers(this->segment_list_));
d1291 5
a1295 3
  Output_file_header* file_header
    = new Output_file_header(target, symtab, segment_headers,
			     parameters->options().entry());
d1301 2
a1302 16
  // Find approriate places for orphan output sections if we are using
  // a linker script.
  if (this->script_options_->saw_sections_clause())
    this->place_orphan_sections_in_script();
  
  Output_segment* load_seg;
  off_t off;
  unsigned int shndx;
  int pass = 0;

  // Take a snapshot of the section layout as needed.
  if (target->may_relax())
    this->prepare_for_relaxation();
  
  // Run the relaxation loop to lay out sections.
  do
d1304 4
a1307 4
      off = this->relaxation_loop_body(pass, target, symtab, &load_seg,
				       phdr_seg, segment_headers, file_header,
				       &shndx);
      pass++;
d1309 12
a1320 2
  while (target->may_relax()
	 && target->relax(pass, input_objects, symtab, this));
d1867 1
a1867 1
  else if (parameters->options().output_is_position_independent())
a1959 13
	  else if (load_seg == NULL)
	    {
	      // This is -N or -n with a section script which prevents
	      // us from using a load segment.  We need to ensure that
	      // the file offset is aligned to the alignment of the
	      // segment.  This is because the linker script
	      // implicitly assumed a zero offset.  If we don't align
	      // here, then the alignment of the sections in the
	      // linker script may not match the alignment of the
	      // sections in the set_section_addresses call below,
	      // causing an error about dot moving backward.
	      off = align_address(off, (*p)->maximum_alignment());
	    }
a2153 10
  return this->script_options_->set_section_addresses(symtab, this);
}

// Place the orphan sections in the linker script.

void
Layout::place_orphan_sections_in_script()
{
  Script_sections* ss = this->script_options_->script_sections();
  gold_assert(ss->saw_sections_clause());
d2163 2
d2262 1
a2262 1
  gold_assert(static_cast<off_t>(local_symcount * symsize) == off - startoff);
d2811 2
a2812 1
  Symbol* sym = symtab->lookup(parameters->options().init());
d2816 1
a2816 1
  sym = symtab->lookup(parameters->options().fini());
d2820 2
a2821 23
  // Look for .init_array, .preinit_array and .fini_array by checking
  // section types.
  for(Layout::Section_list::const_iterator p = this->section_list_.begin();
      p != this->section_list_.end();
      ++p)
    switch((*p)->type())
      {
      case elfcpp::SHT_FINI_ARRAY:
	odyn->add_section_address(elfcpp::DT_FINI_ARRAY, *p);
	odyn->add_section_size(elfcpp::DT_FINI_ARRAYSZ, *p); 
	break;
      case elfcpp::SHT_INIT_ARRAY:
	odyn->add_section_address(elfcpp::DT_INIT_ARRAY, *p);
	odyn->add_section_size(elfcpp::DT_INIT_ARRAYSZ, *p); 
	break;
      case elfcpp::SHT_PREINIT_ARRAY:
	odyn->add_section_address(elfcpp::DT_PREINIT_ARRAY, *p);
	odyn->add_section_size(elfcpp::DT_PREINIT_ARRAYSZ, *p); 
	break;
      default:
	break;
      }
  
a2901 6
  if (parameters->options().Bsymbolic())
    {
      flags |= elfcpp::DF_SYMBOLIC;
      // Add DT_SYMBOLIC for compatibility with older loaders.
      odyn->add_constant(elfcpp::DT_SYMBOLIC, 0);
    }
@


1.134.2.2
log
@	* layout.cc (Layout::get_output_section): Add is_interp and
	is_dynamic_linker_section parameters.  Change all callers.
	(Layout::choose_output_section): Likewise.
	(Layout::make_output_section): Likewise.
	(Layout::add_output_section_data): Add is_dynamic_linker_section
	parameter.  Change all callers.
	* layout.h (class Layout): Update declarations.
	* output.h (class Output_section): Add is_interp, set_is_interp,
	is_dynamic_linker_section, set_is_dynamic_linker_section methods.
	Add is_interp_, is_dynamic_linker_section_ fields.  Change
	generate_code_fills_at_write_ to a bitfield.
	* output.cc (Output_section::Output_sections): Initialize new
	fields.
	(Output_segment::add_output_section): Add do_sort parameter.
	Change all callers.
@
text
@d391 1
a391 3
// pool, and NAME_KEY is the key.  IS_INTERP is true if this is the
// .interp section.  IS_DYNAMIC_LINKER_SECTION is true if this section
// is used by the dynamic linker.
d395 1
a395 2
			   elfcpp::Elf_Word type, elfcpp::Elf_Xword flags,
			   bool is_interp, bool is_dynamic_linker_section)
d444 1
a444 2
	os = this->make_output_section(name, type, flags, is_interp,
				       is_dynamic_linker_section);
d454 2
a455 4
// file.  IS_INTERP is true if this is the .interp section.
// IS_DYNAMIC_LINKER_SECTION is true if this section is used by the
// dynamic linker.  This will return NULL if the input section should
// be discarded.
d460 1
a460 2
			      bool is_input_section, bool is_interp,
			      bool is_dynamic_linker_section)
d508 1
a508 3
	  Output_section* os =
	    this->make_output_section(name, type, flags, is_interp,
				      is_dynamic_linker_section);
d531 1
a531 2
  return this->get_output_section(name, name_key, type, flags, is_interp,
				  is_dynamic_linker_section);
d564 1
a564 1
				     shdr.get_sh_flags(), false, false);
d569 1
a569 2
				       shdr.get_sh_flags(), true, false,
				       false);
d620 1
a620 1
						   false, false, false);
d667 1
a667 2
						 shdr.get_sh_flags(),
						 false, false);
d721 1
a721 1
						   false, false, false);
d737 1
a737 1
					false, false, false);
d752 1
a752 1
		  hdr_oseg->add_output_section(hdr_os, elfcpp::PF_R, false);
d803 1
a803 2
				Output_section_data* posd,
				bool is_dynamic_linker_section)
d806 1
a806 2
						   false, false,
						   is_dynamic_linker_section);
d841 1
a841 3
// appropriate.  IS_INTERP is true if this is the .interp section.
// IS_DYNAMIC_LINKER_SECTION is true if this section is used by the
// dynamic linker.
d845 1
a845 2
			    elfcpp::Elf_Xword flags, bool is_interp,
			    bool is_dynamic_linker_section)
d853 1
a878 5
  if (is_interp)
    os->set_is_interp();
  if (is_dynamic_linker_section)
    os->set_is_dynamic_linker_section();

a973 2
  bool sort_sections = !this->script_options_->saw_sections_clause();

d1001 1
a1001 1
      (*p)->add_output_section(os, seg_flags, sort_sections);
d1011 1
a1011 1
      oseg->add_output_section(os, seg_flags, sort_sections);
d1027 1
a1027 1
              (*p)->add_output_section(os, seg_flags, false);
d1036 1
a1036 1
          oseg->add_output_section(os, seg_flags, false);
d1046 1
a1046 1
      this->tls_segment_->add_output_section(os, seg_flags, false);
d1056 1
a1056 1
      this->relro_segment_->add_output_section(os, seg_flags, false);
d1067 1
a1067 2
						 elfcpp::SHF_ALLOC, false,
						 false);
d1137 1
a1137 1
						       false, false, true);
d1735 1
a1735 2
						   flags, false, false,
						   false);
d1814 1
a1814 2
      this->make_output_section(name, elfcpp::SHT_PROGBITS, flags, false,
				false);
d1974 1
a1974 2
			      elfcpp::SHT_GNU_INCREMENTAL_INPUTS, 0,
			      false, false);
d1984 1
a1984 1
                                                        0, false, false);
d2596 1
a2596 1
							  0, false, false);
d2617 1
a2617 2
				      elfcpp::SHT_SYMTAB_SHNDX, 0, false,
				      false);
d2639 1
a2639 1
							  0, false, false);
d2666 1
a2666 2
  Output_section* os = this->make_output_section(name, elfcpp::SHT_STRTAB, 0,
						 false, false);
d2779 1
a2779 1
						       false, false, true);
d2809 1
a2809 1
				    false, false, true);
d2832 1
a2832 1
						       false, false, true);
d2858 1
a2858 1
							    false, false, true);
d2883 1
a2883 1
							    false, false, true);
d2981 1
a2981 1
						     false, false, true);
d3006 1
a3006 1
					 false, false, true);
d3031 1
a3031 1
					  false, false, true);
d3071 1
a3071 1
						     false, true, true);
d3078 1
a3078 1
      oseg->add_output_section(osec, elfcpp::PF_R, false);
d3094 1
a3094 2
			       elfcpp::PF_R | elfcpp::PF_W,
			       false);
@


1.134.2.3
log
@	PR 10880
	* object.h (class Object): Add is_needed and set_is_needed
	methods.  Add is_needed_ field.  Make bool fields into bitfields.
	* symtab.cc (Symbol_table::set_dynsym_indexes): If a symbol is
	defined in a dynamic object and referenced by a regular object,
	set is_needed for the dynamic object.
	* layout.cc (Layout::finish_dynamic_section): Don't add DT_NEEDED
	if the file is marked with as_needed and it is not needed.
@
text
@d3133 1
a3133 8
      if (!(*p)->is_needed()
	  && (*p)->input_file()->options().as_needed())
	{
	  // This dynamic object was linked with --as-needed, but it
	  // is not needed.
	  continue;
	}

@


1.134.2.4
log
@	Bring over from mainline:
	2010-01-08  Ian Lance Taylor  <iant@@google.com>

	PR 11072
	* layout.cc (Layout::include_section): Remove .gnu_debuglink
	sections.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
a351 5
      // The GNU linker strips .gnu_debuglink sections, so we do too.
      // This is a feature used to keep debugging information in
      // separate files.
      if (strcmp(name, ".gnu_debuglink") == 0)
	return false;
@


1.133
log
@2009-07-24  Chris Demetriou  <cgd@@google.com>

        * layout.cc (is_compressible_debug_section): Fix incorrect
        comment about compressed section names.
@
text
@d2256 1
a2256 1
                                                        off);
@


1.132
log
@	PR 10400
	* layout.h: #include <map>.
	(class Kept_section): Change from struct to class.  Add accessors
	and setters.  Add section size to Comdat_group mapping.  Change
	Comdat_group to std::map.  Add is_comdat_ field.  Add
	linkonce_size field in union.
	(class Layout): Update declaration of find_or_add_kept_section.
	Don't declare find_kept_object.
	* layout.cc (Layout::find_or_add_kept_section): Remove candidate
	parameter.  Add object, shndx, is_comdat, and is_group_name
	parameters.  Change all callers.  Adjust for new Kept_section.
	(Layout::find_kept_object): Remove.
	* object.cc (Sized_relobj::include_section_group): Update use of
	Kept_section.  Rename secnum to shndx.  Only record
	Kept_comdat_section if sections are the same size.
	(Sized_relobj::include_linkonce_section): Update use of
	Kept_section.  Only record Kept_comdat_section if sections are the
	same size.  Set size of linkonce section.
	(Sized_relobj::map_to_kept_section): Update call to
	get_kept_comdat_section.
	* object.h (class Sized_relobj): Rename fields in
	Kept_comdat_section to drop trailing underscores; change object
	field to Relobj*.  Change Kept_comdat_section_table to store
	struct rather than pointer.
	(Sized_relobj::set_kept_comdat_section): Remove kept parameter.
	Add kept_object and kept_shndx parameters.  Change all callers.
	(Sized_relobj::get_kept_comdat_section): Change return type to
	bool.  Add kept_object and kept_shndx parameters.  Change all
	callers.
	* plugin.cc (Pluginobj::include_comdat_group): Update call to
	Layout::find_or_add_kept_section.
@
text
@d751 5
a755 6
// how to deal with compressed sections.  (To make it easier for them,
// we will rename the ouput section in such cases from .foo to
// .foo.zlib.nnnn, where nnnn is the uncompressed size.)  This routine
// doesn't say for certain whether we'll compress -- it depends on
// commandline options as well -- just whether this section is a
// candidate for compression.
@


1.131
log
@	PR 10156
	* layout.cc (Layout::choose_output_section): If we find an
	existing section, update the flags.
	(Layout::create_notes): New function, broken out of
	Layout::finalize.
	(Layout::finalize): Don't create note sections.
	(Layout::create_note): Don't crash if linker script discards
	section.
	(Layout::create_gold_note): Likewise.
	(Layout::create_build_id): Likewise.  Don't set
	after_input_sections on the section.
	(Layout::create_executable_stack_info): Remove target parameter.
	Change caller.
	* layout.h (class Layout): Declare create_notes.  Update
	declaration of create_executable_stack_info.
	* gold.cc (queue_middle_tasks): Call create_notes.
	* output.cc (Output_section::update_flags_for_input_section): Move
	here from output.h.  If SHF_ALLOC flag is newly set, mark address
	invalid.
	* output.h (Output_data::mark_address_invalid): New function.
	(class Output_section): Only declare, not define,
	update_flags_for_input_section.  Remove set_flags.
@
text
@d3048 5
a3052 6
// *KEPT_SECTION is set to point to the signature and the function
// returns false.  Otherwise, the CANDIDATE signature is recorded for
// this NAME in the layout object, *KEPT_SECTION is set to the
// internal copy and the function return false.  In some cases, with
// CANDIDATE->GROUP_ being false, KEPT_SECTION can point back to
// CANDIDATE.
d3056 4
a3059 1
                                 Kept_section* candidate,
d3073 3
a3075 2
  std::pair<Signatures::iterator, bool> ins(
    this->signatures_.insert(std::make_pair(name, *candidate)));
d3077 1
a3077 1
  if (kept_section)
d3082 6
d3091 3
a3093 1
  if (ins.first->second.is_group)
d3096 3
a3098 3
      // If the kept group is from a plugin object, and we're in
      // the replacement phase, accept the new one as a replacement.
      if (ins.first->second.object == NULL
d3101 2
a3102 1
          ins.first->second = *candidate;
d3107 1
a3107 1
  else if (candidate->is_group)
d3112 1
a3112 1
      ins.first->second.is_group = true;
a3119 1
      *kept_section = candidate;
a3123 14
// Find the given comdat signature, and return the object and section
// index of the kept group.
Relobj*
Layout::find_kept_object(const std::string& signature,
                         unsigned int* pshndx) const
{
  Signatures::const_iterator p = this->signatures_.find(signature);
  if (p == this->signatures_.end())
    return NULL;
  if (pshndx != NULL)
    *pshndx = p->second.shndx;
  return p->second.object;
}

@


1.130
log
@	PR 10156
	* layout.cc (Layout::create_note): Use choose_output_section
	rather than make_output_section.
@
text
@d419 4
a422 1
	    return *output_section_slot;
d1034 10
a1213 3
  this->create_gold_note();
  this->create_executable_stack_info(target);
  this->create_build_id();
d1455 3
d1483 2
d1509 1
a1509 1
Layout::create_executable_stack_info(const Target* target)
d1521 2
a1522 1
	is_stack_executable = target->is_default_stack_executable();
d1619 2
a1642 1
      os->set_after_input_sections();
@


1.129
log
@	PR 10219
	* layout.cc (Layout::Layout): Initialize have_stabstr_section_.
	(Layout::make_output_section): Set have_stabstr_section_ if we see
	a .stab*str section.
	(Layout::finalize): Call link_stabs_sections.
	(Layout::link_stabs_sections): New file.
	* layout.h (class Layout): Add have_stabstr_section_ field.
	Declare link_stabs_sections.
@
text
@d1364 5
a1368 4
// NAME is the name, NOTE_TYPE is the type, DESCSZ is the size of the
// descriptor.  ALLOCATE is true if the section should be allocated in
// memory.  This returns the new note section.  It sets
// *TRAILING_PADDING to the number of trailing zero bytes required.
a1438 1
  const char *note_name = this->namepool_.add(section_name, false, NULL);
d1442 3
a1444 3
  Output_section* os = this->make_output_section(note_name,
						 elfcpp::SHT_NOTE,
						 flags);
@


1.128
log
@	PR 10133
	* stringpool.h (class Stringpool_template): Add optimize_ field.
	(Stringpool_template::set_optimize): New function.
	* stringpool.cc (Stringpool_template::Stringpool_template):
	Initialize optimize_ field.
	(Stringpool_template::set_string_offsets): Test local optimize
	fild rather than parameter.
	* layout.cc (Layout::Layout): Call set_optimize on the section
	name stringpool.
@
text
@d127 1
d827 8
d1204 1
d1629 34
@


1.127
log
@	PR 10141
	* options.h (class General_options): Add -z lazy and -z now.  Sort
	-z options into alphabetical order.
	* layout.cc (Layout::finish_dynamic_section): Handle -z now.
@
text
@d140 4
@


1.126
log
@	* layout.cc (Layout::make_output_section): Call
	Target::new_output_section.
	(Layout::attach_allocated_section_to_segment): Put large section
	sections in a separate load segment with the large segment flag
	set.
	(Layout::segment_precedes): Sort large data segments after other
	load segments.
	(align_file_offset): New static function.
	(Layout::set_segment_offsets): Use align_file_offset.
	* output.h (class Output_section): Add is_small_section_ and
	is_large_section_ fields.
	(Output_section::is_small_section): New function.
	(Output_section::set_is_small_section):  New function.
	(Output_section::is_large_section): New function.
	(Output_section::set_is_large_section): New function.
	(Output_section::is_large_data_section): New function.
	(class Output_segment): Add is_large_data_segment_ field.
	(Output_segment::is_large_data_segment): New function.
	(Output_segment::set_is_large_data_segment): New function.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_segment::Output_segment): Likewise.
	(Output_segment::add_output_section): Add assertion that large
	data sections always go in large data segments.  Force small data
	sections to the end of the list of data sections.  Force small BSS
	sections to the start of the list of BSS sections.  For large BSS
	sections to the end of the list of BSS sections.
	* symtab.h (class Symbol): Declare is_common_shndx.
	(Symbol::is_defined): Check Symbol::is_common_shndx.
	(Symbol::is_common): Likewise.
	(class Symbol_table): Define enum Commons_section_type.  Update
	declarations.  Add small_commons_ and large_commons_ fields.
	* symtab.cc (Symbol::is_common_shndx): New function.
	(Symbol_table::Symbol_table): Initialize new fields.
	(Symbol_table::add_from_object): Put small and large common
	symbols in the right list.
	(Symbol_table::sized_finalized_symbol): Check
	Symbol::is_common_shndx.
	(Symbol_table::sized_write_globals): Likewise.
	* common.cc (Symbol_table::do_allocate_commons): Allocate new
	common symbol lists.  Don't call do_allocate_commons_list if the
	list is empty.
	(Symbol_table::do_allocate_commons_list): Remove is_tls
	parameter.  Add comons_section_type parameter.  Change all
	callers.  Handle small and large common symbols.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Check
	Symbol::is_common_shndx.
	* resolve.cc (symbol_to_bits): Likewise.
	* target.h (Target::small_common_shndx): New function.
	(Target::small_common_section_flags): New function.
	(Target::large_common_shndx): New function.
	(Target::large_common_section_flags): New function.
	(Target::new_output_section): New function.
	(Target::Target_info): Add small_common_shndx, large_common_shndx,
	small_common_section_flags, and large_common_section_flags
	fields.
	(Target::do_new_output_section): New virtual function.
	* arm.cc (Target_arm::arm_info): Initialize new fields.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Likewise.
	* sparc.c (Target_sparc::sparc_info) [all versions]: Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	(Target_x86_64::do_new_output_section): New function.
	* configure.ac: Define conditional MCMODEL_MEDIUM.
	* testsuite/Makefile.am (check_PROGRAMS): Add large.
	(large_SOURCES, large_CFLAGS, large_DEPENDENCIES): Define.
	(large_LDFLAGS): Define.
	* testsuite/large.c: New file.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Initialize new fields.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d2838 2
d2863 2
@


1.125
log
@2009-06-04  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::section_name_mapping): Add mapping for
	special ARM sections.
@
text
@d791 2
d880 2
a881 1
  // search for them.  People who need segments sorted on some other
d889 15
a903 12
      if ((*p)->type() == elfcpp::PT_LOAD
	  && (parameters->options().omagic()
	      || ((*p)->flags() & elfcpp::PF_W) == (seg_flags & elfcpp::PF_W)))
        {
          // If -Tbss was specified, we need to separate the data
          // and BSS segments.
          if (parameters->options().user_set_Tbss())
            {
              if ((os->type() == elfcpp::SHT_NOBITS)
                  == (*p)->has_any_data_sections())
                continue;
            }
d905 2
a906 3
          (*p)->add_output_section(os, seg_flags);
          break;
        }
d913 2
d1739 19
a1757 8
  // We sort PT_LOAD segments based on the flags.  Readonly segments
  // come before writable segments.  Then writable segments with data
  // come before writable segments without data.  Then executable
  // segments come before non-executable segments.  Then the unlikely
  // case of a non-readable segment comes before the normal case of a
  // readable segment.  If there are multiple segments with the same
  // type and flags, we require that the address be set, and we sort
  // by virtual address and then physical address.
d1773 13
d1872 1
a1872 16
	  if (are_addresses_set)
	    {
	      if (!parameters->options().nmagic()
		  && !parameters->options().omagic())
		{
		  // Adjust the file offset to the same address modulo
		  // the page size.
		  uint64_t unsigned_off = off;
		  uint64_t aligned_off = ((unsigned_off & ~(abi_pagesize - 1))
					  | (addr & (abi_pagesize - 1)));
		  if (aligned_off < unsigned_off)
		    aligned_off += abi_pagesize;
		  off = aligned_off;
		}
	    }
	  else
d1893 4
d1923 1
@


1.124
log
@	* layout.cc (Layout::section_name_mapping): New array, replacing
	Layout::linkonce_mapping.
	(Layout::section_name_mapping_count): New variable, replacing
	Layout::linkonce_mapping_count.
	(Layout::linkonce_output_name): Remove.
	(Layout::output_section_name): Rewrite.
	* layout.h (class Layout): Rename Linkonce_mapping to
	Section_name_mapping, linkonce_mapping to section_name_mapping,
	linkonce_mapping_count to section_name_mapping_count.  Don't
	declare linkonce_output_name.
@
text
@d2890 4
@


1.123
log
@	* incremental.cc (Incremental_inputs_header_data): Renamed from
	Incremental_input_header_data.
	(Incremental_inputs_header_data::data_size): New field.
	(Incremental_inputs_header_data::put_input_file_count): Renamed
	from input_file_count.
	(Incremental_inputs_header_data::put_command_line_offset): Renamed
	from command_line_offset.
	(Incremental_inputs_header_data::put_reserved): Renamed from
	put_reserved.
	(Incremental_inputs_entry_data): Renamed from
	Incremental_input_entry_data.
	(Incremental_inputs_entry_data::data_size): New field.
	(Incremental_inputs::report_command_line): New method.
	(Incremental_inputs::finalize): New method.
	(Incremental_inputs::create_incremental_inputs_data): New method.
	(Incremental_inputs::sized_create_incremental_inputs_data): New method.
	* incremental.h: New file.
	* layout.cc (Layout::Layout): Handle new incremental_inputs_.
       (Layout::finalize): Create incremental inputs section in
	incremental builds.
       (Layout::create_incremental_info_sections): New method.
	* layout.h (Layout::incremental_inputs): New method.
       (Layout::create_incremental_info_sections): New method.
       (Layout::incremental_inputs_): New field.
	* main.cc (main): Notify Incremental_input of the command line.
@
text
@d2844 4
a2847 1
// The mapping of .gnu.linkonce section names to real section names.
d2850 1
a2850 1
const Layout::Linkonce_mapping Layout::linkonce_mapping[] =
d2852 38
a2889 16
  MAPPING_INIT("d.rel.ro.local", ".data.rel.ro.local"), // Before "d.rel.ro".
  MAPPING_INIT("d.rel.ro", ".data.rel.ro"),		// Before "d".
  MAPPING_INIT("t", ".text"),
  MAPPING_INIT("r", ".rodata"),
  MAPPING_INIT("d", ".data"),
  MAPPING_INIT("b", ".bss"),
  MAPPING_INIT("s", ".sdata"),
  MAPPING_INIT("sb", ".sbss"),
  MAPPING_INIT("s2", ".sdata2"),
  MAPPING_INIT("sb2", ".sbss2"),
  MAPPING_INIT("wi", ".debug_info"),
  MAPPING_INIT("td", ".tdata"),
  MAPPING_INIT("tb", ".tbss"),
  MAPPING_INIT("lr", ".lrodata"),
  MAPPING_INIT("l", ".ldata"),
  MAPPING_INIT("lb", ".lbss"),
d2893 3
a2895 27
const int Layout::linkonce_mapping_count =
  sizeof(Layout::linkonce_mapping) / sizeof(Layout::linkonce_mapping[0]);

// Return the name of the output section to use for a .gnu.linkonce
// section.  This is based on the default ELF linker script of the old
// GNU linker.  For example, we map a name like ".gnu.linkonce.t.foo"
// to ".text".  Set *PLEN to the length of the name.  *PLEN is
// initialized to the length of NAME.

const char*
Layout::linkonce_output_name(const char* name, size_t *plen)
{
  const char* s = name + sizeof(".gnu.linkonce") - 1;
  if (*s != '.')
    return name;
  ++s;
  const Linkonce_mapping* plm = linkonce_mapping;
  for (int i = 0; i < linkonce_mapping_count; ++i, ++plm)
    {
      if (strncmp(s, plm->from, plm->fromlen) == 0 && s[plm->fromlen] == '.')
	{
	  *plen = plm->tolen;
	  return plm->to;
	}
    }
  return name;
}
a2903 7
  if (Layout::is_linkonce(name))
    {
      // .gnu.linkonce sections are laid out as though they were named
      // for the sections are placed into.
      return Layout::linkonce_output_name(name, plen);
    }

d2930 8
a2937 7
  // The .data.rel.ro sections enable a security feature triggered by
  // the -z relro option.  Section which need to be relocated at
  // program startup time but which may be readonly after startup are
  // grouped into .data.rel.ro.  They are then put into a PT_GNU_RELRO
  // segment.  The dynamic linker will make that segment writable,
  // perform relocations, and then make it read-only.  FIXME: We do
  // not yet implement this optimization.
d2939 2
a2940 31
  // It is hard to handle this in a principled way.

  // These are the rules we follow:

  // If the section name has no initial '.', or no dot other than an
  // initial '.', we use the name unchanged (i.e., "mysection" and
  // ".text" are unchanged).

  // If the name starts with '.note', we keep it unchanged (e.g. to
  // avoid truncating '.note.ABI-tag' to '.note').

  // If the name starts with ".data.rel.ro.local" we use
  // ".data.rel.ro.local".

  // If the name starts with ".data.rel.ro" we use ".data.rel.ro".

  // Otherwise, we drop the second '.' and everything that comes after
  // it (i.e., ".text.XXX" becomes ".text").

  const char* s = name;
  if (*s != '.')
    return name;
  ++s;
  const char* sdot = strchr(s, '.');
  if (sdot == NULL)
    return name;
  if (strncmp(name, ".note.", 6) == 0)
    return name;

  const char* const data_rel_ro_local = ".data.rel.ro.local";
  if (strncmp(name, data_rel_ro_local, strlen(data_rel_ro_local)) == 0)
d2942 5
a2946 9
      *plen = strlen(data_rel_ro_local);
      return data_rel_ro_local;
    }

  const char* const data_rel_ro = ".data.rel.ro";
  if (strncmp(name, data_rel_ro, strlen(data_rel_ro)) == 0)
    {
      *plen = strlen(data_rel_ro);
      return data_rel_ro;
a2948 1
  *plen = sdot - name;
@


1.122
log
@	* gold.h (reserve_unordered_map): Define, three versions, one for
	each version of Unordered_map.
	* layout.cc (Layout::Layout): Remove options parameter.  Add
	number_of_input_files parameter.  Don't initialize options_.
	Initialize number_of_input_files_ and resized_signatures_.  Move
	sections_are_attached_.
	(Layout::layout_group): Reserve space for group_signatures_.
	(Layout::find_or_add_kept_section): Change name parameter to be a
	reference.  Resize signatures_ map when it gets large enough.
	(Layout::layout_eh_frame): Use parameters->options() instead of
	this->options_.
	(Layout::make_output_section): Likewise.
	(Layout::attach_allocated_section_to_segment): Likewise.
	(Layout::finalize, Layout::create_executable_stack): Likewise.
	(Layout::set_segment_offsets, Layout::create_interp): Likewise.
	(Layout::finish_dynamic_section, Layout::write_binary): Likewise.
	* layout.h (class Layout): Update declarations.  Remove options_
	field.  Add number_of_input_files_ and resized_signatures_
	fields.  Move sections_are_attached_ field.
	* main.cc (main): Pass number of input files to Layout
	constructor.  Don't pass options.
@
text
@d49 2
a51 1
#include "plugin.h"
d126 2
a127 1
    resized_signatures_(false)
d136 4
d1224 6
d1608 31
@


1.121
log
@2009-03-19  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* layout.cc (Layout::output_section_name): Preserve names
	of '.note.' sections.
@
text
@d89 2
a90 2
Layout::Layout(const General_options& options, Script_options* script_options)
  : options_(options),
a99 1
    sections_are_attached_(false),
d119 1
d124 2
a125 1
    any_postprocessing_sections_(false)
d585 4
d639 1
a639 1
      if (this->options_.eh_frame_hdr())
d759 1
a759 1
      && strcmp(this->options_.compress_debug_sections(), "none") != 0
d761 2
a762 1
    os = new Output_compressed_section(&this->options_, name, type, flags);
d765 1
a765 1
           && this->options_.strip_debug_non_line()
d774 1
a774 1
           && this->options_.strip_debug_non_line()
d886 1
a886 1
          if (this->options_.user_set_Tbss())
d1229 2
a1230 1
  if (this->options_.oformat_enum() != General_options::OBJECT_FORMAT_ELF)
d1251 1
a1251 1
				       this->options_.entry());
d1464 2
a1465 2
  if (this->options_.is_execstack_set())
    is_stack_executable = this->options_.is_stack_executable();
d1727 2
a1728 2
  if (this->options_.user_set_Ttext())
    addr = this->options_.Ttext();
d1771 1
a1771 1
	  else if (this->options_.user_set_Tdata()
d1773 1
a1773 1
		   && (!this->options_.user_set_Tbss()
d1776 1
a1776 1
	      addr = this->options_.Tdata();
d1779 1
a1779 1
	  else if (this->options_.user_set_Tbss()
d1783 1
a1783 1
	      addr = this->options_.Tbss();
d2626 1
a2626 1
  const char* interp = this->options_.dynamic_linker();
d2678 1
a2678 1
      const char* soname = this->options_.soname();
d2695 1
a2695 1
  const General_options::Dir_list& rpath(this->options_.rpath());
d2958 1
a2958 1
Layout::find_or_add_kept_section(const std::string name,
d2962 11
d3209 1
a3209 1
  gold_assert(this->options_.oformat_enum()
@


1.120
log
@2009-03-17  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* layout.h (Layout::create_note): Add section_name parameter.
	* layout.cc (Layout::create_note): Likewise.
	(Layout::create_build_id, Layout::create_gold_note): Fix callers.
@
text
@d2902 3
d2920 2
@


1.119
log
@	* layout.cc (Layout::find_or_add_kept_section): New function.
	(Layout::add_comdat): Removed.
	* layout.h (struct Kept_section): Move out of class Layout.
	Remove trailing underscores from field names.  Add group_sections
	field.  Rename group_ field to is_group.  Change all uses.
	(class Layout): Declare find_or_add_kept_section, not add_comdat.
	* object.cc (Sized_relobj::Sized_relobj): Don't initialize
	comdat_groups_ field.
	(Sized_relobj::include_section_group): Use
	find_or_add_kept_section and Kept_section::group_sections.
	(Sized_relobj::include_linkonce_section): Likewise.
	* object.cc (class Sized_relobj): Don't define Comdat_group or
	Comdat_group_table.  Remove find_comdat_group and
	add_comdat_group.  Remove comdat_groups_ field.
	* plugin.cc (include_comdat_group): Use
	Layout::find_or_add_kept_section.
@
text
@d1330 2
a1331 1
Layout::create_note(const char* name, int note_type, size_t descsz,
d1398 1
a1398 1
  const char* note_name = this->namepool_.add(".note", false, NULL);
d1428 2
a1429 1
					 desc.size(), false, &trailing_padding);
d1561 2
a1562 1
					 descsz, true, &trailing_padding);
@


1.118
log
@	PR 6811
	* options.h (class Search_directory): Add is_system_directory.
	(class General_options): Declare is_in_system_directory.
	* options.cc (get_relative_sysroot): Make static.
	(get_default_sysroot): Make static.
	(General_optoins::is_in_system_directory): New function.
	* fileread.cc (Input_file::is_in_system_directory): New function.
	* fileread.h (class Input_file): Declare is_in_system_directory.
	* object.h (class Object): Add is_in_system_directory.
	(class Input_objects): Remove system_library_directory_ field.
	* object.cc (Input_objects::add_object): Don't set
	system_library_directory_.
	(input_objects::found_in_system_library_directory): Remove.
	* symtab.cc (Symbol_table::write_globals): Remove input_objects
	parameter.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::warn_about_undefined_dynobj_symbol): Likewise.
	Call Object::is_in_system_directory.
	* symtab.h (class Symbol_table): Update declarations.
@
text
@d2933 8
a2940 6
// Record the signature of a comdat section, and return whether to
// include it in the link.  If GROUP is true, this is a regular
// section group.  If GROUP is false, this is a group signature
// derived from the name of a linkonce section.  We want linkonce
// signatures and group signatures to block each other, but we don't
// want a linkonce signature to block another linkonce signature.
d2943 3
a2945 2
Layout::add_comdat(Relobj* object, unsigned int shndx,
                   const std::string& signature, bool group)
a2946 1
  Kept_section kept(object, shndx, group);
d2948 1
a2948 1
    this->signatures_.insert(std::make_pair(signature, kept)));
d2950 2
d2958 1
a2958 1
  if (ins.first->second.group_)
d2963 1
a2963 1
      if (ins.first->second.object_ == NULL
d2966 1
a2966 1
          ins.first->second = kept;
d2971 1
a2971 1
  else if (group)
d2976 1
a2976 1
      ins.first->second.group_ = true;
d2984 1
d2999 2
a3000 2
    *pshndx = p->second.shndx_;
  return p->second.object_;
d3109 1
a3109 1
      
@


1.117
log
@	* layout.cc (Layout::choose_output_section): Don't rename sections
	when using a linker script that has a SECTIONS clause.
	* Makefile.in: Regenerate.

	* testsuite/Makefile.am (script_test_5.sh): New test case.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/script_test_5.cc: New file.
	* testsuite/script_test_5.sh: New file.
	* testsuite/script_test_5.t: New file.
@
text
@d3320 2
a3321 2
  this->symtab_->write_globals(this->input_objects_, this->sympool_,
			       this->dynpool_, this->layout_->symtab_xindex(),
@


1.116
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d429 3
a431 1
  if (is_input_section && !parameters->options().relocatable())
@


1.115
log
@	* layout.cc (Layout::add_comdat): Allow COMDAT group from a replacement
	object to override a kept COMDAT group from a plugin object.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
a142 8
// Return whether PREFIX is a prefix of STR.

static inline bool
is_prefix_of(const char* prefix, const char* str)
{
  return strncmp(prefix, str, strlen(prefix)) == 0;
}

@


1.114
log
@	* layout.cc (Layout::include_section): Check for SHF_EXCLUDE.
	Handle --strip-lto-sections option.
	* options.h (strip_lto_sections): New option.
@
text
@d50 1
d2963 8
@


1.113
log
@2008-09-11  Chris Demetriou  <cgd@@google.com>

        * options.h (origin): New -z option.
        * layout.cc (Layout:finish_dynamic_section): If "-z origin"
        is specified, set DF_ORIGIN in DT_FLAGS and set DF_1_ORIGIN
        in DT_FLAGS_1.
@
text
@d209 3
d262 8
@


1.112
log
@	* layout.cc (Layout::attach_allocated_section_to_segment): Don't
	set tls_segment_ or relro_segment_.
	(Layout::make_output_segment): Set tls_segment_ and relro_segment_
	when appropriate.
	* output.h (Output_section::clear_is_relro): New function.
	* output.cc (Output_segment::add_output_section): Handle SHF_TLS
	sections specially even when output_data_ is empty.
	(Output_segment::maximum_alignment): When first section is relro,
	only force alignment for PT_LOAD segments.
	* script.cc (script_data_segment_align): New function.
	(script_data_segment_relro_end): New function.
	* script-c.h (script_data_segment_align): Declare.
	(script_data_segment_relro_end): Declare.
	* script-sections.h (class Script_sections): Declare
	data_segment_align and data_segment_relro_end.  Add fields
	segment_align_index_ and saw_relro_end_.
	* script-sections.cc (class Sections_element): Add set_is_relro
	virtual function.  Add new bool* parameter to place_orphan_here.
	Add get_output_section virtual function.
	(class Output_section_definition): Add set_is_relro.  Add new
	bool* parameter to place_orphan_here.  Add get_output_section.
	Add is_relro_ field.
	(Output_section_definition::Output_section_definition): Initialize
	evaluated_address_, evaluated_load_address, evaluated_addralign_,
	and is_relro_ fields.
	(Output_section_definition::place_orphan_here): Add is_relro
	parameter.
	(Output_section_definition::set_section_addresses): Set relro for
	output section.
	(Output_section_definition::alternate_constraint): Likewise.
	(class Orphan_output_section): Add new bool* parameter to
	place_orphan_here.  Add get_output_section.
	(Orphan_output_section::place_orphan_here): Add is_relro
	parameter.
	(Script_sections::Script_sections): Initialize
	data_segment_align_index_ and saw_relro_end_.
	(Script_sections::data_segment_align): New function.
	(Script_sections::data_segment_relro_end): New function.
	(Script_sections::place_orphan): Set or clear is_relro.
	(Script_sections::set_section_addresses): Force alignment of first
	TLS section.
	* yyscript.y (exp): Call script_data_segment_align and
	script_data_segment_relro_end.
	* testsuite/relro_script_test.t: New file.
	* testsuite/relro_test.cc (using_script): Declare.
	(t1, t2): Test using_script.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_script_test.
	(relro_script_test_SOURCES): Define.
	(relro_script_test_DEPENDENCIES): Define.
	(relro_script_test_LDFLAGS): Define.
	(relro_script_test_LDADD): Define.
	(relro_script_test.so): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d2756 2
d2779 2
@


1.111
log
@	PR 5990
	* descriptors.cc: New file.
	* descriptors.h: New file.
	* gold-threads.h (class Hold_optional_lock): New class.
	* fileread.cc: Include "descriptors.h".
	(File_read::~File_read): Release descriptor rather than closing
	it.
	(File_read::open) [file]: Call open_descriptor rather than open.
	Set is_descriptor_opened_.
	(File_read::open) [memory]: Assert that descriptor is not open.
	(File_read::reopen_descriptor): New function.
	(File_read::release): Release descriptor.
	(File_read::do_read): Make non-const.  Reopen descriptor.
	(File_read::read): Make non-const.
	(File_read::make_view): Reopen descriptor.
	(File_read::do_readv): Likewise.
	* fileread.h (class File_read): Add is_descriptor_opened_ field.
	Update declarations.
	* layout.cc: Include "descriptors.h".
	(Layout::create_build_id): Use open_descriptor rather than open.
	* output.cc: Include "descriptors.h".
	(Output_file::open): Use open_descriptor rather than open.
	* archive.cc (Archive::const_iterator): Change Archive to be
	non-const.
	(Archive::begin, Archive::end): Make non-const.
	(Archive::count_members): Likewise.
	* archive.h (class Archive): Update declarations.
	* object.h (Object::read): Make non-const.
	* Makefile.am (CCFILES): Add descriptors.cc.
	(HFILES): Add descriptors.h.
	* Makefile.in: Rebuild.
@
text
@d924 1
a924 2
        this->tls_segment_ = this->make_output_segment(elfcpp::PT_TLS,
                                                       seg_flags);
d934 1
a934 2
	this->relro_segment_ = this->make_output_segment(elfcpp::PT_GNU_RELRO,
							 seg_flags);
d3000 6
@


1.110
log
@	* options.h (class General_options): Define --check-sections.
	* layout.cc (Layout::set_segment_offsets): Handle
	--check-sections.
@
text
@d48 1
d1511 1
a1511 1
      int descriptor = ::open("/dev/urandom", O_RDONLY);
d1518 1
a1518 1
	  ::close(descriptor);
@


1.109
log
@	* options.h (class General_options): Define -n/--nmagic and
	-N/--omagic.
	* options.cc (General_options::finalize): For -n/--nmagic or
	-N/--omagic, set -static.
	* layout.cc (Layout::attach_allocated_section_to_segment): If
	-N/--omagic, don't put read-only and read-write sections in
	different segments.
	(Layout::find_first_load_seg): If -N/--omagic, don't insist on
	finding a read-only segment.
	(Layout::set_segment_offsets): If -N/--omagic or -n/--nmagic,
	don't set the minimum segment alignment to the common page size,
	and don't set the file offset to the address modulo the page size.
	* script-sections.cc (Script_sections::create_segments): If
	-n/--omagic, don't put read-only and read-write sections in
	different segments.
@
text
@d1735 3
d1854 19
@


1.108
log
@	Handle output sections with more than 0x7fffffff bytes.
	* object.h (class Relobj): Change map_to_output_ to
	output_sections_, and just keep a section pointer.  Change all
	uses.  Move comdat group support to Sized_relobj.
	(Relobj::is_section_specially_mapped): Remove.
	(Relobj::output_section): Remove poff parameter.  Change all
	callers.
	(Relobj::output_section_offset): New function.
	(Relobj::set_section_offset): Rewrite.
	(Relobj::map_to_output): Remove.
	(Relobj::output_sections): New function.
	(Relobj::do_output_section_offset): New pure virtual function.
	(Relobj::do_set_section_offset): Likewise.
	(class Sized_relobj): Add section_offsets_ field.  Add comdat
	group support from Relobj.  Update declarations.
	(Sized_relobj::get_output_section_offset): New function.
	(Sized_relobj::do_output_section_offset): New function.
	(Sized_relobj::do_set_section_offset): New function.
	* object.cc (Relobj::output_section_address): Remove.
	(Sized_relobj::Sized_relobj): Initialize new fields.
	(Sized_relobj::include_section_group): Cast find_kept_object to
	Sized_relobj.
	(Sized_relobj::include_linkonce_section): Likewise.
	(Sized_relobj::do_layout): Use separate arrays for output section
	and output offset.
	(Sized_relobj::do_count_local_symbols): Change map_to_output to
	output_sections.
	(Sized_relobj::do_finalize_local_symbols): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_local_symbols): Likewise.
	(map_to_kept_section): Compute output address directly.
	* reloc.cc (Sized_relobj::do_read_relocs): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_sections): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (sized_finalize_symbol): Use output_section_offset.
	* output.h (class Output_reloc): Update declarations.  Change
	u2_.relobj to Sized_relobj*.
	(class Output_data_reloc): Change add functions to use
	Sized_relobj*.
	* output.cc (Output_reloc::Output_reloc): Change relobj to
	Sized_relobj*.
	(Output_reloc::local_section_offset): Change return type to
	Elf_Addr.  Use get_output_section_offset.
	(Output_reloc::get_address): Likewise.
	(Output_section::is_input_address_mapped): Don't call
	is_section_specially_mapped.
	(Output_section::output_offset): Likewise.
	(Output_section::output_address): Likewise.
	(Output_section::starting_output_address): Likewise.
	* copy-relocs.cc (Copy_relocs::copy_reloc): Change object
	parameter to Sized_relobj*.
	(Copy_relocs::need_copy_reloc): Likewise.
	(Copy_relocs::save): Likewise.
	* copy-relocs.h (class Copy_relocs): Update declarations.
	(class Copy_relocs::Copy_reloc_entry): Change constructor to use
	Sized_relobj*.  Change relobj_ field to Sized_relobj*.
	* target-reloc.h (relocate_for_relocatable): Change
	offset_in_output_section type to Elf_Addr.  Change code that uses
	it as well.
	* layout.cc (Layout::layout): Always set *off.
	* mapfile.cc (Mapfile::print_input_section): Use
	output_section_offset.
	* i386.cc (Target_i386::copy_reloc): Change object parameter to
	Sized_relobj*.
	* powerpc.cc (Target_powerpc::copy_reloc): Likewise.
	* sparc.cc (Target_sparc::copy_reloc): Likewise.
	* x86_64.cc (Target_x86_64::copy_reloc): Likewise.
@
text
@d868 2
a869 1
          && ((*p)->flags() & elfcpp::PF_W) == (seg_flags & elfcpp::PF_W))
d1112 2
a1113 1
	  && ((*p)->flags() & elfcpp::PF_W) == 0)
d1774 1
d1776 3
a1778 2
	  // FIXME: This should depend on the -n and -N options.
	  (*p)->set_minimum_p_align(target->common_pagesize());
d1782 12
a1793 8
	      // Adjust the file offset to the same address modulo the
	      // page size.
	      uint64_t unsigned_off = off;
	      uint64_t aligned_off = ((unsigned_off & ~(abi_pagesize - 1))
				      | (addr & (abi_pagesize - 1)));
	      if (aligned_off < unsigned_off)
		aligned_off += abi_pagesize;
	      off = aligned_off;
a1827 1
	      uint64_t common_pagesize = target->common_pagesize();
@


1.107
log
@	* layout.cc (Layout::include_section): Do not discard unrecognized
	SHT_STRTAB sections.
@
text
@d451 2
@


1.106
log
@elfcpp/:
	* dwarf.h (enum DW_FORM): Define.
gold/:
	* reduced_debug_output.cc: New file.
	* reduced_debug_output.h: New file.
	* options.h (class General_optoins): Add --strip-debug-non-line.
	* options.cc (General_options::finalize): Add strip_debug_non_line
	to the strip heirarchy.
	* layout.h (class Layout): Add debug_abbrev_ and debug_info_
	fields.
	* layout.cc: Include "reduced_debug_output.h".
	(Layout::Layout): Initialize new fields.
	(line_only_debug_sections): New static array.
	(is_lines_only_debug_sections): New static inline function.
	(Layout::include_section): Handle --strip-debug-non-line.
	(Layout::make_output_section): If --strip-debug-non-line, build
	new output sections for .debug_abbrev and .debug_info.
	* dwarf_reader.cc (read_unsigned_LEB_128): Move to namespace
	gold.  Warn about possible overflow.
	(read_signed_LEB_128): Likewise.
	* dwarf_reader.h: (read_unsigned_LEB_128): Declare.
	(read_signed_LEB_128): Declare.
	* Makefile.am (CCFILES): Add reduced_debug_output.cc.
	(HFILES): Add reduced_debug_output.h.
	* Makefile.in: Rebuild.
@
text
@a212 1
    case elfcpp::SHT_STRTAB:
d218 8
@


1.105
log
@	* mapfile.cc: New file.
	* mapfile.h: New file.
	* options.h (class General_options): Add -M/--print-map and -Map.
	* options.cc (General_options::finalize): Make -M equivalent to
	-Map -.
	* main.cc: Include <cstdio> and "mapfile.h".
	(main): Open mapfile if requested.
	* gold.cc (class Middle_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(queue_initial_tasks): Add mapfile parameter.  Change caller.
	(queue_middle_tasks): Likewise.
	* gold.h (queue_initial_tasks, queue_middle_tasks): Update
	declarations.
	* archive.cc: Include "mapfile.h".
	(Archive::add_symbols): Add mapfile parameter.  Change all
	callers.  Pass mapfile, symbol, and reason to include_member.
	(Archive::include_all_members): Add mapfile parameter.  Change all
	callers.
	(Archive::include_member): Add mapfile, sym, and why parameters.
	Change all callers.  Report inclusion to map file.
	* archive.h: Include "fileread.h".
	(class Archive): Update declarations.
	(Archive::file): New const method.
	(class Add_archive_symbols): Add mapfile_ field.  Update
	constructor.  Change all callers.
	* readsyms.h (class Read_symbols): Likewise.
	(class Finish_group): Likewise.
	(class Read_script): Likewise.
	* common.cc: Include "mapfile.h".
	(Symbol_table::allocate_commons): Add mapfile parameter.  Change
	all callers.
	(Symbol_table::do_allocate_commons): Likewise.
	(Symbol_table::do_allocate_commons_list): Likewise.  Report common
	symbol allocation to mapfile.
	* common.h (class Allocate_commons_task): Add mapfile_ field.
	Update constructor.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* layout.cc: Include "mapfile.h".
	(Layout_task_runner::run): Print information to mapfile.
	(Layout::create_gold_note): Change Output_data_fixed_space to
	Output_data_zero_fill.
	(Layout::create_build_id): Likewise.
	(Layout::print_to_mapfile): New function.
	* layout.h (class Layout_task_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(class Layout): Declare print_to_mapfile.
	* output.cc (Output_section::Input_section::print_to_mapfile): New
	function.
	(Output_section::add_input_section): If producing a map, always
	add to input_sections_ list.
	(Output_section::do_print_to_mapfile): New function.
	(Output_segment::print_sections_to_mapfile): New function.
	(Output_segment::print_section_list_to_mapfile): New function.
	* output.h: Include "mapfile.h".
	(Output_data::print_to_mapfile): New function.
	(Output_data::do_print_to_mapfile): New virtual function.
	(Output_segment_headers::do_print_to_mapfile): New function.
	(Output_file_header::do_print_to_mapfile): New function.
	(Output_data_const::do_print_to_mapfile): New function.
	(class Output_data_const_buffer): Add map_name_ field.  Update
	constructor.  Change all callers.  Add do_print_to_mapfile
	function.
	(class Output_data_fixed_space): Likewise.
	(class Output_data_space): Likewise.
	(class Output_data_zero_fill): New class.
	(Output_data_strtab::do_print_to_mapfile): New function.
	(Output_data_reloc_base::do_print_to_mapfile): New function.
	(Output_relocatable_relocs::do_print_to_mapfile): New function.
	(Output_data_group::do_print_to_mapfile): New function.
	(Output_data_got::do_print_to_mapfile): New function.
	(Output_data_dynamic::do_print_to_mapfile): New function.
	(Output_symtab_xindex::do_print_to_mapfile): New function.
	(class Output_section): Declare do_print_to_mapflie.  Declare
	print_to_mapfile in Input_section.
	(class Output_segment): Declare new functions.
	* object.h (Sized_relobj::symbol_count): New function.
	* script-sections.cc
	(Output_section_element_dot_assignment::set_section_addresses):
	Change Output_data_fixed_space to Output_data_zero_fill.
	(Output_data_expression::do_print_to_mapfile): New function.
	* script.cc (read_input_script): Add mapfile parameter.  Change
	all callers.
	* script.h (read_input_script): Update declaration.
	* ehframe.h (Eh_frame_hdr::do_print_to_mapfile): New function.
	(Eh_frame::do_print_to_mapfile): New function.
	* merge.h (Output_merge_data::do_print_to_mapfile): New function.
	(Output_merge_string::do_print_to_mapfile): New function.
	* i386.cc (Output_data_plt_i386::do_print_to_mapfile): New
	function.
	* sparc.cc (Output_data_plt_sparc::do_print_to_mapfile): New
	function.
	* x86_64.cc (Output_data_plt_x86_64::do_print_to_mapfile): New
	function.
	* Makefile.am (CCFILES): Add mapfile.cc.
	(HFILES): Add mapfile.h.
	* Makefile.in: Rebuild.
@
text
@d46 1
d114 2
d166 13
d189 12
d235 8
d741 20
a760 1
  else
@


1.104
log
@	* options.h (class General_options): Add -z relro.
	* layout.cc (Layout::Layout): Initialize relro_segment_.
	(Layout::add_output_section_data): Return the output section.
	(Layout::make_output_section): Rcognize relro sections and mark
	them appropriately.
	(Layout::attach_allocated_section_to_segment): Put relro sections
	in a PT_GNU_RELRO segment.
	(Layout::create_initial_dynamic_sections): Mark the .dynamic
	section as relro.
	(Layout::segment_precedes): Sort PT_GNU_RELRO segments after
	PT_TLS segments.
	(Layout::linkonce_mapping): Map d.rel.ro.local to
	.data.rel.ro.local.
	(Layout::output_section_name): Us .data.rel.ro.local for any
	section which begins with that.
	* layout.h (class Layout): Update add_output_section_data
	declaration.  Add relro_segment_ field.
	* output.cc (Output_section::Output_section): Initialize is_relro_
	and is_relro_local_ fields.
	(Output_segment::add_output_section): Group relro sections.
	(Output_segment::is_first_section_relro): New function.
	(Output_segment::maximum_alignment): If there is a relro section,
	align the segment to the common page size.
	(Output_segment::set_section_addresses): Track whether we are
	looking at relro sections.  If the last section is a relro
	section, align to the common page size.
	(Output_segment::set_section_list_addresses): Add in_relro
	parameter.  Change all callers.  Align to the page size when
	moving from relro to non-relro section.
	(Output_segment::set_offset): Align memsz of a PT_GNU_RELRO
	segment.
	* output.h (class Output_section): Add is_relro_ and
	is_relro_local_ fields.
	(Output_section::is_relro): New function.
	(Output_section::set_is_relro): New function.
	(Output_section::is_relro_local): New function.
	(Output_section::set_is_relro_local): New function.
	(class Output_segment): Update declarations.
	* i386.cc (Target_i386::got_section): Mark .got section as relro.
	* sparc.cc (Target_sparc::got_section): Likewise.
	* x86_64.cc (Target_x86_64::got_section): Likewise.
	* testsuite/relro_test_main.cc: New file.
	* testsuite/relro_test.cc: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_test.
	(relro_test_SOURCES, relro_test_DEPENDENCIES): New variables.
	(relro_test_LDFLAGS, relro_test_LDADD): New variables.
	(relro_test.so, relro_test_pic.o): New targets.
	* testsuite/Makefile.in: Rebuild.
@
text
@d38 1
d67 7
d1334 2
a1335 1
							   size / 8);
d1363 1
a1363 1
      posd = new Output_data_fixed_space(trailing_padding, 0);
d1500 1
a1500 1
	  posd = new Output_data_fixed_space(trailing_padding, 0);
d1509 1
a1509 1
      this->build_id_note_ = new Output_data_fixed_space(descsz, 4);
d2061 2
a2062 1
							     align);
d2243 2
a2244 1
							   align);
d2323 2
a2324 1
								   align);
d2348 2
a2349 1
								   align);
d2451 2
a2452 1
  Output_section_data* vdata = new Output_data_const_buffer(vbuf, vsize, 2);
d2475 2
a2476 3
      Output_section_data* vddata = new Output_data_const_buffer(vdbuf,
								 vdsize,
								 4);
d2501 2
a2502 3
      Output_section_data* vndata = new Output_data_const_buffer(vnbuf,
								 vnsize,
								 4);
d3101 11
@


1.103
log
@	* output.cc (Output_segment::add_output_section): Remove front
	parameter.
	* output.h (class Output_segment): Remove
	add_initial_output_section and overloaded add_output_section.
	Update declaration of remaining add_output_section.
	* layout.cc (Layout::create_interp): Call add_output_section
	rather than add_initial_output_section.
	(Layout::finish_dynamic_section): Likewise.
@
text
@d93 1
d641 2
a642 1
// Add POSD to an output section using NAME, TYPE, and FLAGS.
d644 1
a644 1
void
d653 1
d712 17
d854 11
d935 1
d1543 17
a1559 4
  // We put the PT_TLS segment last, because that is where the dynamic
  // linker expects to find it (this is just for efficiency; other
  // positions would also work correctly).
  if (type1 == elfcpp::PT_TLS && type2 != elfcpp::PT_TLS)
d1561 1
a1561 1
  if (type2 == elfcpp::PT_TLS && type1 != elfcpp::PT_TLS)
d2682 2
a2683 1
  MAPPING_INIT("d.rel.ro", ".data.rel.ro"),	// Must be before "d".
d2785 3
d2801 7
@


1.102
log
@	* object.cc (Sized_relobj::include_section_group): Adjust section
	indexes read from group data.  Build vector to pass to
	layout_group.
	* layout.cc (Layout::layout_group): Add flags and shndxes
	parameters.  Remove contents parameter.  Change caller.  Update
	explicit instantiations.
	* layout.h (class Layout): Update layout_group declaration.
	* output.cc (Output_data_group::Output_data_group): Add flags and
	input_shndxes parameters.  Remove contents parameter.  Change
	caller.
	(Output_data_group::do_write): Change input_sections_ to
	input_shndxes_.
	* output.h (class Output_data_group): Update constructor
	declaration.  Rename input_sections_ to input_shndxes_.
	* testsuite/many_sections_test.cc: Add template.
@
text
@d2482 1
a2482 1
      oseg->add_initial_output_section(osec, elfcpp::PF_R);
d2497 2
a2498 2
      oseg->add_initial_output_section(this->dynamic_section_,
				       elfcpp::PF_R | elfcpp::PF_W);
@


1.101
log
@	* layout.cc (Layout::include_section): Refactored check for debug
	info section.
	(Layout::add_comdat): Add new parameters.  Change type
	of signature parameter.  Add object and shndx to signatures table.
	(Layout::find_kept_object): New function.
	* layout.h: Include <cstring>.
	(Layout::is_debug_info_section): New function.
	(Layout::add_comdat): Add new parameters.
	(Layout::find_kept_object): New function.
	(Layout::Kept_section): New struct.
	(Layout::Signatures): Change type of map range.
	* object.cc (Relobj::output_section_address): New function.
	(Sized_relobj::include_section_group): Add new parameters.  Change
	calls to Layout::add_comdat.  Change to build table of kept comdat
	groups and table mapping discarded sections to kept sections.
	(Sized_relobj::include_linkonce_section): Likewise.  Add new parameter.
	(Sized_relobj::do_layout): Change calls to include_section_group and
	include_linkonce_section.
	(Sized_relobj::do_finalize_local_symbols): Do not set local symbol
	value to zero when section is discarded.
	(Sized_relobj::map_to_kept_section): New function.
	* object.h (Relobj::output_section_address): New function.
	(Relobj::Comdat_group): New type.
	(Relobj::find_comdat_group): New function.
	(Relobj::Comdat_group_table): New type.
	(Relobj::Kept_comdat_section): New type.
	(Relobj::Kept_comdat_section_table): New type.
	(Relobj::add_comdat_group): New function.
	(Relobj::set_kept_comdat_section): New function.
	(Relobj::get_kept_comdat_section): New function.
	(Relobj::comdat_groups_): New field.
	(Relobj::kept_comdat_sections_): New field.
	(Symbol_value::input_value): Update comment.
	(Sized_relobj::map_to_kept_section) New function.
	(Sized_relobj::include_linkonce_section): Add new parameter.
	* target-reloc.h (Comdat_behavior): New type.
	(get_comdat_behavior): New function.
	(relocate_section): Add code to map a discarded section to the
	corresponding kept section when applying a relocation.
@
text
@d506 2
a507 1
		     const elfcpp::Elf_Word* contents)
d535 2
a536 1
    new Output_data_group<size, big_endian>(object, entry_count, contents);
d3263 2
a3264 1
				const elfcpp::Elf_Word* contents);
d3276 2
a3277 1
			       const elfcpp::Elf_Word* contents);
d3289 2
a3290 1
				const elfcpp::Elf_Word* contents);
d3302 2
a3303 1
			       const elfcpp::Elf_Word* contents);
@


1.100
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d195 1
a195 5
	  // Debugging sections can only be recognized by name.
	  if (is_prefix_of(".debug", name)
	      || is_prefix_of(".gnu.linkonce.wi.", name)
	      || is_prefix_of(".line", name)
	      || is_prefix_of(".stab", name))
d2769 2
a2770 1
Layout::add_comdat(const char* signature, bool group)
d2772 1
a2772 1
  std::string sig(signature);
d2774 1
a2774 1
    this->signatures_.insert(std::make_pair(sig, group)));
d2782 1
a2782 1
  if (ins.first->second)
d2792 1
a2792 1
      ins.first->second = true;
d2804 14
@


1.99
log
@elfcpp/

	* elfcpp.h (DF_1_NOW, DF_1_GLOBAL, DF_1_GROUP,
	DF_1_NODELETE, DF_1_LOADFLTR, DF_1_INITFIRST,
	DF_1_NOOPEN, DF_1_ORIGIN, DF_1_DIRECT, DF_1_TRANS,
	DF_1_INTERPOSE, DF_1_NODEFLIB, DF_1_NODUMP,
	DF_1_CONLFAT): New enum constants.

gold/

	* options.h (DEFINE_enable): New macro.
	(new_dtags): New enable option.
	(initfirst, interpose, loadfltr, nodefaultlib,
	nodelete, nodlopen, nodump): New -z options.
	* layout.cc (Layout:finish_dynamic_section): If new
	dtags enabled, emit DT_RUNPATH.  Also, emit a
	DT_FLAGS_1 containing any specified -z flags.
@
text
@d79 27
a105 9
  : options_(options), script_options_(script_options), namepool_(),
    sympool_(), dynpool_(), signatures_(),
    section_name_map_(), segment_list_(), section_list_(),
    unattached_section_list_(), sections_are_attached_(false),
    special_output_list_(), section_headers_(NULL), tls_segment_(NULL),
    symtab_section_(NULL), dynsym_section_(NULL), dynamic_section_(NULL),
    dynamic_data_(NULL), eh_frame_section_(NULL), eh_frame_data_(NULL),
    added_eh_frame_data_(false), eh_frame_hdr_section_(NULL),
    build_id_note_(NULL), group_signatures_(), output_file_size_(-1),
d1170 4
d1175 1
a1175 1
  this->create_symtab_sections(input_objects, symtab, &off);
d1190 2
a1191 1
  // Now that all sections have been created, set the section indexes.
d1195 1
a1195 1
  this->create_shdrs(&off);
a1841 1
  const bool output_is_object = parameters->options().relocatable();
d1846 5
a1850 7
      // In a relocatable link, we already did group sections.
      if (output_is_object
	  && (*p)->type() == elfcpp::SHT_GROUP)
	continue;

      (*p)->set_out_shndx(shndx);
      ++shndx;
d1916 1
a1916 1
// fully laid out.
d1921 1
d2012 32
d2091 1
a2091 1
Layout::create_shdrs(off_t* poff)
d2098 2
a2099 1
				      &this->namepool_);
d2107 13
a2162 2
  // FIXME: We have to tell set_dynsym_indexes whether the
  // -E/--export-dynamic option was used.
d2203 31
d2865 1
a2865 1
	      symtab->write_section_symbol(*p, of, off);
d2882 1
a2882 1
	  symtab->write_section_symbol(*p, of, off);
d3113 2
a3114 1
			       this->dynpool_, this->of_);
@


1.98
log
@	* layout.cc (Layout::Layout): Initialize sections_are_attached_.
	(Layout::get_output_section): Ignore SHF_WRITE and SHF_EXECINSTR
	in the name/type/flags to section mapping.  Don't call
	allocate_output_section.
	(Layout::choose_output_section): Change parameter from adjust_name
	to is_input_section.  Don't permit input sections after sections
	are attached to segments.  Don't call allocate_output_section.
	(Layout::layout_eh_frame): Call update_flags_for_input_section,
	not write_enable_output_section.
	(Layout::make_output_section): Don't push to
	unattached_section_list_ nor call attach_to_segment.  Call
	attach_section_to_segment if sections are attached.
	(Layout::attach_sections_to_segments): New function.
	(Layout::attach_section_to_segment): New function.
	(Layout::attach_allocated_section_to_segment): Rename from
	attach_to_segment.  Remove flags parameter.
	(Layout::allocate_output_section): Remove function.
	(Layout::write_enable_output_section): Remove function.
	* layout.h (class Layout): Update for above changes.  Add new
	field sections_are_attached_.
	* output.h (Output_section::update_flags_for_input_section): New
	function.
	* output.cc (Output_section::add_input_section): Call
	update_flags_for_input_section.
	* gold.cc (queue_middle_tasks): Call attach_sections_to_segments.
@
text
@d2462 2
d2514 22
@


1.97
log
@	* layout.h (class Layout): Add added_eh_frame_data_ field.
	* layout.cc (Layout::Layout): Initialize new field.
	(Layout::layout_eh_frame): Don't add eh_frame_data_ to .eh_frame
	output section until we find a section we merged successfully.
	* object.cc (Sized_relobj::check_eh_frame_flags): Don't require
	that the size be non-zero.
@
text
@d82 4
a85 4
    unattached_section_list_(), special_output_list_(),
    section_headers_(NULL), tls_segment_(NULL), symtab_section_(NULL),
    dynsym_section_(NULL), dynamic_section_(NULL), dynamic_data_(NULL),
    eh_frame_section_(NULL), eh_frame_data_(NULL),
d237 9
a245 1
  const Key key(name_key, std::make_pair(type, flags));
d279 1
a279 5
                {
                  os = p->second;
                  if ((flags & elfcpp::SHF_ALLOC) != 0)
                    this->allocate_output_section(os, flags);
                }
d292 4
a295 3
// linker created section.  ADJUST_NAME is true if we should apply the
// standard name mappings in Layout::output_section_name.  This will
// return NULL if the input section should be discarded.
d300 1
a300 1
			      bool adjust_name)
d302 6
a307 2
  // We should ignore some flags.  FIXME: This will need some
  // adjustment for ld -r.
d336 1
a336 11
            {
              // If the output section was created unallocated, and we
              // are now allocating it, then we need to clear the
              // address set in the constructor and remove it from the
              // unattached section list.
              if (((*output_section_slot)->flags() & elfcpp::SHF_ALLOC) == 0
                  && (flags & elfcpp::SHF_ALLOC) != 0)
                this->allocate_output_section(*output_section_slot, flags);

              return *output_section_slot;
            }
d358 1
a358 1
  if (adjust_name && !parameters->options().relocatable())
a551 10
  // On some targets gcc assumes that a read-only .eh_frame section
  // will be merged with a read-write .eh_frame section.
  if ((shdr.get_sh_flags() & elfcpp::SHF_WRITE) != 0
      && (os->flags() & elfcpp::SHF_WRITE) == 0)
    {
      elfcpp::Elf_Xword new_flags = os->flags() | elfcpp::SHF_WRITE;
      this->write_enable_output_section(os, new_flags);
      os->set_flags(new_flags);
    }

d598 2
a682 5
  if ((flags & elfcpp::SHF_ALLOC) == 0)
    this->unattached_section_list_.push_back(os);
  else
    this->attach_to_segment(os, flags);

d693 6
d702 25
d730 1
a730 1
Layout::attach_to_segment(Output_section* os, elfcpp::Elf_Xword flags)
d732 1
a831 52
// We have to move an existing output section from the unallocated
// list to the allocated list.

void
Layout::allocate_output_section(Output_section* os, elfcpp::Elf_Xword flags)
{
  os->reset_address_and_file_offset();

  Section_list::iterator p = std::find(this->unattached_section_list_.begin(),
                                       this->unattached_section_list_.end(),
                                       os);
  gold_assert(p != this->unattached_section_list_.end());
  this->unattached_section_list_.erase(p);

  this->attach_to_segment(os, flags);
}

// We have to move an existing output section from the read-only
// segment to the writable segment.

void
Layout::write_enable_output_section(Output_section* os,
                                    elfcpp::Elf_Xword flags)
{
  gold_assert((os->flags() & elfcpp::SHF_WRITE) == 0);
  gold_assert(os->type() == elfcpp::SHT_PROGBITS);
  gold_assert((flags & elfcpp::SHF_WRITE) != 0);
  gold_assert((flags & elfcpp::SHF_ALLOC) != 0);

  if (parameters->options().relocatable())
    return;

  if (this->script_options_->saw_sections_clause())
    return;

  Segment_list::iterator p;
  for (p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
    {
      if ((*p)->type() == elfcpp::PT_LOAD
          && ((*p)->flags() & elfcpp::PF_W) == 0)
        {
          (*p)->remove_output_section(os);
          break;
        }
    }
  gold_assert(p != this->segment_list_.end());

  this->attach_to_segment(os, flags);
}

@


1.96
log
@	* layout.cc (Layout::layout): If we see an input section with a
	name that needs sorting, set the must_sort flag for the output
	section.
	(Layout::make_output_section): If the name of the output section
	indicates that it might	require sorting, set the may_sort flag.
	* output.h (Output_section::may_sort_attached_input_sections): New
	function.
	(Output_section::set_may_sort_attached_input_sections): New
	function.
	(Output_section::must_sort_attached_input_sections): New
	function.
	(Output_section::set_must_sort_attached_input_sections): New
	function.
	(class Output_section): Declare Input_section_sort_entry.  Define
	Input_section_sort_compare.  Declare
	sort_attached_input_sections.  Add new fields:
	may_sort_attached_input_sections_,
	must_sort_attached_input_sections_,
	attached_input_sections_are_sorted_.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_section::add_input_section): Add an entry to
	input_sections_ if may_sort or must_sort are true.
	(Output_section::set_final_data_size): Call
	sort_attached_input_sections if necessary.
	(Output_section::Input_section_sort_entry): Define new class.
	(Output_section::Input_section_sort_compare::operator()): New
	function.
	(Output_section::sort_attached_input_sections): New function.
	* configure.ac: Check whether the compiler supports constructor
	priorities.  Define a CONSTRUCTOR_PRIORITY automake conditional.
	* testsuite/initpri1.c: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add initpri1 if
	CONSTRUCTOR_PRIORITY.
	(initpri1_SOURCES, initpri1_DEPENDENCIES): New variables.
	(initpri1_LDFLAGS): New variable.
	* configure, Makefile.in, testsuite/Makefile.in: Rebuild.
@
text
@d85 2
a86 1
    eh_frame_section_(NULL), eh_frame_data_(NULL), eh_frame_hdr_section_(NULL),
a566 1
      os->add_output_section_data(this->eh_frame_data_);
d608 13
a620 1
    *off = -1;
@


1.95
log
@	* options.h (class General_options): Define build_id option.
	* layout.h (class Layout): Declare write_build_id, create_note,
	create_build_id.  Add build_id_note_ member.
	* layout.cc: Include <cerrno>, <fcntl.h>, <unistd.h>,
	"libiberty.h", "md5.h", "sha1.h".
	(Layout::Layout): Initialize eh_frame_data_,
	eh_frame_hdr_section_, and build_id_note_.
	(Layout::finalize): Call create_build_id.
	(Layout::create_note): New function, broken out of
	Layout::create_gold_note.
	(Layout::create_gold_note): Call create_note.
	(Layout::create_build_id): New function.
	(Layout::write_build_id): New function.
	(Close_task_runner::run): Call write_build_id.
@
text
@d407 11
d685 10
@


1.94
log
@Make sure the start and size of the TLS segment are aligned.
@
text
@d25 1
d30 5
d85 2
a86 1
    eh_frame_section_(NULL), group_signatures_(), output_file_size_(-1),
d1045 1
d1192 5
a1196 2
// Create a .note section for an executable or shared library.  This
// records the version of gold used to create the binary.
d1198 3
a1200 2
void
Layout::create_gold_note()
a1201 3
  if (parameters->options().relocatable())
    return;

a1219 2
  const char* name = "GNU";
  std::string desc(std::string("gold ") + gold::get_version_string());
a1221 1
  size_t descsz = desc.length() + 1;
a1222 1
  const int note_type = 4;
d1224 1
a1224 1
  size_t notesz = 3 * (size / 8) + aligned_namesz + aligned_descsz;
d1226 2
a1227 3
  unsigned char buffer[128];
  gold_assert(sizeof buffer >= notesz);
  memset(buffer, 0, notesz);
a1264 1
  memcpy(buffer + 3 * (size / 8) + aligned_namesz, desc.data(), descsz);
d1267 3
d1272 26
a1297 3
						 0);
  Output_section_data* posd = new Output_data_const(buffer, notesz,
						    size / 8);
d1299 6
d1356 98
d2812 40
d3032 3
@


1.93
log
@Combine read-only .eh_frame sections with read-write .eh_frame
sections.
@
text
@d1538 2
a1539 2
	  uint64_t new_addr = (*p)->set_section_addresses(false, addr, &off,
							  pshndx);
d1564 2
a1565 2
		  new_addr = (*p)->set_section_addresses(true, addr, &off,
							 pshndx);
@


1.92
log
@If we a section with no flags followed by a section with the same name
with flags, put them in the same output section.
@
text
@d523 1
a523 1
  gold_assert(shdr.get_sh_flags() == elfcpp::SHF_ALLOC);
d534 10
d787 35
@


1.91
log
@Support --hash-style=gnu.
@
text
@d239 5
a243 6
      // combination.  If the section has contents but no flags, then
      // see whether we have an existing section with the same name.
      // This is a workaround for cases where assembler code forgets
      // to set section flags, and the GNU linker would simply pick an
      // existing section with the same name.  FIXME: Perhaps there
      // should be an option to control this.
d245 2
a246 1
      if (type == elfcpp::SHT_PROGBITS && flags == 0)
d248 21
a268 3
	  os = this->find_output_section(name);
	  if (os != NULL && os->type() != elfcpp::SHT_PROGBITS)
	    os = NULL;
d270 1
d319 11
a329 1
	    return *output_section_slot;
d655 6
a660 3
    {
      if (parameters->options().relocatable())
	return os;
d662 4
a665 4
      // If we have a SECTIONS clause, we can't handle the attachment
      // to segments until after we've seen all the sections.
      if (this->script_options_->saw_sections_clause())
	return os;
d667 2
a668 1
      gold_assert(!this->script_options_->saw_phdrs_clause());
d670 4
a673 1
      // This output section goes into a PT_LOAD segment.
d675 1
a675 1
      elfcpp::Elf_Word seg_flags = Layout::section_flags_to_segment(flags);
d677 1
a677 4
      // In general the only thing we really care about for PT_LOAD
      // segments is whether or not they are writable, so that is how
      // we search for them.  People who need segments sorted on some
      // other basis will have to use a linker script.
d679 1
a679 16
      Segment_list::const_iterator p;
      for (p = this->segment_list_.begin();
	   p != this->segment_list_.end();
	   ++p)
	{
	  if ((*p)->type() == elfcpp::PT_LOAD
	      && ((*p)->flags() & elfcpp::PF_W) == (seg_flags & elfcpp::PF_W))
	    {
	      // If -Tbss was specified, we need to separate the data
	      // and BSS segments.
	      if (this->options_.user_set_Tbss())
		{
		  if ((type == elfcpp::SHT_NOBITS)
		      == (*p)->has_any_data_sections())
		    continue;
		}
d681 4
a684 4
	      (*p)->add_output_section(os, seg_flags);
	      break;
	    }
	}
d686 21
a706 6
      if (p == this->segment_list_.end())
	{
	  Output_segment* oseg = this->make_output_segment(elfcpp::PT_LOAD,
							   seg_flags);
	  oseg->add_output_section(os, seg_flags);
	}
d708 6
a713 17
      // If we see a loadable SHT_NOTE section, we create a PT_NOTE
      // segment.
      if (type == elfcpp::SHT_NOTE)
	{
	  // See if we already have an equivalent PT_NOTE segment.
	  for (p = this->segment_list_.begin();
	       p != segment_list_.end();
	       ++p)
	    {
	      if ((*p)->type() == elfcpp::PT_NOTE
		  && (((*p)->flags() & elfcpp::PF_W)
		      == (seg_flags & elfcpp::PF_W)))
		{
		  (*p)->add_output_section(os, seg_flags);
		  break;
		}
	    }
d715 17
a731 7
	  if (p == this->segment_list_.end())
	    {
	      Output_segment* oseg = this->make_output_segment(elfcpp::PT_NOTE,
							       seg_flags);
	      oseg->add_output_section(os, seg_flags);
	    }
	}
d733 6
a738 9
      // If we see a loadable SHF_TLS section, we create a PT_TLS
      // segment.  There can only be one such segment.
      if ((flags & elfcpp::SHF_TLS) != 0)
	{
	  if (this->tls_segment_ == NULL)
	    this->tls_segment_ = this->make_output_segment(elfcpp::PT_TLS,
							   seg_flags);
	  this->tls_segment_->add_output_section(os, seg_flags);
	}
d741 9
a749 1
  return os;
d762 17
@


1.90
log
@From Craig Silverstein: rework option handling to make it easier to
add a new option.
@
text
@d1927 7
a1933 1
  // FIXME: We need an option to create a GNU hash table.
d1935 4
a1938 14
  unsigned char* phash;
  unsigned int hashlen;
  Dynobj::create_elf_hash_table(*pdynamic_symbols, local_symcount,
				&phash, &hashlen);

  Output_section* hashsec = this->choose_output_section(NULL, ".hash",
							elfcpp::SHT_HASH,
							elfcpp::SHF_ALLOC,
							false);

  Output_section_data* hashdata = new Output_data_const_buffer(phash,
							       hashlen,
							       align);
  hashsec->add_output_section_data(hashdata);
d1940 4
a1943 2
  hashsec->set_link_section(dynsym);
  hashsec->set_entsize(4);
d1945 29
a1973 1
  odyn->add_section_address(elfcpp::DT_HASH, hashsec);
@


1.89
log
@From Craig Silverstein: rename some option functions in preparation
for reworking option handling.
@
text
@d615 1
a615 1
      && this->options_.compress_debug_sections()
@


1.88
log
@Remove gcc 3.2 compatibility hacks.
@
text
@d61 1
a61 1
  if (this->options_.oformat() != General_options::OBJECT_FORMAT_ELF)
d990 1
a990 1
  if (this->options_.oformat() != General_options::OBJECT_FORMAT_ELF)
d2564 1
a2564 1
  gold_assert(this->options_.oformat()
d2735 1
a2735 1
  if (this->options_->oformat() != General_options::OBJECT_FORMAT_ELF)
@


1.87
log
@Don't check assertions until symbols are finalized.  Create an output
section if the script uses a data statement with no input sections.
Don't create a loadable segment for the headers if there is no room.
@
text
@d1988 3
a1990 4
      this->sized_create_version_sections
          SELECT_SIZE_ENDIAN_NAME(32, false)(
              versions, symtab, local_symcount, dynamic_symbols, dynstr
              SELECT_SIZE_ENDIAN(32, false));
d1995 3
a1997 4
      this->sized_create_version_sections
          SELECT_SIZE_ENDIAN_NAME(32, true)(
              versions, symtab, local_symcount, dynamic_symbols, dynstr
              SELECT_SIZE_ENDIAN(32, true));
d2002 3
a2004 4
      this->sized_create_version_sections
          SELECT_SIZE_ENDIAN_NAME(64, false)(
              versions, symtab, local_symcount, dynamic_symbols, dynstr
              SELECT_SIZE_ENDIAN(64, false));
d2009 3
a2011 4
      this->sized_create_version_sections
          SELECT_SIZE_ENDIAN_NAME(64, true)(
              versions, symtab, local_symcount, dynamic_symbols, dynstr
              SELECT_SIZE_ENDIAN(64, true));
d2028 1
a2028 2
    const Output_section* dynstr
    ACCEPT_SIZE_ENDIAN)
d2037 4
a2040 3
  versions->symbol_section_contents SELECT_SIZE_ENDIAN_NAME(size, big_endian)(
      symtab, &this->dynpool_, local_symcount, dynamic_symbols, &vbuf, &vsize
      SELECT_SIZE_ENDIAN(size, big_endian));
d2062 2
a2063 3
      versions->def_section_contents SELECT_SIZE_ENDIAN_NAME(size, big_endian)(
          &this->dynpool_, &vdbuf, &vdsize, &vdentries
          SELECT_SIZE_ENDIAN(size, big_endian));
d2088 3
a2090 3
      versions->need_section_contents SELECT_SIZE_ENDIAN_NAME(size, big_endian)
        (&this->dynpool_, &vnbuf, &vnsize, &vnentries
         SELECT_SIZE_ENDIAN(size, big_endian));
@


1.86
log
@Put input sections with no flags in output sections with the same name.
@
text
@d715 12
@


1.85
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d239 15
a253 2
      // combination.
      Output_section* os = this->make_output_section(name, type, flags);
@


1.84
log
@Implement -q/--emit-relocs.
@
text
@d55 1
d60 1
a60 1
  Output_file* of = new Output_file(parameters->output_file_name());
d161 2
a162 2
      gold_assert(!parameters->output_is_object()
		  && !parameters->emit_relocs());
d166 1
a166 1
      if (parameters->strip_debug()
d176 1
a176 1
      if (parameters->strip_debug_gdb()
d309 1
a309 1
  if (adjust_name && !parameters->output_is_object())
d343 1
a343 1
  if (parameters->output_is_object()
d376 2
a377 1
  gold_assert(parameters->output_is_object() || parameters->emit_relocs());
d434 1
a434 1
  gold_assert(parameters->output_is_object());
d614 1
a614 1
      if (parameters->output_is_object())
d906 1
a906 1
		 const Task* task)
a907 2
  Target* const target = parameters->target();

d916 1
a916 1
  if (!parameters->output_is_object() && !parameters->doing_static_link())
d938 1
a938 1
      if (!parameters->output_is_shared())
d960 1
a960 1
  else if (parameters->output_is_object())
d972 1
a972 1
  if (parameters->output_is_object())
d995 1
a995 1
      && !parameters->output_is_object())
d1010 1
a1010 1
  if (!parameters->output_is_object())
d1066 1
a1066 1
  if (parameters->output_is_object())
d1081 1
a1081 1
  const int size = parameters->get_size();
d1101 1
a1101 1
  bool is_big_endian = parameters->is_big_endian();
d1178 1
a1178 1
  if (parameters->output_is_object())
d1317 1
a1317 1
  else if (parameters->output_is_shared())
d1563 1
a1563 1
  const bool output_is_object = parameters->output_is_object();
d1649 1
a1649 1
  if (parameters->get_size() == 32)
d1654 1
a1654 1
  else if (parameters->get_size() == 64)
d1721 1
a1721 1
  if (!parameters->strip_all())
d1847 1
a1847 1
  const int size = parameters->get_size();
d1959 1
a1959 1
  if (parameters->get_size() == 32)
d1961 8
a1968 2
      if (parameters->is_big_endian())
        {
d1970 6
a1975 6
          this->sized_create_version_sections
              SELECT_SIZE_ENDIAN_NAME(32, true)(
		  versions, symtab, local_symcount, dynamic_symbols, dynstr
                  SELECT_SIZE_ENDIAN(32, true));
#else
          gold_unreachable();
d1977 7
a1983 10
        }
      else
        {
#ifdef HAVE_TARGET_32_LITTLE
          this->sized_create_version_sections
              SELECT_SIZE_ENDIAN_NAME(32, false)(
		  versions, symtab, local_symcount, dynamic_symbols, dynstr
                  SELECT_SIZE_ENDIAN(32, false));
#else
          gold_unreachable();
a1984 6
        }
    }
  else if (parameters->get_size() == 64)
    {
      if (parameters->is_big_endian())
        {
d1986 6
a1991 6
          this->sized_create_version_sections
              SELECT_SIZE_ENDIAN_NAME(64, true)(
                  versions, symtab, local_symcount, dynamic_symbols, dynstr
                  SELECT_SIZE_ENDIAN(64, true));
#else
          gold_unreachable();
d1993 2
a1994 12
        }
      else
        {
#ifdef HAVE_TARGET_64_LITTLE
          this->sized_create_version_sections
              SELECT_SIZE_ENDIAN_NAME(64, false)(
                  versions, symtab, local_symcount, dynamic_symbols, dynstr
                  SELECT_SIZE_ENDIAN(64, false));
#else
          gold_unreachable();
#endif
        }
a1995 2
  else
    gold_unreachable();
d2140 1
a2140 1
  if (parameters->output_is_shared())
d2232 1
a2232 1
  if (parameters->output_is_shared() && this->has_static_tls())
d2427 1
a2427 1
  gold_assert(!parameters->output_is_object());
d2454 1
a2454 1
  if (!parameters->strip_all())
d2561 1
a2561 1
  Output_file out(parameters->output_file_name());
@


1.83
log
@From Craig Silverstein: rework handling of Script_options.
@
text
@d158 4
a161 2
      // For a relocatable link these should be handled elsewhere.
      gold_assert(!parameters->output_is_object());
d375 1
a375 1
  gold_assert(parameters->output_is_object());
@


1.82
log
@From Craig Silverstein: rename option functions for future option
handling rewrite.
@
text
@d928 2
a929 1
      Versions versions(this->options_, &this->dynpool_);
d984 1
a984 1
				       this->script_options_->entry());
@


1.81
log
@Implement -Tdata and -Tbss.
@
text
@d60 1
a60 1
  if (this->options_.output_format() != General_options::OBJECT_FORMAT_ELF)
d494 1
a494 1
      if (this->options_.create_eh_frame_hdr())
d639 1
a639 1
	      if (this->options_.user_set_bss_segment_address())
d962 1
a962 1
  if (this->options_.output_format() != General_options::OBJECT_FORMAT_ELF)
d1312 2
a1313 2
  if (this->options_.user_set_text_segment_address())
    addr = this->options_.text_segment_address();
d1353 1
a1353 1
	  else if (this->options_.user_set_data_segment_address()
d1355 1
a1355 1
		   && (!this->options_.user_set_bss_segment_address()
d1358 1
a1358 1
	      addr = this->options_.data_segment_address();
d1361 1
a1361 1
	  else if (this->options_.user_set_bss_segment_address()
d1365 1
a1365 1
	      addr = this->options_.bss_segment_address();
d2556 1
a2556 1
  gold_assert(this->options_.output_format()
d2727 1
a2727 1
  if (this->options_->output_format() != General_options::OBJECT_FORMAT_ELF)
@


1.80
log
@Set TEXTREL correctly when using a SECTIONS clause.
@
text
@d624 4
a627 5
      // The only thing we really care about for PT_LOAD segments is
      // whether or not they are writable, so that is how we search
      // for them.  People who need segments sorted on some other
      // basis will have to wait until we implement a mechanism for
      // them to describe the segments they want.
d637 9
d1275 7
a1281 6
  // come before writable segments.  Then executable segments come
  // before non-executable segments.  Then the unlikely case of a
  // non-readable segment comes before the normal case of a readable
  // segment.  If there are multiple segments with the same type and
  // flags, we require that the address be set, and we sort by
  // virtual address and then physical address.
d1284 3
d1313 1
a1313 1
    addr = options_.text_segment_address();
d1346 23
a1377 1
	  bool are_addresses_set = (*p)->are_addresses_set();
a1379 4
	      // When it comes to setting file offsets, we care about
	      // the physical address.
	      addr = (*p)->paddr();

@


1.79
log
@Add support for --format binary for input files.
@
text
@d2171 1
a2171 3
  for (Segment_list::const_iterator p = this->segment_list_.begin();
       p != this->segment_list_.end();
       ++p)
d2173 30
a2202 6
      if (((*p)->flags() & elfcpp::PF_W) == 0
	  && (*p)->dynamic_reloc_count() > 0)
	{
	  have_textrel = true;
	  break;
	}
@


1.78
log
@Support --oformat binary.
@
text
@d60 1
a60 1
  if (this->options_.output_format() != General_options::OUTPUT_FORMAT_ELF)
d954 1
a954 1
  if (this->options_.output_format() != General_options::OUTPUT_FORMAT_ELF)
d2505 1
a2505 1
	      == General_options::OUTPUT_FORMAT_BINARY);
d2675 1
a2675 1
  if (this->options_->output_format() != General_options::OUTPUT_FORMAT_ELF)
@


1.77
log
@Implement --just-symbols, including -R FILE.  Fix symbol values when
doing a relocatable link.
@
text
@d60 2
d954 3
d2494 49
d2674 4
@


1.76
log
@Support creating empty output when there are no input objects.
@
text
@d945 3
a947 1
  if (parameters->output_is_object())
a948 2
  else if (this->script_options_->saw_sections_clause())
    load_seg = this->set_section_addresses_from_script(symtab);
@


1.75
log
@Fix group signature handling for relocatable link, add bootstrap
relocatable test.
@
text
@d894 1
a894 1
  Target* const target = input_objects->target();
@


1.74
log
@Initial -r support.
@
text
@d76 1
a76 1
    eh_frame_section_(NULL), output_file_size_(-1),
d436 1
a436 1
  // This is a hack to force that to happen.
d438 9
a446 5
  if (sym == NULL)
    sym = symtab->define_as_constant(signature, NULL, 0, 0,
				     elfcpp::STT_NOTYPE,
				     elfcpp::STB_WEAK,
				     elfcpp::STV_HIDDEN, 0, false);
a448 1
  os->set_info_symndx(sym);
d802 31
@


1.73
log
@Implement PHDRS.
@
text
@d39 1
a141 2
  // Some section types are never linked.  Some are only linked when
  // doing a relocateable link.
d156 3
a158 1
      return parameters->output_is_object();
d334 18
a351 7
  Output_section* os = this->choose_output_section(object,
						   name,
						   shdr.get_sh_type(),
						   shdr.get_sh_flags(),
						   true);
  if (os == NULL)
    return NULL;
d361 94
d605 3
d911 3
a913 1
  if (this->script_options_->saw_sections_clause())
d922 10
a931 5
  segment_headers = new Output_segment_headers(this->segment_list_);
  if (load_seg != NULL)
    load_seg->add_initial_output_data(segment_headers);
  if (phdr_seg != NULL)
    phdr_seg->add_initial_output_data(segment_headers);
d941 2
a942 1
  this->special_output_list_.push_back(segment_headers);
d944 2
a945 1
  if (this->script_options_->saw_phdrs_clause())
d959 5
a963 1
  off_t off = this->set_segment_offsets(target, load_seg, &shndx);
d1397 39
d1491 1
d1496 5
d1715 1
d2348 1
d2626 88
@


1.72
log
@Implement SIZEOF_HEADERS, section constraints, other minor linker
script items.
@
text
@d400 7
a406 4
	      Output_segment* hdr_oseg;
	      hdr_oseg = this->make_output_segment(elfcpp::PT_GNU_EH_FRAME,
						   elfcpp::PF_R);
	      hdr_oseg->add_output_section(hdr_os, elfcpp::PF_R);
d504 2
d708 2
d768 2
a769 1
      phdr_seg = this->make_output_segment(elfcpp::PT_PHDR, elfcpp::PF_R);
d827 8
d1016 2
d1882 6
a1887 3
  Output_segment* oseg = this->make_output_segment(elfcpp::PT_INTERP,
						   elfcpp::PF_R);
  oseg->add_initial_output_section(osec, elfcpp::PF_R);
d1896 8
a1903 5
  Output_segment* oseg = this->make_output_segment(elfcpp::PT_DYNAMIC,
						   (elfcpp::PF_R
						    | elfcpp::PF_W));
  oseg->add_initial_output_section(this->dynamic_section_,
				   elfcpp::PF_R | elfcpp::PF_W);
@


1.71
log
@Fully implement the SECTIONS clause.
@
text
@d400 3
a402 3
	      Output_segment* hdr_oseg =
		new Output_segment(elfcpp::PT_GNU_EH_FRAME, elfcpp::PF_R);
	      this->segment_list_.push_back(hdr_oseg);
d526 2
a527 3
	  Output_segment* oseg = new Output_segment(elfcpp::PT_LOAD,
						    seg_flags);
	  this->segment_list_.push_back(oseg);
d551 2
a552 3
	      Output_segment* oseg = new Output_segment(elfcpp::PT_NOTE,
							seg_flags);
	      this->segment_list_.push_back(oseg);
d562 2
a563 5
	    {
	      this->tls_segment_ = new Output_segment(elfcpp::PT_TLS,
						      seg_flags);
	      this->segment_list_.push_back(this->tls_segment_);
	    }
d571 21
d622 5
a626 5
  const char* dynamic_name = this->namepool_.add(".dynamic", false, NULL);
  this->dynamic_section_ = this->make_output_section(dynamic_name,
						     elfcpp::SHT_DYNAMIC,
						     (elfcpp::SHF_ALLOC
						      | elfcpp::SHF_WRITE));
d703 2
a704 2
  Output_segment* load_seg = new Output_segment(elfcpp::PT_LOAD, elfcpp::PF_R);
  this->segment_list_.push_back(load_seg);
d753 1
d759 4
d799 1
a799 10
  Output_segment* phdr_seg = NULL;
  if (load_seg != NULL
      && !parameters->output_is_object()
      && !parameters->doing_static_link())
    {
      // Create the PT_PHDR segment which will hold the program
      // headers.
      phdr_seg = new Output_segment(elfcpp::PT_PHDR, elfcpp::PF_R);
      this->segment_list_.push_back(phdr_seg);
    }
d1003 1
a1003 2
      Output_segment* oseg = new Output_segment(elfcpp::PT_GNU_STACK, flags);
      this->segment_list_.push_back(oseg);
d1605 4
a1608 4
  const char* dynsym_name = this->namepool_.add(".dynsym", false, NULL);
  Output_section* dynsym = this->make_output_section(dynsym_name,
						     elfcpp::SHT_DYNSYM,
						     elfcpp::SHF_ALLOC);
d1626 4
a1629 4
  const char* dynstr_name = this->namepool_.add(".dynstr", false, NULL);
  Output_section* dynstr = this->make_output_section(dynstr_name,
						     elfcpp::SHT_STRTAB,
						     elfcpp::SHF_ALLOC);
d1651 4
a1654 4
  const char* hash_name = this->namepool_.add(".hash", false, NULL);
  Output_section* hashsec = this->make_output_section(hash_name,
						      elfcpp::SHT_HASH,
						      elfcpp::SHF_ALLOC);
d1767 4
a1770 4
  const char* vname = this->namepool_.add(".gnu.version", false, NULL);
  Output_section* vsec = this->make_output_section(vname,
						   elfcpp::SHT_GNU_versym,
						   elfcpp::SHF_ALLOC);
d1789 5
a1793 4
      const char* vdname = this->namepool_.add(".gnu.version_d", false, NULL);
      Output_section *vdsec;
      vdsec = this->make_output_section(vdname, elfcpp::SHT_GNU_verdef,
					elfcpp::SHF_ALLOC);
a1815 1
      const char* vnname = this->namepool_.add(".gnu.version_r", false, NULL);
d1817 4
a1820 2
      vnsec = this->make_output_section(vnname, elfcpp::SHT_GNU_verneed,
					elfcpp::SHF_ALLOC);
d1858 4
a1861 4
  const char* interp_name = this->namepool_.add(".interp", false, NULL);
  Output_section* osec = this->make_output_section(interp_name,
						   elfcpp::SHT_PROGBITS,
						   elfcpp::SHF_ALLOC);
d1864 2
a1865 2
  Output_segment* oseg = new Output_segment(elfcpp::PT_INTERP, elfcpp::PF_R);
  this->segment_list_.push_back(oseg);
d1875 3
a1877 3
  Output_segment* oseg = new Output_segment(elfcpp::PT_DYNAMIC,
					    elfcpp::PF_R | elfcpp::PF_W);
  this->segment_list_.push_back(oseg);
@


1.70
log
@Don't pass around the target in order to define symbols; get it from
the parameters instead.
@
text
@d32 2
d190 2
a191 2
  for (Section_name_map::const_iterator p = this->section_name_map_.begin();
       p != this->section_name_map_.end();
d193 2
a194 2
    if (strcmp(p->second->name(), name) == 0)
      return p->second;
d216 2
a217 1
// and section flags FLAGS.
a222 7
  // We should ignore some flags.
  flags &= ~ (elfcpp::SHF_INFO_LINK
	      | elfcpp::SHF_LINK_ORDER
	      | elfcpp::SHF_GROUP
	      | elfcpp::SHF_MERGE
	      | elfcpp::SHF_STRINGS);

d240 74
d333 7
a339 17
  // If we are not doing a relocateable link, choose the name to use
  // for the output section.
  size_t len = strlen(name);
  if (!parameters->output_is_object())
    name = Layout::output_section_name(name, &len);

  // FIXME: Handle SHF_OS_NONCONFORMING here.

  // Canonicalize the section name.
  Stringpool::Key name_key;
  name = this->namepool_.add_with_length(name, len, true, &name_key);

  // Find the output section.  The output section is selected based on
  // the section name, type, and flags.
  Output_section* os = this->get_output_section(name, name_key,
						shdr.get_sh_type(),
						shdr.get_sh_flags());
d343 2
a344 1
  *off = os->add_input_section(object, shndx, name, shdr, reloc_shndx);
d368 8
a375 6
  Stringpool::Key name_key;
  const char* name = this->namepool_.add(".eh_frame", false, &name_key);

  Output_section* os = this->get_output_section(name, name_key,
						elfcpp::SHT_PROGBITS,
						elfcpp::SHF_ALLOC);
a384 4
	  Stringpool::Key hdr_name_key;
	  const char* hdr_name = this->namepool_.add(".eh_frame_hdr",
                                                     false,
						     &hdr_name_key);
d386 5
a390 3
	    this->get_output_section(hdr_name, hdr_name_key,
				     elfcpp::SHT_PROGBITS,
				     elfcpp::SHF_ALLOC);
d392 12
a403 2
	  Eh_frame_hdr* hdr_posd = new Eh_frame_hdr(os, this->eh_frame_data_);
	  hdr_os->add_output_section_data(hdr_posd);
d405 2
a406 8
	  hdr_os->set_after_input_sections();

	  Output_segment* hdr_oseg =
	    new Output_segment(elfcpp::PT_GNU_EH_FRAME, elfcpp::PF_R);
	  this->segment_list_.push_back(hdr_oseg);
	  hdr_oseg->add_output_section(hdr_os, elfcpp::PF_R);

	  this->eh_frame_data_->set_eh_frame_hdr(hdr_posd);
d425 3
a427 1
      *off = os->add_input_section(object, shndx, name, shdr, reloc_shndx);
d440 4
a443 6
  // Canonicalize the name.
  Stringpool::Key name_key;
  name = this->namepool_.add(name, true, &name_key);

  Output_section* os = this->get_output_section(name, name_key, type, flags);
  os->add_output_section_data(posd);
d496 5
d654 1
a654 1
					false); // only_if_ref
d666 1
a666 1
					false); // only_if_ref
d737 1
a737 2
  Output_segment* phdr_seg = NULL;
  if (!parameters->doing_static_link())
a741 5
      // Create the PT_PHDR segment which will hold the program
      // headers.
      phdr_seg = new Output_segment(elfcpp::PT_PHDR, elfcpp::PF_R);
      this->segment_list_.push_back(phdr_seg);

d770 7
a776 1
  // FIXME: Handle PT_GNU_STACK.
d778 10
a787 1
  Output_segment* load_seg = this->find_first_load_seg();
d792 2
a793 2
  load_seg->add_initial_output_data(segment_headers);
  this->special_output_list_.push_back(segment_headers);
d801 3
a803 1
  load_seg->add_initial_output_data(file_header);
d805 1
d1055 21
d1090 3
a1092 9
  uint64_t vaddr1 = seg1->vaddr();
  uint64_t vaddr2 = seg2->vaddr();
  if (vaddr1 != vaddr2)
    return vaddr1 < vaddr2;

  uint64_t paddr1 = seg1->paddr();
  uint64_t paddr2 = seg2->paddr();
  gold_assert(paddr1 != paddr2);
  return paddr1 < paddr2;
d1110 3
a1112 1
  if (parameters->output_is_shared())
a1113 2
  else if (options_.user_set_text_segment_address())
    addr = options_.text_segment_address();
d1117 16
a1143 6
	  // If the last segment was readonly, and this one is not,
	  // then skip the address forward one page, maintaining the
	  // same position within the page.  This lets us store both
	  // segments overlapping on a single page in the file, but
	  // the loader will put them on different pages in memory.

d1147 1
a1147 1
	  uint64_t aligned_addr = addr;
d1150 2
a1151 2
          // FIXME: This should depend on the -n and -N options.
          (*p)->set_minimum_addralign(target->common_pagesize());
d1153 17
a1169 1
	  if (was_readonly && ((*p)->flags() & elfcpp::PF_W) != 0)
d1171 6
a1176 1
	      uint64_t align = (*p)->addralign();
d1178 1
a1178 1
	      addr = align_address(addr, align);
d1180 8
a1187 2
	      if ((addr & (abi_pagesize - 1)) != 0)
		addr = addr + abi_pagesize;
d1191 2
a1192 2
	  off = orig_off + ((addr - orig_addr) & (abi_pagesize - 1));
	  uint64_t new_addr = (*p)->set_section_addresses(addr, &off, pshndx);
d1200 1
a1200 1
	  if (aligned_addr != addr)
d1215 1
d1217 2
a1218 1
		  new_addr = (*p)->set_section_addresses(addr, &off, pshndx);
d1311 24
d2124 22
@


1.69
log
@Originally from Craig Silverstein, with changes: support using a
version script to force symbols to be local.
@
text
@d531 1
a531 2
Layout::create_initial_dynamic_sections(const Input_objects* input_objects,
					Symbol_table* symtab)
d542 1
a542 2
  symtab->define_in_output_data(input_objects->target(), "_DYNAMIC", NULL,
				this->dynamic_section_, 0, 0,
d556 1
a556 1
Layout::define_section_symbols(Symbol_table* symtab, const Target* target)
d574 1
a574 2
	  symtab->define_in_output_data(target,
					start_name.c_str(),
d586 1
a586 2
	  symtab->define_in_output_data(target,
					stop_name.c_str(),
d683 1
a683 1
      this->create_dynamic_symtab(input_objects, target, symtab, &dynstr,
d1372 1
a1372 1
                              const Target* target, Symbol_table* symtab,
d1413 1
a1413 1
  index = symtab->set_dynsym_indexes(target, index, pdynamic_symbols,
@


1.68
log
@Don't include options.h in fileread.h.  Remove General_options
reference from Output_file class.
@
text
@d1294 2
a1295 2
  off = symtab->finalize(local_symcount, off, dynoff, dyn_global_index,
			 dyncount, &this->sympool_);
@


1.67
log
@From Andrew Chatham and Craig Silverstein: Add support for version
scripts.
@
text
@d31 1
d56 1
a56 2
  Output_file* of = new Output_file(this->options_,
                                    this->input_objects_->target());
@


1.66
log
@Support assignments and expressions in linker scripts.
@
text
@d686 1
a686 1
      Versions versions;
@


1.65
log
@Add support for -e and for ENTRY in linker scripts.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
d66 3
a68 3
Layout::Layout(const General_options& options)
  : options_(options), entry_(options.entry()), namepool_(), sympool_(),
    dynpool_(), signatures_(),
d725 1
a725 1
				       this->entry_);
d747 4
@


1.64
log
@Add -h/-soname option.
@
text
@d67 2
a68 1
  : options_(options), namepool_(), sympool_(), dynpool_(), signatures_(),
d724 2
a725 1
  file_header = new Output_file_header(target, symtab, segment_headers);
@


1.63
log
@Reduce the number of system calls.  Use readv instead of pread.  Do
better handling of cached views.
@
text
@d1716 7
@


1.62
log
@Speed up relocations against local symbols in merged sections.
@
text
@d742 1
a742 1
  this->create_symtab_sections(input_objects, symtab, task, &off);
a1214 1
			       const Task* task,
d1288 1
a1288 1
  off = symtab->finalize(task, local_symcount, off, dynoff, dyn_global_index,
@


1.61
log
@Use string length when available when calling Stringpool.  Compare
pointers first when looking up Stringpool entries.
@
text
@d735 6
d749 2
a750 2
  // Set the file offsets of all the non-data sections which don't
  // have to wait for the input sections.
d1120 4
@


1.60
log
@Don't write unattached after_input sections twice.
@
text
@d272 1
a272 1
  name = this->namepool_.add_prefix(name, len, &name_key);
@


1.59
log
@Print statistics about merge sections with --stats.
@
text
@a2045 8
  for (Section_list::const_iterator p = this->unattached_section_list_.begin();
       p != this->unattached_section_list_.end();
       ++p)
    {
      if ((*p)->after_input_sections())
	(*p)->write(of);
    }

@


1.58
log
@Rewrite workqueue.  This version eliminates the master thread, and
reduces the amount of locking required to find a new thread to run.
@
text
@d2065 5
@


1.57
log
@From Craig Silverstein: size hash tables to avoid resizing.
@
text
@d47 1
a47 1
Layout_task_runner::run(Workqueue* workqueue)
d50 2
a51 1
					    this->symtab_);
d76 2
a77 1
    has_static_tls_(false)
d658 2
a659 1
Layout::finalize(const Input_objects* input_objects, Symbol_table* symtab)
d665 1
a665 1
  this->count_local_symbols(input_objects);
d736 1
a736 1
  this->create_symtab_sections(input_objects, symtab, &off);
d753 6
d1118 4
a1121 1
	(*p)->create_postprocessing_buffer();
d1126 1
a1126 1
      else if (pass == AFTER_INPUT_SECTIONS_PASS
d1130 1
a1130 1
      else if (pass == STRTAB_AFTER_INPUT_SECTIONS_PASS
d1141 1
a1141 1
      if (pass != STRTAB_AFTER_INPUT_SECTIONS_PASS)
d1167 2
a1168 1
Layout::count_local_symbols(const Input_objects* input_objects)
d1193 1
a1193 1
      Task_lock_obj<Object> tlo(**p);
d1205 1
d1279 1
a1279 1
  off = symtab->finalize(local_symcount, off, dynoff, dyn_global_index,
d2021 9
a2029 2
  off_t off = this->output_file_size_;
  off = this->set_section_offsets(off, AFTER_INPUT_SECTIONS_PASS);
d2031 5
a2035 7
  // Now that we've finalized the names, we can finalize the shstrab.
  off = this->set_section_offsets(off, STRTAB_AFTER_INPUT_SECTIONS_PASS);

  if (off > this->output_file_size_)
    {
      of->resize(off);
      this->output_file_size_ = off;
d2071 2
a2072 2
Task::Is_runnable_type
Write_sections_task::is_runnable(Workqueue*)
d2074 1
a2074 1
  return IS_RUNNABLE;
d2080 2
a2081 1
class Write_sections_task::Write_sections_locker : public Task_locker
d2083 2
a2084 19
 public:
  Write_sections_locker(Task_token& output_sections_blocker,
			Task_token& final_blocker,
			Workqueue* workqueue)
    : output_sections_block_(output_sections_blocker, workqueue),
      final_block_(final_blocker, workqueue)
  { }

 private:
  Task_block_token output_sections_block_;
  Task_block_token final_block_;
};

Task_locker*
Write_sections_task::locks(Workqueue* workqueue)
{
  return new Write_sections_locker(*this->output_sections_blocker_,
				   *this->final_blocker_,
				   workqueue);
d2099 2
a2100 2
Task::Is_runnable_type
Write_data_task::is_runnable(Workqueue*)
d2102 1
a2102 1
  return IS_RUNNABLE;
d2107 2
a2108 2
Task_locker*
Write_data_task::locks(Workqueue* workqueue)
d2110 1
a2110 1
  return new Task_locker_block(*this->final_blocker_, workqueue);
d2125 2
a2126 2
Task::Is_runnable_type
Write_symbols_task::is_runnable(Workqueue*)
d2128 1
a2128 1
  return IS_RUNNABLE;
d2133 2
a2134 2
Task_locker*
Write_symbols_task::locks(Workqueue* workqueue)
d2136 1
a2136 1
  return new Task_locker_block(*this->final_blocker_, workqueue);
d2152 2
a2153 2
Task::Is_runnable_type
Write_after_input_sections_task::is_runnable(Workqueue*)
d2156 2
a2157 2
    return IS_BLOCKED;
  return IS_RUNNABLE;
d2162 2
a2163 2
Task_locker*
Write_after_input_sections_task::locks(Workqueue* workqueue)
d2165 1
a2165 1
  return new Task_locker_block(*this->final_blocker_, workqueue);
d2181 1
a2181 1
Close_task_runner::run(Workqueue*)
@


1.56
log
@From Cary Coutant: Set DF_STATIC_TLS as appropriate.
@
text
@d1157 19
@


1.55
log
@From Cary Coutant: Fix x86_64 TLS.  Also set DT_TEXTREL as well as
DF_TEXTREL.
@
text
@d74 2
a75 1
    input_without_gnu_stack_note_(false)
d1737 2
@


1.54
log
@Fix ehframe header handling for shared libraries.
@
text
@d1731 5
a1735 1
    flags |= elfcpp::DF_TEXTREL;
@


1.53
log
@From Cary Coutant: More support for generating shared libraries.
@
text
@d995 3
a997 1
  if (options_.user_set_text_segment_address())
@


1.52
log
@Stringpool stats.  Also make Symbol_table support functions inline.
@
text
@d661 2
d682 1
a682 1
      this->create_dynamic_symtab(target, symtab, &dynstr,
d733 2
d1083 4
d1148 15
a1214 1
      Task_lock_obj<Object> tlo(**p);
d1216 1
a1216 2
							off,
							&this->sympool_);
d1324 2
a1325 1
Layout::create_dynamic_symtab(const Target* target, Symbol_table* symtab,
d1351 9
a1359 4
  // FIXME: Some targets apparently require local symbols in the
  // dynamic symbol table.  Here is where we will have to count them,
  // and set the dynamic symbol indexes, and add the names to
  // this->dynpool_.
d1447 22
@


1.51
log
@Compress all debug sections.
@
text
@d1961 10
@


1.50
log
@From Craig Silverstein: Add support for compressing .debug_str section.
@
text
@d35 1
d390 16
d413 8
a420 1
  Output_section* os = new Output_section(this->options_, name, type, flags);
d1097 4
d1116 4
a1123 13
// Allow any section not associated with a segment to change its
// output section name at the last minute.

void
Layout::modify_section_names()
{
  for (Section_list::iterator p = this->unattached_section_list_.begin();
       p != this->unattached_section_list_.end();
       ++p)
    if ((*p)->maybe_modify_output_section_name())
      this->namepool_.add((*p)->name(), true, NULL);
}

a1931 4

  // Determine the final section names as well (at least, for sections
  // that we haven't written yet).
  this->modify_section_names();
@


1.49
log
@Clean up setting address and section offset.
@
text
@d396 1
a396 1
  Output_section* os = new Output_section(name, type, flags);
d713 1
a713 1
  off = this->set_section_offsets(off, false);
d1062 1
a1062 1
Layout::set_section_offsets(off_t off, bool after_input_sections)
d1072 11
a1082 2
      if ((*p)->after_input_sections() != after_input_sections)
	continue;
d1092 13
d1908 3
a1910 1
  // file size.
d1912 9
a1920 1
  off = this->set_section_offsets(off, true);
@


1.48
log
@From Cary Coutant: Count textrel with output sections rather than
setting a flag as we add each reloc in the target code.
@
text
@d68 1
a68 1
    tls_segment_(NULL), symtab_section_(NULL),
d79 3
a81 3
  // We expect three unattached Output_data objects: the file header,
  // the segment headers, and the section headers.
  this->special_output_list_.reserve(3);
d698 1
a698 1
  // set_section_offsets.
a704 5
  // Set the file offsets of all the data sections not associated with
  // segments. This makes sure that debug sections have their offsets
  // before symbols are finalized.
  off = this->set_section_offsets(off, true);

d711 2
a712 2
  // Set the file offsets of all the non-data sections not associated with
  // segments.
d719 1
a719 1
  Output_section_headers* oshdrs = this->create_shdrs(&off);
d721 1
a721 1
  file_header->set_section_info(oshdrs, shstrtab_section);
d723 2
a724 1
  // Now we know exactly where everything goes in the output file.
d1062 1
a1062 2
Layout::set_section_offsets(off_t off,
                            bool do_bits_sections)
d1068 2
a1069 5
      bool is_bits_section = ((*p)->type() == elfcpp::SHT_PROGBITS
                              || (*p)->type() == elfcpp::SHT_NOBITS);
      if (is_bits_section != do_bits_sections)
        continue;
      if ((*p)->offset() != -1)
d1071 4
d1076 2
a1077 1
      (*p)->set_address(0, off);
d1194 2
a1195 2
      Output_section_data* pos = new Output_data_space(off - startoff,
						       align);
d1206 2
a1207 1
      osymtab->set_address(0, startoff);
d1228 1
a1228 1
  this->namepool_.set_string_offsets();
d1230 4
a1233 1
  Output_section* os = this->make_output_section(name, elfcpp::SHT_STRTAB, 0);
d1244 1
a1244 1
Output_section_headers*
d1253 1
a1253 1
  oshdrs->set_address(0, off);
d1256 1
a1256 2
  this->special_output_list_.push_back(oshdrs);
  return oshdrs;
d1324 2
a1325 2
  Output_section_data* odata = new Output_data_space(index * symsize,
						     align);
d1883 1
a1883 1
Layout::write_sections_after_input_sections(Output_file* of) const
d1885 10
d1902 10
@


1.47
log
@From Craig Silverstein: Add --strip-debug-gdb.
@
text
@d73 1
a73 2
    input_without_gnu_stack_note_(false),
    have_textrel_(false)
d1620 21
a1640 7
    
    // Add a DT_FLAGS entry. We add it even if no flags are set so that
    // post-link tools can easily modify these flags if desired.
    unsigned int flags = 0;
    if (this->have_textrel_)
      flags |= elfcpp::DF_TEXTREL;
    odyn->add_constant(elfcpp::DT_FLAGS, flags);
@


1.46
log
@From Cary Coutant: Improve i386 shared library TLS support.
@
text
@d101 27
d162 8
@


1.45
log
@Add heuristics for undefined symbol warnings.
@
text
@d73 2
a74 1
    input_without_gnu_stack_note_(false)
d1586 7
@


1.44
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d1931 2
a1932 2
  this->symtab_->write_globals(this->target_, this->sympool_, this->dynpool_,
			       this->of_);
@


1.43
log
@From Craig Silverstein and Cary Coutant: fix assignment of section
indexes to sections which are not associated with segments.
@
text
@d104 1
a104 1
Layout::include_section(Object*, const char* name,
d205 8
a212 2
// NAME, with header HEADER, from object OBJECT.  Set *OFF to the
// offset of this input section without the output section.
d216 3
a218 2
Layout::layout(Relobj* object, unsigned int shndx, const char* name,
	       const elfcpp::Shdr<size, big_endian>& shdr, off_t* off)
a240 11
  // Special GNU handling of sections named .eh_frame.
  if (!parameters->output_is_object()
      && strcmp(name, ".eh_frame") == 0
      && shdr.get_sh_size() > 0
      && shdr.get_sh_type() == elfcpp::SHT_PROGBITS
      && shdr.get_sh_flags() == elfcpp::SHF_ALLOC)
    {
      this->layout_eh_frame(object, shndx, name, shdr, os, off);
      return os;
    }

d243 1
a243 1
  *off = os->add_input_section(object, shndx, name, shdr);
d248 3
a250 2
// Special GNU handling of sections named .eh_frame.  They will
// normally hold exception frame data.
d253 6
a258 2
void
Layout::layout_eh_frame(Relobj* object,
a259 1
			const char* name,
d261 2
a262 1
			Output_section* os, off_t* off)
d264 10
d277 2
d291 1
a291 1
	  Eh_frame_hdr* hdr_posd = new Eh_frame_hdr(os);
d294 2
d300 2
d307 17
a323 1
  *off = os->add_input_section(object, shndx, name, shdr);
d1760 16
a1815 9
  // Write out the Output_sections.  Most won't have anything to
  // write, since most of the data will come from input sections which
  // are handled elsewhere.  But some Output_sections do have
  // Output_data.
  for (Section_list::const_iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
    (*p)->write(of);

d1823 59
d1935 28
d1979 4
a1982 2
Layout::layout<32, false>(Relobj* object, unsigned int shndx, const char* name,
			  const elfcpp::Shdr<32, false>& shdr, off_t*);
d1988 4
a1991 2
Layout::layout<32, true>(Relobj* object, unsigned int shndx, const char* name,
			 const elfcpp::Shdr<32, true>& shdr, off_t*);
d1997 4
a2000 2
Layout::layout<64, false>(Relobj* object, unsigned int shndx, const char* name,
			  const elfcpp::Shdr<64, false>& shdr, off_t*);
d2006 4
a2009 2
Layout::layout<64, true>(Relobj* object, unsigned int shndx, const char* name,
			 const elfcpp::Shdr<64, true>& shdr, off_t*);
d2012 59
@


1.42
log
@From Cary Coutant: More support for -shared, including fixes to GOT
handling.
@
text
@d640 1
a640 1
  off = this->set_section_offsets(off, &shndx, true);
d650 4
a653 1
  off = this->set_section_offsets(off, &shndx, false);
a998 1
                            unsigned int* pshndx,
a1008 2
      (*p)->set_out_shndx(*pshndx);
      ++*pshndx;
d1016 16
@


1.41
log
@From Cary Coutant: Set offsets of sections with data before finalizing
local symbols.
@
text
@d594 2
a595 1
      this->create_interp(target);
@


1.40
log
@Add support for PT_GNU_STACK.
@
text
@d636 5
d647 1
a647 1
  // Set the file offsets of all the sections not associated with
d649 1
a649 1
  off = this->set_section_offsets(off, &shndx);
d994 3
a996 1
Layout::set_section_offsets(off_t off, unsigned int* pshndx)
d1002 4
@


1.39
log
@Fix versions of copied symbols.
@
text
@d70 4
a73 1
    eh_frame_section_(NULL), output_file_size_(-1)
d410 21
d569 2
a570 1
  this->create_note_section();
d663 1
a663 1
Layout::create_note_section()
d679 1
a679 1
#ifdef GABI_FORMAT_FOR_DOTNOTE_SECTION   // this is not defined by default
d747 48
d1202 2
a1203 3
  index = symtab->set_dynsym_indexes(&this->options_, target, index,
				     pdynamic_symbols, &this->dynpool_,
				     pversions);
@


1.38
log
@Rework section mapping algorithm to handle .data.rel.ro sections.
@
text
@d581 1
a581 1
      this->create_version_sections(&versions, local_dynamic_count,
d1217 1
d1232 1
a1232 1
                  versions, local_symcount, dynamic_symbols, dynstr
d1243 1
a1243 1
                  versions, local_symcount, dynamic_symbols, dynstr
d1257 1
a1257 1
                  versions, local_symcount, dynamic_symbols, dynstr
d1268 1
a1268 1
                  versions, local_symcount, dynamic_symbols, dynstr
d1285 1
d1299 1
a1299 1
      &this->dynpool_, local_symcount, dynamic_symbols, &vbuf, &vsize
@


1.37
log
@From Cary Coutant: preliminary shared library support.
@
text
@d1517 41
a1557 2
  // If the section name has no '.', or only an initial '.', we use
  // the name unchanged (i.e., ".text" is unchanged).
d1559 1
a1559 7
  // Otherwise, if the section name does not include ".rel", we drop
  // the last '.'  and everything that follows (i.e., ".text.XXX"
  // becomes ".text").

  // Otherwise, if the section name has zero or one '.' after the
  // ".rel", we use the name unchanged (i.e., ".rel.text" is
  // unchanged).
d1561 2
a1562 2
  // Otherwise, we drop the last '.' and everything that follows
  // (i.e., ".rel.text.XXX" becomes ".rel.text").
d1565 3
a1567 2
  if (*s == '.')
    ++s;
d1572 2
a1573 2
  const char* srel = strstr(s, ".rel");
  if (srel == NULL)
d1575 2
a1576 2
      *plen = sdot - name;
      return name;
a1577 7

  sdot = strchr(srel + 1, '.');
  if (sdot == NULL)
    return name;
  sdot = strchr(sdot + 1, '.');
  if (sdot == NULL)
    return name;
@


1.36
log
@From Craig Silverstein: implement -Ttext.
@
text
@d414 1
a414 1
  if (!input_objects->any_dynamic())
d548 1
a548 1
  if (input_objects->any_dynamic())
@


1.35
log
@From Craig Silverstein: always use 32-bit format for gold note.
@
text
@d820 5
a824 1
  uint64_t addr = target->text_segment_address();
@


1.34
log
@Add an option for Stringpools to not copy strings.
@
text
@d643 12
d656 3
@


1.33
log
@Add --stats option to print runtime and memory usage statistics.
@
text
@d223 1
a223 1
  name = this->namepool_.add(name, len, &name_key);
d268 1
d299 1
a299 1
  name = this->namepool_.add(name, &name_key);
d417 1
a417 1
  const char* dynamic_name = this->namepool_.add(".dynamic", NULL);
d698 1
a698 1
  const char* note_name = this->namepool_.add(".note", NULL);
d1003 1
a1003 1
      const char* symtab_name = this->namepool_.add(".symtab", NULL);
d1013 1
a1013 1
      const char* strtab_name = this->namepool_.add(".strtab", NULL);
d1040 1
a1040 1
  const char* name = this->namepool_.add(".shstrtab", NULL);
d1132 1
a1132 1
  const char* dynsym_name = this->namepool_.add(".dynsym", NULL);
d1153 1
a1153 1
  const char* dynstr_name = this->namepool_.add(".dynstr", NULL);
d1178 1
a1178 1
  const char* hash_name = this->namepool_.add(".hash", NULL);
d1270 1
a1270 1
  const char* vname = this->namepool_.add(".gnu.version", NULL);
d1292 1
a1292 1
      const char* vdname = this->namepool_.add(".gnu.version_d", NULL);
d1318 1
a1318 1
      const char* vnname = this->namepool_.add(".gnu.version_r", NULL);
d1359 1
a1359 1
  const char* interp_name = this->namepool_.add(".interp", NULL);
@


1.32
log
@Implement -s and -S options which strip symbols.
@
text
@d70 1
a70 1
    eh_frame_section_(NULL)
d627 2
@


1.31
log
@Create a note section with the version of gold.
@
text
@d89 8
d101 1
a101 1
Layout::include_section(Object*, const char*,
d122 13
a135 1
      // FIXME: Handle stripping debug sections here.
d996 3
a998 1
  this->sympool_.set_string_offsets();
d1000 22
a1021 22
  const char* symtab_name = this->namepool_.add(".symtab", NULL);
  Output_section* osymtab = this->make_output_section(symtab_name,
						      elfcpp::SHT_SYMTAB,
						      0);
  this->symtab_section_ = osymtab;

  Output_section_data* pos = new Output_data_space(off - startoff,
						   align);
  osymtab->add_output_section_data(pos);

  const char* strtab_name = this->namepool_.add(".strtab", NULL);
  Output_section* ostrtab = this->make_output_section(strtab_name,
						      elfcpp::SHT_STRTAB,
						      0);

  Output_section_data* pstr = new Output_data_strtab(&this->sympool_);
  ostrtab->add_output_section_data(pstr);

  osymtab->set_address(0, startoff);
  osymtab->set_link_section(ostrtab);
  osymtab->set_info(local_symcount);
  osymtab->set_entsize(symsize);
d1023 2
a1024 1
  *poff = off;
d1581 1
a1581 4
  const Output_section* symtab_section = this->symtab_section_;
  for (Section_list::const_iterator p = this->section_list_.begin();
       p != this->section_list_.end();
       ++p)
d1583 4
a1586 1
      if ((*p)->needs_symtab_index())
d1588 9
a1596 6
	  gold_assert(symtab_section != NULL);
	  unsigned int index = (*p)->symtab_index();
	  gold_assert(index > 0 && index != -1U);
	  off_t off = (symtab_section->offset()
		       + index * symtab_section->entsize());
	  symtab->write_section_symbol(*p, of, off);
@


1.30
log
@Full support for --sysroot.
@
text
@d524 2
d609 73
@


1.29
log
@From Craig Silverstein: avoid some signed/unsigned warnings from gcc 4.2.
@
text
@d1312 1
a1312 1
            rpath_val = *p;
d1318 1
a1318 1
                if (strcmp(*q, *p) == 0)
d1323 1
a1323 1
                  rpath_val += *p;
@


1.28
log
@Put size and endianness in parameters.
@
text
@d894 1
a894 1
      gold_assert(dyncount * symsize
@


1.27
log
@Add basic exception frame header, plus test.
@
text
@d254 1
a254 1
	  Eh_frame_hdr* hdr_posd = new Eh_frame_hdr(object->target(), os);
d407 1
a407 2
  this->dynamic_data_ =  new Output_data_dynamic(input_objects->target(),
						 &this->dynpool_);
a520 1
  const int size = target->get_size();
d558 1
a558 1
      this->create_version_sections(target, &versions, local_dynamic_count,
a566 1
  bool big_endian = target->is_big_endian();
d568 1
a568 2
  segment_headers = new Output_segment_headers(size, big_endian,
					       this->segment_list_);
d576 1
a576 5
  file_header = new Output_file_header(size,
				       big_endian,
				       target,
				       symtab,
				       segment_headers);
d589 1
a589 1
  this->create_symtab_sections(size, input_objects, symtab, &off);
d599 1
a599 1
  Output_section_headers* oshdrs = this->create_shdrs(size, big_endian, &off);
d821 1
a821 1
Layout::create_symtab_sections(int size, const Input_objects* input_objects,
d827 1
a827 1
  if (size == 32)
d832 1
a832 1
  else if (size == 64)
d955 1
a955 1
Layout::create_shdrs(int size, bool big_endian, off_t* poff)
d958 1
a958 1
  oshdrs = new Output_section_headers(size, big_endian, this,
d1015 1
a1015 1
  const int size = target->get_size();
d1074 1
a1074 1
  Dynobj::create_elf_hash_table(target, *pdynamic_symbols, local_symcount,
d1096 1
a1096 1
Layout::create_version_sections(const Target* target, const Versions* versions,
d1104 1
a1104 1
  if (target->get_size() == 32)
d1106 1
a1106 1
      if (target->is_big_endian())
d1129 1
a1129 1
  else if (target->get_size() == 64)
d1131 1
a1131 1
      if (target->is_big_endian())
d1481 1
a1481 2
Layout::write_data(const Symbol_table* symtab, const Target* target,
		   Output_file* of) const
d1495 1
a1495 1
	  symtab->write_section_symbol(target, *p, of, off);
d1511 1
a1511 1
	  symtab->write_section_symbol(target, *p, of, off);
d1554 1
a1554 1
  this->layout_->write_data(this->symtab_, this->target_, this->of_);
@


1.26
log
@Fix typo in comment.
@
text
@d34 1
d69 2
a70 1
    dynsym_section_(NULL), dynamic_section_(NULL), dynamic_data_(NULL)
d211 11
d227 40
@


1.25
log
@Add licensing text to every source file.
@
text
@d1419 1
a1419 1
      // linkonce section with tihs signature.  Record that we've seen
@


1.24
log
@Define __start and __stop symbols.
@
text
@d3 20
@


1.23
log
@Add global parameters.
@
text
@d340 52
@


1.22
log
@Use nops when doing alignment padding between code sections.
@
text
@d10 1
d90 1
a90 1
      return this->options_.is_relocatable();
d174 1
a174 1
  if (!this->options_.is_relocatable())
d399 1
a399 1
  target->finalize_sections(&this->options_, this);
a456 1
				       this->options_,
d1060 2
a1061 2
      &this->options_, &this->dynpool_, local_symcount, dynamic_symbols,
      &vbuf, &vsize SELECT_SIZE_ENDIAN(size, big_endian));
@


1.21
log
@Don't try to find version definition index when creating an executable.
@
text
@d31 2
a32 1
  Output_file* of = new Output_file(this->options_);
@


1.20
log
@Add support for --enable-target to control which template
specializations we generate.
@
text
@d1059 2
a1060 2
      &this->dynpool_, local_symcount, dynamic_symbols, &vbuf, &vsize
      SELECT_SIZE_ENDIAN(size, big_endian));
@


1.19
log
@Force PT_LOAD segments to be aligned to the page size.
@
text
@d989 10
a998 3
	this->sized_create_version_sections SELECT_SIZE_ENDIAN_NAME(32, true)(
            versions, local_symcount, dynamic_symbols, dynstr
            SELECT_SIZE_ENDIAN(32, true));
d1000 10
a1009 3
	this->sized_create_version_sections SELECT_SIZE_ENDIAN_NAME(32, false)(
            versions, local_symcount, dynamic_symbols, dynstr
            SELECT_SIZE_ENDIAN(32, false));
d1014 10
a1023 3
	this->sized_create_version_sections SELECT_SIZE_ENDIAN_NAME(64, true)(
            versions, local_symcount, dynamic_symbols, dynstr
            SELECT_SIZE_ENDIAN(64, true));
d1025 10
a1034 3
	this->sized_create_version_sections SELECT_SIZE_ENDIAN_NAME(64, false)(
            versions, local_symcount, dynamic_symbols, dynstr
            SELECT_SIZE_ENDIAN(64, false));
d1480 1
d1485 1
d1487 1
d1492 1
d1494 1
d1499 1
d1501 1
d1506 1
@


1.18
log
@Add support for -rpath.
@
text
@d613 4
@


1.17
log
@Add support for SHF_MERGE sections.
@
text
@d1151 29
@


1.16
log
@gcc 3.2.2 and 4.1.0 portability hacks.
@
text
@d136 3
a138 1
	      | elfcpp::SHF_GROUP);
d229 1
a229 1
  Output_section* os = new Output_section(name, type, flags, true);
a470 1
  // FIXME: We don't need to do this if we are stripping symbols.
d694 3
a696 1
// Create the symbol table sections.
@


1.15
log
@Generate version information.
@
text
@d982 3
a984 4
	this->sized_create_version_sections<32, true>(versions,
						      local_symcount,
						      dynamic_symbols,
						      dynstr);
d986 3
a988 4
	this->sized_create_version_sections<32, false>(versions,
						       local_symcount,
						       dynamic_symbols,
						       dynstr);
d993 3
a995 4
	this->sized_create_version_sections<64, true>(versions,
						      local_symcount,
						      dynamic_symbols,
						      dynstr);
d997 3
a999 4
	this->sized_create_version_sections<64, false>(versions,
						       local_symcount,
						       dynamic_symbols,
						       dynstr);
d1013 2
a1014 1
    const Output_section* dynstr)
d1023 3
a1025 4
  versions->symbol_section_contents<size, big_endian>(&this->dynpool_,
						      local_symcount,
						      dynamic_symbols,
						      &vbuf, &vsize);
d1046 3
a1048 3
      versions->def_section_contents<size, big_endian>(&this->dynpool_,
						       &vdbuf, &vdsize,
						       &vdentries);
d1072 3
a1074 3
      versions->need_section_contents<size, big_endian>(&this->dynpool_,
							&vnbuf, &vnsize,
							&vnentries);
@


1.14
log
@Can now dynamically link hello, world.
@
text
@d45 2
a46 2
    tls_segment_(NULL), symtab_section_(NULL), dynsym_section_(NULL),
    dynamic_section_(NULL), dynamic_data_(NULL)
d325 1
a325 1
  symtab->define_in_output_data(input_objects->target(), "_DYNAMIC",
d408 8
a415 3
      // Create the dynamic symbol table, including the hash table,
      // the dynamic relocations, and the version sections.
      this->create_dynamic_symtab(target, symtab);
d424 9
d848 5
a852 1
Layout::create_dynamic_symtab(const Target* target, Symbol_table* symtab)
d880 1
a880 2

  std::vector<Symbol*> dynamic_symbols;
d884 3
a886 2
  index = symtab->set_dynsym_indexes(index, &dynamic_symbols,
				     &this->dynpool_);
d904 2
d925 2
d941 4
d949 1
a949 1
  Dynobj::create_elf_hash_table(target, dynamic_symbols, local_symcount,
d968 125
d1144 1
a1144 1
  if (sym != NULL && sym->is_defined() && !sym->is_defined_in_dynobj())
d1148 1
a1148 1
  if (sym != NULL && sym->is_defined() && !sym->is_defined_in_dynobj())
@


1.13
log
@Added a testsuite.  More support for COPY relocations.
@
text
@d45 2
a46 1
    tls_segment_(NULL), symtab_section_(NULL), dynsym_section_(NULL)
d329 5
d395 1
a395 1
  target->finalize_sections(this);
a407 5
      // This holds the dynamic tags.
      Output_data_dynamic* odyn;
      odyn = new Output_data_dynamic(input_objects->target(),
				     &this->dynpool_);

d410 1
a410 1
      this->create_dynamic_symtab(target, odyn, symtab);
d418 1
a418 1
      this->finish_dynamic_section(input_objects, symtab, odyn);
d456 1
a456 3
  Output_section* ostrtab;
  this->create_symtab_sections(size, input_objects, symtab, &off,
			       &ostrtab);
a464 3
  // Now the section index of OSTRTAB is set.
  this->symtab_section_->set_link(ostrtab->out_shndx());

d684 1
a684 2
			       off_t* poff,
			       Output_section** postrtab)
d740 21
a760 1
  off = symtab->finalize(local_symcount, off, &this->sympool_);
d783 1
a787 1
  *postrtab = ostrtab;
d819 3
a821 2
  oshdrs = new Output_section_headers(size, big_endian, this->segment_list_,
				      this->unattached_section_list_,
d834 1
a834 2
Layout::create_dynamic_symtab(const Target* target, Output_data_dynamic* odyn,
			      Symbol_table* symtab)
d901 1
d913 3
d936 1
a937 1
  // FIXME: .hash should link to .dynsym.
d973 1
a973 2
			       const Symbol_table* symtab,
			       Output_data_dynamic* odyn)
a974 2
  this->dynamic_section_->add_output_section_data(odyn);

d981 2
d1252 2
a1253 1
  this->symtab_->write_globals(this->target_, this->sympool_, this->of_);
@


1.12
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d386 1
a386 1
  const Target* const target = input_objects->target();
d388 2
@


1.11
log
@Snapshot.  Includes first cut at output relocation sections.
@
text
@a4 1
#include <cassert>
d12 1
d42 1
a42 1
  : options_(options), namepool_(), sympool_(), signatures_(),
d44 2
a45 1
    special_output_list_(), tls_segment_(NULL)
d49 5
a53 1
  segment_list_.reserve(12);
d227 1
d230 1
a230 1
    this->section_list_.push_back(os);
d308 22
d386 2
a387 1
  const int size = input_objects->target()->get_size();
d400 5
d407 1
a407 5
      this->create_dynamic_symtab(size, symtab);

      // Create the .dynamic section to hold the dynamic data, and put
      // it in a PT_DYNAMIC segment.
      this->create_dynamic_section();
d411 5
a415 1
      this->create_interp(input_objects->target());
d423 1
a423 1
  bool big_endian = input_objects->target()->is_big_endian();
d437 1
a437 1
				       input_objects->target(),
d449 1
a449 2
  off_t off = this->set_segment_offsets(input_objects->target(), load_seg,
					&shndx);
a452 1
  Output_section* osymtab;
d455 1
a455 1
			       &osymtab, &ostrtab);
d465 1
a465 1
  osymtab->set_link(ostrtab->out_shndx());
d473 1
d493 1
a493 1
      assert(type2 != elfcpp::PT_PHDR);
d503 1
a503 1
      assert(type2 != elfcpp::PT_INTERP);
d533 1
a533 1
      assert(flags1 != flags2);
d558 1
a558 1
  assert(paddr1 != paddr2);
d586 1
a586 1
	    abort();
d666 2
a667 2
  for (Layout::Section_list::iterator p = this->section_list_.begin();
       p != this->section_list_.end();
a686 1
			       Output_section** posymtab,
d702 1
a702 1
    abort();
d713 15
d741 1
a741 1
  assert(local_symcount * symsize == off - startoff);
d748 8
a755 3
  Output_section* osymtab = new Output_section_symtab(symtab_name,
						      off - startoff);
  this->section_list_.push_back(osymtab);
d758 6
a763 4
  Output_section *ostrtab = new Output_section_strtab(strtab_name,
						      &this->sympool_);
  this->section_list_.push_back(ostrtab);
  this->special_output_list_.push_back(ostrtab);
a767 1
  osymtab->set_addralign(align);
a769 1
  *posymtab = osymtab;
d787 1
a787 1
  Output_section* os = new Output_section_strtab(name, &this->namepool_);
d789 2
a790 2
  this->section_list_.push_back(os);
  this->special_output_list_.push_back(os);
d803 1
a803 1
				      this->section_list_,
d816 2
a817 1
Layout::create_dynamic_symtab(int, Symbol_table*)
d819 95
a913 2
  abort();
}
d915 2
a916 1
// Create the .dynamic section and PT_DYNAMIC segment.
d918 1
a918 4
void
Layout::create_dynamic_section()
{
  abort();
d930 1
a930 1
      assert(interp != NULL);
d948 35
d1132 2
a1133 1
Layout::write_data(Output_file* of) const
d1135 42
d1206 1
a1206 1
  this->layout_->write_data(this->of_);
@


1.10
log
@More dynamic object support, initial scripting support.
@
text
@d679 1
d686 5
a690 1
      off = (*p)->finalize_local_symbols(off, &this->sympool_);
d693 1
a693 1
  unsigned int local_symcount = (off - startoff) / symsize;
d696 1
a696 1
  off = symtab->finalize(off, &this->sympool_);
@


1.9
log
@Rework stringpool and hash tables so that we always generate the same
output regardless of randomize_va_space.
@
text
@d358 3
d363 19
a381 5
      // If there are any dynamic objects in the link, then we need
      // some additional segments: PT_PHDRS, PT_INTERP, and
      // PT_DYNAMIC.  We also need to finalize the dynamic symbol
      // table and create the dynamic hash table.
      abort();
a388 1
  int size = input_objects->target()->get_size();
d395 2
a396 1
  // FIXME: Attach them to PT_PHDRS if necessary.
d754 43
@


1.8
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@d56 1
a56 1
 return reinterpret_cast<size_t>(k.first) + k.second.first + k.second.second;
d98 1
a98 1
    if (strcmp(p->first.first, name) == 0)
d124 2
a125 2
Layout::get_output_section(const char* name, elfcpp::Elf_Word type,
			   elfcpp::Elf_Xword flags)
d132 1
a132 1
  const Key key(name, std::make_pair(type, flags));
d170 2
a171 1
  name = this->namepool_.add(name, len);
d175 2
a176 1
  Output_section* os = this->get_output_section(name, shdr.get_sh_type(),
d194 2
a195 1
  name = this->namepool_.add(name);
d197 1
a197 1
  Output_section* os = this->get_output_section(name, type, flags);
d678 1
a678 1
  const char* symtab_name = this->namepool_.add(".symtab");
d683 1
a683 1
  const char* strtab_name = this->namepool_.add(".strtab");
d709 1
a709 1
  const char* name = this->namepool_.add(".shstrtab");
@


1.7
log
@Can now do a full static link of hello, world in C or C++
@
text
@d12 1
d155 1
a155 1
Layout::layout(Object* object, unsigned int shndx, const char* name,
d660 2
a661 2
  for (Input_objects::Object_list::const_iterator p = input_objects->begin();
       p != input_objects->end();
d960 1
a960 1
Layout::layout<32, false>(Object* object, unsigned int shndx, const char* name,
d965 1
a965 1
Layout::layout<32, true>(Object* object, unsigned int shndx, const char* name,
d970 1
a970 1
Layout::layout<64, false>(Object* object, unsigned int shndx, const char* name,
d975 1
a975 1
Layout::layout<64, true>(Object* object, unsigned int shndx, const char* name,
@


1.6
log
@Framework for relocation scanning.  Implement simple static TLS
relocations.
@
text
@d41 1
a41 1
  : options_(options), last_shndx_(0), namepool_(), sympool_(), signatures_(),
d89 1
a89 3
// Return the output section to use for input section NAME, with
// header HEADER, from object OBJECT.  Set *OFF to the offset of this
// input section without the output section.
a90 1
template<int size, bool big_endian>
d92 1
a92 2
Layout::layout(Object* object, const char* name,
	       const elfcpp::Shdr<size, big_endian>& shdr, off_t* off)
d94 7
a100 3
  // We discard empty input sections.
  if (shdr.get_sh_size() == 0)
    return NULL;
d102 2
a103 2
  if (!this->include_section(object, name, shdr))
    return NULL;
d105 13
a117 5
  // Unless we are doing a relocateable link, .gnu.linkonce sections
  // are laid out as though they were named for the sections are
  // placed into.
  if (!this->options_.is_relocatable() && Layout::is_linkonce(name))
    name = Layout::linkonce_output_name(name);
d119 2
a120 1
  // FIXME: Handle SHF_OS_NONCONFORMING here.
d122 8
a129 2
  // Canonicalize the section name.
  name = this->namepool_.add(name);
a130 10
  // Find the output section.  The output section is selected based on
  // the section name, type, and flags.

  // FIXME: If we want to do relaxation, we need to modify this
  // algorithm.  We also build a list of input sections for each
  // output section.  Then we relax all the input sections.  Then we
  // walk down the list and adjust all the offsets.

  elfcpp::Elf_Word type = shdr.get_sh_type();
  elfcpp::Elf_Xword flags = shdr.get_sh_flags();
a135 1
  Output_section* os;
d137 1
a137 1
    os = ins.first->second;
d142 1
a142 1
      os = this->make_output_section(name, type, flags);
d144 1
d146 29
d178 1
a178 1
  *off = os->add_input_section(object, name, shdr);
d183 14
d217 1
a217 3
  ++this->last_shndx_;
  Output_section* os = new Output_section(name, type, flags,
					  this->last_shndx_);
d388 8
a395 2
  // Set the file offsets of all the segments.
  off_t off = this->set_segment_offsets(input_objects->target(), load_seg);
d409 4
a412 1
  off = this->set_section_offsets(off);
d508 3
a510 3
// Set the file offsets of all the segments.  They have all been
// created.  LOAD_SEG must be be laid out first.  Return the offset of
// the data to follow.
d513 2
a514 1
Layout::set_segment_offsets(const Target* target, Output_segment* load_seg)
d548 1
a548 1
	      uint64_t align = (*p)->max_data_align();
d550 1
a550 1
	      addr = (addr + align - 1) & ~ (align - 1);
d556 1
d558 1
a558 1
	  uint64_t new_addr = (*p)->set_section_addresses(addr, &off);
d579 2
a580 2
		  addr = ((aligned_addr + common_pagesize - 1)
			  & ~ (common_pagesize - 1));
d582 1
a582 1
		  new_addr = (*p)->set_section_addresses(addr, &off);
d610 1
a610 1
Layout::set_section_offsets(off_t off)
d616 2
d620 1
a620 3
      uint64_t addralign = (*p)->addralign();
      if (addralign != 0)
	off = (off + addralign - 1) & ~ (addralign - 1);
d652 1
a652 1
  off = (off + align - 1) & ~ (align - 1);
a673 1
  ++this->last_shndx_;
d676 1
a676 2
						      off - startoff,
						      this->last_shndx_);
a678 1
  ++this->last_shndx_;
d681 1
a681 2
						      &this->sympool_,
						      this->last_shndx_);
a685 1
  osymtab->set_link(ostrtab->shndx());
d709 1
a709 4
  ++this->last_shndx_;
  Output_section* os = new Output_section_strtab(name,
						 &this->namepool_,
						 this->last_shndx_);
d727 1
a727 2
  uint64_t addralign = oshdrs->addralign();
  off_t off = (*poff + addralign - 1) & ~ (addralign - 1);
d737 1
a737 1
#define MAPPING_INIT(f, t) { f, sizeof(f) - 1, t }
d764 2
a765 1
// to ".text".
d768 1
a768 1
Layout::linkonce_output_name(const char* name)
d778 4
a781 1
	return plm->to;
d786 53
d851 1
a851 1
    this->signatures_.insert(std::make_pair(signature, group)));
d959 1
a959 1
Layout::layout<32, false>(Object* object, const char* name,
d964 1
a964 1
Layout::layout<32, true>(Object* object, const char* name,
d969 1
a969 1
Layout::layout<64, false>(Object* object, const char* name,
d974 1
a974 1
Layout::layout<64, true>(Object* object, const char* name,
@


1.5
log
@Lay out object file sections when we add the symbols to the symbol
table.
@
text
@d17 1
a17 24
// Layout_task methods.

Layout_task::~Layout_task()
{
}

// This task can be run when it is unblocked.

Task::Is_runnable_type
Layout_task::is_runnable(Workqueue*)
{
  if (this->this_blocker_->is_blocked())
    return IS_BLOCKED;
  return IS_RUNNABLE;
}

// We don't need to hold any locks for the duration of this task.  In
// fact this task will be the only one running.

Task_locker*
Layout_task::locks(Workqueue*)
{
  return NULL;
}
d23 1
a23 1
Layout_task::run(Workqueue* workqueue)
d43 1
a43 1
    special_output_list_()
d236 1
a236 1
      // segment.
d239 1
a239 4
	  // See if we already have an equivalent PT_TLS segment.
	  for (p = this->segment_list_.begin();
	       p != segment_list_.end();
	       ++p)
d241 3
a243 15
	      if ((*p)->type() == elfcpp::PT_TLS
		  && (((*p)->flags() & elfcpp::PF_W)
		      == (seg_flags & elfcpp::PF_W)))
		{
		  (*p)->add_output_section(os, seg_flags);
		  break;
		}
	    }

	  if (p == this->segment_list_.end())
	    {
	      Output_segment* oseg = new Output_segment(elfcpp::PT_TLS,
							seg_flags);
	      this->segment_list_.push_back(oseg);
	      oseg->add_output_section(os, seg_flags);
d245 1
d406 8
d839 1
a839 19
// Close_task methods.

// We can't run until FINAL_BLOCKER is unblocked.

Task::Is_runnable_type
Close_task::is_runnable(Workqueue*)
{
  if (this->final_blocker_->is_blocked())
    return IS_BLOCKED;
  return IS_RUNNABLE;
}

// We don't lock anything.

Task_locker*
Close_task::locks(Workqueue*)
{
  return NULL;
}
d844 1
a844 1
Close_task::run(Workqueue*)
@


1.4
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d48 2
a49 9
  // Nothing ever frees this.
  Layout* layout = new Layout(this->options_);
  layout->init();
  for (Input_objects::Object_list::const_iterator p =
	 this->input_objects_->begin();
       p != this->input_objects_->end();
       ++p)
    (*p)->layout(layout);
  off_t file_size = layout->finalize(this->input_objects_, this->symtab_);
d58 1
a58 1
			  this->symtab_, layout, workqueue, of);
a66 7
{
}

// Prepare for doing layout.

void
Layout::init()
@


1.3
log
@Finished layout code.
@
text
@d46 1
a46 1
Layout_task::run(Workqueue*)
d48 3
a50 2
  Layout layout(this->options_);
  layout.init();
d55 11
a65 2
    (*p)->layout(&layout);
  layout.finalize(this->input_objects_, this->symtab_);
d71 3
a73 2
  : options_(options), namepool_(), sympool_(), signatures_(),
    section_name_map_(), segment_list_(), section_list_()
d135 4
d206 3
a208 1
  Output_section* os = new Output_section(name, type, flags);
d374 1
d376 2
a377 1
  segment_headers = new Output_segment_headers(size, this->segment_list_);
d379 1
d385 1
d391 1
d400 2
a401 1
  this->create_symtab_sections(input_objects, symtab, &osymtab, &ostrtab);
d411 1
a411 2
  Output_section_headers* oshdrs = this->create_shdrs(size, off);
  off += oshdrs->data_size();
d602 2
d605 2
a606 1
      off = (off + addralign - 1) & ~ (addralign - 1);
d616 1
a616 1
Layout::create_symtab_sections(const Input_objects* input_objects,
d618 1
d622 23
a644 1
  off_t off = 0;
d653 3
d658 26
a683 3
  *posymtab = new Output_section_symtab(this->namepool_.add(".symtab"), off);
  *postrtab = new Output_section_strtab(this->namepool_.add(".strtab"),
					&this->sympool_);
d698 3
d702 2
a703 1
						 &this->namepool_);
d706 1
d715 1
a715 1
Layout::create_shdrs(int size, off_t off)
d718 3
a720 2
  oshdrs = new Output_section_headers(size, this->segment_list_,
				      this->section_list_);
d722 1
a722 1
  off = (off + addralign - 1) & ~ (addralign - 1);
d724 3
d817 91
@


1.2
log
@More section layout code.
@
text
@d55 1
a55 1
  layout.finalize(this->input_objects_);
d61 2
a62 3
  : options_(options), namepool_(), signatures_(),
    section_name_map_(), segment_list_(), section_list_(),
    data_list_()
a170 76
// Return whether SEG1 should be before SEG2 in the output file.  This
// is based entirely on the segment type and flags.  When this is
// called the segment addresses has normally not yet been set.

bool
Layout::segment_precedes(const Output_segment* seg1,
			 const Output_segment* seg2)
{
  elfcpp::Elf_Word type1 = seg1->type();
  elfcpp::Elf_Word type2 = seg2->type();

  // The single PT_PHDR segment is required to precede any loadable
  // segment.  We simply make it always first.
  if (type1 == elfcpp::PT_PHDR)
    {
      assert(type2 != elfcpp::PT_PHDR);
      return true;
    }
  if (type2 == elfcpp::PT_PHDR)
    return false;

  // The single PT_INTERP segment is required to precede any loadable
  // segment.  We simply make it always second.
  if (type1 == elfcpp::PT_INTERP)
    {
      assert(type2 != elfcpp::PT_INTERP);
      return true;
    }
  if (type2 == elfcpp::PT_INTERP)
    return false;

  // We then put PT_LOAD segments before any other segments.
  if (type1 == elfcpp::PT_LOAD && type2 != elfcpp::PT_LOAD)
    return true;
  if (type2 == elfcpp::PT_LOAD && type1 != elfcpp::PT_LOAD)
    return false;

  const elfcpp::Elf_Word flags1 = seg1->flags();
  const elfcpp::Elf_Word flags2 = seg2->flags();

  // The order of non-PT_LOAD segments is unimportant.  We simply sort
  // by the numeric segment type and flags values.  There should not
  // be more than one segment with the same type and flags.
  if (type1 != elfcpp::PT_LOAD)
    {
      if (type1 != type2)
	return type1 < type2;
      assert(flags1 != flags2);
      return flags1 < flags2;
    }

  // We sort PT_LOAD segments based on the flags.  Readonly segments
  // come before writable segments.  Then executable segments come
  // before non-executable segments.  Then the unlikely case of a
  // non-readable segment comes before the normal case of a readable
  // segment.  If there are multiple segments with the same type and
  // flags, we require that the address be set, and we sort by
  // virtual address and then physical address.
  if ((flags1 & elfcpp::PF_W) != (flags2 & elfcpp::PF_W))
    return (flags1 & elfcpp::PF_W) == 0;
  if ((flags1 & elfcpp::PF_X) != (flags2 & elfcpp::PF_X))
    return (flags1 & elfcpp::PF_X) != 0;
  if ((flags1 & elfcpp::PF_R) != (flags2 & elfcpp::PF_R))
    return (flags1 & elfcpp::PF_R) == 0;

  uint64_t vaddr1 = seg1->vaddr();
  uint64_t vaddr2 = seg2->vaddr();
  if (vaddr1 != vaddr2)
    return vaddr1 < vaddr2;

  uint64_t paddr1 = seg1->paddr();
  uint64_t paddr2 = seg2->paddr();
  assert(paddr1 != paddr2);
  return paddr1 < paddr2;
}

d215 1
a215 1
	      (*p)->add_output_section(os);
d225 1
a225 1
	  oseg->add_output_section(os);
d241 1
a241 1
		  (*p)->add_output_section(os);
d251 1
a251 1
	      oseg->add_output_section(os);
d268 1
a268 1
		  (*p)->add_output_section(os);
d278 1
a278 1
	      oseg->add_output_section(os);
d286 2
a287 1
// Create the sections for the symbol table.
d289 2
a290 2
void
Layout::create_symtab_sections()
d292 13
d323 4
a326 1
// 5) Finalize the symbol table: set symbol values to their final
a329 3
// 6) Create the symbol table sections and the section name table
// section.

d337 4
a340 2
void
Layout::finalize(const Input_objects* input_objects)
d353 129
d485 160
a644 2
  Output_segment_headers* segment_headers;
  segment_headers = new Output_segment_headers(this->segment_list_);
@


1.1
log
@New drop, with first cut of section layout code.
@
text
@d7 1
d49 3
a51 1
  for (Object_list::const_iterator p = this->input_objects_->begin();
d55 1
d60 17
a292 2
	      if ((*p)->flags() != seg_flags)
		(*p)->update_flags(seg_flags);
a318 2
		  if ((*p)->flags() != seg_flags)
		    (*p)->update_flags(seg_flags);
d331 27
d361 58
@

