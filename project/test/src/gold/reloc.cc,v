head	1.69;
access;
symbols
	binutils-2_24-branch:1.69.0.2
	binutils-2_24-branchpoint:1.69
	binutils-2_21_1:1.60.2.1
	binutils-2_23_2:1.68
	binutils-2_23_1:1.68
	binutils-2_23:1.68
	binutils-2_23-branch:1.68.0.6
	binutils-2_23-branchpoint:1.68
	binutils-2_22_branch:1.68.0.4
	binutils-2_22:1.68
	binutils-2_22-branch:1.68.0.2
	binutils-2_22-branchpoint:1.68
	binutils-2_21:1.60
	binutils-2_21-branch:1.60.0.2
	binutils-2_21-branchpoint:1.60
	binutils-2_20_1:1.44.2.1
	binutils-2_20:1.44.2.1
	binutils-arc-20081103-branch:1.38.0.4
	binutils-arc-20081103-branchpoint:1.38
	binutils-2_20-branch:1.44.0.2
	binutils-2_20-branchpoint:1.44
	dje-cgen-play1-branch:1.43.0.2
	dje-cgen-play1-branchpoint:1.43
	arc-20081103-branch:1.38.0.2
	arc-20081103-branchpoint:1.38
	binutils-2_19_1:1.37
	binutils-2_19:1.37
	binutils-2_19-branch:1.37.0.2
	binutils-2_19-branchpoint:1.37
	binutils_latest_snapshot:1.69
	added-to-binutils:1.33;
locks; strict;
comment	@// @;


1.69
date	2012.09.05.00.34.20;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2011.06.25.00.40.56;	author ian;	state Exp;
branches;
next	1.67;

1.67
date	2011.05.31.04.26.49;	author ian;	state Exp;
branches;
next	1.66;

1.66
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.65;

1.65
date	2011.04.14.23.29.41;	author ccoutant;	state Exp;
branches;
next	1.64;

1.64
date	2011.04.12.00.44.48;	author ccoutant;	state Exp;
branches;
next	1.63;

1.63
date	2011.02.10.01.12.37;	author ian;	state Exp;
branches;
next	1.62;

1.62
date	2010.12.14.19.03.30;	author rwild;	state Exp;
branches;
next	1.61;

1.61
date	2010.12.01.19.49.22;	author ian;	state Exp;
branches;
next	1.60;

1.60
date	2010.10.14.22.10.22;	author ccoutant;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2010.08.12.22.01.11;	author ccoutant;	state Exp;
branches;
next	1.57;

1.57
date	2010.07.12.17.59.58;	author ccoutant;	state Exp;
branches;
next	1.56;

1.56
date	2010.03.11.01.10.53;	author ian;	state Exp;
branches;
next	1.55;

1.55
date	2010.03.10.17.37.11;	author ccoutant;	state Exp;
branches;
next	1.54;

1.54
date	2010.02.12.04.33.53;	author ian;	state Exp;
branches;
next	1.53;

1.53
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.52;

1.52
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2009.11.09.02.02.01;	author ian;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.29.05.16.23;	author ian;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.25.16.57.32;	author dougkwan;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.15.00.33.18;	author ian;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.13.21.17.43;	author tmsriram;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.06.22.58.27;	author ian;	state Exp;
branches;
next	1.45;

1.45
date	2009.09.30.22.21.13;	author ian;	state Exp;
branches;
next	1.44;

1.44
date	2009.08.05.20.51.56;	author tmsriram;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2009.06.24.14.36.14;	author ian;	state Exp;
branches;
next	1.42;

1.42
date	2009.03.04.06.46.27;	author ian;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.28.02.25.33;	author tmsriram;	state Exp;
branches;
next	1.40;

1.40
date	2008.12.12.16.33.04;	author ian;	state Exp;
branches;
next	1.39;

1.39
date	2008.11.15.01.40.23;	author ccoutant;	state Exp;
branches;
next	1.38;

1.38
date	2008.09.29.21.10.26;	author ccoutant;	state Exp;
branches;
next	1.37;

1.37
date	2008.07.10.23.01.19;	author ian;	state Exp;
branches;
next	1.36;

1.36
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.35;

1.35
date	2008.04.16.22.54.29;	author ian;	state Exp;
branches;
next	1.34;

1.34
date	2008.04.02.20.58.21;	author ian;	state Exp;
branches;
next	1.33;

1.33
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2008.02.28.19.46.06;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2008.02.27.22.38.18;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2008.02.06.08.13.50;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2008.01.02.23.48.49;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2007.12.21.23.08.25;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.12.21.21.19.45;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.12.20.21.21.24;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.14.19.00.21;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.12.06.05.55.50;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.01.06.34.12;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.22.00.05.51;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.15.23.46.46;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.12.20.35.21;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.14.06.49.14;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.02.20.52.18;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.25.17.50.26;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.04.20.00.53;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.16.17.42.48;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.06.00.02.36;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.01.16.51.25;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.30.23.52.50;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.16.00.38.25;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.07.18.51.39;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.06.22.46.08;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.03.18.26.11;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.20.20.40.49;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.29.19.58.17;	author iant;	state Exp;
branches;
next	;

1.60.2.1
date	2011.02.10.01.15.28;	author ian;	state Exp;
branches;
next	;

1.44.2.1
date	2009.10.16.05.51.18;	author ian;	state Exp;
branches;
next	;


desc
@@


1.69
log
@	* object.h (Sized_relobj_file::emit_relocs): Delete.
	(Sized_relobj_file::emit_relocs_reltype): Delete.
	* reloc.cc (Sized_relobj_file::do_relocate_sections): Call target
	relocate_relocs for --emit-relocs.
	(Sized_relobj_file::emit_relocs, emit_relocs_reltype): Delete.
	* output.h: Update comment.
	(Output_segment::first_section): New function.
	(Output_segment::first_section_load_address): Use first_section.
	* output.cc (Output_segment::first_section): New function extracted..
	(Output_segment::first_section_load_address): ..from here.  Delete.
	* target-reloc.h (relocate_for_relocatable): Rename to relocate_relocs.
	* target.h (Sized_target::relocate_for_relocatable): Likewise.
	* arm.cc (Target_arm::relocate_for_relocatable): Likewise, and
	adjust call to target.h function.
	* i386.cc (Target_i386): Likewise.
	* sparc.cc (Target_sparc): Likewise.
	* x86_64.cc (Target_x86_64): Likewise.
	* powerpc.cc (Target_powerpc): Likewise.
	(Target_powerpc::Scan::local, global): Handle R_POWERPC_TLS.  Ensure
	first tls section has section symbol for optimised local dynamic
	output relocs.
	(Target_powerpc::Relocate::relocate): Correct local dynamic value.
	(Target_powerpc::relocate_relocs): Adjust relocs emitted for
	optimised tls code.
	* testsuite/testfile.cc (Target_test::relocate_for_relocatable):
	Rename to relocate_relocs.  Update error message.
@
text
@// reloc.cc -- relocate input files for gold.

// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <algorithm>

#include "workqueue.h"
#include "layout.h"
#include "symtab.h"
#include "output.h"
#include "merge.h"
#include "object.h"
#include "target-reloc.h"
#include "reloc.h"
#include "icf.h"
#include "compressed_output.h"
#include "incremental.h"

namespace gold
{

// Read_relocs methods.

// These tasks just read the relocation information from the file.
// After reading it, the start another task to process the
// information.  These tasks requires access to the file.

Task_token*
Read_relocs::is_runnable()
{
  return this->object_->is_locked() ? this->object_->token() : NULL;
}

// Lock the file.

void
Read_relocs::locks(Task_locker* tl)
{
  Task_token* token = this->object_->token();
  if (token != NULL)
    tl->add(this, token);
}

// Read the relocations and then start a Scan_relocs_task.

void
Read_relocs::run(Workqueue* workqueue)
{
  Read_relocs_data* rd = new Read_relocs_data;
  this->object_->read_relocs(rd);
  this->object_->set_relocs_data(rd);
  this->object_->release();

  // If garbage collection or identical comdat folding is desired, we  
  // process the relocs first before scanning them.  Scanning of relocs is
  // done only after garbage or identical sections is identified.
  if (parameters->options().gc_sections()
      || parameters->options().icf_enabled())
    {
      workqueue->queue_next(new Gc_process_relocs(this->symtab_,
                                                  this->layout_, 
                                                  this->object_, rd,
                                                  this->this_blocker_,
						  this->next_blocker_));
    }
  else
    {
      workqueue->queue_next(new Scan_relocs(this->symtab_, this->layout_,
					    this->object_, rd,
                                            this->this_blocker_,
					    this->next_blocker_));
    }
}

// Return a debugging name for the task.

std::string
Read_relocs::get_name() const
{
  return "Read_relocs " + this->object_->name();
}

// Gc_process_relocs methods.

Gc_process_relocs::~Gc_process_relocs()
{
  if (this->this_blocker_ != NULL)
    delete this->this_blocker_;
}

// These tasks process the relocations read by Read_relocs and
// determine which sections are referenced and which are garbage.
// This task is done only when --gc-sections is used.  This is blocked
// by THIS_BLOCKER_.  It unblocks NEXT_BLOCKER_.

Task_token*
Gc_process_relocs::is_runnable()
{
  if (this->this_blocker_ != NULL && this->this_blocker_->is_blocked())
    return this->this_blocker_;
  if (this->object_->is_locked())
    return this->object_->token();
  return NULL;
}

void
Gc_process_relocs::locks(Task_locker* tl)
{
  tl->add(this, this->object_->token());
  tl->add(this, this->next_blocker_);
}

void
Gc_process_relocs::run(Workqueue*)
{
  this->object_->gc_process_relocs(this->symtab_, this->layout_, this->rd_);
  this->object_->release();
}

// Return a debugging name for the task.

std::string
Gc_process_relocs::get_name() const
{
  return "Gc_process_relocs " + this->object_->name();
}

// Scan_relocs methods.

Scan_relocs::~Scan_relocs()
{
  if (this->this_blocker_ != NULL)
    delete this->this_blocker_;
}

// These tasks scan the relocations read by Read_relocs and mark up
// the symbol table to indicate which relocations are required.  We
// use a lock on the symbol table to keep them from interfering with
// each other.

Task_token*
Scan_relocs::is_runnable()
{
  if (this->this_blocker_ != NULL && this->this_blocker_->is_blocked())
    return this->this_blocker_;
  if (this->object_->is_locked())
    return this->object_->token();
  return NULL;
}

// Return the locks we hold: one on the file, one on the symbol table
// and one blocker.

void
Scan_relocs::locks(Task_locker* tl)
{
  Task_token* token = this->object_->token();
  if (token != NULL)
    tl->add(this, token);
  tl->add(this, this->next_blocker_);
}

// Scan the relocs.

void
Scan_relocs::run(Workqueue*)
{
  this->object_->scan_relocs(this->symtab_, this->layout_, this->rd_);
  delete this->rd_;
  this->rd_ = NULL;
  this->object_->release();
}

// Return a debugging name for the task.

std::string
Scan_relocs::get_name() const
{
  return "Scan_relocs " + this->object_->name();
}

// Relocate_task methods.

// We may have to wait for the output sections to be written.

Task_token*
Relocate_task::is_runnable()
{
  if (this->object_->relocs_must_follow_section_writes()
      && this->output_sections_blocker_->is_blocked())
    return this->output_sections_blocker_;

  if (this->object_->is_locked())
    return this->object_->token();

  return NULL;
}

// We want to lock the file while we run.  We want to unblock
// INPUT_SECTIONS_BLOCKER and FINAL_BLOCKER when we are done.
// INPUT_SECTIONS_BLOCKER may be NULL.

void
Relocate_task::locks(Task_locker* tl)
{
  if (this->input_sections_blocker_ != NULL)
    tl->add(this, this->input_sections_blocker_);
  tl->add(this, this->final_blocker_);
  Task_token* token = this->object_->token();
  if (token != NULL)
    tl->add(this, token);
}

// Run the task.

void
Relocate_task::run(Workqueue*)
{
  this->object_->relocate(this->symtab_, this->layout_, this->of_);

  // This is normally the last thing we will do with an object, so
  // uncache all views.
  this->object_->clear_view_cache_marks();

  this->object_->release();
}

// Return a debugging name for the task.

std::string
Relocate_task::get_name() const
{
  return "Relocate_task " + this->object_->name();
}

// Read the relocs and local symbols from the object file and store
// the information in RD.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_read_relocs(Read_relocs_data* rd)
{
  rd->relocs.clear();

  unsigned int shnum = this->shnum();
  if (shnum == 0)
    return;

  rd->relocs.reserve(shnum / 2);

  const Output_sections& out_sections(this->output_sections());
  const std::vector<Address>& out_offsets(this->section_offsets());

  const unsigned char* pshdrs = this->get_view(this->elf_file_.shoff(),
					       shnum * This::shdr_size,
					       true, true);
  // Skip the first, dummy, section.
  const unsigned char* ps = pshdrs + This::shdr_size;
  for (unsigned int i = 1; i < shnum; ++i, ps += This::shdr_size)
    {
      typename This::Shdr shdr(ps);

      unsigned int sh_type = shdr.get_sh_type();
      if (sh_type != elfcpp::SHT_REL && sh_type != elfcpp::SHT_RELA)
	continue;

      unsigned int shndx = this->adjust_shndx(shdr.get_sh_info());
      if (shndx >= shnum)
	{
	  this->error(_("relocation section %u has bad info %u"),
		      i, shndx);
	  continue;
	}

      Output_section* os = out_sections[shndx];
      if (os == NULL)
	continue;

      // We are scanning relocations in order to fill out the GOT and
      // PLT sections.  Relocations for sections which are not
      // allocated (typically debugging sections) should not add new
      // GOT and PLT entries.  So we skip them unless this is a
      // relocatable link or we need to emit relocations.  FIXME: What
      // should we do if a linker script maps a section with SHF_ALLOC
      // clear to a section with SHF_ALLOC set?
      typename This::Shdr secshdr(pshdrs + shndx * This::shdr_size);
      bool is_section_allocated = ((secshdr.get_sh_flags() & elfcpp::SHF_ALLOC)
				   != 0);
      if (!is_section_allocated
	  && !parameters->options().relocatable()
	  && !parameters->options().emit_relocs()
	  && !parameters->incremental())
	continue;

      if (this->adjust_shndx(shdr.get_sh_link()) != this->symtab_shndx_)
	{
	  this->error(_("relocation section %u uses unexpected "
			"symbol table %u"),
		      i, this->adjust_shndx(shdr.get_sh_link()));
	  continue;
	}

      off_t sh_size = shdr.get_sh_size();

      if (sh_size == 0)
	continue;

      unsigned int reloc_size;
      if (sh_type == elfcpp::SHT_REL)
	reloc_size = elfcpp::Elf_sizes<size>::rel_size;
      else
	reloc_size = elfcpp::Elf_sizes<size>::rela_size;
      if (reloc_size != shdr.get_sh_entsize())
	{
	  this->error(_("unexpected entsize for reloc section %u: %lu != %u"),
		      i, static_cast<unsigned long>(shdr.get_sh_entsize()),
		      reloc_size);
	  continue;
	}

      size_t reloc_count = sh_size / reloc_size;
      if (static_cast<off_t>(reloc_count * reloc_size) != sh_size)
	{
	  this->error(_("reloc section %u size %lu uneven"),
		      i, static_cast<unsigned long>(sh_size));
	  continue;
	}

      rd->relocs.push_back(Section_relocs());
      Section_relocs& sr(rd->relocs.back());
      sr.reloc_shndx = i;
      sr.data_shndx = shndx;
      sr.contents = this->get_lasting_view(shdr.get_sh_offset(), sh_size,
					   true, true);
      sr.sh_type = sh_type;
      sr.reloc_count = reloc_count;
      sr.output_section = os;
      sr.needs_special_offset_handling = out_offsets[shndx] == invalid_address;
      sr.is_data_section_allocated = is_section_allocated;
    }

  // Read the local symbols.
  gold_assert(this->symtab_shndx_ != -1U);
  if (this->symtab_shndx_ == 0 || this->local_symbol_count_ == 0)
    rd->local_symbols = NULL;
  else
    {
      typename This::Shdr symtabshdr(pshdrs
				     + this->symtab_shndx_ * This::shdr_size);
      gold_assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);
      const int sym_size = This::sym_size;
      const unsigned int loccount = this->local_symbol_count_;
      gold_assert(loccount == symtabshdr.get_sh_info());
      off_t locsize = loccount * sym_size;
      rd->local_symbols = this->get_lasting_view(symtabshdr.get_sh_offset(),
						 locsize, true, true);
    }
}

// Process the relocs to generate mappings from source sections to referenced
// sections.  This is used during garbage collection to determine garbage
// sections.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_gc_process_relocs(Symbol_table* symtab,
							  Layout* layout,
							  Read_relocs_data* rd)
{  
  Sized_target<size, big_endian>* target =
    parameters->sized_target<size, big_endian>();

  const unsigned char* local_symbols;
  if (rd->local_symbols == NULL)
    local_symbols = NULL;
  else
    local_symbols = rd->local_symbols->data();

  for (Read_relocs_data::Relocs_list::iterator p = rd->relocs.begin();
       p != rd->relocs.end();
       ++p)
    {
      if (!parameters->options().relocatable())
	  {
	    // As noted above, when not generating an object file, we
	    // only scan allocated sections.  We may see a non-allocated
	    // section here if we are emitting relocs.
	    if (p->is_data_section_allocated)
              target->gc_process_relocs(symtab, layout, this, 
                                        p->data_shndx, p->sh_type, 
                                        p->contents->data(), p->reloc_count, 
                                        p->output_section,
                                        p->needs_special_offset_handling,
                                        this->local_symbol_count_, 
                                        local_symbols);
        }
    }
}


// Scan the relocs and adjust the symbol table.  This looks for
// relocations which require GOT/PLT/COPY relocations.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_scan_relocs(Symbol_table* symtab,
					       Layout* layout,
					       Read_relocs_data* rd)
{
  Sized_target<size, big_endian>* target =
    parameters->sized_target<size, big_endian>();

  const unsigned char* local_symbols;
  if (rd->local_symbols == NULL)
    local_symbols = NULL;
  else
    local_symbols = rd->local_symbols->data();

  // For incremental links, allocate the counters for incremental relocations.
  if (layout->incremental_inputs() != NULL)
    this->allocate_incremental_reloc_counts();

  for (Read_relocs_data::Relocs_list::iterator p = rd->relocs.begin();
       p != rd->relocs.end();
       ++p)
    {
      // When garbage collection is on, unreferenced sections are not included
      // in the link that would have been included normally. This is known only
      // after Read_relocs hence this check has to be done again.
      if (parameters->options().gc_sections()
	  || parameters->options().icf_enabled())
        {
          if (p->output_section == NULL)
            continue;
        }
      if (!parameters->options().relocatable())
	{
	  // As noted above, when not generating an object file, we
	  // only scan allocated sections.  We may see a non-allocated
	  // section here if we are emitting relocs.
	  if (p->is_data_section_allocated)
	    target->scan_relocs(symtab, layout, this, p->data_shndx,
				p->sh_type, p->contents->data(),
				p->reloc_count, p->output_section,
				p->needs_special_offset_handling,
				this->local_symbol_count_,
				local_symbols);
	  if (parameters->options().emit_relocs())
	    this->emit_relocs_scan(symtab, layout, local_symbols, p);
	  if (layout->incremental_inputs() != NULL)
	    this->incremental_relocs_scan(p);
	}
      else
	{
	  Relocatable_relocs* rr = this->relocatable_relocs(p->reloc_shndx);
	  gold_assert(rr != NULL);
	  rr->set_reloc_count(p->reloc_count);
	  target->scan_relocatable_relocs(symtab, layout, this,
					  p->data_shndx, p->sh_type,
					  p->contents->data(),
					  p->reloc_count,
					  p->output_section,
					  p->needs_special_offset_handling,
					  this->local_symbol_count_,
					  local_symbols,
					  rr);
	}

      delete p->contents;
      p->contents = NULL;
    }

  // For incremental links, finalize the allocation of relocations.
  if (layout->incremental_inputs() != NULL)
    this->finalize_incremental_relocs(layout, true);

  if (rd->local_symbols != NULL)
    {
      delete rd->local_symbols;
      rd->local_symbols = NULL;
    }
}

// This is a strategy class we use when scanning for --emit-relocs.

template<int sh_type>
class Emit_relocs_strategy
{
 public:
  // A local non-section symbol.
  inline Relocatable_relocs::Reloc_strategy
  local_non_section_strategy(unsigned int, Relobj*, unsigned int)
  { return Relocatable_relocs::RELOC_COPY; }

  // A local section symbol.
  inline Relocatable_relocs::Reloc_strategy
  local_section_strategy(unsigned int, Relobj*)
  {
    if (sh_type == elfcpp::SHT_RELA)
      return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_RELA;
    else
      {
	// The addend is stored in the section contents.  Since this
	// is not a relocatable link, we are going to apply the
	// relocation contents to the section as usual.  This means
	// that we have no way to record the original addend.  If the
	// original addend is not zero, there is basically no way for
	// the user to handle this correctly.  Caveat emptor.
	return Relocatable_relocs::RELOC_ADJUST_FOR_SECTION_0;
      }
  }

  // A global symbol.
  inline Relocatable_relocs::Reloc_strategy
  global_strategy(unsigned int, Relobj*, unsigned int)
  { return Relocatable_relocs::RELOC_COPY; }
};

// Scan the input relocations for --emit-relocs.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::emit_relocs_scan(
    Symbol_table* symtab,
    Layout* layout,
    const unsigned char* plocal_syms,
    const Read_relocs_data::Relocs_list::iterator& p)
{
  Relocatable_relocs* rr = this->relocatable_relocs(p->reloc_shndx);
  gold_assert(rr != NULL);
  rr->set_reloc_count(p->reloc_count);

  if (p->sh_type == elfcpp::SHT_REL)
    this->emit_relocs_scan_reltype<elfcpp::SHT_REL>(symtab, layout,
						    plocal_syms, p, rr);
  else
    {
      gold_assert(p->sh_type == elfcpp::SHT_RELA);
      this->emit_relocs_scan_reltype<elfcpp::SHT_RELA>(symtab, layout,
						       plocal_syms, p, rr);
    }
}

// Scan the input relocation for --emit-relocs, templatized on the
// type of the relocation section.

template<int size, bool big_endian>
template<int sh_type>
void
Sized_relobj_file<size, big_endian>::emit_relocs_scan_reltype(
    Symbol_table* symtab,
    Layout* layout,
    const unsigned char* plocal_syms,
    const Read_relocs_data::Relocs_list::iterator& p,
    Relocatable_relocs* rr)
{
  scan_relocatable_relocs<size, big_endian, sh_type,
			  Emit_relocs_strategy<sh_type> >(
    symtab,
    layout,
    this,
    p->data_shndx,
    p->contents->data(),
    p->reloc_count,
    p->output_section,
    p->needs_special_offset_handling,
    this->local_symbol_count_,
    plocal_syms,
    rr);
}

// Scan the input relocations for --incremental.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::incremental_relocs_scan(
    const Read_relocs_data::Relocs_list::iterator& p)
{
  if (p->sh_type == elfcpp::SHT_REL)
    this->incremental_relocs_scan_reltype<elfcpp::SHT_REL>(p);
  else
    {
      gold_assert(p->sh_type == elfcpp::SHT_RELA);
      this->incremental_relocs_scan_reltype<elfcpp::SHT_RELA>(p);
    }
}

// Scan the input relocation for --incremental, templatized on the
// type of the relocation section.

template<int size, bool big_endian>
template<int sh_type>
void
Sized_relobj_file<size, big_endian>::incremental_relocs_scan_reltype(
    const Read_relocs_data::Relocs_list::iterator& p)
{
  typedef typename Reloc_types<sh_type, size, big_endian>::Reloc Reltype;
  const int reloc_size = Reloc_types<sh_type, size, big_endian>::reloc_size;
  const unsigned char* prelocs = p->contents->data();
  size_t reloc_count = p->reloc_count;

  for (size_t i = 0; i < reloc_count; ++i, prelocs += reloc_size)
    {
      Reltype reloc(prelocs);

      if (p->needs_special_offset_handling
	  && !p->output_section->is_input_address_mapped(this, p->data_shndx,
						         reloc.get_r_offset()))
	continue;

      typename elfcpp::Elf_types<size>::Elf_WXword r_info =
	  reloc.get_r_info();
      const unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);

      if (r_sym >= this->local_symbol_count_)
	this->count_incremental_reloc(r_sym - this->local_symbol_count_);
    }
}

// Relocate the input sections and write out the local symbols.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_relocate(const Symbol_table* symtab,
						 const Layout* layout,
						 Output_file* of)
{
  unsigned int shnum = this->shnum();

  // Read the section headers.
  const unsigned char* pshdrs = this->get_view(this->elf_file_.shoff(),
					       shnum * This::shdr_size,
					       true, true);

  Views views;
  views.resize(shnum);

  // Make two passes over the sections.  The first one copies the
  // section data to the output file.  The second one applies
  // relocations.

  this->write_sections(layout, pshdrs, of, &views);

  // To speed up relocations, we set up hash tables for fast lookup of
  // input offsets to output addresses.
  this->initialize_input_to_output_maps();

  // Apply relocations.

  this->relocate_sections(symtab, layout, pshdrs, of, &views);

  // After we've done the relocations, we release the hash tables,
  // since we no longer need them.
  this->free_input_to_output_maps();

  // Write out the accumulated views.
  for (unsigned int i = 1; i < shnum; ++i)
    {
      if (views[i].view != NULL)
	{
	  if (views[i].is_ctors_reverse_view)
	    this->reverse_words(views[i].view, views[i].view_size);
	  if (!views[i].is_postprocessing_view)
	    {
	      if (views[i].is_input_output_view)
		of->write_input_output_view(views[i].offset,
					    views[i].view_size,
					    views[i].view);
	      else
		of->write_output_view(views[i].offset, views[i].view_size,
				      views[i].view);
	    }
	}
    }

  // Write out the local symbols.
  this->write_local_symbols(of, layout->sympool(), layout->dynpool(),
			    layout->symtab_xindex(), layout->dynsym_xindex(),
			    layout->symtab_section_offset());
}

// Sort a Read_multiple vector by file offset.
struct Read_multiple_compare
{
  inline bool
  operator()(const File_read::Read_multiple_entry& rme1,
	     const File_read::Read_multiple_entry& rme2) const
  { return rme1.file_offset < rme2.file_offset; }
};

// Write section data to the output file.  PSHDRS points to the
// section headers.  Record the views in *PVIEWS for use when
// relocating.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::write_sections(const Layout* layout,
						    const unsigned char* pshdrs,
						    Output_file* of,
						    Views* pviews)
{
  unsigned int shnum = this->shnum();
  const Output_sections& out_sections(this->output_sections());
  const std::vector<Address>& out_offsets(this->section_offsets());

  File_read::Read_multiple rm;
  bool is_sorted = true;

  const unsigned char* p = pshdrs + This::shdr_size;
  for (unsigned int i = 1; i < shnum; ++i, p += This::shdr_size)
    {
      View_size* pvs = &(*pviews)[i];

      pvs->view = NULL;

      const Output_section* os = out_sections[i];
      if (os == NULL)
	continue;
      Address output_offset = out_offsets[i];

      typename This::Shdr shdr(p);

      if (shdr.get_sh_type() == elfcpp::SHT_NOBITS)
	continue;

      if ((parameters->options().relocatable()
	   || parameters->options().emit_relocs())
	  && (shdr.get_sh_type() == elfcpp::SHT_REL
	      || shdr.get_sh_type() == elfcpp::SHT_RELA)
	  && (shdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0)
	{
	  // This is a reloc section in a relocatable link or when
	  // emitting relocs.  We don't need to read the input file.
	  // The size and file offset are stored in the
	  // Relocatable_relocs structure.
	  Relocatable_relocs* rr = this->relocatable_relocs(i);
	  gold_assert(rr != NULL);
	  Output_data* posd = rr->output_data();
	  gold_assert(posd != NULL);

	  pvs->offset = posd->offset();
	  pvs->view_size = posd->data_size();
	  pvs->view = of->get_output_view(pvs->offset, pvs->view_size);
	  pvs->address = posd->address();
	  pvs->is_input_output_view = false;
	  pvs->is_postprocessing_view = false;
	  pvs->is_ctors_reverse_view = false;

	  continue;
	}

      // In the normal case, this input section is simply mapped to
      // the output section at offset OUTPUT_OFFSET.

      // However, if OUTPUT_OFFSET == INVALID_ADDRESS, then input data is
      // handled specially--e.g., a .eh_frame section.  The relocation
      // routines need to check for each reloc where it should be
      // applied.  For this case, we need an input/output view for the
      // entire contents of the section in the output file.  We don't
      // want to copy the contents of the input section to the output
      // section; the output section contents were already written,
      // and we waited for them in Relocate_task::is_runnable because
      // relocs_must_follow_section_writes is set for the object.

      // Regardless of which of the above cases is true, we have to
      // check requires_postprocessing of the output section.  If that
      // is false, then we work with views of the output file
      // directly.  If it is true, then we work with a separate
      // buffer, and the output section is responsible for writing the
      // final data to the output file.

      off_t output_section_offset;
      Address output_section_size;
      if (!os->requires_postprocessing())
	{
	  output_section_offset = os->offset();
	  output_section_size = convert_types<Address, off_t>(os->data_size());
	}
      else
	{
	  output_section_offset = 0;
	  output_section_size =
              convert_types<Address, off_t>(os->postprocessing_buffer_size());
	}

      off_t view_start;
      section_size_type view_size;
      bool must_decompress = false;
      if (output_offset != invalid_address)
	{
	  view_start = output_section_offset + output_offset;
	  view_size = convert_to_section_size_type(shdr.get_sh_size());
	  section_size_type uncompressed_size;
	  if (this->section_is_compressed(i, &uncompressed_size))
	    {
	      view_size = uncompressed_size;
	      must_decompress = true;
	    }
	}
      else
	{
	  view_start = output_section_offset;
	  view_size = convert_to_section_size_type(output_section_size);
	}

      if (view_size == 0)
	continue;

      gold_assert(output_offset == invalid_address
		  || output_offset + view_size <= output_section_size);

      unsigned char* view;
      if (os->requires_postprocessing())
	{
	  unsigned char* buffer = os->postprocessing_buffer();
	  view = buffer + view_start;
	  if (output_offset != invalid_address && !must_decompress)
	    {
	      off_t sh_offset = shdr.get_sh_offset();
	      if (!rm.empty() && rm.back().file_offset > sh_offset)
		is_sorted = false;
	      rm.push_back(File_read::Read_multiple_entry(sh_offset,
							  view_size, view));
	    }
	}
      else
	{
	  if (output_offset == invalid_address)
	    view = of->get_input_output_view(view_start, view_size);
	  else
	    {
	      view = of->get_output_view(view_start, view_size);
	      if (!must_decompress)
		{
		  off_t sh_offset = shdr.get_sh_offset();
		  if (!rm.empty() && rm.back().file_offset > sh_offset)
		    is_sorted = false;
		  rm.push_back(File_read::Read_multiple_entry(sh_offset,
							      view_size, view));
		}
	    }
	}

      if (must_decompress)
        {
	  // Read and decompress the section.
          section_size_type len;
	  const unsigned char* p = this->section_contents(i, &len, false);
	  if (!decompress_input_section(p, len, view, view_size))
	    this->error(_("could not decompress section %s"),
			this->section_name(i).c_str());
        }

      pvs->view = view;
      pvs->address = os->address();
      if (output_offset != invalid_address)
	pvs->address += output_offset;
      pvs->offset = view_start;
      pvs->view_size = view_size;
      pvs->is_input_output_view = output_offset == invalid_address;
      pvs->is_postprocessing_view = os->requires_postprocessing();
      pvs->is_ctors_reverse_view =
	(!parameters->options().relocatable()
	 && view_size > size / 8
	 && (strcmp(os->name(), ".init_array") == 0
	     || strcmp(os->name(), ".fini_array") == 0)
	 && layout->is_ctors_in_init_array(this, i));
    }

  // Actually read the data.
  if (!rm.empty())
    {
      if (!is_sorted)
	std::sort(rm.begin(), rm.end(), Read_multiple_compare());
      this->read_multiple(rm);
    }
}

// Relocate section data.  VIEWS points to the section data as views
// in the output file.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::do_relocate_sections(
    const Symbol_table* symtab,
    const Layout* layout,
    const unsigned char* pshdrs,
    Output_file* of,
    Views* pviews)
{
  unsigned int shnum = this->shnum();
  Sized_target<size, big_endian>* target =
    parameters->sized_target<size, big_endian>();

  const Output_sections& out_sections(this->output_sections());
  const std::vector<Address>& out_offsets(this->section_offsets());

  Relocate_info<size, big_endian> relinfo;
  relinfo.symtab = symtab;
  relinfo.layout = layout;
  relinfo.object = this;

  const unsigned char* p = pshdrs + This::shdr_size;
  for (unsigned int i = 1; i < shnum; ++i, p += This::shdr_size)
    {
      typename This::Shdr shdr(p);

      unsigned int sh_type = shdr.get_sh_type();
      if (sh_type != elfcpp::SHT_REL && sh_type != elfcpp::SHT_RELA)
	continue;

      off_t sh_size = shdr.get_sh_size();
      if (sh_size == 0)
	continue;

      unsigned int index = this->adjust_shndx(shdr.get_sh_info());
      if (index >= this->shnum())
	{
	  this->error(_("relocation section %u has bad info %u"),
		      i, index);
	  continue;
	}

      Output_section* os = out_sections[index];
      if (os == NULL)
	{
	  // This relocation section is against a section which we
	  // discarded.
	  continue;
	}
      Address output_offset = out_offsets[index];

      gold_assert((*pviews)[index].view != NULL);
      if (parameters->options().relocatable())
	gold_assert((*pviews)[i].view != NULL);

      if (this->adjust_shndx(shdr.get_sh_link()) != this->symtab_shndx_)
	{
	  gold_error(_("relocation section %u uses unexpected "
		       "symbol table %u"),
		     i, this->adjust_shndx(shdr.get_sh_link()));
	  continue;
	}

      const unsigned char* prelocs = this->get_view(shdr.get_sh_offset(),
						    sh_size, true, false);

      unsigned int reloc_size;
      if (sh_type == elfcpp::SHT_REL)
	reloc_size = elfcpp::Elf_sizes<size>::rel_size;
      else
	reloc_size = elfcpp::Elf_sizes<size>::rela_size;

      if (reloc_size != shdr.get_sh_entsize())
	{
	  gold_error(_("unexpected entsize for reloc section %u: %lu != %u"),
		     i, static_cast<unsigned long>(shdr.get_sh_entsize()),
		     reloc_size);
	  continue;
	}

      size_t reloc_count = sh_size / reloc_size;
      if (static_cast<off_t>(reloc_count * reloc_size) != sh_size)
	{
	  gold_error(_("reloc section %u size %lu uneven"),
		     i, static_cast<unsigned long>(sh_size));
	  continue;
	}

      gold_assert(output_offset != invalid_address
		  || this->relocs_must_follow_section_writes());

      relinfo.reloc_shndx = i;
      relinfo.reloc_shdr = p;
      relinfo.data_shndx = index;
      relinfo.data_shdr = pshdrs + index * This::shdr_size;
      unsigned char* view = (*pviews)[index].view;
      Address address = (*pviews)[index].address;
      section_size_type view_size = (*pviews)[index].view_size;

      Reloc_symbol_changes* reloc_map = NULL;
      if (this->uses_split_stack() && output_offset != invalid_address)
	{
	  typename This::Shdr data_shdr(pshdrs + index * This::shdr_size);
	  if ((data_shdr.get_sh_flags() & elfcpp::SHF_EXECINSTR) != 0)
	    this->split_stack_adjust(symtab, pshdrs, sh_type, index,
				     prelocs, reloc_count, view, view_size,
				     &reloc_map);
	}

      if (!parameters->options().relocatable())
	{
	  target->relocate_section(&relinfo, sh_type, prelocs, reloc_count, os,
				   output_offset == invalid_address,
				   view, address, view_size, reloc_map);
	  if (parameters->options().emit_relocs())
	    {
	      Relocatable_relocs* rr = this->relocatable_relocs(i);
	      target->relocate_relocs(&relinfo, sh_type, prelocs, reloc_count,
				      os, output_offset, rr,
				      view, address, view_size,
				      (*pviews)[i].view,
				      (*pviews)[i].view_size);
	    }
	  if (parameters->incremental())
	    this->incremental_relocs_write(&relinfo, sh_type, prelocs,
					   reloc_count, os, output_offset, of);
	}
      else
	{
	  Relocatable_relocs* rr = this->relocatable_relocs(i);
	  target->relocate_relocs(&relinfo, sh_type, prelocs, reloc_count,
				  os, output_offset, rr,
				  view, address, view_size,
				  (*pviews)[i].view,
				  (*pviews)[i].view_size);
	}
    }
}

// Write the incremental relocs.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::incremental_relocs_write(
    const Relocate_info<size, big_endian>* relinfo,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    Address output_offset,
    Output_file* of)
{
  if (sh_type == elfcpp::SHT_REL)
    this->incremental_relocs_write_reltype<elfcpp::SHT_REL>(
	relinfo,
	prelocs,
	reloc_count,
	output_section,
	output_offset,
	of);
  else
    {
      gold_assert(sh_type == elfcpp::SHT_RELA);
      this->incremental_relocs_write_reltype<elfcpp::SHT_RELA>(
	  relinfo,
	  prelocs,
	  reloc_count,
	  output_section,
	  output_offset,
	  of);
    }
}

// Write the incremental relocs, templatized on the type of the
// relocation section.

template<int size, bool big_endian>
template<int sh_type>
void
Sized_relobj_file<size, big_endian>::incremental_relocs_write_reltype(
    const Relocate_info<size, big_endian>* relinfo,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    Address output_offset,
    Output_file* of)
{
  typedef typename Reloc_types<sh_type, size, big_endian>::Reloc Reloc;
  const unsigned int reloc_size =
      Reloc_types<sh_type, size, big_endian>::reloc_size;
  const unsigned int sizeof_addr = size / 8;
  const unsigned int incr_reloc_size =
      Incremental_relocs_reader<size, big_endian>::reloc_size;

  unsigned int out_shndx = output_section->out_shndx();

  // Get a view for the .gnu_incremental_relocs section.

  Incremental_inputs* inputs = relinfo->layout->incremental_inputs();
  gold_assert(inputs != NULL);
  const off_t relocs_off = inputs->relocs_section()->offset();
  const off_t relocs_size = inputs->relocs_section()->data_size();
  unsigned char* const view = of->get_output_view(relocs_off, relocs_size);

  for (size_t i = 0; i < reloc_count; ++i, prelocs += reloc_size)
    {
      Reloc reloc(prelocs);

      typename elfcpp::Elf_types<size>::Elf_WXword r_info = reloc.get_r_info();
      const unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);
      const unsigned int r_type = elfcpp::elf_r_type<size>(r_info);

      if (r_sym < this->local_symbol_count_)
        continue;

      // Get the new offset--the location in the output section where
      // this relocation should be applied.

      Address offset = reloc.get_r_offset();
      if (output_offset != invalid_address)
	offset += output_offset;
      else
	{
          section_offset_type sot_offset =
              convert_types<section_offset_type, Address>(offset);
	  section_offset_type new_sot_offset =
	      output_section->output_offset(relinfo->object,
					    relinfo->data_shndx,
					    sot_offset);
	  gold_assert(new_sot_offset != -1);
	  offset += new_sot_offset;
	}

      // Get the addend.
      typename elfcpp::Elf_types<size>::Elf_Swxword addend;
      if (sh_type == elfcpp::SHT_RELA)
	addend =
	    Reloc_types<sh_type, size, big_endian>::get_reloc_addend(&reloc);
      else
        {
          // FIXME: Get the addend for SHT_REL.
          addend = 0;
        }

      // Get the index of the output relocation.

      unsigned int reloc_index =
          this->next_incremental_reloc_index(r_sym - this->local_symbol_count_);

      // Write the relocation.

      unsigned char* pov = view + reloc_index * incr_reloc_size;
      elfcpp::Swap<32, big_endian>::writeval(pov, r_type);
      elfcpp::Swap<32, big_endian>::writeval(pov + 4, out_shndx);
      elfcpp::Swap<size, big_endian>::writeval(pov + 8, offset);
      elfcpp::Swap<size, big_endian>::writeval(pov + 8 + sizeof_addr, addend);
      of->write_output_view(pov - view, incr_reloc_size, view);
    }
}

// Create merge hash tables for the local symbols.  These are used to
// speed up relocations.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::initialize_input_to_output_maps()
{
  const unsigned int loccount = this->local_symbol_count_;
  for (unsigned int i = 1; i < loccount; ++i)
    {
      Symbol_value<size>& lv(this->local_values_[i]);
      lv.initialize_input_to_output_map(this);
    }
}

// Free merge hash tables for the local symbols.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::free_input_to_output_maps()
{
  const unsigned int loccount = this->local_symbol_count_;
  for (unsigned int i = 1; i < loccount; ++i)
    {
      Symbol_value<size>& lv(this->local_values_[i]);
      lv.free_input_to_output_map();
    }
}

// If an object was compiled with -fsplit-stack, this is called to
// check whether any relocations refer to functions defined in objects
// which were not compiled with -fsplit-stack.  If they were, then we
// need to apply some target-specific adjustments to request
// additional stack space.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::split_stack_adjust(
    const Symbol_table* symtab,
    const unsigned char* pshdrs,
    unsigned int sh_type,
    unsigned int shndx,
    const unsigned char* prelocs,
    size_t reloc_count,
    unsigned char* view,
    section_size_type view_size,
    Reloc_symbol_changes** reloc_map)
{
  if (sh_type == elfcpp::SHT_REL)
    this->split_stack_adjust_reltype<elfcpp::SHT_REL>(symtab, pshdrs, shndx,
						      prelocs, reloc_count,
						      view, view_size,
						      reloc_map);
  else
    {
      gold_assert(sh_type == elfcpp::SHT_RELA);
      this->split_stack_adjust_reltype<elfcpp::SHT_RELA>(symtab, pshdrs, shndx,
							 prelocs, reloc_count,
							 view, view_size,
							 reloc_map);
    }
}

// Adjust for -fsplit-stack, templatized on the type of the relocation
// section.

template<int size, bool big_endian>
template<int sh_type>
void
Sized_relobj_file<size, big_endian>::split_stack_adjust_reltype(
    const Symbol_table* symtab,
    const unsigned char* pshdrs,
    unsigned int shndx,
    const unsigned char* prelocs,
    size_t reloc_count,
    unsigned char* view,
    section_size_type view_size,
    Reloc_symbol_changes** reloc_map)
{
  typedef typename Reloc_types<sh_type, size, big_endian>::Reloc Reltype;
  const int reloc_size = Reloc_types<sh_type, size, big_endian>::reloc_size;

  size_t local_count = this->local_symbol_count();

  std::vector<section_offset_type> non_split_refs;

  const unsigned char* pr = prelocs;
  for (size_t i = 0; i < reloc_count; ++i, pr += reloc_size)
    {
      Reltype reloc(pr);

      typename elfcpp::Elf_types<size>::Elf_WXword r_info = reloc.get_r_info();
      unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);
      if (r_sym < local_count)
	continue;

      const Symbol* gsym = this->global_symbol(r_sym);
      gold_assert(gsym != NULL);
      if (gsym->is_forwarder())
	gsym = symtab->resolve_forwards(gsym);

      // See if this relocation refers to a function defined in an
      // object compiled without -fsplit-stack.  Note that we don't
      // care about the type of relocation--this means that in some
      // cases we will ask for a large stack unnecessarily, but this
      // is not fatal.  FIXME: Some targets have symbols which are
      // functions but are not type STT_FUNC, e.g., STT_ARM_TFUNC.
      if (!gsym->is_undefined()
	  && gsym->source() == Symbol::FROM_OBJECT
	  && !gsym->object()->uses_split_stack())
	{
	  unsigned int r_type = elfcpp::elf_r_type<size>(reloc.get_r_info());
	  if (parameters->target().is_call_to_non_split(gsym, r_type))
	    {
	      section_offset_type offset =
		convert_to_section_size_type(reloc.get_r_offset());
	      non_split_refs.push_back(offset);
	    }
	}
    }

  if (non_split_refs.empty())
    return;

  // At this point, every entry in NON_SPLIT_REFS indicates a
  // relocation which refers to a function in an object compiled
  // without -fsplit-stack.  We now have to convert that list into a
  // set of offsets to functions.  First, we find all the functions.

  Function_offsets function_offsets;
  this->find_functions(pshdrs, shndx, &function_offsets);
  if (function_offsets.empty())
    return;

  // Now get a list of the function with references to non split-stack
  // code.

  Function_offsets calls_non_split;
  for (std::vector<section_offset_type>::const_iterator p
	 = non_split_refs.begin();
       p != non_split_refs.end();
       ++p)
    {
      Function_offsets::const_iterator low = function_offsets.lower_bound(*p);
      if (low == function_offsets.end())
	--low;
      else if (low->first == *p)
	;
      else if (low == function_offsets.begin())
	continue;
      else
	--low;

      calls_non_split.insert(*low);
    }
  if (calls_non_split.empty())
    return;

  // Now we have a set of functions to adjust.  The adjustments are
  // target specific.  Besides changing the output section view
  // however, it likes, the target may request a relocation change
  // from one global symbol name to another.

  for (Function_offsets::const_iterator p = calls_non_split.begin();
       p != calls_non_split.end();
       ++p)
    {
      std::string from;
      std::string to;
      parameters->target().calls_non_split(this, shndx, p->first, p->second,
					   view, view_size, &from, &to);
      if (!from.empty())
	{
	  gold_assert(!to.empty());
	  Symbol* tosym = NULL;

	  // Find relocations in the relevant function which are for
	  // FROM.
	  pr = prelocs;
	  for (size_t i = 0; i < reloc_count; ++i, pr += reloc_size)
	    {
	      Reltype reloc(pr);

	      typename elfcpp::Elf_types<size>::Elf_WXword r_info =
		reloc.get_r_info();
	      unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);
	      if (r_sym < local_count)
		continue;

	      section_offset_type offset =
		convert_to_section_size_type(reloc.get_r_offset());
	      if (offset < p->first
		  || (offset
		      >= (p->first
			  + static_cast<section_offset_type>(p->second))))
		continue;

	      const Symbol* gsym = this->global_symbol(r_sym);
	      if (from == gsym->name())
		{
		  if (tosym == NULL)
		    {
		      tosym = symtab->lookup(to.c_str());
		      if (tosym == NULL)
			{
			  this->error(_("could not convert call "
					"to '%s' to '%s'"),
				      from.c_str(), to.c_str());
			  break;
			}
		    }

		  if (*reloc_map == NULL)
		    *reloc_map = new Reloc_symbol_changes(reloc_count);
		  (*reloc_map)->set(i, tosym);
		}
	    }
	}
    }
}

// Find all the function in this object defined in section SHNDX.
// Store their offsets in the section in FUNCTION_OFFSETS.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::find_functions(
    const unsigned char* pshdrs,
    unsigned int shndx,
    Sized_relobj_file<size, big_endian>::Function_offsets* function_offsets)
{
  // We need to read the symbols to find the functions.  If we wanted
  // to, we could cache reading the symbols across all sections in the
  // object.
  const unsigned int symtab_shndx = this->symtab_shndx_;
  typename This::Shdr symtabshdr(pshdrs + symtab_shndx * This::shdr_size);
  gold_assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);

  typename elfcpp::Elf_types<size>::Elf_WXword sh_size =
    symtabshdr.get_sh_size();
  const unsigned char* psyms = this->get_view(symtabshdr.get_sh_offset(),
					      sh_size, true, true);

  const int sym_size = This::sym_size;
  const unsigned int symcount = sh_size / sym_size;
  for (unsigned int i = 0; i < symcount; ++i, psyms += sym_size)
    {
      typename elfcpp::Sym<size, big_endian> isym(psyms);

      // FIXME: Some targets can have functions which do not have type
      // STT_FUNC, e.g., STT_ARM_TFUNC.
      if (isym.get_st_type() != elfcpp::STT_FUNC
	  || isym.get_st_size() == 0)
	continue;

      bool is_ordinary;
      unsigned int sym_shndx = this->adjust_sym_shndx(i, isym.get_st_shndx(),
						      &is_ordinary);
      if (!is_ordinary || sym_shndx != shndx)
	continue;

      section_offset_type value =
	convert_to_section_size_type(isym.get_st_value());
      section_size_type fnsize =
	convert_to_section_size_type(isym.get_st_size());

      (*function_offsets)[value] = fnsize;
    }
}

// Reverse the words in a section.  Used for .ctors sections mapped to
// .init_array sections.  See ctors_sections_in_init_array in
// layout.cc.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::reverse_words(unsigned char* view,
						   section_size_type view_size)
{
  typedef typename elfcpp::Swap<size, big_endian>::Valtype Valtype;
  Valtype* vview = reinterpret_cast<Valtype*>(view);
  section_size_type vview_size = view_size / (size / 8);
  for (section_size_type i = 0; i < vview_size / 2; ++i)
    {
      Valtype tmp = vview[i];
      vview[i] = vview[vview_size - 1 - i];
      vview[vview_size - 1 - i] = tmp;
    }
}

// Class Merged_symbol_value.

template<int size>
void
Merged_symbol_value<size>::initialize_input_to_output_map(
    const Relobj* object,
    unsigned int input_shndx)
{
  Object_merge_map* map = object->merge_map();
  map->initialize_input_to_output_map<size>(input_shndx,
					    this->output_start_address_,
					    &this->output_addresses_);
}

// Get the output value corresponding to an input offset if we
// couldn't find it in the hash table.

template<int size>
typename elfcpp::Elf_types<size>::Elf_Addr
Merged_symbol_value<size>::value_from_output_section(
    const Relobj* object,
    unsigned int input_shndx,
    typename elfcpp::Elf_types<size>::Elf_Addr input_offset) const
{
  section_offset_type output_offset;
  bool found = object->merge_map()->get_output_offset(NULL, input_shndx,
						      input_offset,
						      &output_offset);

  // If this assertion fails, it means that some relocation was
  // against a portion of an input merge section which we didn't map
  // to the output file and we didn't explicitly discard.  We should
  // always map all portions of input merge sections.
  gold_assert(found);

  if (output_offset == -1)
    return 0;
  else
    return this->output_start_address_ + output_offset;
}

// Track_relocs methods.

// Initialize the class to track the relocs.  This gets the object,
// the reloc section index, and the type of the relocs.  This returns
// false if something goes wrong.

template<int size, bool big_endian>
bool
Track_relocs<size, big_endian>::initialize(
    Object* object,
    unsigned int reloc_shndx,
    unsigned int reloc_type)
{
  // If RELOC_SHNDX is -1U, it means there is more than one reloc
  // section for the .eh_frame section.  We can't handle that case.
  if (reloc_shndx == -1U)
    return false;

  // If RELOC_SHNDX is 0, there is no reloc section.
  if (reloc_shndx == 0)
    return true;

  // Get the contents of the reloc section.
  this->prelocs_ = object->section_contents(reloc_shndx, &this->len_, false);

  if (reloc_type == elfcpp::SHT_REL)
    this->reloc_size_ = elfcpp::Elf_sizes<size>::rel_size;
  else if (reloc_type == elfcpp::SHT_RELA)
    this->reloc_size_ = elfcpp::Elf_sizes<size>::rela_size;
  else
    gold_unreachable();

  if (this->len_ % this->reloc_size_ != 0)
    {
      object->error(_("reloc section size %zu is not a multiple of "
		      "reloc size %d\n"),
		    static_cast<size_t>(this->len_),
		    this->reloc_size_);
      return false;
    }

  return true;
}

// Return the offset of the next reloc, or -1 if there isn't one.

template<int size, bool big_endian>
off_t
Track_relocs<size, big_endian>::next_offset() const
{
  if (this->pos_ >= this->len_)
    return -1;

  // Rel and Rela start out the same, so we can always use Rel to find
  // the r_offset value.
  elfcpp::Rel<size, big_endian> rel(this->prelocs_ + this->pos_);
  return rel.get_r_offset();
}

// Return the index of the symbol referenced by the next reloc, or -1U
// if there aren't any more relocs.

template<int size, bool big_endian>
unsigned int
Track_relocs<size, big_endian>::next_symndx() const
{
  if (this->pos_ >= this->len_)
    return -1U;

  // Rel and Rela start out the same, so we can use Rel to find the
  // symbol index.
  elfcpp::Rel<size, big_endian> rel(this->prelocs_ + this->pos_);
  return elfcpp::elf_r_sym<size>(rel.get_r_info());
}

// Return the addend of the next reloc, or 0 if there isn't one.

template<int size, bool big_endian>
uint64_t
Track_relocs<size, big_endian>::next_addend() const
{
  if (this->pos_ >= this->len_)
    return 0;
  if (this->reloc_size_ == elfcpp::Elf_sizes<size>::rel_size)
    return 0;
  elfcpp::Rela<size, big_endian> rela(this->prelocs_ + this->pos_);
  return rela.get_r_addend();
}

// Advance to the next reloc whose r_offset is greater than or equal
// to OFFSET.  Return the number of relocs we skip.

template<int size, bool big_endian>
int
Track_relocs<size, big_endian>::advance(off_t offset)
{
  int ret = 0;
  while (this->pos_ < this->len_)
    {
      // Rel and Rela start out the same, so we can always use Rel to
      // find the r_offset value.
      elfcpp::Rel<size, big_endian> rel(this->prelocs_ + this->pos_);
      if (static_cast<off_t>(rel.get_r_offset()) >= offset)
	break;
      ++ret;
      this->pos_ += this->reloc_size_;
    }
  return ret;
}

// Instantiate the templates we need.

#ifdef HAVE_TARGET_32_LITTLE
template
void
Sized_relobj_file<32, false>::do_read_relocs(Read_relocs_data* rd);
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Sized_relobj_file<32, true>::do_read_relocs(Read_relocs_data* rd);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Sized_relobj_file<64, false>::do_read_relocs(Read_relocs_data* rd);
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Sized_relobj_file<64, true>::do_read_relocs(Read_relocs_data* rd);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Sized_relobj_file<32, false>::do_gc_process_relocs(Symbol_table* symtab,
						   Layout* layout,
						   Read_relocs_data* rd);
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Sized_relobj_file<32, true>::do_gc_process_relocs(Symbol_table* symtab,
						  Layout* layout,
						  Read_relocs_data* rd);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Sized_relobj_file<64, false>::do_gc_process_relocs(Symbol_table* symtab,
						   Layout* layout,
						   Read_relocs_data* rd);
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Sized_relobj_file<64, true>::do_gc_process_relocs(Symbol_table* symtab,
						  Layout* layout,
						  Read_relocs_data* rd);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Sized_relobj_file<32, false>::do_scan_relocs(Symbol_table* symtab,
					     Layout* layout,
					     Read_relocs_data* rd);
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Sized_relobj_file<32, true>::do_scan_relocs(Symbol_table* symtab,
					    Layout* layout,
					    Read_relocs_data* rd);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Sized_relobj_file<64, false>::do_scan_relocs(Symbol_table* symtab,
					     Layout* layout,
					     Read_relocs_data* rd);
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Sized_relobj_file<64, true>::do_scan_relocs(Symbol_table* symtab,
					    Layout* layout,
					    Read_relocs_data* rd);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Sized_relobj_file<32, false>::do_relocate(const Symbol_table* symtab,
					  const Layout* layout,
					  Output_file* of);
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Sized_relobj_file<32, true>::do_relocate(const Symbol_table* symtab,
					 const Layout* layout,
					 Output_file* of);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Sized_relobj_file<64, false>::do_relocate(const Symbol_table* symtab,
					  const Layout* layout,
					  Output_file* of);
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Sized_relobj_file<64, true>::do_relocate(const Symbol_table* symtab,
					 const Layout* layout,
					 Output_file* of);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Sized_relobj_file<32, false>::do_relocate_sections(
    const Symbol_table* symtab,
    const Layout* layout,
    const unsigned char* pshdrs,
    Output_file* of,
    Views* pviews);
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Sized_relobj_file<32, true>::do_relocate_sections(
    const Symbol_table* symtab,
    const Layout* layout,
    const unsigned char* pshdrs,
    Output_file* of,
    Views* pviews);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Sized_relobj_file<64, false>::do_relocate_sections(
    const Symbol_table* symtab,
    const Layout* layout,
    const unsigned char* pshdrs,
    Output_file* of,
    Views* pviews);
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Sized_relobj_file<64, true>::do_relocate_sections(
    const Symbol_table* symtab,
    const Layout* layout,
    const unsigned char* pshdrs,
    Output_file* of,
    Views* pviews);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Sized_relobj_file<32, false>::initialize_input_to_output_maps();

template
void
Sized_relobj_file<32, false>::free_input_to_output_maps();
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Sized_relobj_file<32, true>::initialize_input_to_output_maps();

template
void
Sized_relobj_file<32, true>::free_input_to_output_maps();
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Sized_relobj_file<64, false>::initialize_input_to_output_maps();

template
void
Sized_relobj_file<64, false>::free_input_to_output_maps();
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Sized_relobj_file<64, true>::initialize_input_to_output_maps();

template
void
Sized_relobj_file<64, true>::free_input_to_output_maps();
#endif

#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
template
class Merged_symbol_value<32>;
#endif

#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
template
class Merged_symbol_value<64>;
#endif

#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
template
class Symbol_value<32>;
#endif

#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
template
class Symbol_value<64>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
class Track_relocs<32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Track_relocs<32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Track_relocs<64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Track_relocs<64, true>;
#endif

} // End namespace gold.
@


1.68
log
@	* layout.cc: Include "object.h".
	(ctors_sections_in_init_array): New static variable.
	(Layout::is_ctors_in_init_array): New function.
	(Layout::layout): Add entry to ctors_sections_in_init_array if
	appropriate.
	* layout.h (class Layout): Declare is_ctors_in_init_array.
	* reloc.cc (Sized_relobj_file::do_relocate): Call reverse_words if
	is_ctors_reverse_view is set.
	(Sized_relobj_file::write_sections): Add layout parameter.  Change
	all callers.  Set is_ctors_reverse_view field of View_size.
	(Sized_relobj_file::reverse_words): New function.
	* object.h (Sized_relobj_file::View_size): Add
	is_ctors_reverse_view field.
	(class Sized_relobj_file): Update declarations.
	* testsuite/initpri3.c: New test.
	* testsuite/Makefile.am: (check_PROGRAMS): Add initpri3a and
	initpri3b.
	(initpri3a_SOURCES, initpri3a_DEPENDENCIES): New variables.
	(initpri3a_LDFLAGS, initpri3a_LDADD): New variables.
	(initpri3b_SOURCES, initpri3b_DEPENDENCIES): New variables.
	(initpri3b_LDFLAGS, initpri3b_LDADD): New variables.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1017 8
a1024 3
	    this->emit_relocs(&relinfo, i, sh_type, prelocs, reloc_count,
			      os, output_offset, view, address, view_size,
			      (*pviews)[i].view, (*pviews)[i].view_size);
d1032 5
a1036 5
	  target->relocate_for_relocatable(&relinfo, sh_type, prelocs,
					   reloc_count, os, output_offset, rr,
					   view, address, view_size,
					   (*pviews)[i].view,
					   (*pviews)[i].view_size);
a1040 69
// Emit the relocs for --emit-relocs.

template<int size, bool big_endian>
void
Sized_relobj_file<size, big_endian>::emit_relocs(
    const Relocate_info<size, big_endian>* relinfo,
    unsigned int i,
    unsigned int sh_type,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    typename elfcpp::Elf_types<size>::Elf_Addr offset_in_output_section,
    unsigned char* view,
    typename elfcpp::Elf_types<size>::Elf_Addr address,
    section_size_type view_size,
    unsigned char* reloc_view,
    section_size_type reloc_view_size)
{
  if (sh_type == elfcpp::SHT_REL)
    this->emit_relocs_reltype<elfcpp::SHT_REL>(relinfo, i, prelocs,
					       reloc_count, output_section,
					       offset_in_output_section,
					       view, address, view_size,
					       reloc_view, reloc_view_size);
  else
    {
      gold_assert(sh_type == elfcpp::SHT_RELA);
      this->emit_relocs_reltype<elfcpp::SHT_RELA>(relinfo, i, prelocs,
						  reloc_count, output_section,
						  offset_in_output_section,
						  view, address, view_size,
						  reloc_view, reloc_view_size);
    }
}

// Emit the relocs for --emit-relocs, templatized on the type of the
// relocation section.

template<int size, bool big_endian>
template<int sh_type>
void
Sized_relobj_file<size, big_endian>::emit_relocs_reltype(
    const Relocate_info<size, big_endian>* relinfo,
    unsigned int i,
    const unsigned char* prelocs,
    size_t reloc_count,
    Output_section* output_section,
    typename elfcpp::Elf_types<size>::Elf_Addr offset_in_output_section,
    unsigned char* view,
    typename elfcpp::Elf_types<size>::Elf_Addr address,
    section_size_type view_size,
    unsigned char* reloc_view,
    section_size_type reloc_view_size)
{
  const Relocatable_relocs* rr = this->relocatable_relocs(i);
  relocate_for_relocatable<size, big_endian, sh_type>(
    relinfo,
    prelocs,
    reloc_count,
    output_section,
    offset_in_output_section,
    rr,
    view,
    address,
    view_size,
    reloc_view,
    reloc_view_size);
}

@


1.67
log
@	* reloc.cc (Sized_relobj_file::do_read_relocs): Ignore empty reloc
	sections.
@
text
@d662 1
a662 1
  this->write_sections(pshdrs, of, &views);
d681 2
d717 2
a718 1
Sized_relobj_file<size, big_endian>::write_sections(const unsigned char* pshdrs,
d767 1
d882 6
d1496 20
@


1.66
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@d325 3
@


1.65
log
@	* gold/layout.cc (Layout::symtab_section_offset): New function.
	* gold/layout.h (Layout::symtab_section_offset): New function.
	* gold/reloc.cc (Sized_relobj::do_relocate): Call it.
@
text
@d261 1
a261 1
Sized_relobj<size, big_endian>::do_read_relocs(Read_relocs_data* rd)
d272 1
a272 1
  const std::vector<Address>& out_offsets(this->section_offsets_);
d383 3
a385 3
Sized_relobj<size, big_endian>::do_gc_process_relocs(Symbol_table* symtab,
						     Layout* layout,
						     Read_relocs_data* rd)
d423 1
a423 1
Sized_relobj<size, big_endian>::do_scan_relocs(Symbol_table* symtab,
d540 1
a540 1
Sized_relobj<size, big_endian>::emit_relocs_scan(
d567 1
a567 1
Sized_relobj<size, big_endian>::emit_relocs_scan_reltype(
d593 1
a593 1
Sized_relobj<size, big_endian>::incremental_relocs_scan(
d611 1
a611 1
Sized_relobj<size, big_endian>::incremental_relocs_scan_reltype(
d641 3
a643 3
Sized_relobj<size, big_endian>::do_relocate(const Symbol_table* symtab,
					    const Layout* layout,
					    Output_file* of)
d712 3
a714 3
Sized_relobj<size, big_endian>::write_sections(const unsigned char* pshdrs,
					       Output_file* of,
					       Views* pviews)
d718 1
a718 1
  const std::vector<Address>& out_offsets(this->section_offsets_);
d891 1
a891 1
Sized_relobj<size, big_endian>::do_relocate_sections(
d903 1
a903 1
  const std::vector<Address>& out_offsets(this->section_offsets_);
d1027 1
a1027 1
Sized_relobj<size, big_endian>::emit_relocs(
d1064 1
a1064 1
Sized_relobj<size, big_endian>::emit_relocs_reltype(
d1096 1
a1096 1
Sized_relobj<size, big_endian>::incremental_relocs_write(
d1132 1
a1132 1
Sized_relobj<size, big_endian>::incremental_relocs_write_reltype(
d1218 1
a1218 1
Sized_relobj<size, big_endian>::initialize_input_to_output_maps()
d1232 1
a1232 1
Sized_relobj<size, big_endian>::free_input_to_output_maps()
d1250 1
a1250 1
Sized_relobj<size, big_endian>::split_stack_adjust(
d1282 1
a1282 1
Sized_relobj<size, big_endian>::split_stack_adjust_reltype(
d1439 1
a1439 1
Sized_relobj<size, big_endian>::find_functions(
d1442 1
a1442 1
    Sized_relobj<size, big_endian>::Function_offsets* function_offsets)
d1639 1
a1639 1
Sized_relobj<32, false>::do_read_relocs(Read_relocs_data* rd);
d1645 1
a1645 1
Sized_relobj<32, true>::do_read_relocs(Read_relocs_data* rd);
d1651 1
a1651 1
Sized_relobj<64, false>::do_read_relocs(Read_relocs_data* rd);
d1657 1
a1657 1
Sized_relobj<64, true>::do_read_relocs(Read_relocs_data* rd);
d1663 3
a1665 3
Sized_relobj<32, false>::do_gc_process_relocs(Symbol_table* symtab,
					      Layout* layout,
					      Read_relocs_data* rd);
d1671 3
a1673 3
Sized_relobj<32, true>::do_gc_process_relocs(Symbol_table* symtab,
					     Layout* layout,
					     Read_relocs_data* rd);
d1679 3
a1681 3
Sized_relobj<64, false>::do_gc_process_relocs(Symbol_table* symtab,
					      Layout* layout,
					      Read_relocs_data* rd);
d1687 3
a1689 3
Sized_relobj<64, true>::do_gc_process_relocs(Symbol_table* symtab,
					     Layout* layout,
					     Read_relocs_data* rd);
d1695 3
a1697 3
Sized_relobj<32, false>::do_scan_relocs(Symbol_table* symtab,
					Layout* layout,
					Read_relocs_data* rd);
d1703 3
a1705 3
Sized_relobj<32, true>::do_scan_relocs(Symbol_table* symtab,
				       Layout* layout,
				       Read_relocs_data* rd);
d1711 3
a1713 3
Sized_relobj<64, false>::do_scan_relocs(Symbol_table* symtab,
					Layout* layout,
					Read_relocs_data* rd);
d1719 3
a1721 3
Sized_relobj<64, true>::do_scan_relocs(Symbol_table* symtab,
				       Layout* layout,
				       Read_relocs_data* rd);
d1727 3
a1729 3
Sized_relobj<32, false>::do_relocate(const Symbol_table* symtab,
				     const Layout* layout,
				     Output_file* of);
d1735 3
a1737 3
Sized_relobj<32, true>::do_relocate(const Symbol_table* symtab,
				    const Layout* layout,
				    Output_file* of);
d1743 3
a1745 3
Sized_relobj<64, false>::do_relocate(const Symbol_table* symtab,
				     const Layout* layout,
				     Output_file* of);
d1751 3
a1753 3
Sized_relobj<64, true>::do_relocate(const Symbol_table* symtab,
				    const Layout* layout,
				    Output_file* of);
d1759 1
a1759 1
Sized_relobj<32, false>::do_relocate_sections(
d1770 1
a1770 1
Sized_relobj<32, true>::do_relocate_sections(
d1781 1
a1781 1
Sized_relobj<64, false>::do_relocate_sections(
d1792 1
a1792 1
Sized_relobj<64, true>::do_relocate_sections(
d1803 1
a1803 1
Sized_relobj<32, false>::initialize_input_to_output_maps();
d1807 1
a1807 1
Sized_relobj<32, false>::free_input_to_output_maps();
d1813 1
a1813 1
Sized_relobj<32, true>::initialize_input_to_output_maps();
d1817 1
a1817 1
Sized_relobj<32, true>::free_input_to_output_maps();
d1823 1
a1823 1
Sized_relobj<64, false>::initialize_input_to_output_maps();
d1827 1
a1827 1
Sized_relobj<64, false>::free_input_to_output_maps();
d1833 1
a1833 1
Sized_relobj<64, true>::initialize_input_to_output_maps();
d1837 1
a1837 1
Sized_relobj<64, true>::free_input_to_output_maps();
@


1.64
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d694 1
a694 1
			    layout->symtab_section()->offset());
@


1.63
log
@	PR gold/12316
	* object.h (class Sized_relobj): Remove clear_local_symbols.
	* reloc.cc (Sized_relobj::do_relocate): Don't call
	clear_local_symbols.
@
text
@d59 3
a61 1
  tl->add(this, this->object_->token());
d177 3
a179 1
  tl->add(this, this->object_->token());
d229 3
a231 1
  tl->add(this, this->object_->token());
d492 1
a492 1
    this->finalize_incremental_relocs(layout);
d605 1
a605 1
// Scan the input relocation for --emit-relocs, templatized on the
d693 2
a694 1
			    layout->symtab_xindex(), layout->dynsym_xindex());
d1144 2
a1145 1
  const unsigned int incr_reloc_size = 8 + 2 * sizeof_addr;
@


1.62
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
a687 3

  // We should no longer need the local symbol values.
  this->clear_local_symbols();
@


1.61
log
@	* dwarf_reader.h (class Sized_dwarf_line_info): Add
	track_relocs_type_ field.
	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Set track_relocs_type_.
	(Sized_dwarf_line_info::process_one_opcode): Ignore the section
	contents when using RELA relocs.
	(Sized_dwarf_line_info::read_relocs): Add the reloc addend to
	reloc_map_.
	* reloc.cc (Track_relocs::next_addend): New function.
	* reloc.h (class Track_relocs): Declare next_addend.
@
text
@d372 1
a372 1
// sections.  This is used during garbage colletion to determine garbage 
@


1.60
log
@	* debug.h (DEBUG_INCREMENTAL): New flag.
	(debug_string_to_enum): Add DEBUG_INCREMENTAL).
	* gold.cc (queue_initial_tasks): Check parameters for incremental link
	mode.
	* incremental.cc (report_command_line): Ignore all forms of
	--incremental.
	* layout.cc (Layout::Layout): Check parameters for incremental link
	mode.
	* options.cc (General_options::parse_incremental): New function.
	(General_options::parse_no_incremental): New function.
	(General_options::parse_incremental_full): New function.
	(General_options::parse_incremental_update): New function.
	(General_options::incremental_mode_): New data member.
	(General_options::finalize): Check incremental_mode_.
	* options.h (General_options): Update help text for --incremental.
	Add --no-incremental, --incremental-full, --incremental-update.
	(General_options::Incremental_mode): New enum type.
	(General_options::incremental_mode): New function.
	(General_options::incremental_mode_): New data member.
	* parameters.cc (Parameters::incremental_mode_): New data member.
	(Parameters::set_options): Set incremental_mode_.
	(Parameters::set_incremental_full): New function.
	(Parameters::incremental): New function.
	(Parameters::incremental_update): New function.
	(set_parameters_incremental_full): New function.
	* parameters.h (Parameters::set_incremental_full): New function.
	(Parameters::incremental): New function.
	(Parameters::incremental_update): New function.
	(Parameters::incremental_mode_): New data member.
	(set_parameters_incremental_full): New function.
	* plugin.cc (Plugin_manager::add_input_file): Check parameters for
	incremental link mode.
	* reloc.cc (Sized_relobj::do_read_relocs): Likewise.
	(Sized_relobj::do_relocate_sections): Likewise.
	* testsuite/Makefile.am (incremental_test): Use --incremental-full
	option.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/incremental_test.sh: Filter all forms of --incremental.
@
text
@d1594 14
@


1.60.2.1
log
@	PR gold/12316
	* object.h (class Sized_relobj): Remove clear_local_symbols.
	* reloc.cc (Sized_relobj::do_relocate): Don't call
	clear_local_symbols.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d688 3
@


1.59
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d306 1
a306 1
	  && !parameters->options().incremental())
d1003 1
a1003 1
	  if (parameters->options().incremental())
@


1.58
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_SYMTAB,
	SHT_GNU_INCREMENTAL_RELOCS.

gold/ChangeLog:

	* archive.cc: Include incremental.h.
	(Archive::Archive): Initialize incremental_info_.
	(Archive::include_member): Record archive members in incremental info.
	(Add_archive_symbols::run): Record begin and end of an archive in
	incremental info.
	(Lib_group::include_member): Record objects in incremental info.
	* archive.h (Incremental_archive_entry): Forward declaration.
	(Archive::set_incremental_info): New member function.
	(Archive::incremental_info): New member function.
	(Archive::Unused_symbol_iterator): New class.
	(Archive::unused_symbols_begin): New member function.
	(Archive::unused_symbols_end): New member function.
	(Archive::incremental_info_): New data member.
	* incremental-dump.cc (find_input_containing_global): New function.
	(dump_incremental_inputs): Dump new incremental info sections.
	* incremental.cc: Include symtab.h.
	(Output_section_incremental_inputs): New class.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Support
	new incremental info sections.
	(Sized_incremental_binary::do_check_inputs): Likewise.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): New function.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Rewrite.
	(Incremental_inputs::finalize): Do nothing but finalize string table.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Output_section_incremental_inputs::set_final_data_size): New function.
	(Output_section_incremental_inputs::do_write): New function.
	(Output_section_incremental_inputs::write_header): New function.
	(Output_section_incremental_inputs::write_input_files): New function.
	(Output_section_incremental_inputs::write_info_blocks): New function.
	(Output_section_incremental_inputs::write_symtab): New function.
	* incremental.h (Incremental_script_entry): Forward declaration.
	(Incremental_object_entry): Forward declaration.
	(Incremental_archive_entry): Forward declaration.
	(Incremental_inputs): Forward declaration.
	(Incremental_inputs_header_data): Remove.
	(Incremental_inputs_header): Remove.
	(Incremental_inputs_header_write): Remove.
	(Incremental_inputs_entry_data): Remove.
	(Incremental_inputs_entry): Remove.
	(Incremental_inputs_entry_write): Remove.
	(enum Incremental_input_type): Add INCREMENTAL_INPUT_ARCHIVE_MEMBER.
	(Incremental_binary::find_incremental_inputs_sections): Add parameters.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Sized_ncremental_binary::do_find_incremental_inputs_sections):
	Likewise.
	(Incremental_input_entry): New class.
	(Incremental_script_entry): New class.
	(Incremental_object_entry): New class.
	(Incremental_archive_entry): New class.
	(Incremental_inputs::Incremental_inputs): Initialize new data members.
	(Incremental_inputs::report_inputs): Remove.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): Change prototype.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Change prototype.
	(Incremental_inputs::get_reloc_count): New function.
	(Incremental_inputs::set_reloc_count): New function.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::inputs_section): New function.
	(Incremental_inputs::symtab_section): New function.
	(Incremental_inputs::relocs_section): New function.
	(Incremental_inputs::get_stringpool): Add const.
	(Incremental_inputs::command_line): Add const.
	(Incremental_inputs::inputs): Remove.
	(Incremental_inputs::command_line_key): New function.
	(Incremental_inputs::input_file_count): New function.
	(Incremental_inputs::input_files): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::Input_info): Remove.
	(Incremental_inputs::lock_): Remove.
	(Incremental_inputs::inputs_): Change type.
	(Incremental_inputs::inputs_map_): Remove.
	(Incremental_inputs::current_object_entry_): New data member.
	(Incremental_inputs::inputs_section_): New data member.
	(Incremental_inputs::symtab_section_): New data member.
	(Incremental_inputs::relocs_section_): New data member.
	(Incremental_inputs::reloc_count_): New data member.
	(Incremental_inputs_reader): New class.
	(Incremental_symtab_reader): New class.
	(Incremental_relocs_reader): New class.
	* layout.cc (Layout::finalize): Move finalization of incremental info
	and creation of incremental info sections to follow finalization of
	symbol table.  Set offsets for postprocessing sections.
	(Layout::create_incremental_info_sections): Call
	Incremental_inputs::create_data_sections.  Add incremental symtab
	and relocs sections.  Set sh_entsize and sh_link fields.  Arrange for
	sections to layout after input sections.
	* layout.h (struct Timespec): Forward declaration.
	(Layout::incremental_inputs): Add const.
	(Layout::create_incremental_info_sections): Add parameter.
	* main.cc (main): Remove call to Incremental_inputs::report_inputs.
	* object.cc: Include incremental.h.
	(Relobj::finalize_incremental_relocs): New function.
	(Sized_relobj::do_layout): Record input sections in incremental info.
	* object.h (Object::output_section): New function.
	(Object::output_section_offset): Moved from Relobj.
	(Object::get_incremental_reloc_base): New function.
	(Object::get_incremental_reloc_count): New function.
	(Object::do_output_section): New function.
	(Object::do_output_section_offset): Moved from Relobj.
	(Object::do_get_incremental_reloc_base): New function.
	(Object::do_get_incremental_reloc_count): New function.
	(Object::Object): Initialize new data members.
	(Relobj::output_section): Renamed do_output_section and moved to
	protected.
	(Relobj::output_section_offset): Moved to Object.
	(Relobj::do_get_incremental_reloc_base): New function.
	(Relobj::do_get_incremental_reloc_count): New function.
	(Relobj::allocate_incremental_reloc_counts): New function.
	(Relobj::count_incremental_reloc): New function.
	(Relobj::finalize_incremental_relocs): New function.
	(Relobj::next_incremental_reloc_index): New function.
	(Relobj::reloc_counts_): New data member.
	(Relobj::reloc_bases_): New data member.
	(Sized_relobj::do_relocate_sections): Add parameter.  Change caller.
	(Sized_relobj::relocate_sections): Add parameter.  Change all callers.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* plugin.cc (Plugin_manager::add_input_file): Rewrite test for
	incremental link.
	* readsyms.cc (Read_symbols::do_read_symbols): Move reporting of
	archives and object files elsewhere.
	(Add_symbols::run): Report object files here.
	(Finish_group::run): Report end of archive at end of group.
	* reloc.cc: Include layout.h, incremental.h.
	(Sized_relobj::do_read_relocs): Need relocations for incremental link.
	(Sized_relobj::do_scan_relocs): Record relocations for incremental link.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::do_relocate_sections): Write incremental relocations.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* script.cc (read_input_script): Rewrite test for incremental link.
	Change call to Incremental_inputs::report_script.
	* symtab.h (Symbol_table::first_global_index): New function.
	(Symbol_table::output_count): New function.
@
text
@d67 1
a67 1
  Read_relocs_data *rd = new Read_relocs_data;
d268 1
a268 1
  const unsigned char *pshdrs = this->get_view(this->elf_file_.shoff(),
d272 1
a272 1
  const unsigned char *ps = pshdrs + This::shdr_size;
@


1.57
log
@	* compressed_output.cc (zlib_decompress): New function.
	(get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* compressed_output.h (get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info)
	Handle compressed debug sections.
	* layout.cc (is_compressed_debug_section): New function.
	(Layout::output_section_name): Map compressed section names to
	canonical names.
	* layout.h (is_compressed_debug_section): New function.
	(is_debug_info_section): Recognize compressed debug sections.
	* merge.cc: Include compressed_output.h.
	(Output_merge_data::do_add_input_section): Handle compressed
	debug sections.
	(Output_merge_string::do_add_input_section): Handle compressed
	debug sections.
	* object.cc: Include compressed_output.h.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(build_compressed_section_map): New function.
	(Sized_relobj::do_read_symbols): Handle compressed debug sections.
	* object.h (Object::section_is_compressed): New method.
	(Object::do_section_is_compressed): New method.
	(Sized_relobj::Compressed_section_map): New type.
	(Sized_relobj::do_section_is_compressed): New method.
	(Sized_relobj::compressed_sections_): New data member.
	* output.cc (Output_section::add_input_section): Handle compressed
	debug sections.
	* reloc.cc: Include compressed_output.h.
	(Sized_relobj::write_sections): Handle compressed debug sections.
@
text
@d28 1
d37 1
d305 2
a306 1
	  && !parameters->options().emit_relocs())
d430 4
d461 2
d484 4
d583 48
d661 1
a661 1
  this->relocate_sections(symtab, layout, pshdrs, &views);
d891 1
d1003 3
d1088 120
d1744 1
d1755 1
d1766 1
d1777 1
@


1.56
log
@	* reloc.cc (Sized_relobj::split_stack_adjust_reltype): Call the
	target to ask whether a reference to a symbol requires a stack
	split.
	* target.h (Target::is_call_to_non_split): New function.
	(Target::do_is_call_to_non_split): Declare virtual function.
	* target.cc: Include "symtab.h".
	(Target::do_is_call_to_non_split): New function.
	* i386.cc (Target_i386::do_is_call_to_non_split): New function.
@
text
@d35 1
d736 1
d741 6
d765 1
a765 1
	  if (output_offset != invalid_address)
d781 8
a788 5
	      off_t sh_offset = shdr.get_sh_offset();
	      if (!rm.empty() && rm.back().file_offset > sh_offset)
		is_sorted = false;
	      rm.push_back(File_read::Read_multiple_entry(sh_offset,
							  view_size, view));
d792 10
@


1.55
log
@	* fileread.cc (File_read::~File_read): Don't delete whole_file_view_.
	(File_read::open[1]): Remove initial mapping of whole_file_view_.
	(File_read::open[2]): Add whole_file_view_ to list of views.
	(File_read::make_view): Remove test of whole_file_view_.
	(File_read::find_or_make_view): Create whole_file_view_ if
	necessary.
	(File_read::clear_views): Replace bool parameter with enum;
	adjust all callers.  Don't delete views with permanent data;
	do delete cached views and views from archives if
	--no-keep-files-mapped is set.  Set whole_file_view_ to NULL
	if clearing the corresponding view.
	* fileread.h (File_read::Clear_views_mode): New enum.
	(File_read::View::is_permanent_view): New method.
	(File_read::clear_views): Replace bool parameter
	with enum; adjust all callers.
	* options.h (General_options): Change keep_files_mapped option;
	add map_whole_files.
	* readsyms.cc (Add_symbols::run): Delete sd_ object before
	releasing the file.
	* reloc.cc (Scan_relocs::run): Delete rd_ object before releasing
	the file.
@
text
@d1109 1
a1109 2
      if (gsym->type() == elfcpp::STT_FUNC
	  && !gsym->is_undefined()
d1113 7
a1119 3
	  section_offset_type offset =
	    convert_to_section_size_type(reloc.get_r_offset());
	  non_split_refs.push_back(offset);
@


1.54
log
@	* gold.cc (queue_middle_gc_tasks): Use a separate blocker for each
	Read_relocs task.
	(queue_middle_tasks): Likewise, and also for Scan_relocs.  Run
	Allocate_commons_task first.
	* reloc.cc (Read_relocs::run): Pass next_blocker_ down to next
	task, rather than symtab_lock_.
	(Gc_process_relocs::~Gc_process_relocs): New function.
	(Gc_process_relocs::is_runnable): Check this_blocker_.
	(Gc_process_relocs::locks): Use next_blocker_ rather than
	blocker_.
	(Scan_relocs::~Scan_relocs): New function.
	(Scan_relocs::is_runnable): Check this_blocker_ rather than
	symtab_lock_.
	(Scan_relocs::locks): Drop symtab_lock_ and blocker_.  Add
	next_blocker_.
	* reloc.h (class Read_relocs): Drop symtab_lock_ and blocker_
	fields.  Add this_blocker_ and next_blocker_ fields.  Adjust
	constructor accordingly.
	(class Gc_process_relocs): Likewise.
	(class Scan_relocs): Likewise.
	* common.h (class Allocate_commons_task): Remove symtab_lock_
	field, and corresponding constructor parameter.
	* common.cc (Allocate_commons_tasK::is_runnable): Remove use of
	symtab_lock_.
	(Allocate_commons_task::locks): Likewise.
@
text
@a181 1
  this->object_->release();
d184 1
@


1.53
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d78 2
a79 2
                                                  this->symtab_lock_, 
                                                  this->blocker_));
d85 2
a86 2
                                            this->symtab_lock_, 
                                            this->blocker_));
d100 7
a106 1
// These tasks process the relocations read by Read_relocs and 
d108 2
a109 1
// This task is done only when --gc-sections is used.
d114 2
d125 1
a125 1
  tl->add(this, this->blocker_);
d145 6
d159 2
a160 2
  if (!this->symtab_lock_->is_writable())
    return this->symtab_lock_;
d173 1
a173 2
  tl->add(this, this->symtab_lock_);
  tl->add(this, this->blocker_);
@


1.52
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d242 2
a243 2
  unsigned int sec_shnum = this->shnum();
  if (sec_shnum == 0)
d246 1
a246 1
  rd->relocs.reserve(sec_shnum / 2);
d252 1
a252 1
					       sec_shnum * This::shdr_size,
d256 1
a256 1
  for (unsigned int i = 1; i < sec_shnum; ++i, ps += This::shdr_size)
d265 1
a265 1
      if (shndx >= sec_shnum)
d344 1
a344 1
      const int symsize = This::sym_size;
d347 1
a347 1
      off_t locsize = loccount * symsize;
d360 1
a360 1
						     Layout* alayout,
d382 1
a382 1
              target->gc_process_relocs(symtab, alayout, this, 
d400 1
a400 1
					       Layout* alayout,
d431 1
a431 1
	    target->scan_relocs(symtab, alayout, this, p->data_shndx,
d438 1
a438 1
	    this->emit_relocs_scan(symtab, alayout, local_symbols, p);
d445 1
a445 1
	  target->scan_relocatable_relocs(symtab, alayout, this,
d508 1
a508 1
    Layout* alayout,
d517 1
a517 1
    this->emit_relocs_scan_reltype<elfcpp::SHT_REL>(symtab, alayout,
d522 1
a522 1
      this->emit_relocs_scan_reltype<elfcpp::SHT_RELA>(symtab, alayout,
d535 1
a535 1
    Layout* alayout,
d543 1
a543 1
    alayout,
d560 1
a560 1
					    const Layout* alayout,
d563 1
a563 1
  unsigned int sec_shnum = this->shnum();
d567 1
a567 1
					       sec_shnum * This::shdr_size,
d571 1
a571 1
  views.resize(sec_shnum);
d585 1
a585 1
  this->relocate_sections(symtab, alayout, pshdrs, &views);
d592 1
a592 1
  for (unsigned int i = 1; i < sec_shnum; ++i)
d610 2
a611 2
  this->write_local_symbols(of, alayout->sympool(), alayout->dynpool(),
			    alayout->symtab_xindex(), alayout->dynsym_xindex());
d636 1
a636 1
  unsigned int sec_shnum = this->shnum();
d644 1
a644 1
  for (unsigned int i = 1; i < sec_shnum; ++i, p += This::shdr_size)
d705 1
a705 1
      off_t out_section_offset;
d709 1
a709 1
	  out_section_offset = os->offset();
d714 1
a714 1
	  out_section_offset = 0;
d723 1
a723 1
	  view_start = out_section_offset + output_offset;
d728 1
a728 1
	  view_start = out_section_offset;
d738 1
a738 1
      unsigned char* aview;
d742 1
a742 1
	  aview = buffer + view_start;
d749 1
a749 1
							  view_size, aview));
d755 1
a755 1
	    aview = of->get_input_output_view(view_start, view_size);
d758 1
a758 1
	      aview = of->get_output_view(view_start, view_size);
d763 1
a763 1
							  view_size, aview));
d767 1
a767 1
      pvs->view = aview;
d793 1
a793 1
    const Layout* alayout,
d797 1
a797 1
  unsigned int sec_shnum = this->shnum();
d806 1
a806 1
  relinfo.layout = alayout;
d810 1
a810 1
  for (unsigned int i = 1; i < sec_shnum; ++i, p += This::shdr_size)
d883 1
a883 1
      unsigned char* aview = (*pviews)[index].view;
d893 1
a893 1
				     prelocs, reloc_count, aview, view_size,
d901 1
a901 1
				   aview, address, view_size, reloc_map);
d904 1
a904 1
			      os, output_offset, aview, address, view_size,
d912 1
a912 1
					   aview, address, view_size,
d929 1
a929 1
    Output_section* aoutput_section,
d931 1
a931 1
    unsigned char* aview,
d939 1
a939 1
					       reloc_count, aoutput_section,
d941 1
a941 1
					       aview, address, view_size,
d947 1
a947 1
						  reloc_count, aoutput_section,
d949 1
a949 1
						  aview, address, view_size,
d965 1
a965 1
    Output_section* aoutput_section,
d967 1
a967 1
    unsigned char* aview,
d978 1
a978 1
    aoutput_section,
d981 1
a981 1
    aview,
d1032 1
a1032 1
    unsigned char* aview,
d1039 1
a1039 1
						      aview, view_size,
d1046 1
a1046 1
							 aview, view_size,
d1063 1
a1063 1
    unsigned char* aview,
d1100 1
a1100 1
	  section_offset_type off =
d1102 1
a1102 1
	  non_split_refs.push_back(off);
d1155 1
a1155 1
					   aview, view_size, &from, &to);
d1174 1
a1174 1
	      section_offset_type off =
d1176 2
a1177 2
	      if (off < p->first
		  || (off
d1219 2
a1220 2
  const unsigned int sym_tab_shndx = this->symtab_shndx_;
  typename This::Shdr symtabshdr(pshdrs + sym_tab_shndx * This::shdr_size);
d1228 3
a1230 3
  const int symsize = This::sym_size;
  const unsigned int symcount = sh_size / symsize;
  for (unsigned int i = 0; i < symcount; ++i, psyms += symsize)
d1422 1
a1422 1
					      Layout* alayout,
d1430 1
a1430 1
					     Layout* alayout,
d1438 1
a1438 1
					      Layout* alayout,
d1446 1
a1446 1
					     Layout* alayout,
d1454 1
a1454 1
					Layout* alayout,
d1462 1
a1462 1
				       Layout* alayout,
d1470 1
a1470 1
					Layout* alayout,
d1478 1
a1478 1
				       Layout* alayout,
d1486 1
a1486 1
				     const Layout* alayout,
d1494 1
a1494 1
				    const Layout* alayout,
d1502 1
a1502 1
				     const Layout* alayout,
d1510 1
a1510 1
				    const Layout* alayout,
d1519 1
a1519 1
    const Layout* alayout,
d1529 1
a1529 1
    const Layout* alayout,
d1539 1
a1539 1
    const Layout* alayout,
@


1.51
log
@	PR 10925
	* reloc.cc: Instantiate
	Sized_relobj::initialize_input_to_output_maps and
	Sized_relobj:free_input_to_output_maps.
@
text
@d242 2
a243 2
  unsigned int shnum = this->shnum();
  if (shnum == 0)
d246 1
a246 1
  rd->relocs.reserve(shnum / 2);
d252 1
a252 1
					       shnum * This::shdr_size,
d256 1
a256 1
  for (unsigned int i = 1; i < shnum; ++i, ps += This::shdr_size)
d265 1
a265 1
      if (shndx >= shnum)
d344 1
a344 1
      const int sym_size = This::sym_size;
d347 1
a347 1
      off_t locsize = loccount * sym_size;
d360 1
a360 1
						     Layout* layout,
d382 1
a382 1
              target->gc_process_relocs(symtab, layout, this, 
d400 1
a400 1
					       Layout* layout,
d431 1
a431 1
	    target->scan_relocs(symtab, layout, this, p->data_shndx,
d438 1
a438 1
	    this->emit_relocs_scan(symtab, layout, local_symbols, p);
d445 1
a445 1
	  target->scan_relocatable_relocs(symtab, layout, this,
d508 1
a508 1
    Layout* layout,
d517 1
a517 1
    this->emit_relocs_scan_reltype<elfcpp::SHT_REL>(symtab, layout,
d522 1
a522 1
      this->emit_relocs_scan_reltype<elfcpp::SHT_RELA>(symtab, layout,
d535 1
a535 1
    Layout* layout,
d543 1
a543 1
    layout,
d560 1
a560 1
					    const Layout* layout,
d563 1
a563 1
  unsigned int shnum = this->shnum();
d567 1
a567 1
					       shnum * This::shdr_size,
d571 1
a571 1
  views.resize(shnum);
d585 1
a585 1
  this->relocate_sections(symtab, layout, pshdrs, &views);
d592 1
a592 1
  for (unsigned int i = 1; i < shnum; ++i)
d610 2
a611 2
  this->write_local_symbols(of, layout->sympool(), layout->dynpool(),
			    layout->symtab_xindex(), layout->dynsym_xindex());
d636 1
a636 1
  unsigned int shnum = this->shnum();
d644 1
a644 1
  for (unsigned int i = 1; i < shnum; ++i, p += This::shdr_size)
d705 1
a705 1
      off_t output_section_offset;
d709 1
a709 1
	  output_section_offset = os->offset();
d714 1
a714 1
	  output_section_offset = 0;
d723 1
a723 1
	  view_start = output_section_offset + output_offset;
d728 1
a728 1
	  view_start = output_section_offset;
d738 1
a738 1
      unsigned char* view;
d742 1
a742 1
	  view = buffer + view_start;
d749 1
a749 1
							  view_size, view));
d755 1
a755 1
	    view = of->get_input_output_view(view_start, view_size);
d758 1
a758 1
	      view = of->get_output_view(view_start, view_size);
d763 1
a763 1
							  view_size, view));
d767 1
a767 1
      pvs->view = view;
d793 1
a793 1
    const Layout* layout,
d797 1
a797 1
  unsigned int shnum = this->shnum();
d806 1
a806 1
  relinfo.layout = layout;
d810 1
a810 1
  for (unsigned int i = 1; i < shnum; ++i, p += This::shdr_size)
d883 1
a883 1
      unsigned char* view = (*pviews)[index].view;
d893 1
a893 1
				     prelocs, reloc_count, view, view_size,
d901 1
a901 1
				   view, address, view_size, reloc_map);
d904 1
a904 1
			      os, output_offset, view, address, view_size,
d912 1
a912 1
					   view, address, view_size,
d929 1
a929 1
    Output_section* output_section,
d931 1
a931 1
    unsigned char* view,
d939 1
a939 1
					       reloc_count, output_section,
d941 1
a941 1
					       view, address, view_size,
d947 1
a947 1
						  reloc_count, output_section,
d949 1
a949 1
						  view, address, view_size,
d965 1
a965 1
    Output_section* output_section,
d967 1
a967 1
    unsigned char* view,
d978 1
a978 1
    output_section,
d981 1
a981 1
    view,
d1032 1
a1032 1
    unsigned char* view,
d1039 1
a1039 1
						      view, view_size,
d1046 1
a1046 1
							 view, view_size,
d1063 1
a1063 1
    unsigned char* view,
d1100 1
a1100 1
	  section_offset_type offset =
d1102 1
a1102 1
	  non_split_refs.push_back(offset);
d1155 1
a1155 1
					   view, view_size, &from, &to);
d1174 1
a1174 1
	      section_offset_type offset =
d1176 2
a1177 2
	      if (offset < p->first
		  || (offset
d1219 2
a1220 2
  const unsigned int symtab_shndx = this->symtab_shndx_;
  typename This::Shdr symtabshdr(pshdrs + symtab_shndx * This::shdr_size);
d1228 3
a1230 3
  const int sym_size = This::sym_size;
  const unsigned int symcount = sh_size / sym_size;
  for (unsigned int i = 0; i < symcount; ++i, psyms += sym_size)
d1422 1
a1422 1
					      Layout* layout,
d1430 1
a1430 1
					     Layout* layout,
d1438 1
a1438 1
					      Layout* layout,
d1446 1
a1446 1
					     Layout* layout,
d1454 1
a1454 1
					Layout* layout,
d1462 1
a1462 1
				       Layout* layout,
d1470 1
a1470 1
					Layout* layout,
d1478 1
a1478 1
				       Layout* layout,
d1486 1
a1486 1
				     const Layout* layout,
d1494 1
a1494 1
				    const Layout* layout,
d1502 1
a1502 1
				     const Layout* layout,
d1510 1
a1510 1
				    const Layout* layout,
d1519 1
a1519 1
    const Layout* layout,
d1529 1
a1529 1
    const Layout* layout,
d1539 1
a1539 1
    const Layout* layout,
@


1.50
log
@	* object.h (class Relobj): Drop options parameter from
	gc_process_relocs, scan_relocs, relocate, do_gc_process_relocs,
	do_scan_relocs, do_relocate.  Change all callers.
	(class Sized_relobj): Drop options parameters from
	do_gc_process_relocs, do_scan_relocs, do_relocate,
	do_relocate_sections, relocate_sections, emit_relocs_scan,
	emit_relocs_scan_reltype.  Change all callers.
	(struct Relocate_info): Remove options field and all references to
	it.
	* reloc.h (class Read_relocs): Remove options constructor
	parameter and options_ field.  Change all callers.
	(class Gc_process_relocs, class Scan_relocs): Likewise.
	(class Relocate_task): Likewise.
	* target-reloc.h (scan_relocs): Remove options parameter.  Change
	all callers.
	(scan_relocatable_relocs): Likewise.
	* target.h (class Sized_target): Remove options parameter from
	gc_process_relocs, scan_relocs, scan_relocatable_relocs.  Change
	all callers.
	* gc.h (gc_process_relocs): Remove options parameter.  Change all
	callers.
	* arm.cc: Update functions to remove options parameters.
	* i386.cc: Likewise.
	* powerpc.cc: Likewise.
	* sparc.cc: Likewise.
	* x86_64.cc: Likewise.
	* testsuite/testfile.cc: Likewise.
@
text
@d1554 40
@


1.49
log
@2009-10-25  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_output_section, Arm_relobj): Forward class declarations.
	(Arm_input_section::as_arm_input_section): New method.
	(Arm_output_section): New class definition.
	(Arm_output_section::create_stub_group,
	Arm_output_section::group_sections): New method definitions.
@
text
@d75 1
a75 2
      workqueue->queue_next(new Gc_process_relocs(this->options_,
                                                  this->symtab_,
d83 2
a84 2
      workqueue->queue_next(new Scan_relocs(this->options_, this->symtab_,
                                            this->layout_, this->object_, rd,
d122 1
a122 2
  this->object_->gc_process_relocs(this->options_, this->symtab_, this->layout_,
            	     this->rd_);
d167 1
a167 2
  this->object_->scan_relocs(this->options_, this->symtab_, this->layout_,
			     this->rd_);
d216 1
a216 2
  this->object_->relocate(this->options_, this->symtab_, this->layout_,
			  this->of_);
d359 3
a361 4
Sized_relobj<size, big_endian>::do_gc_process_relocs(const General_options& options,
					       Symbol_table* symtab,
					       Layout* layout,
					       Read_relocs_data* rd)
d382 1
a382 1
              target->gc_process_relocs(options, symtab, layout, this, 
d399 1
a399 2
Sized_relobj<size, big_endian>::do_scan_relocs(const General_options& options,
					       Symbol_table* symtab,
d431 1
a431 1
	    target->scan_relocs(options, symtab, layout, this, p->data_shndx,
d438 1
a438 1
	    this->emit_relocs_scan(options, symtab, layout, local_symbols, p);
d445 1
a445 1
	  target->scan_relocatable_relocs(options, symtab, layout, this,
a506 1
    const General_options& options,
d517 1
a517 1
    this->emit_relocs_scan_reltype<elfcpp::SHT_REL>(options, symtab, layout,
d522 2
a523 3
      this->emit_relocs_scan_reltype<elfcpp::SHT_RELA>(options, symtab,
						       layout, plocal_syms, p,
						       rr);
a533 1
    const General_options& options,
a541 1
    options,
d559 1
a559 2
Sized_relobj<size, big_endian>::do_relocate(const General_options& options,
					    const Symbol_table* symtab,
d585 1
a585 1
  this->relocate_sections(options, symtab, layout, pshdrs, &views);
a791 1
    const General_options& options,
a804 1
  relinfo.options = &options;
d1421 3
a1423 4
Sized_relobj<32, false>::do_gc_process_relocs(const General_options& options,
					Symbol_table* symtab,
					Layout* layout,
					Read_relocs_data* rd);
d1429 3
a1431 4
Sized_relobj<32, true>::do_gc_process_relocs(const General_options& options,
				       Symbol_table* symtab,
				       Layout* layout,
				       Read_relocs_data* rd);
d1437 3
a1439 4
Sized_relobj<64, false>::do_gc_process_relocs(const General_options& options,
					Symbol_table* symtab,
					Layout* layout,
					Read_relocs_data* rd);
d1445 3
a1447 4
Sized_relobj<64, true>::do_gc_process_relocs(const General_options& options,
				       Symbol_table* symtab,
				       Layout* layout,
				       Read_relocs_data* rd);
d1453 1
a1453 2
Sized_relobj<32, false>::do_scan_relocs(const General_options& options,
					Symbol_table* symtab,
d1461 1
a1461 2
Sized_relobj<32, true>::do_scan_relocs(const General_options& options,
				       Symbol_table* symtab,
d1469 1
a1469 2
Sized_relobj<64, false>::do_scan_relocs(const General_options& options,
					Symbol_table* symtab,
d1477 1
a1477 2
Sized_relobj<64, true>::do_scan_relocs(const General_options& options,
				       Symbol_table* symtab,
d1485 1
a1485 2
Sized_relobj<32, false>::do_relocate(const General_options& options,
				     const Symbol_table* symtab,
d1493 1
a1493 2
Sized_relobj<32, true>::do_relocate(const General_options& options,
				    const Symbol_table* symtab,
d1501 1
a1501 2
Sized_relobj<64, false>::do_relocate(const General_options& options,
				     const Symbol_table* symtab,
d1509 1
a1509 2
Sized_relobj<64, true>::do_relocate(const General_options& options,
				    const Symbol_table* symtab,
a1517 1
    const General_options& options,
a1527 1
    const General_options& options,
a1537 1
    const General_options& options,
a1547 1
    const General_options& options,
@


1.48
log
@	* object.h (class Relocate_info): Add reloc_shdr and data_shdr
	fields.
	* object.cc (Sized_relobj::relocate_sections): Set reloc_shdr and
	data_shdr fields of relinfo.
	* i386.cc (class Target_i386::Relocate): Remove ldo_addrs_ field.
	(Target_i386::Relocate::relocate_tls): Don't call fix_up_ldo.  For
	R_386_TLS_LDO_32, adjust based on section flags.
	(Target_i386::Relocate::fix_up_ldo): Remove.
@
text
@d802 1
a802 1
Sized_relobj<size, big_endian>::relocate_sections(
d1539 44
@


1.47
log
@	* gc.h (gc_process_relocs): Check if icf is enabled using new
	function.
	* gold.cc (queue_initial_tasks): Likewise.
	(queue_middle_tasks): Likewise.
	* object.cc (do_layout): Likewise.
	* symtab.cc (is_section_folded): Likewise.
	* main.cc (main): Likewise.
	* reloc.cc (Read_relocs::run): Likewise.
	(Sized_relobj::do_scan_relocs): Likewise.
	* icf.cc (is_function_ctor_or_dtor): New function.
	(Icf::find_identical_sections): Check if function is ctor or dtor when
	safe icf is chosen.
	* options.h (General_options::icf): Change option to be an enum.
	(Icf_status): New enum.
	(icf_enabled): New method.
	(icf_safe_folding): New method.
	(set_icf_status): New method.
	(icf_status_): New variable.
	* (options.cc) (General_options::finalize): Set icf_status_.
	* testsuite/Makefile.am: Add commands to build icf_safe_test. Modify
	icf_test and icf_keep_unique_test to use the --icf enum flag.
	* testsuite/icf_safe_test.sh: New file.
	* testsuite/icf_safe_test.cc: New file.
@
text
@d893 1
d895 1
@


1.46
log
@	* options.h (class General_options): Define
	split_stack_adjust_size parameter.
	* object.h (class Object): Add uses_split_stack_ and
	has_no_split_stack_ fields.  Add uses_split_stack and
	has_no_split_stack accessor functions.  Declare
	handle_split_stack_section.
	(class Reloc_symbol_changes): Define.
	(class Sized_relobj): Define Function_offsets.  Declare
	split_stack_adjust, split_stack_adjust_reltype, and
	find_functions.
	* object.cc (Object::handle_split_stack_section): New function.
	(Sized_relobj::do_layout): Call handle_split_stack_section.
	* dynobj.cc (Sized_dynobj::do_layout): Call
	handle_split_stack_section.
	* reloc.cc (Sized_relobj::relocate_sections): Call
	split_stack_adjust for executable sections in split_stack
	objects.  Pass reloc_map to relocate_section.
	(Sized_relobj::split_stack_adjust): New function.
	(Sized_relobj::split_stack_adjust_reltype): New function.
	(Sized_relobj::find_functions): New function.
	* target-reloc.h: Include "object.h".
	(relocate_section): Add reloc_symbol_changes parameter.  Change
	all callers.
	* target.h (class Target): Add calls_non_split method.  Declare
	do_calls_non_split virtual method.  Declare match_view and
	set_view_to_nop.
	* target.cc: Include "elfcpp.h".
	(Target::do_calls_non_split): New function.
	(Target::match_view): New function.
	(Target::set_view_to_nop): New function.
	* gold.cc (queue_middle_tasks): Give an error if mixing
	split-stack and non-split-stack objects with -r.
	* i386.cc (Target_i386::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_i386::do_calls_non_split): New function.
	* x86_64.cc (Target_x86_64::relocate_section): Add
	reloc_symbol_changes parameter.
	(Target_x86_64::do_calls_non_split): New function.
	* arm.cc (Target_arm::relocate_section): Add reloc_symbol_changes
	parameter.
	* powerpc.cc (Target_powerpc::relocate_section): Add
	reloc_symbol_changes parameter.
	* sparc.cc (Target_sparc::relocate_section): Add
	reloc_symbol_changes parameter.
	* configure.ac: Call AM_CONDITIONAL for the default target.
	* configure: Rebuild.
	* testsuite/Makefile.am (TEST_AS): New variable.
	(check_SCRIPTS): Add split_i386.sh and split_x86_64.sh.
	(check_DATA): Add split_i386 and split_x86_64 files.
	(SPLIT_DEFSYMS): Define.
	(split_i386_[1234n].o): New targets.
	(split_i386_[124]): New targets.
	(split_i386_[1234r].stdout): New targets.
	(split_x86_64_[1234n].o): New targets.
	(split_x86_64_[124]): New targets.
	(split_x86_64_[1234r].stdout): New targets.
	(MOSTLYCLEANFILES): Add new executables.
	* testsuite/split_i386.sh: New file.
	* testsuite/split_x86_64.sh: New file.
	* testsuite/split_i386_1.s: New file.
	* testsuite/split_i386_2.s: New file.
	* testsuite/split_i386_3.s: New file.
	* testsuite/split_i386_4.s: New file.
	* testsuite/split_i386_n.s: New file.
	* testsuite/split_x86_64_1.s: New file.
	* testsuite/split_x86_64_2.s: New file.
	* testsuite/split_x86_64_3.s: New file.
	* testsuite/split_x86_64_4.s: New file.
	* testsuite/split_x86_64_n.s: New file.
	* testsuite/testfile.cc (Target_test): Update relocation_section
	function.
	* testsuite/Makefile.in: Rebuild.
@
text
@d34 1
d72 2
a73 1
  if (parameters->options().gc_sections() || parameters->options().icf())
d425 2
a426 1
      if (parameters->options().gc_sections() || parameters->options().icf())
@


1.45
log
@	* object.h (class Object): Remove target_ field, and target,
	sized_target, and set_target methods.
	(Object::sized_target): Remove.
	(class Sized_relobj): Update declarations.  Remove sized_target.
	* object.cc (Sized_relobj::setup): Remove target parameter.
	Change all callers.
	(Input_objects::add_object): Don't do anything with the target.
	(make_elf_sized_object): Add punconfigured parameter.  Change all
	callers.  Set or test parameter target.
	* dynobj.cc (Sized_dynobj::target): Remove target parameter.
	Change all callers.
	* parameters.cc (Parameters::set_target): Change parameter type to
	be non-const.
	(Parameters::default_target): Remove.
	(set_parameters_target): Change parameter type to be non-const.
	(parameters_force_valid_target): New function.
	(parameters_clear_target): New function.
	* parameters.h (class Parameters): Update declarations.  Remove
	default_target method.  Add sized_target and clear_target
	methods.  Change target_ to be non-const.
	(set_parameters_target): Update declaration.
	(parameters_force_valid_target): Declare.
	(parameters_clear_target): Declare.
	* readsyms.cc (Read_symbols::do_read_symbols): Pass punconfigured
	as NULL if we aren't searching.
	(Add_symbols::run): Don't check for compatible target.
	* fileread.cc (Input_file::open_binary): Call
	parameters_force_valid_target.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (make_sized_plugin_object): Likewise.  Don't call
	set_target on object.
	* dynobj.h (class Sized_dynobj): Update declarations.
	* archive.cc (Archive::get_elf_object_for_member): Return NULL if
	make_elf_object returns NULL.
	(Archive::include_member): Don't check whether object target is
	compatible.
	* output.cc (Output_section::add_input_section): Get target from
	parameters.
	(Output_section::relax_input_section): Likewise.
	* reloc.cc (Sized_relobj::do_gc_process_relocs): Get target from
	parameters.
	(Sized_relobj::do_scan_relocs): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* symtab.cc (Symbol_table::wrap_symbol): Likewise.  Remove object
	parameter.  Change all callers.
	(Symbol_table::add_from_object): Get target from parameters.
	(Symbol_table::add_from_relobj): Don't check object target.
	(Symbol_table::add_from_dynobj): Likewise.
	(Symbol_table::define_special_symbol): Get target from
	parameters.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/binary_unittest.cc (gold_testsuite): Remove target
	parameter.  Change all callers.  Clear parameter target.
	(Binary_test): Test target here.
	* testsuite/object_unittest.cc (gold_testsuite): Remove
	target_test_pointer parameter.  Change all callers.
	(Object_test): Test target here.
@
text
@d891 14
d907 1
a907 5
	  target->relocate_section(&relinfo,
				   sh_type,
				   prelocs,
				   reloc_count,
				   os,
d909 1
a909 3
				   (*pviews)[index].view,
				   (*pviews)[index].address,
				   (*pviews)[index].view_size);
d912 2
a913 6
			      os, output_offset,
			      (*pviews)[index].view,
			      (*pviews)[index].address,
			      (*pviews)[index].view_size,
			      (*pviews)[i].view,
			      (*pviews)[i].view_size);
d918 3
a920 10
	  target->relocate_for_relocatable(&relinfo,
					   sh_type,
					   prelocs,
					   reloc_count,
					   os,
					   output_offset,
					   rr,
					   (*pviews)[index].view,
					   (*pviews)[index].address,
					   (*pviews)[index].view_size,
d1025 238
@


1.44
log
@*** empty log message ***
@
text
@d366 2
a367 1
  Sized_target<size, big_endian>* target = this->sized_target();
d407 2
a408 1
  Sized_target<size, big_endian>* target = this->sized_target();
d807 2
a808 1
  Sized_target<size, big_endian>* target = this->sized_target();
@


1.44.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a33 1
#include "icf.h"
d71 1
a71 2
  if (parameters->options().gc_sections()
      || parameters->options().icf_enabled())
d366 1
a366 2
  Sized_target<size, big_endian>* target =
    parameters->sized_target<size, big_endian>();
d406 1
a406 2
  Sized_target<size, big_endian>* target =
    parameters->sized_target<size, big_endian>();
d421 1
a421 2
      if (parameters->options().gc_sections()
	  || parameters->options().icf_enabled())
d805 1
a805 2
  Sized_target<size, big_endian>* target =
    parameters->sized_target<size, big_endian>();
a886 1
      relinfo.reloc_shdr = p;
a887 15
      relinfo.data_shdr = pshdrs + index * This::shdr_size;
      unsigned char* view = (*pviews)[index].view;
      Address address = (*pviews)[index].address;
      section_size_type view_size = (*pviews)[index].view_size;

      Reloc_symbol_changes* reloc_map = NULL;
      if (this->uses_split_stack() && output_offset != invalid_address)
	{
	  typename This::Shdr data_shdr(pshdrs + index * This::shdr_size);
	  if ((data_shdr.get_sh_flags() & elfcpp::SHF_EXECINSTR) != 0)
	    this->split_stack_adjust(symtab, pshdrs, sh_type, index,
				     prelocs, reloc_count, view, view_size,
				     &reloc_map);
	}

d890 5
a894 1
	  target->relocate_section(&relinfo, sh_type, prelocs, reloc_count, os,
d896 3
a898 1
				   view, address, view_size, reloc_map);
d901 6
a906 2
			      os, output_offset, view, address, view_size,
			      (*pviews)[i].view, (*pviews)[i].view_size);
d911 10
a920 3
	  target->relocate_for_relocatable(&relinfo, sh_type, prelocs,
					   reloc_count, os, output_offset, rr,
					   view, address, view_size,
a1024 238
// If an object was compiled with -fsplit-stack, this is called to
// check whether any relocations refer to functions defined in objects
// which were not compiled with -fsplit-stack.  If they were, then we
// need to apply some target-specific adjustments to request
// additional stack space.

template<int size, bool big_endian>
void
Sized_relobj<size, big_endian>::split_stack_adjust(
    const Symbol_table* symtab,
    const unsigned char* pshdrs,
    unsigned int sh_type,
    unsigned int shndx,
    const unsigned char* prelocs,
    size_t reloc_count,
    unsigned char* view,
    section_size_type view_size,
    Reloc_symbol_changes** reloc_map)
{
  if (sh_type == elfcpp::SHT_REL)
    this->split_stack_adjust_reltype<elfcpp::SHT_REL>(symtab, pshdrs, shndx,
						      prelocs, reloc_count,
						      view, view_size,
						      reloc_map);
  else
    {
      gold_assert(sh_type == elfcpp::SHT_RELA);
      this->split_stack_adjust_reltype<elfcpp::SHT_RELA>(symtab, pshdrs, shndx,
							 prelocs, reloc_count,
							 view, view_size,
							 reloc_map);
    }
}

// Adjust for -fsplit-stack, templatized on the type of the relocation
// section.

template<int size, bool big_endian>
template<int sh_type>
void
Sized_relobj<size, big_endian>::split_stack_adjust_reltype(
    const Symbol_table* symtab,
    const unsigned char* pshdrs,
    unsigned int shndx,
    const unsigned char* prelocs,
    size_t reloc_count,
    unsigned char* view,
    section_size_type view_size,
    Reloc_symbol_changes** reloc_map)
{
  typedef typename Reloc_types<sh_type, size, big_endian>::Reloc Reltype;
  const int reloc_size = Reloc_types<sh_type, size, big_endian>::reloc_size;

  size_t local_count = this->local_symbol_count();

  std::vector<section_offset_type> non_split_refs;

  const unsigned char* pr = prelocs;
  for (size_t i = 0; i < reloc_count; ++i, pr += reloc_size)
    {
      Reltype reloc(pr);

      typename elfcpp::Elf_types<size>::Elf_WXword r_info = reloc.get_r_info();
      unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);
      if (r_sym < local_count)
	continue;

      const Symbol* gsym = this->global_symbol(r_sym);
      gold_assert(gsym != NULL);
      if (gsym->is_forwarder())
	gsym = symtab->resolve_forwards(gsym);

      // See if this relocation refers to a function defined in an
      // object compiled without -fsplit-stack.  Note that we don't
      // care about the type of relocation--this means that in some
      // cases we will ask for a large stack unnecessarily, but this
      // is not fatal.  FIXME: Some targets have symbols which are
      // functions but are not type STT_FUNC, e.g., STT_ARM_TFUNC.
      if (gsym->type() == elfcpp::STT_FUNC
	  && !gsym->is_undefined()
	  && gsym->source() == Symbol::FROM_OBJECT
	  && !gsym->object()->uses_split_stack())
	{
	  section_offset_type offset =
	    convert_to_section_size_type(reloc.get_r_offset());
	  non_split_refs.push_back(offset);
	}
    }

  if (non_split_refs.empty())
    return;

  // At this point, every entry in NON_SPLIT_REFS indicates a
  // relocation which refers to a function in an object compiled
  // without -fsplit-stack.  We now have to convert that list into a
  // set of offsets to functions.  First, we find all the functions.

  Function_offsets function_offsets;
  this->find_functions(pshdrs, shndx, &function_offsets);
  if (function_offsets.empty())
    return;

  // Now get a list of the function with references to non split-stack
  // code.

  Function_offsets calls_non_split;
  for (std::vector<section_offset_type>::const_iterator p
	 = non_split_refs.begin();
       p != non_split_refs.end();
       ++p)
    {
      Function_offsets::const_iterator low = function_offsets.lower_bound(*p);
      if (low == function_offsets.end())
	--low;
      else if (low->first == *p)
	;
      else if (low == function_offsets.begin())
	continue;
      else
	--low;

      calls_non_split.insert(*low);
    }
  if (calls_non_split.empty())
    return;

  // Now we have a set of functions to adjust.  The adjustments are
  // target specific.  Besides changing the output section view
  // however, it likes, the target may request a relocation change
  // from one global symbol name to another.

  for (Function_offsets::const_iterator p = calls_non_split.begin();
       p != calls_non_split.end();
       ++p)
    {
      std::string from;
      std::string to;
      parameters->target().calls_non_split(this, shndx, p->first, p->second,
					   view, view_size, &from, &to);
      if (!from.empty())
	{
	  gold_assert(!to.empty());
	  Symbol* tosym = NULL;

	  // Find relocations in the relevant function which are for
	  // FROM.
	  pr = prelocs;
	  for (size_t i = 0; i < reloc_count; ++i, pr += reloc_size)
	    {
	      Reltype reloc(pr);

	      typename elfcpp::Elf_types<size>::Elf_WXword r_info =
		reloc.get_r_info();
	      unsigned int r_sym = elfcpp::elf_r_sym<size>(r_info);
	      if (r_sym < local_count)
		continue;

	      section_offset_type offset =
		convert_to_section_size_type(reloc.get_r_offset());
	      if (offset < p->first
		  || (offset
		      >= (p->first
			  + static_cast<section_offset_type>(p->second))))
		continue;

	      const Symbol* gsym = this->global_symbol(r_sym);
	      if (from == gsym->name())
		{
		  if (tosym == NULL)
		    {
		      tosym = symtab->lookup(to.c_str());
		      if (tosym == NULL)
			{
			  this->error(_("could not convert call "
					"to '%s' to '%s'"),
				      from.c_str(), to.c_str());
			  break;
			}
		    }

		  if (*reloc_map == NULL)
		    *reloc_map = new Reloc_symbol_changes(reloc_count);
		  (*reloc_map)->set(i, tosym);
		}
	    }
	}
    }
}

// Find all the function in this object defined in section SHNDX.
// Store their offsets in the section in FUNCTION_OFFSETS.

template<int size, bool big_endian>
void
Sized_relobj<size, big_endian>::find_functions(
    const unsigned char* pshdrs,
    unsigned int shndx,
    Sized_relobj<size, big_endian>::Function_offsets* function_offsets)
{
  // We need to read the symbols to find the functions.  If we wanted
  // to, we could cache reading the symbols across all sections in the
  // object.
  const unsigned int symtab_shndx = this->symtab_shndx_;
  typename This::Shdr symtabshdr(pshdrs + symtab_shndx * This::shdr_size);
  gold_assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);

  typename elfcpp::Elf_types<size>::Elf_WXword sh_size =
    symtabshdr.get_sh_size();
  const unsigned char* psyms = this->get_view(symtabshdr.get_sh_offset(),
					      sh_size, true, true);

  const int sym_size = This::sym_size;
  const unsigned int symcount = sh_size / sym_size;
  for (unsigned int i = 0; i < symcount; ++i, psyms += sym_size)
    {
      typename elfcpp::Sym<size, big_endian> isym(psyms);

      // FIXME: Some targets can have functions which do not have type
      // STT_FUNC, e.g., STT_ARM_TFUNC.
      if (isym.get_st_type() != elfcpp::STT_FUNC
	  || isym.get_st_size() == 0)
	continue;

      bool is_ordinary;
      unsigned int sym_shndx = this->adjust_sym_shndx(i, isym.get_st_shndx(),
						      &is_ordinary);
      if (!is_ordinary || sym_shndx != shndx)
	continue;

      section_offset_type value =
	convert_to_section_size_type(isym.get_st_value());
      section_size_type fnsize =
	convert_to_section_size_type(isym.get_st_size());

      (*function_offsets)[value] = fnsize;
    }
}

@


1.43
log
@	PR 10244
	* reloc.cc (relocate_sections): Skip empty relocation sections.
@
text
@d68 6
a73 6
  // If garbage collection is desired, we must process the relocs
  // instead of scanning the relocs as reloc processing is necessary 
  // to determine unused sections.
  if (parameters->options().gc_sections())
    {  
      workqueue->queue_next(new Gc_process_relocs(this->options_, 
d421 1
a421 1
      if (parameters->options().gc_sections())
@


1.42
log
@	PR 9918
	* target-reloc.h (relocate_section): Pass output_section to
	relocate.
	* i386.cc (Target_i386::should_apply_static_reloc): Add
	output_section parameter.  Change all callers.
	(Target_i386::Relocate::relocate): Add output_section parameter.
	* x86_64.cc (Target_x86_64::Relocate::relocate): Likewise.
	* sparc.cc (Target_sparc::Relocate::relocate): Likewise.
	* powerpc.cc (Target_powerpc::Relocate::relocate): Likewise.
	* testsuite/two_file_shared.sh: New script.
	* testsuite/Makefile.am (check_SCRIPTS): Add two_file_shared.sh.
	(check_DATA): Add two_file_shared.dbg.
	(two_file_shared.dbg): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d825 4
a857 1
      off_t sh_size = shdr.get_sh_size();
@


1.41
log
@2009-01-20  Sriraman Tallam <tmsriram@@google.com>

	* Makefile.am (CCFILES): Add gc.cc.
	(HFILES): Add gc.h.
	* Makefile.in: Regenerate.
	* gold.cc (Gc_runner): New class.
	(queue_initial_tasks): Call garbage collection related tasks
	when corresponding options are invoked.
	(queue_middle_gc_tasks): New function.
	(queue_middle_tasks): Reorder tasks to allow relocs to be read and
	processed early before laying out sections during garbage collection.
	* gold.h (queue_middle_gc_tasks): New function.
	(is_prefix_of): Move from "layout.cc".
	* i386.cc (Target_i386::gc_process_relocs): New function.
	* layout.cc (is_prefix_of): Remove. Move to "gold.h"
	* main.cc (main): Create object of class "Garbage_collection".
	* object.cc (Relobj::copy_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Sized_relobj::do_layout): Allow this function to be called twice
	during garbage collection and defer layout of section during the
	first call.
	* object.h (Relobj::get_symbols_data): New function.
	(Relobj::is_section_name_included): New function.
	(Relobj::copy_symbols_data): New function.
	(Relobj::set_symbols_data): New function.
	(Relobj::get_relocs_data): New function.
	(Relobj::set_relocs_data): New function.
	(Relobj::is_output_section_offset_invalid): New pure virtual function.
	(Relobj::gc_process_relocs): New function.
	(Relobj::do_gc_process_relocs): New pure virtual function.
	(Relobj::sd_): New data member.
	(Sized_relobj::is_output_section_offset_invalid): New function.
	(Sized_relobj::do_gc_process_relocs): New function.
	* options.h (General_options::gc_sections): Modify to not be a no-op.
	(General_options::print_gc_sections): New option.
	* plugin.cc (Plugin_finish::run): Remove function call to
	Plugin_manager::layout_deferred_objects.  Move it to "gold.cc".
	* powerpc.cc (Target_powerpc::gc_process_relocs): New function.
	* reloc.cc (Read_relocs::run): Add task to process relocs and
	determine unreferenced sections when doing garbage collection.
	(Gc_process_relocs): New class.
	(Sized_relobj::do_gc_process_relocs): New function.
	(Sized_relobj::do_scan_relocs): Don't try to scan the relocs for
	sections that are garbage collected.
	* reloc.h (Gc_process_relocs): New class.
	* sparc.cc (Target_sparc::gc_process_relocs): New function.
	* symtab.cc (Symbol::should_add_dynsym_entry): Do not add entries for
	symbols whose corresponding sections are garbage collected.
	(Symbol_table::Symbol_table): Add new parameter for the garbage
	collection object.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::resolve): Do not treat symbols seen in dynamic objects
	as garbage.
	(Symbol_table::add_from_object): Likewise.
	(Symbol_table::add_from_relobj): When building shared objects, do not
	treat externally visible symbols as garbage.
	(Symbol_table::sized_finalize_symbol): Do not check dynamic symbol
	table information for static and relocatable links.
	* symtab.h (Symbol_table::set_gc): New function.
	(Symbol_table::gc): New function.
	(Symbol_table::gc_mark_undef_symbols): New function.
	(Symbol_table::gc_mark_symbol_for_shlib): New function.
	(Symbol_table::gc_mark_dyn_syms): New function.
	(Symbol_table::gc_): New data member.
	* target.h (Sized_target::gc_process_relocs): New pure virtual
	function.
	* x86_64.cc (Target_x86_64::gc_process_relocs): New function.
	* testsuite/testfile.cc (Target_test::gc_process_relocs): New function.
@
text
@d282 3
a284 1
      // relocatable link or we need to emit relocations.
@


1.40
log
@	* target-reloc.h (Default_scan_relocatable_relocs): Only discard
	r_type == 0 for a local symbol with r_sym == 0.
	(scan_relocatable_relocs): Pass r_sym to
	local_non_section_strategy.
	* reloc.cc (Emit_relocs_strategy::local_non_section_strategy): Add
	r_sym parameter.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d65 1
d68 19
a86 3
  workqueue->queue_next(new Scan_relocs(this->options_, this->symtab_,
					this->layout_, this->object_, rd,
					this->symtab_lock_, this->blocker_));
d97 37
d353 41
d416 8
d1186 36
@


1.39
log
@	* reloc.cc (Sized_relobj::do_read_relocs): Use constant invalid_address
	instead of -1U.
@
text
@d371 1
a371 1
  local_non_section_strategy(unsigned int, Relobj*)
@


1.38
log
@	* mapfile.cc (Mapfile::print_input_section): Change -1U to -1ULL.
	* object.cc (Sized_relobj::do_layout): Use constant invalid_address
	instead of -1U.
	(Sized_relobj::do_finalize_local_symbols): Likewise.
	(Sized_relobj::map_to_kept_section): Likewise.
	* object.h (Sized_relobj::invalid_address): New constant.
	(Sized_relobj::do_output_section_offset): Check for invalid_address
	and return -1ULL.
	* output.cc (Output_reloc::local_section_offset): Use constant
	invalid_address instead of -1U.
	(Output_reloc::get_address): Likewise.
	(Output_section::output_address): Change -1U to -1ULL.
	* output.h (Output_reloc::invalid_address): New constant.
	* reloc.cc (Sized_relobj::write_sections): Use constant
	invalid_address instead of -1U.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (Symbol_table::sized_finalize_symbol): Handle symbol
	values for merge sections.
	* target-reloc.h (relocate_for_relocatable): Use constant
	invalid_address instead of -1U.
@
text
@d277 1
a277 1
      sr.needs_special_offset_handling = out_offsets[shndx] == -1U;
@


1.37
log
@	Handle output sections with more than 0x7fffffff bytes.
	* object.h (class Relobj): Change map_to_output_ to
	output_sections_, and just keep a section pointer.  Change all
	uses.  Move comdat group support to Sized_relobj.
	(Relobj::is_section_specially_mapped): Remove.
	(Relobj::output_section): Remove poff parameter.  Change all
	callers.
	(Relobj::output_section_offset): New function.
	(Relobj::set_section_offset): Rewrite.
	(Relobj::map_to_output): Remove.
	(Relobj::output_sections): New function.
	(Relobj::do_output_section_offset): New pure virtual function.
	(Relobj::do_set_section_offset): Likewise.
	(class Sized_relobj): Add section_offsets_ field.  Add comdat
	group support from Relobj.  Update declarations.
	(Sized_relobj::get_output_section_offset): New function.
	(Sized_relobj::do_output_section_offset): New function.
	(Sized_relobj::do_set_section_offset): New function.
	* object.cc (Relobj::output_section_address): Remove.
	(Sized_relobj::Sized_relobj): Initialize new fields.
	(Sized_relobj::include_section_group): Cast find_kept_object to
	Sized_relobj.
	(Sized_relobj::include_linkonce_section): Likewise.
	(Sized_relobj::do_layout): Use separate arrays for output section
	and output offset.
	(Sized_relobj::do_count_local_symbols): Change map_to_output to
	output_sections.
	(Sized_relobj::do_finalize_local_symbols): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_local_symbols): Likewise.
	(map_to_kept_section): Compute output address directly.
	* reloc.cc (Sized_relobj::do_read_relocs): Change map_to_output to
	output_sections and section_offsets.
	(Sized_relobj::write_sections): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* symtab.cc (sized_finalize_symbol): Use output_section_offset.
	* output.h (class Output_reloc): Update declarations.  Change
	u2_.relobj to Sized_relobj*.
	(class Output_data_reloc): Change add functions to use
	Sized_relobj*.
	* output.cc (Output_reloc::Output_reloc): Change relobj to
	Sized_relobj*.
	(Output_reloc::local_section_offset): Change return type to
	Elf_Addr.  Use get_output_section_offset.
	(Output_reloc::get_address): Likewise.
	(Output_section::is_input_address_mapped): Don't call
	is_section_specially_mapped.
	(Output_section::output_offset): Likewise.
	(Output_section::output_address): Likewise.
	(Output_section::starting_output_address): Likewise.
	* copy-relocs.cc (Copy_relocs::copy_reloc): Change object
	parameter to Sized_relobj*.
	(Copy_relocs::need_copy_reloc): Likewise.
	(Copy_relocs::save): Likewise.
	* copy-relocs.h (class Copy_relocs): Update declarations.
	(class Copy_relocs::Copy_reloc_entry): Change constructor to use
	Sized_relobj*.  Change relobj_ field to Sized_relobj*.
	* target-reloc.h (relocate_for_relocatable): Change
	offset_in_output_section type to Elf_Addr.  Change code that uses
	it as well.
	* layout.cc (Layout::layout): Always set *off.
	* mapfile.cc (Mapfile::print_input_section): Use
	output_section_offset.
	* i386.cc (Target_i386::copy_reloc): Change object parameter to
	Sized_relobj*.
	* powerpc.cc (Target_powerpc::copy_reloc): Likewise.
	* sparc.cc (Target_sparc::copy_reloc): Likewise.
	* x86_64.cc (Target_x86_64::copy_reloc): Likewise.
@
text
@d589 2
a590 2
      // However, if OUTPUT_OFFSET == -1U, then input data is handled
      // specially--e.g., a .eh_frame section.  The relocation
d622 1
a622 1
      if (output_offset != -1U)
d636 1
a636 1
      gold_assert(output_offset == -1U
d644 1
a644 1
	  if (output_offset != -1U)
d655 1
a655 1
	  if (output_offset == -1U)
d670 1
a670 1
      if (output_offset != -1U)
d674 1
a674 1
      pvs->is_input_output_view = output_offset == -1U;
d775 1
a775 1
      gold_assert(output_offset != -1U
d787 1
a787 1
				   output_offset == -1U,
@


1.36
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d196 2
a197 1
  std::vector<Map_to_output>& map_sections(this->map_to_output());
d220 1
a220 1
      Output_section* os = map_sections[shndx].output_section;
d277 1
a277 1
      sr.needs_special_offset_handling = map_sections[shndx].offset == -1;
d538 2
a539 1
  const std::vector<Map_to_output>& map_sections(this->map_to_output());
d551 1
a551 1
      const Output_section* os = map_sections[i].output_section;
d554 1
a554 1
      off_t output_offset = map_sections[i].offset;
d589 1
a589 1
      // However, if OUTPUT_OFFSET == -1, then input data is handled
d607 1
a607 1
      off_t output_section_size;
d611 1
a611 1
	  output_section_size = os->data_size();
d616 2
a617 1
	  output_section_size = os->postprocessing_buffer_size();
d622 1
a622 1
      if (output_offset != -1)
d636 2
a637 4
      gold_assert(output_offset == -1
		  || (output_offset >= 0
		      && (output_offset + static_cast<off_t>(view_size)
                          <= output_section_size)));
d644 1
a644 1
	  if (output_offset != -1)
d655 1
a655 1
	  if (output_offset == -1)
d670 1
a670 1
      if (output_offset != -1)
d674 1
a674 1
      pvs->is_input_output_view = output_offset == -1;
d702 2
a703 1
  const std::vector<Map_to_output>& map_sections(this->map_to_output());
d728 1
a728 1
      Output_section* os = map_sections[index].output_section;
d735 1
a735 1
      off_t output_offset = map_sections[index].offset;
d775 1
a775 1
      gold_assert(output_offset != -1
d787 1
a787 1
				   output_offset == -1,
d830 1
a830 1
    off_t offset_in_output_section,
d866 1
a866 1
    off_t offset_in_output_section,
@


1.35
log
@	* copy-relocs.cc: New file.
	* copy-relocs.h: New file.
	* reloc.cc: Remove Copy_relocs code.
	* reloc.h: Likewise.
	* reloc-types.h (struct Reloc_types) [both versions]: Add
	get_reloc_addend_noerror.
	* output.h (class Output_data_reloc<elfcpp::SHT_REL>): Add
	variants of add_global which take an addend which must be zero.
	* i386.cc: Include "copy-relocs.h".
	(class Target_i386): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_i386::copy_reloc): Rewrite to pass to Copy_relocs class.
	Change all callers.
	(Target_i386::do_finalize_sections): Change handling of
	copy_relocs_.
	* sparc.cc: Include "copy-relocs.h".
	(class Target_sparc): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_sparc::copy_reloc): Rewrite to pass to Copy_relocs class.
	Change all callers.
	(Target_sparc::do_finalize_sections): Change handling of
	copy_relocs_.
	* x86_64.cc: Include "copy-relocs.h".
	(class Target_x86_64): Change type of copy_relocs_ to variable,
	update initializer.
	(Target_x86_64::copy_reloc): Rewrite to pass to Copy_relocs
	class.  Change all callers.
	(Target_x86_64::do_finalize_sections): Change handling of
	copy_relocs_.
	* Makefile.am (CCFILES): Add copy-relocs.cc.
	(HFILES): Add copy-relocs.h.
@
text
@d211 1
a211 1
      unsigned int shndx = shdr.get_sh_info();
d236 1
a236 1
      if (shdr.get_sh_link() != this->symtab_shndx_)
d240 1
a240 1
		      i, shdr.get_sh_link());
d510 2
a511 1
  this->write_local_symbols(of, layout->sympool(), layout->dynpool());
d718 1
a718 1
      unsigned int index = shdr.get_sh_info();
d739 1
a739 1
      if (shdr.get_sh_link() != this->symtab_shndx_)
d743 1
a743 1
		     i, shdr.get_sh_link());
@


1.34
log
@	* fileread.cc (File_read::find_view): Add byteshift and vshifted
	parameters.  Update for new key type to views_.  Change all
	callers.
	(File_read::read): Adjust for byteshift in returned view.
	(File_read::add_view): New function, broken out of
	find_and_make_view.
	(File_read::make_view): New function, broken out of
	find_and_make_view.
	(File_read::find_or_make_view): Add offset and aligned
	parameters.  Rewrite accordingly.  Change all callers.
	(File_read::get_view): Add offset and aligned parameters.  Adjust
	for byteshift in return value.
	(File_read::get_lasting_view): Likewise.
	* fileread.h (class File_read): Update declarations.
	(class File_read::View): Add byteshift_ field.  Add byteshift to
	constructor.  Add byteshift method.
	* archive.h (Archive::clear_uncached_views): New function.
	(Archive::get_view): Add aligned parameter.  Change all callers.
	* object.h (Object::get_view): Add aligned parameter.  Change all
	callers.
	(Object::get_lasting_view): Likewise.

	* fileread.cc (File_read::release): Don't call clear_views if
	there are multiple objects.
	* fileread.h (File_read::clear_uncached_views): New function.
	* archive.cc (Add_archive_symbols::run): Call clear_uncached_views
	on the archive.
@
text
@a954 138
// Copy_relocs::Copy_reloc_entry methods.

// Return whether we should emit this reloc.  We should emit it if the
// symbol is still defined in a dynamic object.  If we should not emit
// it, we clear it, to save ourselves the test next time.

template<int size, bool big_endian>
bool
Copy_relocs<size, big_endian>::Copy_reloc_entry::should_emit()
{
  if (this->sym_ == NULL)
    return false;
  if (this->sym_->is_from_dynobj())
    return true;
  this->sym_ = NULL;
  return false;
}

// Emit a reloc into a SHT_REL section.

template<int size, bool big_endian>
void
Copy_relocs<size, big_endian>::Copy_reloc_entry::emit(
    Output_data_reloc<elfcpp::SHT_REL, true, size, big_endian>* reloc_data)
{
  this->sym_->set_needs_dynsym_entry();
  reloc_data->add_global(this->sym_, this->reloc_type_, this->output_section_,
                         this->relobj_, this->shndx_, this->address_);
}

// Emit a reloc into a SHT_RELA section.

template<int size, bool big_endian>
void
Copy_relocs<size, big_endian>::Copy_reloc_entry::emit(
    Output_data_reloc<elfcpp::SHT_RELA, true, size, big_endian>* reloc_data)
{
  this->sym_->set_needs_dynsym_entry();
  reloc_data->add_global(this->sym_, this->reloc_type_, this->output_section_,
                         this->relobj_, this->shndx_, this->address_,
			 this->addend_);
}

// Copy_relocs methods.

// Return whether we need a COPY reloc for a relocation against GSYM.
// The relocation is being applied to section SHNDX in OBJECT.

template<int size, bool big_endian>
bool
Copy_relocs<size, big_endian>::need_copy_reloc(
    const General_options*,
    Relobj* object,
    unsigned int shndx,
    Sized_symbol<size>* sym)
{
  // FIXME: Handle -z nocopyrelocs.

  if (sym->symsize() == 0)
    return false;

  // If this is a readonly section, then we need a COPY reloc.
  // Otherwise we can use a dynamic reloc.
  if ((object->section_flags(shndx) & elfcpp::SHF_WRITE) == 0)
    return true;

  return false;
}

// Save a Rel reloc.

template<int size, bool big_endian>
void
Copy_relocs<size, big_endian>::save(
    Symbol* sym,
    Relobj* relobj,
    unsigned int shndx,
    Output_section* output_section,
    const elfcpp::Rel<size, big_endian>& rel)
{
  unsigned int reloc_type = elfcpp::elf_r_type<size>(rel.get_r_info());
  this->entries_.push_back(Copy_reloc_entry(sym, reloc_type, relobj, shndx,
                                            output_section,
                                            rel.get_r_offset(), 0));
}

// Save a Rela reloc.

template<int size, bool big_endian>
void
Copy_relocs<size, big_endian>::save(
    Symbol* sym,
    Relobj* relobj,
    unsigned int shndx,
    Output_section* output_section,
    const elfcpp::Rela<size, big_endian>& rela)
{
  unsigned int reloc_type = elfcpp::elf_r_type<size>(rela.get_r_info());
  this->entries_.push_back(Copy_reloc_entry(sym, reloc_type, relobj, shndx,
                                            output_section,
					    rela.get_r_offset(),
					    rela.get_r_addend()));
}

// Return whether there are any relocs to emit.  We don't want to emit
// a reloc if the symbol is no longer defined in a dynamic object.

template<int size, bool big_endian>
bool
Copy_relocs<size, big_endian>::any_to_emit()
{
  for (typename Copy_reloc_entries::iterator p = this->entries_.begin();
       p != this->entries_.end();
       ++p)
    {
      if (p->should_emit())
	return true;
    }
  return false;
}

// Emit relocs.

template<int size, bool big_endian>
template<int sh_type>
void
Copy_relocs<size, big_endian>::emit(
    Output_data_reloc<sh_type, true, size, big_endian>* reloc_data)
{
  for (typename Copy_reloc_entries::iterator p = this->entries_.begin();
       p != this->entries_.end();
       ++p)
    {
      if (p->should_emit())
	p->emit(reloc_data);
    }
}

d1051 1
a1051 2
// Instantiate the templates we need.  We could use the configure
// script to restrict this to only the ones for implemented targets.
a1170 76
class Copy_relocs<32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Copy_relocs<32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Copy_relocs<64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Copy_relocs<64, true>;
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Copy_relocs<32, false>::emit<elfcpp::SHT_REL>(
    Output_data_reloc<elfcpp::SHT_REL, true, 32, false>*);
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Copy_relocs<32, true>::emit<elfcpp::SHT_REL>(
    Output_data_reloc<elfcpp::SHT_REL, true, 32, true>*);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Copy_relocs<64, false>::emit<elfcpp::SHT_REL>(
    Output_data_reloc<elfcpp::SHT_REL, true, 64, false>*);
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Copy_relocs<64, true>::emit<elfcpp::SHT_REL>(
    Output_data_reloc<elfcpp::SHT_REL, true, 64, true>*);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
void
Copy_relocs<32, false>::emit<elfcpp::SHT_RELA>(
    Output_data_reloc<elfcpp::SHT_RELA , true, 32, false>*);
#endif

#ifdef HAVE_TARGET_32_BIG
template
void
Copy_relocs<32, true>::emit<elfcpp::SHT_RELA>(
    Output_data_reloc<elfcpp::SHT_RELA, true, 32, true>*);
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
void
Copy_relocs<64, false>::emit<elfcpp::SHT_RELA>(
    Output_data_reloc<elfcpp::SHT_RELA, true, 64, false>*);
#endif

#ifdef HAVE_TARGET_64_BIG
template
void
Copy_relocs<64, true>::emit<elfcpp::SHT_RELA>(
    Output_data_reloc<elfcpp::SHT_RELA, true, 64, true>*);
#endif

#ifdef HAVE_TARGET_32_LITTLE
template
@


1.33
log
@Update copyright years.  Update language files.
@
text
@d200 1
a200 1
					       true);
d272 1
a272 1
					   true);
d294 1
a294 1
						 locsize, true);
d468 1
a468 1
					       true);
d748 1
a748 1
						    sh_size, false);
@


1.32
log
@Read input scripts which look like input objects with proper
serialization.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.31
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d67 3
a69 3
  workqueue->queue_front(new Scan_relocs(this->options_, this->symtab_,
					 this->layout_, this->object_, rd,
					 this->symtab_lock_, this->blocker_));
@


1.30
log
@Implement -q/--emit-relocs.
@
text
@d232 2
a233 2
	  && !parameters->output_is_object()
	  && !parameters->emit_relocs())
d320 1
a320 1
      if (!parameters->output_is_object())
d332 1
a332 1
	  if (parameters->emit_relocs())
d558 2
a559 1
      if ((parameters->output_is_object() || parameters->emit_relocs())
d735 1
a735 1
      if (parameters->output_is_object())
d777 1
a777 1
      if (!parameters->output_is_object())
d788 1
a788 1
	  if (parameters->emit_relocs())
@


1.29
log
@Initial -r support.
@
text
@d32 1
d227 8
a234 7
      // relocatable link.
      if (!parameters->output_is_object())
	{
	  typename This::Shdr secshdr(pshdrs + shndx * This::shdr_size);
	  if ((secshdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0)
	    continue;
	}
d277 1
d321 14
a334 6
	target->scan_relocs(options, symtab, layout, this, p->data_shndx,
			    p->sh_type, p->contents->data(), p->reloc_count,
			    p->output_section,
			    p->needs_special_offset_handling,
			    this->local_symbol_count_,
			    local_symbols);
d362 92
d558 1
a558 1
      if (parameters->output_is_object()
d563 4
a566 3
	  // This is a reloc section in a relocatable link.  We don't
	  // need to read the input file.  The size and file offset
	  // are stored in the Relocatable_relocs structure.
d777 19
a795 9
	target->relocate_section(&relinfo,
				 sh_type,
				 prelocs,
				 reloc_count,
				 os,
				 output_offset == -1,
				 (*pviews)[index].view,
				 (*pviews)[index].address,
				 (*pviews)[index].view_size);
d813 69
@


1.28
log
@Reduce the number of system calls.  Use readv instead of pread.  Do
better handling of cached views.
@
text
@d225 8
a232 4
      // GOT and PLT entries.  So we skip them.
      typename This::Shdr secshdr(pshdrs + shndx * This::shdr_size);
      if ((secshdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0)
	continue;
d317 23
a339 5
      target->scan_relocs(options, symtab, layout, this, p->data_shndx,
			  p->sh_type, p->contents->data(), p->reloc_count,
			  p->output_section, p->needs_special_offset_handling,
			  this->local_symbol_count_,
			  local_symbols);
d455 23
d630 2
d672 26
a697 9
      target->relocate_section(&relinfo,
			       sh_type,
			       prelocs,
			       reloc_count,
			       os,
			       output_offset == -1,
			       (*pviews)[index].view,
			       (*pviews)[index].address,
			       (*pviews)[index].view_size);
@


1.27
log
@Correct handling of non-section symbol in merged section.  Avoid some
64-bit signed/unsigned warnings.
@
text
@d25 2
d164 5
d386 3
d391 9
d408 1
a408 1
					       Views* pviews) const
d413 3
d493 7
a499 1
	    this->read(shdr.get_sh_offset(), view_size, view);
d508 5
a512 1
	      this->read(shdr.get_sh_offset(), view_size, view);
d524 8
@


1.26
log
@Speed up relocations against local symbols in merged sections.
@
text
@d462 2
a463 1
		      && output_offset + view_size <= output_section_size));
@


1.25
log
@Convert more instances of off_t to be 32-bit types.
@
text
@a25 1
#include "object.h"
d28 2
d347 4
d355 4
d596 70
d997 20
@


1.24
log
@Rewrite workqueue.  This version eliminates the master thread, and
reduces the amount of locking required to find a new thread to run.
@
text
@d436 1
a436 1
      off_t view_size;
d440 1
a440 1
	  view_size = shdr.get_sh_size();
d445 1
a445 1
	  view_size = output_section_size;
@


1.23
log
@From Cary Coutant: More support for generating shared libraries.
@
text
@d40 2
a41 2
Task::Is_runnable_type
Read_relocs::is_runnable(Workqueue*)
d43 1
a43 1
  return this->object_->is_locked() ? IS_LOCKED : IS_RUNNABLE;
d48 2
a49 2
Task_locker*
Read_relocs::locks(Workqueue*)
d51 1
a51 1
  return new Task_locker_obj<Object>(*this->object_);
d61 2
d83 2
a84 2
Task::Is_runnable_type
Scan_relocs::is_runnable(Workqueue*)
d86 5
a90 3
  if (!this->symtab_lock_->is_writable() || this->object_->is_locked())
    return IS_LOCKED;
  return IS_RUNNABLE;
d96 2
a97 1
class Scan_relocs::Scan_relocs_locker : public Task_locker
d99 3
a101 18
 public:
  Scan_relocs_locker(Object* object, Task_token& symtab_lock, Task* task,
		     Task_token& blocker, Workqueue* workqueue)
    : objlock_(*object), symtab_locker_(symtab_lock, task),
      blocker_(blocker, workqueue)
  { }

 private:
  Task_locker_obj<Object> objlock_;
  Task_locker_write symtab_locker_;
  Task_locker_block blocker_;
};

Task_locker*
Scan_relocs::locks(Workqueue* workqueue)
{
  return new Scan_relocs_locker(this->object_, *this->symtab_lock_, this,
				*this->blocker_, workqueue);
d111 1
d128 2
a129 2
Task::Is_runnable_type
Relocate_task::is_runnable(Workqueue*)
d133 1
a133 1
    return IS_BLOCKED;
d136 1
a136 1
    return IS_LOCKED;
d138 1
a138 1
  return IS_RUNNABLE;
d143 1
d145 2
a146 1
class Relocate_task::Relocate_locker : public Task_locker
d148 4
a151 22
 public:
  Relocate_locker(Task_token& input_sections_blocker,
		  Task_token& final_blocker, Workqueue* workqueue,
		  Object* object)
    : input_sections_blocker_(input_sections_blocker, workqueue),
      final_blocker_(final_blocker, workqueue),
      objlock_(*object)
  { }

 private:
  Task_block_token input_sections_blocker_;
  Task_block_token final_blocker_;
  Task_locker_obj<Object> objlock_;
};

Task_locker*
Relocate_task::locks(Workqueue* workqueue)
{
  return new Relocate_locker(*this->input_sections_blocker_,
			     *this->final_blocker_,
			     workqueue,
			     this->object_);
d161 1
d380 1
a380 1
					       Views* pviews)
d383 1
a383 1
  std::vector<Map_to_output>& map_sections(this->map_to_output());
d500 1
a500 1
  std::vector<Map_to_output>& map_sections(this->map_to_output());
@


1.22
log
@Compress all debug sections.
@
text
@d393 1
a393 1
  this->write_local_symbols(of, layout->sympool());
@


1.21
log
@Add threading support.
@
text
@d379 10
a388 6
	  if (views[i].is_input_output_view)
	    of->write_input_output_view(views[i].offset, views[i].view_size,
					views[i].view);
	  else
	    of->write_output_view(views[i].offset, views[i].view_size,
				  views[i].view);
d426 33
d463 1
a463 1
	  view_start = os->offset() + output_offset;
d468 2
a469 2
	  view_start = os->offset();
	  view_size = os->data_size();
d477 1
a477 1
		      && output_offset + view_size <= os->data_size()));
d480 7
a486 2
      if (output_offset == -1)
	view = of->get_input_output_view(view_start, view_size);
d489 7
a495 2
	  view = of->get_output_view(view_start, view_size);
	  this->read(shdr.get_sh_offset(), view_size, view);
d505 1
d593 3
@


1.20
log
@From Cary Coutant: Count textrel with output sections rather than
setting a flag as we add each reloc in the target code.
@
text
@d66 8
d125 8
d144 3
d186 8
@


1.19
log
@From Craig Silverstein: Track_relocs doesn't need to hold onto the
object.
@
text
@d559 2
a560 2
  reloc_data->add_global(this->sym_, this->reloc_type_, this->relobj_,
			 this->shndx_, this->address_);
d571 3
a573 2
  reloc_data->add_global(this->sym_, this->reloc_type_, this->relobj_,
			 this->shndx_, this->address_, this->addend_);
d610 1
d615 2
a616 1
					    rel.get_r_offset(), 0));
d627 1
d632 1
@


1.18
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d675 1
a675 1
    Sized_relobj<size, big_endian>* object,
a678 2
  this->object_ = object;

@


1.17
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d119 1
a119 1
// These tasks are always runnable.
d124 4
d132 1
a132 1
// FINAL_BLOCKER when we are done.
d137 2
a138 1
  Relocate_locker(Task_token& token, Workqueue* workqueue,
d140 3
a142 1
    : blocker_(token, workqueue), objlock_(*object)
d146 2
a147 1
  Task_locker_block blocker_;
d154 3
a156 1
  return new Relocate_locker(*this->final_blocker_, workqueue,
d184 2
d207 2
a208 1
      if (!this->is_section_included(shndx))
d258 2
d304 1
d306 1
a306 2
			  local_symbols,
			  this->symbols_);
d351 8
a358 2
	of->write_output_view(views[i].offset, views[i].view_size,
			      views[i].view);
a384 3
      if (map_sections[i].offset == -1)
	continue;

d388 1
d395 12
a406 2
      off_t start = os->offset() + map_sections[i].offset;
      off_t sh_size = shdr.get_sh_size();
d408 1
a408 1
      if (sh_size == 0)
d411 12
a422 5
      gold_assert(map_sections[i].offset >= 0
		  && map_sections[i].offset + sh_size <= os->data_size());

      unsigned char* view = of->get_output_view(start, sh_size);
      this->read(shdr.get_sh_offset(), sh_size, view);
d425 6
a430 3
      pvs->address = os->address() + map_sections[i].offset;
      pvs->offset = start;
      pvs->view_size = sh_size;
d449 2
a455 3
  relinfo.local_symbol_count = this->local_symbol_count_;
  relinfo.local_values = &this->local_values_;
  relinfo.symbols = this->symbols_;
d474 2
a475 1
      if (!this->is_section_included(index))
d481 1
d507 1
a507 1
		  reloc_size);
d525 2
d666 98
d937 20
@


1.16
log
@From Craig Silverstein: avoid some signed/unsigned warnings from gcc 4.2.
@
text
@d190 3
a192 3
	  fprintf(stderr, _("%s: %s: relocation section %u has bad info %u\n"),
		  program_name, this->name().c_str(), i, shndx);
	  gold_exit(false);
d208 4
a211 5
	  fprintf(stderr,
		  _("%s: %s: relocation section %u uses unexpected "
		    "symbol table %u\n"),
		  program_name, this->name().c_str(), i, shdr.get_sh_link());
	  gold_exit(false);
d223 4
a226 7
	  fprintf(stderr,
		  _("%s: %s: unexpected entsize for reloc section %u: "
		    "%lu != %u"),
		  program_name, this->name().c_str(), i,
		  static_cast<unsigned long>(shdr.get_sh_entsize()),
		  reloc_size);
	  gold_exit(false);
d232 3
a234 4
	  fprintf(stderr, _("%s: %s: reloc section %u size %lu uneven"),
		  program_name, this->name().c_str(), i,
		  static_cast<unsigned long>(sh_size));
	  gold_exit(false);
d431 3
a433 3
	  fprintf(stderr, _("%s: %s: relocation section %u has bad info %u\n"),
		  program_name, this->name().c_str(), i, index);
	  gold_exit(false);
d447 4
a450 5
	  fprintf(stderr,
		  _("%s: %s: relocation section %u uses unexpected "
		    "symbol table %u\n"),
		  program_name, this->name().c_str(), i, shdr.get_sh_link());
	  gold_exit(false);
d465 2
a466 5
	  fprintf(stderr,
		  _("%s: %s: unexpected entsize for reloc section %u: "
		    "%lu != %u"),
		  program_name, this->name().c_str(), i,
		  static_cast<unsigned long>(shdr.get_sh_entsize()),
d468 1
a468 1
	  gold_exit(false);
d474 3
a476 4
	  fprintf(stderr, _("%s: %s: reloc section %u size %lu uneven"),
		  program_name, this->name().c_str(), i,
		  static_cast<unsigned long>(sh_size));
	  gold_exit(false);
@


1.15
log
@Add cache parameter to get_view.  Discard uncached views on unlock.
Fix bug this exposed in archive armap symbol name handling.
@
text
@d234 1
a234 1
      if (reloc_count * reloc_size != sh_size)
d481 1
a481 1
      if (reloc_count * reloc_size != sh_size)
@


1.14
log
@Add licensing text to every source file.
@
text
@d175 2
a176 1
					       shnum * This::shdr_size);
d246 2
a247 1
      sr.contents = this->get_lasting_view(shdr.get_sh_offset(), sh_size);
d266 1
a266 1
						 locsize);
d321 2
a322 1
					       shnum * This::shdr_size);
d461 1
a461 1
						    sh_size);
@


1.13
log
@Add support for --enable-target to control which template
specializations we generate.
@
text
@d3 20
@


1.12
log
@Add support for SHF_MERGE sections.
@
text
@d614 1
d618 1
d620 1
d624 1
d626 1
d630 1
d632 1
d636 1
d638 1
d645 1
d647 1
d654 1
d656 1
d663 1
d665 1
d672 1
d674 1
d681 1
d683 1
d690 1
d692 1
d699 1
d701 1
d708 1
d710 1
d713 1
d715 1
d718 1
d720 1
d723 1
d725 1
d728 1
d730 1
d735 1
d737 1
d742 1
d744 1
d749 1
d751 1
d756 1
d758 1
d763 1
d765 1
d770 1
d772 1
d777 1
d779 1
d784 1
@


1.11
log
@Generate version information.
@
text
@d346 3
@


1.10
log
@Can now dynamically link hello, world.
@
text
@d487 1
a487 1
  if (this->sym_->is_defined_in_dynobj())
@


1.9
log
@Added a testsuite.  More support for COPY relocations.
@
text
@d500 1
d512 1
@


1.8
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d7 1
d475 41
a515 1
// Relocate_functions functions.
d522 1
a522 1
Relocate_functions<size, big_endian>::need_copy_reloc(
d526 1
a526 1
    Symbol*)
d530 3
d541 65
d682 35
a716 4
bool
Relocate_functions<32, false>::need_copy_reloc(const General_options*,
					       Relobj*, unsigned int,
					       Symbol*);
d719 3
a721 4
bool
Relocate_functions<32, true>::need_copy_reloc(const General_options*,
					      Relobj*, unsigned int,
					      Symbol*);
d724 3
a726 4
bool
Relocate_functions<64, false>::need_copy_reloc(const General_options*,
					       Relobj*, unsigned int,
					       Symbol*);
d729 3
a731 4
bool
Relocate_functions<64, true>::need_copy_reloc(const General_options*,
					      Relobj*, unsigned int,
					      Symbol*);
@


1.7
log
@Snapshot.  Includes first cut at output relocation sections.
@
text
@d230 1
a230 1
  assert(this->symtab_shndx_ != -1U);
d237 1
a237 1
      assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);
d240 1
a240 1
      assert(loccount == symtabshdr.get_sh_info());
d269 2
a270 2
      target->scan_relocs(options, symtab, layout, this, p->sh_type,
			  p->contents->data(), p->reloc_count,
d360 2
a361 2
      assert(map_sections[i].offset >= 0
	     && map_sections[i].offset + sh_size <= os->data_size());
d421 1
a421 1
      assert((*pviews)[index].view != NULL);
d474 23
d572 23
@


1.6
log
@More dynamic object support, initial scripting support.
@
text
@d394 1
a394 1
  relinfo.values = this->values_;
@


1.5
log
@Add Elf_file interface which can be used by both Sized_relobj and
Sized_dynobj.
@
text
@d230 1
@


1.4
log
@Split Object into Dynobj and Relobj, incorporate elfcpp swapping changes.
@
text
@d153 1
a153 1
  const unsigned char *pshdrs = this->get_view(this->shoff_,
d184 1
a184 1
      if (shdr.get_sh_link() != this->symtab_shnum_)
d230 1
a230 1
  if (this->symtab_shnum_ == 0 || this->local_symbol_count_ == 0)
d235 1
a235 1
				     + this->symtab_shnum_ * This::shdr_size);
d296 1
a296 1
  const unsigned char* pshdrs = this->get_view(this->shoff_,
d422 1
a422 1
      if (shdr.get_sh_link() != this->symtab_shnum_)
@


1.3
log
@Can now do a full static link of hello, world in C or C++
@
text
@d143 1
a143 1
Sized_object<size, big_endian>::do_read_relocs(Read_relocs_data* rd)
d251 1
a251 1
Sized_object<size, big_endian>::do_scan_relocs(const General_options& options,
d288 1
a288 1
Sized_object<size, big_endian>::do_relocate(const General_options& options,
d330 1
a330 1
Sized_object<size, big_endian>::write_sections(const unsigned char* pshdrs,
d377 1
a377 1
Sized_object<size, big_endian>::relocate_sections(
d478 1
a478 1
Sized_object<32, false>::do_read_relocs(Read_relocs_data* rd);
d482 1
a482 1
Sized_object<32, true>::do_read_relocs(Read_relocs_data* rd);
d486 1
a486 1
Sized_object<64, false>::do_read_relocs(Read_relocs_data* rd);
d490 1
a490 1
Sized_object<64, true>::do_read_relocs(Read_relocs_data* rd);
d494 1
a494 1
Sized_object<32, false>::do_scan_relocs(const General_options& options,
d501 1
a501 1
Sized_object<32, true>::do_scan_relocs(const General_options& options,
d508 1
a508 1
Sized_object<64, false>::do_scan_relocs(const General_options& options,
d515 1
a515 1
Sized_object<64, true>::do_scan_relocs(const General_options& options,
d522 1
a522 1
Sized_object<32, false>::do_relocate(const General_options& options,
d529 1
a529 1
Sized_object<32, true>::do_relocate(const General_options& options,
d536 1
a536 1
Sized_object<64, false>::do_relocate(const General_options& options,
d543 1
a543 1
Sized_object<64, true>::do_relocate(const General_options& options,
@


1.2
log
@Framework for relocation scanning.  Implement simple static TLS
relocations.
@
text
@d41 2
a42 2
					 this->object_, rd, this->symtab_lock_,
					 this->blocker_));
d55 3
a57 1
  return this->symtab_lock_->is_writable() ? IS_RUNNABLE : IS_LOCKED;
d90 2
a91 1
  this->object_->scan_relocs(this->options_, this->symtab_, this->rd_);
d176 8
d253 1
d268 1
a268 1
      target->scan_relocs(options, symtab, this, p->sh_type,
a352 2
      assert(map_sections[i].offset >= 0
	     && map_sections[i].offset < os->data_size());
d356 6
d496 1
d503 1
d510 1
d517 1
@


1.1
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d13 80
d131 1
a131 1
  this->object_->relocate(this->options_, this->symtab_, this->sympool_,
d135 137
d276 1
a276 1
Sized_object<size, big_endian>::do_relocate(const General_options&,
d278 1
a278 1
					    const Stringpool* sympool,
d298 1
a298 1
  this->relocate_sections(symtab, pshdrs, &views);
d309 1
a309 1
  this->write_local_symbols(of, sympool);
d347 2
a348 3
      this->input_file()->file().read(shdr.get_sh_offset(),
				      sh_size,
				      view);
d361 6
a366 3
Sized_object<size, big_endian>::relocate_sections(const Symbol_table* symtab,
						  const unsigned char* pshdrs,
						  Views* pviews)
a368 1
  std::vector<Map_to_output>& map_sections(this->map_to_output());
d371 9
d397 1
a397 1
      if (map_sections[index].output_section == NULL)
d445 6
a450 4
      target->relocate_section(symtab, this, sh_type, prelocs, reloc_count,
			       this->local_symbol_count_,
			       this->values_,
			       this->symbols_,
d462 40
d504 1
a504 1
				     const Stringpool* sympool,
d511 1
a511 1
				    const Stringpool* sympool,
d518 1
a518 1
				     const Stringpool* sympool,
d525 1
a525 1
				    const Stringpool* sympool,
@

