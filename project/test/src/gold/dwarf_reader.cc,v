head	1.51;
access;
symbols
	binutils-2_24-branch:1.51.0.2
	binutils-2_24-branchpoint:1.51
	binutils-2_21_1:1.27
	binutils-2_23_2:1.41.2.1
	binutils-2_23_1:1.41.2.1
	binutils-2_23:1.41
	binutils-2_23-branch:1.41.0.2
	binutils-2_23-branchpoint:1.41
	binutils-2_22_branch:1.33.0.4
	binutils-2_22:1.33
	binutils-2_22-branch:1.33.0.2
	binutils-2_22-branchpoint:1.33
	binutils-2_21:1.27
	binutils-2_21-branch:1.27.0.2
	binutils-2_21-branchpoint:1.27
	binutils-2_20_1:1.22.8.1
	binutils-2_20:1.22.8.1
	binutils-arc-20081103-branch:1.22.0.10
	binutils-arc-20081103-branchpoint:1.22
	binutils-2_20-branch:1.22.0.8
	binutils-2_20-branchpoint:1.22
	dje-cgen-play1-branch:1.22.0.6
	dje-cgen-play1-branchpoint:1.22
	arc-20081103-branch:1.22.0.4
	arc-20081103-branchpoint:1.22
	binutils-2_19_1:1.22
	binutils-2_19:1.22
	binutils-2_19-branch:1.22.0.2
	binutils-2_19-branchpoint:1.22
	binutils_latest_snapshot:1.51
	added-to-binutils:1.17;
locks; strict;
comment	@// @;


1.51
date	2013.08.07.17.11.24;	author ccoutant;	state Exp;
branches;
next	1.50;

1.50
date	2013.07.29.18.29.12;	author sterling;	state Exp;
branches;
next	1.49;

1.49
date	2013.07.01.20.12.11;	author ccoutant;	state Exp;
branches;
next	1.48;

1.48
date	2013.03.01.23.05.27;	author ccoutant;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.01.22.53.02;	author ccoutant;	state Exp;
branches;
next	1.46;

1.46
date	2012.11.01.22.35.05;	author roland;	state Exp;
branches;
next	1.45;

1.45
date	2012.10.23.21.41.37;	author ccoutant;	state Exp;
branches;
next	1.44;

1.44
date	2012.10.23.21.37.26;	author ccoutant;	state Exp;
branches;
next	1.43;

1.43
date	2012.10.23.21.34.58;	author ccoutant;	state Exp;
branches;
next	1.42;

1.42
date	2012.09.07.20.14.06;	author ccoutant;	state Exp;
branches;
next	1.41;

1.41
date	2012.07.11.14.18.40;	author ian;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2012.05.01.22.46.36;	author ccoutant;	state Exp;
branches;
next	1.39;

1.39
date	2012.05.01.19.12.21;	author mark;	state Exp;
branches;
next	1.38;

1.38
date	2012.03.21.19.02.21;	author ccoutant;	state Exp;
branches;
next	1.37;

1.37
date	2012.03.13.00.25.58;	author ccoutant;	state Exp;
branches;
next	1.36;

1.36
date	2012.02.29.21.22.29;	author ccoutant;	state Exp;
branches;
next	1.35;

1.35
date	2012.01.28.01.43.58;	author ian;	state Exp;
branches;
next	1.34;

1.34
date	2011.12.17.22.39.52;	author ccoutant;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.05.19.19.42;	author ppluzhnikov;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2011.03.10.01.31.32;	author ian;	state Exp;
branches;
next	1.31;

1.31
date	2010.12.20.18.37.36;	author ian;	state Exp;
branches;
next	1.30;

1.30
date	2010.12.14.19.03.29;	author rwild;	state Exp;
branches;
next	1.29;

1.29
date	2010.12.01.19.49.22;	author ian;	state Exp;
branches;
next	1.28;

1.28
date	2010.11.17.01.53.22;	author ccoutant;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.12.17.59.58;	author ccoutant;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.14.19.53.04;	author ian;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2009.12.09.03.02.28;	author dougkwan;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.09.23.05.21;	author ian;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.28.20.48.16;	author ian;	state Exp;
branches
	1.22.8.1;
next	1.21;

1.21
date	2008.05.01.00.25.33;	author csilvers;	state Exp;
branches;
next	1.20;

1.20
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.19;

1.19
date	2008.04.03.04.18.53;	author davem;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.26.23.36.46;	author ian;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.18.23.35.09;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.11.18.17.27;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.28.19.38.35;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.28.18.01.06;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.16.06.47.53;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.14.18.33.47;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.14.01.03.01;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.13.01.26.27;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.12.20.55.52;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.12.19.56.20;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.09.23.16.54;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.09.07.03.14;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.07.00.49.56;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.02.23.02.44;	author iant;	state Exp;
branches;
next	;

1.41.2.1
date	2012.11.07.17.31.29;	author roland;	state Exp;
branches;
next	;

1.33.2.1
date	2011.12.19.21.14.39;	author ian;	state Exp;
branches;
next	;

1.22.8.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	;


desc
@@


1.51
log
@gold/
	Revert support for v2 DWP files:

	2013-03-01  Cary Coutant  <ccoutant@@google.com>

	    Add dwp support for v2 DWARF package file format.
	    * dwarf_reader.cc (Dwarf_info_reader::visit_type_unit): Add
	    tu_length parameter.  Adjust all callers.
	    * dwarf_reader.h (Dwarf_info_reader::visit_type_unit): Likewise.
	    * dwp.cc: Include dwarf.h.
	    (Section_bounds): New struct type.
	    (Unit_set): New struct type.
	    (Dwo_file::Dwo_file): Initialize new data member.
	    (Dwo_file::read_compunit_index, Dwo_file::read_typeunit_index):
	    Combine and rename to...
	    (Dwo_file::read_unit_index): ...this.
	    (Dwo_file::sized_read_compunit_index)
	    (Dwo_file::sized_read_typeunit_index): Combine and rename to...
	    (Dwo_file::sized_read_unit_index): ...this.
	    (Dwo_file::copy_section): Remove section_name, is_str_offsets
	    parameters; add section_id parameter.
	    (Dwo_file::add_cu_set, Dwo_file::add_tu_set): Combine and rename to...
	    (Dwo_file::add_unit_set): ...this.
	    (Dwo_file::shndx_map_): Remove.
	    (Dwo_file::sect_offsets_): New data member.
	    (Dwp_output_file::Dwp_output_file): Initialize new data members.
	    (Dwp_output_file::add_section): Rename to...
	    (Dwp_output_file::add_contribution): ...this.
	    (Dwp_output_file::add_cu_set): Combine parameters into a struct.
	    (Dwp_output_file::add_tu_set): Likewise.
	    (Dwp_output_file::Contribution): New type.
	    (Dwp_output_file::Section::contributions): New data member.
	    (Dwp_output_file::Cu_or_tu_set): Remove.
	    (Dwp_output_file::Section::Section): New ctor.
	    (Dwp_output_file::Dwp_index::Shndx_pool): Remove.
	    (Dwp_output_file::Dwp_index::Section_table): New type.
	    (Dwp_output_file::Dwp_index::Dwp_index): Initialize new data members.
	    (Dwp_output_file::Dwp_index::enter_set): Change type of "set"
	    parameter.
	    (Dwp_output_file::Dwp_index::shndx_pool): Remove.
	    (Dwp_output_file::Dwp_index::shndx_pool_end): Remove.
	    (Dwp_output_file::Dwp_index::section_table): New member function.
	    (Dwp_output_file::Dwp_index::section_table_end): New member function.
	    (Dwp_output_file::Dwp_index::shndx_pool_size): Remove.
	    (Dwp_output_file::Dwp_index::section_table_rows): New member function.
	    (Dwp_output_file::Dwp_index::section_table_cols): New member function.
	    (Dwp_output_file::Dwp_index::shndx_pool_): Remove.
	    (Dwp_output_file::Dwp_index::section_table_): New data member.
	    (Dwp_output_file::Dwp_index::section_mask_): New data member.
	    (Dwp_output_file::add_output_section): New member function.
	    (Dwp_output_file::write_new_section): New member function.
	    (Dwp_output_file::write_contributions): New member function.
	    (Dwp_output_file::section_id_map_): New data member.
	    (class Dwo_id_info_reader): Remove.
	    (class Unit_reader): New class.
	    (get_dwarf_section_name): New function.
	    (Dwo_file::read_executable): Adjust initializations of class data.
	    (Dwo_file::read): Add support for v2 package file format.
	    (Dwo_file::read_unit_index): Likewise.
	    (Dwo_file::sized_read_unit_index): Likewise.
	    (Dwo_file::copy_section): Likewise.
	    (Dwo_file::add_unit_set): Likewise.
	    (Dwp_output_file::add_output_section): Likewise.
	    (Dwp_output_file::add_contribution): Likewise.
	    (Dwp_output_file::Dwp_index::find_or_add): Use row index to check
	    for empty slot.
	    (Dwp_output_file::Dwp_index::enter_set): Add support for v2 package
	    file format.
	    (Dwp_output_file::Dwp_index::grow): Use row index to check for empty
	    slot.
	    (Dwp_output_file::initialize): Remove unused function.
	    (Dwp_output_file::finalize): Add support for v2 package file format.
	    (Dwp_output_file::write_index): Likewise.
	    * gdb-index.cc (Gdb_index_info_reader::visit_type_unit): Adjust
	    function prototype.
@
text
@// dwarf_reader.cc -- parse dwarf2/3 debug information

// Copyright 2007, 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <algorithm>
#include <vector>

#include "elfcpp_swap.h"
#include "dwarf.h"
#include "object.h"
#include "reloc.h"
#include "dwarf_reader.h"
#include "int_encoding.h"
#include "compressed_output.h"

namespace gold {

// Class Sized_elf_reloc_mapper

// Initialize the relocation tracker for section RELOC_SHNDX.

template<int size, bool big_endian>
bool
Sized_elf_reloc_mapper<size, big_endian>::do_initialize(
    unsigned int reloc_shndx, unsigned int reloc_type)
{
  this->reloc_type_ = reloc_type;
  return this->track_relocs_.initialize(this->object_, reloc_shndx,
					reloc_type);
}

// Looks in the symtab to see what section a symbol is in.

template<int size, bool big_endian>
unsigned int
Sized_elf_reloc_mapper<size, big_endian>::symbol_section(
    unsigned int symndx, Address* value, bool* is_ordinary)
{
  const int symsize = elfcpp::Elf_sizes<size>::sym_size;
  gold_assert(static_cast<off_t>((symndx + 1) * symsize) <= this->symtab_size_);
  elfcpp::Sym<size, big_endian> elfsym(this->symtab_ + symndx * symsize);
  *value = elfsym.get_st_value();
  return this->object_->adjust_sym_shndx(symndx, elfsym.get_st_shndx(),
					 is_ordinary);
}

// Return the section index and offset within the section of
// the target of the relocation for RELOC_OFFSET.

template<int size, bool big_endian>
unsigned int
Sized_elf_reloc_mapper<size, big_endian>::do_get_reloc_target(
    off_t reloc_offset, off_t* target_offset)
{
  this->track_relocs_.advance(reloc_offset);
  if (reloc_offset != this->track_relocs_.next_offset())
    return 0;
  unsigned int symndx = this->track_relocs_.next_symndx();
  typename elfcpp::Elf_types<size>::Elf_Addr value;
  bool is_ordinary;
  unsigned int target_shndx = this->symbol_section(symndx, &value,
						   &is_ordinary);
  if (!is_ordinary)
    return 0;
  if (this->reloc_type_ == elfcpp::SHT_RELA)
    value += this->track_relocs_.next_addend();
  *target_offset = value;
  return target_shndx;
}

static inline Elf_reloc_mapper*
make_elf_reloc_mapper(Relobj* object, const unsigned char* symtab,
		      off_t symtab_size)
{
  if (object->elfsize() == 32)
    {
      if (object->is_big_endian())
        {
#ifdef HAVE_TARGET_32_BIG
	  return new Sized_elf_reloc_mapper<32, true>(object, symtab,
						      symtab_size);
#else
	  gold_unreachable();
#endif
        }
      else
        {
#ifdef HAVE_TARGET_32_LITTLE
	  return new Sized_elf_reloc_mapper<32, false>(object, symtab,
						       symtab_size);
#else
	  gold_unreachable();
#endif
        }
    }
  else if (object->elfsize() == 64)
    {
      if (object->is_big_endian())
        {
#ifdef HAVE_TARGET_64_BIG
	  return new Sized_elf_reloc_mapper<64, true>(object, symtab,
						      symtab_size);
#else
	  gold_unreachable();
#endif
        }
      else
        {
#ifdef HAVE_TARGET_64_LITTLE
	  return new Sized_elf_reloc_mapper<64, false>(object, symtab,
						       symtab_size);
#else
	  gold_unreachable();
#endif
        }
    }
  else
    gold_unreachable();
}

// class Dwarf_abbrev_table

void
Dwarf_abbrev_table::clear_abbrev_codes()
{
  for (unsigned int code = 0; code < this->low_abbrev_code_max_; ++code)
    {
      if (this->low_abbrev_codes_[code] != NULL)
	{
	  delete this->low_abbrev_codes_[code];
	  this->low_abbrev_codes_[code] = NULL;
	}
    }
  for (Abbrev_code_table::iterator it = this->high_abbrev_codes_.begin();
       it != this->high_abbrev_codes_.end();
       ++it)
    {
      if (it->second != NULL)
	delete it->second;
    }
  this->high_abbrev_codes_.clear();
}

// Read the abbrev table from an object file.

bool
Dwarf_abbrev_table::do_read_abbrevs(
    Relobj* object,
    unsigned int abbrev_shndx,
    off_t abbrev_offset)
{
  this->clear_abbrev_codes();

  // If we don't have relocations, abbrev_shndx will be 0, and
  // we'll have to hunt for the .debug_abbrev section.
  if (abbrev_shndx == 0 && this->abbrev_shndx_ > 0)
    abbrev_shndx = this->abbrev_shndx_;
  else if (abbrev_shndx == 0)
    {
      for (unsigned int i = 1; i < object->shnum(); ++i)
	{
	  std::string name = object->section_name(i);
	  if (name == ".debug_abbrev")
	    {
	      abbrev_shndx = i;
	      // Correct the offset.  For incremental update links, we have a
	      // relocated offset that is relative to the output section, but
	      // here we need an offset relative to the input section.
	      abbrev_offset -= object->output_section_offset(i);
	      break;
	    }
	}
      if (abbrev_shndx == 0)
	return false;
    }

  // Get the section contents and decompress if necessary.
  if (abbrev_shndx != this->abbrev_shndx_)
    {
      if (this->owns_buffer_ && this->buffer_ != NULL)
        {
	  delete[] this->buffer_;
	  this->owns_buffer_ = false;
        }

      section_size_type buffer_size;
      this->buffer_ =
	  object->decompressed_section_contents(abbrev_shndx,
						&buffer_size,
						&this->owns_buffer_);
      this->buffer_end_ = this->buffer_ + buffer_size;
      this->abbrev_shndx_ = abbrev_shndx;
    }

  this->buffer_pos_ = this->buffer_ + abbrev_offset;
  return true;
}

// Lookup the abbrev code entry for CODE.  This function is called
// only when the abbrev code is not in the direct lookup table.
// It may be in the hash table, it may not have been read yet,
// or it may not exist in the abbrev table.

const Dwarf_abbrev_table::Abbrev_code*
Dwarf_abbrev_table::do_get_abbrev(unsigned int code)
{
  // See if the abbrev code is already in the hash table.
  Abbrev_code_table::const_iterator it = this->high_abbrev_codes_.find(code);
  if (it != this->high_abbrev_codes_.end())
    return it->second;

  // Read and store abbrev code definitions until we find the
  // one we're looking for.
  for (;;)
    {
      // Read the abbrev code.  A zero here indicates the end of the
      // abbrev table.
      size_t len;
      if (this->buffer_pos_ >= this->buffer_end_)
	return NULL;
      uint64_t nextcode = read_unsigned_LEB_128(this->buffer_pos_, &len);
      if (nextcode == 0)
	{
	  this->buffer_pos_ = this->buffer_end_;
	  return NULL;
	}
      this->buffer_pos_ += len;

      // Read the tag.
      if (this->buffer_pos_ >= this->buffer_end_)
	return NULL;
      uint64_t tag = read_unsigned_LEB_128(this->buffer_pos_, &len);
      this->buffer_pos_ += len;

      // Read the has_children flag.
      if (this->buffer_pos_ >= this->buffer_end_)
	return NULL;
      bool has_children = *this->buffer_pos_ == elfcpp::DW_CHILDREN_yes;
      this->buffer_pos_ += 1;

      // Read the list of (attribute, form) pairs.
      Abbrev_code* entry = new Abbrev_code(tag, has_children);
      for (;;)
	{
	  // Read the attribute.
	  if (this->buffer_pos_ >= this->buffer_end_)
	    return NULL;
	  uint64_t attr = read_unsigned_LEB_128(this->buffer_pos_, &len);
	  this->buffer_pos_ += len;

	  // Read the form.
	  if (this->buffer_pos_ >= this->buffer_end_)
	    return NULL;
	  uint64_t form = read_unsigned_LEB_128(this->buffer_pos_, &len);
	  this->buffer_pos_ += len;

	  // A (0,0) pair terminates the list.
	  if (attr == 0 && form == 0)
	    break;

	  if (attr == elfcpp::DW_AT_sibling)
	    entry->has_sibling_attribute = true;

	  entry->add_attribute(attr, form);
	}

      this->store_abbrev(nextcode, entry);
      if (nextcode == code)
	return entry;
    }

  return NULL;
}

// class Dwarf_ranges_table

// Read the ranges table from an object file.

bool
Dwarf_ranges_table::read_ranges_table(
    Relobj* object,
    const unsigned char* symtab,
    off_t symtab_size,
    unsigned int ranges_shndx)
{
  // If we've already read this abbrev table, return immediately.
  if (this->ranges_shndx_ > 0
      && this->ranges_shndx_ == ranges_shndx)
    return true;

  // If we don't have relocations, ranges_shndx will be 0, and
  // we'll have to hunt for the .debug_ranges section.
  if (ranges_shndx == 0 && this->ranges_shndx_ > 0)
    ranges_shndx = this->ranges_shndx_;
  else if (ranges_shndx == 0)
    {
      for (unsigned int i = 1; i < object->shnum(); ++i)
	{
	  std::string name = object->section_name(i);
	  if (name == ".debug_ranges")
	    {
	      ranges_shndx = i;
	      this->output_section_offset_ = object->output_section_offset(i);
	      break;
	    }
	}
      if (ranges_shndx == 0)
	return false;
    }

  // Get the section contents and decompress if necessary.
  if (ranges_shndx != this->ranges_shndx_)
    {
      if (this->owns_ranges_buffer_ && this->ranges_buffer_ != NULL)
        {
	  delete[] this->ranges_buffer_;
	  this->owns_ranges_buffer_ = false;
        }

      section_size_type buffer_size;
      this->ranges_buffer_ =
	  object->decompressed_section_contents(ranges_shndx,
						&buffer_size,
						&this->owns_ranges_buffer_);
      this->ranges_buffer_end_ = this->ranges_buffer_ + buffer_size;
      this->ranges_shndx_ = ranges_shndx;
    }

  if (this->ranges_reloc_mapper_ != NULL)
    {
      delete this->ranges_reloc_mapper_;
      this->ranges_reloc_mapper_ = NULL;
    }

  // For incremental objects, we have no relocations.
  if (object->is_incremental())
    return true;

  // Find the relocation section for ".debug_ranges".
  unsigned int reloc_shndx = 0;
  unsigned int reloc_type = 0;
  for (unsigned int i = 0; i < object->shnum(); ++i)
    {
      reloc_type = object->section_type(i);
      if ((reloc_type == elfcpp::SHT_REL
	   || reloc_type == elfcpp::SHT_RELA)
	  && object->section_info(i) == ranges_shndx)
	{
	  reloc_shndx = i;
	  break;
	}
    }

  this->ranges_reloc_mapper_ = make_elf_reloc_mapper(object, symtab,
						     symtab_size);
  this->ranges_reloc_mapper_->initialize(reloc_shndx, reloc_type);
  this->reloc_type_ = reloc_type;

  return true;
}

// Read a range list from section RANGES_SHNDX at offset RANGES_OFFSET.

Dwarf_range_list*
Dwarf_ranges_table::read_range_list(
    Relobj* object,
    const unsigned char* symtab,
    off_t symtab_size,
    unsigned int addr_size,
    unsigned int ranges_shndx,
    off_t offset)
{
  Dwarf_range_list* ranges;

  if (!this->read_ranges_table(object, symtab, symtab_size, ranges_shndx))
    return NULL;

  // Correct the offset.  For incremental update links, we have a
  // relocated offset that is relative to the output section, but
  // here we need an offset relative to the input section.
  offset -= this->output_section_offset_;

  // Read the range list at OFFSET.
  ranges = new Dwarf_range_list();
  off_t base = 0;
  for (;
       this->ranges_buffer_ + offset < this->ranges_buffer_end_;
       offset += 2 * addr_size)
    {
      off_t start;
      off_t end;

      // Read the raw contents of the section.
      if (addr_size == 4)
	{
	  start = this->dwinfo_->read_from_pointer<32>(this->ranges_buffer_
						       + offset);
	  end = this->dwinfo_->read_from_pointer<32>(this->ranges_buffer_
						     + offset + 4);
	}
      else
	{
	  start = this->dwinfo_->read_from_pointer<64>(this->ranges_buffer_
						       + offset);
	  end = this->dwinfo_->read_from_pointer<64>(this->ranges_buffer_
						     + offset + 8);
	}

      // Check for relocations and adjust the values.
      unsigned int shndx1 = 0;
      unsigned int shndx2 = 0;
      if (this->ranges_reloc_mapper_ != NULL)
        {
	  shndx1 = this->lookup_reloc(offset, &start);
	  shndx2 = this->lookup_reloc(offset + addr_size, &end);
        }

      // End of list is marked by a pair of zeroes.
      if (shndx1 == 0 && start == 0 && end == 0)
        break;

      // A "base address selection entry" is identified by
      // 0xffffffff for the first value of the pair.  The second
      // value is used as a base for subsequent range list entries.
      if (shndx1 == 0 && start == -1)
	base = end;
      else if (shndx1 == shndx2)
	{
	  if (shndx1 == 0 || object->is_section_included(shndx1))
	    ranges->add(shndx1, base + start, base + end);
	}
      else
	gold_warning(_("%s: DWARF info may be corrupt; offsets in a "
		       "range list entry are in different sections"),
		     object->name().c_str());
    }

  return ranges;
}

// Look for a relocation at offset OFF in the range table,
// and return the section index and offset of the target.

unsigned int
Dwarf_ranges_table::lookup_reloc(off_t off, off_t* target_off)
{
  off_t value;
  unsigned int shndx =
      this->ranges_reloc_mapper_->get_reloc_target(off, &value);
  if (shndx == 0)
    return 0;
  if (this->reloc_type_ == elfcpp::SHT_REL)
    *target_off += value;
  else
    *target_off = value;
  return shndx;
}

// class Dwarf_pubnames_table

// Read the pubnames section from the object file.

bool
Dwarf_pubnames_table::read_section(Relobj* object, const unsigned char* symtab,
                                   off_t symtab_size)
{
  section_size_type buffer_size;
  unsigned int shndx = 0;

  // Find the .debug_pubnames/pubtypes section.
  const char* name = (this->is_pubtypes_
                      ? ".debug_pubtypes"
                      : ".debug_pubnames");
  for (unsigned int i = 1; i < object->shnum(); ++i)
    {
      if (object->section_name(i) == name)
        {
          shndx = i;
          this->output_section_offset_ = object->output_section_offset(i);
          break;
        }
    }
  if (shndx == 0)
    return false;


  this->buffer_ = object->decompressed_section_contents(shndx,
							&buffer_size,
							&this->owns_buffer_);
  if (this->buffer_ == NULL)
    return false;
  this->buffer_end_ = this->buffer_ + buffer_size;

  // For incremental objects, we have no relocations.
  if (object->is_incremental())
    return true;

  // Find the relocation section
  unsigned int reloc_shndx = 0;
  unsigned int reloc_type = 0;
  for (unsigned int i = 0; i < object->shnum(); ++i)
    {
      reloc_type = object->section_type(i);
      if ((reloc_type == elfcpp::SHT_REL
	   || reloc_type == elfcpp::SHT_RELA)
	  && object->section_info(i) == shndx)
	{
	  reloc_shndx = i;
	  break;
	}
    }

  this->reloc_mapper_ = make_elf_reloc_mapper(object, symtab, symtab_size);
  this->reloc_mapper_->initialize(reloc_shndx, reloc_type);
  this->reloc_type_ = reloc_type;

  return true;
}

// Read the header for the set at OFFSET.

bool
Dwarf_pubnames_table::read_header(off_t offset)
{
  // Make sure we have actually read the section.
  gold_assert(this->buffer_ != NULL);

  // Correct the offset.  For incremental update links, we have a
  // relocated offset that is relative to the output section, but
  // here we need an offset relative to the input section.
  offset -= this->output_section_offset_;

  if (offset < 0 || offset + 14 >= this->buffer_end_ - this->buffer_)
    return false;

  const unsigned char* pinfo = this->buffer_ + offset;

  // Read the unit_length field.
  uint64_t unit_length = this->dwinfo_->read_from_pointer<32>(pinfo);
  pinfo += 4;
  if (unit_length == 0xffffffff)
    {
      unit_length = this->dwinfo_->read_from_pointer<64>(pinfo);
      this->unit_length_ = unit_length + 12;
      pinfo += 8;
      this->offset_size_ = 8;
    }
  else
    {
      this->unit_length_ = unit_length + 4;
      this->offset_size_ = 4;
    }

  // Check the version.
  unsigned int version = this->dwinfo_->read_from_pointer<16>(pinfo);
  pinfo += 2;
  if (version != 2)
    return false;

  this->reloc_mapper_->get_reloc_target(pinfo - this->buffer_,
                                        &this->cu_offset_);

  // Skip the debug_info_offset and debug_info_size fields.
  pinfo += 2 * this->offset_size_;

  if (pinfo >= this->buffer_end_)
    return false;

  this->pinfo_ = pinfo;
  return true;
}

// Read the next name from the set.

const char*
Dwarf_pubnames_table::next_name()
{
  const unsigned char* pinfo = this->pinfo_;

  // Read the offset within the CU.  If this is zero, we have reached
  // the end of the list.
  uint32_t offset;
  if (this->offset_size_ == 4)
    offset = this->dwinfo_->read_from_pointer<32>(&pinfo);
  else
    offset = this->dwinfo_->read_from_pointer<64>(&pinfo);
  if (offset == 0)
    return NULL;

  // Return a pointer to the string at the current location,
  // and advance the pointer to the next entry.
  const char* ret = reinterpret_cast<const char*>(pinfo);
  while (pinfo < this->buffer_end_ && *pinfo != '\0')
    ++pinfo;
  if (pinfo < this->buffer_end_)
    ++pinfo;

  this->pinfo_ = pinfo;
  return ret;
}

// class Dwarf_die

Dwarf_die::Dwarf_die(
    Dwarf_info_reader* dwinfo,
    off_t die_offset,
    Dwarf_die* parent)
  : dwinfo_(dwinfo), parent_(parent), die_offset_(die_offset),
    child_offset_(0), sibling_offset_(0), abbrev_code_(NULL), attributes_(),
    attributes_read_(false), name_(NULL), name_off_(-1), linkage_name_(NULL),
    linkage_name_off_(-1), string_shndx_(0), specification_(0),
    abstract_origin_(0)
{
  size_t len;
  const unsigned char* pdie = dwinfo->buffer_at_offset(die_offset);
  if (pdie == NULL)
    return;
  unsigned int code = read_unsigned_LEB_128(pdie, &len);
  if (code == 0)
    {
      if (parent != NULL)
	parent->set_sibling_offset(die_offset + len);
      return;
    }
  this->attr_offset_ = len;

  // Lookup the abbrev code in the abbrev table.
  this->abbrev_code_ = dwinfo->get_abbrev(code);
}

// Read all the attributes of the DIE.

bool
Dwarf_die::read_attributes()
{
  if (this->attributes_read_)
    return true;

  gold_assert(this->abbrev_code_ != NULL);

  const unsigned char* pdie =
      this->dwinfo_->buffer_at_offset(this->die_offset_);
  if (pdie == NULL)
    return false;
  const unsigned char* pattr = pdie + this->attr_offset_;

  unsigned int nattr = this->abbrev_code_->attributes.size();
  this->attributes_.reserve(nattr);
  for (unsigned int i = 0; i < nattr; ++i)
    {
      size_t len;
      unsigned int attr = this->abbrev_code_->attributes[i].attr;
      unsigned int form = this->abbrev_code_->attributes[i].form;
      if (form == elfcpp::DW_FORM_indirect)
        {
          form = read_unsigned_LEB_128(pattr, &len);
          pattr += len;
        }
      off_t attr_off = this->die_offset_ + (pattr - pdie);
      bool ref_form = false;
      Attribute_value attr_value;
      attr_value.attr = attr;
      attr_value.form = form;
      attr_value.aux.shndx = 0;
      switch(form)
	{
	  case elfcpp::DW_FORM_flag_present:
	    attr_value.val.intval = 1;
	    break;
	  case elfcpp::DW_FORM_strp:
	    {
	      off_t str_off;
	      if (this->dwinfo_->offset_size() == 4)
		str_off = this->dwinfo_->read_from_pointer<32>(&pattr);
	      else
		str_off = this->dwinfo_->read_from_pointer<64>(&pattr);
	      unsigned int shndx =
		  this->dwinfo_->lookup_reloc(attr_off, &str_off);
	      attr_value.aux.shndx = shndx;
	      attr_value.val.refval = str_off;
	      break;
	    }
	  case elfcpp::DW_FORM_sec_offset:
	    {
	      off_t sec_off;
	      if (this->dwinfo_->offset_size() == 4)
		sec_off = this->dwinfo_->read_from_pointer<32>(&pattr);
	      else
		sec_off = this->dwinfo_->read_from_pointer<64>(&pattr);
	      unsigned int shndx =
		  this->dwinfo_->lookup_reloc(attr_off, &sec_off);
	      attr_value.aux.shndx = shndx;
	      attr_value.val.refval = sec_off;
	      ref_form = true;
	      break;
	    }
	  case elfcpp::DW_FORM_addr:
	  case elfcpp::DW_FORM_ref_addr:
	    {
	      off_t sec_off;
	      if (this->dwinfo_->address_size() == 4)
		sec_off = this->dwinfo_->read_from_pointer<32>(&pattr);
	      else
		sec_off = this->dwinfo_->read_from_pointer<64>(&pattr);
	      unsigned int shndx =
		  this->dwinfo_->lookup_reloc(attr_off, &sec_off);
	      attr_value.aux.shndx = shndx;
	      attr_value.val.refval = sec_off;
	      ref_form = true;
	      break;
	    }
	  case elfcpp::DW_FORM_block1:
	    attr_value.aux.blocklen = *pattr++;
	    attr_value.val.blockval = pattr;
	    pattr += attr_value.aux.blocklen;
	    break;
	  case elfcpp::DW_FORM_block2:
	    attr_value.aux.blocklen =
		this->dwinfo_->read_from_pointer<16>(&pattr);
	    attr_value.val.blockval = pattr;
	    pattr += attr_value.aux.blocklen;
	    break;
	  case elfcpp::DW_FORM_block4:
	    attr_value.aux.blocklen =
		this->dwinfo_->read_from_pointer<32>(&pattr);
	    attr_value.val.blockval = pattr;
	    pattr += attr_value.aux.blocklen;
	    break;
	  case elfcpp::DW_FORM_block:
	  case elfcpp::DW_FORM_exprloc:
	    attr_value.aux.blocklen = read_unsigned_LEB_128(pattr, &len);
	    attr_value.val.blockval = pattr + len;
	    pattr += len + attr_value.aux.blocklen;
	    break;
	  case elfcpp::DW_FORM_data1:
	  case elfcpp::DW_FORM_flag:
	    attr_value.val.intval = *pattr++;
	    break;
	  case elfcpp::DW_FORM_ref1:
	    attr_value.val.refval = *pattr++;
	    ref_form = true;
	    break;
	  case elfcpp::DW_FORM_data2:
	    attr_value.val.intval =
		this->dwinfo_->read_from_pointer<16>(&pattr);
	    break;
	  case elfcpp::DW_FORM_ref2:
	    attr_value.val.refval =
		this->dwinfo_->read_from_pointer<16>(&pattr);
	    ref_form = true;
	    break;
	  case elfcpp::DW_FORM_data4:
	    {
	      off_t sec_off;
	      sec_off = this->dwinfo_->read_from_pointer<32>(&pattr);
	      unsigned int shndx =
		  this->dwinfo_->lookup_reloc(attr_off, &sec_off);
	      attr_value.aux.shndx = shndx;
	      attr_value.val.intval = sec_off;
	      break;
	    }
	  case elfcpp::DW_FORM_ref4:
	    {
	      off_t sec_off;
	      sec_off = this->dwinfo_->read_from_pointer<32>(&pattr);
	      unsigned int shndx =
		  this->dwinfo_->lookup_reloc(attr_off, &sec_off);
	      attr_value.aux.shndx = shndx;
	      attr_value.val.refval = sec_off;
	      ref_form = true;
	      break;
	    }
	  case elfcpp::DW_FORM_data8:
	    {
	      off_t sec_off;
	      sec_off = this->dwinfo_->read_from_pointer<64>(&pattr);
	      unsigned int shndx =
		  this->dwinfo_->lookup_reloc(attr_off, &sec_off);
	      attr_value.aux.shndx = shndx;
	      attr_value.val.intval = sec_off;
	      break;
	    }
	  case elfcpp::DW_FORM_ref_sig8:
	    attr_value.val.uintval =
		this->dwinfo_->read_from_pointer<64>(&pattr);
	    break;
	  case elfcpp::DW_FORM_ref8:
	    {
	      off_t sec_off;
	      sec_off = this->dwinfo_->read_from_pointer<64>(&pattr);
	      unsigned int shndx =
		  this->dwinfo_->lookup_reloc(attr_off, &sec_off);
	      attr_value.aux.shndx = shndx;
	      attr_value.val.refval = sec_off;
	      ref_form = true;
	      break;
	    }
	  case elfcpp::DW_FORM_ref_udata:
	    attr_value.val.refval = read_unsigned_LEB_128(pattr, &len);
	    ref_form = true;
	    pattr += len;
	    break;
	  case elfcpp::DW_FORM_udata:
	  case elfcpp::DW_FORM_GNU_addr_index:
	  case elfcpp::DW_FORM_GNU_str_index:
	    attr_value.val.uintval = read_unsigned_LEB_128(pattr, &len);
	    pattr += len;
	    break;
	  case elfcpp::DW_FORM_sdata:
	    attr_value.val.intval = read_signed_LEB_128(pattr, &len);
	    pattr += len;
	    break;
	  case elfcpp::DW_FORM_string:
	    attr_value.val.stringval = reinterpret_cast<const char*>(pattr);
	    len = strlen(attr_value.val.stringval);
	    pattr += len + 1;
	    break;
	  default:
	    return false;
	}

      // Cache the most frequently-requested attributes.
      switch (attr)
	{
	  case elfcpp::DW_AT_name:
	    if (form == elfcpp::DW_FORM_string)
	      this->name_ = attr_value.val.stringval;
	    else if (form == elfcpp::DW_FORM_strp)
	      {
		// All indirect strings should refer to the same
		// string section, so we just save the last one seen.
		this->string_shndx_ = attr_value.aux.shndx;
		this->name_off_ = attr_value.val.refval;
	      }
	    break;
	  case elfcpp::DW_AT_linkage_name:
	  case elfcpp::DW_AT_MIPS_linkage_name:
	    if (form == elfcpp::DW_FORM_string)
	      this->linkage_name_ = attr_value.val.stringval;
	    else if (form == elfcpp::DW_FORM_strp)
	      {
		// All indirect strings should refer to the same
		// string section, so we just save the last one seen.
		this->string_shndx_ = attr_value.aux.shndx;
		this->linkage_name_off_ = attr_value.val.refval;
	      }
	    break;
	  case elfcpp::DW_AT_specification:
	    if (ref_form)
	      this->specification_ = attr_value.val.refval;
	    break;
	  case elfcpp::DW_AT_abstract_origin:
	    if (ref_form)
	      this->abstract_origin_ = attr_value.val.refval;
	    break;
	  case elfcpp::DW_AT_sibling:
	    if (ref_form && attr_value.aux.shndx == 0)
	      this->sibling_offset_ = attr_value.val.refval;
	  default:
	    break;
	}

      this->attributes_.push_back(attr_value);
    }

  // Now that we know where the next DIE begins, record the offset
  // to avoid later recalculation.
  if (this->has_children())
    this->child_offset_ = this->die_offset_ + (pattr - pdie);
  else
    this->sibling_offset_ = this->die_offset_ + (pattr - pdie);

  this->attributes_read_ = true;
  return true;
}

// Skip all the attributes of the DIE and return the offset of the next DIE.

off_t
Dwarf_die::skip_attributes()
{
  gold_assert(this->abbrev_code_ != NULL);

  const unsigned char* pdie =
      this->dwinfo_->buffer_at_offset(this->die_offset_);
  if (pdie == NULL)
    return 0;
  const unsigned char* pattr = pdie + this->attr_offset_;

  for (unsigned int i = 0; i < this->abbrev_code_->attributes.size(); ++i)
    {
      size_t len;
      unsigned int form = this->abbrev_code_->attributes[i].form;
      if (form == elfcpp::DW_FORM_indirect)
        {
          form = read_unsigned_LEB_128(pattr, &len);
          pattr += len;
        }
      switch(form)
	{
	  case elfcpp::DW_FORM_flag_present:
	    break;
	  case elfcpp::DW_FORM_strp:
	  case elfcpp::DW_FORM_sec_offset:
	    pattr += this->dwinfo_->offset_size();
	    break;
	  case elfcpp::DW_FORM_addr:
	  case elfcpp::DW_FORM_ref_addr:
	    pattr += this->dwinfo_->address_size();
	    break;
	  case elfcpp::DW_FORM_block1:
	    pattr += 1 + *pattr;
	    break;
	  case elfcpp::DW_FORM_block2:
	    {
	      uint16_t block_size;
	      block_size = this->dwinfo_->read_from_pointer<16>(&pattr);
	      pattr += block_size;
	      break;
	    }
	  case elfcpp::DW_FORM_block4:
	    {
	      uint32_t block_size;
	      block_size = this->dwinfo_->read_from_pointer<32>(&pattr);
	      pattr += block_size;
	      break;
	    }
	  case elfcpp::DW_FORM_block:
	  case elfcpp::DW_FORM_exprloc:
	    {
	      uint64_t block_size;
	      block_size = read_unsigned_LEB_128(pattr, &len);
	      pattr += len + block_size;
	      break;
	    }
	  case elfcpp::DW_FORM_data1:
	  case elfcpp::DW_FORM_ref1:
	  case elfcpp::DW_FORM_flag:
	    pattr += 1;
	    break;
	  case elfcpp::DW_FORM_data2:
	  case elfcpp::DW_FORM_ref2:
	    pattr += 2;
	    break;
	  case elfcpp::DW_FORM_data4:
	  case elfcpp::DW_FORM_ref4:
	    pattr += 4;
	    break;
	  case elfcpp::DW_FORM_data8:
	  case elfcpp::DW_FORM_ref8:
	  case elfcpp::DW_FORM_ref_sig8:
	    pattr += 8;
	    break;
	  case elfcpp::DW_FORM_ref_udata:
	  case elfcpp::DW_FORM_udata:
	  case elfcpp::DW_FORM_GNU_addr_index:
	  case elfcpp::DW_FORM_GNU_str_index:
	    read_unsigned_LEB_128(pattr, &len);
	    pattr += len;
	    break;
	  case elfcpp::DW_FORM_sdata:
	    read_signed_LEB_128(pattr, &len);
	    pattr += len;
	    break;
	  case elfcpp::DW_FORM_string:
	    len = strlen(reinterpret_cast<const char*>(pattr));
	    pattr += len + 1;
	    break;
	  default:
	    return 0;
	}
    }

  return this->die_offset_ + (pattr - pdie);
}

// Get the name of the DIE and cache it.

void
Dwarf_die::set_name()
{
  if (this->name_ != NULL || !this->read_attributes())
    return;
  if (this->name_off_ != -1)
    this->name_ = this->dwinfo_->get_string(this->name_off_,
					    this->string_shndx_);
}

// Get the linkage name of the DIE and cache it.

void
Dwarf_die::set_linkage_name()
{
  if (this->linkage_name_ != NULL || !this->read_attributes())
    return;
  if (this->linkage_name_off_ != -1)
    this->linkage_name_ = this->dwinfo_->get_string(this->linkage_name_off_,
						    this->string_shndx_);
}

// Return the value of attribute ATTR.

const Dwarf_die::Attribute_value*
Dwarf_die::attribute(unsigned int attr)
{
  if (!this->read_attributes())
    return NULL;
  for (unsigned int i = 0; i < this->attributes_.size(); ++i)
    {
      if (this->attributes_[i].attr == attr)
        return &this->attributes_[i];
    }
  return NULL;
}

const char*
Dwarf_die::string_attribute(unsigned int attr)
{
  const Attribute_value* attr_val = this->attribute(attr);
  if (attr_val == NULL)
    return NULL;
  switch (attr_val->form)
    {
      case elfcpp::DW_FORM_string:
        return attr_val->val.stringval;
      case elfcpp::DW_FORM_strp:
	return this->dwinfo_->get_string(attr_val->val.refval,
					 attr_val->aux.shndx);
      default:
        return NULL;
    }
}

int64_t
Dwarf_die::int_attribute(unsigned int attr)
{
  const Attribute_value* attr_val = this->attribute(attr);
  if (attr_val == NULL)
    return 0;
  switch (attr_val->form)
    {
      case elfcpp::DW_FORM_flag_present:
      case elfcpp::DW_FORM_data1:
      case elfcpp::DW_FORM_flag:
      case elfcpp::DW_FORM_data2:
      case elfcpp::DW_FORM_data4:
      case elfcpp::DW_FORM_data8:
      case elfcpp::DW_FORM_sdata:
        return attr_val->val.intval;
      default:
        return 0;
    }
}

uint64_t
Dwarf_die::uint_attribute(unsigned int attr)
{
  const Attribute_value* attr_val = this->attribute(attr);
  if (attr_val == NULL)
    return 0;
  switch (attr_val->form)
    {
      case elfcpp::DW_FORM_flag_present:
      case elfcpp::DW_FORM_data1:
      case elfcpp::DW_FORM_flag:
      case elfcpp::DW_FORM_data4:
      case elfcpp::DW_FORM_data8:
      case elfcpp::DW_FORM_ref_sig8:
      case elfcpp::DW_FORM_udata:
        return attr_val->val.uintval;
      default:
        return 0;
    }
}

off_t
Dwarf_die::ref_attribute(unsigned int attr, unsigned int* shndx)
{
  const Attribute_value* attr_val = this->attribute(attr);
  if (attr_val == NULL)
    return -1;
  switch (attr_val->form)
    {
      case elfcpp::DW_FORM_sec_offset:
      case elfcpp::DW_FORM_addr:
      case elfcpp::DW_FORM_ref_addr:
      case elfcpp::DW_FORM_ref1:
      case elfcpp::DW_FORM_ref2:
      case elfcpp::DW_FORM_ref4:
      case elfcpp::DW_FORM_ref8:
      case elfcpp::DW_FORM_ref_udata:
        *shndx = attr_val->aux.shndx;
        return attr_val->val.refval;
      case elfcpp::DW_FORM_ref_sig8:
        *shndx = attr_val->aux.shndx;
        return attr_val->val.uintval;
      case elfcpp::DW_FORM_data4:
      case elfcpp::DW_FORM_data8:
        *shndx = attr_val->aux.shndx;
        return attr_val->val.intval;
      default:
        return -1;
    }
}

off_t
Dwarf_die::address_attribute(unsigned int attr, unsigned int* shndx)
{
  const Attribute_value* attr_val = this->attribute(attr);
  if (attr_val == NULL || attr_val->form != elfcpp::DW_FORM_addr)
    return -1;

  *shndx = attr_val->aux.shndx;
  return attr_val->val.refval;
}

// Return the offset of this DIE's first child.

off_t
Dwarf_die::child_offset()
{
  gold_assert(this->abbrev_code_ != NULL);
  if (!this->has_children())
    return 0;
  if (this->child_offset_ == 0)
    this->child_offset_ = this->skip_attributes();
  return this->child_offset_;
}

// Return the offset of this DIE's next sibling.

off_t
Dwarf_die::sibling_offset()
{
  gold_assert(this->abbrev_code_ != NULL);

  if (this->sibling_offset_ != 0)
    return this->sibling_offset_;

  if (!this->has_children())
    {
      this->sibling_offset_ = this->skip_attributes();
      return this->sibling_offset_;
    }

  if (this->has_sibling_attribute())
    {
      if (!this->read_attributes())
	return 0;
      if (this->sibling_offset_ != 0)
	return this->sibling_offset_;
    }

  // Skip over the children.
  off_t child_offset = this->child_offset();
  while (child_offset > 0)
    {
      Dwarf_die die(this->dwinfo_, child_offset, this);
      // The Dwarf_die ctor will set this DIE's sibling offset
      // when it reads a zero abbrev code.
      if (die.tag() == 0)
	break;
      child_offset = die.sibling_offset();
    }

  // This should be set by now.  If not, there was a problem reading
  // the DWARF info, and we return 0.
  return this->sibling_offset_;
}

// class Dwarf_info_reader

// Begin parsing the debug info.  This calls visit_compilation_unit()
// or visit_type_unit() for each compilation or type unit found in the
// section, and visit_die() for each top-level DIE.

void
Dwarf_info_reader::parse()
{
  if (this->object_->is_big_endian())
    {
#if defined(HAVE_TARGET_32_BIG) || defined(HAVE_TARGET_64_BIG)
      this->do_parse<true>();
#else
      gold_unreachable();
#endif
    }
  else
    {
#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_64_LITTLE)
      this->do_parse<false>();
#else
      gold_unreachable();
#endif
    }
}

template<bool big_endian>
void
Dwarf_info_reader::do_parse()
{
  // Get the section contents and decompress if necessary.
  section_size_type buffer_size;
  bool buffer_is_new;
  this->buffer_ = this->object_->decompressed_section_contents(this->shndx_,
							       &buffer_size,
							       &buffer_is_new);
  if (this->buffer_ == NULL || buffer_size == 0)
    return;
  this->buffer_end_ = this->buffer_ + buffer_size;

  // The offset of this input section in the output section.
  off_t section_offset = this->object_->output_section_offset(this->shndx_);

  // Start tracking relocations for this section.
  this->reloc_mapper_ = make_elf_reloc_mapper(this->object_, this->symtab_,
					      this->symtab_size_);
  this->reloc_mapper_->initialize(this->reloc_shndx_, this->reloc_type_);

  // Loop over compilation units (or type units).
  unsigned int abbrev_shndx = this->abbrev_shndx_;
  off_t abbrev_offset = 0;
  const unsigned char* pinfo = this->buffer_;
  while (pinfo < this->buffer_end_)
    {
      // Read the compilation (or type) unit header.
      const unsigned char* cu_start = pinfo;
      this->cu_offset_ = cu_start - this->buffer_;
      this->cu_length_ = this->buffer_end_ - cu_start;

      // Read unit_length (4 or 12 bytes).
      if (!this->check_buffer(pinfo + 4))
	break;
      uint32_t unit_length =
          elfcpp::Swap_unaligned<32, big_endian>::readval(pinfo);
      pinfo += 4;
      if (unit_length == 0xffffffff)
	{
	  if (!this->check_buffer(pinfo + 8))
	    break;
	  unit_length = elfcpp::Swap_unaligned<64, big_endian>::readval(pinfo);
	  pinfo += 8;
	  this->offset_size_ = 8;
	}
      else
	this->offset_size_ = 4;
      if (!this->check_buffer(pinfo + unit_length))
	break;
      const unsigned char* cu_end = pinfo + unit_length;
      this->cu_length_ = cu_end - cu_start;
      if (!this->check_buffer(pinfo + 2 + this->offset_size_ + 1))
	break;

      // Read version (2 bytes).
      this->cu_version_ =
	  elfcpp::Swap_unaligned<16, big_endian>::readval(pinfo);
      pinfo += 2;

      // Read debug_abbrev_offset (4 or 8 bytes).
      if (this->offset_size_ == 4)
	abbrev_offset = elfcpp::Swap_unaligned<32, big_endian>::readval(pinfo);
      else
	abbrev_offset = elfcpp::Swap_unaligned<64, big_endian>::readval(pinfo);
      if (this->reloc_shndx_ > 0)
	{
	  off_t reloc_offset = pinfo - this->buffer_;
	  off_t value;
	  abbrev_shndx =
	      this->reloc_mapper_->get_reloc_target(reloc_offset, &value);
	  if (abbrev_shndx == 0)
	    return;
	  if (this->reloc_type_ == elfcpp::SHT_REL)
	    abbrev_offset += value;
	  else
	    abbrev_offset = value;
	}
      pinfo += this->offset_size_;

      // Read address_size (1 byte).
      this->address_size_ = *pinfo++;

      // For type units, read the two extra fields.
      uint64_t signature = 0;
      off_t type_offset = 0;
      if (this->is_type_unit_)
        {
	  if (!this->check_buffer(pinfo + 8 + this->offset_size_))
	    break;

	  // Read type_signature (8 bytes).
	  signature = elfcpp::Swap_unaligned<64, big_endian>::readval(pinfo);
	  pinfo += 8;

	  // Read type_offset (4 or 8 bytes).
	  if (this->offset_size_ == 4)
	    type_offset =
		elfcpp::Swap_unaligned<32, big_endian>::readval(pinfo);
	  else
	    type_offset =
		elfcpp::Swap_unaligned<64, big_endian>::readval(pinfo);
	  pinfo += this->offset_size_;
	}

      // Read the .debug_abbrev table.
      this->abbrev_table_.read_abbrevs(this->object_, abbrev_shndx,
				       abbrev_offset);

      // Visit the root DIE.
      Dwarf_die root_die(this,
			 pinfo - (this->buffer_ + this->cu_offset_),
			 NULL);
      if (root_die.tag() != 0)
	{
	  // Visit the CU or TU.
	  if (this->is_type_unit_)
	    this->visit_type_unit(section_offset + this->cu_offset_,
				  type_offset, signature, &root_die);
	  else
	    this->visit_compilation_unit(section_offset + this->cu_offset_,
					 cu_end - cu_start, &root_die);
	}

      // Advance to the next CU.
      pinfo = cu_end;
    }

  if (buffer_is_new)
    {
      delete[] this->buffer_;
      this->buffer_ = NULL;
    }
}

// Read the DWARF string table.

bool
Dwarf_info_reader::do_read_string_table(unsigned int string_shndx)
{
  Relobj* object = this->object_;

  // If we don't have relocations, string_shndx will be 0, and
  // we'll have to hunt for the .debug_str section.
  if (string_shndx == 0)
    {
      for (unsigned int i = 1; i < this->object_->shnum(); ++i)
	{
	  std::string name = object->section_name(i);
	  if (name == ".debug_str")
	    {
	      string_shndx = i;
	      this->string_output_section_offset_ =
		  object->output_section_offset(i);
	      break;
	    }
	}
      if (string_shndx == 0)
	return false;
    }

  if (this->owns_string_buffer_ && this->string_buffer_ != NULL)
    {
      delete[] this->string_buffer_;
      this->owns_string_buffer_ = false;
    }

  // Get the secton contents and decompress if necessary.
  section_size_type buffer_size;
  const unsigned char* buffer =
      object->decompressed_section_contents(string_shndx,
					    &buffer_size,
					    &this->owns_string_buffer_);
  this->string_buffer_ = reinterpret_cast<const char*>(buffer);
  this->string_buffer_end_ = this->string_buffer_ + buffer_size;
  this->string_shndx_ = string_shndx;
  return true;
}

// Read a possibly unaligned integer of SIZE.
template <int valsize>
inline typename elfcpp::Valtype_base<valsize>::Valtype
Dwarf_info_reader::read_from_pointer(const unsigned char* source)
{
  typename elfcpp::Valtype_base<valsize>::Valtype return_value;
  if (this->object_->is_big_endian())
    return_value = elfcpp::Swap_unaligned<valsize, true>::readval(source);
  else
    return_value = elfcpp::Swap_unaligned<valsize, false>::readval(source);
  return return_value;
}

// Read a possibly unaligned integer of SIZE.  Update SOURCE after read.
template <int valsize>
inline typename elfcpp::Valtype_base<valsize>::Valtype
Dwarf_info_reader::read_from_pointer(const unsigned char** source)
{
  typename elfcpp::Valtype_base<valsize>::Valtype return_value;
  if (this->object_->is_big_endian())
    return_value = elfcpp::Swap_unaligned<valsize, true>::readval(*source);
  else
    return_value = elfcpp::Swap_unaligned<valsize, false>::readval(*source);
  *source += valsize / 8;
  return return_value;
}

// Look for a relocation at offset ATTR_OFF in the dwarf info,
// and return the section index and offset of the target.

unsigned int
Dwarf_info_reader::lookup_reloc(off_t attr_off, off_t* target_off)
{
  off_t value;
  attr_off += this->cu_offset_;
  unsigned int shndx = this->reloc_mapper_->get_reloc_target(attr_off, &value);
  if (shndx == 0)
    return 0;
  if (this->reloc_type_ == elfcpp::SHT_REL)
    *target_off += value;
  else
    *target_off = value;
  return shndx;
}

// Return a string from the DWARF string table.

const char*
Dwarf_info_reader::get_string(off_t str_off, unsigned int string_shndx)
{
  if (!this->read_string_table(string_shndx))
    return NULL;

  // Correct the offset.  For incremental update links, we have a
  // relocated offset that is relative to the output section, but
  // here we need an offset relative to the input section.
  str_off -= this->string_output_section_offset_;

  const char* p = this->string_buffer_ + str_off;

  if (p < this->string_buffer_ || p >= this->string_buffer_end_)
    return NULL;

  return p;
}

// The following are default, do-nothing, implementations of the
// hook methods normally provided by a derived class.  We provide
// default implementations rather than no implementation so that
// a derived class needs to implement only the hooks that it needs
// to use.

// Process a compilation unit and parse its child DIE.

void
Dwarf_info_reader::visit_compilation_unit(off_t, off_t, Dwarf_die*)
{
}

// Process a type unit and parse its child DIE.

void
Dwarf_info_reader::visit_type_unit(off_t, off_t, uint64_t, Dwarf_die*)
{
}

// Print a warning about a corrupt debug section.

void
Dwarf_info_reader::warn_corrupt_debug_section() const
{
  gold_warning(_("%s: corrupt debug info in %s"),
	       this->object_->name().c_str(),
	       this->object_->section_name(this->shndx_).c_str());
}

// class Sized_dwarf_line_info

struct LineStateMachine
{
  int file_num;
  uint64_t address;
  int line_num;
  int column_num;
  unsigned int shndx;    // the section address refers to
  bool is_stmt;          // stmt means statement.
  bool basic_block;
  bool end_sequence;
};

static void
ResetLineStateMachine(struct LineStateMachine* lsm, bool default_is_stmt)
{
  lsm->file_num = 1;
  lsm->address = 0;
  lsm->line_num = 1;
  lsm->column_num = 0;
  lsm->shndx = -1U;
  lsm->is_stmt = default_is_stmt;
  lsm->basic_block = false;
  lsm->end_sequence = false;
}

template<int size, bool big_endian>
Sized_dwarf_line_info<size, big_endian>::Sized_dwarf_line_info(
    Object* object,
    unsigned int read_shndx)
  : data_valid_(false), buffer_(NULL), buffer_start_(NULL),
    reloc_mapper_(NULL), symtab_buffer_(NULL), directories_(), files_(),
    current_header_index_(-1)
{
  unsigned int debug_shndx;

  for (debug_shndx = 1; debug_shndx < object->shnum(); ++debug_shndx)
    {
      // FIXME: do this more efficiently: section_name() isn't super-fast
      std::string name = object->section_name(debug_shndx);
      if (name == ".debug_line" || name == ".zdebug_line")
	{
	  section_size_type buffer_size;
	  bool is_new = false;
	  this->buffer_ = object->decompressed_section_contents(debug_shndx,
								&buffer_size,
								&is_new);
	  if (is_new)
	    this->buffer_start_ = this->buffer_;
	  this->buffer_end_ = this->buffer_ + buffer_size;
	  break;
	}
    }
  if (this->buffer_ == NULL)
    return;

  // Find the relocation section for ".debug_line".
  // We expect these for relobjs (.o's) but not dynobjs (.so's).
  unsigned int reloc_shndx = 0;
  for (unsigned int i = 0; i < object->shnum(); ++i)
    {
      unsigned int reloc_sh_type = object->section_type(i);
      if ((reloc_sh_type == elfcpp::SHT_REL
	   || reloc_sh_type == elfcpp::SHT_RELA)
	  && object->section_info(i) == debug_shndx)
	{
	  reloc_shndx = i;
	  this->track_relocs_type_ = reloc_sh_type;
	  break;
	}
    }

  // Finally, we need the symtab section to interpret the relocs.
  if (reloc_shndx != 0)
    {
      unsigned int symtab_shndx;
      for (symtab_shndx = 0; symtab_shndx < object->shnum(); ++symtab_shndx)
        if (object->section_type(symtab_shndx) == elfcpp::SHT_SYMTAB)
          {
	    this->symtab_buffer_ = object->section_contents(
		symtab_shndx, &this->symtab_buffer_size_, false);
            break;
          }
      if (this->symtab_buffer_ == NULL)
        return;
    }

  this->reloc_mapper_ =
      new Sized_elf_reloc_mapper<size, big_endian>(object,
						   this->symtab_buffer_,
						   this->symtab_buffer_size_);
  if (!this->reloc_mapper_->initialize(reloc_shndx, this->track_relocs_type_))
    return;

  // Now that we have successfully read all the data, parse the debug
  // info.
  this->data_valid_ = true;
  this->read_line_mappings(read_shndx);
}

// Read the DWARF header.

template<int size, bool big_endian>
const unsigned char*
Sized_dwarf_line_info<size, big_endian>::read_header_prolog(
    const unsigned char* lineptr)
{
  uint32_t initial_length = elfcpp::Swap_unaligned<32, big_endian>::readval(lineptr);
  lineptr += 4;

  // In DWARF2/3, if the initial length is all 1 bits, then the offset
  // size is 8 and we need to read the next 8 bytes for the real length.
  if (initial_length == 0xffffffff)
    {
      header_.offset_size = 8;
      initial_length = elfcpp::Swap_unaligned<64, big_endian>::readval(lineptr);
      lineptr += 8;
    }
  else
    header_.offset_size = 4;

  header_.total_length = initial_length;

  gold_assert(lineptr + header_.total_length <= buffer_end_);

  header_.version = elfcpp::Swap_unaligned<16, big_endian>::readval(lineptr);
  lineptr += 2;

  if (header_.offset_size == 4)
    header_.prologue_length = elfcpp::Swap_unaligned<32, big_endian>::readval(lineptr);
  else
    header_.prologue_length = elfcpp::Swap_unaligned<64, big_endian>::readval(lineptr);
  lineptr += header_.offset_size;

  header_.min_insn_length = *lineptr;
  lineptr += 1;

  header_.default_is_stmt = *lineptr;
  lineptr += 1;

  header_.line_base = *reinterpret_cast<const signed char*>(lineptr);
  lineptr += 1;

  header_.line_range = *lineptr;
  lineptr += 1;

  header_.opcode_base = *lineptr;
  lineptr += 1;

  header_.std_opcode_lengths.resize(header_.opcode_base + 1);
  header_.std_opcode_lengths[0] = 0;
  for (int i = 1; i < header_.opcode_base; i++)
    {
      header_.std_opcode_lengths[i] = *lineptr;
      lineptr += 1;
    }

  return lineptr;
}

// The header for a debug_line section is mildly complicated, because
// the line info is very tightly encoded.

template<int size, bool big_endian>
const unsigned char*
Sized_dwarf_line_info<size, big_endian>::read_header_tables(
    const unsigned char* lineptr)
{
  ++this->current_header_index_;

  // Create a new directories_ entry and a new files_ entry for our new
  // header.  We initialize each with a single empty element, because
  // dwarf indexes directory and filenames starting at 1.
  gold_assert(static_cast<int>(this->directories_.size())
	      == this->current_header_index_);
  gold_assert(static_cast<int>(this->files_.size())
	      == this->current_header_index_);
  this->directories_.push_back(std::vector<std::string>(1));
  this->files_.push_back(std::vector<std::pair<int, std::string> >(1));

  // It is legal for the directory entry table to be empty.
  if (*lineptr)
    {
      int dirindex = 1;
      while (*lineptr)
        {
	  const char* dirname = reinterpret_cast<const char*>(lineptr);
          gold_assert(dirindex
		      == static_cast<int>(this->directories_.back().size()));
          this->directories_.back().push_back(dirname);
          lineptr += this->directories_.back().back().size() + 1;
          dirindex++;
        }
    }
  lineptr++;

  // It is also legal for the file entry table to be empty.
  if (*lineptr)
    {
      int fileindex = 1;
      size_t len;
      while (*lineptr)
        {
          const char* filename = reinterpret_cast<const char*>(lineptr);
          lineptr += strlen(filename) + 1;

          uint64_t dirindex = read_unsigned_LEB_128(lineptr, &len);
          lineptr += len;

          if (dirindex >= this->directories_.back().size())
            dirindex = 0;
	  int dirindexi = static_cast<int>(dirindex);

          read_unsigned_LEB_128(lineptr, &len);   // mod_time
          lineptr += len;

          read_unsigned_LEB_128(lineptr, &len);   // filelength
          lineptr += len;

          gold_assert(fileindex
		      == static_cast<int>(this->files_.back().size()));
          this->files_.back().push_back(std::make_pair(dirindexi, filename));
          fileindex++;
        }
    }
  lineptr++;

  return lineptr;
}

// Process a single opcode in the .debug.line structure.

template<int size, bool big_endian>
bool
Sized_dwarf_line_info<size, big_endian>::process_one_opcode(
    const unsigned char* start, struct LineStateMachine* lsm, size_t* len)
{
  size_t oplen = 0;
  size_t templen;
  unsigned char opcode = *start;
  oplen++;
  start++;

  // If the opcode is great than the opcode_base, it is a special
  // opcode. Most line programs consist mainly of special opcodes.
  if (opcode >= header_.opcode_base)
    {
      opcode -= header_.opcode_base;
      const int advance_address = ((opcode / header_.line_range)
                                   * header_.min_insn_length);
      lsm->address += advance_address;

      const int advance_line = ((opcode % header_.line_range)
                                + header_.line_base);
      lsm->line_num += advance_line;
      lsm->basic_block = true;
      *len = oplen;
      return true;
    }

  // Otherwise, we have the regular opcodes
  switch (opcode)
    {
    case elfcpp::DW_LNS_copy:
      lsm->basic_block = false;
      *len = oplen;
      return true;

    case elfcpp::DW_LNS_advance_pc:
      {
        const uint64_t advance_address
            = read_unsigned_LEB_128(start, &templen);
        oplen += templen;
        lsm->address += header_.min_insn_length * advance_address;
      }
      break;

    case elfcpp::DW_LNS_advance_line:
      {
        const uint64_t advance_line = read_signed_LEB_128(start, &templen);
        oplen += templen;
        lsm->line_num += advance_line;
      }
      break;

    case elfcpp::DW_LNS_set_file:
      {
        const uint64_t fileno = read_unsigned_LEB_128(start, &templen);
        oplen += templen;
        lsm->file_num = fileno;
      }
      break;

    case elfcpp::DW_LNS_set_column:
      {
        const uint64_t colno = read_unsigned_LEB_128(start, &templen);
        oplen += templen;
        lsm->column_num = colno;
      }
      break;

    case elfcpp::DW_LNS_negate_stmt:
      lsm->is_stmt = !lsm->is_stmt;
      break;

    case elfcpp::DW_LNS_set_basic_block:
      lsm->basic_block = true;
      break;

    case elfcpp::DW_LNS_fixed_advance_pc:
      {
        int advance_address;
        advance_address = elfcpp::Swap_unaligned<16, big_endian>::readval(start);
        oplen += 2;
        lsm->address += advance_address;
      }
      break;

    case elfcpp::DW_LNS_const_add_pc:
      {
        const int advance_address = (header_.min_insn_length
                                     * ((255 - header_.opcode_base)
                                        / header_.line_range));
        lsm->address += advance_address;
      }
      break;

    case elfcpp::DW_LNS_extended_op:
      {
        const uint64_t extended_op_len
            = read_unsigned_LEB_128(start, &templen);
        start += templen;
        oplen += templen + extended_op_len;

        const unsigned char extended_op = *start;
        start++;

        switch (extended_op)
          {
          case elfcpp::DW_LNE_end_sequence:
            // This means that the current byte is the one immediately
            // after a set of instructions.  Record the current line
            // for up to one less than the current address.
            lsm->line_num = -1;
            lsm->end_sequence = true;
            *len = oplen;
            return true;

          case elfcpp::DW_LNE_set_address:
            {
              lsm->address =
		elfcpp::Swap_unaligned<size, big_endian>::readval(start);
              typename Reloc_map::const_iterator it
                  = this->reloc_map_.find(start - this->buffer_);
              if (it != reloc_map_.end())
                {
		  // If this is a SHT_RELA section, then ignore the
		  // section contents.  This assumes that this is a
		  // straight reloc which just uses the reloc addend.
		  // The reloc addend has already been included in the
		  // symbol value.
		  if (this->track_relocs_type_ == elfcpp::SHT_RELA)
		    lsm->address = 0;
		  // Add in the symbol value.
		  lsm->address += it->second.second;
                  lsm->shndx = it->second.first;
                }
              else
                {
                  // If we're a normal .o file, with relocs, every
                  // set_address should have an associated relocation.
		  if (this->input_is_relobj())
                    this->data_valid_ = false;
                }
              break;
            }
          case elfcpp::DW_LNE_define_file:
            {
              const char* filename  = reinterpret_cast<const char*>(start);
              templen = strlen(filename) + 1;
              start += templen;

              uint64_t dirindex = read_unsigned_LEB_128(start, &templen);

              if (dirindex >= this->directories_.back().size())
                dirindex = 0;
	      int dirindexi = static_cast<int>(dirindex);

              // This opcode takes two additional ULEB128 parameters
              // (mod_time and filelength), but we don't use those
              // values.  Because OPLEN already tells us how far to
              // skip to the next opcode, we don't need to read
              // them at all.

              this->files_.back().push_back(std::make_pair(dirindexi,
							   filename));
            }
            break;
          }
      }
      break;

    default:
      {
        // Ignore unknown opcode  silently
        for (int i = 0; i < header_.std_opcode_lengths[opcode]; i++)
          {
            size_t templen;
            read_unsigned_LEB_128(start, &templen);
            start += templen;
            oplen += templen;
          }
      }
      break;
  }
  *len = oplen;
  return false;
}

// Read the debug information at LINEPTR and store it in the line
// number map.

template<int size, bool big_endian>
unsigned const char*
Sized_dwarf_line_info<size, big_endian>::read_lines(unsigned const char* lineptr,
                                                    unsigned int shndx)
{
  struct LineStateMachine lsm;

  // LENGTHSTART is the place the length field is based on.  It is the
  // point in the header after the initial length field.
  const unsigned char* lengthstart = buffer_;

  // In 64 bit dwarf, the initial length is 12 bytes, because of the
  // 0xffffffff at the start.
  if (header_.offset_size == 8)
    lengthstart += 12;
  else
    lengthstart += 4;

  while (lineptr < lengthstart + header_.total_length)
    {
      ResetLineStateMachine(&lsm, header_.default_is_stmt);
      while (!lsm.end_sequence)
        {
          size_t oplength;
          bool add_line = this->process_one_opcode(lineptr, &lsm, &oplength);
          if (add_line
              && (shndx == -1U || lsm.shndx == -1U || shndx == lsm.shndx))
            {
              Offset_to_lineno_entry entry
                  = { static_cast<off_t>(lsm.address),
		      this->current_header_index_,
		      static_cast<unsigned int>(lsm.file_num),
		      true, lsm.line_num };
	      std::vector<Offset_to_lineno_entry>&
		map(this->line_number_map_[lsm.shndx]);
	      // If we see two consecutive entries with the same
	      // offset and a real line number, then mark the first
	      // one as non-canonical.
	      if (!map.empty()
		  && (map.back().offset == static_cast<off_t>(lsm.address))
		  && lsm.line_num != -1
		  && map.back().line_num != -1)
		map.back().last_line_for_offset = false;
	      map.push_back(entry);
            }
          lineptr += oplength;
        }
    }

  return lengthstart + header_.total_length;
}

// Read the relocations into a Reloc_map.

template<int size, bool big_endian>
void
Sized_dwarf_line_info<size, big_endian>::read_relocs()
{
  if (this->symtab_buffer_ == NULL)
    return;

  off_t value;
  off_t reloc_offset;
  while ((reloc_offset = this->reloc_mapper_->next_offset()) != -1)
    {
      const unsigned int shndx =
          this->reloc_mapper_->get_reloc_target(reloc_offset, &value);

      // There is no reason to record non-ordinary section indexes, or
      // SHN_UNDEF, because they will never match the real section.
      if (shndx != 0)
	this->reloc_map_[reloc_offset] = std::make_pair(shndx, value);

      this->reloc_mapper_->advance(reloc_offset + 1);
    }
}

// Read the line number info.

template<int size, bool big_endian>
void
Sized_dwarf_line_info<size, big_endian>::read_line_mappings(unsigned int shndx)
{
  gold_assert(this->data_valid_ == true);

  this->read_relocs();
  while (this->buffer_ < this->buffer_end_)
    {
      const unsigned char* lineptr = this->buffer_;
      lineptr = this->read_header_prolog(lineptr);
      lineptr = this->read_header_tables(lineptr);
      lineptr = this->read_lines(lineptr, shndx);
      this->buffer_ = lineptr;
    }

  // Sort the lines numbers, so addr2line can use binary search.
  for (typename Lineno_map::iterator it = line_number_map_.begin();
       it != line_number_map_.end();
       ++it)
    // Each vector needs to be sorted by offset.
    std::sort(it->second.begin(), it->second.end());
}

// Some processing depends on whether the input is a .o file or not.
// For instance, .o files have relocs, and have .debug_lines
// information on a per section basis.  .so files, on the other hand,
// lack relocs, and offsets are unique, so we can ignore the section
// information.

template<int size, bool big_endian>
bool
Sized_dwarf_line_info<size, big_endian>::input_is_relobj()
{
  // Only .o files have relocs and the symtab buffer that goes with them.
  return this->symtab_buffer_ != NULL;
}

// Given an Offset_to_lineno_entry vector, and an offset, figure out
// if the offset points into a function according to the vector (see
// comments below for the algorithm).  If it does, return an iterator
// into the vector that points to the line-number that contains that
// offset.  If not, it returns vector::end().

static std::vector<Offset_to_lineno_entry>::const_iterator
offset_to_iterator(const std::vector<Offset_to_lineno_entry>* offsets,
                   off_t offset)
{
  const Offset_to_lineno_entry lookup_key = { offset, 0, 0, true, 0 };

  // lower_bound() returns the smallest offset which is >= lookup_key.
  // If no offset in offsets is >= lookup_key, returns end().
  std::vector<Offset_to_lineno_entry>::const_iterator it
      = std::lower_bound(offsets->begin(), offsets->end(), lookup_key);

  // This code is easiest to understand with a concrete example.
  // Here's a possible offsets array:
  // {{offset = 3211, header_num = 0, file_num = 1, last, line_num = 16},  // 0
  //  {offset = 3224, header_num = 0, file_num = 1, last, line_num = 20},  // 1
  //  {offset = 3226, header_num = 0, file_num = 1, last, line_num = 22},  // 2
  //  {offset = 3231, header_num = 0, file_num = 1, last, line_num = 25},  // 3
  //  {offset = 3232, header_num = 0, file_num = 1, last, line_num = -1},  // 4
  //  {offset = 3232, header_num = 0, file_num = 1, last, line_num = 65},  // 5
  //  {offset = 3235, header_num = 0, file_num = 1, last, line_num = 66},  // 6
  //  {offset = 3236, header_num = 0, file_num = 1, last, line_num = -1},  // 7
  //  {offset = 5764, header_num = 0, file_num = 1, last, line_num = 48},  // 8
  //  {offset = 5764, header_num = 0, file_num = 1,!last, line_num = 47},  // 9
  //  {offset = 5765, header_num = 0, file_num = 1, last, line_num = 49},  // 10
  //  {offset = 5767, header_num = 0, file_num = 1, last, line_num = 50},  // 11
  //  {offset = 5768, header_num = 0, file_num = 1, last, line_num = 51},  // 12
  //  {offset = 5773, header_num = 0, file_num = 1, last, line_num = -1},  // 13
  //  {offset = 5787, header_num = 1, file_num = 1, last, line_num = 19},  // 14
  //  {offset = 5790, header_num = 1, file_num = 1, last, line_num = 20},  // 15
  //  {offset = 5793, header_num = 1, file_num = 1, last, line_num = 67},  // 16
  //  {offset = 5793, header_num = 1, file_num = 1, last, line_num = -1},  // 17
  //  {offset = 5793, header_num = 1, file_num = 1,!last, line_num = 66},  // 18
  //  {offset = 5795, header_num = 1, file_num = 1, last, line_num = 68},  // 19
  //  {offset = 5798, header_num = 1, file_num = 1, last, line_num = -1},  // 20
  // The entries with line_num == -1 mark the end of a function: the
  // associated offset is one past the last instruction in the
  // function.  This can correspond to the beginning of the next
  // function (as is true for offset 3232); alternately, there can be
  // a gap between the end of one function and the start of the next
  // (as is true for some others, most obviously from 3236->5764).
  //
  // Case 1: lookup_key has offset == 10.  lower_bound returns
  //         offsets[0].  Since it's not an exact match and we're
  //         at the beginning of offsets, we return end() (invalid).
  // Case 2: lookup_key has offset 10000.  lower_bound returns
  //         offset[21] (end()).  We return end() (invalid).
  // Case 3: lookup_key has offset == 3211.  lower_bound matches
  //         offsets[0] exactly, and that's the entry we return.
  // Case 4: lookup_key has offset == 3232.  lower_bound returns
  //         offsets[4].  That's an exact match, but indicates
  //         end-of-function.  We check if offsets[5] is also an
  //         exact match but not end-of-function.  It is, so we
  //         return offsets[5].
  // Case 5: lookup_key has offset == 3214.  lower_bound returns
  //         offsets[1].  Since it's not an exact match, we back
  //         up to the offset that's < lookup_key, offsets[0].
  //         We note offsets[0] is a valid entry (not end-of-function),
  //         so that's the entry we return.
  // Case 6: lookup_key has offset == 4000.  lower_bound returns
  //         offsets[8].  Since it's not an exact match, we back
  //         up to offsets[7].  Since offsets[7] indicates
  //         end-of-function, we know lookup_key is between
  //         functions, so we return end() (not a valid offset).
  // Case 7: lookup_key has offset == 5794.  lower_bound returns
  //         offsets[19].  Since it's not an exact match, we back
  //         up to offsets[16].  Note we back up to the *first*
  //         entry with offset 5793, not just offsets[19-1].
  //         We note offsets[16] is a valid entry, so we return it.
  //         If offsets[16] had had line_num == -1, we would have
  //         checked offsets[17].  The reason for this is that
  //         16 and 17 can be in an arbitrary order, since we sort
  //         only by offset and last_line_for_offset.  (Note it
  //         doesn't help to use line_number as a tertiary sort key,
  //         since sometimes we want the -1 to be first and sometimes
  //         we want it to be last.)

  // This deals with cases (1) and (2).
  if ((it == offsets->begin() && offset < it->offset)
      || it == offsets->end())
    return offsets->end();

  // This deals with cases (3) and (4).
  if (offset == it->offset)
    {
      while (it != offsets->end()
             && it->offset == offset
             && it->line_num == -1)
        ++it;
      if (it == offsets->end() || it->offset != offset)
        return offsets->end();
      else
        return it;
    }

  // This handles the first part of case (7) -- we back up to the
  // *first* entry that has the offset that's behind us.
  gold_assert(it != offsets->begin());
  std::vector<Offset_to_lineno_entry>::const_iterator range_end = it;
  --it;
  const off_t range_value = it->offset;
  while (it != offsets->begin() && (it-1)->offset == range_value)
    --it;

  // This handles cases (5), (6), and (7): if any entry in the
  // equal_range [it, range_end) has a line_num != -1, it's a valid
  // match.  If not, we're not in a function.  The line number we saw
  // last for an offset will be sorted first, so it'll get returned if
  // it's present.
  for (; it != range_end; ++it)
    if (it->line_num != -1)
      return it;
  return offsets->end();
}

// Returns the canonical filename:lineno for the address passed in.
// If other_lines is not NULL, appends the non-canonical lines
// assigned to the same address.

template<int size, bool big_endian>
std::string
Sized_dwarf_line_info<size, big_endian>::do_addr2line(
    unsigned int shndx,
    off_t offset,
    std::vector<std::string>* other_lines)
{
  if (this->data_valid_ == false)
    return "";

  const std::vector<Offset_to_lineno_entry>* offsets;
  // If we do not have reloc information, then our input is a .so or
  // some similar data structure where all the information is held in
  // the offset.  In that case, we ignore the input shndx.
  if (this->input_is_relobj())
    offsets = &this->line_number_map_[shndx];
  else
    offsets = &this->line_number_map_[-1U];
  if (offsets->empty())
    return "";

  typename std::vector<Offset_to_lineno_entry>::const_iterator it
      = offset_to_iterator(offsets, offset);
  if (it == offsets->end())
    return "";

  std::string result = this->format_file_lineno(*it);
  if (other_lines != NULL)
    for (++it; it != offsets->end() && it->offset == offset; ++it)
      {
        if (it->line_num == -1)
          continue;  // The end of a previous function.
        other_lines->push_back(this->format_file_lineno(*it));
      }
  return result;
}

// Convert the file_num + line_num into a string.

template<int size, bool big_endian>
std::string
Sized_dwarf_line_info<size, big_endian>::format_file_lineno(
    const Offset_to_lineno_entry& loc) const
{
  std::string ret;

  gold_assert(loc.header_num < static_cast<int>(this->files_.size()));
  gold_assert(loc.file_num
	      < static_cast<unsigned int>(this->files_[loc.header_num].size()));
  const std::pair<int, std::string>& filename_pair
      = this->files_[loc.header_num][loc.file_num];
  const std::string& filename = filename_pair.second;

  gold_assert(loc.header_num < static_cast<int>(this->directories_.size()));
  gold_assert(filename_pair.first
              < static_cast<int>(this->directories_[loc.header_num].size()));
  const std::string& dirname
      = this->directories_[loc.header_num][filename_pair.first];

  if (!dirname.empty())
    {
      ret += dirname;
      ret += "/";
    }
  ret += filename;
  if (ret.empty())
    ret = "(unknown)";

  char buffer[64];   // enough to hold a line number
  snprintf(buffer, sizeof(buffer), "%d", loc.line_num);
  ret += ":";
  ret += buffer;

  return ret;
}

// Dwarf_line_info routines.

static unsigned int next_generation_count = 0;

struct Addr2line_cache_entry
{
  Object* object;
  unsigned int shndx;
  Dwarf_line_info* dwarf_line_info;
  unsigned int generation_count;
  unsigned int access_count;

  Addr2line_cache_entry(Object* o, unsigned int s, Dwarf_line_info* d)
      : object(o), shndx(s), dwarf_line_info(d),
        generation_count(next_generation_count), access_count(0)
  {
    if (next_generation_count < (1U << 31))
      ++next_generation_count;
  }
};
// We expect this cache to be small, so don't bother with a hashtable
// or priority queue or anything: just use a simple vector.
static std::vector<Addr2line_cache_entry> addr2line_cache;

std::string
Dwarf_line_info::one_addr2line(Object* object,
                               unsigned int shndx, off_t offset,
                               size_t cache_size,
                               std::vector<std::string>* other_lines)
{
  Dwarf_line_info* lineinfo = NULL;
  std::vector<Addr2line_cache_entry>::iterator it;

  // First, check the cache.  If we hit, update the counts.
  for (it = addr2line_cache.begin(); it != addr2line_cache.end(); ++it)
    {
      if (it->object == object && it->shndx == shndx)
        {
          lineinfo = it->dwarf_line_info;
          it->generation_count = next_generation_count;
          // We cap generation_count at 2^31 -1 to avoid overflow.
          if (next_generation_count < (1U << 31))
            ++next_generation_count;
          // We cap access_count at 31 so 2^access_count doesn't overflow
          if (it->access_count < 31)
            ++it->access_count;
          break;
        }
    }

  // If we don't hit the cache, create a new object and insert into the
  // cache.
  if (lineinfo == NULL)
  {
    switch (parameters->size_and_endianness())
      {
#ifdef HAVE_TARGET_32_LITTLE
        case Parameters::TARGET_32_LITTLE:
          lineinfo = new Sized_dwarf_line_info<32, false>(object, shndx); break;
#endif
#ifdef HAVE_TARGET_32_BIG
        case Parameters::TARGET_32_BIG:
          lineinfo = new Sized_dwarf_line_info<32, true>(object, shndx); break;
#endif
#ifdef HAVE_TARGET_64_LITTLE
        case Parameters::TARGET_64_LITTLE:
          lineinfo = new Sized_dwarf_line_info<64, false>(object, shndx); break;
#endif
#ifdef HAVE_TARGET_64_BIG
        case Parameters::TARGET_64_BIG:
          lineinfo = new Sized_dwarf_line_info<64, true>(object, shndx); break;
#endif
        default:
          gold_unreachable();
      }
    addr2line_cache.push_back(Addr2line_cache_entry(object, shndx, lineinfo));
  }

  // Now that we have our object, figure out the answer
  std::string retval = lineinfo->addr2line(shndx, offset, other_lines);

  // Finally, if our cache has grown too big, delete old objects.  We
  // assume the common (probably only) case is deleting only one object.
  // We use a pretty simple scheme to evict: function of LRU and MFU.
  while (addr2line_cache.size() > cache_size)
    {
      unsigned int lowest_score = ~0U;
      std::vector<Addr2line_cache_entry>::iterator lowest
          = addr2line_cache.end();
      for (it = addr2line_cache.begin(); it != addr2line_cache.end(); ++it)
        {
          const unsigned int score = (it->generation_count
                                      + (1U << it->access_count));
          if (score < lowest_score)
            {
              lowest_score = score;
              lowest = it;
            }
        }
      if (lowest != addr2line_cache.end())
        {
          delete lowest->dwarf_line_info;
          addr2line_cache.erase(lowest);
        }
    }

  return retval;
}

void
Dwarf_line_info::clear_addr2line_cache()
{
  for (std::vector<Addr2line_cache_entry>::iterator it = addr2line_cache.begin();
       it != addr2line_cache.end();
       ++it)
    delete it->dwarf_line_info;
  addr2line_cache.clear();
}

#ifdef HAVE_TARGET_32_LITTLE
template
class Sized_dwarf_line_info<32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Sized_dwarf_line_info<32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Sized_dwarf_line_info<64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Sized_dwarf_line_info<64, true>;
#endif

} // End namespace gold.
@


1.50
log
@2013-07-22  Sterling Augustine  <saugustine@@google.com>

	* dwarf_reader.cc (Dwarf_pubnames_table::read_section):
	Convert parameter shndx to local variable. Add parameters symtab
	and symtab_size.  Scan over section names.  Find relocation
	section corresponding to current section.  Create and initialize
	reloc_mapper_ and reloc_type_.
	(Dwarf_pubnames_table::read_header):  Add assertion.  Change
	unit_length to off_t.  Initialize member unit_length_.  Fill in field
	cu_offset_.
	* dwarf_reader.h (Dwarf_pubnames_table::Dwarf_pubnames_table):
	Initialize new fields unit_length_ and cu_offset_.
	(Dwarf_pubnames_table::read_section): Update prototype.
	(Dwarf_pubnames_table::cu_offset): New member function.
	(Dwarf_pubnames_table::subsection_size): Likewise.
	(Dwarf_pubnames_table::cu_offset_, Dwarf_pubnames_table::unit_length):
	New fields.
	(Dwarf_info_reader::symtab, Dwarf_info_reader::symtab_size): Make
	member functions public.
	* gdb_index.cc (Gdb_index_info_reader::read_pubnames_and_pubtypes):
	Update comment.  Rework logic.  Move repeated parts to...
	(Gdb_index_info_reader::read_pubtable): ...here. New function.
	(Gdb_index::Gdb_index): Initialize new fields, pubnames_table_,
	pubtypes_table_, and stmt_list_offset.
	(Gdb_index::map_pubtable_to_dies, Gdb_index::find_pubname_offset,
	Gdb_index::find_pubtype_offset,
	Gdb_index::map_pubnames_and_types_to_dies): Define new functions.
	(Gdb_index::pubnames_read): Update prototype and rework logic.
	* gdb_index.h (Gdb_index_info_reader, Dwarf_pubnames_table):
	Forward declare.
	(Gdb_index::map_pubtable_to_dies, Gdb_index::find_pubname_offset,
	Gdb_index::find_pubtype_offset, Gdb_index::pubnames_table)
	Gdb_index::pubtypes_table, Gdb_index::map_pubnames_and_types_to_dies,
	Gdb_index::map_pubtable_to_dies):
	Declare functions.
	(Gdb_index::pubnames_read): Update declaration.
	(Gdb_index::Pubname_offset_map): New type.
	(Gdb_index::cu_pubname_map_, Gdb_index::cu_pubtype_map_,
	Gdb_index::pubnames_table_, Gdb_index::pubtypes_table_,
	Gdb_index::stmt_list_offset): Declare.
	(Gdb_index::pubnames_shndx_, Gdb_index::pubnames_offet_,
	Gdb_index::pubtypes_object_, Gdb_index::pubtypes_shndx_)
	Gdb_index::pubtypes_offset_): Remove.
@
text
@d1337 1
a1337 2
				  cu_end - cu_start, type_offset, signature,
				  &root_die);
d1480 1
a1480 1
Dwarf_info_reader::visit_type_unit(off_t, off_t, off_t, uint64_t, Dwarf_die*)
@


1.49
log
@gold/
	* dwarf_reader.cc (Dwarf_ranges_table::read_ranges_table): Save
	reloc_type_.
	(Dwarf_ranges_table::read_range_list): Call lookup_reloc.
	(Dwarf_ranges_table::lookup_reloc): New function.
	* dwarf_reader.h (Dwarf_ranges_table::Dwarf_ranges_table): Initialize
	reloc_type_.
	(Dwarf_ranges_table::lookup_reloc): New function.
	(Dwarf_ranges_table::reloc_type_): New data member.
@
text
@d481 1
a481 1
// Read the pubnames section SHNDX from the object file.
d484 2
a485 1
Dwarf_pubnames_table::read_section(Relobj* object, unsigned int shndx)
d488 1
d490 5
a494 3
  // If we don't have relocations, shndx will be 0, and
  // we'll have to hunt for the .debug_pubnames/pubtypes section.
  if (shndx == 0)
d496 6
a501 14
      const char* name = (this->is_pubtypes_
			  ? ".debug_pubtypes"
			  : ".debug_pubnames");
      for (unsigned int i = 1; i < object->shnum(); ++i)
	{
	  if (object->section_name(i) == name)
	    {
	      shndx = i;
	      this->output_section_offset_ = object->output_section_offset(i);
	      break;
	    }
	}
      if (shndx == 0)
	return false;
d503 3
d513 24
d545 3
d559 1
a559 1
  uint32_t unit_length = this->dwinfo_->read_from_pointer<32>(pinfo);
d564 1
d569 4
a572 1
    this->offset_size_ = 4;
d580 3
@


1.48
log
@Add dwp support for v2 DWARF package file format.

gold/
	* dwarf_reader.cc (Dwarf_info_reader::visit_type_unit): Add
	tu_length parameter.  Adjust all callers.
	* dwarf_reader.h (Dwarf_info_reader::visit_type_unit): Likewise.
	* dwp.cc: Include dwarf.h.
	(Section_bounds): New struct type.
	(Unit_set): New struct type.
	(Dwo_file::Dwo_file): Initialize new data member.
	(Dwo_file::read_compunit_index, Dwo_file::read_typeunit_index):
	Combine and rename to...
	(Dwo_file::read_unit_index): ...this.
	(Dwo_file::sized_read_compunit_index)
	(Dwo_file::sized_read_typeunit_index): Combine and rename to...
	(Dwo_file::sized_read_unit_index): ...this.
	(Dwo_file::copy_section): Remove section_name, is_str_offsets
	parameters; add section_id parameter.
	(Dwo_file::add_cu_set, Dwo_file::add_tu_set): Combine and rename to...
	(Dwo_file::add_unit_set): ...this.
	(Dwo_file::shndx_map_): Remove.
	(Dwo_file::sect_offsets_): New data member.
	(Dwp_output_file::Dwp_output_file): Initialize new data members.
	(Dwp_output_file::add_section): Rename to...
	(Dwp_output_file::add_contribution): ...this.
	(Dwp_output_file::add_cu_set): Combine parameters into a struct.
	(Dwp_output_file::add_tu_set): Likewise.
	(Dwp_output_file::Contribution): New type.
	(Dwp_output_file::Section::contributions): New data member.
	(Dwp_output_file::Cu_or_tu_set): Remove.
	(Dwp_output_file::Section::Section): New ctor.
	(Dwp_output_file::Dwp_index::Shndx_pool): Remove.
	(Dwp_output_file::Dwp_index::Section_table): New type.
	(Dwp_output_file::Dwp_index::Dwp_index): Initialize new data members.
	(Dwp_output_file::Dwp_index::enter_set): Change type of "set"
	parameter.
	(Dwp_output_file::Dwp_index::shndx_pool): Remove.
	(Dwp_output_file::Dwp_index::shndx_pool_end): Remove.
	(Dwp_output_file::Dwp_index::section_table): New member function.
	(Dwp_output_file::Dwp_index::section_table_end): New member function.
	(Dwp_output_file::Dwp_index::shndx_pool_size): Remove.
	(Dwp_output_file::Dwp_index::section_table_rows): New member function.
	(Dwp_output_file::Dwp_index::section_table_cols): New member function.
	(Dwp_output_file::Dwp_index::shndx_pool_): Remove.
	(Dwp_output_file::Dwp_index::section_table_): New data member.
	(Dwp_output_file::Dwp_index::section_mask_): New data member.
	(Dwp_output_file::add_output_section): New member function.
	(Dwp_output_file::write_new_section): New member function.
	(Dwp_output_file::write_contributions): New member function.
	(Dwp_output_file::section_id_map_): New data member.
	(class Dwo_id_info_reader): Remove.
	(class Unit_reader): New class.
	(get_dwarf_section_name): New function.
	(Dwo_file::read_executable): Adjust initializations of class data.
	(Dwo_file::read): Add support for v2 package file format.
	(Dwo_file::read_unit_index): Likewise.
	(Dwo_file::sized_read_unit_index): Likewise.
	(Dwo_file::copy_section): Likewise.
	(Dwo_file::add_unit_set): Likewise.
	(Dwp_output_file::add_output_section): Likewise.
	(Dwp_output_file::add_contribution): Likewise.
	(Dwp_output_file::Dwp_index::find_or_add): Use row index to check
	for empty slot.
	(Dwp_output_file::Dwp_index::enter_set): Add support for v2 package
	file format.
	(Dwp_output_file::Dwp_index::grow): Use row index to check for empty
	slot.
	(Dwp_output_file::initialize): Remove unused function.
	(Dwp_output_file::finalize): Add support for v2 package file format.
	(Dwp_output_file::write_index): Likewise.
	* gdb-index.cc (Gdb_index_info_reader::visit_type_unit): Adjust
	function prototype.
@
text
@d377 1
d434 2
a435 5
	  shndx1 =
	      this->ranges_reloc_mapper_->get_reloc_target(offset, &start);
	  shndx2 =
	      this->ranges_reloc_mapper_->get_reloc_target(offset + addr_size,
							   &end);
d461 18
@


1.47
log
@gold/
	* dwarf_reader.cc (Dwarf_info_reader::check_buffer): Move
	function into class definition in header file.
	(Dwarf_info_reader::warn_corrupt_debug_section): New function.
	* dwarf_reader.h (Dwarf_info_reader::warn_corrupt_debug_section):
	New function.
	(Dwarf_info_reader::check_buffer): Move here from .cc file.
@
text
@d1288 2
a1289 1
				  type_offset, signature, &root_die);
d1432 1
a1432 1
Dwarf_info_reader::visit_type_unit(off_t, off_t, uint64_t, Dwarf_die*)
@


1.46
log
@gold/
	* dwarf_reader.cc (Sized_elf_reloc_mapper::symbol_section): Cast
	SYMNDX to off_t before comparing it to this->data_size().
	* output.cc (Output_symtab_xindex::endian_do_write): Likewise.
	* incremental.cc (Output_section_incremental_inputs::do_write):
	Cast GLOBAL_SYM_COUNT to off_t before comparing it to SYMTAB_SIZE.
@
text
@a1143 15
// Check that the pointer P is within the current compilation unit.

inline bool
Dwarf_info_reader::check_buffer(const unsigned char* p) const
{
  if (p > this->buffer_ + this->cu_offset_ + this->cu_length_)
    {
      gold_warning(_("%s: corrupt debug info in %s"),
		   this->object_->name().c_str(),
		   this->object_->section_name(this->shndx_).c_str());
      return false;
    }
  return true;
}

d1435 10
@


1.45
log
@gold/
	* dwarf_reader.cc (Dwarf_ranges_table::read_range_list): Call
	Dwarf_info_reader::read_from_pointer.
	(Dwarf_pubnames_table::read_header): Likewise.
	(Dwarf_pubnames_table::next_name): Likewise.
	(Dwarf_die::read_attributes): Likewise.
	(Dwarf_die::skip_attributes): Likewise.
	(Dwarf_info_reader::read_from_pointer): New function template.
	* dwarf_reader.h (Dwarf_ranges_table): Add dwinfo_.
	(Dwarf_pubnames_table): Likewise.
	(Dwarf_info_reader::read_from_pointer): New function template.
	* gdb-index.cc (Gdb_index_info_reader): Adjust call to
	Dwarf_pubnames_table ctor.
@
text
@d60 1
a60 1
  gold_assert((symndx + 1) * symsize <= this->symtab_size_);
d533 1
a533 1
  
@


1.44
log
@gold/
	* dwarf_reader.cc (Dwarf_info_reader::do_parse): Use stored
	abbrev_shndx.
	* dwarf_reader.h (Dwarf_info_reader::Dwarf_info_reader): Initialize
	abbrev_shndx_.
	(Dwarf_info_reader::set_abbrev_shndx): New method.
	(Dwarf_info_reader::abbrev_shndx_): New data member.
@
text
@d415 4
a418 2
	  start = read_from_pointer<32>(this->ranges_buffer_ + offset);
	  end = read_from_pointer<32>(this->ranges_buffer_ + offset + 4);
d422 4
a425 2
	  start = read_from_pointer<64>(this->ranges_buffer_ + offset);
	  end = read_from_pointer<64>(this->ranges_buffer_ + offset + 8);
d517 1
a517 1
  uint32_t unit_length = read_from_pointer<32>(pinfo);
d521 1
a521 1
      unit_length = read_from_pointer<64>(pinfo);
d529 1
a529 1
  unsigned int version = read_from_pointer<16>(pinfo);
d555 1
a555 1
    offset = read_from_pointer<32>(&pinfo);
d557 1
a557 1
    offset = read_from_pointer<64>(&pinfo);
d645 1
a645 1
		str_off = read_from_pointer<32>(&pattr);
d647 1
a647 1
		str_off = read_from_pointer<64>(&pattr);
d658 1
a658 1
		sec_off = read_from_pointer<32>(&pattr);
d660 1
a660 1
		sec_off = read_from_pointer<64>(&pattr);
d673 1
a673 1
		sec_off = read_from_pointer<32>(&pattr);
d675 1
a675 1
		sec_off = read_from_pointer<64>(&pattr);
d689 2
a690 1
	    attr_value.aux.blocklen = read_from_pointer<16>(&pattr);
d695 2
a696 1
	    attr_value.aux.blocklen = read_from_pointer<32>(&pattr);
d715 2
a716 1
	    attr_value.val.intval = read_from_pointer<16>(&pattr);
d719 2
a720 1
	    attr_value.val.refval = read_from_pointer<16>(&pattr);
d726 1
a726 1
	      sec_off = read_from_pointer<32>(&pattr);
d736 1
a736 1
	      sec_off = read_from_pointer<32>(&pattr);
d747 1
a747 1
	      sec_off = read_from_pointer<64>(&pattr);
d755 2
a756 1
	    attr_value.val.uintval = read_from_pointer<64>(&pattr);
d761 1
a761 1
	      sec_off = read_from_pointer<64>(&pattr);
d888 1
a888 1
	      block_size = read_from_pointer<16>(&pattr);
d895 1
a895 1
	      block_size = read_from_pointer<32>(&pattr);
d1364 27
@


1.43
log
@gold/
	* dwarf_reader.cc (make_elf_reloc_mapper): Check size and endianness
	from object, not parameters.
	(Dwarf_info_reader::parse): Likewise.
	* object.h (Relobj::elfsize, Relobj::is_big_endian): New methods.
	(Relobj::do_elfsize, Relobj::do_is_big_endian): New methods.
	(Sized_relobj::do_elfsize, Sized_relobj::do_is_big_endian): New
	methods.
@
text
@d1198 1
a1198 1
  unsigned int abbrev_shndx = 0;
@


1.42
log
@2012-09-06  Cary Coutant  <ccoutant@@google.com>

gold/
	* dwarf_reader.cc (Dwarf_die::read_attributes): Add
	DW_FORM_GNU_addr_index and DW_FORM_GNU_str_index.
	(Dwarf_die::skip_attributes): Likewise.
	* object.cc (Read_symbols_data::~Read_symbols_data): Update comment.
	* testsuite/gdb_index_test.cc (inline_func_1): New function.
	(main): Call it.
	* testsuite/gdb_index_test_comm.sh: Check index for inline function.
@
text
@a30 1
#include "parameters.h"
d92 1
a92 1
make_elf_reloc_mapper(Object* object, const unsigned char* symtab,
d95 1
a95 1
  switch (parameters->size_and_endianness())
d97 11
d109 4
a112 3
      case Parameters::TARGET_32_LITTLE:
	return new Sized_elf_reloc_mapper<32, false>(object, symtab,
						     symtab_size);
d114 11
a124 4
#ifdef HAVE_TARGET_32_BIG
      case Parameters::TARGET_32_BIG:
	return new Sized_elf_reloc_mapper<32, true>(object, symtab,
						    symtab_size);
d126 3
d130 4
a133 3
      case Parameters::TARGET_64_LITTLE:
	return new Sized_elf_reloc_mapper<64, false>(object, symtab,
						     symtab_size);
d135 1
a135 7
#ifdef HAVE_TARGET_64_BIG
      case Parameters::TARGET_64_BIG:
	return new Sized_elf_reloc_mapper<64, true>(object, symtab,
						    symtab_size);
#endif
      default:
	gold_unreachable();
d137 2
d1157 1
a1157 1
  switch (parameters->size_and_endianness())
d1159 4
a1162 4
#ifdef HAVE_TARGET_32_LITTLE
      case Parameters::TARGET_32_LITTLE:
        this->do_parse<false>();
        break;
d1164 7
a1170 9
#ifdef HAVE_TARGET_32_BIG
      case Parameters::TARGET_32_BIG:
        this->do_parse<true>();
        break;
#endif
#ifdef HAVE_TARGET_64_LITTLE
      case Parameters::TARGET_64_LITTLE:
        this->do_parse<false>();
        break;
a1171 7
#ifdef HAVE_TARGET_64_BIG
      case Parameters::TARGET_64_BIG:
        this->do_parse<true>();
        break;
#endif
      default:
	gold_unreachable();
@


1.41
log
@	* arm.cc (Arm_relocate_functions::abs16): Remove unused typedef.
	(Arm_exidx_cantunwind::do_fixed_endian_write): Likewise.
	(Target_arm::scan_reloc_for_stub): Likewise.
	* common.cc (Symbol_table::do_allocate_commons_list): Likewise.
	* dwarf_reader.cc (Dwarf_die::skip_attributes): Likewise.
	* ehframe.cc (Eh_frame::do_add_ehframe_input_section): Likewise.
	* incremental.cc (Sized_incr_dynobj::do_add_symbols): Likewise.
	* powerpc.cc (Target_powerpc::relocate_tls): Likewise.
@
text
@d748 2
d900 2
@


1.41.2.1
log
@gold/
	* dwarf_reader.cc (Sized_elf_reloc_mapper::symbol_section): Cast
	SYMNDX to off_t before comparing it to this->data_size().
	* output.cc (Output_symtab_xindex::endian_do_write): Likewise.
	* incremental.cc (Output_section_incremental_inputs::do_write):
	Cast GLOBAL_SYM_COUNT to off_t before comparing it to SYMTAB_SIZE.
@
text
@d61 1
a61 1
  gold_assert(static_cast<off_t>((symndx + 1) * symsize) <= this->symtab_size_);
d511 1
a511 1

@


1.40
log
@elfcpp/

	* dwarf.h (enum DW_TAG, enum DW_FORM, enum DW_AT, enum DW_ENCODING)
	(enum DW_OP, enum DW_CFA): Remove.
	Include dwarf2.def.

gold/

	* dwarf_reader.cc (Dwarf_die::read_attributes)
	(Dwarf_die::skip_attributes, Dwarf_die::int_attribute)
	(Dwarf_die::uint_attribute): Remove DW_FORM_null.
	* reduced_debug_output.cc
	(Output_reduced_debug_info_section::get_die_end): Remove
	DW_FORM_GNU_ref_index.  Add default case.
@
text
@a823 2
  typedef Dwarf_abbrev_table::Attribute Attribute;

@


1.39
log
@gold: Handle DW_AT_high_pc as offset from DW_AT_low_pc in gdb-index.cc.

        * dwarf_reader.cc (Dwarf_die::address_attribute): New function.
        * dwarf_reader.h (Dwarf_die::address_attribute): Likewise.
        * gdb-index.cc (Gdb_index_info_reader::record_cu_ranges): Handle
        DW_AT_high_pc as offset from DW_AT_low_pc.

        * testsuite/Makefile.am (gdb_index_test_3.sh): New test case.
        * testsuite/Makefile.in: Regenerate.
        * testsuite/gdb_index_test_3.c: New test source file.
        * testsuite/gdb_index_test_3.sh: New test source file.
@
text
@a615 3
	  case elfcpp::DW_FORM_null:
	    attr_value.val.intval = 0;
	    break;
a844 1
	  case elfcpp::DW_FORM_null:
a983 1
      case elfcpp::DW_FORM_null:
a1004 1
      case elfcpp::DW_FORM_null:
@


1.38
log
@2012-03-21  Cary Coutant  <ccoutant@@google.com>

	* Makefile.am: Add gdb-index.cc, gdb-index.h.
	* Makefile.in: Regenerate.
	* dwarf_reader.cc (Sized_elf_reloc_mapper::do_initialize): New function.
	(Sized_elf_reloc_mapper::symbol_section): New function.
	(Sized_elf_reloc_mapper::do_get_reloc_target): New function.
	(make_elf_reloc_mapper): New function.
	(Dwarf_abbrev_table::clear_abbrev_codes): New function.
	(Dwarf_abbrev_table::do_read_abbrevs): New function.
	(Dwarf_abbrev_table::do_get_abbrev): New function.
	(Dwarf_ranges_table::read_ranges_table): New function.
	(Dwarf_ranges_table::read_range_list): New function.
	(Dwarf_pubnames_table::read_section): New function.
	(Dwarf_pubnames_table::read_header): New function.
	(Dwarf_pubnames_table::next_name): New function.
	(Dwarf_die::Dwarf_die): New function.
	(Dwarf_die::read_attributes): New function.
	(Dwarf_die::skip_attributes): New function.
	(Dwarf_die::set_name): New function.
	(Dwarf_die::set_linkage_name): New function.
	(Dwarf_die::attribute): New function.
	(Dwarf_die::string_attribute): New function.
	(Dwarf_die::int_attribute): New function.
	(Dwarf_die::uint_attribute): New function.
	(Dwarf_die::ref_attribute): New function.
	(Dwarf_die::child_offset): New function.
	(Dwarf_die::sibling_offset): New function.
	(Dwarf_info_reader::check_buffer): New function.
	(Dwarf_info_reader::parse): New function.
	(Dwarf_info_reader::do_parse): New function.
	(Dwarf_info_reader::do_read_string_table): New function.
	(Dwarf_info_reader::lookup_reloc): New function.
	(Dwarf_info_reader::get_string): New function.
	(Dwarf_info_reader::visit_compilation_unit): New function.
	(Dwarf_info_reader::visit_type_unit): New function.
	(Sized_dwarf_line_info::Sized_dwarf_line_info): Use
	Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::symbol_section): Remove function.
	(Sized_dwarf_line_info::read_relocs): Use Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::read_line_mappings): Remove object
	parameter, adjust callers.
	(Sized_dwarf_line_info::format_file_lineno): Fix type of cast.
	* dwarf_reader.h: Include <sys/types.h>.
	(class Track_relocs): Remove forward declaration.
	(class Elf_reloc_mapper): New class.
	(class Sized_elf_reloc_mapper): New class.
	(class Dwarf_abbrev_table): New class.
	(class Dwarf_range_list): New class.
	(class Dwarf_ranges_table): New class.
	(class Dwarf_pubnames_table): New class.
	(class Dwarf_die): New class.
	(class Dwarf_info_reader): New class.
	(Sized_dwarf_line_info::read_line_mappings): Remove object parameter.
	(Sized_dwarf_line_info::symbol_section): Remove member function.
	* dynobj.h (Sized_dynobj::do_section_contents): Refactor code from
	base class.
	* gdb-index.cc: New source file.
	* gdb-index.h: New source file.
	* incremental.cc (Sized_relobj_incr::do_layout): Track .debug_info
	and .debug_types sections, call Layout::add_to_gdb_index.
	(Sized_relobj_incr::do_section_name): Implement.
	(Sized_relobj_incr::do_section_contents): Adjust parameter list and
	return type; Implement.
	(Sized_incr_dynobj::do_section_contents): Adjust parameter list and
	return type.
	* incremental.h (Sized_relobj_incr::do_section_contents): Adjust
	parameter list and return type.
	(Sized_incr_dynobj::do_section_contents): Likewise.
	* layout.cc: Include gdb-index.h.
	(Layout::Layout): Initialize gdb_index_data_.
	(Layout::init_fixed_output_section): Check for .gdb_index section.
	(Layout::add_to_gdb_index): New function. Instantiate.
	* layout.h: Add forward declaration for class Gdb_index.
	(Layout::add_to_gdb_index): New member function.
	(Layout::gdb_index_data_): New data member.
	* main.cc: Include gdb-index.h.
	(main): Print statistics for gdb index.
	* object.cc (Object::section_contents): Move code into
	do_section_contents.
	(need_decompressed_section): Check for sections needed when building
	gdb index.
	(build_compressed_section_map): Likewise.
	(Sized_relobj_file::do_read_symbols): Need local symbols when building
	gdb index.
	(Sized_relobj_file::do_layout): Track .debug_info and .debug_types
	sections; call Layout::add_to_gdb_index.
	(Sized_relobj_file::do_decompressed_section_contents): Call
	do_section_contents directly.
	* object.h (Object::do_section_contents): Adjust parameter list and
	return type.
	(Object::do_decompressed_section_contents): Call do_section_contents
	directly.
	(Sized_relobj_file::do_section_contents): Adjust parameter list and
	return type.
	* options.h (class General_options): Add --gdb-index option.
	* plugin.cc (Sized_pluginobj::do_section_contents): Adjust parameter
	list and return type.
	* plugin.h (Sized_pluginobj::do_section_contents): Likewise.
	* reloc.h (Track_relocs::checkpoint): New function.
	(Track_relocs::reset): New function.

	* testsuite/Makefile.am (gdb_index_test_1.sh, gdb_index_test_2.sh):
	New test cases.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/gdb_index_test.cc: New test source file.
	* testsuite/gdb_index_test_1.sh: New test source file.
	* testsuite/gdb_index_test_2.sh: New test source file.
@
text
@d1054 11
@


1.37
log
@	* dwarf_reader.cc (Sized_dwarf_line_info::process_one_opcode): Fix
	handling of DW_LNE_define_file.
@
text
@d3 1
a3 1
// Copyright 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d39 1361
d1430 2
a1431 1
    symtab_buffer_(NULL), directories_(), files_(), current_header_index_(-1)
d1457 2
a1458 4
  bool got_relocs = false;
  for (unsigned int reloc_shndx = 0;
       reloc_shndx < object->shnum();
       ++reloc_shndx)
d1460 1
a1460 1
      unsigned int reloc_sh_type = object->section_type(reloc_shndx);
d1463 1
a1463 1
	  && object->section_info(reloc_shndx) == debug_shndx)
d1465 1
a1465 2
	  got_relocs = this->track_relocs_.initialize(object, reloc_shndx,
                                                      reloc_sh_type);
d1472 1
a1472 1
  if (got_relocs)
d1478 2
a1479 2
            this->symtab_buffer_ = object->section_contents(
                symtab_shndx, &this->symtab_buffer_size_, false);
d1486 7
d1496 1
a1496 1
  this->read_line_mappings(object, read_shndx);
a1872 17
// Looks in the symtab to see what section a symbol is in.

template<int size, bool big_endian>
unsigned int
Sized_dwarf_line_info<size, big_endian>::symbol_section(
    Object* object,
    unsigned int sym,
    typename elfcpp::Elf_types<size>::Elf_Addr* value,
    bool* is_ordinary)
{
  const int symsize = elfcpp::Elf_sizes<size>::sym_size;
  gold_assert(sym * symsize < this->symtab_buffer_size_);
  elfcpp::Sym<size, big_endian> elfsym(this->symtab_buffer_ + sym * symsize);
  *value = elfsym.get_st_value();
  return object->adjust_sym_shndx(sym, elfsym.get_st_shndx(), is_ordinary);
}

d1877 1
a1877 1
Sized_dwarf_line_info<size, big_endian>::read_relocs(Object* object)
d1882 1
a1882 1
  typename elfcpp::Elf_types<size>::Elf_Addr value;
d1884 1
a1884 1
  while ((reloc_offset = this->track_relocs_.next_offset()) != -1)
d1886 2
a1887 5
      const unsigned int sym = this->track_relocs_.next_symndx();

      bool is_ordinary;
      const unsigned int shndx = this->symbol_section(object, sym, &value,
						      &is_ordinary);
d1891 2
a1892 5
      if (is_ordinary && shndx != elfcpp::SHN_UNDEF)
	{
	  value += this->track_relocs_.next_addend();
	  this->reloc_map_[reloc_offset] = std::make_pair(shndx, value);
	}
d1894 1
a1894 1
      this->track_relocs_.advance(reloc_offset + 1);
d1902 1
a1902 2
Sized_dwarf_line_info<size, big_endian>::read_line_mappings(Object* object,
							    unsigned int shndx)
d1906 1
a1906 1
  this->read_relocs(object);
d2110 1
a2110 1
	      < static_cast<int>(this->files_[loc.header_num].size()));
@


1.36
log
@	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Call Object::decompressed_section_contents.
	* dwarf_reader.h (Sized_dwarf_line_info::~Sized_dwarf_line_info):
	New dtor.
	(Sized_dwarf_line_info::buffer_start_): New data member.
	* merge.cc (Output_merge_data::do_add_input_section): Call
	Object::decompressed_section_contents.
	(Output_merge_string::do_add_input_section): Likewise.
	* object.cc (need_decompressed_section): New function.
	(build_compressed_section_map): Decompress sections needed later.
	(Sized_relobj_file::do_decompressed_section_contents): New function.
	(Sized_relobj_file::do_discard_decompressed_sections): New function.
	* object.h (Object::decompressed_section_contents): New function.
	(Object::discard_decompressed_sections): New function.
	(Object::do_decompressed_section_contents): New function.
	(Object::do_discard_decompressed_sections): New function.
	(Compressed_section_info): New type.
	(Compressed_section_map): Include decompressed section contents.
	(Sized_relobj_file::do_decompressed_section_contents): New function.
	(Sized_relobj_file::do_discard_decompressed_sections): New function.
@
text
@a415 1
              oplen += templen;
d421 5
a425 5
              read_unsigned_LEB_128(start, &templen);   // mod_time
              oplen += templen;

              read_unsigned_LEB_128(start, &templen);   // filelength
              oplen += templen;
@


1.35
log
@Update copyright year.
@
text
@d65 5
a69 4
Sized_dwarf_line_info<size, big_endian>::Sized_dwarf_line_info(Object* object,
                                                               unsigned int read_shndx)
  : data_valid_(false), buffer_(NULL), symtab_buffer_(NULL),
    directories_(), files_(), current_header_index_(-1)
d72 1
d80 6
a85 2
	  this->buffer_ = object->section_contents(debug_shndx, &buffer_size,
						   false);
a92 15
  section_size_type uncompressed_size = 0;
  unsigned char* uncompressed_data = NULL;
  if (object->section_is_compressed(debug_shndx, &uncompressed_size))
    {
      uncompressed_data = new unsigned char[uncompressed_size];
      if (!decompress_input_section(this->buffer_,
				    this->buffer_end_ - this->buffer_,
				    uncompressed_data,
				    uncompressed_size))
	object->error(_("could not decompress section %s"),
		      object->section_name(debug_shndx).c_str());
      this->buffer_ = uncompressed_data;
      this->buffer_end_ = this->buffer_ + uncompressed_size;
    }

@


1.34
log
@2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.
@
text
@d3 1
a3 1
// Copyright 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.33
log
@2011-04-05  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gold/12640
	* dwarf_reader.cc (Sized_dwarf_line_info): Fix vector bounds
	violation.
@
text
@d494 4
a497 2
                  = { lsm.address, this->current_header_index_,
                      lsm.file_num, true, lsm.line_num };
@


1.33.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d3 1
a3 1
// Copyright 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d494 2
a495 4
                  = { static_cast<off_t>(lsm.address),
		      this->current_header_index_,
		      static_cast<unsigned int>(lsm.file_num),
		      true, lsm.line_num };
@


1.32
log
@	* dwarf_reader.cc (Sized_dwarf_line_info): Include all lines,
	but mark earlier ones as non-canonical
	(offset_to_iterator): Update search target and example
	(do_addr2line): Return extra lines in a vector*
	(format_file_lineno): Extract from do_addr2line
	(one_addr2line): Add vector* out-param
	* dwarf_reader.h (Offset_to_lineno_entry): New field recording
	when a lineno entry appeared last for its instruction
	(Dwarf_line_info): Add vector* out-param
	* object.cc (Relocate_info): Pass NULL for the vector* out-param
	* symtab.cc (Odr_violation_compare): Include the lineno in the
	comparison again.
	(linenos_from_loc): New. Combine the canonical line for an
	address with its other lines.
	(True_if_intersect): New. Helper functor to make
	std::set_intersection a query.
	(detect_odr_violations): Compare sets of lines instead of just
	one line for each function. This became less deterministic, but
	has fewer false positives.
	* symtab.h: Declarations.
	* testsuite/Makefile.am (odr_violation2.o): Compile with -O2 to
	mix an optimized and non-optimized object in the same binary
	(odr_violation2.so): Same.
	* testsuite/Makefile.in: Regenerate from Makefile.am.
	* testsuite/debug_msg.cc (main): Make OdrDerived classes.
	* testsuite/debug_msg.sh: Update line numbers and add
	assertions.
	* testsuite/odr_violation1.cc: Use OdrDerived, in a
	non-optimized context.
	* testsuite/odr_violation2.cc: Make sure Ordering::operator()
	isn't inlined, and use OdrDerived in an optimized context.
	* testsuite/odr_header1.h: Defines OdrDerived, where
	optimization will change the
	first-instruction-in-the-destructor's file and line number.
	* testsuite/odr_header2.h: Defines OdrBase.
@
text
@d191 1
a191 1
  header_.std_opcode_lengths.reserve(header_.opcode_base + 1);
@


1.31
log
@	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Only keep
	second of two consecutive entries with same offset.
@
text
@d495 1
a495 1
                      lsm.file_num, lsm.line_num };
d499 2
a500 2
	      // offset and a real line number, then always use the
	      // second one.
d505 2
a506 3
		map.back() = entry;
	      else
		map.push_back(entry);
d614 1
a614 1
  const Offset_to_lineno_entry lookup_key = { offset, 0, 0, 0 };
d623 21
a643 19
  // {{offset = 3211, header_num = 0, file_num = 1, line_num = 16},  // 0
  //  {offset = 3224, header_num = 0, file_num = 1, line_num = 20},  // 1
  //  {offset = 3226, header_num = 0, file_num = 1, line_num = 22},  // 2
  //  {offset = 3231, header_num = 0, file_num = 1, line_num = 25},  // 3
  //  {offset = 3232, header_num = 0, file_num = 1, line_num = -1},  // 4
  //  {offset = 3232, header_num = 0, file_num = 1, line_num = 65},  // 5
  //  {offset = 3235, header_num = 0, file_num = 1, line_num = 66},  // 6
  //  {offset = 3236, header_num = 0, file_num = 1, line_num = -1},  // 7
  //  {offset = 5764, header_num = 0, file_num = 1, line_num = 47},  // 8
  //  {offset = 5765, header_num = 0, file_num = 1, line_num = 48},  // 9
  //  {offset = 5767, header_num = 0, file_num = 1, line_num = 49},  // 10
  //  {offset = 5768, header_num = 0, file_num = 1, line_num = 50},  // 11
  //  {offset = 5773, header_num = 0, file_num = 1, line_num = -1},  // 12
  //  {offset = 5787, header_num = 1, file_num = 1, line_num = 19},  // 13
  //  {offset = 5790, header_num = 1, file_num = 1, line_num = 20},  // 14
  //  {offset = 5793, header_num = 1, file_num = 1, line_num = 67},  // 15
  //  {offset = 5793, header_num = 1, file_num = 1, line_num = -1},  // 16
  //  {offset = 5795, header_num = 1, file_num = 1, line_num = 68},  // 17
  //  {offset = 5798, header_num = 1, file_num = 1, line_num = -1},  // 18
d655 1
a655 1
  //         offset[19] (end()).  We return end() (invalid).
d674 11
a684 10
  //         offsets[17].  Since it's not an exact match, we back
  //         up to offsets[15].  Note we back up to the *first*
  //         entry with offset 5793, not just offsets[17-1].
  //         We note offsets[15] is a valid entry, so we return it.
  //         If offsets[15] had had line_num == -1, we would have
  //         checked offsets[16].  The reason for this is that
  //         15 and 16 can be in an arbitrary order, since we sort
  //         only by offset.  (Note it doesn't help to use line_number
  //         as a secondary sort key, since sometimes we want the -1
  //         to be first and sometimes we want it to be last.)
d715 3
a717 1
  // match.  If not, we're not in a function.
d724 3
a726 1
// Return a string for a file name and line number.
d730 4
a733 2
Sized_dwarf_line_info<size, big_endian>::do_addr2line(unsigned int shndx,
                                                      off_t offset)
d754 18
a771 1
  // Convert the file_num + line_num into a string.
d774 3
a776 3
  gold_assert(it->header_num < static_cast<int>(this->files_.size()));
  gold_assert(it->file_num
	      < static_cast<int>(this->files_[it->header_num].size()));
d778 1
a778 1
      = this->files_[it->header_num][it->file_num];
d781 1
a781 1
  gold_assert(it->header_num < static_cast<int>(this->directories_.size()));
d783 1
a783 1
              < static_cast<int>(this->directories_[it->header_num].size()));
d785 1
a785 1
      = this->directories_[it->header_num][filename_pair.first];
d797 1
a797 1
  snprintf(buffer, sizeof(buffer), "%d", it->line_num);
d831 2
a832 1
                               size_t cache_size)
d883 1
a883 1
  std::string retval = lineinfo->addr2line(shndx, offset);
@


1.30
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d496 12
a507 1
              line_number_map_[lsm.shndx].push_back(entry);
@


1.29
log
@	* dwarf_reader.h (class Sized_dwarf_line_info): Add
	track_relocs_type_ field.
	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Set track_relocs_type_.
	(Sized_dwarf_line_info::process_one_opcode): Ignore the section
	contents when using RELA relocs.
	(Sized_dwarf_line_info::read_relocs): Add the reloc addend to
	reloc_map_.
	* reloc.cc (Track_relocs::next_addend): New function.
	* reloc.h (class Track_relocs): Declare next_addend.
@
text
@a273 4
// Templating on size and big_endian would yield more efficient (and
// simpler) code, but would bloat the binary.  Speed isn't important
// here.

@


1.28
log
@	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Check for ".zdebug_line".
@
text
@d3 1
a3 1
// Copyright 2007, 2008, 2009 Free Software Foundation, Inc.
d116 1
d396 2
a397 1
              lsm->address = elfcpp::Swap_unaligned<size, big_endian>::readval(start);
d399 1
a399 1
                  = reloc_map_.find(start - this->buffer_);
d402 9
a410 2
                  // value + addend.
                  lsm->address += it->second.second;
d548 4
a551 1
	this->reloc_map_[reloc_offset] = std::make_pair(shndx, value);
@


1.27
log
@	* compressed_output.cc (zlib_decompress): New function.
	(get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* compressed_output.h (get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info)
	Handle compressed debug sections.
	* layout.cc (is_compressed_debug_section): New function.
	(Layout::output_section_name): Map compressed section names to
	canonical names.
	* layout.h (is_compressed_debug_section): New function.
	(is_debug_info_section): Recognize compressed debug sections.
	* merge.cc: Include compressed_output.h.
	(Output_merge_data::do_add_input_section): Handle compressed
	debug sections.
	(Output_merge_string::do_add_input_section): Handle compressed
	debug sections.
	* object.cc: Include compressed_output.h.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(build_compressed_section_map): New function.
	(Sized_relobj::do_read_symbols): Handle compressed debug sections.
	* object.h (Object::section_is_compressed): New method.
	(Object::do_section_is_compressed): New method.
	(Sized_relobj::Compressed_section_map): New type.
	(Sized_relobj::do_section_is_compressed): New method.
	(Sized_relobj::compressed_sections_): New data member.
	* output.cc (Output_section::add_input_section): Handle compressed
	debug sections.
	* reloc.cc: Include compressed_output.h.
	(Sized_relobj::write_sections): Handle compressed debug sections.
@
text
@d71 13
a83 10
  for (debug_shndx = 0; debug_shndx < object->shnum(); ++debug_shndx)
    // FIXME: do this more efficiently: section_name() isn't super-fast
    if (object->section_name(debug_shndx) == ".debug_line")
      {
        section_size_type buffer_size;
        this->buffer_ = object->section_contents(debug_shndx, &buffer_size,
						 false);
        this->buffer_end_ = this->buffer_ + buffer_size;
        break;
      }
@


1.26
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d35 1
d84 15
@


1.25
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d297 1
a297 1
	  = read_unsigned_LEB_128(start, &templen);
d356 1
a356 1
	  = read_unsigned_LEB_128(start, &templen);
d378 1
a378 1
		= reloc_map_.find(start - this->buffer_);
d423 1
a423 1
        // Ignore unknown opcode  silently.
d426 1
d433 1
a433 1
    }
@


1.24
log
@2009-12-08  Doug Kwan  <dougkwan@@google.com>

	* Makefile.am (CCFILES): Add attributes.cc and int_encoding.cc.
	(HFILES): Add attributes.h and int_encoding.h.
	* Makefile.in: Regenerate.
	* dwarf_reader.cc (read_unsigned_LEB_128, read_signed_LEB_128): Move
	function definitions to int_encoding.cc
	* dwarf_reader.h (read_unsigned_LEB_128, read_signed_LEB_128): Move
	prototypes to int_encoding.h
	* reduced_debug_output.cc (int_encoding.h): New include.
	(write_unsigned_LEB_128, get_length_as_unsigned_LEB_128): Move
	function definitions to int_encoding.cc
	(insert_into_vector, read_from_pointer): Move template definitions to
	int_encoding.h
	* attributes.cc: New file.
	* attributes.h: New file.
	* int_encoding.cc: New file.
	* int_encoding.h: New file.
@
text
@d297 1
a297 1
            = read_unsigned_LEB_128(start, &templen);
d356 1
a356 1
            = read_unsigned_LEB_128(start, &templen);
d378 1
a378 1
                  = reloc_map_.find(start - this->buffer_);
d423 1
a423 1
        // Ignore unknown opcode  silently
a425 1
            size_t templen;
d432 1
a432 1
  }
@


1.23
log
@	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Change read_shndx type to unsigned int.
	(Sized_dwarf_line_info::read_lines): Change shndx type to unsigned
	int.
	(Sized_dwarf_line_info::read_line_mappings): Likewise.
	* dwarf_reader.h (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Change read_shndx type to unsigned int.
	(Sized_dwarf_line_info::read_lines): Change shndx type to unsigned
	int.
	(Sized_dwarf_line_info::read_line_mappings): Likewise.
	* layout.cc (Layout::create_symtab_sections): Cast the result of
	local_symcount * symsize to off_t in the gold_assert.
@
text
@d34 1
a37 68
// Read an unsigned LEB128 number.  Each byte contains 7 bits of
// information, plus one bit saying whether the number continues or
// not.

uint64_t
read_unsigned_LEB_128(const unsigned char* buffer, size_t* len)
{
  uint64_t result = 0;
  size_t num_read = 0;
  unsigned int shift = 0;
  unsigned char byte;

  do
    {
      if (num_read >= 64 / 7) 
        {
          gold_warning(_("Unusually large LEB128 decoded, "
			 "debug information may be corrupted"));
          break;
        }
      byte = *buffer++;
      num_read++;
      result |= (static_cast<uint64_t>(byte & 0x7f)) << shift;
      shift += 7;
    }
  while (byte & 0x80);

  *len = num_read;

  return result;
}

// Read a signed LEB128 number.  These are like regular LEB128
// numbers, except the last byte may have a sign bit set.

int64_t
read_signed_LEB_128(const unsigned char* buffer, size_t* len)
{
  int64_t result = 0;
  int shift = 0;
  size_t num_read = 0;
  unsigned char byte;

  do
    {
      if (num_read >= 64 / 7) 
        {
          gold_warning(_("Unusually large LEB128 decoded, "
			 "debug information may be corrupted"));
          break;
        }
      byte = *buffer++;
      num_read++;
      result |= (static_cast<uint64_t>(byte & 0x7f) << shift);
      shift += 7;
    }
  while (byte & 0x80);

  if ((shift < 8 * static_cast<int>(sizeof(result))) && (byte & 0x40))
    result |= -((static_cast<int64_t>(1)) << shift);
  *len = num_read;
  return result;
}

// This is the format of a DWARF2/3 line state machine that we process
// opcodes using.  There is no need for anything outside the lineinfo
// processor to know how this works.

@


1.22
log
@elfcpp/:
	* dwarf.h (enum DW_FORM): Define.
gold/:
	* reduced_debug_output.cc: New file.
	* reduced_debug_output.h: New file.
	* options.h (class General_optoins): Add --strip-debug-non-line.
	* options.cc (General_options::finalize): Add strip_debug_non_line
	to the strip heirarchy.
	* layout.h (class Layout): Add debug_abbrev_ and debug_info_
	fields.
	* layout.cc: Include "reduced_debug_output.h".
	(Layout::Layout): Initialize new fields.
	(line_only_debug_sections): New static array.
	(is_lines_only_debug_sections): New static inline function.
	(Layout::include_section): Handle --strip-debug-non-line.
	(Layout::make_output_section): If --strip-debug-non-line, build
	new output sections for .debug_abbrev and .debug_info.
	* dwarf_reader.cc (read_unsigned_LEB_128): Move to namespace
	gold.  Warn about possible overflow.
	(read_signed_LEB_128): Likewise.
	* dwarf_reader.h: (read_unsigned_LEB_128): Declare.
	(read_signed_LEB_128): Declare.
	* Makefile.am (CCFILES): Add reduced_debug_output.cc.
	(HFILES): Add reduced_debug_output.h.
	* Makefile.in: Rebuild.
@
text
@d3 1
a3 1
// Copyright 2007, 2008 Free Software Foundation, Inc.
d132 1
a132 1
                                                               off_t read_shndx)
d511 1
a511 1
                                                    off_t shndx)
d598 1
a598 1
							    off_t shndx)
@


1.22.8.1
log
@Merge elfcpp and gold from trunk.
@
text
@d3 1
a3 1
// Copyright 2007, 2008, 2009 Free Software Foundation, Inc.
d132 1
a132 1
                                                               unsigned int read_shndx)
d511 1
a511 1
                                                    unsigned int shndx)
d598 1
a598 1
							    unsigned int shndx)
@


1.21
log
@	* dwarf_reader.cc (next_generation_count): New static var.
	(Addr2line_cache_entry): New struct.
	(addr2line_cache): New static var.
	(Dwarf_line_info::one_addr2line): Added caching.
	(Dwarf_line_info::clear_addr2line_cache): New function.
	* dwarf_reader.h (Dwarf_line_info::one_addr2line): Add
	cache-size parameter.
	(Dwarf_line_info::one_addr2line_cache): New function.
	* symtab.cc (Symbol_table::detect_odr_violations): Pass
	new cache-size argument to one_addr2line(), and clear cache.
@
text
@d35 1
a35 1
namespace {
d51 6
d82 6
a100 5
} // End anonymous namespace.


namespace gold {

@


1.20
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d26 1
d803 22
d827 2
a828 1
                               unsigned int shndx, off_t offset)
d830 5
a834 1
  switch (parameters->size_and_endianness())
d836 20
d857 2
a858 3
    case Parameters::TARGET_32_LITTLE:
      return Sized_dwarf_line_info<32, false>(object, shndx).addr2line(shndx,
                                                                       offset);
d861 2
a862 3
    case Parameters::TARGET_32_BIG:
      return Sized_dwarf_line_info<32, true>(object, shndx).addr2line(shndx,
                                                                      offset);
d865 2
a866 3
    case Parameters::TARGET_64_LITTLE:
      return Sized_dwarf_line_info<64, false>(object, shndx).addr2line(shndx,
                                                                       offset);
d869 2
a870 3
    case Parameters::TARGET_64_BIG:
      return Sized_dwarf_line_info<64, true>(object, shndx).addr2line(shndx,
                                                                      offset);
d872 32
a903 2
    default:
      gold_unreachable();
d905 12
@


1.19
log
@	*  dwarf_reader.cc (Sized_dwarf_line_info::read_header_prolog,
	Sized_dwarf_line_info::process_one_opcode): Use Swap_unaligned.
@
text
@d178 1
a178 1
  this->read_line_mappings(read_shndx);
d545 1
d547 2
a548 1
    typename elfcpp::Elf_types<size>::Elf_Addr* value)
d554 1
a554 1
  return elfsym.get_st_shndx();
d561 1
a561 1
Sized_dwarf_line_info<size, big_endian>::read_relocs()
d571 10
a580 2
      const unsigned int shndx = this->symbol_section(sym, &value);
      this->reloc_map_[reloc_offset] = std::make_pair(shndx, value);
d589 2
a590 1
Sized_dwarf_line_info<size, big_endian>::read_line_mappings(off_t shndx)
d594 1
a594 1
  read_relocs();
@


1.18
log
@	PR gold/5986
	Fix problems building gold with gcc 4.3.0.
	* gold.h (TEMPLATE_ATTRIBUTE_PRINTF_4): Define.
	(gold_error_at_location, gold_warning_at_location): Use it.
	* configure.ac: Check whether we can compile and use a template
	function with a printf attribute.
	* x86_64.cc (Target_x86_64::do_code_fill): Swap out a 32-bit value
	when jumping over bytes.
	* object.cc: Instantiate Object::read_section_data.
	* debug.h: Include <cstring>
	* dwarf_reader.cc: Include <algorithm>
	* main.cc: Include <cstring>.
	* options.cc: Include <cstring>.
	* output.cc: Include <cstring>.
	* script.cc: Include <cstring>.
	* script.h: Include <string>.
	* symtab.cc: Include <cstring> and <algorithm>.
	* target-select.cc: Include <cstring>.
	* version.cc: Include <string>.
	* testsuite/testmain.cc: Include <cstdlib>.
	* configure, config.in: Rebuild.
@
text
@d188 1
a188 1
  uint32_t initial_length = elfcpp::Swap<32, big_endian>::readval(lineptr);
d196 1
a196 1
      initial_length = elfcpp::Swap<64, big_endian>::readval(lineptr);
d206 1
a206 1
  header_.version = elfcpp::Swap<16, big_endian>::readval(lineptr);
d210 1
a210 1
    header_.prologue_length = elfcpp::Swap<32, big_endian>::readval(lineptr);
d212 1
a212 1
    header_.prologue_length = elfcpp::Swap<64, big_endian>::readval(lineptr);
d397 1
a397 1
        advance_address = elfcpp::Swap<16, big_endian>::readval(start);
d435 1
a435 1
              lsm->address = elfcpp::Swap<size, big_endian>::readval(start);
@


1.17
log
@Update copyright years.  Update language files.
@
text
@d25 2
@


1.16
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d3 1
a3 1
// Copyright 2007 Free Software Foundation, Inc.
@


1.15
log
@From Craig Silverstein: Handle quoted strings differently in version
scripts, and handle extern "C++" in the middle of a block.
@
text
@d793 2
a794 1
  if (parameters->get_size() == 32 && !parameters->is_big_endian())
d796 3
a798 4
    return Sized_dwarf_line_info<32, false>(object, shndx).addr2line(shndx,
                                                                     offset);
#else
    gold_unreachable();
a799 1
  else if (parameters->get_size() == 32 && parameters->is_big_endian())
d801 3
a803 4
    return Sized_dwarf_line_info<32, true>(object, shndx).addr2line(shndx,
                                                                    offset);
#else
    gold_unreachable();
a804 1
  else if (parameters->get_size() == 64 && !parameters->is_big_endian())
d806 3
a808 4
    return Sized_dwarf_line_info<64, false>(object, shndx).addr2line(shndx,
                                                                     offset);
#else
    gold_unreachable();
d810 4
a813 6
  else if (parameters->get_size() == 64 && parameters->is_big_endian())
#ifdef HAVE_TARGET_64_BIT
    return Sized_dwarf_line_info<64, true>(object, shndx).addr2line(shndx,
                                                                    offset);
#else
    gold_unreachable();
d815 3
a817 2
  else
    gold_unreachable();
@


1.14
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d128 1
@


1.13
log
@From Craig Silverstein: Speed up ODR violation reporting.
@
text
@d130 3
a132 3
        off_t buffer_size;
        this->buffer_ = object->section_contents(
            debug_shndx, &buffer_size, false);
@


1.12
log
@From Craig Silverstein: Fix up comments.
@
text
@d121 2
a122 1
Sized_dwarf_line_info<size, big_endian>::Sized_dwarf_line_info(Object* object)
d175 1
a175 1
  this->read_line_mappings();
d499 2
a500 1
Sized_dwarf_line_info<size, big_endian>::read_lines(unsigned const char* lineptr)
d522 2
a523 1
          if (add_line)
d576 1
a576 1
Sized_dwarf_line_info<size, big_endian>::read_line_mappings()
d586 1
a586 1
      lineptr = this->read_lines(lineptr);
d794 2
a795 1
    return Sized_dwarf_line_info<32, false>(object).addr2line(shndx, offset);
d801 2
a802 1
    return Sized_dwarf_line_info<32, true>(object).addr2line(shndx, offset);
d808 2
a809 1
    return Sized_dwarf_line_info<64, false>(object).addr2line(shndx, offset);
d815 2
a816 1
    return Sized_dwarf_line_info<64, true>(object).addr2line(shndx, offset);
@


1.11
log
@From Craig Silverstein: Better handling of ODR violations which are
not in a function.
@
text
@d646 1
a646 1
  //  {offset = 5798, header_num = 1, file_num = 1, line_num = -1},  // 16
d652 1
a652 1
  // (as is true for the rest, most notably from 3236->5764).
d656 1
a656 1
  //         at the beginning of offsets, we return NULL.
d658 1
a658 1
  //         offset[17] (end()).  We return NULL.
d675 1
a675 1
  //         functions, so we return NULL (not a valid offset).
@


1.10
log
@DW_LNE_end_sequence indicates that the address points to the byte
*after* the current target sequence.
@
text
@d424 1
a424 1
            lsm->address -= 1;
d609 114
a733 1
  const Offset_to_lineno_entry lookup_key = { offset, 0, 0, 0 };
d746 3
a748 11
      = std::lower_bound(offsets->begin(), offsets->end(), lookup_key);

  // If we found an exact match, great, otherwise find the last entry
  // before the passed-in offset.
  if (it == offsets->end() || it->offset > offset)
    {
      if (it == offsets->begin())
        return "";
      --it;
      gold_assert(it->offset < offset);
    }
@


1.9
log
@From Craig Silverstein: Clean up DWARF line reader code.
@
text
@d421 4
@


1.8
log
@From Craig Silverstein: Rework debug info code a bit, add option for
ODR violations, add test case.
@
text
@d633 1
a633 1
  if (it->offset > offset)
a674 4

// Note: this routine instantiates the appropriate
// Sized_dwarf_line_info templates for this config, so we don't have
// to have a separte instantiation section for them.
@


1.7
log
@From Craig Silverstein: Support debug info for shared libraries.
@
text
@d28 1
d121 1
a121 1
Dwarf_line_info<size, big_endian>::Dwarf_line_info(Object* object)
d181 1
a181 1
Dwarf_line_info<size, big_endian>::read_header_prolog(
d242 1
a242 1
Dwarf_line_info<size, big_endian>::read_header_tables(
d315 1
a315 1
Dwarf_line_info<size, big_endian>::process_one_opcode(
d494 1
a494 1
Dwarf_line_info<size, big_endian>::read_lines(unsigned const char* lineptr)
d534 1
a534 1
Dwarf_line_info<size, big_endian>::symbol_section(
d549 1
a549 1
Dwarf_line_info<size, big_endian>::read_relocs()
d569 1
a569 1
Dwarf_line_info<size, big_endian>::read_line_mappings()
d599 1
a599 1
Dwarf_line_info<size, big_endian>::input_is_relobj()
d610 2
a611 1
Dwarf_line_info<size, big_endian>::addr2line(unsigned int shndx, off_t offset)
d674 38
d714 1
a714 1
class Dwarf_line_info<32, false>;
d719 1
a719 1
class Dwarf_line_info<32, true>;
d724 1
a724 1
class Dwarf_line_info<64, false>;
d729 1
a729 1
class Dwarf_line_info<64, true>;
@


1.6
log
@From Craig Silverstein: Dwarf_line_info can work with Object rather
than Sized_relobj.
@
text
@d122 1
a122 1
    directories_(1), files_(1)
d138 1
a153 2
  if (!got_relocs)
    return;
d156 13
a168 12
  unsigned int symtab_shndx;
  for (symtab_shndx = 0; symtab_shndx < object->shnum(); ++symtab_shndx)
    if (object->section_type(symtab_shndx) == elfcpp::SHT_SYMTAB)
      {
        off_t symtab_size;
        this->symtab_buffer_ = object->section_contents(
            symtab_shndx, &symtab_size, false);
        this->symtab_buffer_end_ = this->symtab_buffer_ + symtab_size;
        break;
      }
  if (this->symtab_buffer_ == NULL)
    return;
d244 12
d262 5
a266 4
          const unsigned char* dirname = lineptr;
          gold_assert(dirindex == static_cast<int>(directories_.size()));
          directories_.push_back(reinterpret_cast<const char*>(dirname));
          lineptr += directories_.back().size() + 1;
d283 3
a285 1
          if (dirindex >= directories_.size())
d287 1
a287 1
          lineptr += len;
d295 3
a297 2
          gold_assert(fileindex == static_cast<int>(files_.size()));
          files_.push_back(std::pair<int, std::string>(dirindex, filename));
d426 1
d432 1
a432 3
                  lsm->address =
		    (elfcpp::Swap<size, big_endian>::readval(start)
		     + it->second.second);
d437 4
a440 3
                  // Every set_address should have an associated
                  // relocation.
                  this->data_valid_ = false;
d451 3
a453 1
              if (dirindex >= directories_.size())
d455 1
a455 1
              oplen += templen;
d463 1
a463 1
              files_.push_back(std::pair<int, std::string>(dirindex,
d518 2
a519 1
                  = { lsm.address, lsm.file_num, lsm.line_num };
d538 1
a538 1
  gold_assert(this->symtab_buffer_ + sym * symsize < this->symtab_buffer_end_);
d590 15
d614 10
a623 3
  const Offset_to_lineno_entry lookup_key = { offset, 0, 0 };
  std::vector<Offset_to_lineno_entry>& offsets = this->line_number_map_[shndx];
  if (offsets.empty())
d627 1
a627 1
      = std::lower_bound(offsets.begin(), offsets.end(), lookup_key);
d633 1
a633 1
      if (it == offsets.begin())
d641 6
a646 4
  gold_assert(it->file_num < static_cast<int>(files_.size()));
  const std::pair<int, std::string>& filename_pair = files_[it->file_num];
  gold_assert(filename_pair.first < static_cast<int>(directories_.size()));
  const std::string& dirname = directories_[filename_pair.first];
d648 7
@


1.5
log
@From Craig Silverstein: rework DWARF reader code a bit.
@
text
@d120 2
a121 3
Dwarf_line_info<size, big_endian>::Dwarf_line_info(
  Sized_relobj<size, big_endian>* object)
  : data_valid_(true), buffer_(NULL), symtab_buffer_(NULL),
d135 1
a135 4
    {
      this->data_valid_ = false;
      return;
    }
d154 1
a154 4
    {
      this->data_valid_ = false;
      return;
    }
d168 1
a168 4
    {
      this->data_valid_ = false;
      return;
    }
d172 1
d551 1
a551 2
  if (this->data_valid_ == false)
    return;
@


1.4
log
@From Craig Silverstein: Use relocations in reporting error message
locations.
@
text
@d27 1
d119 66
d436 1
a436 1
            }                
d545 1
a545 1
  while ((reloc_offset = this->track_relocs_->next_offset()) != -1)
d547 1
a547 1
      const unsigned int sym = this->track_relocs_->next_symndx();
d550 1
a550 1
      this->track_relocs_->advance(reloc_offset + 1);
d560 3
@


1.3
log
@From Cary Coutant: mark negative constant as unsigned.
@
text
@d27 1
d351 19
a369 6
            // FIXME: modify the address based on the reloc
            lsm->address = elfcpp::Swap<size, big_endian>::readval(start);
            // FIXME: set lsm->shndx from the reloc
            lsm->shndx = 1;
            break;

d452 37
d493 2
a494 1
  while (buffer_ < buffer_end_)
d496 1
a496 1
      const unsigned char* lineptr = buffer_;
d500 1
a500 1
      buffer_ = lineptr;
d508 1
a508 1
    sort(it->second.begin(), it->second.end());
d517 3
d521 4
a524 1
  std::vector<Offset_to_lineno_entry>& offsets = line_number_map_[shndx];
@


1.2
log
@From Craig Silverstein: Templatize the Dwarf reader.
@
text
@d111 1
a111 1
  lsm->shndx = -1;
@


1.1
log
@From Craig Silverstein: Add first version of generating error messages
with file name and line number.
@
text
@d121 2
a122 1
Dwarf_line_info::read_header_prolog(const unsigned char* lineptr)
d180 1
d182 2
a183 1
Dwarf_line_info::read_header_tables(const unsigned char* lineptr)
d237 1
d239 2
a240 4
Dwarf_line_info::process_one_opcode(int size, bool big_endian,
                                    const unsigned char* start,
                                    struct LineStateMachine* lsm,
                                    size_t* len)
d317 1
a317 4
        if (big_endian)
          advance_address = elfcpp::Swap<16, true>::readval(start);
        else
          advance_address = elfcpp::Swap<16, false>::readval(start);
d351 1
a351 10
            if (size == 32 && big_endian == false)
              lsm->address = elfcpp::Swap<32, false>::readval(start);
            else if (size == 32 && big_endian == true)
              lsm->address = elfcpp::Swap<32, true>::readval(start);
            else if (size == 64 && big_endian == false)
              lsm->address = elfcpp::Swap<64, false>::readval(start);
            else if (size == 64 && big_endian == true)
              lsm->address = elfcpp::Swap<64, true>::readval(start);
            else
              gold_assert(false);  // We need to implement more cases, then.
d401 1
d403 1
a403 2
Dwarf_line_info::read_lines(int size, bool big_endian,
                            unsigned const char* lineptr)
d424 1
a424 2
          bool add_line = this->process_one_opcode(size, big_endian,
                                                   lineptr, &lsm, &oplength);
d438 1
a438 2
// Called after all line numbers have been read.

d440 1
a440 1
Dwarf_line_info::finalize_line_number_map()
d442 11
a452 1
  for (Lineno_map::iterator it = line_number_map_.begin();
d461 1
d463 1
a463 1
Dwarf_line_info::addr2line(unsigned int shndx, off_t offset)
d467 1
a467 1
  std::vector<Offset_to_lineno_entry>::const_iterator it
d506 1
a506 2
const unsigned char*
Dwarf_line_info::read_header_prolog<32, false>(const unsigned char* lineptr);
d511 1
a511 2
const unsigned char*
Dwarf_line_info::read_header_prolog<32, true>(const unsigned char* lineptr);
d516 1
a516 2
const unsigned char*
Dwarf_line_info::read_header_prolog<64, false>(const unsigned char* lineptr);
d521 1
a521 2
const unsigned char*
Dwarf_line_info::read_header_prolog<64, true>(const unsigned char* lineptr);
@

