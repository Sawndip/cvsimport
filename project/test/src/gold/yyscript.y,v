head	1.27;
access;
symbols
	binutils-2_24-branch:1.27.0.4
	binutils-2_24-branchpoint:1.27
	binutils-2_21_1:1.26
	binutils-2_23_2:1.27
	binutils-2_23_1:1.27
	binutils-2_23:1.27
	binutils-2_23-branch:1.27.0.2
	binutils-2_23-branchpoint:1.27
	binutils-2_22_branch:1.26.0.6
	binutils-2_22:1.26
	binutils-2_22-branch:1.26.0.4
	binutils-2_22-branchpoint:1.26
	binutils-2_21:1.26
	binutils-2_21-branch:1.26.0.2
	binutils-2_21-branchpoint:1.26
	binutils-2_20_1:1.21
	binutils-2_20:1.21
	binutils-arc-20081103-branch:1.16.0.6
	binutils-arc-20081103-branchpoint:1.16
	binutils-2_20-branch:1.21.0.4
	binutils-2_20-branchpoint:1.21
	dje-cgen-play1-branch:1.21.0.2
	dje-cgen-play1-branchpoint:1.21
	arc-20081103-branch:1.16.0.4
	arc-20081103-branchpoint:1.16
	binutils-2_19_1:1.16
	binutils-2_19:1.16
	binutils-2_19-branch:1.16.0.2
	binutils-2_19-branchpoint:1.16
	binutils_latest_snapshot:1.27
	added-to-binutils:1.14;
locks; strict;
comment	@ * @;


1.27
date	2011.11.11.22.29.43;	author sterling;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.08.16.10.31;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2010.08.02.13.34.33;	author ian;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.09.14.14.18;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.09.17.32.58;	author dougkwan;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.16.18.56.07;	author dougkwan;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.23.06.39.47;	author ian;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.24.19.08.37;	author ian;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.14.05.56.46;	author ian;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.09.16.09.32;	author ian;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.06.07.23.31;	author csilvers;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.13.07.37.46;	author ian;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.25.07.50.21;	author bje;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.28.20.35.39;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.04.22.54.31;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2008.02.04.06.45.50;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2008.02.04.05.41.40;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.23.19.31.56;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.23.01.31.13;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.18.23.35.09;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.15.23.41.28;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.09.19.57.45;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.07.05.19.02;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.06.00.47.10;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.26.22.16.06;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	;


desc
@@


1.27
log
@2011-11-11  Sterling Augustine  <saugustine@@google.com>

	* yyscript.y (section_cmd): Add support for INCLUDE directive.
	(file_or_sections_cmd): Likewise.
@
text
@/* yyscript.y -- linker script grammar for gold.  */

/* Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
   Written by Ian Lance Taylor <iant@@google.com>.

   This file is part of gold.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

/* This is a bison grammar to parse a subset of the original GNU ld
   linker script language.  */

%{

#include "config.h"

#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "script-c.h"

%}

/* We need to use a pure parser because we might be multi-threaded.
   We pass some arguments through the parser to the lexer.  */

%pure-parser

%parse-param {void* closure}
%lex-param {void* closure}

/* Since we require bison anyhow, we take advantage of it.  */

%error-verbose

/* The values associated with tokens.  */

%union {
  /* A string.  */
  struct Parser_string string;
  /* A number.  */
  uint64_t integer;
  /* An expression.  */
  Expression_ptr expr;
  /* An output section header.  */
  struct Parser_output_section_header output_section_header;
  /* An output section trailer.  */
  struct Parser_output_section_trailer output_section_trailer;
  /* A section constraint.  */
  enum Section_constraint constraint;
  /* A complete input section specification.  */
  struct Input_section_spec input_section_spec;
  /* A list of wildcard specifications, with exclusions.  */
  struct Wildcard_sections wildcard_sections;
  /* A single wildcard specification.  */
  struct Wildcard_section wildcard_section;
  /* A list of strings.  */
  String_list_ptr string_list;
  /* Information for a program header.  */
  struct Phdr_info phdr_info;
  /* Used for version scripts and within VERSION {}.  */
  struct Version_dependency_list* deplist;
  struct Version_expression_list* versyms;
  struct Version_tree* versnode;
  enum Script_section_type section_type;
}

/* Operators, including a precedence table for expressions.  */

%right PLUSEQ MINUSEQ MULTEQ DIVEQ '=' LSHIFTEQ RSHIFTEQ ANDEQ OREQ
%right '?' ':'
%left OROR
%left ANDAND
%left '|'
%left '^'
%left '&'
%left EQ NE
%left '<' '>' LE GE
%left LSHIFT RSHIFT
%left '+' '-'
%left '*' '/' '%'

/* A fake operator used to indicate unary operator precedence.  */
%right UNARY

/* Constants.  */

%token <string> STRING
%token <string> QUOTED_STRING
%token <integer> INTEGER

/* Keywords.  This list is taken from ldgram.y and ldlex.l in the old
   GNU linker, with the keywords which only appear in MRI mode
   removed.  Not all these keywords are actually used in this grammar.
   In most cases the keyword is recognized as the token name in upper
   case.  The comments indicate where this is not the case.  */

%token ABSOLUTE
%token ADDR
%token ALIGN_K		/* ALIGN */
%token ALIGNOF
%token ASSERT_K		/* ASSERT */
%token AS_NEEDED
%token AT
%token BIND
%token BLOCK
%token BYTE
%token CONSTANT
%token CONSTRUCTORS
%token COPY
%token CREATE_OBJECT_SYMBOLS
%token DATA_SEGMENT_ALIGN
%token DATA_SEGMENT_END
%token DATA_SEGMENT_RELRO_END
%token DEFINED
%token DSECT
%token ENTRY
%token EXCLUDE_FILE
%token EXTERN
%token FILL
%token FLOAT
%token FORCE_COMMON_ALLOCATION
%token GLOBAL		/* global */
%token GROUP
%token HLL
%token INCLUDE
%token INHIBIT_COMMON_ALLOCATION
%token INFO
%token INPUT
%token KEEP
%token LEN
%token LENGTH		/* LENGTH, l, len */
%token LOADADDR
%token LOCAL		/* local */
%token LONG
%token MAP
%token MAX_K		/* MAX */
%token MEMORY
%token MIN_K		/* MIN */
%token NEXT
%token NOCROSSREFS
%token NOFLOAT
%token NOLOAD
%token ONLY_IF_RO
%token ONLY_IF_RW
%token ORG
%token ORIGIN		/* ORIGIN, o, org */
%token OUTPUT
%token OUTPUT_ARCH
%token OUTPUT_FORMAT
%token OVERLAY
%token PHDRS
%token PROVIDE
%token PROVIDE_HIDDEN
%token QUAD
%token SEARCH_DIR
%token SECTIONS
%token SEGMENT_START
%token SHORT
%token SIZEOF
%token SIZEOF_HEADERS	/* SIZEOF_HEADERS, sizeof_headers */
%token SORT_BY_ALIGNMENT
%token SORT_BY_NAME
%token SPECIAL
%token SQUAD
%token STARTUP
%token SUBALIGN
%token SYSLIB
%token TARGET_K		/* TARGET */
%token TRUNCATE
%token VERSIONK		/* VERSION */

/* Keywords, part 2.  These are keywords that are unique to gold,
   and not present in the old GNU linker.  As before, unless the
   comments say otherwise, the keyword is recognized as the token
   name in upper case. */

%token OPTION

/* Special tokens used to tell the grammar what type of tokens we are
   parsing.  The token stream always begins with one of these tokens.
   We do this because version scripts can appear embedded within
   linker scripts, and because --defsym uses the expression
   parser.  */
%token PARSING_LINKER_SCRIPT
%token PARSING_VERSION_SCRIPT
%token PARSING_DEFSYM
%token PARSING_DYNAMIC_LIST

/* Non-terminal types, where needed.  */

%type <expr> parse_exp exp
%type <expr> opt_at opt_align opt_subalign opt_fill
%type <output_section_header> section_header opt_address_and_section_type
%type <section_type> section_type
%type <output_section_trailer> section_trailer
%type <constraint> opt_constraint
%type <string_list> opt_phdr
%type <integer> data_length
%type <input_section_spec> input_section_no_keep
%type <wildcard_sections> wildcard_sections
%type <wildcard_section> wildcard_file wildcard_section
%type <string_list> exclude_names
%type <string> wildcard_name
%type <integer> phdr_type memory_attr
%type <phdr_info> phdr_info
%type <versyms> vers_defns
%type <versnode> vers_tag
%type <deplist> verdep
%type <string> string

%%

/* Read the special token to see what to read next.  */
top:
	  PARSING_LINKER_SCRIPT linker_script
	| PARSING_VERSION_SCRIPT version_script
	| PARSING_DEFSYM defsym_expr
        | PARSING_DYNAMIC_LIST dynamic_list_expr
	;

/* A file contains a list of commands.  */
linker_script:
	  linker_script file_cmd
	| /* empty */
	;

/* A command which may appear at top level of a linker script.  */
file_cmd:
	  EXTERN '(' extern_name_list ')'
	| FORCE_COMMON_ALLOCATION
	    { script_set_common_allocation(closure, 1); }
	| GROUP
	    { script_start_group(closure); }
	  '(' input_list ')'
	    { script_end_group(closure); }
	| INHIBIT_COMMON_ALLOCATION
	    { script_set_common_allocation(closure, 0); }
	| INPUT '(' input_list ')'
	| MEMORY '{' memory_defs '}'
        | OPTION '(' string ')'
	    { script_parse_option(closure, $3.value, $3.length); }
	| OUTPUT_FORMAT '(' string ')'
	    {
	      if (!script_check_output_format(closure, $3.value, $3.length,
					      NULL, 0, NULL, 0))
		YYABORT;
	    }
	| OUTPUT_FORMAT '(' string ',' string ',' string ')'
	    {
	      if (!script_check_output_format(closure, $3.value, $3.length,
					      $5.value, $5.length,
					      $7.value, $7.length))
		YYABORT;
	    }
	| PHDRS '{' phdrs_defs '}'
	| SEARCH_DIR '(' string ')'
	    { script_add_search_dir(closure, $3.value, $3.length); }
	| SECTIONS '{'
	    { script_start_sections(closure); }
	  sections_block '}'
	    { script_finish_sections(closure); }
	| TARGET_K '(' string ')'
	    { script_set_target(closure, $3.value, $3.length); }
        | VERSIONK '{'
            { script_push_lex_into_version_mode(closure); }
          version_script '}'
            { script_pop_lex_mode(closure); }
	| file_or_sections_cmd
	| ignore_cmd
	| ';'
	;

/* Top level commands which we ignore.  The GNU linker uses these to
   select the output format, but we don't offer a choice.  Ignoring
   these is more-or-less OK since most scripts simply explicitly
   choose the default.  */
ignore_cmd:
	  OUTPUT_ARCH '(' string ')'
	;

/* A list of external undefined symbols.  We put the lexer into
   expression mode so that commas separate names; this is what the GNU
   linker does.  */

extern_name_list:
	    { script_push_lex_into_expression_mode(closure); }
	  extern_name_list_body
	    { script_pop_lex_mode(closure); }
	;

extern_name_list_body:
	  string
	    { script_add_extern(closure, $1.value, $1.length); }
	| extern_name_list_body string
	    { script_add_extern(closure, $2.value, $2.length); }
	| extern_name_list_body ',' string
	    { script_add_extern(closure, $3.value, $3.length); }
	;

/* A list of input file names.  */
input_list:
	  input_list_element
	| input_list opt_comma input_list_element
	;

/* An input file name.  */
input_list_element:
	  string
	    { script_add_file(closure, $1.value, $1.length); }
	| '-' STRING
	    { script_add_library(closure, $2.value, $2.length); }
	| AS_NEEDED
	    { script_start_as_needed(closure); }
	  '(' input_list ')'
	    { script_end_as_needed(closure); }
	;

/* Commands in a SECTIONS block.  */
sections_block:
	  sections_block section_block_cmd
	| /* empty */
	;

/* A command which may appear within a SECTIONS block.  */
section_block_cmd:
	  file_or_sections_cmd
	| string section_header
	    { script_start_output_section(closure, $1.value, $1.length, &$2); }
	  '{' section_cmds '}' section_trailer
	    { script_finish_output_section(closure, &$7); }
	;

/* The header of an output section in a SECTIONS block--everything
   after the name.  */
section_header:
	    { script_push_lex_into_expression_mode(closure); }
	  opt_address_and_section_type opt_at opt_align opt_subalign
	    { script_pop_lex_mode(closure); }
	  opt_constraint
	    {
	      $$.address = $2.address;
	      $$.section_type = $2.section_type;
	      $$.load_address = $3;
	      $$.align = $4;
	      $$.subalign = $5;
	      $$.constraint = $7;
	    }
	;

/* The optional address followed by the optional section type.  This
   is a separate nonterminal to avoid a shift/reduce conflict on
   '(' in section_header.  */

opt_address_and_section_type:
	':'
	    {
	      $$.address = NULL;
	      $$.section_type = SCRIPT_SECTION_TYPE_NONE;
	    }
	| '(' ')' ':'
	    {
	      $$.address = NULL;
	      $$.section_type = SCRIPT_SECTION_TYPE_NONE;
	    }
	| exp ':'
	    {
	      $$.address = $1;
	      $$.section_type = SCRIPT_SECTION_TYPE_NONE;
	    }
	| exp '(' ')' ':'
	    {
	      $$.address = $1;
	      $$.section_type = SCRIPT_SECTION_TYPE_NONE;
	    }
	| '(' section_type ')' ':'
	    {
	      $$.address = NULL;
	      $$.section_type = $2;
	    }
	| exp '(' section_type ')' ':'
	    {
	      $$.address = $1;
	      $$.section_type = $3;
	    }
	;

/* We only support NOLOAD.  */
section_type:
	NOLOAD
	    { $$ = SCRIPT_SECTION_TYPE_NOLOAD; }
	| DSECT
	    {
	      yyerror(closure, "DSECT section type is unsupported");
	      $$ = SCRIPT_SECTION_TYPE_DSECT;
	    }
	| COPY
	    {
	      yyerror(closure, "COPY section type is unsupported");
	      $$ = SCRIPT_SECTION_TYPE_COPY;
	    }
	| INFO
	    {
	      yyerror(closure, "INFO section type is unsupported");
	      $$ = SCRIPT_SECTION_TYPE_INFO;
	    }
	| OVERLAY
	    {
	      yyerror(closure, "OVERLAY section type is unsupported");
	      $$ = SCRIPT_SECTION_TYPE_OVERLAY;
	    }
	;

/* The address at which an output section should be loaded.  */
opt_at:
	  /* empty */
	    { $$ = NULL; }
	| AT '(' exp ')'
	    { $$ = $3; }
	;

/* The alignment of an output section.  */
opt_align:
	  /* empty */
	    { $$ = NULL; }
	| ALIGN_K '(' exp ')'
	    { $$ = $3; }
	;

/* The input section alignment within an output section.  */
opt_subalign:
	  /* empty */
	    { $$ = NULL; }
	| SUBALIGN '(' exp ')'
	    { $$ = $3; }
	;

/* A section constraint.  */
opt_constraint:
	  /* empty */
	    { $$ = CONSTRAINT_NONE; }
	| ONLY_IF_RO
	    { $$ = CONSTRAINT_ONLY_IF_RO; }
	| ONLY_IF_RW
	    { $$ = CONSTRAINT_ONLY_IF_RW; }
	| SPECIAL
	    { $$ = CONSTRAINT_SPECIAL; }
	;

/* The trailer of an output section in a SECTIONS block.  */
section_trailer:
	  opt_memspec opt_at_memspec opt_phdr opt_fill opt_comma
	    {
	      $$.fill = $4;
	      $$.phdrs = $3;
	    }
	;

/* A memory specification for an output section.  */
opt_memspec:
	  '>' string
	    { script_set_section_region(closure, $2.value, $2.length, 1); }
	| /* empty */
	;

/* A memory specification for where to load an output section.  */
opt_at_memspec:
	  AT '>' string
	    { script_set_section_region(closure, $3.value, $3.length, 0); }
	| /* empty */
	;

/* The program segment an output section should go into.  */
opt_phdr:
	  opt_phdr ':' string
	    { $$ = script_string_list_push_back($1, $3.value, $3.length); }
	| /* empty */
	    { $$ = NULL; }
	;

/* The value to use to fill an output section.  FIXME: This does not
   handle a string of arbitrary length.  */
opt_fill:
	  '=' parse_exp
	    { $$ = $2; }
	| /* empty */
	    { $$ = NULL; }
	;

/* Commands which may appear within the description of an output
   section in a SECTIONS block.  */
section_cmds:
	  /* empty */
	| section_cmds section_cmd
	;

/* A command which may appear within the description of an output
   section in a SECTIONS block.  */
section_cmd:
	  assignment end
	| input_section_spec
	| data_length '(' parse_exp ')'
	    { script_add_data(closure, $1, $3); }
	| ASSERT_K '(' parse_exp ',' string ')'
	    { script_add_assertion(closure, $3, $5.value, $5.length); }
	| FILL '(' parse_exp ')'
	    { script_add_fill(closure, $3); }
	| CONSTRUCTORS
	    {
	      /* The GNU linker uses CONSTRUCTORS for the a.out object
		 file format.  It does nothing when using ELF.  Since
		 some ELF linker scripts use it although it does
		 nothing, we accept it and ignore it.  */
	    }
	| SORT_BY_NAME '(' CONSTRUCTORS ')'
	| INCLUDE string
	    { script_include_directive(closure, $2.value, $2.length); }
	| ';'
	;

/* The length of data which may appear within the description of an
   output section in a SECTIONS block.  */
data_length:
	  QUAD
	    { $$ = QUAD; }
	| SQUAD
	    { $$ = SQUAD; }
	| LONG
	    { $$ = LONG; }
	| SHORT
	    { $$ = SHORT; }
	| BYTE
	    { $$ = BYTE; }
	;

/* An input section specification.  This may appear within the
   description of an output section in a SECTIONS block.  */
input_section_spec:
	  input_section_no_keep
	    { script_add_input_section(closure, &$1, 0); }
	| KEEP '(' input_section_no_keep ')'
	    { script_add_input_section(closure, &$3, 1); }
	;

/* An input section specification within a KEEP clause.  */
input_section_no_keep:
	  string
	    {
	      $$.file.name = $1;
	      $$.file.sort = SORT_WILDCARD_NONE;
	      $$.input_sections.sections = NULL;
	      $$.input_sections.exclude = NULL;
	    }
	| wildcard_file '(' wildcard_sections ')'
	    {
	      $$.file = $1;
	      $$.input_sections = $3;
	    }
	;

/* A wildcard file specification.  */
wildcard_file:
	  wildcard_name
	    {
	      $$.name = $1;
	      $$.sort = SORT_WILDCARD_NONE;
	    }
	| SORT_BY_NAME '(' wildcard_name ')'
	    {
	      $$.name = $3;
	      $$.sort = SORT_WILDCARD_BY_NAME;
	    }
	;

/* A list of wild card section specifications.  */
wildcard_sections:
	  wildcard_sections opt_comma wildcard_section
	    {
	      $$.sections = script_string_sort_list_add($1.sections, &$3);
	      $$.exclude = $1.exclude;
	    }
	| wildcard_section
	    {
	      $$.sections = script_new_string_sort_list(&$1);
	      $$.exclude = NULL;
	    }
	| wildcard_sections opt_comma EXCLUDE_FILE '(' exclude_names ')'
	    {
	      $$.sections = $1.sections;
	      $$.exclude = script_string_list_append($1.exclude, $5);
	    }
	| EXCLUDE_FILE '(' exclude_names ')'
	    {
	      $$.sections = NULL;
	      $$.exclude = $3;
	    }
	;

/* A single wild card specification.  */
wildcard_section:
	  wildcard_name
	    {
	      $$.name = $1;
	      $$.sort = SORT_WILDCARD_NONE;
	    }
	| SORT_BY_NAME '(' wildcard_section ')'
	    {
	      $$.name = $3.name;
	      switch ($3.sort)
		{
		case SORT_WILDCARD_NONE:
		  $$.sort = SORT_WILDCARD_BY_NAME;
		  break;
		case SORT_WILDCARD_BY_NAME:
		case SORT_WILDCARD_BY_NAME_BY_ALIGNMENT:
		  break;
		case SORT_WILDCARD_BY_ALIGNMENT:
		case SORT_WILDCARD_BY_ALIGNMENT_BY_NAME:
		  $$.sort = SORT_WILDCARD_BY_NAME_BY_ALIGNMENT;
		  break;
		default:
		  abort();
		}
	    }
	| SORT_BY_ALIGNMENT '(' wildcard_section ')'
	    {
	      $$.name = $3.name;
	      switch ($3.sort)
		{
		case SORT_WILDCARD_NONE:
		  $$.sort = SORT_WILDCARD_BY_ALIGNMENT;
		  break;
		case SORT_WILDCARD_BY_ALIGNMENT:
		case SORT_WILDCARD_BY_ALIGNMENT_BY_NAME:
		  break;
		case SORT_WILDCARD_BY_NAME:
		case SORT_WILDCARD_BY_NAME_BY_ALIGNMENT:
		  $$.sort = SORT_WILDCARD_BY_ALIGNMENT_BY_NAME;
		  break;
		default:
		  abort();
		}
	    }
	;

/* A list of file names to exclude.  */
exclude_names:
	  exclude_names opt_comma wildcard_name
	    { $$ = script_string_list_push_back($1, $3.value, $3.length); }
	| wildcard_name
	    { $$ = script_new_string_list($1.value, $1.length); }
	;

/* A single wildcard name.  We recognize '*' and '?' specially since
   they are expression tokens.  */
wildcard_name:
	  string
	    { $$ = $1; }
	| '*'
	    {
	      $$.value = "*";
	      $$.length = 1;
	    }
	| '?'
	    {
	      $$.value = "?";
	      $$.length = 1;
	    }
	;

/* A command which may appear at the top level of a linker script, or
   within a SECTIONS block.  */
file_or_sections_cmd:
	  ENTRY '(' string ')'
	    { script_set_entry(closure, $3.value, $3.length); }
	| assignment end
	| ASSERT_K '(' parse_exp ',' string ')'
	    { script_add_assertion(closure, $3, $5.value, $5.length); }
	| INCLUDE string
	    { script_include_directive(closure, $2.value, $2.length); }
	;

/* A list of MEMORY definitions.  */
memory_defs:
	  memory_defs opt_comma memory_def
	| /* empty */
	;

/* A single MEMORY definition.  */
memory_def:
	  string memory_attr ':' memory_origin '=' parse_exp opt_comma memory_length '=' parse_exp
	  { script_add_memory(closure, $1.value, $1.length, $2, $6, $10); }
	|
	  /* LD supports an INCLUDE directive here, currently GOLD does not.  */
	  INCLUDE string
	  { script_include_directive(closure, $2.value, $2.length); }
	|
	;

/* The (optional) attributes of a MEMORY region.  */
memory_attr:
	  '(' string ')'
	  { $$ = script_parse_memory_attr(closure, $2.value, $2.length, 0); }
        | /* Inverted attributes. */
	  '(' '!' string ')'
	  { $$ = script_parse_memory_attr(closure, $3.value, $3.length, 1); }
	| /* empty */
	    { $$ = 0; }
	;

memory_origin:
          ORIGIN
	|
	  ORG
	|
	  'o'
	;

memory_length:
          LENGTH
	|
	  LEN
	|
	  'l'
	;

/* A list of program header definitions.  */
phdrs_defs:
	  phdrs_defs phdr_def
	| /* empty */
	;

/* A program header definition.  */
phdr_def:
	  string phdr_type phdr_info ';'
	    { script_add_phdr(closure, $1.value, $1.length, $2, &$3); }
	;

/* A program header type.  The GNU linker accepts a general expression
   here, but that would be a pain because we would have to dig into
   the expression structure.  It's unlikely that anybody uses anything
   other than a string or a number here, so that is all we expect.  */
phdr_type:
	  string
	    { $$ = script_phdr_string_to_type(closure, $1.value, $1.length); }
	| INTEGER
	    { $$ = $1; }
	;

/* Additional information for a program header.  */
phdr_info:
	  /* empty */
	    { memset(&$$, 0, sizeof(struct Phdr_info)); }
	| string phdr_info
	    {
	      $$ = $2;
	      if ($1.length == 7 && strncmp($1.value, "FILEHDR", 7) == 0)
		$$.includes_filehdr = 1;
	      else
		yyerror(closure, "PHDRS syntax error");
	    }
	| PHDRS phdr_info
	    {
	      $$ = $2;
	      $$.includes_phdrs = 1;
	    }
	| string '(' INTEGER ')' phdr_info
	    {
	      $$ = $5;
	      if ($1.length == 5 && strncmp($1.value, "FLAGS", 5) == 0)
		{
		  $$.is_flags_valid = 1;
		  $$.flags = $3;
		}
	      else
		yyerror(closure, "PHDRS syntax error");
	    }
	| AT '(' parse_exp ')' phdr_info
	    {
	      $$ = $5;
	      $$.load_address = $3;
	    }
	;

/* Set a symbol to a value.  */
assignment:
	  string '=' parse_exp
	    { script_set_symbol(closure, $1.value, $1.length, $3, 0, 0); }
	| string PLUSEQ parse_exp
	    {
	      Expression_ptr s = script_exp_string($1.value, $1.length);
	      Expression_ptr e = script_exp_binary_add(s, $3);
	      script_set_symbol(closure, $1.value, $1.length, e, 0, 0);
	    }
	| string MINUSEQ parse_exp
	    {
	      Expression_ptr s = script_exp_string($1.value, $1.length);
	      Expression_ptr e = script_exp_binary_sub(s, $3);
	      script_set_symbol(closure, $1.value, $1.length, e, 0, 0);
	    }
	| string MULTEQ parse_exp
	    {
	      Expression_ptr s = script_exp_string($1.value, $1.length);
	      Expression_ptr e = script_exp_binary_mult(s, $3);
	      script_set_symbol(closure, $1.value, $1.length, e, 0, 0);
	    }
	| string DIVEQ parse_exp
	    {
	      Expression_ptr s = script_exp_string($1.value, $1.length);
	      Expression_ptr e = script_exp_binary_div(s, $3);
	      script_set_symbol(closure, $1.value, $1.length, e, 0, 0);
	    }
	| string LSHIFTEQ parse_exp
	    {
	      Expression_ptr s = script_exp_string($1.value, $1.length);
	      Expression_ptr e = script_exp_binary_lshift(s, $3);
	      script_set_symbol(closure, $1.value, $1.length, e, 0, 0);
	    }
	| string RSHIFTEQ parse_exp
	    {
	      Expression_ptr s = script_exp_string($1.value, $1.length);
	      Expression_ptr e = script_exp_binary_rshift(s, $3);
	      script_set_symbol(closure, $1.value, $1.length, e, 0, 0);
	    }
	| string ANDEQ parse_exp
	    {
	      Expression_ptr s = script_exp_string($1.value, $1.length);
	      Expression_ptr e = script_exp_binary_bitwise_and(s, $3);
	      script_set_symbol(closure, $1.value, $1.length, e, 0, 0);
	    }
	| string OREQ parse_exp
	    {
	      Expression_ptr s = script_exp_string($1.value, $1.length);
	      Expression_ptr e = script_exp_binary_bitwise_or(s, $3);
	      script_set_symbol(closure, $1.value, $1.length, e, 0, 0);
	    }
	| PROVIDE '(' string '=' parse_exp ')'
	    { script_set_symbol(closure, $3.value, $3.length, $5, 1, 0); }
	| PROVIDE_HIDDEN '(' string '=' parse_exp ')'
	    { script_set_symbol(closure, $3.value, $3.length, $5, 1, 1); }
	;

/* Parse an expression, putting the lexer into the right mode.  */
parse_exp:
	    { script_push_lex_into_expression_mode(closure); }
	  exp
	    {
	      script_pop_lex_mode(closure);
	      $$ = $2;
	    }
	;

/* An expression.  */
exp:
	  '(' exp ')'
	    { $$ = $2; }
	| '-' exp %prec UNARY
	    { $$ = script_exp_unary_minus($2); }
	| '!' exp %prec UNARY
	    { $$ = script_exp_unary_logical_not($2); }
	| '~' exp %prec UNARY
	    { $$ = script_exp_unary_bitwise_not($2); }
	| '+' exp %prec UNARY
	    { $$ = $2; }
	| exp '*' exp
	    { $$ = script_exp_binary_mult($1, $3); }
	| exp '/' exp
	    { $$ = script_exp_binary_div($1, $3); }
	| exp '%' exp
	    { $$ = script_exp_binary_mod($1, $3); }
	| exp '+' exp
	    { $$ = script_exp_binary_add($1, $3); }
	| exp '-' exp
	    { $$ = script_exp_binary_sub($1, $3); }
	| exp LSHIFT exp
	    { $$ = script_exp_binary_lshift($1, $3); }
	| exp RSHIFT exp
	    { $$ = script_exp_binary_rshift($1, $3); }
	| exp EQ exp
	    { $$ = script_exp_binary_eq($1, $3); }
	| exp NE exp
	    { $$ = script_exp_binary_ne($1, $3); }
	| exp LE exp
	    { $$ = script_exp_binary_le($1, $3); }
	| exp GE exp
	    { $$ = script_exp_binary_ge($1, $3); }
	| exp '<' exp
	    { $$ = script_exp_binary_lt($1, $3); }
	| exp '>' exp
	    { $$ = script_exp_binary_gt($1, $3); }
	| exp '&' exp
	    { $$ = script_exp_binary_bitwise_and($1, $3); }
	| exp '^' exp
	    { $$ = script_exp_binary_bitwise_xor($1, $3); }
	| exp '|' exp
	    { $$ = script_exp_binary_bitwise_or($1, $3); }
	| exp ANDAND exp
	    { $$ = script_exp_binary_logical_and($1, $3); }
	| exp OROR exp
	    { $$ = script_exp_binary_logical_or($1, $3); }
	| exp '?' exp ':' exp
	    { $$ = script_exp_trinary_cond($1, $3, $5); }
	| INTEGER
	    { $$ = script_exp_integer($1); }
	| string
	    { $$ = script_symbol(closure, $1.value, $1.length); }
	| MAX_K '(' exp ',' exp ')'
	    { $$ = script_exp_function_max($3, $5); }
	| MIN_K '(' exp ',' exp ')'
	    { $$ = script_exp_function_min($3, $5); }
	| DEFINED '(' string ')'
	    { $$ = script_exp_function_defined($3.value, $3.length); }
	| SIZEOF_HEADERS
	    { $$ = script_exp_function_sizeof_headers(); }
	| ALIGNOF '(' string ')'
	    { $$ = script_exp_function_alignof($3.value, $3.length); }
	| SIZEOF '(' string ')'
	    { $$ = script_exp_function_sizeof($3.value, $3.length); }
	| ADDR '(' string ')'
	    { $$ = script_exp_function_addr($3.value, $3.length); }
	| LOADADDR '(' string ')'
	    { $$ = script_exp_function_loadaddr($3.value, $3.length); }
	| ORIGIN '(' string ')'
	    { $$ = script_exp_function_origin(closure, $3.value, $3.length); }
	| LENGTH '(' string ')'
	    { $$ = script_exp_function_length(closure, $3.value, $3.length); }
	| CONSTANT '(' string ')'
	    { $$ = script_exp_function_constant($3.value, $3.length); }
	| ABSOLUTE '(' exp ')'
	    { $$ = script_exp_function_absolute($3); }
	| ALIGN_K '(' exp ')'
	    { $$ = script_exp_function_align(script_exp_string(".", 1), $3); }
	| ALIGN_K '(' exp ',' exp ')'
	    { $$ = script_exp_function_align($3, $5); }
	| BLOCK '(' exp ')'
	    { $$ = script_exp_function_align(script_exp_string(".", 1), $3); }
	| DATA_SEGMENT_ALIGN '(' exp ',' exp ')'
	    {
	      script_data_segment_align(closure);
	      $$ = script_exp_function_data_segment_align($3, $5);
	    }
	| DATA_SEGMENT_RELRO_END '(' exp ',' exp ')'
	    {
	      script_data_segment_relro_end(closure);
	      $$ = script_exp_function_data_segment_relro_end($3, $5);
	    }
	| DATA_SEGMENT_END '(' exp ')'
	    { $$ = script_exp_function_data_segment_end($3); }
	| SEGMENT_START '(' string ',' exp ')'
	    {
	      $$ = script_exp_function_segment_start($3.value, $3.length, $5);
	      /* We need to take note of any SEGMENT_START expressions
		 because they change the behaviour of -Ttext, -Tdata and
		 -Tbss options.  */
	      script_saw_segment_start_expression(closure);
	    }
	| ASSERT_K '(' exp ',' string ')'
	    { $$ = script_exp_function_assert($3, $5.value, $5.length); }
	;

/* Handle the --defsym option.  */
defsym_expr:
	  string '=' parse_exp
	    { script_set_symbol(closure, $1.value, $1.length, $3, 0, 0); }
	;

/* Handle the --dynamic-list option.  A dynamic list has the format
   { sym1; sym2; extern "C++" { namespace::sym3 }; };
   We store the symbol we see in the "local" list; that is where
   Command_line::in_dynamic_list() will look to do its check.
   TODO(csilvers): More than one of these brace-lists can appear, and
   should just be merged and treated as a single list.  */
dynamic_list_expr: dynamic_list_nodes ;

dynamic_list_nodes:
	  dynamic_list_node
	| dynamic_list_nodes dynamic_list_node
        ;

dynamic_list_node:
          '{' vers_defns ';' '}' ';'
            { script_new_vers_node (closure, NULL, $2); }
        ;

/* A version script.  */
version_script:
	  vers_nodes
	;

vers_nodes:
	  vers_node
	| vers_nodes vers_node
	;

vers_node:
	  '{' vers_tag '}' ';'
	    {
	      script_register_vers_node (closure, NULL, 0, $2, NULL);
	    }
	| string '{' vers_tag '}' ';'
	    {
	      script_register_vers_node (closure, $1.value, $1.length, $3,
					 NULL);
	    }
	| string '{' vers_tag '}' verdep ';'
	    {
	      script_register_vers_node (closure, $1.value, $1.length, $3, $5);
	    }
	;

verdep:
	  string
	    {
	      $$ = script_add_vers_depend (closure, NULL, $1.value, $1.length);
	    }
	| verdep string
	    {
	      $$ = script_add_vers_depend (closure, $1, $2.value, $2.length);
	    }
	;

vers_tag:
	  /* empty */
	    { $$ = script_new_vers_node (closure, NULL, NULL); }
	| vers_defns ';'
	    { $$ = script_new_vers_node (closure, $1, NULL); }
	| GLOBAL ':' vers_defns ';'
	    { $$ = script_new_vers_node (closure, $3, NULL); }
	| LOCAL ':' vers_defns ';'
	    { $$ = script_new_vers_node (closure, NULL, $3); }
	| GLOBAL ':' vers_defns ';' LOCAL ':' vers_defns ';'
	    { $$ = script_new_vers_node (closure, $3, $7); }
	;

/* Here is one of the rare places we care about the distinction
   between STRING and QUOTED_STRING.  For QUOTED_STRING, we do exact
   matching on the pattern, so we pass in true for the exact_match
   parameter.  For STRING, we do glob matching and pass in false.  */
vers_defns:
	  STRING
	    {
	      $$ = script_new_vers_pattern (closure, NULL, $1.value,
					    $1.length, 0);
	    }
	| QUOTED_STRING
	    {
	      $$ = script_new_vers_pattern (closure, NULL, $1.value,
					    $1.length, 1);
	    }
	| vers_defns ';' STRING
	    {
	      $$ = script_new_vers_pattern (closure, $1, $3.value,
                                            $3.length, 0);
	    }
	| vers_defns ';' QUOTED_STRING
	    {
	      $$ = script_new_vers_pattern (closure, $1, $3.value,
                                            $3.length, 1);
	    }
        | /* Push string on the language stack. */
          EXTERN string '{'
	    { version_script_push_lang (closure, $2.value, $2.length); }
	  vers_defns opt_semicolon '}'
	    {
	      $$ = $5;
	      version_script_pop_lang(closure);
	    }
        | /* Push string on the language stack.  This is more complicated
             than the other cases because we need to merge the linked-list
             state from the pre-EXTERN defns and the post-EXTERN defns.  */
          vers_defns ';' EXTERN string '{'
	    { version_script_push_lang (closure, $4.value, $4.length); }
	  vers_defns opt_semicolon '}'
	    {
	      $$ = script_merge_expressions ($1, $7);
	      version_script_pop_lang(closure);
	    }
        | EXTERN  // "extern" as a symbol name
	    {
	      $$ = script_new_vers_pattern (closure, NULL, "extern",
					    sizeof("extern") - 1, 1);
	    }
	| vers_defns ';' EXTERN
	    {
	      $$ = script_new_vers_pattern (closure, $1, "extern",
					    sizeof("extern") - 1, 1);
	    }
	;

/* A string can be either a STRING or a QUOTED_STRING.  Almost all the
   time we don't care, and we use this rule.  */
string:
          STRING
	    { $$ = $1; }
	| QUOTED_STRING
	    { $$ = $1; }
	;

/* Some statements require a terminator, which may be a semicolon or a
   comma.  */
end:
	  ';'
	| ','
	;

/* An optional semicolon.  */
opt_semicolon:
	  ';'
	|  /* empty */
	;

/* An optional comma.  */
opt_comma:
	  ','
	| /* empty */
	;

%%
@


1.26
log
@        * README: Remove claim that MEMORY is not supported.
        * expression.cc (script_exp_function_origin)
        (script_exp_function_length): Move from here to ...
        * script.cc: ... here.
        (script_set_section_region, script_add_memory)
        (script_parse_memory_attr, script_include_directive): New
        functions.
        * script-sections.cc
        (class Memory_region): New class.
        (class Output_section_definition): Add set_memory_region,
        set_section_vma, set_section_lma and get_section_name methods.
        (class Script_Sections): Add add_memory_region,
        find_memory_region, find_memory_region_origin,
        find_memory_region_length and set_memory_region methods.
        Have set_section_addresses method walk the list of set memory
        regions.
        Extend the print methos to display memory regions.
        * script-sections.h: Add prototypes for new methods.
        Add enum for MEMORY region attributes.
        * yyscript.y: Add support for parsing MEMORY regions.
        * script-c.h: Add prototypes for new functions.
        * testsuite/Makefile.am: Add test of MEMORY region functionality.
        * testsuite/Makefile.in: Regenerate.
        * testsuite/memory_test.sh: New script.
        * testsuite/memory_test.s: New assembler source file.
        * testsuite/memory_test.t: New linker script.
@
text
@d531 2
d694 2
@


1.25
log
@	PR 11855
	* script.cc (Script_options::Script_options): Initialize
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_assignment): Update
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_reference): New function.
	(script_symbol): New function.
	* script.h (class Script_options): Add symbol_definitions_ and
	symbol_references_ fields.
	(Script_options::referenced_const_iterator): New type.
	(Script_options::referenced_begin): New function.
	(Script_options::referenced_end): New function.
	(Script_options::is_referenced): New function.
	(Script_options::any_unreferenced): New function.
	* script-c.h (script_symbol): Declare.
	* yyscript.y (exp): Call script_symbol.
	* symtab.cc: Include "script.h".
	(Symbol_table::gc_mark_undef_symbols): Add layout parameter.
	Change all callers.  Check symbols referenced by scripts.
	(Symbol_table::add_undefined_symbols_from_command_line): Add
	layout parameter.  Change all callers.
	(Symbol_table::do_add_undefined_symbols_from_command_line):
	Likewise.  Break out loop body.  Check symbols referenced by
	scripts.
	(Symbol_table::add_undefined_symbol_from_command_line): New
	function broken out of
	do_add_undefined_symbols_from_command_line.
	* symtab.h (class Symbol_table): Update declarations.
	* archive.cc: Include "layout.h".
	(Archive::should_include_member): Add layout parameter.  Change
	all callers.  Check for symbol mentioned in expression.
	* archive.h (class Archive): Update declaration.
	* object.cc (Sized_relobj::do_should_include_member): Add layout
	parameter.
	* object.h (Object::should_include_member): Add layout parameter.
	Change all callers.
	(Object::do_should_include_member): Add layout parameter.
	(class Sized_relobj): Update declaration.
	* dynobj.cc (Sized_dynobj::do_should_include_member): Add layout
	parameter.
	* dynobj.h (class Sized_dynobj): Update declaration.
	* plugin.cc (Sized_pluginobj::do_should_include_member): Add
	layout parameter.
	* plugin.h (class Sized_pluginobj): Update declaration.
@
text
@d146 1
d161 1
d220 1
a220 1
%type <integer> phdr_type
d255 1
d477 1
a477 1
	    { yyerror(closure, "memory regions are not supported"); }
d484 1
a484 1
	    { yyerror(closure, "memory regions are not supported"); }
d694 44
d935 1
a935 1
	    { $$ = script_exp_function_origin($3.value, $3.length); }
d937 1
a937 1
	    { $$ = script_exp_function_length($3.value, $3.length); }
@


1.24
log
@        * yyscript.y (input_list_element): Allow strings prefixed with
        the '-' character.  Treat these as libraries.
        * script.cc (script_add_library): New function.  Adds a library
        specified by "-l<name>" found in an input script.
        * script-c.h: Add prototype for script_add_library.
@
text
@d870 1
a870 1
	    { $$ = script_exp_string($1.value, $1.length); }
@


1.23
log
@2010-04-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::choose_output_section): Handle script section
	types.
	(Layout::make_output_section_for_script): Add section type parameter.
	Handle script section types.
	* layout.h (Layout::make_output_section_for_script): Add section
	type parameter.
	* output.cc (Output_section::Output_section): Initialize data member
	is_noload_.
	(Output_section::do_reset_address_and_file_offset): Do not set address
	to 0 if section is a NOLOAD section.
	* output.h (Output_section::is_noload): New method.
	(Output_section::set_is_noload): Ditto.
	(Output_section::is_noload_): New data member.
	* script-c.h (Script_section_type): New enum type.
	(struct Parser_output_section_header): Add new file section_type.
	* script-sections.cc (Sections_element::output_section_name): Add
	parameter for returning script section type.
	(Output_section_definition::output_section_name): Ditto.
	(Output_section_definition::section_type)P; New method.
	(Output_section_definiton::script_section_type_name): Ditto.
	(Output_section_definition::script_section_type_): New data member.
	(Output_section_definition::Output_section_definition): Initialize
	data member Output_section_definition::script_section_type_.
	(Output_section_definition::create_sections): Pass script section type
	to Layout::make_output_section_for_script.
	(Output_section_definition::output_section_name): Return script
	section type to caller.
	(Output_section_definition::set_section_address): Do not advance
	dot value and load address if section type is NOLOAD.  Set address
	of NOLOAD sections regardless of section flags.
	(Output_section_definition::print): Print section type if it is
	not SCRIPT_SECTION_TYPE_NONE.
	(Output_section_definition::section_type): New method.
	(Output_section_definition::script_section_type_name): Ditto.
	(Script_sections::output_section_name): Add new parameter
	PSECTION_TYPE for returning script section type.  Pass it to
	section elements.  Handle discard sections.
	(Sort_output_sections::operator()): Handle NOLOAD sections.
	* script-sections.h (Script_sections::Section_type): New enum type.
   	(Script_sections::output_section_name): Add a new parameter for
	returning script section type.
	* script.cc (script_keyword_parsecodes): Add keywords COPY, DSECT,
	INFO and NOLOAD.
	* yyscript.y (union): Add new field SECTION_TYPE.
	(COPY, DSECT, INFO, NOLOAD): New tokens.
	(opt_address_and_section_type): Change type to output_section_header.
	(section_type): New non-terminal
	(section_header): Handle section type.
 	(opt_address_and_section_type): Return section type value.
@
text
@d323 2
@


1.22
log
@2009-10-16  Doug Kwan  <dougkwan@@google.com>

	* expression.cc (class Segment_start_expression): New class definition.
	(Segment_start_expression::value): New method definition.
	(script_exp_function_segment_start): Return a new
	Segment_start_expression.
	* gold/script-c.h (script_saw_segment_start_expression): New function
	prototype.
	* script-sections.cc (Script_sections::Script_sections): Initialize
	SAW_SEGMENT_START_EXPRESSION_ to false.
	(Script_sections::set_section_addresses): Use -Ttext, -Tdata
	and -Tbbs options to specify section addresses if given in
	command line and no SEGMENT_START expression is seen in a script.
	* script-sections.h (Script_sections::saw_segment_start_expression,
	Script_sections::set_saw_segment_start_expression): New method
	definition.
	(Script_sections::saw_segment_start_expression_): New data member
	declaration.
	* script.cc (script_saw_segment_start_expression): New function.
	* yyscript.y (SEGMENT_START): Call script_saw_segment_start_expression.
	* testsuite/Makefile.am (check_SCRIPTS): Add script_test_6.sh,
	script_test_7.sh and script_test_8.sh.
	(check_DATA): Add script_test_6.stdout, script_test_7.stdout and
	script_test_8.stdout.
	(MOSTLYCLEANFILES): Add script_test_6, script_test_7 and script_test_8.
	(script_test_6, script_test_6.stdout, script_test_7,
	script_test_7.stdout, script_test_8, script_test_8.stdout): New rules.
	* Makefile.in: Regenerate.
	* testsuite/script_test_6.sh: New file.
	* testsuite/script_test_6.t: Same.
	* testsuite/script_test_7.sh: Same.
	* testsuite/script_test_7.t: Same.
	* testsuite/script_test_8.sh: Same.
@
text
@d80 1
d125 1
d131 1
d143 1
d157 1
d205 1
a205 1
%type <expr> parse_exp exp opt_address_and_section_type
d207 2
a208 1
%type <output_section_header> section_header
d352 2
a353 1
	      $$.address = $2;
d366 5
a370 2
	  ':'
	    { $$ = NULL; }
d372 4
a375 1
	    { $$ = NULL; }
d377 4
a380 1
	    { $$ = $1; }
a381 2
	    { $$ = $1; }
	| exp '(' string ')' ':'
d383 38
a420 2
	      yyerror(closure, "section types are not supported");
	      $$ = $1;
@


1.21
log
@	PR 10030
	* yyscript.y: Parse TARGET.
	* script.cc (script_set_target): New function.
	* script-c.h (script_set_target): Declare.
	* options.cc (General_options::string_to_object_format): Rename
	from string_to_object_format in anonymous namespace.  Change
	callers.
	* options.h (class General_options): Declare
	string_to_object_format.
@
text
@d864 4
@


1.20
log
@	* yyscript.y (file_cmd): Recognize EXTERN.
	(extern_name_list, extern_name_list_body): New nonterminals.
	* script.cc (script_add_extern): Define.
	* script-c.h (script_add_extern): Declare.
@
text
@d269 2
@


1.19
log
@	* readsyms.cc (Read_symbols::incompatible_warning): New function.
	(Read_symbols::requeue): New function.
	(Read_symbols::do_read_symbols): If make_elf_object fails because
	the target type is not configured, and the file was searched for,
	issue a warning and retry with the next directory.
	(Add_symbols::run): If the file has an incompatible format, and
	it was searched for, requeue the Read_symbols task.  On error,
	release the object.
	* readsyms.h (class Read_symbols): Add dirindex_ field.  Add
	dirindex parameter to constructor.  Change all callers.  Declare
	incompatible_warning and requeue.
	(class Add_symbols): Add dirpath_, dirindex_, mapfile_,
	input_argument_ and input_group_ fields.  Add them to
	constructor.  Change all callers.
	(class Read_script): Add dirindex_ field.  Add it to constructor.
	Change all callers.
	* archive.cc (Archive::setup): Remove input_objects parameter.
	Change all callers.
	(Archive::get_file_and_offset): Likewise.
	(Archive::read_all_symbols): Likewise.
	(Archive::read_symbols): Likewise.
	(Archive::get_elf_object_for_member): Remove input_objects
	parameter.  Add punconfigured parameter.  Change all callers.
	(Archive::add_symbols): Change return type to bool.  Check return
	value of include_member.
	(Archive::include_all_members): Likewise.
	(Archive::include_member): Change return type to bool.  Return
	false if first included object has incompatible target.  Set
	included_member_ field.
	(Add_archive_symbols::run): If add_symbols returns false, requeue
	Read_symbols task.
	* archive.h (class Archive): Add included_member_ field.
	Initialize it in constructor.  Add input_file and searched_for
	methods.  Update declarations.
	(class Add_archive_symbols): Add dirpath_, dirindex_, and
	input_argument_ fields.  Add them to constructor.  Change all
	callers.
	* script.cc: Include "target-select.h".
	(class Parser_closure): Add skip_on_incompatible_target_ and
	found_incompatible_target_ fields.  Add
	skip_on_incompatible_target parameter to constructor.  Change all
	callers.  Add methods skip_on_incompatible_target,
	clear_skip_on_incompatible_target, found_incompatible_target, and
	set_found_incompatible_target.
	(read_input_script): Add dirindex parameter.  Change all callers.
	If parser finds an incompatible target, requeue Read_symbols
	task.
	(script_set_symbol): Clear skip_on_incompatible_target in
	closure.
	(script_add_assertion, script_parse_option): Likewise.
	(script_start_sections, script_add_phdr): Likewise.
	(script_check_output_format): New function.
	* script.h (read_input_script): Update declaration.
	* script-c.h (script_check_output_format): Declare.
	* yyscript.y (file_cmd): Handle OUTPUT_FORMAT.
	(ignore_cmd): Remove OUTPUT_FORMAT.
	* fileread.cc (Input_file::Input_file): Add explicit this.
	(Input_file::will_search_for): New function.
	(Input_file::open): Add pindex parameter.  Change all callers.
	* fileread.h (class Input_file): Add input_file_argument method.
	Declare will_search_for.  Update declarations.
	* object.cc (make_elf_object): Add punconfigured parameter.
	Change all callers.
	* object.h (class Object): Make input_file public.  Add
	searched_for method.
	(make_elf_object): Update declaration.
	* dirsearch.cc (Dirsearch::find): Add pindex parameter.  Use it to
	restart search.
	* dirsearch.h (class Dirsearch): Update declaration.
	* options.h (class General_options): Add --warn-search-mismatch.
	* parameters.cc (Parameters::is_compatible_target): New function.
	* parameters.h (class Parameters): Declare is_compatible_target.
	* workqueue.cc (Workqueue::add_blocker): New function.
	* workqueue.h (class Workqueue): Declare add_blocker.
@
text
@d237 2
a238 1
	  FORCE_COMMON_ALLOCATION
d286 19
@


1.18
log
@	PR 7088
	* yyscript.y (file_cmd): Handle INPUT.
@
text
@d248 13
d282 1
a282 3
	  OUTPUT_FORMAT '(' string ')'
	| OUTPUT_FORMAT '(' string ',' string ',' string ')'
	| OUTPUT_ARCH '(' string ')'
@


1.17
log
@	* options.cc (General_options::parse_dynamic_list): New function.
	* options.h (General_options): New flags dynamic_list,
	dynamic_list_data, dynamic_list_cpp_new, and
	dynamic_list_cpp_typeinfo.  New variable dynamic_list_.
	(General_options::in_dynamic_list): New function.
	* script.cc (Lex::Mode): New enum DYNAMIC_LIST.
	(Lex::can_start_name): Add support for DYNAMIC_LIST mode.
	(Lex::can_continue_name): Likewise.
	(yylex): Likewise.
	(read_script_file): New parameter script_options.
	(read_dynamic_list): New function.
	(Script_options::define_dynamic_list): New function.
	(dynamic_list_keyword_parsecodes): New variable.
	(dynamic_list_keywords): New variable.
	* script.h (Script_options::define_dynamic_list): New function
	prototype.
	(read_dynamic_list): New function prototype.
	* symtab.cc (strprefix): New macro.
	(Symbol::should_add_dynsym_entry): Support dynamic_list,
	dynamic_list_data, dynamic_list_cpp_new, and
	dynamic_list_cpp_typeinfo.
	* yyscript.y (PARSING_DYNAMIC_LIST): New token.
	(dynamic_list_expr): New rule.
	(dynamic_list_nodes): Likewise.
	(dynamic_list_node): Likewise.
	* testsuite/Makefile.am (dynamic_list): New test.
	* testsuite/Makefile.in: Regenerated.
	* testsuite/dynamic_list.t: New file.
	* testsuite/dynamic_list.sh: New file.
@
text
@d245 1
@


1.16
log
@	* layout.cc (Layout::attach_allocated_section_to_segment): Don't
	set tls_segment_ or relro_segment_.
	(Layout::make_output_segment): Set tls_segment_ and relro_segment_
	when appropriate.
	* output.h (Output_section::clear_is_relro): New function.
	* output.cc (Output_segment::add_output_section): Handle SHF_TLS
	sections specially even when output_data_ is empty.
	(Output_segment::maximum_alignment): When first section is relro,
	only force alignment for PT_LOAD segments.
	* script.cc (script_data_segment_align): New function.
	(script_data_segment_relro_end): New function.
	* script-c.h (script_data_segment_align): Declare.
	(script_data_segment_relro_end): Declare.
	* script-sections.h (class Script_sections): Declare
	data_segment_align and data_segment_relro_end.  Add fields
	segment_align_index_ and saw_relro_end_.
	* script-sections.cc (class Sections_element): Add set_is_relro
	virtual function.  Add new bool* parameter to place_orphan_here.
	Add get_output_section virtual function.
	(class Output_section_definition): Add set_is_relro.  Add new
	bool* parameter to place_orphan_here.  Add get_output_section.
	Add is_relro_ field.
	(Output_section_definition::Output_section_definition): Initialize
	evaluated_address_, evaluated_load_address, evaluated_addralign_,
	and is_relro_ fields.
	(Output_section_definition::place_orphan_here): Add is_relro
	parameter.
	(Output_section_definition::set_section_addresses): Set relro for
	output section.
	(Output_section_definition::alternate_constraint): Likewise.
	(class Orphan_output_section): Add new bool* parameter to
	place_orphan_here.  Add get_output_section.
	(Orphan_output_section::place_orphan_here): Add is_relro
	parameter.
	(Script_sections::Script_sections): Initialize
	data_segment_align_index_ and saw_relro_end_.
	(Script_sections::data_segment_align): New function.
	(Script_sections::data_segment_relro_end): New function.
	(Script_sections::place_orphan): Set or clear is_relro.
	(Script_sections::set_section_addresses): Force alignment of first
	TLS section.
	* yyscript.y (exp): Call script_data_segment_align and
	script_data_segment_relro_end.
	* testsuite/relro_script_test.t: New file.
	* testsuite/relro_test.cc (using_script): Declare.
	(t1, t2): Test using_script.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_script_test.
	(relro_script_test_SOURCES): Define.
	(relro_script_test_DEPENDENCIES): Define.
	(relro_script_test_LDFLAGS): Define.
	(relro_script_test_LDADD): Define.
	(relro_script_test.so): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d196 1
d226 1
d841 18
@


1.15
log
@	* yyscript.y: Fix spelling error in comment.
@
text
@d814 4
a817 1
	    { $$ = script_exp_function_data_segment_align($3, $5); }
d819 4
a822 1
	    { $$ = script_exp_function_data_segment_relro_end($3, $5); }
@


1.14
log
@Support -d/--define-common.
@
text
@d1 1
a1 1
/* yyscript.y -- linker script grammer for gold.  */
@


1.13
log
@Implement PHDRS.
@
text
@d235 3
a237 1
	  GROUP
d241 2
@


1.12
log
@Implement SIZEOF_HEADERS, section constraints, other minor linker
script items.
@
text
@d33 1
d74 2
d204 1
d211 2
d241 1
d375 1
d396 1
a396 1
	    { yyerror(closure, "program headers are not supported"); }
d398 1
d597 58
@


1.11
log
@Fully implement the SECTIONS clause.
@
text
@d63 2
d200 1
d235 2
d247 1
d296 2
d303 1
a303 1
	      script_pop_lex_mode(closure);
d351 12
a364 1
	    { script_push_lex_into_expression_mode(closure); }
d367 1
a367 2
	      $$.fill = $5;
	      script_pop_lex_mode(closure);
d395 1
a395 1
	  '=' exp
d426 1
@


1.10
log
@Use string instead of STRING, so that we handled QUOTED_STRING.
@
text
@d374 2
a375 1
/* The value to use to fill an output section.  */
@


1.9
log
@Parse a SECTIONS clause in a linker script.
@
text
@d279 1
a279 1
	| STRING section_header
d312 1
a312 1
	| exp '(' STRING ')' ':'
d355 1
a355 1
	  '>' STRING
d362 1
a362 1
	  AT '>' STRING
d369 1
a369 1
	  opt_phdr ':' STRING
d396 1
a396 1
	| ASSERT_K '(' parse_exp ',' STRING ')'
d436 1
a436 1
	  STRING
d546 1
a546 1
	  STRING
d566 1
a566 1
	| ASSERT_K '(' parse_exp ',' STRING ')'
d690 1
a690 3
	| STRING
	    { $$ = script_exp_string($1.value, $1.length); }
	| QUOTED_STRING
@


1.8
log
@From Craig Silverstein: Handle quoted strings differently in version
scripts, and handle extern "C++" in the middle of a block.
@
text
@d32 1
d59 13
a71 1
  // Used for version scripts and within VERSION {}
a118 1
%token COPY
a123 1
%token DSECT
a133 1
%token INFO
a147 1
%token NOLOAD
d194 10
a203 1
%type <expr> parse_exp exp
d232 4
d270 290
d566 2
@


1.7
log
@From Andrew Chatham and Craig Silverstein: Add support for version
scripts.
@
text
@d85 1
d189 1
d212 1
a212 1
        | OPTION '(' STRING ')'
d227 3
a229 3
	  OUTPUT_FORMAT '(' STRING ')'
	| OUTPUT_FORMAT '(' STRING ',' STRING ',' STRING ')'
	| OUTPUT_ARCH '(' STRING ')'
d240 1
a240 1
	  STRING
d251 1
a251 1
	  ENTRY '(' STRING ')'
d258 1
a258 1
	  STRING '=' parse_exp
d260 1
a260 1
	| STRING PLUSEQ parse_exp
d266 1
a266 1
	| STRING MINUSEQ parse_exp
d272 1
a272 1
	| STRING MULTEQ parse_exp
d278 1
a278 1
	| STRING DIVEQ parse_exp
d284 1
a284 1
	| STRING LSHIFTEQ parse_exp
d290 1
a290 1
	| STRING RSHIFTEQ parse_exp
d296 1
a296 1
	| STRING ANDEQ parse_exp
d302 1
a302 1
	| STRING OREQ parse_exp
d308 1
a308 1
	| PROVIDE '(' STRING '=' parse_exp ')'
d310 1
a310 1
	| PROVIDE_HIDDEN '(' STRING '=' parse_exp ')'
d378 2
d384 1
a384 1
	| DEFINED '(' STRING ')'
d388 1
a388 1
	| ALIGNOF '(' STRING ')'
d390 1
a390 1
	| SIZEOF '(' STRING ')'
d392 1
a392 1
	| ADDR '(' STRING ')'
d394 1
a394 1
	| LOADADDR '(' STRING ')'
d396 1
a396 1
	| ORIGIN '(' STRING ')'
d398 1
a398 1
	| LENGTH '(' STRING ')'
d400 1
a400 1
	| CONSTANT '(' STRING ')'
d416 1
a416 1
	| SEGMENT_START '(' STRING ',' exp ')'
d420 1
a420 1
	| ASSERT_K '(' exp ',' STRING ')'
d426 1
a426 1
	  STRING '=' parse_exp
d445 1
a445 1
	| STRING '{' vers_tag '}' ';'
d450 1
a450 1
	| STRING '{' vers_tag '}' verdep ';'
d457 1
a457 1
	  STRING
d461 1
a461 1
	| verdep STRING
d480 4
d488 6
a493 1
					    $1.length);
d497 7
a503 1
	      $$ = script_new_vers_pattern (closure, $1, $3.value, $3.length);
d505 3
a507 3
        | /* Push STRING on the language stack. */
          EXTERN STRING '{'
	    { version_script_push_lang(closure, $2.value, $2.length); }
d513 10
d526 1
a526 1
					    sizeof("extern") - 1);
d531 1
a531 1
					    sizeof("extern") - 1);
d533 9
@


1.6
log
@Support assignments and expressions in linker scripts.
@
text
@d58 4
d185 3
d212 4
d426 1
a426 1
/* A version script.  Not yet implemented.  */
d428 76
d511 6
@


1.5
log
@Report linker script errors with line numbers.  Ignore OUTPUT_FORMAT
with three arguments, and ignore OUTPUT_ARCH.
@
text
@d3 1
a3 1
/* Copyright 2006, 2007 Free Software Foundation, Inc.
d52 6
a57 2
  const char* string;
  int64_t integer;
d75 3
d92 1
d169 13
d184 7
d192 2
a193 2
file_list:
	  file_list file_cmd
d204 1
a204 1
            { script_parse_option(closure, $3); }
d228 1
a228 1
	    { script_add_file(closure, $1); }
d239 185
a423 1
	    { script_set_entry(closure, $3); }
@


1.4
log
@Add support for -e and for ENTRY in linker scripts.
@
text
@d171 1
a171 2
	  OUTPUT_FORMAT '(' STRING ')'
	| GROUP
d178 11
@


1.3
log
@From Craig Silverstein: preliminary support for OPTION in linker script.
@
text
@d163 1
d169 1
d178 1
d181 1
d187 1
d197 8
@


1.2
log
@Add licensing text to every source file.
@
text
@d154 7
d174 2
@


1.1
log
@More dynamic object support, initial scripting support.
@
text
@d3 20
@

