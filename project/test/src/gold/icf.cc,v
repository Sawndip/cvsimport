head	1.21;
access;
symbols
	binutils-2_24-branch:1.21.0.2
	binutils-2_24-branchpoint:1.21
	binutils-2_21_1:1.15.2.2
	binutils-2_23_2:1.20
	binutils-2_23_1:1.20
	binutils-2_23:1.20
	binutils-2_23-branch:1.20.0.6
	binutils-2_23-branchpoint:1.20
	binutils-2_22_branch:1.20.0.4
	binutils-2_22:1.20
	binutils-2_22-branch:1.20.0.2
	binutils-2_22-branchpoint:1.20
	binutils-2_21:1.15
	binutils-2_21-branch:1.15.0.2
	binutils-2_21-branchpoint:1.15
	binutils-2_20_1:1.3.2.1
	binutils-2_20:1.3.2.1
	binutils-2_20-branch:1.3.0.2
	binutils-2_20-branchpoint:1.3
	binutils_latest_snapshot:1.21;
locks; strict;
comment	@// @;


1.21
date	2013.03.15.07.51.32;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2011.06.28.21.15.42;	author ian;	state Exp;
branches;
next	1.19;

1.19
date	2011.02.02.21.55.29;	author tmsriram;	state Exp;
branches;
next	1.18;

1.18
date	2011.01.25.17.14.59;	author dougkwan;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.14.19.03.30;	author rwild;	state Exp;
branches;
next	1.16;

1.16
date	2010.11.05.21.14.12;	author ccoutant;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.28.17.14.15;	author tmsriram;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2010.07.29.18.57.28;	author tmsriram;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.23.18.49.22;	author tmsriram;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.20.21.13.30;	author tmsriram;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.10.01.26.57;	author tmsriram;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.22.18.26.29;	author dougkwan;	state Exp;
branches;
next	1.9;

1.9
date	2010.02.21.00.57.59;	author tmsriram;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.13.02.04.20;	author tmsriram;	state Exp;
branches;
next	1.7;

1.7
date	2010.01.04.19.08.39;	author tmsriram;	state Exp;
branches;
next	1.6;

1.6
date	2009.12.14.19.53.04;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.13.21.17.43;	author tmsriram;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.13.00.03.43;	author tmsriram;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2009.08.12.19.03.16;	author tmsriram;	state Exp;
branches;
next	1.1;

1.1
date	2009.08.05.20.51.56;	author tmsriram;	state Exp;
branches;
next	;

1.15.2.1
date	2011.02.03.20.42.07;	author ian;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2011.02.27.15.17.29;	author ian;	state Exp;
branches;
next	;

1.3.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	;


desc
@@


1.21
log
@	* gc.h (gc_process_relocs): Don't look through function descriptors.
	* icf.cc (get_section_contents): Do so here instead.
@
text
@// icf.cc -- Identical Code Folding.
//
// Copyright 2009, 2010, 2011 Free Software Foundation, Inc.
// Written by Sriraman Tallam <tmsriram@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

// Identical Code Folding Algorithm
// ----------------------------------
// Detecting identical functions is done here and the basic algorithm
// is as follows.  A checksum is computed on each foldable section using
// its contents and relocations.  If the symbol name corresponding to
// a relocation is known it is used to compute the checksum.  If the
// symbol name is not known the stringified name of the object and the
// section number pointed to by the relocation is used.  The checksums
// are stored as keys in a hash map and a section is identical to some
// other section if its checksum is already present in the hash map.
// Checksum collisions are handled by using a multimap and explicitly
// checking the contents when two sections have the same checksum.
//
// However, two functions A and B with identical text but with
// relocations pointing to different foldable sections can be identical if
// the corresponding foldable sections to which their relocations point to
// turn out to be identical.  Hence, this checksumming process must be
// done repeatedly until convergence is obtained.  Here is an example for
// the following case :
//
// int funcA ()               int funcB ()
// {                          {
//   return foo();              return goo();
// }                          }
//
// The functions funcA and funcB are identical if functions foo() and
// goo() are identical.
//
// Hence, as described above, we repeatedly do the checksumming,
// assigning identical functions to the same group, until convergence is
// obtained.  Now, we have two different ways to do this depending on how
// we initialize.
//
// Algorithm I :
// -----------
// We can start with marking all functions as different and repeatedly do
// the checksumming.  This has the advantage that we do not need to wait
// for convergence. We can stop at any point and correctness will be
// guaranteed although not all cases would have been found.  However, this
// has a problem that some cases can never be found even if it is run until
// convergence.  Here is an example with mutually recursive functions :
//
// int funcA (int a)            int funcB (int a)
// {                            {
//   if (a == 1)                  if (a == 1)
//     return 1;                    return 1;
//   return 1 + funcB(a - 1);     return 1 + funcA(a - 1);
// }                            }
//
// In this example funcA and funcB are identical and one of them could be
// folded into the other.  However, if we start with assuming that funcA
// and funcB are not identical, the algorithm, even after it is run to
// convergence, cannot detect that they are identical.  It should be noted
// that even if the functions were self-recursive, Algorithm I cannot catch
// that they are identical, at least as is.
//
// Algorithm II :
// ------------
// Here we start with marking all functions as identical and then repeat
// the checksumming until convergence.  This can detect the above case
// mentioned above.  It can detect all cases that Algorithm I can and more.
// However, the caveat is that it has to be run to convergence.  It cannot
// be stopped arbitrarily like Algorithm I as correctness cannot be
// guaranteed.  Algorithm II is not implemented.
//
// Algorithm I is used because experiments show that about three
// iterations are more than enough to achieve convergence. Algorithm I can
// handle recursive calls if it is changed to use a special common symbol
// for recursive relocs.  This seems to be the most common case that
// Algorithm I could not catch as is.  Mutually recursive calls are not
// frequent and Algorithm I wins because of its ability to be stopped
// arbitrarily.
//
// Caveat with using function pointers :
// ------------------------------------
//
// Programs using function pointer comparisons/checks should use function
// folding with caution as the result of such comparisons could be different
// when folding takes place.  This could lead to unexpected run-time
// behaviour.
//
// Safe Folding :
// ------------
//
// ICF in safe mode folds only ctors and dtors if their function pointers can
// never be taken.  Also, for X86-64, safe folding uses the relocation
// type to determine if a function's pointer is taken or not and only folds
// functions whose pointers are definitely not taken.
//
// Caveat with safe folding :
// ------------------------
//
// This applies only to x86_64.
//
// Position independent executables are created from PIC objects (compiled
// with -fPIC) and/or PIE objects (compiled with -fPIE).  For PIE objects, the
// relocation types for function pointer taken and a call are the same.
// Now, it is not always possible to tell if an object used in the link of
// a pie executable is a PIC object or a PIE object.  Hence, for pie
// executables, using relocation types to disambiguate function pointers is
// currently disabled.
//
// Further, it is not correct to use safe folding to build non-pie
// executables using PIC/PIE objects.  PIC/PIE objects have different
// relocation types for function pointers than non-PIC objects, and the
// current implementation of safe folding does not handle those relocation
// types.  Hence, if used, functions whose pointers are taken could still be
// folded causing unpredictable run-time behaviour if the pointers were used
// in comparisons.
//
//
//
// How to run  : --icf=[safe|all|none]
// Optional parameters : --icf-iterations <num> --print-icf-sections
//
// Performance : Less than 20 % link-time overhead on industry strength
// applications.  Up to 6 %  text size reductions.

#include "gold.h"
#include "object.h"
#include "gc.h"
#include "icf.h"
#include "symtab.h"
#include "libiberty.h"
#include "demangle.h"
#include "elfcpp.h"
#include "int_encoding.h"

namespace gold
{

// This function determines if a section or a group of identical
// sections has unique contents.  Such unique sections or groups can be
// declared final and need not be processed any further.
// Parameters :
// ID_SECTION : Vector mapping a section index to a Section_id pair.
// IS_SECN_OR_GROUP_UNIQUE : To check if a section or a group of identical
//                            sections is already known to be unique.
// SECTION_CONTENTS : Contains the section's text and relocs to sections
//                    that cannot be folded.   SECTION_CONTENTS are NULL
//                    implies that this function is being called for the
//                    first time before the first iteration of icf.

static void
preprocess_for_unique_sections(const std::vector<Section_id>& id_section,
                               std::vector<bool>* is_secn_or_group_unique,
                               std::vector<std::string>* section_contents)
{
  Unordered_map<uint32_t, unsigned int> uniq_map;
  std::pair<Unordered_map<uint32_t, unsigned int>::iterator, bool>
    uniq_map_insert;

  for (unsigned int i = 0; i < id_section.size(); i++)
    {
      if ((*is_secn_or_group_unique)[i])
        continue;

      uint32_t cksum;
      Section_id secn = id_section[i];
      section_size_type plen;
      if (section_contents == NULL)
        {
          // Lock the object so we can read from it.  This is only called
          // single-threaded from queue_middle_tasks, so it is OK to lock.
          // Unfortunately we have no way to pass in a Task token.
          const Task* dummy_task = reinterpret_cast<const Task*>(-1);
          Task_lock_obj<Object> tl(dummy_task, secn.first);
          const unsigned char* contents;
          contents = secn.first->section_contents(secn.second,
                                                  &plen,
                                                  false);
          cksum = xcrc32(contents, plen, 0xffffffff);
        }
      else
        {
          const unsigned char* contents_array = reinterpret_cast
            <const unsigned char*>((*section_contents)[i].c_str());
          cksum = xcrc32(contents_array, (*section_contents)[i].length(),
                         0xffffffff);
        }
      uniq_map_insert = uniq_map.insert(std::make_pair(cksum, i));
      if (uniq_map_insert.second)
        {
          (*is_secn_or_group_unique)[i] = true;
        }
      else
        {
          (*is_secn_or_group_unique)[i] = false;
          (*is_secn_or_group_unique)[uniq_map_insert.first->second] = false;
        }
    }
}

// This returns the buffer containing the section's contents, both
// text and relocs.  Relocs are differentiated as those pointing to
// sections that could be folded and those that cannot.  Only relocs
// pointing to sections that could be folded are recomputed on
// subsequent invocations of this function.
// Parameters  :
// FIRST_ITERATION    : true if it is the first invocation.
// SECN               : Section for which contents are desired.
// SECTION_NUM        : Unique section number of this section.
// NUM_TRACKED_RELOCS : Vector reference to store the number of relocs
//                      to ICF sections.
// KEPT_SECTION_ID    : Vector which maps folded sections to kept sections.
// SECTION_CONTENTS   : Store the section's text and relocs to non-ICF
//                      sections.

static std::string
get_section_contents(bool first_iteration,
                     const Section_id& secn,
                     unsigned int section_num,
                     unsigned int* num_tracked_relocs,
                     Symbol_table* symtab,
                     const std::vector<unsigned int>& kept_section_id,
                     std::vector<std::string>* section_contents)
{
  // Lock the object so we can read from it.  This is only called
  // single-threaded from queue_middle_tasks, so it is OK to lock.
  // Unfortunately we have no way to pass in a Task token.
  const Task* dummy_task = reinterpret_cast<const Task*>(-1);
  Task_lock_obj<Object> tl(dummy_task, secn.first);

  section_size_type plen;
  const unsigned char* contents = NULL;
  if (first_iteration)
    contents = secn.first->section_contents(secn.second, &plen, false);

  // The buffer to hold all the contents including relocs.  A checksum
  // is then computed on this buffer.
  std::string buffer;
  std::string icf_reloc_buffer;

  if (num_tracked_relocs)
    *num_tracked_relocs = 0;

  Icf::Reloc_info_list& reloc_info_list = 
    symtab->icf()->reloc_info_list();

  Icf::Reloc_info_list::iterator it_reloc_info_list =
    reloc_info_list.find(secn);

  buffer.clear();
  icf_reloc_buffer.clear();

  // Process relocs and put them into the buffer.

  if (it_reloc_info_list != reloc_info_list.end())
    {
      Icf::Sections_reachable_info v =
        (it_reloc_info_list->second).section_info;
      // Stores the information of the symbol pointed to by the reloc.
      Icf::Symbol_info s = (it_reloc_info_list->second).symbol_info;
      // Stores the addend and the symbol value.
      Icf::Addend_info a = (it_reloc_info_list->second).addend_info;
      // Stores the offset of the reloc.
      Icf::Offset_info o = (it_reloc_info_list->second).offset_info;
      Icf::Reloc_addend_size_info reloc_addend_size_info =
        (it_reloc_info_list->second).reloc_addend_size_info;
      Icf::Sections_reachable_info::iterator it_v = v.begin();
      Icf::Symbol_info::iterator it_s = s.begin();
      Icf::Addend_info::iterator it_a = a.begin();
      Icf::Offset_info::iterator it_o = o.begin();
      Icf::Reloc_addend_size_info::iterator it_addend_size =
        reloc_addend_size_info.begin();

      for (; it_v != v.end(); ++it_v, ++it_s, ++it_a, ++it_o, ++it_addend_size)
        {
	  if (first_iteration
	      && it_v->first != NULL)
	    {
	      Symbol_location loc;
	      loc.object = it_v->first;
	      loc.shndx = it_v->second;
	      loc.offset = convert_types<off_t, long long>(it_a->first
							   + it_a->second);
	      // Look through function descriptors
	      parameters->target().function_location(&loc);
	      if (loc.shndx != it_v->second)
		{
		  it_v->second = loc.shndx;
		  // Modify symvalue/addend to the code entry.
		  it_a->first = loc.offset;
		  it_a->second = 0;
		}
	    }

          // ADDEND_STR stores the symbol value and addend and offset,
          // each at most 16 hex digits long.  it_a points to a pair
          // where first is the symbol value and second is the
          // addend.
          char addend_str[50];

	  // It would be nice if we could use format macros in inttypes.h
	  // here but there are not in ISO/IEC C++ 1998.
          snprintf(addend_str, sizeof(addend_str), "%llx %llx %llux",
                   static_cast<long long>((*it_a).first),
		   static_cast<long long>((*it_a).second),
		   static_cast<unsigned long long>(*it_o));

	  // If the symbol pointed to by the reloc is not in an ordinary
	  // section or if the symbol type is not FROM_OBJECT, then the
	  // object is NULL.
	  if (it_v->first == NULL)
            {
	      if (first_iteration)
                {
		  // If the symbol name is available, use it.
                  if ((*it_s) != NULL)
                      buffer.append((*it_s)->name());
                  // Append the addend.
                  buffer.append(addend_str);
                  buffer.append("@@");
		}
	      continue;
	    }

          Section_id reloc_secn(it_v->first, it_v->second);

          // If this reloc turns back and points to the same section,
          // like a recursive call, use a special symbol to mark this.
          if (reloc_secn.first == secn.first
              && reloc_secn.second == secn.second)
            {
              if (first_iteration)
                {
                  buffer.append("R");
                  buffer.append(addend_str);
                  buffer.append("@@");
                }
              continue;
            }
          Icf::Uniq_secn_id_map& section_id_map =
            symtab->icf()->section_to_int_map();
          Icf::Uniq_secn_id_map::iterator section_id_map_it =
            section_id_map.find(reloc_secn);
          bool is_sym_preemptible = (*it_s != NULL
				     && !(*it_s)->is_from_dynobj()
				     && !(*it_s)->is_undefined()
				     && (*it_s)->is_preemptible());
          if (!is_sym_preemptible
              && section_id_map_it != section_id_map.end())
            {
              // This is a reloc to a section that might be folded.
              if (num_tracked_relocs)
                (*num_tracked_relocs)++;

              char kept_section_str[10];
              unsigned int secn_id = section_id_map_it->second;
              snprintf(kept_section_str, sizeof(kept_section_str), "%u",
                       kept_section_id[secn_id]);
              if (first_iteration)
                {
                  buffer.append("ICF_R");
                  buffer.append(addend_str);
                }
              icf_reloc_buffer.append(kept_section_str);
              // Append the addend.
              icf_reloc_buffer.append(addend_str);
              icf_reloc_buffer.append("@@");
            }
          else
            {
              // This is a reloc to a section that cannot be folded.
              // Process it only in the first iteration.
              if (!first_iteration)
                continue;

              uint64_t secn_flags = (it_v->first)->section_flags(it_v->second);
              // This reloc points to a merge section.  Hash the
              // contents of this section.
              if ((secn_flags & elfcpp::SHF_MERGE) != 0
		  && parameters->target().can_icf_inline_merge_sections())
                {
                  uint64_t entsize =
                    (it_v->first)->section_entsize(it_v->second);
		  long long offset = it_a->first;

                  unsigned long long addend = it_a->second;
                  // Ignoring the addend when it is a negative value.  See the 
                  // comments in Merged_symbol_value::Value in object.h.
                  if (addend < 0xffffff00)
                    offset = offset + addend;

		  // For SHT_REL relocation sections, the addend is stored in the
		  // text section at the relocation offset.
		  uint64_t reloc_addend_value = 0;
                  const unsigned char* reloc_addend_ptr =
		    contents + static_cast<unsigned long long>(*it_o);
		  switch(*it_addend_size)
		    {
		      case 0:
		        {
                          break;
                        }
                      case 1:
                        {
                          reloc_addend_value =
                            read_from_pointer<8>(reloc_addend_ptr);
			  break;
                        }
                      case 2:
                        {
                          reloc_addend_value =
                            read_from_pointer<16>(reloc_addend_ptr);
			  break;
                        }
                      case 4:
                        {
                          reloc_addend_value =
                            read_from_pointer<32>(reloc_addend_ptr);
			  break;
                        }
                      case 8:
                        {
                          reloc_addend_value =
                            read_from_pointer<64>(reloc_addend_ptr);
			  break;
                        }
		      default:
		        gold_unreachable();
		    }
		  offset = offset + reloc_addend_value;

                  section_size_type secn_len;
                  const unsigned char* str_contents =
                  (it_v->first)->section_contents(it_v->second,
                                                  &secn_len,
                                                  false) + offset;
                  if ((secn_flags & elfcpp::SHF_STRINGS) != 0)
                    {
                      // String merge section.
                      const char* str_char =
                        reinterpret_cast<const char*>(str_contents);
                      switch(entsize)
                        {
                        case 1:
                          {
                            buffer.append(str_char);
                            break;
                          }
                        case 2:
                          {
                            const uint16_t* ptr_16 =
                              reinterpret_cast<const uint16_t*>(str_char);
                            unsigned int strlen_16 = 0;
                            // Find the NULL character.
                            while(*(ptr_16 + strlen_16) != 0)
                                strlen_16++;
                            buffer.append(str_char, strlen_16 * 2);
                          }
                          break;
                        case 4:
                          {
                            const uint32_t* ptr_32 =
                              reinterpret_cast<const uint32_t*>(str_char);
                            unsigned int strlen_32 = 0;
                            // Find the NULL character.
                            while(*(ptr_32 + strlen_32) != 0)
                                strlen_32++;
                            buffer.append(str_char, strlen_32 * 4);
                          }
                          break;
                        default:
                          gold_unreachable();
                        }
                    }
                  else
                    {
                      // Use the entsize to determine the length.
                      buffer.append(reinterpret_cast<const 
                                                     char*>(str_contents),
                                    entsize);
                    }
		  buffer.append("@@");
                }
              else if ((*it_s) != NULL)
                {
                  // If symbol name is available use that.
                  buffer.append((*it_s)->name());
                  // Append the addend.
                  buffer.append(addend_str);
                  buffer.append("@@");
                }
              else
                {
                  // Symbol name is not available, like for a local symbol,
                  // use object and section id.
                  buffer.append(it_v->first->name());
                  char secn_id[10];
                  snprintf(secn_id, sizeof(secn_id), "%u",it_v->second);
                  buffer.append(secn_id);
                  // Append the addend.
                  buffer.append(addend_str);
                  buffer.append("@@");
                }
            }
        }
    }

  if (first_iteration)
    {
      buffer.append("Contents = ");
      buffer.append(reinterpret_cast<const char*>(contents), plen);
      // Store the section contents that dont change to avoid recomputing
      // during the next call to this function.
      (*section_contents)[section_num] = buffer;
    }
  else
    {
      gold_assert(buffer.empty());
      // Reuse the contents computed in the previous iteration.
      buffer.append((*section_contents)[section_num]);
    }

  buffer.append(icf_reloc_buffer);
  return buffer;
}

// This function computes a checksum on each section to detect and form
// groups of identical sections.  The first iteration does this for all 
// sections.
// Further iterations do this only for the kept sections from each group to
// determine if larger groups of identical sections could be formed.  The
// first section in each group is the kept section for that group.
//
// CRC32 is the checksumming algorithm and can have collisions.  That is,
// two sections with different contents can have the same checksum. Hence,
// a multimap is used to maintain more than one group of checksum
// identical sections.  A section is added to a group only after its
// contents are explicitly compared with the kept section of the group.
//
// Parameters  :
// ITERATION_NUM           : Invocation instance of this function.
// NUM_TRACKED_RELOCS : Vector reference to store the number of relocs
//                      to ICF sections.
// KEPT_SECTION_ID    : Vector which maps folded sections to kept sections.
// ID_SECTION         : Vector mapping a section to an unique integer.
// IS_SECN_OR_GROUP_UNIQUE : To check if a section or a group of identical
//                            sections is already known to be unique.
// SECTION_CONTENTS   : Store the section's text and relocs to non-ICF
//                      sections.

static bool
match_sections(unsigned int iteration_num,
               Symbol_table* symtab,
               std::vector<unsigned int>* num_tracked_relocs,
               std::vector<unsigned int>* kept_section_id,
               const std::vector<Section_id>& id_section,
               std::vector<bool>* is_secn_or_group_unique,
               std::vector<std::string>* section_contents)
{
  Unordered_multimap<uint32_t, unsigned int> section_cksum;
  std::pair<Unordered_multimap<uint32_t, unsigned int>::iterator,
            Unordered_multimap<uint32_t, unsigned int>::iterator> key_range;
  bool converged = true;

  if (iteration_num == 1)
    preprocess_for_unique_sections(id_section,
                                   is_secn_or_group_unique,
                                   NULL);
  else
    preprocess_for_unique_sections(id_section,
                                   is_secn_or_group_unique,
                                   section_contents);

  std::vector<std::string> full_section_contents;

  for (unsigned int i = 0; i < id_section.size(); i++)
    {
      full_section_contents.push_back("");
      if ((*is_secn_or_group_unique)[i])
        continue;

      Section_id secn = id_section[i];
      std::string this_secn_contents;
      uint32_t cksum;
      if (iteration_num == 1)
        {
          unsigned int num_relocs = 0;
          this_secn_contents = get_section_contents(true, secn, i, &num_relocs,
                                                    symtab, (*kept_section_id),
                                                    section_contents);
          (*num_tracked_relocs)[i] = num_relocs;
        }
      else
        {
          if ((*kept_section_id)[i] != i)
            {
              // This section is already folded into something.  See
              // if it should point to a different kept section.
              unsigned int kept_section = (*kept_section_id)[i];
              if (kept_section != (*kept_section_id)[kept_section])
                {
                  (*kept_section_id)[i] = (*kept_section_id)[kept_section];
                }
              continue;
            }
          this_secn_contents = get_section_contents(false, secn, i, NULL,
                                                    symtab, (*kept_section_id),
                                                    section_contents);
        }

      const unsigned char* this_secn_contents_array =
            reinterpret_cast<const unsigned char*>(this_secn_contents.c_str());
      cksum = xcrc32(this_secn_contents_array, this_secn_contents.length(),
                     0xffffffff);
      size_t count = section_cksum.count(cksum);

      if (count == 0)
        {
          // Start a group with this cksum.
          section_cksum.insert(std::make_pair(cksum, i));
          full_section_contents[i] = this_secn_contents;
        }
      else
        {
          key_range = section_cksum.equal_range(cksum);
          Unordered_multimap<uint32_t, unsigned int>::iterator it;
          // Search all the groups with this cksum for a match.
          for (it = key_range.first; it != key_range.second; ++it)
            {
              unsigned int kept_section = it->second;
              if (full_section_contents[kept_section].length()
                  != this_secn_contents.length())
                  continue;
              if (memcmp(full_section_contents[kept_section].c_str(),
                         this_secn_contents.c_str(),
                         this_secn_contents.length()) != 0)
                  continue;
              (*kept_section_id)[i] = kept_section;
              converged = false;
              break;
            }
          if (it == key_range.second)
            {
              // Create a new group for this cksum.
              section_cksum.insert(std::make_pair(cksum, i));
              full_section_contents[i] = this_secn_contents;
            }
        }
      // If there are no relocs to foldable sections do not process
      // this section any further.
      if (iteration_num == 1 && (*num_tracked_relocs)[i] == 0)
        (*is_secn_or_group_unique)[i] = true;
    }

  return converged;
}

// During safe icf (--icf=safe), only fold functions that are ctors or dtors.
// This function returns true if the section name is that of a ctor or a dtor.

static bool
is_function_ctor_or_dtor(const std::string& section_name)
{
  const char* mangled_func_name = strrchr(section_name.c_str(), '.');
  gold_assert(mangled_func_name != NULL);
  if ((is_prefix_of("._ZN", mangled_func_name)
       || is_prefix_of("._ZZ", mangled_func_name))
      && (is_gnu_v3_mangled_ctor(mangled_func_name + 1)
          || is_gnu_v3_mangled_dtor(mangled_func_name + 1)))
    {
      return true;
    }
  return false;
}

// This is the main ICF function called in gold.cc.  This does the
// initialization and calls match_sections repeatedly (twice by default)
// which computes the crc checksums and detects identical functions.

void
Icf::find_identical_sections(const Input_objects* input_objects,
                             Symbol_table* symtab)
{
  unsigned int section_num = 0;
  std::vector<unsigned int> num_tracked_relocs;
  std::vector<bool> is_secn_or_group_unique;
  std::vector<std::string> section_contents;
  const Target& target = parameters->target();

  // Decide which sections are possible candidates first.

  for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
       p != input_objects->relobj_end();
       ++p)
    {
      // Lock the object so we can read from it.  This is only called
      // single-threaded from queue_middle_tasks, so it is OK to lock.
      // Unfortunately we have no way to pass in a Task token.
      const Task* dummy_task = reinterpret_cast<const Task*>(-1);
      Task_lock_obj<Object> tl(dummy_task, *p);

      for (unsigned int i = 0;i < (*p)->shnum(); ++i)
        {
	  const std::string section_name = (*p)->section_name(i);
          if (!is_section_foldable_candidate(section_name))
            continue;
          if (!(*p)->is_section_included(i))
            continue;
          if (parameters->options().gc_sections()
              && symtab->gc()->is_section_garbage(*p, i))
              continue;
	  // With --icf=safe, check if the mangled function name is a ctor
	  // or a dtor.  The mangled function name can be obtained from the
	  // section name by stripping the section prefix.
	  if (parameters->options().icf_safe_folding()
              && !is_function_ctor_or_dtor(section_name)
	      && (!target.can_check_for_function_pointers()
                  || section_has_function_pointers(*p, i)))
            {
	      continue;
            }
          this->id_section_.push_back(Section_id(*p, i));
          this->section_id_[Section_id(*p, i)] = section_num;
          this->kept_section_id_.push_back(section_num);
          num_tracked_relocs.push_back(0);
          is_secn_or_group_unique.push_back(false);
          section_contents.push_back("");
          section_num++;
        }
    }

  unsigned int num_iterations = 0;

  // Default number of iterations to run ICF is 2.
  unsigned int max_iterations = (parameters->options().icf_iterations() > 0)
                            ? parameters->options().icf_iterations()
                            : 2;

  bool converged = false;

  while (!converged && (num_iterations < max_iterations))
    {
      num_iterations++;
      converged = match_sections(num_iterations, symtab,
                                 &num_tracked_relocs, &this->kept_section_id_,
                                 this->id_section_, &is_secn_or_group_unique,
                                 &section_contents);
    }

  if (parameters->options().print_icf_sections())
    {
      if (converged)
        gold_info(_("%s: ICF Converged after %u iteration(s)"),
                  program_name, num_iterations);
      else
        gold_info(_("%s: ICF stopped after %u iteration(s)"),
                  program_name, num_iterations);
    }

  // Unfold --keep-unique symbols.
  for (options::String_set::const_iterator p =
	 parameters->options().keep_unique_begin();
       p != parameters->options().keep_unique_end();
       ++p)
    {
      const char* name = p->c_str();
      Symbol* sym = symtab->lookup(name);
      if (sym == NULL)
	{
	  gold_warning(_("Could not find symbol %s to unfold\n"), name);
	}
      else if (sym->source() == Symbol::FROM_OBJECT 
               && !sym->object()->is_dynamic())
        {
          Object* obj = sym->object();
          bool is_ordinary;
          unsigned int shndx = sym->shndx(&is_ordinary);
          if (is_ordinary)
            {
	      this->unfold_section(obj, shndx);
            }
        }

    }

  this->icf_ready();
}

// Unfolds the section denoted by OBJ and SHNDX if folded.

void
Icf::unfold_section(Object* obj, unsigned int shndx)
{
  Section_id secn(obj, shndx);
  Uniq_secn_id_map::iterator it = this->section_id_.find(secn);
  if (it == this->section_id_.end())
    return;
  unsigned int section_num = it->second;
  unsigned int kept_section_id = this->kept_section_id_[section_num];
  if (kept_section_id != section_num)
    this->kept_section_id_[section_num] = section_num;
}

// This function determines if the section corresponding to the
// given object and index is folded based on if the kept section
// is different from this section.

bool
Icf::is_section_folded(Object* obj, unsigned int shndx)
{
  Section_id secn(obj, shndx);
  Uniq_secn_id_map::iterator it = this->section_id_.find(secn);
  if (it == this->section_id_.end())
    return false;
  unsigned int section_num = it->second;
  unsigned int kept_section_id = this->kept_section_id_[section_num];
  return kept_section_id != section_num;
}

// This function returns the folded section for the given section.

Section_id
Icf::get_folded_section(Object* dup_obj, unsigned int dup_shndx)
{
  Section_id dup_secn(dup_obj, dup_shndx);
  Uniq_secn_id_map::iterator it = this->section_id_.find(dup_secn);
  gold_assert(it != this->section_id_.end());
  unsigned int section_num = it->second;
  unsigned int kept_section_id = this->kept_section_id_[section_num];
  Section_id folded_section = this->id_section_[kept_section_id];
  return folded_section;
}

} // End of namespace gold.
@


1.20
log
@	* target.h (Target::can_check_for_function_pointers): Rewrite.
	Make non-virtual.
	(Target::can_icf_inline_merge_sections): Likewise.
	(Target::section_may_have_icf_unsafe_poineters): Likewise.
	(Target::Target_info): Add can_icf_inline_merge_sections field.
	(Target::do_can_check_for_function_pointers): New virtual
	function.
	(Target::do_section_may_have_icf_unsafe_pointers): Likewise.
	* arm.cc (Target_arm::do_can_check_for_function_pointers): Rename
	from can_check_for_function_pointers, move in file.
	(Target_arm::do_section_may_have_icf_unsafe_pointers): Rename from
	section_may_have_icf_unsafe_poineters, move in file.
	(Target_arm::arm_info): Initialize can_icf_inline_merge_sections.
	* i386.cc (Target_i386::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_i386::can_icf_inline_merge_sections): Remove.
	(Target_i386::i386_info): Initialize
	can_icf_inline_merge_sections.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Initialize can_icf_inline_merge_sections.
	* sparc.cc (Target_sparc::sparc_info) [both version]: Likewise.
	* x86_64.cc (Target_x86_64::do_can_check_for_function_pointers):
	Rename from can_check_for_function_pointers, move in file.
	(Target_x86_64::can_icf_inline_merge_sections): Remove.
	(Target_x86_64::x86_64_info): Initialize
	can_icf_inline_merge_sections.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Likewise.
	* icf.cc (get_section_contents): Correct formatting.
@
text
@d291 19
@


1.19
log
@2011-02-02  Sriraman Tallam  <tmsriram@@google.com>

	* icf.h (is_section_foldable_candidate): Change type of parameter
        to std::string.
	* icf.cc (Icf::find_identical_sections): Change type of local variable
        section_name to be std::string.
	(is_function_ctor_or_dtor): Change type of parameter to std::string.
@
text
@d3 1
a3 1
// Copyright 2009, 2010 Free Software Foundation, Inc.
d376 1
a376 1
		  && parameters->target().can_icf_inline_merge_sections ())
@


1.18
log
@2011-01-25  Doug Kwan  <dougkwan@@google.com>

	* gold/icf.cc (get_section_contents): Always lock section's object.
@
text
@d655 1
a655 2
// This function returns true if the mangled function name is a ctor or a
// dtor.
d658 1
a658 1
is_function_ctor_or_dtor(const char* mangled_func_name)
d660 6
a665 4
  if ((is_prefix_of("_ZN", mangled_func_name)
       || is_prefix_of("_ZZ", mangled_func_name))
      && (is_gnu_v3_mangled_ctor(mangled_func_name)
          || is_gnu_v3_mangled_dtor(mangled_func_name)))
d700 1
a700 1
	  const char* section_name = (*p)->section_name(i).c_str();
a707 2
	  const char* mangled_func_name = strrchr(section_name, '.');
	  gold_assert(mangled_func_name != NULL);
d712 1
a712 1
              && !is_function_ctor_or_dtor(mangled_func_name + 1)
@


1.17
log
@Fix typos in gold.

gold/:
	* dwarf_reader.cc: Remove outdated comment.
	* gold-threads.cc: Fix typo in error message.
	* archive.cc: Fix typos in comments.
	* archive.h: Likewise.
	* arm-reloc-property.cc: Likewise.
	* arm-reloc-property.h: Likewise.
	* arm-reloc.def: Likewise.
	* arm.cc: Likewise.
	* attributes.h: Likewise.
	* cref.cc: Likewise.
	* ehframe.cc: Likewise.
	* fileread.h: Likewise.
	* gold.h: Likewise.
	* i386.cc: Likewise.
	* icf.cc: Likewise.
	* incremental.h: Likewise.
	* int_encoding.cc: Likewise.
	* layout.h: Likewise.
	* main.cc: Likewise.
	* merge.h: Likewise.
	* object.cc: Likewise.
	* object.h: Likewise.
	* options.cc: Likewise.
	* readsyms.cc: Likewise.
	* reduced_debug_output.cc: Likewise.
	* reloc.cc: Likewise.
	* script-sections.cc: Likewise.
	* sparc.cc: Likewise.
	* symtab.h: Likewise.
	* target-reloc.h: Likewise.
	* target.cc: Likewise.
	* target.h: Likewise.
	* timer.cc: Likewise.
	* timer.h: Likewise.
	* x86_64.cc: Likewise.
@
text
@d240 6
a247 1

d249 1
a249 10
    {
      // Lock the object so we can read from it.  This is only called
      // single-threaded from queue_middle_tasks, so it is OK to lock.
      // Unfortunately we have no way to pass in a Task token.
      const Task* dummy_task = reinterpret_cast<const Task*>(-1);
      Task_lock_obj<Object> tl(dummy_task, secn.first);
      contents = secn.first->section_contents(secn.second,
                                              &plen,
                                              false);
    }
a371 6
              // Lock the object so we can read from it.  This is only called
              // single-threaded from queue_middle_tasks, so it is OK to lock.
              // Unfortunately we have no way to pass in a Task token.
              const Task* dummy_task = reinterpret_cast<const Task*>(-1);
              Task_lock_obj<Object> tl(dummy_task, it_v->first);

@


1.16
log
@	PR gold/10708
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Hold a lock on the
	object when reading from the file.
	* gold.cc (queue_middle_tasks): Hold a lock on the object when doing
	second layout pass.
	* icf.cc (preprocess_for_unique_sections): Hold a lock on the object
	when reading section contents.
	(get_section_contents): Likewise.
	(icf::find_identical_sections): Likewise.
	* mapfile.cc (Mapfile::print_discarded_sections): Hold a lock on the
	object when reading from the file.
	* plugin.cc (Plugin_manager::layout_deferred_objects): Hold a lock on
	the object when doing deferred section layout.
@
text
@d296 1
a296 1
          // each atmost 16 hex digits long.  it_a points to a pair
d553 1
a553 1
//                            sectionsis already known to be unique.
@


1.15
log
@2010-09-28  Sriraman Tallam  <tmsriram@@google.com>

	* target.h (Target::can_icf_inline_merge_sections): New virtual
	function.
	* x86_64.cc (Target__x86_64::can_icf_inline_merge_sections): New
	virtual function.
	* i386.cc (Target_i386::can_icf_inline_merge_sections): New
	virtual function.
	* icf.cc (get_section_contents): Inline merge sections only when
	target allows it.
@
text
@d185 5
d245 5
d376 6
d701 6
@


1.15.2.1
log
@	* icf.h (is_section_foldable_candidate): Change type of parameter
        to std::string.
	* icf.cc (Icf::find_identical_sections): Change type of local variable
        section_name to be std::string.
	(is_function_ctor_or_dtor): Change type of parameter to std::string.
@
text
@d649 2
a650 1
// This function returns true if the section name is that of a ctor or a dtor.
d653 1
a653 1
is_function_ctor_or_dtor(const std::string& section_name)
d655 4
a658 6
  const char* mangled_func_name = strrchr(section_name.c_str(), '.');
  gold_assert(mangled_func_name != NULL);
  if ((is_prefix_of("._ZN", mangled_func_name)
       || is_prefix_of("._ZZ", mangled_func_name))
      && (is_gnu_v3_mangled_ctor(mangled_func_name + 1)
          || is_gnu_v3_mangled_dtor(mangled_func_name + 1)))
d687 1
a687 1
	  const std::string section_name = (*p)->section_name(i);
d695 2
d701 1
a701 1
              && !is_function_ctor_or_dtor(section_name)
@


1.15.2.2
log
@	Backport from mainline:
	2010-11-05  Cary Coutant  <ccoutant@@google.com>
	PR gold/10708
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Hold a lock on the
	object when reading from the file.
	* gold.cc (queue_middle_tasks): Hold a lock on the object when doing
	second layout pass.
	* icf.cc (preprocess_for_unique_sections): Hold a lock on the object
	when reading section contents.
	(get_section_contents): Likewise.
	(icf::find_identical_sections): Likewise.
	* mapfile.cc (Mapfile::print_discarded_sections): Hold a lock on the
	object when reading from the file.
	* plugin.cc (Plugin_manager::layout_deferred_objects): Hold a lock on
	the object when doing deferred section layout.
@
text
@a184 5
          // Lock the object so we can read from it.  This is only called
          // single-threaded from queue_middle_tasks, so it is OK to lock.
          // Unfortunately we have no way to pass in a Task token.
          const Task* dummy_task = reinterpret_cast<const Task*>(-1);
          Task_lock_obj<Object> tl(dummy_task, secn.first);
a239 5
      // Lock the object so we can read from it.  This is only called
      // single-threaded from queue_middle_tasks, so it is OK to lock.
      // Unfortunately we have no way to pass in a Task token.
      const Task* dummy_task = reinterpret_cast<const Task*>(-1);
      Task_lock_obj<Object> tl(dummy_task, secn.first);
a365 6
              // Lock the object so we can read from it.  This is only called
              // single-threaded from queue_middle_tasks, so it is OK to lock.
              // Unfortunately we have no way to pass in a Task token.
              const Task* dummy_task = reinterpret_cast<const Task*>(-1);
              Task_lock_obj<Object> tl(dummy_task, it_v->first);

a685 6
      // Lock the object so we can read from it.  This is only called
      // single-threaded from queue_middle_tasks, so it is OK to lock.
      // Unfortunately we have no way to pass in a Task token.
      const Task* dummy_task = reinterpret_cast<const Task*>(-1);
      Task_lock_obj<Object> tl(dummy_task, *p);

@


1.14
log
@	* arm.cc (Target_arm<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* i386.cc (Target_i386<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* x86_64.cc (Target_x86_64<big_endian>::gc_process_relocs): Add template
	parameter to the call to gold::gc_process_relocs.
	* powerpc.cc (Target_powerpc<big_endian>::gc_process_relocs): Add
	template parameter to the call to gold::gc_process_relocs.
	* sparc.cc (Target_sparc<big_endian>::gc_process_relocs): Add template
	paramter to the call to gold::gc_process_relocs.
	* gc.h (get_embedded_addend_size): New function.
	(gc_process_relocs): Save the size of the reloc for use by ICF.
	* icf.cc (get_section_contents): Get the addend from the text section
	for SHT_REL relocation sections.
	* icf.h (Icf::Reloc_addend_size_info): New typedef.
	(Icf::Reloc_info): Add new member reloc_addend_size_info.
	* int_encoding.h (read_from_pointer): New overloaded function.
	* testsuite/Makefile.am (icf_sht_rel_addend_test): New test.
	* testsuite/icf_sht_rel_addend_test.sh: New file.
	* testsuite/icf_sht_rel_addend_test_1.cc: New file.
	* testsuite/icf_sht_rel_addend_test_2.cc: New file.
@
text
@d369 2
a370 1
              if ((secn_flags & elfcpp::SHF_MERGE) != 0)
@


1.13
log
@2010-04-23  Sriraman Tallam  <tmsriram@@google.com>

	* gc.h (gc_process_relocs): Pass information on relocs pointing to
	sections that are not ordinary to icf.
	* icf.cc (get_section_contents): Handle relocation pointing to section
	with no object or shndx information.
	* testsuite/Makefile.am: Remove icf_virtual_function_folding_test.sh
	* testsuite/Makefile.in: Regenerate.
	* testsuite/icf_virtual_function_folding_test.cc: Remove printf.
	* testsuite/icf_virtual_function_folding_test.sh: Delete file.
@
text
@d148 2
d274 2
d280 2
d283 1
a283 1
      for (; it_v != v.end(); ++it_v, ++it_s, ++it_a, ++it_o)
d381 40
@


1.12
log
@2010-04-18  Sriraman Tallam  <tmsriram@@google.com>

	* icf.cc (get_section_contents): Check for preemptible functions.
	Ignore addend when appropriate.
	* symtab.cc (should_add_dynsym_entry): Add new parameter.  Check for
	section folded.
	(add_from_relobj): Check for section folded.
	(set_dynsym_indexes): Fix call to should_add_dynsym_entry.
	* symtab.h (should_add_dynsym_entry): Add new parameter.
	* target-reloc.h (scan_relocs): Check for section folded.
	* x86_64.cc (Target_x86_64::Scan::possible_function_pointer_reloc):
	Check reloc types for function pointers in shared objects.
	* testsuite/Makefile.am (icf_virtual_function_folding_test): New test
	case.
	(icf_preemptible_functions_test): New test case.
	(icf_string_merge_test): New test case.
	* testsuite.Makefile.in: Regenerate.
	* testsuite/icf_safe_so_test.sh: Change to not fold foo_glob and
	bar_glob.  Refactor code.
	* testsuite/icf_preemptible_functions_test.cc: New file.
	* testsuite/icf_preemptible_functions_test.sh: New file.
	* testsuite/icf_string_merge_test.cc: New file.
	* testsuite/icf_string_merge_test.sh: New file.
	* testsuite/icf_virtual_function_folding_test.cc: New file.
	* testsuite/icf_virtual_function_folding_test.sh: New file.
@
text
@d266 1
d268 1
d270 1
d291 18
d430 1
a430 2
                  const char *sym_name = (*it_s)->name();
                  buffer.append(sym_name);
@


1.11
log
@2010-03-09  Sriraman Tallam  <tmsriram@@google.com>

	* icf.cc (get_section_contents): Add '@@' marker after processing the
	merge reloc.
@
text
@d307 6
a312 1
          if (section_id_map_it != section_id_map.end())
d346 8
a353 1
                  long long offset = it_a->first + it_a->second;
@


1.10
log
@2010-02-22  Doug Kwan  <dougkwan@@google.com>

	* gold-threads.h (Once::~Once): Explicitly define virtual destructor.
	* icf.cc (get_section_contents): Cast snprintf arguments to long long
	types to avoid warnings due to different uint64_t implementations
	on different hosts.
@
text
@d392 1
@


1.9
log
@2010-02-20  Sriraman Tallam  <tmsriram@@google.com>

	* gc.h (gc_process_relocs): Change vectors to point to the new list.
	Add reloc offset information.
	* icf.cc (get_section_contents): Change iterators to point to the new
	vectors. Add reloc offset information to the contents.
	* icf.h (Icf::Sections_reachable_info): New typedef.
	(Icf::Sections_reachable_list): New typedef.
	(Icf::Offset_info): New typedef.
	(Icf::Reloc_info): New struct typedef.
	(Icf::Reloc_info_list): New typedef.
	(Icf::symbol_reloc_list): Delete method.
	(Icf::addend_reloc_list): Delete method.
	(Icf::section_reloc_list): Delete method.
	(Icf::reloc_info_list): New method.
	(Icf::reloc_info_list_): New member.
@
text
@d281 7
a287 2
          snprintf(addend_str, sizeof(addend_str), "%llx %llx %lux",
                   (*it_a).first, (*it_a).second, (*it_o));
@


1.8
log
@2010-02-12  Sriraman Tallam  <tmsriram@@google.com>

	* arm.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* sparc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* powerpc.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* i386.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	* x86_64.cc (Scan::local_reloc_may_be_function_pointer): New function.
	(Scan::global_reloc_may_be_function_pointer): New function.
	(Scan::possible_function_pointer_reloc): New function.
	(Target_x86_64::can_check_for_function_pointers): New function.
	* gc.h (gc_process_relocs): Scan relocation types to determine if
	function pointers were taken for targets that support it.
	* icf.cc (Icf::find_identical_sections): Include functions for
	folding in safe ICF whose pointer is not taken.
	* icf.h (Secn_fptr_taken_set): New typedef.
	(fptr_section_id_): New member.
	(section_has_function_pointers): New function.
	(set_section_has_function_pointers): New function.
	(check_section_for_function_pointers): New function.
	* options.h: Fix comment for safe ICF option.
	* target.h (can_check_for_function_pointers): New function.
	* testsuite/Makefile.am: Add icf_safe_so_test test case.
	Modify icf_safe_test for X86-64.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/icf_safe_so_test.cc: New file.
	* testsuite/icf_safe_so_test.sh: New file.
	* testsuite/icf_safe_test.cc (kept_func_3): New function.
	(main): Change to take pointer to function kept_func_3.
	* testsuite/icf_safe_test.sh (arch_specific_safe_fold): Check if safe
	folding is done correctly for X86-64.
@
text
@d251 5
a255 7
  Icf::Section_list& seclist = symtab->icf()->section_reloc_list();
  Icf::Symbol_list& symlist = symtab->icf()->symbol_reloc_list();
  Icf::Addend_list& addendlist = symtab->icf()->addend_reloc_list();

  Icf::Section_list::iterator it_seclist = seclist.find(secn);
  Icf::Symbol_list::iterator it_symlist = symlist.find(secn);
  Icf::Addend_list::iterator it_addendlist = addendlist.find(secn);
d262 1
a262 1
  if (it_seclist != seclist.end())
d264 6
a269 6
      gold_assert(it_symlist != symlist.end());
      gold_assert(it_addendlist != addendlist.end());
      Icf::Sections_reachable_list v = it_seclist->second;
      Icf::Symbol_info s = it_symlist->second;
      Icf::Addend_info a = it_addendlist->second;
      Icf::Sections_reachable_list::iterator it_v = v.begin();
d272 1
d274 1
a274 1
      for (; it_v != v.end(); ++it_v, ++it_s, ++it_a)
d276 2
a277 2
          // ADDEND_STR stores the symbol value and addend, each
          // atmost 16 hex digits long.  it_v points to a pair
d280 3
a282 3
          char addend_str[34];
          snprintf(addend_str, sizeof(addend_str), "%llx %llx",
                   (*it_a).first, (*it_a).second);
@


1.7
log
@	* gc.h (gc_process_relocs): Call is_section_foldable_candidate to
	check for .text or .gnu.linkonce.t sections.
	* icf.cc (Icf::find_identical_sections): Ditto.
	Change the detection for mangled function name within the section
	name.
	* icf.h (is_section_foldable_candidate): New function.
@
text
@d104 30
d593 1
d611 2
a615 2
	  const char* mangled_func_name = strrchr(section_name, '.');
	  gold_assert(mangled_func_name != NULL);
d617 6
a622 2
	      && !is_function_ctor_or_dtor(mangled_func_name + 1))
	    continue;
@


1.6
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d3 1
a3 1
// Copyright 2009 Free Software Foundation, Inc.
d26 1
a26 1
// is as follows.  A checksum is computed on each .text section using
d37 2
a38 2
// relocations pointing to different .text sections can be identical if
// the corresponding .text sections to which their relocations point to
d105 1
a105 1
// How to run  : --icf
d573 1
a573 2
          // Only looking to fold functions, so just look at .text sections.
          if (!is_prefix_of(".text.", section_name))
d580 5
a584 1
	  // With --icf=safe, check if mangled name is a ctor or a dtor.
d586 1
a586 1
	      && !is_function_ctor_or_dtor(section_name + 6))
@


1.5
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d560 1
a560 1
  std::vector<unsigned int> num_tracked_rels;
d588 1
a588 1
          num_tracked_rels.push_back(0);
d608 1
a608 1
                                 &num_tracked_rels, &this->kept_section_id_,
@


1.4
log
@	* gc.h (gc_process_relocs): Check if icf is enabled using new
	function.
	* gold.cc (queue_initial_tasks): Likewise.
	(queue_middle_tasks): Likewise.
	* object.cc (do_layout): Likewise.
	* symtab.cc (is_section_folded): Likewise.
	* main.cc (main): Likewise.
	* reloc.cc (Read_relocs::run): Likewise.
	(Sized_relobj::do_scan_relocs): Likewise.
	* icf.cc (is_function_ctor_or_dtor): New function.
	(Icf::find_identical_sections): Check if function is ctor or dtor when
	safe icf is chosen.
	* options.h (General_options::icf): Change option to be an enum.
	(Icf_status): New enum.
	(icf_enabled): New method.
	(icf_safe_folding): New method.
	(set_icf_status): New method.
	(icf_status_): New variable.
	* (options.cc) (General_options::finalize): Set icf_status_.
	* testsuite/Makefile.am: Add commands to build icf_safe_test. Modify
	icf_test and icf_keep_unique_test to use the --icf enum flag.
	* testsuite/icf_safe_test.sh: New file.
	* testsuite/icf_safe_test.cc: New file.
@
text
@d560 1
a560 1
  std::vector<unsigned int> num_tracked_relocs;
d588 1
a588 1
          num_tracked_relocs.push_back(0);
d608 1
a608 1
                                 &num_tracked_relocs, &this->kept_section_id_,
@


1.3
log
@2009-08-12  Sriraman Tallam  <tmsriram@@google.com>

	* icf.cc (Icf::find_identical_sections): Issue a warning when a
	symbol in the --keep-unique list is not found.
@
text
@d117 1
d534 16
d572 1
d574 1
a574 1
          if (!is_prefix_of(".text.", (*p)->section_name(i).c_str()))
d581 4
@


1.3.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a116 1
#include "demangle.h"
a532 16
// During safe icf (--icf=safe), only fold functions that are ctors or dtors.
// This function returns true if the mangled function name is a ctor or a
// dtor.

static bool
is_function_ctor_or_dtor(const char* mangled_func_name)
{
  if ((is_prefix_of("_ZN", mangled_func_name)
       || is_prefix_of("_ZZ", mangled_func_name))
      && (is_gnu_v3_mangled_ctor(mangled_func_name)
          || is_gnu_v3_mangled_dtor(mangled_func_name)))
    {
      return true;
    }
  return false;
}
a554 1
	  const char* section_name = (*p)->section_name(i).c_str();
d556 1
a556 1
          if (!is_prefix_of(".text.", section_name))
a562 4
	  // With --icf=safe, check if mangled name is a ctor or a dtor.
	  if (parameters->options().icf_safe_folding()
	      && !is_function_ctor_or_dtor(section_name + 6))
	    continue;
@


1.2
log
@Sriraman Tallam  <tmsriram@@google.com>

	* icf.cc (Icf::find_identical_sections): Unfold symbols that have
	been maked as --keep-unique.
	(Icf::unfold_section): New function.
	* icf.h (Icf::unfold_section): New function.
	* options.h (General_options::keep_unique): New option.
	* testsuite/Makefile.am: Add commands to build icf_keep_unique_test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/icf_keep_unique_test.sh: New file.
	* testsuite/icf_keep_unique_test.cc: New file.
@
text
@d609 6
a614 3
      if (sym != NULL
	  && sym->source() == Symbol::FROM_OBJECT 
          && !sym->object()->is_dynamic())
@


1.1
log
@*** empty log message ***
@
text
@d601 23
d627 15
@

