head	1.67;
access;
symbols
	binutils-2_24-branch:1.67.0.2
	binutils-2_24-branchpoint:1.67
	binutils-2_21_1:1.58
	binutils-2_23_2:1.66
	binutils-2_23_1:1.66
	binutils-2_23:1.66
	binutils-2_23-branch:1.66.0.2
	binutils-2_23-branchpoint:1.66
	binutils-2_22_branch:1.63.0.4
	binutils-2_22:1.63
	binutils-2_22-branch:1.63.0.2
	binutils-2_22-branchpoint:1.63
	binutils-2_21:1.58
	binutils-2_21-branch:1.58.0.2
	binutils-2_21-branchpoint:1.58
	binutils-2_20_1:1.42.2.2
	binutils-2_20:1.42.2.1
	binutils-arc-20081103-branch:1.38.0.4
	binutils-arc-20081103-branchpoint:1.38
	binutils-2_20-branch:1.42.0.2
	binutils-2_20-branchpoint:1.42
	dje-cgen-play1-branch:1.40.0.2
	dje-cgen-play1-branchpoint:1.40
	arc-20081103-branch:1.38.0.2
	arc-20081103-branchpoint:1.38
	binutils-2_19_1:1.37
	binutils-2_19:1.37
	binutils-2_19-branch:1.37.0.2
	binutils-2_19-branchpoint:1.37
	binutils_latest_snapshot:1.67
	added-to-binutils:1.32;
locks; strict;
comment	@// @;


1.67
date	2013.06.14.20.07.18;	author ccoutant;	state Exp;
branches;
next	1.66;

1.66
date	2012.03.13.16.08.53;	author ian;	state Exp;
branches;
next	1.65;

1.65
date	2011.12.17.22.39.52;	author ccoutant;	state Exp;
branches;
next	1.64;

1.64
date	2011.10.18.00.25.52;	author ccoutant;	state Exp;
branches;
next	1.63;

1.63
date	2011.07.08.23.49.11;	author ian;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2011.07.06.04.43.39;	author ian;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.02.05.29.59;	author ian;	state Exp;
branches;
next	1.60;

1.60
date	2011.06.17.13.31.33;	author ian;	state Exp;
branches;
next	1.59;

1.59
date	2011.06.08.04.05.25;	author ccoutant;	state Exp;
branches;
next	1.58;

1.58
date	2010.10.11.20.04.04;	author ian;	state Exp;
branches;
next	1.57;

1.57
date	2010.08.28.08.05.04;	author dougkwan;	state Exp;
branches;
next	1.56;

1.56
date	2010.08.13.00.18.18;	author dougkwan;	state Exp;
branches;
next	1.55;

1.55
date	2010.07.09.01.34.31;	author ccoutant;	state Exp;
branches;
next	1.54;

1.54
date	2010.02.05.00.30.35;	author dougkwan;	state Exp;
branches;
next	1.53;

1.53
date	2010.01.11.07.09.48;	author ian;	state Exp;
branches;
next	1.52;

1.52
date	2010.01.11.05.44.04;	author ian;	state Exp;
branches;
next	1.51;

1.51
date	2010.01.09.00.13.48;	author ian;	state Exp;
branches;
next	1.50;

1.50
date	2010.01.05.22.55.08;	author ian;	state Exp;
branches;
next	1.49;

1.49
date	2010.01.05.05.56.28;	author ian;	state Exp;
branches;
next	1.48;

1.48
date	2009.12.29.00.31.48;	author ian;	state Exp;
branches;
next	1.47;

1.47
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.46;

1.46
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2009.12.05.07.28.45;	author hjl;	state Exp;
branches;
next	1.44;

1.44
date	2009.11.04.01.24.41;	author ian;	state Exp;
branches;
next	1.43;

1.43
date	2009.09.30.22.21.13;	author ian;	state Exp;
branches;
next	1.42;

1.42
date	2009.08.19.17.53.50;	author ccoutant;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2009.08.12.18.30.39;	author ccoutant;	state Exp;
branches;
next	1.40;

1.40
date	2009.06.22.06.51.53;	author ian;	state Exp;
branches;
next	1.39;

1.39
date	2009.02.27.19.57.46;	author ian;	state Exp;
branches;
next	1.38;

1.38
date	2008.09.19.22.54.57;	author ccoutant;	state Exp;
branches;
next	1.37;

1.37
date	2008.07.23.14.36.09;	author ian;	state Exp;
branches;
next	1.36;

1.36
date	2008.05.08.18.44.33;	author ian;	state Exp;
branches;
next	1.35;

1.35
date	2008.05.07.06.08.01;	author ian;	state Exp;
branches;
next	1.34;

1.34
date	2008.04.19.18.30.58;	author ian;	state Exp;
branches;
next	1.33;

1.33
date	2008.03.25.18.37.16;	author ccoutant;	state Exp;
branches;
next	1.32;

1.32
date	2008.02.29.19.19.17;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2008.02.28.22.39.29;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2008.01.24.00.15.00;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2008.01.09.19.57.45;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.15.01.12.55;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.14.01.03.01;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.13.20.02.32;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.22.23.08.22;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.14.15.35.27;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.14.07.10.20;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.14.06.54.56;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.14.06.49.14;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.14.04.06.18;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.19.06.02.29;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.04.20.00.53;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.08.29.05.48.24;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.28.04.12.19;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.06.06.28.56;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.06.00.02.36;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.01.16.51.25;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.16.00.38.25;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.03.18.38.43;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.03.18.26.11;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.06.20.40.16;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.29.22.34.01;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.29.19.58.17;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.26.21.50.25;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.07.21.21.41;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.18.22.29.20;	author iant;	state Exp;
branches;
next	;

1.63.2.1
date	2011.12.19.21.14.39;	author ian;	state Exp;
branches;
next	;

1.42.2.1
date	2009.10.16.05.51.18;	author ian;	state Exp;
branches;
next	1.42.2.2;

1.42.2.2
date	2009.11.04.01.28.30;	author ian;	state Exp;
branches;
next	;


desc
@@


1.67
log
@gold/
	* resolve.cc (Symbol::override_base): Don't override st_type
	from plugin placeholder symbols.
	(Symbol_table::resolve): Likewise.
	(Symbol_table::should_override): Don't complain about TLS mismatch
	if the TO symbol is a plugin placeholder.
	* testsuite/Makefile.am (plugin_test_tls): New test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_test_tls.sh: New test script.
	* testsuite/two_file_test_2_tls.cc: New test source.
	* testsuite/two_file_test_tls.cc: New test source.
@
text
@// resolve.cc -- symbol resolution for gold

// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include "elfcpp.h"
#include "target.h"
#include "object.h"
#include "symtab.h"
#include "plugin.h"

namespace gold
{

// Symbol methods used in this file.

// This symbol is being overridden by another symbol whose version is
// VERSION.  Update the VERSION_ field accordingly.

inline void
Symbol::override_version(const char* version)
{
  if (version == NULL)
    {
      // This is the case where this symbol is NAME/VERSION, and the
      // version was not marked as hidden.  That makes it the default
      // version, so we create NAME/NULL.  Later we see another symbol
      // NAME/NULL, and that symbol is overriding this one.  In this
      // case, since NAME/VERSION is the default, we make NAME/NULL
      // override NAME/VERSION as well.  They are already the same
      // Symbol structure.  Setting the VERSION_ field to NULL ensures
      // that it will be output with the correct, empty, version.
      this->version_ = version;
    }
  else
    {
      // This is the case where this symbol is NAME/VERSION_ONE, and
      // now we see NAME/VERSION_TWO, and NAME/VERSION_TWO is
      // overriding NAME.  If VERSION_ONE and VERSION_TWO are
      // different, then this can only happen when VERSION_ONE is NULL
      // and VERSION_TWO is not hidden.
      gold_assert(this->version_ == version || this->version_ == NULL);
      this->version_ = version;
    }
}

// This symbol is being overidden by another symbol whose visibility
// is VISIBILITY.  Updated the VISIBILITY_ field accordingly.

inline void
Symbol::override_visibility(elfcpp::STV visibility)
{
  // The rule for combining visibility is that we always choose the
  // most constrained visibility.  In order of increasing constraint,
  // visibility goes PROTECTED, HIDDEN, INTERNAL.  This is the reverse
  // of the numeric values, so the effect is that we always want the
  // smallest non-zero value.
  if (visibility != elfcpp::STV_DEFAULT)
    {
      if (this->visibility_ == elfcpp::STV_DEFAULT)
	this->visibility_ = visibility;
      else if (this->visibility_ > visibility)
	this->visibility_ = visibility;
    }
}

// Override the fields in Symbol.

template<int size, bool big_endian>
void
Symbol::override_base(const elfcpp::Sym<size, big_endian>& sym,
		      unsigned int st_shndx, bool is_ordinary,
		      Object* object, const char* version)
{
  gold_assert(this->source_ == FROM_OBJECT);
  this->u_.from_object.object = object;
  this->override_version(version);
  this->u_.from_object.shndx = st_shndx;
  this->is_ordinary_shndx_ = is_ordinary;
  // Don't override st_type from plugin placeholder symbols.
  if (object->pluginobj() == NULL)
    this->type_ = sym.get_st_type();
  this->binding_ = sym.get_st_bind();
  this->override_visibility(sym.get_st_visibility());
  this->nonvis_ = sym.get_st_nonvis();
  if (object->is_dynamic())
    this->in_dyn_ = true;
  else
    this->in_reg_ = true;
}

// Override the fields in Sized_symbol.

template<int size>
template<bool big_endian>
void
Sized_symbol<size>::override(const elfcpp::Sym<size, big_endian>& sym,
			     unsigned st_shndx, bool is_ordinary,
			     Object* object, const char* version)
{
  this->override_base(sym, st_shndx, is_ordinary, object, version);
  this->value_ = sym.get_st_value();
  this->symsize_ = sym.get_st_size();
}

// Override TOSYM with symbol FROMSYM, defined in OBJECT, with version
// VERSION.  This handles all aliases of TOSYM.

template<int size, bool big_endian>
void
Symbol_table::override(Sized_symbol<size>* tosym,
		       const elfcpp::Sym<size, big_endian>& fromsym,
		       unsigned int st_shndx, bool is_ordinary,
		       Object* object, const char* version)
{
  tosym->override(fromsym, st_shndx, is_ordinary, object, version);
  if (tosym->has_alias())
    {
      Symbol* sym = this->weak_aliases_[tosym];
      gold_assert(sym != NULL);
      Sized_symbol<size>* ssym = this->get_sized_symbol<size>(sym);
      do
	{
	  ssym->override(fromsym, st_shndx, is_ordinary, object, version);
	  sym = this->weak_aliases_[ssym];
	  gold_assert(sym != NULL);
	  ssym = this->get_sized_symbol<size>(sym);
	}
      while (ssym != tosym);
    }
}

// The resolve functions build a little code for each symbol.
// Bit 0: 0 for global, 1 for weak.
// Bit 1: 0 for regular object, 1 for shared object
// Bits 2-3: 0 for normal, 1 for undefined, 2 for common
// This gives us values from 0 to 11.

static const int global_or_weak_shift = 0;
static const unsigned int global_flag = 0 << global_or_weak_shift;
static const unsigned int weak_flag = 1 << global_or_weak_shift;

static const int regular_or_dynamic_shift = 1;
static const unsigned int regular_flag = 0 << regular_or_dynamic_shift;
static const unsigned int dynamic_flag = 1 << regular_or_dynamic_shift;

static const int def_undef_or_common_shift = 2;
static const unsigned int def_flag = 0 << def_undef_or_common_shift;
static const unsigned int undef_flag = 1 << def_undef_or_common_shift;
static const unsigned int common_flag = 2 << def_undef_or_common_shift;

// This convenience function combines all the flags based on facts
// about the symbol.

static unsigned int
symbol_to_bits(elfcpp::STB binding, bool is_dynamic,
	       unsigned int shndx, bool is_ordinary, elfcpp::STT type)
{
  unsigned int bits;

  switch (binding)
    {
    case elfcpp::STB_GLOBAL:
    case elfcpp::STB_GNU_UNIQUE:
      bits = global_flag;
      break;

    case elfcpp::STB_WEAK:
      bits = weak_flag;
      break;

    case elfcpp::STB_LOCAL:
      // We should only see externally visible symbols in the symbol
      // table.
      gold_error(_("invalid STB_LOCAL symbol in external symbols"));
      bits = global_flag;

    default:
      // Any target which wants to handle STB_LOOS, etc., needs to
      // define a resolve method.
      gold_error(_("unsupported symbol binding %d"), static_cast<int>(binding));
      bits = global_flag;
    }

  if (is_dynamic)
    bits |= dynamic_flag;
  else
    bits |= regular_flag;

  switch (shndx)
    {
    case elfcpp::SHN_UNDEF:
      bits |= undef_flag;
      break;

    case elfcpp::SHN_COMMON:
      if (!is_ordinary)
	bits |= common_flag;
      break;

    default:
      if (type == elfcpp::STT_COMMON)
	bits |= common_flag;
      else if (!is_ordinary && Symbol::is_common_shndx(shndx))
	bits |= common_flag;
      else
        bits |= def_flag;
      break;
    }

  return bits;
}

// Resolve a symbol.  This is called the second and subsequent times
// we see a symbol.  TO is the pre-existing symbol.  ST_SHNDX is the
// section index for SYM, possibly adjusted for many sections.
// IS_ORDINARY is whether ST_SHNDX is a normal section index rather
// than a special code.  ORIG_ST_SHNDX is the original section index,
// before any munging because of discarded sections, except that all
// non-ordinary section indexes are mapped to SHN_UNDEF.  VERSION is
// the version of SYM.

template<int size, bool big_endian>
void
Symbol_table::resolve(Sized_symbol<size>* to,
		      const elfcpp::Sym<size, big_endian>& sym,
		      unsigned int st_shndx, bool is_ordinary,
		      unsigned int orig_st_shndx,
		      Object* object, const char* version)
{
  // It's possible for a symbol to be defined in an object file
  // using .symver to give it a version, and for there to also be
  // a linker script giving that symbol the same version.  We
  // don't want to give a multiple-definition error for this
  // harmless redefinition.
  bool to_is_ordinary;
  if (to->source() == Symbol::FROM_OBJECT
      && to->object() == object
      && is_ordinary
      && to->is_defined()
      && to->shndx(&to_is_ordinary) == st_shndx
      && to_is_ordinary
      && to->value() == sym.get_st_value())
    return;

  if (parameters->target().has_resolve())
    {
      Sized_target<size, big_endian>* sized_target;
      sized_target = parameters->sized_target<size, big_endian>();
      sized_target->resolve(to, sym, object, version);
      return;
    }

  if (!object->is_dynamic())
    {
      // Record that we've seen this symbol in a regular object.
      to->set_in_reg();
    }
  else if (st_shndx == elfcpp::SHN_UNDEF
           && (to->visibility() == elfcpp::STV_HIDDEN
               || to->visibility() == elfcpp::STV_INTERNAL))
    {
      // A dynamic object cannot reference a hidden or internal symbol
      // defined in another object.
      gold_warning(_("%s symbol '%s' in %s is referenced by DSO %s"),
                   (to->visibility() == elfcpp::STV_HIDDEN
                    ? "hidden"
                    : "internal"),
                   to->demangled_name().c_str(),
                   to->object()->name().c_str(),
                   object->name().c_str());
      return;
    }
  else
    {
      // Record that we've seen this symbol in a dynamic object.
      to->set_in_dyn();
    }

  // Record if we've seen this symbol in a real ELF object (i.e., the
  // symbol is referenced from outside the world known to the plugin).
  if (object->pluginobj() == NULL && !object->is_dynamic())
    to->set_in_real_elf();

  // If we're processing replacement files, allow new symbols to override
  // the placeholders from the plugin objects.
  if (to->source() == Symbol::FROM_OBJECT)
    {
      Pluginobj* obj = to->object()->pluginobj();
      if (obj != NULL
          && parameters->options().plugins()->in_replacement_phase())
        {
          this->override(to, sym, st_shndx, is_ordinary, object, version);
          return;
        }
    }

  // A new weak undefined reference, merging with an old weak
  // reference, could be a One Definition Rule (ODR) violation --
  // especially if the types or sizes of the references differ.  We'll
  // store such pairs and look them up later to make sure they
  // actually refer to the same lines of code.  We also check
  // combinations of weak and strong, which might occur if one case is
  // inline and the other is not.  (Note: not all ODR violations can
  // be found this way, and not everything this finds is an ODR
  // violation.  But it's helpful to warn about.)
  if (parameters->options().detect_odr_violations()
      && (sym.get_st_bind() == elfcpp::STB_WEAK
	  || to->binding() == elfcpp::STB_WEAK)
      && orig_st_shndx != elfcpp::SHN_UNDEF
      && to->shndx(&to_is_ordinary) != elfcpp::SHN_UNDEF
      && to_is_ordinary
      && sym.get_st_size() != 0    // Ignore weird 0-sized symbols.
      && to->symsize() != 0
      && (sym.get_st_type() != to->type()
          || sym.get_st_size() != to->symsize())
      // C does not have a concept of ODR, so we only need to do this
      // on C++ symbols.  These have (mangled) names starting with _Z.
      && to->name()[0] == '_' && to->name()[1] == 'Z')
    {
      Symbol_location fromloc
          = { object, orig_st_shndx, static_cast<off_t>(sym.get_st_value()) };
      Symbol_location toloc = { to->object(), to->shndx(&to_is_ordinary),
				static_cast<off_t>(to->value()) };
      this->candidate_odr_violations_[to->name()].insert(fromloc);
      this->candidate_odr_violations_[to->name()].insert(toloc);
    }

  // Plugins don't provide a symbol type, so adopt the existing type
  // if the FROM symbol is from a plugin.
  elfcpp::STT fromtype = (object->pluginobj() != NULL
			  ? to->type()
			  : sym.get_st_type());
  unsigned int frombits = symbol_to_bits(sym.get_st_bind(),
                                         object->is_dynamic(),
					 st_shndx, is_ordinary,
                                         fromtype);

  bool adjust_common_sizes;
  bool adjust_dyndef;
  typename Sized_symbol<size>::Size_type tosize = to->symsize();
  if (Symbol_table::should_override(to, frombits, fromtype, OBJECT,
				    object, &adjust_common_sizes,
				    &adjust_dyndef))
    {
      elfcpp::STB tobinding = to->binding();
      typename Sized_symbol<size>::Value_type tovalue = to->value();
      this->override(to, sym, st_shndx, is_ordinary, object, version);
      if (adjust_common_sizes)
	{
	  if (tosize > to->symsize())
	    to->set_symsize(tosize);
	  if (tovalue > to->value())
	    to->set_value(tovalue);
	}
      if (adjust_dyndef)
	{
	  // We are overriding an UNDEF or WEAK UNDEF with a DYN DEF.
	  // Remember which kind of UNDEF it was for future reference.
	  to->set_undef_binding(tobinding);
	}
    }
  else
    {
      if (adjust_common_sizes)
	{
	  if (sym.get_st_size() > tosize)
	    to->set_symsize(sym.get_st_size());
	  if (sym.get_st_value() > to->value())
	    to->set_value(sym.get_st_value());
	}
      if (adjust_dyndef)
	{
	  // We are keeping a DYN DEF after seeing an UNDEF or WEAK UNDEF.
	  // Remember which kind of UNDEF it was.
	  to->set_undef_binding(sym.get_st_bind());
	}
      // The ELF ABI says that even for a reference to a symbol we
      // merge the visibility.
      to->override_visibility(sym.get_st_visibility());
    }

  if (adjust_common_sizes && parameters->options().warn_common())
    {
      if (tosize > sym.get_st_size())
	Symbol_table::report_resolve_problem(false,
					     _("common of '%s' overriding "
					       "smaller common"),
					     to, OBJECT, object);
      else if (tosize < sym.get_st_size())
	Symbol_table::report_resolve_problem(false,
					     _("common of '%s' overidden by "
					       "larger common"),
					     to, OBJECT, object);
      else
	Symbol_table::report_resolve_problem(false,
					     _("multiple common of '%s'"),
					     to, OBJECT, object);
    }
}

// Handle the core of symbol resolution.  This is called with the
// existing symbol, TO, and a bitflag describing the new symbol.  This
// returns true if we should override the existing symbol with the new
// one, and returns false otherwise.  It sets *ADJUST_COMMON_SIZES to
// true if we should set the symbol size to the maximum of the TO and
// FROM sizes.  It handles error conditions.

bool
Symbol_table::should_override(const Symbol* to, unsigned int frombits,
			      elfcpp::STT fromtype, Defined defined,
			      Object* object, bool* adjust_common_sizes,
			      bool* adjust_dyndef)
{
  *adjust_common_sizes = false;
  *adjust_dyndef = false;

  unsigned int tobits;
  if (to->source() == Symbol::IS_UNDEFINED)
    tobits = symbol_to_bits(to->binding(), false, elfcpp::SHN_UNDEF, true,
			    to->type());
  else if (to->source() != Symbol::FROM_OBJECT)
    tobits = symbol_to_bits(to->binding(), false, elfcpp::SHN_ABS, false,
			    to->type());
  else
    {
      bool is_ordinary;
      unsigned int shndx = to->shndx(&is_ordinary);
      tobits = symbol_to_bits(to->binding(),
			      to->object()->is_dynamic(),
			      shndx,
			      is_ordinary,
			      to->type());
    }

  if ((to->type() == elfcpp::STT_TLS) ^ (fromtype == elfcpp::STT_TLS)
      && !to->is_placeholder())
    Symbol_table::report_resolve_problem(true,
					 _("symbol '%s' used as both __thread "
					   "and non-__thread"),
					 to, defined, object);

  // We use a giant switch table for symbol resolution.  This code is
  // unwieldy, but: 1) it is efficient; 2) we definitely handle all
  // cases; 3) it is easy to change the handling of a particular case.
  // The alternative would be a series of conditionals, but it is easy
  // to get the ordering wrong.  This could also be done as a table,
  // but that is no easier to understand than this large switch
  // statement.

  // These are the values generated by the bit codes.
  enum
  {
    DEF =              global_flag | regular_flag | def_flag,
    WEAK_DEF =         weak_flag   | regular_flag | def_flag,
    DYN_DEF =          global_flag | dynamic_flag | def_flag,
    DYN_WEAK_DEF =     weak_flag   | dynamic_flag | def_flag,
    UNDEF =            global_flag | regular_flag | undef_flag,
    WEAK_UNDEF =       weak_flag   | regular_flag | undef_flag,
    DYN_UNDEF =        global_flag | dynamic_flag | undef_flag,
    DYN_WEAK_UNDEF =   weak_flag   | dynamic_flag | undef_flag,
    COMMON =           global_flag | regular_flag | common_flag,
    WEAK_COMMON =      weak_flag   | regular_flag | common_flag,
    DYN_COMMON =       global_flag | dynamic_flag | common_flag,
    DYN_WEAK_COMMON =  weak_flag   | dynamic_flag | common_flag
  };

  switch (tobits * 16 + frombits)
    {
    case DEF * 16 + DEF:
      // Two definitions of the same symbol.

      // If either symbol is defined by an object included using
      // --just-symbols, then don't warn.  This is for compatibility
      // with the GNU linker.  FIXME: This is a hack.
      if ((to->source() == Symbol::FROM_OBJECT && to->object()->just_symbols())
          || (object != NULL && object->just_symbols()))
        return false;

      if (!parameters->options().muldefs())
	Symbol_table::report_resolve_problem(true,
					     _("multiple definition of '%s'"),
					     to, defined, object);
      return false;

    case WEAK_DEF * 16 + DEF:
      // We've seen a weak definition, and now we see a strong
      // definition.  In the original SVR4 linker, this was treated as
      // a multiple definition error.  In the Solaris linker and the
      // GNU linker, a weak definition followed by a regular
      // definition causes the weak definition to be overridden.  We
      // are currently compatible with the GNU linker.  In the future
      // we should add a target specific option to change this.
      // FIXME.
      return true;

    case DYN_DEF * 16 + DEF:
    case DYN_WEAK_DEF * 16 + DEF:
      // We've seen a definition in a dynamic object, and now we see a
      // definition in a regular object.  The definition in the
      // regular object overrides the definition in the dynamic
      // object.
      return true;

    case UNDEF * 16 + DEF:
    case WEAK_UNDEF * 16 + DEF:
    case DYN_UNDEF * 16 + DEF:
    case DYN_WEAK_UNDEF * 16 + DEF:
      // We've seen an undefined reference, and now we see a
      // definition.  We use the definition.
      return true;

    case COMMON * 16 + DEF:
    case WEAK_COMMON * 16 + DEF:
    case DYN_COMMON * 16 + DEF:
    case DYN_WEAK_COMMON * 16 + DEF:
      // We've seen a common symbol and now we see a definition.  The
      // definition overrides.
      if (parameters->options().warn_common())
	Symbol_table::report_resolve_problem(false,
					     _("definition of '%s' overriding "
					       "common"),
					     to, defined, object);
      return true;

    case DEF * 16 + WEAK_DEF:
    case WEAK_DEF * 16 + WEAK_DEF:
      // We've seen a definition and now we see a weak definition.  We
      // ignore the new weak definition.
      return false;

    case DYN_DEF * 16 + WEAK_DEF:
    case DYN_WEAK_DEF * 16 + WEAK_DEF:
      // We've seen a dynamic definition and now we see a regular weak
      // definition.  The regular weak definition overrides.
      return true;

    case UNDEF * 16 + WEAK_DEF:
    case WEAK_UNDEF * 16 + WEAK_DEF:
    case DYN_UNDEF * 16 + WEAK_DEF:
    case DYN_WEAK_UNDEF * 16 + WEAK_DEF:
      // A weak definition of a currently undefined symbol.
      return true;

    case COMMON * 16 + WEAK_DEF:
    case WEAK_COMMON * 16 + WEAK_DEF:
      // A weak definition does not override a common definition.
      return false;

    case DYN_COMMON * 16 + WEAK_DEF:
    case DYN_WEAK_COMMON * 16 + WEAK_DEF:
      // A weak definition does override a definition in a dynamic
      // object.
      if (parameters->options().warn_common())
	Symbol_table::report_resolve_problem(false,
					     _("definition of '%s' overriding "
					       "dynamic common definition"),
					     to, defined, object);
      return true;

    case DEF * 16 + DYN_DEF:
    case WEAK_DEF * 16 + DYN_DEF:
    case DYN_DEF * 16 + DYN_DEF:
    case DYN_WEAK_DEF * 16 + DYN_DEF:
      // Ignore a dynamic definition if we already have a definition.
      return false;

    case UNDEF * 16 + DYN_DEF:
    case DYN_UNDEF * 16 + DYN_DEF:
    case DYN_WEAK_UNDEF * 16 + DYN_DEF:
      // Use a dynamic definition if we have a reference.
      return true;

    case WEAK_UNDEF * 16 + DYN_DEF:
      // When overriding a weak undef by a dynamic definition,
      // we need to remember that the original undef was weak.
      *adjust_dyndef = true;
      return true;

    case COMMON * 16 + DYN_DEF:
    case WEAK_COMMON * 16 + DYN_DEF:
    case DYN_COMMON * 16 + DYN_DEF:
    case DYN_WEAK_COMMON * 16 + DYN_DEF:
      // Ignore a dynamic definition if we already have a common
      // definition.
      return false;

    case DEF * 16 + DYN_WEAK_DEF:
    case WEAK_DEF * 16 + DYN_WEAK_DEF:
    case DYN_DEF * 16 + DYN_WEAK_DEF:
    case DYN_WEAK_DEF * 16 + DYN_WEAK_DEF:
      // Ignore a weak dynamic definition if we already have a
      // definition.
      return false;

    case UNDEF * 16 + DYN_WEAK_DEF:
      // When overriding an undef by a dynamic weak definition,
      // we need to remember that the original undef was not weak.
      *adjust_dyndef = true;
      return true;

    case DYN_UNDEF * 16 + DYN_WEAK_DEF:
    case DYN_WEAK_UNDEF * 16 + DYN_WEAK_DEF:
      // Use a weak dynamic definition if we have a reference.
      return true;

    case WEAK_UNDEF * 16 + DYN_WEAK_DEF:
      // When overriding a weak undef by a dynamic definition,
      // we need to remember that the original undef was weak.
      *adjust_dyndef = true;
      return true;

    case COMMON * 16 + DYN_WEAK_DEF:
    case WEAK_COMMON * 16 + DYN_WEAK_DEF:
    case DYN_COMMON * 16 + DYN_WEAK_DEF:
    case DYN_WEAK_COMMON * 16 + DYN_WEAK_DEF:
      // Ignore a weak dynamic definition if we already have a common
      // definition.
      return false;

    case DEF * 16 + UNDEF:
    case WEAK_DEF * 16 + UNDEF:
    case UNDEF * 16 + UNDEF:
      // A new undefined reference tells us nothing.
      return false;

    case DYN_DEF * 16 + UNDEF:
    case DYN_WEAK_DEF * 16 + UNDEF:
      // For a dynamic def, we need to remember which kind of undef we see.
      *adjust_dyndef = true;
      return false;

    case WEAK_UNDEF * 16 + UNDEF:
    case DYN_UNDEF * 16 + UNDEF:
    case DYN_WEAK_UNDEF * 16 + UNDEF:
      // A strong undef overrides a dynamic or weak undef.
      return true;

    case COMMON * 16 + UNDEF:
    case WEAK_COMMON * 16 + UNDEF:
    case DYN_COMMON * 16 + UNDEF:
    case DYN_WEAK_COMMON * 16 + UNDEF:
      // A new undefined reference tells us nothing.
      return false;

    case DEF * 16 + WEAK_UNDEF:
    case WEAK_DEF * 16 + WEAK_UNDEF:
    case UNDEF * 16 + WEAK_UNDEF:
    case WEAK_UNDEF * 16 + WEAK_UNDEF:
    case DYN_UNDEF * 16 + WEAK_UNDEF:
    case COMMON * 16 + WEAK_UNDEF:
    case WEAK_COMMON * 16 + WEAK_UNDEF:
    case DYN_COMMON * 16 + WEAK_UNDEF:
    case DYN_WEAK_COMMON * 16 + WEAK_UNDEF:
      // A new weak undefined reference tells us nothing unless the
      // exisiting symbol is a dynamic weak reference.
      return false;

    case DYN_WEAK_UNDEF * 16 + WEAK_UNDEF:
      // A new weak reference overrides an existing dynamic weak reference.
      // This is necessary because a dynamic weak reference remembers
      // the old binding, which may not be weak.  If we keeps the existing
      // dynamic weak reference, the weakness may be dropped in the output.
      return true;

    case DYN_DEF * 16 + WEAK_UNDEF:
    case DYN_WEAK_DEF * 16 + WEAK_UNDEF:
      // For a dynamic def, we need to remember which kind of undef we see.
      *adjust_dyndef = true;
      return false;

    case DEF * 16 + DYN_UNDEF:
    case WEAK_DEF * 16 + DYN_UNDEF:
    case DYN_DEF * 16 + DYN_UNDEF:
    case DYN_WEAK_DEF * 16 + DYN_UNDEF:
    case UNDEF * 16 + DYN_UNDEF:
    case WEAK_UNDEF * 16 + DYN_UNDEF:
    case DYN_UNDEF * 16 + DYN_UNDEF:
    case DYN_WEAK_UNDEF * 16 + DYN_UNDEF:
    case COMMON * 16 + DYN_UNDEF:
    case WEAK_COMMON * 16 + DYN_UNDEF:
    case DYN_COMMON * 16 + DYN_UNDEF:
    case DYN_WEAK_COMMON * 16 + DYN_UNDEF:
      // A new dynamic undefined reference tells us nothing.
      return false;

    case DEF * 16 + DYN_WEAK_UNDEF:
    case WEAK_DEF * 16 + DYN_WEAK_UNDEF:
    case DYN_DEF * 16 + DYN_WEAK_UNDEF:
    case DYN_WEAK_DEF * 16 + DYN_WEAK_UNDEF:
    case UNDEF * 16 + DYN_WEAK_UNDEF:
    case WEAK_UNDEF * 16 + DYN_WEAK_UNDEF:
    case DYN_UNDEF * 16 + DYN_WEAK_UNDEF:
    case DYN_WEAK_UNDEF * 16 + DYN_WEAK_UNDEF:
    case COMMON * 16 + DYN_WEAK_UNDEF:
    case WEAK_COMMON * 16 + DYN_WEAK_UNDEF:
    case DYN_COMMON * 16 + DYN_WEAK_UNDEF:
    case DYN_WEAK_COMMON * 16 + DYN_WEAK_UNDEF:
      // A new weak dynamic undefined reference tells us nothing.
      return false;

    case DEF * 16 + COMMON:
      // A common symbol does not override a definition.
      if (parameters->options().warn_common())
	Symbol_table::report_resolve_problem(false,
					     _("common '%s' overridden by "
					       "previous definition"),
					     to, defined, object);
      return false;

    case WEAK_DEF * 16 + COMMON:
    case DYN_DEF * 16 + COMMON:
    case DYN_WEAK_DEF * 16 + COMMON:
      // A common symbol does override a weak definition or a dynamic
      // definition.
      return true;

    case UNDEF * 16 + COMMON:
    case WEAK_UNDEF * 16 + COMMON:
    case DYN_UNDEF * 16 + COMMON:
    case DYN_WEAK_UNDEF * 16 + COMMON:
      // A common symbol is a definition for a reference.
      return true;

    case COMMON * 16 + COMMON:
      // Set the size to the maximum.
      *adjust_common_sizes = true;
      return false;

    case WEAK_COMMON * 16 + COMMON:
      // I'm not sure just what a weak common symbol means, but
      // presumably it can be overridden by a regular common symbol.
      return true;

    case DYN_COMMON * 16 + COMMON:
    case DYN_WEAK_COMMON * 16 + COMMON:
      // Use the real common symbol, but adjust the size if necessary.
      *adjust_common_sizes = true;
      return true;

    case DEF * 16 + WEAK_COMMON:
    case WEAK_DEF * 16 + WEAK_COMMON:
    case DYN_DEF * 16 + WEAK_COMMON:
    case DYN_WEAK_DEF * 16 + WEAK_COMMON:
      // Whatever a weak common symbol is, it won't override a
      // definition.
      return false;

    case UNDEF * 16 + WEAK_COMMON:
    case WEAK_UNDEF * 16 + WEAK_COMMON:
    case DYN_UNDEF * 16 + WEAK_COMMON:
    case DYN_WEAK_UNDEF * 16 + WEAK_COMMON:
      // A weak common symbol is better than an undefined symbol.
      return true;

    case COMMON * 16 + WEAK_COMMON:
    case WEAK_COMMON * 16 + WEAK_COMMON:
    case DYN_COMMON * 16 + WEAK_COMMON:
    case DYN_WEAK_COMMON * 16 + WEAK_COMMON:
      // Ignore a weak common symbol in the presence of a real common
      // symbol.
      return false;

    case DEF * 16 + DYN_COMMON:
    case WEAK_DEF * 16 + DYN_COMMON:
    case DYN_DEF * 16 + DYN_COMMON:
    case DYN_WEAK_DEF * 16 + DYN_COMMON:
      // Ignore a dynamic common symbol in the presence of a
      // definition.
      return false;

    case UNDEF * 16 + DYN_COMMON:
    case WEAK_UNDEF * 16 + DYN_COMMON:
    case DYN_UNDEF * 16 + DYN_COMMON:
    case DYN_WEAK_UNDEF * 16 + DYN_COMMON:
      // A dynamic common symbol is a definition of sorts.
      return true;

    case COMMON * 16 + DYN_COMMON:
    case WEAK_COMMON * 16 + DYN_COMMON:
    case DYN_COMMON * 16 + DYN_COMMON:
    case DYN_WEAK_COMMON * 16 + DYN_COMMON:
      // Set the size to the maximum.
      *adjust_common_sizes = true;
      return false;

    case DEF * 16 + DYN_WEAK_COMMON:
    case WEAK_DEF * 16 + DYN_WEAK_COMMON:
    case DYN_DEF * 16 + DYN_WEAK_COMMON:
    case DYN_WEAK_DEF * 16 + DYN_WEAK_COMMON:
      // A common symbol is ignored in the face of a definition.
      return false;

    case UNDEF * 16 + DYN_WEAK_COMMON:
    case WEAK_UNDEF * 16 + DYN_WEAK_COMMON:
    case DYN_UNDEF * 16 + DYN_WEAK_COMMON:
    case DYN_WEAK_UNDEF * 16 + DYN_WEAK_COMMON:
      // I guess a weak common symbol is better than a definition.
      return true;

    case COMMON * 16 + DYN_WEAK_COMMON:
    case WEAK_COMMON * 16 + DYN_WEAK_COMMON:
    case DYN_COMMON * 16 + DYN_WEAK_COMMON:
    case DYN_WEAK_COMMON * 16 + DYN_WEAK_COMMON:
      // Set the size to the maximum.
      *adjust_common_sizes = true;
      return false;

    default:
      gold_unreachable();
    }
}

// Issue an error or warning due to symbol resolution.  IS_ERROR
// indicates an error rather than a warning.  MSG is the error
// message; it is expected to have a %s for the symbol name.  TO is
// the existing symbol.  DEFINED/OBJECT is where the new symbol was
// found.

// FIXME: We should have better location information here.  When the
// symbol is defined, we should be able to pull the location from the
// debug info if there is any.

void
Symbol_table::report_resolve_problem(bool is_error, const char* msg,
				     const Symbol* to, Defined defined,
				     Object* object)
{
  std::string demangled(to->demangled_name());
  size_t len = strlen(msg) + demangled.length() + 10;
  char* buf = new char[len];
  snprintf(buf, len, msg, demangled.c_str());

  const char* objname;
  switch (defined)
    {
    case OBJECT:
      objname = object->name().c_str();
      break;
    case COPY:
      objname = _("COPY reloc");
      break;
    case DEFSYM:
    case UNDEFINED:
      objname = _("command line");
      break;
    case SCRIPT:
      objname = _("linker script");
      break;
    case PREDEFINED:
    case INCREMENTAL_BASE:
      objname = _("linker defined");
      break;
    default:
      gold_unreachable();
    }

  if (is_error)
    gold_error("%s: %s", objname, buf);
  else
    gold_warning("%s: %s", objname, buf);

  delete[] buf;

  if (to->source() == Symbol::FROM_OBJECT)
    objname = to->object()->name().c_str();
  else
    objname = _("command line");
  gold_info("%s: %s: previous definition here", program_name, objname);
}

// A special case of should_override which is only called for a strong
// defined symbol from a regular object file.  This is used when
// defining special symbols.

bool
Symbol_table::should_override_with_special(const Symbol* to,
					   elfcpp::STT fromtype,
					   Defined defined)
{
  bool adjust_common_sizes;
  bool adjust_dyn_def;
  unsigned int frombits = global_flag | regular_flag | def_flag;
  bool ret = Symbol_table::should_override(to, frombits, fromtype, defined,
					   NULL, &adjust_common_sizes,
					   &adjust_dyn_def);
  gold_assert(!adjust_common_sizes && !adjust_dyn_def);
  return ret;
}

// Override symbol base with a special symbol.

void
Symbol::override_base_with_special(const Symbol* from)
{
  bool same_name = this->name_ == from->name_;
  gold_assert(same_name || this->has_alias());

  this->source_ = from->source_;
  switch (from->source_)
    {
    case FROM_OBJECT:
      this->u_.from_object = from->u_.from_object;
      break;
    case IN_OUTPUT_DATA:
      this->u_.in_output_data = from->u_.in_output_data;
      break;
    case IN_OUTPUT_SEGMENT:
      this->u_.in_output_segment = from->u_.in_output_segment;
      break;
    case IS_CONSTANT:
    case IS_UNDEFINED:
      break;
    default:
      gold_unreachable();
      break;
    }

  if (same_name)
    {
      // When overriding a versioned symbol with a special symbol, we
      // may be changing the version.  This will happen if we see a
      // special symbol such as "_end" defined in a shared object with
      // one version (from a version script), but we want to define it
      // here with a different version (from a different version
      // script).
      this->version_ = from->version_;
    }
  this->type_ = from->type_;
  this->binding_ = from->binding_;
  this->override_visibility(from->visibility_);
  this->nonvis_ = from->nonvis_;

  // Special symbols are always considered to be regular symbols.
  this->in_reg_ = true;

  if (from->needs_dynsym_entry_)
    this->needs_dynsym_entry_ = true;
  if (from->needs_dynsym_value_)
    this->needs_dynsym_value_ = true;

  this->is_predefined_ = from->is_predefined_;

  // We shouldn't see these flags.  If we do, we need to handle them
  // somehow.
  gold_assert(!from->is_forwarder_);
  gold_assert(!from->has_plt_offset());
  gold_assert(!from->has_warning_);
  gold_assert(!from->is_copied_from_dynobj_);
  gold_assert(!from->is_forced_local_);
}

// Override a symbol with a special symbol.

template<int size>
void
Sized_symbol<size>::override_with_special(const Sized_symbol<size>* from)
{
  this->override_base_with_special(from);
  this->value_ = from->value_;
  this->symsize_ = from->symsize_;
}

// Override TOSYM with the special symbol FROMSYM.  This handles all
// aliases of TOSYM.

template<int size>
void
Symbol_table::override_with_special(Sized_symbol<size>* tosym,
				    const Sized_symbol<size>* fromsym)
{
  tosym->override_with_special(fromsym);
  if (tosym->has_alias())
    {
      Symbol* sym = this->weak_aliases_[tosym];
      gold_assert(sym != NULL);
      Sized_symbol<size>* ssym = this->get_sized_symbol<size>(sym);
      do
	{
	  ssym->override_with_special(fromsym);
	  sym = this->weak_aliases_[ssym];
	  gold_assert(sym != NULL);
	  ssym = this->get_sized_symbol<size>(sym);
	}
      while (ssym != tosym);
    }
  if (tosym->binding() == elfcpp::STB_LOCAL
      || ((tosym->visibility() == elfcpp::STV_HIDDEN
	   || tosym->visibility() == elfcpp::STV_INTERNAL)
	  && (tosym->binding() == elfcpp::STB_GLOBAL
	      || tosym->binding() == elfcpp::STB_GNU_UNIQUE
	      || tosym->binding() == elfcpp::STB_WEAK)
	  && !parameters->options().relocatable()))
    this->force_local(tosym);
}

// Instantiate the templates we need.  We could use the configure
// script to restrict this to only the ones needed for implemented
// targets.

// We have to instantiate both big and little endian versions because
// these are used by other templates that depends on size only.

#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
template
void
Symbol_table::resolve<32, false>(
    Sized_symbol<32>* to,
    const elfcpp::Sym<32, false>& sym,
    unsigned int st_shndx,
    bool is_ordinary,
    unsigned int orig_st_shndx,
    Object* object,
    const char* version);

template
void
Symbol_table::resolve<32, true>(
    Sized_symbol<32>* to,
    const elfcpp::Sym<32, true>& sym,
    unsigned int st_shndx,
    bool is_ordinary,
    unsigned int orig_st_shndx,
    Object* object,
    const char* version);
#endif

#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
template
void
Symbol_table::resolve<64, false>(
    Sized_symbol<64>* to,
    const elfcpp::Sym<64, false>& sym,
    unsigned int st_shndx,
    bool is_ordinary,
    unsigned int orig_st_shndx,
    Object* object,
    const char* version);

template
void
Symbol_table::resolve<64, true>(
    Sized_symbol<64>* to,
    const elfcpp::Sym<64, true>& sym,
    unsigned int st_shndx,
    bool is_ordinary,
    unsigned int orig_st_shndx,
    Object* object,
    const char* version);
#endif

#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
template
void
Symbol_table::override_with_special<32>(Sized_symbol<32>*,
					const Sized_symbol<32>*);
#endif

#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
template
void
Symbol_table::override_with_special<64>(Sized_symbol<64>*,
					const Sized_symbol<64>*);
#endif

} // End namespace gold.
@


1.66
log
@	* resolve.cc (Symbol_table::resolve): When merging common symbols,
	keep the larger alignment.
@
text
@d99 3
a101 1
  this->type_ = sym.get_st_type();
d348 5
d356 1
a356 1
                                         sym.get_st_type());
d361 1
a361 1
  if (Symbol_table::should_override(to, frombits, sym.get_st_type(), OBJECT,
d455 2
a456 3
  if (to->type() == elfcpp::STT_TLS
      ? fromtype != elfcpp::STT_TLS
      : fromtype == elfcpp::STT_TLS)
@


1.65
log
@2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.
@
text
@d359 1
d361 7
a367 2
      if (adjust_common_sizes && tosize > to->symsize())
        to->set_symsize(tosize);
d377 7
a383 2
      if (adjust_common_sizes && sym.get_st_size() > tosize)
        to->set_symsize(sym.get_st_size());
@


1.64
log
@	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.
@
text
@d339 1
a339 1
          = { object, orig_st_shndx, sym.get_st_value() };
d341 1
a341 1
				to->value() };
@


1.63
log
@	PR gold/12279
	* resolve.cc (Symbol_table::should_override): Add fromtype
	parameter.  Change all callers.  Give error when linking together
	TLS and non-TLS symbol.
	(Symbol_table::should_override_with_special): Add fromtype
	parameter.  Change all callers.
	* i386.cc (Target_i386::Relocate::relocate_tls): Don't crash if
	there is no TLS segment if we have reported some errors.
	* x86_64.cc (Target_x86_64::relocate_tls): Likewise.
@
text
@d299 1
a299 1
  if (object->pluginobj() == NULL)
@


1.63.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d299 1
a299 1
  if (object->pluginobj() == NULL && !object->is_dynamic())
d339 1
a339 1
          = { object, orig_st_shndx, static_cast<off_t>(sym.get_st_value()) };
d341 1
a341 1
				static_cast<off_t>(to->value()) };
@


1.62
log
@	PR gold/12952
	* resolve.cc (Symbol::override_base_with_special): Simply override
	version with special symbol version, ignoring previous version.
@
text
@d354 2
a355 2
  if (Symbol_table::should_override(to, frombits, OBJECT, object,
				    &adjust_common_sizes,
d412 2
a413 2
                              Defined defined, Object* object,
			      bool* adjust_common_sizes,
d437 7
a443 1
  // FIXME: Warn if either but not both of TO and SYM are STT_TLS.
d879 3
a881 1
Symbol_table::should_override_with_special(const Symbol* to, Defined defined)
d886 2
a887 2
  bool ret = Symbol_table::should_override(to, frombits, defined, NULL,
					   &adjust_common_sizes,
@


1.61
log
@	PR gold/12525
	PR gold/12952
	* resolve.cc (Symbol::override_base_with_special): Don't override
	the version if the overriding symbol has a different name.
	* dynobj.cc (Versions::add_def): Add dynpool parameter.  Change
	all callers.  If we give an error about an undefined version,
	define the base version if necessary.
	* dynobj.h (class Versions): Update declaration.
	* testsuite/weak_alias_test_5.cc: New file.
	* testsuite/weak_alias_test.script: New file.
	* testsuite/weak_alias_test_main.cc: Check that versioned_symbol
	and versioned_alias have the right value, and call t2.
	* testsuite/Makefile.am (weak_alias_test_DEPENDENCIES): Add
	weak_alias_test_5.so.
	(weak_alias_test_LDADD): Likewise.
	(weak_alias_test_5_pic.o, weak_alias_test_5.so): New targets.
	* testsuite/Makefile.in: Rebuild.
@
text
@d914 9
a922 1
    this->override_version(from->version_);
@


1.60
log
@	PR gold/12893
	* resolve.cc (Symbol_table::resolve): Don't give an error if a
	symbol is redefined with the exact same object and value.
@
text
@d890 2
a891 1
  gold_assert(this->name_ == from->name_ || this->has_alias());
d913 2
a914 1
  this->override_version(from->version_);
@


1.59
log
@	* common.cc (Symbol_table::do_allocate_commons_list): For incremental
	update, allocate common from bss section's free list.
	* incremental-dump.cc (dump_incremental_inputs): Print flag for
	linker-defined symbols.
	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Skip GOT and PLT entries that are no longer referenced.
	(Output_section_incremental_inputs::write_info_blocks): Mark
	linker-defined symbols.
	(Sized_incr_relobj::do_add_symbols): Process linker-defined symbols.
	* output.cc (Output_section::allocate): New function.
	* output.h (Output_section::allocate): New function.
	* resolve.cc (Symbol_table::report_resolve_problem): Add case for
	linker-defined symbols.
	(Symbol::override_base_with_special): Copy is_predefined_ flag.
	* symtab.cc (Symbol::init_fields): Initialize is_predefined_ flag.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* symtab.h (Symbol::is_predefined): New function.
	(Symbol::init_base_output_data): Add is_predefined parameter.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::is_predefined_): New data member.
	(Sized_symbol::init_output_data): Add is_predefined parameter.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(enum Symbol_table::Defined): Add INCREMENTAL_BASE.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d248 15
a323 1
  bool to_is_ordinary;
@


1.58
log
@	* resolve.cc (symbol_to_bits): Report the value of the unsupported
	binding.
@
text
@d833 1
d912 2
@


1.57
log
@2010-08-27  Doug Kwan  <dougkwan@@google.com>

	* gold/resolve.cc (Symbol_table::should_override): Let a weak
	reference override an existing dynamic weak reference.
	* testsuite/Makefile.am: Add new test dyn_weak_ref.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/dyn_weak_ref.sh: New file.
	* testsuite/dyn_weak_ref_1.c: Ditto.
	* testsuite/dyn_weak_ref_2.c: Ditto.
@
text
@d198 1
a198 1
      gold_error(_("unsupported symbol binding"));
@


1.56
log
@2010-08-12  Cary Coutant  <ccoutant@@google.com>
	    Doug Kwan  <dougkwan@@google.com>

	* resolve.cc (Symbol_table::should_override): When a weak dynamic
	defintion overrides non-weak undef, remember that the original undef
	is not weak.
	* symtab.cc (Symbol_table::sized_write_global): For undef without
	an original weak binding, set binding to global in output.
	* testsuite/Makefile.am: Add new test strong_ref_weak_def.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/strong_ref_weak_def.sh: New file.
	* testsuite/strong_ref_weak_def_1.c: Ditto.
	* testsuite/strong_ref_weak_def_2.c: Ditto.
@
text
@a632 1
    case DYN_WEAK_UNDEF * 16 + WEAK_UNDEF:
d637 2
a638 1
      // A new weak undefined reference tells us nothing.
d641 7
@


1.55
log
@	* resolve.cc (Symbol_table::resolve): Remember whether undef was
	weak when resolving to a dynamic def.
	(Symbol_table::should_override): Add adjust_dyndef flag; set it
	for weak undef/dynamic def cases. Adjust callers.
	* symtab.cc (Symbol::init_fields): Initialize undef_binding_set_ and
	undef_binding_weak_.
	(Symbol_table::sized_write_globals): Adjust symbol binding.
	(Symbol_table::sized_write_symbol): Add binding parameter.
	* symtab.h (Symbol::set_undef_binding): New method.
	(Symbol::is_undef_binding_weak): New method.
	(Symbol::undef_binding_set_, Symbol::undef_binding_weak_): New members.
	(Symbol_table::should_override): Add new parameter.
	(Symbol_table::sized_write_symbol): Add new parameter.

	* testsuite/weak_undef_file1.cc: Add new test case.
	* testsuite/weak_undef_file2.cc: Fix header comment.
	* testsuite/weak_undef_test.cc: Add new test case.
@
text
@d579 5
@


1.54
log
@2010-02-04  Doug Kwan  <dougkwan@@google.com>

	PR 11247
	* arm-reloc-property.cc (cstdio): Include.
	* configure.ac (targetobjs): Remove duplicates.
	* configure: Regenerate.
	* resolve.cc (Symbol_table::resolve): Explicit instantiate both
	big and little endian version for a given address size.
@
text
@d338 1
d341 2
a342 1
				    &adjust_common_sizes))
d344 1
d348 6
d359 6
d399 2
a400 1
			      bool* adjust_common_sizes)
d403 1
a550 1
    case WEAK_UNDEF * 16 + DYN_DEF:
d556 6
a578 1
    case WEAK_UNDEF * 16 + DYN_WEAK_DEF:
d584 6
d600 4
d606 2
a607 2
    case UNDEF * 16 + UNDEF:
      // A new undefined reference tells us nothing.
a624 2
    case DYN_DEF * 16 + WEAK_UNDEF:
    case DYN_WEAK_DEF * 16 + WEAK_UNDEF:
d636 6
d849 1
d852 3
a854 2
					   &adjust_common_sizes);
  gold_assert(!adjust_common_sizes);
@


1.53
log
@	* resolve.cc (Symbol_table::resolve): Add symbols to list of ODR
	candidates before doing symbol resolution.
@
text
@d919 4
a922 1
#ifdef HAVE_TARGET_32_LITTLE
a932 1
#endif
a933 1
#ifdef HAVE_TARGET_32_BIG
d946 1
a946 1
#ifdef HAVE_TARGET_64_LITTLE
a956 1
#endif
a957 1
#ifdef HAVE_TARGET_64_BIG
@


1.52
log
@	* resolve.cc (Symbol_table::resolve): Add symbols to the list of
	ODR candidates if only one is weak.
@
text
@d300 32
a371 32

  // A new weak undefined reference, merging with an old weak
  // reference, could be a One Definition Rule (ODR) violation --
  // especially if the types or sizes of the references differ.  We'll
  // store such pairs and look them up later to make sure they
  // actually refer to the same lines of code.  We also check
  // combinations of weak and strong, which might occur if one case is
  // inline and the other is not.  (Note: not all ODR violations can
  // be found this way, and not everything this finds is an ODR
  // violation.  But it's helpful to warn about.)
  bool to_is_ordinary;
  if (parameters->options().detect_odr_violations()
      && (sym.get_st_bind() == elfcpp::STB_WEAK
	  || to->binding() == elfcpp::STB_WEAK)
      && orig_st_shndx != elfcpp::SHN_UNDEF
      && to->shndx(&to_is_ordinary) != elfcpp::SHN_UNDEF
      && to_is_ordinary
      && sym.get_st_size() != 0    // Ignore weird 0-sized symbols.
      && to->symsize() != 0
      && (sym.get_st_type() != to->type()
          || sym.get_st_size() != to->symsize())
      // C does not have a concept of ODR, so we only need to do this
      // on C++ symbols.  These have (mangled) names starting with _Z.
      && to->name()[0] == '_' && to->name()[1] == 'Z')
    {
      Symbol_location fromloc
          = { object, orig_st_shndx, sym.get_st_value() };
      Symbol_location toloc = { to->object(), to->shndx(&to_is_ordinary),
				to->value() };
      this->candidate_odr_violations_[to->name()].insert(fromloc);
      this->candidate_odr_violations_[to->name()].insert(toloc);
    }
@


1.51
log
@	PR 11108
	* symtab.h (class Symbol): Remove fields is_target_special_ and
	has_plt_offset_.  Add field is_defined_in_discarded_section_.
	(Symbol::is_defined_in_discarded_section): New function.
	(Symbol::set_is_defined_in_discarded_section): New function.
	(Symbol::has_plt_offset): Rewrite.
	(Symbol::set_plt_offset): Verify that new offset is not -1U.
	* symtab.cc (Symbol::init_fields): Initialize plt_offset_ to -1U.
	Don't initialize is_target_special_ or has_plt_offset_.
	Initialize is_defined_in_discarded_section_.
	(Symbol_table::add_from_relobj): If appropriate, set
	is_defined_in_discarded_section.
	* resolve.cc (Symbol::override_base_with_special): Don't test
	is_target_special_.  Change has_plt_offset_ to has_plt_offset().
	* target-reloc.h (relocate_section): Do special handling for
	symbols defined in discarded sections for global symbols as well
	as local symbols.
@
text
@d345 5
a349 3
  // actually refer to the same lines of code.  (Note: not all ODR
  // violations can be found this way, and not everything this finds
  // is an ODR violation.  But it's helpful to warn about.)
d352 2
a353 2
      && sym.get_st_bind() == elfcpp::STB_WEAK
      && to->binding() == elfcpp::STB_WEAK
@


1.50
log
@	* options.h (class General_options): Use DEFINE_bool_alias for
	allow_multiple_definition.
	* resolve.cc (Symbol_table::should_override): Don't test
	allow_multiple_definition.
@
text
@a861 1
  gold_assert(!from->is_target_special_ || this->is_target_special_);
d863 1
a863 1
  gold_assert(!from->has_plt_offset_);
@


1.49
log
@	PR 10980
	* options.h (class General_options): Add
	--allow-multiple-definition and -z muldefs.
	* resolve.cc (Symbol_table::should_override): Don't warn about a
	multiple symbol definition if --allow-multiple-definition or -z
	muldefs.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d443 1
a443 2
      if (!parameters->options().allow_multiple_definition()
	  && !parameters->options().muldefs())
@


1.48
log
@	* symtab.h (class Symbol_table): Add enum Defined.
	* resolve.cc (Symbol_table::should_override): Add defined
	parameter.  Change all callers.  Test whether object is NULL
	before calling a method on it.
	(Symbol_table::report_resolve_problem): Add defined parameter.
	Change all callers.
	(Symbol_table::should_override_with_special): Likewise.
	* symtab.cc (Symbol_table::define_in_output_data): Add defined
	parameter.  Change all callers.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::define_in_output_segment): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::define_as_constant): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* script.h (class Symbol_assignment): Add is_defsym parameter to
	constructor; change all callers.
	* script.cc (Script_options::add_symbol_assignment): Add is_defsym
	parameter.  Change all callers.  Add is_defsym_ field.
	(class Parser_closure): Add parsing_defsym parameter to
	constructor; change all callers.  Add parsing_defsym accessor
	function.  Add parsing_defsym_ field.
@
text
@d443 5
a447 3
      Symbol_table::report_resolve_problem(true,
					   _("multiple definition of '%s'"),
					   to, defined, object);
@


1.47
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d307 1
a307 1
  if (Symbol_table::should_override(to, frombits, object,
d329 1
a329 1
					     to, object);
d334 1
a334 1
					     to, object);
d338 1
a338 1
					     to, object);
d381 2
a382 1
                              Object* object, bool* adjust_common_sizes)
d440 1
a440 1
          || object->just_symbols())
d445 1
a445 1
					   to, object);
d485 1
a485 1
					     to, object);
d520 1
a520 1
					     to, object);
d640 1
a640 1
					     to, object);
d749 2
a750 1
// the existing symbol.  OBJECT is where the new symbol was found.
d758 2
a759 1
				     const Symbol* to, Object* object)
d767 21
a787 4
  if (object != NULL)
    objname = object->name().c_str();
  else
    objname = _("command line");
d808 1
a808 1
Symbol_table::should_override_with_special(const Symbol* to)
d812 1
a812 1
  bool ret = Symbol_table::should_override(to, frombits, NULL,
@


1.46
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d40 1
a40 1
Symbol::override_version(const char* aversion)
d42 1
a42 1
  if (aversion == NULL)
d52 1
a52 1
      this->version_ = aversion;
d61 2
a62 2
      gold_assert(this->version_ == aversion || this->version_ == NULL);
      this->version_ = aversion;
d70 1
a70 1
Symbol::override_visibility(elfcpp::STV avisibility)
d77 1
a77 1
  if (avisibility != elfcpp::STV_DEFAULT)
d80 3
a82 3
	this->visibility_ = avisibility;
      else if (this->visibility_ > avisibility)
	this->visibility_ = avisibility;
d92 1
a92 1
		      Object* aobject, const char* aversion)
d95 2
a96 2
  this->u_.from_object.object = aobject;
  this->override_version(aversion);
d103 1
a103 1
  if (aobject->is_dynamic())
d116 1
a116 1
			     Object* aobject, const char* aversion)
d118 1
a118 1
  this->override_base(sym, st_shndx, is_ordinary, aobject, aversion);
d131 1
a131 1
		       Object* aobject, const char* aversion)
d133 1
a133 1
  tosym->override(fromsym, st_shndx, is_ordinary, aobject, aversion);
d141 1
a141 1
	  ssym->override(fromsym, st_shndx, is_ordinary, aobject, aversion);
@


1.45
log
@2009-12-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* resolve.cc (symbol_to_bits): Treat STB_GNU_UNIQUE as STB_GLOBAL.
	(Symbol_table::override_with_special): Likewise.
	(Symbol_table::add_from_object): Likewise.
@
text
@d40 1
a40 1
Symbol::override_version(const char* version)
d42 1
a42 1
  if (version == NULL)
d52 1
a52 1
      this->version_ = version;
d61 2
a62 2
      gold_assert(this->version_ == version || this->version_ == NULL);
      this->version_ = version;
d70 1
a70 1
Symbol::override_visibility(elfcpp::STV visibility)
d77 1
a77 1
  if (visibility != elfcpp::STV_DEFAULT)
d80 3
a82 3
	this->visibility_ = visibility;
      else if (this->visibility_ > visibility)
	this->visibility_ = visibility;
d92 1
a92 1
		      Object* object, const char* version)
d95 2
a96 2
  this->u_.from_object.object = object;
  this->override_version(version);
d103 1
a103 1
  if (object->is_dynamic())
d116 1
a116 1
			     Object* object, const char* version)
d118 1
a118 1
  this->override_base(sym, st_shndx, is_ordinary, object, version);
d131 1
a131 1
		       Object* object, const char* version)
d133 1
a133 1
  tosym->override(fromsym, st_shndx, is_ordinary, object, version);
d141 1
a141 1
	  ssym->override(fromsym, st_shndx, is_ordinary, object, version);
@


1.44
log
@	PR 10860
	* options.h (class General_options): Add --warn-common.
	* resolve.cc (Symbol_table::resolve): Handle --warn-common when
	merging two common symbols.
	(Symbol_table::should_override): Handle --warn-common when merging
	a common symbol with a defined symbol.  Use report_resolve_problem
	for multiple definitions.
	(Symbol_table::report_resolve_problem): New function.
	* symtab.h (class Symbol_table): Declare report_resolve_problem.
@
text
@d181 1
d887 1
@


1.43
log
@	* object.h (class Object): Remove target_ field, and target,
	sized_target, and set_target methods.
	(Object::sized_target): Remove.
	(class Sized_relobj): Update declarations.  Remove sized_target.
	* object.cc (Sized_relobj::setup): Remove target parameter.
	Change all callers.
	(Input_objects::add_object): Don't do anything with the target.
	(make_elf_sized_object): Add punconfigured parameter.  Change all
	callers.  Set or test parameter target.
	* dynobj.cc (Sized_dynobj::target): Remove target parameter.
	Change all callers.
	* parameters.cc (Parameters::set_target): Change parameter type to
	be non-const.
	(Parameters::default_target): Remove.
	(set_parameters_target): Change parameter type to be non-const.
	(parameters_force_valid_target): New function.
	(parameters_clear_target): New function.
	* parameters.h (class Parameters): Update declarations.  Remove
	default_target method.  Add sized_target and clear_target
	methods.  Change target_ to be non-const.
	(set_parameters_target): Update declaration.
	(parameters_force_valid_target): Declare.
	(parameters_clear_target): Declare.
	* readsyms.cc (Read_symbols::do_read_symbols): Pass punconfigured
	as NULL if we aren't searching.
	(Add_symbols::run): Don't check for compatible target.
	* fileread.cc (Input_file::open_binary): Call
	parameters_force_valid_target.
	* gold.cc (queue_middle_tasks): Likewise.
	* plugin.cc (make_sized_plugin_object): Likewise.  Don't call
	set_target on object.
	* dynobj.h (class Sized_dynobj): Update declarations.
	* archive.cc (Archive::get_elf_object_for_member): Return NULL if
	make_elf_object returns NULL.
	(Archive::include_member): Don't check whether object target is
	compatible.
	* output.cc (Output_section::add_input_section): Get target from
	parameters.
	(Output_section::relax_input_section): Likewise.
	* reloc.cc (Sized_relobj::do_gc_process_relocs): Get target from
	parameters.
	(Sized_relobj::do_scan_relocs): Likewise.
	(Sized_relobj::relocate_sections): Likewise.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* symtab.cc (Symbol_table::wrap_symbol): Likewise.  Remove object
	parameter.  Change all callers.
	(Symbol_table::add_from_object): Get target from parameters.
	(Symbol_table::add_from_relobj): Don't check object target.
	(Symbol_table::add_from_dynobj): Likewise.
	(Symbol_table::define_special_symbol): Get target from
	parameters.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/binary_unittest.cc (gold_testsuite): Remove target
	parameter.  Change all callers.  Clear parameter target.
	(Binary_test): Test target here.
	* testsuite/object_unittest.cc (gold_testsuite): Remove
	target_test_pointer parameter.  Change all callers.
	(Object_test): Test target here.
@
text
@d305 1
a308 2
      typename Sized_symbol<size>::Size_type tosize = to->symsize();

a309 1

d315 1
a315 1
      if (adjust_common_sizes && sym.get_st_size() > to->symsize())
d322 18
d441 3
a443 8
      // FIXME: Do a better job of reporting locations.
      gold_error(_("%s: multiple definition of %s"),
		 object != NULL ? object->name().c_str() : _("command line"),
		 to->demangled_name().c_str());
      gold_error(_("%s: previous definition here"),
		 (to->source() == Symbol::FROM_OBJECT
		  ? to->object()->name().c_str()
		  : _("command line")));
d478 6
a483 2
      // definition overrides.  FIXME: We should optionally issue, version a
      // warning.
d513 6
a518 1
      // object.  FIXME: We should optionally issue a warning.
d634 5
d744 38
@


1.42
log
@	* resolve.cc (Symbol_table::resolve): Don't complain about defined
	symbols in shared libraries overridden by hidden or internal symbols
	in the main program.
@
text
@d247 1
a247 1
  if (object->target()->has_resolve())
d250 1
a250 1
      sized_target = object->sized_target<size, big_endian>();
@


1.42.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@d247 1
a247 1
  if (parameters->target().has_resolve())
d250 1
a250 1
      sized_target = parameters->sized_target<size, big_endian>();
@


1.42.2.2
log
@	PR 10860
	* options.h (class General_options): Add --warn-common.
	* resolve.cc (Symbol_table::resolve): Handle --warn-common when
	merging two common symbols.
	(Symbol_table::should_override): Handle --warn-common when merging
	a common symbol with a defined symbol.  Use report_resolve_problem
	for multiple definitions.
	(Symbol_table::report_resolve_problem): New function.
	* symtab.h (class Symbol_table): Declare report_resolve_problem.
@
text
@a304 1
  typename Sized_symbol<size>::Size_type tosize = to->symsize();
d308 2
d311 1
d317 1
a317 1
      if (adjust_common_sizes && sym.get_st_size() > tosize)
a323 18
  if (adjust_common_sizes && parameters->options().warn_common())
    {
      if (tosize > sym.get_st_size())
	Symbol_table::report_resolve_problem(false,
					     _("common of '%s' overriding "
					       "smaller common"),
					     to, object);
      else if (tosize < sym.get_st_size())
	Symbol_table::report_resolve_problem(false,
					     _("common of '%s' overidden by "
					       "larger common"),
					     to, object);
      else
	Symbol_table::report_resolve_problem(false,
					     _("multiple common of '%s'"),
					     to, object);
    }

d425 8
a432 3
      Symbol_table::report_resolve_problem(true,
					   _("multiple definition of '%s'"),
					   to, object);
d467 2
a468 6
      // definition overrides.
      if (parameters->options().warn_common())
	Symbol_table::report_resolve_problem(false,
					     _("definition of '%s' overriding "
					       "common"),
					     to, object);
d498 1
a498 6
      // object.
      if (parameters->options().warn_common())
	Symbol_table::report_resolve_problem(false,
					     _("definition of '%s' overriding "
					       "dynamic common definition"),
					     to, object);
a613 5
      if (parameters->options().warn_common())
	Symbol_table::report_resolve_problem(false,
					     _("common '%s' overridden by "
					       "previous definition"),
					     to, object);
a718 38
// Issue an error or warning due to symbol resolution.  IS_ERROR
// indicates an error rather than a warning.  MSG is the error
// message; it is expected to have a %s for the symbol name.  TO is
// the existing symbol.  OBJECT is where the new symbol was found.

// FIXME: We should have better location information here.  When the
// symbol is defined, we should be able to pull the location from the
// debug info if there is any.

void
Symbol_table::report_resolve_problem(bool is_error, const char* msg,
				     const Symbol* to, Object* object)
{
  std::string demangled(to->demangled_name());
  size_t len = strlen(msg) + demangled.length() + 10;
  char* buf = new char[len];
  snprintf(buf, len, msg, demangled.c_str());

  const char* objname;
  if (object != NULL)
    objname = object->name().c_str();
  else
    objname = _("command line");

  if (is_error)
    gold_error("%s: %s", objname, buf);
  else
    gold_warning("%s: %s", objname, buf);

  delete[] buf;

  if (to->source() == Symbol::FROM_OBJECT)
    objname = to->object()->name().c_str();
  else
    objname = _("command line");
  gold_info("%s: %s: previous definition here", program_name, objname);
}

@


1.41
log
@	PR 10471
	* resolve.cc (Symbol_table::resolve): Check for references from
	dynamic objects to hidden and internal symbols.
	* testsuite/Makefile.am (hidden_test.sh): New test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/hidden_test.sh: New script.
	* testsuite/hidden_test_1.c: New test source.
	* testsuite/hidden_test_main.c: New test source.
@
text
@d260 3
a262 2
  else if (to->visibility() == elfcpp::STV_HIDDEN
           || to->visibility() == elfcpp::STV_INTERNAL)
@


1.40
log
@	* layout.cc (Layout::make_output_section): Call
	Target::new_output_section.
	(Layout::attach_allocated_section_to_segment): Put large section
	sections in a separate load segment with the large segment flag
	set.
	(Layout::segment_precedes): Sort large data segments after other
	load segments.
	(align_file_offset): New static function.
	(Layout::set_segment_offsets): Use align_file_offset.
	* output.h (class Output_section): Add is_small_section_ and
	is_large_section_ fields.
	(Output_section::is_small_section): New function.
	(Output_section::set_is_small_section):  New function.
	(Output_section::is_large_section): New function.
	(Output_section::set_is_large_section): New function.
	(Output_section::is_large_data_section): New function.
	(class Output_segment): Add is_large_data_segment_ field.
	(Output_segment::is_large_data_segment): New function.
	(Output_segment::set_is_large_data_segment): New function.
	* output.cc (Output_section::Output_section): Initialize new
	fields.
	(Output_segment::Output_segment): Likewise.
	(Output_segment::add_output_section): Add assertion that large
	data sections always go in large data segments.  Force small data
	sections to the end of the list of data sections.  Force small BSS
	sections to the start of the list of BSS sections.  For large BSS
	sections to the end of the list of BSS sections.
	* symtab.h (class Symbol): Declare is_common_shndx.
	(Symbol::is_defined): Check Symbol::is_common_shndx.
	(Symbol::is_common): Likewise.
	(class Symbol_table): Define enum Commons_section_type.  Update
	declarations.  Add small_commons_ and large_commons_ fields.
	* symtab.cc (Symbol::is_common_shndx): New function.
	(Symbol_table::Symbol_table): Initialize new fields.
	(Symbol_table::add_from_object): Put small and large common
	symbols in the right list.
	(Symbol_table::sized_finalized_symbol): Check
	Symbol::is_common_shndx.
	(Symbol_table::sized_write_globals): Likewise.
	* common.cc (Symbol_table::do_allocate_commons): Allocate new
	common symbol lists.  Don't call do_allocate_commons_list if the
	list is empty.
	(Symbol_table::do_allocate_commons_list): Remove is_tls
	parameter.  Add comons_section_type parameter.  Change all
	callers.  Handle small and large common symbols.
	* object.cc (Sized_relobj::do_finalize_local_symbols): Check
	Symbol::is_common_shndx.
	* resolve.cc (symbol_to_bits): Likewise.
	* target.h (Target::small_common_shndx): New function.
	(Target::small_common_section_flags): New function.
	(Target::large_common_shndx): New function.
	(Target::large_common_section_flags): New function.
	(Target::new_output_section): New function.
	(Target::Target_info): Add small_common_shndx, large_common_shndx,
	small_common_section_flags, and large_common_section_flags
	fields.
	(Target::do_new_output_section): New virtual function.
	* arm.cc (Target_arm::arm_info): Initialize new fields.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info) [all versions]:
	Likewise.
	* sparc.c (Target_sparc::sparc_info) [all versions]: Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	(Target_x86_64::do_new_output_section): New function.
	* configure.ac: Define conditional MCMODEL_MEDIUM.
	* testsuite/Makefile.am (check_PROGRAMS): Add large.
	(large_SOURCES, large_CFLAGS, large_DEPENDENCIES): Define.
	(large_LDFLAGS): Define.
	* testsuite/large.c: New file.
	* testsuite/testfile.cc (Target_test::test_target_info):
	Initialize new fields.
	* configure, testsuite/Makefile.in: Rebuild.
@
text
@d260 14
@


1.39
log
@	PR 9836
	* symtab.cc (Symbol_table::add_from_object): If the visibility is
	hidden or internal, force the symbol to be local.
	* resolve.cc (Symbol::override_visibility): Define.
	(Symbol::override_base): Use override_visibility.
	(Symbol_table::resolve): Likewise.
	(Symbol::override_base_with_special): Likewise.
	(Symbol_table::override_with_special): If the visibility is hidden
	or internal, force the symbol to be local.
	* symtab.h (class Symbol): Add set_visibility and
	override_visibility.
	* testsuite/ver_test_1.sh: New file.
	* testsuite/Makefile.am (check_SCRIPTS): Add ver_test_1.sh.
	(check_DATA): Add ver_test_1.syms.
	(ver_test_1.syms): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d220 2
@


1.38
log
@Add plugin functionality for link-time optimization (LTO).

include/:
	* plugin-api.h: New file.

gold/:
	* configure.ac (plugins): Add --enable-plugins option.
	* configure: Regenerate.
	* config.in: Regenerate.
	* Makefile.am (LIBDL): New variable.
	(CCFILES): Add plugin.cc.
	(HFILES): Add plugin.h.
	(ldadd_var): Add LIBDL.
	* Makefile.in: Regenerate.

	* archive.cc: Include "plugin.h".
	(Archive::setup): Don't preread archive symbols when using a plugin.
	(Archive::get_file_and_offset): Add memsize parameter.  Change callers.
	(Archive::get_elf_object_for_member): Call plugin hooks for claiming
	files.
	(Archive::include_member): Add symbols from plugin objects.
	* archive.h (Archive::get_file_and_offset): Add memsize parameter.
	* descriptors.cc (Descriptors::open): Check for file descriptors
	abandoned by plugins.
	(Descriptors::claim_for_plugin): New function.
	* descriptors.h (Descriptors::claim_for_plugin): New function.
	(Open_descriptor::is_claimed): New field.
	(claim_descriptor_for_plugin): New function.
	* fileread.cc (File_read::claim_for_plugin): New function.
	* fileread.h (File_read::claim_for_plugin): New function.
	(File_read::descriptor): New function.
	* gold.cc: Include "plugin.h".
	(queue_initial_tasks): Add task to call plugin hooks for generating
	new object files.
	* main.cc: Include "plugin.h".
	(main): Load plugin libraries.
	* object.h (Pluginobj): Declare.
	(Object::pluginobj): New function.
	(Object::do_pluginobj): New function.
	(Object::set_target): New function.
	* options.cc: Include "plugin.h".
	(General_options::parse_plugin): New function.
	(General_options::General_options): Initialize plugins_ field.
	(General_options::add_plugin): New function.
	* options.h (Plugin_manager): Declare.
	(General_options): Add --plugin option.
	(General_options::has_plugins): New function.
	(General_options::plugins): New function.
	(General_options::add_plugin): New function.
	(General_options::plugins_): New field.
	* plugin.cc: New file.
	* plugin.h: New file.
	* readsyms.cc: Include "plugin.h".
	(Read_symbols::do_read_symbols): Check for archive before checking
	for ELF file.  Call plugin hooks to claim files.
	* resolve.cc (Symbol_table::resolve): Record when symbol is referenced
	from a real object file; force override when processing replacement
	files.
	* symtab.cc (Symbol::init_fields): Initialize in_real_elf_ field.
	(Symbol::init_base_object): Likewise.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): Likewise.
	(Symbol::output_section): Assert that object is not a plugin.
	(Symbol_table::add_from_pluginobj): New function.
	(Symbol_table::sized_finalize_symbol): Treat symbols from plugins as
	undefined.
	(Symbol_table::sized_write_globals): Likewise.
	(Symbol_table::add_from_pluginobj): Instantiate template.
	* symtab.h (Sized_pluginobj): Declare.
	(Symbol::in_real_elf): New function.
	(Symbol::set_in_real_elf): New function.
	(Symbol::in_real_elf_): New field.
	(Symbol_table::add_from_pluginobj): New function.

	* testsuite/Makefile.am (AM_CFLAGS): New variable.
	(LIBDL): New variable.
	(LDADD): Add LIBDL.
	(check_PROGRAMS): Add plugin_test_1 and plugin_test_2.
	(check_SCRIPTS): Add plugin_test_1.sh and plugin_test_2.sh.
	(check_DATA): Add plugin_test_1.err and plugin_test_2.err.
	(MOSTLYCLEANFILES): Likewise.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/plugin_test.c: New file.
	* testsuite/plugin_test_1.sh: New file.
	* testsuite/plugin_test_2.sh: New file.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d66 20
d101 1
a101 1
  this->visibility_ = sym.get_st_visibility();
d302 3
d747 1
a747 1
  this->visibility_ = from->visibility_;
d802 6
a807 1
  if (tosym->binding() == elfcpp::STB_LOCAL)
@


1.37
log
@	* symtab.cc (Symbol_table::resolve): Remove version parameter.
	Change all callers.
	* symtab.h (class Symbol_table): Update declaration.
	* testsuite/ver_test_9.cc: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add ver_test_9.
	(ver_test_9_SOURCES, ver_test_9_DEPENDENCIES): Define.
	(ver_test_9_LDFLAGS, ver_test_9_LDADD): Define.
	(ver_test_9.so, ver_test_9.o): New targets.
	* testsuite/Makefile.in: Rebuild.
@
text
@d29 1
d244 18
@


1.36
log
@	* symtab.c (Symbol::init_base_output_data): Add version
	parameter.  Change all callers.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): Likewise.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Sized_symbol::init_undefined): Likewise.
	(Symbol_table::do_define_in_output_data): If the new symbol has a
	version, mark it as the default.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* symtab.h (class Symbol): Update declarations.
	(class Sized_symbol): Likewise.
	* resolve.cc (Symbol::override_version): New function.
	(Symbol::override_base: Call override_version.
	(Symbol::override_base_with_special): Likewise.
	* testsuite/ver_script_8.script: New file.
	* testsuite/Makefile.am (check_PROGRAMS): Add ver_test_8.
	(ver_test_8_SOURCES, ver_test_8_DEPENDENCIES): Define.
	(ver_test_8_LDFLAGS, ver_test_8_LDADD): Define.
	(ver_test_8_1.so, ver_test_8_2.so): New targets.
@
text
@d213 1
a213 1
// non-ordinary section indexes are mapped to SHN_UNDEF.  VERSION of
@


1.35
log
@	PR 6049
	* options.h (DEFINE_set): Add VARNAME_begin and VARNAME_end
	functions.
	(class General_options): Remove existing --undefined, and add
	--no-undefined instead.  Add new --undefined as synonym for -u.
	* archive.cc (Archive::add_symbols): Check whether symbol was
	named with -u.
	* gold.cc (queue_middle_tasks): Add -u symbols to symbol table.
	* symtab.h (class Symbol): Rename CONSTANT to IS_CONSTANT; change
	all uses.  Add IS_UNDEFINED.  Update declarations to split
	different versions of init_base.  Declare init_base_undefined.
	(Symbol::is_defined): Handle IS_UNDEFINED.
	(Symbol::is_undefined): Likewise.
	(Symbol::is_weak_undefined): Call is_undefined.
	(Symbol::is_absolute): Handle IS_CONSTANT.
	(class Sized_symbol): Update declarations to split different
	versions of init.  Declare init_undefined.
	(class Symbol_table): Declare new functions.
	* symtab.cc (Symbol::init_base_object): Rename from init_base.
	Change all callers.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::init_base_undefined): New function.
	(Sized_symbol::init_object): Rename from init.  Change all
	callers.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Sized_symbol::init_undefined): New function.
	(Symbol_table::add_undefined_symbols_from_command_line): New
	function.
	(Symbol_table::do_add_undefined_symbols_from_command_line): New
	function.
	(Symbol::final_value_is_known): Handle IS_UNDEFINED.
	(Symbol::output_section): Likewise.
	(Symbol::set_output_section): Likewise.
	(Symbol_table::sized_finalize_symbol): Likewise.
	(Symbol_table::sized_write_globals): Likewise.
	* resolve.cc (Symbol_table::should_override): Likewise.
	(Symbol::override_base_with_special): Likewise.
@
text
@d35 30
d75 1
a75 5
  if (version != NULL && this->version() != version)
    {
      gold_assert(this->version() == NULL);
      this->version_ = version;
    }
d702 1
a702 6
  if (from->version_ != NULL && this->version_ != from->version_)
    {
      gold_assert(this->version_ == NULL);
      this->version_ = from->version_;
    }

@


1.34
log
@	* object.cc (Xindex::initialize_symtab_xindex): New function.
	(Xindex::read_symtab_xindex): New function.
	(Xindex::sym_xindex_to_shndx): New function.
	(Sized_relobj::find_symtab): Pick up SHT_SYMTAB_SHNDX section if
	available.
	(Sized_relobj::do_initialize_xindex): New function.
	(Sized_relobj::do_read_symbols): Adjust section links.
	(Sized_relobj::symbol_section_and_value): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::include_section_group): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_layout): Adjust section links.
	(Sized_relobj::do_count_local_symbols): Adjust section links and
	symbol section indexes.
	(Sized_relobj::do_finalize_local_symbols): Distinguish between
	ordinary and special symbols.
	(Sized_relobj::write_local_symbols): Add symtab_xindex and
	dynsym_xindex parameters.  Change all callers.  Adjust section
	links.  Use SHN_XINDEX when needed.
	(Sized_relobj::get_symbol_location_info): Adjust section links.
	Don't get fooled by special symbols.
	* object.h (class Xindex): Define.
	(class Object): Add xindex_ parameter.  Declare virtual functoin
	do_initialize_xindex.
	(Object::adjust_sym_shndx): New function.
	(Object::set_xindex): New protected function.
	(class Symbol_value): Add is_ordinary_shndx_ field.
	(Symbol_value::Symbol_value): Initialize is_ordinary_shndx_.
	(Symbol_value::value): Assert ordinary section.
	(Symbol_value::initialize_input_to_output_map): Likewise.
	(Symbol_value::set_input_shndx): Add is_ordinary parameter.
	Change all callers.
	(Symbol_value::input_shndx): Add is_ordinary parameter.  Change
	all callers.
	(class Sized_relobj): Update declarations.
	(Sized_relobj::local_symbol_input_shndx): Add is_ordinary
	parameter.  Change all callers.
	(Sized_relobj::adjust_shndx): New function.
	* dynobj.cc (Sized_dynobj::Sized_dynobj): Initialize dynsym_shndx_
	field.
	(Sized_dynobj::find_dynsym_sections): Remove pdynsym_shndx
	parameter.  Change all callers.  Pick up SHT_DYNSYM_SHNDX section
	for SHT_DYNSYM section if available.  Set dynsym_shndx_ field.
	(Sized_dynobj::read_dynsym_section): Adjust section links.
	(Sized_dynobj::read_dynamic): Likewise.
	(Sized_dynobj::do_read_symbols): Use dynsym_shndx_ field.  Adjust
	section links.
	(Sized_dynobj::do_initialize_xindex): New function.
	* dynobj.h (class Sized_dynobj): Add dynsym_shndx_ field.  Declare
	do_initialize_xindex.
	(Sized_dynobj::adjust_shndx): New function.
	* layout.cc (Layout::Layout): Initialize symtab_xindex_ and
	dynsym_xindex_ fields.
	(Layout::finalize): Add a call to set_section_indexes before
	creating the symtab sections.
	(Layout::set_section_indexes): Don't do anything if the section
	already has a section index.
	(Layout::create_symtab_sections): Add shnum parameter.  Change
	caller.  Create .symtab_shndx section if needed.
	(Layout::create_shdrs): Add shstrtab_section parameter.  Change
	caller.
	(Layout::allocated_output_section_count): New function.
	(Layout::create_dynamic_symtab): Create .dynsym_shndx section if
	needed.
	* layout.h (class Layout): Add symtab_xindex_ and dynsym_xindex_
	fields.  Update declarations.
	(Layout::symtab_xindex): New function.
	(Layout::dynsym_xindex): New function.
	(class Write_symbols_task): Add layout_ field.
	(Write_symbols_task::Write_symbols_task): Add layout parameter.
	Change caller.
	* output.cc (Output_section_headers::Output_section_headers): Add
	shstrtab_section parameter.  Change all callers.
	(Output_section_headers::do_sized_write): Store overflow values
	for section count and section string table section index in
	section header zero.
	(Output_file_header::do_sized_write): Check for overflow of
	section count and section string table section index.
	(Output_symtab_xindex::do_write): New function.
	(Output_symtab_xindex::endian_do_write): New function.
	* output.h (class Output_section_headers): Add shstrtab_section_.
	Update declarations.
	(class Output_symtab_xindex): Define.
	(Output_section::has_out_shndx): New function.
	* symtab.cc (Symbol::init_fields): Initialize is_ordinary_shndx_
	field.
	(Symbol::init_base): Add st_shndx and is_ordinary parameters.
	Change all callers.
	(Sized_symbol::init): Likewise.
	(Symbol::output_section): Check for ordinary symbol.
	(Symbol_table::add_from_object): Remove orig_sym parameter.  Add
	st_shndx, is_ordinary, and orig_st_shndx parameters.  Change all
	callers.
	(Symbol_table::add_from_relobj): Add symndx_offset parameter.
	Change all callers.  Simplify handling of symbols from sections
	not included in the link.
	(Symbol_table::add_from_dynobj): Handle ordinary symbol
	distinction.
	(Weak_alias_sorter::operator()): Assert that symbols are
	ordinary.
	(Symbol_table::sized_finalize_symbol): Handle ordinary symbol
	distinction.
	(Symbol_table::write_globals): Add symtab_xindex and dynsym_xindex
	parameters.  Change all callers.
	(Symbol_table::sized_write_globals): Likewise.  Handle ordinary
	symbol distinction.  Use SHN_XINDEX when needed.
	(Symbol_table::write_section_symbol): Add symtab_xindex
	parameter.  Change all callers.
	(Symbol_table::sized_write_section_symbol): Likewise.  Use
	SHN_XINDEX when needed.
	* symtab.h (class Symbol): Add is_ordinary_shndx_ field.  Update
	declarations.
	(Symbol::shndx): Add is_ordinary parameter.  Change all callers.
	(Symbol::is_defined): Check is_ordinary.
	(Symbol::is_undefined, Symbol::is_weak_undefined): Likewise.
	(Symbol::is_absolute, Symbol::is_common): Likewise.
	(class Sized_symbol): Update declarations.
	(class Symbol_table): Update declarations.
	* resolve.cc (Symbol::override_base): Add st_shndx and is_ordinary
	parameters.  Change all callers.
	(Sized_symbol::override): Likewise.
	(Symbol_table::override): Likewise.
	(symbol_to_bits): Add is_ordinary parameter.  Change all callers.
	(Symbol_table::resolve): Remove orig_sym parameter.  Add st_shndx,
	is_ordinary, and orig_st_shndx parameters.  Change all callers.
	* copy-relocs.cc (Copy_relocs::emit_copy_reloc): Require symbol
	to be in an ordinary section.
	* dwarf_reader.cc (Sized_dwarf_line_info::symbol_section): Add
	object and is_ordinary parameters.  Change all callers.
	(Sized_dwarf_line_info::read_relocs): Add object parameter.
	Change all callers.  Don't add undefined or non-ordinary symbols
	to reloc_map_.
	(Sized_dwarf_line_info::read_line_mappings): Add object parameter.
	Change all callers.
	* dwarf_reader.h (class Sized_dwarf_line_info): Update
	declarations.
	* ehframe.cc (Eh_frame::read_fde): Check for ordinary symbol.
	* reloc.cc (Sized_relobj::do_read_relocs): Adjust section links.
	(Sized_relobj::relocate_sections): Likewise.
	* target-reloc.h (scan_relocs): Adjust section symbol index.
	(scan_relocatable_relocs): Likewise.
	* i386.cc (Scan::local): Check for ordinary symbols.
	* sparc.cc (Scan::local): Likewise.
	* x86_64.cc (Scan::local): Likewise.
	* testsuite/binary_unittest.cc (Sized_binary_test): Update calls
	to symbol_section_and_value.
	* testsuite/many_sections_test.cc: New file.
	* testsuite/Makefile.am (BUILT_SOURCES): Define.
	(check_PROGRAMS): Add many_sections_test.
	(many_sections_test_SOURCES): Define.
	(many_sections_test_DEPENDENCIES): Define.
	(many_sections_test_LDFLAGS): Define.
	(BUILT_SOURCES): Add many_sections_define.h.
	(many_sections_define.h): New target.
	(BUILT_SOURCES): Add many_sections_check.h.
	(many_sections_check.h): New target.
	(check_PROGRAMS): Add many_sections_r_test.
	(many_sections_r_test_SOURCES): Define.
	(many_sections_r_test_DEPENDENCIES): Define.
	(many_sections_r_test_LDFLAGS): Define.
	(many_sections_r_test_LDADD): Define.
	(many_sections_r_test.o): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d284 4
a287 1
  if (to->source() != Symbol::FROM_OBJECT)
d668 2
a669 1
    case CONSTANT:
@


1.33
log
@	* i386.cc (Target_i386::Got_type): New enum declaration.
	(Target_i386::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_i386::Scan::global): Likewise.
	(Target_i386::Relocate::relocate): Likewise.
	(Target_i386::Relocate::relocate_tls): Likewise.
	* object.h (Got_offset_list): New class.
	(Sized_relobj::local_has_got_offset): Added got_type parameter.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::local_has_tls_got_offset): Removed.
	(Sized_relobj::local_tls_got_offset): Removed.
	(Sized_relobj::set_local_tls_got_offset): Removed.
	(Sized_relobj::Local_got_offsets): Changed to store a list of offsets.
	* output.cc (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* output.h (Output_data_got::add_global): Added got_type parameter.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): New function.
	(Output_data_got::add_global_pair_with_rela): New function.
	(Output_data_got::add_local): Added got_type parameter.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): New function.
	(Output_data_got::add_local_pair_with_rela): New function.
	(Output_data_got::add_global_tls): Removed.
	(Output_data_got::add_global_tls_with_rel): Removed.
	(Output_data_got::add_global_tls_with_rela): Removed.
	(Output_data_got::add_local_tls): Removed.
	(Output_data_got::add_local_tls_with_rel): Removed.
	(Output_data_got::add_local_tls_with_rela): Removed.
	* resolve.cc (Symbol::override_base_with_special): Removed
	reference to has_got_offset_ field.
	* symtab.cc (Symbol::init_fields): Replaced initialization
	of got_offset_ with got_offsets_.  Removed initialization
	of has_got_offset_
	*symtab.h (Symbol::has_got_offset): Aded got_type parameter.
	(Symbol::got_offset): Likewise.
	(Symbol::set_got_offset): Likewise.
	(Symbol::has_tls_got_offset): Removed.
	(Symbol::tls_got_offset): Removed.
	(Symbol::set_tls_got_offset): Removed.
	(Symbol::got_offset_): Removed.
	(Symbol::tls_mod_got_offset_): Removed.
	(Symbol::tls_pair_got_offset_): Removed.
	(Symbol::got_offsets_): New field.
	(Symbol::has_got_offset): Removed.
	(Symbol::has_tls_mod_got_offset): Removed.
	(Symbol::has_tls_pair_got_offset): Removed.
	* x86_64.cc (Target_x86_64::Got_type): New enum declaration.
	(Target_x86_64::Scan::local): Updated callers of Output_data_got
	member functions.
	(Target_x86_64::Scan::global): Likewise.
	(Target_x86_64::Relocate::relocate): Likewise.
	(Target_x86_64::Relocate::relocate_tls): Likewise.
@
text
@d40 1
d50 2
a51 2
  // FIXME: Handle SHN_XINDEX.
  this->u_.from_object.shndx = sym.get_st_shndx();
d68 1
d71 1
a71 1
  this->override_base(sym, object, version);
d83 1
d86 1
a86 1
  tosym->override(fromsym, object, version);
d94 1
a94 1
	  ssym->override(fromsym, object, version);
d127 1
a127 1
	       unsigned int shndx, elfcpp::STT type)
d166 2
a167 1
      bits |= common_flag;
d182 7
a188 5
// we see a symbol.  TO is the pre-existing symbol.  ORIG_SYM is the
// new symbol, seen in OBJECT.  SYM is almost always identical to
// ORIG_SYM, but may be munged (for instance, if we determine the
// symbol is in a to-be-discarded section, we'll set sym's shndx to
// UNDEFINED).  VERSION of the version of SYM.
d194 2
a195 1
		      const elfcpp::Sym<size, big_endian>& orig_sym,
d219 1
a219 1
                                         sym.get_st_shndx(),
d228 1
a228 1
      this->override(to, sym, object, version);
d246 1
a246 2
  // We use orig_sym here because we want the symbol exactly as it
  // appears in the object file, not munged via our future processing.
d248 1
a248 1
      && orig_sym.get_st_bind() == elfcpp::STB_WEAK
d250 4
a253 3
      && orig_sym.get_st_shndx() != elfcpp::SHN_UNDEF
      && to->shndx() != elfcpp::SHN_UNDEF
      && orig_sym.get_st_size() != 0    // Ignore weird 0-sized symbols.
d255 2
a256 2
      && (orig_sym.get_st_type() != to->type()
          || orig_sym.get_st_size() != to->symsize())
d262 3
a264 2
          = { object, orig_sym.get_st_shndx(), orig_sym.get_st_value() };
      Symbol_location toloc = { to->object(), to->shndx(), to->value() };
d284 2
a285 4
  if (to->source() == Symbol::FROM_OBJECT)
    tobits = symbol_to_bits(to->binding(),
			    to->object()->is_dynamic(),
			    to->shndx(),
d288 9
a296 2
    tobits = symbol_to_bits(to->binding(), false, elfcpp::SHN_ABS,
			    to->type());
d749 3
a751 1
    const elfcpp::Sym<32, false>& orig_sym,
d762 3
a764 1
    const elfcpp::Sym<32, true>& orig_sym,
d775 3
a777 1
    const elfcpp::Sym<64, false>& orig_sym,
d788 3
a790 1
    const elfcpp::Sym<64, true>& orig_sym,
@


1.32
log
@Remove gcc 3.2 compatibility hacks.
@
text
@a681 1
  gold_assert(!from->has_got_offset_);
@


1.31
log
@Don't warn about redefinitions from a --just-symbols object.
@
text
@d88 1
a88 3
      Sized_symbol<size>* ssym;
      ssym = this->get_sized_symbol SELECT_SIZE_NAME(size) (sym
							    SELECT_SIZE(size));
d94 1
a94 2
	  ssym = this->get_sized_symbol SELECT_SIZE_NAME(size) (
						sym SELECT_SIZE(size));
d194 1
a194 3
      sized_target = object->sized_target
                     SELECT_SIZE_ENDIAN_NAME(size, big_endian) (
                         SELECT_SIZE_ENDIAN_ONLY(size, big_endian));
d713 1
a713 3
      Sized_symbol<size>* ssym;
      ssym = this->get_sized_symbol SELECT_SIZE_NAME(size) (sym
							    SELECT_SIZE(size));
d719 1
a719 2
	  ssym = this->get_sized_symbol SELECT_SIZE_NAME(size) (
						sym SELECT_SIZE(size));
@


1.30
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d321 8
@


1.29
log
@Originally from Craig Silverstein, with changes: support using a
version script to force symbols to be local.
@
text
@d246 1
a246 1
  if (parameters->detect_odr_violations()
@


1.28
log
@Support assignments and expressions in linker scripts.
@
text
@d683 1
d723 2
@


1.27
log
@From Craig Silverstein: Add support for --demangle.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
d280 9
a288 5
  unsigned int tobits = symbol_to_bits(to->binding(),
                                       (to->source() == Symbol::FROM_OBJECT
                                        && to->object()->is_dynamic()),
                                       to->shndx(),
                                       to->type());
@


1.26
log
@From Craig Silverstein: Rework debug info code a bit, add option for
ODR violations, add test case.
@
text
@d259 1
a259 1
      Symbol_location from_location
d261 3
a263 3
      Symbol_location to_location = { to->object(), to->shndx(), to->value() };
      this->candidate_odr_violations_[to->name()].insert(from_location);
      this->candidate_odr_violations_[to->name()].insert(to_location);
d320 1
a320 1
		 to->name());
@


1.25
log
@From Craig Silverstein: First cut at detecting ODR violations.
@
text
@d246 2
a247 1
  if (orig_sym.get_st_bind() == elfcpp::STB_WEAK
@


1.24
log
@Fix versions of copied symbols.
@
text
@d122 58
d181 5
a185 2
// we see a symbol.  TO is the pre-existing symbol.  SYM is the new
// symbol, seen in OBJECT.  VERSION of the version of SYM.
d191 1
d215 4
a218 47
  unsigned int frombits;
  switch (sym.get_st_bind())
    {
    case elfcpp::STB_GLOBAL:
      frombits = global_flag;
      break;

    case elfcpp::STB_WEAK:
      frombits = weak_flag;
      break;

    case elfcpp::STB_LOCAL:
      gold_error(_("%s: invalid STB_LOCAL symbol %s in external symbols"),
		 object->name().c_str(), to->name());
      frombits = global_flag;
      break;

    default:
      gold_error(_("%s: unsupported symbol binding %d for symbol %s"),
		 object->name().c_str(),
		 static_cast<int>(sym.get_st_bind()), to->name());
      frombits = global_flag;
      break;
    }

  if (!object->is_dynamic())
    frombits |= regular_flag;
  else
    frombits |= dynamic_flag;

  switch (sym.get_st_shndx())
    {
    case elfcpp::SHN_UNDEF:
      frombits |= undef_flag;
      break;

    case elfcpp::SHN_COMMON:
      frombits |= common_flag;
      break;

    default:
      if (sym.get_st_type() == elfcpp::STT_COMMON)
	frombits |= common_flag;
      else
        frombits |= def_flag;
      break;
    }
d236 28
d279 5
a283 45
  unsigned int tobits;
  switch (to->binding())
    {
    case elfcpp::STB_GLOBAL:
      tobits = global_flag;
      break;

    case elfcpp::STB_WEAK:
      tobits = weak_flag;
      break;

    case elfcpp::STB_LOCAL:
      // We should only see externally visible symbols in the symbol
      // table.
      gold_unreachable();

    default:
      // Any target which wants to handle STB_LOOS, etc., needs to
      // define a resolve method.
      gold_unreachable();
    }

  if (to->source() == Symbol::FROM_OBJECT
      && to->object()->is_dynamic())
    tobits |= dynamic_flag;
  else
    tobits |= regular_flag;

  switch (to->shndx())
    {
    case elfcpp::SHN_UNDEF:
      tobits |= undef_flag;
      break;

    case elfcpp::SHN_COMMON:
      tobits |= common_flag;
      break;

    default:
      if (to->type() == elfcpp::STT_COMMON)
	tobits |= common_flag;
      else
        tobits |= def_flag;
      break;
    }
d729 1
d740 1
d751 1
d762 1
@


1.23
log
@Keep track of weak aliases, so that overriding environ works.
@
text
@d623 2
d657 14
@


1.22
log
@Better multiple definition errors.
@
text
@d74 29
d207 1
a207 1
      to->override(sym, object, version);
d668 28
d743 2
a744 1
Sized_symbol<32>::override_with_special(const Sized_symbol<32>*);
d750 2
a751 1
Sized_symbol<64>::override_with_special(const Sized_symbol<64>*);
@


1.21
log
@Remove extraneous newline.
@
text
@d173 2
a174 1
  if (Symbol_table::should_override(to, frombits, &adjust_common_sizes))
d199 1
a199 1
                              bool* adjust_common_sizes)
d280 8
a287 2
      // FIXME: Report locations.
      gold_error(_("multiple definition of %s"), to->name());
d583 2
a584 1
  bool ret = Symbol_table::should_override(to, frombits, &adjust_common_sizes);
@


1.20
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d280 1
a280 1
      gold_error(_("multiple definition of %s\n"), to->name());
@


1.19
log
@From Craig Silverstein: add some internationalization calls.
@
text
@d136 4
a139 4
      fprintf(stderr,
	      _("%s: %s: invalid STB_LOCAL symbol %s in external symbols\n"),
	      program_name, object->name().c_str(), to->name());
      gold_exit(false);
d142 5
a146 5
      fprintf(stderr,
	      _("%s: %s: unsupported symbol binding %d for symbol %s\n"),
	      program_name, object->name().c_str(),
	      static_cast<int>(sym.get_st_bind()), to->name());
      gold_exit(false);
d279 2
a280 3
      fprintf(stderr, _("%s: multiple definition of %s\n"),
	      program_name, to->name());
      // FIXME: Report locations.  Record that we have seen an error.
@


1.18
log
@Add licensing text to every source file.
@
text
@d279 1
a279 1
      fprintf(stderr, "%s: multiple definition of %s\n",
@


1.17
log
@Let special symbols override existing symbols rather than
reinitializing them.
@
text
@d3 20
@


1.16
log
@Add support for --enable-target to control which template
specializations we generate.
@
text
@d54 19
d93 10
a102 5
  // Build a little code for each symbol.
  // Bit 0: 0 for global, 1 for weak.
  // Bit 1: 0 for regular object, 1 for shared object
  // Bits 2-3: 0 for normal, 1 for undefined, 2 for common
  // This gives us values from 0 to 11:
d104 2
a105 18
  enum
  {
    DEF = 0,
    WEAK_DEF = 1,
    DYN_DEF = 2,
    DYN_WEAK_DEF = 3,
    UNDEF = 4,
    WEAK_UNDEF = 5,
    DYN_UNDEF = 6,
    DYN_WEAK_UNDEF = 7,
    COMMON = 8,
    WEAK_COMMON = 9,
    DYN_COMMON = 10,
    DYN_WEAK_COMMON = 11
  };

  int tobits;
  switch (to->binding())
d108 1
a108 1
      tobits = 0;
d112 1
a112 1
      tobits = 1;
d116 4
a119 3
      // We should only see externally visible symbols in the symbol
      // table.
      gold_unreachable();
d122 5
a126 3
      // Any target which wants to handle STB_LOOS, etc., needs to
      // define a resolve method.
      gold_unreachable();
d129 4
a132 3
  if (to->source() == Symbol::FROM_OBJECT
      && to->object()->is_dynamic())
    tobits |= (1 << 1);
d134 1
a134 1
  switch (to->shndx())
d137 1
a137 1
      tobits |= (1 << 2);
d141 1
a141 1
      tobits |= (2 << 2);
d145 4
a148 2
      if (to->type() == elfcpp::STT_COMMON)
	tobits |= (2 << 2);
d152 32
a183 2
  int frombits;
  switch (sym.get_st_bind())
d186 1
a186 1
      frombits = 0;
d190 1
a190 1
      frombits = 1;
d194 3
a196 4
      fprintf(stderr,
	      _("%s: %s: invalid STB_LOCAL symbol %s in external symbols\n"),
	      program_name, object->name().c_str(), to->name());
      gold_exit(false);
d199 3
a201 5
      fprintf(stderr,
	      _("%s: %s: unsupported symbol binding %d for symbol %s\n"),
	      program_name, object->name().c_str(),
	      static_cast<int>(sym.get_st_bind()), to->name());
      gold_exit(false);
d204 3
a206 5
  if (!object->is_dynamic())
    {
      // Record that we've seen this symbol in a regular object.
      to->set_in_reg();
    }
d208 1
a208 2
    {
      frombits |= (1 << 1);
d210 1
a210 5
      // Record that we've seen this symbol in a dynamic object.
      to->set_in_dyn();
    }

  switch (sym.get_st_shndx())
d213 1
a213 1
      frombits |= (1 << 2);
d217 1
a217 1
      frombits |= (2 << 2);
d221 4
a224 2
      if (sym.get_st_type() == elfcpp::STT_COMMON)
	frombits |= (2 << 2);
d238 17
d259 2
a260 2
      fprintf(stderr, "%s: %s: multiple definition of %s\n",
	      program_name, object->name().c_str(), to->name());
d262 1
a262 1
      return;
d273 1
a273 2
      to->override(sym, object, version);
      return;
d281 1
a281 2
      to->override(sym, object, version);
      return;
d289 1
a289 2
      to->override(sym, object, version);
      return;
d298 1
a298 2
      to->override(sym, object, version);
      return;
d304 1
a304 1
      return;
d310 1
a310 2
      to->override(sym, object, version);
      return;
d317 1
a317 2
      to->override(sym, object, version);
      return;
d322 1
a322 1
      return;
d328 1
a328 2
      to->override(sym, object, version);
      return;
d335 1
a335 1
      return;
d342 1
a342 2
      to->override(sym, object, version);
      return;
d350 1
a350 1
      return;
d358 1
a358 1
      return;
d365 1
a365 2
      to->override(sym, object, version);
      return;
d373 1
a373 1
      return;
d381 1
a381 1
      return;
d387 1
a387 2
      to->override(sym, object, version);
      return;
d394 1
a394 1
      return;
d409 1
a409 1
      return;
d424 1
a424 1
      return;
d439 1
a439 1
      return;
d443 1
a443 1
      return;
d450 1
a450 2
      to->override(sym, object, version);
      return;
d457 1
a457 2
      to->override(sym, object, version);
      return;
d461 2
a462 3
      if (sym.get_st_size() > to->symsize())
	to->set_symsize(sym.get_st_size());
      return;
d467 1
a467 2
      to->override(sym, object, version);
      return;
d471 3
a473 8
      {
	// Use the real common symbol, but adjust the size if necessary.
	typename Sized_symbol<size>::Size_type symsize = to->symsize();
	to->override(sym, object, version);
	if (to->symsize() < symsize)
	  to->set_symsize(symsize);
      }
      return;
d481 1
a481 1
      return;
d488 1
a488 2
      to->override(sym, object, version);
      return;
d496 1
a496 1
      return;
d504 1
a504 1
      return;
d511 1
a511 2
      to->override(sym, object, version);
      return;
d518 2
a519 3
      if (sym.get_st_size() > to->symsize())
	to->set_symsize(sym.get_st_size());
      return;
d526 1
a526 1
      return;
d533 1
a533 2
      to->override(sym, object, version);
      return;
d540 23
a562 3
      if (sym.get_st_size() > to->symsize())
	to->set_symsize(sym.get_st_size());
      return;
d564 17
d583 1
d585 25
d654 12
@


1.15
log
@Any symbol which is in both a regular object and a dynamic object
requires an entry in the dynamic symbol table.
@
text
@d523 1
d526 1
a526 1
Symbol_table::resolve<32, true>(
d528 1
a528 1
    const elfcpp::Sym<32, true>& sym,
d531 1
d533 1
d536 1
a536 1
Symbol_table::resolve<32, false>(
d538 1
a538 1
    const elfcpp::Sym<32, false>& sym,
d541 1
d543 1
d546 1
a546 1
Symbol_table::resolve<64, true>(
d548 1
a548 1
    const elfcpp::Sym<64, true>& sym,
d551 1
d553 1
d556 1
a556 1
Symbol_table::resolve<64, false>(
d558 1
a558 1
    const elfcpp::Sym<64, false>& sym,
d561 1
@


1.14
log
@Set in_dyn_ and in_reg_ when overriding a symbol.
@
text
@a191 9
  if ((tobits & (1 << 1)) != (frombits & (1 << 1)))
    {
      // This symbol is seen in both a dynamic object and a regular
      // object.  That means that we need the symbol to go into the
      // dynamic symbol table, so that the dynamic linker can use the
      // regular symbol to override or define the dynamic symbol.
      to->set_needs_dynsym_entry();
    }

@


1.13
log
@Don't emit symbols seen only in dynamic object, don't read duplicate
dynamic object.
@
text
@d35 4
@


1.12
log
@Generate version information.
@
text
@d159 6
a164 1
  if (object->is_dynamic())
@


1.11
log
@Can now dynamically link hello, world.
@
text
@d20 1
a20 1
		      Object* object)
d24 5
d43 1
a43 1
			     Object* object)
d45 1
a45 1
  this->override_base(sym, object);
d52 1
a52 1
// symbol, seen in OBJECT.
d58 1
a58 1
		      Object* object)
d66 1
a66 1
      sized_target->resolve(to, sym, object);
d220 1
a220 1
      to->override(sym, object);
d229 1
a229 1
      to->override(sym, object);
d238 1
a238 1
      to->override(sym, object);
d246 1
a246 1
      // definition overrides.  FIXME: We should optionally issue a
d248 1
a248 1
      to->override(sym, object);
d261 1
a261 1
      to->override(sym, object);
d269 1
a269 1
      to->override(sym, object);
d281 1
a281 1
      to->override(sym, object);
d296 1
a296 1
      to->override(sym, object);
d320 1
a320 1
      to->override(sym, object);
d343 1
a343 1
      to->override(sym, object);
d407 1
a407 1
      to->override(sym, object);
d415 1
a415 1
      to->override(sym, object);
d427 1
a427 1
      to->override(sym, object);
d435 1
a435 1
	to->override(sym, object);
d454 1
a454 1
      to->override(sym, object);
d478 1
a478 1
      to->override(sym, object);
d502 1
a502 1
      to->override(sym, object);
d528 2
a529 1
    Object* object);
d536 2
a537 1
    Object* object);
d544 2
a545 1
    Object* object);
d552 2
a553 1
    Object* object);
@


1.10
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d25 1
a25 1
  this->u_.from_object.shnum = sym.get_st_shndx();
d113 1
a113 1
  switch (to->shnum())
@


1.9
log
@Snapshot.  Includes first cut at output relocation sections.
@
text
@d22 1
a22 1
  assert(this->source_ == FROM_OBJECT);
d101 1
a101 1
      abort();
d106 1
a106 1
      abort();
d510 1
a510 1
      abort();
@


1.8
log
@gcc 3.2.2 portability hacks.
@
text
@d109 2
a110 1
  if (to->object() != NULL && to->object()->is_dynamic())
d176 9
@


1.7
log
@Can now do a full static link of hello, world in C or C++
@
text
@d58 3
a60 2
      sized_target = object->sized_target SELECT_SIZE_ENDIAN_NAME (
	SELECT_SIZE_ENDIAN_ONLY(size, big_endian));
@


1.6
log
@Lay out object file sections when we add the symbols to the symbol
table.
@
text
@d22 4
a25 2
  this->object_ = object;
  this->shnum_ = sym.get_st_shndx(); // FIXME: Handle SHN_XINDEX.
d29 1
a29 1
  this->other_ = sym.get_st_nonvis();
d42 1
a42 1
  this->size_ = sym.get_st_size();
d320 3
d326 4
d403 5
d409 5
d416 8
d429 4
d437 4
d445 3
d453 4
d461 4
d469 4
d478 3
d485 4
d493 4
a496 2
      abort();
      break;
@


1.5
log
@Clean up HAVE_MEMBER_TEMPLATE_SPECIFICATIONS somewhat.
@
text
@d187 4
a190 3
      // Two definitions of the same symbol.  We can't give an error
      // here, because we have not yet discarded linkonce and comdat
      // sections.  FIXME.
@


1.4
log
@Snapshot.  Now able to produce a minimal executable which actually
runs.
@
text
@d56 2
a57 8
#ifdef HAVE_MEMBER_TEMPLATE_SPECIFICATIONS
      sized_target = object->sized_target<size, big_endian>();
#else
      Target* target = object->target();
      assert(target->get_size() == size);
      assert(target->is_big_endian() ? big_endian : !big_endian);
      sized_target = static_cast<Sized_target<size, big_endian>*>(target);
#endif
@


1.3
log
@g++ 3.2.2 portability fixes.
@
text
@d193 3
a195 4
      // Two definitions of the same symbol.
      fprintf(stderr, "%s: %s: multiple definition of %s\n",
	      program_name, object->name().c_str(), to->name());
      // FIXME: Report locations.  Record that we have seen an error.
@


1.2
log
@More symbol resolution code.
@
text
@d55 10
a64 1
      object->sized_target<size, big_endian>()->resolve(to, sym, object);
@


1.1
log
@Another snapshot of the current state of the sources.  Gets to the
point of symbol resolution and can now issue a multiple definition
error.  Also added target selection infrastructure.
@
text
@d13 30
d49 1
a49 1
Symbol_table::resolve(Symbol* to,
d117 2
d148 6
a153 1
    frombits |= (1 << 1);
d166 2
d171 2
d191 9
a199 7
      // In the original SVR4 linker, a weak definition followed by a
      // regular definition was treated as a multiple definition
      // error.  In the Solaris linker and the GNU linker, a weak
      // definition followed by a regular definition causes the
      // regular definition to be ignored.  We are currently
      // compatible with the GNU linker.  In the future we should add
      // a target specific option to change this.  FIXME.
d204 7
d215 5
d224 5
d232 4
d238 5
d247 4
d253 3
d258 4
d267 3
d274 4
d282 3
d290 4
d298 4
d306 3
d322 2
d337 2
d352 2
d367 2
d371 3
d377 5
d386 4
d433 2
d436 2
a437 1
      break;
d448 1
a448 1
    Symbol* to,
d455 1
a455 1
    Symbol* to,
d462 1
a462 1
    Symbol* to,
d469 1
a469 1
    Symbol* to,
@

