head	1.44;
access;
symbols
	binutils-2_24-branch:1.44.0.2
	binutils-2_24-branchpoint:1.44
	binutils-2_21_1:1.39
	binutils-2_23_2:1.41
	binutils-2_23_1:1.41
	binutils-2_23:1.41
	binutils-2_23-branch:1.41.0.2
	binutils-2_23-branchpoint:1.41
	binutils-2_22_branch:1.40.0.4
	binutils-2_22:1.40
	binutils-2_22-branch:1.40.0.2
	binutils-2_22-branchpoint:1.40
	binutils-2_21:1.39
	binutils-2_21-branch:1.39.0.2
	binutils-2_21-branchpoint:1.39
	binutils-2_20_1:1.31
	binutils-2_20:1.31
	binutils-arc-20081103-branch:1.29.0.6
	binutils-arc-20081103-branchpoint:1.29
	binutils-2_20-branch:1.31.0.2
	binutils-2_20-branchpoint:1.31
	dje-cgen-play1-branch:1.30.0.2
	dje-cgen-play1-branchpoint:1.30
	arc-20081103-branch:1.29.0.4
	arc-20081103-branchpoint:1.29
	binutils-2_19_1:1.29
	binutils-2_19:1.29
	binutils-2_19-branch:1.29.0.2
	binutils-2_19-branchpoint:1.29
	binutils_latest_snapshot:1.44
	added-to-binutils:1.28;
locks; strict;
comment	@// @;


1.44
date	2013.05.03.09.30.24;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2013.05.01.19.45.27;	author hjl;	state Exp;
branches;
next	1.42;

1.42
date	2013.04.29.17.15.08;	author ccoutant;	state Exp;
branches;
next	1.41;

1.41
date	2012.02.29.21.22.29;	author ccoutant;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.01.22.05.01;	author ian;	state Exp;
branches;
next	1.39;

1.39
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2010.08.03.20.38.09;	author ccoutant;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.21.21.03.54;	author ccoutant;	state Exp;
branches;
next	1.36;

1.36
date	2010.07.12.17.59.58;	author ccoutant;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.23.07.43.39;	author dougkwan;	state Exp;
branches;
next	1.34;

1.34
date	2010.04.09.00.04.30;	author dougkwan;	state Exp;
branches;
next	1.33;

1.33
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2009.07.09.23.29.55;	author ian;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.23.21.15.08;	author ian;	state Exp;
branches;
next	1.29;

1.29
date	2008.04.08.18.46.43;	author ian;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.13.21.04.21;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2008.03.13.20.58.11;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2007.12.21.21.19.45;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2007.12.20.16.27.30;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.20.01.32.10;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2007.12.20.01.29.04;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.19.01.23.46;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2007.12.19.00.29.28;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2007.12.18.21.24.07;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.18.00.48.04;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.15.01.01.48;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.01.06.34.12;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.30.00.35.27;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.29.20.10.17;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.27.06.13.32;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.22.00.45.46;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.09.07.00.15;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.20.04.35.43;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.19.23.33.37;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.18.17.46.22;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.14.06.49.14;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.12.06.06.34;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.10.06.33.56;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.25.17.50.26;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.23.03.16.47;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.22.05.38.12;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.16.17.42.48;	author iant;	state Exp;
branches;
next	;


desc
@@


1.44
log
@	* merge.cc (Output_merge_string::do_add_input_section): Correct
	scan for number of strings.  Rename vars to avoid shadowing.
	Include missing terminator in input_size_.
@
text
@// merge.cc -- handle section merging for gold

// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cstdlib>
#include <algorithm>

#include "merge.h"
#include "compressed_output.h"

namespace gold
{

// Class Object_merge_map.

// Destructor.

Object_merge_map::~Object_merge_map()
{
  for (Section_merge_maps::iterator p = this->section_merge_maps_.begin();
       p != this->section_merge_maps_.end();
       ++p)
    delete p->second;
}

// Get the Input_merge_map to use for an input section, or NULL.

Object_merge_map::Input_merge_map*
Object_merge_map::get_input_merge_map(unsigned int shndx)
{
  gold_assert(shndx != -1U);
  if (shndx == this->first_shnum_)
    return &this->first_map_;
  if (shndx == this->second_shnum_)
    return &this->second_map_;
  Section_merge_maps::const_iterator p = this->section_merge_maps_.find(shndx);
  if (p != this->section_merge_maps_.end())
    return p->second;
  return NULL;
}

// Get or create the Input_merge_map to use for an input section.

Object_merge_map::Input_merge_map*
Object_merge_map::get_or_make_input_merge_map(const Merge_map* merge_map,
					      unsigned int shndx)
{
  Input_merge_map* map = this->get_input_merge_map(shndx);
  if (map != NULL)
    {
      // For a given input section in a given object, every mapping
      // must be done with the same Merge_map.
      gold_assert(map->merge_map == merge_map);
      return map;
    }

  // We need to create a new entry.
  if (this->first_shnum_ == -1U)
    {
      this->first_shnum_ = shndx;
      this->first_map_.merge_map = merge_map;
      return &this->first_map_;
    }
  if (this->second_shnum_ == -1U)
    {
      this->second_shnum_ = shndx;
      this->second_map_.merge_map = merge_map;
      return &this->second_map_;
    }

  Input_merge_map* new_map = new Input_merge_map;
  new_map->merge_map = merge_map;
  this->section_merge_maps_[shndx] = new_map;
  return new_map;
}

// Add a mapping.

void
Object_merge_map::add_mapping(const Merge_map* merge_map, unsigned int shndx,
			      section_offset_type input_offset,
			      section_size_type length,
			      section_offset_type output_offset)
{
  Input_merge_map* map = this->get_or_make_input_merge_map(merge_map, shndx);

  // Try to merge the new entry in the last one we saw.
  if (!map->entries.empty())
    {
      Input_merge_entry& entry(map->entries.back());

      // Use section_size_type to avoid signed/unsigned warnings.
      section_size_type input_offset_u = input_offset;
      section_size_type output_offset_u = output_offset;

      // If this entry is not in order, we need to sort the vector
      // before looking anything up.
      if (input_offset_u < entry.input_offset + entry.length)
	{
	  gold_assert(input_offset < entry.input_offset);
	  gold_assert(input_offset_u + length
		      <= static_cast<section_size_type>(entry.input_offset));
	  map->sorted = false;
	}
      else if (entry.input_offset + entry.length == input_offset_u
	       && (output_offset == -1
		   ? entry.output_offset == -1
		   : entry.output_offset + entry.length == output_offset_u))
	{
	  entry.length += length;
	  return;
	}
    }

  Input_merge_entry entry;
  entry.input_offset = input_offset;
  entry.length = length;
  entry.output_offset = output_offset;
  map->entries.push_back(entry);
}

// Get the output offset for an input address.

bool
Object_merge_map::get_output_offset(const Merge_map* merge_map,
				    unsigned int shndx,
				    section_offset_type input_offset,
				    section_offset_type* output_offset)
{
  Input_merge_map* map = this->get_input_merge_map(shndx);
  if (map == NULL
      || (merge_map != NULL && map->merge_map != merge_map))
    return false;

  if (!map->sorted)
    {
      std::sort(map->entries.begin(), map->entries.end(),
		Input_merge_compare());
      map->sorted = true;
    }

  Input_merge_entry entry;
  entry.input_offset = input_offset;
  std::vector<Input_merge_entry>::const_iterator p =
    std::lower_bound(map->entries.begin(), map->entries.end(),
		     entry, Input_merge_compare());
  if (p == map->entries.end() || p->input_offset > input_offset)
    {
      if (p == map->entries.begin())
	return false;
      --p;
      gold_assert(p->input_offset <= input_offset);
    }

  if (input_offset - p->input_offset
      >= static_cast<section_offset_type>(p->length))
    return false;

  *output_offset = p->output_offset;
  if (*output_offset != -1)
    *output_offset += (input_offset - p->input_offset);
  return true;
}

// Return whether this is the merge map for section SHNDX.

inline bool
Object_merge_map::is_merge_section_for(const Merge_map* merge_map,
				       unsigned int shndx)
{
  Input_merge_map* map = this->get_input_merge_map(shndx);
  return map != NULL && map->merge_map == merge_map;
}

// Initialize a mapping from input offsets to output addresses.

template<int size>
void
Object_merge_map::initialize_input_to_output_map(
    unsigned int shndx,
    typename elfcpp::Elf_types<size>::Elf_Addr starting_address,
    Unordered_map<section_offset_type,
		  typename elfcpp::Elf_types<size>::Elf_Addr>* initialize_map)
{
  Input_merge_map* map = this->get_input_merge_map(shndx);
  gold_assert(map != NULL);

  gold_assert(initialize_map->empty());
  // We know how many entries we are going to add.
  // reserve_unordered_map takes an expected count of buckets, not a
  // count of elements, so double it to try to reduce collisions.
  reserve_unordered_map(initialize_map, map->entries.size() * 2);

  for (Input_merge_map::Entries::const_iterator p = map->entries.begin();
       p != map->entries.end();
       ++p)
    {
      section_offset_type output_offset = p->output_offset;
      if (output_offset != -1)
	output_offset += starting_address;
      else
	{
	  // If we see a relocation against an address we have chosen
	  // to discard, we relocate to zero.  FIXME: We could also
	  // issue a warning in this case; that would require
	  // reporting this somehow and checking it in the routines in
	  // reloc.h.
	  output_offset = 0;
	}
      initialize_map->insert(std::make_pair(p->input_offset, output_offset));
    }
}

// Class Merge_map.

// Add a mapping for the bytes from OFFSET to OFFSET + LENGTH in input
// section SHNDX in object OBJECT to an OUTPUT_OFFSET in merged data
// in an output section.

void
Merge_map::add_mapping(Relobj* object, unsigned int shndx,
		       section_offset_type offset, section_size_type length,
		       section_offset_type output_offset)
{
  gold_assert(object != NULL);
  Object_merge_map* object_merge_map = object->merge_map();
  if (object_merge_map == NULL)
    {
      object_merge_map = new Object_merge_map();
      object->set_merge_map(object_merge_map);
    }

  object_merge_map->add_mapping(this, shndx, offset, length, output_offset);
}

// Return the output offset for an input address.  The input address
// is at offset OFFSET in section SHNDX in OBJECT.  This sets
// *OUTPUT_OFFSET to the offset in the merged data in the output
// section.  This returns true if the mapping is known, false
// otherwise.

bool
Merge_map::get_output_offset(const Relobj* object, unsigned int shndx,
			     section_offset_type offset,
			     section_offset_type* output_offset) const
{
  Object_merge_map* object_merge_map = object->merge_map();
  if (object_merge_map == NULL)
    return false;
  return object_merge_map->get_output_offset(this, shndx, offset,
					     output_offset);
}

// Return whether this is the merge section for SHNDX in OBJECT.

bool
Merge_map::is_merge_section_for(const Relobj* object, unsigned int shndx) const
{
  Object_merge_map* object_merge_map = object->merge_map();
  if (object_merge_map == NULL)
    return false;
  return object_merge_map->is_merge_section_for(this, shndx);
}

// Class Output_merge_base.

// Return the output offset for an input offset.  The input address is
// at offset OFFSET in section SHNDX in OBJECT.  If we know the
// offset, set *POUTPUT and return true.  Otherwise return false.

bool
Output_merge_base::do_output_offset(const Relobj* object,
				    unsigned int shndx,
				    section_offset_type offset,
				    section_offset_type* poutput) const
{
  return this->merge_map_.get_output_offset(object, shndx, offset, poutput);
}

// Return whether this is the merge section for SHNDX in OBJECT.

bool
Output_merge_base::do_is_merge_section_for(const Relobj* object,
					   unsigned int shndx) const
{
  return this->merge_map_.is_merge_section_for(object, shndx);
}

// Record a merged input section for script processing.

void
Output_merge_base::record_input_section(Relobj* relobj, unsigned int shndx)
{
  gold_assert(this->keeps_input_sections_ && relobj != NULL);
  // If this is the first input section, record it.  We need do this because
  // this->input_sections_ is unordered.
  if (this->first_relobj_ == NULL)
    {
      this->first_relobj_ = relobj;
      this->first_shndx_ = shndx;
    }

  std::pair<Input_sections::iterator, bool> result =
    this->input_sections_.insert(Section_id(relobj, shndx));
  // We should insert a merge section once only.
  gold_assert(result.second);
}

// Class Output_merge_data.

// Compute the hash code for a fixed-size constant.

size_t
Output_merge_data::Merge_data_hash::operator()(Merge_data_key k) const
{
  const unsigned char* p = this->pomd_->constant(k);
  section_size_type entsize =
    convert_to_section_size_type(this->pomd_->entsize());

  // Fowler/Noll/Vo (FNV) hash (type FNV-1a).
  if (sizeof(size_t) == 8)
    {
      size_t result = static_cast<size_t>(14695981039346656037ULL);
      for (section_size_type i = 0; i < entsize; ++i)
	{
	  result &= (size_t) *p++;
	  result *= 1099511628211ULL;
	}
      return result;
    }
  else
    {
      size_t result = 2166136261UL;
      for (section_size_type i = 0; i < entsize; ++i)
	{
	  result ^= (size_t) *p++;
	  result *= 16777619UL;
	}
      return result;
    }
}

// Return whether one hash table key equals another.

bool
Output_merge_data::Merge_data_eq::operator()(Merge_data_key k1,
					     Merge_data_key k2) const
{
  const unsigned char* p1 = this->pomd_->constant(k1);
  const unsigned char* p2 = this->pomd_->constant(k2);
  return memcmp(p1, p2, this->pomd_->entsize()) == 0;
}

// Add a constant to the end of the section contents.

void
Output_merge_data::add_constant(const unsigned char* p)
{
  section_size_type entsize = convert_to_section_size_type(this->entsize());
  section_size_type addralign =
    convert_to_section_size_type(this->addralign());
  section_size_type addsize = std::max(entsize, addralign);
  if (this->len_ + addsize > this->alc_)
    {
      if (this->alc_ == 0)
	this->alc_ = 128 * addsize;
      else
	this->alc_ *= 2;
      this->p_ = static_cast<unsigned char*>(realloc(this->p_, this->alc_));
      if (this->p_ == NULL)
	gold_nomem();
    }

  memcpy(this->p_ + this->len_, p, entsize);
  if (addsize > entsize)
    memset(this->p_ + this->len_ + entsize, 0, addsize - entsize);
  this->len_ += addsize;
}

// Add the input section SHNDX in OBJECT to a merged output section
// which holds fixed length constants.  Return whether we were able to
// handle the section; if not, it will be linked as usual without
// constant merging.

bool
Output_merge_data::do_add_input_section(Relobj* object, unsigned int shndx)
{
  section_size_type len;
  bool is_new;
  const unsigned char* p = object->decompressed_section_contents(shndx, &len,
								 &is_new);

  section_size_type entsize = convert_to_section_size_type(this->entsize());

  if (len % entsize != 0)
    {
      if (is_new)
	delete[] p;
      return false;
    }

  this->input_count_ += len / entsize;

  for (section_size_type i = 0; i < len; i += entsize, p += entsize)
    {
      // Add the constant to the section contents.  If we find that it
      // is already in the hash table, we will remove it again.
      Merge_data_key k = this->len_;
      this->add_constant(p);

      std::pair<Merge_data_hashtable::iterator, bool> ins =
	this->hashtable_.insert(k);

      if (!ins.second)
	{
	  // Key was already present.  Remove the copy we just added.
	  this->len_ -= entsize;
	  k = *ins.first;
	}

      // Record the offset of this constant in the output section.
      this->add_mapping(object, shndx, i, entsize, k);
    }

  // For script processing, we keep the input sections.
  if (this->keeps_input_sections())
    record_input_section(object, shndx);

  if (is_new)
    delete[] p;

  return true;
}

// Set the final data size in a merged output section with fixed size
// constants.

void
Output_merge_data::set_final_data_size()
{
  // Release the memory we don't need.
  this->p_ = static_cast<unsigned char*>(realloc(this->p_, this->len_));
  // An Output_merge_data object may be empty and realloc is allowed
  // to return a NULL pointer in this case.  An Output_merge_data is empty
  // if all its input sections have sizes that are not multiples of entsize.
  gold_assert(this->p_ != NULL || this->len_ == 0);
  this->set_data_size(this->len_);
}

// Write the data of a merged output section with fixed size constants
// to the file.

void
Output_merge_data::do_write(Output_file* of)
{
  of->write(this->offset(), this->p_, this->len_);
}

// Write the data to a buffer.

void
Output_merge_data::do_write_to_buffer(unsigned char* buffer)
{
  memcpy(buffer, this->p_, this->len_);
}

// Print merge stats to stderr.

void
Output_merge_data::do_print_merge_stats(const char* section_name)
{
  fprintf(stderr,
	  _("%s: %s merged constants size: %lu; input: %zu; output: %zu\n"),
	  program_name, section_name,
	  static_cast<unsigned long>(this->entsize()),
	  this->input_count_, this->hashtable_.size());
}

// Class Output_merge_string.

// Add an input section to a merged string section.

template<typename Char_type>
bool
Output_merge_string<Char_type>::do_add_input_section(Relobj* object,
						     unsigned int shndx)
{
  section_size_type sec_len;
  bool is_new;
  const unsigned char* pdata = object->decompressed_section_contents(shndx,
								     &sec_len,
								     &is_new);

  const Char_type* p = reinterpret_cast<const Char_type*>(pdata);
  const Char_type* pend = p + sec_len / sizeof(Char_type);
  const Char_type* pend0 = pend;

  if (sec_len % sizeof(Char_type) != 0)
    {
      object->error(_("mergeable string section length not multiple of "
		      "character size"));
      if (is_new)
	delete[] pdata;
      return false;
    }

  if (pend[-1] != 0)
    {
      gold_warning(_("%s: last entry in mergeable string section '%s' "
		     "not null terminated"),
		   object->name().c_str(),
		   object->section_name(shndx).c_str());
      // Find the end of the last NULL-terminated string in the buffer.
      while (pend0 > p && pend0[-1] != 0)
	--pend0;
    }

  Merged_strings_list* merged_strings_list =
      new Merged_strings_list(object, shndx);
  this->merged_strings_lists_.push_back(merged_strings_list);
  Merged_strings& merged_strings = merged_strings_list->merged_strings;

  // Count the number of non-null strings in the section and size the list.
  size_t count = 0;
  const Char_type* pt = p;
  while (pt < pend0)
    {
      size_t len = string_length(pt);
      if (len != 0)
	++count;
      pt += len + 1;
    }
  if (pend0 < pend)
    ++count;
  merged_strings.reserve(count + 1);

  // The index I is in bytes, not characters.
  section_size_type i = 0;

  // We assume here that the beginning of the section is correctly
  // aligned, so each string within the section must retain the same
  // modulo.
  uintptr_t init_align_modulo = (reinterpret_cast<uintptr_t>(pdata)
				 & (this->addralign() - 1));
  bool has_misaligned_strings = false;

  while (p < pend0)
    {
      size_t len = string_length(p);

      // Within merge input section each string must be aligned.
      if (len != 0
	  && ((reinterpret_cast<uintptr_t>(p) & (this->addralign() - 1))
	      != init_align_modulo))
	  has_misaligned_strings = true;

      Stringpool::Key key;
      this->stringpool_.add_with_length(p, len, true, &key);

      merged_strings.push_back(Merged_string(i, key));
      p += len + 1;
      i += (len + 1) * sizeof(Char_type);
    }
  if (p < pend)
    {
      size_t len = pend - p;

      Stringpool::Key key;
      this->stringpool_.add_with_length(p, len, true, &key);

      merged_strings.push_back(Merged_string(i, key));

      i += (len + 1) * sizeof(Char_type);
    }

  // Record the last offset in the input section so that we can
  // compute the length of the last string.
  merged_strings.push_back(Merged_string(i, 0));

  this->input_count_ += count;
  this->input_size_ += i;

  if (has_misaligned_strings)
    gold_warning(_("%s: section %s contains incorrectly aligned strings;"
		   " the alignment of those strings won't be preserved"),
		 object->name().c_str(),
		 object->section_name(shndx).c_str());

  // For script processing, we keep the input sections.
  if (this->keeps_input_sections())
    record_input_section(object, shndx);

  if (is_new)
    delete[] pdata;

  return true;
}

// Finalize the mappings from the input sections to the output
// section, and return the final data size.

template<typename Char_type>
section_size_type
Output_merge_string<Char_type>::finalize_merged_data()
{
  this->stringpool_.set_string_offsets();

  for (typename Merged_strings_lists::const_iterator l =
	 this->merged_strings_lists_.begin();
       l != this->merged_strings_lists_.end();
       ++l)
    {
      section_offset_type last_input_offset = 0;
      section_offset_type last_output_offset = 0;
      for (typename Merged_strings::const_iterator p =
	     (*l)->merged_strings.begin();
	   p != (*l)->merged_strings.end();
	   ++p)
	{
	  section_size_type length = p->offset - last_input_offset;
	  if (length > 0)
	    this->add_mapping((*l)->object, (*l)->shndx, last_input_offset,
	    		      length, last_output_offset);
	  last_input_offset = p->offset;
	  if (p->stringpool_key != 0)
	    last_output_offset =
	        this->stringpool_.get_offset_from_key(p->stringpool_key);
	}
      delete *l;
    }

  // Save some memory.  This also ensures that this function will work
  // if called twice, as may happen if Layout::set_segment_offsets
  // finds a better alignment.
  this->merged_strings_lists_.clear();

  return this->stringpool_.get_strtab_size();
}

template<typename Char_type>
void
Output_merge_string<Char_type>::set_final_data_size()
{
  const off_t final_data_size = this->finalize_merged_data();
  this->set_data_size(final_data_size);
}

// Write out a merged string section.

template<typename Char_type>
void
Output_merge_string<Char_type>::do_write(Output_file* of)
{
  this->stringpool_.write(of, this->offset());
}

// Write a merged string section to a buffer.

template<typename Char_type>
void
Output_merge_string<Char_type>::do_write_to_buffer(unsigned char* buffer)
{
  this->stringpool_.write_to_buffer(buffer, this->data_size());
}

// Return the name of the types of string to use with
// do_print_merge_stats.

template<typename Char_type>
const char*
Output_merge_string<Char_type>::string_name()
{
  gold_unreachable();
  return NULL;
}

template<>
const char*
Output_merge_string<char>::string_name()
{
  return "strings";
}

template<>
const char*
Output_merge_string<uint16_t>::string_name()
{
  return "16-bit strings";
}

template<>
const char*
Output_merge_string<uint32_t>::string_name()
{
  return "32-bit strings";
}

// Print merge stats to stderr.

template<typename Char_type>
void
Output_merge_string<Char_type>::do_print_merge_stats(const char* section_name)
{
  char buf[200];
  snprintf(buf, sizeof buf, "%s merged %s", section_name, this->string_name());
  fprintf(stderr, _("%s: %s input bytes: %zu\n"),
	  program_name, buf, this->input_size_);
  fprintf(stderr, _("%s: %s input strings: %zu\n"),
	  program_name, buf, this->input_count_);
  this->stringpool_.print_stats(buf);
}

// Instantiate the templates we need.

template
class Output_merge_string<char>;

template
class Output_merge_string<uint16_t>;

template
class Output_merge_string<uint32_t>;

#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
template
void
Object_merge_map::initialize_input_to_output_map<32>(
    unsigned int shndx,
    elfcpp::Elf_types<32>::Elf_Addr starting_address,
    Unordered_map<section_offset_type, elfcpp::Elf_types<32>::Elf_Addr>*);
#endif

#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
template
void
Object_merge_map::initialize_input_to_output_map<64>(
    unsigned int shndx,
    elfcpp::Elf_types<64>::Elf_Addr starting_address,
    Unordered_map<section_offset_type, elfcpp::Elf_types<64>::Elf_Addr>*);
#endif

} // End namespace gold.
@


1.43
log
@Restore empty string handling

	* merge.cc (Output_merge_string<Char_type>::do_add_input_section):
	Restore empty string handling.
@
text
@d508 1
a508 1
  section_size_type len;
d511 1
a511 1
								     &len,
d515 1
a515 1
  const Char_type* pend = p + len / sizeof(Char_type);
d518 1
a518 1
  if (len % sizeof(Char_type) != 0)
d545 8
a552 5
  for (const Char_type* pt = p, len = string_length(pt);
       pt < pend0;
       pt += len + 1)
    if (len != 0)
      ++count;
d601 1
a601 1
  this->input_size_ += len;
@


1.42
log
@2013-04-29  Alexander Ivchenko  <alexander.ivchenko@@intel.com>

gold/
	* output.cc (Output_section::add_merge_input_section): Allow
	to merge sections if the alignment is more than character size.
	* merge.h (Output_merge_string::Output_merge_string): Remove
	assert.
	* merge.cc (Output_merge_string<Char_type>::do_add_input_section): Count
	only not-null strings. Check the alignment of strings.
	* stringpool.h
	(Stringpool_template<Stringpool_char>::Stringpool_template): Add
	alignment as the argument.
	(Stringpool_template<Stringpool_char>::addralign_): New class member.
	* stringpool.cc (Stringpool_template<Stringpool_char>::new_key_offset):
	Align non-zero length strings according to the addralign_.
	(Stringpool_template<Stringpool_char>::set_string_offsets):
	Updating offsets according to the given alignment.
	* testsuite/Makefile.am (text_section_grouping): Test if string
	literals are getting merged.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/merge_string_literals_1.c: New file.
	* testsuite/merge_string_literals_2.c: Ditto.
	* testsuite/merge_string_literals.sh: Ditto.
@
text
@d568 5
a572 6
      if (len != 0)
	{
	  // Within merge input section each string must be aligned.
	  if ((reinterpret_cast<uintptr_t>(p) & (this->addralign() - 1))
	      != init_align_modulo)
	    has_misaligned_strings = true;
d574 2
a575 2
	  Stringpool::Key key;
	  this->stringpool_.add_with_length(p, len, true, &key);
d577 1
a577 2
	  merged_strings.push_back(Merged_string(i, key));
	}
@


1.41
log
@	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info):
	Call Object::decompressed_section_contents.
	* dwarf_reader.h (Sized_dwarf_line_info::~Sized_dwarf_line_info):
	New dtor.
	(Sized_dwarf_line_info::buffer_start_): New data member.
	* merge.cc (Output_merge_data::do_add_input_section): Call
	Object::decompressed_section_contents.
	(Output_merge_string::do_add_input_section): Likewise.
	* object.cc (need_decompressed_section): New function.
	(build_compressed_section_map): Decompress sections needed later.
	(Sized_relobj_file::do_decompressed_section_contents): New function.
	(Sized_relobj_file::do_discard_decompressed_sections): New function.
	* object.h (Object::decompressed_section_contents): New function.
	(Object::discard_decompressed_sections): New function.
	(Object::do_decompressed_section_contents): New function.
	(Object::do_discard_decompressed_sections): New function.
	(Compressed_section_info): New type.
	(Compressed_section_map): Include decompressed section contents.
	(Sized_relobj_file::do_decompressed_section_contents): New function.
	(Sized_relobj_file::do_discard_decompressed_sections): New function.
@
text
@d543 1
a543 1
  // Count the number of strings in the section and size the list.
d545 5
a549 2
  for (const Char_type* pt = p; pt < pend0; pt += string_length(pt) + 1)
    ++count;
d556 8
d568 6
a573 2
      Stringpool::Key key;
      this->stringpool_.add_with_length(p, len, true, &key);
d575 2
a576 1
      merged_strings.push_back(Merged_string(i, key));
d578 2
d602 6
@


1.40
log
@	PR gold/12571
	* options.h (class General_options): Add
	--ld-generated-unwind-info.
	* ehframe.cc (Fde::write): Add address parameter.  Change all
	callers.  If associated with PLT, fill in address and size.
	(Cie::set_output_offset): Only add merge mapping if there is an
	object.
	(Cie::write): Add address parameter.  Change all callers.
	(Eh_frame::add_ehframe_for_plt): New function.
	* ehframe.h (class Fde): Update declarations.  Move shndx_ and
	input_offset_ fields into union u_, with new plt field.
	(Fde::Fde): Adjust for new union field.
	(Fde::Fde) [Output_data version]: New constructor.
	(Fde::add_mapping): Only add merge mapping if there is an object.
	(class Cie): Update declarations.
	(class Eh_frame): Declare add_ehframe_for_plt.
	* layout.cc (Layout::layout_eh_frame): Break out code into
	make_eh_frame_section, and call it.
	(Layout::make_eh_frame_section): New function.
	(Layout::add_eh_frame_for_plt): New function.
	* layout.h (class Layout): Update declarations.
	* merge.cc (Merge_map::add_mapping): Add assertion.
	* i386.cc: Include "dwarf.h".
	(class Output_data_plt_i386): Make first_plt_entry,
	dyn_first_plt_entry, exec_plt_entry, and dyn_plt_entry const.  Add
	plt_eh_frame_cie_size, plt_eh_frame_fde_size, plt_eh_frame_cie,
	and plt_eh_frame_fde.
	(Output_data_plt_i386::Output_data_plt_i386): Align to 16-byte
	boundary.  Call add_eh_frame_for_plt if appropriate.
	* x86_64.cc: Include "dwarf.h".
	(class Output_data_plt_x86_64): Align to 16-byte boundary.  Make
	first_plt_entry, plt_entry and tlsdesc_plt_entry const.  Add
	plt_eh_frame_cie_size, plt_eh_frame_fde_size, plt_eh_frame_cie,
	and plt_eh_frame_fde.
	(Output_data_plt_x86_64::init): Call add_eh_frame_for_plt if
	appropriate.
@
text
@d409 3
a411 14
  section_size_type uncompressed_size = 0;
  unsigned char* uncompressed_data = NULL;
  const unsigned char* p = object->section_contents(shndx, &len, false);

  if (object->section_is_compressed(shndx, &uncompressed_size))
    {
      uncompressed_data = new unsigned char[uncompressed_size];
      if (!decompress_input_section(p, len, uncompressed_data,
				    uncompressed_size))
	object->error(_("could not decompress section %s"),
		      object->section_name(shndx).c_str());
      p = uncompressed_data;
      len = uncompressed_size;
    }
d417 2
a418 2
      if (uncompressed_data != NULL)
	delete[] uncompressed_data;
d449 2
a450 2
  if (uncompressed_data != NULL)
    delete[] uncompressed_data;
d509 4
a512 14
  section_size_type uncompressed_size = 0;
  unsigned char* uncompressed_data = NULL;
  const unsigned char* pdata = object->section_contents(shndx, &len, false);

  if (object->section_is_compressed(shndx, &uncompressed_size))
    {
      uncompressed_data = new unsigned char[uncompressed_size];
      if (!decompress_input_section(pdata, len, uncompressed_data,
				    uncompressed_size))
	object->error(_("could not decompress section %s"),
		      object->section_name(shndx).c_str());
      pdata = uncompressed_data;
      len = uncompressed_size;
    }
d522 2
a523 2
      if (uncompressed_data != NULL)
	delete[] uncompressed_data;
d588 2
a589 2
  if (uncompressed_data != NULL)
    delete[] uncompressed_data;
@


1.39
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2010 Free Software Foundation, Inc.
d245 1
@


1.38
log
@	* merge.cc (Output_merge_string::do_add_input_section): Count strings
	to reserve space in merged_strings vector. Keep total input size
	for stats.
	(Output_merge_string::do_print_merge_stats): Print total input size.
	* merge.h (Output_merge_string): Add input_size_ field.
	* stringpool.cc (Stringpool_template::string_length): Move
	implementations out of Stringpool_template class and place in
	stringpool.h.
	* stringpool.h (string_length): Move out of Stringpool_template.
@
text
@d148 1
a148 1
				    section_offset_type *output_offset)
@


1.37
log
@	* merge.h (Output_merge_string::Merged_string): Remove object, shndx,
	string, and length fields.
	(Output_merge_string::Merged_strings_list): New type.
	(Output_merge_string::Merged_strings_lists): New typedef.
	(Output_merge_string): Replace merged_strings_ with
	merged_strings_lists_.
	* merge.cc (Output_merge_string::do_add_input_section): Allocate new
	Merged_strings_list per input object and section.  Don't store pointer
	to the string.  Don't store length with each merged string entry.
	(Output_merge_string::finalize_merged_data): Loop over list of merged
	strings lists.  Recompute length of each merged string.
@
text
@d536 1
d547 10
a556 1
  size_t count = 0;
d563 8
d573 13
a585 1
  while (i < len)
d587 1
a587 12
      const Char_type* pl;
      for (pl = p; *pl != 0; ++pl)
	{
	  if (pl >= pend)
	    {
	      gold_warning(_("%s: last entry in mergeable string section '%s' "
			     "not null terminated"),
			   object->name().c_str(),
			   object->section_name(shndx).c_str());
	      break;
	    }
	}
d590 1
a590 1
      this->stringpool_.add_with_length(p, pl - p, true, &key);
a591 1
      section_size_type bytelen_with_null = ((pl - p) + 1) * sizeof(Char_type);
d594 1
a594 3
      p = pl + 1;
      i += bytelen_with_null;
      ++count;
d602 1
d721 3
a723 1
  fprintf(stderr, _("%s: %s input: %zu\n"),
@


1.36
log
@	* compressed_output.cc (zlib_decompress): New function.
	(get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* compressed_output.h (get_uncompressed_size): New function.
	(decompress_input_section): New function.
	* dwarf_reader.cc (Sized_dwarf_line_info::Sized_dwarf_line_info)
	Handle compressed debug sections.
	* layout.cc (is_compressed_debug_section): New function.
	(Layout::output_section_name): Map compressed section names to
	canonical names.
	* layout.h (is_compressed_debug_section): New function.
	(is_debug_info_section): Recognize compressed debug sections.
	* merge.cc: Include compressed_output.h.
	(Output_merge_data::do_add_input_section): Handle compressed
	debug sections.
	(Output_merge_string::do_add_input_section): Handle compressed
	debug sections.
	* object.cc: Include compressed_output.h.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(build_compressed_section_map): New function.
	(Sized_relobj::do_read_symbols): Handle compressed debug sections.
	* object.h (Object::section_is_compressed): New method.
	(Object::do_section_is_compressed): New method.
	(Sized_relobj::Compressed_section_map): New type.
	(Sized_relobj::do_section_is_compressed): New method.
	(Sized_relobj::compressed_sections_): New data member.
	* output.cc (Output_section::add_input_section): Handle compressed
	debug sections.
	* reloc.cc: Include compressed_output.h.
	(Sized_relobj::write_sections): Handle compressed debug sections.
@
text
@d548 5
d571 1
a571 2
      const Char_type* str = this->stringpool_.add_with_length(p, pl - p, true,
							       &key);
d574 1
a574 2
      this->merged_strings_.push_back(Merged_string(object, shndx, i, str,
						    bytelen_with_null, key));
d581 4
d606 4
a609 4
  for (typename Merged_strings::const_iterator p =
	 this->merged_strings_.begin();
       p != this->merged_strings_.end();
       ++p)
d611 17
a627 3
      section_offset_type offset =
	this->stringpool_.get_offset_from_key(p->stringpool_key);
      this->add_mapping(p->object, p->shndx, p->offset, p->length, offset);
d633 1
a633 1
  this->merged_strings_.clear();
@


1.35
log
@2010-05-23  Doug Kwan  <dougkwan@@google.com>

	* arm.cc (Arm_input_section::do_output_offset): Use convert_types
	instead of a cast.
	(Target_arm::apply_cortex_a8_workaround): Rewrite a conditional branch
	with a direct branch, not a conditional branch, to a stub.
	* merge.cc (Output_merge_base::record_input_section): New method
	defintion.
	(Output_merge_data::do_add_input_section): Record input section if
	keeps-input-sections flag is set.
	(Output_merge_string::do_add_input_section): Ditto.
	* merge.h (Output_merge_base::Output_merge_base): Initialize new data
	members KEEPS_INPUT_SECTIONS_, FIRST_RELOBJ_, FIRST_SHNDX_ and
	INPUT_SECTIONS_.
	(Output_merge_base::keeps_input_sections,
	Output_merge_base::set_keeps_input_sections,
	Output_merge_base::first_relobj, Output_merge_base::first_shndx): New
	method definitions.
	(Output_merge_base::Input_sections): New type declaration.
	(Output_merge_base::input_sections_begin,
	Output_merge_base::input_sections_end,
	Output_merge_base::do_set_keeps_input_sections): New method definitions.
	(Output_merge_base::bool keeps_input_sections_,
	Output_merge_base::first_relobj_, Output_merge_base::first_shndx_,
	Output_merge_base::input_sections_): New data members.
	(Output_merge_data::do_set_keeps_input_sections): New method
	defintion.
	(Output_merge_string::do_set_keeps_input_sections): Ditto.
	* output.cc (Output_section::Input_section::relobj): Move method
	defintion from class declaration to here and handle merge sections.
	(Output_section::Input_section::shndx): Ditto.
	(Output_section::Output_section): Remove initializations of removed
	data members and initialize new data member LOOKUP_MAPS_.
	(Output_section::add_input_section): Set keeps-input-sections flag
	for a newly created merge output section as appropriate.  Adjust code
	to use Output_section_lookup_maps class.
	(Output_section::add_relaxed_input_section): Adjst code for lookup
	maps code refactoring.
 	(Output_section::add_merge_input_section): Add a new parameter
	KEEPS_INPUT_SECTION.  Adjust code to use Output_section_lookup_maps
	class.  If adding input section to a newly created merge output
	section fails, remove the new merge section.
	(Output_section::convert_input_sections_in_list_to_relaxed_input_sections):
	Adjust code for use of the Output_section_lookup_maps class.
 	(Output_section::find_merge_section): Ditto.
	(Output_section::build_lookup_maps): New method defintion.
 	(Output_section::find_relaxed_input_section): Adjust code to use
	Output_section_lookup_maps class.
	(Output_section::get_input_sections): Export merge sections.  Adjust
	code to use Output_section_lookup_maps class.
	(Output_section:::add_script_input_section): Adjust code to use
	Output_section_lookup_maps class.  Update lookup maps for merge
	sections also.
	(Output_section::discard_states): Use Output_section_lookup_maps.
	(Output_section::restore_states): Same.
	* output.h (Merge_section_properties): Move class defintion out of
	Output_section.
	(Output_section_lookup_maps): New class.
	(Output_section::Input_section::is_merge_section): New method
	defintion.
	(Output_section::Input_section::relobj): Move defintion out of class
	defintion.  Declare method only.
	(Output_section::Input_section::shndx): Ditto.
	(Output_section::Input_section::output_merge_base): New method defintion.
     	(Output_section::Input_section::u2_.pomb): New union field.
	(Output_section::Merge_section_by_properties_map,
	Output_section::Output_section_data_by_input_section_map,
	Output_section::Ouptut_relaxed_input_section_by_input_section_map):
	Remove types.
   	(Output_section::add_merge_input_section): Add new parameter
	KEEPS_INPUT_SECTIONS.
	(Output_section::build_lookup_maps): New method declaration.
	(Output_section::merge_section_map_,
	Output_section::merge_section_by_properties_map_,
	Output_section::relaxed_input_section_map_,
	Output_section::is_relaxed_input_section_map_valid_): Remove data
	members.
	(Output_section::lookup_maps_): New data member.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d29 1
d408 2
d412 11
d426 5
a430 1
    return false;
d459 3
d519 2
d523 11
d541 2
d584 3
@


1.34
log
@2010-04-08  Doug Kwan  <dougkwan@@google.com>

	* merge.cc (Output_merge_data::set_final_data_size): Handle empty
	Output_merge_data.
	* output.cc (Output_section::add_merge_input_section): Simplify
	code and return status of Output_merge_base::add_input_section.
	Update merge section map only if Output_merge_base::add_input_section
	returns true.
@
text
@d307 20
d437 4
d544 4
@


1.33
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d428 4
a431 1
  gold_assert(this->p_ != NULL);
@


1.32
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d292 1
a292 1
				    section_offset_type off,
d295 1
a295 1
  return this->merge_map_.get_output_offset(object, shndx, off, poutput);
d357 2
a358 2
  section_size_type ent_size = convert_to_section_size_type(this->entsize());
  section_size_type addr_align =
d360 1
a360 1
  section_size_type addsize = std::max(ent_size, addr_align);
d372 3
a374 3
  memcpy(this->p_ + this->len_, p, ent_size);
  if (addsize > ent_size)
    memset(this->p_ + this->len_ + ent_size, 0, addsize - ent_size);
d389 1
a389 1
  section_size_type ent_size = convert_to_section_size_type(this->entsize());
d391 1
a391 1
  if (len % ent_size != 0)
d394 1
a394 1
  this->input_count_ += len / ent_size;
d396 1
a396 1
  for (section_size_type i = 0; i < len; i += ent_size, p += ent_size)
d409 1
a409 1
	  this->len_ -= ent_size;
d414 1
a414 1
      this->add_mapping(object, shndx, i, ent_size, k);
d534 1
a534 1
      section_offset_type soffset =
d536 1
a536 1
      this->add_mapping(p->object, p->shndx, p->offset, p->length, soffset);
@


1.31
log
@	* merge.cc (Object_merge_map::initialize_input_to_output_map):
	Reserve space in the hash table.
@
text
@d292 1
a292 1
				    section_offset_type offset,
d295 1
a295 1
  return this->merge_map_.get_output_offset(object, shndx, offset, poutput);
d357 2
a358 2
  section_size_type entsize = convert_to_section_size_type(this->entsize());
  section_size_type addralign =
d360 1
a360 1
  section_size_type addsize = std::max(entsize, addralign);
d372 3
a374 3
  memcpy(this->p_ + this->len_, p, entsize);
  if (addsize > entsize)
    memset(this->p_ + this->len_ + entsize, 0, addsize - entsize);
d389 1
a389 1
  section_size_type entsize = convert_to_section_size_type(this->entsize());
d391 1
a391 1
  if (len % entsize != 0)
d394 1
a394 1
  this->input_count_ += len / entsize;
d396 1
a396 1
  for (section_size_type i = 0; i < len; i += entsize, p += entsize)
d409 1
a409 1
	  this->len_ -= entsize;
d414 1
a414 1
      this->add_mapping(object, shndx, i, entsize, k);
d534 1
a534 1
      section_offset_type offset =
d536 1
a536 1
      this->add_mapping(p->object, p->shndx, p->offset, p->length, offset);
@


1.30
log
@	* merge.cc (do_add_input_section): Correct pend value.  Change
	message about last entry not being null terminated from error to
	warning.
@
text
@d207 6
@


1.29
log
@	* merge.cc (Object_merge_map::get_output_offset): Remove inline
	qualifier.
@
text
@d468 1
a468 1
  const Char_type* pend = p + len;
d488 4
a491 2
	      object->error(_("entry in mergeable string section "
			      "not null terminated"));
@


1.28
log
@Update copyright years.  Update language files.
@
text
@d143 1
a143 1
inline bool
@


1.27
log
@Don't crash if we change the address of the .eh_frame section after we
find its size.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.26
log
@Speed up relocations against local symbols in merged sections.
@
text
@d531 3
a533 1
  // Save some memory.
@


1.25
log
@Update comments about output offsets and merged input sections.
@
text
@d33 1
a33 115
// For each object with merge sections, we store an Object_merge_map.
// This is used to map locations in input sections to a merged output
// section.  The output section itself is not recorded here--it can be
// found in the map_to_output_ field of the Object.

class Object_merge_map
{
 public:
  Object_merge_map()
    : first_shnum_(-1U), first_map_(),
      second_shnum_(-1U), second_map_(),
      section_merge_maps_()
  { }

  ~Object_merge_map();

  // Add a mapping for MERGE_MAP, for the bytes from OFFSET to OFFSET
  // + LENGTH in the input section SHNDX to OUTPUT_OFFSET in the
  // output section.  An OUTPUT_OFFSET of -1 means that the bytes are
  // discarded.  OUTPUT_OFFSET is relative to the start of the merged
  // data in the output section.
  void
  add_mapping(const Merge_map*, unsigned int shndx, section_offset_type offset,
	      section_size_type length, section_offset_type output_offset);

  // Get the output offset for an input address in MERGE_MAP.  The
  // input address is at offset OFFSET in section SHNDX.  This sets
  // *OUTPUT_OFFSET to the offset in the output section; this will be
  // -1 if the bytes are not being copied to the output.  This returns
  // true if the mapping is known, false otherwise.  *OUTPUT_OFFSET is
  // relative to the start of the merged data in the output section.
  bool
  get_output_offset(const Merge_map*, unsigned int shndx,
		    section_offset_type offset,
		    section_offset_type *output_offset);

 private:
  // Map input section offsets to a length and an output section
  // offset.  An output section offset of -1 means that this part of
  // the input section is being discarded.
  struct Input_merge_entry
  {
    // The offset in the input section.
    section_offset_type input_offset;
    // The length.
    section_size_type length;
    // The offset in the output section.
    section_offset_type output_offset;
  };

  // A less-than comparison routine for Input_merge_entry.
  struct Input_merge_compare
  {
    bool
    operator()(const Input_merge_entry& i1, const Input_merge_entry& i2) const
    { return i1.input_offset < i2.input_offset; }
  };

  // A list of entries for a particular input section.
  struct Input_merge_map
  {
    // We store these with the Relobj, and we look them up by input
    // section.  It is possible to have two different merge maps
    // associated with a single output section.  For example, this
    // happens routinely with .rodata, when merged string constants
    // and merged fixed size constants are both put into .rodata.  The
    // output offset that we store is not the offset from the start of
    // the output section; it is the offset from the start of the
    // merged data in the output section.  That means that the caller
    // is going to add the offset of the merged data within the output
    // section, which means that the caller needs to know which set of
    // merged data it found the entry in.  So it's not enough to find
    // this data based on the input section and the output section; we
    // also have to find it based on a set of merged data in the
    // output section.  In order to verify that we are looking at the
    // right data, we store a pointer to the Merge_map here, and we
    // pass in a pointer when looking at the data.  If we are asked to
    // look up information for a different Merge_map, we report that
    // we don't have it, rather than trying a lookup and returning an
    // answer which will receive the wrong offset.
    const Merge_map* merge_map;
    // The list of mappings.
    std::vector<Input_merge_entry> entries;
    // Whether the ENTRIES field is sorted by input_offset.
    bool sorted;

    Input_merge_map()
      : merge_map(NULL), entries(), sorted(true)
    { }
  };

  // Map input section indices to merge maps.
  typedef std::map<unsigned int, Input_merge_map*> Section_merge_maps;

  // Return a pointer to the Input_merge_map to use for the input
  // section SHNDX, or NULL.
  Input_merge_map*
  get_input_merge_map(unsigned int shndx);

  // Get or make the the Input_merge_map to use for the section SHNDX
  // with MERGE_MAP.
  Input_merge_map*
  get_or_make_input_merge_map(const Merge_map* merge_map, unsigned int shndx);

  // Any given object file will normally only have a couple of input
  // sections with mergeable contents.  So we keep the first two input
  // section numbers inline, and push any further ones into a map.  A
  // value of -1U in first_shnum_ or second_shnum_ means that we don't
  // have a corresponding entry.
  unsigned int first_shnum_;
  Input_merge_map first_map_;
  unsigned int second_shnum_;
  Input_merge_map second_map_;
  Section_merge_maps section_merge_maps_;
};
d150 2
a151 1
  if (map == NULL || map->merge_map != merge_map)
d184 43
d266 11
d292 9
d618 18
@


1.24
log
@Remove one inline.
@
text
@d52 2
a53 1
  // discarded.
d62 2
a63 1
  // true if the mapping is known, false otherwise.
d91 1
a91 1
  // A list of entries for a particular section.
d94 19
a112 1
    // The Merge_map for this section.
d185 1
a185 1
      // must be donw with the same Merge_map.
d300 2
a301 2
// section SHNDX in object OBJECT to an OUTPUT_OFFSET in a merged
// output section.
d320 3
a322 2
// *OUTPUT_OFFSET to the offset in the output section.  This returns
// true if the mapping is known, false otherwise.
@


1.23
log
@Make functions on hot path inline.  Remove a mistaken virtual
declaration.
@
text
@d303 1
a303 1
inline bool
@


1.22
log
@Move Stringpool offsets into a chunked_vector indexed by keys.
@
text
@d237 1
a237 1
bool
d303 1
a303 1
bool
@


1.21
log
@Use string length when available when calling Stringpool.  Compare
pointers first when looking up Stringpool entries.
@
text
@d523 1
d525 1
a525 1
							       NULL);
d529 1
a529 1
						    bytelen_with_null));
a554 1
      size_t charlen_without_null = (p->length / sizeof(Char_type)) - 1;
d556 1
a556 2
	this->stringpool_.get_offset_with_length(p->string,
						 charlen_without_null);
@


1.20
log
@Print statistics about merge sections with --stats.
@
text
@d523 2
a524 1
      const Char_type* str = this->stringpool_.add_prefix(p, pl - p, NULL);
d553 7
a559 2
    this->add_mapping(p->object, p->shndx, p->offset, p->length,
		      this->stringpool_.get_offset(p->string));
@


1.19
log
@Add section_size_type and section_offset_type, use them to replace a
lot of instances of off_t.
@
text
@d417 2
d472 12
d506 2
d531 1
d534 2
d585 45
@


1.18
log
@Minor speedup to Output_merge_string::do_add_input_section.
@
text
@d54 2
a55 2
  add_mapping(const Merge_map*, unsigned int shndx, off_t offset, off_t length,
	      off_t output_offset);
d63 3
a65 2
  get_output_offset(const Merge_map*, unsigned int shndx, off_t offset,
		    off_t *output_offset);
d74 1
a74 1
    off_t input_offset;
d76 1
a76 1
    off_t length;
d78 1
a78 1
    off_t output_offset;
d194 3
a196 2
			      off_t input_offset, off_t length,
			      off_t output_offset)
d205 4
d211 1
a211 1
      if (input_offset < entry.input_offset + entry.length)
d213 3
a215 2
	  gold_assert(input_offset < entry.input_offset
		      && input_offset + length <= entry.input_offset);
d218 1
a218 1
      else if (entry.input_offset + entry.length == input_offset
d221 1
a221 1
		   : entry.output_offset + entry.length == output_offset))
d239 3
a241 2
				    unsigned int shndx, off_t input_offset,
				    off_t *output_offset)
d267 2
a268 1
  if (input_offset - p->input_offset >= p->length)
d285 2
a286 1
		       off_t offset, off_t length, off_t output_offset)
d305 2
a306 1
			     off_t offset, off_t* output_offset) const
d324 2
a325 2
				    off_t offset,
				    off_t* poutput) const
d338 2
a339 1
  uint64_t entsize = this->pomd_->entsize();
d345 1
a345 1
      for (uint64_t i = 0; i < entsize; ++i)
d355 1
a355 1
      for (uint64_t i = 0; i < entsize; ++i)
d380 4
a383 2
  uint64_t entsize = this->entsize();
  uint64_t addsize = std::max(entsize, this->addralign());
d409 1
a409 1
  off_t len;
d412 1
a412 1
  uint64_t entsize = this->entsize();
d417 1
a417 1
  for (off_t i = 0; i < len; i += entsize, p += entsize)
d479 1
a479 1
  off_t len;
d493 1
a493 1
  off_t i = 0;
d509 1
a509 1
      size_t bytelen_with_null = ((pl - p) + 1) * sizeof(Char_type);
d524 1
a524 1
off_t
@


1.17
log
@Compress all debug sections.
@
text
@d469 1
d482 2
a483 2
      off_t plen = 0;
      for (const Char_type* pl = p; *pl != 0; ++pl)
d485 1
a485 3
          // The length PLEN is in characters, not bytes.
	  ++plen;
	  if (i + plen * static_cast<off_t>(sizeof(Char_type)) >= len)
d493 1
a493 1
      const Char_type* str = this->stringpool_.add(p, true, NULL);
d495 1
a495 1
      off_t bytelen_with_null = (plen + 1) * sizeof(Char_type);
d499 1
a499 1
      p += plen + 1;
@


1.16
log
@From Craig Silverstein: Add support for compressing .debug_str section.
@
text
@d448 8
d544 9
@


1.15
log
@Clean up setting address and section offset.
@
text
@d499 2
a500 3
// Set the final data size of a merged string section.  This is where
// we finalize the mappings from the input sections to the output
// section.
d503 2
a504 2
void
Output_merge_string<Char_type>::set_final_data_size()
a514 2
  this->set_data_size(this->stringpool_.get_strtab_size());

d517 10
@


1.14
log
@Rework merge_map for speed.
@
text
@d431 1
a431 1
Output_merge_data::do_set_address(uint64_t, off_t)
d505 1
a505 1
Output_merge_string<Char_type>::do_set_address(uint64_t, off_t)
@


1.13
log
@Make Merge_key_less operator() inline.
@
text
@d33 4
a36 1
// Class Merge_map::Merge_key_less.
d38 101
a138 2
// Sort the entries in a merge mapping.  The key is an input object, a
// section index in that object, and an offset in that section.
d140 126
a265 20
inline bool
Merge_map::Merge_key_less::operator()(const Merge_key& mk1,
				      const Merge_key& mk2) const
{
  // The order of different objects and different sections doesn't
  // matter.  We want to get consistent results across links so we
  // don't use pointer comparison.
  if (mk1.object != mk2.object)
    {
      // Two different object files can have the same name: if foo.a
      // includes both bar/qux.o and baz/qux.o, then both end up with
      // the name foo.a(qux.o).  But it's impossible for two different
      // object files to have both the same name and the same offset.
      if (mk1.object->offset() != mk2.object->offset())
        return mk1.object->offset() < mk2.object->offset();
      return mk1.object->name() < mk2.object->name();
    }
  if (mk1.shndx != mk2.shndx)
    return mk1.shndx < mk2.shndx;
  return mk1.offset < mk2.offset;
d278 8
a285 12
  Merge_key mk;
  mk.object = object;
  mk.shndx = shndx;
  mk.offset = offset;

  Merge_value mv;
  mv.length = length;
  mv.output_offset = output_offset;

  std::pair<Merge_mapping::iterator, bool> ins =
    this->merge_map_.insert(std::make_pair(mk, mv));
  gold_assert(ins.second);
d297 2
a298 22
  Merge_key mk;
  mk.object = object;
  mk.shndx = shndx;
  mk.offset = offset;
  Merge_mapping::const_iterator p = this->merge_map_.lower_bound(mk);

  // If MK is not in the map, lower_bound returns the next iterator
  // larger than it.
  if (p == this->merge_map_.end()
      || p->first.object != object
      || p->first.shndx != shndx
      || p->first.offset != offset)
    {
      if (p == this->merge_map_.begin())
	return false;
      --p;
    }

  if (p->first.object != object || p->first.shndx != shndx)
    return false;

  if (offset - p->first.offset >= p->second.length)
d300 2
a301 5

  *output_offset = p->second.output_offset;
  if (*output_offset != -1)
    *output_offset += (offset - p->first.offset);
  return true;
@


1.12
log
@Generate a complete exception frame header.  Discard duplicate
exception frame information.
@
text
@d38 1
a38 1
bool
@


1.11
log
@From Craig Silverstein: add cast to avoid warning.
@
text
@d33 2
d39 2
a40 2
Output_merge_base::Merge_key_less::operator()(const Merge_key& mk1,
					      const Merge_key& mk2) const
d60 5
a64 4
// Add a mapping from an OFFSET in input section SHNDX in object
// OBJECT to an OUTPUT_OFFSET in a merged output section.  This
// manages the mapping used to resolve relocations against merged
// sections.
d67 2
a68 2
Output_merge_base::add_mapping(Relobj* object, unsigned int shndx,
			       off_t offset, off_t output_offset)
d74 7
a80 2
  std::pair<Merge_map::iterator, bool> ins =
    this->merge_map_.insert(std::make_pair(mk, output_offset));
d84 4
a87 5
// Return the output address for an input address.  The input address
// is at offset OFFSET in section SHNDX in OBJECT.
// OUTPUT_SECTION_ADDRESS is the address of the output section.  If we
// know the address, set *POUTPUT and return true.  Otherwise return
// false.
d90 2
a91 4
Output_merge_base::do_output_address(const Relobj* object, unsigned int shndx,
				     off_t offset,
				     uint64_t output_section_address,
				     uint64_t* poutput) const
a92 2
  gold_assert(output_section_address == this->address());

d97 1
a97 1
  Merge_map::const_iterator p = this->merge_map_.lower_bound(mk);
d114 6
a119 3
  // Any input section is fully mapped: we don't need to know the size
  // of the range starting at P->FIRST.OFFSET.
  *poutput = output_section_address + p->second + (offset - p->first.offset);
d123 17
d240 1
a240 1
      this->add_mapping(object, shndx, i, k);
d267 2
d307 3
a309 1
      this->merged_strings_.push_back(Merged_string(object, shndx, i, str));
d312 1
a312 1
      i += (plen + 1) * sizeof(Char_type);
d332 1
a332 1
    this->add_mapping(p->object, p->shndx, p->offset,
@


1.10
log
@Fix handling of wide string merge sections.
@
text
@d272 1
a272 1
	  if (i + plen * sizeof(Char_type) >= len)
@


1.9
log
@Correctly handle alignment in merge sections.
@
text
@a261 1
  len /= sizeof(Char_type);
d263 1
d270 1
d272 1
a272 1
	  if (i + plen >= len)
d285 1
a285 1
      i += plen + 1;
@


1.8
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d26 1
d165 2
a166 1
  if (this->len_ + entsize > this->alc_)
d169 1
a169 1
	this->alc_ = 128 * entsize;
d178 3
a180 1
  this->len_ += entsize;
@


1.7
log
@Add an option for Stringpools to not copy strings.
@
text
@d172 1
a172 1
	gold_fatal("out of memory", true);
d254 3
a256 5
      fprintf(stderr,
	      _("%s: %s: mergeable string section length not multiple of "
		"character size\n"),
	      program_name, object->name().c_str());
      gold_exit(false);
d269 3
a271 5
	      fprintf(stderr,
		      _("%s: %s: entry in mergeable string section "
			"not null terminated\n"),
		      program_name, object->name().c_str());
	      gold_exit(false);
@


1.6
log
@From Craig Silverstein: don't get confused if the same file name
occurs in an archive.
@
text
@d279 1
a279 1
      const Char_type* str = this->stringpool_.add(p, NULL);
@


1.5
log
@Add cache parameter to get_view.  Discard uncached views on unlock.
Fix bug this exposed in archive armap symbol name handling.
@
text
@d43 9
a51 1
    return mk1.object->name() < mk2.object->name();
@


1.4
log
@Avoid dereferencing map->end().
@
text
@d180 1
a180 1
  const unsigned char* p = object->section_contents(shndx, &len);
d240 1
a240 1
  const unsigned char* pdata = object->section_contents(shndx, &len);
@


1.3
log
@Add licensing text to every source file.
@
text
@d89 2
a90 1
  if (p->first.object != object
@


1.2
log
@We don't need a hash table mapping input locations to strings.
@
text
@d3 20
@


1.1
log
@Add support for SHF_MERGE sections.
@
text
@a210 26
// Compute a hash code for a Merge_string_key, which is an object, a
// section index, and an offset.

template<typename Char_type>
size_t
Output_merge_string<Char_type>::Merge_string_key_hash::operator()(
    const Merge_string_key& key) const
{
  // This is a very simple minded hash code.  Fix it if it we get too
  // many collisions.
  const std::string& oname(key.object->name());
  return oname[0] + oname.length() + key.shndx + key.offset;
}

// Compare two Merge_string_keys for equality.

template<typename Char_type>
bool
Output_merge_string<Char_type>::Merge_string_key_eq::operator()(
    const Merge_string_key& k1, const Merge_string_key& k2) const
{
  return (k1.object == k2.object
	  && k1.shndx == k2.shndx
	  && k1.offset == k2.offset);
}

d252 1
a252 4
      Merge_string_key k(object, shndx, i);
      typename Merge_string_hashtable::value_type v(k, str);
      bool b = this->hashtable_.insert(v).second;
      gold_assert(b);
d271 3
a273 3
  for (typename Merge_string_hashtable::const_iterator p =
	 this->hashtable_.begin();
       p != this->hashtable_.end();
d275 2
a276 2
    this->add_mapping(p->first.object, p->first.shndx, p->first.offset,
		      this->stringpool_.get_offset(p->second));
d281 1
a281 1
  this->hashtable_.clear();
@

