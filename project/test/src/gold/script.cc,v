head	1.86;
access;
symbols
	binutils-2_24-branch:1.86.0.4
	binutils-2_24-branchpoint:1.86
	binutils-2_21_1:1.79.2.1
	binutils-2_23_2:1.86
	binutils-2_23_1:1.86
	binutils-2_23:1.86
	binutils-2_23-branch:1.86.0.2
	binutils-2_23-branchpoint:1.86
	binutils-2_22_branch:1.84.0.4
	binutils-2_22:1.84
	binutils-2_22-branch:1.84.0.2
	binutils-2_22-branchpoint:1.84
	binutils-2_21:1.79
	binutils-2_21-branch:1.79.0.2
	binutils-2_21-branchpoint:1.79
	binutils-2_20_1:1.55.2.1
	binutils-2_20:1.55.2.1
	binutils-arc-20081103-branch:1.47.0.6
	binutils-arc-20081103-branchpoint:1.47
	binutils-2_20-branch:1.55.0.2
	binutils-2_20-branchpoint:1.55
	dje-cgen-play1-branch:1.54.0.2
	dje-cgen-play1-branchpoint:1.54
	arc-20081103-branch:1.47.0.4
	arc-20081103-branchpoint:1.47
	binutils-2_19_1:1.47
	binutils-2_19:1.47
	binutils-2_19-branch:1.47.0.2
	binutils-2_19-branchpoint:1.47
	binutils_latest_snapshot:1.86
	added-to-binutils:1.41;
locks; strict;
comment	@// @;


1.86
date	2011.11.17.17.46.54;	author sterling;	state Exp;
branches;
next	1.85;

1.85
date	2011.10.31.22.51.03;	author ccoutant;	state Exp;
branches;
next	1.84;

1.84
date	2011.06.29.21.57.14;	author ian;	state Exp;
branches
	1.84.2.1;
next	1.83;

1.83
date	2011.06.28.23.12.31;	author ian;	state Exp;
branches;
next	1.82;

1.82
date	2011.04.12.00.44.48;	author ccoutant;	state Exp;
branches;
next	1.81;

1.81
date	2011.03.30.21.07.13;	author ccoutant;	state Exp;
branches;
next	1.80;

1.80
date	2011.01.25.18.55.24;	author ian;	state Exp;
branches;
next	1.79;

1.79
date	2010.11.03.17.18.23;	author nickc;	state Exp;
branches
	1.79.2.1;
next	1.78;

1.78
date	2010.09.08.20.08.14;	author espindola;	state Exp;
branches;
next	1.77;

1.77
date	2010.09.08.16.10.31;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	2010.08.12.22.01.11;	author ccoutant;	state Exp;
branches;
next	1.74;

1.74
date	2010.08.02.13.34.33;	author ian;	state Exp;
branches;
next	1.73;

1.73
date	2010.06.09.14.14.18;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	2010.05.18.18.08.03;	author espindola;	state Exp;
branches;
next	1.71;

1.71
date	2010.04.23.04.47.33;	author ian;	state Exp;
branches;
next	1.70;

1.70
date	2010.04.09.17.32.58;	author dougkwan;	state Exp;
branches;
next	1.69;

1.69
date	2010.03.22.14.18.24;	author espindola;	state Exp;
branches;
next	1.68;

1.68
date	2010.01.12.06.52.58;	author ian;	state Exp;
branches;
next	1.67;

1.67
date	2010.01.12.06.41.36;	author ian;	state Exp;
branches;
next	1.66;

1.66
date	2010.01.09.05.49.57;	author ian;	state Exp;
branches;
next	1.65;

1.65
date	2010.01.06.05.30.24;	author ian;	state Exp;
branches;
next	1.64;

1.64
date	2009.12.31.03.48.46;	author ian;	state Exp;
branches;
next	1.63;

1.63
date	2009.12.30.22.35.48;	author ian;	state Exp;
branches;
next	1.62;

1.62
date	2009.12.29.00.31.48;	author ian;	state Exp;
branches;
next	1.61;

1.61
date	2009.12.14.19.53.05;	author ian;	state Exp;
branches;
next	1.60;

1.60
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2009.10.16.18.56.07;	author dougkwan;	state Exp;
branches;
next	1.58;

1.58
date	2009.10.16.05.19.07;	author ian;	state Exp;
branches;
next	1.57;

1.57
date	2009.10.10.07.39.04;	author cgd;	state Exp;
branches;
next	1.56;

1.56
date	2009.10.10.04.56.43;	author ian;	state Exp;
branches;
next	1.55;

1.55
date	2009.07.06.23.11.21;	author ian;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2009.06.23.06.39.47;	author ian;	state Exp;
branches;
next	1.53;

1.53
date	2009.05.15.17.01.04;	author ian;	state Exp;
branches;
next	1.52;

1.52
date	2009.03.24.19.08.37;	author ian;	state Exp;
branches;
next	1.51;

1.51
date	2009.03.14.05.56.46;	author ian;	state Exp;
branches;
next	1.50;

1.50
date	2009.03.13.21.30.06;	author ian;	state Exp;
branches;
next	1.49;

1.49
date	2009.02.01.00.45.28;	author ian;	state Exp;
branches;
next	1.48;

1.48
date	2008.11.06.07.23.31;	author csilvers;	state Exp;
branches;
next	1.47;

1.47
date	2008.08.13.07.37.46;	author ian;	state Exp;
branches;
next	1.46;

1.46
date	2008.07.29.22.58.03;	author ian;	state Exp;
branches;
next	1.45;

1.45
date	2008.07.23.23.44.02;	author ian;	state Exp;
branches;
next	1.44;

1.44
date	2008.06.30.20.59.54;	author csilvers;	state Exp;
branches;
next	1.43;

1.43
date	2008.05.21.21.37.44;	author ian;	state Exp;
branches;
next	1.42;

1.42
date	2008.03.26.23.36.46;	author ian;	state Exp;
branches;
next	1.41;

1.41
date	2008.03.04.23.10.38;	author iant;	state Exp;
branches;
next	1.40;

1.40
date	2008.03.04.18.21.43;	author iant;	state Exp;
branches;
next	1.39;

1.39
date	2008.02.28.20.35.39;	author iant;	state Exp;
branches;
next	1.38;

1.38
date	2008.02.28.19.46.06;	author iant;	state Exp;
branches;
next	1.37;

1.37
date	2008.02.28.04.45.47;	author iant;	state Exp;
branches;
next	1.36;

1.36
date	2008.02.28.00.18.24;	author iant;	state Exp;
branches;
next	1.35;

1.35
date	2008.02.27.15.09.16;	author iant;	state Exp;
branches;
next	1.34;

1.34
date	2008.02.26.22.48.08;	author iant;	state Exp;
branches;
next	1.33;

1.33
date	2008.02.26.21.45.30;	author iant;	state Exp;
branches;
next	1.32;

1.32
date	2008.02.13.01.20.38;	author iant;	state Exp;
branches;
next	1.31;

1.31
date	2008.02.09.01.22.17;	author iant;	state Exp;
branches;
next	1.30;

1.30
date	2008.02.08.07.31.09;	author iant;	state Exp;
branches;
next	1.29;

1.29
date	2008.02.07.05.45.07;	author iant;	state Exp;
branches;
next	1.28;

1.28
date	2008.02.07.01.51.25;	author iant;	state Exp;
branches;
next	1.27;

1.27
date	2008.02.04.22.54.31;	author iant;	state Exp;
branches;
next	1.26;

1.26
date	2008.02.04.06.45.50;	author iant;	state Exp;
branches;
next	1.25;

1.25
date	2008.02.04.05.41.40;	author iant;	state Exp;
branches;
next	1.24;

1.24
date	2008.01.26.01.17.45;	author iant;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.23.01.31.13;	author iant;	state Exp;
branches;
next	1.22;

1.22
date	2008.01.18.23.35.09;	author iant;	state Exp;
branches;
next	1.21;

1.21
date	2008.01.15.23.41.28;	author iant;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.09.19.57.45;	author iant;	state Exp;
branches;
next	1.19;

1.19
date	2008.01.07.05.19.02;	author iant;	state Exp;
branches;
next	1.18;

1.18
date	2008.01.06.00.47.10;	author iant;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.14.19.00.21;	author iant;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.22.00.05.51;	author iant;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.30.06.27.03;	author iant;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.29.17.12.11;	author iant;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.27.00.29.34;	author iant;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.26.22.16.06;	author iant;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.14.06.57.58;	author iant;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.14.06.49.14;	author iant;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.04.05.49.04;	author iant;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.02.21.24.41;	author iant;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.25.06.43.17;	author iant;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.25.00.27.29;	author iant;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.24.17.09.50;	author iant;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.22.21.02.10;	author iant;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.21.21.29.12;	author chatham;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.29.17.56.40;	author iant;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.14.19.21.05;	author iant;	state Exp;
branches;
next	;

1.84.2.1
date	2011.12.19.21.14.40;	author ian;	state Exp;
branches;
next	;

1.79.2.1
date	2011.02.01.14.54.37;	author ian;	state Exp;
branches;
next	;

1.55.2.1
date	2009.10.16.05.51.18;	author ian;	state Exp;
branches;
next	;


desc
@@


1.86
log
@2011-11-17  Sterling Augustine  <saugustine@@google.com>

	* script.cc (script_include_directive): Implement.
	(read_script_file): New local variables name and search_path. Update
	comment. Call IS_ABSOLUTE_PATH and Dirsearch::find_file_in_dir_list.
	* dirsearch.h (Dirsearch::find_file_in_dir_list): Declare new method.
	* dirsearch.cc (Dirsearch::find_file_in_dir_list): Implement it.
@
text
@// script.cc -- handle linker scripts for gold.

// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
// Written by Ian Lance Taylor <iant@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fnmatch.h>
#include <string>
#include <vector>
#include "filenames.h"

#include "elfcpp.h"
#include "demangle.h"
#include "dirsearch.h"
#include "options.h"
#include "fileread.h"
#include "workqueue.h"
#include "readsyms.h"
#include "parameters.h"
#include "layout.h"
#include "symtab.h"
#include "target-select.h"
#include "script.h"
#include "script-c.h"
#include "incremental.h"

namespace gold
{

// A token read from a script file.  We don't implement keywords here;
// all keywords are simply represented as a string.

class Token
{
 public:
  // Token classification.
  enum Classification
  {
    // Token is invalid.
    TOKEN_INVALID,
    // Token indicates end of input.
    TOKEN_EOF,
    // Token is a string of characters.
    TOKEN_STRING,
    // Token is a quoted string of characters.
    TOKEN_QUOTED_STRING,
    // Token is an operator.
    TOKEN_OPERATOR,
    // Token is a number (an integer).
    TOKEN_INTEGER
  };

  // We need an empty constructor so that we can put this STL objects.
  Token()
    : classification_(TOKEN_INVALID), value_(NULL), value_length_(0),
      opcode_(0), lineno_(0), charpos_(0)
  { }

  // A general token with no value.
  Token(Classification classification, int lineno, int charpos)
    : classification_(classification), value_(NULL), value_length_(0),
      opcode_(0), lineno_(lineno), charpos_(charpos)
  {
    gold_assert(classification == TOKEN_INVALID
		|| classification == TOKEN_EOF);
  }

  // A general token with a value.
  Token(Classification classification, const char* value, size_t length,
	int lineno, int charpos)
    : classification_(classification), value_(value), value_length_(length),
      opcode_(0), lineno_(lineno), charpos_(charpos)
  {
    gold_assert(classification != TOKEN_INVALID
		&& classification != TOKEN_EOF);
  }

  // A token representing an operator.
  Token(int opcode, int lineno, int charpos)
    : classification_(TOKEN_OPERATOR), value_(NULL), value_length_(0),
      opcode_(opcode), lineno_(lineno), charpos_(charpos)
  { }

  // Return whether the token is invalid.
  bool
  is_invalid() const
  { return this->classification_ == TOKEN_INVALID; }

  // Return whether this is an EOF token.
  bool
  is_eof() const
  { return this->classification_ == TOKEN_EOF; }

  // Return the token classification.
  Classification
  classification() const
  { return this->classification_; }

  // Return the line number at which the token starts.
  int
  lineno() const
  { return this->lineno_; }

  // Return the character position at this the token starts.
  int
  charpos() const
  { return this->charpos_; }

  // Get the value of a token.

  const char*
  string_value(size_t* length) const
  {
    gold_assert(this->classification_ == TOKEN_STRING
		|| this->classification_ == TOKEN_QUOTED_STRING);
    *length = this->value_length_;
    return this->value_;
  }

  int
  operator_value() const
  {
    gold_assert(this->classification_ == TOKEN_OPERATOR);
    return this->opcode_;
  }

  uint64_t
  integer_value() const;

 private:
  // The token classification.
  Classification classification_;
  // The token value, for TOKEN_STRING or TOKEN_QUOTED_STRING or
  // TOKEN_INTEGER.
  const char* value_;
  // The length of the token value.
  size_t value_length_;
  // The token value, for TOKEN_OPERATOR.
  int opcode_;
  // The line number where this token started (one based).
  int lineno_;
  // The character position within the line where this token started
  // (one based).
  int charpos_;
};

// Return the value of a TOKEN_INTEGER.

uint64_t
Token::integer_value() const
{
  gold_assert(this->classification_ == TOKEN_INTEGER);

  size_t len = this->value_length_;

  uint64_t multiplier = 1;
  char last = this->value_[len - 1];
  if (last == 'm' || last == 'M')
    {
      multiplier = 1024 * 1024;
      --len;
    }
  else if (last == 'k' || last == 'K')
    {
      multiplier = 1024;
      --len;
    }

  char *end;
  uint64_t ret = strtoull(this->value_, &end, 0);
  gold_assert(static_cast<size_t>(end - this->value_) == len);

  return ret * multiplier;
}

// This class handles lexing a file into a sequence of tokens.

class Lex
{
 public:
  // We unfortunately have to support different lexing modes, because
  // when reading different parts of a linker script we need to parse
  // things differently.
  enum Mode
  {
    // Reading an ordinary linker script.
    LINKER_SCRIPT,
    // Reading an expression in a linker script.
    EXPRESSION,
    // Reading a version script.
    VERSION_SCRIPT,
    // Reading a --dynamic-list file.
    DYNAMIC_LIST
  };

  Lex(const char* input_string, size_t input_length, int parsing_token)
    : input_string_(input_string), input_length_(input_length),
      current_(input_string), mode_(LINKER_SCRIPT),
      first_token_(parsing_token), token_(),
      lineno_(1), linestart_(input_string)
  { }

  // Read a file into a string.
  static void
  read_file(Input_file*, std::string*);

  // Return the next token.
  const Token*
  next_token();

  // Return the current lexing mode.
  Lex::Mode
  mode() const
  { return this->mode_; }

  // Set the lexing mode.
  void
  set_mode(Mode mode)
  { this->mode_ = mode; }

 private:
  Lex(const Lex&);
  Lex& operator=(const Lex&);

  // Make a general token with no value at the current location.
  Token
  make_token(Token::Classification c, const char* start) const
  { return Token(c, this->lineno_, start - this->linestart_ + 1); }

  // Make a general token with a value at the current location.
  Token
  make_token(Token::Classification c, const char* v, size_t len,
	     const char* start)
    const
  { return Token(c, v, len, this->lineno_, start - this->linestart_ + 1); }

  // Make an operator token at the current location.
  Token
  make_token(int opcode, const char* start) const
  { return Token(opcode, this->lineno_, start - this->linestart_ + 1); }

  // Make an invalid token at the current location.
  Token
  make_invalid_token(const char* start)
  { return this->make_token(Token::TOKEN_INVALID, start); }

  // Make an EOF token at the current location.
  Token
  make_eof_token(const char* start)
  { return this->make_token(Token::TOKEN_EOF, start); }

  // Return whether C can be the first character in a name.  C2 is the
  // next character, since we sometimes need that.
  inline bool
  can_start_name(char c, char c2);

  // If C can appear in a name which has already started, return a
  // pointer to a character later in the token or just past
  // it. Otherwise, return NULL.
  inline const char*
  can_continue_name(const char* c);

  // Return whether C, C2, C3 can start a hex number.
  inline bool
  can_start_hex(char c, char c2, char c3);

  // If C can appear in a hex number which has already started, return
  // a pointer to a character later in the token or just past
  // it. Otherwise, return NULL.
  inline const char*
  can_continue_hex(const char* c);

  // Return whether C can start a non-hex number.
  static inline bool
  can_start_number(char c);

  // If C can appear in a decimal number which has already started,
  // return a pointer to a character later in the token or just past
  // it. Otherwise, return NULL.
  inline const char*
  can_continue_number(const char* c)
  { return Lex::can_start_number(*c) ? c + 1 : NULL; }

  // If C1 C2 C3 form a valid three character operator, return the
  // opcode.  Otherwise return 0.
  static inline int
  three_char_operator(char c1, char c2, char c3);

  // If C1 C2 form a valid two character operator, return the opcode.
  // Otherwise return 0.
  static inline int
  two_char_operator(char c1, char c2);

  // If C1 is a valid one character operator, return the opcode.
  // Otherwise return 0.
  static inline int
  one_char_operator(char c1);

  // Read the next token.
  Token
  get_token(const char**);

  // Skip a C style /* */ comment.  Return false if the comment did
  // not end.
  bool
  skip_c_comment(const char**);

  // Skip a line # comment.  Return false if there was no newline.
  bool
  skip_line_comment(const char**);

  // Build a token CLASSIFICATION from all characters that match
  // CAN_CONTINUE_FN.  The token starts at START.  Start matching from
  // MATCH.  Set *PP to the character following the token.
  inline Token
  gather_token(Token::Classification,
	       const char* (Lex::*can_continue_fn)(const char*),
	       const char* start, const char* match, const char** pp);

  // Build a token from a quoted string.
  Token
  gather_quoted_string(const char** pp);

  // The string we are tokenizing.
  const char* input_string_;
  // The length of the string.
  size_t input_length_;
  // The current offset into the string.
  const char* current_;
  // The current lexing mode.
  Mode mode_;
  // The code to use for the first token.  This is set to 0 after it
  // is used.
  int first_token_;
  // The current token.
  Token token_;
  // The current line number.
  int lineno_;
  // The start of the current line in the string.
  const char* linestart_;
};

// Read the whole file into memory.  We don't expect linker scripts to
// be large, so we just use a std::string as a buffer.  We ignore the
// data we've already read, so that we read aligned buffers.

void
Lex::read_file(Input_file* input_file, std::string* contents)
{
  off_t filesize = input_file->file().filesize();
  contents->clear();
  contents->reserve(filesize);

  off_t off = 0;
  unsigned char buf[BUFSIZ];
  while (off < filesize)
    {
      off_t get = BUFSIZ;
      if (get > filesize - off)
	get = filesize - off;
      input_file->file().read(off, get, buf);
      contents->append(reinterpret_cast<char*>(&buf[0]), get);
      off += get;
    }
}

// Return whether C can be the start of a name, if the next character
// is C2.  A name can being with a letter, underscore, period, or
// dollar sign.  Because a name can be a file name, we also permit
// forward slash, backslash, and tilde.  Tilde is the tricky case
// here; GNU ld also uses it as a bitwise not operator.  It is only
// recognized as the operator if it is not immediately followed by
// some character which can appear in a symbol.  That is, when we
// don't know that we are looking at an expression, "~0" is a file
// name, and "~ 0" is an expression using bitwise not.  We are
// compatible.

inline bool
Lex::can_start_name(char c, char c2)
{
  switch (c)
    {
    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
    case 'M': case 'N': case 'O': case 'Q': case 'P': case 'R':
    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
    case 'Y': case 'Z':
    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
    case 'm': case 'n': case 'o': case 'q': case 'p': case 'r':
    case 's': case 't': case 'u': case 'v': case 'w': case 'x':
    case 'y': case 'z':
    case '_': case '.': case '$':
      return true;

    case '/': case '\\':
      return this->mode_ == LINKER_SCRIPT;

    case '~':
      return this->mode_ == LINKER_SCRIPT && can_continue_name(&c2);

    case '*': case '[':
      return (this->mode_ == VERSION_SCRIPT
              || this->mode_ == DYNAMIC_LIST
	      || (this->mode_ == LINKER_SCRIPT
		  && can_continue_name(&c2)));

    default:
      return false;
    }
}

// Return whether C can continue a name which has already started.
// Subsequent characters in a name are the same as the leading
// characters, plus digits and "=+-:[],?*".  So in general the linker
// script language requires spaces around operators, unless we know
// that we are parsing an expression.

inline const char*
Lex::can_continue_name(const char* c)
{
  switch (*c)
    {
    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
    case 'M': case 'N': case 'O': case 'Q': case 'P': case 'R':
    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
    case 'Y': case 'Z':
    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
    case 'm': case 'n': case 'o': case 'q': case 'p': case 'r':
    case 's': case 't': case 'u': case 'v': case 'w': case 'x':
    case 'y': case 'z':
    case '_': case '.': case '$':
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      return c + 1;

    // TODO(csilvers): why not allow ~ in names for version-scripts?
    case '/': case '\\': case '~':
    case '=': case '+':
    case ',':
      if (this->mode_ == LINKER_SCRIPT)
        return c + 1;
      return NULL;

    case '[': case ']': case '*': case '?': case '-':
      if (this->mode_ == LINKER_SCRIPT || this->mode_ == VERSION_SCRIPT
          || this->mode_ == DYNAMIC_LIST)
        return c + 1;
      return NULL;

    // TODO(csilvers): why allow this?  ^ is meaningless in version scripts.
    case '^':
      if (this->mode_ == VERSION_SCRIPT || this->mode_ == DYNAMIC_LIST)
        return c + 1;
      return NULL;

    case ':':
      if (this->mode_ == LINKER_SCRIPT)
        return c + 1;
      else if ((this->mode_ == VERSION_SCRIPT || this->mode_ == DYNAMIC_LIST)
               && (c[1] == ':'))
        {
          // A name can have '::' in it, as that's a c++ namespace
          // separator. But a single colon is not part of a name.
          return c + 2;
        }
      return NULL;

    default:
      return NULL;
    }
}

// For a number we accept 0x followed by hex digits, or any sequence
// of digits.  The old linker accepts leading '$' for hex, and
// trailing HXBOD.  Those are for MRI compatibility and we don't
// accept them.

// Return whether C1 C2 C3 can start a hex number.

inline bool
Lex::can_start_hex(char c1, char c2, char c3)
{
  if (c1 == '0' && (c2 == 'x' || c2 == 'X'))
    return this->can_continue_hex(&c3);
  return false;
}

// Return whether C can appear in a hex number.

inline const char*
Lex::can_continue_hex(const char* c)
{
  switch (*c)
    {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
      return c + 1;

    default:
      return NULL;
    }
}

// Return whether C can start a non-hex number.

inline bool
Lex::can_start_number(char c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      return true;

    default:
      return false;
    }
}

// If C1 C2 C3 form a valid three character operator, return the
// opcode (defined in the yyscript.h file generated from yyscript.y).
// Otherwise return 0.

inline int
Lex::three_char_operator(char c1, char c2, char c3)
{
  switch (c1)
    {
    case '<':
      if (c2 == '<' && c3 == '=')
	return LSHIFTEQ;
      break;
    case '>':
      if (c2 == '>' && c3 == '=')
	return RSHIFTEQ;
      break;
    default:
      break;
    }
  return 0;
}

// If C1 C2 form a valid two character operator, return the opcode
// (defined in the yyscript.h file generated from yyscript.y).
// Otherwise return 0.

inline int
Lex::two_char_operator(char c1, char c2)
{
  switch (c1)
    {
    case '=':
      if (c2 == '=')
	return EQ;
      break;
    case '!':
      if (c2 == '=')
	return NE;
      break;
    case '+':
      if (c2 == '=')
	return PLUSEQ;
      break;
    case '-':
      if (c2 == '=')
	return MINUSEQ;
      break;
    case '*':
      if (c2 == '=')
	return MULTEQ;
      break;
    case '/':
      if (c2 == '=')
	return DIVEQ;
      break;
    case '|':
      if (c2 == '=')
	return OREQ;
      if (c2 == '|')
	return OROR;
      break;
    case '&':
      if (c2 == '=')
	return ANDEQ;
      if (c2 == '&')
	return ANDAND;
      break;
    case '>':
      if (c2 == '=')
	return GE;
      if (c2 == '>')
	return RSHIFT;
      break;
    case '<':
      if (c2 == '=')
	return LE;
      if (c2 == '<')
	return LSHIFT;
      break;
    default:
      break;
    }
  return 0;
}

// If C1 is a valid operator, return the opcode.  Otherwise return 0.

inline int
Lex::one_char_operator(char c1)
{
  switch (c1)
    {
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '!':
    case '&':
    case '|':
    case '^':
    case '~':
    case '<':
    case '>':
    case '=':
    case '?':
    case ',':
    case '(':
    case ')':
    case '{':
    case '}':
    case '[':
    case ']':
    case ':':
    case ';':
      return c1;
    default:
      return 0;
    }
}

// Skip a C style comment.  *PP points to just after the "/*".  Return
// false if the comment did not end.

bool
Lex::skip_c_comment(const char** pp)
{
  const char* p = *pp;
  while (p[0] != '*' || p[1] != '/')
    {
      if (*p == '\0')
	{
	  *pp = p;
	  return false;
	}

      if (*p == '\n')
	{
	  ++this->lineno_;
	  this->linestart_ = p + 1;
	}
      ++p;
    }

  *pp = p + 2;
  return true;
}

// Skip a line # comment.  Return false if there was no newline.

bool
Lex::skip_line_comment(const char** pp)
{
  const char* p = *pp;
  size_t skip = strcspn(p, "\n");
  if (p[skip] == '\0')
    {
      *pp = p + skip;
      return false;
    }

  p += skip + 1;
  ++this->lineno_;
  this->linestart_ = p;
  *pp = p;

  return true;
}

// Build a token CLASSIFICATION from all characters that match
// CAN_CONTINUE_FN.  Update *PP.

inline Token
Lex::gather_token(Token::Classification classification,
		  const char* (Lex::*can_continue_fn)(const char*),
		  const char* start,
		  const char* match,
		  const char** pp)
{
  const char* new_match = NULL;
  while ((new_match = (this->*can_continue_fn)(match)) != NULL)
    match = new_match;

  // A special case: integers may be followed by a single M or K,
  // case-insensitive.
  if (classification == Token::TOKEN_INTEGER
      && (*match == 'm' || *match == 'M' || *match == 'k' || *match == 'K'))
    ++match;

  *pp = match;
  return this->make_token(classification, start, match - start, start);
}

// Build a token from a quoted string.

Token
Lex::gather_quoted_string(const char** pp)
{
  const char* start = *pp;
  const char* p = start;
  ++p;
  size_t skip = strcspn(p, "\"\n");
  if (p[skip] != '"')
    return this->make_invalid_token(start);
  *pp = p + skip + 1;
  return this->make_token(Token::TOKEN_QUOTED_STRING, p, skip, start);
}

// Return the next token at *PP.  Update *PP.  General guideline: we
// require linker scripts to be simple ASCII.  No unicode linker
// scripts.  In particular we can assume that any '\0' is the end of
// the input.

Token
Lex::get_token(const char** pp)
{
  const char* p = *pp;

  while (true)
    {
      if (*p == '\0')
	{
	  *pp = p;
	  return this->make_eof_token(p);
	}

      // Skip whitespace quickly.
      while (*p == ' ' || *p == '\t' || *p == '\r')
	++p;

      if (*p == '\n')
	{
	  ++p;
	  ++this->lineno_;
	  this->linestart_ = p;
	  continue;
	}

      // Skip C style comments.
      if (p[0] == '/' && p[1] == '*')
	{
	  int lineno = this->lineno_;
	  int charpos = p - this->linestart_ + 1;

	  *pp = p + 2;
	  if (!this->skip_c_comment(pp))
	    return Token(Token::TOKEN_INVALID, lineno, charpos);
	  p = *pp;

	  continue;
	}

      // Skip line comments.
      if (*p == '#')
	{
	  *pp = p + 1;
	  if (!this->skip_line_comment(pp))
	    return this->make_eof_token(p);
	  p = *pp;
	  continue;
	}

      // Check for a name.
      if (this->can_start_name(p[0], p[1]))
	return this->gather_token(Token::TOKEN_STRING,
				  &Lex::can_continue_name,
				  p, p + 1, pp);

      // We accept any arbitrary name in double quotes, as long as it
      // does not cross a line boundary.
      if (*p == '"')
	{
	  *pp = p;
	  return this->gather_quoted_string(pp);
	}

      // Check for a number.

      if (this->can_start_hex(p[0], p[1], p[2]))
	return this->gather_token(Token::TOKEN_INTEGER,
				  &Lex::can_continue_hex,
				  p, p + 3, pp);

      if (Lex::can_start_number(p[0]))
	return this->gather_token(Token::TOKEN_INTEGER,
				  &Lex::can_continue_number,
				  p, p + 1, pp);

      // Check for operators.

      int opcode = Lex::three_char_operator(p[0], p[1], p[2]);
      if (opcode != 0)
	{
	  *pp = p + 3;
	  return this->make_token(opcode, p);
	}

      opcode = Lex::two_char_operator(p[0], p[1]);
      if (opcode != 0)
	{
	  *pp = p + 2;
	  return this->make_token(opcode, p);
	}

      opcode = Lex::one_char_operator(p[0]);
      if (opcode != 0)
	{
	  *pp = p + 1;
	  return this->make_token(opcode, p);
	}

      return this->make_token(Token::TOKEN_INVALID, p);
    }
}

// Return the next token.

const Token*
Lex::next_token()
{
  // The first token is special.
  if (this->first_token_ != 0)
    {
      this->token_ = Token(this->first_token_, 0, 0);
      this->first_token_ = 0;
      return &this->token_;
    }

  this->token_ = this->get_token(&this->current_);

  // Don't let an early null byte fool us into thinking that we've
  // reached the end of the file.
  if (this->token_.is_eof()
      && (static_cast<size_t>(this->current_ - this->input_string_)
	  < this->input_length_))
    this->token_ = this->make_invalid_token(this->current_);

  return &this->token_;
}

// class Symbol_assignment.

// Add the symbol to the symbol table.  This makes sure the symbol is
// there and defined.  The actual value is stored later.  We can't
// determine the actual value at this point, because we can't
// necessarily evaluate the expression until all ordinary symbols have
// been finalized.

// The GNU linker lets symbol assignments in the linker script
// silently override defined symbols in object files.  We are
// compatible.  FIXME: Should we issue a warning?

void
Symbol_assignment::add_to_table(Symbol_table* symtab)
{
  elfcpp::STV vis = this->hidden_ ? elfcpp::STV_HIDDEN : elfcpp::STV_DEFAULT;
  this->sym_ = symtab->define_as_constant(this->name_.c_str(),
					  NULL, // version
					  (this->is_defsym_
					   ? Symbol_table::DEFSYM
					   : Symbol_table::SCRIPT),
					  0, // value
					  0, // size
					  elfcpp::STT_NOTYPE,
					  elfcpp::STB_GLOBAL,
					  vis,
					  0, // nonvis
					  this->provide_,
                                          true); // force_override
}

// Finalize a symbol value.

void
Symbol_assignment::finalize(Symbol_table* symtab, const Layout* layout)
{
  this->finalize_maybe_dot(symtab, layout, false, 0, NULL);
}

// Finalize a symbol value which can refer to the dot symbol.

void
Symbol_assignment::finalize_with_dot(Symbol_table* symtab,
				     const Layout* layout,
				     uint64_t dot_value,
				     Output_section* dot_section)
{
  this->finalize_maybe_dot(symtab, layout, true, dot_value, dot_section);
}

// Finalize a symbol value, internal version.

void
Symbol_assignment::finalize_maybe_dot(Symbol_table* symtab,
				      const Layout* layout,
				      bool is_dot_available,
				      uint64_t dot_value,
				      Output_section* dot_section)
{
  // If we were only supposed to provide this symbol, the sym_ field
  // will be NULL if the symbol was not referenced.
  if (this->sym_ == NULL)
    {
      gold_assert(this->provide_);
      return;
    }

  if (parameters->target().get_size() == 32)
    {
#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
      this->sized_finalize<32>(symtab, layout, is_dot_available, dot_value,
			       dot_section);
#else
      gold_unreachable();
#endif
    }
  else if (parameters->target().get_size() == 64)
    {
#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
      this->sized_finalize<64>(symtab, layout, is_dot_available, dot_value,
			       dot_section);
#else
      gold_unreachable();
#endif
    }
  else
    gold_unreachable();
}

template<int size>
void
Symbol_assignment::sized_finalize(Symbol_table* symtab, const Layout* layout,
				  bool is_dot_available, uint64_t dot_value,
				  Output_section* dot_section)
{
  Output_section* section;
  uint64_t final_val = this->val_->eval_maybe_dot(symtab, layout, true,
						  is_dot_available,
						  dot_value, dot_section,
						  &section, NULL, false);
  Sized_symbol<size>* ssym = symtab->get_sized_symbol<size>(this->sym_);
  ssym->set_value(final_val);
  if (section != NULL)
    ssym->set_output_section(section);
}

// Set the symbol value if the expression yields an absolute value or
// a value relative to DOT_SECTION.

void
Symbol_assignment::set_if_absolute(Symbol_table* symtab, const Layout* layout,
				   bool is_dot_available, uint64_t dot_value,
				   Output_section* dot_section)
{
  if (this->sym_ == NULL)
    return;

  Output_section* val_section;
  uint64_t val = this->val_->eval_maybe_dot(symtab, layout, false,
					    is_dot_available, dot_value,
					    dot_section, &val_section, NULL,
					    false);
  if (val_section != NULL && val_section != dot_section)
    return;

  if (parameters->target().get_size() == 32)
    {
#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
      Sized_symbol<32>* ssym = symtab->get_sized_symbol<32>(this->sym_);
      ssym->set_value(val);
#else
      gold_unreachable();
#endif
    }
  else if (parameters->target().get_size() == 64)
    {
#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
      Sized_symbol<64>* ssym = symtab->get_sized_symbol<64>(this->sym_);
      ssym->set_value(val);
#else
      gold_unreachable();
#endif
    }
  else
    gold_unreachable();
  if (val_section != NULL)
    this->sym_->set_output_section(val_section);
}

// Print for debugging.

void
Symbol_assignment::print(FILE* f) const
{
  if (this->provide_ && this->hidden_)
    fprintf(f, "PROVIDE_HIDDEN(");
  else if (this->provide_)
    fprintf(f, "PROVIDE(");
  else if (this->hidden_)
    gold_unreachable();

  fprintf(f, "%s = ", this->name_.c_str());
  this->val_->print(f);

  if (this->provide_ || this->hidden_)
    fprintf(f, ")");

  fprintf(f, "\n");
}

// Class Script_assertion.

// Check the assertion.

void
Script_assertion::check(const Symbol_table* symtab, const Layout* layout)
{
  if (!this->check_->eval(symtab, layout, true))
    gold_error("%s", this->message_.c_str());
}

// Print for debugging.

void
Script_assertion::print(FILE* f) const
{
  fprintf(f, "ASSERT(");
  this->check_->print(f);
  fprintf(f, ", \"%s\")\n", this->message_.c_str());
}

// Class Script_options.

Script_options::Script_options()
  : entry_(), symbol_assignments_(), symbol_definitions_(),
    symbol_references_(), version_script_info_(), script_sections_()
{
}

// Returns true if NAME is on the list of symbol assignments waiting
// to be processed.

bool
Script_options::is_pending_assignment(const char* name)
{
  for (Symbol_assignments::iterator p = this->symbol_assignments_.begin();
       p != this->symbol_assignments_.end();
       ++p)
    if ((*p)->name() == name)
      return true;
  return false;
}

// Add a symbol to be defined.

void
Script_options::add_symbol_assignment(const char* name, size_t length,
				      bool is_defsym, Expression* value,
				      bool provide, bool hidden)
{
  if (length != 1 || name[0] != '.')
    {
      if (this->script_sections_.in_sections_clause())
	{
	  gold_assert(!is_defsym);
	  this->script_sections_.add_symbol_assignment(name, length, value,
						       provide, hidden);
	}
      else
	{
	  Symbol_assignment* p = new Symbol_assignment(name, length, is_defsym,
						       value, provide, hidden);
	  this->symbol_assignments_.push_back(p);
	}

      if (!provide)
	{
	  std::string n(name, length);
	  this->symbol_definitions_.insert(n);
	  this->symbol_references_.erase(n);
	}
    }
  else
    {
      if (provide || hidden)
	gold_error(_("invalid use of PROVIDE for dot symbol"));

      // The GNU linker permits assignments to dot outside of SECTIONS
      // clauses and treats them as occurring inside, so we don't
      // check in_sections_clause here.
      this->script_sections_.add_dot_assignment(value);
    }
}

// Add a reference to a symbol.

void
Script_options::add_symbol_reference(const char* name, size_t length)
{
  if (length != 1 || name[0] != '.')
    {
      std::string n(name, length);
      if (this->symbol_definitions_.find(n) == this->symbol_definitions_.end())
	this->symbol_references_.insert(n);
    }
}

// Add an assertion.

void
Script_options::add_assertion(Expression* check, const char* message,
			      size_t messagelen)
{
  if (this->script_sections_.in_sections_clause())
    this->script_sections_.add_assertion(check, message, messagelen);
  else
    {
      Script_assertion* p = new Script_assertion(check, message, messagelen);
      this->assertions_.push_back(p);
    }
}

// Create sections required by any linker scripts.

void
Script_options::create_script_sections(Layout* layout)
{
  if (this->saw_sections_clause())
    this->script_sections_.create_sections(layout);
}

// Add any symbols we are defining to the symbol table.

void
Script_options::add_symbols_to_table(Symbol_table* symtab)
{
  for (Symbol_assignments::iterator p = this->symbol_assignments_.begin();
       p != this->symbol_assignments_.end();
       ++p)
    (*p)->add_to_table(symtab);
  this->script_sections_.add_symbols_to_table(symtab);
}

// Finalize symbol values.  Also check assertions.

void
Script_options::finalize_symbols(Symbol_table* symtab, const Layout* layout)
{
  // We finalize the symbols defined in SECTIONS first, because they
  // are the ones which may have changed.  This way if symbol outside
  // SECTIONS are defined in terms of symbols inside SECTIONS, they
  // will get the right value.
  this->script_sections_.finalize_symbols(symtab, layout);

  for (Symbol_assignments::iterator p = this->symbol_assignments_.begin();
       p != this->symbol_assignments_.end();
       ++p)
    (*p)->finalize(symtab, layout);

  for (Assertions::iterator p = this->assertions_.begin();
       p != this->assertions_.end();
       ++p)
    (*p)->check(symtab, layout);
}

// Set section addresses.  We set all the symbols which have absolute
// values.  Then we let the SECTIONS clause do its thing.  This
// returns the segment which holds the file header and segment
// headers, if any.

Output_segment*
Script_options::set_section_addresses(Symbol_table* symtab, Layout* layout)
{
  for (Symbol_assignments::iterator p = this->symbol_assignments_.begin();
       p != this->symbol_assignments_.end();
       ++p)
    (*p)->set_if_absolute(symtab, layout, false, 0, NULL);

  return this->script_sections_.set_section_addresses(symtab, layout);
}

// This class holds data passed through the parser to the lexer and to
// the parser support functions.  This avoids global variables.  We
// can't use global variables because we need not be called by a
// singleton thread.

class Parser_closure
{
 public:
  Parser_closure(const char* filename,
		 const Position_dependent_options& posdep_options,
		 bool parsing_defsym, bool in_group, bool is_in_sysroot,
                 Command_line* command_line,
		 Script_options* script_options,
		 Lex* lex,
		 bool skip_on_incompatible_target,
		 Script_info* script_info)
    : filename_(filename), posdep_options_(posdep_options),
      parsing_defsym_(parsing_defsym), in_group_(in_group),
      is_in_sysroot_(is_in_sysroot),
      skip_on_incompatible_target_(skip_on_incompatible_target),
      found_incompatible_target_(false),
      command_line_(command_line), script_options_(script_options),
      version_script_info_(script_options->version_script_info()),
      lex_(lex), lineno_(0), charpos_(0), lex_mode_stack_(), inputs_(NULL),
      script_info_(script_info)
  {
    // We start out processing C symbols in the default lex mode.
    this->language_stack_.push_back(Version_script_info::LANGUAGE_C);
    this->lex_mode_stack_.push_back(lex->mode());
  }

  // Return the file name.
  const char*
  filename() const
  { return this->filename_; }

  // Return the position dependent options.  The caller may modify
  // this.
  Position_dependent_options&
  position_dependent_options()
  { return this->posdep_options_; }

  // Whether we are parsing a --defsym.
  bool
  parsing_defsym() const
  { return this->parsing_defsym_; }

  // Return whether this script is being run in a group.
  bool
  in_group() const
  { return this->in_group_; }

  // Return whether this script was found using a directory in the
  // sysroot.
  bool
  is_in_sysroot() const
  { return this->is_in_sysroot_; }

  // Whether to skip to the next file with the same name if we find an
  // incompatible target in an OUTPUT_FORMAT statement.
  bool
  skip_on_incompatible_target() const
  { return this->skip_on_incompatible_target_; }

  // Stop skipping to the next file on an incompatible target.  This
  // is called when we make some unrevocable change to the data
  // structures.
  void
  clear_skip_on_incompatible_target()
  { this->skip_on_incompatible_target_ = false; }

  // Whether we found an incompatible target in an OUTPUT_FORMAT
  // statement.
  bool
  found_incompatible_target() const
  { return this->found_incompatible_target_; }

  // Note that we found an incompatible target.
  void
  set_found_incompatible_target()
  { this->found_incompatible_target_ = true; }

  // Returns the Command_line structure passed in at constructor time.
  // This value may be NULL.  The caller may modify this, which modifies
  // the passed-in Command_line object (not a copy).
  Command_line*
  command_line()
  { return this->command_line_; }

  // Return the options which may be set by a script.
  Script_options*
  script_options()
  { return this->script_options_; }

  // Return the object in which version script information should be stored.
  Version_script_info*
  version_script()
  { return this->version_script_info_; }

  // Return the next token, and advance.
  const Token*
  next_token()
  {
    const Token* token = this->lex_->next_token();
    this->lineno_ = token->lineno();
    this->charpos_ = token->charpos();
    return token;
  }

  // Set a new lexer mode, pushing the current one.
  void
  push_lex_mode(Lex::Mode mode)
  {
    this->lex_mode_stack_.push_back(this->lex_->mode());
    this->lex_->set_mode(mode);
  }

  // Pop the lexer mode.
  void
  pop_lex_mode()
  {
    gold_assert(!this->lex_mode_stack_.empty());
    this->lex_->set_mode(this->lex_mode_stack_.back());
    this->lex_mode_stack_.pop_back();
  }

  // Return the current lexer mode.
  Lex::Mode
  lex_mode() const
  { return this->lex_mode_stack_.back(); }

  // Return the line number of the last token.
  int
  lineno() const
  { return this->lineno_; }

  // Return the character position in the line of the last token.
  int
  charpos() const
  { return this->charpos_; }

  // Return the list of input files, creating it if necessary.  This
  // is a space leak--we never free the INPUTS_ pointer.
  Input_arguments*
  inputs()
  {
    if (this->inputs_ == NULL)
      this->inputs_ = new Input_arguments();
    return this->inputs_;
  }

  // Return whether we saw any input files.
  bool
  saw_inputs() const
  { return this->inputs_ != NULL && !this->inputs_->empty(); }

  // Return the current language being processed in a version script
  // (eg, "C++").  The empty string represents unmangled C names.
  Version_script_info::Language
  get_current_language() const
  { return this->language_stack_.back(); }

  // Push a language onto the stack when entering an extern block.
  void
  push_language(Version_script_info::Language lang)
  { this->language_stack_.push_back(lang); }

  // Pop a language off of the stack when exiting an extern block.
  void
  pop_language()
  {
    gold_assert(!this->language_stack_.empty());
    this->language_stack_.pop_back();
  }

  // Return a pointer to the incremental info.
  Script_info*
  script_info()
  { return this->script_info_; }

 private:
  // The name of the file we are reading.
  const char* filename_;
  // The position dependent options.
  Position_dependent_options posdep_options_;
  // True if we are parsing a --defsym.
  bool parsing_defsym_;
  // Whether we are currently in a --start-group/--end-group.
  bool in_group_;
  // Whether the script was found in a sysrooted directory.
  bool is_in_sysroot_;
  // If this is true, then if we find an OUTPUT_FORMAT with an
  // incompatible target, then we tell the parser to abort so that we
  // can search for the next file with the same name.
  bool skip_on_incompatible_target_;
  // True if we found an OUTPUT_FORMAT with an incompatible target.
  bool found_incompatible_target_;
  // May be NULL if the user chooses not to pass one in.
  Command_line* command_line_;
  // Options which may be set from any linker script.
  Script_options* script_options_;
  // Information parsed from a version script.
  Version_script_info* version_script_info_;
  // The lexer.
  Lex* lex_;
  // The line number of the last token returned by next_token.
  int lineno_;
  // The column number of the last token returned by next_token.
  int charpos_;
  // A stack of lexer modes.
  std::vector<Lex::Mode> lex_mode_stack_;
  // A stack of which extern/language block we're inside. Can be C++,
  // java, or empty for C.
  std::vector<Version_script_info::Language> language_stack_;
  // New input files found to add to the link.
  Input_arguments* inputs_;
  // Pointer to incremental linking info.
  Script_info* script_info_;
};

// FILE was found as an argument on the command line.  Try to read it
// as a script.  Return true if the file was handled.

bool
read_input_script(Workqueue* workqueue, Symbol_table* symtab, Layout* layout,
		  Dirsearch* dirsearch, int dirindex,
		  Input_objects* input_objects, Mapfile* mapfile,
		  Input_group* input_group,
		  const Input_argument* input_argument,
		  Input_file* input_file, Task_token* next_blocker,
		  bool* used_next_blocker)
{
  *used_next_blocker = false;

  std::string input_string;
  Lex::read_file(input_file, &input_string);

  Lex lex(input_string.c_str(), input_string.length(), PARSING_LINKER_SCRIPT);

  Script_info* script_info = NULL;
  if (layout->incremental_inputs() != NULL)
    {
      const std::string& filename = input_file->filename();
      Timespec mtime = input_file->file().get_mtime();
      unsigned int arg_serial = input_argument->file().arg_serial();
      script_info = new Script_info(filename);
      layout->incremental_inputs()->report_script(script_info, arg_serial,
						  mtime);
    }

  Parser_closure closure(input_file->filename().c_str(),
			 input_argument->file().options(),
			 false,
			 input_group != NULL,
			 input_file->is_in_sysroot(),
                         NULL,
			 layout->script_options(),
			 &lex,
			 input_file->will_search_for(),
			 script_info);

  bool old_saw_sections_clause =
    layout->script_options()->saw_sections_clause();

  if (yyparse(&closure) != 0)
    {
      if (closure.found_incompatible_target())
	{
	  Read_symbols::incompatible_warning(input_argument, input_file);
	  Read_symbols::requeue(workqueue, input_objects, symtab, layout,
				dirsearch, dirindex, mapfile, input_argument,
				input_group, next_blocker);
	  return true;
	}
      return false;
    }

  if (!old_saw_sections_clause
      && layout->script_options()->saw_sections_clause()
      && layout->have_added_input_section())
    gold_error(_("%s: SECTIONS seen after other input files; try -T/--script"),
	       input_file->filename().c_str());

  if (!closure.saw_inputs())
    return true;

  Task_token* this_blocker = NULL;
  for (Input_arguments::const_iterator p = closure.inputs()->begin();
       p != closure.inputs()->end();
       ++p)
    {
      Task_token* nb;
      if (p + 1 == closure.inputs()->end())
	nb = next_blocker;
      else
	{
	  nb = new Task_token(true);
	  nb->add_blocker();
	}
      workqueue->queue_soon(new Read_symbols(input_objects, symtab,
					     layout, dirsearch, 0, mapfile, &*p,
					     input_group, NULL, this_blocker, nb));
      this_blocker = nb;
    }

  *used_next_blocker = true;

  return true;
}

// Helper function for read_version_script(), read_commandline_script() and
// script_include_directive().  Processes the given file in the mode indicated
// by first_token and lex_mode.

static bool
read_script_file(const char* filename, Command_line* cmdline,
                 Script_options* script_options,
                 int first_token, Lex::Mode lex_mode)
{
  Dirsearch dirsearch;
  std::string name = filename;

  // If filename is a relative filename, search for it manually using "." +
  // cmdline->options()->library_path() -- not dirsearch.
  if (!IS_ABSOLUTE_PATH(filename))
    {
      const General_options::Dir_list& search_path =
          cmdline->options().library_path();
      name = Dirsearch::find_file_in_dir_list(name, search_path, ".");
    }

  // The file locking code wants to record a Task, but we haven't
  // started the workqueue yet.  This is only for debugging purposes,
  // so we invent a fake value.
  const Task* task = reinterpret_cast<const Task*>(-1);

  // We don't want this file to be opened in binary mode.
  Position_dependent_options posdep = cmdline->position_dependent_options();
  if (posdep.format_enum() == General_options::OBJECT_FORMAT_BINARY)
    posdep.set_format_enum(General_options::OBJECT_FORMAT_ELF);
  Input_file_argument input_argument(name.c_str(),
				     Input_file_argument::INPUT_FILE_TYPE_FILE,
				     "", false, posdep);
  Input_file input_file(&input_argument);
  int dummy = 0;
  if (!input_file.open(dirsearch, task, &dummy))
    return false;

  std::string input_string;
  Lex::read_file(&input_file, &input_string);

  Lex lex(input_string.c_str(), input_string.length(), first_token);
  lex.set_mode(lex_mode);

  Parser_closure closure(filename,
			 cmdline->position_dependent_options(),
			 first_token == Lex::DYNAMIC_LIST,
			 false,
			 input_file.is_in_sysroot(),
                         cmdline,
			 script_options,
			 &lex,
			 false,
			 NULL);
  if (yyparse(&closure) != 0)
    {
      input_file.file().unlock(task);
      return false;
    }

  input_file.file().unlock(task);

  gold_assert(!closure.saw_inputs());

  return true;
}

// FILENAME was found as an argument to --script (-T).
// Read it as a script, and execute its contents immediately.

bool
read_commandline_script(const char* filename, Command_line* cmdline)
{
  return read_script_file(filename, cmdline, &cmdline->script_options(),
                          PARSING_LINKER_SCRIPT, Lex::LINKER_SCRIPT);
}

// FILENAME was found as an argument to --version-script.  Read it as
// a version script, and store its contents in
// cmdline->script_options()->version_script_info().

bool
read_version_script(const char* filename, Command_line* cmdline)
{
  return read_script_file(filename, cmdline, &cmdline->script_options(),
                          PARSING_VERSION_SCRIPT, Lex::VERSION_SCRIPT);
}

// FILENAME was found as an argument to --dynamic-list.  Read it as a
// list of symbols, and store its contents in DYNAMIC_LIST.

bool
read_dynamic_list(const char* filename, Command_line* cmdline,
                  Script_options* dynamic_list)
{
  return read_script_file(filename, cmdline, dynamic_list,
                          PARSING_DYNAMIC_LIST, Lex::DYNAMIC_LIST);
}

// Implement the --defsym option on the command line.  Return true if
// all is well.

bool
Script_options::define_symbol(const char* definition)
{
  Lex lex(definition, strlen(definition), PARSING_DEFSYM);
  lex.set_mode(Lex::EXPRESSION);

  // Dummy value.
  Position_dependent_options posdep_options;

  Parser_closure closure("command line", posdep_options, true,
			 false, false, NULL, this, &lex, false, NULL);

  if (yyparse(&closure) != 0)
    return false;

  gold_assert(!closure.saw_inputs());

  return true;
}

// Print the script to F for debugging.

void
Script_options::print(FILE* f) const
{
  fprintf(f, "%s: Dumping linker script\n", program_name);

  if (!this->entry_.empty())
    fprintf(f, "ENTRY(%s)\n", this->entry_.c_str());

  for (Symbol_assignments::const_iterator p =
	 this->symbol_assignments_.begin();
       p != this->symbol_assignments_.end();
       ++p)
    (*p)->print(f);

  for (Assertions::const_iterator p = this->assertions_.begin();
       p != this->assertions_.end();
       ++p)
    (*p)->print(f);

  this->script_sections_.print(f);

  this->version_script_info_.print(f);
}

// Manage mapping from keywords to the codes expected by the bison
// parser.  We construct one global object for each lex mode with
// keywords.

class Keyword_to_parsecode
{
 public:
  // The structure which maps keywords to parsecodes.
  struct Keyword_parsecode
  {
    // Keyword.
    const char* keyword;
    // Corresponding parsecode.
    int parsecode;
  };

  Keyword_to_parsecode(const Keyword_parsecode* keywords,
                       int keyword_count)
      : keyword_parsecodes_(keywords), keyword_count_(keyword_count)
  { }

  // Return the parsecode corresponding KEYWORD, or 0 if it is not a
  // keyword.
  int
  keyword_to_parsecode(const char* keyword, size_t len) const;

 private:
  const Keyword_parsecode* keyword_parsecodes_;
  const int keyword_count_;
};

// Mapping from keyword string to keyword parsecode.  This array must
// be kept in sorted order.  Parsecodes are looked up using bsearch.
// This array must correspond to the list of parsecodes in yyscript.y.

static const Keyword_to_parsecode::Keyword_parsecode
script_keyword_parsecodes[] =
{
  { "ABSOLUTE", ABSOLUTE },
  { "ADDR", ADDR },
  { "ALIGN", ALIGN_K },
  { "ALIGNOF", ALIGNOF },
  { "ASSERT", ASSERT_K },
  { "AS_NEEDED", AS_NEEDED },
  { "AT", AT },
  { "BIND", BIND },
  { "BLOCK", BLOCK },
  { "BYTE", BYTE },
  { "CONSTANT", CONSTANT },
  { "CONSTRUCTORS", CONSTRUCTORS },
  { "COPY", COPY },
  { "CREATE_OBJECT_SYMBOLS", CREATE_OBJECT_SYMBOLS },
  { "DATA_SEGMENT_ALIGN", DATA_SEGMENT_ALIGN },
  { "DATA_SEGMENT_END", DATA_SEGMENT_END },
  { "DATA_SEGMENT_RELRO_END", DATA_SEGMENT_RELRO_END },
  { "DEFINED", DEFINED },
  { "DSECT", DSECT },
  { "ENTRY", ENTRY },
  { "EXCLUDE_FILE", EXCLUDE_FILE },
  { "EXTERN", EXTERN },
  { "FILL", FILL },
  { "FLOAT", FLOAT },
  { "FORCE_COMMON_ALLOCATION", FORCE_COMMON_ALLOCATION },
  { "GROUP", GROUP },
  { "HLL", HLL },
  { "INCLUDE", INCLUDE },
  { "INFO", INFO },
  { "INHIBIT_COMMON_ALLOCATION", INHIBIT_COMMON_ALLOCATION },
  { "INPUT", INPUT },
  { "KEEP", KEEP },
  { "LENGTH", LENGTH },
  { "LOADADDR", LOADADDR },
  { "LONG", LONG },
  { "MAP", MAP },
  { "MAX", MAX_K },
  { "MEMORY", MEMORY },
  { "MIN", MIN_K },
  { "NEXT", NEXT },
  { "NOCROSSREFS", NOCROSSREFS },
  { "NOFLOAT", NOFLOAT },
  { "NOLOAD", NOLOAD },
  { "ONLY_IF_RO", ONLY_IF_RO },
  { "ONLY_IF_RW", ONLY_IF_RW },
  { "OPTION", OPTION },
  { "ORIGIN", ORIGIN },
  { "OUTPUT", OUTPUT },
  { "OUTPUT_ARCH", OUTPUT_ARCH },
  { "OUTPUT_FORMAT", OUTPUT_FORMAT },
  { "OVERLAY", OVERLAY },
  { "PHDRS", PHDRS },
  { "PROVIDE", PROVIDE },
  { "PROVIDE_HIDDEN", PROVIDE_HIDDEN },
  { "QUAD", QUAD },
  { "SEARCH_DIR", SEARCH_DIR },
  { "SECTIONS", SECTIONS },
  { "SEGMENT_START", SEGMENT_START },
  { "SHORT", SHORT },
  { "SIZEOF", SIZEOF },
  { "SIZEOF_HEADERS", SIZEOF_HEADERS },
  { "SORT", SORT_BY_NAME },
  { "SORT_BY_ALIGNMENT", SORT_BY_ALIGNMENT },
  { "SORT_BY_NAME", SORT_BY_NAME },
  { "SPECIAL", SPECIAL },
  { "SQUAD", SQUAD },
  { "STARTUP", STARTUP },
  { "SUBALIGN", SUBALIGN },
  { "SYSLIB", SYSLIB },
  { "TARGET", TARGET_K },
  { "TRUNCATE", TRUNCATE },
  { "VERSION", VERSIONK },
  { "global", GLOBAL },
  { "l", LENGTH },
  { "len", LENGTH },
  { "local", LOCAL },
  { "o", ORIGIN },
  { "org", ORIGIN },
  { "sizeof_headers", SIZEOF_HEADERS },
};

static const Keyword_to_parsecode
script_keywords(&script_keyword_parsecodes[0],
                (sizeof(script_keyword_parsecodes)
                 / sizeof(script_keyword_parsecodes[0])));

static const Keyword_to_parsecode::Keyword_parsecode
version_script_keyword_parsecodes[] =
{
  { "extern", EXTERN },
  { "global", GLOBAL },
  { "local", LOCAL },
};

static const Keyword_to_parsecode
version_script_keywords(&version_script_keyword_parsecodes[0],
                        (sizeof(version_script_keyword_parsecodes)
                         / sizeof(version_script_keyword_parsecodes[0])));

static const Keyword_to_parsecode::Keyword_parsecode
dynamic_list_keyword_parsecodes[] =
{
  { "extern", EXTERN },
};

static const Keyword_to_parsecode
dynamic_list_keywords(&dynamic_list_keyword_parsecodes[0],
                      (sizeof(dynamic_list_keyword_parsecodes)
                       / sizeof(dynamic_list_keyword_parsecodes[0])));



// Comparison function passed to bsearch.

extern "C"
{

struct Ktt_key
{
  const char* str;
  size_t len;
};

static int
ktt_compare(const void* keyv, const void* kttv)
{
  const Ktt_key* key = static_cast<const Ktt_key*>(keyv);
  const Keyword_to_parsecode::Keyword_parsecode* ktt =
    static_cast<const Keyword_to_parsecode::Keyword_parsecode*>(kttv);
  int i = strncmp(key->str, ktt->keyword, key->len);
  if (i != 0)
    return i;
  if (ktt->keyword[key->len] != '\0')
    return -1;
  return 0;
}

} // End extern "C".

int
Keyword_to_parsecode::keyword_to_parsecode(const char* keyword,
                                           size_t len) const
{
  Ktt_key key;
  key.str = keyword;
  key.len = len;
  void* kttv = bsearch(&key,
                       this->keyword_parsecodes_,
                       this->keyword_count_,
                       sizeof(this->keyword_parsecodes_[0]),
                       ktt_compare);
  if (kttv == NULL)
    return 0;
  Keyword_parsecode* ktt = static_cast<Keyword_parsecode*>(kttv);
  return ktt->parsecode;
}

// The following structs are used within the VersionInfo class as well
// as in the bison helper functions.  They store the information
// parsed from the version script.

// A single version expression.
// For example, pattern="std::map*" and language="C++".
struct Version_expression
{
  Version_expression(const std::string& a_pattern,
		     Version_script_info::Language a_language,
                     bool a_exact_match)
    : pattern(a_pattern), language(a_language), exact_match(a_exact_match),
      was_matched_by_symbol(false)
  { }

  std::string pattern;
  Version_script_info::Language language;
  // If false, we use glob() to match pattern.  If true, we use strcmp().
  bool exact_match;
  // True if --no-undefined-version is in effect and we found this
  // version in get_symbol_version.  We use mutable because this
  // struct is generally not modifiable after it has been created.
  mutable bool was_matched_by_symbol;
};

// A list of expressions.
struct Version_expression_list
{
  std::vector<struct Version_expression> expressions;
};

// A list of which versions upon which another version depends.
// Strings should be from the Stringpool.
struct Version_dependency_list
{
  std::vector<std::string> dependencies;
};

// The total definition of a version.  It includes the tag for the
// version, its global and local expressions, and any dependencies.
struct Version_tree
{
  Version_tree()
      : tag(), global(NULL), local(NULL), dependencies(NULL)
  { }

  std::string tag;
  const struct Version_expression_list* global;
  const struct Version_expression_list* local;
  const struct Version_dependency_list* dependencies;
};

// Helper class that calls cplus_demangle when needed and takes care of freeing
// the result.

class Lazy_demangler
{
 public:
  Lazy_demangler(const char* symbol, int options)
    : symbol_(symbol), options_(options), demangled_(NULL), did_demangle_(false)
  { }

  ~Lazy_demangler()
  { free(this->demangled_); }

  // Return the demangled name. The actual demangling happens on the first call,
  // and the result is later cached.
  inline char*
  get();

 private:
  // The symbol to demangle.
  const char* symbol_;
  // Option flags to pass to cplus_demagle.
  const int options_;
  // The cached demangled value, or NULL if demangling didn't happen yet or
  // failed.
  char* demangled_;
  // Whether we already called cplus_demangle
  bool did_demangle_;
};

// Return the demangled name. The actual demangling happens on the first call,
// and the result is later cached. Returns NULL if the symbol cannot be
// demangled.

inline char*
Lazy_demangler::get()
{
  if (!this->did_demangle_)
    {
      this->demangled_ = cplus_demangle(this->symbol_, this->options_);
      this->did_demangle_ = true;
    }
  return this->demangled_;
}

// Class Version_script_info.

Version_script_info::Version_script_info()
  : dependency_lists_(), expression_lists_(), version_trees_(), globs_(),
    default_version_(NULL), default_is_global_(false), is_finalized_(false)
{
  for (int i = 0; i < LANGUAGE_COUNT; ++i)
    this->exact_[i] = NULL;
}

Version_script_info::~Version_script_info()
{
}

// Forget all the known version script information.

void
Version_script_info::clear()
{
  for (size_t k = 0; k < this->dependency_lists_.size(); ++k)
    delete this->dependency_lists_[k];
  this->dependency_lists_.clear();
  for (size_t k = 0; k < this->version_trees_.size(); ++k)
    delete this->version_trees_[k];
  this->version_trees_.clear();
  for (size_t k = 0; k < this->expression_lists_.size(); ++k)
    delete this->expression_lists_[k];
  this->expression_lists_.clear();
}

// Finalize the version script information.

void
Version_script_info::finalize()
{
  if (!this->is_finalized_)
    {
      this->build_lookup_tables();
      this->is_finalized_ = true;
    }
}

// Return all the versions.

std::vector<std::string>
Version_script_info::get_versions() const
{
  std::vector<std::string> ret;
  for (size_t j = 0; j < this->version_trees_.size(); ++j)
    if (!this->version_trees_[j]->tag.empty())
      ret.push_back(this->version_trees_[j]->tag);
  return ret;
}

// Return the dependencies of VERSION.

std::vector<std::string>
Version_script_info::get_dependencies(const char* version) const
{
  std::vector<std::string> ret;
  for (size_t j = 0; j < this->version_trees_.size(); ++j)
    if (this->version_trees_[j]->tag == version)
      {
        const struct Version_dependency_list* deps =
          this->version_trees_[j]->dependencies;
        if (deps != NULL)
          for (size_t k = 0; k < deps->dependencies.size(); ++k)
            ret.push_back(deps->dependencies[k]);
        return ret;
      }
  return ret;
}

// A version script essentially maps a symbol name to a version tag
// and an indication of whether symbol is global or local within that
// version tag.  Each symbol maps to at most one version tag.
// Unfortunately, in practice, version scripts are ambiguous, and list
// symbols multiple times.  Thus, we have to document the matching
// process.

// This is a description of what the GNU linker does as of 2010-01-11.
// It walks through the version tags in the order in which they appear
// in the version script.  For each tag, it first walks through the
// global patterns for that tag, then the local patterns.  When
// looking at a single pattern, it first applies any language specific
// demangling as specified for the pattern, and then matches the
// resulting symbol name to the pattern.  If it finds an exact match
// for a literal pattern (a pattern enclosed in quotes or with no
// wildcard characters), then that is the match that it uses.  If
// finds a match with a wildcard pattern, then it saves it and
// continues searching.  Wildcard patterns that are exactly "*" are
// saved separately.

// If no exact match with a literal pattern is ever found, then if a
// wildcard match with a global pattern was found it is used,
// otherwise if a wildcard match with a local pattern was found it is
// used.

// This is the result:
//   * If there is an exact match, then we use the first tag in the
//     version script where it matches.
//     + If the exact match in that tag is global, it is used.
//     + Otherwise the exact match in that tag is local, and is used.
//   * Otherwise, if there is any match with a global wildcard pattern:
//     + If there is any match with a wildcard pattern which is not
//       "*", then we use the tag in which the *last* such pattern
//       appears.
//     + Otherwise, we matched "*".  If there is no match with a local
//       wildcard pattern which is not "*", then we use the *last*
//       match with a global "*".  Otherwise, continue.
//   * Otherwise, if there is any match with a local wildcard pattern:
//     + If there is any match with a wildcard pattern which is not
//       "*", then we use the tag in which the *last* such pattern
//       appears.
//     + Otherwise, we matched "*", and we use the tag in which the
//       *last* such match occurred.

// There is an additional wrinkle.  When the GNU linker finds a symbol
// with a version defined in an object file due to a .symver
// directive, it looks up that symbol name in that version tag.  If it
// finds it, it matches the symbol name against the patterns for that
// version.  If there is no match with a global pattern, but there is
// a match with a local pattern, then the GNU linker marks the symbol
// as local.

// We want gold to be generally compatible, but we also want gold to
// be fast.  These are the rules that gold implements:
//   * If there is an exact match for the mangled name, we use it.
//     + If there is more than one exact match, we give a warning, and
//       we use the first tag in the script which matches.
//     + If a symbol has an exact match as both global and local for
//       the same version tag, we give an error.
//   * Otherwise, we look for an extern C++ or an extern Java exact
//     match.  If we find an exact match, we use it.
//     + If there is more than one exact match, we give a warning, and
//       we use the first tag in the script which matches.
//     + If a symbol has an exact match as both global and local for
//       the same version tag, we give an error.
//   * Otherwise, we look through the wildcard patterns, ignoring "*"
//     patterns.  We look through the version tags in reverse order.
//     For each version tag, we look through the global patterns and
//     then the local patterns.  We use the first match we find (i.e.,
//     the last matching version tag in the file).
//   * Otherwise, we use the "*" pattern if there is one.  We give an
//     error if there are multiple "*" patterns.

// At least for now, gold does not look up the version tag for a
// symbol version found in an object file to see if it should be
// forced local.  There are other ways to force a symbol to be local,
// and I don't understand why this one is useful.

// Build a set of fast lookup tables for a version script.

void
Version_script_info::build_lookup_tables()
{
  size_t size = this->version_trees_.size();
  for (size_t j = 0; j < size; ++j)
    {
      const Version_tree* v = this->version_trees_[j];
      this->build_expression_list_lookup(v->local, v, false);
      this->build_expression_list_lookup(v->global, v, true);
    }
}

// If a pattern has backlashes but no unquoted wildcard characters,
// then we apply backslash unquoting and look for an exact match.
// Otherwise we treat it as a wildcard pattern.  This function returns
// true for a wildcard pattern.  Otherwise, it does backslash
// unquoting on *PATTERN and returns false.  If this returns true,
// *PATTERN may have been partially unquoted.

bool
Version_script_info::unquote(std::string* pattern) const
{
  bool saw_backslash = false;
  size_t len = pattern->length();
  size_t j = 0;
  for (size_t i = 0; i < len; ++i)
    {
      if (saw_backslash)
	saw_backslash = false;
      else
	{
	  switch ((*pattern)[i])
	    {
	    case '?': case '[': case '*':
	      return true;
	    case '\\':
	      saw_backslash = true;
	      continue;
	    default:
	      break;
	    }
	}

      if (i != j)
	(*pattern)[j] = (*pattern)[i];
      ++j;
    }
  return false;
}

// Add an exact match for MATCH to *PE.  The result of the match is
// V/IS_GLOBAL.

void
Version_script_info::add_exact_match(const std::string& match,
				     const Version_tree* v, bool is_global,
				     const Version_expression* ve,
				     Exact* pe)
{
  std::pair<Exact::iterator, bool> ins =
    pe->insert(std::make_pair(match, Version_tree_match(v, is_global, ve)));
  if (ins.second)
    {
      // This is the first time we have seen this match.
      return;
    }

  Version_tree_match& vtm(ins.first->second);
  if (vtm.real->tag != v->tag)
    {
      // This is an ambiguous match.  We still return the
      // first version that we found in the script, but we
      // record the new version to issue a warning if we
      // wind up looking up this symbol.
      if (vtm.ambiguous == NULL)
	vtm.ambiguous = v;
    }
  else if (is_global != vtm.is_global)
    {
      // We have a match for both the global and local entries for a
      // version tag.  That's got to be wrong.
      gold_error(_("'%s' appears as both a global and a local symbol "
		   "for version '%s' in script"),
		 match.c_str(), v->tag.c_str());
    }
}

// Build fast lookup information for EXPLIST and store it in LOOKUP.
// All matches go to V, and IS_GLOBAL is true if they are global
// matches.

void
Version_script_info::build_expression_list_lookup(
    const Version_expression_list* explist,
    const Version_tree* v,
    bool is_global)
{
  if (explist == NULL)
    return;
  size_t size = explist->expressions.size();
  for (size_t i = 0; i < size; ++i)
    {
      const Version_expression& exp(explist->expressions[i]);

      if (exp.pattern.length() == 1 && exp.pattern[0] == '*')
	{
	  if (this->default_version_ != NULL
	      && this->default_version_->tag != v->tag)
	    gold_warning(_("wildcard match appears in both version '%s' "
			   "and '%s' in script"),
			 this->default_version_->tag.c_str(), v->tag.c_str());
	  else if (this->default_version_ != NULL
		   && this->default_is_global_ != is_global)
	    gold_error(_("wildcard match appears as both global and local "
			 "in version '%s' in script"),
		       v->tag.c_str());
	  this->default_version_ = v;
	  this->default_is_global_ = is_global;
	  continue;
	}

      std::string pattern = exp.pattern;
      if (!exp.exact_match)
	{
	  if (this->unquote(&pattern))
	    {
	      this->globs_.push_back(Glob(&exp, v, is_global));
	      continue;
	    }
	}

      if (this->exact_[exp.language] == NULL)
	this->exact_[exp.language] = new Exact();
      this->add_exact_match(pattern, v, is_global, &exp,
			    this->exact_[exp.language]);
    }
}

// Return the name to match given a name, a language code, and two
// lazy demanglers.

const char*
Version_script_info::get_name_to_match(const char* name,
				       int language,
				       Lazy_demangler* cpp_demangler,
				       Lazy_demangler* java_demangler) const
{
  switch (language)
    {
    case LANGUAGE_C:
      return name;
    case LANGUAGE_CXX:
      return cpp_demangler->get();
    case LANGUAGE_JAVA:
      return java_demangler->get();
    default:
      gold_unreachable();
    }
}

// Look up SYMBOL_NAME in the list of versions.  Return true if the
// symbol is found, false if not.  If the symbol is found, then if
// PVERSION is not NULL, set *PVERSION to the version tag, and if
// P_IS_GLOBAL is not NULL, set *P_IS_GLOBAL according to whether the
// symbol is global or not.

bool
Version_script_info::get_symbol_version(const char* symbol_name,
					std::string* pversion,
					bool* p_is_global) const
{
  Lazy_demangler cpp_demangled_name(symbol_name, DMGL_ANSI | DMGL_PARAMS);
  Lazy_demangler java_demangled_name(symbol_name,
				     DMGL_ANSI | DMGL_PARAMS | DMGL_JAVA);

  gold_assert(this->is_finalized_);
  for (int i = 0; i < LANGUAGE_COUNT; ++i)
    {
      Exact* exact = this->exact_[i];
      if (exact == NULL)
	continue;

      const char* name_to_match = this->get_name_to_match(symbol_name, i,
							  &cpp_demangled_name,
							  &java_demangled_name);
      if (name_to_match == NULL)
	{
	  // If the name can not be demangled, the GNU linker goes
	  // ahead and tries to match it anyhow.  That does not
	  // make sense to me and I have not implemented it.
	  continue;
	}

      Exact::const_iterator pe = exact->find(name_to_match);
      if (pe != exact->end())
	{
	  const Version_tree_match& vtm(pe->second);
	  if (vtm.ambiguous != NULL)
	    gold_warning(_("using '%s' as version for '%s' which is also "
			   "named in version '%s' in script"),
			 vtm.real->tag.c_str(), name_to_match,
			 vtm.ambiguous->tag.c_str());

	  if (pversion != NULL)
	    *pversion = vtm.real->tag;
	  if (p_is_global != NULL)
	    *p_is_global = vtm.is_global;

	  // If we are using --no-undefined-version, and this is a
	  // global symbol, we have to record that we have found this
	  // symbol, so that we don't warn about it.  We have to do
	  // this now, because otherwise we have no way to get from a
	  // non-C language back to the demangled name that we
	  // matched.
	  if (p_is_global != NULL && vtm.is_global)
	    vtm.expression->was_matched_by_symbol = true;

	  return true;
	}
    }

  // Look through the glob patterns in reverse order.

  for (Globs::const_reverse_iterator p = this->globs_.rbegin();
       p != this->globs_.rend();
       ++p)
    {
      int language = p->expression->language;
      const char* name_to_match = this->get_name_to_match(symbol_name,
							  language,
							  &cpp_demangled_name,
							  &java_demangled_name);
      if (name_to_match == NULL)
	continue;

      if (fnmatch(p->expression->pattern.c_str(), name_to_match,
		  FNM_NOESCAPE) == 0)
	{
	  if (pversion != NULL)
	    *pversion = p->version->tag;
	  if (p_is_global != NULL)
	    *p_is_global = p->is_global;
	  return true;
	}
    }

  // Finally, there may be a wildcard.
  if (this->default_version_ != NULL)
    {
      if (pversion != NULL)
	*pversion = this->default_version_->tag;
      if (p_is_global != NULL)
	*p_is_global = this->default_is_global_;
      return true;
    }

  return false;
}

// Give an error if any exact symbol names (not wildcards) appear in a
// version script, but there is no such symbol.

void
Version_script_info::check_unmatched_names(const Symbol_table* symtab) const
{
  for (size_t i = 0; i < this->version_trees_.size(); ++i)
    {
      const Version_tree* vt = this->version_trees_[i];
      if (vt->global == NULL)
	continue;
      for (size_t j = 0; j < vt->global->expressions.size(); ++j)
	{
	  const Version_expression& expression(vt->global->expressions[j]);

	  // Ignore cases where we used the version because we saw a
	  // symbol that we looked up.  Note that
	  // WAS_MATCHED_BY_SYMBOL will be true even if the symbol was
	  // not a definition.  That's OK as in that case we most
	  // likely gave an undefined symbol error anyhow.
	  if (expression.was_matched_by_symbol)
	    continue;

	  // Just ignore names which are in languages other than C.
	  // We have no way to look them up in the symbol table.
	  if (expression.language != LANGUAGE_C)
	    continue;

	  // Remove backslash quoting, and ignore wildcard patterns.
	  std::string pattern = expression.pattern;
	  if (!expression.exact_match)
	    {
	      if (this->unquote(&pattern))
		continue;
	    }

	  if (symtab->lookup(pattern.c_str(), vt->tag.c_str()) == NULL)
	    gold_error(_("version script assignment of %s to symbol %s "
			 "failed: symbol not defined"),
		       vt->tag.c_str(), pattern.c_str());
	}
    }
}

struct Version_dependency_list*
Version_script_info::allocate_dependency_list()
{
  dependency_lists_.push_back(new Version_dependency_list);
  return dependency_lists_.back();
}

struct Version_expression_list*
Version_script_info::allocate_expression_list()
{
  expression_lists_.push_back(new Version_expression_list);
  return expression_lists_.back();
}

struct Version_tree*
Version_script_info::allocate_version_tree()
{
  version_trees_.push_back(new Version_tree);
  return version_trees_.back();
}

// Print for debugging.

void
Version_script_info::print(FILE* f) const
{
  if (this->empty())
    return;

  fprintf(f, "VERSION {");

  for (size_t i = 0; i < this->version_trees_.size(); ++i)
    {
      const Version_tree* vt = this->version_trees_[i];

      if (vt->tag.empty())
	fprintf(f, "  {\n");
      else
	fprintf(f, "  %s {\n", vt->tag.c_str());

      if (vt->global != NULL)
	{
	  fprintf(f, "    global :\n");
	  this->print_expression_list(f, vt->global);
	}

      if (vt->local != NULL)
	{
	  fprintf(f, "    local :\n");
	  this->print_expression_list(f, vt->local);
	}

      fprintf(f, "  }");
      if (vt->dependencies != NULL)
	{
	  const Version_dependency_list* deps = vt->dependencies;
	  for (size_t j = 0; j < deps->dependencies.size(); ++j)
	    {
	      if (j < deps->dependencies.size() - 1)
		fprintf(f, "\n");
	      fprintf(f, "    %s", deps->dependencies[j].c_str());
	    }
	}
      fprintf(f, ";\n");
    }

  fprintf(f, "}\n");
}

void
Version_script_info::print_expression_list(
    FILE* f,
    const Version_expression_list* vel) const
{
  Version_script_info::Language current_language = LANGUAGE_C;
  for (size_t i = 0; i < vel->expressions.size(); ++i)
    {
      const Version_expression& ve(vel->expressions[i]);

      if (ve.language != current_language)
	{
	  if (current_language != LANGUAGE_C)
	    fprintf(f, "      }\n");
	  switch (ve.language)
	    {
	    case LANGUAGE_C:
	      break;
	    case LANGUAGE_CXX:
	      fprintf(f, "      extern \"C++\" {\n");
	      break;
	    case LANGUAGE_JAVA:
	      fprintf(f, "      extern \"Java\" {\n");
	      break;
	    default:
	      gold_unreachable();
	    }
	  current_language = ve.language;
	}

      fprintf(f, "      ");
      if (current_language != LANGUAGE_C)
	fprintf(f, "  ");

      if (ve.exact_match)
	fprintf(f, "\"");
      fprintf(f, "%s", ve.pattern.c_str());
      if (ve.exact_match)
	fprintf(f, "\"");

      fprintf(f, "\n");
    }

  if (current_language != LANGUAGE_C)
    fprintf(f, "      }\n");
}

} // End namespace gold.

// The remaining functions are extern "C", so it's clearer to not put
// them in namespace gold.

using namespace gold;

// This function is called by the bison parser to return the next
// token.

extern "C" int
yylex(YYSTYPE* lvalp, void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  const Token* token = closure->next_token();
  switch (token->classification())
    {
    default:
      gold_unreachable();

    case Token::TOKEN_INVALID:
      yyerror(closurev, "invalid character");
      return 0;

    case Token::TOKEN_EOF:
      return 0;

    case Token::TOKEN_STRING:
      {
	// This is either a keyword or a STRING.
	size_t len;
	const char* str = token->string_value(&len);
	int parsecode = 0;
        switch (closure->lex_mode())
          {
          case Lex::LINKER_SCRIPT:
            parsecode = script_keywords.keyword_to_parsecode(str, len);
            break;
          case Lex::VERSION_SCRIPT:
            parsecode = version_script_keywords.keyword_to_parsecode(str, len);
            break;
          case Lex::DYNAMIC_LIST:
            parsecode = dynamic_list_keywords.keyword_to_parsecode(str, len);
            break;
          default:
            break;
          }
	if (parsecode != 0)
	  return parsecode;
	lvalp->string.value = str;
	lvalp->string.length = len;
	return STRING;
      }

    case Token::TOKEN_QUOTED_STRING:
      lvalp->string.value = token->string_value(&lvalp->string.length);
      return QUOTED_STRING;

    case Token::TOKEN_OPERATOR:
      return token->operator_value();

    case Token::TOKEN_INTEGER:
      lvalp->integer = token->integer_value();
      return INTEGER;
    }
}

// This function is called by the bison parser to report an error.

extern "C" void
yyerror(void* closurev, const char* message)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  gold_error(_("%s:%d:%d: %s"), closure->filename(), closure->lineno(),
	     closure->charpos(), message);
}

// Called by the bison parser to add an external symbol to the link.

extern "C" void
script_add_extern(void* closurev, const char* name, size_t length)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->script_options()->add_symbol_reference(name, length);
}

// Called by the bison parser to add a file to the link.

extern "C" void
script_add_file(void* closurev, const char* name, size_t length)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);

  // If this is an absolute path, and we found the script in the
  // sysroot, then we want to prepend the sysroot to the file name.
  // For example, this is how we handle a cross link to the x86_64
  // libc.so, which refers to /lib/libc.so.6.
  std::string name_string(name, length);
  const char* extra_search_path = ".";
  std::string script_directory;
  if (IS_ABSOLUTE_PATH(name_string.c_str()))
    {
      if (closure->is_in_sysroot())
	{
	  const std::string& sysroot(parameters->options().sysroot());
	  gold_assert(!sysroot.empty());
	  name_string = sysroot + name_string;
	}
    }
  else
    {
      // In addition to checking the normal library search path, we
      // also want to check in the script-directory.
      const char* slash = strrchr(closure->filename(), '/');
      if (slash != NULL)
	{
	  script_directory.assign(closure->filename(),
				  slash - closure->filename() + 1);
	  extra_search_path = script_directory.c_str();
	}
    }

  Input_file_argument file(name_string.c_str(),
			   Input_file_argument::INPUT_FILE_TYPE_FILE,
			   extra_search_path, false,
			   closure->position_dependent_options());
  Input_argument& arg = closure->inputs()->add_file(file);
  arg.set_script_info(closure->script_info());
}

// Called by the bison parser to add a library to the link.

extern "C" void
script_add_library(void* closurev, const char* name, size_t length)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  std::string name_string(name, length);

  if (name_string[0] != 'l')
    gold_error(_("library name must be prefixed with -l"));
    
  Input_file_argument file(name_string.c_str() + 1,
			   Input_file_argument::INPUT_FILE_TYPE_LIBRARY,
			   "", false,
			   closure->position_dependent_options());
  Input_argument& arg = closure->inputs()->add_file(file);
  arg.set_script_info(closure->script_info());
}

// Called by the bison parser to start a group.  If we are already in
// a group, that means that this script was invoked within a
// --start-group --end-group sequence on the command line, or that
// this script was found in a GROUP of another script.  In that case,
// we simply continue the existing group, rather than starting a new
// one.  It is possible to construct a case in which this will do
// something other than what would happen if we did a recursive group,
// but it's hard to imagine why the different behaviour would be
// useful for a real program.  Avoiding recursive groups is simpler
// and more efficient.

extern "C" void
script_start_group(void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  if (!closure->in_group())
    closure->inputs()->start_group();
}

// Called by the bison parser at the end of a group.

extern "C" void
script_end_group(void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  if (!closure->in_group())
    closure->inputs()->end_group();
}

// Called by the bison parser to start an AS_NEEDED list.

extern "C" void
script_start_as_needed(void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->position_dependent_options().set_as_needed(true);
}

// Called by the bison parser at the end of an AS_NEEDED list.

extern "C" void
script_end_as_needed(void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->position_dependent_options().set_as_needed(false);
}

// Called by the bison parser to set the entry symbol.

extern "C" void
script_set_entry(void* closurev, const char* entry, size_t length)
{
  // We'll parse this exactly the same as --entry=ENTRY on the commandline
  // TODO(csilvers): FIXME -- call set_entry directly.
  std::string arg("--entry=");
  arg.append(entry, length);
  script_parse_option(closurev, arg.c_str(), arg.size());
}

// Called by the bison parser to set whether to define common symbols.

extern "C" void
script_set_common_allocation(void* closurev, int set)
{
  const char* arg = set != 0 ? "--define-common" : "--no-define-common";
  script_parse_option(closurev, arg, strlen(arg));
}

// Called by the bison parser to refer to a symbol.

extern "C" Expression*
script_symbol(void* closurev, const char* name, size_t length)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  if (length != 1 || name[0] != '.')
    closure->script_options()->add_symbol_reference(name, length);
  return script_exp_string(name, length);
}

// Called by the bison parser to define a symbol.

extern "C" void
script_set_symbol(void* closurev, const char* name, size_t length,
		  Expression* value, int providei, int hiddeni)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  const bool provide = providei != 0;
  const bool hidden = hiddeni != 0;
  closure->script_options()->add_symbol_assignment(name, length,
						   closure->parsing_defsym(),
						   value, provide, hidden);
  closure->clear_skip_on_incompatible_target();
}

// Called by the bison parser to add an assertion.

extern "C" void
script_add_assertion(void* closurev, Expression* check, const char* message,
		     size_t messagelen)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->script_options()->add_assertion(check, message, messagelen);
  closure->clear_skip_on_incompatible_target();
}

// Called by the bison parser to parse an OPTION.

extern "C" void
script_parse_option(void* closurev, const char* option, size_t length)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  // We treat the option as a single command-line option, even if
  // it has internal whitespace.
  if (closure->command_line() == NULL)
    {
      // There are some options that we could handle here--e.g.,
      // -lLIBRARY.  Should we bother?
      gold_warning(_("%s:%d:%d: ignoring command OPTION; OPTION is only valid"
		     " for scripts specified via -T/--script"),
		   closure->filename(), closure->lineno(), closure->charpos());
    }
  else
    {
      bool past_a_double_dash_option = false;
      const char* mutable_option = strndup(option, length);
      gold_assert(mutable_option != NULL);
      closure->command_line()->process_one_option(1, &mutable_option, 0,
                                                  &past_a_double_dash_option);
      // The General_options class will quite possibly store a pointer
      // into mutable_option, so we can't free it.  In cases the class
      // does not store such a pointer, this is a memory leak.  Alas. :(
    }
  closure->clear_skip_on_incompatible_target();
}

// Called by the bison parser to handle OUTPUT_FORMAT.  OUTPUT_FORMAT
// takes either one or three arguments.  In the three argument case,
// the format depends on the endianness option, which we don't
// currently support (FIXME).  If we see an OUTPUT_FORMAT for the
// wrong format, then we want to search for a new file.  Returning 0
// here will cause the parser to immediately abort.

extern "C" int
script_check_output_format(void* closurev,
			   const char* default_name, size_t default_length,
			   const char*, size_t, const char*, size_t)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  std::string name(default_name, default_length);
  Target* target = select_target_by_bfd_name(name.c_str());
  if (target == NULL || !parameters->is_compatible_target(target))
    {
      if (closure->skip_on_incompatible_target())
	{
	  closure->set_found_incompatible_target();
	  return 0;
	}
      // FIXME: Should we warn about the unknown target?
    }
  return 1;
}

// Called by the bison parser to handle TARGET.

extern "C" void
script_set_target(void* closurev, const char* target, size_t len)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  std::string s(target, len);
  General_options::Object_format format_enum;
  format_enum = General_options::string_to_object_format(s.c_str());
  closure->position_dependent_options().set_format_enum(format_enum);
}

// Called by the bison parser to handle SEARCH_DIR.  This is handled
// exactly like a -L option.

extern "C" void
script_add_search_dir(void* closurev, const char* option, size_t length)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  if (closure->command_line() == NULL)
    gold_warning(_("%s:%d:%d: ignoring SEARCH_DIR; SEARCH_DIR is only valid"
		   " for scripts specified via -T/--script"),
		 closure->filename(), closure->lineno(), closure->charpos());
  else if (!closure->command_line()->options().nostdlib())
    {
      std::string s = "-L" + std::string(option, length);
      script_parse_option(closurev, s.c_str(), s.size());
    }
}

/* Called by the bison parser to push the lexer into expression
   mode.  */

extern "C" void
script_push_lex_into_expression_mode(void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->push_lex_mode(Lex::EXPRESSION);
}

/* Called by the bison parser to push the lexer into version
   mode.  */

extern "C" void
script_push_lex_into_version_mode(void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  if (closure->version_script()->is_finalized())
    gold_error(_("%s:%d:%d: invalid use of VERSION in input file"),
	       closure->filename(), closure->lineno(), closure->charpos());
  closure->push_lex_mode(Lex::VERSION_SCRIPT);
}

/* Called by the bison parser to pop the lexer mode.  */

extern "C" void
script_pop_lex_mode(void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->pop_lex_mode();
}

// Register an entire version node. For example:
//
// GLIBC_2.1 {
//   global: foo;
// } GLIBC_2.0;
//
// - tag is "GLIBC_2.1"
// - tree contains the information "global: foo"
// - deps contains "GLIBC_2.0"

extern "C" void
script_register_vers_node(void*,
			  const char* tag,
			  int taglen,
			  struct Version_tree* tree,
			  struct Version_dependency_list* deps)
{
  gold_assert(tree != NULL);
  tree->dependencies = deps;
  if (tag != NULL)
    tree->tag = std::string(tag, taglen);
}

// Add a dependencies to the list of existing dependencies, if any,
// and return the expanded list.

extern "C" struct Version_dependency_list*
script_add_vers_depend(void* closurev,
		       struct Version_dependency_list* all_deps,
		       const char* depend_to_add, int deplen)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  if (all_deps == NULL)
    all_deps = closure->version_script()->allocate_dependency_list();
  all_deps->dependencies.push_back(std::string(depend_to_add, deplen));
  return all_deps;
}

// Add a pattern expression to an existing list of expressions, if any.

extern "C" struct Version_expression_list*
script_new_vers_pattern(void* closurev,
			struct Version_expression_list* expressions,
			const char* pattern, int patlen, int exact_match)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  if (expressions == NULL)
    expressions = closure->version_script()->allocate_expression_list();
  expressions->expressions.push_back(
      Version_expression(std::string(pattern, patlen),
                         closure->get_current_language(),
                         static_cast<bool>(exact_match)));
  return expressions;
}

// Attaches b to the end of a, and clears b.  So a = a + b and b = {}.

extern "C" struct Version_expression_list*
script_merge_expressions(struct Version_expression_list* a,
                         struct Version_expression_list* b)
{
  a->expressions.insert(a->expressions.end(),
                        b->expressions.begin(), b->expressions.end());
  // We could delete b and remove it from expressions_lists_, but
  // that's a lot of work.  This works just as well.
  b->expressions.clear();
  return a;
}

// Combine the global and local expressions into a a Version_tree.

extern "C" struct Version_tree*
script_new_vers_node(void* closurev,
		     struct Version_expression_list* global,
		     struct Version_expression_list* local)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  Version_tree* tree = closure->version_script()->allocate_version_tree();
  tree->global = global;
  tree->local = local;
  return tree;
}

// Handle a transition in language, such as at the
// start or end of 'extern "C++"'

extern "C" void
version_script_push_lang(void* closurev, const char* lang, int langlen)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  std::string language(lang, langlen);
  Version_script_info::Language code;
  if (language.empty() || language == "C")
    code = Version_script_info::LANGUAGE_C;
  else if (language == "C++")
    code = Version_script_info::LANGUAGE_CXX;
  else if (language == "Java")
    code = Version_script_info::LANGUAGE_JAVA;
  else
    {
      char* buf = new char[langlen + 100];
      snprintf(buf, langlen + 100,
	       _("unrecognized version script language '%s'"),
	       language.c_str());
      yyerror(closurev, buf);
      delete[] buf;
      code = Version_script_info::LANGUAGE_C;
    }
  closure->push_language(code);
}

extern "C" void
version_script_pop_lang(void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->pop_language();
}

// Called by the bison parser to start a SECTIONS clause.

extern "C" void
script_start_sections(void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->script_options()->script_sections()->start_sections();
  closure->clear_skip_on_incompatible_target();
}

// Called by the bison parser to finish a SECTIONS clause.

extern "C" void
script_finish_sections(void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->script_options()->script_sections()->finish_sections();
}

// Start processing entries for an output section.

extern "C" void
script_start_output_section(void* closurev, const char* name, size_t namelen,
			    const struct Parser_output_section_header* header)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->script_options()->script_sections()->start_output_section(name,
								     namelen,
								     header);
}

// Finish processing entries for an output section.

extern "C" void
script_finish_output_section(void* closurev,
			     const struct Parser_output_section_trailer* trail)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->script_options()->script_sections()->finish_output_section(trail);
}

// Add a data item (e.g., "WORD (0)") to the current output section.

extern "C" void
script_add_data(void* closurev, int data_token, Expression* val)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  int size;
  bool is_signed = true;
  switch (data_token)
    {
    case QUAD:
      size = 8;
      is_signed = false;
      break;
    case SQUAD:
      size = 8;
      break;
    case LONG:
      size = 4;
      break;
    case SHORT:
      size = 2;
      break;
    case BYTE:
      size = 1;
      break;
    default:
      gold_unreachable();
    }
  closure->script_options()->script_sections()->add_data(size, is_signed, val);
}

// Add a clause setting the fill value to the current output section.

extern "C" void
script_add_fill(void* closurev, Expression* val)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->script_options()->script_sections()->add_fill(val);
}

// Add a new input section specification to the current output
// section.

extern "C" void
script_add_input_section(void* closurev,
			 const struct Input_section_spec* spec,
			 int keepi)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  bool keep = keepi != 0;
  closure->script_options()->script_sections()->add_input_section(spec, keep);
}

// When we see DATA_SEGMENT_ALIGN we record that following output
// sections may be relro.

extern "C" void
script_data_segment_align(void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  if (!closure->script_options()->saw_sections_clause())
    gold_error(_("%s:%d:%d: DATA_SEGMENT_ALIGN not in SECTIONS clause"),
	       closure->filename(), closure->lineno(), closure->charpos());
  else
    closure->script_options()->script_sections()->data_segment_align();
}

// When we see DATA_SEGMENT_RELRO_END we know that all output sections
// since DATA_SEGMENT_ALIGN should be relro.

extern "C" void
script_data_segment_relro_end(void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  if (!closure->script_options()->saw_sections_clause())
    gold_error(_("%s:%d:%d: DATA_SEGMENT_ALIGN not in SECTIONS clause"),
	       closure->filename(), closure->lineno(), closure->charpos());
  else
    closure->script_options()->script_sections()->data_segment_relro_end();
}

// Create a new list of string/sort pairs.

extern "C" String_sort_list_ptr
script_new_string_sort_list(const struct Wildcard_section* string_sort)
{
  return new String_sort_list(1, *string_sort);
}

// Add an entry to a list of string/sort pairs.  The way the parser
// works permits us to simply modify the first parameter, rather than
// copy the vector.

extern "C" String_sort_list_ptr
script_string_sort_list_add(String_sort_list_ptr pv,
			    const struct Wildcard_section* string_sort)
{
  if (pv == NULL)
    return script_new_string_sort_list(string_sort);
  else
    {
      pv->push_back(*string_sort);
      return pv;
    }
}

// Create a new list of strings.

extern "C" String_list_ptr
script_new_string_list(const char* str, size_t len)
{
  return new String_list(1, std::string(str, len));
}

// Add an element to a list of strings.  The way the parser works
// permits us to simply modify the first parameter, rather than copy
// the vector.

extern "C" String_list_ptr
script_string_list_push_back(String_list_ptr pv, const char* str, size_t len)
{
  if (pv == NULL)
    return script_new_string_list(str, len);
  else
    {
      pv->push_back(std::string(str, len));
      return pv;
    }
}

// Concatenate two string lists.  Either or both may be NULL.  The way
// the parser works permits us to modify the parameters, rather than
// copy the vector.

extern "C" String_list_ptr
script_string_list_append(String_list_ptr pv1, String_list_ptr pv2)
{
  if (pv1 == NULL)
    return pv2;
  if (pv2 == NULL)
    return pv1;
  pv1->insert(pv1->end(), pv2->begin(), pv2->end());
  return pv1;
}

// Add a new program header.

extern "C" void
script_add_phdr(void* closurev, const char* name, size_t namelen,
		unsigned int type, const Phdr_info* info)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  bool includes_filehdr = info->includes_filehdr != 0;
  bool includes_phdrs = info->includes_phdrs != 0;
  bool is_flags_valid = info->is_flags_valid != 0;
  Script_sections* ss = closure->script_options()->script_sections();
  ss->add_phdr(name, namelen, type, includes_filehdr, includes_phdrs,
	       is_flags_valid, info->flags, info->load_address);
  closure->clear_skip_on_incompatible_target();
}

// Convert a program header string to a type.

#define PHDR_TYPE(NAME) { #NAME, sizeof(#NAME) - 1, elfcpp::NAME }

static struct
{
  const char* name;
  size_t namelen;
  unsigned int val;
} phdr_type_names[] =
{
  PHDR_TYPE(PT_NULL),
  PHDR_TYPE(PT_LOAD),
  PHDR_TYPE(PT_DYNAMIC),
  PHDR_TYPE(PT_INTERP),
  PHDR_TYPE(PT_NOTE),
  PHDR_TYPE(PT_SHLIB),
  PHDR_TYPE(PT_PHDR),
  PHDR_TYPE(PT_TLS),
  PHDR_TYPE(PT_GNU_EH_FRAME),
  PHDR_TYPE(PT_GNU_STACK),
  PHDR_TYPE(PT_GNU_RELRO)
};

extern "C" unsigned int
script_phdr_string_to_type(void* closurev, const char* name, size_t namelen)
{
  for (unsigned int i = 0;
       i < sizeof(phdr_type_names) / sizeof(phdr_type_names[0]);
       ++i)
    if (namelen == phdr_type_names[i].namelen
	&& strncmp(name, phdr_type_names[i].name, namelen) == 0)
      return phdr_type_names[i].val;
  yyerror(closurev, _("unknown PHDR type (try integer)"));
  return elfcpp::PT_NULL;
}

extern "C" void
script_saw_segment_start_expression(void* closurev)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  Script_sections* ss = closure->script_options()->script_sections();
  ss->set_saw_segment_start_expression(true);
}

extern "C" void
script_set_section_region(void* closurev, const char* name, size_t namelen,
			  int set_vma)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  if (!closure->script_options()->saw_sections_clause())
    {
      gold_error(_("%s:%d:%d: MEMORY region '%.*s' referred to outside of "
		   "SECTIONS clause"),
		 closure->filename(), closure->lineno(), closure->charpos(),
		 static_cast<int>(namelen), name);
      return;
    }

  Script_sections* ss = closure->script_options()->script_sections();
  Memory_region* mr = ss->find_memory_region(name, namelen);
  if (mr == NULL)
    {
      gold_error(_("%s:%d:%d: MEMORY region '%.*s' not declared"),
		 closure->filename(), closure->lineno(), closure->charpos(),
		 static_cast<int>(namelen), name);
      return;
    }

  ss->set_memory_region(mr, set_vma);
}

extern "C" void
script_add_memory(void* closurev, const char* name, size_t namelen,
		  unsigned int attrs, Expression* origin, Expression* length)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  Script_sections* ss = closure->script_options()->script_sections();
  ss->add_memory_region(name, namelen, attrs, origin, length);
}

extern "C" unsigned int
script_parse_memory_attr(void* closurev, const char* attrs, size_t attrlen,
			 int invert)
{
  int attributes = 0;

  while (attrlen--)
    switch (*attrs++)
      {
      case 'R':
      case 'r':
	attributes |= MEM_READABLE; break;
      case 'W':
      case 'w':
	attributes |= MEM_READABLE | MEM_WRITEABLE; break;
      case 'X':
      case 'x':
	attributes |= MEM_EXECUTABLE; break;
      case 'A':
      case 'a':
	attributes |= MEM_ALLOCATABLE; break;
      case 'I':
      case 'i':
      case 'L':
      case 'l':
	attributes |= MEM_INITIALIZED; break;
      default:
	yyerror(closurev, _("unknown MEMORY attribute"));
      }

  if (invert)
    attributes = (~ attributes) & MEM_ATTR_MASK;

  return attributes;
}

extern "C" void
script_include_directive(void* closurev, const char* filename, size_t length)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  std::string name(filename, length);
  Command_line* cmdline = closure->command_line();
  read_script_file(name.c_str(), cmdline, &cmdline->script_options(),
                   PARSING_LINKER_SCRIPT, Lex::LINKER_SCRIPT);
}

// Functions for memory regions.

extern "C" Expression*
script_exp_function_origin(void* closurev, const char* name, size_t namelen)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  Script_sections* ss = closure->script_options()->script_sections();
  Expression* origin = ss->find_memory_region_origin(name, namelen);

  if (origin == NULL)
    {
      gold_error(_("undefined memory region '%s' referenced "
		   "in ORIGIN expression"),
		 name);
      // Create a dummy expression to prevent crashes later on.
      origin = script_exp_integer(0);
    }

  return origin;
}

extern "C" Expression*
script_exp_function_length(void* closurev, const char* name, size_t namelen)
{
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  Script_sections* ss = closure->script_options()->script_sections();
  Expression* length = ss->find_memory_region_length(name, namelen);

  if (length == NULL)
    {
      gold_error(_("undefined memory region '%s' referenced "
		   "in LENGTH expression"),
		 name);
      // Create a dummy expression to prevent crashes later on.
      length = script_exp_integer(0);
    }

  return length;
}
@


1.85
log
@	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.
@
text
@d1538 3
a1540 3
// Helper function for read_version_script() and
// read_commandline_script().  Processes the given file in the mode
// indicated by first_token and lex_mode.
a1546 2
  // TODO: if filename is a relative filename, search for it manually
  // using "." + cmdline->options()->search_path() -- not dirsearch.
d1548 10
d1568 1
a1568 1
  Input_file_argument input_argument(filename,
d3362 1
a3362 1
script_include_directive(void* closurev, const char*, size_t)
d3364 5
a3368 2
  // FIXME: Implement ?
  yyerror (closurev, _("GOLD does not currently support INCLUDE directives"));
@


1.84
log
@	* script.cc (Token::integer_value): Accept trailing M/m/K/k
	modifier.
	(Lex::gather_token): Accept trailing M/m/K/k for integers.
@
text
@d986 1
a986 1
						  &section, NULL);
d993 2
a994 1
// Set the symbol value if the expression yields an absolute value.
d998 2
a999 1
				   bool is_dot_available, uint64_t dot_value)
d1007 3
a1009 2
					    NULL, &val_section, NULL);
  if (val_section != NULL)
d1032 2
d1223 1
a1223 1
    (*p)->set_if_absolute(symtab, layout, false, 0);
@


1.84.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d986 1
a986 1
						  &section, NULL, false);
d993 1
a993 2
// Set the symbol value if the expression yields an absolute value or
// a value relative to DOT_SECTION.
d997 1
a997 2
				   bool is_dot_available, uint64_t dot_value,
				   Output_section* dot_section)
d1005 2
a1006 3
					    dot_section, &val_section, NULL,
					    false);
  if (val_section != NULL && val_section != dot_section)
a1028 2
  if (val_section != NULL)
    this->sym_->set_output_section(val_section);
d1218 1
a1218 1
    (*p)->set_if_absolute(symtab, layout, false, 0, NULL);
@


1.83
log
@	PR gold/12934
	* target-select.cc (Target_selector::Target_selector): Add
	emulation parameter.  Change all callers.
	(select_target_by_bfd_name): Rename from select_target_by_name.
	Change all callers.
	(select_target_by_emulation): New function.
	(supported_emulation_names): New function.
	* target-select.h (class Target_selector): Add emulation_ field.
	Update declarations.
	(Target_selector::recognize_by_bfd_name): Rename from
	recognize_by_name.  Change all callers.
	(Target_selector::supported_bfd_names): Rename from
	supported_names.  Change all callers.
	(Target_selector::recognize_by_emulation): New function.
	(Target_selector::supported_emulations): New function.
	(Target_selector::emulation): New function.
	(Target_selector::do_recognize_by_bfd_name): Rename from
	do_recognize_by_name.  Change all callers.
	(Target_selector::do_supported_bfd_names): Rename from
	do_supported_names.  Change all callers.
	(Target_selector::do_recognize_by_emulation): New function.
	(Target_selector::do_supported_emulations): New function.
	(select_target_by_bfd_name): Change name in declaration.
	(select_target_by_emulation): Declare.
	(supported_emulation_names): Declare.
	* parameters.cc (parameters_force_valid_target): Try to find
	target based on emulation from -m option.
	* options.h (class General_options): Change doc string for -m.
	* options.cc (help): Print emulations.
	(General_options::parse_V): Likewise.
	* freebsd.h (Target_selector_freebsd::Target_selector_freebsd):
	Add emulation parameter.  Change all callers.
@
text
@d149 1
a149 7
  integer_value() const
  {
    gold_assert(this->classification_ == TOKEN_INTEGER);
    // Null terminate.
    std::string s(this->value_, this->value_length_);
    return strtoull(s.c_str(), NULL, 0);
  }
d168 29
d500 1
a500 3
// accept them.  The old linker also accepts trailing MK for mega or
// kilo.  FIXME: Those are mentioned in the documentation, and we
// should accept them.
d727 1
a727 1
  while ((new_match = (this->*can_continue_fn)(match)))
d729 7
@


1.82
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d2807 1
a2807 1
  Target* target = select_target_by_name(name.c_str());
@


1.81
log
@	* archive.cc (Archive::include_member): Adjust call to report_object.
	(Add_archive_symbols::run): Add script_info to call to
	report_archive_begin.
	(Lib_group::include_member): Adjust call to report_object.
	(Add_lib_group_symbols::run): Adjust call to report_object.
	* incremental-dump.cc (dump_incremental_inputs): Remove unnecessary
	blocks.  Add object count for script input files.
	* incremental.cc (Incremental_inputs::report_archive_begin): Add
	script_info parameter; change all callers.
	(Incremental_inputs::report_object): Add script_info parameter;
	change all callers.
	(Incremental_inputs::report_script): Store backpointer to
	incremental info entry.
	(Output_section_incremental_inputs::set_final_data_size): Record
	additional information for scripts.
	(Output_section_incremental_inputs::write_info_blocks): Likewise.
	* incremental.h (Incremental_script_entry::add_object): New function.
	(Incremental_script_entry::get_object_count): New function.
	(Incremental_script_entry::get_object): New function.
	(Incremental_script_entry::objects_): New data member; adjust
	constructor.
	(Incremental_inputs::report_archive_begin): Add script_info parameter.
	(Incremental_inputs::report_object): Add script_info parameter.
	(Incremental_inputs_reader::get_object_count): New function.
	(Incremental_inputs_reader::get_object_offset): New function.
	* options.cc (Input_arguments::add_file): Return reference to
	new input argument.
	* options.h (Input_argument::set_script_info): New function.
	(Input_argument::script_info): New function.
	(Input_argument::script_info_): New data member; adjust all
	constructors.
	(Input_file_group::add_file): Return reference to new input argument.
	(Input_file_lib::add_file): Likewise.
	(Input_arguments::add_file): Likewise.
	* readsyms.cc (Add_symbols::run): Adjust call to report_object.
	* script.cc (Parser_closure::Parser_closure): Add script_info
	parameter; adjust all callers.
	(Parser_closure::script_info): New function.
	(Parser_closure::script_info_): New data member.
	(read_input_script): Report scripts earlier to incremental info.
	(script_add_file): Set script_info in Input_argument.
	(script_add_library): Likewise.
	* script.h (Script_options::Script_info): Rewrite class.
@
text
@d1439 4
a1442 2
      script_info = new Script_info();
      layout->incremental_inputs()->report_script(filename, script_info, mtime);
@


1.80
log
@	* script.cc (script_add_extern): Rewrite to use
	add_symbol_reference.
@
text
@d1209 2
a1210 1
		 bool skip_on_incompatible_target)
d1218 2
a1219 1
      lex_(lex), lineno_(0), charpos_(0), lex_mode_stack_(), inputs_(NULL)
d1370 5
d1411 2
d1434 9
d1451 2
a1452 1
			 input_file->will_search_for());
a1497 10
  if (layout->incremental_inputs() != NULL)
    {
      // Like new Read_symbols(...) above, we rely on closure.inputs()
      // getting leaked by closure.
      const std::string& filename = input_file->filename();
      Script_info* info = new Script_info(closure.inputs());
      Timespec mtime = input_file->file().get_mtime();
      layout->incremental_inputs()->report_script(filename, info, mtime);
    }

d1547 2
a1548 1
			 false);
d1607 1
a1607 1
			 false, false, NULL, this, &lex, false);
d2633 2
a2634 1
  closure->inputs()->add_file(file);
d2652 2
a2653 1
  closure->inputs()->add_file(file);
@


1.79
log
@        PR ld/12001
        * ldlang.c (ldlang_def_chain_list): New variable.  Contains a list
        of symbols defined via the --defsym command line option and
        currently waiting assignment.
        (insert_defined): Add a defined symbol to the symbol table.
        (ldlang_add_def): Add a entry to the ldlang_def_chain_list.
        (lang_place_defineds): Walk ldlang_def_chain_list defining the
        symbols.
        (lang_process): Call lang_place_defineds.
        (lang_add_assignment): If the assignment has come from a --defsym
        command line option then call lang_add_def.

        * ld-script/default-script2.d: Fix expected address for text
        section.

        PR gold/12001
        * script.h (class Symbol_assignment: name): New member.  Returns
        the name of the symbol.
        * scrfipt.cc (Script_options::is_pending_assignment): New member.
        Returns true if the given symbol name is on the list of
        assignments wating to be processed.
        * archive.cc (should_incldue_member): If the symbol is undefined,
        check to see if it is on the list of symbols pending assignment.
@
text
@d2579 2
a2580 6
  // We treat exactly like -u NAME.  FIXME: If it seems useful, we
  // could handle this after the command line has been read, by adding
  // entries to the symbol table directly.
  std::string arg("--undefined=");
  arg.append(name, length);
  script_parse_option(closurev, arg.c_str(), arg.size());
@


1.79.2.1
log
@	Backport from mainline:
	2011-01-25  Ian Lance Taylor  <iant@@google.com>
	* script.cc (script_add_extern): Rewrite to use
	add_symbol_reference.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d2579 6
a2584 2
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->script_options()->add_symbol_reference(name, length);
@


1.78
log
@2010-09-08  Rafael Espindola  <espindola@@google.com>

	* script-sections.cc (Script_sections::add_memory_region): Convert
	field precision to int.
	* script.cc (script_set_section_region, script_set_section_region):
	Convert field precision to int.
@
text
@d1053 14
@


1.77
log
@        * README: Remove claim that MEMORY is not supported.
        * expression.cc (script_exp_function_origin)
        (script_exp_function_length): Move from here to ...
        * script.cc: ... here.
        (script_set_section_region, script_add_memory)
        (script_parse_memory_attr, script_include_directive): New
        functions.
        * script-sections.cc
        (class Memory_region): New class.
        (class Output_section_definition): Add set_memory_region,
        set_section_vma, set_section_lma and get_section_name methods.
        (class Script_Sections): Add add_memory_region,
        find_memory_region, find_memory_region_origin,
        find_memory_region_length and set_memory_region methods.
        Have set_section_addresses method walk the list of set memory
        regions.
        Extend the print methos to display memory regions.
        * script-sections.h: Add prototypes for new methods.
        Add enum for MEMORY region attributes.
        * yyscript.y: Add support for parsing MEMORY regions.
        * script-c.h: Add prototypes for new functions.
        * testsuite/Makefile.am: Add test of MEMORY region functionality.
        * testsuite/Makefile.in: Regenerate.
        * testsuite/memory_test.sh: New script.
        * testsuite/memory_test.s: New assembler source file.
        * testsuite/memory_test.t: New linker script.
@
text
@d3234 1
a3234 1
		 namelen, name);
d3244 1
a3244 1
		 namelen, name);
@


1.76
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d3223 119
@


1.75
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_SYMTAB,
	SHT_GNU_INCREMENTAL_RELOCS.

gold/ChangeLog:

	* archive.cc: Include incremental.h.
	(Archive::Archive): Initialize incremental_info_.
	(Archive::include_member): Record archive members in incremental info.
	(Add_archive_symbols::run): Record begin and end of an archive in
	incremental info.
	(Lib_group::include_member): Record objects in incremental info.
	* archive.h (Incremental_archive_entry): Forward declaration.
	(Archive::set_incremental_info): New member function.
	(Archive::incremental_info): New member function.
	(Archive::Unused_symbol_iterator): New class.
	(Archive::unused_symbols_begin): New member function.
	(Archive::unused_symbols_end): New member function.
	(Archive::incremental_info_): New data member.
	* incremental-dump.cc (find_input_containing_global): New function.
	(dump_incremental_inputs): Dump new incremental info sections.
	* incremental.cc: Include symtab.h.
	(Output_section_incremental_inputs): New class.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Support
	new incremental info sections.
	(Sized_incremental_binary::do_check_inputs): Likewise.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): New function.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Rewrite.
	(Incremental_inputs::finalize): Do nothing but finalize string table.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Output_section_incremental_inputs::set_final_data_size): New function.
	(Output_section_incremental_inputs::do_write): New function.
	(Output_section_incremental_inputs::write_header): New function.
	(Output_section_incremental_inputs::write_input_files): New function.
	(Output_section_incremental_inputs::write_info_blocks): New function.
	(Output_section_incremental_inputs::write_symtab): New function.
	* incremental.h (Incremental_script_entry): Forward declaration.
	(Incremental_object_entry): Forward declaration.
	(Incremental_archive_entry): Forward declaration.
	(Incremental_inputs): Forward declaration.
	(Incremental_inputs_header_data): Remove.
	(Incremental_inputs_header): Remove.
	(Incremental_inputs_header_write): Remove.
	(Incremental_inputs_entry_data): Remove.
	(Incremental_inputs_entry): Remove.
	(Incremental_inputs_entry_write): Remove.
	(enum Incremental_input_type): Add INCREMENTAL_INPUT_ARCHIVE_MEMBER.
	(Incremental_binary::find_incremental_inputs_sections): Add parameters.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Sized_ncremental_binary::do_find_incremental_inputs_sections):
	Likewise.
	(Incremental_input_entry): New class.
	(Incremental_script_entry): New class.
	(Incremental_object_entry): New class.
	(Incremental_archive_entry): New class.
	(Incremental_inputs::Incremental_inputs): Initialize new data members.
	(Incremental_inputs::report_inputs): Remove.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): Change prototype.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Change prototype.
	(Incremental_inputs::get_reloc_count): New function.
	(Incremental_inputs::set_reloc_count): New function.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::inputs_section): New function.
	(Incremental_inputs::symtab_section): New function.
	(Incremental_inputs::relocs_section): New function.
	(Incremental_inputs::get_stringpool): Add const.
	(Incremental_inputs::command_line): Add const.
	(Incremental_inputs::inputs): Remove.
	(Incremental_inputs::command_line_key): New function.
	(Incremental_inputs::input_file_count): New function.
	(Incremental_inputs::input_files): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::Input_info): Remove.
	(Incremental_inputs::lock_): Remove.
	(Incremental_inputs::inputs_): Change type.
	(Incremental_inputs::inputs_map_): Remove.
	(Incremental_inputs::current_object_entry_): New data member.
	(Incremental_inputs::inputs_section_): New data member.
	(Incremental_inputs::symtab_section_): New data member.
	(Incremental_inputs::relocs_section_): New data member.
	(Incremental_inputs::reloc_count_): New data member.
	(Incremental_inputs_reader): New class.
	(Incremental_symtab_reader): New class.
	(Incremental_relocs_reader): New class.
	* layout.cc (Layout::finalize): Move finalization of incremental info
	and creation of incremental info sections to follow finalization of
	symbol table.  Set offsets for postprocessing sections.
	(Layout::create_incremental_info_sections): Call
	Incremental_inputs::create_data_sections.  Add incremental symtab
	and relocs sections.  Set sh_entsize and sh_link fields.  Arrange for
	sections to layout after input sections.
	* layout.h (struct Timespec): Forward declaration.
	(Layout::incremental_inputs): Add const.
	(Layout::create_incremental_info_sections): Add parameter.
	* main.cc (main): Remove call to Incremental_inputs::report_inputs.
	* object.cc: Include incremental.h.
	(Relobj::finalize_incremental_relocs): New function.
	(Sized_relobj::do_layout): Record input sections in incremental info.
	* object.h (Object::output_section): New function.
	(Object::output_section_offset): Moved from Relobj.
	(Object::get_incremental_reloc_base): New function.
	(Object::get_incremental_reloc_count): New function.
	(Object::do_output_section): New function.
	(Object::do_output_section_offset): Moved from Relobj.
	(Object::do_get_incremental_reloc_base): New function.
	(Object::do_get_incremental_reloc_count): New function.
	(Object::Object): Initialize new data members.
	(Relobj::output_section): Renamed do_output_section and moved to
	protected.
	(Relobj::output_section_offset): Moved to Object.
	(Relobj::do_get_incremental_reloc_base): New function.
	(Relobj::do_get_incremental_reloc_count): New function.
	(Relobj::allocate_incremental_reloc_counts): New function.
	(Relobj::count_incremental_reloc): New function.
	(Relobj::finalize_incremental_relocs): New function.
	(Relobj::next_incremental_reloc_index): New function.
	(Relobj::reloc_counts_): New data member.
	(Relobj::reloc_bases_): New data member.
	(Sized_relobj::do_relocate_sections): Add parameter.  Change caller.
	(Sized_relobj::relocate_sections): Add parameter.  Change all callers.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* plugin.cc (Plugin_manager::add_input_file): Rewrite test for
	incremental link.
	* readsyms.cc (Read_symbols::do_read_symbols): Move reporting of
	archives and object files elsewhere.
	(Add_symbols::run): Report object files here.
	(Finish_group::run): Report end of archive at end of group.
	* reloc.cc: Include layout.h, incremental.h.
	(Sized_relobj::do_read_relocs): Need relocations for incremental link.
	(Sized_relobj::do_scan_relocs): Record relocations for incremental link.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::do_relocate_sections): Write incremental relocations.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* script.cc (read_input_script): Rewrite test for incremental link.
	Change call to Incremental_inputs::report_script.
	* symtab.h (Symbol_table::first_global_index): New function.
	(Symbol_table::output_count): New function.
@
text
@d703 1
a703 1
		  const char **pp)
d1886 1
a1886 1
  const char *symbol_;
d1891 1
a1891 1
  char *demangled_;
d2121 1
a2121 1
				     Exact *pe)
d2600 1
a2600 1
      const char *slash = strrchr(closure->filename(), '/');
d2705 1
a2705 1
script_symbol(void *closurev, const char* name, size_t length)
d2872 2
a2873 2
			  struct Version_tree *tree,
			  struct Version_dependency_list *deps)
d2884 1
a2884 1
extern "C" struct Version_dependency_list *
d2886 2
a2887 2
		       struct Version_dependency_list *all_deps,
		       const char *depend_to_add, int deplen)
d2898 1
a2898 1
extern "C" struct Version_expression_list *
d2900 2
a2901 2
			struct Version_expression_list *expressions,
			const char *pattern, int patlen, int exact_match)
d2916 2
a2917 2
script_merge_expressions(struct Version_expression_list *a,
                         struct Version_expression_list *b)
d2929 1
a2929 1
extern "C" struct Version_tree *
d2931 2
a2932 2
		     struct Version_expression_list *global,
		     struct Version_expression_list *local)
@


1.74
log
@	PR 11855
	* script.cc (Script_options::Script_options): Initialize
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_assignment): Update
	symbol_definitions_ and symbol_references_.
	(Script_options::add_symbol_reference): New function.
	(script_symbol): New function.
	* script.h (class Script_options): Add symbol_definitions_ and
	symbol_references_ fields.
	(Script_options::referenced_const_iterator): New type.
	(Script_options::referenced_begin): New function.
	(Script_options::referenced_end): New function.
	(Script_options::is_referenced): New function.
	(Script_options::any_unreferenced): New function.
	* script-c.h (script_symbol): Declare.
	* yyscript.y (exp): Call script_symbol.
	* symtab.cc: Include "script.h".
	(Symbol_table::gc_mark_undef_symbols): Add layout parameter.
	Change all callers.  Check symbols referenced by scripts.
	(Symbol_table::add_undefined_symbols_from_command_line): Add
	layout parameter.  Change all callers.
	(Symbol_table::do_add_undefined_symbols_from_command_line):
	Likewise.  Break out loop body.  Check symbols referenced by
	scripts.
	(Symbol_table::add_undefined_symbol_from_command_line): New
	function broken out of
	do_add_undefined_symbols_from_command_line.
	* symtab.h (class Symbol_table): Update declarations.
	* archive.cc: Include "layout.h".
	(Archive::should_include_member): Add layout parameter.  Change
	all callers.  Check for symbol mentioned in expression.
	* archive.h (class Archive): Update declaration.
	* object.cc (Sized_relobj::do_should_include_member): Add layout
	parameter.
	* object.h (Object::should_include_member): Add layout parameter.
	Change all callers.
	(Object::do_should_include_member): Add layout parameter.
	(class Sized_relobj): Update declaration.
	* dynobj.cc (Sized_dynobj::do_should_include_member): Add layout
	parameter.
	* dynobj.h (class Sized_dynobj): Update declaration.
	* plugin.cc (Sized_pluginobj::do_should_include_member): Add
	layout parameter.
	* plugin.h (class Sized_pluginobj): Update declaration.
@
text
@d1465 1
a1465 1
  if (layout->incremental_inputs())
d1467 1
a1467 1
      // Like new Read_symbols(...) above, we rely on close.inputs()
d1469 1
d1471 2
a1472 4
      layout->incremental_inputs()->report_script(
          input_argument,
          input_file->file().get_mtime(),
          info);
d1474 1
@


1.73
log
@        * yyscript.y (input_list_element): Allow strings prefixed with
        the '-' character.  Treat these as libraries.
        * script.cc (script_add_library): New function.  Adds a library
        specified by "-l<name>" found in an input script.
        * script-c.h: Add prototype for script_add_library.
@
text
@d1048 2
a1049 2
  : entry_(), symbol_assignments_(), version_script_info_(),
    script_sections_()
d1074 7
d1094 13
d2702 11
@


1.72
log
@2010-05-18  Rafael Espindola  <espindola@@google.com>

	* options.cc (General_options::finalize): Handle -nostdlib.
	* options.h (nostdlib): New option.
	* script.cc (script_add_search_dir): Handle -nostdlib.
@
text
@d2596 18
@


1.71
log
@	* expression.cc (Expression::Expression_eval_info): Add
	result_alignment_pointer field.
	(Expression::eval_with_dot): Add result_alignment_pointer
	parameter.  Change all callers.
	(Expression::eval_maybe_dot): Likewise.
	(class Binary_expression): Add alignment_pointer parameter to
	left_value and right_value.  Change all callers.
	(BINARY_EXPRESSION): Set result alignment.
	(class Trinary_expression): Add alignment_pointer parameter to
	arg2_value and arg3_value.  Change all callers.
	(Trinary_cond::value): Set result alignment.
	(Max_expression::value, Min_expression::value): Likewise.
	(Align_expression::value): Likewise.
	* script-sections.cc (class Sections_element): Add dot_alignment
	parameter to set_section_addresses virtual function.  Update
	instantiations.
	(class Output_section_element): Likewise.
	(Script_sections::create_segments): Add dot_alignment parameter.
	Change all callers.
	(Script_sections::create_segments_from_phdrs_clause): Likewise.
	(Script_sections::set_phdrs_clause_addresses): Likewise.
	* script-sections.h: Update declarations.
	* script.h: Update declarations.
	* output.h (Output_segment::set_minimum_p_align): Don't decrease
	min_p_align.
	* testsuite/script_test_3.t: Set large alignment.
	* testsuite/script_test_3.sh: Make sure that at least one LOAD
	segment has expected alignment.
@
text
@d2770 1
a2770 1
  else
@


1.70
log
@2010-04-09  Doug Kwan  <dougkwan@@google.com>

	* layout.cc (Layout::choose_output_section): Handle script section
	types.
	(Layout::make_output_section_for_script): Add section type parameter.
	Handle script section types.
	* layout.h (Layout::make_output_section_for_script): Add section
	type parameter.
	* output.cc (Output_section::Output_section): Initialize data member
	is_noload_.
	(Output_section::do_reset_address_and_file_offset): Do not set address
	to 0 if section is a NOLOAD section.
	* output.h (Output_section::is_noload): New method.
	(Output_section::set_is_noload): Ditto.
	(Output_section::is_noload_): New data member.
	* script-c.h (Script_section_type): New enum type.
	(struct Parser_output_section_header): Add new file section_type.
	* script-sections.cc (Sections_element::output_section_name): Add
	parameter for returning script section type.
	(Output_section_definition::output_section_name): Ditto.
	(Output_section_definition::section_type)P; New method.
	(Output_section_definiton::script_section_type_name): Ditto.
	(Output_section_definition::script_section_type_): New data member.
	(Output_section_definition::Output_section_definition): Initialize
	data member Output_section_definition::script_section_type_.
	(Output_section_definition::create_sections): Pass script section type
	to Layout::make_output_section_for_script.
	(Output_section_definition::output_section_name): Return script
	section type to caller.
	(Output_section_definition::set_section_address): Do not advance
	dot value and load address if section type is NOLOAD.  Set address
	of NOLOAD sections regardless of section flags.
	(Output_section_definition::print): Print section type if it is
	not SCRIPT_SECTION_TYPE_NONE.
	(Output_section_definition::section_type): New method.
	(Output_section_definition::script_section_type_name): Ditto.
	(Script_sections::output_section_name): Add new parameter
	PSECTION_TYPE for returning script section type.  Pass it to
	section elements.  Handle discard sections.
	(Sort_output_sections::operator()): Handle NOLOAD sections.
	* script-sections.h (Script_sections::Section_type): New enum type.
   	(Script_sections::output_section_name): Add a new parameter for
	returning script section type.
	* script.cc (script_keyword_parsecodes): Add keywords COPY, DSECT,
	INFO and NOLOAD.
	* yyscript.y (union): Add new field SECTION_TYPE.
	(COPY, DSECT, INFO, NOLOAD): New tokens.
	(opt_address_and_section_type): Change type to output_section_header.
	(section_type): New non-terminal
	(section_header): Handle section type.
 	(opt_address_and_section_type): Return section type value.
@
text
@d958 1
a958 1
						  &section);
d977 1
a977 1
					    NULL, &val_section);
@


1.69
log
@2010-03-22  Rafael Espindola  <espindola@@google.com>

	* archive.cc (Should_include): Move to archive.h.
	(should_include_member): Make it a member of Archive.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* archive.h: Include options.h.
	(Archive_member): Moved from Archive.
	(Should_include): Moved from archive.cc.
	(Lib_group): New.
	(Add_lib_group_symbols): New.
	* dynobj.cc (do_should_include_member): New.
	* dynobj.h (do_should_include_member): New.
	* gold.cc (queue_initial_tasks): Update call to queue.
	* main.cc (main): Print lib group stats.
	* object.cc (do_should_include_member): New.
	* object.h: Include archive.h.
	(Object::should_include_member): New.
	(Object::do_should_include_member): New.
	(Sized_relobj::do_should_include_member): New.
	* options.cc (General_options::parse_start_lib): New.
	(General_options::parse_end_lib): New.
	(Input_arguments::add_file): Handle lib groups.
	(Input_arguments::start_group): Check we are not in a lib.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib): New.
	* options.h (General_options): Add start_lib and end_lib.
	(Input_argument::lib_): New.
	(Input_argument::lib): New.
	(Input_argument::is_lib): New.
	(Input_file_lib): New.
	(Input_arguments::in_lib_): New.
	(Input_arguments::in_lib): New.
	(Input_arguments::start_lib): New.
	(Input_arguments::end_lib_): New.
	* plugin.cc (Pluginobj::get_symbol_resolution_info): Mark symbols
	in unused members as preempted.
	(Sized_pluginobj::do_should_include_member): New.
	* plugin.h (Sized_pluginobj::do_should_include_member): New.
	* readsyms.cc (Read_symbols::locks): If we are just reading a member,
	return the blocker.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::do_read_symbols): Handle lib groups.
	(Read_symbols::get_name): Handle lib groups.
	* readsyms.h (Read_symbols): Add an archive member pointer.
	(Read_symbols::do_whole_lib_group): New.
	(Read_symbols::do_lib_group): New.
	(Read_symbols::member_): New.
	* script.cc (read_input_script): Update call to queue_soon.
@
text
@d1649 1
d1655 1
d1665 1
d1679 1
@


1.68
log
@	* script.cc (Version_script_info::build_expression_list_lookup):
	Change complaing about duplicate wildcard match from error to
	warning.
@
text
@d1441 1
a1441 1
					     input_group, this_blocker, nb));
@


1.67
log
@	* script.cc (class Lazy_demangler): Recreate--revert part of patch
	of 2009-12-30.
	(Version_script_info::Version_script_info): Initialize globs_,
	default_version_, default_is_global_, and exact_.  Don't
	initialize globals_ or locals_.
	(Version_script_info::build_lookup_tables): Build local symbols
	first.
	(Version_script_info::unquote): New function.
	(Version_script_info::add_exact_match): New function.
	(Version_script_info::build_expression_list_lookup): Remove lookup
	parameter.  Add is_global parameter.  Change all callers.  Handle
	wildcard pattern specially.  Unquote pattern.  Call
	add_exact_match.
	(Version_script_info::get_name_to_match): New function.
	(Version_script_info::get_symbol_version): New function.
	(Version_script_info::get_symbol_version_helper): Remove.
	(Version_script_info::check_unmatched_names): Call unquote.
	* script.h (class Version_script_info): Change get_symbol_version
	to be non-inline and add is_global parameter; change all callers.
	Rewrite symbol_is_local.  Update declarations.  Define struct
	Version_tree_match, Exact, Globs.  Don't define struct Lookup.
	Remove globals_ and locals_ members.  Add exact_, globs_,
	default_version_, is_global_.
	(Version_script_info::Glob): Remove pattern, add expression and
	is_global.  Update constructor.  Change all callers.
	* dynobj.cc (Versions::finalize): Mark the version symbol as the
	default version.
	(Versions::symbol_section_contents): If a symbol is undefined, or
	defined in a dynamic object, set the version index to
	VER_NDX_LOCAL.
	* symtab.cc (Symbol_table::add_from_relobj): Don't call
	symbol_is_local.
	(Symbol_table::add_from_pluginobj): Likewise.
	* testsuite/ver_matching_test.sh: blaza1 and blaza go into V2.
@
text
@d2148 3
a2150 3
	    gold_error(_("wildcard match appears in both version '%s' "
			 "and '%s' in script"),
		       this->default_version_->tag.c_str(), v->tag.c_str());
@


1.66
log
@	* script.cc (Version_script_info::build_expression_list_lookup):
	Don't warn about ambiguous version, just record the ambiguity.
	(Version_script_info::get_symbol_version_helper): Give error if
	version is ambiguous.
@
text
@d1842 45
d1890 2
a1891 2
  : dependency_lists_(), expression_lists_(), version_trees_(),
    is_finalized_(false)
d1894 1
a1894 4
    {
      this->globals_[i] = NULL;
      this->locals_[i] = NULL;
    }
d1960 78
d2047 77
a2123 2
      this->build_expression_list_lookup(v->global, v, &this->globals_[0]);
      this->build_expression_list_lookup(v->local, v, &this->locals_[0]);
d2128 2
d2135 1
a2135 1
    Lookup** lookup)
d2140 1
a2140 1
  for (size_t j = 0; j < size; ++j)
d2142 18
a2159 5
      const Version_expression& exp(explist->expressions[j]);
      Lookup **pp = &lookup[exp.language];
      if (*pp == NULL)
	*pp = new Lookup();
      Lookup* p = *pp;
d2161 2
a2162 3
      if (!exp.exact_match && strpbrk(exp.pattern.c_str(), "?*[") != NULL)
	p->globs.push_back(Glob(exp.pattern.c_str(), v));
      else
d2164 1
a2164 3
	  std::pair<Exact::iterator, bool> ins =
	    p->exact.insert(std::make_pair(exp.pattern, v));
	  if (!ins.second)
d2166 2
a2167 8
	      const Version_tree* v1 = ins.first->second;
	      if (v1 != NULL && v1->tag != v->tag)
		{
		  // This is an ambiguous match.  It's OK if it's just
		  // documenting symbol versions, but not if we look
		  // up this symbol.
		  ins.first->second = NULL;
		}
d2170 5
d2178 2
a2179 1
// Record that we have matched a name found in the version script.
d2181 5
a2185 3
void
Version_script_info::matched_symbol(const Version_tree* version_tree,
				    const char* name) const
d2187 1
a2187 2
  const struct Version_expression_list* global = version_tree->global;
  for (size_t i = 0; i < global->expressions.size(); ++i)
d2189 8
a2196 8
      const Version_expression& expression(global->expressions[i]);
      if (expression.pattern == name
	  && (expression.exact_match
	      || strpbrk(expression.pattern.c_str(), "?*[") == NULL))
	{
	  expression.was_matched_by_symbol = true;
	  return;
	}
a2197 1
  gold_unreachable();
d2200 5
a2204 5
// Look up SYMBOL_NAME in the list of versions.  If CHECK_GLOBAL is
// true look at the globally visible symbols, otherwise look at the
// symbols listed as "local:".  Return true if the symbol is found,
// false otherwise.  If the symbol is found, then if PVERSION is not
// NULL, set *PVERSION to the version.
d2207 3
a2209 3
Version_script_info::get_symbol_version_helper(const char* symbol_name,
                                               bool check_global,
					       std::string* pversion) const
d2211 4
a2215 3
  const Lookup* const * pp = (check_global
			      ? &this->globals_[0]
			      : &this->locals_[0]);
d2218 2
a2219 2
      const Lookup* lookup = pp[i];
      if (lookup == NULL)
d2222 4
a2225 3
      const char* name_to_match;
      char* allocated;
      switch (i)
d2227 4
a2230 18
	case LANGUAGE_C:
	  allocated = NULL;
	  name_to_match = symbol_name;
	  break;
	case LANGUAGE_CXX:
	  allocated = cplus_demangle(symbol_name, DMGL_ANSI | DMGL_PARAMS);
	  if (allocated == NULL)
	    continue;
	  name_to_match = allocated;
	  break;
	case LANGUAGE_JAVA:
	  allocated = cplus_demangle(symbol_name,
				     DMGL_ANSI | DMGL_PARAMS | DMGL_JAVA);
	  if (allocated == NULL)
	    continue;
	  name_to_match = allocated;
	default:
	  gold_unreachable();
d2233 2
a2234 2
      Exact::const_iterator pe = lookup->exact.find(name_to_match);
      if (pe != lookup->exact.end())
d2236 7
d2244 3
a2246 10
	    {
	      if (pe->second != NULL)
		*pversion = pe->second->tag;
	      else
		{
		  gold_error(_("'%s' has multiple versions in version script"),
			     name_to_match);
		  return false;
		}
	    }
d2254 2
a2255 5
	  if (check_global && !parameters->options().undefined_version())
	    this->matched_symbol(pe->second, name_to_match);

	  if (allocated != NULL)
	    free (allocated);
d2259 1
d2261 16
a2276 3
      for (std::vector<Glob>::const_iterator pg = lookup->globs.begin();
	   pg != lookup->globs.end();
	   ++pg)
d2278 5
a2282 10
	  // Check for * specially since it is fairly common.
	  if ((pg->pattern[0] == '*' && pg->pattern[1] == '\0')
	      || fnmatch(pg->pattern, name_to_match, FNM_NOESCAPE) == 0)
	    {
	      if (pversion != NULL)
		*pversion = pg->version->tag;
	      if (allocated != NULL)
		free (allocated);
	      return true;
	    }
d2284 1
d2286 8
a2293 2
      if (allocated != NULL)
	free (allocated);
d2327 3
a2329 7
	  // Ignore wildcard patterns.
	  if (!expression.exact_match
	      && strpbrk(expression.pattern.c_str(), "?*[") != NULL)
	    continue;

	  if (symtab->lookup(expression.pattern.c_str(),
			     vt->tag.c_str()) == NULL)
d2331 2
a2332 3
	      gold_error(_("version script assignment of %s to symbol %s "
			   "failed: symbol not defined"),
			 vt->tag.c_str(), expression.pattern.c_str());
d2334 5
@


1.65
log
@	PR 10980
	* options.h (class General_options): Add --undefined-version.
	* script.cc (struct Version_expression): Add was_matched_by_symbol
	field.
	(Version_script_info::matched_symbol): New function.
	(Version_script_info::get_symbol_version_helper): Call
	matched_symbol.
	(Version_script_info::check_unmatched_names): New function.
	* script.h (class Version_script_info): Update declarations.
	* gold.cc (queue_middle_tasks): Handle --no-undefined-version.
@
text
@d1960 7
a1966 5
	      if (v1->tag != v->tag)
		gold_error(_("'%s' appears in version script with both "
			     "versions '%s' and '%s'"),
			   exp.pattern.c_str(), v1->tag.c_str(),
			   v->tag.c_str());
d2042 10
a2051 1
	    *pversion = pe->second->tag;
@


1.64
log
@	PR 10979
	* script.cc (read_input_script): If we see a new SECTIONS clause,
	and we have added an input section, give an error.
	* layout.h (class Layout): Add have_added_input_section function.
	Add have_added_input_section_ field.
	* layout.cc (Layout::Layout): Initialize
	have_added_input_section_.
	(Layout::layout): Set have_added_input_section_.
	(Layout::layout_eh_frame): Likewise.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d1796 1
a1796 3
// PATTERN should be from the stringpool.
struct
Version_expression
d1801 2
a1802 1
    : pattern(a_pattern), language(a_language), exact_match(a_exact_match)
d1809 4
a1814 1

d1970 21
d2041 10
d2053 1
d2080 44
@


1.63
log
@	PR 10861
	* script.h (class Version_script_info): Define Language enum.
	Update declarations.  Define Glob, Exact, and Lookup types.  Add
	new fields globals_, locals_, and is_finalized_.
	* script.cc: Various formatting fixes.
	(class Parser_closure): Change language_stack_ from a vector of
	std::string to one of Version_script_info::Language.  Adjust all
	uses accordingly.
	(class Lazy_demangler): Remove.
	(struct Version_expression): Change language from std::string to
	Version_script_info::Language.
	(Version_script_info::Version_script_info): New function.
	(Version_script_info::~Version_script_info): Don't call clear.
	(Version_script_info::finalize): New function.
	(Version_script_info::build_lookup_tables): New function.
	(Version_script_info::build_expression_list_lookup): New
	function.
	(Version_script_info::get_symbol_version_helper): Rewrite to use
	lookup tables.
	(Version_script_info::print_expression_list): Adjust to use
	Version_script_info::Language.
	(script_push_lex_into_version_mode): Check that the version script
	has not been finalized.
	(version_script_push_lang): Change language string to
	Version_script_info::Language.
	* options.cc (Command_line::version_script): New function.
	* options.h (class General_options): Add finalize_dynamic_list
	function.  Change version_script from declaration to definition.
	* testsuite/ver_test_4.script: Remove duplicate def of t2_2.
	* testsuite/version_script.map: Remove duplicate def of foo.
	* testsuite/Makefile.am (ver_matching_def.so): Depend upon
	version_script.map.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1401 3
d1417 6
@


1.62
log
@	* symtab.h (class Symbol_table): Add enum Defined.
	* resolve.cc (Symbol_table::should_override): Add defined
	parameter.  Change all callers.  Test whether object is NULL
	before calling a method on it.
	(Symbol_table::report_resolve_problem): Add defined parameter.
	Change all callers.
	(Symbol_table::should_override_with_special): Likewise.
	* symtab.cc (Symbol_table::define_in_output_data): Add defined
	parameter.  Change all callers.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::define_in_output_segment): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::define_as_constant): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* script.h (class Symbol_assignment): Add is_defsym parameter to
	constructor; change all callers.
	* script.cc (Script_options::add_symbol_assignment): Add is_defsym
	parameter.  Change all callers.  Add is_defsym_ field.
	(class Parser_closure): Add parsing_defsym parameter to
	constructor; change all callers.  Add parsing_defsym accessor
	function.  Add parsing_defsym_ field.
@
text
@d1186 2
a1187 2
    language_stack_.push_back("");
    lex_mode_stack_.push_back(lex->mode());
d1317 1
a1317 1
  const std::string&
d1322 2
a1323 1
  void push_language(const std::string& lang)
d1327 2
a1328 1
  void pop_language()
d1367 1
a1367 1
  std::vector<std::string> language_stack_;
a1780 46
// Helper class that calls cplus_demangle when needed and takes care of freeing
// the result.

class Lazy_demangler
{
 public:
  Lazy_demangler(const char* symbol, int options)
    : symbol_(symbol), options_(options), demangled_(NULL), did_demangle_(false)
  { }

  ~Lazy_demangler()
  { free(this->demangled_); }

  // Return the demangled name. The actual demangling happens on the first call,
  // and the result is later cached.

  inline char*
  get();

 private:
  // The symbol to demangle.
  const char *symbol_;
  // Option flags to pass to cplus_demagle.
  const int options_;
  // The cached demangled value, or NULL if demangling didn't happen yet or
  // failed.
  char *demangled_;
  // Whether we already called cplus_demangle
  bool did_demangle_;
};

// Return the demangled name. The actual demangling happens on the first call,
// and the result is later cached. Returns NULL if the symbol cannot be
// demangled.

inline char*
Lazy_demangler::get()
{
  if (!this->did_demangle_)
    {
      this->demangled_ = cplus_demangle(this->symbol_, this->options_);
      this->did_demangle_ = true;
    }
  return this->demangled_;
}

d1787 9
a1795 6
// pattern and language should be from the stringpool
struct Version_expression {
  Version_expression(const std::string& pattern,
                     const std::string& language,
                     bool exact_match)
      : pattern(pattern), language(language), exact_match(exact_match) {}
d1798 1
a1798 1
  std::string language;
d1805 2
a1806 1
struct Version_expression_list {
a1809 1

d1812 2
a1813 1
struct Version_dependency_list {
a1816 1

d1819 2
a1820 1
struct Version_tree {
d1822 2
a1823 1
      : tag(), global(NULL), local(NULL), dependencies(NULL) {}
d1831 13
a1845 1
  this->clear();
d1848 2
d1853 2
a1854 2
  for (size_t k = 0; k < dependency_lists_.size(); ++k)
    delete dependency_lists_[k];
d1856 2
a1857 2
  for (size_t k = 0; k < version_trees_.size(); ++k)
    delete version_trees_[k];
d1859 2
a1860 2
  for (size_t k = 0; k < expression_lists_.size(); ++k)
    delete expression_lists_[k];
d1864 14
d1882 1
a1882 1
  for (size_t j = 0; j < version_trees_.size(); ++j)
d1888 2
d1894 2
a1895 2
  for (size_t j = 0; j < version_trees_.size(); ++j)
    if (version_trees_[j]->tag == version)
d1898 1
a1898 1
          version_trees_[j]->dependencies;
d1907 52
d1970 62
a2031 40
  Lazy_demangler cpp_demangled_name(symbol_name, DMGL_ANSI | DMGL_PARAMS);
  Lazy_demangler java_demangled_name(symbol_name,
                                     DMGL_ANSI | DMGL_PARAMS | DMGL_JAVA);
  for (size_t j = 0; j < version_trees_.size(); ++j)
    {
      // Is it a global symbol for this version?
      const Version_expression_list* explist =
          check_global ? version_trees_[j]->global : version_trees_[j]->local;
      if (explist != NULL)
        for (size_t k = 0; k < explist->expressions.size(); ++k)
          {
            const char* name_to_match = symbol_name;
            const struct Version_expression& exp = explist->expressions[k];
            if (exp.language == "C++")
              {
                name_to_match = cpp_demangled_name.get();
                // This isn't a C++ symbol.
                if (name_to_match == NULL)
                  continue;
              }
            else if (exp.language == "Java")
              {
                name_to_match = java_demangled_name.get();
                // This isn't a Java symbol.
                if (name_to_match == NULL)
                  continue;
              }
            bool matched;
            if (exp.exact_match)
              matched = strcmp(exp.pattern.c_str(), name_to_match) == 0;
            else
              matched = fnmatch(exp.pattern.c_str(), name_to_match,
                                FNM_NOESCAPE) == 0;
            if (matched)
	      {
		if (pversion != NULL)
		  *pversion = this->version_trees_[j]->tag;
		return true;
	      }
          }
d2033 1
d2111 1
a2111 1
  std::string current_language;
d2118 1
a2118 1
	  if (!current_language.empty())
d2120 13
a2132 1
	  fprintf(f, "      extern \"%s\" {\n", ve.language.c_str());
d2137 1
a2137 1
      if (!current_language.empty())
d2149 1
a2149 1
  if (!current_language.empty())
d2484 3
a2537 2
// TODO: In the old linker, the last argument used to be a bool, but I
// don't know what it meant.
d2589 19
a2607 1
  closure->push_language(std::string(lang, langlen));
@


1.61
log
@	Revert -Wshadow changes, all changes from:
	2009-12-11  Doug Kwan  <dougkwan@@google.com>
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* configure.ac: Remove -Wshadow when setting WARN_CXXFLAGS.
@
text
@d877 3
d1057 2
a1058 2
				      Expression* value, bool provide,
				      bool hidden)
d1063 5
a1067 2
	this->script_sections_.add_symbol_assignment(name, length, value,
						     provide, hidden);
d1070 2
a1071 2
	  Symbol_assignment* p = new Symbol_assignment(name, length, value,
						       provide, hidden);
d1171 1
a1171 1
		 bool in_group, bool is_in_sysroot,
d1177 2
a1178 1
      in_group_(in_group), is_in_sysroot_(is_in_sysroot),
d1201 5
d1337 2
d1391 1
d1487 1
d1551 2
a1552 2
  Parser_closure closure("command line", posdep_options, false, false, NULL,
			 this, &lex, false);
d2285 3
a2287 2
  closure->script_options()->add_symbol_assignment(name, length, value,
						   provide, hidden);
@


1.60
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d81 3
a83 3
  Token(Classification aclassification, int linenum, int char_pos)
    : classification_(aclassification), value_(NULL), value_length_(0),
      opcode_(0), lineno_(linenum), charpos_(char_pos)
d85 2
a86 2
    gold_assert(aclassification == TOKEN_INVALID
		|| aclassification == TOKEN_EOF);
d90 4
a93 4
  Token(Classification aclassification, const char* value, size_t length,
	int linenum, int char_pos)
    : classification_(aclassification), value_(value), value_length_(length),
      opcode_(0), lineno_(linenum), charpos_(char_pos)
d95 2
a96 2
    gold_assert(aclassification != TOKEN_INVALID
		&& aclassification != TOKEN_EOF);
d100 1
a100 1
  Token(int opcode, int linenum, int char_pos)
d102 1
a102 1
      opcode_(opcode), lineno_(linenum), charpos_(char_pos)
d216 2
a217 2
  set_mode(Mode mde)
  { this->mode_ = mde; }
d1163 1
a1163 1
  Parser_closure(const char* afilename,
d1165 3
a1167 3
		 bool in_a_group, bool is_in_a_sysroot,
                 Command_line* acommand_line,
		 Script_options* script_opts,
d1169 4
a1172 4
		 bool skip_on_a_incompatible_target)
    : filename_(afilename), posdep_options_(posdep_options),
      in_group_(in_a_group), is_in_sysroot_(is_in_a_sysroot),
      skip_on_incompatible_target_(skip_on_a_incompatible_target),
d1174 2
a1175 2
      command_line_(acommand_line), script_options_(script_opts),
      version_script_info_(script_opts->version_script_info()),
d1817 4
a1820 4
  Version_expression(const std::string& apattern,
                     const std::string& alanguage,
                     bool is_exact_match)
      : pattern(apattern), language(alanguage), exact_match(is_exact_match) {}
@


1.59
log
@2009-10-16  Doug Kwan  <dougkwan@@google.com>

	* expression.cc (class Segment_start_expression): New class definition.
	(Segment_start_expression::value): New method definition.
	(script_exp_function_segment_start): Return a new
	Segment_start_expression.
	* gold/script-c.h (script_saw_segment_start_expression): New function
	prototype.
	* script-sections.cc (Script_sections::Script_sections): Initialize
	SAW_SEGMENT_START_EXPRESSION_ to false.
	(Script_sections::set_section_addresses): Use -Ttext, -Tdata
	and -Tbbs options to specify section addresses if given in
	command line and no SEGMENT_START expression is seen in a script.
	* script-sections.h (Script_sections::saw_segment_start_expression,
	Script_sections::set_saw_segment_start_expression): New method
	definition.
	(Script_sections::saw_segment_start_expression_): New data member
	declaration.
	* script.cc (script_saw_segment_start_expression): New function.
	* yyscript.y (SEGMENT_START): Call script_saw_segment_start_expression.
	* testsuite/Makefile.am (check_SCRIPTS): Add script_test_6.sh,
	script_test_7.sh and script_test_8.sh.
	(check_DATA): Add script_test_6.stdout, script_test_7.stdout and
	script_test_8.stdout.
	(MOSTLYCLEANFILES): Add script_test_6, script_test_7 and script_test_8.
	(script_test_6, script_test_6.stdout, script_test_7,
	script_test_7.stdout, script_test_8, script_test_8.stdout): New rules.
	* Makefile.in: Regenerate.
	* testsuite/script_test_6.sh: New file.
	* testsuite/script_test_6.t: Same.
	* testsuite/script_test_7.sh: Same.
	* testsuite/script_test_7.t: Same.
	* testsuite/script_test_8.sh: Same.
@
text
@d81 3
a83 3
  Token(Classification classification, int lineno, int charpos)
    : classification_(classification), value_(NULL), value_length_(0),
      opcode_(0), lineno_(lineno), charpos_(charpos)
d85 2
a86 2
    gold_assert(classification == TOKEN_INVALID
		|| classification == TOKEN_EOF);
d90 4
a93 4
  Token(Classification classification, const char* value, size_t length,
	int lineno, int charpos)
    : classification_(classification), value_(value), value_length_(length),
      opcode_(0), lineno_(lineno), charpos_(charpos)
d95 2
a96 2
    gold_assert(classification != TOKEN_INVALID
		&& classification != TOKEN_EOF);
d100 1
a100 1
  Token(int opcode, int lineno, int charpos)
d102 1
a102 1
      opcode_(opcode), lineno_(lineno), charpos_(charpos)
d216 2
a217 2
  set_mode(Mode mode)
  { this->mode_ = mode; }
d1163 1
a1163 1
  Parser_closure(const char* filename,
d1165 3
a1167 3
		 bool in_group, bool is_in_sysroot,
                 Command_line* command_line,
		 Script_options* script_options,
d1169 4
a1172 4
		 bool skip_on_incompatible_target)
    : filename_(filename), posdep_options_(posdep_options),
      in_group_(in_group), is_in_sysroot_(is_in_sysroot),
      skip_on_incompatible_target_(skip_on_incompatible_target),
d1174 2
a1175 2
      command_line_(command_line), script_options_(script_options),
      version_script_info_(script_options->version_script_info()),
d1817 4
a1820 4
  Version_expression(const std::string& pattern,
                     const std::string& language,
                     bool exact_match)
      : pattern(pattern), language(language), exact_match(exact_match) {}
@


1.58
log
@	* script.cc (Script_options::add_symbol_assignment): Always add a
	dot assginment to script_sections_.
	* script-sections.cc (Script_sections::add_dot_assignment):
	Initialize if necessary.
@
text
@d2742 8
@


1.57
log
@2009-10-10  Chris Demetriou  <cgd@@google.com>

	* options.h (Input_file_argument::Input_file_type): New enum.
	(Input_file_argument::is_lib_): Replace with...
	(Input_file_argument::type_): New member.
	(Input_file_argument::Input_file_argument): Take Input_file_type
	'type' rather than boolean 'is_lib' as second argument.
	(Input_file_argument::is_lib): Use type_.
	(Input_file_argument::is_searched_file): New function.
	(Input_file_argument::may_need_search): Handle is_searched_file.
	* options.cc (General_options::parse_library): Support -l:filename.
	(General_options::parse_just_symbols): Update for Input_file_argument
	changes.
	(Command_line::process): Likewise.
	* archive.cc (Archive::get_file_and_offset): Likewise.
	* plugin.cc (Plugin_manager::release_input_file): Likewise.
	* script.cc (read_script_file, script_add_file): Likewise.
	* fileread.cc (Input_file::Input_file): Likewise.
	(Input_file::will_search_for): Handle is_searched_file.
	(Input_file::open): Likewise.
	* readsyms.cc (Read_symbols::get_name): Likewise.
	* testsuite/Makefile.am (searched_file_test): New test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/searched_file_test.cc: New file.
	* testsuite/searched_file_test_lib.cc: New file.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
d1073 5
a1077 4
      if (!this->script_sections_.in_sections_clause())
	gold_error(_("invalid assignment to dot outside of SECTIONS"));
      else
	this->script_sections_.add_dot_assignment(value);
@


1.56
log
@	* descriptor.cc: Include <cstdio> and "binary-io.h".
	(Descriptors::open): Open the files in binary mode always.
	* script.cc (Lex::get_token): Treat \r as whitespace.
@
text
@d1455 3
a1457 1
  Input_file_argument input_argument(filename, false, "", false, posdep);
d2184 4
a2187 2
  Input_file_argument file(name_string.c_str(), false, extra_search_path,
			   false, closure->position_dependent_options());
@


1.55
log
@	* fileread.cc (File_read::get_mtime): New method.
	* fileread.h (Timespec): New structure.
	(File_read::get_mtime): New method.
	* incremental.cc (Incremental_inputs_entry_data::timestamp_usec):
	Renamed from timestamp_nsec.
	(Incremental_inputs_entry_write::timestamp_sec): Fix argument to
	Elf_Xword.
	(Incremental_inputs_entry_write::timestamp_usec): Renamed from
	timestamp_nsec.
	(Incremental_inputs::report_archive): Save mtime; style fix.
	(Incremental_inputs::report_obejct): Save mtime; style fix.
	(Incremental_inputs::report_script): Save mtime; style fix.
	(Incremental_inputs::finalize_inputs): Style fix.
	(Incremental_inputs::finalize): Style fix.
	(Incremental_inputs::create_input_section_data): Store inputs
	mtime.
	* incremental.h (Incremental_inputs::report_script): Add mtime
	argument.
	(Incremental_inputs::Input_info::Input_info): Intialize only one
	union member.
	(Incremental_inputs::Input_info::archive): Move to nameless
	union.
	(Incremental_inputs::Input_info::obejct): Move to nameless union.
	(Incremental_inputs::Input_info::script): Move to nameless union.
	(Incremental_inputs::mtime): New field.
	* script.cc (read_input_script): Pass file mtime to
	Incremental_input.
	* script.h (Script_info::inputs): Style fix.
@
text
@d746 1
a746 1
      while (*p == ' ' || *p == '\t')
@


1.55.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@d3 1
a3 1
// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d746 1
a746 1
      while (*p == ' ' || *p == '\t' || *p == '\r')
d1073 4
a1076 5

      // The GNU linker permits assignments to dot outside of SECTIONS
      // clauses and treats them as occurring inside, so we don't
      // check in_sections_clause here.
      this->script_sections_.add_dot_assignment(value);
d1455 1
a1455 3
  Input_file_argument input_argument(filename,
				     Input_file_argument::INPUT_FILE_TYPE_FILE,
				     "", false, posdep);
d2182 2
a2183 4
  Input_file_argument file(name_string.c_str(),
			   Input_file_argument::INPUT_FILE_TYPE_FILE,
			   extra_search_path, false,
			   closure->position_dependent_options());
@


1.54
log
@	PR 10030
	* yyscript.y: Parse TARGET.
	* script.cc (script_set_target): New function.
	* script-c.h (script_set_target): Declare.
	* options.cc (General_options::string_to_object_format): Rename
	from string_to_object_format in anonymous namespace.  Change
	callers.
	* options.h (class General_options): Declare
	string_to_object_format.
@
text
@d1423 4
a1426 1
      layout->incremental_inputs()->report_script(input_argument, info);
@


1.53
log
@	* gold.h (Incremental_argument_list): Remove (invalid) forward
	declaration.
	* incremental.cc (Incremental_inputs::report_achive): New method.
	(Incremental_inputs::report_object): New method.
	(Incremental_inputs::report_script): New method.
	(Incremental_inputs::finalize_inputs): New method.
	(Incremental_inputs::finalize): Call finalize_inputs().
	(Incremental_inputs::sized_create_incremental_inputs_section_data):
	Create inputs entries.
	* incremental.h (Incremental_input_type): New enum.
	(Incremental_inputs::Incremental_input): Initialize new fields.
	(Incremental_inputs::report_inputs): New method.
	(Incremental_inputs::report_achive): New method.
	(Incremental_inputs::report_object): New method.
	(Incremental_inputs::report_script): New method.
	(Incremental_inputs::finalize_inputs): New method.
	(Incremental_inputs::Input_info): New struct.
	(Incremental_inputs::Input_info_map): New typedef.
	(Incremental_inputs::lock_): New field.
	(Incremental_inputs::Inputs_): New field.
	(Incremental_inputs::Inputs_map): New field.
	* main.cc (main): Call Incremental_input::report_inputs.
	* options.h (Input_argument_list): Typedef moved from
	Input_arguments.
	(Input_file_group::Files): Remove, use ::Input_argument_list.
	(Input_file_group::Input_argument_list): Remove, use
	::Input_argument_list.
	* plugin.cc (Plugin_manager::add_input_file): Add error in
	incremental build.
	* read_syms.cc (do_read_syms): Call Incremental_input::report_*
	functions.
	* script.cc (read_input_script): Call
	Incremental_input::report_script.
	* script.h (Script_info): New class.
@
text
@d1210 1
a1210 1
  // Stop skipping to the next flie on an incompatible target.  This
d2334 12
@


1.52
log
@	* yyscript.y (file_cmd): Recognize EXTERN.
	(extern_name_list, extern_name_list_body): New nonterminals.
	* script.cc (script_add_extern): Define.
	* script-c.h (script_add_extern): Declare.
@
text
@d46 1
d1418 7
@


1.51
log
@	* readsyms.cc (Read_symbols::incompatible_warning): New function.
	(Read_symbols::requeue): New function.
	(Read_symbols::do_read_symbols): If make_elf_object fails because
	the target type is not configured, and the file was searched for,
	issue a warning and retry with the next directory.
	(Add_symbols::run): If the file has an incompatible format, and
	it was searched for, requeue the Read_symbols task.  On error,
	release the object.
	* readsyms.h (class Read_symbols): Add dirindex_ field.  Add
	dirindex parameter to constructor.  Change all callers.  Declare
	incompatible_warning and requeue.
	(class Add_symbols): Add dirpath_, dirindex_, mapfile_,
	input_argument_ and input_group_ fields.  Add them to
	constructor.  Change all callers.
	(class Read_script): Add dirindex_ field.  Add it to constructor.
	Change all callers.
	* archive.cc (Archive::setup): Remove input_objects parameter.
	Change all callers.
	(Archive::get_file_and_offset): Likewise.
	(Archive::read_all_symbols): Likewise.
	(Archive::read_symbols): Likewise.
	(Archive::get_elf_object_for_member): Remove input_objects
	parameter.  Add punconfigured parameter.  Change all callers.
	(Archive::add_symbols): Change return type to bool.  Check return
	value of include_member.
	(Archive::include_all_members): Likewise.
	(Archive::include_member): Change return type to bool.  Return
	false if first included object has incompatible target.  Set
	included_member_ field.
	(Add_archive_symbols::run): If add_symbols returns false, requeue
	Read_symbols task.
	* archive.h (class Archive): Add included_member_ field.
	Initialize it in constructor.  Add input_file and searched_for
	methods.  Update declarations.
	(class Add_archive_symbols): Add dirpath_, dirindex_, and
	input_argument_ fields.  Add them to constructor.  Change all
	callers.
	* script.cc: Include "target-select.h".
	(class Parser_closure): Add skip_on_incompatible_target_ and
	found_incompatible_target_ fields.  Add
	skip_on_incompatible_target parameter to constructor.  Change all
	callers.  Add methods skip_on_incompatible_target,
	clear_skip_on_incompatible_target, found_incompatible_target, and
	set_found_incompatible_target.
	(read_input_script): Add dirindex parameter.  Change all callers.
	If parser finds an incompatible target, requeue Read_symbols
	task.
	(script_set_symbol): Clear skip_on_incompatible_target in
	closure.
	(script_add_assertion, script_parse_option): Likewise.
	(script_start_sections, script_add_phdr): Likewise.
	(script_check_output_format): New function.
	* script.h (read_input_script): Update declaration.
	* script-c.h (script_check_output_format): Declare.
	* yyscript.y (file_cmd): Handle OUTPUT_FORMAT.
	(ignore_cmd): Remove OUTPUT_FORMAT.
	* fileread.cc (Input_file::Input_file): Add explicit this.
	(Input_file::will_search_for): New function.
	(Input_file::open): Add pindex parameter.  Change all callers.
	* fileread.h (class Input_file): Add input_file_argument method.
	Declare will_search_for.  Update declarations.
	* object.cc (make_elf_object): Add punconfigured parameter.
	Change all callers.
	* object.h (class Object): Make input_file public.  Add
	searched_for method.
	(make_elf_object): Update declaration.
	* dirsearch.cc (Dirsearch::find): Add pindex parameter.  Use it to
	restart search.
	* dirsearch.h (class Dirsearch): Update declaration.
	* options.h (class General_options): Add --warn-search-mismatch.
	* parameters.cc (Parameters::is_compatible_target): New function.
	* parameters.h (class Parameters): Declare is_compatible_target.
	* workqueue.cc (Workqueue::add_blocker): New function.
	* workqueue.h (class Workqueue): Declare add_blocker.
@
text
@d2122 13
@


1.50
log
@	* fileread.cc (Input_file::open): Remove options parameter.
	Change all callers.
	(Input_file::open_binary): Likewise.
	* script.cc (read_input_script): Likewise.
	* readsyms.h (class Read_symbols): Remove options_ field.  Remove
	options parameter from constructor.  Change all callers.
	(class Read_script): Likewise.
	* fileread.h (class Input_file): Update declarations.
	* script.h (read_input_script): Update declaration.
@
text
@d43 1
d1166 2
a1167 1
		 Lex* lex)
d1170 2
d1203 24
d1327 6
d1359 3
a1361 2
		  Dirsearch* dirsearch, Input_objects* input_objects,
		  Mapfile* mapfile, Input_group* input_group,
d1379 2
a1380 1
			 &lex);
d1383 11
a1393 1
    return false;
d1412 1
a1412 1
					     layout, dirsearch, mapfile, &*p,
d1446 2
a1447 1
  if (!input_file.open(dirsearch, task))
d1462 2
a1463 1
			 &lex);
d1522 1
a1522 1
			 this, &lex);
d2242 1
d2253 1
d2283 28
d2469 1
d2662 1
@


1.49
log
@	* script.cc (Lazy_demangler): New class.
        (Version_script_info::get_symbol_version_helper): Demangle a
	symbol only once.
@
text
@d1324 1
a1324 2
read_input_script(Workqueue* workqueue, const General_options& options,
		  Symbol_table* symtab, Layout* layout,
d1365 1
a1365 1
      workqueue->queue_soon(new Read_symbols(options, input_objects, symtab,
d1400 1
a1400 1
  if (!input_file.open(cmdline->options(), dirsearch, task))
@


1.48
log
@	* options.cc (General_options::parse_dynamic_list): New function.
	* options.h (General_options): New flags dynamic_list,
	dynamic_list_data, dynamic_list_cpp_new, and
	dynamic_list_cpp_typeinfo.  New variable dynamic_list_.
	(General_options::in_dynamic_list): New function.
	* script.cc (Lex::Mode): New enum DYNAMIC_LIST.
	(Lex::can_start_name): Add support for DYNAMIC_LIST mode.
	(Lex::can_continue_name): Likewise.
	(yylex): Likewise.
	(read_script_file): New parameter script_options.
	(read_dynamic_list): New function.
	(Script_options::define_dynamic_list): New function.
	(dynamic_list_keyword_parsecodes): New variable.
	(dynamic_list_keywords): New variable.
	* script.h (Script_options::define_dynamic_list): New function
	prototype.
	(read_dynamic_list): New function prototype.
	* symtab.cc (strprefix): New macro.
	(Symbol::should_add_dynsym_entry): Support dynamic_list,
	dynamic_list_data, dynamic_list_cpp_new, and
	dynamic_list_cpp_typeinfo.
	* yyscript.y (PARSING_DYNAMIC_LIST): New token.
	(dynamic_list_expr): New rule.
	(dynamic_list_nodes): Likewise.
	(dynamic_list_node): Likewise.
	* testsuite/Makefile.am (dynamic_list): New test.
	* testsuite/Makefile.in: Regenerated.
	* testsuite/dynamic_list.t: New file.
	* testsuite/dynamic_list.sh: New file.
@
text
@d1702 46
d1850 3
a1862 1
            char* demangled_name = NULL;
d1865 1
a1865 2
                demangled_name = cplus_demangle(symbol_name,
                                                DMGL_ANSI | DMGL_PARAMS);
d1867 1
a1867 1
                if (demangled_name == NULL)
a1868 1
                name_to_match = demangled_name;
d1872 1
a1872 3
                demangled_name = cplus_demangle(symbol_name,
                                                (DMGL_ANSI | DMGL_PARAMS
						 | DMGL_JAVA));
d1874 1
a1874 1
                if (demangled_name == NULL)
a1875 1
                name_to_match = demangled_name;
a1882 2
            if (demangled_name != NULL)
              free(demangled_name);
@


1.47
log
@	* layout.cc (Layout::attach_allocated_section_to_segment): Don't
	set tls_segment_ or relro_segment_.
	(Layout::make_output_segment): Set tls_segment_ and relro_segment_
	when appropriate.
	* output.h (Output_section::clear_is_relro): New function.
	* output.cc (Output_segment::add_output_section): Handle SHF_TLS
	sections specially even when output_data_ is empty.
	(Output_segment::maximum_alignment): When first section is relro,
	only force alignment for PT_LOAD segments.
	* script.cc (script_data_segment_align): New function.
	(script_data_segment_relro_end): New function.
	* script-c.h (script_data_segment_align): Declare.
	(script_data_segment_relro_end): Declare.
	* script-sections.h (class Script_sections): Declare
	data_segment_align and data_segment_relro_end.  Add fields
	segment_align_index_ and saw_relro_end_.
	* script-sections.cc (class Sections_element): Add set_is_relro
	virtual function.  Add new bool* parameter to place_orphan_here.
	Add get_output_section virtual function.
	(class Output_section_definition): Add set_is_relro.  Add new
	bool* parameter to place_orphan_here.  Add get_output_section.
	Add is_relro_ field.
	(Output_section_definition::Output_section_definition): Initialize
	evaluated_address_, evaluated_load_address, evaluated_addralign_,
	and is_relro_ fields.
	(Output_section_definition::place_orphan_here): Add is_relro
	parameter.
	(Output_section_definition::set_section_addresses): Set relro for
	output section.
	(Output_section_definition::alternate_constraint): Likewise.
	(class Orphan_output_section): Add new bool* parameter to
	place_orphan_here.  Add get_output_section.
	(Orphan_output_section::place_orphan_here): Add is_relro
	parameter.
	(Script_sections::Script_sections): Initialize
	data_segment_align_index_ and saw_relro_end_.
	(Script_sections::data_segment_align): New function.
	(Script_sections::data_segment_relro_end): New function.
	(Script_sections::place_orphan): Set or clear is_relro.
	(Script_sections::set_section_addresses): Force alignment of first
	TLS section.
	* yyscript.y (exp): Call script_data_segment_align and
	script_data_segment_relro_end.
	* testsuite/relro_script_test.t: New file.
	* testsuite/relro_test.cc (using_script): Declare.
	(t1, t2): Test using_script.
	* testsuite/Makefile.am (check_PROGRAMS): Add relro_script_test.
	(relro_script_test_SOURCES): Define.
	(relro_script_test_DEPENDENCIES): Define.
	(relro_script_test_LDFLAGS): Define.
	(relro_script_test_LDADD): Define.
	(relro_script_test.so): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d187 3
a189 1
    VERSION_SCRIPT
d398 1
a398 1
    case '*': case '[': 
d400 1
d435 1
d444 2
a445 1
      if (this->mode_ == LINKER_SCRIPT || this->mode_ == VERSION_SCRIPT)
d449 1
d451 1
a451 1
      if (this->mode_ == VERSION_SCRIPT)
d458 2
a459 1
      else if (this->mode_ == VERSION_SCRIPT && (c[1] == ':'))
d1171 1
a1171 1
  { 
d1383 1
d1415 1
a1415 1
			 &cmdline->script_options(),
d1436 1
a1436 1
  return read_script_file(filename, cmdline,
d1440 2
a1441 2
// FILE was found as an argument to --version-script.  Read it as a
// version script, and store its contents in
d1447 1
a1447 1
  return read_script_file(filename, cmdline,
d1451 11
d1644 13
d1998 3
d2377 1
a2377 1
script_finish_output_section(void* closurev, 
@


1.46
log
@	* script.cc (Script_options::finalize_symbols): Finalize SECTIONS
	symbols before other symbols.
	* testsuite/script_test_2.cc (test_addr): Declare.
	(test_addr_alias): Declare.
	(main): Check that test_addr and test_addr_alias have the right
	values.
	* testsuite/script_test_2.t: Define test_addr_alias and
	test_addr.
@
text
@d2403 28
@


1.45
log
@	PR 6647
	* script.cc (Version_script_info::get_versions): Don't add empty
	version tag to return value.
	(Version_script_info::get_symbol_version_helper): Change return
	type to bool.  Add pversion parameter.  Change all callers.
	(script_register_vers_node): Don't require a non-NULL tag.
	* script.h (class Version_script_info): Update declarations.
	(Version_script_info::get_symbol_version): Change return type to
	bool.  Add version parameter.  Change all callers.
	* symtab.cc (Sized_symbol::add_from_relobj): Rework version
	handling.  Handle an empty version from a version script.
	(Symbol_table::define_special_symbol): Likewise.
	* testsuite/ver_test_10.script: New file.
	* testsuite/ver_test_10.sh: New file.
	* testsuite/Makefile.am (check_SCRIPTS): Add ver_test_10.sh.
	(check_DATA): Add ver_test_10.syms.
	(ver_test_10.syms, ver_test_10.so): New target.
	* testsuite/Makefile.in: Rebuild.
@
text
@d1112 6
a1126 2

  this->script_sections_.finalize_symbols(symtab, layout);
@


1.44
log
@2008-06-30  Craig Silverstein  <csilvers@@cs.stanford.edu>

        * script.cc (Lex::can_continue_name): Make '?' allowable in
        version-script names.
        * testsuite/version_script.map: Change glob pattern to use '?'
@
text
@d1735 2
a1736 1
    ret.push_back(version_trees_[j]->tag);
d1757 7
a1763 1
const std::string&
d1765 2
a1766 1
                                               bool check_global) const
d1807 5
a1811 1
              return version_trees_[j]->tag;
d1814 1
a1814 2
  static const std::string empty = "";
  return empty;
a2220 1
  gold_assert(tag != NULL);
d2222 2
a2223 1
  tree->tag = std::string(tag, taglen);
@


1.43
log
@	* mapfile.cc: New file.
	* mapfile.h: New file.
	* options.h (class General_options): Add -M/--print-map and -Map.
	* options.cc (General_options::finalize): Make -M equivalent to
	-Map -.
	* main.cc: Include <cstdio> and "mapfile.h".
	(main): Open mapfile if requested.
	* gold.cc (class Middle_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(queue_initial_tasks): Add mapfile parameter.  Change caller.
	(queue_middle_tasks): Likewise.
	* gold.h (queue_initial_tasks, queue_middle_tasks): Update
	declarations.
	* archive.cc: Include "mapfile.h".
	(Archive::add_symbols): Add mapfile parameter.  Change all
	callers.  Pass mapfile, symbol, and reason to include_member.
	(Archive::include_all_members): Add mapfile parameter.  Change all
	callers.
	(Archive::include_member): Add mapfile, sym, and why parameters.
	Change all callers.  Report inclusion to map file.
	* archive.h: Include "fileread.h".
	(class Archive): Update declarations.
	(Archive::file): New const method.
	(class Add_archive_symbols): Add mapfile_ field.  Update
	constructor.  Change all callers.
	* readsyms.h (class Read_symbols): Likewise.
	(class Finish_group): Likewise.
	(class Read_script): Likewise.
	* common.cc: Include "mapfile.h".
	(Symbol_table::allocate_commons): Add mapfile parameter.  Change
	all callers.
	(Symbol_table::do_allocate_commons): Likewise.
	(Symbol_table::do_allocate_commons_list): Likewise.  Report common
	symbol allocation to mapfile.
	* common.h (class Allocate_commons_task): Add mapfile_ field.
	Update constructor.  Change all callers.
	* symtab.h (class Symbol_table): Update declarations.
	* layout.cc: Include "mapfile.h".
	(Layout_task_runner::run): Print information to mapfile.
	(Layout::create_gold_note): Change Output_data_fixed_space to
	Output_data_zero_fill.
	(Layout::create_build_id): Likewise.
	(Layout::print_to_mapfile): New function.
	* layout.h (class Layout_task_runner): Add mapfile_ field.  Update
	constructor.  Change caller.
	(class Layout): Declare print_to_mapfile.
	* output.cc (Output_section::Input_section::print_to_mapfile): New
	function.
	(Output_section::add_input_section): If producing a map, always
	add to input_sections_ list.
	(Output_section::do_print_to_mapfile): New function.
	(Output_segment::print_sections_to_mapfile): New function.
	(Output_segment::print_section_list_to_mapfile): New function.
	* output.h: Include "mapfile.h".
	(Output_data::print_to_mapfile): New function.
	(Output_data::do_print_to_mapfile): New virtual function.
	(Output_segment_headers::do_print_to_mapfile): New function.
	(Output_file_header::do_print_to_mapfile): New function.
	(Output_data_const::do_print_to_mapfile): New function.
	(class Output_data_const_buffer): Add map_name_ field.  Update
	constructor.  Change all callers.  Add do_print_to_mapfile
	function.
	(class Output_data_fixed_space): Likewise.
	(class Output_data_space): Likewise.
	(class Output_data_zero_fill): New class.
	(Output_data_strtab::do_print_to_mapfile): New function.
	(Output_data_reloc_base::do_print_to_mapfile): New function.
	(Output_relocatable_relocs::do_print_to_mapfile): New function.
	(Output_data_group::do_print_to_mapfile): New function.
	(Output_data_got::do_print_to_mapfile): New function.
	(Output_data_dynamic::do_print_to_mapfile): New function.
	(Output_symtab_xindex::do_print_to_mapfile): New function.
	(class Output_section): Declare do_print_to_mapflie.  Declare
	print_to_mapfile in Input_section.
	(class Output_segment): Declare new functions.
	* object.h (Sized_relobj::symbol_count): New function.
	* script-sections.cc
	(Output_section_element_dot_assignment::set_section_addresses):
	Change Output_data_fixed_space to Output_data_zero_fill.
	(Output_data_expression::do_print_to_mapfile): New function.
	* script.cc (read_input_script): Add mapfile parameter.  Change
	all callers.
	* script.h (read_input_script): Update declaration.
	* ehframe.h (Eh_frame_hdr::do_print_to_mapfile): New function.
	(Eh_frame::do_print_to_mapfile): New function.
	* merge.h (Output_merge_data::do_print_to_mapfile): New function.
	(Output_merge_string::do_print_to_mapfile): New function.
	* i386.cc (Output_data_plt_i386::do_print_to_mapfile): New
	function.
	* sparc.cc (Output_data_plt_sparc::do_print_to_mapfile): New
	function.
	* x86_64.cc (Output_data_plt_x86_64::do_print_to_mapfile): New
	function.
	* Makefile.am (CCFILES): Add mapfile.cc.
	(HFILES): Add mapfile.h.
	* Makefile.in: Rebuild.
@
text
@d434 1
a434 1
    case ',': case '?': 
d439 1
a439 1
    case '[': case ']': case '*': case '-':
@


1.42
log
@	PR gold/5986
	Fix problems building gold with gcc 4.3.0.
	* gold.h (TEMPLATE_ATTRIBUTE_PRINTF_4): Define.
	(gold_error_at_location, gold_warning_at_location): Use it.
	* configure.ac: Check whether we can compile and use a template
	function with a printf attribute.
	* x86_64.cc (Target_x86_64::do_code_fill): Swap out a 32-bit value
	when jumping over bytes.
	* object.cc: Instantiate Object::read_section_data.
	* debug.h: Include <cstring>
	* dwarf_reader.cc: Include <algorithm>
	* main.cc: Include <cstring>.
	* options.cc: Include <cstring>.
	* output.cc: Include <cstring>.
	* script.cc: Include <cstring>.
	* script.h: Include <string>.
	* symtab.cc: Include <cstring> and <algorithm>.
	* target-select.cc: Include <cstring>.
	* version.cc: Include <string>.
	* testsuite/testmain.cc: Include <cstdlib>.
	* configure, config.in: Rebuild.
@
text
@d1316 1
a1316 1
		  Input_group* input_group,
d1356 1
a1356 1
					     layout, dirsearch, &*p,
@


1.41
log
@From Craig Silverstein: rework option handling to make it easier to
add a new option.
@
text
@d25 3
a30 2
#include <cstdio>
#include <cstdlib>
@


1.40
log
@From Craig Silverstein: rename some option functions in preparation
for reworking option handling.
@
text
@d2134 1
a2134 1
      char* mutable_option = strndup(option, length);
@


1.39
log
@Support -d/--define-common.
@
text
@d1384 2
a1385 2
  if (posdep.format() == General_options::OBJECT_FORMAT_BINARY)
    posdep.set_format("elf");
@


1.38
log
@Read input scripts which look like input objects with proper
serialization.
@
text
@d2083 9
@


1.37
log
@Don't check assertions until symbols are finalized.  Create an output
section if the script uses a data statement with no input sections.
Don't create a loadable segment for the headers if there is no room.
@
text
@a848 41
// A trivial task which waits for THIS_BLOCKER to be clear and then
// clears NEXT_BLOCKER.  THIS_BLOCKER may be NULL.

class Script_unblock : public Task
{
 public:
  Script_unblock(Task_token* this_blocker, Task_token* next_blocker)
    : this_blocker_(this_blocker), next_blocker_(next_blocker)
  { }

  ~Script_unblock()
  {
    if (this->this_blocker_ != NULL)
      delete this->this_blocker_;
  }

  Task_token*
  is_runnable()
  {
    if (this->this_blocker_ != NULL && this->this_blocker_->is_blocked())
      return this->this_blocker_;
    return NULL;
  }

  void
  locks(Task_locker* tl)
  { tl->add(this, this->next_blocker_); }

  void
  run(Workqueue*)
  { }

  std::string
  get_name() const
  { return "Script_unblock"; }

 private:
  Task_token* this_blocker_;
  Task_token* next_blocker_;
};

d1309 1
a1309 2
// as a script.  We've already read BYTES of data into P, but we
// ignore that.  Return true if the file was handled.
d1317 2
a1318 2
		  Input_file* input_file, const unsigned char*, off_t,
		  Task_token* this_blocker, Task_token* next_blocker)
d1320 2
a1337 5
  // THIS_BLOCKER must be clear before we may add anything to the
  // symbol table.  We are responsible for unblocking NEXT_BLOCKER
  // when we are done.  We are responsible for deleting THIS_BLOCKER
  // when it is unblocked.

d1339 1
a1339 7
    {
      // The script did not add any files to read.  Note that we are
      // not permitted to call NEXT_BLOCKER->unblock() here even if
      // THIS_BLOCKER is NULL, as we do not hold the workqueue lock.
      workqueue->queue(new Script_unblock(this_blocker, next_blocker));
      return true;
    }
d1341 1
d1354 3
a1356 3
      workqueue->queue(new Read_symbols(options, input_objects, symtab,
					layout, dirsearch, &*p,
					input_group, this_blocker, nb));
d1359 2
@


1.36
log
@From Craig Silverstein: Have Parameters point to General_options.
@
text
@d983 1
a983 1
  uint64_t final_val = this->val_->eval_maybe_dot(symtab, layout,
d1003 3
a1005 2
  uint64_t val = this->val_->eval_maybe_dot(symtab, layout, is_dot_available,
					    dot_value, NULL, &val_section);
d1059 1
a1059 1
  if (!this->check_->eval(symtab, layout))
d1124 9
@


1.35
log
@Fix handling of ENTRY in linker script.
@
text
@d954 1
a954 1
  if (parameters->get_size() == 32)
d963 1
a963 1
  else if (parameters->get_size() == 64)
d1008 1
a1008 1
  if (parameters->get_size() == 32)
d1017 1
a1017 1
  else if (parameters->get_size() == 64)
d2039 1
a2039 1
	  const std::string& sysroot(parameters->sysroot());
@


1.34
log
@From Craig Silverstein: rework handling of Script_options.
@
text
@d2116 1
a2116 1
  std::string arg("entry=");
@


1.33
log
@From Craig Silverstein: rename option functions for future option
handling rewrite.
@
text
@d1440 1
a1440 1
			 cmdline->script_options(),
d2114 5
a2118 2
  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
  closure->script_options()->set_entry(entry, length);
d2167 3
a2169 1
      free(mutable_option);
@


1.32
log
@Assignments in linker scripts override definitions from object files.
@
text
@d1422 2
a1423 2
  if (posdep.input_format() == General_options::OBJECT_FORMAT_BINARY)
    posdep.set_input_format("elf");
d2097 1
a2097 1
  closure->position_dependent_options().set_as_needed();
d2106 1
a2106 1
  closure->position_dependent_options().clear_as_needed();
@


1.31
log
@Track sections for expressions.
@
text
@d898 4
d914 2
a915 1
					  this->provide_);
@


1.30
log
@Don't read linker scripts in binary mode.
@
text
@d918 1
a918 1
  this->finalize_maybe_dot(symtab, layout, false, false, 0);
d926 2
a927 2
				     bool dot_has_value,
				     uint64_t dot_value)
d929 1
a929 1
  this->finalize_maybe_dot(symtab, layout, true, dot_has_value, dot_value);
d938 2
a939 2
				      bool dot_has_value,
				      uint64_t dot_value)
d952 2
a953 2
      this->sized_finalize<32>(symtab, layout, is_dot_available, dot_has_value,
			       dot_value);
d961 2
a962 2
      this->sized_finalize<64>(symtab, layout, is_dot_available, dot_has_value,
			       dot_value);
d974 2
a975 2
				  bool is_dot_available, bool dot_has_value,
				  uint64_t dot_value)
d977 1
a977 1
  bool dummy;
d980 2
a981 2
						  dot_has_value, dot_value,
						  &dummy);
d984 2
d992 1
a992 2
				   bool is_dot_available, bool dot_has_value,
				   uint64_t dot_value)
d997 1
a997 1
  bool is_absolute;
d999 2
a1000 3
					    dot_has_value, dot_value,
					    &is_absolute);
  if (!is_absolute)
d1161 1
a1161 1
    (*p)->set_if_absolute(symtab, layout, false, false, 0);
@


1.29
log
@Ignore version scripts for relocatable links.
@
text
@d1415 5
a1419 2
  Input_file_argument input_argument(filename, false, "", false,
				     cmdline->position_dependent_options());
@


1.28
log
@Implement --just-symbols, including -R FILE.  Fix symbol values when
doing a relocatable link.
@
text
@d1742 6
d1750 1
d1753 1
d1756 1
@


1.27
log
@Implement PHDRS.
@
text
@d1415 1
a1415 1
  Input_file_argument input_argument(filename, false, "",
d2041 1
a2041 1
			   closure->position_dependent_options());
@


1.26
log
@Implement SIZEOF_HEADERS, section constraints, other minor linker
script items.
@
text
@d2434 7
a2440 2
  pv->push_back(std::string(str, len));
  return pv;
d2456 52
@


1.25
log
@Fully implement the SECTIONS clause.
@
text
@d396 3
a398 1
      return this->mode_ == VERSION_SCRIPT;
d1612 1
d2148 18
@


1.24
log
@Don't pass around the target in order to define symbols; get it from
the parameters instead.
@
text
@d916 23
d950 2
a951 1
      this->sized_finalize<32>(symtab, layout);
d959 2
a960 1
      this->sized_finalize<64>(symtab, layout);
d971 19
a989 1
Symbol_assignment::sized_finalize(Symbol_table* symtab, const Layout* layout)
d991 30
a1020 2
  Sized_symbol<size>* ssym = symtab->get_sized_symbol<size>(this->sym_);
  ssym->set_value(this->val_->eval(symtab, layout));
d1080 12
a1091 3
  if (this->script_sections_.in_sections_clause())
    this->script_sections_.add_symbol_assignment(name, length, value,
						 provide, hidden);
d1094 6
a1099 3
      Symbol_assignment* p = new Symbol_assignment(name, length, value,
						   provide, hidden);
      this->symbol_assignments_.push_back(p);
d1127 1
d1130 1
a1130 1
// Finalize symbol values.
d1139 23
d2389 7
a2395 2
  pv->push_back(*string_sort);
  return pv;
@


1.23
log
@Parse a SECTIONS clause in a linker script.
@
text
@d897 1
a897 1
Symbol_assignment::add_to_table(Symbol_table* symtab, const Target* target)
d900 1
a900 2
  this->sym_ = symtab->define_as_constant(target,
					  this->name_.c_str(),
d1038 1
a1038 2
Script_options::add_symbols_to_table(Symbol_table* symtab,
				     const Target* target)
d1043 1
a1043 1
    (*p)->add_to_table(symtab, target);
@


1.22
log
@From Craig Silverstein: Handle quoted strings differently in version
scripts, and handle extern "C++" in the middle of a block.
@
text
@d888 1
a888 6
// Class Script_options.

Script_options::Script_options()
  : entry_(), symbol_assignments_()
{
}
d890 5
a894 1
// Add any symbols we are defining to the symbol table.
d897 1
a897 2
Script_options::add_symbols_to_table(Symbol_table* symtab,
				     const Target* target)
d899 3
a901 7
  for (Symbol_assignments::iterator p = this->symbol_assignments_.begin();
       p != this->symbol_assignments_.end();
       ++p)
    {
      elfcpp::STV vis = p->hidden ? elfcpp::STV_HIDDEN : elfcpp::STV_DEFAULT;
      p->sym = symtab->define_as_constant(target,
					  p->name.c_str(),
d909 1
a909 2
					  p->provide);
    }
d912 1
a912 1
// Finalize symbol values.
d915 1
a915 1
Script_options::finalize_symbols(Symbol_table* symtab, const Layout* layout)
d917 8
d928 1
a928 1
      this->sized_finalize_symbols<32>(symtab, layout);
d936 1
a936 1
      this->sized_finalize_symbols<64>(symtab, layout);
d947 105
a1051 2
Script_options::sized_finalize_symbols(Symbol_table* symtab,
				       const Layout* layout)
d1056 1
a1056 7
    {
      if (p->sym != NULL)
	{
	  Sized_symbol<size>* ssym = symtab->get_sized_symbol<size>(p->sym);
	  ssym->set_value(p->value->eval(symtab, layout));
	}
    }
d1384 26
a1459 1
  { "COPY", COPY },
a1464 1
  { "DSECT", DSECT },
a1473 1
  { "INFO", INFO },
a1486 1
  { "NOLOAD", NOLOAD },
d1587 235
d2006 10
d2046 1
a2046 1
extern void
d2056 1
a2056 1
extern void
d2065 1
a2065 1
extern void
a2071 152
// The following structs are used within the VersionInfo class as well
// as in the bison helper functions.  They store the information
// parsed from the version script.

// A single version expression.
// For example, pattern="std::map*" and language="C++".
// pattern and language should be from the stringpool
struct Version_expression {
  Version_expression(const std::string& pattern,
                     const std::string& language,
                     bool exact_match)
      : pattern(pattern), language(language), exact_match(exact_match) {}

  std::string pattern;
  std::string language;
  // If false, we use glob() to match pattern.  If true, we use strcmp().
  bool exact_match;
};


// A list of expressions.
struct Version_expression_list {
  std::vector<struct Version_expression> expressions;
};


// A list of which versions upon which another version depends.
// Strings should be from the Stringpool.
struct Version_dependency_list {
  std::vector<std::string> dependencies;
};


// The total definition of a version.  It includes the tag for the
// version, its global and local expressions, and any dependencies.
struct Version_tree {
  Version_tree()
      : tag(), global(NULL), local(NULL), dependencies(NULL) {}

  std::string tag;
  const struct Version_expression_list* global;
  const struct Version_expression_list* local;
  const struct Version_dependency_list* dependencies;
};

Version_script_info::~Version_script_info()
{
  for (size_t k = 0; k < dependency_lists_.size(); ++k)
    delete dependency_lists_[k];
  for (size_t k = 0; k < version_trees_.size(); ++k)
    delete version_trees_[k];
  for (size_t k = 0; k < expression_lists_.size(); ++k)
    delete expression_lists_[k];
}

std::vector<std::string>
Version_script_info::get_versions() const
{
  std::vector<std::string> ret;
  for (size_t j = 0; j < version_trees_.size(); ++j)
    ret.push_back(version_trees_[j]->tag);
  return ret;
}

std::vector<std::string>
Version_script_info::get_dependencies(const char* version) const
{
  std::vector<std::string> ret;
  for (size_t j = 0; j < version_trees_.size(); ++j)
    if (version_trees_[j]->tag == version)
      {
        const struct Version_dependency_list* deps =
          version_trees_[j]->dependencies;
        if (deps != NULL)
          for (size_t k = 0; k < deps->dependencies.size(); ++k)
            ret.push_back(deps->dependencies[k]);
        return ret;
      }
  return ret;
}

const std::string&
Version_script_info::get_symbol_version_helper(const char* symbol_name,
                                               bool check_global) const
{
  for (size_t j = 0; j < version_trees_.size(); ++j)
    {
      // Is it a global symbol for this version?
      const Version_expression_list* explist =
          check_global ? version_trees_[j]->global : version_trees_[j]->local;
      if (explist != NULL)
        for (size_t k = 0; k < explist->expressions.size(); ++k)
          {
            const char* name_to_match = symbol_name;
            const struct Version_expression& exp = explist->expressions[k];
            char* demangled_name = NULL;
            if (exp.language == "C++")
              {
                demangled_name = cplus_demangle(symbol_name,
                                                DMGL_ANSI | DMGL_PARAMS);
                // This isn't a C++ symbol.
                if (demangled_name == NULL)
                  continue;
                name_to_match = demangled_name;
              }
            else if (exp.language == "Java")
              {
                demangled_name = cplus_demangle(symbol_name,
                                                (DMGL_ANSI | DMGL_PARAMS
						 | DMGL_JAVA));
                // This isn't a Java symbol.
                if (demangled_name == NULL)
                  continue;
                name_to_match = demangled_name;
              }
            bool matched;
            if (exp.exact_match)
              matched = strcmp(exp.pattern.c_str(), name_to_match) == 0;
            else
              matched = fnmatch(exp.pattern.c_str(), name_to_match,
                                FNM_NOESCAPE) == 0;
            if (demangled_name != NULL)
              free(demangled_name);
            if (matched)
              return version_trees_[j]->tag;
          }
    }
  static const std::string empty = "";
  return empty;
}

struct Version_dependency_list*
Version_script_info::allocate_dependency_list()
{
  dependency_lists_.push_back(new Version_dependency_list);
  return dependency_lists_.back();
}

struct Version_expression_list*
Version_script_info::allocate_expression_list()
{
  expression_lists_.push_back(new Version_expression_list);
  return expression_lists_.back();
}

struct Version_tree*
Version_script_info::allocate_version_tree()
{
  version_trees_.push_back(new Version_tree);
  return version_trees_.back();
}

d2172 148
@


1.21
log
@From Andrew Chatham and Craig Silverstein: Add support for version
scripts.
@
text
@d1520 1
a1520 1
      return STRING;
d1716 3
a1718 2
                     const std::string& language)
      : pattern(pattern), language(language) {}
d1722 2
d1795 1
a1795 1
      const Version_expression_list* exp =
d1797 2
a1798 2
      if (exp != NULL)
        for (size_t k = 0; k < exp->expressions.size(); ++k)
d1801 1
d1803 1
a1803 1
            if (exp->expressions[k].language == "C++")
d1812 1
a1812 1
            else if (exp->expressions[k].language == "Java")
d1822 6
a1827 2
            bool matched = fnmatch(exp->expressions[k].pattern.c_str(),
                                   name_to_match, FNM_NOESCAPE) == 0;
d1904 1
a1904 1
			const char *pattern, int patlen)
d1911 2
a1912 1
                         closure->get_current_language()));
d1916 14
d1944 1
a1944 1
// Handle a transition in language, such as at the 
@


1.20
log
@Support assignments and expressions in linker scripts.
@
text
@d25 1
d33 1
d250 5
a254 3
  // Return whether C can appear in a name which has already started.
  inline bool
  can_continue_name(char c);
d260 5
a264 3
  // Return whether C can appear in a hex number.
  inline bool
  can_continue_hex(char c);
d270 6
a275 4
  // Return whether C can appear in a non-hex number.
  inline bool
  can_continue_number(char c)
  { return Lex::can_start_number(c); }
d310 1
a310 1
	       bool (Lex::*can_continue_fn)(char),
d393 4
a396 1
      return this->mode_ == LINKER_SCRIPT && can_continue_name(c2);
d409 2
a410 2
inline bool
Lex::can_continue_name(char c)
d412 1
a412 1
  switch (c)
d427 1
a427 1
      return true;
d430 26
a455 4
    case '=': case '+': case '-':
    case ':': case '[': case ']':
    case ',': case '?': case '*':
      return this->mode_ == LINKER_SCRIPT;
d458 1
a458 1
      return false;
d475 1
a475 1
    return this->can_continue_hex(c3);
d481 2
a482 2
inline bool
Lex::can_continue_hex(char c)
d484 1
a484 1
  switch (c)
d490 1
a490 1
      return true;
d493 1
a493 1
      return false;
d688 1
a688 1
		  bool (Lex::*can_continue_fn)(char),
d693 3
a695 2
  while ((this->*can_continue_fn)(*match))
    ++match;
d978 1
d980 5
a984 1
  { }
d1020 5
d1052 5
d1082 17
d1112 2
d1122 3
d1193 7
a1199 5
// FILENAME was found as an argument to --script (-T).
// Read it as a script, and execute its contents immediately.

bool
read_commandline_script(const char* filename, Command_line* cmdline)
d1219 2
a1220 1
  Lex lex(input_string.c_str(), input_string.length(), PARSING_LINKER_SCRIPT);
d1242 21
d1287 2
a1288 1
// parser.
d1302 5
d1309 2
a1310 2
  static int
  keyword_to_parsecode(const char* keyword, size_t len);
d1313 2
a1314 5
  // The array of all keywords.
  static const Keyword_parsecode keyword_parsecodes_[];

  // The number of keywords.
  static const int keyword_count;
d1321 2
a1322 2
const Keyword_to_parsecode::Keyword_parsecode
Keyword_to_parsecode::keyword_parsecodes_[] =
d1404 17
a1420 3
const int Keyword_to_parsecode::keyword_count =
  (sizeof(Keyword_to_parsecode::keyword_parsecodes_)
   / sizeof(Keyword_to_parsecode::keyword_parsecodes_[0]));
d1450 2
a1451 1
Keyword_to_parsecode::keyword_to_parsecode(const char* keyword, size_t len)
d1457 4
a1460 4
		       Keyword_to_parsecode::keyword_parsecodes_,
		       Keyword_to_parsecode::keyword_count,
		       sizeof(Keyword_to_parsecode::keyword_parsecodes_[0]),
		       ktt_compare);
d1499 12
a1510 1
	int parsecode = Keyword_to_parsecode::keyword_to_parsecode(str, len);
d1688 10
d1705 231
@


1.19
log
@Report linker script errors with line numbers.  Ignore OUTPUT_FORMAT
with three arguments, and ignore OUTPUT_ARCH.
@
text
@d3 1
a3 1
// Copyright 2006, 2007 Free Software Foundation, Inc.
d31 1
d39 1
a39 1
#include "yyscript.h"
d61 2
d71 2
a72 2
    : classification_(TOKEN_INVALID), value_(), opcode_(0),
      lineno_(0), charpos_(0)
d77 2
a78 2
    : classification_(classification), value_(), opcode_(0),
      lineno_(lineno), charpos_(charpos)
d85 1
a85 1
  Token(Classification classification, const std::string& value,
d87 2
a88 2
    : classification_(classification), value_(value), opcode_(0),
      lineno_(lineno), charpos_(charpos)
a93 6
  // A token representing a string of characters.
  Token(const std::string& s, int lineno, int charpos)
    : classification_(TOKEN_STRING), value_(s), opcode_(0),
      lineno_(lineno), charpos_(charpos)
  { }

d96 2
a97 2
    : classification_(TOKEN_OPERATOR), value_(), opcode_(opcode),
      lineno_(lineno), charpos_(charpos)
d127 2
a128 2
  const std::string&
  string_value() const
d130 3
a132 1
    gold_assert(this->classification_ == TOKEN_STRING);
d143 1
a143 1
  int64_t
d147 3
a149 1
    return strtoll(this->value_.c_str(), NULL, 0);
d155 5
a159 2
  // The token value, for TOKEN_STRING or TOKEN_INTEGER.
  std::string value_;
d169 1
a169 3
// This class handles lexing a file into a sequence of tokens.  We
// don't expect linker scripts to be large, so we just read them and
// tokenize them all at once.
d174 18
a191 2
  Lex(Input_file* input_file)
    : input_file_(input_file), tokens_()
d194 7
a200 5
  // Tokenize the file.  Return the final token, which will be either
  // an invalid token or an EOF token.  An invalid token indicates
  // that tokenization failed.
  Token
  tokenize();
d202 4
a205 2
  // A token sequence.
  typedef std::vector<Token> Token_sequence;
d207 4
a210 4
  // Return the tokens.
  const Token_sequence&
  tokens() const
  { return this->tokens_; }
a215 4
  // Read the file into a string buffer.
  void
  read_file(std::string*);

d218 2
a219 2
  make_token(Token::Classification c, const char* p) const
  { return Token(c, this->lineno_, p - this->linestart_ + 1); }
d223 2
a224 1
  make_token(Token::Classification c, const std::string& v, const char* p)
d226 1
a226 1
  { return Token(c, v, this->lineno_, p - this->linestart_ + 1); }
d230 2
a231 2
  make_token(int opcode, const char* p) const
  { return Token(opcode, this->lineno_, p - this->linestart_ + 1); }
d235 2
a236 2
  make_invalid_token(const char* p)
  { return this->make_token(Token::TOKEN_INVALID, p); }
d240 2
a241 2
  make_eof_token(const char* p)
  { return this->make_token(Token::TOKEN_EOF, p); }
d245 1
a245 1
  static inline bool
d249 1
a249 1
  static inline bool
d253 1
a253 1
  static inline bool
d257 1
a257 1
  static inline bool
d265 1
a265 1
  static inline bool
d301 2
a302 1
  gather_token(Token::Classification, bool (*can_continue_fn)(char),
d309 13
a321 4
  // The file we are reading.
  Input_file* input_file_;
  // The token sequence we create.
  Token_sequence tokens_;
d324 1
a324 1
  // The start of the current line in the buffer.
d333 1
a333 1
Lex::read_file(std::string* contents)
d335 1
a335 1
  off_t filesize = this->input_file_->file().filesize();
d346 1
a346 1
      this->input_file_->file().read(off, get, buf);
d358 3
a360 2
// some character which can appear in a symbol.  That is, "~0" is a
// symbol name, and "~ 0" is an expression using bitwise not.  We are
d378 1
a378 1
    case '_': case '.': case '$': case '/': case '\\':
d381 3
d385 1
a385 1
      return can_continue_name(c2);
d395 2
a396 1
// script language requires spaces around operators.
d413 1
a413 2
    case '_': case '.': case '$': case '/': case '\\':
    case '~':
d416 5
a420 1
    case '=': case '+': case '-': case ':': case '[': case ']':
d422 1
a422 1
      return true;
d433 2
a434 2
// kilo.  Those are mentioned in the documentation, and we accept
// them.
d442 1
a442 1
    return Lex::can_continue_hex(c3);
d655 1
a655 1
		  bool (*can_continue_fn)(char),
d660 1
a660 1
  while ((*can_continue_fn)(*match))
d663 1
a663 3
  return this->make_token(classification,
			  std::string(start, match - start),
			  start);
d678 1
a678 3
  return this->make_token(Token::TOKEN_STRING,
			  std::string(p, skip),
			  start);
d736 1
a736 1
      if (Lex::can_start_name(p[0], p[1]))
d738 2
a739 2
				  Lex::can_continue_name,
				  p, p + 2, pp);
d751 1
a751 1
      if (Lex::can_start_hex(p[0], p[1], p[2]))
d753 1
a753 1
				  Lex::can_continue_hex,
d758 1
a758 1
				  Lex::can_continue_number,
d788 1
a788 1
// Tokenize the file.  Return the final token.
d790 2
a791 2
Token
Lex::tokenize()
d793 2
a794 9
  std::string contents;
  this->read_file(&contents);

  const char* p = contents.c_str();

  this->lineno_ = 1;
  this->linestart_ = p;

  while (true)
d796 4
a799 1
      Token t(this->get_token(&p));
d801 1
a801 5
      // Don't let an early null byte fool us into thinking that we've
      // reached the end of the file.
      if (t.is_eof()
	  && static_cast<size_t>(p - contents.c_str()) < contents.length())
	t = this->make_invalid_token(p);
d803 6
a808 2
      if (t.is_invalid() || t.is_eof())
	return t;
d810 1
a810 2
      this->tokens_.push_back(t);
    }
d854 73
d939 2
a940 2
		 Layout* layout,
		 const Lex::Token_sequence* tokens)
d943 2
a944 2
      command_line_(command_line), layout_(layout), tokens_(tokens),
      next_token_index_(0), inputs_(NULL)
d972 2
a973 1
  Command_line* command_line()
d976 4
a979 9
  // Return the Layout structure passed in at constructor time.  This
  // value may be NULL.
  Layout* layout()
  { return this->layout_; }

  // Whether we are at the end of the token list.
  bool
  at_eof() const
  { return this->next_token_index_ >= this->tokens_->size(); }
d985 12
a996 3
    const Token* ret = &(*this->tokens_)[this->next_token_index_];
    ++this->next_token_index_;
    return ret;
d999 3
a1001 3
  // Return the previous token.
  const Token*
  last_token() const
d1003 3
a1005 2
    gold_assert(this->next_token_index_ > 0);
    return &(*this->tokens_)[this->next_token_index_ - 1];
d1008 10
d1044 10
a1053 7
  // May be NULL if the user chooses not to pass one in.
  Layout* layout_;

  // The tokens to be returned by the lexer.
  const Lex::Token_sequence* tokens_;
  // The index of the next token to return.
  unsigned int next_token_index_;
d1071 4
a1074 3
  Lex lex(input_file);
  if (lex.tokenize().is_invalid())
    return false;
d1081 2
a1082 2
			 layout,
			 &lex.tokens());
d1143 4
a1146 7
  Lex lex(&input_file);
  if (lex.tokenize().is_invalid())
    {
      // Opening the file locked it, so now we need to unlock it.
      input_file.file().unlock(task);
      return false;
    }
d1153 2
a1154 2
			 NULL,
			 &lex.tokens());
d1168 23
d1209 1
a1209 1
  keyword_to_parsecode(const char* keyword);
d1229 1
d1315 6
d1324 1
a1324 1
  const char* key = static_cast<const char*>(keyv);
d1327 6
a1332 1
  return strcmp(key, ktt->keyword);
d1338 1
a1338 1
Keyword_to_parsecode::keyword_to_parsecode(const char* keyword)
d1340 4
a1343 1
  void* kttv = bsearch(keyword,
a1367 4

  if (closure->at_eof())
    return 0;

a1368 1

d1372 2
d1375 3
d1379 1
a1379 1
      gold_unreachable();
d1383 4
a1386 2
	const char* str = token->string_value().c_str();
	int parsecode = Keyword_to_parsecode::keyword_to_parsecode(str);
d1389 2
a1390 1
	lvalp->string = str;
d1394 4
d1413 2
a1414 4

  const Token* token = closure->last_token();
  gold_error(_("%s:%d:%d: %s"), closure->filename(), token->lineno(),
	     token->charpos(), message);
d1420 1
a1420 1
script_add_file(void* closurev, const char* name)
d1428 1
a1428 1
  std::string name_string;
d1431 1
a1431 1
  if (IS_ABSOLUTE_PATH (name))
d1437 1
a1437 2
	  name_string = sysroot + name;
	  name = name_string.c_str();
d1453 1
a1453 1
  Input_file_argument file(name, false, extra_search_path,
d1508 1
a1508 1
script_set_entry(void* closurev, const char* entry)
d1511 14
a1524 4
  if (closure->command_line() != NULL)
    closure->command_line()->set_entry(entry);
  else
    closure->layout()->set_entry(entry);
d1530 1
a1530 1
script_parse_option(void* closurev, const char* option)
d1539 1
a1539 1
      gold_warning(_("%s: ignoring command OPTION; OPTION is only valid"
d1541 1
a1541 1
		   closure->filename());
d1546 2
a1547 1
      char* mutable_option = strdup(option);
d1552 19
@


1.18
log
@Add support for -e and for ENTRY in linker scripts.
@
text
@d884 1
a884 1
  // Return the next token.
d893 8
d1251 3
a1253 1
  gold_error(_("%s: %s"), closure->filename(), message);
@


1.17
log
@Rewrite workqueue.  This version eliminates the master thread, and
reduces the amount of locking required to find a new thread to run.
@
text
@d37 1
d838 1
d842 1
a842 1
      command_line_(command_line), tokens_(tokens),
d874 5
d919 2
d952 1
d1027 1
d1036 3
d1335 12
d1359 2
a1360 2
      gold_warning(_("%s: Ignoring command OPTION; OPTION is only valid"
		     " for scripts specified via -T"),
@


1.16
log
@Add threading support.
@
text
@d800 2
a801 2
  Is_runnable_type
  is_runnable(Workqueue*)
d804 2
a805 2
      return IS_BLOCKED;
    return IS_RUNNABLE;
d808 3
a810 5
  Task_locker*
  locks(Workqueue* workqueue)
  {
    return new Task_locker_block(*this->next_blocker_, workqueue);
  }
d827 2
a828 2
// can't use global variables because we need not be called in the
// main thread.
d928 1
a928 1
		  const Dirsearch& dirsearch, Input_objects* input_objects,
d957 1
a957 1
      // THIS_BLOCKER is NULL, as we are not in the main thread.
d971 1
a971 1
	  nb = new Task_token();
d993 5
d1001 1
a1001 1
  if (!input_file.open(cmdline->options(), dirsearch))
d1008 1
a1008 1
      input_file.file().unlock();
d1020 1
a1020 1
      input_file.file().unlock();
d1024 1
a1024 1
  input_file.file().unlock();
@


1.15
log
@From Craig Silverstein: Implement OPTION in linker scripts.
@
text
@d818 4
@


1.14
log
@From Craig Silverstein: Remove extraneous comment.
@
text
@d834 1
d837 2
a838 1
      in_group_(in_group), is_in_sysroot_(is_in_sysroot), tokens_(tokens),
d864 6
d908 2
d940 1
d987 2
a988 3
  // We don't need to use the real directory search path here:
  // FILENAME was specified on the command line, and we don't want to
  // search for it.
d1009 1
d1320 18
a1337 1
  printf("%s: Saw option %s\n", closure->filename(), option);  //!!
@


1.13
log
@From Craig Silverstein and Ian Lance Taylor: Process --script option.
@
text
@a934 4
  // If this routine was called from the main thread rather than a
  // work queue -- as it is for the --script option -- then our
  // work here is done.

@


1.12
log
@From Craig Silverstein: preliminary support for OPTION in linker script.
@
text
@d31 1
d935 4
d971 40
@


1.11
log
@Remove extraneous newlines.
@
text
@d1048 1
d1260 9
@


1.10
log
@Run all error handling through an Errors object.  Delete output file
on error.
@
text
@d1169 1
a1169 1
  gold_error(_("%s: %s\n"), closure->filename(), message);
@


1.9
log
@Full support for --sysroot.
@
text
@d1169 1
a1169 3
  fprintf(stderr, _("%s: %s: %s\n"),
	  program_name, closure->filename(), message);
  gold_exit(false);
@


1.8
log
@From Craig Silverstein: add support for searching for input files
named in linker scripts.
@
text
@d29 1
d35 1
d832 1
a832 1
		 bool in_group,
d835 1
a835 1
      in_group_(in_group), tokens_(tokens),
d855 6
d897 2
d928 1
d1180 33
a1212 8
  // In addition to checking the normal library search path, we also
  // want to check in the script-directory.
  const char *slash = strrchr(closure->filename(), '/');
  std::string script_directory(closure->filename(),
                               slash ? slash - closure->filename() + 1 : 0);
  Input_file_argument file(name, false,
                           slash ? script_directory.c_str() : ".",
                           closure->position_dependent_options());
@


1.7
log
@Rework File_read interface.  Get file size.  Use pread when
available.
@
text
@d1169 8
a1176 14
  std::string absname;
  if (name[0] == '/')
    {
      absname = name;
    }
  else
    {
      // Prepend `dirname closure->filename()` to make the path absolute.
      char *slash = strrchr(closure->filename(), '/');
      absname.assign(closure->filename(),
                     slash ? slash - closure->filename() + 1 : 0);
      absname += name;
    }
  Input_file_argument file(absname.c_str(), false, closure->position_dependent_options());
@


1.6
log
@Break out default pbytes argument to read and get_view routines,
adding new routines.
@
text
@d302 1
d304 2
a306 1
  off_t got;
d308 1
a308 1
  do
d310 6
a315 3
      this->input_file_->file().read_up_to(off, sizeof buf, buf, &got);
      contents->append(reinterpret_cast<char*>(&buf[0]), got);
      off += got;
a316 1
  while (got == sizeof buf);
@


1.5
log
@From Craig Silverstein: Fix bug when reading large script files.
@
text
@d308 1
a308 1
      this->input_file_->file().read(off, sizeof buf, buf, &got);
@


1.4
log
@Add licensing text to every source file.
@
text
@d310 1
@


1.3
log
@Make relative references in linker scripts absolute and update a
comment about relocate() being called.
@
text
@d3 20
@


1.2
log
@Hash tables, dynamic section, i386 PLT, gold_assert.
@
text
@d1144 14
a1157 1
  Input_file_argument file(name, false, closure->position_dependent_options());
@


1.1
log
@More dynamic object support, initial scripting support.
@
text
@a6 1
#include <cassert>
d52 4
a55 1
  { assert(classification == TOKEN_INVALID || classification == TOKEN_EOF); }
d62 4
a65 1
  { assert(classification != TOKEN_INVALID && classification != TOKEN_EOF); }
d109 1
a109 1
    assert(this->classification_ == TOKEN_STRING);
d116 1
a116 1
    assert(this->classification_ == TOKEN_OPERATOR);
d123 1
a123 1
    assert(this->classification_ == TOKEN_INTEGER);
d1105 1
a1105 1
      abort();
@

