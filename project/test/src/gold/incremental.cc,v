head	1.56;
access;
symbols
	binutils-2_24-branch:1.56.0.2
	binutils-2_24-branchpoint:1.56
	binutils-2_21_1:1.24
	binutils-2_23_2:1.55.2.1
	binutils-2_23_1:1.55.2.1
	binutils-2_23:1.55
	binutils-2_23-branch:1.55.0.2
	binutils-2_23-branchpoint:1.55
	binutils-2_22_branch:1.47.0.4
	binutils-2_22:1.47
	binutils-2_22-branch:1.47.0.2
	binutils-2_22-branchpoint:1.47
	binutils-2_21:1.24
	binutils-2_21-branch:1.24.0.2
	binutils-2_21-branchpoint:1.24
	binutils-2_20_1:1.6.2.1
	binutils-2_20:1.6.2.1
	binutils-2_20-branch:1.6.0.2
	binutils-2_20-branchpoint:1.6
	dje-cgen-play1-branch:1.4.0.2
	dje-cgen-play1-branchpoint:1.4
	binutils_latest_snapshot:1.56;
locks; strict;
comment	@// @;


1.56
date	2012.11.01.22.35.06;	author roland;	state Exp;
branches;
next	1.55;

1.55
date	2012.07.11.14.18.40;	author ian;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2012.05.02.21.37.23;	author roland;	state Exp;
branches;
next	1.53;

1.53
date	2012.04.24.22.05.28;	author ccoutant;	state Exp;
branches;
next	1.52;

1.52
date	2012.03.21.19.02.21;	author ccoutant;	state Exp;
branches;
next	1.51;

1.51
date	2012.01.28.00.23.31;	author hjl;	state Exp;
branches;
next	1.50;

1.50
date	2012.01.04.00.18.22;	author ccoutant;	state Exp;
branches;
next	1.49;

1.49
date	2011.10.10.17.38.07;	author ccoutant;	state Exp;
branches;
next	1.48;

1.48
date	2011.09.29.17.04.35;	author ccoutant;	state Exp;
branches;
next	1.47;

1.47
date	2011.09.19.19.29.55;	author ccoutant;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2011.09.18.15.06.27;	author ccoutant;	state Exp;
branches;
next	1.45;

1.45
date	2011.09.14.01.10.43;	author ccoutant;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.08.22.48.08;	author ian;	state Exp;
branches;
next	1.43;

1.43
date	2011.07.06.22.26.37;	author ccoutant;	state Exp;
branches;
next	1.42;

1.42
date	2011.07.06.22.15.12;	author ccoutant;	state Exp;
branches;
next	1.41;

1.41
date	2011.07.06.22.07.59;	author ccoutant;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.06.21.22.55;	author ccoutant;	state Exp;
branches;
next	1.39;

1.39
date	2011.07.06.21.19.31;	author ccoutant;	state Exp;
branches;
next	1.38;

1.38
date	2011.06.08.04.05.24;	author ccoutant;	state Exp;
branches;
next	1.37;

1.37
date	2011.06.08.03.50.10;	author ccoutant;	state Exp;
branches;
next	1.36;

1.36
date	2011.05.26.18.44.26;	author ccoutant;	state Exp;
branches;
next	1.35;

1.35
date	2011.05.24.23.31.07;	author ccoutant;	state Exp;
branches;
next	1.34;

1.34
date	2011.05.24.21.57.28;	author ccoutant;	state Exp;
branches;
next	1.33;

1.33
date	2011.05.24.21.41.10;	author ccoutant;	state Exp;
branches;
next	1.32;

1.32
date	2011.05.23.23.27.10;	author ccoutant;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.25.20.28.48;	author ccoutant;	state Exp;
branches;
next	1.30;

1.30
date	2011.04.22.22.39.55;	author ccoutant;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.12.05.55.33;	author ian;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.12.00.44.47;	author ccoutant;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.05.20.16.17;	author ccoutant;	state Exp;
branches;
next	1.26;

1.26
date	2011.03.30.21.07.13;	author ccoutant;	state Exp;
branches;
next	1.25;

1.25
date	2011.03.30.01.31.57;	author ccoutant;	state Exp;
branches;
next	1.24;

1.24
date	2010.10.14.22.10.22;	author ccoutant;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.15.18.10.31;	author ccoutant;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.25.08.36.54;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.19.00.02.18;	author ian;	state Exp;
branches;
next	1.20;

1.20
date	2010.08.12.22.14.59;	author ccoutant;	state Exp;
branches;
next	1.19;

1.19
date	2010.08.12.22.01.11;	author ccoutant;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.05.22.04.48;	author ian;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.04.18.18.18;	author espindola;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.03.15.43.01;	author espindola;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.03.04.26.01;	author espindola;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.02.18.14.22;	author espindola;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.02.16.27.15;	author espindola;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.25.00.10.05;	author espindola;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.24.22.50.44;	author espindola;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.24.20.18.17;	author espindola;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.09.23.07.30;	author dougkwan;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.09.22.38.07;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.09.16.40.51;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.01.17.32.35;	author ian;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2009.07.06.23.11.21;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.31.23.07.26;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.15.17.01.04;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	2009.04.24.15.44.02;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	2009.03.20.23.37.51;	author ian;	state Exp;
branches;
next	;

1.55.2.1
date	2012.11.07.17.31.30;	author roland;	state Exp;
branches;
next	;

1.47.2.1
date	2011.12.19.21.14.39;	author ian;	state Exp;
branches;
next	;

1.6.2.1
date	2009.10.16.05.51.17;	author ian;	state Exp;
branches;
next	;


desc
@@


1.56
log
@gold/
	* dwarf_reader.cc (Sized_elf_reloc_mapper::symbol_section): Cast
	SYMNDX to off_t before comparing it to this->data_size().
	* output.cc (Output_symtab_xindex::endian_do_write): Likewise.
	* incremental.cc (Output_section_incremental_inputs::do_write):
	Cast GLOBAL_SYM_COUNT to off_t before comparing it to SYMTAB_SIZE.
@
text
@// inremental.cc -- incremental linking support for gold

// Copyright 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
// Written by Mikolaj Zalewski <mikolajz@@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

#include "gold.h"

#include <set>
#include <cstdarg>
#include "libiberty.h"

#include "elfcpp.h"
#include "options.h"
#include "output.h"
#include "symtab.h"
#include "incremental.h"
#include "archive.h"
#include "object.h"
#include "output.h"
#include "target-select.h"
#include "target.h"
#include "fileread.h"
#include "script.h"

namespace gold {

// Version number for the .gnu_incremental_inputs section.
// Version 1 was the initial checkin.
// Version 2 adds some padding to ensure 8-byte alignment where necessary.
const unsigned int INCREMENTAL_LINK_VERSION = 2;

// This class manages the .gnu_incremental_inputs section, which holds
// the header information, a directory of input files, and separate
// entries for each input file.

template<int size, bool big_endian>
class Output_section_incremental_inputs : public Output_section_data
{
 public:
  Output_section_incremental_inputs(const Incremental_inputs* inputs,
				    const Symbol_table* symtab)
    : Output_section_data(size / 8), inputs_(inputs), symtab_(symtab)
  { }

 protected:
  // This is called to update the section size prior to assigning
  // the address and file offset.
  void
  update_data_size()
  { this->set_final_data_size(); }

  // Set the final data size.
  void
  set_final_data_size();

  // Write the data to the file.
  void
  do_write(Output_file*);

  // Write to a map file.
  void
  do_print_to_mapfile(Mapfile* mapfile) const
  { mapfile->print_output_data(this, _("** incremental_inputs")); }

 private:
  // Write the section header.
  unsigned char*
  write_header(unsigned char* pov, unsigned int input_file_count,
	       section_offset_type command_line_offset);

  // Write the input file entries.
  unsigned char*
  write_input_files(unsigned char* oview, unsigned char* pov,
		    Stringpool* strtab);

  // Write the supplemental information blocks.
  unsigned char*
  write_info_blocks(unsigned char* oview, unsigned char* pov,
		    Stringpool* strtab, unsigned int* global_syms,
		    unsigned int global_sym_count);

  // Write the contents of the .gnu_incremental_symtab section.
  void
  write_symtab(unsigned char* pov, unsigned int* global_syms,
	       unsigned int global_sym_count);

  // Write the contents of the .gnu_incremental_got_plt section.
  void
  write_got_plt(unsigned char* pov, off_t view_size);

  // Typedefs for writing the data to the output sections.
  typedef elfcpp::Swap<size, big_endian> Swap;
  typedef elfcpp::Swap<16, big_endian> Swap16;
  typedef elfcpp::Swap<32, big_endian> Swap32;
  typedef elfcpp::Swap<64, big_endian> Swap64;

  // Sizes of various structures.
  static const int sizeof_addr = size / 8;
  static const int header_size =
      Incremental_inputs_reader<size, big_endian>::header_size;
  static const int input_entry_size =
      Incremental_inputs_reader<size, big_endian>::input_entry_size;
  static const unsigned int object_info_size =
      Incremental_inputs_reader<size, big_endian>::object_info_size;
  static const unsigned int input_section_entry_size =
      Incremental_inputs_reader<size, big_endian>::input_section_entry_size;
  static const unsigned int global_sym_entry_size =
      Incremental_inputs_reader<size, big_endian>::global_sym_entry_size;
  static const unsigned int incr_reloc_size =
      Incremental_relocs_reader<size, big_endian>::reloc_size;

  // The Incremental_inputs object.
  const Incremental_inputs* inputs_;

  // The symbol table.
  const Symbol_table* symtab_;
};

// Inform the user why we don't do an incremental link.  Not called in
// the obvious case of missing output file.  TODO: Is this helpful?

void
vexplain_no_incremental(const char* format, va_list args)
{
  char* buf = NULL;
  if (vasprintf(&buf, format, args) < 0)
    gold_nomem();
  gold_info(_("the link might take longer: "
	      "cannot perform incremental link: %s"), buf);
  free(buf);
}

void
explain_no_incremental(const char* format, ...)
{
  va_list args;
  va_start(args, format);
  vexplain_no_incremental(format, args);
  va_end(args);
}

// Report an error.

void
Incremental_binary::error(const char* format, ...) const
{
  va_list args;
  va_start(args, format);
  // Current code only checks if the file can be used for incremental linking,
  // so errors shouldn't fail the build, but only result in a fallback to a
  // full build.
  // TODO: when we implement incremental editing of the file, we may need a
  // flag that will cause errors to be treated seriously.
  vexplain_no_incremental(format, args);
  va_end(args);
}

// Return TRUE if a section of type SH_TYPE can be updated in place
// during an incremental update.  We can update sections of type PROGBITS,
// NOBITS, INIT_ARRAY, FINI_ARRAY, PREINIT_ARRAY, and NOTE.  All others
// will be regenerated.

bool
can_incremental_update(unsigned int sh_type)
{
  return (sh_type == elfcpp::SHT_PROGBITS
	  || sh_type == elfcpp::SHT_NOBITS
	  || sh_type == elfcpp::SHT_INIT_ARRAY
	  || sh_type == elfcpp::SHT_FINI_ARRAY
	  || sh_type == elfcpp::SHT_PREINIT_ARRAY
	  || sh_type == elfcpp::SHT_NOTE);
}

// Find the .gnu_incremental_inputs section and related sections.

template<int size, bool big_endian>
bool
Sized_incremental_binary<size, big_endian>::find_incremental_inputs_sections(
    unsigned int* p_inputs_shndx,
    unsigned int* p_symtab_shndx,
    unsigned int* p_relocs_shndx,
    unsigned int* p_got_plt_shndx,
    unsigned int* p_strtab_shndx)
{
  unsigned int inputs_shndx =
      this->elf_file_.find_section_by_type(elfcpp::SHT_GNU_INCREMENTAL_INPUTS);
  if (inputs_shndx == elfcpp::SHN_UNDEF)  // Not found.
    return false;

  unsigned int symtab_shndx =
      this->elf_file_.find_section_by_type(elfcpp::SHT_GNU_INCREMENTAL_SYMTAB);
  if (symtab_shndx == elfcpp::SHN_UNDEF)  // Not found.
    return false;
  if (this->elf_file_.section_link(symtab_shndx) != inputs_shndx)
    return false;

  unsigned int relocs_shndx =
      this->elf_file_.find_section_by_type(elfcpp::SHT_GNU_INCREMENTAL_RELOCS);
  if (relocs_shndx == elfcpp::SHN_UNDEF)  // Not found.
    return false;
  if (this->elf_file_.section_link(relocs_shndx) != inputs_shndx)
    return false;

  unsigned int got_plt_shndx =
      this->elf_file_.find_section_by_type(elfcpp::SHT_GNU_INCREMENTAL_GOT_PLT);
  if (got_plt_shndx == elfcpp::SHN_UNDEF)  // Not found.
    return false;
  if (this->elf_file_.section_link(got_plt_shndx) != inputs_shndx)
    return false;

  unsigned int strtab_shndx = this->elf_file_.section_link(inputs_shndx);
  if (strtab_shndx == elfcpp::SHN_UNDEF
      || strtab_shndx > this->elf_file_.shnum()
      || this->elf_file_.section_type(strtab_shndx) != elfcpp::SHT_STRTAB)
    return false;

  if (p_inputs_shndx != NULL)
    *p_inputs_shndx = inputs_shndx;
  if (p_symtab_shndx != NULL)
    *p_symtab_shndx = symtab_shndx;
  if (p_relocs_shndx != NULL)
    *p_relocs_shndx = relocs_shndx;
  if (p_got_plt_shndx != NULL)
    *p_got_plt_shndx = got_plt_shndx;
  if (p_strtab_shndx != NULL)
    *p_strtab_shndx = strtab_shndx;
  return true;
}

// Set up the readers into the incremental info sections.

template<int size, bool big_endian>
void
Sized_incremental_binary<size, big_endian>::setup_readers()
{
  unsigned int inputs_shndx;
  unsigned int symtab_shndx;
  unsigned int relocs_shndx;
  unsigned int got_plt_shndx;
  unsigned int strtab_shndx;

  if (!this->find_incremental_inputs_sections(&inputs_shndx, &symtab_shndx,
					      &relocs_shndx, &got_plt_shndx,
					      &strtab_shndx))
    return;

  Location inputs_location(this->elf_file_.section_contents(inputs_shndx));
  Location symtab_location(this->elf_file_.section_contents(symtab_shndx));
  Location relocs_location(this->elf_file_.section_contents(relocs_shndx));
  Location got_plt_location(this->elf_file_.section_contents(got_plt_shndx));
  Location strtab_location(this->elf_file_.section_contents(strtab_shndx));

  View inputs_view = this->view(inputs_location);
  View symtab_view = this->view(symtab_location);
  View relocs_view = this->view(relocs_location);
  View got_plt_view = this->view(got_plt_location);
  View strtab_view = this->view(strtab_location);

  elfcpp::Elf_strtab strtab(strtab_view.data(), strtab_location.data_size);

  this->inputs_reader_ =
      Incremental_inputs_reader<size, big_endian>(inputs_view.data(), strtab);
  this->symtab_reader_ =
      Incremental_symtab_reader<big_endian>(symtab_view.data(),
					    symtab_location.data_size);
  this->relocs_reader_ =
      Incremental_relocs_reader<size, big_endian>(relocs_view.data(),
						  relocs_location.data_size);
  this->got_plt_reader_ =
      Incremental_got_plt_reader<big_endian>(got_plt_view.data());

  // Find the main symbol table.
  unsigned int main_symtab_shndx =
      this->elf_file_.find_section_by_type(elfcpp::SHT_SYMTAB);
  gold_assert(main_symtab_shndx != elfcpp::SHN_UNDEF);
  this->main_symtab_loc_ = this->elf_file_.section_contents(main_symtab_shndx);

  // Find the main symbol string table.
  unsigned int main_strtab_shndx =
      this->elf_file_.section_link(main_symtab_shndx);
  gold_assert(main_strtab_shndx != elfcpp::SHN_UNDEF
	      && main_strtab_shndx < this->elf_file_.shnum());
  this->main_strtab_loc_ = this->elf_file_.section_contents(main_strtab_shndx);

  // Walk the list of input files (a) to setup an Input_reader for each
  // input file, and (b) to record maps of files added from archive
  // libraries and scripts.
  Incremental_inputs_reader<size, big_endian>& inputs = this->inputs_reader_;
  unsigned int count = inputs.input_file_count();
  this->input_objects_.resize(count);
  this->input_entry_readers_.reserve(count);
  this->library_map_.resize(count);
  this->script_map_.resize(count);
  for (unsigned int i = 0; i < count; i++)
    {
      Input_entry_reader input_file = inputs.input_file(i);
      this->input_entry_readers_.push_back(Sized_input_reader(input_file));
      switch (input_file.type())
	{
	case INCREMENTAL_INPUT_OBJECT:
	case INCREMENTAL_INPUT_ARCHIVE_MEMBER:
	case INCREMENTAL_INPUT_SHARED_LIBRARY:
	  // No special treatment necessary.
	  break;
	case INCREMENTAL_INPUT_ARCHIVE:
	  {
	    Incremental_library* lib =
		new Incremental_library(input_file.filename(), i,
					&this->input_entry_readers_[i]);
	    this->library_map_[i] = lib;
	    unsigned int member_count = input_file.get_member_count();
	    for (unsigned int j = 0; j < member_count; j++)
	      {
		int member_offset = input_file.get_member_offset(j);
		int member_index = inputs.input_file_index(member_offset);
		this->library_map_[member_index] = lib;
	      }
	  }
	  break;
	case INCREMENTAL_INPUT_SCRIPT:
	  {
	    Script_info* script = new Script_info(input_file.filename(), i);
	    this->script_map_[i] = script;
	    unsigned int object_count = input_file.get_object_count();
	    for (unsigned int j = 0; j < object_count; j++)
	      {
		int object_offset = input_file.get_object_offset(j);
		int object_index = inputs.input_file_index(object_offset);
		this->script_map_[object_index] = script;
	      }
	  }
	  break;
	default:
	  gold_unreachable();
	}
    }

  // Initialize the map of global symbols.
  unsigned int nglobals = this->symtab_reader_.symbol_count();
  this->symbol_map_.resize(nglobals);

  this->has_incremental_info_ = true;
}

// Walk the list of input files given on the command line, and build
// a direct map of file index to the corresponding input argument.

void
check_input_args(std::vector<const Input_argument*>& input_args_map,
		 Input_arguments::const_iterator begin,
		 Input_arguments::const_iterator end)
{
  for (Input_arguments::const_iterator p = begin;
       p != end;
       ++p)
    {
      if (p->is_group())
	{
	  const Input_file_group* group = p->group();
	  check_input_args(input_args_map, group->begin(), group->end());
	}
      else if (p->is_lib())
	{
	  const Input_file_lib* lib = p->lib();
	  check_input_args(input_args_map, lib->begin(), lib->end());
	}
      else
	{
	  gold_assert(p->is_file());
	  unsigned int arg_serial = p->file().arg_serial();
	  if (arg_serial > 0)
	    {
	      gold_assert(arg_serial <= input_args_map.size());
	      gold_assert(input_args_map[arg_serial - 1] == 0);
	      input_args_map[arg_serial - 1] = &*p;
	    }
	}
    }
}

// Determine whether an incremental link based on the existing output file
// can be done.

template<int size, bool big_endian>
bool
Sized_incremental_binary<size, big_endian>::do_check_inputs(
    const Command_line& cmdline,
    Incremental_inputs* incremental_inputs)
{
  Incremental_inputs_reader<size, big_endian>& inputs = this->inputs_reader_;

  if (!this->has_incremental_info_)
    {
      explain_no_incremental(_("no incremental data from previous build"));
      return false;
    }

  if (inputs.version() != INCREMENTAL_LINK_VERSION)
    {
      explain_no_incremental(_("different version of incremental build data"));
      return false;
    }

  if (incremental_inputs->command_line() != inputs.command_line())
    {
      gold_debug(DEBUG_INCREMENTAL,
		 "old command line: %s",
		 inputs.command_line());
      gold_debug(DEBUG_INCREMENTAL,
		 "new command line: %s",
		 incremental_inputs->command_line().c_str());
      explain_no_incremental(_("command line changed"));
      return false;
    }

  // Walk the list of input files given on the command line, and build
  // a direct map of argument serial numbers to the corresponding input
  // arguments.
  this->input_args_map_.resize(cmdline.number_of_input_files());
  check_input_args(this->input_args_map_, cmdline.begin(), cmdline.end());

  // Walk the list of input files to check for conditions that prevent
  // an incremental update link.
  unsigned int count = inputs.input_file_count();
  for (unsigned int i = 0; i < count; i++)
    {
      Input_entry_reader input_file = inputs.input_file(i);
      switch (input_file.type())
	{
	case INCREMENTAL_INPUT_OBJECT:
	case INCREMENTAL_INPUT_ARCHIVE_MEMBER:
	case INCREMENTAL_INPUT_SHARED_LIBRARY:
	case INCREMENTAL_INPUT_ARCHIVE:
	  // No special treatment necessary.
	  break;
	case INCREMENTAL_INPUT_SCRIPT:
	  if (this->do_file_has_changed(i))
	    {
	      explain_no_incremental(_("%s: script file changed"),
				     input_file.filename());
	      return false;
	    }
	  break;
	default:
	  gold_unreachable();
	}
    }

  return true;
}

// Return TRUE if input file N has changed since the last incremental link.

template<int size, bool big_endian>
bool
Sized_incremental_binary<size, big_endian>::do_file_has_changed(
    unsigned int n) const
{
  Input_entry_reader input_file = this->inputs_reader_.input_file(n);
  Incremental_disposition disp = INCREMENTAL_CHECK;

  // For files named in scripts, find the file that was actually named
  // on the command line, so that we can get the incremental disposition
  // flag.
  Script_info* script = this->get_script_info(n);
  if (script != NULL)
    n = script->input_file_index();

  const Input_argument* input_argument = this->get_input_argument(n);
  if (input_argument != NULL)
    disp = input_argument->file().options().incremental_disposition();

  // For files at the beginning of the command line (i.e., those added
  // implicitly by gcc), check whether the --incremental-startup-unchanged
  // option was used.
  if (disp == INCREMENTAL_STARTUP)
    disp = parameters->options().incremental_startup_disposition();

  if (disp != INCREMENTAL_CHECK)
    return disp == INCREMENTAL_CHANGED;

  const char* filename = input_file.filename();
  Timespec old_mtime = input_file.get_mtime();
  Timespec new_mtime;
  if (!get_mtime(filename, &new_mtime))
    {
      // If we can't open get the current modification time, assume it has
      // changed.  If the file doesn't exist, we'll issue an error when we
      // try to open it later.
      return true;
    }

  if (new_mtime.seconds > old_mtime.seconds)
    return true;
  if (new_mtime.seconds == old_mtime.seconds
      && new_mtime.nanoseconds > old_mtime.nanoseconds)
    return true;
  return false;
}

// Initialize the layout of the output file based on the existing
// output file.

template<int size, bool big_endian>
void
Sized_incremental_binary<size, big_endian>::do_init_layout(Layout* layout)
{
  typedef elfcpp::Shdr<size, big_endian> Shdr;
  const int shdr_size = elfcpp::Elf_sizes<size>::shdr_size;

  // Get views of the section headers and the section string table.
  const off_t shoff = this->elf_file_.shoff();
  const unsigned int shnum = this->elf_file_.shnum();
  const unsigned int shstrndx = this->elf_file_.shstrndx();
  Location shdrs_location(shoff, shnum * shdr_size);
  Location shstrndx_location(this->elf_file_.section_contents(shstrndx));
  View shdrs_view = this->view(shdrs_location);
  View shstrndx_view = this->view(shstrndx_location);
  elfcpp::Elf_strtab shstrtab(shstrndx_view.data(),
			      shstrndx_location.data_size);

  layout->set_incremental_base(this);

  // Initialize the layout.
  this->section_map_.resize(shnum);
  const unsigned char* pshdr = shdrs_view.data() + shdr_size;
  for (unsigned int i = 1; i < shnum; i++)
    {
      Shdr shdr(pshdr);
      const char* name;
      if (!shstrtab.get_c_string(shdr.get_sh_name(), &name))
	name = NULL;
      gold_debug(DEBUG_INCREMENTAL,
		 "Output section: %2d %08lx %08lx %08lx %3d %s",
		 i,
		 static_cast<long>(shdr.get_sh_addr()),
		 static_cast<long>(shdr.get_sh_offset()),
		 static_cast<long>(shdr.get_sh_size()),
		 shdr.get_sh_type(), name ? name : "<null>");
      this->section_map_[i] = layout->init_fixed_output_section(name, shdr);
      pshdr += shdr_size;
    }
}

// Mark regions of the input file that must be kept unchanged.

template<int size, bool big_endian>
void
Sized_incremental_binary<size, big_endian>::do_reserve_layout(
    unsigned int input_file_index)
{
  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;

  Input_entry_reader input_file =
      this->inputs_reader_.input_file(input_file_index);

  if (input_file.type() == INCREMENTAL_INPUT_SHARED_LIBRARY)
    {
      // Reserve the BSS space used for COPY relocations.
      unsigned int nsyms = input_file.get_global_symbol_count();
      Incremental_binary::View symtab_view(NULL);
      unsigned int symtab_count;
      elfcpp::Elf_strtab strtab(NULL, 0);
      this->get_symtab_view(&symtab_view, &symtab_count, &strtab);
      for (unsigned int i = 0; i < nsyms; ++i)
	{
	  bool is_def;
	  bool is_copy;
	  unsigned int output_symndx =
	      input_file.get_output_symbol_index(i, &is_def, &is_copy);
	  if (is_copy)
	    {
	      const unsigned char* sym_p = (symtab_view.data()
					    + output_symndx * sym_size);
	      elfcpp::Sym<size, big_endian> gsym(sym_p);
	      unsigned int shndx = gsym.get_st_shndx();
	      if (shndx < 1 || shndx >= this->section_map_.size())
		continue;
	      Output_section* os = this->section_map_[shndx];
	      off_t offset = gsym.get_st_value() - os->address();
	      os->reserve(offset, gsym.get_st_size());
	      gold_debug(DEBUG_INCREMENTAL,
			 "Reserve for COPY reloc: %s, off %d, size %d",
			 os->name(),
			 static_cast<int>(offset),
			 static_cast<int>(gsym.get_st_size()));
	    }
	}
      return;
    }

  unsigned int shnum = input_file.get_input_section_count();
  for (unsigned int i = 0; i < shnum; i++)
    {
      typename Input_entry_reader::Input_section_info sect =
	  input_file.get_input_section(i);
      if (sect.output_shndx == 0 || sect.sh_offset == -1)
	continue;
      Output_section* os = this->section_map_[sect.output_shndx];
      gold_assert(os != NULL);
      os->reserve(sect.sh_offset, sect.sh_size);
    }
}

// Process the GOT and PLT entries from the existing output file.

template<int size, bool big_endian>
void
Sized_incremental_binary<size, big_endian>::do_process_got_plt(
    Symbol_table* symtab,
    Layout* layout)
{
  Incremental_got_plt_reader<big_endian> got_plt_reader(this->got_plt_reader());
  Sized_target<size, big_endian>* target =
      parameters->sized_target<size, big_endian>();

  // Get the number of symbols in the main symbol table and in the
  // incremental symbol table.  The difference between the two counts
  // is the index of the first forced-local or global symbol in the
  // main symbol table.
  unsigned int symtab_count =
      this->main_symtab_loc_.data_size / elfcpp::Elf_sizes<size>::sym_size;
  unsigned int isym_count = this->symtab_reader_.symbol_count();
  unsigned int first_global = symtab_count - isym_count;

  // Tell the target how big the GOT and PLT sections are.
  unsigned int got_count = got_plt_reader.get_got_entry_count();
  unsigned int plt_count = got_plt_reader.get_plt_entry_count();
  Output_data_got_base* got =
      target->init_got_plt_for_update(symtab, layout, got_count, plt_count);

  // Read the GOT entries from the base file and build the outgoing GOT.
  for (unsigned int i = 0; i < got_count; ++i)
    {
      unsigned int got_type = got_plt_reader.get_got_type(i);
      if ((got_type & 0x7f) == 0x7f)
	{
	  // This is the second entry of a pair.
	  got->reserve_slot(i);
	  continue;
	}
      unsigned int symndx = got_plt_reader.get_got_symndx(i);
      if (got_type & 0x80)
	{
	  // This is an entry for a local symbol.  Ignore this entry if
	  // the object file was replaced.
	  unsigned int input_index = got_plt_reader.get_got_input_index(i);
	  gold_debug(DEBUG_INCREMENTAL,
		     "GOT entry %d, type %02x: (local symbol)",
		     i, got_type & 0x7f);
	  Sized_relobj_incr<size, big_endian>* obj =
	      this->input_object(input_index);
	  if (obj != NULL)
	    target->reserve_local_got_entry(i, obj, symndx, got_type & 0x7f);
	}
      else
	{
	  // This is an entry for a global symbol.  GOT_DESC is the symbol
	  // table index.
	  // FIXME: This should really be a fatal error (corrupt input).
	  gold_assert(symndx >= first_global && symndx < symtab_count);
	  Symbol* sym = this->global_symbol(symndx - first_global);
	  // Add the GOT entry only if the symbol is still referenced.
	  if (sym != NULL && sym->in_reg())
	    {
	      gold_debug(DEBUG_INCREMENTAL,
			 "GOT entry %d, type %02x: %s",
			 i, got_type, sym->name());
	      target->reserve_global_got_entry(i, sym, got_type);
	    }
	}
    }

  // Read the PLT entries from the base file and pass each to the target.
  for (unsigned int i = 0; i < plt_count; ++i)
    {
      unsigned int plt_desc = got_plt_reader.get_plt_desc(i);
      // FIXME: This should really be a fatal error (corrupt input).
      gold_assert(plt_desc >= first_global && plt_desc < symtab_count);
      Symbol* sym = this->global_symbol(plt_desc - first_global);
      // Add the PLT entry only if the symbol is still referenced.
      if (sym != NULL && sym->in_reg())
	{
	  gold_debug(DEBUG_INCREMENTAL,
		     "PLT entry %d: %s",
		     i, sym->name());
	  target->register_global_plt_entry(symtab, layout, i, sym);
	}
    }
}

// Emit COPY relocations from the existing output file.

template<int size, bool big_endian>
void
Sized_incremental_binary<size, big_endian>::do_emit_copy_relocs(
    Symbol_table* symtab)
{
  Sized_target<size, big_endian>* target =
      parameters->sized_target<size, big_endian>();

  for (typename Copy_relocs::iterator p = this->copy_relocs_.begin();
       p != this->copy_relocs_.end();
       ++p)
    {
      if (!(*p).symbol->is_copied_from_dynobj())
	target->emit_copy_reloc(symtab, (*p).symbol, (*p).output_section,
				(*p).offset);
    }
}

// Apply incremental relocations for symbols whose values have changed.

template<int size, bool big_endian>
void
Sized_incremental_binary<size, big_endian>::do_apply_incremental_relocs(
    const Symbol_table* symtab,
    Layout* layout,
    Output_file* of)
{
  typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
  typedef typename elfcpp::Elf_types<size>::Elf_Swxword Addend;
  Incremental_symtab_reader<big_endian> isymtab(this->symtab_reader());
  Incremental_relocs_reader<size, big_endian> irelocs(this->relocs_reader());
  unsigned int nglobals = isymtab.symbol_count();
  const unsigned int incr_reloc_size = irelocs.reloc_size;

  Relocate_info<size, big_endian> relinfo;
  relinfo.symtab = symtab;
  relinfo.layout = layout;
  relinfo.object = NULL;
  relinfo.reloc_shndx = 0;
  relinfo.reloc_shdr = NULL;
  relinfo.data_shndx = 0;
  relinfo.data_shdr = NULL;

  Sized_target<size, big_endian>* target =
      parameters->sized_target<size, big_endian>();

  for (unsigned int i = 0; i < nglobals; i++)
    {
      const Symbol* gsym = this->global_symbol(i);

      // If the symbol is not referenced from any unchanged input files,
      // we do not need to reapply any of its relocations.
      if (gsym == NULL)
	continue;

      // If the symbol is defined in an unchanged file, we do not need to
      // reapply any of its relocations.
      if (gsym->source() == Symbol::FROM_OBJECT
	  && gsym->object()->is_incremental())
	continue;

      gold_debug(DEBUG_INCREMENTAL,
		 "Applying incremental relocations for global symbol %s [%d]",
		 gsym->name(), i);

      // Follow the linked list of input symbol table entries for this symbol.
      // We don't bother to figure out whether the symbol table entry belongs
      // to a changed or unchanged file because it's easier just to apply all
      // the relocations -- although we might scribble over an area that has
      // been reallocated, we do this before copying any new data into the
      // output file.
      unsigned int offset = isymtab.get_list_head(i);
      while (offset > 0)
	{
	  Incremental_global_symbol_reader<big_endian> sym_info =
	      this->inputs_reader().global_symbol_reader_at_offset(offset);
	  unsigned int r_base = sym_info.reloc_offset();
	  unsigned int r_count = sym_info.reloc_count();

	  // Apply each relocation for this symbol table entry.
	  for (unsigned int j = 0; j < r_count;
	       ++j, r_base += incr_reloc_size)
	    {
	      unsigned int r_type = irelocs.get_r_type(r_base);
	      unsigned int r_shndx = irelocs.get_r_shndx(r_base);
	      Address r_offset = irelocs.get_r_offset(r_base);
	      Addend r_addend = irelocs.get_r_addend(r_base);
	      Output_section* os = this->output_section(r_shndx);
	      Address address = os->address();
	      off_t section_offset = os->offset();
	      size_t view_size = os->data_size();
	      unsigned char* const view = of->get_output_view(section_offset,
							      view_size);

	      gold_debug(DEBUG_INCREMENTAL,
			 "  %08lx: %s + %d: type %d addend %ld",
			 (long)(section_offset + r_offset),
			 os->name(),
			 (int)r_offset,
			 r_type,
			 (long)r_addend);

	      target->apply_relocation(&relinfo, r_offset, r_type, r_addend,
				       gsym, view, address, view_size);

	      // FIXME: Do something more efficient if write_output_view
	      // ever becomes more than a no-op.
	      of->write_output_view(section_offset, view_size, view);
	    }
	  offset = sym_info.next_offset();
	}
    }
}

// Get a view of the main symbol table and the symbol string table.

template<int size, bool big_endian>
void
Sized_incremental_binary<size, big_endian>::get_symtab_view(
    View* symtab_view,
    unsigned int* nsyms,
    elfcpp::Elf_strtab* strtab)
{
  *symtab_view = this->view(this->main_symtab_loc_);
  *nsyms = this->main_symtab_loc_.data_size / elfcpp::Elf_sizes<size>::sym_size;

  View strtab_view(this->view(this->main_strtab_loc_));
  *strtab = elfcpp::Elf_strtab(strtab_view.data(),
			       this->main_strtab_loc_.data_size);
}

namespace
{

// Create a Sized_incremental_binary object of the specified size and
// endianness. Fails if the target architecture is not supported.

template<int size, bool big_endian>
Incremental_binary*
make_sized_incremental_binary(Output_file* file,
			      const elfcpp::Ehdr<size, big_endian>& ehdr)
{
  Target* target = select_target(NULL, 0, // XXX
				 ehdr.get_e_machine(), size, big_endian,
				 ehdr.get_e_ident()[elfcpp::EI_OSABI],
				 ehdr.get_e_ident()[elfcpp::EI_ABIVERSION]);
  if (target == NULL)
    {
      explain_no_incremental(_("unsupported ELF machine number %d"),
	       ehdr.get_e_machine());
      return NULL;
    }

  if (!parameters->target_valid())
    set_parameters_target(target);
  else if (target != &parameters->target())
    gold_error(_("%s: incompatible target"), file->filename());

  return new Sized_incremental_binary<size, big_endian>(file, ehdr, target);
}

}  // End of anonymous namespace.

// Create an Incremental_binary object for FILE.  Returns NULL is this is not
// possible, e.g. FILE is not an ELF file or has an unsupported target.  FILE
// should be opened.

Incremental_binary*
open_incremental_binary(Output_file* file)
{
  off_t filesize = file->filesize();
  int want = elfcpp::Elf_recognizer::max_header_size;
  if (filesize < want)
    want = filesize;

  const unsigned char* p = file->get_input_view(0, want);
  if (!elfcpp::Elf_recognizer::is_elf_file(p, want))
    {
      explain_no_incremental(_("output is not an ELF file."));
      return NULL;
    }

  int size = 0;
  bool big_endian = false;
  std::string error;
  if (!elfcpp::Elf_recognizer::is_valid_header(p, want, &size, &big_endian,
					       &error))
    {
      explain_no_incremental(error.c_str());
      return NULL;
    }

  Incremental_binary* result = NULL;
  if (size == 32)
    {
      if (big_endian)
	{
#ifdef HAVE_TARGET_32_BIG
	  result = make_sized_incremental_binary<32, true>(
	      file, elfcpp::Ehdr<32, true>(p));
#else
	  explain_no_incremental(_("unsupported file: 32-bit, big-endian"));
#endif
	}
      else
	{
#ifdef HAVE_TARGET_32_LITTLE
	  result = make_sized_incremental_binary<32, false>(
	      file, elfcpp::Ehdr<32, false>(p));
#else
	  explain_no_incremental(_("unsupported file: 32-bit, little-endian"));
#endif
	}
    }
  else if (size == 64)
    {
      if (big_endian)
	{
#ifdef HAVE_TARGET_64_BIG
	  result = make_sized_incremental_binary<64, true>(
	      file, elfcpp::Ehdr<64, true>(p));
#else
	  explain_no_incremental(_("unsupported file: 64-bit, big-endian"));
#endif
	}
      else
	{
#ifdef HAVE_TARGET_64_LITTLE
	  result = make_sized_incremental_binary<64, false>(
	      file, elfcpp::Ehdr<64, false>(p));
#else
	  explain_no_incremental(_("unsupported file: 64-bit, little-endian"));
#endif
	}
    }
  else
    gold_unreachable();

  return result;
}

// Class Incremental_inputs.

// Add the command line to the string table, setting
// command_line_key_.  In incremental builds, the command line is
// stored in .gnu_incremental_inputs so that the next linker run can
// check if the command line options didn't change.

void
Incremental_inputs::report_command_line(int argc, const char* const* argv)
{
  // Always store 'gold' as argv[0] to avoid a full relink if the user used a
  // different path to the linker.
  std::string args("gold");
  // Copied from collect_argv in main.cc.
  for (int i = 1; i < argc; ++i)
    {
      // Adding/removing these options should not result in a full relink.
      if (strcmp(argv[i], "--incremental") == 0
	  || strcmp(argv[i], "--incremental-full") == 0
	  || strcmp(argv[i], "--incremental-update") == 0
	  || strcmp(argv[i], "--incremental-changed") == 0
	  || strcmp(argv[i], "--incremental-unchanged") == 0
	  || strcmp(argv[i], "--incremental-unknown") == 0
	  || strcmp(argv[i], "--incremental-startup-unchanged") == 0
	  || is_prefix_of("--incremental-base=", argv[i])
	  || is_prefix_of("--incremental-patch=", argv[i])
	  || is_prefix_of("--debug=", argv[i]))
	continue;
      if (strcmp(argv[i], "--incremental-base") == 0
	  || strcmp(argv[i], "--incremental-patch") == 0
	  || strcmp(argv[i], "--debug") == 0)
	{
	  // When these options are used without the '=', skip the
	  // following parameter as well.
	  ++i;
	  continue;
	}

      args.append(" '");
      // Now append argv[i], but with all single-quotes escaped
      const char* argpos = argv[i];
      while (1)
	{
	  const int len = strcspn(argpos, "'");
	  args.append(argpos, len);
	  if (argpos[len] == '\0')
	    break;
	  args.append("'\"'\"'");
	  argpos += len + 1;
	}
      args.append("'");
    }

  this->command_line_ = args;
  this->strtab_->add(this->command_line_.c_str(), false,
		     &this->command_line_key_);
}

// Record the input archive file ARCHIVE.  This is called by the
// Add_archive_symbols task before determining which archive members
// to include.  We create the Incremental_archive_entry here and
// attach it to the Archive, but we do not add it to the list of
// input objects until report_archive_end is called.

void
Incremental_inputs::report_archive_begin(Library_base* arch,
					 unsigned int arg_serial,
					 Script_info* script_info)
{
  Stringpool::Key filename_key;
  Timespec mtime = arch->get_mtime();

  // For a file loaded from a script, don't record its argument serial number.
  if (script_info != NULL)
    arg_serial = 0;

  this->strtab_->add(arch->filename().c_str(), false, &filename_key);
  Incremental_archive_entry* entry =
      new Incremental_archive_entry(filename_key, arg_serial, mtime);
  arch->set_incremental_info(entry);

  if (script_info != NULL)
    {
      Incremental_script_entry* script_entry = script_info->incremental_info();
      gold_assert(script_entry != NULL);
      script_entry->add_object(entry);
    }
}

// Visitor class for processing the unused global symbols in a library.
// An instance of this class is passed to the library's
// for_all_unused_symbols() iterator, which will call the visit()
// function for each global symbol defined in each unused library
// member.  We add those symbol names to the incremental info for the
// library.

class Unused_symbol_visitor : public Library_base::Symbol_visitor_base
{
 public:
  Unused_symbol_visitor(Incremental_archive_entry* entry, Stringpool* strtab)
    : entry_(entry), strtab_(strtab)
  { }

  void
  visit(const char* sym)
  {
    Stringpool::Key symbol_key;
    this->strtab_->add(sym, true, &symbol_key);
    this->entry_->add_unused_global_symbol(symbol_key);
  }

 private:
  Incremental_archive_entry* entry_;
  Stringpool* strtab_;
};

// Finish recording the input archive file ARCHIVE.  This is called by the
// Add_archive_symbols task after determining which archive members
// to include.

void
Incremental_inputs::report_archive_end(Library_base* arch)
{
  Incremental_archive_entry* entry = arch->incremental_info();

  gold_assert(entry != NULL);
  this->inputs_.push_back(entry);

  // Collect unused global symbols.
  Unused_symbol_visitor v(entry, this->strtab_);
  arch->for_all_unused_symbols(&v);
}

// Record the input object file OBJ.  If ARCH is not NULL, attach
// the object file to the archive.  This is called by the
// Add_symbols task after finding out the type of the file.

void
Incremental_inputs::report_object(Object* obj, unsigned int arg_serial,
				  Library_base* arch, Script_info* script_info)
{
  Stringpool::Key filename_key;
  Timespec mtime = obj->get_mtime();

  // For a file loaded from a script, don't record its argument serial number.
  if (script_info != NULL)
    arg_serial = 0;

  this->strtab_->add(obj->name().c_str(), false, &filename_key);

  Incremental_input_entry* input_entry;

  this->current_object_ = obj;

  if (!obj->is_dynamic())
    {
      this->current_object_entry_ =
	  new Incremental_object_entry(filename_key, obj, arg_serial, mtime);
      input_entry = this->current_object_entry_;
      if (arch != NULL)
	{
	  Incremental_archive_entry* arch_entry = arch->incremental_info();
	  gold_assert(arch_entry != NULL);
	  arch_entry->add_object(this->current_object_entry_);
	}
    }
  else
    {
      this->current_object_entry_ = NULL;
      Stringpool::Key soname_key;
      Dynobj* dynobj = obj->dynobj();
      gold_assert(dynobj != NULL);
      this->strtab_->add(dynobj->soname(), false, &soname_key);
      input_entry = new Incremental_dynobj_entry(filename_key, soname_key, obj,
						 arg_serial, mtime);
    }

  if (obj->is_in_system_directory())
    input_entry->set_is_in_system_directory();

  if (obj->as_needed())
    input_entry->set_as_needed();

  this->inputs_.push_back(input_entry);

  if (script_info != NULL)
    {
      Incremental_script_entry* script_entry = script_info->incremental_info();
      gold_assert(script_entry != NULL);
      script_entry->add_object(input_entry);
    }
}

// Record an input section SHNDX from object file OBJ.

void
Incremental_inputs::report_input_section(Object* obj, unsigned int shndx,
					 const char* name, off_t sh_size)
{
  Stringpool::Key key = 0;

  if (name != NULL)
    this->strtab_->add(name, true, &key);

  gold_assert(obj == this->current_object_);
  gold_assert(this->current_object_entry_ != NULL);
  this->current_object_entry_->add_input_section(shndx, key, sh_size);
}

// Record a kept COMDAT group belonging to object file OBJ.

void
Incremental_inputs::report_comdat_group(Object* obj, const char* name)
{
  Stringpool::Key key = 0;

  if (name != NULL)
    this->strtab_->add(name, true, &key);
  gold_assert(obj == this->current_object_);
  gold_assert(this->current_object_entry_ != NULL);
  this->current_object_entry_->add_comdat_group(key);
}

// Record that the input argument INPUT is a script SCRIPT.  This is
// called by read_script after parsing the script and reading the list
// of inputs added by this script.

void
Incremental_inputs::report_script(Script_info* script,
				  unsigned int arg_serial,
				  Timespec mtime)
{
  Stringpool::Key filename_key;

  this->strtab_->add(script->filename().c_str(), false, &filename_key);
  Incremental_script_entry* entry =
      new Incremental_script_entry(filename_key, arg_serial, script, mtime);
  this->inputs_.push_back(entry);
  script->set_incremental_info(entry);
}

// Finalize the incremental link information.  Called from
// Layout::finalize.

void
Incremental_inputs::finalize()
{
  // Finalize the string table.
  this->strtab_->set_string_offsets();
}

// Create the .gnu_incremental_inputs, _symtab, and _relocs input sections.

void
Incremental_inputs::create_data_sections(Symbol_table* symtab)
{
  int reloc_align = 4;

  switch (parameters->size_and_endianness())
    {
#ifdef HAVE_TARGET_32_LITTLE
    case Parameters::TARGET_32_LITTLE:
      this->inputs_section_ =
	  new Output_section_incremental_inputs<32, false>(this, symtab);
      reloc_align = 4;
      break;
#endif
#ifdef HAVE_TARGET_32_BIG
    case Parameters::TARGET_32_BIG:
      this->inputs_section_ =
	  new Output_section_incremental_inputs<32, true>(this, symtab);
      reloc_align = 4;
      break;
#endif
#ifdef HAVE_TARGET_64_LITTLE
    case Parameters::TARGET_64_LITTLE:
      this->inputs_section_ =
	  new Output_section_incremental_inputs<64, false>(this, symtab);
      reloc_align = 8;
      break;
#endif
#ifdef HAVE_TARGET_64_BIG
    case Parameters::TARGET_64_BIG:
      this->inputs_section_ =
	  new Output_section_incremental_inputs<64, true>(this, symtab);
      reloc_align = 8;
      break;
#endif
    default:
      gold_unreachable();
    }
  this->symtab_section_ = new Output_data_space(4, "** incremental_symtab");
  this->relocs_section_ = new Output_data_space(reloc_align,
						"** incremental_relocs");
  this->got_plt_section_ = new Output_data_space(4, "** incremental_got_plt");
}

// Return the sh_entsize value for the .gnu_incremental_relocs section.
unsigned int
Incremental_inputs::relocs_entsize() const
{
  return 8 + 2 * parameters->target().get_size() / 8;
}

// Class Output_section_incremental_inputs.

// Finalize the offsets for each input section and supplemental info block,
// and set the final data size of the incremental output sections.

template<int size, bool big_endian>
void
Output_section_incremental_inputs<size, big_endian>::set_final_data_size()
{
  const Incremental_inputs* inputs = this->inputs_;

  // Offset of each input entry.
  unsigned int input_offset = this->header_size;

  // Offset of each supplemental info block.
  unsigned int file_index = 0;
  unsigned int info_offset = this->header_size;
  info_offset += this->input_entry_size * inputs->input_file_count();

  // Count each input file and its supplemental information block.
  for (Incremental_inputs::Input_list::const_iterator p =
	   inputs->input_files().begin();
       p != inputs->input_files().end();
       ++p)
    {
      // Set the index and offset of the input file entry.
      (*p)->set_offset(file_index, input_offset);
      ++file_index;
      input_offset += this->input_entry_size;

      // Set the offset of the supplemental info block.
      switch ((*p)->type())
	{
	case INCREMENTAL_INPUT_SCRIPT:
	  {
	    Incremental_script_entry *entry = (*p)->script_entry();
	    gold_assert(entry != NULL);
	    (*p)->set_info_offset(info_offset);
	    // Object count.
	    info_offset += 4;
	    // Each member.
	    info_offset += (entry->get_object_count() * 4);
	  }
	  break;
	case INCREMENTAL_INPUT_OBJECT:
	case INCREMENTAL_INPUT_ARCHIVE_MEMBER:
	  {
	    Incremental_object_entry* entry = (*p)->object_entry();
	    gold_assert(entry != NULL);
	    (*p)->set_info_offset(info_offset);
	    // Input section count, global symbol count, local symbol offset,
	    // local symbol count, first dynamic reloc, dynamic reloc count,
	    // comdat group count.
	    info_offset += this->object_info_size;
	    // Each input section.
	    info_offset += (entry->get_input_section_count()
			    * this->input_section_entry_size);
	    // Each global symbol.
	    const Object::Symbols* syms = entry->object()->get_global_symbols();
	    info_offset += syms->size() * this->global_sym_entry_size;
	    // Each comdat group.
	    info_offset += entry->get_comdat_group_count() * 4;
	  }
	  break;
	case INCREMENTAL_INPUT_SHARED_LIBRARY:
	  {
	    Incremental_dynobj_entry* entry = (*p)->dynobj_entry();
	    gold_assert(entry != NULL);
	    (*p)->set_info_offset(info_offset);
	    // Global symbol count, soname index.
	    info_offset += 8;
	    // Each global symbol.
	    const Object::Symbols* syms = entry->object()->get_global_symbols();
	    gold_assert(syms != NULL);
	    unsigned int nsyms = syms->size();
	    unsigned int nsyms_out = 0;
	    for (unsigned int i = 0; i < nsyms; ++i)
	      {
		const Symbol* sym = (*syms)[i];
		if (sym == NULL)
		  continue;
		if (sym->is_forwarder())
		  sym = this->symtab_->resolve_forwards(sym);
		if (sym->symtab_index() != -1U)
		  ++nsyms_out;
	      }
	    info_offset += nsyms_out * 4;
	  }
	  break;
	case INCREMENTAL_INPUT_ARCHIVE:
	  {
	    Incremental_archive_entry* entry = (*p)->archive_entry();
	    gold_assert(entry != NULL);
	    (*p)->set_info_offset(info_offset);
	    // Member count + unused global symbol count.
	    info_offset += 8;
	    // Each member.
	    info_offset += (entry->get_member_count() * 4);
	    // Each global symbol.
	    info_offset += (entry->get_unused_global_symbol_count() * 4);
	  }
	  break;
	default:
	  gold_unreachable();
	}

     // Pad so each supplemental info block begins at an 8-byte boundary.
     if (info_offset & 4)
       info_offset += 4;
   }

  this->set_data_size(info_offset);

  // Set the size of the .gnu_incremental_symtab section.
  inputs->symtab_section()->set_current_data_size(this->symtab_->output_count()
						  * sizeof(unsigned int));

  // Set the size of the .gnu_incremental_relocs section.
  inputs->relocs_section()->set_current_data_size(inputs->get_reloc_count()
						  * this->incr_reloc_size);

  // Set the size of the .gnu_incremental_got_plt section.
  Sized_target<size, big_endian>* target =
    parameters->sized_target<size, big_endian>();
  unsigned int got_count = target->got_entry_count();
  unsigned int plt_count = target->plt_entry_count();
  unsigned int got_plt_size = 8;  // GOT entry count, PLT entry count.
  got_plt_size = (got_plt_size + got_count + 3) & ~3;  // GOT type array.
  got_plt_size += got_count * 8 + plt_count * 4;  // GOT array, PLT array.
  inputs->got_plt_section()->set_current_data_size(got_plt_size);
}

// Write the contents of the .gnu_incremental_inputs and
// .gnu_incremental_symtab sections.

template<int size, bool big_endian>
void
Output_section_incremental_inputs<size, big_endian>::do_write(Output_file* of)
{
  const Incremental_inputs* inputs = this->inputs_;
  Stringpool* strtab = inputs->get_stringpool();

  // Get a view into the .gnu_incremental_inputs section.
  const off_t off = this->offset();
  const off_t oview_size = this->data_size();
  unsigned char* const oview = of->get_output_view(off, oview_size);
  unsigned char* pov = oview;

  // Get a view into the .gnu_incremental_symtab section.
  const off_t symtab_off = inputs->symtab_section()->offset();
  const off_t symtab_size = inputs->symtab_section()->data_size();
  unsigned char* const symtab_view = of->get_output_view(symtab_off,
							 symtab_size);

  // Allocate an array of linked list heads for the .gnu_incremental_symtab
  // section.  Each element corresponds to a global symbol in the output
  // symbol table, and points to the head of the linked list that threads
  // through the object file input entries.  The value of each element
  // is the section-relative offset to a global symbol entry in a
  // supplemental information block.
  unsigned int global_sym_count = this->symtab_->output_count();
  unsigned int* global_syms = new unsigned int[global_sym_count];
  memset(global_syms, 0, global_sym_count * sizeof(unsigned int));

  // Write the section header.
  Stringpool::Key command_line_key = inputs->command_line_key();
  pov = this->write_header(pov, inputs->input_file_count(),
			   strtab->get_offset_from_key(command_line_key));

  // Write the list of input files.
  pov = this->write_input_files(oview, pov, strtab);

  // Write the supplemental information blocks for each input file.
  pov = this->write_info_blocks(oview, pov, strtab, global_syms,
				global_sym_count);

  gold_assert(pov - oview == oview_size);

  // Write the .gnu_incremental_symtab section.
  gold_assert(static_cast<off_t>(global_sym_count) * 4 == symtab_size);
  this->write_symtab(symtab_view, global_syms, global_sym_count);

  delete[] global_syms;

  // Write the .gnu_incremental_got_plt section.
  const off_t got_plt_off = inputs->got_plt_section()->offset();
  const off_t got_plt_size = inputs->got_plt_section()->data_size();
  unsigned char* const got_plt_view = of->get_output_view(got_plt_off,
							  got_plt_size);
  this->write_got_plt(got_plt_view, got_plt_size);

  of->write_output_view(off, oview_size, oview);
  of->write_output_view(symtab_off, symtab_size, symtab_view);
  of->write_output_view(got_plt_off, got_plt_size, got_plt_view);
}

// Write the section header: version, input file count, offset of command line
// in the string table, and 4 bytes of padding.

template<int size, bool big_endian>
unsigned char*
Output_section_incremental_inputs<size, big_endian>::write_header(
    unsigned char* pov,
    unsigned int input_file_count,
    section_offset_type command_line_offset)
{
  Swap32::writeval(pov, INCREMENTAL_LINK_VERSION);
  Swap32::writeval(pov + 4, input_file_count);
  Swap32::writeval(pov + 8, command_line_offset);
  Swap32::writeval(pov + 12, 0);
  gold_assert(this->header_size == 16);
  return pov + this->header_size;
}

// Write the input file entries.

template<int size, bool big_endian>
unsigned char*
Output_section_incremental_inputs<size, big_endian>::write_input_files(
    unsigned char* oview,
    unsigned char* pov,
    Stringpool* strtab)
{
  const Incremental_inputs* inputs = this->inputs_;

  for (Incremental_inputs::Input_list::const_iterator p =
	   inputs->input_files().begin();
       p != inputs->input_files().end();
       ++p)
    {
      gold_assert(static_cast<unsigned int>(pov - oview) == (*p)->get_offset());
      section_offset_type filename_offset =
	  strtab->get_offset_from_key((*p)->get_filename_key());
      const Timespec& mtime = (*p)->get_mtime();
      unsigned int flags = (*p)->type();
      if ((*p)->is_in_system_directory())
	flags |= INCREMENTAL_INPUT_IN_SYSTEM_DIR;
      if ((*p)->as_needed())
	flags |= INCREMENTAL_INPUT_AS_NEEDED;
      Swap32::writeval(pov, filename_offset);
      Swap32::writeval(pov + 4, (*p)->get_info_offset());
      Swap64::writeval(pov + 8, mtime.seconds);
      Swap32::writeval(pov + 16, mtime.nanoseconds);
      Swap16::writeval(pov + 20, flags);
      Swap16::writeval(pov + 22, (*p)->arg_serial());
      gold_assert(this->input_entry_size == 24);
      pov += this->input_entry_size;
    }
  return pov;
}

// Write the supplemental information blocks.

template<int size, bool big_endian>
unsigned char*
Output_section_incremental_inputs<size, big_endian>::write_info_blocks(
    unsigned char* oview,
    unsigned char* pov,
    Stringpool* strtab,
    unsigned int* global_syms,
    unsigned int global_sym_count)
{
  const Incremental_inputs* inputs = this->inputs_;
  unsigned int first_global_index = this->symtab_->first_global_index();

  for (Incremental_inputs::Input_list::const_iterator p =
	   inputs->input_files().begin();
       p != inputs->input_files().end();
       ++p)
    {
      switch ((*p)->type())
	{
	case INCREMENTAL_INPUT_SCRIPT:
	  {
	    gold_assert(static_cast<unsigned int>(pov - oview)
			== (*p)->get_info_offset());
	    Incremental_script_entry* entry = (*p)->script_entry();
	    gold_assert(entry != NULL);

	    // Write the object count.
	    unsigned int nobjects = entry->get_object_count();
	    Swap32::writeval(pov, nobjects);
	    pov += 4;

	    // For each object, write the offset to its input file entry.
	    for (unsigned int i = 0; i < nobjects; ++i)
	      {
		Incremental_input_entry* obj = entry->get_object(i);
		Swap32::writeval(pov, obj->get_offset());
		pov += 4;
	      }
	  }
	  break;

	case INCREMENTAL_INPUT_OBJECT:
	case INCREMENTAL_INPUT_ARCHIVE_MEMBER:
	  {
	    gold_assert(static_cast<unsigned int>(pov - oview)
			== (*p)->get_info_offset());
	    Incremental_object_entry* entry = (*p)->object_entry();
	    gold_assert(entry != NULL);
	    const Object* obj = entry->object();
	    const Relobj* relobj = static_cast<const Relobj*>(obj);
	    const Object::Symbols* syms = obj->get_global_symbols();
	    // Write the input section count and global symbol count.
	    unsigned int nsections = entry->get_input_section_count();
	    unsigned int nsyms = syms->size();
	    off_t locals_offset = relobj->local_symbol_offset();
	    unsigned int nlocals = relobj->output_local_symbol_count();
	    unsigned int first_dynrel = relobj->first_dyn_reloc();
	    unsigned int ndynrel = relobj->dyn_reloc_count();
	    unsigned int ncomdat = entry->get_comdat_group_count();
	    Swap32::writeval(pov, nsections);
	    Swap32::writeval(pov + 4, nsyms);
	    Swap32::writeval(pov + 8, static_cast<unsigned int>(locals_offset));
	    Swap32::writeval(pov + 12, nlocals);
	    Swap32::writeval(pov + 16, first_dynrel);
	    Swap32::writeval(pov + 20, ndynrel);
	    Swap32::writeval(pov + 24, ncomdat);
	    Swap32::writeval(pov + 28, 0);
	    gold_assert(this->object_info_size == 32);
	    pov += this->object_info_size;

	    // Build a temporary array to map input section indexes
	    // from the original object file index to the index in the
	    // incremental info table.
	    unsigned int* index_map = new unsigned int[obj->shnum()];
	    memset(index_map, 0, obj->shnum() * sizeof(unsigned int));

	    // For each input section, write the name, output section index,
	    // offset within output section, and input section size.
	    for (unsigned int i = 0; i < nsections; i++)
	      {
		unsigned int shndx = entry->get_input_section_index(i);
		index_map[shndx] = i + 1;
		Stringpool::Key key = entry->get_input_section_name_key(i);
		off_t name_offset = 0;
		if (key != 0)
		  name_offset = strtab->get_offset_from_key(key);
		int out_shndx = 0;
		off_t out_offset = 0;
		off_t sh_size = 0;
		Output_section* os = obj->output_section(shndx);
		if (os != NULL)
		  {
		    out_shndx = os->out_shndx();
		    out_offset = obj->output_section_offset(shndx);
		    sh_size = entry->get_input_section_size(i);
		  }
		Swap32::writeval(pov, name_offset);
		Swap32::writeval(pov + 4, out_shndx);
		Swap::writeval(pov + 8, out_offset);
		Swap::writeval(pov + 8 + sizeof_addr, sh_size);
		gold_assert(this->input_section_entry_size
			    == 8 + 2 * sizeof_addr);
		pov += this->input_section_entry_size;
	      }

	    // For each global symbol, write its associated relocations,
	    // add it to the linked list of globals, then write the
	    // supplemental information:  global symbol table index,
	    // input section index, linked list chain pointer, relocation
	    // count, and offset to the relocations.
	    for (unsigned int i = 0; i < nsyms; i++)
	      {
		const Symbol* sym = (*syms)[i];
		if (sym->is_forwarder())
		  sym = this->symtab_->resolve_forwards(sym);
		unsigned int shndx = 0;
		if (sym->source() != Symbol::FROM_OBJECT)
		  {
		    // The symbol was defined by the linker (e.g., common).
		    // We mark these symbols with a special SHNDX of -1,
		    // but exclude linker-predefined symbols and symbols
		    // copied from shared objects.
		    if (!sym->is_predefined()
			&& !sym->is_copied_from_dynobj())
		      shndx = -1U;
		  }
		else if (sym->object() == obj && sym->is_defined())
		  {
		    bool is_ordinary;
		    unsigned int orig_shndx = sym->shndx(&is_ordinary);
		    if (is_ordinary)
		      shndx = index_map[orig_shndx];
		    else
		      shndx = 1;
		  }
		unsigned int symtab_index = sym->symtab_index();
		unsigned int chain = 0;
		unsigned int first_reloc = 0;
		unsigned int nrelocs = obj->get_incremental_reloc_count(i);
		if (nrelocs > 0)
		  {
		    gold_assert(symtab_index != -1U
				&& (symtab_index - first_global_index
				    < global_sym_count));
		    first_reloc = obj->get_incremental_reloc_base(i);
		    chain = global_syms[symtab_index - first_global_index];
		    global_syms[symtab_index - first_global_index] =
			pov - oview;
		  }
		Swap32::writeval(pov, symtab_index);
		Swap32::writeval(pov + 4, shndx);
		Swap32::writeval(pov + 8, chain);
		Swap32::writeval(pov + 12, nrelocs);
		Swap32::writeval(pov + 16,
				 first_reloc * (8 + 2 * sizeof_addr));
		gold_assert(this->global_sym_entry_size == 20);
		pov += this->global_sym_entry_size;
	      }

	    // For each kept COMDAT group, write the group signature.
	    for (unsigned int i = 0; i < ncomdat; i++)
	      {
		Stringpool::Key key = entry->get_comdat_signature_key(i);
		off_t name_offset = 0;
		if (key != 0)
		  name_offset = strtab->get_offset_from_key(key);
		Swap32::writeval(pov, name_offset);
		pov += 4;
	      }

	    delete[] index_map;
	  }
	  break;

	case INCREMENTAL_INPUT_SHARED_LIBRARY:
	  {
	    gold_assert(static_cast<unsigned int>(pov - oview)
			== (*p)->get_info_offset());
	    Incremental_dynobj_entry* entry = (*p)->dynobj_entry();
	    gold_assert(entry != NULL);
	    Object* obj = entry->object();
	    Dynobj* dynobj = obj->dynobj();
	    gold_assert(dynobj != NULL);
	    const Object::Symbols* syms = obj->get_global_symbols();

	    // Write the soname string table index.
	    section_offset_type soname_offset =
		strtab->get_offset_from_key(entry->get_soname_key());
	    Swap32::writeval(pov, soname_offset);
	    pov += 4;

	    // Skip the global symbol count for now.
	    unsigned char* orig_pov = pov;
	    pov += 4;

	    // For each global symbol, write the global symbol table index.
	    unsigned int nsyms = syms->size();
	    unsigned int nsyms_out = 0;
	    for (unsigned int i = 0; i < nsyms; i++)
	      {
		const Symbol* sym = (*syms)[i];
		if (sym == NULL)
		  continue;
		if (sym->is_forwarder())
		  sym = this->symtab_->resolve_forwards(sym);
		if (sym->symtab_index() == -1U)
		  continue;
		unsigned int flags = 0;
		// If the symbol has hidden or internal visibility, we
		// mark it as defined in the shared object so we don't
		// try to resolve it during an incremental update.
		if (sym->visibility() == elfcpp::STV_HIDDEN
		    || sym->visibility() == elfcpp::STV_INTERNAL)
		  flags = INCREMENTAL_SHLIB_SYM_DEF;
		else if (sym->source() == Symbol::FROM_OBJECT
			 && sym->object() == obj
			 && sym->is_defined())
		  flags = INCREMENTAL_SHLIB_SYM_DEF;
		else if (sym->is_copied_from_dynobj()
			 && this->symtab_->get_copy_source(sym) == dynobj)
		  flags = INCREMENTAL_SHLIB_SYM_COPY;
		flags <<= INCREMENTAL_SHLIB_SYM_FLAGS_SHIFT;
		Swap32::writeval(pov, sym->symtab_index() | flags);
		pov += 4;
		++nsyms_out;
	      }

	    // Now write the global symbol count.
	    Swap32::writeval(orig_pov, nsyms_out);
	  }
	  break;

	case INCREMENTAL_INPUT_ARCHIVE:
	  {
	    gold_assert(static_cast<unsigned int>(pov - oview)
			== (*p)->get_info_offset());
	    Incremental_archive_entry* entry = (*p)->archive_entry();
	    gold_assert(entry != NULL);

	    // Write the member count and unused global symbol count.
	    unsigned int nmembers = entry->get_member_count();
	    unsigned int nsyms = entry->get_unused_global_symbol_count();
	    Swap32::writeval(pov, nmembers);
	    Swap32::writeval(pov + 4, nsyms);
	    pov += 8;

	    // For each member, write the offset to its input file entry.
	    for (unsigned int i = 0; i < nmembers; ++i)
	      {
		Incremental_object_entry* member = entry->get_member(i);
		Swap32::writeval(pov, member->get_offset());
		pov += 4;
	      }

	    // For each global symbol, write the name offset.
	    for (unsigned int i = 0; i < nsyms; ++i)
	      {
		Stringpool::Key key = entry->get_unused_global_symbol(i);
		Swap32::writeval(pov, strtab->get_offset_from_key(key));
		pov += 4;
	      }
	  }
	  break;

	default:
	  gold_unreachable();
	}

     // Pad the info block to a multiple of 8 bytes.
     if (static_cast<unsigned int>(pov - oview) & 4)
      {
	Swap32::writeval(pov, 0);
	pov += 4;
      }
    }
  return pov;
}

// Write the contents of the .gnu_incremental_symtab section.

template<int size, bool big_endian>
void
Output_section_incremental_inputs<size, big_endian>::write_symtab(
    unsigned char* pov,
    unsigned int* global_syms,
    unsigned int global_sym_count)
{
  for (unsigned int i = 0; i < global_sym_count; ++i)
    {
      Swap32::writeval(pov, global_syms[i]);
      pov += 4;
    }
}

// This struct holds the view information needed to write the
// .gnu_incremental_got_plt section.

struct Got_plt_view_info
{
  // Start of the GOT type array in the output view.
  unsigned char* got_type_p;
  // Start of the GOT descriptor array in the output view.
  unsigned char* got_desc_p;
  // Start of the PLT descriptor array in the output view.
  unsigned char* plt_desc_p;
  // Number of GOT entries.
  unsigned int got_count;
  // Number of PLT entries.
  unsigned int plt_count;
  // Offset of the first non-reserved PLT entry (this is a target-dependent value).
  unsigned int first_plt_entry_offset;
  // Size of a PLT entry (this is a target-dependent value).
  unsigned int plt_entry_size;
  // Symbol index to write in the GOT descriptor array.  For global symbols,
  // this is the global symbol table index; for local symbols, it is the
  // local symbol table index.
  unsigned int sym_index;
  // Input file index to write in the GOT descriptor array.  For global
  // symbols, this is 0; for local symbols, it is the index of the input
  // file entry in the .gnu_incremental_inputs section.
  unsigned int input_index;
};

// Functor class for processing a GOT offset list for local symbols.
// Writes the GOT type and symbol index into the GOT type and descriptor
// arrays in the output section.

template<int size, bool big_endian>
class Local_got_offset_visitor : public Got_offset_list::Visitor
{
 public:
  Local_got_offset_visitor(struct Got_plt_view_info& info)
    : info_(info)
  { }

  void
  visit(unsigned int got_type, unsigned int got_offset)
  {
    unsigned int got_index = got_offset / this->got_entry_size_;
    gold_assert(got_index < this->info_.got_count);
    // We can only handle GOT entry types in the range 0..0x7e
    // because we use a byte array to store them, and we use the
    // high bit to flag a local symbol.
    gold_assert(got_type < 0x7f);
    this->info_.got_type_p[got_index] = got_type | 0x80;
    unsigned char* pov = this->info_.got_desc_p + got_index * 8;
    elfcpp::Swap<32, big_endian>::writeval(pov, this->info_.sym_index);
    elfcpp::Swap<32, big_endian>::writeval(pov + 4, this->info_.input_index);
  }

 private:
  static const unsigned int got_entry_size_ = size / 8;
  struct Got_plt_view_info& info_;
};

// Functor class for processing a GOT offset list.  Writes the GOT type
// and symbol index into the GOT type and descriptor arrays in the output
// section.

template<int size, bool big_endian>
class Global_got_offset_visitor : public Got_offset_list::Visitor
{
 public:
  Global_got_offset_visitor(struct Got_plt_view_info& info)
    : info_(info)
  { }

  void
  visit(unsigned int got_type, unsigned int got_offset)
  {
    unsigned int got_index = got_offset / this->got_entry_size_;
    gold_assert(got_index < this->info_.got_count);
    // We can only handle GOT entry types in the range 0..0x7e
    // because we use a byte array to store them, and we use the
    // high bit to flag a local symbol.
    gold_assert(got_type < 0x7f);
    this->info_.got_type_p[got_index] = got_type;
    unsigned char* pov = this->info_.got_desc_p + got_index * 8;
    elfcpp::Swap<32, big_endian>::writeval(pov, this->info_.sym_index);
    elfcpp::Swap<32, big_endian>::writeval(pov + 4, 0);
  }

 private:
  static const unsigned int got_entry_size_ = size / 8;
  struct Got_plt_view_info& info_;
};

// Functor class for processing the global symbol table.  Processes the
// GOT offset list for the symbol, and writes the symbol table index
// into the PLT descriptor array in the output section.

template<int size, bool big_endian>
class Global_symbol_visitor_got_plt
{
 public:
  Global_symbol_visitor_got_plt(struct Got_plt_view_info& info)
    : info_(info)
  { }

  void
  operator()(const Sized_symbol<size>* sym)
  {
    typedef Global_got_offset_visitor<size, big_endian> Got_visitor;
    const Got_offset_list* got_offsets = sym->got_offset_list();
    if (got_offsets != NULL)
      {
	this->info_.sym_index = sym->symtab_index();
	this->info_.input_index = 0;
	Got_visitor v(this->info_);
	got_offsets->for_all_got_offsets(&v);
      }
    if (sym->has_plt_offset())
      {
	unsigned int plt_index =
	    ((sym->plt_offset() - this->info_.first_plt_entry_offset)
	     / this->info_.plt_entry_size);
	gold_assert(plt_index < this->info_.plt_count);
	unsigned char* pov = this->info_.plt_desc_p + plt_index * 4;
	elfcpp::Swap<32, big_endian>::writeval(pov, sym->symtab_index());
      }
  }

 private:
  struct Got_plt_view_info& info_;
};

// Write the contents of the .gnu_incremental_got_plt section.

template<int size, bool big_endian>
void
Output_section_incremental_inputs<size, big_endian>::write_got_plt(
    unsigned char* pov,
    off_t view_size)
{
  Sized_target<size, big_endian>* target =
    parameters->sized_target<size, big_endian>();

  // Set up the view information for the functors.
  struct Got_plt_view_info view_info;
  view_info.got_count = target->got_entry_count();
  view_info.plt_count = target->plt_entry_count();
  view_info.first_plt_entry_offset = target->first_plt_entry_offset();
  view_info.plt_entry_size = target->plt_entry_size();
  view_info.got_type_p = pov + 8;
  view_info.got_desc_p = (view_info.got_type_p
			  + ((view_info.got_count + 3) & ~3));
  view_info.plt_desc_p = view_info.got_desc_p + view_info.got_count * 8;

  gold_assert(pov + view_size ==
	      view_info.plt_desc_p + view_info.plt_count * 4);

  // Write the section header.
  Swap32::writeval(pov, view_info.got_count);
  Swap32::writeval(pov + 4, view_info.plt_count);

  // Initialize the GOT type array to 0xff (reserved).
  memset(view_info.got_type_p, 0xff, view_info.got_count);

  // Write the incremental GOT descriptors for local symbols.
  typedef Local_got_offset_visitor<size, big_endian> Got_visitor;
  for (Incremental_inputs::Input_list::const_iterator p =
	   this->inputs_->input_files().begin();
       p != this->inputs_->input_files().end();
       ++p)
    {
      if ((*p)->type() != INCREMENTAL_INPUT_OBJECT
	  && (*p)->type() != INCREMENTAL_INPUT_ARCHIVE_MEMBER)
	continue;
      Incremental_object_entry* entry = (*p)->object_entry();
      gold_assert(entry != NULL);
      const Object* obj = entry->object();
      gold_assert(obj != NULL);
      view_info.input_index = (*p)->get_file_index();
      Got_visitor v(view_info);
      obj->for_all_local_got_entries(&v);
    }

  // Write the incremental GOT and PLT descriptors for global symbols.
  typedef Global_symbol_visitor_got_plt<size, big_endian> Symbol_visitor;
  symtab_->for_all_symbols<size, Symbol_visitor>(Symbol_visitor(view_info));
}

// Class Sized_relobj_incr.  Most of these methods are not used for
// Incremental objects, but are required to be implemented by the
// base class Object.

template<int size, bool big_endian>
Sized_relobj_incr<size, big_endian>::Sized_relobj_incr(
    const std::string& name,
    Sized_incremental_binary<size, big_endian>* ibase,
    unsigned int input_file_index)
  : Sized_relobj<size, big_endian>(name, NULL), ibase_(ibase),
    input_file_index_(input_file_index),
    input_reader_(ibase->inputs_reader().input_file(input_file_index)),
    local_symbol_count_(0), output_local_dynsym_count_(0),
    local_symbol_index_(0), local_symbol_offset_(0), local_dynsym_offset_(0),
    symbols_(), defined_count_(0), incr_reloc_offset_(-1U),
    incr_reloc_count_(0), incr_reloc_output_index_(0), incr_relocs_(NULL),
    local_symbols_()
{
  if (this->input_reader_.is_in_system_directory())
    this->set_is_in_system_directory();
  const unsigned int shnum = this->input_reader_.get_input_section_count() + 1;
  this->set_shnum(shnum);
  ibase->set_input_object(input_file_index, this);
}

// Read the symbols.

template<int size, bool big_endian>
void
Sized_relobj_incr<size, big_endian>::do_read_symbols(Read_symbols_data*)
{
  gold_unreachable();
}

// Lay out the input sections.

template<int size, bool big_endian>
void
Sized_relobj_incr<size, big_endian>::do_layout(
    Symbol_table*,
    Layout* layout,
    Read_symbols_data*)
{
  const unsigned int shnum = this->shnum();
  Incremental_inputs* incremental_inputs = layout->incremental_inputs();
  gold_assert(incremental_inputs != NULL);
  Output_sections& out_sections(this->output_sections());
  out_sections.resize(shnum);
  this->section_offsets().resize(shnum);

  // Keep track of .debug_info and .debug_types sections.
  std::vector<unsigned int> debug_info_sections;
  std::vector<unsigned int> debug_types_sections;

  for (unsigned int i = 1; i < shnum; i++)
    {
      typename Input_entry_reader::Input_section_info sect =
	  this->input_reader_.get_input_section(i - 1);
      // Add the section to the incremental inputs layout.
      incremental_inputs->report_input_section(this, i, sect.name,
					       sect.sh_size);
      if (sect.output_shndx == 0 || sect.sh_offset == -1)
	continue;
      Output_section* os = this->ibase_->output_section(sect.output_shndx);
      gold_assert(os != NULL);
      out_sections[i] = os;
      this->section_offsets()[i] = static_cast<Address>(sect.sh_offset);

      // When generating a .gdb_index section, we do additional
      // processing of .debug_info and .debug_types sections after all
      // the other sections.
      if (parameters->options().gdb_index())
	{
	  const char* name = os->name();
	  if (strcmp(name, ".debug_info") == 0)
	    debug_info_sections.push_back(i);
	  else if (strcmp(name, ".debug_types") == 0)
	    debug_types_sections.push_back(i);
	}
    }

  // Process the COMDAT groups.
  unsigned int ncomdat = this->input_reader_.get_comdat_group_count();
  for (unsigned int i = 0; i < ncomdat; i++)
    {
      const char* signature = this->input_reader_.get_comdat_group_signature(i);
      if (signature == NULL || signature[0] == '\0')
	this->error(_("COMDAT group has no signature"));
      bool keep = layout->find_or_add_kept_section(signature, this, i, true,
						   true, NULL);
      if (keep)
	incremental_inputs->report_comdat_group(this, signature);
      else
	this->error(_("COMDAT group %s included twice in incremental link"),
		    signature);
    }

  // When building a .gdb_index section, scan the .debug_info and
  // .debug_types sections.
  for (std::vector<unsigned int>::const_iterator p
	   = debug_info_sections.begin();
       p != debug_info_sections.end();
       ++p)
    {
      unsigned int i = *p;
      layout->add_to_gdb_index(false, this, NULL, 0, i, 0, 0);
    }
  for (std::vector<unsigned int>::const_iterator p
	   = debug_types_sections.begin();
       p != debug_types_sections.end();
       ++p)
    {
      unsigned int i = *p;
      layout->add_to_gdb_index(true, this, 0, 0, i, 0, 0);
    }
}

// Layout sections whose layout was deferred while waiting for
// input files from a plugin.
template<int size, bool big_endian>
void
Sized_relobj_incr<size, big_endian>::do_layout_deferred_sections(Layout*)
{
}

// Add the symbols to the symbol table.

template<int size, bool big_endian>
void
Sized_relobj_incr<size, big_endian>::do_add_symbols(
    Symbol_table* symtab,
    Read_symbols_data*,
    Layout*)
{
  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;
  unsigned char symbuf[sym_size];
  elfcpp::Sym<size, big_endian> sym(symbuf);
  elfcpp::Sym_write<size, big_endian> osym(symbuf);

  typedef typename elfcpp::Elf_types<size>::Elf_WXword Elf_size_type;

  unsigned int nsyms = this->input_reader_.get_global_symbol_count();
  this->symbols_.resize(nsyms);

  Incremental_binary::View symtab_view(NULL);
  unsigned int symtab_count;
  elfcpp::Elf_strtab strtab(NULL, 0);
  this->ibase_->get_symtab_view(&symtab_view, &symtab_count, &strtab);

  Incremental_symtab_reader<big_endian> isymtab(this->ibase_->symtab_reader());
  unsigned int isym_count = isymtab.symbol_count();
  unsigned int first_global = symtab_count - isym_count;

  const unsigned char* sym_p;
  for (unsigned int i = 0; i < nsyms; ++i)
    {
      Incremental_global_symbol_reader<big_endian> info =
	  this->input_reader_.get_global_symbol_reader(i);
      unsigned int output_symndx = info.output_symndx();
      sym_p = symtab_view.data() + output_symndx * sym_size;
      elfcpp::Sym<size, big_endian> gsym(sym_p);
      const char* name;
      if (!strtab.get_c_string(gsym.get_st_name(), &name))
	name = "";

      typename elfcpp::Elf_types<size>::Elf_Addr v = gsym.get_st_value();
      unsigned int shndx = gsym.get_st_shndx();
      elfcpp::STB st_bind = gsym.get_st_bind();
      elfcpp::STT st_type = gsym.get_st_type();

      // Local hidden symbols start out as globals, but get converted to
      // to local during output.
      if (st_bind == elfcpp::STB_LOCAL)
	st_bind = elfcpp::STB_GLOBAL;

      unsigned int input_shndx = info.shndx();
      if (input_shndx == 0 || input_shndx == -1U)
	{
	  shndx = elfcpp::SHN_UNDEF;
	  v = 0;
	}
      else if (shndx != elfcpp::SHN_ABS)
	{
	  // Find the input section and calculate the section-relative value.
	  gold_assert(shndx != elfcpp::SHN_UNDEF);
	  Output_section* os = this->ibase_->output_section(shndx);
	  gold_assert(os != NULL && os->has_fixed_layout());
	  typename Input_entry_reader::Input_section_info sect =
	      this->input_reader_.get_input_section(input_shndx - 1);
	  gold_assert(sect.output_shndx == shndx);
	  if (st_type != elfcpp::STT_TLS)
	    v -= os->address();
	  v -= sect.sh_offset;
	  shndx = input_shndx;
	}

      osym.put_st_name(0);
      osym.put_st_value(v);
      osym.put_st_size(gsym.get_st_size());
      osym.put_st_info(st_bind, st_type);
      osym.put_st_other(gsym.get_st_other());
      osym.put_st_shndx(shndx);

      Symbol* res = symtab->add_from_incrobj(this, name, NULL, &sym);

      if (shndx != elfcpp::SHN_UNDEF)
	++this->defined_count_;

      // If this is a linker-defined symbol that hasn't yet been defined,
      // define it now.
      if (input_shndx == -1U && !res->is_defined())
	{
	  shndx = gsym.get_st_shndx();
	  v = gsym.get_st_value();
	  Elf_size_type symsize = gsym.get_st_size();
	  if (shndx == elfcpp::SHN_ABS)
	    {
	      symtab->define_as_constant(name, NULL,
					 Symbol_table::INCREMENTAL_BASE,
					 v, symsize, st_type, st_bind,
					 gsym.get_st_visibility(), 0,
					 false, false);
	    }
	  else
	    {
	      Output_section* os = this->ibase_->output_section(shndx);
	      gold_assert(os != NULL && os->has_fixed_layout());
	      v -= os->address();
	      if (symsize > 0)
		os->reserve(v, symsize);
	      symtab->define_in_output_data(name, NULL,
					    Symbol_table::INCREMENTAL_BASE,
					    os, v, symsize, st_type, st_bind,
					    gsym.get_st_visibility(), 0,
					    false, false);
	    }
	}

      this->symbols_[i] = res;
      this->ibase_->add_global_symbol(output_symndx - first_global, res);
    }
}

// Return TRUE if we should include this object from an archive library.

template<int size, bool big_endian>
Archive::Should_include
Sized_relobj_incr<size, big_endian>::do_should_include_member(
    Symbol_table*,
    Layout*,
    Read_symbols_data*,
    std::string*)
{
  gold_unreachable();
}

// Iterate over global symbols, calling a visitor class V for each.

template<int size, bool big_endian>
void
Sized_relobj_incr<size, big_endian>::do_for_all_global_symbols(
    Read_symbols_data*,
    Library_base::Symbol_visitor_base*)
{
  // This routine is not used for incremental objects.
}

// Get the size of a section.

template<int size, bool big_endian>
uint64_t
Sized_relobj_incr<size, big_endian>::do_section_size(unsigned int)
{
  gold_unreachable();
}

// Get the name of a section.  This returns the name of the output
// section, because we don't usually track the names of the input
// sections.

template<int size, bool big_endian>
std::string
Sized_relobj_incr<size, big_endian>::do_section_name(unsigned int shndx)
{
  Output_sections& out_sections(this->output_sections());
  Output_section* os = out_sections[shndx];
  if (os == NULL)
    return NULL;
  return os->name();
}

// Return a view of the contents of a section.

template<int size, bool big_endian>
const unsigned char*
Sized_relobj_incr<size, big_endian>::do_section_contents(
    unsigned int shndx,
    section_size_type* plen,
    bool)
{
  Output_sections& out_sections(this->output_sections());
  Output_section* os = out_sections[shndx];
  gold_assert(os != NULL);
  off_t section_offset = os->offset();
  typename Input_entry_reader::Input_section_info sect =
      this->input_reader_.get_input_section(shndx - 1);
  section_offset += sect.sh_offset;
  *plen = sect.sh_size;
  return this->ibase_->view(section_offset, sect.sh_size).data();
}

// Return section flags.

template<int size, bool big_endian>
uint64_t
Sized_relobj_incr<size, big_endian>::do_section_flags(unsigned int)
{
  gold_unreachable();
}

// Return section entsize.

template<int size, bool big_endian>
uint64_t
Sized_relobj_incr<size, big_endian>::do_section_entsize(unsigned int)
{
  gold_unreachable();
}

// Return section address.

template<int size, bool big_endian>
uint64_t
Sized_relobj_incr<size, big_endian>::do_section_address(unsigned int)
{
  gold_unreachable();
}

// Return section type.

template<int size, bool big_endian>
unsigned int
Sized_relobj_incr<size, big_endian>::do_section_type(unsigned int)
{
  gold_unreachable();
}

// Return the section link field.

template<int size, bool big_endian>
unsigned int
Sized_relobj_incr<size, big_endian>::do_section_link(unsigned int)
{
  gold_unreachable();
}

// Return the section link field.

template<int size, bool big_endian>
unsigned int
Sized_relobj_incr<size, big_endian>::do_section_info(unsigned int)
{
  gold_unreachable();
}

// Return the section alignment.

template<int size, bool big_endian>
uint64_t
Sized_relobj_incr<size, big_endian>::do_section_addralign(unsigned int)
{
  gold_unreachable();
}

// Return the Xindex structure to use.

template<int size, bool big_endian>
Xindex*
Sized_relobj_incr<size, big_endian>::do_initialize_xindex()
{
  gold_unreachable();
}

// Get symbol counts.

template<int size, bool big_endian>
void
Sized_relobj_incr<size, big_endian>::do_get_global_symbol_counts(
    const Symbol_table*,
    size_t* defined,
    size_t* used) const
{
  *defined = this->defined_count_;
  size_t count = 0;
  for (typename Symbols::const_iterator p = this->symbols_.begin();
       p != this->symbols_.end();
       ++p)
    if (*p != NULL
	&& (*p)->source() == Symbol::FROM_OBJECT
	&& (*p)->object() == this
	&& (*p)->is_defined())
      ++count;
  *used = count;
}

// Read the relocs.

template<int size, bool big_endian>
void
Sized_relobj_incr<size, big_endian>::do_read_relocs(Read_relocs_data*)
{
}

// Process the relocs to find list of referenced sections. Used only
// during garbage collection.

template<int size, bool big_endian>
void
Sized_relobj_incr<size, big_endian>::do_gc_process_relocs(Symbol_table*,
							  Layout*,
							  Read_relocs_data*)
{
  gold_unreachable();
}

// Scan the relocs and adjust the symbol table.

template<int size, bool big_endian>
void
Sized_relobj_incr<size, big_endian>::do_scan_relocs(Symbol_table*,
						    Layout* layout,
						    Read_relocs_data*)
{
  // Count the incremental relocations for this object.
  unsigned int nsyms = this->input_reader_.get_global_symbol_count();
  this->allocate_incremental_reloc_counts();
  for (unsigned int i = 0; i < nsyms; i++)
    {
      Incremental_global_symbol_reader<big_endian> sym =
	  this->input_reader_.get_global_symbol_reader(i);
      unsigned int reloc_count = sym.reloc_count();
      if (reloc_count > 0 && this->incr_reloc_offset_ == -1U)
	this->incr_reloc_offset_ = sym.reloc_offset();
      this->incr_reloc_count_ += reloc_count;
      for (unsigned int j = 0; j < reloc_count; j++)
	this->count_incremental_reloc(i);
    }
  this->incr_reloc_output_index_ =
      layout->incremental_inputs()->get_reloc_count();
  this->finalize_incremental_relocs(layout, false);

  // The incoming incremental relocations may not end up in the same
  // location after the incremental update, because the incremental info
  // is regenerated in each link.  Because the new location may overlap
  // with other data in the updated output file, we need to copy the
  // relocations into a buffer so that we can still read them safely
  // after we start writing updates to the output file.
  if (this->incr_reloc_count_ > 0)
    {
      const Incremental_relocs_reader<size, big_endian>& relocs_reader =
	  this->ibase_->relocs_reader();
      const unsigned int incr_reloc_size = relocs_reader.reloc_size;
      unsigned int len = this->incr_reloc_count_ * incr_reloc_size;
      this->incr_relocs_ = new unsigned char[len];
      memcpy(this->incr_relocs_,
	     relocs_reader.data(this->incr_reloc_offset_),
	     len);
    }
}

// Count the local symbols.

template<int size, bool big_endian>
void
Sized_relobj_incr<size, big_endian>::do_count_local_symbols(
    Stringpool_template<char>* pool,
    Stringpool_template<char>*)
{
  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;

  // Set the count of local symbols based on the incremental info.
  unsigned int nlocals = this->input_reader_.get_local_symbol_count();
  this->local_symbol_count_ = nlocals;
  this->local_symbols_.reserve(nlocals);

  // Get views of the base file's symbol table and string table.
  Incremental_binary::View symtab_view(NULL);
  unsigned int symtab_count;
  elfcpp::Elf_strtab strtab(NULL, 0);
  this->ibase_->get_symtab_view(&symtab_view, &symtab_count, &strtab);

  // Read the local symbols from the base file's symbol table.
  off_t off = this->input_reader_.get_local_symbol_offset();
  const unsigned char* symp = symtab_view.data() + off;
  for (unsigned int i = 0; i < nlocals; ++i, symp += sym_size)
    {
      elfcpp::Sym<size, big_endian> sym(symp);
      const char* name;
      if (!strtab.get_c_string(sym.get_st_name(), &name))
	name = "";
      gold_debug(DEBUG_INCREMENTAL, "Local symbol %d: %s", i, name);
      name = pool->add(name, true, NULL);
      this->local_symbols_.push_back(Local_symbol(name,
						  sym.get_st_value(),
						  sym.get_st_size(),
						  sym.get_st_shndx(),
						  sym.get_st_type(),
						  false));
    }
}

// Finalize the local symbols.

template<int size, bool big_endian>
unsigned int
Sized_relobj_incr<size, big_endian>::do_finalize_local_symbols(
    unsigned int index,
    off_t off,
    Symbol_table*)
{
  this->local_symbol_index_ = index;
  this->local_symbol_offset_ = off;
  return index + this->local_symbol_count_;
}

// Set the offset where local dynamic symbol information will be stored.

template<int size, bool big_endian>
unsigned int
Sized_relobj_incr<size, big_endian>::do_set_local_dynsym_indexes(
    unsigned int index)
{
  // FIXME: set local dynsym indexes.
  return index;
}

// Set the offset where local dynamic symbol information will be stored.

template<int size, bool big_endian>
unsigned int
Sized_relobj_incr<size, big_endian>::do_set_local_dynsym_offset(off_t)
{
  return 0;
}

// Relocate the input sections and write out the local symbols.
// We don't actually do any relocation here.  For unchanged input files,
// we reapply relocations only for symbols that have changed; that happens
// in queue_final_tasks.  We do need to rewrite the incremental relocations
// for this object.

template<int size, bool big_endian>
void
Sized_relobj_incr<size, big_endian>::do_relocate(const Symbol_table*,
						 const Layout* layout,
						 Output_file* of)
{
  if (this->incr_reloc_count_ == 0)
    return;

  const unsigned int incr_reloc_size =
      Incremental_relocs_reader<size, big_endian>::reloc_size;

  // Get a view for the .gnu_incremental_relocs section.
  Incremental_inputs* inputs = layout->incremental_inputs();
  gold_assert(inputs != NULL);
  const off_t relocs_off = inputs->relocs_section()->offset();
  const off_t relocs_size = inputs->relocs_section()->data_size();
  unsigned char* const view = of->get_output_view(relocs_off, relocs_size);

  // Copy the relocations from the buffer.
  off_t off = this->incr_reloc_output_index_ * incr_reloc_size;
  unsigned int len = this->incr_reloc_count_ * incr_reloc_size;
  memcpy(view + off, this->incr_relocs_, len);

  // The output section table may have changed, so we need to map
  // the old section index to the new section index for each relocation.
  for (unsigned int i = 0; i < this->incr_reloc_count_; ++i)
    {
      unsigned char* pov = view + off + i * incr_reloc_size;
      unsigned int shndx = elfcpp::Swap<32, big_endian>::readval(pov + 4);
      Output_section* os = this->ibase_->output_section(shndx);
      gold_assert(os != NULL);
      shndx = os->out_shndx();
      elfcpp::Swap<32, big_endian>::writeval(pov + 4, shndx);
    }

  of->write_output_view(off, len, view);

  // Get views into the output file for the portions of the symbol table
  // and the dynamic symbol table that we will be writing.
  off_t symtab_off = layout->symtab_section()->offset();
  off_t output_size = this->local_symbol_count_ * This::sym_size;
  unsigned char* oview = NULL;
  if (output_size > 0)
    oview = of->get_output_view(symtab_off + this->local_symbol_offset_,
				output_size);

  off_t dyn_output_size = this->output_local_dynsym_count_ * sym_size;
  unsigned char* dyn_oview = NULL;
  if (dyn_output_size > 0)
    dyn_oview = of->get_output_view(this->local_dynsym_offset_,
				    dyn_output_size);

  // Write the local symbols.
  unsigned char* ov = oview;
  unsigned char* dyn_ov = dyn_oview;
  const Stringpool* sympool = layout->sympool();
  const Stringpool* dynpool = layout->dynpool();
  Output_symtab_xindex* symtab_xindex = layout->symtab_xindex();
  Output_symtab_xindex* dynsym_xindex = layout->dynsym_xindex();
  for (unsigned int i = 0; i < this->local_symbol_count_; ++i)
    {
      Local_symbol& lsym(this->local_symbols_[i]);

      bool is_ordinary;
      unsigned int st_shndx = this->adjust_sym_shndx(i, lsym.st_shndx,
						     &is_ordinary);
      if (is_ordinary)
	{
	  Output_section* os = this->ibase_->output_section(st_shndx);
	  st_shndx = os->out_shndx();
	  if (st_shndx >= elfcpp::SHN_LORESERVE)
	    {
	      symtab_xindex->add(this->local_symbol_index_ + i, st_shndx);
	      if (lsym.needs_dynsym_entry)
		dynsym_xindex->add(lsym.output_dynsym_index, st_shndx);
	      st_shndx = elfcpp::SHN_XINDEX;
	    }
	}

      // Write the symbol to the output symbol table.
      {
	elfcpp::Sym_write<size, big_endian> osym(ov);
	osym.put_st_name(sympool->get_offset(lsym.name));
	osym.put_st_value(lsym.st_value);
	osym.put_st_size(lsym.st_size);
	osym.put_st_info(elfcpp::STB_LOCAL,
			 static_cast<elfcpp::STT>(lsym.st_type));
	osym.put_st_other(0);
	osym.put_st_shndx(st_shndx);
	ov += sym_size;
      }

      // Write the symbol to the output dynamic symbol table.
      if (lsym.needs_dynsym_entry)
	{
	  gold_assert(dyn_ov < dyn_oview + dyn_output_size);
	  elfcpp::Sym_write<size, big_endian> osym(dyn_ov);
	  osym.put_st_name(dynpool->get_offset(lsym.name));
	  osym.put_st_value(lsym.st_value);
	  osym.put_st_size(lsym.st_size);
	  osym.put_st_info(elfcpp::STB_LOCAL,
			   static_cast<elfcpp::STT>(lsym.st_type));
	  osym.put_st_other(0);
	  osym.put_st_shndx(st_shndx);
	  dyn_ov += sym_size;
	}
    }

  if (output_size > 0)
    {
      gold_assert(ov - oview == output_size);
      of->write_output_view(symtab_off + this->local_symbol_offset_,
			    output_size, oview);
    }

  if (dyn_output_size > 0)
    {
      gold_assert(dyn_ov - dyn_oview == dyn_output_size);
      of->write_output_view(this->local_dynsym_offset_, dyn_output_size,
			    dyn_oview);
    }
}

// Set the offset of a section.

template<int size, bool big_endian>
void
Sized_relobj_incr<size, big_endian>::do_set_section_offset(unsigned int,
							   uint64_t)
{
}

// Class Sized_incr_dynobj.  Most of these methods are not used for
// Incremental objects, but are required to be implemented by the
// base class Object.

template<int size, bool big_endian>
Sized_incr_dynobj<size, big_endian>::Sized_incr_dynobj(
    const std::string& name,
    Sized_incremental_binary<size, big_endian>* ibase,
    unsigned int input_file_index)
  : Dynobj(name, NULL), ibase_(ibase),
    input_file_index_(input_file_index),
    input_reader_(ibase->inputs_reader().input_file(input_file_index)),
    symbols_(), defined_count_(0)
{
  if (this->input_reader_.is_in_system_directory())
    this->set_is_in_system_directory();
  if (this->input_reader_.as_needed())
    this->set_as_needed();
  this->set_soname_string(this->input_reader_.get_soname());
  this->set_shnum(0);
}

// Read the symbols.

template<int size, bool big_endian>
void
Sized_incr_dynobj<size, big_endian>::do_read_symbols(Read_symbols_data*)
{
  gold_unreachable();
}

// Lay out the input sections.

template<int size, bool big_endian>
void
Sized_incr_dynobj<size, big_endian>::do_layout(
    Symbol_table*,
    Layout*,
    Read_symbols_data*)
{
}

// Add the symbols to the symbol table.

template<int size, bool big_endian>
void
Sized_incr_dynobj<size, big_endian>::do_add_symbols(
    Symbol_table* symtab,
    Read_symbols_data*,
    Layout*)
{
  const int sym_size = elfcpp::Elf_sizes<size>::sym_size;
  unsigned char symbuf[sym_size];
  elfcpp::Sym<size, big_endian> sym(symbuf);
  elfcpp::Sym_write<size, big_endian> osym(symbuf);

  unsigned int nsyms = this->input_reader_.get_global_symbol_count();
  this->symbols_.resize(nsyms);

  Incremental_binary::View symtab_view(NULL);
  unsigned int symtab_count;
  elfcpp::Elf_strtab strtab(NULL, 0);
  this->ibase_->get_symtab_view(&symtab_view, &symtab_count, &strtab);

  Incremental_symtab_reader<big_endian> isymtab(this->ibase_->symtab_reader());
  unsigned int isym_count = isymtab.symbol_count();
  unsigned int first_global = symtab_count - isym_count;

  // We keep a set of symbols that we have generated COPY relocations
  // for, indexed by the symbol value. We do not need more than one
  // COPY relocation per address.
  typedef typename std::set<Address> Copied_symbols;
  Copied_symbols copied_symbols;

  const unsigned char* sym_p;
  for (unsigned int i = 0; i < nsyms; ++i)
    {
      bool is_def;
      bool is_copy;
      unsigned int output_symndx =
	  this->input_reader_.get_output_symbol_index(i, &is_def, &is_copy);
      sym_p = symtab_view.data() + output_symndx * sym_size;
      elfcpp::Sym<size, big_endian> gsym(sym_p);
      const char* name;
      if (!strtab.get_c_string(gsym.get_st_name(), &name))
	name = "";

      Address v;
      unsigned int shndx;
      elfcpp::STB st_bind = gsym.get_st_bind();
      elfcpp::STT st_type = gsym.get_st_type();

      // Local hidden symbols start out as globals, but get converted to
      // to local during output.
      if (st_bind == elfcpp::STB_LOCAL)
	st_bind = elfcpp::STB_GLOBAL;

      if (!is_def)
	{
	  shndx = elfcpp::SHN_UNDEF;
	  v = 0;
	}
      else
	{
	  // For a symbol defined in a shared object, the section index
	  // is meaningless, as long as it's not SHN_UNDEF.
	  shndx = 1;
	  v = gsym.get_st_value();
	  ++this->defined_count_;
	}

      osym.put_st_name(0);
      osym.put_st_value(v);
      osym.put_st_size(gsym.get_st_size());
      osym.put_st_info(st_bind, st_type);
      osym.put_st_other(gsym.get_st_other());
      osym.put_st_shndx(shndx);

      Sized_symbol<size>* res =
	  symtab->add_from_incrobj<size, big_endian>(this, name, NULL, &sym);
      this->symbols_[i] = res;
      this->ibase_->add_global_symbol(output_symndx - first_global,
				      this->symbols_[i]);

      if (is_copy)
	{
	  std::pair<typename Copied_symbols::iterator, bool> ins =
	      copied_symbols.insert(v);
	  if (ins.second)
	    {
	      unsigned int shndx = gsym.get_st_shndx();
	      Output_section* os = this->ibase_->output_section(shndx);
	      off_t offset = v - os->address();
	      this->ibase_->add_copy_reloc(this->symbols_[i], os, offset);
	    }
	}
    }
}

// Return TRUE if we should include this object from an archive library.

template<int size, bool big_endian>
Archive::Should_include
Sized_incr_dynobj<size, big_endian>::do_should_include_member(
    Symbol_table*,
    Layout*,
    Read_symbols_data*,
    std::string*)
{
  gold_unreachable();
}

// Iterate over global symbols, calling a visitor class V for each.

template<int size, bool big_endian>
void
Sized_incr_dynobj<size, big_endian>::do_for_all_global_symbols(
    Read_symbols_data*,
    Library_base::Symbol_visitor_base*)
{
  // This routine is not used for dynamic libraries.
}

// Iterate over local symbols, calling a visitor class V for each GOT offset
// associated with a local symbol.

template<int size, bool big_endian>
void
Sized_incr_dynobj<size, big_endian>::do_for_all_local_got_entries(
    Got_offset_list::Visitor*) const
{
}

// Get the size of a section.

template<int size, bool big_endian>
uint64_t
Sized_incr_dynobj<size, big_endian>::do_section_size(unsigned int)
{
  gold_unreachable();
}

// Get the name of a section.

template<int size, bool big_endian>
std::string
Sized_incr_dynobj<size, big_endian>::do_section_name(unsigned int)
{
  gold_unreachable();
}

// Return a view of the contents of a section.

template<int size, bool big_endian>
const unsigned char*
Sized_incr_dynobj<size, big_endian>::do_section_contents(
    unsigned int,
    section_size_type*,
    bool)
{
  gold_unreachable();
}

// Return section flags.

template<int size, bool big_endian>
uint64_t
Sized_incr_dynobj<size, big_endian>::do_section_flags(unsigned int)
{
  gold_unreachable();
}

// Return section entsize.

template<int size, bool big_endian>
uint64_t
Sized_incr_dynobj<size, big_endian>::do_section_entsize(unsigned int)
{
  gold_unreachable();
}

// Return section address.

template<int size, bool big_endian>
uint64_t
Sized_incr_dynobj<size, big_endian>::do_section_address(unsigned int)
{
  gold_unreachable();
}

// Return section type.

template<int size, bool big_endian>
unsigned int
Sized_incr_dynobj<size, big_endian>::do_section_type(unsigned int)
{
  gold_unreachable();
}

// Return the section link field.

template<int size, bool big_endian>
unsigned int
Sized_incr_dynobj<size, big_endian>::do_section_link(unsigned int)
{
  gold_unreachable();
}

// Return the section link field.

template<int size, bool big_endian>
unsigned int
Sized_incr_dynobj<size, big_endian>::do_section_info(unsigned int)
{
  gold_unreachable();
}

// Return the section alignment.

template<int size, bool big_endian>
uint64_t
Sized_incr_dynobj<size, big_endian>::do_section_addralign(unsigned int)
{
  gold_unreachable();
}

// Return the Xindex structure to use.

template<int size, bool big_endian>
Xindex*
Sized_incr_dynobj<size, big_endian>::do_initialize_xindex()
{
  gold_unreachable();
}

// Get symbol counts.

template<int size, bool big_endian>
void
Sized_incr_dynobj<size, big_endian>::do_get_global_symbol_counts(
    const Symbol_table*,
    size_t* defined,
    size_t* used) const
{
  *defined = this->defined_count_;
  size_t count = 0;
  for (typename Symbols::const_iterator p = this->symbols_.begin();
       p != this->symbols_.end();
       ++p)
    if (*p != NULL
	&& (*p)->source() == Symbol::FROM_OBJECT
	&& (*p)->object() == this
	&& (*p)->is_defined()
	&& (*p)->dynsym_index() != -1U)
      ++count;
  *used = count;
}

// Allocate an incremental object of the appropriate size and endianness.

Object*
make_sized_incremental_object(
    Incremental_binary* ibase,
    unsigned int input_file_index,
    Incremental_input_type input_type,
    const Incremental_binary::Input_reader* input_reader)
{
  Object* obj = NULL;
  std::string name(input_reader->filename());

  switch (parameters->size_and_endianness())
    {
#ifdef HAVE_TARGET_32_LITTLE
    case Parameters::TARGET_32_LITTLE:
      {
	Sized_incremental_binary<32, false>* sized_ibase =
	    static_cast<Sized_incremental_binary<32, false>*>(ibase);
	if (input_type == INCREMENTAL_INPUT_SHARED_LIBRARY)
	  obj = new Sized_incr_dynobj<32, false>(name, sized_ibase,
						 input_file_index);
	else
	  obj = new Sized_relobj_incr<32, false>(name, sized_ibase,
						 input_file_index);
      }
      break;
#endif
#ifdef HAVE_TARGET_32_BIG
    case Parameters::TARGET_32_BIG:
      {
	Sized_incremental_binary<32, true>* sized_ibase =
	    static_cast<Sized_incremental_binary<32, true>*>(ibase);
	if (input_type == INCREMENTAL_INPUT_SHARED_LIBRARY)
	  obj = new Sized_incr_dynobj<32, true>(name, sized_ibase,
						input_file_index);
	else
	  obj = new Sized_relobj_incr<32, true>(name, sized_ibase,
						input_file_index);
      }
      break;
#endif
#ifdef HAVE_TARGET_64_LITTLE
    case Parameters::TARGET_64_LITTLE:
      {
	Sized_incremental_binary<64, false>* sized_ibase =
	    static_cast<Sized_incremental_binary<64, false>*>(ibase);
	if (input_type == INCREMENTAL_INPUT_SHARED_LIBRARY)
	  obj = new Sized_incr_dynobj<64, false>(name, sized_ibase,
						 input_file_index);
	else
	  obj = new Sized_relobj_incr<64, false>(name, sized_ibase,
						 input_file_index);
     }
      break;
#endif
#ifdef HAVE_TARGET_64_BIG
    case Parameters::TARGET_64_BIG:
      {
	Sized_incremental_binary<64, true>* sized_ibase =
	    static_cast<Sized_incremental_binary<64, true>*>(ibase);
	if (input_type == INCREMENTAL_INPUT_SHARED_LIBRARY)
	  obj = new Sized_incr_dynobj<64, true>(name, sized_ibase,
						input_file_index);
	else
	  obj = new Sized_relobj_incr<64, true>(name, sized_ibase,
						input_file_index);
      }
      break;
#endif
    default:
      gold_unreachable();
    }

  gold_assert(obj != NULL);
  return obj;
}

// Copy the unused symbols from the incremental input info.
// We need to do this because we may be overwriting the incremental
// input info in the base file before we write the new incremental
// info.
void
Incremental_library::copy_unused_symbols()
{
  unsigned int symcount = this->input_reader_->get_unused_symbol_count();
  this->unused_symbols_.reserve(symcount);
  for (unsigned int i = 0; i < symcount; ++i)
    {
      std::string name(this->input_reader_->get_unused_symbol(i));
      this->unused_symbols_.push_back(name);
    }
}

// Iterator for unused global symbols in the library.
void
Incremental_library::do_for_all_unused_symbols(Symbol_visitor_base* v) const
{
  for (Symbol_list::const_iterator p = this->unused_symbols_.begin();
       p != this->unused_symbols_.end();
       ++p)
  v->visit(p->c_str());
}

// Instantiate the templates we need.

#ifdef HAVE_TARGET_32_LITTLE
template
class Sized_incremental_binary<32, false>;

template
class Sized_relobj_incr<32, false>;

template
class Sized_incr_dynobj<32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Sized_incremental_binary<32, true>;

template
class Sized_relobj_incr<32, true>;

template
class Sized_incr_dynobj<32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Sized_incremental_binary<64, false>;

template
class Sized_relobj_incr<64, false>;

template
class Sized_incr_dynobj<64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Sized_incremental_binary<64, true>;

template
class Sized_relobj_incr<64, true>;

template
class Sized_incr_dynobj<64, true>;
#endif

} // End namespace gold.
@


1.55
log
@	* arm.cc (Arm_relocate_functions::abs16): Remove unused typedef.
	(Arm_exidx_cantunwind::do_fixed_endian_write): Likewise.
	(Target_arm::scan_reloc_for_stub): Likewise.
	* common.cc (Symbol_table::do_allocate_commons_list): Likewise.
	* dwarf_reader.cc (Dwarf_die::skip_attributes): Likewise.
	* ehframe.cc (Eh_frame::do_add_ehframe_input_section): Likewise.
	* incremental.cc (Sized_incr_dynobj::do_add_symbols): Likewise.
	* powerpc.cc (Target_powerpc::relocate_tls): Likewise.
@
text
@d1435 1
a1435 1
  gold_assert(global_sym_count * 4 == symtab_size);
@


1.55.2.1
log
@gold/
	* dwarf_reader.cc (Sized_elf_reloc_mapper::symbol_section): Cast
	SYMNDX to off_t before comparing it to this->data_size().
	* output.cc (Output_symtab_xindex::endian_do_write): Likewise.
	* incremental.cc (Output_section_incremental_inputs::do_write):
	Cast GLOBAL_SYM_COUNT to off_t before comparing it to SYMTAB_SIZE.
@
text
@d1435 1
a1435 1
  gold_assert(static_cast<off_t>(global_sym_count) * 4 == symtab_size);
@


1.54
log
@	* configure.ac (ENABLE_GOLD): Consider *-*-nacl* targets ELF.
	* configure: Regenerate.

gold/
	* nacl.cc: New file.
	* nacl.h: New file.
	* Makefile.am (CCFILES, HFILES): Add them.
	* Makefile.in: Regenerate.
	* i386.cc (Output_data_plt_i386_nacl): New class.
	(Output_data_plt_i386_nacl_exec): New class.
	(Output_data_plt_i386_nacl_dyn): New class.
	(Target_i386_nacl): New class.
	(Target_selector_i386_nacl): New class.
	(target_selector_i386): Use it instead of Target_selector_i386.
	* x86_64.cc (Output_data_plt_x86_64_nacl): New class.
	(Target_x86_64_nacl): New class.
	(Target_selector_x86_64_nacl): New class.
	(target_selector_x86_64, target_selector_x32): Use it instead of
	Target_selector_x86_64.
	* arm.cc (Output_data_plt_arm_nacl): New class.
	(Target_arm_nacl): New class.
	(Target_selector_arm_nacl): New class.
	(target_selector_arm, target_selector_armbe): Use it instead of
	Target_selector_arm.

	* target-select.cc (select_target): Take new Input_file* and off_t
	arguments, pass them on to recognize method of selector.
	* object.cc (make_elf_sized_object): Update caller.
	* parameters.cc (parameters_force_valid_target): Likewise.
	* incremental.cc (make_sized_incremental_binary): Likewise.
	* target-select.h: Update decl.
	(Target_selector::recognize): Take new Input_file* argument,
	pass it on to do_recognize.
	(Target_selector::do_recognize): Take new Input_file* argument.
	* freebsd.h (Target_selector_freebsd::do_recognize): Likewise.
	* powerpc.cc (Target_selector_powerpc::do_recognize): Likewise.
	* sparc.cc (Target_selector_sparc::do_recognize): Likewise.
	* testsuite/testfile.cc (Target_selector::do_recognize): Likewise.

	* target.h (Target::Target_info): New members isolate_execinstr
	and rosegment_gap.
	(Target::isolate_execinstr, Target::rosegment_gap): New methods.
	* arm.cc (Target_arm::arm_info): Update initializer.
	* i386.cc (Target_i386::i386_info): Likewise.
	* powerpc.cc (Target_powerpc::powerpc_info): Likewise.
	* sparc.cc (Target_sparc::sparc_info): Likewise.
	* x86_64.cc (Target_x86_64::x86_64_info): Likewise.
	* testsuite/testfile.cc (Target_test::test_target_info): Likewise.
	* layout.cc (Layout::attach_allocated_section_to_segment):
	Take new const Target* argument.  If target->isolate_execinstr(), act
	like --rosegment.
	(Layout::find_first_load_seg): Take new const Target* argument;
	if target->isolate_execinstr(), reject PF_X segments.
	(Layout::relaxation_loop_body): Update caller.
	(Layout::set_segment_offsets): If target->isolate_execinstr(),
	reset file offset to zero when we hit LOAD_SEG, and then do a second
	loop over the segments before LOAD_SEG to reassign offsets after
	addresses have been determined.  Handle target->rosegment_gap().
	(Layout::attach_section_to_segment): Take new const Target* argument;
	pass it to attach_allocated_section_to_segment.
	(Layout::make_output_section): Update caller.
	(Layout::attach_sections_to_segments): Take new const Target* argument;
	pass it to attach_section_to_segment.
	* gold.cc (queue_middle_tasks): Update caller.
	* layout.h (Layout): Update method decls with new arguments.

	* arm.cc (Target_arm::Target_arm): Take optional argument for the
	Target_info pointer to use.
	(Target_arm::do_make_data_plt): New virtual method.
	(Target_arm::make_data_plt): New method that calls it.
	(Target_arm::make_plt_entry): Use it.
	(Output_data_plt_arm::Output_data_plt_arm): Take additional argument
	for the section alignment.
	(Output_data_plt_arm::do_first_plt_entry_offset): New abstract virtual
	method.
	(Output_data_plt_arm::first_plt_entry_offset): Call it.
	(Output_data_plt_arm::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_arm::get_plt_entry_size): Call it.
	(Output_data_plt_arm::do_fill_plt_entry): New abstract virtual method.
	(Output_data_plt_arm::fill_plt_entry): New method that calls it.
	(Output_data_plt_arm::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_arm::fill_first_plt_entry): New method that calls it.
	(Output_data_plt_arm::set_final_data_size): Use get_plt_entry_size
	method instead of sizeof(plt_entry).
	(Output_data_plt_arm::add_entry): Likewise.
	Use first_plt_entry_offset method instead of sizeof(first_plt_entry).
	(Target_arm::first_plt_entry_offset): Call method on this->plt_ rather
	than static method.
	(Target_arm::plt_entry_size): Likewise.
	(Output_data_plt_arm::first_plt_entry, Output_data_plt_arm::plt_entry):
	Move to ...
	(Output_data_plt_arm_standard): ... here, new class.
	(Output_data_plt_arm::do_write): Move guts of PLT filling to...
	(Output_data_plt_arm_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_arm_standard::do_fill_plt_entry): ... and here.

	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Take additional argument for the PLT entry size.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset):
	Use get_plt_entry_size method rather than plt_entry_size variable.
	(Output_data_plt_x86_64::reserve_slot): Likewise.
	(Output_data_plt_x86_64::do_adjust_output_section): Likewise.
	(Output_data_plt_x86_64::add_entry): Likewise.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Likewise.
	(Output_data_plt_x86_64::address_for_global): Likewise.
	(Output_data_plt_x86_64::address_for_local): Likewise.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::first_plt_entry_offset): Likewise.
	Make method non-static.
	(Output_data_plt_x86_64::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_x86_64::get_plt_entry_size): Just call that.
	(Output_data_plt_x86_64::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_x86_64::add_eh_frame): New method to call it.
	(Output_data_plt_x86_64::do_fill_first_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_first_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_plt_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_plt_entry): New method to call it.
	(Output_data_plt_x86_64::do_fill_tlsdesc_entry): New abstract
	virtual method.
	(Output_data_plt_x86_64::fill_tlsdesc_entry): New method to call it.
	(Output_data_plt_x86_64::plt_entry_size)
	(Output_data_plt_x86_64::first_plt_entry)
	(Output_data_plt_x86_64::plt_entry)
	(Output_data_plt_x86_64::tlsdesc_plt_entry)
	(Output_data_plt_x86_64::plt_eh_frame_fde_size)
	(Output_data_plt_x86_64::plt_eh_frame_fde): Move to ...
	(Output_data_plt_x86_64_standard): ... here, new class.
	(Target_x86_64::Target_x86_64): Take optional argument for the
	Target_info pointer to use.
	(Target_x86_64::do_make_data_plt): New virtual method.
	(Target_x86_64::make_data_plt): New method to call it.
	(Target_x86_64::init_got_plt_for_update): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_x86_64::init):	Don't do add_eh_frame_for_plt here.
	(Target_x86_64::first_plt_entry_offset): Call method on this->plt_
	rather than static method.
	(Target_x86_64::plt_entry_size): Likewise.
	(Output_data_plt_x86_64::do_write): Use get_plt_entry_size method
	rather than plt_entry_size variable.  Move guts of PLT filling to...
	(Output_data_plt_x86_64_standard::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_x86_64_standard::do_fill_plt_entry): ... and here ...
	(Output_data_plt_x86_64_standard::do_fill_tlsdesc_entry): ... and here.

	* i386.cc (Output_data_plt_i386::Output_data_plt_i386): Take
	additional argument for the section alignment.
	Don't do add_eh_frame_for_plt here.
	(Output_data_plt_i386::first_plt_entry_offset): Make the method
	non-static.  Use get_plt_entry_size method rather than plt_entry_size
	variable.
	(Output_data_plt_i386::do_get_plt_entry_size): New abstract virtual
	method.
	(Output_data_plt_i386::get_plt_entry_size): Call it.
	(Output_data_plt_i386::do_add_eh_frame): New abstract virtual method.
	(Output_data_plt_i386::add_eh_frame): New method to call it.
	(Output_data_plt_i386::do_fill_first_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_first_plt_entry): New method to call it.
	(Output_data_plt_i386::do_fill_plt_entry): New abstract virtual
	method.
	(Output_data_plt_i386::fill_plt_entry): New method to call it.
	(Output_data_plt_i386::set_final_data_size): Use get_plt_entry_size
	method instead of plt_entry_size.
	(Output_data_plt_i386::plt_entry_size)
	(Output_data_plt_i386::plt_eh_frame_fde_size)
	(Output_data_plt_i386::plt_eh_frame_fde): Move to ...
	(Output_data_plt_i386_standard): ... here, new class.
	(Output_data_plt_i386_exec): New class.
	(Output_data_plt_i386::exec_first_plt_entry): Move to ...
	(Output_data_plt_i386_exec::first_plt_entry): ... here.
	(Output_data_plt_i386::exec_plt_entry): Move to ...
	(Output_data_plt_i386_exec::plt_entry): ... here.
	(Output_data_plt_i386_dyn): New class.
	(Output_data_plt_i386::first_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::first_plt_entry): ... here.
	(Output_data_plt_i386::dyn_plt_entry): Move to ...
	(Output_data_plt_i386_dyn::plt_entry): ... here.
	(Target_i386::Target_i386): Take optional argument for the Target_info
	pointer to use.
	(Target_i386::do_make_data_plt): New virtual method.
	(Target_i386::make_data_plt): New method to call it.
	(Target_i386::make_plt_section): Use that.
	Call this->plt_->add_eh_frame method here.
	(Output_data_plt_i386::add_entry): Use get_plt_entry_size method
	rather than plt_entry_size variable.
	(Output_data_plt_i386::add_local_ifunc_entry): Likewise.
	(Output_data_plt_i386::address_for_local): Likewise.
	(Output_data_plt_i386::do_write): Likewise.
	Move guts of PLT filling to...
	(Output_data_plt_i386_exec::do_fill_first_plt_entry): ... here ...
	(Output_data_plt_i386_exec::do_fill_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_first_plt_entry): ... and here ...
	(Output_data_plt_i386_dyn::do_fill_plt_entry): ... and here.

Change-Id: Id24b95600489835ff5e860a39c147203d4380c2b
@
text
@a2730 2
  typedef typename elfcpp::Elf_types<size>::Elf_WXword Elf_size_type;

@


1.53
log
@	* incremental-dump.cc (find_input_containing_global): Replace
	magic number with symbolic constant.
	(dump_incremental_inputs): Update version number.
	* incremental.cc (Output_section_incremental_inputs): Update version
	number; import symbolic constants from Incremental_inputs_reader.
	(Incremental_inputs::create_data_sections): Align relocations
	section correctly for 64-bit targets.
	(Output_section_incremental_inputs::set_final_data_size): Use symbolic
	constants; add padding.
	(Output_section_incremental_inputs::write_header): Add assert for
	header_size.
	(Output_section_incremental_inputs::write_input_files): Add assert
	for input_entry_size.
	(Output_section_incremental_inputs::write_info_blocks): Add padding;
	add assert for object_info_size, input_section_entry_size,
	global_sym_entry_size.
	* incremental.h (Incremental_inputs_reader): Add symbolic constants
	for data structure sizes; use them.
	(Incremental_input_entry_reader): Import symbolic constants from
	Incremental_inputs_reader; use them.
@
text
@d3 1
a3 1
// Copyright 2009, 2010, 2011 Free Software Foundation, Inc.
d146 1
a146 1
              "cannot perform incremental link: %s"), buf);
d299 1
a299 1
              && main_strtab_shndx < this->elf_file_.shnum());
d325 1
a325 1
	        new Incremental_library(input_file.filename(), i,
d385 4
a388 4
        {
          gold_assert(p->is_file());
          unsigned int arg_serial = p->file().arg_serial();
          if (arg_serial > 0)
d394 1
a394 1
        }
d424 2
a425 2
      		 "old command line: %s",
      		 inputs.command_line());
d427 2
a428 2
      		 "new command line: %s",
      		 incremental_inputs->command_line().c_str());
d549 1
a549 1
        name = NULL;
d552 5
a556 5
	         i,
	         static_cast<long>(shdr.get_sh_addr()),
	         static_cast<long>(shdr.get_sh_offset()),
	         static_cast<long>(shdr.get_sh_size()),
	         shdr.get_sh_type(), name ? name : "<null>");
d586 1
a586 1
          unsigned int output_symndx =
d595 1
a595 1
	        continue;
d613 1
a613 1
          input_file.get_input_section(i);
d615 1
a615 1
        continue;
d784 1
a784 1
        {
d806 6
a811 6
	      		 "  %08lx: %s + %d: type %d addend %ld",
	      		 (long)(section_offset + r_offset),
	      		 os->name(),
	      		 (int)r_offset,
	      		 r_type,
	      		 (long)r_addend);
d821 1
a821 1
        }
d851 1
a851 1
                              const elfcpp::Ehdr<size, big_endian>& ehdr)
d853 4
a856 3
  Target* target = select_target(ehdr.get_e_machine(), size, big_endian,
                                 ehdr.get_e_ident()[elfcpp::EI_OSABI],
                                 ehdr.get_e_ident()[elfcpp::EI_ABIVERSION]);
d860 1
a860 1
               ehdr.get_e_machine());
d897 1
a897 1
                                               &error))
d907 1
a907 1
        {
d909 2
a910 2
          result = make_sized_incremental_binary<32, true>(
              file, elfcpp::Ehdr<32, true>(p));
d912 1
a912 1
          explain_no_incremental(_("unsupported file: 32-bit, big-endian"));
d914 1
a914 1
        }
d916 1
a916 1
        {
d918 2
a919 2
          result = make_sized_incremental_binary<32, false>(
              file, elfcpp::Ehdr<32, false>(p));
d921 1
a921 1
          explain_no_incremental(_("unsupported file: 32-bit, little-endian"));
d923 1
a923 1
        }
d928 1
a928 1
        {
d930 2
a931 2
          result = make_sized_incremental_binary<64, true>(
              file, elfcpp::Ehdr<64, true>(p));
d933 1
a933 1
          explain_no_incremental(_("unsupported file: 64-bit, big-endian"));
d935 1
a935 1
        }
d937 1
a937 1
        {
d939 2
a940 2
          result = make_sized_incremental_binary<64, false>(
              file, elfcpp::Ehdr<64, false>(p));
d942 1
a942 1
          explain_no_incremental(_("unsupported file: 64-bit, little-endian"));
d944 1
a944 1
        }
d979 1
a979 1
        continue;
d994 8
a1001 8
        {
          const int len = strcspn(argpos, "'");
          args.append(argpos, len);
          if (argpos[len] == '\0')
            break;
          args.append("'\"'\"'");
          argpos += len + 1;
        }
d1007 1
a1007 1
                     &this->command_line_key_);
d1109 1
a1109 1
          new Incremental_object_entry(filename_key, obj, arg_serial, mtime);
d1215 1
a1215 1
          new Output_section_incremental_inputs<32, false>(this, symtab);
d1222 1
a1222 1
          new Output_section_incremental_inputs<32, true>(this, symtab);
d1229 1
a1229 1
          new Output_section_incremental_inputs<64, false>(this, symtab);
d1236 1
a1236 1
          new Output_section_incremental_inputs<64, true>(this, symtab);
d1339 2
a1340 2
	        if (sym->symtab_index() != -1U)
	          ++nsyms_out;
d1488 1
a1488 1
          strtab->get_offset_from_key((*p)->get_filename_key());
d1492 1
a1492 1
        flags |= INCREMENTAL_INPUT_IN_SYSTEM_DIR;
d1494 1
a1494 1
        flags |= INCREMENTAL_INPUT_AS_NEEDED;
d1632 1
a1632 1
		        && !sym->is_copied_from_dynobj())
d1714 2
a1715 2
	        if (sym->symtab_index() == -1U)
	          continue;
d1915 3
a1917 3
        this->info_.sym_index = sym->symtab_index();
        this->info_.input_index = 0;
        Got_visitor v(this->info_);
d2048 1
a2048 1
          this->input_reader_.get_input_section(i - 1);
d2053 1
a2053 1
        continue;
d2078 1
a2078 1
        this->error(_("COMDAT group has no signature"));
d2084 1
a2084 1
        this->error(_("COMDAT group %s included twice in incremental link"),
d2164 1
a2164 1
        st_bind = elfcpp::STB_GLOBAL;
d2197 1
a2197 1
        ++this->defined_count_;
d2490 1
a2490 1
        name = "";
d2593 1
a2593 1
                                    dyn_output_size);
d2637 6
a2642 6
        {
          gold_assert(dyn_ov < dyn_oview + dyn_output_size);
          elfcpp::Sym_write<size, big_endian> osym(dyn_ov);
          osym.put_st_name(dynpool->get_offset(lsym.name));
          osym.put_st_value(lsym.st_value);
          osym.put_st_size(lsym.st_size);
d2645 4
a2648 4
          osym.put_st_other(0);
          osym.put_st_shndx(st_shndx);
          dyn_ov += sym_size;
        }
d2662 1
a2662 1
                            dyn_oview);
d2772 1
a2772 1
        st_bind = elfcpp::STB_GLOBAL;
@


1.52
log
@2012-03-21  Cary Coutant  <ccoutant@@google.com>

	* Makefile.am: Add gdb-index.cc, gdb-index.h.
	* Makefile.in: Regenerate.
	* dwarf_reader.cc (Sized_elf_reloc_mapper::do_initialize): New function.
	(Sized_elf_reloc_mapper::symbol_section): New function.
	(Sized_elf_reloc_mapper::do_get_reloc_target): New function.
	(make_elf_reloc_mapper): New function.
	(Dwarf_abbrev_table::clear_abbrev_codes): New function.
	(Dwarf_abbrev_table::do_read_abbrevs): New function.
	(Dwarf_abbrev_table::do_get_abbrev): New function.
	(Dwarf_ranges_table::read_ranges_table): New function.
	(Dwarf_ranges_table::read_range_list): New function.
	(Dwarf_pubnames_table::read_section): New function.
	(Dwarf_pubnames_table::read_header): New function.
	(Dwarf_pubnames_table::next_name): New function.
	(Dwarf_die::Dwarf_die): New function.
	(Dwarf_die::read_attributes): New function.
	(Dwarf_die::skip_attributes): New function.
	(Dwarf_die::set_name): New function.
	(Dwarf_die::set_linkage_name): New function.
	(Dwarf_die::attribute): New function.
	(Dwarf_die::string_attribute): New function.
	(Dwarf_die::int_attribute): New function.
	(Dwarf_die::uint_attribute): New function.
	(Dwarf_die::ref_attribute): New function.
	(Dwarf_die::child_offset): New function.
	(Dwarf_die::sibling_offset): New function.
	(Dwarf_info_reader::check_buffer): New function.
	(Dwarf_info_reader::parse): New function.
	(Dwarf_info_reader::do_parse): New function.
	(Dwarf_info_reader::do_read_string_table): New function.
	(Dwarf_info_reader::lookup_reloc): New function.
	(Dwarf_info_reader::get_string): New function.
	(Dwarf_info_reader::visit_compilation_unit): New function.
	(Dwarf_info_reader::visit_type_unit): New function.
	(Sized_dwarf_line_info::Sized_dwarf_line_info): Use
	Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::symbol_section): Remove function.
	(Sized_dwarf_line_info::read_relocs): Use Sized_elf_reloc_mapper.
	(Sized_dwarf_line_info::read_line_mappings): Remove object
	parameter, adjust callers.
	(Sized_dwarf_line_info::format_file_lineno): Fix type of cast.
	* dwarf_reader.h: Include <sys/types.h>.
	(class Track_relocs): Remove forward declaration.
	(class Elf_reloc_mapper): New class.
	(class Sized_elf_reloc_mapper): New class.
	(class Dwarf_abbrev_table): New class.
	(class Dwarf_range_list): New class.
	(class Dwarf_ranges_table): New class.
	(class Dwarf_pubnames_table): New class.
	(class Dwarf_die): New class.
	(class Dwarf_info_reader): New class.
	(Sized_dwarf_line_info::read_line_mappings): Remove object parameter.
	(Sized_dwarf_line_info::symbol_section): Remove member function.
	* dynobj.h (Sized_dynobj::do_section_contents): Refactor code from
	base class.
	* gdb-index.cc: New source file.
	* gdb-index.h: New source file.
	* incremental.cc (Sized_relobj_incr::do_layout): Track .debug_info
	and .debug_types sections, call Layout::add_to_gdb_index.
	(Sized_relobj_incr::do_section_name): Implement.
	(Sized_relobj_incr::do_section_contents): Adjust parameter list and
	return type; Implement.
	(Sized_incr_dynobj::do_section_contents): Adjust parameter list and
	return type.
	* incremental.h (Sized_relobj_incr::do_section_contents): Adjust
	parameter list and return type.
	(Sized_incr_dynobj::do_section_contents): Likewise.
	* layout.cc: Include gdb-index.h.
	(Layout::Layout): Initialize gdb_index_data_.
	(Layout::init_fixed_output_section): Check for .gdb_index section.
	(Layout::add_to_gdb_index): New function. Instantiate.
	* layout.h: Add forward declaration for class Gdb_index.
	(Layout::add_to_gdb_index): New member function.
	(Layout::gdb_index_data_): New data member.
	* main.cc: Include gdb-index.h.
	(main): Print statistics for gdb index.
	* object.cc (Object::section_contents): Move code into
	do_section_contents.
	(need_decompressed_section): Check for sections needed when building
	gdb index.
	(build_compressed_section_map): Likewise.
	(Sized_relobj_file::do_read_symbols): Need local symbols when building
	gdb index.
	(Sized_relobj_file::do_layout): Track .debug_info and .debug_types
	sections; call Layout::add_to_gdb_index.
	(Sized_relobj_file::do_decompressed_section_contents): Call
	do_section_contents directly.
	* object.h (Object::do_section_contents): Adjust parameter list and
	return type.
	(Object::do_decompressed_section_contents): Call do_section_contents
	directly.
	(Sized_relobj_file::do_section_contents): Adjust parameter list and
	return type.
	* options.h (class General_options): Add --gdb-index option.
	* plugin.cc (Sized_pluginobj::do_section_contents): Adjust parameter
	list and return type.
	* plugin.h (Sized_pluginobj::do_section_contents): Likewise.
	* reloc.h (Track_relocs::checkpoint): New function.
	(Track_relocs::reset): New function.

	* testsuite/Makefile.am (gdb_index_test_1.sh, gdb_index_test_2.sh):
	New test cases.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/gdb_index_test.cc: New test source file.
	* testsuite/gdb_index_test_1.sh: New test source file.
	* testsuite/gdb_index_test_2.sh: New test source file.
@
text
@d44 4
a47 3
// Version information. Will change frequently during the development, later
// we could think about backward (and forward?) compatibility.
const unsigned int INCREMENTAL_LINK_VERSION = 1;
d116 12
a127 2
  static const int header_size = 16;
  static const int input_entry_size = 24;
d1207 2
d1215 1
d1222 1
d1229 1
d1236 1
d1243 2
a1244 1
  this->relocs_section_ = new Output_data_space(4, "** incremental_relocs");
a1264 2
  const unsigned int sizeof_addr = size / 8;
  const unsigned int rel_size = 8 + 2 * sizeof_addr;
d1308 1
a1308 1
	    info_offset += 28;
d1311 1
a1311 1
			    * (8 + 2 * sizeof_addr));
d1314 1
a1314 1
	    info_offset += syms->size() * 20;
d1360 5
a1364 1
    }
d1374 1
a1374 1
						  * rel_size);
d1465 1
d1500 1
d1574 3
a1576 1
	    pov += 28;
d1608 3
a1610 1
		pov += 8 + 2 * sizeof_addr;
d1663 2
a1664 1
		pov += 20;
d1775 7
@


1.51
log
@Correct incremental relocation offset

2012-01-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* incremental.cc (write_info_blocks): Correct relocation offset.
@
text
@d2005 5
d2023 12
d2052 19
d2232 3
a2234 1
// Get the name of a section.
d2238 1
a2238 1
Sized_relobj_incr<size, big_endian>::do_section_name(unsigned int)
d2240 5
a2244 1
  gold_unreachable();
d2250 15
a2264 4
Object::Location
Sized_relobj_incr<size, big_endian>::do_section_contents(unsigned int)
{
  gold_unreachable();
d2836 5
a2840 2
Object::Location
Sized_incr_dynobj<size, big_endian>::do_section_contents(unsigned int)
@


1.50
log
@	* gold/incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Use abstract base class for GOT.
	* gold/output.h (class Output_data_got_base): New abstract base class.
	(class Output_data_got): Derive from new base class, adjust ctors.
	(Output_data_got::reserve_slot): Make virtual; rename to
	do_reserve_slot; Adjust callers.
	* gold/target.h (Sized_target::init_got_plt_for_update): Return
	pointer to abstract base class.
	* gold/x86_64.cc (Target_x86_64::init_got_plt_for_update): Likewise.
@
text
@d1635 2
a1636 1
		Swap32::writeval(pov + 16, first_reloc * 3 * sizeof_addr);
@


1.49
log
@	* gold/incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* gold/incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* gold/plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.
@
text
@d635 1
a635 1
  Output_data_got<size, big_endian>* got =
@


1.48
log
@	* gold/incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* gold/symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.
@
text
@d1969 3
a1971 2
    symbols_(), incr_reloc_offset_(-1U), incr_reloc_count_(0),
    incr_reloc_output_index_(0), incr_relocs_(NULL), local_symbols_()
d2124 3
d2290 15
a2304 3
    const Symbol_table*, size_t*, size_t*) const
{
  gold_unreachable();
d2598 1
a2598 1
    symbols_()
d2696 1
d2865 16
a2880 3
    const Symbol_table*, size_t*, size_t*) const
{
  gold_unreachable();
@


1.47
log
@	* incremental.cc (can_incremental_update): Fix typo in comment.
	* incremental.h (can_incremental_update): Likewise.
@
text
@d688 1
a688 1
      if (sym->in_reg())
@


1.47.2.1
log
@	Copy from mainline to binutils 2.22 branch:

	2011-12-17  Cary Coutant  <ccoutant@@google.com>

	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
	* resolve.cc (Symbol_table::resolve): Likewise.
	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
	arrays.
	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13023
	* expression.cc (Expression::eval_with_dot): Add
	is_section_dot_assignment parameter.
	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
	absolute and assigning to dot within a section.
	* script-sections.cc
	(Output_section_element_assignment::set_section_addresses): Pass
	dot_section to set_if_absolute.
	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
	as is_section_dot_assignment flag to eval_with_dot.
	(Output_section_element_dot_assignment::set_section_addresses):
	Likewise.
	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
	parameter.  Also set value if relative to dot_section; set the
	symbol's output_section.
	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
	parameter.  Adjust all callers.
	(Expression::eval_maybe_dot): Likewise.
	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
	Adjust all callers.
	* testsuite/script_test_2.t: Test assignment of an absolute value
	to dot within an output section element.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	* options.h (class General_options): Add --[no-]gnu-unique options.
	* symtab.cc (Symbol_table::sized_write_globals): Convert
	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.

	2011-10-31  Cary Coutant  <ccoutant@@google.com>

	PR gold/13359
	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
	unnecessary assertion.
	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.

	2011-10-31 Sriraman Tallam  <tmsriram@@google.com>

	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
	gc_mark_symbol.
	Change to just keep the section associated with symbol.
	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
	they are externally visible and --export-dynamic is turned on.
	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13163
	* script-sections.cc
	(Output_section_element_dot_assignment::needs_output_section): New
	function.

	2011-10-19  Ian Lance Taylor  <iant@@google.com>

	PR gold/13204
	* layout.cc (Layout::segment_precedes): Don't assert failure if a
	--section-start option was seen.
	* options.h (General_options::any_section_start): New function.

	2011-10-18  Cary Coutant  <ccoutant@@google.com>

	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
	(Output_file::map_no_anonymous): Check for non-zero
	return code from posix_fallocate.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13245
	* plugin.cc (is_visible_from_outside): Check for symbols
	referenced from dynamic objects.
	* resolve.cc (Symbol_table::resolve): Don't count references
	from dynamic objects as references from real ELF files.
	* testsuite/plugin_test_2.sh: Adjust expected result.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
	task for members of lib groups.

	2011-10-17  Cary Coutant  <ccoutant@@google.com>

	PR gold/13288
	* fileread.cc (File_read::find_view): Add assert.
	(File_read::make_view): Move bounds check (replace with assert)...
	(File_read::find_or_make_view): ... to here.

	2011-10-12  Cary Coutant  <ccoutant@@google.com>

	* output.cc (Output_file::open_base_file): Handle case where
	::read returns less than requested size.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
	Initialize defined_count_.
	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
	* incremental.h (Sized_relobj_incr::defined_count_): New data
	member.
	(Sized_incr_dynobj::defined_count_): New data member.
	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
	Return zeroes instead of internal error.

	2011-10-10  Cary Coutant  <ccoutant@@google.com>

	PR gold/13249
	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
	(Output_reloc::symbol_value): Return PLT offset if flag is set.
	* output.h (class Output_reloc): Add use_plt_offset flag.
	(Output_reloc::type_): Adjust size of bit field.
	(Output_reloc::use_plt_offset_): New bit field.
	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
	flag.  Adjust all callers.
	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
	creating RELATIVE relocations.

	2011-10-03   Diego Novillo  <dnovillo@@google.com>

	* options.cc (parse_uint): Fix dereference of RETVAL.

	2011-09-29  Cary Coutant  <ccoutant@@google.com>

	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Check for NULL.
	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
	symbols during incremental update.
	(Symbol_table::add_from_dynobj): Likewise.

	2011-09-26  Cary Coutant  <ccoutant@@google.com>

	* gold.cc (queue_initial_tasks): Move option checks ...
	* options.cc (General_options::finalize): ... to here. Disable
	some options; make others fatal.

	2011-09-23  Simon Baldwin  <simonb@@google.com>

	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
	configuration options.
	* configure: Regenerate.
	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
	* Makefile.in: Regenerate.
	* testsuite/Makefile.in: Regenerate.
@
text
@d688 1
a688 1
      if (sym != NULL && sym->in_reg())
d1969 2
a1970 3
    symbols_(), defined_count_(0), incr_reloc_offset_(-1U),
    incr_reloc_count_(0), incr_reloc_output_index_(0), incr_relocs_(NULL),
    local_symbols_()
a2122 3
      if (shndx != elfcpp::SHN_UNDEF)
        ++this->defined_count_;

d2286 3
a2288 15
    const Symbol_table*,
    size_t* defined,
    size_t* used) const
{
  *defined = this->defined_count_;
  size_t count = 0;
  for (typename Symbols::const_iterator p = this->symbols_.begin();
       p != this->symbols_.end();
       ++p)
    if (*p != NULL
	&& (*p)->source() == Symbol::FROM_OBJECT
	&& (*p)->object() == this
	&& (*p)->is_defined())
      ++count;
  *used = count;
d2582 1
a2582 1
    symbols_(), defined_count_(0)
a2679 1
	  ++this->defined_count_;
d2848 3
a2850 16
    const Symbol_table*,
    size_t* defined,
    size_t* used) const
{
  *defined = this->defined_count_;
  size_t count = 0;
  for (typename Symbols::const_iterator p = this->symbols_.begin();
       p != this->symbols_.end();
       ++p)
    if (*p != NULL
	&& (*p)->source() == Symbol::FROM_OBJECT
	&& (*p)->object() == this
	&& (*p)->is_defined()
	&& (*p)->dynsym_index() != -1U)
      ++count;
  *used = count;
@


1.46
log
@	* incremental.cc (can_incremental_update): New function.
	* incremental.h (can_incremental_update): New function.
	* layout.cc (Layout::init_fixed_output_section): Call it.
	(Layout::make_output_section): Don't allow patch space in .eh_frame.
	* object.cc (Sized_relobj_file::do_layout): Call
	can_incremental_update.
@
text
@d164 1
a164 1
// Return TRUE if a section of type SH_TYPE will can be updated in place
@


1.45
log
@	* incremental.cc (Sized_relobj_incr::do_layout): Call
	report_comdat_group for kept comdat sections.
	* testsuite/Makefile.am (incremental_comdat_test_1): New test.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/incr_comdat_test_1.cc: New source file.
	* testsuite/incr_comdat_test_2_v1.cc: New source file.
	* testsuite/incr_comdat_test_2_v2.cc: New source file.
	* testsuite/incr_comdat_test_2_v3.cc: New source file.
@
text
@d164 16
@


1.44
log
@	PR gold/12372
	* target.h (Target::plt_address_for_global): New function.
	(Target::plt_address_for_local): New function.
	(Target::plt_section_for_global): Remove.
	(Target::plt_section_for_local): Remove.
	(Target::do_plt_address_for_global): New virtual function.
	(Target::do_plt_address_for_local): New virtual function.
	(Target::do_plt_section_for_global): Remove.
	(Target::do_plt_section_for_local): Remove.
	(Target::register_global_plt_entry): Add Symbol_table and Layout
	parameters.
	* output.cc (Output_data_got::Got_entry::write): Use
	plt_address_for_global and plt_address_for_local.
	* layout.cc (Layout::add_target_dynamic_tags): Use size and
	address of output section.
	* i386.cc (class Output_data_plt_i386): Add irelative_rel_,
	got_irelative_, and irelative_count_ fields.  Update
	declarations.
	(Output_data_plt_i386::has_irelative_section): New function.
	(Output_data_plt_i386::entry_count): Add irelative_count_.
	(Output_data_plt_i386::set_final_data_size): Likewise.
	(class Target_i386): Add got_irelative_ and rel_irelative_
	fields.  Update declarations.
	(Target_i386::Target_i386): Initialize new fields.
	(Target_i386::do_plt_address_for_global): New function replacing
	do_plt_section_for_global.
	(Target_i386::do_plt_address_for_local): New function replacing
	do_plt_section_for_local.
	(Target_i386::got_section): Create got_irelative_.
	(Target_i386::rel_irelative_section): New function.
	(Output_data_plt_i386::Output_data_plt_i386): Initialize new
	fields.  Don't define __rel_iplt_{start,end}.
	(Output_data_plt_i386::add_entry): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_i386::add_local_ifunc_entry): Add symtab and
	layout parameters.  Change all callers.  Use different PLT and
	GOT.
	(Output_data_plt_i386::rel_tls_desc): Fix formatting.
	(Output_data_plt_i386::rel_irelative): New function.
	(Output_data_plt_i386::address_for_global): New function.
	(Output_data_plt_i386::address_for_local): New function.
	(Output_data_plt_i386::do_write): Write out IRELATIVE area.  Use
	IRELATIVE GOT when changing IFUNC GOT entries.
	(Target_i386::Scan::global): Use IRELATIVE GOT for IRELATIVE
	reloc.
	(Target_i386::do_finalize_sections): Create the __rel_iplt symbols
	if we didn't create an IRELATIVE GOT.
	(Target_i386::Relocate::relocate): Use plt_address_for_global and
	plt_address_for_local.
	(Target_i386::do_dynsym_value): Use plt_address_for_global.
	* x86_64.cc (class Output_data_plt_x86_64): Add irelative_rel_,
	got_irelative_, and irelative_count_ fields.  Update
	declarations.
	(Output_data_plt_x86_64::Output_data_plt_x86_64) [both versions]:
	Initialize new fields.  Remove symtab parameter.  Change all
	callers.
	(Output_data_plt_x86_64::get_tlsdesc_plt_offset): Add
	irelative_count_.
	(Output_data_plt_x86_64::has_irelative_section): New function.
	(Output_data_plt_x86_64::entry_count): Add irelative_count_.
	(class Target_x86_64): Add got_irelative_ and rel_irelative_
	fields.  Update declarations.
	(Target_x86_64::Target_x86_64): Initialize new fields.
	(Target_x86_64::do_plt_address_for_global): New function replacing
	do_plt_section_for_global.
	(Target_x86_64::do_plt_address_for_local): New function replacing
	do_plt_section_for_local.
	(Target_x86_64::got_section): Create got_irelative_.
	(Target_x86_64::rela_irelative_section): New function.
	(Output_data_plt_x86_64::init): Remove symtab parameter.  Change
	all callers.  Don't create __rel_iplt_{start,end}.
	(Output_data_plt_x86_64::add_entry): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_x86_64::add_local_ifunc_entry): Add symtab and
	layout parameters.  Change all callers.  Use different PLT and
	GOT.
	(Output_data_plt_x86_64::add_relocation): Add symtab and layout
	parameters.  Change all callers.  Use different PLT and GOT for
	IFUNC symbols.
	(Output_data_plt_x86_64::rela_tlsdesc): Fix formatting.
	(Output_data_plt_x86_64::rela_irelative): New function.
	(Output_data_plt_x86_64::address_for_global): New function.
	(Output_data_plt_x86_64::address_for_local): New function.
	(Output_data_plt_x86_64::set_final_data_size): Likewise.
	(Output_data_plt_x86_64::do_write): Write out IRELATIVE area.
	(Target_x86_64::init_got_plt_for_update): Create got_irelative_.
	(Target_x86_64::register_global_plt_entry): Add symtab and layout
	parameters.
	(Target_x86_64::Scan::global): Use IRELATIVE GOT for IRELATIVE
	reloc.
	(Target_x86_64::do_finalize_sections): Create the __rela_iplt
	symbols if we didn't create an IRELATIVE GOT.
	(Target_x86_64::Relocate::relocate): Use plt_address_for_global and
	plt_address_for_local.
	(Target_x86_64::do_dynsym_value): Use plt_address_for_global.
	* testsuite/ifuncvar1.c: New test file.
	* testsuite/ifuncvar2.c: New test file.
	* testsuite/ifuncvar3.c: New test file.
	* testsuite/Makefile.am (check_PROGRAMS): Add ifuncvar.
	(ifuncvar1_pic.o, ifuncvar2_pic.o, ifuncvar.so): New targets.
	(ifuncvar_SOURCES, ifuncvar_DEPENDENCIES): New variables.
	(ifuncvar_LDFLAGS, ifuncvar_LDADD): New variables.
	* testsuite/Makefile.in: Rebuild.
@
text
@d2011 3
a2013 1
      if (!keep)
@


1.43
log
@	* gold/incremental.cc
	(Output_section_incremental_inputs::write_info_blocks): Check for
	hidden and internal symbols.
@
text
@d3 1
a3 1
// Copyright 2009, 2010 Free Software Foundation, Inc.
d677 1
a677 1
	  target->register_global_plt_entry(i, sym);
@


1.42
log
@	* incremental.cc (Sized_incremental_binary::do_file_has_changed):
	Check disposition for startup file.
	(Incremental_inputs::report_command_line): Ignore
	--incremental-startup-unchanged option.
	* options.cc (General_options::parse_incremental_startup_unchanged):
	New function.
	(General_options::General_options): Initialize new data member.
	* options.h (Incremental_disposition): Add INCREMENTAL_STARTUP.
	(General_options): Add --incremental-startup-unchanged option.
	(General_options::incremental_startup_disposition): New function.
	(General_options::incremental_startup_disposition_): New data member.
@
text
@d1672 9
a1680 3
		if (sym->source() == Symbol::FROM_OBJECT
		    && sym->object() == obj
		    && sym->is_defined())
@


1.41
log
@	* incremental.cc (Sized_incremental_binary::setup_readers): Pass
	input file index to Script_info ctor.
	(Sized_incremental_binary::do_file_has_changed): Find the
	command-line argument for files named in scripts.
	* incremental.h (Script_info::Script_info): New ctor
	with input file index.
	(Script_info::input_file_index): New function.
	(Script_info::input_file_index_): New data member.
	(Incremental_binary::get_library): Add const.
	(Incremental_binary::get_script_info): Add const.
	* readsyms.cc (Read_member::is_runnable): Check for this_blocker_.
	* testsuite/Makefile.am (incremental_test_5): New test case.
	(incremental_test_6): New test case.
	* testsuite/Makefile.in: Regenerate.
@
text
@d463 6
d947 1
@


1.40
log
@	* incremental.cc (Sized_incremental_binary::do_check_inputs): Add
	debug output when command lines differ.
@
text
@d312 1
a312 1
	    Script_info* script = new Script_info(input_file.filename());
d451 8
@


1.39
log
@	* incremental.cc (Incremental_inputs::report_command_line): Ignore
	--incremental-patch option.
	* layout.cc (Free_list::allocate): Extend allocation beyond original
	end if enabled.
	(Layout::make_output_section): Mark sections that should get
	patch space.
	* options.cc (parse_percent): New function.
	* options.h (parse_percent): New function.
	(DEFINE_percent): New macro.
	(General_options): Add --incremental-patch option.
	* output.cc (Output_section::Output_section): Initialize new data
	members.
	(Output_section::add_input_section): Print section name when out
	of patch space.
	(Output_section::add_output_section_data): Likewise.
	(Output_section::set_final_data_size): Add patch space when
	doing --incremental-full.
	(Output_section::do_reset_address_and_file_offset): Remove patch
	space.
	(Output_segment::set_section_list_addresses): Print debug output
	only if --incremental-update.
	* output.h (Output_section::set_is_patch_space_allowed): New function.
	(Output_section::is_patch_space_allowed_): New data member.
	(Output_section::patch_space_): New data member.
	* parameters.cc (Parameters::incremental_full): New function.
	* parameters.h (Parameters::incremental_full): New function
	* testsuite/Makefile.am (incremental_test_2): Add test for
	--incremental-patch option.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/two_file_test_1_v1.cc (t1, t2, t3): Add comments.
	(t18): Remove function body.
@
text
@d396 6
@


1.38
log
@	* common.cc (Symbol_table::do_allocate_commons_list): For incremental
	update, allocate common from bss section's free list.
	* incremental-dump.cc (dump_incremental_inputs): Print flag for
	linker-defined symbols.
	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
	Skip GOT and PLT entries that are no longer referenced.
	(Output_section_incremental_inputs::write_info_blocks): Mark
	linker-defined symbols.
	(Sized_incr_relobj::do_add_symbols): Process linker-defined symbols.
	* output.cc (Output_section::allocate): New function.
	* output.h (Output_section::allocate): New function.
	* resolve.cc (Symbol_table::report_resolve_problem): Add case for
	linker-defined symbols.
	(Symbol::override_base_with_special): Copy is_predefined_ flag.
	* symtab.cc (Symbol::init_fields): Initialize is_predefined_ flag.
	(Symbol::init_base_output_data): Likewise.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Sized_symbol::init_output_data): Likewise.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(Symbol_table::do_define_in_output_data): Likewise.
	(Symbol_table::do_define_in_output_segment): Likewise.
	(Symbol_table::do_define_as_constant): Likewise.
	* symtab.h (Symbol::is_predefined): New function.
	(Symbol::init_base_output_data): Add is_predefined parameter.
	(Symbol::init_base_output_segment): Likewise.
	(Symbol::init_base_constant): Likewise.
	(Symbol::is_predefined_): New data member.
	(Sized_symbol::init_output_data): Add is_predefined parameter.
	(Sized_symbol::init_output_segment): Likewise.
	(Sized_symbol::init_constant): Likewise.
	(enum Symbol_table::Defined): Add INCREMENTAL_BASE.
@
text
@d928 1
d932 1
@


1.37
log
@	* copy-relocs.cc (Copy_relocs::copy_reloc): Call make_copy_reloc
	instead of emit_copy_reloc.
	(Copy_relocs::emit_copy_reloc): Refactor.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* copy-relocs.h (Copy_relocs::emit_copy_reloc): Move to public
	section.
	(Copy_relocs::make_copy_reloc): New function.
	(Copy_relocs::add_copy_reloc): Remove.
	* gold.cc (queue_middle_tasks): Emit old COPY relocations from
	unchanged input files.
	* incremental-dump.cc (dump_incremental_inputs): Print "COPY" flag.
	* incremental.cc (Sized_incremental_binary::do_reserve_layout):
	Reserve BSS space for COPY relocations.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Output_section_incremental_inputs::write_info_blocks): Record
	whether a symbol is copied from a shared object.
	(Sized_incr_dynobj::do_add_symbols): Record COPY relocations.
	* incremental.h (enum Incremental_shlib_symbol_flags): New type.
	(INCREMENTAL_SHLIB_SYM_FLAGS_SHIFT): New constant.
	(Incremental_input_entry_reader::get_output_symbol_index): Add
	is_copy parameter.
	(Incremental_binary::emit_copy_relocs): New function.
	(Incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data member.
	(Sized_incremental_binary::add_copy_reloc): New function.
	(Sized_incremental_binary::do_emit_copy_relocs): New function.
	(Sized_incremental_binary::Copy_reloc): New struct.
	(Sized_incremental_binary::Copy_relocs): New typedef.
	(Sized_incremental_binary::copy_relocs_): New data member.
	* symtab.cc (Symbol_table::add_from_incrobj): Change return type.
	* symtab.h (Symbol_table::add_from_incrobj): Change return type.
	* target.h (Sized_target::emit_copy_reloc): New function.
	* x86_64.cc (Target_x86_64::emit_copy_reloc): New function.
@
text
@d633 8
a640 4
	  gold_debug(DEBUG_INCREMENTAL,
		     "GOT entry %d, type %02x: %s",
		     i, got_type, sym->name());
	  target->reserve_global_got_entry(i, sym, got_type);
d651 8
a658 4
      gold_debug(DEBUG_INCREMENTAL,
		 "PLT entry %d: %s",
		 i, sym->name());
      target->register_global_plt_entry(i, sym);
d1559 11
a1569 3
		if (sym->source() == Symbol::FROM_OBJECT
		    && sym->object() == obj
		    && sym->is_defined())
d1575 2
d2047 1
a2047 1
      if (input_shndx == 0)
d2074 34
a2107 4
      this->symbols_[i] =
	symtab->add_from_incrobj(this, name, NULL, &sym);
      this->ibase_->add_global_symbol(output_symndx - first_global,
				      this->symbols_[i]);
@


1.36
log
@	* incremental-dump.cc (dump_incremental_inputs): Print COMDAT groups.
	* incremental.cc (Incremental_inputs::report_input_section): Fix
	comment, indentation.
	(Incremental_inputs::report_comdat_group): New function.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of data for incremental input file entry.
	(Output_section_incremental_inputs::write_info_blocks): Write COMDAT
	group count, COMDAT group signatures.
	(Sized_incr_relobj::do_layout): Record kept COMDAT group info from
	an unchanged input file.
	* incremental.h (Incremental_object_entry::Incremental_object_entry):
	Initialize new data member.
	(Incremental_object_entry::add_comdat_group): New function.
	(Incremental_object_entry::get_comdat_group_count): New function.
	(Incremental_object_entry::get_comdat_signature_key): New function.
	(Incremental_object_entry::groups_): New data member.
	(Incremental_inputs::report_comdat_group): New function.
	(Incremental_input_entry_reader::get_symbol_offset): Adjust size of
	data for incremental input file entry.
	(Incremental_input_entry_reader::get_comdat_group_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	data for incremental input file entry.
	(Incremental_input_entry_reader::get_global_symbol_reader): Likewise.
	(Incremental_input_entry_reader::get_comdat_group_signature): New
	function.
	* object.cc (Sized_relobj::include_section_group): Report kept
	COMDAT groups for incremental links.
@
text
@d25 1
d522 2
d528 33
a560 1
    return;
d654 20
d1603 3
a1605 1
	    const Object* obj = entry->object();
d1630 1
a1630 1
		unsigned int def_flag = 0;
d1634 6
a1639 2
		  def_flag = 1U << 31;
		Swap32::writeval(pov, sym->symtab_index() | def_flag);
d2545 6
d2555 1
d2557 1
a2557 1
	  this->input_reader_.get_output_symbol_index(i, &is_def);
d2564 1
a2564 1
      typename elfcpp::Elf_types<size>::Elf_Addr v;
d2594 3
a2596 2
      this->symbols_[i] =
	symtab->add_from_incrobj<size, big_endian>(this, name, NULL, &sym);
d2599 13
@


1.35
log
@	* gold.cc (queue_initial_tasks): Pass incremental base filename
	to Output_file::open_base_file; don't print error message.
	* incremental-dump.cc (main): Adjust call to
	Output_file::open_for_modification.
	* incremental-dump.cc (main): Likewise.
	* incremental.cc (Incremental_inputs::report_command_line):
	Ignore --incremental-base option when comparing command lines.
	Ignore parameter when given as separate argument.
	* options.h (class General_options): Add --incremental-base.
	* output.cc (Output_file::Output_file):
	(Output_file::open_base_file): Add base_name and writable parameters;
	read base file into new file; print error message here.
	(Output_file::map_no_anonymous): Add writable parameter; adjust all
	callers.
	* output.h (Output_file::open_for_modification): Rename to...
	(Output_file::open_base_file): ...this; add base_name and
	writable parameters; adjust all callers.
	(Output_file::map_no_anonymous): Add writable parameter; adjust all
	callers.
	* testsuite/Makefile.am (incremental_test_4): Test
	--incremental-base.
	* testsuite/Makefile.in: Regenerate.
@
text
@d1031 1
a1031 3
// Record the input object file OBJ.  If ARCH is not NULL, attach
// the object file to the archive.  This is called by the
// Add_symbols task after finding out the type of the file.
d1040 1
a1040 1
      this->strtab_->add(name, true, &key);
d1047 14
d1188 3
a1190 2
	    // local symbol count, first dynamic reloc, dynamic reloc count.
	    info_offset += 24;
d1197 2
d1442 1
d1449 2
a1450 1
	    pov += 24;
d1527 11
d1893 14
@


1.34
log
@	* dynobj.h (Dynobj::do_dynobj): New function.
	* incremental-dump.cc (dump_incremental_inputs): Print as_needed
	flag and soname for shared objects.
	* incremental.cc (Incremental_inputs::report_object): Make
	either Incremental_object_entry or Incremental_dynobj_entry; add
	soname to string table.
	(Incremental_inputs::report_input_section): Add assertion.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	type of input file entry for shared libraries; adjust size of
	shared library info entry.
	(Output_section_incremental_inputs::write_input_files): Write
	as_needed flag for shared libraries.
	(Output_section_incremental_inputs::write_info_blocks): Adjust type
	of input file entry for shared libraries; write soname.
	(Sized_incr_dynobj::Sized_incr_dynobj): Read as_needed flag and
	soname from incremental info.
	* incremental.h (enum Incremental_input_flags): Add
	INCREMENTAL_INPUT_AS_NEEDED.
	(Incremental_input_entry::Incremental_input_entry): Initialize new
	data member.
	(Incremental_input_entry::set_as_needed): New function.
	(Incremental_input_entry::as_needed): New function.
	(Incremental_input_entry::do_dynobj_entry): New function.
	(Incremental_input_entry::as_needed_): New data member.
	(Incremental_object_entry::Incremental_object_entry): Don't check
	for shared library.
	(Incremental_object_entry::do_type): Likewise.
	(class Incremental_dynobj_entry): New class.
	(Incremental_input_entry_reader::as_needed): New function.
	(Incremental_input_entry_reader::get_soname): New function.
	(Incremental_input_entry_reader::get_global_symbol_count): Rewrite.
	(Incremental_input_entry_reader::get_output_symbol_index): Adjust
	size of shared library info entry.
	* layout.cc (Layout::finish_dynamic_section): Don't test for
	incremental link when adding DT_NEEDED entries.
	* object.h (Object::Object): Initialize new data member.
	(Object::dynobj): New function.
	(Object::set_as_needed): New function.
	(Object::as_needed): New function.
	(Object::do_dynobj): New function.
	(Object::as_needed_): New data member.
@
text
@d864 1
d867 8
@


1.33
log
@	* incremental-dump.cc (dump_incremental_inputs): Print dynamic reloc
	info; adjust display of GOT entries.
	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	vector of input objects; remove file_status_.
	(Sized_incremental_binary::do_reserve_layout): Remove file_status_.
	(Sized_incremental_binary::do_process_got_plt): Adjust calls to
	got_plt reader; call target hooks to reserve GOT entries.
	(Output_section_incremental_inputs::set_final_data_size): Adjust size
	of input file info header and GOT info entry.
	(Output_section_incremental_inputs::write_info_blocks): Write dynamic
	relocation info.
	(Got_plt_view_info::got_descriptor): Remove.
	(Got_plt_view_info::sym_index): New data member.
	(Got_plt_view_info::input_index): New data member.
	(Local_got_offset_visitor::visit): Write input file index.
	(Global_got_offset_visitor::visit): Write 0 for input file index.
	(Global_symbol_visitor_got_plt::operator()): Replace got_descriptor
	with sym_index and input_index.
	(Output_section_incremental_inputs::write_got_plt): Adjust size of
	incremental info GOT entry; replace got_descriptor with input_index.
	(Sized_relobj_incr::Sized_relobj_incr): Adjust initializers; record
	map from input file index to object.
	(Sized_relobj_incr::do_layout): Replace direct data member reference
	with accessor function.
	(Sized_relobj_incr::do_for_all_local_got_entries): Move to base class.
	* incremental.h (Incremental_input_entry_reader::get_symbol_offset):
	Adjust size of input file info header.
	(Incremental_input_entry_reader::get_first_dyn_reloc): New function.
	(Incremental_input_entry_reader::get_dyn_reloc_count): New function.
	(Incremental_input_entry_reader::get_input_section): Adjust size of
	input file info header.
	(Incremental_got_plt_reader::Incremental_got_plt_reader): Adjust size
	of incremental info GOT entry.
	(Incremental_got_plt_reader::get_got_desc): Remove.
	(Incremental_got_plt_reader::get_got_symndx): New function.
	(Incremental_got_plt_reader::get_got_input_index): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Remove
	file_status_; add input_objects_.
	(Sized_incremental_binary::~Sized_incremental_binary): Remove.
	(Sized_incremental_binary::set_file_is_unchanged): Remove.
	(Sized_incremental_binary::file_is_unchanged): Remove.
	(Sized_incremental_binary::set_input_object): New function.
	(Sized_incremental_binary::input_object): New function.
	(Sized_incremental_binary::file_status_): Remove.
	(Sized_incremental_binary::input_objects_): New data member.
	(Sized_relobj_incr): Rename Sized_incr_relobj to this; adjust all
	references.
	(Sized_relobj_incr::invalid_address): Move to base class.
	(Sized_relobj_incr::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_incr::do_output_section_offset): Likewise.
	(Sized_relobj_incr::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_incr::section_offsets_): Likewise.
	* object.cc (Sized_relobj::do_for_all_local_got_entries): New
	function.
	(Sized_relobj_file::Sized_relobj_file): Remove local_got_offsets_.
	(Sized_relobj_file::layout_section): Replace refs to section_offsets_
	with accessor function.
	(Sized_relobj_file::do_layout): Likewise.
	(Sized_relobj_file::do_layout_deferred_sections): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Move to base class.
	(Sized_relobj_file::compute_final_local_value): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::do_finalize_local_symbols): Likewise.
	* object.h (Relobj::Relobj): Initialize new data members.
	(Relobj::add_dyn_reloc): New function.
	(Relobj::first_dyn_reloc): New function.
	(Relobj::dyn_reloc_count): New function.
	(Relobj::first_dyn_reloc_): New data member.
	(Relobj::dyn_reloc_count_): New data member.
	(Sized_relobj): Rename Sized_relobj_base to this; adjust all
	references.
	(Sized_relobj::Address): New typedef.
	(Sized_relobj::invalid_address): Move here from child class.
	(Sized_relobj::Sized_relobj): Initialize new data members.
	(Sized_relobj::sized_relobj): New function.
	(Sized_relobj::is_output_section_offset_invalid): Move here from
	child class.
	(Sized_relobj::get_output_section_offset): Likewise.
	(Sized_relobj::local_has_got_offset): Likewise.
	(Sized_relobj::local_got_offset): Likewise.
	(Sized_relobj::set_local_got_offset): Likewise.
	(Sized_relobj::do_for_all_local_got_entries): Likewise.
	(Sized_relobj::clear_got_offsets): New function.
	(Sized_relobj::section_offsets): Move here from child class.
	(Sized_relobj::do_output_section_offset): Likewise.
	(Sized_relobj::do_set_section_offset): Likewise.
	(Sized_relobj::Local_got_offsets): Likewise.
	(Sized_relobj::local_got_offsets_): Likewise.
	(Sized_relobj::section_offsets_): Likewise.
	(Sized_relobj_file): Rename Sized_relobj to this; adjust all
	references.
	(Sized_relobj_file::is_output_section_offset_invalid): Move to base
	class.
	(Sized_relobj_file::sized_relobj): New function
	(Sized_relobj_file::local_has_got_offset): Move to base class.
	(Sized_relobj_file::local_got_offset): Likewise.
	(Sized_relobj_file::set_local_got_offset): Likewise.
	(Sized_relobj_file::get_output_section_offset): Likewise.
	(Sized_relobj_file::do_for_all_local_got_entries): Likewise.
	(Sized_relobj_file::do_output_section_offset): Likewise.
	(Sized_relobj_file::do_set_section_offset): Likewise.
	(Sized_relobj_file::Local_got_offsets): Likewise.
	(Sized_relobj_file::local_got_offsets_): Likewise.
	(Sized_relobj_file::section_offsets_): Likewise.
	* output.cc (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors).
	(set_needs_dynsym_index): Convert relobj to derived class pointer.
	(Output_reloc::get_symbol_index): Likewise.
	(Output_reloc::local_section_offset): Likewise.
	(Output_reloc::get_address): Likewise.
	(Output_reloc::symbol_value): Likewise.
	(Output_data_got::reserve_slot): Move to class definition.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_slot_for_global): Remove.
	(Output_data_got::reserve_global): New function.
	* output.h (Output_reloc::Output_reloc): Adjust type of relobj
	(all constructors, two instantiations).
	(Output_reloc::get_relobj): New function (two instantiations).
	(Output_reloc::u1_.relobj, Output_reloc::u2_.relobj): Adjust type.
	(Output_data_reloc_base::add): Convert relobj to derived class pointer.
	(Output_data_reloc::add_global): Adjust type of relobj.
	(Output_data_reloc::add_global_relative): Likewise.
	(Output_data_reloc::add_symbolless_global_addend): Likewise.
	(Output_data_reloc::add_local): Likewise.
	(Output_data_reloc::add_local_relative): Likewise.
	(Output_data_reloc::add_symbolless_local_addend): Likewise.
	(Output_data_reloc::add_local_section): Likewise.
	(Output_data_reloc::add_output_section): Likewise.
	(Output_data_reloc::add_absolute): Likewise.
	(Output_data_reloc::add_target_specific): Likewise.
	(Output_data_got::reserve_slot): Move definition here.
	(Output_data_got::reserve_local): New function.
	(Output_data_got::reserve_global): New function.
	* reloc.cc (Sized_relobj_file::do_read_relocs): Replace refs to
	section_offsets_ with accessor function.
	(Sized_relobj_file::write_sections): Likewise.
	(Sized_relobj_file::do_relocate_sections): Likewise.
	* target.h (Sized_target::reserve_local_got_entry): New function.
	(Sized_target::reserve_global_got_entry): New function.
	* x86_64.cc (Target_x86_64::reserve_local_got_entry): New function.
	(Target_x86_64::reserve_global_got_entry): New function.
	(Target_x86_64::init_got_plt_for_update): Create rela_dyn section.
@
text
@a977 5
  Incremental_object_entry* obj_entry =
      new Incremental_object_entry(filename_key, obj, arg_serial, mtime);
  if (obj->is_in_system_directory())
    obj_entry->set_is_in_system_directory();
  this->inputs_.push_back(obj_entry);
d979 17
a995 1
  if (arch != NULL)
d997 7
a1003 3
      Incremental_archive_entry* arch_entry = arch->incremental_info();
      gold_assert(arch_entry != NULL);
      arch_entry->add_object(obj_entry);
d1006 8
d1018 1
a1018 1
      script_entry->add_object(obj_entry);
a1019 3

  this->current_object_ = obj;
  this->current_object_entry_ = obj_entry;
d1036 1
d1179 1
a1179 1
	    Incremental_object_entry* entry = (*p)->object_entry();
d1182 2
a1183 2
	    // Global symbol count.
	    info_offset += 4;
d1345 2
d1509 1
a1509 1
	    Incremental_object_entry* entry = (*p)->object_entry();
d1514 6
d2379 3
@


1.32
log
@	* gold.cc (queue_middle_tasks): Process existing GOT/PLT entries.
	* incremental-dump.cc (dump_incremental_inputs): Mask high-order
	bit when checking got_type.
	* incremental.cc (Sized_incremental_binary::setup_readers):
	Store symbol table and string table locations; initialize bit vector
	of file status flags.
	(Sized_incremental_binary::do_reserve_layout): Set bit flag for
	unchanged files.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::get_symtab_view): Use stored locations.
	(Output_section_incremental_inputs::set_final_data_size): Record
	file index for each input file.
	(Output_section_incremental_inputs::write_got_plt): Store file index
	instead of input entry offset for each GOT entry.
	* incremental.h
	(Incremental_input_entry::Incremental_input_entry): Initialize new
	data member.
	(Incremental_input_entry::set_offset): Store file index.
	(Incremental_input_entry::get_file_index): New function.
	(Incremental_input_entry::file_index_): New data member.
	(Incremental_binary::process_got_plt): New function.
	(Incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data members.
	(Sized_incremental_binary::~Sized_incremental_binary): New destructor.
	(Sized_incremental_binary::set_file_is_unchanged): New function.
	(Sized_incremental_binary::file_is_unchanged): New function.
	(Sized_incremental_binary::do_process_got_plt): New function.
	(Sized_incremental_binary::file_status_): New data member.
	(Sized_incremental_binary::main_symtab_loc_): New data member.
	(Sized_incremental_binary::main_strtab_loc_): New data member.
	* output.cc (Output_data_got::Got_entry::write): Add case
	RESERVED_CODE.
	(Output_data_got::add_global): Call add_got_entry.
	(Output_data_got::add_global_plt): Likewise.
	(Output_data_got::add_global_with_rel): Likewise.
	(Output_data_got::add_global_with_rela): Likewise.
	(Output_data_got::add_global_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_global_pair_with_rela): Likewise.
	(Output_data_got::add_local): Call add_got_entry.
	(Output_data_got::add_local_plt): Likewise.
	(Output_data_got::add_local_with_rel): Likewise.
	(Output_data_got::add_local_with_rela): Likewise.
	(Output_data_got::add_local_pair_with_rel): Call add_got_entry_pair.
	(Output_data_got::add_local_pair_with_rela): Likewise.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_section::add_output_section_data): Edit FIXME.
	* output.h
	(Output_section_data_build::Output_section_data_build): New
	constructor with size parameter.
	(Output_data_space::Output_data_space): Likewise.
	(Output_data_got::Output_data_got): Initialize new data member; new
	constructor with size parameter.
	(Output_data_got::add_constant): Call add_got_entry.
	(Output_data_got::reserve_slot): New function.
	(Output_data_got::reserve_slot_for_global): New function.
	(class Output_data_got::Got_entry): Add RESERVED_CODE.
	(Output_data_got::add_got_entry): New function.
	(Output_data_got::add_got_entry_pair): New function.
	(Output_data_got::free_list_): New data member.
	* target.h (Sized_target::init_got_plt_for_update): New function.
	(Sized_target::register_global_plt_entry): New function.
	* x86_64.cc (Output_data_plt_x86_64::Output_data_plt_x86_64):
	Initialize new data member; call init; add constructor with PLT count.
	(Output_data_plt_x86_64::init): New function.
	(Output_data_plt_x86_64::add_relocation): New function.
	(Output_data_plt_x86_64::reserve_slot): New function.
	(Output_data_plt_x86_64::free_list_): New data member.
	(Target_x86_64::init_got_plt_for_update): New function.
	(Target_x86_64::register_global_plt_entry): New function.
	(Output_data_plt_x86_64::add_entry): Allocate from free list for
	incremental updates.
	(Output_data_plt_x86_64::add_relocation): New function.
	* testsuite/object_unittest.cc (Object_test): Set default options.
@
text
@d279 1
a330 4
  // Initialize the status of each input file.
  this->file_status_ = new unsigned char[(count + 7) / 8];
  memset(this->file_status_, 0, (count + 7) / 8);

a523 2
  this->set_file_is_unchanged(input_file_index);

d577 1
a577 1
      unsigned int got_desc = got_plt_reader.get_got_desc(i);
d580 3
a582 3
	  // This is an entry for a local symbol.  GOT_DESC is the index
	  // of the object file entry in the list of input files.  Ignore
	  // this entry if the object file was replaced.
d586 4
a589 2
	  if (this->file_is_unchanged(got_desc))
	    got->reserve_slot(i);
d596 2
a597 2
	  gold_assert(got_desc >= first_global && got_desc < symtab_count);
	  Symbol* sym = this->global_symbol(got_desc - first_global);
d601 1
a601 1
	  got->reserve_slot_for_global(i, sym, got_type);
d1146 2
a1147 2
	    // local symbol count.
	    info_offset += 16;
d1216 1
a1216 1
  got_plt_size += got_count * 4 + plt_count * 4;  // GOT array, PLT array.
d1393 2
d1399 3
a1401 1
	    pov += 16;
d1596 8
a1603 5
  // Value to write in the GOT descriptor array.  For global symbols,
  // this is the global symbol table index; for local symbols, it is
  // the offset of the input file entry in the .gnu_incremental_inputs
  // section.
  unsigned int got_descriptor;
d1628 3
a1630 2
    unsigned char* pov = this->info_.got_desc_p + got_index * 4;
    elfcpp::Swap<32, big_endian>::writeval(pov, this->info_.got_descriptor);
d1660 3
a1662 2
    unsigned char* pov = this->info_.got_desc_p + got_index * 4;
    elfcpp::Swap<32, big_endian>::writeval(pov, this->info_.got_descriptor);
d1689 2
a1690 1
        this->info_.got_descriptor = sym->symtab_index();
d1729 1
a1729 1
  view_info.plt_desc_p = view_info.got_desc_p + view_info.got_count * 4;
d1755 1
a1755 1
      view_info.got_descriptor = (*p)->get_file_index();
d1765 1
a1765 1
// Class Sized_incr_relobj.  Most of these methods are not used for
d1770 1
a1770 1
Sized_incr_relobj<size, big_endian>::Sized_incr_relobj(
d1774 1
a1774 1
  : Sized_relobj_base<size, big_endian>(name, NULL), ibase_(ibase),
d1779 2
a1780 3
    symbols_(), section_offsets_(), incr_reloc_offset_(-1U),
    incr_reloc_count_(0), incr_reloc_output_index_(0), incr_relocs_(NULL),
    local_symbols_()
d1786 1
d1793 1
a1793 1
Sized_incr_relobj<size, big_endian>::do_read_symbols(Read_symbols_data*)
d1802 1
a1802 1
Sized_incr_relobj<size, big_endian>::do_layout(
d1812 1
a1812 1
  this->section_offsets_.resize(shnum);
d1825 1
a1825 1
      this->section_offsets_[i] = static_cast<Address>(sect.sh_offset);
d1833 1
a1833 1
Sized_incr_relobj<size, big_endian>::do_layout_deferred_sections(Layout*)
d1841 1
a1841 1
Sized_incr_relobj<size, big_endian>::do_add_symbols(
d1926 1
a1926 1
Sized_incr_relobj<size, big_endian>::do_should_include_member(
d1939 1
a1939 1
Sized_incr_relobj<size, big_endian>::do_for_all_global_symbols(
a1945 11
// Iterate over local symbols, calling a visitor class V for each GOT offset
// associated with a local symbol.

template<int size, bool big_endian>
void
Sized_incr_relobj<size, big_endian>::do_for_all_local_got_entries(
    Got_offset_list::Visitor*) const
{
  // FIXME: Implement Sized_incr_relobj::do_for_all_local_got_entries.
}

d1950 1
a1950 1
Sized_incr_relobj<size, big_endian>::do_section_size(unsigned int)
d1959 1
a1959 1
Sized_incr_relobj<size, big_endian>::do_section_name(unsigned int)
d1968 1
a1968 1
Sized_incr_relobj<size, big_endian>::do_section_contents(unsigned int)
d1977 1
a1977 1
Sized_incr_relobj<size, big_endian>::do_section_flags(unsigned int)
d1986 1
a1986 1
Sized_incr_relobj<size, big_endian>::do_section_entsize(unsigned int)
d1995 1
a1995 1
Sized_incr_relobj<size, big_endian>::do_section_address(unsigned int)
d2004 1
a2004 1
Sized_incr_relobj<size, big_endian>::do_section_type(unsigned int)
d2013 1
a2013 1
Sized_incr_relobj<size, big_endian>::do_section_link(unsigned int)
d2022 1
a2022 1
Sized_incr_relobj<size, big_endian>::do_section_info(unsigned int)
d2031 1
a2031 1
Sized_incr_relobj<size, big_endian>::do_section_addralign(unsigned int)
d2040 1
a2040 1
Sized_incr_relobj<size, big_endian>::do_initialize_xindex()
d2049 1
a2049 1
Sized_incr_relobj<size, big_endian>::do_get_global_symbol_counts(
d2059 1
a2059 1
Sized_incr_relobj<size, big_endian>::do_read_relocs(Read_relocs_data*)
d2068 1
a2068 1
Sized_incr_relobj<size, big_endian>::do_gc_process_relocs(Symbol_table*,
d2079 1
a2079 1
Sized_incr_relobj<size, big_endian>::do_scan_relocs(Symbol_table*,
d2124 1
a2124 1
Sized_incr_relobj<size, big_endian>::do_count_local_symbols(
d2165 1
a2165 1
Sized_incr_relobj<size, big_endian>::do_finalize_local_symbols(
d2179 1
a2179 1
Sized_incr_relobj<size, big_endian>::do_set_local_dynsym_indexes(
d2190 1
a2190 1
Sized_incr_relobj<size, big_endian>::do_set_local_dynsym_offset(off_t)
d2203 1
a2203 1
Sized_incr_relobj<size, big_endian>::do_relocate(const Symbol_table*,
d2329 1
a2329 1
Sized_incr_relobj<size, big_endian>::do_set_section_offset(unsigned int,
d2616 1
a2616 1
	  obj = new Sized_incr_relobj<32, false>(name, sized_ibase,
d2630 1
a2630 1
	  obj = new Sized_incr_relobj<32, true>(name, sized_ibase,
d2644 1
a2644 1
	  obj = new Sized_incr_relobj<64, false>(name, sized_ibase,
d2658 1
a2658 1
	  obj = new Sized_incr_relobj<64, true>(name, sized_ibase,
d2704 1
a2704 1
class Sized_incr_relobj<32, false>;
d2715 1
a2715 1
class Sized_incr_relobj<32, true>;
d2726 1
a2726 1
class Sized_incr_relobj<64, false>;
d2737 1
a2737 1
class Sized_incr_relobj<64, true>;
@


1.31
log
@	* incremental-dump.cc (dump_incremental_inputs): Print local
	symbol info for each input file.
	* incremental.cc
	(Output_section_incremental_inputs::set_final_data_size): Add local
	symbol info to input file entries in incremental info.
	(Output_section_incremental_inputs::write_info_blocks): Likewise.
	(Sized_incr_relobj::Sized_incr_relobj): Initialize new data members.
	(Sized_incr_relobj::do_add_symbols): Cosmetic change.
	(Sized_incr_relobj::do_count_local_symbols): Replace stub with
	implementation.
	(Sized_incr_relobj::do_finalize_local_symbols): Likewise.
	(Sized_incr_relobj::do_relocate): Write the local symbols.
	(Sized_incr_dynobj::do_add_symbols): Cosmetic change.
	* incremental.h (Incremental_inputs_reader::get_symbol_offset):
	Adjust size of input file header.
	(Incremental_inputs_reader::get_local_symbol_offset): New function.
	(Incremental_inputs_reader::get_local_symbol_count): New function.
	(Incremental_inputs_reader::get_input_section): Adjust size of input
	file header.
	(Incremental_inputs_reader::get_global_symbol_reader): Likewise.
	(Sized_incr_relobj::This): New typedef.
	(Sized_incr_relobj::sym_size): New const data member.
	(Sized_incr_relobj::Local_symbol): New struct.
	(Sized_incr_relobj::do_output_local_symbol_count): New function.
	(Sized_incr_relobj::do_local_symbol_offset): New function.
	(Sized_incr_relobj::local_symbol_count_): New data member.
	(Sized_incr_relobj::output_local_dynsym_count_): New data member.
	(Sized_incr_relobj::local_symbol_index_): New data member.
	(Sized_incr_relobj::local_symbol_offset_): New data member.
	(Sized_incr_relobj::local_dynsym_offset_): New data member.
	(Sized_incr_relobj::local_symbols_): New data member.
	* object.h (Relobj::output_local_symbol_count): New function.
	(Relobj::local_symbol_offset): New function.
	(Relobj::do_output_local_symbol_count): New function.
	(Relobj::do_local_symbol_offset): New function.
	(Sized_relobj::do_output_local_symbol_count): New function.
	(Sized_relobj::do_local_symbol_offset): New function.
@
text
@d261 13
d330 4
d527 2
d545 77
d727 6
a732 14
  unsigned int symtab_shndx =
      this->elf_file_.find_section_by_type(elfcpp::SHT_SYMTAB);
  gold_assert(symtab_shndx != elfcpp::SHN_UNDEF);
  Location symtab_location(this->elf_file_.section_contents(symtab_shndx));
  *symtab_view = this->view(symtab_location);
  *nsyms = symtab_location.data_size / elfcpp::Elf_sizes<size>::sym_size;

  unsigned int strtab_shndx = this->elf_file_.section_link(symtab_shndx);
  gold_assert(strtab_shndx != elfcpp::SHN_UNDEF
              && strtab_shndx < this->elf_file_.shnum());

  Location strtab_location(this->elf_file_.section_contents(strtab_shndx));
  View strtab_view(this->view(strtab_location));
  *strtab = elfcpp::Elf_strtab(strtab_view.data(), strtab_location.data_size);
d1113 1
d1123 3
a1125 2
      // Set the offset of the input file entry.
      (*p)->set_offset(input_offset);
d1748 1
a1748 1
      view_info.got_descriptor = (*p)->get_offset();
@


1.30
log
@	* incremental.cc (Sized_incremental_binary::setup_readers): Allocate
	global symbol map.
	(Sized_incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incr_relobj::do_add_symbols): Add symbols to global symbol map.
	(Sized_incr_relobj::do_relocate): Remap section indices in incremental
	relocations.
	(Sized_incr_dynobj::do_add_symbols): Add symbols to global symbol map.
	(Sized_incr_dynobj::do_for_all_global_symbols): Remove FIXME.
	(Sized_incr_dynobj::do_for_all_local_got_entries): Likewise.
	* incremental.h
	(Incremental_inputs_reader::global_symbol_reader_at_offset): New
	function.
	(Incremental_binary::apply_incremental_relocs): New function.
	(Incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize new
	data member.
	(Sized_incremental_binary::add_global_symbol): New function.
	(Sized_incremental_binary::global_symbol): New function.
	(Sized_incremental_binary::do_apply_incremental_relocs): New function.
	(Sized_incremental_binary::symbol_map_): New data member.
	* layout.cc (Layout_task_runner::run): Apply incremental relocations.
	* target.h (Sized_target::apply_relocation): New function.
	* target-reloc.h (apply_relocation): New function.
	* x86_64.cc (Target_x86_64::apply_relocation): New function.
@
text
@d1058 3
a1060 2
	    // Input section count + global symbol count.
	    info_offset += 8;
d1299 1
d1304 2
d1308 3
a1310 1
	    pov += 8;
d1680 2
d1683 2
a1684 1
    incr_reloc_count_(0), incr_reloc_output_index_(0), incr_relocs_(NULL)
d1768 1
a1768 1
  unsigned const char* sym_p;
d2039 1
a2039 1
    Stringpool_template<char>*,
d2042 31
a2072 1
  // FIXME: Count local symbols.
d2081 1
a2081 1
    off_t,
d2084 3
a2086 2
  // FIXME: Finalize local symbols.
  return index;
d2152 85
d2315 1
a2315 1
  unsigned const char* sym_p;
@


1.29
log
@	* incremental.cc (Sized_incr_relobj::do_add_symbols): Always
	initialize local variable v.
@
text
@d313 4
d526 96
d1755 3
a1757 4
  // Incremental_symtab_reader<big_endian> isymtab(this->ibase_->symtab_reader());
  // Incremental_relocs_reader<size, big_endian> irelocs(this->ibase_->relocs_reader());
  // unsigned int isym_count = isymtab.symbol_count();
  // unsigned int first_global = symtab_count - isym_count;
d1764 2
a1765 1
      sym_p = symtab_view.data() + info.output_symndx() * sym_size;
d1811 2
d2098 13
d2186 3
a2188 4
  // Incremental_symtab_reader<big_endian> isymtab(this->ibase_->symtab_reader());
  // Incremental_relocs_reader<size, big_endian> irelocs(this->ibase_->relocs_reader());
  // unsigned int isym_count = isymtab.symbol_count();
  // unsigned int first_global = symtab_count - isym_count;
d2234 2
a2270 1
  // FIXME: Implement Sized_incr_dynobj::do_for_all_local_got_entries.
@


1.28
log
@	* archive.cc (Archive::include_member): Adjust call to
	report_object.
	(Add_archive_symbols::run): Track argument serial numbers.
	(Lib_group::include_member): Likewise.
	(Add_lib_group_symbols::run): Adjust call to report_archive_begin.
	* archive.h (Incremental_archive_entry::Archive_member):
	Initialize arg_serial_.
	(Archive_member::arg_serial_): New data member.
	* dynobj.cc (Dynobj::Dynobj): Allow input_file_ to be NULL.
	(Sized_dynobj::do_add_symbols): Track symbols when doing an
	incremental link.
	(Sized_dynobj::do_for_all_local_got_entries): New function.
	* dynobj.h: (Sized_dynobj::do_for_all_local_got_entries): New
	function.
	* fileread.cc (get_mtime): New function.
	* fileread.h (get_mtime): New function.
	* gold.cc (queue_initial_tasks): Check for incremental update.
	(process_incremental_input): New function.
	(queue_middle_tasks): Don't force valid target for incremental
	update.
	* incremental-dump.cc (find_input_containing_global): Adjust
	size of symbol info entry.
	(dump_incremental_inputs): Dump argument serial number and
	in_system_directory flag; bias shndx by 1; print symbol names
	when dumping per-file symbol lists; use new symbol info readers.
	* incremental.cc
	(Output_section_incremental_inputs:update_data_size): New function.
	(Sized_incremental_binary::setup_readers): Setup input readers
	for each input file; build maps for files added from libraries
	and scripts.
	(Sized_incremental_binary::check_input_args): New function.
	(Sized_incremental_binary::do_check_inputs): Build map of argument
	serial numbers to input arguments.
	(Sized_incremental_binary::do_file_has_changed): Rename
	do_file_is_unchanged to this; compare file modification times.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_incremental_binary::do_get_input_reader): Remove.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Incremental_checker::can_incrementally_link_output_file): Remove.
	(Incremental_inputs::report_command_line): Exclude --debug options.
	(Incremental_inputs::report_archive_begin): Add parameter; track
	argument serial numbers; don't put input file entry for archive
	before archive members.
	(Incremental_inputs::report_archive_end): Put input file entry
	for archive after archive members.
	(Incremental_inputs::report_object): Add parameter; track argument
	serial numbers and in_system_directory flag.
	(Incremental_inputs::report_script): Add parameter; track argument
	serial numbers.
	(Output_section_incremental_inputs::set_final_data_size): Adjust
	size of symbol info entry; check for forwarding symbols.
	(Output_section_incremental_inputs::write_input_files): Write
	in_system_directory flag and argument serial number.
	(Output_section_incremental_inputs::write_info_blocks): Map section
	indices between incremental info and original input file; store
	input section index for each symbol.
	(class Local_got_offset_visitor): Derive from Got_offset_list::Visitor;
	change operator() to visit().
	(class Global_got_offset_visitor): Likewise.
	(class Global_symbol_visitor_got_plt):
	(Output_section_incremental_inputs::write_got_plt): Use new visitor
	classes.
	(Sized_incr_relobj::Sized_incr_relobj): New constructor.
	(Sized_incr_relobj::do_read_symbols): New function.
	(Sized_incr_relobj::do_layout): New function.
	(Sized_incr_relobj::do_layout_deferred_sections): New function.
	(Sized_incr_relobj::do_add_symbols): New function.
	(Sized_incr_relobj::do_should_include_member): New function.
	(Sized_incr_relobj::do_for_all_global_symbols): New function.
	(Sized_incr_relobj::do_for_all_local_got_entries): New function.
	(Sized_incr_relobj::do_section_size): New function.
	(Sized_incr_relobj::do_section_name): New function.
	(Sized_incr_relobj::do_section_contents): New function.
	(Sized_incr_relobj::do_section_flags): New function.
	(Sized_incr_relobj::do_section_entsize): New function.
	(Sized_incr_relobj::do_section_address): New function.
	(Sized_incr_relobj::do_section_type): New function.
	(Sized_incr_relobj::do_section_link): New function.
	(Sized_incr_relobj::do_section_info): New function.
	(Sized_incr_relobj::do_section_addralign): New function.
	(Sized_incr_relobj::do_initialize_xindex): New function.
	(Sized_incr_relobj::do_get_global_symbol_counts): New function.
	(Sized_incr_relobj::do_read_relocs): New function.
	(Sized_incr_relobj::do_gc_process_relocs): New function.
	(Sized_incr_relobj::do_scan_relocs): New function.
	(Sized_incr_relobj::do_count_local_symbols): New function.
	(Sized_incr_relobj::do_finalize_local_symbols): New function.
	(Sized_incr_relobj::do_set_local_dynsym_indexes): New function.
	(Sized_incr_relobj::do_set_local_dynsym_offset): New function.
	(Sized_incr_relobj::do_relocate): New function.
	(Sized_incr_relobj::do_set_section_offset): New function.
	(Sized_incr_dynobj::Sized_incr_dynobj): New function.
	(Sized_incr_dynobj::do_read_symbols): New function.
	(Sized_incr_dynobj::do_layout): New function.
	(Sized_incr_dynobj::do_add_symbols): New function.
	(Sized_incr_dynobj::do_should_include_member): New function.
	(Sized_incr_dynobj::do_for_all_global_symbols): New function.
	(Sized_incr_dynobj::do_for_all_local_got_entries): New function.
	(Sized_incr_dynobj::do_section_size): New function.
	(Sized_incr_dynobj::do_section_name): New function.
	(Sized_incr_dynobj::do_section_contents): New function.
	(Sized_incr_dynobj::do_section_flags): New function.
	(Sized_incr_dynobj::do_section_entsize): New function.
	(Sized_incr_dynobj::do_section_address): New function.
	(Sized_incr_dynobj::do_section_type): New function.
	(Sized_incr_dynobj::do_section_link): New function.
	(Sized_incr_dynobj::do_section_info): New function.
	(Sized_incr_dynobj::do_section_addralign): New function.
	(Sized_incr_dynobj::do_initialize_xindex): New function.
	(Sized_incr_dynobj::do_get_global_symbol_counts): New function.
	(make_sized_incremental_object): New function.
	(Incremental_library::copy_unused_symbols): New function.
	(Incremental_library::do_for_all_unused_symbols): New function.
	* incremental.h (enum Incremental_input_flags): New type.
	(class Incremental_checker): Remove.
	(Incremental_input_entry::Incremental_input_entry): Add argument
	serial number.
	(Incremental_input_entry::arg_serial): New function.
	(Incremental_input_entry::set_is_in_system_directory): New function.
	(Incremental_input_entry::is_in_system_directory): New function.
	(Incremental_input_entry::arg_serial_): New data member.
	(Incremental_input_entry::is_in_system_directory_): New data member.
	(class Script_info): Move here from script.h.
	(Script_info::Script_info): Add filename parameter.
	(Script_info::filename): New function.
	(Script_info::filename_): New data member.
	(Incremental_script_entry::Incremental_script_entry): Add argument
	serial number.
	(Incremental_object_entry::Incremental_object_entry): Likewise.
	(Incremental_object_entry::add_input_section): Build list of input
	sections with map to original shndx.
	(Incremental_object_entry::get_input_section_index): New function.
	(Incremental_object_entry::shndx_): New data member.
	(Incremental_object_entry::name_key_): Rename; adjust all refs.
	(Incremental_object_entry::sh_size_): Rename; adjust all refs.
	(Incremental_archive_entry::Incremental_archive_entry): Add argument
	serial number.
	(Incremental_inputs::report_archive_begin): Likewise.
	(Incremental_inputs::report_object): Likewise.
	(Incremental_inputs::report_script): Likewise.
	(class Incremental_global_symbol_reader): New class.
	(Incremental_input_entry_reader::Incremental_input_entry_reader): Read
	and store flags and input file type.
	(Incremental_input_entry_reader::arg_serial): New function.
	(Incremental_input_entry_reader::type): Extract type from flags.
	(Incremental_input_entry_reader::is_in_system_directory): New function.
	(Incremental_input_entry_reader::get_input_section_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_symbol_offset): Call accessor
	function for type; adjust size of global symbol entry.
	(Incremental_input_entry_reader::get_global_symbol_count): Call
	accessor function for type.
	(Incremental_input_entry_reader::get_object_count): Likewise.
	(Incremental_input_entry_reader::get_object_offset): Likewise.
	(Incremental_input_entry_reader::get_member_count): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol_count): Likewise.
	(Incremental_input_entry_reader::get_member_offset): Likewise.
	(Incremental_input_entry_reader::get_unused_symbol): Likewise.
	(Incremental_input_entry_reader::Global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_info): Remove.
	(Incremental_input_entry_reader::get_global_symbol_reader): New
	function.
	(Incremental_input_entry_reader::get_output_symbol_index): New
	function.
	(Incremental_input_entry_reader::type_): Remove.
	(Incremental_input_entry_reader::flags_): New data member.
	(Incremental_inputs_reader::input_file_offset): New function.
	(Incremental_inputs_reader::input_file_index): New function.
	(Incremental_inputs_reader::input_file): Call input_file_offset.
	(Incremental_inputs_reader::input_file_at_offset): New function.
	(Incremental_relocs_reader::get_r_type): Reformat.
	(Incremental_relocs_reader::get_r_shndx): Reformat.
	(Incremental_relocs_reader::get_r_offset): Reformat.
	(Incremental_relocs_reader::data): New function.
	(Incremental_binary::Incremental_binary): Initialize new data members.
	(Incremental_binary::check_inputs): Add cmdline parameter.
	(Incremental_binary::file_is_unchanged): Remove.
	(Input_reader::arg_serial): New function.
	(Input_reader::get_unused_symbol_count): New function.
	(Input_reader::get_unused_symbol): New function.
	(Input_reader::do_arg_serial): New function.
	(Input_reader::do_get_unused_symbol_count): New function.
	(Input_reader::do_get_unused_symbol): New function.
	(Incremental_binary::input_file_count): New function.
	(Incremental_binary::get_input_reader): Change signature to use
	index instead of filename.
	(Incremental_binary::file_has_changed): New function.
	(Incremental_binary::get_input_argument): New function.
	(Incremental_binary::get_library): New function.
	(Incremental_binary::get_script_info): New function.
	(Incremental_binary::init_layout): New function.
	(Incremental_binary::reserve_layout): New function.
	(Incremental_binary::output_file): New function.
	(Incremental_binary::do_check_inputs): New function.
	(Incremental_binary::do_file_is_unchanged): Remove.
	(Incremental_binary::do_file_has_changed): New function.
	(Incremental_binary::do_init_layout): New function.
	(Incremental_binary::do_reserve_layout): New function.
	(Incremental_binary::do_input_file_count): New function.
	(Incremental_binary::do_get_input_reader): Change signature.
	(Incremental_binary::input_args_map_): New data member.
	(Incremental_binary::library_map_): New data member.
	(Incremental_binary::script_map_): New data member.
	(Sized_incremental_binary::Sized_incremental_binary): Initialize
	new data members.
	(Sized_incremental_binary::output_section): New function.
	(Sized_incremental_binary::inputs_reader): Add const.
	(Sized_incremental_binary::symtab_reader): Add const.
	(Sized_incremental_binary::relocs_reader): Add const.
	(Sized_incremental_binary::got_plt_reader): Add const.
	(Sized_incremental_binary::get_symtab_view): New function.
	(Sized_incremental_binary::Inputs_reader): New typedef.
	(Sized_incremental_binary::Input_entry_reader): New typedef.
	(Sized_incremental_binary::do_check_inputs): Add cmdline parameter.
	(Sized_incremental_binary::do_file_is_unchanged): Remove.
	(Sized_incremental_binary::do_file_has_changed): New function.
	(Sized_incremental_binary::do_init_layout): New function.
	(Sized_incremental_binary::do_reserve_layout): New function.
	(Sized_input_reader::Inputs_reader): Remove.
	(Sized_input_reader::Input_entry_reader): Remove.
	(Sized_input_reader::do_arg_serial): New function.
	(Sized_input_reader::do_get_unused_symbol_count): New function.
	(Sized_input_reader::do_get_unused_symbol): New function.
	(Sized_incremental_binary::do_input_file_count): New function.
	(Sized_incremental_binary::do_get_input_reader): Change signature;
	use index instead of filename.
	(Sized_incremental_binary::section_map_): New data member.
	(Sized_incremental_binary::input_entry_readers_): New data member.
	(class Sized_incr_relobj): New class.
	(class Sized_incr_dynobj): New class.
	(make_sized_incremental_object): New function.
	(class Incremental_library): New class.
	* layout.cc (Free_list::num_lists): New static data member.
	(Free_list::num_nodes): New static data member.
	(Free_list::num_removes): New static data member.
	(Free_list::num_remove_visits): New static data member.
	(Free_list::num_allocates): New static data member.
	(Free_list::num_allocate_visits): New static data member.
	(Free_list::init): New function.
	(Free_list::remove): New function.
	(Free_list::allocate): New function.
	(Free_list::dump): New function.
	(Free_list::print_stats): New function.
	(Layout_task_runner::run): Resize output file for incremental updates.
	(Layout::Layout): Initialize new data members.
	(Layout::set_incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::layout_eh_frame): Do not build .eh_frame_hdr section for
	incremental updates.
	(Layout::create_gold_note): Do not create gold note section for
	incremental updates.
	(Layout::set_segment_offsets): Do not recalculate RELRO alignment
	for incremental updates.
	(Layout::set_section_offsets): For incremental updates, allocate space
	from free list.
	(Layout::create_symtab_sections): Layout with offsets relative to
	start of section; for incremental updates, allocate space from free
	list.
	(Layout::create_shdrs): For incremental updates, allocate space from
	free list.
	(Layout::finish_dynamic_section): For incremental updates, do not
	check --as-needed (fixed in subsequent patch).
	* layout.h (class Free_list): New class.
	(Layout::set_incremental_base): New function.
	(Layout::incremental_base): New function.
	(Layout::init_fixed_output_section): New function.
	(Layout::allocate): New function.
	(Layout::incremental_base_): New data member.
	(Layout::free_list_): New data member.
	* main.cc (main): Print Free_list statistics.
	* object.cc (Relobj::finalize_incremental_relocs): Add
	clear_counts parameter; clear counts only when clear_counts is set.
	(Sized_relobj::Sized_relobj): Initialize new base class.
	(Sized_relobj::do_layout): Don't report special sections.
	(Sized_relobj::do_for_all_local_got_entries): New function.
	(Sized_relobj::write_local_symbols): Add symtab_off parameter; add
	symtab_off to all symbol table offsets.
	(Sized_relobj::do_get_global_symbol_counts): Add typename keyword.
	* object.h (class Got_offset_list): Move to top of file.
	(Object::Object): Allow case where input_file == NULL.
	(Object::~Object): Likewise.
	(Object::input_file): Assert that input_file != NULL.
	(Object::lock): Allow case where input_file == NULL.
	(Object::unlock): Likewise.
	(Object::is_locked): Likewise.
	(Object::token): Likewise.
	(Object::release): Likewise.
	(Object::is_incremental): New function.
	(Object::get_mtime): New function.
	(Object::for_all_local_got_entries): New function.
	(Object::clear_view_cache_marks): Allow case where input_file == NULL.
	(Object::set_is_in_system_directory): New function.
	(Object::is_in_system_directory): New function.
	(Object::do_is_incremental): New function.
	(Object::do_get_mtime): New function.
	(Object::do_for_all_local_got_entries): New function.
	(Object::is_in_system_directory_): New data member.
	(Relobj::finalize_incremental_relocs): Add clear_counts parameter.
	(class Sized_relobj_base): New class.
	(class Sized_relobj): Derive from Sized_relobj_base.
	(class Sized_relobj::Symbols): Redeclare from base class.
	(class Sized_relobj::local_got_offset_list): Remove.
	(class Sized_relobj::Output_sections): Redeclare from base class.
	(class Sized_relobj::do_for_all_local_got_entries): New function.
	(class Sized_relobj::write_local_symbols): Add offset parameter.
	(class Sized_relobj::local_symbol_offset_): Update comment.
	(class Sized_relobj::local_dynsym_offset_): Update comment.
	* options.cc (Input_arguments::add_file): Remove const.
	* options.h (Input_file_argument::Input_file_argument):
	Initialize arg_serial_ (all constructors).
	(Input_file_argument::set_arg_serial): New function.
	(Input_file_argument::arg_serial): New function.
	(Input_file_argument::arg_serial_): New data member.
	(Input_arguments::Input_arguments): Initialize file_count_.
	(Input_arguments::add_file): Remove const.
	(Input_arguments::number_of_input_files): New function.
	(Input_arguments::file_count_): New data member.
	(Command_line::number_of_input_files): Call
	Input_arguments::number_of_input_files.
	* output.cc (Output_segment_headers::Output_segment_headers):
	Set current size.
	(Output_section::Input_section::current_data_size): New function.
	(Output_section::Output_section): Initialize new data members.
	(Output_section::add_input_section): Don't do merge sections for
	an incremental link; allocate space from free list for an
	incremental update.
	(Output_section::add_output_section_data): Allocate space from
	free list for an incremental update.
	(Output_section::update_data_size): New function.
	(Output_section::set_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const; allocate
	space from free list for an incremental update.
	(Output_segment::set_offset): Adjust size of RELRO segment for an
	incremental update.
	* output.h (Output_data::current_data_size): Move here from
	child classes.
	(Output_data::pre_finalize_data_size): New function.
	(Output_data::update_data_size): New function.
	(Output_section_headers::update_data_size): new function.
	(Output_section_data_build::current_data_size): Move to Output_data.
	(Output_data_strtab::update_data_size): New function.
	(Output_section::current_data_size): Move to Output_data.
	(Output_section::set_fixed_layout): New function.
	(Output_section::has_fixed_layout): New function.
	(Output_section::reserve): New function.
	(Output_section::update_data_size): New function.
	(Output_section::has_fixed_layout_): New data member.
	(Output_section::free_list_): New data member.
	(Output_segment::set_section_addresses): Remove const.
	(Output_segment::set_section_list_addresses): Remove const.
	* plugin.cc (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* plugin.h (Sized_pluginobj::do_for_all_local_got_entries):
	New function.
	* readsyms.cc (Read_symbols::do_read_symbols): Add library
	parameter when calling Add_symbols constructor; store argument
	serial number for members of a lib group.
	(Add_symbols::locks): Allow case where token == NULL.
	(Add_symbols::run): Report libraries denoted by --start-lib/--end-lib.
	(Read_member::~Read_member): New function.
	(Read_member::is_runnable): New function.
	(Read_member::locks): New function.
	(Read_member::run): New function.
	(Check_script::~Check_script): New function.
	(Check_script::is_runnable): New function.
	(Check_script::locks): New function.
	(Check_script::run): New function.
	(Check_library::~Check_library): New function.
	(Check_library::is_runnable): New function.
	(Check_library::locks): New function.
	(Check_library::run): New function.
	* readsyms.h (Add_symbols::Add_symbols): Add library parameter.
	(Add_symbols::library_): New data member.
	(class Read_member): New class.
	(class Check_script): New class.
	(class Check_library): New class.
	* reloc.cc (Read_relocs::is_runnable): Allow case where
	token == NULL.
	(Read_relocs::locks): Likewise.
	(Scan_relocs::locks): Likewise.
	(Relocate_task::locks): Likewise.
	(Sized_relobj::do_scan_relocs): Tell finalize_incremental_relocs
	to clear counters.
	(Sized_relobj::incremental_relocs_scan): Fix comment.
	(Sized_relobj::do_relocate): Pass output file offset to
	write_local_symbols.
	(Sized_relobj::incremental_relocs_write_reltype): Use reloc_size
	from class declaration.
	* script.cc (read_input_script): Allocate Script_info; pass
	argument serial number to report_script.
	* script.h (class Script_info): Move to incremental.h.
	* symtab.cc (Symbol_table::add_from_incrobj): New function.
	* symtab.h (Symbol_table::add_from_incrobj): New function.
	(Symbol_table::set_file_offset): New function.
@
text
@d1671 1
a1671 1
      typename elfcpp::Elf_types<size>::Elf_Addr v;
a1690 1
	  v = gsym.get_st_value();
@


1.27
log
@	* incremental-dump.cc (dump_incremental_inputs): Change signature
	to take a Sized_incremental_binary; change caller.  Use readers
	in Sized_incremental_binary.
	* incremental.cc
	(Sized_incremental_binary::find_incremental_inputs_sections):
	Rename do_find_incremental_inputs_sections to this.
	(Sized_incremental_binary::setup_readers): New function.
	(Sized_incremental_binary::do_check_inputs): Check
	has_incremental_info_ flag; move setup code to setup_readers;
	use input readers.
	(Sized_incremental_binary::do_file_is_unchanged): New function.
	(Sized_incremental_binary::do_get_input_reader): New function.
	* incremental.h (class Incremental_binary): Move to end of file.
	(Incremental_binary::file_is_unchanged): New function.
	(Incremental_binary::do_file_is_unchanged): New function.
	(Incremental_binary::Input_reader): New class.
	(Incremental_binary::get_input_reader): New function.
	(class Sized_incremental_binary): Move to end of file.
	(Sized_incremental_binary::Sized_incremental_binary): Setup the
	input section reader classes.
	(Sized_incremental_binary::has_incremental_info): New function.
	(Sized_incremental_binary::inputs_reader): New function.
	(Sized_incremental_binary::symtab_reader): New function.
	(Sized_incremental_binary::relocs_reader): New function.
	(Sized_incremental_binary::got_plt_reader): New function.
	(Sized_incremental_binary::do_file_is_unchanged): New function.
	(Sized_incremental_binary::Sized_input_reader): New class.
	(Sized_incremental_binary::get_input_reader): New function.
	(Sized_incremental_binary::find_incremental_inputs_sections):
	Rename do_find_incremental_inputs_sections to this.
	(Sized_incremental_binary::setup_readers): New function.
	(Sized_incremental_binary::has_incremental_info_): New data member.
	(Sized_incremental_binary::inputs_reader_): New data member.
	(Sized_incremental_binary::symtab_reader_): New data member.
	(Sized_incremental_binary::relocs_reader_): New data member.
	(Sized_incremental_binary::got_plt_reader_): New data member.
	(Sized_incremental_binary::current_input_file_): New data member.
@
text
@d29 1
d34 1
d38 2
d61 6
d260 53
d316 36
d358 1
d361 2
d369 1
a369 1
  if (this->inputs_reader_.version() != INCREMENTAL_LINK_VERSION)
d375 1
a375 1
  if (incremental_inputs->command_line() != this->inputs_reader_.command_line())
d381 33
d417 1
a417 2
// Return TRUE if the file specified by INPUT_ARGUMENT is unchanged
// with respect to the base file.
d421 2
a422 2
Sized_incremental_binary<size, big_endian>::do_file_is_unchanged(
    const Input_argument* input_argument) const
d424 5
a428 2
  Incremental_disposition disp =
      input_argument->file().options().incremental_disposition();
d431 1
a431 1
    return disp == INCREMENTAL_UNCHANGED;
d433 16
a448 1
  // FIXME: Handle INCREMENTAL_CHECK.
d452 71
d525 20
a544 7
Incremental_binary::Input_reader*
Sized_incremental_binary<size, big_endian>::do_get_input_reader(
    const char*)
{
  unsigned int file_index = this->current_input_file_++;
  gold_assert(file_index < this->inputs_reader_.input_file_count());
  return new Sized_input_reader(this->inputs_reader_.input_file(file_index));
a655 15
// Analyzes the output file to check if incremental linking is possible and
// (to be done) what files need to be relinked.

bool
Incremental_checker::can_incrementally_link_output_file()
{
  Output_file output(this->output_name_);
  if (!output.open_for_modification())
    return false;
  Incremental_binary* binary = open_incremental_binary(&output);
  if (binary == NULL)
    return false;
  return binary->check_inputs(this->incremental_inputs_);
}

d678 2
a679 1
	  || strcmp(argv[i], "--incremental-unknown") == 0)
d710 1
d716 4
d722 1
a722 1
      new Incremental_archive_entry(filename_key, mtime);
a723 1
  this->inputs_.push_back(entry);
d770 1
d782 2
a783 2
Incremental_inputs::report_object(Object* obj, Library_base* arch,
				  Script_info* script_info)
d786 5
a790 1
  Timespec mtime = obj->input_file()->file().get_mtime();
d794 3
a796 1
      new Incremental_object_entry(filename_key, obj, mtime);
d839 3
a841 2
Incremental_inputs::report_script(const std::string& filename,
				  Script_info* script, Timespec mtime)
d845 1
a845 1
  this->strtab_->add(filename.c_str(), false, &filename_key);
d847 1
a847 1
      new Incremental_script_entry(filename_key, script, mtime);
d965 1
a965 1
	    info_offset += syms->size() * 16;
d977 14
a990 2
	    unsigned int nsyms = syms != NULL ? syms->size() : 0;
	    info_offset += nsyms * 4;
d1133 3
d1140 2
a1141 2
      Swap16::writeval(pov + 20, (*p)->type());
      Swap16::writeval(pov + 22, 0);
d1206 6
d1216 2
d1225 1
a1225 1
		Output_section* os = obj->output_section(i);
d1229 1
a1229 1
		    out_offset = obj->output_section_offset(i);
d1242 2
a1243 2
	    // linked list chain pointer, relocation count, and offset
	    // to the relocations.
d1249 10
d1274 5
a1278 4
		Swap32::writeval(pov + 4, chain);
		Swap32::writeval(pov + 8, nrelocs);
		Swap32::writeval(pov + 12, first_reloc * 3 * sizeof_addr);
		pov += 16;
d1280 2
d1294 2
a1295 3
	    // Write the global symbol count.
	    unsigned int nsyms = syms != NULL ? syms->size() : 0;
	    Swap32::writeval(pov, nsyms);
d1299 2
d1304 12
a1315 1
		Swap32::writeval(pov, sym->symtab_index());
d1317 1
d1319 3
d1411 1
a1411 1
class Local_got_offset_visitor
d1419 1
a1419 1
  operator()(unsigned int got_type, unsigned int got_offset)
d1442 1
a1442 1
class Global_got_offset_visitor
d1450 1
a1450 1
  operator()(unsigned int got_type, unsigned int got_offset)
d1487 3
a1489 2
        info_.got_descriptor = sym->symtab_index();
	got_offsets->for_all_got_offsets(Got_visitor(info_));
d1539 1
d1550 1
a1550 2
      const Sized_relobj<size, big_endian>* obj =
          static_cast<Sized_relobj<size, big_endian>*>(entry->object());
d1552 3
a1554 11
      unsigned int nsyms = obj->local_symbol_count();
      for (unsigned int i = 0; i < nsyms; i++)
        {
          const Got_offset_list* got_offsets = obj->local_got_offset_list(i);
          if (got_offsets != NULL)
            {
	      typedef Local_got_offset_visitor<size, big_endian> Got_visitor;
	      view_info.got_descriptor = (*p)->get_offset();
	      got_offsets->for_all_got_offsets(Got_visitor(view_info));
	    }
	}
d1562 810
d2377 6
d2388 6
d2399 6
d2410 6
@


1.26
log
@	* archive.cc (Archive::include_member): Adjust call to report_object.
	(Add_archive_symbols::run): Add script_info to call to
	report_archive_begin.
	(Lib_group::include_member): Adjust call to report_object.
	(Add_lib_group_symbols::run): Adjust call to report_object.
	* incremental-dump.cc (dump_incremental_inputs): Remove unnecessary
	blocks.  Add object count for script input files.
	* incremental.cc (Incremental_inputs::report_archive_begin): Add
	script_info parameter; change all callers.
	(Incremental_inputs::report_object): Add script_info parameter;
	change all callers.
	(Incremental_inputs::report_script): Store backpointer to
	incremental info entry.
	(Output_section_incremental_inputs::set_final_data_size): Record
	additional information for scripts.
	(Output_section_incremental_inputs::write_info_blocks): Likewise.
	* incremental.h (Incremental_script_entry::add_object): New function.
	(Incremental_script_entry::get_object_count): New function.
	(Incremental_script_entry::get_object): New function.
	(Incremental_script_entry::objects_): New data member; adjust
	constructor.
	(Incremental_inputs::report_archive_begin): Add script_info parameter.
	(Incremental_inputs::report_object): Add script_info parameter.
	(Incremental_inputs_reader::get_object_count): New function.
	(Incremental_inputs_reader::get_object_offset): New function.
	* options.cc (Input_arguments::add_file): Return reference to
	new input argument.
	* options.h (Input_argument::set_script_info): New function.
	(Input_argument::script_info): New function.
	(Input_argument::script_info_): New data member; adjust all
	constructors.
	(Input_file_group::add_file): Return reference to new input argument.
	(Input_file_lib::add_file): Likewise.
	(Input_arguments::add_file): Likewise.
	* readsyms.cc (Add_symbols::run): Adjust call to report_object.
	* script.cc (Parser_closure::Parser_closure): Add script_info
	parameter; adjust all callers.
	(Parser_closure::script_info): New function.
	(Parser_closure::script_info_): New data member.
	(read_input_script): Report scripts earlier to incremental info.
	(script_add_file): Set script_info in Input_argument.
	(script_add_library): Likewise.
	* script.h (Script_options::Script_info): Rewrite class.
@
text
@d157 1
a157 1
Sized_incremental_binary<size, big_endian>::do_find_incremental_inputs_sections(
d209 1
a209 2
// Determine whether an incremental link based on the existing output file
// can be done.
d212 2
a213 3
bool
Sized_incremental_binary<size, big_endian>::do_check_inputs(
    Incremental_inputs* incremental_inputs)
d218 1
a218 1
  unsigned int plt_got_shndx;
d221 4
a224 7
  if (!do_find_incremental_inputs_sections(&inputs_shndx, &symtab_shndx,
					   &relocs_shndx, &plt_got_shndx,
					   &strtab_shndx))
    {
      explain_no_incremental(_("no incremental data from previous build"));
      return false;
    }
d229 1
d232 5
a236 4
  View inputs_view(view(inputs_location));
  View symtab_view(view(symtab_location));
  View relocs_view(view(relocs_location));
  View strtab_view(view(strtab_location));
d240 12
a251 2
  Incremental_inputs_reader<size, big_endian>
      incoming_inputs(inputs_view.data(), strtab);
d253 15
a267 1
  if (incoming_inputs.version() != INCREMENTAL_LINK_VERSION)
d273 1
a273 1
  if (incremental_inputs->command_line() != incoming_inputs.command_line())
d279 13
a291 1
  // TODO: compare incremental_inputs->inputs() with entries in data_view.
d293 16
a308 1
  return true;
@


1.25
log
@	* archive.cc (Library_base::should_include_member): Move
	method here from class Archive.
	(Archive::Archive): Initialize base class.
	(Archive::should_include_member): Move to base class.
	(Archive::do_for_all_unused_symbols): New function.
	(Add_archive_symbols::run): Remove redundant access to
	incremental_inputs.
	(Lib_group::Lib_group): Initialize base class.
	(Lib_group::do_filename): New function.
	(Lib_group::include_member): Pass pointer to Lib_group to
	report_object.
	(Lib_group::do_for_all_unused_symbols): New function.
	(Add_lib_group_symbols::run): Report archive information for
	incremental links.
	* archive.h (class Library_base): New base class.
	(class Archive): Derive from Library_base.
	(Archive::filename): Move to base class.
	(Archive::set_incremental_info): Likewise.
	(Archive::incremental_info): Likewise.
	(Archive::Should_include): Likewise.
	(Archive::should_include_member): Likewise.
	(Archive::Armap_entry): Remove.
	(Archive::Unused_symbol_iterator): Remove.
	(Archive::unused_symbols_begin): Remove.
	(Archive::unused_symbols_end): Remove.
	(Archive::do_filename): New function.
	(Archive::do_get_mtime): New function.
	(Archive::do_for_all_unused_symbols): New function.
	(Archive::task_): Move to base class.
	(Archive::incremental_info_): Likewise.
	(class Lib_group): Derive from Library_base.
	(Lib_group::do_filename): New function.
	(Lib_group::do_get_mtime): New function.
	(Lib_group::do_for_all_unused_symbols): New function.
	(Lib_group::task_): Move to base class.
	* dynobj.cc (Sized_dynobj::do_for_all_global_symbols): New
	function.
	* dynobj.h (Sized_dynobj::do_for_all_global_symbols): New
	function.
	* incremental.cc (Incremental_inputs::report_archive_begin):
	Use Library_base; call library's get_mtime; add incremental inputs
	entry before members.
	(class Unused_symbol_visitor): New class.
	(Incremental_inputs::report_archive_end): Use Library_base; use
	visitor class to record unused symbols; don't add incremental inputs
	entry after members.
	(Incremental_inputs::report_object): Use Library_base.
	* incremental.h
	(Incremental_archive_entry::Incremental_archive_entry): Remove
	unused Archive parameter.
	(Incremental_inputs::report_archive_begin): Use Library_base.
	(Incremental_inputs::report_archive_end): Likewise.
	(Incremental_inputs::report_object): Likewise.
	* object.cc (Sized_relobj::do_for_all_global_symbols): New
	function.
	* object.h (Object::for_all_global_symbols): New function.
	(Object::do_for_all_global_symbols): New function.
	(Sized_relobj::do_for_all_global_symbols): New function.
	* plugin.cc (Sized_pluginobj::do_for_all_global_symbols):  New
	function.
	* plugin.h (Sized_pluginobj::do_for_all_global_symbols):  New
	function.
@
text
@d439 2
a440 1
Incremental_inputs::report_archive_begin(Library_base* arch)
d450 7
d507 2
a508 1
Incremental_inputs::report_object(Object* obj, Library_base* arch)
d525 7
d567 1
d660 9
a668 2
	  // No supplemental info for a script.
	  (*p)->set_info_offset(0);
d872 19
a890 1
	  // No supplemental info for a script.
@


1.24
log
@	* debug.h (DEBUG_INCREMENTAL): New flag.
	(debug_string_to_enum): Add DEBUG_INCREMENTAL).
	* gold.cc (queue_initial_tasks): Check parameters for incremental link
	mode.
	* incremental.cc (report_command_line): Ignore all forms of
	--incremental.
	* layout.cc (Layout::Layout): Check parameters for incremental link
	mode.
	* options.cc (General_options::parse_incremental): New function.
	(General_options::parse_no_incremental): New function.
	(General_options::parse_incremental_full): New function.
	(General_options::parse_incremental_update): New function.
	(General_options::incremental_mode_): New data member.
	(General_options::finalize): Check incremental_mode_.
	* options.h (General_options): Update help text for --incremental.
	Add --no-incremental, --incremental-full, --incremental-update.
	(General_options::Incremental_mode): New enum type.
	(General_options::incremental_mode): New function.
	(General_options::incremental_mode_): New data member.
	* parameters.cc (Parameters::incremental_mode_): New data member.
	(Parameters::set_options): Set incremental_mode_.
	(Parameters::set_incremental_full): New function.
	(Parameters::incremental): New function.
	(Parameters::incremental_update): New function.
	(set_parameters_incremental_full): New function.
	* parameters.h (Parameters::set_incremental_full): New function.
	(Parameters::incremental): New function.
	(Parameters::incremental_update): New function.
	(Parameters::incremental_mode_): New data member.
	(set_parameters_incremental_full): New function.
	* plugin.cc (Plugin_manager::add_input_file): Check parameters for
	incremental link mode.
	* reloc.cc (Sized_relobj::do_read_relocs): Likewise.
	(Sized_relobj::do_relocate_sections): Likewise.
	* testsuite/Makefile.am (incremental_test): Use --incremental-full
	option.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/incremental_test.sh: Filter all forms of --incremental.
@
text
@d439 1
a439 1
Incremental_inputs::report_archive_begin(Archive* arch)
d442 1
a442 1
  Timespec mtime = arch->file().get_mtime();
d446 1
a446 1
      new Incremental_archive_entry(filename_key, arch, mtime);
d448 1
d451 27
d483 1
a483 1
Incremental_inputs::report_archive_end(Archive* arch)
d490 2
a491 9
  for (Archive::Unused_symbol_iterator p = arch->unused_symbols_begin();
       p != arch->unused_symbols_end();
       ++p)
    {
      Stringpool::Key symbol_key;
      this->strtab_->add(*p, true, &symbol_key);
      entry->add_unused_global_symbol(symbol_key);
    }
  this->inputs_.push_back(entry);
d499 1
a499 1
Incremental_inputs::report_object(Object* obj, Archive* arch)
@


1.23
log
@	* incremental.cc (Output_section_incremental_inputs::write_info_blocks):
	Resolve forwarding symbols.
@
text
@d404 4
a407 1
      if (strcmp(argv[i], "--incremental-changed") == 0
@


1.22
log
@        * archive.cc: Formatting fixes: Remove whitespace between
        typename and following asterisk.  Remove whitespace between
        function name and opening parenthesis.
        * archive.h: Likewise.
        * arm.cc: Likewise.
        * attributes.cc: Likewise.
        * attributes.h: Likewise.
        * common.cc: Likewise.
        * copy-relocs.cc: Likewise.
        * dirsearch.h: Likewise.
        * dynobj.cc: Likewise.
        * ehframe.cc: Likewise.
        * ehframe.h: Likewise.
        * expression.cc: Likewise.
        * fileread.cc: Likewise.
        * fileread.h: Likewise.
        * gc.h: Likewise.
        * gold-threads.cc: Likewise.
        * gold.cc: Likewise.
        * i386.cc: Likewise.
        * icf.h: Likewise.
        * incremental-dump.cc: Likewise.
        * incremental.cc: Likewise.
        * layout.cc: Likewise.
        * layout.h: Likewise.
        * main.cc: Likewise.
        * merge.cc: Likewise.
        * merge.h: Likewise.
        * object.cc: Likewise.
        * object.h: Likewise.
        * options.cc: Likewise.
        * options.h: Likewise.
        * output.cc: Likewise.
        * output.h: Likewise.
        * plugin.cc: Likewise.
        * plugin.h: Likewise.
        * powerpc.cc: Likewise.
        * reloc.cc: Likewise.
        * script-c.h: Likewise.
        * script-sections.cc: Likewise.
        * script.cc: Likewise.
        * stringpool.cc: Likewise.
        * symtab.cc: Likewise.
        * symtab.h: Likewise.
        * target.cc: Likewise.
        * timer.cc: Likewise.
        * timer.h: Likewise.
        * version.cc: Likewise.
        * x86_64.cc: Likewise.
@
text
@d876 2
@


1.21
log
@	* incremental.cc
	(Output_section_incremental_inputs::write_input_files): Add cast
	to avoid signed/unsigned comparison warning.
	(Output_section_incremental_inputs::write_info_blocks): Likewise.
@
text
@d625 1
a625 1
	    Incremental_object_entry *entry = (*p)->object_entry();
d640 1
a640 1
	    Incremental_object_entry *entry = (*p)->object_entry();
d653 1
a653 1
	    Incremental_archive_entry *entry = (*p)->archive_entry();
@


1.20
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_GOT_PLT.

gold/ChangeLog:

	* arm.cc (Target_arm::got_size): Add const.
	(Target_arm::got_entry_count): New function.
	(Target_arm::plt_entry_count): New function.
	(Target_arm::first_plt_entry_offset): New function.
	(Target_arm::plt_entry_size): New function.
	(Output_data_plt_arm::entry_count): New function.
	(Output_data_plt_arm::first_plt_entry_offset): New function.
	(Output_data_plt_arm::get_plt_entry_size): New function.
	* i386.cc (Target_i386::got_size): Add const.
	(Target_i386::got_entry_count): New function.
	(Target_i386::plt_entry_count): New function.
	(Target_i386::first_plt_entry_offset): New function.
	(Target_i386::plt_entry_size): New function.
	(Output_data_plt_i386::entry_count): New function.
	(Output_data_plt_i386::first_plt_entry_offset): New function.
	(Output_data_plt_i386::get_plt_entry_size): New function.
	* incremental-dump.cc (dump_incremental_inputs): Adjust call to
	find_incremental_inputs_sections.  Dump incremental_got_plt section.
	* incremental.cc: Include target.h.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Add
	parameter.  Adjust all callers.  Find incremental_got_plt section.
	(Incremental_inputs::create_data_sections): Create incremental_got_plt
	section.
	(Output_section_incremental_inputs::set_final_data_size): Calculate
	size of incremental_got_plt section.
	(Output_section_incremental_inputs::do_write): Write the
	incremental_got_plt section.
	(Got_plt_view_info): New struct.
	(Local_got_offset_visitor): New class.
	(Global_got_offset_visitor): New class.
	(Global_symbol_visitor_got_plt): New class.
	(Output_section_incremental_inputs::write_got_plt): New function.
	* incremental.h (Incremental_binary::find_incremental_inputs_sections):
	Add parameter.  Adjust all callers.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Incremental_inputs::got_plt_section): New function.
	(Incremental_inputs::got_plt_section_): New data member.
	(Incremental_got_plt_reader): New class.
	* layout.cc (Layout::create_incremental_info_sections): Add the
	incremental_got_plt section.
	* object.h (Got_offset_list::get_list): New function.
	(Got offset_list::for_all_got_offsets): New function.
	(Sized_relobj::local_got_offset_list): New function.
	* powerpc.cc (Target_powerpc::got_size): Add const.
	(Target_powerpc::got_entry_count): New function.
	(Target_powerpc::plt_entry_count): New function.
	(Target_powerpc::first_plt_entry_offset): New function.
	(Target_powerpc::plt_entry_size): New function.
	(Output_data_plt_powerpc::entry_count): New function.
	(Output_data_plt_powerpc::first_plt_entry_offset): New function.
	(Output_data_plt_powerpc::get_plt_entry_size): New function.
	* sparc.cc (Target_sparc::got_size): Add const.
	(Target_sparc::got_entry_count): New function.
	(Target_sparc::plt_entry_count): New function.
	(Target_sparc::first_plt_entry_offset): New function.
	(Target_sparc::plt_entry_size): New function.
	(Output_data_plt_sparc::entry_count): New function.
	(Output_data_plt_sparc::first_plt_entry_offset): New function.
	(Output_data_plt_sparc::get_plt_entry_size): New function.
	* symtab.h (Symbol::got_offset_list): New function.
	(Symbol_table::for_all_symbols): New function.
	* target.h (Sized_target::got_entry_count): New function.
	(Sized_target::plt_entry_count): New function.
	(Sized_target::plt_entry_size): New function.
	* x86_64.cc (Target_x86_64::got_size): Add const.
	(Target_x86_64::got_entry_count): New function.
	(Target_x86_64::plt_entry_count): New function.
	(Target_x86_64::first_plt_entry_offset): New function.
	(Target_x86_64::plt_entry_size): New function.
	(Output_data_plt_x86_64::entry_count): New function.
	(Output_data_plt_x86_64::first_plt_entry_offset): New function.
	(Output_data_plt_x86_64::get_plt_entry_size): New function.
@
text
@d787 1
a787 1
      gold_assert(pov - oview == (*p)->get_offset());
d830 2
a831 1
	    gold_assert(pov - oview == (*p)->get_info_offset());
d901 2
a902 1
	    gold_assert(pov - oview == (*p)->get_info_offset());
d925 2
a926 1
	    gold_assert(pov - oview == (*p)->get_info_offset());
@


1.19
log
@elfcpp/ChangeLog:

	* elfcpp.h (enum SHT): Add SHT_GNU_INCREMENTAL_SYMTAB,
	SHT_GNU_INCREMENTAL_RELOCS.

gold/ChangeLog:

	* archive.cc: Include incremental.h.
	(Archive::Archive): Initialize incremental_info_.
	(Archive::include_member): Record archive members in incremental info.
	(Add_archive_symbols::run): Record begin and end of an archive in
	incremental info.
	(Lib_group::include_member): Record objects in incremental info.
	* archive.h (Incremental_archive_entry): Forward declaration.
	(Archive::set_incremental_info): New member function.
	(Archive::incremental_info): New member function.
	(Archive::Unused_symbol_iterator): New class.
	(Archive::unused_symbols_begin): New member function.
	(Archive::unused_symbols_end): New member function.
	(Archive::incremental_info_): New data member.
	* incremental-dump.cc (find_input_containing_global): New function.
	(dump_incremental_inputs): Dump new incremental info sections.
	* incremental.cc: Include symtab.h.
	(Output_section_incremental_inputs): New class.
	(Sized_incremental_binary::do_find_incremental_inputs_sections): Support
	new incremental info sections.
	(Sized_incremental_binary::do_check_inputs): Likewise.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): New function.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Rewrite.
	(Incremental_inputs::finalize): Do nothing but finalize string table.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Output_section_incremental_inputs::set_final_data_size): New function.
	(Output_section_incremental_inputs::do_write): New function.
	(Output_section_incremental_inputs::write_header): New function.
	(Output_section_incremental_inputs::write_input_files): New function.
	(Output_section_incremental_inputs::write_info_blocks): New function.
	(Output_section_incremental_inputs::write_symtab): New function.
	* incremental.h (Incremental_script_entry): Forward declaration.
	(Incremental_object_entry): Forward declaration.
	(Incremental_archive_entry): Forward declaration.
	(Incremental_inputs): Forward declaration.
	(Incremental_inputs_header_data): Remove.
	(Incremental_inputs_header): Remove.
	(Incremental_inputs_header_write): Remove.
	(Incremental_inputs_entry_data): Remove.
	(Incremental_inputs_entry): Remove.
	(Incremental_inputs_entry_write): Remove.
	(enum Incremental_input_type): Add INCREMENTAL_INPUT_ARCHIVE_MEMBER.
	(Incremental_binary::find_incremental_inputs_sections): Add parameters.
	(Incremental_binary::do_find_incremental_inputs_sections): Likewise.
	(Sized_ncremental_binary::do_find_incremental_inputs_sections):
	Likewise.
	(Incremental_input_entry): New class.
	(Incremental_script_entry): New class.
	(Incremental_object_entry): New class.
	(Incremental_archive_entry): New class.
	(Incremental_inputs::Incremental_inputs): Initialize new data members.
	(Incremental_inputs::report_inputs): Remove.
	(Incremental_inputs::report_archive): Remove.
	(Incremental_inputs::report_archive_begin): New function.
	(Incremental_inputs::report_archive_end): New function.
	(Incremental_inputs::report_object): Change prototype.
	(Incremental_inputs::report_input_section): New function.
	(Incremental_inputs::report_script): Change prototype.
	(Incremental_inputs::get_reloc_count): New function.
	(Incremental_inputs::set_reloc_count): New function.
	(Incremental_inputs::create_data_sections): New function.
	(Incremental_inputs::create_incremental_inputs_section_data): Remove.
	(Incremental_inputs::inputs_section): New function.
	(Incremental_inputs::symtab_section): New function.
	(Incremental_inputs::relocs_section): New function.
	(Incremental_inputs::get_stringpool): Add const.
	(Incremental_inputs::command_line): Add const.
	(Incremental_inputs::inputs): Remove.
	(Incremental_inputs::command_line_key): New function.
	(Incremental_inputs::input_file_count): New function.
	(Incremental_inputs::input_files): New function.
	(Incremental_inputs::relocs_entsize): New function.
	(Incremental_inputs::sized_create_inputs_section_data): Remove.
	(Incremental_inputs::finalize_inputs): Remove.
	(Incremental_inputs::Input_info): Remove.
	(Incremental_inputs::lock_): Remove.
	(Incremental_inputs::inputs_): Change type.
	(Incremental_inputs::inputs_map_): Remove.
	(Incremental_inputs::current_object_entry_): New data member.
	(Incremental_inputs::inputs_section_): New data member.
	(Incremental_inputs::symtab_section_): New data member.
	(Incremental_inputs::relocs_section_): New data member.
	(Incremental_inputs::reloc_count_): New data member.
	(Incremental_inputs_reader): New class.
	(Incremental_symtab_reader): New class.
	(Incremental_relocs_reader): New class.
	* layout.cc (Layout::finalize): Move finalization of incremental info
	and creation of incremental info sections to follow finalization of
	symbol table.  Set offsets for postprocessing sections.
	(Layout::create_incremental_info_sections): Call
	Incremental_inputs::create_data_sections.  Add incremental symtab
	and relocs sections.  Set sh_entsize and sh_link fields.  Arrange for
	sections to layout after input sections.
	* layout.h (struct Timespec): Forward declaration.
	(Layout::incremental_inputs): Add const.
	(Layout::create_incremental_info_sections): Add parameter.
	* main.cc (main): Remove call to Incremental_inputs::report_inputs.
	* object.cc: Include incremental.h.
	(Relobj::finalize_incremental_relocs): New function.
	(Sized_relobj::do_layout): Record input sections in incremental info.
	* object.h (Object::output_section): New function.
	(Object::output_section_offset): Moved from Relobj.
	(Object::get_incremental_reloc_base): New function.
	(Object::get_incremental_reloc_count): New function.
	(Object::do_output_section): New function.
	(Object::do_output_section_offset): Moved from Relobj.
	(Object::do_get_incremental_reloc_base): New function.
	(Object::do_get_incremental_reloc_count): New function.
	(Object::Object): Initialize new data members.
	(Relobj::output_section): Renamed do_output_section and moved to
	protected.
	(Relobj::output_section_offset): Moved to Object.
	(Relobj::do_get_incremental_reloc_base): New function.
	(Relobj::do_get_incremental_reloc_count): New function.
	(Relobj::allocate_incremental_reloc_counts): New function.
	(Relobj::count_incremental_reloc): New function.
	(Relobj::finalize_incremental_relocs): New function.
	(Relobj::next_incremental_reloc_index): New function.
	(Relobj::reloc_counts_): New data member.
	(Relobj::reloc_bases_): New data member.
	(Sized_relobj::do_relocate_sections): Add parameter.  Change caller.
	(Sized_relobj::relocate_sections): Add parameter.  Change all callers.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* plugin.cc (Plugin_manager::add_input_file): Rewrite test for
	incremental link.
	* readsyms.cc (Read_symbols::do_read_symbols): Move reporting of
	archives and object files elsewhere.
	(Add_symbols::run): Report object files here.
	(Finish_group::run): Report end of archive at end of group.
	* reloc.cc: Include layout.h, incremental.h.
	(Sized_relobj::do_read_relocs): Need relocations for incremental link.
	(Sized_relobj::do_scan_relocs): Record relocations for incremental link.
	(Sized_relobj::incremental_relocs_scan): New function.
	(Sized_relobj::incremental_relocs_scan_reltype): New function.
	(Sized_relobj::do_relocate_sections): Write incremental relocations.
	(Sized_relobj::incremental_relocs_write): New function.
	(Sized_relobj::incremental_relocs_write_reltype): New function.
	* script.cc (read_input_script): Rewrite test for incremental link.
	Change call to Incremental_inputs::report_script.
	* symtab.h (Symbol_table::first_global_index): New function.
	(Symbol_table::output_count): New function.
@
text
@d35 1
d92 4
d161 1
d183 7
d202 2
d220 1
d224 2
a225 1
					   &relocs_shndx, &strtab_shndx))
d575 1
d678 10
d742 7
d751 1
d975 189
@


1.18
log
@	* incremental.cc: Include "libiberty.h".
@
text
@d3 1
a3 1
// Copyright 2009 Free Software Foundation, Inc.
d30 1
d42 67
d148 2
d152 29
a180 7
Sized_incremental_binary<size, big_endian>::do_find_incremental_inputs_section(
    Location* location,
    unsigned int* strtab_shndx)
{
  unsigned int shndx = this->elf_file_.find_section_by_type(
      elfcpp::SHT_GNU_INCREMENTAL_INPUTS);
  if (shndx == elfcpp::SHN_UNDEF)  // Not found.
d182 9
a190 2
  *strtab_shndx = this->elf_file_.section_link(shndx);
  *location = this->elf_file_.section_contents(shndx);
d194 3
d202 3
a204 5
  const int entry_size =
      Incremental_inputs_entry_write<size, big_endian>::data_size;
  const int header_size =
      Incremental_inputs_header_write<size, big_endian>::data_size;

a205 1
  Location location;
d207 2
a208 1
  if (!do_find_incremental_inputs_section(&location, &strtab_shndx))
a212 7
  if (location.data_size < header_size
      || strtab_shndx >= this->elf_file_.shnum()
      || this->elf_file_.section_type(strtab_shndx) != elfcpp::SHT_STRTAB)
    {
      explain_no_incremental(_("invalid incremental build data"));
      return false;
    }
d214 3
d218 4
a221 1
  View data_view(view(location));
d223 1
a224 1
  Incremental_inputs_header<size, big_endian> header(data_view.data());
d226 4
a229 1
  if (header.get_version() != INCREMENTAL_LINK_VERSION)
d235 1
a235 12
  const char* command_line;
  // We divide instead of multiplying to make sure there is no integer
  // overflow.
  size_t max_input_entries = (location.data_size - header_size) / entry_size;
  if (header.get_input_file_count() > max_input_entries
      || !strtab.get_c_string(header.get_command_line_offset(), &command_line))
    {
      explain_no_incremental(_("invalid incremental build data"));
      return false;
    }

  if (incremental_inputs->command_line() != command_line)
d242 1
d277 2
a278 2
// Create an Incremental_binary object for FILE. Returns NULL is this is not
// possible, e.g. FILE is not an ELF file or has an unsupported target. FILE
d370 2
d386 1
a386 1
      // Adding/removing these options should result in a full relink.
d412 5
a416 2
// Record that the input argument INPUT is an achive ARCHIVE.  This is
// called by Read_symbols after finding out the type of the file.
d419 1
a419 2
Incremental_inputs::report_archive(const Input_argument* input,
                                   Archive* archive)
d421 2
a422 1
  Hold_lock hl(*this->lock_);
d424 27
a450 5
  Input_info info;
  info.type = INCREMENTAL_INPUT_ARCHIVE;
  info.archive = archive;
  info.mtime = archive->file().get_mtime();
  this->inputs_map_.insert(std::make_pair(input, info));
d453 3
a455 2
// Record that the input argument INPUT is an object OBJ.  This is
// called by Read_symbols after finding out the type of the file.
d458 1
a458 2
Incremental_inputs::report_object(const Input_argument* input,
                                  Object* obj)
d460 2
a461 1
  Hold_lock hl(*this->lock_);
d463 14
a476 7
  Input_info info;
  info.type = (obj->is_dynamic()
	       ? INCREMENTAL_INPUT_SHARED_LIBRARY
	       : INCREMENTAL_INPUT_OBJECT);
  info.object = obj;
  info.mtime = obj->input_file()->file().get_mtime();
  this->inputs_map_.insert(std::make_pair(input, info));
d479 3
a481 3
// Record that the input argument INPUT is an script SCRIPT.  This is
// called by read_script after parsing the script and reading the list
// of inputs added by this script.
d484 2
a485 3
Incremental_inputs::report_script(const Input_argument* input,
                                  Timespec mtime,
                                  Script_info* script)
d487 4
a490 1
  Hold_lock hl(*this->lock_);
d492 2
a493 5
  Input_info info;
  info.type = INCREMENTAL_INPUT_SCRIPT;
  info.script = script;
  info.mtime = mtime;
  this->inputs_map_.insert(std::make_pair(input, info));
d496 3
a498 7
// Compute indexes in the order in which the inputs should appear in
// .gnu_incremental_inputs.  This needs to be done after all the
// scripts are parsed.  The function is first called for the command
// line inputs arguments and may call itself recursively for e.g. a
// list of elements of a group or a list of inputs added by a script.
// The [BEGIN; END) interval to analyze and *INDEX is the current
// value of the index (that will be updated).
d501 2
a502 4
Incremental_inputs::finalize_inputs(
    Input_argument_list::const_iterator begin,
    Input_argument_list::const_iterator end,
    unsigned int* index)
d504 1
a504 7
  for (Input_argument_list::const_iterator p = begin; p != end; ++p)
    {
      if (p->is_group())
        {
          finalize_inputs(p->group()->begin(), p->group()->end(), index);
          continue;
        }
d506 4
a509 19
      Inputs_info_map::iterator it = this->inputs_map_.find(&(*p));
      // TODO: turn it into an assert when the code will be more stable.
      if (it == this->inputs_map_.end())
        {
          gold_error("internal error: %s: incremental build info not provided",
		     (p->is_file() ? p->file().name() : "[group]"));
          continue;
        }
      Input_info* info = &it->second;
      info->index = *index;
      (*index)++;
      this->strtab_->add(p->file().name(), false, &info->filename_key);
      if (info->type == INCREMENTAL_INPUT_SCRIPT)
        {
          finalize_inputs(info->script->inputs()->begin(),
                          info->script->inputs()->end(),
                          index);
        }
    }
d518 1
a518 11
  unsigned int index = 0;
  finalize_inputs(this->inputs_->begin(), this->inputs_->end(), &index);

  // Sanity check.
  for (Inputs_info_map::const_iterator p = this->inputs_map_.begin();
       p != this->inputs_map_.end();
       ++p)
    {
      gold_assert(p->second.filename_key != 0);
    }

d522 1
a522 1
// Create the content of the .gnu_incremental_inputs section.
d524 2
a525 2
Output_section_data*
Incremental_inputs::create_incremental_inputs_section_data()
d531 3
a533 1
      return this->sized_create_inputs_section_data<32, false>();
d537 3
a539 1
      return this->sized_create_inputs_section_data<32, true>();
d543 3
a545 1
      return this->sized_create_inputs_section_data<64, false>();
d549 3
a551 1
      return this->sized_create_inputs_section_data<64, true>();
d556 9
d567 4
a570 1
// Sized creation of .gnu_incremental_inputs section.
d573 2
a574 2
Output_section_data*
Incremental_inputs::sized_create_inputs_section_data()
d576 343
a918 50
  const int entry_size =
      Incremental_inputs_entry_write<size, big_endian>::data_size;
  const int header_size =
      Incremental_inputs_header_write<size, big_endian>::data_size;

  unsigned int sz = header_size + entry_size * this->inputs_map_.size();
  unsigned char* buffer = new unsigned char[sz];
  unsigned char* inputs_base = buffer + header_size;

  Incremental_inputs_header_write<size, big_endian> header_writer(buffer);
  gold_assert(this->command_line_key_ > 0);
  int cmd_offset = this->strtab_->get_offset_from_key(this->command_line_key_);

  header_writer.put_version(INCREMENTAL_LINK_VERSION);
  header_writer.put_input_file_count(this->inputs_map_.size());
  header_writer.put_command_line_offset(cmd_offset);
  header_writer.put_reserved(0);

  for (Inputs_info_map::const_iterator it = this->inputs_map_.begin();
       it != this->inputs_map_.end();
       ++it)
    {
      gold_assert(it->second.index < this->inputs_map_.size());

      unsigned char* entry_buffer =
          inputs_base + it->second.index * entry_size;
      Incremental_inputs_entry_write<size, big_endian> entry(entry_buffer);
      int filename_offset =
          this->strtab_->get_offset_from_key(it->second.filename_key);
      entry.put_filename_offset(filename_offset);
      switch (it->second.type)
        {
        case INCREMENTAL_INPUT_SCRIPT:
          entry.put_data_offset(0);
          break;
        case INCREMENTAL_INPUT_ARCHIVE:
        case INCREMENTAL_INPUT_OBJECT:
        case INCREMENTAL_INPUT_SHARED_LIBRARY:
          // TODO: add per input data.  Currently we store
          // an out-of-bounds offset for future version of gold to reject
          // such an incremental_inputs section.
          entry.put_data_offset(0xffffffff);
          break;
        default:
          gold_unreachable();
        }
      entry.put_timestamp_sec(it->second.mtime.seconds);
      entry.put_timestamp_nsec(it->second.mtime.nanoseconds);
      entry.put_input_type(it->second.type);
      entry.put_reserved(0);
d920 2
d923 14
a936 2
  return new Output_data_const_buffer(buffer, sz, 8,
				      "** incremental link inputs list");
@


1.17
log
@2009-12-04  Rafael Avila de Espindola  <espindola@@google.com>

	* incremental.cc (Incremental_inputs::sized_create_inputs_section_data):
	Don't set the data_offset twice.
@
text
@d26 1
@


1.16
log
@2009-12-03  Rafael Avila de Espindola  <espindola@@google.com>

	* incremental.cc (Incremental_inputs_header)
	(Incremental_inputs_header_write, Incremental_inputs_entry)
	(Incremental_inputs_entry_write): Move ...
	* incremental.h (Incremental_inputs_header)
	(Incremental_inputs_header_write, Incremental_inputs_entry)
	(Incremental_inputs_entry_write): here.
@
text
@a511 4
      // TODO: add per input data and timestamp.  Currently we store
      // an out-of-bounds offset for future version of gold to reject
      // such an incremental_inputs section.
      entry.put_data_offset(0xffffffff);
@


1.15
log
@2009-12-02  Rafael Avila de Espindola  <espindola@@google.com>

	* incremental.cc (make_sized_incremental_binary): Set the target.
	Error if it is incompatible.
	* output.h (Output_file): Add filename method.
@
text
@a33 2
using elfcpp::Convert;

a39 160
// Accessors.

// Reader class for .gnu_incremental_inputs header. See
// Incremental_inputs_header_data for fields descriptions.

template<int size, bool big_endian>
class Incremental_inputs_header
{
 private:
  typedef Incremental_inputs_header_data Data_type;

 public:
  Incremental_inputs_header(const unsigned char *p)
    : p_(reinterpret_cast<const Data_type*>(p))
  { }

  static const int data_size = sizeof(Data_type);

  elfcpp::Elf_Word
  get_version() const
  { return Convert<32, big_endian>::convert_host(this->p_->version); }

  elfcpp::Elf_Word
  get_input_file_count() const
  { return Convert<32, big_endian>::convert_host(this->p_->input_file_count); }

  elfcpp::Elf_Word
  get_command_line_offset() const
  { return Convert<32, big_endian>::convert_host(this->p_->command_line_offset); }

  elfcpp::Elf_Word
  get_reserved() const
  { return Convert<32, big_endian>::convert_host(this->p_->reserved); }

 private:
  const Data_type* p_;
};

// Writer class for .gnu_incremental_inputs header. See
// Incremental_inputs_header_data for fields descriptions.

template<int size, bool big_endian>
class Incremental_inputs_header_write
{
 private:
  typedef Incremental_inputs_header_data Data_type;

 public:
  Incremental_inputs_header_write(unsigned char *p)
    : p_(reinterpret_cast<Data_type*>(p))
  { }

  static const int data_size = sizeof(Data_type);

  void
  put_version(elfcpp::Elf_Word v)
  { this->p_->version = Convert<32, big_endian>::convert_host(v); }

  void
  put_input_file_count(elfcpp::Elf_Word v)
  { this->p_->input_file_count = Convert<32, big_endian>::convert_host(v); }

  void
  put_command_line_offset(elfcpp::Elf_Word v)
  { this->p_->command_line_offset = Convert<32, big_endian>::convert_host(v); }

  void
  put_reserved(elfcpp::Elf_Word v)
  { this->p_->reserved = Convert<32, big_endian>::convert_host(v); }

 private:
  Data_type* p_;
};

// Reader class for an .gnu_incremental_inputs entry. See
// Incremental_inputs_entry_data for fields descriptions.
template<int size, bool big_endian>
class Incremental_inputs_entry
{
 private:
  typedef Incremental_inputs_entry_data Data_type;

 public:
  Incremental_inputs_entry(const unsigned char *p)
    : p_(reinterpret_cast<const Data_type*>(p))
  { }

  static const int data_size = sizeof(Data_type);

  elfcpp::Elf_Word
  get_filename_offset()
  { return Convert<32, big_endian>::convert_host(this->p_->filename_offset); }

  elfcpp::Elf_Word
  get_data_offset()
  { return Convert<32, big_endian>::convert_host(this->p_->data_offset); }

  elfcpp::Elf_Xword
  get_timestamp_sec()
  { return Convert<64, big_endian>::convert_host(this->p_->timestamp_sec); }

  elfcpp::Elf_Word
  get_timestamp_nsec()
  { return Convert<32, big_endian>::convert_host(this->p_->timestamp_nsec); }

  elfcpp::Elf_Word
  get_input_type()
  { return Convert<32, big_endian>::convert_host(this->p_->input_type); }

  elfcpp::Elf_Word
  get_reserved()
  { return Convert<32, big_endian>::convert_host(this->p_->reserved); }

 private:
  const Data_type* p_;
};

// Writer class for an .gnu_incremental_inputs entry. See
// Incremental_inputs_entry_data for fields descriptions.
template<int size, bool big_endian>
class Incremental_inputs_entry_write
{
 private:
  typedef Incremental_inputs_entry_data Data_type;

 public:
  Incremental_inputs_entry_write(unsigned char *p)
    : p_(reinterpret_cast<Data_type*>(p))
  { }

  static const int data_size = sizeof(Data_type);

  void
  put_filename_offset(elfcpp::Elf_Word v)
  { this->p_->filename_offset = Convert<32, big_endian>::convert_host(v); }

  void
  put_data_offset(elfcpp::Elf_Word v)
  { this->p_->data_offset = Convert<32, big_endian>::convert_host(v); }

  void
  put_timestamp_sec(elfcpp::Elf_Xword v)
  { this->p_->timestamp_sec = Convert<64, big_endian>::convert_host(v); }

  void
  put_timestamp_nsec(elfcpp::Elf_Word v)
  { this->p_->timestamp_nsec = Convert<32, big_endian>::convert_host(v); }

  void
  put_input_type(elfcpp::Elf_Word v)
  { this->p_->input_type = Convert<32, big_endian>::convert_host(v); }

  void
  put_reserved(elfcpp::Elf_Word v)
  { this->p_->reserved = Convert<32, big_endian>::convert_host(v); }

 private:
  Data_type* p_;
};

@


1.14
log
@2009-12-02  Rafael Avila de Espindola  <espindola@@google.com>

       * incremental.cc (Incremental_inputs_entry): Remove unused argument
       from the get_* methods.
@
text
@d336 5
@


1.13
log
@2009-12-02  Rafael Avila de Espindola  <espindola@@google.com>

	* incremental-dump.cc (main): Check that the offeset of a script is 0.
	* incremental.cc (Incremental_inputs::sized_create_inputs_section_data):
	Write 0 for the data_offset of scripts.
@
text
@d132 1
a132 1
  get_filename_offset(elfcpp::Elf_Word v)
d136 1
a136 1
  get_data_offset(elfcpp::Elf_Word v)
d140 1
a140 1
  get_timestamp_sec(elfcpp::Elf_Xword v)
d144 1
a144 1
  get_timestamp_nsec(elfcpp::Elf_Word v)
d148 1
a148 1
  get_input_type(elfcpp::Elf_Word v)
d152 1
a152 1
  get_reserved(elfcpp::Elf_Word v)
@


1.12
log
@2009-11-24  Rafael Avila de Espindola  <espindola@@google.com>

	* Makefile.am: Build incremental-dump
	* Makefile.in: Regenerate.
	* incremental-dump.cc: New.
	* incremental.cc (Incremental_inputs_header_data,
	Incremental_inputs_entry_data): Move to incremental.h
	* incremental.h: (Incremental_inputs_header_data,
	Incremental_inputs_entry_data): Move from incremental.cc

2009-11-24  Rafael Avila de Espindola  <espindola@@google.com>

	* elfcpp_file.h: Include elfcpp.h.
@
text
@d653 16
@


1.11
log
@2009-11-24  Rafael Avila de Espindola  <espindola@@google.com>

	* incremental.cc (Incremental_inputs_header,
	Incremental_inputs_header_write, Incremental_inputs_entry,
	Incremental_inputs_entry_write): Add a typedef with the data type.
@
text
@a41 43
namespace internal {

// Header of the .gnu_incremental_input section.
struct Incremental_inputs_header_data
{
  // Incremental linker version.
  elfcpp::Elf_Word version;

  // Numer of input files in the link.
  elfcpp::Elf_Word input_file_count;

  // Offset of command line options in .gnu_incremental_strtab.
  elfcpp::Elf_Word command_line_offset;

  // Padding.
  elfcpp::Elf_Word reserved;
};

// Data stored in .gnu_incremental_input after the header for each of the
// Incremental_input_header_data::input_file_count input entries.
struct Incremental_inputs_entry_data
{
  // Offset of file name in .gnu_incremental_strtab section.
  elfcpp::Elf_Word filename_offset;

  // Offset of data in .gnu_incremental_input.
  elfcpp::Elf_Word data_offset;

  // Timestamp (in seconds).
  elfcpp::Elf_Xword timestamp_sec;

  // Nano-second part of timestamp (if supported).
  elfcpp::Elf_Word timestamp_nsec;

  // Type of the input entry.
  elfcpp::Elf_Half input_type;

  // Padding.
  elfcpp::Elf_Half reserved;
};

}

d45 1
a45 1
// internal::Incremental_inputs_header_data for fields descriptions.
d51 1
a51 1
  typedef internal::Incremental_inputs_header_data Data_type;
d81 1
a81 1
// internal::Incremental_inputs_header_data for fields descriptions.
d87 1
a87 1
  typedef internal::Incremental_inputs_header_data Data_type;
d117 1
a117 1
// internal::Incremental_inputs_entry_data for fields descriptions.
d122 1
a122 1
  typedef internal::Incremental_inputs_entry_data Data_type;
d160 1
a160 1
// internal::Incremental_inputs_entry_data for fields descriptions.
d165 1
a165 1
  typedef internal::Incremental_inputs_entry_data Data_type;
@


1.10
log
@2009-11-24  Rafael Avila de Espindola  <espindola@@google.com>

	* incremental.cc (Incremental_inputs_header,
	Incremental_inputs_header_write, Incremental_inputs_entry,
	Incremental_inputs_entry_write): Update comment about which
	type has the filed descriptions.
@
text
@d93 3
d98 1
a98 1
    : p_(reinterpret_cast<const internal::Incremental_inputs_header_data*>(p))
d101 1
a101 1
  static const int data_size = sizeof(internal::Incremental_inputs_header_data);
d120 1
a120 1
  const internal::Incremental_inputs_header_data* p_;
d129 3
d134 1
a134 1
    : p_(reinterpret_cast<internal::Incremental_inputs_header_data*>(p))
d137 1
a137 1
  static const int data_size = sizeof(internal::Incremental_inputs_header_data);
d156 1
a156 1
  internal::Incremental_inputs_header_data* p_;
d164 3
d169 1
a169 1
    : p_(reinterpret_cast<const internal::Incremental_inputs_entry_data*>(p))
d172 1
a172 1
  static const int data_size = sizeof(internal::Incremental_inputs_entry_data);
d199 1
a199 1
  const internal::Incremental_inputs_entry_data* p_;
d207 3
d212 1
a212 1
    : p_(reinterpret_cast<internal::Incremental_inputs_entry_data*>(p))
d215 1
a215 1
  static const int data_size = sizeof(internal::Incremental_inputs_entry_data);
d242 1
a242 1
  internal::Incremental_inputs_entry_data* p_;
@


1.9
log
@2009-11-10  Doug Kwan  <dougkwan@@google.com>

	* i386.cc (Target_i386::do_calls_non_split): Add a cast to avoid
	a format warning.
	* incremental.cc (open_incremental_binary): Initialized local
	variables to avoid warnings.
	* object.cc (make_elf_object): Ditto.
	* x86_64.cc (Target_x86_64::do_calls_non_split): Add a cast to avoid
	a format warning.
@
text
@d88 1
a88 1
// internal::Incremental_input_header for fields descriptions.
d121 1
a121 1
// internal::Incremental_input_header for fields descriptions.
d154 1
a154 1
// internal::Incremental_input_entry for fields descriptions.
d194 1
a194 1
// internal::Incremental_input_entry for fields descriptions.
@


1.8
log
@elfcpp/:
	* elf_file.h: (class Elf_strtab): New class.
gold/:
	* gold.cc: (queue_initial_tasks): Pass incremental_inputs to
	Incremental_checker.
	* incremental.cc: (INCREMENTAL_LINK_VERSION): Change type to
	unsigned int.
	(class Incremental_inputs_header): New class.
	(Incremental_inputs_header_writer): Edit comment.
	(Incremental_inputs_entry): New class.
	(Incremental_inputs_entry_writer): Edit comment.
	(Sized_incremental_binary::do_find_incremental_inputs_section):
	Add *strtab_shndx parameter, fill it.
	(Sized_incremental_binary::do_check_inputs): New method.
	(Incremental_checker::can_incrementally_link_output_file): Use
	Sized_incremental_binary::check_inputs.
	(Incremental_inputs::report_command_line): Save command line in
	command_line_.
	* incremental.h:
	(Incremental_binary::find_incremental_inputs_section): New
	method.
	(Incremental_binary::do_find_incremental_inputs_section): Add
	strtab_shndx parameter.
	(Incremental_binary::do_check_inputs): New pure virtual method.
	(Sized_incremental_binary::do_check_inputs): Declare.
	(Incremental_checker::Incremental_checker): Add incremental_inputs
	parameter, use it to initialize incremental_inputs_.
	(Incremental_checker::incremental_inputs_): New field.
	(Incremental_checker::command_line): New method.
	(Incremental_checker::inputs): New method.
	(Incremental_checker::command_line_): New field.
@
text
@d391 2
a392 2
  int size;
  bool big_endian;
@


1.7
log
@elfcpp/:
	* elfcpp_file.h: Fix header guard.  Include <cstdio>.
	(class Elf_recognizer): New class, code from gold/object.cc.
	(Elf_file::find_section_by_type): New method.
gold/:
	* incremental.cc: Include <cstdarg> and "target-select.h".
	(vexplain_no_incremental): New function.
	(explain_no_incremental): New function.
	(Incremental_binary::error): New method.
	(Sized_incremental_binary::do_find_incremental_inputs_section): New
	method.
	(make_sized_incremental_binary): New function.
	(open_incremental_binary): New function.
	(can_incrementally_link_file): Add checks if output is ELF and has
	inputs section.
	* incremental.h: Include "elfcpp_file.h" and "output.h".
	(Incremental_binary): New class.
	(Sized_incremental_binary): New class.
	(open_incremental_binary): Declare.
	* object.cc (is_elf_object): Use
	elfcpp::Elf_recognizer::is_elf_file.
	(make_elf_object): Use elfcpp::Elf_recognizer::is_valid_header.
	* output.h (Output_file::filesize): New method.
@
text
@d40 1
a40 1
const int INCREMENTAL_LINK_VERSION = 1;
d87 36
a122 1
// See internal::Incremental_input_header for fields descriptions.
d153 42
a194 1
// See internal::Incremental_input_entry for fields descriptions.
d275 2
a276 1
    Location* location)
d282 1
d287 59
d462 1
a462 8
  Incremental_binary::Location inputs_location;
  if (!binary->find_incremental_inputs_section(&inputs_location))
    {
      explain_no_incremental("no incremental data from previous build");
      delete binary;
      return false;
    }
  return true;
d499 4
a502 1
  this->strtab_->add(args.c_str(), true, &this->command_line_key_);
@


1.6
log
@	* gold.cc: Include "incremental.h".
	(queue_initial_tasks): Call Incremental_checker methods.
	* incremental.cc: Include "output.h".
	(Incremental_checker::can_incrementally_link_output_file): New
	method.
	* incremental.h (Incremental_checker): New class.
@
text
@d24 3
d32 1
d157 156
d322 10
d565 22
@


1.6.2.1
log
@Merge elfcpp and gold from trunk.
@
text
@a23 3

#include <cstdarg>

a28 1
#include "target-select.h"
d36 1
a36 1
const unsigned int INCREMENTAL_LINK_VERSION = 1;
d83 1
a83 36
// Reader class for .gnu_incremental_inputs header. See
// internal::Incremental_input_header for fields descriptions.

template<int size, bool big_endian>
class Incremental_inputs_header
{
 public:
  Incremental_inputs_header(const unsigned char *p)
    : p_(reinterpret_cast<const internal::Incremental_inputs_header_data*>(p))
  { }

  static const int data_size = sizeof(internal::Incremental_inputs_header_data);

  elfcpp::Elf_Word
  get_version() const
  { return Convert<32, big_endian>::convert_host(this->p_->version); }

  elfcpp::Elf_Word
  get_input_file_count() const
  { return Convert<32, big_endian>::convert_host(this->p_->input_file_count); }

  elfcpp::Elf_Word
  get_command_line_offset() const
  { return Convert<32, big_endian>::convert_host(this->p_->command_line_offset); }

  elfcpp::Elf_Word
  get_reserved() const
  { return Convert<32, big_endian>::convert_host(this->p_->reserved); }

 private:
  const internal::Incremental_inputs_header_data* p_;
};

// Writer class for .gnu_incremental_inputs header. See
// internal::Incremental_input_header for fields descriptions.

d114 1
a114 42
// Reader class for an .gnu_incremental_inputs entry. See
// internal::Incremental_input_entry for fields descriptions.
template<int size, bool big_endian>
class Incremental_inputs_entry
{
 public:
  Incremental_inputs_entry(const unsigned char *p)
    : p_(reinterpret_cast<const internal::Incremental_inputs_entry_data*>(p))
  { }

  static const int data_size = sizeof(internal::Incremental_inputs_entry_data);

  elfcpp::Elf_Word
  get_filename_offset(elfcpp::Elf_Word v)
  { return Convert<32, big_endian>::convert_host(this->p_->filename_offset); }

  elfcpp::Elf_Word
  get_data_offset(elfcpp::Elf_Word v)
  { return Convert<32, big_endian>::convert_host(this->p_->data_offset); }

  elfcpp::Elf_Xword
  get_timestamp_sec(elfcpp::Elf_Xword v)
  { return Convert<64, big_endian>::convert_host(this->p_->timestamp_sec); }

  elfcpp::Elf_Word
  get_timestamp_nsec(elfcpp::Elf_Word v)
  { return Convert<32, big_endian>::convert_host(this->p_->timestamp_nsec); }

  elfcpp::Elf_Word
  get_input_type(elfcpp::Elf_Word v)
  { return Convert<32, big_endian>::convert_host(this->p_->input_type); }

  elfcpp::Elf_Word
  get_reserved(elfcpp::Elf_Word v)
  { return Convert<32, big_endian>::convert_host(this->p_->reserved); }

 private:
  const internal::Incremental_inputs_entry_data* p_;
};

// Writer class for an .gnu_incremental_inputs entry. See
// internal::Incremental_input_entry for fields descriptions.
a152 217
// Inform the user why we don't do an incremental link.  Not called in
// the obvious case of missing output file.  TODO: Is this helpful?

void
vexplain_no_incremental(const char* format, va_list args)
{
  char* buf = NULL;
  if (vasprintf(&buf, format, args) < 0)
    gold_nomem();
  gold_info(_("the link might take longer: "
              "cannot perform incremental link: %s"), buf);
  free(buf);
}

void
explain_no_incremental(const char* format, ...)
{
  va_list args;
  va_start(args, format);
  vexplain_no_incremental(format, args);
  va_end(args);
}

// Report an error.

void
Incremental_binary::error(const char* format, ...) const
{
  va_list args;
  va_start(args, format);
  // Current code only checks if the file can be used for incremental linking,
  // so errors shouldn't fail the build, but only result in a fallback to a
  // full build.
  // TODO: when we implement incremental editing of the file, we may need a
  // flag that will cause errors to be treated seriously.
  vexplain_no_incremental(format, args);
  va_end(args);
}

template<int size, bool big_endian>
bool
Sized_incremental_binary<size, big_endian>::do_find_incremental_inputs_section(
    Location* location,
    unsigned int* strtab_shndx)
{
  unsigned int shndx = this->elf_file_.find_section_by_type(
      elfcpp::SHT_GNU_INCREMENTAL_INPUTS);
  if (shndx == elfcpp::SHN_UNDEF)  // Not found.
    return false;
  *strtab_shndx = this->elf_file_.section_link(shndx);
  *location = this->elf_file_.section_contents(shndx);
  return true;
}

template<int size, bool big_endian>
bool
Sized_incremental_binary<size, big_endian>::do_check_inputs(
    Incremental_inputs* incremental_inputs)
{
  const int entry_size =
      Incremental_inputs_entry_write<size, big_endian>::data_size;
  const int header_size =
      Incremental_inputs_header_write<size, big_endian>::data_size;

  unsigned int strtab_shndx;
  Location location;

  if (!do_find_incremental_inputs_section(&location, &strtab_shndx))
    {
      explain_no_incremental(_("no incremental data from previous build"));
      return false;
    }
  if (location.data_size < header_size
      || strtab_shndx >= this->elf_file_.shnum()
      || this->elf_file_.section_type(strtab_shndx) != elfcpp::SHT_STRTAB)
    {
      explain_no_incremental(_("invalid incremental build data"));
      return false;
    }

  Location strtab_location(this->elf_file_.section_contents(strtab_shndx));
  View data_view(view(location));
  View strtab_view(view(strtab_location));
  elfcpp::Elf_strtab strtab(strtab_view.data(), strtab_location.data_size);
  Incremental_inputs_header<size, big_endian> header(data_view.data());

  if (header.get_version() != INCREMENTAL_LINK_VERSION)
    {
      explain_no_incremental(_("different version of incremental build data"));
      return false;
    }

  const char* command_line;
  // We divide instead of multiplying to make sure there is no integer
  // overflow.
  size_t max_input_entries = (location.data_size - header_size) / entry_size;
  if (header.get_input_file_count() > max_input_entries
      || !strtab.get_c_string(header.get_command_line_offset(), &command_line))
    {
      explain_no_incremental(_("invalid incremental build data"));
      return false;
    }

  if (incremental_inputs->command_line() != command_line)
    {
      explain_no_incremental(_("command line changed"));
      return false;
    }

  // TODO: compare incremental_inputs->inputs() with entries in data_view.
  return true;
}

namespace
{

// Create a Sized_incremental_binary object of the specified size and
// endianness. Fails if the target architecture is not supported.

template<int size, bool big_endian>
Incremental_binary*
make_sized_incremental_binary(Output_file* file,
                              const elfcpp::Ehdr<size, big_endian>& ehdr)
{
  Target* target = select_target(ehdr.get_e_machine(), size, big_endian,
                                 ehdr.get_e_ident()[elfcpp::EI_OSABI],
                                 ehdr.get_e_ident()[elfcpp::EI_ABIVERSION]);
  if (target == NULL)
    {
      explain_no_incremental(_("unsupported ELF machine number %d"),
               ehdr.get_e_machine());
      return NULL;
    }

  return new Sized_incremental_binary<size, big_endian>(file, ehdr, target);
}

}  // End of anonymous namespace.

// Create an Incremental_binary object for FILE. Returns NULL is this is not
// possible, e.g. FILE is not an ELF file or has an unsupported target. FILE
// should be opened.

Incremental_binary*
open_incremental_binary(Output_file* file)
{
  off_t filesize = file->filesize();
  int want = elfcpp::Elf_recognizer::max_header_size;
  if (filesize < want)
    want = filesize;

  const unsigned char* p = file->get_input_view(0, want);
  if (!elfcpp::Elf_recognizer::is_elf_file(p, want))
    {
      explain_no_incremental(_("output is not an ELF file."));
      return NULL;
    }

  int size;
  bool big_endian;
  std::string error;
  if (!elfcpp::Elf_recognizer::is_valid_header(p, want, &size, &big_endian,
                                               &error))
    {
      explain_no_incremental(error.c_str());
      return NULL;
    }

  Incremental_binary* result = NULL;
  if (size == 32)
    {
      if (big_endian)
        {
#ifdef HAVE_TARGET_32_BIG
          result = make_sized_incremental_binary<32, true>(
              file, elfcpp::Ehdr<32, true>(p));
#else
          explain_no_incremental(_("unsupported file: 32-bit, big-endian"));
#endif
        }
      else
        {
#ifdef HAVE_TARGET_32_LITTLE
          result = make_sized_incremental_binary<32, false>(
              file, elfcpp::Ehdr<32, false>(p));
#else
          explain_no_incremental(_("unsupported file: 32-bit, little-endian"));
#endif
        }
    }
  else if (size == 64)
    {
      if (big_endian)
        {
#ifdef HAVE_TARGET_64_BIG
          result = make_sized_incremental_binary<64, true>(
              file, elfcpp::Ehdr<64, true>(p));
#else
          explain_no_incremental(_("unsupported file: 64-bit, big-endian"));
#endif
        }
      else
        {
#ifdef HAVE_TARGET_64_LITTLE
          result = make_sized_incremental_binary<64, false>(
              file, elfcpp::Ehdr<64, false>(p));
#else
          explain_no_incremental(_("unsupported file: 64-bit, little-endian"));
#endif
        }
    }
  else
    gold_unreachable();

  return result;
}

d162 1
a162 4
  Incremental_binary* binary = open_incremental_binary(&output);
  if (binary == NULL)
    return false;
  return binary->check_inputs(this->incremental_inputs_);
d199 1
a199 4

  this->command_line_ = args;
  this->strtab_->add(this->command_line_.c_str(), false,
                     &this->command_line_key_);
a394 22
// Instantiate the templates we need.

#ifdef HAVE_TARGET_32_LITTLE
template
class Sized_incremental_binary<32, false>;
#endif

#ifdef HAVE_TARGET_32_BIG
template
class Sized_incremental_binary<32, true>;
#endif

#ifdef HAVE_TARGET_64_LITTLE
template
class Sized_incremental_binary<64, false>;
#endif

#ifdef HAVE_TARGET_64_BIG
template
class Sized_incremental_binary<64, true>;
#endif

@


1.5
log
@	* fileread.cc (File_read::get_mtime): New method.
	* fileread.h (Timespec): New structure.
	(File_read::get_mtime): New method.
	* incremental.cc (Incremental_inputs_entry_data::timestamp_usec):
	Renamed from timestamp_nsec.
	(Incremental_inputs_entry_write::timestamp_sec): Fix argument to
	Elf_Xword.
	(Incremental_inputs_entry_write::timestamp_usec): Renamed from
	timestamp_nsec.
	(Incremental_inputs::report_archive): Save mtime; style fix.
	(Incremental_inputs::report_obejct): Save mtime; style fix.
	(Incremental_inputs::report_script): Save mtime; style fix.
	(Incremental_inputs::finalize_inputs): Style fix.
	(Incremental_inputs::finalize): Style fix.
	(Incremental_inputs::create_input_section_data): Store inputs
	mtime.
	* incremental.h (Incremental_inputs::report_script): Add mtime
	argument.
	(Incremental_inputs::Input_info::Input_info): Intialize only one
	union member.
	(Incremental_inputs::Input_info::archive): Move to nameless
	union.
	(Incremental_inputs::Input_info::obejct): Move to nameless union.
	(Incremental_inputs::Input_info::script): Move to nameless union.
	(Incremental_inputs::mtime): New field.
	* script.cc (read_input_script): Pass file mtime to
	Incremental_input.
	* script.h (Script_info::inputs): Style fix.
@
text
@d28 1
d153 12
@


1.4
log
@	* incremental.cc (Incremental_inputs::report_command_line): Filter
	out --incremental-* options.
@
text
@d27 1
d69 1
a69 1
  elfcpp::Elf_Word timestamp_usec;
d133 2
a134 2
  put_timestamp_sec(elfcpp::Elf_Word v)
  { this->p_->timestamp_sec = Convert<32, big_endian>::convert_host(v); }
d137 2
a138 2
  put_timestamp_usec(elfcpp::Elf_Word v)
  { this->p_->timestamp_usec = Convert<32, big_endian>::convert_host(v); }
d201 2
a202 1
  inputs_map_.insert(std::make_pair(input, info));
d219 2
a220 1
  inputs_map_.insert(std::make_pair(input, info));
d229 1
d237 2
a238 1
  inputs_map_.insert(std::make_pair(input, info));
d263 1
a263 1
      Inputs_info_map::iterator it = inputs_map_.find(&(*p));
d265 1
a265 1
      if (it == inputs_map_.end())
d294 2
a295 2
  for (Inputs_info_map::const_iterator p = inputs_map_.begin();
       p != inputs_map_.end();
d372 2
a373 2
      entry.put_timestamp_sec(0);
      entry.put_timestamp_usec(0);
@


1.3
log
@	* gold.h (Incremental_argument_list): Remove (invalid) forward
	declaration.
	* incremental.cc (Incremental_inputs::report_achive): New method.
	(Incremental_inputs::report_object): New method.
	(Incremental_inputs::report_script): New method.
	(Incremental_inputs::finalize_inputs): New method.
	(Incremental_inputs::finalize): Call finalize_inputs().
	(Incremental_inputs::sized_create_incremental_inputs_section_data):
	Create inputs entries.
	* incremental.h (Incremental_input_type): New enum.
	(Incremental_inputs::Incremental_input): Initialize new fields.
	(Incremental_inputs::report_inputs): New method.
	(Incremental_inputs::report_achive): New method.
	(Incremental_inputs::report_object): New method.
	(Incremental_inputs::report_script): New method.
	(Incremental_inputs::finalize_inputs): New method.
	(Incremental_inputs::Input_info): New struct.
	(Incremental_inputs::Input_info_map): New typedef.
	(Incremental_inputs::lock_): New field.
	(Incremental_inputs::Inputs_): New field.
	(Incremental_inputs::Inputs_map): New field.
	* main.cc (main): Call Incremental_input::report_inputs.
	* options.h (Input_argument_list): Typedef moved from
	Input_arguments.
	(Input_file_group::Files): Remove, use ::Input_argument_list.
	(Input_file_group::Input_argument_list): Remove, use
	::Input_argument_list.
	* plugin.cc (Plugin_manager::add_input_file): Add error in
	incremental build.
	* read_syms.cc (do_read_syms): Call Incremental_input::report_*
	functions.
	* script.cc (read_input_script): Call
	Incremental_input::report_script.
	* script.h (Script_info): New class.
@
text
@d165 6
@


1.2
log
@	* incremental.cc (Incremental_inputs_header_data): Renamed from
	Incremental_input_header_data.
	(Incremental_inputs_header_data::data_size): New field.
	(Incremental_inputs_header_data::put_input_file_count): Renamed
	from input_file_count.
	(Incremental_inputs_header_data::put_command_line_offset): Renamed
	from command_line_offset.
	(Incremental_inputs_header_data::put_reserved): Renamed from
	put_reserved.
	(Incremental_inputs_entry_data): Renamed from
	Incremental_input_entry_data.
	(Incremental_inputs_entry_data::data_size): New field.
	(Incremental_inputs::report_command_line): New method.
	(Incremental_inputs::finalize): New method.
	(Incremental_inputs::create_incremental_inputs_data): New method.
	(Incremental_inputs::sized_create_incremental_inputs_data): New method.
	* incremental.h: New file.
	* layout.cc (Layout::Layout): Handle new incremental_inputs_.
       (Layout::finalize): Create incremental inputs section in
	incremental builds.
       (Layout::create_incremental_info_sections): New method.
	* layout.h (Layout::incremental_inputs): New method.
       (Layout::create_incremental_info_sections): New method.
       (Layout::incremental_inputs_): New field.
	* main.cc (main): Notify Incremental_input of the command line.
@
text
@d89 1
a89 1
  
d182 91
d279 11
d318 1
a318 1
    }  
d326 4
a329 2
{  
  unsigned int sz =
d331 2
d334 2
a336 1
  
d339 1
a339 1
  
d341 1
a341 1
  header_writer.put_input_file_count(0);   // TODO: store input files data.
d344 23
a366 1
  
d368 1
a368 1
      "** incremental link inputs list");
@


1.1
log
@include/elf:
	* common.h (SHT_GNU_INCREMENTAL_INPUTS): Define.
elfcpp:
	* elfcpp.h (SHT_GNU_INCREMENTAL_INPUTS): Define.
gold:
	* incremental.cc: New file.
	* Makefile.am (CCFILES): Add incremental.cc.
	* Makefile.in: Rebuild.
@
text
@d25 2
d39 1
a39 1
struct Incremental_input_header_data
d56 1
a56 1
struct Incremental_input_entry_data
d83 1
a83 1
class Incremental_input_header_write
d86 2
a87 2
  Incremental_input_header_write(unsigned char *p)
    : p_(reinterpret_cast<internal::Incremental_input_header_data>(p))
d89 2
d97 1
a97 1
  input_file_count(elfcpp::Elf_Word v)
d101 1
a101 1
  command_line_offset(elfcpp::Elf_Word v)
d105 1
a105 1
  reserved(elfcpp::Elf_Word v)
d109 1
a109 1
  internal::Incremental_input_header_data* p_;
d114 1
a114 1
class Incremental_input_entry_write
d117 2
a118 2
  Incremental_input_entry_write(unsigned char *p)
    : p_(reinterpret_cast<internal::Incremental_input_entry_data>(p))
d121 2
d148 1
a148 1
  internal::Incremental_input_entry_data* p_;
d151 91
@

