head	1.20;
access;
symbols
	cygwin-1_7_35-release:1.20
	cygwin-1_7_34-release:1.20
	cygwin-1_7_33-release:1.17.2.2
	cygwin-1_7_32-release:1.17.2.2
	cygwin-1_7_31-release:1.17.2.2
	cygwin-1_7_30-release:1.17.2.1
	cygwin-1_7_29-release:1.17.2.1
	cygwin-1_7_29-release-branchpoint:1.17.0.2
	cygwin-1_7_28-release:1.17
	cygwin-1_7_27-release:1.17
	cygwin-1_7_26-release:1.17
	cygwin-1_7_25-release:1.17
	cygwin-1_7_24-release:1.17
	cygwin-1_7_23-release:1.17
	cygwin-1_7_22-release:1.17
	cygwin-1_7_21-release:1.17
	cygwin-1_7_20-release:1.17
	cygwin-1_7_19-release:1.17
	cygwin-64bit-postmerge:1.17
	cygwin-64bit-premerge-branch:1.16.0.6
	cygwin-64bit-premerge:1.16
	cygwin-1_7_18-release:1.16
	cygwin-1_7_17-release:1.16
	cygwin-64bit-branch:1.16.0.4
	cygwin-1_7_16-release:1.16
	cygwin-1_7_15-release:1.16
	cygwin-1_7_14_2-release:1.16
	cygwin-1_7_14-release:1.16
	cygwin-1_7_12-release:1.16
	cygwin-1_7_11-release:1.16
	cygwin-1_7_10-release:1.16
	cygwin-1_7_9-release:1.16
	cygwin-1_7_8-release:1.16
	cygwin-1_7_7-release:1.16
	cygwin-1_7_5-release:1.16
	cygwin-1_7_4-release:1.16
	cygwin-1_7_3-release:1.16
	cygwin-1_7_2-release:1.16
	cygwin-1_7_1-release:1.16
	cv-branch-2:1.16.0.2
	cr-0x5f1:1.14.0.6
	cv-branch:1.14.0.4
	cr-0x3b58:1.14.0.2
	cr-0x9e:1.1.0.4
	cr-0x9d:1.1.0.2;
locks; strict;
comment	@// @;


1.20
date	2015.01.19.17.42.37;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2014.05.19.09.52.43;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2014.03.12.16.00.47;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2013.04.23.09.44.30;	author corinna;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2008.02.06.22.30.38;	author corinna;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	2007.02.23.11.43.48;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.08.20.31.43;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.06.11.11.07;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.01.15.35.47;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.30.15.58.27;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.04.19.44.04;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.15.10.17.52;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.06.20.32.45;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.24.22.04.18;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.30.14.48.19;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.20.16.06.14;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.19.13.12.00;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.07.10.47.39;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.06.16.25.58;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.19.18.49.40;	author corinna;	state Exp;
branches;
next	;

1.17.2.1
date	2014.04.07.11.12.58;	author corinna;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2014.07.16.08.30.48;	author corinna;	state Exp;
branches;
next	;

1.16.4.1
date	2012.12.04.17.25.21;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.20
log
@	* bsd_helper.h: Throughout, convert "struct thread" to "class thread".
	* bsd_mutex.cc (_msleep): Fetch signal_arrived handle from thread's
	ipcblk.
	* process.h (class process): Drop _signal_arrived and align methods.
	(process_cache::process): Drop signal_arrived parameter.
	* process.cc (process::process): Ditto.  Drop related code.
	(process::~process): Drop closing signal_arrived handle.
	(process_cache::process): Drop signal_arrived parameter in call to
	process::process.
	(thread::dup_signal_arrived): New method duplicating thread's
	signal_arrived handle.
	(thread::close_signal_arrived): New method closing thread's
	signal_arrived handle.
	* msg.cc (client_request_msg::serve): Drop signal_arrived parameter from
	call to process_cache::process. Use thread constructor to initialize td.
	* sem.cc (client_request_sem::serve): Ditto.
	* shm.cc (client_request_shm::serve): Ditto.
@
text
@/* bsd_mutex.cc

   Copyright 2003, 2004, 2005, 2007, 2012, 2014, 2015 Red Hat Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */
#ifdef __OUTSIDE_CYGWIN__
#include "woutsup.h"
#include <errno.h>
#define _KERNEL 1
#define __BSD_VISIBLE 1
#include <sys/smallprint.h>
#include <limits.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <sys/sem.h>

#include "process.h"
#include "cygserver_ipc.h"

/* A BSD kernel global mutex. */
struct mtx Giant;

void
mtx_init (mtx *m, const char *name, const void *, int)
{
  m->name = name;
  m->owner = 0;
  m->cnt = 0;
  /* Can't use Windows Mutexes here since Windows Mutexes are only
     unlockable by the lock owner. */
  m->h = CreateSemaphore (NULL, 1, 1, NULL);
  if (!m->h)
    panic ("couldn't allocate %s mutex, %u\n", name, GetLastError ());
}

void
_mtx_lock (mtx *m, DWORD winpid, const char *file, int line)
{
  _log (file, line, LOG_DEBUG, "Try locking mutex %s (%u) (hold: %u)",
	m->name, winpid, m->owner);
  if (WaitForSingleObject (m->h, INFINITE) != WAIT_OBJECT_0)
    _panic (file, line, "wait for %s in %d failed, %u", m->name, winpid,
	    GetLastError ());
  m->owner = winpid;
  _log (file, line, LOG_DEBUG, "Locked      mutex %s/%u (%u)",
	m->name, ++m->cnt, winpid);
}

int
mtx_owned (mtx *m, DWORD winpid)
{
  return m->owner == winpid;
}

void
_mtx_assert (mtx *m, int what, DWORD winpid, const char *file, int line)
{
  switch (what)
    {
      case MA_OWNED:
        if (!mtx_owned (m, winpid))
	  _panic (file, line, "Mutex %s not owned", m->name);
	break;
      case MA_NOTOWNED:
        if (mtx_owned (m, winpid))
	  _panic (file, line, "Mutex %s is owned", m->name);
        break;
      default:
        break;
    }
}

void
_mtx_unlock (mtx *m, const char *file, int line)
{
  DWORD owner = m->owner;
  unsigned long cnt = m->cnt;
  m->owner = 0;
  /* Cautiously check if mtx_destroy has been called (shutdown).
     In that case, m->h is NULL. */
  if (m->h && !ReleaseSemaphore (m->h, 1, NULL))
    {
      /* Check if the semaphore was already on it's max value. */
      if (GetLastError () != ERROR_TOO_MANY_POSTS)
	_panic (file, line, "release of mutex %s failed, %u", m->name,
		GetLastError ());
    }
  _log (file, line, LOG_DEBUG, "Unlocked    mutex %s/%u (owner: %u)",
  	m->name, cnt, owner);
}

void
mtx_destroy (mtx *m)
{
  HANDLE tmp = m->h;
  m->h = NULL;
  if (tmp)
    CloseHandle (tmp);
}

/*
 * Helper functions for msleep/wakeup.
 */

static int
win_priority (int priority)
{
  int p = (int)((priority) & PRIO_MASK) - PZERO;
  /* Generating a valid priority value is a bit tricky.  The only valid
     values on NT4 are -15, -2, -1, 0, 1, 2, 15. */
  switch (p)
    {
      case -15: case -14: case -13: case -12: case -11:
        return THREAD_PRIORITY_IDLE;
      case -10: case -9: case -8: case -7: case -6:
        return THREAD_PRIORITY_LOWEST;
      case -5: case -4: case -3: case -2: case -1:
        return THREAD_PRIORITY_BELOW_NORMAL;
      case 0:
        return THREAD_PRIORITY_NORMAL;
      case 1: case 2: case 3: case 4: case 5:
        return THREAD_PRIORITY_ABOVE_NORMAL;
      case 6: case 7: case 8: case 9: case 10:
      	return THREAD_PRIORITY_HIGHEST;
      case 11: case 12: case 13: case 14: case 15:
        return THREAD_PRIORITY_TIME_CRITICAL;
    }
  return THREAD_PRIORITY_NORMAL;
}

/*
 * Sets the thread priority, returns the old priority.
 */
static int
set_priority (int priority)
{
  int old_prio = GetThreadPriority (GetCurrentThread ());
  if (!SetThreadPriority (GetCurrentThread (), win_priority (priority)))
    log (LOG_WARNING,
    	  "Warning: Setting thread priority to %d failed with error %u\n",
	  win_priority (priority), GetLastError ());
  return old_prio;
}

/*
 * Original description from BSD code:
 *
 * General sleep call.  Suspends the current process until a wakeup is
 * performed on the specified identifier.  The process will then be made
 * runnable with the specified priority.  Sleeps at most timo/hz seconds
 * (0 means no timeout).  If pri includes PCATCH flag, signals are checked
 * before and after sleeping, else signals are not checked.  Returns 0 if
 * awakened, EWOULDBLOCK if the timeout expires.  If PCATCH is set and a
 * signal needs to be delivered, ERESTART is returned if the current system
 * call should be restarted if possible, and EINTR is returned if the system
 * call should be interrupted by the signal (return EINTR).
 *
 * The mutex argument is exited before the caller is suspended, and
 * entered before msleep returns.  If priority includes the PDROP
 * flag the mutex is not entered before returning.
 */
static HANDLE msleep_glob_evt;

class msleep_sync_array
{
  enum msleep_action {
    MSLEEP_ENTER = 0,
    MSLEEP_LEAVE,
    MSLEEP_WAKEUP
  };

  CRITICAL_SECTION cs;
  long cnt;
  long max_cnt;
  struct msleep_record {
    void *ident;
    HANDLE wakeup_evt;
    LONG threads;
  } *a;

  int find_ident (void *ident, msleep_action action)
  {
    int i;
    for (i = 0; i < cnt; ++i)
      if (a[i].ident == ident)
	return i;
    if (i >= max_cnt)
      panic ("ident %x not found and run out of slots.", ident);
    if (i >= cnt && action == MSLEEP_LEAVE)
      panic ("ident %x not found (%d).", ident, action);
    return i;
  }

  HANDLE first_entry (int i, void *ident)
  {
    debug ("New ident %x, index %d", ident, i);
    a[i].ident = ident;
    a[i].wakeup_evt = CreateEvent (NULL, TRUE, FALSE, NULL);
    if (!a[i].wakeup_evt)
      panic ("CreateEvent failed: %u", GetLastError ());
    debug ("i = %d, CreateEvent: %x", i, a[i].wakeup_evt);
    a[i].threads = 1;
    ++cnt;
    return a[i].wakeup_evt;
  }

  HANDLE next_entry (int i)
  {
    if (a[i].ident && WaitForSingleObject (a[i].wakeup_evt, 0) != WAIT_OBJECT_0)
      {
        ++a[i].threads;
	return a[i].wakeup_evt;
      }
    return NULL;
  }

public:

  msleep_sync_array (int count) : cnt (0), max_cnt (count)
  {
    InitializeCriticalSection (&cs);
    if (!(a = new msleep_record[count]))
      panic ("Allocating msleep records failed: %d", errno);
  }

  ~msleep_sync_array () { delete a; }

  HANDLE enter (void *ident)
  {
    HANDLE evt = NULL;
    while (!evt)
      {
        EnterCriticalSection (&cs);
	int i = find_ident (ident, MSLEEP_ENTER);
	if (i >= cnt)
	  evt = first_entry (i, ident);
	else if (!(evt = next_entry (i)))
	  {
	    /* wakeup has been called, so sleep to wait until all
	       formerly waiting threads have left and retry. */
	    LeaveCriticalSection (&cs);
	    Sleep (1L);
	  }
      }
    LeaveCriticalSection (&cs);
    return evt;
  }

  void leave (void *ident)
  {
    EnterCriticalSection (&cs);
    int i = find_ident (ident, MSLEEP_LEAVE);
    if (--a[i].threads == 0)
      {
	debug ("i = %d, CloseEvent: %x", i, a[i].wakeup_evt);
	CloseHandle (a[i].wakeup_evt);
	a[i].ident = NULL;
	--cnt;
	if (i < cnt)
	  a[i] = a[cnt];
      }
    LeaveCriticalSection (&cs);
  }

  void wakeup (void *ident)
  {
    EnterCriticalSection (&cs);
    int i = find_ident (ident, MSLEEP_WAKEUP);
    if (i < cnt && a[i].ident)
      SetEvent (a[i].wakeup_evt);
    LeaveCriticalSection (&cs);
  }
};

static msleep_sync_array *msleep_sync;

void
msleep_init (void)
{
  extern struct msginfo msginfo;
  extern struct seminfo seminfo;

  msleep_glob_evt = CreateEvent (NULL, TRUE, FALSE, NULL);
  if (!msleep_glob_evt)
    panic ("CreateEvent in msleep_init failed: %u", GetLastError ());
  int32_t msgmni = support_msgqueues ? msginfo.msgmni : 0;
  int32_t semmni = support_semaphores ? seminfo.semmni : 0;
  TUNABLE_INT_FETCH ("kern.ipc.msgmni", &msgmni);
  TUNABLE_INT_FETCH ("kern.ipc.semmni", &semmni);
  debug ("Try allocating msgmni (%d) + semmni (%d) msleep records",
  	 msgmni, semmni);
  msleep_sync = new msleep_sync_array (msgmni + semmni);
  if (!msleep_sync)
    panic ("Allocating msleep records in msleep_init failed: %d", errno);
}

int
_msleep (void *ident, struct mtx *mtx, int priority,
	const char *wmesg, int timo, struct thread *td)
{
  int ret = -1;

  HANDLE evt = msleep_sync->enter (ident);

  if (mtx)
    mtx_unlock (mtx);
  int old_priority = set_priority (priority);
  HANDLE obj[4] =
    {
      evt,
      msleep_glob_evt,
      td->client->handle (),
      td->ipcblk->signal_arrived
    };
  /* PCATCH handling.  If PCATCH is given and signal_arrived is a valid
     handle, then it's used in the WaitFor call and EINTR is returned. */
  int obj_cnt = 3;
  if ((priority & PCATCH) && obj[3])
    obj_cnt = 4;
  switch (WaitForMultipleObjects (obj_cnt, obj, FALSE, timo ?: INFINITE))
    {
      case WAIT_OBJECT_0:	/* wakeup() has been called. */
	ret = 0;
	debug ("msleep wakeup called for %d", td->td_proc->winpid);
        break;
      case WAIT_OBJECT_0 + 1:	/* Shutdown event (triggered by wakeup_all). */
        priority |= PDROP;
	/*FALLTHRU*/
      case WAIT_OBJECT_0 + 2:	/* The dependent process has exited. */
	debug ("msleep process exit or shutdown for %d", td->td_proc->winpid);
	ret = EIDRM;
        break;
      case WAIT_OBJECT_0 + 3:	/* Signal for calling process arrived. */
	debug ("msleep process got signal for %d", td->td_proc->winpid);
        ret = EINTR;
	break;
      case WAIT_TIMEOUT:
        ret = EWOULDBLOCK;
        break;
      default:
	/* There's a chance that a process has been terminated before
	   WaitForMultipleObjects has been called.  In this case the handles
	   might be invalid.  The error code returned is ERROR_INVALID_HANDLE.
	   Since we can trust the values of these handles otherwise, we
	   treat an ERROR_INVALID_HANDLE as a normal process termination and
	   hope for the best. */
	if (GetLastError () != ERROR_INVALID_HANDLE)
	  panic ("wait in msleep (%s) failed, %u", wmesg, GetLastError ());
	debug ("wait in msleep (%s) failed for %d, %u", wmesg,
	       td->td_proc->winpid, GetLastError ());
	ret = EIDRM;
	break;
    }

  msleep_sync->leave (ident);

  set_priority (old_priority);

  if (mtx && !(priority & PDROP))
    mtx_lock (mtx);
  return ret;
}

/*
 * Make all threads sleeping on the specified identifier runnable.
 */
int
wakeup (void *ident)
{
  msleep_sync->wakeup (ident);
  return 0;
}

/*
 * Wakeup all sleeping threads.  Only called in the context of cygserver
 * shutdown.
 */
void
wakeup_all (void)
{
  SetEvent (msleep_glob_evt);
}
#endif /* __OUTSIDE_CYGWIN__ */
@


1.19
log
@	* bsd_mutex.cc (msleep_sync_array::~msleep_sync_array): New destructor
	to make Coverity happy (CID 59838).
@
text
@d3 1
a3 1
   Copyright 2003, 2004, 2005, 2007, 2012, 2014 Red Hat Inc.
d317 1
a317 1
      td->client->signal_arrived ()
d322 1
a322 2
  if ((priority & PCATCH)
      && td->client->signal_arrived () != INVALID_HANDLE_VALUE)
@


1.18
log
@	* Throughout, fix format specifiers in debug statements to accommodate
	x86_64.
@
text
@d230 2
@


1.17
log
@	* Merge in cygwin-64bit-branch.
@
text
@d3 1
a3 1
   Copyright 2003, 2004, 2005, 2007, 2012 Red Hat Inc.
d37 1
a37 1
    panic ("couldn't allocate %s mutex, %lu\n", name, GetLastError ());
d46 1
a46 1
    _panic (file, line, "wait for %s in %d failed, %lu", m->name, winpid,
d89 1
a89 1
	_panic (file, line, "release of mutex %s failed, %lu", m->name,
d144 1
a144 1
    	  "Warning: Setting thread priority to %d failed with error %lu\n",
d204 1
a204 1
      panic ("CreateEvent failed: %lu", GetLastError ());
d287 1
a287 1
    panic ("CreateEvent in msleep_init failed: %lu", GetLastError ());
d351 2
a352 2
	  panic ("wait in msleep (%s) failed, %lu", wmesg, GetLastError ());
	debug ("wait in msleep (%s) failed for %d, %lu", wmesg,
@


1.17.2.1
log
@	* Throughout, fix format specifiers in debug statements to accommodate
	x86_64.

	* setpwd.cc (client_request_setpwd::serve): Use RtlSecureZeroMemory to
	delete password from memory.
@
text
@d3 1
a3 1
   Copyright 2003, 2004, 2005, 2007, 2012, 2014 Red Hat Inc.
d37 1
a37 1
    panic ("couldn't allocate %s mutex, %u\n", name, GetLastError ());
d46 1
a46 1
    _panic (file, line, "wait for %s in %d failed, %u", m->name, winpid,
d89 1
a89 1
	_panic (file, line, "release of mutex %s failed, %u", m->name,
d144 1
a144 1
    	  "Warning: Setting thread priority to %d failed with error %u\n",
d204 1
a204 1
      panic ("CreateEvent failed: %u", GetLastError ());
d287 1
a287 1
    panic ("CreateEvent in msleep_init failed: %u", GetLastError ());
d351 2
a352 2
	  panic ("wait in msleep (%s) failed, %u", wmesg, GetLastError ());
	debug ("wait in msleep (%s) failed for %d, %u", wmesg,
@


1.17.2.2
log
@2014-05-19  Corinna Vinschen  <corinna@@vinschen.de>

	* bsd_mutex.cc (msleep_sync_array::~msleep_sync_array): New destructor
	to make Coverity happy (CID 59838).

2014-05-19  Corinna Vinschen  <corinna@@vinschen.de>

	* bsd_helper.cc (ipcexit_creat_hookthread): Delete shs to make
	Coverity happy (CID 59993).
	* transport_pipes.cc (transport_layer_pipes::listen): Make listen_pipe
	and connect_pipe statics to make Coverity happy (CID 60010/60011).

2014-04-16  Corinna Vinschen  <corinna@@vinschen.de>

	* cygserver-config: Use numeric id 18 instead of "system" in chown.
@
text
@a229 2
  ~msleep_sync_array () { delete a; }

@


1.16
log
@	* bsd_helper.cc: Replace %E __small_printf format specifier with %lu
	and call to GetLastError throughout.
	* bsd_mutex.cc: Ditto.
	* sysv_sem.cc (semget): Replace %X __small_printf format specifier
	with %llx.
@
text
@d3 1
a3 1
   Copyright 2003, 2004, 2005, 2007 Red Hat Inc.
d288 2
a289 2
  long msgmni = support_msgqueues ? msginfo.msgmni : 0;
  long semmni = support_semaphores ? seminfo.semmni : 0;
@


1.16.4.1
log
@	* bsd_helper.cc (tunable_int_fetch): Convert 2nd parameter to
	int32_t.
	* bsd_helper.h (tunable_int_fetch): Fix declaration accordingly.
	* bsd_log.cc (log_level): Change type to int32_t.
	* bsd_log.h (log_level): Fix declaration accordingly.
	* bsd_mutex.cc (msgmni): Change type to int32_t.
	(semmni): Ditto.
	* cygserver.cc: Fix debug output to be target agnostic.  Use same
	style throughout.
	* msg.cc (client_request_msg::serve): Refuse to serve 64 bit processes
	from 32 bit cygserver.
	* sem.cc (client_request_sem::serve): Ditto.
	* shm.cc (client_request_shm::serve): Ditto.
	* sysv_shm.cc (shm_delete_mapping): Mark size as unused to make gcc
	happy.
	(kern_shmat): Ditto with flags.
	* process.h (class process): Change type of _cleaning_up member to LONG.
	* threaded_queue.h (class threaded_queue): Ditto for _workers_count.
@
text
@d3 1
a3 1
   Copyright 2003, 2004, 2005, 2007, 2012 Red Hat Inc.
d288 2
a289 2
  int32_t msgmni = support_msgqueues ? msginfo.msgmni : 0;
  int32_t semmni = support_semaphores ? seminfo.semmni : 0;
@


1.15
log
@	Throughout remove using wincap.
	* Makefile.in (OBJS): Remove wincap.o.
	* README: Don't mention 9x.
	* bsd_mutex.cc (_mtx_unlock): Drop checking for 9x error codes.
	* cygserver.cc (server_submission_loop::request_loop): Add FIXME
	comment.
	* wincap.cc: Remove.
	* wincap.h: Remove.
	* woutsup.h: Don't include wincap.h.
@
text
@d37 1
a37 1
    panic ("couldn't allocate %s mutex, %E\n", name);
d46 2
a47 1
    _panic (file, line, "wait for %s in %d failed, %E", m->name, winpid);
d89 2
a90 1
	_panic (file, line, "release of mutex %s failed, %E", m->name);
d204 1
a204 1
      panic ("CreateEvent failed: %E");
d287 1
a287 1
    panic ("CreateEvent in msleep_init failed: %E");
d351 3
a353 3
	  panic ("wait in msleep (%s) failed, %E", wmesg);
	debug ("wait in msleep (%s) failed for %d, %E", wmesg,
							td->td_proc->winpid);
@


1.14
log
@	* bsd_mutex.cc (msleep_cnt): Remove.
	(msleep_max_cnt): Remove.
	(msleep_arr): Remove.
	(class msleep_sync_array): New class to encapsulate msleep/wakeup
	thread synchronization.
	(msleep_sync): New object pointer.
	(msleep_init): Initialize new msleep_sync object.
	(_mutex): Just call msleep_sync->enter() and msleep_sync->leave() for
	thread synchronization. Improve debug output a bit more.
	(wakeup): Just call msleep_sync->wakeup().
	(wakeup_all): Whitespace fix.
@
text
@d3 1
a3 1
   Copyright 2003, 2004, 2005 Red Hat Inc.
d86 2
a87 5
      /* Check if the semaphore was already on it's max value.  In this case,
         ReleaseSemaphore returns FALSE with an error code which *sic* depends
	 on the OS. */
      if (  (!wincap.is_winnt () && GetLastError () != ERROR_INVALID_PARAMETER)
          || (wincap.is_winnt () && GetLastError () != ERROR_TOO_MANY_POSTS))
d112 1
a112 1
     values on 9x and NT4 are -15, -2, -1, 0, 1, 2, 15. */
@


1.13
log
@	* bsd_helper.cc (ipcexit_hookthread): Fix whitespace and handle leak.
	* bsd_mutex.cc: Include stdlib.h, sys/msg.h and sys/sem.h.
	(mtx_init): Initialize lock counter to 0.
	(_mtx_lock): Increment and log mutex lock counter.
	(mtx_owned): Add winpid argument. Return true only if mutex is
	actually owned by process winpid.
	(_mtx_assert): Add winpid argument accordingly.
	(_mtx_unlock): Log owner and lock count.
	(MSLEEP_MUTEX): Remove.
	(MSLEEP_SEM): Ditto.
	(MSLEEP_EVENT): Ditto.
	(msleep_event_name): Ditto.
	(msleep_cs): New global critical section.
	(msleep_cnt): New global variable indicating msleep record usage.
	(msleep_max_cnt): New global variable indicating msleep record size.
	(msleep_arr): New global pointer to msleep records.
	(msleep_init): Initialize msleep_cs. Allocate msleep_arr array.
	(_msleep): Rewrite using new msleep_cs/msleep_arr based thread
	synchronization. Don't be shy with debug output.
	(wakeup): Rewrite using new msleep_cs/msleep_arr based thread
	synchronization.
	* bsd_mutex.h (struct mtx): Add lock counter for better debugging.
	(mtx_owned): Declare with winpid argument.
	(_mtx_assert): Ditto.
	(mtx_assert): Define with winpid argument.
	* cygserver.cc (version): Remove.
	(SERVER_VERSION): New define, decoupling server version information
	from source code control system.
	(print_version): Simplify printing server version.
	* process.cc (process::process): Fix wrong bracketing (and handle leak).
	(process::~process): Only try to close _signal_arrived if valid.
	* sysv_sem.cc: Include sys/smallprint.h.
	(semundo_clear): Define with additional struct thread pointer argument.
	Accomodate throughout.
	(SEMUNDO_LOCKASSERT): Define with winpid argument. Accomodate
	throughout.
	(struct sem_undo): Define un_proc as pid_t on Cygwin. Accomodate
	throughout.
	(seminit): Improve debugging by adding the semid to the mutex name.
	(semget): Correctly print key value as 64 bit hex value in debug
	output.
	(semexit_myhook): Remove Cygwin specific unlocking of mutexes owned
	by exiting process.  Keep semaphore global lock throughout whole
	function to avoid races.
	* sysv_shm.cc (GIANT_REQUIRED): Define empty on Cygwin. We know that
	Giant is locked.
@
text
@d168 111
a278 8
CRITICAL_SECTION msleep_cs;
static long msleep_cnt;
static long msleep_max_cnt;
static struct msleep_record {
  void *ident;
  HANDLE wakeup_evt;
  LONG threads;
} *msleep_arr;
a288 1
  InitializeCriticalSection (&msleep_cs);
d295 2
a296 4
  msleep_max_cnt = msgmni + semmni;
  msleep_arr = (struct msleep_record *) calloc (msleep_max_cnt,
  						sizeof (struct msleep_record));
  if (!msleep_arr)
a304 1
  int i;
d306 1
a306 32
  while (1)
    {
      EnterCriticalSection (&msleep_cs);
      for (i = 0; i < msleep_cnt; ++i)
	if (msleep_arr[i].ident == ident)
	  break;
      if (!msleep_arr[i].ident)
	{
	  debug ("New ident %x, index %d", ident, i);
	  if (i >= msleep_max_cnt)
	    panic ("Too many idents to wait for.\n");
	  msleep_arr[i].ident = ident;
	  msleep_arr[i].wakeup_evt = CreateEvent (NULL, TRUE, FALSE, NULL);
	  if (!msleep_arr[i].wakeup_evt)
	    panic ("CreateEvent in msleep (%s) failed: %E", wmesg);
	  msleep_arr[i].threads = 1;
	  ++msleep_cnt;
	  LeaveCriticalSection (&msleep_cs);
	  break;
	}
      else if (WaitForSingleObject (msleep_arr[i].wakeup_evt, 0)
	       != WAIT_OBJECT_0)
	{
	  ++msleep_arr[i].threads;
	  LeaveCriticalSection (&msleep_cs);
	  break;
	}
      /* Otherwise wakeup has been called, so sleep to wait until all
         formerly waiting threads have left and retry. */
      LeaveCriticalSection (&msleep_cs);
      Sleep (1L);
    }
d313 1
a313 1
      msleep_arr[i].wakeup_evt,
a323 1

d328 1
a328 1
	debug ("msleep wakeup called");
d334 1
a334 1
	debug ("msleep process exit or shutdown");
d338 1
a338 1
	debug ("msleep process got signal");
d353 2
d359 1
a359 10
  EnterCriticalSection (&msleep_cs);
  if (--msleep_arr[i].threads == 0)
    {
      CloseHandle (msleep_arr[i].wakeup_evt);
      msleep_arr[i].ident = NULL;
      --msleep_cnt;
      if (i < msleep_cnt)
        msleep_arr[i] = msleep_arr[msleep_cnt];
    }
  LeaveCriticalSection (&msleep_cs);
d374 1
a374 9
  int i;

  EnterCriticalSection (&msleep_cs);
  for (i = 0; i < msleep_cnt; ++i)
    if (msleep_arr[i].ident == ident)
      break;
  if (msleep_arr[i].ident)
    SetEvent (msleep_arr[i].wakeup_evt);
  LeaveCriticalSection (&msleep_cs);
d385 1
a385 1
    SetEvent (msleep_glob_evt);
@


1.12
log
@	* bsd_mutex.cc (_msleep): Whitespace fix.
	* process.cc (process::process): Handle invalid signal_arrived values
	more gracefully.
@
text
@d17 3
d32 1
d43 2
a44 1
  _log (file, line, LOG_DEBUG, "Try locking mutex %s", m->name);
d48 2
a49 1
  _log (file, line, LOG_DEBUG, "Locked      mutex %s", m->name);
d53 1
a53 1
mtx_owned (mtx *m)
d55 1
a55 1
  return m->owner > 0;
d59 1
a59 1
_mtx_assert (mtx *m, int what, const char *file, int line)
d64 1
a64 1
        if (!mtx_owned (m))
d68 1
a68 1
        if (mtx_owned (m))
d79 2
d93 2
a94 1
  _log (file, line, LOG_DEBUG, "Unlocked    mutex %s", m->name);
a109 16
/* Values for which */
#define MSLEEP_MUTEX	0
#define MSLEEP_SEM	1
#define MSLEEP_EVENT	2

static char *
msleep_event_name (void *ident, char *name, int which)
{
  if (wincap.has_terminal_services ())
    __small_sprintf (name, "Global\\cygserver.msleep.evt.%1d.%08x",
		     which, ident);
  else
    __small_sprintf (name, "cygserver.msleep.evt.%1d.%08x", which, ident);
  return name;
}

d168 8
d180 3
d186 12
d205 34
a238 1
  char name[64];
a239 32
  /* The mutex is used to indicate an ident specific critical section.
     The critical section is needed to synchronize access to the
     semaphore and eventually the event object.  The whole idea is
     that a wakeup is *guaranteed* to wakeup *all* threads.  If that's
     not synchronized, sleeping threads could return into the msleep
     function before all other threads have called CloseHandle(evt).
     That's bad, since the event still exists and is signalled! */
  HANDLE mutex = CreateMutex (NULL, FALSE,
			      msleep_event_name (ident, name, MSLEEP_MUTEX));
  if (!mutex)
    panic ("CreateMutex in msleep (%s) failed: %E", wmesg);
  WaitForSingleObject (mutex, INFINITE);

  /* Ok, we're in the critical section now.  We create an ident specific
     semaphore, which is used to synchronize the waiting threads. */
  HANDLE sem = CreateSemaphore (NULL, 0, LONG_MAX,
				msleep_event_name (ident, name, MSLEEP_SEM));
  if (!sem)
    panic ("CreateSemaphore in msleep (%s) failed: %E", wmesg);

  /* This thread is one more thread sleeping.  The semaphore value is
     so used as a counter of sleeping threads.  That info is needed by
     the wakeup function. */
  ReleaseSemaphore (sem, 1, NULL);

  /* Leave critical section. */
  ReleaseMutex (mutex);

  HANDLE evt = CreateEvent (NULL, TRUE, FALSE,
			    msleep_event_name (ident, name, MSLEEP_EVENT));
  if (!evt)
    panic ("CreateEvent in msleep (%s) failed: %E", wmesg);
d245 1
a245 1
      evt,
d261 1
d267 1
d271 1
d278 9
a286 1
	panic ("wait in msleep (%s) failed, %E", wmesg);
d290 10
a299 13
  CloseHandle (evt);
  /* wakeup has reset the semaphore to 0.  Now indicate that this thread
     has called CloseHandle (evt) and enter the critical section.  The
     critical section is still hold by wakeup, until all formerly sleeping
     threads have indicated that the event has been dismissed.  That's
     the signal for wakeup that it's the only thread still holding a
     handle to the event object.  wakeup will then close the last handle
     and leave the critical section. */
  ReleaseSemaphore (sem, 1, NULL);
  WaitForSingleObject (mutex, INFINITE);
  CloseHandle (sem);
  ReleaseMutex (mutex);
  CloseHandle (mutex);
d314 1
a314 63
  char name[64];
  LONG threads;

  HANDLE evt = OpenEvent (EVENT_MODIFY_STATE, FALSE,
  			  msleep_event_name (ident, name, MSLEEP_EVENT));
  if (!evt) /* No thread is waiting. */
    {
      /* Another round of different error codes returned by 9x and NT
         systems. Oh boy... */
      if (  (!wincap.is_winnt () && GetLastError () != ERROR_INVALID_NAME)
	  || (wincap.is_winnt () && GetLastError () != ERROR_FILE_NOT_FOUND))
	panic ("OpenEvent (%s) in wakeup failed: %E", name);
      return 0;
    }

  /* The mutex is used to indicate an ident specific critical section.
     The critical section is needed to synchronize access to the
     semaphore and eventually the event object.  The whole idea is
     that a wakeup is *guaranteed* to wakeup *all* threads.  If that's
     not synchronized, sleeping threads could return into the msleep
     function before all other threads have called CloseHandle(evt).
     That's bad, since the event still exists and is signalled! */
  HANDLE mutex = OpenMutex (MUTEX_ALL_ACCESS, FALSE,
			    msleep_event_name (ident, name, MSLEEP_MUTEX));
  if (!mutex)
    panic ("OpenMutex (%s) in wakeup failed: %E", name);
  WaitForSingleObject (mutex, INFINITE);
  /* Ok, we're in the critical section now.  We create an ident specific
     semaphore, which is used to synchronize the waiting threads. */
  HANDLE sem = OpenSemaphore (SEMAPHORE_ALL_ACCESS, FALSE,
			      msleep_event_name (ident, name, MSLEEP_SEM));
  if (!sem)
    panic ("OpenSemaphore (%s) in wakeup failed: %E", name);
  ReleaseSemaphore (sem, 1, &threads);
  /* `threads' is the number of waiting threads.  Now reset the semaphore
     to 0 and wait for this number of threads to indicate that they have
     called CloseHandle (evt).  Then it's save to do the same here in
     wakeup, which then means that the event object is destroyed and
     can get safely recycled. */
  for (int i = threads + 1; i > 0; --i)
    WaitForSingleObject (sem, INFINITE);

  if (!SetEvent (evt))
    panic ("SetEvent (%s) in wakeup failed, %E", name);

  /* Now wait for all threads which were waiting for this wakeup. */
  while (threads-- > 0)
    WaitForSingleObject (sem, INFINITE);

  /* Now our handle is the last handle to this event object. */
  CloseHandle (evt);
  /* But paranoia rulez, so we check here again. */
  evt = OpenEvent (EVENT_MODIFY_STATE, FALSE,
		   msleep_event_name (ident, name, MSLEEP_EVENT));
  if (evt)
    panic ("Event %s has not been destroyed.  Obviously I can't count :-(",
	   name);

  CloseHandle (sem);

  /* Leave critical section (all of wakeup is critical). */
  ReleaseMutex (mutex);
  CloseHandle (mutex);
d316 7
@


1.11
log
@	* bsd_mutex.cc: Include limits.h.
	(MSLEEP_MUTEX): New define for third parameter to msleep_event_name.
	(MSLEEP_SEM): Ditto.
	(MSLEEP_EVENT): Ditto.
	(msleep_event_name): Add third parameter to allow multiple
	synchronization objects per ident.
	(_msleep): Implement new synchronization technique to make sure
	that all threads have been woken up by a corresponding wakeup call.
	(wakeup): Ditto.
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Red Hat Inc.
d239 1
a239 1
  
@


1.10
log
@	* bsd_mutex.cc (_msleep): Simplify event creation.  Revert change from
	2004-08-24.  It should be unnecessary now.
	* msg.cc (client_request_msg::serve): Release process critical
	section as early as possible.
	* sem.cc (client_request_sem::serve): Ditto.
	* shm.cc (client_request_shm::serve): Ditto.
	* process.cc: Use hold and release method calls instead of
	EnterCriticalSection/LeaveCriticalSection calls throughout.
	* process.h (_hold): Rename from hold.  Take filename and linenumber
	parameter for logging.  Define matching hold macro.
	(release): Ditto.
@
text
@d16 1
d100 6
d107 1
a107 1
msleep_event_name (void *ident, char *name)
d110 2
a111 1
    __small_sprintf (name, "Global\\cygserver.msleep.evt.%08x", ident);
d113 1
a113 1
    __small_sprintf (name, "cygserver.msleep.evt.%08x", ident);
d190 31
a220 2
  msleep_event_name (ident, name);
  HANDLE evt = CreateEvent (NULL, TRUE, FALSE, name);
d239 1
d261 1
a261 9
#if 0
  /* Dismiss event before entering mutex. */
  /* CV 2004-09-06, Don't dismiss for now. 
     TODO: Dismissing was meant to solve a problem with heavy load but
     there's no proof that it helps.  On the contrary, it breaks msgtest
     in the testsuite.  As long as I don't get a testcase to track that
     down, I'll keep it that way. */
  ResetEvent (evt);
#endif
d263 13
d277 1
d290 5
a294 3
  msleep_event_name (ident, name);
  HANDLE evt = OpenEvent (EVENT_MODIFY_STATE, FALSE, name);
  if (!evt)
d301 1
d303 40
d344 9
a352 5
    {
      if (!SetEvent (evt))
	panic ("SetEvent (%s) in wakeup failed, %E", name);
      CloseHandle (evt);
    }
@


1.9
log
@	Fix copyright throughout.
	Eliminate use of _impure_ptr outside Cygwin.
	* bsd_helper.cc: Include errno.h instead of cygerrno.h.
	* bsd_mutex.cc : Ditto.
	* client.cc: Ditto.
	* cygserver.cc: Ditto.
	* process.cc: Don't build functions inside Cygwin.  Don't include
	cygerrno.h.  Don't set errno.
	* transport_pipes.cc (SET_ERRNO): New define.  Use througout.
	* transport_sockets.cc (SET_ERRNO): Ditto.
	(GET_ERRNO): Ditto.
@
text
@d183 1
a183 3
  HANDLE evt = OpenEvent (EVENT_ALL_ACCESS, FALSE, name);
  if (!evt)
    evt = CreateEvent (NULL, TRUE, FALSE, name);
a201 1
  td->client->release ();
a232 1
  td->client->hold ();
@


1.8
log
@	* bsd_mutex.cc (_msleep): Disable resetting event object for now.
@
text
@d3 1
a3 1
   Copyright 2003 Red Hat Inc.
d12 1
a12 1
#include "cygerrno.h"
@


1.7
log
@	* bsd_mutex.cc (_msleep): Release process object while waiting.
@
text
@d226 1
d228 5
d234 1
@


1.6
log
@	* bsd_mutex.cc (_msleep): Reset event object and close it before
	entering mutex.  Turn order of conditional for better readability.
@
text
@d204 1
d229 1
@


1.5
log
@	* bsd_helper.cc: Whitespace fixes.
	* bsd_mutex.cc: Ditto.
@
text
@d225 3
d229 1
a229 1
  if (!(priority & PDROP) && mtx)
a230 1
  CloseHandle (evt);
@


1.4
log
@	* bsd_mutex.cc (win_priority): Actually calculate p from priority.
@
text
@d52 1
a52 1
_mtx_assert(mtx *m, int what, const char *file, int line)
d58 1
a58 1
	  _panic(file, line, "Mutex %s not owned", m->name);
d62 1
a62 1
	  _panic(file, line, "Mutex %s is owned", m->name);
@


1.3
log
@	* bsd_mutex.cc (win_priority): Move to msleep helper function section.
	(set_priority): Ditto. Fix formatting.
	(_msleep): Cleanup obj formatting.  Rearrange obj order.
@
text
@d112 1
a112 1
  int p = (int)((p) & PRIO_MASK) - PZERO;
@


1.2
log
@        * bsd_mutex.cc (_msleep): Handle PCATCH using signal_arrived event.
        * client.cc: Include sigproc.h.
        * msg.cc (client_request_msg::serve): Accomodate third parameter to
        process::process.
        * sem.cc (client_request_sem::serve): Ditto.
        * shm.cc (client_request_shm::serve): Ditto.
        * process.cc (process::process): Duplicate signal_arrived into
        Cygserver process space.
        (process::~process): Close _signal_arrived handle.
        (process_cache::process): Add signal_arrived handling.
        * process.h (process::process): Add signal_arrived parameter.
        (process:signal_arrived): New read accessor.
        (process:_signal_arrived): New member.
        (process_cache::process): Add signal_arrived parameter.
@
text
@a108 27
/*
 * Original description from BSD code:
 *
 * General sleep call.  Suspends the current process until a wakeup is
 * performed on the specified identifier.  The process will then be made
 * runnable with the specified priority.  Sleeps at most timo/hz seconds
 * (0 means no timeout).  If pri includes PCATCH flag, signals are checked
 * before and after sleeping, else signals are not checked.  Returns 0 if
 * awakened, EWOULDBLOCK if the timeout expires.  If PCATCH is set and a
 * signal needs to be delivered, ERESTART is returned if the current system
 * call should be restarted if possible, and EINTR is returned if the system
 * call should be interrupted by the signal (return EINTR).
 *
 * The mutex argument is exited before the caller is suspended, and
 * entered before msleep returns.  If priority includes the PDROP
 * flag the mutex is not entered before returning.
 */
static HANDLE msleep_glob_evt;

void
msleep_init (void)
{
  msleep_glob_evt = CreateEvent (NULL, TRUE, FALSE, NULL);
  if (!msleep_glob_evt)
    panic ("CreateEvent in msleep_init failed: %E");
}

d142 1
a142 1
  if (!SetThreadPriority (GetCurrentThread (), win_priority(priority)))
d145 1
a145 1
	  win_priority(priority), GetLastError ());
d149 27
d191 7
a197 1
  HANDLE obj[4] = { evt, td->client->handle (), msleep_glob_evt, td->client->signal_arrived () };
d209 1
a209 1
      case WAIT_OBJECT_0 + 2:	/* Shutdown event (triggered by wakeup_all). */
d212 1
a212 1
      case WAIT_OBJECT_0 + 1:	/* The dependent process has exited. */
@


1.1
log
@	Don't use safe_new but new throughout.  Fix copyright dates
	throughout.
	* Makefile.in: Accomodate all new files and name changes.
	Add a *.d dependency.
	(sbindir): Add.
	(etcdir): Drop in favor of more appropriate sysconfdir definition.
	(sysconfdir): Add.
	(CXXFLAGS): Add -MMD flag. Add SYSCONFDIR definition.
	(.SUFFIXES): Add.
	(install): Add action items.
	(libclean): New target.
	(fullclean): Ditto.
	* bsd_helper.cc: New file.
	* bsd_helper.h: Ditto.
	* bsd_log.cc: Ditto.
	* bsd_log.h: Ditto.
	* bsd_mutex.cc: Ditto.
	* bsd_mutex.h: Ditto.
	* client.cc: Rearrange to build as less as possible if
	__INSIDE_CYGWIN__.
	(client_request::handle_request): Add Message Queue and Semaphore
	handling.
	* cygserver.cc: Rearrange to build as less as possible if
	__INSIDE_CYGWIN__. Use new debug/log/panic logging functions.
	(DEF_CONFIG_FILE): New definition for configuration file.  Use
	throughout.
	(getfunc): Remove.
	(__cygserver__printf): Remove.
	(client_request_attach_tty::serve): Return error if impersonation
	fails.
	(print_usage): Pump up help message.
	(print_version): Add output of default configuration file.
	(main): Accommodate new options.  Allow overwrite of threading options
	from config file.  Call several new initialization functions.  Drop
	printing dots.  Don't define SIGHANDLE inline.
	* cygserver.conf: New file.
	* cygserver_process.h: Rename to process.h.
	* cygserver_transport.h: Rename to transport.h.
	* cygserver_transport_pipes.h: Rename to transport_pipes.h.
	* cygserver_transport_sockets.h: Rename to transport_sockets.h.
	* msg.cc: Rewrite.
	* sem.cc: Rewrite.
	* shm.cc: Rewrite.
	* sysv_msg.cc: New file, derived from FreeBSD version 1.52.
	* sysv_sem.cc: New file, derived from FreeBSD version 1.66.
	* sysv_shm.cc: New file, derived from FreeBSD version 1.89.
	* threaded_queue.cc: Rearrange to build as less as possible if
	__INSIDE_CYGWIN__.
	* transport.cc (transport_layer_base::impersonate_client): Define bool.
	(transport_layer_base::revert_to_self): Ditto.
	* transport.h (transport_layer_base::impersonate_client): Declare bool.
	(transport_layer_base::revert_to_self): Ditto.
	* transport_pipes.cc (transport_layer_pipes::transport_layer_pipes):
	Don't call init_security.
	(init_security): Remove.
	(transport_layer_pipes::accept): Use global sec_all_nih.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::impersonate_client): Define bool.
	(transport_layer_pipes::revert_to_self): Ditt.
	* transport_pipes.h (transport_layer_pipes::impersonate_client): Declare
	bool.
	(transport_layer_pipes::revert_to_self): Ditto.
	* woutsup.h: Include bsd compatibility headers.
	(SIGHANDLE): Add definition.
	(__cygserver__printf): Remove definition.
	(__noop_printf): Ditto.
	(debug_printf): Define using debug.
	(syscall_printf): Define using log.
	(system_printf): Ditto.
	Drop all other _printf definitions.
@
text
@d191 8
a198 3
  /* PCATCH can't be handled here. */
  HANDLE obj[3] = { evt, td->client->handle (), msleep_glob_evt };
  switch (WaitForMultipleObjects (3, obj, FALSE, timo ?: INFINITE))
d209 3
@

