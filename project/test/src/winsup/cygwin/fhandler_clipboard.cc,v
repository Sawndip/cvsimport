head	1.59;
access;
symbols
	cygwin-1_7_35-release:1.59
	cygwin-1_7_34-release:1.59
	cygwin-1_7_33-release:1.59
	cygwin-1_7_32-release:1.59
	cygwin-1_7_31-release:1.59
	cygwin-1_7_30-release:1.59
	cygwin-1_7_29-release:1.59
	cygwin-1_7_29-release-branchpoint:1.59.0.2
	cygwin-pre-user-db:1.59
	cygwin-1_7_28-release:1.59
	cygwin-1_7_27-release:1.58
	cygwin-1_7_26-release:1.58
	cygwin-1_7_25-release:1.55
	cygwin-1_7_24-release:1.55
	cygwin-1_7_23-release:1.55
	cygwin-1_7_22-release:1.55
	cygwin-1_7_21-release:1.55
	cygwin-1_7_20-release:1.54
	cygwin-1_7_19-release:1.54
	cygwin-64bit-postmerge:1.54
	cygwin-64bit-premerge-branch:1.53.0.2
	cygwin-64bit-premerge:1.53
	cygwin-1_7_18-release:1.53
	post-ptmalloc3:1.51.2.5
	pre-ptmalloc3:1.51.2.5
	cygwin-1_7_17-release:1.52
	cygwin-64bit-branch:1.51.0.2
	cygwin-1_7_16-release:1.51
	cygwin-1_7_15-release:1.50
	cygwin-1_7_14_2-release:1.50
	cygwin-1_7_14-release:1.50
	cygwin-1_7_12-release:1.50
	cygwin-1_7_11-release:1.49
	cygwin-1_7_10-release:1.49
	signal-rewrite:1.47.0.2
	pre-notty:1.46
	cygwin-1_7_9-release:1.44
	cv-post-1_7_9:1.44.0.4
	cygwin-1_7_8-release:1.44
	cygwin-1_7_7-release:1.44
	cygwin-1_7_5-release:1.44
	cygwin-1_7_4-release:1.44
	cygwin-1_7_3-release:1.44
	cygwin-1_7_2-release:1.44
	fifo_doover3:1.44.0.2
	cygwin-1_7_1-release:1.44
	prefifo:1.43
	cv-branch-2:1.42.0.2
	pre-ripout-set_console_state_for_spawn:1.40
	EOL_registry_mounts:1.39
	preoverlapped:1.35
	drop_9x_support_start:1.35
	cr-0x5f1:1.35.0.8
	cv-branch:1.35.0.6
	pre-ptymaster-archetype:1.35
	cr-0x3b58:1.35.0.4
	cr-0x5ef:1.35.0.2
	after-mmap-privanon-noreserve:1.35
	after-mmap-revamp:1.35
	before-mmap-revamp:1.35
	cgf-more-exit-sync:1.34
	post_wait_sig_exit:1.32
	pre_wait_sig_exit:1.32
	reparent-point:1.26
	noreparent:1.26.0.4
	cr-0x5e6:1.26.0.2
	cr-0x9e:1.24.0.6
	cr-0x9d:1.24.0.4
	cgf-deleteme:1.24.0.2
	pre-sigrewrite:1.24
	corinna-01:1.24
	cr-0x9c:1.23.0.6
	cr-0x9b:1.23.0.4
	cr-0x99:1.23
	Z-emcb-cygwin_daemon:1.23.0.2
	w32api-2_2:1.21
	mingw-runtime-2_4:1.21
	pre-cgf-merge:1.23
	cgf-dev-branch:1.21.0.6
	predaemon:1.16
	cygwin_daemon_merge_HEAD:1.16
	pregp02r1:1.15.0.2
	cygnus_cvs_20020108_pre:1.13
	Z-cygwin_daemon_merge-new_HEAD:1.19
	Z-cygwin_daemon_merge_HEAD:1.19
	cygwin_daemon:1.9.0.4;
locks; strict;
comment	@// @;


1.59
date	2013.12.10.21.05.23;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2013.11.24.12.13.33;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2013.10.25.16.16.50;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2013.10.25.15.04.24;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2013.06.17.10.11.54;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2012.08.17.09.23.34;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2012.07.02.20.17.27;	author corinna;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2012.03.26.11.24.51;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2011.11.14.01.29.48;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2011.07.31.12.37.52;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2011.06.06.05.02.09;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2011.05.01.14.35.12;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2009.07.24.20.54.33;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2009.06.30.21.18.43;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2009.06.04.17.14.53;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.03.05.12.20;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2008.02.25.18.32.23;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2008.01.31.20.26.01;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.14.04.28.44;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.28.19.22.21;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.28.19.02.49;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.27.14.33.09;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.06.20.05.00;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.05.03.16.44;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.27.01.57.37;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.04.18.04.11;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.01.11.51.28;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.10.13.45.09;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.09.04.04.22;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.14.04.01.32;	author cgf;	state Exp;
branches
	1.21.4.1
	1.21.6.1;
next	1.20;

1.20
date	2002.09.30.04.35.17;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.19.03.30.20;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.01.19.03.26;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.25.17.47.46;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.10.13.38.48;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.24.04.16.45;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.22.18.39.22;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.04.02.34.19;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.06.05.17.22;	author cgf;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2001.09.06.04.41.59;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.26.19.22.23;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.24.22.26.50;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.24.02.07.58;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.22.22.11.34;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.10.00.45.11;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.28.05.41.43;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.17.01.46.26;	author dj;	state Exp;
branches;
next	;

1.51.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.51.2.3;

1.51.2.3
date	2012.10.31.17.00.08;	author corinna;	state Exp;
branches;
next	1.51.2.4;

1.51.2.4
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	1.51.2.5;

1.51.2.5
date	2013.02.09.20.38.00;	author corinna;	state Exp;
branches;
next	;

1.21.4.1
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	;

1.21.6.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.21.6.2;

1.21.6.2
date	2003.02.14.03.03.27;	author cgf;	state Exp;
branches;
next	1.21.6.3;

1.21.6.3
date	2003.04.03.01.32.32;	author cgf;	state Exp;
branches;
next	1.21.6.4;

1.21.6.4
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.9.4.1
date	2002.01.04.03.56.07;	author rbcollins;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2002.02.28.12.53.23;	author rbcollins;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2002.06.13.14.34.04;	author rbcollins;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2002.07.02.10.58.17;	author scottc;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.59
log
@	* fhandler.h (fhandler_dev_clipboard): Add private member
	cygnativeformat.  Declare private method set_clipboard.
	* fhandler_clipboard.cc (cygnativeformat): Convert static variable to
	fhandler_dev_clipboard member.
	(fhandler_dev_clipboard::set_clipboard): Convert from static function
	to fhandler_dev_clipboard method.
@
text
@/* fhandler_dev_clipboard: code to access /dev/clipboard

   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009, 2011, 2012, 2013
   Red Hat, Inc

   Written by Charles Wilson (cwilson@@ece.gatech.edu)

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <wchar.h>
#include "cygerrno.h"
#include "path.h"
#include "fhandler.h"
#include "sync.h"
#include "dtable.h"
#include "cygheap.h"
#include "child_info.h"

/*
 * Robert Collins:
 * FIXME: should we use GetClipboardSequenceNumber to tell if the clipboard has
 * changed? How does /dev/clipboard operate under (say) linux?
 */

static const WCHAR *CYGWIN_NATIVE = L"CYGWIN_NATIVE_CLIPBOARD";

typedef struct
{
  timestruc_t	timestamp;
  size_t	len;
  char		data[1];
} cygcb_t;

fhandler_dev_clipboard::fhandler_dev_clipboard ()
  : fhandler_base (), pos (0), membuffer (NULL), msize (0)
{
  /* FIXME: check for errors and loop until we can open the clipboard */
  OpenClipboard (NULL);
  cygnativeformat = RegisterClipboardFormatW (CYGWIN_NATIVE);
  CloseClipboard ();
}

/*
 * Special clipboard dup to duplicate input and output
 * handles.
 */

int
fhandler_dev_clipboard::dup (fhandler_base * child, int flags)
{
  fhandler_dev_clipboard *fhc = (fhandler_dev_clipboard *) child;
  fhc->pos = fhc->msize = 0;
  fhc->membuffer = NULL;
  return fhandler_base::dup (child, flags);
}

int
fhandler_dev_clipboard::set_clipboard (const void *buf, size_t len)
{
  HGLOBAL hmem;
  /* Native CYGWIN format */
  if (OpenClipboard (NULL))
    {
      cygcb_t *clipbuf;

      hmem = GlobalAlloc (GMEM_MOVEABLE, sizeof (cygcb_t) + len);
      if (!hmem)
	{
	  __seterrno ();
	  CloseClipboard ();
	  return -1;
	}
      clipbuf = (cygcb_t *) GlobalLock (hmem);

      clock_gettime (CLOCK_REALTIME, &clipbuf->timestamp);
      clipbuf->len = len;
      memcpy (clipbuf->data, buf, len);

      GlobalUnlock (hmem);
      EmptyClipboard ();
      HANDLE ret = SetClipboardData (cygnativeformat, hmem);
      CloseClipboard ();
      /* According to MSDN, hmem must not be free'd after transferring the
	 data to the clipboard via SetClipboardData. */
      /* GlobalFree (hmem); */
      if (!ret)
	{
	  __seterrno ();
	  return -1;
	}
    }

  /* CF_TEXT/CF_OEMTEXT for copying to wordpad and the like */
  len = sys_mbstowcs (NULL, 0, (const char *) buf, len);
  if (!len)
    {
      set_errno (EILSEQ);
      return -1;
    }
  if (OpenClipboard (NULL))
    {
      PWCHAR clipbuf;

      hmem = GlobalAlloc (GMEM_MOVEABLE, (len + 1) * sizeof (WCHAR));
      if (!hmem)
	{
	  __seterrno ();
	  CloseClipboard ();
	  return -1;
	}
      clipbuf = (PWCHAR) GlobalLock (hmem);
      sys_mbstowcs (clipbuf, len + 1, (const char *) buf);
      GlobalUnlock (hmem);
      HANDLE ret = SetClipboardData (CF_UNICODETEXT, hmem);
      CloseClipboard ();
      /* According to MSDN, hmem must not be free'd after transferring the
	 data to the clipboard via SetClipboardData. */
      /* GlobalFree (hmem); */
      if (!ret)
	{
	  __seterrno ();
	  return -1;
	}
    }
  return 0;
}

/* FIXME: arbitrary seeking is not handled */
ssize_t __stdcall
fhandler_dev_clipboard::write (const void *buf, size_t len)
{
  /* write to our membuffer */
  size_t cursize = msize;
  void *tempbuffer = realloc (membuffer, cursize + len);
  if (!tempbuffer)
    {
      debug_printf ("Couldn't realloc() clipboard buffer for write");
      return -1;
    }
  membuffer = tempbuffer;
  msize = cursize + len;
  memcpy ((unsigned char *) membuffer + cursize, buf, len);

  /* now pass to windows */
  if (set_clipboard (membuffer, msize))
    {
      /* FIXME: membuffer is now out of sync with pos, but msize
		is used above */
      return -1;
    }

  pos = msize;
  return len;
}

int __reg2
fhandler_dev_clipboard::fstat (struct stat *buf)
{
  buf->st_mode = S_IFCHR | STD_RBITS | STD_WBITS | S_IWGRP | S_IWOTH;
  buf->st_uid = geteuid32 ();
  buf->st_gid = getegid32 ();
  buf->st_nlink = 1;
  buf->st_blksize = PREFERRED_IO_BLKSIZE;

  buf->st_ctim.tv_sec = 1164931200L;	/* Arbitrary value: 2006-12-01 */
  buf->st_ctim.tv_nsec = 0L;
  buf->st_birthtim = buf->st_atim = buf->st_mtim = buf->st_ctim;

  if (OpenClipboard (NULL))
    {
      UINT formatlist[1] = { cygnativeformat };
      int format;
      HGLOBAL hglb;
      cygcb_t *clipbuf;

      if ((format = GetPriorityClipboardFormat (formatlist, 1)) > 0
	  && (hglb = GetClipboardData (format))
	  && (clipbuf = (cygcb_t *) GlobalLock (hglb)))
	{
	  buf->st_atim = buf->st_mtim = clipbuf->timestamp;
	  buf->st_size = clipbuf->len;
	  GlobalUnlock (hglb);
	}
      CloseClipboard ();
    }

  return 0;
}

void __reg3
fhandler_dev_clipboard::read (void *ptr, size_t& len)
{
  HGLOBAL hglb;
  size_t ret = 0;
  UINT formatlist[2];
  UINT format;
  LPVOID cb_data;
  int rach;

  if (!OpenClipboard (NULL))
    {
      len = 0;
      return;
    }
  formatlist[0] = cygnativeformat;
  formatlist[1] = CF_UNICODETEXT;
  if ((format = GetPriorityClipboardFormat (formatlist, 2)) <= 0
      || !(hglb = GetClipboardData (format))
      || !(cb_data = GlobalLock (hglb)))
    {
      CloseClipboard ();
      len = 0;
      return;
    }
  if (format == cygnativeformat)
    {
      cygcb_t *clipbuf = (cygcb_t *) cb_data;

      if (pos < (off_t) clipbuf->len)
	{
	  ret = ((len > (clipbuf->len - pos)) ? (clipbuf->len - pos) : len);
	  memcpy (ptr, clipbuf->data + pos , ret);
	  pos += ret;
	}
    }
  else if ((rach = get_readahead ()) >= 0)
    {
      /* Deliver from read-ahead buffer. */
      char * out_ptr = (char *) ptr;
      * out_ptr++ = rach;
      ret = 1;
      while (ret < len && (rach = get_readahead ()) >= 0)
	{
	  * out_ptr++ = rach;
	  ret++;
	}
    }
  else
    {
      wchar_t *buf = (wchar_t *) cb_data;

      size_t glen = GlobalSize (hglb) / sizeof (WCHAR) - 1;
      if (pos < (off_t) glen)
	{
	  /* If caller's buffer is too small to hold at least one
	     max-size character, redirect algorithm to local
	     read-ahead buffer, finally fill class read-ahead buffer
	     with result and feed caller from there. */
	  char *conv_ptr = (char *) ptr;
	  size_t conv_len = len;
#define cprabuf_len MB_LEN_MAX	/* max MB_CUR_MAX of all encodings */
	  char cprabuf [cprabuf_len];
	  if (len < cprabuf_len)
	    {
	      conv_ptr = cprabuf;
	      conv_len = cprabuf_len;
	    }

	  /* Comparing apples and oranges here, but the below loop could become
	     extremly slow otherwise.  We rather return a few bytes less than
	     possible instead of being even more slow than usual... */
	  if (glen > pos + conv_len)
	    glen = pos + conv_len;
	  /* This loop is necessary because the number of bytes returned by
	     sys_wcstombs does not indicate the number of wide chars used for
	     it, so we could potentially drop wide chars. */
	  while ((ret = sys_wcstombs (NULL, 0, buf + pos, glen - pos))
		  != (size_t) -1
		 && (ret > conv_len
			/* Skip separated high surrogate: */
		     || ((buf [glen - 1] & 0xFC00) == 0xD800
			 && glen - pos > 1)))
	     --glen;
	  if (ret == (size_t) -1)
	    ret = 0;
	  else
	    {
	      ret = sys_wcstombs ((char *) conv_ptr, (size_t) -1,
				  buf + pos, glen - pos);
	      pos = glen;
	      /* If using read-ahead buffer, copy to class read-ahead buffer
	         and deliver first byte. */
	      if (conv_ptr == cprabuf)
		{
		  puts_readahead (cprabuf, ret);
		  char *out_ptr = (char *) ptr;
		  ret = 0;
		  while (ret < len && (rach = get_readahead ()) >= 0)
		    {
		      * out_ptr++ = rach;
		      ret++;
		    }
		}
	    }
	}
    }
  GlobalUnlock (hglb);
  CloseClipboard ();
  len = ret;
}

off_t
fhandler_dev_clipboard::lseek (off_t offset, int whence)
{
  /* On reads we check this at read time, not seek time.
   * On writes we use this to decide how to write - empty and write, or open, copy, empty
   * and write
   */
  pos = offset;
  /* treat seek like rewind */
  if (membuffer)
    {
      free (membuffer);
      membuffer = NULL;
    }
  msize = 0;
  return 0;
}

int
fhandler_dev_clipboard::close ()
{
  if (!have_execed)
    {
      pos = msize = 0;
      if (membuffer)
	{
	  free (membuffer);
	  membuffer = NULL;
	}
    }
  return fhandler_base::close ();
}

void
fhandler_dev_clipboard::fixup_after_exec ()
{
  if (!close_on_exec ())
    {
      pos = msize = 0;
      membuffer = NULL;
    }
}
@


1.58
log
@	Throughout, drop unnecessary explicit includes of windows header files
	included by default.
	* winlean.h: Add long comment to explain why we have to define certain
	symbols.
	(_NORMALIZE_): Define.
	(_WINNLS_): Drop definition and subsequent undef.
	(_WINNETWK_): Ditto.
	(_WINSVC_): Ditto.

2013-11-23  Eric Blake  <eblake@@redhat.com>
@
text
@a30 2
/* this is MT safe because windows format id's are atomic */
static UINT cygnativeformat;
d62 2
a63 2
static int
set_clipboard (const void *buf, size_t len)
@


1.57
log
@	* devices.in (dev_storage): Map /dev/clipboard to \Device\Null.
	* devices.cc: Regenerate.
	* fhandler.h (fhandler_dev_clipboard::open): Drop declaration.
	* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Drop call to
	open.  Set private members to 0 and call fhandler_base::dup.
	(fhandler_dev_clipboard::open): Remove so that default
	fhandler_base::open is used to open \Device\Null.
	(set_clipboard): Drop gratuitios call to RegisterClipboardFormatW.
	(fhandler_dev_clipboard::close): Call fhandler_base::close from here.
@
text
@a15 2
#include <wingdi.h>
#include <winuser.h>
@


1.56
log
@	* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Drop gratuitios
	handling of membuffer.  It's NULL anyway.
	(fhandler_dev_clipboard::lseek): Set membuffer to NULL after freeing
	it to avoid subsequent crashes when accessing invalid pointer.
@
text
@d58 1
a58 1
fhandler_dev_clipboard::dup (fhandler_base * child, int)
d61 3
a63 16

  if (!fhc->open (get_flags (), 0))
    system_printf ("error opening clipboard, %E");
  return 0;
}

int
fhandler_dev_clipboard::open (int flags, mode_t)
{
  set_flags (flags | O_TEXT);
  pos = 0;
  if (!cygnativeformat)
    cygnativeformat = RegisterClipboardFormatW (CYGWIN_NATIVE);
  nohandle (true);
  set_open_status ();
  return 1;
a89 2
      if (!cygnativeformat)
	cygnativeformat = RegisterClipboardFormatW (CYGWIN_NATIVE);
d334 1
a334 1
      pos = 0;
a339 1
      msize = 0;
d341 1
a341 1
  return 0;
@


1.55
log
@	* fhandler_clipboard.cc (fhandler_dev_clipboard::read): Fix buffer
	read access overrun when pos > 0.
@
text
@a71 3
  if (membuffer)
    free (membuffer);
  membuffer = NULL;
d336 4
a339 1
    free (membuffer);
@


1.54
log
@	* Merge in cygwin-64bit-branch.
@
text
@d298 2
a299 1
		     || ((buf [pos + glen - 1] & 0xFC00) == 0xD800 && glen - pos > 1)))
@


1.53
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d32 1
a32 1
static const NO_COPY WCHAR *CYGWIN_NATIVE = L"CYGWIN_NATIVE_CLIPBOARD";
d184 1
a184 1
fhandler_dev_clipboard::fstat (struct __stat64 *buf)
d246 1
a246 1
      if (pos < clipbuf->len)
d270 1
a270 1
      if (pos < glen)
d328 2
a329 2
_off64_t
fhandler_dev_clipboard::lseek (_off64_t offset, int whence)
@


1.52
log
@	* fhandler_clipboard.cc (fhandler_dev_clipboard::read): Use
	read-ahead buffer for reading Windows clipboard if caller's
	buffer is too small for complete characters.
	* include/limits.h: Remove outdated TODO comment.
@
text
@d3 2
a4 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009, 2011,
   2012 Red Hat, Inc
d34 1
a34 1
static int cygnativeformat;
d183 1
a183 1
int __stdcall
d217 1
a217 1
void __stdcall
d223 1
a223 1
  int format;
d272 3
a274 3
	  /* If caller's buffer is too small to hold at least one 
	     max-size character, redirect algorithm to local 
	     read-ahead buffer, finally fill class read-ahead buffer 
d296 1
a296 1
		 && (ret > conv_len 
@


1.51
log
@	* fhandler.h (class fhandler_dev_clipboard): Remove member eof.
	* fhandler_clipboard.cc: Throughout remove handling of eof member.
	(fhandler_dev_clipboard::write): Handle EOF condition immediately,
	rather than pushing it erroneously to the next read call.  Rearrange
	code.  Fix bug in CF_UNICODETEXT case which potentially dropped single
	bytes at the end of the buffer.  Add comment.
	* strfuncs.cc (sys_cp_wcstombs): Allow returning non-NUL-terminated
	buffer if dst != NULL and len == (size_t) -1.  Extend leading comment
	to explain what's returned in more detail.
@
text
@d225 1
d247 1
a247 1
      	{
d253 12
d272 14
d289 2
a290 2
	  if (glen > pos + len)
	    glen = pos + len;
d296 3
a298 1
		 && ret > len)
d304 1
a304 1
	      ret = sys_wcstombs ((char *) ptr, (size_t) -1,
d307 13
@


1.51.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d184 1
a184 1
fhandler_dev_clipboard::fstat (struct stat *buf)
d286 2
a287 2
off_t
fhandler_dev_clipboard::lseek (off_t offset, int whence)
@


1.51.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@a224 1
  int rach;
d246 1
a246 1
	{
a251 12
  else if ((rach = get_readahead ()) >= 0)
    {
      /* Deliver from read-ahead buffer. */
      char * out_ptr = (char *) ptr;
      * out_ptr++ = rach;
      ret = 1;
      while (ret < len && (rach = get_readahead ()) >= 0)
	{
	  * out_ptr++ = rach;
	  ret++;
	}
    }
a258 14
	  /* If caller's buffer is too small to hold at least one 
	     max-size character, redirect algorithm to local 
	     read-ahead buffer, finally fill class read-ahead buffer 
	     with result and feed caller from there. */
	  char *conv_ptr = (char *) ptr;
	  size_t conv_len = len;
#define cprabuf_len MB_LEN_MAX	/* max MB_CUR_MAX of all encodings */
	  char cprabuf [cprabuf_len];
	  if (len < cprabuf_len)
	    {
	      conv_ptr = cprabuf;
	      conv_len = cprabuf_len;
	    }

d262 2
a263 2
	  if (glen > pos + conv_len)
	    glen = pos + conv_len;
d269 1
a269 3
		 && (ret > conv_len 
			/* Skip separated high surrogate: */
		     || ((buf [pos + glen - 1] & 0xFC00) == 0xD800 && glen - pos > 1)))
d275 1
a275 1
	      ret = sys_wcstombs ((char *) conv_ptr, (size_t) -1,
a277 13
	      /* If using read-ahead buffer, copy to class read-ahead buffer
	         and deliver first byte. */
	      if (conv_ptr == cprabuf)
		{
		  puts_readahead (cprabuf, ret);
		  char *out_ptr = (char *) ptr;
		  ret = 0;
		  while (ret < len && (rach = get_readahead ()) >= 0)
		    {
		      * out_ptr++ = rach;
		      ret++;
		    }
		}
@


1.51.2.3
log
@	* cygthread.cc: Fix usage of %p in debug printfs, throughout.
	* dcrt0.cc: Ditto.
	* dtable.cc: Ditto.
	* errno.cc: Ditto.
	* exceptions.cc: Ditto.
	* fhandler.cc: Ditto.
	* fhandler_console.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.

	* fhandler_clipboard.cc (cygnativeformat): Define as UINT.
	(fhandler_dev_clipboard::read): Ditto for local format variable.
	Use casts to compare off_t with size_t value.
	* fhandler_console.cc (fhandler_console::ioctl): Avoid compiler
	warnings.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Fix cast.
	* include/sys/dirent.h (struct __DIR): Define __d_internal as uintptr_t,
	rather than unsigned int.

	And pull in changes from HEAD.
@
text
@d34 1
a34 1
static UINT cygnativeformat;
d223 1
a223 1
  UINT format;
d246 1
a246 1
      if (pos < (off_t) clipbuf->len)
d270 1
a270 1
      if (pos < (off_t) glen)
@


1.51.2.4
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009, 2011, 2012, 2013
   Red Hat, Inc
d183 1
a183 1
int __reg2
d217 1
a217 1
void __reg3
d272 3
a274 3
	  /* If caller's buffer is too small to hold at least one
	     max-size character, redirect algorithm to local
	     read-ahead buffer, finally fill class read-ahead buffer
d296 1
a296 1
		 && (ret > conv_len
@


1.51.2.5
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d32 1
a32 1
static const WCHAR *CYGWIN_NATIVE = L"CYGWIN_NATIVE_CLIPBOARD";
@


1.50
log
@	* fhandler.h (class fhandler_dev_clipboard): Add fstat method.
	* fhandler_clipboard.cc (cygcb_t): New type for Cygwin-specific
	clipboard format.
	(set_clipboard): Use new clipboard format to allow setting a timestamp.
	(fhandler_dev_clipboard::fstat): New method.  Read modification and
	access timestamp as well as length from clipboard data.
	(fhandler_dev_clipboard::read): Use new clipboard format.
@
text
@d44 1
a44 2
  : fhandler_base (), pos (0), membuffer (NULL), msize (0),
  eof (true)
a70 1
  eof = false;
d159 4
a162 1
  if (!eof)
d164 6
a169 11
      /* write to our membuffer */
      size_t cursize = msize;
      void *tempbuffer = realloc (membuffer, cursize + len);
      if (!tempbuffer)
	{
	  debug_printf ("Couldn't realloc() clipboard buffer for write");
	  return -1;
	}
      membuffer = tempbuffer;
      msize = cursize + len;
      memcpy ((unsigned char *) membuffer + cursize, buf, len);
d171 2
a172 14
      /* now pass to windows */
      if (set_clipboard (membuffer, msize))
	{
	  /* FIXME: membuffer is now out of sync with pos, but msize
		    is used above */
	  return -1;
	}

      pos = msize;

      eof = false;
      return len;
    }
  else
d174 3
a176 2
      /* FIXME: return 0 bytes written, file not open */
      return 0;
d178 3
d221 1
a221 1
  size_t ret;
d224 1
a224 1
  size_t plen = len;
a225 3
  len = 0;
  if (eof)
    return;
a226 4
    return;
  formatlist[0] = cygnativeformat;
  formatlist[1] = CF_UNICODETEXT;
  if ((format = GetPriorityClipboardFormat (formatlist, 2)) <= 0)
d228 1
a228 1
      CloseClipboard ();
d231 5
a235 1
  if (!(hglb = GetClipboardData (format)))
d238 1
d243 1
a243 1
      cygcb_t *clipbuf;
d245 5
a249 4
      if (!(clipbuf = (cygcb_t *) GlobalLock (hglb)))
	{
	  CloseClipboard ();
	  return;
a250 5
      ret = ((plen > (clipbuf->len - pos)) ? (clipbuf->len - pos) : plen);
      memcpy (ptr, clipbuf->data + pos , ret);
      pos += ret;
      if (pos + plen - ret >= clipbuf->len)
	eof = true;
d254 1
a254 2
      int wret;
      PWCHAR buf;
d256 2
a257 1
      if (!(buf = (PWCHAR) GlobalLock (hglb)))
d259 20
a278 2
	  CloseClipboard ();
	  return;
a279 13
      size_t glen = GlobalSize (hglb) / sizeof (WCHAR) - 1;
      /* This loop is necessary because the number of bytes returned by
	 sys_wcstombs does not indicate the number of wide chars used for
	 it, so we could potentially drop wide chars. */
      if (glen - pos > plen)
	glen = pos + plen;
      while ((wret = sys_wcstombs (NULL, 0, buf + pos, glen - pos)) != -1
	     && (size_t) wret > plen)
	--glen;
      ret = sys_wcstombs ((char *) ptr, plen, buf + pos, glen - pos);
      pos += ret;
      if (pos + plen - ret >= wcslen (buf))
	eof = true;
a305 1
      eof = true;
a321 1
      eof = false;
@


1.49
log
@Throughout use "have_execed" macro rather than "hExeced" global handle.
Throughout rename _PROC_* to _CH_*.
* child_info.h: Include "pinfo.h".
(child_info_types): Rename _PROC_* -> _CH_* to avoid confusion with similarly
named constants.
(_PROC_*): Delete unneeded aliases.
(PROC_*): Ditto.
(CURR_CHILD_INFO_MAGIC): Ditto.
(cchildren): Define using "pinfo_minimal".
(child_info::set_saw_ctrl_c): Move to
(child_info_spawn::set_saw_ctrl_c): Here.
(child_info_spawn::lock): New field.
(child_info_spawn::hExeced): Ditto.
(child_info_spawn::ev): Ditto.
(child_info_spawn::~child_info_spawn): Move to sigproc.cc.
(child_info_spawn::child_info_spawn): Ditto.
(child_info_spawn::cleanup): Declare new function.
(child_info_spawn::set_saw_ctrl_c): Move to this class.  Set flag only when
execed and return true when we have set the flag.
(child_info_spawn::child_info_spawn::signal_myself_exited): New function.
(child_info_spawn::wait_for_myself): Ditto.
(child_info_spawn::has_execed_cygwin): Ditto.
(child_info_spawn::has_execed): Ditto.  Replaces "hExeced" test.
(child_info_spawn::operator HANDLE&): New operator.
(child_info_spawn::worker): Define old "spawn_guts" as class member.
(ch_spawn): Declare.
(have_execed): Define.
(have_execed_cygwin): Ditto.
* cygheap.h: Update comment.
* dcrt0.cc (get_cygwin_startup_info): Use _CH_* enums.
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Ditto.
(multiple_cygwin_problem): Ditto.
* exceptions.cc (chExeced): Delete obsolete declaration.
(ctrl_c_handler): Reference set_saw_ctrl_c via new ch_spawn global.
* globals.cc (hExeced): Delete.
* pinfo.cc (pinfo::thisproc): Refer to cygheap as ::cygheap for consistency in
handle naming when -DDEBUGGING.
(pinfo::init): Accommodate case where myself.h is known but h0 is passed in.
(pinfo::pinfo): New constructor for setting up a pinfo passed in by previous
exec'or.
(pinfo::proc_waiter): Don't handle subprocess if we're in the process of
exiting due to an exec of a cygwin process.  Don't close rd_proc_pipe here.
Close it when we actually are finished with the process.  Use new
ch_spawn.signal_myself_exited function to let exec stub know that subprocess
has exited.
(pinfo::wait): Clarify debugging output.
(pinfo::release): Use "close_h" to close all handles to avoid races.
(winpids::add): Assume that elements of the array do not need to be zeroed and
are properly initialized or suffer problems on pinfo::release.  Don't close
hProcess since release does that now.
* pinfo.h: Update comment.
(pinfo_minimal): Move some elements from pinfo here so that child_info_spawn
can use them.
(pinfo): Inherit from pinfo_minimal.
(pinfo::pinfo): Modify to accommodate new pinfo_minimal.
(pinfo::allow_remove): New function.
* sigproc.cc (proc_subproc): Use boolean values for true/false.  Implement
PROC_EXEC_CLEANUP.
(proc_terminate): Set ppid = 1 since the procs list will only be iterated when
the process has not execed.  Don't do any cleanup here since it is now handled
in pinfo::release.
(sigproc_init): Initialize sync_proc_subproc earlier.
(child_info::child_info): Assume that all important fields are properly
initialized and avoid memset().
(child_info_spawn::child_info_spawn): Specifically test for execing and then
set up appropriate fields in the struct.
(child_info_spawn::cleanup): Define new function.
(child_info_spawn::record_children): Specifically test for being execed here.
Fill in pinfo_minimal part of children array.
(child_info_spawn::reattach_children): Use constructor to duplicate information
for previous exec'or.  Add more debugging output.
(remove_proc): Force deletion of thread when exiting due to exec.  Rely on
pinfo::cleanup in release.
* sigproc.h (PROC_EXEC_CLEANUP): New enum.
(PROC_DETACHED_CHILD): Delete.
* spawn.cc (chExeced): Delete.
(child_info_spawn::worker): Rename from spawn_guts.  Use elements of
child_info_spawn throughout rather than ch.whatever.  Use ::cygheap to refer to
global rather than element of child_info.  Use wait_for_myself() rather than
waitpid().  Call child_info_spawn::cleanup on function return.
(spawnve): Reflect movement of spawn_guts functionality into
child_info_spawn::worker.
* syscalls.cc (popen): Ditto.
* winsup.h (spawn_guts): Delete declaration.
@
text
@d3 2
a4 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009, 2011 Red Hat, Inc
d36 7
a87 1
  void *clipbuf;
d91 3
a93 1
      hmem = GlobalAlloc (GMEM_MOVEABLE, len + sizeof (size_t));
d100 6
a105 3
      clipbuf = GlobalLock (hmem);
      memcpy ((unsigned char *) clipbuf + sizeof (size_t), buf, len);
      *(size_t *) (clipbuf) = len;
d131 2
d140 2
a141 2
      clipbuf = GlobalLock (hmem);
      sys_mbstowcs ((PWCHAR) clipbuf, len + 1, (const char *) buf);
d195 34
d257 1
a257 1
      unsigned char *buf;
d259 1
a259 1
      if (!(buf = (unsigned char *) GlobalLock (hglb)))
d264 2
a265 3
      size_t buflen = (*(size_t *) buf);
      ret = ((plen > (buflen - pos)) ? (buflen - pos) : plen);
      memcpy (ptr, buf + sizeof (size_t)+ pos , ret);
d267 1
a267 1
      if (pos + plen - ret >= buflen)
@


1.48
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d20 4
d270 1
a270 1
  if (!hExeced)
@


1.47
log
@	* fhandler.h (class fhandler_dev_mem): Remove dup method declaration.
	* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Accommodate the
	fact that the entire fhandler gets copied over to the child in
	operator =.
	* fhandler_floppy.cc (fhandler_dev_floppy::dup): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::dup): Ditto.
	* fhandler_serial.cc (fhandler_serial::dup): Ditto.
	* fhandler_socket.cc (fhandler_socket::dup): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::dup): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::dup): Ditto.  Remove entirely.
@
text
@d47 1
a47 1
fhandler_dev_clipboard::dup (fhandler_base * child)
@


1.46
log
@whitespace elimination
@
text
@a52 5

  fhc->membuffer = membuffer;
  fhc->pos = pos;
  fhc->msize = msize;

@


1.45
log
@	Throughout, use user32 UNICODE functions rather than ANSI functions.
	* autoload.cc: Convert all definitions for ANSI user32 functions to
	definitions for the corresponding UNICODE function.
	(SendMessageA): Remove.
	(SendNotifyMessageW): Define.
	* fhandler_windows.cc (fhandler_windows::write): Use SendNotifyMessageW
	call rather than SendMessage to make function always return immediately.
	(fhandler_windows::read): Make function interruptible and a cancellation
	point.  Handle O_NONBLOCK.
	* select.cc (peek_serial): Don't wait for signal_arrived here.
	* window.cc (wininfo::winthread): Call CreateWindowExW directly rather
	than CreateWindow wrapper.
@
text
@d102 1
a102 1
         data to the clipboard via SetClipboardData. */
d133 1
a133 1
         data to the clipboard via SetClipboardData. */
d166 1
a166 1
	            is used above */
@


1.44
log
@* sigproc.h (wait_for_sigthread): Eliminate parameter.
* sigproc.cc (wait_for_sigthread): Ditto.  Don't synchronize with wait_sig
after receiving an event that it is ready to go.
(init_sig_pipe): New function.
(wait_sig): Call init_sig_pipe to create pipes for communicating signals to
this process.  Don't send sigCONT signal when initializing.
* fork.cc (frok::child): Accommodate wait_for_sigpipe parameter change.
* fhandler.h (fhandler_*::write): Make ssize_t/__stdcall.
(fhandler_*::write_overlapped): Ditto.
(fhandler_*::raw_write): Ditto.
(fhandler_*::readv): Ditto.
(fhandler_*::writev): Ditto.
(fhandler_*::raw_read): Make __stdcall.
* fhandler: Accommodate changes to read/write functions throughout.
* fhandler_clipboard.cc: Ditto.
* fhandler_console.cc: Ditto.
* fhandler_dsp.cc: Ditto.
* fhandler_fifo.cc: Ditto.
* fhandler_mailslot.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_random.cc: Ditto.
* fhandler_tape.cc: Ditto.
* fhandler_tty.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_windows.cc: Ditto.
* fhandler_zero.cc: Ditto.
* syscalls.cc (readv): Use ssize_t as temp variable.
* fhandler.cc (fhandler_base::read): Coerce returned len to signed or it will
never be treated as < 0.
(fhandler_base::wait_overlapped): Minimize calls to GetLastError.  Remove
duplicate debugging test.  Fix error return.
* fhandler.h (fhandler_fifo::fifo_name): Declare new function.
(fhandler_fifo::close): Ditto.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
* fhandler.cc (fhandler_fifo::fifo_name): Define new function.
(FIFO_BUF_SIZE): New define.
(cnp): Ditto.
(fhandler_fifo::open): Rework.  Use cnp to open named pipe.  Always open write
side as a client.  Open dummy client when writing and can't connect.
(wait): Rework.  Implement fifo_wait_for_next_client.  Handle signals during
connect better.  Add new fifo_wait_for_server code which polls
(sigh) waiting for server.
(fhandler_fifo::raw_read): Handle transition states when one client closes and
another is available.
(fhandler_fifo::close): Define.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
@
text
@d3 1
a3 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
   Red Hat, Inc
d27 1
a27 1
static const NO_COPY char *CYGWIN_NATIVE = "CYGWIN_NATIVE_CLIPBOARD";
d37 1
a37 1
  cygnativeformat = RegisterClipboardFormat (CYGWIN_NATIVE);
d71 1
a71 1
    cygnativeformat = RegisterClipboardFormat (CYGWIN_NATIVE);
d98 1
a98 1
	cygnativeformat = RegisterClipboardFormat (CYGWIN_NATIVE);
@


1.43
log
@* select.h: New file split from fhandler.h.
(select_record::select_record): Define do-nothing constructor for "new" to
avoid gratuitous zeroing.
(select_info): New base class.
(select_pipe_info): New class with methods for dealing with pipes.
(select_socket_info): New class with methods for dealing with sockets.
(select_serial_info): Dummy class for serial.
(select_mailslot_info): Dummy class for mailslots.
(select_stuff): Define device_specific_* as actual classes rather than void *.
* dtable.h (dtable::select_read): Accommodate return value change to 'bool' and
argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* dtable.cc (dtable::select_read): Accommodate return value change to 'bool'
and argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* fhandler.h: Excise select-related classes.
(fhandler_*::select_read): Change argument to select_stuff.
(fhandler_*::select_write): Ditto.
(fhandler_*::select_except): Ditto.
* select.cc (UNIX_FD_ZERO): Use memset rather than bzero.
(select_stuff::test_and_set): Change return type to bool.  Allocate
select_record on entry and let fhandler_*::select_* operate on the start.next
field of select_stuff.
(pipeinf): Delete.
(select_pipe_info::select_pipe_info): New constructor.  Allocates event for
controlling pipe waits.
(select_pipe_info::~select_pipe_info): New destructor.  Destroy event.  Stop
thread.
(select_pipe_info::add_watch_handle): New function.
(thread_pipe): Wait for the hEvent part of any overlapped pipes before peeking.
(start_thread_pipe): Don't allocate device_specific_pipe stuff here.  Assume
that it has been allocated earlier.
(pipe_cleanup): Rely on select_pipe_info destructor to clean up pipe
paraphenalia.
(fhandler_*::select_*): Derive select_record from new select_stuff argument.
(fhandler_pipe::select_*): Ditto.  Allocate pipe-specific field if not already
allocated.
(serialinf): Delete.
(thread_serial): serialinf -> select_serial_info.
(fhandler_base::ready_for_read): Rewrite to accommodate change in argument to
fhandler_*::select_*.
(socketinf): Delete.
(thread_socket): socketinf -> select_socket_info.
(mailslotinf): Delete.
(thread_mailslot): mailslotinf -> select_mailslot_info.
@
text
@d146 1
a146 1
int
@


1.42
log
@	* fhandler_clipboard.cc: Avoid calling system_printf.
	(set_clipboard): Add basic error checking.  Set errno here.  Per MSDN,
	don't call GlobalFree on data block transferred to clipboard.
	(fhandler_dev_clipboard::write): Drop setting errno after call to
	set_clipboard.
	(fhandler_dev_clipboard::read): Add basic error checking. Simplify code.
@
text
@d212 1
a212 1
      
@


1.41
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d84 1
a84 3
  OpenClipboard (0);
  hmem = GlobalAlloc (GMEM_MOVEABLE, len + sizeof (size_t));
  if (!hmem)
d86 24
a109 25
      system_printf ("Couldn't allocate global buffer for write");
      return -1;
    }
  clipbuf = GlobalLock (hmem);
  memcpy ((unsigned char *) clipbuf + sizeof (size_t), buf, len);
  *(size_t *) (clipbuf) = len;
  GlobalUnlock (hmem);
  EmptyClipboard ();
  if (!cygnativeformat)
    cygnativeformat = RegisterClipboardFormat (CYGWIN_NATIVE);
  if (!SetClipboardData (cygnativeformat, hmem))
    {
      system_printf
	("Couldn't write native format to the clipboard %04x %x",
	 cygnativeformat, hmem);
/* FIXME: return an appriate error code &| set_errno(); */
      return -1;
    }
  CloseClipboard ();
  if (GlobalFree (hmem))
    {
      system_printf
	("Couldn't free global buffer after write to the clipboard");
/* FIXME: return an appriate error code &| set_errno(); */
      return 0;
a112 3

  OpenClipboard (0);

d116 1
a116 1
      system_printf ("Invalid string");
d119 1
a119 2
  hmem = GlobalAlloc (GMEM_MOVEABLE, (len + 1) * sizeof (WCHAR));
  if (!hmem)
d121 20
a140 19
      system_printf ("Couldn't allocate global buffer for write");
      return -1;
    }
  clipbuf = GlobalLock (hmem);
  sys_mbstowcs ((PWCHAR) clipbuf, len, (const char *) buf);
  *((PWCHAR) clipbuf + len) = L'\0';
  GlobalUnlock (hmem);
  if (!SetClipboardData (CF_UNICODETEXT, hmem))
    {
      system_printf ("Couldn't write to the clipboard");
/* FIXME: return an appriate error code &| set_errno(); */
      return -1;
    }
  CloseClipboard ();
  if (GlobalFree (hmem))
    {
      system_printf
	("Couldn't free global buffer after write to the clipboard");
/* FIXME: return an appriate error code &| set_errno(); */
d156 1
a156 1
	  system_printf ("Couldn't realloc() clipboard buffer for write");
d166 2
a167 2
	  /* FIXME: membuffer is now out of sync with pos, but msize is used above */
	  set_errno (ENOSPC);
d190 3
d194 31
a224 1
    len = 0;
d227 4
a230 4
      formatlist[0] = cygnativeformat;
      formatlist[1] = CF_UNICODETEXT;
      OpenClipboard (0);
      if ((format = GetPriorityClipboardFormat (formatlist, 2)) <= 0)
d233 1
a233 44
#if 0
	  system_printf ("a non-accepted format! %d", format);
#endif
	  len = 0;
	}
      else
	{
	  hglb = GetClipboardData (format);
	  if (format == cygnativeformat)
	    {
	      unsigned char *buf = (unsigned char *) GlobalLock (hglb);
	      size_t buflen = (*(size_t *) buf);
	      ret = ((len > (buflen - pos)) ? (buflen - pos) : len);
	      memcpy (ptr, buf + sizeof (size_t)+ pos , ret);
	      pos += ret;
	      if (pos + len - ret >= buflen)
		eof = true;
	      GlobalUnlock (hglb);
	    }
	  else
	    {
	      int wret;
	      PWCHAR buf;
	      buf = (PWCHAR) GlobalLock (hglb);
	      size_t glen = GlobalSize (hglb) / sizeof (WCHAR) - 1;

	      /* This loop is necessary because the number of bytes returned
		 by WideCharToMultiByte does not indicate the number of wide
		 chars used for it, so we could potentially drop wide chars. */
	      if (glen - pos > len)
	        glen = pos + len;
	      while ((wret = sys_wcstombs (NULL, 0, buf + pos, glen - pos))
		      != -1
		     && (size_t) wret > len)
	      	--glen;
	      ret = sys_wcstombs ((char *) ptr, len, buf + pos, glen - pos);
	      //ret = snprintf((char *) ptr, len, "%s", buf);//+pos);
	      pos += ret;
	      if (pos + len - ret >= wcslen (buf))
		eof = true;
	      GlobalUnlock (hglb);
	    }
	  CloseClipboard ();
	  len = ret;
d235 13
d249 3
@


1.40
log
@Remove unneeded header files from source files throughout.
@
text
@d3 2
a4 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2008 Red Hat, Inc
a14 1
#include <stdlib.h>
a18 1
#include "security.h"
@


1.39
log
@	* Fix copyright dates.
@
text
@a13 1
#include <stdio.h>
a14 1
#include <unistd.h>
a15 2
#include <windows.h>
#include <winnls.h>
@


1.38
log
@	* dcrt0.cc (initial_env): Only use local buffer "buf" if DEBUGGING is
	enabled.  Replace calls to GetEnvironmentVariable by calls to
	GetEnvironmentVariableA for clarity.  Call GetEnvironmentVariableA
	with NULL buffer.
	(cygbench): Ditto, drop local buffer.
	* environ.cc (getearly): Call GetEnvironmentVariableA.
	(environ_init): Retrieve unicode environment and convert to current
	codepage locally.
	(getwinenveq): Ditto.
	* exceptions.cc (try_to_debug): Accommodate new sys_mbstowcs calling
	convention.
	* fhandler_clipboard.cc (set_clipboard): Call sys_mbstowcs to retrieve
	required buffer length.
	* fork.cc (frok::child): Call GetEnvironmentVariableA.
	* miscfuncs.cc: Accommodate changed arguments in calls to sys_mbstowcs.
	* sec_auth.cc: Ditto.
	* strfuncs.cc (sys_wcstombs_alloc): Fix formatting.
	(sys_mbstowcs): Change arguments to allow specifying a source string
	length.
	(sys_mbstowcs_alloc): Ditto.
	* uinfo.cc (cygheap_user::ontherange): Accommodate changed arguments in
	calls to sys_mbstowcs.
	* winsup.h (sys_mbstowcs): Adjust declaration.
	(sys_mbstowcs_alloc): Ditto.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc
@


1.37
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d124 1
a124 1
  len = MultiByteToWideChar (get_cp (), 0, (const char *) buf, len, NULL, 0);
d137 1
a137 1
  sys_mbstowcs ((PWCHAR) clipbuf, (const char *) buf, len);
@


1.36
log
@	* dcrt0.cc (dll_crt0_1): Use GetCommandLineW and convert to current
	codepage.
	* environ.cc (set_file_api_mode): Always set file api to ANSI if not
	using the OEM codepage.
	(codepage_init): Allow "utf8" codepage.
	* fhandler_clipboard.cc (set_clipboard): Convert clipbuf to void and
	cast as needed.  Always convert input to wide char and write
	CF_UNICODETEXT to clipboard.
	(fhandler_dev_clipboard::read): Read CF_UNICODETEXT from clipboard and
	convert to current codepage if CYGWIN_NATIVE format is not available.
	* fhandler_console.cc: Drop redundant undef.
	* smallprint.cc (__small_vsprintf): Convert PWCHAR and UNICODE_STRING
	to current codepage for printing.
	* strfuncs.cc: Use PWCHAR throughout.
	(get_cp): Return CP_UTF8 for utf8_cp codepage setting.
	(sys_wcstombs): Allow NULL target buffer.
	(sys_wcstombs_alloc): New function.
	(sys_mbstowcs_alloc): Ditto.
	* winsup.h (codepage_type): Add utf8_cp.
	(HEAP_NOTHEAP): Define.
	(sys_wcstombs_alloc): Declare.
	(sys_mbstowcs_alloc): Declare.
@
text
@d236 1
a236 1
	      
@


1.35
log
@* cygheap.h (init_cygheap::manage_console_count): Declare new function.
(init_cygheap::console_count): Renamed from open_fhs.  Make private.
* cygheap.cc (init_cygheap::manage_console_count): Define new function.
* dtable.cc (dtable::fixup_after_exec): Always call fixup_after_exec on
elements of fd even when they are about to be closed.
* fhandler.h (report_tty_counts): Remove open_fhs from debugging output.
* fhandler_console.cc (fhandler_console::open): Use manage_console_count rather
than manipulating count directly.
(fhandler_console::close): Ditto.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.  Don't close handles if
close_on_exec.
* fhandler_tty.cc (fhandler_tty_slave::open): Use manage_console_count() rather
than manipulating count directly.  Reflect change in arguments to
report_tty_counts().
(fhandler_tty_slave::close): Ditto for both.
(fhandler_tty_slave::dup): Ditto for both.
(fhandler_tty_slave::ioctl): Use myctty() rather than raw ctty #.
(fhandler_tty_slave::fixup_after_fork): Reflect change in arguments to
report_tty_counts().
(fhandler_tty_master::init_console): Use manage_console_count() rather than
manipulating count directly.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fixup_after_exec): Don't
perform any operations if close_on_exec.
* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fixup_after_exec): Ditto.
* fhandler_serial.cc (fhandler_serial::fixup_after_exec): Ditto.
* pinfo.h (_pinfo::_ctty): Declare new function.
(myctty): Declare new macro.
(__ctty): Declare new macro.
* pinfo.cc (_pinfo::_ctty): Define new function.
(_pinfo::set_ctty): Use manage_console_count() rather than manipulating count
directly.
* signal.cc (kill_pgrp): Use myctty() and __ctty() macros rather than raw ctty
#.
* syscalls.cc (setsid): Ditto.  Use manage_console_count() rather than
manipulating count directly.
@
text
@d17 1
d19 1
d87 1
a87 1
  unsigned char *clipbuf;
d96 2
a97 2
  clipbuf = (unsigned char *) GlobalLock (hmem);
  memcpy (clipbuf + sizeof (size_t), buf, len);
d123 8
a130 1
  hmem = GlobalAlloc (GMEM_MOVEABLE, len + 2);
d136 3
a138 4
  clipbuf = (unsigned char *) GlobalLock (hmem);
  memcpy (clipbuf, buf, len);
  *(clipbuf + len) = '\0';
  *(clipbuf + len + 1) = '\0';
d140 1
a140 2
  if (!SetClipboardData
      ((current_codepage == ansi_cp ? CF_TEXT : CF_OEMTEXT), hmem))
d206 1
a206 1
      formatlist[1] = current_codepage == ansi_cp ? CF_TEXT : CF_OEMTEXT;
d232 16
a247 8
	      LPSTR lpstr;
	      lpstr = (LPSTR) GlobalLock (hglb);

	      ret = ((len > (strlen (lpstr) - pos)) ? (strlen (lpstr) - pos)
		     : len);

	      memcpy (ptr, lpstr + pos, ret);
	      //ret = snprintf((char *) ptr, len, "%s", lpstr);//+pos);
d249 1
a249 1
	      if (pos + len - ret >= strlen (lpstr))
@


1.34
log
@	Revert erroneous checkin.
@
text
@d279 6
a284 3
  eof = false;
  pos = msize = 0;
  membuffer = NULL;
@


1.33
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d51 1
a51 1
fhandler_dev_clipboard::dup (fhandler_base * child, HANDLE from_proc)
@


1.32
log
@* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Set membuffer to NULL.
(fhandler_dev_clipboard::fixup_after_exec): Don't call close here.  Just set
variables directly.
@
text
@d51 1
a51 1
fhandler_dev_clipboard::dup (fhandler_base * child)
@


1.31
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d267 4
a270 1
	free (membuffer);
d279 3
a281 1
  close ();
@


1.30
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d276 1
a276 1
  (void) close ();
@


1.29
log
@* wininfo.h (wininfo::timer_active): Delete.
(wininfo::itv): Ditto.
(wininfo::start_time): Ditto.
(wininfo::window_started): Ditto.
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(wininfo::wininfo): Ditto.
(wininfo::lock): New method.
(wininfo::release): Ditto.
* window.cc: Use new lock/acquire wininfo methods throughout.
(wininfo::wininfo): Delete
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(getitimer): Ditto.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
(wininfo::lock): Define new function.
(wininfo::release): Ditto.
(wininfo::process): Delete WM_TIMER handling.
* timer.cc (struct timetracker): Delete it, flags.  Add it_interval,
interval_us, sleepto_us, running, init_muto(), syncthread, and gettime().
(ttstart): Make NO_COPY.
(lock_timer_tracker): New class.
(timer_tracker::timer_tracker): Distinguish ttstart case.
(timer_tracker::~timer_tracker): New destructor.  Clean out events, and reset
magic.
(timer_tracker::init_muto): New method.
(to_us): Round up as per POSIX.
(timer_thread): Reorganize to match timer_tracker::settime and
timer_tracker::gettime.  Call sig_send without wait.  Call auto_release.
(timer_tracker::settime): Reorganize logic to avoid race.  Call gettime to
recover old value.
(timer_tracker::gettime): New method.
(timer_create): Properly set errno on invalid timerid.  Use new
lock_timer_tracker method.
(timer_delete): Ditto.  Simplify code slightly.
(timer_gettime): New function.
(fixup_timers_after_fork): Reinit ttstart.
(getitimer): New implementation.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
* cygwin.din: Export timer_gettime.
* winsup.h: Remove has has_visible_window_station declaration.
* Makefile.in (DLL_OFILES): Add lsearch.o.
* cygthread.h (cygthread::notify_detached): New element.
(cygthread::cygthread): Take optional fourth argument signifying event to
signal on thread completion.
* cygthread.cc (cygthread::stub): Signal notify_detached event, if it exists.
(cygthread::cygthread): Initialize notify_detached from fourth argument.
(cygthread::detach): Wait for notify_detached field is present.
* lsearch.cc: New file.
* search.h: Ditto.
* include/cygwin/version.h: Bump API minor number to 126.
* cygwin.din: Export lsearch, lfind.
@
text
@d260 1
a260 1
fhandler_dev_clipboard::close (void)
d262 8
a269 5
  eof = true;
  pos = 0;
  if (membuffer)
    free (membuffer);
  msize = 0;
d274 1
a274 1
fhandler_dev_clipboard::dump ()
d276 1
a276 1
  paranoid_printf ("here, fhandler_dev_clipboard");
@


1.28
log
@* fhandler_clipboard.cc: Use int for cygnativeformat rather than UINT as that
is what is returned by GetPriorityClipboardFormat.
(fhandler_dev_clipboard::read): Ditto for the format variable.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004 Red Hat, Inc
@


1.27
log
@	* fhandler_clipboard.cc (fhandler_dev_clipboard::write): Never set
	errno to 0.
	(fhandler_dev_clipboard::read): Ditto.
	* fhandler_windows.cc (fhandler_windows::read): Ditto.
	* scandir.cc (scandir): Ditto.
	* syscalls.cc (_fstat64_r): Ditto.
	(_fstat_r): Ditto.
	(_stat64_r): Ditto.
	(_stat_r): Ditto.

	* mmap.cc (mmap64): Fix /dev/zero mapping.
@
text
@d33 1
a33 1
static UINT cygnativeformat;
d193 1
a193 1
  UINT format;
@


1.26
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@a176 1
      set_errno (0);
a206 1
	  set_errno (0);
a238 1
	  set_errno (0);
@


1.25
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d76 1
a76 1
  set_nohandle (true);
@


1.24
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003 Red Hat, Inc
@


1.23
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Red Hat, Inc
d22 1
d36 1
a36 1
  : fhandler_base (FH_CLIPBOARD), pos (0), membuffer (NULL), msize (0),
d55 1
a55 1
  if (!fhc->open (NULL, get_flags (), 0))
d66 1
a66 1
fhandler_dev_clipboard::open (path_conv *, int flags, mode_t)
@


1.22
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@a15 1
#include <errno.h>
@


1.21
log
@Throughout, change fhandler_*::read and fhandler_*::raw_read to void functions
whose second arguments are both the lenght and the return value.
* fhandler.cc (fhandler_base::read): Rework slightly to use second argument as
input/output.  Tweak CRLF stuff.
(fhandler_base::readv): Accommodate fhandler_*::read changes.
* cygthread.h (cygthread::detach): Declare as taking optional handle argument.
(cygthread::detach): When given a handle argument, wait for the handle to be
signalled before waiting for thread to detach.  Return true when signal
detected.
@
text
@d247 2
a248 2
__off64_t
fhandler_dev_clipboard::lseek (__off64_t offset, int whence)
@


1.21.6.1
log
@merge from trunk
@
text
@d36 1
a36 1
  : fhandler_base (), pos (0), membuffer (NULL), msize (0),
@


1.21.6.2
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003 Red Hat, Inc
a22 1
#include "path.h"
d55 1
a55 1
  if (!fhc->open (get_flags (), 0))
d66 1
a66 1
fhandler_dev_clipboard::open (int flags, mode_t)
@


1.21.6.3
log
@merge from trunk
@
text
@d248 2
a249 2
_off64_t
fhandler_dev_clipboard::lseek (_off64_t offset, int whence)
@


1.21.6.4
log
@merge from trunk
@
text
@d16 1
@


1.21.4.1
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d36 1
a36 1
  : fhandler_base (), pos (0), membuffer (NULL), msize (0),
@


1.20
log
@Remove \n from calls to strace class printfs throughout.
@
text
@d188 2
a189 2
int __stdcall
fhandler_dev_clipboard::read (void *ptr, size_t len)
d195 3
a197 1
  if (!eof)
d202 10
a211 1
      if ((format = GetPriorityClipboardFormat (formatlist, 2)) > 0)
d230 2
a231 3
	      ret =
		((len > (strlen (lpstr) - pos)) ? (strlen (lpstr) - pos) :
		 len);
d242 1
a242 1
	  return ret;
a243 13
      else
	{
	  CloseClipboard ();
#if 0
	  system_printf ("a non-accepted format! %d", format);
#endif
	  set_errno (0);
	  return 0;
	}
    }
  else
    {
      return 0;
@


1.19
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@d91 1
a91 1
      system_printf ("Couldn't allocate global buffer for write\n");
d104 1
a104 1
	("Couldn't write native format to the clipboard %04x %x\n",
d113 1
a113 1
	("Couldn't free global buffer after write to the clipboard\n");
d124 1
a124 1
      system_printf ("Couldn't allocate global buffer for write\n");
d135 1
a135 1
      system_printf ("Couldn't write to the clipboard\n");
d143 1
a143 1
	("Couldn't free global buffer after write to the clipboard\n");
d160 1
a160 1
	  system_printf ("Couldn't realloc() clipboard buffer for write\n");
d238 1
a238 1
	  system_printf ("a non-accepted format! %d\n", format);
@


1.18
log
@* fhandler_clipboard.c (fhandler_dev_clipboard::open): Force text mode.
* fhandler_console.cc (fhandler_console::open): *Really* force binary mode
rather than make it optional.
* fhandler_proc.cc (fhandler_proc::open): Ditto.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (set_flags): Add more debugging.
@
text
@d76 1
@


1.17
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d68 1
a68 1
  set_flags (flags, O_TEXT);
@


1.16
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@d68 1
a68 1
  set_flags (flags);
@


1.15
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@d249 2
a250 2
__off32_t
fhandler_dev_clipboard::lseek (__off32_t offset, int whence)
@


1.14
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Red Hat, Inc
@


1.13
log
@Ensure that all fhandler_*::read definitions are __stdcall throughout.
* fhandler.cc (fhandler_base::set_inheritance): Be more defensive in debugging
code.
* fhandler.h: Adjust regparms throughout to reflect passing 'this' parameter.
* fhandler_console.cc (fhandler_console::read): Remove unneeded test.  Only
honor "key down" events.
* miscfuncs.cc (strcasestr): Reorganize for efficient code use.
(check_null_empty_str_errno): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
* syscalls.cc (_read): Return 0 when length == 0, as per Single UNIX
Specification.
@
text
@d249 2
a250 2
off_t
fhandler_dev_clipboard::lseek (off_t offset, int whence)
@


1.12
log
@Remove 'cb' parameter and modify fhandler_* constructors throughout.
* dtable.cc (dtable::build_fhandler): Remove debugging output which uses 'cb'.
* exec.cc (execvp): New function.
(execvpe): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Use constructor initialization.
* fhandler.h (fhandler_tty_common::fhandler_tty_common): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Ditto.
* fhandler_console.cc (fhandler_console::fhandler_console): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Ditto.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Ditto.
(fhandler_tty_slave::fhandler_tty_slave): Ditto.
(fhandler_pty_master::fhandler_pty_master): Ditto.
* fhandler_windows.cc (fhandler_windows::fhandler_windows): Ditto.
@
text
@d187 1
a187 1
int
@


1.11
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@d35 3
a37 2
fhandler_dev_clipboard::fhandler_dev_clipboard ():
fhandler_base (FH_CLIPBOARD)
a38 5
  set_cb (sizeof *this);
  eof = true;
  pos = 0;
  membuffer = NULL;
  msize = 0;
@


1.10
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@d35 2
a36 2
fhandler_dev_clipboard::fhandler_dev_clipboard (const char *name):
fhandler_base (FH_CLIPBOARD, name)
@


1.9
log
@Move appropriate variables to NO_COPY segment, throughout.
@
text
@d59 1
a59 1
  if (!fhc->open (get_name (), get_flags (), 0))
d70 1
a70 1
fhandler_dev_clipboard::open (const char *, int flags, mode_t)
@


1.9.4.1
log
@Merged changes from HEAD
@
text
@d35 2
a36 3
fhandler_dev_clipboard::fhandler_dev_clipboard ()
  : fhandler_base (FH_CLIPBOARD), pos (0), membuffer (NULL), msize (0),
  eof (true)
d38 5
d59 1
a59 1
  if (!fhc->open (NULL, get_flags (), 0))
d70 1
a70 1
fhandler_dev_clipboard::open (path_conv *, int flags, mode_t)
d191 1
a191 1
int __stdcall
@


1.9.4.2
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Red Hat, Inc
d249 2
a250 2
__off64_t
fhandler_dev_clipboard::lseek (__off64_t offset, int whence)
@


1.9.4.3
log
@Merged changes from HEAD
@
text
@d68 1
a68 1
  set_flags (flags, O_TEXT);
@


1.9.4.4
log
@Merged changes from HEAD
@
text
@d68 1
a68 1
  set_flags (flags | O_TEXT);
@


1.9.4.5
log
@Merged changes from HEAD
@
text
@a75 1
  set_nohandle (true);
@


1.8
log
@Remove initialization of static or global values to zero, throughout.  This
just needlessly grows the size of the DLL.
* tty.cc (tty::alive): Make inuse handle non-inheriting on open, just for
thread safety.
@
text
@d31 1
a31 1
static const char *CYGWIN_NATIVE = "CYGWIN_NATIVE_CLIPBOARD";
@


1.7
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d33 1
a33 1
static UINT cygnativeformat = 0;
@


1.6
log
@forced commit
@
text
@a17 2
#include "cygerrno.h"
#include "fhandler.h"
d21 3
@


1.5
log
@Remove trailing underscore from fhandler_base and friends, throughout.
* fhandler.h (fhandler_base::set_open_status): New method.  Stores original
open status.
(fhandler_base::get_open_status): New method.  Retrieves original open status.
(fhandler_base::reset_to_open_binmode): New method.
* fhandler.cc (fhandler_base::open): Save open status.
(fhandler_base::init): Ditto.
* fhandler_clipboard.cc (fhandler_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
* fhandler_dsp.cc (fhandler_dsp::open): Ditto.
* fhandler_dev_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_dev_random.cc (fhandler_dev_random::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tty_slave.cc (fhandler_tty_slave::open): Ditto.
* fhandler_tty_master.cc (fhandler_tty_master::open): Ditto.
* fhandler_dev_zero.cc (fhandler_dev_zero::open): Ditto.
* syscalls.cc (setmode): Rework so that 0 mode value causes reversion to open
state.
* fhandler_tty_slave.cc (fhandler_tty_slave::read): Use correct multiplier when
converting from deciseconds to milliseconds.
@
text
@@


1.4
log
@* fhandler.h (fhandler_dev_clipboard): Extend to support writing.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Initialize new fields.  Open clipboard here.
(fhandler_dev_clipboard::dup): New method.
(fhandler_dev_clipboard::open): Accomodate new fields.  Register clipboard
here, if appropriate.
(set_clipboard): New function.  Moves buffer to clipboard.
(fhandler_dev_clipboard::write): Truly implement clipboard writing.
(fhandler_dev_clipboard::read): Reimplement to allow successive reads.
(fhandler_dev_clipboard::lseek): Truly implement seeks in clipboard.
(fhandler_dev_clipboard::close): Clear out new fields.  Support sequential
reads and sequential writes.  Support for binary data via a native clipboard
format.
@
text
@d79 1
@


1.3
log
@* autoload.cc: Autoload CharToOemA.
* dcrt0.cc (dll_crt0_1): Translate command line to OEM if current codepage is
OEM.
* environ.cc: Add new option 'codepage' to CYGWIN environment variable.
* fhandler_clipboard.cc (fhandler_clipboard::read): Read clipboard in OEM mode
if current codepage is OEM.
* fhandler_console.cc (fhandler_console::read): Only translate console input if
current codepage is ANSI.
* fhandler_console.cc (fhandler_console::write_normal): Translate output data
if current codepage is ANSI.
* pinfo.cc (codepage_init): New function.  Setup current codepage from CYGWIN
environment variable and set codepage for file APIs.
* security.cc (read_sd): Translate file name to it if current codepage is OEM.
* winsup.h: (sys_wcstombs,sys_mbstowcs): Use current codepage for translations
between multibyte and widechar string and vice versa.
@
text
@d3 1
a3 1
   Copyright 2000 Red Hat, Inc
d15 1
d17 1
d24 9
a32 1
static BOOL clipboard_eof; // NOT THREAD-SAFE
d34 2
a35 2
fhandler_dev_clipboard::fhandler_dev_clipboard (const char *name)
  : fhandler_base (FH_CLIPBOARD, name)
d38 28
a65 1
  clipboard_eof = false;
d72 7
a78 1
  clipboard_eof = false;
d82 69
d152 1
a152 1
fhandler_dev_clipboard::write (const void *, size_t len)
d154 33
a186 1
  return len;
d193 4
a196 4
  LPSTR lpstr;
  int ret;

  if (!clipboard_eof)
d198 46
a243 17
      OpenClipboard(0);
      hglb = GetClipboardData((current_codepage==ansi_cp ? CF_TEXT : CF_OEMTEXT));
      lpstr = (LPSTR) GlobalLock(hglb);
      if (len < sizeof (lpstr))
        {
          set_errno (EINVAL);
          GlobalUnlock (hglb);
          CloseClipboard ();
          return -1;
        }

      ret = snprintf((char *) ptr, len, "%s", lpstr);
      GlobalUnlock(hglb);
      CloseClipboard();
      set_errno (0);
      clipboard_eof = true;
      return ret;
d254 9
d269 5
a273 1
  clipboard_eof = false;
d280 1
a280 1
  paranoid_printf("here, fhandler_dev_clipboard");
@


1.2
log
@Whitespace cleanup.

* configure.in: Eliminate subdir stuff.
* configure: Regenerate.
* include/getopt.h (option): Make name field 'const'.
@
text
@d55 1
a55 1
      hglb = GetClipboardData(CF_TEXT);
@


1.1
log
@* fhandler_clipboard.cc: new file
* Makefile.in: include fhandler_clipboard.o in DLL_OFILES list.
* fhandler.h: add FH_CLIPBOARD to the devices enum.
(fhandler_dev_clipboard): new
* path.cc (windows_device_names): add "\\dev\\clipboard"
(get_device_number): check for "clipboard"
* dcrt0.cc: declare a few more functions from winuser.h
* dtable.cc (dtable::build_fhandler): check for FH_CLIPBOARD in
switch().
@
text
@d51 1
a51 1
 
@

